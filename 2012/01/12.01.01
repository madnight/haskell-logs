00:35:36 <hoqhuuep> I've noticed "xs" used as an identifier in several examples (usually as a parameter which is a list). Is this intended to be the plural of "x" or does it have some other meaning?
00:35:54 <ddarius> The former.
00:36:18 <hoqhuuep> Alrighty, cheers.
00:45:35 <etpace> Hmm.. Does anyone know how one compiles a recursive let expression? Is the let expression lifted to a semantically equivalent top level expression and compiled from there?
00:54:22 <vikramverma> ddarius: If you're decomposing list parameters in this way, what identifier would you use when you're taking the head more than once? "(x:y:z:?)"?
01:05:11 <hoqhuuep> In a python shell I can type "help(math.sqrt)" to get the documentation for that function. Is there a similar function in GHCi?
01:09:04 <sylecn> I think "docstring" is not part of haskell spec. if there was, it should be mentioned in those tutorials. but in GHCi, the type system can tell you some information about the function, use :t funcName
01:10:06 <sylecn> for more information, use hoggle or hayoo
01:10:21 <sylecn> s/hoggle/hoogle/
01:13:29 <hoqhuuep> I thought that must be a typo... Until I googled hoogle... Seems to be exactly what I needed, thanks!
01:13:41 <hoqhuuep> sylecn++
01:13:52 <azaq23> @hoogle a -> a
01:13:52 <lambdabot> Prelude id :: a -> a
01:13:52 <lambdabot> Data.Function id :: a -> a
01:13:52 <lambdabot> GHC.Exts breakpoint :: a -> a
01:22:21 <bss03> @hoogle (a -> b) -> (c -> d) -> (Either a c -> Either b d)
01:22:21 <lambdabot> No results found
01:22:28 <bss03> @djinn (a -> b) -> (c -> d) -> (Either a c -> Either b d)
01:22:28 <lambdabot> f a b c =
01:22:29 <lambdabot>     case c of
01:22:29 <lambdabot>     Left d -> Left (a d)
01:22:29 <lambdabot>     Right e -> Right (b e)
01:22:49 <bss03> @src (+++)
01:22:50 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:22:54 <bss03> :t (+++)
01:22:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
01:23:49 <bss03> :t (+++) `asTypeOf` (undefined :: (a -> b) -> (c -> d) -> (Either a c -> Either b d)
01:23:50 <lambdabot> parse error (possibly incorrect indentation)
01:23:55 <bss03> :t (+++) `asTypeOf` (undefined :: (a -> b) -> (c -> d) -> (Either a c -> Either b d))
01:23:55 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> Either b b' -> Either c c'
01:24:11 <bss03> @hoogle (+++)
01:24:11 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
01:24:11 <lambdabot> Text.ParserCombinators.ReadPrec (+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
01:24:11 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
01:24:42 <bss03> @hoogle (b -> c) -> (b' -> c') -> Either b b' -> Either c c')
01:24:42 <lambdabot> Parse error:
01:24:42 <lambdabot>   (b -> c) -> (b' -> c') -> Either b b' -> Either c c')
01:24:42 <lambdabot>                                                       ^
01:24:46 <bss03> @hoogle (b -> c) -> (b' -> c') -> Either b b' -> Either c c'
01:24:46 <lambdabot> No results found
01:25:07 <bss03> :( hoogle doesn't know about instances. :(
01:25:22 <ddarius> etpace: That would just move the problem around and require lambda lifting.
01:46:06 <bss03> :t \f g -> flip $ either (flip f) (const g)
01:46:06 <lambdabot> forall a b a1 b1. (a -> a1 -> b) -> (a -> b) -> a -> Either a1 b1 -> b
01:47:01 <bss03> :t ap
01:47:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:48:41 <bss03> #pl \f x g -> either (a x) b @ c f x
01:48:47 <bss03> @pl \f x g -> either (a x) b @ c f x
01:48:47 <lambdabot> (const .) . ap ((@) . flip either b . a) . c
01:48:55 <bss03> @pl \f x g -> either (a x) b $ c f x
01:48:55 <lambdabot> (const .) . ap (flip either b . a) . c
02:59:04 * hackagebot shake 0.1.4 - Build system library, like Make, but properly supports generated files.  http://hackage.haskell.org/package/shake-0.1.4 (NeilMitchell)
03:23:44 <markus3> Hi! what is the conventional way of running a bounded number of threads? Like, when I have a Chan, and each threads read from it, but some of them sometimes die away.
03:31:06 <Saizan> i'm not sure i get your use case but there are a few thread pool packages on hackage
03:37:24 <markus3> I need to run IO actions for every chan element. The actions sometimes die because of errors, and then I need to respawn more threads, to cover those that died. Maybe its ok to just forkIO for every element in the chan, and have GHC runtime do the scheduling?
03:39:04 <markus3> I've looked at the packages (maybe not to deep), but haven't found something directly for this
03:41:44 <Saizan> well, it's quite ok to forkIO for each element in the chan, unless you have some reason to limit the rate of consumption
03:42:10 <Saizan> these are lightweight non-OS threads
03:42:16 <markus3> yes
03:45:15 <markus3> yes, it might be, I will try. Each tread runs some bash, so I was worried, that running infinitely many threads would be bad for performance
03:45:49 <markus3> but maybe GHC runtime can do the limiting for me
03:45:56 <markus3> thank you for answering
03:45:59 <shachaf> markus3: If each thread spawns a process then it probably will be expensive. :-)
03:46:06 <shachaf> Do the threads *themselves* die, or just some action that they run?
03:46:44 <Saizan> shachaf: is there a difference?
03:46:57 <markus3> I think, that the thread dies, because there's an error with the bash commands they run
03:46:59 <shachaf> What I was thinking wasn't making much sense, I think.
03:47:14 <copumpkin> you can catch errors inside the thread and stop the threads from dying
03:47:17 <shachaf> You could just have the threads be forever (doActualThings `catch` whatever), or something along those lines.
03:47:19 <copumpkin> if you want some sort of persistent pooly thing
03:48:37 <markus3> yes. I think I get it now -- I can continue executing after catching the error
04:05:15 <GorDonFreeMan> hi :)
04:05:29 <GorDonFreeMan> realtime preempted linux kernel's HRT & TSC test result data http://pastebin.com/AUKD963h
04:05:32 <mauke> The paste AUKD963h has been copied to http://hpaste.org/55944
04:05:34 <GorDonFreeMan> here's some fun
05:28:47 <etpace> Are there any tools out there can convert a .hs file to a syntactically equivalent ocaml file?
05:29:09 <mauke> what does that even mean?
05:29:25 <alistra> etpace: mv?
05:29:29 <alistra> mv 1.hs 1.ml
05:29:40 <lukish> I've noticed using often some kind of pattern and cutted that in some function:
05:29:41 <lukish> findAllFromThat :: (a -> a) -> (a -> Bool) -> [a] -> [a]
05:29:41 <lukish> findAllFromThat func condition = map fst . filter ( condition . snd ) . map ( (&&&) id func )
05:29:43 <alistra> and it is _syntactically_ equivalent
05:29:58 <lukish> Is there some analog of my kludge?
05:30:16 <ion> lukish: Yeah, that’s a frequent pattern indeed.
05:30:48 <mauke> lukish: findAllFromThat func condition = filter (condition . func)
05:30:59 <alistra> @hoogle (a -> b) -> (b -> Bool) -> [a] -> [a]
05:30:59 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
05:30:59 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
05:30:59 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
05:31:09 <ion> Oh, i missed the last map.
05:31:54 <alistra> :t \func condition -> filter (condition . func)
05:31:55 <lambdabot> forall a a1. (a1 -> a) -> (a -> Bool) -> [a1] -> [a1]
05:32:00 <hpc> :t \f g -> filter (g . f)
05:32:01 <lambdabot> forall a a1. (a1 -> a) -> (a -> Bool) -> [a1] -> [a1]
05:32:12 <lukish>  mauke oh wow
05:32:15 <lukish> Thanks
05:32:16 <hpc> heh
05:32:17 <alistra> @pl \func condition -> filter (condition . func)
05:32:17 <lambdabot> (filter .) . flip (.)
05:32:23 <alistra> trololol
05:33:57 <ion> I find the “map fst . filter (f . snd)” pattern somewhat frequent when i already have data in that format.
05:34:41 <alistra> :t lookip
05:34:41 <lambdabot> Not in scope: `lookip'
05:34:44 <alistra> :t lookup
05:34:44 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
05:35:50 <etpace> ah mauke alistra, I meant, renaming case to match etc and other syntactic differences
05:35:55 <etpace> so maybe semantic equivalence modulo laziness
05:37:40 <alistra> etpace: i never heard of such contraption
05:46:02 <Kanisterschleife> hello. Does Haskell automatically check if when I pass a String to a function expecting a type different from String if that type belongs to the typeclass Read and, if yes, automatically apply read?
05:46:27 <alistra> no it doesn't automatically apply read
05:47:28 <copumpkin> o.O
05:47:55 <alistra> but it checks the type correctness
05:47:58 <alistra> it's not perl
05:47:59 <Kanisterschleife> alistra: Hm ok. Then could you explain to me the line "inh <- openFile 'input.txt' ReadMode" from the RealWorldHaskell book? :t fileOpen says that it assumes an argument of type FilePath, not [Char]
05:48:14 <copumpkin> FilePath is a synonym for String which is a synonym for [Char]
05:48:15 <hpc> @src FilePath
05:48:15 <lambdabot> type FilePath = String
05:48:19 <hpc> @src String
05:48:20 <lambdabot> type String = [Char]
05:48:22 <hpc> @src []
05:48:23 <lambdabot> data [] a = [] | a : [a]
05:48:33 <ion> RWH has that line? With 'input.txt'?
05:48:42 <hpc> 'type' defines a type alias, which is basically just a #define, if you know C
05:48:54 <Kanisterschleife> Ah ok, then of course it is clear..
05:48:55 <hpc> aliases are desugared early in compilation
05:49:01 <Kanisterschleife> Thank you!
05:49:06 <alistra> hpc: even C has typedefs :|
05:49:09 <Kanisterschleife> Thought it would be a different type
05:49:24 <ion> It should be. :-P
05:49:43 <Kanisterschleife> it should be?
05:49:44 <hpc> to make it a new type instead of an alias, use 'newtype'
05:50:03 <hpc> but you still need explicit wrapping and unwrapping
05:50:15 <maltem> Kanisterschleife, morally speaking, I guess
05:50:20 <ion> (And here it is. http://hackage.haskell.org/package/system-filepath)
05:50:52 <Kanisterschleife> hpc: How can I get the information you requested from the bot above? Like "give me the definition of FilePath"
05:51:03 <hpc> use @src
05:51:22 <hpc> "@src thingYouWantSourceFor", and hope lambdabot has it in the database
05:51:24 <Kanisterschleife> hpc: from within what?
05:51:51 <Kanisterschleife> Ah, sorry, I meant from the command line, not from within IRC
05:51:52 <hpc> say it somewhere that lambdabot can see
05:51:54 <hpc> ah
05:51:59 <hpc> use :info
05:52:07 <hpc> or :browse, i forget which
05:52:10 <Kanisterschleife> ah, works, great :)
05:52:22 <Kanisterschleife> Thank you all :-)
05:52:24 <hpc> and use :help to get a list of everything you can do in ghci
05:53:13 <Kanisterschleife> ok
05:54:41 * maltem wonders if some trouble could have been avoided, were type String = [Char] not included in the Prelude
06:00:40 <dropdrive> How do I import Prelude hiding (.), but then also being able to call (.) ?
06:00:57 <ion> Prelude..
06:01:04 <dropdrive> ion: Really, thanks.
06:01:39 <hpc> dropdrive: if you want to call it prefix, you put parens around the whole thing
06:01:47 <hpc> :t (Prelude..) -- not Prelude.(.)
06:01:48 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:02:15 <vav> dropdrive: you can also additionally import Prelude as P and use (P..)
06:02:21 <hpc> that's a tricky thing to discover for yourself
06:03:02 <dropdrive> I see thanks all.
06:03:06 <ksion> Too bad you cannot import Prelude as . and use (...) ;)
06:03:44 <hpc> haha
06:04:04 <vav> I've been looking for something worthwhile to use for f ... g but not yet.
06:04:16 * hackagebot xml-hamlet 0.2.0 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.2.0 (MichaelSnoyman)
06:04:22 <dropdrive> So I saw someone here talk about how ($) is better when it's left associative
06:04:24 <hpc> :t let f = (Prelude..) in f f f -- vav
06:04:25 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:04:29 <dropdrive> What's the motivation there?
06:04:47 <hpc> that's generally called (.:) though
06:04:55 <hpc> same number of dots, visually shorter
06:05:42 <hpc> dropdrive: a common stylistic error newbies make is to write f $ g $ h $ x, instead of f . g . h $ x
06:05:51 <hpc> due to how ($) associates, the two are the same
06:06:11 <dropdrive> hpc: Oops, I sometimes do the former
06:06:13 <hpc> but the latter is prefered because (f . g . h) is a well-typed expression
06:06:19 <hpc> whereas (f $ g $ h) is not
06:06:50 <hpc> there's another reason which involves ($) being able to remove parens in more edge cases, but i can't remember specifics
06:06:53 <vav> although when f g and h are 80 characters long and full of brackets it can be clearer to write the first
06:08:50 <dropdrive> What about the stuff in Data.Functor.Syntax -- seems pretty reasonable...?
06:09:18 * hackagebot xml2html 0.1.0 - blaze-html instances for xml-conduit types  http://hackage.haskell.org/package/xml2html-0.1.0 (MichaelSnoyman)
06:29:17 * hackagebot shake 0.1.5 - Build system library, like Make, but properly supports generated files.  http://hackage.haskell.org/package/shake-0.1.5 (NeilMitchell)
06:43:42 <mekeor> is there a function (let's say "x") which takes a function ("f") and a list ("l") and an integer ("i") and returns the result of giving f the first i elements of l?
06:44:15 <mekeor> i mean, e.g.: x f l 1 = f (l!!1)
06:44:30 <mekeor> oops
06:44:32 <mekeor> i mean
06:44:40 <mekeor> x f l 1 = f (l!!0)
06:44:50 <mauke> that looks like a type error
06:44:51 <mekeor> another example:
06:45:01 <alistra> @hoogle splitAt
06:45:01 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
06:45:01 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
06:45:01 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
06:45:19 <mekeor> x f l 2 = f (l!!0) (l!!1)
06:45:43 <mauke> mekeor: what would the type of x be?
06:45:48 <merijn> mekeor: I think such a function requires some advanced type hackery or dependent types
06:45:59 <alistra> > (\f l i -> first f $ splitAt i l) (+2) [1..10] 3
06:46:00 <lambdabot>   No instance for (GHC.Num.Num [a])
06:46:00 <lambdabot>    arising from a use of `e_121103' at <i...
06:46:05 <mekeor> mauke: oh..
06:46:24 <alistra> > (\f l i -> first f $ splitAt i l) (map (+2)) [1..10] 3
06:46:25 <lambdabot>   ([3,4,5],[4,5,6,7,8,9,10])
06:46:34 <mekeor> mauke & merijn : you're right..
06:46:53 <alistra> @hoogle ([a], [a]) -> [a]
06:46:53 <lambdabot> Network.CGI.Protocol formEncode :: [(String, String)] -> String
06:46:53 <lambdabot> Network.CGI formEncode :: [(String, String)] -> String
06:46:53 <lambdabot> Network.HTTP.Base urlEncodeVars :: [(String, String)] -> String
06:46:56 <merijn> mekeor: Printf does something similar with some type hackery
06:47:16 <mekeor> because "f" is (a -> b) or (a -> a -> b) or (a -> a -> a -> b) ... etc
06:47:17 <merijn> mekeor: But it's not possible to do that safely in haskell afaik
06:47:39 <mekeor> what a bummer..
06:47:52 <mekeor> btw: would agda be able to implement that?
06:47:57 <alistra> @pl (\f l i -> first f $ splitAt i l)
06:47:57 <lambdabot> (. flip splitAt) . (.) . first
06:48:02 <merijn> mekeor: Yeah, should be possible in agda
06:48:06 <mauke> $(x 2) f l
06:48:16 * mekeor is jealous
06:48:22 <merijn> mekeor: Since then you can encode the number of arguments of f in the type and check that the list is at least that long
06:48:37 <merijn> (Assuming you use lists/vectors which encode their length in the type)
06:48:40 <mekeor> cool
06:49:00 <mekeor> anyway. than you :)
06:49:04 <alistra> mekeor: i assume you don't want for f to just take a list
06:49:05 <alistra> ?
06:49:20 <mekeor> er.. no
06:49:24 <vav> yeah, if it's [a] -> t
06:49:26 <vav> oh
06:49:46 <alistra> > (map (+2)) [1..10] 3 (\f l i -> (\(a,b) -> a ++ b) $ first f $ splitAt i l)
06:49:47 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
06:49:47 <lambdabot>         against inferred type ...
06:49:48 <mekeor> i mean, no i dont want f to take a list
06:49:56 <mauke> :t flip (.) take . (.)
06:49:57 <lambdabot> forall a b. ([a] -> b) -> Int -> [a] -> b
06:50:09 <alistra> > (\f l i -> (\(a,b) -> a ++ b) $ first f $ splitAt i l) (map (+2)) [1..10] 3
06:50:10 <lambdabot>   [3,4,5,4,5,6,7,8,9,10]
06:50:14 <vav> :t \f l i -> f $ fst (splitAt i l)
06:50:15 <lambdabot> forall b a. ([a] -> b) -> [a] -> Int -> b
06:50:24 <vav> that's how I read your question
06:50:31 <mauke> > (flip (.) take . (.)) (map (+2)) 3 [1..10]
06:50:32 <lambdabot>   [3,4,5]
06:50:33 <mekeor> merijn: but, of course, i could implement such a func for different f, right?
06:50:46 <mekeor> i merijn i mean something like x1, x2, x3 etc.
06:53:10 <merijn> mekeor: You could implement it for a specific f, yes. Although you'd have to be sure that the list is long enough
06:53:23 <mekeor> of course.
06:53:43 <merijn> mekeor: Although, if you have the source of f it'd probably easier to rewrite it to use a list directly
06:54:05 <mekeor> you're right, yes
06:55:21 <merijn> (It might be possible to implement using type level naturals and Oleg-like type hackery, but I dunno how far that extension is)
07:13:23 <hughfdjackson> the strangest thing about haskell is how well it seems to be supported by high quality information
07:13:53 <hughfdjackson> coming from a javascript background where there has never been so much written by so many who understand so little, it'd be awesome if i'm not mistaken ^^
07:16:03 <merijn> hughfdjackson: I guess there's two factors in play, one is that coming from an academic environment people were expected to actually write well-supported articles about what they were doing. And the other is that, since haskell hasn't been that widely adopted yet, most people writing about it are fairly knowledgeable.
07:16:36 <hughfdjackson> ^_^ whereas with js, it was designed to be shoved into the user-space asap
07:17:00 <hughfdjackson> with syntax that disguises language features u.u
07:17:22 <merijn> Haskell has quite a bit of syntactic sugar disguising stuff too, though :p
07:17:35 <merijn> do-notation and list comprehensions, for one
07:17:46 <hughfdjackson> i was wondering about do-notation before
07:17:47 <merijn> literal overloading
07:18:03 <merijn> hughfdjackson: What were you wondering about it?
07:18:06 <hughfdjackson> e.g. foo 34 = 300?
07:18:20 <hughfdjackson> merijn: i was just wondering if it was sugar, or if it was based on more core language features
07:18:27 <carpi> is there a way to randomly choose an element from a list?
07:18:31 <merijn> hughfdjackson: do-notation is pure sugar
07:18:32 <hughfdjackson> that is, transparently used more core language features
07:18:42 <mauke> carpi: yes
07:18:55 <merijn> hughfdjackson: I dunno how well you understand types yet? Okay-ish?
07:18:55 <carpi> mauke: could you please tell me how i might go about doing it?
07:19:12 <hughfdjackson> merijn: Okayish may be being generous
07:19:19 <hughfdjackson> working on it :D
07:19:20 <mauke> randomRIO (0, length xs - 1)
07:20:16 <merijn> hughfdjackson: 'do { print "foo"; print "bar" }' desugars to 'print "foo" >> print "bar"'
07:20:28 <merijn> :t print
07:20:29 <lambdabot> forall a. (Show a) => a -> IO ()
07:20:38 <merijn> :t (>>)
07:20:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:20:45 <carpi> but that makes the function IO.. the problem is.. if i make this "choose a random element" function IO, then all the other functions the depend on it will also become IO
07:21:07 <mauke> carpi: you can either do that or pass a random number generator around
07:21:27 <merijn> hughfdjackson: So print is an IO action, and (>>) is a function that takes two monadic actions (in this case two IO actions) and combines them into a single new monadic action (IO in this case)
07:21:42 <hughfdjackson> :) gotcha
07:21:45 <mauke> > do { "foo"; "bar" }
07:21:46 <lambdabot>   "barbarbar"
07:21:54 <hughfdjackson> >>'s implementation being the choice of the particular monad type?
07:22:00 <mauke> yeah
07:22:01 <merijn> hughfdjackson: Yes
07:22:13 <merijn> hughfdjackson: In case of IO it just does the first thing, then the second
07:22:22 <carpi> you mean something like using randomR function for instance...where the StdGen type is passed around?
07:22:28 <mauke> carpi: yes
07:22:30 <hughfdjackson> merijn: but it could do anything it chose?
07:22:44 <mauke> hughfdjackson: within the constraints of the type
07:22:47 <hughfdjackson> i mean.. the do notation is sugar for something that does not guarentee sequential execution?
07:22:52 <merijn> hughfdjackson: Yes, it can do different things for different monads
07:22:52 <mauke> hughfdjackson: and it is considered bad style to break the monad laws
07:23:13 <mauke> hughfdjackson: how do you "execute" a list?
07:23:17 <mauke> [] is a monad
07:23:24 <merijn> hughfdjackson: Well, for some monads there is no sensible interpretation of sequential (i.e. the list monad)
07:23:34 <merijn> hughfdjackson: 'do { x <- foo; bar x }' desugars to 'foo >>= (\x -> bar x)'
07:23:37 <mauke> lists are perfectly sequential
07:23:39 <merijn> :t (>>=)
07:23:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:23:45 <mauke> it's just executing that's nonsensical
07:23:47 <hughfdjackson> ah, i see
07:23:53 <hughfdjackson> mauke: :3 you know me
07:23:57 <merijn> mauke: I meant sequential execution, yeah
07:24:36 <mauke> hughfdjackson: ((->) e) is a good monad
07:24:47 <merijn> hughfdjackson: So >>= takes a monadic 'a' action, and a function that takes an 'a' and returns a monadic 'b' action and combines them into a single monadic 'b' action
07:25:27 <hughfdjackson> merijn: with you just about
07:25:40 <hughfdjackson> mauke: that, for the moment, went over my head ^^
07:25:43 <merijn> hughfdjackson: In case of IO it means "take an IO action that produces an 'a' and turn it into a IO action that produces a 'b', by using a function that takes an 'a' and returns a 'b' action.
07:26:30 <hughfdjackson> :D intriguing
07:26:36 <carpi> mauke: i tried that too. but theres a problem. I have to make the initial StdGen value manually and once the element has been chosen and the function exits.. it uses the same StdGen value when I call the function again for a new random value.
07:27:13 <mauke> carpi: don't use the same StdGen again
07:27:17 <merijn> hughfdjackson: If you are familiar with event-driven programming you can think of it as taking a callback that can produce an 'a' and turning it into a new callback that returns a 'b'
07:27:52 <merijn> hughfdjackson: Those two desugaring rules are basically all that do-notation does
07:28:07 <mauke> and by "return x" I mean "invoke a callback passing x as the argument"
07:28:33 <hughfdjackson> :D merijn that makes a good deal more sense, cheers matey
07:28:35 <merijn> You could write everything using (>>) and (>>=), but as you may guess it would become quite unreadable if you want to do a lot of IO actions in sequence
07:28:43 <mauke> it's not that bad, actually
07:29:05 <mauke> http://mauke.dyndns.org/stuff/haskell/how-to-io.html#a7
07:29:23 <merijn> mauke: Depends how far you want to scope variables with >>=, you could need a lot of parenthesis :p
07:29:28 <hughfdjackson> mauke: last time i tried to read this, i wasn't able to understand
07:29:35 <hughfdjackson> ^^ let's see if i've learnt enough
07:29:58 <merijn> hughfdjackson: A simple example of a different monad is the Maybe monad (I assume you're familiar with Maybe).
07:30:41 <hughfdjackson> in passing only, i'm afraid
07:31:15 <mauke> @src Maybe
07:31:16 <lambdabot> data Maybe a = Nothing | Just a
07:31:34 <mauke> @src fromMaybe
07:31:34 <hughfdjackson> merijn: lemmie read mauke's post and read up on maybe more :) i don't wanna pester you when all i need to do is read
07:31:34 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
07:31:46 <merijn> hughfdjackson: ok
07:32:24 <hughfdjackson> :) cheers though
07:49:11 <nexion> I'm using Database.MongoDB which uses Data.Bson which doesn't appear to support Data.Text.Lazy, but rather String and UString. If I'm interested in the Text value, should I retrieve string data as String and convert to Text manually, or is there a better way?
07:49:18 * hackagebot reactive-banana 0.4.3.1 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.4.3.1 (HeinrichApfelmus)
07:50:50 <teneen> In the definition of IO in GHC.Types
07:50:51 <teneen> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
07:51:02 <teneen> what is # State# ?
07:51:30 <copumpkin> an implementation detail
07:51:54 <Saizan> the first # is part of the (# , #) btw, those are unboxed pairs
07:52:24 <copumpkin> http://www.haskell.org/ghc/docs/7.2.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#t:State-35-
07:53:01 <merijn> Is there a paper discussing the GHC implementation in a reasonably understandable way for people who don't know how functional languages are implemented?
07:54:11 <teneen> from where did the compiler get the definition for State?
07:54:29 <merijn> teneen: Could be defined inside the implementation of the compiler
07:54:50 <byorgey> teneen: note that State# is not the same as State
07:54:58 <merijn> Mind you, that's a random observation, not an explanation based on knowledge :p
07:55:01 <byorgey> State# is some magical primitive thing defined internally to GHC
07:55:40 <byorgey> (except of course it isn't really magical)
07:55:46 <Saizan> merijn: is that excluding "implementing lazy functional languages" ?
07:55:48 <teneen> Can State# be used in normal code?
07:56:12 <Saizan> merijn: or were you more asking about a GHC commentary?
07:56:25 <byorgey> teneen: yes
07:56:28 <Jacco> Say you have a data Tree = Leaf | Node Tree Tree, would seq evaluate a complete tree, or only the value (either Leaf or Node .. ..)
07:56:32 <byorgey> @package acme-realworld
07:56:32 <lambdabot> http://hackage.haskell.org/package/acme-realworld
07:56:45 <byorgey> teneen: ^^^ there's an example of State# being used in normal code
07:57:14 <Saizan> Jacco: seq only demands the outermost constructor
07:57:50 <Jacco> Ok, thanks :)
07:58:01 <teneen> byorgey: seems interesting =D
07:58:07 <merijn> Saizan: No, I meant that in a "that does not assume prior knowledge of how functional languages are implemented"-way
07:58:58 <merijn> Saizan: An explanation of how to implement lazy functional languages would be interesting, although I'm more specifically interested in GHC
08:00:24 <Saizan> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/ maybe
08:01:21 <nus> teneen, http://darcs.haskell.org/ghc/docs/comm/
08:01:28 <hughfdjackson> merijn: looking at mauke's article on the do notation, it appears that js is not the only one to use sugar to lie about its language features xD
08:02:02 <hughfdjackson> (i think my major problem with javascript is that the 'sugar' was once the only way, which led to massive misunderstandings)
08:02:08 <merijn> hughfdjackson: How does do-notation lie?
08:02:29 <teneen> nus: thanks a lot
08:02:46 <nus> teneen, also peruse http://hackage.haskell.org/trac/ghc/wiki
08:03:33 <teneen> So in " newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)) " what are the #'s before State and after 'a' ?
08:03:39 <merijn> Saizan: That looks as as good a starting point as any, thanks :)
08:05:35 <nus> teneen, http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
08:05:37 <hughfdjackson> merijn: i mean.. the do notation makes it look as though you're really returning a value from a function (as you may in many imperative languages)
08:05:40 <hughfdjackson> thats all ^^
08:06:16 <hughfdjackson> :) first impressions only
08:07:21 <teneen> nus: thanks again :)
08:07:47 <nus> teiresias, yw
08:07:58 <merijn> hughfdjackson: You can think of all statements/functions having an implicit extra input argument and return value, the state of your program. Meaning every line uses the newly produced program state as input
08:08:16 <nus> err, teneen , rather
08:08:29 <merijn> hughfdjackson: The >>= functions (and by extension the "x <- foo") are just a way to do that explicitly
08:09:11 <merijn> hughfdjackson: The IO monad is really just an implementation of imperative programming.
08:10:28 <merijn> hughfdjackson: Now the syntactic sugar makes this slightly obvious then using >> and >>= directly, but that's not to "lie" about language features. It's just that everyone thinks it's a lot more convenient to write code that way
08:10:47 <merijn> s/slightly obvious/slightly less obvious/
08:12:04 <hughfdjackson> ^^ i should say that i was using 'lie' in a very loose sense
08:12:21 <hughfdjackson> 'using syntax in such a way as may mislead as to what's going on' may be a better way to put it :0
08:12:23 <hughfdjackson> *:)
08:13:05 <merijn> Well, it's actually pretty clear what happens, no? Because <- does actually "return" the value in the remaining scope of the do-notation
08:13:16 <merijn> In that sense it's not really misleading
08:13:57 <hughfdjackson> maybe i'm just misleading myself then :D
08:19:19 * hackagebot derive 2.5.5 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.5 (NeilMitchell)
08:20:15 <teneen> byorgey: Is that acme-realworld package a joke, or can it really restore previous states?
08:25:15 <srhb> Can I "end" an infinite list from inside a list comprehension, when I reach a certain element? Or is takeWhile the way to go?
08:28:47 <irene-knapp> is Edward Amsden an IRC user in here?
08:28:49 <parcs`> > [ n | n <- [1..], n < 100 ]
08:28:53 <lambdabot>   mueval-core: Time limit exceeded
08:29:07 <irene-knapp> wanted to chat about his package objective-c-ffi and collaborate, if so
08:29:47 <srhb> parcs`: So the answer is no, because it doesn't know if a smaller n occurs after a larger one.
08:30:17 <teneen> does anybody know what acme-realworld package is used for?
08:30:33 <Sgeo_> teneen, it's acme, which usually means it's not for real use
08:30:59 <Feuerbach> > take 5 [ n | n <- [1..], n < 100 ]
08:31:00 <lambdabot>   [1,2,3,4,5]
08:31:12 <noplamodo> Hi...I'm trying to run a parser (Parsec 3) with 'runParser'. I've set the state to 0, and everything works fine except that I can't use functions like 'putState' or 'modifyState' though 'getState' works fine..."No instance for (Num ())      arising from the literal `0'"
08:31:23 <teneen> Sgeo_: I see
08:31:53 <Sgeo_> teiresias, similarly, the acme package that has launchMissiles doesn't actually allow you to launch missiles.
08:32:14 <Sgeo_> But getWorld and putWorld are just ... jokes, I guess, playing off the internals of IO
08:32:25 <Feuerbach> noplamodo: please show the code
08:32:35 <Sgeo_> Can't hurt to play around with it, just don't use it in production code.
08:32:40 <parcs`> srhb: yep, just use takeWhile :P
08:32:41 <Sgeo_> Or with the goal of being useful.
08:33:05 <teneen> Sgeo_: But if you look at the source, execIO actually executes the IO action. But when I run it nothing happens
08:33:59 <Sgeo_> I don't know anything about GHC internals
08:34:43 <teneen> Sgeo_: execIO is in the acme-realworld package
08:34:46 <hpaste> noplamodo pasted “problem with putState and modifyState” at http://hpaste.org/55949
08:35:23 <noplamodo> Feuerbach : there's the part that poses problems
08:36:43 <Sgeo_> Please don't expect getWorld and putWorld to actually be capable of manipulating the universe.
08:37:53 <teneen> Sgeo_: Yes, I expect so. Because the RealWorld type does not actually represent the universe!
08:38:15 <Feuerbach> noplamodo: also, please paste the full error message there
08:38:40 <teneen> Sgeo_: It's just that, by seeing it's source, I expect execIO to do the side-effecs when it actually doesn't
08:38:47 <noplamodo> Feuerbach : ok, sorry i forgot to...
08:39:22 * Sgeo_ has no idea
08:39:32 <hpaste> noplamodo annotated “problem with putState and modifyState” with “problem with putState and modifyState (annotation)” at http://hpaste.org/55949#a55950
08:40:00 <aninhumer> Sgeo_: modifyWorld (modifyHappiness (+100))
08:40:15 <Feuerbach> noplamodo: my guess is that somewhere you have a type signature which restricts the state to ()
08:40:24 <Feuerbach> that snippet by itself looks good to me
08:40:59 <vhd> is there an inverse function to concat?
08:41:23 <Feuerbach> if you post a full source file I could say more (this one does not compile because of many undefined identifiers)
08:41:27 <maurer> vhd: There can't be.
08:41:33 <Feuerbach> vhd: no, because it's not injective
08:41:43 <maurer> vhd: Though ``words'' might do somethin like what you want
08:41:55 <Clint> splitOnMagic
08:45:20 <noplamodo> Feuerbach : that's what i thought...although i don't see what could limit it? (maybe i'm blind)
08:46:03 <noplamodo> seems that any operation on the state gives the same error, even 'getState' when i'm trying to use the state i get...
08:46:23 <nexion> what kind of an exception is generated by the call to "error"? and more interestingly, it seems to bypass its first handler and is caught higher up.. what could be causing it?
08:47:02 <nexion> both handlers are with 'catch' for \ex -> with let _ = ex :: SomeException
08:47:32 <dons> happy new year, folks.
08:47:40 <Feuerbach> nexion: it's ErrorCall
08:47:43 <mauke> nexion: you're probably throwing it outside of the first handler
08:47:50 <Feuerbach> dons: happy new year!
08:48:07 <Feuerbach> nexion: it could be due to laziness
08:48:09 <KorriX> not only dons: Happy new year to everybody !
08:48:34 <dons> 10 years of #haskell
08:48:40 <hpaste> nexion pasted “the first handler” at http://hpaste.org/55951
08:48:40 <dons> well done, shapr :)
08:49:06 <nexion> mauke, pasted it -- seems like it should be within
08:49:22 <mauke> nexion: I don't think so
08:49:34 <mauke> > let x = error "boom!" in length [x, x, x]
08:49:35 <lambdabot>   3
08:49:38 <mauke> no exception
08:50:29 <mauke> :t throwIO
08:50:30 <lambdabot> Not in scope: `throwIO'
08:50:40 <mauke> @hoogle throwIO
08:50:41 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
08:50:41 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
08:50:41 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
08:52:33 <dons> #haskell 02.01.01: 06:11:05 <shapr> wheee
08:52:34 <dons> :)
08:53:24 <Feuerbach> dons: so that would be 11 years?
08:53:38 <dons> yy.mm.dd
08:53:50 <irene-knapp> cool
08:54:05 <nexion> mauke, how is the throw getting around the handler?
08:54:14 <mauke> nexion: what throw?
08:54:28 <nexion> the "error" call
08:54:37 <mauke> laziness
08:55:26 <nexion> could I force it to run that handler on exception?
08:55:33 <irene-knapp> bottoms other than infinite recursion need to just go away ><
08:55:46 <mauke> nexion: it already does
08:55:52 <mauke> you don't have an exception
08:56:02 <nexion> "error" is different?
08:56:32 <irene-knapp> error is like undefined - it's a bottom, a pure value that can't be evaluated
08:56:42 <irene-knapp> your program just exits if you try :(
08:56:55 <irene-knapp> good Haskell style makes no use of these, haha
08:56:55 <mauke> nexion: dude, which part of "laziness" was unclear?
08:57:22 <irene-knapp> (note: opinions given are those of myself.  I do not speak for the channel :D)
08:57:26 <nexion> my question now is how to maintain the desired behavior
08:57:29 <irene-knapp> throwIO
08:57:35 <mauke> use throwIO or fail or something
08:57:41 <Fuco> @pl \f x y z -> f (f x y) z
08:57:41 <lambdabot> (.) =<< (.)
08:57:50 <irene-knapp> don't use fail, fail is also evil :) use throwIO
08:58:15 <mauke> fail shouldn't be in Monad but we're monomorphically IO.fail here
08:58:16 <irene-knapp> or if you don't want to work in IO, use ExceptionT from the mtl library on the monad of your choice
08:58:17 <Fuco> =<< is flip >>=?
08:58:24 <irene-knapp> (or Exception, which is a synonym for ExceptionT Identity)
08:58:26 <mauke> @src (=<<)
08:58:26 <lambdabot> f =<< x = x >>= f
08:58:41 <irene-knapp> mauke: that's fair
08:58:56 <Fuco> cool feature, didn't know about @src :P
08:59:00 <irene-knapp> yeah
08:59:37 <nexion> one problem is that the library I'm using could call "error" and it would be highly desired to run this exact handler in that case
08:59:49 <irene-knapp> that is, indeed, a problem :( what library is it?
08:59:59 <merijn> nexion: Libraries should never use error
09:00:10 <merijn> And I don't think any major libraries exist that do
09:00:13 <irene-knapp> I'd be surprised if that happened though, because of what merijn said
09:00:13 <nexion> http://hackage.haskell.org/packages/archive/bson/0.1.6/doc/html/Data-Bson.html which is used by Database.MongoDB
09:00:48 <nexion> unless there's a better way to access MongoDB?
09:00:49 <Feuerbach> merijn: why should they not?
09:01:03 <irene-knapp> because there's no way to catch it ><
09:01:09 <merijn> Feuerbach: Because you can't handle errors
09:01:18 <Feuerbach> merijn: how's that?
09:01:19 <nexion> oh :/
09:01:33 <Feuerbach> I'm pretty sure you can
09:01:36 <merijn> Feuerbach: error is similar to calling exit/abort
09:01:51 <Feuerbach> error is just an ordinary exception
09:01:52 <merijn> Feuerbach: There are exceptions, and things like Either and Maybe which you can use to encapsulate errors
09:02:05 <irene-knapp> error is not just an ordinary exception, no.
09:03:03 <gavri> are the typeclassopedia exercise solutions available?
09:03:32 <Feuerbach> > evaluate (error "blah") `Control.Exception.catch` (\(ErrorCall e) -> print e)
09:03:33 <lambdabot>   Not in scope: `evaluate'Not in scope: data constructor `ErrorCall'Not in sc...
09:03:50 <irene-knapp> > (error "blah")
09:03:51 <lambdabot>   *Exception: blah
09:04:04 <irene-knapp> > (error "blah") `Control.Exception.catch` ((ErrorCall e) -> print e)
09:04:05 <lambdabot>   Pattern syntax in expression context: (ErrorCall e) -> print eNot in scope:...
09:04:12 <irene-knapp> > (error "blah") `Control.Exception.catch` ((ErrorCall e) -> putStrLn $ show e)
09:04:13 <lambdabot>   Pattern syntax in expression context:
09:04:13 <lambdabot>      (ErrorCall e) -> putStrLn $ show...
09:04:32 <merijn> irene-knapp: Missing a \
09:04:32 <irene-knapp> > (error "blah") `Control.Exception.catch` (\e -> putStrLn $ show e)
09:04:33 <lambdabot>   Not in scope: `Control.Exception.catch'
09:04:35 <maurer> merijn: You can catch errors, see the "spoon" package
09:04:38 <Feuerbach> irene-knapp: note the "evaluate"
09:04:42 <irene-knapp> > (error "blah") `catch` (\e -> putStrLn $ show e)
09:04:43 <lambdabot>   <IO ()>
09:04:52 <irene-knapp> I'm not aware of any Haskell function called "evaluate" O_o
09:04:57 <irene-knapp> so I assumed that was a mistake
09:05:00 <irene-knapp> @hoogle evaluate
09:05:00 <Feuerbach> it's in Control.Exception
09:05:01 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
09:05:01 <lambdabot> Control.Exception evaluate :: a -> IO a
09:05:01 <lambdabot> Control.OldException evaluate :: a -> IO a
09:05:04 <irene-knapp> oh, I see
09:05:08 <irene-knapp> hm
09:05:17 <irene-knapp> > (Control.Exception.evaluate $ error "blah") `catch` (\e -> putStrLn $ show e)
09:05:18 <lambdabot>   Not in scope: `Control.Exception.evaluate'
09:05:27 <Feuerbach> just try that in ghci
09:05:32 <irene-knapp> > (evaluate $ error "blah") `catch` (\e -> putStrLn $ show e)
09:05:33 <lambdabot>   Not in scope: `evaluate'
09:05:42 <Sgeo_> lambdabot is not GHCi
09:05:48 <irene-knapp> I'd rather have it working here.  Trying it in ghci won't convince anybody because it could be something weird about my system. :)
09:05:59 <irene-knapp> > (evaluate $ error "blah") `catch` (\e -> putStrLn $ show e)
09:06:00 <lambdabot>   Not in scope: `evaluate'
09:06:08 <irene-knapp> > (Control.Exception.Base.evaluate $ error "blah") `catch` (\e -> putStrLn $ show e)
09:06:09 <lambdabot>   Not in scope: `Control.Exception.Base.evaluate'
09:07:12 <irene-knapp> (evaluate $ error "blah") `Control.Exception.catch` (\e -> putStrLn $ show (e :: ErrorCall))
09:07:13 <irene-knapp> blah
09:07:16 <irene-knapp> okay, so that works for me in ghci
09:07:16 <nexion> I suspect maybe I shouldn't be using this lib
09:07:21 <irene-knapp> but that doesn't solve your problem, because
09:07:23 <merijn> Feuerbach: A very simple argument for not using errors is this: You cannot tell that a function call can fail from its type signature
09:07:25 <irene-knapp> laziness lets it escape =p
09:07:25 <nexion> what do you guys use as a mongodb driver?
09:07:29 <mux> if there is no way to fix the upstream library to not use error, it'd probably be best to use the spoon package from hackage that encapsulates the hacks needed to catch error calls
09:07:38 <irene-knapp> nexion: I avoid mongodb.  I'm an SQL fan.
09:07:42 <Feuerbach> (error "blah") `Control.Exception.catch` (\e -> putStrLn $ show (e :: ErrorCall))
09:07:44 <Feuerbach> > (error "blah") `Control.Exception.catch` (\e -> putStrLn $ show (e :: ErrorCall))
09:07:45 <lambdabot>   Not in scope: type constructor or class `ErrorCall'Not in scope: `Control.E...
09:08:00 <parcs`> irene-knapp: but sql is not web scale!
09:08:08 <irene-knapp> parcs: duly noted :D
09:08:12 <merijn> Feuerbach: And library APIs should never be able to unexpectedly fail
09:08:13 <nexion> lol
09:08:35 * irene-knapp is the author of the tiny package direct-sqlite, and might be somewhat biased :)
09:08:42 <Feuerbach> > head []
09:08:43 <lambdabot>   *Exception: Prelude.head: empty list
09:08:57 <merijn> Feuerbach: Head is a terrible function and should be removed from the prelude IMO
09:08:58 <irene-knapp> Feuerbach: yes, it's very annoying.  some of us want that out of the standard.
09:09:16 <merijn> Head should be [a] -> Maybe a
09:09:20 <irene-knapp> exactly so
09:09:26 <Feuerbach> merijn: that kind of contradicts your "And I don't think any major libraries exist that do"
09:09:31 <srhb> Same goes for tail then?
09:09:31 <Sgeo_> :t maybeToList
09:09:32 <lambdabot> forall a. Maybe a -> [a]
09:09:36 <Sgeo_> erm
09:09:38 <irene-knapp> yes, tail should be [a] -> Maybe [a]
09:09:39 <Sgeo_> :t listToMaybe
09:09:40 <lambdabot> forall a. [a] -> Maybe a
09:09:51 <Sgeo_> > listToMaybe [1,2,3]
09:09:52 <lambdabot>   Just 1
09:09:56 <Sgeo_> > listToMaybe []
09:09:57 <lambdabot>   Nothing
09:10:23 <irene-knapp> anyway, Feuerbach, it's definitely a strong convention to not have bottoms in pure code, the prelude notwithstanding (we're stuck with it for compatibility reasons)
09:10:40 <irene-knapp> Feuerbach: are you the author of a library that you don't want to rework?  because you're reacting as if you are :)
09:15:36 <Feuerbach> irene-knapp: there are several ways to handle errors, as you probably know. In each particular case you should be guided by common sence, not some hypothetical "strong conventions"
09:15:47 <irene-knapp> surely
09:15:53 <irene-knapp> well, no, actually
09:16:02 <irene-knapp> what you're saying is basically an argument for pragmatism over principle
09:16:14 <Feuerbach> yes
09:16:17 <irene-knapp> I assert that (in life in general, including in programming) when you have a principle which you know through long experience to hold
09:16:25 <irene-knapp> you should follow it /even when you can't see how it applies/
09:17:01 <irene-knapp> unless you have some specific reason against it in this instance,
09:17:01 * mux couldn't disagree more.
09:17:16 <irene-knapp> in which case a smart person will look to see why it disagrees, potentially reconsidering the principle
09:17:21 <Sgeo_> In the toy code I'm writing, I'm pretty sure it's theoretically impossible for me to avoid bottoms
09:17:24 <mux> you shouldn't follow anything that you don't understand
09:17:38 <mux> you should understand it first
09:17:40 <irene-knapp> mux: by assumption, you do understand it in this case
09:17:58 <irene-knapp> you certainly shouldn't let anyone else tell you what principles to follow
09:18:04 <irene-knapp> you should have your own
09:18:10 <mux> dogma is as bad in programming as in real life
09:18:18 <irene-knapp> okay.  well, disagreement noted!
09:18:29 <mauke> you should be pragmatic about your list of dogmas
09:18:34 <Feuerbach> anyway, my point was that error *is* used in real libraries, where appropriate
09:18:41 <irene-knapp> and not let them out in the street where they can get hit by karmas
09:19:07 <irene-knapp> Feuerbach: I personally would go so far as to cast aspersions on the real-ness of any library that does that :)
09:19:22 <irene-knapp> and would certainly never use such a library, rewriting it myself if necessary
09:19:34 * mauke keeps it real and also tight
09:19:42 <irene-knapp> if forced to use it by budgetary constraints I would make sure somebody knew how annoyed I was at this :)
09:19:56 * Sgeo_ was yelling about ftphs the other day
09:20:09 <irene-knapp> it's the equivalent of a C library calling exit() if it doesn't like the parameters you pass it
09:20:13 <Sgeo_> Not due to error abuse, but due to lazi I/O abuse.
09:20:14 <bahamas> hello. is this correct (Num b) => length :: [a] -> b or shouldn't it be length :: (Num b) => [a] -> b instead?
09:20:18 <irene-knapp> ah, yeah
09:20:21 <mauke> irene-knapp: more like abort()
09:20:25 <irene-knapp> mauke: true enough
09:20:34 <mauke> which is actually catchable
09:20:37 <Sgeo_> bahamas, the second, but that's not the actual type of length
09:20:43 <irene-knapp> but only with some trouble.  yeah.  makes sense.
09:20:58 <mux> :t fromInteger . genericLength
09:20:59 <lambdabot> forall a b. (Num a) => [b] -> a
09:21:18 <irene-knapp> Feuerbach, anyway we've pretty much boiled our disagreement down to fundamentals I think
09:21:19 <bahamas> Sgeo_: yes, i know. this is from learn you a haskell, which as the first version i mentioned, and i was confused
09:21:26 <irene-knapp> Feuerbach, so I guess there's nothing further to discuss
09:21:30 <Sgeo_> bahamas, wait, what?
09:21:31 <bahamas> s/as/has/
09:21:31 <Sgeo_> Link
09:21:33 <Sgeo_> ?
09:21:47 <bahamas> Sgeo_: http://learnyouahaskell.com/types-and-typeclasses bottom of the page
09:22:21 <Sgeo_> LYAH isn't perfect
09:22:50 <Sgeo_> Although the only beef I've had with LYAH until now (or is it another tutorial) is the claim that recursion without naming a function is obviously impossible
09:23:08 <Feuerbach> Sgeo_: haha
09:23:30 <bahamas> Sgeo_: i don't expect it to be. i just wanted to make sure i was right in this particular case
09:23:53 <MostAwesomeDude> Sgeo_: Well, technically, doesn't that function get named <anonymous function #1> ? :3
09:24:51 <MostAwesomeDude> Or are all lambdas inlined at site of definition?
09:25:15 * Sgeo_ has no idea
09:25:23 <Sgeo_> But that's an implementation detail, isn't it?
09:25:40 <Sgeo_> > fix (\fact n -> if n == 0 then 1 else fact (n-1)) 5
09:25:41 <lambdabot>   1
09:25:47 <Sgeo_> > fix (\fact n -> if n == 0 then 1 else n * fact (n-1)) 5
09:25:48 <lambdabot>   120
09:27:14 <Sgeo_> :t runEitherT
09:27:15 <lambdabot> Not in scope: `runEitherT'
09:27:18 <Sgeo_> :t runErrorT
09:27:19 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
09:27:34 <Sgeo_> :t runMaybeT
09:27:35 <lambdabot> Not in scope: `runMaybeT'
09:27:41 <Sgeo_> :t runStateT
09:27:42 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
09:27:46 <Sgeo_> :/
09:28:31 * Sgeo_ is trying to grasp the general semantics of runWhateverT
09:29:05 <bahamas> Sgeo_: btw, in that same paragraph, why not use fromInteger instead of fromIntegral?
09:29:19 <maurer> Sgeo_: The basic idea is that unpacks the monadic action.
09:29:34 <Sgeo_> runErrorT seems to imply that all it does is convert from monad transformer stack form to regular form, but runStateT also pulls out the underlying semantic of State, which is runState's job
09:29:48 <maurer> Sgeo_: For example, in runStateT, it fills in the hole in the function that is inner to it with whatever is passed in, and extracts the results
09:29:49 <parcs`> @src StateT
09:29:49 <lambdabot> Source not found. There are some things that I just don't know.
09:30:01 <parcs`> runStateT, runErrorT, are just record accessors
09:30:08 <bahamas> ah, because Int and Integer are different types
09:30:11 <maurer> runErrorT unpacks it, and gets the underlying thing out, which in this case isn't an expression with a hole, but an either type
09:30:35 <rwbarton> you can read the type of runStateT as StateT s m a -> (s -> m (a, s))
09:31:03 <parcs`> you can't make a monad instance of (\a -> \s -> m (a, s)) so you wrap it into a newtype StateT s m a = StateT { runStateT :: s -> m (a, s) } and now suddenly you can
09:31:04 <Sgeo_> I can't mentally generalize between runErrorT and runStateT though
09:31:10 <Sgeo_> runErrorT still leaves in an Either
09:31:23 <rwbarton> and runStateT leaves in a s -> and a (, s)
09:31:45 <rwbarton> I don't see what about them is different
09:31:55 <Sgeo_> But in that case, it's not wrapped up in a State
09:32:28 <Sgeo_> Wait, would that even make sense?
09:32:35 <rwbarton> no
09:32:46 <rwbarton> I see what you are saying no
09:32:47 <rwbarton> w
09:33:32 <monochrom> no, runErrorT and runStateT are too different to be generalized together
09:34:04 <rwbarton> generalized in Haskell, yes
09:34:14 <monochrom> apart from "unwrap the newtype"
09:34:23 <bahamas> btw, is there a way to define a function with type annotations in the interpreter?
09:34:40 <mauke> sure
09:35:05 <Sgeo_> :k MaybeT
09:35:06 <lambdabot> Not in scope: type constructor or class `MaybeT'
09:35:08 <Sgeo_> :k ListT
09:35:09 <lambdabot> Not in scope: type constructor or class `ListT'
09:35:12 <rwbarton> Sgeo_: in general "FooT Bar a" is not comprised of Foo and Bar and a in any systematic way
09:35:41 <Sgeo_> :t lift
09:35:42 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:35:45 <rwbarton> I would think of that as an issue having to do with FooT, though, not runFooT which is why I was confused
09:36:04 <mauke> runFoot
09:36:14 <Sgeo_> > (+) <$> (Just 1) <*> lift ([1,2,3])
09:36:15 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
09:36:15 <lambdabot>         against inferred ...
09:36:35 <Sgeo_> How would I do what I tried to do?
09:37:06 <rwbarton> return
09:37:15 <Sgeo_> > (+) <$> return (Just 1) <*> lift ([1,2,3])
09:37:16 <lambdabot>   No instance for (GHC.Show.Show (t [] (Data.Maybe.Maybe t1)))
09:37:16 <lambdabot>    arising fro...
09:37:17 <Sgeo_> Like that?
09:37:24 <bahamas> mauke: is has to be done after the function is defined though, right?
09:37:28 <rwbarton> wait I have no idea what you wanted to do
09:37:31 <mauke> bahamas: no
09:38:05 <Sgeo_> @hoogle Maybe a -> MaybeT m a
09:38:05 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
09:38:05 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
09:38:05 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
09:38:18 <Sgeo_> But I can't possibly lift both values
09:38:28 <Sgeo_> And expect that to work
09:38:42 <Feuerbach> > let f :: Integer -> Integer; f x = x + x
09:38:43 <lambdabot>   not an expression: `let f :: Integer -> Integer; f x = x + x'
09:38:50 <alistra> @src Applicative
09:38:50 <lambdabot> class Functor f => Applicative f where
09:38:50 <lambdabot>     pure  :: a -> f a
09:38:50 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
09:38:56 <rwbarton> which monad are you expecting to use here?
09:38:56 <Sgeo_> rwbarton, what I want to do is use a regular function with monadic arguments from different monads.
09:38:58 <Feuerbach> bahamas: it would look something like that ^^
09:39:02 <rwbarton> you can't
09:39:25 <rwbarton> well, you have to choose a way to "combine" the monads (i.e. pick a monad that both of your monads map into)
09:39:26 <Feuerbach> > let f :: Integer -> Integer; f x = x + x in f 2
09:39:26 <bahamas> mauke: if i do this ghci> addThree :: Int -> Int -> Int -> Int, I get <interactive>:1:0: Not in scope: `addThree'
09:39:27 <lambdabot>   4
09:39:38 <bahamas> Feuerbach: ah, I have to use 'let'
09:39:48 <bahamas> thanks
09:39:50 <rwbarton> in general this is a real choice that will affect what you get out
09:40:14 <rwbarton> not just a matter of symbol-pushing
09:40:24 <monochrom> bahamas: easiest way is enter your definitions in a file, load file in ghci
09:40:40 <rwbarton> since you now have two different kinds of "effect" and you need to say how they interact with each other
09:41:13 <mekeor> so, how can i write "do { x <- monadicFunc; func x }" using (>>=) ?
09:41:23 <Sgeo_> @hoogle IO (Maybe a) -> MaybeT IO a
09:41:23 <lambdabot> Did you mean: IO (Maybe a) -> MaybeT (IO a) a
09:41:23 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
09:41:34 <monochrom> monadicFunc >>= func
09:41:39 <ion> monadicFunc in that example is probably not a function.
09:41:42 <alistra> @pl do { x <- monadicFunc; func x }
09:41:42 <lambdabot> (line 1, column 4):
09:41:42 <lambdabot> unexpected "{"
09:41:42 <lambdabot> expecting variable, "(", operator or end of input
09:41:44 <MostAwesomeDude> mekeor: monadicFunc >>= func
09:41:45 <alistra> meh
09:41:47 <ion> func =<< monadicAction
09:42:01 <mekeor> MostAwesomeDude, monochrom: thanks
09:42:04 <monochrom> monadicFunc doesn't look like a function
09:42:05 <mauke> @undo do { x <- monadicFunc; func x }
09:42:05 <lambdabot> monadicFunc >>= \ x -> func x
09:42:09 <mekeor> ion: sorry for unprecise terms.
09:42:15 <MostAwesomeDude> mekeor: Do you see why this works?
09:42:18 <mekeor> s/terms/terminology/
09:42:24 <mekeor> MostAwesomeDude: er
09:42:30 <mekeor> probably not, no.
09:42:57 <mzero> bahamas: if you put your code in a file, Stuff.hs, say, then start ghci and type   :l Stuff.hs    --- then, in another window edit Stuff.hs, save, and then back in ghci  type just    :r    for reload - which will reload the last file loaded (with :l)  - very very convienent
09:43:15 <rwbarton> > (+) <$> return 1 <*> lift [1,2,3] :: MaybeT [] Int
09:43:16 <lambdabot>   Not in scope: type constructor or class `MaybeT'
09:43:26 <mzero> also note, there is file name completion in ghci as you type Stuff.hs via the tab key
09:43:28 <rwbarton> > (+) <$> return 1 <*> lift [1,2,3] :: Control.Monad.Trans.Maybe.MaybeT [] Int
09:43:29 <lambdabot>   Not in scope:
09:43:29 <lambdabot>    type constructor or class `Control.Monad.Trans.Maybe.MaybeT'
09:43:40 <alistra> mekeor: you can use both >>= and =<<, but the recommended is actually a multiline like that:
09:43:47 <alistra>     func
09:43:47 <alistra>      ||
09:43:47 <alistra>      /\
09:43:47 <alistra>      /\
09:43:47 <alistra> monadicAntion
09:43:54 <alistra> Action*
09:44:11 <mekeor> alistra: joke?
09:44:17 <alistra> is it?
09:44:26 <mekeor> i think so, yes.
09:44:29 <gavri> are there solutions to the typeclassopedia exercises available?
09:44:43 <alistra> mekeor: well, you'll never know then
09:44:44 <Sgeo_> rwbarton, if I have a Maybe a, can I convert it to a MaybeT m a?
09:44:57 <bahamas> mzero: yes, learn you a haskell mentioned that. thanks
09:45:07 <applicative> gavri, never seen any. which one were you looking at?
09:45:11 <Jeanne-Kamikaze> can one pass an objective-c file to ghc the way you pass a .c file when you're doing ffi ?
09:45:33 <gavri> applicative: the first set of exercises. want to make sure I'm getting them right
09:46:01 <Jeanne-Kamikaze> there seem to be a few projects on the way but nothing official apparently
09:46:04 <rwbarton> Sgeo_: yes
09:46:05 <ion> > runMaybeT $ (+) <$> return 1 <*> lift [1,2,3]
09:46:06 <lambdabot>   Not in scope: `runMaybeT'
09:46:30 <rwbarton> in this particular case, you can just write maybeToMaybeT (Just x) = return x; maybeToMaybeT Nothing = mzero
09:46:39 <irene-knapp> Jeanne-Kamikaze: yes, ghc supports it.  Cabal sorta does, kinda halfway, and I have patches that dcoutts has been sitting on for about a year to add support :(
09:46:55 <rwbarton> but in general, there should always be a way to convert like this since Maybe a "=" MaybeT Identity a
09:47:14 <Jeanne-Kamikaze> irene-knapp, so would I add the .m sources to c-sources: in a cabal file, or is there another keyword for it ?
09:47:25 <rwbarton> and I would expect monad transformers to be functorial in their monad argument
09:47:36 <rwbarton> so since you have Identity -> m for any m, you get MaybeT Identity -> MaybeT m
09:47:39 <irene-knapp> yes, that is correct, but I believe you're likely to run into other problems caused by that - I don't remember which, precisely
09:47:48 <applicative> gavri, i see them, make functor instances for Either e, (->) e , etc
09:47:51 <irene-knapp> I do recall some issue with having main() live on the C side, if it does
09:47:52 <hpaste> Gavri pasted “typeclassopedia exercise 1-4” at http://hpaste.org/55953
09:48:09 <gavri> applicative: yeah, those
09:48:11 <Jeanne-Kamikaze> ok thanks
09:48:17 <irene-knapp> sure.  good luck.
09:48:22 <gavri> are http://hpaste.org/55953 correct?
09:48:30 <applicative> the first one goes wrong because you are using Either as a constructor
09:48:47 <gavri> applicative: damn. thanks
09:48:51 <applicative> you need to say , what is fmap f (Right x) and what is fmap f (Left e)
09:49:00 <mauke> gavri: 'instance (' is a syntax error
09:49:01 <applicative> the cases will differ....
09:49:29 <gavri> oops, sorry mauke and applicative. I should have at the least tried them out
09:49:43 <rwbarton> haha, yeah, there is something important missing from your instance declarations!
09:49:56 <mauke> gavri: I'd start with 'class Hunctor h where hmap :: (a -> b) -> h a -> h b'
09:50:05 <applicative> gavri, you'll need to indent the second line of each, ...fmap f ....
09:50:28 <gavri> mauke: why hunctor?
09:50:35 <mauke> because Functor is already defined
09:50:48 <applicative> that's a good idea actually
09:50:49 <gavri> mauke, got it. thanks
09:51:22 <applicative> gavri, then each line will begin "instance Hunctor .... where hmap ...." -- you aren't saying what you;re instancing in the paste
09:52:00 <gavri> applicative: sorry. that was a complete screw up. I should have tried them out
09:52:56 <gavri> but once I type them down, is there any place I can check if they're correct? or will I have to just check if the functor laws hold and be done with it?
09:53:06 <Sgeo_> Would it make sense for my API binding to sometimes return IO (Either ReturnValue ())?
09:53:10 <rwbarton> gavri: they are mostly correct
09:53:26 <rwbarton> In this case the compiler will tell you where they are not
09:53:27 <applicative> you have the middle three right, the first is a mess
09:53:36 <fmapE> irene-knapp: You wanted to talk objective-c bindings?
09:53:42 <irene-knapp> fmapE: oh hi!
09:53:43 <irene-knapp> yes, so
09:53:53 <irene-knapp> I assume that, like me, you looked at hoc and found it too bitrotten to use
09:53:59 <fmapE> yep
09:54:26 <irene-knapp> I had been attacking the problem from a hoc-like direction though, writing code to scrape ObjC APIs out of a combination of the XML bindings data that Apple provides for this purpose, and the reflection API
09:54:42 <irene-knapp> your thing basically fits in as an RTS that I hadn't written yet for my thing, so that dovetails nicely :)
09:54:43 <fmapE> interesting
09:54:45 <irene-knapp> yeah
09:54:48 <fmapE> do you have anything working?
09:54:56 <fmapE> ha great
09:54:59 <irene-knapp> not to the point of being able to write client code against it, no
09:55:10 <irene-knapp> I do have scraping the XML data working
09:55:17 <fmapE> cool
09:55:26 <irene-knapp> scraping the reflection data is not working, because of a problem that you also didn't deal with, which is structures and doubles in function parameters and return values
09:55:37 <applicative> gavri there will be some issues about parentheses too.  I'm trying to figure out the functor laws for the funny tree.  It's probably a trick question!
09:55:39 <irene-knapp> Apple's APIs actually use those extensively so it's a real problem
09:55:48 <fmapE> yep I was going to bring that up
09:55:49 <irene-knapp> my approach is to use libffi, which is already linked into GHC anyway
09:55:57 <fmapE> Yep I'm using libffi
09:56:01 <irene-knapp> but libffi itself wants some structs, so managing ownership of the data is a problem
09:56:12 <irene-knapp> why don't I post my code somewhere and you can compare to yours, gimme a sec :)
09:56:18 <fmapE> go for it
09:56:20 <gavri> about the fourth one (Pair a a), neither of the functor laws seem to be broken if I apply the function to either a or b instead of neither. how is it that f has to be applied to both a and b?
09:56:39 <rwbarton> gavri: the types won't work out.
09:56:44 <applicative> if you only applie it to one, then one would be of type a and one would be of type b
09:56:55 <applicative> but they're supposed to be the same, so you have no choice
09:57:00 <MostAwesomeDude> @hoogle (a -> b -> b) -> (b -> c) -> (a -> b -> c)
09:57:00 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
09:57:00 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:57:00 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
09:57:07 <gavri> rwbarton, applicative: thanks again
09:57:16 <applicative> gavri, so your impulse was exactly right
09:57:23 <MostAwesomeDude> Meh.
09:58:24 <mauke> gavri: you'll get a type error if you don't
09:59:21 <gavri> applicative: I also forgot to add the Leaf constructor application for the fifth one. besides everything else that is probably wrong there
09:59:31 <irene-knapp> fmapE: $ darcs get http://ireneknapp.com/software/darcs/direct-cocoa/
09:59:57 <rwbarton> you also made a very common error on the last line
09:59:58 <applicative> gavri, f fell out of the right hand side of the Node constructor somehow.
10:00:07 <gavri> mauke: yeah, it just hit me again that the types constrain how a functor can be created too. thanks
10:00:13 <irene-knapp> so TranslateAPI/LibFFI.hs is the immediately relevant part of this
10:00:19 <dropdrive> True or False: if foo.hs defines bar, then there necessarily exists '^bar ' in foo.hs ?
10:00:31 <mauke> dropdrive: false
10:00:46 <dropdrive> mauke: how so?
10:00:47 <monochrom> what is ^bar ?
10:00:52 <mauke> dropdrive: bar=()
10:00:53 * applicative is baffled
10:00:57 <irene-knapp> oh you'll also need a dependency, which you can get with $ darcs get http://ireneknapp.com/software/darcs/direct-xml-expat/
10:00:59 <rwbarton> there will probably at least be a line that starts with some whitespace, followed by bar and then a word boundary
10:01:00 <dropdrive> monochrom: Line beginning with bar
10:01:03 <irene-knapp> if you want to actually run the thing
10:01:09 <dropdrive> mauke: Okay, what about '^bar[ =]'?
10:01:15 <rwbarton> f()=1
10:01:23 <Feuerbach> irene-knapp: what's this? ;) http://ireneknapp.com/software/darcs/direct-cocoa/TranslateAPI/Util.hs
10:01:25 <mauke> dropdrive: bar()=()
10:01:29 <rwbarton> also your entire module could be indented
10:01:31 <monochrom> you could write "  bar = 0"
10:01:46 <dropdrive> monochrom: Is that legal?
10:01:48 <rwbarton> also you could define   x `bar` y = x + y
10:01:49 <irene-knapp> Feuerbach, hahaha :D good catch lol
10:01:51 <monochrom> yes
10:01:56 <mauke> dropdrive: (bar) = ()
10:01:59 <mauke> dropdrive: ; bar = ()
10:02:06 <irene-knapp> Feuerbach, as you can see I found Prelude.error offensive to my eyes so I made my own more-explicit version of it lol
10:02:10 <irene-knapp> I had forgotten I'd done that
10:02:29 <irene-knapp> note that I explicitly make it a /fatal/ error
10:02:37 <irene-knapp> also, this is a program, not a library =p
10:02:50 <monochrom> and you should have worded "does it match the regex ^bar"
10:02:57 <dropdrive> rwbarton: When I indent, my module doesn't compile
10:03:01 <gavri> regarding question 5 here in the first set of exercises http://www.haskell.org/haskellwiki/Typeclassopedia how does one compose two functors? don't functors require concrete types to be made a concrete type?
10:03:15 <hpaste> applicative pasted “postcolonial” at http://hpaste.org/55954
10:03:18 <monochrom> indent every line
10:03:27 <fmapE> irene-knapp: I'm gonna look at your LibFFI code for now, I don't have any scraping code to compare to so I'll parse that later
10:03:36 <dropdrive> monochrom: Good point, yes...
10:03:41 <applicative> dropdrive, here's a valid module ^^^ no indentation at all
10:03:53 <irene-knapp> fmapE: yes, that was what I was expecting you would do :)
10:04:20 <monochrom> data X = X{bar :: ()}  also defines bar
10:04:42 <fmapE> aha so you aren't actually calling any Objective-C code, just runtime methods that give class info
10:04:50 <irene-knapp> exactly so
10:05:16 <Sgeo_> @src IO.mfix
10:05:17 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:05:17 <irene-knapp> mind, the ObjC ABI is the C ABI plus the runtime API
10:05:25 <irene-knapp> so this struct/double stuff will be the same
10:05:45 <gavri> what does "The composition of two Functors is also a Functor. True or False?" mean? how does one compose two functors?
10:06:21 <rwbarton> much like one would compose two functions
10:06:21 <monochrom> "Maybe (IO Int)" involves composing Maybe and IO
10:06:31 <fmapE> ok
10:06:36 <irene-knapp> what I basically did with regard to ownership of the structures that libffi wants is, I wrapped them in ForeignPtrs
10:06:52 <irene-knapp> in the case of structures which are followed by lists of other structures, though, it gets finicky
10:06:56 <gavri> monochrom: thanks. got it
10:07:20 <applicative> gavri, but to make a functor instance for it, within haskell you have to make a newtype wrapper, unless i'm in a sudden typical muddle
10:07:31 <byorgey> applicative: that's right
10:07:33 <Eduard_Munteanu> gavri: you could make a newtype wrapper for x |-> Maybe (IO x), and provide your own instance
10:07:39 <irene-knapp> I took the stance that each exposed Haskell type for these structs should be a single object, not containing foreign pointers that are invisible to the garbage collector, because that would mess things up
10:07:45 <irene-knapp> so I copy the information around
10:07:50 <byorgey> newtype Compose f g a = C (f (g a))
10:07:52 <fmapE> ok
10:08:01 <applicative> byorgey: gavri is solving the exercises in typeclassopedia
10:08:10 <byorgey> I know, I can tell =)
10:08:21 <c_wraith> I'd hope *you* could tell that
10:08:38 <irene-knapp> I honestly couldn't tell you what state this code is in, it's been a while since I worked on it :( it looks fairly clean and complete at a readthrough now, but I don't know :(
10:08:51 <applicative> gavri, byorgey is the author.
10:08:53 <gavri> omg, is that brent yorgey?
10:09:05 * byorgey bows
10:09:09 <monochrom> yes
10:09:17 <fmapE> ok
10:09:27 <gavri> byorgey: thanks for typeclassopedia
10:09:43 <byorgey> gavri: you're welcome, glad you find it useful
10:09:46 <fmapE> I haven't even tried to get structs working yet
10:09:49 <fmapE> but I plan on it soon
10:10:03 <irene-knapp> so a CIF by the way, this needs to be documented as I had forgotten and just looked it up, is libffi's name for the information on a particular function
10:10:05 * irene-knapp nods
10:10:17 <irene-knapp> feel free to make changes anywhere in my code and send me darcs patches :)
10:10:21 <fmapE> ok
10:10:22 <irene-knapp> you have my email? :)
10:10:26 <fmapE> yep
10:10:27 <irene-knapp> great
10:10:39 <irene-knapp> ah!  doorbell just rang.  afk now, that was good timing :)
10:10:52 <fmapE> k bye
10:11:02 <monochrom> the postman is delivering that email
10:14:57 <mm_freak> i have a GADT F :: * -> * -> *, where the first type argument is just a phantom type and fully determined by the constructor used
10:15:46 <mm_freak> at some places i want to make sure that a specific constructor is used, at other places i want to allow all possible constructors
10:16:18 <c_wraith> yes, it works for that.
10:16:28 <mm_freak> for the latter places i currently have a proxy type:  data FP a = forall p. FP (F p a)
10:16:44 <mm_freak> is there a solution, which doesn't require this proxy type?  CPS is not an option here
10:17:21 <c_wraith> can't you just do something like type FP a = F p a
10:17:35 <rwbarton> when the F is in negative position, you can use ordinary polymorphism
10:17:51 <c_wraith> Any use of an unconstrained type variable seems like it should suffice
10:18:00 <byorgey> c_wraith: that's not allowed
10:18:08 <byorgey> you get an error about p not being in scope.
10:18:11 <mm_freak> c_wraith: p wouldn't be in scope there
10:18:22 <c_wraith> That seems like an unnecessary restriction
10:18:31 <mm_freak> rwbarton: "negative position"?
10:18:34 <Eduard_Munteanu> What's the suggestion, a rank-2 type?
10:18:43 <rwbarton> to the left of (an odd number of) ->
10:18:52 <mm_freak> Eduard_Munteanu: currently i get along with existential quantification
10:19:06 <mm_freak> basically i deal with functions of this type:  F X a -> FP b
10:19:22 <rwbarton> e.g. forall a. FP a -> Int is the same as forall p a. F p a -> Int
10:20:10 <byorgey> yeah, but if you want an FP in a positive position like the example mm_freak just wrote, I don't think there's any way other than an existential wrapper
10:20:23 <Eduard_Munteanu> c_wraith: I guess it catches basic mistakes, though
10:20:55 <rwbarton> c_wraith: what would it be otherwise, dynamically scoped?
10:21:05 <c_wraith> rwbarton: free
10:21:07 <mm_freak> byorgey: it would be fine, if the functions weren't wrapped in a newtype, for which i define some instances
10:21:14 <c_wraith> rwbarton: err, not free
10:21:18 <rwbarton> free stuff is supposed to be listed among the parameters
10:21:32 <c_wraith> rwbarton: explicitly unreferrable
10:21:41 <c_wraith> which is the same as existential
10:22:00 <Eduard_Munteanu> c_wraith: do you mean like ordinary type sigs introduce foralls behind your back?
10:22:03 <Sgeo_> @djinn (a -> b -> c -> d -> e) -> d -> b -> c -> a -> e
10:22:03 <lambdabot> f a b c d e = a e c d b
10:22:24 <mm_freak> ok, thanks
10:22:34 <Sgeo_> @pl \a b c d e -> a e c d b
10:22:34 <lambdabot> flip . ((flip . (flip .) . flip) .) . flip
10:22:37 <saati> @. djinn pl a -> b -> c -> d -> e) -> d -> b -> c -> a -> e
10:22:38 <lambdabot> Cannot parse command
10:22:38 <lambdabot> Cannot parse command
10:22:38 <lambdabot> Cannot parse command
10:22:42 <saati> @. @djinn @pl a -> b -> c -> d -> e) -> d -> b -> c -> a -> e
10:22:43 <lambdabot> Plugin `compose' failed with: Unknown command: "@djinn"
10:22:53 <saati> @. pl djinn a -> b -> c -> d -> e) -> d -> b -> c -> a -> e
10:22:53 <lambdabot> Cannot parse command
10:22:54 <Eduard_Munteanu> I mean   type FP a = F p a   <=>   type FP a = forall p. F p a    going along with that suggestion.
10:23:03 <rwbarton> your ) is mismatched :P
10:23:12 <saati> @. pl djinn (a -> b -> c -> d -> e) -> d -> b -> c -> a -> e
10:23:12 <lambdabot> f = flip . ((flip . (flip .) . flip) .) . flip
10:23:18 <saati> rwbarton: thanks
10:23:37 <mm_freak> Eduard_Munteanu: but that's not existential anymore
10:23:40 <byorgey> Eduard_Munteanu: type FP a = forall p. F p a  is not allowed either.  You need a constructor for the existential to hide behind.
10:23:52 <rwbarton> it's not allowed?
10:23:54 <Sgeo_> Does anyone understand complex pl stuff like that?
10:24:00 <rwbarton> well, it's not what you want certainly
10:24:04 <byorgey> oh, sorry, yes, that is allowed but it's not an existential.
10:24:34 <byorgey> Sgeo_: define 'understand'.
10:24:51 <Sgeo_> Able to write, able to read, separately considered.
10:24:56 <Eduard_Munteanu> byorgey: oh, I don't mean an existential, but a higher rank type
10:25:15 <byorgey> Sgeo_: I would be capable of deriving it myself.  But I have no intuitive understanding of it just looking at it.
10:25:22 <Eduard_Munteanu> E.g. Foo -> FP a   would be   Foo -> (forall p. F p a)
10:25:52 <Sgeo_> Sometimes it really is better to just use a lambda I guess
10:26:20 <rwbarton> hopefully that point is well before flip . ((flip . (flip .) . flip) .) . flip!
10:26:22 <Eduard_Munteanu> Sgeo_: sure, lots of times
10:26:23 <byorgey> Eduard_Munteanu: but as I understand it, mm_freak wants an existentially quantified thing, not higher-rank
10:26:49 <byorgey> Sgeo_: indeed.
10:27:12 <Eduard_Munteanu> Yeah, it wasn't a suggestion, I was trying to understand what c_wraith said.
10:28:29 <carpi> ive been trying to generate a random number between 0 and the length of a list to randomly pick an element from a list.. but I can't figure out how to make it use a different StdGen value everytime I call the function
10:29:03 <carpi> thing is.. if i do randomNum (1,10) it might give say 4
10:29:05 <c_wraith> carpi: you have to pass a gen into the function.  Preferably make it polymorphic
10:29:09 <byorgey> carpi: the primitive functions for generating random numbers take a generator and return a random number along with a new generator.
10:29:50 <carpi> byorgey: c_wraith true..which means the first time I call the primitive random functions i have to provide a manually created StdGen value?
10:30:04 <c_wraith> carpi: doesn't have to be manually generated, *or* a StdGen
10:30:14 <Sgeo_> :k EitherT
10:30:15 <lambdabot>     Not in scope: type constructor or class `EitherT'
10:30:17 <c_wraith> carpi: it just needs to be passed in to the function
10:30:21 <Sgeo_> :k ErrorT
10:30:22 <lambdabot> * -> (* -> *) -> * -> *
10:30:27 <MostAwesomeDude> carpi: do { g <- getStdGen; return randomR (1, 10) g }
10:30:33 <MostAwesomeDude> :t randomR
10:30:34 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
10:30:37 <Sgeo_> :t ErrorT
10:30:38 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
10:31:24 <c_wraith> carpi: Please note that RandomGen is a typeclass, and you can use other random number generators than StdGen with the Random typeclass
10:31:26 <carpi> MostAwesomeDude: the IO primitives would be appropriate for my situation. But then i would have to change a lot of code upstream to accomodate the IO
10:32:06 <MostAwesomeDude> carpi: Well, since generators can't mutate in-place, you *must* operate in some state monad.
10:32:09 <carpi> I feel like this is such a severe limitation . I feel like haskell is constraining me to think in one and only one way. I maybe wrong.. its just my opinion
10:32:34 <MostAwesomeDude> Or use unsafePerformIO, but that's horribly icky.
10:32:41 <byorgey> carpi: it is! that's the point =)
10:32:51 <c_wraith> carpi: it's forcing you to think of functions as things that act only on their inputs
10:33:00 <MostAwesomeDude> (I know that some people view unsafePerformIO as the correct answer in this situation, but ugh.)
10:33:26 <byorgey> carpi: also, I really recommend using the MonadRandom package. It makes dealing with randomness so much nicer.
10:33:30 <byorgey> @package MonadRandom
10:33:30 <lambdabot> http://hackage.haskell.org/package/MonadRandom
10:33:31 <c_wraith> MostAwesomeDude: no one thinks unsafePerformIO is correct for this.  Because it's demonstrateably wrong.
10:33:52 <byorgey> however, it's good to get an idea of how things work at a lower level
10:33:57 <carpi> byorgey: is it available in prelude or a seperate package on Hackage
10:34:07 <byorgey> carpi: it's a package on Hackage.
10:34:39 <carpi> byorgey: but how is it going to be different from using the IO primitive of the Random module in prelude.. after all the IO is also a monad?
10:34:42 <Eduard_Munteanu> Rhyme time :P
10:35:13 <c_wraith> carpi: no, MonadRandom need not mean IO.  In fact, it's mostly defined around RandT, which is a kind of state monad
10:35:30 <byorgey> carpi: it handles threading generators around for you, so you don't have to explicitly deal with any StdGens or whatever
10:35:49 <Eduard_Munteanu> It's a PRNG after all, you don't need IO.
10:36:12 <Eduard_Munteanu> (just for seeding)
10:36:19 <carpi> byorgey: c_wraith so i can use MonadRandom in pure functions?
10:36:37 <c_wraith> carpi: not the way you think
10:36:55 <Sgeo_> :t liftIO . runErrorT
10:36:56 <lambdabot> forall (m :: * -> *) e a. (MonadIO m) => ErrorT e IO a -> m (Either e a)
10:37:01 <byorgey> carpi: every function in Haskell is pure.
10:37:16 <byorgey> carpi: you can use MonadRandom without using IO, if that's what you mean.
10:37:32 <byorgey> but then again you don't need MonadRandom to not use IO for random stuff.
10:38:06 <carpi> byorgey: I don't know if i can agree with that..even though i don't know much about Haskell. Because some articles i read say all functions are pure. some say all functions are pure but ones using monads have a different purity and some articles say haskell has pure and impure functions.. i don't know which is right
10:38:30 <monochrom> they are all right and all wrong
10:38:36 <byorgey> carpi: yeah, sadly there is no accepted terminology.  And it also depends on your point of view.
10:38:39 <c_wraith> carpi: if you want to use "random" numbers, you need to maintain PRNG state.  Haskell forces you to be aware of what's going on
10:38:57 <c_wraith> carpi: there isn't any way out of that, unless you're working in IO
10:39:02 <monochrom> at the end, there are a million different definitions of "pure"
10:39:14 <c_wraith> carpi: in which case, you can treat "the state of the universe" as your state
10:39:28 <byorgey> carpi: anyway, if you don't know which is right, I suggest you don't ask questions like "can I use X in pure functions" because no one will know what you mean (especially yourself). =)
10:39:30 <bss03> carpi: unsafePerformIO and friends (which are GHC--not in the Haskell spec.) are impure, definitely.
10:39:57 <c_wraith> bss03: unsafePerformIO is in the haskell2010 spec, as part of the FFI
10:40:17 <Eduard_Munteanu> Maybe you meant monadic functions, leaving purity aside.
10:40:31 <bss03> carpi: monadic functions still pass the purity tests: referential transparency.
10:40:33 <carpi> byorgey: the only reasons i ask questions like that is because.. the definition of what a pure function is.. is quite clear. its what a pure functions is not .. thats the problem..
10:41:09 <byorgey> carpi: it's not clear to me at all.  Again, it depends on your point of view and how you are using the term.
10:41:32 <MostAwesomeDude> carpi: Pure functions do not mutate state. Pure functions return the same output for given inputs, always. Those are the only conditions I know of.
10:41:35 <merijn> carpi: Aside from unsafePerformIO there are no impure functions (if by purity you mean referentially transparency)
10:41:51 <merijn> carpi: print and all other IO functions are pure too
10:41:58 <c_wraith> carpi: by any definition, a pure function cannot return different results when given the same arguments.  That means that any use of psuedo-random numbers must pass around the prng state
10:42:00 <Eduard_Munteanu> Emphasis on "mutate", or rephrase :D
10:42:03 <merijn> That's kinda the point of having monads...
10:42:29 <bss03> c_wraith: Which package, I can't find it.
10:42:31 <byorgey> that's not the point of having monads.  monads do not have a point.  they just are.
10:42:47 <merijn> byorgey: Ok, "that's the point of implementing IO as a monad"
10:42:51 <MostAwesomeDude> s/monads/ponies/g and reread.
10:43:08 <merijn> MostAwesomeDude: Ponies are a reason in and of themselves
10:43:17 <byorgey> merijn: agreed then.
10:43:18 <Eduard_Munteanu> (Since "state" can be confusing)
10:43:19 <c_wraith> bss03: FFI is part of base in GHC.  But the Haskell2010 spec isn't a package, it's a list of extensions that are mandated
10:43:37 <monochrom> carpi: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/95022  don't bother reading the text, just admire at how many messages there are. if you have only seen 3 conflicting stances, you have seen nothing
10:43:39 <MostAwesomeDude> merijn: Ponies make reasoning about computational pipelines easier.
10:43:45 <bss03> c_wraith: Haskell2010 also has a list of FFI packages.
10:43:57 <c_wraith> bss03: you mean modules?
10:43:57 <carpi> i think i will try working with the primitives in Random and if it doesn't work im try monad random.. however the confusion remains intact :( I think they will evaporate with time
10:43:59 <bss03> c_wraith: If it's not in any of those packages, it isn't in the FFI mandated by the spec.
10:44:02 <merijn> byorgey: Damn you haskellers and your forcing me to make my natural speech more explicit! >.>
10:44:15 <bss03> c_wraith: Sorry, yes, module.  Been thinking too much JAva recently.
10:44:21 <byorgey> merijn: =)
10:44:53 <merijn> MostAwesomeDude: "Dear Princess Celestia, today I learned that I might not be able to solve the Halting problem, but <insert valuable moral lesson here>."
10:45:33 <merijn> I'd totally watch that...
10:45:43 <MostAwesomeDude> merijn: "Dear Princess Celestia, today I learned that monads, while initially very complex and frightening, are actually very friendly and can help solve many difficult-to-express problems elegantly."
10:46:16 <MostAwesomeDude> Next step: Find a sextet of female VAs willing to talk about computation and start redubbing.
10:46:19 <merijn> Man, if I ever become filthy rich I know how I'll be blowing my money...
10:46:53 <bss03> "Dear Princess Celestia, today I wrote my first monad from scratch using phatom types to trick the type check into solving the halting problem, ..."
10:46:58 <c_wraith> bss03: section 8.4.3 says "Some external entities can be imported as pure functions", then gives an example.  The existence of that clause is sufficient to implement unsafePerformIO
10:47:32 <bss03> c_wraith: That doesn't make unsafePerformIO part of the spec.
10:47:41 <merijn> I'm not sure whether to be surprised or not by the seeming overlap of people who know MLP and functional programming >.>
10:47:57 <bss03> c_wraith: But, it is a reeferential opacity that you can drive a truck through.
10:48:06 <Eduard_Munteanu> MLP?
10:48:08 <monochrom> what is MLP?
10:48:11 <c_wraith> bss03: the name might not be part of the spec, but the functionality sure is.
10:48:28 <merijn> Eduard_Munteanu, monochrom: If you have to ask you're either to cool or not cool enough to know :>
10:48:30 <Eduard_Munteanu> Unless you're wondering why the seeming overlap is so small :P
10:49:12 <bss03> c_wraith: I'll give you that.  Any time you FFI import something as pure when it should really live in the IO Monad, Haskell is letting you break referential transparency.
10:49:53 <merijn> Eduard_Munteanu, monochrom: Anyhoo, it stands for My Little Pony >.>
10:50:14 <vhd> what does it mean when it is said a predicate is total? How can a predicate not be total?
10:50:24 <MostAwesomeDude> Hey, are there any useful tools for creating/accessing annotations on types or values? I want to annotate a minority of constructors with some data to make it easier to process special cases during my computation.
10:50:30 <bss03> > head []
10:50:30 <lambdabot>   *Exception: Prelude.head: empty list
10:50:33 <c_wraith> vhd: it means that it doesn't produce output for some input
10:50:41 <MostAwesomeDude> I already have lots of record types floating around, and I was wondering if I could somehow cut down on some of those.
10:50:42 <bss03> vhd: ^^ head is not total.
10:50:47 <Eduard_Munteanu> Heh, didn't know what that was.
10:50:57 <vhd> hmm so is it the same is when a function is called strict?
10:50:59 <c_wraith> vhd: like, say...  p (Just x) = x == "hello"
10:51:00 <bss03> > fromJust Nothing
10:51:00 <lambdabot>   *Exception: Maybe.fromJust: Nothing
10:51:06 <bss03> vhd: ^^ fromJust is not total.
10:51:11 <byorgey> vhd: no.
10:51:21 <Eduard_Munteanu> Although many of the other alternatives listed on Wikipedia are just as absurd :D
10:51:30 <bss03> vhd: No, totallity and strictness aren't the same.
10:51:54 <vhd> ok bss03 what should I be putting in google to read up on this stuff?
10:52:00 <bss03> vhd: "id" is total, but strict.
10:52:07 <monochrom> vhd: what is the context?
10:52:25 * monochrom always asks "what is the context?" and it is always prudent
10:52:53 <bss03> vhd: I think there's a good explanation of strictness in the Haskell wikibook.
10:52:55 <monochrom> most #haskell answerers would make superb manager types
10:52:59 <Eduard_Munteanu> monochrom isn't human? :)
10:53:01 <sanjoyd> Is there something like tryRead?  That tells me whether a String can be parsed into some type or not?
10:53:09 * Eduard_Munteanu is prudent about that "it"
10:53:14 <vhd> ok I will check that out
10:53:18 * monochrom isn't human
10:53:38 <monochrom> but the "it" refers to the question, not to monochrom
10:53:51 <Eduard_Munteanu> Oh, oops.
10:53:52 <monochrom> or refers to the act of asking that question
10:53:55 <bss03> vhd: I'm not sure about totallity.  To determine if a function is total, I always read the documentation / definition.
10:54:10 <vhd> hmm ok
10:54:25 <bss03> sanjoyd: Use "reads" instead of "read"  to get a list of successes.
10:54:50 <bss03> > reads "123" :: [(Int, String)]
10:54:51 <lambdabot>   [(123,"")]
10:54:58 <bss03> > reads "1a2c3" :: [(Int, String)]
10:54:59 <lambdabot>   [(1,"a2c3")]
10:55:17 <bss03> > reads "zero" :: [(Int, String)]
10:55:18 <lambdabot>   []
10:55:24 <sanjoyd> bss03: thanks!
10:56:56 <merijn> > reads "1-2" :: [(Int, String)]
10:56:57 <lambdabot>   [(1,"-2")]
10:57:07 <merijn> @src reads
10:57:07 <lambdabot> reads = readsPrec minPrec
10:57:10 <Sgeo_> maybeRead = fst . listToMaybe . reads ?
10:57:24 <Sgeo_> Wait, no
10:57:55 <dolio> fmap fst
10:57:56 <ion> listToMaybe . map fst . filter (null . snd) . reads
10:58:01 <Sgeo_> maybeRead r = fst <$> (listToMaybe . reads) r)
10:58:25 <Sgeo_> :t fst <$> listToMaybe . reads
10:58:26 <lambdabot>     Couldn't match expected type `(a, b)'
10:58:26 <lambdabot>            against inferred type `Maybe a1'
10:58:26 <lambdabot>     In the first argument of `(.)', namely `listToMaybe'
10:58:43 <Sgeo_> :t \r ->fst <$> (listToMaybe . reads $ r)
10:58:44 <lambdabot> forall a. (Read a) => String -> Maybe a
10:59:06 * Sgeo_ thinks something could be done with two fmaps, but not sure what
10:59:33 <conal> Sgeo_: move the fmap fst into the composition, and drop the r
11:00:04 <Sgeo_> :t fmap fst . listToMaybe . reads
11:00:05 <lambdabot> forall a. (Read a) => String -> Maybe a
11:00:12 <conal> it helps to think of fmap as unary rather than binary
11:00:21 <Sgeo_> ty
11:00:23 <ion> listToMaybe . map fst . filter (null . snd) . reads :-P
11:00:33 <chemistree> S
11:00:43 <Sgeo_> Although I guess I feel more comfortable with <$> usually since it "feels" more generic, as in its use for simple applicatives
11:01:14 <ion> fmap *is* (<$>)
11:01:15 <hpc> agreed; fmap feels too "container"-y
11:01:45 * Sgeo_ is aware that fmap is <$>
11:02:00 <c_wraith> interesting...  infix operator names are inherently more abstract
11:02:03 <hpc> ion: just because (fmap fix return) == id, doesn't mean they should be interchangable
11:02:39 <ion> They’re the same by definition.
11:02:47 <chemistree> what browser  are you all using for this IRC?
11:02:48 <hpc> ion: stylistically
11:03:00 <Sgeo_> chemistree, many of us are not using browsers to access IRC
11:03:07 <chemistree> irssi?
11:03:22 * Eduard_Munteanu incidentally uses irssi
11:03:32 <Sgeo_> Things like irssi are called IRC clients, not browsers.
11:03:38 <Sgeo_> Some use irssi, I'm using XChat
11:03:48 <merijn> My browser has a built in IRC client, does that count? :>
11:03:53 <chemistree> so you run Irssi through your terminal? Or something like that?
11:04:04 <Sgeo_> merijn, Opera?
11:04:09 <merijn> Sgeo_: Yeah
11:04:10 <chemistree> Merijn: what browser?
11:04:13 <chemistree> ah
11:04:26 <Sgeo_> oops
11:04:45 <merijn> Anyhoo, I should go and leave so I can actually go back to work rather than procrastinating here
11:05:15 <Eduard_Munteanu> @google list of irc clients
11:05:16 <lambdabot> http://en.wikipedia.org/wiki/Comparison_of_Internet_Relay_Chat_clients
11:05:16 <lambdabot> Title: Comparison of Internet Relay Chat clients - Wikipedia, the free encyclopedia
11:07:15 <chemistree> sgeo_: are you one of the 12 users refered to here http://forum.xchat.org/ ?
11:07:40 <chemistree> under username
11:07:52 <chemistree> ^^^ who is online
11:07:55 <Sgeo_> I'm not a member of those forums
11:07:58 <The_Journey> do state monads actually change states or are they just syntactic sugars?
11:08:19 <Sgeo_> The online users stuff is only people on that forum
11:08:26 <Sgeo_> It's entirely independent of actual XChat usage
11:08:45 <Sgeo_> The_Journey, stateful computations are actually functions
11:08:46 <hpc> The_Journey: have you learned what monads are?
11:09:08 <Sgeo_> do notation is syntactic sugar, but state is ... a way of thinking about it
11:09:18 <Sgeo_> Nothing is actually mutated in the State monad
11:09:20 <nh2> what library function shall I use for integer log2?
11:09:41 <hpc> @hoogle logBase
11:09:42 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
11:09:53 <Sgeo_> >logBase 100 10
11:09:59 <Sgeo_> > logBase 100 10
11:10:00 <lambdabot>   0.5
11:10:03 <Sgeo_> > logBase 10 100
11:10:04 <lambdabot>   2.0
11:10:21 <Sgeo_> > logBase 2 1677216
11:10:22 <lambdabot>   20.67763706744639
11:10:25 <Sgeo_> oops
11:10:30 <hpc> nh2: logBase will work well enough, unless you need lots of precision or you are using pathologically large numbers
11:10:39 <Sgeo_> > logBase 2 65536
11:10:41 <lambdabot>   16.0
11:10:44 <hpc> > logBase (2 ** 128 + 1) :: CReal
11:10:45 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
11:10:45 <lambdabot>         against infe...
11:10:52 <hpc> > logBase 2 (2 ** 128 + 1) :: CReal
11:10:53 <lambdabot>   128.0000000000000000000000000000000000000042
11:11:03 <Eduard_Munteanu> Presumably it could be optimized for integer log 2.
11:11:08 <nh2> hpc: I'm using Integer, so they can potentially be big (I fear floating point precision)
11:11:09 <Eduard_Munteanu> *base 2
11:11:14 <nh2> there is one in some ghc-internal part that claims it is fast (I guess it uses one of the "first 1" instructions), but I wondered if there is a higher level one
11:11:22 <The_Journey> the way that the state monad is presented in LYAH seems to be like a shortcut instead of changing actual states
11:11:35 <nh2> I'm talking of http://www.haskell.org/ghc/docs/7.2.2/html/libraries/integer-gmp-0.3.0.0/GHC-Integer-Logarithms.html
11:11:37 <hpc> nh2: use CReal; the worst that happens is you try and logBase a number <= 0 and get nontermination
11:11:39 <Sgeo_> The_Journey, there is no such thing as "changing"
11:11:52 <Eduard_Munteanu> The_Journey: it is a way to abstract threading the state yourself
11:12:00 <hpc> which would be an error anyway, so you don't lose any stability
11:12:20 <hpc> it's slow, but as precise as you want it to be
11:13:34 <hpc> @hoogle era
11:13:35 <lambdabot> Foreign.C.Error eRANGE :: Errno
11:13:35 <lambdabot> System.Posix.Terminal Erase :: ControlCharacter
11:13:35 <lambdabot> Prelude interact :: (String -> String) -> IO ()
11:14:44 <hpc> http://darcs.augustsson.net/Darcs/CReal/ -- site is being slow, might be down
11:15:14 <conal> conceivably, a clever compiler could recognize the sort of computations that State captures and implement them with mutation, aka "compile-time garbage collection".
11:15:44 <hpc> conal: haha, i never made that connection between mutation and GC
11:16:05 <conal> i rarely hear about research along those lines anymore. used to be a popular topic.
11:16:52 <cobra-the-joker> conal, what research and what lines ?
11:16:53 <hpc> probably because more focus is going into the GC itself
11:17:02 <alistra> hpc: i'll help the site by opening another connection
11:17:04 <Sgeo_> :t mfix
11:17:05 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:17:07 <Sgeo_> :t fixIO
11:17:07 <lambdabot> Not in scope: `fixIO'
11:17:20 <Sgeo_> Are there any good examples of mfix in IO?
11:17:21 <hpc> so the gains of mutation analysis would be less now than they used to
11:17:35 <hpc> @hoogle sqlite memo
11:17:36 <lambdabot> No results found
11:17:47 <hpc> Sgeo_: there's an sqlite memoization package on hackage
11:17:52 <alistra> @src fix
11:17:52 <lambdabot> fix f = let x = f x in x
11:18:04 <conal> cobra-the-joker: compiling purely functional code into code that mutates representations rather than using allocation + deallocation/GC.
11:18:05 <hpc> it uses fixIO to memoize recursive functions
11:18:14 <Eduard_Munteanu> It's quite unfortunate, since people often have to resort to rewriting stuff in e.g. ST to optimize by introducing mutation.
11:18:40 <cobra-the-joker> aha
11:18:48 <conal> cobra-the-joker: shifting allocation/deallocation from run-time to compile-time.
11:18:54 <mercury^> Did everyone else also get CTCP VERSION from Sgeo_ ?
11:18:59 <hpc> no
11:19:16 <Sgeo_> mercury^, no, I accidentally VERSIONed you because I mis-tab-completed someone else's nick
11:19:27 <Eduard_Munteanu> Well, actually selectively removing collection at compile-time, rather than adding it, I guess.
11:19:29 <Sgeo_> Hence the oops
11:19:54 <Eduard_Munteanu> Like "hey, we don't need to create this object, just overwrite..."
11:20:23 <conal> by noticing last-use
11:21:06 <Eduard_Munteanu> conal: I remember region inference was put down as well, at least in the context of languages like Haskell.
11:21:39 <conal> i recently played with that sort of analysis in deriving a fast CUDA parallel scan algorithm from its purely functional specification.
11:21:59 <conal> which is pretty important since CUDA programs don't allocate or deallocate.
11:22:28 <conal> Eduard_Munteanu: ah, yeah. related.
11:25:15 <conal> i sometimes wonder whether physical reality is doing this same compile-time GC hack. implementing a purely functional / math spec via mutation. with temporal unidirectionality as an abstraction leak.
11:29:32 <Eduard_Munteanu> Heh, hm. I'm still hoping we can do better than purely runtime GC approaches. As straightforward as it is, it still gets researchy when you get to realtime GC.
11:29:40 <Eduard_Munteanu> (for example)
11:30:02 <eyebloom> How are folds normally denoted with math symbols? Is it a special variation of the sum symbol?
11:31:07 <conal> eyebloom: enlarging the symbol and placing some sort of subscripting below it, generalizing the common Sigma and Pi notations
11:31:27 <conal> eyebloom: e.g., intersection & union.
11:31:28 <Saizan> i thought it was banana brackets
11:32:07 <eyebloom> I see.
11:32:36 <Saizan> http://en.wikipedia.org/wiki/Catamorphism#Notation
11:32:51 <teneen> What's the precedence level and associativity of backticks?
11:33:52 <hpc> infix 5, iirc
11:34:05 <c_wraith> teneen: it can be set by infix declarations, though
11:34:24 <ion> > let plus = (+); times = (*); infixl 7 `plus`; infixl 6 `times` in 2 `times` 3 `plus` 4
11:34:24 <lambdabot>   14
11:34:54 <c_wraith> nice job making the precedences confusing, ion. :)
11:35:04 <teneen> hpc: what's iirc?
11:35:13 <hpc> "if i recall correctly"
11:35:23 <ion> @google iirc
11:35:23 <lambdabot> http://iirc.niu.edu/
11:35:23 <lambdabot> Title: Illinois Interactive Report Card
11:35:28 <eyebloom> So in LaTex that would be \sum_{\cup}^S to describe the union of all the elements of a set of sets S.
11:36:04 <teneen> hpc: ok thanks
11:36:11 <teneen> hpc: but what about the associativity
11:36:20 <teneen> hpc: what's the default?
11:36:54 <Sgeo_> > let minus = (-) in 1 `minus` 2 `minus` 3
11:36:55 <lambdabot>   -4
11:36:56 <hpc> default is no associativity (mixing associativities is a syntax error)
11:37:03 <conal> eyebloom: a big \cup and no sigma.
11:37:10 <hpc> > let plus = (+) in 5 `plus` 5 + 5
11:37:11 <lambdabot>   15
11:37:24 <hpc> > let plus = (+); times = (*) in 5 `plus` 5 `times` 5
11:37:25 <lambdabot>   50
11:37:28 <hpc> hmm
11:37:34 <hpc> perhaps i am mistaken
11:37:43 <KorriX> what exactly mean 'in' operator ?
11:37:49 <Sgeo_> KorriX, not in. let/in
11:37:54 <eyebloom> Ok what if \cup is a more specific function like graph merging.
11:37:57 <Eduard_Munteanu> I wonder, is there proper terminology to distinguish the definitional idea of associativity vs associativity as a property?
11:37:57 <KorriX> okay :D
11:38:17 <hpc> KorriX: "let definitions in expression" -- the definitions are local to the expression after "in"
11:38:28 <KorriX> i know that
11:38:28 <eyebloom> create symbol for that I guess like "&" and make it large.
11:38:34 <KorriX> but i forgotten about 'let' :D
11:39:16 <KorriX> > [1,2,3] >>= \x -> [x,x]
11:39:17 <lambdabot>   [1,1,2,2,3,3]
11:39:24 <KorriX> bind operator is crazy :)
11:39:36 <hpc> the list monad is crazy
11:39:40 <hpc> bind is a walk in the park :P
11:39:56 <conal> eyebloom: whatever binary symbol you use, but bigger. i'm describing one math notation convention i've seen. like much math notation, it's not terribly consistent or unambiguous.
11:40:01 <Sgeo_> Does lambdabot have LogicT?
11:40:10 <KorriX> but i don't understand how bind operator works with list
11:40:17 <teneen> hpc: with "no associativity" are things just evaluated from left to right in order?
11:40:34 <KorriX> and how it is possible that result is not [[1,1],[2,2], ...]
11:40:42 <KorriX> like with:
11:40:55 <KorriX> > [1,2,3] >>= \x -> (x,x)
11:40:55 <Sgeo_> KorriX,
11:40:56 <lambdabot>   Couldn't match expected type `[b]' against inferred type `(t, t)'
11:40:57 <hpc> teneen: i suggest ignoring everything i said about associativity :P
11:41:18 <Sgeo_> > infix 5 +; 1 + 2 + 3
11:41:19 <lambdabot>   <no location info>: parse error on input `infix'
11:41:27 <eyebloom> Right. I'm maybe looking for suggestions. Could anyone point me to the Latex version of a paper with lots of haskel like function definitions?
11:41:30 <Sgeo_> Ok, that doesn't work
11:41:46 <Sgeo_> > let infix 5 + in 1 + 2 + 3
11:41:47 <lambdabot>   The fixity declaration for `+' lacks an accompanying binding
11:41:47 <lambdabot>    (You cannot...
11:42:12 <Sgeo_> > let plus = (+); infix 5 `plus` in 1 `plus` 2 `plus` 3
11:42:13 <lambdabot>   Precedence parsing error
11:42:13 <lambdabot>      cannot mix `plus' [infix 5] and `plus' [infix...
11:42:18 <Sgeo_> KorriX, ^^
11:42:36 <Sgeo_> Oh wait, not KorriX. teneen
11:42:52 <KorriX> no problem :)
11:43:04 <teneen> Sgeo_: nice
11:43:10 <KorriX> i have problem with understanding higher order classes
11:43:15 <teneen> Sgeo_: so things with no associativity cannot be evaluated?
11:43:26 <Sgeo_> teneen, not if they're mixed with... uh.. hmm
11:43:31 <KorriX> Functior is logical, but Monad and Associative is crazy
11:43:35 <Sgeo_> Not if they're mixed with things of no associativity
11:43:40 <Sgeo_> Hmm
11:43:56 <Sgeo_> > let plus = (+); infix 5 `plus` in 1 `plus` 2 + 3
11:43:57 <lambdabot>   6
11:43:58 <Eduard_Munteanu> teneen: you have to associate it yourself
11:44:02 <Taos> why does
11:44:05 <Sgeo_> > let plus = (+); infix 5 `plus` in 1 + 2 `plus` 3
11:44:06 <Taos> 3 `mod` 3 == True
11:44:06 <lambdabot>   6
11:44:08 <Taos> not behave right?
11:44:16 <Eduard_Munteanu> As in, use parantheses.
11:44:18 <Sgeo_> > 3 `mod` 3 == True
11:44:19 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
11:44:19 <lambdabot>    arising from a use of ...
11:44:27 <Sgeo_> > (3 `mod` 3) == True
11:44:27 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
11:44:28 <lambdabot>    arising from a use of ...
11:44:34 <Sgeo_> Oh, duh
11:44:38 <Sgeo_> > 3 `mod` 3
11:44:39 <c_wraith> Taos: mod doesn't return a Bool unless 3 is a Bool
11:44:39 <lambdabot>   0
11:44:40 <hpc> > 0 == 0 == True
11:44:41 <lambdabot>   Precedence parsing error
11:44:41 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
11:44:51 <Taos> damn
11:44:51 <hpc> > True == 0 == 0 -- which is which?!
11:44:52 <lambdabot>   Precedence parsing error
11:44:52 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
11:45:22 <Taos> how can I do that statement then?
11:45:28 <c_wraith> change True to 0
11:45:35 <Sgeo_> > 3 `mod` 3 == 0
11:45:36 <Taos> wait what?
11:45:36 <lambdabot>   True
11:45:39 <Taos> mkay
11:45:44 <Sgeo_> Taos, mod returns a number
11:45:49 <Taos> Ah
11:45:50 <Sgeo_> So compare against a number
11:45:50 <Taos> Right
11:46:13 <int-e> Sgeo_: in what sense does that `plus` example not behave correctly?
11:46:30 <ion> > let f = (+); g = (+); infix 5 `g` in 1 `f` 2 `g` 3  -- The error message seems to reveal the default infixity.
11:46:30 <Sgeo_> int-e, I was just pondering how infixl and infix would interact
11:46:31 <lambdabot>   6
11:46:37 <int-e> > let plus = (-); infix 6 `plus` in 1 `plus` 2 + 3
11:46:38 <lambdabot>   Precedence parsing error
11:46:38 <lambdabot>      cannot mix `plus' [infix 6] and `GHC.Num.+' [...
11:46:38 <ion> err
11:46:52 <int-e> Sgeo_: wrong precedence then, + has 6.
11:46:59 <Sgeo_> int-e, Oh!
11:47:19 * Sgeo_ should stay far away from precedence issues.
11:47:23 <Sgeo_> Smalltalk's nice like that.
11:47:36 <Taos> smalltalk is scary
11:47:43 <Sgeo_> Very easy to understand precedence.
11:47:46 <Eduard_Munteanu> You give precedence as a partial order?
11:48:00 <hpc> Taos: it's easy; first you talk about the traffic, then the weather
11:48:01 <Eduard_Munteanu> (That'd be one alternative.)
11:48:06 <Sgeo_> + * / are all same precedence
11:48:22 <Taos> So tehre is no else than in haskell?
11:48:24 <Taos> creepy
11:48:29 <Sgeo_> Taos,
11:48:40 <Sgeo_> > if 1==1 then "Hi" else "Math broke boo"
11:48:41 <lambdabot>   "Hi"
11:49:08 <Taos> yea but no elseif ?
11:49:11 <Taos> if elseif else
11:49:18 <c_wraith> > let _ == _ = False in if 1==1 then "Hi" else "Math broke boo"
11:49:19 <lambdabot>   "Math broke boo"
11:49:19 <Sgeo_> > if 1==2 then "o.O" else if 3==4 then "o.O" else "Whew"
11:49:20 * hackagebot copilot-core 0.2.2 - An intermediate representation for Copilot.  http://hackage.haskell.org/package/copilot-core-0.2.2 (LeePike)
11:49:20 <lambdabot>   "Whew"
11:49:25 <hpc> Taos: use guards
11:49:30 <Taos> hm
11:50:07 <Sgeo_> > case () of () | 1==2 -> "o.O" | 3==4 -> "Still o.O" | otherwise -> "Whew"
11:50:07 <lambdabot>   "Whew"
11:50:51 <Sgeo_> I don't know if that's the best way to do things
11:51:08 <ion> > let f = (+); g = (+); infix 9 `g` in 1 `f` 2 `g` 3  -- Ah, it had to be 9.
11:51:09 <lambdabot>   Precedence parsing error
11:51:09 <lambdabot>      cannot mix `f' [infixl 9] and `g' [infix 9] i...
11:51:19 <bss03> Anyone have much experience with ExistentialQuantification?
11:51:31 <bss03> I'm thinking I might need ConstraintKinds, too.
11:52:13 <c_wraith> bss03: what are you trying to declare?
11:52:31 <bss03> I have a data structure: data SF a = U (UF Zero a) | forall r. S (ST r a) (ST r a) (UF (Succ r) a)
11:52:37 <Sgeo_> http://codepad.org/2wFRLjFd
11:52:46 <Sgeo_> I tried to move the () to the first line, but got an error :(
11:53:05 <Sgeo_> http://codepad.org/FSFqKuy1
11:53:31 <bss03> But, I also need to be able to write a function of type SF a -> UF Zero a, and I think the typechecker is going to bite me.
11:54:06 <c_wraith> You're doing some sort of type-level arithmetic here?
11:54:22 * hackagebot copilot-language 0.2 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.2 (LeePike)
11:54:24 * hackagebot copilot-libraries 0.2 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-libraries-0.2 (LeePike)
11:54:26 * hackagebot copilot-sbv 0.2 - A compiler for CoPilot targeting SBV.  http://hackage.haskell.org/package/copilot-sbv-0.2 (LeePike)
11:54:28 * hackagebot copilot-c99 0.2.2 - A compiler for Copilot targeting C99.  http://hackage.haskell.org/package/copilot-c99-0.2.2 (LeePike)
11:54:30 * hackagebot copilot-cbmc 0.2 - Copilot interface to a C model-checker.  http://hackage.haskell.org/package/copilot-cbmc-0.2 (LeePike)
11:54:43 <bss03> Because, I can't write that in a truely "forAll r." manner.  I can only handle the case when r = Succ (... (Succ Z)).
11:55:09 <dgpratt>  teaching my 10 year old daughter some Haskell; she's quite enamoured with it :)
11:55:09 <bss03> c_wraith: I'm trying to adapt something used by the pqueue package.
11:55:24 <c_wraith> bss03: indeed, you'd be happiest with PolyKinds and GADTs
11:55:33 <c_wraith> since that's exactly what they're for
11:55:44 <bss03> c_wraith: In that package they do BinomialTrees, but have the rank at type level.
11:55:46 <zachk> dgpratt: what are you teaching her?
11:56:02 <c_wraith> at the very least, GADTs would help
11:56:18 <dgpratt> zachk: we're making a penguin with gloss
11:56:25 <c_wraith> because GADTs give you the ability to constrain the types associated with constructors
11:56:50 <bss03> c_wraith: I'm trying to do the same for SkewBinomialTrees, in this case for the forest.
11:57:26 <c_wraith> dgpratt: sounds like you're using haskell as Logo then.  Not a bad idea, for teaching.  Logo was awesome.
11:57:41 <MasterPrime> Okay. So, I'm going to learn haskell. I'm a learn by doing kind of guy. I've found information sticks best when I do something real vs. something theoretical. The plan is to update a project that is a little out of date. I've been told it should be simple enough.
11:58:06 <dgpratt> c_wraith: yes; I was inspired by the stuff cdsmith was doing with school-age kids
11:58:11 <MasterPrime> So if someone could just give me a quick explanation of the blocks of code here: https://github.com/FalconNL/mc2obj/blob/master/BlockDefs.hs I should be able to continue on my own for a little.
11:58:21 <hpc> MasterPrime: you might learn better by starting a simple project from scratch; something that you can add onto as you learn more
11:59:52 <hpc> MasterPrime: that code smells like minecraft
11:59:59 <bss03> MasterPrime which block of code, that paste is a bit long.
12:00:34 <hpc> MasterPrime: first it imports IntMap and IntSet (a set of ints, and a map with int keys)
12:00:40 <hpc> then it defines some type aliases
12:00:49 <MasterPrime> well the whole thing really. I'm starting from 0 with haskell. just need a crash course to get me moving.
12:00:58 <bss03> hpc: Smells of minecraft -- does minecraft have cake and portals?
12:01:04 <hpc> which imo should be data declarations
12:01:07 <hpc> bss03: yes
12:01:08 <MasterPrime> bss03: yes
12:01:40 <MasterPrime> and it is MC. it's to export chunks to an OBJ file but keeping the geometry.
12:02:33 <MasterPrime> so I understood the first part with the importing and defining. but things like lines 8 and 9
12:02:55 <bss03> MasterPrime: Those are type aliases.
12:03:18 <c_wraith> MasterPrime: you *really* should use something else as a resource for the basic syntax of haskell.
12:03:31 <c_wraith> which isn't to say you can't play with that code while you're learning
12:03:44 <c_wraith> But you should have another resource on-hand for basic syntax questions
12:03:46 <MasterPrime> The thing is, I don't plan on using haskell outside of this project.
12:03:49 <bss03> MasterPrime: Line 8 says whenever I type "Face" I mean "A list of 3-tuples of a Vertex, a TextureCoordinate, and a Vertex".
12:03:58 <hpc> that code is very poor style imo
12:04:00 <MasterPrime> nobody else wants to pick it up and it's a really handy tool.
12:04:20 * hackagebot copilot 2.0.2 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0.2 (LeePike)
12:04:22 * hackagebot copilot-cbmc 0.22 - Copilot interface to a C model-checker.  http://hackage.haskell.org/package/copilot-cbmc-0.22 (LeePike)
12:04:32 <hpc> @where lyah
12:04:33 <lambdabot> http://www.learnyouahaskell.com/
12:04:33 <bss03> MasterPrime: [a] = list of a
12:04:45 <MasterPrime> so unless I can find some bored haskell hacker that wants a side project, I've gotta do it.
12:04:57 <hpc> MasterPrime: read learnyouahaskell - it's the best resource for beginners, and i don't just say that because i got the book for free :P
12:05:23 <bss03> MasterPrime: Line 9 uses the convention a -> b = function taking something of type a and returning something of type b.
12:06:13 <MasterPrime> that I know. the part that confuses me is the 'a'
12:06:47 <c_wraith> MasterPrime: also, don't underestimate the fact that haskell is *different*.  It's not just a new syntax for C.
12:07:09 <MasterPrime> Oh I get that it's different. I'm not a programmer but I can at least read C and figure out what's happening.
12:07:50 <MasterPrime> haskell has always felt like being dropped on an alien planet and trying to talk to people when I look at the source.
12:07:51 <bss03> MasterPrime: There's no "a" on line 9.  For now you can treat "a" and "b" in my statement above as meta-syntatic variables.  Imagine I used "foo" and "bar" instead of "a" and "b", resp.
12:08:55 <MasterPrime> [(  0, \_ _  -> []) <-----what is this doing. it's like a chatbot got confused and merged a bunch of different emoticons.
12:10:07 <c_wraith> it's doing several different things
12:10:13 <c_wraith> it's starting a list of pairs
12:10:19 <c_wraith> it contains the first pair in the list
12:10:25 <c_wraith> the first value in the pair is 0
12:10:30 <bss03> MasterPrime: "\_ _ -> []" means an anonyumous function "\" of two arguments that I don't care about "_ _" that returns "->" an empty list "[]".
12:10:31 <c_wraith> the second is an anonymous function
12:10:50 <conal> btw, that second value could be written "mempty"
12:11:10 <conal> i can't help seeing stuff like that.
12:11:10 <c_wraith> hmm.
12:11:11 <geheimdienst> MasterPrime: (42,37) is a tuple with 2 things in it, and "\_ _ -> []" is a lambda (function) that takes 2 arguments, doesn't care about them, and gives an empty list. another lambda that does care about its args would be e.g. "\x y -> x + (2 * y)"
12:11:27 <c_wraith> > mempty `asTypeOf` \_ _ -> []
12:11:28 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1 -> [a])
12:11:28 <lambdabot>    arising from a ...
12:11:32 <c_wraith> :t mempty `asTypeOf` \_ _ -> []
12:11:33 <lambdabot> forall t t1 a. (Monoid (t -> t1 -> [a])) => t -> t1 -> [a]
12:12:04 <c_wraith> ...  That's the second time I've seen lambdabot spit out a strangely spurious constraint
12:12:43 <Sgeo> What's spurious about it?
12:12:46 <Sgeo> :t mempty
12:12:47 <lambdabot> forall a. (Monoid a) => a
12:13:04 <Sgeo> mempty is only defined on Monoids
12:13:21 <c_wraith> in order to unify, that instance already has to be in scope
12:13:25 <Sgeo> You're asking for an mempty of type (a -> b -> [c])
12:13:39 <bss03> Usually lambdabot drops instances that are in scope.
12:13:47 <rwbarton> > mempty 1 2 :: [Int]
12:13:48 <lambdabot>   []
12:14:02 <rwbarton> maybe it's not in scope for :t?
12:14:04 <Eduard_Munteanu> Hm... that Copilot thingy and similar stuff looks interesting, but I kinda wonder... has anybody seriously used it for smaller MCUs, like your ordinary PICs/AVRs?
12:14:07 <MasterPrime> so the next line is the second item in a list with a value 1 is an anonymous function with 1 argument that it doesn't care about and gives a type block named stone?
12:14:08 <bss03> :t fmap `asTypeOf` (.)
12:14:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:14:15 <Sgeo> o.O I was unaware that functions were monoids
12:14:19 <Sgeo> *some functions
12:14:34 <c_wraith> MasterPrime: all the items in the list need the same type.  So the function must take two parameters
12:14:38 <bss03> Sgeo: functions that return monoids are monoids.
12:14:57 <MasterPrime> and those parameters are defined in \_ _?
12:14:58 <hpc> yo dawg?
12:15:02 <Eduard_Munteanu> I mean, yeah, I can see that sort of stuff running on an ARM, but on the former kind of MCUs resources are rather tight.
12:15:22 <bss03> MasterPrime: Not quite, 'block "Stone"' returns a function of one argument.
12:15:24 <c_wraith> MasterPrime: ah, that's sneaky.  it's using currying.  block takes two arguments
12:15:30 <drull95> there ought to be a program that lets you learn by doing
12:15:39 <MasterPrime> ^every program
12:15:55 <MasterPrime> I'm much better with adobe creative than I am with programming.
12:16:05 <Cale> Sgeo: some function types* were monoids
12:16:12 <tulcod> if i have a Point2D type with a Cartesian2D constructor, and I would make a function which would return a Point2D based on polar coordinates, would that be fundamentally different from a value constructor?
12:16:50 <drull95> well i mean one containing brief descriptions of syntax as they are first used, then some common patterns and then some functions which are deliberately a bit short of what's wanted
12:17:17 <Eduard_Munteanu> tulcod: fundamentally yes, but maybe you want to know about practical aspects?
12:17:17 <drull95> one that's meant to be finished
12:17:18 <MasterPrime> drull95: codeacademy.com does that with javascript
12:17:43 <tulcod> Eduard_Munteanu: whatever useful you have to say about the matter :)
12:17:59 <tulcod> i'm just trying to understand the type system
12:18:38 <tulcod> because in Real World Haskell, it is mentioned that value constructors can be seen as a function - my question is then, whether they are "just functions"
12:18:38 <Eduard_Munteanu> tulcod: well your other functions manipulating points will have to pattern-match on the polar coords constructor if you use different constructors.
12:19:06 <hpc> tulcod: could you give some code? it's hard to see what you are asking
12:19:06 <Cale> tulcod: Value constructors which have parameters are all functions.
12:19:21 * hackagebot copilot 2.0.3 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0.3 (LeePike)
12:19:37 <Cale> tulcod: you can use them like any other function, but you're additionally allowed to pattern match against them (which is what makes them constructors)
12:19:37 <tulcod> Cale: so are all functions which have parameters and return objects of a certain type value constructors?
12:20:17 <Cale> tulcod: If you see a function whose name starts with an uppercase letter (or a colon, if it's infix), that's a constructor
12:20:18 <Eduard_Munteanu> *will also have to
12:20:49 <Cale> They're more commonly called data constructors, rather than value constructors, but whatever.
12:20:50 <tulcod> Cale, Eduard_Munteanu: i think i get it now. the difference is in capitalization and allowance of pattern matching.
12:20:59 <Cale> yep
12:21:12 <tulcod> great, thanks guys :)
12:21:19 <Eduard_Munteanu> Yeah, you can't pattern-match on function application.
12:21:28 <tulcod> Cale: i think the name kinda depends on your literature
12:21:53 <Cale> tulcod: yeah
12:22:17 <Cale> Value constructors is not a terrible name, they do construct values, certainly.
12:22:31 <rwbarton> well, "allowance of pattern matching" is a consequence of the fact that data constructors are what define the structure of an algebraic data type
12:23:09 <Cale> The Haskell standard uses the term "data constructor" though, so most people tend to follow that convention. :)
12:23:13 <Sgeo> http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html Um
12:23:22 <tulcod> rwbarton: obviously it's not hacked together the way i explained it, but i'm just interested in the fundamental similarities and differences
12:23:34 <Sgeo> "The ability to define new functions that can be used as control constructs is especially important when you want to design embedded domain specific languages. Take the simple example of the when (i.e., one-arm if) function in Haskell. "
12:23:45 <Sgeo> This has nothing to do with laziness and everything to do with monads.
12:23:55 <Sgeo> Am I missing something, or is augustss wrong?
12:24:19 <c_wraith> Sgeo: it depends on the separation of evaluation and execution.
12:24:27 <c_wraith> Sgeo: at least, "when" does.
12:24:35 <c_wraith> Sgeo: but other control constructs don't
12:24:40 <Cale> Look more carefully at his example
12:24:45 <c_wraith> for instance, you can write an "if" function
12:24:52 <Cale> The computation inside the 'when' is an error.
12:25:04 <Cale> *evaluating* which computation it is will produce an error
12:25:09 <c_wraith> oh, well that's a good point
12:25:30 <Sgeo> Ah
12:25:33 <Cale> But the error will only happen if the condition holds at the last possible moment
12:26:20 <Cale> Maybe that's not the strongest possible argument for laziness, but it's a decent thing to point out.
12:26:43 <Cale> He saves the best for last there. The real reason that laziness is good is compositionality and reuse.
12:29:48 <conal> which is the main point of "why FP matters" iirc. that paper sold me on laziness.
12:30:00 <conal> (and of course we really mean non-strictness, not laziness)
12:30:43 <Cale> MasterPrime: I can help a bit with that code perhaps...
12:31:22 <MasterPrime> Sweet. how?
12:31:36 <Sgeo> Huh, so Haskell does have variable shadowing in monads
12:31:41 <Sgeo> http://ideone.com/5I5nH
12:31:50 <Sgeo> (What's the right word instead of variable?)
12:31:58 <hpc> haskell has shadowing, period
12:32:09 <applicative> Harper in his comment on augustss concedes that much, "As you know, in the eager world we tend to write out our own recursive functions, rather than use combinators."
12:32:13 <hpc> (\id -> id 5) (succ)
12:32:17 <hpc> > (\id -> id 5) (succ)
12:32:18 <bss03> -Wall will warn you about it in GHC.
12:32:18 <lambdabot>   6
12:32:23 <Cale> MasterPrime: The blockDefs value being defined there is an IntMap (which is a data structure containing values indexed by integers), and the values in the IntMap are functions from Int and Neighbours to lists of (String, Face) pairs
12:32:36 <Cale> MasterPrime: The Int parameter looks like the Minecraft "damage" value
12:32:44 <benmachine> Sgeo: yes, because do-bindings turn into lambdas
12:32:55 <Cale> (which is used to determine the colour of wool, type of wood, and a bunch of other things)
12:32:56 <Sgeo> > let a=5; a=6 in a -- shouldn't shadow
12:32:57 <lambdabot>   Conflicting definitions for `a'
12:32:57 <lambdabot>  Bound at: <interactive>:1:4
12:32:58 <lambdabot>            <in...
12:33:21 <hpc> > let a = 5 in let a = 6 in a
12:33:22 <lambdabot>   6
12:33:28 <benmachine> Sgeo: let-bindings are recursive, do-bindings aren't
12:33:33 <MasterPrime> Cale: ok. so how would I add a new block to it?
12:33:53 <benmachine> actually hpc makes a good point
12:33:55 <Sgeo> > runIdentity $ do { let a = 5; let a = 6; return a }
12:33:56 <lambdabot>   <no location info>: parse error on input `}'
12:34:04 <Sgeo> !!
12:34:10 <Sgeo> :t runIdentity
12:34:11 <lambdabot> forall a. Identity a -> a
12:34:19 <hpc> > runIdentity $ do { let a = 5; let a = 6; return a;}
12:34:20 <lambdabot>   <no location info>: parse error on input `;'
12:34:24 <rwbarton> needs more {}{}
12:34:25 <hpc> pah
12:34:41 <Sgeo> > runIdentity $ do { let { a = 5; let a = 6 }; return a }
12:34:42 <lambdabot>   <no location info>: parse error on input `}'
12:34:44 <applicative> doesn't it need a constructor for Identity?
12:34:54 <Sgeo> > runIdentity $ do { let { a = 5; let a = 6 ;}; return a }
12:34:55 <lambdabot>   <no location info>: parse error on input `}'
12:35:07 <Sgeo> applicative, that should be a type error, but probably
12:35:15 <Sgeo> > runIdentity $ Identity $ do { let { a = 5; let a = 6 ;}; return a }
12:35:16 <lambdabot>   <no location info>: parse error on input `}'
12:35:25 <rwbarton> does that even look remotely plausible :P
12:35:30 <Sgeo> > runIdentity $ Identity $ do { let { a = 5;  a = 6 }; return a }
12:35:31 <lambdabot>   Conflicting definitions for `a'
12:35:31 <lambdabot>  Bound at: <interactive>:1:36
12:35:31 <lambdabot>            <i...
12:35:37 <rwbarton> > runIdentity $ do { let { a = 5 } ; let { a = 6 } ; return a }
12:35:38 <lambdabot>   6
12:36:13 <Sgeo> rwbarton, thank you
12:37:31 <Cale> MasterPrime: okay... so the first part of each pair there is pretty clearly the block ID
12:38:21 <Cale> MasterPrime: Does your block's appearance depend on the damage value?
12:38:57 <MasterPrime> I'm not sure which blocks do. http://www.minecraftwiki.net/wiki/Data_values#Block_IDs_.28Minecraft_Official_Release.29
12:39:04 <MasterPrime> that's the list. I just need to add the ones that aren't there.
12:39:29 <Cale> Ah, okay, so you're updating this to work with 1.0.0 then...
12:39:32 <MasterPrime> yeah
12:39:50 <MasterPrime> he only gave it partial 1.8 support. It looks like he coded the information by hand which might be why.
12:41:10 <Cale> Yeah, I was trying to work out what version it was. I see there are pistons in there, but no hanging moss.
12:42:23 <Cale> (er, "vines", I guess is the proper term :P)
12:42:50 <MasterPrime> so would I have to create the geometry for each block or is there a way to automate it?
12:43:42 <Cale> Well, he already has done the geometry for stairs
12:44:06 <Cale> The enchantment table will be mildly annoying
12:44:55 <Cale> The straightforward ones will be straightforward, the new blocks with new geometry will require some more code to actually produce that geometry.
12:45:34 <MasterPrime> Okay. The question is still how would I add the blocks. I don't know haskell and unless I can find someone else to do it, I'll learn just enough to update this.
12:46:10 <noplamodo> Hmm...can anyone explain why i have this http://hpaste.org/55949 compiler error when using Text.Parsec but not when using the compatibility layer Text.ParserCombinators.Parsec ?
12:46:21 <Ornedan> I'll have to nth the suggestion to work your way through learnyouahaskell
12:46:23 <Cale> MasterPrime: Cargo cult it :)
12:46:45 <Cale> MasterPrime: Do the easy blocks first, and just copy the code for a similar block :)
12:47:16 <Cale> but put in the right block ID and texture name
12:48:05 <hpc> MasterPrime: alternatively, "abstract cargo cult" it
12:48:26 <hpc> define a function that does what you would copy-paste, then call it with parameters for the stuff that changes
12:49:42 <byorgey> noplamodo: might be the monomorphism restriction, try giving an explicit type signature for parseReq
12:50:00 <Botje> noplamodo: are you using the Parser type anywhere, perchance?
12:50:11 <Botje> type Parser = Parsec String ()
12:50:28 <Botje> whereas your code seems to suggest you want Parsec String Int
12:54:32 <applicative> noplamodo: if you strike the offending parseHttpReq' what does ghci infer for the type of parseReq
13:03:09 <noplamodo> byorgey Botje applicative : Thanks for your help, i'll take a look. Sorry i was afk a moment. :)
13:11:15 <mekeor> how can i test a string for readability?
13:11:54 <ion> reads
13:13:13 <mekeor> > reads "foo"
13:13:14 <lambdabot>   []
13:13:20 <mekeor> > reads "123"
13:13:21 <lambdabot>   []
13:13:35 <hpc> > reads "123 plus some extra stuff"
13:13:36 <lambdabot>   []
13:13:45 <conal> mekeor: give a type
13:13:47 <rwbarton> > reads "123 plus some extra stuff" :: [(Integer, String)]
13:13:48 <lambdabot>   [(123," plus some extra stuff")]
13:13:49 <hpc> > reads "() plus some extra stuff" -- yay defaulting
13:13:50 <lambdabot>   [(()," plus some extra stuff")]
13:13:52 <mekeor> > reads "foo" :: Int
13:13:54 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:13:54 <lambdabot>         against inferred type ...
13:13:57 <mekeor> > reads "123" :: Int
13:13:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:13:58 <lambdabot>         against inferred type ...
13:15:15 <ion> > reads "()"
13:15:16 <lambdabot>   [((),"")]
13:15:52 <ion> > (reads :: ReadS Integer) "123"
13:15:53 <lambdabot>   [(123,"")]
13:15:55 <mekeor> :t reads
13:15:56 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:16:22 <mekeor> > (reads :: ReadS Integer) "foo"
13:16:23 <lambdabot>   []
13:16:28 <mekeor> ion: nice. thanks =)
13:16:58 <ion> > listToMaybe . map fst . filter (null . snd) . (reads :: ReadS Integer)) $ "123"
13:16:58 <lambdabot>   <no location info>: parse error on input `)'
13:17:01 <ion> > listToMaybe . map fst . filter (null . snd) . (reads :: ReadS Integer) $ "123"
13:17:03 <lambdabot>   Just 123
13:17:09 <ion> > listToMaybe . map fst . filter (null . snd) . (reads :: ReadS Integer) $ "123foo"
13:17:11 <lambdabot>   Nothing
13:17:47 <mekeor> ingenious
13:21:17 * applicative wonders whether a line like "filter f = Conduit $ return $ PreparedConduit (return . Producing . Prelude.filter f . return) (return [])" means 'give up now'
13:22:12 <Botje> sprinkle some more returns in there.
13:22:37 <applicative> we're stacked pretty high, my brain exploded two monad transformers ago
13:23:19 <ski> > (reads :: ReadS Integer) "123 plus some extra stuff"
13:23:20 <lambdabot>   [(123," plus some extra stuff")]
13:23:26 <mike-burns> I think that line means "name some of those values using a let".
13:24:16 <ion> applicative: Hah
13:27:02 <c_wraith> applicative: there isn't even a runResourceT in there. :P
13:27:50 <applicative> well, once I use it to make a Conduit, you know its coming
13:28:24 <Sgeo> "GHC 7 and later will warn if an UNPACK pragma cannot be used because it fails the use constraint."
13:28:28 <Sgeo> Why warn and not error?
13:28:41 <hpc> Sgeo: because it can just not unpack
13:28:49 <hpc> it doesn't break the program, just slow it down
13:29:57 <Sgeo> "Unpacking is one of the most important optimizations available to us."
13:29:59 <Sgeo> :/
13:30:35 * Sgeo doesn't want to have to think about this sort of stuff
13:31:02 <monochrom> you can see warnings
13:31:33 <Sgeo> I mean, thinking to use {-# UNPACK #-} at all
13:32:42 <monochrom> what are you going to do to improve this status quo?
13:33:06 <mirari_> Is it true that while all programs can be rewritten in CPS, rewriting a CPS program into direct style cannot generally be done without introducing additional data structures. Or, in other words: If I think I have a solution for a problem in CPS, then rewriting that in direct-style might not be easy to do "on the fly/in the head"?
13:33:19 <hpc> monochrom: does -O2 do any unpacking?
13:33:27 <monochrom> I don't know
13:33:43 <c_wraith> It doesn't unpack data structures, so far as I know.
13:34:02 <hpc> i know of -funbox
13:35:17 <KorriX> After installing happstack my ghci  "Could not find module `Happstack.Lite'" - do you have any ideas ?
13:36:45 <Jeanne-Kamikaze> I am building bindings around a C project that requires cmake to be run in order to generate a header file. How would this fit into cabal, if it even does ?
13:37:01 <monochrom> the additional data structure can probably be introduced and then eliminated (by fusion, deforestation, etc)
13:38:11 <c_wraith> unfortunately, ghc doesn't do general deforestation.
13:38:29 <monochrom> no, not ghc. human.
13:39:17 <applicative> c_wraith: did it:  runResourceT $  L.sourceList [1,2,3,4,5] $= (Conduit $ return $ PreparedConduit (return . Producing . Prelude.filter even . return) (return []))  $$  fmap show $ L.fold (+) 0
13:39:25 <c_wraith> woo!
13:39:37 <c_wraith> today, on "entire programs in one line"...
13:39:39 <applicative> its "6", almost as easy as Data.List, and much safer
13:40:02 <jonrafkind> do monads have any particular use other than isolating state in a lazy language?
13:40:29 <c_wraith> jonrafkind: yes.  that use is almost accidental
13:40:31 <applicative> jonrafkind: yes
13:40:34 <monochrom> yes, such as isolating environment in a lazy language
13:40:35 <mauke> jonrafkind: how do monads isolate state?
13:40:48 <jonrafkind> because all the state is kept in the monad, i thought
13:40:54 <mauke> what does that mean?
13:40:59 <mauke> [] is a monad
13:41:07 <mauke> it doesn't really "isolate" anything
13:41:09 <jonrafkind> monochrom, I see environment and state as the same
13:41:10 <monochrom> also isolating nondeterministic choice in a lazy language
13:41:18 <applicative> !
13:41:23 <monochrom> immutable environment
13:41:52 <monochrom> also isolating continuations in a lazy language
13:42:03 <copumpkin> yeah, control flow wankery
13:42:08 * applicative is putting continuations in solitary
13:42:09 <jonrafkind> do you think monads have any use outside a lazy language?
13:42:11 <copumpkin> also, parsing
13:42:14 <copumpkin> jonrafkind: absolutely
13:42:22 <copumpkin> the laziness is almost completely unrelated
13:42:28 <jonrafkind> i saw the monads in java post, it was mostly about the math but no use cass
13:42:29 <copumpkin> even if you think monads are just for IO
13:42:29 <jonrafkind> cases
13:42:35 <monochrom> also isolating semantics in a lazy language (EDSL with multiple semantics)
13:42:41 <jonrafkind> i haven't seen a useful example of monads outside haskell
13:42:55 <mauke> that's because you can't write return in other languages
13:43:08 <c_wraith> jquery is more or less a monad.
13:43:09 <jonrafkind> its impossible?
13:43:17 <jonrafkind> most likely you can emulate return, no?
13:43:26 <c_wraith> dynamically-typed languages can write return
13:43:27 <applicative> you kind of need a type system for starters
13:43:31 <c_wraith> few statically-typed languages can
13:43:38 <jonrafkind> why do you need a type system?
13:43:50 <c_wraith> To make sure you don't get it wrong.
13:43:52 <mauke> c_wraith: how?
13:43:55 <jonrafkind> thats orthogonal
13:43:57 <monochrom> you need polymorphism in the answer type
13:44:01 <monochrom> @type maxBound
13:44:02 <lambdabot> forall a. (Bounded a) => a
13:44:07 <monochrom> @type return
13:44:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:44:09 <copumpkin> jonrafkind: to give us a way to statically separate behaviors we want from ones we don't want
13:44:17 <c_wraith> monochrom: only to abstract over all monads.
13:44:21 <copumpkin> jonrafkind: and to help us write complicated programs
13:44:26 <ion> c_wraith: It has return, fmap and join?
13:44:28 <jonrafkind> oh ok, so i guess no one uses scheme. wtf
13:44:33 <mauke> jonrafkind: so I don't have to pass types around manually
13:44:41 <Fuco> where can I find the source for implementation of instance for Monad ((->) r)
13:44:43 <monochrom> untyped works, of course
13:44:50 <parcs`> Fuco: Control.Monad.Instances
13:44:54 <c_wraith> You can write monadic code in dynamic languages.  It just can't really use a monad abstraction
13:44:58 <applicative> Control.Monad.Instances\
13:44:58 <parcs`> @src (->) (>>=)
13:44:58 <lambdabot> f >>= k = \ r -> k (f r) r
13:45:01 <Fuco> I was just looking there and couldn't find it :O
13:45:01 <parcs`> @src (->) return
13:45:01 <lambdabot> return = const
13:45:26 <copumpkin> jonrafkind: many of us do or have
13:45:31 <Fuco> ah... they link to GHC-base from the doc. page
13:45:35 <copumpkin> jonrafkind: I even happen to be an op in #scheme, for some weird reason :P
13:45:36 <ion> @djinn (r -> a) -> (a -> r -> b) -> r -> b
13:45:36 <lambdabot> f a b c = b (a c) c
13:45:45 <ion> @djinn (>>=) :: (r -> a) -> (a -> r -> b) -> r -> b
13:45:45 <lambdabot> Cannot parse command
13:45:47 <jonrafkind> so i dont know why the opinion is that typed languages are required..
13:45:59 <jonrafkind> nor do I see what types and monads have to do with each other
13:46:11 <copumpkin> jonrafkind: I didn't say it was required, but I gave you reasons I wanted types
13:46:12 <mauke> jonrafkind: how are you going to write return without a type system?
13:46:19 <monochrom> you need good types or no types.
13:46:21 <c_wraith> jonrafkind: in order to properly abstract return, you need to have return-type polymorphism.
13:46:22 <parcs`> @djinn (m ~ ((->) r) => m a -> (a -> m b) -> m b
13:46:22 <lambdabot> Cannot parse command
13:46:37 <parcs`> @djinn (m ~ ((->) r)) => m a -> (a -> m b) -> m b
13:46:38 <lambdabot> Cannot parse command
13:46:42 * applicative is trying to envisage join and return in a world without types.  
13:46:46 <jonrafkind> well im not an expert on monads/return, but why cant you just write the expression without a type
13:46:46 <copumpkin> parcs`: djinn doesn't know any fancy type shit
13:47:01 <copumpkin> jonrafkind: because what return means depends on the type it has
13:47:02 <mauke> jonrafkind: because then it doesn't know wtf you're trying to do
13:47:08 <mauke> jonrafkind: types aren't just some safety checks
13:47:30 <jonrafkind> so I guess you would explicitly create the monad when you do return
13:47:32 <c_wraith> jonrafkind: there are two things going on.  You can write functions that do what return and (>>=) for any particular type do, in any language.  What most languages don't let you do is abstract those ideas.
13:47:40 <jonrafkind> so bind/unbind would have to be explicit rather than implicit
13:47:49 <copumpkin> there's no unbind
13:48:02 <mauke> what would unbind do?
13:48:06 <jonrafkind> ok bind/return
13:48:07 <mauke> cobind?
13:48:13 <copumpkin> but anyway, the reasons I listed for wanting types were unrelated to monads, and are still reasons for wanting types
13:48:29 <jonrafkind> thats nice
13:48:48 <copumpkin> jonrafkind: did you give up on agda?
13:49:00 <jonrafkind> i was doing a project with it and the project ended.. so yea :p
13:49:04 <copumpkin> ah, okay
13:49:24 <copumpkin> because I think agda really demonstrates the "types helping you program" approach to types
13:49:33 <jonrafkind> rofl.. agda was the most painful experience of my life
13:49:33 <copumpkin> if you use it that way, anyway
13:49:39 <jonrafkind> but maybe if i was good at it it might be useful
13:49:39 <KorriX> ghc-pkg list | grep happstack - gives results, but importing Happstack.Lite fails - any suggestions ?
13:49:52 <copumpkin> jonrafkind: yeah, it takes getting used to, especially if you're coming from scheme
13:49:56 <rwbarton> copumpkin: I think this is all off-topic to jonrafkind's question which was "can monads be useful in other languages"
13:50:07 <copumpkin> rwbarton: [05:22:13 PM] <jonrafkind> why do you need a type system?
13:50:15 <jonrafkind> im not a "schemer", im not forieign to types, but agda takes it to another level entirely..
13:50:28 <mauke> you know the rules and so do I
13:50:29 <jonrafkind> copumpkin, my question was about why do you need a type system for monads..
13:50:36 <tsousa> does anyone read this book? http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?s=books&ie=UTF8&qid=1325456772&sr=1-1
13:50:37 <copumpkin> jonrafkind: ah, I missed the context on that
13:50:40 <rwbarton> 22:21 < mauke> that's because you can't write return in other languages 22:21 < jonrafkind> most likely you can emulate return, no? 22:22 < applicative> you kind of need a type system for starters
13:50:41 <jonrafkind> lulz
13:50:49 <copumpkin> :)
13:51:05 <monochrom> what c_wraith says
13:51:54 <jonrafkind> I mean assuming you could do without types then using macros you could write monads and all its machinery in scheme, but you say its not really possible without types
13:52:17 <monochrom> i.e., if you don't mind having different names returnOfList, returnOfMaybe, returnOfIO... sure, you can do it in every language. if you want one single name "return" though, that needs a type-directed type resolution.
13:52:28 <rwbarton> or you need to pass around a monad dictionary manually
13:52:31 <ion> We know the game and we're gonna play it
13:52:32 <copumpkin> jonrafkind: there's a fairly hefty chunk of monad code from edwardk
13:52:36 <copumpkin> in scheme
13:52:44 <copumpkin> it's not strictly monads, but it gives you lots of the same kind of stuff
13:52:47 <applicative> KorriX: ghc-pkg find-module Happstack.Lite
13:53:12 <monochrom> but we're entering too-busy-asking-to-read-answers territory
13:53:15 <copumpkin> jonrafkind: https://github.com/ekmett/scheme-monads
13:53:50 <applicative> copumpkin: yeah, but its ekmett, so the haskell type system is probably emulated
13:54:24 <Fuco> this just blows my mind... (->) being a monad/functor etc. I've always thought it was just a part of syntax but it's actually legit part of the language
13:54:32 <copumpkin> applicative: nah, it's not too bad :P
13:54:52 <KorriX> thanks
13:54:54 <copumpkin> I don't think you can write code polymorphic over monads, though
13:54:55 * applicative studies
13:55:03 <copumpkin> but you can work with individual ones
13:55:05 <KorriX> i don't have package named Happstack.Lite
13:55:07 <ion> fuco: http://heh.fi/haskell/functors/#function-instance
13:55:10 <KorriX> :D
13:55:16 <hpc> copumpkin: in scheme?
13:55:21 <copumpkin> hpc: yeah
13:55:23 <Fuco> ion: sweet, thanks
13:56:09 <MarcWeber> Lemmih, dcoutts_ : cabal-install-ghc72 has two .cabal files causing trouble. Which purpose does the ._*.cabal file serve?
13:56:27 <rwbarton> well you can, they look awful though -- (define replicateM (lambda (return bind n x) ...))
13:56:43 <ksion> Fuco: AFAIK only = and :: are somewhat special operators in Haskell.
13:57:00 <ion> They’re not operators.
13:57:10 <copumpkin> rwbarton: ick :)
13:57:38 <hpc> ksion: there's lots of special syntactic stuff in haskell
13:57:42 <applicative> looking at all the parentheses in ekmetts scheme-monad, I suddenly want to type more returns from Data.Conduit
13:57:48 <hpc> ksion: some of it behaves like types or functions
13:57:52 <c_wraith> ksion: not only those.  ->, <-, \, etc
13:58:00 <ksion> Fuco: You can do stuff with seemingly fundamental elements, like $, e.g.  map  ($ 3) [sqrt]
13:58:12 <hpc> you can't define [] in haskell, under the current capitalization rules
13:58:37 <hpc> and if you could, you would only get ([] foo) notation of list types
13:58:50 <c_wraith> hpc: not just that, [] also can be used as a circumfix type constructor
13:58:51 <hpc> tuples have mandatory parens
13:59:01 <ksion> c_wraith: Oh, right. There are few special constructs that basically say "thou shall pattern match *here*",  among other semantical things.
13:59:05 <hpc> c_wraith: that's what i said :P
13:59:32 <c_wraith> ksion: yeah, the number of exceptions is kind of surprising.  heck, .. is reserved
13:59:55 <c_wraith> because .. is syntax, not an operator
14:00:04 <monochrom> copumpkin: in dependent typing, the type guides writing the program; in those formal methods I like, specifications and the formal method guide writing the program, too. but people don't like that. people are taught to pull the program out of their ass, so any requirement to establish any relation between the program and some second thing becomes a cost.
14:00:17 <Fuco> but $ is a legit function, right?
14:00:18 <hpc> because of [foo .. bar], and import Foo (Foo(..))
14:00:36 <ion> ($) is a function, yeah.
14:00:52 <ksion> @type ($)
14:00:52 <lambdabot> forall a b. (a -> b) -> a -> b
14:01:05 <Fuco> ksion: I'm probably not getting what you tried to show then
14:01:27 <ksion> $ is basically redundant, but it's useful in cases like the one I pointed out.
14:01:34 <Fuco> yea I see
14:01:40 <hpc> :t zipWith ($)
14:01:41 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
14:01:57 <ksion> hpc: Yeah, that's very common pattern.
14:02:48 <Fuco> yea, I love that feeling when you figure out something clever like that :D That's why I keep getting "back" to haskell for all these years
14:02:51 <scooty-puff> anyone know what module in the ghc compiler converts a CmmGraph back to a list of CmmNode's or instructions, or why its not necessary?
14:03:10 <scooty-puff> (basically, where does it convert from a cfg to a list of instructions(
14:03:12 <scooty-puff> ))
14:03:22 <Fuco> I was fooling with StateT the other day and it all suddenly clicked and I was like "Whoa dude"
14:04:04 <monochrom> yes, practice helps understanding. reading and reading and reading and talk and talk and talk does not.
14:04:37 <ion> fuco: Why do you go away? :-P
14:04:46 * applicative has learned a number of things from monochrom's talking
14:04:51 <monochrom> you learned numbers by operating with numbers, not by listening to lectures on "the true nature of numbers"
14:05:02 * ion misread that as “monochrom’s stalking”
14:05:02 <Codex_> Can someone explain how pullbacks should really be used. I mean the contravariant powerset functor stuff?
14:05:35 * monochrom 's only stalking tool is /whois
14:07:04 <ksion> <Fuco> I was fooling with StateT the other day and it all suddenly clicked and I was like "Whoa dude" -- It's great when it happens, but in learning Haskell, this sudden enlightment usually follows a long period of puzzlement. :)
14:07:16 <Fuco> ion: well sometimes it gets really frustrating. Also it takes some time to get the intuition and so on (and my algebra/logic/etc courses helped a lot too)
14:07:25 <Fuco> ksion: exactly :P
14:08:16 <ddarius> Codex_: That's not Haskell related.
14:09:03 <ksion> Fuco: It also depends on what you learn from. For example, I couldn't grasp applicatives until I read LYAH even though I went through RWH before.
14:09:39 <ddarius> ksion: That does not imply that if you had just gone through LYAH you would have grasped applicative functors.
14:10:01 <Fuco> ddarius: you obviously have to first read RWH and then LYAH :D
14:10:04 <copumpkin> monochrom: yeah :/
14:10:42 <ksion> ddarius: Of course. I had burst through a wall of my own stupidity, slamming it with RWH. (It's heavy book, very good for slamming anything).
14:10:51 <ProfDrum> Im having some trouble. I've been asked to write Reversi in Haskell as part of my course, but Im not sure where to even start. All we've done is some very basic functions. Does anyone know a good place to start with this?
14:11:21 <Philippa> a datatype for the board
14:11:32 <ddarius> ProfDrum: Your instructor or TA probably knows.
14:12:07 <monochrom> that is a mean homework
14:12:30 * applicative is now the first on his block to use unsafePerformIO on a conduit
14:12:39 <tromp> start from any other boardgame written in haskell?!
14:12:50 <Philippa> eh, it's only really mean if you have to write an AI or a nice UI as well
14:13:04 <ProfDrum> The board I was thinking a 2D array, but Im used to Java, Im not sure if that even makes sense for Haskell. Im reafing though Learn you a Haskell right now, but if anyone has a better resource I'd be all for hearing it
14:13:13 <mzero> ProfDrum: what other sorts of Haskell programs have you written for the prior assignments? (Help calibrate us)
14:13:37 <Philippa> a 2D array works, or if it's all you've been taught for now then a list of lists will do
14:14:00 <ProfDrum> literally things like extracting a slice from a list
14:14:03 <tromp> bitbiards will be easier though
14:14:05 <ProfDrum> and quicksort
14:14:08 <monochrom> basic data structures are probably more important than basic functions for a Reversi homework. functions are cheap. the functions write themselves once you have chosen good data structures. at least for this kind of homework anyway. the hard part is data structures.
14:14:12 <tromp> bitboards
14:14:45 <mzero> ProfDrum: have you written a data type yet?
14:15:45 <mzero> I'm also just curious, as we seem to get a lot of this sort of thing --- is it fashionable nowadays to throw in Haskell for like two weeks in some otherwise general programming survey course?
14:16:12 <ProfDrum> No, or at least not to my knowledge. I missed 2 practical sessions last term, but I caught up on them in my own time, one was quicksort, the other writing the "tail" function using other functions
14:16:18 * ddarius prefers the American name for reversi.
14:16:24 <ProfDrum> Othello isnt it?
14:16:26 <mzero> Is this a course in Haskell or Functional Programming? Or is this just like, "well, we've covered loops and recursion in Java... now we'll show you some Haskell... then move on to Python..." ?
14:16:44 <monochrom> but windows calls it reversi, and windows is american...
14:16:49 <mzero> going from tail and quick sort to "write Reversi" seems, well, a bit of a jump
14:17:03 <ProfDrum> This is "functional programming", a sub section of a sub module. We get 10 weeks of Haskell, then we move onto C
14:17:18 <monochrom> a general survey course is unlikely to ask you to do any useful thing in homework
14:17:25 * mzero wonders how C is "functional programming"
14:17:37 <ProfDrum> Java has bene what we've been using so far, and this would be a piece of piss in Java to be honest, but Haskell is different
14:17:54 <ProfDrum> functional programming is the subsection, C is a different part of the module - "Programming and Reasoning"
14:18:11 <monochrom> a piece of piss in your native tongue, to be exact
14:18:18 <mzero> but yeah - this sort of thing drives me nuts - we should write an article about "the other side of college programming courses" and let educators know the absurdity of the way they try to cram Haskell in
14:18:27 <mzero> OKAY - enough ranting, on to helping ProfDrum
14:18:35 <monochrom> I mean s/Java/your native tongue/
14:18:41 <ProfDrum> Mm, indeed
14:18:47 <McManiaC> if I "import {-# SOURCE #-}" a data type constructor, do I have to copy & paste ALL constructors for that type to the -boot file?
14:19:03 <ddarius> "It's easy if I don't have to learn anything."
14:19:07 <mzero> ProfDrum:    have you written any data types yet.... like, say,       data Colors = Red | Blue | Green
14:19:24 <monochrom> well, java is learned, too
14:19:34 <McManiaC> because I only need one very smallish type constructor, but the datatype has a ton of different constructors
14:19:52 <ProfDrum> ddarius, the problem is, it might be easy, or at least less intimidating, if I didnt feel there was a massive, unguided step
14:20:23 <mzero> what are they asking for specifically? a function that executes a move? a full UI with AI opponent?
14:21:04 <mzero> in any event, ProfDrum, the code will end up being smaller, and more clear than the code in Java would be ---
14:21:17 <mzero> but indeed, you'll have to "step out of your Java-comfort-zone" to get there
14:21:22 <McManiaC> http://npaste.de/V8/ :(
14:21:28 <ProfDrum> we've been given a recommended way of solving it - two functions specifically
14:21:32 <monochrom> not smaller and not clearer if done by translating java to haskell
14:21:40 <ProfDrum> one that takes a configuration and a colour, and lists all moves that colour could make
14:21:53 <ProfDrum> and one that chooses the best move for that colour
14:22:00 <ddarius> As expected, relevant information was not provided.
14:22:03 <ProfDrum> the overall program is supposed to be able to play against a human
14:22:24 <mzero> wow - that is quite a bit jump from implementing quicksort
14:22:34 <mzero> but, okay
14:22:40 <ProfDrum> Good, I was worrying it was just me
14:22:45 <mzero> as always - start with the types ----
14:22:46 <ddarius> ProfDrum: What week are you in this subsection?
14:22:55 <mzero> (did they give you the types of those functions .....? )
14:22:57 <drull95> does anyone know  how to make WASH do the content-type tag correctly? would I have to patch WASH to do this?
14:23:03 <monochrom> ddarius: you should also expect: relevant information is not demanded
14:23:14 <ddarius> drull95: WASH is pretty fucking old.
14:23:31 <ddarius> monochrom: Indeed.  People here just press on without asking questions.
14:23:40 <ddarius> Which isn't completely accurate in this case, but still.
14:23:44 <ion> A piece of piss?
14:23:55 <ProfDrum> ddarius, final week of the subsection. mzero , no, we were told to choose a suitable datatype for the board config. I can sort of see what Im doing, but not how to go about it.
14:23:57 <monochrom> a variant of "a piece of cake", I assume
14:24:11 <ddarius> mzero: So this is after 9 weeks of Haskell.
14:24:19 <ProfDrum> yeah
14:24:20 <ProfDrum> and yeah
14:24:41 <monochrom> you can use an array or a flat list or a nested list
14:24:49 <mzero> right - but if the preceding task was just quick sort? (that should have been week 1)   well... no matter.....
14:25:15 <mzero> okay, ProfDrum  --- so, start with just the types --- write the type for the board down
14:25:24 <mzero> write the type of each of the two functions down
14:25:34 <monochrom> as for individual cells, data Cell = Empty | Black | White should show you how java is more complicated, and c more unsafe
14:25:43 <mzero> don't write implementations, just yet - just the types
14:26:07 <mzero> perhaps we should let ProfDrum come up with the types?  :-)
14:26:24 <ProfDrum> probably best ;)
14:26:39 <monochrom> ProfDrum still has to make the decision between array, flat list, nested list.
14:26:50 <mzero> write those types up - then hpaste 'em here and we'll talk
14:27:20 <monochrom> IMO I am doing the service of saving everyone here a brutal detour to abuse of type class for the cell type.
14:27:29 <mzero> heh!
14:28:00 <mzero> I know - as a new Haskeller, I always was trying to put type classes in everywhere, and use advanced type magic features,....
14:28:11 <ProfDrum> I wont be about much longer tonight unfortunately, but I'll be back to pester some more
14:28:17 <ion> , thread per cell which stores state and a master thread which has a map from serialized cell position to thread ID and a SOAP API.
14:28:23 <ddarius> monochrom: If I were covering Haskell for only 10 weeks as a representative of functional programming, I would probably not cover type classes to the extent that I could get away with it.
14:28:28 <mzero> now I'm an experienced Haskeller and I find 90% the time I'm like "nope, no need for a type class for that...."
14:29:44 <monochrom> ion wins :)
14:30:20 <ddarius> Thread per cell is my kind of style.
14:31:16 <monochrom> I think if you avoid type classes you will be cornered with the type of (==) and (+)
14:31:16 * ddarius considers making a multithreaded Othello server with an AJAX interface where each cell responds to JSON requests.
14:31:36 <ddarius> monochrom: Hence the "to the extent I could get away with it."
14:31:51 <ddarius> I can explain Num and Eq and Show and not cover how to declare classes and instances.
14:32:08 <applicative> drull95: do you mean the function that determines content type?
14:32:09 <monochrom> oh, evil. clever.
14:32:40 <ion> ddarius: Make it distributed! A server per cell!
14:32:57 <drull95> when i look at the page in the browser it shows the content type as text at the top of the page
14:33:21 <ddarius> ion: That wouldn't work well with browsers' same origin policy, except that there could be multiple servers serving the domain.
14:34:52 <c_wraith> type classes are much easier when you ignore higher-kinded classes
14:35:10 <c_wraith> No one has trouble with Eq or Ord
14:35:42 <tomh> to concat two IO lists I can use mappend right or am I confused now
14:35:53 <c_wraith> liftM2 concat
14:35:56 <Saizan> i think noone has trouble with Eq or Ord also because they are used to comparison operators to be overloaded
14:36:11 <tomh> ah thanks
14:36:11 <c_wraith> That's also true
14:36:16 <ion> @type concat
14:36:17 <lambdabot> forall a. [[a]] -> [a]
14:36:21 <c_wraith> err, right.
14:36:24 <ion> liftA2 (++)
14:36:28 <c_wraith> yeah, ++ is better
14:36:38 <c_wraith> and by "better" I mean "correct"
14:36:49 <hpc> heh
14:36:55 <monochrom> it is both better and correct, so don't you worry :)
14:37:07 <hpc> "correcter"
14:37:22 <ion> liftA2 mappend works, too. Perhaps you want to be generic. :-P
14:37:24 <ion> @type liftA2 mappend
14:37:25 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a
14:37:25 <jmcarthur> tomh: if there was an instance Monoid a => Monoid (IO a) then you could do that
14:37:41 <monochrom> haskell is beautifuller than java
14:37:55 <tomh> yeah, there isn't :) I'll try liftA2 (++)
14:37:58 <jmcarthur> any applicative can be made into a Monoid in the same way, although that's not always the monoid you want
14:38:14 <ion> monochrom: Spoken with the accent where you pronounce “java” as “javer”.
14:38:31 <monochrom> hasker is beautifuller than javer
14:38:46 <ProfDrum> speaking of funny pronunciations
14:39:13 <ProfDrum> am I the only one that says "hask-ell"? everyone else seems to say "haskell" to rhyme with "pascal"
14:39:27 <c_wraith> it should rhyme with rascal
14:39:28 <jmcarthur> it's supposed to rhyme with "rascal"
14:39:43 <c_wraith> pascal has emphasis on the first syllable.
14:39:50 <c_wraith> haskell has emphasis on the second
14:39:57 <jmcarthur> huh?
14:40:01 <hpc> c_wraith: other way around
14:40:01 <shachaf> ProfDrum: If there's a glottal stop in your pronunciation of "Haskell", that's pretty unusual. :-)
14:40:02 <conal> lol
14:40:04 <hpc> HASkell
14:40:06 <applicative> what nonsense
14:40:06 <hpc> pasCAL
14:40:07 <ion> :-D
14:40:10 <c_wraith> err, yes.
14:40:11 <monochrom> I do all 4 combinations
14:40:26 <ion> ell Hask
14:40:43 <c_wraith> Hask'el, brother of Kal'el
14:41:06 <applicative> wow this WASH is a monster
14:41:25 <c_wraith> isn't that some mega-library that's mostly abandoned now?
14:41:37 <jmcarthur> i sometimes have trouble reasoning about whether a non-trivial use of MonadFix terminates
14:42:12 <ProfDrum> Hmm. I do use a glottal stop it seems
14:42:17 <hpc> jmcarthur: a side-effect of fix in general - you might know it as the halting problem ;)
14:42:21 <ProfDrum> (I had to youtube "glottal stop" for that :/ )
14:42:38 <jmcarthur> hpc: true, but this i see MonadFix as a little more complex sometimes
14:42:43 <monochrom> you may be mistaking MonadFix semantics altogether
14:43:18 <monochrom> see my http://www.haskell.org/haskellwiki/MonadFix
14:44:03 <jmcarthur> i've used it enough to feel pretty good that i don't have the "loop" intuition about it
14:44:09 <applicative> c_wraith, yes, drull95 was asking about it.
14:44:55 <drull95> i don't know much about web programming, i learned wash a long time ago :)
14:45:12 <monochrom> ok, then good. if you question "how to tell if the value is bottom", that's certainly legitimate and difficult
14:45:20 <jmcarthur> in this case, it's a somewhat complicated mutually recursive list of IORefs definition in the StateT s IO monad
14:46:05 <mekeor> @faq Can Haskell produce errors while handling with command-line arguments which contain unicode-characters?
14:46:05 <lambdabot> The answer is: Yes! Haskell can do that.
14:46:50 <c_wraith> mekeor: that sounds backwards to me.  shouldn't the question be whether it can avoid them?
14:47:08 <mekeor> @faq Can Haskell avoid errors while handling with command-line arguments which contain unicode-characters?
14:47:09 <lambdabot> The answer is: Yes! Haskell can do that.
14:47:26 <jmcarthur> well, to be more clear, the variables my DoRec expression binds are a IntMap of IORefs and a list of IORefs :
14:47:26 <c_wraith> By the way, Haskell as specified currently has some issues with non-character filenames.
14:49:17 <monochrom> getArg, getEnvirontment,  FilePath are problematic in GHC when it comes to non-ascii. the FilePath part is being worked on now (avail raw bytes and you decide what to make of it)
14:50:10 <monochrom> the dilemma is difference between linux, windows, ...
14:50:33 <mekeor> so, i wrote a calculator using the reverse polnish notation which knows a quite big list of operators. but the operator strings include e.g. "÷" for division... but the code produces an error when i use that character… why?
14:50:54 <mekeor> that's the code: (i'm proud of it =)) https://github.com/MekeorMelire/garepinoh/blob/master/Garepinoh.hs
14:51:39 <hpc> mekeor: what's the error?
14:51:40 <monochrom> most likely encoding surprise problem
14:51:41 <c_wraith> mekeor: what version of GHC?
14:52:17 <monochrom> does the user enter his/her RPN input via getArgs?
14:52:18 <mekeor> hpc: "Missing operator."\n"garepinoh: Prelude.read: no parse"
14:52:34 <mekeor> c_wraith: 7.0.4
14:52:45 <mekeor> monochrom: yep.
14:53:04 <mekeor> (that's why he has to type '*' instead of *, btw)
14:53:14 <c_wraith> should be able to just use \*
14:53:21 <mekeor> or that, okay..
14:53:22 <monochrom> ok so exactly what I said. getArgs doing wrong things for now.
14:53:23 <c_wraith> slightly simpler, but it depends on the shell
14:54:12 <mekeor> so, "./garepinoh 2 3 /" works, but "./garepinoh 2 3 ÷" doesnt
14:54:54 <c_wraith> yeah, as monochrom says, it's really a ghc bug
14:55:09 <mekeor> hpc: "Missing operator." is printed by my code directly; "Prelude.read: no parse" is printed "by haskell".
14:55:22 <mekeor> c_wraith: what? oO
14:55:43 <mekeor> but that's a really HUGE bug then…
14:55:55 <monochrom> the division symbol in UTF-8 is 0xC3 0xB7. getArgs gives you that in the wrong representation of ["\xC3", "\xB7"], i.e., two bytes becomes two Chars. you can live with it for now by going through utf8-string first
14:56:24 <jmcarthur> i was unaware of this bug o_O
14:56:31 <mekeor> monochrom: what do you thing, when will that bug be fixed?
14:56:39 <monochrom> dunno
14:56:54 <jmcarthur> that's a lame bug
14:57:02 <mekeor> bummer. but not important… thank you, btw  =)
14:57:07 <ml|> xmonad started fine a few hours ago, but now mod-q ... /usr/local/lib/ghc-7.2.2/ghc: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory; google was no help, how can I fix this?
14:57:13 <monochrom> we waited 10 years for getLine to decode utf-8. what do you think? :)
14:57:22 <mekeor> O_
14:57:22 <mekeor> O
14:57:40 <monochrom> it was not considered a bug because "everyone uses ascii, no?"
14:57:42 <mekeor> ml|: join #xmonad
14:57:53 <mekeor> monochrom: haha :D
14:57:54 <c_wraith> ml|: do you have gmp installed?
14:58:08 <ml|> mekeor: heh, was told to ask here
14:58:15 <monochrom> however, to their defense, linux and windows difference over this is also a hurdle
14:58:20 <mekeor> ml|: okay then =)
14:58:33 <maurer> ml|: Does the same thing happen if you type "ghc" at the command line?
14:58:40 <ml|> c_wraith: AFAIK
14:58:43 <ml|> maurer: yes
14:58:54 <maurer> monochrom: How are linux and windows difference on this
14:58:57 <maurer> *different
14:59:13 <maurer> ml|: Have you installed system updates recently?
14:59:23 <maurer> Perhaps ones that bumped your libgmp.so.3 revision?
14:59:34 <ml|> I have not touched ghc stuff in a while, maybe a reinstall is need?
14:59:45 <ml|> maurer: yes I did, let me check that
15:00:05 <monochrom> natively, linux gives you bytes, windows gives you words (using utf-16)
15:00:35 <maurer> If you bumped libgmp, you can hack around it for the moment by doing ln -s /usr/lib/libgmp.so.whateverthefuck /usr/local/lib/libgmp.so.3
15:00:54 <monochrom> also, linux's bytes are not always utf-8. locale-dependent.
15:01:20 <maurer> monochrom: Argh. I really wish that when this became an issue we had all picked the same thing and switched
15:01:22 <hpc> why the hell does windows use utf16?
15:01:43 <maurer> hpc: UTF16 lets you do fast regex matching on foreign stuff, faster seeking of text documents, and a number of other things
15:01:49 <maurer> Due to constand width characters
15:01:53 <maurer> *constant
15:01:55 <hpc> ah, that it does
15:02:01 <maurer> Like, both have benefits
15:02:08 <mzero> maurer: that isn't so
15:02:09 <maurer> But we really needed to pick one
15:02:13 <maurer> mzero: No?
15:02:18 <mzero> you can do just as fast seek and regexp on UTF8
15:02:20 <ddarius> UTF16 doesn't lead to constant width characters.
15:02:30 <mzero> and UTF16 isn't constant width either
15:02:32 <maurer> ddarius: Wait, it doesn't? Then what's the point?
15:02:36 <mzero> er, exactly, what ddarius  said
15:02:39 <maurer> Why does it even exist?
15:02:54 <maurer> I assumed that it was there because 16 bits were enough for all glyphs
15:02:59 <monochrom> 15 years ago, UTF16 was constant-width
15:03:01 <mzero> nope - 21 bits
15:03:07 <ddarius> maurer: Unicode requires 21 bits.
15:03:12 <c_wraith> it is *faster* to do many operations in UTF-16 than UTF-8
15:03:13 <ddarius> > maxBound :: Char
15:03:14 <lambdabot>   '\1114111'
15:03:17 <ben> What does UTF-32 do with the extra 11 bits?
15:03:22 <c_wraith> ben: padding
15:03:22 <mzero> c_wraith: nope, it isn't
15:03:25 <monochrom> it's also why java defined char = 16 bits (using utf-16 again) back then
15:03:32 <mzero> ben - nothing
15:03:33 <ml|> hmm, [REMOVE] libgmp3c2
15:03:36 <ddarius> Well Java isn't using UTF-16.
15:03:40 <russellw> Windows like Java made the choice of UTF16 back when we could still talk ourselves into believing sixteen bits would be enough. When it became apparent that this was a pipe dream, it was already too late to change
15:03:41 <maurer> Should we just surrender to the inevitable and make character strings have 64-bit wide glyphs? Then we'll never run out of space for more glyphs
15:03:44 <ml|> now to fine out why
15:03:52 <c_wraith> mzero: yes, it is.  Ask bos why Data.Text is utf-16
15:03:55 <maurer> ml|: Or just reinstall it :P
15:04:06 <c_wraith> mzero: you can be sure that bos relied on benchmarking for that decision
15:04:10 <ddarius> Also note that, particularly Java, wasn't using UTF-16 because the Unicode standard was far from finalized at those points.
15:04:13 <mzero> indeed - ask him - !  and summer student who did the work to change it to UTF-8
15:04:23 <ben> but it's still utf-16
15:04:26 <c_wraith> mzero: and it is *still* utf-16.  it wasn't changed
15:04:26 <ml|> maurer: heh, but would like to know why this happened ;)
15:04:38 <maurer> ml|: Most likely it was installed as a dependency of something else
15:04:48 <ml|> maurer: yeah
15:04:49 <maurer> ml|: Possibly a packaged version of ghc that you later uninstalled
15:04:57 <mzero> for the vast majority of text operations, UTF-8 is just as fast -- because you can still do byte-level operations for seeking and regexp (thanks to the UTF style of multi-byte with)
15:05:10 <ml|> maurer: makes sense
15:05:37 <mzero> c_wraith: actually, he didn't initially - it had to do with the complication of the fusion operations when there were four sizes, not just two
15:05:54 <ben> I wonder where we'd be with a utf21 where three code points are packed into one 8-bit word
15:06:12 <c_wraith> ben: that sounds horrifying. :)
15:06:20 <ben> There's even one bit left over!
15:06:35 * ddarius isn't sure how you pack 63 bits of information into 8 bits.
15:06:42 <ben> err, bytes, sorry
15:08:09 <maurer> mzero: So, seeking and regex are necessarily slower on non-fixed width stuff. With fixed with, it is a single multiply and add, regardless of seek length. With variable width, it is potentially linear comparisons
15:08:18 <ddarius> ben: How do you intend to represent only one or two code points?
15:08:25 <maurer> Regex can involve seeking in a fairly straightforward way, and so can be made slower
15:09:25 <ben> hm :(
15:12:13 <mzero> maurer: nope, they're not!  This is because UTF-8 guarantees that there is no possible mis-aligned match -- hence you just search for the matching string at successive bytes - no need to decode the width of each character -- if you are compiling the regex into a state machine, then you do it on the bytes, and it is fine
15:12:41 <mzero> ah - by seeking to "character n" - yes, that is true
15:12:51 <mzero> that is slower (vs. seeking for some given string)
15:12:57 <c_wraith> which applies more for KMP and similar algorithms
15:13:06 <mzero> but most string processing is done streaming over the character, not by indexing character positions....
15:13:35 <c_wraith> Well, string searching is often optimized with "skip ahead 3 characters, and look at what's there"
15:13:39 <c_wraith> or whatever.
15:13:48 <c_wraith> The important part is that you don't look at every byte
15:14:06 <c_wraith> Because it's way faster to not look at everything
15:14:25 * mzero looks at his current, giant, string parser and doesn't see a single index based operation in the whole thing.... 
15:14:36 <c_wraith> parsing isn't searching
15:14:44 <mzero> true dat
15:14:45 <c_wraith> You do, in fact, need to look at every character to parse
15:15:10 <mzero> so - in what context do you "skip three characters and look at the fourth"?
15:15:17 <maurer> mzero: Line wrapping
15:15:49 <mzero> well - not if you intend to line wrap to a modern terminal.... ansi escape sequences and all!
15:16:06 <maurer> mzero: Sure, it depends on the exact line wrap
15:16:08 <mzero> and not if you're line wrapping for the character layout
15:16:18 <mzero> on a proportional font
15:16:21 <c_wraith> searching for the string "hello"
15:16:31 <maurer> mzero: Nobody uses fonts that aren't monospace :P
15:17:26 <c_wraith> mzero: http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm
15:17:38 <mzero> fails to see how searching for "hello" in a string is any slower in UTF-8 vs. UTF-16 vs. UTF-32.... unless what you want is the number characters that precede it (vs. the preceding string vs. an opaque index )
15:17:40 <c_wraith> a key part of that algorithm is skipping n characters ahead
15:18:04 <c_wraith> perhaps "hello" was a bad example
15:18:11 <ml|> maurer: turns out it is not as easy as reinstalling that package, it was removed from testing repos; trying to find out why
15:18:24 <mzero> yes - you run KMP over the bytes of the UTF-8 encoded thing --- works just fine
15:18:41 <ml|> guess I can try stable version of that package
15:18:53 * ml| uses Debian
15:19:04 <c_wraith> mzero: sure, but you asked when "skip n characters ahead" is important.  And that's an example.
15:19:12 <mzero> right, so to use KMP in searching within UTF-8 encoded text, you convert your problem to searching for encoded byte sequences in the encoded string --- and run KMP over the bytes of that ... works because of the nature of UTF-8
15:19:35 <mzero> well it isn't because when using KMP for searching UTF-8 text, you are skipping n bytes ahead
15:20:06 <Bynbo7> nid
15:20:12 <Axman6> whoops
15:21:37 <mzero> is there a diff written in haskell?
15:22:00 <hpc> mzero: as in gnu diff?
15:22:12 <Axman6> there's bound to be some code from darcs that could be used
15:22:16 <dschoepe> mzero: The algorithm is here: http://hackage.haskell.org/package/Diff
15:22:18 <Ke> I could use some nice diff library too
15:22:18 <mzero> ah look at that
15:22:20 <mzero> lovely
15:22:28 <mzero> that's exactly what I want!
15:26:00 * monochrom has created a new MonadFix monster! will add to that haskell wiki page after dinner
15:27:00 <nh2> older versions of quickcheck have a "generate" function that generates an example structure. Is there an equivalent for quickcheck 2?
15:27:18 <hpc> @hoogle generate
15:27:19 <lambdabot> Graphics.Rendering.OpenGL.GL.Hints GenerateMipmap :: HintTarget
15:27:19 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Parameters generateMipmap :: TextureTarget -> StateVar Capability
15:27:19 <lambdabot> Graphics.Rendering.OpenGL.GLU.Quadrics GenerateTextureCoordinates :: QuadricTexture
15:27:30 <Sgeo> > maybe id id (Just id) 'h'
15:27:31 <lambdabot>   'h'
15:27:51 <Sgeo> > maybe id id Nothing "THIS IS STUPID"
15:27:52 <lambdabot>   "THIS IS STUPID"
15:28:17 <Sgeo> Does GHC work on WINE? Could I use that to compile a Windows binary from Linux?
15:29:15 <roconnor> anyone know anything about the category of contexts?
15:29:19 <ehuber_> i have a stupid question :D  suppose I have two monads (same type). how can i combine them into a single monad
15:29:52 <mzero> ehuber_: you have, for some monad m     v :: m a    and w :: m a
15:30:01 <ehuber_> yeah
15:30:04 <ehuber_> is it just >> ?
15:30:06 <mzero> and you want to combine them? do you have a function available for combining the a's?
15:30:08 <tgeeky> Sgeo: that sounds unlikely to work, but I can test them if you build them
15:30:22 <mzero> or do you want to just discard the first a value?
15:30:29 <hpc> ehuber_: suppose v = return 1; w = return 'z'
15:30:39 <rwbarton> ehuber_: your question is like "I have two numbers, how do I combine them"
15:30:45 <hpc> ehuber_: what should (v ?? w) produce, assuming (??) is what you want
15:30:50 <ehuber_> i dont need the inner values
15:30:55 <mzero> > let v = return 1; w = return 'z' in   v >> w
15:30:56 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
15:30:56 <lambdabot>    arising from a use of...
15:31:05 <mzero> heh
15:31:06 <hpc> ehuber_: sounds like (>>)
15:31:08 <roconnor> ehuber_: are they v : m () and w : m () ?
15:31:21 <mzero> :t  (>>)
15:31:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:31:23 <ehuber_> roconnor: no
15:31:29 <mzero> I think then that is what you want
15:31:44 <ehuber_> actually i should really just stare long and hard at control.monad :D
15:32:14 <roconnor> @type liftM2 (,)
15:32:14 <mzero> > let v = return 3; w = return 7; in (liftM2 (*) v w) :: Maybe Int
15:32:15 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
15:32:15 <lambdabot>   Just 21
15:32:42 <mzero> > let v = return 3; w = return 'z'; in (liftM2 (,) v w) :: Maybe (Int,Char)
15:32:43 <lambdabot>   Just (3,'z')
15:34:17 <mzero> ehuber_: I found writing implementations for all the utility functions in control.monad a great exercise
15:34:46 <ehuber_> oh the humanity
15:35:54 <ddarius> roconnor: There are multiple things that are/could be called "the category of contexts."  It's also not on-topic for #haskell.
15:37:54 <ddarius> ehuber_: A monad would be something like IO or State.  return 3 is not a monad.
15:41:59 <Veinor> 'return 3' is a monadic value
15:45:01 <ml|> maurer: reinstalling the stable version[the only one available] of libgmp3c2 worked :)
15:45:33 <Sgeo> @hoogle os
15:45:33 <lambdabot> System.Info os :: String
15:45:34 <lambdabot> package OSM
15:45:34 <lambdabot> package osx-ar
15:45:36 <ml|> still want to figure out why it was removed from the repos
15:46:57 <brooksbp> is there a haskell implementation of memcached?
15:47:45 <hpc> brooksbp: not the same, but check out acid-state
15:49:24 * hackagebot enumerator 0.4.17 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.17 (JohnMillikin)
15:50:39 <zeiris> What's the difference between OpenGL and OpenGLRaw?
15:50:54 <zeiris> Is Raw "lower level" in that it doesn't have any wrappers?
15:50:58 <Axman6> OpenGLRaw will be more low level
15:51:18 <Axman6> it'll basically just be FFI wrappers around the C interface
15:51:20 <jmcarthur> Raw more directly reflects the C API
15:51:29 <jmcarthur> (i prefer raw, myself)
15:54:03 <Sgeo> Setting NoBuffering doesn't work
15:54:17 <hughfdjackson> mauke: if i could tweak your ear for a second
15:54:19 <Sgeo> I don't know if it's WINE's fault or the binary's fault
15:54:26 <Sgeo> Who was the person who offered to help me test?
15:54:35 <hughfdjackson> is haskell's io similar or disimilar to the javascript event loop non-blocking model
15:55:01 <Sgeo> tgeeky, hello
15:55:03 <hughfdjackson> it seems to be, but..
15:55:21 <hughfdjackson> :D also, that question is open to all, it's just i know mauke's jsing is rather good
16:04:22 <ddarius> hughfdjackson: The answer is "no."
16:04:30 <hughfdjackson> ddarius: :D cheers
16:06:40 <ddarius> hughfdjackson: The two aren't even comparable.
16:06:48 <hughfdjackson> :D you've compared them
16:06:57 <hughfdjackson> by virtue of their dissimilar features, granted ;)
16:07:47 <ddarius> Haskell libraries can choose to prevent a non-blocking, event loop interface, and some do.  They can also present a blocking, threaded interface, and some do.  This is orthogonal to IO.
16:07:49 <shachaf> ddarius: They are similar in that they both use continuation-passing style.
16:07:58 <ddarius> shachaf: Neither uses continuation passing style.
16:08:22 <Sgeo> Is hSetBuffering stdin NoBuffering >> hSetBuffering stdout NoBuffering supposed to work on Windows?
16:08:38 <Sgeo> Because my .exe compiled from GHC running under WINE isn't buffering correctly
16:08:42 <Sgeo> I had a friend try it
16:08:43 <shachaf> ddarius: Well, they both involve passing continuations, at least?
16:09:11 <ddarius> shachaf: Not really unless any function that takes a function is "being passed a continuation."
16:14:14 <shachaf> ddarius: It's "what to do after this thing is done, possibly using the value it 'yields'".
16:14:25 <shachaf> That seems pretty similar to a continuation to me.
16:16:28 <elliott> Which of (Data.IntMap.IntMap a) and (Data.HashMap.Lazy.HashMap Int a) is likely to be faster? I seem to recall that the latter was faster at some point in time, but I don't know if that's still true.
16:17:41 <ddarius> shachaf: Is registering a handler for a button click passing a continuation?
16:18:25 <ddarius> For the non-blocking APIs, you -can- use continuation passing style with them, but that doesn't make them continuation passing style.
16:18:32 <shachaf> ddarius: I suppose I see your point.
16:19:52 <shachaf> What about IO in Haskell?
16:20:05 <ddarius> I will agree that it is not unreasonable to call the second argument to (>>=) a "continuation," but I don't think it is either necessary or helpful most of the time.
16:20:22 <shachaf> Fair enough.
16:20:30 <ddarius> IO in Haskell is not continuation passing style, otherwise you would have access to the continuation and could write callCC.
16:21:13 <ddarius> There are certainly very close connections between continuation passing style and monadic style.
16:21:30 <hpc> indeed, look at Cont
16:22:05 <ddarius> The reason (>>=) is called "bind" is because it models binding, let binding specifically.  In Moggi's monadic metalanguage, m >>= \x -> f x would be written let x <- m in f x
16:23:07 <ddarius> This corresponds exactly to the what the semantics of (non-recursive) let would be in an impure language like ML.
16:23:31 <nh2> haha oh man, I just accidentally built a fork bomb with QuickCheck
16:23:51 <nh2> I have a reference implementation in ./test
16:24:09 <nh2> and then I did a ghc --make test.hs ... :P
16:24:36 <nh2> where test.hs was the quickcheck file calling ./test
16:24:37 <shachaf> That doesn't have much to do with QuickCheck.
16:26:34 <nh2> shachaf: true, but I guess it is the general testing environment making one call everything just "test".
16:26:55 <ddarius> Calling executables "test" is usually a bad idea.
16:28:42 * ddarius kinda feels like making a simple SPIN in Haskell.
16:29:33 <shachaf> ddarius: As in the model checker?
16:29:34 <aristid> ddarius: i heard rotating teapots are the craze right now.
16:30:58 <j2j2> info
16:31:09 <ddarius> shachaf: Yes.
16:32:09 <mmos1127_> how do I convert Char to Word8?
16:32:16 <shachaf> mmos1127_: You can't.
16:32:35 <shachaf> A Word8 is a number between 0 and 255; there are more than 256 Chars.
16:32:47 <hpc> :t fromIntegral . ord
16:32:48 <lambdabot> forall b. (Num b) => Char -> b
16:32:53 <shachaf> Alternatively, (const 0).
16:33:07 <mmos1127_> I've done it before-- I think like hpc said.
16:33:09 <hpc> alternatively, accept that anything outside asciii will crash it
16:33:12 <shachaf> The point is that you need to figure out what you mean by "convert".
16:33:17 <shachaf> @karma+ before
16:33:18 <lambdabot> before's karma raised to 0.
16:33:25 <mmos1127_> okay, I want to turn String into ByteString
16:33:36 <aristid> mmos1127_: possible!
16:33:38 <shachaf> mmos1127_: It's more popular to conert Char to [Word8]
16:33:39 <elliott> mmos1127_: With which encoding?
16:33:40 <hpc> @hoogle pack
16:33:40 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelStorage Pack :: PixelStoreDirection
16:33:41 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
16:33:41 <lambdabot> Data.Text.Lazy pack :: String -> Text
16:33:46 <shachaf> mmos1127_: You'll need to encode it, then.
16:33:48 <hpc> oh look! :P
16:33:51 <elliott> shachaf: *hi5*
16:33:55 <shachaf> hpc: Be quiet.
16:33:59 <elliott> hpc: Only in Data.ByteString.LyingToYourself.
16:34:01 <McManiaC> working on a small new GHC extension: http://npaste.de/7ue1/
16:34:02 <McManiaC> :D
16:34:28 <mmos1127_> I accept that anything outside ascii will crash it, may I go in peace.
16:34:29 <aristid> shachaf: why? referring to Data.Text.Lazy.pack was quite sensible
16:34:33 <shachaf> hpc: That's like someone saying "I have Maybe x and I want x -- what do I do?", and anwering "fromJust".
16:34:42 <shachaf> aristid: I think hpc was referring to .Char8 there.
16:34:52 <shachaf> Especially given what the question was, and the previous "fromIntegral . ord".
16:34:58 <elliott> mmos1127_: Is there a reason you don't want Data.Text?
16:35:14 <mmos1127_> Actually taking another step back, I want strict IO
16:35:34 <elliott> You can do that with Strings, ByteStrings and Texts.
16:35:39 <ddarius> Actually, it won't crash it, it will just produce garbage.
16:35:47 <mmos1127_> ooh how do I do that with String?
16:36:07 <elliott> slurpHandle h = (:) <$> getChar <*> slurpHandle h ... well, with some boring error handling I've missed. I think it's on Hackage somewhere.
16:36:17 <elliott> http://hackage.haskell.org/package/strict-io, I believe.
16:36:29 <elliott> Oh, that's not it.
16:36:34 <mmos1127_> it's strict writing
16:36:34 <elliott> http://hackage.haskell.org/package/strict This is.
16:36:36 <shachaf> elliott: "h" there is for decoration, right? :-)
16:36:42 <elliott> shachaf: Err, yes.
16:36:48 <hpc> slurpHandle h = do {s <- hGetContents h; evaluate (length s); return s} -- nicer version?
16:36:51 <elliott> mmos1127_: writeFile is stict.
16:36:53 <elliott> strict.
16:37:11 <shachaf> At any rate you don't actually want to read a file one character at a time, probably.
16:37:11 <parcs`> ++++
16:37:12 <elliott> As is hPutStr and so on.
16:37:15 <ddarius> McManiaC: That's a horrible idea.
16:37:16 <parcs`> @karma ++
16:37:16 <lambdabot> ++ has a karma of 1
16:37:16 <elliott> So, er, don't worry, be happy.
16:37:31 <elliott> shachaf: Good thing GHC does buffering!
16:38:16 <mmos1127_> I'm a bit unclear, but tell you what I've write it using String and System.IO.writeFile and if it crashes becasue too many files are open, then I'll know I need to change something.
16:38:28 <monochrom> hPutStr doesn't read one character at a time
16:38:37 <elliott> mmos1127_: Well, yes, you need to change *something*.
16:38:41 <parcs`> McManiaC: what does that do?
16:38:43 <elliott> It's probably not writeFile.
16:38:47 <McManiaC> ddarius: worse than exploiting do-notation for stuff like blaze-html?
16:38:53 <ddarius> monochrom: All the characters that it reads, it reads one at a time.
16:39:10 <mmos1127_> Thanks for patience with a beginner everyone!
16:39:10 <ddarius> McManiaC: That's horrible too, but I suspect not as horrible as this.
16:39:16 <mmos1127_> every-single-person++
16:39:28 <McManiaC> ddarius: why?
16:40:49 <sanjoyd> @src replace
16:40:49 <lambdabot> Source not found.
16:40:54 <McManiaC> parcs`: basically desugares "foo{ a }" to "addRecordValue foo a"
16:41:15 <ddarius> McManiaC: Except that that doesn't seem to be what you want as neither of your examples have that form.
16:41:36 <ddarius> Or rather the second does but doesn't really fit the type or my guess at your intent.
16:42:11 <ddarius> McManiaC: Why do you want to do this?
16:42:40 <McManiaC> ddarius: as a replacement for said do-notation exploits
16:43:15 <ddarius> McManiaC: Why don't you just use functions and lists?  Can you provide an example of something that you want to write and how you'd write it with this extension?
16:44:16 <ddarius> McManiaC: Note that what blaze-html is really trying to steal by using do-notation is -layout- which this extension does not look like it will provide.
16:44:25 <McManiaC> ddarius: http://npaste.de/o8m/ as a very simple example
16:46:07 <elliott> To the best of my knowledgw, what blaze-html wants is layout for monoids.
16:46:11 <elliott> *knowledge
16:46:45 <ddarius> McManiaC: And what is wrong with html [head [title "bla bla"]), body [style "margin: 20px;", h1 ["Yo!], p [em ["So"], "konnte das dann aussehen"]]], suitably laid out?
16:47:05 <hpc> ddarius: ending a line with lots of ]]]]]]]]]]]]]]]]]
16:47:13 <elliott> hpaste: As opposed to lots of }}}}}}}
16:47:28 <hpc> or lots of )))))))) ala lisp
16:47:39 <elliott> Erm.
16:47:40 <elliott> *hpc:
16:47:50 <ddarius> hpc: That's no different than his proposed extension.
16:48:19 <ddarius> Except I don't need to use shift to type ] and I do for }.
16:48:24 <hpc> ddarius: i missed the description of the extension
16:48:27 <hpc> heh, also that
16:48:36 <hughfdjackson> the Simon Peyton-Jones talks were *really* good
16:48:39 <hughfdjackson> *talk
16:48:41 <hughfdjackson> *was
16:48:47 <ddarius> hughfdjackson: Yes, SPJ is fun to watch.
16:48:50 <hughfdjackson> :P even if it took me most of the day to get through
16:48:52 <Phlogistique> hi
16:48:53 <aristid> ddarius: you forgot that there needs to be an umlaut. that's what's wrong.
16:49:20 <elliott> He also has an unmatched ) and ".
16:49:29 <elliott> Clearly inferior :)
16:50:00 <McManiaC> ddarius: flexibility in the types, e.g. 'style' could be a separate type and the HTML record only has a "HtmlStyle Style" field
16:50:12 <aristid> elliott: maybe he just wanted to test us if we find the errors. it's ddarius after all
16:50:21 <ddarius> McManiaC: You can accomplish that with exactly that syntax.
16:51:30 <Phlogistique> I just read the chapter about Parsec on RWH; I'm surprised that the programmer is supposed to write the applicative instance themselve
16:51:42 <ddarius> Phlogistique: No they aren't.
16:52:12 <elliott> Phlogistique: Parsec 3 (I think) fixed that.
16:52:35 <Phlogistique> cool
16:52:37 <aristid> RWH is outdated regarding a number of things
16:52:48 <aristid> the haskell library ecosystem is moving extremely fast
16:53:18 <ddarius> Phlogistique: It's not like it would be terribly trying even if you did.  instance Applicative (Parsec x y) where (<*>) = ap; pure = return
16:53:42 <Phlogistique> isn't there any up to date tutorial for Parsec?
16:53:42 <Sgeo> Are there any compiler pragmas I can put in my .hs file to force it to be -threaded?
16:53:54 <Phlogistique> ddarius:  indeed
16:53:57 <shachaf> {-# OPTIONS_GHC -threaded #-} ?
16:54:14 <rwbarton> that seems likely to not work
16:54:18 <ddarius> Phlogistique: Very little about the core has changed.  The Parsec Letter is still the best introduction.  Just be aware the module names have changed and there are a few slight differences.
16:54:25 * hackagebot hasktags 0.68.2 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.68.2 (MarcWeber)
16:54:42 <rwbarton> since I think -threaded specifies the threaded runtime, which is not a per-file option. (?)
16:54:59 <elliott> Sgeo: Why do you want to do that?
16:55:09 <shachaf> rwbarton: Oh, true.
16:55:14 <Phlogistique> a shame the parsec letter can't be updated
16:55:27 <Sgeo> Because a library I may or may not make will call foreign functions, and I want to be sure other threads aren't blocked
16:55:45 <ddarius> Someone could copy it to the wiki and it could be updated from there.
16:56:40 <shachaf> Sgeo: Oh, in a library?
16:56:48 <shachaf> As rwbarton mentioned, -threaded isn't per-file.
16:57:01 <shachaf> It's a link-time option.
16:57:32 <Sgeo> Should I use forkOS, or tell users of the library to use -threaded?
16:57:52 <elliott> If someone doesn't want their program blocking, I would hazard a guess that they'll already be using -threaded.
16:57:52 <ddarius> Sgeo: forkOS will make no difference.
16:58:06 <Sgeo> Ah, ok
16:58:06 <ddarius> Sgeo: forkOS is only if you are working with a library with thread local state.
16:58:06 <elliott> Forcing the decision seems pointless.
16:58:20 <rwbarton> yeah, maybe I don't get something but if the user doesn't have -threaded then there are no other threads to be blocked...
16:58:27 <shachaf> Sgeo: You should read some "introduction to what forkOS and forkIO actually mean".
16:58:38 <Sgeo> If my library uses forkIO for stuff, though
16:59:31 <rwbarton> oh
17:00:03 <shachaf> I wonder if there is such an introduction anywhere.
17:00:17 <ddarius> shachaf: Yes, read the Haddock documentation.  It explains this in detail.
17:01:16 <ddarius> Really, all you need to know is that if you are not dealing with thread local state, then there is no semantic difference between forkOS and forkIO, and you should prefer the latter.
17:01:29 <shachaf> ddarius: I don't think "Using forkOS instead of forkIO makes no difference at all to the scheduling behaviour of the Haskell runtime system." is correct.
17:01:38 <elliott> shachaf: ISTR the paper originally describing forkOS was helpful to me.
17:01:45 <ddarius> It doesn't make any observable difference.
17:01:52 <shachaf> Though that's an implementation detail, not about the guarantees forkIO/forkOS give you.
17:02:31 <Sgeo> I don't think the foreign library has thread-local state. It's not a thread-safe library, but I believe that's for different reasons that I do understand.
17:02:44 <ddarius> Sgeo: Then use forkIO.
17:02:44 <shachaf> Also, s/it's/its/g in http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html :-)
17:03:03 <ddarius> Sgeo: Will the foreign functions call blocking functions?
17:03:36 <Sgeo> In normal operation, it does, but I can disable those with no loss of functionality, because there are callback versions of all of those.
17:03:40 <Sgeo> I think.
17:04:04 <Sgeo> Actually, well, I think they may all block for short lengths of time, and longer lengths of time are annoying for reasons unrelated to blocking.
17:05:28 <karoyakani> @pl palindrome xs = if reverse xs == xs then "yes" else "no"
17:05:28 <lambdabot> palindrome = flip (flip if' "yes" . ((==) =<< reverse)) "no"
17:05:55 <elliott> @unpl ((==) <*> reverse) xs
17:05:56 <lambdabot> ((==) <*> reverse) xs
17:06:00 <elliott> :|
17:06:19 <shachaf> karoyakani: "yes" and "no"? Really?
17:06:20 <Sgeo> Basically: It's an event-based library. There's a function to run one step, but there are synchronous functions that can wait for a length of time. But event handlers can end up running during that length of time.
17:06:47 <rwbarton> shachaf: Leaves room for future expansion.
17:07:48 <shachaf> karoyakani: (This is the sort of thing you'd just use booleans for, normally.)
17:08:09 <ddarius> The paper "Extending the Haskell Foreign Function Interface with Concurrency" explains -all- of this in detail.
17:08:21 <rwbarton> @pl if x then True else False
17:08:21 <lambdabot> if' x True False
17:08:22 <shachaf> let equal x y = if x == y then "yes" else "no"; let palindrome xs = if equal xs (reverse xs) == "yes" then "yes" else "no"
17:08:33 <rwbarton> @pl x == True
17:08:33 <lambdabot> x == True
17:08:38 <rwbarton> @pl x == False
17:08:39 <lambdabot> x == False
17:08:58 <Sgeo> @pl \x -> x == True
17:08:58 <lambdabot> (True ==)
17:09:07 <elliott> Sgeo: Just use (writeChan foo ...) as the event handlers so they run in ~0 time.
17:09:32 <Sgeo> And use a global Chan or something, or what?
17:09:50 <Sgeo> elliott, also, event handlers mean not having to deal with the blocking issue
17:09:57 <Sgeo> I think
17:10:00 <Sgeo> It's been a while
17:11:54 <elliott> Sgeo: A global Chan? Haskell has lexical scoping.
17:12:10 <elliott> do { c <- newChan; spawnHandlerHandlerThreadThing c; installEventHandler e (writeChan c ...) }
17:12:41 <Sgeo> Oh, and give that Chan to whatever wants to use it?
17:12:49 <Sgeo> (Or at least the readChan of it)
17:13:16 * elliott shrugs
17:13:18 <Sgeo> But then no, I don't want to hook up another chan if some other function also wants a chan
17:13:22 <elliott> What?
17:13:29 <elliott> OK, here's an example.
17:13:48 <Sgeo> I guess I could though. I will absolutely abstract away at a low level the nonsense about only one event handler for any given event.
17:14:01 <elliott> installEventHandlerWithoutBlockingRiskInTheLibrary handler = do { c <- newChan; forkIO $ forever (readChan c >> handler); rawInstallEventHandler e (writeChan c ()) }
17:14:24 * hackagebot ekg 0.3.0.0 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.0.0 (JohanTibell)
17:14:41 <Sgeo> elliott, getting rid of the blocking risk only entails installing event handlers, I don't need to make the handlers take 0 time.
17:15:07 <Sgeo> But yeah, I should be thinking chans, probably
17:15:18 <elliott> I was just responding to "But event handlers can end up running during that length of time.".
17:17:31 <ion> runInstallEventHandlerWithoutBlockingRiskInTheLibraryWithoutBlockingRiskInTheLibrary
17:18:11 <elliott> :D
17:22:34 <rwbarton> Is FactoryFactory Java's version of IO (IO (IO a))?
17:23:29 <shachaf> rwbarton: Isn't a "factory" like a function that makes something?
17:23:58 <shachaf> In which case it would presumably be the equivalent of a -> b -> c.
17:24:06 <rwbarton> I think they call functions "classes", but yes
17:24:16 <Sgeo> client :: (MonadIO m, CryptoRandomGen g) => TLSParams -> g -> Handle -> m (TLSCtx Handle)
17:24:26 <Sgeo> Would I get the Handle from Network?
17:24:54 <Sgeo> That's the only way I can make sense of this
17:24:55 <rwbarton> But it's in IO, and it's not a -> b -> IO c, it's a -> IO (b -> IO c)
17:25:30 <shachaf> Fair enough. a -> IO (b -> IO c)
17:25:49 <shachaf> Or, if a and b aren't used, just IO (IO c).
17:26:18 <Sgeo> Is http://hackage.haskell.org/packages/archive/tls/0.8.4/doc/html/Network-TLS.html anywhere near safe enough for real use?
17:27:42 <The_Journey> how would I pattern match using records syntax?
17:29:50 <shachaf> The same way that you create values using record syntax.
17:30:51 <Sgeo> Does lambdabot know of any record datatypes?
17:30:59 <Sgeo> So I could make an example?
17:31:16 <hpc> > Identity {runIdentity = 5}
17:31:17 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity t))
17:31:17 <lambdabot>    arisi...
17:31:21 <shachaf> I'm sure you can make an example without having lambdabot evaluate it.
17:31:24 <hpc> :t Identity {runIdentity = 5}
17:31:25 <lambdabot> forall t. (Num t) => Identity t
17:31:33 <hpc> @src Identity
17:31:33 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
17:31:36 <Sgeo> ty
17:32:14 <Sgeo> > (\(Identity { runIdentity=char } -> char) (Identity 'a')
17:32:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:32:29 <Sgeo> > (\(Identity { runIdentity=char }) -> char) (Identity 'a')
17:32:30 <lambdabot>   'a'
17:32:46 <Sgeo> The_Journey, do you understand lambdas? Can you understand my example?
17:33:47 <Sgeo> > (\(Identity { runIdentity='b' }) -> char) (Identity 'a')
17:33:48 <lambdabot>   Overlapping instances for GHC.Show.Show
17:33:48 <lambdabot>                              (GHC.T...
17:33:52 <Sgeo> Wait what
17:34:18 <The_Journey> Sgeo: you're pattern matching if it's runIdentity's type is a char...?
17:34:48 <monochrom> > char
17:34:49 <lambdabot>   Overlapping instances for GHC.Show.Show
17:34:49 <lambdabot>                              (GHC.T...
17:34:50 <rwbarton> no, he just named the field 'char'
17:34:53 <monochrom> that's why
17:34:58 <ski> > (\(Node {rootLabel = x,subForest = ys}) -> (x,ys)) (Node () [])
17:34:59 <lambdabot>   ((),[])
17:35:03 <monochrom> @undefine
17:35:05 <monochrom> > char
17:35:06 <lambdabot>   Overlapping instances for GHC.Show.Show
17:35:06 <lambdabot>                              (GHC.T...
17:35:09 <Sgeo> > (\(Identity { runIdentity='b' }) -> c) (Identity 'a')
17:35:10 <lambdabot>   *Exception: <interactive>:3:1-36: Non-exhaustive patterns in lambda
17:35:10 <rwbarton> er not the field, the variable that will hold the value of the field
17:35:13 <monochrom> @type char
17:35:14 <lambdabot> Char -> Doc
17:35:15 <Sgeo> > (\(Identity { runIdentity='a' }) -> c) (Identity 'a')
17:35:16 <monochrom> :)
17:35:16 <lambdabot>   c
17:35:25 <Sgeo> !!!
17:35:30 <Sgeo> wait, what
17:35:32 <Sgeo> Oh, derp
17:35:40 <Sgeo> > (\(Identity { runIdentity=c }) -> c) (Identity 'a')
17:35:41 <lambdabot>   'a'
17:35:53 <The_Journey> Sgeo: would it be possible for you to show an example on codepad?
17:35:57 <Sgeo> The_Journey, I am pattern matching on the runIdentity record.
17:35:58 <Sgeo> Sure
17:36:16 <monochrom> you want this:  (\(Identity { runIdentity='x' }) -> "should err") (Identity 'a')
17:37:27 <gwern> > 0.99 * 0.3 * 0.5
17:37:28 <lambdabot>   0.1485
17:37:43 <Sgeo> http://codepad.org/z08zBUgk
17:38:13 <Sgeo> I am pattern matching with pattern theChar and field myField
17:39:09 <The_Journey> Sgeo: ah ok, I see, thank you
17:39:17 <Sgeo> You're welcome.
17:39:33 <Sgeo> Note that I could have used the same name for the type and the constructor. They don't interfere
17:39:48 <The_Journey> Sgeo: say that myField is a list, how would I pattern match whether if it's an empty list?
17:40:10 <ski> Blah {myField = [], &c.}
17:40:23 <Sgeo> [] for the empty list
17:40:27 <The_Journey> ok, thank you
17:40:31 <Sgeo> (x:xs) for a non-empty list
17:40:37 <Sgeo> Or _ if it's below []
17:40:51 <monochrom> you can enter any pattern after that "="
17:41:08 <Sgeo> Just like regular pattern matching
17:41:28 <monochrom> myfun Blah{f = Stuff{mylist=[]}, n=True} = ... :)
17:42:13 * ski . o O ( s/.../(.../ )
17:42:15 <Sgeo> Does it make sense to have an API where Chans are retrieved, instead of being event-based the way the underlying library is?
17:42:22 <monochrom> because "Stuff{mylist=[]}" is just another pattern that happens to use record again!
17:42:49 * ski records the pattern
17:42:59 <rwbarton> :t 1 ?* 2
17:43:00 <lambdabot> Not in scope: `?*'
17:43:12 <rwbarton> :t ?(*) 1 2
17:43:13 * monochrom loves the uniformity availed by recursive definitions
17:43:13 <lambdabot> parse error on input `?'
17:43:17 <Sgeo> @hoogle (?*)
17:43:18 <lambdabot> No results found
17:43:31 <Sgeo> rwbarton, oh, that weird trick? Ask .. hold on
17:43:36 <Sgeo> n/m
17:43:58 <rwbarton> no implicit parameter operators, I guess
17:44:11 <rwbarton> :t 1 `?f` 2
17:44:12 <lambdabot> parse error on input `?f'
17:44:25 <BMeph> :t (?(*)) 1 2
17:44:26 <lambdabot> Not in scope: `?'
17:44:26 <Sgeo> :t ?f 1 2
17:44:27 <lambdabot> forall t t1 t2. (?f::t1 -> t2 -> t, Num t1, Num t2) => t
17:44:32 <ski> @type let (*) = ?foo in 1 * 2
17:44:33 <lambdabot> forall t t1 t2. (?foo::t -> t1 -> t2, Num t, Num t1) => t2
17:44:59 <Sgeo> :t ?f a b c d e f g
17:45:00 <lambdabot> forall t a a1. (?f::Expr -> Expr -> Expr -> Expr -> Expr -> a -> a1 -> t, SimpleReflect.FromExpr a, SimpleReflect.FromExpr a1) => t
17:45:08 <Sgeo> :t ?f a b c d e f g a c b c
17:45:09 <lambdabot> forall t a a1. (?f::Expr -> Expr -> Expr -> Expr -> Expr -> a -> a1 -> Expr -> Expr -> Expr -> Expr -> t, SimpleReflect.FromExpr a, SimpleReflect.FromExpr a1) => t
17:45:19 <ski> @quote
17:45:19 <lambdabot> sigfpe says: Clearly the first line of code ought to be 'extract :: (Monad m) => m a -> a'. The rest of the post will fill in the details.
17:52:37 <aristid> wat?
17:52:51 <aristid> i didn't know that sigfpe is that evil
17:53:07 <ddarius> Sgeo: In my opinion, a blocking, thread-based API is always preferable from a usability standpoint.  The only question for me is whether I should provide cooperative or pre-emptive concurrency.
17:56:21 <Sgeo> aristid, I just googled it, he's 100% serious
17:56:25 <Sgeo> As far as I can tell
17:57:25 <Sgeo> Oh, here's the catch:
17:57:29 <Sgeo> Or should I not spoil it
17:57:34 <Sgeo> http://blog.sigfpe.com/2009/01/rewriting-monadic-expressions-with.html
17:59:21 <irene-knapp> hm
18:01:12 * ddarius forgets whether he implement the CEK or Krivine's abstract machine as a collection of rewrite rules.
18:03:05 <ddarius> Hmm... I should write a Joy interpreter that way.  I wonder if I could use that to program crazy optimizations.
18:03:54 <j2j2>  
18:05:58 <ski> Sgeo : sounds related to TheHunter's <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> in 2005
18:09:49 <aristid> Sgeo: that's one of his less interesting blog posts i think
18:15:26 <Sgeo> ddarius, thing is, isn't it approximately as easy, in Haskell, to convert callback-taking functions to regular style with an MVar as it is to convert regular style to threads?
18:18:30 <Sgeo> What's the difference between unsafeCoerce and unsafeCoerce# ?
18:20:04 <ddarius> unsafeCoerce# is GHC-specific.
18:20:48 <ddarius> Sgeo: What is "regular style"?
18:21:06 <Sgeo> Just calling something in a blocking way
18:21:53 <ddarius> "Regular style" would be threads then.
18:23:13 <tibbe> Sgeo: we convert callbacks to threads in the I/O manager using MVars
18:23:48 <Sgeo> So would it really be easier to supply a blocking library?
18:24:04 <ddarius> Sgeo: No, it would be easier to use a blocking library.
18:24:16 <Sgeo> erm, yeah, oops
18:25:17 <dmitri_> bmiTell weight height
18:25:17 <dmitri_>     | bmi <= 18.5 = "You're underweight, you emo, you!"
18:25:17 <dmitri_>     | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
18:25:17 <dmitri_>     | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"
18:25:17 <dmitri_>     | otherwise   = "You're a whale, congratulations!"
18:25:17 <dmitri_>     where bmi = weight / height ^ 2
18:25:42 <irene-knapp> heh
18:25:43 <irene-knapp> cute
18:25:49 <alistra> is it kg or miles?
18:26:27 <Clint> figs
18:26:36 <aristid> alistra: it's kg^2/m^2
18:27:11 <alistra> well i'm fat without the kg^2
18:27:51 <alistra>  It was invented between 1830 and 1850
18:28:01 <alistra> enjoy your up-to-date scales
18:28:02 <aristid> sorry, my mistake. it's kg/m^2
18:28:07 <irene-knapp> yes, I was going to say
18:28:40 <ddarius> Sgeo: I would recommend reading "On the Duality of Operating System Structures" and "A Language-Based Approach to Unifying Threads and Events" at some point.
18:29:19 <ddarius> kg isn't a weight(!)
18:29:25 <irene-knapp> it's a mass, yes
18:30:01 <Philippa> that's not the most screwy thing about BMI, but hey
18:30:02 <ddarius> I guess that's consistent with "BMI."
18:31:06 <ddarius> If you are going to reduce someone's health to a single number that is relatively easily measurable, BMI is not the best.  Of course, reducing someone's health to a single number is not the most advisable route.
18:31:14 <irene-knapp> indeed
18:31:39 <aristid> ddarius: if you only need to regulate a single thing, then one number might be fine
18:31:44 <irene-knapp> hey I've got one
18:31:49 <ghorn> I want compile time errors on tensor dimension mismatch. I've done it with FunDeps but that leads to UndecidableInstances. Could I get a hand converting http://pastebin.com/c8ECNw67 to use type families?
18:31:51 <mauke> The paste c8ECNw67 has been copied to http://hpaste.org/55966
18:31:52 <irene-knapp> let's use IQ as a measure of health
18:31:59 <irene-knapp> it should be at least vaguely correlated!
18:32:00 <ddarius> ghorn: Yes.
18:32:06 <ddarius> Er maybe.
18:32:06 <irene-knapp> and it's at least vaguely measurable, too!
18:32:17 <alistra> ddarius: well thanks to encoding a one number is as good as any finite number of numbers
18:32:41 <aristid> irene-knapp: i read that it is correlated, except for intelligent people being more likely to consume alcohol
18:32:47 <irene-knapp> haha, logical
18:32:57 <aristid> *positively correlated
18:32:59 <alistra> Iq is hard to measure above some level
18:33:00 * irene-knapp nods
18:33:09 <ddarius> IQ is hard to measure.
18:33:15 <aristid> irene-knapp: know it from experience?
18:33:22 <alistra> because you need a person with higher iq to create the questions or whatever
18:33:28 <irene-knapp> it's also hard to measure because I lose six stones as a Go player (the equivalent of about two years of experience) by skipping dinner
18:33:35 <aristid> ddarius: did the scales explode when they tried to measure yours?
18:33:41 <alistra> it's like universal turing machines and diagonalization all over again
18:33:47 <irene-knapp> in fact, stones of Go ability is probably a much more meaningful metric of intellect than IQ :)
18:33:49 <ddarius> As far as I know, I've never taken an IQ test.
18:34:10 <penelope> ghorn: Shape?
18:34:14 <aristid> irene-knapp: have you tested the effects of sleep deprivation on your stones?
18:34:16 <irene-knapp> but I only mentioned it because I can't imagine that the skipping-dinner thing doesn't also affect my IQ, were it to be measured
18:34:23 <ddarius> irene-knapp: Thus everyone who's never played Go is a complete idiot?
18:34:25 <ghorn> penelope: excuse me?
18:34:29 <irene-knapp> painfully, yes.  it hurts but not as much as the low blood sugar does :)
18:34:32 <Philippa> irene-knapp: couple that with a weird form of diabetes and maybe some mood issues for an encore and you end up with something that tends to make you choose between smarts and fitness, too
18:34:35 <irene-knapp> ddarius: hmmmmm
18:34:41 <irene-knapp> Philippa: true, hm.
18:34:45 <aristid> irene-knapp: of course it would affect your IQ, as those tests do involve cognitive stuff
18:34:53 <irene-knapp> aristid: yes, indeed
18:34:57 * BMeph has taken many IQ tests, but the owners always demand them back...
18:34:58 <penelope> ghorn: The Shape type library, used in Repa?
18:35:28 <mokus> BMeph: getting caught lowers your score ;)
18:37:04 <penelope> I have an iq of 100i.
18:37:13 <irene-knapp> hmm.
18:37:27 <aristid> penelope: fascinating. doubtful, though.
18:37:43 <ddarius> I should formulate a game theoretic semantics for FRP.
18:37:49 <penelope> Hmm.
18:37:58 <Philippa> aristid: Imagination Quotient? Seems likely to me
18:38:26 <penelope> I guess haskell is not yet agda, yet.
18:39:21 <aristid> penelope: it probably won't be for the foreseeable future
18:41:46 <jmcarthur> ddarius: i have no idea how that would work, but it sounds awesome
18:41:53 <jmcarthur> s/work/look/
18:43:00 <ghorn> penelope: I think i will use that, but I don't think it lets me add scalar to vector or matrix while preventing adding vector to matrix
18:43:19 <ghorn> I'm doing a symbolic expression library w/ automatic differentiation
18:43:24 <penelope> ghorn: It's the preludes fault, I think.
18:43:48 <Sgeo> Does it make any sense to mix FRP and conduits?
18:43:52 <ghorn> penelope: for making Num single parameter type class ?
18:44:28 <penelope> For overspecifiying +, and tying it together with, for example -
18:44:32 <jmcarthur> Sgeo: i'm not familiar with "conduits"? what is it / are they?
18:44:59 <Sgeo> jmcarthur, something similar to iteratees, but a bit different
18:45:04 <ben> the yesod iteratee replacement
18:45:21 <BMeph> jmcarthur: Snoyman's latest side-project. :)
18:45:27 <ben> http://www.yesodweb.com/blog/2011/12/resourcet
18:45:28 <ghorn> penelope: i agree, that is really annoying
18:45:36 <aristid> jmcarthur: which he's moving yesod and everything to.
18:45:45 <jmcarthur> huh
18:45:50 * jmcarthur reads
18:45:58 <Philippa> much as Num sucks, ultimately the worst it costs you is the name you wanted though
18:46:11 <ben> the github page has a "this is why this is not iteratees" summary
18:46:19 <aristid> jmcarthur: by the way when you have read it, tell me whether Source forms a Monad. i am still not sure.
18:46:48 <penelope> gah. what am I going to wear now that I spent all this money on iteratree boots.
18:46:49 <ghorn> Philippa: you mean (+) ?
18:46:55 <Sgeo> But does it make sense to do streaming stuff like that in the same project as FRP?
18:46:59 <rwbarton> nothing really wrong with (+) :: a -> a -> a
18:47:07 <Sgeo> Or does FRP subsume conduits/iteratees?
18:47:13 <penelope> but
18:47:14 <jmcarthur> Sgeo: i think these sound like somewhat orthogonal things
18:47:15 <penelope> in math
18:47:30 <penelope> (+) has many overloaded meanings
18:47:32 <ben> remind me what the solution for being unable to sensibly say liftIO $ withFile ... is
18:47:35 <penelope> which is why
18:47:39 <penelope> f = ma
18:48:04 <rwbarton> you don't really ever (+) two things of different types, though there might be some "implicit conversions"
18:48:08 <penelope> works just as well in newtonian as in relativistic mechancis
18:48:10 <aristid> rwbarton: (+) :: a -> a -> a can only be const or flip const, or something involving bottom, i think
18:48:18 <rwbarton> I mean inside a class of course
18:48:25 <aristid> oh
18:48:27 <rwbarton> class Add a where
18:48:36 <ghorn> for me right now "implicit conversions" means runtime checks
18:48:47 <aristid> rwbarton: why didn't you say that?
18:48:53 <rwbarton> the context made it clear
18:48:53 <ski> rwbarton : point plus vector ?
18:48:58 <rwbarton> hmmmmm
18:49:00 <aristid> rwbarton: did it?
18:49:10 * BMeph refuses to point out complex numbers to penelope as an example of "adding different things"...
18:49:30 <ben> BMeph: the assumption is that either side of + for complex numbers is already a complex number, surely
18:49:42 <ben> 5 + 3i, both 5 and 3i are complex numbers?
18:49:56 <rwbarton> ski: I guess that is a good example, though I wouldn't feel too bad about making "additive action" a separate operator, I'm already sort of ambivalent about multiplication/action
18:50:08 <ski> > 5 :: Complex CReal
18:50:09 <lambdabot>   5.0 :+ 0.0
18:50:21 <penelope> Everything is a complex number, except that everything is a quaternion, etc.
18:50:47 <alistra> > 5.0 + 0.0
18:50:48 <lambdabot>   5.0
18:50:51 * BMeph is confused; isn't everything an object? ;þ
18:50:57 <rwbarton> ski: though you're definitely right about (+) being used that way in math
18:51:10 <Philippa> BMeph: no, but everything is objectionable
18:51:11 <Z_G> I thought everything was a memory location?
18:51:13 <alistra> > fix (+)
18:51:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:51:52 <irene-knapp> cute, haha
18:52:12 <Philippa> Z_G: that's one that definitely isn't reliable. You might launch those missiles via some kind of CPU-level OUT instruction with no corresponding memory, for example
18:52:37 <ghorn> adding real to complex is compatible, and you could say adding real or complex to quaternion is also compatible
18:52:40 <ghorn> there's a heirarchy
18:52:45 <rwbarton> anyways, though there may be practical advantages (as well as disadvantages) to class Add a b c where (+) :: a -> b -> c, I think it doesn't match the underlying math well
18:52:48 <ghorn> but adding vector to matrix is not compatible
18:53:02 <ben> It kinda feels like the C++ guys are gonna be laughing at us for coming up with conduits ResourceT while they have been enjoying their RAII for ages.
18:53:21 <ski> > fix (In . Endo . (+))
18:53:22 <lambdabot>   No instance for (GHC.Num.Num (L.Mu Data.Monoid.Endo))
18:53:22 <lambdabot>    arising from a use...
18:53:33 <penelope> ghorn: but doesn't it depend on what you want + to mean in the context?
18:54:04 <aristid> ghorn: unless the matrix happens to be n*1
18:54:16 <ski> rwbarton : *nod*
18:54:43 * Philippa notes that pure and especially foundational maths is often done with more precision and/or formality than most applied maths
18:55:08 <penelope> For instance, we might want a + b /= b + a
18:56:26 <aristid> what if we want + to involve a random number generator? i propose class MonadRandom m => Random a b c m where (+) :: a -> b -> m c
18:56:46 <aristid> -Random+Add
18:56:47 * ski . o O ( non-commutative geometry )
18:56:58 <rwbarton> it's not *that* non-commutative :P
18:57:07 <ghorn> yes, * for quaternion multiply or matrix multiply is non-commutative
18:57:15 <jmcarthur> based on that blog post, this stuff looks more like regions than iteratees
18:57:26 <aristid> jmcarthur: that's just the first part.
18:57:29 <jmcarthur> aristid: i didn't see Source anywhere
18:57:32 <jmcarthur> ah!
18:57:43 <ghorn> in my library (*)/(+) is not commutative as I build symbolic expression trees
18:57:49 <jmcarthur> continuing...
18:58:38 <aristid> jmcarthur: this is the definitive source: https://github.com/snoyberg/conduit
18:58:52 <aristid> blog posts can be inconclusive
18:58:54 <ddarius> "Foundational" math is usually (formal) logic.
18:59:11 <penelope> ghorn: so there must be a most general form you want to accept/express?
18:59:19 <aristid> ddarius: you do not consider logic a part of math?
18:59:30 <ddarius> ghorn: Let's not forget octonions.
18:59:43 <ghorn> ddarius: thank you I almost forgot octonions
19:00:30 <ddarius> aristid: I'm not sure what part of my statement fails to suggest the opposite of that.
19:00:54 <ghorn> penelope: what is more general than (+) :: a -> b -> c   ?
19:01:02 <mokus> (+) :: a
19:01:08 * ddarius was too slow.
19:01:53 <Philippa> ghorn: there's little point to that, as you might as well just run with a ton of newtypes
19:02:14 <ben> (+) :: c => a
19:02:17 <JoeyA> Is it possible to document data constructor arguments with Haddock, without using record or GADT syntax?
19:02:19 <penelope> hee. foo = undefined == ruby
19:02:28 * ski . o O ( "The Octonions" by John C. Baez in 2001-05-16 at <http://math.ucr.edu/home/baez/octonions/oct.ps> )
19:02:50 <Sgeo> With data Peano = Zero | Succ Peano; infinity = fix Succ, does infinity act as one would expect?
19:02:59 <Sgeo> (And appropriate instances ofc)
19:03:12 <ddarius> Sgeo: More or less.
19:03:15 <Sgeo> n + infinity is infinity, infinity - infinity is undefined
19:03:26 <penelope> But you mean Alpha0, not infitity.
19:03:39 <ddarius> penelope: "Aleph"?
19:03:41 <aristid> ddarius: nothing of your statement necessarily suggests that logic is math. "is" is not symmetric.
19:03:44 <byorgey> Sgeo: yes
19:03:46 <penelope> Yes.
19:03:48 <ghorn> well hijacking (+) from Num is an issue for my library, but i'm fine with using GhornAdd instead and defining really specific behavior that I want
19:03:49 <Philippa> and w is just as likely around here
19:04:05 <Sgeo> But one of 0 * infinity or infinity * 0 is overdefined, I think
19:04:06 <Z_G> Can anyone recommend a graphics library that's working with ghc7.* hgl seems to have dependency failures and piping out to netpbm format is getting a little boring.
19:04:07 <ghorn> and I still don't know how to do that
19:04:12 <Philippa> aristid: given that "logic" contains a lot more than formal logic...
19:04:27 <Sgeo> At least, for the typical ways of implementing *
19:04:29 <Philippa> "mathematical logic is maths" is somewhat less enlightening
19:04:48 <ddarius> aristid: Is foundational math not math?
19:05:41 <aristid> ddarius: it doesn't necessarily have to be classified as such.
19:05:55 <aristid> ddarius: it could be that you would see it as logic, and not so much as math.
19:05:57 <byorgey> Sgeo: given the obvious definition of multiplication, 0*inf would be 0 and inf*0 would be undefined.
19:06:10 <aristid> ddarius: which is the wrong interpretation, and that's why i asked.
19:06:52 <Sgeo> byorgey, and ideally it would be both undefined, right?
19:07:00 <byorgey> Sgeo: depends on your point of view.
19:07:15 <byorgey> Sgeo: from mine, ideally they would both be zero.
19:07:25 <ddarius> Which is easily accomplished.
19:07:32 <penelope> Aleph0 is well defined.
19:07:52 <byorgey> indeed, just add an extra case to the definition of multiplication checking whether the second argument is zero.
19:09:21 <aristid> > [1..] >> []
19:09:25 <lambdabot>   mueval-core: Time limit exceeded
19:09:35 <aristid> > [] >> [1..]
19:09:36 <lambdabot>   []
19:09:57 <ski> byorgey : and then `0 * _|_' isn't `0'
19:10:15 <aristid> > length ([1..3] >> [1..7])
19:10:16 <lambdabot>   21
19:10:26 <ski> (or the other way around, if you check the first argument first)
19:11:05 <aristid> byorgey: should >> also return [] for [1..]>>[]?
19:11:34 <rwbarton> is (>>) even a class method?
19:11:40 <aristid> no
19:12:01 <aristid> i'm not sure if there is a native Data.List equivalent for (>>)
19:12:14 <rwbarton> actually it is
19:12:24 <aristid> what's the name?
19:12:29 <rwbarton> but still having x >> y =/= x >>= \_ -> y seems poor
19:12:46 * ski regards default definitions as laws
19:12:48 <rwbarton> I mean is it a member of Monad, rather than defined outside
19:13:48 <ddarius> do nRef <- newIORef 0; let { p = replicateM_ 10 $ do n <- readIORef nRef; writeIORef nRef (n+1) }; forkIO p; forkIO p; waitUntilIdle; readIORef nRef
19:14:01 <Veinor> ski: same here
19:14:11 <ddarius> What are the possible return values of that action (if waitUntilIdle blocks until both instances of p are finished)?
19:14:22 <jmcarthur> aristid: i think that if Source is a monad then it's very non-obvious
19:15:09 <aristid> jmcarthur: you can define return (= a source that just returns one element), and concatenate
19:15:33 <jmcarthur> ah, treating it like a list
19:15:43 <aristid> yes
19:16:00 <jmcarthur> i see
19:16:19 <aristid> jmcarthur: but there are these pesky monad laws and i have no idea how to go about showing whether they are violated or not
19:18:21 <ghorn> penelope: So you are saying that you can't redefine (+) to make it more general?
19:18:52 <jmcarthur> well, we know that the list monad obeys the laws. if you can define the semantics of Source in terms of list and then show that your monad instance coresponds to the instance for list then i think that would suffice
19:19:01 <ghorn> penelope: i mean, that (+) :: a -> a -> a is the most general possible while still being useful?
19:20:00 <aristid> jmcarthur: well, they are like lists IF you ignore the resource allocation and reference creation and "take any base monad that has either IO or ST at the bottom" thing
19:20:38 <jmcarthur> aristid: can we model the resource allocation and reference creation somehow?
19:20:51 <ddarius> aristid: If you can show that every "primitive" operation can be modelled by a suitable monad (transformer) you will be set.
19:21:01 <rwbarton> it's not the list monad you want, it's the Writer [a] monad (or WriterT [a] Something)
19:21:15 <aristid> rwbarton: huh?
19:21:15 <ddarius> Alternatively, you could directly calculate from a proposed definition of (>>=) and return.
19:21:41 <rwbarton> isn't (>>) on Source supposed to be like concatenating lists?
19:21:44 <jmcarthur> rwbarton: that doesn't correspond to the implementation of return i think aristid intends
19:22:04 <rwbarton> maybe you're not doing what I think you are.
19:22:11 <hpaste> “Boyd Stephen Smith Jr.” pasted “Co-Induction?” at http://hpaste.org/55967
19:22:16 <jmcarthur> > [a,b,c] >> [c,d,e]
19:22:17 <lambdabot>   [c,d,e,c,d,e,c,d,e]
19:22:28 <jmcarthur> i think that is the intended behavior there
19:22:32 <aristid> yes
19:22:36 <rwbarton> hmm, okay...
19:22:45 <bss03> Did I name that method right? ^^ (hpaste)
19:23:57 <bss03> Also, I know it would be pretty easy to substitute "f" with somethink like "Identity" given this definition, but how easy would it be to go the other way around?
19:24:10 <jmcarthur> rwbarton: in a >>= b, for each value produced by a, create a new source and drain it before getting the next value from a
19:24:17 <bss03> I.e. will I be in a lot of pain if I drop the "f" decoration from the co-induct type?
19:24:25 <jmcarthur> *create a new source by applying b to the output of a
19:25:30 <ddarius> bss03: 1) "coinduct" is not a word.  2) coinduction is not "induction backwards."
19:26:34 <bss03> ddarius: So, is this "deduction" then?  I know I have the right (or nearly the right) type signature; is there a good name for it?
19:27:18 <cmccann> coinduction is actually noitcudnioc backwards
19:28:20 <ski> (bss03 : .. reminds me of bar induction)
19:29:00 <rwbarton> this looks like just ordinary induction
19:29:29 <Sgeo> If reactive-banana is getting dynamic event switching, will this have any implications as to whether Behavior is a monad?
19:29:57 <Sgeo> Because in the same post where the reactive-banana person talks about dynamic event switching, e mentions offhand that similar reasoning applies to join
19:30:05 <aristid> jmcarthur, ddarius: i wonder if sourcePull and sourceClose qualify as primitive operations, as they can't be operated directly on the value, but need initialization first (they operate on PreparedSource)
19:30:09 <bss03> rwbarton: For me, regular induction is if something is true for n0 and truth for n -> truth for n + 1, it is true for all naturals.
19:30:35 <rwbarton> yes, so let P(n) be "I have a function f n a -> f Zero a"
19:30:42 <bss03> rwbarton: This is, if truth for n+1 -> truth for n, then it is true for 0.
19:31:11 <aristid> bss03: seems like a complex way to prove something for 0:)
19:31:14 <rwbarton> I see what you are saying also
19:31:52 <ddarius> bss03: This is still a special case of induction.
19:31:52 <bss03> aristid: I'm converting a datatype that is existentially qualified across ranks to a recursive data type that must start at rank 0.
19:32:35 <Sgeo> bss03, you also need to prove truth for some positive n in order to prove it for 0
19:32:58 <bss03> ddarius: Kk.  I had the name as "induct" first, but when I wrote out the type signature I thought induct would have, it didn't get me anywhere.
19:32:59 <ddarius> Sgeo: That's the second argument.
19:33:09 <bss03> ddarius: Also, yes, it should be "induce" not "induct".
19:33:23 <ddarius> bss03: "Induct" is a word, but it has nothing to do with logic.
19:33:26 <aristid> bss03: induce_backwards?:)
19:33:38 <ddarius> Oh, I missed your second comment.
19:33:39 <bss03> induce_down, maybe.
19:33:50 <rwbarton> jmcarthur: I see how that could be useful.  I usually think primarily of things such as this Source as like Unix programs in a shell, where I can compose with ; and |.
19:34:50 <cmccann> induction is when your types generate an electric current while moving  through a magnetic field
19:35:07 <rwbarton> Then I think of "(f ; g)" as like f >> g, which corresponds to something like WriterT String IO.
19:35:22 <bss03> Sgeo: I just invoke the law of large numbers. :P
19:35:33 <aristid> rwbarton: that would be more Conduit than Source
19:35:59 <rwbarton> Conduit is when my programs read from their input, right?
19:36:03 <jmcarthur> yeah, a source is strictly a generator rather than a transformer, i guess
19:36:10 <aristid> rwbarton: yes
19:36:15 <rwbarton> Suppose my programs f and g don't read stdin.
19:36:26 <rwbarton> so they're the beginning of a pipeline (f ; g) | h | ...
19:36:35 <aristid> rwbarton: then your >> doesn't generalise to >>=, i think.
19:36:41 <jmcarthur> rwbarton: i would name ';' mplus
19:36:53 <rwbarton> it does, f can return a value
19:37:02 <jmcarthur> f `mplus` g
19:37:04 <rwbarton> mplus is weird because ; represents a sequence of IO effects
19:37:06 <aristid> rwbarton: but g doesn't read it.
19:37:07 <Sgeo> If conduits were monads, then would there be any need for Source to be a monad?
19:37:13 <rwbarton> not in that particular case
19:37:21 <aristid> rwbarton: and Source returns MULTIPLE values.
19:37:30 <rwbarton> (f ; g $?) | h
19:37:39 <jmcarthur> rwbarton: i don't think it sounds weird for mplus to represent a sequencing of effects
19:37:55 <rwbarton> surely you don't think it sounds weird for >> to represent a sequencing of effects, though
19:38:20 <aristid> rwbarton: IO and Source are fairly different things
19:39:16 <aristid> rwbarton: let's say you have f >>= g, and g :: X -> Source Y
19:39:24 <jmcarthur> rwbarton: i don't think that sounds weird at all, except that Source is kind of defined such that its last type parameter is the type of values produced, but your proposed semantics wouldn't obey that
19:39:34 <aristid> rwbarton: how would this behave? what if f returns multiple values?
19:39:36 <rwbarton> you'd have to add an extra parameter, yes
19:39:58 <rwbarton> really you have some kind of 2-dimensional structure
19:40:07 <ddarius> bss03: Just for completeness:  Let Q(n)(i) = P(n-i) || i > n, then forall N, n. (forall i. Q(N)(i) -> Q(N)(i+1)) && Q(N)(0) -> Q(N)(n) then instantiate the result of normal induction to N and you get Q(N)(N) = P(N-N) || N > N = P(0)
19:40:08 <rwbarton> I'm not sure what the best way to describe it is
19:42:12 <aristid> rwbarton: so you propose something that is essentially (Source m s, a)?
19:43:14 <rwbarton> I'm suggesting wherever your Source indicates that it's done producing output, you add a field of type 'a' there
19:43:40 <aristid> jmcarthur: turns out your "mplus" is actually in Source, although as Monoid, not MonadPlus
19:44:03 <aristid> rwbarton: why?
19:44:10 <cgroza> Is tail call elimination ALWAYS possible in haskell? I mean, is it possible to write code in haskell that is not tail recursive?
19:44:19 <c_wraith> of course.
19:44:26 <ddarius> What c_wraith said.
19:44:27 <c_wraith> foldr isn't tail recursive
19:44:46 <ghorn> ddarius: can you help me with that paste?
19:44:54 <c_wraith> heck, map isn't tail recursive
19:44:56 <rwbarton> but this is just intuition I get from trying to model Unix pipelines. and your list-like (>>=) also exists there (it's like xargs)
19:45:22 <ddarius> Something being in tail position is a simple syntactic property.  You can easily write functions that have recursive calls that are not in tail position.
19:45:23 <cgroza> thanks, I am reading an wikipedia article saying this is guaranteed by some standards. I wonder how is that possible.
19:45:44 <c_wraith> cgroza: they probably mean the standards guarantee that tail calls will be optimized to loops
19:46:06 <c_wraith> cgroza: which is something GHC does, with anything it can reasonably do so for
19:46:11 <ddarius> cgroza: The "optimization" of having tail calls become gotos only applies to tail calls.
19:46:29 <cgroza> c_wraith: your explanation makes more sense :D.
19:47:48 <ddarius> It's actually somewhat tricky to specify what tail call "optimization" is optimizing since the normal semantics of functions already "optimizes" tail calls.
19:48:24 <ddarius> Really, it's just that some language implementations have broken implementations of functions, not that others are "optimizing" them.
19:49:54 <roconnor> wha?
19:50:16 <ddarius> Incidentally, the Haskell standards say nothing about tail call optimizations so you technically can't rely on it.  Of course, it would make no sense to make a Haskell implementation that didn't optimize tail calls.
19:51:03 <rwbarton> aristid: another analogy is that a Source is a computation that can do some IO and produce some output. But imagine that I just want to print the output rather than sending it somewhere else in the program. Then I can just write that computation in the IO monad, using print.
19:51:34 <roconnor> I think you guys are grossly misleading cgroza
19:52:28 <aristid> rwbarton: if you want to print it, you send it to a conduit or sink :)
19:52:41 <aristid> rwbarton: there are chaining operators for that
19:52:58 <rwbarton> aristid: now since you don't actually want to print the output, you want a monad which supports some new operation like "yield". but it is still going to have (>>) as sequencing IO actions, and it is a monad so there needs to be a notion of monadic result which is different than what we output, etc.
19:53:28 <aristid> rwbarton: huh? Source basically _is_ the Monad that supports yield.
19:53:48 <rwbarton> huh?
19:53:58 <rwbarton> I can write do { print "a"; print "b" }
19:54:02 <rwbarton> which prints a and then b
19:54:10 <rwbarton> now I write do { yield "a"; yield "b" }
19:54:11 <rwbarton> what happens?
19:54:55 <aristid> rwbarton: you get a source that returns two values?
19:54:56 <ddarius> roconnor: How so?
19:55:12 <rwbarton> Well, that's what I'd expect, but that's not what your list-like (>>=) does.
19:55:44 <Sgeo> What happens if I use unsafeCoerce to try to smuggle an STRef into a different runST thread?
19:55:57 <irene-knapp> you probably crash
19:56:15 <irene-knapp> or at least badly confuse ST's plumbing
19:56:20 <jmcarthur> aristid: that's not what the proposed semantics would do
19:56:30 <roconnor> Tell me I'm wrong, but in "normal" languages calling a function pushes a stack frame from local variables, and the thing being optimized in a TCO is removing the stack frame before the tail call.
19:56:36 <aristid> yield doesn't exist in Source itself
19:56:45 <jmcarthur> yield a >> yield b  would just produce b (yield is just return, here)
19:56:50 <roconnor> so (1) a normal (operational) semantics of function calls is non-optimized
19:56:52 <aristid> you need another type for that, and make a Source from it.
19:56:56 <rwbarton> anyways I have only implemented this in a totally different setting (I wanted to manage []-"effects", not IO effects).
19:57:03 <ddarius> roconnor: No, that's an implementation, not a semantics.
19:57:23 <ddarius> roconnor: You could formalize a semantics that way, and then talk about optimizing tail calls, but you would be adding a stack just to optimize it out.
19:57:25 <roconnor> ddarius: TCO doesn't change the denotational semantics of functions.
19:57:30 <ddarius> roconnor: I agree.
19:57:40 <roconnor> so TCO is about operational semantics
19:57:41 <rwbarton> so I have no idea how well it would solve the problems that iteratees etc. are classically designed to solve
19:57:44 <ddarius> It doesn't change the semantics at all.
19:57:46 <ddarius> roconnor: False.
19:57:57 <roconnor> hmm okay
19:58:06 <ddarius> roconnor: I can model this stack pushing operationally -or- denotationally.
19:58:18 <aristid> rwbarton: i'm not talking about that anyways, the other combinators are supposed to take care of that.
19:58:19 <rwbarton> but it seems like the most natural interface to expose to the user of the library.
19:58:30 <aristid> i just noticed, when looking at Source, that it looks like a list
19:58:55 <jmcarthur> aristid: it actually looks a lot like orc, now that i think about it
19:59:05 <jmcarthur> (which has the list semantics)
19:59:07 <ddarius> roconnor: The most "obvious" semantics of functions (which is operational) is replacing formal arguments for actual arguments.  This is the way functions are usually taught initially in any language, and the only difference between call-by-name and call-by-value here would be restricting this rule to apply only when the actuals are values.  This is beta reduction.
19:59:31 <roconnor> [23:26] <ddarius> It's actually somewhat tricky to specify what tail call "optimization" is optimizing since the normal semantics of functions already "optimizes" tail calls.
19:59:34 * monochrom hates it when "semantics" is reserved for "denotational semantics".
19:59:35 <ddarius> roconnor: This archetypical semantics "optimizes" tail calls.
19:59:41 <MarcWeber> Can somebody help me understand this error message? http://dpaste.com/680122/
19:59:51 <MarcWeber> Could not deduce (b ~ Either String a0)
19:59:59 <ddarius> roconnor: Yes, the normal and -operational- semantics of functions is "textual" rewriting via beta reduction.
20:00:00 <MarcWeber> I've never seen this "~" in a error message before.
20:00:05 <ddarius> (or its first-order equivalent)
20:00:19 <roconnor> I see
20:00:25 <ddarius> roconnor: Typical -implementations- do indeed push stack and do a bunch of other things.
20:01:00 <ddarius> It can be the case that your semantics prohibits "tail call optimization" e.g. if you reify the stack as Smalltalk does.
20:01:00 <roconnor> ddarius: thanks for clairfying
20:01:05 <jmcarthur> monochrom: i admit to using "semantics" as a shorthand for "denotational semantics" very often. i suppose i might not be careful enough to be unambiguous sometimes.
20:01:30 <ddarius> roconnor: If you'd like, I can also provide you a denotational semantics that pushes stack and which can be "optimized."
20:01:54 <monochrom> sometimes GHC says "could not deduce b ~ Either String a0" for "could not match b with Either String a0"
20:02:01 <aristid> jmcarthur, rwbarton: so if we would change Source to take an additional type parameter, and rename the return that i wrote to yield, and write >> and return the way that rwbarton proposed, we would essentially get coroutines, right?
20:02:05 <bss03> MarcWeber: I think it (~) has something to do with associated types or fundeps.
20:02:07 <roconnor> I don't quite see how dentonational semantics have have the notation of memory use
20:02:16 <rwbarton> MarcWeber: it basically means "Could not unify expected type b with inferred type Either String a0"
20:02:36 <bss03> MarcWeber: Basically, GHC tried to prove that b and Either String a0 where the same type and couldn't.
20:02:40 <ddarius> roconnor: You just model the stack.  There's nothing special about it.  There's nothing that operational semantics can do that denotational semantics cannot or vice versa.
20:02:40 <rwbarton> oh I see monochrom already said this
20:03:01 <aristid> rwbarton: i guess both is possible, but i'm not sure which of the two is more useful
20:03:16 <roconnor> ddarius: what would you say the difference between operational and denotational semantics is?
20:03:29 <jmcarthur> aristid: i guess in the same sense that Writer gives you a coroutine
20:03:36 <MarcWeber> bss03, rwbarton Got it. Looks like contents of wiki are either outdated or sligtly wrong. Makes sense to return Left if coercion fails for whatever reason..
20:04:08 <aristid> jmcarthur: with writer you can't really schedule the observation times
20:04:11 <rwbarton> aristid: it sounds a lot like coroutines, yes. presumably you have something like a "scheduler" that makes sure that when I feed the output of f into g, the effects of f only occur as the output of f is consumed by g
20:04:26 <aristid> jmcarthur: whereas with Source, it pauses when you don't pull anything
20:04:32 <jmcarthur> aristid: you can unless it's actually transforming some other monad
20:04:51 <jmcarthur> WriterT w IO isn't so controllable, but WriterT w Identity is (just use normal laziness)
20:04:54 <aristid> rwbarton: well, no there is no actual scheduler.
20:05:06 <ddarius> roconnor: In denotational semantics, you are attempting to map your programming language's semantics to a mathematical object.  In operational semantics, you are typically providing a term rewriting system on the syntax.
20:05:09 <aristid> rwbarton: the only thing is that Sources only return data when you pull from them.
20:05:13 <rwbarton> well, the implementation of whatever that piping operation is
20:05:38 <aristid> the piping operation is not fundamental.
20:06:11 <aristid> the fundamental operation is sourcePull, and it reads exactly one element if possible
20:06:21 <ddarius> However, syntax is a mathematical object and term rewriting can be modelled denotationally, and likewise I can use "big-step" operational semantics to get essentially denotational semantics, or model the formal (meta)rules being used in the denotational semantics operationally.
20:06:23 <roconnor> ddarius: since terms are a mathematical object, does that make operation semantics a special case of dentoational semantics?
20:06:30 <rwbarton> and it performs whatever effects are necessary to get that element, right
20:06:37 <rwbarton> everything up to the first yield, so to speak
20:06:52 <ddarius> roconnor: Yes, in an unsatisfying technical sense.
20:06:58 <aristid> rwbarton: that's the idea
20:07:09 <ddarius> You certainly don't need to go that far, though, to model something like memory or stack usage.
20:07:20 <ddarius> Simply include the heap/stack in your model.
20:09:52 <ddarius> Perhaps more generically, denotational semantics tends to be functional and operational semantics relationaly.
20:09:54 <ddarius> -y
20:10:24 <ddarius> This is clearest in the handling of non-determinism by each.
20:14:16 <monochrom> in practice, denotational tries very hard to have the domain and co-domain disjoint (maps programs to a CPO for example, and emphasizes that the CPO is not the programs), and operational tries very hard to have the co-domain a subset of the domain. the point is not what "I could do", the point is what the communities actually do
20:15:18 <ddarius> monochrom: Agreed.
20:24:01 <MarcWeber> acid-state: Does checkpointing remove the log files?
20:27:16 <roconnor> MarcWeber: I'd like to know too.
20:28:22 <MarcWeber> In my test it does not.
20:28:39 <roconnor> that would be my expectation
20:29:14 <MarcWeber> roconnor: When a checkpoint is made the events could be deleted though. At least the state was still there after doing so manually.
20:29:22 <roconnor> yep
20:29:32 <roconnor> which is why I want to know the answer :)
20:34:55 <nwf> Greetings #haskell.  Is there a way to declare (formally; i.e. not just to users in the comments) that a given entity is _not_ to be exported from a module?  Like a "module Foo ( ... ) hiding ( ... ) where ..." declaration?
20:35:29 <mike-burns> Private functions, basically?
20:35:40 <Veinor> nwf: Just don't put it in the first ( ... ). Or is there something i'm missing?
20:36:00 <mike-burns> nwf: The way I do that is I make a separate module for those, import that module where I need it, and never expose the module via the cabal conf.
20:36:02 <nwf> I realize that that works, but I want something for the case where correctness depends on something not being exported.
20:36:32 <roconnor> nwf: the only way you can not export something is to explictly export everything else.
20:36:40 <nwf> (The typical trick of "smart" constructors, e.g.)
20:36:57 <roconnor> nwf: but this is common
20:37:31 <nwf> Right, but it means that any analysis tool looking at the list of exports can't distinguish "private but safe to export" and "unsafe to export".
20:37:42 <Veinor> I think the standard trick is to have a Foo.Internal module that contains everything you need to import but should never export.
20:37:50 <Veinor> Then in Foo, import Foo.Internal.
20:38:02 <mike-burns> Yeah!
20:38:06 <nwf> And omit Foo.Internal from the .cabal exported section?  Blah.
20:38:15 <Veinor> Like mike-burns said, yeah.
20:38:18 <nwf> That continues to be a "safety by omission"
20:38:35 <Veinor> At the point at which your users are messing with your .cabal file, I think you kind of have to give up.
20:38:48 <mike-burns> It's to protect himself.
20:38:51 <nwf> Well, perhaps a Hiding: declaration in the cabal file would be better.
20:39:03 <nwf> But I feel like it should be explicit somewhere.
20:39:27 <mike-burns> nwf: Can we get more concrete: what are you trying to make private? A data def?
20:40:52 <nwf> Let's take as an example the H constructor from Tagless-Staged.
20:41:11 <mike-burns> I love how no one in this channel uses examples from the app they're working on.
20:41:27 <mike-burns> OK so it's a constructor.
20:41:42 <Sgeo> An automatic converter between Event and Source would be nice, I think
20:41:47 <Sgeo> Not sure how doable it is
20:42:12 <mike-burns> I think the best you can do is what I suggested; there is no way to mark functions or data as private, or all the other fancy things you do in Scala.
20:42:47 <nwf> mike-burns: I do not have a specific application in mind; I am (re)reading the Tagless-Staged paper and the "is not exported ... and not available to the programmer" assertion triggered a mental warning about implicitness this time.
20:44:22 <monochrom> haha, someone uses my http://www.vex.net/~trebla/haskell/sicp.xhtml to say "life without cabal-install is safer": http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg20888.html
20:44:55 <nwf> Concretely, I suppose I am then going to suggest that the grammar of Haskell be extended to allow a "hiding" branch in module declarations, and/or that Cabal's syntax grow a similar explicit-module-hiding directive for this purpose.
20:46:11 <nwf> (It'd just be a syntactic extension, for now; I suppose I'd like ghc or cabal to complain if something is mentioned in both places and for there to be a "module Foo hiding ... where ..." variant, but otherwise...)
20:46:29 <mike-burns> I can see the reasoning. You'll want to open a ticket on ghc, I suppose, and try to convince them. A patch will help, but I'm not sure if too many people think it's an actual problem.
20:46:39 <monochrom> in a package, you can mark modules as unexposed. it means other people can't import them.
20:46:50 <nwf> monochrom: Oh!  How do I do this?
20:47:25 <monochrom> I'll have to look at the manual for that
20:47:41 <mike-burns> Other-modules
20:48:50 <monochrom> you list the modules you want exposed with the compulsory "exposed-modules: ..." line. so just omit modules you want unexposed. this is for the myproject.cabal file
20:49:31 <monochrom> oh, the unexposed modules must appear in the "other-modules: ..." line.
20:49:43 <monochrom> "Every module in the package must be listed in one of other-modules, exposed-modules or main-is fields." darn that
20:50:06 <mike-burns> http://www.haskell.org/pipermail/haskell-cafe/2010-April/076338.html - here's a thread complaining about it.
20:50:07 <nwf> Ah ha.  So the Foo.Internal module should be other-module:; excellent, thank you.
20:50:30 <jmcarthur> it's pretty common to just expose the Internal module(s) too
20:50:44 <mike-burns> A clear sign of a problem.
20:50:52 <jmcarthur> with the convention that the non-Internal modules should be generally safe, but the Internal ones might not be
20:51:06 <mike-burns> I try to make my internal modules into separate packages or patches.
20:51:25 <jmcarthur> the reason people export them is so that people who think they know what they're doing can dig into the internals if they want
20:51:54 <nwf> Well, in many cases the safety proofs go out the window if (data) constructors are exported.
20:51:56 <jmcarthur> i'm not a huge fan of the practice in principle, but i've been in the position of using Internals modules, too
20:52:15 <jmcarthur> e.g. ByteString's internals
20:52:20 <jmcarthur> or the GHC.* modules
20:52:37 <mike-burns> Oh sure, I've used it, but it's a clear sign that some part of the API went wrong when I use the Internal stuff from my own code.
20:53:00 <jmcarthur> i agree that it's kind of an admission of failure to export Internal modules
20:53:38 <jmcarthur> failure to expose the most flexible abstraction in a safe way, that is
20:53:47 <mike-burns> Right.
20:54:08 <monochrom> I have a cunning plan. write an internal module you don't expose. make a copy of that module you expose, but change every type "X -> Y" to "X -> IO Y".
20:54:52 <jmcarthur> then again, i've gotten feature requests on some of my packages from people who would have been able to work around the lack of the features if i had given them access to the internals. this was always due to oversight on my part, but the fact remains that the problem would have been less severe if there had been a workaround
20:55:11 <rwbarton> having hackage build haddock for the internal modules is also convenient, which it won't if they're not exposed
20:55:20 <mike-burns> type DoNotUseThis = IO
20:55:20 <rwbarton> convenient just to understand how the package works
20:55:43 <nwf> In thinking about it, I still would prefer that module allow "hiding (...)"; having to break TSCore.hs into pieces just to make the package safer would be a bit of a drag.
20:55:45 <rwbarton> or to debug it, when it doesn't work
20:55:51 <nwf> Though I suppose in the limit it will get a .cabal file anyway.
20:55:53 <mike-burns> Can we get haddock to build for the unexposed modules? Is there a flag for this that Hackage can enable?
20:56:11 <rwbarton> that would be great, I don't see any problem with it in theory, yeah
20:56:26 <nwf> Cabal claims to build haddock for unexposed modules with --internals (also --executables might be nice)
20:56:42 <mike-burns> Exposing internal packages just because we don't have a flag set seems like a mistake.
20:56:46 <nwf> Er, --internal.
20:57:06 <QAR> hello
20:57:09 <monochrom> "cabal haddock --internal"
20:57:10 <nwf> EHLO
20:57:27 <QAR> is Haskell similar to Standard ML
20:57:33 <monochrom> haddock itself couldn't care less
20:57:42 <mike-burns> QAR: They are both programming languages, yes.
20:57:51 <monochrom> yes, they are similar.
20:57:56 <nwf> QAR: Superficially, yes.  They're even both functional languages. ;)
20:58:02 <monochrom> just swap "::" and ":"
20:58:07 <mike-burns> Is there a specific question, QAR ?
20:58:12 <rwbarton> with type systems that have a common foundation
20:58:29 <nwf> And be prepared to sequence events manually, rather than top-down-left-to-right.
20:58:42 <QAR> i am a java programmer so will i find it difficult to learn a new programming paradigm
20:58:58 <nwf> I have yet to understand Harper's insistence that monadic sequencing is evil. :(
20:58:58 <mike-burns> That's the best description of a Java programmer I've ever heard.
20:59:15 <jmcarthur> QAR: there is no such thing as a "programming paradigm"
20:59:15 <monochrom> the SPJ & JH interview covers "::" vs ":". http://channel9.msdn.com/Blogs/Charles/YOW-2011-Simon-Peyton-Jones-and-John-Hughes-Its-Raining-Haskell
20:59:16 <nwf> QAR: If you are familiar with SML already, then no.
20:59:43 <QAR> thanks
21:00:09 <irene-knapp> mike-burns: haha :D
21:00:18 <monochrom> haha mike-burns evil
21:00:25 <nwf> QAR: You might find http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell useful.
21:00:25 <jmcarthur> programming paradigms are nothing more than artificial constraints designed to keep you from exploring the larger design space of programs
21:00:51 <mike-burns> The major difference between programming paradigms are conditionals.
21:01:42 <monochrom> that's like saying a world map is artificially drawn to keep you from exploring the world
21:01:42 <nwf> One Of These Days (TM) I will be smart enough and have enough time to make an Mozart/Oz-like VM for Haskell.  I am sure somebody will beat me to it.
21:02:17 <irene-knapp> me.
21:02:22 <QAR> is the syntax any different from SML
21:02:23 <irene-knapp> what are Mozart and Oz in this context?
21:02:35 <irene-knapp> no; they both use letters, numbers, and punctuation
21:03:00 <monochrom> SML doesn't allow all of unicode
21:03:07 <irene-knapp> oh, really?  interesting :)
21:03:08 <nwf> irene-knapp: http://www.mozart-oz.org/
21:03:14 <irene-knapp> ah!  looking
21:03:22 <nwf> (Tragically, sort of dead.)
21:03:29 <irene-knapp> hmm
21:03:36 <irene-knapp> I dunno, distributed computing is not really my thing
21:03:43 <nwf> Also closely related: http://www.ps.uni-saarland.de/alice/
21:03:46 <rwbarton> certainly the syntax is not identical to SML's, but in general they are somewhat similar
21:03:48 <mike-burns> Sort of dead? Sounds like it definitely needs to be ported to Haskell!
21:03:51 <irene-knapp> yeah, familiar with Alice
21:04:06 <monochrom> I think Mozart/Oz is more than distributed computing
21:04:10 <irene-knapp> yeah, hmm
21:04:25 <jmcarthur> monochrom: i'm not sure i see how a programming paradigm is like a map of the program design space, if that's what you are getting at
21:04:31 <nwf> Peter's book based on Mozart is really a treasure.
21:04:33 <ziedaniel1> @pl \y f -> f (y f)
21:04:33 <lambdabot> ap id
21:05:22 <nwf> (http://www.info.ucl.ac.be/~pvr/book.html)
21:06:18 <companion_cube> wow, this mozart/oz thing looks great
21:06:25 <companion_cube> is it used?
21:06:42 <monochrom> a world map has boundaries like "here is sea, there is land". the presence of those marks does not stop you from entering sea or entering land.
21:07:12 <monochrom> knowing programming paradigm boundaries does not stop you from exploring outside those boundaries.
21:08:09 <irene-knapp> you are now required to design a paradigm called "Dragons"
21:08:26 <monochrom> http://www.vex.net/~trebla/tmp/dragon.jpg
21:08:48 <nwf> companion_cube: Back in the day it had a following; I think it has suffered from "primary developer got PhD and left" but I haven't looked in detail in a few years.
21:08:49 <Veinor> dragons are when one developer insists they have to review all the changes
21:08:50 <irene-knapp> haha!
21:08:59 <Veinor> 'hoarding' them
21:09:29 <companion_cube> nwf: I see...
21:10:14 <nwf> Yeah, 1.4.0 is from 2008/07/02. :(
21:13:31 <jeff_s_> I just realized that it's strange that type constructors are functions, since functions otherwise have to start with a lowercase letter.
21:14:01 <PatrickRobotham> jeff_s_: Type constructors aren't functions.
21:14:13 <PatrickRobotham> jeff_s_: You may be thinking of value constructors
21:14:31 <PatrickRobotham> data List a = Empty | Cons a (List a)
21:14:45 <PatrickRobotham> List is the type constructor
21:14:46 <jeff_s_> Ya, the "Empty" and "Cons" part of that.
21:15:07 <companion_cube> they are more values than functions, aren't they?
21:15:11 <companion_cube> Empty is just a value
21:15:34 <PatrickRobotham> a value is a function that takes zero arguments companion_cube ;)
21:15:41 <mike-burns> Beyond being functions, you can also pattern match using them. So they're a little special, jeff_s_ .
21:15:49 <mike-burns> Hah.
21:16:29 <monochrom> Empty is not a function
21:16:57 <monochrom> but I'm fine with "Cons is a function"
21:16:57 <jeff_s_> Uh oh. I feel like I've done something wrong!
21:17:27 <companion_cube> PatrickRobotham: then what's thedifference between the function and a call to the function? :)
21:17:59 <azaq23> PatrickRobotham: Functions are values, values are not functions in haskell.
21:18:19 <jeff_s_> :t map Nothing
21:18:20 <lambdabot>     Couldn't match expected type `a -> b'
21:18:20 <lambdabot>            against inferred type `Maybe a1'
21:18:20 <lambdabot>     In the first argument of `map', namely `Nothing'
21:18:25 <jeff_s_> :t map Just
21:18:26 <lambdabot> forall a. [a] -> [Maybe a]
21:18:51 <PatrickRobotham> jeff_s_: Technically, List is the type constructor, because it takes a type and returns a type.
21:19:01 <PatrickRobotham> jeff_s_: Cons is a data constructor
21:19:18 <jeff_s_> Ah, I see.
21:19:22 <Veinor> yeah, 'Cons is a function' is an ok thing to say
21:19:25 <Veinor> in my opinion
21:19:37 <ddarius> Considering it is true, it should be.
21:19:42 <ski> irene-knapp : Oz is the language used by CTM and Mozart is its implementation. also Alice ML is related (but statically typed)
21:19:47 <ski> @where CTM
21:19:47 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
21:20:11 <ddarius> Alice ML essentially uses the SEAM VM underneath Oz.
21:20:43 <nwf> ddarius: I don't think that's true; they used to use the Oz VM up until they switched over to SEAM.  When they did that, they lost interop with Oz.
21:20:53 <ddarius> I would say Mozart is the entire environment around Oz, not (just) the implementation.
21:20:54 <nwf> Er, sorry, used to use the _Mozart_ VM.
21:21:31 <irene-knapp> okay, hmm
21:21:50 <ski> (you should take a look at CTM, if you haven't yet)
21:21:56 * irene-knapp nods
21:22:23 <nwf> Is there a CTM-alike using Haskell?
21:22:40 <mercury^> When reading CTM I found that they did monads no justice.
21:23:26 <ddarius> mercury^: Why would they?
21:23:56 <mercury^> Why they would do monads no justice? I don't know!
21:26:17 <monochrom> because they don't want to go bind
21:26:29 <ddarius> CTM is like a modern SICP for which monads are not that important (though you could have an SICP for which monads played a more important role.)  Furthermore, Peter van Roy doesn't like monads due to the very real expressiveness problems they have.
21:27:01 <mercury^> Can you elaborate on the expressiveness problems?
21:27:40 <ddarius> It's really pure languages that have the expressiveness problem and monads are just a symptom of it.
21:28:01 <nwf> Managing stacks of monad transformers stinks.
21:28:18 <ddarius> nwf: You're doing it wrong then.
21:28:32 <mercury^> To get state you just need a single layer of state anyway.
21:28:36 <ddarius> But, at any rate, the issue is if I have some pile of "pure" code and I want to add a counter to some function to see how often it is called, this is a global transformation.
21:28:59 <mike-burns> Oh, yes. That stinks.
21:29:04 <ddarius> Whereas in a more expressive language, one with mutable state in this case, it would be a local transformation.
21:29:22 <ddarius> Monads are just a particularly structured way of making this global transformation.
21:29:26 <nwf> Well, it can be a local transformation with unsafePerformIO and MVars. =P
21:29:34 <mercury^> Well, the real issue is that you will eventually read out the counter.
21:29:39 <mercury^> And print it or something.
21:30:02 <mercury^> That is a non-local transformation even if you have mutable state.
21:30:08 <ddarius> mercury^: No it isn't.
21:30:20 <nwf> Well, it introduces the need for a top-level MVar.
21:30:28 <nwf> And that gets us into Affine Central IO.
21:30:34 <mercury^> So if you add a print instruction to the function itself, I think it clearly deserves a different type.
21:30:39 <ddarius> nwf: Not quite.
21:31:11 <ddarius> mercury^: You don't need to add a print instruction to the function itself, but if you did, again that would lead to a global transformation that a more expressive language would not require.
21:32:27 <ddarius> Haskell trades expressiveness for "safety."
21:32:34 <ddarius> And composability.
21:32:44 <ddarius> Well, some forms of composability.
21:37:17 <mm_freak> what's the infix priority of (->)?
21:37:30 <mm_freak> GHCi won't tell me
21:37:44 <Sgeo> @hoogle (MonadTrans t, Monad m) => t Identity a -> t m a
21:37:44 <lambdabot> Did you mean: (MonadTrans t, Monad m) => t (Identity t) a -> t m a
21:37:45 <lambdabot> Data.Graph.Inductive.Basic grev :: DynGraph gr => gr a b -> gr a b
21:37:45 <lambdabot> Data.Map deleteMax :: Map k a -> Map k a
21:38:03 <Sgeo> @hoogle (MonadTrans t, Monad m) => t (Identity t) a -> t m a
21:38:03 <lambdabot> No results found
21:38:11 <Sgeo> Why would you ask me if that's what I meant
21:38:17 <Sgeo> And I don't think it really is
21:38:18 <ziedaniel1> It's a type, not a function
21:38:31 <Sgeo> @hoogle :: (MonadTrans t, Monad m) => t (Identity t) a -> t m a
21:38:31 <lambdabot> No results found
21:38:41 <Sgeo> @hoogle :: (MonadTrans t, Monad m) => t Identity a -> t m a
21:38:42 <monochrom> you try to ask a computer why? :)
21:38:42 <lambdabot> Did you mean: (MonadTrans t, Monad m) => t (Identity t) a -> t m a
21:38:42 <lambdabot> Data.Graph.Inductive.Basic grev :: DynGraph gr => gr a b -> gr a b
21:38:42 <lambdabot> Data.Map deleteMax :: Map k a -> Map k a
21:39:09 <Sgeo> Argh, thought ziedaniel1 was talking to me
21:39:15 <nwf> monochrom: SHRDLU could answer "Why?" in the 1970s, and it's a failing of modern software engineering that more programs can't.
21:39:24 <jmcarthur> monochrom: i think what i was trying to get was more that the idea of a programming paradigm is fundamentally an attempt to limit your vocabulary, which has the effect of limiting the ways you can think about your problem
21:42:03 <jmcarthur> "i can only think about actors" or "i can only think about relations" or "i can only think about actions", and so on
21:42:06 <Philippa> jmcarthur: Hmm. I don't entirely agree with that, but even the CTM notion of paradigm has unpleasant consequences when it's applied to Haskell carelessly
21:42:33 <ddarius> Imposing artificial restrictions is often a rather good thing in software engineering (and many other areas.)
21:43:07 <jmcarthur> ddarius: i agree, but the challenge is to know when to impose what restrictions
21:43:22 <jmcarthur> as opposed to limiting yourself to "everything must be an object, always"
21:44:02 <Philippa> eh, even that I'd buy if only it came coupled with a sensible means of sealing off reflection where appropriate
21:44:55 <ddarius> Philippa: See Mirrors.
21:46:15 <Philippa> well, that and doesn't cost me static typing, but yeah
21:46:19 <monochrom> a paradigm that says "alcohol is allowed for only age of 20 or above" encourages people to explore alcohol below age of 20
21:46:30 <Philippa> ddarius: *nod*. They were certainly somewhere in my to-read pile at one point, but I've lost a couple of said piles
21:47:08 <monochrom> a map that marks "here is USA" and missing everything outside USA encourages people to loiter outside
21:47:30 <monochrom> you would be right to make me s/people/some people/g in the above.
21:48:41 * ddarius doesn't understand monochrom's penultimate statement.
21:48:45 <monochrom> my thought is that without those making explicit those restrictions and boundaries, even fewer people would think of exploring. also, "you have to know the rules before you break them". rules are guidances for breaking rules.
21:49:19 <ddarius> I strongly agree with you last sentence.
21:49:20 <Sgeo> Why is ImplicitParams so hated?
21:49:43 <ddarius> But I don't quite understand what you meant by or why you chose the wording "loiter outside."
21:50:27 <Sgeo> Also, ooh mirrors, did Newspeak get a good Mirror API yet?
21:51:16 <Philippa> ddarius: did you ever hack up a reflective monadic language in the end, btw?
21:51:29 <ddarius> I don't recall intending to do that.
21:51:57 <Philippa> it may've been a few years back, plus I may've emphasised the wrong features
21:52:09 <Philippa> (reflective was a big part, monadic a means to an end)
21:52:38 <ddarius> Ah, I think I know what you mean, though if it is what I think it is that was before mirrors and like eight years back.
21:53:11 <Philippa> clearly we've known each other for too long
21:53:29 <ski> mm_freak : <http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons> "* Function arrow is infixr with fixity 0. (This might change; I'm not sure what it should be.)"
21:58:43 <ddarius> The Report doesn't allow infix type constructors, and there are no other infix type constructors, so it wasn't a problem for the Report.
22:01:36 <ddarius> I wonder if GHC will apply value level fixity declarations to type level operators.
22:01:58 <ddarius> (And possibly kind level now.)
22:05:40 <shachaf> ddarius: Aren't fixity declarations associated with a particular scope?
22:05:52 <ddarius> Yes.
22:06:15 <shachaf> And presumably type-level operators are scoped somewhere (maybe implicitly).
22:07:08 <Sgeo> Where are good mirror infos?
22:07:18 <shachaf> (Assuming that you mean "lower-case" operators, anyway.)
22:07:36 <ddarius> shachaf: "Case" doesn't matter.
22:07:54 <shachaf> Oh, this statement was made with context.
22:08:03 <rwbarton> oh, I never thought about that--can I declare the fixity of the infix operator parameters to my function?
22:08:11 <mm_freak> ski: thanks
22:08:16 <ddarius> infixr 1 :+ is perfectly legitimate.
22:08:50 <shachaf> ddarius: Right, but in that case a new scope isn't introduced.
22:09:09 <shachaf> (When the operator is used, I mean.)
22:09:15 <ddarius> > let f (+) = a+b+c in f (+)
22:09:16 <lambdabot>   a + b + c
22:09:42 <ddarius> > let infixr 1 +; f (+) = a + b + c in f (+)
22:09:43 <lambdabot>   The fixity declaration for `+' lacks an accompanying binding
22:09:43 <lambdabot>    (You cannot...
22:09:59 <ddarius> > let f (+) = let infixr 1 + in a + b + c in f (+)
22:09:59 <lambdabot>   The fixity declaration for `+' lacks an accompanying binding
22:10:00 <lambdabot>    (The fixity...
22:10:07 <rwbarton> > let f (+) = a + b + c where infixr 1 + in f (+)
22:10:08 <lambdabot>   The fixity declaration for `+' lacks an accompanying binding
22:10:08 <lambdabot>    (The fixity...
22:10:17 <rwbarton> Guess not
22:10:23 <ddarius> rwbarton: I think the answer is you'd have to rebind the parameter locally.
22:10:34 <rwbarton> Yes, that would work
22:10:43 <ddarius> > let f g = let (+) = g; infixr 1 + in a + b + c in f (+)
22:10:44 <lambdabot>   a + (b + c)
22:11:26 <ddarius> You might be able to do some unbelievable evilness with view patterns but probably not.
22:13:43 <rwbarton> > fromJust $ do { (+) <- return (+); infixr 1 +; return $ a + b + c }
22:13:45 <lambdabot>   <no location info>: parse error on input `infixr'
22:14:15 * ddarius has to brace himself for the unbelievably atrocious chicken breast "art" on Gilad's Newspeak page every time.
22:16:58 <shachaf> ddarius: I don't get it.
22:17:03 * shachaf hasn't seen this page before.
22:18:28 <Sgeo> At first, I understood why this would get confused: http://ideone.com/LBzGI
22:18:40 <Sgeo> But IO () doesn't have a Show instance, while String does
22:19:42 <ddarius> shachaf: Brace yourself: http://bracha.org/Site/Newspeak.html
22:19:57 <shachaf> ddarius: Yes, I already found it.
22:20:04 <shachaf> I don't get it, though.
22:20:10 <ddarius> What do you not get?
22:20:16 <shachaf> Sgeo: Add a type sinature for main.
22:20:19 <shachaf> ddarius: The picture.
22:20:29 <ddarius> shachaf: It's "art" by his sister.
22:21:00 <Sgeo> shachaf, that did not help it realize that there is only one intersection between PrintfType r and Show r
22:21:09 <Sgeo> http://ideone.com/4J9U2
22:21:14 <ddarius> Sgeo: That's not how type classes work.
22:21:18 <shachaf> Wait, that doesn't help.
22:21:22 <ddarius> You need to tell print what type it should show?
22:21:30 <ddarius> sprint could be IO () or String or something else.
22:21:47 <Sgeo> ddarius, the compiler's not smart enough to take the intersection of type classes?
22:21:56 <shachaf> The ambiguity is with "sprint", never mind.
22:21:57 <ddarius> Sgeo: It's not a matter of "smartness."
22:21:59 <rwbarton> it's not wrong enough to do that
22:22:14 <ddarius> Sgeo: And at any rate, the "intersection" isn't {String} anyway.
22:22:20 <Sgeo> ddarius,
22:22:21 <Sgeo> oh
22:22:31 <shachaf> @remember rwbarton <Sgeo> the compiler's not smart enough to take the intersection of type classes? <rwbarton> it's not wrong enough to do that
22:22:32 <lambdabot> I will remember.
22:22:48 <rwbarton> a useful property to remember about the type class system is that adding new instances can never make your program stop compiling
22:24:01 <shachaf> Well, adding new instances can never make a particular expression that was valid invalid. If the new instances are valid.
22:24:44 <rwbarton> okay, right, assuming the instance itself is fine
22:24:55 <rwbarton> In particular, someone in one of the modules you import might define a new instance for some class
22:25:05 <rwbarton> this shouldn't be allowed to break your program
22:25:35 <ddarius> That is allowed to break your program.
22:25:47 <rwbarton> with OverlappingInstances? or am I forgetting something else
22:25:57 <ddarius> If I already have such an instance defined.
22:26:01 <rwbarton> it could collide, yeah
22:26:10 <ddarius> But your original statement was good.
22:26:44 <ddarius> I'm pretty sure with at least IncoherentInstances and maybe with only OverlappingInstances you can produce cases that will cause problems, but then IncoherentInstances is evil
22:27:30 <rwbarton> (I still have a hunch that you can write unsafeCoerce with IncoherentInstances and type families, though I've never tried)
22:28:16 <rwbarton> Anyways, this property of the type class system rules out a lot of things that people sometimes expect it to do.
22:29:29 <rwbarton> Like select instances with backtracking based on whether the contexts of those instances are satisfied
22:31:13 <Sgeo> Why is ImplicitParams considered evil?
22:33:20 <ddarius> Sgeo: Use it for a while.  You'll find out.
22:33:28 <Sgeo> lol
22:35:40 * Sgeo is trying to get an intuition about the reflection package
22:35:55 <Sgeo> It's like some sort of morally-acceptable ImplicitParams?
22:37:23 <rwbarton> think of it as being able to create a variable type class dictionary at runtime
22:38:43 * Sgeo is less interested in how it works and more interested in how to use it >.>
22:39:09 <rwbarton> with ImplicitParams can you put an implicit parameter on an instance declaration?
22:39:20 <rwbarton> Sgeo, I mean that is what you can do with it
22:40:10 <dropdrive> @pl \x y -> f (g h $ x) y
22:40:10 <lambdabot> f . g h
22:40:19 <rwbarton> (like data M = M Integer; instance (?p :: Integer) => Mod M where M x + M y = M $ (x + y) `mod` p; --etc.)
22:40:46 <rwbarton> um, s/Mod/Num/
22:40:52 <Sgeo> I have this vague notion, I think I read in the paper, that it puts values into the type?
22:43:20 <mister_awesome> >>...
22:44:25 <mister_awesome> hello?
22:44:47 <rwbarton> I guess that would require a matching implicit parameter on the class
22:44:49 <shachaf> mister_awesome: There is only silence and some second-hand clothes.
22:44:52 <rwbarton> if it worked at all
22:45:09 <mister_awesome> shachaf: ah
22:46:40 <Sgeo> Would it make sense to use Data.Reflection instead of the Reader monad?
22:47:07 <mister_awesome> well, i'm just here to see if i can learn anything
22:47:12 <mister_awesome> haskell related
22:47:14 <shachaf> Sgeo: "the Reader monad" is just (r ->).
22:47:40 <Sgeo> shachaf, which is commonly used for application-wide readable state, I think?
22:48:52 <shachaf> It's used for scoped "readable state". It's exactly like adding an extra argument.
22:50:09 <Sgeo> But then I think the point of the paper behind Data.Reflection is that with Reader, you have to make all functions that even call functions that need the state monad (same as adding an extra argument to all those functions)
22:51:54 <Sgeo> "The fourth approach to the configurations problem is to use a
22:51:54 <Sgeo> reader monad [3]. Its drawback is that any code that uses configu-
22:51:54 <Sgeo> ration data (even only indirectly, by calling other functions that do)
22:51:54 <Sgeo> must be sequenced into monadic style—even if it does not other-
22:51:54 <Sgeo> wise have to be.
22:51:55 <Sgeo> "
22:52:56 <shachaf> Sgeo: That's like saying "the drawback of passing your configuration as an argument is that you need to pass it as an argument to any function that uses it".
22:53:27 <Sgeo> I think the paper has something to say about that too
23:32:23 <Sgeo> @hoogle replace
23:32:23 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Replace :: TextureFunction
23:32:23 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
23:32:23 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
23:34:35 <Sgeo> :t splitOn
23:34:36 <lambdabot> Not in scope: `splitOn'
23:40:26 <dmwit> :t (break, span, splitAt)
23:40:27 <lambdabot> forall a a1 a2. ((a -> Bool) -> [a] -> ([a], [a]), (a1 -> Bool) -> [a1] -> ([a1], [a1]), Int -> [a2] -> ([a2], [a2]))
23:49:55 <jdavis> What does the symbol "⊥" mean in the context of haskell?
23:50:31 <shachaf> "haskell" is pretty broad as contexts go.
23:50:41 <jdavis> http://www.haskell.org/haskellwiki/Stack_overflow
23:50:47 <jdavis> OK, how about as used in that page?
23:50:47 <opqdonut> it's called "bottom", and it means an undefined/nondeterminating computation
23:50:56 <jdavis> Oh, thanks.
23:50:58 <shachaf> Oh, wait.
23:51:02 <shachaf> My Unicode support is broken.
23:51:06 <shachaf> I saw that as "?".
23:51:07 <opqdonut> see e.g. http://www.haskell.org/haskellwiki/Bottom
23:51:18 <companion_cube> I will not buy this unicode, it is scratched.
23:51:18 <opqdonut> I guess this channel usually types it as _|_
23:51:21 <jdavis> shachaf: I can see how that would be confusing
23:51:25 <rwbarton> heh, that seemed like a really odd answer :)
23:51:52 <opqdonut> ok, the wiki page for bottom is quite poor
23:53:51 <dropdrive> @pl \a b c d -> (f g) . (h a b c d)
23:53:51 <lambdabot> ((((f g .) .) .) .) . h
23:54:43 <alistra> @pl \a b -> off b a
23:54:43 <lambdabot> flip off
23:55:32 <dropdrive> @pl \a b c d -> (f g) (h a b c d)
23:55:32 <lambdabot> (((f g .) .) .) . h
23:55:35 <Twey> (fmap . fmap . fmap . fmap . fmap $ f g) h
