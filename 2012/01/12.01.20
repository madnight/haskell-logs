00:19:58 <bartavelle> hi, how can i do assignments in a if then else expression in a do block ? ie. http://hpaste.org/56717
00:20:05 <bartavelle> this fails with a parse error
00:21:12 <tikhonjelvis> An if is just an expression.
00:21:31 <tikhonjelvis> So you can do filecontent <- if ... then getContents else readFile filename
00:21:56 <bartavelle> ah !
00:22:49 <tikhonjelvis> This is also true of case and let...in expressions.
00:23:26 <bartavelle> this explains things
00:23:28 <bartavelle> thanks !
00:23:39 <tikhonjelvis> No problem. Have fun with whatever you're working on.
00:24:09 * DanBurton thinks that "if" should be a function, and we should get rid of "then" and "else"
00:24:14 <tikhonjelvis> yeah
00:24:30 <Sathiyanathan> Hai
00:24:48 <Sathiyanathan> Any budy there
00:24:49 <tikhonjelvis> bartavelle: You can pattern-match the list. Something like: [filename, fieldname, fieldvalue] <- args
00:24:59 <bartavelle> ah
00:25:01 <bartavelle> much better
00:25:23 <tikhonjelvis> Why isn't if a function? Is it just historical?
00:26:32 <ChristianS> case is not a function, and if is syntactic sugar for case
00:27:14 <tikhonjelvis> In that case, why is if syntactic sugar rather than a function?
00:28:18 <DarkUnicorn> seems to be already discussed http://www.haskell.org/haskellwiki/If-then-else#Replace_syntactic_sugar_by_a_function
00:28:57 <bartavelle> can i do an assignment just after a do ?
00:29:03 <kmc> it doesn't say why the original "if then else" syntax was included, though
00:29:07 <tikhonjelvis> heh
00:29:13 <tikhonjelvis> kmc: I was just typing that...
00:29:13 <bartavelle> i find the do block syntax really confusing
00:29:14 <Axman6> bartavelle: assignment?
00:29:18 <bartavelle> like
00:29:26 <bartavelle> this : http://hpaste.org/56718
00:29:33 <bartavelle> line 6
00:29:42 <bartavelle> Couldn't match expected type `IO t0' with actual type `[String]'
00:29:43 <kmc> tikhonjelvis, my guess is just that people were used to it, from ML etc.
00:29:55 <kmc> in language with strict evaluation, it is much less convenient to replace "if" with a function
00:30:01 <tikhonjelvis> kmc: Well, it's not a language construct in Lisp :)
00:30:06 <tikhonjelvis> Or scheme, I guess.
00:30:13 <kmc> it's a special form
00:30:16 <tikhonjelvis> They cheat with macros, of course, but that's natural.
00:30:17 <kmc> it's not a function
00:30:22 <tikhonjelvis> Oh yeah, I remember that bit.
00:30:35 <tikhonjelvis> Well, I think it's just a method in Smalltalk :)
00:30:48 <Axman6> bartavelle: ah, the problem is you're using <- where you should be using let .. = args
00:30:52 <bartavelle> ah
00:30:59 <tikhonjelvis> But I've never used Smalltalk so you probably shouldn't trust me.
00:31:19 <bartavelle> this is confusing ... i suppose i should read some documentation instead of trying to bruteforce the syntax
00:31:47 <Axman6> bartavelle: <- isn't assignment. it's taken from the -> in lambdas. x <- foo; bar x y --> foo >>= \x -> bar x y
00:31:47 <tikhonjelvis> bartavelle: Maybe learnyouahaskell.com?
00:32:02 <kmc> @undo do { x <- a; b x }
00:32:02 <lambdabot> a >>= \ x -> b x
00:32:29 <kmc> "do" is syntactic sugar for lambdas and applications of this (>>=) operator
00:32:51 <kmc> @. pl undo do { x <- a; b x }
00:32:52 <lambdabot> b =<< a
00:32:55 <bartavelle> ok
00:33:09 <bartavelle> tikhonjelvis, actually i did read a large part of it, i'm comfortable with the purely functional part, but skipped all the monadic stuff
00:33:15 <bartavelle> i guess this wasn't a smart move
00:33:21 <kmc> that's a false dichotomy
00:33:29 <bartavelle> yes
00:33:33 <kmc> monads in general are "purely functional"
00:33:35 <bartavelle> i understand monads can be pure
00:33:45 <bartavelle> but their syntax is confusing
00:33:48 <bartavelle> to me
00:33:58 <tikhonjelvis> Did you cover Functors and type classes?
00:34:01 <kmc> well the "do" syntax is optional
00:34:06 <kmc> you can do everything with (>>=) instead
00:34:09 <kmc> which is an ordinary operator
00:34:14 <bartavelle> tikhonjelvis, i think so
00:34:25 <kmc> some people recommend getting used to that style before using "do"
00:34:45 <tikhonjelvis> I sometimes use a mix of the two. Don't know if that's good style...
00:34:53 <kmc> it is, if it's a good mix :)
00:34:56 <arbn> bartavelle: You might try the "Trivial Monad" tutorial. I found that more helpful than LYaH.
00:35:29 <tikhonjelvis> I can't remember where I understood monads for the first time. It wasn't LYaH though.
00:35:43 <tikhonjelvis> Not that there's anything wrong with it--I was just reading other things at the time.
00:35:51 <bartavelle> actually i did write a complex parser, so I wrote a bit of parsec which has a monadic interface (i suppose?)
00:36:06 <tikhonjelvis> It does.
00:36:07 <bartavelle> but it almost only was about using ; between declarations
00:36:18 <kmc> Parsec supports a monadic interface, among others
00:36:22 <bartavelle> didn't have to really understand what happened
00:36:40 <kmc> LYAH didn't exist when i was learning Haskell
00:36:50 <kmc> i read All About Monads, which was helpful, but is kinda crap too
00:36:58 <tikhonjelvis> Resoudning praise there
00:37:31 <tikhonjelvis> I learned Haskell concurrently with SICP. I'm not sure if that helped or hurt though...
00:37:46 <kmc> http://www.haskell.org/wikiupload/2/23/Monad-tutorials-chart.png
00:38:01 <tikhonjelvis> I did find the Write Yourself a Scheme Tutorial really helpful though.
00:38:08 <tikhonjelvis> But that is probably *not* a coincidence.
00:38:56 <tikhonjelvis> That said, for covering the same things, it's surprising how different the SICP Scheme interpreters were from the Haskell version.
00:43:21 <carpi> is it really okay to completely forget about order of evaluation while writing a function and only concentrate on what the function is going to do?
00:43:53 <tikhonjelvis> I don't see why it wouldn't be.
00:44:47 <carpi> its a mental paradigm shift.. cos its different to what im used to
00:45:20 <tikhonjelvis> I have to admit I never gave it much mind in other languages.
00:45:46 <tikhonjelvis> Luckily I've only had to do a bit of multi-threaded imperative programming so far :)
00:50:18 <av> hi, can anyone help me with Parsec? here's the code: http://hpaste.org/56690
00:51:07 <tikhonjelvis> Wow, I just noticed that hpaste gives you warnings.
00:51:13 <kmc> carpi, it's a good way to start, but not always sufficient
00:51:17 <kmc> particularly if you care about performance
00:51:58 <kmc> instead of "concentrate on what the function is going to do" i would say "concentrate on what the function is" or "what the function means"
00:52:23 <carpi> kmc: thats what I thought. I mean.. after all.. haskell can't be thaaat good ;)
00:52:25 <tikhonjelvis> Among other things, it makes your code look like what it represents (if you squint).
00:52:50 <kmc> Haskell makes almost no performance guarantees
00:53:09 <kmc> it doesn't even require lazy evaluation
00:53:36 <tikhonjelvis> I've had too much fun with gcc to believe in predictable performance :)
00:53:37 <kmc> just the semantics that match lazy evaluation
00:53:51 <carpi> a while ago.. I read an article that mentioned the ability to modifty some sort of intermediate code for performance gains..
00:53:55 <av> the question is: is the lexeme parser integer supposed to succeed when the integer is immediately followed by the string, without whitespace separating the two? I would like to have it fail in this case
00:54:01 <carpi> kmc: so you first write the function normally..
00:54:10 <carpi> and then you partially compile it i think
00:54:17 * shachaf wonders whether various other languages actually guarantee strict evaluation.
00:54:19 <carpi> which gives you some sort of human readable intermediate code
00:54:31 <carpi> and modify this intermediate code for performance
00:54:38 <carpi> i don't remember the article that i read it from
00:54:41 <tikhonjelvis> shachaf: laziness + mutation = death. So I hope they do.
00:54:50 <shachaf> I suppose it's a thing you need to specify in defining a language.
00:55:19 <Axman6> carpi: you're probably talking about Core, and I don't think anyone writes core. you modify your Haskell code to get the Core you're after
00:55:25 <tikhonjelvis> I think some languages give you pretty good control over it though.
00:55:30 <kmc> actually laziness is based on pervasive implicit mutation
00:55:45 <tikhonjelvis> erm
00:55:48 <shachaf> kmc: Yes, but I'm sure that's not what tikhonjelvis meant.
00:55:51 <kmc> and Haskell supports both
00:56:04 <Axman6> kmc: but only mutation from a computation that describes a result into the result?
00:56:10 <kmc> yeah
00:56:19 <tikhonjelvis> I guess lazy is subtly different from normal order evaluation?
00:56:26 <kmc> but that's enough to implement some things that seemingly require "real mutation"
00:56:29 <kmc> like memoization
00:56:42 <carpi> Axman6: hmm. i think that is what it is though i can't be sure..
00:56:42 <shachaf> Sure.
00:56:58 <shachaf> But that's not like mutation of identifiers at the level of the language.
00:57:01 <Axman6> carpi: almost certainly
00:57:34 <kmc> tikhonjelvis, "lazy" is an evaluation strategy best described by manipulating a graph, not a syntax tree
00:57:51 <carpi> In any case, it is unfortunate that one must be constanty aware of performance while writing code in haskell
00:58:04 <kmc> it differs from call-by-name in that you share the results of computations which are demanded on multiple branches
00:58:12 * av wonders whether anyone can help with Parsec
00:58:16 <tikhonjelvis> carpi: That's true of any language that can deliver good performance. In other language, you just don't bother.
00:58:27 <kmc> sure, but Haskell makes it much harder in some ways
00:58:46 <shachaf> And easier in some ways.
00:58:48 <kmc> tikhonjelvis, if i evaluate «let x = big_complicated in x+x» under call-by-name, I substitute to get «big_complicated + big_complicated» and I duplicate that work
00:58:50 <shachaf> FSVO "performance"
00:58:51 <tikhonjelvis> Maybe. But it's surprisingly easy to write really slow C. (If, like me, you don't know what you're doing :)).
00:59:13 <kmc> tikhonjelvis, with lazy evaluation you have a graph that *isn't* a tree, you have a node for (+) that points twice to the *same* big_complicated
00:59:25 <tikhonjelvis> ah, that makes sense
00:59:29 <kmc> once you've evaluated big_complicated the first time, you replace that node in place
00:59:33 <kmc> (that's the mutation)
01:00:57 <Manehattan> hello... does anyone have an idea how I can make a 'Conduit a m b' to 'Conduit (a,c) m (b,c)'?
01:01:01 <carpi> though.. somehow on the language shootouts haskell seems to score quite well..almost on par with some of the faster languages..
01:01:22 <kmc> carpi, yeah, have you looked at the "Haskell" code for those?
01:01:26 <tikhonjelvis> carpi: Those benchmarks don't show how much programmer effort it takes to reach that performance.
01:01:41 <shachaf> Some of those benchmarks are also completely bogus.
01:01:45 <shachaf> E.g. "thread-ring".
01:01:48 <carpi> but i think the code tested in those shootout was written by haskell ninja's
01:02:08 <kmc> not "Haskell ninjas", people who know a lot about GHC specifically
01:02:13 <Axman6> shachaf: oi, don't belittle my claim to fame :(
01:02:23 <kmc> tuned for particular compiler versions, and extremely fragile
01:02:23 <shachaf> Axman6: What? It is.
01:02:28 <Axman6> yeah i know
01:02:32 <shachaf> Axman6: If the judges knew better they'd reject it.
01:02:35 <c_wraith> the thread ring benchmark is funny.  It seems specifically designed to tailor to the non-threaded GHC runtime.
01:02:40 <Axman6> but, how many of you can say you made Don Stewart's code faster? =)
01:02:59 <tikhonjelvis> Bah, I can barely say I've ever made *my own* code faster...
01:03:09 <Axman6> shachaf: why? it does exactly what's asked for. it's a hell of a lot faster when compiled without threading
01:03:42 <c_wraith> shachaf: if you've looked at the current fastest C code for that benchmark, you'd see that it's cheating pretty hard, too
01:03:43 <shachaf> Axman6: No, what's asked for is "preömtive threads"
01:03:52 <kmc> writing very high-performance Haskell code tends to require lots of ugly, verbose, unsafe, fragile, compiler-specific hacks
01:04:02 <c_wraith> so clearly, the judges don't mind that particular kind of cheating
01:04:02 * av wonders if Parsec was written just for him and nobody else uses it
01:04:11 <kmc> but the baseline of GHC performance without all that is still adequate for many tasks
01:04:13 <tikhonjelvis> kmc: So does very high-performance C
01:04:17 <shachaf> Of course the requirements are also silly.
01:04:28 <shachaf> But that doesn't change the fact that the GHC code doesn't meet them.
01:05:02 <c_wraith> Actually, GHC can't generate truly pre-emptive code in any way.
01:05:11 <c_wraith> Which is something of a problem.
01:06:04 <c_wraith> if you know how to write a non-allocating infinite loop, you can hang even the threaded runtime with it.
01:06:13 <shachaf> Right.
01:06:53 <c_wraith> fortunately, it's the case that it's kind of hard to do accidentally, and people who know how to do it know not to
01:07:01 <Manehattan> so does anyone have an idea how I can make a 'Conduit a m b' to 'Conduit (a,c) m (b,c)'?
01:07:55 <carpi> my friend is working on a project that requires him to not be able to use any construct that is not a function or a part of the language. So in essence, avoiding the use of variables. Would it be possible to write a body of code that consists of only functions and language elements?
01:07:56 <c_wraith> because it needs to spin forever.  most infinite loops block on blackholes, instead
01:08:19 <c_wraith> carpi: sure.  SKI calculus, for instance
01:08:29 <tikhonjelvis> capri: Does that exclude data types?
01:09:11 <tikhonjelvis> You could always use some really esoteric language that has none of those things :)
01:09:26 <carpi> it includes data types.. after all, it would be impossible to do anything useful in haskell without data type
01:09:42 <carpi> tikhonjelvis: but he using it for haskel
01:09:46 <tikhonjelvis> ah
01:10:08 <carpi> its actually quite interesting.. its soething like this..
01:10:23 <carpi> the setup includes a computer, camera and lots of lego blocks
01:10:56 <carpi> you attach meaning to the different lego blocks based on their size or color or any other property
01:11:08 <carpi> and the meaning could be a function or a language element.
01:11:11 <carpi> no variables
01:11:27 <carpi> and you build your body of code using those lego pieces..in front of the camera
01:11:42 <carpi> and the computer processess what you are building live..and translate it to haskell code
01:11:55 <c_wraith> carpi: he should really look at http://en.wikipedia.org/wiki/To_Mock_a_Mockingbird
01:11:59 <tikhonjelvis> Heh, that's pretty neat.
01:12:01 <Manehattan> sounds to me like arrow combinators
01:12:03 <c_wraith> it introduces a visual combinator logic
01:12:24 <tikhonjelvis> Some people really have fun naming their books.
01:12:26 <carpi> and that is why the necessity to avoid using custom variables
01:13:26 <bartavelle> is there an easy way to load latin1 files with getContents ?
01:13:44 <dmos> I have a lot of state wrapped in (many) closures (think arrow stream transformers). Now I need to be able to manipulate said state (store to/restore from state snapshots). Any ideas/pointers on how to structure the code to achieve this?
01:13:51 <bartavelle> nvm, i'll read the doc
01:14:02 <carpi> thans for link... looks interesting.. is it directly related to the what he is doing?
01:14:13 <c_wraith> bartavelle: well, you can open the file, set the encoding on the handle, then use hGetContents
01:14:48 <c_wraith> carpi: it has a system that models all calculations in a visual way, without involving variables
01:15:13 <c_wraith> carpi: I don't know how *directly* it will apply, but it should certainly be useful to consider
01:16:18 <bartavelle> c_wraith, yes, works better
01:16:20 <carpi> but would building haskell code with lego blocks be useful? i feel like it more of a toy than something someone here would use
01:16:41 <tikhonjelvis> It's lego! It justifies itself.
01:25:26 <lukish> From what cabal package is System(getArgs) import?
01:25:33 <lukish> @index getArgs
01:25:34 <lambdabot> System.Environment
01:26:13 <lukish> cabal: There is no package named system
01:26:30 <tikhonjelvis> I suspect it's installed by default or part of base. Or something.
01:26:35 <tikhonjelvis> Are you sure it doesn't just work?
01:27:01 <c_wraith> System is in the haskell98 package, which is no longer compatible with the base package
01:27:12 <c_wraith> it only exists for compatibility with Haskell98 code
01:27:25 <c_wraith> Use System.Environment for getArgs now
01:27:31 <c_wraith> which is in base
01:40:58 <lukish> http://pastebin.com/g95FNYNU i have that problem again
01:41:00 <mauke> The paste g95FNYNU has been copied to http://hpaste.org/56719
01:41:34 <lukish> I already removed ~/.ghci and ~/.ghc/
01:41:43 <lukish> I already removed ~/.cabal and ~/.ghc/ *
01:49:57 <hpaste_> btvl pasted “mysqldumpextract” at http://hpaste.org/56720
01:50:09 <bartavelle> i just wrote this, it is quite simple, but incredibly slow
01:50:14 <bartavelle> if somebody has advice
01:50:37 <bartavelle> ah hpaste has hints
01:50:38 <bartavelle> fun
01:51:04 <statusfailed> What exactly is "Data.Generics" and why/how is it different to Template Haskell?
01:51:16 <c_wraith> it's almost entirely different
01:51:47 <c_wraith> Data.Generics is runtime support for getting information about a data structure, so many different data structures can be manipulated with the same code
01:52:10 <c_wraith> Template Haskell is about generating code at compile-time programmatically.
01:52:23 <c_wraith> They have some overlapping use cases, in the case of implementing instances for data types
01:52:33 <c_wraith> But the mechanisms they use are very different
01:54:52 <statusfailed> c_wraith: Ah, ok. that makes sense
01:55:13 <siracusa> bartavelle: Using attoparsec instead of parsec would be worth a try to improve speed
01:55:15 <statusfailed> There seem to be very many libraries for generics though
01:55:24 <c_wraith> there are.
01:55:51 <c_wraith> Data.Generics has the advantages of being faster than Data.Data, but it's still something GHC can auto-derive (at least newer versions of GHC can)
01:55:53 <statusfailed> Can generics libraries be written using the standard language then?
01:56:07 <statusfailed> oh, so Data.Data is also a generics library?
01:56:10 <c_wraith> yes
01:56:13 <bartavelle> siracusa, is that something very similar ? Or will I have to invest significant time ?
01:56:34 <dreixel> sorry, but Data.Generics and Data.Data are the same library, namely syb
01:56:42 <dreixel> maybe you are confusing it with GHC.Generics ?
01:56:57 <siracusa> bartavelle: It's very similar, but you'd have to use ByteString instead of String, IIRC
01:57:02 <c_wraith> Oh, I was
01:57:09 <statusfailed> 0_o
01:57:36 <dreixel> statusfailed: what kind of generic functions are you looking for?
01:57:48 <dreixel> if you're manipulating large ASTs, probably syb is the easiest/most convenient
01:58:00 <dreixel> for about anything else I generally recommend GHC.Generics, these days
01:58:02 <statusfailed> Ok, I want to examine a datastructure to read/write a config file
01:58:43 <statusfailed> of the form KEY=VALUE, where KEYs correspond to datastructure fields
01:58:57 <dreixel> ok, then in principle I'd suggest GHC.Generics
01:59:12 <statusfailed> in principle?
02:00:07 <dreixel> yes, there might be details you're not telling me, or haven't yet realized you will need :)
02:00:16 <dreixel> have a look at http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html
02:00:25 <dreixel> this is also assuming you are using GHC version 7.2, at least
02:00:51 <statusfailed> I can be :)
02:00:57 <statusfailed> (probably am)
02:01:03 <statusfailed> nope, upgrading
02:01:19 <dreixel> the links at the end of that page also provide more information and examples
02:01:31 <dreixel> you are looking for a generic reader and writer, there are good examples of those
02:01:40 <dreixel> (e.g. read and show)\
02:02:19 <statusfailed> What are the advantages of GHC.Generics over Data.Data and Data.Generics?
02:02:28 <statusfailed> or: which is likely to exist for longer
02:02:47 <lukish> http://pastebin.com/ANqksVCa I've try to build MonadRandom and get that message
02:02:49 <mauke> The paste ANqksVCa has been copied to http://hpaste.org/56721
02:02:49 <dreixel> statusfailed: it's faster, and, in my opinion, more elegant
02:03:09 <dreixel> statusfailed: syb (Data.Data) has been around for longer
02:03:36 <dreixel> but I don't think anyone can guarantee you for how long GHC will support either of them
02:03:53 <statusfailed> I've seen lots of uses of the Data and Typeable classes before, which is why I ask
02:04:16 <dreixel> right, they have been around for much longer, so lots of generic code in the wild uses them
02:04:37 <dreixel> but I find generic readers particularly nasty to write in syb
02:04:37 <quicksilver> Typeable is not really replaced by GHC.Generics I don't think
02:04:44 <lukish> @index urlEncode
02:04:44 <lambdabot> bzzt
02:04:51 <dreixel> no, indeed, Typeable is different.
02:05:01 <quicksilver> but GHC.Generics appears to be the nicest of the generics APIs so far
02:05:12 <quicksilver> and there have been many over the years (more than the ones you mentioned)
02:05:24 <dreixel> some 15 or so :P
02:05:31 <statusfailed> yeah, I saw a list somewhere
02:05:31 <statusfailed> heh
02:05:37 <statusfailed> ok, I will take your advice then
02:06:03 <dreixel> statusfailed: if you run into problems just ask
02:06:22 <dreixel> I'm not always around, but you can also use the generics mailing list
02:07:44 <statusfailed> dreixel: oh trust me I'll ask :D
02:08:00 <statusfailed> thanks :)
02:09:09 <dreixel> yw
02:24:21 <donri> when you say ghc.generics, you mean in 7.2+?
02:24:35 <donri> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html doesn't seem to have a whole lot in 7.0
02:25:36 <dreixel> donri: yes, 7.2+
02:26:00 <dreixel> before that we had the generic classes, a very different thing
02:30:31 <donri> WP: "Software entities created using generic programming are known as generics in Ada, Eiffel, Java, C#, F#, and Visual Basic .NET; parametric polymorphism in ML, Scala and Haskell (the Haskell community also uses the term "generic" for a related but somewhat different concept); templates in C++; and parameterized types in the influential 1994 book Design Patterns."
02:30:39 <donri> is there a good read explaining that parenthesis?
02:31:11 <dreixel> donri: yes
02:31:14 <dreixel> just a sec
02:31:26 <shachaf> donri: Maybe it's referring to SYB?
02:31:48 <dreixel> here's a good article explaining many forms of generics in many languages
02:31:57 <dreixel> trying to clear up some of the naming confusion: www.cs.ox.ac.uk/jeremy.gibbons/publications/dgp.pdf
02:32:09 <donri> thanks
02:33:28 <donri> i've also heard that generics do at runtime what can sometimes be done at compile-time with e.g. template-haskell?
02:33:53 <shachaf> donri: Have you figured out what you mean by the word "generics" yet?
02:34:05 <donri> no :) reading, sorry
02:34:11 <shachaf> If not, then there's probably not a very productive answer to that question. :-)
02:34:17 <donri> in deed
02:35:11 <dreixel> that paper will explain everything ;-)
02:35:36 <donri> yes, patience me young padawan
02:39:18 <adimit> what's preferred style for ignoring two args? \_ _ -> x or const $ const x? I prefer the former, methinks.
02:40:51 <shachaf> adimit: Then use the former.
02:41:28 <shachaf> (\_ -> return pure const x)
02:41:57 <adimit> shachaf: yeah, will do. I just thought I'd poll "the community," because maybe there are preferences.
02:42:27 <shachaf> I think context is more relevant here.
03:05:52 <wereHamster> how can I mark a function as internal so haddock won't generate documentation for it?
03:06:20 <shachaf> wereHamster: Is it sufficient not to export it?
03:07:13 <wereHamster> it is, but then haddock still reports coverage as 6/8  75%
03:07:21 <wereHamster> the two functions are internal stuff
03:11:07 <McManiaC> can I build & install ONLY the library of a cabal package?
03:11:14 <ChristianS> -- |This function is internal stuff, nobody cares what it does.
03:11:21 <McManiaC> the executable seems to break all the time
03:11:27 <McManiaC> i.e. the compilation fails
03:11:42 <McManiaC> and I dont really need it anyway
03:13:22 <ocharles> McManiaC: only way I know would be to unpack it and manually edit the .cabal file
03:16:17 <donri> I have NoImplicitPrelude listed in extensions in Cabal which causes Paths_pkg to fail to build; anyone got a solution?
03:18:59 <hvr> what do the "trace elements" in GHC heap-profiles mean?
03:19:36 <hvr> (and what does it mean, if they take up a significant amount of the heap-prof?)
03:29:35 <bartavelle> I can't find <|> in attoparsec, but this seems to use it : http://hackage.haskell.org/packages/archive/aeson/0.3.2.11/doc/html/src/Data-Aeson-Parser.html
03:29:36 <bartavelle> how comes ?
03:29:51 <hvr> bartavelle: import Control.Applicative
03:30:04 <bartavelle> trying
03:30:40 <bartavelle> seems ok
03:31:00 <bartavelle> question 2 : is it possible to easily do something like "word8 '('"
03:31:11 <bartavelle> because '(' is a char and word8 wants Word8
03:31:14 <bartavelle> hum
03:31:17 <bartavelle> i can use the hex value
03:31:24 <hvr> Char != 8bit
03:31:33 <hvr> Char is actually a unicode code-point
03:31:59 <ion> Data.ByteString.Internal.c2w (with the obvious warnings)
03:33:22 <bartavelle> thx
03:40:12 <Veinor> http://hackage.haskell.org/package/fix-imports this looks neat
03:41:46 <ion> Oh, i had forgot about that. I’ll have to try it.
03:44:15 <Veinor> bleh, darcs
03:44:34 <Veinor> actually, more
03:44:41 <Veinor> 'bleh, hosted on a repository without a convenient web view)
04:05:53 <carpi> i wrote some code to find the mean of numbers from 1 to 1e9 and I timed it. It took 33.145s without adding signatures to the helper functions in the 'mean' function while it took only 16.682s when i added the signature to the 'mean' function's helper function..
04:06:03 <carpi> could someone please tell me if that is expected behaviour?
04:06:12 <quicksilver> it's not surprising
04:06:24 <quicksilver> you stopped it being polymorphic
04:06:25 <mauke> you didn't add "the signature"
04:06:31 <mauke> you added "a signature"
04:06:41 <quicksilver> so GHC was able to specialise to the types you chose
04:06:46 <quicksilver> and generate simpler/faster code
04:07:28 <carpi> soo adding a signature makes such a big difference? i mean it almost slashed the time it took by half
04:07:30 <Veinor> that'd depend on the signature, wouldn't it
04:07:55 <Veinor> could you hpaste the code?
04:08:17 <carpi> one momen please
04:10:57 <Ptival> carpi: figure out how the polymorphic type was instantiated, see if it differs from the explicit one you provided
04:11:05 <hpaste_> Carpi pasted “performance anomoly” at http://hpaste.org/56722
04:13:23 <Ptival> go ::  Integral a => Double -> a -> Double -> Double
04:14:16 <Veinor> i assume it instantiates 'a' as Integer in that case
04:14:19 <Veinor> and Integers are slower than Ints
04:14:46 <carpi> but i don't think Ints go as high as 1e9
04:15:15 <Ptival> > maxBound :: Int
04:15:16 <lambdabot>   9223372036854775807
04:15:35 <carpi> oops speggetti sauce
04:15:39 <Veinor> > 2 ^^ 31 - 1
04:15:41 <lambdabot>   2.147483647e9
04:16:01 <mauke> 2^31 has 10 digits
04:16:09 <tdammers> Int is platform dependent, right?
04:16:21 <Veinor> yeah
04:16:46 <tdammers> so you might even get 63 bits, if you run on x64
04:16:54 <Veinor> > 2 ^^ 64 - 1
04:16:55 <lambdabot>   1.8446744073709552e19
04:17:01 <bartavelle> if somebody has something more effective than that for parsing single quoted strings with \' in them : http://hpaste.org/56723
04:17:01 <Veinor> > 2 ^ 63 - 1
04:17:02 <lambdabot>   9223372036854775807
04:17:03 <bartavelle> I'm interested
04:17:07 <Veinor> > 2 ^ 63 - 1 == maxBound
04:17:08 <lambdabot>   Ambiguous type variable `t' in the constraints:
04:17:08 <lambdabot>    `GHC.Num.Num t' arising ...
04:17:09 <bartavelle> (with attoparsec)
04:17:11 <Veinor> > 2 ^ 63 - 1 == maxBound :: Int
04:17:12 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:17:12 <lambdabot>         against inferred type ...
04:17:15 <Veinor> :|
04:17:41 <Veinor> oh right
04:17:46 <Veinor> > 2 ^ 63 - 1 == (maxBound :: Int)
04:17:47 <lambdabot>   True
04:19:43 <Veinor> you're only guaranteed 28 bits but eh
04:20:57 <tdammers> > 2 ^^ 28 - 1
04:20:58 <lambdabot>   2.68435455e8
04:23:34 <zeiris> How do I turn a String into a ByteString, without a Word8/=Char mismatch?
04:25:40 <ocharles> what is a "Word8/=Char mismatch"?
04:25:54 <ocharles> @hoogle String -> ByteString
04:25:55 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
04:25:55 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
04:25:55 <lambdabot> Data.String fromString :: IsString a => String -> a
04:26:03 <zeiris> Ah, I had the wrong import.
04:28:15 <Veinor> that won't work in general for unicode stuff, though
04:29:08 <quicksilver> @hoogle utf8encode
04:29:08 <lambdabot> No results found
04:30:44 <quicksilver> Data.Bytestring.UTF8 is probably a better answer, ocharles
04:30:51 <quicksilver> I mean, zeiris
04:31:01 <quicksilver> not using ByteString at all may possiblye be even better.
04:31:30 <ocharles> Data.Text \o/
04:31:43 <Veinor> Data.Text is excellent
04:32:52 <asda8_> there are still a lot of libs that use ByteString :(
04:33:20 <mauke> good
04:33:57 <Veinor> why's that good?
04:34:12 <mauke> we need more ByteStrings
04:34:38 <Veinor> it sucks at unicode though
04:35:38 <Sgeo> Just use ByteStrings for binary non-text data?
04:35:46 <Sgeo> Sounds useful for some purposes to me
04:37:19 <quicksilver> yes, I wasn't suggesting bytestrings were bad for binary data
04:37:30 <quicksilver> but the OP had text, presumably, since he was talking about Char
04:37:43 <Veinor> also Data.ByteString code is absolutely unreadable
04:37:48 <Veinor> i mean, the implementation
04:42:40 <av> Hi everyone, I wonder if anyone can help me with Parsec's token parser
04:42:52 <av> there's an example in http://hpaste.org/56690 -- why doesn't the parser fail?
04:43:39 <av> the integer parser succeeds even though there is no whitespace directly succeeding it
04:44:31 <av> how do i enforce the whitespace such that the parser succeeds on "123 abc" but fails on "123abc"?
04:44:34 <ChristianS> @hoogle utf8-string
04:44:34 <lambdabot> package utf8-string
04:44:50 <ChristianS> it's not perfect for utf8-encoded bytestrings, but it's a start
04:45:41 <Axman6> av: i can't open the link now, but what are you using to parse the whitespace?
04:46:52 <av> Axman6: it's the integer lexeme parser from Parsec.Token
04:47:11 <Axman6> av: what code are you using to parse the whitespace i mean
04:47:55 <av> Axman6: the lexeme parser has a trailing whiteSpace parser (also from Parsec.Token) incorporated automatically
04:48:26 <av> Axman6: it looks like that whiteSpace parser allows 0 or more, not 1 or more whitespace
04:48:40 <Veinor> yeah, that looks right
04:48:44 <Veinor> kind of odd
04:50:23 <Veinor> but i assume that's so that you can write 2+3 and have that parse properly
04:51:35 <av> Veinor: good point, makes sense
04:52:39 <av> Veinor: but then again, "+" is an operator which you can also define in the language definition, so the parser could just as well look for either an operator or whitespace following the integer
04:53:08 <av> Veinor: but not failing on "123abc" is plain wrong in my case, so the question is: how do I make it fail
04:53:12 <Veinor> what about for(i=0;i<3;i++){printf("hi");}
04:53:18 <antq> so, is there a idiomatic way of passing along context during tree (AST) traversal in Haskell? I currently have, "tExpr :: Ctx -> Expr -> TM Foo" or "tExpr :: Expr -> Ctx -> TM Foo" but I was hoping not to name Ctx to every function. Using StateT Ctx TM Foo seems like overkill. Any suggestions?
04:53:36 <Veinor> av: you could use the whiteSpace parser?
04:53:39 <Veinor> er wait no
04:53:40 <Veinor> that's silly
04:55:26 <Veinor> you could use symbol " "
04:55:28 <Veinor> i think
04:55:45 <Veinor> which will parse a literal 0x20 character and then any amount of whitespace
04:56:15 <av> Veinor: not good either since it could well be a tab, newline, eof, etc., doesn't have to be a space character
04:57:36 <Veinor> try lexeme space then
04:57:44 <Veinor> where space is defined in Text.Parsec.Char
04:59:33 <av> Veinor: sure, but that would bloat my code so far that using the Parsec.Token stuff is no longer really worth it -- if there is no simple solution, then I'll abandon Parsec.Token altogether (my grammar isn't all that complicated)
05:00:39 <Veinor> yeah, it sounds like what you're doing isn't a perfect fit for Parsec.Token
05:01:50 <sipa> antq: does Ctx change during traversal?
05:04:07 <antq> sipa: yes
05:04:32 <sipa> but only downward?
05:04:48 <sipa> (in that case, you could use ReaderT Ctx as well)
05:07:34 <antq> sipa: only downard
05:07:39 <antq> ReaderT great.. thank you very much
05:08:05 <antq> sipa: yeah, exactly. i didn't want to have to wrap StateT to pop state before returning
05:09:34 <sipa> antq: there is also something called implicit arguments, but i haven't used that myself
05:10:58 <quicksilver> don't use it, ever.
05:11:31 <sipa> it feels like a hack
05:11:43 <quicksilver> it is a hack and it doesn't make a lot of sense with lexical scope
05:13:30 <hpc> the only legit use for it ive seen is lambdabot @type queries
05:13:32 <hpc> :t map ?f
05:13:33 <lambdabot> forall a b. (?f::a -> b) => [a] -> [b]
05:13:58 <koeien> that's clever
05:14:20 <hpc> :t ?f . ?f
05:14:21 <lambdabot> forall a. (?f::a -> a) => a -> a
05:15:35 <Veinor> oh, so you use it to figure out 'what type does this thing have to be'
05:15:38 <Veinor> cute
05:16:24 <antq> are they anything like Agda's implicit arguments (or instance arguments) or Scala's implicits?
05:16:53 <hpc> antq: not sure what scala's implicits are
05:17:08 <hpc> they are like perl's local keyword, if that helps
05:17:26 <hpc> https://en.wikipedia.org/wiki/Scope_%28programming%29#Lexical_versus_dynamic_scoping
05:17:41 <antq> i don't know perl :) but i can look that up anyway
05:17:58 <antq> example of implicits in a monoid: http://www.scala-lang.org/node/114
05:18:03 <danr> hpc: isn't local for dynamic scoping in perl?
05:18:05 <antq> s/in/for
05:18:15 <bartavelle> can i create a "IO Handle" from a "Handle" ?
05:18:17 <antq> hpc: thanks
05:18:21 <sipa> bartavelle: return
05:18:25 <bartavelle> ok
05:18:59 <bartavelle> thanks
05:19:24 <hpc> danr: implicit params are basically dynamic scope
05:19:29 <antq> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/other-type-extensions.html covers it
05:19:55 <danr> hpc: they are? hmm I never thought about it that way
05:20:35 <hpc> oh hey, they are even documented as dynamic scope
05:21:07 <koeien> can't you just use the Reader monad?
05:21:12 <nand`> What's the difference between ReaderT a IO () and Reader a (IO ())
05:21:33 <nand`> as in, what's the advantage
05:21:37 <sipa> nand`: the first is a monad action that produces (), composed from IO and ReaderT
05:21:49 <hpc> nand`: yourRunReader2 :: a -> IO ()
05:22:11 <hpc> @unmtl ReaderT a IO ()
05:22:11 <lambdabot> a -> IO ()
05:22:23 <hpc> @unmtl Reader a (IO ())
05:22:23 <lambdabot> a -> IO ()
05:22:26 <antq> yeah. btw this is more or less how Agda's instance arguments (alternative to type classes) work.. didn't realise the more general term was "dynamic scope." thanks guys
05:22:54 <hpc> nand`: you get transformer functions for free, would be the main advantage
05:22:55 <antq> anyway, back to work for me :)
05:22:57 <hpc> :t lift
05:22:58 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:23:09 <Veinor> . o O (MonadCis)
05:23:24 <hpc> in this case, lift :: IO a -> ReaderT e IO a
05:23:40 <nand`> :t return :: (Monad t, Monad m) => m a -> t (m a)
05:23:41 <lambdabot> forall (m :: * -> *) a (t :: * -> *). (Monad m, Monad t) => m a -> t (m a)
05:24:05 <nand`> I still don't see the difference
05:24:58 <koeien> you have lift, otherwise you'd need quite so plumbing
05:25:03 <nand`> in my example return :: IO () -> Reader (IO ())
05:25:04 <koeien> /so/some
05:25:08 <nand`> Reader e*
05:25:30 <nand`> hmm
05:25:58 <nand`> can you provide a minimal example of a program that uses monad transformers that would be much more complex using nested monads
05:25:59 <hpc> nand`: i suppose in the case of Reader, the two are the same
05:26:11 <hpc> @unmtl State s (IO a)
05:26:12 <lambdabot> s -> (IO a, s)
05:26:17 <hpc> @unmtl StateT s IO a
05:26:17 <lambdabot> s -> IO (a, s)
05:26:31 <nand`> ah
05:26:40 <nand`> there's the difference I was looking for
05:26:40 <hpc> try writing a stateful IO action that sets the state to the result of getLine
05:26:51 <hpc> ie, setLine :: State String (IO ())
05:27:04 <hpc> :t lift getLine >>= put
05:27:05 <lambdabot> forall (t :: (* -> *) -> * -> *). (MonadTrans t, MonadState String (t IO)) => t IO ()
05:27:13 <hpc> it's that easy with transformers
05:27:39 <koeien> yeah State is obvious, but in Reader you could just do ask >>= \x -> ...
05:27:40 <hpc> nand`: that Reader example was tricky; i almost started questioning the usefulness of transformers myself :P
05:28:12 <nand`> not a good idea then that the introduction on monad readers (haskellwiki) uses reader and IO
05:28:23 <nand`> err
05:28:25 <nand`> moand transformers8
05:28:36 <koeien> well Reader is one of the easiest monads
05:28:56 <koeien> the motivation is weak in that case, yeah
05:29:18 <nand`> personally I think State is simpler than Reader
05:29:34 <koeien> really? Reader e is just (e ->)
05:30:02 <danr> o_O only identity monad is simpler than reader monad!
05:30:21 <danr> or the constant unit monad
05:30:25 <danr> mayhaps
05:30:34 <hpc> depending on your weighted values of "simple", i would say Maybe is simpler than Reader
05:31:01 <hpc> smaller kind, and it doesn't use "scary functions"
05:31:01 <nand`> and []
05:31:15 <nand`> since it works the way you'd expect it to
05:31:26 <nand`> (well, that's true for most monads - but here it's graphical and intuitive)
05:31:57 <hpc> [] is perhaps the monad that people start using first when they learn haskell
05:32:00 <hpc> even before IO
05:32:05 <hpc> because list comprehensions
05:32:17 <nand`> it's great for modelling non-deterministic calculations
05:32:41 <hpc> nand`: and also for modelling "try every combination" calculations
05:32:59 <koeien> what's the difference?
05:33:11 <hpc> koeien: perspective :P
05:33:43 <nand`> > filterM (const [True, False]) [1,2,3]
05:33:44 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
05:34:16 <hpc> heh, when i was taking stat last semester, i used ghci instead of R for the homework
05:34:29 <hpc> and that filterM term was the basis for pretty much all the functions i defined
05:35:45 <koeien> i used higher order functions in R, my instructor went crazy
05:36:07 <hpc> haha
05:37:04 <dcoutts> donri: oh that's an interesting bug, we should fix that by explicitly importing the Prelude in Paths_pkg.
05:37:05 <hpc> at work i wrote curry and ($) in perl, for a bit of particularly callback-heavy code
05:37:11 <Sgeo> :t filterM
05:37:12 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
05:37:12 <hpc> my boss still hasn't reviewed that work yet :P
05:37:38 <dcoutts> donri: the workaround would be to use {-# LANGUAGE NoImplicitPrelude #-} in the modules, rather than extensions: NoImplicitPrelude
05:37:39 <koeien> perl programmers should know TIMTOWTDOI
05:38:14 <hpc> koeien: sadly, they seem to know "there's a couple of ways to do most things"
05:38:35 <hpc> all perl code ive seen that wasn't my own was written in either sed-style or C-style
05:38:50 <hpc> and admitedly most of mine too
05:40:03 <nand`> I tried to curry in C# once
05:40:18 <nand`> Func<Func<int>,Func<Func<int>,Func<int>>>
05:40:23 <nand`> that was the signature I came up with for the + function
05:40:38 <koeien> that's not even polymorphic :)
05:41:15 <hpc> currying in perl is fun, because it's polymorphic in tuple width
05:41:23 <nand`> C# doesn't have any common parent for numeric classes unfortunately
05:41:47 <nand`> I could use Func<object> etc. though for an effectively untyped calculus
05:41:57 <koeien> wouldn't that box like crazy?
05:42:01 <nand`> it would
05:42:11 <nand`> actually I'm not sure
05:42:17 <nand`> does implicit covariance/contravariance box
05:42:51 <nand`> I'm guessing not, but I'd still need a different function for each type of integer
05:42:52 <nand`> oh well
05:43:03 <hpc> i imagine the performance depending on what kind of optimizations happen behind the scenes
05:43:24 <nand`> Func<Func<dynamic>,Func<Func<dynamic>,Func<dynamic>>>
05:43:27 <hpc> it could easily notice that unbox . box == id
05:43:29 <hpc> or it might not
05:46:25 <nand`> hmm
06:02:23 <titto> what is the simplest way of defining a "typeshow" function so that for example: typeshow (33::Int)) -> "Int" ?
06:02:52 <ion> Why do you need one?
06:02:56 <koeien> Typeable
06:03:23 <ion> What do you expect for typeshow (33 :: Num a => a)?
06:03:44 <dmwit> ion: ambiguity error
06:03:54 <dmwit> :t typeOf
06:03:54 <lambdabot> forall a. (Typeable a) => a -> TypeRep
06:04:38 <titto> ion: I would expect it to work only for monomorphic types
06:04:48 <ion> > typeOf (33 :: Num a => a)
06:04:49 <lambdabot>   Integer
06:04:59 <dmwit> Thank goodness for defaulting, eh?
06:05:07 <dmwit> But it does give ambiguity errors for most polymorphic values.
06:05:11 <koeien> show . typeOf yeah
06:05:14 <dmwit> > typeOf (undefined :: Ix a => a)
06:05:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:05:14 <lambdabot>    `GHC.Arr.Ix a'
06:05:14 <lambdabot>      aris...
06:05:18 <koeien> use deriving Typeable on your data types
06:05:33 <lostman> is it possible to use any types in template haskell splices? I want to do something like this:
06:05:45 <lostman> let xs = IntSet.fromList [1..100]
06:05:45 <lostman> in [| if IntSet.member t $( [| xs |] ) then foo else bar |]
06:06:09 <lostman> but GHC complains...
06:06:27 <lostman> Could not deduce (Language.Haskell.TH.Syntax.Lift IntSet)
06:06:38 <KSkrzet> why do you define xs outside of splice?
06:07:08 <lostman> it's actually generated by another bit of TH
06:07:17 <titto> typeOf won't work for [Int], I would need to use typeOf1, my question can also be rephrased as: can I defined a class: class Reflect t where typeRep :: t -> TypeRep
06:07:17 <lostman> but the result is IntSet
06:07:47 <koeien> > typeof ([1,2,3] :: [Int])
06:07:48 <lambdabot>   Not in scope: `typeof'
06:07:52 <koeien> > typeOf ([1,2,3] :: [Int])
06:07:53 <lambdabot>   [Int]
06:08:34 <erus`> whats a sum type
06:08:35 <erus`> ?
06:08:42 <erus`> a product is like a tuple
06:08:43 <koeien> data X = Y | Z
06:08:52 <koeien> that's right
06:08:55 <erus`> like a set of things?
06:08:59 <lostman> do I have to bind it to a name first and use something like $( varE 'xs ) ?
06:09:27 <hpc> product type = "this and this and this and this..."
06:09:34 <hpc> sum type = "this or this or this or this..."
06:09:41 <koeien> the terminology comes from category theory, I think
06:09:50 <dmwit> erus`: You know about disjoint sums from set theory?
06:10:08 <dmwit> Like a union, but with an additional tag, so that common elements can be disambiguated.
06:10:24 <erus`> no i need to read up on that
06:10:24 <dmwit> Well, sum types are the same: like a union, but with a tag (specifically, the constructor used).
06:10:33 <dmwit> Ah, well, that's not a helpful analogy, then.
06:10:34 <dmwit> =P
06:10:51 <koeien> {1,2,3} + {1,4} = {("first", 1), ("first", 2), ("first", 3), ("second", 1), ("second", 4)}
06:11:30 <dmwit> Any type with multiple constructors is a sum type.
06:11:46 <dmwit> And, in the same sense that (,) is "the" product type, Either is "the" sum type.
06:12:08 <erus`> ah ok
06:12:21 <dmwit> (And, to make that sense precise: all other products are isomorphic to some (,)'s, and all other sums are isomorphic to some Either's.
06:12:24 <dmwit> )
06:13:02 <erus`> dmwit: whats the standard notation for a sum type?
06:13:07 <titto> koeien: thanks
06:13:16 <erus`> where A x B is a product
06:13:33 <dmwit> erus`: I'm not sure there is one. You'll see A+B most often in category theory and set theory.
06:13:34 <koeien> you can use +
06:13:43 <koeien> sometimes the disjoint union-symbol
06:13:54 <dmwit> But I don't think there's a super-duper standard notation for type theory.
06:15:54 <dmwit> +, ⊕, ∐, ∀, ⊎ all sort of mean "sum type" in various contexts
06:16:07 <erus`> ok, should i represent products as data structures like A x (B x (C x d))) ? and the same with sum types?
06:16:10 <koeien> how do you pronounce the second one? i've heard it as "puzzle"
06:16:18 <dmwit> erus`: yes, exactly like that
06:16:40 <dmwit> koeien: oplus, tensor sum, tensor plus
06:17:00 <koeien> i've heard tensor plus only in tensor algebra context
06:17:16 <dmwit> It's used in CT that way, too.
06:17:19 <mm_freak> o-plus =)
06:17:22 <koeien> I see. thanks.
06:18:25 <dmwit> http://tlt.its.psu.edu/suggestions/international/bylanguage/mathchart.html seems very nice
06:25:17 <ion> I really wish the list of instances of a type on Haddock had links to the respective instance definitions.
06:26:34 <asda8_> is there a shortcut for writing: do { x <- ['a'..'z']; y <- ['a'..'z']; z <- ['a'..'z']; return ... }
06:26:37 <byorgey> yeah, that would be nice
06:26:41 <asda8_> i mean for binding x,y,z
06:27:17 <ion> Depends on the ...
06:27:27 <byorgey> asda8_: sure:  do { [x,y,z] <- replicateM 3 ['a'..'z']; return ...
06:27:32 <koeien> binding is not "first-class"
06:28:17 <byorgey> binding may not be first-class but you can bind a whole pattern full of variables at once.
06:28:22 <koeien> if ... is, for instance, x+y+z
06:28:46 <koeien> you can do liftM3 (\x y z -> x+y+z) xs xs xs where xs = ['a'..'z']
06:28:58 <koeien> maybe some clever use of join can also help here
06:30:18 <byorgey> in that case you could just do   liftM sum (replicateM 3 ['a'..'z'])
06:30:33 <byorgey> of course, adding Chars doesn't make sense
06:30:41 <ion> instance Num Char where … ;-)
06:30:45 <byorgey> =)
06:31:07 <asda8_> byorgey: thanks!
06:31:30 <byorgey> Next time I write a program to do simple substitution of caesar ciphers or whatever I'll make a Num instance for Char =)
06:31:45 <ion> You still might want to say what the you want instead of “...” to get an accurate answer instead of guesswork.
06:31:54 <koeien> just map to Z/26Z :)
06:32:20 <nand`> What's the “easiest” way to do graphics development in Haskell? I'm currently looking at SDL, but getting the project to run is such a huge crutch and I can't simply build it either, I need to use a cabal project just so I can add the extra dependencies
06:32:27 <asda8_> ion: in this case just x:y:z:[]
06:32:33 <nand`> I'm wondering if there's any simpler solution
06:32:49 <koeien> then replicateM 3 ['a'..'z'] is what you want.
06:32:56 <byorgey> nand`: it depends exactly what sotr of graphics development you want to do.  Can you be more specific?
06:32:57 <ion> nand: cabal is really quite easy and convenient. I recommend learning to write .cabal files.
06:33:41 <nand`> byorgey: Create a window, display some moving images, play some sound, draw some text, obtain user input like clicks
06:33:42 <nand`> that's about it
06:33:47 <byorgey> 'cabal init' can even help you get started by asking you a few questions and generating an initial .cabal file.
06:33:58 <nand`> I used cabal init
06:34:02 <byorgey> ok.
06:34:11 <asda8_> koeien: thanks
06:34:26 <byorgey> nand`: I'd suggest gloss
06:34:34 <byorgey> nand`: except I'm not sure it does sound
06:34:37 <nand`> but the problem is, cabal doesn't tie into my editor. Normally when writing haskell files I just type Ctrl+B and my project builds+runs; with cabal I have to alt tab and use cabal configure && cabal build && dist\build\foo\foo.exe
06:34:59 <ion> Configure your editor to run cabal build. That’s what i do.
06:35:02 <koeien> you can't rebind a command?
06:35:21 <koeien> nm <C-b> !cabal build -- or something ike this
06:35:32 <hpc> nand`: add it to a makefile
06:35:44 <hpc> all:
06:35:51 <hpc> ^Icabal configure && ...
06:37:15 <hpc> then you can at least tab out and only type "make"
06:39:55 <nand`> come to think of it I'll just create a new build system for cabal files
06:40:01 <nand`> didn't know my editor could do that
06:40:10 <hpc> that works
06:40:24 <erus`> dmwit: i assume i have to start with some types built in (excluding function, sum and product) ?
06:40:26 <hpc> what is your editor, btw?
06:40:44 <nand`> hpc: Sublime Text 2
06:41:27 <quicksilver> when your editor doesn't support rebinding keys it's surely time to get a new editor.
06:41:28 <dmwit> erus`: The context of the question isn't clear, but most languages come with some base types, yes.
06:41:35 <erus`> I can't, for example, make a bool type out of those blocks
06:41:42 <koeien> data Bool = True | False
06:41:56 <quicksilver> you only need one base, erus`, technically.
06:41:57 <dmwit> erus`: If you have sum, product, and fixed-point combinators, the () base type is probably enough to get "everything".
06:42:09 <dmwit> Where I put "everything" in quotes because fuck efficiency, right?
06:42:23 <hpaste_> “Ertugrul Söylemez” pasted “Makefile for Cabal projects” at http://hpaste.org/56730
06:42:37 <mm_freak> hpc, nand`:  that's the Makefile i use
06:42:56 <mm_freak> it makes compiling a lot faster, because it doesn't reconfigure unless necessary
06:43:01 <nand`> quicksilver: rebinding the key would be a bad thing here, since the same key (build) is shared for all other languages. I don't use just haskell or just cabal files, it would break 99% of my projects if I rebound the key completely
06:43:10 <nand`> I could just bind a different key though
06:43:16 <mm_freak> for small changes, "cabal configure" usually takes more time than "cabal build"
06:43:18 <nand`> but why bother when the build system does it much better
06:44:20 <donri> what is the key bound to?
06:44:22 <quicksilver> nand`: well, a reasonable editor allows keys to behave differently depending what language is being edited.
06:44:22 <quicksilver> clearly your editor supports that via its build system, so that's fine
06:44:22 <quicksilver> I'm just saying it would be pretty dire if it didn't.
06:45:25 <nand`> quicksilver: I know about 0.05% of what Sublime Text 2 can do; there's a very high probability that it can do that (bind keys based on language)
06:45:50 <Veinor> is sublime text 2 any good?
06:46:13 <nand`> Veinor: it's the best editor for code I've ever used, if that says anything
06:46:16 <Veinor> ... oh, you can't remote-edit?
06:46:20 <Veinor> ew, no thanks then
06:46:49 <jeank> try vim
06:46:51 <byorgey> nand`: that depends.  what other editors for code have you used?
06:46:53 <nand`> (I've only really used Visual Studio, Notepad++, nano, gvim and emacs though)
06:47:08 <Veinor> also that reminds me, i need to work on my haskell-mode thing for nice imports
06:47:30 <koeien> vim/emacs are the best editors for haskell IME
06:47:41 <koeien> especially emacs
06:47:43 <nand`> I've never used either for haskell
06:47:44 <luite> Veinor: you could use fuse with sshfs or similar
06:48:18 <Veinor> i heard macfuse sucks
06:48:53 <Veinor> (i mean, the flipside of this is that i've had horrible experiences with emacs's tramp mode taking like 3 seconds to save on a vm on the same machine)
06:49:19 <luite> Veinor: hmm, fuse4x works fine here
06:49:28 <byorgey> sublime text 2 looks like it could be nice, but at $59 for a license it's approximately $59 more expensive than what I'm willing to pay for an editor
06:49:39 <nand`> byorgey: it's effectively freeware
06:49:46 <nand`> the free trial is unlimited, all it does is ask you to buy it
06:49:54 <luite> Veinor: this is a fork of macfuse, you can install it with macports
06:49:54 <Veinor> s/59/49/ for me
06:49:55 <ocharles> tbh, seeing as you spend the majority of your career in a text editor, it makes sense to have a good one
06:50:02 <ocharles> so I'm not too bothered about paying if that's what it takes
06:50:05 <koeien> vim asks you to donate to Uganda.
06:50:13 <Veinor> ocharles: i mean, is it $59 better than vim/emacs
06:50:29 <nand`> Veinor: you can't compare the three
06:50:44 <nand`> they're completely different editors with completely different philosophies made for completely different users
06:50:45 <ocharles> Veinor: only you can determine that
06:50:54 <ocharles> Veinor: you might put more or less value on $59
06:50:58 <jeank> well, you can just say if vim or emacs is good after a good time training and programming at them
06:51:08 <jeank> since the learning curve is not short...
06:51:16 <Veinor> i think i'm going to stick with emacs
06:51:22 <nand`> the reason I don't use vim is because I don't want to spend more time figuring out how to use my editor than I spend time actually programming
06:51:24 <Veinor> if only because it's what i'm used to
06:51:42 <koeien> nand`: i learned it years ago, not going back. but i understand your point.
06:51:46 <nand`> note: sublime text 2 comes with a vim emulation mode
06:51:55 <mm_freak> nand`: the usual argument (to which i agree) is that the learning pays off
06:52:13 <koeien> nand`: so does emacs :) which makes it bearable
06:52:22 <jeank> well, in this case I agree with ocharles, since you are going to program most of your time, learning a toll very well seems reasonable...
06:52:28 <jeank> even if it takes some time
06:52:36 <nand`> mm_freak: I just don't see the point. I'm not bottlenecked by my editor, I'm bottlenecked by my ability to program
06:52:42 <nand`> writing down code isn't the hard part
06:52:54 <quicksilver> emacs is actually more discoverable than most of the shiny new editors
06:53:15 <quicksilver> shiny new editors seldom have every single operation factored through named commands, with each named command having documentation
06:53:21 <mm_freak> nand`: well, people often say that…  but when people watch me use emacs, they get that point =)
06:53:41 <koeien> mm_freak: yeah some people are easily impressed ;)
06:53:44 <nand`> quicksilver: ST2 has this, it also has a command line with autocompletion and fuzzy/partial matching, even description searching :)
06:54:21 <jeank> anyway this is what motivated me to learn vim, since this guy is an expert in vim he seems very productive: http://www.derekwyatt.org/vim/vim-tutorial-videos/
06:54:23 <mm_freak> editors like emacs and vim have some fundamental differences, but also some details that matter
06:54:36 <mm_freak> for example in almost any other editor i miss emacs' rectangle editing facility
06:54:40 <nand`> and a really handy “goto” feature, I hit Ctrl + p and begin typing the name of anything (function, type class, data definition etc) and it tkes me there
06:54:41 <koeien> CTRL+V
06:55:21 <koeien> mm_freak: that is a life-saving feature some times
06:55:30 <nand`> personally, the most important feature about an editor is how well its autocompletion works
06:55:47 <nand`> programming without it is like programming blindfolded to me
06:55:49 <CoconutCrab> that is the job of an IDE, not an editor
06:55:54 <mm_freak> nand`: both emacs and vim excel at this
06:55:58 <CoconutCrab> just my opinion
06:56:04 <koeien> mm_freak: however i was unimpressed by macros in emacs :(
06:56:09 <nand`> mm_freak: I've heard, it's the reason I stopped using Notepad++ anyhow
06:56:16 <mm_freak> koeien: really?  why?
06:56:26 <koeien> not so easy as in vim with q and @
06:56:47 <koeien> but i use evil, so best of both worlds now
06:56:50 <mm_freak> koeien: i don't know the macro facility in vim, but i quite like the one in emacs
06:57:11 <nand`> CoconutCrab: I think the distinction is fuzzy. If my editor can automatically invoke my compiler, auto complete, syntax highlight and/or manage project files; does that make it an IDE?
06:57:17 <mm_freak> F3, start typing, C-e e e e e (repeat five times)
06:57:17 <mm_freak> done
06:57:21 <nand`> since by that logic, editors like vim or emacs would be IDEs as well
06:57:26 <jeank> in vim you have to enter the Visual Block Mode
06:57:58 <koeien> mm_freak: that's pretty similar yeah
06:58:00 <mm_freak> nand`: sort of…  in emacs for example you have inferior-haskell, which is not just compilation, but it integrates the entire interpreter
06:58:23 <jeank> they could be, since they are so extensible, you can implement almost anything
06:58:30 <nand`> mm_freak: like highlighting syntax errors as you type them?
06:58:40 <jeank> yeah
06:58:41 <daimrod> flymake can do it.
06:58:53 <mm_freak> nand`: not sure, i'm not using it…  but for example it can infer types on the fly
06:58:59 <nand`> neat
06:59:00 <jeank> but like eclipse, it depends on community
06:59:16 <nand`> makes me want to try out emacs again
07:00:12 <mm_freak> nand`: i think the best example of how powerful emacs can be is the agda mode for emacs
07:00:31 <nand`> mm_freak: elaborate?
07:00:34 <mm_freak> or AUCTeX
07:00:48 <mm_freak> nand`: it's basically inferior-haskell on steroids =)
07:01:02 <mm_freak> nand`: for example it has this neat 'holes' feature
07:01:34 <mm_freak> x = ?, now emacs turns that "?" into a hole and you can infer the type of the expression that has to go there and in some cases even the value
07:01:58 <mm_freak> sometimes i miss that feature in haskell, but you can't really have it there
07:02:10 <russruss> yeah, it's pretty great.  there's also a command that puts in patterns for all the constructors of a current argument
07:03:25 <mm_freak> basically agda-mode thinks for you…  it justifies agda being called a proof "assistant" =)
07:03:29 <Veinor> mm_freak: what about using implicits?
07:03:36 <Veinor> @t map ?f [1,2,3]
07:03:37 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:03:40 <Veinor> @type map ?f [1,2,3]
07:03:41 <lambdabot> forall a b. (?f::a -> b, Num a) => [b]
07:03:51 <mm_freak> Veinor: that's not the same thing
07:05:12 <Veinor> how so?
07:06:10 <mm_freak> Veinor: in agda when you write "xs :: {A : Set} -> Vec A zero" and "xs = ?", agda-mode can infer that 'xs' must be the empty list
07:06:29 <koeien> ow often does that occur, then?
07:06:33 <nand`> byorgey: thanks for the suggestion (gloss), it works brilliantly
07:06:40 <mm_freak> it's a simple example, but it can get arbitrarily complicated as long as agda can infer the value for you
07:06:42 <Veinor> ah
07:06:59 <Veinor> (i don't know enough agda to know exactly what that means, but that sounds reasonable)
07:06:59 <byorgey> nand`: great!
07:07:10 <nand`> seems to be based on OpenGL, maybe I can work with OpenGL directly - it seems to work right out of the box unlike SDL which had me compiling and tweaking for hours to get a hello world running, and even then only if I copied the .dlls to the output folder (it ignores PATH)
07:07:15 <Veinor> i guess what i'd like is a thing for haskell mode to say 'give me the type of what i need here'
07:07:24 <mm_freak> Veinor: Vec is a dependent type for lists of certain lengths
07:08:02 <nand`> what I want is a keybind to automatically run @pointless on my functions
07:08:03 * nand` hides
07:08:13 <Veinor> but everything you write is already pointless
07:08:15 <mm_freak> nand`: gloss is great for tests and simple visualizations, but i'd also have a look at brent's diagrams package
07:08:15 <Veinor> ICE BURN
07:08:20 <erus`> @hoogle Bool -> (a -> c) -> (b -> c) -> c
07:08:20 <lambdabot> Data.Generics.Aliases extQ :: (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q
07:08:20 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
07:08:20 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
07:08:52 <mm_freak> Veinor: you can have that in haskell, but only for top-level definitions…  haskell-mode doesn't have holes
07:08:54 <Veinor> erus`: i don't think that can be realized
07:09:01 <erus`> bool :: Bool -> (a -> c) -> (b -> c) -> c     should be a prelude function
07:09:11 <Veinor> what would it do?
07:09:15 <erus`> like maybe and either
07:09:17 <koeien> erus`: do you mean something like either?
07:09:21 <hpc> erus`: i think i would rather have (??)
07:09:25 <koeien> erus`: ah, but what would it do?
07:09:30 <Veinor> mm_freak: yeah, that's my big problem with where clauses
07:09:35 <koeien> @djinn Bool -> (a -> c) -> (b -> c) -> c
07:09:35 <lambdabot> -- f cannot be realized.
07:09:36 <Veinor> you can't play around with the stuff that's inside them
07:09:53 <koeien> erus`: such a function does not exist
07:09:55 <erus`> bool :: Bool -> a -> a -> a    i mean
07:09:59 <koeien> if'
07:10:00 <hpc> erus`: if'
07:10:23 <PDani> hi
07:10:37 <koeien> but there is a fairly good argument that it should be a -> a -> Bool -> a
07:11:12 <Veinor> @type let f g = map g ?x in f (+1)
07:11:13 <lambdabot> forall a. (?x::[a], Num a) => [a]
07:11:34 <BlankVer1e> how good would the experience of writing a c++ compiler in haskell be?
07:11:45 <quicksilver> better than writing it in any other language
07:11:47 <BlankVer1e> its in a standard CS compilers course project
07:11:48 <koeien> painful
07:11:50 <hpc> haha
07:11:53 <koeien> really????
07:11:55 <quicksilver> it would still drive you insane and possibly kill you
07:11:57 <koeien> C++ grammar is horrible
07:12:01 <bartavelle> indeed
07:12:08 <BlankVer1e> so not all features are to be implemented
07:12:10 <Veinor> so i guess you could introduce holes as implicit variables, find the type signature, and then spit it back out
07:12:23 <bartavelle> you just can't implement all c++ features in finite time
07:12:30 <bartavelle> I'm pretty sure it is proved
07:12:40 <BlankVer1e> I mean very small subset is required
07:12:51 <quicksilver> I think haskell is great for writing compilers
07:12:55 <nand`> did anybody just get confused between bartavelle and BlankVer1e
07:12:55 <quicksilver> a small subset of C++ should be fine
07:12:59 <koeien> ok, a small C++-subset, haskell is probably very well suited for it
07:13:06 <BlankVer1e> any pointers to how t go abt writing a compiler in haskell?
07:13:08 <Veinor> nand`: they eve have the same color on my irc client
07:13:25 <Veinor> http://i.imgur.com/Bp7VG.png
07:13:38 <koeien> BlankVer1e: for parsing, use Parsec
07:13:51 <koeien> for the emitting of code that depends on the exact language
07:13:58 <koeien> you can also use Happy + Alex
07:14:09 <BlankVer1e> to mips assembly?
07:14:11 <koeien> (i prefer parser combinators for most things though)
07:14:38 <ibizaman> hi guys, I'm new to haskelle and I have a hard time choosing the right data type, see here : http://pastebin.com/xuzpHq91
07:14:40 <mauke> The paste xuzpHq91 has been copied to http://hpaste.org/56731
07:15:07 <BlankVer1e> its not source to source ... i need to translate to machine code
07:15:14 <koeien> sure
07:15:24 <koeien> that will probably be explained in the course
07:15:45 <koeien> you will have an ADT for the AST (syntax tree)
07:15:54 <ibizaman> I'd like a tree structure, but the branch should have some properties that the leaf has not, how can I generalise this?
07:15:55 <koeien> and you compile the syntax tree to assembly code
07:16:06 <koeien> it's not extremely hard, the hard part is emitting efficient code
07:16:08 <BlankVer1e> and for lexical analysis?
07:16:11 <hpaste_> PDani pasted “binary loader” at http://hpaste.org/56732
07:16:33 <koeien> ibizaman: for generalization, Tree a b = Leaf b | Branch a (Tree a b)
07:16:39 <BlankVer1e> and I guess it will be less buggy than writing in python?
07:16:48 <BlankVer1e> efficiency is not a major concern btw
07:16:49 <koeien> BlankVer1e: IME, yes.
07:17:16 <ibizaman> koeien: thanks, I'll try that
07:17:22 <BlankVer1e> what tools resemble lex/yacc in haskell?
07:17:29 <PDani> i wrote this code for loading a 100MB binary file which contains 32bit words. when i try to run it with ./Parser +RTS -K200M -M200M, it complains about heap overflow
07:17:30 <TheLemonMan> do both of the >>= params belong to the same monad ?
07:17:32 <BlankVer1e> parsec?
07:17:33 <koeien> BlankVer1e: Haskell has Alex and Happy for this
07:17:37 <hpc> BlankVer1e: happy/alex
07:17:41 <quicksilver> but you don't have to use happy and alex
07:17:42 <koeien> BlankVer1e: Parsec is another approach really
07:17:50 <quicksilver> I prefer using parser combinators directly to parser generators
07:17:57 <koeien> I agree with quicksilver
07:18:01 <hpc> ^
07:18:04 <quicksilver> although, typically, happy/alex will be fast if you need to parse very large files quickly
07:18:10 <quicksilver> which is, I assume, why GHC uses them itself
07:18:16 <quicksilver> s/fast/faster/
07:18:16 <bartavelle> your course will probably be about lex/yacc like tools however
07:18:38 <BlankVer1e> quicksilver: Parsec is a parser combinator and alex/happy is parser generator
07:18:45 <koeien> my compiler course did mostly recursive descent
07:18:50 <quicksilver> I know?
07:18:52 <PDani> any idea?
07:18:58 <ibizaman> koeien: did you meant Tree a b = Leaf b | Branch a [Tree a b] or was using a tuple intentional ?
07:19:03 <BlankVer1e> quicksilver: asking if it is..
07:19:22 <BlankVer1e> quicksilver: whats a parser combinator?
07:19:41 <koeien> ibizaman: I did not use a tuple, but I was wrong, yes. I meant your defintion
07:19:46 <ibizaman> ok
07:19:51 <hpc> what you wrote was a kind of list :P
07:20:09 <koeien> TheLemonMan: yes, but your statement is not 100% accurate
07:20:10 <quicksilver> BlankVer1e: parser combinators let you work directly with parsers as a value in the language
07:20:15 <quicksilver> more flexible/compositional
07:20:22 <koeien> TheLemonMan: the second argument is a function returning a value, which belongs to the same monad
07:20:30 <quicksilver> parser generators are preprocessing tools you run over a grammar file
07:20:32 <BlankVer1e> quicksilver: means you can "combine" parsers?
07:20:34 <quicksilver> which generate code for you
07:20:36 <quicksilver> yes.
07:20:40 <koeien> BlankVer1e: that's right, for example
07:20:52 <Veinor> PDani: not offhand, but it might help if you pasted your code
07:20:54 <quicksilver> so you can write the parser for artihmetic expressions separately from the parser for data declarations
07:20:54 <koeien> if t is a parser, (many t) is a parser
07:20:57 <quicksilver> and then combine them
07:21:07 <quicksilver> but you can test them separately
07:21:07 <PDani> Veinor: <hpaste_> PDani pasted binary loader at http://hpaste.org/56732
07:21:07 <koeien> many t runs t zero or more times, collecting its results
07:21:17 <Veinor> ah, didn't see that
07:21:50 <koeien> the interesting thing is that t and many are ordinary Haskell values
07:21:53 <BlankVer1e> and how easy are happy/alex in case we are required to use a generator instead?
07:22:19 <koeien> not harder or easier than lex/yacc
07:22:36 <koeien> (probably less documentation)
07:22:48 <koeien> but it should still be fine
07:22:51 <Veinor> hm, not sure
07:22:59 <Veinor> sorry :/
07:23:17 <koeien> you can read the manual here: http://www.haskell.org/happy/
07:23:35 <void2> hi
07:23:46 <koeien> hi
07:26:16 <TheLemonMan> so if i have an obj from the IO monad and i want to feed the content to Just i have to do something like Just =<< liftIO obj ?
07:26:36 <koeien> Are you using monad transformers?
07:26:48 <koeien> liftM Just  sounds more like what you want
07:26:51 <koeien> :t liftM Just
07:26:52 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (Maybe a1)
07:26:54 <copumpkin> :t (Just =<<)
07:26:54 <lambdabot> forall a. Maybe a -> Maybe a
07:27:01 <copumpkin> that should be id by a monad law
07:27:24 <TheLemonMan> isnt liftIO just a specialized liftM ?
07:27:25 <koeien> return = Just
07:27:29 <koeien> :t liftIO
07:27:30 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
07:27:41 <koeien> no, it's different
07:27:56 <koeien> liftIO lifts IO values to monads "in which IO actions can be run"
07:28:47 <TheLemonMan> wait, arent IO actions done in the IO monad already ?
07:28:51 <koeien> liftM applies any function "inside" a monad
07:29:10 <koeien> TheLemonMan: I could write another monad, for example
07:29:20 <hpc> TheLemonMan: other monads can produce IO actions when "run"
07:29:22 <hpc> :t runSTM
07:29:23 <lambdabot> Not in scope: `runSTM'
07:29:24 <quicksilver> liftIO is lift . lift . lift . lift (for an unknown number of lifts)
07:29:27 <hpc> @hoogle runSTM
07:29:27 <lambdabot> No results found
07:29:28 <quicksilver> it's quite unrelated to liftM
07:29:29 <copumpkin> :t atomically
07:29:30 <lambdabot> Not in scope: `atomically'
07:29:36 <hpc> @hoogle STM a -> IO a
07:29:36 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
07:29:37 <lambdabot> GHC.Conc atomically :: STM a -> IO a
07:29:37 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
07:29:42 <koeien> data MyMonad a = MyIO (IO a) | MyPrint37
07:29:44 <hpc> STM is a MonadIO
07:31:00 <TheLemonMan> hrm, gotcha, all this monad stuff is pretty hard to dive into
07:31:19 <copumpkin> I wouldn't try, honestly :)
07:31:23 <koeien> lift and liftIO are related to monad transformers
07:31:32 <copumpkin> the easiest way to get monads is to not try to get them prematurely :P
07:31:36 <koeien> if you don't know what they are, you don't want to use them yet
07:31:58 <koeien> you can (and should) understand liftM otoh
07:32:42 <PDani> any idea?
07:32:56 <copumpkin> hpc: it is?
07:33:07 <hpc> i think so
07:33:10 <copumpkin> hpc: not cleanly
07:33:19 <copumpkin> @hoogle unsafeIOtoSTM
07:33:19 <lambdabot> GHC.Conc.Sync unsafeIOToSTM :: IO a -> STM a
07:33:19 <lambdabot> GHC.Conc unsafeIOToSTM :: IO a -> STM a
07:33:25 <hpc> ah
07:33:29 <copumpkin> your liftIO could be that
07:33:31 <copumpkin> but you don't want it to be
07:33:40 <koeien> unsafeLiftIO!
07:34:27 <koeien> PDani: how much memory does your system have?
07:34:34 <koeien> PDani: how are you invoking your program?
07:34:37 <PDani> 4GB
07:34:49 <PDani> <PDani> i wrote this code for loading a 100MB binary file which contains 32bit words. when i try to run it with ./Parser +RTS -K200M -M200M, it complains about heap overflow
07:35:23 <koeien> did you compile with -O2 ?
07:35:27 <PDani> yes
07:35:42 <PDani> i tried with -K400M and -M400M, same result
07:36:38 <int-e> PDani: are you using bytestrings?
07:36:52 <koeien> http://hpaste.org/56732
07:36:54 <PDani> i tried to invoke the recursive call inside the Get monad based on isEmpty result, it uses up stack instead of heap iirc
07:37:15 <int-e> oh, nninary. hmm
07:37:19 <int-e> *binary
07:38:40 <PDani> yes
07:38:41 <int-e> and what is the result of the parsing step? what are you doing with the date afterwards?
07:41:11 <PDani> int-e, nothing, i just want it to be loaded into the memory fast, with the lowest memory overhead
07:41:33 <PDani> and i want to access the fields randomly
07:41:53 <Botje> .oO(mmap?)
07:42:05 <PDani> i tried memory map also
07:44:15 <mkscrg> i'm looking for a good hash functions library. what's the community standard for that?
07:44:39 <erus`> dmwit: can i have an a => a -> a    in simply typed lamda calculus?
07:45:05 <slom> mkscrg: that depends on what you want to do with the hash function
07:45:06 <mm_freak> mkscrg: check out the cryptohash library
07:45:36 <copumpkin> erus`: no, because it's polymorphic. Also, I'm not sure what the => means there
07:45:49 <erus`> forall
07:46:02 <mkscrg> slom / mm_freak: i don't need cryptographic security. i'm just doing consistent hashing to distribute messages in a distributed system
07:46:58 <ion> Why must cereal have a single Serialize class with put and get methods? I only want to implement serialization for convenient hashing of certain values and don’t care about deserialization at the moment. :-(
07:46:59 <mm_freak> mkscrg: as long as your performance constraints allow it, i'd still use a cryptographic hash function
07:47:15 <Sgeo> mm_freak, what are the benefits, if any, of AFRP/
07:47:16 <Sgeo> ?
07:47:21 <parcs`> ion: so don't make it an instance of Serialize
07:47:23 <mkscrg> mm_freak: interesting. what's your reasoning there?
07:47:28 <parcs`> make a getFoo :: Get Foo function
07:47:43 <mm_freak> Sgeo: compared to what?
07:47:51 <Sgeo> mm_freak, something like reactive-banana
07:47:53 <sipa> mkscrg: how many bits?
07:47:54 <parcs`> err, putFoo :: Put Foo
07:48:02 <koeien> PDani: you might benefit from -funbox-strict-fields
07:48:08 <mm_freak> Sgeo: internal simplicity and high performance
07:48:24 <Sgeo> "internal" simplicity?
07:48:39 <mm_freak> netwire can well do more than a few million FPS when used in applicative style
07:48:47 <mm_freak> yeah, AFRP is based on the automaton arrow
07:49:04 <mkscrg> sipa: really don't need many, assuming the hash function has good uniformity over the output (i guess that's a good reason to use a crypto hash).
07:49:05 <Sgeo> Is netwire any easier to use than reactive-banana?
07:49:10 <mm_freak> Sgeo: dunno
07:49:37 <mm_freak> probably, but netwire is a pure AFRP library with no application-specific functionality
07:49:44 <mkscrg> for some message, the message goes to worker # (hash message `mod` numberOfWorkers)
07:49:46 <sipa> mkscrg: not haskell; but for non-cryptographic small hashes, i've used lookup3 and lookup8 by bob jenkins before (resp. 32 and 64 bits)
07:49:55 <wyfrn_> am i right that Text.ParserCompinators.ReadP.readP_toS will always result in a list with just one element ?
07:50:00 <ion> parcs: That isn’t perfect either. data Foo = Foo { bars :: [Bar] }, instance Serialize Foo, instance Serialize Bar → put foo uses the predefined put for lists which uses my put for Bar. Unless i’m missing something, i’d need to write my own puts for the lists, maybes etc. i use as well.
07:50:13 <Sgeo> I mean, netwire has everything being a wire, no distinction between behaviors and events, right?
07:50:16 <mm_freak> Sgeo: basically if you know how to use the automaton arrow, you know how to use netwire
07:50:22 <mm_freak> Sgeo: right
07:50:29 * Sgeo hmms
07:50:46 <mm_freak> Sgeo: events are modeled as inhibiting vs. producing wires
07:50:53 <erus`> ah i need system F before i get polymorphism
07:50:55 <Sgeo> reactive-banana has some tools that make it easy to hook into a pre-existing event framework. What of netwire?
07:50:58 <mm_freak> an inhibiting wire corresponds to an unhappened event
07:51:31 <mm_freak> netwire doesn't need such tools, because it has no separate event system…  to hook into an event framework (like SDL) you just write corresponding wires
07:51:53 <parcs`> ion: there exist combinators in Data.Serialize.Put like "putListOf :: Putter a -> Putter [a]", "putMaybeOf :: Putter a -> Putter (Maybe a)"
07:52:00 <sipa> mkscrg: for more than 64 bits, it is hard to get a significant speedup over cryptographic hashes, so those tend to be used also for non-cryptographic-requiring purposes
07:52:05 <Sgeo> What does a "corresponding wire" look like?
07:52:31 <ion> parcs: Oh, i had managed to skip over them when skimming the docs. Thanks!
07:52:39 <mm_freak> Sgeo: depends on the architecture…  either you pass SDL events as signals or you provide them through an underlying reader/state monad
07:52:58 <mm_freak> in the latter case you can have a wire like:  quitEvent :: SdlWire a a
07:52:59 <Sgeo> My use-case isn't SDL
07:53:06 <mm_freak> yeah, but i'm taking SDL as an example
07:53:13 <mkscrg> sipa: right. even 64 bits is overkill for what i'm doing. do you know of any low-bit-count hash function libraries in haskell?
07:53:36 <mm_freak> Sgeo: the basic idea is:  quitEvent is a wire that acts like the identity wire, when a quit event has happened
07:53:43 <mm_freak> otherwise it inhibits
07:54:35 <mm_freak> w2 . quitEvent . w1
07:54:46 <mm_freak> if quitEvent inhibits, the composition inhibits
07:55:00 <mm_freak> otherwise the result is the output of w2 and it gets the output of w1 as input
07:55:13 <Enigmagic> mkscrg: are you concerned about storage size or hash speed?
07:55:27 <mm_freak> to combine events you use Alternative or ArrowZero/ArrowPlus
07:55:46 <mm_freak> quitResult . quitEvent <+> drawResult . drawEvent
07:55:47 * Sgeo is currently mostly thinking in terms of arrow syntax
07:55:57 <mm_freak> you shouldn't =)
07:56:01 <nand`> is there a better way to convert four integrals a' b' c' and d' to Num a => a than: let [a, b, c, d] = map fromIntegral [a', b', c', d']
07:56:03 <Sgeo> :/
07:56:19 <mm_freak> Sgeo: arrow syntax is useful, when you have to distribute signals in a nontrivial way
07:56:19 <Sgeo> I actually _understand_ arrow syntax
07:56:27 <koeien> nand`: no
07:56:33 <mkscrg> Enigmagic: speed. i'm not using the hash for storage, but for message distribution in a cluster of workers
07:56:41 <Sgeo> Not what it desugars into though
07:56:43 <nand`> I use arrows mainly for first, second *** and &&&
07:56:48 <mm_freak> Sgeo: http://www.haskell.org/pipermail/haskell-cafe/2011-December/097493.html
07:57:31 * Sgeo doesn't exactly mind being able to think imperatively
07:58:03 <mm_freak> Sgeo: you can use both styles, but i think the applicative style is nicer
07:58:16 <hpaste_> PetrosGR pasted “zip-archive linking error while building pandoc” at http://hpaste.org/56735
07:58:20 <mm_freak> i think the post gives good examples of that
07:58:24 <petrosgr> Hello!
07:59:32 <BlankVer1e> is there any writing compilers in haskell article ? google doesnt help
07:59:33 <Sgeo> mm_freak, I don't get the banana brackets in arrow syntax thing
07:59:40 <Enigmagic> mkscrg: well there are a couple murmur hash implementations on hackage, they don't look highly optimized though
07:59:49 <petrosgr> I'm trying to build pandoc on GHC 7.2 and while i have fixed the json and citeproc-hs dependencies and everything compiles fine, I get a linking error for zip-archive (i think) at the end. Can anyone give me a hint at what to look for?
07:59:58 <mm_freak> Sgeo: the GHC manual explains them quite well actually
08:00:08 <mm_freak> Sgeo: file:///usr/share/doc/ghc/html/users_guide/arrow-notation.html
08:00:12 <danm__> http://bloggingmath.wordpress.com/2010/01/20/writing-a-compiler-in-haskell-compiler-series-part-i/ <-- this was one of the first results I found in google?
08:00:32 <Enigmagic> mkscrg: that's what i'd use in c++ at least... you could try them out and see if one (or both) are fast enough for your app
08:00:40 <mm_freak> Sgeo: wait lol
08:00:51 <mm_freak> Sgeo: http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
08:00:54 <mm_freak> there you go =)
08:00:55 <Sgeo> mm_freak, which of netwire or reactive-banana would be simpler to understand for someone with no Haskell experience
08:00:57 <Sgeo> ty
08:01:32 <mm_freak> Sgeo: good question…  i don't really know
08:01:40 <mm_freak> netwire is probably not very suitable for haskell beginners
08:01:48 <mm_freak> there is a lot of type stuff going on
08:02:23 <mkscrg> Enigmagic / sipa: it seems like the most optimized hash functions available in Haskell are in cryptohash. maybe i'd do best to use one of those and just chop off the bits i don't want
08:02:37 <mm_freak> Sgeo: actually i write netwire with library authors in mind
08:03:10 <BlankVer1e> what about the machine code generation part in haskell?
08:03:47 <mm_freak> Sgeo: as you can see the Wire type is extremely general…  it's even a data family
08:04:02 <TheLemonMan> do i look like an idiot if i ask why getLine >>= Just wont work ?
08:04:07 <mm_freak> Sgeo: application and library authors would then simply use a constrained variant of that
08:04:12 <Enigmagic> mkscrg: i suspect that even the unoptimized murmurhash will be a fair bit faster than md5 or sha1, but truncating one of those would be fine too
08:04:29 <Sgeo> mm_freak, just to clarify, I'm not saying that I'm the beginner (although I don't understand data families), just that my library would only be of interest to a small community who mostly haven't used Haskell
08:04:31 <mm_freak> TheLemonMan: if you want to wrap the result in a Just, use fmap Just getLine
08:04:40 <koeien> TheLemonMan: just look at the types
08:04:46 <parcs`> TheLemonMan: look at the type of (getLine >>=), now look at the type of Just
08:04:46 <koeien> getLine :: IO String
08:04:52 <Sgeo> TheLemonMan, Just doesn't give a monadic value
08:04:59 <koeien> (>>=) :: IO a -> (a -> IO b) -> IO b
08:05:05 <Sgeo> Well, it does
08:05:07 <Sgeo> But wrong monad
08:05:07 <mkscrg> Enigmagic: good to know. i'll look into both
08:05:25 <koeien> so (getLine >>=) :: (String -> IO b) -> IO b
08:05:30 <Sgeo> You could do getLine >>= return . Just
08:05:34 <koeien> but Just is not of type String -> IO b
08:05:56 <TheLemonMan> aha, so it *has* to return an IO value
08:06:04 <koeien> that's right
08:06:38 <parcs`> TheLemonMan: you can do with mm_freak suggested, 'fmap Just getLine', which is exactly the same as 'getLine >>= return . Just'
08:07:12 <mm_freak> Sgeo: when designing a netwire-based library you first have to think about the concrete representation…  most libraries will look something like this:  type MyWire m = Wire LastException (Kleisli m)
08:07:32 <mm_freak> and often you will also wrap 'm' with an application-specific monad
08:08:07 <mm_freak> for example in an opengl framework:  type GlWire m = Wire LastException (Kleisli (StateT GlState m))
08:08:13 <mm_freak> something like that
08:08:20 <BlankVer1e> koeien: any tips about machine code generation for compiler?
08:08:33 <Sgeo> mm_freak, hmm
08:08:50 <mm_freak> i've also used nondeterministic wires a la:  type MyWire m = Wire LastException (Kleisli (LogicT m))
08:09:05 <koeien> BlankVer1e: not specifically, you can just write your own assembler, that's fairly easy
08:09:30 <BlankVer1e> koeien: like I have no idea at all
08:09:53 <koeien> the hard part is figuring out things like how to convert  (If cond thenPart elsePart) to machine code
08:09:59 <dmwit> class MixNMatch m n where bindCast :: (a -> n b) -> (m a -> n b)
08:10:04 <Sgeo> I think I'm going to go with my original plan of writing event types that are isomorphic to reactive-banana's AddHandler, so no FRP framework _must_ be used
08:10:05 <BlankVer1e> koeien: and its a university course , will using haskell too heavy , no body has tried it in our uni
08:10:06 <koeien> but this will surely be explained in the course
08:10:26 <koeien> that depends on your haskell-fu
08:10:33 <Sgeo> fromHandler could be used for reactive-banana, some function to get a wire out might be used for netwire, etc.
08:10:34 <hpc> koeien: the condition is expressed as either a 0 or a 1
08:10:41 <hpc> koeien: you test it, then jump on the zero flag
08:10:46 <koeien> hpc: (I know that)
08:10:51 <hpc> oh
08:10:52 <hpc> :P
08:10:52 <Sgeo> Although my library may be opinionated and provide things for one of them
08:11:25 <BlankVer1e> koeien: i have basic haskell knowledge , a decent img hosting web app using yesod , and I am doing a project for creating a nosql database from scratch in haskell also
08:12:09 <koeien> then in that case I suspect it's probably one of the better language choices for a compiler
08:12:36 <koeien> (after a Haskell course my classmates said: "yeah, great, you can easily parse and walk trees, but what else is it good for?!")
08:12:54 <koeien> but parsing and walking trees is 90% of the core of a compiler
08:14:00 <Sgeo> Most of the teachers at my school haven't heard of Haskell before me, I think
08:14:10 <Sgeo> Well, one vaguely knew it as the purely functional language, I guess
08:14:56 <hpc> one of my professors did his thesis on indexed monads, using haskell
08:15:18 <hpc> he's currently the youngest professor on campus, and is the sole professor teaching python
08:15:20 <mm_freak> i guess haskell is a language for young people
08:15:22 <hpc> we think it's some kind of a hazing
08:15:52 <mm_freak> old people are much worse at accepting new things, especially when it invalidates things that they take for granted
08:15:58 <koeien> mm_freak: older people in industry tend not to look around so much anymore, perhaps?
08:16:45 <koeien> i had a colleague who was learning Erlang, he was in his 40s
08:17:12 <mm_freak> koeien: most older people can't stand drastic changes
08:17:36 <mm_freak> to old school C programmers haskell is as drastic as a change can get
08:17:39 <rumina1> can I use +, -, /, * in prefix?
08:17:44 <parcs`> > sin pi
08:17:45 <koeien> rumina1: yes, use (+)
08:17:45 <lambdabot>   1.2246467991473532e-16
08:17:46 <mm_freak> rumina1: (+) 3 4
08:18:00 <parcs`> > sin pi :: CReal
08:18:01 <lambdabot>   0.0
08:18:06 * cmccann wonders whether it would make sense to use netwire instead of just messing with automaton arrows directly
08:18:26 <kuznero> Hi All!
08:18:35 <koeien> hello
08:18:38 <mm_freak> cmccann: note that netwire doesn't use the automaton arrow…  it uses a generalization of that
08:18:52 <mm_freak> but otherwise yeah, it's basically the automaton arrow premessed =)
08:19:03 <conal> Is there a semi-standard typeclass that serves as a sort of dual to Monoid in that it has an associative operator but with an annihilator rather than an identity? (for all x, x `op` ann == ann)
08:19:40 <parcs`> conal: MonadPlus?
08:20:14 <mm_freak> parcs`: no, MonadPlus' mzero is identity
08:20:30 <conal> and i'm going for kind *, rather than kind * -> *
08:20:32 <cmccann> mm_freak, netwire is generalized far beyond what I'm actually using the automaton arrows for, which is why I'm wondering if learning how to use it would save me time or not
08:20:42 <parcs`> > mzero `mplus` return ()
08:20:43 <lambdabot>   No instance for (GHC.Show.Show (m ()))
08:20:43 <lambdabot>    arising from a use of `M342760821...
08:20:53 <parcs`> > (mzero `mplus` return ()) :: Maybe ()
08:20:54 <lambdabot>   Just ()
08:21:15 <parcs`> oops
08:21:16 <mm_freak> cmccann: netwire has quite a learning curve, but once you learned it it will definitely save you time…  i've spend months of effort
08:21:32 <koeien> conal: i'm not even aware of a name for "semigroup with a zero" in mathematics
08:21:50 <mm_freak> cmccann: but it's not that generalized…  it's really just this:  newtype Wire e (>~) a b = Wire (a >~ (Either e b, Wire e (>~) a b))
08:21:52 <conal> my application is for pattern matching, where I want to use a lub to combine substitutions, yielding top on a conflict.
08:22:00 <mm_freak> cmccann: so the difference to the automaton arrow is that Either there
08:22:19 <conal> non-linear pattern matching, i.e., allowing more than one occurrence of a given pattern variable.
08:22:25 <mm_freak> cmccann: the data family part is really just for efficiency…  it easily makes netwire faster by a factor of 100
08:24:16 <inteq> is there any chance that there is a wkilled windows dev in the channel who is decent with python? my company is hiring and i know this group is skilled.
08:24:17 <parcs`> mm_freak: as opposed to what design?
08:24:22 <inteq> skilled*
08:24:45 <koeien> inteq: you should probably mention your location
08:24:47 <mm_freak> parcs`: as opposed to a concretely defined type
08:25:16 <mm_freak> parcs`: netwire 2 used to have a concrete Wire type, which lead to performance problems making it even slower than yampa
08:25:31 <inteq> koeien: sorry. we are in marietta, ga
08:25:42 <rumina1> (+) works, but how can I get it to use more than two arguments?
08:25:56 <hpc> :t sum
08:25:56 <koeien> rumina1: you don't :) use sum
08:25:57 <lambdabot> forall a. (Num a) => [a] -> a
08:26:00 <mm_freak> rumina1: you can't…  that doesn't make sense in haskell
08:26:01 <koeien> > sum [1,2,3,4]
08:26:02 <lambdabot>   10
08:26:04 <mm_freak> rumina1: but you can sum a list
08:27:42 <BlankVer1e> koeien: I got the frontend part figured out how to do in haskell , but for backend I am not not sure , what about http://bloggingmath.wordpress.com/2010/08/13/the-basics-of-llvm-compiler-series-part-x/
08:27:47 <BlankVer1e> llvm for backend?
08:27:57 <koeien> that's probably far too complicated for your purposes
08:28:00 <cmccann> mm_freak, hm, maybe I will try netwire at some point, if nothing else it'll save me reimplementing some of your prefab wires
08:28:02 <parcs`> mm_freak: why is that? you're just definining a concrete type "data instance Wire e (Kleisli m) a b where ..." anyway
08:28:18 <BlankVer1e> koeien: i heard that we need to target mips instruction set
08:28:21 <mm_freak> koeien: ?
08:28:50 <BlankVer1e> SPIM to run the machine code i guess
08:29:05 <koeien> mm_freak: learning how to emit llvm is probably not easier than how to emit MIPS asm
08:29:19 <koeien> but i could be wrong about that
08:29:22 <mm_freak> parcs`: with the concrete type you have the Kleisli wrapping everywhere and need to use tuples everywhere…  also many of the monadic classes don't exist for arrows and reinventions of them are slower than the corresponding monad stuff
08:29:23 <BlankVer1e> is the code generation usually done manually
08:29:40 <BlankVer1e> mapping the AST to mips instruction set?
08:29:44 <koeien> BlankVer1e: it's not that hard to do
08:29:49 <mm_freak> parcs`: with a data family i can say:  data instance Wire e (Kleisli m) a b = Wire (a -> m (Either e b, Wire e (Kleisli m) a b)))
08:30:05 <mm_freak> koeien: are you sure you wanted to address me? =)
08:30:16 <koeien> mm_freak: you said '?'
08:30:36 <mm_freak> koeien: oh, sorry…  that was a mistake
08:30:42 <koeien> :)
08:30:57 <Enigmagic> koeien: learning llvm is almost definitely easier than emitting mips asm
08:31:13 <koeien> in that case it depends on the course requiremetns.
08:31:27 <mm_freak> parcs`: imagine having to write all monadic computations using the Kleisli arrow
08:31:32 <mm_freak> it's not nice and very slow =)
08:31:50 <ion> @tell edwardk The newDupableSupply calls and the SPECIALIZE entries for newDupableEnumSupply, newDupableNumSupply seem to lack “Dupable”. http://hackage.haskell.org/packages/archive/streams/0.8.1/doc/html/src/Data-Stream-Supply.html
08:31:50 <lambdabot> Consider it noted.
08:43:34 <gwern> @pl foo f = unlines $ concat $ intersperse [""] (chunkFiles $ lines f)
08:43:34 <lambdabot> foo = unlines . join . intersperse [[]] . chunkFiles . lines
08:48:12 <chridi> hi
08:48:30 <chridi> how could i find out, in which line a exception was thrown?
08:50:20 <chridi> the function name would also be great to know ;)
08:52:01 <anandjeyahar> how do i build the ghc compiler from source?? am tired of running into version incompatibilities while installing via cabal
08:54:24 <monochrom> anandjeyahar: I'm pretty sure building GHC yourself will not solve cabal problems. rather, my http://www.vex.net/~trebla/haskell/sicp.xhtml is more to the point. generally, cabal problems are because you have too many packages, not too few.
08:55:40 <anandjeyahar> monochrom: perhaps... haskell anyway is my new toy.. and cabal issues are coming in the way..:-)
08:55:48 <sm> +1, and if you prefer to spend more time building in exchange for less learning about cabal, use virthualenv to install
08:56:24 <anandjeyahar> or rather cabal complaining about dependencies and their version limits..
08:57:00 <anandjeyahar> sm: virtualenv for haskell?? let me look that up.. am used to the python version...
08:57:02 <sm> http://hackage.haskell.org/package/virthualenv
08:57:03 <davv3_> anandjeyahar: platform? distro?
08:57:15 <anandjeyahar> ubuntu 11.10
08:57:26 <danr> Is Osaki's book on purely functional data structures available for download somewhere?
08:57:29 <anandjeyahar> don't ask... bad idea to upgrade....
08:58:19 <sm> a third option is to clear out your packages once in a while, https://gist.github.com/1185421
08:58:30 <anandjeyahar> sm:Cool i missed the extra h  the first time...
09:02:24 <chridi> when I do a :history in ghci, the first line shows the location, where the exception was thrown?
09:06:50 <nand`> Graphics.UI.GLUT.Callbacks.Window.closeCallback throws an error when run: first.hs: user error (unknown GLUT entry glutCloseFunc)
09:07:20 <nand`> Does anybody know how to fix it? I found a japanese website that seems to note the issue: http://snak.tdiary.net/20091211.html
09:08:12 <nand`> apparently he solved it only be rebuilding the source
09:19:41 <erus`> @pl \x -> if x then c else d
09:19:42 <lambdabot> flip (flip if' c) d
09:22:02 <hpaste_> kuznero pasted “How to simplify into oneliner?” at http://hpaste.org/56736
09:22:27 <kuznero> Gents, could anybody suggest the way?
09:22:30 <wjt> @type liftM
09:22:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:23:24 <wjt> kuznero: there's your way ^ :)
09:23:31 <kuznero> wjt: normal `>>= \bs -> return $ filter (/= smt)` isn't gonna work, right?
09:23:31 <kuznero> :)
09:23:57 <rwbarton> Almost (you're missing a bit), but liftM will be nicer.
09:24:20 <kuznero> rwbarton: could you please say what is it that I'm missing...?
09:24:26 <hpaste_> wjt annotated “How to simplify into oneliner?” with “How to simplify into oneliner? (annotation)” at http://hpaste.org/56736#a56737
09:24:28 <donri> in ghci with :set +m, how do you set the "continued" prompt?
09:24:34 <ChristianS> parseBlocks = manyTill block eof >>= filter (/= Null)   ?
09:24:43 <rwbarton> >>= \bs -> return $ filter (/= smt) bs
09:25:27 <kuznero> rwbarton: I tried that - does not seem to be working
09:25:44 <wjt> kuznero: see my annotation :)
09:26:06 <rwbarton> @undo do { bs <- manyTill block eof; return $ filter (/= Null) bs }
09:26:06 <lambdabot> manyTill block eof >>= \ bs -> return $ filter (/= Null) bs
09:26:10 <kuznero> wjt: thanks! will definitely use that one
09:26:32 <wjt> kuznero: <$> from Control.Applicative is a nice (almost-)synonym
09:27:53 <kuznero> Ha! Nice... works both ways! Thanks, gents :)
09:28:32 <Rusky> haskell's readline package is having trouble loading ncurses since /usr/lib/ncurses.so has "INPUT(-lncursesw)"
09:28:39 <Rusky> anybody seen that before?
09:30:15 <parcs`> Rusky: yes. go to ~/.ghc/*/package.conf.d and edit the 'extra-libraries' field in the readline package config and do ghc-pkg recache
09:30:33 <parcs`> ghc-pkg --user recache
09:30:56 <Rusky> ah, thanks
09:36:54 <shergill> haskell newbie here. how do you register a package with ghc-pkg? executing 'cabal install package.cabal' doesn't do the trick (even though it builds and compiles the binary). and running 'ghc-pkg register package.cabal' produces a 'missing id field' error
09:36:56 <Rusky> parcs`: cabal-dev or something it's calling isn't picking up the change, somehow
09:37:12 <shergill> could someone tell me what i am doing wrong?
09:37:41 <shergill> or point me in the right direction wrt man pages/documentation
09:39:55 <Rusky> shergill: don't take my word for it but you usually "cabal install" from within the package directory, without passing the .cabal file; I don't know if that's what you're trying to do though
09:40:58 <parcs`> Rusky: are you using cabal-dev ghci?
09:41:03 <shergill> Rusky: sorry my bad. that's the command i was running. running 'ghc-pkg list | grep package' still doesn't show the package though
09:41:20 <Rusky> parcs`: cabal-dev lambdabot
09:41:34 <Rusky> cabal-dev install lambdabot rather
09:41:51 <Rusky> I think it may work now, the sandbox had its own readline install
09:43:44 <zzo38> Can you add Program: namespace to Haskell wiki, that Haskell programs can be written? And then add a link on those pages in that namespace, that you download the raw file but with .lhs extension. An example of what might be done is on esolang wiki: http://esolangs.org/wiki/Pure_BF/Implementation
09:54:50 <joevandyk> Is there anything like https://www.relishapp.com/myronmarston/vcr for haskell?  (vcr is a testing library for ruby that "records your test suite's HTTP interactions and replay them during future test runs for fast, deterministic, accurate tests."
10:05:59 <maurer> Anyone know if it's possible to write LLVM passes in haskell at the moment?
10:06:33 <Veinor> i wonder if it's possible to write a heredoc in haskell using TH
10:06:50 <Veinor> oh nice you can
10:10:04 <MasterBrony> Veinor: you coming to the hackathon?
10:10:20 <Veinor> ...
10:10:26 <Veinor> why did you change your username?
10:10:33 <MasterBrony> cause I'm a master brony
10:10:34 <MasterBrony> why else
10:10:43 <Veinor> : |
10:10:51 <elliott> his logic is sound
10:10:53 <MostAwesomeDude> I bet he's trolling in another channel.
10:10:54 <shergill> heh
10:10:57 <shachaf> MasterBrony: I'm already at the hackathon.
10:11:07 <MostAwesomeDude> MasterBrony: Who's your favorite pony?
10:11:08 <Veinor> also yeah
10:11:23 <elliott> shachaf: I *am* the hackathon.
10:11:55 <shachaf> elliott: We miss you in that other channel...
10:12:13 <shachaf> (I think. I don't actually know because why would I watch that channel without you?)
10:13:18 <MasterBrony> MostAwesomeDude: the littlest of them all
10:14:46 <esap> This is strange function: \f x -> f >>= \v -> v x
10:15:04 <Veinor> @type \f x -> f >>= \v -> v x
10:15:05 <lambdabot> forall t (m :: * -> *) b. (Monad m) => m (t -> m b) -> t -> m b
10:15:14 <Veinor> @pl \f x -> f >>= \v -> v x
10:15:14 <lambdabot> (. flip id) . (>>=)
10:15:17 <elliott> esap: \f x -> f >>= ($ x)
10:15:20 <elliott> not that weird
10:15:25 <gwern> > 37.63754920 * 6.45
10:15:26 <lambdabot>   242.76219234
10:16:14 <parcs`> :t \f x -> join (f <*> pure x)
10:16:15 <lambdabot> forall (m :: * -> *) a a1. (Applicative m, Monad m) => m (a -> m a1) -> a -> m a1
10:16:30 <ion> @type \f x -> do a <- f; a x
10:16:31 <lambdabot> forall t (m :: * -> *) b. (Monad m) => m (t -> m b) -> t -> m b
10:16:50 <esap> elliott: from the type, you could think it removes one "m", but it works for arbitrary monad :-)
10:17:47 <ion> esap: You could say so, yeah.
10:17:52 <cmccann> join removes one "m" as well :P
10:17:55 <parcs`> it's like a more specific version of join
10:18:06 <esap> cmccann: good point.
10:18:14 <elliott> So does unsafeCoerce!
10:18:20 <ion> elliott: good point.
10:18:45 <cmccann> unsafeCoerce is such a versatile function
10:18:52 <esap> I didn't think there was a specific 'a' to go from IO a -> a, but this proves that idea wrong :-)
10:18:54 <elliott> @quote isJust.*unsafeCoerce
10:18:54 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
10:19:08 <cmccann> haha
10:19:08 <ion> esap: join goes from IO (IO a) to IO a.
10:19:12 * cmccann was just about to look for that
10:19:14 <elliott> cmccann: (that actually works)
10:19:18 <esap> ion: right
10:19:18 <elliott> oh, you've seen it
10:19:33 <elliott> unfortunately, only for types with <=4 constructors, iirc :(
10:19:37 <shachaf> isTrue :: Bool -> Bool; isTrue = unsafeCoerce
10:19:40 <elliott> we need an unsaferCoerce
10:20:05 <elliott> Will the new kind-lifting stuff be able to lift unsafeCoerce?
10:20:11 <elliott> I want to unsafeCoerce# Maybe :: *.
10:20:21 <ion> @remember shachaf isTrue :: Bool -> Bool; isTrue = unsafeCoerce
10:20:22 <lambdabot> Nice!
10:20:29 <Veinor> you know that bug a dev version of ghc had where if your program didn't typecheck it deleted your source file?
10:20:39 <Veinor> that's unsaferCoerce
10:20:41 <elliott> haha
10:20:55 <elliott> I really don't want to know what unsafestCoerce does
10:21:11 <Veinor> same except it uses a kernel exploit to root your box and then does rm -rf /
10:21:40 <ion> “If your program didn’t typecheck it deleted your source file” a.k.a. the extreme programming methodology.
10:21:45 <cmccann> elliott: unsaferCoerce :: a -> b, unsaferCoerce _ = error "NOPE" -- guaranteed to never be safe
10:22:08 <shachaf> cmccann: I think printing an error is pretty safe as far as results from an unsafeCoerce-like function go.
10:22:08 <ion> cmccann: unsaferCoerce (error "NOPE")
10:22:12 <Veinor> ion: motivation to write modular code!
10:22:22 <Veinor> that way fewer LOC get lost
10:22:39 <cmccann> shachaf, true, it really should create an error that can't be easily caught
10:22:45 <c_wraith> like, say...
10:22:51 <cmccann> just so long as it always crashes the program no matter what
10:22:57 <c_wraith> unsaferCoerce _ = unsafeCoerce () ()
10:23:12 <c_wraith> segfaults are hard to catch
10:23:16 <cmccann> c_wraith, ooh, I like that
10:23:31 <elliott> That's not enough!
10:23:34 <elliott> You could run your program under gdb.
10:23:34 <hpc> unsaferCoerce _ = unsafeCoerce . unsafePerformIO $ randomIO
10:23:37 <hpc> :t randomIO
10:23:38 <lambdabot> forall a. (Random a) => IO a
10:23:39 <elliott> Or under a service supervision daemon.
10:23:44 <elliott> unsaferCoerce has to destroy the entire universe to be sure.
10:23:54 <parcs`> fix . unsafeCoerce
10:23:58 <cmccann> elliott, isn't that what unsafestCoerce is for?
10:24:25 <elliott> cmccann: Oh, you're right. Haskell is a multi-paradigm language, after all; we have to support all *kinds* of unsafe coercion.
10:25:04 <shachaf> unsaferCoerce _ = unsafePerformIO (getProcessID >>= signalProcess killProcess)
10:25:05 <esap> elliott: heh, you mean every paradigm must resort to unsafe coercions?
10:25:26 <paradigm> esap: yeah I hate it when I have to resort to unsafe coercions
10:25:28 <paradigm> every one of me
10:25:36 <cmccann> someone should implement a dependently-typed unsafeCoerce in Agda, you'd have to provide a proof that the coercion is invalid
10:25:37 <shergill> heh
10:25:50 <elliott> @remember cmccann someone should implement a dependently-typed unsafeCoerce in Agda, you'd have to provide a proof that the coercion is invalid
10:25:50 <lambdabot> Nice!
10:25:58 <cmccann> heh
10:26:07 <elliott> unsafeCoerce : ~ (a = b) -> a -> b
10:26:11 <elliott> (except with more unicode.)
10:26:16 <hpc> unsafeCoerce : \forall {A B : Set} -> ((A -> B) -> Void) -> A -> B
10:26:37 <elliott> mine has a stronger unsafety requirement
10:26:58 <shergill> @help
10:26:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:27:14 <shergill> @list
10:27:14 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:33:46 <hpaste_> “C. McCann” pasted “unsaferCoerce” at http://hpaste.org/56741
10:34:03 <cmccann> not Agda, but hey
10:35:41 <Sgeo> uh
10:36:29 <elliott> cmccann: I approve
10:37:10 <elliott> cmccann: hmm, does that stop you doing "instance () :/~ ()" and using unsaferCoerce safely?
10:37:22 <elliott> I guess you'd need IncoherentInstances to make that work
10:37:43 <cmccann> yeah, it's going to depend on the inequality constraint working correctly
10:38:45 <cmccann> but since the one instance is completely generic you'd need incoherent instances, yes
10:38:56 <cmccann> and personally that's just going too far
10:39:10 <cmccann> unsafeCoerce is one thing, but I draw the line at IncoherentInstances
10:39:12 <c_wraith> IncoherentInstances is always going too far
10:40:24 <copumpkin> I don't think I've ever used IncoherentInstances for something that wasn't voodoo
10:41:23 <cmccann> actually, wait, I don't think that would need incoherent instances after all
10:41:27 <cmccann> but it also wouldn't work
10:41:33 <cmccann> because the constraint
10:41:35 <cmccann> ergh
10:41:38 <cmccann> the constraint is on the class
10:41:44 <cmccann> so you'd have to mess with TypeEq as well
10:41:55 <elliott> copumpkin: I'm afraid to find out what you consider voodoo
10:42:15 <elliott> cmccann: you could maybe do something with ~ to stop working around it?
10:42:52 <cmccann> elliott, don't think so
10:43:15 <cmccann> that only helps with unifying type variables and delaying checks until after instance selection
10:43:18 <elliott> while the topic is type equality and scary type hacks: can you implement "nope :: (A ~ B) => Void", for distinct types A and B you pick yourself? also, A and B can't be Void :P
10:43:21 <cmccann> which is how TypeEq works anyway
10:43:24 <elliott> or (() -> Void)
10:43:42 <elliott> prize for succeeding: lambdabot karma
10:43:50 <elliott> prize for failing impressively: lambdabot karma
10:44:09 * elliott has had it in the back of his mind for ages but doesn't think it's possible...
10:44:19 <Sgeo> What is ~ ? same type?
10:44:29 <elliott> Sgeo: yes, it comes with type families
10:44:33 <hpc> elliott: nope = undefined -- ;)
10:44:38 <copumpkin> elliott: you can't even write that type
10:44:43 <cmccann> I think any constraint of the form (A ~ B) where A and B differ will be rejected
10:44:46 <elliott> copumpkin: Proxy (A,B) -> Void
10:44:47 <elliott> sheesh!!!
10:44:59 <elliott> hpc: you know, I even considered pointing out the obvious constraint :P
10:45:11 <elliott> cmccann: well obviously you won't actually be able to use nope
10:45:33 <cmccann> I don't think the definition would be accepted, even if you never use it
10:45:54 <elliott>     Couldn't match type `A' with `B'
10:45:54 <elliott>     Inaccessible code in
10:45:54 <elliott>       the type signature for nope :: A ~ B => Proxy (A, B) -> Void
10:45:55 <elliott> hmph
10:46:10 <elliott> i'm sure you can fool it with a complex enough phrasing
10:46:17 <cmccann> probably
10:46:33 <cmccann> if only by making the type checker diverge
10:47:50 <cmccann> but that's not terribly exciting in and of itself
10:48:06 <copumpkin> elliott: that's just gonna be the equality GADT
10:48:29 <Veinor> what the hell did i just come back to
10:48:54 <elliott> copumpkin: right, I would also accept nope :: Eq A B -> Void
10:48:58 <hpc> Veinor: dangerous thoughts :P
10:49:12 <elliott> Veinor: #i-cant-believe-its-not-agda
10:49:39 <gwern> preflex: seen aavogt
10:49:40 <preflex>  aavogt was last seen on #haskell 4 days, 19 hours, 41 minutes and 17 seconds ago, saying: for example -XScopedTypeVariables
10:49:40 <Veinor> is :/~ a constraint that's satisfied only for inequal types
10:49:46 <Veinor> that's horrifying
10:50:09 <cmccann> Veinor, yes
10:50:15 <elliott> copumpkin: wtf, that's not enough
10:50:20 <elliott> copumpkin: Equal A B complains about inaccessible code again
10:50:21 <cmccann> Veinor, I wrote it because someone on SO asked if it was possible
10:50:32 <elliott> I guess it'd be possible with the Leibniz formulation
10:50:33 <elliott> but wtf?!?!
10:50:40 <elliott> oh
10:50:40 <cmccann> cf. http://stackoverflow.com/q/6939043/157360
10:50:43 <elliott> it's because i pattern-matched on Refl :)
10:50:59 <elliott> you just have to do that indirectly via a function, haha
10:51:34 <Veinor> cmccann: that's amazing
10:52:08 <elliott> cmccann: perhaps the best depiction of the X-Y Problem I've seen yet
10:52:39 <cmccann> Veinor, I don't think it would ever actually be useful, but it is entertaining
10:53:22 <Veinor> yeah obviously
10:53:30 <cmccann> elliott, pretty much, though at least the questioner seemed to realize that
10:53:36 <elliott> yeah, i don't think it's possible to write nope even with the leibniz equality definition :(
10:54:47 <cmccann> incidentally, for some reason it strikes me as funny when GHC's error message is "couldn't match type 'No' with 'Yes'"
10:55:35 <elliott> cmccann: that should just be the sole type error
10:55:37 <Veinor> my favorite silly haskell thing is
10:55:39 <Veinor> > fix error
10:55:40 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:55:44 <hpc> @remember ghc Couldn't match type `No' with `Yes'
10:55:45 <lambdabot> It is stored.
10:55:46 <cmccann> yeah that one's a classic
10:56:03 <cmccann> I think that's the primary use of "fix" to be honest
10:56:05 <elliott> > fix (error . show)
10:56:07 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
10:56:15 <elliott> hmm, I guess it defaulted to () there
10:56:16 <Veinor> cmccann: haha
10:56:26 <elliott> that's the only time show ever decreases quotes
10:56:37 <Veinor> > fix show
10:56:38 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
10:56:40 <Veinor> also another good one
10:56:51 <elliott> @yhjulwwiefzojcbxybbruweejw
10:56:51 <lambdabot> "\"#$%&'()*+,\""
10:56:53 <elliott> @yhjulwwiefzojcbxybbruweejw
10:56:53 <lambdabot> "\""
10:56:56 <cmccann> :t fmap fix return
10:56:57 <lambdabot> forall a. a -> a
10:56:59 <Veinor> elliott: what
10:57:06 <elliott> @v
10:57:06 <lambdabot> "\""
10:57:07 <elliott> @yhjulwwiefzojcbxybbruweejw
10:57:07 <lambdabot> "\"#$%&'()*+,\""
10:57:09 <elliott> @yhjulwwiefzojcbxybbruweejw
10:57:09 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
10:57:14 <Veinor> what is going on i'm confused
10:57:14 <elliott> Veinor: it's yhjulwwiefzojcbxybbruweejw
10:57:25 <elliott> the command is actually called that
10:57:31 <Veinor> yeah but what does it do
10:57:40 <elliott> gives examples of lambdabot output from ye olden days
10:57:42 <elliott> where it worked like
10:57:45 <elliott> let v = <expr> in ...
10:57:52 <elliott> so you could get an implicit fix by referencing v
10:57:59 <elliott> then the variable name was lengthened to stop people doing that :P
10:58:04 <Sgeo> implicit fix?
10:58:14 <elliott> Sgeo: as in, > Just (show v)
10:58:18 <elliott> would end up as
10:58:21 <elliott> > fix (Just . show)
10:58:22 <lambdabot>   Just "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\...
10:58:25 <Sgeo> Ah, ok
10:58:35 * elliott was never actually around for this, just heard the story second-hand :P
10:58:42 <Veinor> ah
10:58:51 <elliott> anyway, yhjulwwiefzojcbxybbruweejw was the last name it had before the thing was rewritten to avoid binding it completely
10:58:52 <Veinor> also fmap fix return is id, that's great
10:59:05 <elliott> i've forgotten how fmap fix return works :(
10:59:10 <Sgeo> :t fmap fix return
10:59:11 <lambdabot> forall a. a -> a
10:59:22 <koeien> > fmap fix return 3
10:59:23 <lambdabot>   3
10:59:25 <koeien> yay!
10:59:27 <hpc> fmap fix return == fix . return == fix . const == id
10:59:32 <cmccann> elliott that's return in the pointless obfuscation monad, if that helps
10:59:34 <elliott> oh!
10:59:38 <hpc> just drill down the instances
10:59:40 <shergill> :t fix
10:59:40 <lambdabot> forall a. (a -> a) -> a
10:59:43 <cmccann> i.e. const
10:59:48 <elliott> cmccann: Hey, it's nice for applicative style :)
10:59:56 <elliott> admittedly, that's not the Monad instance...
11:00:02 <elliott> join on (->) is nice too though
11:00:12 <cmccann> yeah, I actually use it a fair bit, heh
11:00:39 <koeien> > join (*) 3
11:00:40 <lambdabot>   9
11:00:49 <mekeor> @src join
11:00:49 <lambdabot> join x =  x >>= id
11:01:25 <hpc> join f x = f x x -- more specific
11:01:27 <zachk> @src fix
11:01:27 <lambdabot> fix f = let x = f x in x
11:01:37 <zachk> @src fmap
11:01:37 <lambdabot> Source not found. I am sorry.
11:01:42 <mekeor> hpc: ah, okay. i see. ty.
11:01:47 <cmccann> but the ((->) e) instance makes a nice EDSL for obfuscating things with pointless style :P
11:02:11 <ion> @@ @djinn @type join `asAppliedTo` (undefined :: a -> b)
11:02:12 <lambdabot>  f a b = a b b
11:02:29 <cmccann> fix, pure, and (<*>) together give you turing completeness after all
11:02:47 <Sgeo> cmccann, o.O
11:02:49 <elliott> not quite
11:02:50 <kyagrd> cmccann, such as Lennart's BASIC EDSL?
11:02:55 <elliott> you need a newtype wrapper
11:03:04 <elliott> oh
11:03:06 <elliott> i guess with fix
11:03:14 <elliott> Sgeo: pure and (<*>) are generalisations of K and S
11:03:16 <cmccann> elliott, yeah, I think fix gives you enough rope to hang yourself there
11:03:20 <elliott> and are K and S for (->)
11:03:31 <Sgeo> :t pure succ
11:03:32 <lambdabot> forall a (f :: * -> *). (Enum a, Applicative f) => f (a -> a)
11:03:33 <elliott> k :: a -> (r -> a)
11:03:38 <elliott> s :: (r -> a -> b) -> (r -> a) -> (r -> b)
11:03:40 <nand`> does anybody here use GLUT?
11:04:01 <ion> @@ @djinn @type (<*>) `asTypeIn` \ (<*>) -> undefined <*> (undefined :: a -> b)
11:04:02 <lambdabot>  f a b c = a c (b c)
11:04:08 <cmccann> nand`, no, I avoid it and use SDL most of the time
11:04:17 <elliott> cmccann: actually i am not so sure.
11:04:27 <elliott> cmccann: you can't do church numerals because of types still
11:04:30 <elliott> (i think)
11:04:48 <elliott> ion: Nice.
11:05:03 <cmccann> elliott, I think there are workarounds but you have to jump through some extra hoops, but I'm not certain
11:05:09 <nand`> cmccann: oh okay. I considered SDL at first but it was much harder to get a project running with so I scrapped it and used GLUT, which works out of the box
11:05:26 <etpace> Does anyone havea ny musings/thoughts about why some things that are seen as "bad practice" (short variable names, unqualified imports, ..?) are quite common, or rather the standard in haskell?
11:05:27 <elliott> hSDL is quite easy to get a simple working skeleton up with
11:05:32 <cmccann> nand`, I mostly dislike the program structure that GLUT requires
11:05:36 <elliott> etpace: those aren't bad practice
11:05:46 <elliott> at least, short variable names aren't, and not everyone agrees on unqualified imports (I don't mind them much)
11:05:52 <koeien> etpace: mathematics background, more general code, imports are never ambigious
11:06:07 <elliott> imports are never ambiguous? huh?
11:06:13 <etpace> yeah, what does that mean?
11:06:14 <kyagrd> ah ... haskell.org dead, couldn't be blacklisted based because of SOPA
11:06:21 <koeien> well, they are, if the compiler catches it.
11:06:26 <kyagrd> Oh, it's alive just slow response
11:06:27 <elliott> etpace: const a b = a -- what names would you use intead? :)
11:06:28 <etpace> And mathematics background seems quite a bad excuse, especially when writing very non-mathematics libraries
11:06:33 <elliott> *instead
11:06:41 <etpace> Thats true
11:06:44 <koeien> if your program passes the compiler, you can always resolve your symbols unambigiously
11:06:46 <elliott> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b -- what names?
11:06:51 <elliott> short variable names usually appear in generic code
11:06:56 <koeien> elliott: probably x and y tbh ;)
11:06:59 <elliott> which /is/ very mathematical in structure, even if it's not "mathsy"
11:07:13 <elliott> and haskell generally has a lot more of that than other languages
11:07:19 <ion> const nikolaTesla thomasEdison = nikolaTesla
11:07:20 <etpace> true
11:07:51 <elliott> ion: I approve of this naming scheme and will adopt it for parameters in the Popelude post haste
11:08:15 <cmccann> anyway, the correct approach is "use the shortest variable name that communicates the intent"
11:08:31 <elliott> @quote platitude
11:08:31 <lambdabot> ddarius says: "use the right platitude for the job"
11:08:36 <etpace> I agree in the general cases nothing can be helped, but i've definitely come across code that is far too liberal with "xs ys xss a" when the type signatures are not that general
11:08:41 <koeien> variable names should be proportional in length to their scope
11:08:43 <djanatyn> > let (|) = flip ($) in "hello" | reverse
11:08:44 <Veinor> i wrote a post about not using single-letter type variables
11:08:45 <lambdabot>   <no location info>: parse error on input `|'
11:08:47 <etpace> perhaps you could argue that type signatures give some naming to variables too
11:08:53 <elliott> etpace: they do :)
11:08:58 <djanatyn> > let (|) = flip ($) in "hello" (|) reverse
11:08:59 <lambdabot>   <no location info>: parse error on input `|'
11:09:09 <elliott> if you have [Person] in the type signature, maybe (p:ps) is reasonable, but (person:people) is just clutter
11:09:15 <Veinor> like
11:09:20 <elliott> especially since a lot of haskell has a very "horizontal" style, columns are at a premium
11:09:20 <Veinor> Form m i e v a in digestive-functors
11:09:22 <Veinor> that's just silly
11:09:23 <cmccann> etpace, would using some other name have made the code any clearer, though? particularly accounting for idiomatic patterns like "x:xs"
11:09:39 <ion> @type ala
11:09:40 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:09:41 <etpace> I think in Veinors example, it can be
11:09:51 <djanatyn> > let (|) = flip (\\) in "hello" \\ reverse
11:09:52 <lambdabot>   <no location info>: parse error on input `|'
11:09:59 <djanatyn> errm.
11:10:00 <Veinor> ion: see, that's just unreadable
11:10:10 <djanatyn> what symbols can I use here?
11:10:13 <ion> > let a | True = 42 in a
11:10:14 <lambdabot>   42
11:10:19 <etpace> Also cmccann I find it hard to judge -- I often think its unclear before I "remember" what the small variables are, then its perfectly clear
11:10:26 <cmccann> the type for "ala" is fine, actually, if you know what the Newtype class does
11:10:27 <ion> | is reserved for pattern guards.
11:10:28 <etpace> but does that mean the code is unclear?
11:10:30 <elliott> Veinor: it's made more unreadable by the forall
11:10:34 <elliott> I would use names other than o/n
11:10:43 <elliott> I would use e.g. w, u for wrapped/unwrapped
11:10:48 <djanatyn> yeah, thought so
11:10:50 <Veinor> i'd use
11:10:52 <Veinor> old and new
11:10:54 <elliott> but Newtype is very general, so it wouldn't make much sense at all to use words
11:10:56 <Veinor> or something
11:10:59 <ion> cmccann: I suggested replacing “o” and “n” with “old” and “new”. IIRC djahandarie was going to do that.
11:11:00 <elliott> Veinor: old? there's nothing old about it :)
11:11:08 <elliott> oh, hmm, is that the etymology?
11:11:14 <Veinor> also in snap, instead of Handler b v a, Handler base view a
11:11:30 <djanatyn> > let pipe = flip ($) in "hello" `pipe` reverse
11:11:31 <lambdabot>   "olleh"
11:11:34 <cmccann> ion, that would be better I think
11:11:53 <elliott> old and new are better than o and n, but at the same time the newtype package has a bunch of really big signatures
11:12:00 <elliott> long names could make those less readable
11:12:36 <cmccann> etpace, would you have to stop and think about what the code does anyway? does remembering what the variables mean actually slow that down significantly enough to outweigh the benefit of less visual clutter?
11:13:04 <cmccann> if you know exactly what a name means, then all else equal short names are better
11:13:12 <Sgeo> Newtype class?
11:13:14 <koeien> it depends i think, I agree with Veinor's example
11:13:35 <elliott> Sgeo: http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html
11:13:45 * elliott really wishes it was called something other than Newtype
11:13:59 <etpace> cmccann: I guess there is a trade off between clutter after understanding vs speed of understanding at initial appraoch
11:14:12 <cmccann> etpace, that's exactly the trade-off
11:14:13 <Veinor> elliott: it makes me think of gundams
11:14:46 <cmccann> etpace, and if it takes only a moment to figure out initially but you spend a long time thinking about the code afterwards, the names don't matter that much
11:14:57 <cmccann> it's more important to have consistency in naming in related chunks of code
11:15:07 <rwbarton> the thing I didn't "get" about Newtype at first is that it's supposed to be an asymmetric thing--it's not just expressing a relationship that two types are isomorphic, but saying that o is specifically what you get by unwrapping the newtype n
11:15:30 * elliott would call Newtype "Wrapper" or something
11:15:39 <cmccann> rwbarton, yeah, it's for lifting stuff using a type to newtypes wrapping that type
11:15:50 <ion> rwbarton: Yeah, for instance, Integer is what you get by unwrapping IO Integer.
11:16:11 <elliott> ion: there are newbies watching!!!
11:16:13 * cmccann has Applicative-style infix operators for lifting to Newtype instances
11:16:14 <elliott> :P
11:16:14 <rwbarton> right, but it's not for transporting functions across arbitrary isomorphisms
11:16:19 <parcs`> Integer is what you get by unwrapping ((Integer))
11:16:36 <koeien> ion: oh how does that work?
11:16:45 <koeien> ion: i tried to do that but the compiler didn't let me :(
11:16:50 <rwbarton> ion: It took me a while to realize that you are perhaps in fact technically "correct".
11:16:59 <koeien> the best kind of correct.
11:18:51 <shergill> naw, that's theoretically correct
11:18:56 * byorgey thinks 'over' and 'under' in the newtype package are backwards
11:18:58 <ion> rwbarton: I am? :-P
11:19:46 <cmccann> wouldn't unwrapping "IO a" give you "State# RealWorld -> (# State# RealWorld, a #)"?
11:20:19 <rwbarton> and isn't State# s a representation-less token in ghc's implementation?
11:20:38 <rwbarton> as in, its representation is the 0 byte string
11:21:34 <elliott> rwbarton: it's still a function though
11:21:40 <elliott> that's why
11:21:45 <elliott> > (undefined :: IO ()) `seq` 42
11:21:46 <lambdabot>   *Exception: Prelude.undefined
11:21:52 <elliott> > ((undefined :: IO ()) >>= return) `seq` 42
11:21:53 <lambdabot>   42
11:24:13 <rwbarton> oh, I guess, seq on functions, bleh.
11:25:24 <dmwit> GHC has lots of 0-byte registers available.
11:25:32 <dmwit> Which is a darn good thing, because they use them a lot.
11:27:47 <erus`> id \1 -> 2
11:27:50 <erus`> > id \1 -> 2
11:27:51 <lambdabot>   <no location info>: parse error on input `\'
11:27:57 <erus`> > id (\1 -> 2)
11:27:58 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
11:27:58 <lambdabot>    arising from a use of ...
11:28:37 <erus`> id \1 -> 2 is a valid lamdba calc term, right? meaning id (\1 -> 2)
11:29:41 <nand`> erus`: no
11:29:49 <nand`> parse error, you have to enclose it in parentheses
11:30:07 <aluink> say i have Ord a => [(a,b)], how can I get the tuple with the max a? i can't seem to find an elegant solution
11:30:19 <cmccann> aluink, use Data.Map
11:30:27 <koeien> maximumBy (compare `on` fst)
11:30:29 <aluink> ok, i'll look into that
11:30:30 <ion> I do wish that syntax was allowed.
11:30:30 <byorgey> aluink: maximumBy (comparing fst)
11:31:54 * cmccann tends to assume that a type like "(Ord a) => [(a, b)]" almost always means "shouldn't be using a list in the first place"
11:33:42 <erus`> nand`: where did you read that?
11:34:29 <Saizan> some allow id \1 -> 2; but i think the grammar is more complicated if you want to
11:34:51 <Sgeo> > id \a -> 2
11:34:52 <lambdabot>   <no location info>: parse error on input `\'
11:34:56 <Sgeo> > id $ \a -> 2
11:34:57 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
11:34:57 <lambdabot>    arising from a use of ...
11:35:18 <cmccann> > id (\1 -> 2) 0
11:35:19 <lambdabot>   *Exception: <interactive>:3:4-10: Non-exhaustive patterns in lambda
11:35:47 <erus`> why would the syntax be harder to read, just consume until you hit a EOF or )
11:35:53 <ion> > id (\1 -> 2) 1 2 2 2
11:35:54 <lambdabot>   2
11:36:05 <erus`> well might aswel conform
11:36:21 <elliott> ion: :(
11:38:56 <erus`> well my typed lambda calc evaluator works
11:39:05 <erus`> whats the next step?
11:39:33 <elliott> erus`: dependent types!
11:39:44 <erus`> i want generic functions
11:39:50 <erus`> but i dunno how to do it
11:40:08 <dolio> Agda allows 'f \x -> ...'.
11:40:09 <cmccann> erus`, what do you have now, simply-typed lambda calculus?
11:40:15 <dolio> It's not ambiguous.
11:40:24 <dolio> But Haskell doesn't.
11:40:34 <erus`> cmccann: yeah
11:41:17 <cmccann> erus`, with type inference? or explicit types
11:41:41 <erus`> it infers function body
11:41:46 <erus`> not arguement tho
11:42:06 <cmccann> you could probably take a stab at something like System F then
11:42:41 <dolio> Hindley-Milner is a good thing to implement, too.
11:42:50 <cmccann> that would be the other obvious choice
11:43:55 <dolio> It's pretty easy for just lambda terms (no let).
11:44:36 * cmccann was going to suggest H-M instead if it was already inferring all the types, since that's about the most you can do without losing full inference
11:55:55 <mekeor> what do you think? what'd be the best way to represent a seven-segment display (but with variable width and height) in haskell?
11:57:31 <erus`> cmccann: can i infer arguements in simply typed?
11:57:54 <erus`> well i can but is it stupid
11:57:56 <copumpkin> infer arguments?
11:57:57 <cmccann> erus`, simply-typed lambda calculus allows complete type inference, I think
11:58:07 <byorgey> mekeor: what do you mean by "represent"?
11:58:14 <mekeor> i mean, would you give all nodes a coordinate? or would you enumerate all edges?
11:58:19 <mekeor> byorgey: ↑
11:58:33 <byorgey> mekeor: you mean you want to produce an image of a seven-segment display?  Or you want to create a data structure to represent the state of a seven-segment display? Or...?
11:58:46 <erus`> :w
11:58:52 <mekeor> byorgey: the latter. a data structure.
11:59:11 <Saizan> erus`, cmccann: (\x -> x) has a lot of incomparable types in STLC, it does have one principal type schema though
11:59:40 <Saizan> *scheme?
12:00:13 <Saizan> anyhow, inferring type schemes for STLC is basically what H-M does
12:00:33 <elliott> schema, I think.
12:01:29 <rwbarton> probably, because "axiom schema"
12:01:30 <byorgey> scheme, I think.
12:01:33 <rwbarton> heh :)
12:02:10 <byorgey> it is schemes.  http://www.mendeley.com/research/principal-typeschemes-for-functional-programs/
12:04:00 <byorgey> mekeor: maybe represent the six vertices of the display using abstract integer coordinates (i.e. [0,1] x [0,1,2]) and represent an edge with a pair of vertices?
12:04:54 <mekeor> byorgey: yea, that's what i was thinking, but i wasn't sure.
12:05:39 <mekeor> byorgey: thank you :)
12:05:46 <byorgey> sure =)
12:15:47 <danols_work> I've been in python/django for almost 4 years now, i'm getting tired of it's gotchas and nuances, what haskell framework I ought to look at?
12:15:59 <koeien> none as mature as django
12:16:12 <Veinor> snap or yesod are probably the closest equivalents, but yeah
12:16:13 <koeien> that said, you can look at yesod and snap
12:16:14 <elliott> danols_work: Yesod and Snap are the biggest ones
12:16:19 <stepcut> danols_work: happstack is nice. lots of flexibility and good documentation
12:16:23 <danols_work> happstack has concept of 'apps' ?
12:16:26 <elliott> http://www.yesodweb.com/, http://snapframework.com/
12:16:29 <danols_work> i just read about snapplets which is good
12:16:47 <danols_work> does snap have something like the acid-state?
12:16:59 <stepcut> danols_work: acid-state originated in happstack, though it is independent now
12:17:27 <danols_work> is there a benefit of using acid-state vs regual sql ?
12:17:30 <stepcut> elliott: why do you think snap and yesod are good choices, but not happstack?
12:17:37 <mightybyte> danols_work: Snap has excellent support for acid-state itself.
12:17:42 <elliott> stepcut: I just said they were the biggest -- they certainly get more buzz
12:17:48 <elliott> I haven't used any of the three myself.
12:17:52 <koeien> depends on how much you care about your data
12:18:15 <mdmkolbe> I'm trying to do a profiling build and I get an error that suggests I need to install the profiling libraries for package "strict".  How do I get the profiling version of the library?  ( "cabal install strict" says there is nothing to install so I'm guessing that is just the non-profiling version.)
12:18:19 <koeien> a "real" database is more battle-tested
12:18:21 <joyfulgirl> Hey, folks, any pandoc-knowledgeable folks here? I'm trying to understand the circumstances under which it does and doesn't produce numbered reference-links ([some website][1], as opposed to [some website][])
12:18:22 <stepcut> danols_work:  acid-state is it is a very different approach than SQL. The thing that makes it especially nice is that it stores haskell datatypes natively and queries and written in plain old haskell
12:18:24 <koeien> mdmkolbe: cabal install X -p
12:18:38 <danols_work> unfortunately 'it has to look good' to be popular
12:18:55 <elliott> mdmkolbe: --reinstall
12:19:02 <danols_work> stepcut: yes I agree, and DB is an old technology that I think has reach it's usefulness ,
12:19:05 <elliott> mdmkolbe: you can enable profiling by default in your ~/.cabal/config
12:19:07 <danols_work> ?
12:19:12 <koeien> mdmkolbe: you can also enable library-profiling in .cabal/config
12:19:20 <stepcut> danols_work: but, acid-state is is realiable, but it is also missing certain, potentially critictal features
12:19:22 <danols_work> anyone here with haskell web programing experience?
12:19:23 <elliott> mdmkolbe: I would recommend just trashing ~/.ghc and ~/.cabal and starting over with profiling on
12:19:26 <danols_work> anyone with 'paid' experience
12:19:33 <mightybyte> danols_work: Yes
12:19:52 <stepcut> danols_work: features that could be implemented but have not been yet. Such as sharding
12:20:06 <mdmkolbe> elliott, koeien: -p with --reinstall seems to have worked (just -p by itself did not)
12:20:08 <danols_work> mightybyte: would you please share your thoughts, what have you coded on in before?
12:20:10 <stepcut> danols_work: I am a full time haskell web developer
12:20:15 <monochrom> apparently, the founder of yesod has paid experience
12:20:16 <danols_work> stepcut: ? for acid-state?
12:21:13 <stepcut> danols_work: yeah. acid-state does not currently have sharding. Or replication for that matter. happstack-state has some experimental replication support, but it is not a solved problem yet
12:21:26 <mightybyte> danols_work: Prior to Haskell I did a lot of Java.
12:21:42 <mightybyte> danols_work: Then I was trying to build a website using drupal and PHP.
12:21:52 <stepcut> danols_work: so.. if your expected dataset size is small, then acid-state can be a nice choice. If you are going to need a huge amount of data.. then it is not ready yet
12:22:00 <mightybyte> danols_work: It was miserable and I couldn't motivate myself at all, so I switched to Haskell.
12:22:10 <danols_work> mightybyte: what framework you utlize now?
12:22:18 <danols_work> stepcut: k
12:22:19 <danols_work> thank you
12:22:51 <Veinor> mightybyte is one of the snap devs, so he might be kind of biased :D
12:22:54 <mightybyte> danols_work: I currently develop Haskell in my day job and I used Snap to build an internal website for my company.
12:23:12 <mightybyte> :)
12:23:15 <danols_work> why did you pick snap?
12:23:23 <mightybyte> Because I wrote it. :)
12:23:37 <Veinor> http://code.amateurtopologist.com/scalemate i built this in snap, both the bit of code that handles the uploading of images to the server and the templating
12:23:47 <stepcut> what are some things that make snap better than happstack or yesod?
12:24:04 <koeien> the snap code is really beautiful :)
12:24:13 <koeien> yesod is very opinionated
12:24:18 <Veinor> (though i need to come up with a better approach for detecting the 'active' page other than 'the url of the target is a prefix of the current url')
12:24:23 <stepcut> koeien: how does 'beautiful code' translate to usefulness?
12:24:27 <mdmkolbe> What does this error mean "Dynamic linking required, but this is a non-standard build (eg. prof). You need to build the program twice: once the normal way, and then in the desired way using -osuf to set the object file suffix."?  (That file has Template Haskell in it which I suspect is the cause.)
12:24:34 <mightybyte> stepcut: Better maintainability
12:24:49 <danols_work> stepcut: beautiful code is VERY important
12:24:50 <koeien> stepcut: it shows care and makes you trust the code more (as a user)
12:25:17 <stepcut> what do you think makes the code beautiful? adherence to code formatting standards?
12:25:26 <koeien> no
12:25:47 <mightybyte> Blood sweat and tears invested ;)
12:25:57 <kuznero> :)
12:25:59 <koeien> ease of understanding the core data types, for example :)
12:26:07 <danols_work> php > python > haskell
12:26:11 <danols_work> I left php
12:26:20 <elliott> php is better than python is better than haskell, indeed!
12:26:21 <danols_work> knew of haskell for a long time
12:26:22 <stepcut> koeien: like Response and Request?
12:26:36 <Veinor> elliott: yeah, that's the way i read it too
12:26:36 <koeien> although i must say that i did not read happstack's code, so it's not really a "comparison"
12:26:42 <koeien> not completely, that is
12:26:52 <danols_work> anywho sorry guys
12:26:57 <stepcut> koeien: so happstack code could be beautiful and you don't know it ?
12:27:06 <koeien> that's quite possible
12:27:10 <danols_work> if I were to give a haskell framework a try ( i have haskell experience for way back and though the langauge is awesome)
12:27:12 <danols_work> snap?
12:27:22 <koeien> happstack is the oldest afaik so it could be the most mature
12:27:41 <danols_work> happstack is not popular
12:27:45 <stepcut> danols_work: I think you will find that happstack has very complete documentation
12:27:48 <koeien> haskell is not popular
12:27:53 <danols_work> hence maybe not a great choice for a money making career
12:27:54 <cmccann> I think yesod's code consists mostly of alchemical formulas, magic incantations, and mystic runes to invoke the dark gods of TH
12:27:57 <stepcut> danols_work: how do you determine that happstack is not popular?
12:28:04 <danols_work> koeien: fair enough
12:28:09 <danols_work> stepcut: feeling ?
12:28:39 <stepcut> danols_work: it is the bases the hackage2 server, there a full featured wiki, and is used by a number of haskell startups
12:29:03 * geekosaur has noticed a certain amount of belief that happstack is too complex for people to understand.
12:29:10 <danols_work> stepcut: if I may how do you base that observation on ?
12:29:16 <koeien> geekosaur: is that because of macid?
12:29:18 <mightybyte> Snap originated as a simplified happstack.
12:29:21 <stepcut> danols_work: which observation ?
12:29:26 <geekosaur> (I'm also under the impression that there was a time when that was deserved, but it's not really true any more)
12:29:39 <stepcut> but then snap got more complicated as it had to put things back in :p
12:29:49 <mightybyte> s/back//
12:29:52 <stepcut> anyway, happstack-lite is a simplification of snap .
12:29:59 <danols_work> stepcut: there is the re-invent the wheel fallacy
12:30:08 <danols_work> i'm getting confused
12:30:31 <geekosaur> koeien, it's not so much because of anything, it's just one of those urban legend things.  it does have a basis in old versions of HappS, but happstack has changed a *lot* since then
12:30:50 <cmccann> yesod has type-safe wheels that only roll when attached to a vehicle with sufficient wheels to move
12:30:51 * elliott remembers when the only thing in town was HAppS, uphill, both ways, etc.
12:30:51 <danols_work> guys do +1 for me
12:31:13 <danols_work> happstack, snapp, yesod ?
12:31:13 <shergill> danols_work: this might be helpful http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks
12:31:14 <elliott> I can't believe http://happs.org/ is still up
12:31:54 <danols_work> what and who is behing haskell money wise?
12:32:01 <stepcut> danols_work: happstack contains a lot of features which most people do not use when they first get started.. so it comes off as complicated. But, of course, many of those features where implemented because people actually needed them in more complex web applications. happstack-lite is very of happstack which contains only the stuff you are likely to use when you first start developing a haskell web application. it simplies they ty
12:32:01 <stepcut> pes and conslidates everything into one easy to find location. But remains fully compatible with 'normal' happstack
12:32:06 <Veinor> the illuminati!
12:32:46 <elliott> danols_work: depends what you mean by haskell
12:33:01 <stepcut> elliott: yeah.. in many ways happs is a thorn in the side of happstack, because people remember the old versions which where much different, harder to use, and poorly documented
12:33:04 <elliott> the report is done by the haskell committee, ghc is an open-source project although the main developers are at microsoft research
12:33:10 <elliott> and i guess the industrial haskell group do... _something_
12:33:32 <cmccann> galois has provided various resources for the haskell community are various times
12:33:35 <cmccann> but I don't recall the specifics
12:33:37 <stepcut> sometimes it seems like it would be a good idea to just rename the project and pretend it was something new ;)
12:33:40 <mightybyte> danols_work: I'll be happy to give you my candid opinion about why we decided to leave happstack and start Snap, but I do so offline to avoid inciting argument.
12:33:43 <danols_work> out of those three snap has the best 'look'
12:33:53 <danols_work> the site wise
12:34:01 <danols_work> that is important if you want the code to be popular
12:34:06 <elliott> lol
12:34:24 <elliott> web design of the homepage is definitely _the_ most important attribute of any piece of software.
12:34:25 <danols_work> you laugh but it's my observation
12:34:28 <koeien> not very likely amongst experienced haskellers
12:34:29 <shergill> mightybyte: when you started developing Snap, was Yesod already an active project?
12:34:37 <mightybyte> No
12:34:49 <stepcut> elliott: indeed. it is past time to redo the happstack web site
12:34:52 <koeien> i don't like all the TH there
12:35:00 <danols_work> ok i'm gonna start coidng in haskell on the side, this compnay is small enough that maybe I can turn the ship again
12:35:02 <elliott> marienz: <padawan--> Sorry bothering you. I noticed you are fond of maths. So, i thought of inviting you to #calculus.
12:35:07 <danols_work> but jsesus I don't want a new girlfriend in 4 years
12:35:09 <cmccann> elliott, I remember there being widespread hilarity when someone noticed that the Rails site was actually running on PHP
12:35:13 <danols_work> I want a 'wife'
12:35:13 <marienz> elliott: ty
12:35:23 <elliott> marienz: :)
12:35:49 <stepcut> danols_work: anyway, there is a short (less than ~2000 word) intro to happstack here, http://happstack.com/docs/happstack-lite/happstack-lite.html, and a very detailed intro with lots of examples here, http://happstack.com/docs/crashcourse/index.html
12:36:45 <danols_work> ok thank you all
12:36:58 <danols_work> end of work day for me --- I will be back
12:37:07 <stepcut> danols_word: take care!
12:37:12 <danols_work> I put all your links on my todo for the night
12:37:19 <danols_work> thanks again
12:37:25 <monochrom> a programming language is not a girlfriend or wife or boyfriend or husband or same-sex partner or common-law spouse or soul mate
12:37:51 <koeien> danols_work: you can also check out the IRC channels of those projects
12:38:00 <cmccann> monochrom, how about a pet? livestock, perhaps? can it be one of those?
12:38:01 <mekeor> monochrom: what instead?
12:38:21 <monochrom> I prefer livestock. yummy.
12:38:33 <erus`> monochrom: oh, so same sex partners are not 'boyfriends' or 'girlfriends'... Would you call them abominations?
12:38:37 <elliott> languages are like pet rocks
12:38:38 <cmccann> ok. livestock it is.
12:38:40 <elliott> they never do what you tell them to
12:38:46 * byorgey finds that deadstock is much yummier than live
12:38:49 <cmccann> and you can throw them at people
12:39:02 <maxerize> haskell ftw
12:39:07 <koeien> maxerize: well said
12:39:10 <cmccann> byorgey, I like my steaks especially rare
12:39:13 <monochrom> the "or"s there are not mutually disjoint.
12:39:15 <maxerize> i just wanted to say it
12:39:19 <byorgey> cmccann: still mooing rare?
12:40:16 * cmccann goes with "if you can't take it to the vet and save it, it's overcooked"
12:40:22 <byorgey> hehe
12:45:10 <tkahn6> is typeclassopedia still recommend reading?
12:45:14 <tkahn6> recommended*
12:45:28 <koeien> it's on the haskell wiki now
12:45:39 <koeien> but yes, sure, it's excellent
12:45:54 <elliott> it's the prettiest wiki page i've ever seen
12:46:00 <elliott> tkahn6: (http://www.haskell.org/haskellwiki/Typeclassopedia)
12:46:07 <tkahn6> elliott: thanks
12:46:12 <tkahn6> but the pdf is really pretty too
12:46:16 <tkahn6> is that outdated?
12:46:20 <tkahn6> (the pdf)
12:46:25 <elliott> the wiki page is the official one now
12:46:29 <tkahn6> k
12:46:33 <koeien> not really, youc an still use it
12:46:34 <elliott> but the wiki page looks just as good as the pdf imo :P
12:47:00 <koeien> but there might be different wording, more examples
12:47:31 <koeien> byorgey added some stuff on the wiki I see
12:49:57 <byorgey> you have geheimdienst to thank for the beauty of the wiki page
12:50:13 <byorgey> yes, I've added some stuff and plan to continue doing so
12:50:23 <tkahn6> byorgey thanks
12:50:50 <donri> speaking of, if anyone wants to help i've been trying to put all about monads on the haskellwiki here http://www.haskell.org/haskellwiki/All_About_Monads
12:52:25 <nand`> I want Valve to make a “Meet the Monad” video now
12:54:20 <enzuru> found an outdated link, i'll update it
12:54:59 <donri> at the moment, if you edit the page directly the edits will be lost
12:55:36 <enzuru> oh noes
12:55:47 <enzuru> what should i do then
12:56:24 <donri> https://github.com/dag/all-about-monads is the place to be
12:56:44 <donri> i suppose you could edit the original html if you don't want to write a pandoc transformation
12:57:29 <donri> sorry for making it complicating :) but the generated wikimarkup isn't good enough yet
12:57:59 <enzuru> :[
12:58:11 <enzuru> just make sure you update 'Maybe' link
12:58:30 <enzuru> the one in this sentence: 'We will use the Maybe type constructor throughout this chapter, so you should familiarize yourself with the definition and usage of Maybe before continuing.'
12:59:09 <donri> there's loads of broken links that hopefully will get fixed at some point
12:59:45 <enzuru> oh okay
12:59:56 <enzuru> that's the only one i encountered
13:00:02 <enzuru> or clicked on, at least :P
13:01:29 <partyhard> Hi.Im having problem understanding the "let" command. Can anybody explain it simply.Thanks.:)
13:01:39 <donri> "let" is syntax, not a command
13:02:06 <partyhard> how to apply it in general
13:02:24 <partyhard> im confused :P
13:02:25 <donri> > let x = 5 in x * 2
13:02:26 <lambdabot>   10
13:02:40 <shergill> @src fix
13:02:41 <lambdabot> fix f = let x = f x in x
13:02:44 <partyhard> that i understand
13:02:54 <partyhard> how to apply it on a bigger scale
13:03:06 <partyhard> i little bit complicated
13:03:08 <donri> how do you mean?
13:03:15 <partyhard> where to put what
13:03:27 <partyhard> how do i apply it in general
13:03:38 <shergill> partyhard: do you understand the fix example?
13:03:38 <c_wraith> well.  there are two different forms of let.  It's important to know they're different
13:03:39 <partyhard> so my brain understand the concept
13:03:41 <partyhard> :P
13:03:44 <donri> i don't understand the question, sorry
13:03:51 <tkahn6> donri: as an intermediate noob i will do your monds tutorial and tell you how it goes
13:03:56 <tkahn6> monads*
13:04:16 <partyhard> i dont understand the fix example
13:04:27 <elliott> @pl \k -> r k . a a'
13:04:28 <lambdabot> (. a a') . r
13:04:28 <partyhard> shergill
13:04:38 <partyhard> O_O
13:04:42 <donri> tkahn6: it's not my text, i'm just porting it to the wiki
13:04:50 <tkahn6> donri: oh i see
13:04:57 <tkahn6> donri: looks pretty tho
13:05:04 <donri> mostly thanks to pandoc :)
13:05:09 * donri shoulder of giants etc
13:05:45 <partyhard> so its "let parameter in body" right?
13:06:14 <Peaker> partyhard: let <definitions> in <body>
13:06:36 <shergill> partyhard: let creates bindings, with the syntax as Peaker demonstrated above
13:06:45 <partyhard> in definition you put in the varibales what else
13:07:04 <Peaker> partyhard: Each <definition> is: "<name> = <expression>"
13:07:23 <partyhard> i dont understand sorry :)
13:07:29 <partyhard> peaker
13:07:51 <partyhard> aha i get it
13:08:09 <partyhard> so the expresion is the algoritam
13:08:17 <partyhard> that calculates stuff
13:08:25 <Peaker> partyhard: yeah, you could say that
13:08:30 <partyhard> the formula
13:08:44 <donri> > let Just x = Just 5 in x
13:08:45 <lambdabot>   5
13:08:57 <Peaker> hmm.. yeah, I accidentally over-simplified :-)
13:09:09 <Peaker> partyhard: do you know what patterns are? And what data constructors are?
13:09:23 <partyhard> no i just started :)
13:09:32 <Peaker> partyhard: then forget what donri said above :)
13:09:38 <donri> O:)
13:09:40 <partyhard> ok.:)
13:09:49 <partyhard> the name is the wrapper for the expression
13:10:06 <partyhard> like a function
13:10:10 <donri> "let" lets you define functions and variables locally
13:10:11 <partyhard> when you want to call it
13:10:15 <donri> local to the "in" part
13:10:26 <vhd> What is the difference between a "floating" and "realFrac" and why is there a need for the two?
13:10:41 <Peaker> partyhard: not a "wrapper" -- but a way to "abstract" things...
13:11:00 <partyhard> in the try haskell is says" if you want to use variables more then once use the let"
13:11:19 <partyhard> so it localy declared
13:11:33 <elliott> vhd: you can do things like take the floor of RealFracs
13:11:41 <elliott> but Floating is just sin, pi, log, sqrt, etc.
13:11:44 <partyhard> you can not use it in some other part of the code
13:11:51 <elliott> you can give a (Floating a) => Floating (a -> a) instance
13:12:00 <elliott> but not a (sensible) (RealFrac a) => RealFrac (a -> a) instance
13:12:05 <Peaker> partyhard: It mainly lets you give a name to some expression so that you can use the name rather than type out the expression repeatedly
13:12:20 <Peaker> partyhard: it also allows you to refer back to the same name -- expressing recursions
13:12:45 <vhd> elliott what if I want to take a the floor of a Floating, seems like a long way to do something as simple as trying to floor the result of a logBase :(
13:12:46 <Peaker> partyhard: also gives you a nice syntax for defining functions:   "let f x = ..."    instead of   "let f = \x -> ..."
13:12:56 <partyhard> so it a expresion in a expresion in a expresion when you finnaly want to do something with it
13:13:14 <elliott> vhd: You just require a RealFrac...
13:13:16 <partyhard> so you always refer to it
13:13:26 <elliott> vhd: There are lots of numeric typeclasses because there are lots of numbers :)
13:13:40 <Peaker> partyhard: that sentence does not seem to be coherent :)
13:14:11 <Peaker> > let r = 8 ; pi = 3.14159265 in (pi*r^2, 2*pi*r)
13:14:12 <lambdabot>   (201.0619296,50.2654824)
13:14:20 <partyhard> so the parameter part it just the laying out the algoritam
13:14:27 <partyhard> telling haskell what to do
13:14:34 <donri> stepcut: y u no #happs
13:14:42 <donri> uh ignore me
13:14:58 <Peaker> partyhard: the first part gives names to expressions, the latter part uses those names
13:15:19 <elliott> partyhard: are you reading a haskell tutorial?
13:15:24 <Peaker> partyhard: the whole purpose of "let" is to assign some value to names in some local scope
13:15:32 <partyhard> just started.:)
13:15:48 <elliott> partyhard: it'll probably explain let...in itself
13:15:55 <elliott> at least if it's a good tutorial :)
13:16:33 <partyhard> the body part is adding or binding values to the algoritam (definition)
13:16:38 <shergill> partyhard: learn you a haskell for great good
13:16:41 <shergill> is.. good
13:16:53 <partyhard> let add1 x = x + 1 in map add1 [1,5,7]
13:17:01 <elliott> yep, that's correct
13:17:09 <partyhard> so it takes one value at the time from map
13:17:15 <nand`> let can also be used to pattern match
13:17:22 <partyhard> and puts it in the algoritam
13:17:27 <partyhard> x=x+1
13:17:28 <nand`> > let (Just x) = Just 5 in x
13:17:29 <lambdabot>   5
13:17:47 <partyhard> is that correct?
13:17:47 <mekeor> cool
13:17:52 <partyhard> way of thinking
13:17:52 <elliott> partyhard: pretty much
13:18:17 <nand`> partyhard: x+1, not x=x+1
13:18:25 <partyhard> ah  yes
13:18:27 <nand`> x=x+1 is not an expression
13:18:40 <partyhard> :)
13:18:42 <partyhard> explain please
13:18:45 <nand`> it's a definition
13:18:53 <nand`> you can't do something like
13:18:59 <partyhard> it bind the value x+1 to x
13:19:05 <nand`> f (x=x+1)
13:19:12 <partyhard> is that correct
13:19:59 <nand`> partyhard: I would avoid using the term “bind” here; I'd simply say “it defines x as x+1”
13:20:22 <nand`> in haskell all you can do is define things
13:20:38 <nand`> you can't change things once they're defined
13:20:48 <elliott> it's actually
13:20:49 <elliott> add1 x
13:20:52 <elliott> being defined as x+1 though :)
13:20:56 <partyhard> i thought haskell doesnt reserve space in memory for variable unitl its used
13:21:03 <nand`> yeah in that earlier example it was :)
13:21:28 <Axman6> partyhard: no, the values of variables aren't computed until they're needed. that's a very different thing
13:21:48 <Ptival> partyhard: don't try to reason about the memory from the start :)
13:21:50 <partyhard> ah yes i remmember
13:22:01 <nand`> partyhard: haskell doesn't really have variables. You have functions and parameters. Functions are declared once and then they stay that way forever. Parameters are given to functions
13:22:08 <nand`> If anything, parameters = variables
13:22:11 <erus`> the stuff before => is called class constraints, yeah?  what is an instance of a constraint inside the body of the type called?
13:22:36 <nand`> essentially, the value of a parameter isn't evaluated unless it's absolutely needed
13:23:11 <Ptival> erus`: yes for your first question, and ??? for your second question
13:23:23 <partyhard> :)
13:23:26 <erus`> how the hell do generics work
13:23:36 <erus`> (implementation)
13:23:45 <partyhard> let (Just x) = Just 5 in x
13:24:01 <Ptival> class constraints become dictionaries
13:24:06 <partyhard>  i dont uderstand this concept.Thanks for the help appreciate it.:)
13:24:14 <elliott> erus`: which generics
13:24:17 <nand`> by generics do you mean types of kind * -> * (or higher)?
13:24:24 <elliott> nand`: unlikely
13:24:27 <elliott> probably ghc generics or syb
13:24:34 <sipa> or GADTs?
13:24:38 <erus`> id :: a => a -> a
13:24:40 <elliott> though i could be wrong :)
13:24:47 <sipa> erus`: you mean polymorphism?
13:24:48 <erus`> what kinda type system do i need to model that
13:24:51 <nand`> only meaning of “generic” I've heard is generics in C#, which is like List<T>, corresponding to haskell [] :: * -> *
13:24:59 <sipa> erus`: it is forall a. a -> a
13:25:02 <Ptival> erus`: what do you intend?
13:25:02 <sipa> not a => a -> a
13:25:03 <elliott> erus`: oh, is this about your lambda calculus thing?
13:25:08 <elliott> erus`: you want hindley-milner
13:25:17 <partyhard> dame you type fast nand
13:25:26 <elliott> it's polymorphism, not generics
13:25:31 <nand`> erus`: the left side of => needs two components, a type class and a type variable
13:25:39 <nand`> eg. c a => a -> a
13:25:41 <erus`> i cant really understand the wiki article  on it
13:25:50 <nand`> c is the class and a is some variable that, in this case, must be a member of the class c
13:26:10 <sipa> see c as a function from types to bools
13:26:30 <erus`> ah
13:26:46 <sipa> for example, Eq Int is true, because Int belongs to the class Eq
13:26:58 <elliott> i'm pretty sure erus` is talking about forall, guys :)
13:27:06 <elliott> given that the function name they used was "id"
13:27:15 <Ptival> I think he's talking about both and mixing them up :)
13:27:24 <elliott> hehe, perhaps
13:28:09 <Ptival> there are two polymorphisms in Haskell, the general one (forall t. ...) and the ad-hoc one (Class t => ...) which are really different beasts
13:28:18 <erus`> what does => look like in a type data structure ?
13:28:25 <mekeor> does "deriving (Foo,bar)" work with "newtype", too ?
13:28:29 <elliott> Ptival: erm, but the latter is a special of the former
13:28:38 <partyhard> Can somebody explain this - let (Just x) = Just 5 in x - it very confusing and my brain start to hurt.:)
13:28:40 <elliott> mekeor: yes (see also GeneralizedNewtypeDeriving which lets you derive any class for a newtype that the wrapped type has)
13:28:51 <Axman6> mekeor: only with the GeneralizedNewtypeDeriving extensions i believe
13:28:59 <elliott> erus`: it depends which => you are talking about
13:29:10 <elliott> Ptival: as in, C t => ... is actually forall t. C t => ...
13:29:19 <elliott> ...but of course haskell itself does not have any "forall", just ghc extensions :)
13:29:20 <Ptival> elliott: sure
13:29:32 <erus`> i just want forall first i guess
13:29:33 <elliott> Axman6: nah, you can still derive most classes without that
13:29:34 <mekeor> thanks, elliott and Axman6 :)
13:29:38 <elliott> that's why it's generalised :)
13:29:48 <elliott> erus`: data Type = ... | Forall VarName Type | ..., probably
13:29:48 <nand`> erus`: for forall you don't need =>
13:29:54 <elliott> same way you represent lambdas
13:29:54 <shachaf> elliott: Well, "C t =>" means something on its own, no matter how t is quantified.
13:29:58 <nand`> a -> a is the same as forall a. a -> a
13:30:01 <elliott> shachaf: Yes, indeed.
13:30:13 <adimit> partyhard: you're pattern-matching Just 5, stripping it of its type constructor, meaning you end up with 5 assigned to x.
13:30:22 <shachaf> You can also say forall a. C a => D a => a
13:30:46 <partyhard> whats pattern matching :)
13:30:51 <elliott> shachaf: hmm, can you really
13:30:55 <elliott> i mean
13:30:56 <nand`> suffice to say you can't use => without forall in haskell
13:30:59 <nand`> partyhard: something like
13:30:59 <elliott> foo :: C a => D a => a
13:31:02 <elliott> is that valid haskell2010?
13:31:13 <Ptival> erus`: one case of "forall in data structure" is just to have a parameterized data structure, for instance a List
13:31:13 <nand`> > let f 0 = "zero"; f 1 = "one"; f 2 = "two" in map f [0..2]
13:31:13 <shachaf> It's valid inmyghc2012.
13:31:14 <lambdabot>   ["zero","one","two"]
13:31:38 <elliott> partyhard: I would recommend continuing to read the Haskell tutorial; things like pattern matching are very fundamental, and will be explained probably better/more naturally than we can by whatever tutorial you're reading :)
13:31:47 <erus`> so i need a lambda/abstraction in my data type?
13:31:48 <adimit> partyhard: I recommend going through LYAH, because there's a ton of stuff to explain about pattern matching.
13:31:53 <nand`> partyhard: but you can also pattern match on data constructors
13:31:57 <Ptival> data List a = Nil | Cons a (* List a is defined "for all a" *)
13:32:06 <nand`> let [a,b,c] = map (+1) [0,1,2] in a+b+c
13:32:10 <nand`> > let [a,b,c] = map (+1) [0,1,2] in a+b+c
13:32:11 <lambdabot>   6
13:32:22 <nand`> in this example, a=1; b=2 and c=3
13:32:37 <adimit> partyhard: just in case you were wondering, no, the example you stated doesn't do anything useful, it just serves to illustrate pattern matching.
13:32:38 * Ptival is really bad at following interlaced discussions tonight @__@
13:32:45 <adimit> (on Maybe values.)
13:32:53 <Axman6> @where lyah
13:32:53 <lambdabot> http://www.learnyouahaskell.com/
13:32:59 <Axman6> partyhard: ^^^^^^^^^^^^^^^^^^^^^^^
13:33:07 <elliott> Axman6++
13:33:10 <Axman6> damn, that worked quite well, at least in my client =)
13:33:12 <ion> Axman7
13:33:20 <elliott> Axman7++
13:33:24 <elliott> Axman8--
13:33:25 <elliott> Axman7--
13:33:26 <Axman6> don't you mutate me D:
13:33:27 <elliott> back to normal
13:33:29 <partyhard> OK. Thanks guys. I hope this a start of a good friendship.:)
13:33:32 <nand`> Axman6: same; partyhard: see also http://tryhaskell.com/ for an interactive example; but I recommend LYAH - it's much much better
13:33:36 <Ptival> ain't so pure now
13:34:10 <shergill> @list
13:34:11 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:34:15 <nand`> Axman6++ = Bynbo7
13:34:16 <ion> with benefits
13:34:18 <ekipan> > case Just 5 of Just x -> x -- same thing, mostly (subtle difference in its strictness)
13:34:18 <lambdabot>   5
13:35:08 <nand`> ekipan: what's this about strictness?
13:36:05 <ekipan> I think let binding like that is, uh, what's the word
13:36:10 <adimit> nand`: let is "stricter," i.e. in ekipan's example, x will be a thunk, not actually 5 until you evaluate it.
13:36:52 <Peaker> I wonder if Haskell were simpler if it had: A) "record" instead of "newtype" (unlifted products, not just unlifted wrapper)  B) no "data", just anonymous sums (like OCaml variants) -- these are of course lifted
13:37:15 * cmccann wants unlifted sums
13:37:16 <nand`> and when pattern matching variables with let; they get evaluated immediately on matching them?
13:37:17 <Peaker> I guess GADTs kind of supercede B and anonymous variants
13:37:29 <Peaker> cmccann: that would not make Haskell *simpler* though :)
13:37:33 <partyhard> ok.:)
13:37:44 <ekipan> > (case Just 1 of Just 2 -> 3, let Just 1 = Just 2 in 3)
13:37:45 <lambdabot>   (*Exception: <interactive>:3:1-26: Non-exhaustive patterns in case
13:37:53 <elliott> Peaker: Tentative ++, I dislike the coupling between naming types and defining ADTs.
13:37:55 <OscarZ> Ptival: so in a type definition, forall a . a -> a is explicit way to say a -> a ?
13:37:55 <ekipan> > let Just 1 = Just 2 in 3
13:37:56 <lambdabot>   3
13:38:34 <Peaker> elliott: Perhaps with a "real" record system, you wouldn't need to define a record type either
13:38:48 <ekipan> > case Just 1 of ~(Just 2) -> 3 -- same semantics as the let afaiu
13:38:48 <lambdabot>   3
13:38:59 <elliott> Peaker: Well, we could just adopt structural type-style records.
13:39:15 <elliott> Peaker: We *do* want some way to "de-anonymise" a type, though.
13:39:23 <Peaker> elliott: Type synonyms :)
13:39:29 <elliott> That's not de-anonymised.
13:39:30 <nand`> partyhard: here's another example of pattern matching
13:39:34 <nand`> > let 1+1=3 in 1+1
13:39:35 <lambdabot>   3
13:39:37 <elliott> I mean in a way that ensures you don't mistake it for its representation.
13:40:00 <Peaker> elliott: You could wrap it in an anonymous record structure, with some data constructor
13:40:02 <partyhard> hmm :)
13:40:03 <adimit> don't confuse poor partyhard.
13:40:04 <cl1> what would be cool is if classes had value type parameters, e.g. you could use "MyConfigurationSettingValue" as a parameter, AND if modules had parametric types and value types as well
13:40:12 <partyhard> :D
13:40:15 <cl1> just a thought I had last night
13:40:19 * cmccann often wishes for inline anonymous sums, something like "data Foo = Foo A (B | Maybe C)"
13:40:22 <nand`> partyhard: that one's sneaky though, it's actually overwriting the (+) function with a new, local version that only works on 1 and 1
13:40:24 <nand`> for example
13:40:28 <cl1> ada has something similar
13:40:30 <nand`> > let 1+1=2 in 3+3
13:40:31 <lambdabot>   *Exception: <interactive>:3:4-8: Non-exhaustive patterns in function +
13:40:39 <Peaker> cmccann: I also with for unlifted products
13:40:41 <elliott> nand`: it's probably easier for both you and partyhard to read LYAH instead of learning pattern matching from IRC :P
13:40:44 <Peaker> wish*
13:40:56 <elliott> Peaker: well, structural type-style records don't have constructor names
13:40:57 <nand`> elliott: I don't think that example is mentioned in LYAH
13:41:07 <nand`> I brought it up because I think it's cool
13:41:18 <elliott> nand`: fair enough -- i wasn't paying much attention :)
13:41:23 <partyhard> its intersting that the equal sign when they change position is there any difference a
13:41:27 <Ptival> OscarZ: http://en.wikibooks.org/wiki/Haskell/Polymorphism#cite_note-0
13:41:42 <Peaker> elliott: ah.. then that's not what I want :)
13:41:43 <elliott> Peaker: oh, you could wrap it in an anonymous sum
13:41:58 <elliott> with only one element
13:42:03 <cmccann> I wonder how well it would work to have strictly anonymous products/sums, with special support for nullary constructors behaving like constructor names when they're the first type in a product
13:42:50 * cmccann adds enough hand-waving to make that seem vaguely plausible
13:42:50 <partyhard> nand it turn out an error for this example :/
13:42:51 <partyhard> let 1+1=2 in 3+3
13:42:52 <Peaker> elliott: that forces lifting.. not good for "newtype" like behavior
13:43:01 <elliott> Peaker: hmm, right
13:43:06 <elliott> Peaker: but aren't the records unlifted?
13:43:15 <elliott> so a sum with a record inside...
13:43:18 <Peaker> heh
13:43:19 <ekipan> partyhard: that's because that defines a new function named (+) that only works on the arguments 1 and 1
13:43:32 <elliott> serious suggestion :)
13:43:47 <Ptival> Peaker: I fail to see how OCaml variants are anonymous, can you explain just a bit please?
13:43:54 <ion> > let 1+1=3; 3+3=42 in [1+1, 3+3, 2+2]
13:43:55 <lambdabot>   [3,42,*Exception: <interactive>:3:4-16: Non-exhaustive patterns in function +
13:44:18 <Ptival> type foo = Bar of int | Baz of string
13:44:52 <partyhard> so the equal sign has to before 1+1
13:44:56 <Peaker> Ptival: I might be confusing matters - I've not used OCaml, I've only heard of it.  I heard that it has anonymous variants where you say: f :: (OneType | AnotherType) -> ..    and if you unify multiple functions, it will correctly intersect/union based on whether its a contra-variant or a co-variant position
13:45:16 <ekipan> the equal sign is part of the syntax of defining a function
13:45:18 <Ptival> oh, I've never used them if they exist
13:45:24 <Ptival> I'll check that
13:45:26 <ion> > let 1 ^-^ 1 = 3; 3 ^-^ 3 = 42 in [1^-^1, 3^-^3, 2^-^2]
13:45:27 <Peaker> Ptival: then if you case expression on the anonymous sum, your catch-all case will remain with a smaller sum, which is nice
13:45:27 <lambdabot>   [3,42,*Exception: <interactive>:3:4-28: Non-exhaustive patterns in function...
13:45:28 <elliott> Peaker: i think it's
13:45:30 <nand`> a=b defines b as a
13:45:32 <elliott> [`Foo of int | `Bar of string]
13:45:32 <elliott> or something
13:45:33 <nand`> err
13:45:37 <nand`> other way round
13:45:41 <nand`> a=b defines a as b
13:45:48 <nand`> it does *not* define b as a; therefore a=b and b=a are not the same
13:45:53 <nand`> don't confuse 1+1=2 and 2=1+1
13:46:02 <Ptival> elliott: polymorphic variants?
13:46:12 <ekipan> (let {definitions} in (expression)) -- <-- this makes up an expression, you can put it anywhere you would expect an expression, like in the middle of a bigger expression
13:46:12 <elliott> Ptival: dunno :)
13:46:44 <Ptival> elliott: these are such that the constructor `Foo can be part of multiple types
13:46:52 <ekipan> any names defined within the let clause scope over the in clause, and only there
13:46:56 <Ptival> I believe*
13:47:00 <partyhard> aha now i understand nand
13:47:12 <elliott> Ptival: right
13:47:26 <nand`> 1+1=2 can be rewritten as (+) 1 1 = 2
13:47:42 <Ptival> so they are anonymous in the sense that they do not enforce the type such as Nil and Cons enforce List?
13:47:44 <ekipan> or you could give it a less confusing name: newPlus 1 1 = 2
13:47:50 <nand`> ^ was abotu to do that
13:48:11 <ekipan> > let foo 1 1 = 2 in foo 3 3 -- this causes an error, you see why?
13:48:11 <lambdabot>   *Exception: <interactive>:3:4-14: Non-exhaustive patterns in function foo
13:48:16 <Ptival> s/such as/whereas
13:48:17 <nand`> let p 1 1 = 3 in 1 `p` 1
13:48:41 <partyhard> 'p' is a caracter
13:48:42 <cl1> if haskell has c interaction and ada has c interaction, one would think I could do all my c-ish stuff in ada instead, correct?
13:48:44 <partyhard> right
13:48:49 <nand`> p is a name in this case
13:48:53 <nand`> oh wait
13:48:57 <nand`> you meant `p`?
13:49:01 <partyhard> yes
13:49:05 <Nereid> p is no different from (+)
13:49:07 <Ptival> > let 2 + 2 = 5 in 2 + 2 (* the usual mind bender *)
13:49:07 <lambdabot>   <no location info>: parse error on input `)'
13:49:11 <Peaker> here's an idea I didn't think through:
13:49:12 <nand`> f a b = a `f` b
13:49:13 <Peaker> type (a, b) = Fst a * Snd b -- giving a name to an anonymous product, data constructors also serve as field names
13:49:13 <Peaker> type Maybe a = (Nothing | Just a) -- giving a name to an anonymous sum
13:49:14 <nand`> same thing
13:49:15 <Nereid> > 1 `(+)` 1
13:49:16 <lambdabot>   <no location info>: parse error on input `('
13:49:16 <Ptival> arg @__@
13:49:20 <Nereid> heh.
13:49:23 * Ptival is doing too much OCaml
13:49:50 <Ptival> > let 2 + 2 = 5 in 2 + 2    -- the usual mind bender
13:49:51 <lambdabot>   5
13:50:17 <ekipan> > (+1) `map` [2,3,4] -- it's just syntax that lets you use an ordinary function name as an infix operator
13:50:17 <lambdabot>   [3,4,5]
13:50:23 <zachk> > [1 + 1 == 2 , (+) 1 1 == 2 , (+ 1) 1 == 2, (1 +) 1 == 2 ]
13:50:24 <lambdabot>   [True,True,True,True]
13:50:45 <sipa> > let (>>) = (+) in do {2; 3}
13:50:46 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
13:50:47 <lambdabot>    arising from a u...
13:50:58 <Ptival> Peaker: I think this is indeed relevant to OCaml's polymorphic variants
13:51:08 <partyhard> it interesting it no different from previous example let 1+1=2 in 3+3 but this one turn out an error
13:51:17 <ion> > (==) ((+) 1 1) (2 3)
13:51:18 <lambdabot>   True
13:51:59 <Nereid> lol
13:52:05 <Nereid> > 2 x
13:52:06 <partyhard> :)
13:52:06 <lambdabot>   2
13:52:09 <DanBurton> wat
13:52:11 <Ptival> ion is overbending my mind
13:52:22 <elliott> > 2 (+) 2
13:52:22 <lambdabot>   2
13:52:22 <Nereid> @type 2
13:52:23 <lambdabot> forall t. (Num t) => t
13:52:36 <Ptival> @type (+)
13:52:37 <lambdabot> forall a. (Num a) => a -> a -> a
13:52:37 <DanBurton> since when is 2 a function?
13:52:46 <cmccann> since lambdabot has a Num instance for functions
13:52:49 <cmccann> apparently
13:52:53 <nand`> heh
13:52:54 <ion> ptival: Ignore that, i was abusing Caleskell.
13:52:56 <nand`> that's interesting
13:53:10 <Ptival> crazy defaulting and instances?
13:53:14 <Ptival> meh
13:53:15 <partyhard> let 2 + 2 = 5 in 2 + 2 in this example whats the name and whats the expression
13:53:18 <DanBurton> lambdabot's num instance for functions should be church numerals
13:53:19 <ion> No, just crazy instnces.
13:53:29 <Ptival> k
13:53:33 <nand`> partyhard: + is the name
13:53:37 <cmccann> DanBurton, sounds good to me
13:53:55 <Ptival> partyhard: this is a partial definition of the infix function +, where we define only the result for the input 2 and 2
13:54:00 <nand`> + is defined as a function, that when given arguments 2 and 2, returns the expression 5; this function is then used in the expression 2 + 2
13:54:15 <Ptival> and then we apply said function to the only input for which we have defined it, that is 2 and 2
13:54:17 <nand`> if given anything other than 2 and 2, the function doesn't have anything defined
13:54:19 <nand`> therefore haskell cries
13:54:33 <partyhard> so you could write it let x=5 in x
13:54:37 <elliott> I think we have somehow collectively managed to make partyhard more confused about let...in than they were when we started out.
13:54:39 <nand`> yes
13:54:41 <partyhard> same thing ?
13:54:45 <nand`> more or less
13:54:45 <Ptival> > let x = 5 in x
13:54:46 <lambdabot>   can't find file: L.hs
13:54:56 <DanBurton> @define toChurch :: Int -> ((a -> a) -> a -> a); toChurch n f x = iterate f x !! n
13:55:08 <Ptival> L.hs?
13:55:10 <Ptival> wat?
13:55:12 <geekosaur> *blink*
13:55:13 <DanBurton> wait did lambdabot just die?
13:55:20 <nand`> > 0
13:55:21 <lambdabot>   0
13:55:26 <Ptival> > let x = 5 in x
13:55:26 <nand`> > let x = 5 in x
13:55:26 <lambdabot>   5
13:55:26 <Axman6> @undefine
13:55:27 <lambdabot>   5
13:55:30 <nand`> there we go
13:55:31 <elliott> DanBurton: No.
13:55:33 <Ptival> he's back :)
13:55:33 <ion> She just blinked.
13:55:35 <partyhard> :D
13:55:37 <geekosaur> L.hs is used internally for @let
13:55:38 <Ptival> oh he's a she
13:55:39 <nand`> lambdabot is a she?
13:55:42 <DanBurton> she blinked on me
13:55:45 <DanBurton> @wiki lambdabot
13:55:45 <lambdabot> http://www.haskell.org/haskellwiki/lambdabot
13:55:50 <geekosaur> (and @undefine, which apparently fixed it)
13:55:56 <DanBurton> see wiki for her picture
13:55:56 <elliott> @define I'm pretty sure it's @let.
13:56:01 <Axman6> nah it was fixed before that
13:56:06 <DanBurton> elliott: oh right
13:56:11 <DanBurton> @let toChurch :: Int -> ((a -> a) -> a -> a); toChurch n f x = iterate f x !! n
13:56:12 <lambdabot>  Defined.
13:56:17 <partyhard> its very intersting that the operator + is the name, are 2 and 2 the argumnet the
13:56:20 <donri> fucking straight geeks always pretending bots are female
13:56:28 <partyhard> let 2+2 = 5 in 2+2
13:56:29 <nand`> > toChurch 5 (+1) 0
13:56:31 <lambdabot>   5
13:56:43 <partyhard> then
13:56:52 <wvoq> hello, all.  Supposing that I have a datatype consisting of monoids, typing "deriving Monoid" seems like a natural thing to do
13:56:59 <wvoq> making the datatype a product monoid
13:57:07 <DanBurton> donri: or chauvinistic gays, perhaps?
13:57:07 <cheater_> @vixen
13:57:08 <lambdabot> The press is the enemy.
13:57:10 <wvoq> but this is forbidden
13:57:20 <cmccann> wvoq, a product type I assume you mean
13:57:32 <partyhard> could you also writte it let (+) 2 2 = 5 in 2+2
13:57:32 <donri> DanBurton: you're right, that was a sexist assumption on my part
13:57:44 <wvoq> cmccann: well yes, a product type that has a product monoid structure, no?
13:57:47 <cheater_> @eliza
13:57:48 <lambdabot> Say again?
13:57:48 <nand`> now somebody can go ahead and write a Num instance for (a -> a) -> a -> a
13:57:49 <donri> wvoq: you can for newtypes
13:57:51 <cheater_> hmm.
13:57:54 <cmccann> wvoq, and yes that would make sense for product types but the whole deriving thing is kind of ad hoc magic baked into the language
13:57:59 <donri> wvoq: with -XGenericNewtypeDeriving
13:58:17 <shergill> curious, but who runs lambdabot?
13:58:24 <elliott> cale
13:58:28 <wvoq> donri: thanks kindly
13:58:37 <nand`> I'd like a deriving (Random) as well, personally
13:58:38 <wvoq> cmccann: I admit this
13:58:49 <DanBurton> @where cale
13:58:50 <lambdabot> I know nothing about cale.
13:58:53 <partyhard> I thought the name come first and then the expression in let why is it written then in 2+2
13:58:57 <donri> > let (+) 2 2 = 5 in 2+2
13:58:57 <DanBurton> lambdabot lies
13:58:58 <lambdabot>   5
13:59:05 <partyhard> and that the plus sign is the name
13:59:05 <cmccann> wvoq, I think there are TH packages that do automagic deriving
13:59:06 <wvoq> cmccann: but what's the trouble, really?
13:59:09 <Ptival> partyhard: indeed
13:59:21 <nand`> partyhard: + is an operator so it doesn't have to be first, simply put
13:59:27 <cmccann> wvoq, the trouble is that it's baked into the language definition and nobody bothered to think of every possible deriving trick
13:59:27 <Ptival> > let 2 <*| 2 = 42 in (<*|) 2 2
13:59:28 <lambdabot>   42
13:59:29 <nand`> a+b is sugar for (+) a b
13:59:32 <wvoq> cmccann: I think that's what I found here: http://hackage.haskell.org/packages/archive/derive/0.1.1/doc/html/Data-Derive-Monoid.html
13:59:33 <zachk> partyhard: in Haskell every function only takes one argument
13:59:34 <nand`> same with a-b, a*b and so forth
13:59:34 <wvoq> it just looks scary
13:59:51 <partyhard> why is it then a name
14:00:03 <nand`> it's the name of the function defined in let
14:00:04 <zachk> partyhard: that function though can be another function
14:00:07 <cmccann> wvoq, in other words there probably isn't any real reason
14:00:11 <partyhard> a-b are three argumnets
14:00:18 <Ptival> > let ($+@) 2 2 = 42 in 2 $+@ 2
14:00:19 <lambdabot>   42
14:00:22 <nand`> no
14:00:32 <nand`> a-b is (-) a b; there are two parameters here: a and b
14:00:33 <wvoq> cmccann: I see.  Thanks for the advice!
14:00:38 <nand`> (-) is not a parameter, it's the function name
14:00:42 <ion> @type (-)
14:00:43 <lambdabot> forall a. (Num a) => a -> a -> a
14:00:44 <ion> @type (-) 2
14:00:45 <lambdabot> forall t. (Num t) => t -> t
14:00:45 <ion> @type (-) 2 3
14:00:46 <lambdabot> forall t. (Num t) => t
14:00:48 <ddarius> newtype T a = T (a -> Bool) deriving Monoid-
14:00:54 <cheater_> @type (@)
14:00:55 <lambdabot> parse error on input `@'
14:01:12 <zachk> > (flip (-)) 2 4
14:01:13 <lambdabot>   2
14:01:17 <partyhard> nameofallgo 2+2
14:01:20 <shergill> is there a way to specify ghc LANGUAGE OPTIONS in a file as opposed to passing them on the command line? or do you use environment variables?
14:01:21 <Ptival> > let (-) = (+) in 2 - 2
14:01:22 <lambdabot>   4
14:01:23 <partyhard> what the name here
14:01:37 <nand`> Ptival: that's a fun one
14:01:38 <ion> {-# LANGUAGE PHP #-}
14:01:39 <zachk> shergill: lookup pragmas
14:01:45 <donri> shergill: {-# LANGUAGE ... #-}
14:02:01 <shergill> zachki, donri: i want it to be enabled for multiple files
14:02:05 <shergill> a common configuration
14:02:08 <shergill> for ghci
14:02:10 <cmccann> shergill, use cabal?
14:02:13 <donri> shergill: you can also use cabal and list extensions used by all/many of your modules
14:02:22 <cmccann> oh, if you want stuff in GHCi that's different
14:02:32 <nand`> > let _ + _ = 3 in 1+1 -- partyhard
14:02:32 <lambdabot>   3
14:02:38 <shergill> yeah, wanted it for ghci. know a way?
14:02:44 <DanBurton> ion: that is just creepy
14:02:52 <cmccann> shergill, you can set them from the REPL prompt
14:02:54 <donri> shergill: :set -Xbla in your ~/.ghci
14:02:56 <cmccann> and use a .ghci file
14:02:58 <sipa> ion: blasphemy!
14:03:18 <elliott> {-# LANGUAGE INTERCAL #-}
14:03:25 <elliott> PLEASE DO ...
14:03:25 <shergill> is the .ghci file location stored in an env variable?
14:03:27 <nicoo> hi
14:03:27 <nand`> {-# LANGUAGE UNLAMBDA #-}
14:03:28 <nand`> hard mode
14:03:33 <elliott> shergill: no, it's just $HOME/.ghci
14:03:41 <shergill> hmm that's problematic
14:03:41 <cmccann> elliott, PLEASE DON'T GIVE UP
14:03:48 <elliott> it is?
14:03:50 <elliott> nand`: {-# LANGUAGE INTERCAL, Unlambda #-}
14:03:56 <rwbarton> you can also put a .ghci file in your project directory I think
14:04:06 <nand`> ```s`kk`sss`k`k`PLEASE`s`s`k?
14:04:07 <shergill> i have multiple projects and am using virthualenv for sandboxing
14:04:18 <shachaf> rwbarton: Are you going to show up?
14:04:28 <copumpkin> omg a rwbarton
14:04:28 <cmccann> why not {-# LANGUAGE LazyK #-} ?
14:04:32 <rwbarton> shachaf: Maybe, not sure yet...
14:04:35 <shergill> i'd like ghci to be able to pick up the language options automatically
14:04:38 <elliott> cmccann: lazy k uses lazy io!
14:04:46 <elliott> that's evil, even if unlambda is strict
14:05:06 <partyhard> nand what does underscore mean
14:05:08 <copumpkin> rwbarton: we'll catch you eventually
14:05:13 <cmccann> elliott, no it doesn't, it just transforms an input to an output
14:05:14 <rwbarton> yes
14:05:14 <sipa> partyhard: "anything"
14:05:15 <nand`> partyhard: ignore this variable
14:05:28 <partyhard> is this a special operator
14:05:39 <sipa> no it is a special pattern
14:05:41 <elliott> cmccann: by that argument, interact doesn't use lazy io
14:05:46 <elliott> it just transforms an input to an output
14:05:47 <partyhard> :D
14:05:52 <elliott> lazy k is specified to use lazy io :)
14:06:22 <cmccann> elliott, yes, but Haskell isn't a pathological esoteric language that can get away with lame excuses like that
14:06:36 <nand`> let f 0 = "no"; f 1 = "one"; f 2 = "two"; f _ = "many"  in map (++" apples") .  map f [1,2,3,4]
14:06:38 <shachaf> Lazy K could do Haskell-style IO too.
14:06:41 <cmccann> anyway, it's not precisely lazy IO in the haskell sense
14:06:42 <nand`> > let f 0 = "no"; f 1 = "one"; f 2 = "two"; f _ = "many"  in map (++" apples") .  map f [1,2,3,4]
14:06:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:06:43 <lambdabot>         against inferred ty...
14:06:45 <elliott> cmccann: It isn't?
14:06:50 <partyhard> in these example nand there only values no varibale
14:06:52 <elliott> cmccann: I mean, pathological, check, esoteric, check...
14:06:57 <elliott> "Language", debatable.
14:06:58 <nand`> > let f 0 = "no"; f 1 = "one"; f 2 = "two"; f _ = "many"  in map (++" apples") .  map f $ [1,2,3,4]
14:07:00 <lambdabot>   ["one apples","two apples","many apples","many apples"]
14:07:03 <partyhard> can you writte some with x
14:07:06 <Ptival> > let 2 + 2 = 6 * 7 :: Expr in 2 + 2
14:07:06 <nand`> oops, one apples
14:07:07 <lambdabot>   6 * 7
14:07:07 <nand`> oh well
14:07:11 <partyhard> with underscore
14:07:29 <nand`> partyhard: ignore this parameter*
14:08:05 <qpu> Ptival: where is Expr defined?
14:08:18 <nand`> > let f x _ z = x + z in f 1 2 3 -- partyhard
14:08:19 <lambdabot>   4
14:08:20 <cmccann> Lazy K's IO has more in common with Haskell's pre-monad version of IO I think
14:08:23 <shergill> ah the .ghci looks in current directory as well. that works. thanks, donri, elliott
14:08:36 <donri> \o/
14:08:39 <shergill> *the .ghci file is searched for
14:08:53 <shergill> apparently sleepy brain can't do english, but can maths
14:08:55 <elliott> cmccann: i don't think so; it's [Word8] -> [Word8]
14:08:59 <elliott> stdin -> stdout
14:09:06 <elliott> just represented as a church list of church numerals
14:09:12 <partyhard> One last question -- let take5s = filter (==5) in take5s [1,5,2,5,3,5] in this example whats the name and the expression
14:09:14 <partyhard> :)
14:09:15 <elliott> so it's just like interact
14:09:23 <Ptival> qpu: https://github.com/seliopou/lambdabot/blob/master/Plugin/Free/Expr.hs ?
14:09:51 <nand`> paradigm: take5s is the name
14:09:57 <cmccann> I don't think you could imitate unsafeInterleaveIO completely, because there's no way to do "IO" via spooky action at a distance
14:10:01 <nand`> it's defined to “filter (==5)”
14:10:10 <nand`> the same thing could have been written as
14:10:11 <elliott> cmccann: well, no, but it _is_ getContents
14:10:17 <nand`> > filter (==5) [1,5,2,5,3,5]
14:10:18 <lambdabot>   [5,5,5]
14:10:20 <qpu> Ptival: neat, thanks!
14:10:42 <elliott> cmccann: it's lazy io, even if it's not the-full-complete-power-of-haskell-lazy-io :P
14:10:44 <Ptival> qpu: I don't know if it resides somewhere in GHC...
14:10:49 <Ptival> don't think so :\
14:10:58 <qpu> i couldn't find it on my local hoogle
14:11:19 <nicoo> Would somebody know if there is a git tracking plugin for lambdabot ?
14:11:22 <cmccann> elliott, yes, it's missing the part that makes lazy IO so dubious :P
14:11:30 <elliott> Ptival: qpu: that's not the right Expr.
14:11:36 <elliott> http://hackage.haskell.org/packages/archive/show/0.4.1.2/doc/html/SimpleReflect.html
14:11:44 <Ptival> oh sorry
14:11:46 <elliott> cmccann: you don't think getContents is dubious?
14:12:03 <elliott> cmccann: I mean, the input requests *are* directed by evaluation in Lazy K
14:12:04 <Ptival> I read lambdabot and Expr and didn't check =__=
14:12:13 <qpu> i wondered where the Num instance went… :)
14:12:22 <nand`> what does getContents do? read from Stdin until EOF?
14:12:32 <elliott> http://hackage.haskell.org/package/simple-reflect also has it
14:12:36 <partyhard> Buy.:)
14:12:37 <partyhard> Thanks nand. I appreciated your help you have bean very helpful  and patient.Appreciate it.
14:12:38 <elliott> but the show package version is the one lambdabot uses :)
14:12:39 <Ptival> thanks elliott
14:12:39 <cmccann> elliott, but you can't hide it in "pure" code in Lazy K
14:12:41 <elliott> nand`: lazily
14:12:47 <partyhard> Bye.:P
14:12:48 <elliott> cmccann: why not?
14:13:03 <nand`> partyhard: no problem, be sure to check out LYAH
14:13:20 <partyhard> I will.:)
14:13:35 <nand`> elliott: neat, so if I want the first 50 characters of input I'll just liftM (take 50) getContents
14:13:50 <elliott> nand`: it's not neat, it's lazy IO and it's evil :P
14:14:00 <elliott> lots of resource allocation issues
14:14:18 <cmccann> elliott, because you have to pass the input stream around to use it
14:14:38 <cmccann> there's no magic "read from input" function
14:14:42 <shachaf> elliott: Did you hear conal arguing for lazy I/O the other day?
14:14:46 <elliott> cmccann: hmm... do you consider interact lazy IO?
14:15:08 <elliott> because lazy K IO is literally just interact, so maybe i'm confused as to where we're disagreeing :)
14:15:12 <elliott> shachaf: Nope.
14:16:51 <nand`> elliott: then what would I use? sequence $ replicate 10 getChar?
14:17:09 <cmccann> elliott, interact is obviously implemented in terms of lazy IO in Haskell but I think if you defined it as a primitive it would have important differences vs. lazy IO in general
14:17:11 <Peaker> nand`: replicateM does the sequence-after-replicate dance
14:17:14 <elliott> nand`: that works, yep... you can have a more consistent interface using iteratees/conduits/whatever
14:17:23 <elliott> which are designed as solutions to the lazy IO problem
14:17:40 <Ptival> what is the lazy IO problem? :)
14:17:41 <elliott> cmccann: Fair enough -- but it still means that you can cause getchar() to be called or not called based on how much and when you force your argument.
14:17:46 <elliott> That's the essence of lazy IO, if you ask me.
14:17:53 <elliott> Ptival: the problem is that it sucks :P
14:18:06 <shachaf> Our essential bodily fluids.
14:18:08 <Ptival> elliott: I like it for fun
14:18:20 <Peaker> Ptival: I want to demonstrate some Haskell coolness to coworkers
14:18:39 <Peaker> Ptival: I make a little "withTimeout" action that does a forkIO of a threadDelay, and kills your thread if timeout passes
14:18:41 <cmccann> elliott, I don't see the I/O streams in this case as fundamentally different than constructing an IO action in Haskell I guess
14:18:52 <Peaker> Ptival: Then I demonstrate it with "getContents".. and it of course breaks
14:19:11 <cmccann> elliott, in that doing particular things with "special" values defines the behavior of the program as a whole
14:19:18 <Peaker> Ptival: because of lazy I/O. Lazy I/O is one more annoyance I have to think about when writing and demonstrating Haskell
14:19:34 <Peaker> it makes the IO semantics of our programs pretty horrible
14:19:43 <Ptival> :)
14:19:47 <elliott> cmccann: IO in general doesn't do that without things like observable sharing or unsafeInterleaveIO, does it?
14:19:47 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
14:20:02 * Ptival admits he likes lazy IO because he never used it for real
14:20:31 <Peaker> Having no error reporting semantics is also pretty annoying
14:20:55 <geekosaur> lazy IO is great for small stuff, then you start encountering the cases where it breaks and you have no control over it
14:21:07 <geekosaur> and no way to find out that it broke, even
14:21:25 <cmccann> elliott, I'm comparing "consuming the input stream" in Lazy K more to using IO in the normal way, not sure what you mean
14:21:43 <srhb> If I need to grab a web page from Haskell, what library should I use?
14:21:47 <srhb> As a String, I mean.
14:21:50 <elliott> cmccann: fair enough -- I agree you can consider lazy K programs as impure, but it means that the language you end up considering isn't referentially transparent, etc.
14:21:52 <elliott> er
14:21:57 <elliott> *as not using lazy IO
14:22:05 <elliott> because evaluation order matters
14:22:05 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
14:22:16 <elliott> lambdabot: You just told me I had a message!
14:22:28 <Ptival> such an attention whore
14:22:31 <cmccann> geekosaur, I'd say that lazy IO works okay for very specific scenarios, particularly those where you aggressively don't care about how input is managed
14:22:47 <srhb> IO String, rather.
14:23:23 <Peaker> cmccann: it's not only that -- it's also not caring which thread does the input
14:23:25 <geekosaur> cmccann, I was thinking the equivalent of shell one-liners; but I think we're saying the same thing...
14:23:38 <geekosaur> "throwaway crap"
14:23:52 <Peaker> cmccann: and whenever you start delving with cute concurrency combinators in Haskell, lazy I/O becomes an even bigger PITA
14:23:53 <cmccann> geekosaur, I'm including "very elaborate one-liners" basically :P
14:24:11 <geekosaur> you've never seen my shell one-liners :)
14:24:22 <cmccann> heh
14:25:06 <cmccann> Peaker, I would count "having multiple threads using the input" as caring how input is managed
14:25:24 <Peaker> cmccann: the multiple threads don't necessarily even know that it's user input
14:27:39 <somaya> what programming languages where used to write tryhaskell.org? :)
14:27:53 <shirt> somaya: java and visual basic
14:28:11 <elliott> :D
14:28:14 <elliott> somaya: Haskell.
14:28:28 <shachaf> JavaScript.
14:28:43 <cmccann> elliott, yeah, now that I think about it I guess you can make things murky if you have the input stream being consumed in too many places
14:29:02 <somaya> i like how javascript is implemented there :) so elegant :)
14:29:57 <cmccann> elliott, it would be pretty trivial to make IO in Lazy K well-behaved though, which isn't something you can really do with lazy IO in general
14:30:24 <somaya> and the one who came up with the idea of chatting and trying the tutorial is genius :)
14:30:28 <elliott> cmccann: sure it is, it's called deepseq :)
14:30:28 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
14:30:37 <elliott> lambdabot: Oh, come on.
14:30:39 <cmccann> haha
14:31:21 <shergill> @help messages
14:31:22 <lambdabot> messages. Check your messages.
14:32:38 <cmccann> elliott, I don't think deepseq applied to a lazy input stream is really what you'd want :P
14:33:02 <cmccann> elliott, are you familiar with the interleaved version of a list monad transformer?
14:35:21 <irene-knapp> :t unfoldr
14:35:22 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:35:22 <cmccann> with lazy K, or interact for that matter, you could treat the I/O streams in a similar way by preventing "pure" functions from having access to the raw I/O streams
14:35:24 <irene-knapp> :t unfoldl
14:35:25 <lambdabot> Not in scope: `unfoldl'
14:35:30 <irene-knapp> @hoogle unfoldr
14:35:31 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
14:35:31 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
14:35:31 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
14:37:22 <NothingMan65___> Good evenin everyone.
14:37:37 <NothingMan65___> I really wanna get going with Haskell, but I'm getting stuck on the basics.
14:37:53 <ion> Have you read LYAH?
14:38:04 <cmccann> NothingMan65___, getting past the basics is usually the hardest part of learning Haskell, heh
14:39:04 <NothingMan65___> No I haven't ion, but maybe I can just ask.  I'm trying to write a VERY simple hs file, which could printout a list of integers.  I would be happy with printing [1..5]
14:39:18 <ion> print [1..5]
14:39:20 <cmccann> heh
14:39:21 <ion> @where lyah
14:39:21 <lambdabot> http://www.learnyouahaskell.com/
14:39:36 <cmccann> well, "main = print [1..5]" I guess
14:40:30 <NothingMan65___> Okay, super.  What about main :: IO (), do I need to worry about that right now?
14:40:40 <cmccann> that's just the type signature
14:40:46 <cmccann> it's not required
14:40:46 <elliott> NothingMan65___: I second the recommendation of LYAH :)
14:40:56 <NothingMan65___> Aight, I'll stop asking questions.
14:40:57 <NothingMan65___> Thanks
14:40:58 <cmccann> but you should probably give LYAH or something similar a go
14:41:00 <ekipan> @type print [1..5]
14:41:01 <lambdabot> IO ()
14:41:05 <ion> Also, tryhaskell
14:41:06 <NothingMan65___> *done*
14:41:08 <ion> @where tryhaskell
14:41:09 <lambdabot> http://tryhaskell.org/
14:41:21 <elliott> <cmccann> with lazy K, or interact for that matter, you could treat the I/O streams in a similar way by preventing "pure" functions from having access to the raw I/O streams
14:41:27 * ddarius recommends starting at GW-BASIC and then moving on to QBASIC.  Two BASICs down, several dozen to go.
14:41:30 <elliott> cmccann: I'm not quite sure I understand what you're proposing there
14:41:41 <ion> nothingman65: Don’t stop asking questions. :-P
14:41:49 <sipa> ddarius: that's how i started!
14:43:36 <cmccann> elliott, maybe a quick example would be simpler
14:44:16 <nand`> NothingMan65___: I'd recommend ignoring main and indeed ghc itself, and focusing mainly on ghci for about the first 10 chapters or so of learnyouahaskell
14:44:23 <nand`> that's what it mentions as well, in fact
14:49:23 <akosch> I started with C64 ASM, but I can't say it was useful for learning haskell
14:49:51 <ddarius> akosch: You can't say that it wasn't useful for learning Haskell.
14:50:12 <elliott> Haskell is basically just a 6502 with a lambda calculus coprocessor.
14:50:13 <akosch> ddarius: I sure can't ;)
14:50:24 <mekeor> is there a function which takes a list (e.g. [1,2,3,4,5]) and returns all possible sub-lists (not respectin the order) (that is in the example, [[1],[1,2],[1,3],[1,4],[1,5],[2],[2,3],[2,4],[2,5],[3],[3,4],[4],[4,5],[5],[1,2,3],[2,3,4],[3,4,5]] ?
14:50:31 <mekeor> elliott: 6502 ?
14:50:41 * geekosaur doesn't think haskell would get very far with a stack constrained to page 2 :p
14:50:45 <elliott> mekeor: http://en.wikipedia.org/wiki/MOS_Technology_6502
14:52:13 <c_wraith> > filterM (return [False, True]) [1,2,3,4,5]
14:52:14 <lambdabot>   [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,...
14:52:27 <mekeor> @src filterM
14:52:28 <akosch> I don't think self-modifying code fits with the haskell philosophy though
14:52:28 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:52:46 <c_wraith> :t filterM
14:52:47 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:52:59 <elliott> akosch: Isn't that what graph reduction is?
14:53:07 <qpu> mekeor: perhaps http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:subsequences
14:53:14 <mekeor> c_wraith: is that really what i am looking for?
14:53:38 <akosch> elliott: hm, I'm not sure what you mean
14:53:39 <c_wraith> mekeor: it is essentially a powerset operation
14:53:39 <elliott> > subsequences [1,2,3,4,5]
14:53:40 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
14:53:50 <elliott> akosch: Well, id 42 rewrites itself into 42.
14:53:54 <mekeor> qpu: thank you!
14:53:57 <elliott> repeat 42 rewrites itself into 42 : repeat 42, etc. :)
14:55:22 <akosch> elliott: well kinda, still it's not the same :)
14:55:43 <qpu> the kind of self-modifying code typical of hand-written assembly is pretty wild
14:56:08 <qpu> guy steele's keynote from Strange Loop 2010 had some great examples
14:56:25 <akosch> elliott: when you use counters for flow control, it's a bit of a Russian roulette
14:56:48 <qpu> crazy tricks to get your code to fit on one punch card :]
14:57:26 <qpu> the first part of this: http://www.infoq.com/presentations/Thinking-Parallel-Programming
14:57:57 <ion> I hear C64 demos use code-generating code a lot.
14:59:06 <akosch> ion: yeah, I always though of demos as an arcane art
14:59:50 <akosch> ion: nowadays I like to imagine it like this: http://4.bp.blogspot.com/_VPeUj6_-i8E/Sn-ljp3UfmI/AAAAAAAABl8/IeffWr1VecY/s400/Pig_onl_03.JPG
14:59:58 <qpu> haha
15:00:27 <ion> hah
15:01:09 <akosch> at the same time lisp code looks like this now: http://www.myjewishlearning.com/blog/wp-content/uploads/2009/12/r-crumb-genesis.jpg
15:01:46 <akosch> apply / eval ;)
15:04:12 <grwip> hi there, quick question: how can I extract more than 15 digits after the decimal point of a double?
15:05:06 <dolio> :t showFFloat
15:05:07 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
15:05:40 <dolio> > showFFloat (Just 60) 1 ""
15:05:41 <lambdabot>   "1.000000000000000000000000000000000000000000000000000000000000"
15:05:46 <grwip>  showFFloat (Just 100) (pi) "" -> "3.1415926535897930000000000000000000000000000000000000000000000
15:05:57 <grwip> > showFFloat (Just 100) (pi)
15:05:58 <lambdabot>   Overlapping instances for GHC.Show.Show
15:05:58 <lambdabot>                              (GHC.B...
15:05:59 <geekosaur> grwip, do you know that there's anything more to be extracted?
15:06:04 <ion> > showFFloat (Just 100) (pi :: CReal) ""
15:06:05 <lambdabot>   "*Exception: CCeal.floatRadix
15:06:26 <c_wraith> grwip: are you aware that we can't get more than 15 digits precision on any real-world measurement?
15:07:09 <grwip> geekosaur, c_wraith: it's one of the euler project problem, find the longest cycle in decimal digits for 1/d with d <- [1..1000]
15:07:26 <c_wraith> oh.
15:07:30 <c_wraith> don't use floats for that
15:07:31 <grwip> I think I may expect to find sequences longer than 15 digits
15:07:32 <c_wraith> or doubles
15:07:45 <c_wraith> they both are flawed
15:07:50 <c_wraith> you need exact precision
15:07:59 <grwip> ok, what do I use for that?
15:08:03 <elliott> <ion> > showFFloat (Just 100) (pi :: CReal) ""
15:08:03 <elliott> <lambdabot>   "*Exception: CCeal.floatRadix
15:08:05 <elliott> CCeal? :)
15:08:16 <c_wraith> you could use Rational, but it's best to just do the work directly for this problem, I think
15:08:17 <geekosaur> you want rationals, I think.  floating point explicitly limits precision, typically to 64 bits which is appropximately 15 decimal digits
15:08:23 <ion> elliott: Hah
15:08:24 <geekosaur> or, that
15:09:07 <c_wraith> grwip: think of how you detect cycles in doing long division by hand.
15:09:08 <geekosaur> actually 48 bits; the other 8 are the exponent
15:09:28 <c_wraith> grwip: then implement that in your code
15:09:30 <grwip> I do that to learn haskell, so I try to avoid paper...
15:09:44 <grwip> oh ok, I understand what you mean
15:10:02 <grwip> thanks for the help, and I heard about CReal now so I'll have a look at that
15:10:07 <c_wraith> don't use CReal
15:10:11 <c_wraith> it's very bad for this
15:10:15 <c_wraith> Rational is better
15:10:21 <c_wraith> but still not as good as just solving the problem
15:10:41 <ion> Avoiding thinking of how to do something by hand isn’t a great goal when learning a programming language.
15:10:55 <grwip> yes right, bad choice of word
15:10:55 <c_wraith> especially for project euler
15:11:09 <c_wraith> project euler is almost entirely about "do you know math" rather than "do you know how to program"
15:11:31 <grwip> I know math but I try to get more familiar with haskell
15:11:41 <elliott> i think grwip meant that they wanted to solve the problem with haskell, not on paper
15:11:47 <elliott> before seeing "then implement that in your code"
15:11:48 <qpu> RWH or LYAH books are good for learning Haskell
15:12:01 <jtbates> Hello, I'm running XMonad on Mac OS 10.6 (Snow Leopard).  It will run with no config file, but if I try to use one it crashes X11 (and for some reason the X11 app will continuously restart).
15:12:12 <qpu> (just another suggestion, if you get bored with euler)
15:12:14 <grwip> elliott: right, thanks
15:12:21 <mekeor> jtbates: #xmonad
15:12:24 <hpaste_> pradeep3013 pasted “tuple Eq ignore” at http://hpaste.org/56755
15:12:37 <grwip> qpu: I did LYAH, I'll get to RWH
15:12:39 <jtbates> mekeor: whoops, thanks
15:12:43 <mekeor> np
15:13:10 <pradeep3013> can anybody explain why that Eq instance doesn't compile
15:13:15 <sipa> pradeep3013: there already exists an Eq instance for (,,)
15:13:38 <sipa> the type alias doesn't introduce a new type, only a new name for a particular tuple
15:14:02 <ion> Use a newtype instead.
15:14:20 <sipa> or a data constructor with 3 parameters
15:14:26 <ion> (Well, actually use a new data type for that case.)
15:14:50 <povman> epic facebook fail!
15:14:59 <mekeor> povman: huh?
15:15:06 <pradeep3013> ok Sipa/ion will try, why did the error msg for above so weird Illegal instance declaration for `Eq KeyMouse'
15:15:06 <pradeep3013>       (All instance types must be of the form (T t1 ... tn)
15:15:06 <pradeep3013>        where T is not a synonym.
15:15:09 <povman> the hacker cup doesn't work lol.
15:15:25 <ion> Your T is a synonym.
15:15:31 <sipa> pradeep3013: oh, you can't define an Eq instance for a type alias in Haskell98
15:15:37 <sipa> add FlexibleInstances if you want to
15:15:47 <ekipan> but you don't want to
15:15:52 <sipa> indeed
15:16:08 <pradeep3013> ok
15:18:36 <elliott> sipa: also TypeSynonymInstances
15:18:40 <dolio> ddarius: Where are you?
15:20:40 <ybit> https://github.com/heath/Project-Euler-Problems/blob/master/haskell/three.hs
15:20:46 <pradeep3013> yes, it suggested to use TypeSynonymInstances. I wish it gave a simple message like "you can't define an Eq instance for a type alias" though.. I got it to compile changing it into a data declaration as suggested
15:21:12 <ybit> three.hs:19:14: parse error on input `='
15:23:30 <elliott> pradeep3013: you can though :)
15:23:33 <elliott> you just don't want to
15:23:48 <elliott> ybit: you need "let" in front of definitions in a do block
15:26:13 <pradeep3013> @elliot then maybe "you can't define an Eq instance for a type alias unless you turn on …" :). The point is it is hard to map from the error message to what needs changing.
15:26:14 <lambdabot> Unknown command, try @list
15:26:34 <shergill> is there a way to specify the ghc-package-path location into ghci other than the $GHC_PACKAGE_PATH variable?
15:27:45 <ekipan> Needs to be of the form (T t1 .. tn), and T can't be synonym. That's clear, isn't it?
15:27:53 <elliott> pradeep3013: GHC's error messages could be better, yeah.
15:29:18 <ion> GHC could learn from GCC’s STL error messages.
15:29:40 <hpc> ion: haha, good one
15:30:24 <pradeep3013> @ekipan well I yet don't know what a synonym is and what that T t1..tn means here, a data declaration… ?
15:30:24 <lambdabot> Unknown command, try @list
15:30:57 <mekeor> @list
15:30:58 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:31:13 <aristid> mekeor: i think ekipan is not supposed to be a command
15:31:20 <aristid> ekipan: are you a command?
15:31:25 <ekipan> not last I checked
15:31:26 <elliott> pradeep3013: it's probably a bad idea to ping people with @ on this channel :)
15:31:41 <mekeor> aristid: i know.
15:31:44 <ekipan> @yow
15:31:44 <lambdabot> Couldn't find fortune file
15:32:04 <pradeep3013> oops sorry
15:32:04 <aristid> @. elite quote
15:32:04 <lambdabot> Plugin `compose' failed with: getRandItem: empty list
15:32:07 <mekeor> @eval
15:32:17 <aristid> @quote
15:32:18 <lambdabot> me says: trololololo
15:32:43 <ekipan> what a wonderful quote
15:32:45 <c_wraith> wait, the lambdabot running here doesn't have getRandomItem fixed?
15:32:48 <ekipan> eloquent
15:32:50 <mekeor> @search foobar
15:32:50 <lambdabot> Unknown command, try @list
15:32:54 <mekeor> @search google foobar
15:32:54 <lambdabot> Unknown command, try @list
15:32:55 <aristid> c_wraith: huh?
15:33:04 <c_wraith> err, getRandItem
15:33:07 <ekipan> mekeor: /msg lambdabot if you wanna mess around
15:33:13 <aristid> ekipan: it would have been even more eloquent with @elite
15:33:17 <c_wraith> it's a bug in the quote plugin
15:33:25 <c_wraith> in the way it picks random quotes
15:33:38 <aristid> c_wraith: so it just sometimes breaks?
15:34:05 <c_wraith> I fixed it in a local branch of lambdabot, but I thought gwern fixed it upstream
15:34:48 <c_wraith> aristid: it's an interaction between adding and removing quotes, and the two not agreeing on what invariants the Map being used as the store should maintain
15:35:21 <aristid> c_wraith: ah, unchecked invariants
15:36:05 <elliott> Should have used Haskell!
15:36:07 <aristid> c_wraith: possibly gwern did fix it upstream, but it just didn't find its way to the actual lambdabot here
15:36:19 <aristid> elliott: that would have prevented it for sure :D
15:36:24 <elliott> this lambdabot is on latest darcs
15:36:35 <elliott> I know this because Cale applied and then backed out my patch :)
15:37:10 <c_wraith> Oh.  Well.  The problem is that removing a user's last quote leaves them in the Map, with an empty quote list, but the code for randomly picking a quote assumes that can't happen
15:37:45 <hpc> so basically... someone messed up when writing @quote
15:37:47 <geekosaur> isn't it supposed to be @quote?
15:37:49 <geekosaur> hrm
15:38:24 <geekosaur> interesting.  I guess I'll make sure I keep my version of @quote when I get around to updating my lb :)
15:38:36 <aristid> c_wraith: a multimap type in the core would be nice :P
15:38:37 <Sgeo> Maybe the Map should have been wrapped in an abstract type? I guess that would be similar to how OO would do encapsulation, right?
15:39:06 <c_wraith> I mean, when I was messing around with my local version, it was a pretty easy fix
15:39:11 <geekosaur> (mine is old enough a @quote that doesn;t know how to forget stuff, I'm pretty sure I dealt with this when I added it locally)
15:39:34 <c_wraith> It was even easy to get it to clean up when it ran into that situation while the stored Map still had bad data in it
15:40:25 <elliott> just bug Cale to add your patch :P
15:40:34 <aristid> uh. doaitse swierstra replied to a haskell-cafe thread from 2010, today.
15:40:37 <c_wraith> sadly, I blew up my local version
15:40:48 <c_wraith> I'm not even sure how
15:40:52 <c_wraith> but it doesn't start anymore!
15:41:03 <aristid> well, yesterday
15:41:04 <c_wraith> lambdabot's code is a bit fragile.
15:41:27 <aristid> c_wraith: lies
15:41:35 <aristid> c_wraith: haskell always runs correctly
15:41:58 <c_wraith> aristid: I think you mean it always does what the code says to do.
15:42:00 <elliott> It's because it checks literally every possible property statically, in the type system.
15:42:10 <elliott> And has no side-effects, which means nothing can go wrong!
15:42:21 <c_wraith> sometimes the code says "now is a good time to not start up, and not explain why!"
16:03:11 <nitwit> Dealing with a CSV file, how does one deal with fields with embedded commas?
16:03:44 <nitwit> Using Regex for parsing. Example: http://hpaste.org/56773
16:04:14 <zachk> nitwit: Parsec is normally recommended to me
16:05:43 <nitwit> I am to use Regex to solve this. I tried explaining that Parsec was better suited for the job.
16:07:03 <cmccann> "here, pound these screws in with this hammer" "isn't that what screwdrivers are for" "no, just use the hammer"
16:07:43 <ion> When all you have is a hammer, everything looks like a skull.
16:08:05 <shergill> nitwit: ask them if you can implement the solution in apl
16:08:41 <geekosaur> intercal?
16:08:57 <Enigmagic> Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.
16:09:54 <zachk> nitwit: what is it supposed to parse too?
16:10:15 <ion> He said CSV data
16:10:30 <nitwit> I'm not exactly dealing with the most flexible of individuals here. It is mandatory to use Regex only.
16:10:45 <ion> Naturally, the existing CSV parser implementations should be ignored.
16:11:21 <cmccann> at least CSV is a pretty simple format, so it shouldn't be too painful to do it the wrong way
16:11:22 <nitwit> zachk: I am to parse CSV data exported by a specific program, ExifTool. It reads meta-data from files, recursively.
16:11:44 <ion> “Here, clean the floor with this hammer.” “I have this vacuum cleaner right next to me.” “No, just use the hammer.”
16:12:12 <shergill> ion: heh
16:12:54 <zachk> nitwit: match something like ".*" nongreedily if you can
16:13:42 <Enigmagic> @google regex csv embedded commas
16:13:46 <lambdabot> http://www.kimgentes.com/worshiptech-web-tools-page/2008/10/14/regex-pattern-for-parsing-csv-files-with-embedded-commas-dou.html
16:15:04 <ion> .* is an excellent regexp for parsing CSV data. At the very end, simply filter the result through a CSV library.
16:15:31 <rwbarton> it's sort of weird to claim copyright on that regular expression
16:16:03 <zachk> "\".*\""
16:16:04 <cmccann> or parse with just ., then post-process the sequence of matches with Parsec
16:16:37 <ion> rwbarton: Hah
16:16:52 <ddarius> rwbarton: All copyrighted textual information is making a claim on a regular expression.
16:19:51 <dmwit> (...which is not to say that all regular expressions can be copyrighted, of course.)
16:25:48 <ddarius> dmwit: Some regexes have passed into the public domain.
16:26:50 <ybit> i'm a bit stumped on how to make the pal function return a number instead of string
16:26:53 <ybit> pal x =  show(x) == show(reverse x)
16:27:07 <ybit> in its current state, it's returning a Bool
16:27:40 <ybit> show isn't necessary either
16:27:55 <cmccann> ybit, what are you trying to accomplish?
16:28:23 <Axman6> what do you need to use show for?
16:28:52 <ddarius> Wherefore?
16:29:22 <Axman6> pal x =  show(x) == show(reverse x)
16:29:45 <ybit> cmccann: i'm trying to solve project euler #3 in haskell
16:29:49 <ybit> ^ultimate goal
16:29:57 <Axman6> that's likely to give strange results (like [12,3] is not a palindrome for [3,12])
16:30:40 <ion> > let pal x = show x == show (reverse x) in pal ['"']
16:30:41 <lambdabot>   True
16:30:59 <Axman6> ybit: what is problem #3?
16:31:05 <ion> Ah, it was show . reverse and not reverse . show. I’m too tired to think. :-P
16:31:22 <cmccann> ybit, if "x" is supposed to be a number then you probably want reverse (show x)
16:31:41 <ddarius> ion: show x == show x
16:31:43 <Axman6> it doesn't make sense to reverse a numver
16:31:50 <nand`> pal = (==) <$> show <*> reverse.show
16:32:17 <cmccann> > (\x -> show x == reverse (show x)) <$> [10, 11, 12]
16:32:18 <nand`> for some reason haskell's type inferral gives me () -> Bool on this; if I add the correct signature manually, Num a => a -> Bool, it works fine
16:32:18 <lambdabot>   [False,True,False]
16:32:20 <nand`> why is this?
16:32:32 <nand`> @type (==) <$> show <*> reverse.show
16:32:33 <lambdabot> forall a. (Show a) => a -> Bool
16:32:35 <nand`> oh hmm
16:32:36 <ybit> Axman6: https://github.com/heath/Project-Euler-Problems/blob/master/haskell/three.hs
16:32:39 <ddarius> nand`: Monomorphism restrictionand extended defaulting.
16:33:04 <nand`> hmm, I keep running into that monomorphism restriction
16:33:15 <cmccann> ybit, I think you mean #4
16:33:22 <nand`> I suppose it makes more sense to use the non-applicative style in this case either way
16:33:32 <nand`> pal x = show x == reverse.show x
16:33:38 <ybit> indeed
16:33:47 <nand`> reverse (show x) even
16:35:47 <monochrom> extended defaulting gives much hilarity such as:
16:36:00 <monochrom> @check reverse xs == xs
16:36:01 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
16:36:07 <monochrom> @check \xs -> reverse xs == xs
16:36:08 <lambdabot>   "OK, passed 500 tests."
16:36:28 <ion> @chekc \xs -> take 1 xs == nub xs
16:36:29 <lambdabot>   "OK, passed 500 tests."
16:36:41 <monochrom> this is because xs receives the type [()], and so xs's content is [(), (), (), ...]
16:36:44 <nand`> how the hell did it catch that typo
16:36:59 <nand`> monochrom: interesting
16:37:17 <monochrom> and so, of course if you reverse [(),()] you get [(),()] again
16:37:25 <roconnor> @check const = id
16:37:26 <lambdabot>   Parse error at "=" (column 7)
16:37:37 <roconnor> @check const == id
16:37:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
16:37:48 <roconnor> oh right
16:37:52 <ion> @check True
16:37:53 <lambdabot>   "OK, passed 500 tests."
16:38:14 <roconnor> @check \x y const x y == y
16:38:14 <lambdabot>   Parse error at "==" (column 16)
16:38:15 <ion> True seems to be True with a rathe high probability.
16:38:18 <roconnor> @check \x y -> const x y == y
16:38:18 <lambdabot>   "OK, passed 500 tests."
16:40:24 <monochrom> this is why I dislike various ghci features. they give you false expectations. they don't carry over to compiled programs. they add more surprises, not fewer.
16:53:47 * cmccann thinks GHC needs a {-# LANGUAGE MoreSurprises  #-} pragma that causes programs to randomly crash with the message "Surprise!"
16:54:09 <cmccann> and then a message telling to go on #haskell and ask monochrom for help
16:54:27 <monochrom> I curse you :)
16:54:31 <cmccann> :D
16:54:47 <monochrom> I'll just have to keep changing nicks to evade persecution!
16:54:48 <hpc> cmccann: no, what we need is {-# LANGUAGE NoSurprises #-}, which does the same thing
16:55:20 <hpc> if they expect the surprise, it's not that surprising, is it? :P
16:55:26 <cmccann> haha
16:55:52 <theorbtwo> Clearly, it should randomly crash with the message "The Spanish Inquisition!" instead.  Nobody expects that.
16:56:07 <cmccann> NoSurprises should remove the randomness though
16:56:10 <shachaf> cmccann: It's a pity you're not at HacBos; someone has a type family hackery problem you would surely enjoy.
16:56:10 <cmccann> just always crash
16:56:17 <cmccann> oh dear
16:56:29 <elliott> Oh no.
16:56:57 <theorbtwo> @check \x -> x != 83
16:56:57 <lambdabot>   Not in scope: `!='
16:57:05 <theorbtwo> @check \x -> x /= 83
16:57:06 <lambdabot>   "OK, passed 500 tests."
16:57:07 * cmccann dug up that type inequality thing earlier, that's enough type hackery for today
16:57:59 <aristid> @check \x -> x < 20
16:58:00 <lambdabot>   "Falsifiable, after 48 tests:\n22\n"
16:58:07 <aristid> @check \x -> x < 50
16:58:07 <lambdabot>   "Falsifiable, after 138 tests:\n63\n"
16:58:16 <cmccann> elliott, oh btw, had to run AFK for a bit, but about that lazy IO stuff
16:58:34 <shachaf> cmccann: The general problem is to turn a function :: r -> a -> b -> ... -> m z to a -> b -> ... -> r -> m z
16:58:51 <irene-knapp> @check \x -> 3 ** x + 4 ** x == 5 ** x
16:58:52 <lambdabot>   "Falsifiable, after 0 tests:\n0.5\n"
16:58:53 <shachaf> With some newtypes.
16:58:59 <irene-knapp> @check \x -> 3 ** x + 4 ** x == 5 ** x :: Int -> Bool
16:59:00 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Bool.Bool'
16:59:02 <cmccann> shachaf, didn't I already write something like that
16:59:07 <shachaf> Did you?
16:59:19 <irene-knapp> @check (\x -> 3 ** x + 4 ** x == 5 ** x) :: Int -> Bool
16:59:20 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Bool.Bool'
16:59:28 <cmccann> I have some type hackery that rotates the arguments of a function
16:59:33 <irene-knapp> @check \(x :: Int) -> 3 ** x + 4 ** x == 5 ** x
16:59:33 <lambdabot>   Parse error in pattern at "->" (column 13)
16:59:36 <elliott> shachaf: BUT WHAT IF AM M = (q ->)
16:59:37 <hpaste_> “C. McCann” pasted “this would be more awkward in lazy k” at http://hpaste.org/56776
16:59:39 <irene-knapp> oh well
16:59:56 <cmccann> elliott, anyway see that hpaste for the sort of thing I was thinking of
17:00:32 <cmccann> shachaf, https://github.com/isomorphism/typewriter/blob/master/Data/Typewriter/Variadic/Flip.hs
17:00:34 <elliott> cmccann: interesting, but whence io?
17:01:09 <cmccann> elliott: I was trying to suggest doing something like that in lazy k to make the I/O well-behaved
17:01:50 <elliott> cmccann: I meant the io function you use there :)
17:01:52 <cmccann> anything constructed using the monad there (which is just a specialized Cont) and fed to interact will still behave like it was sane I/O
17:01:56 <elliott> oh!
17:01:58 <elliott> it's a local binding
17:02:11 <elliott> sorry, missed that :)
17:02:31 <cmccann> yeah, execStreamIO turns the stream stuff into an IO action via interact
17:03:08 <cmccann> that should behave as if you were using getLine/putStrLn/whatever
17:03:13 <cmccann> without any way to "cheat"
17:03:30 <ddarius> cmccann: Next exercise: arbitrary permutations.
17:03:42 <cmccann> note that this would be a huge pain to actually implement in lazy k
17:04:18 <cmccann> ddarius, permutations of what?
17:04:42 <elliott> cmccann: eh -- there's lazier.scm
17:04:58 <elliott> that gives you all the convenience of the lambda calculus with all the ... something of compiling to lazy k
17:05:03 <cmccann> heh
17:07:17 <cmccann> anyway, doing it this way is possible because the I/O is limited to consuming/producing lists
17:07:22 <cmccann> lazy IO in general can't necessarily be tidied up the same way
17:07:52 <cmccann> which is the distinction I was trying to get at, after realizing that duplicating the input list would make it necessary to do so
17:07:53 <elliott> yeah
17:08:59 <hpc> i wonder what would happen if you used Acme.RealWorld and the reverse State monad to create a new IO type
17:09:17 <elliott> Acme.RealWorld doesn't actually work
17:09:22 <elliott> it's just passing around 0-byte values
17:09:25 <elliott> everything's a nop
17:09:36 <elliott> so... you'd get the identity monad :)
17:09:37 * cmccann writes a program that runs backwards in time and kills its parent thread before it was spawned
17:09:52 <elliott> Feather!
17:09:56 <elliott> Wait, people here don't know what Feather is. Never mind.
17:10:01 <hpc> elliott: GHC internals then :P
17:10:17 <elliott> hpc: Have you considered just buying a time machine?
17:11:28 <cmccann> why buy a time machine, just borrow one from your future self
17:11:34 <Sgeo> All the good time machines are built with Acme.RealWorld
17:11:35 <cmccann> then return it to your past self when you're done using it
17:12:02 <elliott> relevant: http://qntm.org/f16
17:12:19 <cmccann> it's just like tying the knot, except with causality
17:15:18 <elliott> I wonder whether that reverse-and-also-not-reversed Writer monad idea would actually work.
17:16:26 <elliott> oh, hmm, it doesn't actually make any sense :) it's more like a... WriterState
17:16:42 * cmccann isn't sure what elliott is talking about
17:16:44 <irene-knapp> elliott: cute post
17:16:55 <elliott> cmccann: me too
17:17:18 <elliott> cmccann: the reverse state monad lets you see what the state will be like in the future; the state monad lets you see what it was like in the past
17:17:26 <elliott> it would be nice if you could see both combined
17:18:49 <cmccann> wouldn't be too hard to make a State monad with two state values going in opposite directions, I'd think
17:19:02 <cmccann> but I doubt it makes sense to combine them
17:19:36 <elliott> cmccann: that's easy with a reverse state monad transformer
17:19:53 <elliott> it's not really combining them, it's more like... in the state monad, you can push changes forwards, and in the reverse state monad, you can push changes backwards
17:20:07 <elliott> so you just need "bidirectional state pushes" :)
17:20:41 <cmccann> in the end it amounts to composing a bunch of functions (s -> s)
17:20:55 <cmccann> not sure how that would be bidirectional
17:22:18 * ddarius really like William Deming.
17:22:40 <hpaste_> elliott pasted “something like this” at http://hpaste.org/56777
17:24:07 <elliott> hmm... doesn't quite work :)
17:24:46 <elliott> oh, it does
17:25:00 <elliott> cmccann: the idea is something like: runBiState (do { put (Sum 1); r <- get; put (Sum 1); return r }) (Sum 0) --> Sum 2
17:26:07 <cmccann> elliott, hm, ok. that is kinda interesting.
17:26:23 * cmccann wonders if it would be too confusing to actually use
17:26:32 <elliott> I guess "put" is actually more like "tell".
17:26:54 <elliott> I suppose a Writer monad where you can access the value would be a good starting point...
17:32:32 <cmccann> we should really start using the reverse state monad more often
17:32:40 <cmccann> then we could advertise haskell as being programming with time travel
17:33:03 <cmccann> it's starting to seem too approachable these days, we need something weirder
17:34:58 <elliott> I thought that's what Agda was for.
17:36:24 <cmccann> I guess, but I like running programs
17:36:27 <cmccann> not just compiling them
17:36:32 <cmccann> I don't think people do that with agda very often
17:36:56 <hpaste_> elliott pasted “BiStateMonoidWriterThing, take 2” at http://hpaste.org/56778
17:37:19 <elliott> cmccann: I saw someone complain about the performance of Agda's naturals once!
17:37:29 <Saizan> cmccann is an old-fashioned guy
17:37:31 <elliott> That's a whole *one* Agda program run.
17:37:52 <cmccann> haha
17:39:18 <cmccann> elliott, not sure why the result would be 2 there
17:40:00 <elliott> cmccann: the past value is (Sum 1), the future value is (Sum 1)
17:40:06 <elliott> mappend (Sum 1) (Sum 1) = Sum 2
17:40:21 <elliott> the idea is to "merge" the values from the past and the future with mappend
17:40:46 <cmccann> oh, so each "tell" should go in both directions?
17:40:52 <elliott> right
17:41:02 <elliott> (note: that get is broken -- should have mempty as second tuple element)
17:41:14 <cmccann> doesn't that just amount to a writer monad where "get" returns the final value of the entire computation?
17:41:29 <elliott> cmccann: nope, because it doesn't include the current instant
17:41:40 <ion> I actually found a use for RState once. http://hpaste.org/49828
17:42:03 <shergill> has anyone here used both agda and coq? or someone who's at least familiar with both?
17:42:08 <mgsloan> how evil would it be to have an annotation on where declarations that indicated that it should be used implicitly?  In other words, we could have "let implicit f = Sum in mappend 1 2"
17:42:13 <elliott> so in: do { tell (Sum 1); tell (Sum 1); r <- BiState (\w -> (w, Sum 1)); tell (Sum 1); tell (Sum 1); return r } -- the final accumulator is 5, but the result is 4
17:42:17 <shergill> wondering what the benefits/differences are in terms of functionality
17:42:46 <elliott> shergill: coq is more oriented to theorem-proving, with a tactics language etc.; more "real mathematics" has been done in Coq... Agda is more experimental and more of a programming language than Coq
17:42:49 <elliott> also, more unicode :)
17:43:00 <ion> Convert a number between 0 and (length ['A'..'Z'] ^ 3 * length ['0'..'9'] ^ 4 - 1) into a string like WZA-4381. With State, 1 results in BAA-0000. With RState, 1 results in AAA-0001.
17:43:02 <cmccann> elliott, ah, so you can't observe the difference using get, I guess
17:44:13 <elliott> hmm... my Monad instance is broken because it includes the present instant for the action produced by the RHS of (>>=)
17:44:18 <elliott> I get the feeling this isn't really possible :)
17:44:47 <cmccann> elliott, it might be but I'm suspicious that a state monad isn't really the right starting point
17:44:49 <elliott> ion: it's also useful for generating the fibonacci numbers!
17:45:14 <ion> Indeed
17:45:19 <elliott> cmccann: it's not really a state monad at this point, since mempty is used for non-changing actions... a Writer monad is the best fit, but you can't observe the accumulators of "surrounding" computations like that, thus the argument :/
17:45:24 <shergill> elliott: is agda used for things other than theorem-proving?
17:45:24 <elliott> maybe writing join would be easier...
17:45:38 <shergill> um in as  much as agda is used
17:45:47 <elliott> shergill: sure; there's even a webframework written in it... and an FRP implementation that compiles to javascript :P
17:45:57 <shergill> oh
17:46:06 <elliott> (not to say they're necessarily practical to use, mind you)
17:46:30 <elliott> but programming in any dependently-typed language tends to involve a lot of theorem proving, really, if only because the libraries want you to give them proofs
17:46:31 <cmccann> if memory serves me Agda has a pretty simple FFI to Haskell
17:46:50 <cmccann> so it's not like there's a huge hurdle to using it for programming whatever
17:46:59 <ion> So you can use unsafeCoerce from Agda?
17:47:13 <elliott> ion: trustMe
17:47:15 <shergill> yeah true
17:47:26 <elliott> Agda uses unsafeCoerce all the time in its generated code, as I understand it
17:47:28 <ion> tazjin: Thanks for the information!
17:47:39 <shergill> heh
17:47:39 <elliott> presumably to implement coercions from equalities, for one
17:48:46 <elliott> personally I have standards, so I only program in Epigram 2
17:48:55 <cmccann> ion, I don't think it's all that hard to break agda's type system using stuff that's explicitly there to mean "because I said so"
17:48:55 * shergill was reminded of the unsaferCoerce and unsafestCoerce discussion from earlier
17:49:10 <Sgeo> o.O unsaferCoerce and unsafestCoerce?
17:49:20 <elliott> I was thinking that it's a good thing Agda can utilise the power of unsaferCoerce.
17:49:47 <cmccann> for anyone who missed it before: http://hpaste.org/56741
17:50:18 <cmccann> guaranteeing that unsafeCoerce is slightly more unsafe that normal :D
17:50:54 <elliott> you should really use a proper hierarchical module
17:50:57 <elliott> Unsafe.R.Coerce
17:51:10 <cmccann> heh
17:51:26 <ion> Unsafe.R sounds like a bad kind of interface to R.
17:52:05 * cmccann should collect some of the suggested implementations and make an Acme.Unsafe module
17:52:14 <shergill> heh
17:52:37 <shergill> Unsafe.R.Us?
17:54:01 <ion> cmccann: Any code that requires eight language extensions can’t be bad.
17:54:30 <cmccann> ion, TypeOperators is probably the most important one
17:56:33 <elliott> I wonder if there's any technical obstacle to adding { data Total f; full :: (forall a. f a) -> Total f; lookup :: Total f -> f a; replace :: f a -> Total f -> Total f } to GHC.
17:57:47 <elliott> I guess not, since you can do basically the same thing with Typeable, and GHC can magically come up with an identifier for each type.
17:58:49 <Sgeo> I don't get what unsaferCoerce does
17:58:54 <Sgeo> The code is a bit too complicated for me
17:59:03 <cmccann> Sgeo, in that hpaste? it's just unsafeCoerce
17:59:14 <elliott> "Just".
17:59:21 <elliott> unsafeCoerce has the power to coerce equal types.
17:59:22 <cmccann> but with a constraint that prevents you from coercing from a type to the same type
17:59:28 <Sgeo> Ah
17:59:32 <elliott> unsaferCoerce lets you do less than unsafeCoerce, so it must be *safer*.
17:59:39 <mike-burns> I wish I had some visibility into what http-conduit was doing. Like curl -v.
18:00:01 <Sgeo> unsaferCoerce on a type and a newtype wrapper of it should be safe, right?
18:00:21 <cmccann> Sgeo, alas, I couldn't figure out how to prevent that
18:00:23 <cmccann> but yes
18:00:48 <shergill> that's for unsafestCoerce
18:01:02 <Sgeo> Also, go from some type to Any back to the type
18:01:12 <cmccann> no, unsafestCoerce should be stronger yet
18:01:22 <cmccann> and prevent things like the silly isJust implementation
18:01:35 <Sgeo> That's not prevented, is it? (If it was, I'd wonder why that technology is not used to just avoid any need of unsafeCoerce or Dynamics in the first place)
18:02:08 <cmccann> @quote isjust
18:02:08 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
18:02:39 <ion> @quote isTrue
18:02:40 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
18:02:45 <cmccann> :D
18:03:04 <elliott> Sgeo: You can't do everything with ->Any and Any-> that you can with Dynamic.
18:03:10 <elliott> Wait, how would that let you avoid unsafeCoerce?
18:03:16 <elliott> a -> Any; Any -> a is just as unsafe as unsafeCoerce.
18:03:36 <elliott> isUnit :: () -> Bool; isUnit = not . unsafeCoerce
18:04:07 <Sgeo> elliott, if the type system could be made to detect that it was truly a -> Any, Any -> a, then the type system might be coercable into any insanity that is supposed to work but shouldn't be typecheckable, like a native implementation of ST
18:04:30 <Sgeo> *that unsafestCoerce was being used for
18:04:48 <elliott> Sgeo: So you're asking for a dynamic type that's statically type-checked?
18:04:55 <elliott> I agree, that would be useful.
18:05:02 <elliott> Almost as useful as it is impossible :P
18:05:03 <cmccann> right, that's why I can't actually make an unsafestCoerce that does what I want :P
18:05:22 <cmccann> if that was possible then yes you could avoid the whole nonsense with whatever magic powers enable that
18:06:43 <kisielk_home> so I'm trying to use newtype to create a type deriving from Num, but I get a message that Num is not a derivable type. Can someone explain?
18:07:13 <parcs`> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
18:07:35 * cmccann would only be satsified with an unsafestCoerce that was statically checked as only being used in situations where unsafeCoerce would cause a runtime error
18:08:26 <elliott> Ideally you'd want an unsafestCoerce that also requires that no bijection exists between the two types
18:08:31 <elliott> you know, just in case
18:09:47 <cmccann> ideally "unsafestCoerce False :: Maybe Bool" should be rejected because that gives you "Nothing"
18:10:12 <elliott> I'm not sure why we're so desperate to invent unsafestCoerce when C already exists.
18:10:16 <cmccann> whereas "unsafestCoerce True :: Maybe Bool" would be allowed, because that evaluates to Just segfault
18:10:22 <elliott> Use the right language for the job and all that.
18:11:54 <cmccann> typing that in GHCi did in fact produce the message "Just Segmentation fault", which seems pleasingly accurate
18:12:01 <ion> hehe
18:12:45 <monochrom> use the right unsafeBlah for the job
18:13:32 <cmccann> unsafeDestroyWorld :: RealWorld -> Void
18:13:44 <monochrom> haha that's nice
18:14:11 <elliott> bigBang :: Void -> RealWorld
18:14:18 <elliott> that's how the RTS gets started
18:14:37 <monochrom> newtype IO a = IO { launchMissiles :: ReadWorld -> Void }
18:15:48 <elliott> ReadWorld = ReadS RealWorld
18:16:53 <ion> http://hackage.haskell.org/packages/archive/acme-realworld/0.1.1/doc/html/Acme-RealWorld.html
18:18:15 <monochrom> hahaha
18:19:48 <Axman6> that's awesome
18:21:15 <elliott> We should link that to people who perpetuate the "IO is just State World" myth :)
18:21:30 <elliott> "Yeah, it is! And you wouldn't believe the amazing things it lets us do..."
18:23:19 <stephenjudkins> i'm looking for an example of a network app written in Haskell, with an easy-to-follow codebase
18:23:44 <stephenjudkins> anyone have a recommendation?
18:23:49 <elliott> one of the web frameworks, perhaps?
18:23:56 <elliott> I hear Snap's code is nice
18:24:10 <elliott> there's that torrent client... actually about 5 of them I think
18:24:13 <nand`> I like the ZeroMQ examples also for an example of what it means to write a truly networked app
18:24:25 <stephenjudkins> elliott: hmm, i'd be a little more interested in lower-level network stuff
18:24:37 <nand`> disregard my suggestion then
18:24:42 <nand`> it's the complete opposite of lower-levle
18:24:53 <stephenjudkins> a torrent client would be perfect, actually
18:25:57 * cmccann recalls someone doing a nice comparison of implementing a torrent client in haskell and erlang
18:26:01 <elliott> stephenjudkins: yeah, but i don't know how nice their code is :)
18:27:34 <Axman6> stephenjudkins: combinatorrent is probably the one people are referring to, and its code is quite nice
18:27:42 <Axman6> i write some of the binary parsing code for it
18:27:51 <stepkut> stephenjudkins: you might look at http://hackage.haskell.org/package/scalable-server-0.2.2 too.. it's not a full app, but it is short and possibly interesting
18:28:15 <stephenjudkins> stepkut: that looks great
18:28:16 <companion_cube> http://jlouisramblings.blogspot.com/2010/04/haskell-vs-erlang-for-bittorent-clients.html cmccann ?
18:28:39 <stephenjudkins> Axman6: thanks
18:30:20 <cmccann> companion_cube, yes
18:30:29 <stepkut> stephenjudkins: what are you hoping to learn? A basic network app is not much more complex than reading and writing a file..
18:30:33 <Axman6> stephenjudkins: haskell is a great language for network programming. GHC provides extremely high performance threading (as good, if not better than Erlang's), and some very nice abstractions for working wiht streaming data
18:31:48 <stephenjudkins> stepkut: i'm looking for something that supports many concurrent connections
18:32:35 <elliott> stephenjudkins: you might be interested in the mighttpd article from http://themonadreader.wordpress.com/2011/10/26/issue-19/ -- still http, but focusing specifically on huge numbers of concurrent connections
18:32:46 <stepkut> stephenjudkins: typically you just have a loop like: forever $ do socket <- accept listenSocket ; forkIO $ handleRequest socket
18:32:47 <elliott> (and outperforming nginx, as it happens)
18:33:49 <parcs`> elliott: that's because mighttpd as like 5% the feature set of nginx :P
18:34:01 <stephenjudkins> thanks for your help, everyone
18:34:45 <elliott> parcs`: shhh, it's a cool hook, even if it is meaningless :)
18:34:56 <parcs`> it is
18:35:36 <Jafet> You should use the httpd that was written as a linux kernel module
18:35:43 <elliott> TUX
18:36:02 <Jafet> Because, you know, sendfile involves a damn kernel mode switch.
18:36:08 <Jafet> We can't have that.
18:36:49 <companion_cube> we don't need no stinkin' context switch!
18:42:37 <hpaste_> elliott pasted “Bi — it works!” at http://hpaste.org/56779
18:42:58 <elliott> well, it typechecks, and the example works
18:43:05 <elliott> laws? what laws? i don't need to check any laws
18:45:17 <elliott> (tell [1] >> get >>= tell) === (get >>= \r -> tell [1] >> tell r) :)
18:45:23 <elliott> (producing (repeat 1))
18:46:55 <elliott> cmccann: it works! \o/ ^
18:48:03 <cmccann> yay!
18:48:18 <cmccann> now find something it's actually useful for
18:48:35 <elliott> what?! are you kidding?!?! I haven't even defined the transformer version yet!
18:49:14 <cmccann> :D
18:51:59 <elliott> oh
18:52:04 <elliott> no transformer version; you need MonadFix :(
18:52:08 <elliott> well
18:52:11 <elliott> no MonadTrans version, anyway
18:54:56 <elliott> *Main> runBiterT test
18:54:56 <elliott> *** Exception: <<loop>>
18:55:05 <elliott> I don't think this thing wants to become a transformer.
18:56:08 <cmccann> heh
18:56:23 <elliott> aha, it works!
18:56:32 <Sgeo> Biter?
18:56:48 <elliott> Biter!
18:56:55 <hpaste_> elliott pasted “BiterT” at http://hpaste.org/56780
18:57:00 <elliott> look on my works ye mighty, etc. etc. etc.
18:57:16 <elliott> it's like the writer monad, except you can look at the accumulator, and also it travels both directions in time.
19:00:03 <cmccann> elliott, so when does this end up on hackage
19:00:54 <elliott> cmccann: over my dead body
19:01:00 <cmccann> hahahaha
19:03:27 <elliott> test :: BiterT (Sum Int) [] Int; test = do { a <- liftBiterT [Sum 1, Sum 2]; b <- liftBiterT [Sum 1, Sum 2]; tell a; Sum r <- get; liftBiterT $ guard (a == b); tell b; return r }
19:03:30 <elliott> --> [(2,Sum {getSum = 2}),(4,Sum {getSum = 4})]
19:03:34 <elliott> this thing is great
19:05:15 * cmccann is still trying to decide if it would ever be useful
19:05:33 <Sgeo> Is the reverse state monad useful for anything other than looking weird?
19:06:33 <cmccann> actually, I seem to recall a few examples where it worked really well
19:06:41 <cmccann> but don't remember what they were
19:06:53 <monochrom> spam says: "learn a new language in IO days". how do I get a language from IO? :)
19:06:53 <elliott> Sgeo: ion gave an example above
19:07:15 <elliott> monochrom: sorry, you'll only be able to learn a new IO language
19:07:26 <monochrom> hehe
19:07:30 <elliott> liftM learn ioDays
19:08:18 <elliott> cmccann: well you can get just past or future state
19:08:24 <elliott> which is a bit more useful than "all the state apart from this step"
19:08:50 <Sgeo> elliott, I don't see it
19:09:29 <elliott> Sgeo: <ion> I actually found a use for RState once. http://hpaste.org/49828  <ion> Convert a number between 0 and (length ['A'..'Z'] ^ 3 * length ['0'..'9'] ^ 4 - 1) into a string like WZA-4381. With State, 1 results in BAA-0000. With RState, 1 results in AAA-0001.
19:11:58 <drdo> Damn, building lifted-base is taking more than 256MB ram so it's getting killed on my VPS, any ideas?
19:12:44 <elliott> ghc on 256 megs of ram?
19:12:45 <elliott> good luck
19:14:06 <drdo> Is there some "super aggressive, screw time, GC option" ?
19:14:33 <elliott> it's called swap :P
19:14:45 <drdo> that 256 included swap :P
19:15:27 <drdo> unless i can mount some swap file, no idea if i can do that
19:15:33 <elliott> don't see why not
19:16:38 <monochrom> there is +RTS -M256M or something. make it -M128M just to be sure
19:17:37 <drdo> nop, can't activate swap
19:17:53 <monochrom> but usually the runtime doesn't ask for more memory if GC alone is sufficient
19:18:22 <drdo> How do i pass that to cabal install?
19:18:45 <monochrom> that will need an environment variable
19:19:14 <monochrom> I will have to find it in the GHC manual
19:19:17 <drdo> Oh i see it, GHCRTS
19:19:24 <monochrom> yes. good.
19:19:46 <monochrom> it affects all programs built by GHC. such as GHC itself
19:19:54 <monochrom> and cabal, too
19:20:02 <drdo> -rtsopts are disabled ?
19:20:05 <elliott> is ghc built with rtsopts?
19:20:07 <elliott> haha knew it
19:20:11 <drdo> oh boy
19:20:21 <elliott> drdo: i think cabal has a --with-ghc
19:20:27 <elliott> --with-ghc="ghc +RTS -M128M -RTS" for hideous hack
19:20:36 <Sgeo> elliott, why wouldn't it be?
19:20:38 <elliott> oh! there is even a --ghc-options
19:20:43 <elliott> --ghc-options="+RTS -M128M -RTS"
19:20:46 <monochrom> that's strange, GHC itself should be the last one to disable rtsopts
19:20:48 <elliott> Sgeo: because -rtsopts isn't default?
19:20:56 <elliott> monochrom: i suspect it's cabal or something
19:21:08 <monochrom> oh, right, couldn't get pass cabal
19:21:09 <elliott> one of the programs involved in a build process that's not ghc failing because it's set
19:21:11 <Sgeo> But RTS options seems more useful for GHC than many other programs perhaps?
19:21:18 <drdo> bam still killed
19:21:44 <monochrom> yeah, see, it allocates 300MB because after GCing it still needs 300MB
19:22:37 <drdo> time to ask why i can't use swapon
19:23:42 <monochrom> "the program is using 2TB memory, can I just put a cap on heap size?" is an understandable reaction considering human panic, but rather illogical once you know what other things the runtime has already tried before resorting to asking for 2TB
19:23:53 <elliott> it should just forget objects at random
19:23:59 <elliott> well, not at random
19:24:03 <elliott> least recently used firt
19:24:04 <elliott> first
19:24:57 <drdo> heap compression!
19:27:44 <monochrom> what is lifted-base? pretty unusual to take that much memory to compile. usually 64MB or less.
19:28:34 <Clint> it's bits that got split out of monad-control
19:29:36 <drdo> Hmm
19:29:46 <drdo> It's linking some program
19:29:54 <drdo> Linking /tmp/lifted-base-0.1.0.29937/lifted-base-0.1.0.2/dist/setup/setup
19:29:55 <elliott> have you compiled haskell-src-exts yet?
19:29:59 <elliott> that'll be fun
19:30:10 <monochrom> oh, the link takes 4TB memory and infinite time, yes. the "gold" linker does much better
19:30:50 <drdo> monochrom: Not sure if serious (i'm serious)
19:31:31 <monochrom> serious about the "gold" being faster and less memory for ghc-generated code
19:31:32 <drdo> i.e. not sure if you actually mean i should try that gold linker or if you're making fun of the gold linker
19:32:07 <monochrom> not serious about conventioning linkers taking 4TB memory. we don't even have such a laptop yet. :)
19:33:13 <monochrom> I have essentially switched to the gold linker and forgotten about it
19:35:25 <drdo> woah, xmonad just froze
19:36:03 <Clint> rewrite it to use xcb
19:36:35 <elliott> drdo: i hear broken dzen pipes cause that or something
19:36:42 <drdo> elliott: Not using dzen
19:36:50 <Clint> xmobar
19:37:05 <drdo> that i am, in fact i just started using it and it's the first time this has happened
19:37:25 <Clint> your loghook might be flawed
19:37:39 <elliott> http://www.haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#XMonad_is_frozen.21
19:38:18 <drdo> yes that makes perfect sense
19:40:33 <danols> mightybyte: hi
19:41:15 <danols> omg I just realized there is way more people in this channel then in django....
19:41:27 <drdo> there, it's reading now
19:41:31 <elliott> there's more people in here than #python, iirc
19:41:33 <elliott> or at least close
19:41:40 <danols> yes that too!
19:41:48 <danols> any idea ?
19:41:56 <elliott> any idea?
19:42:10 <ybit> any idea!
19:42:15 <danols> I would assume python being more popular
19:42:16 <drdo> some idea!
19:42:19 <elliott> (looks like we're the ~5th biggest channel)
19:42:24 <danols> no so great idea she said last night
19:42:26 <elliott> #python is slightly bigger, 937 people
19:42:31 <ybit> *rimshot*
19:42:35 <danols> haha
19:42:53 <danols> anyone with django experience here ?
19:43:04 <ybit> right, i'm supposed to be working :)
19:43:08 <danols> extensive experience that decided to use haskell/webframeworks ?
19:43:46 <Clint> i've picked hakyll over django once
19:44:21 <drdo> I want a framework that let's me pretend the web doesn't exist. Where do i find that?
19:44:23 <danols> hakyll --- oh man
19:45:01 <danols> I'd like to keep my decission pool to hapstack, snap and yesod :)
19:45:43 <stepkut> drdo: impossible!
19:45:43 <amiller> is there a haskell opengl implementation that's, like, rock solid
19:46:13 <amiller> i'm quite used to jerking around with wxwidgets and ipython and the event loop sometimes gets twitchy and the opengl context crashes the whole process often enough
19:46:14 <drdo> stepkut: I really hate it :(
19:46:36 <stepkut> drdo: well. it could be an irc framework or something I guess
19:46:56 <stepkut> drdo: http://patch-tag.com/r/stepcut/ircbot/home <-- no web!
19:47:14 <stepkut> you can pretend it's still the 80s!
19:47:17 <drdo> I want web, i just don't want to deal with it
19:47:41 <farfarhad> hi everyone, it's asked me to create a binary search tree in Haskell implementing a mapping key. that's the direction: http://nopaste.info/7fe01ed952.html . I know what a BST is and how to implement it, what I didn't understand is what is BST implementing a mapping function. why is BST k v? what should do that code?
19:47:41 <drdo> Meanwhile i just use wai/warp and parenscript
19:47:54 <stepkut> ;)
19:48:13 <stepkut> why wai and not something higher-level?
19:48:44 <drdo> Mainly because i haven't bothered looking
19:49:35 <drdo> Well
19:49:48 <drdo> The next reasonable abstraction level is the one i want
19:49:57 <stepkut> :-/
19:50:16 <drdo> Forgetting the web exists and not writing a line of html and js
19:50:27 <stepkut> does wai even provide any sort of routing combinators? or do you have to roll-your-own?
19:50:28 <drdo> Anything in between is going to suck tbh
19:50:50 <drdo> stepkut: What are routing combinators?
19:51:49 <stepkut> drdo: some way of taking apart the url, extracting values from it, and calling the right code to handle it
19:52:00 <danols> when you guys are here, how often are people asking about webframeworks and which ones are popular
19:52:02 <danols> ?
19:52:34 <stepkut> drdo: for example, if you had a url like, /view/5 you might want extract the 5, parse it as an integer and then call a function that shows item number 5
19:52:39 <drdo> Ah that
19:52:48 <drdo> I just rolled it by hand, it's only a few lines
19:53:10 <stepkut> drdo: so you might do something like, [ "view" </> int :-> \n -> viewItem n
19:53:14 <stepkut> ]
19:53:20 <drdo> wai provides a [ByteString] path
19:54:03 <drdo> and the query already parsed
19:54:10 <stepkut> drdo: well.. a web framework is a collection of a whole bunch of things that are 'only a few lines' :p
19:54:59 <stepkut> drdo: sure, but then you still want functions to lookup values in the parsed data, do additional conversions on the types, aggregate errors, and so on?
19:56:04 <stepkut> if you take all your hand rolled functions, and abstract out anything else you are doing over and over, you'll end up with your own web framework :)
19:56:22 <parcs`> why the hell did websites start abusing directories as input parameters anyway?
19:56:34 <drdo> stepkut: Writing a proper web framework would be way too much work
19:56:41 <parcs`> that is what query parameters are for
19:57:31 <parcs`> routing is trivial if you are not misusing directories :P
19:57:35 <drdo> The only half decent web framework i know is Weblocks
19:57:59 <drdo> That might be because i don't know many :)
19:58:19 <stepkut> parcs`: path components are for hierarchical data, query parameters are for non-hierarchical data
19:59:57 <drdo> Is there some framework that's on the same level of abstraction as, for example, GTK?
20:01:03 <stepkut> drdo: Google Web Toolkit?
20:01:15 <drdo> stepkut: loljava
20:01:18 <stepkut> :)
20:02:31 <farfarhad> noone?
20:02:37 <stepkut> what do you consider GTK to be an abstraction of ? While it is higher level than low-level X.. you aren't really get that abstracted away from it ?
20:03:46 <monochrom> quite abstracted from X. X itself doesn't even have widgets, i.e., buttons, text boxes, menus
20:04:46 <drdo> stepkut: Oh boy, trust me, being abstracted from X is a big win (and what monochrom said)
20:05:01 <geekosaur> Gtk+ is higher level than Xt, and even a bit higher than Xaw
20:05:01 <stepkut> monochrom: sure. it defines a bunch of useful things on top of X.. but it doesn't really hide from you the fact that you are writing a GUI app.. In that sense, all the web frameworks are abstractions.. because without them you get a bunch of bytes over the wire..
20:05:28 <drdo> stepkut: I don't want the GUI part abstracted, i want the Web part abstracted
20:05:57 <drdo> It's just horrible and i hate dealing with it
20:06:20 <stepkut> drdo: for example?
20:06:29 <drdo> for example what?
20:06:34 <monochrom> interesting, to be more abstract than the web part. I don't know what it looks like :)
20:06:49 <stepkut> what would it be like to 'abstract' the web part? What are you trying to hide?
20:07:26 <stepkut> wash/cgi tries to 'abstract' the web by making it look more like an interactive command-line app and less like the stateless nightmare that it is..
20:07:31 <penelope> so, I had read that one could implement sequence only in terms of applicative, but I'm having trouble doing it myself...
20:08:16 <monochrom> you can start with the original sequence code and transform it step by step
20:09:45 <monochrom> sequence (x:xs) = do { y <- x; ys <- sequence xs; return (y:ys) } --> sequence (x:xs) = (\y ys -> y:ys) <$> x <*> sequence xs
20:09:48 <drdo> Have you guys ever done anything on the web? I'm finding it hard to even know where start bashing it
20:09:53 <drdo> *where to
20:10:16 <penelope> too much info! spoilers! thanks!
20:10:18 <monochrom> because generally do { y <- a; ys <- b; return (f y ys) } --> f <$> a <*> b
20:10:46 <monochrom> it is also liftM2 and liftA2
20:11:04 <stepkut> drdo: yup. I am a full-time Haskell web developer. And I agree the web sucks.. composibility sucks, global namespacing, lack of a bytecode VM on the browsers, trying to design anything using CSS is an exercise in trying to outsmart the W3C
20:11:39 <drdo> stepkut: So what's hard to understand about me not wanting to deal with it? :)
20:11:41 <stepkut> drdo: that is a big part of the problem.. it's hard to build a good framework on such a crappy foundation :)
20:12:39 <stepkut> drdo: because.. I am not sure how you can not deal with it.. I mostly know ways to make dealing with it slightly more tolerable
20:13:02 <monochrom> or the expectation is too high concerning web pages. my view: they're just web pages
20:13:03 <drdo> I'm not sure either, that's why i'm asking
20:13:16 <stepkut> drdo: for example, digestive-functors makes form generation, validation, and processing more sane.. but you are by no means getting away from having to understand what a form is or how it works
20:13:24 <drdo> It seems like when i try to do the simplest things the Web fights me back and says "NO!"
20:13:59 <drdo> stepkut: I'm not even talking about such things, just the UI part
20:14:07 <stepkut> drdo: forms are part of the UI..
20:14:09 <drdo> Graphics part rather
20:14:16 <drdo> Yes i realised that when i wrote it
20:14:16 <stepkut> drdo: the page layout?
20:14:17 <penelope> stepkut: as a full-time haskell web developer, what are your your haskell web and persistance frameworks of choice?
20:14:22 <drdo> stepkut: yes
20:14:27 <stepkut> penelope: happstack + acid-state
20:14:33 <penelope> :-)
20:14:42 <drdo> acid-state is for rich people :S
20:14:54 <stepkut> drdo: or people with small amounts of data..
20:15:00 <drdo> or that :P
20:15:28 <stepkut> drdo: or people who are confident that sharding, etc, can be added when they actually get enough data to need it
20:15:54 <penelope> When is acid-state going to get sharding?
20:16:00 <monochrom> you don't say "mercedes-benz is for rich people. or people who just wants the entry-level C300". oh, wait... :)
20:16:22 <stepkut> drdo: so, something like dreamweaver allows you to do layout with out understanding much about html/css..
20:16:34 <stepkut> penelope: when someone needs it bad enough ?
20:16:48 <stepkut> penelope: I'm working on needing it bad enough right now :)
20:17:12 <penelope> I'm wishing you all the necessity you will need!
20:17:19 <stepkut> me too :)
20:17:44 <stepkut> the only thing worse than needing to scale.. is not needing to scale ;)
20:18:46 <stepkut> in related news.. I am writing a bunch of tutorials on acid-state + IxSet right now so that more people can try to need sharding too :)
20:19:05 <penelope> !!
20:19:08 <stepkut> ... also a good excuse to finally learn how to use Data.Lens
20:19:14 <penelope> Do share!
20:19:41 <stepkut> http://happstack.com/docs/crashcourse/AcidState.html
20:19:48 <stepkut> just added the section on IxSet today
20:19:57 <stepkut> I am doing a section on IxSet + Data.Lens now
20:20:14 <drdo> stepkut: I understand it, i just hate it
20:20:15 <penelope> Virtual hugh.
20:20:17 <penelope> hug
20:20:24 <stepkut> :)
20:21:26 <stepkut> and then an advanced section on using multiple acid-state components and store the acid handles in reader monad in order to modularize your code (and avoid having to explicitly pass around or reference the handles)
20:22:05 <penelope> how does one choose the nesting order of monad transformers, anyway?
20:22:14 <amiller> so with ipython i use opengl a lot and there is a background thread that receives input, even when i'm in the interpreter
20:22:21 <stepkut> penelope: in general you can make most any order work
20:22:26 <penelope> hmm.
20:22:29 <amiller> i can't tell if there's anything like that for haskell
20:22:36 <stepkut> penelope: though there are a few execptions -- for example, there are some edge cases with the Writer monad
20:23:25 <stepkut> penelope: in general I like to do, ServerPartT (ReaderT Env IO) a, because then all class instances for ServerPartT are still available with no extra effort
20:24:15 <penelope> I ran into some trouble trying to do ReaderT (ServerPartT ...) ...
20:24:20 <stepkut> though, when using web-routes.. I find it much easier (and possibly required?) to but the RouteT monad transformer on the outside
20:24:29 <penelope> ah
20:24:31 <penelope> Yes
20:24:38 <penelope> That was the issue.
20:25:03 <stepkut> penelope: in theory that should work.. but we may be missing some class instances that would make, ReaderT r (ServerPartT m), easier to use out of the box
20:25:46 <penelope> meh. I ran into a wall, and no amount of lift . lift ... would help
20:26:12 <stepkut> penelope: I would need to see the code..
20:27:29 <stepkut> out of the box right now, if you do, ServerPartT (ReaderT r m), you can use 'ask' with out any lift.
20:28:00 <stepkut> but if you do, ReaderT r (ServerPartT m), then you would need some lifts. But that could (and probably should) be fixed by adding some addition class instances
20:29:06 <penelope> If I remember correctly, it was in fact the RouteT that made me need to rethink the stack order...
20:29:22 <stepkut> yeah
20:29:59 <stepkut> I usually need to put RouteT on the outside because it makes, nestURL, easier to deal with
20:30:39 <penelope> It just seemed more natural to do the config on the outside...
20:31:33 <stepkut> possibly.. it is mostly just personal taste I think
20:32:02 <penelope> I'm happy enough that I got acid-state to work with happstack and web-routes on my own...
20:32:03 <stepkut> you could also just avoid monad transformers entirely, create a new monad from scratch and add a Happstack instance for it :)
20:32:09 <penelope> (needs tuturial)
20:32:12 <stepkut> :)
20:32:21 <stepkut> I'm writing as fast as I can :p
20:33:37 <stepkut> penelope: it needs some modernization, but there is a working example of happstack + web-routes + acid-state here, http://src.seereason.com/examples/happstack-imageboard/
20:34:10 <penelope> Oh! That's you! I haven't managed to get it to compile :-)
20:34:14 <stepkut> + digestive-functors + HSP
20:34:25 * stepkut checks
20:34:58 <penelope> Eh. Not everyone is as consistent with cabal dependencies as they should be.
20:35:37 <penelope> Frankly, It's a labor of love--
20:36:31 <stepkut> I need to get a working buildbot again
20:36:43 <penelope> I mean, what's up with needing to track down and recompile all of your cabal installs because you we foolish enough to type sudo aptitude safe-upgrade+
20:36:44 <stepkut> something that can test cabal install against a clean Haskell Platform install
20:36:46 <penelope> ?
20:37:02 <adu> penelope: lift . lift
20:38:12 <stepkut> penelope: cabal was never meant to be mixed with debian packages
20:38:52 <stepkut> penelope: happstack-imageboard builds for me. But, if it needs additional patches I am happy to make them
20:39:02 <penelope> hmm
20:39:06 <penelope> Let me try...
20:39:23 <stepkut> that said, I just patched in on Jan 8, so if you tried before then.. it probably failed
20:40:20 * thunderbolt is looking for toy monad definition examples.
20:40:23 <stepkut> I do want it to work though :) It is a relatively small app that demonstrates a large collection of happstack related technologies
20:40:43 <penelope> Yea, I go through phases. Last week, I was busy trying to find some typesafe reasonable way of introducing "traits" into java.
20:41:24 <stepkut> happstack + acid-state + ixset + hsp + digestive-functors + file-uploads + IO worker queues + jmacro
20:41:45 <penelope> Makes you forget about the terrible liftM vs fmap vs Num issues.
20:41:50 <stepkut> :)
20:41:57 <stepkut> liftM vs fmap vs <$>
20:42:04 <ion> liftA
20:42:10 <stepkut> that too!
20:42:28 <stepkut> Num :(
20:44:12 <penelope> Can we set up a group to wine about these things? I mean, they managed to stop SOPA. Maybe we can whine enough to get a decent numeric tower, and have Functor => Pointed => Applicative => Monad ?
20:45:07 <Sgeo> traits?
20:45:18 <Sgeo> I meant, I've heard of them in a Ruby and in a Smalltalk context
20:45:48 <ion> Perhaps we could get Wikipedia to go dark for a day in protest of the typeclass situation.
20:45:51 <thunderbolt> Scala has them too, iirc.
20:45:55 <stepkut> penelope: that would be swell :) I think maybe we just have to give up an Haskell and make sure Agda gets it right before it is too late
20:46:18 <Sgeo> Pointed?
20:46:39 <ekipan> Functor + pure
20:46:47 <Sgeo> Ah
20:46:47 <ion> “(Note that previous versions of the Typeclassopedia explained pure in terms of a type class Pointed, which can still be found in the pointed package. However, the current consensus is that Pointed is not very useful after all. For a more detailed explanation, see Why not Pointed?)” http://www.haskell.org/haskellwiki/Typeclassopedia
20:46:55 <penelope> Functor f => Pointed where pure :: a -> f a
20:47:07 <Sgeo> Is there a name for Functor + <*> without pure?
20:47:22 <ion> The “Why not pointed?” article isn’t that useful in its current form, though. :-P
20:47:32 <penelope> oh!
20:47:58 * thunderbolt really needs to brush up on abstract algebra.
20:48:06 <stepkut> ion: yeah.. I fail to see why it is not useful..
20:48:54 <stepkut> obviously, pure and return are useful
20:49:23 <stepkut> so, it would have to mean that pure/return are not useful when you can't also implement a Applicative/Monad instance
20:50:05 <dolio> Generally having multiplication but no unit is a more interesting algebraic structure than unit without multiplication.
20:50:20 <penelope> Well, it's probably safer to err on more minimal interfaces...
20:50:24 <penelope> but
20:50:25 <dolio> Because it's not even a unit, just a value.
20:51:27 <penelope> I can think of a pure + fmap that I have encountered.
20:51:29 <penelope> Though
20:51:56 <penelope> That might be because it's too easy to just do monad.
20:52:52 <stepkut> penelope: you mean a type for which fmap + pure can be implemented, but not a monad?
20:53:23 <penelope> Well, I meant a use for such a creature.
20:54:04 <stepkut> penelope: I  believe the Store comonad is such a creature, http://hackage.haskell.org/packages/archive/comonads-fd/2.0.2/doc/html/Control-Comonad-Store-Lazy.html, and is used to implement Data.Lens
20:54:25 * Sgeo doesn't quite get comonads
20:55:00 <penelope> eh. haskell and agda somehow manage to always make me feel stupid.
20:55:00 <Sgeo> They're just things with an extract operation?
20:55:51 <stepkut> and fmap
20:56:03 <thunderbolt> penelope: Me too. And I have a freakin' B.S. in math :)
20:59:34 <geekosaur> I think it regularly does that to just about everyone whose name isn't Oleg or maybe Simon...
20:59:55 <ion> Oleg Simon!
21:00:41 <penelope> anything with a co- in front of it is clearly trying to spell trouble.
21:01:30 <stepkut> coagda
21:01:45 <ion> coal mining
21:05:22 * copumpkin glares at penelope 
21:06:02 <penelope> cooperation? No, that's ok.
21:06:53 <penelope> covarient tensors, they should be glared at.
21:27:21 <kallisti> how does one sanely go about testing a Haskell program?
21:33:04 <ion> kallisti: test-framework-th and QuickCheck (and HUnit for the subset of tests for which QuickCheck-style fuzzing isn’t appropriate).
21:33:21 <farfarhad> hi everyone, it's asked me to create a binary search tree in Haskell implementing a mapping key. that's the direction: http://nopaste.info/7fe01ed952.html . I know what a BST is and how to implement it, what I didn't understand is what is BST implementing a mapping function. why is BST k v? what should do that code?
21:51:38 <mzero> question about optimization: If I have a top level exported function, and that function has value in a where clause that isn't dependent on the functions inputs, will ghc hoist that value to top-level so that it is only evaluated once?
21:52:00 <mzero> I did a -ddump-simpl, and it didn't look like it would
21:52:15 <mzero> but maybe that is too early in the compile chain?
22:15:12 <mzero> okay, I'll answer it myself: yes - *if* you use -O, -O1, or -O2
22:38:29 <mgsloan> has anyone module-ized this: http://chrisdone.com/posts/2011-12-05-generic-map.html ?
22:42:20 <mgsloan> ahh, stable-maps looks good :D
22:44:15 <mgsloan> bah, stable-maps isn't the thing I'm looking for
23:19:12 <Lemmih> mgsloan: Map String Dynamic?
23:20:39 <mgsloan> Lemmih: yeah, I'm just using a custom glookup, working swimmingly.  I definitely should use Dynamic instead of Value, though, thanks!
