00:01:23 <qubital> Does GHC allow error to be caught?
00:01:45 <shachaf> qubital: In IO.
00:02:16 <shachaf> (You can also do it in non-IO, in certain safe cases. But in general that's unsafe.)
00:02:19 <qubital> Why is that?
00:02:23 <shachaf> Why is what?
00:02:27 <shachaf> Why can you only do it in IO?
00:02:31 <qubital> yes.
00:02:36 <shachaf> Because it exposes evaluation order.
00:02:52 <shachaf> What should catchError (error "a" + error "b") be?
00:03:11 <sparkleshy> (error = exception?)
00:03:38 <shachaf> sparkleshy: error is referring to the function "error", presumably, which throws one kind of exception.
00:04:05 <sparkleshy> ooh. Okay. *goes back to reading about stuff*
00:05:15 <qubital> error as described in the report just seems so final.
00:05:24 <shachaf> qubital: That's because it is.
00:05:27 <shachaf> You shouldn't use it. It's evil.
00:05:42 <shachaf> It's really just a convenience function as an alternative to an infinite loop.
00:06:10 <qubital> Yes, it's confusing to think it can be caught, even in IO.
00:06:27 <shachaf> qubital: IO is the Sin Bin, you know.
00:06:35 <mjrosenb> presumably it is slightly more informative than an infinite loop.
00:07:09 <shachaf> mjrosenb: Slightly. Although GHC catches some infinite loops these days.
00:07:19 <qubital> A lot of well known libraries use it though.
00:07:32 <shachaf> qubital: They're mostly evil.
00:47:02 <erus`> > 1000 * 1.5 / 60
00:47:03 <lambdabot>   25.0
00:57:22 <sparkleshy> `filter (>5) [10,2,16,9,4] => [10,16,9] :: (Num a, Ord a) => [a]` but `[10,16,9] => [10,16,9] :: (Num t) => [t]`;
00:57:47 <sparkleshy> Why does the first thing have more type information?
00:58:17 <quicksilver> because you used > on it
00:58:25 <quicksilver> so it must be a type supporting > - i.e. Ord
01:00:16 <erus`> god i would hate to write a haskell compiler
01:00:32 <erus`> i love using it but thinking about how it works gives me a headache
01:00:54 <sparkleshy> I see... But why does it tell me the Ord part for the first [10,16,9] but not the second [10,16,9]? It feels like two identical things are quietly not-actually-identical.
01:01:12 <quicksilver> sparkleshy: they are not identical as you suspect.
01:01:17 <mauke> because you used > on it
01:01:31 <quicksilver> the point being that numeric literals like 10 and 16 don't have a fixed type
01:01:34 <quicksilver> they're polymorphic
01:01:46 <quicksilver> since they're polymorphic you can add more constraints
01:01:50 <quicksilver> "this 10 is any number type"
01:01:55 <quicksilver> "this 10 is any *ordered* number type"
01:02:15 <sparkleshy> Oooooooh.
01:02:30 <quicksilver> once you resolve to a fixed type (such as, Int) then your two expressions are exactly the same
01:02:36 <quicksilver> (the type is just [Int] then)
01:07:31 <frerich> It's always moments like when I realized that numeric literals are polymorphic that I ask myself - why did other languages have to be so complicated/restrictive? :-}
01:07:55 <frerich> A bit like Git, once I groked it I had trouble understanding why anybody else would want to do things differently.
01:09:07 <osfameron> haskell numbers make me cry
01:09:20 <flux> frerich, maybe you'll revisit this thought when you'll be writing your own programming language?-)
01:09:33 <osfameron> I suspect there's a nice "minimal things you need to know about haskell numbers" tutorial somewhere that would make me cry less?
01:09:59 <frerich> flux: Good point :-)
01:10:35 <Cale> osfameron: Maybe just read the Prelude?
01:10:48 <Cale> http://www.haskell.org/onlinereport/classes.gif might also be useful
01:11:46 <Cale> But looking at the definition of each of the typeclasses and seeing what things are in it will give a pretty good sense of what's going on
01:11:55 <osfameron> Cale: those are probably both useful for reference.  I'm more talking about the "you gave a Float and I needed a Double" or Int versus Integer versus Integral crap
01:12:07 <Cale> oh
01:12:11 <osfameron> in general I don't *care* even slightly about the difference between Float and Double, and I cry when Haskell wants me to.
01:12:22 <mauke> osfameron: you should care
01:12:29 <mauke> because Floats are evil and you probably don't want to use them
01:12:35 <osfameron> and I end up having to sprinkle fromInt (or fromIntegral, or whatever) everywhere
01:12:36 <Cale> In that case, you mainly just need to know about two functions: fromIntegral and realToFrac
01:13:03 <Cale> (and perhaps round/floor/ceiling/truncate for the rest)
01:13:20 <osfameron> mauke: then when I type 1.0, Haskell should Do The Right Thing, surely.
01:13:24 <Cale> fromIntegral converts from any integer-like type to any numeric type at all
01:13:27 <mauke> osfameron: it does
01:13:37 <quicksilver> frerich: For storing checksummed blobs, git is perfect. As a version control almost every single design decision was wrong, it's hard to imagine why anyone would do *anything* that way.
01:14:07 <osfameron> mauke: ah.  so perhaps one of the mistakes I make is trying to placate a compiler error by adding ::Float instead of ::Double ?
01:14:21 <mauke> why are you adding anything?
01:14:30 <osfameron> mauke: to placate compiler errors
01:14:36 <mauke> don't placate
01:15:00 <mauke> understand, then punch the compiler with your iron fist
01:15:01 <osfameron> last time, I was attempting to write a function to calculate my ai-class score
01:15:13 <mauke> have no mercy
01:15:18 <frerich> osfaemron:: In my experience, quite a bit of trouble comes from functions which aren't polymorphic when it comes to numbers. Like 'length' hardcoding 'Int' or things like that. I believe such functions caused quite a few 'fromIntegral' calls in my code. :-/
01:15:27 <osfameron> and, apparently, summing a set of numbers multiplied by a fraction was a pain in the arse.
01:15:34 <Cale> Int should be banned from the Prelude
01:15:51 <osfameron> yeah, length was one of the problems (to get an average)
01:16:10 <mauke> osfameron: you should be able to get by with just three types, Int, Integer, and Double
01:16:11 <Cale> Yeah, so length produces an Int, unfortunately
01:16:20 <mauke> you can ignore the rest
01:16:23 <osfameron> why do I need to care about Int/Integer ?
01:16:31 <mauke> :t length
01:16:32 <lambdabot> forall a. [a] -> Int
01:16:34 <Cale> So if you want to divide by the length of the list, you'll have to convert from Int to whatever fractional type you're using
01:16:36 <mauke> because length really likes Ints
01:16:45 <Cale> So fromIntegral (length xs)
01:16:59 <Cale> Or else just use genericLength from Data.List
01:17:11 <Cale> (ugh, the default one should be the generic one)
01:17:34 <ddarius> I think the vast majority of the time, people actually do want length and not genericLength.
01:18:20 * frerich actually expected shachaf to come up with this (presumably unpopular) opinion, but ddarius would've been my second guess :)
01:18:22 <Cale> I think the vast majority of the time, people actually don't want Int.
01:18:50 <shachaf> frerich: What? Me?
01:19:02 <Cale> I would have much less problem with  length :: [a] -> Integer
01:19:02 <shachaf> ddarius: Part of the reason is that genericLength is a foldr rather than a foldl'.
01:19:13 <Sgeo> > length [1 .. ((fromIntegral (maxBound :: Int))+1)::Integer]
01:19:17 <lambdabot>   mueval-core: Time limit exceeded
01:19:30 <shachaf> 2^63-1 is a pretty big number.
01:19:56 <ddarius> The problem with Int is it is not defined.
01:20:16 <Sgeo> > (maxBound::Int) + 1
01:20:17 <lambdabot>   -9223372036854775808
01:20:39 <Blkt> good (late) morning everyone
01:20:39 <ddarius> You can be sure that Matthias Blume would not approve of Int.
01:21:35 <shachaf> Nor does conal.
01:22:10 <mauke> well, that's just semantics
01:22:10 <ddarius> conal wouldn't approve for the reasons Matthias wouldn't, but also for the reasons Cale doesn't.
01:22:42 <ddarius> Matthias would be perfectly happy if Int was defined to be Int32 or Int64 or Int37.
01:23:42 <Cale> I really just want people to have to make conscious decisions to use Int rather than having it be inferred for them because they computed the length of a list somewhere.
01:25:39 <quicksilver> however genericLength is wrong too
01:25:57 <quicksilver> unless you're happy relying on RULES-based semantically changing optimisations.
01:26:10 <quicksilver> genericLength is lazy for the benefit of lazy natural types and similar tricks
01:26:20 <quicksilver> but you really really don't want your main list length function to be a foldr.
01:26:24 <dibblego> is there a canonical name for flip (^)?
01:26:43 <shachaf> dibblego: flip (^) is probably the best you can do.
01:26:50 <shachaf> Unless by (^) you mean xor, in which case it's xor.
01:26:59 <dibblego> *also, even in English (not necessarily Haskell)
01:27:04 <quicksilver> in fact, fromIntegral . length is better than genericLength if you want an Integer
01:27:06 <dibblego> no I mean "flip exponentiation"
01:27:19 <shachaf> > reverse "exponentiate"
01:27:20 <lambdabot>   "etaitnenopxe"
01:27:25 <mauke> :t foldl' (+) 0
01:27:26 <lambdabot> forall a. (Num a) => [a] -> a
01:27:36 <dibblego> quite pronounceable, thanks!
01:27:39 <shachaf> quicksilver: Yep. There should be a foldl' genericLength.
01:27:47 <mauke> I call it length'
01:27:56 <shachaf> mauke: Not sum'?
01:28:02 <mauke> wait
01:28:08 <frerich> osfameron: I think in many cases, I agree with you on the 'I don't care about Int/Integer/whatever in many cases'; I believe the correct way to express this is to just not use any of them but rather 'Num a => a' (or whatever constraints you need). Actually, in my own code, I consider 'Int' to be a code smell (usually it turns out I can get rid of some conversions by just using '(Num a, Ord a) => a' or something like that.
01:28:19 <mauke> :t foldl' (+) 0 . map 1
01:28:20 <lambdabot> forall a a1. (Num a) => [a1] -> a
01:28:52 * ddarius wonders if mauke meant to use that Num instance.
01:29:33 <mauke> it is a mystery
01:29:34 <shachaf> ddarius: As opposed to Integral?
01:29:56 <ddarius> shachaf: Look closer, or are you already so corrupted?
01:30:16 <shachaf> ddarius: Oh, you mean Caleskell 1 = const 1?
01:30:20 <shachaf> I assumed that was on purpose.
01:30:26 <ddarius> it is a mystery
01:30:28 * shachaf is corrupted. :-(
01:30:44 <shachaf> @ty foldl' (flip((+).1)) 0 -- FUSION
01:30:45 <lambdabot> forall a b. (Num a) => [b] -> a
01:42:35 <Feuerbach> Are arrow laws described anywhere?
01:42:57 <shachaf> @google haskell arrow laws
01:42:58 <lambdabot> http://www.haskell.org/arrows/biblio.html
01:42:59 <lambdabot> Title: Arrows: bibliography
01:44:47 <kizzo> Is there a way to print the type of an expression from within a haskell program, just like :t from GHCi ?
01:45:10 <shachaf> kizzo: Not in general, except in some special cases.
01:45:22 <kizzo> Ah alrighty.
01:45:28 <shachaf> Types don't really exist at runtime.
01:45:41 <shachaf> Why do you want to print the type?
01:46:42 <quicksilver> unless by "an expression" you actually mean "a string of text which represents an expression"
01:46:49 <quicksilver> i.e. interpreting haskall source code
01:47:08 <quicksilver> in which case the answer is GHC As A Library or one of the wrappers like hint.
01:47:18 <kizzo> shachaf: I may not have a good answer to your question : )
01:47:23 <kizzo> I may need to rethink things.
01:47:24 <shachaf> Right, that was the main special case I was referring to.
01:47:46 <shachaf> The other special case involves Typeable, but that's pretty limited and usually shouldn't be used for this sort of thig anyway.
01:48:15 <quicksilver> well the thing about Typeable is it only knows the answer which is statically known at compile time
01:48:22 <shachaf> Right.
01:48:23 <quicksilver> and, erm, - you should know that too, since you're the programmer.
01:48:32 <quicksilver> you might as well just embed the name of the type as text :)
01:48:44 <quicksilver> although this typeable hack might be useful for code maintenance / DRY reasons.
01:48:55 <shachaf> Well, you can have a library which logs the types of arguments that are passed to it or something?
01:48:59 <shachaf> I don't know.
01:49:17 <quicksilver> yes, you could
01:49:29 <quicksilver> as long as the library is prepared to insist on a Typeable constraint
01:49:30 <shachaf> I'm inventing reasons, though. I dobut that's what kizzo wants.
01:49:38 <shachaf> Right.
01:53:29 * hackagebot IntervalMap 0.2.3 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.2.3 (ChristophBreitkopf)
01:57:05 <dibblego> lambdabot's @check is broke
01:58:10 <Phlogistique> you're broke
01:58:39 <dibblego> no you
02:15:37 <erus`> whats it called when someone claims something to be true based on a single experience ?
02:16:41 <ManateeLazyCat> quicksilver: Hey, how are you?
02:21:03 <Phlogistique> erus`: induction
02:21:17 <opqdonut> erus`: argument by anecdote
02:21:26 <erus`> ah anecdote
02:21:28 <erus`> thats it
02:34:34 <Sgeo> Is there any actual use for http://hackage.haskell.org/packages/archive/OneTuple/0.2.1/doc/html/Data-Tuple-OneTuple.html ?
02:34:51 <Sgeo> Any reason to distinguish between _|_ and OneTuple _|_
02:35:30 <shachaf> Sgeo: Consistency?
02:35:34 <opqdonut> yeah
02:54:42 <gregATio> ive asked this question before but i've lost the link, can anyone point me to flymake for haskell?
02:56:54 <gienah> gregATio: flymake is used in
02:57:01 <gienah> @hackage ghc-mod
02:57:01 <lambdabot> http://hackage.haskell.org/package/ghc-mod
03:04:06 <gregATio> no worries found the link,
03:23:04 <djanatyn> > fmap (*2) [1..10]
03:23:05 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
03:23:46 <djanatyn> > fmap (*2) [(+1),(+2),(+3)]
03:23:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:23:47 <lambdabot>    arising from a use of `...
03:25:19 <djanatyn> fmap (+) [1..5]
03:25:29 <djanatyn> > fmap (+) [1..5]
03:25:30 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:25:30 <lambdabot>    arising from a use of `...
03:26:45 <donri> whatcha up to djanatyn
03:28:13 <teneen> what do I have to import to use the parsec examples in RWH here http://book.realworldhaskell.org/read/using-parsec.html?
03:28:17 <teneen> my ghc is 7.2.2
03:28:25 <teneen> and the examples don't work
03:29:33 <donri> teneen: do you have parsec installed?
03:29:39 <teneen> yes
03:29:51 <donri> try Text.Parsec
03:30:15 <teneen> donri: I tried it but no success
03:30:45 <teneen> No instance for (Text.Parsec.Prim.Stream s0 m0 Char)
03:30:47 <teneen>       arising from a use of `char'
03:31:34 <djanatyn> donri: playing with functors
03:31:43 <djanatyn> and just thinking about stuff
03:32:40 <aweis_> i have been hacking in haskell for 4 days now and I am growing more frustrated every day
03:32:49 <djanatyn> :(
03:33:09 <teneen> what do I have to import in the latest parsec library to get a simple parser like "char ','" to work
03:36:02 <int-e> char is defined in Text.Parsec.Char
03:36:26 <quicksilver> you need to explain exactly what you're doing with it, teneen
03:36:35 <quicksilver> paste the code and the error you're getting
03:36:40 <donri> Text.Parsec exports .Char though
03:36:42 <quicksilver> how are you trying to "run" the parser?
03:37:03 <teneen> I'm getting error with defining any parser
03:37:07 <int-e> right. "work" has too many different meanings.
03:37:14 <shachaf> teneen: People here are probably able to answer your question, but it's more likely to be through looking up things than through any knowledge of Parsec.
03:37:16 <teneen> I didn't reach to a stage were I can run yet
03:37:32 <donri> perhaps hpaste some code you expect to work that doesn't
03:37:45 <shachaf> What they won't be able to do, though, is read your mind.
03:37:57 <int-e> but what error? you may be running into the (dreadful) monomorphism restriction but that's only a guess.
03:38:36 <teneen> I'll paste the code
03:38:51 <shachaf> teneen: The first example in the link you posted works fine for me just as it is.
03:41:05 <hpaste_> teneen pasted “parsec-test” at http://hpaste.org/56289
03:41:20 <teneen> I run it through ghci though
03:41:45 <shachaf> teneen: Do you, uh, import anything?
03:42:05 <teneen> Text.ParserCombinators.Parsec
03:42:27 <donri> you have to import it in the file, you can't import it in ghci and then :load or :m the file
03:42:45 <teneen> I defined it in ghci
03:43:00 <djanatyn> Functors are pretty sweet
03:43:05 <teneen> donri: I just pasted the code at hpaste for demostration
03:43:28 <teneen> my ghc is 7.2.1
03:43:48 <shachaf> teneen: OK, int-e was correct.
03:43:56 <shachaf> teneen: It's the monomorphism restriction.
03:44:03 <shachaf> teneen: The solution is to add a type signature.
03:44:09 <shachaf> You should do that anyway.
03:45:28 <teneen> shachaf: I disabled the monomorphism restriction now and it worked fine
03:45:50 <teneen> shachaf: though I remember giving a type signature before as in the link and it also didn't work
03:46:21 <shachaf> Well, the only difference the monomorphism restriction makes is when you don't give a type signature.
03:46:29 <shachaf> So either you gave the wrong one or you misunderstand something.
03:47:14 <teneen> shachaf: Yes, I figured it out now
03:47:29 <teneen> shachaf: thanks
03:48:59 <dever> hey all, have a fairly uninformative error here. when i run my program i just get <<loop>> as output
03:49:20 <shachaf> dever: That means that in the process of evaluating a thunk, GHC tried to evaluate the same thunk.
03:49:24 <shachaf> For example, x = x
03:50:10 <wjt> Grr. System.Environment.getProgName explicitly strips out the directory information on grounds of portability; and there's no unportable-but-functional variation in 'unix' AFAICT. Anyone know if grabbing argv[0] is exposed anywhere else, or do I get to enjoy calling getProgArgv myself?
03:50:27 <dever> hrm, figured as much. time to trawl trough some code so
03:50:33 <dever> thanks shachaf
03:51:59 <aweis_> the haskell wiki references some infinite sequence fibs
03:52:14 <aweis_> I dont seem to have this as a part of my standard library?
03:52:28 <shachaf> aweis_: It's not part of the standard library.
03:54:00 <mikeplus64> wjt: can you just do getCurrentDirectory?
03:55:03 <shachaf> mikeplus64: The current directory isn't the directory the program is in.
03:55:05 <wjt> mikeplus64: nope, i'm after the location of the executable
03:55:15 <wjt> i'm just gonna stick to a shell-flavoured wrapper, I thikn :)
03:55:59 <mikeplus64> shachaf: wjt oh, right
03:56:25 <quicksilver> wjt: argv[0] is a hopeless way to get the location of the executable anyway
03:56:31 <quicksilver> any attempt to do that is broken.
03:56:54 <quicksilver> in fact, any attempt to write an executable which operates different depending on its location is a pretty horrendous idea on a traditional unix system
03:57:13 <shachaf> quicksilver++
03:58:26 <mikeplus64> http://hackage.haskell.org/package/FindBin
03:58:58 <mikeplus64> wjt: ^
04:00:51 <yitz> quicksilver: wjt did not specify that wjt is on a unix system, thought the reference to a "shell-flavoured wrapper" may imply that
04:02:11 <quicksilver> yes indeed. My comments should not be taken to assume that.
04:03:30 <yitz> even if wjt is on a unix system, that unix system could in fact by mac os x, in which case you would want to be able to figure out where the app bundle is if you were run from one. not sure how that works natively.
04:06:43 <arw> even in more mainstream systems like linux and solaris getting the "real" path of a binary is next to impossible in many cases.
04:07:22 <arw> you might have chroots, mounts, sym- and hardlinks, zones and namespaces interfering with stuff.
04:07:59 <arw> and even in the simplest cases, only some systems have a reliable way to determine the path of the current binary
04:14:40 <etpace> @hoogle (Eq a) => a -> a -> [a] -> [a]
04:14:41 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
04:14:42 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
04:14:42 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
04:15:42 <sipa> arw: given a chroot, how is the path inside any less a real path than the path to the same file in the unchrooted env?
04:16:11 <arw> sipa: the path might not even exist inside the chroot or it might point to a very different file.
04:17:55 <arw> sipa: the chroot syscall changes the fs root for the current process. but the current process will always be an executable from outside the chroot, meaning its path will be useless inside.
04:19:10 <arw> sipa: its not that the path really is useless. its just not valid within the namespace a chroot confines you to.
04:20:06 <sipa> arw: my point is that a mounted filesystem is always a virtualized and constructed environement
04:20:52 <arw> sipa: i'm not sure what you mean by that.
04:21:36 <sipa> you said that it is hard to get the "real" path; i guess i'm arguing that no "real path" exists
04:21:47 <sipa> except device + inode number maybe :)
04:22:24 <arw> sipa: by 'real' i mean 'where you can find the binary that was executed'.
04:22:43 <sipa> in which context?
04:22:51 <sipa> each process can have a different view of the filesystem
04:24:10 <arw> sipa: yes. meaning different inodes will have differnent paths. but there is always one inode, maybe invisible within the current context, which is mmap-ed executable into the current process memory.
04:25:00 <sipa> yes, but that inode may not even have any pathname associated with it in any context
04:25:23 <sipa> so, the only true identifier for files (at least for some filesystems) is device + inode number
04:25:39 <sipa> philosophical_discussions_about_filesystems++
04:25:42 <arw> yes, that is right.
04:26:01 <arw> and thats for all filesystems i know of, since you can just delete the executable.
04:26:22 <sipa> except read-only ones (cramfs & co)
04:46:34 <earthy> cdrom...
04:47:46 <etpace> @pl mapM (\x -> return 1 >>= (x,1)) [1..5]
04:47:46 <lambdabot> mapM (($ 1) . flip (,) 1) [1..5]
04:49:46 <shachaf> etpace: What?
04:50:30 <angstrom> in Parsec, how can I turn a Char parser into String parser (that'd take strings of length 1)?
04:50:57 <ion> pure <$> parser
04:51:00 <quicksilver> angstrom: fmap (\x -> [x])
04:51:04 <shachaf> angstrom: Is a Char parser a thing that returns a Char or that "takes" a Char?
04:51:11 <shachaf> s/return/produce/
04:51:16 <quicksilver> oh, I think I misunderstood
04:51:17 <funktronic> not sure if any if y'all are in boston, but this is tonight http://www.eventbrite.com/event/2653032291
04:51:19 <quicksilver> and shachaf is right
04:51:23 <angstrom> shachaf: good point
04:52:13 <shachaf> angstrom: ?
04:53:03 <angstrom> shachaf: it produces a Char
04:53:49 <shachaf> In that case, I imagine that what ion or quicksilver said would work.
04:54:14 <shachaf> But if you don't immediately see why it would work, I suggest you ignore it and instead try to figure it out yourself. :-)
04:54:40 <quicksilver> or "do {foo <- oldParser; return [foo]}"
04:54:48 <quicksilver> if that is a better fit for how you like to see parsers
04:55:00 <shachaf> For example, what quicksilver said.
04:55:01 <quicksilver> all these solutions are equivalent
04:55:14 <angstrom> I see. thanks
04:55:14 <quicksilver> and it's good to be familiar with these different ways of writing it
05:04:44 <dever> shachaf: re my earlier question, is there anywhere i can find out what is being evaluated?
05:04:56 <dever> i've isolated the error, but can't see where the problem is
05:05:30 <shachaf> dever: @paste it, maybe?
05:06:26 <Phlogistique> does anyone have a working command line interface to hpaste? pasting in a web interface is way too much trouble
05:07:18 <dever> shachaf: not sure if i'll be able, work related code
05:07:50 <shachaf> dever: Ah.
05:08:24 <shachaf> dever: Maybe try the GHCi debugger?
05:08:37 <Eduard_Munteanu> Now you have two problems? :P
05:08:57 <dever> shachaf: i'll sanitise it and then paste it
05:09:09 <quicksilver> Phlogistique: http://code.google.com/p/pastepipe/ ?
05:09:33 <Phlogistique> quicksilver: looks outdated
05:10:13 * Eduard_Munteanu wishes wgetpaste worked with hpaste
05:11:48 <Phlogistique> I'm using either curlpaste or pastebinit depending on the machine
05:12:11 <Phlogistique> wgetpaste and pastoob work too
05:12:20 <Phlogistique> and http://sprunge.us/ is the easiest to install
05:13:01 <Phlogistique> yeah right, pastepipe can't compile anymore with a simple "cabal install"
05:13:16 <Phlogistique> it needs fixing
05:13:41 <quicksilver> who runs hpaste at the moment? chrisdone?
05:15:15 <donri> yep
05:16:35 <quicksilver> would be good if he could maintain pastepipe or a similar
05:18:13 <dever> shachaf: http://hpaste.org/56290
05:19:53 <shachaf> Hmm, that's not something I can run.
05:20:20 <dever> aye, actually give me a min and i'll make it runnable
05:22:41 * shachaf doesn't know anything about all this PrimMonad business, by the way.
05:26:56 <shachaf> dever: I don't really get what's going on at all.
05:27:17 <shachaf> I suppose you don't either, which is why you're asking...
05:29:37 <dever> shachaf: it's on the same hpaste as an annotation
05:30:18 <shachaf> dever: You should pay attention to hlint, by the way.
05:30:40 <shachaf> Also, use either tabs or spaces (hint: spaces), but please don't use both. :-)
05:30:40 <dever> shachaf: i know :) i usually write the code and then see what hlint has to say about it
05:31:03 <Phlogistique> what editor do you use?
05:31:14 <dever> shachaf: that'd be a problem with using one editor here and one editor at home. i thought i had them both set up for soft tabs
05:31:42 <shachaf> By the way, is it just me or are you doing a lot of weird premature-ish optimization?
05:32:02 <Phlogistique> get a git repository with your editor config and make the editor's config file a link to the git repo
05:32:43 <dever> the strictness stuff is there as a cheap attempt to fix the loop problem, thought it could have been a problem with something there not being evaluated, and then being passed on
05:33:08 <dever> Phlogistique: textmate at home, but am constrained to linux here at work, so sublime text
05:34:40 <donri> i heard the arrow brackets (||) could be used for applicative somehow, is that true and how?
05:36:12 <shachaf> dever: OK, so just calling V.read g 12 gets you a <<loop>>.
05:36:31 <shachaf> Are you sure you understand how Data.Vector.Storable.Mutable works?
05:36:43 <dever> actually, that could be wrong.
05:37:26 <dever> let me check
05:39:11 <shachaf> Oh, the problem is probably in your Storable instance.
05:39:53 <shachaf> Are you sure that's how you write Storable instances?
05:40:36 <shachaf> This seems more like how you'd write a Storable instance for a pointer to a C structure.
05:41:07 <shachaf> Yes, I'm pretty sure that's the issue.
05:41:38 <shachaf> Er, wait.
05:41:49 <shachaf> dever: q = castPtr q
05:42:23 <dever> ahhhh.
05:42:34 <shachaf> That's anticlimactic.
05:42:44 <dever> that is pretty anticlimactic
05:42:51 <dever> how the hell did i not see that earlier
05:42:52 <shachaf> There I was thinking you were overwriting memory of Haskell structures or something.
05:43:29 * shachaf hasn't slept in many hours.
05:43:39 <dever> that is such a silly mistake :/
05:43:50 <dever> shachaf: i don't have that excuse unfortunately ;)
05:44:04 <dever> thanks for the help, i appreciate it a lot. i may not have ever seen that.
05:44:27 <shachaf> dever: It's OK, it's just an excuse anyway. :-)
05:45:38 <dever> cheers anyway. i was pulling my hair out trying to figure that out.
05:47:27 <shachaf> There are some more methodical ways of tracking this sort of thing down, like using cost centres or something.
05:47:52 <shachaf> In general the lack of stack traces is pretty annoying.
05:49:27 <shachaf> dever: Are you sure Data.Vector.Mutable.Unboxed or something like that wouldn't do what you want?
05:50:14 <dever> shachaf: aye, a stack trace would have been dead handy there
05:51:16 <dever> shachaf: pretty sure. i solved my memory issues pretty much by using plain Data.Vector.Storable, but not my performance issues, and for some reason I thought mutable would solve performance issues
05:51:22 <dever> but that doesn't appear to be the case
06:18:16 <hughfdjackson> does the notion of observers exist in functional programming?
06:18:31 <hughfdjackson> or a parallel notion
06:20:00 <byorgey> hughfdjackson: what is the notion of observers?
06:20:38 <dibblego> functional reactive programming
06:21:26 <hughfdjackson> byorgey: where an object notifies those objects that are 'observing' it (subscribed to it is another way to think of it) of any changes
06:21:31 <hughfdjackson> dibblego: ^_^ looking it up
06:21:43 <byorgey> hughfdjackson: ah, yes, then what dibblego said =)
06:21:46 <hughfdjackson> (have vaguely heard of it before, haven't investigated)
06:21:58 <byorgey> @package reactive-banana
06:21:58 <lambdabot> http://hackage.haskell.org/package/reactive-banana
06:22:13 <byorgey> hughfdjackson: I think that ^^^ would be a good place to start
06:22:30 <hughfdjackson> :D very much appreciated
06:22:59 <byorgey> if you look at the web page http://www.haskell.org/haskellwiki/Reactive-banana  it has lots of examples etc.
06:23:19 <byorgey> and its author is well-known for being very smart and a great communicator
06:23:43 <hughfdjackson>  :) looking at it now !
06:31:46 <ytre4k0> http://sergey-mavrodi.com/op/view_485.html - your invite: 245006 - invite to take part in a free lottery from Sergey Mavrodi on a site MMM-2011. One time per a week played off 10 prizes: 5 for 100 dollars and 5 for 50. To pay and inlay nothing it is needed. It is desirable to have a box on gmail.com after registration on invite you can choose English on the main page of site. thank you! we
06:31:46 <ytre4k0> can great deal!
06:32:46 <erus`> wut
06:33:36 <benj_> "thank you! we can great deal!"
06:40:29 <Sgeo> @hoogle (a -> Bool) -> IO a -> IO a
06:40:29 <lambdabot> Foreign.Marshal.Error throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
06:40:30 <lambdabot> Foreign.C.Error throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
06:40:30 <lambdabot> Foreign.C.Error throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a
07:11:20 <cheater_> when can . not be replaced with $ ?
07:11:36 <shachaf> Usually.
07:11:50 <shachaf> In fact, always.
07:12:00 <sipa> f . g $ x
07:12:04 <sipa> f $ g $ x
07:12:04 <shachaf> If it looks like (.) can be replaced with ($), it's an illusion.
07:12:08 <shachaf> It's only syntactic.
07:12:14 <cheater_> i thought eg head . sort was the same thing as head $ sort
07:12:20 <sipa> no
07:12:20 <shachaf> That's not true.
07:12:31 <shachaf> sipa: That example is, as I said, a syntactic illusion.
07:12:35 <cheater_> > head . sort [ 2, 3, 1 ]
07:12:36 <lambdabot>   No instance for (GHC.Num.Num [a])
07:12:36 <lambdabot>    arising from a use of `e_1231' at <int...
07:12:38 <cheater_> huh
07:12:39 <shachaf> ($) ((.) f g) x
07:12:42 <sipa> head . sort $ x is the same thing as head $ sort $ x
07:12:45 <shachaf> ($) f (($) g x)
07:12:58 <shachaf> See?
07:13:07 <cheater_> > sort [ 2, 3, 1 ]
07:13:08 <lambdabot>   [1,2,3]
07:13:24 <cheater_> > (head . sort) [ 2, 3, 1 ]
07:13:26 <lambdabot>   1
07:13:40 <cheater_> > head $ sort [ 2, 3, 1 ]
07:13:41 <lambdabot>   1
07:14:29 <cheater_> is . lazy whereas $ is not?
07:14:36 <cheater_> kinda.
07:14:39 <donri> why is . said to be preferable to $?
07:14:43 <shachaf> cheater_: No.
07:14:57 <shachaf> cheater_: Just, like, expand their definitions out, man.
07:15:04 <shachaf> I know you can do it.
07:15:14 <cheater_> is there something that can replace both $ and . in a convenient way?
07:15:26 <donri> <<< ;)
07:15:30 <shachaf> donri: f . g . h $ x is preferable to f $ g $ h $ x because it demonstrates how you're using a function (f . g . h)
07:15:38 <shachaf> cheater_: No, because they're completely different functions.
07:15:45 <shachaf> They have different types. They do different thigns.
07:15:56 <Clint> :t ($)
07:15:57 <lambdabot> forall a b. (a -> b) -> a -> b
07:15:57 <Clint> :t (.)
07:15:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:16:02 <shachaf> donri: That way you can e.g. lift out the (f . g . h) and give it a name.
07:16:12 <donri> that's all eh
07:16:26 <donri> which is fine and valid, just thought there was more to it :)
07:16:47 <donri> i have hlint yell at me for cases where i can replace $ with .
07:16:50 <shachaf> donri: $ is also ugly.
07:17:00 <shachaf> I like it less and less as I use Haskell more.
07:17:16 <donri> do you use parens instead?
07:17:26 <donri> i tend to combine them: f . g $ x
07:17:45 <shachaf> I prefer parentheses more as time goes on.
07:17:56 <gregATio> anyone had any difficulty installing ghc-mod
07:18:04 <donri> i guess parenthesis are underappreciated in haskelland ;)
07:18:16 <danr> shachaf: I agree that $ is ugly
07:18:24 <shachaf> gregATio: If you had any difficulty, why don't you share it with us instead of keeping it to yourself? :-)
07:18:58 <shachaf> gregATio: If someone had difficulty, it's unlikely that they'll step up and say it, because then they'll be obligated to help you, and they'll feel bad if they can't.
07:19:43 <gregATio> lol
07:19:44 <gregATio> ok
07:20:20 <gregATio> im running cabal install ghc-mod
07:21:37 <gregATio> getting this errror
07:21:41 <gregATio> setup: The program happy version >=1.17 is required but it could not be found.
07:21:43 <gregATio> cabal: Error: some packages failed to install:
07:22:04 <drull95> cabal install happy
07:22:24 <gregATio> i thought it would pull it down automatically
07:22:26 <gregATio> ok will try
07:22:47 <drull95> it will only auto install haskell libraries
07:23:01 <gregATio> ah thanks
07:28:40 * hackagebot failure 0.1.1 - A simple type class for success/failure computations.  http://hackage.haskell.org/package/failure-0.1.1 (MichaelSnoyman)
07:32:21 <The_Journey> hi, is it possible to have optional parameters in Haskell?
07:32:41 <shachaf> The_Journey: Kind of, sometimes, with some techniques, but not really.
07:32:53 <shachaf> That's because every function has exactly one parameter.
07:33:14 <cheater_> The_Journey: look at how it works in cmdlib, imo it's quite useful
07:34:00 <donri> you can use record update syntax to have defaults
07:38:10 <gregATio> strange, the happy program is also in my apt repository, cabal didnt recognise that happy was installed after a cabal install happy, trying the one in apt-get
07:42:09 <byorgey> gregATio: cabal install happy  probably put it in your  ~/.cabal/ directory
07:42:23 <byorgey> gregATio: you need to copy it somewhere on your $PATH, or add ~/.cabal/bin to your $PATH
07:42:48 <byorgey> gregATio: it is not recommended to mix installing things via cabal and installing them via apt-get.
07:42:52 <byorgey> stick to one or the other.
07:43:17 <shachaf> gregATio: It needs to be in your PATH.
07:43:19 <gregATio> i see thanks byorgey
07:43:26 <gregATio> dont cross the streams
07:43:27 <shachaf> PATH="$HOME/.cabal/bin:$PATH"
07:43:31 <byorgey> gregATio: exactly =)
07:43:53 <gregATio> ok will uninstall apt
07:43:54 <dcoutts> or you can set up cabal to install symlinks in ~/bin/
07:43:57 <gregATio> no
07:44:05 <gregATio> i mean uninstall happy
07:44:13 <byorgey> gregATio: I don't think you need to go so far as to uninstall apt itself ;)
07:44:35 <gregATio> lol how do you set up cabal to put sym links in?
07:44:43 <byorgey> gregATio: edit ~/.cabal/config
07:45:29 <gregATio> thanks
07:45:41 <byorgey> and set symlink-bindir, or else change 'prefix' under the install-dirs user if you want cabal to install stuff somewhere other than ~/.cabal
07:46:07 <byorgey> I have my prefix: set to $HOME/local
07:46:53 <byorgey> I guess the argument for leaving stuff in ~/.cabal  is that you can blow away everything installed by cabal without messing anything else up, although I have never personally found the need to do that
07:50:49 <gregATio> how do i uninstall something in cabal?
07:52:46 <drull95> ghc-pkg unregister
07:52:57 <drull95> though i don't know if that actuall removes the file
07:54:51 <byorgey> it doesn't
07:55:02 <byorgey> if you want stuff actually removed you have to do it manually.
07:55:08 <drull95> a feature that i want to add to cabal one day is to generate packages for the underlying os
07:55:18 <Eduard_Munteanu> Which means removing ~/.cabal and ~/.ghc altogether.
07:55:20 <drull95> then you could use your package manager
07:55:30 <Eduard_Munteanu> drull95: there is stuff like that AFAIK, in Gentoo
07:55:33 <byorgey> Eduard_Munteanu: you can remove things at a finer grain than that.
07:55:36 <dcoutts> drull95: there are tools that convert cabal->native
07:55:42 <Eduard_Munteanu> It generates ebuilds.
07:55:51 <Eduard_Munteanu> Yeah, sure.
07:55:52 <drull95> cool
07:55:59 <dcoutts> there are such tools for gentoo, arch, debian, rpm/fedora
07:56:07 <Eduard_Munteanu> But it's a PITA to clean up the mess sometimes.
07:56:17 <dcoutts> but they're mainly used by the distro maintainers, rather than end users
07:56:50 <Eduard_Munteanu> dcoutts: that's reasonable, unless your package manager can also install stuff user-locally.
07:56:57 <Eduard_Munteanu> Most can't, AFAIK.
07:57:27 * Eduard_Munteanu wishes for such a thing
08:04:58 <Sgeo> http://hackage.haskell.org/packages/archive/cml/0.1.3/doc/html/Control-Concurrent-CML.html this shouldn't be overkill if I just want to use the nice receive, is it?
08:05:06 <Sgeo> It might be
08:06:19 <Sgeo> Actually, I don't think it fits my use-case at all
08:08:10 <parcs`> The_Journey: an "optional" parameter in haskell would be 'Maybe Foo'
08:08:33 <shachaf> There's also what parcs` said.
08:14:19 <dylukes> shachaf: I remembered why I thought (+) and \x y -> x + y are different!
08:14:24 <dylukes> The former is a CAF, the latter is not.
08:14:34 <dylukes> That was all.
08:14:50 <shachaf> dylukes: Context?
08:14:56 <dylukes> Like... a while ago...
08:14:57 <dylukes> nevermind.
08:15:11 <shachaf> I think iw as saying that they're denotationally equivalent.
08:15:18 <shachaf> s/iw /I w/
08:18:51 <shachaf> Or something.
08:27:38 <vhd> using flags "+RTS -p" to profile with ghc I get what I want, however one of the function is said to have 0 entries which is wrong as it should be my most used function. I have tried annotating it with SCC but even that reports 0. Is this a bug or am I doing it wrong?
08:28:14 <vhd> p.s everything else is reporting correctly.
08:53:39 <carpi> are there any learning centers for learning haskell?
08:56:53 <aristid> which haddock version works gith ghc 7.0?
08:57:29 <carpi> books and online resources are good uptil a certain point..but beyond that, it would be nice to have an instructors help..
08:59:10 <frigga1> carpi: http://i.qkme.me/35nlkz.jpg :P
09:01:00 <carpi> lol.. i saw that this morning. made me chuckle.. I wish it was a lot more harder that it discourages me.. so i won't have to bother learning it. But its at that sweet point where it is difficult yet beautiful. so it keeps me going : )
09:01:41 <carpi> haskell should be mandatory from grade 4 if you ask me. kids should learn haskell as soon as they learn numbers from 1 to 1000
09:02:16 <frigga1> Can't say I disagree.
09:04:07 <mike-burns> > [1..1000]
09:04:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:04:48 <aristid> i mean this is seriously annoying. haddock 2.9.4 demands 7.2, haddock 2.9.3 just fails to build, and haddock 2.8.1 demands ghc 6.12
09:05:09 <carpi> (..) should be a function... !!
09:05:24 <shachaf> > enumFromTo 1 1000
09:05:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:05:29 <aristid> haskell platform meanwhile still packages ghc 7.0.4
09:05:56 <carpi> so (..) is sugar?
09:06:09 <byorgey> carpi: yep
09:07:39 <carpi> i wish there was sugar for all the programs we ever wanted to write.. Quake (!!) Doom 3 (!!!) C&C4 (&&). wouldn't that be nice. ok..that wasn't funny. back to studying without an instructor : (
09:21:27 <erus`> all sugar should be removed
09:21:29 <erus`> :D
09:23:11 <saati> erus`: you want do notation removed?
09:24:31 <arw> indent should be removed
09:25:26 <Peaker> arw: indent-based syntax?
09:25:58 <Peaker> redundant syntax is annoying.. especially when the redundancy isn't compiler-checked (e.g: indent vs. braces)
09:26:08 <Peaker> also meaningful indent means newbies don't write horrendously indented code
09:26:59 <saati> are there many haskell newbies who don't know another language well?
09:27:48 <monochrom> syntax sugar for all the programs we want to write: doom.exe, quake.exe, cnc.exe
09:30:30 <Eduard_Munteanu> That's bad for your syntactic teeth :P
09:31:32 <gwern> @src iterate
09:31:33 <lambdabot> iterate f x =  x : iterate f (f x)
09:32:25 <drull95> erus', you want to write machine code?
09:37:43 <mrakan> Why does the following always return 0, regardless of the file contents: (withFile f ReadMode $ fmap length . hGetContents)
09:38:07 <mrakan> If I force evaluation of hGetContents before calling length, I get the correct result. Does hGetContents clash with withFile somehow?
09:38:28 <Saizan> essentially, yes
09:38:55 <shachaf> mrakan: hGetContents does lazy I/O, which is evil (but sometimes convenient).
09:39:03 <Saizan> because hGetContents will delay the actual reading of the file until you force the result
09:39:30 <Saizan> but by that time withFile has already closed the Handle
09:39:31 <shachaf> When you hGetContents a handle, it gets put into "semi-closed" state, and will only get closed automatically when you've forced the last character (or so).
09:39:38 <mrakan> Ahh, I see. Because when I request the IO Int, the handle is already closed.
09:39:40 <shachaf> But withFile closes it before that.
09:40:04 <roconnor> http://www.reddit.com/r/haskell/comments/o5b4w/httpconduit/c3ffq6t?context=3
09:40:04 <mrakan> Thanks guys. A Haskell class of students in Zagreb, Croatia, is thankful. :) Cheers.
09:40:07 <cheater_> can hGetContents give inconsistent results if a file is changed between two reads from haskell?
09:40:19 <Saizan> forcing the IO Int is not even enough here, you've to force the result of it
09:40:38 <roconnor> Saizan: evaluate?
09:40:40 <mrakan> Saizan: Ah, yes, you're right. I need the Int within.
09:40:42 <Saizan> cheater_: keeping the Handle open should give you a lock
09:41:01 <Saizan> roconnor: yeah, that'd work
09:41:14 <roconnor> mrakan: but the real answer is to not use hGetContents
09:41:15 <shachaf> You might be able to say withFile f ReadMode $ (>>= evaluate) . fmap length . hGetContents
09:41:19 <Saizan> roconnor: assuming you execute the IO Int
09:41:38 <Saizan> like shachaf shows
09:42:50 <parcs`> @hoogle performGC
09:42:50 <lambdabot> System.Mem performGC :: IO ()
09:49:01 * hackagebot primitive 0.4.1 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.4.1 (RomanLeshchinskiy)
09:49:45 <rwbarton> er, how about fmap length (readFile f)?
09:50:25 <shachaf> rwbarton: I think people were trying to clarify the general problem of lazy I/O more than this specific use case.
09:51:08 <rwbarton> I wish #haskell would get over this obsession with the "problems" of lazy I/O.
09:52:13 <shachaf> rwbarton: Not "problem" in that sense necessarily.
09:52:36 <shachaf> The problem this person had had to do with lazy I/O. People were trying to clarify this problem. :-)
09:52:38 <Saizan> we still have to explain the problems when someone specifically is confused by them :)
09:52:58 <rwbarton> Well, okay, as long as it was a "Here is how you can convert your program to a similar working one", and not "Here is how you should solve your problem, isn't it ugly, btw enumerators rool", that's fine.
09:53:36 <shachaf> rwbarton: No one ever said anything about enumerators. :-(
09:53:45 <Saizan> i don't even like them much
09:53:56 <shachaf> Besides, am I allowed to dislike both lazy I/O *and* iteratees/enumerators/whatever?
09:54:21 <shachaf> I pretty much hate the world, and anyone who attempts to interact with it is my enemy.
09:54:30 <rwbarton> "Back in my day, when we read a file, we read a file."
09:54:42 <Saizan> btw, another problem with lazy I/O stuff is that it impairs learning of normal IO actions by messing with the execution/evaluation distinction
09:55:01 <shachaf> rwbarton: Back in my day, reading a file *denoted* something!
09:55:20 <conal> shachaf: :)
09:55:21 <rwbarton> until someone else writes the file while you are reading it
09:55:37 <shachaf> Saizan++ about learning.
09:55:44 <shachaf> conal: Hah, I said the magic conal-summoning word.
09:56:15 <shachaf> conal: Are you going to bahaskell this month?
09:56:31 <conal> shachaf: i think so. wednesday of next week, right?
09:56:40 <shachaf> The 18th.
09:56:44 <shachaf> Huh, that *is* next week.
09:56:53 * shachaf wonders whether conal actually has an IRC highlight for "denote".
09:57:15 <conal> shachaf: i'm in the bay area every other week these days, including next week.
09:57:25 <conal> shachaf: no, not for "denote".
09:57:56 <rwbarton> Saizan: I guess so. My take is that I imagine that readFile reads the file *immediately*, like strict IO, except it's actually implemented in some magic way, and there are certain conditions I need to check for this to work (which are satisfied 99% of the time).
09:58:05 <Kanisterschleife> Hi. Is it possible to make emacs dynamically learn about type and variable declarations in Haskell source?
09:58:12 <rwbarton> But I can see how that's not an easy viewpoint for a newcomer to adopt.
09:59:51 <Saizan> readFile is less likely to screw up i guess, except if you e.g. go to write to the same file
09:59:52 <conal> shachaf: about total-map (Data.TMap), if you have a use case for what you think of as "traversing" a TMap, please let me know. I'd love to support operations that are both useful and meaningful (non-abstraction-leaky) .
10:00:25 <shachaf> conal: You might ask Peaker. I think he brought either this or something similar up at one point.
10:00:31 * shachaf ought to sleep or something.
10:00:49 <conal> shachaf: thx. i'll drop him a note.
10:00:50 <Saizan> the withFile and hGetContents question is pretty recurring though
10:01:28 <rwbarton> right, I don't deny that the Prelude induces people to go wrong with its odd mix of lazy IO and functions that require strict IO.
10:01:50 <shachaf> rwbarton: One of the things that readFile doesn't give you is predictability with regard to the number of open file descriptors.
10:02:05 <rwbarton> shachaf: Caring about that falls into the 1%.
10:02:13 <shachaf> I guess that in the cases that it's actually a flaw, you wouldn't use readFile anyway.
10:02:55 <conal> shachaf: just like alloc/free gives predictability with regard to the number of currently-unallocated bytes on the heap.
10:03:06 <rwbarton> yep!
10:03:17 <rwbarton> I basically view lazy IO as analogous to garbage collection
10:03:20 <Saizan> it's fairly brittle to have preconditions that don't follow in any way from the model
10:03:32 <Saizan> and whihc aren't enforced
10:03:32 <rwbarton> conal++
10:03:51 <shachaf> Fair enough, I suppose. Except the reaction to readFile not closing FDs isn't GC, it's your next readFile failing.
10:04:08 <shachaf> Which mans that the behaviour of readFile can change based on whether you've GCed recently, or something.
10:04:11 <Saizan> which is what you have if you want to keep the "readFile reads immediately" model
10:04:28 <rwbarton> that is to say, there are cases where it makes programming easier, and other cases where you are too resource-bound not to think about these issues.
10:04:33 <conal> i'd love to see GC get expanded to resources other than RAM, rather than muck up our programming model/APIs.
10:04:44 <shachaf> That could be interesting.
10:04:48 <Saizan> and then there are cases where it's just surprising
10:04:56 <conal> file descriptors, video memory, etc.
10:05:00 <rwbarton> I half-jokingly suggested long ago here that Haskell could close file descriptors temporarily when it needed to open new ones
10:05:18 <rwbarton> of course this wouldn't actually work
10:05:22 <rwbarton> in general
10:05:40 <conal> rwbarton: still, it's thinking in the direction of high-level programming.
10:05:55 <conal> rwbarton: and maybe a variation would work fine.
10:06:01 <rwbarton> (e.g. it might not work because you had an open file handle to a file that has been deleted)
10:06:03 <shachaf> rwbarton: I the FD limit per-process of per-user or both?
10:06:06 <kqr> how do i specify a custom comparison (< and > specifically) between two instances of a type i have declared myself with the type keyword? (eg i have a type of the form (String, Integer) and i want to perform the comparison solely based on the intger)
10:06:12 <rwbarton> per-process is the usually relevant one
10:06:16 <Saizan> i consider (readFile "foo" >>= writeFile "foo" . f) more of a problem than exhausting FDs
10:06:22 <shachaf> You could fork when you're about to have too many FDs open. :-)
10:06:25 <rwbarton> yes! let's spawn a new process and hand it file descriptors over unix sockets! :D
10:06:36 <rwbarton> Too bad kmc isn't here, he'd love this.
10:06:44 <c_wraith> kqr: things declared with the "type" keyword can't have custom instances.  "type" just declares aliases, not real types
10:06:46 <shachaf> This sounds like an entry for some evil contest.
10:06:55 <shachaf> rwbarton: kmc is in other channels these days.
10:07:02 <conal> hopefully we'll figure out how to move all of this file system cruft out of the programming model into the implementation of high-level, denotative alternatives.
10:07:14 <shachaf> I think he got burnt out by #haskell.
10:07:33 <kqr> c_wraith, so if i want to be able to compare my (String, Integer) in a sensible way, is there any other way to construct the type, or do I have to specify unreliable conditions at every comparison?
10:07:41 <rwbarton> He seems to be here p% of the time where p is not close to either 0 or 100.
10:08:12 <rwbarton> But maybe p has gone down in the past few weeks.
10:08:14 <shachaf> rwbarton: Yes, but until recently "kmc here" and "kmc on Freenode" have been roughly the same.
10:08:20 <rwbarton> ah
10:08:42 <c_wraith> kqr: how do you want to compare them?  Seems like the default ordering for tuples should be what you want most of the time.
10:09:49 <rwbarton> This idea is so crazy it just might work. Makes you wonder a little why there is a per-process limit, though
10:10:12 <c_wraith> rwbarton: well, the current per-process limit on linux is just to prevent dos attacks on the kernel
10:10:21 <Saizan> shachaf: we should bring #haskell to kmc!
10:10:22 <kqr> c_wraith, the (String, Integer) is a tag associated with a value (think perhaps directories coupled with their sizes), and i'd like to be able to sort them based solely on the numerical value (find out which directories are the largest)
10:10:33 <shachaf> Saizan: No, don't drive him off from Freenode. :-(
10:10:43 <kqr> c_wraith, i figured the sort functionis implemented using < and >, so it'd make sense to make the tuple orderable
10:10:55 <c_wraith> kqr: if you make the tuple (Integer, String), the default ordering will do that.
10:11:04 <Saizan> shachaf: ok, i'll wait for another occasion to start my stalking career
10:11:17 <rwbarton> kqr: a couple other options are using sortBy, or using a proper data type (declared with 'data')
10:11:21 <kqr> c_wraith, may i be picky and complain that that doesn't represent the kind of data very well?
10:11:33 <shachaf> Saizan: It's never too early to start!
10:11:40 <c_wraith> kqr: in that case, create a custom data type, instead of using a tuple
10:11:44 <kqr> rwbarton, does it make sense to construct a proper data type in my case?
10:11:47 <c_wraith> kqr: then you can create your own instances
10:11:50 <kqr> okay
10:11:53 <kqr> how do i do that?
10:12:05 <c_wraith> data Entry = Entry String Integer
10:12:12 <kqr> oh
10:12:13 <c_wraith> or whatever you want to call it
10:12:14 <tromp> @pl \n -> 4*n*(8*n+1)
10:12:14 <kqr> like that
10:12:14 <lambdabot> liftM2 (*) (4 *) ((1 +) . (8 *))
10:12:18 <shachaf> rwbarton: Oh, you worked at Ksplice too?
10:12:19 <kqr> thanks
10:12:22 <rwbarton> Yep
10:12:38 <tromp> > iterate (\n -> 4*n*(8*n+1)) 1
10:12:39 <lambdabot>   [1,36,41616,55420693056,98286503002057414584576,309127573515950117423442905...
10:13:13 <kqr> c_wraith, to extract the string and the integer i can use pattern matching, right?
10:13:20 <c_wraith> kqr: yes
10:13:24 <kqr> neat
10:13:46 <kqr> is there any way to tell if a type alias or a proper data type is the right thing to use?
10:13:59 <kqr> or is it just best to stick to aliases until you need a proper type
10:14:37 <c_wraith> kqr: I recommend adding "deriving (Show, Eq)" to the end of the data declaration, too.  That will give you a Show instance for debugging, and an Eq instance that works naturally.  (Things are equal if both subparts are the same)
10:14:38 <rwbarton> I think some would say that you should rarely if ever use 'type'.
10:14:56 <kqr> yeah, thanks
10:14:57 <c_wraith> yeah, I only ever use "type" to cut down on typing for complex types I use frequently
10:15:05 <kqr> like String?
10:15:18 <kqr> makes sense
10:15:35 <c_wraith> Heh.  I happen to think String shouldn't be an alias of [Char], but given that it is, the type alias makes sense.
10:15:44 <kqr> haha
10:15:47 <kqr> why shouldn't it?
10:15:54 <rwbarton> that was my reaction too
10:15:57 <kqr> confusing with nested lists?
10:16:18 <c_wraith> kqr: declaring instances...  It's currently really annoying to declare an instance of some class for lists and for strings.
10:16:34 <kqr> i'm not sure i follow
10:16:35 <c_wraith> kqr: they overlap because strings are lists
10:16:44 <kqr> right
10:16:57 <tromp> > filter (\n->n`mod`1000==576) iterate (\n -> 4*n*(8*n+1)) 1
10:16:58 <lambdabot>   Couldn't match expected type `[a]'
10:16:59 <lambdabot>         against inferred type `(a1 -> a1...
10:17:00 <c_wraith> kqr: well, then, don't worry about it for now.  It's something you'll run into in the future, though, probably
10:17:10 <tromp> > filter (\n->n`mod`1000==576) . iterate (\n -> 4*n*(8*n+1)) $ 1
10:17:15 <lambdabot>   mueval-core: Time limit exceeded
10:18:10 <kqr> if it doesn't really make sense to compare two instances of a type (they could look alike, but still be different things), should i avoid deriving eq?
10:18:31 <c_wraith> kqr: yes, if you don't want the == or /= operations to be defined for that type
10:18:49 <kqr> cool
10:18:50 <kqr> i really like the type siystem
10:19:07 <kqr> well, once i got used to it
10:19:08 <kqr> somewhat
10:19:54 <merijn> kqr: Once you've reached that point it (mostly) gets easier from there :p
10:20:16 <c_wraith> kqr: also, since you initially asked about this, if you want to declare a custom ordering on your type, you can use "instance Ord MyType where .." then define compare how you want it to work.  It's a really good idea to make sure that it's consistent with your Eq definition, too.
10:20:46 <kqr> c_wraith, yeah, i saw that somewhere while googling for a solution for type aliases
10:20:55 <c_wraith> kqr: that is, == is true if and only if compare returns EQ
10:24:13 <hpaste_> Sebasti0n pasted “Multiple Calls to vecLen” at http://hpaste.org/56294
10:24:15 <mrakan> How do I get rid of the resource busy error: (\f -> readFile f >>= writeFile f . map toUpper) In other words, how do I force readFile to close the handle before I write to the same file with writeFile?
10:24:32 <mrakan> I know it's better to do this another way, I'm just toying with lazyness.
10:25:09 <Sebasti0n> Can anybody spot the problem in my piece of code? I am computing the centroid of 100 vectors yet vecLen is called multiple thousand times. I can only see it being called once...
10:26:25 <shachaf> Sebasti0n: Did you disable the monomorphism restriction, maybe?
10:26:48 <shachaf> Actually, you wouldn't even need to disable it for this.
10:26:53 <shachaf> What's the type of vecLen?
10:27:04 <shachaf> It's probably polymorphic and so somehow being recomputed every time.
10:27:15 <rwbarton> you would, for le
10:27:31 <hpaste_> Sebasti0n pasted “vecLen” at http://hpaste.org/56295
10:27:44 <Eduard_Munteanu> shachaf: try moving that to the toplevel, might improve sharing
10:27:47 <Eduard_Munteanu> Erm.
10:27:53 <Eduard_Munteanu> Sebasti0n
10:27:54 <shachaf> rwbarton: Are you going to Hac Boston, by the way?
10:28:17 <rwbarton> Yes (just on Saturday though)
10:29:00 <Sebasti0n> shachaf: What do you mean it is recomputed every time?
10:29:39 <shachaf> Sebasti0n: Never mind, whatever I said doesn't apply.
10:29:53 <shachaf> Unless it does?
10:29:58 <shachaf> What are the types of everything?
10:30:02 <rwbarton> where are you getting this "hundreds of thousands times" count?
10:30:09 <rwbarton> oops "multiple thousand times"
10:30:24 <Sebasti0n> I profiled the code
10:30:36 <Sebasti0n> because it was slower than it should have been
10:30:43 <shachaf> Oh. I assumed you were using Debug.Trace for some reason.
10:31:07 <rwbarton> can you paste the profiler output? It can be tricky to interpret
10:31:36 <rwbarton> I don't see how a single call to centroid could generate more than one call to vecLen.
10:32:03 <hpaste_> Sebasti0n pasted “Profiling Output” at http://hpaste.org/56296
10:32:30 <monochrom> clearly, we haven't seen the caller code.
10:33:15 <monochrom> perhaps we are not meant to help troubleshoot this
10:33:39 <rwbarton> does it matter, when vecLen only appears in an argument to a data constructor?
10:34:23 <monochrom> sorry, I see the caller code now
10:34:46 <rwbarton> ah, I thought you meant the caller of centroid.
10:35:23 <Sebasti0n> vecLen is also called when a vector is constructed, but as I only use 100 vectors it shouldn't be that many calls
10:36:41 <Sebasti0n> centroid is called very often in my code, and it is using so much computing time and I don't know why
10:36:58 <Sebasti0n> I am suspecting vecLen is at fault
10:37:31 <shachaf> The hand of vecLen.
10:38:01 <Sebasti0n> true
10:38:16 <Sebasti0n> I do not really see though what I can do
10:40:15 <Sebasti0n> do you need any other information to help?
10:40:31 <kqr> c_wraith, i'm sorry to bother you with another question, but the example i saw on implementing compare was using named fields in the data type declaration
10:40:41 <monochrom> 47.8% of time for get_adM4, 7.5% for centroid, 1.5% for vecLen. I thought that would point away from vecLen or even centroid?
10:40:43 <kqr> c_wraith, can i implement sort based on fields without naming them?
10:40:49 <kqr> c_wraith, or is it a good convention to name them?
10:41:26 <c_wraith> kqr: sure you can.  Just pattern match in the definition
10:41:35 <kqr> ah, right
10:41:36 <kqr> thanks
10:41:54 <Sebasti0n> well, this is just a small test program
10:42:08 <kqr> c_wraith, but data Foo = Foo {Bar :: String, Baz :: Integer} is the same as data Foo = Foo String Integer?
10:42:15 <Sebasti0n> centroid       Hana.Core.Vector                                   10091        1860  49.4   43.1    53.7   45.5
10:42:17 <Kanisterschleife> Hi. I'm trying to compile xmobar from source. Running runhaskell on the Setup.lhs file I'm told that the X11 library is missing. However, cabal list X11 tells me that a new enough version is installed. What could be the problem here?
10:42:32 <Sebasti0n> that is what it looks like in the program where the problem occurs
10:42:44 <Sebasti0n> so I wanted to see what was up with centroid being so slow
10:43:26 <c_wraith> kqr: it's nearly the same (the record selector names need to start with a lowercase value, though).  The record syntax just gives you some extra stuff, but it includes everything in the non-record form, including pattern-matching
10:43:36 <Sebasti0n> and thos 1860 calls to centroid result in 580519 calls to veclen
10:44:08 <monochrom> Kanisterschleife: perhaps it means the C-side X11 library?
10:44:19 <kqr> c_wraith, and the pattern matching against a record type is done in the same way as pattern matching of the other kind of type?
10:44:32 <rwbarton> hmm
10:44:46 <rwbarton> perhaps ghc is doing too much inlining?
10:44:49 <monochrom> also "cabal list" is unreliable. use "ghc-pkg list"
10:44:59 <Eduard_Munteanu> Sebasti0n: have you factored vecLen outside, on the toplevel?
10:45:06 <Eduard_Munteanu> And give it a type sig.
10:45:18 <Sebasti0n> it is on the top level
10:45:22 <Eduard_Munteanu> Ah.
10:45:23 <c_wraith> kqr: It can be used the exact same way.  It actually provides an additional option, but don't worry about that for now.
10:45:34 <kqr> c_wraith, sounds good
10:45:36 <rwbarton> try adding {-# NOINLINE centroid #-}
10:46:01 <Kanisterschleife> monochrom: According to this, X11 1.5.0.1 is installed, and runhaskell tells me that X11 is missing and should be of version >= 1.3.0
10:46:02 <Sebasti0n> above the type sig?
10:46:04 <kqr> c_wraith, out of curiosity, what is the extra option about? (no need for a detailed description, just the general idea)
10:46:09 <rwbarton> yes
10:46:57 <Sebasti0n> what do you suspect the problem to be?
10:46:59 <monochrom> oh, I now remember. add "--user" to your Setup.lhs command
10:47:07 <monochrom> or commands
10:47:32 <c_wraith> kqr: you can pattern match on named fields, with something like (Foo {bar = ""}).
10:47:53 <kqr> aha, like that
10:48:20 <monochrom> "cabal install" defaults to --user and Setup.lhs defaults to --global
10:48:27 <kqr> c_wraith, is it good practise to always mconstruct record types, or are there reasons to avoid them?
10:48:43 <Sebasti0n> rwbarton: it didn't change anything
10:49:21 <rwbarton> I was thinking of something like "let Vector x y z = centroid vs in {- use z many times -}", then perhaps z gets replaced by vecLen vs and unshared
10:50:12 <c_wraith> kqr: using named fields is more verbose often, but it makes the program code more resilient to adding fields in the record.  If you have a record type that you expect to change a lot, it can make maintenance easier.
10:50:24 <c_wraith> kqr: but it's mostly a matter of taste
10:50:32 <Sebasti0n> in the profiling report, when vecLen is ident under centroid, does it mean the calls listed result from calls from centroid?
10:50:35 <Kanisterschleife> monochrom: Cool, this works! Could you explain what the differen between --user and --global is?
10:50:39 <Sebasti0n> only from centroid?
10:50:44 <kqr> c_wraith, good point
10:51:04 <kqr> c_wraith, i probably won't change this type much, so i was thinking rather in a self-documentation viewpoint
10:51:19 <rwbarton> Sebasti0n: I would think so
10:51:36 <Sebasti0n> this is very weird then
10:52:03 <Sebasti0n> I mean it is doing things and I don't know how to change anything as it should be called just once
10:52:24 <monochrom> Kanisterschleife: my http://www.vex.net/~trebla/haskell/sicp.xhtml#globaluser may help.
10:53:15 <rwbarton> btw, do you in fact have NoMonomorphismRestriction?
10:53:43 <Sebasti0n> no
10:54:11 <c_wraith> kqr: no one would find either direction odd, really.  Use whichever you think is more appropriate, for yourself.
10:54:15 <kqr> c_wraith, fields in record types must be unique even across multiple types?
10:54:32 <rwbarton> what happens if you replace the type signature of centroid by [Vector Double] -> Vector Double?
10:54:57 <kqr> c_wraith, field names*
10:54:58 <c_wraith> kqr: yes, the names are defined at the module scope, not specifically for the type.
10:55:07 <Kanisterschleife> monochrom: Ok, so the X11 module was installed "locally" only for my current user, and hence runhaskell, looking only for global modules by default, couldn't see it?
10:55:11 <kqr> c_wraith, okay
10:55:17 <monochrom> right
10:55:26 <Kanisterschleife> monochrom: Great, I understand - thank you very much!
10:57:15 <Sebasti0n> rwbarton: vecLen is called just once
10:57:22 <Sebasti0n> horray
10:57:29 <Sebasti0n> what was the cause for this??
10:57:34 <rwbarton> no idea
10:57:45 <Sebasti0n> and you still fixed it ;)
10:58:56 <rwbarton> did it make your program actually faster?
10:59:10 <rwbarton> not just some number of calls as measured by the profiler went down
10:59:59 <akosch> oh no, I have cyclic module imports! what can I do?
11:00:03 <Sebasti0n> I will check that now
11:00:32 <parcs`> akosch: combine the modules into one
11:01:37 <parcs`> or refactor the cyclic part into its own module, or read about .hs-boot files
11:01:39 <akosch> parcs`: I liked them the way they are, but I guess it won't hurt... much :)
11:02:39 <akosch> parcs`: I'd rather skip the third option, sounds scary
11:03:02 <parcs`> an .hs-boot file is like a c header file
11:03:12 <hpaste_> Duffman- pasted “statemonad” at http://hpaste.org/56297
11:03:27 <Duffman-> hey guys, i'm looking into the statemonad in learn you a haskell for great good
11:03:34 <Duffman-> the author suggests this code snippet: http://hpaste.org/56297
11:03:43 <Duffman-> later on he says that the binding to a is obsolete
11:03:48 <Duffman-> which I understand
11:04:03 <Sebasti0n> rwbarton: I have to change some more things, I'll be back in a bit
11:04:04 <Duffman-> but in the code I just pasted, what value is bound to a?
11:04:28 <parcs`> Duffman-: 3
11:04:33 <Duffman-> yes, that's what my gut says
11:04:43 <parcs`> and the last pop will cause an error
11:04:48 <Duffman-> but I don't understand why if I look at the implementation of the state-monad and the functions pop & push
11:04:51 <akosch> parcs`: does cabal work with .hs-boot files?
11:04:52 <shachaf> Duffman-: What's the type of pop?
11:04:58 <Duffman-> State Stack Int
11:05:03 <shachaf> Oh.
11:05:14 <shachaf> Then, yes, 3.
11:05:25 <shachaf> And the function stackManip as a whole is equivalent to pop.
11:05:31 <shachaf> Not necessarily an error.
11:05:42 <parcs`> akosch: i think so
11:05:53 <Duffman-> yes, I can see that. But can you explain how the "3" ends up in the "a" value?
11:06:09 <Duffman-> I don't see how the implementation of "pop" returns the element it just popped
11:06:19 <parcs`> Duffman-: what is the implementation of pop?
11:06:19 <akosch> parcs`: thanks!
11:06:23 <Duffman-> wait
11:06:36 <Duffman-> I'll give you another hpaste link soon
11:06:39 <parcs`> pop = State $ \(x:xs) -> (x, xs) ?
11:07:01 <Duffman-> yes
11:07:12 <Duffman-> so x =  3
11:07:23 <Duffman-> but it doesn't seem to return "x" somewhere
11:08:03 <rwbarton> the other important bit is the implementation of (>>=) for State
11:08:13 <Duffman-> yes
11:08:23 <shachaf> Duffman-: Expand the do-notation.
11:08:36 <parcs`> and then expand the version of >>=, if necessary :P
11:08:37 <Duffman-> yes I'm writing that down
11:08:45 <parcs`> implementation*
11:09:11 <Duffman-> i'll see if I can find an error in my expansion
11:09:16 <Duffman-> I'll let you know in 5 :)
11:14:32 <Duffman-> parcs`: shachaf: what I get after expansion: push 3 >== (\_ -> pop >== (\a -> pop))
11:16:46 <parcs`> Duffman-: do you understand how State works conceptually?
11:17:32 <Duffman-> I think that's what I'm trying to figure out
11:18:31 <Duffman-> I understand the first push
11:19:03 <parcs`> but you don't understand the pop?
11:19:40 <Duffman-> I think I do
11:19:57 <Duffman-> what I understand from it is
11:21:33 <Duffman-> it applies function h (which is everything after the "$" in the implementation of pop) on the current state, it takes its head and puts that in "a", and the tail of the state is the new state
11:23:39 <Duffman-> then it applies function f (which is \a -> pop) and applies that to "a".
11:23:52 <Duffman-> no I'm not sure I think
11:24:06 <Duffman-> about the step after (a, newState) = h s
11:24:59 <carpi> dear haskellers.. how do you usually comment your programs?
11:25:13 <carpi> before the function or on the sides right after the statement?
11:25:21 <Duffman-> it binds g to \(x:xs) -> (x,xs)
11:25:34 <Duffman-> and then finally applies "g" to newState"
11:25:47 <DanBurton> carpi: it depends, but usually before
11:26:03 <carpi> tnaks for the clarification.i think ill follow the same
11:27:37 <DanBurton> carpi: "on the side" is of course useful when evaluating Haskell for an audience, e.g. lambdabot or ghci
11:27:45 <DanBurton> > 3 + 3 -- carpi: like this
11:27:46 <lambdabot>   6
11:27:51 <Duffman-> so parcs`, what I think that happens when "a <- pop" is called is the following: it applies function h (which is everything after the "$" in the implementation of pop) on the current state which means it takes its head and puts that in "a", and the tail of the state is the new state.
11:28:32 <Duffman-> After that (Stage g) = f a results in binding g to the implementation of "pop"
11:28:44 <gwern> lambdabot: @join #lesswrong
11:28:45 <carpi> ah yes.. i noticed that style in some of the books and  articles about haskell.  : )
11:29:01 <Duffman-> to finally apply that implementation to the newState...
11:29:16 <Duffman-> but there's something wrong in my train of thought because I'm not binding a...
11:30:11 <DanBurton> carpi: and if you're documenting a module, haddock style is recommended: http://www.haskell.org/haddock/
11:37:04 <gregATio> anyone know how to start and use flymake in ghc-mod
11:46:48 <mm_freak> what kind does (->) have in GHC 7.4 with PolyKinds enabled?
11:48:16 <DanBurton> * -> * -> * is its regular kind; dunno what Polykinds are exactly but I can't imagine why they would change that
11:48:40 <DanBurton> @kind (->)
11:48:41 <lambdabot> ?? -> ? -> *
11:48:50 <DanBurton> well ok the weird question mark kinds
11:48:53 <mm_freak> it's kind polymorphism…  yeah, i'd expect that (except for the unlifted type stuff)
11:49:18 * hackagebot logic-classes 1.1 - Support for propositional and first order logic, normal forms, and a resolution theorem prover.  http://hackage.haskell.org/package/logic-classes-1.1 (DavidFox)
11:50:02 <mm_freak> i wondered whether PolyKinds supports higher-"sorted" kind polymorphism
11:52:32 <byorgey> mm_freak: what do you mean by "higher-sorted kind polymorphism"?
11:52:51 <byorgey> and DanBurton is right, (->) still has the same kind
11:53:49 <mm_freak> byorgey: lifting higher-kinded polymorphism (forall (a :: * -> *)) to the next level
11:54:28 <byorgey> ah. No, it does not support that.
11:54:42 <byorgey> although it might at some point in the future.
11:54:50 <DanBurton> what exactly is the "next level"?
11:55:14 <mm_freak> DanBurton: in pseudo-code you would say that Constraint has sort * -> *
11:55:23 <byorgey> DanBurton: terms are classified by types which are classified by kinds which are classified by ...
11:55:26 <mm_freak> DanBurton: now imagine being polymorphic about such a thing
11:56:03 <DanBurton> that's kind of like asking me to think about a four-dimensional object. I can sorta imagine it, but it's rather immaterial to me at the moment
11:56:05 <mm_freak> oh wait, no…  Constraint would have sort *
11:56:05 <byorgey> mm_freak: Constraint does not have an arrow sort.
11:56:22 <byorgey> DanBurton: that sounds pretty accurate =)
11:56:29 <DanBurton> =)
11:56:49 <mm_freak> well, (->) for kinds has sort * -> * -> *, where "*" means "kind"
11:57:00 <byorgey> mm_freak: PolyKinds has been carefully designed so only one sort is needed
11:57:24 <byorgey> mm_freak: for example, you cannot use (->) (the kind version) on its own, it must be fully applied
11:57:31 <mm_freak> yeah, i read that
11:57:45 <mm_freak> i guess that's good
11:58:04 <byorgey> I don't know if it's good, but it is simple.
11:58:24 <mm_freak> PolyKinds allows weird code already
11:58:37 <mm_freak> useful, but weird
11:58:48 <byorgey> exactly.  the idea was to do something as simple as possible while still allowing interesting new things
11:58:55 <DanBurton> it won't be weird once we brainwash everyone to get used to it
11:59:18 <byorgey> DanBurton: right. and at that point we will have a better idea of what other extra features people want the most.
11:59:30 <mm_freak> i love it already =)
11:59:38 <byorgey> =)
11:59:43 <mm_freak> but i'll wait for GHC 7.4 to make it into the platform, which might take a few months
12:00:21 <byorgey> that could take a long time
12:00:36 <mm_freak> i'm still waiting for the "exists" keyword…  that's something i'd love
12:01:05 <mm_freak> other implementations have it, but i'm pretty much GHC-bound
12:01:22 <DanBurton> is there a trac ticket for that?
12:01:25 <byorgey> the only other implementation I know of that has it is UHC
12:03:12 <byorgey> mm_freak: however, UHC's implementation is pretty limited; in particular it cannot be used along with type class constraints
12:03:26 <byorgey> and that covers pretty much 99% of how existentials actually get used
12:03:29 <mm_freak> well, that's quite useless
12:04:08 <copumpkin> nuh uh
12:04:16 <copumpkin> I use existentials without constraints a lot
12:04:25 * DanBurton demands examples
12:04:25 <byorgey> copumpkin: oh really? in what context?
12:04:44 <copumpkin> well, the constraints come from within the GADT, I guess :)
12:04:50 <copumpkin> you have a GADT with "phantom" types
12:04:57 <copumpkin> pattern matching introduces constraints
12:05:04 <copumpkin> but the existential itself doesn't need them
12:05:12 <byorgey> oh, right, I see
12:05:25 <copumpkin> this is also why I asked for pure existential newtypes on the bugtracker
12:05:31 <copumpkin> since they're not allowed right now
12:05:33 <mm_freak> DanBurton: say you have a statically length-checked list type (List :: Nat -> * -> *)
12:05:55 <byorgey> mm_freak: don't hold your breath for an exists keyword.  It is not at all clear to me how it would actually work.
12:06:16 <mm_freak> DanBurton: one way to implement 'getLine' is:  getLine :: (forall n. List n Char -> IO b) -> IO b
12:06:20 <copumpkin> Marco: yay dartmouth
12:06:37 <mm_freak> DanBurton: the other is:  getLine :: IO (exists n. List n Char)
12:06:43 <mm_freak> add constraints
12:07:26 <mm_freak> DanBurton: currently you have to write a wrapper type for the second style:  data ListP a = forall n. Length n => ListP (List n a)
12:07:43 <DanBurton> mm_freak: makes sense
12:08:07 <mm_freak> byorgey: well, GHC 7.4 with ConstraintKinds gives an example of how that could work
12:08:36 <mm_freak> please ban Rapeseed…  spamming me by privmsg
12:08:43 --- mode: ChanServ set +o copumpkin
12:08:54 <copumpkin> mm_freak: personalized spam or just general spam?
12:08:58 <copumpkin> Rapeseed: you there?
12:09:03 <mm_freak> general
12:09:05 --- mode: copumpkin set +b *!~Rapeseed@201.160.243.202
12:09:05 --- kick: Rapeseed was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
12:09:14 --- mode: copumpkin set -o copumpkin
12:09:16 <DanBurton> mm_freak: couldn't GHC just implement "exists" with a sort of preprocessor that expands "exists" into the workaround?
12:09:22 <DanBurton> copumpkin: I got the spam too
12:09:22 <mm_freak> i don't what to quote, because it's racist
12:09:33 <copumpkin> mm_freak: aha, thanks!
12:09:36 <mm_freak> DanBurton: yes, that's what i'm suggesting
12:09:44 <byorgey> DanBurton: no, because "expanding into the workaround" involves inventing a name for a constructor
12:09:50 <byorgey> and that is exactly what the problem is
12:09:58 <DanBurton> byorgey: what's wrong with that?
12:10:05 <byorgey> to make an existential package you need some way to pattern-match it again
12:10:30 <mm_freak> byorgey: straightforward pattern-matching wouldn't work?
12:10:51 <mm_freak> you don't have to translate to the workaround literally
12:11:00 <byorgey> mm_freak: you'd have to invent a new syntax for opening/pattern-matching on existentially quantified values
12:11:21 <byorgey> which is silly since we already have a way to encode it using data types.
12:11:29 <mm_freak> probably an 'Exists' library is better than an 'exists' construct
12:11:32 <Eduard_Munteanu> mm_freak: I think you need a wrapper if you're essentially translating that to a regular data existential
12:11:48 <DanBurton> mm_freak: not a bad idea
12:12:21 <mm_freak> well, ConstraintKinds gives us that option, so i guess with GHC 7.4 i won't be calling for 'exists' that much anymore =)
12:12:56 <Eduard_Munteanu> How do you mean? (I'm not really familiar with ConstraintKinds)
12:13:14 <Sebasti0n> rwbarton: It reduced the runtime from 20 to 5 seconds, so yes, it helped. thank you!
12:13:42 <mm_freak> data Exists (c :: * -> Constraint) = forall a. (c a) => Exists { extract :: a }
12:13:49 <mm_freak> not sure if the syntax is right, but that's the idea
12:14:34 <Eduard_Munteanu> Ah, I kinda see what you mean.
12:14:43 <mrakan> What's the definition of (seq)?
12:14:53 <mrakan> Is it a primitive?
12:14:57 <Eduard_Munteanu> mrakan: it's a primitive
12:15:02 <mrakan> Okay, thanks.
12:15:10 <Eduard_Munteanu> But it's much like a 'const'.
12:15:23 <Eduard_Munteanu> :t seq
12:15:23 <lambdabot> forall a t. a -> t -> t
12:15:26 <Eduard_Munteanu> :t const
12:15:27 <lambdabot> forall a b. a -> b -> a
12:15:46 <Eduard_Munteanu> Except for being flipped and its effect on evaluation.
12:16:46 <byorgey> mm_freak: ahhh, I see, neat =)
12:17:00 <Eduard_Munteanu> Well, you can define 'seq' using bang patterns, but it should be thought of as a language primitive, conceptually.
12:17:19 <mrakan> Aren't bang patterns defined partially using seq?
12:17:29 <mm_freak> byorgey: you still need type aliases though, if you want multiple constraints, which is a bit unfortunate, but yeah, it would help a lot
12:17:37 <Eduard_Munteanu> mrakan: seq as a concept perhaps
12:18:02 <byorgey> mm_freak: oh, I see, right, because we don't have   (Eq, Show) :: * -> Constraint
12:18:03 <mm_freak> type IntBits a :: Constraint = (Bits a, Integral a)
12:18:07 <byorgey> yeah
12:18:07 <mm_freak> yeah
12:19:18 <mm_freak> mrakan: bang patterns need seq…  "f (!x) = y" is roughly translated to "f x | x `seq` False = undefined | otherwise = y"
12:20:13 <mm_freak> mrakan: in general pattern matching is the preferred way to introduce strictness…  it keeps the code clean
12:20:51 <Eduard_Munteanu> That'd be the core seq I presume.
12:21:29 <DanBurton> mm_freak: dealing with numeric code, that isn't always an option though
12:22:32 <mm_freak> DanBurton: usually you only need to force the result…  the arguments are usually subject to some termination condition, unless you are producing codata, in which case you don't need seq
12:23:17 <mm_freak> the "result" being an accumulation argument
12:23:37 <Duffman-> :t fmap
12:23:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:26:35 <hpaste_> Duffman- pasted “Monads3” at http://hpaste.org/56300
12:26:45 <zgillis> *Discuss politics now at ##nexo !*
12:31:22 <rwbarton> heh, what happens with bang-patterns and RebindableSyntax?
12:31:33 <Duffman-> hey guys, I'm trying to figure out the state monad with someone from my class ( Nath ) but we're kind of stuck. Can someone please have a look at this code: http://hpaste.org/56300   We're trying to write down what happens when "runState stackManip [5,8,2,1]" is executed. We have expanded the do-block as follows: push 3 >>= (\_ -> pop >>=(\a -> pop)). We're now trying to figure out the result
12:31:33 <Duffman-> of the first ">>=". We are however stuck because the State constructor needs 2 parameters, but in the state-monad implementation, all we see is (State x) (only 1 parameter.) So to what is this "x" being bound?
12:32:48 <Eduard_Munteanu> rwbarton: presumably you get the core seq regardless of RebindableSyntax?
12:33:25 <Eduard_Munteanu> I guess that's what the bang patterns translation refers to.
12:34:27 <Botje> Duffman-: the State *type* has two arguments.
12:34:29 <funktronic> @src (.)
12:34:29 <lambdabot> (f . g) x = f (g x)
12:34:30 <lambdabot> NB: In lambdabot,  (.) = fmap
12:34:39 <Botje> Duffman-: the State *constructor* only has one.
12:35:54 <alistra> Duffman, oh yeah!
12:36:14 <Duffman-> Botje: if I'm understanding correctly then, x is bound to "\xs -> ((),a:xs)" ?
12:37:16 <Duffman-> alistra: haha, I see you're a big fan. :)
12:37:40 <alistra> i saw all the episodes
12:38:13 <alistra> counting the one from today :D
12:39:21 <Duffman-> :D
12:39:31 <Botje> Duffman-: yes.
12:39:52 <Duffman-> and what happens with the "3" then, that's in "push 3"?
12:40:51 <Duffman-> it just gets bound to the "a" of "push a" I guess ..
12:41:31 <Botje> yes
12:42:35 <DanBurton> "push 3", by equational reasoning, can be expanded to "State $ \xs -> ((), 3:xs)"
12:42:52 <Duffman-> yeah, and then only the part after the "$" is bound to x I assume.
12:42:59 <The_Journey> when I'm using foldl with a lambda function, is the accumulator on the left or on the right of the lambda? Like is it this \x acc ->, or is it this \acc x -> ?
12:43:17 <Duffman-> \x acc -> I believe
12:43:22 <Botje> The_Journey: the type is a -> b -> a, with a as return type
12:43:33 <The_Journey> oh right, the types -_-
12:43:41 <hpc> use the types, luke
12:43:49 <Botje> that's how i remember it ;)
12:44:30 <DanBurton> The_Journey: foldl, accumulator is the "left" argument. foldr, accumulator is the "right" argument. That's how I remember. =)
12:44:51 <Duffman-> DanBurton: that's how I remember it as well :)
12:45:07 <DanBurton> though I periodically forget and doubt myself
12:45:11 <The_Journey> is pattern matching allowed in a lambda function?
12:45:24 <Botje> sure
12:45:28 <Duffman-> The_Journey: yes
12:45:29 <The_Journey> ok, thank you
12:45:35 <Botje> you will get nasty runtime exceptions if the pattern doesn't match, though
12:45:36 <DanBurton> The_Journey: allowed, yes. Not always a good idea, since you can only match one pattern.
12:46:31 <DanBurton> e.g. Matching a newtype is never problematic, because there is only one constructor
12:46:59 <DanBurton> Matching on tuples is also never problematic, as they only have one constructor per tuple type
12:52:22 <The_Journey> is it possible to build a list using foldl? How would an example look like?
12:53:00 <dmwit> :t foldl
12:53:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:53:19 <dmwit> > foldl (flip (:)) [] [1..5]
12:53:21 <lambdabot>   [5,4,3,2,1]
12:53:24 <mjrosenb> The_Journey: if that a is actually [c], then the return type will be a list
12:53:31 <mjrosenb> sort of like that.
12:53:44 <DanBurton> The_Journey: foldl is used for consuming a list, to produce anything. So assuming you have a list from which to build the desired list, then yes, you can.
12:54:26 <The_Journey> ah ok, I see
12:54:37 <ski> > foldl (\s n -> concat ["(",s," + ",show n,")"]) "0" [2,8,5,7,1,4]
12:54:38 <lambdabot>   "((((((0 + 2) + 8) + 5) + 7) + 1) + 4)"
12:54:51 <ski> > foldr (\n s -> concat ["(",show n," + ",s,")"]) "0" [2,8,5,7,1,4]
12:54:52 <lambdabot>   "(2 + (8 + (5 + (7 + (1 + (4 + 0))))))"
12:55:27 <The_Journey> how do I include module path in ghci? I'm trying to load a file but I can't pass the flag -i<directory> like I can when using just ghc
12:55:59 <mjrosenb> The_Journey: :load
12:56:18 <mjrosenb> The_Journey: or :import
12:56:48 <dmwit> :set -i<directory>
12:57:26 <The_Journey> dmwit: thank you, that worked
12:57:54 <mjrosenb> oh... module path...
12:58:02 <mjrosenb> i totally missed the word 'path'
13:04:07 <jeff_s_> I have a function :: ByteString -> Either ByteString (Int, ByteString), how do I turn it into a function :: a -> Maybe (Either ByteString (Int, ByteString))? I was thinking liftM, but that gives me a type error.
13:04:32 <copumpkin> (return . )
13:04:39 <copumpkin> or (Just .)
13:04:52 <copumpkin> oh wait, where'd that a come from?
13:04:58 <Roberta}{> FREE PORN MOVIES AT => WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX WWW.FROG.XXX
13:04:58 <Roberta}{> WWW.FROG.XXX
13:05:10 --- mode: ChanServ set +q *!*@31.Red-95-124-172.staticIP.rima-tde.net
13:05:19 <dmwit> Yes, that 'a' is throwing me for a loop, too.
13:05:20 <alistra> hey
13:05:25 <alistra> i was interested in that
13:05:31 <jeff_s_> Hm, maybe I'm not using the output of the function correctly.
13:06:24 <jeff_s_> No, I think it's right. I'm doing f >>= return . fst, to get the first part of the Right part of the Either.
13:06:41 <jeff_s_> or, with your edit, return . f >>= return . fst
13:07:57 <copumpkin> huh?
13:08:19 <jeff_s_> So f :: ByteString -> Either ByteString (Int, ByteString)
13:08:33 <jeff_s_> I'm performing a computation in the Maybe monad, and want to use f.
13:08:43 <jeff_s_> And then I want to pull out the Int part.
13:09:01 <parcs`> :t either Nothing (return . fst)
13:09:02 <lambdabot>     Couldn't match expected type `a -> c'
13:09:02 <lambdabot>            against inferred type `Maybe a1'
13:09:02 <lambdabot>     In the first argument of `either', namely `Nothing'
13:09:03 <copumpkin> so you want ByteString -> Maybe Int ?
13:09:16 <copumpkin> parcs`: might as well just do Just instead of return :P
13:09:24 <copumpkin> or use mzero
13:09:43 <copumpkin> :t either (const mzero) (return . fst)
13:09:43 <lambdabot> forall (m :: * -> *) a a1 b. (MonadPlus m) => Either a (a1, b) -> m a1
13:09:46 <parcs`> :t either (fail . show) (Just . fst)
13:09:46 <lambdabot> forall a a1 b. (Show a) => Either a (a1, b) -> Maybe a1
13:10:08 <parcs`> > fail "" :: Maybe a
13:10:09 <lambdabot>   Nothing
13:10:09 * copumpkin slaps parcs` for using fail
13:10:18 <jeff_s_> I'm not trying to get rid of the Either monad. Maybe (Either ByteString Int) is the return type I expect.
13:10:19 * parcs` fails
13:11:05 <parcs`> why do you expect that type?
13:11:36 <jeff_s_> Because I'm performing a parse on something that might or might not exist in a map.
13:11:57 <copumpkin> jeff_s_: then just compose it with Just
13:12:22 <parcs`> you can use let to bind a non-monadic value
13:12:35 <copumpkin> yeah
13:20:35 <DukeDave> So, I've managed to send ghci off in to no-where-land
13:20:42 <DukeDave> (I'm playing with wxHaskell)
13:20:54 <DukeDave> It's not responding to ^C
13:20:59 <DukeDave> Should it?
13:21:07 <cheater_> try ^\
13:22:14 <DukeDave> cheater_: Nope :(
13:22:17 <jeff_s_> Could my problem be that I'm starting with the Maybe monad? I need to inject Right into Map.lookup.
13:22:33 <cheater_> try kill -15
13:22:44 <DanBurton> usually ghci will stop for me after spamming ^C a few times
13:22:46 <DukeDave> cheater_: Oh, yeah, I can kill it
13:23:07 <DukeDave> But as DanBurton has just hinted, normally you can kill things gracefully
13:23:49 <DanBurton> and if you've found a way to prevent it from dying gracefully, the ghci devs probably want to know :)
13:23:55 <cheater_> nothing graceful about spamming ctrl-c
13:24:10 <cheater_> kill -15 is in no way worse
13:24:11 * DanBurton spams ctrl-c with much grace
13:24:15 <cheater_> it just tells the program to close
13:24:40 <DukeDave> Well, you lose ghci as well
13:24:42 <DukeDave> Unless..
13:24:54 <DanBurton> ^C doesn't kill ghci
13:25:03 <DukeDave> DanBurton: Yes!
13:25:05 <DanBurton> it just interrupts/stops whatever it is munching on
13:25:14 <DukeDave> But ^C isn't working here :|
13:25:19 <DanBurton> sadface
13:25:39 <DukeDave> cheater_: So you see, it would be nice to kill the IO, without having to kill ghci
13:25:43 <DanBurton> what expression did you evaluate that made it hang?
13:25:58 <cheater_> what
13:26:03 <DukeDave> Just calling Graphics.UI.WX.start
13:26:07 <cheater_> kill the io without killing ghci? what does that mean
13:26:22 <DukeDave> Well, Graphics.UI.WX.start (return ())
13:26:50 <DukeDave> cheater_: To stop the evaluation of that start function ^
13:27:20 <cheater_> what does that even mean
13:27:21 <mdmkolbe> Where does GHC document all the different sorts of kinds that exist?  (e.g. "#")
13:27:29 <cheater_> you don't evaluate functions in an STG
13:27:30 <mdmkolbe> I'm unable to find it in the user's guide
13:27:57 <DanBurton> @wiki kind
13:27:58 <lambdabot> http://www.haskell.org/haskellwiki/kind
13:28:35 <DanBurton> links to http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes
13:28:42 <DukeDave> cheater_: I don't know how an STG is?
13:28:56 <cheater_> spineless tagless g-machine
13:28:58 <DukeDave> I'd give you a reproduction, but darcsden has just gone down :(
13:28:58 <DanBurton> mdmkolbe: that what you were looking for?
13:29:50 <DukeDave> Presumably when you 'do some IO' in ghci, it doesn't start another OS process, or does it?
13:29:51 <mdmkolbe> DanBurton: That looks like a good place for me to start
13:35:22 <DukeDave> cheater_: Does that make sense?
13:36:29 <DukeDave> Woo, darcsden is back up
13:37:21 <Vish> Hi
13:37:32 <Vish> Guys, how do I create a list
13:37:34 <cheater_> DukeDave: no idea.
13:37:58 <Vish> what does x:xs mean?
13:38:08 <DukeDave> Ah, sorry, so if you kill the ghc process, then it drops you back to the ghci prompt
13:38:14 <shachaf> Vish: You should probably read an itnroduction to Haskell.
13:38:21 <shachaf> It'll be more productive than asking questions like that in here.
13:38:30 <shachaf> I hear that this one is popular, though I've never read it:
13:38:30 <Vish> I have exam tomorrow and I just need basic haskell for proof by induction
13:38:32 <shachaf> @where lyah
13:38:32 <lambdabot> http://www.learnyouahaskell.com/
13:38:52 <shachaf> Vish: That's not the way to learn Haskell, sadly, as popular as "test-driven development" might be these days.
13:39:19 <Vish> I just need to 5 functions such as lenght, drop, take, reverse, ++.
13:39:29 <Vish> those are the only 5 i need to know
13:40:44 <copumpkin> Vish: that kind of attitude is bound to annoy people who love haskell around here :)
13:40:54 <monochrom> here is a concrete example. 5:[1,4] means [5,1,4]. actually it's the other way round, [5,1,4] is syntax sugar for 5:(1:(4:[])). [] is the empty list. my parentheses are redundant.
13:40:56 <copumpkin> which is presumably why they hang out in an IRC channel about it
13:41:13 <DukeDave> copumpkin: Well, apparently there's something to be said for lazy evaluation..
13:41:16 <Vish> thanks monochrom
13:41:30 <copumpkin> DukeDave: definitely :)
13:41:53 <DukeDave> If the lecturer hasn't asked about proof by induction until the exam, then it's not reasonable to expect someone to revise it :)
13:42:34 <Vish> I know how to prove by induction, it's just haskell that I am having trouble with. The lecturers at MIT are not very helpful.
13:42:49 <copumpkin> v
13:43:03 <copumpkin> Vish: come to the haskell hackathon on the 20th :)
13:43:17 <Vish> where is it?
13:43:18 <copumpkin> (at MIT)
13:43:21 <copumpkin> can't remember what room
13:43:24 <Vish> what venue?
13:43:30 <copumpkin> http://www.haskell.org/haskellwiki/Hac_Boston
13:43:36 <monochrom> I wouldn't believe or disbelieve students' unilateral statements about teachers. I also think it's irrelevant.
13:43:45 <monochrom> err, s/it's/they're/
13:44:22 <copumpkin> The hackathon itself is in Building 4 spread between rooms 159 and 261.
13:44:27 <Vish> Thanks mate.
13:44:28 <copumpkin> that was more hidden than it should be :P
13:45:07 <Vish> thanks guys, i guess, i will try my best.
13:45:56 <u_quark> let process f data = partial_result:process f rest where (partial_result, rest) = f data {- ignoring data is a keyword -} like parsers work... what's the name of that function/process/pattern?
13:46:04 <monochrom> actually make it s/disbelieve//
13:46:29 * Clint learns of the existence of trifecta
13:58:05 <kqr> how do you do if you have a function that reads a file, performs some operations on the content, closes the file, and then wants to return the modified content? if i put hClose before return, it just returns an empty string. does it close the file otherwise?
13:58:36 <gregATio> guys im having an issue with my emacs setup, haskell-saved-checked-command is nill, anyone got any ideas whats wrong with my setup?
13:58:48 <dmwit> kqr: Why not just use readFile?
13:58:59 <kqr> dmwit, i'll look that up
13:59:29 <kqr> dmwit, looks like precisely what i want. thanks
14:01:35 <hpaste_> plediii pasted “Why isn't the class of a restricted in 'test'?” at http://hpaste.org/56303
14:02:29 <hpaste_> plediii annotated “Why isn't the class of a restricted in 'test'?” with “Why isn't the class of a restricted in 'test'? (annotation)” at http://hpaste.org/56303#a56304
14:02:33 <shachaf> plediii: Data type constraints don't do what you think they do.
14:02:39 <shachaf> In fact, they do practically nothing useful.
14:02:41 <shachaf> You should never use them.
14:02:59 <plediii> shachaf: I realize it's not what I think, that's why I'm asking
14:03:03 <shachaf> What you seem to be trying to do here is closer to an existential type.
14:03:28 <shachaf> You can look up how existential types work on the wiki or something; however, you probably don't *want* existential types either, for this example.
14:03:33 <shachaf> Why are you using a typeclass at all?
14:04:36 <plediii> shachaf: what I'm really trying to do is reduce the number of times I have to write that constraint in functions
14:04:50 <shachaf> plediii: In particular, what does a Datum give you that a Char doesn't?
14:05:26 <plediii> so in that example, say I only want Datum to carry types of class C.  How can I avoid writing (C a) => in front of every function that uses Datum?
14:06:06 <shachaf> plediii: You can use an existential type, like I said, in certain cases.
14:06:19 <shachaf> Or you can sometimes get a more flexible solution with more specific GADTs.
14:06:28 <gregATio> does the following make any sense to anyone, "haskell-check-command = hlint"
14:06:30 <shachaf> However, are you sure you want to be doing what you think you want to be doing?
14:07:25 <Jafet> u_quark: it happens to be an unfoldr
14:07:40 <monochrom> please don't name your functions "test" :)
14:07:56 <Jafet> What if they test!
14:08:06 <Pseudonym> Then they test something.
14:08:11 <shachaf> Yes.
14:08:16 <shachaf> Name your functions "testSomething".
14:08:18 <shachaf> That's a good name.
14:08:27 <monochrom> dummy_doll
14:08:27 <hiptobecubic> A little generic, no?
14:08:28 <Pseudonym> You can call it "test" if it's something that takes a test.
14:08:31 <hiptobecubic> :)
14:08:39 <Jafet> testTest
14:08:42 <gregATio> evenBetterName them should___When_____
14:08:43 <dmwit> Yes, "test" is much too long. Just name it "t".
14:08:45 <monochrom> I actually renamed that one to seafood
14:08:45 <shachaf> testASpecificSOmething
14:08:57 <Pseudonym> dmwit: Don't laugh. Lee Naish probably would call it that.
14:09:02 <u_quark> Jafet: yes, thanks
14:09:19 <shachaf> plediii: I urge you to figure out what you want to do before jumping to typeclasses.
14:09:20 <gregATio> oh god I've started writing in CamelCase
14:09:36 <Pseudonym> HaveYouKnow
14:09:41 <Pseudonym> HaveYouNow
14:09:53 <gregATio> LOLoud
14:09:55 <Pseudonym> See, "test" is both a verb and a noun.
14:10:09 <Pseudonym> If you intend it to be a verb, you could call it "test".
14:10:17 <Pseudonym> If you intend it to be a noun, make it more specific.
14:10:38 <shachaf> Unless it's an argument.
14:10:40 <gregATio> hmmm i like that pseudonym
14:10:45 <Jafet> What if I want it to be an adverb
14:10:49 <plediii> shachaf: Obviously that example isn't a very good use of typeclasses.  I just don't understand why if Datum's argument is always an instance of C, I have to repeate that everywhere
14:10:49 <shachaf> > let test test = test == 0 in (test 0, test 1)
14:10:50 <lambdabot>   (True,False)
14:10:51 <Pseudonym> testily
14:11:07 <monochrom> so, the moral of the story: "data C a => ..." does not save you any work. you are better off not using it.
14:11:12 <shachaf> plediii: Well, think of how it's implemented.
14:11:23 <shachaf> plediii: The caller still needs to pass the dictionary in.
14:11:25 <Pseudonym> shachaf: I love it!
14:11:47 <plediii> shachaf: what dictionary?
14:12:08 <shachaf> plediii: The thing the type class gets translated into.
14:12:20 <shachaf> plediii: A good exercise in understand type classes is seeing how they're (often) implemented.
14:12:21 <Pseudonym> Just to prove that you can use "test" in this way, here's some real code I wrote:
14:12:27 <Pseudonym> is Prime 21 == False
14:12:31 <geekosaur> type clases look a lot like parameters,because they secretly are
14:12:33 <monochrom> the only purpose of "data C a => Datum a = DCtor a" is to constrain the type of DCtor to "DCtor :: C a => a -> Datum a". that is all.
14:12:33 <Pseudonym> is Fibonacci 8 == True
14:12:58 <shachaf> plediii: What you're trying to do here is more along the lines of an existential type, or a GADT constraint.
14:13:00 <geekosaur> the parameter is a dictionary that lets the function find the right implementation of class functions for a type
14:13:04 <Pseudonym> class TestableProperty property a | property -> a where { is :: property -> a -> Bool }
14:13:20 <shachaf> plediii: This is possible but not really possible in Haskell 98, and you should understand why this approach isn't working before you use it.
14:13:33 <monochrom> I am also not convinced that Datum is meant to be existential.
14:13:38 <plediii> shachaf: I would like to understand why it's not working
14:13:47 <monochrom> I am thoroughly convined that the author just wants to shorten type sigs.
14:14:45 <shachaf> plediii: OK. I think the simplest way to understand that might be to see how type classes are commonly implemented.
14:15:12 <Jafet> The author would probably love to have constraint kinds
14:16:30 <plediii> monochrom: that is what I want to do. But I also want to understand why it didn't work
14:16:36 <shachaf> A New Kind of Kind.
14:16:54 <plediii> shachaf: is there some instructive implementation I could look at?
14:17:09 <monochrom> the short answer is that the Haskell Report does not promise what you think
14:17:34 <shachaf> plediii: Hmm, I'm not sure.
14:17:36 <plediii> Well, I'll put the Haskell Report on my reading list
14:17:56 <shachaf> plediii: I think several of SPJ's introductory talks/slides/papers give an overview of this.
14:18:04 <Pseudonym> plediii: You can skip the monomorphism restriction section on a first reading.
14:18:47 <Saizan> but the report is the best place to read about the MR
14:18:52 * shachaf has yet to read the Haskell Report.
14:19:00 <Saizan> i wouldn't pass the chance
14:19:01 <shachaf> Except for bits of it in order to out-pedant others.
14:19:03 <Pseudonym> Saizan: Have you read the wiki page?
14:19:08 <shachaf> (Or occasionally to understand it.)
14:19:25 <monochrom> see Section 4.2.1. it says what "data C a =>" buys you. and then it adds "The context in the data declaration has no other effect whatsoever." So it positively denies your wish.
14:19:26 <Pseudonym> http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:19:39 <Saizan> Pseudonym: yeah, it was quite confusing with all the talk about CAFs and all, but it might have changed in these years
14:19:58 <Pseudonym> monochrom: Hasn't the behaviour changed with GADTs?
14:20:14 <monochrom> is GADTs in the Haskell Report?
14:20:22 <Pseudonym> Obviously not.
14:20:31 <Pseudonym> Might be in prime, though.
14:20:32 <monochrom> well I'm just talking about the Haskell Report
14:20:36 <Pseudonym> Sure.
14:20:36 <Jafet> So pedant hour begins
14:20:42 <copumpkin> lol
14:20:48 <Axman6> not again :(
14:20:52 <copumpkin> Jafet: just for a change
14:20:54 <Pseudonym> Jafet: You left off a full stop.
14:20:55 <Saizan> Pseudonym: data C a => Foo a = Foo a is still the same, but data Foo a = C a => Foo a does do the intuitive thing
14:20:58 <dolio> The behavior of "data C a => ..." hasn't changed with GADTs.
14:21:02 <monochrom> GADTs change all behaviours, sure. not sure what's the relevance
14:21:26 <Pseudonym> dolio: I recall reading somewhere that...
14:21:40 <Saizan> or data Foo a :: * where Foo :: C a => a -> Foo a
14:21:42 <Pseudonym> data C a => Foo a = Foo a
14:21:47 <Pseudonym> is a constraint on the constructor Foo.
14:21:50 <Pseudonym> But:
14:21:50 <plediii> shachaf: SPJ's slides are "a taste of Haskell?"
14:22:05 <Pseudonym> data C a => Foo a where { Foo :: a -> Foo a }
14:22:16 <Pseudonym> actually puts the dictionary in the data structure.
14:22:31 <Saizan> nope, you've to put the C a => in the type of the constructor
14:22:35 <Pseudonym> And yes, this is vague.
14:22:45 <shachaf> plediii: Those might well cover it.
14:22:49 <shachaf> He has a lot of slides, though.
14:22:50 <geekosaur> as I understand it data C a => ... works in ADTs, not sure it's supported in GADTs; GADTs add data ... where foo :: C a => ...
14:22:53 <geekosaur> which works as expected
14:23:02 <shachaf> I'm pretty sure the SYB slides also cover it.
14:23:06 <plediii> shachaf: I didn't realize until I opened it whose initials those were :/
14:24:06 <dolio> Yes, what geekosaur said.
14:25:24 <geekosaur> I should have put the first "works" in scare quotes, since it "works" in ways that are rarely useful
14:25:29 <dolio> Unless they changed it in 7.4.
14:27:22 <plediii> monochrom: ah I understand what you meant about "data C a =>" only constrainting the DCtor.  Is there some legal way to construct a Datum with an `a' which isn't of class C?
14:29:32 <monochrom> no
14:32:43 <exFalso> @lambdabot (\f a -> lift . f =<< liftM return a)
14:32:44 <lambdabot> Unknown command, try @list
14:32:58 <exFalso> uhmm how does one invoke lambdabot?
14:33:06 <shachaf> exFalso: @nixon
14:33:33 <Eduard_Munteanu> @help
14:33:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:33:34 <exFalso> @nixon (\f a -> lift . f =<< liftM return a)
14:33:34 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
14:33:37 <Eduard_Munteanu> @list
14:33:37 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:33:45 <Eduard_Munteanu> Hah.
14:33:56 <lukish> How can I apply 2 filters in one? I have `filter x1 . filter x2 $ y' but I wanna filter2 (x1 x2) $ y
14:33:59 <lukish> ?
14:34:03 <Eduard_Munteanu> exFalso: what do you want to do with that?
14:34:08 <shachaf> We should get rid of @nixon or something.
14:34:13 <Eduard_Munteanu> Get a type? Convert to pointfree?
14:34:14 <shachaf> lukish: What's wrong with filter x1 . filter x2?
14:34:16 <mm_freak> related question:  is there any difference between "data C a => X a = X a" and "data X :: * -> * where X :: (C a) => a -> X a"?
14:34:24 <Eduard_Munteanu> Erm, from in this case :)
14:34:24 <exFalso> oh i thought lambdabot was the one that pointfrees functions
14:34:26 <shachaf> lukish: Do you know what "(x1 x2)" means?
14:34:34 <shachaf> exFalso: Oh, if you want to do *that*, use @pl
14:34:37 <monochrom> filter (\i -> x1 i && x2 i) or filter (\i -> x2 i && x1 i) depending on which one you like
14:34:38 <shachaf> You can also /msg lambdabot
14:34:44 <exFalso> thanks:)
14:34:47 <shachaf> And in particular /msg lambdabot @help and /msg lambdabot @list
14:34:48 <exFalso> (\@pl f a -> lift . f =<< liftM return a)
14:34:55 <monochrom> actually I'm inclined to (\i -> x2 i && x1 i)
14:34:56 <exFalso> @pl (\f a -> lift . f =<< liftM return a)
14:34:57 <lambdabot> (. fmap return) . (=<<) . (lift .)
14:34:59 <exFalso> arrgh
14:35:07 <exFalso> hmm fair enough
14:35:34 <Eduard_Munteanu> There's also @unpl for the reverse conversion.
14:35:44 <lukish> shachaf: there are a lot of that x1 x2 and I want to apply them all
14:36:03 <Eduard_Munteanu> (they're not really inverses, don't expect to get the same thing back)
14:36:11 <shachaf> lukish: Do you know what putting two things in front of each other does in Haskell?
14:36:14 <shachaf> E.g. "f x"
14:36:20 <exFalso> Eduard_Munteanu: thanks!
14:36:21 <Eduard_Munteanu> @. unpl pl (\f a -> lift . f =<< liftM return a)
14:36:21 <lambdabot> (\ e n -> (fmap return n) >>= \ q -> lift (e q))
14:36:36 <monochrom> shachaf, you can just answer filter (\i -> x2 i && x1 i)
14:36:48 <lukish> shachaf: yes
14:37:02 <lukish> Okay [x1,x2]
14:37:04 <lukish> Anyway
14:37:51 <shachaf> monochrom: I know, but (a) you've already done that, and (b) I've seen a bunch of lukish's questions before, and it seems to me that a more general answer is needed.
14:38:04 <gwern>  iterate
14:38:07 <shachaf> I wasn't trying to be rude, although in retrospect I see why it might have come across as such.
14:38:09 <gwern> @src iterate
14:38:10 <lambdabot> iterate f x =  x : iterate f (f x)
14:38:29 <monochrom> no, I am not saying rude
14:38:51 <monochrom> I am just saying, why do people not see what I write, and see what I don't write
14:39:07 <shachaf> I never said you were saying rude. :-)
14:40:17 <monochrom> it's just poor focus. whereas the "filter x1 . filter x2" part is pretty clear, the focus was put on the "x1 x2" part
14:40:58 <monochrom> I think people actively avoid the straight resolution and go for the round-about long shot.
14:41:06 <shachaf> I suppose that's true to a degree.
14:41:25 <shachaf> monochrom: I think my goal is to show people what's unclear about their questions, so they ask better questions next time.
14:41:30 <shachaf> Good questions make me happy.
14:41:40 <geekosaur> give a fish/teach to fih...
14:41:52 <geekosaur> (so much for typing)
14:41:59 <srhb> That's a good approach, I think. Especially since it can be very, very difficult both to formulate questions and understand the (real) answers when you're not as experienced.
14:42:43 <srhb> Often when starting out there's just the vague idea of what you want to do and an even more vague intuition about how to achieve it.
14:43:31 <c_wraith> :t (.) `on` filter $ ?x1 ?x2
14:43:33 <lambdabot>     Precedence parsing error
14:43:33 <lambdabot>         cannot mix `on' [infixl 0] and `$' [infixr 0] in the same infix expression
14:43:41 <gwern> @hoogle iterate
14:43:42 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
14:43:42 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
14:43:42 <lambdabot> Data.ByteString.Lazy.Char8 iterate :: (Char -> Char) -> Char -> ByteString
14:43:45 <c_wraith> :t ((.) `on` filter) ?x1 ?x2
14:43:45 <lambdabot> forall a. (?x1::a -> Bool, ?x2::a -> Bool) => [a] -> [a]
14:44:13 <monochrom> "How can I apply 2 filters in one? I have `filter x1 . filter x2 $ y' but" is clearly not vague. the rest is a red herring. I am a fan of clear questions too. to improve that question, I say delete the rest, not add more.
14:44:14 <c_wraith> huh.  on is infixl 0?  streange
14:44:17 <parcs`> :t liftM2 (>>) (liftM2 (>>) guard guard) return
14:44:18 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m Bool
14:44:24 <c_wraith> also, strange
14:44:29 <shachaf> monochrom: Makes sense.
14:47:53 <monochrom> "I get type error 'Char doesn't match Bool', what's wrong?" (no code shown, or even wrong code show) is the vague one, and all you people who just screamed "ask better questions" are precisely the ones who do not demand a better question in that case.
14:48:16 <shachaf> monochrom: I do demand a better question in that case!
14:48:24 <shachaf> In fact, altely I've been demanding a better question almost every single time.
14:48:29 <shachaf> I've been overdoing it, probably.
14:48:53 <monochrom> I'll over-do with you.
14:49:16 <c_wraith> So if I wanted to model a retroencabulator in haskell, should I use typeclasses?
14:49:34 <monochrom> haha
14:49:36 <shachaf> c_wraith: No, valueclasses.
14:49:46 <monochrom> use unsafePerformIO
14:49:46 <shachaf> Retroencabulators are values, after all.
14:49:53 <shachaf> unsafeCoerce
14:50:01 <shachaf> And monads.
14:50:06 <c_wraith> the scary thing about the retroencabulator video is that it's really *clever* technobabble.  It's almost coherent.
14:50:37 <c_wraith> like the bit about "instead of generating power from the relative motion of conductors and fields"...  Which is actually how must electrical generators work.
14:50:44 <monochrom> we need more technobabble haskell videos
14:50:55 <c_wraith> err, *most
14:51:21 <monochrom> "Haskell is about value-added programming" :)
14:51:42 <c_wraith> have you seen the retroencabulator video?  You're not near the level of semi-coherence needed.
14:51:50 <Saizan> oh shit, do we have to pay taxes on that?
14:51:52 <monochrom> no, I haven't
14:52:22 <monochrom> I haven't reached that level because I haven't brought up monads yet.
14:53:03 <c_wraith> oh, I was thinking of the turbo encabulator, not the retro encabulator
14:53:04 <c_wraith> http://www.youtube.com/watch?v=rLDgQg6bq7o
14:53:29 <gregATio> flymake is complaining about an import of Data.Monoid?! any ideas anyone?
14:53:51 <c_wraith> gregATio: probably you're not using anything from it that isn't also in Prelude
14:53:55 <gwern> gregATio: Monoids are so weak. use Monads like a Manad
14:55:09 <gregATio> aha thanks
14:55:40 <c_wraith> In general, if the compiler is complaining about an import, it's a warning that you're importing something you aren't using.
14:56:07 <c_wraith> Well.  If it's a warning, that's the cause.  Obviously, if you're trying to import something that doesn't exist, that's an error
14:57:28 <gregATio> its Data.Monoid it does exist!
14:57:47 <Saizan> this would be a case for asking for a better question
14:57:53 <Saizan> "what is the error message?"
14:58:17 <gregATio> i cant see an error just red highlights
14:58:53 <c_wraith> I'm pretty sure flymake gives you an error buffer
14:59:26 <gregATio> ah yes i had to C-c d to see the error
14:59:36 <gregATio> it was actually complaining about a missing main function
14:59:40 <gregATio> which is pretty odd
15:00:03 <c_wraith> I've seen that error before
15:00:11 <c_wraith> it usually happens when you capitalize something at the top level
15:00:15 <c_wraith> like Module or Import
15:00:22 <c_wraith> those should be lowercase only!
15:00:57 <monochrom> mm_freak: there is a difference. "seafood (X a) = ..." can be given type sig "seafood :: X a -> ..." without constraint "C a =>"
15:01:05 <gregATio> the function main is not defined in module Main
15:01:28 <gregATio> is it because i didnt specify a module?
15:02:21 <gregATio> actually it was just hightlighting the first line
15:02:29 <gregATio> regardless of what is there
15:02:56 <monochrom> normally the compiler expects main to be in module Main or unnamed module
15:05:54 <gregATio> filling in bits of knowledge here and there
15:09:55 <srhb> I'm trying to build an interpreter for simple arithmetic expressions with only plus, minus and integers. I have an interpreter and a lexer so far, but can't figure out how to go about a hand-made parser handling precedence. Am I missing some technique, or am I just feeling the lack of a parser generator?
15:10:20 <shachaf> srhb: Do you need to handle precedence with only +, -, and integer?
15:10:27 <srhb> No, I lied
15:10:32 <srhb> Addition and multiplication
15:10:34 <srhb> Not plus and minus.
15:10:37 <c_wraith> ah.
15:10:41 <c_wraith> there's a standard trick
15:10:49 <c_wraith> for how you define your grammar
15:10:56 <c_wraith> that makes precedence implicit in the grammar
15:11:00 <srhb> Oh?
15:12:06 <c_wraith> expr := term | (term + term)  ;  term := atom | (atom * atom)
15:12:20 <monochrom> additive = multiplicative `sepBy` plus_sign; multiplicative = atom `sepBy` times_sign; atom = one_number <|> parenthesized additive
15:12:50 <monochrom> of course, "additive" really means "possibly additive", etc.
15:12:57 <c_wraith> basically, the tighter you want something to bind, the deeper you should put it in the recursion
15:13:21 <srhb> What is <|> ? I don't seem to have that in prelude
15:13:30 <shachaf> @hoogle <|>
15:13:30 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
15:13:30 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
15:13:30 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
15:13:37 <srhb> c_wraith: I think I understand that. I'll try to have a go.
15:13:55 <monochrom> <|> is parsec's notation for |
15:13:56 <srhb> So that does use Parsec.
15:14:06 <c_wraith> yes, that's parsec (or similar) code
15:15:38 <srhb> I was trying to avoid using anything but Data types, my lexeme list and pattern matching, but I guess that's not practically feasible.
15:19:39 <monochrom> you can write your own recursive-descent parser and not use parsec
15:20:43 <srhb> Yeah, I'm searching on the topic now. :)
15:30:30 <clsmith> hey all. i'm hoping to learn some category theory, specifically so i can work out what adjunctions are all about. :p any recommendations of books to read?
15:31:13 <clsmith> (i'm not a mathematician or anything, i just blag my way through type theory)
15:32:25 <clsmith> oh, and i like diagrams! :D <.<;
15:34:23 <PatrickRobotham> clsmith: Hey, I'm hoping to  learn category theory too!
15:34:36 <PatrickRobotham> clsmith: I'm currently reading Conceptual Mathematics: A First Introduction to Categories.
15:35:02 <djahandarie> clsmith, it's not a guide to category theory, but a fun paper is "Physics, Topology, Logic and Computation: A Rosetta Stone"
15:35:37 <djahandarie> I highly recommend ncatlab as the category theory wiki.
15:35:51 <djahandarie> Though it's super advanced in some areas, it does tend to give some very nice closed definitions
15:38:20 <clsmith> PatrickRobotham: oh, that book looks good (at a glance). hmmm
15:38:46 <clsmith> djahandarie: i remember reading a rosetta stone, but my last pass through it i didn't quite get it. :p i might have another go
15:39:02 <PatrickRobotham> clsmith: Do you know what a commutative diagram is?
15:39:11 <clsmith> PatrickRobotham: i think so.
15:39:22 <clsmith> yes
15:44:07 <PatrickRobotham> Cool.
15:44:37 * hackagebot pretty 1.1.1.0 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.1.1.0 (DavidTerei)
15:50:49 <drull95> yee haw! i making a bot to play online games. so far i can open a window, take a screen shot and then display it using cv-combinators
15:50:59 <drull95> now on to some actual computer vision
15:51:26 <drull95> or maybe just image processing, i'm still working on that part
16:40:54 <clsmith> currently my favourite explanation of category theory: http://www.youtube.com/watch?v=4PoiPN7KDRM
16:41:27 <clsmith> (i'm not quite sure what is going on there, but it appears to be some form of interpretive dance)
16:42:45 <djahandarie> clsmith, was that a description of the video, or a description of category theory?
16:43:20 <acowley> Simple-minded OpenCL dot product on the CPU can beat hmatrix's dot product! Hooray!
16:43:33 <clsmith> hahaha. as far as i can tell, it may as well be a description of both
16:44:02 <hughfdjackson> clsmith: o.o trippy
16:44:23 <acowley> (assuming you want to compute dot products of >10million element vectors)
16:44:25 <ben_m> Makes perfect sense.
16:45:51 <acowley> Does anyone have an example of using the new criterion chart generation stuff?
16:49:54 <byorgey> acowley: who would ever want to compute dot products of vectors smaller than that?
16:50:39 <byorgey> that would be known as "low-dimensional linear algebra", where "low-dimensional" is said in as condescending a tone as possible
16:50:40 <acowley> byorgey: unambitious people with little imagination
16:50:45 <byorgey> exactly
16:50:45 <acowley> haha
16:50:48 <acowley> yes
16:51:43 <Pseudonym> Condescention is just the category dual of descention.
16:51:53 <Pseudonym> ndescention
16:52:32 <djahandarie> $n$descension
16:53:02 <shachaf> djahandarie: Is that TeX-style italicizing?
16:53:13 <djahandarie> 'tis.
16:53:33 <shachaf> That's not how you're supposed to italicise things, man.
16:53:50 <mkscrg> anybody used Cloud Haskell yet? (the remote package on hackage)
16:54:00 <djahandarie> Everyone has LaTeX built into their IRC client, don't they?
16:54:04 <byorgey> $n$-descension
16:54:22 <hpc> @remember byorgey that would be known as "low-dimensional linear algebra", where "low-dimensional" is said in as condescending a tone as possible
16:54:22 <lambdabot> Done.
16:54:38 <byorgey> I think I understand 2-descension, but the definition of 3-descension involves high-dimensional associahedra diagrams
16:54:45 <djahandarie> Haha
16:58:49 <acowley> Oh, well that was easy. For the edification of all: you just give your criterion'ed executable a "-o report.html" command line argument.
16:59:38 * hackagebot couchdb-conduit 0.1.0.0 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.1.0.0 (AlexanderDorofeev)
17:01:59 <copumpkin> and so it begins
17:02:25 <copumpkin> combinatorial explosion of iteratee-like libraries and the various consumers/producers that could be hooked to them
17:03:18 <kfish> yay
17:05:25 <byorgey> iteraspleesion!
17:05:34 <BMeph> copumpkin: So, what did you think of Bob Atkey's article (assuming you gave it any thought at all...)? :)
17:05:44 <copumpkin> which was that?
17:06:47 <BMeph> I'll look it up, and hopefully, someone else will throw the URL up, five seconds before I do... ;þ
17:06:49 <dolio> Reasoning about stream processing with effects.
17:07:31 <BMeph> "As it is Written, So Let it Be Done." ;þ
17:07:33 <MarcWeber> Which is current state of tagging template haskell generated code?
17:07:50 <acowley> that article has been sitting at the top of my reading list for a while now. Is it as awesome as the title and intro lead me to believe?
17:08:06 <MarcWeber> Does anybody know details about the hothasktags package and how it does it better then the old hasktags application?
17:08:32 <shachaf> rwbarton: About super mario brothers?
17:09:08 <BMeph> MarcWeber: Yes. Not me, mind you, but I'm sure there is an "anybody" "out there" that does. ;)
17:10:21 <BMeph> copumpkin: The ref: http://personal.cis.strath.ac.uk/~raa/posts/2012-01-06-streams.html
17:12:25 <dolio> byorgey: Shouldn't you be recording babies playing avant-garde piano compositions?
17:13:03 <acowley> my benchmark is swamped by generating random vectors, but my CPU isn't working very hard during said generation.
17:14:23 * gwern feels a little disgruntled at http://pastebin.com/pKDy3Spp - it's already that long, and I haven't even implemented any of the hard parts of the hypertime model
17:14:26 <mauke> The paste pKDy3Spp has been copied to http://hpaste.org/56309
17:16:33 <rwbarton> shachaf: Hmm? I wrote the patch for that blog post, yeah.
17:17:01 <shachaf> rwbarton: What post?
17:17:11 <shachaf> kmc said I should ask you about super mario brothers.
17:17:16 <rwbarton> oh.
17:17:32 <shachaf> Oh, you did Ksplice-style patching of a Super Mario Bros. bug?
17:17:41 <rwbarton> hang on
17:17:56 * shachaf hunts on oracle.com
17:18:30 <shachaf> Looks like the post isn't there.
17:18:36 <rwbarton> mhm, wonder what happened to it
17:18:47 <rwbarton> Maybe some lawyers ate it?
17:19:01 <shachaf> rwbarton: Is *that* why that sort of thing happens?
17:19:09 <shachaf> It's lawyer food?
17:19:25 <shachaf> Lawyers aren't evil, they just depend on certain things to survive.
17:19:33 <irene-knapp> hm.
17:19:34 <shachaf> It makes sense.
17:19:37 <irene-knapp> it does.
17:21:06 <shachaf> rwbarton: Even a YouTube video was removed.
17:21:09 <shachaf> Thanks, Oracle.
17:21:21 <rwbarton> shachaf: http://web.archive.org/web/20110430131107/http://blog.ksplice.com/2011/04/smb-1985-0001-advisory/
17:22:33 <rwbarton> the videos are down? sad
17:24:32 <copumpkin> BMeph: oh, I briefly looked at that but haven't had time to let it soak in yet
17:25:36 * BMeph tells gwern that he prefers the word 'finitude' to 'finite-ness'.
17:25:56 <rwbarton> shachaf: Wait, no they're not.
17:26:23 <rwbarton> shachaf: http://www.youtube.com/user/lakitucloudsec/videos
17:29:58 <irene-knapp> "finitude" sounds like what the Street Sharks have
17:30:09 <irene-knapp> (them being a late-80s flop)
17:30:19 * BMeph wonders if Nelson's ZigZag(TM) project is still alive somewhere...
17:36:51 <cl1> foo :: a -> Either a
17:36:54 <cl1> foo = Right
17:37:01 <cl1> why can i not do that? ^^^
17:37:24 <copumpkin> cause Either takes two parameters
17:37:49 <ion> > let foo :: a -> Either a; foo = Right
17:37:50 <lambdabot>   not an expression: `let foo :: a -> Either a; foo = Right'
17:37:52 <ion> > let foo :: a -> Either a; foo = Right in foo
17:37:53 <lambdabot>   `Data.Either.Either a' is not applied to enough type arguments
17:37:53 <lambdabot>  Expected ki...
17:38:03 <cl1> well why can't i define a function in terms of a type constructor?
17:38:24 * cl1 realizes his type signature was wrong, he has only had 4 hours of sleep
17:41:51 <djahandarie> > let foo :: a -> Either x a; foo = Right in foo 3
17:41:52 <lambdabot>   Right 3
17:42:02 <djahandarie> > let foo :: a -> Maube a; foo = Just in foo 3
17:42:03 <lambdabot>   Not in scope: type constructor or class `Maube'
17:42:08 <djahandarie> > let foo :: a -> Maybe a; foo = Just in foo 3
17:42:09 <lambdabot>   Just 3
17:42:33 <ion> Maybe, maube, mauke
17:42:37 <shachaf> Thinking of Maube you forget everything else.
17:42:47 <djahandarie> Exactly what I was thinking, ion.
17:42:50 <acowley> Either always makes me want a type with a Wrong data constructor
17:42:52 <cl1> lol
17:43:07 <ion> acowley: Well, the semantics of Left are often like that. :-)
17:43:15 <acowley> Good point!
17:43:38 <cl1> > let foo = Right in foo 3
17:43:39 <lambdabot>   Right 3
17:43:48 <djahandarie> @let foo = Right
17:43:50 <lambdabot>  Defined.
17:43:53 <djahandarie> :t foo
17:43:54 <lambdabot> forall b a. b -> Either a b
17:43:56 <cl1> bah, ghci wouldn't interpret that when i had it in a where clause earlier today
17:44:19 <cl1> it was on a different computer, so i don't have the full context to show
17:44:37 <acowley> I will now use data Possibly a b = Wrong a | LessWrong b and type CouldBe a = Maube (Possibly String a)
17:44:48 <djahandarie> Maube strikes again.
17:45:15 <djahandarie> Maube that was intentional though.
17:45:16 <acowley> I choose Maube because I 3-descend the usage of Maybe
17:45:22 <ion> Someone should release acme-maube with “type Maube = Maybe”.
17:45:23 <shachaf> Did people here hear elliott's exciting proposal for MonadZero yesterday?
17:45:25 <cl1> > \x -> let Error = Left in let Value = Right in if x then Error "y u no work?!?" else Value 42
17:45:26 <lambdabot>   Not in scope: data constructor `Error'Not in scope: data constructor `Value...
17:45:33 * cmccann suggests Sinister and Dexter instead of Left and Right
17:46:01 <ion> cl1: You can’t define data constructores like that.
17:46:13 <Peaker> shachaf: nope, what was it?
17:46:14 <cl1> ion, why not?
17:46:16 <Peaker> shachaf: where was it?
17:46:34 <jasonkuhrt> I am currently reading http://learnyouahaskell.com and am confused by the following paragraph:
17:46:46 <elliott> shachaf forced me into here and I'm not proud of him.
17:46:49 <cl1> let Error :: -> Either _ a; Error = Left in Error "wtf?
17:46:52 <cl1> let Error :: -> Either _ a; Error = Left in Error "wtf?"
17:46:54 <jasonkuhrt> While there are singleton lists, there's no such thing as a singleton tuple. It doesn't really make much sense when you think about it. A singleton tuple would just be the value it contains and as such would have no benefit to us.
17:46:56 <cmccann> also, I occasionally want an "either or both" type, for which I suggest "data AndOr a b = This a | That b | These a b"
17:46:59 <cl1> > let Error :: -> Either _ a; Error = Left in Error "wtf?"
17:46:59 <shachaf> Peaker: It was in the elliott channel. All elliott, all the time.
17:47:00 <lambdabot>   <no location info>: parse error on input `->'
17:47:08 <acowley> how about data Moser a b = Brian a | Dexter b
17:47:10 <jasonkuhrt> can anyone explain that a little better?
17:47:19 <cl1> > let Error :: Either _ a; Error = Left in Error "wtf?"
17:47:20 <lambdabot>   <no location info>: Invalid type signature
17:47:32 <ion> cl1: The point of data constructors is that they’re not only values but they can be used in pattern matching as well. If i define, say, Foo = (+1), what do you suppose the semantics of the pattern would be in “f (Foo x) = x”?
17:47:44 <djahandarie> jasonkuhrt, I think he's just trying to say there would be no point in having a unary tuple.
17:47:50 <elliott> cmccann: What does that give you over (Maybe a, Maybe b)? I guess it's a bit easy to map over.
17:48:02 <djahandarie> jasonkuhrt, as it'd just be the 'Identity' data type.
17:48:06 <cmccann> elliott: it excludes (Nothing, Nothing) for one thing
17:48:13 <Peaker> shachaf: where's conal's release of TMap?
17:48:22 <djahandarie> jasonkuhrt, namely, data Identity a = Identity a
17:48:26 <jasonkuhrt> djahandarie: because every tuple is a singleton?
17:48:29 <elliott> cmccann: Oh, right.
17:48:34 <shachaf> @hackage total-map
17:48:34 <lambdabot> http://hackage.haskell.org/package/total-map
17:48:38 <ion> cl1: The names of non-data constructor values need to begin with something else than a capital letter.
17:48:48 <cl1> ion, i see what you mean for pattern matching
17:48:57 <clsmith> is there a way to, given a do block, translate it into a point-free expression? (and what about arrow do blocks?)
17:48:57 <cl1> DOH
17:49:07 <cl1> so i could declare it lower case and all would be well
17:49:10 <cl1> ion, thanks
17:49:12 <djahandarie> jasonkuhrt, not sure what you mean by that. I believe he's just trying to say that (3) would have no more information than 3.
17:49:21 * cl1 should have figured that out
17:49:36 <Jafet> @undo do { x <- y; let z = x; case z of quux -> return 42; }
17:49:37 <lambdabot>  Parse error at "}" (column 54)
17:49:39 <djahandarie> Where (_) is my notation for a unary tuple.
17:49:43 <Jafet> @undo do { x <- y; let { z = x }; case z of quux -> return 42; }
17:49:43 <lambdabot> y >>= \ x -> let { z = x} in case z of { quux -> return 42}
17:49:43 <shachaf> cmccann: You want to hear elliott's crazy MonadZero proposal, right?
17:49:54 <elliott> STOP JUDGING ME.
17:49:56 <clsmith> oh neat.
17:50:01 <jasonkuhrt> djahandarie: right, and when he says singlton lists, what does that mean? i.e. a singleton list is what? this? `[]`
17:50:05 <Jafet> That just desugars the syntax.
17:50:11 <ion> What’s elliott’s crazy MonadZero proposal?
17:50:17 <cmccann> elliott: it's (a + b + a*b), I'm not sure how else you'd express that easily
17:50:20 <Jafet> Whether you can make it point-free depends on which combinators you have.
17:50:24 <elliott> ion: :(
17:50:26 <djahandarie> jasonkuhrt, a singleton list is a list with a single item.
17:50:28 <clsmith> that's what i was looking for, thanks :)
17:50:29 <djahandarie> jasonkuhrt, such as [3].
17:50:37 <elliott> I was hoping nobody would take shachaf's bait.
17:50:48 <cmccann> shachaf, I don't know, what kind of crazy are we talking here
17:50:49 <clsmith> i don't suppose it can also 'unproc'?
17:50:51 <jasonkuhrt> djahandarie: ah ok, of course
17:51:14 <jasonkuhrt> whereas (3) has no use, [3] might for a variety of reasons
17:51:31 <shachaf> cmccann: Well, you know how fail is ugly and all, because it exposes source location information in a non-IO context.
17:51:38 <elliott> shachaf: Nooo!
17:51:39 <elliott> I'll explain.
17:51:40 <shachaf> Why am I talking?
17:51:42 <elliott> You'll misrepresent me.
17:51:45 <djahandarie> jasonkuhrt, basically. It kind of has to do with how you define tuples vs. how you define lists.
17:51:52 <cmccann> shachaf, yes, that's clearly the worst part of fail, that it exposes source location
17:51:58 <elliott> cmccann: ion: You know how fail is hideous and needs to leave Monad?
17:52:03 <ion> elliott: Absolutely
17:52:19 <djahandarie> jasonkuhrt, each different length of a tuple is defined seperately. I.e., (_,_) has its own defintion, and (_,_,_) is another definition, etc., etc.
17:52:21 <jasonkuhrt> Thanks djahandarie, ya makes sense now. Mostly I just wasn't quite understanding how he was phrasing it, the concept is very simple, I just wasn't clear if there was something more to it
17:52:28 <elliott> cmccann: ion: But just using MonadZero would suck, because we'd lose the information that it's a pattern-match failure (as opposed to some other failure) in monads like IO, and source location information can be useful.
17:52:52 <jasonkuhrt> djahandarie: cheers!
17:52:53 <elliott> cmccann: ion: At the same time, source location information being "observable" is kind of ugly; you can change the semantics of code simply by adjusting whitespace in it.
17:52:57 <djahandarie> jasonkuhrt, yep, np.
17:53:22 <dolio> Why would you need IO to get source code information?
17:53:31 <elliott> cmccann: ion: So, we add a new method to MonadZero: class MonadZero m where { mzero :: m a; mfail :: b -> m a; mfail _ = mzero; mzero = mfail (error "mzero") }
17:53:35 <Peaker> shachaf: reviewing total-map I'm surprised toList of Set doesn't require the Ord constraint (makes sense, but I thought it was mindlessly on everything)
17:53:47 <elliott> cmccann: ion: And pattern match failures turn into mfail (error "pattern match failure at ...").
17:54:08 <jmcarthur> i'd rather have a separate MonadFail
17:54:09 <elliott> You can't observe it, and the interface is semantically identical to the old MonadZero, but it allows the error information to be propagated upwards.
17:54:30 <jmcarthur> i don't think i necessarily want fail to have the semantics of mzero in all cases
17:54:33 <elliott> dolio: Well, it means that you can create a program that produces a wildly different result just by removing one space of indentation.
17:54:39 <cmccann> yeah, I'd prefer a separate MonadFail in that case
17:54:54 <elliott> Even a separate MonadFail has that problem.
17:55:00 <Peaker> shachaf: beautiful that the entire module :browse shows 4 lines :)
17:55:02 * elliott isn't sure how seriously he likes this solution.
17:55:09 <jmcarthur> i also don't see how this proposal solves the problem at all though
17:55:10 <Peaker> (and is comparable in power to Data.Map)
17:55:14 <jmcarthur> of source location
17:55:33 <elliott> jmcarthur: It depends what you mean by the "problem of source location"; i.e. which problem/
17:55:38 <jmcarthur> the main reason i prefer a separate MonadFail is just to keep its semantics from being conflated with mzero
17:55:47 <dolio> I can create a program that has a 'wildly' different error message by changing 'error "hello"' to 'error "goodbye"'.
17:55:58 <elliott> dolio: Yes, but that's just error messages.
17:56:30 <elliott> dolio: case runError $ do { Just m <- Nothing } of Left s -> ...
17:56:49 <jmcarthur> elliott: the claim that leaking the source location into fail is a problem
17:57:05 <jmcarthur> i'm not convinced either way that it's actually a problem yet
17:57:13 <elliott> jmcarthur: Well, you can't distinguish (error "...") from any other _|_.
17:57:16 <cmccann> leaking the source location into fail is a problem only if there's a way to intercept such errors in pure code
17:57:16 <dolio> case runError $ do { Left "whatever" } of Left s -> ...
17:57:17 <elliott> Only in the sin-bin.
17:57:29 <elliott> And the sin-bin can do all sorts of things; it could just read your own code, after all.
17:57:30 <dolio> It's a static desugaring.
17:57:34 <ion> I wouldn’t mind if there was even more statically available information that could be introspected.
17:57:40 <elliott> dolio: I don't see your point. I'm saying that:
17:57:41 <jmcarthur> i was going to say what dolio just said
17:57:41 <elliott> dolio: case runError $ do { Just m <- Nothing } of Left s -> ...
17:57:44 <elliott> dolio: case runError $ do {Just m <- Nothing} of Left s -> ...
17:57:48 <elliott> shouldn't differ in result.
17:57:52 <nexion> hey guys.. I'm wondering why I'm getting the warning posted at http://hpaste.org/56310 since I've specified "forall", yet it says it's defaulting to Integer
17:58:00 <elliott> It means that automated source-code formatting can change behaviour.
17:58:15 <elliott> I mean, it's probably not a very big problem, but it *is* kind of awful.
17:58:17 <rwbarton> (Either (IO String) a??)
17:58:42 <dolio> I don't believe it's a problem at all.
17:58:45 <nexion> I also have {-# LANGUAGE ExistentialQuantification #-} at the top
17:58:53 <elliott> rwbarton: I was using _|_ for it because the semantics of stuffing error messages into _|_ and recovering them safely later are well-covered :P
17:58:59 <jmcarthur> i don't think it's any worse than CPP
17:59:16 <mauke> nexion: what's the type of LTR.decimal?
17:59:35 <nexion> import qualified Data.Text.Lazy.Read as LTR
17:59:43 <elliott> dolio: Well, I don't think it's a big deal. Actually this originated as a joke and then I realised the current behaviour is kind of awful. I don't think it's something anyone cares about, though.
17:59:44 <mauke> nexion: what's the type of LTR.decimal?
17:59:49 <elliott> Blame shachaf for bringing it up. :p
18:00:00 <dolio> Okay.
18:00:20 <nexion> mauke, decimal :: Integral a => Reader a
18:00:40 <mauke> nexion: ok, so what do you think the type of parsedI is?
18:02:37 <nexion> I'm not sure.. I don't think it's one specific type, at least that was the intent
18:02:48 <mauke> impossible
18:02:57 <nexion> I'd like it to work for any bounded integral
18:02:59 <mauke> it needs to know the type to be able to call the right 'read'
18:03:22 <mauke> why bounded?
18:03:40 <mauke> there are no constraints on parsedI except Integral, so it defaults to Integer
18:05:36 <mauke> nexion: I think you want fromIntegralCheckBounds :: forall b . (Integral b, Bounded b) => Integer -> Maybe b
18:06:33 <nexion> so that it calls the appropriate read for Integer?
18:07:13 <mauke> yes
18:07:30 <mauke> I mean, it's already doing that but now we're explicit about it
18:07:58 <mauke> shorter version of the same problem: fromIntegral . read
18:08:03 <mauke> :t fromIntegral . read
18:08:04 <lambdabot> forall b. (Num b) => String -> b
18:08:20 <mauke> :t fromIntegral
18:08:21 <lambdabot> forall a b. (Integral a, Num b) => a -> b
18:08:39 <mauke> that 'Integral a' doesn't appear in the type of fromIntegral . read
18:09:51 <nexion> ah, I see
18:10:10 <monochrom> yeah, you have an intermediate value with an intermediate type that doesn't get exposed. would be fine if not for type class. type class absolutely wants external influence to help choose instance.
18:10:57 <monochrom> @type fromEnum . read
18:10:58 <lambdabot>     Ambiguous type variable `a' in the constraints:
18:10:58 <lambdabot>       `Enum a' arising from a use of `fromEnum' at <interactive>:1:0-7
18:10:58 <lambdabot>       `Read a' arising from a use of `read' at <interactive>:1:11-14
18:11:09 <monochrom> hehe
18:11:23 <monochrom> also:
18:11:41 <monochrom> @type toInteger . read
18:11:42 <lambdabot> String -> Integer
18:11:52 <monochrom> @type toInteger
18:11:53 <lambdabot> forall a. (Integral a) => a -> Integer
18:12:03 <monochrom> hrm, that may get defaulted too
18:14:40 <nexion> I'm also getting a similar warning for: randomRIO (0, 2 ^ 64)
18:14:46 <nexion> @type randomRIO
18:14:46 <lambdabot> forall a. (Random a) => (a, a) -> IO a
18:15:48 <nexion> what's the cleanest way to be explicit about the type here?
18:16:29 <byorgey> nexion: perhaps  randomRIO (0 :: Int, 2 ^ 64)
18:16:50 <mauke> > 2 ^ 64 :: Int
18:16:53 <lambdabot>   0
18:17:14 <elliott> nexion: randomIO (0, maxBound :: Int) is probably what you want.
18:17:22 <byorgey> heh, good point.  hopefully Int wasn't the type nexion is going for.
18:17:41 <elliott> At least I think randomIO is inclusive.
18:18:28 <Cale> Fixed @check
18:18:48 <mauke> @check True
18:18:49 <elliott> yay
18:18:50 <nexion> the maxBound :: Int one works, but that won't be 64-bit.. right?
18:18:56 <lambdabot>   "OK, passed 500 tests."
18:19:16 <mauke> nexion: randomRIO (0 :: Integer, 2 ^ 64 - 1)
18:19:20 <byorgey> nexion: the size of Int is architecture-dependent
18:19:21 <djahandarie> @check \x -> x /= 932145
18:19:24 <shachaf> @check is in the mail
18:19:24 <byorgey> nexion: what are you trying to do?
18:19:30 <lambdabot>   "OK, passed 500 tests."
18:19:35 <byorgey> > maxBound :: Int
18:19:36 <lambdabot>   Parse error at "in" (column 4)
18:19:41 <rwbarton> @check mate
18:19:42 <lambdabot>   9223372036854775807
18:19:48 <lambdabot>   Not in scope: `mate'
18:19:48 <byorgey> > 2^64 - 1 :: Int
18:19:54 <lambdabot>   -1
18:20:00 <djahandarie> Own'd
18:20:02 <elliott> @check (==)
18:20:03 <byorgey> > 2^63 - 1 :: Int
18:20:06 <lambdabot>   "OK, passed 500 tests."
18:20:12 <lambdabot>   9223372036854775807
18:20:19 <elliott> 500 tests on the search space of ()^2.
18:20:28 <elliott> Doesn't feel like enough.
18:20:29 <nexion> mauke, that still warns
18:20:34 <mauke> nexion: about what?
18:20:39 <shachaf> elliott: Don't worry, it's very exhaustive.
18:20:47 <shachaf> I can confirm that I feel exhausted right now.
18:20:50 <nexion>     Warning: Defaulting the following constraint(s) to type `Integer'
18:20:51 <nexion>                (Integral b0) arising from a use of `^'
18:20:51 <nexion>                              at Liberty/WebGateway/RandomString.hs:14:40
18:20:51 <nexion>                (Num b0) arising from the literal `64'
18:21:14 <mauke> haha, oh wow
18:21:18 <mauke> :t (^)
18:21:22 <byorgey> nexion: oh, that's just because the type of the exponent can be different than the type of the base + result
18:21:26 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
18:21:26 <byorgey> it's a pretty annoying warning
18:21:33 <byorgey> I'd say just ignore it
18:21:37 <mauke> 2 ^ (64 :: Int)
18:21:43 <byorgey> or do that
18:21:53 <nexion> ah
18:22:28 <nexion> victory :)
18:22:35 <nexion> ty
18:22:42 <Axman6> @check \x y -> x == (y :: Bool)
18:22:43 <lambdabot>   "Falsifiable, after 4 tests:\nTrue\nFalse\n"
18:22:55 <Axman6> took that long?
18:23:38 <cmccann> elliott, hey, wanna see something ridiculous?
18:23:59 <elliott> cmccann: I... think so?
18:24:15 <hpaste_> “C. McCann” pasted “cheating” at http://hpaste.org/56311
18:24:18 <cmccann> there
18:25:06 <elliott> cmccann: heh
18:25:07 <rwbarton> nice setup
18:25:16 <elliott> cmccann: Isn't Oops = Error String?
18:26:12 <Axman6> Chear*
18:26:13 <Axman6> t*
18:26:18 <elliott> Er, yes.
18:26:21 <elliott> But yes, this is why we should stuff all our error messages into _|_s.
18:27:33 <cmccann> yeah, I just defined a new type for the sake of being explicit about everything
18:27:55 <cmccann> anyway, note that this would allow a module to potentially distinguish local definitions from other functions, even if they're equivalent in every other way
18:29:10 <elliott> You could argue that changing the source location changes what your function actually means, but you could argue that every language pure in the same way.
18:29:32 <rwbarton> if I run my program at a different time, it is a different program?
18:29:54 <augur> @tell conal does your tfp stuff allow the composed widgets to expose their structure? you comment in the tfp video that hiding the internals of the system is something that really benefits the tfp approach over visual programming approaches but sometimes i imagine you'd want to see the guts here or there to insert things or remove things..
18:29:54 <lambdabot> Consider it noted.
18:30:27 <elliott> rwbarton: Specifically, the meanings of expressions depend on the time, and the state of the universe.
18:30:28 <cmccann> elliott, well, I'm not entirely certain this would allow anything that couldn't be done by other means
18:30:33 <elliott> I guess the latter kind of includes the former :P
18:31:11 <elliott> cmccann: Other means howso? I mean, it's clearly the desugaring of do leaking the information here.
18:31:35 <rwbarton> deriving Show leaks information too
18:31:42 <cmccann> elliott, in the sense of being able to do anything with that information
18:31:45 <rwbarton> I can't rename my identifiers
18:31:58 <elliott> cmccann: Ah.
18:32:06 <elliott> rwbarton: That's a bit more benign than changing whitespace.
18:32:27 <elliott> Especially since deriving is much closer to a boilerplate-removing preprocessor type thing than the desugaring of a core language construct.
18:32:54 <rwbarton> (I'm not really arguing any particular point here, just trying to think of related phenomena.)
18:33:06 <cmccann> elliott, at the moment I can't think of anything you could do with this that couldn't also be accomplished by, e.g. not exporting Cheat's constructors
18:34:15 <elliott> cmccann: Maybe the problem is I'm not sure what "this" is. You mean something that exports the same interface as Cheat, but defines two primitives cheat1 and cheat2 that can be distinguished from each other?
18:34:29 <elliott> cheat1 = Oops "a"; cheat2 = Oops "b" fit those criteria.
18:34:41 <cmccann> elliott, from each other and from any function that can be defined outside the module
18:34:57 <cmccann> possibly without anything outside the module being able to tell the difference
18:35:06 <elliott> cmccann: Well, um...
18:35:18 <elliott> cmccann: GHCi> cheat2
18:35:24 <elliott> Oops "Pattern match failure ..."
18:35:30 <elliott> GHCi> let cheat3 = fail "Pattern match failure ..." :: Oops ()
18:35:43 <elliott> cheating then thinks cheat3 is cheat2.
18:35:51 <cmccann> elliott, yeah, I'd need to be a bit more devious to prevent that
18:36:02 <elliott> You can hide the constructor, but there's nothing stopping you just enumerating every finite string.
18:37:49 <elliott> cmccann: I think if that's all you're trying to do, you can do it without fail quite easily: data Cheat a = Cheat a | Cheat1 | Cheat2, and just don't export Cheat1/Cheat2.
18:38:06 <cmccann> elliott, right, that's what I meant
18:38:18 <cmccann> I don't think this lets you do anything you can't do with something like that
18:38:32 <cmccann> other than obfuscating it a bit I guess
18:39:09 <cmccann> with higher-rank polymorphism and not exporting constructors I could probably be a lot more devious than the simple example, but even then I doubt it would do much
18:46:11 <jasonkuhrt> I am just starting to learn Haskell, are there any particular blogs that haskeller's read/publish at?
18:46:31 <elliott> http://planet.haskell.org/?
18:47:18 <DanBurton> ^ is an aggregation of various Haskell blogs
18:47:44 <byorgey> more accurately, it is an aggregation of blogs of various Haskell people
18:47:55 <byorgey> the posts are not always about Haskell though most are
18:48:01 <DanBurton> aye
18:48:01 <jasonkuhrt> ok great
18:48:04 * cmccann resists the urge to suggest http://okmij.org/ftp/ChangeLog.html
18:48:17 <jasonkuhrt> I guess from there I can reach specific single blogs if I wish
18:48:18 <jasonkuhrt> cool
18:50:04 <jasonkuhrt> cmccann: why resist, seems interesting?! =)
18:50:24 <cmccann> jasonkuhrt, but probably not helpful for a beginner
18:50:41 <mpunp> #emacs
18:51:36 <jasonkuhrt> cmccann: that's ok, I like jumping between difficulty levels, I'm not very linear in my learning process, and it helps to read way-advanced topics I don't get just to start sifting through it ambiently
18:51:54 <jasonkuhrt> cmccann: thanks
18:53:30 <Sgeo> http://neilmitchell.blogspot.com/2012/01/hiding-win32-windows.html
18:53:41 <Sgeo> This... something like this actually happened? What?
18:53:45 <cmccann> jasonkuhrt, ok. in that case, yeah, worth browsing that site, heh.
18:57:12 <Cody__> If you are feeling particularly helpful can you look at http://hpaste.org/56314? Questions are commented in there.  Thanks
18:59:53 <djahandarie> What if I'm only feeling somewhat helpful?
19:00:19 <elliott> djahandarie: Not good enough, sorry.
19:00:30 <djahandarie> Damn.
19:00:37 <cmccann> Cody__, in both cases "sort xs" is just applying sort to the "xs" bound in initial pattern match
19:00:50 <cmccann> in the first case, "x" is being added to the front of that list
19:01:17 <cmccann> the second case has nothing to do with the values used in the first
19:01:23 <cmccann> other than both referring to the same "xs"
19:01:25 <abaw> b
19:01:32 <mike-burns> I'm confused about line 4.
19:01:49 <cmccann> and yes, line 4 probably makes no sense
19:02:02 <Cody__> Oh I see. That clears up a lot. Thanks
19:02:39 <djahandarie> I'm late, but here is my annotation: http://hpaste.org/56314
19:02:40 <cmccann> also, note that in the else clause, the value "x" is being discarded and won't appear in the result at all
19:02:44 <djahandarie> And yeah, line 4 makes no sense
19:02:49 <Cody__> Line 4 made sense when I was wrong.
19:03:07 <cmccann> Cody__, I suspect that what you want here is something like "sort (x1:x2:xs)" as the initial binding
19:03:23 <cmccann> compare x1 and x2, then do other stuff after that
19:03:51 <Cody__> Yes. I thought calling the function again would "move up the list."
19:04:09 <cmccann> Cody__, there isn't really a list to "move up" in any sense
19:04:17 <Cody__> As in a ++ operator
19:04:32 <mike-burns> :t (++)
19:04:33 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:04:33 <cmccann> there's just the argument being pattern matched with (x:xs), and there's whatever value you return
19:04:47 * cmccann sighs
19:04:53 <cmccann> :t (Prelude.++)
19:04:54 <lambdabot> forall a. [a] -> [a] -> [a]
19:05:03 <mike-burns> WTF was that (++)?
19:05:08 <Cody__> ++ In java, not haskell. Like count++
19:05:21 <cmccann> mike-burns, an alias for mappend
19:05:37 <cmccann> lambdabot has some... peculiar ideas about certain things
19:05:39 <penelope> Well, Prelude.++ is kind of a relic...
19:05:48 <cmccann> :t map
19:05:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:05:52 <cmccann> heh
19:05:53 <cmccann> :t (.)
19:05:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:06:34 <elliott> mike-burns: caleskell
19:06:38 <cmccann> Cody__, anyway, no--nothing is being changed or updated here
19:06:50 <elliott> cmccann: Don't be ridiculous, the concept of "mapping" is clearly specific to lists.
19:06:53 <mike-burns> elliott: It's frustrating.
19:06:57 <Axman6> nothing is ever* changed or updated in Haskell
19:06:58 <penelope> ack
19:07:00 <elliott> Composition, on the other hand, is intimately related to Functors.
19:07:11 <Cody__> Alright, I'll make some revisions.
19:07:15 <elliott> As is flipping.
19:07:16 <elliott> :t flip
19:07:16 <penelope> map is a category thing
19:07:17 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
19:07:44 <cmccann> well, map and (.) are both special cases of fmap
19:07:46 <mike-burns> Hah.
19:08:06 <Axman6> :t flip . flip
19:08:07 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
19:08:17 * elliott would prefer to see (.) become (Control.Category..)
19:08:19 <mike-burns> This Caleskell makes it harder to talk with new devs.
19:08:34 <elliott> And map become fmap.
19:08:41 <penelope> no!
19:08:45 <cmccann> elliott, yes, that would make more sense
19:08:45 <Axman6> mike-burns: i've had this argument many times with him, and his view is that lambdabot is not here foir teaching
19:08:54 <elliott> Not that I'd object to (++) as mappend, either... but lambdabot should not have all these things there.
19:08:54 <penelope> fmap -> map
19:08:58 <elliott> base should.
19:09:04 <ion> *And* (.) being fmap isn’t really that useful either as long as Prelude doesn’t do that.
19:09:04 <cmccann> (++) as mappend makes sense
19:09:07 * BMeph would prefer that 'map' be renamed 'lmap'! >;)
19:09:09 <elliott> penelope: That's what I meant; rename fmap to map.
19:09:24 <penelope> :-)
19:09:33 <elliott> (.) as fmap is just ridiculous; it's confusing and awkward... same for flip, really.
19:09:42 <mike-burns> Well, he controls lambdabot , so he gets to decide.
19:09:43 <Axman6> elliott: indeed
19:09:46 <elliott> It would be nice if lambdabot had a @stdrun or something.
19:09:49 <JoeyA> :t flip
19:09:50 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
19:10:02 <mike-burns> It'd be nice if there were a separate bot for non-teaching.
19:10:07 <penelope> so
19:10:13 <penelope> map or lift?
19:10:47 * cmccann isn't sure where that flip definition is coming from though
19:11:09 <ion> (z -> a -> b) -> a -> z -> b
19:11:17 <elliott> :t \f x -> fmap ($x) f
19:11:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
19:11:23 <elliott> cmccann: That, presumably.
19:11:28 <cmccann> well, yeah
19:11:29 <elliott> \f x -> ($x) . f
19:11:38 <elliott> \f x y -> ($x) (f y) --> f y x
19:11:42 <elliott> I mean, that's obvious.
19:11:45 <cmccann> but I don't think that has a standard name, does it?
19:11:47 <elliott> But I have to wonder who came up with it.
19:12:01 <elliott> cmccann: I've never found one, but it only comes up rarely.
19:12:16 <elliott> fmap . ($) isn't a bad spelling.
19:12:29 <DanBurton> :t ($)
19:12:30 <lambdabot> forall a b. (a -> b) -> a -> b
19:12:51 <penelope> Funny how newspeak (double plus good) is bad for people, but good for haskell.
19:13:25 <DanBurton> penelope: huh?
19:13:31 <rwbarton> it's called the "cotensorial strength", for whatever that's worth (probably nothing).
19:13:38 <elliott> penelope: What?
19:13:51 <elliott> rwbarton: cotensorialStrength :: (Functor f) => f (a -> b) -> a -> f b
19:13:54 <cmccann> :t sequence fmap
19:13:55 <lambdabot>     Couldn't match expected type `[m a]'
19:13:55 <lambdabot>            against inferred type `(a1 -> b) -> f a1 -> f b'
19:13:55 <lambdabot>     In the first argument of `sequence', namely `fmap'
19:13:55 <elliott> Let's get it into Data.Functor!
19:14:17 <DanBurton> @google cotensorial strength
19:14:19 <lambdabot> http://www.springerlink.com/index/0741044045r67l2p.pdf
19:14:19 <lambdabot> Title: Abstract - SpringerLink
19:14:20 <penelope> Oh, I mean, simplicity + orthongonal = good in the haskell context
19:14:31 <cmccann> :t sequenceA fmap
19:14:32 <lambdabot> Not in scope: `sequenceA'
19:14:35 <cmccann> pf
19:14:41 <elliott> :t Data.Foldable.sequenceA fmap
19:14:42 <lambdabot> Not in scope: `Data.Foldable.sequenceA'
19:14:45 <elliott> :t F.sequenceA fmap
19:14:46 <lambdabot> Couldn't find qualified module.
19:14:49 <penelope> Creepy in the english context
19:14:50 <elliott> :t Foldable.sequenceA fmap
19:14:51 <lambdabot> Couldn't find qualified module.
19:14:56 * BMeph loathes SpringerLink! More than Jery Springer, even.
19:15:01 <elliott> The best thing about lambdabot is guessing its import names.
19:15:03 <Axman6> @hoogle sequenceA
19:15:07 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
19:15:07 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
19:15:14 <elliott> Oh.
19:15:18 <elliott> :t Data.Traversable.sequenceA fmap
19:15:20 <lambdabot> forall a b (f :: * -> *). (Functor f, Data.Traversable.Traversable ((->) (a -> b))) => f a -> (a -> b) -> f b
19:15:24 <DanBurton> :t T.sequenceA
19:15:25 <ddarius> BMeph: Why would you loathe Jerry Springer?
19:15:25 <lambdabot> Couldn't find qualified module.
19:15:43 <DanBurton> elliott: should be documented somewhere..........right?
19:15:53 <dolio> Don't insult our mayor!
19:16:10 <cmccann> anyway, Data.Traversable.sequence would be a better generalized flip if you ask me :P
19:16:13 <BMeph> ddarius: Uh, because he's creepy.
19:16:29 <elliott> DanBurton: Yes. In L.hs.
19:16:48 <penelope> What's the difference between Traversable and Foldable?
19:16:48 <elliott> lambdabot doesn't really do the whole "documentation" thing.
19:16:57 <elliott> penelope: Traversable is like Foldable but it can Traverse :-)
19:17:09 <BMeph> dolio: Former mayor, right? =8*O
19:17:15 <dolio> BMeph: Yeah.
19:17:16 <elliott> Foldable is just foldr; Traversable has mapM.
19:17:24 <ddarius> penelope: All Foldable is is a "toList" function.
19:17:27 <dolio> That's always a fun piece of trivia.
19:17:33 <cmccann> penelope, Foldable can flatten things into a list, Traversable can preserve the structure
19:17:48 <penelope> That seems wrong!
19:17:53 <DanBurton> @where L.hs
19:17:53 <lambdabot> I know nothing about l.hs.
19:17:58 <BMeph> dolio: Not to the hoosiers that think he's crepy. ;)
19:17:58 <DanBurton> lies!
19:18:10 <BMeph> *creepy
19:18:16 * elliott thinks Foldable should just be fold :: (Monoid m) => t m -> m, and require Functor.
19:18:24 <elliott> It looks slightly less like toList that way!
19:18:45 <penelope> So traversable <= foldable
19:18:49 <DanBurton> fold = unsafePerformIO -- what?
19:18:58 <BMeph> I like 'ListLike', myself. :)
19:19:17 <Axman6> > scanl (+) 1 [3,5..]
19:19:18 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
19:19:29 * DanBurton also likes ListLike
19:19:34 <Axman6> > scanl (+) 1 [3,5..] !! 10000000
19:19:35 <elliott> ListLike makes me sad.
19:19:40 <lambdabot>   mueval: Prelude.undefined
19:19:40 <lambdabot>  mueval: ExitFailure 1
19:19:40 <dolio> BMeph: Why? It's not like he was your mayor. You can make fun of people from Cincinnati.
19:19:42 <BMeph> For that matter, I like Greif's Thrists; I just wish I had a use for them.... :)
19:19:43 <elliott> It's just a bunch of functions that lists happen to have pretending to be an abstract concept.
19:19:46 <Axman6> > scanl (+) 1 [3,5..] !! 100000
19:19:48 <lambdabot>   10000200001
19:20:13 <Axman6> > map (^2) [1..] !! 100000
19:20:15 <lambdabot>   10000200001
19:20:30 <DanBurton> > (^0.5) 10000200001
19:20:31 <ddarius> BMeph: It should be called IEnumerable.
19:20:32 <lambdabot>   Ambiguous type variable `t' in the constraints:
19:20:32 <lambdabot>    `GHC.Real.Fractional t'
19:20:32 <lambdabot> ...
19:20:33 <BMeph> dolio: Yeah, but...who doesn't make fun of people from Cincinnati? ;)
19:20:44 <dolio> People from Kentucky.
19:20:47 <cmccann> haha
19:20:51 <DanBurton> > sqrt 10000200001
19:20:52 <lambdabot>   100001.0
19:20:52 <Axman6> > (**0.5) 10000200001
19:20:53 <lambdabot>   100001.0
19:21:28 <DanBurton> that is an amusing number
19:21:52 <ddarius> DanBurton: Multiplication is convolution plus carry.
19:22:18 <Axman6> convolution with what?
19:22:32 <ddarius> Axman6: Of the digits.
19:22:47 <penelope> from the perspectinve of addition
19:22:49 <Axman6> ah, yeah that makes a lot of sense with that example
19:24:46 <Cody__> > let findMin (x:xs) = [y | y<-xs, min y x == y] in findMin [3,2,5,3,0]
19:24:47 <lambdabot>   [2,3,0]
19:25:03 <rwbarton> > 1 / (1 - 0.001 - 0.001^2) :: CReal
19:25:04 <lambdabot>   1.0010020030050080130210340550891442333776
19:25:14 <bgamari> how does one bring make a Maybe into a MaybeT?
19:25:23 <penelope> lift
19:25:31 <Axman6> :t lift
19:25:32 <cmccann> penelope, no
19:25:33 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
19:25:36 <cmccann> that's the other way around
19:25:36 <BMeph> dolio: No, they're worse than the folks from Cleveland. :)
19:25:45 <ddarius> :t maybe mzero return
19:25:46 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
19:27:10 <penelope> well, if you want a maybe in a maybeT, no?
19:28:05 <bgamari> hmm
19:28:51 <DanBurton> > let findMin (x:xs) = filter (<= x) xs in findMin [3,2,5,3,0]-- Cody__
19:28:52 <lambdabot>   [2,3,0]
19:30:00 <Cody__> > let findMin (x:xs) = filter (<= x)  xs in findMin [1,2,5,3,0]
19:30:00 <lambdabot>   [0]
19:30:37 <penelope> Cody__: what's the type signature you should expect for findMin?
19:30:52 <Cody__> Hold on
19:32:39 <Cody__> findMin :: [Ixs] -> [x]. Not very good with typeclasses.
19:32:57 <Cody__> findMin :: [x] -> [x].
19:33:12 <penelope> not [x]
19:33:16 <penelope> -> x
19:33:17 <penelope> ?
19:34:01 <Axman6> Cody__: what are you trying to do?
19:34:11 <Cody__> I'll be calling this in selection sort. So for comparison reasons. it should be findMin :: [Int] -> a
19:34:29 <penelope> one might expect find :: a -> [a] -> Maybe a
19:34:29 <Axman6> are you sure? that type looks very wrong
19:34:30 <penelope> and
19:34:47 <penelope> min a -> [a] -> a
19:35:27 <penelope> oops
19:35:34 <penelope> minimum [a] -> a
19:35:44 <Cody__> Axman6: Not good with types yet, usually I just call :t in GHCi.
19:35:59 <penelope> well: minimum :: Ord a => [a] -> a
19:36:04 <Cody__> penelope: That's it
19:36:35 <Axman6> Cody__: time to learn, because they're extremely important. many haskell programmers start by writing all the types for their program, and then implementing the functions.
19:37:12 <Sgeo> > minimum []
19:37:13 <lambdabot>   *Exception: Prelude.minimum: empty list
19:37:15 <Sgeo> :(
19:37:18 <penelope> The most important thing is to write the type, and then define the subparts with "undefined"
19:37:56 <penelope> It's just like a math proof.
19:38:10 <Cody__> Axman6: I remember reading in some tutorial that most people just get their type definitions  from :t in GHCi. Bad habit I realize now
19:38:22 <Axman6> indeed
19:38:25 <penelope> Not a bad habit!
19:38:43 <ddarius> @let convolve ~(x:xs) ys@(~(y:_)) = x*y : add (scale x ys) (convolve xs ys) where add = zipWith (+); scalel = map . (*)
19:38:43 <lambdabot>  <local>:2:42: Not in scope: `scale'
19:38:49 <ddarius> @let convolve ~(x:xs) ys@(~(y:_)) = x*y : add (scale x ys) (convolve xs ys) where add = zipWith (+); scale = map . (*)
19:38:50 <lambdabot>  Defined.
19:38:51 * elliott doubts any experienced Haskell programmer does that
19:38:52 <Axman6> it's a bad idea unless you're writing some really trivial (and the complexity of the code that is 'trivial' gets larger the more you learn =))
19:39:11 <elliott> For really complicated definitions sometimes I use :t to figure out what I'm doing, but that's usually when I have no idea what I'm doing.
19:39:14 <penelope> I think of it as computer assisted teaching.
19:39:24 <elliott> Which is never a good situation to be in.
19:39:31 <Axman6> > join convolve [1,0,0,0,1]
19:39:35 <lambdabot>   mueval-core: Time limit exceeded
19:39:52 <Axman6> > take 5 $  join convolve [1,0,0,0,1]
19:39:55 <lambdabot>   [1,1,0,0,1]
19:39:55 <Sgeo> ddarius, what's with the irrefutable pattern?
19:40:04 <penelope> What I'd really like is for a haskell ide where I could select a sub-expression and have it give me the type.
19:40:05 <ddarius> Hmm, clearly not right.
19:40:15 <penelope> (in context!)
19:40:16 <Axman6> no :\
19:40:25 <elliott> penelope++
19:40:31 <Cody__> > let findMin (x:xs) = (head . sort) xs in findMin [53,6,23,76,0]
19:40:33 <lambdabot>   0
19:40:37 <Axman6> i wrote a colvolution function in Haskell at the end of my signals processing course exam because I was bored =)
19:40:38 <cmccann> penelope,  I'd rather have an IDE that allowed me to select a type and have it give me the expression :]
19:40:44 <elliott> Everyone keeps wanting that, nobody is writing it.
19:40:45 <ddarius> penelope: See Chameleon's type debugger.
19:40:55 <Sgeo> djinn!
19:41:07 <penelope> Oh! That sounds like candy.
19:41:23 <Cody__> > let findMin (x:xs) = (head . sort) xs in findMin [-1,53,6,23,76,0]
19:41:25 <lambdabot>   0
19:41:39 <ddarius> Axman6: Yeah, I've written one multiple times.  The basis of this one is (trying to be) the multiplication of geometric series by Doug McIlroy.
19:41:43 <cmccann> Sgeo, at one point I did some horrendous hacks to use djinn from TH to make a splice that would find the type it needed and magically write itself :P
19:41:50 <penelope> Cody__!
19:41:57 <Sgeo> @djinn (a -> b -> c) -> b -> a -> r -> q -> (c -> q) -> c
19:41:57 <lambdabot> f a b c _ _ _ = a c b
19:42:05 <penelope> what happens when you sort?
19:42:12 <elliott> penelope: What if x is the minimum?
19:42:17 <Axman6> Cody__: why would you sort to find the minimum?
19:42:28 <elliott> Axman6: That's not unreasonable...
19:42:32 <penelope> Axman6: lazy!
19:42:39 <Cody__> Because then it would be at the start. So I then take the head
19:42:51 <Axman6> foldl1 min >_>
19:42:53 <mysticc> Hey .. I was installing ghc-7.4 and I am getting error ./configure: line 1866: ghc/stage2/build/tmp/ghc-stage2: No such file or directory .. Can any body tell what does this mean ?>
19:42:58 <penelope> and what would be the head of sort?
19:43:00 <elliott> Axman6: Why bother? If the fold is lazy, it'll be fine.
19:43:07 <Cody__> penelope: Ya I know it cheating, running out of ideas lol.
19:43:09 <elliott> Cody__: Your right-hand side doesn't mention "x" at all.
19:43:17 <elliott> So it can't possibly work if the first element is the minimum.
19:43:26 <penelope> No, Cody__, you're getting to the right answer.
19:43:28 <elliott> Since you match the argument against (x:xs), so x is the first element and xs is the rest of the list.
19:43:38 <ddarius> @undefine
19:43:45 <ddarius> @let convolve ~(x:xs) ys@(~(y:ys')) = x*y : add (scale x ys') (convolve xs ys) where add = zipWith (+); scale = map . (*)
19:43:46 <lambdabot>  Defined.
19:43:46 <Cody__> I thought (x:xs) == [some list]?
19:43:55 <elliott> Cody__:
19:43:56 <elliott> > 1 : [2,3]
19:43:57 <lambdabot>   [1,2,3]
19:44:04 <elliott> [1,2,3] == (1 : 2 : 3 : []).
19:44:10 <elliott> Cody__: Are you reading a Haskell tutorial?
19:44:12 <ddarius> > let xs = [1,0,0,0,1]++repeat 0 in take 10 $ convolve xs xs
19:44:14 <lambdabot>   [1,0,0,0,2,0,0,0,1,0]
19:44:17 <Cody__> YAHT
19:44:18 <ddarius> Off by one error.
19:44:19 <elliott> It should explain how patterns like (x:xs) work.
19:44:37 <elliott> Cody__: You might want to check out LYAH. YAHT isn't very popular any more.
19:44:38 <elliott> @where lyah
19:44:38 <lambdabot> http://www.learnyouahaskell.com/
19:44:40 <penelope> The important point here is that haskell is lazy.
19:44:42 <penelope> soa
19:44:44 <penelope> so
19:45:10 <penelope> O(head . sort) in haskell == O(min) in strict languages.
19:45:27 <ddarius> It depends on the sort.
19:45:29 <elliott> penelope: Big-O notation weeps.
19:45:51 <penelope> I'm such a sad programmer!
19:45:53 <Cody__> elliot: I'll switch tutorials, thanks.
19:45:55 <Axman6> ddarius: does it make much sense to use anything other than a merge sort?
19:46:02 <Cody__> Quicksort?
19:46:08 <elliott> Cody__: YAHT isn't really bad, LYAH is just better :)
19:46:14 <Cody__> Lol^
19:46:16 <Jafet> base doesn't use an ordinary merge sort.
19:46:36 <Jafet> I'm not even sure if it's O(n log n) operations for all inputs, though it seems to be.
19:46:37 <elliott> Cody__: Quicksort isn't very good on linked lists (which Haskell's lists are), and it isn't very good if you're not sorting in-place (which you can't with Haskell's immutable lists).
19:46:44 <elliott> Mergesort is nicer, anyway.
19:46:44 <DanBurton> but YAHT sounds like Yacht, while LYAH sounds like Liar, which makes YAHT cooler
19:46:45 <Axman6> quicksort isn't quicksort when written in the usualy way (since quicksort was originally an inplace sort)
19:46:53 <Jafet> (It merges runs of varying lengths)
19:46:59 <penelope> And quicksort is evil on a sorted list.
19:47:37 <Axman6> merge sort also gives you the nice result that take k (sort <list of n elements) takes O(k log n) time
19:47:43 <Axman6> i think
19:47:56 <elliott> and take k (sort xs) is exactly what we're talking about here :P
19:47:57 <Axman6> hmm, n log k?
19:48:04 <elliott> where k=1, ofc
19:48:08 <Axman6> yeah
19:48:12 <djahandarie> elliott, Big-O notation makes me weep even when correctly used.
19:48:24 <Cody__> > let quickSort (x:xs) = quickSort [y | y <- xs, y < x]  ++ [x] ++ quickSort [y | y <-xs, y >= x] in quickSort [36,3,63,7,3]
19:48:25 <lambdabot>   *Exception: <interactive>:3:4-94: Non-exhaustive patterns in function quick...
19:48:28 <elliott> djahandarie: Big-O notation loves you.
19:48:31 <elliott> djahandarie: :(
19:48:38 <DanBurton> n log k
19:48:48 <penelope> djahandarie: prescriptavist!
19:48:59 <Cody__> Edit* not my code
19:49:07 <elliott> Cody__: You forgot the clause for the empty list.
19:49:13 <elliott> Or whoever said that did.
19:49:25 <Cody__> Case stament then?
19:49:32 <DanBurton> > let quickSort (x:xs) = quickSort [y | y <- xs, y < x] ++ [x] ++ quickSort [y | y <-xs, y >= x]; quickSort [] = [] in quickSort [36,3,63,7,3]
19:49:34 <lambdabot>   [3,3,7,36,63]
19:49:36 <Cody__> Not sure if lambdabot can do two functions at once
19:49:39 <elliott> No, just -- yeah, what DanBurton said.
19:49:45 <elliott> It just evaluates expressions.
19:49:48 <rwbarton> (case statement would work also)
19:49:50 <DanBurton> semicolon does the trick
19:49:51 <elliott> You can certainly define multiple clauses in a let...in.
19:49:52 <rwbarton> er, case expression
19:49:53 <Cody__> Oh I see
19:50:07 <Sgeo> There's no way to do multiple clauses in a lambda, is there?
19:50:10 <DanBurton> rarely use semicolons unless for lambdabot, though ;)
19:50:21 <DanBurton> Sgeo: correct
19:50:23 <penelope> in haskell,
19:50:24 <penelope> yes
19:50:32 <DanBurton> no way, unless you use a case statement
19:50:37 <penelope> you can have in ... where
19:50:50 <penelope> let foo = bar where ...
19:50:54 <penelope> sorory
19:50:56 <penelope> sorry
19:51:21 <Cody__> I usually just define quickSort [] = [] and quickSort [x] = [x] before I do the actual algorithm
19:51:27 <penelope> let foo = x; let y = bar in something
19:53:04 <elliott> penelope: That's not valid.
19:53:49 * Cody__ is going to watch the award show for the BCS
19:53:58 <ddarius> > do let foo = x; let y = Just 3 in y
19:53:58 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:54:16 <penelope> elliot: what I mean to say, is that you are allowed to have multiple expression binding in an expression in haskell.
19:54:28 <penelope> bindings
19:54:48 <penelope> But I tend to use where, so
19:55:01 <cmccann> > do { let foo = x; let y = Just 3 in y }
19:55:02 <lambdabot>   <no location info>: parse error on input `}'
19:55:11 <cmccann> > do { let foo = x; let y = Just 3 in y; }
19:55:12 <lambdabot>   <no location info>: parse error on input `;'
19:55:17 <cmccann> pf
19:55:30 <ddarius> cmccann: let in do needs braces around the bindings
19:55:44 <cmccann> ddarius, ah
19:55:59 * cmccann can never remember how this nonsense with braces works
19:56:27 <penelope> let x = (let y = 5; let z = 10; 11)
19:56:28 <rwbarton> > do let { foo = x }; let y = Just 3 in y
19:56:29 <lambdabot>   Just 3
19:56:34 <ddarius> > do let in Just 3 -- except in this case.
19:56:35 <lambdabot>   Just 3
19:57:00 <elliott> > do do do do let in let in do let in 3
19:57:02 <lambdabot>   3
19:57:08 <elliott> The two best parts of Haskell, in my opinion.
19:57:19 <elliott> do { x } not requiring x to be of any particular type, and "let in".
19:57:53 <ddarius> elliott: 3 is a monadic value in lambdabot anyway.
19:58:04 <penelope> Hmm. I'm annoyed I can use "where" everywhere one could use "let .. in"
19:58:29 <ddarius> penelope: You can't.
19:58:34 <ddarius> Except by introducing a let.
19:58:50 <penelope> I'm mean, I'm annoyed that I can't.
19:58:50 <Axman6> > do { let x = 3; True }
19:58:51 <lambdabot>   <no location info>: parse error on input `}'
19:58:59 <Axman6> > do { True }
19:59:00 <lambdabot>   True
19:59:04 <Axman6> interesting
19:59:25 <ddarius> The Report isn't completely clear on this topic.
19:59:26 <elliott> penelope: "where" used to be an expression form, and let...in didn't exist.
19:59:30 <elliott> Haskell 1.2 changed that, IIRC.
19:59:33 <ddarius> Some people think that behavior should be changed.
19:59:46 <elliott> I forget why it became a clause-level thing.
19:59:48 <elliott> Indentation?
20:00:33 <penelope> OMG: I miss monadic comprehensios.
20:00:33 <elliott> Axman6: that was a syntax error
20:00:37 <elliott> > do { let { x = 3 }; True }
20:00:38 <lambdabot>   True
20:00:41 <elliott> penelope: They're in GHC 7.2 onwards.
20:00:43 <ddarius> penelope: They're back anyway.
20:00:50 <elliott> > do { False; True }
20:00:51 <lambdabot>   Couldn't match expected type `m a'
20:00:51 <lambdabot>         against inferred type `GHC.Bool....
20:01:00 <penelope> !!! :-) !!?
20:01:14 <penelope> ReallyL
20:01:15 <penelope> ?
20:01:16 <elliott> Yes.
20:01:19 <penelope> OMGC
20:01:26 <elliott> Including the "group by" stuff.
20:01:39 <elliott> Did anyone ever find anything better about Haskell 98 compared to 1.4?
20:01:39 <ddarius> penelope: Ah, I see another worshipper of the great Garbage Collector in the sky.
20:01:54 <penelope> Well, some one is going to sleep happy tonight!
20:02:38 <elliott> Monad comprehensions aren't really all that nice.
20:02:43 <elliott> They're like do notation, except you can't use layout.
20:02:56 * cmccann would rather have idiom brackets :T
20:02:58 <elliott> And you put the last thing first for some reason.
20:03:02 <elliott> cmccann++
20:04:00 <penelope> grr.
20:04:59 <cmccann> penelope, you don't like idiom brackets? :[
20:05:13 <penelope> Well, either comprehensions have to go, or do has to go, composition has to go, and It's not going to be composition.
20:05:28 <ddarius> Beware penelope my call upon the great GC to reap you and leave your loved one with a broken heart.
20:05:59 * elliott holds a reference to penelope
20:06:09 <elliott> You'll have to take me down first!
20:06:40 <penelope> but! [(x,y) | x
20:06:41 <elliott> Coming this summer: "What are the GC roots?" "THERE ARE NO ROOTS IN THIS UNIVERSE, MORTAL."
20:07:29 <penelope> [(x,y) | x <- xs, y <- ys] would be so nice if it mean the same thing, in any monad, no?
20:07:41 <elliott> penelope: do { x <- xs; y <- ys; return (x,y) }
20:07:45 <ddarius> liftA2 (,)
20:07:46 <elliott> penelope: (| (xs,ys) |) with idiom brackets
20:08:09 <Sgeo> Wait, I thought idiom brackets weren't syntax, just a clever... thing
20:08:20 <penelope> You know, python programmers freak out at reduce, but love love love list comprehensions.
20:08:24 <Sgeo> iI Ii
20:08:39 <elliott> Sgeo: That's just one horrid implementation of idiom brackets.
20:08:45 <elliott> She has nicer ones: http://personal.cis.strath.ac.uk/~conor/pub/she/idiom.html
20:09:04 <rwbarton> :t iI
20:09:05 <lambdabot> Not in scope: `iI'
20:09:24 <elliott> rwbarton: http://www.haskell.org/haskellwiki/Idiom_brackets
20:09:25 <cmccann> Sgeo, idiom brackets are a platonic ideal
20:09:34 <cmccann> syntax for them is just one step closer to that
20:09:39 <elliott> Even that "motivation" section is silly.
20:09:43 <elliott> That isn't the motivation for idiom brackets at all.
20:09:59 <elliott> cmccann: We know we have idiom brackets when all our programs are one-liners?
20:10:10 <elliott> main = (| dwim |)
20:10:24 <ddarius> Syntax would seem like a step away from a Platonic ideal.
20:10:52 <Axman6> elliott: not dwiw?
20:11:16 <elliott> Axman6: Meaning is deeper than wanting, man!
20:11:16 <penelope> Maybe we could type latex, like in agda?
20:11:16 <Sgeo> I've been meaning to want to do this for a while
20:11:26 <elliott> penelope: Agda is Unicode explosion, not LaTeX.
20:11:34 <elliott> Oh, "type".
20:11:44 <elliott> Agda does have that Emacs mode to let you type sort-of-LaTeX for all the Unicode, yes.
20:11:57 <Axman6> elliott: but, it's the meaning of you, not the meaning of what you want the program to do
20:12:05 <elliott> Axman6: Oooh.
20:12:11 <penelope> Well, I kind of thought that was the solution for all things good.
20:12:12 <elliott> main = do
20:12:18 <Axman6> elliott: what is your meaning!
20:12:19 <elliott> Beat that!
20:12:23 <elliott> Just... do.
20:12:31 <cmccann> elliott, though the example in the article is something that annoys me on occasion
20:12:55 <cmccann> such that I have a combinator for it in my pile of utility functions
20:13:16 <elliott> cmccann: Yeah, the "join"s seem rather unintuitive; i.e. I tend not to realise I've missed one in applicative form until the typechecker tells me.
20:13:49 <elliott> I don't think syntactic hacks are the way to solve that, though. Maybe I don't know what you mean by "the example", though. At least I can't think of a utility function that would solve it other than... join :)
20:14:44 <cmccann> elliott: "(=<*) :: m (a -> m b) -> m a -> m b" is what I use
20:14:59 <elliott> Aww, but that only works for one argument.
20:15:07 <elliott> Oh, hmm.
20:15:12 <elliott> No, you just do it at the end, right.
20:15:16 <cmccann> it works for the common case, which is... yeah
20:16:09 <penelope> It's nice for applicatives.
20:16:26 <lispy> what is the type class constraint on m?
20:16:27 <Sgeo> Night
20:16:29 <cmccann> the name I gave it is an amalgamation of (=<<) and (<*>) as you can probably guess
20:16:53 <cmccann> lispy, Applicative and Monad both, in practice
20:17:04 <elliott> (=<*) = unsafeCoerce
20:17:06 <cmccann> since I only use that as part of a chain with (<*>)
20:17:16 <penelope> But I'd like sort of a universal thing.
20:17:27 <elliott> penelope: More universal than applicatives?
20:17:40 <elliott> Monad comprehensions are less universal than a notation for Applicatives.
20:17:53 <penelope> Applicatives, Monads, Arrows, Next-Big
20:17:53 <cmccann> penelope, how about function application
20:18:14 <elliott> penelope: You want a notation that preempts all future abstractions?
20:18:17 <cmccann> we should have a special syntax for function application, instead of having to just write things next to each other
20:18:33 <penelope> elliot:
20:18:33 <cmccann> hm
20:18:37 <penelope> I think
20:18:44 <elliott> cmccann: I'd rather overload juxtaposition some more.
20:18:49 <cmccann> how about allowing only single-letter identifiers? then we can ditch the spaces too
20:19:05 <penelope> We have to much physics in haskell, and not enough math.
20:19:07 <elliott> And let's use a Greek letter instead of a backslash!
20:19:18 <elliott> And remove the type system.
20:19:28 <elliott> penelope: I have no idea what that means.
20:19:35 <ddarius> > length (filter isLetter ['\0'..])
20:19:36 <lambdabot>   93455
20:19:44 <ddarius> That's more than enough identifiers.
20:19:47 <elliott> That's more tha- yes.
20:20:01 <Axman6> @hoogle isIdent
20:20:02 <lambdabot> No results found
20:20:07 <penelope> Physics people make silly distinctions between similar things in different domains.
20:20:11 <Axman6> @hoogle Char -> Bool
20:20:12 <lambdabot> Data.Char isAlpha :: Char -> Bool
20:20:12 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
20:20:12 <lambdabot> Data.Char isAscii :: Char -> Bool
20:20:18 <Axman6> @more
20:20:25 <Axman6> @hoogle+
20:20:25 <lambdabot> Data.Char isAsciiLower :: Char -> Bool
20:20:25 <lambdabot> Data.Char isAsciiUpper :: Char -> Bool
20:20:25 <lambdabot> Data.Char isControl :: Char -> Bool
20:20:29 <Axman6> @hoogle+
20:20:29 <lambdabot> Data.Char isDigit :: Char -> Bool
20:20:29 <lambdabot> Data.Char isHexDigit :: Char -> Bool
20:20:29 <lambdabot> Data.Char isLatin1 :: Char -> Bool
20:20:37 <Axman6> hmm, there's quite a lot there...
20:21:03 <elliott> Why do isAscii/isLatin1 exist?
20:21:11 * cmccann complains that the unicode symbol for juxtaposition-as-multiplication isn't valid Haskell syntax
20:21:27 <Axman6> why not? it can be helpful to make sure all your Chars will fit in a single byte
20:21:39 <elliott> Axman6: *in a single byte in Latin-1
20:21:44 <Axman6> or 7 bits in the case of isAscii
20:21:58 <elliott> If you're going to encode it in Latin-1 later, why not do it now and check whether it's one byte?
20:22:02 <elliott> Or, er.
20:22:07 <elliott> Just do it and handle the failure.
20:22:13 <elliott> No Char encodes to Latin-1 in more than one byte, it just fails to encode.
20:22:29 * elliott would be happy with something like `isRepresentableIn :: Char -> Encoding -> Bool`
20:22:35 <penelope> has anyone tried to run plan9? the origin of unicode?
20:22:46 <mauke> wat
20:23:02 <elliott> penelope: Unicode is not UTF-8.
20:23:25 <pikhq> And Plan 9 is not the origin of Unicode.
20:23:34 <penelope> !?
20:23:46 <penelope> Tell me more
20:23:48 <penelope> !
20:23:51 <elliott> Plan 9 is the system for which UTF-8 was designed, and was first implemented in.
20:23:54 <pikhq> Plan 9 is only the origin of the Unicode transformation format UTF-8.
20:24:02 <elliott> Unicode is a bunch of characters; UTF-8 is a way to encode them in bytes.
20:24:26 <elliott> I believe at least the bulk of the character work was done by the time UTF-8 came along, since they converted Plan 9 to it immediately.
20:24:30 * ddarius likes organizations that are stood up purely to make lists.
20:24:49 <rwbarton> @check \x -> isAlpha x == (isUpper x || isLower x)
20:24:50 <lambdabot>   "Falsifiable, after 2 tests:\n'\\14725'\n"
20:24:52 <cmccann> ddarius, you should start an organization to maintain a list of such organizations
20:24:53 <elliott> "By early 1992 the search was on for a good byte-stream encoding of multi-byte character sets. The draft ISO 10646 standard contained a non-required annex called UTF-1 that provided a byte-stream encoding of its 32-bit code points. This encoding was not satisfactory on performance grounds, but did introduce the notion that bytes in the ASCII range of 0–127 represent themselves in UTF, thereby providing backward compatibility."
20:25:00 <elliott> Right, so they already had all the characters.
20:25:25 <elliott> cmccann: 1. Organisation for Listing Organisations for Listings
20:25:33 <pikhq> Yeah, Unicode 1.0 was published late 1991. 2.0 was 1992.
20:25:34 <rwbarton> UTF-1? Doesn't sound very efficient
20:25:39 <penelope> so who came up with unicode?
20:25:52 <elliott> penelope: A committee.
20:25:58 <penelope> hee
20:26:11 <pikhq> penelope: The Unicode Consortium.
20:28:27 * ddarius makes UTF-11.
20:29:39 <penelope> so I'm just in the middle of teaching myself iteratees...but now we've move on to ? containers ?
20:30:16 <elliott> penelope: Well, you have to handle today's enterprise ?-containing needs.
20:30:38 <penelope> :-)
20:31:54 <penelope> success (failure) at any cost.
20:31:58 <lispy> Quick someone code up an Enterprise Service Bus in Haskell!
20:32:59 <lispy> ESBs are hot and we don't even have 1 on hackage
20:33:03 <elliott> lispy: *Someone* has to drive all the enterprise services around.
20:34:05 <penelope> aop iop hot injection.
20:34:37 <lispy> "Hey, TCP/IP with HTTP/SSL would work really well.  So...let's invent something worse on top of it!"
20:34:52 * lispy tries to imagine how ESB was born
20:35:35 * cmccann is pretty sure ESB means a kind of beer
20:35:44 <penelope> night
20:35:56 <elliott> Enterprise service beer.
20:36:02 <elliott> http://upload.wikimedia.org/wikipedia/commons/a/a2/ESB.svg
20:36:08 <cmccann> elliott, that would probably be more useful
20:36:15 <elliott> That tangle seems accurate.
20:37:01 <cmccann> elliott, oh, it's a name for the rug you sweep everything under
20:37:15 <ddarius> The difference between an ESB and "the internet" is really centralized control of naming.  I'm pretty sure most current implementations of ESBs do pretty much use TCP/IP and HTTP/SSL.
20:37:33 <elliott> cmccann++
20:38:18 <lispy> ddarius: yes, and SOAP/REST/etc
20:38:39 <lispy> ddarius: it's about request routing and queuing really
20:38:54 <lispy> and doing a structured but generic meta format (aka xml)
20:38:55 <ddarius> lispy: Those are orthogonal, though in practice many advocates of ESBs are also advocates of those for the "interoperability" benefits.
20:39:44 <elliott> Liskni_si: ASN.1!
20:39:59 <elliott> Er.
20:40:00 <ddarius> lispy: Yes, the internet is also about request routing and, in some cases queuing.  Queuing isn't fundamental for an ESB, but is usually desirable.
20:40:01 <elliott> *lispy:
20:41:40 <ddarius> The motivation for things like WS-Security is a standardized format that allows you to have separate parts of a message encrypted or variously packaged so that intermediate services/infrastructure can manipulate inspect the messages.
20:41:54 <lispy> elliott: I see your ASN.1 and raise you ASN.1 verification tools: http://corp.galois.com/asn1
20:43:24 <elliott> lispy: Oh no. I was joking. :(
20:44:40 <ddarius> My newer laptop's screen is so much crappier than my old laptop's screen.
20:49:50 * hackagebot failure 0.1.2 - A simple type class for success/failure computations.  http://hackage.haskell.org/package/failure-0.1.2 (MichaelSnoyman)
20:56:01 <The_Journey> hi, is tail O(1)?
20:56:18 <Axman6> what do you think?
20:56:24 <Axman6> @src tail
20:56:24 <lambdabot> tail (_:xs) = xs
20:56:24 <lambdabot> tail []     = undefined
20:56:35 <The_Journey> uh... yes?
20:56:42 <Axman6> chow many operations can you see happening there?
20:56:58 <cmccann> given that undefined represents non-termination, I would argue that tail is in fact O(infinity)
20:57:02 <cmccann> as an upper bound
20:57:34 <cmccann> big-O doesn't really make sense on partial functions
20:57:43 <elliott> #haskell gives you the advice you *really* need!
20:58:12 <cmccann> no, the real advice is "don't use tail"
20:58:35 <rwbarton> big-O doesn't really make sense when all you have is denotational semantics
20:59:00 <ddarius> Big-O doesn't care about programming.
20:59:05 <ddarius> Or its semantics.
20:59:54 * cmccann stands by his argument that tail is O(∞) however
21:00:05 <elliott> Yeah, but GHC can optimise a ton of infinite loops.
21:00:12 <elliott> Sometimes it even tells you why you got one.
21:00:14 <elliott> Other times it's just <<loop>>.
21:00:17 <ddarius> cmccann: So is (+1)
21:01:26 <Axman6> o/ XexonixXexillion
21:01:28 <cmccann> ddarius, yes, it's very troubling
21:03:20 * cmccann grumbles about Turing-completeness being overrated anyway
21:04:01 <lispy> Sont of OT question, let me know if I should take it elsewhere.  What are the good subreddits for programming topics?  I know of compsci, coding, programming, and haskell.
21:04:47 <ddarius> However, O(f) is a limit as n -> infinity.  If you are asking how the running time of tail varies with respect to input lists of length n, then it is still 1 as n -> infinity.
21:04:59 <salisbury> lispy: depends on what type of programming you're doing
21:05:05 <Axman6> lispy: they're the only ones i know. i follow compilers too, but it's almost enver got anything
21:05:14 <ddarius> lispy: Stop pointing your eyes at reddit.
21:05:33 <elliott> Point them at #haskell instead, that's so much more productive :P
21:05:59 <lispy> ddarius: where should I point my eyes?
21:06:26 <salisbury> there is /r/ai, for example, or /r/compilers as Axman6 mentioned
21:07:18 <salisbury> but yes, #haskell is bursting with knowledgeable people
21:07:38 <ddarius> salisbury: lispy has been here for some time.
21:07:50 <ddarius> lispy: Find some pretty woman (or man) to point them at, then point them at her (or him.)
21:09:32 <lispy> I guess I could just make sure to read all of sigfpe's blog.
21:09:40 <lispy> I'm sure I'd learn a ton
21:12:48 <salisbury> is it unusual to do something like "data TallyF = TallyF ([ByteString] → Map ByteString Int)"
21:13:07 <ddarius> No.
21:13:17 <ddarius> Except that newtype would arguably be better.
21:14:06 <salisbury> I was thinking it may, but I was unsure about lazy/strict evaluation of a function. Is there a difference?
21:14:21 <salisbury> a function with no parameters applied, that is
21:15:04 <lispy> thunks and functions in STG have the same representation and I would expect (although I don't know for certain) that GHC would end up with the function boxed by the TallyF constructor.
21:15:24 <lispy> I wouldn't expect strict unboxing to fire
21:15:54 <lispy> salisbury: criterion would provide a very good emperical answer
21:15:59 <ddarius> salisbury: You don't need to worry about performance concerns.
21:16:17 <ddarius> salisbury: Is TallyF _|_ a meaningful object in the semantics in your head?
21:16:41 * lispy predics no
21:16:50 <lispy> predicts even
21:17:00 <salisbury> yeah, no
21:17:10 <elliott> use newtype then :)
21:17:32 <salisbury> will do, thanks
21:18:38 * cmccann wants "oldtype" to go with "newtype"
21:19:03 <lispy> newtype and type are bad names in Haskell
21:19:20 <lispy> I would have preferred typedef for type.
21:19:34 <lispy> or typealias
21:19:35 <byorgey> 'oldtype' may only be used to reaffirm the definition of a type which was previously defined
21:19:54 <lispy> byorgey: so, oldtype = type def?
21:20:08 <lispy> oldtype String = [Char]
21:20:14 <byorgey> no, you can't use oldtype to give something a new name
21:20:25 <lispy> but [Char] is the old type :)
21:20:31 <byorgey> only to reiterate a previous definition
21:20:39 <elliott> that's ok, String is in the prelude
21:20:41 <elliott> so that definition is valid
21:20:47 <byorgey> ah, good point
21:20:50 <lispy> heh
21:21:09 <elliott> olddata lets you verify you're using a certain implementation
21:21:14 <elliott> olddata Map k a = ... -- works even for hidden cnostructors
21:22:08 <rwbarton> olddata Bool = True | False
21:22:28 <elliott> rwbarton: ERROR!
21:22:30 <elliott> False comes first.
21:22:39 <rwbarton> how does it work with hidden constructors then
21:22:41 <elliott> That would break the derived Ord instance, which you also forgot to include.
21:22:44 <elliott> rwbarton: Badly.
21:22:55 <rwbarton> ah ok
21:22:58 <lispy> oldinstance command fixes that
21:23:06 <elliott> :D
21:23:19 <elliott> oldmodule Prelude where { ... } -- make sure we're using the right prelude
21:25:10 * byorgey smells a new esoteric programming language designed especially for paranoid people
21:28:06 <cmccann> perhaps the compiler is allowed to change the meaning of identifiers if it's been too long since you reminded it
21:28:13 <cmccann> it's like INTERCAL's politeness
21:29:30 <byorgey> hehe
21:29:53 <elliott> INTERCAL really missed an opportunity there by just erroring out if you're too impolite.
21:30:00 <elliott> It should just corrupt vital sections of your program.
21:30:21 <Jafet> Unless politely asked not to
21:35:11 * cmccann thinks PLEASE DON'T GIVE UP is one of the best commands in any programming language
21:36:41 <elliott> That's just a comment, really. Although REINSTATE treats it specially.
21:36:57 <elliott> I guess "comment" is a bit ill-defined.
21:37:18 <elliott> (This is #intercal, right?)
21:38:11 <cmccann> elliott, it matters for politeness, though
21:38:22 <cmccann> at least, I think it does
21:39:09 <elliott> cmccann: Well, yeah, the PLEASE bit does :)
21:39:35 * cmccann considers an INTERCAL monad along the lines of the BASIC monad
21:39:47 <ddarius> @google intercal monad
21:39:48 <lambdabot> http://www.flightofthehawk.com/Articles/monad7.html
21:39:48 <lambdabot> Title: The Seventh Monad: From Death to the Astral Interval
21:40:11 <elliott> It's "PLEASE DO N'T GIVE UP" --> "PLEASE DO NOT GIVE UP", so the GIVE UP part is ignored, except treated specially by REINSTATE (by making it be a no-op).
21:41:04 <elliott> "Well of course the seventh monad begins with the last breath" -- I never knew monads were so powerful.
21:42:27 <cmccann> elliott, that's talking about Cont, right?
21:42:46 <cmccann> sounds like a reasonable description of CPS code to me.
21:43:14 <elliott> "the essence can choose at that time to exit the body and remain in what we might call a 'holding pattern' until the body itself ceases" -- sounds like stashing a continuation away to me.
21:43:37 <elliott> "Once the last breath has occurred then the fragment is in the first stage of the seventh monad which we will call transition." -- this is clearly referring to (>>=)
21:43:44 <cmccann> yeah
21:43:49 <elliott> "the second stage which is structural by nature, and is the dissolution or breakdown of components " -- and this sounds like runCont
21:43:50 <cmccann> not the worst monad tutorial I've seen, really
21:44:09 <elliott> The death analogy is the logical next step from the nuclear waste analogy.
21:44:34 <ion> :-D
21:44:56 <elliott> s/s "/s"/
21:45:19 <cmccann> elliott, yes, and puts a new light on the "sin bin" term as well
21:45:30 <ion> “© 1999 Victoria Marina-Tompkins”
21:45:31 <cmccann> in case anyone doubted what kind of afterlife IO is
21:45:37 <ion> Shouldn’t that be “© 1999 Michael”?
21:47:48 <elliott> I must admit the "dissolution or breakdown of components" part sounds more comonadic.
21:48:10 <elliott> Though I guess join fits that, actually.
21:50:01 <NemesisD> anyone here use attoparsec? my grammar has 2 tokens, one is a subset of the other. i'm trying to figure out how to make the parser greedy so it doesn't always just choose the subset
21:56:02 <ddarius> NemesisD: attoparsec tries alternatives in order.
21:56:32 <lispy> ddarius: if he just changes the order it will consume too much on the failure case, right?
21:56:46 * lispy hasn't used attoparsec in a long time
21:56:58 <elliott> Doesn't attoparsec have "try"?
21:57:05 <ddarius> try is id in attoparsec
21:57:12 <elliott> Oh.
21:57:13 <ddarius> http://hackage.haskell.org/packages/archive/attoparsec/0.10.1.0/doc/html/src/Data-Attoparsec-ByteString-Internal.html#try
21:57:25 <elliott> Okay then.
22:03:36 <NemesisD> ah. it turns out it was because it was actually failing on the fist one. precedence with <|> worked as expected after i fixed that
22:10:00 * hackagebot couchdb-conduit 0.1.0.1 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.1.0.1 (AlexanderDorofeev)
22:31:55 <estan> if i have two "tables" of the same dimension (represented as list of lists), and want to construct third table with the same dimension, where each position of the table is the result of applying a function to the corresponding position in the two other tables, what's the most elegant way to do that?
22:33:11 <companion_cube> > zipWith (+) [1..10] [11..20]
22:33:12 <lambdabot>   [12,14,16,18,20,22,24,26,28,30]
22:33:40 <companion_cube> oh, wait
22:33:45 <estan> :)
22:36:31 <estan> e.g. taking your example with addition i'd want to get from e.g. t1 = [[1,2], [3,4]] and t2 = [[5,6], [7,8]] to t3 = [[6,8], [10,12]].
22:38:02 <companion_cube> :t \l1 l2 -> map (uncurry $ zipWith (+)) $ zip l1 l2
22:38:03 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
22:38:22 <ion> @type zipWith (zipWith (+))
22:38:23 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
22:38:37 <companion_cube> hmmm, much better :D
22:38:48 <ion> > zipWith (zipWith (+)) [[1,2],[3,4]] [[5,6],[7,8]]
22:38:49 <lambdabot>   [[6,8],[10,12]]
22:39:01 <estan> heh. awesome. and of course.
22:39:03 <estan> thanks.
22:39:23 <estan> just two zippers!
22:40:17 <ddarius> :t zipWith . zipWith
22:40:17 <lambdabot> forall a b c. (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
22:41:12 <companion_cube> :t zipWith . (zipWith . zipWith)
22:41:13 <lambdabot> forall a b c. (a -> b -> c) -> [[[a]]] -> [[[b]]] -> [[[c]]]
22:41:25 <companion_cube> :t zipWith . (zipWith . (zipWith . zipWith))
22:41:26 <lambdabot> forall a b c. (a -> b -> c) -> [[[[a]]]] -> [[[[b]]]] -> [[[[c]]]]
22:41:31 <companion_cube> excellent
22:41:34 <estan> ohhh the dimensions, my head!
22:41:36 <estan> ;)
22:43:27 <ddarius> zips are not called "zippers."  There is another concept called a "zipper."
22:43:49 <ion> @type zipWith . zipWith . zipWith . zipWith  -- redundant brackets?
22:43:50 <lambdabot> forall a b c. (a -> b -> c) -> [[[[a]]]] -> [[[[b]]]] -> [[[[c]]]]
22:44:01 <companion_cube> and there are also "zippos"
22:45:13 <ddarius> (.) is associative
22:46:11 <estan> ddarius: yea sorry, at that point i was talking about the actual zippers used for joining fabric, from which i guess zipWith got its name :) (didn't know there was a concept of zippers separate from zips in haskell).
22:48:13 <elliott> Zippers are named after those too.
22:49:00 <estan> right, guessed as much.
22:56:12 <simon_> Good morning. I'm having some problems. In Data.Maybe there's a function isJust. When i try to implement that myself i get an non exhaustive patterns exception. Does anyone know what i might be doing wrong?
22:56:52 <ben> You might be asking questions without posting code!
22:57:04 <simon_> the exact same as in the library
22:57:20 <simon_> isJust Nothing = False; isJust _ = True
22:57:42 <simon_> when i use it with something that's not nothing i get an exception
22:58:03 <ben> > let isJust Nothing = False; isJust _ = True in (isJust Nothing, isJust $ Just ())
22:58:04 <lambdabot>   (False,True)
22:58:21 <ben> You must have typoed the function name in the second case or something
22:58:56 <simon_> ooops so stupid ;(
22:59:09 <ion> data Maybe a = Nothing | Just a | FileNotFound FilePath
23:03:43 <tehgeekmeister> iirc there are multiple state monad implementations -- which is preferred these days?
23:05:35 <ion> RState
23:06:37 <tehgeekmeister> ion: that's not even on hackage?
23:06:38 <Enigmagic> tehgeekmeister: i use mtl2
23:06:59 <tehgeekmeister> Enigmagic: okay.  i remembered something about one of them being deprecated, is why i asked.
23:07:18 <Enigmagic> tehgeekmeister: mtl-1 has been deprecated, mtl-2 is fine
23:07:38 <ion> tehgeekmeister: I was joking. It’s the reverse state monad.
23:07:58 <tehgeekmeister> ion: oh, god, i remember trying to grok that once.  no thanks.
23:18:13 <Guest8365> Good morning #haskell, any ideas on how to resolve this error? <command line>: cannot satisfy -package-id binary-0.5.0.2-c377ef9355c0db222ea16bbcdc8fbd30:  binary-0.5.0.2-c377ef9355c0db222ea16bbcdc8fbd30 is shadowed by package binary-0.5.0.2-417372e05b93d9fea0831a6df8c85d25 (use -v for more information)
23:18:44 <Guest8365> binary and bson were both installed, then I think upgrading to ghc 7.4 and then installing 7.2 caused this problem
23:19:00 <Guest8365> cabal install --reinstall binary worked fine
23:19:09 <Guest8365> cabal install --reinstall bson fails with the above error
23:22:00 <Lemmih> Guest8365: You could delete all locally installed packages.
23:26:52 <Guest8365> Lemmih: Is there a way to echo where cabal is installing everything?
23:28:44 <tehgeekmeister> can functor be derived automatically?
23:31:29 <elliott> tehgeekmeister: yes, sometimes
23:31:38 <elliott> with DeriveFunctor
23:31:57 <elliott> i think it can fail on rank-n types and stuff like that
23:32:44 <tehgeekmeister> thanks
23:33:15 <tehgeekmeister> thanks
23:33:20 <tehgeekmeister> errr, this is not my terminal
23:33:22 <tehgeekmeister> sorry
23:38:27 <elliott> tehgeekmeister: always remember to thank your terminal
23:47:42 <Blkt> good morning everyone
23:51:23 <tehgeekmeister> seems like there are cases where the state monad can't be used, and IORefs are necessary.  i don't want to believe this.  is it true?
23:54:04 <yitz> tehgeekmeister: well there are times when IORefs are the right tool. it may sometimes - or even always - be possible to use something like StateT IO or MonadIO m => StateT m in those cases instead by making a big mess of things.
23:55:16 <tehgeekmeister> yitz: i'm writing a stateful recursive evaluator for another language.  seems like you can't do the recursion and the statefulness in the state monad.  you could get one or the other.
23:55:33 <tehgeekmeister> though, i guess i could make my own monad that did it.  yeah.
23:55:37 <yitz> sure
23:56:22 <yitz> if the language is also side-effectful, there is going to have to be IO in there somehow though.
23:56:43 <tehgeekmeister> yeah, it is
23:57:10 <tehgeekmeister> but i'm not doing anything that interacts with the real world yet -- project is *way* too new for that.
23:57:26 <yitz> see how augustus did burp, his python evaluator. he used ContT, and seems to have worked out well for him.
