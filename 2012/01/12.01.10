00:00:01 <yitz> *augustss
00:00:09 <yitz> preflex: seen augustss
00:00:09 <preflex>  augustss was last seen on #haskell 62 days, 8 hours, 11 minutes and 32 seconds ago, saying: > div (-1) 2
00:00:21 <Veinor> oh no
00:01:17 <yitz> Veinor? did i say something wrong?
00:01:30 <Veinor> no i was saying 'oh no augustss'
00:02:08 <yitz> Veinor: he is one of the founders of haskell and a top-notch computer scientist
00:02:17 <yitz> unless i got the nick wrong
00:03:28 <Veinor> i meant 'oh no, he hasn't been seen in a while'
00:05:46 <yitz> ah :)
00:06:18 <yitz> he's working at a bank, so he's probably very busy.
00:06:28 <tehgeekmeister> mmm, i guess there's a dirty trick i could use to make it work...
00:06:30 <tehgeekmeister> yesss!
00:07:59 <tehgeekmeister> i get scope for free!  woooooo!
00:40:06 <ozataman> does anyone know why cabal-dev wouldn't install using latest cabal and cabal-install on ubuntu? It spends a while on the linking stage and exists with code 9.
00:59:13 <Axman6> y/24
00:59:17 <Axman6> oops
01:00:19 * hackagebot splot 0.3.1 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.3.1 (EugeneKirpichov)
01:06:34 <yitz> ozataman left, but i am using cabal-dev on ubuntu with no trouble. ftr.
01:12:34 <tehgeekmeister> aren't equations attempted in top down order?
01:20:54 <augur> tehgeekmeister: yes
01:21:19 <tehgeekmeister> mmm.  then my pattern match isn't as useful as i thought it was.  okay.
01:22:23 <erus`> does it make sense for generics to be implemented in the lowest level type system or an abstraction above it that is compiled down ?
01:28:51 <nus> @hackage berp
01:28:51 <lambdabot> http://hackage.haskell.org/package/berp
01:29:01 <nus> yitz, are you talking about this ^^^
01:40:22 * hackagebot monadiccp 0.7.3 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-0.7.3 (TomSchrijvers)
01:43:21 <Phlogistique> lambdabot, how good is your chatterbot module?
01:43:50 <Phlogistique> lambdabot: can Haskell make coffee?
01:45:46 <dreixel> erus`: both make sense
01:46:14 <dreixel> I mean, what kind of generics are you talking about? polymorphism or datatype-genericity?
01:52:00 <erus`> type generics with type arguements
01:52:07 <erus`> like     List Int
01:52:52 <Veinor> so type constructors?
01:54:03 <erus`> yeah
01:54:22 <erus`> its like pre processing anyway, right?
01:54:30 <erus`> like templates
01:55:19 <elliott> no
01:55:59 <elliott> i mean, i don't see how that view can account for e.g. certain kinds of polymorphic recursion
01:56:18 <erus`> I dont have custom types
01:56:38 <elliott> wikipedia backs me up at least as far as viewing parametric polymorphism as templates goes: "In some strongly typed languages, such as C++, polymorphic recursion is difficult to implement because all data types are determined during compilation. Polymorphic recursion causes data types to be infinitely nested, forcing the compiler to throw an error."
01:57:00 <elliott> erus`: that's too vague a statement to change my statements :P
01:57:30 <erus`> well i dont have polymorphism :)
01:58:43 <elliott> well, I was talking about well-known languages with such features like Haskell, not your language I'm meant to guess every detail of to answer questions about :p
01:59:06 <erus`> yeah it was a vague question
01:59:34 <erus`> is there a reason why people hate templates?
02:00:11 <Jaxan> do they?
02:00:32 <erus`> I allways hear people moan about templates
02:00:33 <elliott> they're really ugly for doing any kind of advanced stuff in, they're resolved at compile-time which limits their use, you have to put them in headers? I'm not really experienced with C++ but they seem pretty obviously sub-par to me
02:00:57 <elliott> also from the practical perspective they tend to make compilation very slow (due to the compile-time resolution thing) and produce ugly error messages
02:02:02 <Veinor> also you can't do Foo<Bar<Baz>>
02:02:07 <Veinor> you need to do Foo<Bar<Baz> >
02:02:16 <Veinor> iirc this is fixed in c++11
02:02:23 <erus`> well my templates are a little more integrated
02:03:07 <elliott> yeah c++0x fixes that
02:03:31 <elliott> because C++'s grammar wasn't ambiguous enough
02:03:37 <erus`> type List a = @[ (), (a, List a) ]     --  @[ means can-be-any-of-these
02:05:39 <erus`> (1, (2, (3, () ) ) )   -- a list of numbers
02:10:57 <erus`> This works because I assume that if a type check causes an infinite loop (it checks the same bit twice) then the types check.
02:11:15 <erus`> But im not sure how true that is
02:11:29 <frerich> erus`: Another issue with C++ templates is that the support for them differs quite a lot between different compilers and STL implementations; so writing software which is portable across many platforms/compilers is a lot harder than one might think.
02:15:26 * hackagebot sloth 0.0.1 - Testing for minimal strictness  http://hackage.haskell.org/package/sloth-0.0.1 (JanChristiansen)
02:15:30 <hpaste_> erus` pasted “tom's type system” at http://hpaste.org/56320
02:22:15 <estan> anyone know a tiny haskell project that is very well written? i could use some code-reading i think (haskell newb).
02:22:41 <estan> (feel free to brag ;)
02:23:34 <ion> GHC
02:23:41 * ion ducks
02:23:44 <estan> tiny? ;)
02:24:00 <NapHtaKeRoSene> hi
02:24:01 <NapHtaKeRoSene> anybody know how to call a pointer to function in linux C ?
02:24:16 <elliott> NapHtaKeRoSene: yes, but don't you want to ask about Haskell in the Haskell channel?
02:24:42 <NapHtaKeRoSene> blog it in my pm if you don't want it here
02:24:59 <elliott> NapHtaKeRoSene: go to ##c
02:25:08 <elliott> this channel is about Haskell, a programming language quite unlike C :P
02:25:11 <NapHtaKeRoSene> cant i dont have registered
02:25:24 <erus`> NapHtaKeRoSene: ptr(); ?
02:25:28 <elliott> well, register your nick then... this isn't the channel for it either way
02:35:07 <estan> the reason i'm asking for well-written small haskell projects is i'm working on a small school assignment, and i don't know if my style is up to snuff: http://ideone.com/SQ6le
02:35:30 <estan> if someone sees something horrid in that code, style-wise, feel free to point it out.
02:36:18 <gienah> estan: hlint might have some code style suggestions
02:36:47 <gienah> hlint MolSeq.hs
02:37:10 <estan> gienah: ah. thx for the tip.
02:37:28 <opqdonut> hlint is nice yeah
02:37:46 <opqdonut> I see nothing horrid about that, I'd use more whitespace (e.g. in the list comprehension)
02:37:58 <erus`> hlint should come with the platform
02:37:59 <opqdonut> and a nested where is a bit iffy too. but sometimes you just need one.
02:39:27 <estan> opqdonut: alright, the list compr., would you rather see [1 | (a, b) <- zip s1 s2, a /= b] ?
02:39:38 <opqdonut> yeah, for example
02:39:40 <quicksilver> I don't think anything is horrible about that estan
02:40:14 <opqdonut> but of course you could rewrite the whole line as "ndiff = length . filter (/=) $ zip s1 s2"
02:40:23 <opqdonut> but that's a minor point :)
02:40:27 <quicksilver> that nested where is not necessary
02:40:39 <quicksilver> and since you're defining "dist" locally
02:40:45 <estan> opqdonut: thx!
02:40:45 <quicksilver> it doesn't need "x" and "y" as parameters
02:40:49 <quicksilver> it has them in scope already
02:40:54 <Peaker> estan: you could use some more point-free style, e.g: seqLength s = length (seqSequence s) -> seqLength = length . seqSequence
02:41:05 <estan> quicksilver: ah. you're right.
02:41:29 <opqdonut> also, "a = fromIntegral(ndiff) / fromIntegral(ntot)" could be "a = fromIntegral ndiff / fromIntegral ntot"
02:41:40 <estan> Peaker: also good point. thx.
02:41:41 <opqdonut> and I might actually put the fromIntegrals into the definitions of ndiff and ntot
02:41:46 <opqdonut> but that's debatable
02:42:50 <estan> quicksilver: you mean the nested where is not necessary since i could put my dist helper function outside?
02:43:01 <opqdonut> also, you might consider writing MolSeq as "data MolSeq elemtype = MolSeq { seqName :: String, seqSequence :: [elemtype]}"
02:43:18 <akosch> is there an if expression for IO Bool values, which runs the action automatically and works with the result? I'm a bit annoyed with writing things like "isDirectory <- doesDirectoryExist path \n if isDirectory then ..." all the time. I'd rather feed the result directly to if.
02:43:24 <opqdonut> and then have "data DNA = A | C | G | T; data Protein = Protein String" or something
02:43:59 <Saizan> akosch: nope, but you can write a function that does that
02:44:18 <estan> opqdonut: ah right. (there actually is an alphabet for proteins as well, i'm just being sloppily non-explicit about that).
02:44:22 <frerich> estan: I'm not too familiar with Haskell yet, but I just noticed the 'seqType x /= seqType y = error "Sequence types differ!"' guard in seqDistance. I would consider making 'MolSeq' parametrized on the sequence type (so you have 'MolSeq DNa' and 'MolSeq Protein') and then change the 'seqDistance' function to 'MolSeq a -> MolSeq a -> Float' so that it's simply not possible to call the fucntion with 'incompatible' MolSeq values
02:44:28 <akosch> Saizan: I thought of that, but it won't have the nice syntax of if, right?
02:44:46 <Sgeo> When I write a function that takes stuff and a value and returns a modified copy of the value, should the argument that is the original value be the last argument?
02:44:49 <estan> anyway, the assignment is due tomorrow, so i don't have unlimited time to polish stuff of course. but thanks for all the suggestions.
02:44:57 <Sgeo> That's how lenses do it I think, and it makes sense for use with .
02:45:02 <opqdonut> Sgeo: it usually is last
02:45:06 <Sgeo> Ok
02:45:13 <opqdonut> Sgeo: see e.g. the containers package
02:45:14 <akosch> Saizan: I mean "if ... then ... else ..."
02:45:18 <Sgeo> Things like that should be in a tutorial somewhere >.>
02:45:47 <merijn> akosch: foo a b = a >>= \x -> if x then b else return () (with foo :: IO Bool -> IO () -> IO ())
02:46:20 <merijn> akosch: And then you can write "foo (doesDirectoryExist path) stuff"
02:46:27 <elliott> akosch: I would be wary of functions like doesDirectoryExist, by the way.
02:46:35 <merijn> ^^
02:46:46 <merijn> doesDirectoryExist == race condition
02:46:53 <elliott> It's really didDirectoryExistAtSomeTimeInThePastProbablyAndMightNotNow.
02:47:13 <estan> frerich: ah. that's a good improvement i think. unfortunately the assignment instructions are explicit about us using the error function to signal an error if they differ.
02:47:23 <akosch> elliott: oh, I didn't know...
02:47:55 <frerich> estan: I see. I'm not sure it would've worked out (again, I'm still rather new at Haskell) but it seemed like something worth considering for me :-)
02:47:56 <akosch> merijn: thanks, give me a second to understand that :)
02:47:57 <elliott> akosch: Specifically, the directory could be removed between you checking whether it exists and using it. It's best to just perform whatever operations you're going to, and handle the failure.
02:48:07 <elliott> merijn: foo a b = a >>= flip when b
02:48:08 <merijn> akosch: Think of this: What happens if a process removes a file/directory *after* you called "doesDirectoryExist"/"doesFileExist" but before you do anything with the file/directory?
02:48:18 <elliott> merijn: foo a b = a >>= (`when` b) is nicer actually
02:48:32 <merijn> :t when
02:48:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:50:29 <akosch> got it. I was not sure how good those "other operations" handle errors
02:50:57 <akosch> I assume they throw exceptions so I can give sane error messages
02:51:14 <elliott> yep
02:51:16 <merijn> akosch: The usual solution (in all languages) is to just try whatever operation and handle whatever error occurs
02:52:29 <merijn> akosch: See this section for IO errors: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#g:29
02:53:01 <elliott> merijn: The old exception mechanism? Really?
02:53:13 <akosch> merijn: sound good, why do these doesExist function even exist then? I imagine they have a bit of a limited use: putStrLn "Yes, the directory did exist the last time I checked!" :)
02:53:13 <elliott> I suppose that page does link to Control.Exception.
02:53:13 <merijn> elliott: There's a new one?
02:53:25 <elliott> merijn: Err, yes, extensible exceptions: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html
02:53:28 <elliott> Many years old now I think.
02:54:00 <elliott> akosch: Well, they're useful to implement a tool that tells you if a file exists or not :)
02:54:06 <merijn> elliottt: Oh, duh
02:54:29 <merijn> elliott: I just linked whatever exception link was listed by the readFile/etc functions :p
02:54:34 <elliott> hehe
02:54:46 <elliott> the Prelude should probably re-export Control.Exception these days
02:54:55 <elliott> having to "import Prelude hiding (catch)" sucks :(
03:01:03 <akosch> what's the community's stance on long lines in the source code? I prefer to stick to 80 chars in a line and no more, but when I look at some package sources the lines just run off the screen :(
03:02:00 <akosch> I hate to turn on line wrapping in vim
03:02:01 <koala_man> try not coding on a VT100
03:02:16 <merijn> koala_man: That's a non-argument
03:02:21 <akosch> koala_man: I usually want to edit multiple files
03:02:28 <merijn> I still use 80 columns so I can have multiple files on screen
03:03:06 <erus`> is there an unsigned type?
03:03:35 <elliott> erus`: Word
03:03:57 <erus`> perfect
03:03:57 <elliott> akosch: I generally go for 90-100 columns; the "horizontal" compositional style I tend to use makes 80 a bit awkward, but if it works for you I'd stick with it
03:03:59 <erus`> thanks
03:04:12 <elliott> akosch: Really long lines are just bad, though :P
03:05:15 <akosch> elliott: I have no problems in Haskell (except for some other peoples code), but it's very hard to do in Java for example
03:06:30 <elliott> Maintaining any kind of length limit is impossible with Java :P
03:06:49 <akosch> elliott: (new SomeClass).somemethod((new something).getFactory().createNewInstance(), ....)
03:07:25 <quicksilver> not that hard really, just break the line after the .
03:08:14 <akosch> quicksilver: yeah, but if you always indent the next line more you soon run out of space
03:08:37 <quicksilver> yes, that would be daft
03:08:47 <quicksilver> each continuation line has the same indent.
03:08:52 <quicksilver> fooNess
03:08:55 <quicksilver>   .getBar()
03:09:00 <quicksilver>   .getBaz();
03:09:26 <quicksilver> which is the same way I write haskell, even though haskell doesn't suffer so much from the industrial revolution.
03:10:05 <akosch> quicksilver: 2-space indent?
03:10:18 <quicksilver> generally yes but that's not the point. The point is not to creep.
03:11:18 <akosch> quicksilver: It's a valid point I guess, just have to get used to it :)
03:11:24 <elliott> quicksilver: You still have to indent more for nesting, though.
03:11:37 <elliott> Admittedly with 2-space indents you're unlikely to reach the right margin that way.
03:13:12 <akosch> when coding haskell I tried sticking with this: http://snapframework.com/docs/style-guide
03:14:24 <koeien> the snap code itself is very readable
03:15:02 <koeien> if you ever want to read some well crafted haskell code, that's the way to go.
03:15:24 <akosch> koeien: that was my impression too
03:15:54 <akosch> I'm not sure about hanging lambdas though: I always indent the function body
03:16:20 <quicksilver> hanging lambdas aren't always morally "nesting"
03:16:35 <quicksilver> just like do blocks aren't morally nesting
03:16:52 <quicksilver> in fact hanging lambdas are exactly like do blocks - you can translate a do block into hanging lambdas, after all
03:17:01 <quicksilver> that looks like a good guide to me, akosch
03:17:18 <quicksilver> although being lazy I tend to follow the indentation style my editor supports (having customised it slightly)
03:17:49 <koeien> i admit to not always keeping my line length below X, where X is 80, 78 or w/e
03:18:05 <akosch> quicksilver: sadly haskell support in vim is abysmal
03:18:13 <akosch> quicksilver: compared to C and the likes
03:19:09 <elliott> akosch: Editor support is overrated. Emacsers have it and I spend about half my day pressing tab to cycle through possible indentations.
03:19:21 <elliott> Indenting by hand is probably quicker.
03:19:44 <erus`> @hoogle [a] -> Integer -> [[a]]
03:19:44 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
03:19:45 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
03:19:45 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
03:19:50 <quicksilver> weird, elliott
03:20:28 <elliott> quicksilver: Well, "half my day" is a bit much. But I've used both the indentation and indent modes and they both love to pick the "wrong" indentation.
03:20:29 <quicksilver> I find on each new line (1) emacs is right, say, 75% of the time (2) 24% of the time it's one TAB or one BACKSPACE from being right
03:20:37 <quicksilver> and 1% of the time you have to press more than one key
03:20:47 <quicksilver> that's much quicker than indenting by hand for me.
03:20:59 <elliott> You're lucky, I guess :)
03:21:03 <elliott> Or I indent idiosyncratically.
03:21:05 <erus`> whats the function to get every combination of a list?
03:21:17 <erus`> no i need every combination of n items
03:21:34 <akosch> elliott: I'm quite content for using automatic indenting for ehm... less elaborate languages like PHP too
03:21:48 <koeien> permutations
03:22:01 <koeien> ah there is an easy oneliner for that
03:22:15 <akosch> s/for/with/
03:22:16 * koeien wishes that he could get used to emacs
03:22:46 * elliott likes autoindentation just fine for non-Haskell languages.
03:22:47 <srhb> koeien: evil-mode!
03:22:59 <elliott> I mean, languages you can reliably autoindent (i.e. non-layouted ones) obviously autoindent just fine :)
03:23:12 <koeien> i tried that, the last time it was not complete :(
03:23:33 <srhb> koeien: It's really good now, I use it all the time.
03:23:33 <akosch> if there are any good pretty-printers for haskell, I guess automatic indenting could be done sanely
03:23:49 <srhb> koeien: Only thing really missing are the ex commands.
03:23:59 <elliott> akosch: Well, sure, but they need source code that's already indented.
03:24:06 <koeien> erus`: sequence . replicate n
03:24:08 <elliott> So they don't help for writing it in the first place.
03:24:11 <elliott> koeien: replicateM
03:24:12 <koeien> erus`: but those "count double"
03:24:15 <elliott> erus`: ^
03:24:28 <koeien> > replicateM 2 [1..3]
03:24:29 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
03:24:58 <koeien> srhb: it has been some time since i tried it (or i tried another vim-thingy). I'll try again :)
03:25:05 <akosch> elliott: yes, you have a point...
03:25:06 <erus`> ok but [2, 3] == [3, 2]
03:25:36 <srhb> koeien: evil mode was joined together from vimpulse and vim-mode, both authors working a lot on it now.
03:25:47 <LeNsTR> > [2,3] == [3,2]
03:25:48 <lambdabot>   False
03:25:54 <erus`> in my owlrd
03:26:06 <koeien> erus`: do you want [3,3] also?
03:26:11 <erus`> no
03:26:20 <erus`> like picking 2 from a selection
03:26:26 <koeien> i see. then the easiest way I see is just recurse
03:26:40 <erus`> ok
03:26:42 <koeien> exactly n [] = ... exactly n (x:xs) = ...
03:26:56 <psacvdf> or the permutations function in Data.List
03:27:02 <erus`> ive written this before somewhere i think
03:27:53 <erus`> https://github.com/tm1rbrt/haskell/blob/master/poker/handstats.hs#L13 here
03:28:04 <koeien> psacvdf: that takes all permutations, not only the k-sets from an n-set
03:28:31 <koeien> erus`: seems right, yes.
03:28:46 <koeien> (if tails is what i think it is.)
03:32:25 <Axman6> > let perms xs = f (sort xs) where f [] = [[]]; f xs = let ys = zipWith3 (\a b c -> (a,b++c)) xs (inits xs) (drop 1 $ tails xs) in concatMap (\(y,others) -> map (y:) (f others)) ys; sorted xs = and $ zipWith (<=) xs (tail xs) in sorted (perms "Hello, world!")
03:32:26 <lambdabot>   Not in scope: `sorted'
03:32:49 <koeien> it's not Python :)
03:32:59 <Axman6> > let sorted xs = and $ zipWith (<=) xs (tail xs); perms xs = f (sort xs) where f [] = [[]]; f xs = let ys = zipWith3 (\a b c -> (a,b++c)) xs (inits xs) (drop 1 $ tails xs) in concatMap (\(y,others) -> map (y:) (f others)) ys; in sorted (perms "Hello, world!")
03:33:01 <lambdabot>   False
03:33:07 <Axman6> :o
03:33:25 <Axman6> > let sorted xs = and $ zipWith (<=) xs (tail xs); perms xs = f (sort xs) where f [] = [[]]; f xs = let ys = zipWith3 (\a b c -> (a,b++c)) xs (inits xs) (drop 1 $ tails xs) in concatMap (\(y,others) -> map (y:) (f others)) ys; in sorted (perms "zyx")
03:33:27 <lambdabot>   True
03:33:33 <Axman6> > let sorted xs = and $ zipWith (<=) xs (tail xs); perms xs = f (sort xs) where f [] = [[]]; f xs = let ys = zipWith3 (\a b c -> (a,b++c)) xs (inits xs) (drop 1 $ tails xs) in concatMap (\(y,others) -> map (y:) (f others)) ys; in (perms "zyx")
03:33:35 <lambdabot>   ["xyz","xzy","yxz","yzx","zxy","zyx"]
03:34:28 <Axman6> > let sorted xs = and $ zipWith (<=) xs (tail xs); perms xs = f (sort xs) where f [] = [[]]; f xs = let ys = zipWith3 (\a b c -> (a,b++c)) xs (inits xs) (drop 1 $ tails xs) in concatMap (\(y,others) -> map (y:) (f others)) ys; in let xs = (perms "Hello, world!") in takeWhile (uncurry (<=)) $ zip xs (tail xs)
03:34:30 <lambdabot>   [(" !,Hdellloorw"," !,Hdellloowr"),(" !,Hdellloowr"," !,Hdelllorow"),(" !,H...
03:35:31 <Axman6> > let sorted xs = and $ zipWith (<=) xs (tail xs); perms xs = f (sort xs) where f [] = [[]]; f xs = let ys = zipWith3 (\a b c -> (a,b++c)) xs (inits xs) (drop 1 $ tails xs) in concatMap (\(y,others) -> map (y:) (f others)) ys; in let xs = (perms "Hello, world!") in dropWhile (uncurry (<=)) $ zip xs (tail xs)
03:35:33 <lambdabot>   [(" !,Hdelllowro"," !,Hdellloorw"),(" !,Hdellloorw"," !,Hdellloowr"),(" !,H...
03:35:50 <Axman6> > " !,Hdelllowro" <= " !,Hdellloorw"
03:35:51 <lambdabot>   False
03:35:55 <Axman6> hmm
03:36:09 <Axman6> I was sure that produced the results in lexographic order :(
03:39:51 <erus`> @hoogle [a] -> Bool
03:39:52 <lambdabot> Prelude null :: [a] -> Bool
03:39:52 <lambdabot> Data.List null :: [a] -> Bool
03:39:52 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
03:42:55 <koeien> srhb: :( already found Ctrl-u, it doesn't work in evil
03:43:19 <srhb> Remind me what that does in vim?
03:43:30 <koeien> "page up"
03:43:42 <srhb> Ah, I never use control modifiers in Vim. Felt "impure"
03:43:45 <erus`> does Either GameState GameState seem silly?
03:44:13 <koeien> erus`: it does, I think.
03:44:34 <ion> Impure?
03:44:49 <koeien> if there's a difference between Left gs and Right gs, I'd use data B = Flap | Floep and then (B, GameState)
03:44:58 <srhb> ion: In the sense that vim was great (for me) to avoid doing chords all together.
03:44:59 <hpaste_> plediii pasted “How do I make `Triple' an instance of Expressable?” at http://hpaste.org/56321
03:46:00 <quicksilver> plediii: you can't.
03:46:25 <quicksilver> plediii: "Triple a" can only be expressed if there is a Show instance for a
03:46:28 <koeien> plediii: I think Triple a is only Show if a instantiaties Show
03:46:40 <plediii> koeien: that's right
03:46:51 <koeien> so yeah, this is not possible this way
03:46:54 <quicksilver> so "Triple" alone with no mention of parameter type can't be an instance of Expressible
03:47:21 <elliott> plediii: you probably want     expression :: (Show a) => e a -> String
03:47:22 <koeien> you'd need expression :: Show a => e a -> String
03:47:29 <quicksilver> you could modify Expressible in one of two ways to make it possibl
03:47:34 <srhb> koeien: But you can just bind evil-scroll-up, it;s just not bound by default because Emacs uses that key
03:47:43 <srhb> (universal argument)
03:47:44 <koeien> srhb: I see. Thanks!
03:49:09 <srhb> koeien: Conversely, C-d is bound to evil-scroll-down because they figured that Emacs key wasn't using it very well. :-)
03:50:40 <plediii> koeien: Changing expression's type to "Show a => e a -> String" works.  But isn't that kind an extraneous restriction?  Why can't I make e a expressable without a being a Show?
03:52:19 <plediii> I guess I have to just avoid using show
03:54:04 <plediii> I would like to just use show to display triple since the code to do this is already there, but leave open the possibility that `a' isn't a Show
03:54:17 <akosch> can I use template haskell to build a single module from multiple source files?
03:55:12 <quicksilver> plediii: you can't do that.
03:55:26 <quicksilver> you can't have behaviour which works one way if there is a show instance and a different way if there isn't
03:55:34 <quicksilver> that's not compatible with the way haskell instances are open
03:58:19 <erus`> > sequence [Nothing]
03:58:20 <lambdabot>   Nothing
03:59:04 <MaskRay> why do we write the function composite f(g(x)) as f . g instead of g . f?
03:59:34 <mekeor> MaskRay: read "." as "after"
03:59:44 <sipa> and it is a common symbol in maths
04:00:04 <koeien> because we write function application as f(x) in mathematics, basically.
04:00:10 <koeien> you could also ask why don't we write x(f)
04:00:17 <mm_freak> i have a functor-like pattern that applies to Either-like types:  mapLeft :: MapLeft s => (e' -> e) -> s e' a -> s e a
04:00:18 <plat0> You can also read "." as "of"
04:00:21 <mm_freak> is there a name for this pattern?
04:00:21 <koeien> which is due to historial reasons
04:00:22 <MaskRay> i know, just want to know the slightest advantage of the former over the latter
04:00:22 <cmasseraf> because it's the mathmatical represation... (f . g) (x) means that you apply f after applying g
04:00:28 <MaskRay> in math
04:00:40 <mm_freak> and is it defined somewhere?
04:01:06 <koeien> because g is "to the right" in both cases
04:01:18 <estan> opqdonut: i'm scratching my head here, i don't see how your suggestion of "ndiff = length . filter (/=) $ zip s1 s2" could work, the zip will give me a list of tuples, but then (=/) would have to be a function taking a tuple and returning a bool, wouldn't it?
04:01:38 <koeien> if you define a multiplication on functions, you can leave out the dot and it becomes (fg)x = f(gx)
04:01:57 <koeien> estan: you'd need to uncurry the (/=)
04:01:58 <opqdonut> :t length . filter (uncurry (/=))  -- sorry estan
04:01:59 <lambdabot> forall a. (Eq a) => [(a, a)] -> Int
04:02:22 <estan> koeien opqdonut: ah. *reads up on uncurry*. thanks.
04:02:35 <opqdonut> another option is: "length . filter id $ zipWith (/=) s1 s2"
04:02:39 <opqdonut> :t uncurry
04:02:40 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:02:46 <MaskRay> mekeor: a bit 'wise after the event'. would 'g then f' be more natural?
04:04:31 <mm_freak> ok, apparently what i'm looking for is a bifunctor
04:05:00 <erus`> [a] -> [b] -> [(a, b)]
04:05:08 <erus`> @hoogle [a] -> [b] -> [(a, b)]
04:05:09 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
04:05:09 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
04:05:09 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
04:05:14 <plat0> I believe category theorists use ";" for after.  g . f = f ; g
04:05:36 <koeien> sometimes, yes
04:06:55 <MaskRay> koeien: thanks
04:10:42 <estan> opqdonut: hm. in that last example of yours, should "id" be "((==) True)" ?
04:11:49 <merijn> estan: No, but the list is already a set of booleans
04:12:02 <merijn> and comparing a bool with a bool is redundant
04:12:05 <elliott> estan: There is no difference.
04:12:09 <elliott> > True == True == True == True
04:12:10 <lambdabot>   Precedence parsing error
04:12:10 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
04:12:12 <estan> opqdonut: (since the zipWith gives me a list of Bool, and i want to filter out the faalse ones)
04:12:13 <elliott> Aw.
04:12:17 <elliott> estan:
04:12:19 <elliott> > id True
04:12:20 <lambdabot>   True
04:12:21 <elliott> > id False
04:12:22 <lambdabot>   False
04:12:24 <elliott> > True == True
04:12:25 <lambdabot>   True
04:12:26 <elliott> > False == True
04:12:27 <lambdabot>   False
04:12:38 <estan> ah. forgive me i didn't know "id" was a function ;)
04:12:38 <frerich> estan: It's actually equivalent; if you write 'a == True' (you're comparing a boolean with True, and this comparison yields a boolean) you might just as well just use 'a'.
04:12:44 <elliott> estan: id is just \x -> x :)
04:12:54 <estan> right i get that now. thanks!
04:17:25 <estan> quicksilver: btw i
04:17:39 <estan> 'm still interested in why you think the nested where isn't necessary.
04:17:47 <estan> (sorry for the newline)
04:17:57 <erus`> @hoogle swap
04:17:57 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
04:17:57 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
04:17:57 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
04:18:06 <estan> do you mean because i might as well put that helper function outside?
04:19:45 <Ken`> the carrier of a final coalgebra is not necessarily a final object - true?
04:21:33 <quicksilver> estan: no.
04:21:41 <quicksilver> estan: you just put it at the same level
04:21:48 <quicksilver> estan: things in the same "level" of where can refer to each other
04:22:06 <quicksilver> just like top-level definitions can refer to each other
04:22:14 <estan> quicksilver: damn you're right. *facepalm*.
04:27:14 <erus`> does this exist in the platform:       swapItem a b = foldr (\c d -> if a == c then b:d else c:d) []
04:28:16 <koeien> how is that not a map?
04:28:40 <erus`> oh yeah...
04:29:18 <koeien> let a ? b = \c x -> if a == x then b else c in map (2 ? 3 4) [1..5]
04:29:19 <koeien> > let a ? b = \c x -> if a == x then b else c in map (2 ? 3 4) [1..5]
04:29:20 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
04:29:20 <lambdabot>    arising from a use of `...
04:30:10 <erus`> @pl \c -> if a == c then b else c
04:30:10 <lambdabot> flip if' b =<< (a ==)
04:31:00 <koeien> > let a --> b = \x -> if a == x then b else x in map (2 --> 3) [1..5]
04:31:01 <lambdabot>   [1,3,3,4,5]
05:19:54 <sm> morning all
05:20:19 <sm> I wonder why the constraint conduit==0.0.* doesn't accept conduit-0.0.1.1
05:20:56 <elliott> It doesn't? Are you sure?
05:22:00 <sm> well, that's how it appears when I fail to cabal install xml-conduit --constraint 'conduit==0.0.1.1'
05:22:20 <sm> it insists on using older conduit
05:22:46 * elliott blames cabal's dependency resolution algorithm
05:25:53 <sm> actually, that was a while ago and now I can't reproduce. never mind
05:26:26 <hpc> sm: sounds like you should see a doctor ;)
05:28:21 <sm> ack
05:41:11 <sinelaw> @pl x -> if x then 1 else 0
05:41:11 <lambdabot> (line 1, column 3):
05:41:11 <lambdabot> unexpected ">" or "-"
05:41:11 <lambdabot> expecting variable, "(", operator or end of input
05:41:21 <sinelaw> @pl \x -> if x then 1 else 0
05:41:21 <lambdabot> flip (flip if' 1) 0
05:41:52 <Guest22148> no way it has to be that complicated...
05:41:56 <elliott> fromEnum
05:42:03 <elliott> > map fromEnum [False, True]
05:42:04 <lambdabot>   [0,1]
05:42:19 <Guest22148> point less, but just as long :)
05:43:31 <sinelaw> oh, wait... yip! i wanted fromEnum
05:43:37 <sinelaw> silly me
05:43:49 <sinelaw> @msg lambdabot fromEnum True
05:43:49 <lambdabot> Not enough privileges
05:51:35 <mm_freak> given a Category f, is it unsound for it to be a Bifunctor?
05:52:00 <mm_freak> in haskell that is, not in CT
05:52:39 <mm_freak> and a Bifunctor as defined in edwardk's 'bifunctors' package
05:59:23 <hpaste_> Itkovian pasted “type inference” at http://hpaste.org/56324
05:59:35 <Itkovian> any suggestions?
06:00:13 <Itkovian> nevermind
06:00:15 <Itkovian> aargh
06:00:19 <koeien> wild guess after 2 seconds: you might need rank-2 types
06:00:38 <Itkovian> nah, I left an argument in there that should have been removed
06:00:47 <koeien> Ok.
06:00:54 * Itkovian goes to hide now
06:01:05 <koeien> np, these messages are sometimes confusing :)
06:05:50 <PDani> hi
06:07:25 <_oz_> hi PDani
06:08:18 <PDani> i try to parse a datetime string and get a unix timestamp from it. i currently do it this way: parseTimestamp :: String -> UTCTime ; parseTimestamp = fromJust . (parseTime defaultTimeLocale "%F %X"), and then i use read . (formatTime defaultTimeLocale "%s") function for getting the integer value of unix timestamp. is there a direct way to parse into unix timestamp avoiding the back-and-forth string conversions?
06:09:22 <hpc> PDani: UTCTime might have a Num instance
06:09:44 <Botje> PDani: there's a utcTimeToPOSIXSeconds in Data.Time.Clock.POSIX
06:09:51 <elliott> hpc: it doesn't
06:10:02 <hpc> @hoogle utcTimeToPOSIXSeconds
06:10:02 <PDani> Botje, thx
06:10:02 <elliott> hpc: (what's 1 jan 1970 + 2 mar 1983?)
06:10:03 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
06:10:11 <hpc> elliott: five
06:10:13 <hpc> ;)
06:10:17 <elliott> i knew it
06:10:55 <Botje> elliott: in perl it's three.
06:11:36 <hpc> Botje: holy crap, it is
06:11:55 <PDani> :))
06:12:21 <elliott> hehe
06:16:01 * hackagebot safeint 0.5.2 - overflow-checked Int type  http://hackage.haskell.org/package/safeint-0.5.2 (AndresLoeh)
06:27:01 <JoeyA> Hmm, looks like you can't safely write to a connection while waiting for input when using Network.TLS .
06:31:40 <clsmith> is there a name for a lambda calculus which has types which are themselves lambda calculus, all the way up until you can simply type a higher order? >.> if that makes sense
06:32:51 <Saizan> Pure Type System , iiuc
06:33:14 <ziman> btw, why is it called `pure'?
06:35:25 <Saizan> because it's type systems all the way up :)
06:35:51 <clsmith> ah yes, that seems to be what i'm looking for. thanks. :)
06:36:38 <x_man> Saizan
06:36:48 <x_man> what type system?
06:38:12 <Saizan> http://en.wikipedia.org/wiki/Pure_type_system
06:40:12 <byorgey> More accurately, there are some pure type systems with this kind of "infinite hierarchy", not all do
06:40:38 <byorgey> clsmith: also, Coq and Agda are programming languages with exactly such type systems
06:43:07 <ocharles> man, conduits rock
06:43:14 <ocharles> <3
06:43:14 * elliott was assuming clsmith meant a system where (\x. x) has type (\x. x), but I guess not
06:43:43 <^^thief^^> does anyone have 5 mins for a quick code review of the start of an assignment im working on - just to know if im on the right path as far as structure/functional style goes
06:43:50 <elliott> (the problem of course being that (\x. x) and (\x y. x) have different types, so your kinds are all screwy... but iirc automath worked in this way)
06:44:47 <koeien> ^^thief^^: sure, paste it!
06:44:48 <koeien> @hpaste
06:44:48 <lambdabot> Haskell pastebin: http://hpaste.org/
06:44:51 <roconnor> What type of structure is the Data.Map implementation?
06:45:02 <Saizan> size-balanced binary tree
06:45:09 <roconnor> ya but which one?
06:45:15 <roconnor> AVL, 2-3, red-black?
06:45:22 <quicksilver> none of the above
06:45:25 <roconnor> heh
06:45:31 <quicksilver> directly balanced by storing size at each node
06:45:55 <clsmith> elliott: no, i was thinking that since simply-typed lambda is strongly normalising, and the addition of recursive types can make it non-normalising, you could define (\x.xx)(\x.xx) by defining the type of each as a type-level Y combinator, or something (vague)
06:45:55 <quicksilver> I think it's not a particularly clever structure
06:45:56 <^^thief^^> koeien - thanks! is it ok if i pm you a link to a zip? it spans a few files (the structure was part of what im unsure of..)
06:45:58 <danr> i think it's documented in the source code for Data.Map
06:46:00 <quicksilver> AVL or red/back would be better
06:46:10 <roconnor> how does storing a size at each node balance the tree?
06:46:17 <quicksilver> although it's asymptotically fine
06:46:33 <koeien> ^^thief^^: no problem, although i might not have too much time
06:47:10 <Saizan> roconnor: the operations look at the size to decide how to build the tree
06:47:12 <koeien> roconnor: i think it's explained in the paper.
06:47:24 <koeien> that's linked at Data.Map
06:49:29 <PDani> i need a conversion function: NominalDiffTime -> Int
06:49:43 <PDani> and i can't find it :)
06:49:56 <roconnor> PDani: what sort of Int are you looking for?
06:50:21 <PDani> Prelude.Int
06:50:35 <quicksilver> PDani: try "round"
06:50:38 <PDani> thx
06:50:43 <roconnor> PDani: const 0 :: NominalDiffTime -> Int
06:50:55 <elliott> roconnor: ITYM unsafeCoerce.
06:50:56 <quicksilver> NominalDiffTime is a Num, you can use normal Num functions on it
06:51:02 <elliott> Yours never produces different values!
06:51:18 <quicksilver> :t round
06:51:19 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:51:31 <quicksilver> more precisely it's RealFrac which is why you can use 'round'
06:51:33 <elliott> to be precise, it's a RealFrac :)
06:51:34 <roconnor> PDani: sorry I should have asked what value of Int are you looking for
06:51:35 <elliott> snap
06:51:49 <koeien> the unit is seconds.
06:52:03 <PDani> thx very much
06:52:11 <koeien> so "round" will reduce your precision, of course
06:52:25 <roconnor> the fact that you can multiply NominalDiffTimes with itself is disheartening
06:52:45 <x_man> disconnected
06:54:42 <quicksilver> well it's not *massively* disheartening, roconnor, in the grand scale of things wrong with haskell's number system :)
06:54:57 <quicksilver> it's just another small example of the hierarchy not quite being expressive enough.
06:55:04 <roconnor> quicksilver koeien: thanks.  This paper suggests that the reason AVL isn't used is because storing the size allows balancing, but you get a constant time size operation for free.
06:55:21 <quicksilver> right.
06:55:36 <quicksilver> where "to free" means for no asymptotic cost
06:55:52 <roconnor> where "for free" means no additional space requirements
06:56:08 <quicksilver> folklore has it that the balancing in these size-balanced tree has a substantially worse constant factor than RB or AVL
06:56:13 <roconnor> actually it is more like the balancing comes for free given a constant time size operation.
06:56:26 <roconnor> quicksilver: interesting
06:56:43 <quicksilver> but I've no idea how true that is or how much it depends on the exact operational semantics/cost of your language/compiler.
06:57:24 <quicksilver> I know somebody (bulat?) wrote an AVL tree he felt should replace Data.Map's size balanced tree
06:57:27 <quicksilver> but it never happened
06:58:06 <quicksilver> roconnor: http://www.haskell.org/pipermail/libraries/2006-March/004960.html is part of a long protracted discussion
06:59:00 <quicksilver> it was adrian hey, not bulat
07:09:43 <Silvah> Any good example of how to use Parsec with its "token parser" feature?
07:12:00 <elliott> Silvah: the original Parsec docs cover it quite well IIRC: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
07:12:25 <elliott> hmm, no, seems they don't
07:12:30 <elliott> http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements might be helpful
07:22:53 <Silvah> elliott: thanks.
07:23:00 <Silvah> What was the type of main?
07:23:29 <Silvah> IO anything?
07:28:49 <roconnor> Silvah: IO anything
07:31:04 <mrcarrot> apparently it is possible in an easy way to have root mirrored... i founf it out from undeadly
07:31:24 <mrcarrot> but try to find that in the documentation.....
07:32:18 <mrcarrot> wrong channel
07:56:00 <elliott> Silvah: Yes.
07:56:53 <nexion> is it possible to pattern-match lazy bytestrings?
07:59:55 <parcs`> no
08:00:06 <parcs`> use ==
08:00:42 <elliott> (Technically yes if you import Char8, but don't.)
08:01:09 <nexion> elliott, how? I'm trying to understand how pattern-matching works with different types
08:01:12 * hackagebot delta-h 0.0.2 - Online entropy-based model of lexical category acquisition.  http://hackage.haskell.org/package/delta-h-0.0.2 (GrzegorzChrupala)
08:01:48 <shachaf> elliott: Also technically yes if you import Internal. :-)
08:02:20 <elliott> nexion: Importing Char8 uses a GHC extension thing called OverloadedStrings that basically just makes the pattern matches end up as (==) under the hood -- but Char8 is evil because it lets you pretend ByteStrings are Unicode strings, which they aren't, they're sequences of bytes.
08:02:27 <shachaf> nexion: In the general case, pattern matching is structual, i.e., it lets you compare ADT structure.
08:02:39 <elliott> Pattern-matching is just done on constructors, but also e.g. a literal like "42" will match any Num.
08:02:59 <elliott> OverloadedStrings just generalises that to any IsString, and wraps each literal string in a fromString (compare Num and fromInteger)
08:03:10 <elliott> But none of that probably helps you understand what you want to, so what shachaf said :)
08:03:16 <shachaf> nexion: In some very specific cases -- using Num and sometimes using pseudo-string classes (which ByteString isn't, but there's a module to let you pretend that it is) -- GHC will translate something like "f 5 = ..." to "f x | x == 5 = ..."
08:03:32 <nexion> so Char8 implicitly enables OverloadedStrings in my entire source file?
08:03:38 <shachaf> But in general this is nothing more than convenient syntactic sugar, and you shouldn't rely on it.
08:03:47 <shachaf> nexion: No, you also have to enable the extension yourself.
08:03:51 <shachaf> And *also*, just don't use Char8.
08:04:00 <shachaf> Char8 is a broken module for broken people.
08:04:01 <nexion> that brings me to my next question
08:04:12 <nexion> I understand that Char8 will cripple unicode
08:04:21 <elliott> It's not about "crippling Unicode".
08:04:34 <elliott> It's like pretending a Bool is an Int because you can encode some values of Ints as Bools.
08:05:41 <ChristianS> Char8 is fine if your bytestring is just ascii oder latin1
08:05:48 <shachaf> ChristianS: No. It's not.
08:06:02 <shachaf> ChristianS: *Especially* not Latin1. That's just completely wrong.
08:06:30 <shachaf> A ByteString represents a sequence of bytes, not of characters.
08:06:31 <nexion> so if I have a lazy bytestring I got as output from the regex match and I need to make sure the string is "POST"
08:06:42 <nexion> how could I achieve that without Char8?
08:07:18 <elliott> > map ord "POST"
08:07:19 <lambdabot>   [80,79,83,84]
08:07:20 <shachaf> nexion: foo x | x == postString = ...
08:07:34 <elliott> nexion: Assuming you mean ASCII-encoded, then what shachaf said, where postString = B.pack [80,79,83,84].
08:07:35 <shachaf> Where postString = B.pack [80,79,83,84]
08:07:43 <ChristianS> "More specifically these byte strings are taken to be in the subset of Unicode covered by code points 0-255. This covers Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls." http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Char8.html
08:07:43 <mauke> terrible
08:07:47 <Silvah> elliott: don't tell me that you don't miss Int1.
08:07:55 <elliott> nexion: postString = B.pack $ map (fromIntegral . ord) "POST" might also be acceptable depending on how loose your morals are.
08:08:14 <shachaf> Or postString = encodeInSomeWay "POST" or whatever, depending on how you want to encode things.
08:08:16 <mm_freak> nexion: as a side note, the ByteString types from Data.ByteString.Lazy and Data.ByteString.Lazy.Char8 are the same…  you can use functions from both modules
08:09:04 <shachaf> ChristianS: Well, that's just wrong.
08:09:21 <mauke> shachaf: why is that wrong?
08:09:37 <nexion> elliott, how will that differ from Char8.pack?
08:09:42 <shachaf> mauke: Because I misread it.
08:09:49 <mm_freak> nexion: it won't
08:09:54 <shachaf> OK, it's a correct encoding for that subset of Unicode.
08:10:03 <elliott> nexion: It'll continue your shachaf and elliott support contract throughout 2012.
08:10:03 <shachaf> nexion: The real point is that you should understand the difference between ByteString and Text and String and what actual text is and bytes and characters and so on before using ByteString.
08:10:07 <elliott> Also that.
08:10:28 <mauke> in latin1 text is bytes
08:10:41 <elliott> Only if you conflate the character set and encoding.
08:10:58 <mauke> I do
08:11:03 <Sgeo> nexion, have you seen Text?
08:11:10 <nexion> in my case, the ByteString is expected to be ascii
08:11:28 <elliott> mauke: That's your problem.
08:11:29 <nexion> Sgeo, yeah, I use that for the Unicode sections of the stream
08:11:53 <nexion> to provide some details, I'm doing some very basic parsing of HTTP requests
08:12:10 <nexion> the payload can contain UTF-8, so I convert those into Text
08:12:21 <mm_freak> > B.pack [65, 66, 67] == Bc.pack "ABC"
08:12:21 <mm_freak> True
08:12:22 <lambdabot>   Not in scope: `B.pack'Not in scope: `Bc.pack'
08:12:23 <elliott> nexion: Why not just treat the whole stream as Text?
08:12:28 <elliott> "POST" is perfectly valid UTF-8.
08:12:35 <elliott> If you're worrying about performance concerns, don't; Text is heavily optimised.
08:12:55 <nexion> that would also work
08:13:10 <nexion> and String -> Text is clean
08:13:11 <shachaf> elliott: Hah.
08:13:12 <nexion> noted
08:13:31 <ChristianS> if your bytestring is utf8-encoded, Data.ByteString.UTF8 from the utf8-string package offers some functions that handle arbitrary Char's correctly without crippling them
08:14:16 <ChristianS> but it's very limited. Data.Text offers much more, but for UTF-8 data it'll probably be slower, because it uses UTF-16 internally
08:14:38 <nexion> is there PCRE regex matching support for Text?
08:14:51 <mauke> I don't care how "heavily optimised" Text is; it's got stupidity built in
08:15:45 <elliott> mauke: What stupidity?
08:16:01 <mauke> UTF-16
08:16:16 <nexion> http://hackage.haskell.org/package/regex-pcre <-- I see it has a String variant, but I assume converting among Text and String is O(n)
08:16:28 <nexion> and I was told String is slow
08:16:31 <elliott> nexion: regex matching is also O(n)
08:17:05 <elliott> The main problem here is that String is memory-hungry. If you're only matching reasonably-sized strings, it'll be fine.
08:17:08 <nexion> although not theoretically, O(n) is better than O(2n) :)
08:17:16 <c_wraith> it's actually at least O(n), depending on the exact form of the regex...  mostly because PCRE isn't actually regular.
08:17:35 <elliott> nexion: Please don't use big-O notation to express concepts like that. :(
08:17:41 <nexion> lol
08:17:50 <c_wraith> PCRE can get as bad as exponential. :)
08:17:57 <Sgeo> What is correct notation to express the concept of one having a larger constant factor than the other?
08:18:00 <elliott> nexion: Anyway, the overhead will be almost certainly be negligible.
08:18:06 <elliott> Profile before optimising, etc.
08:18:21 <nexion> yeah, my strings are relatively small
08:23:14 <Sgeo> Are there times that it makes sense to use arrow syntax with a monad?
08:24:32 <cmccann> Sgeo, that's something of an apples-to-oranges comparison
08:24:56 <Sgeo> ..How so?
08:25:04 <Sgeo> All monads are arrows
08:25:22 <parcs`> how is Maybe an arrow?
08:25:36 <cmccann> Monad and Arrow have different kinds
08:25:41 <dolio> All Kleisli arrows are arrows.
08:25:50 <dolio> Not all monads.
08:25:55 <cheater> all arrows are arrows
08:26:02 <cmccann> so a Monad instance can't be an Arrow instance
08:26:28 <parcs`> @src Kleisli
08:26:28 <lambdabot> Source not found. My brain just exploded
08:26:49 <cheater> that would have been cool except lambdabort has no brain
08:26:56 <cmccann> heh
08:27:02 <ben_m> "My brain just exploded". I have that everytime people talk about Arrows and stuff in here
08:27:20 <cheater> no that's just your brain leaking out of your ear after turning to cream cheese
08:27:28 <mauke> I used to be a haskell programmer like you
08:27:36 <parcs`> newtype Kleisi m a b = Kleisli (a -> m b)
08:27:38 <cmccann> Sgeo, anyway, are you thinking of Kleisli arrows? e.g. functions with a type like (a -> m b)
08:27:43 <cheater> mauke: what happen?
08:27:47 <Sgeo> Yes, I think
08:27:51 <parcs`> instance Monad m => Arrow (Kleisli m)
08:27:57 <ben_m> cheater, he took an arrow in the knee
08:28:04 <cheater> heh.
08:28:16 <cheater> his space suit turned into a burrito?
08:28:38 <cmccann> so yes, using arrow notation for Kleisli arrows makes sense, because they're arrows
08:29:46 <ben_m> "The Haskell newtype declaration introduces a new type isomorphic to an existing one, where the constructor names the isomorphism."
08:29:47 <cmccann> Kleisli arrows are also monads, but not the same monad as the one they're defined from
08:29:52 <ben_m> Explain to me like I'm 5, please? :(
08:30:28 <mauke> ben_m: it looks like a different type on the outside, but on the inside it's the same
08:30:30 <Sgeo> ben_m, the type defined by a newtype is perfectly convertible
08:30:33 <Sgeo> In both directions
08:30:34 <cmccann> i.e., Kleisli m a b is isomorphic to ReaderT a m b
08:30:50 <quicksilver> "Kleisli m a" is the same monad as ReaderT a M, right, cmccann ?
08:30:59 <quicksilver> oh, you just said that
08:31:13 <cmccann> quicksilver, yes and yes :]
08:31:14 <elliott> Hey guys, is Kleisli m a ~ ReaderT a m?
08:31:38 <ben_m> Sgeo, convertible to what? :/
08:31:54 <Sgeo> newtype StringWrapper = StringWrapper String
08:32:09 <Sgeo> I can convert String to StringWrapper and StringWrapper to String
08:32:15 <ben_m> ah
08:32:21 <Sgeo> StringWrapper _|_ is not allowed
08:32:29 <mauke> totally is
08:32:30 <Sgeo> Err, well, StringWrapper _|_ = _|_
08:33:18 <Sgeo> So you don't have a value (StringWrapper _|_) which cannot be converted to a String
08:33:54 <ben_m> I see ... where would that be useful, for example?
08:34:04 <parcs`> elliott: i think so, can anyone confirm?
08:34:46 <elliott> I guess it probably isn't if nobody's speaking up!
08:34:53 <byorgey> ben_m: it is useful where you want something that "really is" a String, but you want the compiler to help you keep it separate
08:35:34 <byorgey> for example, you might have  newtype ID = ID String
08:35:48 <byorgey> you don't want to be able to pass an ID where a String is expected, or vice versa
08:35:57 <Sgeo> http://codepad.org/WhWXqRMj
08:35:59 <byorgey> but underneath IDs are just Strings.
08:36:00 <cmccann> pop quiz: if you have "x = _|_ :: StringWrapper" and "foo (StringWrapper s) = s", what happens if you do "foo x"?
08:36:18 <Sgeo> Bad example
08:36:41 <elliott> cmccann: For a second there I thought that was an actual trick question and thought about it intently.
08:36:48 <elliott> I'm disappointed.
08:37:05 <Sgeo> http://codepad.org/WGaMS533 wat.
08:37:13 <cmccann> no, the trick question is if you have "newtype T = T T" and pattern match on that
08:37:15 <parcs`> cmccann: would be better if foo (StringWrapper s) = ()
08:37:23 <elliott> Sgeo: f _ = "foo"
08:37:26 <cmccann> parcs`, ah, probably
08:37:29 <elliott> Sgeo: What's f _|_?
08:37:40 <parcs`> > case undefined of ZipList _ -> ()
08:37:41 <lambdabot>   ()
08:37:44 <elliott> parcs`: Right, that's the surprising part.
08:38:18 * cmccann sabotaged his pop quiz :[
08:38:44 <Sgeo> elliott, o.O
08:38:55 <Sgeo> But I'm pattern matching...
08:39:07 <Sgeo> And the pattern isn't a simple variable
08:39:12 <Sgeo> Or _
08:39:32 <Sgeo> Maybe with @ and seq
08:40:24 <Sgeo> Got it
08:40:30 <Sgeo> http://codepad.org/OhO5zOXs vs http://codepad.org/vTSAIQSO
08:40:55 <ben_m> Wait, what's _|_ again?
08:41:15 <Sgeo> bottom
08:41:29 <Sgeo> Fits any type.
08:41:44 <Sgeo> error somestring and undefined are easy ways to produce bottom in Haskell code
08:41:50 <Sgeo> Infinite loops are also bottom
08:43:01 <ben_m> Ah okay, got confused by newtype Foo = _|_, I thought you meant alternative Constructors
08:46:23 <parcs`> it's the ascii representation of ⊥
08:53:13 <Sgeo> What is hpc?
08:53:29 <Sgeo> Oh, code coverage stuff
08:56:02 <Enigmagic> too bad it's called hpc
08:57:06 <funktronic> Enigmagic: hpc is a fine name for things
08:58:32 <Enigmagic> funktronic: i'm going to write a preprocessor named 'ghc', for it will implement the ghc extensions for ghc
09:02:21 <xplat> i'm going to build a particle accelerator called 'kgb', because it will be a step ahead of the lhc
09:04:32 <Enigmagic> :)
09:11:04 <elliott> <Sgeo> But I'm pattern matching...
09:11:15 <elliott> Sgeo: Yes, and (C a) is identical to a modulo types where C is a newtype constructor.
09:11:39 <elliott> f :: String -> (); f _ = x; g :: StringWrapper -> (); g (StringWrapper _) = x -- what could the difference possibly be?
09:24:42 <Eduard_Munteanu> > map succ "kgb"
09:24:43 <lambdabot>   "lhc"
09:24:45 <Eduard_Munteanu> Heh.
09:26:21 * hackagebot total-map 0.0.1 - Finitely represented /total/ maps  http://hackage.haskell.org/package/total-map-0.0.1 (ConalElliott)
09:26:24 * hackagebot total-map 0.0.2 - Finitely represented /total/ maps  http://hackage.haskell.org/package/total-map-0.0.2 (ConalElliott)
09:27:51 <Sgeo> Suppose I use a function, but its order of arguments is wrong and there's more than 2 arguments.
09:28:06 <Sgeo> Are there ways to fix that other than either a lambda or having my own local definition?
09:28:23 <Sgeo> (i.o.w I think, pointfree argument switching)
09:29:41 <cmccann> Sgeo, unless you want something like https://github.com/isomorphism/typewriter/blob/master/Data/Typewriter/Variadic/Flip.hs probably not
09:30:39 <cmccann> I'd probably use a lambda if it's 3 or maybe 4 arguments, otherwise a local definition
09:35:59 <Sgeo> Is getChanContents as evil as lazy I/O in general, or does that particular use of lazy I/O not have issues/
09:36:35 <cmccann> that depends on which kind of issues you're talking about
09:36:48 <Sgeo> The main objections people have to lazy I/O
09:37:04 <lispy> in cabal if you have a test section can you use an if-statement inside that section?  I'm getting errors that make me think no
09:37:16 <lispy> also, c2hs is barfing on this valid C header
09:37:37 <cmccann> Sgeo, there are at least three distinct complaints I know of
09:38:41 <cmccann> that said, I'd be extra suspicious of lazy IO when concurrency is involved
09:39:07 <lispy> here we go: http://www.haskell.org/pipermail/cabal-devel/2011-March/007316.html
09:39:10 <lispy> seems to be my bug
09:39:17 <burp> does anyone know why ghc in archlinux is stuck at 7.0.3?
09:39:54 <cmccann> Sgeo, but beyond that I'd probably use TChan unless I had a clear reason not to
09:40:09 * Sgeo searches for TChan
09:40:14 <Makoryu> burp: Wasn't there some kind of compatibility issue with 7.0.4 on a lot of systems
09:40:22 <Sgeo> Oh, it's the STM version
09:40:24 <Makoryu> I don't remember what it was exactly
09:40:25 <cmccann> yeah
09:40:33 <burp> hmm, ok
09:40:39 <Sgeo> I don't think I particularly... need it
09:40:42 <lispy> burp: because dons stopped being the package maintainer?
09:41:20 <burp> sounds like a reason
09:41:47 <cmccann> Sgeo, perhaps, but STM lets you not worry about a lot of concurrency issues
09:41:50 <Sgeo> Although considering I was thinking of making an MVar Chan, maybe I should use TChans
09:42:09 <Sgeo> Oh, I was considering making an MVar Chan because I wanted to be able to write a peek function
09:42:43 <cmccann> I think STM's benefits in simplifying concurrency are sufficient to use it by default, personally
09:43:50 <drdo> I'm puzzled, how do i tell wai-handler-fastcgi what address/port to listen on?
09:43:51 * Sgeo wants to be able to conveniently filter on these things, though
09:43:54 <Sgeo> Filter and map
09:44:08 <koeien> drdo: FastCGI doesn't listen afaik
09:44:19 <koeien> you need a webserver that listens and uses your fastcgi backend
09:44:21 <koeien> e.g. apache
09:44:39 <drdo> koeien: Surely the web server needs to connect to my fastcgi server?
09:44:57 <cmccann> Sgeo, as in filter/map on the output sequence from the channel?
09:45:03 <Sgeo> cmccann, yes
09:45:29 <koeien> yes, it does this perhaps by standard input?
09:45:49 <drdo> koeien: What standard input?
09:46:10 <cmccann> Sgeo, you could probably make a simple wrapper that would allow that
09:46:13 <koeien> perhaps i'm talking nonsense here.
09:46:35 <cmccann> you wouldn't be able to use map and filter themselves, but you could implement something equivalent
09:46:58 <drdo> From what i understand, a fastcgi is supposed to get request from the web server and reply with the content
09:47:04 <drdo> *fastcgi server
09:47:05 <drdo> *requests
09:47:25 <cmccann> Sgeo, I can write an example for you if you like
09:48:41 <koeien> drdo: i think fastcgi communicates over standard input/output of the process
09:48:49 <koeien> i'm not positive on that
09:48:53 <drdo> koeien: How can that happen over the network?
09:49:09 <Sgeo> Is there any typeclass for filterable things?
09:49:11 <koeien> it doesn't. e.g. apache runs your process and talks via its standard input/output
09:49:28 <drdo> but on the fastcgi site they say i can do that
09:49:34 <Sgeo> @hoogle (a -> Bool) -> f a -> f a
09:49:34 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
09:49:35 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
09:49:35 <lambdabot> Data.Sequence dropWhileL :: (a -> Bool) -> Seq a -> Seq a
09:49:47 <cmccann> Sgeo, not that I'm aware of. I suspect that it wouldn't work well.
09:49:55 <drdo> and on configuration files for web servers i'm supposed to tell it what to connect to
09:49:56 <koeien> drdo: although, again, i'm not positive. you could ask #yesod
09:51:07 <Sgeo> http://lambda.haskell.org/platform/doc/current/packages/stm-2.2.0.1/doc/html/Control-Concurrent-STM-TMVar.html I don't see withTMVar in here
09:52:02 <parcs`> burp: it was kept in sync with the HP, but the maintainers changed their mind and now they're waiting on the 7.4 release to update the ghc in [extra]. note that ghc-7.2 is in the [testing] repository which you can install without having to subscribe to the [testing] repo
09:52:24 <cmccann> Sgeo, would withTMVar really be useful?
09:52:32 <parcs`> haskell on arch linux is a mess imo
09:53:08 <mekeor> how can i write `function element list = Just $ element:list' pointfree ?
09:53:10 <drdo> parcs`: I install ghc and cabal-install and then just use it
09:53:14 <burp> parcs`: I see
09:53:25 <koeien> @pl \x xs -> Just (x:xs)
09:53:26 <lambdabot> (Just .) . (:)
09:53:31 <cheater> parcs`: same on ubuntu
09:53:41 <cheater> parcs`: i wouldn't say the issue is on the side of the linux repos though.
09:54:25 <mekeor> koeien: oh, yea. i forgot that feature... thanks.   but why "(Just .)" and not just "Just" ? i gont understand it.
09:54:31 <cmccann> Sgeo, I'd think that anything withMVar does would be either superfluous or automatic with TMVar
09:54:47 * Sgeo is currently using an MVar () as a global lock
09:54:50 <koeien> what's the type of  Just . (:) ?
09:54:53 <Makoryu> mekeor: Basically, because (:) takes two arguments
09:54:54 <koeien> :t Just . (:)
09:54:55 <lambdabot> forall a. a -> Maybe ([a] -> [a])
09:55:05 <mekeor> Makoryu: ah.
09:55:11 <koeien> Makoryu: yup
09:55:15 <mekeor> okay
09:55:20 <mekeor> thanks once more =)
09:55:33 * mekeor loves the haskell-community =]
09:55:43 <cmccann> Sgeo, well, why do you need a lock?
09:55:44 * mekeor .. that is, YOU
09:55:50 <koeien> oh yes #haskell is totally awesome :)
09:56:32 <Sgeo> cmccann, because the C library I'm wrapping is in no way threadsafe, and the big reason it's not is because the stateful variables it holds onto can change when an event from outside comes in
09:56:48 <Sgeo> Wait, that's... not quite accurate
09:57:08 <dgpratt> indeed, #haskell is awesome, but I gotta call out lambdabot as a total know-it-all jerk
09:57:15 <Sgeo> But an event can only come in when the stepping function is called
09:57:20 <mekeor> dgpratt: hahahah
09:57:49 <cmccann> Sgeo, would it work to let a single thread do all the interaction with the C library and communicate with other Haskell threads on its behalf?
09:58:45 <Sgeo> cmccann, it might, but I haven't thought that plan through too much. I don't think it would eliminate the need for the lock
10:00:48 <cmccann> Sgeo, only direct interaction with the C library should absolutely require locks
10:01:31 <Sgeo> Surely grabbing the values of the global variables to put them in some data structure counts?
10:02:32 <cmccann> Sgeo, reading the global variables counts, which is why I'm saying to limit all that to one thread or such
10:02:36 <cmccann> if that works, of course
10:02:44 * cmccann doesn't know enough about what you're doing to say for sure
10:03:02 <JoeyA> Is liftIO . throwIO safe?
10:03:19 <Sgeo> :t liftIO . throwIO
10:03:20 <lambdabot> Not in scope: `throwIO'
10:04:31 <JoeyA> This throws an exception in a monad supporting MonadIO.
10:05:14 <JoeyA> It seems like the "correct" thing to do would be to have the overlying monad provide a way to lift 'throw'.
10:05:51 <Cody_> :t read
10:05:51 <lambdabot> forall a. (Read a) => String -> a
10:05:57 <Cody_> > read "5"
10:05:58 <lambdabot>   *Exception: Prelude.read: no parse
10:06:01 <Cody_> > read "5" + 4
10:06:02 <lambdabot>   9
10:06:04 <JoeyA> I'm just wondering if there's a case where (ab)using MonadIO to throw an exception would be dangerous.
10:06:09 <koeien> Cody_: yeah defaulting.
10:06:19 <koeien> > read "5" :: Integer
10:06:20 <lambdabot>   5
10:06:26 <Cody_> Why can't I read just "5"
10:06:32 <Cody_> I see
10:06:41 <koeien> Haskell cannot guess which read to call
10:06:42 <Cody_> > read "5" + 0
10:06:42 <JoeyA> > read ()
10:06:43 <lambdabot>   5
10:06:43 <lambdabot>   Couldn't match expected type `GHC.Base.String'
10:06:43 <lambdabot>         against inferred typ...
10:06:54 <Makoryu> :t read "5"
10:06:55 <lambdabot> forall a. (Read a) => a
10:06:59 <JoeyA> > let xs = [[1],2] in "hi"
10:07:00 <lambdabot>   "hi"
10:07:09 <koeien> Cody_: the type of read "5" + 0 is also a bit weird:
10:07:12 <koeien> :t read "5" + 0
10:07:13 <lambdabot> forall a. (Read a, Num a) => a
10:07:18 <koeien> so here it defaults to Integer
10:07:20 <parcs`> ocharles:
10:07:27 <parcs`> JoeyA: why would it be dangerous
10:07:27 <cmccann> Sgeo, anyway, my point is just that using STM for simple concurrency is often much simpler to reason about, and if you can isolate the non-STM stuff to one thread you can potentially avoid lots of hassle with locking and such
10:07:28 <ocharles> parcs`:
10:07:37 <parcs`> ocharles: typo :P
10:07:39 <ocharles> :)
10:08:26 <JoeyA> parcs`: I don't know.
10:08:36 <parcs`> JoeyA: it wouldn't
10:08:39 <Cody_> I think read has to have an string, an int, and expression. Weird I can just read a string
10:08:55 <Cody_> > read "5" > 4
10:08:55 <lambdabot>   True
10:09:26 <parcs`> but if you want to catch the exception inside a MonadIO m, you have to be able to lift "catch" properly
10:09:27 <Cody_> Just the way she goes lol.
10:09:40 <koeien> Cody_: I agree defaulting is kind-of weird
10:09:40 <parcs`> which is a little harder
10:10:08 <JoeyA> Isn't there a library on Hackage that defines a class for lifting catch?
10:10:16 <parcs`> there are lots
10:10:18 <koeien> Cody_: the type Read a => a defaults to () ...
10:10:27 <parcs`> simplest one is MonadCatchIO-mtl
10:10:27 <koeien> if you run with -Wall ghc will warn you.
10:10:28 <monochrom> > read "()"
10:10:29 <lambdabot>   ()
10:10:32 <monochrom> \∩/
10:11:13 <Cody_> read " "
10:11:18 <Cody_> > read " "
10:11:19 <lambdabot>   *Exception: Prelude.read: no parse
10:11:43 <Cody_> koeien: Makes more sense, thanks
10:12:10 <Makoryu> I'm kind of bemused as to why () is even a default
10:12:23 <JoeyA> parcs`: Thanks
10:12:33 <Sgeo> There's no default option type similar to the tuple combination type, is there?
10:12:36 <cmccann> I don't think anything defaults to () normally
10:12:50 <cmccann> that only happens with GHCi's extended defaulting
10:12:51 <Sgeo> > read " "
10:12:52 <lambdabot>   *Exception: Prelude.read: no parse
10:13:27 <monochrom> you must be reminded that lambdabot is not ghci
10:13:44 <cmccann> Sgeo, what do you mean by "option type"? option usually means something like Maybe
10:13:49 <JoeyA> > [(), read "()", read (read ("\"()\""))]
10:13:50 <lambdabot>   [(),(),()]
10:14:05 <koeien> Sgeo: Scala's Option[] corresponds to Maybe
10:14:42 <Sgeo> What I meant was, similar to Either which supports two types, is there a generic way to go to 3 or 4 or 5 etc. types without making my own type?
10:14:56 <cmccann> Sgeo, nesting Eithers
10:15:04 <koeien> Sgeo: "generic", no.
10:15:16 <cmccann> if you mean larger anonymous sum types like the larger anonymous products (,,), (,,,), &c.
10:15:17 <cmccann> then no
10:15:20 <koeien> you can use nested Either, but your own type is more common and descriptive
10:15:21 <hpc> ErrorT, for certain values of "type"
10:15:22 <hpc> :P
10:15:27 <cmccann> er, not anonymous I guess
10:17:53 <Sgeo> cmccann, I think TChans instead of Chans may be useful for my purposes, thanks. Still not sure though
10:18:17 <monochrom> thinking up good syntax for magical builtin n-way sum type is probably the hard part.
10:18:30 <cmccann> monochrom, yes
10:18:36 <koeien> yeah you'd need genericcally constructors
10:18:51 <cmccann> and the ugly part is that you'd create more headaches like Data.Tuple or whatever it is
10:18:55 <koeien> named
10:19:14 <cmccann> because you can't do anything that's generic in the size of tuple
10:19:33 <koeien> in ML you can, right?
10:20:08 <cmccann> ocaml probably, doesn't it have some sort of structural subtyping?
10:23:22 <monochrom> SML makes sure that "#1" alone and things like "fun f x = #1 x" are banned
10:23:33 <ben_m> Is there a function that applies a function to both values in a tuple? ie. :: (a -> b) -> (a, a) -> (b, b)
10:23:59 <hpc> :t join (***)
10:23:59 <Sgeo> :t (&&&)
10:24:00 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
10:24:00 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:24:05 <Sgeo> Ignore me
10:24:12 <dgpratt> some of these Haskell questions that are showing up on SO lately are giving me mixed emotions about the audience Haskell is now attracting
10:24:27 <koeien> dgpratt: for example?
10:24:28 <monochrom> so apparently if type inference can't figure out the arity of the tuple type, it's an error, not a genericity.
10:24:29 <JoeyA> > (^2) *** (10, 20)
10:24:30 <lambdabot>   Couldn't match expected type `b' -> c''
10:24:30 <lambdabot>         against inferred type `(t, ...
10:24:35 <cmccann> dgpratt, haha, like what
10:24:36 <dgpratt> I know it's complete and unjustified arrogance for me to say that
10:24:38 <ben_m> hpc, great, thanks
10:24:59 <hpc> dgpratt: depends; i would call it arrogance if you were going "lolnoob"
10:25:07 <dgpratt> if the Haskell community decided to keep out the riff-raff, as it were, I'd probably be the first to be shown the door
10:25:11 <JoeyA> :t (***) (^2)
10:25:12 <lambdabot> forall b b' c'. (Num b) => (b' -> c') -> (b, b') -> (b, c')
10:25:14 <hpc> dgpratt: but not if it was a glut of questions that can be answered with "let me hoogle that for you"
10:25:46 <JoeyA> :t join (***) (^2)
10:25:46 <lambdabot> forall c. (Num c) => (c, c) -> (c, c)
10:25:53 <JoeyA> > join (***) (^2) (10, 20)
10:25:54 <cmccann> dgpratt, is this really something new, though? various kinds of bad questions have shown up for years
10:25:54 <lambdabot>   (100,400)
10:25:59 <hpc> > join (***) (* 2) (5, 10)
10:26:00 <lambdabot>   (10,20)
10:26:17 <monochrom> a solution is to stop accessing SO
10:26:24 <dgpratt> cmccann: of course, but the difference was that before it was *me* asking them
10:26:29 <JoeyA> > [read $ show $ (), read . read $ show . show $ (), read . read . read $ show . show . show $ ()]
10:26:30 <lambdabot>   [(),(),()]
10:26:42 <JoeyA> Just curious, is it possible to write a recursive function that continues the pattern?
10:26:45 <JoeyA> This is strictly for fun.
10:26:53 <monochrom> both haskell-cafe and #haskell receive no bad questions these days
10:26:54 <cmccann> dgpratt, personally I've never asked any dumb Haskell questions on SO
10:26:58 <cmccann> I do that on IRC instead
10:27:05 <JoeyA> > let f r s = (r . s) () : f (read . r) (show . s) in f read show
10:27:07 <lambdabot>   ["*Exception: Prelude.read: no parse
10:27:16 <dgpratt> hpc: just questionable coding practices being exhibited, mostly
10:27:34 <Makoryu> dgpratt: Maybe it's time to start a series of Haskell screencasts to show off the basic tools
10:27:41 <Makoryu> (And coax people to use them)
10:27:44 <cmccann> dgpratt, I think many of those are coming from university students
10:27:51 <dgpratt> cmccann: probably so
10:27:54 <cmccann> picking up... strange ideas from teachers
10:28:12 <koeien> my teacher was excellent :)
10:28:33 <zeta-> I'm getting a lot of errors from "ghc-pkg check" like;-
10:28:34 <zeta-> There are problems in package hjsmin-0.0.14:  dependency "text-0.11.1.12-f06512a05e2c40f96d5d8c843eadaaa5" doesn't exist
10:28:38 <cl1> Makoryu, what basic tools are there other than hoggle and ghci?
10:28:40 <dgpratt> cmccann: actually, I wish you were not on SO at all...save some rep for the rest of us!
10:28:46 <zeta-> Should I re - install package or dependency or is there a deeper problem?
10:28:52 * cl1 is on SO
10:28:57 <Makoryu> cl1: Certain typeclasses, I guess
10:29:03 <Makoryu> cl1: Text editors
10:29:10 <Makoryu> cl1: People still ask for Haskell IDEs
10:29:11 <cmccann> dgpratt, hey, I'm barely keeping up these days
10:29:13 <JoeyA> zeta-: +1
10:29:16 <JoeyA> I run into that a lot, too :(
10:29:17 * chrisdone high-fives cmccann
10:29:46 <cmccann> ehird and hammar are way more prolific than I am
10:29:47 <JoeyA> What I want to know is, why is it that the dependency "doesn't exist" ?  What happens to it?
10:29:51 <cl1> Makoryu, haskell does not have a decent IDE
10:30:06 <cmccann> oh, and Daniel Fischer too
10:30:08 <koeien> JoeyA: it's possible that it's been replaced or hidden
10:30:11 <JoeyA> Does it automatically get hidden due to the introduction of a new version?
10:30:12 <Makoryu> cl1: I'm aware
10:30:13 <zeta-> JoeyA: how do you respond?
10:30:37 <monochrom> JoeyA, have you seen my http://www.vex.net/~trebla/haskell/sicp.xhtml ?
10:30:48 <JoeyA> Why, though?  Why doesn't it keep both versions, and let cabal install select the best candidate?
10:30:53 <Makoryu> cl1: But the least we could do is increase awareness as to which text editors have useful support, and which ones are complete disasters
10:30:56 <chrisdone> JoeyA: zeta-that error usually happens when the package was reinstalled. so the hash for the installed module changed. usually things get reinstalled automatically by cabal to help solve trivial dependency problems
10:30:57 <zeta-> JoeyA: I assume the problem is that hash(?) at the end
10:31:08 <cl1> Makoryu, indeed
10:31:12 <cl1> i use notepad++
10:31:13 <koeien> zeta-: that's normal.
10:31:24 <dgpratt> cmccann: http://stackoverflow.com/tags/haskell/topusers
10:31:24 <koeien> cl1: a lot of people use emacs, some vim.
10:31:26 <shachaf> cmccann: ehird = elliott, of course.
10:31:37 <zeta-> the version is the latest installed
10:31:40 <Makoryu> monochrom: That URL.... （　≖‿≖）
10:31:40 <dgpratt> cmccann: #3 this month and #2 all-time; I rest my case :)
10:31:58 <koeien> zeta-: monochrom's link explains it
10:32:10 <koeien> it's a hash of the binary interface
10:32:50 <monochrom> it's really a long story
10:33:10 <cmccann> dgpratt, that's after like two years or so, I think. hammar's only been at it for like 6 months and he's about to take the #2 spot :P
10:33:34 <zeta-> monochrom:  koeien : should I ignore it?
10:33:47 <koeien> if you want to use the package, you should reinstall it
10:34:04 <monochrom> there is a short story of course. it says: either reinstall just enough packages to move on, or clean up thoroughly
10:34:21 <cl1> holy crap! i'm on the all time list for c# (the very last one)
10:34:21 <koeien> the advice at the end of the article is sound. don't use the package manager of your distribution, use haskell platform + cabal for everything
10:34:26 <zeta-> koeien:  OK cool -- reading link...
10:34:46 <chrisdone> cabal-dev generally helps me avoid that specific problem
10:34:50 <JoeyA> cl1: False alarm, it just shows you on the list for comparison :(
10:34:51 <dgpratt> cmccann: truthfully, me complaining about you hogging Haskell rep is akin to me complaining that Michael Phelps is hurting my chances for the Olympics
10:34:54 <JoeyA> Same thing for me
10:34:54 <cl1> oh wait, that just shows where i'm at in comparison to everyone else
10:34:58 <cl1> LOL
10:34:59 * koeien has not had a chance to use cabal-dev yet
10:35:10 <JoeyA> I thought I was a hotshot, at the bottom of the Haskell list :-)
10:35:21 <zeta-> koeien:  yes using HP +cabal (-dev)
10:35:23 <JoeyA> I need to be about twice as active to be somebody, I think.
10:35:27 <Makoryu> monochrom: Is there any reason why the .hi files could not be preprocessed somehow (eg. to strip out inlined code) before their cryptographic hashes are taken?
10:35:37 <cl1> i need way more than twice
10:35:39 <Makoryu> Wait maybe I should finish reading first
10:35:40 <chrisdone> koeien: i use it for pretty much everyything. for a large project where you don't want to be changing the deps all the time it's hard to do without it
10:35:57 <koeien> yeah virtualenv (for python) is very useful
10:35:57 <monochrom> yes, because the inlined code does matter in reality
10:36:01 <hpaste_> mmos1127 pasted “title” at http://hpaste.org/56326
10:36:28 <Makoryu> monochrom: Well so does the non-inlined code, for that matter
10:36:31 * hackagebot postgresql-simple 0.0.3 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.0.3 (LeonSmith)
10:37:00 <Enigmagic> chrisdone: i use https://github.com/alphaHeavy/cabal-waf instead
10:37:03 <mmos1127> question here: http://hpaste.org/56326
10:37:12 <chrisdone> koeien: there's http://hackage.haskell.org/package/virthualenv too
10:38:09 <chrisdone> Enigmagic: does that support ghci?
10:38:16 <Enigmagic> chrisdone: yes
10:38:53 <Enigmagic> chrisdone: it's also faster for large builds : http://breaks.for.alienz.org/blog/2011/10/28/building-large-haskell-projects-with-waf/
10:38:55 <chrisdone> Enigmagic: how do i run ghci with it?
10:39:27 <Enigmagic> ghci -package-db ./build/package.conf.d
10:39:37 <chrisdone> ennh
10:40:00 <Enigmagic> though i could probably make a command for it :P
10:40:12 <monochrom> I will never have time to show you an example, so you will have to believe me or not.
10:40:14 <ben_m> @src join :: Arrow
10:40:15 <lambdabot> Source not found. My mind is going. I can feel it.
10:40:27 <ben_m> I fail at lambdabot.
10:40:53 * chrisdone pats ben_m on the head
10:41:01 <Sgeo> Can unamb be used in STM? Since it uses unsafePerformIO, I doubt it
10:42:45 <Sgeo> What other seemingly harmless things can't be done in STM?
10:42:45 <cmccann> I think it's only STM that can't be used inside unsafePerformIO
10:42:45 <cmccann> specifically atomically
10:42:45 <Sgeo> Oh, ok
10:42:45 <sagelywizard> Is there anything about the list data structure which you couldn't implement with a custom data type? Are there any practical differences in the way GHC would treat a semantically equivalent custom list type?
10:42:45 <monochrom> if you change non-inlined code without changing exported type sigs (and assuming that the changed non-inlined code still typechecks), there is no crash. if you change inlined code, there is a crash.
10:42:45 <chrisdone> Enigmagic: i'll give it a try
10:42:45 <Sgeo> Thought it was the other way around, derp
10:42:45 <Makoryu> monochrom: Hmm, guess I misunderstand how exactly the inliner works
10:42:45 <cmccann> Sgeo, the real problem as I understand it is nesting transactions
10:42:45 <cl1> where can i upload an rtf file for y'all to look at online?
10:42:53 <cl1> i have an idea about visual debugging, but my compiler theory is not so great
10:42:55 <Makoryu> monochrom: Still, it seems to me that without a much more sophisticated package dependency and version management system integrated into the language, the details of this scheme don't entirely make sense
10:43:06 <monochrom> it is not just the inliner. after the inliner, there are other optimizations
10:43:32 <Enigmagic> chrisdone: cool, let me know if it works for you
10:43:46 <monochrom> it is more of "what kind of optimization shows up in inlined code"
10:44:25 <copumpkin> any dutch people around here?
10:44:33 <cl1> i think haskell needs attributes and reflection
10:44:39 <monochrom> there is also transitive dependency.
10:44:40 <Sgeo> cmccann, hmm?
10:45:01 * Cody_ switch from YAHT to LYAH 
10:45:02 <psacvdf> ja
10:45:06 <cmccann> Sgeo, being able to call atomically inside a call to atomically
10:45:13 <Eduard_Munteanu> cl1: how about Template Haskell?
10:45:37 <Sgeo> cmccann, when would that be useful?
10:45:38 * Eduard_Munteanu isn't sure what you mean by attributes
10:46:00 <cmccann> Sgeo, it wouldn't, and would break STM, which is why it's forbidden
10:46:19 <Enigmagic> cl1: a typeclass can work in place of attributes
10:46:24 <cmccann> atomically fails inside unsafePerformIO to ensure that you can't do it
10:46:31 <ben_m> Is there a better way to find instance definitions of things, other than googling? Like instance Monad ((->) r)
10:46:50 <Eduard_Munteanu> ben_m: Hoogle? Hayoo?
10:46:51 <cl1> Enigmagic, orly?
10:47:01 <Sgeo> cmccann, why would someone be tempted to do so?
10:47:09 <mm_freak> ben_m: definitions or declarations?
10:47:11 <JoeyA> Haddock doesn't link to instance definitions, unfortunately.
10:47:20 <mm_freak> declarations are easy to find…  just use :i in ghci
10:47:23 <ben_m> mm_freak, definitions
10:47:25 <cmccann> Sgeo, unintentionally doing it would be the bigger worry I think
10:47:28 <monochrom> try this: X depends on Y depends on Z. Z has two versions, both versions have identical exports, but different unexported data representations. now inline
10:47:34 <ben_m> I wanted to see how bind is defined for functions
10:47:48 <cl1> Eduard_Munteanu, not quite what I was thinking about
10:47:59 <mm_freak> ben_m: you may try to figure that out as an exercise
10:48:02 <Enigmagic> cl1: sure... for a parameterless attribute, 'class MyAttribute a' 'instance MyAttribute MyData' then use template haskell to inspect..
10:48:13 <mm_freak> ben_m: that's more productive than looking up the definition
10:48:35 <Sgeo> :t join (<*>)
10:48:36 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
10:48:37 <lambdabot>       Expected type: f (a -> b) -> f (a -> b) -> a1
10:48:37 <lambdabot>       Inferred type: f (a -> b) -> f a -> f b
10:48:58 <estan> hm. if i have a list [1,2,3] and i'd like a list with all the possible pairs, e.g. [(1,1), (1,2), (1,3), (2,2), (2,3), (3,3)] , what's the most elegant way to do that?
10:49:04 <mm_freak> ben_m: if you can't figure it out, you can ask lambdabot
10:49:22 <ben_m> mm_freak, I failed at that, too :D
10:49:27 <ben_m> But I'll try to figure it out first
10:49:28 <mm_freak> estan: liftA2 (,) [1..3] [1..3]
10:49:32 <estan> (with e.g. (1,2) and (2,1) considered the same, so should not be in the result)
10:49:38 <mm_freak> oh
10:49:39 <Eduard_Munteanu> cl1: well, you don't get reflection a-la other languages that do compiling at runtime
10:50:00 <Makoryu> > (,) <$> [1..3] <*> [1,4,9]
10:50:01 <lambdabot>   [(1,1),(1,4),(1,9),(2,1),(2,4),(2,9),(3,1),(3,4),(3,9)]
10:50:05 <mm_freak> > concatMap (\x -> [x + 1 .. 3]) [1..3]
10:50:06 <lambdabot>   [2,3,3]
10:50:22 <mm_freak> > concatMap (\x -> concatMap (\y -> (x, y)) [x + 1 .. 3]) [1..3]
10:50:22 <lambdabot>   Couldn't match expected type `[b]' against inferred type `(a, a1)'
10:50:46 <mm_freak> > do x <- [1..3]; y <- [x + 1 .. 3]; [(x, y)]
10:50:47 <lambdabot>   [(1,2),(1,3),(2,3)]
10:51:05 <JoeyA> Ah, combinations, omitting flipped versions.
10:51:25 <Sgeo> :t nubBy
10:51:26 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
10:51:28 <chrisdone> > let ws = [1,2,3] in nubBy (on (==) sort) [ [a,b] | a<-ws,b<-ws,a/=b ]
10:51:29 <lambdabot>   [[1,2],[1,3],[2,3]]
10:51:31 <JoeyA> So start by pairing x with each of xs.  Then repeat the procedure for xs.
10:52:03 <JoeyA> > let f (x:xs) = map ((,) x) xs : f xs in f [1..3]
10:52:04 <lambdabot>   [[(1,2),(1,3)],[(2,3)],[]*Exception: <interactive>:3:4-35: Non-exhaustive p...
10:52:08 <JoeyA> I meant to do that.
10:52:10 <mm_freak> > do (x:xs) <- tails [1..3]; y <- xs; [(x, y)]
10:52:11 <lambdabot>   [(1,2),(1,3),(2,3)]
10:52:20 <Sgeo> > nubBy (\(a,b) (c,d) -> a==d && b==c)) $ liftA2 (,) [1,2,3] [1,2,3]
10:52:20 <lambdabot>   <no location info>: parse error on input `)'
10:52:26 <Sgeo> > nubBy (\(a,b) (c,d) -> a==d && b==c) $ liftA2 (,) [1,2,3] [1,2,3]
10:52:27 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
10:52:43 <Sgeo> That may not be efficient, and/or may not be elegent
10:52:45 <JoeyA> > let f (x:xs) = map ((,) x) xs : f xs; f [] = [] in f [1..3]
10:52:46 <lambdabot>   [[(1,2),(1,3)],[(2,3)],[]]
10:53:03 <JoeyA> oh, need to concatenate them.
10:53:12 <mm_freak> if you want inefficient, but still elegant:
10:53:13 <JoeyA> > let f (x:xs) = map ((,) x) xs ++ f xs; f [] = [] in f [1..3]
10:53:14 <lambdabot>   [(1,2),(1,3),(2,3)]
10:53:16 <chrisdone> > nub $ map (sort . take 2) $ permutations [1,2,3]
10:53:17 <mm_freak> > map (take 2) (permutations [1..3])
10:53:18 <lambdabot>   [[1,2],[2,3],[1,3]]
10:53:18 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3]]
10:53:24 <chrisdone> definitely not efficient, but cheeky :p
10:53:25 <mm_freak> well, almost
10:53:39 <mm_freak> i'd prefer the tails method
10:53:50 <JoeyA> > tails [1..3]
10:53:51 <lambdabot>   [[1,2,3],[2,3],[3],[]]
10:53:57 <mm_freak> [ (x, y) | (x:xs) <- [1..3]; y <- xs ]
10:54:03 <mm_freak> > [ (x, y) | (x:xs) <- [1..3]; y <- xs ]
10:54:04 <lambdabot>   <no location info>: parse error on input `;'
10:54:08 <mm_freak> > [ (x, y) | (x:xs) <- [1..3], y <- xs ]
10:54:09 <lambdabot>   No instances for (GHC.Num.Num [t], GHC.Enum.Enum [t])
10:54:09 <lambdabot>    arising from a use...
10:54:16 <monochrom> is this another Project Euler problem?
10:54:18 <mm_freak> > [ (x, y) | (x:xs) <- tails [1..3], y <- xs ]
10:54:19 <lambdabot>   [(1,2),(1,3),(2,3)]
10:54:24 <mm_freak> ok, talking about the tails method and forgetting tails ;)
10:54:27 <JoeyA> Yeah, what he said ^
10:54:37 <Sgeo> :t tails
10:54:38 <lambdabot> forall a. [a] -> [[a]]
10:54:44 <hpaste_> cl1 pasted “attribute example” at http://hpaste.org/56327
10:54:46 <Sgeo> > tails [1,2,3]
10:54:47 <lambdabot>   [[1,2,3],[2,3],[3],[]]
10:54:52 <JoeyA> Note that the (x:xs) pattern automatically excludes that [] list.
10:55:11 <koeien> cl1: that's possible using Data and/or Typeable
10:55:11 <JoeyA> So it's super-elegant, as long as you don't care how it works :-)
10:55:14 <cl1> ^^^ that is what I had in mind when refering to attributes and reflection
10:55:37 <chrisdone> monochrom: oddly enough i wrote this problem this morning. someone at work made a joke about finding a partner with the properties "beautiful, kind, caring, intelligent" etc, pick 2, or whatever. so i produced a list of the options in the irc channel :p
10:55:39 <mm_freak> well, it uses fail…  one might argue that it's an abuse
10:55:41 <JoeyA> estan: We figured it out :-)  ^
10:55:54 <estan> JoeyA: what's the verdict? and do you all agree? ;)
10:56:02 <Sgeo> :t permutations
10:56:03 <lambdabot> forall a. [a] -> [[a]]
10:56:09 <JoeyA> > [ (x, y) | (x:xs) ← tails [1..3], y ← xs ]
10:56:10 <lambdabot>   [(1,2),(1,3),(2,3)]
10:56:24 <JoeyA> (saving a couple chars by using Unicode ;-) )
10:56:27 <cl1> keoien .. i would like to see an example of that
10:56:41 <estan> what about (2,2), (3,3) and (1,1) then? i want those too.
10:56:42 <cl1> i may not understand it right now. but I would like it for reference later on when I do
10:57:07 <monochrom> #haskell never does verdicts.
10:57:28 <mm_freak> > [ (x, y) | xs@(x:_) <- tails [1..3], y <- xs ]
10:57:29 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
10:58:12 <chrisdone> data HaskellQuestionReply = Cons Answer HaskellQuestionReply | NoAnswerAtAll
10:58:19 <chrisdone> wait
10:58:21 <estan> ok, thanks a bunch. let me take ehm, half an hour, to digest that.
10:58:24 <chrisdone> data HaskellQuestionReply = Cons Answer HaskellQuestionReply
10:58:25 <monochrom> think of it as a typical CPO for a typical data type: as you go up, all you see is more branching, never convergence
10:58:26 <chrisdone> just that
10:58:27 * estan bbl.
10:58:29 <Sgeo> "Gets the field labels of a constructor. The list of labels is returned in the same order as they were given in the original constructor declaration.
10:58:29 <Sgeo> "
10:58:45 <Sgeo> What happens for non-records?
10:58:53 <mm_freak> that's data HaskellAnswerStream q = Cons (Answer q) (HaskellAnswerStream q)
10:58:53 <Sgeo> (Data.Data.constrFields)
10:59:35 <JoeyA> Enumeratee Question Answer m a
10:59:55 <chrisdone> mm_freak: and then #haskell is defined by Maybe (HaskellAnswerStream q)
11:00:02 <chrisdone> you either get no reply. or an infinite stream
11:00:13 <mm_freak> JoeyA: no, that's:  Question -> Enumerator Answer m b
11:00:32 <monochrom> oh god
11:00:38 <Sgeo> cl1, I guess one would look at http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Data.html and figure out what you'd need?
11:00:45 <JoeyA> mm_freak: Why so?
11:00:57 <mm_freak> JoeyA: because we're producing an infinite stream of answers for a single question
11:01:03 <JoeyA> oh
11:01:09 * zeta- has finished reading... that was fun :-)
11:01:15 <Sgeo> Give the field names special indicative names, and process the data type using the functions there
11:01:23 <Sgeo> (And deriving (Typeable, Data))
11:01:30 <Sgeo> I may be mistaken though
11:01:38 <Sgeo> Hmm, I think I can use this for my own stuff!
11:01:44 <Sgeo> Wait, no I can't
11:01:52 <Sgeo> Well, I guess I can
11:02:00 <mm_freak> also nowadays we use conduit instead of enumerator =P
11:02:03 <chrisdone> Sgeo: have a think about it and get back to us :p
11:02:06 <Sgeo> Not sure if it's worth it though.
11:03:00 <chrisdone> mm_freak: is conduit the latest innovation in 'writing stuff to a handle'?
11:03:30 <monochrom> I think it's reading
11:03:32 <Sgeo> I _have to_ write a program to generate Haskell code for me. Given that, and given that I _can_ also include definitions of functions to do what I want in the generated code, would it make more sense for me to do that (have autogenerated instances for a class), or more sense for me to write a function that can take a Data and do what I need?
11:03:42 <cmccann> I think we need more solutions to the problem of "things go in one end, things come out the other end"
11:04:01 <Sgeo> If using Data meant I didn't have to generate Haskell code, I'd do that. But I do, so
11:04:14 <monochrom> yes, the next library of that sort will be called revolving-door
11:04:15 <cmccann> Sgeo, why do you need to generate Haskell code for this?
11:04:24 <mm_freak> chrisdone: generating and processing streams
11:05:01 <cmccann> monochrom, hm, I think generalized doors have a lot of potential here actually, we can also include things like trap doors and airlocks and such
11:05:21 <cmccann> I'm not sure what all that would actually mean, of course
11:05:23 <mm_freak> conduit seems to be promising if only for being simpler
11:05:31 <cmccann> but is has lots of metaphorical value so it must be useful
11:05:36 <Sgeo> Because I have a few hundred global variables at the C level (not technically variables, but still, they're state), and want to marshal them into a smaller, but still large, number of data structures.
11:05:43 <Sgeo> http://wiki.activeworlds.com/index.php?title=Attribute
11:06:49 <zeta-> koeien: Should "cabal install --upgrade-dependencies world" make everything sane?
11:07:10 <cmccann> Sgeo, oh boy that looks fun
11:07:50 <cmccann> Sgeo, you're writing FFI bindings for that, I take it?
11:07:57 <Sgeo> yes
11:08:31 <Sgeo> My Haskell code will have toSDK and fromSDK functions. Until I thought of the Data plan, these are methods of a typeclass and my generated code would include marshalling code. With Data, I could make toSDK and fromSDK operate on Datas, and do the necessary marshalling
11:08:49 <Sgeo> Since they're all pretty uniformly marshalled
11:09:11 <eyebloom> What's the most efficient way to remove an arbitrary element from a Data.Set? Is there a predefined function for this?
11:09:31 <mm_freak> eyebloom: arbitrary?  random?
11:09:38 <Sgeo> Is there a reason to prefer one way or the other?
11:09:52 <koeien> eyebloom: in which sense "arbitrary"?
11:09:53 <zeta-> I had thought installing ghc-7.2 binary, HP from source and making all packages global would simplify things...
11:09:55 <eyebloom> Yes, I'm implementing fold in an embedded language.
11:10:12 <monochrom> Data.Set is already Foldable
11:10:16 <koeien> there is deleteMin and friends
11:10:19 <mm_freak> eyebloom: minView
11:10:34 <monochrom> but you can always use maxView yourself
11:10:45 <eyebloom> I'd have to add it to my language.
11:10:52 <eyebloom> Which isn't good.
11:10:53 <chrisdone> deleteArbitrary = delete 5 -- chosen by dice roll
11:10:55 <monochrom> and yes, I chose "maxView" arbitrarily
11:10:59 <cmccann> Sgeo, I'm really not sure what the best approach would be in that situation. how are you generating the code?
11:11:19 <cmccann> chrisdone, I think 7 is more random than 5, use that instead
11:11:25 <mm_freak> eyebloom: as a library user i'd prefer the element not to be too arbitrary
11:11:39 <cmccann> surveys show that 7 is the most random number < 10 if memory serves me
11:11:51 <chrisdone> cmccann: thanks. i also think it'll run faster with 7. i'll update my libraries.
11:12:05 <mm_freak> Set's Foldable instance in particular is min-biased
11:12:07 <Sgeo> cmccann, the current plan is to put all the attributes into a .txt file, copy/pasted from the wiki, with headers and newlines to guide the data structure that each attribute goes with
11:12:17 <Sgeo> I still haven't written any of the code for that yet
11:12:28 <monochrom> the most random number is the smallest number that stands for a halting Turing machine under some indexing scheme
11:12:51 <koeien> the most random number is the most boring natural number.
11:12:53 <koeien> oh wait
11:13:20 <Sgeo> I guess the Data plan might be useful if someone wants to make their own structure that takes from the SDK for some reason
11:13:34 <Sgeo> A different combination of attributes, or something
11:13:39 <eyebloom> mm_freak: I think if my fold function doesn't care about order (which it shouldn't for sets), then I'm just looking for the most efficient way to pull one element.
11:14:01 <cheater> Sgeo: when writing a haskell program make sure to generalize AT. ALL. COST.
11:14:17 <mm_freak> eyebloom: if you want to reinvent Foldable, use minView or maxView…  otherwise i'd suggest using the Foldable instance
11:14:37 <mm_freak> eyebloom: Foldable's fold has O(n), while a minView-based fold will have O(n * log n)
11:14:58 <koeien> you could use toAscList, also, if you don't need to modify the set afterwards
11:15:33 <chrisdone> today i learned the pretty nice design and development workflow of drupal. it was like a HP Lovecraft novel in which the protagonist opens a page in an old dusty sacred book and sees Things That Man Should Not Know and goes into existential depression and madness
11:16:07 <tromp> :t atan2
11:16:08 <lambdabot> forall a. (RealFloat a) => a -> a -> a
11:16:10 <cmccann> chrisdone, sounds enlightening
11:16:13 <monochrom> wait, is that sarcastic?
11:16:25 <chrisdone> monochrom: scathingly :p
11:17:35 <tromp> > let { a = atan2(960,640); d = 3.5 } in d*d*sin a * cos a
11:17:36 <lambdabot>   Overlapping instances for GHC.Show.Show ((t, t1) -> (t, t1))
11:17:37 <lambdabot>    arising fro...
11:18:07 <eyebloom> Hmmm... I think deleteFindMax (or Min) is what I would want.
11:18:32 <tromp> :t  let { a = atan2(960,640); d = 3.5 } in d*d*sin a * cos a
11:18:33 <lambdabot> forall t t1. (RealFloat (t, t1), Fractional t, Fractional t1) => (t, t1) -> (t, t1)
11:18:43 <eyebloom> But maxView would also work.
11:18:44 <koeien> tromp: let a = atan2 960 640 ...
11:18:46 <koeien> is the syntax
11:18:52 <eyebloom> Thanks
11:19:03 <tromp> > let { a = atan2 960 640; d = 3.5 } in d*d*sin a * cos a
11:19:04 <lambdabot>   5.653846153846154
11:19:11 <tromp> thx, koeien
11:19:12 <aristid> monochrom: sarcasm can be confusing
11:19:13 <monochrom> maxView is better than deleteFindMax if you ever want to test "is the set empty anyway"
11:19:15 <chrisdone> i also learned that `git blame` is a handy tool to aid outbursts like 'WHO THE HELL WROTE THIS?'
11:19:28 <cheater> yes it is
11:19:32 <aristid> chrisdone: indeed. that's where the name comes from
11:19:44 <tromp> > let { a = atan2 1280 800; d = 5.3 } in d*d*sin a * cos a
11:19:45 <lambdabot>   12.624719101123596
11:19:46 <eyebloom> Gotcha.
11:19:47 <cl1> is there anything in haskell that would let me dynamically load libraries into existing executable code? such as pluings for and IDE?
11:20:03 <tromp> > 12.624719101123596/5.653846153846154
11:20:04 <lambdabot>   2.2329435144844454
11:20:17 <cl1> lots of questions, my mind is on imporoving the haskell experiance
11:20:21 <Makoryu> cl1: hs-plugins
11:20:21 <statusfailed> Can anyone recommend a good e-reader reasonably suitable for textbooks?
11:20:24 <krakrjak> I just wish git blame would email the guy that wrote that crap letting him know how you feel about the drivel he calls code.
11:20:32 <cl1> too bad I don't know more about haskell
11:20:32 <chrisdone> krakrjak: haha
11:20:36 <Makoryu> cl1: The catch is that you actually have to reload the running executable
11:20:41 <JoeyA> git flame
11:20:42 <chrisdone> krakrjak: like that 'you've got BO' web site?
11:21:05 <JoeyA> If you're not careful, you'll blame someone who did trivial whitespace formatting.
11:21:11 <cl1> Makoryu, while quite lame, it might be sufficient
11:21:33 <krakrjak> chrisdone: yes exactly like that.
11:21:43 <Sgeo> I don't see hs-plugins on Hackage
11:21:56 <chrisdone> it's just called 'plugins' iirc
11:21:59 <Makoryu> cl1: Look up how Xmonad does it
11:21:59 <statusfailed> Sgeo: http://hackage.haskell.org/package/plugins-1.4.1
11:22:08 <statusfailed> but yeah, it's not hs-plugins
11:22:16 <krakrjak> My favorite is readins some blinding code with no chance of being safe and grumbling no so subtly until I finally whip out the git blame and it ME!
11:22:27 <Makoryu> cl1: And keep in mind that it involves editing and compiling a Haskell source file
11:22:42 <Makoryu> Though I bet there's a way to automate that step....
11:22:44 <chrisdone> krakrjak: does that really happen? i thought that was an urban legend made up by Dijkstra
11:23:00 <krakrjak> chrisdone: and perpetuated by Bjarne
11:23:28 <monochrom> wait, Dijkstra told an urban legend about git blame?!
11:24:10 <Enigmagic> You can never trust quotes on the  Abraham LincolnInternet
11:24:13 <chrisdone> he was always ahead of his time
11:24:18 <krakrjak> monochrom: the bartender tells Dijkstra we don't serve time travelling professors here.  Dijkstra walks into a bar.
11:24:20 <monochrom> "EWD 1319: My experience with git"? :)
11:24:31 <chrisdone> monochrom: :D
11:24:33 <monochrom> haha krakrjak
11:24:50 <Cody_> When will Haskell add a "prime" function to the prelude? It'd be nice.
11:24:59 <koeien> Cody_: probably never
11:24:59 <chrisdone> what would the implementation be?
11:25:15 <koeien> Cody_: this is not a generally useful function
11:25:18 <monochrom> Mathematica has a "prime" function
11:25:19 <Cody_> koeien: It make ProjectEuler easier.
11:25:34 <monochrom> Haskell was not conceived for Project Euler
11:25:38 <Cody_> Lol
11:25:43 <koeien> Cody_: i'm sure there is a package somewhere
11:25:58 <cl1> Prelude doesn't make a whole lot of sense to me anyways. Why would you want stuff preloaded? its a single line of code to import if you need it
11:26:03 * Sgeo goes off to think about better approaches to his problem
11:26:25 <chrisdone> cl1: it's almost always required, in fact more
11:26:29 * cmccann just wishes the Prelude had fewer stupid functions in it
11:26:44 * Cody_ wishes it had a prime function
11:26:51 <dmwit> Put every function in its own module.
11:26:55 <dmwit> #OccupyTheNamespace
11:26:56 <chrisdone> i almost always have Control.Monad, Data.List, Control.Applicative, Control.Monad.Reader/State, Data.Function…
11:27:10 <chrisdone> Data.Maybe
11:27:11 <shachaf> dmwit: 99% of the functions are in 1% of the modules?
11:27:18 <dolio> dmwit: Yeah, and name the function f.
11:27:18 <shachaf> Maybe by frequency of use.
11:27:31 <cmccann> dolio, isn't that how numeric prelude does it?
11:27:38 <dolio> Quicksort.f
11:27:38 <shachaf> The same thing with types, of course.
11:27:39 <dolio> Yes.
11:27:44 <monochrom> I know what you wish, Cody_. Prelude has a function "pe" so that "pe n" is the solution to Project Euler #n.
11:27:55 <dolio> Well, it doesn't do it with functions, I think.
11:27:59 <dolio> It does it with classes and types, though.
11:28:11 <dolio> MyModule.T and MyModule.C.
11:28:23 <cl1> why am i chatting in here? I'm getting no work done >_>
11:28:25 <cl1> lol
11:28:28 <Cody_> monochrom: Lol
11:28:33 <dolio> Doing it for functions is just the obvious extension.
11:28:37 <Makoryu> Cody_: Depending on why you need a prime number, a function like "prime :: Num n => n -> Bool" might be totally useless
11:28:58 <shachaf> I think there should be a rule that #haskell vanishes out of existence if three or more "lol"s are said in a row.
11:29:05 <shachaf> In fact, that rule should be true for just one.
11:29:05 <ciaranm> lol
11:29:08 <koeien> yeah probablePrime is more useful sometimes, sometimes you want to generate them in order, and so on
11:29:09 <Cody_> Sorry it was funny.
11:29:19 <chrisdone> > cycle "lo"
11:29:20 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
11:29:24 * Makoryu explodes
11:29:38 <Cody_> good^^
11:29:42 <chrisdone> @faq Can Haskell sing along with trololo guy?
11:29:42 <conal> does anyone remember in what module the Monad instance for pairing-with-monoid lives? i've asked this question recently here and forgot the answer.
11:29:43 <lambdabot> The answer is: Yes! Haskell can do that.
11:29:43 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
11:30:18 * Cody_ is back to reading
11:30:23 <dmwit> conal: Control.Monad.Writer, maybe?
11:30:32 <dmwit> Not sure I understand what you're asking for 100% though.
11:30:44 * conal looks
11:31:12 <cl1> i have to leave. I'm having entirely too much fun in here. I need to get stuff done, this code isn't going to write itself
11:31:19 <cl1> laters all
11:31:24 <conal> dmwit: i'm looking for instance Monoid o => Monad ((,) o) where ...
11:31:26 <shachaf> dmwit: I think conal wants an instance for Moinoid x => (x,) directly?
11:31:37 <conal> shachaf: yeah.
11:31:41 <dmwit> ?unmtl Writer m a
11:31:41 <lambdabot> (a, m)
11:31:45 <dmwit> so?
11:31:48 <shachaf> Right, but without the newtype.
11:31:51 <dmwit> Oh, you want no wrappers.
11:31:55 <conal> but reversed: (m,a) , not (a,m)
11:31:57 <conal> right
11:32:11 <dmwit> I didn't know there was a module with that in it.
11:32:12 <shachaf> The fact that the newtypes reverse the order you'd use without newtypes is kind of weird.
11:32:16 <conal> just to avoid writing the orphan instance myself.
11:32:40 <conal> shachaf: yeah. without the wrapper, the monoid has to come first.
11:32:52 <chrisdone> yeah newtype deriving makes me do strange reordering to my types
11:33:27 <Clint> what does FPS stand for?
11:33:29 <shachaf> A New Type of Deriving.
11:33:34 <shachaf> Clint: Many things.
11:33:38 <koeien> Clint: context?
11:33:39 <Clint> when it means ByteString
11:33:49 <shachaf> When it means ByteString, it stands for ByteString
11:33:53 <shachaf> Oh, FastPackedString.
11:33:55 <Clint> thanks
11:34:07 <chrisdone> Clint: using gd? ;)
11:34:10 <Clint> cgi
11:34:16 <chrisdone> ah, that's the other one
11:34:51 <monochrom> FPS is pretty old. predecessor of ByteString
11:35:18 <monochrom> proper utf8 support was taken out when it transited from old to new
11:35:24 <xplat> monochrom: i should totally write that pe function
11:35:59 <monochrom> bear in mind that pe's type may be weird or problematic in Haskell
11:36:01 <shachaf> xplat: Make sure it reads PE's website and parses any new problems.
11:36:35 <xplat> monochrom: Int -> String is weird or problematic?
11:36:38 <cmccann> monochrom, the result should be a string, suitable to paste into the answer box, I think
11:36:40 <monochrom> taking out utf8 support would have been ok if latin1 support was not put in place.
11:36:53 <bgamari> byorgey: Concerning Diagrams, you let the backend handle most of the low-level geometry heavy-lifting, correct?
11:36:55 <monochrom> String is weird and a bit problematic
11:37:08 <xplat> monochrom: point taken
11:37:11 * cmccann can't argue with that
11:37:20 <monochrom> oh, for pasting into the answer box! then String is good enough
11:37:50 <xplat> it seems to always be a digit-string in the ones i've done so far
11:38:11 * Sgeo attempts to think of a typesafe way to do what he wants
11:38:17 <Cody_> > let replace xs = [1 | _ <- xs] in replace [1..10]
11:38:18 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
11:38:22 <Itkovian> anybody any idea wat the three String arguments in Network.HTTP.postRequestWithBody are?
11:38:30 <Cody_> > let replace xs = ['a' | _ <- xs] in replace [1..10]
11:38:30 <lambdabot>   "aaaaaaaaaa"
11:38:34 <Sgeo> All I can think of is asking the user to pass in something hideous like undefined::(Int, Int, Bool)
11:38:40 <Itkovian> the docs are not exactly … useful : http://hackage.haskell.org/packages/archive/HTTP/4000.2.2/doc/html/Network-HTTP.html
11:38:40 <shachaf> xplat: "Int"?! That's horrible! Integer -> String, please.
11:38:57 <xplat> > let replace = map . const in replace 'a' [1..10]
11:38:58 <lambdabot>   "aaaaaaaaaa"
11:39:28 <xplat> shachaf: i'm not planning to support the situation where project euler has over 2 billion problems
11:39:29 <cmccann> shachaf, taking a stand against Int?
11:39:30 <monochrom> the growth rate of PE is logarithmic to the growth rate of Int size
11:39:44 <Itkovian> OK, my brain is disfunctional it seems
11:39:55 <shachaf> cmccann: It's the right thing to do, In't?
11:40:02 <Sgeo> If I make each attribute be a tuple of a thing defining the attribute, and its type
11:40:07 <cmccann> shachaf, :D
11:40:10 <Sgeo> I might be able to pull it off
11:40:20 <Sgeo> Or, no, not quite
11:40:31 <Cody_> > let replace xs = [x | _ <- xs] in replace [1..10]
11:40:32 <lambdabot>   [x,x,x,x,x,x,x,x,x,x]
11:40:44 <Cody_> > let replace xs = [x | x <- xs] in replace [1..10]
11:40:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:40:55 <Cody_> There we go. _  and x are different
11:41:27 <xplat> > let replace xs = [x | y <- xs] in replace [1..10]
11:41:28 <lambdabot>   [x,x,x,x,x,x,x,x,x,x]
11:41:35 <Sgeo> How immoral would it be for me to peek inside a type to look to see if it structurally uses a defined type of my choosing?
11:41:42 <Cody_> Was just about to try that^^
11:41:44 <shachaf> Sgeo: 14 points.
11:42:01 <ciaranm> Sgeo: about on par with sodomy and cooking a goat in its mother's milk
11:42:18 <parcs`> ciaranm: haha
11:42:34 <chrisdone> Sgeo: if the module's designed right, you won't be able to touch it if you're not supposed to anyway :)
11:43:03 <parcs`> i like that you can easily peek into a library's source code, thanks to hackage/haddock
11:43:04 <xplat> what?  it's much worse than sodomy, sodomy is about as immoral as wearing blended fabrics.  less, considering how fabrics are made.
11:43:08 <monochrom> bear in mind that in Japanese cuisine there is a dish with both chicken and egg, explicitly named "the parent and child meal"
11:43:34 <shachaf> monochrom: Does it have to be the chicken's egg?
11:43:38 <xplat> mm, oyako-don
11:43:44 <monochrom> I don't know
11:44:02 <xplat> shachaf: no
11:44:24 <Sgeo> I want the return type of my function to depend on its arguments. The only way I can do that is to have the arguments be a certain type.
11:44:24 <monochrom> I guess in this industrialized agriculture days, it's hard to do a match like that
11:44:41 <Sgeo> awMyX :: AWMyX
11:45:01 <Sgeo> But then AWMyX isn't a CInt
11:45:05 <monochrom> type class may help you do that
11:45:25 <xplat> https://en.wikipedia.org/wiki/Oyakodon
11:45:29 <parcs`> what do you eat first? the chicken or the egg?
11:45:35 <monochrom> hahaha
11:45:36 <s951> Quick noob question: What am I doing wrong if I'm throwing up this error?
11:45:39 <s951> "Instance of Num [Char] required for definition of findSubstringsInTree"?
11:45:40 <estan> mm_freak: hrmf, i'm too thick. i still can't quite wrap my head around that [(x,y)|(x:xs) <- tails [1..3], y <- xs] ..
11:45:52 <Sgeo> s951, treating a String as though it was a number
11:45:56 <koeien> s951: you are trying to add/subtract/multiply strings
11:46:02 <koeien> > "3" * "2"
11:46:03 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:46:04 <lambdabot>    arising from a use of `GH...
11:46:09 <mm_freak> estan:
11:46:11 <mm_freak> > tails [1..3]
11:46:12 <lambdabot>   [[1,2,3],[2,3],[3],[]]
11:46:13 <Makoryu> s951: Perhaps using (+) instead of (++) to concatenate two strings
11:46:38 <mm_freak> estan: if you say "x <- tails [1..3]", then 'x' will represent [1,2,3], [2,3], [3] and []
11:46:44 <monochrom> if *you* are throwing up a compiler error, you ate too much code. :)
11:46:52 <mm_freak> > [ sum x | x <- tails [1..3] ]
11:46:53 <lambdabot>   [6,5,3,0]
11:47:26 <estan> mm_freak: right, but if i say (x:xs) <-> tails [1..3], shouldn't x be 1,2,3 then? (the head of each list in that list of lists)?
11:47:39 <mm_freak> yes
11:47:40 <estan> err. (x:xs) <- tails [1..3] i mean.
11:47:48 <Makoryu> > "foo" ++ "bar" -- for s951
11:47:50 <lambdabot>   "foobar"
11:47:57 <Makoryu> > "foo" + "bar"
11:47:58 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:47:58 <lambdabot>    arising from a use of `GH...
11:48:00 <s951> Aha. Just saw the problem.
11:48:11 <s951> Trying to use "==0" to test whether a string is null >.<
11:48:15 <mm_freak> estan: and that's what's happening…  one piece of magic you should know about is that the pattern-match will fail for the []
11:48:16 <Makoryu> Whoops
11:48:16 <s951> doh
11:48:26 <koeien> s951: yeah, use the "null" function
11:48:28 <monochrom> haha
11:48:28 <koeien> > null ""
11:48:29 <lambdabot>   True
11:48:29 <mm_freak> estan: in a list comprehension, failed pattern-matches are just ignored
11:48:33 <koeien> > null "Hello world!"
11:48:34 <lambdabot>   False
11:48:42 <mm_freak> [ x | Just x <- [Just 2, Just 3, Nothing, Just 4] ]
11:48:45 <mm_freak> > [ x | Just x <- [Just 2, Just 3, Nothing, Just 4] ]
11:48:46 <lambdabot>   [2,3,4]
11:48:50 <Sgeo> So Haskell DOES have null!
11:48:51 <Makoryu> @source null
11:48:52 <Sgeo> </joke>
11:48:52 <lambdabot> null not available
11:48:55 <monochrom> you may actually want to use pattern matching instead of null
11:49:07 <Sgeo> null (x:xs) = False; null [] = True
11:49:08 <koeien> yeah, that depends
11:49:40 <mauke> @src null
11:49:40 <lambdabot> null []     = True
11:49:41 <lambdabot> null (_:_)  = False
11:49:45 <monochrom> use null if you don't need the content of the list. use pattern matching if you need the content of the list
11:50:14 <estan> mm_freak: but hm, if that's what's happening, shouldn't [(x,y)| ... ] construct a list where the first element is (1,something) the second (2, something) et.c.? how come it's [(1,2), (1,3) et.c?
11:50:29 <monochrom> example: answer x = if null x then "success" else "fail"  good use
11:50:33 <cmccann> monochrom, you mean using (== []) and then head and tail isn't the right way :O
11:50:40 <xplat> why are parallel list comprehensions so limited?
11:50:59 <koeien> what is a parallel list comprehension?
11:51:17 <shachaf> monochrom: I'd still prefer answer [] = "success"; answer _ = "fail" in many cases.
11:51:36 <Makoryu> xplat: Do you mean something like this? [ (x, y) | x <- foo, y <- bar ]
11:51:39 <monochrom> example: job x = if not (null x) then (head x, tail x) else ...  why would you indulge in such redundancy and wordiness
11:51:40 <estan> mm_freak: i mean, since we just concluded that the (x:xs) <- tails [1..3] would give values 1, 2, 3 for x ?
11:51:55 <Cody_> :t odd
11:51:56 <lambdabot> forall a. (Integral a) => a -> Bool
11:51:59 <Cody_> > odd 4
11:52:00 <lambdabot>   False
11:52:07 <xplat> > [x ++ " and " ++ y | xs <- ["ham","love","horse"] | ys <- ["cheese", "marriage", "carriage"]]
11:52:08 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:52:09 <lambdabot>         against inferred ty...
11:52:09 <Cody_> Why does that refuse to work in ghci
11:52:18 <mm_freak> estan: list comprehensions behave like cartesian products
11:52:23 <mauke> Cody_: what do you mean by "refuse"?
11:52:25 <xplat> > [x ++ " and " ++ y | x <- ["ham","love","horse"] | y <- ["cheese", "marriage", "carriage"]]
11:52:26 <lambdabot>   ["ham and cheese","love and marriage","horse and carriage"]
11:52:31 <koeien> Cody_: it ought to.
11:52:33 <Sgeo> Cody_, what refuses to work?
11:52:36 <mm_freak> > [ (x, y) | x <- "abc", y <- "def" ]
11:52:37 <Cody_> odd 5
11:52:37 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
11:52:44 <Cody_> or the "odd" function
11:52:45 <mauke> Cody_: what do you mean by "refuse"?
11:52:51 <Cody_> Throws an error
11:52:55 <mauke> Cody_: what error?
11:52:58 <xplat> koeien: Makoryu: ^
11:53:08 <Makoryu> xplat: Okay. What limitation are you concerned with, exactly?
11:53:16 <Cody_> mauke: It's really long, want me to paste it in hpaste?
11:53:28 <mauke> bored now
11:53:32 <estan> mm_freak: oooh that explains my confusion i think.
11:53:34 <mm_freak> estan: for the first iteration of the first pattern, you will have x = 1 and xs = [2,3]…  then 'y' will be 2 and 3, so your first iteration will give you (1, 2) and (1, 3)
11:54:04 <estan> mm_freak: all makes sense now. thanks a lot (what a miss from my side!)
11:54:13 <xplat> Makoryu: if you filter on one, the lists lose sync
11:54:30 <koeien> use zip
11:54:45 <mm_freak> estan: you're welcome
11:54:53 <Makoryu> xplat: Filter the combined list, then
11:54:57 <xplat> > [x ++ " and " ++ y | x <- ["ham","love","horse"] | y <- ["cheese", "marriage", "carriage"], y < "m"]
11:54:59 <lambdabot>   ["ham and cheese","love and carriage"]
11:55:01 <Cody_> mauke: No instance for (Num [t0]) arising from literal `5'
11:55:23 <koeien> Cody_: what's the exact line you're typing?
11:55:24 <chrisdone> mauke ♥
11:55:29 <Cody_> mauke: possible fix, add an instance decleration for (Num [t0])
11:55:29 <mizu_no_oto> Suppose that I'm making a monte-carlo powered game AI for something like tic-tac-to (the problem is the same with any other additive game, though, like Go, Pente, Othello, &c.).  In order to generate a possible move, I'm thinking that I should probably have a  data structure filled with the coordinates of the empty points where I can get and remove a random element.  I noticed that Data.Map...
11:55:30 <Cody_> odd 5
11:55:31 <shachaf> xplat: Isn't it "ham and eggs"?
11:55:31 <mizu_no_oto> ...has both elemAt and deleteAt, both of which are Olog n), and size is O(1).  Is there a better data structure to use that Map (Int,Int) IDontCareWhatTypeThisIs?  It seems hacky, since I'm not really using the map as a map but as a set where I can access a System.Random element...
11:55:33 <mauke> Cody_: :t odd
11:55:42 <Cody_> :t odd
11:55:42 <lambdabot> forall a. (Integral a) => a -> Bool
11:55:43 <koeien> Cody_: you might have shadowed odd with your own function
11:56:15 <xplat> Makoryu: if i have to turn the list into a list of pairs and filter it, explicitly pattern matching, and do the combination in a map, then why am i even bothering to use a list comprehension?
11:56:29 <Cody_> koeien: Your right, that was really stupid of me.
11:56:40 <Makoryu> xplat: Good question. Instead of a list comprehension, just write "zip listA listB"
11:57:08 <cmccann> mizu_no_oto, if you're only using the key, why not Data.Set instead?
11:57:10 <Makoryu> > zip [1..3] ["foo", "bar", "baz"]
11:57:11 <lambdabot>   [(1,"foo"),(2,"bar"),(3,"baz")]
11:57:25 <xplat> Makoryu: but why does the extension even exist if it's so limited?
11:57:32 <mizu_no_oto> cmccann:  How do you get a system.random element out of a set?
11:58:14 <xplat> i mean, i know how to use zip, i was hoping -XParallelListComprehensions could save me from some pointless pointlessness
11:58:14 <Makoryu> xplat: Eh, it's useful sometimes, and taking it out would presumably break older code from before some of the useful list functions were implemented
11:58:32 <shachaf> xplat: What's the pointless pointlessness involved here?
11:58:42 <Sgeo> pointless pointlesslessness
11:58:53 <xplat> shachaf: well, pointless pointlessness or pointless pattern-matching
11:59:03 <shachaf> It seems to me that list comprehensions are almost never point-free.
11:59:08 <cmccann> mizu_no_oto, oh, you want to remove a series of random elements, not just access arbitrary elements, sorry
11:59:11 * shachaf probalby just missed xplat's original objection.
11:59:37 <mizu_no_oto> cmccann:  yes, that's essentially the essence of a monte carlo simulation
11:59:40 <Makoryu> shachaf: Skipping elements of xs doesn't skip the corresponding elements of ys.
11:59:46 <shachaf> Oh.
11:59:59 <shachaf> Well, that seems reasonable-ish to me.
12:00:05 <cmccann> mizu_no_oto, yeah, I misread what you were trying to do
12:00:05 * Makoryu shrugs
12:00:08 <shachaf> It would be weird if it automatically did that.
12:00:26 <xplat> shachaf: i wanted -XParallelListComprehensions to make my map.filter.zip pipeline more readable by letting me refer to things by name, but it won't because it crosses the streams too late
12:01:08 <xplat> i can only get a map.zip.filter pipeline
12:01:36 <cmccann> mizu_no_oto, if you just want a random sequence of elements without repetition, wouldn't it be easy to just shuffle a sequence instead of pulling them from a map?
12:01:44 <cmccann> or do you need the indexed access as well
12:01:46 <Makoryu> xplat: If I wanted to make that more readable I'd write a combined filter/zip that explicitly has that behavior
12:01:46 <shachaf> xplat: Hmm, I see.
12:02:29 <shachaf> xplat: OK, I see your point.
12:03:21 <xplat> validation!  :)
12:03:32 <mizu_no_oto> cmccann:  Actually, that would work for tic-tac-to.  It wouldn't work for something like Go, othello or pente, though
12:03:47 <shachaf> @google validation free parking
12:03:48 <lambdabot> http://www.youtube.com/watch?v=Cbk980jV7Ao
12:03:49 <lambdabot> Title: Validation - YouTube
12:04:04 <rs46> How do I use a monadic function as a condition in a list comprehension?
12:04:06 <rs46> e.g.
12:04:17 <koeien> :t filterM
12:04:18 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:04:18 <rs46> isOkay :: Int -> IO Bool
12:04:23 <mm_freak> xplat: would concatMap . zip be an option?
12:04:24 <cmccann> mizu_no_oto, anyway, yeah, I'm not sure if there's anything specifically suited to what you want
12:04:28 <xplat> mizu_no_oto: it seems like monte carlo simulation of hard games would be misleading
12:04:32 <shachaf> rs46: That's not any "monadic function", it's an IO functionj.
12:04:35 <mm_freak> xplat: often concatMap is nicer than map . filter
12:04:43 <mizu_no_oto> xplat:  What do you mean?
12:04:48 <shachaf> rs46: You can't use an IO function in a list comprehension, at least in the sense that you're asking.
12:04:52 <shachaf> rs46: You can use filterM.
12:05:11 <rs46> shachaf: ok..
12:05:21 <rs46> I'll take a look thanks
12:05:30 <mizu_no_oto> xplat: That monte-carlo would give worse results than e.g. alpha-beta pruning?
12:05:37 <xplat> mm_freak: mm, yes, but there's no concatZip
12:05:43 <shachaf> rs46: ("monadic" is much more general that "IO", and has nothing to do with "impurity" or anything like that.)
12:05:55 <koeien> i know monte-carlo is a genuine method to write Go engines.
12:06:00 <rs46> cheers :-)
12:06:04 <xplat> mizu_no_oto: yes, because opponents don't move randomly
12:06:15 <Makoryu> xplat: zipWithIf f p (x:xs) (y:ys) | p x && p y = f x y | otherwise = zipWithIf f p xs ys; zipWithIf _ _ _ _ = []
12:06:41 <koeien> xplat: a-b is not feasible for Go, since writing the evaluation function is very hard
12:06:45 <mizu_no_oto> koeien:  Monte carlo tree searches, to be precise
12:07:09 <koeien> for chess the evaluation function is much easier to write, and the combinatorial explosion is less severe
12:07:26 <mm_freak> xplat: well, you can't possibly have all boilterplate code in Data.List =)
12:08:39 <mizu_no_oto> koeien:  Chess is also far, far easier to evaluate mid-game.  It's significantly harder to estimate which player is up in Go
12:09:09 <koeien> mizu_no_oto: yeah. also tablebases for endgames, and an opening book
12:09:27 <koeien> also not really available in Go
12:09:48 <mizu_no_oto> openings have been very throughly studied in Go
12:09:57 <Makoryu> xplat: Whoops! s/(f x y)/\1 : zipWithIf f p xs ys/
12:10:07 <mizu_no_oto> and there are a lot of well known endgame positions
12:10:22 <koeien> sure, i imagine computers might be strong at the endgame
12:10:28 <everyonemines> You mean endgame *structures* ?
12:10:58 <everyonemines> computers are strong at chess endgames, so people do better with long midgames
12:11:17 <everyonemines> where they avoid trading
12:11:18 <koeien> that completely depends on the middle game
12:11:25 <mizu_no_oto> everyonemines:  Yeah - positions that are worth known amounts of points depending on who has the initiative, in go
12:12:08 <rs46> shakakai: dumb question.. using filterM, say I have an IO function of type :: Int -> IO Bool called `isNotGood'
12:12:25 <sipa> :t filterM
12:12:26 <everyonemines> Is haskell really the best choice for a go AI? I kind of wonder.
12:12:26 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:12:33 <rs46> I want all elements in the list where isNotGood a returns false
12:12:41 <koeien> rs46: fmap not isNotGood
12:12:46 <koeien> or not <$> isNotGood
12:13:20 <Makoryu> :t ((<$>), fmap)
12:13:21 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f, Functor f1) => ((a -> b) -> f a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1)
12:13:33 <Makoryu> :t [(<$>), fmap]
12:13:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
12:13:35 <koeien> everyonemines: in terms of raw speed, probably writing in C is better.
12:14:00 <mizu_no_oto> writing in assembly might even be better than C for raw speed
12:14:07 <koeien> yeah exactly
12:14:10 <everyonemines> Hmm, I meant more that efficient implementation would inevitably involve array mutation.
12:14:14 <koeien> but other than that, i don't see why not.
12:14:20 <Axman6> mizu_no_oto: almost never
12:14:21 <koeien> you can do that in Haskell
12:14:25 <Makoryu> 1) Develop it in Haskell 2) Compile it to C by hand
12:14:36 <everyonemines> Because of the nature of go. Yeah, you can do that in haskell but ...
12:14:38 <everyonemines> it's not great.
12:14:39 <mm_freak> everyonemines: no, not in haskell
12:14:58 <koeien> Makoryu: that is extremely painful.
12:15:02 <koeien> at least part 2) of your plan
12:15:26 <mm_freak> everyonemines: see the 'instinct' library…  it's a fast ANN implementation, which does not use array mutation at all
12:15:31 <everyonemines> I think of haskell as better for symbolic manipulations...
12:15:37 <everyonemines> while go is a pretty geometric game.
12:17:31 <mm_freak> everyonemines: haskell is great for both
12:18:04 <everyonemines> mm_freak: what are examples of haskell being effective for that kind of problem
12:18:32 <everyonemines> I know Parsec or whatever is pretty good, but I haven't heard of it being good at this.
12:19:24 <mm_freak> everyonemines: again, check out the 'instinct' library, which makes heavy use of arrays
12:19:36 <mm_freak> lazy vectors to be exact…  it exploits haskell's laziness to get along without any mutation
12:20:15 <shachaf> mm_freak: Except for all the mutation used to implement laziness, of course. :-)
12:20:36 <mm_freak> that's an implementation detail =)
12:20:41 <mm_freak> the haskell code is pure
12:20:56 <everyonemines> . . . .
12:21:09 <everyonemines> I think you're missing the point of functional purity.
12:21:11 <Sgeo> It uses an implementation detail to be efficient?
12:21:41 <shachaf> Sgeo: That's the usual way to be efficient. :-)
12:22:03 <everyonemines> It's not supposed to be a ritualistic thing at the source level, is it?
12:22:33 <mm_freak> the point is:  it is as efficient as array mutation while being idiomatic haskell
12:22:34 <everyonemines> If you have state mutation but it's just hidden then you're worse off than if it's exposed.
12:22:53 <mm_freak> if you think that way, you shouldn't use haskell
12:23:04 <Itkovian> any tips for keeping a haskell install up-to-date?
12:23:19 <mm_freak> Itkovian: which operating system?
12:23:24 <koeien> Itkovian: not really. once you install a new compiler version you'll have to recompile all packages
12:23:26 <Sgeo> everyonemines, you might want to make your own Haskell interpreter
12:23:26 <Itkovian> OSX, linux
12:23:35 <Sgeo> Because I don't think there are any that do what you think
12:23:36 <cmccann> everyonemines, if it's hidden well enough that it behaves exactly the same as if there was no mutation, how are you worse off?
12:23:39 <Itkovian> koeien: yeah, that's what I've been doing so far
12:23:54 <koeien> the ABI is not stable. it depends on the exact version of GHC.
12:24:03 <everyonemines> Well, every program compiles to a register machine thing, that's not what I meant.
12:24:25 <copumpkin> everyonemines: you can run everyonemines on an abstract machine or something completely not like a register machine
12:24:27 <everyonemines> I'm talking about breaking the assumptions that functional purity is supposed to allow.
12:24:36 <copumpkin> ugh
12:24:38 <copumpkin> you can run haskell
12:24:39 <copumpkin> :P
12:24:39 <mm_freak> everyonemines: you are saying that if you want to be efficient through mutation, you should be explicit about that in the code, and i totally disagree there
12:25:18 <koeien> so upgrading will always involve some recompilation
12:25:28 <koeien> i'd just recommed following the Haskell Platform
12:25:34 <everyonemines> Well, I prefer ML. And it is faster. :-)
12:25:42 <copumpkin> everyonemines: [citation needed]
12:25:48 <copumpkin> languages don't have speeds
12:25:51 <mm_freak> everyonemines: i highly doubt that
12:25:56 <copumpkin> implementations do
12:26:06 <c_wraith> copumpkin: what?  someone told me english was faster than german because german has all those big words.
12:26:09 <koeien> copumpkin: over some distribution of programs
12:26:14 <copumpkin> koeien: yeah
12:26:21 <xplat> that's like saying 'if you use bit shifts but they're hidden that's worse than if they're exposed' and condemning strength reduction optimizations
12:26:31 <copumpkin> xplat: damn right, I hate those things
12:26:48 <copumpkin> I only write in microcode
12:26:51 <copumpkin> assembly is too high-level for me
12:26:53 <everyonemines> No, I was saying, abstractions aren't useful where they get broken a lot.
12:27:05 <copumpkin> everyonemines: how do we break them?
12:27:07 <everyonemines> Sometimes they're useful, but sometimes they're not.
12:27:09 <mm_freak> everyonemines: where do they get broken?
12:27:14 <koeien> c_wraith: http://www.economist.com/blogs/johnson/2011/09/language-speed relevant
12:27:17 <mm_freak> laziness in particular
12:27:46 <cheater> chinese is fastest isn't it
12:28:13 <koeien> mandarin is very overloaded
12:28:32 <mm_freak> everyonemines: also note that laziness is not an abstraction itself…  it's a language feature
12:28:33 <koeien> i would expect the opposite
12:28:54 <everyonemines> japanese maybe
12:29:30 <cheater> haha it's in fact the slowest
12:29:32 <everyonemines> mm_freak: Huh? Of course it's an abstraction. So are function definitions. But laziness is higher up.
12:29:54 <copumpkin> everyonemines: no, it's a fundamental building block in our abstract language
12:30:06 <mm_freak> everyonemines: laziness is an evaluation strategy…  you can build abstractions upon that
12:30:09 <everyonemines> If you want to talk about the amount of transformation applied to the compiler and how much the end product resembles the original source.
12:30:12 <cmccann> copumpkin, shouldn't that be non-strictness, actually?
12:30:24 <copumpkin> cmccann: sure, but there's no point in making the distinction here
12:30:31 <cmccann> I thought laziness specifically was an implementation of such
12:30:32 <cmccann> ok
12:30:41 <everyonemines> Yeah, but we're not programming for an abstract language. If you want to write numerical code you have to deal with the facts of computer architecture.
12:30:46 * cmccann tries to be precise about terminology when possible is all :P
12:30:53 <copumpkin> cmccann: fair enough :)
12:31:10 <mm_freak> everyonemines: your brain seems to be messed up from imperative programming
12:31:13 <mm_freak> give haskell a shot =)
12:31:21 <everyonemines> I like ML.
12:31:23 <copumpkin> everyonemines seems more interested in preaching than learning
12:31:25 <everyonemines> but I have.
12:31:37 <cmccann> everyonemines, the facts of computer architecture is that processors doesn't resemble any language
12:31:38 <everyonemines> I've been looking at it. Sometimes.
12:31:46 <cmccann> and that only compilers understand how they work, mostly
12:31:53 <copumpkin> everyonemines: you sound like you've been looking at it with a pre-formed opinion about it
12:31:54 <everyonemines> cmccann: ASM? :-)
12:32:01 <cmccann> everyonemines, hahahaha no
12:32:04 <mm_freak> as a matter of fact i've just written a modular arithmetic library in pure idiomatic haskell with type level numbers and everything that outperforms PARI/GP with GMP!
12:32:17 <xplat> nobody understands how processors work
12:32:32 <mm_freak> so anyone claiming that idiomatic haskell must be slow is a retard
12:32:41 <everyonemines> Well, it's true that ASM doesn't deal with multilevel caching.
12:32:46 <mm_freak> including number crunching
12:32:53 <Sgeo> Is ByteString implemented idomatically?
12:32:56 <Sgeo> idiomatically?
12:33:00 <mm_freak> Sgeo: no
12:33:03 <koeien> far from it
12:33:07 <copumpkin> that's the thing
12:33:11 <copumpkin> abstraction works :P
12:33:19 <copumpkin> the underlying implementations are ugly but we don't have to care
12:34:05 <xplat> ByteString is written unidiomatically, but you can write fast idiomatic code on top of it
12:34:12 <Cale> Right now I wish I had a way to sort/filter type errors by... type?
12:34:37 <mm_freak> Cale: do you have a .Types module in your project? ;)
12:34:47 <c_wraith> also, a lot of the reason bytestring is so ugly underneath is to provide a fast interface to C code, not to be fast itself
12:34:54 * Cale has millions of Couldn't match type `m6' with `m30' (where both type variables are introduced by the typechecker)
12:35:14 <Cale> There are real type errors in there, but I have to dig through the junk to find them :)
12:35:21 <everyonemines> And why is it using C code?
12:35:27 <mm_freak> everyonemines: it's not
12:35:30 <cmccann> Cale, usually I start adding strategic type annotations to deal with stuff like that
12:35:40 <koeien> everyonemines: FFI
12:35:44 <everyonemines> ah
12:35:54 * Cale has > 10000 lines of type errors :D
12:36:03 <cmccann> everyonemines, unfortunately it's going to take a while to reimplement everything in Haskell, so until they we need to interact with other languages sometimes :P
12:36:04 <c_wraith> There are some nice libraries written in C.  It's nice to be able to bind to them efficiently.
12:36:05 <Cale> Doing a big refactoring which breaks everything
12:36:18 <Sgeo> If I have an action that I believe is idempotent, can I run it in STM?
12:36:29 <mm_freak> everyonemines: ByteString is written in a way that makes it possible to interface with C code easily (in particular ByteStrings don't get moved around in memory)
12:36:35 * Sgeo rethinks that
12:36:48 <c_wraith> Sgeo: until you're wrong, sure...  Why not just return an IO action from your STM transaction?
12:36:49 <everyonemines> yeah I see what you mean
12:37:07 <mm_freak> Sgeo: if you can express it in terms of STM, you can run it in STM
12:37:26 <Cody_> Is fac n = product [1..n] more efficient than fac n = n * fac (n-1)?
12:37:27 <Sgeo> But I can't express it in terms of STM
12:37:30 <Sgeo> It's an FFI thing
12:37:40 <c_wraith> Sgeo: there is unsafeIOToSTM
12:37:43 <dmwit> Is factorial really a function you need to optimize?
12:37:46 <koeien> Cody_: I don't know, not essentially.
12:37:48 <monochrom> join (blahblah >> return (putStrLn "hi"))
12:37:49 <cmccann> Sgeo, I'm doubtful that any truly idempotent action would have to be run in the middle of an STM transaction
12:37:49 <Sgeo> Although come to think of it, the answer may change, not because I do it twice, but because of time
12:37:51 <c_wraith> Sgeo: but that's probably not what you want
12:37:57 <cmccann> rather than be returned and run afterwards
12:38:03 <mm_freak> Cody_: if you want speed, go for foldl' (*) 1
12:38:15 <Cody_> dmwit: In my case yes. I tried doing the fac of 1,000,000. Been going for 3+ minutes now
12:38:19 <rwbarton> uh
12:38:19 <ciaranm> if you want fast factorial, there's a closed form approximation whose accuracy is known
12:38:20 <Cale> Cody_: Quite possiblty, especially with -O / -O2
12:38:27 <xplat> Cale: just find one real error, deal with it, repeat
12:38:40 <Cale> xplat: Yep, that's what I'm doing
12:38:40 <dmwit> Cody_: ...so?
12:38:47 <koeien> (stirling)
12:38:51 <Cale> xplat: I just wish there were a way to filter the results better :)
12:38:57 <rwbarton> that probably has more to do with the fact that you are doing a million computations on roughly 1000000-digit numbers
12:39:09 <everyonemines> Suppose you want to represent a parallel prefix sum of an array in haskell.
12:39:14 <Cody_> dmwit: Idk, want to find the fastest way. Wondering if anyone on here knew?
12:39:19 <everyonemines> Suppose future computers have parallel operations like that.
12:39:27 <mm_freak> rwbarton: that's feasible and shouldn't even take too long
12:39:36 <Sgeo> fac n = n * fac (n-1) is not space-efficient
12:39:37 <Cale> Cody_: With product, the strictness analyser will essentially turn that into a foldl' and it'll run in less space.
12:39:42 <Cody_> mm_freak: I'll try your way next
12:39:46 <ciaranm> Cody_: the fastest way is to use stirling's approximation
12:39:55 <koeien> Cody_: stirling of 1e6 gives me Infinity.
12:39:56 <Cale> Stirling's approximation isn't exact
12:39:57 <Cody_> Need to head to google for that
12:40:03 <mm_freak> Cody_: if you compile with -O, 'product' should be fine, but it's not guaranteed
12:40:03 <copumpkin> no stirling
12:40:08 <everyonemines> We're not always going to want to linearize everything, I think.
12:40:08 <rwbarton> It could easily take "3+ minutes", and anyways has nothing to do with the difference between fac n = product [1..n] and fac n = n * fac (n-1) and fac = foldl' (*) 1.
12:40:09 <koeien> which means it's pretty large :)
12:40:22 <copumpkin> why use O(log n) for inexact stirling when you can do O(log n) exact
12:40:42 <dmwit> Cody_: What are you going to do with the factorial of a million once you know it?
12:40:44 <Cody_> rwbarton: Thanks.
12:40:47 <Cale> If you want a really fast factorial, you need to somehow balance the size of the numbers being multiplied.
12:40:53 <rwbarton> yep.
12:40:58 <dmwit> Cody_: (Hint: the answer to this question is probably "throw it away", in which case you don't need to optimize your factorial function.)
12:41:07 <Cody_> dmwit: I'm doing (length . show . factorial) (1000000)
12:41:13 <copumpkin> lol
12:41:26 <Cody_> Guessing it'll be around 5,000,000
12:41:39 <mm_freak> Cody_: you can do that with a sum of logarithms
12:41:47 <mm_freak> no need to compute the product for that
12:41:52 <dmwit> Cody_: You can do that much more efficiently by *not computing the factorial*.
12:42:28 <koeien> > logBase 10 38
12:42:29 <lambdabot>   1.57978359661681
12:42:31 <koeien> > logBase 10 380
12:42:32 <lambdabot>   2.57978359661681
12:42:34 <koeien> > logBase 10 3800
12:42:35 <lambdabot>   3.57978359661681
12:42:36 <koeien> > logBase 10 38000
12:42:37 <lambdabot>   4.579783596616809
12:42:47 <mm_freak> > sum (map log [1..1000000]) / log 10
12:42:48 <lambdabot>   *Exception: stack overflow
12:42:49 <Cody_> dmwit: Thanks for the tip
12:43:01 <ciaranm> someone make RayNbow come back and demand that he fixes his quit message
12:43:13 <xplat> Cody_: i don't remember seeing that one while i was passing you up on Project Euler
12:43:19 <dmwit> ciaranm: ?tell him
12:43:34 <cheater> ciaranm: what is wrong with it?
12:43:42 <mm_freak> Cody_: round that up and you've got the number of digits
12:44:14 <Cody_> xplat: It wasn't. I was trying to find the fac of a a hundred thousand, but accidentally added a zero. I've been waiting ten minutes lol.
12:44:24 <ciaranm> cheater: it's entirely possible that "everywhere" is the center of the universe, in the same way that "everywhere" is the center of the earth if you stick to the surface
12:44:59 <mm_freak> > foldl' (+) 0 (map log [1..1000000]) / log 10
12:44:59 <cheater> no person is everywhere
12:45:00 <lambdabot>   5565708.917186599
12:45:04 <cheater> your nitpick does not stand.
12:45:10 <Cody_> mm_freak: Alright.
12:47:17 <Cale> But 1000000! isn't really that large. If you want to brute force it, there ought to be a way.
12:47:53 <shachaf> @let thatLarge n = n > fromIntegral (maxBound :: Int)
12:47:54 <lambdabot>  Defined.
12:48:12 <mm_freak> 1000000! is easy to calculate with the proper type
12:48:29 <mm_freak> 10 * 10 = e ^ (log 10 + log 10)
12:48:34 <Sgeo> Cale, foldl'?
12:48:48 <Cody_> > let fac n = prod [1..n] in fac 1000000
12:48:48 <lambdabot>   Not in scope: `prod'
12:48:55 <Cody_> > let fac n = product [1..n] in fac 1000000
12:48:56 <lambdabot>   *Exception: stack overflow
12:48:56 <mm_freak> but even with the good old Integer it should be done within seconds to minutes depending on machine
12:49:00 <Axman6> > 10**(foldl' (+) 0 (map log [1..1000000]) / log 10)
12:49:02 <lambdabot>   Infinity
12:49:05 <mm_freak> you can also easily parallelize that computation
12:49:05 <Axman6> :o
12:49:12 <koeien> Axman6: by FAR
12:49:25 <Sgeo> > foldl' (\acc n -> acc * n) 1 [1..1000000] :: Integer
12:49:29 <lambdabot>   mueval-core: Time limit exceeded
12:49:29 <Cody_> mm_freak: The computer I'm on could be why its taking so long
12:49:34 <Cale> Mathematica easily computes 1000000! (all the digits of it) in just a few seconds on my machine without parallelism. So if you get yourself a decent implementation of factorial, it should be fine.
12:49:52 <Cale> It's just that the product of consecutive integers implementation starts to suck.
12:50:00 <copumpkin> Cale: gmp has a built-in primitive for it
12:50:11 <mm_freak> foldl' (*) 1 is decent enough…  its speed is pretty much limited by GMP's multiplication implementation
12:50:12 <copumpkin> not sure if mathematica uses gmp but I'd imagine it would
12:50:27 <copumpkin> mm_freak: it can be done in logarithmic time
12:50:43 <xplat> mathematica probably uses its own thing
12:50:45 <copumpkin> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
12:50:58 <Cale> Yeah, the problem is that you're repeatedly multiplying a giant number by fairly small numbers, rather than multiplying numbers which are about the same size.
12:51:00 <drdo> mm_freak: that multiplication order is also pretty bad
12:51:03 <Cale> That's fib, rather than fac...
12:51:07 <copumpkin> oh
12:51:09 <copumpkin> whoops
12:51:15 <copumpkin> it can still be done :P
12:51:22 <Cale> hehe, wrong functional microbenchmark ;)
12:51:26 <Cale> I've done that before too :)
12:51:31 <copumpkin> lol yep
12:51:36 <koeien> how? the number is O(n) long, amirite?
12:51:44 <Cody_> Still waiting...
12:51:44 <mm_freak> drdo: yeah, GMP's builtin factorial has a better order
12:51:46 <xplat> unfoldl?!
12:51:49 <mm_freak> but we don't have access to that
12:51:55 <copumpkin> I could've sworn it was possible
12:51:56 <copumpkin> hmm
12:52:17 <drdo> mm_freak: I didn't know it mattered until i wrote a parallel one with a different order and it was way way faster
12:52:38 <Sgeo> Is it safe to say that foldl' is a tail-call-exploiting fold?
12:52:42 <copumpkin> The asymptotically-best efficiency is obtained by computing n! from its prime factorization. As documented by Peter Borwein, prime factorization allows n! to be computed in time O(n(log n log log n)2),
12:52:47 <mm_freak> drdo: really, for a one-time calculation of 1000000! you don't want to overcomplicate things =)
12:52:52 <Sgeo> @src foldl'
12:52:53 <lambdabot> foldl' f a []     = a
12:52:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:52:55 <mm_freak> Sgeo: yes
12:53:07 <mm_freak> Sgeo: but that's foldl, too
12:53:11 <xplat> copumpkin: ?!?
12:53:14 <koeien> Sgeo: yes, and strict in its accumulator
12:53:16 <acowley> copumpkin: I was about to guess that complexity
12:53:30 <Cale> Sgeo: It's unsafe to talk about tail calls in the context of a Haskell evaluator at all.
12:53:42 <Cale> Well...
12:53:47 <xplat> how does prime factorization help here?
12:53:59 <koeien> xplat: 4 = 2*2, so you don't need to multiply by 4
12:54:20 <koeien> you can calculate how often a prime number occurs in the total factorial
12:54:22 <Cale> I mean, I guess you can define what they are, but "tail call optimisation" doesn't mean anything because the stack which TCO applies to doesn't exist in GHC's evaluator, or most Haskell evaluators.
12:54:32 <koeien> and then you can efficiently raise it to that power
12:54:32 <mm_freak> xplat: you can employ sort of a sieving scheme to save multiplications
12:54:51 <xplat> mm_freak: ah, hm, i begin to see
12:54:52 <Cale> main = print . length . show . product $ [1..1000000]
12:54:55 <Cale> compiled with -O2
12:55:01 <mm_freak> xplat: but also what koeien said
12:55:04 <Cale> eventually finishes and produces the correct result
12:55:07 <mm_freak> the outcome is probably the same
12:55:09 * Cody_ wonders when his computation will be done.
12:55:12 <rwbarton> Cale, how long was eventually?
12:55:15 <rwbarton> or did you not time it
12:55:17 <Cale> It just takes a couple minutes
12:55:19 <Cale> I didn't time it
12:55:26 <rwbarton> that sounds about right
12:56:44 <Cale> You usually don't really have to use foldl' directly for product and sum if you're compiling with optimisations
12:57:02 <Cale> because the strictness analyser seems to usually be smart enough to handle those cases
12:57:03 <tromp> @pl \n -> iterate f n !! n
12:57:03 <lambdabot> (!!) =<< iterate f
12:57:14 <eikenberry> Anyone used checkinstall to create a quick debian package out of the ghc-7.0.4 binary dist?
12:57:21 <Cody_> > pi
12:57:22 <lambdabot>   3.141592653589793
12:57:26 <eikenberry> Keeps bombing out on me for different reasons.
12:57:48 <tromp> :t iterate succ >>= (!!)
12:57:49 <lambdabot> Int -> Int
12:59:30 <koeien> some uninteresting info: it took 3 minutes and 32 seconds on my machine.
13:00:32 <Cody_> > let pi c d = c / d in pi 62.6 20
13:00:32 <lambdabot>   3.13
13:00:48 <Cody_> koeien: Interesting fact, its still going on mine.
13:01:33 <koeien> this is a core2 quad 2.83GHz
13:01:47 * hackagebot network-conduit 0.0.0 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.0.0 (MichaelSnoyman)
13:01:49 * hackagebot conduit 0.0.2 - A pull-based approach to streaming data.  http://hackage.haskell.org/package/conduit-0.0.2 (MichaelSnoyman)
13:02:17 <Cody_> koeien: I'm just going to close ghci. This is taking too long and it shouldn't.
13:02:27 <koeien> ah yes, ghci is way slower than compiled code
13:02:58 <koeien> ghc --make X.hs -O2 for the best results
13:03:13 <Cody_> -O2?
13:03:22 <Sgeo> Maximum optimization.
13:03:28 <Cody_> I thought it was -o X.exe
13:03:29 <Sgeo> I think
13:03:36 <koeien> -o is where the output file should go to
13:03:38 <Sgeo> -o says what the output file is
13:03:42 <Sgeo> o and O are different
13:03:45 <koeien> it's not related to -O and friends
13:03:50 <Cody_> Lol
13:03:58 <ciaranm> silly windows users
13:04:00 * cmccann compiles with -Oω
13:04:17 <c_wraith> Ow?
13:04:24 <koeien> omega
13:04:28 * Cody_ thinks one day he'll be hip enough to use a mac
13:05:35 <ocharles> fffffuuuuuu. want backtraces for errors :(
13:06:04 <ocharles> a combination of http-conduit and xml-conduit and my own parser randomly throws a ParseError in takeWhile1... but repeating the request works
13:06:38 <ocharles> that takeWhile1 is in xml-conduit I *think*, and I wonder if it happens on chuck bonudaries or something. but I dunno enough about conduit
13:25:52 <plat0> :i ifM
13:26:07 <plat0> :t ifM
13:26:08 <lambdabot> Not in scope: `ifM'
13:26:18 <plat0> Does ifM exist or did I dream it?
13:26:34 <MostAwesomeDude> plat0: Maybe you wanted "when"?
13:26:36 <MostAwesomeDude> :t when
13:26:37 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:26:57 <MostAwesomeDude> Hm.
13:27:00 <MostAwesomeDude> @hoogle ifM
13:27:01 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
13:27:01 <lambdabot> Foreign.C.Error throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
13:27:01 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
13:27:39 <c_wraith> there are two different things people often want with ifM:  Bool -> m a -> m a -> m a  -or-  m Bool -> m a -> m a -> m a
13:28:11 <MostAwesomeDude> @hoogle Monad m => Bool -> m a -> m a -> m a
13:28:12 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
13:28:12 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
13:28:12 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
13:28:22 <c_wraith> the former is more or less exactly what if gives you
13:28:27 <c_wraith> except that if isn't a function, etc
13:28:49 <plat0> I wanted the latter.
13:29:25 <Sgeo> What's throwErrnoIfMinus1?
13:29:37 <plat0> I was wondering how to write it without do notation, but I first wanted to check if it actually existed.  Do people just write it themselves when they need it?
13:30:07 <MostAwesomeDude> plat0: Well, since do-notation blocks are nestable, often people just nest as needed.
13:30:12 <monochrom> throwErrnoIfMinus1 translates unix's "return -1 if error" convention into Haskell exceptions
13:30:20 <MostAwesomeDude> And oftentimes you actually wanted "when" or "unless".
13:31:56 <plat0> Is there a lambdabot command to desugar do notation?
13:32:14 <Sgeo> @undo
13:32:15 <lambdabot> ()
13:32:26 <Sgeo> @undo { x <- Just 5; return x }
13:32:27 <lambdabot>  Parse error at "{" (column 1)
13:32:32 <Sgeo> @undo do { x <- Just 5; return x }
13:32:32 <lambdabot> Just 5 >>= \ x -> return x
13:33:20 <Sgeo> @do print =<< getLine
13:33:20 <lambdabot> print =<< getLine
13:33:24 <plat0> @undo do { x <- a; if x then b else c }
13:33:24 <lambdabot> a >>= \ x -> if x then b else c
13:33:30 <Sgeo> @do getLine >>= print
13:33:31 <plat0> Is that ifM?
13:33:31 <lambdabot> do { a <- getLine; print a}
13:35:27 <acowley> plat0: yes
13:35:40 <acowley> plat0: sometimes people use a function bool :: a -> a -> Bool -> a
13:36:00 <acowley> plat0: so you could write a >>= bool b c
13:39:03 <plat0> Thanks acowley.
13:42:04 <cmccann> acowley, how about an Applicative version instead? :D
13:43:13 <acowley> cmccann: I actually only use my personal prelude where if is an unsafePerformIO FFI call into OpenCL
13:43:31 <monochrom> what? haha
13:45:09 <Axman6> monochrom: you need to use OpenCL to make sure that the Bool is true or false on thousands of GPU cores, just to be sure of its value. you never know when you might get an inconsistent answer from just one CPU!
13:46:00 <monochrom> a more efficient way is to FFI-call into #haskell :)
13:46:25 <Axman6> that's just a waste of resources
13:46:52 * hackagebot irc 0.5.0.0 - A small library for parsing IRC messages.  http://hackage.haskell.org/package/irc-0.5.0.0 (TrevorElliott)
13:47:19 <Axman6> heh, that was quite a well times hackage announcement
13:47:27 <monochrom> how timely for a parse-IRC package to pop up
13:47:36 <Axman6> timed*
13:48:17 <acowley> Axman6: btw, I made CLUtil faster
13:48:24 <Axman6> hooray! how?
13:48:42 <acowley> Axman6: I CPS transformed the runKernel functions so I could use host pointers when running on the CPU
13:48:53 <acowley> Axman6: previously I had to copy the vector data
13:49:03 <acowley> Axman6: I also added support for asynchronous kernel execution
13:49:04 <Axman6> nice =)
13:49:27 <Axman6> ah nice, so you get a reference back you can check for completion?
13:49:32 <acowley> Axman6: The code base grew like 10x, but I think I might actually add in the ability to extract a pure interface
13:49:51 <acowley> Axman6: yeah, I return a value you can wait on (which also handles cleanup after blocking)
13:50:15 <acowley> Axman6: I can actually beat LAPACK with just a dot product on my CPU now (with a big enough vector)
13:50:20 <Axman6> hmm, that could be interesting. though OpenCL is very much not pure really. the OpenGL packages don't hade that fact do they?
13:50:55 <acowley> It won't all be pure. Initialization is all IO, but I think I can give the user a pure function for their kernel.
13:51:10 <Axman6> that'd be cool :)
13:51:17 <acowley> Axman6: I'm not sure if the pure interface will be worth it, it's just something I've started thinking about
13:51:42 <acowley> Axman6: I'm most eager to tie it into my OpenCV interface. I shold be able to write something like a 10-liner to process webcam video on the GPU
13:52:02 <Axman6> that would be very cool
13:53:28 <acowley> I hope more people in the community start using these things. While it strays from being 100% Haskell, it's an awfully compact way to get pretty extreme performance.
13:54:29 <Axman6> indeed. Should get Ben Lippmeier looking at it, and tie it into the rest of his repa work
13:55:20 <Sgeo> :t fromMaybe
13:55:21 <lambdabot> forall a. a -> Maybe a -> a
13:55:25 <acowley> Well, the obvious path forward seems to lead to Accelerate which already exists
13:55:48 <acowley> Maybe that means Accelerate needs more love
13:55:53 <Axman6> hmm, true
13:56:14 <Axman6> i found Accelerate to be a quite confusing code base when I tried to play with it sadly :(
13:56:56 <Axman6> but that might be because I didn't understand a lot of what was going on
13:57:48 <Axman6> personally I think a DSL for producing OpenCL kernels is a much more sane way to do (and then you could build something that's more haskelly on top of that)
13:58:33 <acowley> I'll have to take a serious look at it some time, but I don't feel like I'm intimate enough with OpenCL to be sure such extreme abstractions aren't underperforming
13:58:48 <acowley> I kind of like having external OpenCL source as you don't need to recompile your Haskell code
14:00:21 <Axman6> well, being able to have both is a must. but it would be nice to be able to programatically produce the kernels (and be able to pretty print them with line numbers etc)
14:00:31 <acowley> yeah, agreed
14:01:09 <acowley> I don't know when I'll have time to look into it, which is also why I want more people involved :)
14:01:56 <Axman6> me either, I need to be doing more work on this scholarship, not less, and then I'll be tutoring and doing honours next semester/year
14:02:44 * cmccann would love to experiment with opencl stuff but is pretty sure his outdated hardware doesn't support it
14:03:05 <Axman6> :(
14:03:12 <Ke> you can use it on cpu too, which is fine for experiments
14:03:13 <Eduard_Munteanu> How's Haskell's OpenCL state?
14:03:32 <Axman6> go buy a Radeon HD 7970 or something :P
14:03:36 <dolio> @dice 20d6
14:03:36 <lambdabot> 20d6 => 73
14:03:37 <Eduard_Munteanu> Is there a DSL for that?
14:03:38 <cmccann> Ke, takes a lot of the fun out of it though
14:03:46 <Ke> there are 3 variants of OpenCLRaw on hackage
14:03:58 <Axman6> cmccann: i dunno, high performance parallel programming on the CPu is also quite fun
14:03:59 <Eduard_Munteanu> Uh, not somethine raw, I was expecting nice combinators :)
14:04:13 <dolio> @dice 20d6
14:04:14 <lambdabot> 20d6 => 57
14:04:24 <Axman6> Eduard_Munteanu: acowley's working on some quite nice stuff
14:04:25 <Ke> someone was doing something like that, axman has some details
14:04:39 <Ke> heh
14:05:08 * Eduard_Munteanu hopes r600g gets OpenCL support at some point, but he can run fglrx in the meanwhile
14:05:37 <acowley> cmccann: I do half my development on a laptop without GPU accelerated OpenCL
14:05:58 <Eduard_Munteanu> I wonder if any general-purpose compiler actually tries to vectorize code through OpenCL.
14:06:09 <Ke> open source OpenCL seems as elusive as nuclear fusion
14:06:17 <Axman6> you can get very good results with OpenCL on the CPU, it takes care of writing all the annoying vector code for you (to some extent)
14:06:30 <Eduard_Munteanu> Ke: more like cold fusion, one would say :)
14:06:35 <srhb> Ke: Radiant as the sun?
14:06:38 <srhb> Damn, beat to it...
14:06:42 <Axman6> Ke: Clang supports it for the PTX backent =)
14:06:50 <acowley> cmccann: The cool thing about it is when you have some calculation that is straightforward to express in C, but you'd like it to be totally SIMD'ed and run over multiple cores: OpenCL does that completely painlessly
14:07:10 <Ke> Eduard_Munteanu: that would probably not be worth the effort since there is considerable overhead for doing something on gpu
14:07:24 <cmccann> acowley, hm, interesting
14:07:31 <Axman6> which means you can in theory write OpenCL programs and compile them with Clang, and get them to run on any recent nvidia card
14:07:53 <Eduard_Munteanu> Even GCC doesn't seem to do much CPU vectorizing.
14:07:58 <Ke> Axman6: so you mean no open source support ;o)
14:07:59 <hpaste_> acowley pasted “OpenCL dot product” at http://hpaste.org/56329
14:08:19 <Ke> ptx is like /dev/urandom to opensource
14:08:22 <acowley> cmccann: that's my stupid little dot product kernel that can outperform LAPACK on a dual core machine with big enough vectors
14:08:25 <Ke> only bad entropy
14:08:25 <Axman6> Ke: eh? Clang is pretty damn open source, and so is the PTx backend for LLVM, contributed by nvidia
14:08:44 <Eduard_Munteanu> acowley: how's your dot product different?
14:08:47 <Eduard_Munteanu> GPU?
14:09:01 <acowley> no, it uses both cores
14:09:06 <Axman6> also, didn't nbvidia recently open source a bunch of their OpenCL and CUDA stuff?
14:09:17 <kmklz> Is it okay to say that the primary difference between a concurrent and parallel program is that the former has multiple threads of control acting on a common state while the latter does not?
14:09:17 <Ke> Axman6: but not the backend
14:09:23 <truta> hi guys ;)
14:09:30 <Eduard_Munteanu> Try ScaLAPACK or something, I'm not sure LAPACK is optimized for that, is it?
14:09:37 <Axman6> Ke: not sure what you mean...
14:10:16 <Ke> the ptx does not run on any hardware
14:10:19 <Axman6> kmklz: usually the aim of parallelism is to make things go faster. the aim of concurrency is to make losely related tasks run at the same time
14:10:39 <kmklz> Axman6: so the primary difference is speed?
14:11:00 * monochrom knows communities that define "concurrent" to be our "parallel"
14:11:16 <Axman6> kmklz: well, not really. they have different aims.
14:11:37 <truta> I need some help... i have this function "shellspaces (x:xs) = if x == ' ' then ("\ " ++ (shellspaces xs)) else (x:shellspaces xs)" that replaces any space by the string with "\ ", but it's giving me an error (lexical error in string/character literal at character ' ')... Can someone explain me this behavior and how do i solve this problem? Thanks ;)
14:11:42 <monochrom> actually s/our/haskell mainstream/
14:11:59 * monochrom would not like to be counted
14:12:00 <Axman6> Ke: this is true, but you probably don't ever want to be targeting the instruction set the actual hardware supports, because nvidia change it all the time, to make improvements
14:12:24 <Axman6> truta: "\\ "
14:12:50 <Axman6> you need to escape \, because it is the escape character in haskell strings
14:13:27 <Eduard_Munteanu> > "\""
14:13:28 <lambdabot>   "\""
14:13:35 <truta> thanks Axman6 but if i insert the "\\ ", it will insert me the 2 slashes
14:13:36 <Eduard_Munteanu> > text"\""
14:13:37 <lambdabot>   "
14:13:39 <Axman6> > "\\ "
14:13:40 <ocharles> does anyone know what the compile error https://gist.github.com/aaeda4b47e53752436c9 means?
14:13:40 <lambdabot>   "\\ "
14:13:56 <Eduard_Munteanu> > text "\\ "
14:13:56 <lambdabot>   \
14:14:00 <Axman6> truta: no it won't. only when you `show` the string will there be two \'s:
14:14:10 <Axman6> > text "foo \\ bar"
14:14:10 <Eduard_Munteanu> > text $ show "\\ "
14:14:11 <lambdabot>   foo \ bar
14:14:11 <lambdabot>   can't find file: L.hs
14:15:01 <ocharles> without -debug and -rts it fails with just the 'largeword' error
14:15:43 <Eduard_Munteanu> ocharles: missing profiling libs?
14:15:53 <Axman6> ocharles: it looks like you don't have the profiling versions of those libraries installed
14:16:01 <truta> hum... thanks for the answers... i will try it :)
14:16:24 <parcs`> kmklz: yes that is about right
14:16:40 <monochrom> people are very ill-advised to use show and print on Strings
14:16:40 <Eduard_Munteanu> ocharles: you should probably   cabal --reinstall -p   them, if you got them through cabal
14:16:41 <ocharles> Axman6: hrm, i've installed profiling libraries of everything I got error messages about
14:16:47 <ocharles> yep, already did that with everything
14:17:26 <ocharles> no changes with -fforce-recomp either
14:17:44 <Axman6> do files with those names exist on your system?
14:17:45 <Eduard_Munteanu> monochrom: sometimes I think maybe 'show' shouldn't mess Strings up
14:17:57 <cmccann> maybe people shouldn't use show for pretty printing
14:18:01 <ocharles> hmm, there is a "largeword" package on hackage and I haven't recompiled that
14:18:02 <ocharles> I'll try that
14:18:03 <Eduard_Munteanu> Right.
14:18:09 <ocharles> poof, that was it
14:18:10 <Eduard_Munteanu> Yeah, what cmccann says.
14:18:24 <ocharles> I wonder what depends on that, and why ghc didn't inform me to rebuild it like everything else
14:19:14 <Eduard_Munteanu> ocharles: hm... maybe it's not Haskell code?
14:19:38 * ocharles hopes to god this helps him track down an exception
14:20:09 <cmccann> to be fair, it's a failure of education, and arguably a lack of a pretty-printing equivalent to show
14:20:30 <ocharles> class PrettyPrint?
14:20:46 <monochrom> I see two extreme solutions, and I welcome either. first solution: like Eduard_Munteanu says, show s = s. second solution: escape fully, e.g.,  print "A" gives you "\65"
14:21:50 <mm_freak> ok, i've got factorial of 1000000 in 4.3 seconds in haskell
14:21:52 * hackagebot crypto-conduit 0.1.1.1 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.1.1.1 (FelipeLessa)
14:22:13 <ocharles> https://gist.github.com/bc2cbda66a96e67415cf sigh, is this about as good as :trace gets?
14:22:21 <ocharles> ignore that show :P
14:23:10 <hpaste_> “Ertugrul Söylemez” pasted “Fast integer factorial” at http://hpaste.org/56330
14:23:19 <mm_freak> xplat: if you care, see the paste
14:23:28 <mm_freak> 1000000! in 4.3 seconds on my CPU
14:24:16 <Pseudonym> mm_freak: I'm guessing that excludes printing.
14:24:23 <mm_freak> Pseudonym: no, printing included
14:24:34 <Pseudonym> I would imagine that dominates.
14:24:41 <cl1> what does the second argument in foldr do? just append that to the results?
14:25:00 <monochrom> ask for "fac 1000000 > 1" to skip the printing
14:25:10 <Pseudonym> Or fac 1000000 `seq` ()
14:25:23 <mm_freak> without printing it needs 1.9 secs
14:25:39 <salisbury> could someone with a mathematical leaning please tell me what the heck is going on in either the first or second definition here?
14:25:41 <salisbury> http://en.wikipedia.org/wiki/Mahalanobis_distance#Definition
14:25:43 <srhb> cl1: That is the "starting value" so to speak, for the first argument in the function you're folding with
14:26:12 <monochrom> foldr (+) k [1,2,3] = 1+(2+(3+k)). that's what the 2nd argument does. I wouldn't call it "append".
14:26:29 <salisbury> specifically, what is this T exponent and what operation is going on between the matrix and vector under the sqrt?
14:26:33 <mm_freak> cl1: foldr (+) z [a, b, c] = a + (b + (c + z))
14:26:34 <acowley> salisbury: the third form is the one I find easiest to understand
14:26:42 <cl1> so its the starting value for the accumulator
14:26:56 <mm_freak> cl1: or ending value
14:27:03 <acowley> salisbury: the general idea is that differences of components with low variance count for more than differences of components with high variance
14:27:03 <mm_freak> it depends on how you use it
14:27:12 <Axman6> cl1: it's what replaces [] in the list, and f replaces (:)
14:27:15 <mm_freak> "starting value" is misleading
14:27:23 <srhb> It is, apologies for that.
14:27:24 <Axman6> > foldr f z [a,b,c] :: Expr
14:27:25 <lambdabot>   f a (f b (f c z))
14:27:30 <monochrom> generally, wordy essays are misleading
14:27:46 <Axman6> > foldr (*) z [a,b,c] :: Expr -- Imagine that (*) is any binary function
14:27:47 <lambdabot>   a * (b * (c * z))
14:27:51 <acowley> salisbury: Imagine a 2D vector <X,Y> where you know X with high certainty, and Y with low certainty. If you want to think about the distance between two such vectors, differences in their X component should count for more
14:28:14 <monochrom> formula examples like f a (f b (f c z)) (or rewrite that infix) are both clear and concise
14:28:20 <cl1> so then z is the starting value for the second argument to (*)
14:28:43 <acowley> salisbury: the first two forms just express the operations in matrix form so you can cope with non-diagonal covariance matrices
14:28:43 <salisbury> acowley: I'm pretty confused though as to actually go about implementing the formula though
14:29:11 <acowley> salisbury: all you need is two vectors and a covariance matrix
14:29:21 <monochrom> if you go after visualization, f a (f b (f c z)) is more susceptible to visualization (draw the parse tree)
14:30:55 <monochrom> (whereas I see no visualization for the word "start")
14:31:07 <Axman6> foldr (+) z (a : (b : (c : [])))
14:31:10 <Axman6>            = (a + (b + (c + z)))
14:31:19 <Axman6> damn, so close
14:31:28 <mm_freak> cl1: you could call z the starting value for foldl, but for foldr it doesn't make sense
14:31:38 <mm_freak> cl1: you might not even reach z ever
14:31:49 <cl1> oh
14:31:58 <monochrom> http://www.haskell.org/haskellwiki/Fold has the visualization pictures I allure to. scroll down for them.
14:32:00 <mm_freak> > foldr (:) undefined [1..]
14:32:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:32:09 <salisbury> acowley: I'm really unfamiliar with vector notations, what is the operation going on   between (x- y)   and   S^-1(x-y)
14:32:20 <monochrom> just memorize those pictures and never bother to use words
14:32:49 <acowley> salisbury: x and mu are column vectors, so (x - mu)^T is a row-vector. So it's a row-vector * matrix * column-vector
14:33:10 <cl1> so then foldr (:) [1,2,3] [1..] would return at least [1,2,3] but maybe more
14:33:21 <cl1> no that's not right
14:33:37 <cl1> >take 2 (foldr (:) [1,2,3] [1..])
14:33:44 <Axman6> it will never get to/evaluate [1,2,3]
14:33:53 <cl1> > take 2 (foldr (:) [1,2,3] [1..])
14:33:54 <lambdabot>   [1,2]
14:33:59 <cl1> how strange
14:34:04 <cl1> > take 2 (foldr (:) [1,2,3] [])
14:34:05 <lambdabot>   [1,2]
14:34:09 <salisbury> acowley: ahh, oh I see now
14:34:11 <salisbury> thanks
14:34:19 <Axman6> > take 2 (foldr (:) [-1,-2,-3] [1..])
14:34:20 <lambdabot>   [1,2]
14:34:27 <monochrom> > take 10 (foldr (:) [1,2,3] [1..])
14:34:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:34:30 <salisbury> am I to assume multiplication when there is no explicit operator?
14:34:34 <cl1> > take 2 (foldr (:) [-1,-2,-3] [])
14:34:35 <lambdabot>   [-1,-2]
14:34:40 <acowley> salisbury: no problem! The Mahalanobis distance is a really cool thing.
14:34:48 <acowley> salisbury: yes
14:34:58 <cl1> > take 4 (foldr (:) [-1,-2,-3] [1,2]])
14:34:59 <lambdabot>   <no location info>: parse error on input `]'
14:35:04 <monochrom> @src (++)
14:35:04 <lambdabot> []     ++ ys = ys
14:35:04 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:35:04 <lambdabot> -- OR
14:35:04 <lambdabot> xs ++ ys = foldr (:) ys xs
14:35:05 <Axman6> cl1: remember, in foldr f z, [] is replaced with z, and (:) is replaced with f
14:35:06 <cl1> > take 4 (foldr (:) [-1,-2,-3] [1,2])
14:35:07 <lambdabot>   [1,2,-1,-2]
14:35:14 <monochrom> you're looking at (++)
14:35:21 <cl1> how interesting
14:35:29 <monochrom> or rather the flip of (++)
14:36:17 <monochrom> otoh it's nice that you consider foldr (:), it tells you a lot
14:36:18 <Axman6> > foldr (&&) True $ [True,False] ++ replicate True -- Infinitely long list, but foldr lets us exit early
14:36:19 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:36:19 <lambdabot>         against inferred type ...
14:36:31 <Axman6> > foldr (&&) True $ [True,False] ++ repeat True -- Infinitely long list, but foldr lets us exit early
14:36:33 <lambdabot>   False
14:36:52 <monochrom> it is more like (&&) lets us exit early
14:37:08 <Axman6> well, sure, but if we used foldl, then that would go on forever
14:37:37 <monochrom> it's a conspiracy of (&&), foldr, and refusing to call-by-value
14:38:49 <cl1> foldr messes with my head
14:39:33 <c_wraith> the function you pass to foldr takes two values:  The current element of the list, and the result of the fold over the rest of the list.
14:39:36 <cl1> i understand how it does (1 + (2 + (3 + z))) but what i don't understand is how it does not evaluate what it doesn't need
14:39:43 <mm_freak> cl1: it's not foldr that messes with your head…  it's laziness
14:40:02 <c_wraith> If the function doesn't cause its second argument to be evaluated, it will stop early
14:40:06 <acowley> cl1: can you evaluate False && _
14:40:09 <Axman6> acowley: with that dot product, what happens if you just use the typical OpenCL dot product without the for loop when run on the CPU? does it get optimised into something similar to your version (or at least perform roughly the same?)
14:40:09 <mm_freak> cl1: note how foldr is productive without going into recursion
14:40:20 <mm_freak> foldr (+) z (x:xs) = x + foldr (+) z xs
14:40:35 <mm_freak> s/without/before/
14:40:52 <drunK> msg lambdabot @src foldr
14:40:55 <drunK> ups
14:41:02 <mm_freak> so if the passed operator (+) is not strict on its second argument, you can actually get the result early
14:41:08 <Axman6> cl1: that's how lazy evaluation works. if f doesn't need its second argument, and can return a value, there's no need for foldr to keep going (well, really the result of foldr applied to the rest of the list is ignored, and never evaluated)
14:41:19 <Axman6> > foldr const 0 [1..]
14:41:20 <lambdabot>   1
14:41:38 <Axman6> which is: const 1 (const 2 (const 3 ...
14:41:53 <Axman6> but, const x y = x, and y is never evaluated
14:42:35 <acowley> Axman6: I think dot is only defined on float, float2, and float4
14:42:59 <cl1> oh, i get it now
14:43:01 <acowley> Axman6: which means at best you can cut your vector of floats in quarter
14:43:10 <acowley> Axman6: but then you still have to do the sum
14:43:24 <mm_freak> cl1: this boils down to nonstrict constructors…  imagine (+) being a nonstrict constructor like Cons for a custom list type
14:43:49 <cl1> maybe
14:43:53 <acowley> Axman6: and the sum is nasty to do on a GPU, but the lesser parallelism on the CPU means it's sensible to max out what cores you have then finish the sum with some sequential code
14:44:05 <Axman6> acowley: oh, so dot is defined by OpenCL, I didn't know that
14:44:13 <cl1> (+) constructs an int
14:44:35 <cl1> more specifically a (Num a)
14:44:39 <mm_freak> (+) is not a constructor by itself, and furthermore it is strict in its second argument
14:44:44 <acowley> Axman6: section 6.11.5
14:44:50 <mm_freak> at least for most numeric types you will encounter
14:45:21 <cl1> wtf does strict in its second argument mean? i've seen that strict nomenclature before
14:45:45 <mm_freak> cl1: x + ⊥ = ⊥
14:46:34 <Axman6> cl1: is f is strict, then f undefined = undefined. if we look at const, it is strict in its first argument (const undefined whatever = undefined) but not in its second (const whatever undefined = whatever, even though we passed it undefined)
14:46:56 <mm_freak> simply put:  the result depends on the second argument
14:47:21 <mm_freak> this is a simplification, and the real deal has to do with constructors and weak-head normal form
14:48:11 <Sgeo> > error undefined
14:48:12 <lambdabot>   *Exception: *Exception: Prelude.undefined
14:48:19 <mm_freak> > fix error
14:48:20 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:48:22 <cl1> and people wonder why others say haskell is difficult to learn
14:48:39 <mm_freak> cl1: you don't really have to know that right now…  don't worry about it
14:49:10 <Axman6> cl1: it's not much more difficult to learn that lambda calculus really
14:49:35 <mm_freak> for now it suffices to simplify:  if (+) needs its second argument for its result, then foldr will produce at the end, and you can see this in its definition:  foldr (+) z (x:xs) = x + foldr (+) z xs
14:50:01 <mm_freak> if (+) needs its second argument, which is the recursive result, you will have to recurse down to the base case to produce a result
14:50:30 <Axman6> cl1: don't forget we're using (+) as a placeholder for any function that takes two arguments of the right types for use with foldr
14:50:42 <cl1> > take 2 (foldr (+) [-1,-2,-3] [1,2,3])
14:50:43 <lambdabot>   No instance for (GHC.Num.Num [t])
14:50:43 <lambdabot>    arising from a use of `e_12123123' at ...
14:51:00 <cl1> oh
14:51:06 <cl1> > take 2 (foldr (+) 42 [1,2,3])
14:51:07 <lambdabot>   No instance for (GHC.Num.Num [a])
14:51:07 <lambdabot>    arising from a use of `e_1242123' at <...
14:51:24 <mm_freak> the result is not a list
14:51:35 <cl1> > take 2 (foldr (+) [] [1,2,3])
14:51:36 <lambdabot>   No instance for (GHC.Num.Num [a])
14:51:36 <lambdabot>    arising from a use of `e_12123' at <in...
14:51:40 <cl1> oh
14:51:44 <Axman6> remember, that when you have foldr f z, the result is z
14:51:49 <Axman6> uh, foldr f z []
14:51:51 <cl1> foldr (+) [-1,-2,-3] [1,2,3]
14:51:58 <cl1> > foldr (+) [-1,-2,-3] [1,2,3]
14:51:59 <lambdabot>   No instance for (GHC.Num.Num [t])
14:51:59 <lambdabot>    arising from a use of `e_1123123' at <...
14:52:06 <cl1> > foldr (+) 42 [1,2,3]
14:52:07 <lambdabot>   48
14:52:14 <cl1> ah ha!
14:52:17 <Axman6> so now you'll have an expression like (... (3 + [-1,-2,-3])
14:52:30 <cl1> Axman6, i see the error of my ways, thanks :)
14:52:47 <mm_freak> cl1: foldr (+) 42 [1, 2, 3] = 1 + foldr (+) 42 [2, 3]
14:53:08 <mm_freak> (+) is a bad choice for experimenting with foldr, btw
14:53:30 <cmccann> heh, I appear to be one of the top google results for the etymology of the word "monad"
14:53:38 <acowley> monads are named after you!?
14:54:02 <cmccann> or rather, a question on one of stack overflow's sibling sites
14:54:09 <cmccann> on which my answer is the accepted one
14:54:23 <cmccann> spoiler: the answer is "beats me"
14:56:26 <truta> i need to run the system function (module System.Cmd) multiple times, and i have a list of strings with the commands i need to run, but if i try to use "map system x" where x equals to a list of strings, it gives me an error :S
14:56:28 <acowley> Can't we just say Leibniz named them and refuse to answer any followup questions?
14:56:46 <mm_freak> truta: try mapM_
14:57:00 <cmccann> acowley, that's the one possible etymology that's almost certainly not the actual one, so sure
14:57:03 <mm_freak> or mapM, if you need the results
14:57:22 <Pseudonym> mm_freak, how fast was your fastest factorial?
14:57:29 <Pseudonym> Not including printing.
14:57:35 <Pseudonym> Of 1,000,000, correct?
14:57:38 <acowley> cmccann: it's an elegant myth that feels right, so I say we all agree to consider it true
14:57:53 <mm_freak> Pseudonym: 1.9 secs for (10^6)!
14:58:01 <Pseudonym> Prelude Factorial> bottomUpFactorial 1000000 `seq` ()
14:58:03 <Pseudonym> (2.30 secs, 268317948 bytes)
14:58:09 <Pseudonym> Probably not a comparable machine, though
14:58:36 <mm_freak> Pseudonym: mine was compiled, btw
14:58:45 <Pseudonym> Mine too.
14:58:59 <mm_freak> not sure if the prime sieving is actually making things worse
14:59:08 <Pseudonym> This one doesn't use prime sieving.
14:59:22 <Pseudonym> For comparison:
14:59:33 <Pseudonym> Prelude Factorial> legendreFactorial 1000000 `seq` ()
14:59:36 <Pseudonym> (3.97 secs, 767726224 bytes)
14:59:53 <Pseudonym> Assuming you're using the same algorithm.
14:59:58 <Pseudonym> Sieving takes 0.80 sec for me.
15:00:01 <mm_freak> Pseudonym: just made a variant with 0.9 secs
15:00:05 <Pseudonym> Cool!
15:00:09 <mm_freak> just use the intProd function for [1..1000000]
15:00:19 <Pseudonym> Where intProd does what?
15:00:23 <mm_freak> the sieving makes things works
15:00:28 <mm_freak> see the paste
15:00:40 <mm_freak> intProd [1,2,3,4] = intProd [1*2, 3*4]
15:00:48 <cmccann> acowley, the only way to know for sure would be to ask the guy who coined the term, if he even remembers
15:00:52 <mm_freak> intProd [2, 12] = 24
15:01:20 <Pseudonym> My intProd equivalent multiplies eagerly until you get bigger than 2^64, then does that algorithm on what's left.
15:01:25 <mm_freak> int = "interleaved"
15:01:45 <acowley> I tried reading Moggi when I first started learning Haskell. Classic newb move on my part.
15:02:12 <mm_freak> Pseudonym: i think you don't really need to do that
15:02:12 <Pseudonym> acowley: http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/5/965006909_4eHkJ#!i=965006909&k=4eHkJ
15:02:27 <Eduard_Munteanu> acowley: wow, hehe
15:03:01 <cmccann> acowley, sounds like a great strategy
15:03:04 <Eduard_Munteanu> "Hey, he's gotta explain monads well in functional programming, right?"
15:03:10 <Pseudonym> The theory is that you do small integer multiplications while you can.
15:03:22 <Pseudonym> And only go to GMP when you blow the limit.
15:03:25 <truta> mm_freak: Thanks, mapM_ worked for me :)
15:03:33 <Axman6> mm_freak: hmm, is that program expected to take the same amount of time roughly for 10e6 and 10e8?
15:03:34 <monochrom> cl1: Haskell's "x+⊥=⊥" is not more difficult to learn than C's "x = x + 1"
15:03:50 <Eduard_Munteanu> Pseudonym: presumably there is a check for that, no?
15:03:53 <mm_freak> Axman6: nope, the complexity should be O(n * log n)
15:04:00 <Eduard_Munteanu> They aren't really as fast as Ints.
15:04:00 <monochrom> namely, "x = x + 1? so subtract x on both sides? 0 = 1?"
15:04:00 <Pseudonym> Eduard_Munteanu: There used to be one exposed.
15:04:14 <Pseudonym> I don't think it's exposed any more.
15:04:20 <Axman6> mm_freak: interesting :o
15:04:24 <acowley> I guess I figured, "Monads seem complicated now, they were probably viewed more naively when invented, so I should start there."
15:04:27 <Pseudonym> Anyway, that trick makes it go from 2.44 sec to 2.29 sec on my machine.
15:04:29 <Axman6> i'm getting almost identicle times no matter what I try
15:04:43 <acowley> But it turns out they started out complicated and have gotten simpler over time!
15:04:52 <Eduard_Munteanu> Pseudonym: hm, how does it work though? Interrupt on overflow?
15:04:55 <mm_freak> Axman6: it needs 19 secs for (10^7)!
15:05:07 <cmccann> acowley, haha
15:05:11 <Eduard_Munteanu> I mean, you have to know when your operation overflows or not.
15:05:14 <Pseudonym> Actually, I just do acc >= 2^64 on this version.
15:05:32 <Axman6> urgh, just realised it's not taking n as a parameter >_<
15:05:45 <Pseudonym> In fact, what you should probably do is look for the point where GMP starts using Karatsuba.
15:06:00 <cl1> so since (:) is not strict in its second argument of: take 2 (foldr (:) [] [1,2,3])  ...
15:06:07 <Eduard_Munteanu> Pseudonym: hm? How do you handle 2^61 * 2^61 (obviously, if they're not known at compile-time)?
15:06:16 <mm_freak> Pseudonym: you exceed that limit pretty quickly, so checking for it probably takes more time that is worth
15:06:22 <mm_freak> that → than
15:06:48 <mm_freak> the naive implementation seems to perform best…  considering that GMP is smart enough to use machine word multiplications where possible
15:07:02 <mm_freak> also GHC compiles to an efficient machine word int, where it can
15:07:09 <Pseudonym> Eduard_Munteanu: What you'd like to do is use the hardware multiplier and then look for a high-word.
15:07:22 <Eduard_Munteanu> mm_freak: you might not want to go through GMP in that cases, unless you do some link-time optimization. That would be my guess.
15:07:24 <Pseudonym> What I actually do is multiply two Integers and then see if it overflowed to a large Integer.
15:07:35 <cl1> because of lazy evaluation it does not have to compute the right hand side of (:) and therefore you get 1:2:(3:[]) but (3:[]) is not evaluated because the calling function does not need it?
15:07:51 <Eduard_Munteanu> Pseudonym: checking the carry flag you mean?
15:07:59 <Axman6> cl1: sure
15:08:02 <mm_freak> Eduard_Munteanu: my guess is that you don't do that anyway, because Integer uses Int# where possible and only resorts to Integer# where needed
15:08:06 <Pseudonym> On x86, multiply takes two words and results in a double word.
15:08:19 <Pseudonym> You can then just check the high word to see if it's zero.
15:08:25 <Eduard_Munteanu> mm_freak: yeah, but it isn't clear to me how it decides which way to go :)
15:08:25 <Pseudonym> Same with MIPS.
15:08:41 <c_wraith> sounds like Pseudonym just answered that
15:08:42 <Pseudonym> I don't think that's how it works on SPARC, though.
15:08:46 <Eduard_Munteanu> Oh.
15:08:48 <mm_freak> Eduard_Munteanu: simple: your whole input list consists of machine word integers, so it starts with them
15:09:00 <mm_freak> then as the products exceed that, it switches to GMP integers
15:09:02 <eikenberry> After installing ghc via the binary package specifying PREFIX... is there a command to change the paths that get hardcoded in the various files?
15:09:02 <monochrom> cl1: you may like my http://www.vex.net/~trebla/haskell/lazy.xhtml
15:09:21 <Pseudonym> In fact, I've manually deforested the list of machine word integers.
15:09:30 <Eduard_Munteanu> mm_freak: yeah, Pseudonym just answered that, my question was how do you tell the products exceed that.
15:09:40 <monochrom> eikenberry: no, there isn't
15:09:41 <mm_freak> Eduard_Munteanu: i don't…  GHC does
15:09:48 <Eduard_Munteanu> Erm, not you, GHC :)
15:09:48 <rwbarton> @src Integer
15:09:49 <lambdabot> data Integer = S# Int#
15:09:49 <lambdabot>              | J# Int# ByteArray#
15:09:59 <Eduard_Munteanu> (or actually, compiled code)
15:09:59 <rwbarton> oh, GHC
15:10:05 <Pseudonym> Bingo.
15:10:16 <mm_freak> Eduard_Munteanu: as long as your result is a single machine word, it keeps machine words
15:10:17 <eikenberry> monochrom. sucks, but thanks.
15:10:51 <Eduard_Munteanu> So I guess the overhead is just a check on rdx (?, IIRC) being zero.
15:10:54 <mm_freak> something like: [w, w, w, w, w, w, w, w] -> [w, w, int, int] -> [w, int] -> [int]
15:11:01 <mm_freak> where w is a machine word and int is a GMP integer
15:11:29 <mm_freak> the divide-and-conquer structure of the algorithm alone ensures that you work with machine integers as long as possible
15:11:45 <Eduard_Munteanu> Hm, that's nice.
15:12:07 <Pseudonym> mm_freak: As noted, it may be slightly advantageous not to generate a list of machine words.
15:12:17 <mm_freak> let me try something…  i think i can make this even faster =)
15:12:26 <Pseudonym> But rather do a foldl-like algorithm to multiply eagerly until you blow the limit of a machine word.
15:12:51 <Pseudonym> Either way, it's the multiplies which are the costliest bit.
15:12:57 <Eduard_Munteanu> I guess you can optimize for "small" numbers by enabling interrupt overflows?
15:13:07 <Eduard_Munteanu> erm, overflow interrupts
15:14:42 <Pseudonym> I suspect that interrupt delivery is going to be more expensive than most arithmetic alternatives.
15:15:09 <Pseudonym> For example, even if you don't have a word * word = dword instruction, you can get most of the way there using a priority encoder instruction.
15:15:44 <Pseudonym> ABM, for example, gives you count-leading-zeroes.
15:15:47 <Eduard_Munteanu> I suppose you'd want to do that for plain Ints maybe, since it's zero-overhead as long as your assumptions aren't broken :/
15:16:08 <Pseudonym> Which tells you the order of magnitude of your numbers.
15:16:14 <Eduard_Munteanu> ABM? I know SSE gives you LZCNT
15:16:22 <Pseudonym> Ah, yes.
15:16:25 <Eduard_Munteanu> (some SSE)
15:16:28 <Pseudonym> I was thinking of find-first-set.
15:16:33 <Pseudonym> Which is ABM.
15:17:27 <Pseudonym> Right, so if 64 - (lzcnt(x) + lzcnt(y)) is greater than zero, the multiply won't overflow a word.
15:17:42 <Pseudonym> Or something.
15:17:58 <Pseudonym> Probably an off-by-one error or two in there.
15:18:02 <Eduard_Munteanu> Well, I'd just do a simple check after doing the multiply anyway.
15:18:33 <Eduard_Munteanu> Otherwise it seems it's hurting both code paths more.
15:19:07 <Pseudonym> Interrupt delivery is slow on most modern CPUs.
15:19:17 <Pseudonym> Flushing the pipeline is about the worst thing you can do.
15:20:10 <masylum> hi
15:20:12 <acowley> The all black OpenGL window has to be one of the most depressing things to debug
15:20:14 <Eduard_Munteanu> Yeah, it should be used as panic check, if anything. Unless you strongly assume no/few overflows during normal operation.
15:20:22 <Eduard_Munteanu> masylum: hi
15:20:46 <Eduard_Munteanu> Pseudonym: however it's free if no overflow occurs.
15:21:00 <Eduard_Munteanu> (no interrupt, no overhead, I mean)
15:21:16 <Pseudonym> But it will happen O(n) times when you calculate n!
15:21:27 <Eduard_Munteanu> But anyway, I guess you can also check the overflow flag explicitly, no? IIRc.
15:21:36 <Eduard_Munteanu> Yeah.
15:21:51 * Eduard_Munteanu isn't aware what started this discussion
15:22:59 <eikenberry> monochrom. Was able to do it with a simple sed script and ghc-pkg recache.
15:23:08 <Pseudonym> acowley: In general, the black image is either depressing or Zen.
15:23:08 <eikenberry> At least ghci runs w/o a problem.
15:23:12 <Pseudonym> It's all in the attitude.
15:23:33 <mm_freak> ok, i couldn't optimize further
15:24:12 <AfC> I wonder what to of the Enumerator -> Conduit movement happening.
15:24:14 <Pseudonym> acowley: Do you have any good "bug as artist" images yet?
15:24:21 <AfC> I've looked at Conduit a bit, trying to decide whether I think the design pattern is sound (or at least, more advantageous than Interatees).
15:24:47 <AfC> ...what to think* of...
15:24:57 <Eduard_Munteanu> mm_freak: factorial? Code? :)
15:25:03 <acowley> Pseudonym: I've generated hundreds over the years, but I tend not to keep them. I think they're best appreciated between 2-4am (i.e. when they occur most frequently), but lose some of their essential appeal after that.
15:25:17 <Pseudonym> I've got some that are too good to lose.
15:25:49 <Pseudonym> In fact, I posted a couple to deviantArt.
15:26:10 <Pseudonym> http://deguerre.deviantart.com/#/d3i9hf4
15:27:50 <Pseudonym> But here's my absolute favourite: a fluid simulation which blew up when an eddie hit the edge of the chamber.
15:27:56 <irene-knapp> heh, cute
15:27:59 * irene-knapp just walked in :)
15:28:01 <Pseudonym> http://andrew.bromage.org/fluids/bug.mpeg
15:28:42 <irene-knapp> neat-looking
15:28:52 <irene-knapp> PostScript programming also produces cool-looking bugs, depending on what you're doing
15:28:55 <Pseudonym> Yeah.
15:29:38 <Pseudonym> This, by the way, is with the bug fixed: http://andrew.bromage.org/fluids/eddies.mpeg
15:30:29 <irene-knapp> ah cool
15:30:33 <cmccann> I think I like the buggy version better
15:30:36 <cmccann> should've kept it
15:31:02 <Pseudonym> Unfortunately, I was solving a singular matrix, so the universe could have ended.
15:31:17 <acowley> Are you sure it didn't?
15:31:25 <Pseudonym> Not for sure.
15:31:43 <monochrom> eikenberry: nice, the package database is the hardest part.
15:32:02 <ion> Wow. This bug looks awesome. http://deguerre.deviantart.com/art/Depth-of-Field-Bug-212074096
15:32:12 <eikenberry> monochrom. yeah, it didn't like it at first, but the recache command seemed to fix it.
15:41:23 <cygnus_> what is a good editor for haskell for linux?
15:41:37 <sipa> edlin, in dosbox
15:41:43 <cmccann> haha
15:41:54 <ion> teco
15:41:59 * cmccann uses SciTE, which is adequate
15:42:26 <cygnus_> is there a command line version?
15:42:39 * ion uses GVim, which is adequate. Should get around to looking for some plugin that implements better autoindentation etc.
15:43:10 <Eduard_Munteanu> cygnus_: vim, emacs ...
15:43:17 <acowley> emacs emacs emacs!
15:43:29 <cygnus_> ok
15:44:48 <Axman6> cygnus_: whatever editor you're mose used to
15:45:24 <mm_freak> Eduard_Munteanu: the current state is my intProd implementation from earlier
15:45:27 <cygnus_> I tried using vim but it doesn't keep the indentation
15:45:57 <Ke> cygnus_: http://www.vim.org/scripts/script.php?script_id=1968
15:46:03 <cygnus_> thanks
15:47:06 <Ke> cygnus_: haskellindent in gentoo
15:47:23 <hpaste_> “Ertugrul Söylemez” pasted “Fast integer factorial (2)” at http://hpaste.org/56331
15:47:25 <Ke> might be available elsewhere too
15:47:29 <mm_freak> Eduard_Munteanu: see paste
15:47:45 <mm_freak> (10^6)! in 0.9 secs
15:47:49 <mm_freak> (10^7)! in 19 secs
15:48:17 <mm_freak> i think this is about the limit in idiomatic haskell…  if you want more speed, you need to get below the high level
15:48:44 <Eduard_Munteanu> mm_freak: ah, idiomatic
15:48:46 <mm_freak> but 0.9 secs for (10^6)! isn't that bad =)
15:53:17 <Eduard_Munteanu> Presumably you could see some improvements by doing stuff in ST or even PrimMonad, I guess.
15:53:27 <Eduard_Munteanu> But I'm unsure if it lets you handle Integers better.
15:53:34 <mm_freak> actually i'm not sure about that
15:53:59 <mm_freak> but yeah, i have an idea for a further improvement
15:53:59 <ion> There seems to be a symbol that looks like >>- (⤜), but nothing that looks like >>=.
15:57:46 <rwbarton> mm_freak: one way to make it a bit faster is to (pseudo)randomly permute [1..10^6] first
15:58:14 <rwbarton> oh actually I had a bug
15:59:37 <rwbarton> hmm, seems to be a bit slower now
15:59:46 <Sgeo> PrimMonad?
15:59:48 <Sgeo> @hoogle PrimMonad
15:59:49 <lambdabot> No results found
15:59:49 <c_wraith> heh.  randomly thinking about the factorial thing, and it occurred to me that the optimal multiplication order would be to throw the numbers into a priority queue.
16:00:13 <Axman6> Sgeo: PrimMonad is usually either ST s or IO
16:00:18 <c_wraith> take the bottom two out, multiply them, insert the new result
16:00:45 <c_wraith> And I laughed at the similarity for building a tree for huffman encoding
16:00:55 <c_wraith> err, *to building...
16:03:23 <c_wraith> Hmm.  And you could be clever and do this in such a way as to only build the priority queue with products, so it never is near the full million entries
16:05:15 <Axman6> hmm, is a priority queue really necessary?
16:05:23 <acowley> Pseudonym: Here's a fresh off the GPU bug art image for you: http://imgur.com/5uAav
16:05:39 <c_wraith> necessary?  probably not.  but it does give you optimimum ordering for keeping numbers small as long as possible
16:06:29 <mm_freak> rwbarton: no, i'd expect that to slow things down
16:06:51 <mm_freak> rwbarton: the good thing about the ordered list is that GHC will have an easier time finding out when it can use machine word multiplication
16:16:19 <mmos1127> I've been using 'catches' from Control.Exception, to handle multiple exception types. I need to change my code so that it does one thing if an exception, and something else if no exception. I looked at 'try' but it only takes one handler. What can I do to get something like 'try' but take multiple handlers?
16:17:16 <shachaf> mmos1127: Can you give an example of the behaviour you want?
16:17:34 <mmos1127> okay I'll code it up at hpaste
16:17:58 <ion> Put the thing to do in case of no exception just after the code that potentially raises an exception.
16:18:32 <parcs`> but if _that_ code raises an exception, it will be caught by the 'catch'
16:18:35 <parcs`> which he may not want
16:20:45 <hpaste_> mmos1127 pasted “exception” at http://hpaste.org/56332
16:21:18 <shachaf> mmos1127: Why not have "result" do that something?
16:21:24 <shachaf> s/result/runSomeStuff/
16:21:53 <shachaf> I.e., result <- do { runSomeStuff; somethingHere } `catches` allHandlers
16:22:01 <mmos1127> shachaf: I don't understand; result is data .. ???
16:22:12 <mmos1127> ah...
16:22:13 <shachaf> mmos1127: Yes, I meant to say "runSomeStuff".
16:22:58 <mmos1127> oh, but parcs' pointed out that an exception raised in somethingHere will be caught by the same handler which is not ideal
16:23:09 <shachaf> Oh, I see.
16:23:17 <shachaf> Well, you could add a second handler. :-)
16:24:00 <mm_freak> Eduard_Munteanu: even a variant using STArray is slower than the list-based intProd
16:24:25 <mm_freak> i'll give it one last shot
16:24:51 <mmos1127> shachaf: by the smiley I presume you are joking.. but not sure, so I'll say that somethingHere could raise some of the same types of exceptions as runSomeStuff
16:25:17 <shachaf> mmos1127: I meant a handler around somethingHere, to catch the same types of exceptions and ignore them.
16:26:22 <mmos1127> schachaf: interesting, at least I could get it to work. I'm kinda beginnerish so a lot of time I content myself with writing imperfect code that nonetheless works.
16:30:52 <parcs`> mmos1127: you can have somethingHere return Just (), and the handlers return Nothing. then you can pattern match on result to tell whether an exception was raised
16:31:15 <mmos1127> parcs': thanks
16:31:29 <c_wraith> Uh.  is that more information than a bool?
16:32:31 <cmccann> c_wraith, (Just _|_)
16:32:39 <parcs`> :P
16:32:39 <cmccann> if you want to be picky about it
16:32:53 <c_wraith> Yes, but I don't think that case will be used, by parcs` description of it :)
16:33:49 <parcs`> yeah i don't know why i said Maybe ()
16:33:58 <parcs`> probably because of all the hate speech about Bool :P
16:34:02 <mmos1127> An annoying thing which maybe someone can solve: since a handler type has to match the computation it catches, I find myself writing handlers like (\e -> do { handlerIWishICouldHaveJustUsed e; return <whatever needed>})
16:34:46 <irene-knapp> mmos1127: is the problem that handlerIWishICouldHaveJustUsed has a more general type?
16:34:56 <ion> \e -> <whatever needed> <$ handler e
16:35:20 <mmos1127> irene-knapp: not the type that's needed anyway.. not sure what a more general type is
16:35:49 <mmos1127> also <whatever needed> is annoying because you need some kind of value even though it's never used
16:35:52 <irene-knapp> like, if the type that were needed were Foo, and the type of the handler were ClassOfWhichFooIsAMember someInstance => someInstance
16:35:54 <mauke> are you complaining that the type checker won't accept programs with type errors?
16:36:09 <mmos1127> mauke: YES YOU GOT IT :)
16:36:26 <aavogt> @hoogle void
16:36:26 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
16:36:26 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
16:36:26 <lambdabot> package void
16:36:39 <shachaf> c_wraith: I assumed that the parentheses weren't a 0-tuple but a placeholder.
16:37:31 <parcs`> mmos1127: runSomeStuff `catches` map (whateverNeeded <$) allHandlers
16:38:07 <parcs`> wait that won't work
16:40:06 <parcs`> i wonder why Handler isn't a functor
16:40:43 <jeff_s_> I'm on Mac OS X 10.4. How do I get ghci to know where to find a library? I've been looking through the GHC user guide and haven't found the right option to add a library path.
16:40:46 <mmos1127> is there a typeclass that has a "default" value? Like empty or 0?
16:41:12 <shachaf> mmos1127: There's Monoid.
16:41:58 <jeff_s_> mmos1127: MonadPlus?
16:42:34 <MostAwesomeDude> :t mempty
16:42:35 <lambdabot> forall a. (Monoid a) => a
16:43:00 <Axman6> :t mappend
16:43:01 <lambdabot> forall a. (Monoid a) => a -> a -> a
16:43:16 <parcs`> @src Handler
16:43:17 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:43:20 <dgpratt> so is acid-state genius or insanity...or both?
16:43:48 <aavogt> jeff_s_: if the library is a bunch of .hs files (not packaged with cabal) you can specify a path to those with -i
16:44:25 <jeff_s_> aavogt - Hm, I think that's not quite what I want.
16:44:29 <aavogt> normally you don't have to specify where things are installed to
16:44:32 <jeff_s_> Specifically, I'm looking to solve this problem: can't load .so/.DLL for: odbc (dlopen(libodbc.dylib, 9): image not found)
16:45:23 <Axman6> jeff_s_: it's the same options you'd use for a C compiler: -L/path/to/foo/lib (ie, -L/usr/local/lib)
16:45:48 <roconnor> > 256^64 == 2^256
16:45:49 <lambdabot>   False
16:46:39 <jeff_s_> Axman6 - no change, and I know the file is in the directory I'm passing.
16:47:41 <parcs`> data Handler a where Handler :: Exception e => (e -> IO a) -> Handler a -- this could be a functor, right?
16:48:43 <copumpkin> yeah, it's a composition of Exception e => Reader e and IO
16:49:35 <Peaker> @type Control.Exception.try
16:49:36 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
16:49:39 <Sgeo> If I have a Typeable packed into a data type via ExistentialQuantification or something, can I bring it back to the original type via cast?
16:49:50 <Peaker> Does it catch all IO exceptions, if e = IOError?
16:50:11 <copumpkin> Sgeo: sort of
16:50:19 <Cody_> other than the 99 haskell programs and project euler, any other haskell problems to solve? LYAH doesn't really provide any.
16:50:21 <copumpkin> Sgeo: cast returns a Maybe in case you try casting it to the wrong type
16:50:23 <parcs`> it doesn't have a functor instance though.. someone should propose a library amendment
16:50:33 <Cody_> problems*
16:50:41 <_riba> "inferred type is not general enough" - what? :(
16:50:44 <Sgeo> copumpkin, but if I do what I suggested, will it always be Nothing?
16:50:51 <copumpkin> Cody_: you could do dibblego's intermedia problems
16:51:02 <aavogt> and if the typeable instance lies you could run into problems
16:51:04 <copumpkin> Sgeo: if you try to cast it to the original type, you'll get a Just
16:51:56 <parcs`> it could be made into an applicative too, and a monad
16:52:05 <Cody_> copumkin: That is actually perfect because just got to the chapter with types.
16:52:17 <Eduard_Munteanu> _riba: what's the exact error?
16:52:29 <copumpkin> Cody_: oh  sorry, I forgot to link
16:52:31 <copumpkin> did you find them?
16:52:39 <Cody_> Yea, I googled it.
16:52:43 <copumpkin> cool :)
16:53:18 <copumpkin> Cody_: those problems are actually kind of like proving theorems, but even apart from that being able to reason about types is a useful skill
16:53:40 <slack1256> on Control.Parallel.Strategies the Eval monad is defined in a newtype that includes State# RealWorld
16:53:44 <cl1> monochrom, thanks for the link, that helped with the lazy eval stuff
16:53:55 <slack1256> but in the documentation says that the eval monad is referential transparent
16:53:58 <slack1256> how that could be?
16:54:05 <Cody_> copumkin: Do you know where the answers are?
16:54:16 <_riba> Eduard_Munteanu: I want to use "Eq a", it tells me my inferred type is "Eq Integer"
16:54:23 <monochrom> nice, you're welcome
16:54:33 <copumpkin> Cody_: in your haskell typechecker :)
16:54:41 <copumpkin> Cody_: not sure there are any publicly
16:55:00 <Cody_> type checker works :)
16:55:06 <Sgeo> http://codepad.org/5Gl80nwL
16:55:07 <copumpkin> Cody_: by that I mean that the typechecker can check your answers, but it won't reveal the right answer
16:55:09 <Sgeo> :/
16:55:21 <Cody_> I know.
16:55:38 <Eduard_Munteanu> _riba: well, something's wrong in your code then, what do you want to do? Paste?
16:56:04 <Eduard_Munteanu> Some function you're calling might work only on Integers.
16:56:37 <Eduard_Munteanu> Then 'a' gets inferred to be an Integer.
16:57:35 <Eduard_Munteanu> s/'a'/that supposedly polymorphic value/
16:58:21 <jeff_s_> I fixed it. I had to add /opt/local/lib to the extra-libs-dir field of HDBC-odbc.cabal.
16:58:27 <jeff_s_> Then reinstall it.
16:58:55 <Sgeo> http://codepad.org/LwMbArzs WHEEEEEEE
17:00:19 <Sgeo> Now that (after several failed attempts) I see what doing that looks like, it makes sense that that works
17:01:30 <Sgeo> Hmm, Data.Dynamic doesn't rely on ExistentialQuantification
17:01:59 <Sgeo> It instead uses unsafeCoerce
17:02:39 <shachaf> Makes a lot more sense.
17:02:39 <_riba> Eduard_Munteanu: In that function, I'm just calling functions that already worked, and elem, which works with "Eq a", but after several hours I'll just give up and try to do the next assignment. Thanks anyway.
17:04:35 <siracusa> _riba: Can you paste your function?
17:06:48 <Cody_> > let mult a b = [sum (zipWith (*) ar bc) | bc <- (transpose b), ar <- c] in mult [[2,4],[5,4]] [[3,3],[8,5]]
17:06:49 <lambdabot>   Couldn't match expected type `[t]'
17:06:49 <lambdabot>         against inferred type `SimpleRef...
17:07:17 <Cody_> > import Data.List
17:07:18 <lambdabot>   <no location info>: parse error on input `import'
17:07:43 <Cody_> > let mult a b = [sum (zipWith (*) ar bc) | bc <- (transpose b), ar <- a] in mult [[2,4],[5,4]] [[3,3],[8,5]]
17:07:44 <lambdabot>   [38,47,26,35]
17:08:06 <Cody_> > let mult a b = [sum (zipWith (*) ar bc) | bc <- (transpose b), ar <- a] in [[2,4],[5,4]] `mult` [[3,3],[8,5]]
17:08:07 <lambdabot>   [38,47,26,35]
17:08:25 <Cody_> > let mult a b = [[sum (zipWith (*) ar bc) | bc <- (transpose b)] ar <- a] in [[2,4],[5,4]] `mult` [[3,3],[8,5]]
17:08:26 <lambdabot>   <no location info>: parse error on input `<-'
17:08:50 <Cody_> > let mult a b = [[sum (zipWith (*) ar bc) | bc <- (transpose b)] | ar <- a] in [[2,4],[5,4]] `mult` [[3,3],[8,5]]
17:08:50 <lambdabot>   [[38,26],[47,35]]
17:16:37 <Cody_> :t length
17:16:37 <lambdabot> forall a. [a] -> Int
17:16:45 <Cody_> :t maximum
17:16:46 <lambdabot> forall a. (Ord a) => [a] -> a
17:18:00 <Cody_> When you call maximum on a [Char], does it follow the ascii chart?
17:18:27 <mauke> yes
17:18:35 <monochrom> the unicode chart
17:18:40 <Axman6> Char has many more characters than Ascii
17:19:09 <DanBurton> > max 'z' 'A'
17:19:10 <lambdabot>   'z'
17:19:27 <DanBurton> min 'Z' 'a'
17:19:36 <DanBurton> > min 'Z' 'a'
17:19:37 <lambdabot>   'Z'
17:19:57 <Cody_> I see
17:20:03 <Axman6> > ['\0'..]
17:20:04 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
17:20:17 <Cody_> Huh?
17:20:20 <DanBurton> lol
17:20:30 <DanBurton> > ['a'...]
17:20:31 <lambdabot>   A section must be enclosed in parentheses thus: ('a' ...)Not in scope: `...'
17:20:36 <DanBurton> > ['a'..]
17:20:37 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
17:20:57 <Cody_> > ['a','c',..]
17:20:58 <lambdabot>   <no location info>: parse error on input `..'
17:21:02 <Cody_> > ['a','c'..]
17:21:03 <lambdabot>   "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\153\15...
17:21:33 <DanBurton> > ['z', 'y', .. 'A']
17:21:34 <lambdabot>   <no location info>: parse error on input `..'
17:21:38 <DanBurton> doh
17:21:41 <DanBurton> > ['z', 'y' .. 'A']
17:21:42 <lambdabot>   "zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA"
17:25:14 <Cody_> Is there a website that displays the type classes? Such as Eq, Num, Ord.
17:25:27 <mauke> @where prelude
17:25:27 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
17:26:17 <Axman6> @where typeclassopaedia
17:26:18 <lambdabot> I know nothing about typeclassopaedia.
17:26:20 <Cody_> mauke: Awesome, it even shows the functions that use it
17:26:26 <Axman6> hmm,. i have no idea how to spell that >_<
17:26:34 <Eduard_Munteanu> http://www.haskell.org/haskellwiki/Typeclassopedia
17:26:47 <Cody_> Axman6: I have typeclassopedia bookmarked for a different day.
17:27:11 <JoeyA> Is it possible to use GeneralizedNewtypeDeriving to automatically create a MonadTrans instance?
17:27:29 <Eduard_Munteanu> Cody_: of course, those aren't all the typeclasses. You can define your own ones in Haskell, many packages do.
17:27:30 <JoeyA> I'm trying to derive such an instance from a newtype wrapper around StateT, but I get a kind error.
17:27:52 <JoeyA> newtype RecvM a = RecvM { unRecvM :: StateT RecvState IO a } deriving (Monad, Functor, Applicative, MonadIO, MonadTrans)
17:28:06 <JoeyA> If I take out MonadTrans, it compiles (I'm on GHC 7.2.2)
17:28:28 <Axman6> doesn't the m need to be exposed to be a monad transformer?
17:28:31 <Eduard_Munteanu> JoeyA: well, it's not a monad transformer
17:28:35 <JoeyA> Ah, right
17:28:46 <Cody_> Edward_Munteanu: Not at the ability to do that yet, gonna memorize the typeclasses for prelude.
17:28:56 <JoeyA> Thanks
17:29:02 <Axman6> it needs to transform other monads, not just one
17:29:30 <JoeyA> Even ostriches are mighty fine, see Ryan?
17:29:34 <Axman6> @google bernie pope haskell prelude
17:29:36 <lambdabot> http://www.cs.mu.oz.au/172/Haskell/tourofprelude.html
17:30:02 <Axman6> Cody_: that is also an excellent link for what youre after i think
17:30:08 <Cody_> Golden^
17:30:08 <DanBurton> @where+ typeclassopaedia Try the American English spelling: Typeclassopedia
17:30:09 <lambdabot> I will never forget.
17:30:32 <Eduard_Munteanu> There was a tree of typeclasses somewhere.
17:30:34 <Axman6> thanks DanBurton =)
17:30:37 <DanBurton> :)
17:30:42 <JoeyA> Bah, left out Enum, Bounded, Num, Real, Integral, Fractional, Floating, RealFrac, and RealFloat.
17:30:51 <Axman6> Eduard_Munteanu: at the end of the link i just googled
17:31:19 <JoeyA> Eric bought nine real integral fractions, floating really roughly.
17:31:35 <Eduard_Munteanu> Axman6: hm, it doesn't show up
17:32:13 <DanBurton> Axman6: I just added a redirect on the wiki
17:32:16 <DanBurton> @wiki typeclassopaedia
17:32:17 <lambdabot> http://www.haskell.org/haskellwiki/typeclassopaedia
17:32:23 <Cody_> Why are there so many typeclasses, wouldn't it make sense to have "one universal" type class?
17:32:40 <Axman6> Cody_: how does that make any sense?
17:32:51 <DanBurton> Cody_: well of course not! Not everything fits into every typeclass
17:33:01 <DanBurton> different typeclasses classify different types
17:33:02 <Axman6> Eduard_Munteanu: http://ww2.cs.mu.oz.au/~bjpop/papers/haskell.tour.tar.gz should have it i think
17:33:03 <Rotaerk> the only universal typeclass is one which has no functionality
17:33:08 <Rotaerk> because everything can support that
17:33:36 <parcs`> there should be a type class for every function!
17:33:38 <Eduard_Munteanu> Cody_: typeclasses are a way to restrict polymorphism
17:33:47 <mauke> http://okmij.org/ftp/Haskell/types.html#Haskell1
17:33:52 <augur> conal!
17:33:56 <augur> TVs!
17:33:57 <augur> :o
17:34:00 <mauke> Rotaerk, Axman6: ^
17:34:05 <DanBurton> typeclass Thing a where thing :: a -- how's that?
17:34:06 <Cody_> Axman6: I thought typeclasses were extra fluff.  Thanks Edward_Munteanu
17:34:19 <conal> does anyone know where the pair-with-monoid (unwrapped Writer) monad instance is? i think someone pointed me to it a while ago, and now i've forgotten.
17:34:22 <Eduard_Munteanu> By providing a class context for a certain polymorphic type, you state you only want certain types there, which have certain operations and Haskell lets you use those.
17:34:23 <Axman6> Cody_: if there was a universal class for numbers like i think you're after, then you'd be able to do tnings like pi :: Integer... and get 3, which isn't very useful
17:34:34 <Eduard_Munteanu> Cody_: consider...
17:34:41 <Eduard_Munteanu> :t (*)
17:34:42 <lambdabot> forall a. (Num a) => a -> a -> a
17:35:11 <Eduard_Munteanu> :t (+ 5)
17:35:11 <conal> augur: hey there. i'm hoping to resurrect the TV stuff soon. wxHaskell is getting some love these days.
17:35:12 <lambdabot> forall a. (Num a) => a -> a
17:35:19 <shachaf> I think Cody_'s question makes a lot less sense than the answers to it are assuming. Type classes can be of different kinds.
17:35:22 <Eduard_Munteanu> You can't do that to any type out there.
17:35:35 <Eduard_Munteanu> If that was completely polymorphic, Haskell wouldn't let you.
17:35:36 <Cody_> I'd see the problem
17:35:42 <Cody_> I see*
17:35:52 <DanBurton> > truncate pi
17:35:53 <shachaf> conal: Are you sure that instance is defined anywhere?
17:35:53 <lambdabot>   3
17:35:59 <shachaf> I'm pretty sure it's not in the standard library.
17:36:05 <Cody_> Haskell would get confused, right?
17:36:06 <conal> shachaf: no i'm not sure.
17:36:23 <Axman6> mauke: ew :(
17:36:26 <Eduard_Munteanu> Cody_: it wouldn't, it'd reject it and blame the user :P
17:36:42 <augur> conal: only sort of relatedly, ive wanted for a long time to make a GUI framework that emphasizes data-oriented programs
17:36:50 * Cody_ understands why we need typeclasses
17:37:07 <augur> where each program is a small little box that does one thing, and you just manipulate data according to what can be done with it
17:37:11 <augur> no documents, no programs
17:37:25 <augur> just values plus generic services that you can do
17:37:38 <shachaf> conal: Applicative has an Applicative instance.
17:38:07 <conal> shachaf: yeah. and Control.Monad.Instances has the Functor instance, but not Monad instance. odd!
17:38:08 <shachaf> conal: Maybe that's what you're thinking of?
17:38:25 <shachaf> conal: Maybe it's in order not to break compatibility with existing code that defines it?
17:38:48 <shachaf> That's kind of silly, though.
17:39:00 <shachaf> (Unless it's in the Prelude.)
17:39:01 <conal> shachaf: i hope that's not why. i'd rather break such code.
17:39:09 <augur> conal: and your TV stuff reminded me of that.
17:39:09 <augur> so
17:39:10 <augur> <3
17:39:16 <conal> augur: :)
17:39:33 <conal> i think someone pointed me that elusive monad instance here a few months ago. can't find it in the #haskell logs.
17:39:42 <conal> i'll fire off a haskell-cafe note.
17:40:13 <conal> did it.
17:40:24 <shachaf> conal: I just searched the big directory that I `cabal unpack` everything into, and couldn't find it.
17:41:06 <shachaf> "everything" isn't everything on Hackage, of course, but it's 74 packages.
17:44:37 <conal> shachaf: good idea. thx.
17:45:00 <luite> hmm, how did you search? I do have a directory with everything from hackage
17:45:09 <shachaf> luite: I used ack.
17:45:13 <shachaf> I presume grep would work too.
17:45:22 <shachaf> My directory is only 54MB.
17:47:54 <luite> mine is 3.8GB
17:48:14 <shachaf> luite: Does yours have every version of every package?
17:48:23 <luite> yeah, in git repo's
17:48:31 <shachaf> Oh.
17:48:35 <shachaf> Well, that would explain it.
17:48:45 <shachaf> At least ack doesn't search .git.
17:52:08 <luite> hmm, maybe adding a full-text search index would be useful
17:53:12 <shachaf> luite: Doesn't help when you want to search for things like /\(?Monoid.*\(\(,/ :-)
17:53:31 <shachaf> Well, I suppose it does.
17:53:39 <shachaf> If you just want to search for lines that say Monoid.
17:53:54 <shachaf> But regexps are often more complicated.
17:54:07 * cmccann is suspicious that the instance in question is a myth
17:54:13 <luite> yeah it's more limited than a full grep, but sphinx does support some position based querying, and it would be fast enough to run it on hdiff.luite.com
17:54:57 <shachaf> Google has a regexp-based Code Search that they're shutting down in 5 days. :-(
17:55:28 <luite> yeah I wonder when they'll be shutting down + :)
17:56:50 * cmccann is amused that attempting to find the missing Monad instance has so far turned up at least three different people asking "where is this instance?"
17:56:55 <cmccann> but no actual instance anywhere
17:57:04 <shachaf> cmccann: Who else?
17:57:13 <shachaf> I've seen conal ask it multiple times, but no one else mention it.
17:57:42 <Cody_> Just to be clear, you can't use any function of the Enum typeclass on lists?
17:57:43 <cmccann> luqui and edwardk
17:58:01 <cmccann> on stack overflow and in #haskell respectively
17:58:04 <shachaf> Cody_: If lists are instances of Enum, then yes. If not, then no.
17:58:11 <cl1> i just read up on phantom types, are they very useful or a neat parlor trick?
17:58:32 <cmccann> e.g. http://stackoverflow.com/q/4204086/157360
17:58:34 <shachaf> cl1: They're useful when you need them.
17:58:53 <shachaf> cmccann: Ah, StackOverflow.
17:58:59 <cl1> shachaf .. are they frequently needed?
17:59:02 <Cody_> shachaf: Thanks, LYAH didn't explain it that well.
17:59:06 <shachaf> cl1: It depends on what you're doing.
17:59:14 <shachaf> Cody_: Hmm? That's how all type classes work.
17:59:59 <shachaf> cmccann: How's the competition with ehird going?
18:01:25 <_riba> http://www.complang.tuwien.ac.at/knoop/lehre/ws1112/fp185A03/fp_lu09_testfaelle
18:01:27 <cmccann> shachaf, he's still outclassing me completely in points per day but he's got a long ways to go before catching up
18:01:32 <cmccann> :P
18:01:39 <_riba> How do I test this effectively?
18:01:56 * hackagebot PrimitiveArray 0.1.1.2 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.1.1.2 (ChristianHoener)
18:02:02 <shachaf> cmccann: ehird = elliott, by the way.
18:02:19 <_riba> At the beginning, I used ghci and "let", but the tests are getting more and more complicated
18:03:20 <cmccann> shachaf, ugh, the ambiguous name
18:03:49 * cmccann can never keep track of how many people have some variation on that name :P
18:06:08 <cmccann> http://www.haskell.org/pipermail/libraries/2011-November/017153.html
18:06:20 <cmccann> more evidence for the instance apparently nonexisting
18:06:37 <exFalso> good evening. i'm trying to use ghc for profiling. i recompiled all libraries with profiling turned on, and the results are showing a big bottleneck in one module.however it doesn't expand on functions
18:06:55 <exFalso> *on what functions are causing the bottleneck
18:07:14 <exFalso> is there a way to make the profiling more verbose?
18:08:31 <Eduard_Munteanu> exFalso: did you use -prof-all?
18:09:20 <exFalso> Eduard_Munteanu: no i used -prof, will try that thanks
18:09:42 <Cody_> :t length
18:09:43 <lambdabot> forall a. [a] -> Int
18:09:53 <luite> -auto-all is what you might be looking for
18:10:01 <Cody_> forral a. (Num a) -> [a] -> int
18:10:20 <exFalso> yeah it doesnt recognise -prof-all, will try auto-all
18:10:35 <luite> that inserts cost centers for all top-level functions
18:10:55 <luite> otherwise add your SCC manually
18:11:56 * hackagebot BiobaseXNA 0.6.0.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.6.0.0 (ChristianHoener)
18:12:03 <exFalso> luite: how would one go about that?
18:12:40 <Eduard_Munteanu> Erm, right, sorry
18:15:25 <luite> exFalso: the RWH chapter about optimization has some examples
18:15:54 <exFalso> thanks i'll check that out
18:16:56 * hackagebot angel 0.3.1 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.3.1 (JamieTurner)
18:17:04 <exFalso> and -auto-all worked :D
18:26:56 * hackagebot tagstream-conduit 0.2.1 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.2.1 (YiHuang)
18:37:52 <hugoestr> Hi. I am working through Haskell 99 questions to learn and practice the language. In one of the solutions, they show this line of code: data NestedList a = Elem a | List [NestedList a] Where does Elem and List come from?
18:38:53 <geekosaur> huh?  that's their definition
18:38:59 <shachaf> hugoestr: That defines them.
18:39:06 <shachaf> hugoestr: Just like saying data Maybe a = Just a | Nothing
18:39:15 <geekosaur> it declares a type constructor NestedList which has two data constructors, Elem and List
18:40:14 <djahandarie> Sometimes I wonder why we don't just use GADTs everywhere.
18:40:21 <hugoestr> geekosaur, So I don't have to define them before?
18:40:31 <truta> nop
18:40:51 <geekosaur> correct, you do not need to define them separately, that statement *is* their definition
18:40:51 <truta> thats the definition
18:41:12 <hugoestr> Ooh, that is pretty cool. Thanks shachaf and geekosaur.
18:42:10 <Sgeo> djahandarie, hmm? Because that would be easier for beginners?
18:42:49 <djahandarie> Sgeo, it definitely would be.
18:43:08 <geekosaur> djahandarie, because as yet GADTs are not standard Haskell
18:43:27 <djahandarie> Then it's a good thing that no one uses standard Haskell.
18:43:49 <Sgeo> Tutorials use standard Haskell!
18:43:51 <Sgeo> :/
18:44:50 <truta> :P I did not knew what was GADTs, but i'm now reading about it, and i'm liking
18:45:28 <geekosaur> (people do still, for some reason, use hugs; and there are other non-ghc compilers out there although I havent actually heard much out fo the jhc and uhc camps recently)
18:45:50 * geekosaur would like to see jhc become more complete, sadly he cannot contribute
18:46:42 <djahandarie> Both JHC and UHC support GADTs
18:46:56 * hackagebot angel 0.3.2 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.3.2 (JamieTurner)
18:47:08 <djahandarie> Or at least I've read a paper about UHC supporting GADTs, not sure if that's actually in the compiler...
18:48:18 <geekosaur> huh, I didn;t think they were in jhc yet.  guess I'm not hearing about it because it's being talked about elsewhere...
18:50:07 <djahandarie> Hmmm
18:50:43 <djahandarie> Alright, JHC might not have them, confused that with it having rank-n polymorphism
18:55:27 <user317> so is there a way to get happstacks simpleHTTP to output some logs on what requests its processing?
19:12:48 <Entroacceptor> user317: you can just add a log statement in front
19:18:20 <Sgeo> Do people often use flip lookup?
19:18:49 <mwc> What's the state of the art in Haskell these days for serializing function values for e.g., message passing purposes?
19:20:32 <shachaf> Sgeo: You can use sections sometimes instead of flip.
19:20:49 <shachaf> mwc: There's the CloudHaskell thing.
19:21:09 <mwc> Suppose I want to map (\x -> (x,1)) over a distributed data set and then have some monoid for reducing values.
19:22:07 <mwc> Is there anything in the GHC runtime to get an address for an unapplied function that will be stable across multiple invocations of the same process binary on different machines? (MPI-style concurrent execution)
19:22:11 <mwc> shachaf: looking into it
19:23:32 <mwc> shachaf: so basically the answer is still "encode your query in an EDSL, then serialize that?"
19:25:32 <Mongey> hey, what would be the correct way to do map intersect [[1,2,3],[1,2]]
19:26:04 <mwc> Mongey: I'm assuming you don't want to map intersect over two different lists, but find their intersection?
19:26:41 <shachaf> mwc: I've never used it; I don't know.
19:26:44 <Mongey> mwc: yeah
19:27:12 <shachaf> Mongey: foldr intersect?
19:27:19 <shachaf> I guess it only makes sense for it to be a foldr1.
19:28:00 <DanBurton> :t foldr1 interesect
19:28:01 <lambdabot> Not in scope: `interesect'
19:28:03 <mwc> Mongey: if they're sorted lists, take values from the head while they match, when they don't, discard the one that's lesser. Otherwise, convert them to a Data.Set and use that intersection routine
19:28:12 <DanBurton> :t foldr1 intersect
19:28:13 <lambdabot> forall a. (Eq a) => [[a]] -> [a]
19:28:27 <DanBurton> > foldr1 intersect [[1,2,3],[1,2]]
19:28:28 <lambdabot>   [1,2]
19:28:40 <Mongey> ty
19:29:07 <mwc> Oh, you weren't asking how intersect is implemented
19:29:13 <DanBurton> > foldr1 Data.Set.intersect . map Data.Set.fromList $ [[1,2,3],[1,2]]
19:29:14 <lambdabot>   Not in scope: `Data.Set.intersect'Not in scope: `Data.Set.fromList'
19:29:34 <DanBurton> no Data.Set, lambdabot? :(
19:30:01 <lambdabot> Nope.
19:30:30 <DanBurton> @botsmack
19:30:30 <lambdabot> :)
19:30:45 <lambdabot>  @primatesmack
19:37:08 <cl1> how can you get a non-exhaustive pattern when it ends with otherwise?
19:38:04 <shachaf> In a place that doesn't have to do with the guards.
19:38:24 <shachaf> > let f [] | otherwise = 1 in f "a"
19:38:25 <lambdabot>   *Exception: <interactive>:3:4-23: Non-exhaustive patterns in function f
19:38:51 <shachaf> You could probably figure that out by fiddling with your code enough. :-)
19:39:26 <cl1> so the pattern match failure is not on the guard its one the function parameters
19:39:34 <shachaf> Who knows?
19:39:43 <shachaf> You haven't, you know, shown any code.
19:40:57 <cl1> words' :: String -> [String]
19:40:57 <cl1> words' xs = foldr step [] xs
19:40:57 <cl1>     where step item xss@(x:xs) | isSpace item && null x = xss
19:40:57 <cl1>                                | isSpace item           = []:xs
19:40:57 <cl1>                                | otherwise              = (item:x):xs
19:42:06 <cl1> isSpace item = []:xss
19:42:12 <copumpkin> we try to avoid posting lots of code in here
19:42:14 <copumpkin> @where paste
19:42:15 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
19:42:21 <copumpkin> cl1: ^
19:42:28 <djahandarie> Yes, we avoid pasting it in here so we can read the irccloud pingout spam instead
19:42:28 <cl1> copumpkin, 5 is alot?
19:42:40 <cl1> djahandarie, lol
19:43:02 <copumpkin> cl1: it's usually more than standard etiquette dictates :P it's more than 1 link to a page where interested parties can look, rather than showing 800 people who are probably not interested
19:43:36 <cl1> copumpkin, hopefully only 778 at most
19:43:48 <copumpkin> :)
19:44:37 <cl1> i'll remember for next time, for now, burn your retinas on my code from hell
19:45:30 <shachaf> Yes, because of that long paste, bobry,mndrix,akahn,arnihermann,puzza007,SeanTAllen,lopex,srid all quit in anger.
19:45:50 <mwc> cl1: se what you did?
19:45:57 <cl1> :O
19:46:08 <cl1> >_>
19:46:11 <cl1> <_<
19:46:19 <rwbarton> your 5 lines overloaded irccloud's systems.
19:46:24 <cl1> v_v
19:46:34 <shachaf> cl1: Yes, what's wrong in your code is exactly what I said. You're matching against (:).
19:47:06 <mwc> cl1: xss will never match []
19:47:37 <shachaf> xss is also not a good name for something which is of the same type as xss.
19:48:04 <mwc> well, I'd have done xxs@(x:xs), but that's just me
19:48:31 <mwc> welcome to #haskell, come for the help, stay for the abuse.
19:48:47 <cl1> :D
19:48:53 <cl1> still not as bad as #c
19:48:56 <cl1> i hate that place
19:49:00 <cl1> it makes me cry
19:49:28 <mwc> I'm working on an 8000 line C project that shows every sign of heading towards 20,000 unless I can somehow switch most of it to Haskell
19:49:43 <mwc> so I can understand why ##c is usually bitchy
19:49:54 <cl1> mwc .. maybe use ada instead?
19:49:59 <mwc> Well, it'
19:50:34 <cl1> s so awesomely large its chewing up text from irc?
19:50:43 <mwc> Well, it's OpenCL, so the host program basically does parsing and determines from the topology of the system how to schedule the computation. That hits every weak spot of C
19:50:48 <Axman6> <3 Ada
19:51:07 <mwc> No, ' and \n are located adjacently on my keyboard
19:51:21 <Axman6> mwc: i do it all the time too :(
19:51:32 <cl1> same here
19:53:37 <cl1> unless you are working with an infinite list or a non-associative operator al la (-) doesn't it always make more sense to use foldl' ?
19:54:20 * cl1 was told that plain old foldl is bad and that i should use foldl'
19:54:47 <Axman6> there are only very few cases where you want to use foldl over foldl'
19:55:06 <cl1> however shouldn't you always assume that you are being passed an infinite list so that the operation doesn't error out, therefore always use foldr
19:55:31 <rwbarton> Not if your operation doesn't make sense on infinite lists.
19:55:37 <mwc> cl1: only if it makes sense to perform the operation on an infinite list
19:55:41 <mwc> cl1: mean [1..]
19:56:40 <cl1> guess i've never seen a situation that needed an infinite list
20:01:14 <shachaf> cl1: Rules that say that you should always do something are always wrong.
20:02:54 <cl1> shachaf, point taken
20:03:11 * cl1 moves on to implementing unlines as a fold
20:20:42 <augur> what are some exotic machine architectures that people know about?
20:20:45 <augur> like, really exotic
20:21:02 <mwc> single instuction machines? or do you mean actual existing ones?
20:21:12 <mwc> black hole computers would be another one
20:21:26 <slack1256> what kind of exotic? the only that solve a single problem right?
20:21:31 <slack1256> as the a physics processor?
20:21:35 <augur> anything that people have proposed as something more than just for shits and giggles absurdness
20:21:48 <mwc> augur: http://www.newscientist.com/article/dn8836-black-holes-the-ultimate-quantum-computers.html
20:22:24 <slack1256> augur: http://en.wikipedia.org/wiki/Ageia
20:22:45 <Axman6> augur: the reduceron?
20:22:51 <augur> Axman6: haha
20:22:52 <augur> :)
20:23:02 <slack1256> LISP MACHINES XD
20:23:47 <slack1256> btw guys do you think functional code would benefit more from a RISC processor or not?
20:24:19 <JoeyA> It would benefit most from a processor designed to run functional code ;-)
20:25:48 <cl1> augur, how about a single chip cloud computer: http://techresearch.intel.com/ResearchAreaDetails.aspx?Id=27
20:25:49 <augur> JoeyA: im designing one of those :x
20:25:50 <augur> sort of
20:26:09 <JoeyA> But I don't know if RISC would help or not.  The main problem, I think, is that modern CPUs are designed to execute a single stream of instructions really fast.
20:26:10 <slack1256> augur: tell me more.
20:26:20 <BMeph> augur: Transputers? ;)
20:26:22 <JoeyA> To this end, they use caches, and caches of caches, and caches of caches of caches.
20:27:03 <slack1256> if they could the would use the memory directly, but the von neumann botleneck
20:27:20 <augur> slack1256: well, im using a slightly modified representation of lambda terms in memory that allows the terms themselves to act both as variable environments and call stacks
20:27:39 <augur> so that evaluation proceeds by manipulation of pointers, mostly
20:28:02 <augur> with some copying going on here or there
20:28:07 <slack1256> are you doing this on your college?
20:28:12 <augur> no
20:28:22 <cl1> check this out http://sautinsoft.net/Tested/rtftohtml/Converted/2012-01-10_22-11-40.html
20:29:00 <cl1> i don't see why a debugger couldn't use info from a debugging symbol file and produce something along the lines of this for when you step through a program
20:29:20 <cl1> obviously it wouldn't be spaced out like that, but for each execution step show the next line in that example
20:30:08 <augur> itd probably end up being better if i had actual environments for the evaluation because it would avoid copying... i should work on that
20:32:21 <slack1256> :q
20:32:22 <slack1256> fuck
20:33:36 <JoeyA> What's a good way to have a thread block forever?  An obvious way is: forever (threadDelay 500000000)
20:33:44 <JoeyA> I'm wondering if there's an even simpler way to do it.
20:34:50 <kfish> JoeyA, what kind of event is it waiting for?
20:35:07 <JoeyA> Nothing at all.  An exception, perhaps.
20:35:08 <shachaf> JoeyA: I think that's pretty standard.
20:35:28 <shachaf> JoeyA: You can use maxBound if you like instead of 5*10^don'twanttoreadit
20:35:32 <mwc> If you need to interrupt the wait at some point, consider a condition variable
20:35:41 <shachaf> Or that.
20:35:52 <new2hs> total n00b question here, just starting a Haskell tutorial http://learnyouahaskell.com/starting-out, the first example of a function is doubleMe x = x + x.  My question is this:  It accepts it if I shove it in a file called whatever.hs and :l whatever at the prompt.  But if I type doubleMe x = x + x at the prompt it's an error.  Why?
20:36:04 <shachaf> new2hs: Because that's not how ghci works.
20:36:23 <shachaf> new2hs: "let doubleMe x = x x" would work, but ghci is different in various ways from any other context you can type Haskell code in.
20:36:34 <shachaf> Also, I don't like the name "doubleMe". :-(
20:37:17 <rwbarton> myDouble
20:38:57 <Axman6> takeXAndAddXToItself
20:39:03 <parcs`> f
20:39:24 <JoeyA> Isn't there a point-free way to say that?
20:39:30 <JoeyA> @pl \x -> x*x
20:39:31 <lambdabot> join (*)
20:39:38 <JoeyA> @pl \x -> x+x
20:39:38 <lambdabot> join (+)
20:39:42 <parcs`> (*2)
20:39:44 <JoeyA> joinWithPlus
20:40:02 <JoeyA> > join (+) 2
20:40:02 <lambdabot>   4
20:40:46 <shachaf> @let with f _ x = f x x
20:40:46 <mwc> takeAnyValueOfATypeWhichIsAnInstanceOfNumAndApplyTheNumClass'sPlusOperatorToThatValueOnBothSidesOfTheBinaryOperator
20:40:47 <lambdabot>  Defined.
20:40:49 <shachaf> > join with (+) 2
20:40:51 <lambdabot>   4
20:40:53 <mwc> I think that pretty much self documents it
20:41:11 <shachaf> "I self-documented it"
20:41:55 <shachaf> Oops. Those irccloud people are very irritable today.
20:41:57 <mwc> Well, self-documentated, v. tr., to make something self documenting.
20:42:04 <luite> mwc: you should make an emacs script that automatically expands tavoatwiaionaatncpottvobsotbo to that
20:42:20 <mwc> shudder
20:42:40 <luite> that way you have both documentation and productivity!
20:42:59 <shachaf> Self-documentified?
20:43:06 <mwc> Hahah, Cobohaskeperl?
20:43:47 <mwc> self-documentified works. I guess to narrow it down we need to pick an etymological scheme? Should this word have come from Latin or Greek?
20:44:16 <luite> not greek, we hate them now in europe ;p
20:45:24 <new2hs> so GHCI is mainly a compiler and runtime environment, the prompt is intended for controlling those processes and isn't an interpreter, or at least not an interpreter than can handle all of Haskell
20:45:46 <luite> new2hs: GHC 7.4 adds more functionality to GHCI
20:46:08 <parcs`> but it doesn't add top level definitions
20:46:11 <mwc> new2hs: the ghci top level more or less evaluates expressions as if they occured in a do block
20:46:23 <mwc> except that it allows expressions of non IO type to be evaluated
20:48:12 <JoeyA> I've run into a terminology conflict.  E.g. data MatterState = MatterState { matterTemperature :: Temperature, matterState :: MatterState2 }; data MatterState2 = Solid | Liquid | Gas
20:48:38 <JoeyA> On the one hand, State can mean a collection of variables that changes over time (e.g. the first type parameter of StateT)
20:48:49 <mwc> data MaterialPhase = Solid | Liquid | Gas
20:49:10 <mwc> of course, that's hopelessly wrong anyways
20:49:16 <JoeyA> On the other hand, the "state" of a program can be one of a variety of finite choices (that is, the program is a finite automaton)
20:49:29 <new2hs> thanks for the help folks, it's a little clearer
20:49:33 <shachaf> type MaterialPhase = (Double,Double,Double,Double)
20:50:16 <mwc> You also need to think about how to handle a) supercritical states, b) critical states c) multiple forms of a phase, e.g., ice has 12 different solid forms
20:50:55 <mwc> I would suggest not making the phase a state variable
20:50:56 <luite> hm, 12 different, i didn't know that. do they look different?
20:50:58 <JoeyA> It's seen pretty often in C programs: a switch over a bunch of state codes (look at libcurl for some good examples)
20:51:05 <rwbarton> Also don't forget the phases that haven't been discovered yet, and all the ones that only exist in hypothetical other universes.
20:51:11 <mwc> luite: under crystallographic techniques, sure
20:51:23 <mwc> but some of them only exist in the lab or exotic astronomical conditions
20:52:15 <luite> hm right, so it's basically all crystalline ice with different crystal lattices?
20:52:20 <JoeyA> In my particular case, it's data ConnectionState = Unlocked | Locked | Closed
20:52:24 <JoeyA> and I have a TVar
20:52:51 <JoeyA> Only one thread can access the object at a time.  It's also possible for the connection to be closed.
20:53:06 <JoeyA> TMVar Bool would work, too, but that's less self-documenting.
20:53:22 <JoeyA> (closing the connection requires acquiring the lock)
20:54:09 <JoeyA> Looking at a thesaurus now
20:54:14 <JoeyA> Mood :-)
20:54:26 <JoeyA> Status
20:55:27 <mwc> JoeyA: if you want a term for solid/gas/liquid, it's technically known as a phase, and is found by looking up a phase diagram.
20:56:15 <mwc> also, < JoeyA> (closing the connection requires acquiring the lock)
20:56:20 <mwc> this worries me
20:56:33 <mwc> if the connection is shared, why should one thread close it?
20:56:36 <JoeyA> It's actually a send-only object.
20:56:53 <JoeyA> We don't want to close the connection while someone else is still sending a message.
20:57:11 <JoeyA> It only locks when sending.
20:58:46 <mwc> Right, but suppose this sequence of events occurs: a sends, a gets lock, closes connection; b sends; segfaults/exception.
20:59:15 <mwc> I usually stuff shared resources in whatever is responsible for managing the thread pool or the work unit that's given to the thread pool
20:59:55 <hpaste_> cl1 pasted “is it better to pattern match or call head and tail??” at http://hpaste.org/56337
21:00:33 <JoeyA> Is "segfaults/exception" due to the sequence of events before it, or do you mean a hypothetical error condition?  (e.g. someone pulls the network cable)
21:00:51 <shachaf> cl1: Those are two different functions.
21:01:14 <mwc> I mean segfault if a null pointer gets passed to an underlying C library because it's been given a closed connection handle, or an exception because the haskell API or other libraries detects an error
21:01:15 <shachaf> Oh, maybe not.
21:01:40 <JoeyA> I'm thinking of a tri-state lock.
21:01:46 <JoeyA> Locked | Unlocked | Unavailable
21:01:53 <mwc> cl1: if xs is [] in the second version, line 13 will cause an error
21:02:09 <shachaf> Anyway, pattern-matching is almost always preferable.
21:02:23 <shachaf> Er.
21:02:26 <shachaf> What mwc said.
21:02:28 <mwc> > head []
21:02:29 <lambdabot>   *Exception: Prelude.head: empty list
21:02:35 <JoeyA> send requires the state to be Unlocked.  If it's Locked, it retries; if it's Unavailable, it throws an exception.
21:02:44 <mwc> Ah, that sounds more reasonable
21:02:51 <cl1> mwc .. good catch
21:03:05 <cl1> i'm just gonna stick with pattern matching, it makes more sense to me
21:03:28 <cl1> > tail []
21:03:29 <lambdabot>   *Exception: Prelude.tail: empty list
21:03:38 <cl1> yeah i don't like head and friends
21:03:45 <rwbarton> Consider yourself lucky, then, you should generally prefer pattern matching even if it didn't make more sense to you.
21:03:54 <JoeyA> Also, what do you think of my approach to receiving? :  connect :: Config -> (SendHandle -> RecvM a) -> IO a
21:03:57 <shachaf> rwbarton++
21:04:23 <shachaf> I have the feeling karma is easy to harvest in #haskell by repeating popular dogma at the right times.
21:04:28 <shachaf> Maybe I shouldn't be in support of that.
21:05:00 <rwbarton> Someone should write a bot to do that.
21:05:14 <shachaf> @nixon
21:05:14 <lambdabot> Sure there are dishonest men in local government. But there are dishonest men in national government too.
21:05:28 <mwc> JoeyA: the type (SendHandle -> RecvM a) confuses me, because I'd excect RecvM to be some monad in which we recieve data and SendHandle to be an output only handle
21:05:31 <rwbarton> Close, but not quite what I had in mind.
21:05:31 <JoeyA> RecvM is a state monad supporting liftIO.  The subtle benefit here is that it requires receiving to be done in one thread.
21:05:42 <shachaf> @brain
21:05:43 <lambdabot> The game does not conclude until the woman with the eating disorder ululates.
21:06:28 <JoeyA> mwc: I suppose this is the messy part.  The receiving thread (which is the same thread that called connect) is passed the SendHandle so it can send.
21:06:43 <JoeyA> For example, it'll send its version, then it'll receive the other host's version.
21:06:56 <JoeyA> Then it'll send initial setup, then wait for the other host's data.
21:07:14 <mwc> Then I would rename it to CommM or something, but it's your code
21:07:24 <shachaf> I hope M doesn't stand for Monad.
21:07:24 <JoeyA> So the callback to connect engages in a two-way dialogue with the client.
21:07:47 <JoeyA> However, other threads need to be able to send to the client while the RecvM thread waits.
21:09:39 <JoeyA> If CommM had send and recv actions, and that was the only communication method, then it would not be possible to send data suddenly while waiting for a response.
21:10:41 <JoeyA> (short of sending the communication thread an async exception, which is risky)
21:10:59 <cl1> JoeyA, what are you trying to accomplish (independant of the code you are implementing)
21:11:30 <JoeyA> A wrapper library around Network.TLS that sends and receives packets of information pertinent to my application.
21:11:33 <mwc> As an alternative design, have you considered using a channel to multiplex access to the connection resource? Then threads can suddenly send data by merely writing a transmit frame value to a channel without any blocking, and then they can perform a blocking read on their incoming message channel
21:11:57 * hackagebot couchdb-conduit 0.1.1.0 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.1.1.0 (AlexanderDorofeev)
21:12:03 <cl1> JoeyA, are they one way messages that can be recived by many or a request/response?
21:12:40 <JoeyA> mwc: I sort of do that now (except sending isn't done on a channel).  They tricky bit is, how do you handle a receive error?
21:13:08 <mwc> punt it to the thread that would have gotten the data
21:13:27 <mwc> or throw an exception which is caught by the master thread and kills everything involved
21:13:34 <mwc> depending on what is correct for your application
21:14:36 <JoeyA> cl1: Messages come in on a stream.  I can't simply have multiple threads call recv, since some threads will receive messages they don't need.  It makes more sense to receive all messages and dispatch.
21:14:45 <JoeyA> (there aren't that many message types, anyway)
21:15:24 <JoeyA> Maybe a TChan approach isn't too bad.
21:16:10 <JoeyA> Well, if you have a channel for sending, then you need a thread that does nothing but send.
21:16:12 <cl1> have your recievers give the sender a queue, you can lock on the queue from both threads when adding or removing items from the queue. The sender locks, enqueyes. the reciever locks, dequeues
21:16:41 <cl1> s/enqueyes/enqueues/
21:16:56 <mwc> cl1: a channel does that without the manual locking on each end
21:17:05 <JoeyA> I only have one receiver, in any case.
21:18:48 <cl1> mwc: the queue could do the locking, yes
21:20:55 <cl1> JoeyA, when you say some threads don't need messages, does that imply that if a thread that doesn't need a message consumes it, then there is another thread that should have recieved it but didn't?
21:23:10 <JoeyA> cl1: Suppose we have two threads interested in messages from a connection.  Thread A only cares about Fizz messages, and thread B only cares about Buzz messages.  If both threads call recv on the same handle, then they might receive each other's messages.
21:23:30 <JoeyA> One solution to the problem would be for receiving threads to "put back" messages.
21:23:59 <JoeyA> A more straightforward solution would be to only allow receiving in one thread, and have that one thread dispatch to the target threads.
21:24:30 <cl1> how about they don't take in the first place, have a queue for each thread and place the message in each queue, then that thread can decide if it cares about it
21:24:47 <JoeyA> So I was thinking of using a wrapper monad to force receives to be done solely in one thread.
21:25:02 <JoeyA> Right, and code running in the wrapper monad can do that.
21:25:16 <cl1> or have each thread register to recieve messages by providing a callback, the dispatcher can then send the message to all callbacks
21:25:38 <jkff> Hi folks. I'm building (cabal build) gtk2hs on Mac with -fsplit-objs and, during compilation of the largest file Graphics.Ui.Gtk.Types after the linker phase and "deleting temp files" and "deleting temp dirs" phase I get an error: "ghc: could not execute: /Developer/usr/bin/gcc"
21:25:42 <jkff> What could that mean?
21:25:59 <cl1> if you want to get fancy you can declare flags that identify messages, so when a thread registers to recieve messages, it can say, i only want messages x.|.y.|.z
21:26:14 <jkff> Without -fsplit-objs the thing compiles fine.
21:26:35 <jkff> I increased verbosity to -v3, but it didn't help at all - nothing surrounds this particular message.
21:26:38 <mwc> jkff: random guess, you're overflowing the some command line maximum length limit
21:27:08 <mwc> -fsplit-objs can result in very long command lines to the linker
21:27:29 <jkff> mwc: I thought about that too - however the preceding commands are outlandishly long too and they do get executed. However perhaps in this case an even longer command line was formed :) I'll try doing something to shrink it...
21:27:39 <jkff> This file generates about 6000 split objects.
21:28:28 <mwc> Well, iirc the command line is limited to something like 64 kiB on most unix platforms
21:28:39 <monochrom> yikes, that's extreme
21:29:22 <hpaste_> “Joey Adams” pasted “Network API with single-threaded receive” at http://hpaste.org/56338
21:29:38 <JoeyA> ^ That's a rough prototype of the API I'm going for.
21:30:03 <JoeyA> I'm thinking connect will close the connection once the inner action has completed (meaning it should probably be called withConnection).
21:30:48 <JoeyA> But the key idea is that receiving is trapped in the RecvM monad, and thus in a single thread, while sending can be done in any thread.
21:31:32 <JoeyA> (Internally, SendHandle uses a mutex of some kind.  No mutex is needed for receiving.)
21:32:33 <JoeyA> Anyway, thanks for the input
21:40:06 <amiller> @hoogle bind
21:40:06 <lambdabot> package bind-marshal
21:40:07 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects bindBuffer :: BufferTarget -> StateVar (Maybe BufferObject)
21:40:07 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
21:40:17 <amiller> @tt bind
21:40:18 <lambdabot> Done.
21:42:29 <amiller> does lambdabot accept bitcoin donations
21:43:09 <lispy> amiller: no, but the source is public
21:43:11 <lispy> ?version
21:43:11 <lambdabot> lambdabot 4.2.2.1
21:43:11 <lambdabot> darcs get http://code.haskell.org/lambdabot
21:43:14 <lispy> amiller: ^^
21:44:05 <amiller> i suppose that's close enough, thanks :p
21:44:17 <cl1> JoeyA, I guess what i was getting at is you can make that hpaste api run in its own thread so it can send and recieve messages at a different rate than the threads that actually need the messages. meaning that another abstraction should sit on top of your proposed api between the threads and this api
21:49:47 <JoeyA>  cl1: Thanks.  I plan to post this API on http://codereview.stackexchange.com/ , and define an additional function that provides send and receive channels like you describe.
21:49:57 <JoeyA> (the additional function wraps around my original API)
21:52:44 <eyebloom> Can anyone help figure out how to compile this?
21:52:48 <hpaste_> eyebloom pasted “Toy” at http://hpaste.org/56340
21:54:02 <Axman6> eyebloom: you can't have more than once instance of a class for any one type
21:54:32 <Axman6> so you can either derive Show, or you can write your own instance, but not both
21:54:35 <eyebloom> So how can I show both toy and toycontainer
21:54:57 <Axman6> either just derive it for both, or leave off deriving Show
21:55:21 <Axman6> deriving Foo makes the compiler give you a default instance of Foo Bar, where Bar is the type you're defining
21:55:58 <Axman6> just delete 'deriving Show' from both the data declarations
22:05:05 <The_Journe> hi, is there a fast library for minimization of a multivariable function in Haskell?
22:05:22 <The_Journe> or at least faster than the one in hmatrix?
22:06:03 <DanBurton> "minimization of a multivariable function"?
22:06:16 <DanBurton> you mean memoization?
22:06:27 <eyebloom> Axman6: thanks.
22:07:06 <DanBurton> also technically all functions in haskell have exactly 1 input and 1 output
22:10:33 <Jafet> I expect he is referring to numerical analysis.
22:10:38 <The_Journe> ^
22:10:42 <Jafet> Haskell isn't used much in that area.
22:10:55 <Jafet> Except perhaps for stock market analysis
22:42:07 <jdavis> In http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102, down where it's talking about the "Tofu" type class, it has a line like: "tofu (Just 'a') :: Frank Char Maybe". Why is the explicit type annotation required for that typeclass, but not, say, Eq?
22:46:59 * hackagebot llrbtree 0.0.1 - Left-Leaning Red-Black Tree  http://hackage.haskell.org/package/llrbtree-0.0.1 (KazuYamamoto)
22:51:11 <shachaf> jdavis: What?
22:51:40 <luite> jdavis: ghci does some defaulting, and the type of (==) is relatively simple, with the defaulting rules you often get some concrete type out in ghci
22:52:20 <luite> > maxBound == minBound -- although I didn't expect this to work and get this answer :)
22:52:20 <lambdabot>   True
22:52:32 <mauke> luite: I think defaulting is irrelevant here
22:53:20 <luite> mauke: well, if you use (==) this way, ghci has to use defaulting to choose one instance of Eq
22:53:26 <luite> > 1 == 2 -- uses defaulting to work
22:53:27 <lambdabot>   False
22:53:40 <mauke> luite: what do you mean by "this way" and where are you getting numeric literals from?
22:54:34 <rekahsoft> hi all..was just perusing the XMonad source (specifically XMonad/StackSet.hs) and was wondering about the datatype definition for StackSet, Screen and Workspace..i understand everything except for the use of ! before the type declartion here: "data StackSet i l a sid sd = StackSet { current  :: !(Screen i l a sid sd)
22:55:08 <rekahsoft> ..." what does this notation mean?
22:55:14 <shachaf> rekahsoft: It's a strictness annotation.
22:55:41 <mauke> jdavis: the methods in Eq return a known, concrete type: Bool
22:55:53 <luite> mauke: oh I'm being stupid, sorry
22:56:02 <mauke> jdavis: tofu is polymorphic so the compiler doesn't know what result we want
22:56:03 <arks> Hello~I want to know that the difference between Data.Map.fromList $ [("hello","world"),("Same","World")] and the same statement without "$"~thx
22:56:12 <mauke> arks: none
22:56:16 <ion> @src ($)
22:56:16 <lambdabot> f $ x = f x
22:57:01 <luite> arks: no difference here
22:58:27 <rekahsoft> shachaf: awe..and what does it do?
23:00:26 <shachaf> rekahsoft: It marks the field as strict, so StackSet { current = x, ... } will force x.
23:10:09 <rekahsoft> shachaf: awe..like seq, no?
23:14:31 <shachaf> rekahsoft: Yep, like seq.
23:15:21 <shachaf> data Foo = Bar !Int makes the constructor Bar behave like Bar x = x `seq` BarWithoutBang x
23:19:48 <ion> A nice demonstration: data Foo = Foo { fooA :: String, fooB :: !String }; then run “let foo = Foo "foo" undefined” and “fooA foo” in ghci. Then remove the ! and try again.
23:21:42 <shachaf> let foo foo = foo foo foo where foo = foo { foo = foo }
23:37:13 <tty7> it seems like there are types of numbers which are not in the Num class?!
23:37:43 <tty7> when i try this code, i get an error message:
23:38:05 <tty7> isIntegral :: (Num a) => a -> Bool
23:38:05 <tty7> isIntegral x = x == (fromIntegral . truncate $ x)
23:38:17 <tty7> saying
23:38:25 <shachaf> tty7: truncate doesn't work for every Num.
23:38:32 <shachaf> That's how it's supposed to work.
23:38:40 <ion> @type truncate
23:38:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
23:38:41 <tty7> "Could not deduce (RealFrac a) arising from a use of `truncate` from the context (Num a)"
23:38:48 <tty7> ah, well
23:38:58 <tty7> thanks :)
23:39:15 <shachaf> tty7: You could figure this out yourself by commenting out the type signature and letting ghci infer a type.
23:39:21 <tty7> thought i'd have checked :t truncate and it said Num a... nevermind
23:39:23 <ion> @type \x -> x == (fromIntegral . truncate) x
23:39:24 <lambdabot> forall a. (RealFrac a) => a -> Bool
23:39:34 <tty7> yeah, thanks!
23:40:35 <tty7> hum. is it possible to check whether a given number type value is an Int/Integer/Integral for more than RealFrac's?
23:42:40 <ion> Parse error
23:44:03 <tty7> hm?
23:48:09 <plumenator> Is Parsec with the parallelism feature of ghc/haskell  a good fit for analyzing large log files?
23:52:46 <earthy> plumenator: yes and no
23:52:55 <earthy> parsec itself doesn't parallelize well
23:53:14 <earthy> however, log files tend to have very easily distinguished parallelizable structure
23:53:32 <plumenator> earthy: I was only counting on diving the log files into partitions, eys.
23:53:40 <earthy> (e.g. split at newline and send off the line to a parallel task)
23:53:44 <plumenator> dividing* yes*
23:54:24 <earthy> but parsing in general is hard to parallelize, especially when context can be involved
23:54:42 <earthy> plus, you're often still bound by linear I/O
23:54:52 <plumenator> that's true
23:55:35 <plumenator> we could however work around that by opening the file multiple times and seeking, right?
23:55:50 <earthy> yes
23:56:10 <plumenator> Would it be simpler to just use regex?
23:56:26 <earthy> but you'd have to parse overlapping bits, as you don't know in advance where the logical parts are separated within the file
23:56:58 <earthy> plumenator: simpler, *maybe*. probably not.
23:57:12 <ion> Ask edwardk about Trifecta. I don’t know whether there’s any parallelization at the moment, but IIRC it has some kind of support for parsing distinct top-level structures independently.
23:57:24 <earthy> especially not if you want to have abstract data structures generated from the logfile
23:57:40 <qqMuppetpp> reading from multiple positions in a file is bound to be slower than just reading sequentially..?
23:57:56 <plumenator> i'm looking for simple 'counts' for now.
23:58:28 <ion> Reading from multiple positions is different than reading sequentially into a buffer and parsing multiple areas in parallel.
23:59:22 <plumenator> qqMuppetpp: I assumed we'd open the file multiple times too, so it's technically multiple files.
23:59:40 <qqMuppetpp> plumenator: either way, you're IO bound
23:59:45 <plumenator> true
