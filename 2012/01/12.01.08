00:00:02 <shachaf> aweis: Also, you probably shouldn't ask about ProjectEuler problems in here. Not that there's a rule about it or anything, but what's the point, if you don't solve it yourself?
00:00:52 * ddarius should perhaps go through Project Euler with paper and pencil some day.
00:01:03 <aweis> shachaf: I agree 100%
00:01:13 <aweis> disclaimer: nobody tell me the answer
00:01:35 <aweis> shachaf: im more concerned with understanding if I am causing haskell to be really slow...
00:05:53 <aweis> shachaf: do you have accumulators in your haskell code?
00:09:08 <ddarius> aweis: All those accumulator loops are more complex and less efficient than the simpler "non-tail-recursive" code.  Also, never use foldl.  There are times to use accumulator loops (and foldl, or much better, foldl' encode that pattern directly) but none of the cases in your code are one of them.
00:09:20 <ddarius> Also, listen to hlint.
00:09:54 <ddarius> Also, a lot of your functions can be replaced by standard higher-order functions.
00:10:06 <aweis> ddarius: thanks.  hlint?
00:10:33 <ddarius> aweis: Look at your paste.
00:12:17 <aweis> why fold' over foldl?
00:13:54 <shachaf> @google why would i always use foldl' instead of foldl in haskell
00:13:55 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
00:13:55 <lambdabot> Title: Stack overflow - HaskellWiki
00:16:24 <aweis> why isnt foldl just foldl'?
00:16:54 <aweis> if 99% of the time a foldl is needed, you foldl'
00:16:57 <ddarius> Because the people making the Report had a fetish for making things as lazy as possible.
00:17:43 <ddarius> Ironically, there are a few places where they are overly strict, and a few places where they do, correctly, choose a more strict definition.
00:18:00 <aweis> jeez I really overlooked the laziness component to haskell - it kinda opens my perspective of how functional code should look
00:22:39 <ddarius> @where whyfp
00:22:39 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
00:28:30 <monad> In the book "Real World Haskell", I found the the following declaration: instance NFData BS.ByteString where rnf _ = () ! In my opinion, rnf does nothing! I don't understand how the argument of rnf will be reduced to "normal form". Any idea?
00:28:57 <aweis> ddarius: the accumulators were my problem with efficiency
00:29:21 <monad> BS -> import qualified Data.ByteString.Char8 as BS
00:29:31 <aweis> ddarius: is it common for first time haskeller's to bring these accumulator habits into their haskell
00:30:36 <ddarius> aweis: Yes.
00:31:17 <ddarius> aweis: It's even more common for beginners (and not so beginners) to blithely treat Haskell as if it were an eager language when trying to "optimize" or assess the performance of code.
00:31:45 <aweis> ddarius: from now on when I see someone saying "New to haskell -> should be no big deal since I know SML and Scheme...." make sure to scream "DONT USE ACCUMULATORS"
00:32:36 <shachaf> aweis: That's silly.
00:32:39 <ddarius> aweis: They should use accumulators some times.  foldl' is an extremely handy function.  The issue is that a lazy language is not an eager language and so the performance characteristics are different, and few programmers have any experience optimizing lazy programs.
00:32:43 <shachaf> Accumulators have their place in Haskell.
00:33:12 <ddarius> monad: That would be a bogus instance of NFData.
00:33:32 <shachaf> aweis: Instead of dogma like "USE ACCUMULATORS" or "DON'T USE ACCUMULATORS", I recommend understanding the evaluation model and how things actually work.
00:33:57 <aweis> shachaf: but that takes thinking...
00:34:19 <monad> ddarius: I thought rnf is for reducing to normal form, but actually it does nothing. Very strange!
00:34:24 <AfC> If I have a [cryptographic or noncryptographic] hash function being used as a digest, and wish to shorten the number of digits being used to represent it, can I just take the `mod` of it?
00:34:31 <AfC> I mean, sure I can, but I assume there's a better way to shorten the bit length of a hash function while preserving its distribution characteristic?
00:34:52 <aweis> shachaf: I have /some/ experience with analyzing laziness by drawing out thunking and what not...
00:35:52 <arw> AfC: nothing that is kind of 'linear' should destroy most sane distribution characteristics.
00:36:25 <shachaf> monad: Yes, that instance is wrong, though "rnf !_ = ()" would probably be sufficient. It's probably just used in order to "rnf" something that happens to contain a ByteString.
00:36:26 <etpace> Is there a way to have cabal build tags (via hasktags or whatever) for my project?
00:37:27 <AfC> arw: that's what I thought. I'm getting collisions. Clearly I've got too few bits. I'll try another approach. Thanks.
00:38:01 <arw> AfC: it could also be that your distribution is not as nice and simple as you planned.
00:38:07 <shachaf> aweis: Do you? From outside of Haskell?
00:39:05 <arw> AfC: but you could, assuming equal density, easily calculate the probability of collisions and compare that to the number of collisions you are getting.
00:39:35 <aweis> shachaf: I wrote 2 libraries for lazy evaluation on top of scheme and also on top of sml
00:39:51 <ddarius> aweis: Did you then go on to use them/
00:39:52 <ddarius> ?
00:40:17 <aweis> ddarius: not that much - nor do I remember a whole lot of it
00:40:53 <aweis> ddarius: in all honesty, I think at that time I was still wrapping my head around the functional paradigm, that the laziness aspects of it never sunk in
00:41:40 <Enigmagic> AfC: truncating works with cryptographic hashes, it's faster than a mod too
00:41:53 <ddarius> aweis: I recommend reading that whyfp article that I referenced earlier, if you haven't.
00:42:12 <ddarius> It's equivalent to a mod...
00:42:12 <aweis> ddarius: when I first saw functional code it took about a month to understand type inferencing
00:42:25 <ddarius> Type inference is orthogonal to functional programming.
00:42:27 <aweis> ddarius: then the next month to understand folds and lambdas
00:42:31 <arw> at least to a mod 2^n
00:43:05 <aweis> ddarius: I understand but these were all thrown at me and completely foreign - I just mush those things together
00:43:09 <Enigmagic> ddarius: yeah, but truncating is as fast or faster :P
00:43:32 <Enigmagic> depending on the compiler
00:44:21 <AfC> heh
00:44:24 <shachaf> aweis: Oh yeah, well, it took me a YEAR to understand linked lists. And TEN YEARS to understand function application.
00:45:31 <aweis> shachaf: I first learned function composition in middle school - I found its first application in my first functional code
00:45:54 <AfC> shachaf: don't worry. In ONE HUNDRED YEARS I might understand Monads. And I'm hoping that ONE THOUSAND YEARS will have me on top of Iteratees. :)
00:46:14 * ddarius might have written his first "functional" code in middle school, but probably high school.
00:46:55 <Enigmagic> i hope it doesn't take 100 years to replace iteratees with something better
00:47:07 <augur> byorgey: happy birthday!
00:47:15 <ddarius> Enigmagic: Snoyman is already pushing conduits as a replacement.
00:47:20 <aweis> ddarius: I think that day in 6th grade when students learn f(g(x)) = f o g should then be followed up with a haskell tutorial
00:47:33 <Enigmagic> ddarius: yeah i know
00:47:45 <ddarius> f(g(x)) = (f o g)(x)
00:47:47 <Enigmagic> i can't build different applications with it though
00:48:11 <Enigmagic> i haven't had any problems with enumerator that conduits will solve (though i know some people have)
00:48:22 * ddarius would make no predictions about what coding will be like in a hundred years.
00:48:40 <ddarius> Actually, I intend to be dead well before a hundred years, so I guess I'm free to predict whatever I want.
00:49:48 <aweis> ddarius: use of C will be looked upon as we look upon asm today
00:50:00 <arw> if I make it another 150 years I will be at the founding of the federation...
00:50:22 <aweis> ddarius: all IO will be through monads... in every language
00:50:31 <shachaf> #not-haskell
01:29:33 <yitz> watch for the item in this week's HWN - ddarius predicts his own death
01:31:13 <ion> I predict my own death, too. Unless technology advances enough during the next few decades.
01:32:46 <mjrosenb> ion: it is not unreasonable.
01:33:14 <ddarius> ion: I predict my own death regardless of how technology advances.
01:43:09 <goganchic> hi2all
02:10:54 <gregATio> what is HWN?
02:11:20 <ion> @google hwn haskell
02:11:21 <lambdabot> http://www.haskell.org/haskellwiki/HWN
02:11:22 <lambdabot> Title: Haskell Weekly News - HaskellWiki
02:11:47 <gregATio> question: how similar is haskell and ocaml?
02:11:52 <gregATio> thanks ion
02:13:01 <srhb> gregATio: Hard to answer. Quite similar in the ml bit, not so much in the o bit.
02:13:32 <srhb> Questions like that are probably better answered by Google.
02:15:23 <ion> gregatio: Their Levenshtein distance is 6.
02:15:46 <ddarius> Haskell and O'Caml are probably more different than O'Caml and Java.
02:34:02 <XYU> XYU
02:34:16 <XYU> reverse XYU
02:34:21 <XYU> UYX
02:34:55 <Sgeo> XYU,
02:35:01 <Sgeo> > reverse "XYU"
02:35:02 <lambdabot>   "UYX"
02:35:24 <XYU> okay
02:36:05 <XYU> let XYU = (1488, "ANUS") in snd XYU
02:54:23 <gregATio> really noob question, can you do pattern matching in a let?
02:54:31 <srhb> gregATio: Yes.
02:56:44 <gregATio> im calculating the mean of a list, can you say whats wrong with my function?
02:56:49 <gregATio> http://pastebin.com/iuFaKzpK
02:56:51 <mauke> The paste iuFaKzpK has been copied to http://hpaste.org/56222
02:59:27 <srhb> gregATio: Your indentation is all messed up
02:59:48 <mrcarrot> why not just myMean xs = (sum xs) / (length xs)
03:00:16 <srhb> I think the point is implementing sum and length himself as well
03:00:28 <srhb> Of course, making them local may be a bit silly.
03:01:03 <Saizan> sum xs / fromIntegral (length xs) -- btw
03:01:19 <mrcarrot> ah, yep
03:01:56 <ion> / genericLength xs
03:02:05 <hpaste> srhb annotated “pastebin.com/iuFaKzpK” with “pastebin.com/iuFaKzpK (annotation)” at http://hpaste.org/56222#a56223
03:02:18 <gregATio> thanks guys
03:02:23 <gregATio> checking the pastbin
03:02:29 <gregATio> ahem hpaste
03:03:05 <srhb> gregATio: note that all I've changed is indentation.
03:03:11 <ion> Oh, hlint even recommends foldr versions? Nice.
03:03:18 <srhb> Yeah, it's very clever!
03:04:15 <gregATio> doh
03:04:38 <gregATio> i was staring at the paste thinking "what has he changed" lol
03:05:16 <gregATio> im just working through some exercises in Real world haskell
03:06:11 <ion> Also see LYAH. You might even want to read it first.
03:06:16 <ion> @where lyah
03:06:16 <lambdabot> http://www.learnyouahaskell.com/
03:06:46 <gregATio> Saizan I assume that you need to use fromIntegral because the / operator only takes some kind of floating point type
03:07:23 <gregATio> ion i have read lyah , well up to the chapter on zippers, but it didnt contain enough practical exercises for me
03:07:24 <mrcarrot> gregATio: that is right
03:07:47 <mrcarrot> acutually, lack of exercises is the biggest problem with lyah
03:07:50 <gregATio> for me, i need to start hacking otherwise it doesnt sink in
03:08:20 <ion> @type genericLength
03:08:21 <lambdabot> forall b i. (Num i) => [b] -> i
03:08:27 <ion> @type fromIntegral . length
03:08:28 <lambdabot> forall b a. (Num b) => [a] -> b
03:09:04 <gregATio> whats this genericLength all about, whats wrong with using length?
03:09:32 <mrcarrot> gregATio: length returns an Int. and you can not use Int for division
03:09:44 <ion> As a historical accident length only returns Ints.
03:09:51 <gregATio> aha
03:10:22 <gregATio> how painful, mistakes made in the past seem to cost haskell dearly
03:11:07 <srhb> I'm having some trouble figuring this out. I'm trying to fill a list of lists from IO, and I wan't to print "row n..." for every time a new list in the list is begun. sequence $ map sequence $ replicate numRows $ replicate numCols readLn
03:11:13 <srhb> So where do I put that print statement?
03:13:59 <ddarius> Having length return Int is hardly a "dear" cost.
03:14:33 <ddarius> srhb: Use replicateM
03:15:01 <srhb> ddarius: How does that solve it? Isn't it exactly equivalent?
03:15:25 <ddarius> srhb: It doesn't solve it, but it will make your code much clearer, and perhaps make the solution clearer to you.
03:15:52 <mrcarrot> what is really the diffence between Control.Monad.Reader from monads-fd and mtl?
03:30:39 <rostayob> mrcarrot: i think that now mtl is equivalent to monads-fd... i think that the problem before was that mtl used his own datatypes
03:31:13 <mrcarrot> okay, thanks
03:35:15 <gregATio> er guys i got another one for you :#S
03:35:30 <gregATio> palidrome implementation
03:36:06 <ion> (==) <*> reverse
03:36:08 <mrcarrot> to check if something is a palindrome?
03:36:25 <gregATio> no just tor create a palidrome from a list
03:36:30 <gregATio> dont want the answer
03:36:38 <gregATio> just want to know whats wrong with my solution
03:36:43 <gregATio> pasting ....
03:38:23 <hpaste> gregATio pasted “palidrome” at http://hpaste.org/56228
03:38:57 <srhb> Alright, this is still giving me a lot of trouble. I have this now: replicateM numRows $ replicateM numCols readLn. I think what I want to do is map something like (print "foo" >> id) onto each row... But I'm not sure how to do that (or if it even makes sense)
03:39:26 <gregATio> struggling with types at the mo
03:39:35 <srhb> :t (:)
03:39:36 <lambdabot> forall a. a -> [a] -> [a]
03:39:47 <srhb> x is not a list
03:40:20 <srhb> > [1,2] : 2
03:40:21 <lambdabot>   No instance for (GHC.Num.Num [[t]])
03:40:21 <lambdabot>    arising from a use of `e_1122' at <i...
03:41:26 <ddarius> srhb: Now lay it out more like an imperative language.
03:42:34 <hpaste> ddarius pasted “replicateM” at http://hpaste.org/56229
03:42:47 <srhb> ddarius: I got it
03:42:52 <srhb> The lay it out as imperative did the tricl
03:42:59 <srhb>  replicateM numRows $ print "foo" >> replicateM numCols readLn
03:43:24 <ddarius> putStrLn "foo" presumably...
03:43:30 <srhb> Right.
03:43:55 <srhb> Now I just need to count somehow. :-)
03:45:11 <mrcarrot> gregATio: you can only put something infront of a list with :. 1:[2,3,4] will work, but not [1,2,3]:4
03:46:02 <ddarius> srhb: Go from replicateM to mapM [1..numRows]
03:46:13 <gregATio> thanks mrcarrot
03:46:52 <gregATio> ive created a solution of toPal (x:xs) = x:toPal xs:++[x]
03:47:01 <gregATio> feels really ugly
03:47:17 <gregATio> and slow, because appending is expensive, but hey
03:47:19 <gregATio> it works
03:54:45 <Sgeo> @hoogle (a -> Bool) -> Chan a -> Chan a
03:54:46 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
03:54:46 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
03:54:46 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
04:05:53 <ddarius> Sgeo: You could make a Chan that supports an operation like that, or you could make an IO action that will produce a new Chan that will behave as I'm guessing you want.
04:15:43 <gregATio> ion how exactly does one use (==) <*> reverse to determine whether something is a palindrome , i have read about the applicative function , but am still a noob at using it
04:16:32 <aristid> > (==) <*> reverse $ "1234321"
04:16:33 <lambdabot>   True
04:16:36 <aristid> > (==) <*> reverse $ "123432"
04:16:37 <ion> http://heh.fi/haskell/functors/#function-instance
04:16:37 <lambdabot>   False
04:16:41 <ion> @unpl (==) <*> reverse
04:16:41 <lambdabot> ((==) <*> reverse)
04:16:53 <gregATio> sweet
04:16:58 <ion> (==) <*> reverse just means \x -> x == reverse x
04:17:07 <ion> @type (<*>)
04:17:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:17:15 <ion> @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
04:17:16 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
04:17:26 <gregATio> thanks
04:17:26 <ion> @djinn (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
04:17:26 <lambdabot> f a b c = a c (b c)
04:17:57 <gregATio> whats djinn?
04:18:28 <ion> The type of <*>, when specialized to the (->) a instance, dictates the only correct behavior, which is (<*>) f g x = f x (g x).
04:18:47 <ion> It tries to come up with a sensible implementation given a type.
04:19:47 <Sgeo> @djinn (a -> a) -> a
04:19:47 <lambdabot> -- f cannot be realized.
04:19:59 <Sgeo> How surprising.
04:20:08 <Sgeo> (note: not really)
04:20:57 <gregATio> er thats pretty damn incredible,
04:21:03 <gregATio> is that in ghci
04:21:29 <Sgeo> :t asAppliedTo
04:21:30 <lambdabot> forall t b. (t -> b) -> t -> t -> b
04:24:44 <ion> gregatio: Not by default. See djinn on Hackage.
04:24:48 <ion> @hackage djinn
04:24:48 <lambdabot> http://hackage.haskell.org/package/djinn
04:24:55 <ion> @src asTypeIn
04:24:55 <lambdabot> a `asTypeIn` f = a where _ = f a
04:24:56 <lambdabot> infixl 0 `asTypeIn`
04:25:15 <ion> f asAppliedTo x = f `asTypeIn` ($x)
04:25:43 <ion> `asAppliedTo`
04:25:49 <sipa> :t asTypeIn
04:25:50 <lambdabot> forall a b. a -> (a -> b) -> a
04:32:35 <erus`> have you ever written code that is so complex and such a mess that when you look at it the next day you have no idea how it works?
04:33:52 <gregATio> i think we've all been there erus`
04:33:59 <alistra> alistra@bialobrewy state-machine-optimizer % ghc -prof -auto-all OptimizerMain.hs
04:33:59 <alistra> ghc: unrecognised flags: -prof -auto-all OptimizerMain.hs
04:34:09 <alistra> in the manual it says, that they exist
04:35:24 <gregATio> can you install djinn via cabal?
04:35:58 <rostayob> gregATio: yes
04:36:00 <srhb> http://hpaste.org/56232 <-- I'm still stuck here. I was thinking of using zipWith with a (mapM print [1..numRows]) instead of the print statement inside the replicateM, but I can't figure out how to proceed.
04:38:55 <ddarius> srhb: Go from replicateM to mapM [1..numRows]
04:39:22 <srhb> Can you give a hint on how to do that?
04:39:46 <ddarius> You replace the replicateM with mapM [1..numRows]
04:40:42 <ddarius> s/mapM/forM/
04:40:49 <ddarius> @src forM
04:40:49 <lambdabot> forM = flip mapM
04:46:23 <hpaste> srhb annotated “Read matrix” with “Read matrix (annotation)” at http://hpaste.org/56232#a56234
04:47:00 <srhb> I figured it out! I had tried flip mapM before, ( didn't realize there was a forM) but I didn't make the actual lambda expression, and the second do statement took no argument.
04:47:07 <srhb> Hence the fail. Thank you very much ddarius.
04:50:34 <Sgeo> makeDef text = [d|helloDefinition = $(litE . stringL $ text)|]
04:50:40 <Sgeo> Is there a better way to do that?
04:52:02 <erus`> @hoogle a _> b -> a
04:52:02 <lambdabot> Warning: Unknown type >
04:52:03 <lambdabot> No results found
04:52:08 <erus`> @hoogle a -> b -> a
04:52:08 <lambdabot> Prelude const :: a -> b -> a
04:52:09 <lambdabot> Data.Function const :: a -> b -> a
04:52:09 <lambdabot> Prelude seq :: a -> b -> b
05:03:22 <gregATio> i have a lambda which given a number will return true if the length of the list given is > than the argument supplied
05:03:24 <gregATio> i.e.
05:04:14 <gregATio> lenFunc x = (\ls -> length ls < x)
05:04:32 <gregATio> is there a neater way of creating this function?
05:04:58 <rostayob> lenFunc x ls = length ls < x?
05:05:18 <Sgeo> Note that it might be better to write it recursively, without using length
05:05:31 <rostayob> @pl \ls -> length ls < x
05:05:31 <lambdabot> (< x) . length
05:05:32 <ion> sgeo: Huh. Why?
05:05:34 <Sgeo> Because length will walk the entire list, and fail on infinite lists.
05:05:46 <rostayob> lenFunc x = (< x) . length, but that's pretty unreadable
05:05:57 <ion> Ah, i didn’t pay enough attention. :-)
05:06:00 <Sgeo> If you just need to know that the list is longer than x, you shouldn't need to do that
05:08:45 * mjrosenb is suprised ghc isn't smart enough to do that
05:09:02 <mjrosenb> although, i guess it does change the evaluation semantics in a noticable way
05:10:44 * Sgeo has no idea if GHC is smart enough
05:11:12 <ion> λ> quickCheck $ \n xs -> n >= 0 ==> (length xs <= n) == null (drop n xs)
05:11:12 <ion> +++ OK, passed 100 tests.
05:11:19 <ion> That matches ‘<=’
05:14:00 <mjrosenb> is the n>=0 requirement necessary?
05:14:41 <rostayob> > drop -2 [1,2]
05:14:42 <lambdabot>   Overlapping instances for GHC.Show.Show
05:14:42 <lambdabot>                              (GHC.T...
05:14:49 <rostayob> > drop -2 [1::Int,2]
05:14:50 <lambdabot>   Overlapping instances for GHC.Show.Show
05:14:50 <lambdabot>                              (GHC.T...
05:15:02 <rostayob> > drop (-2) [1::Int,2]
05:15:02 <lambdabot>   [1,2]
05:15:50 <ion> > (length "foo" <= (-1), null (drop (-1) "foo"))
05:15:51 <lambdabot>   (False,False)
05:15:53 <rostayob> mjrosenb: yes, otherwise the first part would always be false while the second might be true
05:16:02 <rostayob> with a negative n
05:16:10 <rostayob> > length [] <= -2
05:16:11 <lambdabot>   False
05:16:20 <rostayob> > null (drop -2 [])
05:16:21 <lambdabot>   Couldn't match expected type `[a]'
05:16:21 <lambdabot>         against inferred type `GHC.Types...
05:16:24 <rostayob> argh
05:16:26 <rostayob> whatever
05:16:42 <mjrosenb> right...
05:17:02 <ion> > (length [] <= (-1), null (drop (-1) []))
05:17:03 <lambdabot>   (False,True)
05:17:28 <gregATio> er whats @pl
05:17:40 <Cody_> :t drop
05:17:41 <lambdabot> forall a. Int -> [a] -> [a]
05:17:47 <rostayob> gregATio: converts a function to point-free form. in other words, it removes abstractions
05:17:52 <rostayob> @pl \x -> foo x
05:17:52 <lambdabot> foo
05:18:02 <ion> Removes abstractions?
05:18:03 <gregATio> oooooh
05:18:21 <rostayob> ion: at the syntax level
05:18:24 <gregATio> i like that (<x).length
05:18:39 <rostayob> gregATio: I don't. i think that the other form is clearer
05:19:12 <ion> > (null (drop 42 [0..]), length [0..] <= 42)
05:19:16 <lambdabot>   mueval-core: Time limit exceeded
05:19:25 <ion> > null (drop 42 [0..])
05:19:26 <lambdabot>   False
05:19:39 <dmwit> :t groupBy
05:19:40 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
05:19:51 <gregATio> i really like this group , im learning so much
05:20:17 <rostayob> gregATio: studies have shown that #haskell makes you smarter
05:20:17 <Sgeo> Is ExistentialQuantification controversial?
05:20:26 <rostayob> 8 out of 10 programmers agree
05:20:52 <Cody_> Who are the other 2 who dont?
05:21:07 <rostayob> Cody_: they're PHP programmers. ah ah.
05:21:13 <rostayob> it's funny because of PHP
05:21:19 <Cody_> Good one.^
05:22:57 <Cody_> >  let take5s = filter (==5) in map take5s [[1,5],[5],[1,1]]
05:22:58 <lambdabot>   [[5],[5],[]]
05:23:10 <Cody_> Why doens't it produce one condesned List?
05:23:36 <erus`> is there a monad Bool
05:23:46 <erus`> or some function like do this if false?
05:23:59 <Cody_> else statement
05:24:03 <ion> cody: Because that’s not what you asked for. :-)
05:24:08 <ion> cody: You could try concatMap.
05:24:19 <mokus> because filter returns a list, and map returns a list of results (which are lists)
05:24:44 <Sgeo> when . not ?
05:24:48 <Sgeo> :t when . not
05:24:49 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:25:54 <Sgeo> erus`, ^
05:28:04 <Cody_> :t filter
05:28:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:28:06 <erus`> this is the ugly bit        (\r -> if r then Left r else chckAnyOf chckd x (yf, ys))
05:28:14 <Cody_> :t map
05:28:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:28:35 <erus`> @hoogle bool
05:28:35 <lambdabot> Prelude data Bool :: *
05:28:35 <lambdabot> Data.Bool data Bool :: *
05:28:36 <lambdabot> Data.Bool module Data.Bool
05:29:18 <Cody_> :t
05:29:22 <Cody_> :t sum
05:29:23 <lambdabot> forall a. (Num a) => [a] -> a
05:29:36 <erus`> @hoogle a -> b -> Bool -> c
05:29:37 <lambdabot> Language.Haskell.TH.Syntax PrimTyConI :: Name -> Int -> Bool -> Info
05:29:37 <lambdabot> Language.Haskell.TH PrimTyConI :: Name -> Int -> Bool -> Info
05:29:37 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
05:30:08 <dmwit> :t unless
05:30:08 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:30:11 <dmwit> Sgeo: =)
05:30:12 <Cody_> >sum (filter (>5) [1..100])
05:30:23 <Sgeo> Oh
05:30:25 <Cody_> > sum (filter (>5) [1..100])
05:30:26 <lambdabot>   5035
05:30:32 <Cody_> Huh
05:30:47 <dmwit> erus`: But yes, I would use something like "unless r $ chckAnyOf chckd x (yf, ys)".
05:31:14 <Cody_> If filter returns a list and sum returns anything of type a. It returns type a because sum was the last function to act on it?
05:31:17 <dmwit> erus`: There's an instance Error e => Monad (Either e)
05:31:41 <dmwit> Cody_: It doesn't return anything, it can only return types a that are instances of Num.
05:31:53 <dmwit> Cody_: (Hence the "(Num a) =>" context.)
05:31:56 <ion> @type filter (== 5)
05:31:57 <lambdabot> forall a. (Num a) => [a] -> [a]
05:31:59 <ion> @type map (filter (== 5))
05:32:00 <lambdabot> forall a. (Num a) => [[a]] -> [[a]]
05:32:22 <Cody_> Can I cast sum to return type []?
05:32:39 <dmwit> No, but you can certainly wrap it in a list.
05:32:44 <dmwit> For example:
05:32:49 <dmwit> :t \xs -> [sum xs]
05:32:50 <lambdabot> forall a. (Num a) => [a] -> [a]
05:32:54 <dmwit> :t \xs -> [sum xs, product xs]
05:32:55 <lambdabot> forall a. (Num a) => [a] -> [a]
05:32:57 <Cody_> Ok
05:33:01 <McManiaC> did they recently change the mtl/transformer packages? they used to be mutual exclusive, didnt they?
05:33:03 <Cody_> Hold on.
05:33:04 <dmwit> :t \xs -> replicate 42 (sum xs)
05:33:05 <lambdabot> forall a. (Num a) => [a] -> [a]
05:33:24 <erus`> is there a package to trace every function call?
05:33:34 <erus`> like step evaluation or something?
05:33:36 <dmwit> McManiaC: Packages don't have a way to specify mutual exclusion.
05:33:50 <mokus> McManiaC: yes, mtl now uses transformers so their types are compatible
05:33:51 <Cody_> > replicate 1 (sum (filter (>5) [1..100]))
05:33:52 <lambdabot>   [5035]
05:33:53 <dmwit> erus`: "hat" used to do that, but it only works on strictly H98 programs (so basically none).
05:33:57 <Cody_> :t replicate
05:33:58 <lambdabot> forall a. Int -> a -> [a]
05:34:05 <mokus> McManiaC: basically, mtl is the new monads-fd
05:34:07 <dmwit> erus`: The ghci debugger is the closest thing we have now.
05:34:08 <Cody_> > replicate (sum (filter (>5) [1..100]))
05:34:08 <McManiaC> mokus: ok nice :)
05:34:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
05:34:09 <lambdabot>    arising from a use of...
05:34:19 <Cody_> > replicate 3 (sum (filter (>5) [1..100]))
05:34:20 <lambdabot>   [5035,5035,5035]
05:34:59 <Cody_> > let (a,b) = (10,12) in a * 2
05:34:59 <Sgeo> If I have a choice between writing a script to write Haskell code for me, or writing Template Haskell, what should I do?
05:35:00 <lambdabot>   20
05:35:00 <dmwit> > return (sum (filter (>5) [1..100])) :: [Integer]
05:35:01 <lambdabot>   [5035]
05:35:15 <Cody_> :t return
05:35:15 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:35:24 <Cody_> ?
05:35:26 <dmwit> return :: a -> [a]
05:35:33 <Cody_> thanks
05:35:38 <dmwit> return = \x -> [x]
05:35:58 <dmwit> It's just a name for one of the other solutions I posted above. =)
05:36:11 <ion> (:[])
05:36:24 <ion> the robot
05:36:26 <McManiaC> Sgeo: I'd go with TH
05:36:50 <dmwit> Sgeo: What's your scripting language?
05:36:58 <dmwit> I think I'd choose TH over sh for generating Haskell code.
05:37:00 <Cody_> > replicate 1 (fst (10,12) * 2)
05:37:00 <lambdabot>   [20]
05:37:12 <Sgeo> dmwit, if I said Haskell, is that a wrong answer? >.>
05:37:12 <dmwit> Not sure whether I'd choose TH over Haskell for generating Haskell code in every case, though.
05:37:17 <ion> Please don’t use replicate 1. That’s dirty. :-P
05:37:18 <dmwit> No, it's not a wrong answer.
05:37:23 <Cody_> > return (fst (10,12) * 2)
05:37:24 <lambdabot>   No instance for (GHC.Show.Show (m t))
05:37:24 <lambdabot>    arising from a use of `M6119027593...
05:37:29 <Cody_> It works
05:37:33 <dmwit> > (:[]) (fst (10,12) * 2)
05:37:33 <lambdabot>   [20]
05:37:41 <erus`> yey my type checker works :) an infinite list type checks as a normal (possibly finite) list
05:37:44 <dmwit> > [fst (10,12) * 2]
05:37:45 <lambdabot>   [20]
05:38:26 <dmwit> Cody_: Usually, there's no need to use replicate 1, return, or (:[]).
05:38:41 <dmwit> Cody_: If you have the value you're going to apply them to, just apply them and evaluate that to a list straight away!
05:38:43 <Cody_> Just use brackets around the expression
05:38:46 <dmwit> Yes.
05:39:15 <ion> cody: Why do you want a list of a single item?
05:39:46 <Cody_> I don't. I want to convert an Int -> List
05:39:47 <Sgeo> The correct answer is maybeToList . Just (kidding)
05:39:55 <Cody_> And I'm experimenting.
05:40:23 <Cody_> > [(fst (10,12) * 2, True)]
05:40:24 <lambdabot>   [(20,True)]
05:43:14 <gregATio> bbl guys thanks for the inout
05:46:27 <ski> > replicate 0 undefined
05:46:28 <lambdabot>   []
05:48:27 <gregATio> thanks guys bbl
05:48:38 <ion> bbq
06:02:38 <erus`> whether i name the argument or not has no effect on the function body right? (providing it does not use the args)
06:03:00 <erus`> > let f a = const in f 1 2
06:03:00 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
06:03:01 <lambdabot>    arising from a use of `...
06:03:21 <erus`> > let f = const in f 1 2
06:03:22 <lambdabot>   1
06:03:48 <Sgeo> The first expression turned into const 2
06:03:59 <Sgeo> Which is a function, which doesn't have a Show instance
06:04:12 <ion> > let f a = a in f 1 2
06:04:13 <lambdabot>   1
06:04:22 * ion ducks
06:04:30 <Sgeo> erus`, if you want to not name an argument, and aren't doing pointfree, use _
06:06:32 <dmwit> erus`: No, there is a difference.
06:06:46 <dmwit> erus`: In particular, when there are lets, they are shared more aggressively the fewer outer bindings there are.
06:06:56 <dmwit> (Same for "where" clauses.)
06:07:36 <dmwit> I believe at higher optimization levels GHC does let-floating to negate this difference, but it's one to be aware of on low optimization levels / other compilers.
06:11:32 <dmwit> It also can change the inferred type / error status of type inference if MonomorphismRestriction is on.
06:11:44 <Blkt> good day everyone
06:31:59 <Sgeo> Do lazy queues exist?
06:32:31 <erus`> do you guys listen to ambient music while programming?
06:33:09 <ion> We listen to Justin Bieber when programming.
06:33:28 <erus`> each to their own
06:33:29 <ben_m> I listen to dubstep when coding Perl.
06:34:00 <ben_m> Other languages, no music.
06:34:18 <ion> cat dubstep_song.ogg, cat perl_program.pl. Not much of a difference.
06:40:18 <Cody_> Every listen to cinema?
06:41:43 <Cody_> http://www.youtube.com/watch?v=GiyAJxacEo0&feature=fvst
06:41:47 <Cody_> Skip to 1:20
07:23:59 * hackagebot pqc 0.4.2 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.4.2 (KidoTakahiro)
07:25:01 <ben_m> Are there any idiomatic Haskell wrappers for OpenGL or maybe SDL?
07:26:24 <ddarius> HOpenGL is more idiomatic than the raw bindings...
07:28:37 <Saizan> gloss also, but i've read mixed opinions about it
07:31:22 <e98> is there an updated to deepseq on hackage planned which changes the array upper bound to <0.5?
07:31:36 <e98> required for bootstrapping cabal-install with ghc-7.4
07:32:02 <ben_m> Saizan, gloss seems cool for something like prototyping something visual
07:32:08 <ben_m> But not for an actual game, I think
07:32:17 <ben_m> But it's pretty awesome regardless.
07:33:16 <Saizan> e98: such things get usually done when the ghc in question is released
07:34:03 <e98> Saizan: I see. it's a pity as most packages seem to anticipate such a bound and are already good to go
07:34:44 <parcs`> e98: just build ghc HEAD
07:35:15 <e98> e98: how is that going to fix deepseq's cabal file? confused
07:35:27 <parcs`> disregard that, install deepseq HEAD
07:35:52 <parcs`> or just change the upper bound yourself
07:36:26 <e98> sure, I could do that
07:36:44 <roconnor> @type runReaderT
07:36:45 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
07:37:33 <e98> parcs`, it's still 0.4 in HEAD
07:39:25 <parcs`> e98: ah.. where are you pulling array 0.4 from anyway?
07:40:01 <e98> parcs`: also one of Ian's releases :) ghc 7.4 rc1
07:40:58 <parcs`> i see
07:41:32 <e98> I'll do it manually and see what else needs changing.....
07:41:44 <parcs`> checkout the branch "ghc-7.4" from the deepseq repo :)
07:48:11 <estan> evening folks. what would be the most elegant way to check if a String is some sequence of 'A', 'B', 'C' and 'D'? (like e.g. "ABBCDDBBDD")
07:48:34 <koeien> :t all (`elem` "ABCD")
07:48:35 <lambdabot> [Char] -> Bool
07:48:51 <estan> ah. naturally. thanks.
07:51:55 <halcyon10> hi, i'm trying to get mersenne-random-pure64's PureMT PRNG to work as an instance of MonadRandom. With my current code http://hpaste.org/56249 it uses the default RandomGen instance, but this one crashes because the PureMT package doesn't implement the splitting of generators. How can i roll my own instance?
07:52:11 <koeien> newtype it
07:52:43 <koeien> newtype MyPureMT = MyPureMT PureMT
07:52:46 <koeien> and then write the instance.
07:53:29 <Martty> you this read wrong
07:53:36 <halcyon10> koeien: thanks, i'll try that. Do i have to write boilerplate instances for every class then?
07:53:56 <koeien> halcyon10: look into the extension GeneralizedNewtypeDeriving
07:54:02 <koeien> Martty: how? please enlighten me :)
07:54:13 <halcyon10> koeien: thanks
07:59:00 * hackagebot enummapset 0.1.0 - IntMap and IntSet with Enum keys/elements.  http://hackage.haskell.org/package/enummapset-0.1.0 (MichalTerepeta)
08:00:04 <Sgeo> Hmm
08:00:08 <Sgeo> What is State# ?
08:00:26 <koeien> most likely a GHC internal, judging by the #
08:00:36 * Sgeo knows that much
08:00:59 <koeien> that's where my knowledge ends.
08:01:08 <cheater_> try #ghc
08:01:15 <rwbarton> @src State#
08:01:16 <lambdabot> Source not found. I am sorry.
08:01:35 <rwbarton> I think it's just   data State# s = State#
08:02:43 <Sgeo> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html why is this so ugly with LaTex stuff strewn all around?
08:02:51 <rwbarton> except it doesn't even have a runtime representation
08:03:40 <mm_freak> Sgeo: might be literal haskell
08:03:55 <koeien> it is
08:04:06 <Sgeo> Is there a more readable version? There should be, if it's using Literate Haskell
08:04:18 <mm_freak> yes, compile the source using latex =)
08:04:24 <mm_freak> then you get a PDF
08:04:53 <koeien> but then you don't have links..
08:05:23 <mm_freak> if the latex code is written properly you have
08:05:39 <roconnor> Wadler was right about using monads.
08:05:40 <mm_freak> you don't get haddock-style links though
08:05:43 <Sgeo> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
08:06:16 <mm_freak> Sgeo: i recommend to forget that definition and pretend you never read it
08:06:27 <koeien> afaik this is used to introduce a data dependency so that IO effects are executed in the correct order
08:06:28 <ski> roconnor ?
08:06:33 <alistra> @pl optimize char = (return . sameArgBranchRemoval $ char) >>= (return . notAccessibleBranchRemoval) >>= trivialAndRemoval
08:06:33 <lambdabot> optimize = (trivialAndRemoval =<<) . (notAccessibleBranchRemoval `fmap`) . return . sameArgBranchRemoval
08:06:49 <Sgeo> mm_freak, I saw something using the IO constructor once
08:06:51 <Sgeo> Forgot what
08:06:57 <Sgeo> But I don't think it was a GHC internal
08:07:11 <Sgeo> Or maybe it was, just not at a level where I would expect that
08:07:14 <koeien> why would you want to do that? /me cannot imagine a situation
08:07:51 <mm_freak> Sgeo: there are a few models for IO, but none of them really work satisfactorily
08:08:15 <mm_freak> one particularly bad one is depicting IO as a giant state monad
08:08:30 <mm_freak> neither does that work too well, nor is it what you are seeing in the base library source code
08:09:36 <Sgeo> mm_freak, so the reason you want me to forget it is that the GHC code doesn't do what it looks like it's doing?
08:10:25 <mm_freak> Sgeo: it might lead you to wrong conclusions…  as koeien said, it's really just a data dependency…  it does implicitly what Clean does explicitly
08:11:09 <halcyon10> koeien: now the MonadRandom instance is working. http://hpaste.org/56252 Thanks again!
08:11:40 <Sgeo> What would happen if I did try to do something like weird a = IO \s -> (s, a)
08:11:54 <mike-burns> :t IO
08:11:55 <lambdabot> Not in scope: data constructor `IO'
08:11:59 <mike-burns> That.
08:12:35 <Sgeo> Importing the constructor from GHC.Types or whatever else exposes the constructor, of course
08:12:54 <mm_freak> Sgeo: nothing much actually
08:13:07 <Sgeo> Would it act like return?
08:13:14 <Sgeo> Or is it broken in some way?
08:13:20 <mm_freak> Sgeo: in the worst case you would get an IO action that messes up execution order
08:14:18 <Sgeo> (Besides being accidentally a boxed tuple when I should have done (# #)
08:16:24 <mm_freak> Sgeo: never done that myself, but i think you are basically writing an unsafeInterleaveIO-ed IO action there
08:16:37 <mm_freak> but not sure about that
08:16:43 * Sgeo has a feeling that the definitions in GHC.Prim are dummy definitions. Can't imagine why, it's not like they're all basically _|_ if looked at literally
08:17:26 <parcs`> GHC.Prim is just documentation
08:17:57 <Sgeo> Hmm? It doesn't need to be imported, or?
08:18:05 <Sgeo> Or wait, would importing it work without the file?
08:18:20 <Sgeo> Hmm, does Haddock barf if definitions aren't supplied? Does GHC?
08:18:22 <Igloo> The file is only for haddock; see the comment at the top
08:18:33 <Sgeo> Ah, ty
08:19:03 <Sgeo> I take it Haddock barfs without the dummy definitions though?
08:19:41 <parcs`> it wouldnt be valid haskell
08:25:08 <mm_freak> do i read the kind signature right for (->) that when using primitive types like Int#, currying is impossible?
08:25:51 <dolio> What do you mean by that?
08:26:15 <dolio> Int# -> Int# -> Int# is a valid type.
08:26:22 <mm_freak> by the kind signature a function of type Int# -> Int# -> Int# seems impossible
08:26:28 <mm_freak> oh
08:26:38 <copumpkin> :k (->)
08:26:39 <lambdabot> ?? -> ? -> *
08:26:46 <copumpkin> the ? is a superkind of *
08:26:57 <mm_freak> ah, i see
08:26:58 <copumpkin> in fact, it's a superkind of almost every other kind
08:28:12 <js2> how do you compile haskell source code in windows?
08:28:24 <mm_freak> if you had a real kind system with kind classes, kind families and so on, what would the kind signature of (->) look like?
08:28:25 <donri> haskell-platform is a good place to start
08:28:30 <donri> @ js2
08:28:34 <donri> @where platform
08:28:34 <lambdabot> http://hackage.haskell.org/platform/
08:28:40 <js2> Downloaded already
08:28:44 <dolio> What is non-real about the current system?
08:29:12 <cheater_> js2: you first need to install a recent version of ghc
08:29:16 <cheater_> then you get the interpreter sources
08:29:28 <donri> doesn't the platform installer install ghc?
08:29:28 <js2> Is that included in the haskell platform?
08:29:29 <cheater_> and free up your computer for the next couple of days or so
08:29:33 <cheater_> yes
08:29:47 <mm_freak> js2: just install the haskell platform and you are ready to go
08:30:01 <koeien> js2: go to the command line, cd to the directory where your sources reside, enter ghc --make YourFile.hs -O2
08:30:06 <js2> Where is GHC, not GHCi?
08:30:06 <koeien> disclaimer: i don't use windows.
08:30:35 <mm_freak> dolio: i think they annoucned GHC 7.4 with "now we have a real kind system"
08:30:56 <dolio> The kind of (->) isn't changing.
08:30:59 <byorgey> mm_freak: no, now we have a richer kind system.  there was nothing fake about the kind system before.
08:31:13 <byorgey> also, we still don't have kind classes or kind families.
08:31:15 <mm_freak> i guess because the current "kind system" is really just for annotations…  you don't have much kind checking, no kind polymorphism at all, etc.
08:31:29 <byorgey> we do now have kind polymorphism.
08:31:33 <byorgey> and we have always had kind checking.
08:31:44 <dolio> If you wanted to use some kind of kind-polymorphic type, you'd instead need a level above kinds that classifies the kinds that can go in each spot.
08:31:46 <mm_freak> yeah, i know
08:31:53 <mm_freak> i still have GHC 7.0.3 =)
08:32:15 <mm_freak> GHC 7.4 broke too many packages, so i'll be patient a bit
08:32:24 <byorgey> GHC 7.4 gets away without a level above kinds by arranging things so that level would have only one inhabitant
08:32:31 <byorgey> so it can just be omitted.
08:32:41 <js2> koein: make isn't the command
08:32:45 <dolio> But that's a lot of extra stuff for just (->).
08:32:55 <koeien> js2: no,  "ghc --make YourMainFile.hs -O2"
08:33:04 <koeien> --make is an argument to ghc
08:33:13 <mm_freak> in any case…  if you have a rich kind system, what would the kind signature for (->) look like?
08:33:29 <Sgeo> http://hackage.haskell.org/trac/ghc/wiki/Commentary is this stuff up to date?
08:33:39 <mm_freak> (->) :: a -> Co a -> Function
08:33:43 <mm_freak> something like that?
08:34:21 <js2> koein: Will it be a problem that I store my source codes in C:\Haskell Programs. Not in C:\Haskell?
08:35:07 <koeien> js2: that should not matter, in fact it's better to keep it separate
08:35:27 <js2> I should specify the C: is a USB
08:36:06 <dolio> It looks  like (->) :: forall (a :: ??) (b :: ?). a -> b -> *
08:36:58 <mm_freak> dolio: huh?  "??" and "?" being inhabitants of one level above kinds?
08:37:05 <dolio> Yes.
08:37:28 <dolio> You need something that classifies * and #, and something that classifies *, # and (#).
08:37:28 <js2> koein: So for example. C:\Haskell Programs> % ghc --make Test.hs -o test.exe
08:37:46 <koeien> js2: yes, does that work?
08:37:50 <js2> No
08:37:51 <dolio> So I reused the names.
08:38:02 <mm_freak> dolio: a kind family couldn't do that?
08:38:02 <koeien> js2: what is the error message?
08:38:22 <mm_freak> dolio: (->) :: FuncArg a => a -> Co a -> Function
08:38:25 <mm_freak> something like that?
08:38:39 <js2> koeien: % is not recognized as an internal or external command, operable program or batch file
08:38:40 <dolio> The kinds of the arguments are unrelated.
08:38:45 <koeien> js2: ah drop the %
08:38:52 <koeien> i missed that the first time
08:39:22 <koeien> (% is sometimes used to signify a command prompt in unix.)
08:39:22 <mm_freak> dolio: i thought, if the argument type is primitive, the result type must be primitive, too
08:39:24 <js2> koeien: Now I get "ghc is not recongized as an internal or external...."
08:39:28 <dolio> No.
08:39:46 <hpc> koeien: i thought the convention was '$' for user prompts, and '#' for root
08:39:58 <mm_freak> ok, in that case you don't even need the kind family
08:40:06 <koeien> hpc: csh uses % afair
08:40:15 <mm_freak> what about (->) :: (FuncArg a, FuncArg b) => a -> b -> Function?
08:40:32 <koeien> js2: that means that the ghc executable is not on your PATH
08:40:36 <mm_freak> or even a separate class FuncResult
08:40:53 <dumiopky> the snap framework has a channel?
08:41:00 <koeien> dumiopky: #snapframework
08:41:39 <koeien> js2: i'm not sure how to help you further with this, you could try to point to the exact ghc executable instead
08:41:53 <koeien> e.g.   c:\Haskell\bin\ghc.exe --make Test.hs -o test.exe
08:41:57 <js2> That'd be easier.
08:42:15 <koeien> (but i'm not sure whether that'll work, and I don't know where exactly your ghc.exe resides.)
08:42:42 <Sgeo> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/STM why is this blank?
08:44:06 <js2> koein: It'd be C:\Haskell\2011.4.0.0\bin> ghc --make Test.hs -o test.exe
08:44:42 <js2> koeien: Then it throws "<no location info>: can't find file: Test.hs
08:45:08 <koeien> js2: yeah try to move to the directory where your Test.hs resides first, then
08:45:22 <koeien> c:\Haskell\2011.4.0.0\bin\ghc --make Test.exe -o test.exe
08:46:01 <js2> Move to the directory inside C:\Haskell\2011.4.0.0\bin> ?
08:46:14 <js2> Source files are here: C:\Haskell Programs
08:46:38 <js2> GHC is here: C:\Haskell\2011.4.0.0\bin>
08:46:54 <koeien> yeah so first   cd "C:\Haskell Programs"
08:47:05 <ddarius> Man.  Every programmer should have to work with old school MS-DOS where you need to fiddle the autoexec.bat and config.sys to get things to run and manage memory, and/or build a Linux from scratch.
08:48:13 <js2> koeien: Ok, not sure where you going with this, but what's next.
08:48:21 * ddarius weeps.
08:48:23 <koeien> js2: after the cd, enter
08:48:26 <koeien> c:\Haskell\2011.4.0.0\bin\ghc --make Test.exe -o test.exe
08:49:28 <eyebloom> Is there any good resource for learning to analyze algorithms written in pure functional languages?
08:51:29 <ddarius> @google resources for learning to analyze algorithms written in a pure functional language
08:51:30 <lambdabot> http://en.wikipedia.org/wiki/Haskell_(programming_language)
08:51:30 <lambdabot> Title: Haskell (programming language) - Wikipedia, the free encyclopedia
08:51:41 <ddarius> Stupid Wikipedia.
08:51:42 <koeien> lol
08:52:55 <eyebloom> I just want to show how a particular function scales.
08:55:07 <Omer_> @type map
08:55:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:57:52 <js2> koeien: The problem is that I had to move my Haskell Programs folder into C:\Haskell\2011.4.0.0\bin
08:58:14 <js2> which I think thats what you were saying
08:59:04 * ddarius weeps.
09:01:57 <szablica> Hi.
09:02:43 <szablica> I get something surprising when I try to load the Control.Monad.State module into ghci.
09:02:48 <szablica> Prelude> :m +Control.Monad.State
09:02:49 <szablica> <no location info>:
09:02:49 <szablica>     Ambiguous module name `Control.Monad.State':
09:02:49 <szablica>       it was found in multiple packages: monads-fd-0.2.0.0 mtl-2.0.1.0
09:03:14 <szablica> Any ideas in what could cause it?
09:03:20 <koeien> you might be able to get away with hiding mtl
09:03:22 <koeien> ghc-pkg hide mtl
09:03:35 <koeien> szablica: you have two packages installed that expose the same module
09:03:44 <koeien> mtl is deprecated i think
09:04:19 <mm_freak> koeien: nope
09:04:21 <mm_freak> mtl 1 is
09:04:40 <koeien> i see
09:05:09 <szablica> So which should I hide?
09:05:22 <geekosaur> and mtl just re-exports monads-fd, I think?
09:05:26 <mm_freak> szablica: an easy solution is:  ghci -XPackageImports
09:05:35 <mm_freak> then write:  import "mtl" Control.Monad.State
09:05:59 <szablica> And what about ghci?
09:06:06 <mm_freak> that is ghci
09:06:31 <mm_freak> i think, monads-fd is deprecated in favor of mtl
09:08:13 <exFalso> if i have a polymorphic list:
09:08:13 <exFalso> ls :: Show a => [a]
09:08:14 <exFalso> ls = undefined
09:08:14 <exFalso> how can i get the length of it?
09:08:33 <szablica> Can I somehow set -XPackageImports in my .ghcirc?
09:08:41 <koeien> :set -XPackageImports
09:08:46 <danr> exFalso: an undefined list does not have a length?
09:08:46 <szablica> kk
09:09:16 <ski> > let ls :: Show a => [a]; ls = undefined in length ls  -- like this, exFalso
09:09:17 <lambdabot>   *Exception: Prelude.undefined
09:09:17 <exFalso> danr: that doesn't matter, im fine if it throws an undefined error, i just need it to compile
09:09:19 <danr> anyway, use length ls
09:09:35 <danr> ok, what ski said :)
09:09:52 <rwbarton> that example is using defaulting for Show
09:09:55 <exFalso> hmm it gives me an ambiguous type error
09:10:16 <ski> so resolve the ambiguity ?
09:10:26 <exFalso> i'll hpaste
09:10:28 <rwbarton> the length of the list may depend on the choice of type
09:10:37 <ski> *nod*
09:11:56 <exFalso> http://hpaste.org/56258
09:12:18 <exFalso> using 7.2.2
09:12:40 <ski>   asd = length (lol :: [MyType])
09:12:58 <ski> where `MyType' is whatever type (in class `Show'), that you want to use
09:13:01 <exFalso> i need to keep it polymorhpic
09:13:05 <mm_freak> is that 7.2.2-specific?
09:13:06 <mm_freak> > length (undefined :: Show a => [a])
09:13:07 <mm_freak> *** Exception: Prelude.undefined
09:13:07 <lambdabot>   *Exception: Prelude.undefined
09:13:16 <ski> exFalso : <rwbarton> the length of the list may depend on the choice of type
09:13:31 <exFalso> ski: how?
09:13:50 <ski> well, depending on the actual class
09:13:53 <exFalso> the real problem is i have a list of [a -> m b] functions and i want to get the length
09:14:04 <exFalso> the above is just the simplified version
09:14:05 <ski> possibly it can't, if you actually have `Show' (and nothing else) in the class constraint
09:14:47 <rwbarton> > let xs :: (Show a, Num a) => [a]; xs = repeat (length $ show (0 `asTypeOf` head xs)) 0 in (xs :: [Integer], xs :: [Double])
09:14:48 <lambdabot>   Couldn't match expected type `t -> [a]'
09:14:48 <lambdabot>         against inferred type `[GHC...
09:14:50 <ski> but e.g. if you had a class like `class Domain a where domain :: [a]', then the length of `domain' can depend on the type `a'
09:14:55 <rwbarton> > let xs :: (Show a, Num a) => [a]; xs = replicate (length $ show (0 `asTypeOf` head xs)) 0 in (xs :: [Integer], xs :: [Double])
09:14:56 <lambdabot>   ([0],[0.0])
09:15:02 <rwbarton> oops
09:15:15 <rwbarton> > show (0 :: Double)
09:15:16 <lambdabot>   "0.0"
09:15:37 <rwbarton> > let xs :: (Show a, Num a) => [a]; xs = xs' where xs' = replicate (length $ show (0 `asTypeOf` head xs')) 0 in (xs :: [Integer], xs :: [Double])
09:15:37 <lambdabot>   ([0],[0.0,0.0,0.0])
09:15:43 <ski> exFalso : and what is the real constraint ?
09:16:10 <exFalso> ski: this is the actual type of the list:
09:16:10 <exFalso> metrics :: (OrderClass o, MonadIO m) => [OrderMovement -> LearnBrainT o m Int]
09:17:29 <exFalso> neither of the type vars can be bound in this part of the code
09:17:36 <ski> in any case, the type of `length' is `[a] -> Int', not `(c => [a]) -> Int'
09:17:51 <ski> i.e. `length' wants a *concrete* list as input
09:18:17 <ski> you can either fix the type, like in `length (lol :: [MyType])'
09:18:18 <exFalso> it is... metrics is defined as metrics = [first element, second element ...]
09:18:46 <mm_freak> ok, in my case it looks like it used defaulting
09:18:48 <ski> or you can defer the choice as in `length lol', and then this expression will have type `Show a => Int'
09:19:02 <ski> (ane because that's ambiguous, you get the ambiguity error)
09:19:09 <exFalso> i tried that latter
09:19:10 <exFalso> yeah
09:19:40 <rwbarton> perhaps you can write [OrderMovement -> (forall o m. (OrderClass o, MonadIO m) => LearnBrainT o m Int)], if this is the true type of metrics
09:19:40 <ski> one way to actually do the latter is to pass some dummy parameter to make it not ambiguous
09:19:53 <rwbarton> I don't know how well that will work though
09:20:09 <exFalso> rwbarton: higher rank types we dont want :)
09:20:30 <rwbarton> well, it is a more accurate type
09:20:40 <ski> so, you will get typing `(OrderClass o,MonadIO m) => Dummy o -> Dummy1 m -> Int'
09:20:48 <rwbarton> that expresses for instance that the length of the list does not depend on the choice of o or m
09:20:58 <exFalso> rwbarton: no, as o and m should be bound before the [] type constructor
09:21:09 <rwbarton> why?
09:21:10 <ski> where `data Dummy :: * -> *' and `data Dummy1 :: (* -> *) -> *'
09:21:19 <exFalso> ski: i'll try that thanks!
09:21:44 <ski> exFalso : note that this will only *defer* the choice of what types to use for `o' and `m', though
09:21:48 <rwbarton> if they need to be, then you need to pick o and m to have a chance to calculate the length
09:22:23 <exFalso> rwbarton: well not binding the monad type won't allow things like sequence or mapM or any of that because it can be whatever, list IO cont
09:22:30 <ski> i.e. some other part of your code will have to actually pick values to use
09:22:32 <exFalso> ski: yes, thanks!
09:22:43 <jmcarthur> is there a name for this property of a binary operation? if S = s1+s2+s3+s3+sn, then S+sm = S, where 1 <= m <= n
09:22:46 <jmcarthur> set union might be an example
09:22:58 <rwbarton> @type let x :: [forall m. m Int] in sequence x
09:22:59 <lambdabot>     The type signature for `x' lacks an accompanying binding
09:22:59 <lambdabot>       (You cannot give a type signature for an imported value)
09:23:03 <rwbarton> @type let x :: [forall m. m Int] ; x = undefined in sequence x
09:23:04 <lambdabot>     Illegal polymorphic or qualified type: forall (m :: * -> *). m Int
09:23:05 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
09:23:05 <lambdabot>     In the type signature for `x': x :: [forall m. m Int]
09:23:14 <ski> exFalso : btw, it's maybe nicer to let `Dummy' and `Dummy1' have a single nullary constructor, instead of having them be constructorless
09:23:14 <jmcarthur> S = s1+s2+s3+s3+...+sn   left out the dits by accident
09:23:16 <jmcarthur> *dots
09:23:59 <jmcarthur> man i suck. you guys know what i mean
09:24:04 <rwbarton> the real solution is probably not to use extraneous polymorphism
09:24:05 <js2> koeien: Figured it out. I have to put the dir in quotes because my dir has a space in it. That is why it wasn't working.
09:24:30 <jmcarthur> i didn't mean to duplicate s3 either
09:24:37 <rwbarton> jmcarthur: idempotent perhaps?
09:24:42 <ski> jmcarthur : maybe you want `forall S. S + S = S', which is idempotency of `(+)' ?
09:24:44 <exFalso> rwbarton: the polymorhpism here is well justified by the design :)
09:24:52 <jmcarthur> rwbarton: that was my first thought too, but i don't think that's right
09:25:00 <rwbarton> "A binary operation is idempotent if, whenever it is applied to two equal values, it gives that value as the result. For example, the operation giving the maximum value of two values is idempotent: max(x, x) = x"
09:25:15 <rwbarton> idempotent has a few sense
09:25:16 <rwbarton> s
09:25:18 <jmcarthur> yeah
09:25:26 <ski> jmcarthur : is `(+)' known to be associative and commutative ?
09:25:46 <jmcarthur> ski: that's not quite what i mean. S+S=S, sure, but this is a more specific property than that
09:25:49 <ski> (and does it have an identity element)
09:25:56 <jmcarthur> it does have an identity
09:26:02 <rwbarton> It's the same property then
09:26:03 <jmcarthur> and it is associative and commutative
09:26:09 <jmcarthur> oh?
09:26:22 <ski> then your property follows from idempotency
09:26:36 <jmcarthur> oh!
09:26:40 <jmcarthur> i see
09:26:52 <Omer_> > map putStrLn [1,2,3]
09:26:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
09:26:53 <lambdabot>    arising from the literal `...
09:26:57 <jmcarthur> a+b+a = b+a+a = b+a
09:26:59 <rwbarton> (s1+s2+...+sn)+sm = (s1+s2+...+s{m-1}+s{m+1}+...+sn)+sm+sm = (s1+s2+...+s{m-1}+s{m+1}+...+sn)+sm = (s1+s2+...+sn)
09:27:09 <jmcarthur> thanks! i see now
09:27:15 <ski> (and, as rwbarton no doubt already saw, if your `n' is `1', then you get the other direction)
09:27:34 <jmcarthur> right
09:27:40 <Omer_> > forever $ putStrLn "a"
09:27:40 <ski> (well, this is assuming `n' is meant to be finite)
09:27:40 <lambdabot>   Ambiguous type variable `b' in the constraint:
09:27:41 <lambdabot>    `Data.Typeable.Typeable b...
09:27:56 <koeien> Omer_: lambdabot won't execute IO actions for you.
09:28:02 <jmcarthur> it's meant to be finite in this case, yes
09:28:05 <ski> > repeat 'a'
09:28:05 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
09:42:31 <exFalso> ski: the Dummy thing doesn't work it's still ambiguous dammit
09:42:32 <fryguybob> @check (\i j -> let fibs = fix (scanl (+) 0 . (1:)) in fibs !! (i `gcd` j) == (fibs !! i) `gcd` (fibs !! j))
09:42:32 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `fix'Not in scope: `scanl'Not in ...
09:42:43 <fryguybob> :(
09:44:09 <koeien> fryguybob: that is not a surprising statement.
09:44:38 <ski> exFalso : you have to make your operation take them as arguments
09:44:58 <koeien> but it's true.
09:45:15 <ski> exFalso : maybe you can show the code that's trying to call `length' ?
09:52:06 <jan_> /quit
09:53:25 <Sgeo> If I use LANGUAGE GADTs, does that mean I can do anything I would be able to do with ExistentialQuantification?
09:54:01 <monochrom> yes, just with a different syntax
09:54:23 <cmccann> Does GADTs imply existential quantification, though?
09:54:28 <monochrom> no
09:55:30 <cmccann> in the sense of "can you have existentials without also enabling that extension" I mean
09:55:42 <monochrom> yes, just with a different syntax
09:55:54 <ski> Sgeo : i think `ExistentialQuantification' implies `ExplicitForall', but `GADTs' doesn't
09:56:44 <ski> (s/all/All/)
09:57:03 <exFalso> ski: http://hpaste.org/56262
09:57:03 <exFalso> i played around with asd but couldn't get it to work
09:58:21 <koeien> exFalso: ScopedTypeVariables might be necessary
09:58:24 <ski>   asd (_ :: Dummy a) = length (lol :: [a])
09:58:29 <ski> alternatively
09:58:49 <monochrom> if you want the two "a"s to refer to the same guy, ScopedTypeVariables
09:58:50 <cmccann> monochrom, ok. I vaguely recall being surprised by some extension that I thought implied existentials not allowing them, but maybe that was something else.
09:58:51 <ski> well, alternatively your explicit `forall a.'
09:58:57 <ski> using `ScopedTypeVariables' in both case
09:58:58 <ski> s
09:59:05 <exFalso> ahh thank you!
09:59:51 <monochrom> without ScopedTypeVariables, "lol :: [a]" is equivalent to "lol :: [b]"
10:00:17 <inteq> i would like to plunge into haskell. i come from a c++/c/python background. can anyone suggest a strong text or set of lectures online that will give me a good foundation?
10:00:24 <koeien> @where lyah
10:00:24 <lambdabot> http://www.learnyouahaskell.com/
10:01:13 <inteq> koeien:thanks! if i keep at this, would i be able to gain employment where haskell is used?
10:01:22 <inteq> at that site, i meant
10:01:27 <inteq> sorry for being ambiguois
10:01:51 <koeien> i couldn't tell you
10:02:11 <ski> @where rwh
10:02:11 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:02:21 <ski> inteq : ^ might also be interesting
10:02:41 <ddarius> @google "Seismic design guide for confined masonry buildings"
10:02:42 <lambdabot> http://www.confinedmasonry.org/wp-content/uploads/2009/09/FINAL_Conf_Mas_Jan_2011.pdf
10:02:42 <lambdabot> Title: SEISMIC DESIGN GUIDE FOR LOW-RISE CONFINED MASONRY BUILDINGS
10:02:51 <akosch> shameless self-promotion: http://stackoverflow.com/q/8780183/71976
10:02:58 <inteq> ski: hmmm. yep. that looks very in-depth. thanks!
10:03:10 <srhb> -query lambdabot
10:03:25 <koeien> akosch: a recursive type.
10:03:45 <koeien> data Handler = Handler (Event -> Maybe Handler)
10:04:07 <Saizan> IO
10:04:08 <koeien> data Handler = Handler (IO (Event -> Maybe Handler)) -- forgot the IO
10:04:15 <akosch> koeien: I don't know anything about those. oh, it's as easy as that?
10:04:16 <inteq> the syntax of haskell honestly makes me feel a little out of place. it is very different to my brain from procedural. but i really want to add this kind of development to my toolset.
10:04:23 <koeien> argh, Event -> IO (Maybe Handler).
10:05:37 <ski> inteq : it's a different programming paradigm. learning it will be a little bit like learning to program from scratch
10:05:46 <koeien> inteq: that's a common feeling. it's very different from imperative programming
10:05:59 <ddarius> inteq: Why not add OOP to your toolset?
10:06:05 <koeien> most of us think it's superior, but it's in any case definitely very different
10:06:21 <ski> (though arguably the hardest part might be unlearning things that aren't true or useful ways to think in this paradigm)
10:06:48 <akosch> koeien: ok, I understand the type. how would I write one?
10:07:07 <koeien> akosch: Handler (\e -> ... some IO action ...)
10:07:10 * ddarius would use newtype, not data there.
10:07:13 <monochrom> "data Handler = Handler (Event -> IO (Maybe Handler))" looks like all it does is eat more events.
10:07:16 * ski thinks "The Koan of Side Effects" at <http://translated.by/you/functional-programming-koans-in-ocaml/original/> is fun
10:07:24 <ddarius> monochrom: And perform IO.
10:07:36 <monochrom> oops, I forgot that
10:07:40 <inteq> ddarius: OOP? i have done OO in python and c++, so I am not sure what you mean. Is there another form of OO that you have in mind?
10:08:12 <akosch> koeien: thanks very much, I'll try it right away!
10:08:15 <ddarius> inteq: Are you sure you've done OO in those languages?
10:08:22 <koeien> akosch: for example.   alwaysPrints37 = Handler (\e -> print 37 >> return (Just alwaysPrints37))
10:08:24 <inteq> koeien: no doubt. it is like i am sitting back in CS101.
10:09:05 <inteq> ddarius: that question feels like it is loaded with hidden meaning. so i would guess that i have not been doing OO in those languages. enlighten me, please.
10:09:48 <akosch> koeien: thanks again, just perfect. If you want the SO credit, I would accept your answer there :)
10:10:08 * monochrom prefers c n = Handler (\e -> putStrLn ("on the " ++ show n ++ "th day of christmas my true love sent to me") >> return (Just (c (n+1))))
10:10:10 <koeien> i do not have an account, never mind.
10:10:20 <ski> koeien : why `Maybe' ?
10:10:40 <koeien> ah Maybe is optional -- if you always return a new Handler, you can forget about it
10:10:47 <ddarius> inteq: You might have been, I'm asking you.  Most people don't identify OOP with procedural programming, and most who use Python and C++ (but not C admittedly) would describe what they do as OOP.
10:11:35 <ski> koeien : it can possibly return itself (for at least some input `Event's)
10:11:41 <exFalso> well both have oop features
10:11:52 <srhb> Doesn't mean you use them though.
10:11:59 <exFalso> i think the only language that is "purely" oop is java
10:12:05 <exFalso> and friends
10:12:09 <ski> akosch : see above ^. note that the `Maybe' might be a needless complicatation, depending on what you're doing exactly
10:12:17 <ddarius> exFalso: Wow, you have a very narrow view of programming languages and/or OOP.
10:12:29 <ddarius> Or a very broad view of "Java and friends"
10:12:48 <inteq> well, i just meant that the paradigm was procedural, so pardon me for not being clear. when i compare a language like haskell to c/c++/python, i am thinking of it more from the perspective of functional vs procedural. but i have done oop and procedural for the duration of my career as a developer. but i have not done any development in a functional languge, althought i have used functional
10:12:49 <inteq> methods like lambdas and closure, but in python.
10:12:59 * ski idly wonders whether Simula,Smalltalk,Self are included among those friends
10:13:03 <akosch> ski: yes, I could omit 'Maybe' but it's a nice addition for breaking out of the loop
10:13:05 <exFalso> c++ programmers mostly say that it's a multiparadigm language, same for python
10:13:36 <exFalso> which ofc includes oop but it's not a necessity
10:13:40 <ski> akosch : *nod*, that's a useful use of it
10:13:49 <MostAwesomeDude> I say that there's a difference between being object-oriented and being object-based.
10:13:50 <arw> exFalso: "jack of all trades, master of none" ;)
10:13:59 <ddarius> exFalso: Yes, but I would say most people in either community are intending to be doing OOP.  It may well be the case, particularly for C++, that you explicitly are not intending to do OOP.
10:14:02 <exFalso> arw: precisely:)
10:14:12 <ski> @where object-oriented
10:14:12 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
10:15:04 <exFalso> ddarius: well i've often heard the argument that python is awesome because of it's "functional" features
10:15:17 <ddarius> I've never heard anyone associate "object oriented" with parametric polymorphism.
10:15:40 <koeien> exFalso: i've also read that multiple times, i do not understand why though
10:15:55 <exFalso> how dare they call it functional haha
10:16:18 <arw> ddarius: i've heard many people associate OOP with many things, so much that i'm not quite sure what OOP really should be. although the current consensus among the rest of the world seems to be "like Java does".
10:17:08 <ddarius> arw: I agree that OOP is poorly defined.  That said, I think there is enough of a consensus on the meaning to that people don't have trouble distinguishing it from procedural.
10:17:17 <MostAwesomeDude> exFalso, koeien : First-class callables. That's what "functional" means in Python.
10:17:39 <MostAwesomeDude> It doesn't mean pure, or referentially transparent. It just means that functions are objects too.
10:19:00 <exFalso> then again i wouldn't call any duck-typed language a programming language
10:19:43 <exFalso> no fish, oh well
10:19:51 <MostAwesomeDude> 0/10, try again in #python.
10:22:13 <srhb> I'm trying to work towards a simple algebraic calculator, so I have a datastructure like data Expr = Num Float | Add Expr Expr. How could I go about converting a String of numbers with the plus character into an Expr tree?
10:22:32 <ski> make a parser
10:22:47 <cmccann> python is probably the least functional language that's still frequently described as being functional
10:22:49 <ski> possibly using `Parsec', or maybe Happy
10:22:59 <koeien> parsec would be easier I think.
10:23:02 <koeien> or attoparsec
10:23:14 <srhb> Hm yes, thanks. I think I'll try to go very low level, and build the parser myself, if I can.
10:23:19 <danr> How do I create tabs for different views in gtk2hs?
10:23:28 <koeien> that might be a useful exercise
10:23:32 <koeien> do you have parens in your expressions?
10:23:38 <srhb> Not yet, no.
10:23:48 <srhb> For now I just want something really basic to build upon.
10:23:49 <ski> srhb : you could use `ReadS' as the parser type
10:23:56 <koeien> then you can get away with using "words"
10:23:57 <ski> @src ReadS
10:23:58 <lambdabot> Source not found. Maybe you made a typo?
10:23:59 <ski> bah
10:24:10 <ski>   type ReadS a = String -> [(a,String)]
10:24:13 <koeien> > words "3 + 4 + 7 "
10:24:14 <lambdabot>   ["3","+","4","+","7"]
10:24:45 <ski> "Dr. Seuss on Parser Monads" <http://www.willamette.edu/~fruehr/haskell/seuss.html>
10:24:56 <srhb> Yes, that would be quite simple. I suppose the simplest, useful exercise also has at least multiplication also.
10:25:04 <srhb> To get some precedence in the mix.
10:25:06 <ski> and brackets
10:25:21 <koeien> drop every second element, read the rest. but if you want more you really should go with a more featureful parsing system :)
10:25:29 <srhb> Gotcha. Thanks for the input.
10:26:27 <ski> > (lex :: ReadS String) "3 + 4 + 7"
10:26:28 <lambdabot>   [("3"," + 4 + 7")]
10:26:36 <ski> > (lex :: ReadS String) "  3 + 4 + 7"
10:26:37 <lambdabot>   [("3"," + 4 + 7")]
10:26:45 <ski> > (lex :: ReadS String) "(3) + 4 + 7"
10:26:46 <lambdabot>   [("(","3) + 4 + 7")]
10:26:57 <srhb> Oh that's useful.
10:27:11 <ski> that lexes a Haskell token, iirc
10:27:41 <ski> > (lex :: ReadS String) "''"
10:27:43 <lambdabot>   []
10:27:44 <ski> > (lex :: ReadS String) "'a'"
10:27:44 <lambdabot>   [("'a'","")]
10:27:54 <ski> > (lex :: ReadS String) "'\\SOH'"
10:27:54 <lambdabot>   [("'\\SOH'","")]
10:28:14 <ski> > '\SOH'
10:28:15 <lambdabot>   '\SOH'
10:28:21 <ski> > ord '\SOH'
10:28:21 <lambdabot>   1
10:30:30 <ski> @type readParen
10:30:30 <lambdabot> forall a. Bool -> ReadS a -> String -> [(a, String)]
10:30:43 <ski> @type readParen :: Bool -> ReadS a -> ReadS a
10:30:44 <lambdabot> forall a. Bool -> ReadS a -> String -> [(a, String)]
10:32:02 <srhb> These are all in Prelude?
10:32:57 <ski> @index readParen
10:32:57 <lambdabot> Text.Read, Prelude
10:33:00 <ski> @index lex
10:33:00 <lambdabot> Text.Read, Prelude, Text.Read.Lex
10:33:05 <ski> @index reads
10:33:05 <lambdabot> Text.Read, Prelude
10:33:07 <ski> @index readsPrec
10:33:07 <lambdabot> Text.Read, Prelude
10:33:21 <srhb> Excellent, I didn;t know the index command.
10:33:59 <ski> you typically use `readParen' like `readParen (p > 5) $ ...'
10:34:05 <estan> if i want the number of positions at which two lists, l1 and l2 differ, is length [(x,y) <- zip l1 l2, x /= y] a good way to go about it? or is there a better way? (sorry if that looks horrid, i'm new to haskell)
10:34:14 <ski> there `p' is an operator precedence
10:34:27 <koeien> estan: that's fine.
10:34:43 <estan> koeien: alright. thanks.
10:35:00 <ski> in case `p' is greater than `5', `readParen' will insist on round brackets in the expression, otherwise they may appear but may be omitted
10:35:20 <ski> > (readParen True reads :: ReadS Integer) "123"
10:35:21 <lambdabot>   []
10:35:24 <ski> > (readParen True reads :: ReadS Integer) "(123)"
10:35:25 <lambdabot>   [(123,"")]
10:35:29 <ski> > (readParen False reads :: ReadS Integer) "123"
10:35:30 <lambdabot>   [(123,"")]
10:35:36 <ski> > (readParen False reads :: ReadS Integer) "(123)"
10:35:37 <lambdabot>   [(123,""),(123,"")]
10:35:55 <koeien> estan: although generally we would call l1 and l2, xs and ys respectively
10:36:07 <ski> this is supposed to be a counterpart to
10:36:19 <ski> @type showParen :: Bool -> ShowS -> ShowS
10:36:20 <lambdabot> Bool -> ShowS -> String -> String
10:36:40 <ski> hm, that's interesting -- `readParen' giving more than one solution above
10:37:11 <ski> (and it happens in my Hugs as well)
10:37:20 <estan> koeien: ah right. i should adhere to the convention yes ;)
10:37:26 <estan> s/the/that7
10:37:29 <ion> I can see why that happens. It seems fine to me.
10:37:42 <ski> > (reads :: ReadS Integer) "(123)"
10:37:43 <lambdabot>   [(123,"")]
10:37:48 <ski> hm, that explains it
10:38:03 <ski> > (reads :: ReadS Integer) "((((123))))"
10:38:04 <lambdabot>   [(123,"")]
10:38:24 <sshine> hmm
10:38:25 <byorgey> estan: also, what you wrote is not quite valid list comprehension syntax
10:38:42 <sshine> my haskell libraries are inherently broken by default on ubuntu 11.10
10:38:51 <koeien> ah yeah i missed that due to wrapping
10:38:58 <byorgey> you would have to write something like  length [(x,y) | (x,y) <- zip l1 l2, x /= y]
10:39:14 <byorgey> but then you might as well write  length [() | (x,y) <- zip l1 l2, x /= y]
10:39:18 <estan> byorgey: ah sorry you're right. i just typed it in wrong.
10:39:27 <ion> sum [ 1 | … ] ;-)
10:39:29 <byorgey> or even   sum [1 | (x,y) <- zip l1 l2, x /= y]
10:39:36 <estan> byorgey: ah right. for my purposes that would work too.
10:39:39 <byorgey> oh, ion beat me
10:39:54 * Sgeo ponders making lazy numbers
10:40:07 <Sgeo> Such that lazyLength xs == 0 is not inherently a bad idea.
10:40:17 <estan> anyway. time to make some mashed potatoes. thanks for the advice everyone.
10:40:18 <ion> It’s done already.
10:40:28 <ski> Sgeo : i think there's a `Natural' package for that
10:41:16 <cmccann> Sgeo, data "Nat = Zero | Succ Nat"
10:41:27 <cmccann> hm, that is not where that quotation mark belonged
10:41:31 <cmccann> oh well
10:41:34 <Sgeo> Not quite what I had in mind, actually
10:41:48 <Sgeo> More of a list of lower and upper bounds
10:42:08 <Sgeo> data LazyNum a = LazyNum [(Maybe a, Maybe a)]
10:42:10 <cmccann> Sgeo, sounds interesting
10:42:41 <cmccann> wouldn't you want each element of the list to narrow the range, though?
10:43:09 <Sgeo> Not sure how to represent that, but I was thinking of a function normalize to force any LazyNum to be a proper LazyNum
10:43:50 <Sgeo> Well, assuming that each element of the list potentially not changing the range can still be considered proper
10:43:58 <cmccann> well, on a fractional type you could specify the new range relative to the old one
10:44:40 <mekeor> in haskell, can all function-definitions be expressed point-free?
10:44:42 <Sgeo> The upper bound of the length of a list is not known until the end of the list
10:44:55 <ion> Couldn’t you do newtype LazyNum a = LazyNum [a] and have comparisons work lazily as well?
10:45:01 <koeien> mekeor: that depends on what you consider to be your "base set" of functions
10:45:04 <ski> Sgeo : i think this is an interesting idea -- i saw some hand-written notes somewhere on the web about making such a lazy improving intervals type
10:45:09 <koeien> mekeor: that you can use
10:45:20 <mekeor> koeien: Prelude ?
10:45:37 <monochrom> the Prelude may not be enough
10:45:43 <koeien> fix is not in the Prelude, is it?
10:45:46 <mekeor> oh. why not?
10:45:52 <mekeor> @hoogle fix
10:45:52 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
10:45:53 <lambdabot> Data.Fixed module Data.Fixed
10:45:53 <lambdabot> Data.Function fix :: (a -> a) -> a
10:45:53 <monochrom> fix is not in the Prelude
10:46:11 <koeien> @pl fix
10:46:11 <lambdabot> fix
10:46:12 <mekeor> so what, koeien?
10:46:21 <mekeor> what's @pl ?
10:46:28 <ski> @help pl
10:46:28 <lambdabot> pointless <expr>. Play with pointfree code.
10:46:31 <koeien> mekeor: @pl makes functions pointfree (it stands for pointless)
10:46:32 <mekeor> ah, okay.
10:46:33 <monochrom> things like \f g (x,y) -> (f x, g y) is not in the Prelude
10:46:49 <mekeor> @pl (.)
10:46:49 <lambdabot> (.)
10:46:55 * ski . o O ( `cross' )
10:46:56 <mekeor> @pl ($)
10:46:56 <lambdabot> id
10:47:00 <alistra> @pl \x -> x
10:47:00 <lambdabot> id
10:47:01 <cheater_> @unpl (.)
10:47:01 <lambdabot> (\ a b c -> a (b c))
10:47:06 <mekeor> @pl (++)
10:47:07 <lambdabot> (++)
10:47:07 <monochrom> if you write your own data type, operations on your data type are not in the Prelude
10:47:16 <mekeor> @pl filter
10:47:17 <lambdabot> filter
10:47:18 <cheater_> why don't you /query lambdabot
10:47:20 <Sgeo> @pl \f g (x,y) -> (f x, g y)
10:47:21 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
10:47:36 <monochrom> ap is not in the Prelude
10:48:05 <mekeor> so, the answer is no, using the Prelude as base? okay. and which'd be the minimal base?
10:48:31 <cmccann> does the Prelude give you the monad instance for ((->) e)? You could define a lot of stuff that way.
10:48:34 <monochrom> if you write your own data type, operations on your data type are not in any base pre-existing before your data type
10:49:02 <ion> I found it interesting that:
10:49:09 <ski> one nice thing about such a lazy improving internals type is that one could code in a natural way the bisection method
10:49:22 <ion> @pl \(x, y) -> (f x, f y)
10:49:22 <lambdabot> f *** f
10:49:23 <ion> and
10:49:31 <ion> @pl \f -> f *** f
10:49:31 <lambdabot> join (***)
10:49:33 <ion> but:
10:49:40 <ion> @pl \f (x, y) -> (f x, f y)
10:49:40 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
10:50:18 <ski> ion : it's not confluent
10:50:36 <ski> cmccann : i think not
10:51:33 <geekosaur> I've always had to import it
10:52:12 <cmccann> guess the prelude isn't really designed to support writing pointlessly pointfree code, go figure
10:52:16 <mekeor> does ghci have that @pl-feature?
10:52:28 <cmccann> mekeor, no, but you can install it as a standlone program
10:52:38 <sshine> pop = do { n <- peek; modify tail; return n } -- can anyone recommend an operator that shortens this?
10:52:44 <mekeor> cmccann: which's called?
10:52:47 <cmccann> :t (*>)
10:52:48 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
10:52:55 <sshine> thanks, cmccann.
10:53:10 <cmccann> well, (<*) I guess
10:53:12 <cmccann> but yeah
10:53:14 <sshine> yes
10:53:35 <cmccann> also you need Applicative, which actual Monad instances usually have but isn't implied because blah blah
10:53:45 <cmccann> mekeor, pointfree
10:54:06 <cmccann> mekeor, it's on hackage if you're interested
10:54:18 <mekeor> nice. thanks.
10:55:04 <cmccann> mekeor, you might also find djinn interesting while you're at it :]
10:55:23 <koeien> @djinn a -> b -> (a,a,b)
10:55:23 <lambdabot> f a b = (a, a, b)
10:55:27 <ion> and pointful
10:58:02 <sshine> @djinn Applicative f => f a -> f b -> f a
10:58:03 <lambdabot> Error: Class not found: Applicative
10:58:05 <Sgeo> :t max
10:58:06 <mekeor> what's djinn ?
10:58:06 <lambdabot> forall a. (Ord a) => a -> a -> a
10:58:13 <ski> @help djinn
10:58:14 <lambdabot> djinn <type>.
10:58:14 <lambdabot> Generates Haskell code from a type.
10:58:14 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
10:58:29 <byorgey> mekeor: you give it a type and it writes a function of that type, or tells you it isn't possible.
10:58:36 <ski> @djinn Not (Either a b) -> (Not a,Not b)
10:58:36 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
10:58:42 <mekeor> byorgey: cool.
10:58:45 <sipa> @djinn Monad m => m a -> (a -> m b) -> m b
10:58:45 <lambdabot> f = (>>=)
10:59:03 <mekeor> can you give an example for a type which isn't possible? byorgey?
10:59:05 <ski> @djinn Monad m => m b -> (b -> m a) -> m a
10:59:05 <lambdabot> -- f cannot be realized.
10:59:08 <mekeor> cool
10:59:17 <byorgey> wat
10:59:19 <ski> @djinn Either a (Not a)
10:59:20 <lambdabot> -- f cannot be realized.
10:59:22 <mekeor> @djinn Monad m => m a -> a
10:59:22 <lambdabot> -- f cannot be realized.
10:59:24 <mekeor> hehe
10:59:26 <ion> Oh, i didn’t even know djinn knows about typeclasses such as Monad.
10:59:26 <ski> @djinn Not (Not (Either a (Not a)))
10:59:26 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
10:59:43 <arw> @djinn Eq a => [a] -> a -> Bool
10:59:43 <lambdabot> Error: Undefined type []
10:59:58 <mekeor> is there a non-monadic function that cannot be realized?
11:00:11 <byorgey> @djinn a -> b
11:00:11 <lambdabot> -- f cannot be realized.
11:00:14 <cmccann> @djinn a
11:00:14 <lambdabot> -- f cannot be realized.
11:00:19 * cmccann cuts to the chase
11:00:19 <mekeor> wtf?!
11:00:20 <ski> byorgey : djinn doesn't really understand higher-ranked types, and therefore also not constraints for classes with methods polymorphic in non-class-parameters
11:00:26 <koeien> @dinn a -> (a -> b)
11:00:26 <lambdabot> -- f cannot be realized.
11:00:31 <ski> @djinn a -> a
11:00:31 <lambdabot> f a = a
11:00:39 <byorgey> ski: oh, I see
11:00:45 <arw> @djinn Eq a => a -> a -> Bool
11:00:45 <lambdabot> f = (==)
11:00:47 <ion> To be precise “@djinn a” doesn’t answer mekeor’s question. ;-)
11:01:07 <byorgey> mekeor: well, how would you write a function of type  a -> b  ?
11:01:24 <ion> *cough*unsa…
11:01:28 <mekeor> ion: oh.. hehe
11:01:35 <mekeor> byorgey: er..
11:01:35 <cmccann> :t \x -> undefined
11:01:36 <lambdabot> forall t a. t -> a
11:01:45 * cmccann shows djinn how it's done
11:01:49 <mekeor> lol
11:01:51 <ion> :t undefined :: a -> b
11:01:52 <lambdabot> forall a b. a -> b
11:01:59 <mekeor> lol
11:02:03 <ski> djinn generalizes `a -> (a -> b)' here to `forall a b. a -> (a -> b)' (just like with type signatures in Haskell, provided `a' and `b' are not already in scope)
11:02:18 <byorgey> mekeor: djinn only works with the fragment of Haskell that corresponds to a constructive logic, so it is not allowed to use undefined or fix
11:02:37 <cmccann> @djinn (a -> a) -> a
11:02:37 <lambdabot> -- f cannot be realized.
11:02:38 <mekeor> @src fix
11:02:39 <lambdabot> fix f = let x = f x in x
11:02:40 <ski> djinn is supposed to be consistent :)
11:02:41 <akosch> is there a safe version of succ and pred for enumerations?
11:03:07 <cmccann> akosch, safe as in using Maybe or the like?
11:03:16 <akosch> cmccann: exactly!
11:03:16 <byorgey> akosch: not that I know of
11:03:29 <mekeor> @djinn fix
11:03:29 <lambdabot> -- f cannot be realized.
11:03:31 <mekeor> @pl fix
11:03:31 <lambdabot> fix
11:03:32 <ion> @hoogle safePred
11:03:32 <lambdabot> No results found
11:03:36 <mekeor> @hoogle fix
11:03:36 <ion> @hoogle predMay
11:03:37 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
11:03:37 <lambdabot> Data.Fixed module Data.Fixed
11:03:37 <lambdabot> Data.Function fix :: (a -> a) -> a
11:03:37 <lambdabot> No results found
11:03:42 <ski> akosch : in some cases you could use `Bounded' and `Eq'
11:03:56 <byorgey> akosch: for types that are instances of Eq, Bounded, and Enum, you could make your own by testing for equality with maxBound or minBound
11:04:05 * ski grins
11:04:19 * byorgey is too slow
11:04:30 <cmccann> :t fromEnum
11:04:30 <lambdabot> forall a. (Enum a) => a -> Int
11:04:47 <ski> byorgey : not really, since you were more elaborative than me here :)
11:04:48 <cmccann> don't think Eq is necessary
11:04:54 <cmccann> just Bounded
11:04:54 <mekeor> byorgey: nope. ski is fast rather than you are slow...
11:05:01 <byorgey> =)
11:05:06 <byorgey> cmccann: good point
11:05:06 <ion> > map (listToMaybe . drop 1 . enumFrom) [False, True]
11:05:07 <lambdabot>   [Just True,Nothing]
11:05:13 <ski> cmccann : how will you compare with `minBound' and `maxBound' otherwise ?
11:05:21 <akosch> ski: I didn't know about Bounded, thanks. I hoped to skip writing them myself :)
11:05:30 <byorgey> ski: you can convert them to Int
11:05:31 <cmccann> ski, convert both to Int
11:05:38 <ski> ah, right
11:05:52 <ski> hm
11:05:54 * cmccann also likes to define enumerate = [minBound .. maxBound] :: (Enum a, Bounded a) => [a]
11:06:22 <akosch> cmccann: wow, this is great. less typing for me! :)
11:06:26 <ski> cmccann,byorgey : doesn't that beg the question ?
11:06:35 <cmccann> since that covers a lot of cases where you'd want to do something along these lines
11:06:36 <donri> isn't [minBound..] the same thing
11:07:02 <Sgeo> I wrote my normalize function, but it's a bit lengthy
11:07:04 <cmccann> donri, might be, actually
11:07:25 <hpaste> Sgeo pasted “Beginnings of LazyNum” at http://hpaste.org/56265
11:08:22 <byorgey> > [minBound ..] :: [Bool]
11:08:23 <lambdabot>   [False,True]
11:08:47 <donri> too bad there's no [..] syntax
11:08:52 <cmccann> heh
11:08:55 <byorgey> ski: why?
11:08:59 <ski> (cmccann,byorgey : hm, no forget it, i was confused, you can do `\x -> if elem x (map fromEnum [minBound .. maxBound]) then Just (toEnum) else Nothing')
11:09:02 <donri> > [ .. ] :: [Bool]
11:09:03 <lambdabot>   <no location info>: parse error on input `..'
11:09:18 <byorgey> @type fromEnum
11:09:19 <lambdabot> forall a. (Enum a) => a -> Int
11:09:27 <byorgey> ski: every Enum can be converted to Int
11:09:34 <donri> > fromEnum True
11:09:35 <lambdabot>   1
11:09:39 <donri> > fromEnum False
11:09:39 <lambdabot>   0
11:09:47 <ski> > [() | False]
11:09:48 <lambdabot>   []
11:09:52 <Sgeo> Hmm, this doesn't prevent there from being nonsensical bounds
11:10:00 <Sgeo> Like [(Just 1, Just 0)]
11:10:10 <byorgey> ski: what's wrong with using the Ord instance on Int?
11:10:29 <ski> works too
11:10:36 <ski> was talking about `Eq', is all
11:10:44 <cmccann> Sgeo, that's potentially sensical though
11:10:55 <byorgey> hmm, are you guaranteed that  fromEnum (succ x) == 1 + fromEnum x ?
11:11:01 <Sgeo> cmccann, how?
11:11:03 <cmccann> Sgeo, could just mean an empty range
11:11:07 <byorgey> ski: ok
11:11:40 <Sgeo> Also, is my normalize function too big, I keep thinking there should be a better way
11:11:44 <ski> byorgey : i could imagine that maybe not being the case for some types meant to correspond to C `enum' types
11:12:06 <byorgey> ski: yeah, makes sense
11:12:08 <cmccann> Sgeo, given that you can't guarantee your ranges will converge to a single value I don't see any reason to prevent them from containing no values either
11:12:10 * ski would assume `fromEnum x < fromEnum (succ x)', though
11:12:16 <byorgey> yeah, I guess that's all you need
11:13:13 <Sgeo> cmccann, repeat (Nothing, Nothing) seems better for containing no values
11:13:14 <Sgeo> :/
11:13:17 <Sgeo> :t repeat
11:13:17 <lambdabot> forall a. a -> [a]
11:13:22 <ski> though i suppose, in some `enum' cases, maybe some interval spans are reserved for future use
11:13:29 * Sgeo shrugs and continues
11:13:36 <cmccann> Sgeo, you'd have multiple representations for empty ranges, yes
11:13:44 <ski> so is `succ' then meant to give the next valid enumeration value ?
11:13:48 <cmccann> but you're lacking a bit in the unique representation department anyway I think
11:14:11 <Sgeo> Actually, repeat (Nothing, Nothing) contains everything, I think
11:14:13 <ski> if so, if values are being added inbetween, the value you get for `succ' would change
11:14:35 <Sgeo> No upper or lower bound
11:14:56 <cmccann> note that (toEnum . fromEnum) is not guaranteed to be id as far as I know
11:15:39 <byorgey> I think the takeaway from all of this is that we still have no idea what the heck Enum is supposed to mean
11:15:50 <mekeor> is the pointfree style pointless?   i mean, does it make sense at all?
11:15:52 <ski> > let a0 = array (1,0) []; a1 = array (2,1) [] in (a0,a1,a0 == a1,show a0,show a1)  -- oops !?
11:15:53 <lambdabot>   (array (1,0) [],array (2,1) [],True,"array (1,0) []","array (2,1) []")
11:15:59 <cmccann> byorgey, yes, I spent far too much time arguing about that on haskell-cafe a while back
11:16:04 <cmccann> don't need to go down that path again
11:16:08 <byorgey> cmccann: yeah, I think I remember that
11:16:09 <ski> > let a0 = array (1,0) []; a1 = array (2,1) [] in show a0 == show a1
11:16:09 <lambdabot>   False
11:16:17 <rwbarton> ski: interesting
11:16:25 <cmccann> I think I mostly ended up complaining about floating point values though
11:16:50 <byorgey> mekeor: it is not completely pointless.  For example, it is much clearer to write  foo = bar . baz   than to write   foo x = bar (baz x)
11:17:02 <byorgey> mekeor: however, when taken to extremes it is silly.
11:17:19 <rwbarton> in a way it makes sense, though, the intervals (1,0) and (2,1) are the same (empty)
11:17:28 <ion> @type array
11:17:29 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
11:17:47 <mekeor> byorgey: i see.
11:17:50 <rwbarton> > let a1 = array (2,1)[] in bounds a1
11:17:51 <lambdabot>   (2,1)
11:18:10 <ski> rwbarton : arguably it should normalize in some way
11:18:16 <ski> hm
11:18:27 <mekeor> does lambdabot support pipes like this?
11:18:28 <mekeor> @type array | @djinn
11:18:29 <lambdabot> parse error on input `|'
11:18:34 <mekeor> hehe :D
11:18:43 <rwbarton> @@ @djinn @type array
11:18:44 <lambdabot>  Error: Undefined type []
11:18:50 <rwbarton> it won't work in this case of course
11:18:50 <mekeor> wow
11:18:54 <rwbarton> @@ @djinn @type id
11:18:55 <lambdabot>  f a = a
11:19:02 <cmccann> Sgeo, "maybeComp f x y = msum [liftM2 f x y, x, y]" I guess
11:19:12 <mekeor> @@ @djinn @type map
11:19:13 <lambdabot>  Error: Undefined type []
11:19:19 <ski> > bounds (array ((0,0),(-1,3)) [] {- a 0*4 matrix -})
11:19:20 <lambdabot>   ((0,0),(-1,3))
11:19:24 <mekeor> why does that not work?
11:19:31 <mekeor> rwbarton: why?
11:19:32 <ion> Oh, @@ @djinn @type id works now? Didn’t djinn fail with “forall …” before?
11:19:36 <rwbarton> djinn doesn't know about []
11:19:45 <mekeor> oh. what a bummer. okay.
11:19:47 <rwbarton> much less Array
11:19:53 <mekeor> i see.
11:19:55 <rwbarton> there is not really much interesting for djinn to say about []
11:20:40 <arw> @djinn Eq a => (a, a) -> Bool
11:20:41 <lambdabot> f (a, b) = a == b
11:20:51 <rwbarton> since logically [a] is equivalent to () (if I need to produce a value of type [a], I can just use [], while if I'm given a value of type [a], it might be [] which doesn't give me anything of a type related to a)
11:20:53 <ski> @djinn Eq b => (b,b) -> Bool
11:20:53 <lambdabot> f (a, b) = a == b
11:21:04 <arw> ski: yes, b works, too :)
11:21:24 <rwbarton> @djinn Bool
11:21:24 <lambdabot> f = False
11:21:25 <cmccann> Sgeo, also "func x y = maybeComp max *** maybeComp min" I think
11:21:27 <rwbarton> heh
11:21:32 <ski> arw : because the relevant class methods aren't polymorphic, except in class parameters
11:22:02 * Sgeo still does not grok ***
11:22:05 <Sgeo> :t (***)
11:22:06 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:22:12 <arw> ski: a typical #haskell answer :)
11:22:19 <akosch> these should work, right? http://hpaste.org/56266
11:22:21 <ion> @type (***) `asAppliedTo` (undefined :: a -> b)
11:22:22 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
11:22:29 <ion> @@ @djinn @type (***) `asAppliedTo` (undefined :: a -> b)
11:22:30 <lambdabot>  -- f cannot be realized.
11:22:36 <ski> @src (->) (***)
11:22:36 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
11:22:41 <akosch> obviously they need Eq
11:22:45 <ski> aka `cross'
11:22:47 <ben_m> This lambdabot magic is confusing me
11:22:49 <akosch> :(
11:23:12 <rwbarton> @djinn forall a. a -> a
11:23:12 <lambdabot> f a = a
11:23:15 <rwbarton> @djinn forall a'. a' -> a'
11:23:15 <lambdabot> -- f cannot be realized.
11:23:26 * Sgeo throws in a cycle
11:24:29 <arw> @djinn Eq c => (a, c, c, d) -> (d, Bool)
11:24:29 <lambdabot> f (_, a, b, c) =
11:24:30 <lambdabot>     case a == b of
11:24:30 <lambdabot>     False -> (c, False)
11:24:30 <lambdabot>     True -> (c, True)
11:24:41 <danr> nice :)
11:24:42 <monochrom> eh? still exploring cross? :)
11:27:22 <ski> akosch : you could replace `x == minBound' by `fromEnum x == fromEnum minBound', and avoid the `Eq a' constraint
11:28:05 <akosch> ski: right, missed that. thanks
11:29:14 <Sgeo> Are pattern guards preferred over view patterns?
11:29:21 <Sgeo> Because I want to use a view pattern here
11:29:57 <ski> use what you prefer ?
11:30:14 <ion> They’re for different purposes, aren’t they?
11:31:05 <ion> I mean, you *can* emulate one with the other, but isn’t it generally obvious which one matches what you want?
11:31:25 <ski> with pattern guards, you can more easily match on an arbitrary expression, with view patterns you have the main input which is matched with the view pattern
11:32:42 <ion> View patterns also let you avoid naming the pre-function value which has a potential benefit with code correctness.
11:33:13 <Sgeo> Isn't one in Haskell2010 while the other isn't?
11:33:45 * ski thinks "pre-function value" is a bit strange a term ;)
11:34:17 <ion> Hehe
11:34:26 <ion> Pre-view function value. Or something.
11:34:41 <Sgeo> compare (normalize -> LazyNum n1s) (normalize -> LazyNum n2s) =
11:35:03 <ski> i would probably just have said "the value being matched (with the view pattern)" or something like that
11:35:24 <ion> In Sgeo’s example, the pre-normalize value
11:36:09 * Sgeo wonders if GHC is smart enough to not bother making the intermediate full LazyNum value
11:36:17 <Sgeo> And just put the lists in n1s and n2s
11:36:36 <ion> Is LazyNum a newtype?
11:36:41 <Sgeo> No
11:36:45 <Sgeo> I guess it could be
11:37:06 <jakeskik> clear
11:37:09 <jakeskik> wups
11:39:50 <frog> does haskell have Mathematica's Manipulate
11:40:17 <frog> Does haskell have Mathematica's Manipulate?
11:40:26 <ski> @type case Data.Sequence.replicate 2 'b' of (Data.Sequence.viewl -> as Data.Sequence.:> a) -> (as,a)
11:40:26 <lambdabot>     Illegal view pattern:  (Data.Sequence.viewl -> as Data.Sequence.:> a)
11:40:27 <lambdabot>     Use -XViewPatterns to enable view patterns
11:40:39 <ski> > case S.replicate 2 'b' of (S.viewl -> as S.:> a) -> (as,a)
11:40:39 <lambdabot>   Not in scope: `S.replicate'Not in scope: `S.viewl'Not in scope: data constr...
11:40:59 <ski> bah
11:41:47 <ski> anyway, the value of  S.replicate 2 'b'  is here being matched with the pattern  S.viewl -> as S.:> a
11:42:24 <Sgeo> S.viewl?
11:42:41 <ski> @type Data.Sequence.viewl
11:42:42 <koeien> view-left
11:42:42 <lambdabot> forall a. Seq.Seq a -> Seq.ViewL a
11:42:43 <ion> > Seq.viewl (Seq.fromList "foobar")
11:42:44 <lambdabot>   'f' :< fromList "oobar"
11:42:52 <ion> > Seq.viewr (Seq.fromList "foobar")
11:42:53 <lambdabot>   fromList "fooba" :> 'r'
11:42:54 <ski> @hoogle :>
11:42:55 <lambdabot> Data.Sequence (:>) :: Seq a -> a -> ViewR a
11:43:35 <ski> (i suppose it should have been `viewr' above)
11:43:48 <ski> > let f (let x*x = y in [y]) = x in f [2]  -- ought to yield `9'
11:43:49 <lambdabot>   <no location info>: Parse error in pattern
11:44:10 <ski> (well, in case s/2/3/ i.e.)
11:44:18 * ski should go get some sleep
11:44:44 <Sgeo> ski, let in a pattern?
11:44:52 <ski> why not ?
11:45:51 <ski> sigh, let me try again
11:46:21 <ski> > let f (let x*x = y in [x]) = y in f [3]  -- what i really meant
11:46:22 <lambdabot>   <no location info>: Parse error in pattern
11:46:32 <koeien> how can you have a * on the left ?
11:47:27 <ski> matching `[3]' with `let x*x = y in [x]' will match it with `[x]', (locally) binding `x' to `3', then matching the value of the expression `x*x' with the pattern `y', binding `y' to (a thunk evaluating to) `9'
11:48:26 <ski> koeien : in an expression `let p0 = e0 in e', `p0' is a pattern, and `e0',`e' are expressions -- in a pattern `let e0 = p0 in p', `e0' would be an expression and `p0',`p' would be patterns
11:48:45 <koeien> i see..
11:48:53 <ion> What’s the etymology of thunk, btw? The Jargon file only seems to tell who came up with the word.
11:49:38 <ion> Oh, i didn’t read far enough. There’s some speculation about the etymology in there.
11:49:50 <parcs`> Thunks were invented by Peter Zilahy Ingerman[1] in 1961. According to the inventor, the name "thunk" came about because it could be optimized by the compiler by "thinking about it", so "thunk", according to its inventor, "is the past tense of 'think' at two in the morning"
11:50:01 <Sgeo> :t foldr
11:50:02 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:50:13 <ion> Thanks, parcs. Tharcs.
11:52:11 <ski> koeien : this way e.g. `let (x,y) = xy in (y,x)' makes sense both as an expression and as a pattern : as an expression it will compute a value of type `(b,a)', given an input value `xy' of type `(a,b)'; as a pattern it will match on a value of type `(b,a)', binding the variable `xy' to a value of type `(a,b)'
11:52:50 * ski . o O ( "think, thank, thunk" )
11:56:18 <tromp> i thunk therefore i am
11:56:39 <ski> relatedly, `\e -> p' would be a valid pattern of type `a -> b', if `e' is an expression of type `a' and `p' is a pattern matching values of type `b'
11:56:45 <Silvah> I thank therefore I was?
11:56:58 <donri> At least I thunk I thought
11:57:02 <tromp> thanks for the thunks!
11:57:40 <tromp> what would you call a haskell powered laptop:-?
11:57:56 <donri> thunkpad
11:58:00 <tromp> bingo::)
11:58:17 <Silvah> I'd call it Don.
11:58:33 * ski . o O ( `callcc :: ((a -> b) -> a) -> a; callcc (\(\a1 -> _) -> a0) = a0@a1' would require stranger extensions, though )
11:59:03 <ion> Stewart?
11:59:44 <Silvah> When there will be Don Stewart built into GHC?
12:00:00 <companion_cube> :D
12:00:20 <dmwit> -XStrongAI
12:00:34 <ion> -XSkynet
12:00:37 <cmccann> I think that was going to be called -fvia-stackoverflow back when he was still really active there
12:06:24 --- mode: ChanServ set +o mauke
12:06:25 --- mode: mauke set +b $a:lawful_evil
12:06:29 <mauke> oh wait
12:06:37 <mauke> an entire new account?
12:06:49 --- kick: lawful_evil was kicked by mauke (ban evasion)
12:07:00 <shachaf> mauke: ?
12:08:49 --- mode: mauke set -o mauke
12:09:06 <Sgeo> Forcing myself to use a fold on a tricky thing makes me understand it better, I think
12:10:04 <Sgeo> When writing the function to pass to foldr, if I can't use the current value, I just return the accumulator, I think
12:10:09 <Sgeo> Since that is the final result
12:10:35 <shachaf> Sgeo: The foldr of a list is pretty much equivalent to the list.
12:11:21 <cmccann> shachaf, is the "pretty much" qualifier even necessary there? :]
12:11:38 <Sgeo> :t foldr
12:11:39 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:12:04 <cmccann> :i []
12:12:16 <cmccann> bah, guess that doesn't work
12:12:33 --- mode: ChanServ set +o mauke
12:12:33 --- mode: mauke set +b $x:~g*!*@pool-*.lsanca.fios.verizon.net#*purple*
12:14:08 <cmccann> Sgeo, anyway, "foldr f z" takes a list and replaces each (:) with f and [] with z
12:14:30 <cmccann> hence the equivalence that shachaf mentioned
12:14:33 --- mode: mauke set -o mauke
12:15:54 <Sgeo> With the particular fold that I'm doing, I either know my entire result on an element, or need to try the next element
12:16:41 <c_wraith> sounds like a foldr to me
12:16:58 <cmccann> Sgeo, thinking about the "next element" is probably not the best approach with a right fold actually
12:16:59 <Sgeo> Which is exactly what I'm doing
12:17:11 <cmccann> you have an element, and the result of the entire remaining list
12:17:32 <Sgeo> And if this element doesn't work out, then just give the result
12:17:37 <Sgeo> Is what I'm thinking
12:17:47 <Sgeo> *result of the entire remaining list
12:17:51 <cmccann> Sgeo, right
12:19:07 <alistra> so far by my statistical sample, women can't code :(
12:19:24 <companion_cube> or don't want to
12:19:30 <cmccann> so far by my statistical sample, people can't code
12:19:49 <alistra> women code worse than men*
12:19:51 <cmccann> at the moment I'm still suspicious that any outliers are measurement errors
12:19:52 <alistra> well
12:19:54 <alistra> not rly
12:20:00 <alistra> because i didn't see a lot of women coding
12:20:06 <shachaf> alistra: Come on, is this really necessary?
12:20:12 <drull95> i have a three year old cousin who likes to "code"
12:20:23 <drull95> female^
12:21:29 <drull95> spoj is doing a good job of reminding me that im stupid
12:22:26 <drull95> i'm supposed to be finding out how much time is being saved by some given algorithm but no matter what i'm feeding in i'm getting the same results
12:23:00 * Sgeo vaguely wonders if this is an appropriate use of pattern guards
12:26:27 <ben_m> Sgeo, "this"?
12:26:43 <Sgeo> Bleh, type errors
12:26:53 <Sgeo> ben_m, I'll paste when I fix
12:27:22 <Sgeo> o.O foldr1 doesn't allow for what I want
12:27:29 <shachaf> foldr1 is the devil.
12:28:31 * Sgeo replaces with foldr and a bottom
12:28:55 <cmccann> is that really an improvement :[
12:29:04 <Sgeo> cmccann, it typechecks]
12:29:11 <cmccann> so does undefined
12:29:29 <Sgeo> And these lists are supposed to be infinite anyway. And in any case, it makes sense that some of these things are not comparable.
12:29:41 <Sgeo> If compare ended up being a total function, that probably means I did something wrong/
12:29:53 <cmccann> Sgeo, compare should also be lazy
12:30:14 <cmccann> and be able to produce "not sure yet" as an answer
12:30:28 <cmccann> and if they're supposed to be infinite, why not use something other than lists
12:31:30 <cmccann> some version of "data Stream a = Stream a (Stream a)"
12:33:13 <hpaste> Sgeo pasted “LazyNums so far” at http://hpaste.org/56270
12:33:13 <ski> > foldr1_ digitToInt (+) "496"
12:33:15 <lambdabot>   19
12:33:49 <ben_m> :t foldr1_
12:33:50 <lambdabot> forall a b. (a -> b) -> (b -> b -> b) -> [a] -> b
12:34:24 <cmccann> Sgeo, honestly I don't think Ord makes sense for that type
12:35:06 <ski> `(Ord a, Eq a)' can be simplified to `Ord a'
12:36:02 <Sgeo> Thanks
12:36:21 <Sgeo> cmccann, but then my pretty (==0) . length disappears
12:36:37 <Sgeo> Wait, that just needs Eq
12:36:48 <ski> (and, in case you didn't know, the brackets in `(Ord a) => ' aren't really necessary)
12:36:52 <Sgeo> But my nice (<5) . length etc. etc. disappears
12:37:04 <cmccann> ski, I actually do that anyway
12:37:16 <ski> cmccann : i know some people do
12:37:20 <cmccann> I like the visual consistency
12:37:21 <aristid> Sgeo: (<5) . length is not nice. but i suppose people told you that already
12:37:22 * ski never does it
12:37:53 * ski thinks `((Foo a,Bar a b),Baz b)' also ought to be valid
12:37:58 <mekeor> what does lojban have to do with haskell??... (http://www.haskell.org/haskellwiki/Lojban) (it's cool though)
12:38:05 <Sgeo> aristid, if you mean because of efficiency and failure concerns, that's what these LazyNums are supposed to solve.
12:38:44 <aristid> Sgeo: oh, you use those? OK
12:38:59 <cmccann> aristid, he's implementing those
12:39:00 <dmwit> Yeah, Ord doesn't make sense. It needs a new type class that only asks for (<) or something.
12:40:08 <dmwit> I'm not sure this is what most people mean when they say "lazy", though.
12:40:17 <dmwit> It's certainly not what I was expecting from a lazy number.
12:40:42 <cmccann> well, it's lazy progressive refinement
12:41:13 <dmwit> Anyway, http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-Natural.html already solves the (<5) . length thing.
12:41:30 <dmwit> > genericLength [1..] < (5 :: Natural)
12:41:31 <lambdabot>   Not in scope: type constructor or class `Natural'
12:41:41 <cmccann> dmwit, he's doing something more general than that
12:41:56 <dmwit> Yes, I understand what he's doing.
12:42:00 <cmccann> oh, right
12:42:02 <cmccann> nevermind, misread
12:42:04 <cmccann> sorry
12:42:29 <dmwit> (In fact, I'm even a bit surprised he's the first to try it.)
12:42:41 <cmccann> I'm sure it's been done
12:43:01 <Sgeo> I think exact real arithmatic kind of overlaps
12:43:04 <cmccann> yeah
12:43:13 <dmwit> Ah, yes.
12:43:16 <cmccann> and that was being discussed in here a week or two ago
12:43:27 <cmccann> about a continued fraction representation
12:43:43 <cmccann> which allowed the kind of progressive refinement that Sgeo is aiming for, in a different way
12:45:17 <rwbarton> a better type would be a list of bounds terminated by an exact value
12:45:18 <ski> well, oughtn't a lazy improving interval type replace the last approximation with the new one ?
12:46:01 <ski> so instead of having two states, `Thunk thunk' and `Value value', we'd have more states
12:48:14 <dmwit> Thunks only allow for one-time mutation.
12:48:19 <dmwit> You're asking for multiple-time mutation.
12:48:44 <dmwit> err... yes, I see you understood that already. =P
12:49:36 <dmwit> Thank goodness for unsafePerformIO, eh chaps?
12:50:25 <Eelis> is there something i can put at the top of a .hs file to tell ghc/cabal not to optimize it?
12:50:40 <koeien> {-# OPTIONS_GHC -O0 #-}
12:50:41 <dmwit> {-# OPTIONS_GHC -O0 #-}
12:50:42 <koeien> perhaps.
12:50:45 <Eelis> ah, great
12:50:47 * Eelis tries
12:50:55 <koeien> don't know if that is a global or per-file setting
12:51:01 <hpc> Eelis: that's "capital 'o'" followed by zero
12:51:05 <Eelis> right
12:51:09 <hpc> in case your font is like mine
12:51:16 <dmwit> Use a better font. =P
12:51:21 <dmwit> Also: copy and paste.
12:51:32 <shachaf> hpc: I imagine that Eelis knows about optimization flags, what with asking this question.
12:51:34 <hpc> dmwit: look at my font my font is so great
12:51:43 <hpc> shachaf: :P
12:51:50 <dmwit> My font uses a tiny little rendering of the word "one" for the 1 character.
12:52:44 * dmwit ponders briefly how unusable a font that rendered every character as its pronunciation would be
12:53:19 <cmccann> dmwit, ☃
12:53:37 <dmwit> see em see see ay en en, ell oh ell
12:53:45 <shachaf> Characters don't have pronunciations.
12:53:48 <shachaf> Especially not in English.
12:54:11 <Sgeo> :t (***)
12:54:11 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:54:31 <dmwit> ess slash , slash see oh em em ay slash comma oh eff space see oh you are ess ee
12:54:51 <Sgeo> :t (&&&)
12:54:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:55:03 <dmwit> bleh, it's terrible
12:55:06 <cmccann> Sgeo, just read the "a" in those as (->)
12:55:38 <dmwit> (***) :: Arrow (~>) => (b ~> c) -> (b' ~> c) -> ((b, b') ~> (c, c'))
12:55:46 <teneen> how to convert an Integer to a ByteString?
12:55:55 <dmwit> unsafeCoerce
12:55:57 <Eduard_Munteanu> :t (<<<)
12:55:58 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
12:56:05 <dmwit> pack . return . fromInteger
12:56:08 <Eduard_Munteanu> :t (Prelude..)
12:56:09 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:56:14 <augur> @seen koninkje_away
12:56:14 <lambdabot> Unknown command, try @list
12:56:17 <augur> D:
12:56:22 <Eelis> hm, i don't think adding {-# OPTIONS_GHC -O0 #-} made any difference. (i have a module that compiles in maybe 30 seconds without optimization, but crashes ghc after 20 minutes with optimization)
12:56:25 <augur> !seen koninkje_away
12:56:26 <Sgeo> @pl \a -> a *** a)
12:56:26 <lambdabot> (line 1, column 14):
12:56:26 <lambdabot> unexpected ")"
12:56:26 <lambdabot> expecting letter or digit, variable, "(", operator, "&&", "***", "&&&", "<|>" or end of input
12:56:28 <Sgeo> @pl \a -> a *** a
12:56:28 <teneen> dmwit: realy? unsafeCoerce?
12:56:28 <lambdabot> join (***)
12:56:32 <augur> hm.
12:56:37 <augur> whats the seen command D:
12:56:41 <dmwit> teneen: No, not really.
12:56:43 <Sgeo> :t join (***)
12:56:43 <dmwit> 100% not really
12:56:44 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
12:56:49 <dmwit> teneen: The other suggestion was also a joke.
12:56:53 <shachaf> teneen: No. Not really. Your question is very vague and ill-defined, so people can't help but give joke answers to it.
12:57:13 <shachaf> If you figured out exactly what you want to do, you might even be able to use Hoogle to do it yourself.
12:57:17 <monochrom> I thought we love guessing games
12:57:25 <mikeplus64> what's the "best" way to download a binary file in haskell? if I'm downloading a png, using (let openURL x = getResponseBody =<< simpleHTTP (getRequest x) in openURL "https://www.google.com/images/nav_logo99.png" >>= writeFile "test.png")
12:57:26 <dmwit> teneen: A real answer begins with, "You are probably using ByteString to represent text. Don't do that.".
12:57:29 <shachaf> On the other hand, what you want to do is probably wrong.
12:57:31 <mikeplus64> seems to work, but the png file is corrupt
12:57:33 <shachaf> What dmwit said.
12:57:34 <teneen> shachaf: I want to convert an Integer value to a ByteString to output it to a file
12:57:44 <shachaf> teneen: What does that mean?
12:57:56 <shachaf> A ByteString is a thing that holds bytes.
12:57:58 <dmwit> teneen: No you don't. You want to convert an Integer value to a Text to encode and output to a file.
12:58:00 <monochrom> perhaps you should give an example
12:58:17 <rwbarton> maybe his file is encoded in ASCII
12:58:18 <dmwit> s/Text/String/ is also acceptable
12:58:27 <Sgeo> dmwit, maybe he has an Integer that is a bunch of bytes?
12:58:33 <teneen> shachaf: I know, that's why I want to convert each digit to be represented by a byte!
12:58:40 <monochrom> maybe he should say "ASCII" himself. I would like that.
12:58:47 <Eelis> i think it may be ignoring {-# OPTIONS_GHC -O0 #-} because cabal is invoking ghc with --make and the module in question is just one of many modules that need compilation
12:58:57 <shachaf> teneen: How?
12:59:10 <shachaf> I can think of dozens of representations of Integers in ByteStrings.
12:59:11 <monochrom> and yes bear in mind that ByteString is about bytes, not "characters" anymore
12:59:13 <ski> dmwit : well, in a sense you get multiple-time mutation with a nested value .. (but one'd like to avoid that here)
12:59:16 <mikeplus64> can anyone tell me why this: let openURL x = getResponseBody =<< simpleHTTP (getRequest x) in openURL "https://www.google.com/images/nav_logo99.png" >>= writeFile "test.png"
12:59:20 <mikeplus64> downloads a corrupt png?
12:59:34 <monochrom> if my Integer is 31416 what should the bytes be?
12:59:35 <rwbarton> windows?
13:00:07 <monochrom> fill in the blanks: there will be ___ bytes, the 1st byte is ___ , ...
13:00:07 <teneen> dmwit: then what's ByteString used for?
13:00:14 <mikeplus64> rwbarton: if you're addressing me, nope
13:00:25 <teneen> dmwit: isn't it good for efficient IO?
13:00:26 <Sgeo> Binary data, I'd assume
13:00:31 <teneen> dmwit: my data is only numbers
13:00:33 <dmwit> teneen: Sequences of bytes. Strings are not sequences of bytes.
13:00:48 <teneen> dmwit: it's an Integer not a string
13:00:58 <monochrom> sure, ByteString is good for efficient I/O of a lot of bytes
13:01:03 <dmwit> teneen: So, you want a binary representation of an Integer?
13:01:15 <mikeplus64> someone want to try that snippet above and verify that it downloads garbage?
13:01:20 <teneen> dmwit:yes it's fine
13:01:36 <dmwit> teneen: Okay, great!
13:01:41 <monochrom> big endian? small endian? middle endian? 3/4 endian?
13:02:01 <rwbarton> mikeplus64: yeah, it fails here too.
13:02:19 <Silvah> Pi endian!
13:02:26 <dmwit> teneen: Use the "binary" library, and just call "put".
13:02:28 <dmwit> done
13:02:29 <mikeplus64> rwbarton: it downloads something resembling a png, but it's not quite there :(
13:02:37 <rwbarton> I assume it's somehow unicode-related
13:02:44 <shachaf> teneen: Do you actually know what you want?
13:02:54 <dmwit> Or even better, just use "encode".
13:02:54 <rwbarton> as String is not really an appropriate data type for representing a PNG file
13:02:55 <Eelis> hm, considering that {-# OPTIONS_GHC -O0 #-} doesn't work, is there a way i can specify in my .cabal file that i don't want any optimization ever?
13:02:59 <dmwit> encode :: Integer -> ByteString
13:03:05 <mikeplus64> yeah, maybe I have to download it as ByteString, but I dunno what function there is to do that
13:03:15 <monochrom> String is also royally inefficient for PNG
13:03:17 <jeff_s_> Is there a way to search hoogle for types that are instances of Applicative?
13:03:25 <teneen> dmwit: where is encode?
13:03:32 <Sgeo> You know what, I shouldn't use join (***) if I don't understand how it works
13:03:42 <dmwit> teneen: http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html#v:encode
13:03:51 <shachaf> Sgeo: Which part don't you understand? join or (***)?
13:04:00 <mikeplus64> ok, now to find a function to download as bytestring
13:04:10 <cmccann> Sgeo, how they work in general, or what (join (***)) means on functions?
13:04:19 <monochrom> Sgeo: the "join" part probably uses the "(->) e" monad, i.e., "instance Monad ((->) e)". hope it helps.
13:04:20 <Sgeo> cmccann, why join (***) means what it means
13:04:24 <Silvah> :t join (***)
13:04:25 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
13:04:32 <shachaf> Sgeo: Which part of it?
13:04:32 <cmccann> well, monochrom is right about join
13:04:40 <cmccann> :t join
13:04:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:04:42 <teneen> dmwit: great thanks
13:04:43 <shachaf> join is \f x -> f x x
13:04:51 <rwbarton> hmm, is there no way to get prelude IO functions to do the old .Char8-style "encoding"?
13:04:56 <rwbarton> LANG=C ghci didn't help
13:04:57 <Sgeo> shachaf, that makes sense, thanks
13:05:06 <Sgeo> And thanks monochrom
13:05:14 <dmwit> rwbarton: Yes, there's a hook for setting latin-1 encoding.
13:05:15 <shachaf> Sgeo: However, you *should* figure out why join does that.
13:05:18 <dmwit> rwbarton: one sec
13:05:28 <shachaf> In the Arrow case, there's less figuring it out, because (***) is just a primitive.
13:05:32 <shachaf> (Or close enough to a primitive.)
13:06:20 <Sgeo> Ok, thought about it, I think I get it
13:06:23 --- mode: ChanServ set +o mauke
13:06:23 --- mode: mauke set -b $a:lawful_evil
13:06:32 <Sgeo> > join (+) 20
13:06:33 <cmccann> Sgeo, and (***) in this case amounts to \f g (x, y) -> (f x, g y)
13:06:33 <lambdabot>   40
13:06:46 --- mode: mauke set +b $a:lawful_evil
13:06:56 <Sgeo> :t (join (***) (liftA2 (+)))
13:06:57 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => (f a, f a) -> (f a -> f a, f a -> f a)
13:07:00 <monochrom> rwbarton: I don't know what LANG=C does to GHC, but if you choose a LANG that specifies iso-latin-1 (iso-8859-1), or if you inside your program "hSetEncoding h latin1", you get Char8 behaviour
13:07:00 <dmwit> Hackage just went down... =/
13:07:13 <cmccann> Sgeo, so (join (***)) gives you \f (x, y) -> (f x , f y)
13:07:26 <dmwit> Anyway, monochrom's on the ball, so Hackage doesn't have to be.
13:07:58 <exFalso> @hoogle Eq a => [a] -> [(a,Int)]
13:07:58 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
13:07:58 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
13:07:58 <lambdabot> Data.Graph.Inductive.Query.BFS level :: Graph gr => Node -> gr a b -> [(Node, Int)]
13:08:02 <dmwit> hSetEncoding is in GHC.IO.Handle; latin1 is in GHC.IO.Encoding
13:08:06 <monochrom> oh yikes, hackage goes down again?
13:08:14 <monochrom> they're also in System.IO
13:08:20 <rwbarton> Hmm, I can't get a working LANG=..., but maybe it's because I don't have those locales built?
13:08:23 <dmwit> It's back up now, which makes me suspect it was just my computer going on the fritz.
13:08:38 <monochrom> heh ok!
13:08:46 --- mode: mauke set -o mauke
13:08:59 <monochrom> but granted GHC.IO exposes more detailed API for hacking
13:09:15 <Sgeo> Who is lawful_evil?
13:09:59 <rwbarton> LANG=en_US.utf8 is so wonderfully evil.
13:10:02 <alistra> dungeons and dragons!
13:10:04 <srhb> Real World Haskell has confused me. Doesn't "foo" =~ "o*" :: [String] make sense?
13:10:26 <rwbarton> I recently discovered that grep '[a-z]' also matches capital letters, except Z.
13:10:57 <dmwit> rwbarton: what
13:10:58 <copumpkin> rwbarton: wat
13:11:29 <dmwit> rwbarton: Your computer is Broken.
13:11:30 <shachaf> rwbarton: Yes, I discovered that also.
13:11:36 <srhb> Sounds like a funny fencepost in some specific implementation
13:11:38 <shachaf> I think it's fixed in a newer version or somethign.
13:11:41 <srhb> Mine doesn;t do that.
13:11:41 <dmwit> My grep does not do that.
13:11:50 <shachaf> It depends on locale.
13:11:50 <monochrom> oh what fun
13:11:51 <dmwit> Even with LANG=en_US.utf8
13:11:53 <Eduard_Munteanu> rwbarton: that can happen if your locale is set to something weird
13:11:59 <dmwit> shachaf: Which locale should I try?
13:12:03 <shachaf> Somehow it orders letters as "aAbBcCdD..."
13:12:08 <shachaf> Which explains this behaviour, of course.
13:12:15 <monochrom> interesting
13:12:22 <dmwit> hah
13:12:24 <Eduard_Munteanu> LANG=en_US LC_ALL=en_US grep ...
13:12:47 <dmwit> Eduard_Munteanu: Still WFM.
13:12:48 <shachaf> dmwit: Happens for me using en_US.UTF-8 and GNU grep 2.6.3.
13:13:13 <dmwit> ah, grep-2.10 here
13:13:15 <shachaf> rwbarton: Also note that the highlighting algorithm is inconsistent.
13:13:37 <shachaf> I.e., if you grep --color '[a-z]', it'll match both 'a' and 'A' but only highlight 'a'.
13:13:38 <drdo> Does anyone have any idea how to use feed (the library) to just read a feed? (or suggest an alternative librar)
13:13:46 <rwbarton> My grep is 2.6.3 also.
13:13:55 <rwbarton> shachaf, nice.
13:14:10 <srhb> What is the right way to get a list of all matches with Text.Regex.Posix and ~= ?
13:14:27 <rwbarton> Eduard_Munteanu: You're reinforcing my belief that all locales besides C are "weird".
13:14:46 <shachaf> srhb: Step 1: Don't use (~=).
13:14:54 <shachaf> That's because the operator is called (=~), of course.
13:15:01 <alistra> :t (=~)
13:15:02 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
13:15:03 <shachaf> But using (=~) will probably also bring you suffering.
13:15:04 <srhb> Sorry, that was my typo.
13:15:07 <Eduard_Munteanu> rwbarton: or 'grep' making weird assumptions? :/
13:15:17 <shachaf> rwbarton: RACIST
13:15:32 <Eduard_Munteanu> I'd rather have [a-z] have a consistent meaning across locales.
13:15:50 <rwbarton> Though it is proven wrong in this case, I generally have more faith in grep than in locales.
13:16:05 <srhb> > "foo" =~ "o" :: [String]
13:16:06 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
13:16:06 <lambdabot>                    ...
13:16:29 <ion>  I love how she uses an entire line just to say “..” instead of relevant information. :-)
13:16:34 <ion> “.”
13:16:39 <srhb> HUh, okay.. This works
13:16:46 <rwbarton> ion: '                    ' isn't relevant information?
13:16:53 <srhb> > "foo" =~ "o" :: [[String]]
13:16:54 <lambdabot>   [["o"],["o"]]
13:17:04 <srhb> Quirky.
13:17:27 <ion> rwbarton: I’d say the “...” is more relevant information than the whitespace.
13:17:34 <donri> srhb: perhaps to deal with groups
13:18:46 <sshine> > "Bloomsbury's" =~ "[sob]"
13:18:47 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
13:18:47 <lambdabot>                    ...
13:18:50 <rwbarton> yup, first element of each list is the entire matched string, then subsequent elements are capture groups.
13:18:52 <sshine> > "Bloomsbury's" =~ "[sob]" :: [[String]]
13:18:53 <lambdabot>   [["o"],["o"],["s"],["b"],["s"]]
13:18:56 <BMeph> Does anyone know if there are any ongoing OS projects?
13:19:03 <rwbarton> Which, indeed, is quirky.
13:19:12 <sshine> > "Bloomsbury's" =~ "[soB]" :: [[String]]
13:19:13 <lambdabot>   [["B"],["o"],["o"],["s"],["s"]]
13:19:13 <BMeph> (A la House)
13:19:24 <dmwit> I thought there was a different mechanism for grouping.
13:19:28 <sshine> I'm not very prepared, it seems. I'm trying to spell boobs.
13:19:41 <rwbarton> > "foo" =~ "(o)" :: [[String]]
13:19:42 <lambdabot>   [["o","o"],["o","o"]]
13:19:55 <rwbarton> dmwit: Just because there is this mechanism doesn't mean there can't also be another mechanism.
13:19:58 <dmwit> ah, now I understand what you mean
13:20:54 <sshine> > "bloodmobiles" =~ "[sobie]" :: [[String]]
13:20:54 <lambdabot>   [["b"],["o"],["o"],["o"],["b"],["i"],["e"],["s"]]
13:20:59 <dmwit> > "Bloomburies" =~ "[Bob's]" :: [String]
13:21:00 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
13:21:00 <lambdabot>                    ...
13:22:23 <midien> hello there! I need a quick answer for the following question: I ve got something like [(1,2,3),(1,2,3),(4,32,1),(1,2,3),(1,2,3),(4,32,1)] and i want a function that generates a list of lists witch the size of each list should be 2 and the number of the lists in the list should be 3... any idea??? please ?:D  (aah so the output should be something like [[Con 1 2 3,Con 1 2 3],[Con 4 32 1,Con 1 2 3],[Con 1 2 3,Con 4 32 1]]
13:22:56 <dmwit> Sounds like homework, mate.
13:23:07 <dmwit> Our homework policy demands big, tall monies.
13:23:27 <Axman6> as well as a lot of effort on your part
13:23:33 <midien> it does... but it's for myself
13:23:46 <sshine> I just want more interesting challenges than my own (home)work. (:
13:23:47 <dmwit> Right, then, what have you tried already?
13:24:15 <midien> i was trying to find a way with list comprehention but i couldn't ( i am learning now haskell)
13:24:25 <sshine> midien, why do you make lists if you know they have exactly two elements?
13:25:20 <ion> Try getting [[(1,2,3),(1,2,3)],[… first and convert tuples to Cons at the end. Or alternatively convert them first. Anyway, The conversion is not a part of the function for the list splitting.
13:25:22 <dmwit> List comprehensions treat each element of a list uniformly. Since you aren't treating them uniformly (you're treating them paired up), you will indeed need some other tool.
13:25:31 <midien> i don't...actually the first triple is the definition of the "lenght of each list" and the length of each element
13:26:01 <dmwit> huh
13:26:14 <dmwit> Then it's clear that I don't yet even understand the problem statement.
13:26:34 <midien> my output that i want to recreate was something like :[(2,3,0),(1,2,3),(1,2,3),(4,32,1),(1,2,3),(1,2,3),(4,32,1)]
13:27:08 <ion> I thought that was your input.
13:27:14 <midien> yes sorry
13:27:16 <midien> my input
13:27:41 <koeien> right, first try to take all consecutive pairs
13:27:50 <midien> but if u check the first element ...is just for "directions" for my new output
13:27:51 <koeien> [a,b,c,d,e,f] -> [(a,b), (c,d), (e,f)]
13:27:53 <koeien> can you do that?
13:28:10 <sshine> midien, so... [a,b,c,d] -> [[a,b],[c,d]]?
13:28:35 <midien> i  do not know always the ouput
13:28:50 <sshine> midien, then how can you make the function?
13:28:53 <midien> that's a small example
13:29:14 <sshine> midien, so... [a,b,c,d,e,f] -> [[a,b],[c,d],[e,f]]?
13:29:54 <sshine> midien, try and make a recursive function that handles two items in the list at a time.
13:30:14 <midien> yes..that is what i am trying:s
13:30:29 <sshine> midien, how do you match a list with at least two elements?
13:31:51 <beginner> awesome :D
13:31:57 <midien> the input list has at least 2 elements..if it has 2 elements i know that the first element should be something like (1,0,0) or (0,1,0)
13:32:31 <drull95> thanks for your help guys :)
13:32:39 <sshine> midien, as far as I can see, the transformation you want done doesn't really have to take into account that you're dealing with lists of three-tuples.
13:32:44 <midien> let (a,b,c)=take 1 fromMyList
13:33:10 <Sgeo> :t take
13:33:11 <lambdabot> forall a. Int -> [a] -> [a]
13:33:12 <koeien> do you know how to pattern match on a list?
13:33:13 <drull95> i was documenting my problem so i could ask you what i was misunderstanding and just as i was about to submit it i had a doh! moment
13:33:17 <midien> so a is the size of my list of lists and b the size of my list
13:33:30 <drull95> good job all around
13:33:36 <ion> midien: I recommend reading LYAH.
13:33:38 <ion> @where lyah
13:33:38 <lambdabot> http://www.learnyouahaskell.com/
13:33:54 <midien> it was my first tutorial
13:34:00 <midien> doesn't help for that :D
13:34:03 <midien> anyway thnx
13:34:10 <midien> i will find a way
13:34:12 <sshine> midien, have you read about pattern matching?
13:34:19 <midien> yes sshine
13:34:36 <sshine> midien, then try and pattern-match a list with two or more elements.
13:34:45 <dmwit> drull95: We're the best brick wall in town.
13:35:16 <dmwit> sshine: You keep saying that. But it's not clear that midien is always going for chunk sizes of two.
13:35:27 <dmwit> midien: Look, you have to specify your problem a bit better if you want help.
13:35:36 <sshine> dmwit, that wasn't clear to me.
13:35:46 <dmwit> Tell us in English how you're supposed to go from an input to an output.
13:35:56 <sshine> or at least supply enough unambiguous examples.
13:36:37 <midien> Hmm u don't like my English? :P
13:36:37 <xil> hi. I used 'for' on a list so that I didn't need to do 'flip map' but I got very very different results. Am I misunderstanding the 'for' function?
13:36:50 <mauke> :t for
13:36:51 <lambdabot> Not in scope: `for'
13:36:56 <mauke> xil: what is 'for'?
13:36:58 <dmwit> :t T.for
13:36:58 <lambdabot> Couldn't find qualified module.
13:37:03 <dmwit> :t Data.Traversable.for
13:37:04 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Data.Traversable.Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
13:37:05 <dmwit> presumably
13:37:20 <dmwit> And yes, for is very different from map.
13:37:29 <dmwit> However, it's very similar to mapM.
13:38:03 <xil> aha. That would do it then. Thanks =]
13:38:28 <Cody_> There are no such things as for loops because in Haskell there is no such thing as an destructive updates. IE x = x + 1
13:38:38 <rwbarton> maybe 'for' should be named something like 'forA'
13:38:45 <rwbarton> :t Data.Traversable.mapA
13:38:46 <lambdabot> Not in scope: `Data.Traversable.mapA'
13:38:48 <rwbarton> :t Data.Traversable.mapM
13:38:49 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
13:38:50 <rwbarton> :t Data.Traversable.map
13:38:51 <lambdabot> Not in scope: `Data.Traversable.map'
13:38:51 <companion_cube> IE 6 = 6 + 1 ?
13:38:58 <Axman6> > let x = x + 1 in x -- there so is
13:39:01 <lambdabot>   mueval-core: Time limit exceeded
13:39:09 <cmccann> heh
13:39:13 <Cody_> X would still be the same afterwards axman5
13:39:26 <dmwit> Axman6: He did say "destructive update", which that is not.
13:39:26 <Cody_> > let x = x + 1 in 5
13:39:27 <lambdabot>   5
13:39:49 <ciaranm> > let  1 + 1  = 3 in 1 + 1
13:39:50 <lambdabot>   3
13:40:06 <dmwit> That's just a misconception.
13:40:12 <dmwit> > let 1 + 1 = 3 in 1 Prelude.+ 1
13:40:13 <lambdabot>   2
13:40:13 <xil> lolol
13:40:17 <dmwit> It's still not destructive update.
13:41:01 <ion> Is there a small, easy-to-install IRC bot that has mueval functionality?
13:41:34 <Cody_> In Haskell, the only way you can *change* a variable is if you reassign. Just because you apply a function to x doesn't mean it changes x. You could apply three functions to x but it wouldn't change it.
13:41:43 <dmwit> ion: I don't think so.
13:41:48 <dmwit> ion: Why do you ask?
13:41:49 <koeien> "reassign", what is that?
13:41:52 <cmccann> xil, by the way, you might want to consider using (<$> [1..2]) instead of flip map
13:41:58 <Feuerbach> Cody_: why would you think that xil wanted any destructive updates? I think he was pretty clear that he wanted "flip map", which is reasonable to name "for"
13:42:13 <Axman6> reassign == mutate in my mind
13:42:15 <Cody_> Feuerbach: Sorry, I jumped in like a min ago
13:42:18 <ion> dmwit: I’d like to have the equivalent of @run on certain other channels.
13:42:20 <Axman6> ,*
13:42:30 * dmwit nods
13:42:45 <cmccann> :t mapM
13:42:46 <Cody_> koeien: I mean set permanently.
13:42:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:42:47 <cmccann> :t forM
13:42:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:42:50 <dmwit> ion: You can request to have lambdabot join other channels. Though I understand that \bot brings a lot of other stuff along that you may or may not want.
13:42:54 <hpc> ion: there's probably bots in other languages that are easy to set up and can make a system call to mueval
13:42:58 * cmccann thinks assuming that "for" would be "flip map" is reasonable, yes
13:43:05 <Axman6> it kinda annoys me that you can reuse variable names in do notation (and let expressions within them)
13:43:05 <hpc> that's how lambdabot does it
13:43:14 <ion> dmwit: Yeah, and it’s probably not possible to get her into e.g. IRCnet.
13:43:20 <koeien> Axman6: does shadowing annoy you elsewhere as well?
13:43:24 <xil> cmccann: why do you recommend that?
13:43:31 <paulotruta> hi ppl
13:43:35 <dmwit> ion: Oh? Why not?
13:43:40 <Axman6> koeien: not so much, but i usually try to avoid it too
13:43:44 <koeien> :t (\x -> (\x -> x))
13:43:46 <lambdabot> forall t t1. t -> t1 -> t1
13:44:02 <mikeplus64> anyone know of ByteString equivalents to the functions in Network.HTTP?
13:44:02 <cmccann> xil, it's just an alternative if you don't like using flip map
13:44:13 <koeien> @hackage network-bytestring
13:44:13 <lambdabot> http://hackage.haskell.org/package/network-bytestring
13:44:22 <koeien> wups, nm
13:44:45 <ion> dmwit: IRCnet servers tend to be rather exclusive about whom they let in in the first place and most seem to have a policy against bots.
13:45:23 <xil> cmccann: oh okay. I'll probably use it next time. I only used for because I thought I remembered reading it as being 'flip map' and wanted to give it a try
13:45:26 <ion> dmwit: Getting lambdabot to run in IRCnet might be too much of a hassle.
13:45:55 <cmccann> xil, forM is flip mapM
13:45:59 <cmccann> that might be what you were thinking of
13:46:06 <xil> yeah it was
13:46:22 <xil> but I'm outside a monad here, so no use for it
13:46:25 <paulotruta> i have this function (tobytes :: String -> Int) that converts a stringof the type "xx.xx MB" to an integer with the respective bytes. I i try to do "filter ((<2195542(.size) media" it works, but if i try "filter ((<(tobytes "2.49 MB").size) media" does not work... can somebody tell me why?
13:46:33 <ion> What is preflex running?
13:46:43 <koeien> paulotruta: those parens can't be richt.
13:46:59 <koeien> filter ((<2195542) . size) media
13:47:15 <paulotruta> yeah mistyped, sorry
13:47:25 <paulotruta> that's what i meant
13:47:33 <koeien> what is the type of size?
13:47:34 <Axman6> paulotruta: just use lambdas and make what you're doing clear: filter (\x -> size x < tobytes "2.49 MB") media
13:47:39 <paulotruta> Int
13:47:50 <koeien> that can't be, it must be a function
13:48:10 <dmwit> paulotruta: Probably 2195542 isn't of type Int in the former.
13:48:36 <dmwit> Check the types of media and size to be sure.
13:49:04 <dmwit> (Perhaps you're forgetting that Int and Integer are different types?)
13:49:24 <Axman6> there's clearly a bracket missing in ((<(tobytes "2.49 MB").size): ( (< (tobytes "2.49 MB")) . size)
13:49:42 <Axman6> but why you wouldn't use a lambda and make it read as you'd say it in english I have no idea
13:49:55 <rwbarton> alternatively, there's an extra (
13:49:56 <paulotruta> yeah i know, but size is part of the media datatype i've created, and it is an Int. The function tobytes returns an Int too
13:49:59 <dmwit> paulotruta: For a real answer, you'll have to paste the actual code, and the actual error message (for example, on hpaste.org).
13:50:00 * koeien prefers the composed version
13:50:08 <Axman6> 'filter each x, where the size of x is less than 2.49 MB'
13:50:24 <Axman6> koeien: remind me not to work on any of your code then
13:52:51 <paulotruta> i've solved it! It had a bracket missing :P Damn brackets sometimes can make people mad xD Thanks guys!
13:53:11 <Axman6> i said that like 5 minutes ago -_-
13:53:20 <Axman6> 09:31:46 < Axman6> there's clearly a bracket missing in ((<(tobytes "2.49 MB").size): ( (< (tobytes "2.49 MB")) . size)
13:53:21 * cmccann also thinks the composed version is nicer than the lambda
13:53:52 <paulotruta> i know Axman6 , but i was looking to the code over and over again and i couldn't find the missing bracket
13:54:07 <dmwit> Perhaps you should choose another editor.
13:54:11 <Axman6> cmccann: the fact it's taken him this long to see what the problem was says to me that it's probably the wronf chouce
13:54:28 <Axman6> wrong choice*
13:54:30 <Axman6> o.O
13:54:53 <dmwit> Aha! You use Dvorak layout.
13:55:00 <Cody_> Does the $ sign mean => Have parentheses go from here all the way to the right?
13:55:02 <dmwit> I can tell by your typos and by having seen quite a few Dvorak users in my time.
13:55:10 <Axman6> dmwit: no, it's definitely qwerty
13:55:14 <koeien> Cody_: that's pretty accurate
13:55:16 <paulotruta> i'm happy with my actual editor, but thanks anyway :)
13:55:24 <koeien> Cody_: but ($) is in fact a perfectly ordinary function
13:55:24 <shachaf> Cody_: No, but it means something vaguely similar.
13:55:24 <dmwit> Cody_: That's fairly accurate, but the true meaning of ($) is this:
13:55:26 <rwbarton> f-g and u-i are adjacent in both
13:55:26 <dmwit> ?src $
13:55:27 <lambdabot> f $ x = f x
13:55:37 <Axman6> dmwit: it's quite possible that those keys are also right next to each other on dvorak
13:55:44 <koeien> Cody_: it just means f $ x = f x, but the precedence is the lowest
13:55:50 <dmwit> Axman6: Odd. 'u' is one button to the left of 'i', and 'f' is one button to the left of 'g' on Dvorak.
13:55:54 <shachaf> {-# NOINLINE ($) #-}
13:55:56 <dmwit> Axman6: So that typo is quite a coincidence indeed.
13:56:07 <hpc> shachaf: really?
13:56:11 <shachaf> I hope not.
13:56:15 <rwbarton> 'u' is one button to the left of 'i', and 'f' is one button to the left of 'g' on qwerty also
13:56:21 <Cody_> koeien: scachaf: dmwit: Thanks
13:56:27 <dmwit> rwbarton: Oh, so they are.
13:56:27 <Axman6> "...yuio..." and "...dfgh..." <- qwerty
13:56:38 <rwbarton> (in fact qwerty f is dvorak u and qwerty g is dvorak i)
13:56:38 <koeien> so f $ x y z just means f (x y z). it's not a special language feature
13:57:07 <roconnor> what is the status of Either and monad?
13:57:23 <Axman6> roconnor: heh, how interesting
13:57:27 <Cody_> koeien: Yea, I thought I saw that in ruby?
13:57:39 <koeien> i do not know ruby, so I can't comment
13:57:48 <Cody_> Not 100% sure
13:57:59 <ion> I don’t remember an equivalent to ($) in Ruby.
13:58:03 <roconnor> what is the status of Either and monad and fail?
13:58:07 <Cody_> Yea nevermind then.
13:59:00 <dmwit> roconnor: There's a Control.Monad.Error which provides a Monad instance for some Either's; and a fixed Monad class with a proper Either instance in the split of category-extras.
14:00:21 <Cody_> :t max Integral
14:00:22 <lambdabot> Not in scope: data constructor `Integral'
14:00:29 <hpc> fixed in the sense of not having "fail"?
14:00:52 <Cody_> :t max Int
14:00:53 <lambdabot> Not in scope: data constructor `Int'
14:00:59 <koeien> > maxBound :: Int
14:01:00 <lambdabot>   9223372036854775807
14:01:09 <dmwit> hpc: yes
14:01:10 <koeien> Integral is not a type, it's a type class.
14:01:13 <danr> > maxBound :: Double
14:01:14 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
14:01:14 <lambdabot>    arising from a use o...
14:01:21 <sshine> maxBound :: Integer
14:01:24 <Cody_> maxBound :: Integer
14:01:32 <koeien> Integer is not bounded.
14:01:34 <Axman6> >'s are important guys
14:01:34 <dmwit> Integer is not Bounded.
14:01:37 <sshine> I know.
14:01:42 <Axman6> @quote stereo
14:01:42 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
14:02:20 <sshine> /nick Dolby5`1
14:02:51 <koeien> > let { x :: Integer; x = fromIntegral (maxBound :: Int) } in x * x -- values of type Integer can be arbitrarily large.
14:02:52 <lambdabot>   85070591730234615847396907784232501249
14:03:38 <ion> maxBound :: Integer should keep allocating memory forever.
14:03:40 * cmccann defines maxBound for Integer by using unsafePerformIO and checking the amount of system memory available
14:03:49 <Cody_> > let fac x = x * fac(x-1) in fac 5
14:03:50 <dmwit> 8.5e36: official proof of unboundedness
14:03:51 <lambdabot>   *Exception: stack overflow
14:04:00 <Cody_> No base case...
14:04:01 <koeien> Cody_: that doesn't have a base case.
14:04:03 <ion> dmwit: hah
14:04:21 * Axman6 wishes someone would turn the stereo down
14:04:40 <roconnor> dmwit: I can't find Control.Monad.Instances anywhere :(
14:05:07 <dmwit> It's in base...
14:05:10 <Cody_> How come today when I computed factorial of 1000 GHCi gave me an answer. But yesterday it would only compute up to the factorial of 998. Is my computer a factor in this?
14:05:29 <dmwit> roconnor: What version of GHC (really, what version of base)?
14:05:47 <hpc> Cody_: your computer is learning; kill it before it's too late
14:06:02 <roconnor> I personally appear to be at 6.12.3, but I'm writing a library so who knows what version they want
14:06:24 <hpc> Cody_: what error did you get yesterday?
14:06:28 <dmwit> > length . show . product . enumFromTo (1 :: Integer) $ 998
14:06:29 <Cody_> hpc: Lol. How does it learn, I believe you because I can now do factorial of 2000 and counting
14:06:30 <lambdabot>   2562
14:06:37 <roconnor> dmwit: anyhow It seems I shoudn't rely on fail to return Left
14:06:47 <roconnor> dmwit: so I should probably use ErrorT rather than Either?
14:06:48 <Cody_> Just did factorial of 20000!
14:07:00 <Cody_> No error, that would have crashed it yesterday
14:07:06 <rwbarton> wait, that wasn't a joke?
14:07:27 <dmwit> roconnor: I doubt that behavior will change any time soon. It's relied on by many pieces of code other than yours. =P
14:07:38 <dmwit> roconnor: But sure, if you're alright with ErrorT, go with that.
14:07:53 <Axman6> > let fac n = fac' n 1 where fac' 0 x = x; fac' n !x = fac' (n-1) (n*x) in iterate fac 2
14:07:54 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
14:07:59 <Axman6> > let fac n = fac' n 1 where fac' 0 x = x; fac' n !x = fac' (n-1) (n*x) in iterate fac 2
14:08:00 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
14:08:07 <Axman6> wait...
14:08:13 <srhb> Mhm..
14:08:16 <roconnor> dmwit: there is a lot of code to touch, but it is probably the right thing to do; and replace fail with throwError
14:08:18 <koeien> 2! = 2
14:08:19 <Cody_> > cycle [1..1000000000]
14:08:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:08:21 <Axman6> > let fac n = fac' n 1 where fac' 0 x = x; fac' n !x = fac' (n-1) (n*x) in iterate fac 3
14:08:22 <lambdabot>   [3,6,720,260121894356579510020490322708104361119152187501694578572754183785...
14:08:25 <Axman6> better
14:08:29 <dmwit> roconnor: Control.Monad.Instances seems to date back to base-3. Are you *sure* you can't find it?
14:08:38 <dmwit> roconnor: (Or: what do you mean by "can't find it"?)
14:08:41 <roconnor> dmwit: I found it
14:08:43 <roconnor> in base
14:08:45 <roconnor> like you said
14:08:47 <roconnor> :)
14:08:50 <dmwit> oh, okay =)
14:09:07 <alistra> > cycle [1..]
14:09:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:09:15 <roconnor> Hmm, I may rely on pattern matching failure in places
14:09:23 <alistra> > cycle [1..] == cycle [1..1000000000]
14:09:27 <roconnor> I definitely want a monad plus
14:09:29 <lambdabot>   mueval-core: Time limit exceeded
14:09:29 <lambdabot>  mueval: ExitFailure 1
14:09:38 <dmwit> It's annoying that do-blocks don't reflect the use of pattern matching in their type signature.
14:09:43 * cmccann votes for just removing fail entirely and dealing with all the code breakage at once
14:09:46 <roconnor> dmwit: that would make things safer
14:10:03 <alistra> > cycle [1..] == cycle [1..100000000]
14:10:07 <lambdabot>   mueval-core: Time limit exceeded
14:10:09 <alistra> > cycle [1..] == cycle [1..10000000]
14:10:14 <lambdabot>   mueval: ExitFailure 1
14:10:15 <lambdabot>  mueval: Prelude.undefined
14:10:18 <alistra> > cycle [1..] == cycle [1..10000000]
14:10:28 <lambdabot>   mueval: ExitFailure 1
14:10:28 <lambdabot>  mueval: Prelude.undefined
14:10:57 <shachaf> alistra: Are you actually hoping to accomplish anything by doing that?
14:11:20 <dmwit> cmccann: My vote would be for making it a separate type class.
14:11:24 <alistra> shachaf: trying to get the exact moment, when mueval timesout
14:11:32 <roconnor>  mzero       = ErrorT $ return (Left noMsg)
14:11:35 <roconnor> that is good
14:11:42 <roconnor> so using ErrorT seems to be the way to go for me
14:11:45 <dmwit> do { (x:_) <- foo; x } :: (Monad m, Fail m) => m a
14:11:48 <dmwit> or whatever
14:12:14 <cmccann> dmwit, isn't that what MonadError already is
14:12:57 <dmwit> cmccann: What's in a name?
14:13:12 <dmwit> wait, no
14:13:18 <dmwit> That's not what MonadError is, is it?
14:13:23 <BMeph> Does anyone know if there are any ongoing OS projects?
14:13:32 <dmwit> I mean, I might want to have fail *and* throwError, no?
14:13:50 <cmccann> under what circumstances would they reasonably differ?
14:13:54 <hpc> @src MonadError
14:13:54 <lambdabot> class (Monad m) => MonadError e m | m -> e where
14:13:54 <lambdabot>     throwError :: e -> m a
14:13:54 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
14:14:03 <dmwit> cmccann: throwError could have a better type than String -> m a
14:14:10 <dmwit> e.g. an actually usable error type
14:15:32 <cmccann> dmwit, so shouldn't fail just be a special case of throwError, where the error type is String?
14:15:49 <dmwit> cmccann: No. I want a monad with a usable error type that still allows pattern-matching in do-blocks.
14:16:05 <dmwit> (and MonadError has a functional dependency preventing throwError from really being polymorphic)
14:16:34 <cmccann> pattern-matching doesn't really allow for useful error messages at all, so wouldn't MonadPlus be more appropriate? Or a MonadZero if you want to separate that out
14:16:41 <rwbarton> fail :: (IsString e, MonadError e m) => String -> m?
14:16:55 <dmwit> rwbarton: lol
14:17:05 <rwbarton> or Error or whatever ErrorT uses
14:17:09 <dmwit> rwbarton: We're supposed to be fixing this, not breaking it harder.
14:17:47 <dmwit> cmccann: I don't know. The string "Pattern (x:_) failed at Foo.hs:36:8" seems pretty useful.
14:18:08 <dmwit> (Which is the kind of String you get now.)
14:19:08 * cmccann shrugs
14:19:26 <dmwit> rwbarton: Oh, yeah, that would be reasonable.
14:19:38 <dmwit> (Error e, MonadError e m) would make me perfectly happy.
14:19:47 <rwbarton> @src Error
14:19:47 <lambdabot> class Error a where
14:19:47 <lambdabot>     noMsg  :: a
14:19:47 <lambdabot>     strMsg :: String -> a
14:20:13 * cmccann doesn't really consider pattern matching in do blocks that compelling a feature, to be honest
14:20:31 <dmwit> yeah
14:20:34 <dmwit> I'm not sure I use it much.
14:20:40 <dmwit> But preventing just seems... non-uniform.
14:20:48 <dmwit> All other binding locations allow patterns.
14:20:50 <shachaf> That's what MonadZero is for.
14:21:05 <shachaf> dmwit: In other locations a failed pattern match results in _|_.
14:21:11 <shachaf> Hmm.
14:21:15 <shachaf> I might be missing some context here.
14:21:24 <cmccann> yes, and I'd be okay with pattern match failures in do blocks resulting in _|_
14:21:30 <shachaf> Oh, now I see.
14:21:34 <cmccann> that would be consistent, at least
14:21:34 <dmwit> Yes, that would probably satisfy me, too.
14:21:37 <dolio> I wouldn't.
14:21:42 <rwbarton> I'd be very sorry to see some fail-like mechanism go away
14:21:43 <shachaf> Making fail part of MonadZero rather than Monad seems more reasonable than the current situation.
14:21:55 <dolio> @src catMaybes
14:21:55 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:22:06 <dmwit> meh
14:22:06 <cmccann> I'd also be okay with pattern matching in do blocks requiring a MonadZero constraint or whatever else people might come up with
14:22:24 <dmwit> catMaybes ls = [fromJust x | x <- ls, isJust x] -- isn't so horrible
14:22:25 <cmccann> I'd be especially okay with pattern matching in list comprehensions requiring a MonadPlus constraint
14:22:35 <koeien> dmwit: quite horrible imo
14:22:42 <cmccann> yeah, fromJust is always horrible
14:22:42 <shachaf> dmwit: That's disgusting.
14:23:18 <dmwit> catMaybes ls = [x | x_ <- ls, x <- maybe [] return x_] -- happier?
14:23:24 <koeien> but shouldn't there be a way to "cast" the MonadZero away?
14:23:25 <dmwit> hell,
14:23:32 <dmwit> catMaybes ls = ls >>= maybe [] return
14:23:51 <koeien> in case you have proven that pattern match failure "cannot" happen?
14:23:53 <rwbarton> in a do-block, the alternative to "pat <- expr" would be "x <- expr; case x of { pat -> ...; _ -> mzero {- or whatever -} }" which adds a new name, several lines, and an extra level of nesting or two
14:24:14 <koeien> well, I suppose that you can always introduce a helper function
14:24:24 <cmccann> koeien, making the type depend on whether the match is exhaustive is slightly more complicated
14:24:46 <dolio> That's how it used to work.
14:25:25 <cmccann> but yes, a MonadZero constraint iff any matches aren't provably exhaustive would be acceptable
14:25:54 <dmwit> I guess I'd survive in such a world.
14:26:26 <dmwit> But it's weird that people are converging on this when rwbarton's suggestion is so much sexier.
14:26:26 <dolio> We could call it: Haskell 1.4.
14:26:40 <shachaf> http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/exps.html#sect3.14
14:26:46 * BMeph will assume that means "no"...
14:27:04 <shachaf> Wait, what's rwbarton's suggestion?
14:27:13 <cl1> @pl foldr (\x y -> x) 0 (reverse [1..3])
14:27:13 <lambdabot> foldr const 0 (reverse [1..3])
14:27:22 <shachaf> I thought rwbarton was speaking for something MonadZero-style.
14:27:25 <dmwit> shachaf: (Error e, MonadError m e) =>
14:27:27 * cmccann cares about consistency, not making it easier to produce _|_, and not having fail on Monad itself
14:27:32 <dmwit> shachaf: instead of MonadZero m =>
14:27:35 <xil> hello again. I have a list of pairs sorted by the first part of each pair. Is there a structure that would allow me to essentially only map over the pairs whose first element is greater than a given value?
14:27:36 <shachaf> Oh.
14:27:44 <shachaf> MonadError?
14:27:57 <rwbarton> I don't know about this catchError stuff
14:28:04 <shachaf> That suggestion seems way more complicated.
14:28:04 <cl1> xil: filter?
14:28:05 <dmwit> True, catchError is a bit off.
14:28:07 <dolio> If you want to put it in Error instead, that's fine.
14:28:08 <koeien> filter ((>37).fst) -- xil (not sure what you mean)
14:28:16 <shachaf> It requires MPTCs, for instance, as you stated it.
14:28:50 <dolio> [] can go in there. It supports all error types, and catch does nothing.
14:28:51 <shachaf> xil: map (\(x,y) -> if x > 37 then ... else (x,y))?
14:29:11 <rwbarton> (btw, I don't necessarily endorse "my suggestion", I was just tweaking some other suggestions. I don't use MonadError often enough to know whether it would be sensible to use it in this way also.)
14:29:33 <xil> the idea is not to waste time filtering
14:29:53 * cmccann endorses basically anything that removes fail from Monad
14:30:05 <xil> I'm timing out on something that really shouldn't be timing out
14:30:28 <rwbarton> how about using a Set and split
14:30:38 <shachaf> cmccann: I recommend Functor m => Monad m and then putting fail in Functor. :-)
14:30:40 <dolio> Do you want to throw the rest away?
14:30:57 <rwbarton> oh, good question
14:30:59 <dolio> If you want to get rid of them, and they're sorted, then you can use takeWhile.
14:31:03 <cmccann> shachaf, ahahahahahaha no
14:31:30 <dolio> It will give the same answer as filter, but not hang a while looping through all the elements at the end.
14:31:47 <rwbarton> aren't the elements he wants at the end of the list though?
14:32:13 <rwbarton> Assuming "sorted" means in increasing order
14:32:14 <dolio> Maybe. In that case he's boned.
14:32:14 <shachaf> xil's sentence provides more and more information each time I read it.
14:32:25 <xil> the ideal situation would be to be able to know which end is longer, from the place I want, and then only map through the shorter end
14:32:26 <shachaf> xil: You want Data.Map, presumably?
14:32:40 <xil> I was thinking about Map, but can I map over a selective portion?
14:32:46 <xil> I don't see how to do that
14:33:21 <dmwit> mapWithKey?
14:33:23 <rwbarton> What exactly does "map over a selective portion" mean?
14:33:29 <dmwit> ah, not quite efficient, though
14:33:39 <parcs`> > do { x | otherwise <- [5]; return x }
14:33:40 <lambdabot>   <no location info>: parse error on input `|'
14:34:12 <rwbarton> parcs`: heh, I read that as some kind of goofy list comprehension at first.
14:34:37 <xil> rwbarton: not waste time looking at the values of the part I don't care about. My list is sorted, so I want to look at only the part greater than, or less than depending on the situation, than a value I give, and map over those
14:34:38 <dmwit> xil: I don't think the usual suspects offer this operation primitively.
14:34:47 <rwbarton> "map"
14:34:53 <dmwit> xil: If you want to do it very, very efficiently, you may have to add something to Data.Map.
14:34:58 <rwbarton> how about split?
14:35:09 <xil> yeah I'm looking at Set now
14:35:22 <dmwit> splitting and re-merging is inefficient compared to just operating on the interesting portion of the data, rwbarton
14:35:40 <rwbarton> Depends. But this get backs to xil not saying what he means by "map".
14:35:58 <rwbarton> Oh, I see what you mean.
14:36:02 <xil> 'map' the function. Like 'map myfunc list'
14:36:05 <rwbarton> I assume that's not what he wants to do.
14:36:18 <dmwit> Presumably he wants a map that's specialized a bit to only take endomorphisms.
14:36:18 <rwbarton> xil: give an example input/output
14:36:28 <xil> if set is immutable then I don't care about destroying it in the process
14:36:34 <rwbarton> since dmwit and I have very different ideas about what you mean.
14:36:35 <Mongey> Hey should map print list work ?
14:36:35 <shachaf> xil: I recommend you stop thinking in terms of the word "list".
14:36:40 <dmwit> Mongey: No.
14:36:48 <dmwit> Mongey: Perhaps you'd like mapM or mapM_.
14:36:50 <astor> hi haskellers, there was a blog post at some points about various ways of implementing lookup tables in haskell and their speed.  can anyone remember where? I cannot find it.
14:36:52 <shachaf> Mongey: Yes, for appropriate values of "work".
14:37:20 <rwbarton> Or, we can try to read your mind for a while longer.
14:37:45 <koeien> Mongey: it works, but probably does not do what you think it does. mapM_ should do the trick
14:38:17 <shachaf> rwbarton: Hey, read my mind!
14:38:34 <dmwit> shachaf: You're thinking, "haha, no way he can actually read my mind".
14:38:44 <rwbarton> shachaf: You're thinking "Hey I wish xil would say what he actually means by 'map'."
14:38:53 <shachaf> WRONG!
14:38:56 <dmwit> rwbarton: I think you accidentally read your own mind!
14:38:58 <shachaf> Haskell is such a bad language. QED
14:39:07 <xil> 'specialMap (+) 6 [0,1,4,5,6,7,9,11] = [7,8,10,12]' so 6 is the first element I care about. The catch is that specialMap shouldn't go through
14:39:12 <xil> there's an example
14:39:28 <xil> oh whoops, I didn't finish. specialMap shouldn't go through the first 4 elements at all
14:39:33 <dmwit> s/(+)/(+1)/ ?
14:39:37 <xil> yes
14:39:42 <rwbarton> Okay, good.
14:39:55 <dmwit> Also, your original question had both keys and values; so is this example really right?
14:39:58 <shachaf> So you don't even have pairs?
14:39:58 <xil> I'm in a rush sort of, so I'm not checking for errors before hitting enter
14:40:14 <shachaf> xil: Maybe you should wait until you're not in a rush before asking your question.
14:40:17 <Mongey> dmwit , koeien thanks
14:40:20 <xil> this example just shows the keys, right. There would be values too
14:40:34 <rwbarton> You can use Set or Map, and split.
14:40:37 <shachaf> xil: ...And is the "map" function mapping over the keys or over the values?
14:40:39 <shachaf> Or both?
14:40:41 <xil> shachaf: this whole thing is time sensitive. So I can't wait =/. But no rush on you all =]
14:40:47 <shachaf> Do the keys get resorted?
14:40:55 <xil> mapping over both ideally
14:41:01 <shachaf> xil: Is this homework?
14:41:04 <xil> no
14:41:08 <shachaf> xil: "ideally"? Either you need it or you don't.
14:41:17 <rwbarton> Really the operation you want is "throw away everything that has too low a key".
14:41:22 <shachaf> Figure out what you want to do as the first step.
14:41:24 <xil> it would help to have it map over the keys and values together, but I can live without it
14:41:25 <dmwit> Okay, if the keys can change, you won't do much better than splitting, mapping, and re-merging.
14:41:40 <shachaf> dmwit: Apparently xil doesn't even care about re-merging.
14:41:42 <rwbarton> I don't think he wants to re-merge at all.
14:41:56 <shachaf> @echo off
14:41:56 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "shachaf!~shachaf@ip24.67-202-82.static.steadfastdns.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo
14:41:56 <lambdabot> off"]} rest:"off"
14:42:10 <xil> I'm going to step away to read up on Set and split. Haven't because I've been here
14:42:13 <dmwit> Ah. I see that now.
14:42:24 <rwbarton> He is probably implementing nearest-neighor point search or something.
14:42:28 <cl1> > let (_,xs) = break (<6) [0..11] in map (+1) xs
14:42:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12]
14:42:37 <Mongey> when I'm printing out stuff, it's always wrapped in quotes, it there a way to stop that ?
14:42:51 <cl1> wtf?
14:43:00 <dmwit> Mongey: Use putStrLn instead of print when printing Strings.
14:43:11 <dmwit> cl1: Perhaps you meant span instead of break?
14:43:17 <cl1> > let (_,xs) = break (>6) [0..11] in map (+1) xs
14:43:18 <lambdabot>   [8,9,10,11,12]
14:43:25 <cl1> there had my < and > mixed up
14:44:11 <cl1> xil: let (_,xs) = break (>6) [0..11] in map (+1) xs
14:44:12 <shachaf> kmc recently suggested that I'm going to get burnt out by #haskell, just like he did.
14:44:54 <astor> found it http://tab.snarc.org/posts/haskell/2011-11-15-lookup-tables.html
14:45:00 <shachaf> Maybe I should use the ddarius technique of ignoring any questions I don't like.
14:45:06 <cmccann> burnt out in what sense?
14:46:35 <rwbarton> cmccann: shachaf doesn't like your question.
14:46:41 <cmccann> apparently!
14:46:49 <shachaf> Exactly! It works so well.
14:47:10 <shachaf> Actually I don't know the answer, really. I'm not the one who used that phrase.
14:47:20 <ryanfairchild> can anyone recommend an editor for OSX?
14:47:20 <shachaf> But I have been getting a lot more annoyed by #haskell recently.
14:47:41 <shachaf> Anyway, that's a #-blah topic or something.
14:47:53 <shachaf> Of course #-blah is just as bad, in a different way.
14:47:59 <cmccann> shachaf, as a rule of thumb IRC is one of the least productive things anyone can do with their time, if you don't enjoy it there's no reason to be here at all
14:48:05 <shachaf> ryanfairchild: What editor do you normally use?
14:48:21 <shachaf> There's no real reason to use a special one for Haskell.
14:48:25 <ryanfairchild> im using TextMate right now, but it seems limited for haskell
14:48:44 <shachaf> TextMate is probably fine.
14:48:47 <shachaf> What's wrong with it?
14:49:00 <ryanfairchild> there was an editor a friend of mine was using that allow for continuous type checking that was sort of nice
14:49:28 <ryanfairchild> allowed*
14:49:29 <cmccann> ryanfairchild, I use simpleminded code editors for Haskell on every OS, it works okay
14:49:40 <shachaf> It's sort of nice, but probably not worth worrying about.
14:49:57 <cmccann> GHCi in a terminal window alongside SciTE, Notepad++, or Smultron
14:50:33 <ryanfairchild> yeah GHCI and TextMate is my current setup, just wasn't sure if there is a defacto editor everyone in the haskell world prefers
14:50:38 <parcs`> how is irc one of the least productive things one can do?
14:50:48 <parcs`> how do you even gauge productivity?
14:51:11 <Axman6> ryanfairchild: i use textmate, and it works fine for haskell
14:51:30 <shachaf> parcs`: If you weren't talking over IRC, I would say that you just discovered an activity even less productive than cmccann's claim.
14:51:31 <ryanfairchild> alright well ill put my curiosity to rest for now :P
14:53:01 <parcs`> anyway who cares if you're not doing anything "productive"; enjoy yourself
14:54:01 <Philippa> shachaf: I find taking holidays and being picky with myself about when I get nasty about stuff but less so about how nasty helps
14:59:05 * hackagebot osm-download 0.1.1 - Download Open Street Map tiles  http://hackage.haskell.org/package/osm-download-0.1.1 (ThomasDuBuisson)
15:26:04 * gwern ponders how to implement hypertime in haskell http://qntm.org/hypertime 
15:29:22 <hpaste> drull95 pasted “i'm really stuck” at http://hpaste.org/56276
15:30:10 <shachaf> drull95: What's the point of asking for help with an online challenge problem?
15:30:25 <companion_cube> sounds fun, geekosaur
15:30:28 <companion_cube> gwern*
15:30:35 <companion_cube> awwwwwww tab-completion fail
15:30:38 <drull95> i really don't get where i'm going wrong with it
15:31:03 <gwern> companion_cube: it is, but I suspect the model will suddenly blow up at some point and I'll wrack my brains trying to understand it
15:31:08 <gwern> companion_cube: so far: universe1 = iterate (+1) 0; universeSheet succ seed = iterate succ seed; start = universeSheet tail universe1; map (take 5) $ take 5 $ start ~> [[0,1,2,3,4],[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8]]
15:31:59 <companion_cube> if you remove the continuum of universes and replace it by an enumeration, mayhaps
15:32:50 <gwern> companion_cube: well, of course. the continuum is an abstraction which doesn't seem to exist. quantised universe
15:36:54 <drull95> ah screw it, wasted all fucking day on it
15:41:22 * geekosaur notes, btb, that Larry Niven may already have done this; some stories in the Svetz cycle work out kinda like that description
15:42:31 <geekosaur> (well, probably didnt do the math part, but the original fiction part :)
15:47:36 <monochrom> there are books on how to express common algorithms in Haskell or similar languages
15:47:53 <gwern> (this is no common algorithm)
15:48:24 * mike-burns watches
15:48:26 <monochrom> I mean algorithms for SPOJ problem etc are common
15:48:57 <dmwit> I don't understand the hypertime link.
15:49:25 <dmwit> Why would there be 10-year stacks?
15:49:33 <Cody_> I computed the factorial of a 100 and stored it in a []. How do I compute how many numbers it has?
15:49:44 <mike-burns> length?
15:49:49 <Cody_> Yes
15:49:53 <dmwit> One of the postulates of the article is that all the lines are identical. That seems in contradiction to the conclusion that ten years later, there are different lines.
15:49:54 <monochrom> how many "number"s? how many "digit"s?
15:49:54 <Cody_> Well no
15:49:59 <Cody_> Length will return 1
15:50:07 <mike-burns> length . show  ?
15:50:15 <Cody_> Digits to be more specific
15:50:16 <dmwit> Why would you store the factorial of 100 in a list?
15:50:22 <byorgey> Cody_: if you use 'show' it will turn it into a String, which is a list of Chars
15:50:25 <byorgey> you can use length on that
15:50:30 <Cody_> To see how many digits it has?
15:50:33 <byorgey> > show 1234
15:50:34 <lambdabot>   "1234"
15:50:36 <dmwit> s/Why would you/Why did you/
15:50:39 <monochrom> > length (show 31549)
15:50:40 <lambdabot>   5
15:50:40 <byorgey> > length (show 1234)
15:50:41 <lambdabot>   4
15:50:44 <byorgey> yep
15:50:50 <Cody_> Curious?
15:51:13 <mike-burns> I think they mean: if calling length produces 1, then why did you put it in a list at all?
15:51:42 <Cody_> I figured a list would be the best way to count em.
15:51:58 <mike-burns> How many factorials of 100 do you have?
15:52:04 <dmwit> heh
15:52:18 <mjrosenb> Cody_: if you put fact 100 into a list, you will have a list with a single element in it, the factorial of 100.
15:53:31 <monochrom> length [23948334] is 1 because 2 is reserved for length [23948334, 948394] and 3 is reserved for length [23948334, 948394, 314159], etc
15:53:40 <mike-burns> If all you ever do to your list is call `head', you have the wrong data structure.
15:54:11 <Cody__> Sorry computer froze
15:54:14 <mike-burns> If all you ever do to your list is call `head', you have the wrong data structure.
15:54:25 <monochrom> length [23948334] is 1 because 2 is reserved for length [23948334, 948394] and 3 is reserved for length [23948334, 948394, 314159], etc
15:54:28 <Cody__> Anyway it'd be (length . show . factorial) 100
15:54:32 <Cody__> Will return 158
15:54:38 <Cody__> So it works
15:54:51 <mike-burns> OK, no list involved (well, you know).
15:55:06 <Cody__> mike-burns: I know
15:55:26 <monochrom> @quote monochrom length
15:55:26 <lambdabot> No quotes match. Maybe you made a typo?
15:55:39 <shachaf> until (\(x,y) -> x == 0) (\(x,y) -> (x `div` 10, y + 1))
15:55:52 * monochrom had a quote that said 99% of Project Euler problems can be solved by length . show
15:55:58 <mike-burns> Hah.
15:56:20 <monochrom> shows you how much numerology is there
15:56:53 <Cody__> Did you know that the factorial of 100,000 has 456,574 digits
15:56:54 <shachaf> > (length . show . replicate 158249) 'c'
15:56:55 <lambdabot>   158251
15:57:43 <Cody__> Is the factorial of a number x and how many digits it has exponential?
15:57:58 <rwbarton> > 100000 * (log 100000 - 1) / log 10
15:57:59 <lambdabot>   456570.5518096748
15:58:59 <rwbarton> > (100000 * (log 100000 - 1) + log (sqrt $ 2 * pi * 100000)) / log 10
15:59:00 <lambdabot>   456573.450899609
15:59:17 <rwbarton> > exp (100000 * (log 100000 - 1) + log (sqrt $ 2 * pi * 100000))
15:59:18 <lambdabot>   Infinity
15:59:21 <rwbarton> oh right
15:59:24 <rwbarton> > exp (100000 * (log 100000 - 1) + log (sqrt $ 2 * pi * 100000)) :: CReal
15:59:28 <lambdabot>   mueval-core: Time limit exceeded
16:00:22 <rwbarton> Cody__: the number of digits is roughly x * log_10(x)
16:01:04 <Cody__> Might come in handy someday
16:01:17 <mike-burns> Er, sure.
16:01:19 <NemesisD> anyone know of any good tutorials to get me started with attoparec having no experience with parsec?
16:02:45 <mike-burns> NemesisD: Not at all, and I've no experience with it, but the aeson package makes it look easy.
16:03:03 <xil> is parsec relatively slow? Like if I have pretty straightforward input that I need to parse, am I better doing it by hand than with parsec?
16:03:51 <xil> my program is running rather slow for the algorithm and I'm just wondering if parsec is a potential source of the problem, or if it's practically as efficient as if I did it by hand
16:04:01 <shachaf> Why don't you profile it and see?
16:04:07 <xil> don't know how
16:04:26 <mike-burns> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/profiling.html
16:04:49 <mike-burns> Also: http://hackage.haskell.org/package/criterion-0.6.0.0
16:07:27 <NemesisD> its a shame theres no longform documentation for attoparsec
16:07:38 <NemesisD> i guess they just assume you've been using parsec for years and know what you're doing
16:08:08 <mike-burns> Most Haskell docs are like that. Submit a pull request?
16:08:19 <NemesisD> with what?
16:08:21 <xil> does anyone know the profiler package for parsec?
16:08:35 <mike-burns> NemesisD: With the docs you can write after you figure out how to use it.
16:09:34 <NemesisD> lol. something seems backwards about it doesn't it. starting with the problem of not knowing attoparsec, the end is writing documentation for it. the middle is a lot of handwaving
16:09:34 <monochrom> lazily write docs
16:10:06 <monochrom> all great phd theses work like that :)
16:10:41 <monochrom> both of Einstein's relativities too, I dare say
16:10:43 <xil> does parsec even have a profiler package?
16:11:09 <monochrom> yes. in principle all packages have profiler packages
16:11:18 <xil> ghc is complaining that it can't find parsec's
16:11:29 <hpaste> Cody pasted “Help” at http://hpaste.org/56277
16:11:35 <xil> the profiling library*
16:11:41 <monochrom> if you built parsec yourself, you could have built with profiling turned on or off.
16:11:44 <Cody__> Can someone look at my hpaste?
16:11:51 <xil> I used cabal to install it. That's all I know
16:11:53 <sshine> xil, I think it depends on the amount of backtracking your parsers end up having.
16:11:54 <xil> cabal install parsec
16:12:18 <monochrom> then you will have to rebuild it with profiling turned on
16:12:35 <xil> do you know how to do that, monochrom?
16:12:50 <monochrom> and it depends on mtl, so you will rebuild mtl with profiling turned on, too
16:12:58 <mike-burns> Cody__: I feel that `my_filter' would look better with a guard.
16:13:11 <Cody__> Haven't gotten there yet
16:13:11 <xil> what's mtl?
16:13:15 <mike-burns> Ah.
16:13:18 <sshine> monad transformer library
16:13:20 <Cody__> So don't confuse me even more lol
16:13:20 <monochrom> a package used by parsec
16:13:43 <mike-burns> Cody__: "If the predicate is true then cons x onto the recursion; else, recur." --- is how I'd say it.
16:13:53 <xil> okay thanks. Do I only need the -p flag on cabal to install with profiling, or is there anything else I'll need?
16:14:08 <Cody__> Where "cons" you mean add to the beginning of the list?
16:14:12 <mike-burns> Yes.
16:14:20 <mike-burns> I mean what (:) does.
16:14:23 <monochrom> edit one line in ~/.cabal/config (you will see which line), then cabal install --reinstall mtl parsec
16:14:24 <Cody__> I know
16:14:34 <sshine> (:) is the turtle operator.
16:14:45 <mike-burns> OK, so turtle x onto the recursion.
16:15:08 <monochrom> you shall not rely upon yourself on remembering to add "-p" in the future
16:15:21 <Cody__> But, if you add 6 back on to it again, wouldn't it just be the same list? So does are you talking about a different list?
16:15:31 <Cody__> *are*
16:15:41 <mike-burns> Cody__: I'm talking about xs, which is different from (x:xs) .
16:15:43 <monochrom> cabal defaults are essentially for xmonad end-users, i.e., no use for docs, no use for profiling, no use for anything
16:16:09 <mikeplus64> is there a map with the arguments flipped included in Prelude? I forget
16:16:22 <sshine> mikeplus64, (flip map)? :P
16:16:35 <mike-burns> @hoogle [a] -> (a -> b) -> [b]
16:16:36 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
16:16:36 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
16:16:36 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
16:16:43 <Ke> end users do need docs for xmonad
16:16:44 <Axman6> mikeplus64: no, there's only mapM <=> forM
16:16:47 <Cody__> mike-burns: So xs is the new list. Not to be confused with the given list of (x:xs)
16:16:59 <mike-burns> Cody__: xs is the tail of (x:xs).
16:17:06 <mikeplus64> sshine: I thought there was a special name for it other than that, looks like I'm wrong
16:17:12 <mikeplus64> Axman6: ok
16:17:20 <mike-burns> Cody__: When naturally recurring over a list, you recur on the tail.
16:17:26 <Axman6> > let f (x:xs) = (x,xs) in f [1,2,3]
16:17:26 <Cody__> Ok
16:17:27 <lambdabot>   (1,[2,3])
16:17:56 <xil> monochrom: got mtl, but parsec fails. There are a bunch of errors about functions having more call patterns than the limit. In some cases the limit is 0 and they have 1 call patters and in others the limit is 1 and there are 3
16:18:17 <Cody__> I am confused. When you want to do something like this in Java, you would += the elements that satisfy the predicate into a new list? I don't see a new list here, that's why I am confused (and still am).
16:18:21 <jeff_s_> xil: I've seen those errors, but they never caused the build to fail.
16:18:24 <monochrom> errors? irrecoverable errors? or just warnings?
16:19:03 <monochrom> Cody, we have immutable lists, there is no +=
16:19:19 <mike-burns> Cody__: When you want to do this algorithm in Java, it works without += .
16:19:25 <monochrom> and also there is no new list
16:19:29 <Cody__> What?
16:19:38 <xil> http://pastebin.com/k72wLNKM
16:19:45 <mauke> The paste k72wLNKM has been copied to http://hpaste.org/56278
16:20:14 <Cody__> mike-burns: I'd just use an arraylist and compare each element in a for loop
16:20:25 <mike-burns> Cody__: That's not this algorithm, though. That's a different algorithm.
16:20:29 <Eduard_Munteanu> Cody__: conceptually x:xs gives you a new list
16:20:44 <erus`> a = b; b = a     -- what is the type of a?
16:20:59 <Axman6> a
16:21:09 <Axman6> :t let a = b; b = a in a
16:21:10 <lambdabot> forall t. t
16:21:22 <monochrom> xil: then you need cabal install --reinstall deepseq too, to get profiling for deepseq
16:21:27 <erus`> ah just a generic type
16:21:29 <erus`> ok cheers
16:21:56 <xil> monochrom: ah right. I installed that too. Thanks. I really appreciate the help. I'm really frazzled right now trying to make this all happen
16:22:43 <Cody__> The way I was taught to do this in Java was to have two lists. One being compared and the other that stored the elements are being compared. I don't see that here and that's why I'm confused. I don't get how you (x:xs) can give you a new list that is different from xs without getting an error because the have the same "name"... <\confused rant>
16:22:53 <Axman6> :t let a = b; b = c; c = d; d = e; e = f; f = a in a
16:22:54 <lambdabot> forall t. t
16:22:56 <monochrom> it may be less haste more speed to completely reinstall all cabal-installed packages with profiling on
16:23:03 <mike-burns> Cody__: http://pastie.org/3151708
16:23:18 <mike-burns> That's how you write this algorithm in Java, using the list data structure.
16:23:27 <shachaf> Cody__: I recommend to stop thinking about Java.
16:23:30 <monochrom> Cody, perhaps you should not bring in java experience
16:23:30 <mike-burns> I cheated in parts, but you know. I haven't written Java.
16:23:53 <xil> monochrom: is there a command that will do that?
16:24:00 <Cody__> It's hard to unthink the way I was taught to solve programming problems.
16:24:02 <monochrom> unfortunately no
16:24:06 <Eduard_Munteanu> Cody__: if you keep a reference to 'xs' it will look the same no matter whether you cons 'x' to it somewhere else.
16:24:26 <Eduard_Munteanu> Or take a Map for example, maybe that's less obvious.
16:24:31 <Axman6> Cody__: you were taught to solve programming problems in a way that causes more problems though ;)
16:24:53 <mike-burns> Cody__: You can't blame us that you were never taught this in Java.
16:24:57 <Cody__> ...In this language
16:25:01 <xil> monochrom: I'm still getting those messages about call patterns. Is it okay or does it mean there's probably another missing profiling library?
16:25:07 <Cody__> mike-burns: I am most certainly not
16:25:31 <monochrom> I wouldn't say java or imperative programming is harmful. but I say the idea of "all programming languages are similar" is harmful and impractical and unreal
16:25:51 <Eduard_Munteanu> > let xs = [1,2,3] in (0:xs, 1:xs)
16:25:53 <lambdabot>   ([0,1,2,3],[1,1,2,3])
16:25:56 <monochrom> xil, those call pattern warnings are the optimizer being chatty, that's all
16:26:12 <mike-burns> I claim the opposite: calling this a "Haskell solution" and that a "Java solution" misses the fact that they are merely different algorithms. You can write either algorithm in either languages.
16:26:30 <mike-burns> Not only are they different algorithms, they're different data structures.
16:26:41 <xil> Cody__: I had similar trouble when coming from Java to Haskell. In time, and by looking at the examples that people here gave me, I started to understand the different way of looking at functional programming. You just do things differently in functional languages than imperative ones
16:27:13 <xil> monochrom: thanks!!! It worked =]
16:27:15 <Cody__> xil: It's like learning to write lefty when your a righty
16:27:28 <xil> Cody__: it's like learning to write with your ears*
16:27:38 <Cody__> ^too true
16:27:49 <monochrom> it's also like an Englishman learning Japanese. do you know what Japanese looks like?
16:28:00 <Cody__> Like chinese
16:28:09 <monochrom> not even close
16:28:20 <Eduard_Munteanu> Heh, interesting analogy it seems.
16:28:20 <Cody__> Whatever, it was a bad joke
16:28:36 <monochrom> Japanese uses the "subject object verb" order for the most part. RPN if you like.
16:28:51 <monochrom> (Chinese doesn't)
16:29:02 <mike-burns> Cody__: Anyway, if you can read Java better, this is what the Haskell is doing: ________________________________
16:29:04 <mike-burns> \setbeamercolor{normal text}{bg=white}
16:29:07 <mike-burns> Whoa.
16:29:10 <mike-burns> http://pastie.org/3151708
16:29:15 <mike-burns> Awkward.
16:29:23 <irene-knapp> haha
16:29:49 <mike-burns> I meant the pastie link, not the LyX.
16:30:10 <mike-burns> Oh yeah: hey Boston, I'll be talking about Haskell tomorrow: http://fsug.org/
16:30:18 <monochrom> oh mike-burns, I have an even better one, how to translate Haskell to Java: http://www.vex.net/~trebla/humour/Nightmare.java
16:31:39 <Cody__> Just a visual skim over both of your examples in Java. I can see why Haskell is more efficient (LOC) for this sort of stuff
16:33:08 <mike-burns> monochrom: Hah, that looks just like the Java I wrote when I did Android apps ... before I found Scala.
16:33:41 <mike-burns> monochrom: Oh, is that TCO?
16:34:04 <monochrom> I think so
16:34:22 <mike-burns> Cody__: It's just that the list data structure is very convenient in Haskell, whereas the array data structure is more convenient in Java.
16:34:34 <mike-burns> So we use lists a bunch, where Java uses arrays.
16:34:35 <Cody__> when it writes => then x : my_filter p xs => Is it adding (cons) x to a separate list? I understand the else
16:34:49 <mike-burns> It's building a new list, yes.
16:34:54 <Cody__> There we go
16:35:01 <Cody__> Like on the side?
16:35:06 <mike-burns> In memory.
16:35:12 <monochrom> I did not think of TCO, but apparently I accidentally TCO'ed it :)
16:35:29 <mike-burns> monochrom: I assume that's what the try/catch is for!
16:35:44 <Cody__> So "x :
16:35:50 <Cody__> is adding to a new list
16:35:56 <monochrom> I only intended catch for pattern-matching!
16:36:02 <mike-burns> Oooh.
16:36:02 <Cody__> and " my_filter p xs" is calling the fuction again
16:36:20 <mike-burns> Cody__: Yes. And `my_filter p xs' produces a new list.
16:36:34 <mike-burns> monochrom: I love it.
16:36:46 <rwbarton> (it doesn't really "add to a new list", it just makes a new list.)
16:36:56 <Cody__> x : my_filter p xs => Left side of cons: add x to a new list. Right side of cons: Call the function again.
16:36:57 <Cody__> no?
16:37:00 <monochrom> but yes, if catch also unwinds stack, then I get TCO as a benefit
16:37:41 <monochrom> anyway, "x:xs" mutates xs as much as "m+n" mutates n. (i.e., not at all)
16:37:44 <mike-burns> monochrom: There was something a few years back about exceptions and TCO in Java, and I figured this was it. This might be it.
16:38:17 <mike-burns> 1 : filter (< 10) [2,3,4,11]
16:38:19 <mike-burns> > 1 : filter (< 10) [2,3,4,11]
16:38:20 <lambdabot>   [1,2,3,4]
16:38:26 <mike-burns> It's doing that.
16:38:35 <Cody__> Only because filter returns a list
16:38:38 <Cody__> :t filter
16:38:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:38:58 <mike-burns> Yup.
16:39:02 <mike-burns> Same with `my_filter'.
16:39:24 <jeff_s_> I spent all day half-thinking about some code I was going to write, its type, and how I should make it an instance of Applicative. Finally I realized that I was overanalyzing it, and I'm just reinventing Monad Maybe.
16:39:35 <mike-burns> I love doing that.
16:39:58 <xil> in the profiler, the %time for everything is 0.0. It only ran for 20ms, so is that why?
16:41:02 <beefcube> i've installed a number of packages with a user local cabal (xmonad*, xmobar*) but cabal doesn't seem to handle their man pages and the manpath? what is the best way to handle that?
16:41:37 <monochrom> xmonad has a man page? anyway, manually
16:41:40 <jeff_s_> beefcube: I know that to get html documentation, I have to turn on an option in my .cabal file. Is that perhaps what you have to do?
16:41:56 <beefcube> that would work
16:42:26 <hpaste> drull95 pasted “help with syntax” at http://hpaste.org/56280
16:42:26 <beefcube> but i like the versatility of man pages on unix :/
16:42:39 <mike-burns> Yeah.
16:42:51 <monochrom> cabal tries not to be unix-specific
16:43:03 <mike-burns> drull95: Is there an error message?
16:43:39 <jeff_s_> I found that cabal (or haddock, I suppose) doesn't seem to handle paths in WIndows in the HTML documentation.
16:43:44 <hpaste> drull95 annotated “help with syntax” with “help with syntax (annotation)” at http://hpaste.org/56280#a56281
16:44:51 <mike-burns> drull95: Ah, I see it. It might be instructive for you to add explicit types to addPerson and updateTimes.
16:45:05 <mike-burns> Oh, maybe I don't see it.
16:45:07 <mike-burns> :t foldl'
16:45:08 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:45:12 <Eduard_Munteanu> drull95: (.) will only take care of one argument
16:45:57 <Eduard_Munteanu> @pl \(m,i) c -> addPerson $ updateTimes (m,i) c
16:45:57 <lambdabot> uncurry ((((addPerson .) . updateTimes) .) . (,))
16:46:09 <drull95> ah, thanks
16:46:19 <Eduard_Munteanu> I don't mean you should use that ^^
16:46:27 <drull95> i remember one time i saw code with seven composes in a row
16:46:38 <Eduard_Munteanu> @unpl addPerson . updateTimes
16:46:39 <lambdabot> (\ c -> addPerson (updateTimes c))
16:47:20 <Eduard_Munteanu> @pl \t c -> addPerson $ updateTimes t c
16:47:20 <lambdabot> (addPerson .) . updateTimes
16:47:52 <rwbarton> @unpl uncurry ((((addPerson .) . updateTimes) .) . (,))
16:47:52 <lambdabot> uncurry (\ e k n -> addPerson (updateTimes (((,)) e k) n))
16:47:57 <Eduard_Munteanu> That's more like it, but I don't think you should use that either.
16:50:33 <drull95> ok i get (addPerson .) . updateTimes -> updateTimes is applied to one arg and then the expr becomes addPerson . (updateTimes (m,i))
16:51:12 <drull95> that takes a bit of practice :)
17:14:00 <Jafet> @pl \x y -> f (g x y)
17:14:00 <lambdabot> (f .) . g
17:14:05 <Jafet> @pl \x y z -> f (g x y z)
17:14:05 <lambdabot> ((f .) .) . g
17:14:16 <Jafet> @pl \x y z -> f (g x (h y z))
17:14:17 <lambdabot> ((f .) .) . (. h) . (.) . g
17:17:32 <jeff_s_> I keep seeing the type ((->) r) in the Prelude, for example it is an instance of Monad. My best guess is that ((->) r) is a function that only has its input value bound. Is that right? What is an example of a use of the type ((->) r)?
17:17:50 <jeff_s_> er, by input value bound, I mean its type
17:17:58 <cmccann> jeff_s_, yes
17:18:13 <cmccann> also, it's the reader monad
17:18:40 <augur_> scott encoding is cool
17:18:44 <jeff_s_> That confuses me, because I would think that a reader would have its output type bound, not its input.
17:18:58 <Jafet> Yes. So the input type is free.
17:19:11 <Jafet> Remember that the type parameter isn't written.
17:19:13 <cmccann> jeff_s_, the "input" is the "environment" for the reader
17:19:27 <cmccann> i.e. Reader e a = (e -> a)
17:20:18 <jeff_s_> Oh, is this a case of monomorphism, or something like that, where once a function with type ((->) r) is used with an actual output value, its output type is fixed?
17:20:24 <Jafet> instance Monad ((->) r); the monad is over (r -> s) for all s
17:20:33 <Jafet> Just as instance Monad []; the monad is over ([] a)
17:21:21 <jeff_s_> Thanks, I think I understand it better.
17:21:46 <jeff_s_> Haskell is WEIRD! (but cool)
17:22:06 <rwbarton> ((->) r) isn't really a "type", or at least not the kind of type that has values.
17:22:22 <rwbarton> It's like Maybe or [].
17:22:39 <Jafet> Maybe is a type
17:22:50 <rwbarton> The terminology here is poor.
17:22:54 <shachaf> Maybe is, maybe isn't. We just don't know.
17:22:55 <rwbarton> But I clarified what I mean.
17:22:55 <rwbarton> t
17:22:56 <rwbarton> .
17:23:15 <shachaf> It's a good thing you clarified what you mean.t.
17:23:33 <rwbarton> "function with type ((->) r)" doesn't make sense.
17:24:23 <Jafet> ./jeff_s -XExplicitForAll
17:25:27 <shachaf> You want to execute jeff_s?
17:25:56 <Jafet> That is the only way to evaluate him, right?
17:26:23 <jeff_s_> Someone had jeff_s a long time ago, maybe I can use it now.
17:26:32 <jeff_s_> nope, it won't let me.
17:26:53 <shachaf> Jeff Sheltren is still around.
17:27:04 <shachaf> I guess that was the reasoning for the execution.
17:28:47 <Jafet> In Soviet Russia, State executes you
17:29:08 * hackagebot total-map 0.0.0 - Finitely represented /total/ maps  http://hackage.haskell.org/package/total-map-0.0.0 (ConalElliott)
17:29:29 <shachaf> @remember Jafet In Soviet Russia, State executes you
17:29:29 <lambdabot> I will remember.
17:31:06 <conal> There. I finally worked out and released the TMap type described in the TCM paper (http://conal.net/papers/type-class-morphisms/).
17:31:42 <Eduard_Munteanu> Hah.
17:31:45 <shachaf> conal++
17:31:49 <conal> :D
17:31:59 <jmcarthur> :D
17:32:37 <conal> I especially like how the meanings of the Functor, Applicative, Monad & Monoid instances are entirely determined by semantic TCM principle.
17:32:38 <xil> well I pretty much give up. I chock this up to me not knowing Haskell well enough to have chosen to use it for this
17:33:07 <shachaf> Hmm, I still haven't read that paper.
17:33:22 <shachaf> Although I've seen the TMap type described elsewhere, at least.
17:33:31 <conal> "As the State is a soulless machine, it can never be weaned from violence to which it owes its very existence." - Mohandas K. Gandhi
17:34:08 * hackagebot oi 0.0.3 - Purely Functional Lazy Interaction with the outer world  http://hackage.haskell.org/package/oi-0.0.3 (NobuoYamashita)
17:34:16 <conal> oh -- hm!
17:34:34 <shachaf> http://hackage.haskell.org/package/NonEmpty -- "Library providing a non-empty list datatype, and total functions operating on it"
17:34:36 <jmcarthur> conal: the trim function... might it make more sense to just not add mappings to the default value in the first place?
17:34:43 <shachaf> Total functions like length'
17:34:55 <jmcarthur> like the insert function would do a check first or something?
17:35:08 <conal> jmcarthur: it's for use after fmap, <*>, and join
17:35:28 <conal> jmcarthur: and i couldn't put it into those methods, since it requires Eq.
17:35:34 <jmcarthur> ah. i see
17:35:39 <conal> jmcarthur: Eq on the *value* type, that is.
17:35:45 <conal> yeah. drag. :p
17:35:47 <jmcarthur> that's a shame, but at least it doesn't affect semantics
17:35:49 <jeff_s_> I feel like there is some built-in functionality that I'm overlooking, or I'm overlooking this. Is there an easy or Prelude way of composing functions :: a -> Bool? Sort of like in this hpaste I'm about to post.
17:35:52 <hpaste> Jeff pasted “What am I missing?” at http://hpaste.org/56284
17:36:24 <jeff_s_> What I wrote works, but it feels clumsy.
17:36:32 <Jafet> @pl \x fs -> and ($x) fs
17:36:32 <lambdabot> and . flip id
17:36:44 <Jafet> Er
17:36:48 <Jafet> @pl \x fs -> all ($x) fs
17:36:48 <lambdabot> all . flip id
17:37:22 <shachaf> conal: What does TMap do about traversal?
17:37:31 <conal> shachaf: traversal?
17:37:43 <jeff_s_> My Lord Jafet, that is a pretty function.
17:37:52 <jeff_s_> add a comma there if you like
17:38:09 <shachaf> conal: As in M.toList, or something.
17:38:25 <Jafet> Yes indeed, a pretty fun, ction
17:38:33 <mike-burns> and' f1 f2 = foldr True $ [f1,f2] <*> [x]  -- maybe this?
17:38:35 <jeff_s_> Ugh.
17:38:39 * shachaf 's computer just hard-rebooted for no reason.
17:38:39 <conal> shachaf: such a thing would be an abstraction leak, i.e., not explainable via the semantic function.
17:39:01 <shachaf> conal: Right, which is why I was wondering. :-)
17:39:12 <shachaf> Despite being an abstraction leak it seems like a very useful operation.
17:39:26 <jmcarthur> well, it's explainable with the restriction of an enumerable domain at least
17:39:27 <shachaf> Maybe if only for Bounded,Enum types or something.
17:39:44 <jeff_s_> So Jafet, that works great when I'm just doing conjunctions, but what if I want to do conjunctions and disjunctions? When I was thinking monadically with readers, I was thiinking I wanted to do things like "f1 >> (f2 `mplus` f3) >> f4".
17:39:51 <conal> shachaf: i'm curious whether such representation-oriented operations can be avoided w/o loss of usefulness.
17:40:30 <conal> shachaf: i.e., whether the uses that motivate abstraction leaks can be handled in semantically sound ways.
17:40:37 <jmcarthur> the ability to use Data.Set to sort some data is pretty useful :\
17:40:45 <Jafet> > (mconcat . map (All.)) [even, (>1), (<5)] 4
17:40:47 <lambdabot>   All {getAll = True}
17:40:49 <jmcarthur> *sort and uniquify
17:40:55 <jeff_s_> I was thinking I was going to use the "ask" function if the Reader to get the input value, but then Bool isn't an instance of Monad.
17:41:03 <Jafet> > (mconcat . map (Any.)) [odd, (>4), (<1)] 4
17:41:05 <lambdabot>   Any {getAny = False}
17:42:01 <shachaf> jeff_s_: You seem confused.
17:43:06 <conal> I've liked that Gandhi quote (above) about the State & violence for a long time. Funny how it also applies to imperative programming.
17:43:32 <shachaf> @ty and .: sequence
17:43:33 <lambdabot> forall (g :: * -> *). (Monad g, Functor g) => [g Bool] -> g Bool
17:44:02 <xil> what's a function like take but which also returns the remaining list?
17:44:08 <shachaf> > (and .: sequence) [even, (>5)] 6
17:44:09 <lambdabot>   True
17:44:10 <shachaf> > (and .: sequence) [even, (>5)] 4
17:44:12 <lambdabot>   False
17:44:20 <Jafet> :t splitAt
17:44:20 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:44:26 <shachaf> span and break
17:44:32 <shachaf> Oh, that's takeWhile.
17:44:47 <xil> thanks
17:46:59 <jmcarthur> conal: a function that would be awesome to have as a primitive, but i have doubts that the Data.Map interface enables the most efficient implementation for it:  adjust :: Ord k => (a -> a) -> k -> TMap k a -> TMap k a
17:47:56 <jmcarthur> hmm... actually...
17:48:12 <jeff_s_> shachaf: I feel confused!
17:48:13 <jmcarthur> i think Data.Map.alter would probably be sufficient
17:48:22 <ion> > ala (All .) Data.Foldable.foldMap [even, (>5)] 6  -- Could this Newtype instance be added, i wonder?
17:48:23 <lambdabot>   No instance for (Control.Newtype.Newtype
17:48:23 <lambdabot>                     (a -> Data.Mon...
17:48:47 <ion> @type ala (All .) Data.Foldable.foldMap [even, (>5)]
17:48:48 <lambdabot> forall a. (Newtype (a -> All) (a -> Bool), Integral a) => a -> Bool
17:49:21 <xil> is it possible that I could get parsec to stack overflow easily? By which I mean that I'm getting a stack overflow on a huge input and am wondering if the fact that I'm new to parsec could be why, or if it's more likely in the rest of my code
17:49:37 <jmcarthur> err... actually, i don't see how to insert a key-value pair
17:50:11 <jeff_s_> xil - I think left recursion could do it.
17:50:31 <xil> in parsec?
17:52:55 <jeff_s_> shachaf - where is (.:) from?
17:52:58 <jeff_s_> xil - yup
17:54:05 <mike-burns> (.:) is only defined in lambdabot.
17:54:18 <conal> jmcarthur: Data.Map has that function, so it'd be easy to add to Data.TotalMap
17:54:44 <Jafet> (.:) = (.) . (.) = \f g -> (f .) . g
17:54:58 <Jafet> = fmap fmap fmap
17:54:59 <Axman6> = \f g x y -> f (g x y)
17:55:02 <conal> jmcarthur: i'm missing your concern about the Map interface & efficiency
17:55:46 <conal> Jafet: is there something like (.:) for (.) . (.) . (.) , etc?
17:55:47 <jeff_s_> That's an interesting function.
17:56:03 <Jafet> conal: philosophically speaking?
17:56:12 <parcs`> it's defined in the 'functors' package too
17:56:19 <conal> Jafet: no. i mean defined.
17:56:23 <ion> djahandarie: instance (Newtype n o) => Newtype (a -> n) (a -> o) where { pack f = pack . f; unpack f = unpack . f } :-P
17:56:25 <jmcarthur> conal: well, Data.Map.adjust wouldn't be enough to implement that function for TMap since the sensible thing to do with TMap is if the key isn't in the Map then you should insert it with the value (f defaultValue)
17:56:42 <jeff_s_> parcs` - ah, thanks!
17:56:48 <parcs`> conal: the 'functors' package has some of those too
17:56:52 <djahandarie> ion, heh
17:56:53 <conal> jmcarthur: and that insertion would be efficient, right?
17:57:02 <conal> parcs`: ah. thx.
17:57:05 <Jafet> I don't even know where (.:) is defined
17:57:10 <ion> Requires UndecidableInstances.
17:57:24 <djahandarie> Yeah
17:57:37 <rwbarton> ion: You can make the arguments related by a Newtype also.
17:58:02 <jmcarthur> conal: well, a lookup followed by an insert has the same big-O as Data.Map.adjust of course, but using Data.Map.alter (which I originally forgot about) would save a search in the map
17:58:04 <conal> Jafet: btw, i try to discourage the "fmap fmap fmap" rendition, because it doesn't extend to any other number of (.) compositions, afaik.
17:58:49 <thlorenz> lets say I have data Point = Point Float Float
17:58:57 <conal> jmcarthur: ah.
17:58:57 <xil> jeff_s_: would the same problem apply to something like mapAccumL? I am using L because I thought that DOESN'T build up on the stack. Do I have that backwards?
17:59:01 <shachaf> Jafet: I suspect that it's in L.hs.
17:59:10 <shachaf> xil: You have it sideways.
17:59:10 <thlorenz> and the p = Point 1 2
17:59:19 <xil> shachaf: go on...=]
17:59:26 <ion> rwbarton: Hmm. I’m not sure i understand.
17:59:26 <thlorenz> how can I get to x and y (e.g. 1 and 2) of that point
17:59:33 <shachaf> It's not as simple as " x \"builds up on the stack\" and y doesn't".
17:59:35 <Axman6> thlorenz: pattern match
17:59:53 <shachaf> xil: mapAccumL is, in a very rough way, the counterpart to foldr, in terms of useful laziness behaviour.
17:59:59 <thlorenz> get it, so something like p.x is not the Haskell way
18:00:05 <Axman6> x (Point a _ ) = a
18:00:07 <xil> shachaf: I thought it'd be the counterpart to foldl
18:00:08 <shachaf> xil: But you shouldn't take it on faith. You should understand why.
18:00:09 <conal> Jafet: and i'm guessing a lot of people don't realize when they see "fmap fmap fmap" that it doesn't extend -- in contrast to "(.) . (.)" and "fmap . fmap".
18:00:14 <jmcarthur> thlorenz: foo (Point x y) = <use x and y here>
18:00:19 <rwbarton> instance (Newtype a a', Newtype b b') => Newtype (a -> b) (a' -> b') where ...
18:00:24 <thlorenz> thanks Axman6
18:00:47 <Axman6> thlorenz: you could define the type as a record too: data Point = Point {x,y :: Float}. then x :: Point -> Float
18:01:06 <shachaf> xil: Wait a minute, I was thinking of scanl.
18:01:10 <Jafet> conal: it was a caleskell joke
18:01:15 <shachaf> xil: OK, mapAccumL is a completely different story.
18:01:28 <conal> Jafet: ah.
18:01:32 <Jafet> (.:) isn't even supposed to use Functor
18:01:39 <shachaf> xil: I recommend looking at its definition and behaviour until you understand it.
18:01:39 <xil> shachaf: oh, so is mapAccumL safe if I don't want to risk a stack overflow from the mapping process?
18:01:43 * jeff_s_ just found the types All and Any.
18:01:54 <xil> shachaf: I would love to do that in an hour and 15 minutes, but I'm in a bit of a crunch until then
18:01:56 <thlorenz> Axman6: ok, but I guess most time you wanna do something with that Point, you would be able to pattern match or are there use cases for the record option?
18:01:58 <Eduard_Munteanu> :t (.:)
18:01:59 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
18:02:01 <shachaf> xil: Do you understand why map is defined in terms of foldr instead of foldl?
18:02:06 <shachaf> xil: What's the big hurry?
18:02:32 <xil> shachaf: codesprint, and I didn't know map was defined in terms of foldr
18:02:41 <Axman6> thlorenz: depends what's easiest for how you're using them. if you're just definint a Num instance, and using that to do everything, then there's not much point using records
18:03:14 <thlorenz> Axman6: thanks, that totally helped
18:04:28 <shachaf> xil: What's the point of asking in this channel for help in a competition?
18:04:36 <ion> rwbarton: I can’t see how to get that to work.
18:04:53 <thlorenz> nice to have a place where people help to point me away from my OO intuition ;)
18:05:11 <xil> shachaf: why not? It's about my understanding of haskell. Ultimately the competition doesn't care that I do it in Haskell, it cares about the algorithms, which I know and can produce
18:05:22 <Jafet> The best points are point-free.
18:05:47 <shachaf> xil: Then produce them in a language that you know well, and then work on the problems in Haskell without the time pressure.
18:05:52 <rwbarton> ion, I thought it would be something like "pack f = pack . f . unpack; unpack g = unpack . g . pack".
18:05:58 <xil> shachaf: Haskell is currently my best language
18:06:01 <Jafet> xil seems to not realize that irc is inherently a waste of time.
18:06:51 <BMeph> conal: Thanks for the quote; it's on twitter, now. :)
18:07:10 <conal> BMeph: :)
18:07:14 <shachaf> xil: Well then, it seems that you're in trouble, because understanding how laziness works is critical to implementing algorithms that work efficiently in Haskell.
18:07:26 * BMeph likes tweeting quotes of other people.
18:07:54 <Jafet> "retweeted from M.Gandhi"
18:08:14 <xil> shachaf: no argument there. But I can use Haskell fairly well in other respects. I'd love to better understand laziness in time, but that doesn't change my current predicament
18:08:26 <dmwit> bleh, stop attacking him, it's not helpful for either of you
18:08:36 <dmwit> That time could have been spent explaining laziness, for example.
18:09:14 <ion> rwbarton: The first problem is “Could not deduce (a ~ a') from the context (Newtype a a', Newtype b b'). Adding (a ~ a'), code that used to work fails due to an ambiguous type variable and i’m too tired to think further. :-)
18:09:14 <shachaf> dmwit: This isn't really meant to be an attack. I suppose the phrasing may have been a bit harsh.
18:09:18 <Jafet> Ideally; but shachaf isn't Cale.
18:09:52 <xil> I definitely agree there was a better way to go about my whole situation, 2 days ago. But I'm here now =/
18:10:50 <rwbarton> ion: Augh, now you're going to make me actually install this newtype package.
18:11:49 <djahandarie> rwbarton, it's the way of the future.
18:12:22 <shachaf> > mapAccumL (\acc x -> (acc ++ show x, x+1)) "init" [0,1,2,3,4]
18:12:23 <lambdabot>   ("init01234",[1,2,3,4,5])
18:12:24 <shachaf> > mapAccumR (\acc x -> (acc ++ show x, x+1)) "init" [0,1,2,3,4]
18:12:26 <lambdabot>   ("init43210",[1,2,3,4,5])
18:12:41 <NemesisD> any of you guys know anything about attoparsec
18:12:56 <ion> rwbarton: The piece of code i tested with: foo :: Bool; foo = ala (All .) F.foldMap [even, (>5)] 6. Have fun. :-)
18:12:58 <rwbarton> oh, ew, I didn't realize this functional dependency was here.
18:13:03 <shachaf> > mapAccumL (\acc x -> (acc ++ show x, x+length acc)) "init" [0,1,2,3,4]
18:13:05 <lambdabot>   ("init01234",[4,6,8,10,12])
18:13:06 <shachaf> > mapAccumR (\acc x -> (acc ++ show x, x+length acc)) "init" [0,1,2,3,4]
18:13:07 <lambdabot>   ("init43210",[8,8,8,8,8])
18:13:21 <djahandarie> rwbarton, instead of a type family, you mean?
18:13:30 <rwbarton> no, instead of nothing
18:13:55 <shachaf> xil: Look at that example and see if you can figure out laziness behaviour from it.
18:15:08 <xil> shachaf: well doesn't each one respectively "pass the accumulator" a different direction?
18:15:26 <xil> oh
18:15:35 <shachaf> xil: Let's say you want just the first element of the list, or just the first 5 characters of the accumulator.
18:15:44 <shachaf> How much computation do you have to do?
18:16:22 <shachaf> (Well, actually, laziness doesn't work here for the accumulator.)
18:16:29 <rwbarton> this library is a bit gross IMO
18:16:42 <djahandarie> You're talking to the maintainer, so suggestions are welcome :p
18:16:46 <shachaf> > mapAccumL (\acc x -> (show x ++ acc, x+length acc)) "init" [0,1,2,3,4]
18:16:48 <lambdabot>   ("43210init",[4,6,8,10,12])
18:16:48 <shachaf> > mapAccumR (\acc x -> (show x ++ acc, x+length acc)) "init" [0,1,2,3,4]
18:16:50 <lambdabot>   ("01234init",[8,8,8,8,8])
18:17:06 <shachaf> Er, that doens't make any difference.
18:17:10 <shachaf> Never mind, I'm just being silly.
18:17:13 <rwbarton> it seems to use a lot of phantom arguments
18:17:29 <parcs`> :t fmap fmap fmap fmap fmap fmap fmap fmap
18:17:30 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
18:17:54 <shachaf> xil: It occurs to me that I have no idea what you're actually trying to do.
18:18:24 <parcs`> it seems like three functors deep is the limit
18:18:47 <ion> [insert Inception reference]
18:18:55 <ion> [insert Xzibit reference]
18:19:41 <parcs`> anyone why that is?
18:19:48 <rwbarton> ion: OK, this library isn't for what I thought it was for
18:20:00 <djahandarie> It's just Isomorphism
18:20:03 <rwbarton> not really
18:20:04 <xil> shachaf: I've found a roundabout way of getting around using mapAccum(L|R) in the mean time. I'll come back after it's over and maybe then, in a more relaxed setting, y'all can help me understand laziness
18:20:15 <rwbarton> the functional dependency makes it not really that
18:20:24 <jeff_s_> What does @pl make haskellbot do? Or, where is the documentation?
18:20:34 <rwbarton> like, next I want to write   instance Newtype a a where pack = id; unpack = id
18:20:40 <Jafet> @help pl
18:20:41 <lambdabot> pointless <expr>. Play with pointfree code.
18:20:49 <jeff_s_> @help pl
18:20:53 <lambdabot> pointless <expr>. Play with pointfree code.
18:20:54 <jeff_s_> oh
18:21:11 <Eduard_Munteanu> @google haskell pointfree
18:21:16 <lambdabot> http://haskell.org/haskellwiki/Pointfree
18:21:16 <lambdabot> Title: Pointfree - HaskellWiki
18:21:42 <Jafet> @hackage pointfree
18:21:44 <lambdabot> http://hackage.haskell.org/package/pointfree
18:21:46 <jeff_s_> I see a lot of room for abuse in this direction.
18:22:00 <rwbarton> it's choosing a specific type that each type is isomorphic to, rather than just expressing the notion that two types are isomorphic
18:22:34 <parcs`> :t [flip flip flip flip flip, flip flip flip flip flip flip, flip flip flip flip flip flip flip]
18:22:46 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => [f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1]
18:22:47 <shachaf> parcs`: You killed lambdabot. :-(
18:22:51 <shachaf> Aw.
18:23:01 <parcs`> i knew she could do it :)
18:23:48 <Jafet> (Why is the limit three?)
18:23:49 <parcs`> but anyway, that's pretty cool too. a 5 or more consecutive application of flip yields the same type
18:26:58 <parcs`> :t \x -> x flip
18:27:12 <lambdabot> forall (f :: * -> *) a b t. (Functor f) => ((f (a -> b) -> a -> f b) -> t) -> t
18:28:09 <Mathnerd314> :t flip fix flip
18:28:11 <lambdabot> forall b (f :: * -> *) a b1. (Functor f) => (((f (a -> b1) -> a -> f b1) -> b) -> (f (a -> b1) -> a -> f b1) -> b) -> b
18:28:47 <ion> @type fix flip
18:28:49 <lambdabot> forall a b. a -> a -> b
18:28:52 <Eduard_Munteanu> @unpl flip fix flip
18:28:52 <lambdabot> (\ c -> fix c (\ d e f -> d f e))
18:29:39 <Mathnerd314> @src fix
18:29:39 <lambdabot> fix f = let x = f x in x
18:30:18 <Mathnerd314> :t let x = x flip in x
18:30:28 <jeff_s_> @unpl any . flip id
18:30:29 <lambdabot> (\ g -> any (\ c -> c g))
18:30:31 <lambdabot>     Occurs check: cannot construct the infinite type:
18:30:31 <lambdabot>       t = (f (a -> b) -> a -> f b) -> t
18:30:31 <lambdabot>     Probable cause: `x' is applied to too many arguments
18:31:00 <xil> shachaf: do you have an article, off-hand, that you like for how it discussed laziness?
18:37:47 <byorgey> xil: try "Why Functional Programming Matters" by John Hughes.
18:38:02 <Cody_> What is faster, case statement or if/elses?
18:38:09 <byorgey> it doesn't *explain* laziness but it shows some cool things you can do with it.
18:38:16 <Axman6> Cody_: yes
18:38:23 <Cody_> Which one
18:38:29 <Cody_> Case?
18:38:31 <Axman6> they end up being the same
18:38:32 <byorgey> Cody_: it doesn't matter.  but they are equivalent.
18:38:51 <Cody_> Thanks
18:38:56 <Axman6> if x then t else f === case x of True -> t; False -> f
18:39:11 <xil> Axman6: lol. I love when people answer non yes/no questions with "yes"
18:39:28 <Axman6> xil: it's a lot of fun =)
18:39:38 <Cody_> I was just experimenting with different ways to write Fibonacci of a number n
18:39:42 <xil> byorgey: thanks =] that would help a lot. In the meantime I'm reading the wikibook about laziness
18:40:20 <Eduard_Munteanu> Cody_: you might want to check this out, but for factorial:  http://www.willamette.edu/~fruehr/haskell/evolution.html   :)
18:40:56 <Cody_> > let fac n = product[1..n] in fac 10
18:41:02 <xil> Cody_: a lot of times I like to create an if' function. I call it (?:) and it has a type of Bool -> (a,a) -> a. Works like (?:) True (a,_) = a; (?:) False (_,b) = b
18:41:04 <lambdabot>   mueval: Prelude.undefined
18:41:05 <lambdabot>  mueval: ExitFailure 1
18:41:26 <Cody_> Edward_Munteanu: That's how I write fac
18:41:35 <Cody_> xil: I
18:41:47 <Cody_> xil: I'll be sure to remember that
18:42:16 <xil> Cody_: it's the java ternary function, but in Haskell. There is a reason why Haskell doesn't come with one, but it helps to make one yourself
18:42:38 <Cody_> Alright
18:43:29 <mike-burns> Why doesn't Haskell come with one?
18:43:58 <Mathnerd314> @pl \x y z -> if x then y else z
18:43:59 <lambdabot> if'
18:44:33 <tromp> :t if'
18:44:34 <The_Journey> hi, I'm trying to use Vectors instead of Lists, but I'm running into a problem. How would I apply a function (a->a) given an ith index and a Vector and returns a new Vector only where the ith element is applied to the function?
18:44:49 <lambdabot> thread killed
18:44:50 <Mathnerd314> it should have one, but doesn't... call it a historical accident
18:45:10 <mike-burns> Mathnerd314: That's what I thought, too, but xil seems to imply otherwise.
18:45:40 <dmwit> The_Journey: If you want that kind of thing, you probably want a (mutable) array instead.
18:45:47 <dmwit> The_Journey: Vectors don't support that efficiently.
18:46:08 <Mathnerd314> xil: would you care to enlighten us?
18:46:42 <xil> I read somewhere that it doesn't have one because it would fill up tons of searches or something like that. Because the if' function could unnecessarily be applied to many many many Prelude functions
18:46:48 <The_Journey> dmwit: well, I'm trying to use the hmatrix library http://hackage.haskell.org/package/hmatrix-0.13.0.0 and I don't think it supports that, does it?
18:46:51 <xil> let me see if I can't find the source. I think it was on the haskell wiki
18:46:55 <dmwit> The_Journey: However, if you choose to stick with Vector anyway, you might like, e.g., (//)
18:47:06 <exFalso> good evening
18:47:06 <exFalso> say i have a computationally costly function
18:47:06 <exFalso> f :: SomeType -> Array (Int, Int) OtherType
18:47:06 <exFalso> i'd like to make a wrapper function to hide the array
18:47:06 <exFalso> g :: SomeType -> Int -> Int -> OtherType
18:47:06 <exFalso> such that calls to h = g (value :: SomeType) will only evaluate f once
18:47:06 <exFalso> i tried g v = \x y -> f v ! (x, y)
18:47:07 <exFalso> and g v x y = f v ! (x, y)
18:47:07 <exFalso> but neither of them "caches" the result of (f v), any ideas?
18:47:15 <exFalso> oops that was a bit long
18:47:44 <dmwit> exFalso: Yes, use let to make sharing explicit.
18:47:55 <dmwit> g v = let cache = f v in \x y -> cache ! (x, y)
18:47:59 <The_Journey> dmwit: I'm not sure I understood that correctly
18:48:09 <mike-burns> :t (//)
18:48:17 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
18:48:24 <dmwit> :t (Data.Vector.//)
18:48:26 <djahandarie> Is there a Haskell library for working with CIDR and subnets?
18:48:29 <lambdabot> Couldn't find qualified module.
18:48:30 <exFalso> dmwit: i'll try that thanks
18:48:55 <The_Journey> is there a (//) function for Data.Vector?
18:49:06 <dmwit> http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector.html#v:-47--47-
18:49:43 <Mathnerd314> xil: there's http://www.haskell.org/haskellwiki/If-then-else
18:49:55 <xil> Mathnerd314: yeah reading that now actually
18:50:01 <byorgey> Herbert Wilf died =(
18:50:47 <The_Journey> dmwit: I'm not exactly sure how to use (//) for my problem
18:51:10 <mike-burns> djahandarie: There's network-address.
18:51:40 <djahandarie> mike-burns, ah nice, this looks like what I need
18:51:43 <djahandarie> Thanks!
18:52:50 <xil> aha
18:52:52 <xil> now I remember
18:53:47 <xil> still can't find it, it might have been in the docs for some module that provides the function
18:54:50 <xil> it's not really a reason, but it sort of is. The page was talking about autocompletion and how the if' function would flood the autocomplete box or something along those lines
18:55:08 <xil> still looking for it though
18:55:09 <mike-burns> Is this Hayoo?
18:55:39 <mike-burns> (That you're talking about.)
18:56:18 <dmwit> The_Journey: Not much to it.
18:56:34 <dmwit> The_Journey: To update index i to value a in vector v, use v // [(i,a)]
18:56:37 <Cody_> When Haskell does multiplication, is is really just doing addition? Such that a*b = a + a * (b-1).
18:56:52 <Eduard_Munteanu> Cody_: nah
18:56:53 <rwbarton> When you do multiplication, are you really just doing addition?
18:56:59 <Cody_> Kinda
18:57:11 <mike-burns> Cody_: If you're that concerned about performance you can look at the compiler output.
18:57:17 <The_Journey> dmwit: ah ok, I see. But the Data.Packed.Vector does not have (//) does it?
18:57:25 <Eduard_Munteanu> Stuff like that should result in either machine multiply instructions or calls to GMP
18:57:34 <rwbarton> It uses the hardware's multiplication opcode to multiply (small) integers, naturally.
18:57:37 <Cody_> mike-burns: More or less food for thought / deeper understanding
18:58:21 <dmwit> The_Journey: I don't see a Data.Packed.Vector. Whatever that is, it's not coming from the vector package.
18:58:23 <Cody_> > let mult a b = a + mult a (b-1) in mult 2 4
18:58:29 <lambdabot>   mueval: ExitFailure 1
18:58:30 <lambdabot>  mueval: Prelude.undefined
18:58:37 <Cody_> You get the point
18:58:52 <The_Journey> dmwit: it is in hmatrix http://hackage.haskell.org/package/hmatrix-0.13.0.0
18:59:36 <dmwit> Oh. Well, for future reference, if you talk about Vector without additional qualifiers (like "the Vector from hmatrix"), people will assume you mean the Vector from vector. =)
18:59:48 <xil> can't find it right now =/. It might even have been some sort of e-mail dialogue. Don't remember anymore. But I'm on the side of putting it in the prelude for now. I'm even a proponent of a guard type function that accepts a list of (Bool,a) pairs and picks the first to evaluate to True
19:00:10 <dmwit> The_Journey: Anyway, that seems to supply a (//) operation, as well.
19:00:14 <dmwit> http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector-Generic.html#t:Vector
19:00:28 <dmwit> and instance Storable a => Vector Vector a
19:00:44 <dmwit> roger, Roger?
19:01:28 <drull95> suggestions for when String vs ByteString conflict; just convert everything to use ByteStrings?
19:01:46 <mike-burns> Throw up your hands in disgust and curse.
19:01:49 <dmwit> Do you want to store text?
19:02:08 <dmwit> If so, don't convert everything to ByteString; bring in yet a third incompatible type (Text).
19:02:21 <The_Journey> dmwit: I'm so, sorry, I'm still lost. What did you mean by instance Storable a => Vector Vector a ?
19:02:37 <mike-burns> Can -XOverloadedStrings help somewhere, drull95 ?
19:02:40 <dmwit> Generally, if you need efficiency, you use Text for text and ByteString for binary data, and if you don't need efficiency, you use String for both.
19:03:19 <dmwit> The_Journey: (//) works on instances of the Vector class. hmatrix provides an instance of the Vector class for the Vector type. Therefore (//) works on the Vector type.
19:03:41 <The_Journey> dmwit: ah ok, thank you very much
19:03:58 <drull95> i have utility functions which take strings, but hGetContents is returning BtyeStrings
19:04:03 <dmwit> The_Journey: (P.S. I've never used either the vector library or the hmatrix library. So you should practice finding this information in the documentation yourself, which is what I did. =)
19:04:09 <rwbarton> I'm confused because hmatrix does not appear to depend on the vector package
19:04:11 <Jafet> @hoogle hGetContents
19:04:13 <lambdabot> System.IO hGetContents :: Handle -> IO String
19:04:13 <lambdabot> GHC.IO.Handle hGetContents :: Handle -> IO String
19:04:13 <lambdabot> Data.ByteString.Lazy hGetContents :: Handle -> IO ByteString
19:04:18 <dmwit> rwbarton: It provides its own vector type.
19:04:19 <drull95> mike-burns: ill try that
19:04:23 <dmwit> rwbarton: =(
19:04:43 <The_Journey> dmwit: How did you find it? I just started Haskell not too long ago
19:04:43 <rwbarton> But it can't even provide a "vector"-Vector instance then
19:04:45 <dmwit> rwbarton: ...and its own (//), in case you were wondering about that.
19:04:56 <dmwit> rwbarton: ...*and* it provides the Vector class itself.
19:05:03 <rwbarton> ...
19:05:08 <dmwit> yes
19:05:11 <rwbarton> why does hackage link to vector then?
19:05:17 <dmwit> It doesn't?
19:05:41 <rwbarton> click on the first "Vector" in the line "Storable a => Vector Vector a"
19:06:03 <dmwit> ...huh
19:06:18 <rwbarton> as I suspect you did, since you pasted http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector-Generic.html#t:Vector
19:06:33 <dmwit> I'm so confused now.
19:06:49 <The_Journey> dmwit: When I'm trying to use the (//) on a Vector in the hmatrix library, I got the error: Couldn't match expected type `Data.Vector.Vector a0' with actual type `Data.Packed.Vector.Vector Double
19:06:52 <drull95> oh, i fixed it. I was importing ByteString but not System.IO, thanks Jafet
19:06:58 <rwbarton> I wish internal modules had haddock/hscolour run on them.
19:07:04 <mike-burns> Yeah.
19:07:25 <dmwit> rwbarton: Okay, now I'm not as confident that hmatrix provides its own (//), Vector, etc.
19:07:31 <Jafet> ByteString is nearly always called BS or B.
19:07:31 <dmwit> And I'm confused.
19:08:21 <Mongey> Is there a function to replace a single element in a list ?
19:08:36 <shachaf> Jafet: Or SB!
19:08:53 <dmwit> The_Journey: Well, the documentation seems to be lying somehow.
19:08:57 <drull95> BS sounds about right :P
19:09:02 <dmwit> Which is a truly magical thing.
19:09:06 <mike-burns> Mongey: We were just discussing that for Vector and Array!
19:09:09 <Jafet> Or Wally.
19:09:15 <Cody_> mike-burns: Got the hang of what I was talking about earlier. Yours and a few other people explanation helped. Trying to rewrite the prelude functions now as practice
19:09:18 <mike-burns> Mongey: (It's (//) .)
19:09:26 <mike-burns> Cody_: Excellent!
19:09:43 <jeff_s_> @unpf flip (all . flip id)
19:09:44 <dmwit> The_Journey: Aha, perhaps when you built the library, you built it with the "vector" flag off.
19:09:44 <lambdabot> (\ b c -> all (\ f -> f c) b)
19:09:53 <rwbarton> ohhhh
19:10:14 <dmwit> hackage-- for not being clear about dependencies and flags and stuff
19:10:27 <rwbarton> @karma hackage
19:10:27 <lambdabot> hackage has a karma of -1
19:10:31 <dmwit> The_Journey: Try "cabal install hmatrix --flag vector"
19:10:39 <The_Journey> dmwit: oh ok, thank you
19:11:02 <dmwit> That one I will admit you should not be expected to figure out on your own.
19:11:37 <Jafet> Mongey: take n xs ++ x' : drop (n+1) xs
19:11:53 <Cody_> :t foldr
19:11:59 <Cody_> > :t foldr
19:12:05 <lambdabot>   mueval: ExitFailure 1
19:12:05 <lambdabot>  mueval: Prelude.undefined
19:12:08 <lambdabot> thread killed
19:13:08 <mike-burns> I think lambdabot needs to be kicked.
19:13:40 <mike-burns> Or rebooted.
19:13:40 <Cody_> Yes seriously
19:13:51 <The_Journey> dmwit: still getting the error Couldn't match expected type `Data.Vector.Vector a0' with actual type `Data.Packed.Vector.Vector Double after I reinstalled hmatrix with "cabal install --reinstall hmatrix --flag vector"
19:14:56 <djahandarie> cabal: bytestring.cabal:70: The 'type' field is required for test suites. The
19:14:56 <djahandarie> available test types are: exitcode-stdio-1.0
19:15:07 <djahandarie> Any thoughts on what causes that from a cabal install bytestring?
19:17:29 <dmwit> The_Journey: Huh. Let me try. Give me a second to install hmatrix.
19:17:35 <byorgey> djahandarie: I don't know, I got that error too
19:17:40 <Cody_> Does Ctrl-Z kill the GHCi? (not exit)
19:17:50 <byorgey> djahandarie: I ended up just deleting the test suite section =P
19:17:57 <djahandarie> Haha
19:18:29 <shachaf> Cody_: That question is too vague to answer. It depends, for example, on what you mean by "kill", and on what OS you're using.
19:18:33 <dmwit> Cody_: On Windows, ctrl-z is EOF (and so will exit ghci); on Linux, ctrl-z transfers control back to the shell and temporarily stops computation.
19:19:03 <Cody_> I mean kill the current operation. Like accidently typing [1..]
19:19:15 <dmwit> Cody_: On Linux, you can then background the process to continue computation while still leaving the shell interactive, foreground the process to give ghci control back, or kill the process to end it unceremoniously.
19:19:21 <shachaf> Cody_: You still haven't specified what OS you're on.
19:19:26 <Cody_> Windows
19:19:26 <shachaf> ^C *might* do what you want.
19:19:28 <shachaf> Why don't you try it?
19:19:57 <Cody_> Ctrl-c.
19:20:09 <Cody_> shachaf: Thanks
19:20:31 <djahandarie> byorgey, that did indeed work, thanks lol
19:20:46 <shachaf> By the way, that's not what "kill" means.
19:20:56 <byorgey> djahandarie: tests, who needs them, amirite?
19:21:03 * shachaf sighs.
19:21:08 <djahandarie> Yeah!... :(
19:21:12 <shachaf> I'm turning old and bitter.
19:21:28 <djahandarie> shachaf, you have graduated to ##c
19:21:28 * Rotaerk__ gives shachaf some sugar.
19:21:36 <Rotaerk__> literally, not figuratively
19:21:51 <shachaf> I don't think that's how "literally" works.
19:22:01 <Rotaerk__> sure it is
19:22:25 <Rotaerk__> it means I'm not trying to snog you, but I'm giving you refined sugarcane
19:22:27 <byorgey> shachaf: you haven't checked your mailbox.
19:22:30 <Cody_> shachaf: Kill the current operation
19:23:30 <byorgey> ah, so Rotaerk__ meant "literally, figuratively" instead of "figuratively, figuratively"
19:23:31 <shachaf> Rotaerk__: Right, except I don't actually have any refined sugarcane.
19:23:35 <shachaf> Nor do I have a mailbox.
19:24:46 <dmwit> The_Journey: I don't get the same error.
19:24:54 <dmwit> The_Journey: Here's what I tried in ghci, tell me if this happens for you, too:
19:25:05 <dmwit> :m + Data.Packed.Vector Data.Vector.Generic
19:25:11 <Rotaerk__> shachaf, I said literally, not actually/physically
19:25:13 <dmwit> let v :: Vector Double; v = undefined
19:25:20 <dmwit> :t v // [(0,0)]
19:25:39 <lambdabot> thread killed
19:25:41 <dmwit> (Which reports Vector Double.)
19:26:06 <dmwit> Actually, I've got to run. I hope you work out whatever problem it is.
19:26:14 <dmwit> There's others here who can undoubtedly help you.
19:31:37 <Cody_> How is Haskell at creating GUI's compared to languages like Java (swing)? Is it hard/but doable? Note: not looking to create a GUI in Haskell anytime in the near future, but later I will.
19:32:09 <mike-burns> It's harder than in Python but easier than in C.
19:33:39 <Axman6> Cody_: imo, it's probably easier to create a web interface. there are bindings to wx, Qt and gtk, but I've never heard much love for any of them (this might be something inherent to GUIs though, not haskell specific =))
19:34:02 <mike-burns> The docs are the weak point.
19:35:46 <Cody_> mike-burns: you said easier than...something. For some reason the screen is cut off on the left so I couldn't see it. And no, it isn't a scroll problem.
19:35:59 <mike-burns> Crazy.
19:36:04 <mike-burns> Easier than C.
19:36:09 <Cody_> Oh ok
19:38:16 <Cody_> Axman6: So creating a GUI type calculator (just the basic 4 functions) in Haskell would be feasible?
19:38:22 <mike-burns> Yes.
19:38:28 <Axman6> of course
19:39:20 <Cody_> When I think functional language, I think the conventional is /=  GUI's
19:39:30 <Cody_> convetional wisdom*
19:39:51 <mike-burns> The conventional wisdom is "research only".
19:40:06 <mike-burns> yi is written in Haskell.
19:40:10 <Cody_> Better stated ^
19:41:50 <Cody_> So in Java (I hate to keep referring to Java but its what the only other language I know), you would convert your source code into a .jar file and then you could drop the .jar to the Desktop. When it'd was clicked, the GUI (program) ran. Same concept in Haskell; compile and drop?
19:42:30 <mike-burns> I have no idea.
19:42:36 <mike-burns> But you can use apt-get or portage or nix.
19:43:56 <shachaf> Cody_: That's not really a language thing.
19:45:37 <Philippa> Cody_: you can do that with GHC if you want, though you may need to bring some dynamically-linked libraries with you
19:45:43 <Cody_> shachaf: Asking if you can do what I used to do in Java to make executable GUI's in Haskell. Not if it was a language thing
19:46:08 <Cody_> Philippa: Specific ones?
19:46:12 <shachaf> Cody_: You can do something along the lines of it in any language.
19:46:18 <mike-burns> I think his point was: package management isn't really a language thing.
19:46:39 <shachaf> In some languages/runtimes it's more work than in others.
19:46:44 <shachaf> Yes, it's possible with GHC.
19:47:19 <Cody_> shachaf: Albeit true, I was hoping for an explanation / generalized description of how it works in Haskell.
19:47:36 <ddarius> shachaf: Yeah, man.  Why don't you read his mind?
19:47:47 <Cody_> scachaf: That's all I needed for now
19:48:08 <Cody_> ddarius: Go bother someone else
19:48:20 <ddarius> Cody_: Learn to communicate.
19:48:27 <mike-burns> I have no idea how to install a Haskell program on Windows. But I also have no idea how to install a program on Windows.
19:48:50 <mike-burns> On the popular OSes you use apt-get, ports, homebrew, etc.
19:48:53 <shachaf> mike-burns: Cody_ isn't even asking about installing programs, as far as I can tell, just about producing a standalone "executable".
19:48:54 <Cody_> ddarius: Learn how to give constructive criticism, not belittle people.
19:48:58 <shachaf> But it's difficult to tell.
19:49:10 <mike-burns> Oh, to produce an executable you use   cabal build
19:49:47 <Cody_> shachaf: You were write on the latter
19:49:54 <Cody_> right*
19:50:23 <shachaf> Cody_: I don't mean to say this as a hostile thing, but do you realize why a bunch of people have been somewhat short-tempered with answering your questions?
19:50:36 <Cody_> Yep
19:50:42 <shachaf> You do?
19:50:55 <Cody_> Don't want to name any names
19:51:08 <shachaf> I'm not asking about names, I'm asking if you realise why.
19:51:27 <Cody_> I can see why
19:51:34 <shachaf> It's partly the people being grouchy or whatever, sure, but it's also partly because the way you ask questions -- or the sort of questions you ask -- is really frustrating and exhausting to answer.
19:51:47 <Cody_> Too specific or vauge?
19:51:54 <Cody_> vague*
19:52:33 <shachaf> It's something to keep in mind. People are here out of the goodness of their hearts, or whatever the reason may be, to help you with your questions. It's in your best interest to make it as easy as possible for them to do so.
19:53:43 <Enigmagic> except for me, i get paid to sit here. :P
19:54:00 <ddarius> Enigmagic: But do you get paid by Cody_?
19:54:01 <Cody_> Someone to break the ice, but ok.
19:54:12 <Enigmagic> ddarius: no :(
19:54:13 <mike-burns> How do I use runhaskell with cabal-dev?
19:54:20 <Cody_> ddarius: was that necessary?
19:54:25 <ddarius> Enigmagic: Then you are presumably still not beholden to him.
19:54:51 <parcs`> mike-burns: runhaskell -package-conf cabal-dev/*.conf
19:54:58 <Enigmagic> ddarius: i wasn't even paying attention, so definitely not.
19:55:09 <Cody_> ddarius: Do you always sit back and shout snide remarks?
19:55:29 <shachaf> Enigmagic: You get paid to sit here? How does that work?
19:55:36 <Cody_> I can't count on my hands how many times you've done this
19:55:41 * byorgey suggests that ddarius and Cody_ just ignore one another
19:55:49 <mike-burns> Or take it to #haskell-blah.
19:55:51 <shachaf> That's probably forpython the best.
19:55:54 <Enigmagic> shachaf: i have a salary of about $0 per year, so i get paid to do whatever i want :D
19:55:56 <shachaf> I'm not quite sure how that happened.
19:55:57 <ddarius> Cody_: I could let you silently turn off more and more people until almost no one responds to you anymore.  Now you are aware of a problem.  You can assume it's with someone else, or you can consider what you may be doing to cause.
19:56:01 <ddarius> byorgey: I'm not upset.
19:56:05 <byorgey> forpython? hehehe
19:56:16 <shachaf> Enigmagic: I don't think that's what "paid" usually means.
19:56:22 <byorgey> ddarius: I know that.
19:56:27 <parcs`> he gets paid with enlightenment
19:56:52 <Enigmagic> shachaf: you're probably right
20:05:35 <mike-burns> runhaskell with -package-conf gives me: <interactive>:1:75: Not in scope: `main'
20:05:49 <mike-burns> Anyone seen this?
20:06:02 <mike-burns> All the Google results are of people asking in here without getting answers.
20:06:19 <shachaf> mike-burns: And now there's one more.
20:06:28 <mike-burns> I just wanted to be a statistic.
20:06:33 <Axman6> mike-burns: #ghc?
20:06:43 <shachaf> mike-burns: Sadly, you'll never amount to more than a datum.
20:07:19 <mike-burns> On par with an anecdote? I'll take it!
20:08:01 <Enigmagic> mike-burns: add quotes around "-package-conf ./path/to/package.conf.d"
20:08:44 <mike-burns> Whoa, that worked.
20:08:45 <shachaf> Enigmagic: Whoa, crazy, man.
20:08:59 <shachaf> That's kind of ridiculous as far as argument parsing goes.
20:09:21 <mike-burns> That's gotta be a bug of some sort.
20:09:26 <mike-burns> Enigmagic++
20:09:30 <mike-burns> I would never have discovered that.
20:09:40 <parcs`> or an = in between
20:09:44 <parcs`> -package-conf=...
20:09:57 <Enigmagic> :)
20:10:03 <mike-burns> Oh yeah, a = also works.
20:10:19 <djahandarie> I can't believe I still have this Hackage issue where it takes like 5 minutes to respond to me
20:10:22 <shachaf> Enigmagic: Are you going to bahaskell this month?
20:10:28 <parcs`> looks like runhaskell's argument parsing a little too simple :P
20:11:40 <Enigmagic> shachaf: if it's this week i may not be able to
20:11:45 <shachaf> Enigmagic: The 18th.
20:12:07 <Enigmagic> i'll try to go then, i'm currently free on the 18th
20:12:29 <Enigmagic> for some reason my evenings are booked up most of the month :\
20:18:41 <NemesisD> any of you guys use attoparsec?
20:19:41 <shachaf> Maybe. If you have a question about it you should ask.
20:23:09 <NemesisD> hmm, hold on i might have gotten it
20:29:45 <NemesisD> got it!
20:34:47 <haskellnewb> Hi
20:34:51 <haskellnewb> can I get some help
20:35:03 <haskellnewb> D:
20:35:27 <shachaf> haskellnewb: If you mention what your problem is, possibly.
20:36:09 <haskellnewb> Oh yay.
20:36:36 <haskellnewb> I started haskell today and I'm trying to get a list of strings from a string just using list comprehension.
20:37:13 <shachaf> That problem is ill-defined. Unless an empty list is a satisfactory answer.
20:37:27 <shachaf> Also, list comprehensions are overrated. They're not really an important part of Haskell.
20:37:49 <haskellnewb> Oh sorry, I just want to separate the string at the full stop.
20:37:57 <haskellnewb> Like string = "Hi. I'm a newb."
20:38:04 <haskellnewb> Into ["hi", "i'm a newb"]
20:38:07 <mjrosenb> you can't really do that using a comprehension
20:38:13 <haskellnewb> you can't? D:
20:38:45 <mikeplus64> > splitAt 3 "Hi. I'm a newb."
20:38:45 <ehuber> look at data.list.split?
20:38:47 <lambdabot>   ("Hi."," I'm a newb.")
20:38:52 <mikeplus64> :)
20:39:04 <mjrosenb> a comprehension acts on every element of the original list independently
20:39:24 <ehuber> i think you would 'minimally' need a fold
20:39:35 <int> possible mistake in the Network.CGI package?
20:39:37 <haskellnewb> (keep in mind i started haskell today :D)
20:39:40 <int> > Network.CGI.urlEncode "#"
20:39:42 <lambdabot>   Not in scope: `Network.CGI.urlEncode'
20:39:48 <shachaf> ehuber: You would "maximally" need a fold, because you can do anything with a fold.
20:40:15 <ehuber> hm, ok
20:40:31 <int> but it parses in Network.HTTP.urlEncode
20:40:46 <int> to whoever this may concern
20:44:35 <shachaf> int: Yes, Network.CGI's urlEncode looks horribly broken.
20:45:04 <shachaf> Oh, maybe not as broken as I thought.
20:46:41 <shachaf> OK, it's only partly broken.
20:51:00 <int> schachaf: i think i will email the package maintainer
20:52:03 <shachaf> int: How does it handle %?
20:56:07 <Axman6> > approxRational pi 0.0001
20:56:07 <lambdabot>   333 % 106
20:56:11 <Axman6> > approxRational pi 0.00001
20:56:12 <lambdabot>   355 % 113
20:56:40 <Axman6> > map (approxRational pi) (iterate (/10) 1)
20:56:41 <lambdabot>   [3 % 1,16 % 5,22 % 7,201 % 64,333 % 106,355 % 113,355 % 113,75948 % 24175,1...
20:57:27 <eyebloom> g(f) = f
20:58:34 <int> schachaf: I checked every character and i think "#" is the only one which does not parse
20:58:54 <int> schachaf: let me check the package source code
21:13:48 <eyebloom> How does a fixpoint combinator relate to the mathematical notion of a fixpoint.
21:14:01 <Sgeo> Is there a recommended GUI library
21:14:15 <Sgeo> For someone who's never done GUI stuff in any language except VB before?
21:14:40 <shachaf> eyebloom: It gives you the least fixed point of a function, where the ordering is definedness.
21:15:01 <shachaf> (Which forms a semilattice with _|_ at, well, the bottom.)
21:15:05 <eyebloom> Define definedness :)
21:15:08 <cmccann> Sgeo, what do you want to do with it?
21:15:11 <shachaf> @google ezyang definedness
21:15:13 <lambdabot> http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
21:15:13 <lambdabot> Title: Hussling Haskell types into Hasse diagrams : Inside 233
21:15:15 <tensorpudding> cross-platform GUI is a real annoyance
21:15:15 <AfC> Sgeo: if you're on Linux then GTK will work superbly for you.
21:15:19 <shachaf> eyebloom: See that post.
21:15:24 <AfC> tensorpudding: always has been :(
21:15:36 <tensorpudding> if you don't care about cross-platform then you'll pick the native one
21:15:40 <shachaf> eyebloom: In particular, "fix f" is always a fixed point of f.
21:15:40 <Sgeo> AfC, what about on Windows? I'm on Linux right now, but ...
21:15:56 <shachaf> eyebloom: That is, f (fix f) = fix f
21:16:05 <shachaf> Sometimes that's _|_, though.
21:16:18 <tensorpudding> there are ones that are portable but they are only native on at most one platform
21:16:24 <eyebloom> In cases of infinite recursion, you mean
21:16:32 <Sgeo> > fix (+0)
21:16:34 <AfC> Sgeo: {shrug} we discarded Windows as a target platform over 10 years ago, so its not a constraint for us. That's obviously not the case for everyone, but all our clients run Linux on the desktop so it's really a no-brainer to simplify.
21:16:36 <lambdabot>   mueval-core: Time limit exceeded
21:17:01 <shachaf> Sgeo: _|_ is a fixed point of (+0), because _|_ + 0 = _|_
21:17:02 <tensorpudding> if you aren't constrained by being on the desktop, making a web app is much preferrable in that regard
21:17:15 <Sgeo> 0 is a fixed point of (+0), but so is _|_, and _|_ is less defined
21:17:17 <ddarius> I'm pretty sure GTK works fine on Windows.
21:17:20 <tensorpudding> you get a useful cross-platform GUI for free
21:17:53 <Sgeo> ^^is that an accurate way of putting it?
21:18:09 <tensorpudding> haskell's gtk bindings are outdated and mediocrely-documented
21:18:27 <tensorpudding> and gtk won't look as good on windows or maqc
21:18:29 <tensorpudding> mac*
21:18:40 <AfC> ddarius: they're still smoothing the warts of getting GTK 3.x to work right there, but for sure the old GTK 2.x works (as well as it ever did).
21:19:47 <cmccann> the nice thing about windows is that most users don't expect consistency in GUIs
21:19:58 <cmccann> so non-native stuff doesn't stick out as badly
21:20:08 <eyebloom> Sgeo: I would look into QT, from a Haskell point of view it may be problematic, but from an overall point of view I would choose it over GTK.
21:20:15 <tensorpudding> it depends on how much your users care
21:20:17 <shachaf> Sgeo: Every value is a fixed point of (+0).
21:20:24 <shachaf> And _|_ is the last least-defined of these, yes.
21:20:32 <tensorpudding> if you want to make an app that's better than the competition it's a big handicap
21:20:49 <shachaf> cmccann: They don't?
21:20:52 <pikhq> tensorpudding: Nonstandard UIs are kinda standard, though. :)
21:21:06 <pikhq> shachaf: Custom UIs are a Windows thing.
21:21:29 <cmccann> shachaf, well, maybe some do, but eventually the perpetual disappointment would dissuade them, I'd think
21:21:43 <shachaf> My experience with Windows GUIs was never that inconsistent.
21:36:30 <ddarius> shachaf: There are certain things that are reasonably consistent about "native" Windows GUIs, but beyond that, there is a lot of variety.  Visual Studio 2010, Word 2010, IE 9, and Notepad are all made by Microsoft and already show a lot of variety in UI even in areas not tightly bound to their differing tasks.
21:37:20 <shachaf> ddarius: I would imagine that none of this variety is in terms of widgets actually looking non-native, though, which I imagine that GTK widgets do.
21:37:39 <Sgeo> What does Ruby Shoes do?
21:39:10 <shachaf> @google what does ruby shoes do
21:39:11 <lambdabot> http://shoesrb.com/
21:39:11 <lambdabot> Title: Shoooes!
21:39:56 <ddarius> shachaf: Some of it is, particularly for "tabs" if they are supported.  I don't recall GTK not using native controls when I wrote stuff for it.
21:40:28 <shachaf> ddarius: I'm probably thinking of my experiences with e.g. GIMP running under Windows; but that was quite a while ago.
21:41:13 <ddarius> shachaf: Looking at the screenshots on the GTK site of GIMP on Windows, it looks like most of the controls, if not all of them, are native.  I can easily imagine that GIMP uses some non-native controls.
21:42:41 <everyonemines> hey does Clean have a channel
21:42:44 <ddarius> Suffice it to say, though, that Corel's Painter (and I believe Photoshop as well) look dramatically non-native compared to these GIMP screenshots.
21:43:16 <ddarius> ?
21:43:38 <everyonemines> whoops
21:44:15 <ddarius> everyonemines: You'll probably have to either ask Google, look at the Clean site, or ask on the Clean mailinglist.
22:48:02 <temp123> how would I take n elements from a list surrounding an element?
22:49:08 <temp123> zipping with [1..] then playing with the indices would be my take on it
22:50:31 <MostAwesomeDude> temp123: Well, you know about "take", right?
22:51:48 <shachaf> temp123: Can you clarify what you're trying to do?
22:54:07 <temp123> shachaf: let's say I have a list of unique elements [a,b,c,d,e,f,g]. I need a function that given the input c and 2 gives me back [a, b, c, d, e]
22:55:08 * mjrosenb is not sure how c factors into the return value
22:55:22 <shachaf> Up to two elements after the first c?
22:55:29 <mjrosenb> oh..
22:55:56 <shachaf> Somewhat odd operation.
22:56:07 <temp123> shachaf: yes :)
22:56:46 <shachaf> > let (a,b) = break (=='c') "abcdefgh" in a ++ take (2+1) b
22:56:48 <lambdabot>   "abcde"
22:57:46 <temp123> shachaf: thanks, this looks good
22:58:18 <temp123> alternatively, how would I get the n nearest elements to c (including c)?
22:59:00 <shachaf> "nearest" in both directions?
22:59:05 <srhb> how come cycle is defined as xs' where xs' = xs ++ xs' and not just xs ++ xs? I'm guessing this is the trick that makes it actually work, but how?
22:59:12 <shachaf> These are somewhat odd things to be doing.
22:59:22 <shachaf> srhb: Try to evaluate it with xs ++ xs by hand and see what happens.
22:59:38 <shachaf> srhb: Learning to evaluate expressions by hand is a good skill, so you should practice it.
22:59:48 <temp123> so if I have the same list [a,b,c,d,e] and the input b and 4, I get [abcd]
23:00:50 <shachaf> I wonder if a version of break that took a "continuation" rather than using a tuple would make sense.
23:00:52 <temp123> i mean [a,b,c,d]
23:01:12 <mjrosenb> scsibug: sounds like grep -c
23:01:20 <shachaf> @ty let break' p f l = let (a,b) = break p l in f a b in break'
23:01:21 <lambdabot> forall a t. (a -> Bool) -> ([a] -> [a] -> t) -> [a] -> t
23:02:04 <shachaf> temp123: OK, I don't get your examples anymore.
23:02:49 <temp123> shachaf: sorry, I try to be clearer
23:04:30 <srhb> temp123: Do you mean at least four elements, or until b?
23:04:35 <srhb> Whichever comes first.
23:05:36 <temp123> let's say I have space to display n items from a list and I have a pivot element for which I want to display the nearest items
23:06:31 <srhb> Then...
23:06:33 <shachaf> I'm not sure that lists are the best data structure to use there.
23:06:34 <temp123> so if my pivot is the first item, then I just need the pivot itself and the next n-1 items
23:06:48 <shachaf> But it seems that you could write something.
23:07:05 <srhb> temp123: That's not what you were asking for before though
23:07:07 <shachaf> I'd just use an explicitly recursive function; I think this is too specialized for utilities to be much help.
23:07:13 <Cale> Nearest by value, or nearest by index?
23:07:21 <srhb> temp123: That would simply be take (n-1) $ dropwhile (not pivot)
23:07:31 <shachaf> This is still insufficiently specified, though.
23:07:43 <shachaf> srhb: No, because temp123 wants elements on both sides of the pivot.
23:08:01 <srhb> Hence I'm saying his newest specification was wrong, shachaf :)
23:08:03 <temp123> shachaf: yes
23:08:23 <shachaf> srhb: Which part of it is wrong?
23:08:25 <srhb> Or I misunderstood, either way.
23:08:28 * hackagebot zlib-bindings 0.0.2 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.0.2 (MichaelSnoyman)
23:08:31 <shachaf> That seems more likely.
23:08:55 <shachaf> It's still ill-specified, though. We could probably make a guess but it might be better if temp123 thought about it until it was specified completely.
23:09:16 <srhb> Really? I wasn't aware that I was more prone to misunderstandings :-)
23:09:52 <temp123> shachaf: I'll hack something together with zip and paste it to hpaste then :)
23:10:27 <srhb> A modified fold with a counter should do the trick.
23:10:29 <Cale> > let contexts n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in contexts 5 [1..10]
23:10:31 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10]]
23:11:32 <temp123> thanks everyone, I have to leave now
23:11:42 * shachaf sighs.
23:12:18 <shachaf> The attitude of someone asking for help really ought to be that the time of the people helping them is more valuable than their own time.
23:12:42 <shachaf> Or at least as valuable, at any rate.
23:12:46 <ddarius> shachaf: Clearly it's not.  I mean, you are sitting around on IRC.
23:13:04 <srhb> It can be hard to evaluate how big a task is if you need help for it.
23:13:47 <shachaf> ddarius: I suppose that's a point.
23:14:50 <ddarius> shachaf: However, another way to bolster your argument is that petitioners are in competition with each other.
23:15:36 <shachaf> People in #haskell are too nice, that's the problem.
23:15:40 <ddarius> Agreed.
23:15:41 <shachaf> And ddarius is the cure.
23:16:15 <ddarius> I wish it were that simple.
23:16:26 <shachaf> Even ddarius is too nice, really.
23:16:36 <ddarius> Agreed.
23:16:41 <shachaf> We pretty much need an auto-kick bot for anyone who joins the channel for any reason ever.
23:18:41 <AfC> That'll keep the Frequently Asked Questions to a minimum.
23:20:04 <mjrosenb> the first rule of #haskell is you do not /join #haskell
23:20:07 <srhb> It might be simpler to make a closed #haskell-elitism channel. :P
23:20:21 <shachaf> srhb: There is one; they just don't tell you about it.
23:20:27 <srhb> That makes sense.
23:22:32 <augur> anyone familiar with prooftree.sty, perchance?
23:29:32 <MarcWeber> Question about enumerators: Why does ET.lines join lines in this sample?
23:29:43 <MarcWeber> I'd expect "Right 3" as result: http://dpaste.com/684323/
23:30:57 <MarcWeber> line 26 prinst ["abc"] - and I'd expect each line "a" "b" "c" being a chunk item.
23:33:28 * hackagebot paragon 0.1.8 - Paragon  http://hackage.haskell.org/package/paragon-0.1.8 (NiklasBroberg)
23:40:28 <mels> .
23:52:15 <MarcWeber> enumFile already returns lines dropping the \n separators
