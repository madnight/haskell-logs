00:00:06 <qqMuppetpp> i don't see how adding seek overhead on top would help
00:00:28 <plumenator> Well, we'd only seek once.
00:02:39 <qqMuppetpp> assuming you're talking about normal spinning disks, the hardware will be seeking back and forth if you read from multiple positions on disk
00:04:06 <Blkt> good morning everyone
00:06:23 <dajfsa> hi! is there a good library for regexes in haskell?
00:07:26 <ion> I find myself using a parser combinator library for almost everything for which i‚Äôd have used regexps in previous languages.
00:08:04 <ion> I don‚Äôt know about good, but there are regexp modules. :-)
00:08:12 <dajfsa> ion: like parsec? i've seen it, its cool but i was just wanting to do some simple matching of filenames/text etc. so was wondering if there's anything common to use
00:09:18 <frerich> dajfsa: You mean globbing?
00:09:38 <dajfsa> frerich: more complex than globs
00:10:38 <quicksilver> parsing is better than regexps for almost all jobs, big and small
00:10:43 <frerich> dajfsa: There's a page on regular expression support in Haskell, at http://www.haskell.org/haskellwiki/Regular_expressions - I personally used 'regex-pcre' (Haskell bindings to PCRE), which worked okay.
00:10:56 <quicksilver> regexps are really designed for the case when the *user* of your program gets to configure the matching
00:11:07 <quicksilver> i.e. regexps should be used when the matching is not known at compile time.
00:11:20 <quicksilver> for example, you're writing an editor.
00:11:21 <dajfsa> frerich: thanks, i'll take a look! looks like there's quite a lot of them...
00:11:43 <frerich> quicksilver: I think regexps also make sense if your parser logic is not too complicated. In that case, they are just a very concise way to describing a parser.
00:11:44 <ion> I wonder what the actual difference is between regex-pcre and pcre-light (beyond ‚Äúit‚Äôs light‚Äù)? :-) http://hackage.haskell.org/package/pcre-light doesn‚Äôt say.
00:12:23 <dajfsa> quicksilver: well, im just trying to do a pretty quick script... i wouldn't use regexs if i was doing complicated matching
00:13:19 <dajfsa> frerich: ok, ill try out regex-pcre, thanks!
00:13:44 <Phlogistique> dajfsa: you would prolly be better off doing it in perl/ruby if it's a quick script
00:14:25 <Phlogistique> also, I don't know how to express something like .*something in parsec
00:14:59 <Phlogistique> many anyChar >> string "something" wouldn't work
00:15:17 <Phlogistique> as s matches anyChar
00:15:32 <dajfsa> Phlogistique: well im trying to learn haskell, i use python normally
00:16:21 <quicksilver> Phlogistique: why?
00:16:27 <quicksilver> haskell is better than perl or ruby for quick scripts.
00:16:31 <Phlogistique> manyTill (string "somethin") anyChar >> string "something" wouldn't be greedy
00:16:33 <qqMuppetpp> dajfsa: if you're just doing it for learning purposes, go with Parsec
00:16:43 <Phlogistique> quicksilver: un unusual statement
00:16:46 <quicksilver> he's not here any more :)
00:17:18 <quicksilver> parser combinators are better than regexps for just about everything except, of course, for the factor of programmer knowledge
00:17:38 <quicksilver> if you're doing something by a real world deadline then it may make sense to use the tool you're more familiar with even if it's the worse tool.
00:17:49 <Phlogistique> quicksilver: how would you answer my question?
00:19:23 <quicksilver> Phlogistique: you're quite right that greedy matches aren't very natural in parsec
00:19:52 <quicksilver> anecdotally I would say I've seen more people bitten by the greedy nature of regexp when they didn't want it, than people specifically needing the greedy behaviour
00:20:16 <quicksilver> real problems often have slightly more structure, too
00:20:33 <quicksilver> but if ".*something" really is the *precise* problem you have, then regexp may be the simplest answer.
00:20:45 <Phlogistique> quicksilver: in regexes you have non-greedy matching too in perl and ruby
00:21:11 <quicksilver> Phlogistique: I am aware of this, yes.
00:21:44 <quicksilver> my point is not that perl-style regexps are not powerful
00:21:46 <quicksilver> obviously they're powerful
00:21:59 <quicksilver> my point is rather than they are an ugly special purpose minilanguage.
00:22:12 <quicksilver> and debugging complex regexps is a... specialised... skill
00:22:37 <Phlogistique> though I don't know a lot about parsing, I wish I could use a combinaroe library enabling the expressive power of both parsec and regexes
00:22:41 <quicksilver> if you are already a regexp expert and the problem you are solving is well matched by a regexp then sure
00:23:46 <Phlogistique> *combinator
00:24:36 <plat0> Can parsec not do everything a regex can?
00:24:47 <quicksilver> technically yes
00:24:57 <quicksilver> in a kind of boring "parsec contains the whole power of haskell" kind of way
00:25:07 <quicksilver> but some things are quite fiddly in it, like the example Phlogistique just gave
00:25:11 <MUFFIN_> Hello guys!!!1!
00:25:40 <plat0> I see.
00:25:45 <quicksilver> parsec can run arbitrary computations and allow the result to consume (or not) tokens and make the parser fail (or not)
00:25:50 <quicksilver> so it quite literally can do "anything"
00:26:05 <quicksilver> but using it that way is not the idiomatic way to use it
00:26:55 <Botje> MUFFIN_: hallo.
00:27:01 * hackagebot Chart-gtk 0.15 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-0.15 (TimDocker)
00:27:12 <Phlogistique> is there any combinator library more similar to regexes in the range of semantics expressed? are PEG the way to go for this?
00:27:57 <Phlogistique> (by "similar" I meant "provides an usable superset")
00:29:02 <MUFFIN_> im gay for trannies
00:32:03 * hackagebot Chart 0.15 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-0.15 (TimDocker)
00:32:05 * hackagebot test-framework-th-prime 0.0.0 - Template Haskell for test framework  http://hackage.haskell.org/package/test-framework-th-prime-0.0.0 (KazuYamamoto)
00:44:08 <MUFFIN_> im gay so bad
00:44:08 <MUFFIN_> im gay so bad
00:44:09 <MUFFIN_> im gay so bad
00:44:14 <MUFFIN_> im gay so bad
00:44:14 <MUFFIN_> im gay so bad
00:44:14 <MUFFIN_> im gay so bad
00:44:14 <MUFFIN_> im gay so bad
00:44:14 <MUFFIN_> im gay so bad
00:44:15 <MUFFIN_> im gay so badim gay so im gay so bad
00:44:15 <MUFFIN_> im gay so badim gay so bad
00:44:16 <MUFFIN_> im gay so bad
00:44:16 <MUFFIN_> im gay so bad
00:44:17 <MUFFIN_> im gay so bad
00:44:17 <MUFFIN_> im gay so bad
00:44:25 <luite> @ops
00:44:25 <lambdabot> Maybe you meant: docs oeis pl
00:44:28 <luite> hmm
00:44:32 <Botje> @where ops
00:44:32 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:44:33 <MUFFIN_> Apologies
00:44:36 <luite> ah thanks
00:44:41 <MUFFIN_> Being at scool is not the best place
00:44:46 --- mode: ChanServ set +o mauke
00:44:46 --- kick: MUFFIN_ was kicked by mauke (MUFFIN_)
00:45:05 <Botje> he shoots, he scores!
00:45:19 <luite> clearly the @where is outdated :(
00:45:44 --- mode: mauke set +b *!*@gateway/web/freenode/ip.195.194.168.90
00:45:50 <quicksilver> mauke's not really an op. He's a benign script kiddie.
00:46:56 <Botje> anyone who can hack his way to ops deserves credit >:)
00:47:44 --- mode: mauke set -o mauke
01:05:14 <asda8> I'm looking for a function to convert my bytestrings from utf8 to ucs2, but only found decoding functions so far.
01:05:54 <asda8> any ideas where I might find one?
01:06:18 <augur> any good videos up lately?
01:19:08 <Jafet> asda8: you could convert through Data.Text.Encoding
01:19:17 <Jafet> ...if it encodes UCS-2
01:19:25 <Jafet> ...who the hell still uses UCS-2.
01:19:40 <asda8> Jafet: sql server, sadly
01:20:25 <Jafet> As no one theoretically uses UCS-2, you might have to implement it.
01:20:25 <asda8> Jafet: the problem is, that I want to work with HDBC and it only supports bytestrings
01:22:06 <asda8> Jafet: also there is a bug in the sql server native driver which forces me to use raw query strings sometimes, which can only be done with String in HDBC (HDBC then assumes UTF8).
01:22:38 <asda8> Jafet: so basically I'm screwed
01:28:00 <cari_veri_dt> Hey there. I want to generate a little html with haskell , how would you suggest me to start off?
01:30:59 <ChristianS> asda8: i think that ucs2 is basically a synonym for UTF-16. some of the Data.Text.Encoding functions should help you there
01:31:14 <qqMuppetpp> cari_veri_dt: I'd look at how the various web frameworks do it
01:31:43 <Twey> cari_veri_dt: Consider the (X)HTML packages, or blaze-html, or one of the templating packages like StringTemplate or Hamlet
01:32:04 <Twey> ChristianS: Not quite ‚Äî UCS-2 is strictly two-byte, whereas UTF-16 is variable-length
01:33:49 <cari_veri_dt> qqMuppetpp: which frameworks ?
01:33:53 <cari_veri_dt> I downloaded a package http://hackage.haskell.org/package/xhtml .
01:34:01 <ChristianS> Twey: well, as long as the input contains only chars from the Basic Multilingual Plane that won't matter
01:34:05 <ChristianS> http://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane
01:34:22 <qqMuppetpp> yesod, snap & happstack, I guess
01:34:38 <Twey> ChristianS: Yeah
01:34:39 <ChristianS> if there are any chars from the higher plans, asda8 will just have to hope that nobody notices ;-)
01:34:44 <Twey> Heh.
01:35:47 <mauke> üê±
01:37:30 <rsimoes1> grumpy mauke pastes unicode kitty cats in #haskell but yells at me in #perl
01:37:53 <rsimoes1> not fair at all
01:38:21 <mauke> when did I yell at you?
01:38:40 <rsimoes1> ALL THE TIME
01:42:52 <ChristianS> asda8: if you really care about the difference, you could filter the chars from the higher planes out or replace with some replacement char. they cannot be represented in UCS-2 anyway.
01:45:44 --- mode: ChanServ set +o mauke
01:45:44 --- mode: mauke set -b *!*@gateway/web/freenode/ip.195.194.168.90
01:47:44 --- mode: mauke set -o mauke
01:55:18 <asda8> ChristianS: thanks, but the problem is I can't always pass binary strings to HDBC because of an sql native client bug which has not been fixed for several years. HDBC translates my haskell Strings to UTF8 by default, so it doesn't work even if I could encode my data in the right format.
01:57:34 <ChristianS> asda8: you MUST send bytestrings (ucs-encoded), but you CAN'T send them? can't help you there, i'm afraid :-(
02:03:14 <cari_veri_dt> where do I put downloaded libraries for ghc to find them on import ?
02:03:31 <rostayob> cari_veri_dt: you should install libraries with cabal
02:05:50 <cari_veri_dt> rostayob: whats the alternative? (but I will consider using cabal)
02:11:17 <rostayob> cari_veri_dt: i'm not sure. you should really use cabal
02:11:27 <rostayob> you can just put the library in your source tree
02:11:33 <rostayob> i guess
02:12:06 <rostayob> cari_veri_dt: but that would be tricky for a lot of libraries
02:12:09 <rostayob> just use cabal
02:14:02 <cari_veri_dt> rosta. ok. know of screencasts on xhtml ?
02:14:46 <nwr> if you use ghc, check ghc-pkg. but you really should use cabal.
02:20:56 <cari_veri_dt> alright I use cabal, but now Id like to learn about using the xhtml package.
02:36:20 <estan_> there's no function in the standard library for doing some crude pretty printing, right? (e.g. like pp in ruby)
02:39:54 <cari_veri_dt> rostayob: where can I look for example codes with the xhtml library in use?
02:40:47 <cari_veri_dt> or even tutorials
02:41:41 <Axman6> estan_: no, but there's several packages for it
02:45:12 <rostayob> cari_veri_dt: i'm not sure, i'd personally follow haddock
02:48:57 <estan_> Axman6: alright.
02:50:58 <rostayob> estan_: the pretty package is in the haskell platform
02:54:00 <cari_veri_dt> ok thank you
02:57:02 * hackagebot hedis 0.1 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.1 (FalkoPeters)
02:58:21 <Vampire> whats haskell
02:59:50 <rostayob> Vampire: haskell.org
03:04:11 <tty7> it's remarkably quiet, regarding that there are 805 people in here..
03:04:25 <Botje> it's lunchtime here in europistan
03:05:01 <tty7> but not everybody is having lunch at the same time ;)
03:05:23 <tty7> and: there are no americans in here? :P
03:05:40 <rostayob> tty7: ll it's quiet because no one needs help right now :P
03:05:48 <tty7> ;)
03:07:03 <tty7> i have seen many other channels with only about 100 people talking as much as we do all the day in about 10 seconds ;)
03:07:31 <Botje> #haskell can get pretty hectic
03:07:38 <quicksilver> it's very variable
03:07:43 <tty7> hm, okay
03:07:55 <tty7> just went here twice so far and it wasn't both times ;)
03:08:45 <tty7> i mean, i am here for about nearly 4 hours now and what happened is.. well, nothing ;)
03:08:59 <tty7> nevermind.
03:09:21 * tty7 enjoys the silence :)
03:10:23 <Jafet> Ask any question about IO String
03:11:27 <tty7> well, just came to a question:
03:11:53 <quicksilver> *channel draws breath in anticipation*
03:12:31 <tty7> how can i break up a long line of code into several lines, apart from defining parts of it as a new function
03:12:48 <rostayob> tty7: where, let
03:13:07 <tty7> yeah i know. but i mean without using that stuff
03:13:13 <rostayob> ?
03:13:23 <tty7> just because the single line would be too long, but it is fairly understandable
03:13:23 <rostayob> you can just break them
03:13:28 <tty7> great :)
03:13:29 <rostayob> just go to a new line
03:13:36 <rostayob> you have to be careful to indentation
03:13:37 <tty7> cool, thanks!
03:13:42 <rostayob> but not too careful haskell is pretty liberal
03:14:01 <Veinor> haskell's lack of support for heredocs annoys me occasionally :/
03:14:10 <Axman6> tty7: as long as the new line is indented as much as, or more than the line before it (that's part of the same expression) then it'll be ok
03:14:26 <tty7> right now, i am in a where statement
03:14:29 <Veinor> also i think most americans are asleep seeing as how it's 7 am
03:14:30 <tty7> like
03:14:36 <rostayob> Veinor: it's not that bad, just ++ and newline
03:14:52 <Veinor> rostayob: does that get compiled down to a constant?
03:15:18 <tty7> where a = 123 \n b = 345 \c = this line is a very long line of code
03:15:32 <rostayob> Veinor: probably not, but i doubt that matters anyways...
03:15:40 <Axman6> Veinor: it gets compiled down to at least something that will only ever be evaluated once usually
03:15:47 <rostayob> yeah
03:15:56 <tty7> so it would be fine to just break the long line somewhere at a space and then indent it up to the "c = " the line above?
03:16:08 <Veinor> Axman6: well, i'd hope so!
03:16:33 <Axman6> tty7: yep
03:16:37 <Veinor> i guess i'm just used to stuff like python's triple-quotes
03:16:40 <tty7> great, thanks! :)
03:16:44 <Axman6> maybe a bit more, experiment and find out =)
03:16:50 <tty7> ;)
03:17:01 <tty7> i will
03:17:04 <Veinor> useful for writing stuff like --help messages
03:17:13 <Axman6> tty7: if you're looking for something to google, search for the 'offside rule'
03:17:17 <rostayob> Veinor: you can dump the core to check what it compiles to. remember that haskell is lazy
03:17:30 <Veinor> that's too much effort
03:17:44 <rostayob> Veinor: is it? you can write a very short program and try
03:17:57 <Veinor> i don't know how to dump core though
03:18:04 <ChristianS> Veinor: you can also write multi-line strings like this: "Usage: doubleintros [-e] [-h] [file ...]\n\
03:18:04 <ChristianS>     \Options:\n\
03:18:04 <ChristianS>     \  -e  Compare full first lines (don't stop at first punctuation)\n\
03:18:04 <ChristianS>     \  -h  Print this help text and exit\n\
03:18:04 <ChristianS>     \Input is read from stdin if no filename is provided."
03:18:10 <tty7> hehe, rostayob. i just did that to check some questions similiar to that and it nearly crashed the computer :D
03:18:25 <Veinor> ChristianS: that's still messy
03:18:48 <rostayob> Veinor: -ddump-*, depending on the optimization level (e.g. -ddump-simpl)
03:19:14 <rostayob> if you store your long string in a top level variable it'd be evaluated once anyways
03:19:38 <rostayob> and similarly, when using a nested variable containing the string repeatedly, it'd be evaluated once
03:20:15 <Veinor> ddump-simpl shows nothing
03:20:24 <rostayob> Veinor: so what you're talking about can be a problem (expecially when using overloadedstrings, which hides the packing-unpacking) but usually isn't
03:21:02 <rostayob> Veinor: it doesn't? check the ghc manual
03:21:08 <rostayob> -ddump-cse?
03:21:24 <Veinor> oh, nevermind, i was running it wrong
03:21:32 <rostayob> Veinor: www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
03:21:35 <Veinor> i have no clue how to interpret the output
03:21:54 <rostayob> Veinor: if you're interested: http://stackoverflow.com/questions/6121146/reading-ghc-core
03:22:07 <rostayob> Veinor: but anyway, if you take lazyness into account,  as i said
03:22:19 <rostayob> you can have all your long strings to be evaluated once anyways
03:22:30 <rostayob> without relying on GHC
03:22:48 <rostayob> also, you shouldn't worry about this until you actually hit problems because of that :)
03:22:55 <Veinor> sure, this is just curiosity
03:24:29 <rostayob> Veinor: reading core is a nice skill to have anyways
03:27:20 <Veinor> hmm
03:27:30 <Veinor> it looks like it does somewhat if i use -O2
03:27:46 <Veinor> oh nevermind
03:28:21 <Veinor> i was missing some of the optimizations because it turns "a" ++ string into 'a' : string
03:28:53 <Veinor> interestingly, x = 2 + 3 doesn't get folded
03:29:12 <rostayob> Veinor: folded?
03:29:27 <Veinor> http://en.wikipedia.org/wiki/Constant_folding
03:29:52 <rostayob> Veinor: oh right.
03:29:53 <Veinor> x = 2 + 3 doesn't add 2+3 at compile time
03:30:54 <rostayob> Veinor: that's probably not implemented since it doesn't really changes how fast your application runs
03:31:14 <Veinor> yeah, i figured
03:31:14 <rostayob> i mean it does, but most of the times not considerably anyways
03:33:17 <Veinor> huh
03:33:26 <Veinor> for funsies i tried embedding a very large integer literal
03:34:25 <Veinor> and it compiles it down to a bunch of integer expressions
03:35:56 <mm_freak> now this is very surprising
03:36:01 <Veinor> that look like (((a*z)+b)*z+c)*z+d
03:36:06 <Veinor> where z = 2^63 - 1
03:36:17 <mm_freak> a State-based adder using data-lens is faster than a purely recursive adder
03:36:59 <hpaste_> ‚ÄúErtugrul S√∂ylemez‚Äù pasted ‚ÄúState- and lens-based adder‚Äù at http://hpaste.org/56341
03:37:44 <mm_freak> with GHC 7.0.3 and -O this code is faster than the usual recursive adder with two arguments
03:38:06 <mm_freak> even though data-lens involves some store comonad machinery under the hood
03:38:25 <tty7> by the way, is it possible to nest multiple where statements?
03:38:42 <mm_freak> tty7: sure
03:38:43 <rostayob> tty7: no
03:38:45 <rostayob> is there?
03:38:48 <rostayob> oh.
03:38:49 <tty7> :)
03:38:50 <mm_freak> no?
03:38:57 <tty7> okay, i will try
03:38:59 <tty7> ;)
03:39:01 <koeien> sure, but "where" is not really a statement
03:39:27 <tty7> a block?
03:39:39 <mm_freak> koeien: what is it then?
03:40:06 <koeien> what would a "statement" be?
03:40:26 <koeien> i'd call it a "clause"
03:40:57 <Veinor> rostayob: ... oh, this is a lot easier to read with -dsuppress-all
03:41:25 <tty7> but the do-structure is a statement, isnt it?
03:41:31 <tty7> at least the compiler says that :P
03:41:46 <mauke> no, the do-structure is an expression
03:41:55 <mm_freak> koeien: you may be confusing "statement" with "command"‚Ä¶  it's certainly not a command, but i'd say it's a statement
03:41:59 <mm_freak> clause is fine, too
03:42:35 <tty7> ah, well, the parts of the do-expression are statements
03:44:21 <tty7> hm.. isn't floor actually the very same as truncate?
03:44:33 <mauke> > floor (-0.1)
03:44:34 <lambdabot>   -1
03:44:46 <tty7> i see :)
03:45:01 <tty7> but for positive values, it should be the same, shouldn't it?
03:45:17 <mauke> @check liftA2 (==) floor truncate
03:45:18 <lambdabot>   "Falsifiable, after 1 tests:\n-0.33333333333333337\n"
03:45:45 <Veinor> @check liftA2 (==) (floor . abs) (truncate . abs)
03:45:46 <tty7> yeah, because of the negativity
03:45:47 <lambdabot>   "OK, passed 500 tests."
03:45:49 <tty7> :)
03:46:03 <joe9>   /join #ronpaul
03:46:25 <tty7> @check liftA2 (==) (abs . floor) (truncate . abs)
03:46:27 <lambdabot>   "Falsifiable, after 1 tests:\n-0.5\n"
03:46:40 <tty7> the other way round
03:46:51 <tty7> @check liftA2 (==) (floor . abs) (abs . truncate)
03:46:53 <lambdabot>   "OK, passed 500 tests."
03:46:57 <tty7> :]
03:47:55 <mm_freak> tty7: for Double and Float at least
03:48:28 <erus`> @check \_ -> True
03:48:29 <lambdabot>   "OK, passed 500 tests."
03:48:47 <tty7> lol erus`
03:48:53 <Veinor> @check (== ())
03:48:54 <lambdabot>   "OK, passed 500 tests."
03:49:06 <mauke> @check (==)
03:49:07 <lambdabot>   "OK, passed 500 tests."
03:49:11 <Veinor> haha
03:49:13 <tty7> @check
03:49:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:49:18 <ion> Oh, @check works again.
03:49:21 <tty7> @check ()
03:49:22 <lambdabot>   "Arguments exhausted after 0 tests."
03:49:45 <Veinor> @check \x -> (x || True)
03:49:46 <lambdabot>   "OK, passed 500 tests."
03:50:01 <tty7> mm_freak: what is the difference for other values?
03:50:06 <mauke> @check (||)
03:50:07 <lambdabot>   "Falsifiable, after 0 tests:\nFalse\nFalse\n"
03:50:59 <koeien> that might depend on the implementation
03:51:40 <w3rs> Hi! Is there a common type class for iterators involving IO? With methods like "next", "hasNext", "close"?
03:54:35 <koeien> w3rs: not that i know of. there is the iteratee package, which does this for some common IO operations
03:56:25 <aadrake> Good afternoon #haskell.  I have a set of type [[String]] that I would like to convert to [(String, Int)] where Int is the number of occurrences of String in [[String]].  Any suggestions?
03:56:29 <w3rs> koeien, is iteratee somehow related to "enumerator" package?
03:57:21 <Sgeo> w3rs, enumerator is one implementation of the iteratee concept, iteratee is another
03:58:48 <tty7> aadrake: doesn't it work to flatten [[String]] and then do map (\x -> (x, count x))?
03:59:08 <tty7> where count is a function that counts the occurences of String in [String]
03:59:33 <Veinor> @hoogle [a] -> a -> Integer
03:59:34 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
03:59:34 <lambdabot> Prelude (!!) :: [a] -> Int -> a
03:59:34 <lambdabot> Data.List (!!) :: [a] -> Int -> a
04:00:07 <mm_freak> tty7: i'm just saying that you shouldn't expect them to be the same, even in restricted domains
04:00:24 <Veinor> i'd do what tty7 said
04:00:25 <mm_freak> you're making an unsafe assumption there
04:00:57 <aadrake> tty7: That may work
04:01:11 <tty7> okay, mm_freak
04:01:23 <tty7> but i cannot decide which one to use then :P
04:03:04 <w3rs> koeien, Sgeo: thanks. I suppose it can be possible to use iteratee or enumerator datatypes somewhat similar to instancing the class. Though, I may copy the design of Java or C++ iterator classes
04:03:38 <tty7> aadrake: why do you actually have a [[String]] instead of a [String]?
04:05:58 <Sgeo> w3rs, I should point out that iteratee might be doing something that enumerator doesn't, particuarly with respect to your question
04:06:48 <tty7> @hoogle a -> [a] -> Integer
04:06:48 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
04:06:48 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
04:06:48 <lambdabot> Prelude asTypeOf :: a -> a -> a
04:07:00 <tty7> @hoogle a -> [a] -> Int
04:07:00 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
04:07:01 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
04:07:01 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
04:07:31 <tty7> is there a function in Data.List that counts the occurencies of an element in a list?
04:07:58 <tty7> or do i have to define it by myself / use something like "length . elemIndices"
04:08:08 <w3rs> aadrake, you may use intermediate "Map String Int" constructed with "insertWith (+)"
04:15:15 <tty7> aadrake: this looks like it could help you as well:
04:15:34 <tty7> http://learnyouahaskell.com/modules#data-list
04:15:55 <tty7> scroll down a while (or search on page for) sort and group
04:16:00 <tty7> there is this example:
04:16:12 <tty7> map¬†(\l@(x:xs)¬†->¬†(x,length¬†l))¬†.¬†group¬†.¬†sort¬†$¬†[1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]¬†¬†[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]¬†¬†
04:16:41 <sordina> Hey haskellers. I'm trying to run a small haskell package I've used before, but I'm getting some linking errors.
04:16:48 <tty7> if you flatten your list before and then use that function defined there, that should work as well
04:17:26 <sordina> I've written this package to install with cabal, and it's worked in the past, but now I'm havving issues with a module.
04:20:47 <sordina> https://github.com/sordina/Midi/blob/master/test/test6.hs is the example that's breaking when I try to build it outside of the package source.
04:24:56 <sordina> Could there be something that's required in my cabal file in relation to TimeSet?
04:27:19 <aleator> Hi. What does "(841) SYSTEM" mean in the profiling graphs?
04:30:28 <sordina> Ah that WAS it.
04:30:57 <sordina> I needed to add TimeSet to exposed_modules... Not sure why though as I don't want users to be able to interact with it...
04:37:17 <sordina> How you you supply multiple items for a .cabal/config attribute? extra-lib-dirs: /usr/lib,/opt/local/lib doesn't seem to cut it
04:42:04 * hackagebot BiobaseTurner 0.2.0.0 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.2.0.0 (ChristianHoener)
04:44:06 <fasta> How can one best scrape data from a website which requires JavaScript evalutation, pressing submit buttons, pressing links and finally extracting table fields?
04:44:35 <fasta> evaluation*
04:45:29 <Jafet> Reverse engineer the http requests
04:45:39 <Jafet> Then ignore the page and send your own
04:47:36 <fasta> Jafet: the disadvantage of that method is that they might change the implementation.
04:47:49 <koeien> that holds almost always
04:48:02 <koeien> the form fields might be renamed, for example
04:48:17 <Jafet> What if they redo the site in Silverlight!
04:48:41 <Jafet> /index.swf
04:48:42 <fasta> Jafet: then I think the problem would also be solved, but for other reasons.
04:49:02 <fasta> Jafet: them going out of business would be one of the reasons.
04:51:29 <fasta> Which library for sending https requests would you suggest?
04:51:49 <koeien> curl
04:53:14 <mm_freak> fasta: http-enumerator
04:53:17 <fasta> koeien: you mean the Haskell binding to curl, or just no Haskell at all?
04:53:37 <fasta> mm_freak: do you speak from experience or because you just want someone to use Haskell?
04:53:44 <mm_freak> experience
04:53:51 <sm> or http-conduit
04:54:05 <mm_freak> i'm using http-enumerator and i'm quite happy with it, although it seems like http-conduit is going to be the future
04:54:55 <mm_freak> http-enumerator has a more haskellish interface and gives you somewhat more flexibility like the ability to process the stream right away
05:08:42 <kuznero> Hi All!
05:08:46 <koeien> hello
05:13:51 <fasta> I use Haskell mode 2.8.0, but it doesn't work with GHC 7.2.2. Is this a known issue?
05:14:22 <fasta> I get 'Can't find the prompt'.
05:17:05 <cads> hi
05:17:15 <cads> having trouble installing gtk2hs
05:17:16 <cads> http://hpaste.org/56344
05:17:25 <cads> I'm in windows
05:18:06 <dcoutts> cads: "The pkg-config package glib-2.0 is required but it could not be found."
05:18:17 <dcoutts> this means the C library
05:18:32 <dcoutts> pkg-config is a system for configuring C libs
05:18:56 <dcoutts> cads: basically you need to go read the gtk2hs install instructions, the bit about installing the Gtk+ C libs first
05:21:38 <cads> yeah
05:21:41 <cads> hmm
05:22:21 <cads> I have gtk 2
05:22:27 <cads> where is haskell looking for it?
05:24:07 <Clint> cads: pkg-config is looking for a file named glib-2.0.pc somewhere in the depths of /usr
05:24:54 <cads> that's in C:\GTK\lib
05:25:38 <Sgeo> Under what circumstances may it be a mistake to use a TMVar?
05:26:00 <byorgey> bgamari: no, the diagrams library itself handles most of the geometry heavy-lifting, assuming I understand what you mean by that.
05:26:13 <Lemmih> Sgeo: When an MVar would do.
05:26:14 <byorgey> bgamari: i.e. the diagrams library calculates positions for everything etc.
05:29:04 <matthiasgorgens> Is there a standard fold (or similar) to run a list of actions [m (Maybe a)] and stop at the first Just?
05:30:05 <matthiasgorgens> (I can write it myself easily, but I thought there might be something in the standard libs.  The Maybe isn't necessary.  Either or Bool would also work.  Or something like the interface to unfold.)
05:30:16 <koeien> :t untilM
05:30:17 <lambdabot> Not in scope: `untilM'
05:30:20 <koeien> @hoogle untilM
05:30:21 <lambdabot> No results found
05:30:40 <koeien> monad-loop package or something
05:30:56 <matthiasgorgens> ok, thanks.
05:31:17 <matthiasgorgens> koeien: hayoo knows about it!
05:31:26 <koeien> yeah hayoo knows more than hoogle IME
05:32:19 <matthiasgorgens> yes.  only hoogle is smarter about what it knows, as far as i know.
05:33:11 <Sgeo> IMO they should be merged
05:33:22 <hpaste_> Cindy pasted ‚ÄúSSM‚Äù at http://hpaste.org/56345
05:33:34 <donri> hayoo indexes all of hackage, hoogle indexes type signatures more smartly
05:36:40 <matthiasgorgens> know I only need to persuade my co-workers that we need yet another library. ;o)
05:38:30 <dgpratt> matthiasgorgens: if you managed to convince your co-workers to use Haskell, that much should be easy
05:40:43 <donri> meh just use cabal and make sure to set strict version requirements
05:41:27 <donri> @where pvp
05:41:27 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
05:47:13 <fasta> How do I set the host name to use in some http request with http-conduits?
05:48:46 <koeien> according to the docs it's automagic
05:49:03 <fasta> koeien: the API is very misleading.
05:49:18 <fasta> koeien: they basically say use parseUrl (for basic stuff) or def
05:49:28 <fasta> koeien: but if you use def, there is no way to set it.
05:49:54 <Sgeo> If I retry after reading a TChan, is the TChan changed?
05:50:04 <fasta> koeien: where can I set the URL according to you?
05:50:18 <Lemmih> Sgeo: No.
05:50:43 <mm_freak> fasta: see the 'Request' type‚Ä¶  the haddocks are a bit misleading, because 'host' is not just a function
05:50:57 <koeien> fasta: i'm not sure, i just read that Host is set automatically :/
05:51:01 <mm_freak> it's actually a record field, so you can say:  myReq { host = "blah.blubb" }
05:51:02 <Sgeo> So then does waitForEvent here make any sense? http://hackage.haskell.org/packages/archive/monad-loops/latest/doc/html/src/Control-Monad-Loops-STM.html#waitForEvent
05:51:14 <Lemmih> Sgeo: Transactions are all or nothing.
05:51:15 <fasta> mm_freak: you can? I thought it wasn't exported.
05:51:41 <fasta> mm_freak: it even says so 'we do not export the constructor'.
05:51:49 <mm_freak> fasta: it is exported, but in the haddocks it looks like a regular function
05:52:04 <fasta> mm_freak: ok, and how am I supposed to guess that?
05:52:21 <mm_freak> fasta: apparently michael put something like "module X (Request, host, ‚Ä¶)" into the source code instead of just saying "module X (Request(..))"
05:52:30 <mm_freak> hence haddock prints 'host' as a regular function
05:52:48 <Lemmih> Sgeo: Consider two threads, one waiting for even numbers and one waiting for odd numbers.
05:52:49 <mm_freak> fasta: you aren't‚Ä¶  i found that out by trial and error
05:53:13 <Lemmih> Sgeo: 'waitForEvent' would fit nicely in that case.
05:53:15 <mm_freak> fasta: of course the proper way is to write a correct URL, then you don't have to deal with that manually
05:53:36 <Sgeo> Lemmih, what if I have one thread waiting for odd numbers, but even numbers are being written to the chan
05:53:39 <fasta> mm_freak: write a correct URL?
05:53:51 <fasta> mm_freak: how does that have anything to do with what you said?
05:54:44 <fasta> mm_freak: the set of arguments that are valid to send to urlEncodedBody is also not documented.
05:55:28 <Sgeo> @hoogle (a -> Bool) -> IO a -> IO a
05:55:28 <lambdabot> Foreign.Marshal.Error throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
05:55:28 <lambdabot> Foreign.C.Error throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
05:55:28 <lambdabot> Foreign.C.Error throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a
05:55:55 <wyfrn> hi all ... iam trying to write a monadic version of any (any :: (a - ut i gom Bool) -> [a] -> m Bool) as composition of prelude functions but i got stuck ... i think i need some help
05:56:17 <Lemmih> Sgeo: Then it waits forever.
05:56:28 <koeien> you mean any :: (a -> m Bool) -> [a] -> m Bool
05:56:29 <koeien> ?
05:56:32 <acowley> There really should be multiple levels in hackage so we can have a level where all packages have at least some threshold amount of documentation
05:57:01 <koeien> acowley: that would require a rating system/comments perhaps
05:57:22 <koeien> with star ratings in multiple categories
05:57:30 <mm_freak> fasta: if you don't want to use simpleHTTP, see the 'parseUrl' function
05:57:34 <acowley> yes, and automatic reporting of haddock coverage. This will never work because there are always exceptions, so people will argue interminably about appropriate metrics
05:57:49 <acowley> But I think we need some way to motivate library authors to document things
05:57:50 <mm_freak> fasta: that one builds a correct request according to the URL for you
05:58:05 <koeien> haddock coverage is a bit pointless
05:58:14 <mm_freak> fasta: that's how you're supposed to use Request, but you can also start from scratch using 'def' and the individual fields
05:58:20 <koeien> (imo) it can be documented poorly even with 100% coverage
05:58:33 <fasta> mm_freak: and an 'url' might contain url encoded data like foo?ax=b&x=1?
05:58:42 <acowley> It doesn't seem appropriate to resent freely-given open source code, so it would be nice if we could offer a carrot rather than an ad hoc public shaming stick
05:58:49 <acowley> koeien: but it's something
05:58:53 <mm_freak> koeien: haddock coverage is for the developer, not the user‚Ä¶  i like being able to see where i forgot to write a comment
05:59:03 <mm_freak> fasta: yes
05:59:13 <acowley> koeien: I think that's the kind of thing where user evaluations count for more
05:59:19 <koeien> mm_freak: yeah that's fine of course
05:59:28 <acowley> koeien: but if a package has 10% haddock coverage, then I'm suspicious from the get go
06:00:01 <acowley> koeien: But absolutely, if a package has 100% coverage and many users complain about documentation, it shouldn't get a free pass
06:00:33 <acowley> I just think situation's like fasta's here really stink, and the worst part is that we don't have any mechanism for making things better
06:02:34 <fasta> I also think that doing raw HTTP requests doesn't work for web-scraping.
06:03:11 <fasta> For the simple reason, that often the URL one is interested in is buried below a big pile of minified JS.
06:03:35 <fasta> (naturally -- just to make things easy -- this URL changes every single time)
06:05:21 <bmktuwien> @help
06:05:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:05:44 <bmktuwien> @list
06:05:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:06:16 <funktronic> @src ($)
06:06:16 <lambdabot> f $ x = f x
06:06:18 <rostayob> is there any released game built in haskell?
06:06:38 <mm_freak> fasta: it's usually still easier to build the request out of a base URL and then just modify the changing fields
06:08:01 <sipa> rostayob: the hedgewars server is written in haskell iirc
06:08:11 <sipa> not the game itself, though
06:08:36 <donri> wasn't someone porting their python minecraft server to haskell
06:09:23 <fasta> mm_freak: I think the visited page stored some data sent by the server which is different every single time, then a form has to be filled in with user name and password, when this is submitted I see in the headers that some strings are also being send, which I didn't input. So, I don't see how just one or two http requests without evaluating JS exactly like the browser would do, would work.
06:09:33 <eulyix> Hi, I'm struggling to figure out why I'm getting a syntax error. This is probably really silly, but here goes!
06:09:34 <eulyix> http://hpaste.org/56349
06:09:40 <kleini_> I found a dead link on http://www.haskell.org/haskellwiki/Monad#Fun , is it okay to mention that here?
06:09:47 <rostayob> sipa: I'm interested to know if it's feasible to do the actual game in Haskell
06:10:08 <koeien> eulyix: i think you mean table and stm to begin in the same column
06:10:13 <rostayob> me and my friend want to do a little game, and we're fighting, he wants C++ and I want Haskell
06:10:18 <koeien> so align them
06:10:27 <rostayob> we both love Haskell but he things it's not adequate for gamedev
06:11:11 <eulyix> koeien,  Ah! Thanks for that. I've spent half an hour wondering what the problem was :$
06:11:18 <acowley> rostayob: Then his love is superficial. Haskell rewards deep love.
06:11:23 <Starfire> rostayob: Probably depends on the game.
06:11:29 <rostayob> Starfire: a 2D platformer
06:11:31 <koeien> eulyix: "syntax error" is generally unmatched parens or this problem
06:11:45 <koeien> (IME)
06:11:55 <Starfire> rostayob: If it's not performance sensitive, then I think Haskell would be great.
06:12:11 <donri> define adequate
06:12:15 <acowley> if it is performance sensitive, then I think Haskell would be great
06:12:16 <eulyix> I thought that because the "=" symbols were aligned, I was in the clear. :) I'll know next time.
06:12:29 <rostayob> Starfire: well performance shouldn't be a problem with haskell
06:12:37 <rostayob> we were more worried about the quality of the libraries
06:12:45 <Starfire> Not performance as such, but I imagine there would a problems with unexpected GC pauses.
06:12:47 <acowley> rostayob: You can always FFI if you find something not working
06:12:58 <rostayob> acowley: true, but we don't want to spend time doing that.
06:13:14 <rostayob> i mean if you find yourself FFIing for a lot of thing
06:13:16 <rostayob> s
06:13:18 <acowley> people are too wary of the FFI
06:13:42 <rostayob> acowley: I've written various bindings and i just don't want to spend time thinking how to write nice wrappers
06:13:46 <rostayob> which is not an easy task
06:13:54 <Starfire> If you're going to do a lot of FFI anyway, why use Haskell in the first place?
06:14:12 <acowley> I'm not suggesting you write the game in C++ then wrappers so you can run it from Haskell
06:14:13 <koeien> Starfire: because of various reasons, it's nicer to work with, you have a REPL.
06:14:15 <acowley> just casual FFI
06:14:26 <Itkovian> What is the preferred way to return lists of key-value pairs? a simple associative list, or a Map?
06:14:28 <rostayob> acowley: "casual" doen't really appy to big libraries
06:14:30 <acowley> Starfire: take a look at any high level graphics library
06:14:33 <Starfire> koeien: But you don't have either of those for the FFI stuff anyway.
06:14:38 <donri> games in c++ have been done before, wouldn't it be more interesting to do it in haskell?
06:14:42 <koeien> Starfire: sure you do
06:14:56 <donri> or is the game more interesting than the development of it?
06:15:07 <rostayob> donri: yeah the the thing is that the main interest in this case is the game design more than the programming
06:15:08 <koeien> Itkovian: both suffice, depends on the exact situation
06:15:17 <mm_freak> fasta: sounds like you want to watch out for cookies
06:15:18 <Starfire> I think Haskell would be excellent as a Lua replacement.
06:15:30 <rostayob> Starfire: lua and haskell are completely different.
06:15:36 <koeien> that's a weird statement
06:15:38 <acowley> rostayob: The idea is not to wrap the library, but wrap an entire subsystem of your game. For instance, write a manually memore managed system in C++, then update it with an FFI call from your main game loop.
06:16:01 <rostayob> acowley: so you're saying "do all the logic in haskell and then draw in C++"?
06:16:02 <Starfire> rostayob: Of course, but they can still fulfill the same purpose.
06:16:07 <mm_freak> Starfire: if you (ab-) use lua for application development, definitely
06:16:12 <acowley> rostayob: No, I think drawing in Haskell is plenty fast
06:16:21 <mm_freak> i'd love to use agda as a scripting language
06:16:24 <Starfire> That probably depends on what is "plenty fast".
06:16:38 <acowley> rostayob: There's a good chance you won't need any FFI at all, it's just a localized fallback if it becomes necessary.
06:16:46 <merijn> mm_freak: Yeah, but that's because haskell has rotted your brain :D
06:16:48 <rostayob> ok: my (and his) worries here are that we won't find high-quality graphics and phisics libraries libraries.
06:17:02 <rostayob> so let me re-phrase: are there high quality, mantained libraries to do such things?
06:17:04 <mm_freak> merijn: you would do application development in lua?
06:17:05 <Starfire> When you start talking about stuff that requires optimized cache patterns and predictable 60 fps, I guess you would spend a lot of time fighting Haskell instead of benefiting from it.
06:17:10 <mm_freak> merijn: independent of haskell
06:17:14 <rostayob> is SDL for haskell mantained and used by people, for example?
06:17:21 <fasta> mm_freak: the word 'cookie' doesn't exist in http-conduit documentation.
06:17:36 <rostayob> same question for hipmunk
06:17:38 <acowley> Starfire: drawing is loading a ton of vertex data, then making very few GL calls each frame. 99% of your time is spent in the GL driver.
06:17:41 <rostayob> are there any games that use those libraries?
06:17:46 <merijn> mm_freak: Probably not, because I'm not too familiar with Lua. Depends on the application
06:18:11 <fasta> acowley: have you actually written a game?
06:18:16 <fasta> acowley: (in Haskell)
06:18:17 <acowley> fasta: Yes, but in C++
06:18:18 <Entroacceptor> someone just published a Ogre3d-binding
06:18:20 <acowley> :)
06:18:25 <merijn> mm_freak: My one experience with Lua is the WoW user interface, where I would definitely prefer Lua over Haskell
06:18:28 <koeien> acowley: yup, optimally you will do GL calls that take relatively long
06:18:32 <fasta> acowley: then I think you shouldn't give advice like that.
06:18:34 <acowley> fasta: I do a fair bit of visualization work now, and I do it all in Haskell
06:19:05 <acowley> fasta: if I was doing a game today, I'd certainly thoroughly evaluate doing it in Haskell
06:19:09 <rostayob> the best thing here would be a link of a released game in haskell
06:19:13 <fasta> A 2D game is entirely possible in Haskell now, 3D too, but a 3D Crysis, not so much.
06:19:14 <Starfire> I don't think anyone has made a high performance game in Haskell.
06:19:16 <rostayob> has anyone done that?
06:19:25 <acowley> a 3D Crysis in Haskell won't happen
06:19:26 <rostayob> even a simple platformer
06:19:29 <acowley> not today
06:19:31 <fasta> rostayob: 2D platform game has been done.
06:19:37 <rostayob> fasta: link?
06:19:40 <acowley> rostayob: yes, Niki and the Robots (or something like that)
06:19:41 <merijn> rostayob: I knew people were working on a game implemented using FRP
06:19:45 <rostayob> acowley: that's not released
06:19:48 <merijn> Forgot the name, though
06:19:50 <Starfire> I would be really interested in using Haskell as an embedded scripting language.
06:19:51 <rostayob> they just have some alpha
06:20:14 <Starfire> But I have the impression that it's somewhat inconvient (though possible) at the moment.
06:20:25 <Clint> acowley: nikki
06:20:31 <Entroacceptor> there's rainkitten
06:20:53 <fasta> rostayob: there is definitely more 'risk' involved in building a Haskell game.
06:20:56 <Entroacceptor> *raincat
06:21:03 <acowley> rostayob: there aren't (m)any games written in Haskell that are for sale
06:21:07 <acowley> rostayob: but there are games in slower languages
06:21:11 <rostayob> fasta: why? considering that we're both experienced haskell programmers?
06:21:16 <fasta> rostayob: especially, if you have to ask.
06:21:21 <mm_freak> fasta: you have to use the web-cookie package and add the cookie headers
06:21:21 <fasta> rostayob: what is experienced?
06:21:23 <Starfire> Having a library like luabind or Boost.Python for Haskell integration would be super cool.
06:21:24 <acowley> rostayob: there's at least one commercial game written in Scheme
06:21:31 <rostayob> acowley: i'm not worried about performance at all, i'm worried about tools
06:21:33 <mm_freak> fasta: web-cookie works well with http-conduit/http-enumerator
06:21:39 <merijn> rostayob: Bite the bullet for people like me who want to program games in Haskell when they have more time :p
06:21:44 <rostayob> fasta: years of free time spent coding in haskell :P
06:21:46 <koeien> Starfire: you can export haskell functions, via the FFI
06:21:47 <mm_freak> merijn: because of the predefined stuff?
06:22:01 <Starfire> koeien: You can, but I think there's plenty of manual work involved.
06:22:08 <fasta> rostayob: you could also just demo it to your friend.
06:22:09 <merijn> mm_freak: What do you mean by predefined?
06:22:13 <Starfire> koeien: And doesn't it require you to link using GHC?
06:22:16 <rostayob> fasta: demo what?
06:22:17 <acowley> rostayob: Well, I'm not going to argue that you will have trouble there
06:22:19 <fasta> rostayob: just show something you made within X hours/days.
06:22:28 <fasta> rostayob: that might convince him that it is feasible.
06:22:39 <koeien> Starfire: yeah it's bulky.
06:22:40 <rostayob> no but he knows that you can draw stuff on the screen in haskell. he wrote a bittorrent client in haskell
06:23:00 <rostayob> but he's worried that doing a semi-serious game in haskell might bring troubles
06:23:01 <fasta> rostayob: and remember; you can call C++ from Haskell.
06:23:19 <rostayob> fasta: wrapping it in C first, it's a pita
06:23:20 <acowley> rostayob: but I think rather than ask about commercial games written in Haskell (which there aren't), you should focus on the more specific bindings you think you want (like chipmunk and SDL, as you mentioned)
06:23:29 <fasta> rostayob: yes, but you could automate that.
06:23:40 <rostayob> fasta: but we don't want to. we don't want to lose time on things like that
06:23:55 <rostayob> acowley: yeah but how can i evaluate those libraries? are people using them?
06:23:57 <fasta> rostayob: then pick libraries first.
06:24:05 <fasta> rostayob: if one of them is not in Haskell, pick C++.
06:24:06 <rostayob> fasta: i picked already
06:24:13 <acowley> A frustrating thing about adopting another language in order to get at a nicer binding for a particular library is that you leave behind the rest of hackage with all its fantastic data structures
06:24:13 <rostayob> fasta: SDL and hipmunk
06:24:22 <fasta> rostayob: so, that should work then, right?
06:24:40 <rostayob> fasta: what if the libraries are unmantained? or simply crap?
06:24:48 <rostayob> or undocumented?
06:24:50 <rostayob> or incomplete?
06:24:56 <fasta> rostayob: that might also be a good reason to use C++
06:25:04 <rostayob> yeah but I'd like to know if that is the case :P
06:25:16 <rostayob> without losing two weeks finding by myself the hard way
06:25:18 <acowley> rostayob: I used SDL once several years ago. It worked, but I've never used it regularly
06:25:38 <rostayob> i get the impression that those libs are written for kicks by people like me :P
06:25:41 <mm_freak> merijn: i have no experience with WoW
06:25:44 <rostayob> just to write something cool
06:25:50 <acowley> rostayob: You are likely correct
06:25:53 <mm_freak> merijn: why is lua better than haskell for this WoW stuff, whatever that is?
06:25:58 <fasta> mm_freak: you meant 'cookie'?
06:26:01 <fasta> mm_freak: not 'web-cookie'?
06:26:23 <rostayob> acowley: yeah, in that case they probably aren't used in the real world
06:26:37 <acowley> rostayob: but I think that's not a helpful way to look at things
06:26:44 <acowley> rostayob: if the libraries work, then they work
06:26:48 <Clint> it's trivial to embed a lua interpreter in your program, and it's small
06:26:59 <acowley> rostayob: if you try to use the SDL library, and spend two days but it sucks, then give up on it and move on
06:27:07 <rostayob> acowley: again, the problem here is that i'm not interested in the programming, but more in the "making a game" part
06:27:14 <rostayob> so i don't want to lose time on those things
06:27:27 <rostayob> with C++ i know i'm safe, i want to know how much of a risk haskell is
06:27:39 <acowley> rostayob: yeah, I understand, but I think it's worth spending a little time (day(s), not weeks) seeing how things stand
06:27:51 <rostayob> acowley: yeah, that's what i'm doing right now :)
06:28:10 <rostayob> the fact that there are no playable games in haskell at all kind of worries me
06:28:12 <DukeDave> Wrapping C++ with C to use the FFI is a pain I'm discovering now with wxHaskell (I've recently become something of a maintainer)
06:28:19 <acowley> rostayob: then I say, decide if you really need SDL or if OpenGL+ImageLoader+Audio library would work
06:28:31 <acowley> rostayob: then see if hipmunk is plausible
06:28:42 <merijn> mm_freak: The game engine doesn't really have a user interface, just an API for for hooking events and running sandboxed Lua which implements the actual UI. This means people can easily hack together their own interfaces. People usually combine all sorts of mods together to create a user interface. The advantage of Lua here is the ability to hijack and modify the state of any other code running. Some complicated module doesn't quite do what I
06:28:42 <merijn> want? Hook/replace some stuff and be able to reuse the rest without work
06:28:48 <koeien> DukeDave: Using C++ is a pain in most languages
06:28:52 <rostayob> acowley: yeah OpenGL + stuff would work. i've already written OpenGL. are the OpenGL bindings better?
06:29:02 <acowley> rostayob: No, they're not
06:29:11 <acowley> rostayob: But they work
06:29:20 <merijn> mm_freak: Haskell's safety and lack of state would mean I'd have to redesign/rewrite or otherwise majorly restructure existing code, without any clear benefit
06:29:42 <acowley> rostayob: The only problem with them, other than that they're not particularly Haskelly, is that they are somewhat out of date if you need access to newer features.
06:29:49 <rostayob> mhm.
06:30:00 <merijn> mm_freak: Sure, the haskell UI might have less bugs, but in the grand scheme of things anything that doesn't bug out more then once every other day or so is irrelevant
06:30:04 <rostayob> btw, is there any other language that is gaining acceptance in the gamedev community?
06:30:10 <acowley> rostayob: However, sometimes their non-Haskelly nature is a virtue as it means you can directly adapt C code you find online.
06:30:14 <rostayob> not to script the game, to write the entire thing
06:30:16 <funktronic> rostayob: i hear C++ is pretty popular
06:30:16 <DukeDave> Something to satisfy this would get us a long way: http://stackoverflow.com/questions/1067278/generate-c-wrapper-from-c
06:30:18 <rostayob> acowley: that's very true
06:30:22 <rostayob> funktronic: yeah apart from that
06:30:30 <funktronic> lua?
06:30:35 <merijn> rostayob: Python maybe? Significant parts of Eve are written in Lua
06:30:35 <rostayob> lua is used for scripting
06:30:37 <merijn> eh
06:30:39 <merijn> python
06:30:43 <funktronic> and of course node.js and ruby
06:30:52 <rostayob> they've written entire games in python?
06:30:59 <rostayob> all these languages are used to script actions afaik
06:31:01 <acowley> rostayob: People still use C++ and Lua for scripting, but you've got Sweeney and Carmack both publically threatening to use Haskell over the past few years.
06:31:11 <ben_m> "threatening" :D
06:31:19 <rostayob> acowley: why wouldn't they just use it?
06:31:20 <Starfire> I think one of the selling points of Lua is that you have pretty good control over its GC.
06:31:24 <acowley> rostayob: Commercial games have been written in practically every language (other than Haskell...ahem)
06:31:26 <funktronic> they would but something about "developers aren't cool enough for haskell"
06:31:27 <rostayob> i think they just want to complain in an original way
06:31:31 <merijn> rostayob: Hold on, lemme look up
06:31:32 <Starfire> So you can actually use it in a real time environment.
06:31:37 <acowley> rostayob: same concerns you have and general FP performance fear!
06:31:49 <merijn> rostayob: One of them had a nice presentation about what they want for game programming (and why not haskell)
06:31:50 <Starfire> I'm not sure how much control you have over the Haskell GC. I think there's some?
06:32:24 <rostayob> my problem is that C++ sucks. it really sucks
06:32:27 <rostayob> i'd even prefer java
06:32:48 <rostayob> but it's depressing, C++ seems totally dominant in gamedev
06:32:48 <Starfire> I'd definitely prefer C++ over Java.
06:32:55 <srhb> rostayob: Every time utters that sentence, a kitten dies.
06:33:03 <srhb> someone*
06:33:04 <rostayob> srhb: what sentence? java?
06:33:08 <funktronic> i'd prefer java over C++
06:33:09 <acowley> The GC can be a problem, but you can write Haskell that minimizes GC stress by not allocating (much), and it's the kind of thing I'd be willing to accept if this is just a game I'd be releasing for free
06:33:12 <srhb> "I'd even prefer java"
06:33:13 <rostayob> java is a *far* better language than C++
06:33:19 <Starfire> I disagree!
06:33:21 <funktronic> and my job is all C++
06:33:28 <acowley> rostayob: You could take a look at C# then, the XBLA stuff has what you want
06:33:28 <rostayob> is that even correct english? boh
06:33:34 <rostayob> acowley: windows...
06:33:38 <funktronic> C# is much better than either java or C++
06:33:39 <acowley> rostayob: Mono has a port of parts of XNA
06:33:47 <funktronic> C# even has currying so there's that
06:33:59 <rostayob> acowley: we're back to uncertainty and fear
06:34:00 * funktronic judges languages by their curry
06:34:14 <rostayob> funktronic: all languages with first order functions have currying
06:34:20 <rostayob> first clas
06:34:24 <rostayob> s
06:34:24 <rostayob> well, closures
06:34:26 <acowley> rostayob: You are a perpetual victim of uncertainty and fear. If you had simply accepted my immediate Haskell bravado, this would all be much simpler (for now). :P
06:34:37 <rostayob> acowley: i would. but i have to convince my friend
06:35:00 <rostayob> and he's right in many ways anyway
06:35:09 <acowley> rostayob: It's worth checking out the Mono XNA forums to see what people are doing.
06:35:29 <ben_m> Clojure is a nice middle ground
06:35:34 <acowley> rostayob: he's right if you're making a big investment and are less concerned about enjoying the process
06:35:47 <ben_m> But game development in Haskell is pretty cool
06:35:52 <rostayob> acowley: we're not. it's a hobby thing. but we're both concerned about making a game
06:35:58 <rostayob> and also, programming is fun anyways
06:36:06 <merijn> rostayob: Found the presentation. "The Next Mainstream Programming Language: A Game Developers Perspective", by Epic's Time Sweeney - http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
06:36:21 <ben_m> rostayob, Just convince him that it'll be a new learning experience. Even if you make your next game in C++, you'll learn tons by making one in Haskell
06:36:28 <merijn> rostayob: His main point against haskell seems to be that lenient rather than lazy is the best default
06:36:45 <merijn> rostayob: He also argues in favour of (at least *some*) dependent types
06:36:47 <rostayob> ben_m: Haskell is our language of choice already
06:36:52 <rostayob> i mean we know haskell already :P
06:37:09 <merijn> rostayob: Fairly interesting slides, even without the talk
06:37:15 <rostayob> merijn: thanks  for the slides
06:37:21 <rostayob> COMIC SANS
06:37:22 <ben_m> rostayob, wasn't implying you don't
06:38:06 <rostayob> ben_m: well i doubt we can learn much about haskell, the language, when developing a game
06:38:09 <ben_m> But if you take your time and write idiomatic Haskell, you'll come up with new techniques for game dev that you might want to employ in a C++ game too
06:38:19 <mm_freak> fasta: oh yes, sorry‚Ä¶  confused module name with package name =)
06:38:43 <mm_freak> merijn: that's not true‚Ä¶  in fact haskell has great abstractions for /local/ state, which other languages lack
06:38:45 <erus`> i wish you could have type statements inside a where
06:38:59 <silver> you can
06:39:21 <silver> but you'll need ScopedTypeVariables or something like that
06:39:53 <erus`> aha
06:40:01 <acowley> I learn about Haskell pretty much every program I write
06:40:31 <erus`> silver no i mean like  'type blah = blue'
06:40:37 <ben_m> rostayob, Check out Functional Reactive Programming for game dev, if you haven't already
06:40:56 <rostayob> ben_m: uff, we don't want to do a research project, we want to code a simple 2D platformer :P
06:41:07 <rostayob> merijn: yeah that talk is quite futuristic, dependent types etc
06:41:22 <silver> erus`, oohh
06:43:49 <merijn> I don't suppose POPL talks like that one are online somewhere?
06:43:55 <mrcarrot> i really hate cabal install. really! i have not had success with even one program from hackage, without a lot of tweaking
06:44:18 <mrcarrot> i was curious about leksah. i had to handpick the versions with cabal to get it to install
06:44:52 <mrcarrot> i was today again curious about manatee... but no way to get it to install because of cabal, without a lot of tweaking
06:45:04 <mrcarrot> curl was not getting installed without hacking
06:45:07 <acowley> rostayob: at the end of the day, a lot of Haskell programming has elements of a research project. For some folks, that holds great appeal. But if instead that is offputting, then arguing for Haskell over C++ in general terms will be difficult.
06:45:37 <rostayob> acowley: doing something innovative and researchy on the programming side is usually really cool
06:45:51 <rostayob> but this time we're concerned about other sides of the process, that's all
06:46:14 <DukeDave> I found that knowing Haskell was quite destructive when I worked all day with C++ in the games industry.
06:46:14 <DukeDave> As a result of my desire Haskell-esque elegance I employed a lot of template meta-programming; this was great for the me and the few people who were comfortable with such approaches, but most people simply complained that the code "unreadable".
06:46:32 <rostayob> DukeDave: templates can lead to horrible things.
06:46:49 <rostayob> and inevitably lead to incredibly horrible compiler errors.
06:47:00 <rostayob> they're probably the worst way to parametrize types
06:47:03 <DukeDave> rostayob: Yeah, I found myself giving up and going 'back to basics', it didn't feel like 'the correct approach' though.
06:47:05 <rostayob> but in C++...
06:47:20 <rostayob> DukeDave: wait you work in the game industry?
06:47:29 <DukeDave> rostayob: Worked
06:47:36 <rostayob> DukeDave: so tell us, is haskell ready?
06:48:20 <DukeDave> rostayob: IMHO: It's not ready in the same way that Linux is 'not ready'
06:48:33 <rostayob> DukeDave: wait, linux is ready
06:48:35 <mrcarrot> haskell is ready for much, but not the tools like cabal, and not the libraries on hackage. they are far from ready.
06:48:53 <rostayob> mrcarrot: i never doubted haskell, the language :)
06:48:59 <DukeDave> rostayob: Then why isn't it being adopted by companies?
06:49:11 <DukeDave> That's how I feel about Haskell
06:49:19 <rostayob> DukeDave: because companies are slow
06:49:26 <rostayob> because managers are silly, etc.
06:49:29 <DukeDave> Yes!
06:49:35 <rostayob> but the thing is, they're not even doing indie games in haskell!
06:49:35 <DukeDave> I would say that people are the problem..
06:49:40 <rostayob> so that worries me
06:49:48 <DukeDave> rostayob: Well, there's a couple of startups isn't there?
06:49:59 <rostayob> DukeDave: nothing ready, just some demos
06:50:03 <tty7> is anybody here who ever tried to implement the sieve of atkin in haskell?
06:50:07 <merijn> rostayob: Haskell only recently started getting hyped
06:50:32 <rostayob> merijn: well.. i'd say 4/5 years ago, no?
06:50:36 <merijn> rostayob: The community is still very many academics, which I guess are less interested in writing games than say the average 16-25 yer old python hacker
06:50:38 <earthy> no
06:50:57 <earthy> hype 'round haskell is the last 2, maybe 3 years
06:51:00 <DukeDave> rostayob: There's a company doing an iPhone game in Haskell, I think
06:51:07 <merijn> rostayob: Maybe, but it has not gotten close to the python and ruby hype levels
06:51:08 <rostayob> DukeDave: yes, Cale works for them
06:52:00 <greglnelson> hi, i'm just learning haskell, i'm looking for a way to log everything i type into the interpreter (GHCi), have googled to no avail. maybe some kind of shell script i can use on linux to wrap ghci command and write out input to it to a file?
06:52:11 <koeien> in linux, use typescript.
06:52:12 <DukeDave> rostayob: Who are they? Google isn't helping :(
06:52:15 <rostayob> greglnelson: ghci already has a history
06:52:17 <dcoutts> rostayob: I know some indie game companies which have been seriously considering it
06:52:17 <rostayob> DukeDave: iPwnStudios
06:52:27 <DukeDave> That's it!
06:52:32 <rostayob> dcoutts: yeah, still there is nothing around, i just don't want to be the first
06:52:37 <koeien> sorry, script
06:52:48 <rostayob> greglnelson: ghci already has a limited history
06:52:59 <greglnelson> rostayob: a startup called silk uses haskell as back end, really interesting, here's their blog http://blog.silkapp.com/
06:53:08 <dcoutts> rostayob: iPwn are not the only ones
06:53:23 <rostayob> dcoutts: who else?
06:53:24 <dcoutts> nor are they the only ones targeting iphone
06:53:24 <merijn> rostayob: Why not? You're an experienced haskell and motivated. Do the hard work for the rest of us who aren't hardcore! ;)
06:53:47 <rostayob> merijn: the other half knows is an hardcore haskeller as well
06:54:19 <dcoutts> rostayob: sorry, confidentiality, lemme see if I can find anything public
06:54:37 <merijn> rostayob: So what's your excuse? :p
06:55:04 <rostayob> merijn: i've articulated the excuses in the past 20 mins :P
06:55:39 <rostayob> mainly, we don't want to worry about crappy/unmantained libs, we just want to focus on designing the game
06:55:51 <dcoutts> rostayob: sorry, can't find anything public
06:56:15 <fasta> What is the point of the 'base' monad?
06:56:17 <rostayob> dcoutts: so there's no one who has *completed* a game in haskell
06:56:27 <rostayob> fasta: base? you mean Identity?
06:56:34 <fasta> rostayob: no, I mean base.
06:56:44 <rostayob> fasta: oh. i don't know about that monad.
06:56:46 <dcoutts> rostayob: the other game company I was thinking of doesn't make whole games, it makes tech to integrate into games
06:56:54 <fasta> http://hackage.haskell.org/package/transformers-base-0.4.1
06:57:34 <fasta> mm_freak: what is the point of liftBase?
06:57:43 <quicksilver> fasta: same as liftIO but generalised
06:57:46 <Saizan> noone remembers bloxors and the one with the kitten, and the tetris clones
06:58:01 <rostayob> Saizan: because those are demos
06:58:04 <fasta> quicksilver: didn't we have lift already for that?
06:58:13 <quicksilver> fasta: lift only ever does one level.
06:58:29 <quicksilver> fasta: liftIO is "lift . lift . lift . lift . lift" the correct number of times to reach the IO at the bottom.
06:58:31 <fasta> quicksilver: so, lift does it across more than one level?
06:58:41 <quicksilver> listBase is the generalisation of liftIO.
06:58:42 <fasta> er liftBase
06:58:46 <fasta> quicksilver: ok
06:59:00 <dcoutts> rostayob: if you decide to give it a shot and want some backup/advice/etc you can get in touch with us, duncan@well-typed.com
06:59:08 <fasta> quicksilver: so, it basically removes redundancy.
06:59:23 <rostayob> dcoutts: it's not a serious project, and i don't think i could afford to hire you guys :)
06:59:31 <fasta> quicksilver: for the implementor of the monad transformer.
07:00:13 <greglnelson> rostayob: thanks, had older version of ghci w bug that didn't create the log file directory, did it and working now, thanks!
07:00:44 <quicksilver> fasta: it also gives you a little more abstraction - you don't have to change your lifts just because you added one more layer (or removed one) from the tower
07:01:03 <fasta> quicksilver: yeah, but you still need write the instance somewhere, right?
07:01:05 <dcoutts> rostayob: not as full time hackers, most efficient would be advice, we have arrangements like that with other small companies using Haskell
07:01:44 <rostayob> dcoutts: it's really not a serious project. just an idea we had for a while and we have some time now
07:01:47 <fasta> quicksilver: in a typical monad transformer implementation, you would have a liftMyTransformer = lift . lift . lift .lift -- boring function anyway.
07:01:53 <quicksilver> fasta: yes.
07:01:58 <dcoutts> rostayob: well, when you get your investors ;-)
07:02:09 <rostayob> or you should have a class MonadFoo and you call the functions directly
07:02:11 <rostayob> dcoutts: eheh
07:02:40 <dcoutts> rostayob: what platform are you thinking of targeting btw?
07:02:53 <DukeDave> I think the best approach at the moment is the situation I'm in, where I work on oDesk for someone who's writing a Haskell application which uses wxHaskell; so now I'm maintaining wxHaskell..
07:03:24 <rostayob> good 'ol computers. we wanted xbox live as well, but we have to use XNA for that if i understand correctly, and that's not an option
07:03:30 <DukeDave> I.e. If Haskell is to become widely used it will be through an open-source approach to get our libs up to standard
07:04:04 <DukeDave> And, given the work on hackage and cabal, we really don't have an excuse not to be maintaining them..
07:04:06 <DukeDave> (imho)
07:04:42 <quicksilver> rostayob: MonadFoo is for the transformers in the stack; liftBase is for the base of the stack.
07:04:53 * dcoutts looks forward to the bright new future when hackage will host build and testsuite results
07:05:09 <rostayob> quicksilver: why? MonadFoo would cover if Foo is the base as well
07:05:31 <rostayob> quicksilver: having base = FooT Identity
07:05:37 <rostayob> i mean that's how all the mtl business works
07:05:46 <quicksilver> rostayob: not all Base are of the form FooT Identity
07:05:51 <quicksilver> rostayob: the interesting ones are not.
07:05:54 <quicksilver> ST, IO, etc.
07:05:57 <rostayob> quicksilver: fair enough.
07:06:02 <quicksilver> that's the case this is about.
07:06:09 <rostayob> oh, I didn't get that
07:06:27 <rostayob> quicksilver: where interesting = magic :)
07:06:37 <quicksilver> doesn't have to be magic.
07:06:42 <quicksilver> it just happens that those are.
07:06:53 <rostayob> if it's not magic, you could probably define it as a transformer
07:13:57 <roconnor> this year is a leap year
07:14:44 <byorgey> so it is!  There will also be a leap second in June or July or something like that.
07:15:43 <yrlnry> I thought they only put it at the end of June if there was also going to be one at the end of December.
07:16:24 <tty7> would be fun to have one or two leap seconds on 12/31 at 23:59:59 :D
07:16:47 <byorgey> three! two! one! ...one! ...... happy new year!
07:16:57 <DukeDave> Haha
07:16:59 <tty7> yeah, like that
07:17:20 <byorgey> yrlnry: the chart at http://en.wikipedia.org/wiki/Leap_second  seems to suggest otherwise
07:17:35 <DukeDave> Ooh, I'd like a leap second one the boundary of daylight savings time
07:17:36 <yrlnry> Wikipedia is probably more reliable than I am.
07:17:47 <DukeDave> I bet that would catch some fun edge cases :)
07:17:58 <tty7> and - assuming that there wouldn't be a media hype - everyone will be confused at new years eve
07:18:13 <tty7> hehe, DukeDave :D
07:18:20 <tty7> that would be cool as well
07:18:51 <byorgey> apparently, the end of December 31 IS exactly when leap seconds are added.
07:19:05 <byorgey> and also the end of June 30.
07:19:13 <tty7> :]
07:19:29 <byorgey> Not sure why I didn't know about this on new year's eve 2005 or 2008
07:41:53 <erus`> how does one descript 1.58 the second time it comes round when the clocks go back for DST?
07:42:01 <erus`> describe*
07:44:11 <tty7> hum..
07:44:19 <tty7> i have to do the following:
07:44:50 <tty7> i have a list of [(Integer, Bool)], where the Int's go from 1 to Infinity and are ordered
07:45:14 <tty7> so map (\x -> (x, f x)) [1..] for some f
07:45:44 <tty7> and now i have to run through that list from the beginning
07:46:20 <tty7> and everytime i find a (n, True), i have to replace all the (k * n^2, True) with (k * n^2, False)
07:46:43 <tty7> is there an elegant way to do that in haskell?
07:46:48 <ben_m> What's k?
07:46:51 <koeien> where k runs through the integers?
07:47:03 <tty7> (or even a not-so-elegant way, i cannot find any so far)
07:47:09 <tty7> yep, k runs through the integers
07:47:28 <koeien> yes, you can do that.
07:47:52 <tty7> i think it wont really work with the infinite list, because both the list and k <- [1..] is infinite
07:48:06 <tty7> although the laziness may help
07:48:08 <ben_m> Isn't k == n?
07:48:13 <koeien> no
07:48:15 <tty7> not necessarily
07:48:16 <ben_m> Or am I misunderstanding things?
07:48:22 <tty7> its the sieve of atkin, btw
07:48:30 <tty7> http://en.wikipedia.org/wiki/Sieve_of_Atkin
07:48:30 <mee> anyone got a recommendation for a library for doing simple parsing of a xhtml 1.0 transitional document? Trying to simply pull all attr values for specific children of a given element. Document format might change underneath me so I'd prefer to do things as loosely as possible
07:48:33 <tty7> steps 4 to 8
07:48:37 <koeien> tty7 means if you encounter (2, True), we need to unset (4, ) (8, ) (12, ) and so on
07:48:45 <ben_m> Ah :)
07:48:49 <koeien> since 2^2 == 4
07:48:59 <ben_m> I got it when he mentioned the sieve
07:49:21 <tty7> yep
07:49:40 <tty7> all the multiples of square numbers have to be changed to (n, False) in fact
07:49:58 * hackagebot websockets 0.5.1.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.5.1.0 (JasperVanDerJeugt)
07:49:59 <koeien> runthrough ((n, True):xs) = (n, True): runthrough (switchoff (n^2) xs)
07:50:11 <koeien> where we assume n^2 > n, so n > 1
07:50:17 <tty7> it would also work to do that for *all* the squares, but it is enough to do it for p^2 where (p, True) is in the list
07:50:22 <koeien> (if you start at 1 obviously the problem is trivial)
07:50:52 <tty7> yeah, assuming n > 1 is no real problem
07:51:01 <fasta> mm_freak: is there no way to show a request such that I can compare it with what the browser is sending?
07:51:07 <tty7> @hoogle runthrough
07:51:07 <lambdabot> No results found
07:51:14 <koeien> fasta: wireshark
07:51:16 <tty7> @hoogle switchoff
07:51:17 <lambdabot> No results found
07:51:33 <tty7> > :t runthrough
07:51:34 <lambdabot>   <no location info>: parse error on input `:'
07:51:42 <koeien> tty7: it's not a standard function
07:51:46 <fasta> koeien: I mean the ones I am constructing myself.
07:52:00 <fasta> koeien: while wireshark could also do that, it seems overkill.
07:52:00 <koeien> they are also going over the wire, no?
07:52:16 <koeien> fasta: netcat
07:53:53 <koeien> tty7: and switchoff n ((x,b):xs) | mod x n == 0 = (x, False): switchoff xs      | otherwise (x,b):switchoff xs
07:54:00 <koeien> (better written as a map)
07:54:28 <fasta> koeien: does that also work for https?
07:54:39 <koeien> no
07:54:44 <fasta> koeien: right.
07:54:50 <fasta> koeien: so, I need it for https.
07:54:56 <tty7> fasta: https is encrypted :)
07:54:57 * hackagebot ircbot 0.1.4 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.1.4 (JeremyShaw)
07:55:03 <koeien> wireshark isn't going to help there either
07:55:03 <fasta> tty7: I know that.
07:55:33 <fasta> tty7: I already said before I was using https.
07:55:58 <mm_freak> fasta: nc -vvlp 4000
07:56:03 <mm_freak> send the request to localhost:4000
07:56:12 <koeien> mm_freak: ssl is involved
07:56:45 <fasta> I think the library should simply have a Show instance for request data.
07:56:45 <mm_freak> koeien, fasta:  in that case:  openssl s_server
07:56:59 <koeien> yeah i knew openssl had something
07:57:00 <koeien> :)
07:57:25 <copumpkin> openssl has everything, but the API and documentation is so crappy that nobody knows where it is
07:58:12 <fasta> mm_freak: what does it do?
07:58:27 <fasta> mm_freak: if I run it, I get tons of errors.
07:58:48 <mm_freak> fasta: i don't remember exactly how to use it‚Ä¶  it's like SSL-ed netcat
07:59:01 <mm_freak> you will have to look it up online
07:59:07 <koeien> maybe you want openssl s_client in this case tho
07:59:25 <koeien> i'm not sure what you want to see, if you just want to see the request i don't see why you have to use ssl
07:59:33 <fasta> I think this just shows that the library is immature.
07:59:48 <fasta> I don't need to do this in a random other language.
08:00:55 <acowley> Wow, I've completely cabal installed myself into a corner
08:01:08 <cheater_> lol
08:01:14 <tty7> koeien: and runthrough ((n, False):xs) = (n, False) : runthrough xs
08:01:15 <tty7> ?
08:01:15 <acowley> I guess it's time to embrace cabal-dev (or is there something better now?)
08:02:04 <mm_freak> fasta: never ran into that issue before, and it's a bit of prejudice to call it immature for one missing feature‚Ä¶  nevertheless i see your point
08:02:22 <fasta> mm_freak: it would be the absolute first thing I would implement.
08:02:26 <mm_freak> fasta: there is also the "HTTP" library, which even includes session management, so you don't have to manage your cookies yourself
08:02:36 <koeien> tty7: yeah something like that
08:02:37 <fasta> mm_freak: but the http library doesn't do https.
08:02:39 <mm_freak> but it might be slow, if you need to do many requests
08:02:42 <mm_freak> true
08:02:43 <koeien> tty7: it was not complete
08:02:55 <copumpkin> http enumerator is nice if you want https
08:02:56 <copumpkin> but no sessions
08:03:07 <copumpkin> you don't have to deal with the enumerator API if you don't want it
08:03:12 <fasta> copumpkin: I would like to have sessions.
08:03:23 <mm_freak> copumpkin: http-enumerator has the same issue
08:03:26 <koeien> acowley: there is that and virtualhenv. i used neither
08:03:33 <mm_freak> seems like http-conduit is a straight translation from enumerator to conduit
08:03:55 <copumpkin> which issue? I just tuned in
08:03:59 <fasta> What about http://hackage.haskell.org/package/shpider-0.2.1.1 ?
08:04:03 <mm_freak> copumpkin: no Show for Request
08:04:08 <copumpkin> oh
08:04:27 <copumpkin> hmm, dunno
08:04:27 <mm_freak> i usually just use netcat, but fasta wants to test openssl requests
08:04:48 <fasta> copumpkin: the actual issue is: https some page, login, click some link depending on JavaScript, scrape some resulting page.
08:04:57 * hackagebot websockets 0.5.1.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.5.1.1 (JasperVanDerJeugt)
08:05:01 <fasta> I don't want to do anything with openssl.
08:05:08 <copumpkin> socat is netcat on steroids
08:05:14 <copumpkin> with ssl and local sockets and so on
08:05:23 <mm_freak> fasta: shpider seems to be reasonable
08:05:28 <copumpkin> I used it back when I was reversing iphone protocols (for a while)
08:05:50 <copumpkin> since it can do unix sockets too
08:05:51 <mm_freak> fasta: it uses curl under the hood, but wraps around the ugly interface, so you might be happy with it
08:06:17 <fasta> mm_freak: I didn't see any way to get cookies from it.
08:06:21 <tty7> okay, thanks koeien :)
08:06:27 <koeien> tty7: did it work?
08:06:32 <fasta> mm_freak: or anything related to JavaScript for that matter.
08:06:41 <koeien> laziness should ensure that there is progress
08:08:11 <tty7> yeah, it looks like.
08:08:12 <bobry> can someone please explain this error message to me https://gist.github.com/64af31adc0439c12c46b?
08:08:19 <tty7> didn't implement it yet, wait a second ;)
08:08:29 <bobry> i wonder why the compiler rejects 'IO (Either [String] a)' instance
08:08:58 <mm_freak> fasta: apparently shpider is really for web spiders
08:09:22 <acowley> I'm worried that cabal-dev is going to greatly diminish the usability of GHCi
08:09:56 <fasta> mm_freak: I don't subscribe to the theory that web spiders should not be able to login on websites.
08:10:52 <acowley> does anyone have some .emacs configuration to support cabal-dev ghci?
08:11:19 <mm_freak> fasta: i know, it appears to me like you need to use curl for cookies‚Ä¶  see the .Options module of shpider
08:11:28 <acowley> I can't just replace ghci with cabal-dev ghci, because that only works in directories with .cabal files, so I need something clever
08:12:53 <fasta> mm_freak: I am sorry, but even the word cook is nowhere to be found there.
08:14:14 <mm_freak> fasta: addCurlOpts
08:15:09 <fasta> mm_freak: that's useful for setting a cookie, but not for getting cookie data.
08:15:54 <mm_freak> fasta: i'm sure you can go the other way, too
08:16:00 <mm_freak> but you'll have to figure that out by yourself
08:16:17 <fasta> mm_freak: how do you mean 'the other way'?
08:18:11 <fasta> mm_freak: Perhaps it is this: Path to file holding initial cookie data; also enables cookie handling.
08:18:36 <fasta> Except it doesn't say what it means by cookie handling.
08:19:30 <fasta> Or it is this one: CurlCookieJar FilePath
08:19:36 <fasta> Anyway, more guess-oriented programming.
08:19:41 <mm_freak> fasta: well, i'd expect it to send and save cookies like a browser would
08:20:04 <mm_freak> i don't know, you'll have to try it out
08:20:26 <mm_freak> interfacing to non-haskell libraries often involves guess-oriented programming
08:20:49 <mm_freak> (or reading the documentation of those libraries)
08:21:48 <fasta> mm_freak: at that point Haskell becomes completely worthless.
08:21:57 <fasta> Except for writing fib, of course.
08:22:03 <copumpkin> lol
08:22:07 <fasta> Or a Haskell compiler ;)
08:22:20 <copumpkin>  /kickban fasta whoops
08:22:24 <copumpkin> I mean
08:22:32 * copumpkin whistles
08:22:47 <mm_freak> fasta: i disagree, but then i also write many boilerplate libraries myself =)
08:22:51 * copumpkin puts on sunglasses and goes outside for a walk
08:23:00 <mm_freak> in haskell it's actually feasible to do that
08:23:49 <mm_freak> fasta: unfortunately my ihttp library is not mature for what you want‚Ä¶  it has all you need, but using it can get very verbose
08:24:38 <mm_freak> also the protocol parser can fail for some rare, weird but standards-conforming messages from peers
08:25:33 <mm_freak> never seen those in the real world, but HTTP allows them
08:37:10 <acowley> oh sweet lack of time... having to recompile everything with cabal-dev takes forever
08:44:12 <tty7> hm..
08:44:31 <tty7> it seems to work, koeien
08:44:32 <tty7> but
08:44:52 <tty7> the whole thing (not sure if due to that last part) is damn slow
08:45:18 <koeien> don't run it in ghci, compile it with -O2
08:45:29 <tty7> okay (:
08:45:34 <tty7> what does -O2 do exactly?
08:45:41 <tty7> i know its the optimize flag
08:45:51 <tty7> but what does it internally do?
08:46:29 <koeien> all kinds of magic that i don't know
08:46:34 <tty7> okay :)
08:46:41 <koeien> it does analyze strictness
08:46:48 <zopa> Hi all. I'm doing some work with Snap, and trying to use the MongoDB snapplet. When I cabal install snaplet-mongoDB everything seems fine, ghc-pkg check is happy, etc. But when I use cabal install to compile my Snap site, a bunch of stuff seems to recompile, and the hash on snap-0.7 in ~/.../package.conf.d/ changes
08:46:49 <rostayob> tty7: GHC's manual is your friend
08:46:53 <koeien> so unnecessary laziness is avoided
08:46:55 <zopa> i.e. from snap-0.7-fddc658f[...].conf to snap-0.7-e0ca0cc0[...].conf
08:47:10 <tty7> hehe, yeah rostayob. :) but i'd like to avoid that
08:47:16 <tty7> nevermind, i will go for it
08:47:30 <zopa> this breaks the snaplet, which complains to ghc-pkg check that its dependency on snap is missing.
08:48:00 <tty7> btw: how to get the programm call's arguments in haskell?
08:48:26 <zopa> reinstalling snap-MongoDB fixes ghc-pkg check until the next cabal install of my site. repeat infinitely.
08:48:28 <mightybyte> zopa: You should build your app all at once
08:48:36 <mightybyte> This is a common cabal issue
08:48:37 <tty7> ah, getArgs :)
08:48:55 <zopa> mightybyte: I don't quite follow.
08:48:58 <mightybyte> zopa: You should create a cabal project for your application and build it with cabal install.
08:49:18 <mightybyte> Then cabal will automatically resolve the correct dependencies for everything.
08:49:21 <donri> (or cabal-dev)
08:49:54 <zopa> Okay, I think that's what snap does by default--are you saying I need to tweak that cabal.install file somehow?
08:50:11 <donri> zopa: you should create a .cabal for your own project/app
08:51:31 <donri> also using cabal-dev is a good idea to isolate the build
08:54:09 <mightybyte> zopa: If you used "snap init" to generate a project, then yes.  You need to add snaplet-mongoDB to the list of dependencies.
08:54:59 <zopa> mightybyte:okay, trying that now. Thanks!
08:56:17 <zopa> donri: Ah, sandboxes! that's a good thought.
09:02:28 <tty7> hum. why doesn't that work:
09:02:34 <tty7> main = do myArgs <- get Args
09:02:40 <tty7>                        someLineOfCode
09:02:46 <tty7>                        where this = head myArgs
09:02:52 <tty7> it says "Not in scope: `myArgs'"
09:02:59 <tty7> for the line of the where
09:04:19 <osfameron> tty7: indentation?
09:04:28 <ion> That parses as main = (do myArgs <- get Args; someLineOfCode) where { this = head myArgs }. The myArgs defined in the do block isn‚Äôt in scope for the where block.
09:04:32 <tty7> so how's the correct indentation?
09:04:54 <tty7> i also indented the where a bit more to check that
09:05:01 <tty7> didn't work either, same error
09:05:31 <donri> tty7: getArgs without space
09:05:35 <tty7> ion: can i have it to parse it like the way i want it to? ;)
09:05:52 <tty7> yeah, i used getArgs. was a typo in here
09:05:57 <ion> Try {-# LANGUAGE DoWhatIMeanNotWhatIWrite #-}
09:06:11 <tty7> heh
09:06:12 <geekosaur> heh
09:06:23 <donri> tty7: you should align the indentation with "myArgs <-"
09:06:39 <tty7> i meant: how to write it the way i want it to behave like
09:06:41 <tty7> thanks, donri
09:07:16 <tty7> you mean the "w" of where just in the same column as the "m" of myArgs?
09:07:22 <tty7> that's what I have done ;)
09:07:48 <acowley> cabal-dev ghci doesn't accept ghci flags?
09:07:51 <ion> I‚Äôd indent ‚Äúwhere‚Äù just one step further than ‚Äúmain‚Äù since that‚Äôs where it belongs logically.
09:08:10 <donri> tty7: also myArgs will not be in scope for "where"
09:08:14 <donri> tty7: use "let"
09:08:23 <tty7> okay :)
09:08:30 <donri> "where" only has the function arguments and outer scope
09:08:39 <tty7> i see
09:09:18 <tty7> so where belongs to the function anyway and i can't force it to be inside a do-block?
09:09:19 <ion> Of course, head is almost always evil.
09:09:30 <tty7> why, ion?
09:09:32 <donri> tty7: in deed, but you can use "let"
09:09:33 <ion> > head []
09:09:34 <lambdabot>   *Exception: Prelude.head: empty list
09:09:46 <tty7> well, true
09:09:59 <ion> You‚Äôre better off using pattern matching.
09:10:36 <tty7> maybe i should use (\x -> if x /= [] then head x else someDefaultValue)
09:11:21 <donri> nah, use pattern matching or at least "null"
09:11:26 <donri> > null []
09:11:26 <lambdabot>   True
09:11:31 <tty7> how to use pattern matching at that point without defining a new function?
09:11:38 <tty7> > null [1, 2, 3]
09:11:38 <lambdabot>   False
09:11:39 <donri> case
09:11:45 <merijn> tty7: case x of
09:11:57 <tty7> thanks :)
09:12:50 <geekosaur> speaking of, the "case of" syntactic construct is dead in the water, right?  (that is, pointfree case)
09:12:51 <donri> do args <- getArgs; case args of [] -> putStrLn "usage: ..."; ["--version"] -> putStrLn "v1.3.3.7"
09:12:53 <ion> tty7: (\xs -> case xs of (x:_) -> x; _ -> something). Or (fromMaybe something . listToMaybe)
09:13:31 <donri> (but probably better use getopt for processing getArgs)
09:13:38 <ChristianS> why is case better than if?
09:13:56 <donri> depends on what you're doing
09:14:13 <koeien> they are essentially different
09:14:28 <ion> Or head (xs <|> pure something)
09:14:40 <ChristianS> actually, if is just syntactic sugar your case anyway
09:14:48 <ChristianS> s/your/for/
09:15:17 <koeien> sure, but not the other way around
09:15:51 <tty7> > head ([] <|> 123)
09:15:52 <lambdabot>   No instance for (GHC.Num.Num [a])
09:15:52 <lambdabot>    arising from a use of `e_1123' at <int...
09:16:08 <koeien> you forgot "pure"
09:16:18 <tty7> > head ([] <|> pure 123)
09:16:18 <lambdabot>   123
09:16:21 <tty7> :)
09:18:40 <donri> > head ([] ++ [123])
09:18:41 <lambdabot>   123
09:26:50 <tty7> hm.
09:27:05 <tty7> still, it is damn slow. (after compiling with -O2)
09:27:53 <ion> Profile it.
09:28:07 <tty7> how to do that?
09:28:33 <tty7> my haskell implementation:
09:28:35 <tty7> $ time ./SieveOfAtkin 100000
09:28:36 <tty7> Found 9592 primes up to 100000.
09:28:36 <tty7> real	1m56.250s
09:28:36 <tty7> user	1m55.139s
09:28:36 <tty7> sys	0m0.776s
09:28:48 <tty7> my python implementation:
09:28:50 <tty7> $ time ./SieveOfAtkin.py 100000
09:28:50 <tty7> Searching for the primes up to 100000.
09:28:50 <tty7> Found 9592 primes up to 100000.
09:28:50 <tty7> real	0m0.126s
09:28:50 <tty7> user	0m0.104s
09:28:50 <tty7> sys	0m0.020s
09:29:02 <tty7> :/
09:29:13 <ion> Please don‚Äôt flood the channel. Use hpaste.
09:29:16 <tty7> maybe it's not haskell, but my implementation is bad
09:29:22 <tty7> sorry
09:29:27 <byorgey> tty7: is your Haskell implementation using lists or arrays?
09:29:32 <tty7> thought it'd be okay for 12 lines
09:29:37 <tty7> lists
09:30:22 <tty7> arrays would be better?
09:30:24 <koeien> @hpaste
09:30:24 <lambdabot> Haskell pastebin: http://hpaste.org/
09:31:17 <byorgey> tty7: having to scan through every position in the list looking for the places you want to cross off pretty much defeats the purpose of using a sieve.
09:31:35 <tty7> yeah
09:31:55 <tty7> but doesn't i have to scan through everything anyway?
09:32:05 <tty7> or is it better with arrays? :)
09:33:32 <ion> tty7: Try this. https://gist.github.com/1595983
09:33:57 <byorgey> tty7: yes, ultimately you have to look at every entry, but I mean for any particular prime you find, you want to go cross off numbers at locations k*n^2, and it makes a big difference if you have to scan through everything to do that
09:38:19 <tty7> huh, ion, that's a pretty cool piece of code :)
09:38:34 <ion> I don‚Äôt remember who wrote it. It was someone in here.
09:38:49 <tty7> though,  the idea was actually to implement the sieve of atkin in haskell ;)
09:39:43 <tty7> to learn haskell and to see if it works to implement such state-based algorithms efficiently in haskell
09:40:00 <MostAwesomeDude> tty7: In Python, it's totally possible to do Atkin with a generator which lazily creates candidate lists; you can do the same in Haskell.
09:40:02 <tty7> but however, that one is really neat and fast :)
09:40:59 <tty7> MostAwesomeDude: so how to do the last step, dropping the multiples of squares, efficiently that way?
09:41:18 <MostAwesomeDude> tty7: filter
09:41:24 <MostAwesomeDude> Paste your code?
09:41:28 <tty7> but filter for what
09:41:28 <MostAwesomeDude> *Pastebin?
09:41:32 <tty7> yep, wait a second
09:43:39 <byorgey> MostAwesomeDude: that doesn't sound very efficient to me.  Unless I've misunderstood what you mean.
09:43:47 <hpaste_> tty7 pasted ‚ÄúSieve of Atkin - slow‚Äù at http://hpaste.org/56350
09:45:22 <ion> tty7: First of all, i‚Äôd reverse the order of the functions. I don‚Äôt think isSquare is the most significant piece of the code. :-)
09:45:39 <tty7> isSquare isn't actually needed atm ;)
09:46:16 <tty7> yeah, i put it kind of 'reversed'
09:46:17 <MostAwesomeDude> ion: I don't know about you, but I read top to bottom, C-style. :3
09:46:31 <tty7> still used to python code :D
09:47:19 <MostAwesomeDude> Python is also top to bottom. :3
09:47:49 <ion> C, too, but you have to add function prototypes first. :-)
09:47:56 <tty7> hehe :)
09:48:49 <MostAwesomeDude> Hm, why do you need firstPrimes *and* primesUpTo? And can't you just use genericTake in both cases?
09:49:30 <tty7> what does genericTake do?
09:49:39 <tty7> i don't really *need* them
09:50:02 <tty7> but wrote both, just in case
09:50:04 <tty7> ;)
09:50:07 <MostAwesomeDude> Oh, genericTake works on Integers so you don't have to constantly fromInteger.
09:50:16 <tty7> ah, okay :)
09:50:25 <tty7> yeah, would be better then probably (:
09:50:29 <MostAwesomeDude> It looks like your code builds up the entire intermediate list of primes, which I would imagine chews memory.
09:51:13 <tty7> i don't think it chews that much memory, due to the laziness. but the squareFree-filtering takes a while I guess
09:51:33 <ion> Converting between integers and doubles is a bit nasty. And will lead to precision problems.
09:53:41 <koeien> you can calculate an integer square root by binary search
10:03:42 <Yrogirg> what is the module for rational numbers?
10:04:04 <byorgey> Data.Ratio
10:04:26 <ion> Note that Rational is defined in Prelude.
10:04:37 <ion> s/defined in/exported by/
10:05:01 <byorgey> > let isqrt n = isqrt' (n `div` 2) where isqrt' x | x*x <= n && (x+1)*(x+1) > n = x | otherwise = isqrt' ((x + (n `div` x)) `div` 2) in isqrt 89235674095806799949025
10:05:02 <lambdabot>   298723407345
10:05:11 <byorgey> > 298723407345^2
10:05:12 <lambdabot>   89235674095806799949025
10:05:59 <Yrogirg> ion and how do I construct these Rationals from prelude?
10:06:02 <byorgey> ^^^ even better than binary search
10:06:09 <ion> > 42 :: Rational
10:06:10 <lambdabot>   42 % 1
10:06:17 <byorgey> > (4 / 7) :: Rational
10:06:18 <lambdabot>   4 % 7
10:06:33 <Yrogirg> > 4 % 5
10:06:34 <lambdabot>   4 % 5
10:07:19 <Yrogirg> but in pure prelude "Not in scope: `%'" still need Data.Ratio
10:07:28 <ion> Just use /
10:07:44 <ion> @check let isqrt :: Integer -> Integer; isqrt n = isqrt' (n `div` 2) where isqrt' x | x*x <= n && (x+1)*(x+1) > n = x | otherwise = isqrt' ((x + (n `div` x)) `div` 2) in \x -> x == isqrt (x^2)
10:07:45 <lambdabot>   "Falsifiable, after 2 tests:\n-3\n"
10:07:56 <ion> @check let isqrt :: Integer -> Integer; isqrt n = isqrt' (n `div` 2) where isqrt' x | x*x <= n && (x+1)*(x+1) > n = x | otherwise = isqrt' ((x + (n `div` x)) `div` 2) in \(NonZero x) -> x == isqrt (x^2)
10:07:56 <lambdabot>   Not in scope: data constructor `NonZero'
10:08:27 <ion> @check let isqrt :: Integer -> Integer; isqrt n = isqrt' (n `div` 2) where isqrt' x | x*x <= n && (x+1)*(x+1) > n = x | otherwise = isqrt' ((x + (n `div` x)) `div` 2) in \(Test.QuickCheck.Modifiers.NonZero x) -> x == isqrt (x^2)
10:08:28 <lambdabot>   Not in scope: data constructor `Test.QuickCheck.Modifiers.NonZero'
10:08:36 <byorgey> try  (x > 0 ==> ...)
10:09:06 <ion> Yeah, that would work, but using NonZero would be the Right Way‚Ñ¢. It‚Äôs strange it‚Äôs not available in @check.
10:09:26 <byorgey> using Positive would be the Right Way.  It definitely doesn't work for negative numbers.
10:10:29 <byorgey> @check let isqrt :: Integer -> Integer; isqrt n = isqrt' (n `div` 2) where isqrt' x | x*x <= n && (x+1)*(x+1) > n = x | otherwise = isqrt' ((x + (n `div` x)) `div` 2) in \x -> x > 0 ==> x == isqrt (x^2)
10:10:30 <lambdabot>   Not in scope: `==>'Precedence parsing error
10:10:30 <lambdabot>      cannot mix `GHC.Classes.>'...
10:10:43 <byorgey> @check let isqrt :: Integer -> Integer; isqrt n = isqrt' (n `div` 2) where isqrt' x | x*x <= n && (x+1)*(x+1) > n = x | otherwise = isqrt' ((x + (n `div` x)) `div` 2) in \x -> (x > 0) ==> (x == isqrt (x^2))
10:10:44 <lambdabot>   Not in scope: `==>'
10:10:48 <byorgey> le sigh
10:11:16 <ion> It seems to work fine with zero, too.
10:11:52 <ion> Oh, but isqrt 1 fails.
10:13:52 <byorgey> oh, right, the initial guess is bad.
10:19:33 <clsmith> is there a website somewhere which describes mathematical constructs in a way programmers can understand? :p i'm trying to understand sheaves and i feel like i'm grasping at straws (as it were) <.<
10:21:02 <yitz> > let isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in isqrt 89235674095806799949025
10:21:03 <lambdabot>   298723407345
10:21:10 <koeien> algebraic geometry? probably not
10:21:16 <yitz> byorgey: ^
10:22:39 <clsmith> koeien: well, i've come across a paper describing how one can model bound variables using presheaves. but i don't know what presheaves *are*.
10:23:01 <ion> @check let isqrt :: Integer -> Integer; isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in \x -> if x < 0 then True else x == isqrt (x^2)
10:23:03 <lambdabot>   "*Exception: divide by zero
10:23:12 <koeien> do you know any topology?
10:23:15 <rwbarton> presheaf is pretty much just a word for functor
10:23:17 <ion> @check let isqrt :: Integer -> Integer; isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in \x -> if x < 1 then True else x == isqrt (x^2)
10:23:19 <lambdabot>   "*Exception: divide by zero
10:23:33 <ion> @check let isqrt :: Integer -> Integer; isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in \x -> if x < 2 then True else x == isqrt (x^2)
10:23:34 <lambdabot>   "OK, passed 500 tests."
10:24:31 <rwbarton> and presheaf is a simpler notion than sheaf
10:24:37 <yitz> @check let isqrt :: Integer -> Integer; isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2 + 1; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in \x -> if x < 1 then True else x == isqrt (x^2)
10:24:38 <lambdabot>   "OK, passed 500 tests."
10:25:25 <DanBurton> :t stable
10:25:26 <lambdabot> Not in scope: `stable'
10:25:39 <koeien> it's defined in the let as well
10:25:45 <DanBurton> oh right
10:27:22 <yitz> @check let isqrt :: Integer -> Integer; isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2 + 1; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in \x -> if x < 1 then True else isqrt x == round (sqrt x)
10:27:23 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
10:27:23 <lambdabot>    arising fr...
10:27:33 <yitz> @check let isqrt :: Integer -> Integer; isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2 + 1; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in \x -> if x < 1 then True else isqrt x == round (sqrt $ fromIntegral x)
10:27:34 <lambdabot>   "Falsifiable, after 4 tests:\n2\n"
10:27:47 <yitz> round (sqrt 2)
10:27:50 <yitz> > round (sqrt 2)
10:27:51 <lambdabot>   1
10:28:20 <yitz> > let isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in isqrt 2
10:28:22 <lambdabot>   2
10:28:41 <yitz> @check let isqrt :: Integer -> Integer; isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2 + 1; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in \x -> if x < 5 then True else isqrt x == round (sqrt $ fromIntegral x)
10:28:43 <lambdabot>   "Falsifiable, after 82 tests:\n30\n"
10:29:03 <ion> floor?
10:29:32 <koeien> that isqrt fails for 2 already
10:30:07 <yitz> koeien: it doesn't fail. it's using a different kind of rounding.
10:30:32 <rwbarton> A New Kind of Rounding
10:30:32 <koeien> ahw, you want the smallest number x such that x * x >= r
10:30:53 <yitz> > let isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in [(n, isqrt n) | n <- [1..]]
10:30:55 <lambdabot>   [(1,*Exception: divide by zero
10:31:01 <yitz> grr
10:31:09 <clsmith> koeien: no :p
10:31:10 <yitz> > let isqrt n = stable . iterate (\m -> (m*m+n+m)`div`(m+m)) $ n `div` 2 + 1; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in [(n, isqrt n) | n <- [1..]]
10:31:11 <lambdabot>   [(1,1),(2,2),(3,2),(4,2),(5,2),(6,3),(7,3),(8,3),(9,3),(10,3),(11,3),(12,4)...
10:31:21 <clsmith> rwbarton: presheaf == functor? any differences at all?
10:31:54 <rwbarton> normally "a presheaf on C" means "a functor C^op -> Set"
10:32:12 <rwbarton> though you can also talk about "D-valued presheaves" for another category D
10:32:30 <yitz> koeien: oh, if you want that instead of the rounded verion, you have to modify the newton formula a little
10:33:29 <rwbarton> also there is a shift in focus. a functor is normally viewed as a kind of morphism between categories, whereas a presheaf is often viewed as an object (of the category of presheaves on C)
10:33:49 <rwbarton> but technically, there is no real difference
10:34:13 <clsmith> hmm, okay, thanks :)
10:34:31 <rwbarton> one also talks of presheaves on objects other than categories, but those are just presheaves on some category associated to the object
10:34:38 * koeien thought sheaves were linked to topological properties
10:34:47 <koeien> maybe presheaves didn't require that
10:36:39 <rwbarton> That is the main (and historically first) example of a notion of sheaf, yes, where the "other object" is a topological space and the associated category is the lattice of open sets
10:36:43 <rwbarton> er, not lattice but poset
10:41:11 <gregATio> i love haskell
10:41:34 <ben_m> I think you'll find likeminded people in here.
10:41:35 <ben_m> Just a guess.
10:46:17 <gregATio> :)
10:49:14 <yitz> > let isqrt n = subtract 1 . stable . iterate (\m -> m-(m*m-n)`div`(m+m)) $ n `div` 2 + 1; stable (x:x':_) | x==x' = x; stable (_:xs) = stable xs in [(n, isqrt n) | n <- [2..]]
10:49:16 <lambdabot>   [(2,1),(3,1),(4,2),(5,2),(6,2),(7,2),(8,2),(9,3),(10,3),(11,3),(12,3),(13,3...
10:50:29 <yitz> there's something a little better than that, i can't remember it at the moment.
10:56:48 <donri> ohai chrisdone
10:57:12 <donri> how's the evaluation coming along
10:58:08 <chrisdone> donri: odd you should mention that. i just decided to return to it now, i decided rather than making it a blog post which will become irrelevant over time, i'll move it to the haskellwiki
10:58:23 <donri> nice idea
10:59:57 <ocharles> is there a website for hackage 2? I want to help but http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0 is no beuno
11:01:44 <donri> ocharles: repo at http://code.haskell.org/hackage-server/
11:02:16 <ocharles> thanks!
11:03:10 <chrisdone> donri: and also i don't have to write it all by myself :p
11:03:17 <donri> in deed :)
11:03:38 <chrisdone> today i re-learn wiki syntax
11:03:56 * chrisdone wonders if pandoc does wiki syntax
11:04:01 <ocharles> I was about to suggest that
11:04:06 <donri> need to take up all about monads again
11:04:07 <chrisdone> it does indeed
11:04:15 <donri> chrisdone: it does, that's how i do all about monads
11:04:21 <chrisdone> cannot be bothered translating markdown to wiki manually
11:04:35 <chrisdone> excellent√©
11:07:32 <chrisdone> donri: yeah, all about monads too
11:07:41 <Guest78005> Can anyone recommend an improvement to this code: count = map (\n -> (length n, head n)) . group . sort
11:08:01 <chrisdone> i'm thinking i should just move all my 'guides' away from my blog onto the haskellwiki
11:08:06 <koeien> map (length &&& head) . group . sort
11:08:09 <Guest78005> I let it run processing a file for 3.5 hours and it still wasn't complete.  The memory usage is huge
11:08:23 <chrisdone> maybe sort/group can be merged
11:08:26 <koeien> oh that should be fine.
11:08:37 <koeien> the error is probably somewhere else
11:08:43 <donri> i think in deed the haskellwiki is a good place to put stuff
11:08:51 <Manehattan1> monads vs. arrows?
11:09:00 <Guest78005> koeien: The file is pretty big, could that be the problem?
11:09:32 <koeien> how big?
11:09:54 <Guest78005> koeien: About 700MB, approximately 550k records.
11:10:21 <donri> chrisdone: where do you plan to do the comparison? http://www.haskell.org/haskellwiki/Web/Frameworks ?
11:10:26 <chrisdone> Guest78005: bytestring will probably speed up the reading
11:10:35 <chrisdone> Guest78005: esp. strict
11:10:37 <Guest78005> koeien: I added that count function to some code that was already working, and quickly
11:10:45 <Manehattan1> Guest78005: or Data.Text
11:11:03 <chrisdone> Guest78005: if you're lazily reading a string from a file it's going to be hitting the filesystem constantly, VERY big speed hit
11:11:36 <aadrake> chrisdone: When running the code to do other stuff and output to disk it takes around 90 seconds
11:11:36 <koeien> yeah this code is very fast
11:11:59 <aadrake> chrisdone: It seems that the count function is time consuming
11:12:03 <koeien> but now you're reordering.
11:12:06 <koeien> (with sort)
11:12:15 <cheater_> hey guys
11:12:19 <koeien> does your program run out of memory? (thrashing)
11:12:25 <cheater_> what's the canonical way to prefix a list of strings with a common prefix?
11:12:35 <koeien> map ("Zomg"++)
11:13:18 <aadrake> koeien: I don't know if it runs out of memory entirely, but it shoots up to around 80% of total memory usage on my system and then trickles down to about 60% where it stays indefinitely
11:13:20 <cheater_> right
11:13:30 <aadrake> koeien: CPU usage is around 4-10%
11:13:44 <cheater_> is there a good function to join paths? kinda like python's os.path.join ?
11:13:56 <koeien> the best thing you can probably do to improve performance is to use bytestrings/ text
11:14:03 <Enigmagic> cheater: </>
11:14:11 <cheater_> for example join "foo" "bar" -> "foo/bar"
11:14:16 <cheater_> :hoogle </>
11:14:23 <cheater_> @hoogle </>
11:14:24 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
11:14:24 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
11:15:06 <cheater_> thank you Enigmagic
11:15:16 <byorgey> I think if you just import System.FilePath you magically get the version corresponding to your platform
11:17:40 <aadrake> koeien: I think it should still run though.  I'm surprised that it just chokes like that
11:18:02 <aadrake> koeien: It makes me wonder if there is some other problem in the code
11:18:15 <cheater_> byorgey: interesting and cool
11:18:18 <koeien> it might be related to the fact that before your code linearly runs through the records, and now you need to read them all at once.
11:18:20 <cheater_> you're like salt and pepper
11:19:33 <ion> There‚Äôs also http://hackage.haskell.org/package/system-filepath
11:19:56 <ion> which has something better than type FilePath = String
11:20:23 <aadrake> koeien: I guess that must be it.  I wonder if there is a way to refactor with some set operations to avoid having to store all that in memory
11:21:19 <chrisdone> aadrake: some ideas: run the ghc profiler to see slow spots. then approaches might be to use strict bytestring if it's binary data, or the "text" package if you're treating it as text. could also investigate replacing the sort algorithm
11:22:37 <kuznero> Hi All!
11:22:38 <aadrake> chrisdone: I've never played with the profiler before, maybe I'll do that on a small subset of the file and see what the results are.
11:23:07 <chrisdone> donri: it'll be here. i didn't even start on the actual APIs yet  http://www.haskell.org/haskellwiki/Web/Comparison_of_Happstack%2C_Snap_and_Yesod
11:23:58 <donri> coolio
11:24:49 <chrisdone> does our mediawiki support references?
11:25:00 <chrisdone> //footnotes
11:26:36 <chrisdone> doesn't seem to
11:27:01 <donri> seems not, because i think your markup is what should work
11:27:59 <chrisdone> oh well
11:28:15 <donri> gwern: we want references!
11:29:09 <gwern> donri: huh
11:29:14 <donri> oh haskellwiki
11:29:17 <donri> on*
11:29:43 <donri> supposedly http://www.mediawiki.org/wiki/Extension:Cite/Cite.php
11:30:03 <gwern> I'm not one of the sysadmins, I can't affect the core MediaWiki functionality
11:30:09 <donri> oh ok
11:30:20 <gwern> bug ashley
11:32:06 <chrisdone> sent a bugging mail
11:33:23 <chrisdone> moved all the refs to the bottom of the page. god bless keyboard macros
11:35:14 * monochrom shakes head at moving all references to bottom
11:35:33 <chrisdone> monochrom: where should I move 'em?
11:35:47 <monochrom> put them where the reader needs them
11:35:50 <chrisdone> the end of each section?
11:36:07 <monochrom> in situ is where the reader needs them
11:36:33 <monochrom> I have thoroughly explained this in haskell-cafe
11:36:54 <chrisdone> i don't read haskell-cafe, it's beneath me :p
11:37:22 <cheater_> i have a function foo :: [String] -> String -> [String]. I would like to have a function foo2 :: String -> String -> [String] and have something like foo metrics dir = map (\x -> foo2 x dir) metrics; however, i get type errors. what should i do?
11:37:26 <cheater_> sorry wrong
11:37:43 <cheater_> it is a function foo :: [String] -> String -> IO [String]
11:38:06 <cheater_> and it's being used somewhere in the form of      bar <- foo  . . .
11:38:25 <ski> `IO' in `foo2' as well ?
11:38:26 <koeien> you might want mapM instead
11:38:27 <cheater_> i think foo2 would need to be of the form String -> String -> IO [String]
11:38:33 <cheater_> ski: probably
11:38:45 <cheater_> ski: i need to list some dirs inside foo2
11:38:52 <ski> you probably want a `concat' as well
11:39:15 <monochrom> chrisdone: you can find what I explained at http://www.mail-archive.com/haskell-cafe@haskell.org/msg91343.html
11:39:33 <Cody_> Should I bother reading the Haskell 98 report because Haskell 2010 report is out?
11:40:02 <ion> I‚Äôd wait for Haskell 2018 report, i hear it‚Äôs gonna rock.
11:40:04 <cheater_> ski: probably somewhere yes
11:40:05 <monochrom> basically the scheme works great for papers I hold in my hand, but emails on screen?
11:40:44 <Cody_> ion: I got the impersion that Haskell 98 was a better paper
11:41:19 <Cody_> 2010 is it
11:41:21 <ski>   foo metrics dir = liftM concat (mapM (\metric -> foo2 metric dir) metrics)  -- cheater_ ?
11:41:25 <Cody_> it is*
11:41:37 <shachaf> Cody_: It doesn't really matter.
11:41:55 <chrisdone> monochrom: i agree with that. in this case i meant footnotes, but they're achieved with mediawiki via the <ref>/<references> elements in the Cite module. in my blog the footnotes are linked up to anchors and have links to jump back to the referer. i don't know how to do footnotes manageably on haskell's mediawiki
11:42:11 <ski> @hoogle (a -> m [b]) -> ([a] -> m [b])
11:42:11 <lambdabot> No results found
11:42:33 <koeien> concat <$> mapM
11:42:39 <koeien> concat <$> mapM f
11:42:42 <monochrom> alright then we're in agreement
11:42:48 <ski> @type liftM concat .: mapM
11:42:49 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
11:43:58 <ski> @type \f -> concat <$> mapM f
11:43:58 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
11:44:08 <chrisdone> monochrom: see i have <ref> parts here. any ideas? http://www.haskell.org/haskellwiki/Web/Comparison_of_Happstack%2C_Snap_and_Yesod
11:44:11 <ski> looks wrong
11:44:31 <koeien> it does
11:45:13 <monochrom> I don't know how to do things on haskell wiki
11:45:54 <monochrom> but you can always put things in parentheses
11:46:58 <donri> looks like haskellwiki lacks styling for blockquotes
11:47:15 <chrisdone> monochrom: seems like my best option‚Ä¶
11:47:16 <chrisdone> donri: indeed
11:47:41 <donri> though it accepts the markup
11:48:06 <monochrom> you're writing "I am benevolent (reason here) and omnipotent (reason here)". if the reasons are just 5 words, it's overkill to use a sophisticated footnote mechanism.
11:48:54 <monochrom> footnotes are when the reasons are like 100 words and therefore 20 times the main text.
11:49:02 <hpaste_> ‚ÄúBen Gamari‚Äù pasted ‚ÄúMonad transformers trouble‚Äù at http://hpaste.org/56352
11:49:20 <donri> fix that underscore chrisdone!
11:49:22 <ski> chrisdone : <http://www.happstack.com/%E2%80%9D> ?
11:49:30 <ChristianS> .oO ( if I'm omnipotent, i don't need a reason )
11:49:43 <bgamari> Could someone help me to understand where the ambiguous type variable in the above snippet is coming from?
11:49:50 <bgamari> http://hpaste.org/56352
11:50:24 <monochrom> you can also put the reason in the Talk page. you can optionally link from the main text to the Talk page, or not.
11:51:01 <hpaste_> ‚ÄúBen Gamari‚Äù annotated ‚ÄúMonad transformers trouble‚Äù with ‚ÄúMonad transformers trouble (error)‚Äù at http://hpaste.org/56352#a56353
11:51:03 <ski> bgamari : annotate with the error message ?
11:51:06 <ski> ok
11:51:41 <cheater_> is there a version of concat for IO [a] ?
11:51:58 <koeien> cheater_: what do you mean?
11:51:59 <Botje> liftM concat
11:52:04 <ski> cheater_ : <ski> @type \f -> concat <$> mapM f
11:52:04 <koeien> [IO a] -> IO [a] ?
11:52:08 <koeien> that's sequence
11:52:21 <ski> cheater_ : er, wrong one
11:52:33 <bgamari> You may recall this code from a few months ago. I'm revisiting the first project I attempted in Haskell
11:52:45 <ski> cheater_ : `\f as -> liftM concat (mapM f as)' this one
11:52:47 <chrisdone> ski: looks like mediawiki auto-converts URLs to hyperlinks
11:53:04 <ski> chrisdone : yes, but that link looks broken
11:53:16 <chrisdone> ski: yeah, because of said conversion
11:53:28 <chrisdone> http://www.happstack.com/‚Äù ‚Üí http://www.happstack.com/%E2%80%9D
11:53:41 <chrisdone> kind of annoying
11:54:00 <ski> chrisdone : s;http://www.happstack.com/;<http://www.happstack.com/; ?
11:54:02 <Botje> ew, smart quote
11:54:08 <ski> er <http://www.happstack.com/>
11:54:09 <chrisdone> donri: what underscore?
11:54:15 <donri> chrisdone: hpaste_ :)
11:54:20 * donri being ocd
11:54:24 <monochrom> that's bad. authors already know how to make hyperlinks properly. why auto-convert, and be broken about it?
11:54:32 <chrisdone> monochrom: indeed
11:54:53 <chrisdone> ski: i'll try that‚Ä¶
11:56:21 <chrisdone> monochrom: i bookmarked your rant for later ragelinking
11:56:38 <cheater_> chrisdone: what rant? url pls
11:56:55 <cheater_> ski: i *was* thinking it might be something like liftM
11:57:00 <cheater_> but i've never used liftM.
11:57:01 <chrisdone> cheater_: i don't have the url anymore. >____>
11:57:04 <ski> chrisdone : done
11:57:07 <cheater_> chrisdone: i h8 u
11:57:13 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg91343.html
11:57:13 <chrisdone> cheater_: http://www.mail-archive.com/haskell-cafe@haskell.org/msg91343.html
11:57:52 <chrisdone> ski: oh, thanks. fair enough
11:58:05 <cheater_> chrisdone: too late, monochrom is my friend now ; ;
11:58:32 <chrisdone> Ôºà‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª
11:58:33 <monochrom> relativity says that some observers see the other order :)
11:59:04 <Nereid> monochrom: only if they're spacelike separated!
11:59:24 <cheater_> chrisdone: orz
11:59:37 <donri> guys did you know you can format email with html
11:59:40 <donri> cool huh
12:00:12 <monochrom> I know, and I use it when it helps
12:00:29 <chrisdone> donri: i love reading SPJ's emails, written with big blue fonts from Microsoft Outlook
12:00:35 <donri> haha
12:00:38 <monochrom> hehehe
12:03:12 <chrisdone> jeremy shaw sent me a few sites that use happstack, good to have on the list
12:03:33 <donri> i sent you some too
12:03:51 <chrisdone> donri: yeah, added the yesod and adding the snap now
12:04:07 <dumiopky> i read 10 chapter of LYAH. Should i keep reading or i should change to Real World Haskell?
12:04:13 <chrisdone> mediawiki are slower than out
12:04:50 <chrisdone> Botje: screw you, smart quotes are smart!
12:04:56 <donri> dumiopky: that's up to you isn't it? :) if you find lyah useful why not finish it
12:05:10 <srhb> chrisdone: The list of happstack sites, where did you put that?
12:05:18 <monochrom> you can do both
12:05:29 <NemesisD> anyone have any experience with any of the SMTP libraries for haskell? I wanted to set up a server that simply parses the inbox name and does something interesting with messages it receives
12:05:30 <monochrom> left eye for LYAH, right eye for RWH
12:05:35 <dumiopky> yeh i was just asking because you guys are the pro in Haskell and i am just learning
12:06:16 <Axman6> dumiopky: i'd try doing some exercises to get you used to actually solving problems with Haskell. things like Project Euler are pretty good for that
12:06:36 <dumiopky> Axman6, i did 20 exercises from 99 haskell problems
12:06:41 <shachaf> Project Euler is pretty not-good for learning a programming language.
12:06:45 <Eduard_Munteanu> There's also  http://en.wikibooks.org/wiki/Haskell  which is nice for some topics
12:06:52 <donri> euler is great for learning integers
12:07:01 <srhb> donri++ for that :P
12:07:05 <monochrom> no, Project Euler is bad. Project Euler tricks you into thinking "would be nice to have primality tests in the Prelude" which is totally absurd
12:07:06 <donri> @where typeclassopedia
12:07:06 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
12:07:15 <ski> @hoogle withSystemRandom
12:07:15 <lambdabot> No results found
12:07:28 <ski> bgamari> :t withSystemRandom
12:07:40 <chrisdone> srhb: it's a very short list http://www.haskell.org/haskellwiki/Web/Comparison_of_Happstack%2C_Snap_and_Yesod#Happstack
12:07:40 <ski> bgamari> :t runRVarT
12:08:07 <srhb> chrisdone: Thanks anyway
12:09:41 <dumiopky> so any advice what i should do next?
12:10:03 <monochrom> do everything concurrently
12:10:04 * hackagebot osm-download 0.1.2 - Download Open Street Map tiles  http://hackage.haskell.org/package/osm-download-0.1.2 (ThomasDuBuisson)
12:10:12 <srhb> dumiopky: Start coding things, keep reading all the books.
12:10:22 <chrisdone> srhb: gitit's also done with happstack
12:10:34 <srhb> Ok :)
12:10:50 <ski> oh, `<ref>...</ref>' is an actual HTML construction ?
12:10:58 <chrisdone> concurrently eating currents while surfing on a strong current
12:11:13 <donri> chrisdone: patch-tag is built with happstack, darcsden with snap
12:11:22 <chrisdone> ski: afaik it's only a mediawiki construct
12:11:23 * ski figured it was just an ersatz
12:11:55 <Axman6> dumiopky: I'm still going to recommend project euler, because it gives you lots of problems that lead you to learning many new things about the language. the solutions themselves aren't important, but getting used to using the language is
12:12:26 <ski> chrisdone : well, in w3m, it displayed literally, but in firefox it got displayed as round brackets
12:14:37 <drull95> regarding all the record proposals, has there been any discussion about using type families instead of creating extensible records?
12:15:23 <drull95> i think adding support for qualified record accessors should be as far as we go
12:15:29 <drull95> at this time anyway
12:26:51 <yitz> drull95: what do you mean by "using type families"? If you have a proposol, write it up *in all of its detail* on the wiki, that would be appreciated.
12:27:30 <drull95> well, an extensible field is really an extensible type constructor right?
12:27:40 <yitz> drull95: i agree that just qualified record accessors would be a bite we could chew, and would be huge progress
12:28:27 <yitz> drull95: but then, i'm biases; that's the aspect of records which happens to bite me the most. others are more often bitten by other problems.
12:28:33 <yitz> *biased
12:29:08 <yitz> drull95: is it?
12:29:31 <drull95> an extension of a type constructor is really a change in the representation and that's what type families are for right?
12:31:26 <drull95> i think i will put something up on the wiki, im having a hard time thinking of words without constantly revising myself
12:31:55 <drull95> do you have an example where you want to use record extension?
12:32:03 <yitz> drull95: great! please do.
12:33:42 <yitz> drull95: my most common issue isn't realy extension. it's when you have a lot of data types with hundreds of fields each. you need to be able to group them easily, and you need to be able to name them meaningfully without the O(n^2) problem of checking for duplicates.
12:34:01 <yitz> drull95: but i know that extension is important too
12:35:25 <drull95> uh, the captcha wants an omega and i have no idea how to type that
12:36:07 <yitz> heh
12:36:22 <Jeanne-Kamikaze> can one link with a static library from cabal ? google seems to suggest you can't
12:37:04 <dcoutts> Jeanne-Kamikaze: one installed already on the system, yes, one bundled in the package itself, no (or at least not easily)
12:37:37 <Jeanne-Kamikaze> damn
12:38:14 <Jeanne-Kamikaze> a dude on a mailing list suggested putting the .a file in the same directory as the haskell library, and then letting applications manually link against it
12:39:03 <dcoutts> Jeanne-Kamikaze: on the other hand, simple .c files can be included in a lib/prog easily
12:39:28 <Jeanne-Kamikaze> yeah, but I need to build this with this makefile
12:39:37 <dcoutts> then best to install it first
12:39:45 <dcoutts> and have the Haskell package link against it
12:40:04 <Jeanne-Kamikaze> how to I link against it ? extra-libraries ?
12:40:08 <dcoutts> yep
12:40:11 <Jeanne-Kamikaze> the thing is
12:40:20 <Jeanne-Kamikaze> what if I actually have that library installed as well ?
12:40:29 <Jeanne-Kamikaze> if I add to extra-lib-dirs or whatever to make it look in there
12:40:38 <Jeanne-Kamikaze> and then do extra-libraries: zomg, but I have zomg installed system wide
12:40:50 <Jeanne-Kamikaze> will it actually look in the custom directory before the system one ?
12:41:02 <dcoutts> the assumption is usually that you'd install the C lib system wide
12:41:20 <dcoutts> or if not, the user will say where they've installed it
12:41:50 <dcoutts> extra-lib-dirs is really if you know that the system wide one is always in some location that's not on the usual linker path
12:42:04 <dcoutts> so it's hardly ever used
12:42:32 <dcoutts> that is, the extra-lib-dirs field in the .cabal file
12:42:52 <dcoutts> the --extra-lib-dirs= flag is for end users who choose to stick C libs in weird places
12:43:16 <bgamari_> ski: Any idea?
12:44:06 <ski> <ski> bgamari> :t withSystemRandom
12:44:06 <ski> <ski> bgamari> :t runRVarT
12:44:17 <Jeanne-Kamikaze> can you put paths in extra-libraries ? it's not finding
12:44:24 <Jeanne-Kamikaze> relative paths, that is
12:44:49 <Jeanne-Kamikaze> *finding it
12:44:53 <bgamari_> :t withSystemRandom
12:44:54 <lambdabot> Not in scope: `withSystemRandom'
12:46:18 <bgamari_> ski: I still don't know where this free type variable is coming from
12:46:33 <bgamari_> I believe in my code it should be clear that withSystemRandom's m is IO
12:51:32 <bgamari_> ski: Am I wrong?\
12:51:35 <DanBurton> quick question: is Agda turing complete?
12:51:59 <DanBurton> if not, challenge: name a programming language that is not turing complete
12:52:16 <DanBurton> * if so
12:54:25 <c_wraith> Agda is not turing-complete in the places where it forces proofs of termination.
12:55:03 <DanBurton> that...would make sense
12:55:41 <c_wraith> yes it would
12:56:04 <nexion> I'm looking for feedback on this data structure: http://hpaste.org/56356 -- do you guys see any potential problems with doing it this way? Basically, I want ClientData to always have cdSocket, and the rest of the data depends on the type of user it is
12:57:03 <nexion> it appears to work as expected, but I've only used types with one layer up to now, so just wanted to double-check
12:57:33 <nexion> or perhaps there's a cleaner way to write it
12:57:42 <c_wraith> nexion: all the accessor functions it creates are partial, which may not be what you want
12:58:06 <c_wraith> It means you need to pattern-match on a constructor to know which accessors you can use without hitting an error
12:58:13 <c_wraith> Which is mildly silly
12:58:29 <nexion> would it typecheck without patternmatching?
12:58:34 <c_wraith> yes
12:58:49 <c_wraith> that's what "partial" means in this case.  It type checks, but raises an error at runtime
12:59:00 <byorgey> DanBurton: Agda is not turing-complete by default.  You can pass a flag to turn off the termination checker and then it is.
12:59:19 <byorgey> DanBurton: Coq is also not turing-complete.
12:59:27 * DanBurton needs to learn him some Agda/Coq
12:59:39 <nexion> like I could do: cgdName clientData (and have it typecheck) as opposed to cgdName clientGuestData following a pattern-match?
12:59:54 <nexion> that's definitely not intended then
13:00:04 <c_wraith> nexion: that is what it means
13:00:12 <copumpkin> byorgey: you don't even need a flag. The thing just marks not-obviously-terminating definitions in pink. You need the flag if you want to import files that contain such things, though
13:00:17 <Sgeo> Clearly, we need a language in which only programs that terminate will compile, and all terminating algorithms can be made to compile.
13:00:20 <nexion> glad I asked :)
13:00:26 <byorgey> DanBurton: http://www.cis.upenn.edu/~bcpierce/sf/
13:00:27 <c_wraith> nexion: and yeah, that why you don't usually see people doing that
13:00:35 <byorgey> copumpkin: ah, fair enough.
13:00:59 <Sgeo> Actually, no reason that language can't exist.
13:01:09 <byorgey> Sgeo: see "halting problem".
13:01:22 <nexion> so I should have a separate data section for ClientGuestData, etc
13:01:26 <Sgeo> byorgey, see "who says that a language doesn't exist if its compiler can never be implemented?"
13:01:36 <DanBurton> byorgey: sweet! Just the book I was looking for, actually.
13:01:46 <byorgey> Sgeo: I guess it depends what you mean by "exists" =)
13:01:50 <copumpkin> the halting problem just states that there's no decision procedure for it
13:02:10 <dmwit> byorgey: Doesn't Coq have a way for you to instruct its termination checker how to prove a thing terminates?
13:02:12 <pdxleif> Umm, Agda?
13:02:17 <byorgey> right, I was naively assuming Sgeo wanted a terminating compiler. =)
13:02:24 <pdxleif> Or Coq.
13:02:30 <copumpkin> pdxleif: what about it?
13:02:32 <dmwit> So, any (provably) terminating algorithm can be made to compile by giving the checker a proof that it terminates.
13:02:41 <copumpkin> dmwit: you can use well-founded recursion I assume
13:02:44 <byorgey> dmwit: yes.
13:02:45 <dmwit> Or am I wrong?
13:02:47 <dmwit> okay
13:02:57 <dmwit> So, Sgeo's language already exists. Hooray!
13:02:58 <byorgey> dmwit: but Sgeo said "all terminating algorithms", not "all provably terminating algorithms"
13:03:03 <dmwit> aha
13:03:07 <dmwit> Yes, fine.
13:03:10 <copumpkin> but I imagine there are some things that are hard to prove terminating even with well-founded recursion
13:03:10 <pdxleif> RE: a compiler where all algorithms terminate
13:03:14 <copumpkin> dmwit: you still doing bitcoins by the way?
13:03:19 <dmwit> Nope.
13:03:24 <copumpkin> aw
13:03:31 <dmwit> I stopped really "doing" them shortly before the market crash. =P
13:03:38 <copumpkin> ah okay :)
13:03:49 <dmwit> I still have a few, but no real plans to do anything serious with them.
13:03:50 <byorgey> pdxleif: yes, Agda and Coq both enforce termination by default.  However there are many terminating algorithms that cannot be expressed in Agda or Coq.
13:04:07 <Sgeo> http://esolangs.org/wiki/Category:Uncomputable
13:04:34 * dmwit hobbles off to write a proof that all terminating programs are provably terminating
13:04:48 <dmwit> copumpkin: (Are you still doing things with bitcoin?)
13:04:48 <byorgey> haha, good luck with that
13:04:54 <pdxleif> Hmm... unsafePerformNonProvableTerminating?
13:04:58 <copumpkin> dmwit: oh yes, lots
13:05:12 <dmwit> byorgey: Well, it's terminating, right? So just run it until it terminates. Proof.
13:05:15 <dmwit> =)
13:05:38 <byorgey> hehe
13:05:38 <Sgeo> "The problem of determining whether or not a given string of symbols is a well-formed You are Reading the Name of this Esolang program is undecidable."
13:05:44 <copumpkin> dmwit, byorgey: you guys coming to hac bos?
13:05:49 <dmwit> copumpkin: Really? What? Just trading/mining, or something more interesting?
13:05:52 <dmwit> copumpkin: I plan to come.
13:06:04 <dmwit> (But don't tell my advisor.)
13:06:17 <byorgey> copumpkin: I had preemptively registered but it turns out that I won't be able to make it, sadly
13:06:25 <copumpkin> dmwit: I'm mostly a lender of bitcoins these days
13:06:27 <copumpkin> byorgey: aww :(
13:06:30 <copumpkin> dmwit: great!
13:06:36 <byorgey> copumpkin: just too crazy with a 4-month old and POPL the following week
13:06:37 <bgamari_> byorgey: By geometric heavy lifting, I mean computing self-intersections of paths, etc.
13:06:43 <copumpkin> byorgey: yeah, I imagine :/
13:06:54 <acowley> I had a talk proposal about Haskell rejected on the basis of a reviewer skepticism that functional languages have fast enough GCs. The talk was to a bunch of people using a lot of Python :(
13:07:05 <byorgey> wat
13:07:12 <copumpkin> wat
13:07:15 <copumpkin> acowley: you coming?
13:07:17 <dmwit> lolwut
13:07:20 <silver_> looooool
13:07:37 <silver_> python people talking about speed, something new
13:07:41 <acowley> copumpkin: I probably can't either. If I can it will be last minute because I need to get out ahead of all the upcoming deadlines
13:07:49 <copumpkin> wah!
13:07:55 <acowley> I still have to make my 5 min. talk for OBT!
13:07:57 <copumpkin> :(
13:08:09 <bgamari_> byorgey: I'm currently doing some computational geometry work, so your code might be of use
13:08:26 <acowley> copumpkin: it really sucks. It's been on my calendar for months now, and every time I look at it I get sadder
13:08:36 * bgamari_ never imagined that boolean operations on polygons would be so involved
13:08:48 <byorgey> bgamari_: diagrams hands the backend a list of explicitly located primitives like paths etc.  Anything the backend needs to do with paths is computed by the backend.
13:08:56 <acowley> copumpkin: hac boston also overlaps Chinese New Year
13:09:06 <bgamari_> byorgey: This is what I suspected
13:09:16 <byorgey> bgamari_: yeah, there's nothing like boolean operations on polygons implemented in diagrams yet
13:09:25 <byorgey> though it might be a cool thing to add
13:09:47 <copumpkin> dmwit: good money in making loans though :) unsecured loans to strangers on the internet who mostly connect from tor! :D
13:09:59 <bgamari_> byorgey: https://github.com/bgamari/GGen/blob/master/GGen/Geometry/PolygonCSG.hs
13:10:07 <bgamari_> byorgey: If you are looking for some code to fix ;)
13:10:17 <dmwit> I'm surprised. I proposed something like that to a friend, but he convinced me nobody would want to borrow bitcoin.
13:10:34 <dmwit> What the heck do people do with borrowed bitcoin?
13:10:36 <byorgey> bgamari_: not particularly ;)
13:10:43 <byorgey> bgamari_: looks cool though
13:11:19 <byorgey> lend it to other people.  I hear you can make good money lending bitcoins.
13:11:20 <acowley> dmwit: flip them as the basis of a random number generator
13:11:20 <copumpkin> dmwit: short sell, mostly, or other forms of speculation, or they start small online services companies like VPS things with them
13:11:29 <acowley> dmwit: then give them back to get the next one to flip
13:11:36 <bgamari_> byorgey: Nor do I, thus it hasn't been touched very much
13:12:17 <dmwit> byorgey: heh, yes, and the funny thing is copumpkin's answer partially corroborated this
13:12:41 * byorgey is sad that he was right
13:13:13 <copumpkin> :)
13:14:11 <dmwit> The other idea I had was a bitcoin-for-TF2-hats trading site, with automated trades. (No other online hat-trading site has both user-set prices and automated trades.)
13:14:28 <acowley> man, getting papers/talks rejected always hurts my productivity that day
13:14:34 <c_wraith> I'm not fully sure why TF2 hats are so popular, but...  good for them
13:14:34 <copumpkin> dmwit: make one in haskell!
13:14:41 <dmwit> But I have neither the time nor the reverse-engineering chops nor the legal balls of steel to make it happen.
13:15:00 <dmwit> c_wraith: Kind of stunning, isn't it?
13:15:05 <acowley> you're going to profit from relative fluctuations in the value of bitcoins and TF2 hats?
13:15:13 <acowley> that's amazing
13:15:24 <dmwit> Oh, no, I plan to profit by taking 0.5% of other people's trades.
13:15:30 <dmwit> Much more reliable.
13:15:36 <dmwit> =)
13:15:38 <acowley> less amazing, more profitable
13:16:24 <acowley> I kind of wish someone did spend all their time doing such trading. It would be great hearing them explain to an outsider what they do.
13:16:49 <dmwit> acowley: There are people that do TF2 trading full-time, and make $3000-$5000 per month.
13:16:53 <dmwit> (!)
13:16:56 <copumpkin> lol
13:17:30 <acowley> to re-use a phrae: wat
13:17:34 <acowley> phrase
13:17:38 <acowley> how?
13:17:59 <acowley> well, maybe I don't want to know
13:18:18 <dmwit> There are certain items which are artificially rare. These can go for anywhere from $50-$2000 per item, depending on how artificially rare they are.
13:18:30 <copumpkin> lol
13:18:33 <acowley> people pay $2k for a TF2 hat?
13:18:37 <dmwit> Yes.
13:18:49 <acowley> I was right, I didn't want to know
13:18:56 <dmwit> =)
13:19:47 <DukeDave> Ha, "things you don't expect to see when you tab to #haskell"
13:21:13 <DanBurton> acowley: whenever I type "wat" it's because I'm thinking of David Tennent as the 10th Doctor Who saying "what? what? WHAT?" with a British accent
13:21:55 <parcs`> dmwit: are vintage items worth something yet? i have a bunch of those :P and some vintage hats
13:22:25 <dmwit> Vintage hats, yes.
13:22:35 <acowley> DanBurton: That would be a fun sound effect to have in an IRC client
13:22:48 <DanBurton> slightly more relevant, does TF2 have a hat with the lambind symbol on it?
13:22:50 <dmwit> n vintage weapons are still only worth n+1 normal weapons.
13:32:14 <dmwit> So, idle curiosity: why are hierarchical module names so popular?
13:32:33 <dmwit> There was nothing stopping people from making CamelCaseHierarchies before the dot notation existed.
13:33:29 <Eduard_Munteanu> I guess it might make more sense with first-class modules.
13:33:48 <Eduard_Munteanu> (maybe that was a source of inspiration?)
13:34:10 <dmwit> Yeah, I guess it has to be viewed as a precursor to something more exciting.
13:34:22 <Igloo> dmwit: I think hierarchical modules were implemented when it would otherwise have been necessary to start using camel case
13:34:22 <dcoutts> dmwit: it's hard to distinguish hierarchy from multi-word names
13:34:43 <shachaf> I think people just like hierarchies.
13:35:26 <dmwit> heh
13:35:38 <mm_freak> dmwit: there is a correspondence between source file directories and hierarchial module names
13:35:46 <dmwit> True, that's nice.
13:35:48 <monochrom> haha CamelCaseHierarchy
13:36:13 <yitz> mm_freak: unfortunately. those two should be independent.
13:36:14 <hpc> case Hierarchy of Camel -> ...
13:36:28 <acowley> does anyone here use cabal-dev and emacs?
13:36:46 <mm_freak> yitz: why?
13:37:02 <yitz> acowley: i use both of those. but i don't run cabal-dev inside emacs, if that's what you mean.
13:37:08 <dmwit> yitz: There was some discussion recently of divorcing the two in GHC. You have to admit it is quite convenient in many cases, though.
13:37:12 <shachaf> mm_freak: Presumably because it would be nice if you could e.g. have multiple modules in a file.
13:37:22 <shachaf> In general the correspondence of module names to filenames is kind of odd.
13:37:32 <acowley> yitz: yes, that's what I want to do. I'm having no luck with any kind of ghci though. Even outside of emacs, getting my test-suite into ghci is proving a pain
13:37:40 <mm_freak> it's kind of odd, but it simplifies many things
13:37:45 <yitz> mm_freak: because those are two separate considerations. it really comes to bite you when those are tied for large complex projects.
13:38:06 <yitz> mm_freak: it's one of the worst mis-features of java. shame that it was copied into haskell.
13:38:14 * dmwit discovers ~/.cabal/share/doc for the first time
13:38:23 <dmwit> IT'S FULL OF STARS!
13:38:23 <mm_freak> yitz: the module system has more serious problems, and i like the simplicity of the scheme
13:38:23 <hpc> yitz: i like not having to "learn the module system"
13:38:39 <hpc> yitz: it's the only thing keeping me from programming in agda right now
13:39:02 <yitz> mm_freak: for simple projects where you don't want to think too much about how to organize your directories, it's a nice default. but it needs to be easy to turn that off.
13:39:09 <dcoutts> dmwit: ~/.cabal/share/doc/index.html
13:39:28 <dmwit> dcoutts: 404'd...?
13:40:18 <dcoutts> dmwit: oh, you need to edit the ~/.cabal/config file, line -- doc-index-file: $datadir/doc/index.html
13:40:26 <dmwit> ooooo
13:40:27 <mm_freak> yitz: i see your point, although project modules naturally map to files in my projects
13:40:30 <parcs`> acowley: you have to pass -package-conf cabal-dev/packages-7.0.4.conf to ghci
13:40:35 <dcoutts> dmwit: it'll regenerate when you next install something
13:40:45 <yitz> acowley: really? hmm, that would be a shame. i haven't tried it with test suites. but that really ought to be possible.
13:40:48 <dcoutts> dmwit: haddock module index of all installed packages
13:40:52 <dmwit> What should I edit it to?
13:40:53 <ski> mm_freak : seen "A Ban on Imports" by Gilad Bracha in 2009-06-30 at <http://gbracha.blogspot.com/2009/06/ban-on-imports.html> ?
13:40:58 <dcoutts> dmwit: uncomment the line
13:41:01 <dmwit> Also, this directory seems to be something different than what I was expecting.
13:41:12 <dcoutts> what were you expecting?
13:41:23 <acowley> parcs`: cabal-dev doesn't let me pass flags to ghci (which is another problem I have)
13:41:28 <monochrom> someone has to come up with rules on how a compiler find modules in the file system, and you, the programmer, has to learn those rules. the someone can make the rules 2 lines long and be inflexible, or 2 pages long and be so flexible as to be programmable by you
13:41:30 <ski> hpc : you should learn the module system in ML (either of SML or OCaml works)
13:41:41 <acowley> yitz: I suspect it's possible, but it didn't "just work"
13:41:51 <dmwit> err... rather, the particular library whose documentation I'm interested in seems not to appear
13:41:58 <mm_freak> what bothers me much more about the current module system is that circular module dependencies are not allowed
13:42:09 <yitz> mm_freak: in a large project, you want each of the following to be an independent variable - vcs repos, module structure, directory structure, team organization.
13:42:12 <dmwit> Which confused me into thinking no library's documentation appeared, which wasn't true.
13:42:15 * dmwit investigates
13:42:19 <dcoutts> dmwit: you need to have enabled doc generation in the ~/.cabal/config
13:42:35 <dcoutts> acowley: ooi, what kind of flags would you want to pass? you don't just want the environment specified by the .cabal file?
13:42:44 <mm_freak> yitz: if your project gets that large, you should consider splitting it into multiple projects
13:42:55 <yitz> mm_freak: well that's just the point
13:43:07 <acowley> dcoutts: I use ghci -fno-ghci-sandbox -framework Carbon when working with gloss and glfw-b
13:43:07 <dcoutts> acowley: I ask because I'm integrating the "cabal ghci" feature from the GSoC project atm
13:43:07 <dmwit> dcoutts: Yes, I have. The project just has some haddock errors, it seems.
13:43:18 <mm_freak> ski: reading it right now
13:43:35 <dcoutts> acowley: you don't use framework: Carbon in the .cabal file?
13:43:35 <yitz> mm_freak: you need to be able to divide it up in different ways
13:43:56 <acowley> dcoutts: I do, but I don't know if it's getting through to ghci
13:44:01 <monochrom> say, how about a rule that says you submit a javascript program to the compiler to tell it how to find modules in files? that's just 200 pages, but it buys you total control and decoupling for your large project. do you will it?
13:44:08 <dmwit> (It apparently assumes that documentation appearing in "class" blocks have the same indentation as the methods they're commenting.)
13:44:13 <dcoutts> acowley: I see, so just working around bugs in cabal-dev
13:44:26 <dcoutts> acowley: what about -fno-ghci-sandbox? I've never heard of it
13:44:30 <acowley> dcoutts: well, I don't know if it's a bug or just not supported
13:44:43 <yitz> monochrom: that doesn't sound like very much fun
13:44:45 <acowley> dcoutts: it lets ghci run on the process's primary thread
13:44:46 <mm_freak> yitz: i'm yet to come across a case, where the current package/module system is insufficient
13:44:56 <acowley> dcoutts: which GUI applications on the Mac ndeed
13:45:06 <monochrom> yeah, exactly my point. choose one: simple rule, flexible rule
13:45:16 <acowley> dcoutts: I should say, it causes ghci to run your code in the main thread
13:45:22 <mm_freak> i really like the simplicity of the current module system
13:45:27 <dmwit> dcoutts: I still don't see a ~/.cabal/share/doc/index.html, nor a ~/.cabal/share/pointless-lenses/html directory (despite verifying manually that "cabal haddock" succeeds for pointless-lenses).
13:45:27 <dcoutts> acowley: ah ok
13:45:29 <acowley> dcoutts: usually ghci runs user code in a separate thread to make things easier to abort
13:45:32 <yitz> monochrom: right. simple should be the default, but flexible should be possible.
13:45:45 <dcoutts> acowley: right
13:45:46 <mm_freak> the only two features i'm missing is:  mutually dependent modules and submodules
13:45:47 <dmwit> share/pointless-lenses-0.0.8/html of course
13:45:53 <mm_freak> though i can live without submodules mostly
13:46:29 <dcoutts> dmwit: share/doc/pointless-lenses-0.0.8/html
13:46:47 <yitz> monochrom: how about this: add an option to ghc that tells it to look for modules based on a simple manifest file you supply it rather than searching for directory names/file names in the file system that match module names.
13:46:57 <dcoutts> dmwit: share/pointless-lenses-0.0.8/ is for data files installed by pointless-lenses-0.0.8
13:46:57 <dmwit> dcoutts: Yes, there's no such directory.
13:46:58 <monochrom> that's an illusion. if the rule has a flexible option, it is no longer simple. it now says, "normally, <simple stuff here>, EXCEPT: ..." not so simple anymore, is it?
13:47:11 <dmwit> dcoutts: only LICENSE
13:47:39 <dmwit> I see I typo'd it above, but:
13:47:49 <dmwit> crabgrass:~/.cabal/share/doc% ls pointless-lenses-0.0.8
13:47:49 <dmwit> LICENSE
13:48:07 <yitz> monochrom: most people don't need to know or care about the ghc option. but its existence would make enterprise project management possible with ghc.
13:48:15 <dcoutts> dmwit: didn't cabal install --enable-documentation, or the equiv in the ~/.cabal/config
13:48:26 <dcoutts> dmwit: erm, sounds like you didn't *
13:48:48 <dmwit> hm
13:49:57 <dmwit> dcoutts: Okay, thanks. I could have sworn I'd switched that on long ago.
13:50:03 <mm_freak> yitz: could you give a concrete example of where that would be useful?
13:50:19 <monochrom> I am not convinced that "most" is most. true or false: most people only hack on projects originally authored by themselves, and not projects originally authored by others?
13:50:40 <dmwit> Aha! I switched it on at another machine. Is it safe to synchronize ~/.cabal between computers? Probably not, huh?
13:50:54 <dmwit> Anyway, ~/.cabal/config should be safe enough to synchronize.
13:51:07 <cheater_> @hoogle shqq
13:51:08 <lambdabot> package shqq
13:51:17 <cheater_> @hoogle ShQQ
13:51:17 <lambdabot> package shqq
13:51:19 <cheater_> uh.
13:51:30 <dmwit> ?hackage shqq
13:51:31 <lambdabot> http://hackage.haskell.org/package/shqq
13:52:05 <dmwit> cheater_: (What response were you hoping for, by the way?)
13:52:12 <monochrom> say I authored and uploaded a package to hackage, or github, whatever. for one reason or another, I exercised that option. say now for one reason or another, you download and hack on my package. can you not know the option anymore? sorry, innocence lost.
13:53:50 <dmwit> For my confused coreader: monochrom is exercising the option to write some kind of module manifest, not the option to upload his code to the Internet.
13:54:03 <yitz> mm_freak: you have separate repos for different teams, with directory organization matching subtasks for each team. now you want to compile a haskell program with modules taken from various subtasks of various teams.
13:54:19 <hpc> dmwit: monochrom has no right to upload code on the internet? ;)
13:54:33 <Eduard_Munteanu> monochrom: in my case, I think I've hacked on other projects more than on my stuff.
13:54:55 <monochrom> monochrom is a bot and has no right to upload to hackage under UN Resolution #2938 Section 1.3
13:55:05 <dmwit> yitz: -I ?
13:55:07 <Eduard_Munteanu> I don't even have a self-contained project I've started.
13:55:42 <yitz> dmwit: is -I different than -i ?
13:55:43 <Eduard_Munteanu> Well, I think I do have one but it's obsoleted. Others hacked it into something nicer :)
13:55:53 <dmwit> (I mean, I'm with you: it would be nice to be able to specify a manifest. But your example isn't exciting enough yet, I think. =)
13:55:53 <Pseudonym> Monochrom may be trying to do an end-run around Rule 21 of the Internet.
13:56:08 <dmwit> yitz: Probably. I meant whichever one is the one that changes the module search path.
13:56:17 <yitz> dmwit: -i won't help unless you use a flat namespace for all modules, without hierarchical names.
13:56:22 <Eduard_Munteanu> That's one strong AI :P
13:56:28 <dmwit> ...what?
13:56:32 <dmwit> That's not true.
13:56:57 <dmwit> You specify which subtasks you want by module name; you specify which teams you want with -i.
13:57:13 <yitz> dmwit: well you can encode the module heirarchy in the module name somehow, ghc actually does support something like that.
13:57:47 <cheater_> dmwit: i was hoping to get info on the module
13:57:47 <ski> (yitz : i assume you've seen that Bracha link, above)
13:57:57 <yitz> dmwit: generally module A.B.C must live in dir/A/B/C.hs where dir is in -i
13:58:01 <cheater_> as in the name of the module (complete path)
13:58:08 <mm_freak> yitz: that's a point where you really want to split your project into subprojects
13:58:16 <c_wraith> preflex: seen mmorrow
13:58:16 <preflex>  mmorrow was last seen on #ghc 1 year, 358 days, 19 hours, 44 minutes and 55 seconds ago, saying: * mmorrow is rtfm'ing
13:58:17 <cheater_> dmwit: because i didn't remember that.
13:58:49 <mm_freak> not just in a semantic way, but in a physical way‚Ä¶  create multiple cabal projects
13:58:51 <yitz> mm_freak: i did already, many subprojects. i need to compile a program that takes modules from several of them. with having to move around my directory structure to match the module hierarchy.
13:59:19 <mm_freak> yitz: why would the module hierarchy change?
13:59:27 <dmwit> Yeah, that's the piece I'm not getting either.
13:59:32 <yitz> mm_freak: each team has a number of separate cabal packages they work on as part of their subproject.
14:00:07 <yitz> mm_freak: the module hierarchy doesn't correspond to the division into subprojects necessarily.
14:00:20 <mm_freak> correct
14:00:42 <dmwit> Right. So you have subproject1/Foo/Bar/Baz.hs and subproject2/Foo/Quux.hs.
14:00:59 <dmwit> If you want to use both, you just import Foo.Bar.Baz and Foo.Quux, and set -isubproject1:subproject2
14:01:06 <dmwit> Am I missing something?
14:01:09 <yitz> the directories are structured according to tasks and subtasks, independent of module hierarchy
14:01:29 <mm_freak> dmwit: you don't use -i, you just use cabal properly
14:01:34 <yitz> dmwit: where exactly is Foo.Bar.Baz located? in what file path?
14:01:38 <mm_freak> then you have proper module dependencies, versioned and all that
14:01:46 <dmwit> yitz: I told you, in subproject1/Foo/Bar/Baz.hs
14:02:02 <mm_freak> yitz: you don't need to know that‚Ä¶  you just need to know the package
14:02:32 <yitz> there is no directory Foo or Bar. the directories are names of tasks, taken from functional requirements and other project documentation.
14:02:35 <mm_freak> if you use cabal properly, no package needs to know anything about the actual directory structure of any oder package
14:03:10 <yitz> because as manager, that's how i decided to organize things. except i can't because ghc and cabal are inflexible and are tying my hands.
14:03:24 <mm_freak> i don't see how
14:04:38 <yitz> mm_freak: look this is just an example which is what you requested. but the point is that module hierarchy and directory structure are really totally separate concerns. it should be possible to separate them.
14:05:00 <mm_freak> yitz: you are already separating them
14:05:12 <yitz> i can't, cabal and ghc won't let men.
14:05:13 <yitz> me
14:05:37 <mm_freak> what you are asking for is the possibility to have a module Foo in a file Bar.hs or a module Foo.X in the file Bar/X.hs
14:05:49 <mm_freak> that doesn't sound desirable to me
14:05:50 <yitz> mm_freak: right, or whatever.
14:06:28 <yitz> mm_freak: well those particular names are silly but i want the ability to pick whatever names i want.
14:06:33 <dmwit> yitz: Okay, now I think you've made it interesting enough. mm_freak just doesn't want to admit that you might want to do that. =)
14:06:38 <yitz> he
14:06:55 <mm_freak> dmwit: i'm interested in a case where you actually want that
14:07:17 <mm_freak> i can totally understand how you want to have multiple/freely chosen base directories, but you can already do that with cabal
14:07:33 <yitz> anyway, i'm getting along without this ability. it's quite annoying though. i can't believe it would be so hard to add such an option to ghc.
14:07:43 <mm_freak> however i can not see how you would want to disconnect file paths from module names
14:08:02 <yitz> mm_freak: i can not see how you would want them connected
14:08:04 <c_wraith> ruby disconnects file paths from module names.  It's an incredible pain, often.
14:08:10 <yitz> what do they have to do with each other?
14:08:25 <mm_freak> yitz: i know where to find stuff
14:09:01 <mm_freak> what i really love about haskell is that i can unpack a project and go right into the code
14:09:11 <mm_freak> haskell has an extremely short idea-to-code period
14:09:24 <mm_freak> anything complicating that i find undesirable
14:10:17 <yitz> mm_freak: you have one particular system deeply etched in your brain, so you can find things. if a different system works better, you have slowed down the idea-to-code period.
14:10:51 <yitz> mm_freak: it's not just idea-to-code. it's keeping track of a huge amount of complexity that doesn't come up in smaller projects.
14:11:02 <mm_freak> yitz: that's why i asked for an example‚Ä¶  i'm open for innovations, but i don't exactly see the innovation in this particular case
14:11:32 <yitz> mm_freak: i really don't think i'm saying anything so difficult to understand
14:12:19 <dmwit> Part of the problem is that any example that requires a manifest is inherently too complicated to say in a few lines of IRC chat.
14:12:34 <c_wraith> yitz: and things like ActiveSupport in ruby are very strong evidence that making modules independent of the file system can result in very bad things
14:13:29 <mm_freak> yitz: well, you are theorizing‚Ä¶  IMO this disconnection will introduce the same problems that we have in PHP
14:13:29 <yitz> c_wraith: it should definitely be off by default.
14:13:43 <mm_freak> or C++ for that matter
14:14:13 <yitz> mm_freak: no because people will not go out of their way to do this. only managers of projects who need it will use it, and that won't affect anyone else.
14:14:36 <mm_freak> yitz: in your project, yes
14:15:08 <mm_freak> what about the rest of the world?  theoretically only managers and framework developers would set up the file/class correspondence in PHP, but that's not how the real world works
14:15:20 <mm_freak> and in almost all cases the result is a total mess
14:15:56 <mm_freak> that's one of the reasons why PHP code is doomed to become unmaintainable at some point, no matter what you do
14:16:15 <mm_freak> and i really prefer not to have that in haskell
14:16:31 <yitz> mm_freak: i'm not proposing anything like php
14:16:51 <mm_freak> the current scheme is somewhat restrictive, but it's simple and predictable‚Ä¶  it also forces you to think harder about the structure of your project
14:17:25 <monochrom> (pun: PHP managers = PHB :) )
14:17:38 <yitz> mm_freak: when you have to scale, "forces you to think harder" can mean "makes the project intractably complex".
14:18:11 <yitz> mm_freak: the current restrictive system is just fine. it should remain in place.
14:18:40 <mm_freak> yitz: that's because when your original scheme fails to scale, you are tempted to work around the issue‚Ä¶  in haskell's module system this is impossible
14:18:43 <yitz> mm_freak: i'm just asking for a way that enterprise project managers can use haskell much more productively.
14:18:55 <mm_freak> you will have to restructure your project, if your original structure is not flexible enough
14:19:00 <hpc> yitz: i think it prevents you from thinking too hard; you decide what structure the modules will have and the file structure falls the same way
14:19:08 <mm_freak> yes, it needs some work, but it's worth it
14:19:08 <hpc> yitz: rather than having both to think about
14:19:23 <yitz> mm_freak: you know what, this could even be in a special build of ghc with some flag to enable it.
14:19:39 <guibou> hello there. Am I allowed to ask a stupid question about typesafety when I don't know anything about haskell, but I have an issue in C++ and python and I'd like to know how the haskell typesystem handle this ?
14:19:50 <hpc> guibou: ask away
14:20:21 <mm_freak> yitz: i totally understand your desire, but i say that you may be suffering from the more flexible = more productive fallacy
14:20:34 <yitz> hpc: yes, and that's fine.
14:21:10 <yitz> mm_freak: no. i have learned that surprising little things become big issue when you scale.
14:21:38 <mm_freak> yitz: correct, and there are two ways to solve the problem when it comes up
14:21:47 <mm_freak> one is to work around, the other is to fix
14:21:55 <yitz> mm_freak: one is: use a different programming language
14:22:00 <mm_freak> haskell doesn't give you the flexibility to work around
14:22:08 <guibou> ok ;). I have an application which have to handle colors. Colors is basically a triplet of floating point c0, c1, c2. Operation on color are defined, such as + which is a simple vector +. Now I have some different colorsystem (such as RGB, HSL, ...) which are color, use the operator on color. I Only want to avoid one think, to add RGBColor with HSLColor. How did you do that in haskell ?
14:22:16 <yitz> mm_freak: i don't prefer that solution though
14:22:41 <mm_freak> guibou: an algebraic data type
14:22:54 <Peaker> guibou: You can define two different color types, each with its own Num instance
14:23:00 <gwern> hm. if a channel is publicly logged, does that mean one is allowed to quote from one's own log of the channel?
14:23:01 <mm_freak> guibou: data Color = RGB Double Double Double | HSL Double Double Double | ‚Ä¶
14:23:05 <yitz> mm_freak: work arounds have a cost. sometimes there is a multiplier of the cost that you wouldn't even think about for a small project.
14:23:23 <c_wraith> mm_freak: that's the opposite of preventing combining colors with different representations
14:23:23 <monochrom> one RGB type. one HSL type. both enjoys +, but can't be mixed
14:23:34 <Peaker> mm_freak: that's assuming he wants to define + for them both
14:23:39 <mm_freak> oh, he wants to /prevent/
14:23:49 <yitz> gwern: forunately, the logging process is time bound, so i think it would be hard to cause an actual loop
14:23:50 <mm_freak> well, either separate types or a type family
14:23:55 <mm_freak> data Color :: * -> *
14:23:59 <mm_freak> data family Color :: * -> *
14:24:09 <mm_freak> data instance Color RGB = RGB Double Double Double
14:24:09 <mm_freak> etc.
14:24:11 <dmwit> ?hackage colour
14:24:11 <lambdabot> http://hackage.haskell.org/package/colour
14:24:18 <gwern> yitz: oh, the process terminates, I'm just wondering if it satisfies the ircnad laws
14:24:26 <monochrom> how haskell allows + for both and still no mixing allowed: the same way Int+Int, Double+Double are allowed but Int+Double not
14:24:39 <monochrom> > (0 :: Int) + (0 :: Double)
14:24:39 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:24:39 <lambdabot>         against inferred type ...
14:24:43 <mm_freak> yitz: well, we could theorize about that all night long without a conclusion =)
14:24:45 <Peaker> guibou: if you have a Vector3 type with a Num instance, you can enable the "GeneralizedNewtypeDeriving" extension, and use: newtype RGB = Vector3 Double deriving (Num) ; newtype HSL = Vector3 Double deriving (Num)
14:24:47 <monochrom> that's the result
14:25:03 <yitz> mm_freak: yeah i think we've made our points :)
14:25:17 <mm_freak> =)
14:26:24 <guibou> (so much information so quick. I'm not answering, but it is because I'm reading and googleing every stuff I don't understand. Thank, I'll answer in a few minutes ;)
14:26:29 <yitz> mm_freak: why a type family and not a class?
14:27:00 <monochrom> because the answerer does not read the part about "I don't know haskell yet"
14:27:04 <mm_freak> yitz: because for a type family of colors you can write common class instances where applicable and separate ones where not
14:27:15 <yitz> ok
14:28:03 <dmwit> Yeah, type/data families definitely seem like an inappropriate answer here.
14:28:35 <amiller> would anyone like to recommend a Monad library for coq
14:28:38 <amiller> i've found a few
14:28:40 <monochrom> it's an overkill. may as well answer "download agda"
14:28:47 <amiller> i can't really evaluate between them / appreciate the differences.
14:29:13 <mm_freak> it's not overkill, it's just not particularly beginner-friendly =)
14:29:20 <mm_freak> guibou: sorry for that, ignore my answer
14:29:56 <guibou> mm_freak: no issue ;) my question is also a bit rough "hello, I don't know anything, but i have a complex question about the type system" ;)
14:30:04 <yitz> mm_freak: it may or may not be overkill, depending on what common operations need to be defined on colorspaces
14:30:28 <hpc> guibou: perhaps a friendlier answer might be something like
14:30:43 <hpc> enum ColorSpace {RGB, HSV, ...}
14:30:57 <dmwit> amiller: Hm. Perhaps the #coq channel would have a better answer.
14:30:58 <hpc> class Color {Double a, b, c; ColorSpace s;}
14:31:12 <hpc> guibou: to use Java syntax
14:31:30 <dmwit> Haskell can do better than Java here.
14:31:34 <yitz> hpc: the languages mentioned were c++ and python
14:31:43 <mm_freak> hpc: then you can't statically prevent adding RGB to HSV
14:32:22 <mm_freak> in C# and C++ you would normally want simple, separate classes with a polymorphic adder function
14:32:23 <hpc> that was just meant to be a segue into the answer above
14:32:45 <mm_freak> not sure if java supports that
14:33:13 <mm_freak> A addColor<A>(A x, A y);
14:33:23 <mm_freak> or a template function in C++
14:34:06 <mm_freak> yitz: type families are always overkill, if you are not used to them, and never, if you are =)
14:34:34 <dmwit> Type families are delicious, and are only going to get better.
14:35:00 <guibou> mm_freak: currently i have solved the issue with a template function in C++, but the issue is that my template is so generic that any type with attributs c0, c1, c2 can be used in this function, perhaps by mistake, so I'm looking for something more "safe"
14:35:05 <mm_freak> just like with GADTs‚Ä¶  you never need them, until you find a single use for them =)
14:35:14 <mm_freak> at which point you start using them for every goddamn thing =)
14:36:07 <mm_freak> guibou: in legacy C++ you can't really do anything about that‚Ä¶  presumably C++1x has a solution there
14:36:50 <dmwit> Oh, have they finally admitted the 'x' in "C++0x" isn't a hex digit?
14:37:16 <hpc> > 0x
14:37:17 <lambdabot>   0
14:37:22 <Peaker> Woah
14:37:59 <mm_freak> in ghci 7.0.3 that's a syntax error
14:38:02 <hpc> that's valid haskell, if C :: Monoid foo, Num foo => foo
14:38:02 <yitz> > 0xe20
14:38:03 <lambdabot>   3616
14:38:14 <hpc> in theory at least
14:38:17 <Peaker> I love yairchu's GADT use in RBTree: https://github.com/yairchu/red-black-tree/blob/master/RedBlackTree.hs#L32
14:38:22 <Peaker> (Guaranteeing the balance invariants)
14:39:21 <mm_freak> recently i've been using a GADT for an Either that can choose never to go Left
14:39:36 <hpc> mm_freak: i like it
14:39:53 <yitz> mm_freak: that sounds like Wit's End in Adventure.
14:40:10 <ski> > 0o
14:40:10 <lambdabot>   0
14:41:47 <mm_freak> yitz: what's that?
14:46:15 <Matthew117> Hello
14:50:25 <Matthew117> I'm new to Haskell, and I'm having a problem safely parsing indexes, tuples in the form (x,y) where x and y are ints. Basically I'm coding the boardgame Orthello (Reversi) and I need a way to enter moves. When you type in input in the right format, it's fine, but accidentally miss out a bracket or comma and it crashes.
14:50:49 <c_wraith> are you just using read?
14:52:03 <yitz> mm_freak: never mind. a very very old game. you had to be there.
14:52:28 <Botje> Matthew117: check out the reads function.
14:52:47 <Botje> you either get back an empty list or a singleton list
14:52:55 <Matthew117> I am just using read. I tried some other things like reads and using exceptions, but I didn't have much luck.
14:53:52 <hpc> :t reads
14:53:53 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:54:15 <hpc> > reads "(1, 2" :: (Int, Int)
14:54:16 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, GHC.Types.Int)'
14:54:16 <lambdabot>         again...
14:54:22 <hpc> > reads "(1, 2" :: ReadS (Int, Int)
14:54:23 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
14:54:23 <lambdabot>           ...
14:54:26 <hpc> argh
14:54:37 <hpc> > reads "(1, 2" :: [((Int, Int), String)]
14:54:38 <lambdabot>   []
14:54:59 <Botje> case reads foo of [] -> (ask again); [((x,y), _)] -> use (x,y)
14:55:08 <Matthew117> ahh, I see
14:55:15 <Matthew117> Thank you
14:55:34 <yitz> > let maybeRead = fmap fst . listToMaybe . reads in map maybeRead ["(1,2)", "(3,4"] :: [Maybe (Int,Int)]
14:55:36 <lambdabot>   [Just (1,2),Nothing]
14:55:44 <monochrom> inexhaustive pattern
14:56:40 <Botje> do you know of examples where reads produces more than one element?
14:57:10 <monochrom> not in the wild, but I wrote some toy ones
14:57:46 <monochrom> the ReadP lib makes it easy to write even more
14:59:50 <Botje> fair enough :)
14:59:53 <Botje> << bed bed bed
15:00:45 <yitz> Matthew117: here's a neat trick using reads that allows much more flexible input syntax:
15:00:48 <yitz> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "1. Picks out any numbers in the string. 2. Has 100's of uses." :: [Int]
15:00:50 <lambdabot>   [1,2,100]
15:01:38 <Peaker> mm_freak: I also thought about a type-tagged Either GADT, in the context of the arrow-choice combinator: Instead of   (a ~> a') -> (b ~> b') -> Either a b ~> Either a' b'   -- have:  SEither tag a b -> SEither tag a' b'  (where tag being same means both are Left or both are Right)
15:05:57 <mm_freak> Peaker: that gives you ArrowChoice without choice =)
15:09:51 <Peaker> mm_freak: the choice is which function to apply
15:10:08 <Peaker> mm_freak: currently that invariant already holds, it's just not encoded in the type
15:10:20 <Peaker> (If given a Left, it will yield a Left, and same for Right)
15:11:58 <mm_freak> Peaker: i'm using it for a different purpose‚Ä¶  a signal function always gets an input signal, but may not produce an output signal
15:12:11 <mm_freak> Signal P e a -> SP e b
15:12:25 <mm_freak> where:  data SP e a = forall p. SP (Signal p e a)
15:12:43 <Manehattan1> hi... can someone point me to some article/paper/tutorial, that can help me understand how to do an IO () thingie in Arrow context?
15:13:19 <mm_freak> Manehattan1: you mean use IO stuff inside of an arrow?
15:13:24 <shachaf> Manehattan1: IO and Arrow are two very different sorts of things.
15:13:24 <mm_freak> sort of like liftIO?
15:13:34 <Manehattan1> I know they are
15:13:45 <shachaf> One is a type constructor and the other is a (multi-parameter) type class.
15:14:04 <shachaf> What do you mean by "Arrow context"?
15:14:53 <Manehattan1> shachaf:  proc x -> do {- arrow stuff here -}
15:15:07 <shachaf> For any Arrow?
15:15:20 <Manehattan1> I'm sure I've seen something mentioning Kleisli
15:15:40 <Manehattan1> the Arrow type is yet to be made, kinda
15:15:43 <shachaf> Are you looking for a specific Arrow?
15:15:48 <mm_freak> if you would say yes or no, i could help
15:15:59 * shachaf never mind.
15:15:59 <Manehattan1> mm_freak: yes
15:16:31 <mm_freak> there you go‚Ä¶  if your arrow allows the effects of an underlying monad, then you can write a type class for this sort of thing
15:16:46 <mm_freak> i called mine ArrowKleisli, which may or may not be an appropriate name
15:17:11 <mm_freak> Manehattan1: http://hackage.haskell.org/packages/archive/netwire/3.1.0/doc/html/Control-Wire-Classes.html
15:17:15 <mm_freak> see the ArrowKleisli class
15:17:32 <Manehattan1> mm_freak: I need to do network stuff in the arrow's execution... though I don't even know if I am thinking right
15:17:45 <mm_freak> depends
15:17:56 <mm_freak> what kind of an arrow, and are you sure you need an arrow?
15:18:10 <shachaf> Saying "the Arrow" is even less informative than saying "the Monad".
15:20:06 <Manehattan1> mm_freak: something like broadcast :: Message -> a Clients (err, Clients)
15:20:53 <mm_freak> Manehattan1: you have left the interesting thing unspecified:  the 'a'
15:21:15 <c_wraith> Watch a be something like Kleisli IO
15:21:37 <Manehattan1> mm_freak: Which I am yet to find out ^^ I am a noob.
15:22:31 <mm_freak> Manehattan1: then better go with:  broadcast :: Message -> [Client] -> MyMonad (err, [Client])
15:22:57 <Manehattan1> mm_freak: Obviously
15:22:57 <HardFu> any channel ops present?
15:24:45 <Manehattan1> something about this frp stuff is a bit beyond me, I can't seem to fit that jigsaw bit into my project idea
15:24:57 <mm_freak> Manehattan1: while you are a beginner i'd suggest to forget the word "arrow", unless you are into high performance parsing, computation meta-information or FRP
15:24:58 <gwern> > ln 100
15:24:58 <lambdabot>   Not in scope: `ln'
15:25:09 <hpc> > log 100
15:25:10 <lambdabot>   4.605170185988092
15:25:17 <Peaker> > logBase 2 128
15:25:18 <lambdabot>   7.0
15:25:21 <hpc> > logBase (exp 1) 100
15:25:22 <lambdabot>   4.605170185988092
15:25:46 <mm_freak> Manehattan1: arrowized FRP (AFRP) is based around the automaton arrow:  newtype Auto a b = Auto (a -> (b, Auto a b))
15:25:47 <Peaker> > exp (2*pi*i)
15:25:48 <lambdabot>   exp (2 * pi * i)
15:26:04 <Peaker> > exp (0 :+ 2*pi)
15:26:05 <lambdabot>   1.0 :+ (-2.4492935982947064e-16)
15:26:05 <gwern> > log 0
15:26:05 <mm_freak> Manehattan1: if you look closely at that type, you will find that it denotes a parametric stream
15:26:06 <lambdabot>   -Infinity
15:26:14 <mm_freak> Manehattan1: that type is not a monad
15:26:52 <Manehattan1> mm_freak: I think I started at the wrong end, then
15:27:08 <mm_freak> Manehattan1: likely‚Ä¶  i doubt that AFRP is beginner-friendly =)
15:27:12 <gwern> > logBase 10 100
15:27:13 <lambdabot>   2.0
15:27:16 <gwern> > logBase 10 0
15:27:17 <lambdabot>   -Infinity
15:27:29 <gwern> hrm. I should rewrite my example to avoid zeros, it seems
15:27:33 <Manehattan1> mm_freak: I don't see myself as a beginner and I am determined to do this
15:28:15 <mm_freak> Manehattan1: then copy the newtype i gave you into a source file and write Category, Applicative and Arrow instances for it
15:28:16 <jboning> is there a good reason that Data.List doesn't include a generalized split function? words and lines are nice to have around, but sometimes, you want to split strings on, say, comma...
15:28:39 <hpc> @src words
15:28:39 <lambdabot> words s = case dropWhile isSpace s of
15:28:39 <lambdabot>     "" -> []
15:28:39 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
15:28:44 <hpc> @src lines
15:28:44 <lambdabot> Source not found. Take a stress pill and think things over.
15:28:51 <Manehattan1> @src splitOn
15:28:52 <lambdabot> Source not found. My mind is going. I can feel it.
15:28:57 <hpc> well that's annoying
15:29:45 <jboning> indeed. with functions like group lying around, I would think something like split would be present
15:30:07 <mm_freak> in some cases you can use groupBy for splitting or at least for lexing
15:30:09 <Saizan> there's the split package btw
15:30:24 <rwbarton> http://byorgey.wordpress.com/2008/12/21/datalistsplit/ http://hackage.haskell.org/package/split
15:32:11 <jboning> well, it's a bit annoying that I have to grab the package or roll my own
15:32:15 <jboning> anwyay, thanks!
15:32:33 <yitz> jboning: nothing wrong with grabbing packages.
15:33:07 <Manehattan1> mm_freak: I've read a bunch of articles on FRP, and I understand it, but there's something keeping me from implementing it... I don't know if it's even a good idea to use it for my project
15:33:34 <mm_freak> Manehattan1: what is your project?
15:33:47 <yitz> mm_freak: the Manehattan1 project
15:33:56 <Manehattan1> yitz: Yes.
15:33:57 <mm_freak> hehe
15:34:53 <Manehattan1> mm_freak: I want to make a bunch of functions, combinators that help serving server-push content to a website
15:35:32 <mm_freak> Manehattan1: FRP is useful whenever you have things in your application that have local state and have data dependencies between them
15:36:47 <Manehattan1> mm_freak: There would be a message manager that reacts to events (message sent, client disconnect) and sends messages accordingly to its peers
15:37:22 <yitz> Manehattan1: the banana frp package, by apfelmus, might be a relatively easy way to get started with frp
15:37:53 <Manehattan1> yitz: I've skimmed it, but not closely...
15:39:10 <mm_freak> well, in haskell there are basically two approaches to FRP
15:39:38 <mm_freak> reactive-banana takes the classic time-dependent values approach
15:39:40 <Manehattan1> mm_freak: Also I want to make it easy to implement something like partial loading of a site
15:40:17 <mm_freak> the other approach is AFRP
15:40:53 <mm_freak> classic approach models Time -> Value functions, while AFRP models automata, self-mutating functions
15:41:49 <Manehattan1> mm_freak: I gathered that, and I came to the conclusion that my "stuff" is not really time dependent, just continuous
15:42:46 <mm_freak> well, for network applications you might be interested in my AFRP library netwire
15:43:09 <mm_freak> it's very powerful and fast, but not easy to get into
15:45:00 <Manehattan1> mm_freak: Of course, when you have an idea, someone else already did it
15:46:09 <Eduard_Munteanu> Oleg? :P
15:46:27 <mm_freak> Manehattan1: i think the wire idea is originally from me =)
15:46:45 <mm_freak> it's a generalization of the automaton arrow
15:46:47 <Manehattan1> mm_freak: Well, yes, I was referring to myself
15:46:55 <mm_freak> ah, i see
15:49:59 <Manehattan1> ah great, don't know what to do about it now
15:50:18 <mm_freak> Manehattan1: if you still want to do it yourself, familiarize yourself with the automaton arrow‚Ä¶  it's the core engine that drives AFRP
15:50:46 <Manehattan1> mm_freak: Ok, thanks for that, I will read myself into the topic
15:50:55 <mm_freak> perhaps you come up with your own generalization of it that solves event handling and change propagation in a new way =)
15:51:52 <mm_freak> but netwire is very difficult to beat there =P
15:55:40 <Manehattan1> mm_freak: I will probably look at netwire too. From the first look, it's very complex and I'm feeling my project has only a small intersection with it
15:56:22 <mm_freak> Manehattan1: it's actually simple to use, but can be difficult to understand
15:57:36 <Manehattan1> mm_freak: From my more than rocky road-trip to haskell I learned this: Every haskell concept seems incredibly difficult to understand, until you suddenly realise the beauty behind it, and then you wonder why you've been so stupid all the time
15:58:10 <mm_freak> yeah, that's true
15:58:27 <hpc> Manehattan1: and then you meet someone who doesn't understand it and wonder why it's so hard to teach ;)
15:59:06 <mm_freak> no matter what concept‚Ä¶  there is a point when it makes click and suddenly it seems so goddamn obvious =)
15:59:07 <Saizan> well, not every, mostly the ones that have been around for a lot
15:59:18 <Manehattan1> hpc: That goes for any computer topic, even teaching your gran how to send an email
15:59:19 <monochrom> my experience: "simple to use" is good. "difficult to understand" is because you think too much
15:59:23 <mm_freak> at least if it's a sound concept
15:59:27 <mm_freak> not every concept is sound of course
16:00:21 <monochrom> @quote array
16:00:21 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
16:00:39 <mm_freak> > 5x
16:00:40 <lambdabot>   5
16:00:43 <mm_freak> d'oh
16:00:48 <mm_freak> now i understand how that works
16:00:54 <hpc> > 5xf
16:00:55 <lambdabot>   Not in scope: `xf'
16:01:01 <mm_freak> 5xf = 5 xf
16:01:03 <hpc> > 0xf
16:01:04 <lambdabot>   15
16:01:08 <mm_freak> and 5 = const 5
16:01:14 <hpc> oh
16:01:16 <hpc> derp
16:01:27 <mm_freak> in lambdabot that is =)
16:01:30 <mm_freak> > 5 15
16:01:31 <lambdabot>   5
16:01:59 <LoliShana> > 5 15
16:02:00 <lambdabot>   5
16:02:21 <LoliShana> Is there some documentation on what this bot can do?
16:02:40 <hpc> @hackage lambdabot
16:02:41 <lambdabot> http://hackage.haskell.org/package/lambdabot
16:02:44 <mm_freak> LoliShana: ">" does regular haskell evaluation, but lambdabot has a Num instance for numeric functions
16:02:57 <mm_freak> > (sin + cos + 5) 3
16:02:58 <lambdabot>   4.151127511459422
16:02:59 <LoliShana> Thanks
16:06:14 <LoliShana> > product [1..5]
16:06:15 <lambdabot>   120
16:06:44 <Manehattan1> > let t = 0:t
16:06:45 <lambdabot>   not an expression: `let t = 0:t'
16:06:53 <Manehattan1> aww
16:07:02 <hpc> > let ones = 1 : ones in ones
16:07:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:09:42 <Manehattan1> > let t = 0:t in t
16:09:43 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:09:54 <Manehattan1> > let t = 0:t in reverse t
16:09:58 <lambdabot>   mueval-core: Time limit exceeded
16:10:23 <sshine> how do you specify multiple lets in one line?
16:10:38 <sshine> > let x = 1; y = 2 in (x, y)
16:10:40 <azaq23> > let {a = 5; b = 10} in a +b
16:10:41 <lambdabot>   (1,2)
16:10:41 <lambdabot>   can't find file: L.hs
16:10:55 <Manehattan1> > let t = 0:t; let u = 1:u in t ++ u
16:10:55 <hpc> you broke it!
16:10:56 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:11:09 <azaq23> nice
16:11:14 <Manehattan1> > let t = 0:t; u = 1:u in t ++ u
16:11:19 <lambdabot>   mueval: ExitFailure 1
16:11:20 <lambdabot>  mueval: Prelude.undefined
16:11:25 <hpc> > 5
16:11:27 <sshine> let x = 1:y; y = 0:x in x
16:11:27 <lambdabot>   5
16:11:35 <sshine> > let x = 1:y; y = 0:x in x
16:11:35 <shachaf> You can experiment with lambdabot in /msg if you want to work out how to do things.
16:11:36 <lambdabot>   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,...
16:11:39 <mm_freak> > fix (1:)
16:11:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:11:47 <Manehattan1> or use ghci locally
16:11:59 <shachaf> Yes, but that won't let you experiment with lambdabot.
16:12:03 <sshine> right, shachaf.
16:12:12 <Manehattan1> > repeat 1
16:12:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:12:19 <sshine> shachaf, is there any way to annoy all of #haskell while writing to lambdabot privately? ;-)
16:12:52 <shachaf> sshine: You could probably increase latency for #haskell queries significantly if you did things right.
16:12:56 <hpc> sshine: if you discover one, make sure it's well documented so others can make use of it ;)
16:12:56 <shachaf> That could work.
16:12:58 <parcs`> @let map = map
16:12:59 <lambdabot>  <local>:1:107:
16:12:59 <lambdabot>      Ambiguous occurrence `map'
16:12:59 <lambdabot>      It could refer to either...
16:13:04 <shachaf> Or you could @undefine randomly.
16:13:22 <hpc> @let botsnack = text ":D"
16:13:23 <lambdabot>  Defined.
16:13:26 <Manehattan1> like @let (+) = (-)
16:13:28 <shachaf> As far as techniques for annoying everyone in #haskell, people have proven to be very creative.
16:13:40 <hpc> @protontorpedo -- an example
16:13:40 <lambdabot> can I build a sales database with it?
16:13:43 <sshine> > botsnack
16:13:45 <lambdabot>   :D
16:13:51 <Manehattan1> @vixen
16:13:52 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
16:14:05 <sshine> @t text
16:14:06 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:14:07 <shachaf> If you want to experiment with lambdabot in public, you can also do so in #haskell-overflow.
16:14:38 <Axman6> @thanks
16:14:38 <lambdabot> you are welcome
16:14:48 <Manehattan1> that would be like buying an extra-loud harley and NOT trying it out at 5 AM in the middle of the neighbourhood
16:15:16 <gwern> hm. are we not allowed to write '[1..50, 1..50]'?
16:15:22 <shachaf> gwern: Nope.
16:15:32 <gwern> huh. I rather expected that to work when I tried it
16:15:57 <shachaf> You can write [1..50] ++ [1..50] or concat [[1..50], [1..50]] or something.
16:16:03 <gwern> I know, but that's kind of ugly
16:16:18 <shachaf> Your syntax proposal is ambiguous. :-)
16:16:37 <shachaf> (Because [1,5..50])
16:16:52 <Axman6> > join (++) [1..50]
16:16:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:17:11 <irene-knapp> :t join
16:17:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:17:15 <Axman6> > [1..50] >>= id
16:17:16 <lambdabot>   No instances for (GHC.Num.Num [b], GHC.Enum.Enum [b])
16:17:16 <lambdabot>    arising from a use...
16:17:20 <Axman6> :\
16:17:47 <Axman6> oh right, wrong join >_<
16:18:00 <irene-knapp> foldl1 (++) [1..50]
16:18:04 <irene-knapp> > foldl1 (++) [1..50]
16:18:06 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:18:06 <lambdabot>    `GHC.Enum.Enum a'
16:18:06 <lambdabot>      a...
16:18:09 <irene-knapp> > foldl1 (++) [1..50] :: Int
16:18:10 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
16:18:10 <lambdabot>    arising from a use of...
16:18:22 <irene-knapp> hm.
16:18:26 <irene-knapp> :t foldl1
16:18:27 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
16:18:31 <Axman6> that doesn't make any sense withoug Num a => Num [a] :\
16:18:37 <Axman6> without*
16:18:39 <parcs`> > foldl1 (++) [1..50] :: Sum Int
16:18:40 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
16:18:41 <lambdabot>    arising fr...
16:19:08 <parcs`> that num instance should exist :P
16:19:23 <Axman6> there's lots of different ways to implement it
16:19:54 <Saizan> not really?
16:19:58 <Axman6> zip based or polynomial based are popular ones
16:20:21 <ergot_> I'm having trouble with parseURI with what it looks like a normal uri, actually I tested copying the uri from the output of my program and parseURI works in that case
16:20:23 <Axman6> ok, there's a few anyway
16:20:36 <Saizan> parcs` meant for Sum, i think
16:20:39 <ergot_> I got the uri I want to parse from a downloaded web
16:20:53 <Axman6> oh, right
16:20:55 <ergot_> could be due encoding problems?
16:20:59 <parcs`> yeah, for Sum and Product
16:21:25 <Axman6> > 1 :: Sum Int
16:21:26 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
16:21:26 <lambdabot>    arising fr...
16:28:23 <ergot_> any function I can use to turn a String into an encoding that will work with parseURI?
16:29:40 <FxMasta> wanna learn how to trade, e book + system, daily 200 $ in 3 hours http://uploading.com/files/3m785864/Forex%2BTrading%2BStrategies.rar/
16:29:50 --- mode: ChanServ set +o monochrom
16:29:54 --- mode: monochrom set +b *!*@41.251.43.76
16:29:54 --- kick: FxMasta was kicked by monochrom (FxMasta)
16:34:54 <tazjin> So I accidentally filled my entire RAM with the "‡≤†_‡≤†" string and crashed my computer. Learning Haskell is fun! :D
16:35:41 <tikhonjelvis> I see you were able to write a useful program immediately :)
16:36:07 <Pseudonym> You shouldn't be able to crash your computer with Haskell.
16:36:14 <Pseudonym> Everyone knows that.
16:36:51 <amiller> if your memory makes faces like that for too long, it can get stuck that way
16:37:40 --- mode: monochrom set -b *!*@41.251.43.76
16:37:45 --- mode: monochrom set -o monochrom
16:37:59 <tazjin> amiller: If that happens, will my computer forever disapprove of my code? D:
16:42:09 <irene-knapp> tazjin: in Dwarf Fortress, I once constructed a pump such that it flooded its own control room.  my dwarves could not swim down to reach the switch and shut it off.  the entire map flooded with water, everything died, and I discovered that the DF's water sim bogs down in a situation like that.
16:42:19 <irene-knapp> tazjin: just remember, "Losing is fun!"
16:43:11 <shachaf> In Dwarf Fortress, I once turned off Dwarf Fortress because it looked boring.
16:43:16 <irene-knapp> cute =p
16:43:30 <shachaf> I'm told that I was lucky.
16:43:32 <irene-knapp> haha
16:43:33 <irene-knapp> yes
16:44:14 <tazjin> Okay, so I call it the GHCI Of Disapproval: http://klaud.tazj.in/DGJE
16:44:23 <irene-knapp> haha nice haha
16:45:16 <Cody_> Can't find a tutorial that visually describes each pass of a function, am I doing it right? http://hpaste.org/56360
16:46:05 <Axman6> Cody_: pass? eh?
16:46:30 <Axman6> Cody_: one sec, i'll annotate it
16:46:41 <Cody_> Axman6: Term I learned while learning Java, don't know if its the correct technical term.
16:47:04 <LoliShana> Cody_: Second example is what happens, I think.
16:48:25 <shachaf> Cody_: That's not how map works.
16:48:36 <shachaf> The list [2,2,3,4,5] never exists.
16:48:47 <shachaf> Nor does the list [2]
16:49:07 <shachaf> What *does* exist, however, is the thunk x : y
16:49:15 <hpaste_> Axman6 annotated ‚ÄúMap‚Äù with ‚ÄúMap (annotation)‚Äù at http://hpaste.org/56360#a56361
16:49:21 <Axman6> Cody_: ^^
16:49:23 <shachaf> Where if you examine x, it turns out to be 2, and if you examine y, it turns out to be [2,3,4,5].
16:49:33 <shachaf> I mean y turns out to be [3,4,5,6]
16:49:38 <shachaf> This distinction is important.
16:50:08 <Cody_> Ah, I see
16:50:18 <Cody_> Thanks Axman6
16:51:18 <Axman6> Cody_: the code i pasted just uses the definition of map directly. at each stop, it looks at the second argument and checks to see if it's [] or (x:xs). the lines 9-14 all use rule 2, the last line uses rule 1
16:51:34 <Axman6> > map f [1,2,3] :: [Expr]
16:51:35 <Cody_> Axman6: Now I understand what they mean by lazy evaluation, because it doesn't evaluate till the last line.
16:51:35 <lambdabot>   [f 1,f 2,f 3]
16:51:51 <Cody_> Or when it needs to
16:51:52 <shachaf> Cody_: "it doesn't evaluate till the last line"?
16:51:52 <monochrom> Cody_: firstly, what they say. secondly, see my http://www.vex.net/~trebla/haskell/lazy.xhtml . I don't exactly have a map example there, because nothing happens to map f xs unless a larger context drives evaluation, at which point the example will become too large
16:52:12 <monochrom> however, I do have fold examples
16:52:47 <Axman6> Cody_: eh? lazy evaluation means that the stuff that's not needed doesn't get evaluated, and things don';t get evaluated until they're needed. this lets us do things like map (+1) [1..], which would be an infinitely long computation, but we can use as much of it as we want without needing infinite computation time
16:54:10 <Axman6> Cody_: if you have head (map (+1) [1,2,3,4,5]), then head will look at the expression and see that it can't tell if it's [] or (x:xs) yet, so it will try to evaluate it until it can tell. this means that only line 10 needs to happen, and the rest fo the computation (map (+1) (2:3:4:5:[])) doesn't get evaluated
16:54:41 * Axman6 -> lunch
16:54:43 <Cody_> Ah, I see
16:54:55 <Cody_> lunch, little late for that.
16:54:58 <shachaf> Axman6: Forcing (head ...) will force both the spine of the list and its first element.
16:55:04 <shachaf> @localtime Axman6
16:55:06 <lambdabot> Local time for Axman6 is Thu Jan 12 12:39:08 2012
16:55:12 <shachaf> Seems right to me.
16:55:21 <Axman6> i'm 10 minutes late!
16:55:22 <Cody_> @localtime Cody_
16:55:23 <lambdabot> Local time for Cody_ is Wed Jan 11 19:36:56 2012
16:55:27 * Axman6 hungry
16:55:40 <monochrom> it is never late for lunch. or dinner. or breakfast. or 2nd breakfast. or the elevensies.
16:56:02 <shachaf> The elevensies are the most important meals of the day.
16:56:04 <shachaf> Both of them.
16:56:12 <monochrom> hehehe
16:56:16 <Axman6> followed by their dessert
17:01:11 <ergot_> this bug is driving me nuts :(
17:03:12 <DanBurton> ergot_: something we can help with?
17:03:56 <ergot_> I hope so
17:04:17 <darrint> I'm working inside (ResourceT IO a). If I say liftIO $ threadDelay x in the middle of that  function, does that effectively delay the computation? (I'm running over a rate limit.)
17:04:22 <ergot_> Im making a little crawler, and testing it with google goes wel until this happens:
17:04:30 <ergot_> crawling http://www.google.com.ar/a/help/intl/es/users/user_features.html  test: getRequest: Not a valid URL - http://www.google.com.ar/a/help/intl/es/users/user_features.html
17:04:55 <ergot_> the getRequest is throwing the erro becasue parseURI is failing to parse that link
17:04:56 <parcs`> darrint: yeah
17:05:17 <ergot_> if I copy the link by hand and test it it works
17:05:35 <ergot_> so, I guess the problem is due encoding issues
17:05:47 <ergot_> maybe I'm wrong, idk
17:06:27 <darrint> rats. I was hoping I was doing it wrong.
17:06:36 <DanBurton> ergot_: paste the relevant snippet to http://hpaste.org/new/haskell and maybe we can help figure out what's wrong
17:07:55 <ergot_> DanBurton: well the code is a little bit large, but basically I'm using: getResponseBody =<< simpleHTTP (getRequest x)
17:08:07 <ergot_> to download each page and extracting links with tagsoup
17:08:52 <ergot_> I tried using utf8Encode on the link string but same problem
17:09:18 <ergot_> I could paste all the code if you want but is ~100LOC
17:11:47 <DanBurton> go ahead and paste it all; no guarantees though :)
17:12:17 <ergot_> ok
17:15:02 <hpaste_> ergot pasted ‚Äúcrawler‚Äù at http://hpaste.org/56362
17:15:50 <ergot_> DanBurton there it is
17:17:22 <DanBurton> taking a look
17:18:45 <ergot_> sorry for the ugly codec:P
17:22:11 <DanBurton> ergot_: well here's the first thing I noticed...not sure how helpful it is
17:22:23 <DanBurton> I loaded the definition of openURL into ghci
17:22:43 <DanBurton> if I try `openURL google.com`, then it gives the "Not a valid URL - google.com" error
17:22:59 <DanBurton> but if I change it to `openURL http://google.com', then it actually gets something
17:23:14 <DanBurton> (with http:// prepended to the url)
17:23:20 <ergot_> well I'm prepending http:// to all links so that should work
17:23:44 <DanBurton> what kind of links does it say are not valid?
17:23:52 <ergot_> let me paste you where I'm getting the problem
17:23:59 <ergot_> just a second
17:24:01 <DanBurton> k
17:24:53 <LoliShana> > > 5 10
17:24:54 <lambdabot>   <no location info>: parse error on input `>'
17:25:23 <DanBurton> > (>) 5 10
17:25:25 <lambdabot>   False
17:29:38 <ergot_> DanBurton http://pastebin.com/0JK8HqR8
17:29:41 <mauke> The paste 0JK8HqR8 has been copied to http://hpaste.org/56363
17:30:28 <ergot_> at the end is the problem
17:31:03 <DanBurton> interesting
17:31:56 <DanBurton> does it always error on that precise link?
17:32:15 <ergot_> yes
17:33:26 <DanBurton> but when you use openURL manually, and copy/paste that link it works, right?
17:33:42 <ergot_> yes
17:34:16 <ergot_> that is why I was thinking in some encoding problem maybe
17:34:25 <DanBurton> indeed
17:35:42 <DanBurton> where does Text.Groom come from?
17:35:55 <monochrom> it's all ascii
17:36:12 <ergot_> it was just to pretry print thelist of crawled links at the end of the program
17:38:22 <DanBurton> Ah, excellent. I'm able to reproduce the exact same situation with the same code.
17:40:28 <irene-knapp> wooooo!
17:40:41 <irene-knapp> one-step building of .app bundles through my cabal-install fork
17:40:53 <irene-knapp> I still feel guilty about forking it :/
17:41:57 <Saizan> merge?
17:42:02 <monochrom> now we can enjoy cabal failures in more ways
17:42:15 <irene-knapp> I had to change way too many things - I have no plans to merge it back
17:42:32 <irene-knapp> I did change the name, for example, so that I can have "faction" installed in parallel to cabal
17:42:44 <DanBurton> ergot_: still working on figuring this out
17:42:53 <ergot_> monochrom it isn't any way to get any other character codes in the String that doesn't show printing it with putStrLn?
17:43:04 <Saizan> oh well, i had nothing to do with OSX anyway
17:43:24 <irene-knapp> but yeah, it's quite nice, it even builds .xib files for you
17:43:34 <irene-knapp> and copies resources where they go
17:44:40 <monochrom> you can use show or print
17:44:52 <DanBurton> ergot_: you can use print instead of putStrLn, I'm not exactly sure but I think that reveals hidden String stuff
17:44:54 <ergot_> monchrom good idea
17:45:06 <DanBurton> > print "Foo\n"
17:45:08 <lambdabot>   <IO ()>
17:45:15 <DanBurton> > show "Foo\n"
17:45:16 <lambdabot>   "\"Foo\\n\""
17:45:30 <ergot_> yeah lets test it with show
17:45:38 <monochrom> > show "G\246del"
17:45:39 <lambdabot>   "\"G\\246del\""
17:45:47 <DanBurton> Looks like lambdabot does some wonky stuff with show
17:46:38 <DanBurton> ergot_: it's as you suspected, though. I just ran a modified version of your code, which tests to see if the URL about to be crawled is equal to the problematic URL, as copy/pasted from the error message. It doesn't pass the test, so something about the string is different.
17:46:46 <dcoutts> irene-knapp: will you post anywhere explaining what your fork does?
17:47:15 * dcoutts has tried and failed at least twice to understand OSX app bundles
17:47:42 <monochrom> oh, don't worry, if you have putStrLn ( ... show mystring ... ) it's correct
17:48:24 <monochrom> whereas if you just have show mystring at the REPL prompt, it's strange because the REPL adds its own escaping
17:48:37 <DanBurton> there is a space at the end!
17:48:57 <DanBurton> or a something
17:49:01 <monochrom> oh, that does it
17:49:12 <irene-knapp> dcoutts: sure, I guess.  hi!  you're alive :)
17:49:20 <dcoutts> :-)
17:49:23 <monochrom> who put a space there?
17:49:49 <irene-knapp> dcoutts: it starts from the patches that I sent you and documented a year ago, and builds on them
17:49:55 <DanBurton> ergot_: you can see the space at the end, even in your error paste
17:50:07 <DanBurton> ergot_: where it says crawling: http://blahblah
17:50:34 <irene-knapp> dcoutts: I'll probably post to Google+ about it
17:50:59 <dcoutts> irene-knapp: great, Google+ posts are publicly available right?
17:51:00 <ergot_> DanBurton: oh it was just a little space?
17:51:00 <DanBurton> ergot_: so if you just trim your URL of trailing spaces, that should fix it.
17:51:07 <irene-knapp> dcoutts: they can be, and this one will be
17:51:08 <ergot_> funny
17:51:16 <ergot_> thanks a lot DanBurton
17:51:26 <dcoutts> irene-knapp: glad you've got something working
17:51:44 <monochrom> DanBurton: you get "\"Foo\\n\"" at ghci prompt too. it is not show being wrong. it is REPL adding its own show, you're looking at show (show s)
17:52:02 <irene-knapp> dcoutts: thank you.  it was a question of maintainability - it was too much work to keep it running outside the tree, I barely even remembered all the steps to clean it properly, and kept getting bitten by stale copies of things sneaking through.  let alone building it post-clean :)
17:52:09 <DanBurton> monochrom: ah that makes sense. sorry for doubting you, lambdabot ;)
17:52:26 <ergot_> crawling "http://www.google.com.ar/a/help/intl/es/users/user_features.html "
17:52:35 <ergot_> I should have used show in the beginning
17:52:37 <ergot_> hehe
17:52:43 <DanBurton> :)
17:52:50 <dcoutts> irene-knapp: ping me when you've posted it, I'll have another go at trying to understand :-)
17:52:54 <irene-knapp> dcoutts: okay :)
17:52:59 <monochrom> well, generally all REPL including lambdabot must be doubted. precisely for this reason.
17:55:17 <djanatyn> > getCurrentTime >>= print
17:55:18 <lambdabot>   Not in scope: `getCurrentTime'
17:56:00 <DanBurton> lambdabot doesn't perform IO actions
17:56:28 <djanatyn> oh, right.
17:56:50 <djanatyn> I was wondering, why can I do (getCurrenTime >>= print) but not do (getCurrentTime >>= show)?
17:57:36 <Jafet> getCurrentTime >>= show >>> return
17:57:37 <monochrom> because show is not a -> IO ()
17:58:05 <mike-burns> :t show
17:58:06 <lambdabot> forall a. (Show a) => a -> String
17:58:08 <mike-burns> :t print
17:58:09 <lambdabot> forall a. (Show a) => a -> IO ()
17:59:14 <DanBurton> :t getCurrentTime >>= return . show
17:59:15 <lambdabot> Not in scope: `getCurrentTime'
17:59:21 <DanBurton> blah
17:59:36 <mike-burns> :t return . show
17:59:37 <lambdabot> forall (m :: * -> *) a. (Monad m, Show a) => a -> m String
18:00:27 <djanatyn> I thought the binder just took a value's fanciness away and passed it was an argument to a regular function
18:00:41 <mike-burns> :t (>>=)
18:00:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:00:47 <mike-burns> The function must be (a -> m b)
18:00:52 <djanatyn> ohhhh. okay.
18:01:09 <mike-burns> (e.g. String -> IO Int)
18:01:21 <monochrom> you cannot escape the fanciness
18:01:43 <mike-burns> The value remains fancy.
18:02:24 <monochrom> monad is like getting bit by a vampire
18:03:17 <Jafet> Monastic vampires.
18:03:28 <mike-burns> There's a fail in there and you don't understand why?
18:03:29 * sipa gets out stake of unsafePerformIO
18:05:13 <djanatyn> I was thinking, there are no situations where you're required to use unsafePerformIO, right?
18:05:17 <djanatyn> even with really lowlevel stuff?
18:05:36 <mike-burns> You'll know it where you see it. And even then, double-check.
18:05:47 <djanatyn> I've never used it, and I don't really want to
18:09:44 <Cody_> Final question about basic recursions. Just want to solidify my knowledge. http://hpaste.org/56364
18:10:47 <mike-burns> Cody_: [1,2,3] is sugar for 1:2:3[] , not the other way around.
18:11:15 <Jafet> @where stepeval
18:11:15 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
18:11:17 <Cody_> I see, which example is technically correct?
18:11:45 <SiCKa> http://www.facebook.com/FinancialSTOCK like this page please
18:12:08 --- mode: ChanServ set +o monochrom
18:12:18 --- mode: monochrom set +b *!*@122-148-193-202.static.dsl.dodo.com.au
18:12:18 --- kick: SiCKa was kicked by monochrom (SiCKa)
18:12:43 <Jafet> But did you like the page?
18:13:12 <monochrom> did I like the page? answer: undefined
18:13:40 <monochrom> I keep it as an unevaluted thunk :)
18:16:20 <irene-knapp> dcoutts: https://plus.google.com/105523658172538902193/posts/aLX8GVjufnd (shouldn't require login to view)
18:16:30 <dcoutts> ta
18:16:45 <irene-knapp> np
18:20:10 * hackagebot haskell-src-meta 0.5.0.3 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.5.0.3 (BenMillwood)
18:25:45 <Cody_> Does anyone here prefer if/elses to guards? Wouldn't see a reason to
18:26:29 <shachaf> It's all context, man.
18:26:48 <shachaf> If you prefer guards to if/elses and they're equivalent in a particular context, feel free to use them.
18:27:26 <shachaf> Asking about people's preferences to this degree of specificity is unlikely to help you much.
18:28:27 <Cody_> I see. apologizes
18:30:55 <JoeyA> There's no way to simultaneously read from a handle and wait for an STM transaction to succeed, without spawning a separate thread.  Is this correct?
18:31:55 <cl1> chapter 5 in real world haskell is brutal. its all over the place
18:32:14 <JoeyA> Thus, to send data to a Handle while waiting for input on it, we need two threads.
18:32:40 <shachaf> JoeyA: Nothing wrong with using two threads.
18:33:01 <JoeyA> shachaf: Yes, but it makes error handling more tricky.
18:33:42 <dcoutts> irene-knapp: ah, a separate OSX app component
18:33:47 <JoeyA> If an error occurs during receiving, we have to kill the sending thread, and vice versa.  If it were all done in one thread (e.g. a thread serving a client), then if an exception arises, it only affects that one thread.
18:33:50 <irene-knapp> dcoutts: yes, indeed!
18:34:02 <JoeyA> And it doesn't leave dangling threads doing god-knows-what.
18:34:06 <irene-knapp> dcoutts: and .frameworks if I ever add support for them will be another one, but I don't need them right now
18:34:11 <shachaf> JoeyA: Well, you can use two threads to implement an interface that can be used from one thread.
18:34:43 <dcoutts> irene-knapp: perhaps that's a better approach, admit that it's not at all a portable executable and let it be different
18:35:22 <JoeyA> Is there a package that does this already?  I'm currently implementing such an interface (i.e. IO msg -> (STM msg -> IO a) -> IO a)
18:35:26 <irene-knapp> dcoutts: yes, when I revisited the problem this week that seemed obvious to me.  it avoids concerns like "what do these flags mean if we're not building an app", for example.
18:35:29 <dcoutts> irene-knapp: I've been thinking of adding new kinds of components for other things like "native" shared libs (ie not Haskell libs)
18:35:31 <JoeyA> Where IO msg is the receive action.
18:35:43 <irene-knapp> dcoutts: that seems reasonable to me
18:35:51 <JoeyA> and STM msg reads from an internal channel, or throws an exception if a read error occurred.
18:36:08 <JoeyA> Thus, it makes it possible for a single thread to read from a connection, and wait for messages from other threads.
18:36:43 <JoeyA> It's intended that the same thread also do the writing.
18:37:08 <dcoutts> irene-knapp: the "main() in C" would be useful to re-integrate, there's an existing ticket for it
18:37:13 <cmccann> JoeyA, obviously the correct solution is a third thread whose job is to kill any dangling threads
18:37:27 <JoeyA> How does it know what those threads are?
18:37:28 <irene-knapp> dcoutts: yes, I know.
18:37:40 <cmccann> JoeyA, I dunno, just wanted to suggest more threads
18:37:47 <JoeyA> heh
18:37:50 <dcoutts> irene-knapp: obj-c doesn't distinguish file extensions does it? it's just .c right?
18:37:53 <irene-knapp> dcoutts: I gave you that patch some time ago, although I forget now whether I attached it to the ticket or sent it to the mailing list.  feel free to use it.
18:37:57 <irene-knapp> dcoutts: no, it does, it's .m
18:38:03 <dcoutts> oh ok
18:38:09 <irene-knapp> dcoutts: I have a monoid of C dialects :)
18:38:25 <dcoutts> irene-knapp: oh I don't remember that, it must have been included in one of your bigger patchsets
18:38:25 <JoeyA> It's like saying, for C, making a separate thread that frees blocks that other functions forgot to free.
18:38:29 <JoeyA> Oh wait, we have that...
18:38:34 <irene-knapp> dcoutts: that's quite possible, yes, I don't really remember :)
18:39:41 <irene-knapp> dcoutts: the monoid of dialects is used to solve this problem:  you have a header file, which ends in .h and might contain C code, Objective-C code, C++ code, ? Objective-C++ is also a possible combination
18:39:54 <cmccann> JoeyA, just make a bunch of threads that create communication threads, and a bunch of other threads that kill every thread they find, and let natural selection sort it out
18:40:03 <JoeyA> lol
18:40:20 <dcoutts> irene-knapp: how does it solve that?
18:40:22 <irene-knapp> dcoutts: you would like to compile this header in isolation.   (for example, Cabal already attempts this, when it is trying to narrow down a missing foreign library problem)
18:40:23 <JoeyA> mapM_ (killThread . ThreadId) [1..]
18:40:36 <dcoutts> right, yes, ok
18:40:42 <irene-knapp> dcoutts: well, in conjunction with the information about which C-side files depend on which other ones...
18:40:59 <irene-knapp> dcoutts: hopefully the rest is obvious :)
18:41:20 <dcoutts> oh I see, frightening :-)
18:41:24 <irene-knapp> yes isn't it :)
18:41:33 <cl1> does haskell have a length limit on function names?
18:41:51 <dcoutts> I recall being frightened of your gcc C dep analysis stuff used in the configure tests
18:42:03 <irene-knapp> dcoutts: yes, I imagine so!
18:42:31 <irene-knapp> I forget what problem motivated that, but it definitely solved some real issue, I wasn't writing it for kicks :)
18:42:54 <irene-knapp> cl1: I suggest stopping at around 40 columns.  it gets annoying when you can't fit two of your function name on the same line :)
18:43:17 <irene-knapp> cl1: so the answer is no, no hard limit that I've ever hit
18:43:17 <dcoutts> irene-knapp: iirc, the problem was that cabal tries compiling all the .h files using gcc, but defaults to -x c equiv, which is no good if the .h file is for objc
18:43:25 <irene-knapp> dcoutts: ah, yes, indeed so!
18:43:43 <JoeyA> If you run into such a limit, consider switching to Java.
18:43:56 <JoeyA> ?bean
18:43:57 <lambdabot> Maybe you meant: brain keal learn read
18:44:08 <JoeyA> http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html
18:44:16 <irene-knapp> dcoutts: but that couldn't have been the sole reason, as it only tries doing that in the situation where it needs to narrow down a foreign-caused build failure
18:44:50 <irene-knapp> dcoutts: I am pretty sure there was some reason for the dependency analysis that was actually - oh!  I think I remember.  it was probably that I had mutual interdependencies of Haskell and C modules.
18:44:52 <cl1> lmao @ JoeyA
18:45:47 <dcoutts> irene-knapp: you mean .c/.h files that #include the generated stub.h files for Haskell FFI exports?
18:45:52 <mightybyte_> Do any of the main test packages have support for Cabal's test infrastructure?
18:46:09 <irene-knapp> dcoutts: yes, indeed so.
18:46:22 <dcoutts> mightybyte_: in a basic sense, yes
18:46:27 <dcoutts> irene-knapp: mm, that really is tricky
18:46:35 <irene-knapp> dcoutts: I remember doing some very careful ordering of the build steps to enable that, and it works for me now
18:47:18 <dcoutts> mightybyte_: since the basic interface for a cabal testsuite is just exitcode-stdio
18:47:37 <irene-knapp> dcoutts: the saving grace is that Haskell modules don't need to be compiled after C-side modules that they depend on.  so circular dependencies are fine; Haskell goes first.
18:47:38 <dcoutts> mightybyte_: if you mean the newer fancier interface, that's not complete yet
18:48:28 <mightybyte_> dcoutts: Yeah, I was specifically thinking about detailed-1.0
18:49:15 <dcoutts> mightybyte_: the expectation is that when the interface is finalised, that test-framework will be altered to support it
18:50:17 <dcoutts> irene-knapp: so you mean it's not needed for the build phase? just for checking if .h files are ok during configure?
18:50:56 <irene-knapp> dcoutts: I guess I have failed to elucidate a reason that it's needed for the build phase, but I'm actually pretty sure there is one, just that I have forgotten it!
18:51:14 <irene-knapp> dcoutts: I'd have to refamiliarize myself with that part of the source to say for sure
18:51:51 <dcoutts> irene-knapp: iirc, we were going to switch to building .c files after .hs for just this reason
18:52:01 <irene-knapp> dcoutts: hmm, I see.
18:52:17 <dcoutts> irene-knapp: oh, perhaps TemplateHaskell
18:52:25 <dcoutts> that lets you tie the knot
18:52:33 <dcoutts> since it has to load .c files :-)
18:52:39 <dcoutts> well, .o
18:52:42 <irene-knapp> dcoutts: oh, yes, the project I'm doing this all for does actually use TH.  that may have been the issue :)
18:52:57 <dcoutts> in that case, yes you'd need the full dep analysis, fun fun
18:53:01 <irene-knapp> yes, haha
18:57:01 <mightybyte_> dcoutts:  Ok.  Any ETA on the interface being finalized?
18:57:58 <dcoutts> mightybyte_: last discussion more or less concluded it's ok, so remaining work is adjusting the existing impl to fit the new interface
18:58:23 <mightybyte_> Ahh, cool.
18:58:41 <dcoutts> mightybyte_: you can ask ttuguel (sp?) if you're interested
18:58:58 <irene-knapp> dcoutts: anyway, so I'm going to sleep.  night!
18:59:17 <dcoutts> irene-knapp: g'night, thanks for the post, interesting
18:59:19 <mightybyte_> dcoutts: Ok, thanks.
18:59:22 <irene-knapp> np!
19:52:15 <randomclown> Noob here, how do I join two strings into a list?
19:52:30 <sshine> randomclown, what do you mean?
19:52:34 <randomclown> like
19:52:39 <randomclown> string1 : string2
19:52:39 <sshine> randomclown, "foo" ++ "bar"
19:52:46 <randomclown> no prepend?
19:52:53 <sshine> (++) is list concatenation, and strings are lists.
19:53:23 <rwbarton> perhaps you instead mean ["foo", "bar"]
19:53:26 <rwbarton> [string1, string2]
19:53:34 <sshine> that's a list of two strings.
19:53:50 <randomclown> how about a string to a list of strings?
19:54:05 <randomclown> just string : list isnt doing it
19:54:06 <sshine> randomclown, how do you want to transform the one string into a list of strings?
19:54:12 <randomclown> x is a string
19:54:16 <rwbarton> string1 : [string2, string3]
19:54:19 <randomclown> xs is a [string]
19:54:22 <sshine> > "foo" : []
19:54:24 <lambdabot>   ["foo"]
19:54:24 <rwbarton> You probably have some other error
19:54:48 <sshine> "foo" : "bar" : ["rest", "of", "list"]
19:55:29 <randomclown> right right
19:55:31 <randomclown> got it
19:55:34 <sshine> cool
20:02:18 <randomclown> how do I fix this function up?
20:02:19 <randomclown> http://hpaste.org/56366
20:02:55 <randomclown> I thought return would wrap it in a monad when it returns
20:03:35 <dmwit> needs more parens
20:03:39 <djanatyn> okay, having some difficulty with Either.
20:03:41 <dmwit> return (lines : contents)
20:04:06 <dmwit> djanatyn: Sock it to us.
20:04:15 <djanatyn> randomFunction :: a -> b
20:04:24 <dmwit> randomclown: ("return" is just a function like all the other functions, not a special keyword or anything like that)
20:04:30 <randomclown> ah thanks dmwit
20:04:34 <djanatyn> randomThing :: Either a somethingStupid
20:04:48 <djanatyn> I know that randomThing is of type a, I think.
20:04:55 <djanatyn> how do I get a passed to randomFunction?
20:05:07 <dmwit> either (Left . randomFunction) Right
20:05:25 <dmwit> case randomThing of Left a -> Left (randomFunction a); Right somethingStupid -> Right somethingStupid
20:05:39 <dmwit> Grab category-extras and use the other fmap.
20:05:48 <dmwit> Lots of ways. =)
20:05:55 <djanatyn> I like the first one
20:06:05 <djanatyn> I was messing with the either function earlier, but having difficulty with it
20:06:09 <rwbarton> pass it to (\(Left (randomFunction -> x)) -> x)
20:06:11 <djanatyn> didn't really understand it
20:06:17 <dmwit> rwbarton: =(
20:06:45 <dmwit> djanatyn: "either" is just a pattern match, but in function form. =)
20:06:48 <rwbarton> I usually assume anything after "category-extras" is fair game for non-serious suggestions.
20:07:06 <dmwit> case x of Left a -> f a; Right b -> g b === either f g x
20:07:26 <dmwit> heh
20:07:34 <dmwit> At least my joke suggestions were still total... =(
20:08:11 <rwbarton> "I know that randomThing is of type a, I think." is often a sign that you want a non-total function.
20:08:34 <dmwit> Ho, yes. When uncertain, partiality is key.
20:09:09 <dmwit> :t <|>
20:09:09 <lambdabot> parse error on input `<|>'
20:09:12 <dmwit> :t (<|>)
20:09:12 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
20:09:20 <dmwit> :t (+++)
20:09:21 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
20:09:43 <dmwit> randomFunction +++ id
20:09:46 <dmwit> :t (|||)
20:09:47 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
20:11:21 <dmwit> Ah, here we go, first :: PFunctor p r t => first :: r a b -> t (p a c) (p b c)
20:11:34 <dmwit> From the "categories" package.
20:17:18 <tempire> Is a Functor a type of monad?
20:17:39 <sshine> no, vice versa.
20:19:19 <tempire> hmm.  so a functor is a computational context‚Ä¶what more is a monad than a context for computation?
20:20:15 <sshine> http://stackoverflow.com/questions/44965/what-is-a-monad
20:20:48 <djanatyn> Is there any way that I can grab a value straight out of an Either?
20:20:55 <tikhonjelvis> Pattern matching
20:21:22 <djanatyn> could you give me an example? ._.
20:21:31 <djanatyn> i'm sorry, i'm not used to either at all, just maybe.
20:21:52 <tikhonjelvis> It's just like Maybe except instead of Nothing you have Left <something>
20:22:06 <cl1> or Right <something>
20:22:08 <djanatyn> ...ooh!
20:22:13 <tikhonjelvis> So case blarg of Left error -> bad; Right right -> good
20:22:33 <tikhonjelvis> I can never remember which is which though :(
20:22:38 <sshine> tikhonjelvis, for example. there are several functions that can be helpful: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
20:23:04 <sshine> tikhonjelvis, I think 'Right is the right one, so Left is the wrong one.'
20:23:17 <tikhonjelvis> Hey, that's clever. I never thought of that.
20:23:53 <cl1> they should have a MabyeError a b = Error a | Right b instead of just using Either
20:23:55 <tikhonjelvis> I always have problems with trivial pairs like that. Sometimes I can't even remember which way to open jars :(
20:24:04 <cl1> it more clearly states intent
20:24:14 <tikhonjelvis> Yes. But I guess Either doesn't *have* to indicate an error.
20:24:33 <tikhonjelvis> Although I can't think of any reasonable cases for it not to.
20:24:36 <cl1> tikhonjelvis, lefty loosy righty tighty (that's how i remember to open jars)
20:24:40 <sshine> tikhonjelvis, I only have problems with that when the jar is upside down, but that way I usually end up with bigger problems.
20:26:05 <cl1> oh and if you try to make an L with your thumb and forefinger on each hand, the one that makes the L correctly is your left hand .. and now back to your regularly scheduled #haskell chat
20:26:24 <sshine> cl1, I have "Lefty loosy, righty tighty, but upside down, I'll look like a clown with jam all over my trousers."
20:27:24 <cl1> sshine, just turn the jar instead of the lid and you will be okay
20:28:23 <cl1> this tutorial for making a JSON parser in real world haskell defines the (<>) operator that essentially does the same thing as (++) but for Doc items. would it be bad form to define the (++) operator instead of (<>)?
20:28:43 <dolio> Either can just be early exit.
20:29:02 <tikhonjelvis> Well, you wouldn't be able to use `++` normally then, would you?
20:29:04 <monochrom> you will have to first "import Prelude hiding((++))" first.
20:29:08 <dolio> Throw and catch.
20:29:52 <tikhonjelvis> I was making a little programming language for fun and use >< for concat, without having read that bit of RWH.
20:29:52 <monochrom> now, bad form - yes, it is bad to hijack a not-so-obscure operator
20:30:49 <tikhonjelvis> I think my name makes a little more sense--you're sticking two lists together, not prying them apart :)
20:31:50 <cl1> monochrom, i see what you mean. I forget that so many things are global in scope
20:31:52 <monochrom> the best name is ‚äï
20:32:09 <tikhonjelvis> Bit annoying to type usually, isn't it?
20:32:24 <cl1> i wouldn't even know how to type that
20:32:38 <tikhonjelvis> What's it's official name?
20:33:02 <sshine> tempire, I haven't found a really clear separation except that "functors represent computational contexts" and "monads represent computations"
20:33:08 <monochrom> I have set up my software environment to let me type \oplus (latex notation) for that. (scim)
20:33:34 <dolio> Functors are structure preserving mappings between categories.
20:33:34 <tikhonjelvis> Yeah, that would work: ‚äï.
20:33:46 <monochrom> official name is "U+2295 CIRCLED PLUS"
20:33:59 <dolio> Monads are endofunctors together with some natural transformations that satisfy certain rules.
20:34:14 <tikhonjelvis> I actually just wanted the LaTeX name.
20:34:37 <tikhonjelvis> I also set my editor (and IRC client :)) to use TeX character commands.
20:34:41 <cl1> dolio, i thought Monads were Monoids in the category of endfunctors
20:34:51 <cl1> \oplus
20:37:28 <monochrom> "computational contexts" is in the same genre as "warp core flux renoeburator" for me, i.e., Hollywood-grade entertainment
20:38:16 <pshrmn> Anyone know of a module specifically for 2D arrays that sort of acts like a matrix (i.e. each row has the same number of elements)? Basically to query cells.
20:38:37 <tikhonjelvis> I think repa is good for that sort of thing, but I'm not an expert.
20:38:56 <monochrom> "functor represents warp core flux renoeburator, monad represents space-time grid force field"
20:39:00 <pshrmn> thanks, just what I am looking for
20:39:48 <Axman6> there's also hmatrix
20:40:16 <Axman6> Repa isn't specifically for 2D arrays, but it is quite good at it (as well as other domensions)
20:40:30 <tempire> sshine: thanks, your input helps.  It's all coming together, one bit at a time
20:41:08 <tikhonjelvis> It's the library I used when I was playing around with some image processing stuff. I never got anywhere though.
20:48:28 --- mode: monochrom set -b *!*@122-148-193-202.static.dsl.dodo.com.au
20:48:32 <companion_cube> monochrom: wow, that's so much clearer now
20:48:33 --- mode: monochrom set -o monochrom
20:48:41 <monochrom> hahaha
20:48:41 <companion_cube> finally, the good monad analogy!
20:50:28 <sshine> companion_cube, I thought that was the one involving tacos.
20:50:49 <companion_cube> burritos* ?
20:50:52 <sshine> yes!
20:51:49 <companion_cube> I'd take a warp core flux renoeburator over a burrito any day.
20:52:26 <cl1> i'll bet a burrito will turn you into a warp core flux renoeburator
20:52:39 <cl1> well at least a bad overly spicey one
20:53:02 <djanatyn> fixed all my Either problems with a case statement and pattern matching :3
20:53:12 <djanatyn> I had to restructure my approach to the problem a little bit, but it turned out fine
20:53:25 <tikhonjelvis> You shouldn't need too many case statements.
20:53:31 <djanatyn> the way that I was working, I would have to have a case statement checking for errors many times.
20:54:06 <djanatyn> it turned out that I only needed to check once, and then bind a name for the non-error portion of maybe and move all the things that needed that value under that.
20:54:34 <djanatyn> and then I wrote some error handling code that I never really planned to write! since it was so easy, I thought I might as well write it anyway.
20:54:41 <djanatyn> not finished at all, but still useful as of right now.
20:54:49 <tikhonjelvis> sounds good
20:55:09 <djanatyn> yeah.
20:55:38 <djanatyn> writing actual code in haskell is really fun! learning the theory was fun too, but actually writing practical stuff is different.
20:55:57 <tikhonjelvis> That's true for every single language I ever learned. Except assembly.
20:56:12 <djanatyn> I'm really surprised, because I've been able to apply almost all of the knowledge I learned about haskell's type system immediately
20:56:29 <bmh> perhaps I'm misunderstanding something -- http://hpaste.org/56367 -- I would really like to make Terrain derive (Enum, Bounded), but can't derive them in this case. Why not?
20:56:32 <djanatyn> i thought that I would have to wait to use a lot of the stuff.
20:56:50 <djanatyn> although, I was kinda using applicative functors just for the hell of it so I stopped doing that ;)
20:57:16 <tikhonjelvis> I think a lot of people use applicative functors just because <$> is prettier than fmap.
20:57:35 <djanatyn> I didn't even really need to use fmap :)
20:57:43 <djanatyn> and removing it made my code cleaner and easier to read, anyway
20:58:26 <tikhonjelvis> bmh: what didn't work?
20:58:46 <tikhonjelvis> bmh: actually, I'll just run the code myself. One sec.
20:58:51 <bmh> tikhonjelvis: deriving bounded and enum fail: "(an enumeration consists of one or more nullary, non-GADT constructors)"
20:59:24 <tikhonjelvis> That probably means you can't have an argument to any constructors in an Enum instance.
21:00:23 <tikhonjelvis> bmh: Why did you want it to be an Enum instance?
21:00:49 <bmh> tikhonjelvis: serialization
21:01:10 <bmh> I know I could just read/show it...
21:01:46 <tikhonjelvis> Yeah, Enum is a special case where your type is just made up of its constructors and nothing else.
21:02:10 <tikhonjelvis> It's actually no dissimilar from Enums in languages like Java.
21:04:33 <ion> Are Doubles Enums in Java? :-P
21:04:38 <tikhonjelvis> Turning on spellcheck crashed my client :(
21:05:08 <tikhonjelvis> Probably not because Java is stupid. Or maybe I'm just biased.
21:05:20 <ion> No, Haskell is stupid with that regard.
21:05:30 <tikhonjelvis> Which regard?
21:05:39 <ion> > fromEnum (42.5 :: Double)
21:05:40 <lambdabot>   42
21:06:16 <sshine> :t fromEnum (42.5 :: Double)
21:06:17 <lambdabot> Int
21:06:22 <bmh> that's... unpleasant.
21:06:39 <tikhonjelvis> I don't like how it handles numbers in general.
21:06:42 <ion> > succ (42.5 :: Double)
21:06:43 <lambdabot>   43.5
21:06:59 <ion> > (toEnum . (+1) . fromEnum :: Double -> Double) 42.5
21:07:03 <lambdabot>   mueval-core: Time limit exceeded
21:07:07 <ion> > (toEnum . (+1) . fromEnum :: Double -> Double) 42.5
21:07:10 <lambdabot>   43.0
21:08:27 <augur> whats the benefit in the STG language of having lambdas only in lets?
21:08:45 <ion> It would be nice if lambdabot didn‚Äôt have an absolute time limit (or had a much longer one) but had a CPU time limit instead.
21:12:38 <JoeyA> augur: My guess (both at the answer, and at your question) is that let can be used to emulate lambdas; why have two representations of the same thing?
21:13:07 <augur> JoeyA: sure, but from what i can see, the STG language _has lambdas_
21:13:10 <augur> but only in lets
21:15:05 <JoeyA> What about letrec?
21:18:09 <augur> JoeyA: dunno!
21:18:19 <augur> i mean, its probably letrec right
21:18:22 <augur> like it is in haskell
21:38:41 <sshine> who was I just talking to?
21:40:22 <sshine> never mind.
21:48:49 <cl1> does quickcheck do code coverage analysis?
21:49:09 <cl1> or better yet, do any of the testing frameworks do code coverage analysis?
21:50:13 <bmh> speaking of quickcheck -- the `detailed` test suite type doesn't seem to work or I'm doing it wrong
21:50:34 <cl1> bmh, i'm a haskell newb, so I couldn't help you there
21:51:06 <bmh> cl1: thanks anyway :)
21:51:23 * cl1 just performed necromancy on a year old thread in haskell-cafe
21:56:32 <cl1> omg, there is not enough time in the day to both work and learn haskell :|
21:56:48 <tikhonjelvis> Pfft, sleep is for the weak.
21:58:49 <cl1> actually i get more done at work in the same amount of time when i'm rested. probably true of learning haskell, but breaking it up in to small enough chunks is difficult to do
22:00:17 <tikhonjelvis> My suggestion is to start some silly side project. It helps me retain stuff I've learned.
22:00:37 <tikhonjelvis> It also lets me be a lazy learner--I only learn something when I need it :)
22:01:18 <cl1> well i wrote a JSON parser this evening in about 200 lines of code
22:01:25 <tikhonjelvis> If you do something useful--like automating your system with Haskell instead of sh/perl--it's even better.
22:01:44 <cl1> thing is, the way it was taught I really needed to do the whole thing in one chunk for it to make sense
22:02:16 <cl1> and now its 45 past midnight, and I need to unwind before I can sleep
22:02:22 <tikhonjelvis> In my experience, the size of a Haskell program is very deceptive--I've had times when I *add* features to my program and it gets *shorter*.
22:02:25 <sshine> cl1, 200 lines of Haskell?
22:02:45 <cl1> sshine, about that, including spaces between the functions and all
22:03:07 <sshine> cl1, do you use parser combinators?
22:03:20 <cl1> sshine, havent' made it that far in the tutorial
22:03:27 <tikhonjelvis> If he's anything like I was when I was learning, he did a ton of stuff that's in the library himself.
22:03:34 <tikhonjelvis> Which is a good thing, I think.
22:04:12 <cl1> the coolest thing i learned this evening is that i can stub functions with undefined :D
22:05:18 <cl1> everything else seemed like putting to use everything i've learned thus far
22:10:09 <Mega> hey guys
22:11:47 <Mega> hi guys
22:11:53 <tikhonjelvis> hello
22:11:57 <Mega> welcome to my channel
22:12:08 <xintron> Morning
22:12:19 <Mega> whats going on guys?
22:12:30 <Mega> we just popped champagne
22:12:42 <cl1> Mega, what for?
22:12:57 <Mega> though she'
22:12:58 <Mega> dunno my mates girlfriend just popped it
22:13:09 <Mega> s not his 'girlfriend' officiallyh
22:13:13 <Mega> in fact she's his boss i think
22:14:38 <Mega> what, ask a question and no reply to my hard work of filling in the detail?
22:14:40 <Mega> how rude!
22:15:08 <Mega> so, how about mit romney
22:23:18 <The_Journey> hi, my program keeps segfaulting, is there anyway I can trace where it is happening?
22:23:42 <randomclown> valgrind?
22:24:17 <The_Journey> is there any debugger for Haskell? Like a gdb?
22:25:43 <c_wraith> you can run gdb on the binaries ghc produces
22:25:58 <c_wraith> usually, segfaults come from native libraries anyway
22:26:05 <c_wraith> so the backtrace is actually somewhat helpful
22:29:01 <kuznero> Good morning, All!
22:47:58 <The_Journey> how may I get a call stack when my program crashes?
22:48:09 <shachaf> You may not. Thanks for asking.
22:48:22 <shachaf> Haskell evaluation and call stacks don't go that well together. :-(
22:48:32 <The_Journey> then is there no way to debug a Haskell program?
22:48:44 <shachaf> There are ways of debugging Haskell programs.
22:48:47 <copumpkin> The_Journey: just don't put bugs in in the first place
22:48:57 <shachaf> Proper stack traces would be nice, but that's somewhat difficult.
22:49:06 <shachaf> copumpkin's solution is the best, naturally.
22:49:09 <ion> Doesn‚Äôt GHC have some recent code that presents a pseudo call stack of some kind in errors with some dark magic?
22:49:44 <shachaf> ion: I think JaffaCake implemented something like that, but said that it ended up not being that helpful.
22:49:46 <jaspervdj> ion: Simon Marlow was at least working on something
22:50:02 <The_Journey> problem is that my program gets segfaults half the time and the other half it works fine, I have no idea what's going on
22:50:08 <Enigmagic> i have limited stack traces working in gdb
22:50:19 <MarcWeber> Who is maintaining hackage right now? I'd like to add realtime JavaScript filter ..
22:50:36 <ion> It would be interesting to know how that‚Äôs done. I should get around to googling it.
22:51:01 <ion> Segfaults? Wow. Are you using FFI or a function named unsafeSomething?
22:51:44 <The_Journey> ion: no, I am not using those
22:52:53 <The_Journey> the only foreign function call that I can think of is because I am using the hmatrix package, which uses GSL, but that can't be the problem
22:53:01 <Enigmagic> The_Journey: hook up a regular debugger like gdb or windbg
22:53:55 <shachaf> Yes, if you're getting segmentation faults then even a regular debugger will probably be helpful to some degree.
22:54:01 <shachaf> Enigmagic: How do your limited stack traces work?
22:54:20 <Enigmagic> shachaf: assembly munging right now, trying to either find the time or the funding to do it for real :P
22:54:22 <Enigmagic> https://plus.google.com/118432899194915702514/posts/bPF9X3s3iM3
22:54:40 <The_Journey> but the binary GHC produces has nothing that I can use in gdb
22:54:50 <The_Journey> backtrace gives me ?? ()
22:54:54 <Enigmagic> The_Journey: what's on the top
22:55:10 <The_Journey> Enigmagic: #0  0x00000000006ce07c in saCy_info ()
22:55:15 <The_Journey> which means nothing to me
22:55:20 <Enigmagic> well, it's in haskell code at least..
22:55:33 <shachaf> The_Journey: You could look at the Core to see what saCy is.
22:56:16 <The_Journey> shachaf: look at the Core...?
22:56:44 <shachaf> Core is an intermediate language generated by GHC in the process of compiling Haskell.
22:56:48 <Enigmagic> The_Journey: here's a trick that works sometimes... run 'x/10000i $pc' and find the first named function
22:57:27 <Enigmagic> it's usually in the same module
22:58:37 <The_Journey> Enigmagic: I'm not really getting anything useful, no named function
22:59:04 <shachaf> Ooh, debugging Haskell through gdb through IRC.
22:59:25 <earthy> higher magic
22:59:57 <The_Journey> can't GHC produce a binary with some debugging info?
23:00:03 <Enigmagic> The_Journey: well, the other option is to relink with -debug and run 'call printObj($r14)' and some of the other commonly used registers to inspect the objects
23:00:29 <Enigmagic> or rebuild everything with -ddump-to-file -ddump-stg to get the core output
23:01:39 <Enigmagic> The_Journey: there is a branch that has it, yes
23:02:14 <Enigmagic> the supported compiler doesn't though
23:03:02 <The_Journey> Enigmagic: am I supposed to a file using those flags when I run the program?
23:03:49 <Enigmagic> The_Journey: nah, -debug is only needed during the link stage
23:04:48 <MarcWeber> dcoutts: do you know who is maintaining hackage currently? I'd like to add a javasript based filter hiding the packages whose names nor descrsiption matches a search text
23:06:14 <The_Journey> I don't understand why I am getting segfaults though, my program has no unsafe operations, and I read somewhere that it is supposedly hard to get segfaults in Haskell if I am not doing those unsafe operations?
23:07:24 <The_Journey> unsafe operations being IO etc...
23:08:01 <shachaf> The_Journey: It is indeed.
23:08:01 <Enigmagic> The_Journey: it's generally true. sometimes a library will have an unsafePerformIO hidden away somewhere though
23:09:46 <The_Journey> then can anyone recommend a linear algebra with function minization other than hmatrix?
23:09:53 <The_Journey> *library
23:09:57 <shachaf> Speaking of unsafe things, I like how you can do this: foreign export ccall foo :: Int -> IO Double; foreign import ccall "foo" bar :: Int -> Double
23:13:15 <Enigmagic> The_Journey: http://hackage.haskell.org/package/levmar might work
23:13:29 <Enigmagic> depending on what you're doing
23:14:22 <Enigmagic> hmatrix does use unsafePerformIO under the covers
23:16:10 <The_Journey> that's a shame
23:56:06 <vodik> if im getting an error "user error (mzero)" what should I be at to fix it?
23:56:23 <vodik> I've got a function getSubDirectories :: FilePath -> ListT IO FilePath
23:56:37 <vodik> however if it ends up building an empty list I get that error
23:59:34 <vodik> actually i just realized where I made a mistake in my logic
23:59:39 <vodik> sorry and thanks
