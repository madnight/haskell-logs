00:00:02 <The_Journey> how can I test whether if the user has a required non-Haskell library installed with cabal?
00:00:14 <tikhonjelvis> Hmm
00:00:25 <The_Journey> my program depends on liblbfgs
00:08:40 <jeltsch> xil, tikhonjelvis: There is now a new package for natural numbers that doesn’t use the (in my opinion, questionable) concept of an indeterminate natural.
00:08:52 <tikhonjelvis> That's good.
00:08:55 <jeltsch> It’s an improved version of what I posted on HPaste.
00:09:10 <xil> how does it compare to Int in terms of speed do you think?
00:10:30 <jeltsch> It uses Integer internally. Computations are just the computations on Integer, except where an underflow might occur. In this case, there is an additional check of whether the result is less than zero.
00:11:21 <tikhonjelvis> What did you call the package?
00:11:25 <jeltsch> This check is only done in negate, (-), and fromInteger.
00:11:29 <jeltsch> natural-numbers
00:12:02 <jeltsch> xil, tikhonjelvis: The package is here: http://hackage.haskell.org/package/natural-numbers
00:12:31 <tikhonjelvis> Cool, I'll play around with it later.
00:12:50 <tikhonjelvis> The stuff I'm playing with now (I must sound really unproductive :)) doesn't really need natural numbers.
00:13:29 <jeltsch> xil: So note that Natural uses Integer, not Int. So it can express arbitrarily big numbers, at a little expense of speed.
00:13:30 <xil> now when you post a package to hackage, does it appear on hoogle?
00:13:36 <xil> yeah I noticed that
00:13:42 <xil> and there is also an infinity right?
00:13:53 <tikhonjelvis> I think hoogle only searches through some really common packages.
00:13:55 <jeltsch> No infinity. Only naturals.
00:14:10 <jeltsch> For infinity, I would devise an extra type, based on Natural.
00:14:10 <tikhonjelvis> And since it's using Integers, it isn't even bounded, is it?
00:14:19 <jeltsch> It isn’t bounded, yes.
00:14:44 <xil> I thought the idea of an infinity was contained in the natural numbers. I mean it's not a number, but it's a good general way to define an upper bound
00:15:22 <jeltsch> xil: I notice that an unsigned version of Int would also be useful. Note that unsigned versions of Int16, etc. already exist: Word16, etc.
00:15:40 <jeltsch> xil: No, natural numbers are defined to not contain an infinity.
00:16:09 <tikhonjelvis> Hmm, I remember using some of the Word types, but I can't recall what for, exactly...
00:16:34 <jeltsch> xil, tikhonjelvis: Wait, I was mistaken.
00:16:38 <xil> jeltsch: what do you mean by "defined"? Because mathematically there is no infinity number, obviously, so whose definition are we talking about?
00:16:48 <tikhonjelvis> Oh yeah, it had to do with image processing.
00:16:52 <jeltsch> There is a type Word (without a bit size), which should be an unsigned version of Int.
00:17:02 <tikhonjelvis> Ah.
00:17:08 <xil> aha
00:17:15 <xil> I use Word all the time and didn't even think about that
00:17:18 <tikhonjelvis> Yeah, I feel I should have thought of that.
00:17:25 <xil> I use it for other things that use it
00:17:26 <jeltsch> xil: The common definition of natural numbers as used in math.
00:18:04 <xil> jeltsch: right, so the definitions of all number sets don't contain infinity, because it's not a number, but for the sake of programming I figured it would be helpful for all unbounded types to have an infinity
00:18:38 <jeltsch> xil: I think it depends on the context. Sometimes, an infinity is useful, sometimes it is unnecessary and possibly misleading.
00:19:35 <jeltsch> But you can derive types with infinity:
00:19:59 <tikhonjelvis> Hehe: infinity = infinity + 1
00:20:20 <jeltsch> data ClosedNatural = Finite Natural | Infinity
00:20:40 <jeltsch> data ClosedInteger = NegativeInfinity | Finite Integer | PositiveInfinity
00:21:06 <jeltsch> Then you should implement classes like Eq and Num for these types.
00:21:35 <jeltsch> However, this is a bit problematic, since things like ∞ - ∞ are not defined.
00:21:53 <tikhonjelvis> Well, just leave them undefined. It's like dividing by 0.
00:22:04 <jeltsch> tikhonjelvis: Maybe.
00:44:13 <jeltsch> tikhonjelvis: There is a new version of the natural-numbers package. See http://hackage.haskell.org/package/natural-numbers
00:44:19 <jeltsch> Version 0.0.1.0.
00:44:24 <jeltsch> Changes:
00:44:34 <jeltsch>     • Natural is an instance of Monoid now.
00:44:53 <tikhonjelvis> It's progress!
00:44:56 <jeltsch>     • Fixed some bugs and removed some unnecessary checks in the Enum instance.
00:46:38 <The_Journey> hi, I am testing my cabal install files. My program depends on hmatrix and I already installed on my system, but when I run runhaskell Setup configure, I get this Setup: At least the following dependencies are missing: hmatrix >=0.13.0.0 , even though I already installed hmatrix. Can anyone help me?
00:49:24 <mm_freak> The_Journey: not really helping understand the problem, but did you try using cabal-install?
00:50:35 <tigger> The_Journey: so when you do "import Data.Packed.Matrix" in ghci there is no error?
00:50:56 <The_Journey> tigger: yea, there's no error
00:51:45 <tigger> can you grep "ghc-pkg list" for hmatrix and see what version you have
00:52:23 <tigger> The_Journey: you prolly don't need grep, just look through it if its small enough
00:52:53 <The_Journey> tigger: 0.13.0.0, here is the part of my cabal files that state the dependencies: http://hpaste.org/56657
00:56:03 <The_Journey> tigger: strange, if I do "cabal install hmatrix ." it then proceeds to build my program correctly
00:56:48 <asda8> has someone here used Data.Reflection? I'm looking for some basic example code to get me started.
00:57:44 <tigger> The_Journey: i doubt, trying "ghc-pkg update hmatrix", hmm, or have you already done "ghc-pkg unregister hmatrix" followed by "ghc-pkg install hmatrix"?
00:59:17 <The_Journey> tigger: I think I'll just reinstall hmatrix and see what happens
01:01:40 <The_Journey> tigger: when I try to do "ghc-pkg update hmatrix", I get this: Reading package info from "hmatrix" ... ghc-pkg: hmatrix: openFile: does not exist (No such file or directory)
01:01:45 <para> hi everyone, I have a problem when trying to install happy:
01:01:58 <para> cannot satisfy -package Cabal-1.8.0.2:      Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a is unusable due to missing or recursive dependencies:       containers-0.3.0.0-4a33235de7e0cf50661efaa6fa22fd1d
01:02:21 <para> I have cabal v 1.8.0.2 and cabal0install 0.8.0
01:02:34 <para> any ideas on what's wrong and how to fix it?
01:03:18 <tigger> The_Journey: hmmm, not sure. Is this after you tried reinstalling like you suggested "ghc-pkg unregister hmatrix" followed by "cabal install hmatrix"
01:04:05 <The_Journey> tigger: yes
01:05:37 <The_Journey> I think I may have messed up the cabal stuff on my system, is there anyway to wipe it completely clean and reinstall the packages?
01:05:43 <tigger> The_Journey: does that also mean you can no longer do "import Data.Packed.Matrix" in ghci?
01:06:41 <The_Journey> tigger: import Data.Packed.Matrix in ghci still works for some reason
01:09:29 <Enigmagic> my guess is: you installed hmatrix with --global once
01:09:49 <tigger> The_Journey: are u running linux or windows
01:09:55 <The_Journey> tigger: linux
01:10:03 <Enigmagic> try running 'ghc-pkg --global unregister hmatrix'
01:10:25 <The_Journey> Enigmagic: ok, I did that
01:10:33 <Enigmagic> did it fail?
01:10:36 <The_Journey> Enigmagic: no
01:11:04 <Enigmagic> ok... now does it fail to load in ghci? make sure you restart ghci too so it reloads the package cache
01:11:22 <The_Journey> Enigmagic: ok, so now it fails in ghci
01:11:48 <para> hey guys... anyone seen my question?
01:11:49 <The_Journey> so what should I do?
01:12:26 <Enigmagic> well if you want to nuke all the packages and start over... if you've installed a lot of things with --global you might just nuke your ghc install and start over :|
01:12:47 <Enigmagic> it's safe to just nuke the ~/.ghc and ~/.cabal directories though if you just want to clean out your user packages
01:13:07 <jeltsch> tikhonjelvis: Yet another update of the natural-numbers package!
01:13:11 <jeltsch> Fixed a bug in pred.
01:13:25 <tigger> The_Journey: can u try "cabal install hmatrix" again?
01:14:33 <tigger> The_Journey: the docs http://www.haskell.org/cabal/FAQ.html#runghc-setup-complains-of-missing-packages, say "The default for runghc Setup.hs configure is --global, but the default for cabal configure is --user."
01:16:03 <The_Journey> tigger: ah, thank you very much
01:16:07 <tigger> The_Journey: so one method installs to the global package directory, and the other to user directory by default?
01:16:09 <The_Journey> tigger: passing in --user fixed it
01:16:32 <tigger> The_Journey: Yes, I think Enigmagic was right about removing the global package first
01:17:24 <The_Journey> is there a logical reason behind why cabal defaults to local while runhaskell Setup defaults to global?
01:23:40 <brisingr> any good haskell graph resources apart from The Monad Reader?
01:31:15 <brisingr> lambdabot:
01:31:19 <Sgeo> :t curry send
01:31:20 <lambdabot> Not in scope: `send'
01:31:23 <Sgeo> :t curry snd
01:31:24 <lambdabot> forall a b. a -> b -> b
01:31:32 <brisingr> sorry
01:31:36 <brisingr> an idiot next to me
01:31:42 <brisingr> took control of my keyboard
01:35:34 <frerich> One thing I like about Haskell, but maybe that's just because I'm not too proficient at it yet, is that it has a very low 'Wat?!' factor (see the four minute lightning talk at https://www.destroyallsoftware.com/talks/wat for examples of languages with a high Wat factor...).
01:41:12 <mm_freak> frerich:
01:41:16 <mm_freak> > let 2 + 2 = 5 in 2 + 2
01:41:17 <lambdabot>   5
01:41:24 <mm_freak> but that's about all you get in haskell =)
01:56:13 <The_Journey> how can I install a package with documentation with cabal?
01:59:37 <mm_freak> The_Journey: set "Documentation" to True in ~/.cabal/config
01:59:37 <donri>     --enable-documentation         Enable building of documentation
01:59:44 <mm_freak> or what donri said
02:00:15 <The_Journey> thank you
02:03:07 <mrg_> hello
02:08:46 <mrg_> i've a question regarding data-types: i want to specialize a char in different ways to distinguish between these data-types but i'm note sure whats the way to go
02:09:25 <magr_> mrg_: you know about newtype?
02:09:36 <mrg_> yes
02:09:46 <donri> are the two of you actually the same person?
02:10:24 <magr_> mrg_: then I don't understand the question
02:12:13 <mrg_> my problem is that i want to distinguish between the types: lets say i've A and B, later on i want to use them both in a list an distinguish which element is of type A and which is of type B
02:12:46 <donri> you can't have a list with different types
02:12:46 <mrg_> in oop i would use a abstract class C and let A and B derive from C
02:13:06 <donri> you can make them the same type and pattern match on the constructors
02:13:06 <mrg_> yes... thats my problem
02:14:21 <donri> data C a b = A a | B b  -- this is really the Either type
02:14:50 <mrg_> i already tried that way but i needed another data-type like data X = foo A [C]
02:15:05 <ivanm> > Right undefined > Left undefined
02:15:05 <lambdabot>   True
02:15:41 <donri> mrg_: if you must, there's Data.Dynamic, but it's quite possible that you only think you must
02:15:58 <donri> http://www.haskell.org/haskellwiki/FAQ#How_do_I_make_a_list_with_elements_of_different_types.3F
02:18:28 <mrg_> i think the best way would be if i can do something like data X = X (A y) [C]
02:18:49 <mrg_> am i right that this is not possible?
02:19:01 <donri> you need that y to be on the left side of the equal sign too
02:26:25 <mrg_> data C = A Char | B Char  data X = X C [C] works fine
02:26:39 <mrg_> but data C = A Char | B Char  data X x = X (A x) [C] doesn't
02:27:07 <donri> because "A" can only take a Char
02:27:16 <mrg_> ghci says "Not in scope: type constructor or class `A'"
02:27:30 <donri> and yes, A is a value constructor not a type
02:27:34 <donri> the type is C
02:28:06 <donri> data C x = A x | B x; data X x = X (C x) [C x]
02:28:23 <mrg_> but that was the problem
02:28:39 <mrg_> i dont want to allow B _ for the first parameter
02:29:33 <mrg_> is tehre any solution?
02:30:33 <shachaf> mrg_: Why not just use "x"?
02:31:04 <shachaf> Keep in mind that data C x = A x | B x is isomorphic to data C x = C x Bool
02:31:12 <mrg_> ive to change location... will be back soon
02:31:21 <shachaf> But here you only want cases where that Bool is False, so why have the Bool at all?
02:31:25 * shachaf sighs.
02:32:23 <jkff> Hi. Is it possible to do allocation profiling of a haskell program - see break down of *allocated* (but perhaps not retained) memory by type?
02:33:00 <jkff> i.e. my program seems to allocate many short-lived objects, and I'd like to know what kind of objects are these.
02:33:54 <Enigmagic> jkff: build with -rtsopts and run with +RTS -hT -RTS
02:34:06 <jkff> Enigmagic: thanks!
02:34:19 <Enigmagic> then inspect the <program>.hp, probably with hp2ps or hp2pretty
02:34:27 <jkff> invalid heap profile option: -hT
02:34:32 <frerich> mm_freak: Well to be fair, you could construct more confusing things than 'let 2 + 2 = 5'. For instance, you could have an operator which communicats some sort of expectation (like, (+) being commutative) but then violate that expectation (writing a (+) which is not commutative).
02:34:47 <frerich> mm_freak: However, this shouldn't eb built into the language (as is the case with JavaScript)
02:34:52 <Enigmagic> jkff: or use -hy if you compiled with -prof
02:35:16 <jkff> Enigmagic: but -hy gives me a breakdown of the program's working set, not of the short-lived objects
02:35:50 <Enigmagic> jkff: so you just want to find allocated objects that are collected during gen0?
02:36:03 <jkff> Enigmagic: yes
02:36:45 <Enigmagic> hmm
02:38:40 <mrg_> re
02:38:43 <Enigmagic> jkff: i don't know if there is a way to see precisely that
02:39:02 <jkff> Enigmagic: thanks, I'll ask cafe then
02:39:24 <mrg_> someone asked why i don't just use x... thats because i want to distinguish...
02:40:34 <mrg_> i thought about defining a typeclass to "simulate" the way of defining c as an abstract class and let A and B derive this class
02:40:38 <shachaf> mrg_: Distinguish what?
02:40:58 <shachaf> No typeclasses are necessary. Also, it sounds like you're confused about what typeclasses are.
02:41:04 <shachaf> 14:19 < shachaf> Keep in mind that data C x = A x | B x is isomorphic to data C x = C x Bool
02:41:07 <shachaf> 14:19 < shachaf> But here you only want cases where that Bool is False, so why have the Bool at all?
02:42:22 <mrg_> what i really want is the type X as data X x = X (A x) [C x]
02:42:39 <shachaf> That can't be what you really want, because (A x) isn't a type.
02:42:58 <mrg_> ok let me explain it in an OOP-way
02:43:23 <shachaf> Must you explain it in an OOP-way?
02:43:26 <donri> perhaps you want dependent types :)
02:43:41 <shachaf> What mrg_ wants seems to have little to do with dependent types.
02:44:42 <mrg_> i want to have C als abstract class and let A and B derive from C... now i have some kind of structure containing one parameter/field/whatever of type A and one list of type C so i can use A as well as B inside the list
02:45:30 <shachaf> Explaining things "in an OOP-way" isn't going to help us. You're probably better off forgetting what an "abstract class" is completely than trying to express things in terms of it.
02:46:25 <mm_freak> mrg_: try explaining the application on a higher level, not as a programmer
02:47:13 <mm_freak> haskell beginners often ask questions like "how do i change the value of a variable?", for which you won't get useful answers
02:47:38 <mm_freak> in your case it's "how do i do <insert OOP stuff here>?"
02:48:24 <ivanm> mm_freak: rather than "what is the Haskelly way of solving this problem, which I would do as <blah> in OOP?" ?
02:48:34 <shachaf> mm_freak++ # good explanation
02:48:48 <mm_freak> ivanm: no, that's still programmer level =)
02:49:17 <ivanm> mm_freak: well, "this problem" as in "I want a program that does <blah>"
02:49:39 <mm_freak> ivanm: rather "i want a program, for which <blah> is a solution"
02:49:44 <mm_freak> could help, but often it doesn't
02:49:44 <ivanm> OK
02:50:01 <mrg_> ok... i want to discribe rules of a context free grammar... i've terminal symbols and nonterminal sysmbols... my rule is contains one nonterminal symbol on the left side an a combination of nonterminal an d terminal symbols on the right side
02:50:32 <mm_freak> mrg_: now we're getting somewhere…  what exactly do you want to have in the end?  a parser?
02:51:01 <mrg_> i want to calculate some things like first an follow sets
02:51:06 <ivanm> I realise I've come in late to this... but why would you want this? is there an actual use-case? homework? a sample programming problem for practice?
02:51:45 <mrg_> you could say homework :P
02:52:14 <mrg_> i could say terminals are lower-case and nonterminals are upercase
02:52:21 <mrg_> but i dont like that approach
02:52:26 <ivanm> well, if it's homework (as in assessable), you should say so upfront
02:52:33 <drdo> Is there some option to make GHC stop bugging me about ambiguous type variables when i'm just ignoring the value?
02:52:37 <ivanm> so we know not to give you *everything*
02:52:54 <ivanm> drdo: in do blocks?
02:53:13 <mrg_> i tried to ask as precisely as i could :P
02:54:53 <mm_freak> mrg_: so you want to analyze the grammer itself?
02:55:12 <mrg_> yes
02:55:15 <mm_freak> drdo: doubt it, because it would change the language
02:55:28 <mm_freak> drdo: if anything, it would be a language extension, but i doubt you'll find one
02:56:05 <drdo> ivanm: I'm just ignoring a polymorphic return value (FromJSON)
02:56:19 <ivanm> drdo: fmap () ?
02:56:23 <ivanm> wait
02:56:25 <ivanm> @hoogle void
02:56:25 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
02:56:25 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
02:56:25 <lambdabot> package void
02:56:31 <ivanm> ^^ second one
02:56:46 <ivanm> drdo: but if you mean GHC complaining about do-block statements, there's a flag you can use
02:57:22 <drdo> I don't think it has nothing to do with do
02:57:45 <dmwit> data Grammar n t = Grammar n (Map n [Either n t])
02:58:00 <ivanm> drdo: well, you can probably use void then
02:58:00 <dmwit> where "n" is short for "nonterminal" and "t" for "terminal"
02:58:03 <drdo> I't just something like this: foo ∷ FromJSON a ⇒ a
02:58:06 <drdo> foo >> return ()
02:58:15 <dmwit> mrg_: Any objections to a type like that?
02:58:19 <drdo> well, foo ∷ Monad m, FromJSON a ⇒ m a
02:58:25 <ivanm> drdo: that type sig is wrong if you're doing "return ()" ;-)
02:58:37 <dmwit> mrg_: Of course, if you just want to write an efficient parser, you shouldn't do a side-trip through a representation like that.
02:58:45 <dmwit> mrg_: Just write the parser straight away instead.
02:58:50 <ivanm> drdo: specifically, the a bit
02:58:55 <ivanm> but I think you want to use void
02:58:56 <ivanm> @src void
02:58:57 <lambdabot> Source not found. Wrong!  You cheating scum!
02:59:02 <ivanm> IIRC, void = fmap (const ())
02:59:06 <mm_freak> drdo: i think the compiler shouldn't complain for fully polymorphic type variables, but it has to complain for polymorphic type variables with constraints
02:59:45 <drdo> mm_freak: I kinda of understand that it makes sense to complain since the compiler would otherwise have to pick a type itself
03:00:14 <mm_freak> drdo: not only that, but even when you don't expect it, the choice of the type may change the semantics of your program
03:00:22 <mm_freak> and i think in all other cases, the compiler won't complain
03:00:26 <mm_freak> > print (const 3 undefined)
03:00:26 <mm_freak> 3
03:00:27 <lambdabot>   <IO ()>
03:00:32 <mrg_> dmwit: that looks like the way to go
03:00:37 <mrg_> thanks!
03:00:49 <mm_freak> drdo: in fact it doesn't
03:01:20 <mm_freak> it only complains, when there is a constraint
03:02:28 <mm_freak> … and no defaulting
03:02:49 <mm_freak> > print (const 3 (undefined :: (Monoid a) => a))
03:02:50 <lambdabot>   Ambiguous type variable `a' in the constraint:
03:02:50 <lambdabot>    `Data.Monoid.Monoid a'
03:02:50 <lambdabot>   ...
03:04:09 <drdo> ScopedTypeVariables makes it not so bad
03:04:35 <mm_freak> huh?  usually it makes things better =)
03:04:41 <mm_freak> x :: Int <- …
03:05:05 <drdo> mm_freak: not so bad == better
03:05:20 <mm_freak> oh, overread the "not"
03:20:19 <mm_freak> btw grammars…  how do you prove that your grammar is context-free?  in other words, what features does your parser have to have?  being only Applicative apparently isn't sufficient
03:22:00 <mm_freak> or maybe i misunderstood?  IIRC applicative parsers can parse context-sensitive grammars, but they need to be infinite to do that, so i suspect recursion is the keyword here
03:22:35 <ezyang> mm_freak: "write down all of the production rules, and see if they have the right form"
03:22:36 <drdo> context-free afaik means the left sides only have non-terminal symbols
03:23:16 <mm_freak> ezyang: and for someone with no experience in formal grammars? =)
03:23:38 <ezyang> "Yeah, I dunno"
03:24:47 <mm_freak> is parsing of all context-sensitive grammars undecidable?
03:26:43 <drdo> mm_freak: Don't think so
03:27:37 <dever> are there any tools for doing nice graphs of haskell programs, like graphical profiling?
03:27:40 <ion> Huh. The documentation says there’s a Show UTCTime instance, but one doesn’t seem to actually exist. http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#v:UTCTime
03:27:43 <dmwit> mm_freak: Definitely not.
03:28:03 <dmwit> mm_freak: a^n b^n c^n is context sensitive, yet is a snap to parse.
03:28:04 <drdo> ion: There definetly is one, i used it recently
03:28:09 <dmwit> "parse"
03:29:04 <donri> >>> getCurrentTime
03:29:04 <ezyang> I assume mm_freak is universally quantifying the statement
03:29:06 <donri> 2012-01-19 12:16:52.934462 UTC
03:29:25 <mm_freak> ezyang: i wasn't, so dmwit's answer was useful
03:29:43 <ezyang> But it's still always possible to build a recognizer for any given context sensitive grammar
03:29:47 <dmwit> One proves that a language is context-sensitive by applying the pumping lemma for CFGs.
03:29:56 <ezyang> It is, however, undecidable to decide if a context sensitive grammar is empty :-)
03:30:04 <dmwit> If you have a grammar (in the EBF sense) then it's definitely context-free.
03:30:08 <dmwit> No proof needed.
03:30:18 <ion> I fail to see one in the source and GHC says “No instance for (Show UTCTime)”, too. http://hackage.haskell.org/packages/archive/time/latest/doc/html/src/Data-Time-Clock-UTC.html
03:30:19 <dmwit> (The definition of context-free is that it admits a grammar...)
03:30:39 <ion> I guess i’ll try updating GHC et al.
03:30:52 <dmwit> ezyang: Um, what? Not all languages are decidable.
03:31:16 <dmwit> What does "context sensitive grammar" mean?
03:31:17 <ezyang> dmwit: Uh, I was just talking about context sensitive grammars.
03:31:19 <donri> instance Show UTCTime
03:31:21 <donri>   -- Defined in time-1.2.0.3:Data.Time.LocalTime.LocalTime
03:31:37 <ezyang> So language is the set of all strings recognized by a context sensitive grammar...
03:31:48 <dmwit> What is a context sensitive grammar?
03:32:14 <donri> a non-CFG
03:32:32 <ezyang> Same as context-free grammar, but relax the requirement for the left-hand side to contain only one nonterminal
03:32:41 <dmwit> aha
03:33:46 <dmwit> Okay, yes, it seems feasible that parsing any given grammar is decidable.
03:33:55 <ion> Duh. One gets the UTCTime type by importing Data.Time.Clock, but one needs to import Data.Time to get the Show instance, too.
03:33:57 * dmwit runs off
03:34:11 <ion> drdo, donri: Thanks. :-)
03:34:26 <donri> Data.Time gets you .Clock too
03:34:29 <ion> yes
03:45:51 <donri> scary: changed a String to Text and everything still compiles
03:47:11 <merijn> donri: By scary you mean "awesome", right? :>
03:48:14 <donri> i mean scary as in doesn't feel like the code is type-safe (but i guess it really is, just knee-jerk reaction)
03:48:49 <donri> it works because overloadedstrings and only using literals yet
03:58:10 <paulotruta> hey ppl ;)
03:59:27 <paulotruta> i have a function that gives me this [[1,1],[1,1],[1],[2],[3,3],[3],[4],[5],[6],[7,7],[7,7]] and i want to have this [[1,1,1,1,1],[2],[3,3,3],[4],[5],[6],[7,7,7,7]]
03:59:40 <paulotruta> i'm all around trying everything but i cant do it right
03:59:49 <paulotruta> can you guys give me a hand? :) tkx
04:00:04 <DarkUnicorn> is it homework? ;)
04:00:23 <mauke> :t group . concat
04:00:24 <lambdabot> forall a. (Eq a) => [[a]] -> [[a]]
04:00:32 <paulotruta> nop, it is part of a little project i'm doing for school
04:00:40 <paulotruta> not homework tough
04:02:23 <paulotruta> thanks mauke ! I did not knew what functions i needed to compose to do that, so i was trying to do it by hand :)
04:02:25 <paulotruta> thanks a lot
04:02:29 <paulotruta> that saved me a lot of time
04:12:58 <tazjin> Is there a function that takes an a of some data type defined in record syntax, a field name and a value and returns a copy with only the appropriate field changed to the value?
04:13:53 <Botje> not that I know of
04:14:15 <Botje> the field name comes as a string I guess?
04:14:36 <tazjin> Yeah, that's what I was thinking
04:15:26 <Botje> i don't think something like that exists, no
04:15:43 <mm_freak> tazjin: you probably want lenses
04:15:50 <mm_freak> tazjin: see the data-lens package
04:16:03 <mm_freak> it doesn't take a field name as a string, but as a lens
04:16:21 <tazjin> Ahh, okay, that looks good. Thanks :]
04:16:37 <mm_freak> and it works for non-records, too…  you can have a lens for a specific key in a map, etc.
04:16:40 <mm_freak> quite great
04:18:05 <mm_freak> for record types you probably also want the data-lens-template package…  it autogenerates the lenses for your record types
04:19:30 <donri> tazjin: i too recommend data-lens, but it can be done with record syntax: a { override = value }
04:19:55 <tazjin> donri: I'm going to look into both, thanks again ;-)
04:19:59 <judas> hi, why does "> tail.tail [1..6]" not work?
04:20:33 <DarkUnicorn> :t tail
04:20:34 <lambdabot> forall a. [a] -> [a]
04:20:55 <judas> it works if i write "> (.) tail tail [1..6]" but i don't understand why
04:21:06 <mm_freak> tazjin: if you just want a syntax to update a certain record field, donri's solution might be enough
04:21:24 <mm_freak> judas: put spaces around the '.'
04:21:42 <mm_freak> judas: otherwise it is parsed as module.symbol
04:21:55 <mm_freak> > Control.Monad.replicateM 3 "01"
04:21:56 <lambdabot>   ["000","001","010","011","100","101","110","111"]
04:21:59 <judas>  "tail . tail [1..6]" does not work either
04:22:05 <mm_freak> ah, a $ is missing
04:22:10 <mm_freak> > tail . tail $ [1..6]
04:22:12 <lambdabot>   [3,4,5,6]
04:22:24 <mm_freak> otherwise it's parsed as "tail . (tail [1..16])"
04:22:27 <mm_freak> which is a type error
04:22:49 <mm_freak> my version is parsed as "(tail . tail) [1..6]", which is what you want actually
04:23:23 <judas> i don't really understand that type error
04:23:51 <Botje> tail . tail [1..6] === \x -> tail (tail [1..6] x)
04:24:04 <Botje> so that tries to give two arguments to the inner tail
04:24:05 <judas> ic
04:24:15 <judas> thanks a lot
04:25:13 <ketil> Any idea what this means?  Configuring glib-0.12.0...
04:25:13 <ketil> setup: The pkg-config package glib-2.0 is required but it could not be found.
04:25:42 <ketil> pkg-config is one of those programs which provides no useful output regardless of parameters.
04:25:45 <Botje> it means you need to install the -dev version of glib first
04:26:39 <Botje> on debian it's called libglib2.0-dev
04:26:52 <mm_freak> ketil: % pkg-config --list-all | grep glib
04:27:59 <ketil> Ah, thanks, Botje.  Apparently the name of the library is called libglib2.0-dev.
04:28:26 <ketil> Does diagrams handle infinite diagrams?
04:28:45 <ketil> I want to draw a grid as a background, or something like that.
05:17:27 <Gothmog_> @pl \xs x -> xs ++ [x]
05:17:27 <lambdabot> (. return) . (++)
05:17:48 <Gothmog_> :t (. return) . (++)
05:17:49 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid (m a)) => m a -> a -> m a
05:17:57 <Gothmog_> :t (. (:[])) . (++)
05:17:58 <lambdabot> forall a. [a] -> a -> [a]
05:27:31 <ion> Pro tip: don’t use (. (:[])) . (++)
05:29:11 <parcs`> :t reverse .: flip (:) . reverse
05:29:12 <lambdabot> forall a. [a] -> a -> [a]
05:36:11 <danr> ion: I prefer pure to (:[])
06:24:42 <dgpratt> given "{n² | 0 < n < 10 ∧ n ≡ 1 (mod 2)}", what is a Haskell expression that is equivalent (no pun intended) to the "n ≡ 1 (mod 2)" bit?
06:25:06 <Veinor> odd n
06:25:07 <Botje> n `mod` 2 == 1
06:25:08 <Veinor> > odd 8
06:25:09 <lambdabot>   False
06:25:11 <Botje> or that :)
06:25:29 <Veinor> @src odd
06:25:29 <lambdabot> odd = not . even
06:25:31 <Veinor> :D
06:26:01 <dgpratt> ok, thanks all
06:28:46 <dgpratt> I really don't get why the math expression is arranged that way; the Haskell version makes a lot more sense :)
06:29:53 <Veinor> > map (^2) . filter (\x -> x > 0 && x < 10 && odd x) [0..]
06:29:53 <lambdabot>   No instance for (GHC.Real.Integral [a])
06:29:53 <lambdabot>    arising from a use of `e_120100'...
06:29:58 <Veinor> bah
06:30:03 <Veinor> > map (^2) . filter (\x -> x > 0 && x < 10 && odd x) $ [0..]
06:30:07 <lambdabot>   mueval-core: Time limit exceeded
06:30:17 <Veinor> > take 10 . map (^2) . filter (\x -> x > 0 && x < 10 && odd x) $ [0..]
06:30:21 <lambdabot>   mueval-core: Time limit exceeded
06:30:34 <Veinor> ... oh right
06:30:38 <Veinor> > take 5 . map (^2) . filter (\x -> x > 0 && x < 10 && odd x) $ [0..]
06:30:39 <lambdabot>   [1,9,25,49,81]
06:31:00 <Veinor> you can't take 10 because there are only 5 elements that pass the filter
06:33:13 <elliott> > take 5 . take 10 . map (^2) . filter (\x -> x > 0 && x < 10 && odd x) $ [0..]
06:33:13 <elliott> wtf lambdabot
06:33:14 <lambdabot>   [1,9,25,49,81]
06:33:55 <Veinor> lambdabot FR: filtering infinite lists in finite time
06:35:13 <elliott> I'm sure Caleskell can do that
06:35:58 <elliott> > take 5 . take 10 . ((^2) .) . filter (\x -> x > 0 x x x x && x < 10 x && odd x) $ [0..]
06:36:00 <lambdabot>   [1,9,25,49,81]
06:36:11 <elliott> hmm...
06:36:16 <elliott> > take 5 . take 10 . (^2) .: filter (\x -> x > 0 x x x x && x < 10 x && odd x) $ [0..]
06:36:17 <lambdabot>   [1,9,25,49,81]
06:36:25 <Veinor> haha
06:36:44 <Veinor> actually
06:37:10 <elliott> > take 5 . take 10 . (^2) . filter (\x -> x > 0 x x x x && x < 10 x && odd x) $ [0..] -- believe it or not, lambdabot actually lacks some Num instaces
06:37:11 <lambdabot>   No instance for (GHC.Num.Num [a])
06:37:11 <lambdabot>    arising from a use of `e_151020100' at...
06:37:15 <elliott> *instances
06:37:35 <Veinor> i think for this particular situation you might be able to do use seemingly impossible functional programs
06:39:18 <elliott> Veinor: that just offers a search, not a filter, no?
06:39:34 <elliott> you'd need to do an infinite number of searches :P
06:39:41 <elliott> well hmm
06:39:45 <Veinor> here's what you do
06:39:48 <elliott> ah, you could write a filter that gives up once it's impossible
06:39:50 <Veinor> yeah
06:39:54 <elliott> _but_ it'd only work on [0..]
06:40:16 <elliott> > infinity
06:40:17 <lambdabot>   Not in scope: `infinity'
06:40:22 <elliott> > Data.Number.Natural.infinity
06:40:23 <lambdabot>   Not in scope: `Data.Number.Natural.infinity'
06:40:25 <elliott> huh
06:40:29 <Veinor> > 1 / 0
06:40:29 <lambdabot>   Infinity
06:41:17 <Veinor> ... actually, gmm
06:41:19 <Veinor> hmm
06:41:32 <elliott> it's just
06:41:45 <Veinor> you can't write 'this bit sequence represents a binary integer less than 10' as a total function
06:42:05 <elliott> foo p n | isNothing (search (\m -> m >= n && p m)) = [] | p n = n : foo p (n+1) | otherwise = foo p (n+1)
06:42:38 <Veinor> actually, you can if you write them bigendian, so nevermind
06:42:41 <elliott> Veinor: the typical impossible search procedure is for peano integers, no?
06:42:50 <elliott> er, naturals
06:42:53 <Veinor> and then specify that they all have to have a trailing 1 at the end
06:43:05 <Veinor> elliott: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
06:43:27 <nand`> If I want to make my type a member of Random; however this type has no reasonable concept of ranges - what's the appropriate method for implementing randomR? What I've done is randomR = const random to simply ignore the range parameter
06:43:34 <nand`> or should I = error?
06:43:39 <Veinor> nand`: what's your type?
06:43:51 <nand`> Veinor: data RPSChoice = Rock | Paper | Scissors
06:44:22 <elliott> Veinor: yes i know :)
06:44:41 <elliott> Veinor: but http://lukepalmer.wordpress.com/2010/11/17/searchable-data-types/
06:44:50 <elliott> it's easy to do (n < 10) on Nat
06:44:51 <Veinor> nand`: in my opinion i'd go with error, yeah
06:45:15 <Veinor> oh, i didn't know you can search the lazy naturals like that
06:45:33 <nand`> fair enough; I just want to avoid creating possible confusion when randomR does nothing special and a user is wondering why
06:45:42 <Veinor> exactly, that's why i'd error
06:46:10 <nand`> it still seems silly to put that into randomR; shouldn't it be a special typeclass or something like (Ord r, Random r) =>
06:46:17 <nand`> err
06:46:20 <nand`> to put randomR into RAndom
06:46:40 <elliott> Veinor: yeah, you just rely on p being total for the conats, so p (fix Succ) terminates
06:54:59 <gwern> > let avg x = sum x / length x in (avg [100,100,101,84,84,86,86,88,92,94], avg [100,83,88,90,90,93,95,98])
06:55:00 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
06:55:00 <lambdabot>    arising from a use o...
06:55:29 <gwern> > let avg x = sum x / fromIntegral (length x) in (avg [100,100,101,84,84,86,86,88,92,94], avg [100,83,88,90,90,93,95,98])
06:55:30 <lambdabot>   (91.5,92.125)
06:56:51 <elliott> We should just make an instance Fractional Int to stop people getting confused about that.
06:57:04 <ion> gwern: genericLength
06:57:15 <ion> elliott: Sounds like a plan.
06:57:23 <elliott> @src Fractional
06:57:24 <lambdabot> class  (Num a) => Fractional a  where
06:57:24 <lambdabot>     (/)             :: a -> a -> a
06:57:24 <lambdabot>     recip           :: a -> a
06:57:24 <lambdabot>     fromRational    :: Rational -> a
06:58:10 <elliott> (/) = div; recip = const 0; fromRational = blah blah round
06:58:11 <elliott> Done.
06:58:28 <ion> elliott: I’d prefer to use unsafeCoerce.
06:58:29 <Veinor> haha
06:58:44 <Veinor> :t genericLength
06:58:45 <lambdabot> forall b i. (Num i) => [b] -> i
07:00:16 <Veinor> why is length :: [a] -> Int, anyway?
07:00:32 <elliott> hysterical raisins
07:00:41 <elliott> also efficiency
07:00:49 <elliott> genericLength is a lazy foldr (obviously)
07:00:55 <elliott> and RULES pragmas didn't exist back then :P
07:01:11 <Veinor> can we pleeeease make genericLength the new length?
07:01:18 <ion> > let avg (Sum x, Sum n) = x/n; toAvg x = (Sum x, Sum 1) in avg . Data.Foldable.foldMap toAvg $ [10, 20, 30]
07:01:20 <lambdabot>   20.0
07:01:30 <donri> Veinor: -XNoImplicitPrelude
07:01:32 <krakrjak> :t genericLength
07:01:32 <lambdabot> forall b i. (Num i) => [b] -> i
07:01:53 <elliott> Veinor: I don't like the idea of relying on compiler optimisations to get code that doesn't leak massively.
07:02:18 <elliott> foldl' (\ (!n) _ -> n+1) 0 would be OK.
07:02:18 <donri> what are you doing with haskell then ^_^
07:02:26 <elliott> Erm... don't need that bang pattern.
07:02:43 <ion> > let avg (Sum x, Sum n) = x/n; toAvg x = (Sum x, Sum 1) in avg (Data.Foldable.foldMap toAvg [10, 20, 30] `mappend` Data.Foldable.foldMap toAvg [15, 25])
07:02:44 <lambdabot>   20.0
07:02:58 <Veinor> @pl \x y -> x + 1
07:02:58 <lambdabot> const . (1 +)
07:03:11 <Veinor> elliott: yeah, i'd be fine with it being strict
07:03:23 <Veinor> @just
07:03:23 <lambdabot> Maybe you meant: list quit
07:03:25 <Veinor> just
07:03:25 <elliott> ion: heh, cool
07:03:30 <elliott> @nothing
07:03:30 <lambdabot> Unknown command, try @list
07:04:14 <Veinor> i want list to have the type (Num a) => [t] -> a
07:05:25 <elliott> yeah, lists should definitely have that type
07:05:29 <elliott> [1,2,3] :: (Num a) => [t] -> a
07:06:12 <elliott> you give it a list; it calculates the length, takes that many elements from itself, and goedelises them
07:08:20 <Veinor> elliott: :|
07:08:28 <Veinor> : |
07:08:29 <Veinor> :  |
07:09:01 <roconnor> preflex: seen sjoerd_visscher
07:09:02 <preflex>  sjoerd_visscher was last seen on #haskell 40 days, 20 hours, 59 minutes and 29 seconds ago, saying: ByronJohnson: there seem to be lazy functions now
07:09:38 <elliott> Veinor: i agree, we should change the cons operator to :|
07:09:44 <elliott> and it should allow whitespace in the middle
07:09:50 <elliott> foldr (:   |) []
07:10:33 <Veinor> /kick elliott
07:12:15 <elliott> I won't tell you about my plan to rename all the Prelude functions after the names of US presidents rendered with Unicode Fraktur characters, then...
07:13:31 <ion> Are there ≤ 43 Prelude functions?
07:14:02 <Veinor>  You mean 44.
07:14:14 <yrlnry> No, because that counts Grover Cleveland twice.
07:14:36 <elliott> We can have two functions named after Grover Cleveland. I'm OK with that.
07:15:00 <elliott> 𝖌𝖗𝖔𝖛𝖊𝖗𝖈𝖑𝖊𝖛𝖊𝖑𝖆𝖓𝖉'
07:15:11 <Veinor> yrlnry: Obama is the 44th president
07:15:19 <yrlnry> Yes, because Grover Cleveland is counted twice.
07:15:36 <yrlnry> So among the 44 presidents, there are 43 distinct individuals with 43 distinct names.
07:15:37 <Veinor> cleveland and cleveland'
07:15:43 <ion> 𝖌𝖗𝖔𝖛𝖊𝖗𝖈𝖑𝖊𝖛𝖊𝖑𝖆𝖓𝖉 and 𝖌𝖗𝖔𝖛𝖊𝖗𝕰𝖑𝖊𝖛𝖊𝖑𝖆𝖓𝖉
07:15:52 <elliott> /kick Veinor not having the required fraktur font to see i already made that joke
07:15:55 <ion> whoops
07:15:59 <Veinor> :(
07:16:02 <elliott> /kick elliott not having the required fraktur font to see what ion did
07:16:03 <yrlnry> elliott++
07:16:05 <ion> 𝖌𝖗𝖔𝖛𝖊𝖗𝖈𝖑𝖊𝖛𝖊𝖑𝖆𝖓𝖉 and 𝖌𝖗𝖔𝖛𝖊𝖗𝕮𝖑𝖊𝖛𝖊𝖑𝖆𝖓𝖉
07:16:34 <cheater_> yrlnry: what ones?
07:16:43 <yrlnry> What ones what?
07:16:48 <elliott> Anyway, I daresay it'll take long enough to convince everyone that this is a good thing that we'll have quite enough Presidents when it comes to assigning the names.
07:17:04 <cheater_> yrlnry: why the discrepancy of 44 vs 43?
07:17:06 <yrlnry> It might be funnier if you renamed the prelude functions after vice-presidents instead.  Also, there are more of them.
07:17:27 <yrlnry> cheater:  Because Cleveland served two non-consecutive terms and so is counted as both 22d and 24th president.
07:18:09 <yrlnry> I now score a geek point for knowing the numbers 22 and 24 without having to look them up.
07:18:51 <cheater_> oh ok.
07:19:03 <elliott> I know the numbers 22 and 24, too.
07:19:16 <elliott> > [0..]
07:19:17 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
07:20:29 <yrlnry> Sure, but did you know the contents of the inverse image f¯¹(Cleveland) of the function f : [1..44] → {U.S. Presidents} ?
07:20:46 <ion> I know the integers 22 and 24, but i have no idea what goes between them.
07:20:50 <yrlnry> hee
07:20:52 <elliott> $ ghc -e ':browse' | wc -l
07:20:52 <elliott> 234
07:20:52 <elliott> Some of those are class/type definitions, but I think we're going to need more presidents.
07:21:22 <yrlnry> As far as I'm concerned we have had way too many presidents already.
07:21:41 <yrlnry> Double Clevelands is only the least of the problem.
07:21:51 <ion> elliott: If we shot a president monthly, we’d have > 230 presidents quite soon.
07:22:03 <elliott> ion: Excellent!
07:22:05 <elliott> I'll tell the Committee.
07:22:18 <danr> ouch, you'll be arrested for planning terrorism!
07:22:27 <elliott> "Planning"?
07:22:36 <danr> executing, then :P
07:22:38 <yrlnry> Conspiring.
07:22:54 <yrlnry> elliott:  maybe you should name them after popes instead.
07:23:10 <elliott> Well, you know, we could just shoot everyone else too. (This is referred to as "a C++".)
07:23:14 <clsmith> ddarius: thanks. i suppose what i was wondering is whether, if the type system *can* be turing complete (and hence undecidable) whether you could just run the function at runtime and if the dependent type fails to hold we get something similar to an assertion exception
07:23:24 <elliott> yrlnry: Perfect.
07:23:52 <elliott> OK, that's it, I'm writing the Popelude now.
07:24:14 <clsmith> at which point assertions become, basically, runtime-checked dependent types? i may be talking gibberish again now.
07:25:07 <danr> clsmith: isn't it the other way around: dependent types becomes assertions?
07:25:33 <danr> clsmith: *jumps in without knowing exactly what you and ddarius talked about before*
07:25:34 <clsmith> danr: well, a subset do, i suppose that makes more sense, yeah
07:26:15 <clsmith> but what i'm trying to work out is how we could then handle those runtime type errors such that we can still reason about our programs without all this silly exception business
07:26:27 <ion> elliott: Speaking of shooting presidents, ping echelon human to animal to human infection collapse outbreak illegal immigrants iraq centrifuge nuclear bomb concealed shipment president white house.
07:26:43 <clsmith> e.g., making checking that the dependent type holds a requirement explicit in the language
07:27:17 <roconnor> ion: is that your email sig?
07:27:19 <elliott> ion: Oh good.
07:27:31 <elliott> ChanServ is watching.
07:27:51 <roconnor> ion: nothing about Iran?
07:28:52 <clsmith> i suppose i just really like the idea that a program is a proof, the type for that program is the problem which it proves (or something like that)
07:30:17 * elliott wonders how to assign pope names to values.
07:31:03 <roconnor> using poperational semantics.
07:31:26 <elliott> :D
07:32:09 <ion> The Church and State monad
07:32:17 <Jaak> gives entireley new meaning to angelic semantics
07:32:19 <qpu> haha
07:32:45 <ion> Programming in the Holy C
07:33:00 <elliott> /ban *!*@*
07:33:45 <Sgeo> Which is easier for game programming, Netwire or reactive-banana?
07:34:48 <roconnor> @type shift
07:34:49 <lambdabot> forall a. (Bits a) => a -> Int -> a
07:34:59 <roconnor> @type Control.Monad.Cont.shift
07:35:00 <lambdabot> Not in scope: `Control.Monad.Cont.shift'
07:35:02 <ion> @type shit
07:35:03 <lambdabot> Not in scope: `shit'
07:35:26 <elliott> @hoogle shift
07:35:26 <lambdabot> Data.Bits shift :: Bits a => a -> Int -> a
07:35:27 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
07:35:27 <lambdabot> Data.Bits shiftR :: Bits a => a -> Int -> a
07:35:35 <elliott> roconnor: i don't think Control.Monad.Cont has that
07:35:39 <roconnor> oh
07:35:42 <roconnor> Oleg defined it in this file
07:37:55 <dolio> shift :: ((a -> r) -> r) -> Cont r a ; shift = cont
07:38:06 <roconnor> shift :: ((a -> r) -> Cont r r) -> Cont r a
07:38:18 <dolio> reset :: Cont r r -> r ; reset m = runCont m id
07:39:40 <dolio> My type gives you more information about what shift does.
07:39:55 <roconnor> My type is the type that Oleg uses in this file.
07:40:03 <roconnor> http://www.haskell.org/pipermail/haskell-cafe/2009-April/059069.html
07:41:48 <dolio> Note that it's not even more convenient for his use.
07:42:33 <dolio> oleg'shift (\k -> return $ Z a (k . maybe a id)) = dolio'shift (\k -> Z a (k . maybe a id))
07:42:54 <gwern> @oeis 2 11 13
07:43:10 <lambdabot> Plugin `oeis' failed with: thread killed
07:43:29 <gwern> @oeis 2 11 13
07:43:33 <lambdabot>  Last filtering prime for n-th prime p: find smallest prime factor of each of...
07:43:33 <lambdabot>  [2,2,3,2,3,2,3,5,2,5,3,2,3,7,5,2,5,3,2,7,3,5,7,3,2,3,2,3,11,3,7,2,11,2,5,7,3...
07:44:05 <gwern> that sounds pretty esoteric
07:44:19 <elliott> gwern: you might want commas
07:44:20 <elliott> @oeis 2, 11, 13
07:44:24 <lambdabot>  Last filtering prime for n-th prime p: find smallest prime factor of each of...
07:44:24 <lambdabot>  [2,2,3,2,3,2,3,5,2,5,3,2,3,7,5,2,5,3,2,7,3,5,7,3,2,3,2,3,11,3,7,2,11,2,5,7,3...
07:44:32 <elliott> oh, you got lucky
07:45:30 <gwern> hehe
07:46:00 <yrlnry> What is the argument format?  Why does "2, 11, 13" find that particular sequence?
07:46:09 <yrlnry> @oeis 2,3,5,8,13
07:46:14 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
07:46:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:46:17 <ion> @oeis 3,1,3,3,7
07:46:30 <danr> @oeis 3, 2, 1, 7, 4, 1
07:46:31 <lambdabot>  2^A000120(n)-1.
07:46:31 <lambdabot>  [0,1,1,3,1,3,3,7,1,3,3,7,3,7,7,15,1,3,3,7,3,7,7,15,3,7,7,15,7,15,15,31,1,3,3...
07:46:40 <lambdabot>  Mix digits of pi and e.
07:46:41 <lambdabot>  [3,2,1,7,4,1,1,8,5,2,9,8,2,1,6,8,5,2,3,8,5,4,8,5,9,9,7,0,9,4,3,5,2,2,3,3,8,5...
07:46:47 <danr> ^ my fav!
07:47:04 <yrlnry> That OEIS plugin should give the URL or at least the sequence ID number.  I thought I knew what 2,11,13 was returning but now I have no idea.
07:47:11 <elliott> <yrlnry> What is the argument format?  Why does "2, 11, 13" find that particular sequence?
07:47:16 <elliott> if you use commas it's adjacent numbers
07:47:21 <elliott> if you just use spaces then it just finds them in the sequence
07:47:43 <yrlnry> But  [2,2,3,2,3,2,3,5,2,5,3,2,3,7,5,2,5,3,2,7,3,5,7,3,2,3,2,3,11,3,7,2,11,2,5,7,3...  does not show a 13.
07:47:52 <hpc> yrlnry: it gets cut off
07:48:38 <Tinned_Tuna> \part
07:48:50 <yrlnry> "A052180		 Last filtering prime for n-th prime p: find smallest prime factor of each of the composite numbers between p and next prime; take maximal value."
07:52:41 <gwern> > 57.9 / 34.1
07:52:42 <lambdabot>   1.6979472140762462
08:00:17 <davv3_> heya. in a function there is an expression then separated with a ":" then another expression, what does that imply (do)?
08:00:40 <dolio> > 1 : [2,3,4]
08:00:41 <lambdabot>   [1,2,3,4]
08:00:54 <davv3_> appends?
08:00:57 <dolio> x : xs is a list with head x and tail xs.
08:01:15 <elliott> davv3_: not append, cons
08:01:22 <elliott> x:xs is xs but with x at the start
08:01:49 <davv3_> ok
08:12:30 <Duffman-> Hi guys, I'm trying to run a parser (written by using parsec) on a file. How can I do this exactly? I'm trying it like this
08:12:31 <Duffman-> parse iniParser "test" $ openFile "C:\\Users\\Simon\\Desktop\\test.txt" ReadMode
08:12:41 <Duffman-> but that gives me a handle, and my parser can't work with that
08:13:17 <silver> @hoogle readFile
08:13:17 <lambdabot> Prelude readFile :: FilePath -> IO String
08:13:18 <lambdabot> System.IO readFile :: FilePath -> IO String
08:13:18 <lambdabot> Data.ByteString.Lazy readFile :: FilePath -> IO ByteString
08:13:22 <silver> you need that
08:14:04 <Duffman-> ok thx
08:14:26 <russruss> Is there something State Monad-like thing that has an alternative instance that does attoparsec style backtracking for lists of non-text types?  I'm trying to "parse" some already tokenized data and I'm feeling like I'm reinventing the wheel
08:14:38 <russruss> I'm kind of a beginner so let me know if the question isn't well formed :-)
08:15:12 <silver> Data.Binary?
08:15:28 <russruss> oh I mean like, it's already tokenized completely so it's in haskell types
08:15:44 <elliott> russruss: I think Parsec 3 can work with non-string types.
08:15:52 <Saizan> russruss: parsec-3 ?
08:15:59 <elliott> But you'd need to use "try" explicitly for backtracking, of course.
08:16:15 <Duffman-> silver, is there some way to get the string-part out of the IO String in ghci, or should I just write a little function and get it out in a do-construct?
08:16:22 <Saizan> well, even parsec-2 if your tokens come in a list
08:16:35 <silver> you can use "<-" in ghci
08:16:43 <Duffman-> didn't know that :o
08:16:46 <silver> ghci session is like IO action
08:17:07 <Duffman-> thx :)
08:17:21 <Duffman-> testing away now ^^
08:17:25 <silver> :)
08:17:57 <elliott> Saizan: huh, i thought parsec 2 was String only
08:28:30 <nand`> How come Control.Monad.State doesn't expose the State data constructor? How am I supposed to box my own state-changing functions?
08:28:59 <elliott> nand`: state
08:29:01 <elliott> :t state
08:29:02 <lambdabot> forall s a. (s -> (a, s)) -> State s a
08:29:06 <elliott> nand`: it also exports StateT
08:29:08 <elliott> :t StateT
08:29:09 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
08:29:12 <elliott> the thing is that State is now StateT Identity
08:29:16 <elliott> so there /is/ no constructor to export
08:29:23 <nand`> elliott: oh okay
08:29:40 <aluink> what's the status of the hackage wiki...seems to be Trac wide
08:30:26 <elliott> "temporarily" down for like two weeks now
08:31:00 <aluink> does anyone know who's responsible for it?
08:32:51 <nand`> must be SOPA
08:33:28 <aluink> Haskell pirates, obviously
08:37:13 <byorgey> nand`: note that even without 'state' you could also use  do { s <- get; let (a,s') = f s; put s'; return a }  although that may not be as efficient
08:43:48 <nand`> first real haskell program: http://hpaste.org/56667  critique?
08:44:34 <cheater_> yes
08:44:38 <cheater_> use qualified imports
08:44:49 <cheater_> either import Foo (bar, baz)
08:44:50 <cheater_> or
08:45:11 <cheater_> a fully qualified import where you give the module you import a name
08:45:24 <Clint> and Enum
08:46:26 <Sgeo> Is that really recommended for all imports? I didn't think so
08:46:56 <hpaste_> anonymous annotated “Rock Paper Scissors” with “Rock Paper Scissors (annotation)” at http://hpaste.org/56667#a56668
08:46:57 <cheater_> it is by me.
08:47:12 <cheater_> and by the people who wrote the FAQ in the topic
08:47:14 <nand`> updated now, that better?
08:47:48 <cheater_> for the first one i'd just qualify it. as, say, R
08:48:08 <Sgeo> Hmm, I don't see an FAQ in the topic
08:50:00 <Sgeo> cheater_, link to FAQ?
08:50:18 <hpaste_> donri pasted “How do I get rid of PrintfArg here?” at http://hpaste.org/56669
08:50:39 <elliott> nand`:     foldl (>>=) (return s) (replicate c playRand)
08:50:39 <elliott> nand`: Does this work? replicateM_ c playRand >> return s
08:50:43 <cheater_> you're right! but i mean the one here: http://www.haskell.org/haskellwiki/FAQ
08:50:48 <cheater_> it used to be in the topic at least
08:51:11 <elliott> nand`: Other than that, it looks good to me; I would use "where" rather than "let...in" in your random definition.
08:51:37 <donri> ^^^ actually, how do I make it Num a => a -> Text?
08:51:53 <elliott> donri: You can't.
08:52:03 <elliott> donri: With Fractional you could use...
08:52:09 <elliott> Uh, whatever of the billion conversion functions there are.
08:52:11 <donri> how do you suggest I rewrite it?
08:52:14 <elliott> @google (Fractional a) => a -> Rational
08:52:15 <lambdabot> http://www.themathpage.com/alg/rational-exponents.htm
08:52:15 <lambdabot> Title: Rational exponents - A complete course in algebra
08:52:16 <elliott> @hoogle (Fractional a) => a -> Rational
08:52:16 <lambdabot> Prelude toRational :: Real a => a -> Rational
08:52:16 <lambdabot> Data.Time.LocalTime timeOfDayToDayFraction :: TimeOfDay -> Rational
08:52:16 <lambdabot> Data.Time.Clock getModJulianDate :: UniversalTime -> Rational
08:52:24 <cheater_> Sgeo: i like that FAQ, it's quite helpful
08:52:26 <elliott> You could have a Real constraint and use toRational to get something to pass to printf.
08:52:41 <Sgeo> cheater_, I don't see anything about always using qualified imports
08:52:51 <Sgeo> (or import lists)
08:52:53 <kqr> how come "half = (/ 2)" is a Double -> Double when (/ 2) is a (Fractional a) => a -> a?
08:52:55 <elliott> donri: I'm ... not sure why you're writing it like that, though; surely you should just do (px/total) and format that?
08:53:00 <elliott> kqr: monomorphism restriction
08:53:06 <Sgeo> cheater_, maybe quote it, so I can find it?
08:53:25 <nand`> elliott: I don't think that would work right; I'm updating the state n times with “playRand”, s is the initial state
08:53:43 <nand`> basically, I apply (>>= playRand) n times to the result of “return s”
08:53:44 <kqr> elliott, oh, thanks
08:53:51 <elliott> nand`: Oh, I see. Consider using foldr (>=>) return.
08:53:57 <elliott> Or, hmm.
08:53:59 <elliott> :t foldM
08:54:00 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:54:06 <elliott> Oh, that requires an input list.
08:54:14 <elliott> kqr: it sucks :)
08:54:30 <elliott> nand`: anyway, foldl (>>=) is bad because the binds will be left-heavy
08:54:30 <kqr> elliott, haha, i haven't encountered the problem with it yet, so i'll just nod and smile
08:54:34 <elliott> which is inefficient
08:54:36 <donri> elliott: it's for http://yuilibrary.com/yui/docs/cssfonts/cssfonts-size.html
08:54:38 <elliott> kqr: you just did :)
08:54:48 <nand`> elliott: I mean I could use foldr (=<<), no?
08:54:56 <elliott> nand`: that wouldn't help :)
08:55:11 <donri> elliott: with yui-cssfonts, 100% == 13px
08:55:20 <kqr> elliott, it's a rare case i'm working at, it being an introductory text to haskell
08:55:42 <elliott> donri: well, that's just a table of multiplications... :P
08:55:44 <donri> elliott: but i also suck at math; not sure how to best model that
08:55:57 <etpace> :t (>=>)
08:55:58 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:55:59 <donri> elliott: well, not *really*: they're not consistently rounded
08:56:07 <elliott> donri: percent = (px/13) * 100
08:56:09 <kqr> elliott, i'd like a simple 1-ary function without any currying which has basic types (no typeclasses) and does not perform anything complicated
08:56:10 <elliott> donri: well, fair enough
08:56:15 <kqr> elliott, turns out that was not as easy to find
08:56:16 <donri> so i thought, i hardcode the table and compute the rest
08:56:39 <elliott> kqr: reverse?
08:56:39 <elliott> id? const? :p
08:56:51 <cheater_> Sgeo: oh i don't know if it's in the FAQ itself, i just know the people who wrote it and what they said about the topic :p
08:56:56 <elliott> donri: anyway, I would just fix a
08:57:13 <kqr> elliott, no list operations, i'll think about the others
08:57:23 <donri> "(px/13) * 100" is what i have, i just need that as a Text with at most one decimal
08:57:24 <elliott> donri: to Int or Integer or whatever; I mean, you can't have fractional pixels.
08:57:29 <Sgeo> cheater_, so, your say-so. Got it.
08:57:55 <donri> elliott: in deed, Int is what I started out with but then I got all these type errors :)
08:58:07 <cheater_> Sgeo: *shrug*
08:58:14 <elliott> donri: Well, because you're dividing an Int.
08:58:41 <elliott> donri: fromIntegral px * (100/13) should do it.
09:00:29 <hpaste_> donri annotated “How do I get rid of PrintfArg here?” with “Type error using elliott's suggestion” at http://hpaste.org/56669#a56670
09:01:10 <hpaste_> elliott annotated “How do I get rid of PrintfArg here?” with “How do I get rid of PrintfArg here? (annotation)” at http://hpaste.org/56669#a56671
09:01:20 <elliott> actually
09:01:22 <elliott> s/Double/Rational/
09:01:27 <elliott> no reason not to :)
09:03:24 <russruss> nand`:  you probably want evalState instead of runState
09:03:39 <Sgeo> :t evalState
09:03:40 <lambdabot> forall s a. State s a -> s -> a
09:03:45 <nand`> oh good point
09:04:10 <donri> elliott: works (with Double or Float, not Rational: No instance for (PrintfArg (GHC.Real.Ratio Integer))) -- thanks a bunch!
09:04:59 <elliott> donri: oh... that sucks, maybe it works if you import Data.Ratio though :P
09:05:01 <elliott> but Double is fine
09:05:11 <donri> isn't Float sufficient?
09:05:23 <elliott> donri: sure, but why not use Double by default?
09:05:31 <elliott> only use Float when you have a specific reason to, really
09:05:31 <hpaste_> russruss annotated “Rock Paper Scissors” with “Rock Paper Scissors (annotation) (annotation)” at http://hpaste.org/56667#a56672
09:05:39 <russruss> also playrand can be written applicatively if you're into that although it's not much nicer
09:06:04 <elliott> play <$> state random <*> state random <*> pure s
09:06:10 <elliott> it's nicer if you don't split it up into a bunch of lines :P
09:06:26 <donri> alright, thanks :)
09:07:25 <dmos> Are there any type indexed containers available somewhere? I didn't find anything on hackage.
09:08:04 <hpaste_> elliott annotated “Rock Paper Scissors” with “Rock Paper Scissors -- how I'd write it” at http://hpaste.org/56667#a56673
09:08:14 <elliott> nand`: It's a tweak-your-code party! \o/
09:08:28 <elliott> dmos: depends what you're looking for
09:08:31 <elliott> dmos: fixed-length vectors?
09:08:47 <elliott> nand`: oh... I'd also do the eta-reduction it suggests :p
09:08:52 <nand`> I'll agree, the applicative form works better here
09:09:02 <hpaste_> elliott annotated “Rock Paper Scissors” with “Rock Paper Scissors -- how I'd write it (annotation)” at http://hpaste.org/56667#a56674
09:09:23 <dmos> I need to store state on a per type basis (phantom types). So something with a key value interface where the key is a type would be nice.
09:09:24 <elliott> that should also perform better thanks to the right-associative (>=>)s
09:09:32 <nyingen> question about arrays: if I have a list of complex numbers, how do I make a CArray out of them?
09:09:40 <hpaste_> cheater annotated “Rock Paper Scissors” with “Rock Paper Scissors (annotation) (annotation) (annotation)” at http://hpaste.org/56667#a56675
09:09:51 <nyingen> none of the functions in the CArray module seem to do this
09:10:24 <elliott> dmos: http://hackage.haskell.org/package/vault
09:10:39 <elliott> Might be what you're looking for.
09:11:55 <dmos> elliott: I saw vault actually before, the thing which didn't fit was that I would need to keep the Key around in separate state between invocations, and that's exactly what I'd like to get around.
09:12:26 <elliott> dmos: Well, there's no type that can just hold a specific piece of state indexed only by a type.
09:12:36 <elliott> I proved to myself it was impossible once, so you'll just have to believe me :P
09:12:54 <elliott> dmos: You need some kind of token. If it's Typeable, you could use a TypeRep.
09:13:39 <elliott> (The problem is basically that you'd need an unsafePerformIO'd IORef for each type, but if you use a typeclass it doesn't quite work.)
09:13:41 <dmos> elliott: :) well, TypeRep would work, because I can recreate that on each access, no?
09:13:53 <elliott> (with an "instance Foo a", because you just get one polymorphic IORef)
09:14:08 <elliott> dmos: Yes, but it requires your types to be Typeable (which vault was designed to avoid).
09:14:20 <elliott> dmos: You could also roll your own:
09:14:24 <elliott> class Keyable a where k :: Key a
09:14:31 <elliott> erm
09:14:33 <elliott> instance Keyable () where k = unsafePerformIO newKey
09:14:38 <elliott> etc., for every type you want
09:14:43 <dmos> elliott: Yes, I read the blog post about why it was desirable to be avoided.
09:14:45 <elliott> probably need noinline pragmas in there too...
09:14:58 <elliott> That's basically what Typeable is giving you there.
09:15:12 <hpaste_> nand annotated “Rock Paper Scissors” with “Rock Paper Scissors -- how I'd write it (annotation)” at http://hpaste.org/56667#a56676
09:15:26 <nand`> current version :)
09:15:37 <elliott> a type-indexed value that everyone's already written instances for :)
09:16:14 <elliott> nand`: looks good to me!
09:16:27 <elliott> nand`: you might also want to consider MonadRandom so you don't have to write the state monad RNG stuff yourself
09:16:31 <elliott> http://hackage.haskell.org/package/MonadRandom
09:16:34 <dmos> elliott: just checking my own thinking: If I'd use the tagged package to declare the instances on phantom types, that would allow me to get away without a performance penalty (of wrapping/unwrapping), and still allow fully typed access if I declare the Typeable instances, no?
09:17:07 <elliott> dmos: I'm not sure what you're proposing; what class definition would you use?
09:17:41 <Zoxc-> are typeclasses kinda like interfaces, except you can't keep references to instances?
09:18:15 <ion> If you made the score part of the state, you could use replicateM in the place of playNumRand.
09:18:40 <elliott> Yes, that would be a good idea.
09:19:27 <dmos> elliott: the idea (which I haven't tested yet), is to have use polymorphic functions with phantom types and therefore be able to access 'state' (in a map passed in or otherwise acquired), to be able to uniquely reference state for a particular combination of phantom types.
09:19:32 <nand`> I was contemplating that but I wanted to keep the random portions separate from the game portions
09:19:39 <dmos> elliott: does that description make sense?
09:19:44 <nand`> basically, the game portion will be re-used with user input instead of random
09:19:56 <nand`> or a mixture of both
09:20:05 <elliott> nand`: sounds like you want something like
09:20:12 <conal> do ghc and ghci understand unix-style shebang (#!) lines? when i try now, the answer seems to be no (error: invalid preprocessing directive #!), but i vaguely remember that they did a whiel back. and i see an old SO thread asking how the shebanging works (http://stackoverflow.com/questions/1122778/what-does-usr-bin-at-the-start-of-a-file-mean).
09:20:21 <elliott> MyInputMonadT (StateT Score ...)
09:20:22 <elliott> or whatever
09:20:26 <elliott> (maybe PromptT?)
09:21:02 <elliott> dmos: Well, just adding a phantom type won't change anything, because they're erased at runtime; it won't let you turn one definition into an arbitrary number of references.
09:21:13 <ion> Control.Monad.Trans.Burrito.BurritoT
09:21:15 <elliott> dmos: I really don't think I understand what you're doing, though.
09:21:39 <elliott> conal: That sounds like you have CPP on.
09:21:40 <nand`> elliott: I'll come around to fathoming it. Never worked with monad transformers before, this may be a good excuse
09:21:47 <elliott> conal: #! is invalid cpp, even if ghc/ghci understand it.
09:21:50 <dmos> elliott: so the type representation of Typeable isn't persisted for the phantom type but rather it's erased as well. That wouldn't work obviously.
09:22:10 <elliott> nand`: actually, it would be an excellent use-case for my generalised SupplyT that I never put on Hackage
09:22:27 <conal> elliott: ah! i bet you're right.
09:22:29 <conal> elliott: thx.
09:22:48 <elliott> conal: :)
09:22:56 <nand`> elliott: note that I could just as well use randomIO together with getChoice :: IO RPS for my specific use case
09:23:05 <nand`> and I wouldn't need the random state transformer
09:23:07 * conal reminds himself yet again to read error messages more carefully.
09:23:25 <elliott> nand`: Well, you'd need to include getChoice :: IO RPS in your state.
09:23:31 <elliott> nand`: Actually, something like
09:23:38 <elliott> nand`: ReaderT (IO RPS) (State Score) would work fine.
09:23:59 <elliott> getChoice = ask >>= liftIO
09:24:25 <nand`> I was thinking playRound :: Score -> IO Score with playRound something like play <$> getChoice <*> randomIO
09:25:09 <elliott> nand`: hmm... but what you're trying to do is receive a stream of RPSes from either the RNG or the user, right?
09:25:21 <elliott> in that case, you should abstract out receiving an RPS, which ReaderT (IO RPS) does
09:25:39 <elliott> or, ah
09:25:44 <elliott> nand`: you need _two_ IO RPSes
09:25:46 <elliott> one for each player
09:25:46 <nand`> elliott: not necessarily, I'm just trying to sequence a two-player game
09:25:58 <elliott> and you can fill in either getChoice or randomIO for either
09:26:00 <elliott> no?
09:26:02 <Sgeo> :t app
09:26:03 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
09:26:26 <nand`> eg. player 1 always picks from the console, player 2 is always random; the function I described earlier does this just via the IO monad
09:26:38 <nand`> actually let me go ahead and implement it
09:27:09 <Sgeo> app :: ArrowApply a => a (a b c, b) c ; app on -> should be app :: (b -> c, b) -> c ; app (func, arg) = func arg
09:27:21 <elliott> nand`: Yes, but I thought you wanted to abstract away from it so that you could choose either random or user choice without changing a lot of the code.
09:27:52 <Sgeo> Hmm, is there some other definition for that app that's more ... pointfree? Or app as a relabelling of some functions combined together?
09:28:04 <Sgeo> uncurry or curry ($)?
09:28:08 <elliott> Abstracting out the "get next move" action for each player, and filling them in when you run the whole thing, achieves that nicely.
09:28:08 <elliott> If you just want your program to handle player-1-from-console and player-2-random and never anything else, that would be fine.
09:28:09 <elliott> Sgeo: uncurry ($)
09:28:20 <elliott> Sgeo: or uncurry id
09:28:23 <elliott> :t uncurry i
09:28:24 <elliott> :t uncurry id
09:28:24 <lambdabot>     Couldn't match expected type `a -> b -> c'
09:28:24 <lambdabot>            against inferred type `Expr'
09:28:24 <lambdabot>     In the first argument of `uncurry', namely `i'
09:28:25 <lambdabot> forall b c. (b -> c, b) -> c
09:28:47 <Sgeo> :t uncurry ($)
09:28:48 <lambdabot> forall b b1. (b -> b1, b) -> b1
09:29:01 <Sgeo> Where did expr come from?
09:29:06 <nand`> elliott: well, how doesn't what I proposed match that criteria? play <$> getChoice <*> randomIO -- I can interchange these freely, make them both getChoice, or make them both randomIO
09:29:29 <elliott> nand`: Well, I'd use ReaderT (IO RPS, IO RPS)
09:29:38 <elliott> nand`: getLeftChoice = ask >>= liftIO . fst; getRightChoice = guess :)
09:29:50 <elliott> Then play <$> getLeftChoice <*> getRightChoice
09:30:16 <elliott> You can then (runReaderT playTheGame (randomIO, randomIO)), or the same with (askTheUserForAChoice, randomIO), etc.
09:30:20 <Sgeo> elliott, would you yell at me if I considered using Netwire instead of reactive-banana?
09:30:28 <prof7bit> I have an installation problem related to cabal and an *old* ubuntu install. I saw somewhere mentioned ghc-pkg and this is the output of ghc-pkg list http://pastebin.com/4vcXY2wK does this mean I have cabal already installed? what is the purpose of ghc-pkg and how does it relate to cabal?
09:30:30 <mauke> The paste 4vcXY2wK has been copied to http://hpaste.org/56677
09:30:52 <elliott> I yell at everyone non-discriminatorily!
09:31:06 <dcoutts> prof7bit: ghc-pkg is a lower level tool that manages the installed libraries that ghc knows about
09:31:17 <dcoutts> prof7bit: cabal talks to ghc-pkg to find out what's currently installed
09:31:43 <geekosaur> prof7bit, "cabal" actually stands for 2 things.  the cabal library is part of a base install; there is also the cabal-install package which installs a command line program named cabal (and which doesn't show up as installed anywhere)
09:32:25 <geekosaur> ...try "type cabal" at a terminal prompt to see if cabal-install is installed
09:32:36 <prof7bit> this seems to be the problem. I don't have a command line program cabal and also no ubuntu package to install it
09:33:08 <elliott> apt-cache search cabal-install should find it.
09:34:29 <geekosaur> if your ubuntu is old enough, you may need to dig up a PPA
09:34:31 <prof7bit> gives no results. its a really old installation: ubuntu hardy 8.10
09:35:17 <elliott> Oh.
09:35:23 <luite> prof7bit: if you have a working GHC install, you can run the bootstrap script from the source distribution
09:35:25 <elliott> You probably shouldn't even use the GHC that thing has.
09:35:52 <elliott> luite: Does latest cabal even work with (probably) ghc 6.8?
09:36:05 <dcoutts> should do
09:36:13 <dcoutts> but not many people test it :-)
09:36:29 <elliott> Better question:
09:36:31 <prof7bit> the concrete problem is i'm working through some tutorials and i need import Text.Regex (and also some other things) and it complains and i don't have any clue how to install the required dependencies.
09:36:35 <elliott> Does a single Hackage package even work with GHC 6.8? :p
09:36:45 <dcoutts> lots of old ones do :-)
09:36:49 <luite> elliott: oh I meant a recent ghc from some binary download
09:36:52 <elliott> prof7bit: With any luck, apt-cache search libghc | grep regex should find the regex package you need.
09:36:58 <elliott> luite: Ah.
09:37:14 <luite> I never use the ghc that comes with ubuntu :)
09:37:15 <elliott> prof7bit: But I would strongly suggest e.g. installing one of the Linux GHC binaries.
09:37:28 <elliott> prof7bit: Otherwise the will not be the last of your problems :P
09:37:30 <elliott> *this
09:37:43 <nand`> oh boy, found a bug in the RPS code :)
09:38:39 <hpaste_> nand annotated “Rock Paper Scissors” with “Rock Paper Scissors bug fix” at http://hpaste.org/56667#a56678
09:38:41 <prof7bit> at one point yesterday i downloaded some cabal source files with a bootstrap.sh script in it and it started compiling things but then stopped with an error because it could not find something (can'T remember what exactly)
09:39:13 <elliott> prof7bit: The best thing to do is probably to download a GHC binary, and bootstrap cabal with that. You can install it into your $HOME so it doesn't clutter the system.
09:40:09 <prof7bit> ok. now where do i het a ghc only binary? I only saw complete packages for recent os versions (debian, arch, etc)?
09:40:28 <prof7bit> s/het/get
09:41:29 <elliott> prof7bit: http://www.haskell.org/ghc/download_ghc_7_0_4#binaries
09:41:36 <prof7bit> the only thing i got more or less working so far was running a recen haskell-platform for windows throuh wine
09:41:40 <elliott> You probably want either Linux (x86) or Linux (x86_64).
09:41:45 <elliott> haha, ouch
09:42:02 <elliott> I'd suggest purging all remnants of your Ubuntu GHC, downloading a binary package, and installing that into /usr/local or $HOME
09:42:12 <elliott> then cabal shouldn't be too hard to get working
09:42:17 <elliott> cabal-install, rather
09:42:39 <mr_sleepy> elliott: haskell platform is really easy to install in openbsd snapshots. just 'pkg_add -i haskell-platform
09:43:20 <rostayob> is Reactive ever going to work with ghc 7?
09:44:03 <elliott> mr_sleepy: Okay... but prof7bit is using Ubuntu.
09:44:20 <elliott> Ancient Ubuntu ("apt-get install haskell-platform" works on recent ones).
09:44:43 <elliott> rostayob: I think reactive might be abandoned(?)
09:44:49 <elliott> you could ask conal
09:44:50 <prof7bit> I already see new problems on the horizon: "NOTE: If you have too old a version of libc, then you will get an error like "floating point exception" from the binaries in these bindists. You will need to either upgrade your libc (we're not sure what the minimum version required is), or use a binary package built for your distribution instead. "
09:45:12 <elliott> prof7bit: That notice has been there for years, I think.
09:45:16 <hpaste_> nand annotated “Rock Paper Scissors” with “Rock Paper Scissors with IO monad” at http://hpaste.org/56667#a56679
09:45:23 <elliott> It's probably talking about libc4 or something :P
09:45:33 <rostayob> elliott: so what general-purpose FRP library would you suggest?
09:45:54 <elliott> rostayob: I use reactive-banana. For AFRP, netwire is popular.
09:46:30 <rostayob> oh, i thought netwire was related to networking?
09:46:35 <prof7bit> ok, then I'm now going to download this archive and try to get it running. wish me luck ;-)
09:47:01 <elliott> rostayob: nope
09:47:08 <elliott> rostayob: It's arrowised FRP though, so very different in style to reactive
09:47:14 <rostayob> ah, cool. are there any docs for netwire?
09:47:14 <elliott> reactive-banana is more "traditional" (Event + Behavior)
09:47:32 <elliott> http://www.haskell.org/haskellwiki/Netwire (also http://www.haskell.org/haskellwiki/Reactive-banana)
09:47:48 <geekosaur> I think there was an early intent for netwire to be used for FRP-based http servers, but it's not specific to that
09:47:48 <rostayob> elliott: apart from the haddock API. I'm kind of new to FRP
09:48:18 <elliott> rostayob: That wasn't the haddock API.
09:48:27 <rostayob> oops, sorry...
09:48:31 * elliott would suggest reactive-banana, unless you're experienced with arrows... but I'm biased :)
09:49:38 <prof7bit> will the binaries in this archive just in place where they are or will i have to do some trickery with my path vriable and with ldconfig and friends?
09:49:56 <elliott> prof7bit: ./configure && sudo make install
09:50:01 <elliott> or ./configure --prefix=$HOME/ghc && make install
09:50:13 <prof7bit> i thought it was a binary?
09:50:28 <elliott> it is
09:50:32 <Sgeo> You can still configure and make install binaries
09:50:41 <Sgeo> Well
09:51:16 <prof7bit> still downloading.... will there be a readme.txt inside?
09:51:21 <cheater_> why would you ever use "make install"
09:51:26 <cheater_> use "checkinstall" instead
09:51:32 <cheater_> we're not in the 80s
09:52:06 <elliott> prof7bit: There's probably a README, but it also probably won't be useful to you.
09:57:52 <rostayob> elliott: thanks for the wiki links, i think that last time i checked there were no docs for netwire
09:58:39 <elliott> rostayob: np :)
10:00:25 <nand`> is there any way to simplify a >>= \b -> c b >> return b
10:00:51 <nyingen> hm, while trying to cabal install a package, the build fails with 'unrecognised flags: -rtsopts'
10:01:20 <elliott> @pl \b -> c b >> return b
10:01:21 <lambdabot> liftM2 (>>) c return
10:01:28 <c_wraith> nand`: there are ways to make it shorter, but not really *simpler*
10:01:32 <elliott> nand`: a >>= liftM2 (>>) c return... I wouldn't recommend it.
10:01:38 <elliott> well
10:01:40 <elliott> it's not that bad :P
10:01:51 <akosch> could I solve the configuration problem with MVars? I mean if I put my database connection into a top-level MVar at the start of my main function, I could access it with 'readMVar' from all the methods that need it. Is this a bad idea?
10:01:56 <nand`> currently using do notation which is arguably the most straightforward in this case I guess
10:02:19 <nand`> do b <- a; print b; return b;
10:02:27 <elliott> that's fine
10:02:37 <elliott> nand`: (; is a separator, not a terminator)
10:02:54 <c_wraith> akosch: usually, creating a top-level MVar is evidence of a problem.
10:03:13 <nand`> I thought you needed the separator after the last line in do notation when writing it within a single line
10:03:15 <nand`> or something like that
10:03:19 <elliott> i'm not sure akosch and c_wraith are using the same definition of top-level :)
10:03:24 <elliott> at least, unsafePerformIO'd ones aren't created at the start of main
10:03:26 <nand`> I remember coming across a problem with that once
10:03:32 <ion> bracket a print return  -- ;-)
10:03:33 <elliott> nand`: nope
10:03:41 <elliott> ion: :D
10:03:50 <elliott> does bracket return the result of the finaliser, though?
10:03:52 <elliott> i somehow doubt it
10:04:18 <ion> print is the finalizer, its result value is not needed.
10:04:27 <c_wraith> no, bracket throws out the result of the finalizer
10:04:42 <elliott> oh, ah
10:04:45 <elliott> even better
10:04:57 <elliott> by which I mean, worse
10:05:01 <akosch> elliott: it's somewhat better than using unsafePerformIO for creating the connection itself on top-level... But I guess it's just as bad.
10:05:38 <elliott> akosch: well, i don't know what you're actually proposing, so I can't comment :)
10:05:52 <ion> @hoogle m a -> (a -> m b) -> (a -> m c) -> m c
10:05:53 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:05:53 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:05:53 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:06:21 <akosch> elliott: I'll better think this over :)
10:06:51 <c_wraith> akosch: if you're already in IO, is it really a problem to wrap it in ReaderT?
10:08:44 <akosch> c_wraith: I guess not, but I need to do it for everything. All of my functions are doing database stuff
10:09:27 <c_wraith> akosch: it's a very common pattern, when building larger haskell software, to build an environment for yourself, that enables all kinds of useful utility programs
10:09:38 <roconnor> what are the laws for Traversable?
10:09:57 <c_wraith> akosch: and very often, that environment is a ReaderT wrapper around IO.
10:10:07 <akosch> c_wraith: what about Data.Reflection?
10:11:47 <elliott> roconnor: I don't think there are any.
10:11:48 <c_wraith> that still requires changing all your type signatures
10:12:06 <elliott> roconnor: Foldable's unstated laws are "same as the Prelude functions composed with toList", IIRC.
10:12:14 <nand`> ion: Works, sort of, the only problem is that the middle argument gets evaluated *after* the last argument.. in my case, the middle argument is an infinite recursion; so the printing never happens until my program terminates
10:13:16 <cmccann> c_wraith, I refer to ReaderT around IO with a record full of IORefs for the environment as the "global variable monad" :P
10:14:18 <c_wraith> cmccann: that's pretty accurate.  Except that it's nicely the "fake-global environment", since you can, at least in theory, pass in a different environment sometimes. :)
10:15:02 * geekosaur gets good mileage out of using local with that setup sometimes
10:15:03 <elliott> cmccann: All you need is ContT on top for goto/setjmp/longjmp, and you have the C monad.
10:16:25 <cmccann> c_wraith, yes, and actually I'd generalize it to TVar and other reference-like things for the base monad, there are even a couple libraries providing type classes for that
10:16:44 <cmccann> and yeah, being able to swap out your pseudo-global environment using local is pretty nice
10:16:57 <hpc> :t local
10:16:58 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
10:17:06 <hpc> ooh
10:17:25 <c_wraith> It has the convenience of being like globals...  But the nice property of not actually being globals.
10:17:53 <cmccann> I think the same pattern also generalizes easily to include State with lenses for the reference type
10:18:38 <geekosaur> (one trick I've done with local is temporary caching during an involved update, which automatically goes away when done with the update --- necessary so I pick up global changes next time)
10:18:54 <elliott> c_wraith: Like singletons!
10:19:11 <c_wraith> elliott: uh, no.  singletons are globals, by definition.
10:19:15 <cmccann> geekosaur, oh, that's cute
10:19:25 <elliott> c_wraith: Yeah, but they're not strictly global variables :)
10:19:49 <rostayob> has anybody write any code to write games with FRP?
10:19:57 <c_wraith> they have all the downsides of being globals... So saying that they aren't is questionable at best. :)
10:20:02 <rostayob> *written
10:20:15 <cmccann> actually, one of the true benefits of the singleton pattern is that controlled instantiation for pseudo-globals makes it easier to make them not-global later
10:20:38 <c_wraith> rostayob: https://github.com/leonidas/codeblog/blob/master/2012/2012-01-17-declarative-game-logic-afrp.md was posted to reddit recently..  I haven't read it, but it seems relevant
10:21:08 <rostayob> c_wraith: thanks
10:22:40 <__emj> :q
10:23:08 <elliott> :wq!
10:23:25 <c_wraith> elliott is really excited about quitting vi
10:23:27 <ocharles> remember to check in your changes to git with git reset --hard too
10:23:42 <ocharles> in fact, done programming? yank out the power cord!
10:23:49 <qpu> heh
10:24:07 <elliott> I just blow up the planet whenever I finish my code.
10:25:38 <nand`> (thus proving that haskell programmers never get anything done)
10:25:57 <elliott> nand`: No, no, I make a backup first.
10:26:02 <elliott> Then I spawn a new universe simulation.
10:26:02 <nand`> oh okay
10:26:04 <nand`> well
10:26:14 <nand`> we're all incremental copies of the universe a planck time unit earlier
10:26:27 <elliott> In fact, you're about to get reset 10 minutes back in about 5 secon
10:26:29 <nand`> I think there's a more efficient way to do it but I don't know enough math yet
10:26:43 <elliott> c_wraith: Like singletons!
10:26:51 <elliott> Actually I probably didn't say that 10 minutes ago.
10:27:02 <Botje> 8 minutes.
10:27:06 <elliott> Close enough.
10:27:13 <elliott> There was a 2-minute glitch.
10:28:11 <nand`> where... where am I?
10:28:58 <cmccann> elliott, don't suppose you have a quantum bogosort implementation lying around
10:29:02 <elliott> nand`: Hi! Welcome to AOL!
10:29:14 <Athas> Huh, cabal doesn't have a manpage?
10:29:14 <nand`> You've got mail
10:29:34 <elliott> cmccann: Sure, but I haven't run it for a while, let me just check it works first...
10:29:39 <cmccann> heh
10:29:53 <nand`> cmccann: isn't that already in Data.List?
10:30:43 <cmccann> no, you need the quantum indeterminism monad from Control.Monad.MWI
10:31:07 <ocharles> it simultaneously is, and isnt, in Data.List
10:31:13 <elliott> Be careful: in Copenhagen realities it destroys the sole universe.
10:31:20 <elliott> This is why you never rely on undefined behaviour...
10:32:10 <cmccann> elliott, only fail does that, it's safe to use otherwise
10:32:33 <elliott> cmccann: Yeah, but it means the MonadPlus instance breaks the laws :(
10:33:04 <elliott> mplus mzero a = _|_ (spontaneous universal existence failure)
10:33:51 <keep_learning> > sliceP  0 3 [: 1 , 2 , 3 , 4 , 5 :]
10:33:51 <nand`> _|_ doesn't cause the universe to fail, it just means the universe has to query God to evaluate it
10:33:52 <lambdabot>   Not in scope: `sliceP'A section must be enclosed in parentheses thus: (: 1)...
10:34:05 <elliott> I doubt lambdabot does DPH
10:34:28 <elliott> nand`: Ooh, we should have supplyBottom :: a -> IO ()
10:34:31 <qpu> why is fail part of Monad?
10:34:43 <keep_learning> elliott  is it possible to load Data.Array.Parallel in ghci ?
10:34:43 <elliott> If any evaluation is blocked on a known _|_ of the right type, the value specified is substituted instead.
10:35:02 <keep_learning> when i am trying to do import Data.Array.Parallel
10:35:03 <elliott> qpu: Because the Haskell 98 Commitee did a bad thing.
10:35:08 <elliott> qpu: It was fine in 1.4.
10:35:17 <elliott> keep_learning: Probably. I haven't used DPH.
10:35:29 <elliott> qpu: It's for failing do-notation pattern-matches
10:35:49 <elliott> do { x:xs <- m; ... } -> m >>= \mv -> case mv of { x:xs -> ...; _ -> fail "pattern match failed at foo.hs line blah" }
10:36:10 <keep_learning> then it says it can not find the module Data.Array.Parallel. It is a member of the hidden package `dph-par' . It is a member of the hidden package `dph-seq'
10:36:22 <keep_learning> How to avoid this error
10:36:49 <ocharles> keep_learning: -package dhp-par
10:36:53 <ocharles> dph-par*
10:36:55 <ocharles> erm
10:36:56 <elliott> keep_learning: ghci -Odph -fdph-par?
10:37:01 <ocharles> in fact
10:37:02 <ocharles> i'll just shutup
10:37:17 <elliott> ghci doesn't hide things automatically, so I guess it's hidden for a reason.
10:37:18 <cmccann> elliott, haha, supplyBottom is cute. obviously breaks some notions of purity but I wonder how badly?
10:37:21 <qpu> elliot: ah, could it have been placed in another class? would do-notation no longer work?
10:37:48 <ion> It could easily be in MonadFail, and the do sugar could use that instead when necessary.
10:37:48 <cmccann> qpu, do notation could work for types with only one constructor
10:37:55 <elliott> cmccann: well... you can't detect _|_, so nothing *observable*
10:38:16 <elliott> qpu: It could have been, but the Committee thought that newbies would be confused by additional constraints popping up in their types.
10:38:27 <elliott> qpu: Instead, newbies are confused as to why the Committee made such an awful decision :)
10:38:32 <qpu> haha
10:38:34 <elliott> At least that's how I heard it.
10:38:41 <ocharles> as a previous newbie, I wish that hadn't been done, with a lot of "for the newbies" decisions :(
10:39:13 <cmccann> elliott, right, so I think it'd end up in the same sort of "impure, but you can't tell at runtime" category as unsafeInterleaveIO
10:39:21 <qpu> yeah, it directed me toward an incorrect understanding of monads for quite a while
10:39:23 <elliott> cmccann: It reminds me of { yikes :: (a -> IO (), a) }
10:39:54 <elliott> cmccann: if you have (f,x) <- yikes, then x blocks until (f y) is executed, and is then y
10:40:18 <keep_learning> ocharles, elliott thank you
10:40:18 <roconnor> @type traverse
10:40:19 <lambdabot> Not in scope: `traverse'
10:40:23 <roconnor> @hoogle traverse
10:40:24 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:40:24 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
10:40:24 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
10:40:28 <ocharles> @type Data.Traversable.traverse
10:40:29 <elliott> (yikes + waitUntilSomeoneStartsEvaluatingThis :: a -> IO () is enough to implement unsafeInterleaveIO.)
10:40:29 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:40:41 <elliott> So yeah, it's basically on the level of unsafeInterleaveIO.
10:40:47 <elliott> But it feels worse.
10:40:51 <cmccann> heh
10:41:19 <cmccann> I wonder if there's a good way to formalize that kind of limited impurity?
10:41:34 <elliott> (unsafeInterleaveIO m = do { (f,x) <- yikes; _ <- forkIO $ do { waitUntilSomeoneStartsEvaluatingThis x; m >>= f }; return x })
10:42:08 <elliott> (You can also do unsafeInterleaveIO with *just* wtf :: (a -> (), a).)
10:42:12 <xil> hi. Does record syntax have a type? By which I mean, does "myT $ {parameterT = whatever}" work because of syntactic sugar, or because the stuff in squiggly brackets is an actual thing that can, for example, be the return type of a function?
10:42:24 <elliott> (Which does exactly what you expect, if you're terrible.)
10:42:27 <cmccann> xil, pure sugar
10:42:29 <elliott> erm
10:42:32 <elliott> wtf :: IO (a -> (), a)
10:42:35 <xil> cmccann: damn. Thanks
10:43:11 <ion> xil: “$”?
10:43:22 <ion> Does that work?
10:43:33 <elliott> No.
10:43:36 <xil> oh does it not? I thought it did
10:43:40 <xil> that's my bad then
10:43:42 <elliott> It's myT { ... }
10:44:01 <cmccann> or possibly (foo x) { ... }
10:45:12 <elliott> cmccann: That syntax is the most confusing thing in Haskell.
10:45:27 <elliott> System.Process surprises me every time with (proc [...]) {...}.
10:45:51 <nand`> I've never seen that before, can you provide a minimal example?
10:45:54 <elliott> (I wonder if you can make a polyglot System.Process-importing/arrow-notation-using program.)
10:45:59 <nand`> or link to an article or something
10:46:04 <elliott> nand`: x { field = blah } just "updates" the record x
10:46:09 <elliott> it's the same as x but with field as blah
10:46:12 <elliott> (f x) { ... } is the same
10:46:15 <elliott> just on the result of an application
10:46:20 <nand`> oh
10:46:33 <ocharles> it's common with "def { foo = bar }" to take some 'default' record, and change just part of it
10:46:41 <hpc> that's definitely an unusual coding technique
10:46:43 <ocharles> benchmarkWebServer def { threadCount = 10 }
10:46:51 <ion> > runIdentity ((head [Identity 42]) { runIdentity = 43 })
10:46:52 <lambdabot>   43
10:47:08 <elliott> That works for all the transformers run*s.
10:47:30 <elliott> > runState ((return 42) { runStateT = \s -> return (43, s) })
10:47:31 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:47:31 <lambdabot>    `GHC.Base.Monad t'
10:47:31 <lambdabot>      a...
10:47:41 <elliott> > runState ((return 42 :: State () Int) { runStateT = \s -> return (43, s) })
10:47:41 <hpc> :t runContT
10:47:42 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
10:47:42 <lambdabot>   Overlapping instances for GHC.Show.Show (s -> (a, s))
10:47:42 <lambdabot>    arising from a use...
10:47:46 <elliott> > runState ((return 42 :: State () Int) { runStateT = \s -> return (43, s) }) ()
10:47:47 <lambdabot>   (43,())
10:47:47 <elliott> sheesh!
10:47:49 <cmccann> yeah, record syntax like "foo bar { .. }" actually binds tighter than function application
10:48:05 <elliott> it probably shouldn't
10:48:08 <nand`> what does it de-sugar to? let Foo (a,b,c,_,e) = f x in Foo (a,b,c,blah,e)?
10:48:18 <elliott> nand`: let Foo a b c _ e = f x in Foo a b c blah e
10:48:21 <elliott> or whatever
10:48:27 <elliott> not tuples :)
10:48:42 <nand`> oh right, my bad
10:48:48 <nand`> I was thinking (Foo a b c _ e)
10:52:42 <parcs`> it would be cool if you could do: "foo :: Bar -> Bar; foo = { a = 1, b = True, c -> succ }" where { .. } is an anonymous record update and -> denotes record modification (-> to parallel the syntax of ViewPatterns)
10:53:00 <elliott> data-lens supports writing something equivalent to that
10:53:02 <elliott> though not the syntax ofc
10:53:25 <elliott> foo = (a ^= 1) . (b ^= True) . (c ^%= succ)
10:53:35 <elliott> or foo = setL a 1 . setL b True . modL c succ
10:53:55 <parcs`> yeah
10:54:04 <hpaste_> keep_learning pasted “error in dph-par lengthP” at http://hpaste.org/56680
10:54:36 <elliott> wat @ that paste
10:54:49 <keep_learning> Could some one please  have a look at the code.
10:54:54 <elliott> what happens if you just type in v?
10:54:58 <elliott> to show the contents
10:55:03 <keep_learning> Why its giving length 0
10:55:38 <keep_learning> elliott it says no instance of ( Show [: Double :] )
10:56:01 <elliott> oh
10:57:27 <keep_learning> elliott i just want to make sure that i don't bother too much Ben Lippmeier
10:57:37 <keep_learning> elliott if its error or not
10:58:06 <elliott> Well, it doesn't look right :P
10:58:15 <elliott> What GHC version?
10:58:23 <keep_learning> ghc-7.2.1
10:59:16 <keep_learning> elliott should i go for ghc-7.4 but i don't know how to install dph-examples without cabal ?
10:59:20 <elliott> it sounds like a bug to me
10:59:29 <elliott> I'd report it, but I've never used DPH, so...
11:00:19 <keep_learning> elliott  could you please tell me how to install libraries in ghc-7.4 without cabal ?
11:00:59 <elliott> Without cabal-install? You could download and runhaskell Setup.hs yourself, but I kind of doubt dph-examples will work with 7.4 right now.
11:01:08 <elliott> I wouldn't bother using 7.4 until it's released.
11:01:28 <keep_learning> elliott thank you for your time
11:01:35 <rwbarton> In my experience older versions of cabal-install tend to work fine with newer ghcs
11:02:14 <elliott> rwbarton: unless that ghc is 7.2 :)
11:02:39 <rwbarton> Oh yeah. That's what the topic is about, isn't it :)
11:03:45 <elliott> rwbarton: nope, 7.4
11:03:58 <rwbarton> "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)"?
11:04:03 <elliott> oh, right
11:04:06 <elliott> the topic topic, yes :)
11:04:35 <meditans> anyone knows how to solve this problem I have with Glade? When executing it complains to have an <interface> instead of a <glade-interface>
11:04:51 <meditans> i'm using glade 3.10.0
11:05:20 <elliott> meditans: Are you using gtk2hs or something?
11:05:27 <elliott> It's probably best to ask a glade or at least gtk-specific channel.
11:05:29 <meditans> yes, gtk2hs
11:05:40 <meditans> ah, ok I will :D
11:06:02 <elliott> I think the official gtk channels are on gimpnet.
11:07:38 <xil> hi, so I have 'data Ts = Ts {tA :: Int, tB :: Int, tC :: Int}' and 'data T = A Int | B Int | C Int' and I want a function with type 'Ts -> [T] -> Ts' that adds each T in the list to the given Ts, so like if you passed '(Ts {tA = 0}) [B 1, C 1]' to the function you'd get 'Ts {tA = 0, tB = 1, tC = 1}'. I have an idea but it looks ugly. I'm hoping to learn better practices from looking at examples
11:08:05 <Sgeo> Is there something like Glade for wxWindows?
11:10:28 <Botje> xil: you got cut off after 'examples'
11:10:34 <xil> nope
11:10:51 <Botje> oh
11:10:54 <xil> haha
11:10:59 <elliott> Botje: you got cut off after "'examples'"
11:11:45 <Botje> pffrt. :P
11:13:05 <akosch> I've tried ReaderT for managing my global application state and it's not bad. Still I don't like to use liftIO all over my code: can I somehow turn this around an lift things into the reader monad instead of lifting my IO actions? I imagine something like an IO transformer :)
11:13:29 <hpaste_> asd pasted “asd” at http://hpaste.org/56681
11:13:47 <xil> lol
11:14:31 <elliott> akosch: No.
11:14:46 <elliott> (Consider IOT (Cont r) if you want to convince yourself why.)
11:15:09 <elliott> Also, since all the Prelude IO functions return (IO a), not some hypothetical (IOT m a), it still wouldn't help :)
11:15:30 <Saizan> akosch: nope
11:15:41 <cmccann> Would "IOT []" fork a thread for each list element? :P
11:15:58 <akosch> elliott: hm, still... using liftIO on 90% of my code seems like boilerplate
11:16:36 <cmccann> akosch, you probably don't need that many liftIO calls one way or another
11:16:36 <akosch> is there any other way around this?
11:16:48 <elliott> akosch: do { liftIO m; liftIO m' } === liftIO $ do { m; m' }
11:17:09 <elliott> akosch: Also, you only need the ReaderT part in functions that access the database.
11:17:13 <cmccann> if you have something that doesn't use the ReaderT environment, you can just use IO and then liftIO on the result of that
11:17:16 <elliott> <cmccann> Would "IOT []" fork a thread for each list element? :P
11:17:17 <elliott> perfect!
11:17:27 <elliott> IOT Maybe is great for cancelling serious international side-effects after the fact.
11:17:53 <Veinor> haha
11:18:05 <cmccann> and if you have a few IO functions you use often, you can create lifted aliases for them
11:18:20 <elliott> Mu IOT -- for quantum bogosort implementations
11:18:22 <akosch> elliott: yeah, liftIO $ do stuff seems bearable... it's just one additional indent
11:18:26 <elliott> you can acess all of the universes!
11:18:28 <elliott> *access
11:19:09 <akosch> cmccann: great idea, I only use a few functions. But I use them a lot...
11:20:04 <cmccann> akosch, yeah, I'd probably do something like "putStrLn = liftIO . putStrLn", put that in some module you import everywhere, and then hide the original putStrLn
11:20:16 <cmccann> kinda hackish but it works
11:20:35 <elliott> cmccann: figuring out what IOT Prob means is left as an exercise for the reader
11:20:35 <elliott> :t fix (liftIO .)
11:20:36 <lambdabot> forall a (f :: * -> *). (Functor f) => f (IO a)
11:20:43 <akosch> cmccann: I imagine I also could use template haskell to do this automatically
11:20:50 <elliott> putStrLn :: (Functor f) => f (IO a)
11:21:01 <elliott> (oh, that's caleskell)
11:21:15 <elliott> akosch: defineLifted 'putStrLn is not really better than putStrLn = liftIO . P.putStrLn
11:21:32 <akosch> maybe I could alias liftIO to some punctuation :)
11:21:38 <elliott> it's not infix
11:21:42 <elliott> so you'd have to use it in a section
11:21:48 <cmccann> akosch, I doubt you'd get much benefit from TH here
11:21:51 <elliott> as in, *not binary
11:23:03 <akosch> cmccann: I could create the lifted definitions with it I imagine
11:23:43 <cmccann> akosch, it wouldn't be much less verbose than writing them manually, like elliott said
11:24:10 <elliott> the time it takes to write the longer definitions <<< the time it'll take to compile with TH :P
11:25:40 <akosch> elliott: ok, I'm satisfied with this solution. Thanks very much everyone! :)
11:25:46 <elliott> :)
11:27:29 <cmccann> elliott, btw, have I mentioned that you've been impressively and terrifyingly prolific on stack overflow?
11:28:40 <elliott> cmccann: I have no idea how it happened, I just answered one question and everything after that's a blur.
11:29:28 <geekosaur> that happens :)
11:29:59 <cmccann> elliott, and now you're #25 for "reputation gained this year" on all of SO
11:30:02 * geekosaur 's profile on SO has a note that he has stopped all SO stuff to keep from getting sucked back into it to the point of not doing any job hunting etc.
11:30:42 <elliott> cmccann: haha, wow -- I noticed I was at the top of the week rankings on my profile but I didn't think it was /that/ bad
11:31:20 <cmccann> elliott: check out the "top new users" from last month, as well: http://stackexchange.com/leagues/1/month/stackoverflow/2011-12-01
11:31:48 <elliott> oh, I remember getting an email about that
11:31:58 <elliott> "Congratulations! Here's some spam!"
11:33:43 <cmccann> elliott, on the other hand, daniel fischer is actually ahead of you this month
11:34:08 <cmccann> I don't know what it is with haskell people but this seems to be a recurring pattern :P
11:34:10 <elliott> My legacy! Ruined!!
11:34:20 <elliott> cmccann: nobody let Oleg know about SO...
11:34:51 <elliott> (at least, not without checking the software can handle the rep counter overflowing first)
11:35:21 <xil> no one's got any suggestions then
11:36:00 <elliott> xil: you want lenses, I think
11:36:13 <elliott> oh... hmm
11:36:18 <elliott> no :)
11:36:46 <xil> oh so not lenses?
11:36:59 <elliott> xil: yes, I have an idea
11:37:05 <frerich_> Hi, I recently noticed that my programs have two different ways to process streams of IO input and I wonder whether those styles have different names or some advantages/disadvantages or something. The tiny two-liner at http://hpaste.org/56682 demonstrates what I mean. Does anybody have some thoughts on this?
11:37:25 <frerich_> In shot, I either have a plain recursive function, or I have an infinite list and then process it with fmap and sequence.
11:37:33 <frerich_> I somehow like the latter better, but I don't know why.
11:37:38 <frerich_> It seems more 'declarative'.
11:37:39 <elliott> xil: count (A n) = Ts n 0 0; count (B n) = Ts 0 n 0; count (C n) = Ts 0 0 n; xil'sFunction ts xs = ts `mappend` foldMap count xs
11:37:53 <elliott> xil: with an instance Monoid Ts where mappend (Ts a b c) (Ts d e f) = Ts (a+d) (b+e) (c+f)
11:37:59 <elliott> and mempty = Ts 0 0 0
11:38:31 <xil> ah, but my actual data type doesn't use Ints
11:38:34 <xil> that was just an example
11:38:39 <elliott> frerich_: I prefer the former. The latter is basically just hiding fix in repeat.
11:38:44 <xil> I need a full on replace, not just adding them together
11:38:46 <elliott> and (>>) in sequence
11:38:49 <elliott> btw, you mean sequence_ :)
11:39:06 <elliott> xil: oh, you want to replace them
11:39:07 <elliott> xil: it sounds like you're doing something you shouldn't :)
11:39:12 <elliott> but lenses /would/ fit in that case
11:39:22 <elliott> still, why are you processing this list? what's T for?
11:39:28 <frerich_> elliott: Hmm, fix. I need to read up on that...
11:39:44 <elliott> frerich_: fix f = f (f (f (f ...)))
11:39:54 <elliott> frerich_: for instance, fix (putStrLn "foo" >>) = putStrLn "foo" >> putStrLn "foo" >> putStrLn "foo" >> ...
11:40:06 <elliott> repeat x = fix (x:) = x : x : x : ...
11:40:07 <frerich_> Hm I see what you mean.
11:40:21 <xil> so I have a bunch of constants that I want the user to be able to set, but I want them to be able to only specify some of them, and I like the list format for doing so, rather than record syntax which can be ugly. So I thought that you could just pass the list of only the constants you want, and it would override the defaults
11:40:25 <cmccann> frerich_, if you prefer the declarative style what you probably actually want is a monadic unfold
11:40:41 <hpaste_> DanBurton pasted “Woes installing GHC 7.0.4 on Ubuntu 10.4” at http://hpaste.org/56683
11:40:49 <elliott> sequence_ (repeat x) = foldr (>>) (return ()) (fix (x:)) = x >> foldr (>>) (return ()) (fix (x:))
11:40:55 <elliott> = x >> x >> foldr (>>) (return ()) (fix (x:))
11:40:58 <elliott> = x >> x >> x >> foldr (>>) (return ()) (fix (x:)) and so on
11:41:03 <frerich_> elliott: But Isn't using an infinite list (would it be fair to call it 'declarative'?) nice in that it somehow treats the input data as a "stream" (it actually uses a list) instead of encoding this "sequential" stream of data as a recursion?
11:41:17 <elliott> frerich_: you are not really doing that, though
11:41:20 <elliott> it's not an infinite stream of inputs
11:41:25 <elliott> it's just an infinite stream of /the same/ IO action
11:41:40 <elliott> it's not [line 1 behind IO barrier, line 2 behind IO barrier, ...], it's [program that reads a line, program that reads a line, ...]
11:42:00 <cmccann> in most cases you won't want to just keep doing the same thing forever
11:42:04 <elliott> e.g. if (IO a) was implemented behind the scenes as containing a C program that computes an a (obviously this is unrealistic :)), repeat getLine is [IO "gets()", IO "gets()", ...]
11:42:13 <elliott> so you're not really constructing a stream of inputs at all
11:42:32 <elliott> hmm, that's not even a "correct" use of gets :D
11:42:36 * elliott shame
11:42:38 <frerich_> Hm, maybe I have the wrong mental image.
11:42:39 <cmccann> and if you did want infinite repetition, just cut to the chase
11:42:41 <cmccann> :t forever
11:42:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
11:42:48 <elliott> oh, I forgot about forever :(
11:42:58 <nand`> so microsoft just added achievements to visual studio
11:43:01 <frerich_> cmccann: Oh, I wasn't aware of that!
11:43:02 <nand`> when is haskell getting the same?
11:43:12 <elliott> nand`:
11:43:15 <elliott> @quote ghc exploded
11:43:15 <lambdabot> ghc says: My brain just exploded.
11:43:18 <cmccann> Achievement Unlocked: Made GHC's Brain Explode
11:43:20 <elliott> yep
11:43:21 <cmccann> heh
11:43:22 <elliott> that's the only achievement
11:43:24 <elliott> good luck
11:43:30 <Sgeo> Write a 10-line long function in pointfree style?
11:43:32 * frerich_ is disappointed, he thought 'flattening' this "read data chunk by chunk" code would be really neat :-}
11:43:37 <nand`> I've gotten GHCi to crash a few times if that counts
11:43:54 <elliott> nand`: a _few_ times?
11:44:01 <elliott> didn't you say you were a newbie?
11:44:08 <elliott> I guess you're either incredibly unlucky or have a broken installation
11:44:31 <cmccann> frerich_, the difference between an infinite list and what you're doing is that you can't really do control-flow decisions inside sequence_
11:44:37 <nand`> eh I've been using ghci for a year or so on and off, I've just never actually written a program in haskell
11:44:42 <zachk> the only ghci i ever got to crash alot was 6.6.1 on openbsd
11:44:47 <cheater_> what were you using ghci for
11:44:57 <elliott> nand`: fair enough
11:44:57 <nand`> well, the only times it crashes is if I get it stuck in some infinite loop and hit ctrl+c, sometimes it likes crashing afterwards
11:45:06 <zachk> thats not a crash
11:45:18 <cmccann> frerich_, so you can't do things like filter to express "repeat this action until X"
11:45:20 <nand`> zachk: I get a full crash dump from ghci
11:45:25 <nand`> with it telling me to “please report this bug”
11:45:32 <zachk> interesting
11:45:35 <elliott> that sounds like an RTS problem of some kind
11:45:40 <cmccann> I've made GHCi fall over because a type was too big
11:45:44 <elliott> nand`: well, report that bug :)
11:45:45 <cmccann> but that's not too hard
11:45:51 <nand`> maybe it's an issue with running too many instances for too long; I currently have.. let me count 9 instances of ghci running
11:45:54 <nand`> the oldest for a few months now
11:46:02 <elliott> ghci doesn't do IPC :
11:46:02 <elliott> :P
11:46:05 <cmccann> but that was more a "grinding to a halt and using all system memory" than an actual crash
11:46:12 <frerich_> I thought it would be neat for writing e.g. GUIs, where you have some IO action which yields some sort of 'event'. Or to write networking applications. Modelling a 'stream of incoming events/data/tokens' as an actual list seemed to be a good idea :-)
11:46:12 <frerich_> but thanks for your responses, I'm currently playing with 'fix' and 'forever'.
11:46:16 <byorgey> Incidentally, the exploding brain referred to in that error message is SPJ's, not GHC's.
11:46:24 <cheater_> why would you be running ghci over 9 months
11:46:31 <cmccann> byorgey, hahaha
11:46:41 <nand`> not 9 months, not quite that long
11:46:56 <cmccann> frerich_, like I said before, I think what you want is a monadic version of unfold
11:47:09 <elliott> @hoogle unfoldM
11:47:09 <lambdabot> No results found
11:47:11 <ion> > forever alone
11:47:12 <lambdabot>   Not in scope: `alone'
11:47:13 <elliott> What, really?
11:47:35 <elliott> frerich_: Haskell IO used to be based on streams
11:47:41 <elliott> main :: [Response] -> [Request]
11:47:48 <elliott> The problem is that it's incredibly brittle (even moreso than lazy IO).
11:47:56 <cmccann> frerich_, to express the same sort of "stream of results that you can process incrementally" you need corecursion, which is inherent to pure lazy lists but needs to be done explicitly with monads
11:48:00 <elliott> frerich_: You might be interested in iteratees/conduits/etc. as far as stream-based IO goes.
11:48:03 <nand`> cheater_: bad habit, I open up a new instance of ghci whenever I get some idea that needs immediate testing or verification then just minimize them in case I want to browse the results later
11:48:12 <elliott> They're based on transforming and processing streams of data from the outside world.
11:50:10 <davv3_> heya. i want to count how many function calls are made in my recursive function, any quick (and dirty?) way to go about this?
11:50:14 <hpaste_> “C. McCann” pasted “monadic unfolds” at http://hpaste.org/56684
11:50:29 <cmccann> frerich_, check out that hpaste to see what I mean
11:51:02 <cmccann> that's a copy+paste from my "module full of things I got tired of reimplementing in every project"
11:51:24 <cheater_> nand`: what operating system are you using for your desktop?
11:52:23 <nand`> cheater_: Windows 7
11:53:09 <elliott> davv3_: Debug.Trace
11:53:12 <dschoepe> davv3_: you can put a `trace "I've been called"' from Debug.Trace at the start of the function
11:53:15 <elliott> davv3_: just add e.g.
11:53:20 <elliott> f _ _ _ | trace "hi" False = undefined
11:53:23 <elliott> to the top of your clauses
11:53:27 <elliott> *at the top
11:53:40 <elliott> cmccann: untilM is at least in some monad-loops package
11:53:47 <elliott> http://hackage.haskell.org/packages/archive/monad-loops/0.3.1.1/doc/html/Control-Monad-Loops.html
11:53:49 <elliott> oh, it has unfoldM too
11:54:29 <xil> elliot, could you recommend a source for learning bout lenses? I'm trying to read up on it and none of the stuff I've found makes sense
11:55:28 <MostAwesomeDude> xil: Do you understand what a lens is? Also, which lens package are you using?
11:55:39 <xil> MostAwesomeDude: no and no
11:55:49 <xil> I haven't picked a package because I don't know what they are
11:55:52 <MostAwesomeDude> xil: Okay. Well, I recommend data-lens.
11:55:52 <xil> trying to figure out what they are
11:55:54 <MostAwesomeDude> Ah.
11:56:20 <MostAwesomeDude> A lens is a view or property that goes between two types. You could look at it as a getter and setter, or an isomorphism.
11:56:45 <MostAwesomeDude> They have a handful of fun properties, like being able to more cleanly do record getters and setters.
11:57:00 <xil> record as in record syntax?
11:57:04 <xil> because that's what I need this for
11:57:09 <cmccann> frerich_, did you see the hpaste link I gave?
11:57:09 <MostAwesomeDude> Yes.
11:57:22 <elliott> xil: yes, I can
11:57:37 <frerich_> cmccann: Yeah, I got disconnected a while ago but I just read the IRC log at http://tunes.org/~nef/logs/haskell/12.01.19 (it seems to be live!)
11:57:56 <frerich_> cmccann: I'm currently digesting your loop functions there
11:58:03 <parcs`> xil: http://twanvl.nl/blog/haskell/overloading-functional-references
11:58:05 <elliott> xil: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio is a good introduction
11:58:05 <elliott> I recommend the data-lens package (by the author of the answer there)
11:58:05 <elliott> but fclabels is also fairly popular
11:58:30 <cmccann> elliott, yeah, none of those functions are particularly remarkable, but there are enough variations that I didn't feel like tracking down existing packages with all the flavors I wanted
11:58:40 <elliott> parcs`: I'm not sure that's a good introduction, especially since none of the major packages implement that technique (and (.) is already generalised by Control.Category)
11:58:52 <elliott> cmccann: right
11:59:31 <cmccann> elliott, I actually think several of those really ought to be in Control.Monad but oh well
11:59:46 <elliott> cmccann: Yes, some richer control structures would be nice.
12:00:06 <elliott> We have this extensible, first-class, overloadable imperative programming infrastructure that we like to brag about, but don't exploit it nearly as much as we could :)
12:01:16 <cmccann> yeah, and the lack of standard corecursive stuff is a big hole
12:01:28 <cmccann> particularly given how common corecursive uses of lists are in pure code
12:01:43 <hpaste_> av pasted “parsec” at http://hpaste.org/56690
12:02:46 <av> Hi, what am I doing wrong here? http://hpaste.org/56690
12:03:03 <frerich_> cmccann: I think your 'sequence_ doesn't allow control flow' is a good point. I must admit, I didn't think that far yet (I first wanted to test whether this 'infinite list of IO actions processed incrementally instead of explicit recursion' idea was actually feasible). However, I could still keep the 'repeat' part (e.g. the "generator" which yields an infinite list of IO actions providing the data) but rather use your 'untilM' or
12:03:03 <frerich_> instead of sequence, no?
12:03:30 <elliott> frerich_: Where would you put the repeat part?
12:04:47 <donri> cabal problem: I have NoImplicitPrelude listed in extensions and as a result my Paths_pkg module fails to build. solutions?
12:05:04 <cmccann> frerich_, if you're just repeating the same action, that's what my iterM stuff is for
12:05:04 <augur> anyone know anything about finding solutions to systems of inequations of sets?
12:05:26 <av> I'm surprised that this parser succeeds -- I would have expected the integer parser to fail given that the integer is not followed by whitespace. or is this normal behaviour for Parsec's lexeme parsers?
12:05:34 <cmccann> (my names for these functions are probably not the best, but oh well)
12:08:48 * cmccann should probably rename those functions, really
12:08:51 <elliott> av: There might be something to turn a parser into a "token" one that requires that kind of separation.
12:08:57 * elliott hasn't really used Parsec's language stuff.
12:09:14 <cmccann> since untilM is more like iterate while iterM is more like repeat :T
12:10:31 <Ragnaroek> I get a "No instance for (IsString Response)" with happstack on a minimal example
12:10:35 <elliott> cmccann: untilM is fine
12:10:35 <elliott> :t until
12:10:35 <elliott> It's more like until than iterate.
12:10:35 <elliott> Oi, lambdabot.
12:10:36 <frerich__> My Wifi router is misbehaving, sorry. Got disconnected again, reading up on the IRC logs.
12:10:36 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
12:11:01 <elliott> cmccann:
12:11:02 <elliott> until  ::              (a -> Bool) -> (a ->   a) -> a -> a
12:11:02 <elliott> untilM :: (Monad m) => (a -> Bool) -> (a -> m a) -> a -> m a
12:11:08 <cmccann> elliott, ha, I forgot that actually existed
12:11:15 <cmccann> okay, yeah, untilM is fine
12:11:19 <elliott> It could also be (a -> m Bool), I guess.
12:11:31 <ion> untilMM
12:11:45 <ion> untilMMM :: (m a -> m Bool) -> …
12:12:14 <elliott> cmccann: iterM could be unfoldM_ :p
12:12:21 <elliott> (Set b = ())
12:12:54 <cmccann> elliott, also a good point
12:13:05 <elliott> then iterM_ would be unfoldM__!
12:13:09 <cmccann> heh
12:13:20 <parcs`> 900 people :)
12:13:28 <elliott> quick! kick someone!
12:13:30 <parcs`> 901!
12:13:40 <roconnor> what happens when we get to 1000?
12:13:43 <xil> I'm just not getting lenses -_-. I'll look at it later I suppose
12:13:51 <MostAwesomeDude> xil: Well, do you understand record syntax?
12:13:56 <xil> yes
12:13:56 <_Mikey> Haskell will become mainstream
12:13:58 <_Mikey> ;/
12:13:59 <ion> OVER 9000
12:14:04 <parcs`> `div`10
12:14:20 <MostAwesomeDude> xil: Lenses help you generalize record syntax to things which might not be records.
12:14:22 <dylukes_> xil: After I read this they made perfect sense: http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
12:14:29 <dylukes_> It's a great explanation for beginners.
12:14:33 <MostAwesomeDude> dylukes_: :T
12:14:36 * dylukes_ troll.
12:14:40 <ion> :-D
12:14:45 <elliott> xil: You know how if foo is a field of a record Rec of type T, foo :: Rec -> T?
12:14:52 <cmccann> elliott, anyway, it really shows that these functions were just pulled from my personal ad-hoc utility module, rather than something I'd put effort into thinking about as a coherent whole :P
12:14:57 <elliott> xil: You could also define setFoo rec x = rec { foo = x }.
12:15:03 <elliott> xil: setFoo :: Rec -> T -> Rec
12:15:10 * frerich__ fell for dylukes link and was already getting fairly intrigued by his definition of 'beginner'
12:15:15 <elliott> xil: (foo, setFoo) :: (Rec -> T, Rec -> T -> Rec) :: Lens Rec T
12:15:20 <parcs`> once this channel hits 1000 haskell will be too mainstream. we will have to migrate to agda
12:15:22 <elliott> That's it.
12:15:26 <dylukes> parcs`: Already there ;)
12:15:40 <dylukes> How many are we at now?
12:15:46 <ion> I use this theorem prover. You wouldn’t have heard of it.
12:15:56 <MostAwesomeDude> xil: Think of it this way. You have some type Parent, and some type Child. If you also have a Lens Parent Child, then you can always get a Child from a Parent.
12:15:59 <parcs`> dylukes: 900
12:15:59 <elliott> xil: data-lens uses the representation (Rec -> (T, T -> Rec)) -- i.e. give me a record, and i'll give you the field, and a function to replace the field. You can think of this as taking the record apart: it turns a record into a field, and a record with a hole where the field should be.
12:16:16 <elliott> MostAwesomeDude: That's also an explanation of (->) :P
12:16:17 <MostAwesomeDude> xil: You can also update the Child in the Parent (returning a new Parent of course), and so on.
12:16:33 <dylukes> My god. parcs` we're almost bigger than #python >:D
12:16:35 <_Mikey> elliott is the field T?
12:16:37 <elliott> OK, that isn't :)
12:16:41 <elliott> _Mikey: Yes.
12:16:43 <roconnor> a lens is a monoidal natural transformation between higher-order coalgebra functors, what's the problem?
12:16:48 <donri> discover bug in cabal, cabal bug tracker is down. FML
12:16:52 <elliott> @remember roconnor a lens is a monoidal natural transformation between higher-order coalgebra functors, what's the problem?
12:16:53 <dylukes> roconnor: >_>
12:16:53 <lambdabot> It is forever etched in my memory.
12:17:08 <dylukes> xil: Simply put, think of lenses as more... what they sound like.
12:17:14 <dylukes> They're something you "look" at a structure through.
12:17:17 <parcs`> dylukes: ehehehehe
12:17:19 <dylukes> They abstract the concept of "accessing".
12:17:20 <MostAwesomeDude> xil: For more fun, if you have a SuperParent which holds a Parent, and a Lens SuperParent Parent, then you can use (.) to create a Lens SuperParent Child.
12:17:30 <dylukes> The name is also convenient because you can "focus" lenses.
12:17:33 <Ragnaroek> happstack anyone?
12:17:34 <elliott> xil: A lens lets you get a little bit out of a whole and replace a little bit inside a hole!!!
12:17:44 <MostAwesomeDude> dylukes: Well, the StateT stuff might be a little scary for him right now.
12:17:48 <elliott> #haskell, where your questions are answered in awful cacophonic quadrophonics.
12:17:54 <dylukes> Yeah, just mentioning it for the sake of metaphor.
12:17:59 <donri> it's kinda weird to call setters "lenses" though
12:18:03 <donri> shrug
12:18:03 <dylukes> @quote fugues
12:18:04 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
12:18:07 <donri> Ragnaroek: shoot
12:18:07 <dylukes> elliott: ^
12:18:10 <elliott> :D
12:18:14 <MostAwesomeDude> Well, it's not just a setter. You also need a getter.
12:18:25 <osfameron> i thought lenses were something to do with bidirectional functions? or was that bananas?
12:18:31 <Ragnaroek> I'm getting: "No instance for (IsString Response)"
12:18:33 <elliott> osfameron: related
12:18:36 <MostAwesomeDude> You can make a lens out of an isomorphism, sure.
12:18:36 <elliott> every isomorphism is a lens
12:18:40 <elliott> a lens just has a residue
12:18:43 <cmccann> osfameron, no, those are different lenses you're thinking of
12:18:47 <xil> interesting
12:18:48 <Ragnaroek> on:serve Nothing $ ok "test"
12:18:50 <donri> Ragnaroek: you're using OverloadedStrings and toResponse, and they're in conflict
12:18:52 <cmccann> or rather, are confusing with bananas
12:18:55 <dylukes> Okay guys, stop.
12:18:59 <dylukes> Just... give him some examples.
12:19:00 <elliott> cmccann: oh, well yes
12:19:04 <elliott> but they are related, still :)
12:19:11 <osfameron> ah
12:19:16 <dylukes> Okay. xil
12:19:17 <dylukes> http://hackage.haskell.org/packages/archive/data-lens-fd/2.0/doc/html/Data-Lens.html
12:19:25 <dylukes> You build a Lens http://hackage.haskell.org/packages/archive/data-lens/2.0.2/doc/html/Data-Lens-Common.html
12:19:25 <xil> that's what I'm looking at now
12:19:28 <parcs`> that is overly abstract
12:19:35 <dylukes> You build a lens from a getter and setter.
12:19:35 <elliott> xil: it's not (A -> B, B -> A), it's (A -> (B, B -> A)) -- which you can think of like (A -> (B, R), (B, R) -> A)
12:19:42 <Ragnaroek> actually I'm on happstack-lite
12:19:47 <elliott> erm
12:19:51 <elliott> crap, that was meant to be osfameron
12:19:56 <cmccann> @google bananas lenses barbed wire
12:19:57 <elliott> osfameron: it's not (A -> B, B -> A), it's (A -> (B, B -> A)) -- which you can think of like (A -> (B, R), (B, R) -> A)
12:19:57 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125
12:19:58 <lambdabot> Title: CiteSeerX — Functional Programming with Bananas, Lenses, Envelopes and Barbed  ...
12:19:59 <donri> Ragnaroek: ok, try throwing in a toResponse there
12:20:01 <elliott> osfameron: where an R is "A without the B part"
12:20:11 <dylukes> cmccann: That's a different lens.
12:20:14 <elliott> I think we're successfully confusing *everyone* present.
12:20:22 <elliott> Including dylukes, now.
12:20:30 <cmccann> yes, that was the point
12:20:33 <dylukes> No, I mean, that's lenses as in |)
12:20:40 <dylukes> Or were those bananas?
12:20:41 <donri> Ragnaroek: ok $ toResponse "test"
12:20:43 <dylukes> [( is lenses.
12:20:50 <dylukes> (| is a banana.
12:20:54 <dylukes> {| is barbed wire?
12:20:59 <dylukes> If I recall correctly
12:21:00 <_Mikey> :o
12:21:02 <cmccann> I don't even know anymore
12:21:04 <dylukes> [[ is an envelope.
12:21:12 <elliott> Can we just kick everyone and start again?
12:21:16 <dylukes> God this channel is so weird.
12:21:17 <parcs`> ┻━┻ ︵╰(°□°)╯︵ ┻━┻
12:21:19 <Ragnaroek> now I'm getting: Ambiguous type variable `a0' in the constraints:
12:21:19 <_Mikey> seriously Haskell is the best programming language.
12:21:20 <Ragnaroek>       (ToMessage a0) arising from a use of `toResponse'
12:21:39 <dylukes> parcs`: ┬─┬ノ( º _ ºノ)
12:21:43 <dylukes> parcs`: ┬─┬ノ( º _ ºノ)
12:21:47 <mm_freak> _Mikey: you haven't seen agda yet ;)
12:21:49 <ion> > replicateM 2 "[({|"
12:21:50 <lambdabot>   ["[[","[(","[{","[|","([","((","({","(|","{[","{(","{{","{|","|[","|(","|{"...
12:21:56 <roconnor> xil: some youtube videos on lenses (in Scala): http://www.youtube.com/watch?v=efv0SQNde5Q&list=PLEDE5BE0C69AF6CCE
12:21:58 <dylukes> ion: It's one of those.
12:22:01 <mm_freak> where haskell ruins you for other languages, agda ruins you for haskell =)
12:22:03 <donri> Ragnaroek: ok try: ok ("test" :: String)
12:22:03 <Duffman-> _Mikey: that's like saying a truck is the best vehicle out there ... depends on what you need.:p
12:22:10 <_Mikey> mm_freak, is it also functional?
12:22:12 <dylukes> mm_freak: It's so true. Fucking dependent types >.>...
12:22:19 <dylukes> _Mikey: It's dependently typed.
12:22:21 <elliott> _Mikey: and dependently typed
12:22:29 <roconnor> xil: some slides from a talk on lenses: http://twanvl.nl/files/lenses-talk-2011-05-17.pdf
12:22:29 <dylukes> It's like... "oh my god I can express EVERYTHING in my types"
12:22:33 <dylukes> *fap fap fap*
12:22:35 <mm_freak> _Mikey: haskell on steroids
12:22:37 <xil> saw the slides
12:22:40 <xil> didn't understand them
12:22:44 <Duffman-> dylukes: that's so wrong :D
12:22:45 <Ragnaroek> donri: ouldn't match expected type `[Char]' with actual type `Response'
12:22:50 <elliott> I don't think we've given xil enough lens resources yet.
12:22:55 <xil> haha
12:22:57 <elliott> This is how "monads are SO COMPLICATED" is born :)
12:22:58 <_Mikey> mm_freak, I thought Haskell was already on steroids :D
12:22:58 <dylukes> Duffman-: I could probably masturbate to const correctness in C++.
12:23:11 <dylukes> LENSES ARE THE NEW MONADS.
12:23:13 <mm_freak> _Mikey: haskell doesn't have dependent types ;)
12:23:15 <dylukes> Monads are so passé.
12:23:15 <Ragnaroek> wait no
12:23:16 <elliott> _Mikey: You've never tried double steroids???
12:23:25 <mm_freak> dylukes: lenses are based on comonads actually…  at least in the data-lens package
12:23:26 <donri> Ragnaroek: :D ok maybe: ok (toResponse ("test" :: String))
12:23:27 <Ragnaroek> it works. wrong parens
12:23:30 <donri> ok
12:23:36 <donri> could always add the IsString instance
12:23:38 <dylukes> mm_freak: The costate (store) comonad, yeah.
12:23:42 <elliott> mm_freak: in the same way that (a -> b) is based on monads, 'cause it's the reader monad :P
12:23:45 <dylukes> :P
12:23:58 <_Mikey> mm_freak, well I've just got the basics of haskell so far but I'm willing to push it up a notch once I feel more experienced.
12:24:01 <dylukes> elliott: One question... you can buid every monad from the Cont monad...
12:24:04 <Ragnaroek> donri: can you explain it?
12:24:08 <dylukes> can you build all comonads from anything equivalent?
12:24:08 <osfameron> elliott: heh, that lens paper confused me. i'm glad that data.lens isn't (entirely) the same, perhaps i'll be able to understand it
12:24:17 <mm_freak> _Mikey: seriously, don't ;)
12:24:25 <ion> instance IsString a where fromString = unsafeCoerce
12:24:25 <donri> Ragnaroek: import Data.String; instance IsString Response where fromString = toResponse -- might work
12:24:33 <dylukes> _Mikey: Don't touch agda with a nine foot pole, unless you want to never leave your room again,
12:24:33 <_Mikey> I'll take your word for it ;)
12:24:38 <dylukes> and never be able to write code in any language
12:24:48 <_Mikey> dylukes, that addictive?
12:24:52 <dylukes> and want to end up in graduate school studying converse inverse reverse endo-what-the-functors.
12:24:58 <elliott> _Mikey: No, no.
12:25:01 <elliott> dylukes said *any* language.
12:25:07 <elliott> You don't "write programs" in Agda. That's for the commoners.
12:25:18 <dylukes> You... prove them.
12:25:23 <av> elliott: thanks. Any more takers on the parsec/token stuff?
12:25:25 <_Mikey> oh..
12:25:39 <mm_freak> _Mikey: agda takes the concept "programs as proofs" to its conclusion
12:25:48 <dylukes> You start by expressing your propositions and such as data types,
12:25:56 <elliott> dylukes: Or you just vaguely imagine a sketch of them and decide you've done enough work for today.
12:25:57 <dylukes> then fill in holes until you get a compilable program.
12:26:00 <dgpratt> mm_freak: I thought Coq was the conclusion
12:26:05 <_Mikey> ah ok
12:26:06 <dylukes> You usually don't actually *run* agda code...
12:26:11 <dylukes> Once it compiles, you're good.
12:26:12 <dylukes> :P
12:26:15 <mm_freak> dgpratt: i think coq isn't really a programming language
12:26:16 <_Mikey> wow!¬
12:26:20 <tsousa> can you guys explain me why people say that Haskell is not a real world language and written in it a medium to large application would be just in dreams?
12:26:26 <dylukes> I have to wonder if Agda's static type checker counts as a dynamic runtime.
12:26:32 <elliott> tsousa: they're jealous
12:26:34 <dylukes> like... it's probably more complex than most dynamic runtimes.
12:26:48 <mm_freak> tsousa: it's wrong
12:26:48 <dylukes> "compile time" in agda might as well be "run time"
12:26:49 <elliott> tsousa: write a medium to large application and tell them you're living their dream
12:26:49 <dylukes> >_>
12:26:54 <dgpratt> mm_freak: hmm...perhaps so
12:27:02 <_Mikey> tsousa, I think there already seveal medium to large applications in haskell
12:27:10 <tsousa> elliott, ehehe
12:27:23 <_Mikey> dylukes, I will compile some agda before I die.
12:27:28 <elliott> tsousa: more seriously, it's just the stereotype of "purely functional must mean = ideologically pure i.e. overly restrictive and 'useless' for real-world programs", usually combined with "programming is _all about_ side-effects, so purity is useless" and "i heard monads are really hard"
12:27:35 <elliott> I wouldn't pay any attention to it.
12:27:39 <roconnor> tsousa: haskell makes writing incorrect programs more diffuclt, and writing medium to large applications that are correct is difficult.  Thus by modus pones, writing medium to large applications in Haskell is difficult.
12:28:07 <dylukes> I mean, even with the purity crap,
12:28:09 <roconnor> tsousa: wait, that isn't modus ponens
12:28:10 <monochrom> people say all sorts of things
12:28:17 <dylukes> the IO monad lets you RESTRICT and REASON about side effects
12:28:25 <cmccann> also, people who say "medium to large programs" often mean "programs bloated by being written in languages with little expressive power"
12:28:26 <dylukes> It doesn't make it harder to do any one thing, as much as,
12:28:29 <Ragnaroek> donri: no doesn't work
12:28:32 <dylukes> it makes it hard for IO to infect your entire program.
12:28:39 <dylukes> It doesn't constrain WHAT you can do, but WHERE.
12:28:40 <elliott> dylukes: preaching to the choir :)
12:28:46 <Ragnaroek> shouldn't the literal "test" be of type String?
12:28:47 <dylukes> Telling tsousa.
12:28:59 <tsousa> and like written an website is doable in Haskell?
12:29:00 <donri> Ragnaroek: not if you're using the OverloadedStrings extension
12:29:01 <nand`> I think... I think learning haskell has actually made me a /worse/ programmer
12:29:06 <elliott> fair enough
12:29:06 <elliott> roconnor: Anything is modus ponens with enough steps.
12:29:13 <dylukes> modus ponens is cool.
12:29:17 <nand`> I can't go back to the imperative style. I cripple all of my imperative programs with a style that penalizes side effects
12:29:20 <nand`> and state as much as possible
12:29:22 <elliott> By ZFC, thus FLT, per extended modus ponens.
12:29:33 <dylukes> nand`: It's okay, Apple's C extensions include full closures!
12:29:33 <dylukes> :D
12:29:36 <elliott> tsousa: definitely
12:29:39 <dylukes> You can just use const everywhere, and closurs.
12:29:48 <elliott> tsousa: http://www.yesodweb.com/, http://snapframework.com/
12:29:54 <Ragnaroek> hmm ok, have to read about that extension
12:29:57 <dylukes> tsousa: also xmonad.
12:30:02 <elliott> in fact, a webserver based on Yesod's Warp was faster than nginx (OK, in a particular benchmark, but it's still cool :))
12:30:03 <Ragnaroek> but that's very ugly
12:30:20 <dylukes> Another big one tsousa is Pugs.
12:30:35 <dylukes> Perl6, implemented in Haskell, by a genius transgender fellow/lady.
12:30:37 <elliott> Is it? I didn't know anyone actually *used* pugs...
12:30:43 <dylukes> elliott: It's still pretty big :P.
12:30:49 <parcs`> dylukes: lol..
12:30:51 <donri> Ragnaroek: it makes string literals become (fromString "bla") where fromString is defined in the Data.String.IsString typeclass that any string-like type can be an instance of (for exampel Text and Html, and in theory Response)
12:30:52 <dylukes> darcs is pretty big.
12:31:05 <tsousa> dylukes, that is the perl intepretor right?
12:31:33 <dylukes> Yeah, perl6.
12:31:42 <dylukes> It's a compiler and interpreter.
12:31:45 <Enigmagic> tsousa: our codebase is pretty big
12:31:53 <Enigmagic> small company
12:32:04 <dylukes> Pugs compiles Perl 6 into Haskell, Perl 5 (???), JavaScript, or PIR
12:32:13 <_Mikey> Haskell will be mainstream soon.
12:32:15 <Enigmagic> $ wc  -l `find . -name "*.hs"` | grep total: 72093 total
12:32:47 <dylukes> Haskell is also very succinct line wise.
12:32:53 <vhd> I notice there is no function which gives me an empty list. Would it be fair to say that this is because the strict type system cannot return an empty list as it needs a type to begin with? I am trying to have an instance return an empty list but am seeing, "Ambiguous type variable `a0' in the constraint:
12:32:53 <vhd>       (Stack a0) arising from a use of `empty'"
12:33:03 <dylukes> I usually find 80 lines of haskell data types is about 300~400 lines of C++ classes.
12:33:09 <dylukes> Depends on the task of course.
12:33:20 <tikhonjelvis> Rather an empty list can be of *every* type.
12:33:20 <tsousa> i dont really like OO
12:33:32 <elliott> _Mikey: Posting blog posts about how amazing Haskell is is already mainstream.
12:33:46 <elliott> Actually knowing Haskell might take a few more decades for its breakthrough.
12:34:03 <lukish> I have http://pastebin.com/KUtFb1jm problem after install ghc7.2.1 from ppa and try to cabal install cabal-install
12:34:05 <mauke> The paste KUtFb1jm has been copied to http://hpaste.org/56694
12:34:18 <conal> Enigmagic: what's your company?
12:34:39 <elliott> lukish: er...
12:34:44 <vhd> tikhonjelvis, if that is the case then why is it complainging about ambiguity?
12:34:46 <elliott> lukish: you're trying to install cabal-install with cabal-install?
12:34:48 <dylukes> Are there any concrete statistics on Haskell's popularity?
12:34:51 <conal> I'm at Tabula, and we're doing quite a lot of a Haskell programming here.
12:34:56 <dylukes> I recall it's consistently not-used, but VERY talked about.
12:34:59 <lukish> elliott: yes
12:35:00 <tikhonjelvis> What context is it complaining in, exactly?
12:35:11 <dylukes> We have the highest number of people on freenode for a language except Python...
12:35:16 <dylukes> and we have on of the most active subreddits.
12:35:29 <Enigmagic> conal: automated trading
12:35:34 <elliott> lukish: but... why? :)
12:35:52 <conal> Enigmagic: ah.
12:35:53 <dylukes> We're the 16th most popular language on github :)
12:35:55 <vhd> tikhonjelvis, http://pastebin.com/xCJRf3M7
12:35:57 <mauke> The paste xCJRf3M7 has been copied to http://hpaste.org/56695
12:36:03 <dylukes> We were 21st when I checked a while ago I believe.
12:36:03 <elliott> dylukes: as i snarkily implied, I expect the buzz is *much* larger than the number of people who are actually Haskell programmers
12:36:07 <elliott> as opposed to people dabbling in Haskell
12:36:08 <dylukes> elliott: Quite.
12:36:30 <vhd> but calling error gives the error I wrote above.
12:36:33 <monochrom> if some people outside say "haskell isn't practical", you go to #haskell, not those people, to ask "why do they say that?" great plan. now go to #python to ask "why do #haskell people say that haskell is practical?" to complete the quest.
12:36:34 <lukish> elliott: because of that http://hpaste.org/56696
12:36:41 <conal> Enigmagic: do you folks have something like a local Hackage for non-public sharable haskell libraries? i'm wondering what haskell companies use.
12:37:02 <Enigmagic> conal: no, we build everything in one go
12:37:05 <cmccann> monochrom, where do I go to ask why every language sucks and all software is terrible?
12:37:09 <elliott> lukish: ok. don't do that
12:37:09 <conal> Enigmagic: ah. thx.
12:37:15 <cheater_> monochrom: why do people come here to ask why others say haskell is impractical?
12:37:15 <elliott> syb is a boot package (IIRC), so you're not allowed to upgrade i
12:37:15 <elliott> t
12:37:22 <Enigmagic> conal: http://breaks.for.alienz.org/blog/2011/10/28/building-large-haskell-projects-with-waf/
12:37:35 <elliott> lukish: upgrading cabal-install won't help
12:37:39 <elliott> you're just not allowed to do that :)
12:37:39 <conal> Enigmagic: thx for the pointer.
12:38:00 <tikhonjelvis> vhd: That seems to compile for me.
12:38:04 <dolio> cmccann: #lisp
12:38:19 <elliott> dolio++
12:38:19 <vhd> tikhonjelvis, yes it compiles, but if you call empty it will complain about ambiguity
12:38:25 <elliott> but also, cmccann++ except sincerely
12:38:48 <lukish> elliott: so what should I do?
12:38:54 <elliott> lukish: not upgrade syb
12:38:56 <elliott> why are you trying to do that?
12:39:16 <cmccann> dolio, hahahaha
12:39:25 <Enigmagic> conal: we're moving to a central build server for external (hackage) packages though to make sure everyone is using exactly the same bits
12:40:10 <lukish> elliott: because of that http://hpaste.org/56696
12:40:12 <lukish> 2nd
12:40:27 <_Mikey> elliott, thats basically my dissertation :D 'a haskell is amazing blog'
12:40:51 <elliott> lukish: OK, that's not good because json only depends on standard packages
12:40:54 <elliott> lukish: run ghc-pkg check
12:41:01 <elliott> you probably have some really broken package issues
12:41:17 <lukish> Yes
12:41:19 * cmccann suggests nuking everything from orbit
12:41:21 <lukish> What's next
12:41:36 <elliott> yay!
12:41:36 <elliott> what cmccann said
12:41:36 <elliott> uninstall every even vaguely ghc-related pkg, rm -r ~/.cabal ~/.ghc
12:41:36 <elliott> reinstall, start again :)
12:41:49 <elliott> where are you getting cabal-install from? the same ppa?
12:41:58 <cmccann> the simplest way to fix severe broken package issues is delete them all, possibly reinstall GHC in dire cases, and try again
12:42:12 <elliott> cmccann: well, I doubt it's anything ~/.cabal-installed
12:42:19 <elliott> since it's syb, Cabal, etc. messing up
12:42:27 <elliott> although hmm
12:42:31 <elliott> syb is cabal installed these days isn't it
12:42:44 <_Mikey> elliott, would you possibly know why cabal fails to configure haskell-src-exts-1.11.1 on my box?
12:42:52 <cmccann> elliott, I figure once you hit the point of reinstalling GHC might as well reinstall everything
12:42:54 <_Mikey> I'm trying to cabal install hoogle
12:43:00 <tikhonjelvis> vhd: I think the problem is that empty dosn't know what sort of stack to return. That is, you need to specify that it's a ListStack--it doesn't have anything to do with using a [].
12:43:08 <cmccann> nuke from orbit, only way to be sure, &c. &c.
12:43:09 <donri> i've had Cabal etc break on system upgrades because ~/.cabal was built against older
12:43:10 <elliott> _Mikey: hpaste the error
12:43:16 <elliott> _Mikey: (the entire cabal output)
12:43:23 <elliott> and I'll take a look
12:43:34 <elliott> cmccann: *everything*? like, your entire OS?
12:43:47 <vhd> tikhonjelvis, is "ListStack []" not enough?
12:44:01 <hpaste_> “_Mikey” pasted “cabal stuffs” at http://hpaste.org/56698
12:44:05 <cmccann> elliott, well, everything haskell-related
12:44:06 <Jafet> elliott: better run a hard drive check, too
12:44:10 <vhd> tikhonjelvis, or do you mean I need to specify what type of ListStack it is.
12:44:11 <tikhonjelvis> vhd: That bit's fine. The issue is where you actually *use* empty.
12:44:11 <Jafet> You never know.
12:44:12 <cmccann> so unless your OS was written in haskell
12:44:32 <vhd> hmm I see what you mean.
12:44:36 <tikhonjelvis> vhd: So you'd have to do something like empty :: ListStack a
12:44:48 <elliott> cmccann: there goes my House system
12:44:49 <tikhonjelvis> vhd: Or, more reasonably, it would be inferred for you.
12:44:58 <rtharper> @src cycle
12:44:58 <lambdabot> cycle [] = undefined
12:44:58 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:45:01 <tikhonjelvis> vhd: If you used it somewhere else, that is.
12:45:07 <vhd> I see
12:45:13 <tikhonjelvis> vhd: It's just like trying to use `read "blarg"` by itself.
12:45:14 <elliott> cmccann: oh, i see -- everything as in user-scope packages too
12:45:15 <elliott> right :)
12:45:33 <elliott> _Mikey: setup: happy version >=1.17 is required but it could not be found.
12:45:36 <elliott> _Mikey: cabal install happy
12:45:38 <elliott> then try again
12:45:47 <stepcut> Enigmagic: build system for what platform?
12:46:52 <Enigmagic> stepcut: the OS?
12:47:16 <knobo> Does anyone have a simple example with monadic comprehension other then list comprehension?
12:47:17 <stepcut> Enigmagic: I am specifically wondering if you are building for ubuntu/debian
12:47:29 <_Mikey> I think I tried that before
12:47:29 <mee> there was that haskell xen domU that Galois(?) released
12:47:42 <_Mikey> elliott, anyways I tried again and same error
12:47:55 * stepcut would love to deploy happstack apps using that haskell xen thing
12:47:58 <Enigmagic> stepcut: we don't create any packages, if that's what you're asking. we use osx for our dev machines and gentoo for most of the servers
12:48:04 <elliott> knobo: [x ++ y | x <- getLine, y <- getLine, x /= y]
12:48:04 <elliott> maybe not the best example, that'll just print an unhelpful error if the two linse are equal :)
12:48:16 <Enigmagic> stepcut: we use the 'rsync' deploy model
12:48:42 <stepcut> ah
12:48:52 <Jafet> @remember Enigmagic we use the 'rsync' deploy model
12:48:53 <lambdabot> Good to know.
12:49:03 <monochrom> heh
12:49:11 <ion> :-D
12:49:21 <Enigmagic> Jafet: and squashfs :P
12:49:46 <hpaste_> “_Mikey” pasted “more cabal stuffs” at http://hpaste.org/56699
12:49:52 <knobo> elliott: thanx anyway.
12:50:22 * elliott completely forgets what he helped knobo with :)
12:50:50 <monochrom> "Installing executable(s) in /home/mikey/.cabal/bin"
12:50:56 <monochrom> is that in your PATH?
12:51:09 <_Mikey> hmm I'm not sure :$
12:51:23 <_Mikey> how to edit your path on a linux box?
12:51:48 <_Mikey> I'll google that ;/
12:51:50 <monochrom> no edit. you enter the complete new value
12:51:50 <_Mikey> sorry :p
12:51:55 <parcs`> knobo: [ e | a <- ma, b <- mb, pred c ] corresponds to do { a <- ma; b <- mb; guard (pred c); return e }
12:51:59 <elliott> _Mikey: export PATH=$HOME/.cabal/bin:$PATH
12:52:06 <elliott> you'll want to edit your bashrc or whatever long term though
12:52:08 <stepcut> _Mikey: there are dozens of ways, many of which only work some of the time :)
12:53:02 <_Mikey> stepcut,  noo! how delightful
12:54:01 <stepcut> yeah, some places only get read when you login in, but not if you ssh in. others only get read if you start x (but not if you ssh in), etc
12:54:04 <parcs`> export PATH="$HOME/.cabal/bin:$PATH"
12:54:24 <parcs`> interpolation is needed just in case you have a space in your PATH :P
12:54:48 <cheater_> or one of many other things
12:54:53 <_Mikey> cheers guys
12:54:53 <elliott> parcs`: nope
12:54:57 <elliott> it'll work without quotes even if you do
12:55:06 <knobo> parcs`: nice example.
12:55:09 <elliott> sh's syntax "implies" quotes when you just do an assignment
12:55:22 <stepcut> parcs: I think I once had a problem using "" where the PATH was correct when I ran things by hand, but when I ran shell scripts, they couldn't use the PATH for some reason :-/
12:56:07 <_Mikey> @hoogle Int->IO()
12:56:07 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
12:56:07 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
12:56:07 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
12:56:17 <_Mikey> I'm going to miss you lambdabot :)
12:57:04 <elliott> lambdabot is going away?
12:57:18 <monochrom> she's graduating
12:57:26 <_Mikey> no, no, I'm just getting hoogle in my terminal
12:57:39 <monochrom> and she has landed a high-pay job in Wall Street
12:57:59 <_Mikey> in this climate she won't keep it long ;p
12:58:16 <elliott> _Mikey: you can add command-line hoogle to ghci, too
12:58:32 <elliott> don't ask me how though
13:00:19 <Phlogistique> http://sprunge.us/hTeh I suppose it has been done countless times before, but this is a pretty cool haskell hello world
13:00:40 <_Mikey> I was just about to :D
13:01:31 <elliott> Phlogistique: ha
13:01:38 <monochrom> yikes
13:01:42 <elliott> _Mikey: http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
13:01:42 <sully> k
13:01:44 <_Mikey> ehttp://www.haskell.org/haskellwiki/GHC/GHCi#Hoogle
13:01:45 <sully> argh
13:01:48 <_Mikey> damn
13:01:49 <_Mikey> :p
13:01:52 <elliott> haha
13:01:55 <Sgeo> ehttp?
13:02:10 <_Mikey> I was about to start typing elliot
13:02:13 <_Mikey> t
13:02:53 <_Mikey> elliott, cheers for the heads up!
13:11:57 <_Mikey> wow
13:12:10 <_Mikey> command line hoogle is amazing
13:16:36 <copumpkin> byorgey: will the quote for lifting data constructors to the type level ever go away? :)
13:16:49 <Sgeo> What quote?
13:17:00 <byorgey> copumpkin: well, there has to be *some* method for disambiguation
13:17:16 <copumpkin> byorgey: if it's used in a typey position, it's a type :P
13:17:17 * elliott would rather see the implicit insertion of the quote gone
13:17:36 <byorgey> copumpkin: the problem is that types and data constructors can have the same name
13:17:37 <elliott> at least someone told me that you only have to use it in cases of ambiguity
13:17:40 * Sgeo doesn't even know what the quote is
13:17:45 <copumpkin> byorgey: true, dammit
13:17:48 * copumpkin shakes his head
13:17:59 <cheater_> hello
13:18:00 <byorgey> elliott: correct
13:18:03 <elliott> copumpkin: doesn't that address your complaint, then?
13:18:08 <elliott> if you don't introduce ambiguity :P
13:18:11 <Sgeo> Oh, for a dependently typed language?
13:18:19 <cheater_> copumpkin: tell us what the quote is or i will bite your head off!
13:18:21 <Sgeo> I was thinking along the lines of something someone said
13:18:22 <copumpkin> yes, and has now made me annoyed that haskell has two namespaces
13:18:22 * elliott would have the quote required all the time, and just do "type Foo = 'Foo" if he wanted it gone
13:18:23 <byorgey> Sgeo: yes, Haskell
13:18:43 <byorgey> elliott: ugh!
13:18:45 * Sgeo blinks
13:19:08 <elliott> byorgey: sorry, but it's nicer than implicitly unifying two separate namespaces with an explicit disambiguation :)
13:19:14 <byorgey> this is for the new feature in GHC 7.4 that lets you lift certain data types to the kind level
13:19:26 <byorgey> elliott: well, I'll grant it's more elegant
13:19:32 <byorgey> but I would be more annoyed by it in practice
13:19:34 <qpu> can't seem to find it, but i read a paper that discussed implicitly defining kinds based on types, and types from data constructors
13:19:59 <elliott> byorgey: what if there was a declaration that took a bunch of constructor names and defined lifted synonyms? I guess picking a keyword is the hard part...
13:20:09 <byorgey> qpu: yes, that's what we were just discussing.  http://www.cis.upenn.edu/~byorgey/pub/promotion.pdf
13:20:12 <elliott> e.g. "tylift Zero Succ", "tylift Nil Cons"
13:20:13 <c_wraith> qpu: byorgey was one of the authors of that paper
13:20:21 <qpu> byorgey: ah, thanks! that's the one :]
13:20:31 <Sgeo> So, turning Haskell into a dependently-typed language?
13:20:38 <c_wraith> not fully.
13:20:40 <c_wraith> Just a little
13:20:59 <copumpkin> Sgeo: no
13:21:24 <byorgey> it turns Haskell into something that acts a bit more like a dependently typed language in some ways, but still isn't.
13:21:29 <mm_freak> is that really a problem?  just make sure your constructors don't clash with other defined types
13:22:01 <elliott> most newtypes already "clash" like that. but then again you won't want to use them on the type level usually
13:22:11 <elliott> well... does Mu lift correctly? :P
13:22:51 <mm_freak> elliott: a type cannot clash with itself
13:23:18 <elliott> mm_freak: huh?
13:23:22 <elliott> yes, because
13:23:23 <mm_freak> or can they?
13:23:25 <elliott> newtype T = T x
13:23:29 <elliott> at the type-level, T is the type T
13:23:34 <elliott> but it's also the lifted constructor T
13:23:37 <mm_freak> you're right
13:23:38 <elliott> so you have to do 'T for the latter
13:23:39 <mm_freak> sorry
13:23:46 <mm_freak> i see
13:24:24 <mm_freak> would dependent types require a change in language semantics?
13:24:36 <elliott> every change is a change to language semantics
13:24:49 <elliott> (not being obtuse, I honestly don't know what you're trying to ask)
13:24:51 <mm_freak> i mean a fundamental one that would break a lot
13:25:15 <mm_freak> i remember people arguing that adding dependent types to haskell would change the language too much
13:25:24 <elliott> well, probably not
13:25:34 <elliott> well hmm
13:25:41 <mm_freak> but on the other hand i see idris, which is really just a simplified haskell with dependent types
13:25:41 <elliott> i guess you'd run into problems with typechecking becoming undecidable
13:25:45 <elliott> but we already have that with UndecidableInstances
13:25:56 <mm_freak> i don't use that extension usually
13:26:01 <elliott> but all existing code could continue to work, I think -- but it'd be a *very* different language under the hood
13:26:02 <cmccann> adding various GHC extensions to haskell changes the language too much
13:26:08 <cmccann> that's why they're extensions
13:26:14 <elliott> even if it retains compatibility with existing programs
13:26:19 <elliott> they'd "mean" different things
13:26:35 <elliott> (I love putting quotes around random words so nobody can disagree with me!)
13:26:57 <mm_freak> i guess the question is:  can you add dependent types as a pure addon, such that enabling the corresponding extension wouldn't break anything per se?
13:27:06 * cmccann "disagrees" with elliott
13:27:21 <elliott> cmccann: Well, you're "wrong".
13:27:30 <elliott> "cmccann:"
13:27:33 <cmccann> heh
13:27:40 <mm_freak> {-# LANGUAGE DependentTypes #-}
13:27:44 <mm_freak> how cool would that be…
13:27:46 <_oz> mm_freak: I think one of the biggest changes would be losing type inference
13:27:53 <elliott> _oz: um
13:27:59 <elliott> hate to break it to you, but ghc passed that step a *long* time ago
13:28:06 <mm_freak> _oz: do you really lose it unconditionally?
13:28:12 <elliott> Rank2Types? there goes type inference
13:28:18 <parcs`> > id runST (return ())
13:28:19 <lambdabot>   Couldn't match expected type `m ()'
13:28:20 <lambdabot>         against inferred type `forall s...
13:28:23 <byorgey> no, for example, Agda does a fairly good job of type inference
13:28:26 <elliott> > (id runST) (return ())
13:28:27 <lambdabot>   ()
13:28:42 <elliott> {-# LANGUAGE SemanticallyMeaningfulParens #-}
13:28:43 <_oz> mm_freak: I am not sure, but I think so.
13:28:46 <byorgey> but type inference does become much more difficult
13:28:46 * monochrom nests quotes so people cannot "disagree with me when they cannot "disagree with me""
13:28:55 <mm_freak> elliott: i guess _oz means losing type inference the way you have it in agda
13:28:58 <cmccann> does Agda even do type inference? I thought it just filled in obvious stuff
13:29:02 <elliott> mm_freak: fair enough
13:29:10 <copumpkin> cmccann: its notion of obvious is extremely sophisticated
13:29:14 <elliott> cmccann: it has value inference :)
13:29:18 <mm_freak> agda can infer a lot, but it's not like in haskell, where you can write entire programs without type signatures
13:29:31 <elliott> Is Agda better at filling in the blanks than Coq?
13:29:33 <Duffman-> what's an easy way to make a string out of a char? I need it to convert it here: typeParser = do t <- many1 alphaNum <|> (char '*')
13:29:38 <elliott> Coq's implicit parameters scare me, they're just so wild.
13:29:44 <elliott> Duffman-: [c]
13:29:47 <byorgey> Duffman-: if c is a Char, then [c] is a String
13:29:48 <elliott> > ['x']
13:29:49 <lambdabot>   "x"
13:29:55 <elliott> in function form: (:[]) or pure or return
13:29:59 <Duffman-> yes
13:30:02 <elliott> for pure, needs import Control.Applicative
13:30:08 <elliott> > (:[]) 'x'
13:30:09 <lambdabot>   "x"
13:30:11 <elliott> > return 'x' :: String
13:30:12 <lambdabot>   "x"
13:30:13 <copumpkin> or just use the string combinator
13:30:15 <copumpkin> instead of the char one
13:30:19 <mm_freak> Duffman-: if you want something more functiony, use any of '(:[])', 'pure' or 'return'
13:30:19 <elliott> or that
13:30:21 <copumpkin> and hand it a one-character string
13:30:27 <mm_freak> i'd probably use 'return'
13:30:35 <Duffman-> yeah thx
13:30:37 <elliott> Duffman-: yeah, string "*" then :p
13:31:08 <mm_freak> but anyway, that doesn't really answer my question…  is there a fundamental reason for not adding dependent types to haskell?
13:31:28 <mm_freak> (disregarding implementation complexity)
13:31:43 <elliott> mm_freak: well, dependent types aren't all pro
13:31:52 <aristid> mm_freak: dependent types, but not totality?
13:32:08 <elliott> mm_freak: one problem is that you have to be careful with type-level computations
13:32:15 <elliott> if it's not total, you can probably implement unsafeCoerce
13:32:20 * cmccann vaguely recalls there being potential issues with non-total functions and dependent types
13:32:25 <mm_freak> aristid: do you need totality for dependent types?
13:32:30 <elliott> cmccann: well _|_ proves everything
13:32:33 <elliott> so you can't do any kind of proving
13:32:39 <aristid> mm_freak: i don't think so, but i'm not sure either :)
13:32:43 <elliott> but most of the advantages of dependent types come from being able to prove things
13:32:46 <mm_freak> elliott: huh?  how?
13:32:49 <elliott> and erase that at runtime
13:33:10 <monochrom> the fundamental reason was that they just wanted a functional language
13:33:11 <cmccann> elliott, right, but I mean things worse than _|_ already is, like unsafeCoerce
13:33:13 <elliott> mm_freak: well, it's OK if you always keep proofs around at runtime and force them before "eliminating" them
13:33:21 <elliott> like, if you have _|_ :: Eq Int String
13:33:26 <elliott> coerce :: Eq a b -> a -> b
13:33:30 <mm_freak> i wouldn't want to turn haskell into a total language…  unless coinduction becomes easier to understand
13:33:36 <elliott> coerce is only safe if it forces its first argument, which means that Eq _cannot_ be erased at runtime
13:33:42 <elliott> unlike in a total language
13:33:43 <mm_freak> i failed badly at writing coinductive code in agda
13:33:51 <elliott> where you could just discard the first argument completely
13:34:33 <elliott> really though, dependent types would "obsolete" about 90% of haskell extensions
13:34:41 <elliott> there's no real point to adding them to haskell specifically
13:34:47 <mm_freak> would they?
13:34:51 <elliott> yes
13:34:54 <elliott> GADTs? subsumed
13:34:58 <elliott> RankNTypes? subsumed
13:35:14 <mm_freak> and that's about where the list ends =)
13:35:23 <elliott> TypeFamilies?
13:35:37 <mm_freak> no, type families wouldn't be obsoleted
13:35:45 <c_wraith> yeah, type families are just functions on types
13:35:54 <c_wraith> which in a dependently-typed language, are just called "functions"
13:36:01 <elliott> yeah but you can define clauses across modules
13:36:01 <mm_freak> although with dependent types you could have actual type functions
13:36:05 <elliott> ...so you'd need more-notation</injoke>
13:36:24 <copumpkin> c_wraith: except you can't pattern match on types
13:36:27 <elliott> also that
13:36:35 <copumpkin> c_wraith: you'd need to build a custom universe of types for something like type families
13:36:36 <elliott> copumpkin: you just need Typeable :D
13:36:52 <mm_freak> idris emphasizes that it's not a dependently typed language…  it's a language with dependent types
13:37:00 <mm_freak> i could totally see haskell go in that direction
13:37:14 <copumpkin> luckily, idris already looks like it's haskell with dependent types
13:37:16 <ddarius> Dependent types have nothing to do with rank-n types.
13:37:49 <elliott> ddarius: Well, dependent types will already bring in rank-n types
13:38:12 <mm_freak> perhaps i'm just jealous…  ur/web has them, but haskell doesn't =)
13:38:25 <elliott> ur/web does not have dependent types
13:38:31 <gienah> my wish for haskell is type level records like in Ur
13:38:32 <lambdabot> gienah: You have 1 new message. '/msg lambdabot @messages' to read it.
13:38:47 <elliott> mm_freak: amusingly, that goes directly against your point, as ur is another "almost dependent types" scenario :)
13:38:51 <elliott> like ATS or Omega or whatever
13:38:57 <mm_freak> really?
13:38:59 <copumpkin> (and haskell, now)
13:39:01 <copumpkin> :P
13:39:01 <Saizan> cmccann: you get unsafeCoerce if you want to erase proof terms
13:39:11 <mm_freak> i thought ur/web has dependent types…  at least the author claimed that
13:39:12 <elliott> copumpkin: yep
13:39:26 <ntyp> how independed is a compiled haskell file?
13:39:32 <ntyp> +n
13:39:35 * copumpkin writes a GHC rewrite rule that all values of an equality type are Refl
13:39:41 <elliott> ntyp: what do you mean by independent?
13:39:51 <gienah> the type level records in Ur look really cool for meta programming web and database stuff
13:39:56 <elliott> copumpkin: hmm, I wonder if that works
13:40:01 <elliott> RULES + GADTs = unsafeCoerce
13:40:02 <ntyp> do i need anything to ship a compiled haskell file out and run it on windows or linux?
13:40:05 <copumpkin> elliott: don't see why not, but don't lie
13:40:09 <mm_freak> ntyp: depends on how you link
13:40:18 <elliott> ntyp: well, there's the gmp dependency
13:40:19 <mm_freak> ntyp: under windows you're probably safe, but i'd try it out
13:40:23 <elliott> but you could link statically
13:40:35 <elliott> mm_freak: on windows you're probably _not_ safe, I would think? I'd expect to have to bundle a gmp dll
13:40:41 <mm_freak> ntyp: under linux the story is a bit more complicated…  what elliott said
13:40:53 <elliott> ntyp: but there's no "ghc runtime shared library"... at least, not by default
13:41:03 <mm_freak> elliott: can't confirm that, but the last GHC i used under windows was 6.12.*
13:41:24 <ntyp> lets say i'll develop an application with buildin features. can i ship the exe or bin out without any other files and can i be sure it runs?
13:41:41 <elliott> ntyp: we just answered that :)
13:41:47 <mm_freak> ntyp: to answer your question, certainly there are options to do that
13:41:47 <elliott> depends on the platform and how you link
13:41:51 <ntyp> ok, than it depends on the linking
13:41:58 <ntyp> thanks for your help
13:42:00 <mm_freak> ntyp: so you can give away binaries
13:42:06 <elliott> ntyp: -optl-static -optl-pthread should do it
13:42:08 <elliott> when you link
13:42:11 <elliott> on linux at least
13:42:26 <ddarius> elliott: No.  Dependent types do not imply rank-n types.
13:42:46 <MightyMo1se> \quit
13:42:48 <mm_freak> i think the confusion is that "forall" and type-lambda are not the same thing
13:43:07 <elliott> ddarius: Well, OK.
13:43:22 <elliott> But -XDependentTypes wouldn't be very useful without an "unrestricted" forall :)
13:43:34 <mm_freak> elliott: why not?
13:44:02 <antilect> Holy ####! Us dept of justice just took down the entire MEGAUPLOAD :O
13:44:05 <elliott> mm_freak: Well, you couldn't "depend".
13:44:09 <elliott> I guess you could have the dependent function arrow and not unify that with forall quantification...
13:44:15 <antilect> Unrelated, sorry, but that is a monumental event in history.
13:44:57 <mm_freak> elliott: why not?  you need type-lambda for dependent types, not forall
13:45:10 <mm_freak> at least not a higher rank forall
13:45:39 <elliott> mm_freak: printf :: (x :: String) -> blah x
13:45:46 <elliott> mm_freak: id :: (a :: *) -> a -> a
13:46:31 <elliott> If you have the dependent function arrow, you have quantification
13:47:12 <mm_freak> you always have quantification, when you have type variables
13:47:32 <ddarius> elliott: Only if * is a type, i.e. * :: *.
13:47:57 <elliott> ddarius: Well, OK (I was imagining :: to work with a hierarchy like Coq or Agda).
13:48:00 <ddarius> Even then the result is different from rank-n types (as well as being unsound.)
13:49:25 <ddarius> In the face of allowing Turing-complete calculations, it's not unreasonable to adopt the * :: * axiom.
13:52:01 <mm_freak> ddarius: in agda terms that would mean Set : Set, right?
13:53:27 <ddarius> mm_freak: Yes.
13:54:10 <mm_freak> ddarius: just guessing here, would that make universes unnecessary?
13:54:57 <mm_freak> [Set, Nat -> Set] : [Set]
13:55:29 <cmccann> bertrand russell is probably spinning in his grave right now
13:55:42 <mm_freak> hehe
13:56:34 <elliott> cmccann: Isn't it Girard? :)
13:58:28 <ddarius> mm_freak: Yes.
13:58:48 <mm_freak> cmccann: russell came up with the barber paradox
13:59:03 <mm_freak> or why Set : Set is unsound
14:02:15 <DanBurton> just got a fresh ghc 7.0.4 install on my lab computer...what are some good libraries to cabal install?
14:02:42 <mm_freak> DanBurton: for what purpose?
14:02:48 <cmccann> DanBurton, all of them
14:02:50 <geekosaur> depends; what do you want to do with it?
14:02:58 <cmccann> install all of hackage
14:03:00 <DanBurton> I'm just a hobbyist Haskell programmer
14:03:02 <elliott> cabal install '*'
14:03:04 <srhb`> Ooooh, no, this is a question for your favourite library!
14:03:13 <DanBurton> so nothing serious
14:03:14 <elliott> cmccann++
14:03:16 <donri> DanBurton: haskell-platform. what OS?
14:03:37 <DanBurton> donri: ubuntu 10.4, and I did get a fresh haskell platform as well :)
14:03:50 <c_wraith> DanBurton: I just install 'em when I need 'em.
14:03:58 <donri> oh, that one has old shite, are you using a ppa?
14:04:03 <elliott> I wonder how large a subset of Hackage actually builds.
14:04:04 <acowley> alternate extremism: only install cabal-dev
14:04:09 <mm_freak> DanBurton: i always install arrows, data-lens, lifted-base, logict, pandoc, stm, mtl, vector and vector-space
14:04:18 <mm_freak> those are very useful general purpose libraries
14:04:31 <mm_freak> except perhaps STM, which is a bit more special-purpose
14:04:47 <DanBurton> mm_freak: what exactly is lifted-base?
14:04:56 <elliott> STM is more general-purposed than pandoc.
14:05:00 <elliott> *no d
14:05:16 <mm_freak> DanBurton: what used to be monad-control is now a set of packages, monad-control being at their base
14:05:26 <DanBurton> acowley: as a hobbyist, I don't find cabal-dev particularly useful
14:05:34 <mm_freak> lifted-base basically gives you MonadControlIO back, but calls it MonadBaseControl IO
14:06:05 <donri> DanBurton: i would first upgrade ubuntu and then apt-get libghc*
14:06:06 <elliott> DanBurton: Hobbyists don't mind running into dependency hell and having to reinstall everything?
14:06:25 <mm_freak> elliott: does that happen to you?
14:06:27 <elliott> That must mean I'm getting paid for this :)
14:06:38 <acowley> DanBurton: I wouldn't seriously recommend a hobbyist going straight for cabal-dev as it does test one's patience. But once you start checking out some big libraries (e.g. web stacks), you will likely run into problems.
14:06:40 <elliott> mm_freak: Yes. Albeit not usually nowadays, I think it was worse a few years ago.
14:06:42 <DanBurton> elliott: well that has happened once or twice trying to install lambdabot and yesod
14:06:57 <donri> make that libghc-.* because apt-get uses regexps
14:07:01 <mm_freak> yeah, a few years ago i'd totally understand your pain =)
14:07:02 <DanBurton> lambdabot was fun
14:07:25 <akosch> DanBurton: it's not a library, but I like hlint
14:07:35 <donri> ah hlint, hoogle too
14:07:46 <akosch> DanBurton: hoogle, if you're offline sometimes ;)
14:07:47 <DanBurton> ah good thinking
14:07:59 <acowley> I still run into issues with QuickCheck sometimes, and recently I was fighting with Text versions
14:08:04 <mm_freak> ah
14:08:07 <mm_freak> and lazysmallcheck
14:08:17 <mm_freak> great library especially for quick-n-dirty manual testing
14:09:01 * DanBurton wonders why darcs isn't in HP
14:09:10 <DanBurton> also hlint
14:09:16 <mm_freak> it isn't?
14:09:16 <acowley> I would also recommend criterion as it's fantastic, but that's one that's given me version headaches in the past, too.
14:09:17 <elliott> Darcs? Seriously?
14:09:36 <elliott> I mean, nothing against darcs, but I don't see why the Platform should build an end-user program (not a library) that isn't even very popular these days.
14:09:43 <elliott> s/build/bundle/
14:10:11 <mm_freak> dunno, i just can't bring myself to use git
14:10:17 <mm_freak> i love the simplicity of darcs
14:10:37 <elliott> like I said, nothing against darcs :) it'd just be really weird for the HP to include it
14:10:45 <mm_freak> it's about the first VCS i've seen that actually cares about usability
14:10:51 <elliott> HP doesn't include an editor, either, and that's essential too
14:11:03 <mm_freak> dunno, the haskell platform is for developers…  by the same argument it shouldn't include cabal-install
14:11:07 <elliott> I guess it'd make sense on Windows where HP bundles gcc etc.
14:11:15 <elliott> yeah, but cabal-install is haskell-related
14:11:19 <elliott> darcs just happens to be written in haskell
14:11:21 <donri> but cabal-install is specifically for haskell
14:11:25 <donri> yea
14:11:26 <geekosaur> um, ghc is for developers.  your point?
14:11:26 <mm_freak> good point
14:11:46 <donri> should HP include yi? :)
14:11:54 <DanBurton> trying to cabal install darcs...it can't find curl even though I have it installed T_T
14:11:54 <mm_freak> no, it should include emacs =P
14:12:11 <DanBurton> we should rewrite emacs in Haskell
14:12:14 <elliott> HP should include the intersection of vi and emacs to avoid flamewars
14:12:17 <elliott> also, to avoid usability
14:12:19 <donri> yi is kinda emacs in haskell
14:12:23 <mm_freak> DanBurton: we've tried that already…  the result is called yi
14:12:39 <DanBurton> leksah builds off of yi, correct?
14:12:44 <akosch> mercurial is quite pleasant, I prefer it to darcs and git
14:12:48 <elliott> no (to my knowledge)
14:13:10 <geekosaur> "yi is kinda emacs in haskell" --- wait, I thought it was *vi* for haskell (hence the name.  early versions were certainly based on vi's UI)
14:13:11 <monochrom> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg11944.html
14:13:14 <mm_freak> akosch: heard that from a number of people now…  i'll give it a try when necessary, but for now i'm still happy with darcs =)
14:13:30 <donri> yi can mimic either
14:13:31 <elliott> geekosaur: as emacs fans like to point out incessantly, emacs' UI is a very small part of it :)
14:13:50 <Jafet> Isn't the intersection of vi and emacs vi?
14:13:59 <ivanm> geekosaur: in the sense that you can customise it, it's like emacs
14:14:11 <ivanm> mm_freak: agreed
14:14:14 <elliott> Jafet: Only if M-x <whatever the most popular vi emulation mode is these days><RET> is a nop in vi.
14:14:22 <Jafet> (`intersection` emacs) = id
14:14:25 <geekosaur> Jafet, ecept when it's vim with all the trimmings :)
14:14:44 <akosch> mm_freak: I haven't used darcs much, so I may not be the best person to judge :)
14:15:08 * geekosaur was amused when fedora's vim binary was bigger than its emacs :)
14:15:14 <monochrom> haha
14:15:24 <akosch> mm_freak: but only positive experiences with mercurial so far (bitbucket it also neat). also it has a really short alias (hg)
14:15:39 <elliott> alias da=darcs
14:15:47 <elliott> alias d=darcs # now darcs is even better
14:15:52 <donri> alias g=git
14:16:00 <donri> + loads of aliases defined in git
14:16:02 <acowley> better to have an alias that runs your vcs automatically
14:16:07 <akosch> i was just joking ;)
14:16:15 <mm_freak> actually i just type "darcs" even without completion, because it's just so easy to type
14:16:16 <Jafet> git init /
14:16:17 <c_wraith> you really only need one exponential merge in darcs before you start looking at alternatives
14:16:31 <elliott> I thought darcs 2 mostly solved that
14:16:40 <mm_freak> completing would actually take longer, because completion is a complex process for the brain and makes you slower if overused
14:16:41 <ivanm> elliott: mostly solved
14:16:46 <ivanm> but I've never run one
14:16:49 <ivanm> *into one
14:16:54 <elliott> I guess "mostly" is the keyword
14:17:09 <gwern> > 37.63754920 * 6.25
14:17:10 <lambdabot>   235.23468250000002
14:17:13 <monochrom> http://www.gnu.org/fun/jokes/ed.msg.html
14:17:19 <Jafet> Or map capslock to darcs
14:17:44 <elliott> capslarcs
14:17:45 <mm_freak> Jafet: there are people who map caps lock to escape for vi, which is actually quite reasonable
14:17:51 <elliott> monochrom: I was waiting for that to come up
14:18:05 <Jafet> Well, you'd do that by swapping escape and capslock
14:18:10 <donri> i swap caps and esc desktop-globally
14:18:10 <Jafet> So you still have a capslock
14:18:12 <monochrom> did you also see my http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg11944.html ? :)
14:18:17 <donri> it's reasonable for more than just vim
14:18:22 * elliott updates the notice: It has been [0] days since the last person linked to "Ed, man! !man ed".
14:18:22 <conal> what flag let one ghc-compile & link a module other than Main to get an executable?
14:18:23 <acowley> I bet there are a bunch of people working on Kinect-driven text editors
14:18:34 <acowley> semaphore will make a comeback
14:18:35 <geekosaur> --main-is?
14:18:36 <elliott> conal: -main-is
14:18:42 <elliott> -main-is Foo.main I think
14:18:52 <geekosaur> yeh, one too many -s there
14:18:54 * cmccann suggests ---main--is--dash-
14:18:57 <geekosaur> consistency, what a concept
14:19:05 <elliott> -main-isn't
14:19:12 <elliott> just list every module your main _isn't_ and it'll figure out the rest
14:19:18 <cmccann> -main-was
14:19:30 <acowley> -main-will-be
14:19:31 <elliott> -main-might-be (for quantum bogosort implementations)
14:19:40 <elliott> That's two quantum bogosort-related innovations today!
14:19:41 <conal> elliott: hrmf. i'm trying exactly that, and I get a link error: "In function `main': Main.c:(.text+0x1): undefined reference to `ZCMain_main_closure'"
14:19:46 <elliott> conal: --make?
14:19:51 <elliott> hmm i guess not
14:20:04 <conal> elliott: yeah. i'm using --make also
14:20:06 <conal> hm
14:20:15 <elliott> maybe try without --make :P
14:20:22 <conal> okay
14:20:34 <acowley> conal: do you explicitly export the main value from your module?
14:20:54 <elliott> conal: this might help: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#options-linker
14:21:04 <elliott> (-main-is is a bit further down from that anchor)
14:21:14 <elliott> "However, if all the modules are otherwise up to date, you may need to force recompilation both of the module where the new "main" is, and of the module where the "main" function used to be; ghc is not clever enough to figure out that they both need recompiling. You can force recompilation by removing the object file, or by using the -fforce-recomp flag."
14:22:42 <Sgeo> o.O at conal having trouble with something
14:22:58 <conal> acowley: i wasn't exporting main explicitly but now am, with the same link-time error message
14:24:37 <conal> elliott: -fforce-recomp did indeed fix the linker problem. hm!
14:24:38 <elliott> conal: you might want to try a clean build per ^
14:24:40 <elliott> ah
14:24:48 <elliott> that's good :)
14:24:49 <acowley> conal: That's the one I usually leave out, but I think it's time to try a clean rebuild (if you haven't already)
14:24:54 <acowley> oh
14:24:59 <elliott> hehe
14:25:39 <conal> and now when i tweak the main module (not called "Main") and re-run *without* -fforce-recomp, no linker error.
14:25:56 <conal> just some awkward state issue, i guess.
14:26:00 <elliott> "you may need to force recompilation both of the module where the new "main" is, and of the module where the "main" function used to be"
14:26:09 <elliott> i guess the problem is that you didn't recompile Main.hs or whatever
14:26:22 <elliott> (which is a really weird thing to have to do...)
14:27:02 <monochrom> because both *.o files claim to have main
14:27:28 <elliott> oh, does ghc basically rename the module you specify as main to Main behind the scenes?
14:27:38 <monochrom> I don't actually know
14:30:04 <mm_freak> when i have that linker error, it's usually related to me having forgot to add a module in the .cabal file
14:30:27 <kqr> what is the official take on tuples vs user defined types in haskell? i find in almost any case a tuple should be a data type of its own. is that most often the case or am i missing something?
14:30:35 <elliott> usually
14:30:40 <elliott> but consider e.g. the state monad
14:30:41 <ivanm> yup
14:30:46 <elliott> s -> (a, s)
14:30:48 <kqr> yeah
14:30:51 <elliott> it would be unreasonable to define a new data type there :)
14:30:56 <kqr> yeah thanks
14:31:00 <ivanm> kqr: if you're just returning two values, use a tuple
14:31:05 <elliott> tuples are useful when you're just bundling two pieces of data together, usually polymorphic or whatever
14:31:10 <mm_freak> kqr: tuples are also used a lot when programming with arrows and sometimes with applicative functors
14:31:10 <elliott> data types are when you're actually representing something
14:31:17 <ivanm> if it's a common grouping, especially in an exposed function, use a data type
14:31:27 <mm_freak> kqr: because the data type you would invent there you would call "Tuple" =)
14:31:30 <ivanm> data types can also be more efficient in my experience
14:32:21 <kqr> i'm just making a short series of introductory texts on haskell, and as i'm trying to focus on ingraining how expressive the type system really is, i'm thinking of not doing tuples very early, replacing them with custom data structures
14:32:25 <kqr> types*
14:32:41 <sshine> in Standard ML, I dislike using records, but in Haskell they are syntactically neat.
14:32:51 <elliott> tuples before data types imo
14:32:54 <akosch> what kind of uploads are encouraged on hackage? I mean I've written a small app using the SDL bindings to be able to start movies with my remote (lirc) and to be able to read BBC news in an ugly, large green font. The code is messy, but hey... it works.
14:32:56 <acowley> use tuples
14:33:03 <kqr> okay
14:33:05 <elliott> they're a good example of a simple polymorphic data type
14:33:06 <kqr> any specific reason?
14:33:09 <Axman6> sshine: really? records are generally regarded as one of the least well implemented parts of haskell
14:33:19 <elliott> and you can use them from ghci directly
14:33:22 <elliott> rather than having to load a fil
14:33:23 <elliott> e
14:33:40 <Axman6> akosch: things with clean code, that other people may find useful
14:33:45 <acowley> kqr: because your audience will encounter them a lot, and they can serve as a generic foundation to your own data types
14:33:50 <kqr> the not loading a file thing is not a concern
14:33:53 <kqr> acowley, yeah, great point
14:33:55 <mm_freak> kqr: tuples are a very common type, so people should understand them…  i don't think you can get very far in haskell without knowing tuples
14:33:59 <sshine> Axman6, I'm just saying I like automatic getters and setters, but I suppose they're not particularly combinator-like.
14:34:05 <akosch> Axman6: clean code would be a bit of an overstatement for my project
14:34:08 <elliott> kqr: also you can go "now that we've seen tuples, we can define our own data types just like them"
14:34:09 <elliott> or whatever
14:34:19 <akosch> Axman6: let's call it a "project" :)
14:34:21 <elliott> show a specific example before introducing the general notion etc.
14:34:35 <sshine> Axman6, do you mean compared with lenses?
14:34:38 <Axman6> akosch: unfinished projects should go on github or somewhere similar
14:34:50 <kqr> elliott, to me, tuples are more like the specific example of an anonymous type
14:34:51 <acowley> kqr: I'd actually say you might as well explicitly bump into the problem with tuples (*too* generic) to motivate the creation of user defined data types
14:34:52 <Axman6> sshine: i mean they're just generally ugly, with many flaws
14:34:55 <elliott> akosch: if it's an app that could be useful to anyone else, sure, upload it
14:35:04 <mm_freak> kqr: they're not at all anonymous
14:35:06 <elliott> kqr: well... it's good to introduce tuples because, ilke
14:35:10 <elliott> kqr: Maybe, Either, (,)
14:35:16 <elliott> showing data structures being built out of simpler parts
14:35:16 <mm_freak> (,) is the type constructor and (,) is the data constructor
14:35:26 <kqr> yeah
14:35:27 <elliott> you wouldn't introduce
14:35:30 <mm_freak> elliott: replace Maybe by ()
14:35:30 <acowley> In death, a tuple has a name. It's ,
14:35:31 <kqr> i'll go for tuples
14:35:34 <elliott> data Result = NoMatch | AMatch Int
14:35:37 <elliott> before Maybe
14:35:49 <elliott> mm_freak: naw, Maybe should come before Either () :P
14:35:55 <akosch> elliott: I think Axman6 could be right with some VCS site
14:36:05 <monochrom> suppose you have "module M where main=...". then M.o has M_main_info as expected, whether -main-is or not. if you have -main-is M, then M.o has in addition ZCMain_main_info. apparently, the runtime only knows to call ZCMain_main_info (or ZCMain_main_closure, whatever)
14:36:08 <elliott> akosch: yeah, possibly
14:36:15 <akosch> elliott: it's better for a start, I'm not even sure it builds on windows
14:36:20 <mm_freak> elliott: () was the very first type i introduced, after which i talked about Bool
14:36:28 <elliott> mm_freak: oh, well, yeah, sure
14:36:36 <elliott> mm_freak: I was listing type constructors
14:36:43 <mm_freak> it worked quite well…  and i really took well ten minutes to explain those two types =)
14:36:46 <elliott> i.e. how to compose types into more elaborate ones
14:36:57 <elliott> of which Maybe -> Either -> (,) is a reasonable progression
14:37:05 <mm_freak> well, for that composition,  (), Either and (,) are good choices
14:37:07 <monochrom> if you previously did -main-is M, and now you do -main-is K, then both M.o and K.o contains ZCMain_main_info/closure
14:37:24 <mm_freak> i wouldn't include Maybe in that set, because Maybe = Either ()
14:37:47 <elliott> mm_freak: yes, but Maybe is the simplest possible type constructor in a sense
14:37:49 <elliott> apart from Identity :)
14:37:54 <elliott> and it has readily-obvious applications
14:38:02 <elliott> then Either is just a simple generalisation of Maybe in a way
14:38:12 <elliott> Either is more complex and harder to see obvious uses for at first
14:38:22 <akosch> also, it's a bit convoluted. I doubt anyone would find a parser for a hungarian online tv-guide useful
14:38:24 <ddarius> Bool -> a
14:38:26 <mm_freak> i see your point…  it's just questionable whether your audience can really understand types in terms of other types with that set of base types =)
14:38:29 <elliott> monochrom: right, so ghc basically makes a Main.main pointing to the right place
14:38:51 <elliott> mm_freak: well, I didn't specify any base types :) -- but if you're introducing tuples, then you're already introducing composite types like that
14:38:58 <elliott> well, "tuples or custom data types"
14:39:06 <elliott> so you already have some foundation to start building on
14:39:13 <elliott> or should, at least
14:39:36 <mm_freak> i wonder whether you need an empty type…  for the ring-like structure of type composition it appears to me like you want a zero type, too
14:39:49 <mm_freak> not just a unit type
14:39:57 <elliott> in an introduction to haskell? i doubt it :p
14:40:02 <hpc> mm_freak: you mean like Category? :P
14:40:06 <mm_freak> no ;)
14:40:09 <mm_freak> hpc: huh?
14:40:15 <mm_freak> Category is a class
14:40:17 <elliott> but ofc (,) and () are related in the same way that Either and Void are
14:40:26 <hpc> data f :. g = ...
14:40:28 <elliott> (which generalised arrows uses to define Arrow and ArrowChoice with the same class)
14:40:34 <hpc> data id f = Id f
14:41:10 <monochrom> C++ has pair<a,b> for our (a,b)
14:48:26 <mm_freak> in haskell there are three levels:  value level, type level and kind level…  when talking about that i often say that "haskell has three levels"
14:48:36 <mm_freak> is there a better or more specific term for that "levels"?
14:48:50 <ddarius> Sorts.
14:49:09 <mm_freak> "haskell has three sorts"?
14:49:12 <elliott> in mm_freak's discussion of haskell there are four levels: value sort, type sort, kind sort, and sort sort
14:49:24 <elliott> Now mm_freak has four problems :)
14:49:32 <elliott> *four sorts
14:51:15 <monochrom> when confronted with the problem of n levels, some people say, "I know, I will add 1 more level". now they have the problem of n+1 levels.
14:52:11 <Phlogistique> Every programming problem can be solved with another layer of abstraction, except the problem of too many layers of abstraction
14:52:18 * elliott balances the desire to @remember that with the desire to not credit people for stealing his jokes :)
14:52:28 <Saizan> if you saw it as a PTS it'd have two sorts * and what's usually written with a square which would be the type of every kind
15:06:38 <ddarius> monochrom: You completely missed arranging bundling with Dell.
15:19:28 <benmachine> http://www.haskell.org/haskellwiki/User:Benmachine/Cont comment appreciated
15:20:34 <vurlybra1e> @botsnack
15:20:34 <lambdabot> :)
15:20:56 <benmachine> padmee seems to be automatically messaging people
15:21:09 <benmachine> when they first enter
15:21:13 <benmachine> 00:07:50 <padmee> would you like to join #calculus and ##bourbaki
15:21:50 <elliott> not automatically
15:21:56 <elliott> oh, depends on your definition of first I guess
15:22:21 <elliott> benmachine: "I think it's just a way to give a name to the "tail" of a do-block." -- yeah, but not really, because it extends /past/ the do block
15:22:34 <elliott> if contstuff is used in a larger computation, the continuation includes everything after it, too
15:22:37 <benmachine> elliott: yes I know
15:22:38 <benmachine> but
15:22:44 <benmachine> I like the mental image :P
15:22:49 <elliott> fair enough :P
15:22:54 <elliott> "the rest of the program" is the usual definition
15:22:59 <startling> is there a name for the 'list' type so that I can do things like ':i List' in ghci?
15:23:00 <benmachine> program?
15:23:03 <elliott> but in Haskell it's "the rest of the Cont computation"
15:23:05 <benmachine> startling: []
15:23:08 <elliott> delimited by runCont
15:23:10 <benmachine> oh I see
15:23:19 <startling> benmachine: awesome, thanks.
15:23:52 <benmachine> elliott: mm. sometimes I use "computation". but what I wanted is for people to be able to *see* how it worked
15:24:03 <benmachine> I don't know if that came across as clearly as it was in my head though :P
15:24:19 <benmachine> I was just all pleased because today I wrote all the type class instances and callCC without looking at the types
15:24:26 <benmachine> just thinking about what it was actually doing
15:24:40 <benmachine> (I've done implementations of Cont before, but always just from the type)
15:24:41 <elliott> it's not an unreasonable explanation, I agree :)
15:24:52 <elliott> going by the types is underrated
15:24:59 <benmachine> it's great sometimes
15:25:00 <elliott> I think it might even be better than "true understanding" :)
15:25:04 <parcs`> it's called callCC because you're applying the current continuation to its argument
15:25:13 <elliott> (because you don't have to be as smart the next time you run into a problem)
15:25:20 <parcs`> yep padmee is spamming
15:25:25 <elliott> padmee: :(
15:25:30 <benmachine> but I never understood how to *use* Cont when I was just looking at the types
15:25:37 <marienz> thanks for reporting, folks
15:25:40 <benmachine> just how to implement it :P
15:26:22 <benmachine> marienz: using the "vaguely-mumbling-it-into-the-current-open-window" method of reporting, you mean? :P
15:26:45 <marienz> benmachine: exactly! Although #freenode tends to yield better results if we haven't already been warned.
15:26:50 <marienz> also, please prod me if there's more spam.
15:26:58 <benmachine> okay
15:29:55 <siracusa> Can anyone tell me when hackage does the next compilation attempt for new packages?
15:31:31 <kfish> siracusa, every 4-6hrs or so
15:32:31 <elliott> 6, I believe.
15:33:21 <siracusa> Hhm, "Upload date: Thu Jan 19 15:06:52 UTC 2012" didn't get compiled yet
15:33:54 <benmachine> that's a little bit surprising
15:35:20 <elliott> I think it was down for a while(?).
15:35:31 <elliott> Although that was some days ago.
15:35:44 <elliott> siracusa: Are you sure it actually compiles? :)
15:35:53 <siracusa> No, it was today
15:36:04 <siracusa> I'm just too lazy to compile myself -P
15:36:07 <siracusa> :-P
15:40:18 <kqr> if you construct at data type which contains amongst other things an integer, and you'd like to limit that integer to numbers >= 0, how would you go about doing that?
15:40:46 <siracusa> kqr: using http://hackage.haskell.org/package/natural-numbers-0.0.1.3 :-D
15:40:57 <kqr> haha, for an arbitrary requirement then?
15:41:28 <siracusa> Well, that's for positive integers
15:41:28 <dmwit> kqr: Smart constructors / mutators.
15:41:45 <dmwit> kqr: If you want it checked at compile-time, use Agda or Coq.
15:41:53 <kqr> haha
15:41:54 <kqr> right
15:41:55 <kqr> thanks
15:42:06 <dmwit> (And, optionally, extract Haskell code.)
15:43:12 <exFalso> good evening! if only a type constructor (f :: * -> *) is in scope how can one provide a (Show (f a)) style context? 'a' is not in scope and i'd like to avoid creating a "class Show2 (f :: * -> *) ...". Any ideas?
15:43:53 <dmwit> You can't.
15:44:28 <exFalso> haskell can't do it?
15:44:40 <dmwit> Haskell can do it, but Show2 is the way it does it. =P
15:44:56 <Sgeo> What's wrong with (Show (f a))?
15:44:58 <Sgeo> I don't get it
15:44:59 <exFalso> :) ok thanks! just trying to scrape boilerplate as always!
15:45:06 <elliott> siracusa: If that's your package, that Monoid instance worries me.
15:45:09 <exFalso> 'a' is not quantified
15:45:12 <elliott> That's what Sum/Product are for.
15:45:27 <elliott> Sgeo: (forall a. Show (f a))
15:45:31 <elliott> exFalso: p.s. it'd be Show1
15:45:33 <Saizan> exFalso: you can make data ShowDict a where Dict :: Show a => ShowDict a; and use require a  (forall a. ShowDict (f a))
15:45:54 <elliott> there's a package with Show1 plus instances
15:45:56 <elliott> but i forget its name
15:46:14 <exFalso> Saizan, elliott: thanks i'll try foralling
15:46:45 <elliott> erm
15:46:48 <siracusa> elliott: No, it's not mine. But I will tell the author but these classes.
15:46:52 <elliott> exFalso: what i said to sgeo won't work
15:47:13 <exFalso> hmm rankntypes
15:47:24 <elliott> siracusa: Sum and Product are types, not classes, but yeah :)
15:47:59 <siracusa> Oh, what do you mean then?
15:48:01 <exFalso> i already used undecidableinstances i dont want to anger the haskell gods even more
15:48:14 <elliott> data Dict constr where { Dict :: constr => Dict constr }; class Lift cls f where { liftD :: Dict (cls (f a)) } -- does this work with ConstraintKinds?
15:48:15 <elliott> siracusa:
15:48:18 <elliott> :t (Sum, Product)
15:48:21 <lambdabot>     Ambiguous occurrence `Sum'
15:48:21 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
15:48:21 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
15:48:26 <elliott> !!! ffs
15:48:33 <elliott> > getSum $ mconcat [Data.Monoid.Sum 42, Data.Monoid.Sum 39]
15:48:34 <lambdabot>   81
15:48:44 <elliott> > getProduct $ mconcat [Data.Monoid.Product 42, Data.Monoid.Product 39]
15:48:45 <lambdabot>   1638
15:49:02 <elliott> > mconcat [42, 39 :: Integer]
15:49:03 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Integer.Type.Integer)
15:49:03 <lambdabot>    arising fr...
15:49:16 <elliott> so it's inconsistent to give a natural type a Monoid instance like that
15:49:24 <elliott> as that's what Sum/Product are for, due to the ambiguity of which to use as the instance
15:49:28 <elliott> like First/Last for Maybe
15:49:42 <siracusa> Aha, I see
15:50:14 <siracusa> This would require an extra package, no?
15:51:03 <elliott> siracusa: erm... I don't see why
15:51:06 <elliott> the only change is to remove the instance
15:52:09 <siracusa> I thought you were saying to re-implement it using Sum
15:52:45 <elliott> nope, I'm saying that it shouldn't have a Monoid instance, as numeric types in general don't for this reason
15:53:03 <elliott> and that Sum and Product are already in Data.Monoid for this purpose, the former of which matches the given Monoid instance
15:53:03 <Sgeo> How acceptable is reactive-banana at dealing with streaming data?
15:53:11 <Sgeo> Is it absolutely horrible, or somewhat acceptable?
15:53:29 <siracusa> elliott: Okay, sorry
15:53:34 <elliott> siracusa: no problem :)
15:53:50 <elliott> Sgeo: It depends what you mean by "streaming data", and I find it curious that you're sure the best it could possibly be is somewhat acceptable :)
15:54:22 <Sgeo> I guess I'm assuming that conduits and enumerators can do it better
15:54:55 <elliott> If you try to solve a problem better-suited to conduits with reactive-banana for some bizarre reason it'll probably go terribly, yes, but I don't see how those libraries are in mutual opposition to each other at all.
15:55:15 <elliott> I mean, trying to use HOpenGL to do Pandoc's job would also go pretty terribly :P
15:55:53 <Sgeo> I guess the thing is that for my AW stuff, sometimes it makes sense to view events as streaming data
15:55:56 <Sgeo> And sometimes as events
15:56:18 <benmachine> oh man, suddenly conduits appeared
15:56:24 <benmachine> this is what I get for parting #haskell :<
15:58:00 <parcs`> why would you do that!
15:58:06 <elliott> Sgeo: It's easy to turn a conduit source thing into a reactive-banana event and vice versa.
15:58:11 <ddarius> benmachine: Maybe you should part again and see what happens when you get back.
15:58:20 <nyingen> hm, upgraded ghc from 6.12 to 7.0, and now my lambdabot installation is totally broken
15:58:29 <elliott> Which is to say, it'll probably not take more than three hours and forty lines of code, but I'm sure I could do it if I wasn't procrastinating in #haskell.
15:58:40 <benmachine> ddarius: technological innovation is motivated by a desire to annoy me by coming up with things I don't know about
15:58:44 <benmachine> I KNEW IT
15:58:49 <Sgeo> elliott, well, I noted that using a Chan it's easy enough to turn an AddHandler into a source
15:59:22 <elliott> Sgeo: Why would you use an AddHandler.
15:59:23 <elliott> ?
15:59:28 <cheater_> what is AW?
15:59:46 <elliott> AddHandlers are more or less an implementation detail; you're never going to be passed one. Converting an Event makes more sense.
16:00:14 <Sgeo> elliott, as ... well, not the primitives, since they themselves need to be built up, but the basis below FRP or conduits for the wrapper
16:00:24 <elliott> Event -> source would just be (reactimate (writeChan blah blah <$> event)) and have a source that reads the chan; source -> event would just be newAddHandler + forkIO (get thing from source >>= fire) in a loop.
16:01:28 <Sgeo> Does Event have stuff for cleaning up unused events?
16:01:44 <elliott> Sgeo: I'd just pick one, since it's easy to convert either way. Personally I would go for Event, since (a) if you have any kind of time-varying values conduits have nothing to offer but FRP does, and (b) "stream of updates" seems far less a primitive concept than "sequence of occurrences".
16:01:50 <elliott> Cleaning up unused events?
16:02:27 <elliott> As in, killing a thread producing values for an Event once it's garbage-collected?
16:02:45 <elliott> If not that then I don't really know what you mean.
16:03:07 <Sgeo> As in, unregistering an event handler at the SDK level if it's not in use means that data that isn't needed won't be sent
16:03:22 <elliott> Right, so a finaliser.
16:03:38 <elliott> You could do something like that, I think.
16:03:51 <elliott> With weak pointers.
16:04:21 <elliott> You just need to arrange a finaliser that throws an exception in the thread that's waiting on the data; that thread can then catch it, let the other side know not to send the data any more, and kill itself.
16:04:38 <elliott> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/System-Mem-Weak.html#v:addFinalizer
16:05:12 <Sgeo> elliott, is there a SomeMeasureOfTime -> Event a -> Event a that delays the argument event by an amount of time?
16:05:29 <elliott> reactive-banana is timeless; if you want a clock, you provide it yourself.
16:05:54 <elliott> (Which is a Good Thing, IMO.)
16:06:17 <elliott> I don't see how it's relevant if you're considering conduits, though; there's no way to "delay" a source there.
16:06:28 <Sgeo> threadDelay
16:06:33 <elliott> The closest thing I can think of is sleeping in the code that's producing the data, but there's nothing stopping you doing that with reactive-banana, either.
16:06:33 <Sgeo> erm
16:07:03 <elliott> You realise that reactive-banana's external event occurrences are just provided by arbitrary IO computations invoking the callback, right?
16:07:04 <Sgeo> How worried should I be about Discrete being useful
16:07:09 <elliott> (Or the fire action, in the case of newAddHandler.)
16:07:18 <elliott> Sgeo: "Worried"?
16:07:37 <Sgeo> The documentation seems to suggest that the creator doesn't like them
16:07:44 <ddarius> How worried should I be that I have nothing to worry about?
16:08:24 <Sgeo> Actually, it's not quite what I want, I think
16:08:34 <elliott> Sgeo: Discrete not being the same as Behavior is kind of ugly (and I'm pushing for the unification of the two), but it's easy to know which one you want in which situation.
16:08:46 <Sgeo> Since I want to look at the difference between each instance, not the value at each change
16:08:56 <elliott> That's a common pattern.
16:09:07 <elliott> Just use "data Foo = Foo (Behavior T) (Event U)", where U is a diff of T.
16:09:50 <elliott> https://github.com/HeinrichApfelmus/reactive-banana/blob/ded24cf828d0f414acca2595a45753f7f998cce7/reactive-banana-wx/src/CRUD.hs#L103
16:09:51 <elliott> https://github.com/HeinrichApfelmus/reactive-banana/blob/b8c353bf275ee2c58a05cbc18f33fe481c8e70e4/BlackBoard/src/Reactive/GraphicOpt.hs#L64
16:09:54 <elliott> Those are two examples of that pattern.
16:14:55 <Sgeo> What if I expose events and then decide I want to write more imperative code using them? Is there a way to, say, block and wait for the first occurence of an event?
16:15:10 <Sgeo> occurrence
16:15:23 <elliott> Again, reactimate (writeChan foo <$> event).
16:15:38 <elliott> You can run arbitrary IO on occurrences of an event, so any control pattern like that is easy.
16:16:09 <Sgeo> Hmm, ok
16:16:43 <Sgeo> reactimate would have to be inside a NetworkDescription, right?
16:16:58 <elliott> Yes, in the same way that getLine has to be inside IO :P
16:17:21 <Sgeo> I guess I could make a combinator for putting it in a compile... wait, hmm
16:17:31 <elliott> NetworkDescription is just that: a description of an event network, compiled into one with compile, and controlled with actuate/pause.
16:17:39 <elliott> (Compiled into an EventNetwork, that is.)
16:17:47 <Sgeo> Can I easily tell a network or whatever it's called to unregister permanently, not temporarily? Or will pause do that if I never resume it
16:17:59 <elliott> Pause will do that if you don't resume it, yes.
16:18:28 <Sgeo> It seems like it might be more efficient to make a "wait for this once" combinator on top of an AddHandler than an Event
16:18:58 <Sgeo> Not that I'm focusing all that much on efficiency, I guess
16:20:15 <elliott> I doubt the difference is significant at all.
16:20:39 <Sgeo> I definitely do have some things that would fit better as Behaviors.
16:21:15 <Sgeo> Can't fit a "read this global state" so well into a conduit source
16:21:46 <ddarius> "You will achieve success this year."  A refreshingly direct fortune cookie.
16:21:59 <monochrom> give it to Haskell :)
16:22:35 <monochrom> "three programming languages walk into a Chinese restaurant..."
16:23:46 <Sgeo> I guess this is what fromPoll is for, although that makes me feel queasy
16:24:01 <elliott> Why? "read this global state" is exactly what fromPoll is for.
16:24:04 <Sgeo> I can't just write a behavior that will poll only when a value is demanded?
16:24:10 <elliott> That's ... what it does.
16:24:12 <Sgeo> Oh
16:25:47 <monochrom> when will there be a fortune cookie that says "top secret, ingest after reading"? :)
16:25:49 <Sgeo> Pure computations that are done within IO are still lazy, right? (return (1+1)) :: IO Int won't do the 1+1 when the IO is demanded, but when the given value is demanded?
16:26:09 <hpc> Sgeo: indeed; (1+1) is still a thunk
16:26:13 <elliott> return is not strict.
16:26:20 <hpc> Sgeo: see also, evaluate
16:26:23 <hpc> @hoogle evaluate
16:26:24 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
16:26:24 <lambdabot> Control.Exception evaluate :: a -> IO a
16:26:24 <lambdabot> Control.OldException evaluate :: a -> IO a
16:26:31 <elliott> evaluate is, though.
16:26:37 <hpc> which is basically (return $!)
16:26:50 <hpc> plus error handling
16:27:17 <Sgeo> So I shouldn't worry about making an IO action that cheapy grabs data from outside, then expensively does pure computations on it
16:33:02 <elliott> hpc: which is to say, it's \x -> (return $! x) >>= return
16:33:02 * elliott weeps
16:37:46 <Sgeo> elliott, is there a reason to use never and union? Can I just use mempty and mappend?
16:39:40 <psnively> Hi guys. Does anyone know how to get haskeline to build correctly on Mac OS X 10.6.8? I have the latest Haskell Platform (i.e. GHC 7.0.2) installed.
16:40:01 <psnively> It fails to link with -liconv, an apparently well-known, well-discussed problem that I haven't found an actual solution to.
16:40:57 <elliott> Sgeo: Yes, you can.
16:41:07 <elliott> Sgeo: But the Monoid instance is being restricted soon.
16:41:09 <elliott> And never and union are a bit more descriptive.
16:41:16 <Sgeo> restricted?
16:41:32 <elliott> To only Event (a -> a), after a long flamew^Wdebate.
16:41:54 <Sgeo> Hmm, why exactly?
16:42:01 <Sgeo> And were you involved?
16:42:09 <elliott> Simultaneous events, and I plead the fifth.
16:42:18 <geekosaur> psnively, as far as I can determine the only way to solve the -liconv problem is to ditch macports
16:42:34 <psnively> geekosaur: That's easy: I'm not using MacPorts.
16:42:44 <psnively> Or Homebrew. Or any package manager.
16:42:47 <parcs`> :t ((>=>) =<< ($!)) return
16:42:48 <lambdabot> forall (m :: * -> *) c. (Monad m) => c -> m c
16:43:07 <startling> so what exactly is an 'action'?
16:43:11 <parcs`> :t ((=<<)(>=>)($!))return
16:43:12 <lambdabot> forall (m :: * -> *) c. (Monad m) => c -> m c
16:43:24 <elliott> startling: a value of type (m a) for some monad m
16:43:25 <parcs`> startling: something of type IO a
16:43:25 <geekosaur> then I wonder if whoever built the HP package was, because the -liconv problem is that Apple ships an older libiconv, and MacPorts includes a newer one with incompatible symbols
16:43:28 <elliott> probably (IO a), if you're asking that :)
16:43:36 <startling> parcs`, elliott : cool, thanks.
16:44:05 <geekosaur> unless your -liconv problem is not the usual one, in which case I'd suggest you show the actual error message you're getting
16:44:06 <elliott> startling: "action" is used to emphasise that a value of (IO a) isn't e.g. an a behind some wrapper or anything like that, but an imperative computation that you could perform any number of times and get a value of type "a" out each time
16:44:11 <elliott> as the result
16:44:16 <elliott> with arbitrary side-effects along the way
16:44:21 <startling> got it.
16:44:37 <startling> so an action is something you have to bind to get the result, basically.
16:44:49 <psnively> Hard to believe no one's ever tried to build Haskeline on stock Mac OS X 10.6... and failed.
16:44:51 <elliott> well... mostly :P
16:45:07 <startling> heh.
16:45:17 <sshine> startling, I think binding is just... connecting two actions in series.
16:45:30 <elliott> it's more like, if you have an action producing an a, and you can turn an a into an action producing b, then you can get an action producing b
16:45:30 <elliott> basically what sshine said
16:45:30 <elliott> you're allowed to sequence two actions, and use the result of the former in the latter
16:45:33 <elliott> more or less
16:45:46 <sshine> startling, you have to run/eval/exec the action to get a result from the action.
16:45:51 <psnively> geekosaur: So is there at least some way to get cabal to spit out what it's doing, i.e. the output from gcc when it tries to link etc.?
16:45:53 <startling> am I using the word 'bind' wrong?
16:46:02 <elliott> sshine: which you can't for IO :P
16:46:05 <elliott> startling: probably not
16:46:10 <elliott> (>>=) :: IO a -> (a -> IO b) -> IO b
16:46:12 <elliott> that's bind
16:46:21 <elliott> (everyone: I know it works on any monad, shhh)
16:46:27 <startling> oh, I meant something like `n <- getLine`.
16:46:32 <elliott> oh! yes
16:46:38 <elliott> when you say
16:46:48 <elliott> do { a <- getLine; ... }, that's just sugar for getLine >>= (\a -> do ...)
16:46:53 <elliott> if that's confusing, ignore it :)
16:47:00 <startling> oh, I think I understand.
16:47:02 <elliott> yes, <- is the bind operator
16:47:06 <elliott> in do notation
16:47:28 <elliott> and it is indeed getting the result out of an action, to use in the rest of the action you're building up
16:47:42 <startling> I had just been using IO stuff mechanically (like, without understanding monads) and now I'm trying to untangle those.
16:47:58 <elliott> It's simpler than most people think :)
16:48:20 <sshine> elliott, I don't know if it's wrong to think that main does that implicitly for IO?
16:48:23 <elliott> Monads basically just offer a way to compose computations in certain ways; those ways happen to be exactly what you want to describe imperative side-effectful programs.
16:48:31 <elliott> sshine: yeah, that's fair
16:48:36 <startling> yep.
16:48:42 <startling> is ghci like, in a monad?
16:48:46 <elliott> yes
16:48:51 <elliott> all of ghci is in one big IO do block, essentially
16:49:01 <startling> I was wondering why at's just sugar for getLine >>= (\a -> do ...)
16:49:01 <startling> 19:35 < elliott> if that's confusing, ignore it :)
16:49:01 <startling> 19:35 < startling> oh, I think I understand.
16:49:01 <startling> 19:35 < elliott> yes, <- is the bind operator
16:49:06 <elliott> except that it also puts "print" in when you evaluate a pure expression :)
16:49:08 <startling> blah, wrong paste.
16:49:21 <startling> I was wondering why `n <- getLine` worked in it. Thanks!
16:49:27 <elliott> right :)
16:49:46 <elliott> no problem
16:51:46 <elliott> CoconutCrap: your b flipped over
16:53:10 <startling> oh! that's why you have to `let` in ghci, too. neat.
16:53:14 <CoconutCrap> elliott: yes, just to remind me what I need to do (not crapping!)
16:53:26 * CoconutCrap went back to lurking
16:53:44 <elliott> startling: yep (although ghci is getting full top-level declarations soon, so it's going to be a magic do-block with top-level "data", etc. declarations :P)
16:54:36 <startling> elliott: that would be handy, yeah. I have bunches of little files scattered around from trying to get the hang of type declarations.
16:54:51 <Sgeo> elliott, internally, how does it work? I doubt it's literally inside a do block
16:55:08 <elliott> Sgeo: I think it parses binds itself.
16:55:31 <elliott> actually, it probably just puts "do" around the line entered and picks apart the AST of that
16:55:37 <elliott> but that's just a guess
16:58:55 <psnively> OK, so... cabal install on haskeline is looking to link with libiconv_open, when libiconv.dylib has _iconv_open. Feh.
17:00:18 <ddarius> "If the maximizer threshold is already set low, but the loudness is still not enough, other dynamics processors can be used. Try using a compressor. If even more loudness is needed - try a multiband compressor. If you are still not quite satisfied, check if your audio is already a pink noise."
17:02:12 <timemage> psnively, you're looking at the same level of the toolchain?
17:02:31 <psnively> timemage: I don't know what that means, I'm afraid.
17:03:29 <timemage> psnively, it's normal for C symbols to be prefixed with _ during compilation and before linking.     so if you're looking an linker errors referring to _symbol and compiler errors refering to symbol, sometimes they're the same thing.
17:04:03 <psnively> Right, sorry, I misspoke: the linker is failing to find _libiconv_open. The .dylib file contains _iconv_open.
17:04:47 <timemage> psnively, guess that's beyond me.  you're on a mac i take it.
17:04:54 <psnively> Yes.
17:05:22 <Clint> it's not necessarily the same API
17:13:50 <cl1> does the person who wrote the real world haskell tutorial hang out in here?
17:15:42 <timemage> if i were him, that question would send me into hiding.
17:16:32 <ddarius> cl1: Real World Haskell is a book and is authored by three individuals.
17:16:50 <c_wraith> and one of them is still around semi-frequently.
17:17:12 <c_wraith> the authors use the names bos, dons, and GammaRay, IIRC.
17:17:16 <c_wraith> bos is still around sometimes
17:17:20 <ddarius> CosmicRay
17:17:24 <c_wraith> d'oh
17:17:25 <c_wraith> thanks
17:17:26 <hpc> dons used to be around
17:17:35 <c_wraith> bos isn't around much since he joined facebook
17:17:41 <hpc> haha
17:17:52 <Sgeo> NetworkDescription is an applicative functor like all monads are supposed to be, right?
17:17:54 <c_wraith> joined = "started working at" in this case :)
17:18:49 <monochrom> dons speaks up every time #haskell size hits a new record
17:19:04 <timemage> c_wraith, i was wondering about that.
17:19:25 <c_wraith> similarly, dons hasn't been around much since he started working in the financial industry
17:19:30 <Sgeo> Oh right, I had a beef with one of the libraries authored by one of the RWS guys
17:19:43 <Sgeo> er, RWH
17:19:49 <c_wraith> RWS?  reader, writer, state!
17:20:22 <monochrom> real world snobol
17:21:01 <ddarius> I wouldn't be surprised if there's more "real world" SNOBOL than Haskell.
17:21:10 <elliott> <Sgeo> NetworkDescription is an applicative functor like all monads are supposed to be, right? ;; yes. wouldn't checking the haddocks be quicker than asking #haskell?
17:21:17 <cl1> i just wanted clarification on exercise one for chapter five. do they want the spaces added to the left or right of the document?
17:21:43 <roconnor> @src sequence
17:21:44 <lambdabot> sequence []     = return []
17:21:44 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:21:44 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
17:22:15 <roconnor> sequence (x:xs) = (:) <$> x <*> y
17:22:22 <roconnor> sequence (x:xs) = (:) <$> x <*> xs
17:22:22 <elliott> roconnor: wat
17:22:25 <elliott> roconnor: wat
17:22:36 <roconnor> sequence (x:xs) = (:) <$> x <*> sequence xs
17:23:00 <elliott> roconnor: itym sequence xs
17:23:00 <elliott> \o/
17:23:10 <roconnor> itym?
17:23:16 <elliott> = liftA2 (:) x (sequence xs), thus producing the foldr definition :P
17:23:18 <elliott> roconnor: i think you mean
17:23:23 <roconnor> yep
17:23:37 <elliott> (as in, itym = i think you mean)
17:24:12 <Sgeo> I was wondering about the difference between a Behavior and a mutable variable, and I think I get it. A behavior gets described in one place, other pieces of code that are not in its definition don't define it, don't describe it.
17:24:54 <elliott> Sgeo: right, a (Behavior a) is a time-varying value -- there's no "non-local" effects
17:25:26 <elliott> of course, you can model mutable variables with "foo :: a -> Event a -> Behavior a" -- foo = stepper
17:25:46 <elliott> and there the "mutations" come from outside... but thinking about FRP in terms of mutations and effects is probably a bad idea
17:26:55 <Sgeo> But any behavior defined by that function must mention the event it's drawn from
17:27:58 <elliott> Sgeo: erm, the point is that the Event is the update stream
17:28:19 <elliott> Behaviors are more general than mutable variables because you can model mutable variables with them
17:28:32 <elliott> and stepper is that model
17:31:15 <roconnor> @type (.).(:)
17:31:16 <lambdabot> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
17:31:25 <roconnor> @type (Prelude..).(:)
17:31:26 <lambdabot> forall a a1. a1 -> (a -> [a1]) -> a -> [a1]
17:31:32 <startling> what happens when I use `do` notation  without any monad things?
17:31:51 <JoeyA> > do "it"
17:31:53 <lambdabot>   "it"
17:31:58 <JoeyA> err, that is a monad thing
17:32:01 <JoeyA> > do 5
17:32:01 <hpc> JoeyA: [] is a monad ;)
17:32:02 <lambdabot>   5
17:32:15 <hpc> don't forget lambdabot Num instances :P
17:32:17 <hpc> > do ()
17:32:18 <lambdabot>   ()
17:32:19 <startling> so it's just an ordinary value or function or whatever
17:32:29 <JoeyA> do is syntactic sugar
17:32:45 <startling> thanks
17:32:47 <JoeyA> anything you do in do (besides the trivial examples above) turns into monadic binds.
17:32:52 <hpc> "do oneLiner" => "oneLiner"
17:33:01 <hpc> "do foo; bar" => "foo >> bar"
17:33:11 <JoeyA> > do {a <- getLine; b <- getLine; return (a ++ b)}
17:33:15 <Sgeo> How is () a monad?
17:33:17 <lambdabot>   mueval: ExitFailure 1
17:33:17 <lambdabot>  mueval: Prelude.undefined
17:33:19 <JoeyA> That's the same as:
17:33:21 <hpc> since (>>) isn't involved in the first, the type never gets constrained to being monadic
17:33:31 <JoeyA> > getLine >>= \a -> getLine >>= \b -> return (a ++ b)
17:33:32 <hpc> (ditto for (>>=))
17:33:36 <lambdabot>   mueval: ExitFailure 1
17:33:36 <lambdabot>  mueval: Prelude.undefined
17:33:43 <sipa> doesn't it even work if you have another non-Preloude (>>) in scope?
17:33:45 <elliott> startling: that's basically a semantic quirk
17:33:56 <JoeyA> @undefine
17:33:56 <hpaste_> ex pasted “broken Applicative instance” at http://hpaste.org/56709
17:33:57 <elliott> startling: as soon as you have two statements, you're in monad-land
17:34:03 <hpc> sipa: you can NoImplicitPrelude
17:34:06 <Sgeo> :t do
17:34:07 <lambdabot> Empty 'do' construct
17:34:11 <elliott> Sgeo: it isn't
17:34:26 <Sgeo> What did do () do then?
17:34:37 <exFalso> hello can anyone tell me why in the above code the Applicative instance is broken (ambiguous type) but the Functor isnt?
17:34:41 <hpc> @undo do ()
17:34:41 <lambdabot> ()
17:34:45 <hpc> > ()
17:34:46 <lambdabot>   ()
17:34:51 <hpc> that's what it did
17:35:15 <elliott> exFalso: which one?
17:35:22 <sipa> Sgeo: do does not imply a monad; it just desugars, and the desugared form usually requires monadicness (?)
17:35:43 <elliott> monadicerosityerificness
17:35:45 <Sgeo> > do 'c'
17:35:46 <lambdabot>   'c'
17:35:57 <elliott> > do Nothing
17:35:58 <lambdabot>   Nothing
17:36:27 <sipa> hpc: yes, but i mean, if you do NoImplicitPrelude, and have another (>>) in scope, that would get used by do-constructs, right?
17:36:36 <hpc> indeed
17:36:36 <JoeyA> > Just $ do it
17:36:38 <lambdabot>   Not in scope: `it'
17:36:46 <Sgeo> You don't need RebindableSyntax for that?
17:36:53 <exFalso> elliott: the one on line 37
17:37:13 <elliott> exFalso: okay, and what is the error?
17:37:31 <exFalso> ambiguous type variable
17:37:38 <elliott> exFalso: the _full_ error
17:37:46 <exFalso>     Ambiguous type variable `t0' in the constraints:
17:37:46 <exFalso>       (Applicative t0) arising from a use of `pure' at Tree2N.hs:38:28-31
17:37:47 <exFalso>       (Treeify n t0) arising from a use of `Tree2NBranch'
17:37:47 <exFalso>                      at Tree2N.hs:38:12-23
17:37:52 <elliott> I suspect it is because it does not know which t to use
17:37:56 <elliott> right
17:37:59 <elliott> or for that matter, which n
17:38:06 <elliott> fmap works because the types are dictated by your input
17:38:10 <elliott> but you have no input here
17:38:15 <elliott> oh, ofc it knows which n
17:38:16 <elliott> but not which t
17:38:20 <exFalso> t is not bound in the Functor instance either
17:38:28 <elliott> as I said, "fmap works because the types are dictated by your input"
17:38:38 <elliott> since you reuse the t from the input, just fmapping oevr it
17:38:52 <elliott>   pure a = Tree2NBranch a (pure Tree2NLeaf :: T (Tree2N n a))
17:38:54 <elliott> for some T
17:38:55 <exFalso> ah fair enough
17:39:00 <elliott> should work
17:39:04 <elliott> *over
17:39:07 <roconnor_> @type ($(:[])).(.).(:)
17:39:08 <lambdabot> forall a. a -> a -> [a]
17:39:15 <roconnor_> @unpl ($(:[])).(.).(:)
17:39:16 <lambdabot> (\ h e -> ((:)) h (e : []))
17:39:22 <roconnor_> @. pl unpl ($(:[])).(.).(:)
17:39:22 <lambdabot> (. return) . (:)
17:39:43 <exFalso> yeah i'd like to keep it unbound. will fiddle around a bit. maybe with dummies?
17:39:50 <exFalso> thanks!
17:40:13 <hpc> roconnor_: looking at that snippet, i find it unsurprising that perl's file extension is ".pl" :P
17:41:39 <elliott> exFalso: there's not really anything you can do
17:41:48 <elliott> you need to pick a t to stuff into the existential
17:42:45 <exFalso> elliott:: adding a "instance (Treeify n t)" solved it
17:42:49 <rwbarton> in principle (particularly as I don't know what Treeify is) you can get back out an ordinary, concrete value like an Int or something that depends on what choice of t you made there
17:42:55 <exFalso> i mean Treeify n t context
17:43:15 <hpaste_> gwern pasted “sorting stdin by longest common prefixes” at http://hpaste.org/56710
17:43:24 <exFalso> yes, thats exactly what that did, thanks :D
17:43:56 <rwbarton> somehow this is a fairly common question though
17:44:09 <elliott> exFalso: hm... where did you put that context?
17:44:55 <exFalso> in the Applicative instance def
17:45:08 <elliott> hmm, OK :)
17:45:14 <elliott> oh!
17:45:16 <rwbarton> oh wait, there is a fundep from n to t?
17:45:18 <elliott> there's a functional dependency
17:45:21 <elliott> ok, that makes sense then :)
17:45:55 <hpaste_> gwern annotated “sorting stdin by longest common prefixes” with “sorting stdin by longest common prefixes (annotation)” at http://hpaste.org/56710#a56711
17:46:01 <elliott> exFalso: (you might want to consider using a type family)
17:46:29 <rwbarton> that error message now seems suboptimal
17:46:55 <rwbarton> I guess with type families or at least associated types, you would have had a better one
17:47:12 <exFalso> elliott: couldnt get my head around those yet :)
17:47:59 <elliott> fair enough :P
17:48:50 <elliott> exFalso: class (Functor (Treed n), Applicative (Treed n), Show1 (Treed n)) => Treeify n where type Treed n; instance Treeify Nil where type Treed Nil = TreeTNil; instance (Treeify r) => Treeify (Succ r) where type Treed (Succ r) = TreeTBranch (Treed r) is how you'd define it that way, fwiw
17:48:59 <elliott> i guess that's kind of incomprehensible on one line :)
17:49:08 <gwern> so anyway, anyone want to take up the challenge of finding multiple longest common prefixes in a list of input? :) the best I could do was pretty darn ugly and incomprehensible
17:49:52 <exFalso> ahh that makes sense!
17:49:58 <exFalso> much nicer syntax!
17:50:44 <gwern> what's frustrating is that I used a stackoverflow suggestion for the algorithm, which was really short and succint - and incredibly hard to actually implement
17:52:26 <rwbarton> gwern: I couldn't even figure out what was going on with your example input/output without reading the code, so it can't be that incomprehensible :P
17:52:42 <gwern> rwbarton: that's because your eye is misled by the grouping of '-'
17:52:55 <rwbarton> partly, yes
17:53:37 <rwbarton> also the title made me expect the ordering would be related to the length of the common prefix rather than the frequency of a maximal common prefix, which seems like an odd thing to me
17:54:08 <rwbarton> actually, wait, I no longer understand what is going on
17:54:40 <exFalso> elliott: and im guessing with typefamilies one can drop undecidableinstances?
17:54:55 <gwern> heh. I make no guarantees it's correct, by the end my mind was warped and I was just hoping it was sort of right :)
17:54:58 <elliott> exFalso: I don't think you need UndecidableInstances for Treeify in the first place
17:55:17 * elliott hasn't looked at gwern's program. Is it confusing enough that I'll understand it less after looking at it?
17:55:31 <exFalso> ghc said it did:)
17:55:34 <rwbarton> "bar = nub . sort . traverse . sort" is cute, whatever the hell it is :)
17:55:46 <centrinia> :t traverse
17:55:47 <lambdabot> Not in scope: `traverse'
17:55:53 <elliott> exFalso: weird
17:56:11 <gwern> rwbarton: well, the idea is that we step through the list pair by pair, asking what the common prefix of the two entries are
17:56:43 <gwern> rwbarton: this gives us a bunch of duplicates we need to throw away (eg. traverse "miku-x" "miku-y" "miky-z" will give us "miku-" "miku-")
17:57:03 <rwbarton> > nub . sort . Data.Traversable.traverse . sort $ "aabc"
17:57:04 <lambdabot>   Couldn't match expected type `[a]'
17:57:04 <lambdabot>         against inferred type `t a1 -> f...
17:57:11 <rwbarton> > nub . sort . Data.Traversable.traverse . sort $ ["aabc", "xyz"]
17:57:12 <lambdabot>   Couldn't match expected type `[a]'
17:57:12 <lambdabot>         against inferred type `t a1 -> f...
17:57:21 <gwern> of course, we may get useless prefixes like "m" too, so we need a processing step where we throw that out looking for longer prefixes...
17:57:24 <rwbarton> oh
17:57:29 <rwbarton> you shadowed my name :(
17:57:29 <elliott> :t nub . sort . Data.Traversable.traverse . sort
17:57:30 <lambdabot>     Couldn't match expected type `[a]'
17:57:30 <lambdabot>            against inferred type `t a1 -> f (t b)'
17:57:30 <lambdabot>     In the first argument of `(.)', namely `Data.Traversable.traverse'
17:57:34 <elliott> :t Data.Traversable.traverse . sort
17:57:35 <lambdabot>     Couldn't match expected type `a -> f b'
17:57:35 <lambdabot>            against inferred type `[a1]'
17:57:35 <lambdabot>     Probable cause: `sort' is applied to too many arguments
17:57:38 <elliott> :(
17:57:40 <rwbarton> it's not Data.Traversable.traverse at all
17:57:45 * gwern shrugs. I specified my imports carefully, don't blame me!
17:58:07 <rwbarton> yes that's how I noticed eventually :P
18:00:09 <rwbarton> do you really want "drop 2 x" on line 247, not "drop 1 x"?
18:00:30 <gwern> rwbarton: hm, that might be a mistake, you are right
18:01:17 <gwern> yeah, bug
18:02:28 <hpaste_> gwern annotated “sorting stdin by longest common prefixes” with “sorting stdin by longest common prefixes (annotation) (annotation)” at http://hpaste.org/56710#a56712
18:03:34 * Sgeo wonders when mm_freak will be awake
18:04:36 <Sgeo> elliott, just vaguely thinking about how I would write sourceEvent, surely I could just make the cleanup event be pause?
18:05:18 <roconnor_> @type \a x -> join $ x <$> a
18:05:19 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
18:05:29 * DanBurton has been having fun with monads in lambda calculus http://stackoverflow.com/a/8936209/208257
18:05:32 <roconnor_> @type \a x -> join $ x `liftM` a
18:05:33 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a1 -> (a1 -> m a) -> m a
18:05:46 <roconnor_> @type (>>=)
18:05:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:06:49 <ddarius> DanBurton: If only you had a Reader monad for your monads.
18:07:00 <russruss> hey, so if I have something that's an arrowplus, what's the best way to get an asum-type function - I don't see one defined in hoogle - should I just make a monoid instance?
18:07:12 <russruss> and use mconcat?
18:07:22 <russruss> all these monoidal type classes confuse me
18:07:41 <DanBurton> ddarius: huh? o_O you mean besides (a ->) ?
18:08:51 <ddarius> DanBurton: You realize that your "evidence tuples" are being passed around like an environment...
18:09:00 <DanBurton> ddarius: yes that's the idea
18:09:28 <startling> is `return` just 'make a monad of this type from this thing'?
18:09:33 <elliott> <Sgeo> elliott, just vaguely thinking about how I would write sourceEvent, surely I could just make the cleanup event be pause?
18:09:37 <elliott> Sgeo: You can't hook into pause.
18:09:40 <DanBurton> startling: basically, yes
18:09:44 <elliott> AFAIK
18:09:50 <elliott> Sgeo: but it wouldn't be hard to add support for that, I think
18:09:52 <startling> DanBurton: that's neat, thanks.
18:09:55 <Sgeo> elliott, what? I'd make the source's cleanup event call pause
18:09:57 <elliott> Sgeo: or, of course, you could write your own wrapper for pause
18:09:59 <DanBurton> :t return
18:09:59 <elliott> right, yes, that would work
18:10:00 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:10:29 <rwbarton> startling: except where you say "monad" it should be replaced by something else, though people don't all agree on what term to use
18:10:39 <elliott> action :P
18:10:41 <Sgeo> mobit?
18:10:48 <rwbarton> personally I like "action" also
18:10:49 * DanBurton typically advocates "Monadic value"
18:11:00 <elliott> DanBurton: That's misleading in the case of e.g. IO
18:11:05 <rwbarton> but then I am used to getting funny looks when I call [1,2,3] an "action"
18:11:14 <elliott> at least, calling (IO a) a "monadic value" would make people inclined to think there's an "a" value inside there, IMO
18:11:15 <startling> so, correctly, Monad is only the typeclass?
18:11:26 <elliott> startling: any instance of monad is "a monad"
18:11:32 <elliott> the type-class is just "Monad"
18:11:33 <DanBurton> elliott: I suppose. "action" is misleading for monads-as-containers though
18:11:55 <elliott> DanBurton: yeah... though it's easier to rephrase containers as computation than it is to rephrase computation as containers :)
18:12:05 <elliott> at least the former is always possible
18:12:07 <startling> then what's the difference between a monad and 'monadic value' or whatever?
18:12:16 <rwbarton> a monad is a type constructor
18:12:17 <hpaste_> “Joey Adams” pasted “What does threadWaitRead do on Windows with -threaded ?” at http://hpaste.org/56713
18:12:24 <rwbarton> whereas a monadic value is... a value
18:12:26 <elliott> (>>=) isn't usually a *terribly* useful operation on "data structures", anyway
18:12:29 <Sgeo> IO is a monad. A given IO a is a monadic value.
18:12:42 <startling> got it.
18:12:44 <elliott> although there's that tree grafting thing
18:12:46 <DanBurton> Likewise, Maybe is a monad, List is a monad, etc.
18:13:01 <elliott> [] is a monad, rather :p
18:13:04 <startling> DanBurton: but [1, 2] is a monadic value?
18:13:14 <DanBurton> startling: precisely
18:13:24 <DanBurton> well, if you subscribe to that terminology ;)
18:13:29 <startling> I think I understand. Thanks, everyone.
18:13:40 <elliott> startling: (from the action point of view, [1,2] is a nondeterministic computation with possible results 1 and 2)
18:14:01 <exFalso> @hoogle f a -> f b -> f (a, b)
18:14:02 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
18:14:03 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
18:14:03 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
18:14:05 <elliott> exFalso: liftA2 (,)
18:14:22 <elliott> note: _not_ zipWith for f ~ []
18:14:26 <exFalso> elliott: i need it to define <*> :)
18:14:31 <elliott> (it's zipWith for f ~ ZipList, though)
18:14:33 <elliott> exFalso: ah
18:14:36 <DanBurton> and Just 3 is a computation with possible result of 3, though you're "not sure" beforehand if the computation will produce anything at all...is there a better way to say that?
18:14:37 <elliott> exFalso: well it depends on your f, then :)
18:15:03 <elliott> exFalso: zp :: f a -> f b -> f (a,b) is equivalent to (<*>), as in, you could replace (<*>) with that in Applicative and it'd still be the same
18:15:09 <elliott> since f <*> x = uncurry ($) <$> zp f x
18:15:45 <elliott> DanBurton: Just 3 is a computation with result 3 in a context with failure
18:15:48 <elliott> rather
18:15:54 <exFalso> true
18:15:58 <rwbarton> well, you could say that from its type we know that Just 3 is a "computation with the possible effect of failure" but from the value Just 3 we know that it does not in fact fail
18:16:04 <elliott> right
18:16:28 <elliott> some people think that makes "action" unsuitable because you can "just look" at the value and see there's no choice or "alternate possibilities" there, but I think that's silly
18:16:39 <elliott> you can evaluate /anything/ far enough and remove all possible branches
18:18:47 <rwbarton> at the risk of engendering a horrible monad analogy, a monad is like a specific configuration of add-on hardware for your Turing machine (as "viewed from the inside")
18:19:46 <rwbarton> By which I mean I think it's actually a good analogy but it's unlikely to help someone who doesn't already get it.
18:20:31 * DanBurton now knows slightly less than he used to about Monads. Thanks rwbarton :)
18:20:35 <roconnor_> I wish the type system could catch when I implement an applicative functor backwards. :(
18:20:45 <rwbarton> You're welcome!
18:21:04 <rwbarton> Actually it is a bit tempting to write up a "monad tutorial" from that point of view
18:21:46 <elliott> rwbarton: I very much like the "extending the language with new capabilities", *but* IMO the main problem with taking it too far is that Haskell's application of monads to the area is *not* as good as it good be from that POV :)
18:22:27 <elliott> in that (a) monads don't really compose as well as we'd like, and (b) there's a fairly involved upfront cost from moving from pure code to code with just one special ability, even with applicative style
18:22:32 <rwbarton> are you talking about things like--
18:22:34 <rwbarton> yes
18:22:42 <rwbarton> my analogy sounds very composable
18:23:52 <rwbarton> Anyways, I would start from the semantic point of view--what types do we need to describe the behavior of a Turing machine equipped with a sensor/printer/read-writable cell/self-destruct button/etc.
18:24:16 <elliott> why a Turing machine? it's much nicer to imagine giving these extra semantics to a pure language, IMO
18:24:29 <elliott> and when you get to something like IO, it's adding impure side-effects and full observation of evaluation order :P
18:24:54 <elliott> but I guess you can view a turing machine as the end result, and monads as a sort of bridge from the lambda calculus to there
18:25:27 <ddarius> DanBurton: Maybe models "detectably" partial computations.
18:26:06 <elliott> Maybe is actually a bit easier to explain as Either (), which is computations with a single exception type
18:36:19 <Sgeo> :t (<$)
18:36:20 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
18:36:59 <hpaste_> “Ben Gamari” pasted “Stack overflow” at http://hpaste.org/56715
18:37:11 <bgamari> Does anyone see a stack overflow in the above?
18:37:39 <bgamari> Or have any tricks to identify the source of the overflow?
18:37:55 <bgamari> So far my attempts at finding it in ghci have failed
18:37:58 <Sgeo> > 5 <$ [1,2,3] -- [5,5,5]?
18:37:59 <lambdabot>   [5,5,5]
18:38:28 <hughfdjackson> :p i like the 'use camelcase warning'
18:39:04 <elliott> bgamari: you'll have to narrow it down a bit, or at least give us a hint as to where you think it's overflowing :)
18:39:11 <hughfdjackson> having flash backs of jslint as we speak :p
18:39:11 <elliott> oh, that's what you're having problems with, heh
18:39:12 <bgamari> It looks like step
18:39:17 <elliott> bgamari: have you tried adding traces to every function?
18:39:23 <elliott> ok, step was my guess too
18:39:36 <bgamari> But I really don't know how. It's not recursive
18:39:49 <bgamari> forM_ shouldn't be recursive either, correct?
18:39:51 <rwbarton> a common cause of stack overflow is any kind of "accumulated" value that you build up for a long time before inspecting
18:39:53 <elliott> hmm... initial suspicion was lazy state monad, but you're using strict
18:39:57 <bgamari> I'm using Strict state
18:40:00 <bgamari> yep
18:40:01 <elliott> bgamari: forM_ will be implemented recursively, yes, but that's not really relevant
18:40:06 <bgamari> Already made that mistake
18:40:09 <elliott> your monad is strict enough for that to be OK
18:40:27 <elliott> bgamari: the most likely thing is that step is causing the forcing of a too-deeply-nested value elsewhere
18:40:31 <rwbarton> it's not strict in the fields of Timestep -- tsTime looks like an offender
18:40:35 <elliott> e.g. you do step (huge stack overflowy computation) and it printed it out, or whatever
18:40:41 <elliott> (just as a hypothetical)
18:40:48 <elliott> yeah
18:40:48 <elliott>      put $ state {tsTime=tsTime state + step_t config}
18:40:54 <elliott> this is probably what's causing the problem
18:41:07 <elliott> the state monad only keeps your state in weak-head normal form, i.e. one layer of strictness
18:41:11 <bgamari> Ahh
18:41:12 <bgamari> damn
18:41:21 <elliott> put $ let !t' = tsTime state + step_t config in state {tsTime=t'}
18:41:22 <elliott> would do the trick
18:41:24 <bgamari> bah, laziness is hard
18:41:32 <elliott> not as hard as strictness :)
18:41:50 <elliott> (ok, probably a little harder than strictness. but more useful.)
18:42:06 <monochrom> some other things are harder when eager
18:42:13 <elliott> bgamari: btw, i would suggest avoiding the name "state".
18:42:20 <elliott> :t state
18:42:21 <lambdabot> forall s a. (s -> (a, s)) -> State s a
18:42:22 <monochrom> for example decomposing consumer and producer
18:42:24 <elliott> since it's already used :)
18:42:24 <bgamari> Heh, fair enough. But in all seriousness, are there ways to approach these problems in larger code bases?
18:42:30 <elliott> bgamari: (you might want to consider -Wall to catch that)
18:42:33 <bgamari> elliott: I'm really bad at shadowing names
18:42:38 <elliott> well, "these problems" are reduced with experience
18:42:53 <elliott> it only took us a minute or two to find the problem in this case, after all :)
18:42:59 <bgamari> there aren't enough synonyms in english
18:43:03 <bgamari> heh, fair enough
18:43:04 <monochrom> learn laziness properly. then you will be aware when you code.
18:43:08 <elliott> bgamari: but generally I would make your records have more strict fields
18:43:16 <bgamari> I guess I just have to develop more of a sense of it
18:43:24 <rwbarton> the space profiler might be able to locate this issue
18:43:27 <elliott> bgamari: there's no reason to have an evaluated Timestep without evaluated tsState/tsTime fields
18:43:41 <elliott> so put a ! before their types in the data declarations and you can avoid all the mess of strictness in the rset of your code
18:44:00 <elliott> indeed, all the fields of FretMC and Frame should probably be strict too
18:44:32 <elliott> basically "small" fields that you don't expect to put huge computations in should be strict
18:45:00 <monochrom> it is not so much code size as who wrote it. the author is the best person to decide on how lazily and how eagerly.
18:45:24 <rwbarton> I thought the difference between strict/lazy state monads was something like undefined >> return () working for the lazy state monad but not the strict one
18:45:36 <rwbarton> I think you will still need to put $! the new state
18:45:48 <monochrom> yes, that's the only strictness of the strict state monad
18:46:15 <monochrom> undefined >> put undefined >> put True
18:46:18 <elliott> that too
18:46:29 <elliott> but I suspect bgamari is forcing the state elsewhere in the computation
18:46:34 <rwbarton> ah true
18:46:37 <elliott> not that i really looked :)
18:46:48 <rwbarton> well, on the next line so yes :)
18:47:05 <elliott> not looking pays off again
18:47:33 <bgamari> Thanks a ton!
18:47:46 <bgamari> It seems that -XBangPatterns should really be in the Haskell report
18:48:02 <bgamari> They are much more convenient than seq, et al
18:48:04 <rwbarton> you might try playing with the space profiler to see whether it could have located your problem for you
18:48:09 <elliott> bgamari: you don't need -XBangPatterns to put them on data declarations
18:48:15 <elliott> which is what i'd recommend doing in this case
18:48:21 <elliott> that's standard
18:48:37 <bgamari> So I was right! ;)
18:48:49 <bgamari> excellent, I was unaware of that
18:49:30 <bgamari> Also, while I'm here, does anyone see a better way to handle emit?
18:49:41 <bgamari> In the above codebase
18:49:56 <bgamari> First I thought to use WriterT
18:50:04 <bgamari> at accumulate my output
18:50:47 <bgamari> But all it can do is accumulate a Monoid
18:51:02 <elliott> what are you accumulating?
18:51:24 <bgamari> timestamps (Word64s)
18:51:29 <elliott> bgamari: a list of timestamps, say?
18:51:40 <elliott> > runWriter $ tell [42]; tell [99]; tell [24]
18:51:41 <lambdabot>   <no location info>: parse error on input `;'
18:51:42 <elliott> > runWriter $ do tell [42]; tell [99]; tell [24]
18:51:44 <lambdabot>   ((),[42,99,24])
18:51:45 <bgamari> sure
18:51:52 <elliott> most uses of the Writer monad use a list
18:52:01 <elliott> or at least a difference list to avoid nasty left-associative concatenations
18:52:18 <monochrom> Writer is not exactly for general-purpose accumulator
18:52:27 <bgamari> But this will have to accumulate the entire list before starting IO, no?
18:52:29 <elliott> "emit Donor t" -- DList (Channel, Time)
18:52:31 <elliott> bgamari: no
18:53:01 <elliott> monad transformers would be rather useless if they didn't "interleave" their computation :)
18:53:29 <bgamari> bah, alright, I guess I was running into the issue we just solved in that case
18:54:08 <bgamari> I just assumed it was the monad forcing evaluation
18:54:31 <bgamari> I'll give it another try
18:54:36 <rwbarton> you would have to be a little careful
18:54:53 <bgamari> the current approach seems quite un-Haskellish
18:54:59 <rwbarton> @unmtl WriterT w Maybe a
18:54:59 <lambdabot> Maybe (a, w)
18:55:07 <rwbarton> that won't be able to "stream" its output
18:55:34 <elliott> oh, i see
18:55:42 <rwbarton> (which is sort of obvious because the computation could fail, and then you can't unprint things!)
18:55:46 <elliott> bgamari: you want to print out emits as they happen or whatever?
18:55:51 <elliott> to a network channel or anything like that
18:55:52 <bgamari> elliott: yes
18:55:58 <elliott> right, that's not as simple
18:56:30 <elliott> i don't think a monad transformer can really deal with that for you
18:56:30 <elliott> in that you're basically asking "what monad transformer lets me produce arbitrary effects" :)
18:56:42 <bgamari> yes, fair enough
18:57:07 <bgamari> I guess the correct solution would be to write a monad specificallly for this task, eh?
18:58:01 <elliott> I'd stick with what you have, really
18:58:08 <bgamari> Alright, fair enough
18:58:10 <rwbarton> yes
18:58:54 <rwbarton> btw
18:58:59 <rwbarton> > (concatMap . replicate) 3 "abc"
18:59:02 <lambdabot>   "aaabbbccc"
18:59:27 <elliott> > ((>>=) . replicate) 3 "abc"
18:59:28 <lambdabot>   Couldn't match expected type `[a] -> a -> b'
18:59:29 <lambdabot>         against inferred type ...
18:59:37 <cmccann> > replicate 3 =<< "abc"
18:59:38 <lambdabot>   "aaabbbccc"
19:00:03 <bgamari> heh, awesome
19:00:35 <bgamari> imperative languages have ruined me ;)
19:00:58 * elliott would suggest concatMap there rather than =<< :p
19:01:15 <tauntaun> From the vantage point marketability, it's functional languages that ruin.
19:02:07 <bgamari> tauntaun: Not what I want to hear ;)
19:02:08 <tauntaun> of*
19:02:32 <tauntaun> bgamari: I'm not happy about it either.
19:02:41 <cmccann> elliott: that =<< is concatMap :P
19:03:05 <bgamari> tauntaun: Good reason to stick with academia I suppose
19:03:18 <hpaste_> rwbarton pasted “hlint test” at http://hpaste.org/56716
19:03:26 * cmccann has no use for these silly list-specific functions
19:03:35 <tauntaun> Academia is full of strange characters, at least in CS departments.
19:03:37 <rwbarton> oh hlint thinks this is fine
19:03:51 <bgamari> tauntaun: You should see physics
19:04:10 <tauntaun> bgamari: I *was* in physics, switched to CS, then switched back.  I prefer human beings.
19:04:31 <dolio> How do they ruin marketability?
19:04:45 <elliott> cmccann: yes, it is, but still :)
19:05:32 <tauntaun> dolio: I meant it only as Paul Graham once did: FP spoils the programmer.
19:05:46 <rwbarton> clearly we need plint, runs your code through @pl and if it's shorter suggests that you replace it by the point-free version :)
19:05:53 <rwbarton> if it gets shorter, I mean
19:06:05 <dolio> Whose marketability does that ruin?
19:07:31 <DanBurton> rwbarton: there should also be a check that there aren't too many uses of (.)
19:07:44 <dolio> Several places will gladly hire people who know functional languages, and then put them on tasks where they don't get to use them.
19:07:58 <DanBurton> too true
19:44:24 <zachk> what is the function that is like words or lines but lets you define the character to split at?
19:46:26 <DanBurton> @hackage split
19:46:26 <lambdabot> http://hackage.haskell.org/package/split
19:46:29 <parcs`> splitAt
19:46:49 <Clint> linesBy
19:46:54 <parcs`> @hoogle splitAt
19:46:54 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
19:46:54 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
19:46:54 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
19:47:18 <parcs`> splitOn*
19:48:18 <DanBurton> > splitOn "," "Hello,world,foo,bar,baz"
19:48:19 <lambdabot>   Not in scope: `splitOn'
19:48:22 <DanBurton> boo
19:48:32 <DanBurton> > Data.List.Split.splitOn "," "Hello,world,foo,bar,baz"
19:48:33 <lambdabot>   Not in scope: `Data.List.Split.splitOn'
19:48:45 <DanBurton> lambdabot no split package? :(
19:49:18 <JoeyA> Does completion of main :: IO () automatically flush stdout :: Handle ?
19:49:48 <JoeyA> I guess I don't see why not.
19:52:12 <lispy> JoeyA: Although I don't know for certain, I think it has to in order for programs to not have incomplete output randomly
19:53:22 <JoeyA> Thanks
19:53:32 <sparkleshy> @pl (\f g x -> f x && g x)
19:53:32 <lambdabot> liftM2 (&&)
19:53:57 <sparkleshy> ooooh
19:54:02 <sparkleshy> I need to learn about monads.
19:58:27 <alt_mattr> cabal's data-files has me befuddled.  I can configure it, and see the files appear in <pkg>/share when I install, but I can't work out how to user the Paths_<pkg>.hs file from my code.
19:59:23 <alt_mattr> I found neil mitchell's suggestion to create a shadow Paths_<pkg>.hs but that shadow file is always preferred
20:00:05 <alt_mattr> I also found antoine's suggestion to use the cpp features (http://haskell.1045720.n5.nabble.com/How-to-use-cabal-s-data-files-feature-and-run-in-place-td4332192.html) but I can't make this work.
20:00:11 <ivanm> alt_mattr: you want to use the Paths_* module?
20:00:21 <ivanm> first of all, do a cabal configiure && cabal build first
20:00:27 <alt_mattr> yes, I need to access the data files
20:00:47 <alt_mattr> cabal build will fail because my code can't see Paths_<pkg> module
20:01:12 <ivanm> when launching ghci, use -idist/build/autogen
20:01:37 <ivanm> then "import Path_<package name>" where you want it
20:01:52 <alt_mattr> I have the import
20:02:55 <ivanm> also add Paths_<packagename> to Other-Modules in .cabal
20:03:08 <ezyang> This 'fail' and 'Monad' thing is just really unfortuante.
20:03:12 <ezyang> *unfortunate
20:04:06 <shachaf> ezyang: Don't worry, just keep fail = error.
20:04:17 <ezyang> but then list comprehensions don't work T_T
20:04:20 <shachaf> Now you've reduced it to a different really unfortunate thing.
20:04:22 <shachaf> Oh, that.
20:04:34 <shachaf> Well, just use Haskell 1.3.
20:05:29 <alt_mattr> ivanm: so I don't need a shadow Paths_<pkg>.hs file?
20:05:35 <alt_mattr> I think this is what tripped me up
20:05:46 <dolio> I don't buy the extra constructor argument, really.
20:05:50 <dolio> I don't think that's that big a deal.
20:05:55 <ivanm> alt_mattr: no, Cabal (the library) generates it when you do a configure && build
20:06:17 <ezyang> I get itchy and scratcy whenever I write a _ -> blah case.
20:06:33 <alt_mattr> ivanm: I know it generates it, but the only documentation I could find on data-files said that I need a shadow (hand-written) version as well
20:06:41 <ivanm> nah
20:06:49 <alt_mattr> I will turf it and see what happens
20:06:51 <alt_mattr> thanks
20:06:57 <ivanm> call ghci with the -idist/build/autogen
20:07:01 <ivanm> option
20:07:54 <alt_mattr> ivanm: that point to the install location, will it still work if I have not cabal install'ed first?
20:08:19 <ivanm> alt_mattr: use this when developing
20:08:53 <ivanm> you build your package that imports and uses Paths_<foo>
20:09:08 <alt_mattr> now I am confused.  When I do `cabal configure & cabal build` the Paths_<pkg>.hs in `build/autogen` points to directories that don't exist
20:09:12 <ivanm> when you run the generated executables, they already have those paths hardcoded in from build time
20:09:25 <ivanm> alt_mattr: because you haven't installed yet! ;-)
20:09:41 <alt_mattr> correct, I don't want to install yet, it is not ready for installation
20:10:25 <alt_mattr> I don't want to smash the files in the installed location, that will break the installed version while I am working on this updated version
20:10:30 <ivanm> ahhhh
20:10:31 <ivanm> right
20:10:42 <ivanm> in that case, you *might* want to make a copy of that module with your testing paths
20:10:44 <ivanm> and test with that
20:10:52 <ivanm> I've only used Paths_* to record version numbers before
20:11:04 <alt_mattr> right, and how do I get the testing version to be ignored when I finally _do_ cabal install?
20:12:14 <alt_mattr> perhaps the best solution is to bump my version number so the old one is still there if I need it - will this work?
20:14:35 <ivanm> alt_mattr: ummm.... good question :p
20:14:47 <alt_mattr> lets be bold - I will try it!
20:15:15 <ivanm> if you list it in the .cabal file (which you should, as you use it) then your one will get added to the tarball
20:15:17 <ivanm> which you don't want
20:16:34 <alt_mattr> well, it did what I wanted.  the old executable and data-files are still in the cabal install location, so I can run them when I need them.
20:16:39 <alt_mattr> thanks for your help
21:11:55 <startling> does `>>` just throw out the result of the first monad?
21:13:45 <geekosaur> yes
21:14:16 <Axman6> the first monadic action*
21:14:47 <startling> yeah that's what I meant. :/
21:14:56 <parcs`> startling: a >> b is identical to a >>= \_ -> b
21:15:23 <startling> and `>>=` just passes the result of the first to another?
21:16:07 <Axman6> yep
21:16:35 <Axman6> the results might be a slightly better choice of words (for example, the list monad passes many reaults)
21:16:41 <Axman6> s*
21:17:12 <startling> I guess I was viewing that as a single list rather than multiple list items, but sure.
21:19:32 <startling> oh! so `>>` is used where you would have a newline in do notation.
21:19:43 <Axman6> yep
21:19:46 <Axman6> without the <-
21:19:54 <startling> yeah, that makes a lot of sense.
21:20:05 <startling> it seemed kind of surperfluous at first.
21:20:34 <Axman6> it's just there because sometimes you want the effects of an action without the result, like say printing a line
21:20:46 <startling> right.
21:34:42 <zeiris> How do I print the full cmdargs help message? (When some sanitization of the args I get fails.)
22:31:53 <startling> when you bind a list, what do you get?
22:50:49 <DanBurton> >>= for lists is flip concatMap
22:53:28 <DanBurton> > [1,2,3] >>= return 3
22:53:30 <lambdabot>   No instance for (GHC.Num.Num [b])
22:53:30 <lambdabot>    arising from a use of `e_11233' at <in...
22:53:44 <DanBurton> > [1,2,3] >> return 3
22:53:45 <lambdabot>   [3,3,3]
22:53:52 <DanBurton> the "effect" of a list is repetition
22:54:12 <DanBurton> [1,2] >> [3,4] >> return ()
22:54:18 <DanBurton> > [1,2] >> [3,4] >> return ()
22:54:19 <lambdabot>   [(),(),(),()]
22:54:32 <DanBurton> > [1,2] >> [1,2,3,4,5] >> return ()
22:54:33 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
22:54:48 <silver> > [1,2,3] >> [1,2]
22:54:49 <lambdabot>   [1,2,1,2,1,2]
22:55:01 <silver> wat
22:55:40 <silver> > [1,2,3] >> 1:
22:55:40 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:55:46 <silver> > [1,2,3] >> (1:)
22:55:47 <lambdabot>   Couldn't match expected type `[b]'
22:55:48 <lambdabot>         against inferred type `[t] -> [t]'
22:56:00 <silver> > [1,2,3] >>= (1:)
22:56:01 <lambdabot>   No instance for (GHC.Num.Num [t])
22:56:01 <lambdabot>    arising from a use of `e_11231' at <in...
22:56:16 <tikhonjelvis> Having fun with lists?
22:56:41 <silver> ye
22:57:18 <tikhonjelvis> You can actually do some really neat stuff with lists and do-notation.
23:00:22 <frerich> Unfortunately I'm so spoiled by IO that the 'imperative' look of do notation totally confuses me when used with lists.
23:01:33 <Axman6> that's something you should definitely change
23:43:15 <Blkt> good morning everyone
23:44:33 <tikhonjelvis> morning
23:46:31 <QinGW> afternoon
23:47:54 <tikhonjelvis> QinGW: You must be really far away from me then...
