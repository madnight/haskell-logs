00:00:06 <ibid> elliott: as i said, a *general* book.  like the dragon book.  or appel's books
00:00:08 <Eduard_Munteanu> ibid: well, but it's just a pointer, really, and you can't do partial application or anything like that.
00:00:43 <elliott> ibid: right
00:01:31 <ibid> Eduard_Munteanu: partial application is mostly syntactic sugar
00:02:08 <Eduard_Munteanu> Perhaps if you have anonymous functions or other such machinery.
00:02:13 <ibid> Eduard_Munteanu: note that i didn't claim that C would be enough to cover the machinery.  i didn't even claim that much for pascal :)
00:02:14 <nus> jirka, read up on currying, and more generally, on (typed) lambda calculus
00:02:22 <Eduard_Munteanu> Ah.
00:03:03 <ibid> Eduard_Munteanu: but jirka seemed to have trouble even with the concept of a function as a value.  C does that, though it's very restricted
00:03:08 <CodeWeaver> boo
00:03:36 <Eduard_Munteanu> Yeah.
00:05:11 <Eduard_Munteanu> But perhaps the point is Haskell is considerably farther from the underlying machine. You can get by without understanding how they actually work.
00:05:34 <Eduard_Munteanu> (they == closures)
00:05:35 <ibid> oh, yeah, i agree if we are talking about understanding the language
00:05:54 <ibid> but the discussion seemed to be also about implementation
00:06:22 <ibid> of course, for a a proper understanding of haskell implementation, one needs to understand graph reduction
00:06:30 <insyde> so, now I'm being told this "read(take 1 . drop 1 $ list)::Int" is two arguments (passing to a constructor that takes an Int)
00:06:52 <ibid> really, the biggest obstacle to adding proper closures to C is that the common ABIs assume that a function pointer is only one word long
00:07:04 <tikhonjelvis> ibid: Getting aquainted with things like lambdas is a good first step before implementing Haskell, I think :)
00:07:22 <ibid> tikhonjelvis: oh, i agree
00:07:32 <tikhonjelvis> Doesn't C not allow nested functions anyhow?
00:07:33 <elliott> insyde: You forgot to enclose it in parentheses.
00:07:37 <ibid> tikhonjelvis: no
00:07:39 <elliott> tikhonjelvis: Only gcc does.
00:07:43 <Ngevd> @pl \f x -> f (f (f x))
00:07:43 <lambdabot> ap (.) (join (.))
00:07:49 <jedai> insyde: Well that's because application is left-associative
00:07:58 <tikhonjelvis> Only gcc *allows* them or only gcc *disallows* them?
00:07:59 <ibid> tikhonjelvis: or rather, it doesn't allow. (not sure what you meany by that double negative)
00:08:00 <jedai> f a b == (f a) b
00:08:10 <ibid> tikhonjelvis: gcc allows them as an extension
00:08:14 <tikhonjelvis> aha
00:08:36 <tikhonjelvis> But the standard does not have them?
00:08:40 <elliott> indeed
00:08:45 <insyde> elliott: thanks...I'm so lost with those rules
00:08:56 <jedai> so f read (take 1 . drop 1 $ list) = (f read) (take 1 . drop 1 $ list)
00:08:59 <ibid> tikhonjelvis: it forbids them, as i recall
00:09:42 <insyde> jedai: yup I see it
00:09:47 <jedai> insyde: in other words for that to work (f read) would have to be a function, that is f would have to take two arguments
00:10:13 <jedai> insyde: (since functions in Haskell are curried)
00:10:51 <insyde> jedai: I'd almost rather put in the extra parentheses everywhere than have to deal with this, but I'll get used to it eventually.
00:11:01 <insyde> jedai: thanks
00:13:32 <elliott> insyde: It might be best to stick wtih explicitly parenthesisnig everything until you gain a deeper understanding of how (.) and ($) work.
00:13:51 <tikhonjelvis> Of course, the best way to get a deeper understanding is to use them :)
00:13:53 <ion> (((((((((((Feel) free) to) put) extra) parentheses) everywhere) if) you) prefer) that.)
00:14:16 <insyde> elliott: gonna have to go with tikhonjelvis on that one haha
00:14:47 <otk> ion: unbalanced parenthesis
00:15:02 <insyde> ion: not using an editor?
00:15:05 <tikhonjelvis> No, they're fine. Emacs :)
00:15:25 <insyde> tikhonjelvis: lol I didn't check, so obviously otk is not using an editor lol
00:15:49 <otk> i have an internal shunting yard algorithm
00:15:55 <tikhonjelvis> It sometimes amusing matches smilies that are far away.
00:16:03 <elliott> tikhonjelvis: I'm not sure that's true. It'll encourage just shoving operators in a term until it compiles.
00:16:17 <elliott> Brute-force reasoning with the types is effective, though.
00:16:30 <tikhonjelvis> Shoving code into GHC until it compiles is a great strategy in generap :P
00:17:17 <tikhonjelvis> Besides, it's a great way to learn how the operators work. Inductive reasoning and all that.
00:28:22 * hackagebot wai-middleware-route 0.3.0 - Wai routing middleware  http://hackage.haskell.org/package/wai-middleware-route-0.3.0 (AlexanderDorofeev)
00:38:21 * hackagebot authenticate-kerberos 1.0.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-kerberos-1.0.0 (ArashRouhani)
01:03:19 <everythingWorks> How would i write a function which takes a function, one parameter for this function and the number of recursions this function should be invoked?
01:03:41 <shachaf> everythingWorks: What have you tried doing so far?
01:03:50 <shachaf> You should probably start with writing the function's type.
01:03:54 <hpaste> everythingWorks pasted “|” at http://hpaste.org/57098
01:04:19 <everythingWorks> So i can configure to run it twice, 3 times, 10 times or even 100 times in a row
01:06:05 <everythingWorks> hm..
01:06:10 <arcatan> everythingWorks: now add an integer parameter and pattern match over it
01:06:35 <everythingWorks> i think i got it
01:06:38 <arcatan> have two cases: when it's zero and when it's more than zero
01:06:47 <hpaste> everythingWorks pasted “moep” at http://hpaste.org/57099
01:07:02 <arcatan> that's pretty much it
01:07:28 <everythingWorks> :D
01:07:36 <nus> everythingWorks, what happens if you pass 0 ?
01:08:05 <everythingWorks> hm.. most likely a endless loop
01:08:57 <nus> so, what arcatan said, the base case is zero
01:09:12 <hpaste> everythingWorks pasted “moep” at http://hpaste.org/57100
01:09:14 <shachaf> Well, the base case is whatever you want it to be.
01:09:15 <everythingWorks> what about that?
01:09:42 <shachaf> 0 makes the most sense, but you have no hope of covering the entire domain.
01:09:44 <arcatan> nus: even if the base case is zero, you'd still have to handle the negative numbers
01:09:54 <elliott> everythingWorks: If count == 0, you don't want to apply f once.
01:09:57 <elliott> You want to apply it 0 times.
01:10:00 <everythingWorks> here its applied once
01:10:01 <everythingWorks> yep
01:10:03 <nus> arcatan, let it sink in by small bites (-:
01:10:07 <elliott> f x, f (f x), f (f (f x)). What comes before f x?
01:10:14 <arcatan> okay :P
01:10:47 <everythingWorks> how would i make such a "|" case?
01:10:48 <everythingWorks> like
01:10:56 <everythingWorks> | count <= 0 = <do nothing>
01:11:12 <everythingWorks> ah got an idea
01:11:31 <nus> we also have '_' for pattern matching
01:11:55 <elliott> everythingWorks: To go one step further, wrap f around everything.
01:12:01 <elliott> everythingWorks: To go one step back, [the opposite of that].
01:12:05 <elliott> So what comes before f x?
01:13:39 <everythingWorks> nus: what do you mean?
01:13:46 <hpaste> everythingWorks pasted “moep” at http://hpaste.org/57101
01:15:04 <elliott> everythingWorks: applyN f x 0 is perfectly well-defined.
01:15:10 <elliott> In fact, it's simpler than using 1 as the base case.
01:15:29 <elliott> Like I said: f x, f (f x), f (f (f x)) -- the transformation is wrapping everything in f (previous) each time.
01:15:36 <elliott> So what do you do to go the other way? You peel off an "f".
01:15:42 <elliott> So if 1 is f x, what's 0?
01:16:57 <cheater> 87.115.33.205
01:16:58 <everythingWorks> x? ;)
01:17:06 <cheater> sorry wrong window
01:18:05 <everythingWorks> :D
01:18:05 <everythingWorks> thanks
01:18:29 <everythingWorks> okay, all i did is I added: applyN _ arg 0 = arg
01:18:41 <everythingWorks> Think that would be very fine. :0
01:18:42 <everythingWorks> :)
01:19:13 <elliott> everythingWorks: you can remove the 1 case too then
01:20:18 <everythingWorks> elliott: if i use " count >= 1 " instead of "count > 1", yep! :D
01:20:36 <everythingWorks> you are good! :D
01:22:21 <jedai> Note that this function is often written : applyN f count = (!! count) . iterate f
01:23:01 <jedai> In fact I often use iterate and index directly rather than write applyN
01:23:43 <everythingWorks> whats (!! count :: Int)?
01:24:18 <jedai> everythingWorks: It's a section that extract the countnth element from a list
01:24:29 <jedai> > (!! 5) [1..]
01:24:30 <lambdabot>   6
01:24:53 <everythingWorks> ah, cool!
01:25:22 <everythingWorks> something like the index operator on imperative languages, eh? myArray[i]
01:25:39 <jedai> everythingWorks: yes, !! is the index operator on lists
01:25:51 <jedai> > [1..] !! 7
01:25:52 <lambdabot>   8
01:26:31 <jedai> (indices start at 0 like usual)
01:29:22 <cheater> hi!
01:29:30 <cheater> irene-knapp: you around?
01:30:41 <cheater> irene-knapp: i was wondering if you knew how good the sql lib you uploaded to hackage is for general mysql queries
01:31:15 <cheater> i know it's not meant for that but then there are no really esoteric ones in the log that i am trying to analyze
01:31:32 <cheater> i just need to get AST's of them
01:47:25 <hpaste> everythingWorks pasted “type deducing” at http://hpaste.org/57102
01:47:34 <everythingWorks> Can you explain me where's the actual problem here?
01:47:54 <everythingWorks> Its something about "Num" i think, as if i use a [Float] instead of a it'll work
01:48:03 <shachaf> There you go. That's the problem.
01:48:19 <shachaf> Look at the type of (/).
01:48:32 <shachaf> Type classes make things overly complicated when you're learning.
01:48:43 <shachaf> In particular numeric classes.
01:48:45 <jedai> everythingWorks: You make a sum of a (any insstance of Num) and divide it by 2, so you get an a
01:48:54 <ion> Also, look at the inferred type to get hints.
01:49:02 <shachaf> jedai: You can't divide any instance of Num by 2.
01:49:13 <ion> @type let avg xs = sum xs / 2 in avg
01:49:14 <lambdabot> forall a. (Fractional a) => [a] -> a
01:49:15 <jedai> everythingWorks: But here you say that the result must be a Float
01:49:17 <everythingWorks> additionally, i need a float obviously :D
01:49:30 <ion> See :i Num and :i Fractional in ghci.
01:49:31 <everythingWorks> as the avg of [3,6] would be 4.5
01:49:46 <jedai> Since you don't make conversion anywhere, that means that a = Float so your type is too general
01:50:28 <jedai> (and there's the matter that (/) is not a method of Num but of Fractional)
01:51:01 <jedai> shachaf: True but even (Fractional a) => [a] -> Float wouldn't work
01:51:14 <shachaf> jedai: Agreed.
01:52:22 <jedai> everythingWorks: Personally I tend to write those functions without signatures and then add it retrospectively by asking ghci the type
01:53:18 <everythingWorks> okay thanks
01:53:26 <everythingWorks> thanks :D
01:54:14 <everythingWorks> Im actually now using either this: avg :: (Fractional a) => [a] -> a or no signature at all. But i like using that signature (wouldnt produce any warnings)
01:55:15 <everythingWorks> the only problem here is, what if I have Int(egers), for instance?
01:55:27 <everythingWorks> As it only will work with Float and Double
01:55:38 <jedai> everythingWorks: And Ratio
01:55:52 <jedai> everythingWorks: Well you convert the integers beforehand
01:56:13 <jedai> everythingWorks: with map fromIntegral
01:57:35 <everythingWorks> jedai: yep that will work
01:57:48 <everythingWorks> #  avg (map fromIntegral [3::Int, 6::Int])
02:04:03 <everythingWorks> btw, shachaf yep your right, these numerical type system is kinda confusing: Float Floating Fractional RealFloat :p
02:09:12 <arcatan> pretty much everyone agrees that the numerical type classes need overhauling, but nobody is quite sure what should be done to them
02:10:06 <everythingWorks> arcatan: first, you could combine floating and fractional, couldnt you?
02:11:47 <jedai> everythingWorks: Globally what almost everyone want is to rewrite them to follow a more mathematical and principled way
02:12:11 <jedai> everythingWorks: Ring, body and so on
02:12:29 <arcatan> everythingWorks: i'm not sure if floating makes sense for types like Rational
02:12:42 <arcatan> jedai: body?
02:13:06 <jedai> everythingWorks: One of the main problem with the current one is that it is very ad-hoc, and it restrict somethings people want
02:13:36 <jedai> arash: (sorry Field, I forgot the right name for an instant and just translated the one in my language)
02:13:59 <jedai> arcatan: that was for you...
02:15:31 <jedai> everythingWorks: Right now Num has too many method, including some that don't make sense on some of the instance (vector, natural...) so you have the choice of forgetting it completely (but you have to use other operators names)
02:16:34 <jedai> or just not defining the methods that don't make sense but that get you some annoying runtime behaviour from time to time
02:17:01 <everythingWorks> okay. Really can't say much about it as I just started with haskell :D
02:17:42 <jedai> everythingWorks: But everyone agree that the current one is not right, neither for the beginners nor the experts
02:21:02 <arcatan> jedai: heh, the Finnish word for fields means municipality in English
02:21:53 <jedai> arcatan: Yes, funny that neither group nor ring seems to have the same problem (in my language, I can't speak for much more than that)
02:25:59 <arcatan> same goes for Finnish and Swedish, though the Swedish word for field would mean body. so at least some languages have a common term for it :)
02:38:24 * hackagebot bson-generic 0.0.5.1 - Generic functionality for BSON  http://hackage.haskell.org/package/bson-generic-0.0.5.1 (PetrPilar)
02:40:16 <luite> arcatan: translated from the German Körper (the reason that K is often used)
03:43:25 <harlekin> Are there any tutorials on lambdacube?
03:44:53 <canepazzo> ciao
03:45:00 <canepazzo> !list
03:50:36 <dibblego> is it possible to install cabal-install with ghc-7.2?
03:50:39 <xarch> hi
03:50:56 <dibblego> to the point, is it known to be impossible?
03:51:01 <xarch> do you think a cyclic representation of graphs is a good idea?
03:51:24 <xarch> or something like [([a], a, [a])] is better?
03:51:56 <ion> If you find yourself using 3-tuple you *probably* want a new data type instead.
03:51:57 <dibblego> note that ([a], a, [a]) ~~ ListZipper a
03:52:14 <xarch> yes
03:52:22 <xarch> but I just wanted to give the idea
03:52:37 <xarch> I would indeed define a new data type in a real code
03:53:12 <xarch> dibblego: hm
03:53:35 <xarch> are you sure it's note the zipper for lists with at least one element, and not that for regular lists?
03:53:38 <xarch> -e
03:53:43 <Axman6> not sure the ListZipper is useful there though
03:53:56 <dibblego> it is the list zipper
03:54:03 <dibblego> I am not sure how useful it is either
03:54:21 <xarch> that's juste a coincidence I think
03:54:25 <dibblego> I don't
03:54:26 <Axman6> yeah
03:54:44 <Axman6> well, in a graph, do the order of the elements of those lists matter?
03:54:51 <Axman6> (also, why are there two lists?)
03:54:53 <dibblego> mostly because I have written and used many zippers and there are not many more operations to think of
03:55:13 <xarch> well, anyway you don't use a zipper like you use a graph I think :p
03:55:16 <dibblego> I suspect that ([a], a, [a]) may be incorrect more than anything
03:55:19 <ion> For a cyclic zipper, perhaps use Seq instead of [].
03:56:38 <xarch> I don't care about zippers actually, I only want a graph
03:57:48 <ion> What do you want a graph for?
03:57:49 <byorgey> a representation of a data structure with sharing/"knot-tying" is almost never a good idea, UNLESS it is going to be read-only
03:58:07 <xarch> hm
03:58:14 <byorgey> xarch: why not use an existing library to represent graphs?
03:58:17 <xarch> I think it'll be read-only, so yes
03:58:21 <byorgey> @package fgl
03:58:21 <lambdabot> http://hackage.haskell.org/package/fgl
03:58:40 <xarch> byorgey: because I can't, it'll probably be in the context of a programming contest
03:58:50 <byorgey> ok, fair enough.
03:59:20 <ion> There’s this, too, for slightly different use cases. http://hackage.haskell.org/package/graph-rewriting
03:59:41 <byorgey> xarch: you could also do things like represent a graph as ([Vertex], Vertex -> [Vertex]), i.e. the list of vertices and a function telling you the neighbors of each vertex
04:00:01 <byorgey> that kind of "extensional" representation could be nice if it's read-only
04:00:19 <byorgey> it really depends on exactly what you want to do with the graph.
04:00:21 <xarch> that looks nice
04:00:38 <xarch> probably a BFS, but it'll depend
04:03:32 * hackagebot OSM 0.6.3 - Parse OpenStreetMap files  http://hackage.haskell.org/package/OSM-0.6.3 (TonyMorris)
04:08:33 * hackagebot OSM 0.6.4 - Parse OpenStreetMap files  http://hackage.haskell.org/package/OSM-0.6.4 (TonyMorris)
04:33:22 <mekeor> @pl \f x -> f x x
04:33:22 <lambdabot> join
04:40:24 <jtza8> Right, I've used Common Lisp for a few years now, and messed about with Scheme a bit. I'd like to give Haskell a go, but I have a few concerns, so I thought I'd ask a few questions.
04:41:17 <jtza8> For one thing, I've got some fear for a purely functional language, irrational, I know, but still...
04:41:35 <nand`> Don't worry, it's okay to be nervous before your first time
04:42:07 <jtza8> For example, I use OpenGL via FFI in CL, how would something that imperative translate into Haskell?
04:42:17 <jtza8> I mean, would it be usable?
04:42:19 <shachaf> jtza8: Haskell can express imperative code perfectly well.
04:42:22 <nand`> Haskell may be pure but its “impureness” wrappers are so well integrated that you can write code which feels like imperative
04:42:29 <nand`> here's an example of OpenGL/GLUT in Haskell:
04:42:43 <nand`> http://pastebin.com/BLBZfUVq
04:42:45 <mauke> The paste BLBZfUVq has been copied to http://hpaste.org/57110
04:42:49 <nand`> not very good, but you see the very imperative feel
04:43:04 <jtza8> Thanks
04:43:44 <nand`> note that even without abusing IO () like that, Haskell has many constructs for things you'd usually think you need imperative code for
04:43:54 <nand`> for example state transitions, Reader, Writer or similar
04:45:26 <jtza8> Okay, that makes me feel way better about Haskell in a practical "dirty" application.
04:45:58 <nand`> keep in mind haskell is intended for use as a real world programming language, unlike some others
04:46:34 <jtza8> That I will, so it's more like CL than Scheme in that respect, I assume.
04:46:58 <jtza8> Also, does OOP make any sense from a functional point of view?
04:47:12 <Saizan> it's purer than scheme, actually
04:47:19 <mauke> in some ways, yes
04:47:26 <mauke> but usually not in haskell
04:47:44 <nand`> how does scheme deal with the real world problem? does it ignore side effects?
04:47:46 <mauke> does anyone actually use OOHaskell?
04:47:52 <mauke> nand`: it just has side effects
04:48:20 <nand`> that's what I meant by ignoring them - pretends the functions have none from a language point of view
04:48:33 <mauke> yeah
04:48:42 <jtza8> Well, I guess that's the biggest challenge for me, switching over to FP.
04:49:07 * kejoki finally had the "Monad satori"
04:49:15 <nand`> jtza8: it will come naturally if you spend enough time with it
04:49:17 <mauke> @where lyah
04:49:17 <lambdabot> http://www.learnyouahaskell.com/
04:49:20 <nand`> ^
04:49:20 <Saizan> OOP makes sense in some cases where you've a small interface which is "implemented" by lots of different cases
04:49:34 <Saizan> and you can do that in haskell with records of functions
04:49:40 <ion> kejoki: A.k.a. the burrito satori
04:50:11 <aristid> Saizan: and SomeException seems to be pseudo-OOP, too? :P
04:50:16 <kejoki> ion: I didn't realized burritos were sartorial.
04:50:20 <nand`> jtza8: the hierarchical and interface components of OOP are made unnecessary in haskell because it has powerful type classes instead
04:51:10 <kejoki> ion: although I had heard that the clothes make the flan.
04:51:11 <Saizan> aristid: the Exception hierarchy seems pretty anti-OOP to me, it's completely based on downcasts :)
04:51:19 <nand`> and as a pure functional language it doesn't need or use state either; sure you could model OOP by using a State [Object] but in practice recommending something like that will result in a muddled mess between OOP and functional that doesn't quite know what it wants to do
04:51:20 <echo_bot> and as a pure functional language it doesn't need or use state either; sure you could model OOP by using a State [Object] but in practice recommending something like that will result in a muddled mess between OOP and functional that doesn't quite know what it wants to do
04:51:48 <nand`> what the hell is echo_bot
04:51:48 <echo_bot> what the hell is echo_bot
04:51:52 <shachaf> @where ops
04:51:52 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:51:52 <echo_bot> @where ops
04:51:52 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:51:53 <echo_bot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:51:53 <echo_bot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:52:00 --- mode: ChanServ set +o mauke
04:52:00 --- kick: echo_bot was kicked by mauke (echo_bot)
04:52:12 <tejaswi> echobot?
04:52:40 <nand`> A popular channel as #haskell is not exactly the best place to test a bot like that, try #echobot-test or something
04:53:07 <kejoki> that had to be a troll.
04:53:16 <tejaswi> definitely
04:53:36 <jtza8> Okay, as for how I'd structure my code, and think of the big picture... is there material which addresses that?
04:54:00 --- mode: mauke set -o mauke
04:54:24 <nand`> jtza8: the concept of functional programming is to use bottom up design, start with simple functions that you know work and can test easily, then combine them to make bigger functions
04:54:53 <nand`> I personally try to keep functions as general as possible eg. using (Foldable t) instead of [] so I can re-use the same algorithms on a Tree if I want to
04:55:28 <nand`> another good practice is to separate algorithmic steps into different sub-functions, instead of making one big function that does lots of things
04:55:31 <kejoki> jtza8: after a few weeks with lyah, Real World Haskell, and the tutorials on haskell.org I have *finally* learned to *really pay attention to types*
04:55:45 <kejoki> and that restructured my code a lot.
04:55:56 <aristid> nand`: i'm not sure if using Foldable is actually so useful
04:56:20 <aristid> nand`: Foldable is basically just toList, so why not use lists?
04:56:35 <nand`> may have been a bad example
04:57:06 <ion> If you use MonadPlus m => m a, you can switch from [] to Logic when you need the features. :-)
04:57:58 <kejoki> jtza8: previous life experience has learned me t' never walk into a roomful o' cooks and ask a general question about cooking...unless I want t' see a entertainin' discussion about which eggs boil best at what altitude...
04:58:35 <jtza8> Well
04:58:42 <jtza8> It helps,
04:58:57 <kejoki> and is entertaining, yes.
04:58:57 <jtza8> especially if you don't know anyting about eggs to start off with :P
04:59:09 <nand`> aristid: come to think of it, is there a sort of Foldable that requires combinators of the type (a -> a -> a) requires them to be associative?
04:59:34 <nand`> Because if so, it should be possible to write a structure which folds in parallel
05:00:07 <ion> kejoki: Oh, i expected you to be Finnish based on your nick, but it seems you’re on IRC from the other side of the lake. :-)
05:00:42 <jtza8> I've been confused before as to which functions should be grouped togeather in which files so I get a usable system... and I know everyone's got an oppinion on that, but I don't, so yeah.
05:00:56 <jtza8> I'd group them by type, I guess.
05:01:03 <jtza8> But that
05:01:14 <jtza8> is probably best answered by looking at code.
05:01:25 <jtza8> Which is what I'll do.
05:01:31 <jtza8> Thanks for all the answers.
05:01:38 <kejoki> ion: heh.  I used to live in Hancock, Michigan.  Home of Suomi College.
05:02:37 <kejoki> jtza8: Types seem to be the best way to understand almost anything in Haskell, definitely.
05:07:58 <dibblego> nand`: there is a Semigroup, which is expected (not enforced) to be associatieve
05:08:10 <dibblego> there are a couple of semigroup packages on hackage
05:13:27 <everythingWorks> Can i write this easier:  [ a | a <- [1..20], a `mod` 3 /= 0] ## filter (\x -> x `mod` 3 /= 0) [1..20]
05:15:28 <ion> What’s wrong with that form?
05:15:45 <aristid> everythingWorks: maybe introduce something like this? divisible n x = x `mod` n == 0
05:15:51 <aristid> then, filter (divisible 3)
05:16:00 <ion> Hehe, i was just about to suggest that. :-)
05:17:20 <everythingWorks> yeah that sounds good to me :D
05:17:21 <everythingWorks> thanks
05:24:07 <akosch> everythingWorks: you could also use (/= 0) . (`mod` 3) to omit the lambda, but I guess this isn't easier :)
05:25:23 <jtza8> kejoki: Well, I've started reading Real World Haskell. Looks like an awesome book so far.
05:32:04 <akosch> can I use memoization techniques with pure code somehow?
05:32:50 <shachaf> akosch: In some cases, yes.
05:32:51 <mwc> akosch: sure, use something like a pure, boxed array or a set to store your memo values, then just redirect your recursion through that.
05:33:08 <dibblego> akosch: this paper discusses some answers to this question http://research.microsoft.com/en-us/um/people/simonpj/papers/weak.htm
05:33:11 <shachaf> Sometimes you can cause memoization to happen through sharing and the structure of your datatype.
05:33:15 <akosch> mwc: ok, so I have to make it explicit?
05:33:20 <zenzike> I'm playing with criterion, and wondering: when is it better to use whnf, rather than nf? I'm struggling to think of an example where I'm benchmarking, but I don't want the entire value to be evaluated (unless it's an infinite structure, maybe?)
05:33:22 <shachaf> You can also use unsafePerformIO.
05:33:43 <mwc> shachaf: well, that's hardly pure now is it :)
05:33:43 <dibblego> unsafePerformIO is listed in aforementioned
05:34:18 <shachaf> mwc: Well, it depends on what you mean by "pure".
05:34:27 <dibblego> uh oh
05:34:29 <akosch> shachaf: any examples on the sharing technique?
05:34:43 <mwc> am I the only person who uses ST instead of unsafePerformIO?
05:35:03 <dibblego> mwc: No, there are two of us at least!
05:35:03 <akosch> shachaf: by pure I mean without unsafePerformIO, that's a bit of cheating ;)
05:35:05 <kejoki> great.  I forsee another Purity Test.
05:35:18 <shachaf> akosch: Well, the interface exposed is referentially transparent.
05:35:30 <c_wraith> mwc: I don't think there's anyone who uses unsafePerformIO instead of ST when that solves the same problem
05:35:31 <shachaf> It's not as if mutation isn't going to be happening anyway -- it's just that GHC will do it implicitly.
05:36:01 <dibblego> c_wraith: there are, I've seen their code
05:36:14 <c_wraith> oh.  now I'm sad
05:36:25 <dibblego> sorry, I kind-of regretted telling you that :(
05:36:47 <mwc> if it makes you feel any better, I think it's just because the ST type signatures scare people
05:36:59 <c_wraith> hopefully, I will forget after finally sleeping.  or maybe shrug it off as a sleep-dep-induced nightmare
05:37:07 <mwc> unsafePerformIO and a simple IORef is a lot more "friendly" to an inexperienced person.
05:42:29 <Veinor> what's the syntax for passing multiple options to ghc through cabal build?
05:50:49 <fbern> it seems that all time related libraries have a dependency to old-locale. Is there a new locale library?
06:18:43 <everythingWorks> kekekekeke:
06:18:50 <everythingWorks> *Main>  (sqrt 15) * (sqrt 15) produces  15.000000000000002
06:18:51 <everythingWorks> :P
06:19:10 <donri> the magic of floating point precision
06:21:00 <mwc> everythingWorks: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.6768 (Kahan, "What Every Computer Scientist Should Know About Floating Point Arithmetic")
06:21:51 <everythingWorks> thanks :D
06:29:59 <chrisdone> wow. 851 people in here. i swear last year 600 was a lot
06:30:53 <hpc> mwc: aw, i was really hoping for "THEY ARE NOT EXACT" in a giant font on one page
06:37:25 <kejoki> _|_ ?
06:38:23 <Saizan> fbern: no
06:39:04 <kejoki> reading the ST monad doc.
06:39:08 <fbern> Saizan: thank you!
06:39:23 <ksf> let's call monads tubes.
06:40:07 <hpc> ksf: and monad transformers can be a series of them!
06:40:15 <ksf> ...just got reminded of the need for a more friendly term by seeing "By reduce I mean a fold (a catamorphism on the monoid of sequences, to be pedantic)"
06:40:28 <nand`> hpc: thus giving us the InternetT monad
06:40:43 <ksf> nah, actually it's tubes inside tubes.
06:41:07 <irene-knapp> .
06:41:34 <shachaf> kejoki: Pronounced "bottom", if you want a word that Google can find.
06:41:51 <shachaf> Represents a computation that doesn't yield a value, like "let x = x in x" or "undefined".
06:41:54 * kejoki favors calling doors "jars" so that his car will make sense when it says "Your door is ajar."
06:42:20 <kejoki> shachaf: Thank you!
06:42:26 <aadrake> Question about the mwc-random library/monadic misunderstanding:  Why is gen <- create; standard gen difference from create >>= standard?
06:42:40 <aadrake> s/difference/different
06:42:45 <shachaf> aadrake: Why don't you tell us?
06:42:47 <ksf> aadrake, it's not.
06:42:55 <ksf> well, except than one needs a do block.
06:42:59 <ion> OptimusPrimeT
06:43:41 <aadrake> ksf: The reason I ask is because using gen <- create; standard gen will produce a new number every time standard gen is called
06:43:52 <aadrake> ksf: However, create >>= standard gives the same number repeatedly
06:44:36 <aadrake> ksf: I thought they were precisely the same, but the result is not the same
06:44:36 <shachaf> You haven't provided enough context to be able to give you a useful answer.
06:44:41 <ksf> that's some weirdness in the surrounding code, then. can you hpaste.org a more complete example?
06:44:57 <ion> @crystalball
06:44:57 <lambdabot> Unknown command, try @list
06:45:03 <aadrake> ksf: I didn't use any surrounding code, just ghci.
06:45:08 <Saizan> aadrake: oh, so the difference is actually between do g <- create; x <- standard g; y <- standard g; return (x,y) and using (create >>= standard) twice?
06:45:43 <ksf> "do {gen <- create; standard gen}" desugars to "create >>= \gen -> standard gen", which is equivalent.
06:45:48 <kejoki> @smartaleck
06:45:49 <lambdabot> Unknown command, try @list
06:45:55 <Saizan> aadrake: if so the answer is that in the former case you reuse the same 'g' twice, while in the latter you create two distinct g's
06:46:14 <Saizan> aadrake: and the generator gets mutated by standard
06:46:43 <aadrake> Saizan: Well, I mean if you have g <- create; then you can call standard g as many times as you want and get numbers sampled from a standard normal distribution
06:46:59 <aadrake> Saizan: If you just call create >>= standard repeatedly, it's always the same number
06:47:15 <Saizan> aadrake: yeah, that's what i meant
06:47:37 <shachaf> What are "create" and "standard"?
06:47:55 <Saizan> aadrake: in the latter case you produce a new generator every time, and so you're back from the start
06:47:57 <aadrake> shachaf: Functions from the mwc-random library.
06:48:04 <Veinor> create :: PrimMonad m => m (Gen (PrimState m))
06:48:12 <ksf> aadrake, you want to compare that to create >>= \g -> standard g >> standard g
06:48:14 <aadrake> Saizan: But isn't the seed different each time?
06:48:21 <Veinor> aadrake: nope.
06:48:32 <Veinor> create = initialize defaultSeed
06:48:52 <aadrake> Veinor: I suppose I was thinking it would be seeded from the hardware clock each time it was called
06:49:00 <rwbarton> It says so right in the documentation. "Finally, create makes a generator from a fixed seed. Generators created in this way aren't really random."
06:49:01 <shachaf> Oh, "every time stnadard gen is called"
06:49:01 <ksf> you've got to do that manually.
06:49:04 <aadrake> Veinor: Otherwise, it's not really random
06:49:17 <ksf> well, really random isn't usually what one wants ;)
06:49:19 <kmc> aadrake, you probably want withSystemRandom
06:49:29 <aadrake> rwbarton: I didn't supply a seed, so I'm not sure where the fixed seed originates
06:49:39 <rwbarton> it is fixed
06:49:50 <Veinor> it's built in to mwc-random
06:49:51 <rwbarton> it originates from... the author of the library? don't understand the question
06:50:07 <ksf> like when compiling some code and using the RNG for generated identifiers: you still want the output to be deterministic.
06:50:07 <aadrake> rwbarton: Oh I understand now.  That's really odd.
06:50:15 <kmc> http://hackage.haskell.org/packages/archive/mwc-random/0.11.0.0/doc/html/src/System-Random-MWC.html#line-547
06:50:16 <ksf> (though GHC disagrees on that)
06:50:48 <ksf> and getting the time needs IO, of course.
06:51:03 <aadrake> The motivation for all this was I am trying to get some random numbers inside a function, which in Haskell is surprisingly complicated.
06:51:08 <aadrake> ksf: So I've learned :)
06:51:10 <kejoki> "Anyone who considers arithmetical methods of producing random digits is, of course, in a state of sin." J von Neumann
06:51:27 <Veinor> aadrake: it's not complicated. it's just different :)
06:51:35 <kmc> it's complicated too
06:51:48 <kmc> anyway often the nicest way is to generate a lazy infinite list of random numbers
06:51:50 <ion> kejoki: or cos
06:51:50 <kmc> and pass that into the function
06:51:56 <kmc> but i don't think mwc-random supports that API
06:51:56 <ksf> it's not more complicated than sanely managing seeds in an imperative language.
06:52:10 <kmc> the standard System.Random does, but it sucks as a random number generator
06:52:19 <aadrake> ksf: Perhaps, but I don't care about the seeds.  I just want some random numbers
06:52:31 <Veinor> oh, that's annoying
06:52:31 <aadrake> err, ksf, not kmc
06:52:38 <ksf> most people might not care, but game programmers (like me) are hawk-eyes when it comes to reproducibility of runs influenced by rngs
06:52:41 <kmc> i issue ksf a Standard #haskell Fallacy Card
06:53:00 <Veinor> create >>= standard is entirely deterministic
06:53:04 <Veinor> but it still has type IO Double
06:53:11 <kejoki> ion: this one *really* applies to Hakell: "Young man, in mathematics you don't understand things. You just get used to them."
06:53:21 <ksf> Veinor, yep, that's ugly.
06:53:56 * kejoki where'd that 's' go?
06:53:58 <Veinor> (or ST s Double, i guess)
06:54:04 <aadrake> All I was really after was a way to grab a random number from within a pure function without having to call another function or meddle in IO, but I don't think that's possible.
06:54:25 <kmc> "<complicated solution to simple problem in Haskell> is no worse than <complicated solution in other languages to problem nobody cares about>"
06:54:46 <Veinor> kmc: what's wrong with System.Random?
06:54:56 <kmc> aadrake, your function isn't a function then
06:55:03 <kmc> Veinor, it's slow and produces poor-quality randomness
06:55:40 <ksf> kmc, you try to run two game instances in sync without syncing RNGs
06:56:18 <ksf> ...or tell the support people to tell the users that multiuser not working is just bad luck
06:56:35 <aadrake> kmc: Well, it started out that way, but then I encountered the odd complexity involved in generating random numbers in Haskell.  However, after I thought about it from a side-effect free perspective it makes sense.  Not that it becomes any less annoying, just consistent
06:56:49 <ksf> ...or try to do replays without doing the same.
06:57:18 <ksf> ...or regenerate a HUGE map from seed without messing up the savegame.
06:58:03 <ion> For networked stuff where the state of the RNG must match on multiple nodes, i’d think twice about trusting System.Random to have exactly the same behavior everywhere (different versions, different architectures etc). I’d include a PRNG with the code.
06:58:10 <kmc> right, i shouldn't say that nobody cares about RNG seed management
06:58:14 <kejoki> aadrake: I just read something about producing a psuedo-random sequence in Haskell, I'm trying to find it.
06:58:15 <kmc> but in many applications you do not
06:58:20 <kejoki> it was easy.
06:58:56 <kmc> aadrake, it's not even about side effects.  it's about the fact that if f is a function, (f 7) must always be the same value, it can't be 3 sometimes and 8 other times
06:58:58 <aadrake> kmc: I was looking to do something like 1+(some random number) but in hindsight that doesn't really match with the whole "function always returns the same value" thing.
06:59:02 <kmc> right
06:59:03 <ksf> aadrake, the cheapest solution (and morally perfectly acceptable) is to pass the function an infinite list of random numbers.
06:59:18 <kmc> except you can't easily do that with mwc-random, to my knowledge
06:59:44 <kmc> you have to use the crappy System.Random or hack around it or use something else i don't know about
07:00:04 <Saizan> can't you use lazy ST?
07:00:14 <aadrake> I'm not tied to mwc-random.  I can use normaldistribution.
07:00:15 <kmc> maybe
07:00:52 <ion> random :: Num a => a; random = 4
07:01:02 <ion> -- dice roll
07:01:53 <ksf> I think that's a case for Acme.*
07:02:04 <ksf> Acme.Universe.Nondeterministic?
07:02:18 <aadrake> kmc: There is only a subtle difference between passing in a list of random numbers as arguments and just getting the random numbers within the "function."  In the end, unless you know the random numbers then the function output is not reproducible.
07:02:32 <ion> Perhaps a module that uses TH to generate a random number upon compilation.
07:02:42 <ion> And export only that.
07:02:47 <kmc> it's not a subtle difference.  a function's result is allowed to depend on its arguments, but not anything else
07:03:04 <kmc> http://hackage.haskell.org/packages/archive/acme-colosson/0.1/doc/html/Acme-Colosson.html
07:03:05 <aadrake> kmc: In the first case, the non-determinism is coming as an argument and is not originating from within the function, while in the second case the results are variable because of things within the function itself.
07:03:15 <ksf> ...whether you pass a seed or the list is just a matter of code organisation.
07:03:52 <kmc> Saizan, it doesn't work because there's no PrimMonad instance for lazy ST
07:04:09 <ksf> they can even end up executing the same assembly, at runtime
07:04:31 <kmc> i don't know if it would be safe to add one
07:04:38 <ksf> aadrake, nope, you have to pass the seed.
07:04:41 <ion> I like how the Acme modules are near the top in the hackage package list by virtue of having a category that begins with A.
07:04:45 <Saizan> kmc: unsafeInterleaveST then :)
07:04:47 <ksf> otherwise it's not a function, again.
07:04:51 <kmc> sure
07:05:20 <kejoki> ion: hah.  Of course, it's right there in lyah.
07:05:21 <aadrake> It's not such a big deal to pass in a seed or infinite list of random numbers, but it does seem needlessly complex.
07:05:50 <kmc> i think "needless" is the wrong word
07:05:58 <roconnor> @type foldMap
07:05:59 <kmc> it preserves a fundamental property of the language
07:05:59 <lambdabot> Not in scope: `foldMap'
07:06:03 <kmc> but, it is inconvenient
07:06:04 <roconnor> @hoogle foldMap
07:06:04 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:06:04 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
07:06:31 <ksf> he who prefers convinience over safety deserves neither
07:06:51 <kmc> it depends, ksf
07:06:52 <roconnor> @type (***)
07:06:52 <aadrake> kmc: Well there is a point to the complexity, but it introduces extra work.  Sometimes I think Haskell has just gotten rid of some complexity and added as much on the other side.
07:06:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:06:53 <mrotondo> what's wrong with passing in the seed? that's what you have to do in most languages
07:06:53 <kmc> it's a tradeoff
07:06:57 <mornfall> ksf: And you sir deserve Ada. :P
07:07:20 <aadrake> mrotondo: I have never had to both with seeds in any language I've used (unless I wanted reproducible random numbers).
07:07:23 <kejoki> aadrake: In the "Input and Output" chapter of Learn you a Haskell there is a section on randomness that shows a simple way to deal with this.  Not the best way, or the most Haskelly way; just a simple way--so you don't get mired in the details.
07:07:28 <kmc> aadrake, imo the simplest way to get random numbers is System.Random.randomRIO
07:07:38 <kmc> randomRIO :: (Random a) => (a, a) -> IO a
07:07:46 <mrotondo> why wouldn't you want reproducible random numbers? seems strictly better than unreproducible ones
07:07:47 <aadrake> bother, not both
07:07:51 * kejoki frowns while considering the pedanticness of pedanticness
07:08:09 <aadrake> mrotondo: Well, in stochastic processes applications the reproducibility is irrelevent.
07:08:17 <aadrake> mrotondo: At least for my purposes
07:08:18 <kejoki> I hear eggs boiling.
07:08:26 <ksf> aadrake, what about debugging?
07:08:28 <mrotondo> unless you want to test your code
07:08:30 <kmc> aadrake, yes, you're right that Haskell has just gotten rid of some complexity and added to the other side
07:09:01 <kmc> whether it's "as much" complexity is a long and probably fruitless debate
07:09:03 <ksf> can't run sane unit regression tests without it.
07:09:05 <aadrake> ksf: In that case I can elect to supply a seed to the PRNG
07:09:17 <mrotondo> so just always supply a seed
07:09:20 <mrotondo> think about it
07:09:26 <mrotondo> it needs to get the seed from somewhere, right?
07:09:31 <roconnor> @hoogle execWriter
07:09:32 <lambdabot> Control.Monad.Trans.Writer.Lazy execWriter :: Writer w a -> w
07:09:32 <lambdabot> Control.Monad.Trans.Writer.Strict execWriter :: Writer w a -> w
07:09:32 <lambdabot> Control.Monad.Writer.Lazy execWriter :: Writer w a -> w
07:09:32 <kmc> mrotondo, it's just less convenient to do it explicitly
07:09:34 <ksf> aadrake, and you'll be able to do so quickly, because haskell forced you to manage your seeds :)
07:09:36 <aadrake> mrotondo: No, because I don't want to always use the same seeds
07:09:43 <kmc> "just always call malloc yourself, it needs to get the memory from somewhere"
07:09:46 <mrotondo> exactly, so you pass in time
07:10:03 <ksf> aadrake, if you do stochastics, I'd even factor out the RNG itself.
07:10:22 <aadrake> mrotondo: For example, when producing an ensemble of simulations of some stochastic process, if you use the same seed then all the paths will have the same behavior
07:10:27 <ksf> as you might want to replace that, or test one against the other, do accuracy vs. speed tradeoffs, etc.
07:10:32 <kmc> sigh
07:10:37 <mrotondo> yes exactly
07:10:41 <mrotondo> that's great
07:10:44 <roconnor> @type fst
07:10:44 <lambdabot> forall a b. (a, b) -> a
07:10:46 <roconnor> @type first
07:10:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:10:57 <kmc> random numbers in Haskell are a pain, aadrake has correctly noticed that, maybe we should move on instead of trying to convince aadrake that they're wrong for wanting them not to be a pain
07:10:57 <mrotondo> you want to be able to reproduce your results, given all the same inputs
07:11:07 <aadrake> mrotondo: I think you're missing my point.  I know that I could pass in the system time as the seed always, but what's the point if I don't want that anyway?
07:11:07 <kmc> this always happens here
07:11:21 <kmc> it's impossible to acknowledge a drawback of the language and move on
07:11:31 <kmc> people have to invent some tortured logic for why that flaw is secretly a virtue
07:11:34 <mrotondo> i'm not coming from any principled point on haskell here
07:11:39 <mrotondo> i just started learning it yesterday
07:11:54 <ksf> well, if you are absolutely sure you don't want to have a reproducible RNG, ever, just use unsafePerformIO or similar and be done with it.
07:11:54 <mrotondo> it just makes sense that you would be able to control your program's output, in any language
07:12:03 <Saizan> kmc: making hidden state explicit is a general virtue of the language
07:12:04 <rwbarton> It is also impossible to accept that perhaps the asker has good reasons for the choice that they have made
07:12:13 <kmc> unsafePerformIO is usually not going to give the semantics you want
07:12:16 <ksf> the whole thing only gets complicated imho when it comes to threading, btw.
07:12:25 <kmc> if you want to "be done with it" then I suggest using IO
07:12:29 <kmc> randomRIO :: (Random a) => (a, a) -> IO a
07:12:44 <roconnor> @hoogle getSum
07:12:44 <lambdabot> Data.Monoid getSum :: Sum a -> a
07:12:54 <aadrake> mrotondo: Controlling the output kind of runs counter to the whole idea of randomness in processes.  I don't want the same process every time.
07:13:05 <Saizan> something can be a virtue and also be inconvenient
07:13:22 <mrotondo> you aren't going to get "randomness" no matter what you do… how do you think RNGs work?
07:13:22 <ksf> aadrake, mathematically, yes, but from a software design POV?
07:13:33 <kmc> ugh
07:13:36 <mrotondo> er, PRNGs
07:13:44 <nand`> you can also use getStdGen :: IO StdGen
07:13:50 <aadrake> mrotondo: I am well aware of the way PRNGs work.  I'm not here to nit-pick about that.
07:14:26 <ksf> *software engineering
07:14:58 <nand`> any “true” random generator will inevitably be IO Something
07:15:01 <aadrake> ksf: If the situation arises where I need to reproduce some sample path for a process then I can always supply a seet in any old language.  I understand why things are the way they are in Haskell, but I think everyone here will agree that it's a pretty impressive level of complexity for what amounts to rand() in most other languages.
07:15:10 <ksf> I prefer to keep all non-determinism where I can't avoid it, and that's concurrency.
07:15:45 <kmc> aadrake, no, as we've seen they won't agree that, there is all kinds of cognitive dissonance preventing them from agreeing
07:16:07 <aadrake> kmc: A fine point.
07:16:45 <ksf> I completely accept the fact than some people might want an impure random function because they don't care.
07:16:58 <ksf> but reproducibility is going to be impossible as soon as more than one thread is involved.
07:17:02 <ion> unsa…O
07:17:59 <ksf> (and I've hunted down enough unreproducible bugs to want to avoid ever having to do it again)
07:18:07 <mrotondo> just
07:18:13 <mrotondo> this is important
07:18:51 <mrotondo> aadrake: what do you think this c program does?
07:18:52 <mrotondo> int main() { int i; for (i = 0; i < 10; i++) { printf("%d\n", rand()); } }
07:18:59 <kejoki> mrotondo: when it's important.  Most of the time, even.  But, when it doesn't matter, it does not matter.
07:19:35 <ksf> (one of which I sent back to the testers three days in a row because it plainly couldn't happen, until they put a phone with it happening on my desk, which resulted in a week of hunting and finally spotting a bug in the JVM)
07:20:38 <ion> replicateM_ 10 (print =<< randomIO)
07:21:01 <mrotondo> i don't know what that does, like i said i only started on haskell yesterday
07:21:20 <mrotondo> my point is that that c program is not very useful, because it prints the same 10 numbers every time you run it
07:21:49 <mrotondo> you _have_ to call srand with some seed to get usefully pseudorandom output
07:22:01 <mrotondo> or you can call it with a known key to get reproducible output
07:22:29 <kmc> that seems irrelevant to the current issue
07:22:35 <aadrake> mrotondo: You will probably enjoy Haskell and think it's the best thing ever, but sooner or later (probably sooner) you will try to solve a problem that is frustratingly complicated in Haskell compared to some other languages.  You have to take the good with the bad.  That's just the way it goes.
07:22:39 <kmc> libc could just as easily call srand() at program start
07:22:55 <ksf> yep.
07:23:05 <mrotondo> but it doesn't because that would be awful!
07:23:26 <mrotondo> ok
07:23:29 <ksf> the issue is really a haskell one, and that is guaranteeing a function works the same in a parallel setting as in a non-parallel setting.
07:23:35 <kmc> aadrake, yeah
07:23:41 <ion> Interfacing with C from Haskell is very easy, too.
07:23:53 <kmc> i'll add that those frustratingly complicated problems do get better once you know the language really well
07:23:56 <kmc> but this can take years
07:24:06 <mrotondo> at this point i'm confused
07:24:11 <kmc> if you're just starting out it feels like hitting a brick wall
07:24:13 <ksf> ...and behave the same with different compilers, or optimisation options.
07:24:24 <mrotondo> why is implementing a seed prng in haskell any harder that it is in another language?
07:24:43 <hpc> @hoogle Int -> StdGen
07:24:44 <lambdabot> System.Random mkStdGen :: Int -> StdGen
07:24:44 <lambdabot> Prelude (!!) :: [a] -> Int -> a
07:24:44 <lambdabot> Data.List (!!) :: [a] -> Int -> a
07:24:45 <mrotondo> rand once you've called srand is just a partially applied function
07:24:53 <ksf> it's not harder, it's just not prudent to provide a global seed store.
07:25:08 <ksf> C could arguably do the same, and, IMNSHO, it should.
07:25:27 <kmc> rand_r
07:25:38 <mrotondo> but can't you just define a new function that's your partially-applied (seeded) rand?
07:25:45 <mrotondo> and pass that around or whatever?
07:25:59 <Saizan> mrotondo: it'd make sense only with access to mutation
07:26:03 <kmc> mrotondo, you can't use it as a pure Int or whatever, because it updates some mutable state and produces a different Int each time
07:26:16 <kmc> so you could have something like:   Seed -> IO Int
07:26:22 <ksf> ...not without unsafe*, that is.
07:26:23 <mrotondo> can't use what as a pure Int? sorry if i'm missing something
07:26:23 <kmc> or probably,  Seed -> IO (IO Int)
07:26:36 <mrotondo> why is IO coming into this?
07:26:36 <kmc> mrotondo, the RNG that came from "partially applying" the seed
07:26:42 <mrotondo> yeah
07:26:56 <kmc> mrotondo, because your RNG has some state
07:27:00 <kmc> and either you explicitly pass that state to/from functions
07:27:08 <mrotondo> hm
07:27:08 <kmc> or it's mutable state that you access with IO actions
07:27:10 <kmc> (or ST actions, etc.)
07:27:24 <mrotondo> can't you just recurse?
07:27:24 <exFalso> hello there. is there a type level peano number package?
07:27:30 <ksf> Seed -> (Seed, Int) is the natural type of such kind of beast.
07:27:41 <ksf> an IO or ST or State wrapper is just plumbing.
07:27:42 <mrotondo> re-apply the values you've generated so far to your function and re-store it?
07:27:45 <kmc> mrotondo, I think you should learn more Haskell before continuing this discussion
07:27:57 <aadrake> mrotondo: The issue is that it's a fundamental property of the language that functions should not have non-deterministic output, which is exactly what I'm trying to accomplish. :)
07:27:58 <mrotondo> fair enough i guess
07:28:16 <mrotondo> i guess i was assuming you could redefine functions
07:28:20 <mrotondo> sounds like that's state too
07:28:36 <mrotondo> well
07:28:37 <kejoki> mrotondo: you'll have to stop thinking in terms of "storing" things.  It's miserably frustrating.
07:28:42 <mrotondo> k
07:29:15 * kejoki was a noob a few weeks ago.
07:29:20 <mrotondo> so then, just to make sure i'm at least heading in the right direction
07:29:37 <kejoki> but now I'm a thoroughly confused noob, so I'm making progress.
07:29:50 <ksf> @quote confusion
07:29:51 <lambdabot> CharlesBabbage says: On two occasions I have been asked, 'Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?' I am not able rightly to apprehend the kind
07:29:51 <lambdabot> of confusion of ideas that could provoke such a question.
07:30:11 <ksf> @quote confusion
07:30:11 <lambdabot> ksf says: Confusion is the first step to enlightenment
07:30:30 <mrotondo> when talking about partial application, that'll typically just be in a case where e.g. you are transiently creating such a function to pass it to map or something?
07:30:37 <ksf> </shamelessegoquoting>
07:30:38 <mrotondo> not actually storing it for use later
07:31:36 <exFalso> no, partial application is key to functional programming
07:31:54 <ksf> partial application is applying a value to a function which results in another function, not a value.
07:32:00 <mrotondo> right
07:32:02 <Saizan> mrotondo: you don't get to make that new function replace a named definition, if that's what you're asking
07:32:06 <mrotondo> yes
07:32:12 <mrotondo> that is what i'm asking, thanks
07:32:15 <aadrake> We need to come up with a new term (if one does not already exist) for the guilt that accompanies having to put things in IO
07:32:24 <exFalso> in fact "partial application" doesn't make much sense, as functions -are- first calss values
07:32:45 <exFalso> aadrake: impure
07:33:08 <Saizan> mrotondo: that replacement would violate referential transparency as much as mutating an Int
07:33:10 <ksf> nah, disciple has reserved all religious terminology for itself.
07:34:00 <mrotondo> seems like it might be relevant? http://cnx.org/content/m13572/
07:34:19 <ksf> exFalso, values aren't functions, though.
07:34:30 <ksf> you won't ever reduce a function to whnf.
07:34:51 <ksf> (well, unless you evaluate under lambdas, but that's besides the point)
07:35:14 <ksf> you won't ever reduce a function to NF.
07:35:38 <exFalso> yes
07:37:09 <ion> I’d still like to see an Acme action that mutates e.g. any given Int value.
07:38:30 <ksf> hmm. that might just be doable nicely with some typeclass hackery.
07:39:03 <ion> I mean, a :: Int; a = 42; main :: IO (); main = do mutate a 123; print a  -- prints 123
07:39:28 <ksf> *serious* typeclass hackery. you'd have to lift all the other operations you use.
07:39:41 <CodeWeaver> Okay, I wander into the chatroom, and the first thing I see is Acme action.  I have visions of a coyote hacking haskell.
07:39:52 <ksf> can ghc do that with the new fancy context kinds?
07:39:59 <ion> That’s not what i mean. I mean actually modifying the memory in which the value for “a” is stored. :-P
07:40:13 <ksf> if in doubt, use disciple.
07:40:16 <exFalso> that can't be done imho
07:40:26 <ion> codeweaver: That’s pretty much it, yeah.
07:40:55 <CodeWeaver> :D
07:40:55 <lpsmith> it would be especially difficult to mutate an int,  because they can be unboxed
07:41:22 <ion> exfalso: Surely it can be done. There’s FFI and you can get to the memory address *somehow* from C.
07:41:23 <lpsmith> It would be more reliable to mutate something that can't be unboxed.
07:41:38 <ksf> exFalso, the underlying technique would be treating everything as an IORef, with access and mutation unsafeInterleaveIO'ed
07:41:57 <ksf> oh, yes, primAddr.
07:42:19 <lpsmith> Even then,  GHC is free to make copies of stuff,  so you might not be able to zap everything.
07:42:22 <exFalso> ksf: but you have to tell the compiler that "a" is special, something like "volatile" in C
07:42:23 <kejoki> ion: um...garbage collection?
07:43:00 <ion> lpsmith: Some copies having different values might be even more fun.
07:43:14 <kmc> http://hpaste.org/52268
07:43:15 <Saizan> NOINLINE might be enough for ghc
07:43:21 <lpsmith> for some definition of "fun", I guess
07:43:35 <kejoki> so we're back to randomness.
07:43:54 <ion> kmc: Ooh, nice
07:44:39 <exFalso> my eyes! my EYES!
07:45:31 <kejoki> that was ... really quick.
07:45:37 <CodeWeaver> That's… pretty horrific code ;)
07:46:30 <kejoki> CodeWeaver: where "horrific" is a synonym for "interesting," nyet?
07:46:45 <ksf> I think mut should have type Int -> Int -> ()
07:47:09 <CodeWeaver> :D
07:47:21 <ion> ksf: :-)
07:47:30 <CodeWeaver> Those are often synonyms, yes.
07:47:42 <kejoki> just checking.
07:48:04 <ksf> it took me some stumbling before realising the fundamental difference disciple sees in "() -> ()" vs. "()"
07:48:53 <ion> (Int -> Int) -> Int -> (), so “mut (+1) a” can have a new effect every time it happens to be evaluated.
07:49:03 <ksf> ...as you need an arrow to have any kind of effects.
07:50:00 <ksf> ...as in "() -!Write someGlobalVar> ()"
07:52:46 <masylum> Hi
07:52:56 <kejoki> why oh why did it take me so long to try   Prelude>a <- getContents
07:54:57 <kejoki> m asylum: hello
07:55:10 <masylum> I have a doubt regarding encodings
07:55:32 <mekeor> go ahead!
07:55:35 <masylum> how can you represent the char '\ufffd' in haskell?
07:55:43 <masylum> http://www.fileformat.info/info/unicode/char/fffd/index.htm
07:55:45 <kejoki> masylum: you just did
07:55:53 <masylum> really?
07:55:57 <masylum> I get a compiler error
07:56:15 <masylum> lexical error in string/character literal at character 'u'
07:56:23 <ion> > '\xfffd'
07:56:24 <lambdabot>   '\65533'
07:56:40 <kejoki> my bad.  I missed the \u
07:56:44 <ion> > '�'
07:56:45 <kejoki> sorry.
07:56:45 <lambdabot>   '\65533'
07:57:05 <ion> > toEnum 0xfffd :: Char
07:57:06 <lambdabot>   '\65533'
07:57:17 <mekeor> it works both, "\65533" and "\xfffd", i think
07:57:26 <masylum> cool
07:57:32 <masylum> http://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.html
07:57:35 <masylum> I was checking that page
07:57:41 <masylum> but I was not sure
07:57:52 <ion> I � Unicode
07:57:57 <masylum> lol
07:58:41 <mjga> I have a function with ~100 alternatives like: atomicNumber      "Ac" =  89. I understand that this may not work fast, but why would it allocate memory during matching?!
07:59:12 <ion> Use Data.Map
08:00:07 <Saizan> mjga: sounds weird
08:00:29 <Saizan> mjga: are you sure the allocation is not part of the production of the string rather than the matching?
08:00:32 <tgeeky> I just used ~ 100 different data declerations
08:00:49 * kejoki bets ~100 == 118
08:00:58 <tgeeky> not when I made mine
08:00:59 <Eduard_Munteanu> Heh.
08:01:07 <tgeeky> i stole the datasets from mathematica
08:01:18 <kejoki> heh
08:01:50 <Eduard_Munteanu> Maybe you should be bold enough and include the g block as well :P
08:02:33 * Saizan wonders what this is about
08:02:37 <kejoki> The compiled version is alloc'ing?
08:05:23 <Eduard_Munteanu> Saizan: something about the periodic table, of course :)
08:08:05 <Saizan> ah
08:08:38 <ion> The periodic table has a red shade.
08:08:44 * hackagebot neither 0.3.1 - Provide versions of Either with good monad and applicative instances. (deprecated)  http://hackage.haskell.org/package/neither-0.3.1 (MichaelSnoyman)
08:10:05 <kejoki> ion: what color fringe?
08:10:06 <mjga> kejoki: yes compiled, and optimized version is allocing a lot
08:10:27 <mjga> during matching, but with OverloadedStrings...
08:10:46 <mjga> funny thing that these strings are at most 2 characters long. I should probably use hash or something
08:11:05 <tgeeky> mjga: no, the automatically-named strings will be 3
08:11:11 <tgeeky> Uuo, etc
08:11:14 <kejoki> mjga : you're getting element names from the user?  I mean, you're doing command line IO?
08:12:03 <mjga> nope
08:12:18 <mjga> tgeeky: but I ignore these
08:13:01 <tgeeky> mjga: in one sense, you should. In another sense, you shouldn't, because you can automatically get them from the AtomicNumber
08:14:12 <donri> edwardk: hey, what's a good way to deal with Maybe lenses like mapLens? they tend to not compose well.
08:14:48 <kejoki> better: what's a good way to learn about what a "lens" is?
08:14:57 <edwardk> donri: you can't compose them and remain a lens
08:15:09 <edwardk> e.g. look up something in this map and then in that map
08:15:20 <edwardk> becaue the composition wouldn't have a way to tell you if the first lookup failed or the second
08:15:58 <donri> kejoki: http://www.scs.stanford.edu/11au-cs240h/notes/zipper.html and http://happstack.com/docs/crashcourse/AcidState.html#ixset_lens
08:16:11 <tgeeky> what happens when you compose a multiplate whose children are all lenses?
08:16:22 <edwardk> tgeeky: the universe explodes
08:16:22 <tgeeky> s/something/compose two multiplates/
08:16:42 <tgeeky> edwardk: well, of course, but *just before* that point
08:16:48 <tgeeky> white hole!
08:16:52 <donri> edwardk: exactly, so i tend to end up with l1 ^%= fmap (l2 ^= ...) and i'm looking for a better way to handle that
08:17:47 <donri> i'm unsure what the "functorial modify" is supposed to do / how to use it
08:18:32 <tgeeky> donri: I'm confused. Is this the sort of thing that is solved by zippers over lenses? like pez http://hackage.haskell.org/packages/archive/pez/0.1.0/doc/html/Data-Label-Zipper.html?
08:18:43 * hackagebot shake 0.2.1 - Build system library, like Make, but properly supports generated files.  http://hackage.haskell.org/package/shake-0.2.1 (NeilMitchell)
08:19:53 <Eduard_Munteanu> @google banana lenses
08:19:54 <lambdabot> http://research.microsoft.com/~emeijer/Papers/fpca91.pdf
08:19:54 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire Erik Meij ...
08:20:02 <tgeeky> i still haven't read that paper
08:20:17 <edwardk> tgeeky: the problem is that a map gives you a lens to a Maybe element, rather than to an element
08:20:21 <Eduard_Munteanu> I kinda have to go through it as well.
08:20:22 <tgeeky> I was told to do so, IIRC, to get a sense of pointfree style
08:20:28 <kejoki> donri: thanks
08:20:35 <edwardk> tgeeky: so you can't correctly compose two of those zippers
08:20:45 <edwardk> er lenses into a zipper
08:21:00 <tgeeky> so what are the potential solutions?
08:21:06 <tgeeky> or are you just stuck? move to Either?
08:21:23 <edwardk> well, that doesn't solve anything either ;)
08:21:44 <donri> what i want is something that behaves like the maybe monad
08:21:50 <donri> but for lens composition
08:22:25 <edwardk> well, fclabels added partial lenses
08:22:38 <edwardk> and roconnor figured out some semantics for them that don't suck entirely
08:23:01 <donri> @hackage partial-lens -- this is for data-lens, is it relevant?
08:23:02 <lambdabot> http://hackage.haskell.org/package/partial-lens -- this is for data-lens, is it relevant?
08:23:09 <edwardk> the issue is that the composition of them fails to be editable when one of them is missing
08:23:22 <edwardk> donri: yeah
08:23:43 <edwardk> try playing with those
08:23:55 <tgeeky> edwardk: edit lenses was just published
08:24:01 <edwardk> those at least give you a notion of failure to compose that can let you dive into multiple maps
08:24:07 <edwardk> which one is this?
08:24:23 <edwardk> oh
08:24:24 <edwardk> dmwit's
08:24:26 <donri> http://hackage.haskell.org/package/edit-lenses
08:24:27 <edwardk> nevermind =)
08:24:37 <edwardk> those aren't lenses in the manner we are discussing =P
08:25:05 <edwardk> bidirectional lenses are about moving back into the null space of some invariant by a corrective process
08:25:13 <donri> roconnor's docs are as great as edwardk's
08:25:19 <edwardk> and neither subsume or are subsumed by functional references
08:25:25 <edwardk> donri: my padawan has come far
08:25:43 <tgeeky> edwardk: when you die, I'm going to petition some government body to keep your brain for future study.
08:25:51 <donri> +1
08:26:14 <bgamari> When working in the GHC tree, how does one force a relink of stage 2 after making a change in the RTS?
08:26:33 <roconnor> edwardk: do you want me to take over data-lens by forking your project and simply uploading to hackage?
08:26:44 <edwardk> roconnor: all yours
08:26:56 <tgeeky> there isn't any guard against this thing whatsoever, right?
08:27:01 <tgeeky> i could just upload any package I want?
08:27:03 <greg`> guys im compiling a program that the book "real world haskell" says shouldnt compile
08:27:22 <tgeeky> greg`: link? hpaste link?
08:27:25 <edwardk> roconnor: the github repo has a 3.0 branch in it that i was playing with but i never got any feedback on whether any of the alternate lens styles in there were faster
08:27:26 <greg`> data CannotShow = CannotShow deriving (Show)
08:27:27 <donri> you need an account, which will be your real name, and logged. duno about authorization.
08:27:45 <greg`> ah sure, but i think that was it
08:27:53 <tgeeky> greg`: you on 7.2?
08:28:08 <greg`> checking
08:28:13 <arcatan> surely that should compile
08:28:22 <tgeeky> yeah
08:28:22 <Saizan> that definition has always compiled fine
08:28:25 <greg`> 7.0.3
08:28:42 <tgeeky> greg`: the link to RWH that says it shouldn't compile?
08:28:43 * hackagebot mime-mail 0.4.1.1 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.1.1 (MichaelSnoyman)
08:29:29 <greg`> ok maybe it wasnt that line , one sec and i'll hpaste the full program
08:31:32 <hpaste> greg pasted “cannot show?” at http://hpaste.org/57115
08:31:46 <tgeeky> greg`: http://copilotco.com/mail-archives/rwhbc.2009/msg00132.html
08:32:00 <tgeeky> greg`: errata that hasn't been corrected
08:32:09 <greg`> no wya
08:32:28 <greg`> no way! how frustrating, ive been trying to figure this out all morning!
08:32:39 <tgeeky> greg`: I just googled for "real world haskell" +"CannotShow"
08:33:00 <greg`> :#S
08:33:04 <greg`> *blush*
08:33:15 <edwardk> note to self, never treat scala strings like haskell lists. taking the tail over and over again is patheticly slow ;)
08:33:17 <kejoki> well, the comment does kind of give you a clue.
08:33:33 <eyebloom> Can you inspect the type of a function within a Haskell program?
08:33:47 <tgeeky> edwardk: do you have code libraries in other languages too? scala? or is most of your library work in haskell?
08:33:57 <kejoki> time to go.  too much egg soup about to ensue.
08:34:28 <shachaf> edwardk: It copies the whole string every time you take the tail?
08:34:41 <hpc> ive seen a terrifyingly large number of people using ERC lately
08:34:42 <edwardk> tgeeky: i have a fair bit of scala code, some c++ stuff, used to write erlang and c# more, etc.
08:34:43 <shachaf> Presumably that means you can't treat them as Haskell Data.Text either.
08:34:46 <roconnor> donri: let me know if you have any questions about partial-lens
08:34:50 <edwardk> shachaf: awesome no? =)
08:35:00 <roconnor> donri: I didn't have any applications when I wrote the library.
08:35:00 <shachaf> Aren't they immutable, though?
08:35:15 <edwardk> shachaf: wondered why my parser for out language at clarifi was so slow. ;)
08:35:19 <edwardk> er for our
08:35:25 <eviltwin_b> eyebloom, no.  most of the reasons you might want to are not really applicable in Haskell, and ghc-api covers mosf of the rest
08:35:28 <chrisdone> edwardk: are scala strings implemented as ropes?
08:35:46 <edwardk> chrisdone: no they are just java strings, but the implicitly convert to a sequence type on use
08:35:50 <edwardk> er they
08:35:58 <chrisdone> oh. wow
08:36:09 <edwardk> so you can do pure functional-ish things to them
08:36:14 <shachaf> By the way, an annoying issue of ByteString etc. is that you might only keep a reference to a very small part of a huge string, but the whole string is kept in memory (unless I completely misunderstand how ByteStrings work).
08:36:24 <eyebloom> Well for example could you do so by pattern matching on a polymorphism?
08:36:50 <mjga> hpc: after all, Emacs is the most popular operating system based on Lisp :-)
08:36:59 <shachaf> Is there some way to make a GC hook that allows code to reallocate the small ByteString after all the references to the large one are gone?
08:37:23 <edwardk> shachaf: thats actually a GOOD thing if you have tons of small references into the single block of memory
08:37:23 <mjga> hpc: next step is to have such an IRC client for Yi or Leksah
08:37:27 <edwardk> i rely on that in trifecta. =)
08:37:29 <mornfall> shachaf: Might be extremely complicated.
08:37:38 <edwardk> i have lots of copies of byte ranges, whole lines from the source material, etc.
08:37:43 <shachaf> edwardk: Well, that's true. Possibly the case I'm thinking of doesn't actually arise that much in practice.
08:37:44 <dschoepe> eyebloom: What do you mean by that? Trying to see what type the a in forall a. a -> a is, for example?
08:37:52 <mornfall> (As in, how do you figure out when the reallocation pays of. Re what edwardk says.)
08:37:57 <edwardk> it can thats why there is a bytestring copy
08:37:58 <mornfall> off*
08:38:12 <shachaf> mornfall: Right. Which is why I was hoping someone would answer with "oh, it's simple". :-)
08:39:02 <Eduard_Munteanu> eyebloom: you'd probably use the GHC API to do that, or perhaps haskell-src(-exts)
08:39:03 <edwardk> it'd be kinda nice to have something that took n bytestrings and calculated an efficiency benchmark and gave you back n bytestrings possibly copied that would minimize or reduce the memory footprint of those n bytestrings
08:39:19 <shachaf> mornfall: Well, presumably if there are *no* other references to the large ByteString then you can reallocate the small one freely.
08:39:29 <Eduard_Munteanu> (inspecting the type of a function)
08:39:33 <edwardk> you can see whether or not two bytestrings share a common parent, and you can calculate a cover per parent for how much of it is in use, and get back 'free' characters for shared ranges, etc.
08:40:03 <eyebloom> Thanks, I'll try to formulate what I'm asking into a better question.
08:41:53 <eyebloom> I ran into a situation where I'm using a type preserving embedded language and I want the user to be able to see the types within the language.
08:42:57 <eyebloom> Trying to do so without a parallel type checking system turns out to be very difficult.
08:45:17 <chrisdone> has anyone implemented overloaded pattern matching before?
08:45:27 <mjga> somehow I need to recompile my whole project twice, when I use profiling, because I used Template Haskell, is there any way to cache TH dynamically loaded executable so that it doesn't get destroyed when I build profiling version?
08:45:39 <mornfall> shachaf: Yeah, that' would be simple, but stops working as soon as you have two tiny bytestrings. :)
08:45:57 <mornfall> shachaf: And what edwardk says sounds like "complicated" to me. :)
08:46:17 <shachaf> mornfall: Yes.
08:46:34 <shachaf> I wonder if there's any sense in having some sort of mechanism for making GC hooks like that in general.
08:47:53 <edwardk> chrisdone: wadler had a proposal for view patterns, f# has a version that lets you use magic view patterns that can be partial or total
08:48:10 <edwardk> we even have a simple pattern model for upcasting and downcasting foreign objects
08:48:52 <mjga> edwardk: doesn't haskell also accept partial view patterns in guards?
08:49:11 <edwardk> mjga: you can use them almost anywhere
08:49:17 <edwardk> sadly the syntax isn't as magic as i'd like
08:49:19 <edwardk> because
08:49:22 <chrisdone> edwardk: upcasting and downcasting? in the context of haskell or which lingua?
08:49:32 <edwardk> do foo -> bar <- baz  would be awesome
08:49:56 <edwardk> chrisdone: something haskellish which can ffi in java/scala types
08:49:58 <chrisdone> where foo is the view function?
08:50:02 <edwardk> yeah
08:50:05 <chrisdone> heh :)
08:50:08 <edwardk> right now you have to parenthesize that
08:50:19 <edwardk> which ruins a bit of its charm
08:50:39 <edwardk> (foo -> bar) <- baz is a 'cheaper' fmap inside a do block
08:50:51 <dark> what is that command here to find a function with a particular type?
08:50:57 <edwardk> you can always x <- baz; let bar = foo x -- but then you name the temporary
08:52:16 <tgeeky> dark: hoogle or hayoo
08:52:18 <chrisdone> edwardk: why would you do the second anyway when you've got bar <- fmap $ baz?
08:52:19 <edwardk> and the do bar <- fmap foo baz -- round trips through your monad stack twice
08:52:40 <chrisdone> true
08:52:47 <edwardk> its one of the reasons we're adding state to MonadState
08:52:54 <dark> tgeeky, uhm, but there was also one that built it himself
08:53:02 <shachaf> edwardk: Would it be possible to make general-purpose RULE to avoid that?
08:53:05 <edwardk> because then a get/put cycle doesn't have to go in and out of the entire monad stack twice
08:53:09 <dark> a constructive proof that the type was inhabited
08:53:17 <edwardk> shachaf: perhaps
08:53:19 <chrisdone> edwardk: adding a modify?
08:53:29 <edwardk> state :: (s -> (a, s) -> m a
08:53:34 <edwardk> modify defined in terms of that
08:53:40 <shachaf> dark: djinn
08:53:40 <chrisdone> you said "adding a state"-mistake?
08:53:41 <edwardk> ideally i'd want to add gets to the dictionary as well
08:53:59 <edwardk> because that also double taps the monad
08:54:01 <dark> !djinn a -> a
08:54:09 <dark> @djinn a -> a
08:54:09 <lambdabot> f a = a
08:54:20 <dark> oh it's lambdabot that does this
08:54:56 <tgeeky> @wn djinn
08:54:56 <lambdabot> *** "djinn" wn "WordNet (r) 3.0 (2006)"
08:54:57 <lambdabot> djinn
08:54:57 <lambdabot>     n 1: (Islam) an invisible spirit mentioned in the Koran and
08:54:57 <lambdabot>          believed by Muslims to inhabit the earth and influence
08:54:57 <lambdabot>          mankind by appearing in the form of humans or animals [syn:
08:54:58 <lambdabot>          {genie}, {jinni}, {jinnee}, {djinni}, {djinny}, {djinn}]
08:54:59 <dark> actually, probably djinn is on cabal
08:55:13 <shachaf> Philippa: See, edwardk supports it too. :-)
08:55:21 <shachaf> ("too")
08:55:34 <dark> isn't djinn pre-islamic?
08:55:35 <edwardk> Philippa was down on the MonadState change proposal?
08:55:36 <tgeeky> dark: yes, it is,http://hackage.haskell.org/package/djinn
08:56:17 <tgeeky> dark: evidently not, no. http://www.wolframalpha.com/input/?i=djinn
08:57:29 <vav> if you going to use Uustalu trees and zippers and Comonad instance would you use his (:<) (:>) (:|) constructors as is? Or use more "standard" less custom constructors.
08:57:44 <chrisdone> edwardk: oh, that wadler view proposal is sexy
08:57:53 * chrisdone scrolls down to look for disadvantages
08:58:08 <edwardk> uustalu trees and zippers?
08:58:18 <edwardk> from the comonad paper?
08:58:27 <vav> Uustalu wrote a bunch... yes
08:58:40 <edwardk> check the comonad package. comonadzip is available via semigroupoids Apply
08:58:51 <edwardk> and streams provides a future and history type that comply with his
08:59:01 <edwardk> so between them you have a modern solution
08:59:22 <vav> oh, neat. Thanks. Figured while you were here would get a quick excellent answer. :)
09:00:01 <edwardk> Apply is technically weaker than the strong lax semigroupal comonad he requires, but in practice, adding a implementationless ComonadApply seemed to be quite a stretch
09:00:49 <ion> < mm_freak> i'd be interested in why edwardk moved back to C#
09:00:52 <ion> edwardk: Any comments? :-)
09:01:20 <edwardk> paid better at the time. i actually left ddarius there and moved on to other things ;)
09:01:22 <hpc> ion: they need his help more than we do?
09:01:35 <edwardk> and as imperative languages go c# isn't that bad
09:01:47 <edwardk> linq makes it pretty nice in a sort of monomorphic way
09:02:04 <ion> Aye, so that doesn’t mean “left the Haskell community for good” :-)
09:02:12 <edwardk> ye gods no
09:02:21 <edwardk> i write scala mostly these days, but with a very strong haskell accent
09:02:53 <edwardk> and i'm still banging away on my type error slicer and what not
09:03:25 <Eduard_Munteanu> And a lot of cursing and swearing, no? :P
09:03:38 <nand`> linq makes C# interesting to use
09:03:39 <shachaf> Eduard_Munteanu: That comes built-in with the Haskell accent.
09:03:49 <nand`> edwardk: opinions on F#?
09:03:59 <edwardk> mostly that its a worse c# ;)
09:04:04 <edwardk> with pattern matching
09:04:21 <edwardk> and with annoying linking issues that make it hard to incrementally introduce into a project
09:04:27 <hpc> edwardk: unsafeTheHellWithThisJustUseReflection -- am i coding scala right?
09:04:28 <hpc> :D
09:04:29 <edwardk> because you can't mix c# and f# within an assembly
09:04:45 <chrisdone> it would be nice to try a language with views like that. i suppose you can emulate it roughly with ViewPatterns but there's an extra step
09:04:49 <edwardk> hpc: thats more the c# style, scala you can usually get away with stating the types
09:04:57 <edwardk> its just how often you have to REPEAT them that gets old
09:05:05 <hpc> ah
09:05:10 <edwardk> chrisdone: f# has them more or less
09:05:38 <edwardk> scala's unapply works pretty similarly in practie
09:05:41 <edwardk> er practice
09:06:09 <Eduard_Munteanu> I think I remember dolio complaining about some theoretical issues, like covariance (if that's the right term).
09:06:32 * Eduard_Munteanu hasn't personally tried it though
09:06:34 <edwardk> yes
09:06:45 <conighion> hallo everyone!! Is it possible to run commands saved in temp.hs from ghci?
09:06:51 <edwardk> actually the funny thing is scala type inference works pretty amazingly well when you have all the covariance annotations
09:07:05 <edwardk> but when types appear in both positive and negative position in requires lots of hand holding
09:07:11 <edwardk> this leads to annoying problems like
09:07:15 <chrisdone> power x Zero = 1; power x (Even n) = … in ViewPatterns would be … power x (peano -> x) = case x of Zero -> …; Even n -> … i suppose
09:07:31 <edwardk> if you have a monad that looks kinda like state, maybe with an exception type tacked in and go to make it polymorphic in the state parameter
09:07:37 <nand`> edwardk: ouch. I was hoping it'd be easy to mix C# and F#, so I can write a bunch of Func<T1, T2> in F# then mix those + C# + LinQ
09:07:43 <nand`> wrong channel I guess
09:07:43 <edwardk> EVERYTHING needs type annotations, fail, empty, get, etc.
09:07:45 <chrisdone> (well, that makes ViewPatterns pointless. power x (peano -> Even n) would make sure, but then it's repating peano)
09:08:16 <Eduard_Munteanu> edwardk: every expression, or just every definition?
09:08:22 <edwardk> nand`: you need to build the f# assembly separately and have it use the c# ones. also f# functions and c# functions are different types, so you need to use pretty heavy conversions
09:08:32 <nand`> edwardk: ew
09:08:33 <edwardk> Eduard_Munteanu: many times every expression
09:09:07 <nand`> every time I run cabal update, I get “there is an updated version of cabal-install”, but after running “cabal install cabal-install”, cabal --version still outputs “0.8” instead of 0.10.2, the one I just built
09:09:08 <nand`> how come
09:09:33 <shachaf> ~/.cabal/bin etc.
09:09:43 <Saizan> nand`: which cabal /= ~/.cabal/bin/cabal
09:09:59 <mjga> nand`: echo $PATH, and check which binary is first?
09:10:19 <mjga> export PATH=~/.cabal/bin:$PATH
09:10:33 <dark> I was hoping djinn to deduce [(a, b)] -> [(a, [b])] , but it knows nothing about lists
09:10:49 <hpc> nand`: or cabal install cabal-install --global, perhaps
09:10:54 <nand`> wait
09:10:57 <Eduard_Munteanu> nand`: normally you should add what mjga said to your ~/.bashrc
09:10:59 <nand`> maybe I just had to run cabal as super user
09:11:13 <Eduard_Munteanu> nand`: don't!
09:11:17 <hpc> nand`: if you run as root, it just ends up in /root/.cabal/...
09:11:31 <nand`> Eduard_Munteanu: did already, should I undo anything?
09:11:43 <nand`> didn't solve my problem either, heh
09:11:50 <nand`> I'll do what mjga said
09:12:04 <mjga> nand`: running at super user just replaced the other binary. it depends whether you want a replacement "forever" (then --global is best), or rather try few things with (say) newest GHC, and then it is better to change PATH
09:12:11 <edwardk> another issue is to use scala monads you really need to trampoline them all manually
09:12:26 <Eduard_Munteanu> I don't think there's a good reason to do global installs.
09:12:28 <edwardk> and that scala monad transformers are basically unusable because of the annotations i mentioned
09:12:28 <nand`> I intend to only have one GHC installation
09:12:34 <aadrake> I think next time someone asks how Haskell is going for me, I will reply that one should not need to know how to use the State monad in order to do a proper job with random numbers.
09:12:42 <hpc> Eduard_Munteanu: i do it to keep my path clean
09:12:52 <shachaf> aadrake: Indeed, one does not need to.
09:12:53 <Saizan> nand`: you could just delete the old cabal binary
09:12:56 <hpc> plus it's nice to have all that stuff in /usr
09:13:04 <Saizan> nand`: and make sure the new one is in your $PATH
09:13:12 <Eduard_Munteanu> hpc: I generally use distro packages for that
09:13:25 <hpc> Eduard_Munteanu: i also like being up-to-date
09:13:27 <hpc> :P
09:13:28 <Eduard_Munteanu> hpc: that is, stuff which actually updates and uninstalls cleanly ;)
09:13:37 <aadrake> shachaf: It seems that is where the path leads though.  I must be reading the wrong things.
09:14:02 <nand`> works fine, thanks
09:14:04 <Eduard_Munteanu> hpc: I hear quite a few distros can generate packages from cabal stuff
09:14:10 * shachaf has the feeling that aadrake is attempting http://bash.org/?152037
09:14:19 <edwardk> actually i'd argue that you really DO need to understand the state monad in order to use random numbers, because you need to thread the random number seed through your code
09:14:28 <edwardk> oso you either understand state or you manually plumb it
09:14:37 <CodeWeaver> is there a particular mailing list or irc chat channel for dealing with package bugs?  I've got a package that won't build, but I'm not sure if I should contact the maintainer via the indicated email.
09:14:40 <edwardk> or you keep choosing 4 through random die rolls over and over
09:14:52 <aadrake> shachaf: Seen it, not really.  :)
09:15:42 <Eduard_Munteanu> hpc: anyway, considering one has to rm -rf ~/.cabal quite often, I'd better not go there at all :)
09:15:46 <Saizan> well, it's a fact of haskell that you've to understand unusual concepts to do even familiar stuff
09:15:47 <nand`> Is there any haskell linter that can point out syntax or type errors for me? (Other than ghc, I mean)
09:15:56 <nand`> unless ghc has a “just error check” mode
09:15:56 <Eduard_Munteanu> So I just do local cabal installs.
09:15:59 <aadrake> edwardk: My point exactly.
09:16:03 <edwardk> nand`: whatever hpaste uses
09:16:12 <hpc> nand`: -o /dev/null # ;)
09:16:41 <nand`> hpc: that will still perform a lot of work though won't it?
09:16:49 <nand`> to clarify, I'm looking for a program light enough to run every few seconds as I type
09:16:59 <nand`> I'm using HLint but it doesn't highlight errors
09:17:05 <nand`> just things that could be improved
09:17:26 <hpc> oh, from man ghc:
09:17:26 <hpc>    Which phases to run
09:17:26 <hpc>        -E  -C  -S  -c  -x suffix
09:17:48 <hpc> search for "WHICH PHASES TO RUN"
09:18:33 <Eduard_Munteanu> I guess that could work if you manage to extract the error location information.
09:19:59 <Eduard_Munteanu> Perhaps you can get more granularity by using the GHC API.
09:20:13 <hpaste> pcavs pasted “Control.Monad.State Ambiguous” at http://hpaste.org/57117
09:20:14 <dark> can one define new types in ghci?
09:20:16 <edwardk> i should post pictures from hac boston
09:20:16 <hpc> looks like -C is the earliest you can go to get error info
09:20:33 <nand`> hpc: interesting
09:20:39 <nand`> I'll consider working it into my editor
09:21:16 <pcavs> Hey, I'm trying out Snap and getting the following Ambiguous module name error (http://hpaste.org/57117) I'm wondering if I should ghc-pkg hide one of those, and if so, which one?
09:21:40 <hpc> i get warnings about -fvia-C, and if compilation succeeds you have to rm file.hc
09:21:45 <hpc> but it's at least quick
09:21:45 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html#g:5
09:22:35 <rata_> hi
09:22:36 <Eduard_Munteanu> Maybe you just want to get it to typecheck, e.g. typecheckModule
09:22:44 <Eduard_Munteanu> rata_: hi
09:25:37 <donri> how to use -C with cabal though? ghc: on the commandline: cannot use `--make' with `-C'
09:25:52 <Saizan> pcavs: you should look at snap's dependencies to see which one it imports and ghc-pkg hide the other
09:26:20 <Saizan> pcavs: most likely you'd have to ghc-pkg hide monads-fd since it's been deprecated for a while
09:27:19 <pcavs> Saizan: thanks, will do.
09:56:02 <louzer> this works:
09:56:04 <louzer> sum $ map (read.(:[])) "123"
09:56:08 <louzer> but this doesn't:
09:56:10 <louzer> map (read.(:[])) "123"
09:56:14 <louzer> and I don't know what (read.(:[])) means.
09:56:18 <louzer> Can anyone help?
09:56:45 <Saizan> (read.(:[])) = \x -> read [x]
09:57:26 <alistra> @unplmap (read.(:[])) "123"
09:57:26 <lambdabot> Unknown command, try @list
09:57:28 <alistra> @unpl map (read.(:[])) "123"
09:57:29 <lambdabot> map (\ d -> read (d : [])) "123"
09:57:45 <Saizan> ?type read
09:57:46 <lambdabot> forall a. (Read a) => String -> a
09:58:27 <Saizan> louzer: read parses the string differently according to which return type you expect
09:59:01 <hpaste> Razzeal pasted “templateHaskell ??” at http://hpaste.org/57121
09:59:05 <Saizan> louzer: in "sum $ map (read.(:[])) "123"" the use of sum makes the compiler decide that you want an integer, and so it works fine
09:59:29 <Saizan> louzer: in map (read.(:[])) "123" it has no clue because you do nothing specific with the result
09:59:30 <Razz> Does anyone have a clue how I could easily change that just pasted function to a function generated with template haskell?
09:59:32 <louzer> i see
09:59:55 <Palmik> Hi guys, could someone explain to me why the first is OK and the second is not? http://hpaste.org/57122
10:00:01 <Saizan> you can use a type annotation though   map (read.(:[])) "123" :: [Integer]
10:00:37 <monochrom> the "sum" helps choose the type of read
10:00:37 <vortexion> i sometimes wonder if ML is easier to get to grips with functional programming than Haskell
10:01:12 <louzer> Saizan: (:[]) "123" is ["123"] so why encapsulate something to a list fi one wants to add the digits?
10:01:32 <Saizan> Palmik: you need to use ScopedTypeVariables and add "forall a." at the start of the type of genericFromBSON
10:01:39 <vortexion> is that 1 2 3 or 123
10:01:57 <louzer> Prelude> (:[]) "123"
10:01:59 <louzer> ["123"]
10:02:00 <Saizan> louzer: (:[]) gets applied to each one of the characters in turn
10:02:09 <Saizan> > (:[]) 'a'
10:02:10 <lambdabot>   "a"
10:02:15 <louzer> wow
10:02:19 <Saizan> to make them a String rather than a Char
10:02:19 <louzer> smart
10:02:25 <louzer> hehe
10:02:28 <Saizan> this is what map does
10:02:29 <louzer> so read works
10:02:35 <louzer> yeah got it
10:02:36 <CodeWeaver> I have to learn to use the in-chat bot commands someday.  Is there a list of them anywhere?
10:03:14 <Palmik> Saizan, OK, I already use ScopedVariables for another reason, so it's not a big deal. Thanks.
10:03:28 <monochrom> ML is an easier introduction to functional programming because it is convenient for familiar imperative things (mutable variables, I/O, eager order). ML is a harder introduction to functional programming because of the same things.
10:03:30 <dschoepe> vortexion: Afaik, ML also allows you to do things in a non-functional way, to some extent, so you're not "forced" to think functionally like you are in Haskell.
10:04:02 <vortexion> it does, can't you use closures to do things in an imperative way in Haskell
10:04:07 <monochrom> for example, "const x y = x" is a lost cause in ML
10:04:29 <vortexion> imperative programming in ML is still harder than functional programming in ML
10:05:16 <dschoepe> vortexion: Using the IO monad, you can get pretty imperative-looking code, but it gets very uncomfortable if you overdo that.
10:05:34 <monochrom> lip-servicely harder
10:05:39 <vortexion> you might as well write it in C
10:06:01 <vortexion> or Java or whatever, choose your poison
10:08:20 <Razz> anyone now how I could easily generate this function with template haskell?
10:08:23 <Razz> http://hpaste.org/57121
10:08:48 <monochrom> as long as you can do "structure Blah begin  val v = ref 0  fun f x = let val _ = v := !v+1 val _ = print "hi" in x-1 end  end" I still call it trivially easy imperative programming
10:11:18 <Saizan> Razz: you have to start with reify ''Reference to get a description of the datatype, then it's a matter of constructing the corresponding AST
10:12:17 <Razz> Saizan: It's the AST I'm not certain about, first time I'm using TH so I was hoping to find some examples somewhere ... any idea?
10:12:29 <Razz> the docs are a bit bare
10:12:45 <tempire> boo
10:12:59 <tempire> happstack doesn't install via cabal on osx 10.7
10:13:53 <Saizan> Razz: you can use $(lift . show =<< [| ..your code here.. |]) to see which AST corresponds to the kind of expressions you want
10:14:17 <Razz> Saizan: brilliant, thx!
10:21:15 <portnov> hi all.
10:21:45 <portnov> Q: is there a way to retrive named captures using Text.Regex.PCRE?
10:21:53 <floomp> is it possible to extrapolate a list from [0,1,2] to something like [0,0,0,1,1,1,2,2,2]?
10:22:03 <CodeWeaver> ooh ooh I think I can do that
10:22:18 <mekeor> me, too
10:22:39 <mekeor> > concatMap (replicate 3) [1..3]
10:22:40 <lambdabot>   [1,1,1,2,2,2,3,3,3]
10:22:43 <mekeor> muhahaha
10:22:48 <CodeWeaver> :D
10:22:48 <mekeor> floomp: ^
10:22:53 <floomp> mekeor: awesome, thank you
10:25:33 <donri> portnov: try matching where a [String] type is expected
10:33:45 * hackagebot HGamer3D-Data 0.1.3 - Library to enable 3D game development for Haskell - API  http://hackage.haskell.org/package/HGamer3D-Data-0.1.3 (PeterAlthainz)
10:38:47 * hackagebot HGamer3D-Ogre-Binding 0.1.3 - Library to enable 3D game development for Haskell - Ogre Bindings  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.1.3 (PeterAlthainz)
10:38:49 * hackagebot HGamer3D-OIS-Binding 0.1.3 - Library to enable 3D game development for Haskell - OIS Bindings  http://hackage.haskell.org/package/HGamer3D-OIS-Binding-0.1.3 (PeterAlthainz)
10:38:51 * hackagebot HGamer3D-API 0.1.3 - Library to enable 3D game development for Haskell - API  http://hackage.haskell.org/package/HGamer3D-API-0.1.3 (PeterAlthainz)
10:42:18 <BMeph_> > replicateM 3 [1..3]
10:42:19 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
10:42:38 <BMeph_> > replicateM 3 . return =<< [1..3]
10:42:39 <lambdabot>   can't find file: L.hs
10:42:55 <BMeph_> Boooo... :/
10:49:23 <ddarius> > concat . transpose . replicate 3 $ [1,2,3]
10:49:24 <lambdabot>   [1,1,1,2,2,2,3,3,3]
10:52:06 <narens> Is there a package for one time "pure" creation and usage of hash tables? i.e. I don't want to modify after creation.
10:53:28 <BMeph> > replicate 3 =<< [1,2,3]
10:53:28 <lambdabot>   [1,1,1,2,2,2,3,3,3]
10:53:35 * BMeph wins!
10:55:25 <mzero> narens: Data.HashMap from unordered-containers
10:55:43 <mzero> or even Data.Map (less efficient, but you can get contents in sorted order)
10:58:17 <ddarius> > [1,1,1,2,2,2,3,3,3]
10:58:18 <lambdabot>   [1,1,1,2,2,2,3,3,3]
10:58:20 * ddarius wins
10:58:26 <narens> mzero: I was hoping for O(1) lookup
10:58:35 <mjga> anybody versed in Graphics.Rendering.OpenGL?
10:58:38 <mzero> Data.HashMap
10:58:40 <mzero> has that
10:59:23 <narens> mzero: but it says the complexity of the functions in Data.HashMap are the same as the ones for Data.Map, so that would make it O(logn)
10:59:39 <alistra> weird
10:59:50 <mzero> umm, I don't think it says that
11:00:04 <mjga> @hoogle Float -> GLfloat
11:00:04 <mzero> lookup is O(min(n,W))
11:00:04 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:00:05 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
11:00:05 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
11:00:15 <mjga> is there any conversion?
11:00:27 <mzero> where W is related to the size of Int
11:00:34 <mzero> and hence constant
11:00:54 <Enigmagic> mjga: i'm going to say that it's not needed? type GLfloat = Float
11:01:14 <mzero> and, it has been extensively optimized
11:01:31 <narens> mzero: alright, I'll take a look.. thanks
11:02:12 <Enigmagic> mjga: doh, i was looking at an old version
11:02:20 <narens> actually, while i'm here... what's the benefit to using the ST monad instead of just the IO monad?
11:02:23 <Enigmagic> try realToFrac
11:05:25 <Enigmagic> narens: runST
11:05:53 <narens> Enigmagic: yea, the moment i wrote that I slapped my forehead
11:06:00 <Enigmagic> narens: :^)
11:14:45 <scooty-puff-sr> how recently was <> added to Data.Monoid?
11:14:58 <scooty-puff-sr> it appears to cause a compiler error for semigroupoids
11:16:34 <eviltwin_b> it was added?  last I checked they were still bikeshedding
11:16:34 <scooty-puff-sr> and wl-pprint-extras
11:16:59 <scooty-puff-sr> this is from ghc 7.5 though (latest of that too) - which might explain it (and make it not really an issue)
11:17:27 <scooty-puff-sr> hey, i learned a new phrase today
11:17:32 <monochrom> 7.5 is really avant garde. 7.4 was still RC2ing just yesterday
11:17:56 <scooty-puff-sr> k
11:18:27 <scooty-puff-sr> well, at least i can be sure for when its ready - it will be a shame if monoid gets (<>) - i like it in the semigroupoids package more..
11:19:34 <eviltwin_b> see, I thought they switched to <> specifically because it was only used by a couple of small pacakages whereas the original <+> was used by ~everything
11:21:00 * ddarius can't think of a module that uses (<+>) except, I think, some parsing libraries.
11:21:12 <scooty-puff-sr> which is probably why semigroupoids used <> - this feels kind of like issues with Monad
11:21:21 <mjga> yeah, I tried 7.5 but couldn't build haskell platform, so I gave up. Would be nice to have "haskell platform devel" repo, but I don't know where it is
11:21:24 <scooty-puff-sr> and some pprint libraries
11:22:07 <monochrom> haskell platform has no normal activity until a GHC release comes out
11:22:11 <ddarius> A "Haskell Platform devel" version would still not build with 7.5
11:22:36 * Clint wonders if time will ever be upgraded in the platform
11:22:47 * ddarius doesn't really know why people care about the Haskell Platform so much.
11:23:17 <mzero> mjga: HP's repo is http://code.haskell.org/haskell-platform/
11:23:22 <mzero> it's darcs
11:23:31 * monochrom knows. the most organized checkpoint we have.
11:24:07 <narens> why on earth is splitAt in Data.List implemented as (take n xs, drop n xs)?
11:24:13 <ddarius> monochrom: Yes, it has some value, but not really for people who are building GHC HEAD.
11:25:07 <ddarius> It's also far from something that makes or breaks whether you can use a specific GHC version.  Most people will not need everything that is in the platform and will need many things that are not.
11:26:03 <mjga> mzero: but ghc version in the NOTES is marked as 6.12, can it be?
11:26:18 <mzero> nah, the NOTES are clearly out of date
11:27:26 <mjga> which script to run to download and build everything on fresh ghc (without cabal and anything)?
11:27:52 <mjga> before I have cabal, I suppose cabal install will not work, or will it?
11:28:18 <monochrom> before you have cabal, cabal install will not work
11:28:46 * hackagebot Dangerous 0.3 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.3 (NateSoares)
11:28:48 * hackagebot Dangerous 0.3.0 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.3.0 (NateSoares)
11:29:37 <mzero> mjga: you have two choices -- if you have a working cabal command, then you can just use haskell-platform.cabal file at the root of that tree
11:29:48 <mzero> something like cabal install --only-dependencies
11:29:51 <mzero> in the root there
11:30:15 <monochrom> if you have GHC 7.0 or older, it is easiest to use that to build cabal-install, then you have it and it (as an executable) works fine for newer GHC
11:30:26 <mzero> on the other hand, if you want to build the tree & tar ball of the sources of the packages, set up and ready to build (w/o cabal), then go into   src/generic  and run prepare.sh
11:30:59 <monochrom> building cabal-install using GHC 7.2 or newer takes more work. the topic has an url for it, and I still wouldn't bother
11:31:28 <mzero> that prepare.sh gets you a tree (currently mis numbered I think), and you cd into there and there is a Makefile
11:31:31 <mzero> so make in there
11:32:24 <hpaste> mjga pasted “Failure to use cabal install with latest haskell-platform repo and ghc-7.5 snapshot” at http://hpaste.org/57124
11:32:33 <mzero> note, if you are on mac os x, that procedure will work, but there is a slightly different one if what you want is "pristine installer" as I build when HP is released
11:34:02 <mzero> ddarius: *that* is why people care about HP -- it is a moderate set of package versions known to play well together
11:34:37 <mzero> mjga: the HP team hasn't begun to look at the set of package versions for bundling with 7.4 yet, much less 7.5!
11:35:13 <mjga> ddarius: it is hard for package maintainer to check the build of all dependencies in all versions, but testing against pristine HP + necessary dependencies is less work
11:37:12 <ion> kmc: Is badbeea in the payload in the first proof of concept right?
11:37:37 <mjga> mzero: the error I show seems just a package version conflict, not really related to any version of GHC
11:37:56 <mzero> well, some of those packages come from your GHC install
11:38:21 <mjga> mzero: maybe
11:38:46 * hackagebot Dangerous 0.3.1 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.3.1 (NateSoares)
11:39:31 <mjga> mzero: maybe I should try with 7.4 RC, then in unlikely case I succeed, I could send a patch :->
11:39:34 <mzero> mjga: containers does
11:40:14 <scooty-puff-sr> i'm having trouble deconstructing a GADT that doesn't care about the phantom types associated with it
11:40:23 <scooty-puff-sr> (related to a node type defined for hoopl)
11:40:24 <hpaste> “Lev Broido” pasted “Trying implicit params” at http://hpaste.org/57125
11:40:37 <scooty-puff-sr> is there a particular trick to it?
11:40:43 <mzero> mjga: the issues is that containers, from your GHC install, requires a newer deepest than the parallel in HP is known to handle
11:41:04 <levkin> Hi
11:41:14 <levkin> Please help with http://hpaste.org/57125
11:41:17 <scooty-puff-sr> (i know its possible by looking at IR.hs in hoopl/testing)
11:41:18 <mzero> you could substitute a newer version of parallel in the HP's .cabal file
11:44:01 <mjga> do I understand well, that next release of HP will skip over GHC 7.2, and work with GHC 7.4?
11:45:20 <mzero> yes, GHC central declared that 7.2 was experimental, and wouldn't go to release
11:45:42 <mzero> (release in the sense of, this is the official, you should use it, release)
11:47:11 <mzero> oh, levkin left
11:47:13 <mzero> oh well
11:47:15 <scooty-puff-sr> fixed it - apparently, add type signatures to everything (even things that the phantom types don't appear in) and it works
11:52:31 <mjga> scooty-puff-sr: so much for automatic type inference
11:52:49 <mjga> at this rate we will all be dependent-typing sooner or later
11:53:42 <mjga> #/msg levkin try changing type of EOF to EOF :: LazyStream a, to at least get correct error message
11:53:46 * hackagebot ProxN 0.0.1 - Proximity sets in N dimensions  http://hackage.haskell.org/package/ProxN-0.0.1 (AndrasSlemmer)
11:57:40 <Ngevd> Hello!
11:58:02 <mekeor> Ngevd: hi
11:59:26 <mjga> mzero: network also doesn't build, and there is a lot of warnings about foreign imports with symbols that are out of scope
12:00:45 <sparkleshy> @pl (\f (a,b) -> f a b)
12:00:46 <lambdabot> (`ap` snd) . (. fst)
12:06:59 <mekeor> @src ap
12:06:59 <lambdabot> ap = liftM2 id
12:07:06 <mekeor> @src liftM2
12:07:06 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:07:47 <mekeor> :t id 1 2
12:07:48 <lambdabot> forall t t1. (Num (t -> t1), Num t) => t1
12:07:54 <salty-horse> reading http://www.haskell.org/haskellwiki/Monad/ST -- how is the mentioned in-place sort "externally pure"? doesn't it modify the input Array? or is something else meant by that description?
12:13:11 <kmc> salty-horse, yeah.  it will copy its input (say, a list or an immutable Array) into a mutable STArray, and sort that in place
12:15:25 <salty-horse> kmc, then how is that "pure"? won't "sort(x) + f(x)" have a different result depending on evaluation order?
12:15:51 <kmc> no, it does not modify the input array
12:15:55 <eviltwin_b> no; sort(x) does not modify x in place, it modifies a *copy* of x in place
12:15:59 <kmc> runST would not let you do that
12:16:25 <kmc> copy the input array to a mutable array, sort that in place, and then copy it back to another mutable array
12:16:43 <kmc> er
12:16:46 <Saizan> the last one is immutable
12:16:47 <kmc> copy the input array to a mutable array, sort that in place, and then copy it back to another immutable array
12:17:22 <kmc> this gives you an algorithm where the creation and use of mutable state is only local
12:17:23 <salty-horse> oh! ok  then :)
12:17:36 <kmc> you are not modifying any mutable state from the outside world, or returning any references to mutable state
12:17:44 <kmc> and so runST will let you provide that algorithm as a function
12:18:13 <salty-horse> kmc, yeah, I got that from the example. I didn't get that the benefits of in-place sorting can be applied to a COPY of the input
12:18:16 <salty-horse> thanksies!
12:18:57 <kmc> actually you can get rid of that final copy
12:18:59 <kmc> runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
12:19:35 <salty-horse> pardon the sacrilege, but this reminds me of "mutable" members and const methods C++
12:19:49 <kmc> haskell is not a religion
12:19:55 <kmc> it's a programming language
12:20:16 <kmc> it's not really the same though
12:20:31 <kmc> runST actually checks that your mutation can't affect the outside world
12:20:31 <salty-horse> not a religion, but that comparison seems bad to me :)
12:21:35 <MostAwesomeDude> salty-horse: Well, first, why is mutability bad?
12:21:35 <salty-horse> kmc, sorry again, "getting rid of the final copy" reminds me of move semantics in C++11
12:21:57 <mekeor> Let's found the Church Of Haskellers, or something! :) Like the Curch of Emacs... or how was it called? with RMS as "St. IGNUcius" hah
12:22:09 <kmc> salty-horse, I'm sorry that you have the impression that people in #haskell are zealots who will bite your head off at the mention of any other language
12:22:11 <salty-horse> MostAwesomeDude, it's not, but comparing Haskell to C++ seems to be degrading :)
12:22:13 <kmc> sometimes i have that impression too
12:22:29 <MostAwesomeDude> salty-horse: Yes, well, you haven't seen what people compare Python to.
12:22:44 <salty-horse> kmc, I never implied that and please let's not dwell on it. I don't want to start that kind of discussion
12:24:41 <kejoki> I'd just like to interject, apropos of nothing much, that googling for    eddie haskell  mike meyer   is a very *bad* way to find the eddie module.
12:25:11 <salty-horse> kejoki, first result
12:25:17 <kmc> same here, google knows me too well
12:25:23 <kejoki> lol
12:25:26 <salty-horse> kejoki, now you have to share what you got
12:25:46 <kejoki> I got beaver cleaver and wayne's world, in an unholy mix.
12:27:10 <kejoki> I guess the first rule is not to use your kid's account because you're too lazy to log in under your own.
12:29:14 <salty-horse> kejoki, logging out is better. no filtering of content (not that it keeps you anonymous)
12:29:22 <mekeor> salty-horse: he's away
12:29:29 <mzero> Eddie Haskell was a famous comedian
12:29:36 <mekeor> ?
12:29:47 <mekeor> @google does that function exist?
12:29:48 <lambdabot> http://php.net/manual/en/function.function-exists.php
12:29:48 <lambdabot> Title: PHP: function_exists - Manual
12:29:51 <mekeor> lool
12:29:52 <salty-horse> mekeor, I know. but maybe he reads the logs
12:29:58 <mekeor> ah, haha
12:30:12 * mekeor never reads logs...
12:30:34 <mzero> whoops - wrong name -- I was thinking of Eddie Cantor
12:30:40 <mzero> which, if you think about it, is also funny
12:30:48 <mzero> but Eddie Haskell was a character on leave it to beaver
12:30:51 <ion> Acme.Function.functionExists, Acme.Function.methodMissing
12:31:47 <mzero> OMG - Eddie Cantor's mother's name was.... Meta!
12:31:52 <mzero> you just can't make this stuff up!
12:32:11 <ion> !
12:32:19 <hydo> ok, I give up. what am I forgetting?  sock <- connectTo host port ; b <- hGetContents sock ; close sock; return b is giving "".  telneting to the host gives me the output I'm expecting.
12:32:32 <hydo> which is a bunch of text.
12:32:40 <ddarius> hGetContents is lazy
12:32:47 <mekeor> hydo: use hpaste, pls :/
12:32:59 <kmc> i suggest strict ByteString IO
12:33:17 <mzero> hydo:  - you've closed the socket before you've consumed the lazy string that hGetContents returns
12:33:27 <hydo> right, but I'm evaling the return value of the function in ghci... strict or not it should show the text instead of an empty string... eerr.. or everything I know is wrong... heh
12:33:34 <hydo> OH GOD
12:33:38 <hydo> mzero: thank you
12:33:39 <mekeor> lol, cool.
12:33:40 <hydo> hurrr
12:33:48 <hydo> spent too much time in pythonland
12:33:48 <kmc> fucking lazy IO
12:34:03 <ddarius> hydo: This behavior isn't really natural.
12:34:03 <kmc> hydo, it's totally un-Haskelly that hGetContents works this way
12:34:05 <hydo> kmc: I actually love lazy io, I just forgot about its implications.
12:34:09 <kmc> it breaks one of the main rules of Haskell
12:34:19 <statusfailed> What's Attoparsec's version of alphaNum ?
12:34:19 <kmc> they break it by using unsafeInterleaveIO
12:34:24 <hydo> kmc: "Don't be dumb."
12:34:25 <hydo> ?
12:34:28 <mzero> so.... everything you know is wrong?!!    As the doctor says, "Good, now we can begin..."
12:34:29 <dolio> The rule that you should be able to close sockets whenever you want?
12:34:30 <lambdabot> dolio: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:34:31 <hydo> Rule #1
12:34:44 <kmc> hydo, no, the rule is that evaluation never causes execution
12:35:23 <hydo> kmc: I like that.  Never heard it in those words before, but you're right on.  I don't think I'll ever forget it.
12:35:31 <dolio> Oh, the rule that IO actions aren't nondeterministic.
12:35:44 <hydo> kmc: or is there a list of haskell commandments somewhere that I've yet to read?
12:35:48 <kmc> dolio, that's not a rule...
12:36:16 <kmc> it's fine for executing the IO action you get from hGetContents to do whatever
12:36:21 <ion> @google haskell "thou shalt"
12:36:23 <lambdabot> http://dedication.www3.50megs.com/haskell_ceremonies.html
12:36:23 <lambdabot> Title: Stephen Haskell, Levitical Laws and Ceremonies
12:36:28 <kmc> but the String value you get from the IO action should behave like a Haskell value
12:36:29 * hydo looks at shakakai...
12:36:32 <kmc> and it doesn't
12:36:46 <hydo> kmc: hence my earlier problem.
12:36:57 <shakakai> hydo: so this is where you hangout on the weekends :P
12:36:59 <kmc> hydo, i don't know.  imo "evaluation vs. execution" is the simple and correct way to understand IO
12:37:08 <kmc> but people keep talking about "pure vs. impure functions" instead
12:37:11 <kmc> which in my mind is totally confusing
12:37:15 <ddarius> dolio's point is that you can rationalize lazy IO by saying hGetContents never promised to give you the input anyway.
12:37:17 <hydo> kmc: yea, absolutely.
12:37:34 <hydo> shakakai: hehe... I used to be here a lot more, but then I got one of those "job" things.
12:37:51 <hydo> shakakai: puts a damper on my hip, active, online lifestyle.
12:37:57 <kmc> ddarius, so the hGetContents IO action looks into the future and figures out whether you're going to seq the result before returning "" or something else?
12:38:01 <kmc> i... guess
12:38:16 <dolio> It returns whatever it wants.
12:38:25 <mzero> don't forget the "Our Functor..." prayer: https://plus.google.com/104222093009939197511/posts/Xx1jzparSCr
12:38:32 <cmccann> so, rationalizing lazy IO by saying that functions using it are broken, rather than lazy IO itself? ok then :P
12:38:42 <kmc> it's not very useful as a standard library function if there is no contract on its behavior
12:38:43 <dolio> And coincidentally, it returns exactly what would be required if you went through a detailed analysis of what was going to be forced before you closed the socket.
12:39:15 <ddarius> kmc: It doesn't have no contract, but yes, having it be this non-deterministic produces a much less useful function.
12:39:36 <kmc> hydo, anyway, "lazy IO" is a broken and un-Haskelly idea and you shouldn't blame yourself for being tricked by it
12:39:53 <kmc> it's not from spending "too much time in pythonland"
12:40:13 <mornfall> What was the most recent take on IO in Haskell anyway?
12:40:25 <hydo> kmc: I'm just mad because I know that.  and I still did it.
12:40:29 <mornfall> I remember hearing something came up to supersede iteratees?
12:40:35 <ion> Conduites
12:40:37 <dolio> Now, go and rewrite your program to be significantly uglier, and use iteratees.
12:40:41 <ion> and typos
12:40:43 <hydo> dolio: haha
12:40:52 <kmc> mornfall, http://www.yesodweb.com/blog/2012/01/conduit-versus-enumerator
12:41:02 <luite> conduits are basically enumerator with a different implementation
12:41:02 <kmc> basically it is still a very active area
12:41:10 <hydo> dolio: naw, I just need to get a dump from a super simple service that shoots xml at whatever connects to it.
12:41:14 <luite> with different tradeoffs
12:41:25 <kmc> this article alone discusses five different libraries
12:41:46 <kmc> iteratee, enumerator, iterIO, conduit, pipes
12:41:47 <hydo> fragmentation, or progress?
12:41:55 <kmc> they happen together
12:42:08 <hydo> hopefully
12:42:35 <kmc> but, there is a lot of fragmentation in Haskell libraries generally
12:42:36 <mornfall> inversion of control... yes, that's definitely a problem with iteratees
12:42:39 <mornfall> think cps IO
12:43:39 <luite> yeah conduit uses mutable state instead
12:44:34 <hydo> mutable state... we're not supposed to like that, I thought.
12:44:46 <hydo> but.. but... I respect snoyman's skills... so torn...
12:44:59 <hydo> more coffee will help.
12:45:00 <luite> hydo: usually you don't really touch the mutable state directly
12:45:03 <kmc> i'm impressed that snoyman had the guts to say "this API really is nicer with mutable state"
12:45:06 <kmc> knowing that he'd be attacked by zealots
12:45:14 <Saizan> it really isn't though
12:45:16 <kmc> i don't know if he's right or not, but I'm glad we're having the discussion
12:45:30 <luite> conduits really do make lots of yesod code cleaner
12:45:32 <cmccann> it's not that hard to fake mutable state in the State monad anyway
12:45:35 <Saizan> it's just more iterators-like
12:45:53 <kmc> maybe iterators are easier to understand than iteratees
12:45:56 <kmc> and more familiar
12:46:02 <luite> enumerator had lots of problems
12:46:07 <kmc> having an easier to understand, more familiar interface is a virtue
12:46:17 <luite> oh and I really like that the things are just called Source, Conduit, Sink
12:46:18 <kmc> if your goal is to get stuff done, rather than win an aesthetics contest
12:46:49 <Saizan> it's not about aesthetics, it's about applicability
12:46:51 <ion> An (IMO) major difference with conduits is that you can have a file opened for reading, another opened for writing and e.g. copy the contents from one to the other while letting the conduit system take care of resource (file) allocation and deallocation for *both* files.
12:47:04 <mornfall> Well, my take is that I am not a newb, neither to coding nor to Haskell, and iteratees were a significant challenge. Even after the libraries came.
12:47:11 <mornfall> So something is clearly wrong with them.
12:47:17 <m_stone> kmc: have you looked much at the `pipes` package, or at oleg's iteratees + monadic regions?
12:47:28 <Saizan> and State wouldn't work, because conduits work by the ephemereal nature of the sources
12:47:35 <kmc> no, i only know about pipes through that yesodweb article
12:47:38 <Sgeo> Suppose, hypothetically, you want to do conduit stuff in the State s monad? Would you need to somehow turn that into StateTs (ST st) monad?
12:47:40 <luite> mornfall: conduit is significantly easier
12:47:40 <aristid> mornfall: "clearly?
12:47:43 <Sgeo> erm
12:47:47 <Sgeo> StateT s (ST st)
12:48:00 <aristid> conduits still change fairly drastically on a weekly basis :D
12:48:10 <kmc> yeah
12:48:11 <aristid> now michael wants to abolish Prepared*
12:48:14 <m_stone> kmc: If I understood what I read on the `pipes` bugtracker, there's apparently an agda proof that the lazy pipes satisfy the category axioms.
12:48:21 <m_stone> kmc: that seems like a fairly attractive property to me...
12:48:23 <luite> I translated some examples on the yesodweb wiki to yesod 0.10 and persistent 0.7 (which both use conduits now)
12:48:28 <luite> earlier today
12:48:31 <kmc> that's cool
12:48:35 <Saizan> though, i guess compared to iteratees even conduits are better :)
12:48:41 <luite> if anyone wants to see more code translated, please tell me :p
12:48:47 <kmc> basically at current I consider Haskell unsuitable for any problem that needs a good solution to the lazy IO / iteratees / conduits problem
12:48:59 <kmc> too much is up in the air right now
12:49:12 <luite> I agree that it's a problem
12:49:16 <aristid> kmc: if you're willing to fix things yourself, it might work out :)
12:49:27 <m_stone> kmc: https://github.com/Gabriel439/Haskell-Pipes-Library/issues/5#issuecomment-3588548
12:49:36 <luite> but I'm really happy that yesod has changed to conduit
12:49:36 <kmc> well, I'm not going to write the 7th iteratee library if that's what you mean aristid
12:49:40 <kmc> i'm definitely not qualified
12:49:52 <mornfall> aristid: Clearly.
12:49:55 <mornfall> aristid: :-)
12:50:04 <ion> Yeah, edwardk should.
12:50:41 <kmc> then someone else will have to document it
12:50:59 <m_stone> kmc: slightly different question for you:
12:51:15 <dolio> Is any language suitable for any problem that requires a good solution to that problem?
12:51:17 <luite> I hope that new entries in the iteratee lib arena will be evaluated against those real-world use cases, database/web/file hamdling stuff with exceptions, finalizers etc
12:51:33 <dolio> Oleg originally did iteratees in Schem as I recall.
12:51:38 <dolio> And we use them at work in Scala.
12:51:41 <ion> “There are twenty overlapping iteratee packages! I know, i’ll write one that will render all of them obsolete with its awesomeness.” Now there are twentyone overlapping iteratee packages.
12:51:57 <kmc> even if conduit is the solution we've all been looking for, that is far from clear at the moment
12:52:14 <mornfall> ion: And the reason for that is that to actually understand iteratees, you have to write your own implementation.
12:52:22 <mornfall> ion: Hardly a new phenomenon.
12:52:30 <dolio> Scheme, evne.
12:52:36 <dolio> Geeze.
12:52:39 <luite> it definitely isn't the solution we've all been looking for, since it's significantly less elegant, requires a special forkIO that duplicates (or reference counts?) the state
12:52:49 <ion> Yeah, that’s a very old observation that applies to a lot of stuff.
12:53:59 <ion> Fortunately some things are in Prelude, so we have just one sucky set of type classes instead of a hundred great but incompatible competing ones. ;-)
12:54:12 <Veinor> luite: props for hdiff
12:55:09 <tgeeky> Veinor: keep up the flattery, maybe he'll write a blog post about how simple it is behind the scenes :O
12:55:14 <luite> Veinor: tnx :) the source is on my github (two bash scripts that download hackage packages and commit to local git repositories)
12:55:15 <dolio> In fact, iteratees are arguably a more important idea in Scheme, Scala, etc.
12:55:25 <dolio> Kind of like deforestation.
12:56:20 <aristid> kmc: no, writing your own iteratee library is not what i mean
12:56:28 <aristid> kmc: i mean fixing broken packages yourself, mostly
12:56:54 <luite> usually there really is no simple fix
12:57:12 <luite> perhaps not even a difficult one :)
12:58:32 <tgeeky> re: fixing broken packages, has anyone ever tried to make a hueristic solver that eats ghc --make (or cabal build)'s output and just stupidly tries 'the obvious thing' (like incrementing a version)?
12:59:34 <kmc> aristid, i guess that works for hobbyists and researchers
12:59:38 <luite> tgeeky: best/easiest autofixer: remove all upper bounds
12:59:52 <kmc> if you're a business trying to solve a business problem, it's best to avoid needing to fix bugs in other people's software that's irrelevant to your core business
12:59:57 <kmc> can't always be avoided
13:00:05 <m_stone> perhaps the smaller question first.
13:00:09 <m_stone> I recently uploaded http://hackage.haskell.org/package/persistent-protobuf.
13:00:40 <kmc> but the idea that basic incremental IO in Haskell requires fixing third party library bugs will scare off a lot of businesses
13:00:43 <m_stone> unfortunately, hackage reports a build failure due to being unable to find two dependencies listed in the cabal file, namely, protocol-buffers and protocol-buffers-descriptor
13:00:53 <kmc> maybe unfairly, because as dolio points out, these problems don't have great solutions in other languages either
13:00:54 <m_stone> is this fixable?
13:01:34 <luite> m_stone: yes, by fixing the build of protocol-buffers on hackage :)
13:01:52 <m_stone> luite: good to know, thanks. :)
13:02:26 <tgeeky> m_stone: cabal unpack protocol-buffers ; <edit cabal file> ; try again ; <do something to make it compile ; fin
13:02:48 <kmc> on a related note, one of the biggest problems with Haskell is that it's so hard to learn
13:03:02 <CodeWeaver> Harder than other FPs?
13:03:04 <kmc> and so if 'conduit' ends up being easier to learn, that is a huge advantage, regardless of what other disadvantages it may have
13:03:09 <tgeeky> kmc: yes, but I don't even want to learn how to deal with dependency hells and other such things
13:03:16 <m_stone> kmc: like C++, it's got tons of useful dialects.
13:03:18 <tgeeky> kmc: oh, yes, that's certainly true.
13:03:44 <kmc> again, thinking in terms of people trying to solve concrete problems with limited resources, rather than open-ended hobby / research projects
13:03:45 <MostAwesomeDude> kmc: Well, no, the problem of incremental I/O is incredibly easy in imperative systems languages. Perhaps a bit verbose, but not difficult.
13:04:14 <kmc> MostAwesomeDude, and you can do it the same way in Haskell too
13:04:15 <edwardk> ion: i started one at hac boston
13:04:20 <kmc> but we consider that not good enough?
13:04:28 <kmc> CodeWeaver, "other FPs"?
13:04:42 <tgeeky> kmc: functional programming languages
13:04:44 <CodeWeaver> Other functional programming… uh, languages.  Commenting on the difficulty of Haskell.
13:04:50 <MostAwesomeDude> kmc:
13:04:51 <kmc> yes, it is much harder
13:05:00 <CodeWeaver> Can you elaborate?
13:05:03 <MostAwesomeDude> kmc: Not without living in the IO monad forever and ever, unless I missed something.
13:05:09 <edwardk> wow, m_stone in haskell. the apocalypse is nigh
13:05:16 <kmc> MostAwesomeDude, sure, that's what i mean
13:05:32 <kmc> 99.9999% of all code ever written was "in the IO monad forever"
13:05:35 <kmc> (made up number alert)
13:05:49 <lispy> hello
13:05:52 <kmc> CodeWeaver, Haskell has many unique features that aren't part of "functional programming"
13:06:04 <m_stone> tgeeky, luite: looking at the protol-buffers build failure log: http://hackage.haskell.org/packages/archive/protocol-buffers/2.0.6/logs/failure/ghc-7.2  -- is ghc just complaining about having INLINE pragmas on class methods?
13:06:21 <kmc> CodeWeaver, to learn Haskell you have to learn FP but also static types, polymorphism, type classes, lazy evaluation, monads, monad transformers, various patterns for dealing with encapsulating effects, etc.
13:06:33 <lispy> m_stone: looks like it
13:06:55 <lispy> m_stone: INLINE only makes sense there if there is a definition given
13:07:05 <m_stone> lispy: and class methods aren't inlinable because of the dictionary-handling?
13:07:05 <lispy> m_stone: this warning is new-ish
13:07:15 <sal23> how do you fix the warning in 7.4.1 for CInt declaration in FFI - Warning: newtype `CInt' is used in an FFI declaration,
13:07:15 <sal23>              but its constructor is not in scope.
13:07:24 <lispy> m_stone: They are inlinable if GHC can statically tell which instance to use
13:07:32 <kmc> sal23, probably import its constructor?  import Foreign.C
13:07:35 <CodeWeaver> kmc:  I'm only partway through learning all that, and I'm at least able to make practical programs.
13:07:40 <ion> edwardk: :-)
13:07:41 <CodeWeaver> Maybe not big ones yet.
13:07:50 <sal23> kmc, import the whole thing? can I import a specific constructor?
13:07:51 <m_stone> lispy: or at link-time, but I guess we don't have any link-time optimization yet?
13:07:55 <kmc> hm, I'm wrong though
13:07:57 <lispy> m_stone: For things that don't have a default in the class declaration, you can INLINE them in the instance declaration
13:08:00 <kmc> Foreign.C.Types does not expose the constructor
13:08:01 <luite> looks like it's ok with the one at 457
13:08:16 <luite> just remove the other ones
13:08:16 <tgeeky> kmc: the first pass at many problems will be, right? Monad was the big idea that came along and 'rescued' Haskell from purity?
13:08:33 <kmc> will be what?
13:08:34 <tgeeky> so they create the IO Monad, and then everyone works with it directly?
13:08:39 <sal23> kmc, yep that makes sense…I was wondering which constructor that would be so I could declare just that in import
13:08:51 <tgeeky> kmc: 99.999% of all code is "in the IO monad forever"
13:09:17 <kmc> tgeeky, I'm referring to the fact that the vast majority of code is written in languages where you can freely use effects anywhere
13:09:35 <tgeeky> kmc: ok. right.
13:09:43 <kmc> maybe it's not such a catastrophe if we write Haskell code in this style
13:09:47 <kmc> you still get many other benefits of the language
13:10:12 <tgeeky> And in the contrary case, SPJ mentioned before that Haskell used to be String->String (I'm assuming before the IO Monad work by... Wadler?)
13:10:15 <kmc> i'm not saying all code should be written this way, but if you're trying to do something like incremental IO, it seems reasonable and natural
13:10:46 <kmc> it's not as nice as an established solution to the iteratees problem
13:10:51 <kmc> but we don't have one of those yet
13:12:20 <tgeeky> ok... this is making he smirk.
13:12:39 <tgeeky> http://www.haskell.org/ghc/dist/7.4.1-rc2/
13:12:45 <tgeeky> We are pleased to announce the first release candidate for GHC 7.4.1:
13:13:04 <tgeeky> and a directly filled with 7.4.0-.... files
13:13:07 <CodeWeaver> Grr.  arg.  I just barely got 7.2.2 working.
13:13:22 <luite> tgeeky: it started with the zeroth rc
13:13:34 <m_stone> kmc: regarding the usefulness of the various proposed incremental-IO solutions... I've been having trouble figuring out how to apply them to an incremental-IO problem that I currently face.
13:13:38 <tgeeky> luite: that's even wronger!
13:13:50 <luite> hehe that was a joke ;p
13:13:56 <tgeeky> hehe :)
13:14:12 <tgeeky> is it normal to call 7.4.0rcXXX "7.4.1"
13:14:19 <luite> no
13:14:28 <luite> 7.4.0.date are the snapshots
13:14:36 <m_stone> kmc: yet the problem is easy to solve with lazy IO.
13:14:40 <luite> and a few are picked as release candidates
13:14:48 <luite> and the release is renamed 7.4.1
13:15:17 <tgeeky> luite: right. So is that procedure, normal, as far as open source software goes?
13:15:28 <luite> it is for ghc :)
13:15:35 <tgeeky> good enough for me
13:15:57 <luite> there's already an unstable branch (7.5), with its own daily snapshots
13:16:11 <ddarius> "Do hundreds of independent communities with differing priorities happen to coincide on minor procedural details?"
13:16:31 <sal23> ddarius, good point :)
13:17:11 <tgeeky> ddarius: well, hundreds (if not thousands) use some website's versioning policy
13:17:11 <m_stone> kmc: the problem is that the data I need to analyze are generated by the ambiguous grammar "S := (AB*)*", where A is a fixed 10-octet terminal and B* are arbitrary bytestrings.
13:17:19 <tgeeky> I always forget the name
13:18:03 <m_stone> kmc: with lazy-io, I can just mmap the whole input, split it with Data.ByteString.Search.Lazy.splitKeepFront, and then fold my computation over the resulting list.
13:18:06 <tgeeky> ddarius: but in hindsight, I agree, stupid question :o
13:18:46 * hackagebot copilot-core 0.2.3 - An intermediate representation for Copilot.  http://hackage.haskell.org/package/copilot-core-0.2.3 (LeePike)
13:18:48 * hackagebot copilot-language 0.3 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.3 (LeePike)
13:19:54 <erus`> does a case expression force evaluation?
13:20:02 <erus`> if so even for _ pattern?
13:20:04 <m_stone> kmc: however, I haven't yet figured out a nice way to express this computation with any of the incremental stuff.
13:20:10 <ddarius> erus`: Not unless it has to.
13:20:12 <kmc> erus`, no, only as much evaluation as the patterns require
13:20:15 <kmc> > case undefined of _ -> ()
13:20:16 <lambdabot>   ()
13:20:20 <ddarius> Which it usually does, but won't for irrefutable patterns.
13:20:26 <mreh> Yampa delayed switches don't feed the input from the last step into the next step immediately following a switch do they?
13:20:29 <kallisti> Monads in Haskell can be thought of as composable computation descriptions. The essence of monad is thus separation of composition timeline from the composed computation's execution timeline, as well as the ability of computation to implicitly carry extra data, as pertaining to the computation itself, in addition to its one (hence the name) output, that it will produce when run (or queried, or called upon).
13:20:56 <kallisti> from the first paragraph on the Monad article of HaskellWiki. I don't think this is a very helpful introductory paragraph.
13:21:02 <mreh> heh
13:21:04 <mreh> not really
13:21:12 <mreh> change it
13:21:13 <kmc> in general if you see "monads in Haskell can be thought of as..." you should just tune out
13:21:15 <mreh> it's a wiki
13:21:26 <kmc> but, that seems like a better description than many
13:21:28 <kallisti> kmc: well it's not /wrong/, at least.
13:21:33 <ddarius> Except that it is factually wrong.
13:21:36 <kmc> it's kinda poorly written though
13:21:56 <kmc> also == mreh, change it :)
13:22:00 <kmc> erus`, this is different in some intermediate languages like Core
13:22:07 <mreh> the list monad doesn't fit that description
13:22:17 <erus`> kmc ah ok
13:22:27 <ddarius> mreh: If you remove some aspects, it does.
13:22:35 <kmc> erus`, in Core or in the language of the STG paper, 'case' always forces evaluation, and takes only single-constructor patterns or wildcards
13:22:54 <kmc> so it represents the operational behavior of forcing a single thunk and then inspecting the result
13:23:11 <kmc> mreh, it fits if you squint enough.  just like every other monad analogy
13:23:37 <kmc> "monads are like containers, as long as you forget everything you know about containers, and treat it as a synonym for 'monad'"
13:23:46 * hackagebot copilot-sbv 0.3 - A compiler for CoPilot targeting SBV.  http://hackage.haskell.org/package/copilot-sbv-0.3 (LeePike)
13:23:51 <mreh> monads are containers
13:24:01 <mreh> :)
13:24:09 <kmc> not really, no
13:24:11 <edwardk> kmc: hahahhaa
13:24:17 <hydo> ssh!
13:24:29 <cmccann> monads are very similar to monads, except for "fail"
13:24:38 <edwardk> @remember kmc: "monads are like containers, as long as you forget everything you know about containers, and treat it as a synonym for 'monad'"
13:24:38 <lambdabot> I will remember.
13:24:53 <mreh> who were you quoting?
13:24:59 <ddarius> Monads are very similar to strong monads a hypothetical category Hask except for "fail."
13:25:08 <ddarius> mreh: I would say, me.
13:25:11 <kmc> nobody in particular
13:25:13 <ddarius> Only paraphrasing.
13:25:15 <kmc> it's something i and others have said here
13:25:20 <kmc> i don't know who invented it
13:25:35 <mreh> "yes... but list monad"
13:26:10 <mreh> i've been bug hunting for 8 hours now
13:26:26 <ddarius> You must be bad at it.  Bugs are everywhere.
13:26:28 <mreh> bugs total == 0
13:26:42 <tgeeky> Talking about monads is recieving the same treatment that depictions of the divine (or prophets) do in Islam -- we admit we can't do it well enough, and we don't do it!
13:27:18 <tgeeky> I should say, for some we that doesn't include me.
13:27:20 <kmc> that's because there's actually very little to talk about, but people always want more
13:27:21 <mreh> didn't leibnitz first postulate the monad?
13:27:31 <kallisti> not the category theory one.
13:27:32 <dolio> No.
13:27:39 <kallisti> he had something else that he called a monad.
13:27:40 <arcatan> i still think that monads should be thought about the same way as algebraic structures. they're arbitary structures satisfying arbitary-but-oftentimes-handy rules.
13:27:41 <mreh> of course not
13:27:43 <kmc> the concept is very simple but abstract and therefore difficult
13:27:50 <ddarius> tgeeky: I would say the early descriptions of monads being used the way they are used in Haskell are quite clear.
13:28:20 <tgeeky> ddarius: right, to those of us who learn like you and I do.
13:28:28 <kmc> but it's the kind of difficulty you can't resolve by throwing more words at it
13:28:41 <tkahn6> monadic IO was a pretty big deal for Haskell when the paper on it was first published… i think there are things to talk about beyond the mathematical definition
13:28:45 <tgeeky> though that's usually the case in a very general sense in academic papers. Very often (modulo translation), the original source is the best.
13:28:45 <hpc> arcatan: agree, but the applications of monads are so unalgebraic to the eyes of a newbie
13:28:52 <ddarius> tgeeky: I'd be very surprised if you knew how I learned, and I was generalizing to most people.
13:29:03 <tgeeky> ddarius: right, I was rejecting that generalization. It's not really valid.
13:29:33 <tgeeky> ddarius: most people learn, however they do it best (if they learn to learn at all). It doesn't take too long to observe that people do it very differently.
13:29:42 <ddarius> arcatan: The problem with that view is that it says almost nothing.  I can make up all kinds of "algebraic" structures satisfying various laws.  Why should we care about monads in particular?
13:29:57 <djahandarie> Something that annoys me about monads is that people often say that they are used to model I/O, and point to Haskell's Monads, when in reality that's a non-example of that concept.
13:30:14 <arcatan> that's the point. because they turn out to be handy and practical.
13:30:24 <djahandarie> Monads can be used to model I/O, but only when utilized in the meta-/type-theory.
13:30:29 <kmc> people are wrong, on the internet, about haskell
13:30:42 <hpc> kmc: outrageous!
13:30:49 <mreh> where?!
13:30:49 <ddarius> arcatan: And people want to know -why- they are handy and practical.  Also, in practice, algebraic structures are -not- chosen arbitrarily.  There are strong intuitions guiding the choice.
13:30:50 <tkahn6> kmc: guess you can't go to sleep now
13:31:50 <dolio> Embedded languages are algebraic structures, and monads are the algebraic theories that describe them.
13:31:54 * mreh dons his bugstalker
13:31:56 <dolio> So that's why they're useful.
13:31:59 <mreh> back to the grind
13:32:44 <hpc> dolio: embedded languages are like taco bell...
13:33:01 <kmc> sigh
13:33:01 <ddarius> hpc: The include a significant amount of glass?
13:33:14 <arcatan> ddarius: that's a fair question, but i'm not sure if that's useful one for a beginner to ask
13:33:22 <dolio> Taco Bell is mostly oats.
13:33:28 <arcatan> or hmm.
13:33:33 <ddarius> arcatan: It is the question they ask though, and it is not an unreasonable question.
13:33:46 * hackagebot copilot-c99 0.2.3 - A compiler for Copilot targeting C99.  http://hackage.haskell.org/package/copilot-c99-0.2.3 (LeePike)
13:33:48 * hackagebot copilot-cbmc 0.23 - Copilot interface to a C model-checker.  http://hackage.haskell.org/package/copilot-cbmc-0.23 (LeePike)
13:33:57 <kmc> specific question -> arguing about how to teach monads -> arguing about what monads are -> burrito jokes
13:34:28 <kmc> these inside jokes aren't funny, you know
13:34:44 <kmc> they're just a way to show off that you're in the club of people who "get" monads
13:35:02 <ddarius> kmc: I would wager that most of the people who make these jokes don't "get" monads.
13:35:37 <tkahn6> … doesn't 'getting' monads just require knowledge of the monad laws?
13:35:37 * mreh thinks kmc is on the kfc gravy train
13:36:33 <kmc> tkahn6, no, it probably means having intuition about what sorts of problems are modeled / solved by monads
13:36:40 * mjga emerged from the cabal hell, and given up having Haskell Platform with 7.4RC2. It seems that changes are mostly trivial (adding Eq a to Num a contexts, and Show to Integral), but versioning makes it more difficult.
13:37:03 <kmc> if you're writing a library, will you notice that it has a natural monadic API?
13:37:32 <kmc> but, a lot of people talk about whether they "get monads" without even knowing what they mean by it
13:37:33 <kallisti> also: if you're writing a library, will you notice that a monadic API is not natural at all?
13:37:35 * cmccann suspects that intuition can only be built by reinventing wheels until you learn to recognize "round things"
13:37:49 <kmc> sometimes they are looking for an epiphany that does not exist
13:37:57 * ddarius puts whiskey glasses on his car.
13:38:03 <kallisti> cmccann: yes. I accidentally invented ReaderT a few days ago. :P
13:38:07 <kmc> because there is so much hype about monads
13:38:19 <m_stone> cmccann: occasionally, there are breakthroughs in how to convey intuitions.
13:38:30 <c_wraith> There is an epiphany, of a sense.  But it's the epiphany of "oh, that's all they are"
13:38:39 <kmc> shrug
13:38:44 <ddarius> @wn epiphany
13:38:45 <lambdabot> *** "epiphany" wn "WordNet (r) 3.0 (2006)"
13:38:45 <lambdabot> epiphany
13:38:45 <lambdabot>     n 1: a divine manifestation
13:38:45 <lambdabot>     2: twelve days after Christmas; celebrates the visit of the
13:38:45 <lambdabot>        three wise men to the infant Jesus [syn: {Epiphany},
13:38:47 * hackagebot copilot 2.0.5 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0.5 (LeePike)
13:38:47 <lambdabot>        {Epiphany of Our Lord}, {Twelfth day}, {Three Kings' Day},
13:38:49 <kmc> i think there should be a separate channel for monad philosophy
13:38:49 <lambdabot>        {January 6}]
13:39:01 <djahandarie> #haskell-monad
13:39:03 <kallisti> heh
13:39:12 <cmccann> kallisti, are you sure you didn't reinvent Kleisli arrows instead? ;]
13:39:27 <c_wraith> I clearly remember when I was first playing with parsec, and thought "I wonder if I can do X. I'll just write some code and... It worked. Oh, that's because it's a monad, and that's what monads do."
13:39:45 <c_wraith> And that's the first time I had a solid grasp on what it is the interface gives
13:39:58 <djahandarie> #haskell>>=
13:40:27 <m_stone> cmccann: my favorite example is: apparently, until fairly recently, the only way to learn to win air combat maneuvering engagements was to go flying with someone who already knew how to win.
13:40:41 <m_stone> cmccann: then, one day, a fellow named Boyd wrote a training manual that worked.
13:40:55 <m_stone> (or, at least, that worked a lot better than all the previous attempts)
13:41:26 <m_stone> as a result, I haven't given up hope on monad tutorials. :)
13:41:43 <mekeor> oO: what's up with that hackage-site? http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Event.html
13:41:54 <tgeeky> You see, a monad is like a double barrel roll.
13:41:56 <ddarius> Boyd was quite a while ago, and given that the history of air combat isn't -that- long, I'm not sure if I'd describe it as "fairly recently."
13:42:01 <cmccann> m_stone, I'd be more optimistic if most of them weren't actively harmful to building intuition :T
13:42:55 <m_stone> ddarius: the timeframes are similar to what we face in computing, no?
13:43:26 <tkahn6> are there any good resources for understanding not just the definiton of a monad, but the overarching semantics? something that explains the semantic relation between say, Parsec, List, and the IO monad?
13:43:43 <kmc> there isn't any
13:43:51 <ddarius> m_stone: A little longer, but what you're saying is like saying Jackson's Structured Programming was a "fairly recent" breakthrough in program design.
13:43:58 <tkahn6> kmc: any resource or any semantic relation?
13:44:03 <kmc> semantic relation
13:44:06 <mekeor> System.Event doesn't exist anymore?? see http://hackage.haskell.org/packages/archive/base/latest/doc/html/
13:44:19 <kmc> tkahn6, just because two things implement the same type class does not mean there is a deep connection between them
13:44:25 <m_stone> ddarius: that's right. :)
13:44:26 <kmc> think of all the things that have Show or Eq instances
13:45:03 <dmwit> I've interrupted a lazy darcs get; is there a way to later continue pulling patches?
13:45:36 <jedai> tkahn6: Well in a way there are, it's called category theory manuals ;)
13:45:51 <kmc> what?
13:45:57 <cmccann> you could probably run with monads giving a semantics of abstract causality, but that's neither terribly helpful nor easy to formalize
13:46:15 <tkahn6> kmc: well ok then, this was actually my current understanding (there is not necessarily a semantic relation, it's just a type class which provides a good interface)
13:46:24 <jedai> cmccann: How do you put the list monad in that frame ?
13:46:38 <tkahn6> i thought you were implying the opposite earlier
13:46:40 <cmccann> jedai, by thinking of it as a nondeterminism monad
13:46:50 <kmc> when were we implying the opposite?
13:47:11 <tkahn6> > kmc: tkahn6, no, it probably means having intuition about what sorts of problems are modeled / solved by monads
13:47:12 <lambdabot>   <no location info>: parse error on input `,'
13:47:20 <kmc> there is intuition to build regarding how to use this generic interface effectively, and how to recognize when one of your libraries could support this interface
13:47:33 <kmc> the same is true of Eq or Show, but is pretty easy and so we don't talk about it much
13:47:43 <jedai> cmccann: Well I guess I see what you mean, even if that nondeterminism isn't linked to what I would call "causality"
13:47:56 <kmc> jedai, what do "category theory manuals" have to do with anything
13:48:03 <luite> is there any progress on the parallel cabal-install program?
13:49:14 <kallisti> jedai: the list monad also implements a form of logic programming.
13:49:41 <kallisti> [] is "false" and anything else is a true result with one or more results.
13:49:52 <jedai> kmc: the concept of monad comes from category theory, don't it ? (even if that isn't how it formed in the first minds trying to formalize it)
13:49:55 <cmccann> jedai, the nondeterminism view of the list monad implies repeatedly picking one out of a selection of values, and the causality aspect is that the values chosen at one step can determine the set of values available at future steps
13:50:08 <kallisti> this is more true if you look at the MonadLogic instance for []
13:50:17 <jedai> kallisti: Ok, I'll buy that as causality :)
13:51:19 <cmccann> jedai, compare that to the acausal Applicative instance, which has a fixed set of choices and simply tries all possible routes
13:51:32 <kallisti> >>= is a kind of non-commutative logical conjunction (>>- from MonadLogic is slightly better in that regard because it's "fair", meaning it ensures that conjunctions between infinite results are handled correctly).
13:51:50 <cmccann> the "abstract causality" interpretation reflects the difference between Monad and Applicative, btw
13:52:01 <kallisti> mplus for lists is a logical disjunction.
13:52:08 <jedai> cmccann: I always saw the nondeterminism aspect as picking everything at once then picking at the end which path you'll keep (or if you want them all)
13:52:17 <ddarius> jedai: The concept of "monad" was first explicitly identified in category theory.  Closure operators in order theory are important special cases of monads which have been used for quite a while.
13:52:23 <tkahn6> kmc: i see your point.
13:52:31 <tkahn6> kmc has left the building
13:52:32 <tkahn6> :(
13:52:33 <m_stone> tkahn6: returning to your more underlying request for some insight into what's going on here...
13:52:48 <m_stone> tkahn6: how would you describe the difference between "functions" and "programs" ?
13:53:41 <tgeeky> cmccann: does that causality principle still hold if you explicitly fix the sizes of lists?
13:53:45 <jedai> To be honest I always adhered to a more formalist view of monads as just type + bind + return (or join + return) which respect some laws
13:54:06 <tkahn6> m_stone: in what context? they mean different things depending on the context
13:54:07 <cmccann> tgeeky, meaning lists of a fixed size?
13:54:09 <jedai> That's not very intuition forming though..
13:54:12 <Algorith>  -!- kmc [~keegan@c-98-216-51-47.hsd1.ma.comcast.net] has left #haskell ["Leaving"]
13:54:46 <tgeeky> cmccann: yeah, even picking values from a list of fixed sices may yield different values, doesn't fixing a size mean that principle is somehow incorrect?
13:54:53 <tgeeky> s/sices/size/
13:54:54 <cmccann> tgeeky, the standard list monad doesn't work if you restrict the list size, so the above doesn't apply directly
13:54:56 <kallisti> using Control.Monad.Logic you can define a logical xor for the list monad like this:  xor a b = (a >>= lnot b) `mplus` (b >>= lnot a)
13:55:31 <cmccann> and the monad instance you get from lists of fixed size is both somewhat trivial and grossly inefficient
13:55:40 <kallisti> actually a better way to write it would be
13:55:58 <tgeeky> cmccann: well, what I'm imagining is a "block size" to lists - they'll be at least some size (n) -- instead of restricting the upper bound, restrict the lower
13:56:09 <ddarius> cmccann: It's just a more concrete representation of the reader monad.
13:56:18 <m_stone> tkahn6: I'm talking about their mathematical meanings. specifically, their algebraic meanings.
13:56:18 <cmccann> ddarius, yes
13:56:20 <bbear> hi
13:56:31 <bbear> I want to learn a good programming language. Do you know one ?
13:56:45 <ddarius> tgeeky: That will produce something that is not a monad, at least not with the standard definition of the list monad.
13:56:46 <tkahn6> lol
13:56:53 <tkahn6> m_stone: i don't know
13:57:01 <hpc> bbear: no, i know several ;)
13:57:03 <kallisti> xor a b = (lnot b >> a) `mplus` (lnot a >> b)   -- so now if both a and b are non-mzero then you get mzero, if only one is non-empty, then it returns that one. and if they're both mzero then it returns mzero.
13:57:07 <mekeor> haha
13:57:15 <kallisti> s/non-empty/non-mzero/
13:57:27 <mekeor> bbear: you could ask in #proglangdesign, too, btw.
13:57:31 <mekeor> or #programming
13:57:38 <tgeeky> ddarius: I think we are talking about the nondet list monad?
13:57:39 <cmccann> tgeeky, depending on how you define that, I believe it will either fail to be a monad or will end up equivalent to one of the two monads for lists
13:57:54 <cmccann> or a product of the two list monads, I guess
13:57:55 <tgeeky> cmccann: and when you say "I believe" you're pretty damn sure? :)
13:58:14 <arcatan> bbear: I've heard rumours that Haskell is a decent one.
13:58:29 <bbear> Iwant to know a functional language.
13:58:34 <jedai> bbear: Here you'll mainly hear impassionated plea for Haskell (not really, most people here know several interesting languages but still...)
13:58:35 <tkahn6> m_stone: a function is a mapping of one set to another
13:58:36 <cmccann> tgeeky, it means I'd be rather surprised by getting anything else from that
13:58:40 <bbear> I want to try my first functional language.
13:59:01 <tkahn6> bbear: http://tryhaskell.org/
13:59:03 <bbear> jedai, I would like to know why haskell is better than the othersr.
13:59:10 <mzero> bbear: if let us know your existing level of programming, we can direct you to the right place to start
13:59:18 <jedai> bbear: Well Haskell is a good choice then, better than many and no worse than others
13:59:21 <m_stone> tkahn6: good.
13:59:22 <mzero> do you know C++? Python? COBOL?
13:59:26 <tgeeky> bbear: because of #haskell, and etc... the community.
13:59:46 <tkahn6> m_sone: i don't know of a mathematical definition of a program
13:59:50 <m_stone> tkahn6: said slightly differently, functions are relations between inputs and outputs.
14:00:09 <m_stone> tkahn6: programs, on the other hand, have something to do with computation.
14:00:20 <tkahn6> m_stone: ok
14:00:20 <kallisti> > let xor a b = (lnot b >> a) `mplus` (lnot a >> b) in xor [1,2,3,4,5] [7,8,9,10]
14:00:21 <jedai> bbear: The main advantage of Haskell as a functional language for a beginner is that it won't allows you to fall back to your imperative habits (well, not easily)
14:00:21 <lambdabot>   []
14:00:25 <kallisti> > let xor a b = (lnot b >> a) `mplus` (lnot a >> b) in xor [1,2,3,4,5] []
14:00:26 <lambdabot>   [1,2,3,4,5]
14:00:54 <bbear> jedai, it's a good advantage
14:01:00 <mekeor> i defined a new data type "Foo". i added "Foo" to the class "Eq" using the keyword "instance" but i'm not sure whether i have to write "deriving Eq" at the definition of "Foo", do i ?
14:01:13 <jedai> bbear: It's extremely ecxpressive, the type system is one of the richest you can get while staying away from dependently-typed language (a whole another world)
14:01:23 <m_stone> tkahn6: okay, well, what might this mysterious "computation" business be about?
14:01:24 <bbear> yes, for example in ocaml you can get some imperative way to write things.
14:01:33 <kmc> "<bbear> I want to learn a good programming language"  uh, what do you consider to be "good"?  and what do you hope to do with this language?
14:01:37 <hpc> mekeor: "deriving" means "write the instance for me"
14:01:39 <hpc> mekeor: so no
14:01:44 <kmc> you can write imperative code in Haskell quite easily
14:01:45 <mekeor> hpc: i see. thanks. :)
14:01:46 <OscarZ> jedai: what are dependently typed languages about ?
14:02:00 <ddarius> OscarZ: Dependent typen.
14:02:16 <m_stone> tkahn6: clearly, part of it has to do with computing outputs from inputs by applying rules, "step by step".
14:02:21 <bbear> kmc, I want to learn a programming language because I think they are better than imperative languages. To be honnest, I expect to do far more better with functionnal languages than I could do with any other languages.
14:02:21 <jedai> OscarZ: well they're language where type and value aren't that separated (a type may depend on a value and so on)
14:02:28 <m_stone> tkahn6: good so far?
14:02:29 <tkahn6> m_stone: ok
14:02:33 <kmc> Haskell is also an imperative language
14:02:37 <bbear> I want to be able to code immediatly and simply my craziest ideas.
14:02:38 <kmc> and it sounds like you have unrealistic expectations
14:02:59 <tkahn6> bbear is a troll lol
14:03:00 <kmc> maybe you want an extremely dynamic language with macros, like Lisp or Scheme or Clojure
14:03:01 <bbear> kmc, yes but I trust in functional programming as a better way to write program.
14:03:02 <kallisti> for logic programming though, LogicT is much better than [] due to mplus incurring quite a bit of overhead for lists.
14:03:06 <m_stone> tkahn6: that part is commonly called "evaluation"
14:03:12 <jedai> OscarZ: That allows you to write program statically typed to ensure things that you couldn't ensure in most statically typed languages
14:03:17 <m_stone> tkahn6: the other part has to do with side-effects.
14:03:24 <kmc> bbear, it's sometimes a better way to write some programs
14:03:31 <kmc> i like Haskell not because it's functional but because it's good
14:03:39 <kmc> half of the things I like about Haskell have nothing to do with FP purist ideology
14:03:41 <tkahn6> m_stone: sure
14:03:48 <kmc> and I love imperative concurrent programming in Haskell
14:04:00 <mzero> bear, on the assumption that you know a little programming, I'd suggest that you start working your way through LYAH, and get Haskell Platform on a machine you can code on, so you can try small examples as you go
14:04:04 <mzero> @where LYAH
14:04:04 <ddarius> Haskell is a really nice language for concurrent programming.
14:04:04 <lambdabot> http://www.learnyouahaskell.com/
14:04:09 <jedai> kmc: Well Haskell is pretty good at imperative, but there's no way to do imperative without realizing it, unlike most other functional languages
14:04:10 <bbear> kmc yes I was talking in general. Sometimes write a C++ or a python program will do the job as well, but I want to have at hand a good language to make more abstract things.
14:04:15 <OscarZ> jedai: What are the downsides in that? Can you give a simple example of a type that depends on value?
14:04:26 <kmc> i see Haskell as a pragmatic multiparadigm language
14:04:31 <mzero> (If you were a very experienced programmer, there are other avenues)
14:04:32 <jedai> OscarZ: simply put, those language aren't turing complete any more
14:04:46 <kmc> bbear, how about Scheme or Clojure
14:04:55 <bbear> kmc, so It's not exactly what I am looking for.
14:04:56 <kmc> anyway this is kind of off-topic
14:05:02 <ddarius> jedai: Dependent typing doesn't require being total.
14:05:06 <jedai> OscarZ: Well that's not really true, but you have to use some tricks to make them do some things
14:05:09 <kmc> Haskell is not the best language for quickly expressing crazy ideas
14:05:26 <jedai> ddarius: True, my experience with them is mostly restricted to Coq
14:05:44 <tkahn6> bbear: try pythong for 'quickly expressing crazy ideas'
14:05:46 <OscarZ> I see.. I was reading about Curry- Howard correspondence and ran into the concept of "dependent types" there.. dont know much about it
14:05:48 <bbear> kmc, not really because haskell has a big community it's not something I could consider as negligible. Scheme is good ?
14:05:58 <jedai> kmc: That depends on what kind of crazy idea, no ?
14:06:01 <kmc> yeah, the Haskell community is big
14:06:02 <bbear> tkahn6, no, I dislike python in that moment.
14:06:05 <kmc> and pretty helpful
14:06:18 <ddarius> I'm pretty sure the Scheme community is larger and also pretty helpful.
14:06:20 <m_stone> tkahn6: so far, we've said that the difference between functions and programs is that functions are relations between inputs and outputs and that programs express rules for performing computations-with-side-effects
14:06:22 <kmc> Python is not that expressive.  it doesn't have easy metaprogramming the way Scheme / Clojure do
14:06:26 <companion_cube> python with iterators and list comphrensions is actually quite good
14:06:30 <bbear> yes.
14:06:30 <kmc> neither does Haskell
14:06:34 <tkahn6> m_stone: ok
14:06:55 <kmc> jedai, what kind of crazy ideas are easier to express in Haskell than in Scheme/
14:06:56 <kmc> ?
14:07:06 <companion_cube> http://code.google.com/p/pure-lang/ this may be cool for very quick prototyping
14:07:18 <bbear> companion_cube, I know a bit python but it get me tired.
14:07:22 <companion_cube> I often tend to write algorithm drafts in a rewriting fashion
14:07:24 <kmc> to me Haskell gives a good tradeoff between expressiveness, safety, and performance.  it's not the king of any one of these
14:07:37 <bbear> I dislike it becauuse I ever end up with code that do the job but which is ugly.
14:08:12 <m_stone> tkahn6: we're getting close to the punch-line of the story now.
14:08:17 <kmc> ddarius, #haskell is a lot more active than #scheme... that may be good or bad
14:08:24 <kmc> lately i'm thinking it's bad
14:08:25 <bbear> maybe it's because I am a bad programmer. But I want to learn and practice a language for its intrinsic beauty. Not something you can easily have with python I think.
14:08:27 <jedai> kmc: Well I was comparing with python when you said that (though you weren't the one speaking of python), but at least Scheme makes it much harder to enforce good practices with types (think string interpolation in a web server context)
14:08:38 <tkahn6> m_stone: alright
14:08:56 <kmc> jedai, yeah, that's not what I think of as "code immediatly and simply my craziest ideas"
14:09:04 <m_stone> tkahn6: another important property that both functions and programs share is that they can sometimes -- when the types are right -- be composed to make new functions or programs
14:09:29 <tkahn6> m_stone: right
14:09:40 <ddarius> kmc: #scheme is only a fraction of the Scheme community (and similarly for #haskell and Haskell.)
14:09:46 <kmc> right
14:09:56 <bbear> This is basically a 5 or 6 items choice. Compare the following languages : #haskell, #ocaml, #scheme, #lisp, #erlang
14:10:07 <m_stone> tkahn6: so, it's pretty clear that functions f and g can be composed into f;g when the source type of g is the same as the output type of f.
14:10:08 <kmc> though, i'm not sure what "community" means here
14:10:09 <bbear> someone talked (kmc) about clojure that I don't know.
14:10:13 <jedai> kmc: I probably don't have enough crazy ideas to compare them on this plan... But Scheme is pretty different because it isn't statically typed, I would agree that it's one of the best choices on the dynamically typed functional scene though
14:10:16 <kmc> bbear, those look like IRC channels, not languages
14:10:26 <m_stone> tkahn6: what about with programs?
14:10:28 <bbear> I could try it yes but I am not sure where it will bring me.
14:10:42 <bbear> kmc, yes think as the language, not as the irc channel.
14:10:43 <kmc> jedai, yes, Scheme is different from Haskell.  it's different in a way that is probably an asset for the goal of "code immediatly and simply my craziest ideas"
14:10:54 <kmc> bbear, anyway, you're getting pretty off topic
14:11:14 <bbear> ...
14:11:15 <m_stone> tkahn6: just as with functions, two programs p and q can be composed as p;q when the output type of p is the same as the input type of q.
14:11:26 <ddarius> kmc: For this purpose, probably people you can "talk" to/ask questions/producing resources.  There are plenty of venues for doing this besides IRC, and many languages use other venues much more heavily than Haskell and IRC much less.
14:11:28 <tkahn6> m_stone: right
14:11:34 <kmc> bbear, are you also asking this question in #ocaml, #scheme, #lisp, #erlang?
14:11:40 <foobar_hask> no
14:11:44 <m_stone> tkahn6: the question then becomes, how should we describe these types?
14:12:10 <bbear> kmc, because the #erlang chan is much more big I could have pertinent answer more easily
14:12:26 <tkahn6> m_stone: depends what you want aspect of the program you want to express in the types
14:12:36 <m_stone> tkahn6: one idea, which works pretty well in pratice, is to use a single type for everything and to accept that some programs will get stuck.
14:12:40 <jedai> kmc: Probably, dynamic typing usually helps for experimentation but not always, once you're used to it, types may help to structure your idea so that you have a result faster finally
14:12:57 <m_stone> tkahn6: this idea leads to un(i)typed languages.
14:13:10 <kmc> jedai, it's not just about dynamic types; the Lisp family supports metaprogramming far better than anything else I've seen
14:13:12 <tkahn6> m_stone: right
14:13:14 <bbear> Actually my real question is what each of this language has different from ocaml.
14:13:23 <kmc> bbear, why don't you ask #ocaml
14:13:27 <bbear> because ocaml is still a good language.
14:13:30 <jedai> kmc: That's undiscutably true :)
14:13:31 <bbear> ok
14:13:37 <ddarius> bbear: Also why wouldn't you actually ask the question you have?
14:13:40 <bbear> it could be simpler.
14:14:18 <m_stone> tkahn6: another idea that works pretty well in practice is to introduce some additionaly machinery like sum and product types and maybe some base types for things like numbers.
14:14:25 <kallisti> bbear: what does any other language have that C doesn't?
14:14:35 <hpc> kallisti: lambdas
14:14:39 <m_stone> tkahn6: then we introduce two additional types: one for functions, and one for programs with arbitrary side-effects.
14:14:41 <kallisti> C is still a good language.
14:14:44 <kallisti> no need to use anything else.
14:14:50 <bbear> kmc, I think I don't ask in #ocaml because I guess they only know #ocaml.
14:14:50 <tkahn6> m_stone: ok
14:15:05 <kmc> kallisti, stop trolling
14:15:16 <companion_cube> hpc: there's a C extension with lambdas :)
14:15:19 <jedai> bbear: Well as someone who started with OCaml and discovered Haskell later, I can tell you that if the parts that interest you in OCaml were the functional parts, you'll be happier with Haskell
14:15:43 <kmc> what if the parts that interest you are solving problems and getting work done?
14:15:48 <kmc> then it's a much less clear tradeoff
14:15:54 <kallisti> Haskell: now with more functions!
14:16:00 <m_stone> tkahn6: that way, we can compose functions whenever their input and output types match
14:16:11 <bbear> jedai, that's exactly the kind of answer I looked for :)
14:16:14 <jedai> bbear: But OCaml has some pretty interesting stuff too, like their functor system (Haskell modules aren't anywhere near that good, though type class can play a similar role in some cases)
14:16:32 <m_stone> say, we write length :: [Int] -> Int and replicate :: Int -> Int -> [Int]
14:16:35 <kmc> for example the ocaml implementation has some big advantages over GHC
14:16:42 <kmc> and strict evaluation has some advantages over lazy evaluation
14:16:51 <tkahn6> m_stone: right and you can go a little faster if you'd like, i am aware of the motivation behind types
14:16:59 <companion_cube> kmc: getting work done is so 2011
14:17:00 <m_stone> tkahn6: great.
14:17:06 <ddarius> kmc: jedai was not making any claim, one way or another, about other motivations for using (or not using) O'Caml.
14:17:13 <jedai> kmc: And lazy evaluation has some advantages over strict evaluation too ;)
14:17:26 <kallisti> tkahn6: I wouldn't say speed is the biggest benefit of static typing.
14:17:30 <kmc> yeah, but that makes it hard to say "you'll be happier with Haskell"
14:17:34 <kmc> it really depends
14:17:36 <companion_cube> kallisti: I would say safety
14:17:37 <tkahn6> kallisti: wat
14:17:49 <m_stone> tkahn6: the point here is that in the model with separate types for programs and functions, we give functions types like a -> b and programs types like a -> IO b.
14:17:51 <kallisti> yes type safety is the important aspect of static typing.
14:17:54 <arcatan> bbear: in Haskell, if you want to use side-effects, you have to say it in your function type (ie. use the IO monad). I don't think OCaml has that.
14:18:10 <tkahn6> m_stone: sure
14:18:16 <jedai> kmc: For functional style, lazy evaluation makes a real difference, makes it far saner to use higher level functions
14:18:17 <arcatan> bbear: it's pretty interesting feature for a functional programmer
14:18:25 <jedai> higher order
14:18:37 <kallisti> m_stone: that distinction isn't really valid. >_>
14:18:38 <m_stone> tkahn6: well, it turned out to be handy to give more fine-grained types to programs in order to distinguish them according to the "notion of computation" in which they worked.
14:18:39 <ddarius> kmc: Which is why he qualified his statement, but yeah, there are tons of reasons why you might prefer O'Caml's -functional- features over Haskell if you were interested in O'Caml for (only) its functional features.
14:19:19 <tkahn6> m_stone: ok
14:19:28 <m_stone> tkahn6: when we do that, we wind up with bunches and bunches of mutually-incomposable arrow-types of the form (a -> m b), (a -> n b), ....
14:19:38 <jedai> kmc: Using functional composition is almost unheard of in OCaml, because it often would be an horrible decision performance wise
14:19:42 <ddarius> At any rate, whether a language is "good" strongly depends on the person doing the programming, particularly whether they think it is good.  I find these "which is better" questions/discussions completely pointless.
14:19:51 <tkahn6> m_stone: right
14:20:05 <kmc> ddarius, yeah
14:20:13 <kmc> it also depends on what you're doing, of course
14:20:26 <kallisti> of course PHP is never a good choice.
14:20:28 <ddarius> kmc: True and that also depends strongly on the person doing the doing.
14:20:44 <kmc> one of my main criteria is "Are you spending most of your time fighting the language in ways that are irrelevant to the problem you're solving?"
14:20:55 <ddarius> kmc: But even if I know what you are doing, my opinions on which language is better for that are not too useful to you.
14:20:57 <jedai> ddarius: I don't think one or the other is better (there are definitely fields where I think OCaml is more adapted) but I think the fundamental choices Haskell made lend themselves better to a more functional style of writing
14:21:16 <bbear> kmc, actually I find this to be true to use python or C when I want to code some thing.
14:21:27 <jedai> kmc: ddarius bbear: Or maybe "compositional" style
14:21:27 <bbear> Any imperative language in general.
14:21:32 * companion_cube writes more Haskell than Ocaml because the build system is simpler, and there are more libs -_-
14:21:35 <kmc> Haskell is an imperative language
14:21:38 <m_stone> tkahn6: the punch line is that we care about categories because we care about composability.
14:21:46 <bbear> kmc, why is it imperative ?
14:21:58 <kmc> bbear, because it supports imperative programming?
14:22:02 <copumpkin> how do I kill the text reloc spam in ghc 7.2.2 on mac os 10.7?
14:22:04 <kmc> so do ocaml, scheme, clojure, etc
14:22:04 <bbear> my problem is I don't want to write more for loop
14:22:10 <kmc> you don't have to
14:22:11 <kmc> but you can
14:22:14 <m_stone> tkahn6: different categories contain different arrows; therefore, some categories describe functions, and other describe restricted classes of programs, and others describe both.
14:22:17 <jedai> kmc: No it ain't one... It can do imperative programming easily enough but its core is functional
14:22:39 <kmc> jedai, would you be happier if I say that IO is an imperative language embedded in Haskell?
14:22:46 <tkahn6> m_stone: that doesn't explain what exactly defines the semantics of 'the notion of computation' and how you then apply that to problems you may run accross
14:22:50 <jedai> kmc: Yes :D
14:23:00 <kmc> they're both described by the Haskell Report, though
14:23:03 <tkahn6> m_stone: for example, what 'notion of computation' does Parsec's monad express
14:23:03 <m_stone> tkahn6: hang on; there's another sentence or two coming.
14:23:07 <tkahn6> ah ok
14:23:41 <ddarius> tkahn6: Nondeterministic, stateful, exceptional programming.
14:23:50 <bbear> kmc, "<kmc> you don't have to <kmc> but you can" That's nice but I don't know if you understand how I want to turn my programming habits.
14:24:04 <jedai> bbear: You'll amost never write for loops in Haskell (though you can)
14:24:10 <bbear> I mean...
14:24:10 <kmc> i use forM_ all the time
14:24:13 <kmc> i don1't know about you
14:24:23 <tkahn6> jedai: i use forM_ a lot as well :p
14:24:26 <jedai> kmc: Ok, outside of IO code
14:24:32 <bbear> yes but for a new commer why would you tell me that I can write for loop if it's not my purppose ?
14:24:32 <kmc> no true scotsman
14:24:36 <kmc> I use forM_ outside of IO code too
14:24:44 <m_stone> tkahn6: we're looking for a category in which we can reason about both functions, programs with limited side-effects, and programs with arbitrary side-effects, and where everything that we think should be composable is.
14:24:46 <kmc> well forM more often
14:24:52 <kmc> but either
14:25:01 <tkahn6> m_stone: ok
14:25:04 <aristid> :t forM
14:25:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
14:25:19 <ddarius> bbear: If your purpose is just to learn about languages, particularly functional languages, just go do it.  I'm not sure why you need the questions you're asking answered.
14:25:27 <bbear> ok
14:25:51 <jedai> kmc: Ok. But forM isn't very often used as a for loop would be, that is you don't often modifiy IORef in it (though you may do thing to the State I agree)
14:25:55 <bbear> yes I'm in the haskell test page. it pleases me well.
14:26:08 <kmc> jedai, I don't know what we're really arguing about here
14:26:12 <kmc> I think the answer is "nothing"
14:26:12 <cmccann> kmc, you should use mapM instead, mapping lists is a very functional way to do it, for loops are too imperative
14:26:15 <bbear> No it's time to learn and stop to ask questions
14:26:20 <kmc> imperative = flip functional
14:26:25 <cmccann> kmc, :D
14:26:31 <arcatan> hah
14:26:45 <bbear> BTW,  does someone think about functional programming as a dual of imperative programming ?
14:26:55 <kallisti> probably.
14:26:55 <kmc> i don't like that Haskell is advertised as this pure perfect mathematical object of beauty
14:27:06 <kmc> it's a big disappointment if you think of it that way
14:27:11 <kmc> it is however a pretty good programming language
14:27:13 <ddarius> kmc: Who is advertising it that way?
14:27:27 <jedai> kmc: Of course, those are the best debates:) Well I think you were scaring bbear away by showing everything imperative Haskell could do and I was couterbalancing your argument
14:27:31 <m_stone> tkahn6: because our programs need to be composable too, we need to have some functors that map the arrows in our main category to some smaller category.
14:27:33 <cmccann> ddarius, mostly people who don't actually use Haskell much, I think
14:27:41 <m_stone> tkahn6: that's what the Kleisli arrow construction is doing.
14:27:51 <OscarZ> kmc: what are its biggest flaws as "the pure perfect mathematical object of beauty" ?
14:28:02 <kmc> i don't really want to get into it
14:28:03 <ddarius> OscarZ: Oh man, there are plenty.
14:28:08 <kmc> i don't even know where to start on that question
14:28:29 <kallisti> kmc: start with the Prelude
14:28:31 <kallisti> hope that helps.
14:28:32 <ddarius> The lambda calculus is pretty close, though, to something that is a reasonably beautiful mathematical object.
14:28:36 <cmccann> OscarZ, being imperfect is the main flaw, everything else follows from that :P
14:29:29 <kmc> anyway where I was going with this is that we shouldn't be ashamed of imperative programming in Haskell, or try to scare people away from it
14:29:36 <m_stone> tkahn6: the reason why the monads turn out to be useful for modeling notions of computation is related to this fact.
14:29:44 <tkahn6> m_stone: ah ok
14:29:51 <tkahn6> m_stone: i'll do some reading on Kleisli arrows
14:29:55 <kmc> if imperative programming is the right tool, use it
14:30:01 <m_stone> tkahn6: just a moment more, and I'll be able to direct you better.
14:30:01 <kmc> the interesting thing about haskell is that you do get other tools
14:30:12 <foobar_hask> kmc, does the haskell language is used as a mathematical tool also ?
14:30:13 <tkahn6> m_stone: excellent
14:30:18 <kmc> foobar_hask, no
14:30:21 <m_stone> tkahn6: as I was saying, the *reason* why they're related is something like this:
14:30:32 <jedai> kmc: Well it is one of the best imperative language (it's very easy to write new imperative patterns in it that other imperative language don't allow easily)
14:30:53 <m_stone> tkahn6: it's pretty clear that we need a way to lift a function a -> b to a program a -> m b with no side-effects.
14:31:09 <m_stone> i.e., that doesn't actually make use of any side-effects that might be allowed by m.
14:31:16 <tkahn6> m_stone: hence return
14:31:35 <aristid> :t (.) return
14:31:36 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
14:31:41 <aristid> heh.
14:31:50 <m_stone> tkahn6: additionally, we need a composition for programs.
14:31:51 <aristid> :t (Prelude..) return
14:31:52 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
14:31:57 <jedai> foobar_hask: What do you mean "as a mathematical tool" ? For symbolic manipulation sometimes, but it's not a specialized language like Matlab, mathematica or others more specialized ones
14:32:01 <m_stone> tkahn6: composition is just an associative binary operation with a unit.
14:32:14 <m_stone> tkahn6: in other words, it's a *monoid*.
14:32:20 <m_stone> tkahn6: does that make sense?
14:32:35 <foobar_hask> jedai: for example a mathematical tool for theoretical researcher in computing.
14:32:36 <tkahn6> m_stone: yes, i've taken some group theory/ring theory, i believe i understand
14:32:36 <akosch> what should I use to write bindings to this? http://hpaste.org/57129
14:32:41 <jedai> foobar_hask: Not that you can't do heavy computation though you'll have to use some of the hackage libraries to be efficient
14:32:57 <m_stone> tkahn6: right. so, unlike with groups, we don't have to guarantee the existence of inverses.
14:32:58 <ddarius> m_stone: It's not a monoid unless you have only one type.
14:33:03 <m_stone> (in fact, it would be terrible if we had to!)
14:33:34 <akosch> I mean I know there are some tools to automate parts of writing bindings, but I don't know anything about them
14:33:36 <ddarius> m_stone: You can glom everything together into one type, but then it produces a partial operation and thus is still not a monoid.
14:34:03 <jedai> foobar_hask: Rather than as a tool, it has been and still is the field of some pretty interesting experiments (many of our current tools originated within those experiments : STM, Parallel Haskell, ...)
14:34:05 <m_stone> ddarius: your points are well taken but I'm not going to address them right now.
14:34:45 <foobar_hask> Do you know why functional languages don't become mainstream languages, as C++ or java ? (if ever it is true ...)
14:35:26 <mjga> I have a cabal package that builds a library, and then I would like to build some executable tests based on this library. how should I declare dependency between these tests and library?
14:35:27 <jedai> foobar_hask: That is a vast question, there are historical reasons, and reputation problems
14:35:40 <ddarius> m_stone: You could avoid addressing them by not making factually incorrect statements that seem unnecessary.
14:36:04 <foobar_hask> And not practical reasons, you think ?
14:36:15 <diracdelta> hi, I'm trying to use the Text.Regex.Posix module, and get "foo foo foo" =~ "foo" :: [String] to work, but I get an error
14:36:24 <m_stone> ddarius: you misunderstand me; I'm very much looking forward to trying to address them shortly; I'm just also trying to finish the pedagogically relevant part of the story first.
14:36:27 <OscarZ> jedai: don't you think functional programming is inherently more difficult than imperative programming?
14:36:29 <foobar_hask> actually there is no reason about speed of implementation ?
14:38:15 <jedai> foobar_hask: Depends on what language, but most practical reasons are fallacies now : speed is (GHC is much faster than many language more used today), inherent difficulty have never been proved (when taught as a first language there was no evident difference with imperative first language in success of the students)
14:38:44 <m_stone> tkahn6: the thing I'm trying to get around to explaining at the moment is that m winds up being an endo-functor because of 'return', and it winds up being a monad because of the associative binary composition with 'return' as the unit.
14:39:28 <Ngevd> Hello!
14:39:36 <Ngevd> My brain has been exerting itself again
14:39:55 <Ngevd> I don't get how things can be functors but not applicatives
14:39:58 <jedai> OscarZ: No, I don't believe that, I believe that programmers that have used an imperative language for years have less difficulty learning a new imperative language than a functional one, but that no proof, and the converse would probably be true too (though hard to test in the current situation)
14:41:02 <kallisti> :t fmap ($x)
14:41:03 <lambdabot> forall b (f :: * -> *). (Functor f) => f (Expr -> b) -> f b
14:41:27 <cmccann> Ngevd, try to write an applicative instance for ((,) a)
14:41:36 <cmccann> without further constraining the type of "a"
14:41:48 <bbear> Actually I look als for a language that could give good fundations and basis to learn new languages,
14:42:18 <kallisti> bbear: Scheme is good for that. I can recommend a good textbook.
14:42:27 <erus`> let x = 2 in (x :: Integer, x :: Double)
14:42:30 <erus`> > let x = 2 in (x :: Integer, x :: Double)
14:42:31 <lambdabot>   (2,2.0)
14:42:34 <kallisti> bbear: but really just learn some languages. that's the best way to get a grasp of "foundations"
14:42:42 <erus`> clever...
14:42:52 <jedai> bbear: You won't find one, at best you'll get a language that'll gives you good fundations to learn _some_ other languages (in the same paradigm, with a closely related syntax, and so on) but that's all
14:43:01 <tkahn6> m_stone: i'm sorry, my knowledge of category theory is very minimal
14:43:04 <hpc> for extra fun, let x = trace "doop!" 2 in ... -- use ghci
14:43:05 <m_stone> tkahn6: so far as I can tell, that's why monads are a useful way to algebraically describe programs with arbitrary side-effects, and why other endo-functors with less restrictive algebraic properties are useful for describing other kinds of programs, like programs that have side-effects but where the ordering of the side-effects doesn't depend on the computations.
14:43:06 <bbear> Well, the idea to teach C to complete beginners is in my opinion the worst idea
14:43:38 <bbear> It gives you an idea of what I deem a language that could give you  good fundations .
14:43:44 <kallisti> http://mitpress.mit.edu/sicp/full-text/book/book.html  this book uses the Scheme language but is otherwise not related to Scheme at all. By the end of it, you learn how to create a compiler.
14:43:46 <bbear> neither C++ is a good idea.
14:43:55 <tkahn6> m_stone: but with that in mind, i'll do some more reading
14:44:03 <jedai> bbear: Well it's not an horrible idea, as long as it's not the first language and especially not the only language you teach to those beginners...
14:44:05 <m_stone> tkahn6: entirely understandable. (if it makes you feel any better, I spent a couple of years trying to learn it and, as ddarius correctly points out; I still haven't mastered it.)
14:44:13 <Taneb> Aha
14:44:13 <Taneb> Pure
14:44:13 <Taneb> Also, I'm Ngevd
14:44:15 <Ngevd> cmccann, thanks
14:44:37 <erus`> hpc in my ghci i get type error :|
14:44:44 <bbear> kallisti, it sounds good. jedai yes but if it's the first and only language you teach them ?
14:44:46 <erus`> is lambdabot special?
14:44:50 <jedai> bbear: And you don't try to make them think they should program in C to do "serious" programming
14:45:10 <jedai> bbear: Then it's an horrible idea !!
14:45:27 <cmccann> Ngevd, you also hit problems with (<*>) but they're more subtle
14:45:42 <jedai> erus`: lambdabot has some "extended" definition, like (.) = fmap for instance
14:45:47 <bbear> yes, but it is still the case sometimes.
14:45:51 <ddarius> m_stone: If you simply replaced "*monoid*" with "*category*" you'd have been fine.  I also would have been happy with "like a monoid."
14:46:15 <hpc> erus`: oh, turn on NoMonomorphismRestriction
14:46:47 <bbear> but http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-3.html
14:46:57 <m_stone> ddarius: yes, I think that makes sense. the problem with what I said is that we want to be able to compose kleisli arrows of type a -> m b and b -> m c, but that, as a result, we have more than one object?
14:47:20 <hpc> "ghci -fno-monomorphism-restriction"
14:47:23 <jedai> erus`: Ooops sorry, didn't see your code... What hpc said, and you should probably put it in your .ghci
14:47:31 <hpc> and import Debug.Trace
14:47:45 <ddarius> m_stone: Yes.  A category can be viewed as a monoid with multiple objects or a "typed monoid" or a "monoid with partial composition.)
14:47:59 <erus`> is that that restriction on by default in ghc too?
14:48:03 <hpc> yes
14:49:14 <bbear> From the little I know in ocaml, haskell looks very close.
14:49:19 <hpc> http://hpaste.org/57131 -- i didn't realize the monomorphism restriction worked like this
14:49:29 <hpc> ie, that both (x :: Integer)s triggered a trace
14:49:29 <bbear> the syntax is maybe simpler and more easy
14:49:51 <kallisti> as far as I know the semantics of O'caml and Haskell are quite different.
14:50:26 <jedai> bbear: it looks close but there are some really deep differences, the lazy evaluation may be the more fundamental one
14:50:44 <jedai> bbear: It change what you can and should write
14:51:05 <kallisti> I don't believe referential transparency doesn't hold in O'Caml, right?
14:51:27 <dolio> You might want to retry that.
14:51:29 <OscarZ> has the functional programming style been the most intuitive for all of you from the beginning? for me, imperative style feels the most "natural" at first, I have this object, modify it so and so, make a copy of it etc.. I guess this is because of real world analogies..
14:51:35 <bbear> you mean it changes the capabilities of the language itself, or it is just a technical details under the cover ?
14:51:56 <kallisti> both.
14:51:59 <bbear> OscarZ, honestly I started with BASIC.
14:52:08 <bbear> I am not sure it is very natural.
14:52:14 <raichoo> So did I.
14:52:21 <ddarius> O'Caml is, in my opinion, much closer to Java than it is to Haskell.
14:52:25 <raichoo> 20 years ago or so.
14:52:38 <dolio> ddarius: Really?
14:52:43 <ddarius> dolio: Yes.
14:52:43 <kallisti> OscarZ: hard to say. I started with Python, then moved into languages like Java, C#, perl, C, C++, javascript, etc, etc. I don't find either model particularly more or less intuitive.
14:52:45 <bbear> Functional - even if you don't think at the syntax - is a more intuitive way to think.
14:53:16 <bbear> maybe more abstract. Not necessarily less intuitive.
14:53:52 <ddarius> dolio: I would say how O'Caml is used is much closer to Haskell than Java (though that does involve a decent amount of assuming on my part), but that the languages themselves are very different in very fundamental ways.
14:53:56 <CodeWeaver> FP definitely wasn't sort of native to my brain.  I've had a couple of decades of imperative programming under my belt.  That being said, in university, I at least touched on a couple of non-imperative languages and found them interesting.  Perhaps that set the seeds for my quest for FP these days.
14:54:08 <dolio> Hmm.
14:54:36 <jedai> bbear: for instance, applying a function n times : applyN n f = (!!n) . iterate f
14:54:45 <CodeWeaver> I also do reasonably well at math and formal (if simple) proofs.  And I'm reasonably good at logic.  So induction doesn't bother me.  Recursion never really did as such, but it was just a tool, not a deep thought process.
14:54:54 <bbear> CodeWeaver, I definitely looks like you.
14:55:49 <mjga> bbear: I think OscarZ talks about some objects, maybe he started with something object-oriented, rather than pure imperative language... which may help to understand type classes, and need for immutable objects, doesn't it?
14:55:55 <CodeWeaver> So getting into FP isn't maybe as hard for me as for some people.
14:56:16 <bbear> I look like you I mean I have the same way.
14:56:18 <jedai> bbear: in OCaml you would write it with a direct recursion : "let applyN n f x= match n with | 0 -> x | n -> applyN (n-1) f (f x)
14:56:27 <CodeWeaver> bbear: I understand. :)
14:56:28 * ddarius needs to make more bread.
14:56:57 <bbear> jedai, honnestly I find the ocaml syntax horrible
14:57:20 <dolio> You're not alone.
14:57:21 <jedai> bbear: More generally, there's plenty of function in OCaml you have to write as a direct recursion, whereas in Haskell you'll use diverse higher order functions
14:59:30 <erus`> @hoogle m a -> m b -> (a -> b -> c) -> m c
14:59:31 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:59:31 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:59:31 <lambdabot> Data.IntMap intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
14:59:51 * ddarius thinks he'll walk to Davis Square and read a book.
15:00:03 <bbear> Does haskell is long to learn ?
15:00:23 <kallisti> can be
15:00:37 <CodeWeaver> I don't know if it would take longer to learn than, say, someone learning java or C++ for the first time.
15:01:12 <diracdelta> Hi, in a number of examples, the regex module can be used like: "foo foo foo" =~ "foo" :: [String]
15:01:15 <Triplefox> with java and c++ the resources are very widespread
15:01:16 <diracdelta> to obtain all matchses
15:01:23 <bbear> I finished the #haskell beginner tutorial.
15:01:27 <bbear> I need something more.
15:01:29 <Triplefox> there are practical codebases etc.
15:01:35 <kallisti> @where LYAH
15:01:35 <lambdabot> http://www.learnyouahaskell.com/
15:01:39 <kallisti> bbear: ^
15:01:43 <CodeWeaver> kallisti, good call!
15:01:44 <diracdelta> but when I try it in my terminal, I get an error. Did the interface to the module change?
15:01:54 <jedai> bbear: Very long, if you mean to master every one of its capacities (including languages extension), pretty fast if you just want to be able to write cool things and understand most programs in it (of course YMMV...)
15:01:57 <CodeWeaver> the Learn You A Haskell book is great.  So's Real World Haskell.
15:02:39 <bbear> I am on it
15:03:01 <kallisti> hmm, I should start doing Project Euler again. This time with Haskell.
15:03:13 <nexion> are there functions for combining maybes? i.e. Maybe a -> Maybe b -> Maybe c -> Maybe (a, b, c)
15:03:18 <kallisti> just glancing at the problem descriptions I can easily think of ways to model the problem in Haskell.
15:03:21 <jedai> bbear: But starting from OCaml should help you get over most of the usual barriers (you already know currying, the function application syntax won't trip you up...)
15:03:28 <kallisti> nexion: Applicative
15:03:48 <OscarZ> I think concentrating on the type system is important. first time I kind of read it through, thinking I understood how it works, but really didnt :)
15:03:50 <kallisti> > (,,,) <$> Just 2 <*> Just 4 <*> Just 6
15:03:50 <lambdabot>   Overlapping instances for GHC.Show.Show (d -> (a, a1, a2, d))
15:03:51 <lambdabot>    arising fr...
15:03:55 <kallisti> > (,,) <$> Just 2 <*> Just 4 <*> Just 6
15:03:56 <lambdabot>   Just (2,4,6)
15:04:00 <nexion> :o
15:04:02 <kallisti> > (,,) <$> Just 2 <*> Nothing <*> Just 6
15:04:02 <lambdabot>   Nothing
15:04:07 <nexion> I learned something today
15:04:09 <nexion> thanks!
15:04:19 <nexion> was wondering what those were
15:04:26 <jedai> bbear: You'll probably start by writing very OCaml-like code then realize it's not necessarily the best way
15:04:38 <kallisti> nexion: your life will be much simpler if you learn about the Monad, Functor, and Applicative instances for Maybe. :)
15:04:50 <kallisti> nexion: also MonadPlus is sometimes useful.
15:04:56 <kallisti> as a sport of logical or
15:04:59 <kallisti> s/sport/sort/
15:05:04 <erus`> @hoogle [a] -> n -> m a
15:05:04 <kallisti> > Just 3 `mplus` Just 2
15:05:05 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
15:05:06 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
15:05:06 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
15:05:06 <lambdabot>   Just 3
15:05:14 <bbear> I was not so deep in ocaml.
15:05:23 <kallisti> :t replicateM
15:05:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:05:45 <kallisti> erus`: what are you looking for?
15:05:54 <erus`> safe (!!)
15:05:59 <kallisti> ah
15:06:20 <bbear> The Learn you a haskell is interesting because well written and simple. I do prefer the haskell community to the ocaml community that is made essentially with french researchers in computer science or another branch.
15:06:26 <kallisti> > take 50 [1..25]
15:06:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
15:06:32 <kallisti> > drop 50 [1..25]
15:06:32 <lambdabot>   []
15:06:33 <bbear> INRIA
15:06:35 <bbear> I think
15:06:43 <zzo38> I wanted to compile Haskell programs into Glulx virtual machine. Some people told me to write a GHC Core interpreter. How does that work?
15:06:44 <erus`> i should use dependantly typed vectors
15:06:47 <kallisti> > listToMaybe $ drop 50 [1..25] -- erus`
15:06:47 <lambdabot>   Nothing
15:06:50 <bbear> or
15:06:53 <kallisti> > listToMaybe $ drop 10 [1..25] -- erus`
15:06:53 <lambdabot>   Just 11
15:07:41 <bbear> Haskell was made by some really smart guys (with PhDs).
15:07:45 <bbear> haha :)
15:07:51 <hpc> bbear: and more importantly, bowties
15:08:05 <kallisti> erus`: that's what you're looking for yes?
15:08:09 <dolio> Some didn't have PhDs.
15:08:17 <mjga> zzo38: you may run ghc with option to spit out Core language, it looks just like haskell, but doesn't have syntactic sugeer
15:08:18 <erus`> yup
15:08:39 <ddarius> bbear: Simon Peyton Jones doesn't have a PhD.
15:08:46 * hackagebot HaskellNN 0.1.1 - High Performance Neural Network in Haskell  http://hackage.haskell.org/package/HaskellNN-0.1.1 (KietLam)
15:08:48 <rostayob> zzo38: they're basically telling you to write a backend for the GHC compiler. GHC core is the language that GHC "desugars" haskell into, it's a lot simpler than Haskell and created to be compiled
15:08:49 <kallisti> @hoogle [a] -> Int -> Maybe a
15:08:49 <lambdabot> Prelude (!!) :: [a] -> Int -> a
15:08:49 <lambdabot> Data.List (!!) :: [a] -> Int -> a
15:08:49 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
15:09:05 <kallisti> yeah no library version of that as far as I know.
15:09:05 <zzo38> mjga: And how are you supposed to interpret (or compile) that, exactly?
15:09:38 <mjga> zzo32: it is just like lambda-calculus, plus few primitives
15:09:45 <kallisti> rostayob: wouldn't a backend deal with the C-- representation?
15:09:59 <rostayob> mjga: well not exactly, there's also the record passing and the pattern matching
15:10:13 <rostayob> kallisti: would it? why? the LLVM backend for examples compiles core
15:10:19 <rostayob> depends what you mean with "backend" I guess
15:10:29 <mjga> rostayob: you mean case expressions and records? that doesn't sound too complicated
15:10:37 <kallisti> oh really? I was under the impression that Core always compiled to STG which then went to C-- which then went to a backend. but I guess not.
15:10:47 <rostayob> mjga: case expressions and explicit type passing
15:10:48 <ddarius> You can put the backend wherever you want.  The benefit of using Core (or something later) is that GHC will already parse, type check, and optimize it.
15:10:58 <kallisti> Going Core -> LLVM seems like a big jump.
15:11:46 <rostayob> kallisti: I'm pretty sure that's how it works. Various Haskell->JS attempts compile Core as well.
15:12:00 <bbear> they can't all have a phd. yes. interesting.
15:12:09 <kallisti> I would be surprised if the LLVM backend didn't compile at least STG if not C--.
15:12:40 <alpounet> the LLVM backend starts with Cmm code
15:12:43 <ddarius> kallisti: GHC doesn't use C--.  It uses something vaguely like a sort of early version of C--.  Usually Cmm is used to refer to it.
15:12:50 <kallisti> ah okay.
15:12:54 * kallisti wasn't sure what to call it.
15:12:57 <zzo38> Which computers is the LLVM backend suitable for?
15:13:07 <kallisti> the STG paper I read called it "a simplified representation of C" or something like that.
15:13:19 <alpounet> zzo38, it's not really about computers, but rather programs
15:13:27 <jedai> zzo38: any where llvm works
15:13:29 <rostayob> kallisti: oh ok, my bad :)
15:13:56 <jedai> zzo38: It's pretty good now, better than the native codegen in many cases
15:13:56 <mjga> zzo38: most general purpose platforms nowadays have LLVM codegen, and I heard that nVidia and few FPGA or custom (DSP) processor companies are planning to have a backend too
15:14:16 <mjga> or maybe nVidia already has its backend, but doesn't publish it? not sure
15:14:17 <alpounet> zzo38, LLVM generally performs better than the native gen on scientific computing stuffs, for example
15:14:20 <zzo38> When you compile Haskell to LLVM, do you still need any other things to make it work?
15:14:47 <kallisti> rostayob: Haskell->JS makes sense to use Core as the intermediate because the output language is still fairly high level.
15:14:50 <mjga> zzo38: you need RTS=runtime support system
15:14:50 <alpounet> zzo38, well, you have to have (the original) llvm installed
15:14:52 <alpounet> that's it
15:15:20 <zzo38> I do have LLVM installed.
15:15:46 <mjga> zzo38: but of course GHC already seems to have LLVM gen
15:15:53 <alpounet> zzo38, then to build a program using the llvm code generator, use the -fllvm flag, iirc
15:16:13 <alpounet> (the llvm codegen is included in ghc)
15:17:00 <zzo38> And yes I thought, RTS would still needed too. So I would need LLVM->Glulx, and the Haskell RTS for Glulx is there anything important to know when compiling into such a virtual machine?
15:17:43 <rostayob> kallisti: yeah, I guess
15:19:19 <EvanR> with acid-state, does the log file grow monotonically as the state is updated?
15:19:33 <EvanR> or do checkpoints consolidate history
15:20:12 <erus`> how can i compile to core without an entry point?
15:20:19 <erus`> is there a library switch or something?
15:20:21 <fbern> hello folks. i was wondering which one of the two word8 attoparsec parsers (Data.Attoparsec.ByteString.Char8) is faster in matching a single character: satisfy or pure
15:20:59 <fbern> that is i want to match a single character ','. shall i use pure 44 or satisfy 44?
15:21:30 <hpc> fbern: unless the library is absolutely horrible, pure = satisfy
15:22:09 <ddarius> fbern: The latter is a type error and pure doesn't parse anything.
15:22:36 <hpc> er, that
15:22:52 <jedai> fbern: doesn't satify take a function ?
15:23:15 <mjga> zzo38: I don't know Glulx, but you need garbage collection at least and support for basic GHC primitives
15:23:21 <hpc> fbern: you want char or char8
15:23:24 <ddarius> word8 is the function you want to use.
15:23:24 <fbern> jedai: sorry. that was a typo. yes satisfy takes a function
15:23:26 <hpc> http://hackage.haskell.org/packages/archive/attoparsec/0.10.1.0/doc/html/src/Data-Attoparsec-ByteString-Char8.html#char
15:23:31 <bbear> why the "let" keyword has to be used in ghci but not in a file.hs ?
15:23:42 <ddarius> char8 takes a character (Char) but treats it as if it were latin1.
15:23:49 <fbern> hpc: char uses satisfy under the hood...
15:23:58 <hpc> bbear: in file.hs, you write definitions
15:24:02 <hpc> bbear: in ghci, you write expressions
15:24:03 <fbern> is there a faster method? i assume not
15:24:03 <jedai> fbern: so use char
15:24:15 <EvanR> you can also type definitions in ghci ;)
15:24:21 <EvanR> and io actions
15:24:21 <bbear> ok
15:24:41 <The_Journey> hi, I use FFI in my program with C-files that need header files. How would I express this in the cabal file?
15:24:52 <hpc> bbear: the longer answer is, ghci is a giant IO do-block with a whole bunch of quirks
15:25:04 <hpc> but that probably won't mean anything until later
15:25:13 <bbear> yes exactly
15:25:35 <fbern> thank you for the replies!
15:25:49 <dolio> In 7.4, you can do pretty much everything in ghci that you can do in a file.
15:25:55 <jedai> fbern: no, and you should probably just write your parser without asking yourself those question for each function, attoparsec was written to be fast, if it's too slow once you have it written it'll be time to search the problem (which is more likely to be in the structure than in the individual functions)
15:26:16 <mjga> EvanR: no I think you can't. My ghci 7.4RC2 complains when I try to type "f x = x + 2" in GHCi command prompt.
15:26:32 <EvanR> let f x = x + 2
15:26:42 <fbern> jedai: you are probably right. preliminary optimization is the root of all evil. we all know that ;-)
15:27:04 <mjga> The_Journey: you may request "framework" on mac, or external library on other platforms
15:27:30 <The_Journey> mjga: I have the header files included in my project
15:27:31 <mjga> EvanR: this is not how I put it in my source file, I'd omit let.
15:27:47 <EvanR> mjga: f x = x + 2 doesnt work in a do block
15:27:56 <bbear> hpc, Actually I prefere to ignore this until later.
15:27:59 <EvanR> see what hpc said
15:28:01 <bbear> doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
15:28:25 <bbear> this looks very like python. But when you start to do functional programming with python, you will end up very frustrated
15:28:26 <EvanR> mjga: and anyway, let f x = whatever is really useful in ghci
15:28:31 <EvanR> so stfu
15:28:33 <hpc> bbear: probably best; when i was learning, i did everything in a file too
15:29:54 <jedai> bbear: Well, here more than the functional paradigm, it's the idea that everything is an expression that is useful (though that makes more sense in a functional setting of course)
15:30:13 <EvanR> functional in python sucks
15:30:16 <hpc> jedai: except for the things that are syntax, ofc :P
15:30:39 <jedai> hpc: You mean definitions ?
15:30:56 <EvanR> if x then y else z
15:31:01 <mjga> The_Journey: I do not know the details, but I looked once at a package that did the same. (I think blas) It had separate declaration for C sources maybe "Includes:"?
15:31:02 <EvanR> syntactic sugar
15:31:34 <mjga> EvanR: yes it is useful, but due to some parsing restrictions it requires "let"
15:31:46 <EvanR> mjga: it also requires let in a do block
15:31:56 <jedai> hpc: well in language like C, the problem is that you have a ton of thing you can write in a definition, that are most definitely not a definition but still can't be used as an expression, no such thing in Haskell
15:32:21 <EvanR> mjga: so its not a restriction its just a different context
15:33:19 <jedai> hpc: Or were you talking about do syntax ?
15:33:24 <erus`> @hoogle [m a] -> m [a]
15:33:24 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:33:24 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:33:24 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
15:33:25 <mjga> maybe, nn anyway. got my lib compiling under ghc-7.4rc2 and working 10x faster, so I can go to sleep with a feeling of achievement.
15:33:47 * hackagebot libnotify 0.0.1.1 - Haskell binding for Libnotify  http://hackage.haskell.org/package/libnotify-0.0.1.1 (MatveyAksenov)
15:36:47 <OscarZ> coming from OO background, I just find it intuitive to create an object, manipulate properties of the object, but still end up with the same object.. I guess its intuitive cos in the stone age it was wise to think that the angry looking ape is the _same_ angry looking ape that hit you with a club a few days ago..
15:37:03 <EvanR> haha
15:37:17 <EvanR> yes thats why i refer to OO as buiding apps with sticks and stones
15:40:39 <OscarZ> yeah.. in Java, the design patterns often involve many classes and interfaces, typically some boilerplate template code that you duplicate etc.. I was surprised that when learning Haskell, some powerful concept like monads (I assume it is) are just expressed with a simple looking type signature
15:41:25 <EvanR> beware of anything marketed as 'powerful'
15:41:50 <EvanR> not sure computers should be carefully and meticulously programmed with 'power' xD
15:41:52 <OscarZ> I guess it just shows the expressiveness of the language, even though I dont yet know it that well
15:42:50 <OscarZ> yeah, but there is certainly some elegance when compared to some OO "design patterns" :)
15:43:47 * hackagebot HaskellNN 0.1.2 - High Performance Neural Network in Haskell  http://hackage.haskell.org/package/HaskellNN-0.1.2 (KietLam)
16:00:34 <nyingen> @quote
16:00:35 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
16:05:25 <insyde> anyone here?
16:05:29 <insyde> got a quick question
16:07:20 <EvanR> insyde is now outsyde
16:08:37 <stephenjudkins> in ghci, how do I show the type of an expression?
16:08:52 <EvanR> :t expr
16:08:53 <lambdabot> Expr -> Expr
16:09:19 <stephenjudkins> EvanR: thanks!
16:10:09 <stephenjudkins> :t [1,2,3]
16:10:10 <lambdabot> forall t. (Num t) => [t]
16:10:34 <stephenjudkins> ok, i would expect to see [Num]. what does the above mean?
16:10:53 <EvanR> Num is not a type
16:10:55 <EvanR> its a class
16:11:23 <EvanR> :t 3
16:11:24 <lambdabot> forall t. (Num t) => t
16:11:33 <EvanR> 3 is polymorphic
16:12:50 <MostAwesomeDude> :t 3 :: Int
16:12:50 <lambdabot> Int
16:12:51 <stephenjudkins> i see. what is the type signature telling me about Num? is the output above what i'd see for ANY typeclass?
16:13:55 <EvanR> number literals are special
16:14:07 <EvanR> they can be anything with a Num instance
16:14:16 <EvanR> :t ['a','b','c']
16:14:17 <lambdabot> [Char]
16:15:43 <penelope> I'm trying to derive an instance of <*> for the free monad, e.g. data Free f a = Var a | Node (f (Free f a))
16:15:43 <eviltwin_b> there is a compiler extension that makes strings polymorphic as well, often used with ByteString and (I think) Data.Text
16:15:51 * sm wants xmonad for emacs
16:15:54 <penelope> Without using >>=
16:15:57 <stephenjudkins> i can see how that can be very useful
16:15:58 <mreh> does this look suspicious to anyone?
16:16:01 <mreh> position p0 v0 = dSwitch (position' p0 v0) (\_ -> position (0,0) (0,0))
16:16:11 <mreh> (it's Yampa)
16:16:14 <EvanR> > 3 :: Complex Double
16:16:15 <lambdabot>   3.0 :+ 0.0
16:16:37 <mreh> it's causing an infinite loop
16:16:45 <mreh> but after the switching even
16:16:48 <stephenjudkins> scala's relative lack of flexibility when it comes to numeric types has been frustrating me on some euler problems
16:16:49 <mreh> but after the switching event
16:17:13 <penelope> sm: there are autolayout modes for emacs...
16:19:09 <mreh> boo hoo, nobody does yampa
16:20:02 <eviltwin_b> or you can use xmonad and rebind the window operations to frame operations (e.g. make C-x 4 f the same as C-x 5 f)
16:20:28 <sm> penelope: thanks
16:21:20 * sm wonders if a .virthualenv is still good after you've upgraded ghc
16:22:06 <penelope> sm: doubtful: any cabal stuff will need to be reinstalled.
16:33:00 <zzo38> In the documentation for the Q type in Template Haskell, it says instances Monad Q, Functor Q, and Quasi Q. Why is there no Applicative Q?
16:34:21 <hpaste> fffuu pasted “dzhus” at http://hpaste.org/57133
16:36:29 <eviltwin_b> zzo38, I believe one has been proposed.  the main reason is that Applicative is still quite recent in terms of Haskell, I think
16:37:32 <gregAtio> hi what do i have to import to  use realToFrac
16:37:39 <gregAtio> * realtoFrac
16:37:51 <gregAtio> ,realtoFrac
16:38:16 <EvanR> nothing
16:38:16 <zzo38> eviltwin_b: OK
16:38:24 <EvanR> :t realToFrac
16:38:25 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
16:38:25 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
16:38:39 <gregAtio> thanks
16:39:38 <eviltwin_b> @index realToFrac
16:39:38 <lambdabot> Prelude
16:46:10 <kmc> so, there is a Hackage package versioning policy for libraries, but is there any policy regarding packages which provide only an executable?
16:46:25 <Sgeo> So, I am making an API. The API is all IO stuff. Most of the functions have one argument in common, and most of the time that argument will stay the same across all the calls that are made
16:47:19 <Sgeo> Now, do I have my functions return ReaderT AWInstance IO a, accept the AWInstance as the last argument (making monadic use reader-style possible), or as the first argument, which seems to be the convention with things like hPutStr
16:52:51 <erus`> what is the infix(l/r) of (->) ?
16:53:42 <Sgeo> a -> b -> c is a -> (b -> c)
16:53:49 <hpc> erus`: infixr
16:53:52 <Sgeo> Although I don't think (->) is a function
16:53:53 <hpc> i forget how tight it binds
16:54:00 <hpc> Sgeo: it's a type constructor
16:54:15 <hpc> which can have fixity
16:54:17 <erus`> except in a case expression
16:54:31 <tikhonjelvis> In a case expression it's just part of the syntax.
16:56:19 <tikhonjelvis> Also, it's part of a lambda (\ x -> x * x) but that's also syntax.
16:56:50 <hpc> well, now that we all know haskell syntax... :P
16:57:02 <tikhonjelvis> hpc: You are, I think, too optimistic.
16:57:07 <erus`> (->) Int ((->) Int Int) = Int -> Int -> Int   then right?
16:57:17 <hpc> erus`: yes
16:57:20 <Jafet> @quote best.view
16:57:20 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
16:57:36 <hpc> let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x
16:57:38 <kmc> i can't find the docs for -XTypeOperators in the GHC manual
16:57:42 <hpc> > let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x
16:57:43 <lambdabot>   0
16:57:57 <kmc> anyway it seems that (->) is below infixr 0
17:00:06 <napping> Isn't it supposed to be?
17:00:48 <kmc> napping, supposed by what?
17:01:13 <napping> the grammer in the report
17:02:11 <napping> The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible.
17:02:15 <kmc> standard Haskell doesn't have infix type operators other than (->)
17:02:22 <kmc> oh, I meant in the type context
17:03:33 <kmc> "Unlike data constructors, infix type constructors are not allowed"
17:04:01 <napping> Ah, I guess lambda/case was just a digression
17:04:03 <kmc> the GHC extension -XTypeOperators relaxes this, but I couldn't find docs on the fixity of (->) and whether fixity settings for other operators would be honored
17:04:07 <hpc> ghc breaks the rules a bit then, with the decision to support things that start with ':'?
17:04:20 <kmc> hpc, those are data constructors, not type constructors
17:04:36 <kmc> the ones you can use without any flag
17:04:37 <hpc> kmc: i mean, type constructors that being with it
17:04:45 <kmc> right, that requires -XTypeOperators
17:04:46 <hpc> oh, you need an extension for those
17:04:47 <hpc> nvm then
17:05:24 <napping> 7.4.3 in the user's guide claims -> is infixr 0
17:05:33 <kmc> cool
17:05:38 <kmc> is that online?
17:05:47 <napping> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
17:06:00 <napping> also claims fixity declarations apply to both type and value operators
17:06:13 <tikhonjelvis> :i (:)
17:06:20 <tikhonjelvis> I guess that doesn't work :(
17:06:20 <kmc> oh, I missed this because it's neither in the "Syntactic extensions" section nor does it contain the string "-XTypeOperators"
17:06:28 <kmc> not in lambdabot
17:06:30 <tikhonjelvis> On lambdabot, I mean.
17:06:34 <kmc> works in GHCi
17:06:38 <tikhonjelvis> Yes, I know.
17:06:47 <kmc> as does :i (->), but it doesn't say fixity
17:06:49 <tikhonjelvis> But GHCi is in a different buffer and I am terminally lazy.
17:06:51 <kmc> data (->) a b   -- Defined in GHC.Prim
17:07:00 <tikhonjelvis> @help
17:07:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:07:57 <napping> I expected that section also, but searching for "infix" on the table of contents turned it up
17:08:23 <napping> are you doing anything particularly tricky with infix operators?
17:10:49 <elliott> declaring fixities for type operators works in 7.0 i think
17:10:51 <elliott> at least
17:11:34 <dufflebunk> I have a binary data file I'd like to parse in Haskell. The format has offsets to different record types and is a fairly complex file format. Does anyone have any suggestions of packages which might make this easier?
17:11:53 <napping> will 7.4 support data declarations in ghci?
17:12:27 <napping> dufflebunk: binary is nice for the sequential parts, I don't know of anything that helps much for seeking around
17:13:08 <Sgeo> So, any advice on API design?
17:14:04 <napping> I've handled it for files of bounded size just by reading it all in an using "drop" on the bytestring for seeking
17:14:28 <dufflebunk> napping, I used binary at first, but switched to Serialize because it had some limitation, but I can't remember what they were.
17:14:30 <elliott> dufflebunk: cereal or attoparsec
17:14:32 <dylukes> dufflebunk: Generally Trifecta/Parsec are good for that stuff.
17:14:35 <dylukes> or Cereal/Attoparsec
17:14:42 <dylukes> if you value speed over sanity.
17:14:46 <elliott> trifecta would be a bad choice for a binary file
17:14:49 <dylukes> Cereal is more like binary
17:14:57 <dylukes> elliott: Trifecta uses Bytestrings internally.
17:14:58 <elliott> sounds like dufflebunk is already using cereal though.
17:15:04 <elliott> dylukes: yes, and afaik assumes utf-8
17:15:06 <napping> It was a format where the file was gzipped, so just seeking wasn't easy
17:15:14 <elliott> dylukes: also, the whole diagnostics support si just going to produce garbled nonsense for binary files
17:15:16 <edwardk> trifecta was designed for parsing programming languages not binary files
17:15:20 <dylukes> That's true.
17:15:21 <elliott> *is
17:15:23 <edwardk> the diagnostics i give would kinda suck for binary =)
17:15:25 <dylukes> :P
17:15:27 <dylukes> mm...
17:15:29 <dylukes> Attoparsec?
17:15:31 <edwardk> look at this line noise. there is an error in that
17:15:37 <Sgeo> So, no design help?
17:15:38 <dylukes> I swear!
17:15:43 <napping> Anyway, all that stuff is for parsing sequential data, isn't it?
17:15:44 <elliott> edwardk: especially fun if your binary file contains valid ANSI escapes
17:15:54 <elliott> napping: yes
17:16:05 <dylukes> I suggested Trifecta because of the seek/mark stuff, but yeah...
17:16:13 <dylukes> does attoparsec have seek/mark stuff?
17:16:28 <edwardk> copumpkin was working on a binary parser that supported seeking
17:16:37 <irene-knapp> so was I, haha
17:16:43 <napping> I don't think those are different enough to worry about, if you can already read individual records
17:16:52 <dylukes> I think you can do it with IterIO.
17:17:09 <elliott> iteratee and iterIO both do seeking
17:17:09 <dylukes> It has seeking support.
17:17:11 <dufflebunk> elliott, Yeah, using Cereal now. It helps with parsing the records individually.
17:17:21 <napping> are there any further restrictions, like non-overlapping sections or only forward references?
17:17:23 <elliott> dufflebunk: right. probably best to just hand-roll the non-sequential parts
17:17:29 <dylukes> IterIO is much nicer for files in my experience.
17:17:33 <dylukes> If only for the convenience functions.
17:18:27 <dufflebunk> elliott, That's what I figured. I couldn't think of how a library could possibly simplify the seeking and searching. But figured I'd ask.
17:18:29 <dylukes> And it's one of those rare cases on Hackage where there's ostensibly TOO MUCH documentation.
17:18:40 <dylukes> dufflebunk: Try out IterIO or iteratee.
17:18:50 <dylukes> iteratee is more conceptual/simpler. IterIO is made for this stuff.
17:18:50 <elliott> if your data fits in memory
17:18:55 <elliott> it'll be easier to just hand-roll it with ByteString
17:19:08 <napping> What are you trying to parse?
17:19:14 <dufflebunk> The files are big.
17:19:42 <otk> howbig?
17:19:46 <dufflebunk> napping, a proprietary geo-spatial database format we use at work.
17:19:47 <dylukes> If you go the IterIO route it can also shoehorn in attoparsec parsers, and if you use the enumerators package for iteratees, theres an attoparsec-enumerator package as well.
17:19:52 <napping> then you may want to handroll something seeking on the files
17:19:55 <dufflebunk> otk, 1kB to 50 GB.
17:20:07 <dylukes> http://hackage.haskell.org/packages/archive/iterIO/0.2/doc/html/Data-IterIO-Parse.html
17:20:09 <Sgeo> IterIO only works on unix things I think
17:20:14 <napping> are you even trying to parse the whole file?
17:20:21 <otk> IO.MMap?
17:20:29 <napping> sounds bad at 50GB
17:20:31 <dylukes> It does depend on unix-2.5
17:20:37 <otk> i will confess i have nfi how memory mapping works in haskell yet
17:20:46 <dylukes> otk: Bindings to mmap :P?
17:20:47 <dylukes> How else.
17:20:59 <dufflebunk> otk, yeah, that's what I'm using. mmap as a bytestring
17:21:01 <otk> on linux
17:21:11 <otk> windows different i would hope
17:21:15 <otk> dufflebunk: ah ok
17:21:17 <dylukes> CreateFileMapping and MapViewOfFile on windows.
17:21:18 <elliott> Sgeo: only unix things work
17:21:29 <dylukes> Which are just Windows-speak for mmap >_>.
17:21:33 <otk> ah
17:21:34 * dufflebunk goes to read bout iterIO
17:21:42 <otk> ive only used .net for mmio
17:21:45 <dylukes> iterIO only works on unix/linux mind you.
17:21:55 <napping> dufflebunk: as for how it might fit into an API, I could imagine some kind of "parseAt :: FileOffset -> Parser a -> Parser a" combinator
17:21:59 <dufflebunk> I don't use windows at work anyways.
17:22:03 <DanBurton> if you like iterIO, you may also like pipes
17:22:15 <DanBurton> @where pipes
17:22:15 <lambdabot> I know nothing about pipes.
17:22:17 <dylukes> iterIO is very reminiscent of bash piping if you're used to that dufflebunk.
17:22:17 <napping> If you are happing mmaping the whole thing into a bytestring, I don't see what iterIO will buy you
17:22:21 <elliott> DanBurton: *@hackage
17:22:25 <elliott> i don't think pipes does seeking so it's not appropriate here
17:22:38 <elliott> though i may be wrong
17:22:40 <DanBurton> @where+ pipes http://hackage.haskell.org/package/pipes
17:22:40 <lambdabot> Nice!
17:23:02 <dylukes> iterIO basically takes the whole iteratee/enumeratee/iterator model and makes it a bit easier, imo.
17:23:15 <napping> dylukes: where is the seek in iterIO?
17:23:26 <DanBurton> pipes is just a light library for enueratee-like stuff
17:23:30 <elliott> @hackage pipes
17:23:30 <lambdabot> http://hackage.haskell.org/package/pipes
17:23:37 <elliott> why have a @where entry for every hackage package? :p
17:23:39 <dylukes> http://hackage.haskell.org/packages/archive/iterIO/0.2/doc/html/Data-IterIO-ListLike.html
17:23:40 <DanBurton> iterIO has a lot of convenience things for IO though
17:23:49 <DanBurton> iirc
17:23:51 <dylukes> napping: it's a control command.
17:24:05 <elliott> pipes is mostly simple because it punts on the hard problems imo
17:24:17 <DanBurton> elliott: perhaps I should point it to the blog post, then.
17:24:20 <dylukes> One of the big gains in iterIO is that you can send messages/control commands BACKWARDS
17:24:25 <DanBurton> @google pipes haskell
17:24:26 <lambdabot> Plugin `search' failed with: getAddrInfo: does not exist (Name or service not known)
17:24:31 <DanBurton> D:
17:24:36 <elliott> lambdabot is getting old these days
17:24:40 <dylukes> Pipes looks nice btw.
17:24:44 <DanBurton> @botsnack
17:24:45 <lambdabot> :)
17:24:55 <dylukes> @ballsack
17:24:55 <lambdabot> Unknown command, try @list
17:25:01 <napping> dylukes: so this doesn't really buy anything if the whole file is already mmaped?
17:25:14 <dylukes> napping: hm?
17:25:17 <dylukes> what doesn't?
17:25:30 <napping> iterIO
17:25:44 <dylukes> mmap'ing maps a file into virtual memory
17:25:45 <dylukes> not physical memory.
17:25:54 <dylukes> You have a few options
17:26:07 <dylukes> as to how you work that into iterIO.
17:26:19 <napping> sure, but if it's all in a big bytestring you can just use "drop" to get a suffix at an offset you like
17:26:31 <napping> and then use the already-written code in Serialize to parse out a chunk
17:26:37 <dylukes> Yeah you could. iterIO just has a lot of convenient parsing faculties.
17:26:41 <dylukes> napping: sure.
17:26:50 <Enigmagic> this calls for mfix and some tequila
17:26:52 <dylukes> It depends on whether you think its worth the mindshare.
17:27:08 <dylukes> Though to be honest, if you use piping in bash enough, and have a basic grasp of iteratees,
17:27:09 <napping> dufflebunk: you have 50GB of address space, right?
17:27:10 <elliott> @remember Enigmagic this calls for mfix and some tequila
17:27:11 <lambdabot> Nice!
17:27:11 <dylukes> iterIO isn't hard, just big.
17:27:23 <dufflebunk> yeah 64bit machines
17:27:33 <dylukes> iterIO is a more flexible approach imo.
17:27:47 <dylukes> It'll work regardless of how you decide to load your data (unless you're on windows).
17:28:02 <Enigmagic> :)
17:28:04 <otk> i like this inlining of C in haskell thing
17:28:19 <otk> pretty convenient
17:28:45 <Enigmagic> otk: hsc2hs?
17:28:48 * hackagebot HaskellNN 0.1.3 - High Performance Neural Network in Haskell  http://hackage.haskell.org/package/HaskellNN-0.1.3 (KietLam)
17:28:58 <dylukes> "Check out Control.Pipe for a copious introduction (in the spirit of the iterIO library) and Control.Pipe.Common for the actual implementation."
17:29:11 <dylukes> edwardk: Is iterIO's copious introduction becoming a hackage meme?
17:29:22 <edwardk> ?
17:29:29 <dylukes> I'm pretty sure I saw the phrase
17:29:34 <dylukes> "(in the spirit of the iterIO library)" somewhere else as well.
17:29:45 <dylukes> with respect to its copious introduction and documentation.
17:29:52 <otk> Enigmagic: i believe Foreign.C.Types
17:30:01 <otk> and then foreign import ccall unsafe "blah.h"
17:30:13 <napping> oh, not an actual inlining thing
17:30:19 <Enigmagic> otk: well the blah.h doesn't really do much of anything
17:30:33 * ddarius hopes edwardk (and xplat) have thoroughly left faffing about with enumeratees.
17:30:36 <Enigmagic> what i want to build some day is the clang quasi-quoter, it's on my todo list
17:30:41 <napping> yeah, the FFI is pretty convenient
17:31:02 <ddarius> A little bit of TH and you could have inline C code quite easily.
17:31:03 <otk> well, its not my code and i know little of the compiler magic, but i can figure enough how it would call externally
17:31:18 <otk> its just neat that it can use the actual .h rather than the compiled .dll or whatever
17:31:40 <elliott> ddarius: But faffing is the best thing to do!
17:31:48 <otk> what i am used to is dropping cdecl all around, compiling to .dll then pinvoking
17:32:58 <hpaste> t pasted “t” at http://hpaste.org/57134
17:32:58 <Enigmagic> otk: does it actually use the header file? i've made typos in the filename before and it didn't complain
17:33:05 <otk> http://hpaste.org/57134 <-
17:34:23 <napping> I think ghc usually doesn't at least if you are compiling to native code
17:35:16 <napping> I don't remember the details but some compilers or modes will generate a C stub file, and include the listed header
17:35:31 <elliott> only -fvia-c uses the headers
17:35:48 <elliott> at least the default native code backend uses a stub file
17:35:58 <elliott> i guess the header is probably included actually
17:36:02 <elliott> but you don't need it at least
17:36:15 <otk> im linking with the .o of it at compile time
17:36:47 <otk> ghc --make -O2 -funbox-strict-fields file.hs mtrandom.o -o blah
17:36:51 <otk> tested and works
17:37:14 <elliott> --make isn't required as of at least ghc 7 btw
17:37:21 <otk> cool
17:37:29 <otk> just drop the --make?
17:37:48 <otk> i just learnt the flags from the makefile
17:40:27 <peterjoel> anyone know when there'll be a haskell platform release with GHC 7.4.x ?
17:41:10 <peterjoel> or will it be 7.2 first?
17:46:07 <napping> I think 7.4 will be out first
17:46:38 <peterjoel> but there isn't a published timescale?
17:47:54 * DanBurton just submitted a solution to one of the Facebook hacker cup problems. In Haskell, of course. :)
17:48:57 <Sgeo> :t foobar
17:48:58 <lambdabot> forall a. (Floating a) => a -> a
17:52:20 <DanBurton> > foobar 3
17:52:21 <lambdabot>   4.440892098500626e-16
17:52:50 <DanBurton> not the most descriptive name...
17:53:49 <elliott> @check \f -> not (foobar === f)
17:53:50 <lambdabot>   Not in scope: `==='
17:53:53 <elliott> hmph
17:54:18 <DanBurton> wat
17:56:26 <elliott> i thought quickcheck had (f === g) for forall x. f x = g x
17:56:46 <DanBurton> @hoogle (===)
17:56:46 <lambdabot> No results found
17:58:28 <otk> confusing that ['a'..'z'] returns a string sequence :<
17:58:50 <djahandarie> > ['a']
17:58:51 <lambdabot>   "a"
17:58:56 <djahandarie> > ['a', 'b']
17:58:57 <lambdabot>   "ab"
17:59:04 <djahandarie> > ['a' .. 'z']
17:59:05 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
17:59:29 <elliott> otk: 'a' :: Char
17:59:37 <djahandarie> > ['a' .. 'z'] ++ ['z', 'y' .. 'a']
17:59:38 <elliott> [a..b] :: [t] given a :: t and b :: t
17:59:38 <lambdabot>   "abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba"
17:59:43 <elliott> > [0..10]
17:59:44 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
17:59:53 <elliott> and String = [Char]
18:00:06 <otk> well, its not so much confusing when you think that a string is just a character array anyway
18:00:06 <Sgeo> > ['z','y'..]
18:00:07 <lambdabot>   "zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:98765432...
18:00:13 <Sgeo> >=<
18:00:30 <otk> just different to ocaml and such i guess
18:00:30 <Sgeo> `_^
18:00:49 <Sgeo> >=< best emoticon
18:00:56 <elliott> otk: not an array, a list
18:01:08 <elliott> [] = (singly) linked list; there are other packages for arrays
18:01:18 <otk> let f m = match m with | ['a'..'z'] -> blah
18:01:29 <otk> elliott: ah sorry, list in haskell
18:01:55 <otk> ok so string = char list
18:02:00 <otk> makes sense enough
18:02:27 <otk> going through learnyouahaskell
18:05:14 <otk> hmm
18:05:23 <otk> [x*2 | x <- [1..10]] list comprehension
18:05:34 <otk> is it different to say map ((*) 2 [1..10]
18:05:54 <otk> oops map ((*) 2) [1..10]
18:06:00 <otk> >  map ((*) 2) [1..10]
18:06:01 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:06:10 <otk> > [x*2 | x <- [1..10]]
18:06:10 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:06:21 <otk> that pipe operator seperating the lambda is kind of awkward
18:06:44 <Sgeo> Note that you can write ((*) 2) as (2*)
18:06:52 <otk> cool
18:06:59 <otk> less noise
18:07:24 <hpc> > (* 2) <$> [1..10] -- or this
18:07:25 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:07:35 <otk> whats the <$>?
18:07:47 <hpc> (<$>) = fmap, which is a generalization of map
18:07:47 <dylukes> <$> == fmap
18:07:52 <otk> ah
18:07:53 <hpc> for lists, map = fmap
18:07:57 <ddarius> > (2*) . [1..10]
18:07:58 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:08:06 * ddarius sows confusion.
18:08:10 <dylukes> >_>
18:08:12 <otk> ugh what the hell is '.'
18:08:15 <dylukes> ddarius: That's just in lambdabot...
18:08:16 <hpc> in lambdabot, (.) = fmap
18:08:18 <hpc> ignore that
18:08:21 <otk> ok
18:08:30 <otk> dislike the character '.'
18:08:38 <elliott> (.) is used for function composition
18:08:38 <hpc> if you're going through lyah, just continue
18:08:38 <dylukes> No no.
18:08:41 <elliott> so you better get used to it :)
18:08:41 <Sgeo> otk, . is not normally used like that
18:08:43 <dylukes> . is function composition.
18:08:44 <ddarius> otk: Then you are going to have a lot of problems.
18:08:45 <dylukes> like
18:08:47 <hpc> it'll all be clear in time, if you ignore our ramblings
18:08:53 <penelope> one day, map will be fmap, and map will be Data.List.map
18:08:54 <otk> even though it is the smallest possible lol
18:08:54 <otk> heh
18:08:56 <dylukes> > let f = (+2) . (+3) in f 1
18:08:57 <lambdabot>   6
18:09:04 <Sgeo> It's usually used like (f . g) x is f (g x)
18:09:06 <otk> well, i see '.' and im reminded of php atrocities
18:09:14 <dylukes> heh no
18:09:22 <elliott> well haskell is of course exactly like php
18:09:37 <ddarius> elliott: That's why Facebook uses PHP and Haskell.
18:09:44 <elliott> Yes.
18:09:46 <dylukes> (.) is also >>> no?
18:09:51 <dylukes> In Control.Category.
18:09:53 <hpc> dylukes: (<<<)
18:09:54 <ddarius> dylukes: Flipped.
18:09:56 <dylukes> Ah, okay.
18:10:01 <otk> int ('0x0' . 'c')
18:10:07 <dylukes> > let f = (+2) <<< (+3) in f 1
18:10:08 * otk has flashback nightmares
18:10:08 <lambdabot>   6
18:10:09 <elliott> ddarius: I mean, you need a degree in category theory to program in PHP, just like Haskell!
18:10:16 <dylukes> otk: what the everloving fuck is that.
18:10:29 <dylukes> @quote postdoc
18:10:29 <lambdabot> No quotes match. Take a stress pill and think things over.
18:10:33 <elliott> And Haskell doesn't have anything you could call a "module system" either. Wait, that one's true.
18:10:33 <dylukes> :<
18:10:34 <otk> dylukes: it equals 12 :(
18:10:48 <dylukes> The, it only takes a good postdoc to reason about... quote.
18:10:49 <dylukes> :<
18:10:57 * dufflebunk hands otp a ==== for old times sake (or whatever php is up to now)
18:11:02 <ddarius> @quote post.doc
18:11:02 <lambdabot> No quotes match. stty: unknown mode: doofus
18:11:22 <otk> dufflebunk: heh
18:11:35 <otk> odly enough comparison vs assignment operators contribute to a large ammount of bugs
18:11:43 <otk> im hoping haskell of course typefails on that type of thing
18:11:53 <Sgeo> > 'a' == "a"
18:11:54 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
18:11:54 <lambdabot>         against inferred type...
18:11:55 <otk> is it just me or is there a shitload of join/part
18:12:10 <otk> Sgeo: excellent
18:12:12 <Sgeo> > 1 == "1"
18:12:13 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
18:12:14 <lambdabot>    arising from the literal ...
18:12:21 <Sgeo> > 1 == 1.0
18:12:22 <hpc> > 1 == 'a'
18:12:22 <lambdabot>   True
18:12:23 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
18:12:23 <lambdabot>    arising from the literal `1...
18:12:32 <penelope> otk: it helps that there are no assigment operators in haskell...
18:12:53 * Sgeo was just paying attention to the comparison bit
18:13:16 <ddarius> @let x === (cast -> Just y) = x == y; x === y = False
18:13:16 <lambdabot>   ViewPatterns is not enabled
18:13:18 <dylukes> > 1 == 1.0
18:13:18 <lambdabot>   True
18:13:21 <ddarius> Kuso.
18:13:22 <otk> penelope: thats a valid point i guess
18:13:24 <dylukes> that only works because Num a has an Eq a instance
18:13:29 <Sgeo> > let (=:) = writeSTRef in do { var <- newSTRef 0; var =: 5; return var }
18:13:30 <lambdabot>   <<ST action>>
18:13:38 <Sgeo> > let (=:) = writeSTRef in runST $ do { var <- newSTRef 0; var =: 5; return var }
18:13:39 <lambdabot>   Inferred type is less polymorphic than expected
18:13:39 <lambdabot>    Quantified type variable...
18:13:42 <otk> http://www.adacore.com/wp-content/uploads/2008/04/01_safe_secure_ada_2005_safe_syntax_b.pdf raises good arguments though if anyones interested
18:13:44 <Sgeo> Uh
18:13:49 <dylukes> > 1 :: Int == 1.0 :: Fractional a => a
18:13:50 <lambdabot>   <no location info>: parse error on input `1.0'
18:13:52 <ddarius> @let x === y = Just x == cast y
18:13:53 <lambdabot>  Defined.
18:13:55 <ddarius> :t (===)
18:13:56 <lambdabot> forall a a1. (Typeable a1, Typeable a, Eq a) => a -> a1 -> Bool
18:14:05 <otk> :t (=)
18:14:06 <lambdabot> parse error on input `='
18:14:09 <Sgeo> Did I just hit some monomorphism garbage?
18:14:18 <dylukes> > (1 :: Int) == (1.0 :: Fractional a => a)
18:14:19 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
18:14:19 <lambdabot>    arising from an expr...
18:14:36 <ddarius> Sgeo: Don't use ($) with runST.
18:14:45 <Sgeo> ddarius, what?
18:14:57 <dylukes> > let x = 1 :: Int; y = 1.0 :: Float in x == y
18:14:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:14:58 <lambdabot>         against inferred type ...
18:15:07 <otk> hm
18:15:07 <dylukes> otk: Is that enough for you :P?
18:15:25 <otk> if there is no asignment operator, why not use = for comparison ?
18:15:28 <otk> one less character
18:15:36 <ddarius> otk: Because we use = for definition.
18:15:36 <dylukes> Because it's used for binding.
18:15:47 <dylukes> It's not an operator though, it's more of a symbolic keyword.
18:15:49 <otk> yes but only when used with let right?
18:15:49 <Sgeo> > let (=:) :: STRef s a -> a -> ST s (); (=:) = writeSTRef in runST $ do { var <- newSTRef 0; var =: 5; return var }
18:15:50 <lambdabot>   Inferred type is less polymorphic than expected
18:15:50 <lambdabot>    Quantified type variable...
18:15:54 <Sgeo> ...???
18:16:08 <ddarius> Sgeo: You are still using ($) with runST.
18:16:17 <Sgeo> > runST $ do { var <- newSTRef 0; var `writeSTRef` 5; return var }
18:16:18 <lambdabot>   Inferred type is less polymorphic than expected
18:16:18 <lambdabot>    Quantified type variable...
18:16:26 <Sgeo> ddarius, what am I supposed to do?
18:16:28 <elliott> > let (=:) :: STRef s a -> a -> ST s (); (=:) = writeSTRef in runST (do { var <- newSTRef 0; var =: 5; return var })
18:16:29 <lambdabot>   Inferred type is less polymorphic than expected
18:16:30 <lambdabot>    Quantified type variable...
18:16:37 <elliott> Not actually the problem in this case.
18:16:39 <otk> what is $ used for there?
18:16:46 <otk> denoting lazyness like in SML?
18:16:46 <otk> lol
18:16:48 <elliott> > runST (newSTRef 42)
18:16:50 <lambdabot>   Inferred type is less polymorphic than expected
18:16:50 <lambdabot>    Quantified type variable...
18:16:52 <otk> (yes aware haskell is all lazy)
18:16:58 <elliott> otk: f $ x = f x
18:17:02 <elliott> Sgeo: You can't return an STRef outside an ST block.
18:17:02 <Sgeo> otk, function application
18:17:04 <otk> oh nice
18:17:05 <ddarius> The problem is that ST is doing exactly what it is supposed to be doing.
18:17:07 <penelope> $ a short hand for dropping parans
18:17:09 <elliott> Sgeo: The rank-2 type stops you.
18:17:15 <ddarius> penelope: No it is not.
18:17:15 <Sgeo> elliott, oh, derp
18:17:20 <penelope> welll
18:17:28 <Sgeo> > let (=:) = writeSTRef in runST $ do { var <- newSTRef 0; var =: 5; readSTRef var }
18:17:29 <lambdabot>   5
18:17:29 <otk> in haskell do you have a choice to use operators or keywords or do you really only get to use operators
18:17:31 <elliott> (forall s. ST s a) -> a, you're not allowed to constrain (s ~ s part of a which is (STRef s' a))
18:17:35 <Sgeo> Look, assignment!
18:17:44 <elliott> otk: I don't understand the question.
18:17:47 <elliott> All the operators are library-defined.
18:17:55 <Sgeo> <- does not count as an operator.
18:17:59 <otk> hm
18:18:11 <otk> i have to overcome this operator hurdle
18:18:18 <otk> seems haskell is really operator heavy
18:18:29 <otk> more than any language ive seen
18:18:35 <penelope> most are just functions.
18:18:38 <Sgeo> otk, the thing is, operators can be user-defined
18:18:45 <Sgeo> I can make my own operator to do what I wish
18:18:46 <otk> Sgeo: yeah thats fine
18:18:48 * hackagebot bytestring-lexing 0.3.0 - Parse literals efficiently from strict or lazy bytestrings  http://hackage.haskell.org/package/bytestring-lexing-0.3.0 (WrenThornton)
18:19:09 <Sgeo> Which is probably why there are so many operators
18:19:16 <penelope> :t (::)
18:19:16 <otk> like let (.>) x y = x + y or something trivial?
18:19:17 <lambdabot> parse error on input `::'
18:19:28 <Sgeo> otk, sure, that works
18:19:28 <otk> .> 5 6
18:19:41 <Sgeo> It would be used like 5 .> 6
18:19:44 <otk> ah
18:19:46 <otk> hm
18:19:49 <otk> :<
18:19:53 <Sgeo> You could actually define it as x .> y = x + y if you wanted
18:20:01 <eviltwin_b> that, and if everything is a function instead of an operator, you end up with haskelisp or something
18:20:02 <Sgeo> Operators beginning with : are different
18:20:20 <otk> oh
18:20:22 <elliott> Not really.
18:20:25 <otk> you can use (.>) 5 6 though
18:20:28 <penelope> except that lisp has no type language.
18:20:33 <Sgeo> otk, yes
18:20:53 <otk> S-expression is the future man
18:20:54 <eviltwin_b> I meant more that you end up with lots of parentheses
18:21:03 <Sgeo> Liskell exists..
18:21:17 <Sgeo> http://www.liskell.org/
18:21:34 <eviltwin_b> judicious use of operators and fixity declarations makes code cleaner
18:21:49 <penelope> Well, a unification with forth can't be too far off the mark then...
18:21:57 <otk> eviltwin_b: debatable imo
18:22:49 <ddarius> @src otherwise
18:22:50 <lambdabot> otherwise = True
18:23:00 <otk> what if someone does let (<<>) g x f = f (x g) and uses it everywhere
18:23:17 <otk> just because you can define operators doesn't make it intuitive\useful imo
18:23:23 <otters> how are you actually supposed to get the values from the array of flags returned by getOpt
18:23:27 <ddarius> What if someone does add x y = x / y and uses it everywhere?
18:23:48 <otk> well thats true but user defined operators just seem evil to me
18:23:55 <otk> unless its something widely accepted
18:24:06 <thlorenz> I'm trying to understand what this statement does: args@(~( aString : aInteger : [] ) ) <- getArgs
18:24:12 <ddarius> otk: That's why mathematicians (and many others) have been doing it for the past thousand years or so.
18:24:28 <otk> how long do you spend working out what an operator means if its not something you thought of?
18:24:31 <elliott> ddarius: Pfft, I hear they use single-letter variable names.
18:24:33 <thlorenz> could someone point me in the right direction (it's hard to google for @(~)
18:24:33 <elliott> So unprofessional.
18:24:41 <elliott> otk: How long do you spend working out what a function name means if it's not something you thought of?
18:24:48 <Sgeo> What happened to jonesforth?
18:24:51 <penelope> otk: one tries hard to be understood.
18:24:55 <eviltwin_b> thlorenz, it's a pattern
18:24:58 <elliott> otk: Haskell has the advantage that getting documentation for anything quickly is easily, and they have the type signature right there.
18:25:05 <otk> elliott: my hope would be that people name their functions approprietly
18:25:07 <elliott> The signature is a billion times more helpful than any name will be.
18:25:11 <dufflebunk> otk: http://www.haskell.org/hoogle
18:25:19 <elliott> otk: That only works when the concept is sufficiently trivial.
18:25:29 <elliott> functionComposition is a bad name for a function.
18:25:35 <ddarius> otk: Why would they apply this to alphanumeric names but not to operators?
18:25:53 <elliott> Anyway, operators can be named appropriately too.
18:25:53 <otk> let divide x y = x / y vs let (<!>) x y = x / y
18:26:02 <otk> but how do you approprietly name one?
18:26:06 <elliott> E.g. (<*>) vs. (<*) vs. (*>); (>>) vs. (>>=).
18:26:11 <elliott> otk: Visually.
18:26:13 <otk> hmm
18:26:13 <thlorenz> eviltwin_b any hint where I could go read up on patterns or what the terminology is so I can google for it?
18:26:17 <ddarius> otk: You seem to know what (/) does.
18:26:41 <elliott> thlorenz: the @ and ~ parts are separate
18:26:57 <elliott> args@pat just binds the whole thing to args, and also matches it against pat; ~pat is an irrefutable pattern
18:27:00 <elliott> eviltwin_b: how much haskell do you know?
18:27:02 <eviltwin_b> name@thing gives a name to the thing matched by a pattern.  ~ is a lazy (technically, irrefutable) pattern.
18:27:06 <otk> (int -> int -> int) hehe
18:27:07 <ddarius> otk: As alluded to by elliott, there's also that add (add (divide 3 4) 2) 5 is harder to read than 3/4 + 2 + 5.
18:27:08 <elliott> erm
18:27:11 <elliott> thlorenz: ^
18:27:24 <thlorenz> thanks elliot
18:27:27 <otk> ddarius: thats true
18:27:32 <otk> it can go either way i guess
18:27:33 * eviltwin_b is being abused by a bluetooth keyboard with a mind of its own...
18:27:50 <ddarius> otk: Choosing good names is tricky.  User-defined operators are just another tool in the bag.
18:28:02 <otk> that sounds good
18:28:02 <Sgeo> elliott, was jonesforth the thing you pointed me to some time ago?
18:28:12 <otk> i have function naming issues :(
18:28:24 <Sgeo> otk, note that functions can also be used as operators
18:28:27 <elliott> Sgeo: I don't know.
18:28:32 <Sgeo> > 5 `elem` [1, 2, 3, 4, 5]
18:28:33 <lambdabot>   True
18:28:35 <penelope> oh, naming is the most difficult thing.
18:28:37 <otk> hm
18:28:42 <otk> this backtick thing..
18:28:49 <otk> im afraid i dont understand its purpose
18:28:51 <elliott> (a `f` b) === (f a b)
18:28:54 <elliott> > mod 10 8
18:28:55 <lambdabot>   2
18:28:56 <elliott> > 8 `mod` 10
18:28:57 <lambdabot>   8
18:28:59 <otk> ah
18:29:06 <elliott> > 42 `elem` [1,2,3]
18:29:06 <otk> thats a dangerous difference
18:29:07 <lambdabot>   False
18:29:15 <elliott> > "abc" `isPrefixOf` "abcd"
18:29:16 <lambdabot>   True
18:29:56 <ddarius> otk: I recommend naming all your functions: g<GUID> e.g. g65d203a8b8334247b053c62cece84bb8.
18:30:04 <otk> ddarius: hahha
18:30:14 <otk> my problem goes in the opposite direction of that
18:30:30 <otk> i normally do let start = .. let blah = ..
18:30:30 <otk> lol
18:30:44 <otk> when im typing, i cant seem to think of what to call it
18:31:26 <otk> i like to make OOP programmers angry though with short functions
18:31:36 <elliott> Effective Haskell programming often involves thinking of the types before writing the definition.
18:31:42 <otk> let xn x xs x' xs' = ..
18:31:48 <elliott> Which gives a bit of time and insight into thinking of a decent name.
18:31:54 <penelope> If you can't give an abstraction a good name, it generally means you don't quite understand the abstraction
18:32:01 <otk> elliott: thats logical
18:32:02 <penelope> (or it's something new)
18:32:41 <otk> probably
18:32:44 <otk> the former
18:32:55 <ddarius> let unitalMagmaMap = ...
18:33:08 <penelope> also
18:33:20 <penelope> let xn x xs x' xs' = ..
18:34:03 <penelope> probably means you need an abstract type to talk about what's going on. It will help with later refactoring.
18:34:32 <EvanR> is there an instance or type for the opposite of the behavior of Monad Maybe
18:34:36 <otk> ah
18:34:42 <elliott> opposite howso
18:34:48 <elliott> if a Maybe value is Nothing, there's no value to pipe on
18:35:12 <EvanR> i mean to say, Monoid
18:35:39 <elliott> EvanR: erm... what would Just a `mappend` Just b do?
18:35:58 <EvanR> Just a
18:36:07 <otk> in haskell docs, they seem to use let binding syntax but drop the 'let' im guessing this is because it is assumed people will know its a let binding?
18:36:16 <EvanR> Nothing + Just b is Just b
18:36:22 <ddarius> EvanR: The monoid instance for Maybe is Just a `mappend` Just b = Just (a `mappend` b)
18:36:27 <EvanR> right
18:36:36 <elliott> EvanR: you're thinking of MonadPlus
18:36:49 <edwardk> i hate that monoid
18:36:51 <EvanR> the maybe monad stops on the first Nothing, i want to stop on the first not Nothing
18:36:54 <ddarius> EvanR: What you are describing isn't the opposite of that and there is a newtype expressing that instance and its dual.
18:36:56 <ddarius> :t First
18:36:57 <lambdabot> forall a. Maybe a -> First a
18:36:58 <ddarius> :t Last
18:36:59 <lambdabot> forall a. Maybe a -> Last a
18:36:59 <penelope> otk: let in monads /= let in pure
18:37:29 <otk> as an example removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
18:37:35 <ddarius> otk: let is an expression form.  Declarations don't use let.
18:37:46 <otk> is obviously meant to be let + that in the REPL?
18:37:53 <penelope> when you're using ghci, you're in a monad
18:37:56 <EvanR> ddarius: ok
18:37:57 <otk> ah
18:37:59 <penelope> hence the let
18:38:01 <otk> i see
18:38:27 <otk> i very rarely if ever actually compile code outside a REPL, will this cause issues
18:38:43 <EvanR> > First (Just 0) `mappend` First (Just 1)
18:38:44 <lambdabot>   First {getFirst = Just 0}
18:38:50 <ddarius> otk: You won't be able to define data types and defining multi-line functions will be awkward.
18:38:51 <EvanR> > Nothing `mappend` First (Just 1)
18:38:52 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
18:38:52 <lambdabot>         against inferred ...
18:38:57 <EvanR> > First Nothing `mappend` First (Just 1)
18:38:58 <lambdabot>   First {getFirst = Just 1}
18:39:01 <EvanR> \o/
18:39:02 <penelope> use emacs!
18:39:08 <otk> haskell needs ;; then!! :)
18:39:25 <otters> can you really only just use pattern matching to deconstruct types
18:39:28 <EvanR> > do {Nothing; Just 0; ;; Nothing;}
18:39:29 <lambdabot>   Nothing
18:39:31 <ddarius> otk: Recently support was added to allow (almost?) the full language of Haskell to be supported by GHCi.
18:39:37 <ddarius> otk: GHC(i) is not Haskell.
18:39:37 <EvanR> otters: already has ;; :)
18:39:53 <otters> what?
18:39:58 <EvanR> otk:
18:40:00 <otk> think he/she meant me hehe
18:40:02 <otters> oh
18:40:04 <otk> ddarius: ok
18:40:04 <EvanR> stupid shared prefixes
18:40:07 <otters> sor
18:40:16 <ddarius> otters: Everything that "deconstructs" an (algebraic) data type ultimately uses pattern matching.
18:40:22 <___otk> better ? heh
18:40:22 <otters> bah
18:40:29 <___otk> ms cdecl style
18:40:32 <___otk> wow horrible
18:40:35 <___otk> my eyes
18:40:37 <otters> well see I have a list of Flags returned from getOpt
18:40:48 <otters> and I don't want getting the values out of the Flags to be *too* painful
18:40:49 <dylukes> ddarius: It's actually the other way around.
18:40:53 <otters> but I fear it may be
18:40:57 <dylukes> Pattern matching is ultimately case/of
18:41:10 <ddarius> dylukes: case is pattern matching.
18:41:15 <dylukes> Nope, other way around :P.
18:41:32 <dylukes> Once you translate to Core (and eventually STG), all evaluation is done by case/of statements.
18:41:37 <dylukes> case/of expressions*.
18:41:46 <shachaf> dylukes: I don't think Core and STG are part of Haskell.
18:41:47 <otk> EvanR: in the prelude> it seems \r forces the code to get evaluated?
18:41:48 <dylukes> Pattern matching is rewritten as a case expression.
18:41:54 <otters> data Flag = Version | Output String
18:42:03 <ddarius> dylukes: By "pattern matching" I mean the general idea, not multiple clauses of a function declaration.
18:42:03 <otters> you know what, maybe I'll just make a sample file
18:42:07 <otters> and let you all have a swing at it
18:42:08 <dylukes> ddarius: ah okay.
18:42:11 <ddarius> dylukes: The Report calls what case does, pattern matching.
18:42:13 <otk> oh so data is associating a type?
18:42:16 <otk> instead of type
18:42:18 <dylukes> Good point.
18:42:46 <penelope> data makes a new data type
18:43:20 <ddarius> dylukes: I'm also well aware of how function declarations and general pattern matching compiles.
18:43:33 <otk> > data Flag = Version | Output String
18:43:34 <lambdabot>   <no location info>: parse error on input `data'
18:43:40 <dylukes> Yeah, I know. That's why I was a bit confused by your statement at first.
18:43:42 <dylukes> Now I see what you mean.
18:43:54 <otk> > data Switch = | On | Off
18:43:55 <lambdabot>   <no location info>: parse error on input `data'
18:43:57 <otk> :<
18:44:13 <otk> > type Switch = | On | Off
18:44:13 <lambdabot>   <no location info>: parse error on input `type'
18:44:13 <otk> peh
18:44:18 <otk> will need to read that section
18:44:27 <penelope> Flag is your new type, Version and Output String are your contructors.
18:44:29 <eviltwin_b> can't do that in ambdabot
18:44:34 <eviltwin_b> l+
18:44:35 <eviltwin_b> meh
18:44:53 * eviltwin_b got interrupted.  and is now quite discombobulated...
18:45:19 <otk> > `(1,2)`
18:45:20 <lambdabot>   <no location info>: parse error on input ``'
18:45:29 <otk> > (1,2)
18:45:29 <lambdabot>   (1,2)
18:45:50 <otk> > let (x,_) = (1,2)
18:45:51 <lambdabot>   not an expression: `let (x,_) = (1,2)'
18:46:25 <sipa> > let (x,_) = (1,2) in x
18:46:26 <lambdabot>   1
18:46:31 <otk> ah
18:46:54 <ddarius> > let (x,y) = (x,1) in y
18:46:55 <lambdabot>   1
18:47:01 <insertpseudonym> quick question
18:47:12 <otk> let x = ()
18:47:14 <penelope> let y = let (x,_) = (1,2) in x
18:47:15 <otk> > let x = ()
18:47:15 <penelope> y
18:47:16 <lambdabot>   not an expression: `let x = ()'
18:47:23 <otk> > let x = _
18:47:24 <lambdabot>   not an expression: `let x = _'
18:47:33 <otk> > let x _ = 1
18:47:33 <lambdabot>   not an expression: `let x _ = 1'
18:47:34 <insertpseudonym> how do I access custom type fields of a particular constructor without writing a separate function?
18:47:57 <otk> > let x() = 1
18:47:57 <lambdabot>   not an expression: `let x() = 1'
18:47:59 <otk> hm
18:48:14 <otk> btw this bot is awesome :)
18:48:17 <penelope> I think you mean
18:48:45 <sipa> insertpseudonym: use records
18:48:46 <penelope> let x = \y -> 1
18:48:50 <penelope> x
18:48:57 <otk> > let x = \y -> 1
18:48:57 <lambdabot>   not an expression: `let x = \y -> 1'
18:49:04 <otk> hmm
18:49:23 <insertpseudonym> sipa: I'll look them up. I need the equivalent of instanceof plus a way to access the field once the appropriate constructor is recognized.
18:49:28 <penelope> x 5
18:49:29 <otters> https://gist.github.com/1697026
18:49:34 <otters> there's a summary of my problem
18:49:37 <eviltwin_b> otk, let ... in ...
18:49:37 <sipa> otk: the syntax for let is: let { pattern = expr; pattern = expr; ...} in expr
18:49:47 <otk> ah hmm
18:50:05 <otters> oh wait
18:50:09 <otters> that doesn't even work
18:50:10 <otters> hang on
18:50:18 <otk> > :t int
18:50:18 <lambdabot>   <no location info>: parse error on input `:'
18:50:20 <otk> :t int
18:50:21 <lambdabot> Int -> Doc
18:50:24 <eviltwin_b> also, can I recommend using /msg if you're going to be doing a lot of that?
18:50:30 <otk> :t (let x = 1 in x)
18:50:31 <lambdabot> forall t. (Num t) => t
18:50:32 <otters> https://gist.github.com/1697030
18:50:34 <otters> that's the one
18:50:36 <otk> hmmm
18:50:58 <otk> this wont work, but curious
18:51:01 <otk> :t (let x : 'a -> int = 1 in x)
18:51:02 <lambdabot>     lexical error in string/character literal at character ' '
18:51:28 <otk> so how do you make x take 'a or unit
18:51:42 <Sgeo> 'a as in a type variable?
18:51:46 <Sgeo> Just make it be lowecase
18:51:48 <Sgeo> :t id
18:51:49 <lambdabot> forall a. a -> a
18:52:01 <insertpseudonym> sipa: records dont' help me because the types are defined externally
18:52:07 <insertpseudonym> don't*
18:52:08 <Sgeo> (You don't need to write the forall a.)
18:52:21 <otk> hrm
18:52:46 <otk> just confirming, in haskell let x = 1 is immediately bound?
18:52:50 <rwbarton> also "x : 'a -> int" looks like you intended for x to be a function, but "1" doesn't look intended to be a function
18:53:00 <penelope> let f = \a -> (1 :: Int)
18:53:09 <Sgeo> otk, what do you mean by immediately bound?
18:53:13 <penelope> f "b"
18:53:36 <penelope> lambda bot is not quite ghci...
18:53:39 <otk> well, for example if i do let x() = 1 in say fsharp, x isnt bound to 1 until it is passed a unit
18:53:47 <Sgeo> > let a=1; b=a+1 in b
18:53:48 <lambdabot>   2
18:53:53 <rwbarton> Uh
18:53:54 <otk> signature is unit -> int
18:54:08 <Sgeo> We tend not to do functions that only take unit
18:54:09 <rwbarton> Either you are confused, or you are grossly misdescribing what is happening
18:54:21 <otk> probably both heh
18:54:27 <otk> Sgeo: that makes sense i think
18:54:34 <Sgeo> unit is called (), but in general there's no reason to write a function with () -> blah in Haskell
18:54:35 <rwbarton> "let x () = 1" just makes x be the function which on the value () produces the value 1.
18:54:49 <otk> ah yes rwbarton
18:55:03 <otk> as opposed to let x _ = 1 where x takes 'a of anything and produces 1
18:55:04 <ddarius> rwbarton: And on the value undefined produces undefined.
18:55:06 <penelope> Unless you are doing actions/io/etc
18:55:12 <penelope> e.g.
18:55:15 <penelope> Random
18:55:18 <Philippa> otk: modulo resource usage, IO etc, "becoming" isn't a thing in haskell
18:55:25 <ddarius> penelope: You still wouldn't write a function consuming ().
18:55:30 <rwbarton> But yes, you can use this to implement delayed/side-effectful computations in ML languages but it does not play the same role in Haskell
18:55:42 <otk> ok
18:55:47 <Sgeo> Between laziness and first-class IO, there's no reason to make a function whose only purpose is to do something like a computation or IO
18:55:52 <ddarius> In F# let x() = 1 defines a function name x that evaluates to 1 when applied to () (and similarly in Haskell.)
18:56:06 <Philippa> ddarius: I can see someone doing it through worries about CAF leaks or their local equivalents, don't think I'd trust the optimiser myself though
18:56:10 <ddarius> In F# and Haskell, x is immediately bound (to a value that would be written \() -> 1 in Haskell.
18:56:18 <Sgeo> In Haskell let x=some_lengthy_computaton will only do some_lengthy_computation when x is used
18:56:25 <otk> ah
18:56:32 <insertpseudonym> why is there no easy way to check which constructor a particular algebraic data type is implementing!?
18:56:34 <ddarius> Philippa: Yes, there may be implementation reasons to do it, but that is very rare and not very helpful here.
18:56:35 <otk> that is interesting
18:56:52 <insertpseudonym> particular instance*
18:57:02 <otk> im guessing haskell has an equivilant of 'a 'b 'c ect
18:57:04 <alkoma> hi, I am currious why this doesn't terminate: 1 > infinity where infinity = infinity + 1
18:57:14 <Sgeo> a b c etc
18:57:22 <otk> cool
18:57:32 <sipa> alkoma: because Int's (>) is strict
18:57:34 <Sgeo> Assuming that 'a is a thing that represents any type and calls it 'a?
18:57:44 <elliott> insertpseudonym: breaks parametricity
18:57:46 <otk> any type correct
18:57:47 <Sgeo> id is a function that takes anything and just gives it back.
18:57:52 <Sgeo> Its type is a -> a
18:58:00 <Philippa> yeah, haskell's use of Capital Constructors means it doesn't need 's for type variables
18:58:16 <Sgeo> The thing to note here is that a is lowercase
18:58:16 <sipa> alkoma: if you'd use Nat, you can do such things
18:58:16 <otk> let x _ = 1; x "Poop" will return 1
18:58:25 <insertpseudonym> elliott: workarounds?
18:58:28 <alkoma> so it have nothing to do with the evaluation strategy, but just the strictness of the function definition?
18:58:35 <Philippa> otk: in ghci, yes. As an expression, you want let x _ = 1 in x "Poop"
18:58:36 <Sgeo> otk, the type of that is.... better yet, let's say let _ = '1'. The type of that is a -> Char
18:58:41 <Sgeo> erm
18:58:47 <Sgeo> let x _ = '1'
18:58:48 <otk> victory, someone said poop
18:58:53 <dylukes> alkoma: Look at it this way
18:58:55 <dylukes> 1 > infinity
18:59:00 <dylukes> 1 > (infinity + 1)
18:59:03 <otk> Philippa: cool
18:59:08 <sipa> alkoma: values of type Int are still 32-bit numbers, they cannot be compared until their expressions are collapsed into a value
18:59:08 <otk> in x sounds odly familar
18:59:09 <dylukes> 1 > ((infinity + 1) + 1)...
18:59:12 <Sgeo> :t \_ -> '!'
18:59:13 <lambdabot> forall t. t -> Char
18:59:17 <Sgeo> otk, ^^
18:59:23 <dylukes> The right hand side will never collapse
18:59:25 <Sgeo> t -> Char takes any type and returns a Char
18:59:25 <dylukes> As sipa said.
18:59:35 <otk> so \ is the lambda operator?
18:59:42 <Sgeo> Yes
18:59:42 <dylukes> > (\x -> 2 *x) 4
18:59:43 <lambdabot>   8
18:59:44 <dylukes> correct.
18:59:48 <alkoma> by the time it see, 1 > ((infinity +1) +)   -- does it have enough to say "False"
18:59:49 <Sgeo> Though I wouldn't call it an operator
18:59:53 <otk> this is like let x = fun _ -> 1
18:59:57 <Philippa> dylukes: yeah, comparisons against omega actually work if you use Peano naturals or similar, too
19:00:03 <Philippa> alkoma: depends on the numeric type
19:00:04 <dylukes> Right, but this is an integer :P.
19:00:12 <alkoma> oops I mean 1 > ((infinity + 1) + 1)
19:00:13 <Philippa> for Int or Integer, no
19:00:18 <otk> which is equvilant (i think!) to let x _ = 1
19:00:19 <Philippa> it can't compare against the thunks
19:00:27 <dylukes> > (λx → x * x) 2
19:00:27 <lambdabot>   Pattern syntax in expression context:
19:00:31 <cl1> would it be safe to assume that haskell is not well suited to driver development?
19:00:33 <Sgeo> f a b = ... is the same as f a = \b -> ... is the same as f = \a -> \b -> ...
19:00:34 <Philippa> you can make it work if you supply a Num instance for Data Nat = S Nat | Z though
19:00:37 <dylukes> unicode isn't turned on in lambdabot?
19:00:40 <Philippa> (and infinity = S infinity)
19:00:41 <dylukes> > (λ x → x * x) 2
19:00:41 <lambdabot>   Pattern syntax in expression context:
19:00:41 <penelope> so we need to define a class Num a => Num (Alpha a) etc with
19:00:57 <penelope> Aleph
19:01:00 <otk> cl1: i am not knowledgeable about this so take this with a grain of salt, but i saw that you can now use haskell to compile linux LKM
19:01:03 <ddarius> > (x y -> y*y) 2
19:01:04 <lambdabot>   Pattern syntax in expression context: x y -> y * y
19:01:27 <Sgeo> o.O at ViewPatterns being enabled in lambdabot
19:01:29 <Philippa> cl1: it's not as 'transparent' as C is. I gather that people've done it anyway
19:01:29 <dylukes> ddarius: Oh, its interpreting lamda as a variable name :\
19:01:38 <ddarius> dylukes: It is a variable name.
19:01:48 <dylukes> ddarius: I thought it was reserved if you turn on unicode?
19:01:49 <ddarius> Sgeo: They aren't enabled.
19:01:56 <ddarius> dylukes: Why?
19:02:02 <Sgeo> Then why is it claiming it sees pattern syntax?
19:02:09 <dylukes> I guess you're right.
19:02:14 <Sgeo> > (\(id -> a) a) 'c'
19:02:15 <cl1> performance would be my largest concern, as this would be a networking protocol
19:02:15 <lambdabot>   <no location info>: parse error on input `)'
19:02:16 <dylukes> None of the others conflict with anything.
19:02:25 <Sgeo> > (\(id -> a) -> a) 'c'
19:02:25 <elliott> cl1: It has been done.
19:02:26 <cl1> otk, that at least gives hope
19:02:26 <lambdabot>   'c'
19:02:35 <elliott> cl1: http://www.haskell.org/haskellwiki/Kernel_Modules
19:02:35 <Sgeo> ^^view patterns
19:02:36 <zzo38> I noticed something about MonadPlus, which is that the monad laws (together with laws of the type system) seems to imply the left zero law (mzero >> x = mzero). I think I have proven that the monad laws do imply it, but the applicative laws do not imply its version of the left zero law (empty *> x = empty), which I have also proven.
19:02:51 <elliott> cl1: I think you'd be at most limited to teh GHC in that fork of House though, so like 6.8 or 6.10 IIRC.
19:03:03 <cl1> it's going to be a windows driver
19:03:09 <otk> cl1: dont lol
19:03:10 <Philippa> cl1: It can be done. Personally I'd prototype in Haskell then port if I was worried about messing up on correctness, but I'm also not a high performance haskeller
19:03:15 <zzo38> (Yes I do mean just the monad laws by itself; the monoid laws for MonadPlus are not required)
19:03:16 <Philippa> ah, and if it's windows? Don't
19:03:18 <otk> use C :)
19:03:21 <elliott> Oh.
19:03:27 <elliott> Yeah, good luck with that.
19:03:39 <ddarius> Does @run and @let use different flags?
19:03:40 <dylukes> when is this going to be "complete"?
19:03:40 <dylukes> http://www.ats-lang.org/
19:03:42 <Philippa> you'd be the pioneer taking arrows in the back
19:03:42 <EvanR> drivers in haskell!
19:03:45 <otk> you will be in a world of pain developing win drivers with anything other than C / C++ or ASM
19:03:50 <zzo38> Do you think I did it correctly?
19:03:54 <ddarius> @let f (id -> x) = x
19:03:54 <lambdabot>   ViewPatterns is not enabled
19:03:55 <otk> preferably C
19:04:02 <otk> ASM for context switching in kernel land
19:04:04 <cl1> well if haskell wouldn't work i plan on using ada
19:04:07 <ddarius> > let f (id -> x) = x in f
19:04:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:04:09 <lambdabot>    arising from a use of `...
19:04:10 <cl1> ada > c
19:04:11 <otk> cl1: nice
19:04:14 <ddarius> Wonderful.
19:04:17 <otk> well, yes
19:04:25 <otk> but ada is a lot more difficult for driver dev iirc?
19:04:29 <otk> C its all there already
19:04:38 <otk> i mean..
19:04:38 <EvanR> use the right tool for the job >_<
19:04:40 <ddarius> dylukes: Ask the ATS people.
19:04:51 <dylukes> It was a rhetorical question
19:04:52 <cl1> otk it has a specification for interfacing with c built into it
19:04:52 <zzo38> I suggest writing the driver with separate parts for Windows-specific stuff and platform-independent stuff so that it can be ported to other systems if required
19:05:23 <cl1> ada makes interfacing with hardware very easy.
19:05:47 <Philippa> yeah, Ada's on the list of "languages I haven't learned but have more respect for than many would expect"
19:05:47 <ddarius> zzo38: The monad laws can't prove the left zero law because they say absolutely nothing about mzero.
19:05:47 <otk> yes but the issue will be not so much the hardware interfacing but how you are communicating with the driver iirc
19:05:49 <cl1> zzo38, that is a good idea
19:06:17 <insertpseudonym> is there a way to use Eq (if it's derived) for checking types?
19:06:20 <otk> for example if its just a pure hardware driver, i.e. no userland abstraction, ada will probably be very good
19:06:25 <cl1> otk, ada can export methods to c, its all good. anyone using c can use what i write in ada as if it were written in c itself
19:06:27 <otk> im no expert on this though
19:06:42 <otk> cl1: if you are at that level of confidence i say do i :)
19:06:53 <dmwit> Anybody know what version of base ghc-6.12 shipped with (or a way to look it up)?
19:06:57 <otk> do it*
19:06:59 <otk> ok now my kb is playing up
19:07:18 <zzo38> ddarius: Are you sure? I think they do. Note that: (1) mzero is supposed to be defined, like anything that is supposed to be prove.  (2) fmap id = id  (3) (>>= return) = id  (4) x >>= f = join (f <$> x)
19:08:00 <otk> > zip [1..] ["apple", "orange", "cherry", "mango"]
19:08:01 <lambdabot>   [(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
19:08:04 <otk> that is... awesome
19:08:17 <ddarius> zzo38: Notice how those say nothing about mzero.  You have no basis for making any claim about mzero from those except claims that would hold if mzero were anything with the appropriate type.
19:08:24 <Clint> dmwit: http://packages.debian.org/squeeze/amd64/ghc6/filelist
19:08:38 <zzo38> ddarius: I am not finished yet! Please wait
19:08:45 <insertpseudonym> okay, can someone just tell me how an instance of an algebraic data type is stored? if I assign a variable to it, how do I use that variable to get the fields?
19:09:14 <Philippa> zzo38: do you really mean, MonadPlus implied by Monad+the relevant ops forming a monoid?
19:09:52 <zzo38> (5) The type signature for mzero; it is a single value which cannot depend on its type.  (6) Since that means  fmap id mzero = mzero  is implied, then fmap (anything) mzero = mzero  since there cannot be any value to apply  (7) Therefore, the left zero law is proven.
19:10:01 <zzo38> Philippa: No.
19:10:05 <zzo38> ddarius: OK, now I am finished.
19:10:05 <Sgeo> > case (Just 5) of { Nothing -> "Bleh"; Just x -> "Bloo" } -- insertpseudonym, you mean pattern matching?
19:10:06 <lambdabot>   "Bloo"
19:10:16 <Sgeo> Remember that data Maybe a = Nothing | Just a
19:10:25 <dmwit> Clint: Thanks.
19:10:58 <Philippa> zzo38: fmap (const undefined) mzero is what?
19:10:59 <zzo38> ddarius: Now what do you think of this? If there is a mistake please tell me which step is wrong
19:11:12 <ddarius> zzo38: return undefined has the same type as mzero.
19:11:25 <insertpseudonym> Sgeo: that may be what I need
19:11:26 <zzo38> ddarius: Yes, but return undefined is not fully defined!
19:11:28 <insertpseudonym> I'll mull on that a bit
19:11:30 <insertpseudonym> thanks
19:11:36 <zzo38> fmap (const undefined) is also not fully defined.
19:12:00 <Philippa> zzo38: ah. No, "like anything which is supposed to be proven" doesn't hold
19:12:06 <zzo38> (I am assuming that mzero must be fully defined, just like return and fmap are required to be fully defined, and anything at all has to in order to follow most kinds of mathematical laws in haskell.)
19:12:17 <kmc> mm_freak, http://hackage.haskell.org/package/detrospector-0.2 should fix the build error you saw
19:12:31 <Philippa> return = undefined can make part of a valid Monad instance, albeit a rather useless one
19:12:50 <zzo38> Philippa: No, it can't!
19:12:53 <insertpseudonym> Sgeo: is there a way to use that in a list comprehension and to store x as a persistent variable?
19:13:07 <Philippa> sure it can. Map everything to _|_ on the relevant type
19:13:33 <insertpseudonym> Sgeo: actually, I could define a separate function; it just looks messier
19:13:35 <zzo38> However, there is a valid Comonad instance that defines  extract = undefined  as follows:  data Coproxy x; instance Comonad Coproxy where { extract _ = undefined; }
19:13:37 <Sgeo> persistent variable?
19:13:49 * hackagebot combinatorics 0.1.0 - Efficient computation of common combinatoric functions.  http://hackage.haskell.org/package/combinatorics-0.1.0 (WrenThornton)
19:13:51 * hackagebot detrospector 0.2 - Markov chain text generator  http://hackage.haskell.org/package/detrospector-0.2 (KeeganMcAllister)
19:13:53 <zzo38> And as far as I know, that is the only one.
19:13:59 <insertpseudonym> Sgeo: as in, I need to access it's value outside the scope of the case statement
19:14:03 <insertpseudonym> its*
19:14:16 <ddarius> data Void; has a Monad instance that satisfies all the laws (better than most Monad instances.)
19:14:17 <Sgeo> > [x | Just x <- [Nothing, Nothing, Just 5, Nothing, Just 3]]
19:14:18 <lambdabot>   [5,3]
19:14:46 <Sgeo> > case (Just "hehe") of {Nothing -> "Boo!"; Just x -> x}
19:14:47 <lambdabot>   "hehe"
19:14:59 <insertpseudonym> oh that is so cool
19:15:01 <ddarius> @free Maybe a
19:15:01 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:15:01 <insertpseudonym> I had no clue
19:15:08 <ddarius> @free f :: Maybe a
19:15:09 <lambdabot> $map_Maybe g f = f
19:15:16 <Sgeo> > case Nothing of {Nothing -> "Boo!"; Just x -> x}
19:15:16 <lambdabot>   "Boo!"
19:15:26 <Sgeo> ddarius, I'm just using Maybe as a nice example of an algebraic data type
19:15:36 <otk> damn http://langref.org/haskell/unsolved has been spammed :<
19:15:39 <ddarius> Sgeo: I haven't even been reading what you are writing.
19:15:54 <zzo38> ddarius: No it doesn't. Is has no Monad instance at all, defined or not, valid or not.
19:15:54 <zzo38> Due to the kind being wrong.
19:16:06 <ddarius> zzo38: Sorry, data Void a;
19:16:07 <Sgeo> insertpseudonym, of course, if you were using Maybe specifically, there are functions that make it easier.
19:16:10 <otk> is Nothing an option type?
19:16:11 <zzo38> (I first discovered Coproxy comonad not in Haskell, but in a category created from a digraph. It applies to any such categories which have an initial object.)
19:16:31 <Sgeo> otk, you have Some and None in ... I forget which ML
19:16:36 <zzo38> ddarius: Are you sure? That is the same as my Coproxy isn't it? And it is comonad, not a monad, I think.
19:16:39 <insertpseudonym> Sgeo: I'm not in this case, but I'll keep it in mind
19:16:45 <otk> Sgeo: ya, fsharp has it
19:16:53 <otk> type 'a option = None | Some of 'a
19:17:02 <ddarius> zzo38: It's both.  It satisfies all laws trivially.
19:17:04 <Sgeo> otk, Maybe does the same thing
19:17:09 <Sgeo> data Maybe a = Nothing | Just a
19:17:13 <otk> cool
19:17:49 <zzo38> ddarius: No it doesn't because the return cannot be fully defined (although fmap and join can be).
19:18:13 <Philippa> zzo38: you're using "fully defined" without defining it here
19:18:26 <Philippa> (hint: undefined has a set-theoretic denotation)
19:18:36 <ddarius> zzo38: Your extract for your "Coproxy" is no more "fully defined" than return would be.
19:18:48 <otk> Sgeo: i can use that in fsharp too now :)
19:18:54 <otk> type 'a Maybe = Nothing | Just of 'a;;
19:19:01 <otk> > Just 5;;
19:19:01 <otk> val it : int Maybe = Just 5
19:19:01 <lambdabot>   <no location info>: parse error on input `;'
19:19:19 <ddarius> zzo38: Category theory does not require return to be a function, let alone a total function.
19:19:29 <ddarius> undefined is a completely legitimate value in Haskell.
19:19:36 <Sgeo> otk, I assume it would be preferable to use option in F#, because there are functions for using it in F#, and everything that should use it does
19:20:05 <otk> Sgeo: yeah that is true
19:20:05 <zzo38> ddarius: No it is. It should be an empty case block, except that Haskell doesn't support empty case blocks, but undefined is equivalent. And since there is no input value, there is no output value either, so for all input values, there is output, vacuously.
19:20:09 <otk> but when learning a language if i go back and implement it in F# it makes it easier for me to get
19:20:24 <Sgeo> otk, ah, ok
19:20:25 <zzo38> ddarius: I know category theory does not require return to be a function. However, it must be defined (I prefer to assume undefined is not a legitimate value for this purpose).
19:20:27 <Philippa> > let f _ = "hello" in f undefined
19:20:28 <lambdabot>   "hello"
19:20:37 <ddarius> zzo38: Again, undefined is a completely valid value in Haskell.  There are no empty types so there is always a potential input value.
19:20:54 <Philippa> and yes, "you prefer". That doesn't have much to do with haskell aside from the validity of "fast and loose" reasoning
19:21:12 <ddarius> zzo38: Again, undefined is a completely legitimate value.  If you don't like that name, then fix id is a completely legitimate value.
19:21:21 <otk> :t undefined
19:21:22 <lambdabot> forall a. a
19:21:29 <otk> :t Nothing
19:21:29 <lambdabot> forall a. Maybe a
19:21:31 <EvanR> > fix id
19:21:35 <lambdabot>   mueval-core: Time limit exceeded
19:22:15 <Philippa> (6) Since that means  fmap id mzero = mzero  is implied, then fmap (anything) mzero = mzero  since there cannot be any value to apply <- wrong
19:22:21 <Philippa> really, fundamentally wrong
19:22:26 <CodeWeaver> Greetings again.
19:22:44 <otk> > 3.123 == 3.123
19:22:45 <lambdabot>   True
19:22:48 <otk> > 3.123 == 3.1233333
19:22:49 <lambdabot>   False
19:22:53 <zzo38> Well, then it is still undefined for an input undefined. But for a fully defined input, the output is fully defined. That is the object in the category of sets, too. Do you know about the "seq" problem in Haskell?
19:22:55 <Philippa> Haskell != System F
19:23:07 <zzo38> System F?
19:23:18 <otk> Philippa: i hope you mean Haskell /= System F!!!
19:23:27 <Philippa> a lambda calculus with parametric polymorphism, uses lambdas and type application
19:23:33 <otk> so many languages, so many operators
19:23:39 <otk> > 5 <> 4
19:23:39 <lambdabot>   No instance for (GHC.Num.Num Text.PrettyPrint.HughesPJ.Doc)
19:23:40 <lambdabot>    arising from...
19:23:43 <otk> poop
19:23:53 <Philippa> unlike System F, Haskell instantiates automatically. That means that mzero doesn't have just one type - it just has a type that subsumes the others
19:23:55 <otk> > let (<>) x y = x /= y
19:23:55 <lambdabot>   not an expression: `let (<>) x y = x /= y'
19:23:58 <Sgeo> otk, at least you don't have to learn the exact semantics of assignment, which seems to differ between language and language
19:24:12 <otk> ah thats valid
19:24:23 <Twey> > let x <> y = x /= y in 3 <> 4
19:24:23 <zzo38> In category of sets, empty set is an initial object, and a set with a single element is a final object. Therefore it is how it work
19:24:24 <lambdabot>   True
19:24:30 <Twey> > let (<>) x y = x /= y in 3 <> 4
19:24:31 <lambdabot>   True
19:24:39 <Philippa> it's rank-1, and fmap will instantiate it
19:24:39 <otk> Twey: was just about to use in
19:24:39 <otk> heh
19:24:40 <Twey> > let (<>) = (/=) in 3 <> 4
19:24:41 <lambdabot>   True
19:24:51 <Twey> otk: You can bind things using a separate command, @let
19:24:59 <Philippa> (possibly to another type variable, but so what?)
19:24:59 <otk> > ((/=) 3 4)
19:25:00 <lambdabot>   True
19:25:05 <otk> Twey: cool
19:25:06 <Twey> But <> is already bound in λb
19:25:15 <Twey> (it's the document-append operator IIRC)
19:25:18 <otk> > (/= 5 4)
19:25:18 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
19:25:18 <lambdabot>    arising fro...
19:25:26 <otk> > /= 5 4
19:25:27 <lambdabot>   <no location info>: parse error on input `/='
19:25:28 <otk> aww
19:25:33 <zzo38> So if you limit yourself to fully defined values, then, there will be empty type in Haskell, which is an initial object, and the () type which is a final object
19:25:48 <ddarius> You can claim, in the absence of bottom, the free theorem I had lambdabot generate holds.  So that the monad laws + parametricity imply mzero >>= f = join (fmap f mzero) = join mzero
19:25:52 <otk> > map (/=) [5,4]
19:25:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
19:25:53 <lambdabot>    arising fro...
19:25:58 <Philippa> Haskell's denotation isn't in SET
19:26:03 <Philippa> it's in CPO
19:26:20 <zzo38> What does CPO mean?
19:26:44 <Philippa> the category of Complete Partial Orders and continuous functions
19:26:46 <otk> > @let g = \y x -> ((\=) 3)
19:26:46 <lambdabot>   <no location info>: parse error on input `@'
19:26:58 <otk> > @let g = \y -> ((\=) 3)
19:26:58 <lambdabot>   <no location info>: parse error on input `@'
19:27:21 <otk> hmm let x = fun x y -> x <> y
19:27:26 <otk> i guess
19:27:37 <otk> > @let f x y = x \= y
19:27:38 <lambdabot>   <no location info>: parse error on input `@'
19:27:44 <otk> oh
19:27:47 <dolio> There's a paper out there claiming the best semantics are in DCPOs with strict functions. but I'm not sure how that works out.
19:27:47 <otk> > @let f x y = x /= y
19:27:48 <lambdabot>   <no location info>: parse error on input `@'
19:27:50 <otk> thats going to get annoying
19:27:56 <dolio> Or, maybe not a paper. Slides I think.
19:28:05 <otk> > @let f x y = x /= y in 5 4
19:28:06 <lambdabot>   <no location info>: parse error on input `@'
19:28:14 <otk> > x /= y in 5 4
19:28:15 <lambdabot>   <no location info>: parse error on input `in'
19:28:49 * hackagebot multiarg 0.1.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.1.0.0 (OmariNorman)
19:28:51 * hackagebot data-or 1.0.0 - A data type for non-exclusive disjunction.  http://hackage.haskell.org/package/data-or-1.0.0 (WrenThornton)
19:28:59 <ddarius> zzo38: If you can prove that, in the absence of bottom, join mzero = mzero, follows from the monad laws and parametricity, you will have done almost what you claimed.
19:29:00 <otk> > 5 \= 4 || 3 \= 2
19:29:01 <lambdabot>   Not in scope: `\='Not in scope: `\='
19:29:06 <otk> > 5 /= 4 || 3 /= 2
19:29:07 <lambdabot>   True
19:29:08 <otk> god damnit
19:29:24 <otk> > 5 /= 4 && 3 /= 2
19:29:24 <lambdabot>   True
19:29:31 <otk> > 5 /= 4 && 3 /= 3
19:29:32 <lambdabot>   False
19:29:37 <otk> ok
19:29:46 <otk> > int 5.4
19:29:47 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
19:29:47 <lambdabot>    arising from the lit...
19:29:56 <otk> > (int)5.4
19:29:56 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
19:29:57 <lambdabot>    arising from the lit...
19:29:59 <Sgeo> otk, what were you expecting int to do?
19:30:05 <Sgeo> > 5.4 :: Int
19:30:06 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
19:30:06 <lambdabot>    arising from the lit...
19:30:10 <otk> dont hate me... cast :P
19:30:20 <otk> int 5.4 -> int 5
19:30:25 <Sgeo> otk, usually just a function
19:30:36 <Sgeo> How would you cast from a floating point number to an int?
19:30:40 <zzo38> otk: You cannot cast in Haskell!
19:30:41 <Sgeo> Surely you'd use a rounding function
19:30:48 <Sgeo> Similar with any other sort of "casting"
19:30:55 <otk> int would be a function and a type
19:30:58 <alistra> > unsafeCoerce 5.4 :: Int
19:30:58 <lambdabot>   Not in scope: `unsafeCoerce'
19:31:00 <nyingen> > floor 3.5
19:31:01 <lambdabot>   3
19:31:03 <otk> ah
19:31:05 <nyingen> > ceil 3.5
19:31:07 <lambdabot>   Not in scope: `ceil'
19:31:07 <otk> > roof 3.5
19:31:07 <lambdabot>   Not in scope: `roof'
19:31:09 <otk> :<
19:31:09 <nyingen> > ceiling 3.5
19:31:10 <lambdabot>   4
19:31:13 <otk> ah
19:31:19 <otk> > top 3.5
19:31:19 <lambdabot>   Not in scope: `top'
19:31:20 <ddarius> @free join
19:31:21 <lambdabot> Expected variable or '.'
19:31:29 <ddarius> @free join :: Maybe (Maybe a) -> Maybe a
19:31:30 <lambdabot> $map_Maybe f . join = join . $map_Maybe ($map_Maybe f)
19:31:38 <Sgeo> @free f :: m (m a) -> m a
19:31:38 <lambdabot> Extra stuff at end of line
19:31:40 <alistra> Prelude Unsafe.Coerce> unsafeCoerce 5.4 :: Int
19:31:41 <zzo38> ddarius: It is what I tried to make, prove in the absence of bottom, with thise things
19:31:45 <alistra> -1717986918
19:31:47 <alistra> here
19:32:07 <zzo38> alistra: unsafeCoerce is a pointer cast, I think
19:32:19 <alistra> well it made a value of Int type
19:32:22 <Sgeo> otk, note that some functions return Ints. If you want to get other types of numbers out of them, use fromIntegral
19:32:22 <alistra> what do you want more :D
19:32:32 <Sgeo> The result of which will match whatever type you need
19:32:36 <ddarius> zzo38: Yes, but even under the assumptions you make, you still have to assume parametricity (which is beyond the monad laws) and the proof still fails because you only get that mzero >>= f = join mzero not mzero >>= f = mzero.
19:32:46 <Sgeo> > fromIntegral (length []) + 3.5
19:32:47 <zzo38> alistra: No it made it treat the 5.4 as if it is a value of Int type
19:32:47 <lambdabot>   3.5
19:32:48 <otk> ah
19:32:52 <Sgeo> > fromIntegral (length [1,2,3]) + 3.5
19:32:53 <lambdabot>   6.5
19:32:55 <otk> now, what about this ;) "123" |> Seq.map (int << char) |> Seq.fold (+) 0;;
19:32:57 <Sgeo> > (length [1,2,3]) + 3.5
19:32:58 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
19:32:58 <lambdabot>    arising from the lit...
19:33:27 <zzo38> (which it isn't; that is why you get strange numbers like that)
19:33:29 <ddarius> @free join :: M (M a) -> M a
19:33:30 <lambdabot> $map_M f . join = join . $map_M ($map_M f)
19:33:47 <ddarius> Sgeo: I was essentially using Maybe as a Skolem variable.
19:33:58 <Sgeo> ...Skolem?
19:34:05 <ddarius> @google skolemization
19:34:06 <lambdabot> http://en.wikipedia.org/wiki/Skolem_normal_form
19:34:07 <lambdabot> Title: Skolem normal form - Wikipedia, the free encyclopedia
19:34:17 * ddarius <3 Skolemization.
19:34:19 <otk> int '1' = 49 and yes ive used this filthy alg IRL
19:34:41 <otk> when i say irl i mean, programming challenges heh
19:34:46 <zzo38> What does parametricity mean?
19:35:08 <Enigmagic> > foldl (+) 0 $ fmap ord "123"
19:35:10 <lambdabot>   150
19:35:20 <otk> Enigmagic: nice
19:35:25 <otk> ord hm
19:35:29 <otk> :t (ord)
19:35:30 <lambdabot> Char -> Int
19:35:32 <otk> ah
19:35:53 <ddarius> zzo38: You know how you know reverse :: [a] -> [a] can't fiddle with the contents of the list, just rearrange, duplicate, or drop items, but not, say, add 2 to them.  Parametricity is the thing that lets you show that.
19:36:42 <elliott> :t ord
19:36:43 <lambdabot> Char -> Int
19:36:44 <elliott> No parens required.
19:37:03 <zzo38> ddarius: O, that is what it means. OK.
19:37:36 <otk> ah
19:37:38 <otk> cool
19:38:27 <otk> f# doesnt have ord hmm
19:38:29 <otk> php has it though
19:38:36 <napping> http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html
19:38:39 <otk> my F# has it now :) let ord : char -> int = int << char;;
19:38:42 <otk> (char -> int)
19:38:47 <napping> "Theorems for Free!" is the introduction
19:39:22 <zzo38> ddarius: I am sorry I prove it wrong.
19:40:28 <napping> voigtlander has a calculator here: http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
19:40:47 <zzo38> Why is there more than one file and why are they in different formats?
19:40:58 <zzo38> Such as, one is PDF, one is TXT, one is DVI?
19:41:12 <mzero> choice!
19:41:31 <otk> suppose let ord (x : char) = int x would suffice though
19:41:43 <otk> prefer composition with >> though
19:41:51 <otk> :t (>)
19:41:52 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:41:55 <otk> :t (>>)
19:41:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:42:00 <dmwit> zzo38: What exactly did you prove wrong?
19:42:18 <zzo38> (My own preference is TXT or DVI; DVI is far superior to PostScript and PDF in my opinion. Except for scanned documents, in which case DjVu is superior instead.)
19:42:27 <zzo38> dmwit: I did it wrong
19:42:37 <zzo38> I didn't prove it to be wrong.
19:42:44 <otk> > Int >> Int
19:42:45 <lambdabot>   Not in scope: data constructor `Int'Not in scope: data constructor `Int'
19:43:01 <dmwit> > Just 3 >> Just 7 :: Maybe Int -- otk?
19:43:01 <lambdabot>   Just 7
19:43:16 <otk> ah cool
19:43:17 <zzo38> Why is the first two documents in PDF format, the third in TXT, and the fourth in DVI and PS?
19:43:31 <otk> > Ord
19:43:32 <lambdabot>   Not in scope: data constructor `Ord'
19:43:35 <otk> > :t Ord
19:43:36 <lambdabot>   <no location info>: parse error on input `:'
19:43:48 <otk> :t Ord
19:43:48 <lambdabot> Not in scope: data constructor `Ord'
19:43:49 * hackagebot pointless-fun 1.1.0 - Some common point-free combinators.  http://hackage.haskell.org/package/pointless-fun-1.1.0 (WrenThornton)
19:43:55 <otk> :t ord
19:43:56 <lambdabot> Char -> Int
19:43:57 <otk> hm
19:44:09 <luite> DjVu is not really superior to PDF, although the latter is a bit more verbose in its markup and metadata so files don't get quite as small
19:44:11 <otk> :t (>)
19:44:12 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:44:13 <dmwit> otk: Ord :: * -> Constraint
19:44:17 <ddarius> zzo38: I'm sure you can imagine up some rationale for why such a thing would occur, alternatively email Phil Wadler.
19:44:24 <dmwit> otk: But only in very new versions of GHC. =)
19:44:28 <otk> ah
19:44:46 <otk> :t show
19:44:46 <lambdabot> forall a. (Show a) => a -> String
19:44:49 <zzo38> In addition, I cannot understand what to do; none of the documents titles seem to mention parametricity even though the main heading does.
19:44:54 <otk> > show 5
19:44:55 <lambdabot>   "5"
19:45:05 <otk> interesting choice for a function that is 'a -> string
19:45:10 <otk> choice of name*
19:45:35 <otk> > show show
19:45:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Base.String)
19:45:36 <lambdabot>    arising f...
19:45:56 <otk> > @let x = 1
19:45:56 <lambdabot>   <no location info>: parse error on input `@'
19:46:01 <otk> @let x = 1
19:46:01 <lambdabot>  Defined.
19:46:06 <otk> > show x
19:46:07 <lambdabot>   Ambiguous occurrence `x'
19:46:07 <lambdabot>  It could refer to either `L.x', defined at <local...
19:46:21 <nyingen> otk: the bot has some limitations
19:46:37 <otk> > show L.x
19:46:37 <nyingen> if you try this in ghci, you'll get more normal results in some cases
19:46:38 <lambdabot>   "1"
19:46:49 <otk> nyingen: yes but im only spamming myself in ghci
19:46:53 <nyingen> :)
19:47:14 <otk> now... does haskell have quotations
19:47:14 <shachaf> otk: That's another advantage of using ghci.
19:47:25 <otk> heh
19:47:47 <nyingen> @quote
19:47:47 <lambdabot> gmh33 says: Haskell makes so much more sense now and all I did was figure out the typing thing
19:48:07 <otk> ah hehe not that type of quotation
19:48:22 <otk> hm how to explain this
19:48:23 <Philippa> the sort Template Haskell (nearly) does?
19:48:31 <otk> returning an AST for your expression
19:48:51 <Philippa> yeah, you want Template Haskell
19:49:04 <otk> okay cool
19:49:23 <otk> another bookmark to read
19:50:10 <zzo38> luite: I am saying that DjVu is superior to PDF for *scanned documents only*. For documents generated by computer, DVI is superior.
19:50:43 <otk> binary document formats are the devil
19:50:43 <ddarius> zzo38: You actually can show that join mzero = mzero from the monad laws and the free theorem.
19:52:14 <otk> @import Network.Curl.Download
19:52:14 <lambdabot> Unknown command, try @list
19:52:42 <zzo38> ddarius: Yes, that is what I thought. So if you think my proof is wrong (following parametricity and no bottoms), then please tell me the mistake better.
19:52:50 <ddarius> @free mzero :: M a
19:52:50 <lambdabot> $map_M f mzero = mzero
19:53:04 <otk> :t free
19:53:05 <lambdabot> Not in scope: `free'
19:53:14 * mzero sometimes finds that his clever nick is a bother... :-)
19:53:37 <ddarius> zzo38: Your "proof" is 1) not really presented and/or full of hand-waving, and 2) incomplete.
19:53:37 <zzo38> otk: "free" is a lambdabot command, not a Haskell value.
19:53:37 <otk> zzo38: thank god for that
19:53:37 <otk> haha
19:53:44 <otk> hopefully no alloc too
19:54:02 <ddarius> zzo38: Be more explicit and step-by-step and show the chain of equalities (with justifications) between mzero >>= f and mzero and you will be set.
19:54:12 <Philippa> otk: we have alloca!
19:54:16 <elliott> otk: We have malloc/free.
19:54:20 <zzo38> ddarius: O, that is what it wrong with it. Yes, it is too informal, I guess.
19:54:21 <ddarius> @hoogle free
19:54:22 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
19:54:22 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
19:54:22 <lambdabot> Foreign.Marshal.Pool freePool :: Pool -> IO ()
19:54:25 <otk> :<
19:54:27 <otk> ah
19:54:30 <otk> Marshalling
19:54:36 <otk> ye crusty devil
19:54:56 <luite> zzo38: no I meant for scanned documents. pdf can do the same low res + high res masking that djvu uses to store pages (with either jpeg2000 pages or with separate jbig2 masks, the first is better but the second more compatible with older (and apple) viewers)
19:54:59 <otk> > printf "test\n"
19:54:59 <lambdabot>   Ambiguous type variable `r' in the constraints:
19:55:00 <lambdabot>    `Text.Printf.PrintfType ...
19:55:43 <zzo38> But even if we agree it is not a proper proof, can you now think that the thing I attempted to prove is correct (making the assumptions I mentioned)? Is it?
19:56:34 <Enigmagic> > printf "test: %d %f" (0 :: Int) (1 :: Double)
19:56:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:56:35 <lambdabot>    `GHC.Show.Show a'
19:56:35 <lambdabot>      a...
19:56:39 <ddarius> zzo38: Under the assumptions of no bottom and parametricity holding (which are essentially the same thing here), then I can easily prove your statement.
19:56:41 <zzo38> luite: In my opinion, PDF is full of stupid stuff. (Your opinion might vary)
19:56:57 <Enigmagic> > printf "test: %d %f" (0 :: Int) (1 :: Double) :: String
19:56:58 <lambdabot>   "test: 0 1.0"
19:56:59 <zzo38> ddarius: O, OK.
19:57:10 <Enigmagic> otk: printf is overly clever
19:57:15 <otk> > printf "test: %s" "test"
19:57:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:57:15 <lambdabot>    `GHC.Show.Show a'
19:57:15 <lambdabot>      a...
19:57:17 <otk> :<
19:57:37 <otk> > putStrLn $ "test"
19:57:38 <lambdabot>   <IO ()>
19:57:41 <otk> ok
19:57:46 <zzo38> Enigmagic: I know how it works; I looked at the source codes and I agree with you
19:58:44 * ddarius finds how printf works clever but not overly clever.
19:58:55 <otk> > printf "test"
19:58:55 <lambdabot>   Ambiguous type variable `r' in the constraints:
19:58:56 <lambdabot>    `Text.Printf.PrintfType ...
19:59:02 <otk> strange because that printf works in my ghci
19:59:08 <zzo38> Since any applicative functor can be made backward, I can use an example to prove that the left zero law is *not* implied by the applicative laws.
19:59:23 <zzo38> (I think.)
19:59:37 <otk> @hoogle dieIf
19:59:37 <lambdabot> No results found
19:59:41 <otk> hoogle is fast
20:00:11 <zzo38> So, there can be instance of Alternative where (empty *> x = empty) does not hold, although it will hold for any monad that also has Alternative (and assuming parametricity).
20:01:33 <otk> > printf "test: %s" ("test" :: String) :: String
20:01:33 <lambdabot>   "test: test"
20:01:34 <ddarius> (*>) isn't (>>=) and that law does not hold for all monads.
20:01:40 <otk> > printf "test: %s" ("" :: String) :: String
20:01:41 <lambdabot>   "test: "
20:01:50 <otk> > printf "test: %s\r\nQUIT\r\n" ("" :: String) :: String
20:01:51 <lambdabot>   "test: \r\nQUIT\r\n"
20:01:53 <otk> aww hehe
20:02:23 <ddarius> For the reason you state.  Every monad gives rise to two, usually distinct, Applicative instances.
20:03:34 <sipa> ddarius: hmm, how so?
20:03:36 <zzo38> ddarius: Yes it does; I am using the one where  (<*>) = ap  which is what the Applicative instance should always be for any Monad anyways
20:03:47 <elliott> sipa: running function before argument and vice-versa
20:04:04 <zzo38> In that case, you will have (*>) = (>>)
20:04:07 <ddarius> zzo38: It should be because that's what people expect, but there is no formal requirement for it to be.
20:04:36 <edwardk> anyone who makes an applicative that doesn't agree with teir monad should be taken out back and shot
20:04:37 <ddarius> There's even a recent article that goes into some of the benefits of the alternate definition.
20:04:43 <zzo38> ddarius: O, well, then I skipped another assumption again too much
20:04:44 <edwardk> i can write that up formally if you prefer ;)
20:05:18 <zzo38> ddarius: I did make up a module (not published yet) which defines a wrapper BackwardAp to make any applicative to go backward
20:05:46 <edwardk> in scalaz there was a big flame war about this because there is an applicative 'validation' for which there isn't a compatible monad, but a lot of people wanted the broken either-like one to be shoe-horned on top anyways
20:05:50 <ddarius> zzo38: As I'm pretty sure was also done in the paper that introduced the Applicative class.
20:06:19 <ddarius> Scala: Embittering edwardk since 2010.
20:06:28 <zzo38> ddarius: I didn't see that, but you are probably correct.
20:06:31 <edwardk> meh before that it was c#
20:06:45 <edwardk> i'm a thoroughly embittered man
20:06:54 <Philippa_> edwardk: do they just not have newtypes, or what?
20:07:04 <ddarius> edwardk: C# actually gives me a modicum of hope.
20:07:08 <Philippa_> I mean, I know I'm lazy, but even I'm not normally /that/ lazy
20:07:12 <edwardk> we ultimately settled on making it easy to get in and out of Either with it
20:07:14 <edwardk> where you can use the monad
20:07:20 <edwardk> and no they don't have newtypes
20:07:22 <Philippa_> (just don't ask me how many WIP blog posts I have open right now)
20:07:37 <Philippa_> ah, I guess that'd explain it
20:07:39 <edwardk> when you make State you are paying a cost
20:07:42 <edwardk> etc
20:08:12 <edwardk> actually it can be a rather disturbingly high cost, given that functional techniques in scala often come with an order of magnitude performance penalty attached
20:08:46 <Philippa_> *wince*. I think you just put me in the Clojure-if-I'm-on-JVM camp
20:08:49 * hackagebot ad 1.3 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.3 (EdwardKmett)
20:08:57 <edwardk> Philippa_: i like types =P
20:09:07 <edwardk> scala is still better than clojure
20:09:26 <edwardk> you can at least program with monads, etc.
20:09:27 <napping> I'm not sure I trust implicits and subtyping
20:09:42 <edwardk> napping: i don't use many implicits, even for monads
20:09:57 <ddarius> edwardk: Are we about to be deluged with module updates, or was that a substantial update?
20:10:07 <edwardk> i found a nice way to abuse subtyping to get 90% of the monad sugar with just that
20:10:10 <napping> It seems hopeless to try to enforce things with types if you can add subclasses
20:10:15 <dolio> The applicative discussion reminds me of another Scala gem.
20:10:28 <edwardk> ddarius: hahah i love how one trickles in and everyone gets scared that i'll start a flood
20:10:33 <lispy> Idle subtypings are the devil's tools
20:10:43 <dolio> Where operators ending with a colon have flipped arguments.
20:10:46 * ddarius "loves" how he is everyone.
20:10:56 <dolio> So 'x :: xs' is the same as 'xs.::(x)'.
20:11:15 <edwardk> that was me making it work with th 2.6, mkTyCon3, and the loss of Eq and Show as superclasses of Num
20:11:15 <edwardk> it was provoked by someone opening an issue on it about one of the corner cases that needs L'Hopital's rule and therefore can't be fixed
20:11:16 <dolio> However, that's not exactly true.
20:11:37 <edwardk> ddarius: you're everyone that matters ;)
20:11:48 <lispy> edwardk: credit where credit is due, Bernouli's ruel
20:11:50 <lispy> rule*
20:12:00 <dolio> Because one day we had a situation where 'xs.::(x)' worked, and 'x :: xs' didn't, and that's because the real translation is 'val free = x ; xs.::(free)'.
20:12:12 <edwardk> dolio: btw- the parser was slow because tail on strings copies the whole thing
20:12:23 <dolio> Making it impossible to delay the evaluation of x.
20:12:31 <dolio> Even if the operator is non-strict.
20:12:33 <edwardk> oh yeah forgot that one
20:13:06 <ddarius> lispy: If something is named after you in mathematics, that's almost always an indication that you are not the original inventor, though there are some notable exceptions.
20:13:19 <edwardk> i need to package up the new monadic plumbing in something other than just the reporting code
20:14:12 <ddarius> dolio: Ah, that translation makes sense.
20:14:14 <edwardk> there is a nice blurb in the intro to combinatorial species book, which talks about how the attribution process is used to kind of sweep under the rug the grueling process of discovery
20:14:36 <ddarius> Well, it -should- respect the strictness of the operator, but I understand the forces that led to that translation.
20:15:01 <edwardk> it infects type checking of that as well
20:15:09 <ddarius> edwardk: I'd imagine.
20:15:11 <edwardk> in ways that boggle the mind sometimes ;)
20:15:31 <lispy> ddarius: in this case, L'Hopital paid a Bernoulli debt to take 'ownership'
20:15:47 <ddarius> That was actually the first thing I thought was wrong with it until dolio elaborated.
20:15:53 <ddarius> lispy: Then L'Hopital is a sucker.
20:16:33 * lispy is playing around and updating the GHC RTS to C99...I wonder if the ghc devs would be interested.
20:17:00 <edwardk> lispy: how invasive was it?
20:17:05 <ddarius> lispy: Do you mean GCC and C99, or is the RTS actually close to superficially portable C?
20:17:36 <lispy> edwardk: emphasis on playing around, just making a few changes at the moment (const and restrict)
20:17:43 <edwardk> ah
20:18:03 <lispy> ddarius: from commens on the wiki I think it's not close.  There is mention of it using some old C
20:18:59 <dolio> Does it use K&R style function declarations?
20:19:00 <dolio> I hope so.
20:19:07 <lispy> I'm actually reading it trying to learn where the threading for the ghci debugger lives.  I'm probably in the wrong subdir :)
20:19:18 <ddarius> My question is more "Does it depend on GCC extensions?"
20:20:03 <lispy> ddarius: according to the wiki it has been ported to microsoft's compiler in the past and shouldn't be that hard to do again
20:20:13 <ddarius> lispy: Okay.
20:20:15 <lispy> ddarius: I really haven't read enough to know if that's true
20:20:24 <ddarius> edwardk: What happens if you use AD on something that depends on L'Hopital's rule?
20:20:34 <Enigmagic> lispy: msvc x86_64 compiler doesn't support inline assembly
20:20:36 <edwardk> NaN mostly
20:21:01 <Enigmagic> lispy: so it'd be more work than it was back in the 32-bit days i reckon
20:21:02 <lispy> Enigmagic: good to know.  I've seen that in at least one place.
20:21:07 <parcs`> how does ghci manage to capture SIGINT even when it's evaluating a non-allocating loop?
20:21:11 <Enigmagic> yeah, like StgCRun.c
20:21:24 <parcs`> capture and respond to*
20:21:38 <ddarius> parcs`: Presumably by registering a handler for that signal.
20:21:39 <lispy> Enigmagic: how does the linux kernel factor out asm?  Into separate files?
20:21:51 <lispy> Enigmagic: or does it just rely on gcc?
20:22:04 <Enigmagic> lispy: gcc and msvc (32-bit only) support inline assembly
20:22:18 <Enigmagic> 64-bit msvc has to be in a separate file
20:22:18 <lispy> aaah
20:23:51 * ddarius needs to buy more hoisin sauce.
20:24:45 <lispy> If you use the restrict keyword in C99 but aliasing is happening, does that mean you get undefined code?
20:24:58 <lispy> I'm assuming that the compiler can't complain and just trusts you
20:25:20 <russellw> lispy, yes
20:25:26 <ddarius> Yay C.
20:25:51 <lispy> sounds like adding restrict should be a separate refactoring pass
20:25:56 <edwardk> lispy: restrict is you telling the compiler to trust you
20:26:06 <zzo38> That is both the advantage and the disadvantage of C, at the same time.
20:26:07 <edwardk> if you get it wrong shame on you
20:26:15 <Enigmagic> lispy: yeah just think about the difference between memmove and memcpy
20:26:19 <ddarius> Humans: The Most Trustworthy Apes
20:26:21 <edwardk> they wanted it so they could compete with the fortran guys on alias analysis
20:27:01 <ddarius> edwardk: I've been looking at SPIN relatively recently.  What should I model check?
20:27:13 <zzo38> But I still think LLVM is better designed than C. The only thing is, they have no macros, but you could write a preprocessor
20:27:27 <ddarius> hah
20:27:44 <ddarius> I think most people call LLVM preprocessors "compilers."
20:27:50 <Enigmagic> LLVM isn't designed to be programmed directly
20:28:20 <russellw> zzo38, that's a particularly strange thing to say considering the semantics of LLVM are essentially those of C
20:29:03 <zzo38> Enigmagic: I think it would actually be as good as C to program in directly, if you have macros. (BLISS has more powerful macros than C; you could have something like BLISS macros in LLVM, it might improve)
20:29:38 <zzo38> And possibly, a literate programming environment to go with LLVM which would include the macro capabilities themself
20:30:00 <Enigmagic> zzo38: latner designed it to be easy to parse so there is a lot of redundancy (calling conventions, types, etc) that would be a pain to code manually
20:30:35 <Enigmagic> i've done it before but i try to avoid it :P
20:31:22 <zzo38> I know there is a lot of redundancy.
20:31:46 <Enigmagic> alright
20:32:11 <zzo38> I do like specifying the types everywhere. For function calls, I would just make a macro that includes the calling conventions and so on.
20:34:50 <Enigmagic> go for it. i personally don't like it but to each their own.
20:41:52 <tomprince> Just design a dialect that does type-inference.
20:41:58 <tomprince> Shouldn't be too hard. :)
20:43:33 <edwardk> ddarius: brainfart, SPIN?
20:47:20 <nyingen> @quote
20:47:20 <lambdabot> Qunatumplation says: "fucking around with math"
20:47:22 <nyingen> @quote
20:47:23 <lambdabot> megeria says: i am so new to haskell that i still have the new car smell
20:50:37 <ddarius> http://www.spinroot.com
20:50:54 * yottabit decides to smell megeria if he ever meets (him|her)
20:52:23 * ddarius decides to avoid yottabit.
20:52:55 <yottabit> just don't wear a scratch-and-sniff shirt and you'll be fine
20:53:06 * ddarius decides to avoid yottabit, anyway.
20:53:31 <nyingen> @quote
20:53:31 <lambdabot> NihilistDandy says: The best part of Haskell is that 80% of module names can be turned into clever blog titles.
20:53:32 <yottabit> even if i want to discuss stuff on this page: http://en.wikipedia.org/wiki/Linear_temporal_logic
20:54:19 <edwardk> yottabit: it may have worn off a bit by now
20:54:51 <yottabit> probably
20:55:12 <stanrifkin> hello, i am new to haskell - my question is if there is a builtin help like in python or in perl with perldoc
20:55:31 <yottabit> stanrifkin: i'm assuming you are using ghci
20:55:41 <yottabit> type in :? the session
20:55:54 <stanrifkin> yottabit: yes - haskell platform
20:56:00 <yottabit> great
20:56:12 <Philippa_> there's some documentation that ships with the Platform as well, though it's got holes in the library docs on Windows
20:56:17 <stanrifkin> yottabit: i already do, but there is only some kind to load or debug options here
20:56:28 <Philippa_> (but googling "Haskell Platform documentation" should help)
20:57:20 <stanrifkin> ok, i see - so only the online documentation (html)
20:57:32 <ddarius> Haskell has no docstrings.
20:57:44 <sipa> stanrifkin: sometimes knowing the type of a function tells you a lot
20:57:49 <sipa> :t maximum
20:57:50 <lambdabot> forall a. (Ord a) => [a] -> a
20:59:43 <stanrifkin> sipa: ok better as nothing
21:02:26 <ddarius> One could sort of fake docstrings with a little bit of TH and a type class.
21:02:56 * yottabit sniffs around for misleading information
21:03:28 * yottabit just wanted to use 'sniff' in a sentence next to ddarius
21:03:58 <ddarius> My dish towel smells like bleach.
21:04:57 <Philippa_> yottabit: does this smell like chloroform?
21:06:28 <mzero> stanrifkin: which OS are you on?
21:07:18 <stanrifkin> mzero: windows, linux ... why?
21:07:51 <stanrifkin> mzero: i installed haskell platform on my windows laptop
21:07:56 <mzero> 'cause if it were on Mac, I'd help find where all the doc is loaded already on your machine
21:08:05 <mzero> I don't know where it ends up on Windows or Linux
21:08:59 <stanrifkin> mzero: tell me... maybe i find it here
21:09:57 <mzero> it's in /Library/Haskell/doc/start.html
21:09:58 <yottabit> /usr/share/doc on debian based systems
21:10:03 <yottabit> if you installed it using apt
21:11:00 <mzero> and once you start installing packages with cabal, you get rebuilt library docs in:   ~/Library/Haskell/doc/frames.html
21:11:54 <yottabit> on my sys, debian based, ~/.cabal/share/doc/
21:14:18 <ddarius> So now stanrifkin knows exactly where the documents are on every platform except his.
21:14:27 <stanrifkin> hehe
21:14:40 <stanrifkin> i'm installing it right now
21:15:40 <stanrifkin> i've got a redhat based system - should be in /usr/share/doc too
21:16:13 <stanrifkin> in windows you get it easy via startmenu
21:16:39 <stanrifkin> but i asked for a cmdline shortcut like help() in python or so
21:16:52 <stanrifkin> ok there is no one so i stick with the html pages
21:21:39 <elliott> Red Hat? I guess it'll be GHC 5 then.
21:21:41 <elliott> (Okay, you said -based.)
21:22:40 <stanrifkin> elliott: ghc 6
21:23:02 <stanrifkin> elliott: fedora 14
21:23:18 <elliott> stanrifkin: I thought Fedora was meant to be bleeding-edge.
21:25:12 <stanrifkin> elliott: old distro, everything works fine no need to upgrade and no nerves :)
21:26:34 <stanrifkin> elliott: do i need version 7?
21:27:36 <stanrifkin> elliott: i am totally new to haskell - i liked the book "higher order perl" so i got to haskell
21:27:55 <elliott> Well, 7 was a quite major release. But you'll probably be fine.
21:28:15 <elliott> You'll have trouble getting quite a lot of Hackage libraries to work I would think though.
21:28:34 <elliott> There are convenient autoconf'd binary packages for 7 if you want to go that route at a later date.
21:28:37 <ddarius> elliott: They should work fine.
21:28:58 <elliott> ddarius: I'm not so optimistic, but I haven't used 6 for years so maybe I'm wrong.
21:29:11 <ddarius> 7 hasn't even been out for years.
21:30:30 <elliott> How many people actually test on 6, though?
21:30:50 <ddarius> elliott: Probably most people.
21:31:05 * elliott is again sceptical.
21:31:09 <ddarius> At any rate, what will happen is the base constraint will lead to older versions of the libraries being installed.
21:32:37 <koninkje> elliott: I still use 6.12
21:32:59 <koninkje> And test on it (obviously)
21:33:27 <koninkje> Anyone else on OSX 10.5 will be the same since GHC 7 requires a version of XTools that doesn't work here
21:33:43 <elliott> koninkje: Well, my condolences :)
21:33:48 <koninkje> heh :)
21:33:57 <elliott> > id runST (return ())
21:33:58 <lambdabot>   Couldn't match expected type `m ()'
21:33:58 <lambdabot>         against inferred type `forall s...
21:34:01 <elliott> > (id runST) (return ())
21:34:02 <lambdabot>   ()
21:34:06 <elliott> Your version is more Lispy than GHC 7.
21:34:29 <koninkje> yeah, and you can't use ($) at # kinds either
21:34:58 <koninkje> neither has been that much of a problem for me
21:35:14 <elliott> I don't think you can do that in GHC 7.4 either.
21:35:16 <koninkje> especially since the typing behavior of ($) keeps changing all the time
21:35:17 <elliott> At least something like that broke.
21:35:59 <koninkje> Well the folks I was golfing bytestring-lexing with would use things like:
21:36:11 <koninkje> word2Int# $ indexWord8OffAddr# addr (ord# i)
21:36:34 <koninkje> So I presume it works on some 7.x version...
21:37:17 <koninkje> but the typing of ($) and similar things has always been a sticking point for inference algorithms
21:37:21 * ddarius for some reason read "scallion" and thought "scallops."
21:37:32 <ddarius> koninkje: No it has'n.t
21:39:52 <koninkje> ddarius: sure it has. The HMF paper talks about it and other examples, comparing how they do or don't get typed under HMF, MLF, and boxy types (it was written before outside-in, IIRC)
21:40:32 <koninkje> Just because (f e) typechecks doesn't mean (f $ e) typechecks. It all depends on the inference algorithm being used
21:40:48 <ddarius> koninkje: I agree but that isn't a fact about the typing of ($).
21:41:06 <koninkje> How not?
21:41:15 <Philippa_> koninkje: you know "typing" means something specific, right?
21:41:27 <koninkje> It's not the typing of the definition of ($), sure. But it's the typing of its use
21:41:33 <koninkje> Philippa_: yes.
21:42:02 <ddarius> There are plenty of examples in even Haskell 98's type system where the inlining of a term type checks while the uninlined version does not (or does with a different type.)
21:42:45 <ddarius> I think all of the systems you enumerated give ($) the same type.
21:43:04 <ddarius> What changes is how the type system overall works.
21:43:14 <koninkje> I'm talking about the use of ($), not the typing of its definition
21:43:55 <koninkje> The example cited above was how (id f e) doesn't work in GHC 6.12 whereas ((id f) e) does.
21:44:04 <koninkje> ...for a particular f and e
21:44:51 <ddarius> The differences in GHC for thing like that have to do with crazy hacks GHC has occasionally done and little to do with the theoretical framework GHC's type system was supposed to fit in.
21:44:55 <koninkje> That has nothing to do with typing the definition of id. But it has everything to do with how it's able to be used in programs
21:45:27 <russellw> ddarius, that is counterintuitive, I would have expected inlining to make no difference whether a term type checks - any chance you could point me to some examples?
21:45:43 <ddarius> russellw: twice f = f . f
21:46:15 <ddarius> russellw: If something type checks, then it's inlining should always type check, but the other direction is not given.
21:46:19 <koninkje> russellw: it's not for H98 specifically, but the HMF paper has more examples
21:46:20 <koninkje> http://research.microsoft.com/pubs/132621/hmf.pdf
21:46:37 <insertpseudonym> If I'm doing "concat . foldl intersect $ list" where list is a list of lists of strings, why doesn't it produce a list of strings?
21:46:47 <ddarius> (The former statement being "subject reduction" which doesn't -need- to hold of a type system, but usually your type system is considered horribly broken if it does not.)
21:46:50 <DanBurton> anyone else doing the facebook hacker cup with Haskell? I've got 2 done so far, 1 to go :)
21:47:22 <ddarius> DanBurton: How much time do they allot for it and how much do I get paid in the end?
21:47:44 <DanBurton> ddarius: if you didn't participate in the qualifying round last week, you can't get in anymore
21:47:56 <ddarius> DanBurton: That wasn't my question.
21:47:57 <DanBurton> ddarius: this round you have 24 hours to complete 3 problems
21:48:00 <russellw> ddarius, okay yes, I tried that definition of twice, and then I tried to apply it to (+) and to the successor function, and each time it failed with a different error message, though I don't understand why in either case. I don't suppose there's a simple explanation of why?
21:48:35 <ddarius> russellw: Your exercise is to find examples where f . f type checks but twice f does not.
21:48:35 <russellw> koninkje, thanks, looking at that now
21:48:46 <ddarius> russellw: Not just find examples where twice f doesn't type check.
21:48:49 <DanBurton> ddarius: I think the cash prize for the winner is like $5k, the top 20 or maybe more get an all-expenses-paid trip to FB HQ to compete in the final rounds
21:49:31 <koninkje> russellw: well, (\f -> f . f)(+) doesn't typecheck because it's trying to unify (c->c) with (a->a->a) which means c=a and c=(a->a)
21:50:15 <DanBurton> the details: http://www.facebook.com/notes/facebook-engineering/announcing-facebooks-2012-hacker-cup/10150468260528920
21:50:26 <shachaf> ddarius: That twice thing rather annoys me.
21:50:30 <shachaf> Is there anything that can be done about it?
21:50:31 <russellw> hmm. Given the obvious definition of the successor function, (s . s) 1 evaluates to 3 as expected, but (s . s) gives a type error
21:50:40 <russellw> Which I wasn't expecting
21:50:46 <ddarius> shachaf: Intersection type systems can produce the "desired" result.
21:51:12 <insertpseudonym> uh anyone?
21:51:44 <ddarius> :t foldl intersect
21:51:45 <lambdabot> forall a. (Eq a) => [a] -> [[a]] -> [a]
21:52:12 <ddarius> :t concat . foldl intersect
21:52:14 <lambdabot>     Couldn't match expected type `[[a]]'
21:52:14 <lambdabot>            against inferred type `[[a1]] -> [a1]'
21:52:14 <lambdabot>     Probable cause: `foldl' is applied to too few arguments
21:52:25 <koninkje> russellw: In particular, you just need to look at section 3. (Though the first two sections are a good lead-in for "why")
21:52:26 <ddarius> GHC is spot on there.
21:52:37 <insertpseudonym> hmm
21:53:05 <Sgeo> @src all
21:53:05 <lambdabot> all p =  and . map p
21:53:09 <Sgeo> @src and
21:53:09 <lambdabot> and   =  foldr (&&) True
21:53:16 <Sgeo> @src (&&)
21:53:17 <lambdabot> True  && x = x
21:53:17 <lambdabot> False && _ = False
21:53:19 <elliott> shachaf: It's annoying that you can't turn every right fold into a foldr.
21:53:21 <Sgeo> Suppose we're folding along
21:53:23 <elliott> (Because of that.)
21:53:27 <Sgeo> The first item is True
21:53:37 * elliott wonders who Sgeo is talking to.
21:53:55 <Sgeo> Does && then discard the True and the && and just give the right-hand side?
21:54:04 <Sgeo> elliott, I was asking a question, not responding to anyone
21:54:10 <ddarius> Sgeo: As opposed to?
21:54:28 <Sgeo> I'm basically wondering if some uses of foldr don't stack overflow with sufficiently long lists
21:54:51 <ddarius> Sgeo: Some uses of foldr don't stack overflow with lists of any length.
21:55:05 <Sgeo> ddarius, as opposed to foldr then demanding the next part of the list while still retaining the True and the &&
21:55:22 <elliott> If foldr always stack overflowed on sufficiently long lists, it'd be pretty useless.
21:55:28 <elliott> Or at least a lot less useful than it is now.
21:55:41 <ddarius> *cough* foldl *cough*
21:56:07 <ddarius> (Okay, foldl doesn't -always- stack overflow on sufficiently long lists.)
21:56:36 <ddarius> Sgeo: Evaluate it by hand using normal order (aka call-by-name).  If you can't evaluate it by hand that way, seek resources to learn how.
21:56:40 <Sgeo> Someone quoted something at me
21:56:41 <Sgeo> "A function strict* in its second argument will always require linear stack space with foldr, so foldl' should be used instead in that case. If the function is lazy/non-strict in its second argument we should use foldr to 1) support infinite lists and 2) to allow a streaming use of the input list where only part of it needs to be in memory at a time."
21:57:24 <ddarius> Sgeo: 1) (&&) isn't strict in its second argument.
21:57:26 <insertpseudonym> ddarius: your original depiction of the types doesn't work with my case I think
21:57:33 <insertpseudonym> ddarius: since I have a list of lists
21:57:57 <Sgeo> :t flip const
21:57:57 <insertpseudonym> so I'm still not getting why it doesn't work...
21:57:57 <lambdabot> forall b a. a -> b -> b
21:58:07 <koninkje> > False && undefined
21:58:08 <lambdabot>   False
21:58:09 <ddarius> insertpseudonym: Uh, I just asked for the type of your code.  Either you miscopied your code, or I miscopied your code, or it's a type error.
21:58:10 <Sgeo> flip const is strict in its second argument. What happens if you foldr with it?
21:58:26 <ddarius> Sgeo: Read the footnote.
21:58:29 <ddarius> @wiki Stack overflow
21:58:30 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
21:58:57 <insertpseudonym> ddarius: ugh...so any proposed solution?
21:59:07 <ddarius> insertpseudonym: Write code that type checks.
21:59:21 <ddarius> GHC said -exactly- what was wrong.
21:59:38 <Sgeo> ddarius, where is the footnote
21:59:39 <insertpseudonym> any resource?
21:59:44 <insertpseudonym> guess I'll google it
21:59:49 <Sgeo> Found it
22:00:07 <elliott> insertpseudonym: What error did you get?
22:01:03 <insertpseudonym>  Couldn't match expected type `[[a0]]' with actual type `[b0] -> a1'  Expected type: a1 -> [[a0]]    Actual type: a1 -> [b0] -> a1  In the return type of a call of `foldl'  In the second argument of `(.)', namely `foldl intersect'
22:01:34 <insertpseudonym> that's for "concat . foldl intersect $ list"
22:01:45 <insertpseudonym> list being a list of lists
22:02:16 <elliott> insertpseudonym: Okay. It's telling you the exact problem, there: itw anted an (a1 -> [[a0]]), but you've given it an (a1 -> [b0] -> a1).
22:02:23 <elliott> That code reduces to concat (foldl insersect list).
22:02:24 <elliott> :t foldl
22:02:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:02:34 <elliott> intersect is the function. You presumably want list to be the [b].
22:02:38 <elliott> Where's the a?
22:04:01 <insertpseudonym> shit it takes two arguments...
22:04:07 <insertpseudonym> is that it?
22:04:45 <insertpseudonym> I'm missing a binary operator I guess
22:05:02 <insertpseudonym> I chose foldl because map intersect wouldn't produce the behavior I wanted
22:05:15 * ddarius has no fucking clue what is going through insertpseudonym's head.
22:05:38 <elliott> insertpseudonym:
22:05:40 <insertpseudonym> insertpseudonym: lol...me neither. I think I need to sleep
22:05:42 <elliott> foldl
22:05:48 <elliott>   :: (a -> b -> a) -- you passed: intersect
22:05:56 <elliott>   -> a -- you passed: list (?!)
22:06:01 <elliott>   -> [b] -- you didn't pass anything
22:06:02 <elliott>   -> a
22:06:20 <elliott> So you ended up with a ([b] -> a), and passed it to concat.
22:06:41 <elliott> (Even ignoring the fact that "intersect" probably wouldn't work either, since you've fixed a = [c] for some c.)
22:06:54 <elliott> > foldl f z [a,b,c]
22:06:55 <lambdabot>   f (f (f z a) b) c
22:07:02 <elliott> > foldl f [a,b,c]
22:07:03 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
22:07:03 <lambdabot>    arising fr...
22:09:13 <Philippa_> is there a neater idiom to accomplish the same thing as, say, join fM <$> a <*> b <*> c?
22:09:47 <Philippa_> er, join $ fM ...?
22:09:59 <elliott> Philippa_: (| fM a b c @ |) with she, I think.
22:10:15 <Philippa_> elliott: need something that works on the Platform
22:10:20 <elliott> Or the horrific http://www.haskell.org/haskellwiki/Idiom_brackets hack.
22:10:41 <insertpseudonym> for the record, the solution was just using foldl1
22:10:49 <Philippa_> *nod*. Looks like join $ ... is the way to go for now, then
22:11:21 <elliott> insertpseudonym: That won't work if list is empty.
22:11:42 <elliott> Although I suppose intersect doesn't have many nice identity elements.
22:12:02 <ddarius> All you need is a universal "set" ...
22:12:12 <insertpseudonym> elliott: could you explain the binary operator? what's the purpose of it in foldl?
22:12:22 <elliott> What binary operator?
22:12:34 <elliott> Philippa_: You can define: f <<*> x = join (f <*> x)
22:12:38 <elliott> fM <$> a <*> b <<*> c
22:12:46 <elliott> Coming up with a good symbol left as an exercise to the reader.
22:12:47 <ddarius> elliott: Ugh.
22:12:54 <elliott> That's uncomfortably far away from fM for my tastes, though.
22:12:55 <insertpseudonym> that's what the documentation calls the paramter I was missing
22:13:07 <elliott> insertpseudonym: No.
22:13:10 <elliott> You were missing the zero.
22:13:11 * ddarius doesn't know how insertpseudonym even arrived at this code.
22:13:13 <elliott> The binary operator is intersect.
22:13:26 <Philippa_> yeah, I'd rather pay for the $
22:13:30 <insertpseudonym> 0 as in the starting point?
22:13:38 <elliott> > foldl f z [a,b,c]
22:13:39 <lambdabot>   f (f (f z a) b) c
22:13:41 <Philippa_> (context: I'm doing an "industrial strength" reader example)
22:13:43 <elliott> > foldl (fun "intersect") z [a,b,c]
22:13:43 <lambdabot>   intersect (intersect (intersect z a) b) c
22:13:51 <elliott> As in the z there.
22:13:59 <Sgeo> Nothing wrong with using join there, right?
22:14:02 <elliott> But yes, the "starting value".
22:14:06 <elliott> Going by the doc's name.
22:14:09 * ddarius recommends that insertpseudonym goes to sleep and then (continues to) reads an introduction to Haskell.
22:15:06 <AfC> I'm constantly being burned by what turns out to be extensions that everyone else is enabling as a matter of course but that aren't part of GHC's default set. Is there a -XAllTheNewHotness or a -f2012-haskell-ftw or something I'm missing?
22:15:30 <elliott> AfC: We used to have that.
22:15:53 <insertpseudonym> ddarius: lol I'm screwing up because I'm not reading any resource other than my teacher's lecture notes...painfully bare. But this is just a mini-course I'm taking and I don't have enough time to really dive into the text. I have to write an event-driven web server for another class and that'll take long enough :(
22:15:56 <elliott> It made code break whenever its definition was change, introduce unexpected side-effects of "powerful" extensions into code without realising it, and generally sucked all round for self-documentation.
22:16:02 <elliott> Also, it completely eliminated any possibility of portability ever.
22:16:05 <elliott> So it's deprecated.
22:16:09 <AfC> ie, Haskell has "moved on" as a language, but without enabling XYZ extensions, you're stuck in Haskell 98 which, er, hasn't moved on.
22:16:14 <ddarius> GHC(i) will tell you what extensions you are missing, and otherwise they'll be documented somewhere or you should know what your code is doing.
22:16:14 <elliott> *2010
22:16:24 <elliott> Anyway, it's not really like that.
22:16:34 <elliott> Most modules use from 0 to 3 extensions.
22:16:49 <elliott> Sometimes you'll adopt a style that requires all modules have one or two extensions, e.g. NoImplicitPrelude or the like.
22:17:01 <elliott> Apart from that, only enable the extensions you need in a module; or if you have a lot of common extensions, add them to your Cabal file.
22:17:04 * ddarius is not really sure what "problem" AfC is having.
22:17:17 <elliott> A blanket "turn on a bunch of extensions for everything" would be bad, because, well... they're extensions.
22:17:18 <AfC> Admittedly some of this is PEBKAC but I seem to go through 10-15 iterations before I notice the "or use -XNoMonomorphismRestriction" arising from some library call I'm making
22:17:21 <elliott> They should be used explicitly and wtih caution.
22:17:22 <Philippa_> I suspect mostly that enumerating the extensions you need (and remembering you need them) is tedious?
22:17:33 <elliott> AfC: Avoid the monomorphism restriction by giving every value a type declaration.
22:17:38 <shachaf> AfC: You should probably not turn on extensions without even understanding what they do.
22:17:47 <Philippa_> AfC: yeah, the monomorphism restriction's something I turn off the moment I get a type error now
22:17:50 <elliott> AfC: Not by turning it off.
22:17:56 <Philippa_> (I'm not in the "always annotate" camp)
22:18:06 <elliott> I am! :)
22:18:06 <ddarius> Philippa_: You don't just turn it off preemptively?
22:18:12 <AfC> ie, if it was my code and my deliberate knowledge of, and decision to use, an extension then sure, of course. But it seems they leak out of libraries all the time (and/or the interaction with Cabal vs # LANGUAGE vs GHCi)
22:18:24 <Philippa_> ddarius: I would if I remembered, the type error is the reminder :-)
22:18:39 <Philippa_> (I don't have default haskell module boilerplate)
22:18:50 <AfC> Philippa_: sure. But in this case, trying to make an example work, I had to turn it on (just cutting and pasting from someone's tutorial documentation)
22:18:52 <ddarius> AfC: That particular error and extension is not due to any "leakage."
22:18:59 <AfC> ddarius: ^
22:19:30 <Philippa_> AfC: ah. I have to admit, I'm an offender for writing tutorials that feature code that's actually exemplary snippets from a file and doesn't work out of context
22:19:40 <AfC> shachaf: indeed, I couldn't agree more. But when one gets this huge amount of goop from the compiler, and in there is "try turning this on" I'm left wondering whether that has anything to do with me.
22:20:45 * DanBurton wonders when -f-glasgow-exts went out of style
22:21:40 * ddarius wonders if the monomorphism restriction was in Haskell 1.0 or, if not, when it was added.
22:21:42 <AfC> (clearly I'm newbie-ish, but I've come to appreciate that first impressions from newcomers are appreciated in Haskell land, which is why I'm attempting to provide same without being rude)
22:22:52 * ddarius expects the monomorphism restriction to be removed in the next few years.
22:23:20 <DanBurton> AfC: newbie perspectives are certainly appreciated
22:23:21 <nyingen> why not today?
22:23:54 <DanBurton> and as long as you don't straight out say "Haskell sucks", most of us have thick enough skin to handle newbie criticism
22:23:54 <kallisti> ddarius: what about FlexibleContexts?
22:24:12 <Enigmagic> Haskell sucks
22:24:41 * DanBurton glares at Enigmagic
22:24:44 <Enigmagic> :)
22:24:53 <DanBurton> @slap Enigmagic
22:24:53 <lambdabot> I'd rather not; Enigmagic looks rather dangerous.
22:24:56 <DanBurton> >,<
22:25:01 <insertpseudonym> the only real criticism possible is that it's not really used
22:25:06 <insertpseudonym> other than that, the language is beautiful
22:25:09 <DanBurton> @slap lambdabot
22:25:09 * lambdabot hits lambdabot with an assortment of kitchen utensils
22:25:15 <Enigmagic> heh
22:25:18 <Sgeo> insertpseudonym, there are things that Haskell needs
22:25:22 <Sgeo> Better records, for starters.
22:25:29 <AfC> Anyway, I'll take this as a bug in Heist ['s documentation] and file it.
22:25:54 <DanBurton> Haskell needs to embrace lenses more deeply, imho
22:26:00 <DanBurton> rather than beefing up records
22:26:06 <Axman6> haskellers*
22:26:08 <insertpseudonym> Sgeo: yea...I'm trying to appreciate it more as a cool, different way of thinking about problems. I think that's the most use I'll get out of it.
22:26:20 <elliott> I agree, Haskell sucks.
22:26:41 * DanBurton thinks everyone should use Coq o_O
22:26:42 <elliott> insertpseudonym: That kind of attitude to Haskell is why most people never get any use out of it.
22:26:44 <Axman6> elliott: sucking would be a side effect, so it probably doesn't
22:26:44 <Sgeo> In the PHP channel, you will find people who unironically say that PHP sucks
22:26:47 <Axman6> uh, Enigmagic
22:26:56 <elliott> Axman6: unsafePerformIO suck
22:27:01 <elliott> --The Haskell Report
22:27:22 <ddarius> I guess the FFI is now part of the Report proper rather than an addendum.
22:27:27 <ddarius> Stupid Haskell 2010.
22:27:30 <Enigmagic> Axman6: yeah? :P
22:27:52 <ddarius> Sgeo: Yeah.  Like Rasmus.  Except he's probably not in the PHP channel.
22:28:22 <Sgeo> ddarius, Rasmus?
22:28:30 <Sgeo> Oh, the creator of PHP
22:28:35 <ddarius> Jesus Christ.  I don't even use PHP.
22:28:38 <Sgeo> o.O
22:29:39 * DanBurton sets off to write a web framework in coq
22:29:51 <ddarius> Hasn't that been done?
22:30:26 <elliott> Agda has been.
22:30:37 <elliott> ddarius: unsafePerformIO isn't part of the Report, though.
22:30:41 <elliott> They replaced it with unsafeLocalState.
22:30:56 <elliott> Sgeo: Anyway, I wasn't being ironic.
22:31:28 <Sgeo> @lang doesn't exist yet.
22:31:29 <lambdabot> pong
22:32:07 <Sgeo> ?
22:33:46 <DanBurton> say I lay 2 apples and 2 pears in front of you. Eating one at a time, where items of the same fruit are indistinguishable, how many ways can you eat all 4?
22:34:36 <DanBurton> I'm trying to think of the closed-form solution for n apples and m pears, but I can't quite think of it.
22:34:43 <Sgeo> > nub . permutations $ "aabb"
22:34:44 <lambdabot>   ["aabb","baab","abab","bbaa","baba","abba"]
22:34:52 <ddarius> DanBurton has too much time on his hands.
22:34:56 <otk> :t nub
22:34:56 <lambdabot> forall a. (Eq a) => [a] -> [a]
22:34:59 <ddarius> Or too many fruit.
22:35:05 <russellw> (n+m)!/(n!m!)
22:35:21 <Sgeo> otk, it deletes duplicates. Note that it's not efficient
22:35:27 <otk> ah
22:35:34 <Sgeo> > nub [1,2,1,3,1,4,2,6,3,10,20,10]
22:35:35 <lambdabot>   [1,2,3,4,6,10,20]
22:35:39 <otk> > nub [1,2,3,3]
22:35:40 <DanBurton> > factorial (2+2) / (factorial 2 * 2)
22:35:40 <lambdabot>   [1,2,3]
22:35:41 <lambdabot>   Not in scope: `factorial'Not in scope: `factorial'
22:35:44 <otk> > set [1,2,3,3]
22:35:44 <DanBurton> boo
22:35:45 <lambdabot>   Not in scope: `set'
22:35:47 <otk> hmm
22:35:56 <DanBurton> I thought Haskell had factorial predefined
22:36:00 <Sgeo> > Data.Set.fromList [1,2,3,3]
22:36:01 <lambdabot>   Not in scope: `Data.Set.fromList'
22:36:02 <kallisti> noep
22:36:04 <otk> DanBurton: ive seen that somewhere
22:36:06 <Sgeo> > Set.fromList [1,2,3,3]
22:36:06 <DanBurton> or at least caleskell
22:36:07 <lambdabot>   Not in scope: `Set.fromList'
22:36:10 <ddarius> DanBurton: That would be silly.  You pretty much never want the factorial function.
22:36:15 <kallisti> Sgeo: it's S not Set
22:36:20 <otk> ddarius: really?
22:36:23 <Sgeo> > S.fromList [1,2,3,3]
22:36:24 <lambdabot>   fromList [1,2,3]
22:36:25 <DanBurton> ddarius: what function do I want then?
22:36:27 <russellw> DanBurton, the divisor is n!m! not (nm)!
22:36:28 <Sgeo> othiym23, ^
22:36:32 <Sgeo> oops, otk ^
22:36:36 <ddarius> n `choose` m
22:36:49 <DanBurton> russellw: yes, but in the case of n=m, it's 2(n!)
22:36:53 <Sgeo> In an actual program, you'd import qualified Data.Set as Set or something
22:37:01 <DanBurton> russellw: I just didnt want to type "factorial" a third time
22:37:06 <russellw> nope, try it and see
22:37:08 <DanBurton> oh phail
22:37:15 <DanBurton> (n!)^2
22:37:15 <kallisti> Sgeo: I usually use S actually
22:37:16 <ddarius> DanBurton: You -really- don't want to calculate 10000 `choose` 10000 by first doing factorials.
22:37:16 <otk> Sgeo: cool
22:37:32 <DanBurton> ddarius: is there a faster way?
22:37:41 <ddarius> DanBurton: Well for that, it's 1.
22:37:50 <ddarius> DanBurton: There are a lot of faster ways.
22:38:27 <ddarius> > length (show (product [2..10000]))
22:38:29 <lambdabot>   35660
22:38:42 <otk> factorial using fold
22:39:03 <kallisti> that's what product is, yes.
22:39:06 <DanBurton> TIL multiplying 10k by other large numbers only reaches 35k xD
22:39:15 <DanBurton> oh wait
22:39:17 <DanBurton> xP length
22:39:38 <DanBurton> i need sleep
22:40:02 <ddarius> > logBase 2 10 * 35660
22:40:03 <lambdabot>   118459.95586368335
22:42:24 <kallisti> http://hackage.haskell.org/packages/archive/statistics/0.8.0.4/doc/html/Statistics-Math.html  found `choose`
22:44:00 <kallisti> not sure why factorial :: Int -> Double
22:45:56 <elliott> Probably it's Binet.
22:46:03 <ddarius> @let n `choose` k | 2*k >= n = n `choose` (n-k) | otherwise = numerator (product (zipWith (%) [k..n] ([1..k-1] ++ repeat 1)))
22:46:04 <lambdabot>  Defined.
22:46:13 <ddarius> > 10 `choose` 10
22:46:15 <lambdabot>   0
22:46:32 <axeljohnsson> Hi, is there any database management system written in Haskell? I've been searching and found one called Siege. Is there more? What are the reasons to not use Haskell for developing a DBMS?
22:46:37 <otk> zipwith (%)?
22:46:44 <otk> :t %
22:46:45 <lambdabot> parse error on input `%'
22:46:46 <ddarius> Off by one.
22:46:49 <otk> oh
22:47:02 <otk> sounds like something scarey
22:47:11 <elliott> It's the rational constructor
22:47:17 <elliott> > 0.5 == 1%2
22:47:18 <lambdabot>   True
22:47:18 <ddarius> @undefine
22:47:29 <elliott> :t (%)
22:47:30 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
22:47:39 <elliott> zipWith f [a,b,c] [d,e,f] = [f a d, f b e, f c f]
22:47:45 <elliott> > zipWith f [a,b,c] [d,e,f] :: [Expr]
22:47:46 <lambdabot>   [f a d,f b e,f c f]
22:48:00 <elliott> > zipWith (+) [a,b,c] [x,y,z] :: [Expr]
22:48:01 <lambdabot>   [a + x,b + y,c + z]
22:48:07 <otk> cool
22:48:40 <ddarius> @let n `choose` k | 2*k >= n = n `choose` (n-k) | otherwise = numerator (product (zipWith (%) [k+1..n] ([1..k] ++ repeat 1)))
22:48:41 <lambdabot>  Defined.
22:48:42 <ddarius> > 10 `choose` 10
22:48:44 <lambdabot>   3628800
22:49:13 <ddarius> Ah.
22:49:16 <ddarius> @undefine
22:49:34 <otk> heh
22:49:37 <otk> n choose k
22:49:50 <ddarius> @let n `choose` k | 2*k >= n = n `choose` (n-k) | otherwise = numerator (product (zipWith (%) [k+1..n] ([1..n-k] ++ repeat 1)))
22:49:51 <lambdabot>  Defined.
22:49:53 <ddarius> > 10 `choose` 10
22:49:55 <lambdabot>   1
22:50:11 <ddarius> > map (10 `choose`) [1..10]
22:50:15 <lambdabot>   mueval-core: Time limit exceeded
22:50:23 <ddarius> @undefine
22:51:05 <ddarius> @let n `choose` k | 2*k > n = n `choose` (n-k) | otherwise = numerator (product (zipWith (%) [k+1..n] ([1..n-k] ++ repeat 1)))
22:51:06 <lambdabot>  Defined.
22:51:06 <ddarius> > map (10 `choose`) [1..10]
22:51:08 <lambdabot>   [10,45,120,210,252,210,120,45,10,1]
22:51:15 <elliott> > n `choose` k
22:51:16 <otk> product [1..3]
22:51:17 <lambdabot>   *Exception: not a number
22:51:19 <elliott> HMPH
22:51:20 <otk> > product [1..3]
22:51:21 <lambdabot>   6
22:51:21 <ddarius> > map (4 `choose`) [1..10]
22:51:23 <lambdabot>   [4,6,4,1,0,0,0,0,0,0]
22:51:31 <elliott> > n `choose` 10
22:51:33 <lambdabot>   *Exception: not a number
22:51:38 <elliott> Useless.
22:51:48 <ddarius> > map (4 `choose`) [0..4]
22:51:50 <lambdabot>   [1,4,6,4,1]
22:52:03 <ddarius> > map (5 `choose`) [0..5]
22:52:04 <lambdabot>   [1,5,10,10,5,1]
22:52:21 <otk> is product just a foldr under the covers
22:52:26 <ddarius> otk: No.
22:52:28 <ddarius> @src product
22:52:29 <lambdabot> product = foldl (*) 1
22:52:35 <otk> oops
22:52:42 <ddarius> Though foldl' would be better virtually all the time.
22:53:03 <ddarius> > 10000 `choose` 10000
22:53:05 <lambdabot>   1
22:54:28 <ddarius> Doh, I have the comparison the wrong way so I'm doing pointless busy work.
22:54:34 <Jafet> bfold (*) 1
22:55:03 <elliott> otk: It could be a foldr, though.
22:55:05 <elliott> It just isn't.
22:55:16 <ddarius> > 10000 `choose` 10000
22:55:18 <otk> fair enough
22:55:18 <lambdabot>   1
22:56:53 <ddarius> > 10000000 `choose` 10000000
22:56:54 <lambdabot>   1
22:57:03 <ddarius> > 100000000000 `choose` 100000000000
22:57:05 <lambdabot>   1
22:57:58 <ddarius> > length (show (product [2..100000000000]))
22:58:03 <lambdabot>   mueval-core: Time limit exceeded
22:58:05 <otk> lol
22:58:20 <otk> hmm
22:58:46 <ddarius> > length (show (2^100000000000))
22:58:50 <lambdabot>   mueval-core: Time limit exceeded
22:58:52 <otk> im guessing when you call length it forces eager creation of the list?
22:59:08 <kallisti> otk: it forces the list but not the values
22:59:16 <otk> ok
22:59:44 <kallisti> > length [undefined, undefined, undefined]
22:59:45 <ddarius> It's not even getting to creating even the first cons cell of the list.
22:59:45 <lambdabot>   3
23:00:19 <kallisti> > product ([1..] :: Expr)
23:00:20 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
23:00:20 <lambdabot>         against inferred ...
23:00:30 <kallisti> > product ([1..] :: [Expr])
23:00:39 <lambdabot>   mueval: ExitFailure 1
23:00:39 <lambdabot>  mueval: Prelude.undefined
23:00:43 <otk> lol
23:01:09 <kallisti> foldl seems like a poor choice actually.
23:01:36 <kallisti> > foldr1 (*) ([1..] :: [Expr])
23:01:40 <lambdabot>   mueval-core: Time limit exceeded
23:01:43 <kallisti> hm, or not.
23:01:49 <kallisti> I guess Expr isn't lazy or something
23:01:49 <elliott> foldl' is the only reasonable choice for Int/Integer/Float/Double.
23:01:56 <kallisti> yes
23:02:40 <donri> > length ([1..]::[Expr])
23:02:44 <lambdabot>   mueval-core: Time limit exceeded
23:02:54 <kallisti> oh @src once again is lying
23:02:54 <ddarius> 2^100000000000 dramatically underestimates 100000000000! and that obviously takes 100000000000 bits or about 11 gigabytes to store.
23:02:57 <donri> > maxBound :: Expr
23:02:58 <lambdabot>   maxBound
23:03:02 <donri> ^_^
23:03:26 <otk> 11gb nice
23:03:44 <otk> how does length work
23:03:45 <kallisti> product and sum use an accumulating parameter in GHC's Prelude
23:03:56 <kallisti> length [] = 0; length (_:xs) = 1 + length xs
23:03:56 <otk> kallisti: because of foldl?
23:04:08 <elliott> length = sum . map (const 1)
23:04:10 <otk> fold threading the accumulator
23:04:16 <kallisti> otk: no it doesn't use foldl at all in the actual source code.
23:04:20 <elliott> That transforms every list element into 1, and then sums them.
23:04:26 <otk> kallisti: while loop? heh
23:04:27 <elliott> The actual source code is irrelevant, since it's an ugly loop with an unboxed Int# in GHC.
23:04:30 <kallisti> otk: ....no
23:04:32 <elliott> Haskell has no while loops.
23:04:45 <otk> what does product compile down to
23:04:47 <elliott> (OK, yes it does, but as a monadic control structure.)
23:05:02 <elliott> Machine code.
23:05:12 <ddarius> elliott: That's still just a function and still just using recursion.
23:05:18 <otk> so it would eventually compile down to a for/while loop
23:05:23 <elliott> ddarius: Yes, indeed.
23:05:26 <elliott> But it's a while loop.
23:05:34 <kallisti> otk: I don't know of a machine language that has for and while loops
23:05:37 <elliott> otk: No common processor architecture I know has for/while loops.
23:05:43 <kallisti> elliott: I win
23:05:45 <elliott> They have conditional jumps.
23:05:46 <pikhq> otk: No, it *might* eventually compile into the same *thing* that a for/while loop compiles into.
23:05:46 <otk> hm
23:05:55 <otk> pikhq: ah thats better
23:06:10 <otk> my bad way of asking
23:06:24 <elliott> Well, folds can compile down in the same way.
23:06:24 <pikhq> (there is no guarantee that it *does*. GHC is perfectly free to compile it down into recursion.)
23:06:42 <kallisti> pikhq: probably with a bit of extra indirection, and jumping actually
23:06:55 <otk> jumptables and other optimizations?
23:06:57 <kallisti> assuming something magical doesn't happen at the STG level.
23:07:42 * ddarius wonders if the Burroughs B5000 had a looping instruction.
23:07:43 <otk> meh its not like it matters that far down anyway im sure... 99% of the time
23:07:54 <dolio> Most machine languages don't have recursion, either.
23:08:11 <otk> doesn't x86 have a loop?
23:08:25 <kallisti> nope. conditional jumps
23:08:29 <ddarius> It has a loop opcode which is decrement ecx and jump to the given label if not zero.
23:08:30 <kallisti> which emulate loops
23:08:31 <pikhq> x86 assembly arguably *does* have a notion of a function call, though.
23:08:36 <otk> hmm..
23:09:00 <otk> what about loop, loopz, loopnz ect
23:09:06 <elliott> There is a LOOP opcode.
23:09:09 <pikhq> Although that is little more than shorthand for "push the instruction pointer on the stack and jump"
23:09:11 <elliott> But it's hardly a while loop.
23:09:22 <otk> ah well...
23:09:25 <otk> i duno enough about it i guess
23:09:42 <ddarius> The stos/ins/outs etc. functions, are actual loops.
23:09:43 <otk> http://en.wikibooks.org/wiki/X86_Disassembly/Loops is interesting
23:09:48 <kallisti> pikhq: oh, x86 has a call stack?
23:09:59 <otk> shows you what the while compiles down to, but i doubt all compilers are the same ect
23:10:06 * ddarius has been writing a lot of extraneous commas today.
23:10:34 <Philippa_> kallisti: it has a whole segment for it, even
23:10:38 <pikhq> kallisti: Well, it has a pointer that is treated as a pointer to the stack by certain opcodes.
23:10:38 <elliott> ddarius shatner
23:10:40 <otk> witnessed a switch statement aparently getting optimized with a jumptable 3 days past
23:10:42 <pikhq> kallisti: call, ret.
23:10:44 <ddarius> Well, to be precise, rep stos etc.
23:10:51 <elliott> otk: That's the whole point of a switch statement.
23:10:54 <kallisti> pikhq: ah I see. so a dedicated register to a stack pointer.
23:10:56 <kallisti> ?
23:10:59 <pikhq> Yeah.
23:11:02 <pikhq> esp.
23:11:03 <ddarius> Also s/functions/opcodes/
23:11:09 <otk> elliott: dont different compilers do different things with switch statements though?
23:11:31 <ddarius> otk: The same compiler will do different things with switch statements.
23:11:37 <elliott> Well, sure, but a compiler that compiled a switch statement into something other than a jump table without a good reason to (e.g. it's small so it's faster without) would be rather second-class.
23:11:48 <otk> ah
23:11:52 <Philippa_> elliott: or the table is sparse and /big/, yeah
23:12:41 * ddarius <3 the x86 string opcodes.
23:13:24 <EvanR> im trying to make a basic mud, and im trying to come up with data structures for rooms and items/mobs that inhabit the rooms...
23:13:45 <EvanR> could throw random int refs around but feels wrong
23:13:57 <ddarius> pikhq: You didn't even mention enter and leave (let alone sysenter/syscall/sysret/sysexit.)
23:13:59 <kallisti> EvanR: consider all of the things that are common between all kinds of things, and include that as a field in the other structures.
23:14:21 <ddarius> EvanR: That sounds like a horrible representation even not in Haskell.
23:14:49 <EvanR> not that im disagreeing with that, but why
23:14:51 <kallisti> EvanR: if you're using concurrency I would recommend using STM and TVars.
23:14:59 <elliott> EvanR: You sound like you want a tree or graph structure.
23:15:15 <russellw> EvanR, consider that muds normally provide a way for players to disambiguate references to objects with similar names by explicitly supplying the object ID number
23:15:18 <kallisti> the rooms would certainly form a graph.
23:15:25 <elliott> That's what the Int "references" would be implementing, anyway.
23:15:29 <russellw> Since you need that anyway, it would be more consistent to apply throughout
23:15:33 <otk> ddarius: sysenter is pretty amazing
23:15:33 <ddarius> EvanR: It sounds very unstructured and non-uniform which is not what you want.
23:15:34 <otk> lol
23:15:46 <elliott> russellw: That shouldn't drive the entire data structure design.
23:15:49 <EvanR> rooms form a graph ok, but things in a room?
23:15:58 <kallisti> EvanR: that's just a set of things.
23:15:59 <elliott> EvanR: Sure.
23:16:02 <russellw> So yes I would go with int references, though for human usability, I wouldn't make them literally random, I would assign them in increasing order
23:16:10 <elliott> EvanR: Consider a tree where a room is the root and all the things inside are branches.
23:16:14 <otk> rather confusing what it does with registers depending on the version (amd vs intel both have a sysenter its even called the same thing, but it is slightly different in regards to what registers it utilizes)
23:16:25 <elliott> EvanR: Now consider a bunch of those trees, and make it into a graph by connecting all the rooms' exits together.
23:16:29 <elliott> Or whatever.
23:16:40 <kallisti> elliott: eh I wouldn't represent it exactly like that. instead of an explicit tree I would use a Set (which technically is still a tree in implementation, but whatever)
23:16:46 <russellw> elliott, I think it should. Since you need integer references everywhere anyway, I think it's better to just decide up front to use those integer references everywhere an object reference is needed. The result will be simpler and more reliable and easier to maintain than having multiple ways to refer to objects
23:16:54 <EvanR> kallisti: why are you talking about Set
23:17:03 <kallisti> russellw: there is nothing about MUDs that requires integer identifiers
23:17:13 <kallisti> though you could have them as well.
23:17:19 <kallisti> I would implement them seperately, as a mapping.
23:17:26 <kallisti> or hash table. if needed.
23:17:34 <russellw> kallisti, yes there is, you need a way for players to disambiguate objects
23:17:39 <elliott> russellw: Yes, but it'll make *every single piece of code* that deals with objects ugly. Better to stick an extra Int field in everything just for this purpose and make the disambiguation-handling code ugly.
23:17:52 <russellw> elliott, why do you say that?
23:18:01 <elliott> I say things because I believe them to be true.
23:18:11 <EvanR> -_-
23:18:18 <russellw> Okay then, what is the reasoning that persuaded you of the truth of that particular statement? :)
23:18:22 <elliott> Also, not every system has to implement that disambiguation, unless "MUD" is actually defined in such a way to eliminate any system that doesn't offer numeric object ID disambiguation.
23:19:06 <elliott> russellw: Because dealing with an Int reference heap rather than something strongly-typed and structured will suck (it's just explicit pointers), but attaching an Int to nodes of a rich structure is easy.
23:19:18 <russellw> It's not a matter of definition but of experience. With small text adventures of the usual kind, it's just about feasible for the single programmer to make sure general disambiguation is never necessary. With a mud, it is not
23:20:06 <kallisti> in my experience disambiguous can be solved by just putting an integer in front of the search phrase.  1.sword, 2.sword, etc.
23:20:12 <elliott> There are more ways to provide disambiguation than object IDs.
23:20:23 <kallisti> that's the system I'm most familiar with. and it works quite well.
23:20:33 <EvanR> muds can have more than one indistinguishable item in the area, and then later one of them suddenly becomes different, might as well be different from the beginning
23:20:36 <elliott> For instance, like kallisti said: "There are a bunch of objects called 'blah' in this room. Which one do you mean? [numbered list of longer descriptions]".
23:20:50 <russellw> elliott, ah, I think I see what you are getting at, you are saying doing it my way would result in weaker type checking than doing it your way? Yes, that's true. In my opinion that's a small price well worth paying, but I will grant opinions could reasonably differ
23:20:51 <EvanR> kallisti: 'sword' being the short form to refer to it
23:21:08 <kallisti> EvanR: yes. or just a general search phrase. there are many ways you can do object queries in a room.
23:21:30 <EvanR> search and naming etc seem to be besides the point here
23:21:36 <kallisti> yes.
23:21:43 <kallisti> which is why it shouldn't be the basis for the entire structure.
23:21:49 <EvanR> i didnt suggest that
23:21:53 <russellw> And yes, you could generate disambiguation numbers on the fly, instead of having them permanently assigned. I think permanent assignment is a cleaner solution for a number of reasons - consider what happens when it's time to serialize your data, for example
23:21:53 <kallisti> I know.
23:22:06 <russellw> No, I suggested it :-)
23:22:19 <elliott> russellw: Not just weaker type checking.
23:22:23 <EvanR> russellw: whats permanent about 2.sword once you move that sword to another room
23:22:23 <kallisti> russellw: in my scheme the numbers wouldn't even really be part of the structure.
23:22:29 <elliott> You would have to explicitly carry around the heap as a separate piece of state from your focused item.
23:22:31 <russellw> I'll stand by my suggestion while acknowledging that there are trade-offs
23:22:33 <elliott> And explicitly dereference it all the time, etc.
23:22:50 * ddarius suggests storing the whole thing in an XML database and having XPath be the UI.
23:22:56 <elliott> russellw: Why would you need to serialise the disambiguator?
23:22:57 <kallisti> ddarius: excellent
23:22:58 <elliott> That's a UI issue.
23:22:59 <EvanR> ddarius: ...
23:23:07 <elliott> *disambiguators
23:23:13 <EvanR> the whole thing is acid-state, or bust
23:23:15 <ddarius> The scary thing is that that would probably work -really- well.
23:23:27 * EvanR puts ddarius on ignore ;)
23:23:32 <kallisti> russellw: MUDs have changed a lot. I think the itenger identification scheme is quite archaic.
23:23:49 <kallisti> it's much easier to refer to names, and use a number /if/ disambiguation within a particular room is needed.
23:23:50 <russellw> elliott, when you are serializing, you need some kind of key. Of course it doesn't have to be the same as the user visible disambiguation, but making it so, means you have just one single key scheme everywhere
23:24:12 <EvanR> kallisti: thats a UI issue
23:24:16 <russellw> kallisti, of course. Most of the time you would use names, using the number only when necessary - not just in a particular room, mind you
23:24:38 <EvanR> there are probably scores of rooms with identical names
23:24:41 <Oxryly> are you guys still talking about text adventures.....?
23:25:16 <otk> cool, haskell has a crc32 and adler32
23:25:17 <EvanR> serialization is a none issue for several reasons
23:25:19 <russellw> EvanR, exactly. That's a case where a permanent integer key is cleaner and easier to track from the user viewpoint as well as the programmer viewpoint
23:25:29 <kallisti> russellw: nothing about using n.name implies that you ever need to store the integer in the structure itself, because it's entirely based on the individual search phrase which number corresponds to a particular object.
23:25:45 <russellw> kallisti, no, but I think it's cleaner and easier if you do
23:25:56 <kallisti> I guess you will find out.
23:26:13 <EvanR> 2.sword 3.sword does not refer to 'permanent integer keys'
23:26:16 <elliott> russellw: Erm.
23:26:22 <elliott> russellw: The whole point of using a graph structure is that it handles that for you.
23:26:25 <EvanR> that refers to a UI thing to choose the second or third such item in the search results
23:26:31 * kallisti has actually maintained a MUD codebase before, by the way.
23:26:32 <russellw> kallisti, well, more exactly, EvanR will find out :-)
23:26:47 <EvanR> kallisti: a C mud?
23:26:48 <elliott> russellw: Saying you should explicitly expose the implementation detail of pointers so that you can use the implementation detail as UI is... weird to me.
23:26:51 <kallisti> EvanR: yes
23:27:04 * ddarius might make a quick text MUD using C# and Ferry.
23:27:07 <russellw> EvanR, I agree, my suggestion is that the first sword at time of creation gets a permanent integer key 1234 which can be used to refer to it at any time
23:27:19 <EvanR> russellw: like MOO
23:27:25 <russellw> kallisti, fair enough
23:27:50 <EvanR> so back to the haskell data structure ;)
23:28:07 <russellw> elliott, bear in mind that implementation detail and user interface do not have a sharp line between them in a mud context, because a mud typically provides some kind of scripting
23:28:20 <kallisti> EvanR: hmmm, I think you'd want either Sets or Maps for linking rooms to other rooms, and rooms to their contents.
23:28:23 <EvanR> the consensus here is to have rooms mobs and items all be the same 'thing' and be in a containment hierarchy plus graph
23:28:41 <kallisti> EvanR: hm, no.
23:28:50 * hackagebot snaplet-mongodb-minimalistic 0.0.6 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6 (PetrPilar)
23:28:50 <EvanR> which i was going to implement with int refs
23:28:52 <Philippa_> has anyone written a MOO with object capabilities?
23:28:56 <kallisti> it depends on what you want, actually. I think it's easier if rooms are conceptually distinct from the other kinds of things.
23:29:20 <Oxryly> how about cars, boats, etc?
23:29:29 <EvanR> vehicles
23:29:30 <EvanR> good point
23:29:36 <EvanR> but i was only going to start with basics
23:29:39 <elliott> russellw: Sure.
23:29:51 <elliott> russellw: It would be great to be able to innovate on a model that requires the scripting language to work with raw object IDs.
23:30:06 <elliott> Otherwise I'd question what Haskell is even buying you.
23:30:17 <ddarius> Philippa_: I think so.
23:30:22 <EvanR> elliott: if the 'scripting language' has 'references' it doesnt need to expose the integer value for any reason
23:30:26 <Philippa_> elliott: not even all that difficult to do, aside from deciding how to handle user logins
23:30:41 <russellw> elliott, I guess you could take the approach of letting Haskell be the scripting language and having the type system run all the way down. That would be an interesting experiment
23:30:51 <Philippa_> EvanR: exactly
23:31:06 <Philippa_> russellw: also a great way to get DoSed
23:31:13 * EvanR wonders why the f java allows null references
23:31:14 <russellw> yep
23:31:28 <russellw> Not to mention fun times debugging even while you weren't being dos'd
23:31:37 <kallisti> EvanR: as for representing different kinds of "things" with different capabilities you may benefit from using existential types. unless you decide that you can represent every kind of object and every kind of room as a universal sort of structure.
23:31:38 <russellw> But it would still be an interesting experiment, at least in the Chinese sense :-)
23:31:39 <ddarius> "f java"?
23:31:49 <Philippa_> ddarius: "WTF java allows..."
23:31:51 <elliott> EvanR: Exactly.
23:32:15 <ddarius> I read "why" as "what".
23:32:20 <elliott> kallisti: That is what existential types require you to do.
23:32:26 <EvanR> lol thats why i didnt say wtf lol
23:32:27 <kallisti> elliott: well, yes.
23:32:31 * elliott is pretty sure he's linked kallisti to the existential antipattern post before, so he won't bother doing it again.
23:32:46 <EvanR> i dont think existentials is necessary here
23:32:52 <russellw> elliott, can you link me to it?
23:32:58 <elliott> EvanR: I agree. (They're never necessary.)
23:33:16 <elliott> russellw: http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F and the linked post http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
23:33:19 * ddarius finds that view silly.
23:33:29 <elliott> ddarius: Note that never necessary =/= never useful.
23:33:37 <russellw> thanks!
23:33:40 <elliott> Existentials may sometimes be useful, just about 1000 times less often than people think they are.
23:33:43 <kallisti> EvanR: yes probably not necessary
23:33:57 <elliott> But they're definitely never *necessary*, since translating them to a form that doesn't use existentials is rather simple.
23:34:07 <ddarius> elliott: Almost nothing in programming languages is necessary.
23:34:23 <EvanR> obviously rooms form a graph, so an actual graph structure would be better than an int map with int refs for exits
23:34:26 <EvanR> ?
23:34:35 <elliott> ddarius: The transformation is also basically local.
23:34:39 <ddarius> elliott: It's not always trivial to translate away existentials.
23:34:43 <elliott> EvanR: I would say so, yes.
23:34:43 <kallisti> EvanR: one MUD I used represented everything as a single structure. it worked pretty well, but also relied on flags to specify different kinds of behaviors such as whether or not you can enter the object, or pick it up, or drop it, etc.
23:35:16 <Oxryly> EvanR: will there need to be pathfinding?
23:35:30 <elliott> ddarius: Hmm, do you have an example?
23:35:35 <EvanR> not in my basic experiment, but that would be nice in a real life mud
23:35:42 <EvanR> 'goto hell'
23:36:32 <EvanR> but path presets is something clients often do
23:36:39 <Oxryly> it seems like keeping a graph structure around is only useful for algos that must traverse multiple rooms (like pathfinding)
23:36:40 <ddarius> elliott: You can always do the double negation translation.  If you don't consider that cumbersome, then your statement holds.
23:36:58 <kallisti> Oxryly: no
23:37:08 <kallisti> it's useful for... moving a player from room A to room B via an exit
23:37:12 <kallisti> the graph is the entire world.
23:37:30 <EvanR> so far im only admitting that rooms form a graph
23:37:51 <Oxryly> kallisti: room A names room B as an exit, then moving needs to look up room B. graph is implicit at best
23:38:16 <elliott> ddarius: Fair enough.
23:38:27 <Oxryly> room exits should probably be dynamic (scriptable)
23:38:29 <elliott> Oxryly: But a graph structure is what Int references *would accomplish*.
23:38:32 <kallisti> EvanR: I would say Set is a good choice for representing the "contents" of a room. because it allows fast membership tests (which is sometimes useful) but can also be linearly traversed if you need to do a more specific kind of search.
23:38:36 <elliott> It's just also safer and easier to use.
23:38:44 <kallisti> but others would work well. Map could be used. or just a regular list.
23:38:59 <kallisti> Oxryly: yes it's an implicit graph
23:39:13 <kallisti> (whatever that means)
23:39:15 <EvanR> heh. Set of what
23:39:20 <kallisti> EvanR: "things"
23:39:20 <EvanR> more int refs
23:39:22 <elliott> no
23:39:25 <elliott> objects
23:39:40 <elliott> you can represent every kind of dynamic behaviour with a single structure
23:39:55 <elliott> the key is balancing between the flexibility and concreteness of this structure
23:39:57 <EvanR> well now its OOP, all the worlds objects are 'stored' 'in' 'rooms'
23:39:57 <elliott> (again see http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F)
23:39:59 <elliott> no
23:40:00 <elliott> it's not OOP
23:40:08 <kallisti> EvanR: unless you intend to use concurrency (at which point I recommend TVars and STM), you have no need for any kind of mutable reference (and if you do, then integer references are not the ones you want.)
23:40:13 <EvanR> if i want to check an item i have to search the entire world for it
23:40:17 <elliott> or at least, the parts of OOP that it does inherit (dynamic behaviour-carrying objects, encapsulation) are the *good* parts
23:40:28 <elliott> EvanR: That's not true at all.
23:40:42 <elliott> EvanR: How are you identifying the item? If by a name: Map String [Item].
23:40:45 <elliott> It's just indexes.
23:40:48 <kallisti> EvanR: hopefully objects are aware of the rooms they're located in.
23:40:54 <kallisti> or the code is, somehow.
23:40:54 <EvanR> String ? o_O
23:40:55 <elliott> Map String (Set Item) is better, I suppose.
23:41:00 <elliott> EvanR: How are you searching for the item?
23:41:06 <elliott> String was an example.
23:41:14 <EvanR> intref
23:41:21 <Oxryly> objects have unique names
23:41:21 <elliott> Yes, if you want to use int refs, you have to use int refs.
23:41:25 <elliott> The suggestion was to not use int refs.
23:41:30 <EvanR> Oxryly: not in a mud, usually
23:41:57 <Oxryly> how are objects specified by coders/designers/etc...?
23:41:59 <kallisti> usually there's a "short name" and a "long name" and I like to be able to specify an object by either, and disambiguate when needed.
23:42:24 <EvanR> Oxryly: in old muds, by their order in the list of item types
23:42:32 <Oxryly> kallisti: so a global Map mapping long names to objects would suffice?
23:42:37 <kallisti> for the long name it would be a sub-string of the long name, corresponding to a subsequence of its words.
23:42:58 <kallisti> Oxryly: no.
23:43:03 <Oxryly> or a hash of the long name if you'd like
23:43:14 <EvanR> hash -_-
23:43:16 <dolio> There could be more than one item with the same long name.
23:43:25 <kallisti> well, for administrators, global identifiers /might/ be needed. in that case I would use unique names.
23:43:29 <EvanR> see what dolio said
23:43:41 <Oxryly> multiple identical "short sword"s, for example?
23:44:00 <elliott> EvanR: You still haven't clarified your question.
23:44:01 <EvanR> multiple identical 'the giant gemmed crown of yendor'
23:44:13 <elliott> EvanR: "if i want to check an item i have to search the entire world for it" Why is this true with a graph-based room layout system?
23:44:14 <kallisti> but in most situations you only need to know about what is in a specific room
23:44:17 <Oxryly> so you have instances of objects
23:44:22 <kallisti> so a global map of objects isn't needed.
23:44:37 <kallisti> unless you need it for admin stuff.
23:45:08 <mrotondo> but in any case, there's no real sense in which a global object collection would be anything other than a list of all the extant objects
23:45:17 <Oxryly> you have a db of classes or prototypes of objects and then instances appear whever the actual objects are contained
23:45:18 * dolio casts locate object.
23:45:35 * ddarius casts cripple server.
23:45:40 <EvanR> elliott: lets start over, rooms are in a graph ok, now how the hell do i program the move command
23:45:56 <EvanR> do rooms still have a unique id
23:46:04 <elliott> EvanR: I don't know. What do you want it to do?
23:46:17 <EvanR> move a mob from one room to another
23:46:20 <elliott> I wouldn't give anything a unique ID; you can disambiguate locally. But there's no obstacle to putting an ID field in everything just for identification purposes.
23:46:30 <mrotondo> EvanR: don't think about the rooms, think about their relations to one another
23:46:39 <kallisti> typically you have a number of paths that you can take, called exits. some games use directional names, others use arbitrary names. you type the name, and it takes you to the room that points to it. It would be a Map String Room
23:46:41 <elliott> EvanR: Okay. Update the graph by removing that mob from the set of room objects, and adding it to the other room's set.
23:46:41 <EvanR> move from the room im in to another
23:46:46 <mrotondo> you should be able to get to the same room in a number of ways, from different places
23:47:11 <EvanR> elliott: so 'objects' have a unique id
23:47:15 <elliott> They do?
23:47:20 <elliott> I did not imply that.
23:47:25 <EvanR> you did by saying 'set'
23:47:28 <mrotondo> so then maybe you identify the connected rooms (the places you can get to from where you are) by the command the user would have to input to go to those other rooms
23:47:38 <elliott> Fine, s/set/list/.
23:47:44 <elliott> The ordering doesn't matter.
23:47:49 <kallisti> mrotondo: yes
23:47:50 <elliott> You really want a multiset, but whatever.
23:47:53 * Oxryly is now fixated on the objects are instances of classes idea. Infected by OOP.
23:48:07 <kallisti> for the player, all the identifiers are /local/ to the room they're in. global identifiers are not needed
23:48:17 <ddarius> Simulation is where OOP arose.
23:48:32 <kallisti> for the administrator, this may not necessarily be the case. at the very least, rooms would benefit from global identifiers so that admins can quickly teleport to rooms.
23:48:42 * elliott thinks "OOP" is perfectly reasonable in this scenario.
23:49:13 <Oxryly> yeah.. producing a room graph with multiple identical nodes would seem to present admin and design problems
23:49:14 <elliott> OOP as in object-oriented programming, not as in the mainstream caricature of it everybody loves to hate.
23:49:35 * ddarius recommends forking a thread for every single room and having them communicate over channels.
23:49:44 <mrotondo> haha
23:49:52 <Oxryly> now we're talking
23:49:54 <EvanR> well, now that were talking about 'how i just think about stuff', im going to go out and say the model which pops into my head when trying to do this is to have the objects be a relational table where each object has a room id its in
23:49:58 <mrotondo> subprocesses
23:50:00 <EvanR> and objects have unique ids
23:50:08 <kallisti> ddarius: I think forking a thread for each player is not unreasonable.
23:50:12 <mrotondo> and the admin can just run ps to figure out the pid of the room he wants to teleport to
23:50:12 <kallisti> if using STM
23:50:26 <ddarius> kallisti: Doing something elsewise would be unreasonable.
23:50:31 <kallisti> yes.
23:50:45 <EvanR> i am completely not using concurrency for the simulation and thats that
23:50:56 <ddarius> This is not what I'm suggesting, as I know you are aware.
23:51:00 <Oxryly> EvanR: I'm with you
23:51:08 <elliott> EvanR: Have you used concurrency in Haskell?
23:51:10 <EvanR> yes
23:51:14 <elliott> You will not be able to service more than one client without concurrency.
23:51:21 <EvanR> incorrect
23:51:24 <elliott> Unless you go and bind to select().
23:51:25 <kallisti> EvanR: having global identifiers is not a bad idea, but using global identifiers to represent the structure between all of the different things is going to be annoying.
23:51:30 <elliott> (I guess the unix package probably has select.)
23:51:33 <kallisti> elliott: that's what is typically done, actually.
23:51:39 <elliott> kallisti: Not in Haskell.
23:51:40 <kallisti> in non-Haskell stuff I've seen.
23:51:41 <kallisti> right
23:51:43 <EvanR> i do not intent to use select, and i dont count accept threads as 'the simulation'
23:52:09 <elliott> EvanR: What's wrong with concurrency?
23:52:11 <elliott> In Haskell, specifically.
23:52:15 <EvanR> nothing
23:52:18 <EvanR> its amazing
23:52:22 <EvanR> in haskell specifically
23:52:24 <elliott> I see. So why are you avoiding it?
23:52:27 <mrotondo> i don't think he said he's against it
23:52:32 <EvanR> im avoiding it in the simulation
23:52:34 <Oxryly> it's a solution for which there's no problem present
23:52:37 <elliott> Well, it seemed a little strong a statement for someone with no problem with it.
23:52:46 <dolio> Why aren't you using concurrency for summing numbers in a list?
23:52:52 <ddarius> EvanR: I would just suggest making a relational data model (or ER model) for the thing and leaving it at that.  Other than adding some caching, there is probably little you will have to do beyond that.
23:53:19 <ddarius> dolio: Dude, I have every character in a text string in a GUI be its own concurrent process.
23:53:38 <EvanR> ddarius: which brings me to my next question... is there a haskell relational module? i only see stuff for tree-like data structures (and graphs apparently...)
23:53:50 * elliott wasn't seconding ddarius' or kallisti's "suggestions", but a blanket ban on concurrency seemed odd.
23:53:59 <EvanR> elliott: its not blanket
23:54:02 <elliott> EvanR: http://hackage.haskell.org/package/ixset
23:54:07 <elliott> Commonly used with acid-state.
23:54:16 <ddarius> EvanR: It's called a database, but there are packages that do not database things.
23:54:19 <elliott> That's not quite full relational model, I don't think, but it might be enough for your needs.
23:54:19 <kallisti> elliott: oh nice
23:54:25 <EvanR> ok ixset
23:54:28 <EvanR> knew about it, didnt remember it
23:54:30 <kallisti> elliott: that's exactly what I would want when writing a Haskell MUD.
23:54:42 * ddarius would actually use a database.
23:54:50 <kallisti> weirdo.
23:54:59 <EvanR> wouldnt acid states be faster
23:55:00 <dolio> That's not very old school.
23:55:07 <ddarius> dolio: I know.
23:55:09 <elliott> EvanR: Huh?
23:55:16 <elliott> EvanR: acid-state is designed to be used with ixset.
23:55:22 <elliott> You just make your acidic state be an IxSet.
23:55:32 <EvanR> i took ddarius to mean he would use a RDBMS server
23:55:42 <elliott> Oh, you were responding to ddarius.
23:55:44 <EvanR> yes
23:55:50 <dolio> You should manually reimplement a graph implicitly into every type of object you make.
23:56:11 <ddarius> EvanR: You add some caching and you're set.
23:56:13 <dolio> And linked lists, too.
23:56:16 <EvanR> meh
23:56:17 <kallisti> elliott: oh hmmm STM might not actually be necessary if using acid-state I think?
23:56:34 <ddarius> You could probably more than get away with -not- having any caching.
23:56:58 <EvanR> probably could get away with a lot for a small number of players
23:57:13 <EvanR> id like to see how big i could get it with least effort
23:57:24 <EvanR> and setting up a db server is effort to me
23:57:28 <ddarius> The least effort, to me, would be to use a relational database.
23:57:49 <dolio> data Item = Item { proto :: ItemProto ; loc :: Either Room Mob ; next : Maybe Item }
23:57:49 <elliott> kallisti: acid-state is basically just STM with persistence and a bit more work.
23:57:51 <mrotondo> redis etc are all knocking on the window right now
23:58:00 <mrotondo> peering at you
23:58:03 <elliott> mrotondo: That doesn't help if you want a *relational* model.
23:58:12 <EvanR> dolio: lol
23:58:17 <EvanR> C
23:58:33 <ddarius> dolio: Skip lists.
23:58:54 * Oxryly 's sarcasm detector is on the fritz.
23:58:56 <EvanR> im asking for serious help and its hard to disambiguate jokes from serious suggestions
23:59:03 <mrotondo> i mean… kinda? you can still do relational stuff in the various nosql dbs
23:59:18 <EvanR> you were joking about relational now?
23:59:19 <EvanR> uhg
23:59:21 <EvanR> nevermind
23:59:21 <dolio> EvanR: That is based on real code, but I wouldn't recommend it.
23:59:34 <dolio> You'd have to make things mutable at least.
23:59:36 <EvanR> ill go back to figuring it all out by myself
23:59:40 <donri> acid-state gives you the in-memory performance of redis with all its data types plus optional relational queries via ixset
23:59:45 <Oxryly> manually implementing a linked list in haskell?  what manner of madness is this?
23:59:45 <dolio> Or else you have to rewrite the entire graph every time you change anything.
23:59:54 <elliott> EvanR: Mine and ddarius' suggestions were serious.
23:59:55 <mrotondo> this acid-state sounds like the biz
23:59:58 <elliott> As if ddarius could ever joke.
