00:09:44 <elliott> Help!! I've been trying to optimise my code with unboxed Maybes but nothing# sometimes segfaults! http://hpaste.org/56368
00:10:23 <elliott> :P
00:18:44 <nick8325> elliott: i could be wrong, but since Addr# has kind # i don't think you're allowed to cast it to Any, are you?
00:19:51 <elliott> unsafeCoerce# works on weird kind combinations like that (unlike unsafeCoerce)... but that code is just a joke, blame kmc :P
00:22:19 <nick8325> oh, fair enough, i thought you were just crazy :P
00:23:36 <elliott> nick8325: Crazy for SPEED!
00:23:43 <nick8325> incidentally, i like how unsafeCoerce# nullAddr# :: Any typechecks but let x = unsafeCoerce# in x nullAddr# :: Any doesn't :)
00:24:32 <shachaf> > id runST (return 5)
00:24:33 <lambdabot>   Couldn't match expected type `m t'
00:24:34 <lambdabot>         against inferred type `forall s....
00:24:34 <shachaf> > let x = id runST in x (return 5)
00:24:35 <lambdabot>   5
00:24:42 <shachaf> To be fair, that's a completely different sort of error.
00:24:45 <BlankVerse> how do i download the source from hackage using cabal?
00:24:49 <shachaf> > (id runST) (return 5) -- Also this.
00:24:51 <lambdabot>   5
00:28:50 <nick8325> shachaf: that last example is a bit disturbing...
00:34:39 <elliott> nick8325: Don't worry, it's fixed in GHC 7.
00:41:55 <nick8325> elliott: ah, that's good. i like f x y to be equal to (f x) y :)
00:42:21 <shachaf> GHC 7 fixes it by breaking it more consistently.
00:44:04 <elliott> nick8325: id runST still isn't runST, though.
00:49:38 * Sgeo wants to make a lens like someAttribute :: (HasSomeAttribute a) => Lens a Int
00:49:46 <Sgeo> Is there something similar to this already?
00:50:08 <elliott> class HasSomeAttribute a where someAttribute :: Lens a Int
00:51:17 <Sgeo> That's easier than the rather bizarre scheme I was cooking up in my head, but I think I've seen something similar to what I want (but not with lenses) esewhere
00:54:15 <elliott> Sgeo: It probably isn't a good idea.
00:55:35 <Sgeo> Are there better ideas?
00:56:29 <elliott> Sgeo: It depends on what you're trying to do.
00:56:42 * Sgeo gets an even worse idea
00:56:52 <elliott> It sounds like you're trying to make records not suck without changing the language at all, which is inadvisable, as all these typeclass hacks will be 10x more painful than just using qualified imports.
00:57:50 <Sgeo> I see your point up until "just using qualified imports", because I don't think qualified imports solve my problems. Not sure though.
00:58:10 * Sgeo is not going to think too much deeper about this tonight
00:58:14 <elliott> Well, you haven't said what your problem is yet, so it's not surprising I can't solve it.
00:59:27 <Sgeo> A number of records, some of which should have overlapping attributes, and I want to make functions that can take any of these structures that has the attribute in question.
01:01:31 <elliott> Why not just have the function take the attribute instead?
01:01:49 <elliott> If there's a common subcomponent to the records, factor it out into its own data type. If it's just a single field like an Int, that data type is already factored out, and it's called Int :P
01:03:08 <Sgeo> It would be a pain to do all that factoring out, I think
01:03:13 * Sgeo should think about this more
01:03:33 <elliott> Nothing is more of a pain than hacking around bad architecture with typeclass tricks.
01:11:55 <aadrake> :t head
01:11:56 <lambdabot> forall a. [a] -> a
01:16:45 <aadrake> Is there any advantage to Text over ByteString or vice versa?
01:17:26 <shachaf> aadrake: They're completely different types.
01:17:31 <merijn> Well, bytestrings are just bytes. While Text (presumably) deals with unicode text (Warning: blind guess work)
01:18:33 <shachaf> What merijn said, more or less. Bytes aren't characters.
01:18:40 <Sgeo> If you want to deal with text, use Text, if you want to deal with binary data that is not text, use ByteString
01:20:06 <elliott> ByteString is bytes, Text is Unicode.
01:20:23 <elliott> That wasn't just stereo -- that was quadrophonic!
01:20:51 <merijn> And my streak of answering questions correctly by blind guesswork continues \o/
01:21:03 <aadrake> Well obviously text and bytes are not the same
01:21:27 <elliott> aadrake: Exactly, which is why it's like asking "is [Float] or Tree String better" :)
01:21:28 <aadrake> The question I'm asking is which method has the most efficient representation of a string
01:21:29 <ChristianS> but you can use the Data.ByteString.Char8 module, if your bytestring contains a sequence of ascii or latin1 characters; or Data.ByteString.UTF8, if it contains a equence of utf8 characters
01:21:40 <elliott> Depends what a string is.
01:21:50 <elliott> Is it Unicode text? ASCII text? A sequence of non-textual bytes?
01:21:54 <earthy> aadrake: they both have the most efficient representation... :)
01:21:58 <aadrake> elliott: A string of Unicode or ASCII
01:21:58 <ChristianS> bytestring is more efficient for utf8 encoded text, since Text internally uses utf16
01:22:08 <elliott> ChristianS: Data.ByteString.UTF8 isn't part of the bytestring package, though.
01:22:11 <AfC> Pity Text is done in terms of UTF-16. We went through that in Java crossing the JNI boundary. Lot of unnecessary copying.
01:22:16 <ChristianS> no, utf8-string package
01:22:41 <ChristianS> elliott: but both use the same Bytestring type
01:24:05 <luite> AfC: there is a UTF-8 based implementation
01:24:08 <merijn> AfC: Data.Text is UTF-16?
01:24:26 <merijn> Heresy!
01:24:30 <AfC> merijn: that's what its Haddock says
01:24:49 <elliott> That's probably for the best.
01:24:57 <elliott> text-icu would be pretty slow if it had to convert back and forth.
01:24:58 <luite> I think it was someones GSoC project last year, but UTF-8 was not really better
01:25:16 <elliott> And http://jaspervdj.be/posts/2011-08-19-text-utf8-the-aftermath.html at least implies that UTF-8 is generally not more than a small optimisation even when you're not using something like that.
01:25:48 <luite> thanks that was the one :)
01:25:59 <elliott> aadrake: Anyway, if you're dealing with Unicode, go with Text.
01:26:20 <elliott> aadrake: The interface is rich, it's fast, and you should really profile before deciding to switch to a less appropriate type for performance reasons.
01:26:21 <AfC> I maintain a Java library that talks to native packages all expecting UTF-8. We spend a huge amount of time converting back and forth. Pain in the arse, and there's nothing I can do about it. It's *not* slow it's just expensive in space.
01:26:44 <merijn> luite: It's not that UTF-8 is faster, just that UTF-16 is an abomination with (almost) no redeeming qualities
01:27:07 <merijn> I cannot for the live of me name one advantage to using UTF-16 over UTF-8
01:27:10 <elliott> merijn: So's x86.
01:27:25 <elliott> The advantage of UTF-16 for Text is that e.g. ICU uses UTF-16.
01:27:42 <koala_man> utf-8 was a backwards compatibility hack for ascii. utf-16 was a backwards compatibility hack for UCS-2.
01:27:47 <luite> merijn: fewer branches necessary when decoding
01:28:01 <luite> than UTF-8
01:28:06 <luite> err
01:28:08 <jaspervdj> merijn: UTF-16 is faster for text processing in the general case (less branches)
01:28:10 <luite> than UTF-16
01:28:27 <luite> ah there's the expert himself :)
01:28:29 <jaspervdj> Also, a lot of native libraries use UTF-16
01:28:30 <Sgeo> Wait, it says Text is unboxed?
01:28:33 <kalven> what is the general case?
01:28:53 <jaspervdj> kalven: Russian, Chinese... i.e. not only english
01:29:09 <jaspervdj> (a lot of native libraries use UTF-8 as well, so that's kind of subjective though)
01:29:10 <elliott> Sgeo: Well, it wouldn't be very good if it wasn't...
01:29:11 <merijn> koala_man: Yes, but ASCII backwards compatibility is worth much more.
01:29:29 <elliott> ASCII compat is irrelevant for internal representations, that's an encoding/decoding issue
01:29:58 <aadrake> elliott: The reason I'm changing from String is because of memory usage issues.
01:30:08 <merijn> elliottt: In theory, yes. In practice not really
01:30:17 <elliott> aadrake: Yeah, don't worry. String has massive overhead.
01:30:43 <elliott> aadrake: It uses UCS-4, boxes every single character, and is of course a linked list.
01:30:47 <koala_man> merijn: maybe if your API requires ascii compatibility, like C did. Not so much if your API requires ucs-2 compatibility, like Java and Win32 did.
01:31:28 <jaspervdj> (Cocoa uses UTF-16 as well as far as I know)
01:32:06 <jaspervdj> merijn: UTF-8 is certainly the right choice for storing text on the hard disk
01:32:10 <elliott> aadrake: Nothing will take even remotely as much memory as String :P
01:32:20 <jaspervdj> For the in-memory presentation, it's more subtle
01:32:32 <Sgeo> What's the difference between UCS-4 and UTF-32?
01:32:46 <silver> that might explain why's my parser takes 1 Gb of memory while running >_>
01:33:09 <elliott> Sgeo: Nothing.
01:33:18 <elliott> Oh, hmm.
01:33:29 <elliott> "Because only 17 planes are actually in use, all current code points are between 0 and 0x10FFFF. UTF-32 is a subset of UCS-4 that uses only this range. Since the Principles and Procedures document of JTC1/SC2/WG2 states that all future assignments of characters will be constrained to the BMP or the first 14 supplementary planes, UTF-32 will be able to represent all Unicode characters. Accordingly, UCS-4 and UTF-32 are now identical except that the
01:33:29 <elliott>  UTF-32 standard has additional Unicode semantics.[clarification needed]"
01:33:39 <merijn> Sgeo: UCS-4 doesn't allow for more codepoints than 32bits int can encode
01:34:02 <ChristianS> merijn: neither does UTF-32/unicode
01:34:07 <merijn> Sgeo: If unicode is increased in size it will run into the same problem as UCS-2 where the encoding can no longer encode all unicode
01:34:50 <elliott> I doubt any UTF-32 encoding code supports >32 bits.
01:35:09 <ChristianS> actually, unicode will never have more than 2^21 characters, that's been decided on long ago
01:35:14 <merijn> ChristianS: They claim they will never extend past 32bits, but they also claimed that about 16bit at some point
01:35:15 <elliott> Anyway I don't think merijn is right that UTF-32 has a mechanism for codepoints taking up more than one 4-byte unit.
01:35:19 <elliott> At least the article says nothing of the sort.
01:35:28 <merijn> elliott: No, looks like I'm not
01:36:31 <ChristianS> in practice, UCS-4 is just an old-fashioned name for UTF-32, i guess
01:42:32 <sid> Hi, how can I create a list with an immutable length please?
01:42:42 <shachaf> sid: Every list has an immutable length.
01:42:49 <merijn> sid: All lists have an immutable length
01:42:49 <shachaf> Because all values are immutable.
01:43:26 <sid> So I'd like a tuple of 100 element for example.
01:43:46 <shachaf> You want a list whose length is known at compile-time?
01:43:46 <elliott> Why a tuple rather than a list?
01:43:50 <elliott> > replicate 100 'x'
01:43:52 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
01:44:02 <merijn> sid: No, because lists can only contain one type, whereas tuples can contain different types
01:44:20 <merijn> elliott: I suspect python experience, because python's tuples are essentially immutable lists
01:44:25 <elliott> merijn: Right.
01:45:03 <Sgeo> > replicate 100 5
01:45:04 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
01:45:30 <merijn> > replicate 100 $ replicate 100 x
01:45:31 <lambdabot>   [[x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x...
01:45:58 <sid> Hum, interesting, so I guess a list is what I want, but I want to have a type that says that all my instances have the same length somehow.
01:45:58 <merijn> > fix $ replicate 100
01:45:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
01:46:27 <erus`> merijn: why doesnt it say x is unknown?
01:46:34 <elliott> sid: That doesn't make much sense.
01:46:37 <Veinor> erus`: lambdabot magic
01:46:39 <elliott> Could you clarify what you want?
01:46:39 <merijn> erus`: lambdabot voodoo
01:46:45 <Sgeo> lambdabot defines x
01:46:51 <Sgeo> :t x
01:46:52 <lambdabot> Expr
01:46:59 <elliott> erus`: lambdabot science
01:47:04 <merijn> erus`: Undefined variables are expressions in lambdabot, so you can do this:
01:47:12 <Sgeo> merijn, uh
01:47:12 <erus`> :t doesitworkforanything
01:47:13 <lambdabot> Not in scope: `doesitworkforanything'
01:47:14 <Sgeo> :t asjdfaksjdf
01:47:14 <elliott> merijn: no
01:47:15 <lambdabot> Not in scope: `asjdfaksjdf'
01:47:20 <elliott> it's just a-z
01:47:26 <merijn> elliott: Oh, it's just single chars?
01:47:30 <silver> @info Expr
01:47:30 <lambdabot> Expr
01:47:37 <elliott> merijn: Single lowercase Latin alphabet letters :P
01:47:40 <merijn> > map f [x,y,z]
01:47:41 <lambdabot>   Ambiguous type variable `b' in the constraints:
01:47:42 <lambdabot>    `GHC.Show.Show b'
01:47:42 <lambdabot>      a...
01:47:53 <Sgeo> > f x
01:47:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:47:54 <lambdabot>    `GHC.Show.Show a'
01:47:54 <lambdabot>      a...
01:47:57 <merijn> hmm
01:48:00 <Sgeo> Used to work
01:48:06 <sid> Say I want to represent a chess board in haskell, 8x8, I want to trigger an error if a player tries to access the 9th case, I have to manually check that the index of the case is less than 9 ?
01:48:06 <Sgeo> > foldr f z [a, b, c]
01:48:07 <lambdabot>   f a (f b (f c z))
01:48:10 <Sgeo> > f a
01:48:11 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:48:11 <lambdabot>    `GHC.Show.Show a'
01:48:11 <lambdabot>      a...
01:48:18 <elliott> > f a :: Expr
01:48:19 <lambdabot>   f a
01:48:26 <elliott> sid: It depends.
01:48:31 <elliott> sid: What representation are you using?
01:48:41 <elliott> sid: I mean, list accessing functions, etc. already check indices for you.
01:48:55 <Sgeo> Not nicely
01:49:06 <merijn> sid: You can define a new data type and not export it's constructors. That way people can only access the board through your exported functions which can check the indexes for you
01:49:13 <elliott> sid: BTW, "instances" means something else in Haskell; you probably mean "value".
01:49:26 <elliott> sid: Anyway, it sounds like you want vectors whose length is checked by the type system.
01:49:35 <elliott> That's not really feasible in Haskell, but I suggest doing what merijn said.
01:49:41 <elliott> newtype Board = Board [[Piece]]
01:49:49 <merijn> elliottt: It will be when we get type level naturals \o/
01:49:54 <elliott> emptyBoard = Board ...initial configuration...
01:50:22 <elliott> merijn: I doubt it. There's nothing stopping you doing those today, after all, it's just uglier; Haskell's type system is a bit too weak to make type-encoded vectors pleasant.
01:50:52 <sid> Ok thanks for that guys.
01:51:05 <merijn> elliott: Well, with compiler support for type level naturals it becomes significantly easier
01:51:41 <merijn> elliott: Otherwise you have to implement them using Peano numbers and code your own functions to convert to and from values from there
01:51:48 <elliott> merijn: Does it? I can't see how much it changes beyond nicer syntax. I guess equality might be a bit easier to get working in tricky cases.
01:52:09 <elliott> Well, yes, but that's not the problem; people have done length-encoded vectors like that a million times, they're awkward to use for other reasons :)
01:57:29 <erus`> is there a better name for a right angle triangle?
01:58:27 <elliott> riangle
01:58:43 <int-e> right triangle
02:01:28 <erus`> things allways seem so simple in my head. Then i go to implement it and im writing hundreds of lines of code with tens of custom types
02:01:39 <erus`> god damn UV unwrapping
02:03:15 <frerich> I actually often experience it the other way round. Something seems fairly complex and contrived to me in the beginning, but once I see the final program I'm amazed how short it is.
02:55:15 * hackagebot conduit 0.0.3 - A pull-based approach to streaming data.  http://hackage.haskell.org/package/conduit-0.0.3 (MichaelSnoyman)
02:55:17 * hackagebot hxt 9.1.6 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.1.6 (UweSchmidt)
02:55:19 * hackagebot hxt-cache 9.0.2 - Cache for HXT XML Documents and other binary data  http://hackage.haskell.org/package/hxt-cache-9.0.2 (UweSchmidt)
02:55:21 * hackagebot hxt-charproperties 9.1.1 - Character properties and classes for XML and Unicode  http://hackage.haskell.org/package/hxt-charproperties-9.1.1 (UweSchmidt)
02:55:23 * hackagebot hxt-curl 9.1.1 - LibCurl interface for HXT  http://hackage.haskell.org/package/hxt-curl-9.1.1 (UweSchmidt)
02:58:52 <Veinor> how to annoy the hell out of c programmers reading your code, part 1:
02:58:59 <Veinor> define (/*) and (*/) operators
03:00:00 <ion> hah
03:00:20 <ion> and //
03:00:23 <merijn> Veinor: :D
03:00:25 * hackagebot hxt-expat 9.1.1 - Expat parser for HXT  http://hackage.haskell.org/package/hxt-expat-9.1.1 (UweSchmidt)
03:00:27 * hackagebot hxt-http 9.1.3 - Interface to native Haskell HTTP package HTTP  http://hackage.haskell.org/package/hxt-http-9.1.3 (UweSchmidt)
03:00:29 * hackagebot hxt-regex-xmlschema 9.0.4 - A regular expression library for W3C XML Schema regular expressions  http://hackage.haskell.org/package/hxt-regex-xmlschema-9.0.4 (UweSchmidt)
03:00:31 * hackagebot hxt-relaxng 9.1.4 - The HXT RelaxNG validator  http://hackage.haskell.org/package/hxt-relaxng-9.1.4 (UweSchmidt)
03:00:33 * hackagebot hxt-tagsoup 9.1.1 - TagSoup parser for HXT  http://hackage.haskell.org/package/hxt-tagsoup-9.1.1 (UweSchmidt)
03:00:35 <Veinor> and (#) for shell-y languages!
03:01:30 <elliott> don't be silly, # is reserved for making code go faster
03:01:51 <Veinor> no, in my experience hash makes things go slower
03:05:35 * hackagebot hxt-unicode 9.0.2 - Unicode en-/decoding functions for utf8, iso-latin-* and other encodings  http://hackage.haskell.org/package/hxt-unicode-9.0.2 (UweSchmidt)
03:05:37 * hackagebot hxt-xpath 9.1.2 - The XPath modules for HXT.  http://hackage.haskell.org/package/hxt-xpath-9.1.2 (UweSchmidt)
03:05:39 * hackagebot hxt-xslt 9.1.1 - The XSLT modules for HXT.  http://hackage.haskell.org/package/hxt-xslt-9.1.1 (UweSchmidt)
03:06:35 <Jafet> elliott smokes the magic hash
03:14:52 <kqr> what's the difference between int and integer?
03:15:04 <Veinor> Integer is unbounded range, Int is bounded
03:15:10 <kqr> right thanks
03:15:29 <ion> Int should not be in Prelude at all. You’ll almost certainly want to use Integer.
03:15:39 <kqr> yeah, i do
03:21:19 <elliott> ion: Not really, unless you want to be writing fromIntegral everywhere when interacting with Prelude functions.
03:21:48 <elliott> I mean, there's no point using Integer for a temporary value you compute just to pass to take or replicate or whatever, for example.
03:22:33 <ion> elliott: Thus the word “almost”. :-)
03:22:48 <elliott> Fair enough.
03:55:33 <erus`> i have two points and the distance between these and a 3rd point. how do i solve pt 3?
03:56:03 <Entroacceptor> learn the proper #math? ;P
03:56:09 <erus`> hohoho
03:56:37 <ion> 2D? It could be in two places. Do you want both? 3D? It could be in an infinite number of places along a circle.
03:56:51 <erus`> I only need 2d
03:57:04 <erus`> oh my first 2 points are on y 0
03:57:10 <Entroacceptor> well, do you know how distance is calculated?
03:57:39 <erus`> pythagorus
03:58:35 * Martty senses trouble
03:59:01 <erus`> hang on  p0 is at 0,0    p1 is at l01, 0
03:59:07 <erus`> i have l01
03:59:25 <erus`> and finaly i have l02 and l12
03:59:38 <erus`> how to solve p2 :|
04:00:05 <Entroacceptor> let's say the known points are A=(xa,ya), B=(xb,yb) and X(x,y)
04:00:35 <Entroacceptor> d(A,X) = sqrt( ( x-xa)^2 + (y-ya)^2 )
04:00:48 <Entroacceptor> d(B,X) analogous
04:01:08 * Sgeo quickly jots down some thoughts
04:01:18 <Entroacceptor> so you have two equations with two unknown variables
04:01:23 <Entroacceptor> just solve that
04:01:27 <Sgeo> Would it be easier to just describe it as the intersection of two circles?
04:01:40 <erus`> yes i guess
04:03:16 <Sgeo> Uh
04:07:57 <Entroacceptor> erus`: got the solution?
04:08:07 <erus`> not yet
04:18:57 <BleuM937> Good evening everybody
04:19:45 <BleuM937> Quick question: what's 'standard' Haskell Date type?
04:21:50 <quicksilver> BleuM937: UTCTime
04:21:54 <quicksilver> from Data.Time
04:23:00 <aadrake> Okay, I did my profiling and it seems that most of the memory usage is coming from type [].  Is there something more efficient I can use or does that mean that an algorithm change is in order?
04:27:36 <BleuM937> Hmm
04:29:45 <BleuM937> so times are constructed using, for example: UTCTime $ fromGregorian 2012 1 1 $ TimeOfDay 0 0 1
04:30:31 <BleuM937> @quicksilver, is there any shorter way to construct a date? That seems pretty awkward.
04:30:31 <lambdabot> Unknown command, try @list
04:31:47 <int-e> aadrake: there is no easy answer to that question. what are you storing in those lists? if it's text (String = [Char]), using Data.Text or Data.ByteString instead may be better. It's also possible that your code is not lazy enough somewhere. It really depends on what you're doing.
04:32:52 <quicksilver> BleuM937: well you can write a function :) but there is parseTime
04:33:18 <quicksilver> BleuM937: http://www.haskell.org/ghc/docs/7.0.2/html/libraries/time-1.2.0.3/Data-Time-Format.html
04:33:32 <aadrake> int-e: I'm already using Data.Text for storage
04:34:07 <aadrake> int-e: I have this count function that I think is causing the problem due to non-strictness: count = map (\n -> (length n, head n)) . group . sort
04:34:33 <aadrake> int-e: I'm relatively new to Haskell so I'm not sure if I can refactor that to a strict fold or if such a thing is even possible
04:36:03 <aadrake> int-e: That function is just counting the occurences of a string in a list of strings and aggregating the results as a tuple of length and key name
04:36:07 <Sgeo> :t map (\n -> (length n, head n)) . group . sort
04:36:08 <lambdabot> forall a. (Ord a) => [a] -> [(Int, a)]
04:36:43 <Sgeo> > map (\n -> (length n, head n)) . group . sort $ []
04:36:44 <lambdabot>   []
04:36:48 <Sgeo> > map (\n -> (length n, head n)) . group . sort $ [1]
04:36:50 <lambdabot>   [(1,1)]
04:37:01 <int-e> > map (\n -> (length n, head n)) . group . sort $ "abracadabra"
04:37:02 <lambdabot>   [(5,'a'),(2,'b'),(1,'c'),(1,'d'),(2,'r')]
04:37:17 <Sgeo> I may be too paranoid about that head
04:37:28 <int-e> the head there is completely safe
04:37:33 <cheater_> heads generally make me paranoid
04:39:10 <aadrake> Sgeo: It runs just fine with a list of strings less than 10,000 elements or so.  After that it chokes.  :)
04:39:45 <donri> > map (length &&& head) . group . sort $ "abracadabra"
04:39:47 <lambdabot>   [(5,'a'),(2,'b'),(1,'c'),(1,'d'),(2,'r')]
04:39:52 <int-e> aadrake: hmm. sorting a large list will allocate a lot of intermediate list nodes ... its residency should not be too bad compared to the list alone though.
04:40:06 <cheater_> @t &&&
04:40:07 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:40:13 <cheater_> @type &&&
04:40:14 <lambdabot> parse error on input `&&&'
04:40:18 <donri> :t (&&&)
04:40:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:40:19 <cheater_> @type (&&&)
04:40:20 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:40:24 <cheater_> yeah. thanks.
04:40:45 <Sgeo> :t (***)
04:40:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:41:10 <cheater_> nice i like that
04:42:01 <aadrake> Where does &&& live
04:42:08 <aadrake> Is it part of some library?
04:42:08 <donri> :info (&&&)
04:42:20 <donri> Control.Arrow methinks
04:42:26 <ion> @type (&&&) `asAppliedTo` (undefined :: a -> b)
04:42:26 <donri> @hoogle (&&&)
04:42:26 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
04:42:27 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
04:42:56 <ion> @type (***) `asAppliedTo` (undefined :: a -> b)
04:42:57 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
04:42:59 <donri> which in turn is in the base package
04:43:39 <aadrake> Strange.  I get a "not in scope" message when I try to compile.
04:43:57 <donri> did you import Control.Arrow
04:43:59 <Sgeo> What's not in scope?
04:44:11 <aadrake> I added the import and it works fine
04:44:24 <donri> lambdabot has lots of shit loaded that's not in prelude
04:44:25 <aadrake> I thought you meant it was part of the base package so didn't require an import
04:44:36 <donri> no i meant http://hackage.haskell.org/package/base :)
04:44:49 <ion> Prelude is only a subset of base.
04:45:11 <rtharper_> kosmikus: ping? =)
04:45:54 <aadrake> Well the memory usage by type graph from the profiler still looks like the usage is huge
04:48:20 <aadrake> The usage over time isn't the same, there's a much sharper point at the top, but I will need to refactor that count function
04:50:12 <kosmikus> rtharper_: pong
04:50:19 <ion> > foldr (\x -> Map.insertWith' (+) x 1) Map.empty "abracadabra"
04:50:20 <lambdabot>   Not in scope: `Map.insertWith''Not in scope: `Map.empty'
04:50:26 <ion> > foldr (\x -> M.insertWith' (+) x 1) M.empty "abracadabra"
04:50:27 <lambdabot>   fromList [('a',5),('b',2),('c',1),('d',1),('r',2)]
04:51:50 <aadrake> ion: Interesting
04:53:51 <aadrake> ion: I'm guessing that is in Data.Map?
04:55:16 <ion> Actually, foldl' is the right fold here.
04:55:27 <ion> > foldl' (\acc x -> M.insertWith (+) x 1 acc) M.empty "abracadabra"
04:55:28 <lambdabot>   fromList [('a',5),('b',2),('c',1),('d',1),('r',2)]
04:55:32 <ion> aadrake: Yeah
04:55:49 <ion> (See what i did there?)
04:56:43 <danr> How do I install cabal-install if I have base-4.4? Dependencies as well as cabal-install complains on a too high base version number
04:56:55 <danr> Is there a darcs version for this maybe?
04:57:07 <aadrake> ion: I am trying to figure it out.  The concept of strict folding from the left is fine but I'm not well-versed on the lambdas (I think that's what they're called) yet.
04:58:03 <ion> > let f acc x = M.insertWith (+) x 1 acc in foldl' f M.empty "abracadabra"
04:58:05 <lambdabot>   fromList [('a',5),('b',2),('c',1),('d',1),('r',2)]
04:58:16 <ion> The same thing with a named function instead of a lambda expression.
04:58:30 <Botje> aadrake: a lambda is an anonymous function
04:58:41 <Botje> that's .. about it :)
05:00:33 <aadrake> ion: not in scope: foldl'
05:00:39 <ion> Hoogle
05:00:43 <ion> @hoogle foldl'
05:00:43 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
05:00:43 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
05:00:43 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
05:00:44 <aadrake> Shouldn't foldl and foldl' always be in scope?
05:00:48 <aadrake> Ah
05:00:57 <silver> foldl' no
05:00:59 <aadrake> I keep thinking things are in the Prelude when they aren't
05:05:57 <erus`> > 2 ^ 2
05:05:58 <lambdabot>   4
05:06:02 <erus`> > 2 ^ 8
05:06:03 <lambdabot>   256
05:13:37 <hpaste_> gregATio pasted “asInt” at http://hpaste.org/56371
05:13:42 <aadrake> ion: That reduced the memory usage some, but it's still over 600mb or so
05:13:48 <aadrake> Down from about 850 :)
05:14:15 <gregATio> just a quick question has anyone any ideas how i can improve the code i pasted
05:14:35 <gregATio> so that i can do string to int conversion
05:14:51 <gregATio> this is an exercise so i am not supposed to use standard library conversion
05:15:02 <gregATio> http://hpaste.org/56371
05:15:19 <quicksilver> that is a very reasonable way to do it, gregATio
05:15:31 <quicksilver> although it doesn't check if the input is a valid number
05:15:36 <quicksilver> > digitToInt 'c'
05:15:37 <lambdabot>   12
05:15:41 <gregATio> ooooh thanks
05:15:53 <quicksilver> might give suprising results if you try "-beef" say
05:15:54 <gregATio> its just an exercise from the book
05:16:02 <gregATio> deadbeef
05:16:04 <gregATio> lol
05:16:06 <quicksilver> quite
05:16:17 <quicksilver> also, you could use a strict foldl for that - foldl'
05:16:21 <quicksilver> but, its' the right approach anyway
05:16:30 <gregATio> thanks thats awesome
05:16:54 <gregATio> i felt it was a little verbose to have to define the whole method again for the minus sign
05:17:40 <gregATio> bbl meeting
05:17:49 <Botje> you could do -1 * step a x
05:19:13 <gregATio> elaborate please Botje
05:19:41 <gregATio> ah i see
05:20:10 <gregATio> but not sure how to form it
05:20:24 <gregATio> because i would still need two where clauses
05:21:01 <hpaste_> cheater pasted “make pairs” at http://hpaste.org/56372
05:21:08 <cheater_> hi
05:21:22 <cheater_> i have a problem, it's probably simple but i don't see how to do it
05:21:28 <danr> cheater_: shoot!
05:21:38 <cheater_> i have this code (i pasted an excerpt above)
05:21:47 <cheater_> in there i have branchResults <- mapM blah blah
05:21:49 <Botje> gregATio: hmm true. boo :(
05:22:46 <cheater_> it returns [[[String]]]: a list, each sublist is defined by a subdir, each sublist of that is defined by a "metric" (an element of a list of strings), each element of that is defined by a file in each subdir
05:23:10 <cheater_> i would now like to have something like this: [[(String, [String])]]
05:23:55 <cheater_> where the first element of the pair is the name of the metric, and the second element of the pair is the same as the innermost stuff in the old version
05:25:36 <hpaste_> cheater annotated “make pairs” with “make pairs (annotation)” at http://hpaste.org/56372#a56373
05:25:48 <cheater_> sorry the previous one had a typo or something
05:26:11 <cheater_> anyways, i know i can do this by making getBranchResultsForMetric return (metic, branchResults) instead of just branchResults
05:26:18 <erus`> >tan 90
05:26:24 <erus`> > tan 90
05:26:25 <lambdabot>   -1.995200412208242
05:26:33 <Sgeo> > tan pi
05:26:33 <erus`> > tan (pi)
05:26:34 <lambdabot>   -1.2246467991473532e-16
05:26:34 <lambdabot>   can't find file: L.hs
05:26:45 <cheater_> but i'm not happy with that, i would like this to just return branchResults and i would like to wrap that into a pair in getBranchResults. how would i do that?
05:27:01 <Sgeo> > tan (pi/2)
05:27:02 <lambdabot>   1.633123935319537e16
05:27:08 <cheater_> so what can i do?
05:27:14 <erus`> wtf
05:27:32 <erus`> rounding error?
05:27:52 <Sgeo> > tan (pi)
05:27:53 <lambdabot>   -1.2246467991473532e-16
05:27:57 <Sgeo> > tan pi
05:27:58 <lambdabot>   -1.2246467991473532e-16
05:28:07 <Sgeo> Hmm, why did it say can't find file?
05:28:09 <Sgeo> Race condition?
05:31:13 <cristaloleg> hi
05:34:35 <Sgeo> Will decodeFloat help me understand CFloats?
05:35:01 <cheater_> hey guys what is the opposite of return? ...
05:35:31 <cheater_> i want something like <-
05:35:33 <int-e> > 1 / (tan(9*pi/2) / tan(pi/2))
05:35:34 <lambdabot>   9.0
05:36:35 <ion> cheater: extract from Control.Comonad
05:36:45 <cheater_> oh i did it without
05:36:51 <cheater_> i just used a lot of lambdas and >>=
05:37:07 <cheater_>   mapM (\metric -> ((getBranchResultsForMetric metric dir) >>= \x -> return (metric, x))) metrics
05:37:58 <cheater_> does that simplify in any way?
05:38:15 <ion> \metric -> (metric,) <$> getBranchResultsForMetric metric dir
05:38:58 <cheater_> @type (<$>)
05:38:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:39:13 <cheater_> i don't know about functors D:
05:39:39 <ion> @where typeclassopedia
05:39:40 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:39:47 <Sgeo> words <$> getLine is do { line <- getLine; return (words line) }
05:40:02 <cheater_> nice, Sgeo
05:40:05 <cheater_> let me ponder that for a sec
05:40:22 <cheater_> the problem is i hadn't slept well today so any learning process is more difficult :S
05:41:04 <cheater_> > (2,) 3
05:41:05 <lambdabot>   Illegal tuple section: use -XTupleSections
05:41:08 <cheater_> huh
05:41:24 <cheater_> how does that (metric,) stuff work?
05:41:36 <Sgeo> cheater, with a language extention called TupleSections
05:41:39 <Sgeo> *extension
05:41:49 <int-e> without the extension, write  (,) metric
05:42:35 <cheater_> alright, i thought that requirement for an extension came from me using the syntax in an incorrect way
05:43:11 <cheater_> so without the extension i'd do something like this? \metric -> (\x -> (metric, x)) <$> getBranchResultsForMetric metric dir
05:44:11 <Saizan> ((,) metric)
05:44:12 * Sgeo only recently learned that it's possible to enable language extensions while inside GHCi
05:45:05 <cheater_> @hoogle (<$>)
05:45:05 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
05:45:05 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
05:45:13 <cheater_> which one do i choose ?
05:45:42 <Sgeo> They're the same, but Control.Applicative is more useful because it has <*>
05:46:15 <Sgeo> :t (<*>)
05:46:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:46:27 <Sgeo> (++) <$> getLine <*> getLine
05:46:41 <int-e> :t mapM ((fmap . (,)) <*> (flip ?getBranchResultsForMetric ?dir))
05:46:42 <lambdabot> forall a (m :: * -> *) a1 a2. (Functor m, ?getBranchResultsForMetric::a1 -> a2 -> m a, ?dir::a2, Monad m) => [a1] -> m [(a1, a)]
05:46:43 <Sgeo> Takes two lines from stdin and appends the first to the second
05:47:06 <Sgeo> Does GHCi support that ? trick?
05:47:19 <int-e> :set -XImplicitParams
05:47:30 <Sgeo> cool, ty
05:47:41 <cheater_> thanks Sgeo
05:49:20 <Sgeo> Prelude Control.Applicative> (++) <$> getLine <*> getLine
05:49:20 <Sgeo> asohfus
05:49:20 <Sgeo> wuehtiuer
05:49:20 <Sgeo> "asohfuswuehtiuer"
05:49:45 <cheater_> nice. what if you want to keep the newline?
05:50:47 <int-e> (\a b -> unlines [a, b]) <$> getLine <*> getLine
05:50:53 <Sgeo> Tell you what, why don't you try to work it out for yourself? (I have to be honest, the only thing that comes to my mind quickly is using a lambda)....
05:51:02 <Sgeo> Oh
05:51:20 <byorgey> unlines <$> replicateM 2 getLine
05:51:42 <int-e> right, that's better
05:51:56 <int-e> @pl (\a b -> unlines [a, b])
05:51:57 <lambdabot> (unlines .) . (. return) . (:)
05:52:15 * Sgeo was just thinking of a lambda with a ++ "\n" ++
05:52:15 <Sgeo> :/
05:52:25 <cheater_> :t replicateM 2
05:52:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
05:52:30 <byorgey> there are many ways to skin a cat.
05:52:41 <byorgey> although some are bloodier than others.
05:52:42 <int-e> (I'd prefer  return --> (:[])  in that pointfree version :) )
05:52:45 <cheater_> Sgeo: still better than what i would've come up with
05:53:01 <cheater_> int-e: because you prefer robot monkeys to marvin the martian?
05:54:01 <Sgeo> I'd prefer to walk away screaming from the pointfree version
05:54:11 <Sgeo> Although it would be nice if I had some intuition about it
05:55:42 <byorgey> developing intuition about convoluted pointfree expressions would waste too much of your brain
05:55:48 <int-e> Sgeo: that's a perfectly reasonable attitude. I typically stop making code pointfree when I have to use sections of (.). Except on #haskell.
05:56:18 <Sgeo> :t (. id)
05:56:19 <lambdabot> forall a b. (a -> b) -> a -> b
05:56:34 <Sgeo> :t (id .)
05:56:35 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
05:56:47 <Sgeo> Thank you Caleskell
05:56:56 <byorgey> :t (id Prelude..)
05:56:57 <lambdabot> forall b a. (a -> b) -> a -> b
05:57:01 <int-e> :t (.) (.) (.) (.)
05:57:02 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
05:57:25 <int-e> ... at some point those types run into a loop :)
05:57:40 <cheater_> they do/
05:57:42 <cheater_> how so?
05:57:51 <Jafet> @quote Jafet succ
05:57:52 <lambdabot> Jafet says: > (.)(.) id const succ 5$ 0xb00b135
05:57:58 <Sgeo> :t (Prelude..) (Prelude..) (Prelude..) (Prelude..)
05:57:59 <lambdabot> forall a a1 b c a2. (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> b) -> a2 -> c
05:58:16 <cheater_> :t (Prelude..)
05:58:17 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:58:35 <Sgeo> Prelude.. is just . from Prelude
05:58:35 <hpc> > (.)(.) id const succ 5$ 0xb00b135
05:58:35 <Saizan> > (.)(.) id const succ 5$ 0xb00b135
05:58:36 <lambdabot>   can't find file: L.hs
05:58:37 <lambdabot>   6
05:58:39 <cheater_> @pl (Prelude..)
05:58:39 <lambdabot> Prelude..
05:58:45 <cheater_> hm.
05:59:26 <Sgeo> http://learnyouahaskell.com/higher-order-functions#composition
06:00:16 * hackagebot compdata 0.5.1 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.5.1 (PatrickBahr)
06:08:23 <int-e> cheater_: I guess the easiest explanation is that by equational reasoning, you can prove that (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.) = (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
06:11:02 <int-e> well "equational reasoning". I really mean reduction to normal form with the rule (.) f g x = f (g x)
06:16:01 <int-e> and I have a (.) too many on the right-hand side.
06:17:57 <int-e> :t ((.)`asTypeOf`?f)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
06:17:58 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (?f::(((((((a -> b) -> f1 (f2 a) -> f1 (f2 b)) -> (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))) -> (((a -> b) -> f2 a -> f2 b) -> (a -> b) -> f1
06:17:59 <lambdabot> (f2 a) -> f1 (f2 b)) -> ((a -> b) -> f2 a -> f2 b) -> (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))) -> (((a -> b) -> f1 (f2 a) -> f1 (f2 b)) -> (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))) -> (((f2 a ->
06:17:59 <lambdabot>  f2 b) -> f1 (f2 a) -> f1 (f2 b)) -> ((a -> b) -> f2 a -> f2 b) -> (a -> b) -> f1 (f2 a) -> f1 (f2 b)) -> ((f2 a -> f2 b) -> f1 (f2 a) -> f1 (f2 b)) -> ((a -> b) -> f2 a -> f2 b) -> (a -> b) -> f (
06:17:59 <lambdabot> f1 (f2 a)) -> f (f1 (f2 b))) -> ((((a -> b) -> f1 (f2 a) -> f1 (f2 b)) -> (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))) -> (((a -> b) -> f2 a -> f2 b) -> (a -> b) -> f1 (f2 a) -> f1 (f2 b)) -> ((a ->
06:17:59 <lambdabot> b) -> f2 a -> f2 b) -> (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))) -> (((f1 (f2 a) -> f1 (f2 b)) -> f (f1 (f2 a)) -> f (f1 (f2 b))) -> ((a -> b) -> f1 (f2 a) -> f1 (f2 b)) -> (a -> b) -> f (f1 (f2 a)
06:18:00 <lambdabot> [37 @more lines]
06:18:14 <ion> :-D
06:18:36 <tromp> stop torturing lambdabot!
06:19:18 <int-e> you're right. should be torturing ghci instead :)
06:24:01 <cheater_> hey guys i'm trying to use ShQQ and am having problems
06:24:14 <cheater_> i have a function such as foo x = x
06:24:32 <cheater_> i replaced that with foo x = [sh| echo $x |]
06:24:40 <cheater_> and am getting type errors D:
06:25:14 <cheater_> hmm, right
06:25:24 <cheater_> the first one is a -> a and the second one is a -> IO String
06:25:27 <hpaste_> int-e pasted “(.)(.)(.)... cycle demonstration by rewriting” at http://hpaste.org/56374
06:26:27 <cheater_> oo i figured it out on my own
06:26:30 * cheater_ is so proud.
06:28:54 * byorgey presents cheater_ with a wodden plaque on which is inscribed a golden lambda and the motto "Ego ex me ipso figuratur"
06:29:21 <byorgey> on a totally unrelated topic, did you know Google Translate can do Latin?
06:30:21 <funktronic> bribing someone on the google translate team will do the trick
06:30:25 <cheater_> uh i don't want to untranslate your googlatin
06:30:36 <byorgey> hehe
06:30:40 <cheater_> i bet it'll reduce into something that has to do with cakes or puddings
06:30:43 <byorgey> it's supposed to mean "I figured it out myself"
06:30:48 <cheater_> lol
06:35:53 <cheater_> hey guys what's the type for decimal fractions?
06:36:11 <earthy> what do you mean by decimal fractions?
06:36:15 <earthy> there's Data.Rational
06:36:19 <cheater_> let me try that
06:36:42 <earthy> but there is afaik no direct analog to C#'s decimal type
06:37:02 <cheater_> i have no idea what that is
06:37:14 <yitz> earthy: not Data.Fixed ?
06:37:25 <cheater_> how do i use Data.Rational? i tried importing Data and it didn't work.
06:37:33 <yitz> cheater_: Data.Ratio
06:37:37 <clsmith> hey all. i'm using ghci, and when i run 'ghci foo.hs', the prompt now looks like "Prelude Main>" (note no asterisk), and no symbols from Main appear to be in scope. am i doing something wrong? :/
06:37:53 <quicksilver> rm foo.o first
06:37:54 <cheater_> yitz: i still don't know how to use it.
06:38:01 <quicksilver> it uses compiled code by preference
06:38:05 <cheater_> clsmith: module Main where
06:38:11 <clsmith> quicksilver: ah :/
06:38:11 <yitz> cheater_: then just use Rational. or use % as the fraction constructor.
06:38:14 <quicksilver> or, just 'touch foo.hs' so it's newer than the .o
06:38:27 <cheater_> yitz: how would i use Rational?
06:38:34 <yitz> > 2 % 3 + 25
06:38:35 <lambdabot>   77 % 3
06:38:35 <clsmith> that works. thanks all.
06:38:53 <clsmith> i thought i was going crazy :p
06:39:27 <yitz> > 42 :: Rational
06:39:28 <lambdabot>   42 % 1
06:39:34 <cheater_> i get strings such as "12.345" and want to calculate on them (addition, division) with best precision. what do?
06:39:37 <quicksilver> > 2/3 + 25 :: Rational
06:39:38 <lambdabot>   77 % 3
06:39:42 <vitalisco> do you guys think that Haskell with be another produtive language like used in a lot of companys or it will be more research than anything?
06:39:47 <cheater_> maybe i should just use floats
06:39:47 <yitz> > 12.345 :: Rational
06:39:48 <lambdabot>   2469 % 200
06:39:51 <quicksilver> > 12.345 :: Rational
06:39:52 <lambdabot>   2469 % 200
06:40:02 <earthy> yitz: no, data.fixed is not a direct analog to C#'s decimal
06:40:02 <cheater_> > read "1.4" :: Rational
06:40:03 <lambdabot>   *Exception: Prelude.read: no parse
06:40:07 <cheater_> why do i get no parse?
06:40:27 <yitz> earthy: ok. not familiar with that c# type. what does it do then?
06:40:34 <quicksilver> because that's not Rational's show/read representation.
06:40:36 <quicksilver> this is a wart.
06:40:50 <donri> > read "7 % 5" :: Rational
06:40:51 <lambdabot>   7 % 5
06:40:59 <cheater_> @hoogle (%)
06:40:59 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
06:41:07 <cheater_> wait why does ghci say % is not in scope
06:41:11 <cheater_> how on earth do i get it
06:41:17 <cheater_> confuuuused
06:41:20 <yitz> cheater_: it's in Data.Ratio
06:41:25 <cheater_> thanks
06:41:59 <quicksilver> % has no real purpose though
06:42:05 <quicksilver> it's only a restricted version of /
06:42:11 <quicksilver> I just use / with Rational
06:42:15 <earthy> yitz: from the language spec: ' A decimal is represented as a 96-bit integer scaled by a power of ten '
06:42:51 <earthy> (it's a 128 bit representation)
06:42:55 <yitz> quicksilver: sometimes less polymorphic functions are useful to avoid the need for type annotations.
06:43:05 <cheater_> how would i later get a decimal representation of a Rational?
06:43:27 <yitz> earthy: oh you can get one of those from Data.Fixed then.
06:43:33 <erus`> > tan (pi/2)
06:43:34 <lambdabot>   1.633123935319537e16
06:43:41 <earthy> yitz: I don't see that from the docs
06:43:47 <erus`> i thought tan was -1 to 1
06:44:01 <cheater_> @hoogle Rational -> Float
06:44:01 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
06:44:02 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
06:44:02 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
06:44:23 <cheater_> aaah cool
06:44:25 <cheater_> thanks guys
06:44:29 <earthy> decimal is a sort of a floating point type
06:44:58 <earthy> 96 bit base number, 28 bit scale, sign bit.
06:45:25 <earthy> with a guaranteed precision of at least 28 digits after the decimal point
06:48:00 <earthy> ah. you could come close using  data E28 = E28 ; instance HasResolution E28 where resolution _ = 1000000000000000000000000000
06:48:18 <mm_freak> erus`: tan represents the intersection of the straight line that passes through the origin and the given point on the unit circle with either the straight line x = -1 or x = 1
06:48:20 <yitz> earthy: right.
06:48:24 <mm_freak> so obviously it is not between -1 and 1
06:48:58 <earthy> but you'd get different rounding behaviour.
06:49:47 <mm_freak> in fact, tan (pi/2) and tan (3*pi/4) are positive infinity and negative infinity respectively
06:50:06 <mm_freak> although haskell's pi seems not to be precise enough
06:50:57 <mm_freak> ok, it's not pi's fault
06:51:01 <mm_freak> > tan (asin 1)
06:51:02 <lambdabot>   1.633123935319537e16
06:54:46 <Sgeo> What happens with an exact real library?
06:55:15 <mm_freak> > tan (pi/2 :: CReal)
06:55:18 <lambdabot>   mueval-core: Time limit exceeded
06:55:23 <mm_freak> that =)
06:55:58 <mm_freak> > tan (pi/4 :: CReal)
06:55:59 <lambdabot>   1.0
06:56:06 <mm_freak> yeah, seems to go into a loop
06:56:11 <mm_freak> > tan (3*pi/2 :: CReal)
06:56:15 <lambdabot>   mueval-core: Time limit exceeded
06:56:22 <mm_freak> > tan (asin 1 :: CReal)
06:56:26 <lambdabot>   mueval-core: Time limit exceeded
06:56:29 <Sgeo> Uh
06:56:37 <Sgeo> CReal is not what I meant by exact real, I think
06:56:49 <mm_freak> CReal is exact, isn't it?
06:57:16 <Sgeo> > sin ((2*pi)^10000000000)
06:57:17 <lambdabot>   NaN
06:57:20 <Sgeo> erm
06:57:26 <Sgeo> whoops
06:57:30 <Sgeo> > sin ((2*pi)*10000000000)
06:57:31 <lambdabot>   -4.478725523900617e-6
06:57:33 <hpc> mm_freak: indeed; it is an exact representation of the computable reals
06:57:43 <Sgeo> > sin (2 * pi)
06:57:44 <lambdabot>   -2.4492935982947064e-16
06:57:44 <Sgeo> oh
06:57:49 <Sgeo> > sin ((2*pi)*10000000000 :: CReal)
06:57:50 <lambdabot>   0.0
06:57:58 <Sgeo> > sin ((2*pi)*1000000000000000000000 :: CReal)
06:57:59 <lambdabot>   0.0
06:58:01 <mm_freak> > sin (2^1024 * pi)
06:58:02 <lambdabot>   NaN
06:58:05 <mm_freak> > sin (2^1024 * pi) :: CReal
06:58:06 <lambdabot>   0.0
06:58:14 <quicksilver> of course really that is only calculating to 50 places
06:58:23 <quicksilver> it would take infinite time to check it was really 0
06:58:58 <Sgeo> I thought CReal was a C's real type... C doesn't have a real type, does it?
06:59:01 <hpc> > sin (2^1024 * pi) == (0 :: CReal)
06:59:02 <lambdabot>   True
06:59:16 <mm_freak> quicksilver: but whatever it outputs as the first 50 digits is exact, right?
06:59:35 <mm_freak> Sgeo: CDouble, CFloat
06:59:37 <Sgeo> > tan (pi/4 :: CReal)
06:59:38 <lambdabot>   1.0
06:59:40 <quicksilver> yes, they are the correct first 50 digits
06:59:42 <Sgeo> > tan (pi/2 :: CReal)
06:59:42 <mm_freak> Sgeo: CReal is not related to C
06:59:46 <lambdabot>   mueval-core: Time limit exceeded
06:59:50 <Sgeo> mm_freak, ah, ok
06:59:52 <hpc> :t showDigits
06:59:53 <lambdabot> Not in scope: `showDigits'
07:00:00 <hpc> @hoogle CReal -> String
07:00:01 <lambdabot> Warning: Unknown type CReal
07:00:01 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
07:00:01 <lambdabot> Prelude show :: Show a => a -> String
07:00:02 <quicksilver> so it really is 0.00000 .... (50 zeros) ....
07:00:06 <Sgeo> I thought you all were being either confused or sarcastic
07:00:16 * hackagebot CC-delcont-alt 0.1.1.0 - Three new monad transformers for multi-prompt delimited control  http://hackage.haskell.org/package/CC-delcont-alt-0.1.1.0 (KidoTakahiro)
07:00:20 <ion> @type showCReal
07:00:21 <lambdabot> Int -> CReal -> String
07:00:22 <quicksilver> CReal is possibly an unfortunate choice of name
07:00:23 <hpc> mm_freak: you can specify the number of digits to print
07:00:31 <hpc> ah, showCReal
07:00:37 <Sgeo> I can't find it on Hoogle or Hayoo
07:00:43 <mm_freak> quicksilver: C as in Computable?
07:00:46 <quicksilver> yes
07:00:53 <mm_freak> Sgeo: i think it's the numbers package
07:00:55 <hpc> mm_freak: or Constructive; depends on your perspective
07:01:19 <ion> Or Califragilistic
07:01:25 <rostayob> Can I link programs to the needed C libraries manually with GHC?
07:01:39 <mm_freak> Sgeo: note: the "numbers" package, not the "Numbers" package =)
07:01:45 <rostayob> i am having problems compiling statically
07:02:00 <Sgeo> It represents reals as functions from Ints to Integers?
07:02:25 <Sgeo> HASKELL 1.2?!?
07:02:43 * lapas kas 2x2 off
07:03:15 <mm_freak> Sgeo: it's pretty old
07:05:44 <ion> sgeo: The Int is an exponent of 2.
07:05:56 <ion> instance Num CReal where
07:06:01 <ion>   fromInteger n     = CR (\p -> n*2^p)
07:06:15 <hpc> ...huh
07:07:27 <hpc> oh i see, the location of the decimal point is encoded in that power
07:07:46 <hpc> 0.5 = CR (\p -> 1 * 2 ^ (p - 1))
07:08:31 <dolio> You give p, and it gives back k such that k/2^(p+1) <= r <= k/2^p.
07:08:40 <dolio> Where r is your target.
07:08:42 <cheater_> hey guys i have a read somewhere in my code. at some point something goes wrong and it can't read the thing, it just says "Prelude.read: no parse". how can i get it to print the line it couldn't read?
07:08:44 <dolio> Or something of that sort.
07:08:51 <dolio> Wait.
07:09:00 <dolio> k/2^p <= r <= (k+1)/2^p
07:09:11 <dolio> That's the right one.
07:09:28 <Botje> cheater_: you could switch to reads + a custom error
07:09:57 <Sgeo> :t reads
07:09:58 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:10:10 <Sgeo> > reads "5blah" :: Int
07:10:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:10:11 <lambdabot>         against inferred type ...
07:10:12 <dever> cheater_: how about printing the line you read beforehand?
07:10:16 <Sgeo> > (reads "5blah") :: Int
07:10:17 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:10:18 <lambdabot>         against inferred type ...
07:10:22 <Sgeo> derp
07:10:23 <hpc> > reads "()blah"
07:10:24 <lambdabot>   [((),"blah")]
07:10:26 <cheater_> dever: i'm not in io.
07:10:39 <Sgeo> > reads "5blah" :: [(Int, String)]
07:10:40 <lambdabot>   [(5,"blah")]
07:10:48 <Sgeo> > reads "blah" :: [(Int, String)]
07:10:48 <dever> is Debug.Trace IO bound?
07:10:49 <lambdabot>   []
07:10:54 <cheater_> no
07:11:01 <dever> you could use that then.
07:11:01 <cheater_> i'm currently trying with traceShow
07:11:11 <cheater_> but i thought there could be something nicer.
07:11:40 <Sgeo> How tightly does :: bind?
07:11:49 <ion> > (reads :: ReadS Integer) "42x"
07:11:50 <lambdabot>   [(42,"x")]
07:11:59 <dolio> Lower than almost anything.
07:12:05 <Sgeo> "almost"?
07:12:18 <dolio> Except \x -> e :: t.
07:12:19 <dolio> Off hand.
07:12:23 <byorgey> say hi everyone, you're being projected on the screen in front of my intro haskell course
07:12:28 <dolio> That's \x -> (e :: t)
07:13:05 <hpc> byorgey: oh god, they let you teach?
07:13:25 <chased> byorgey, haaaaaaaaaaaaaaaaaaaaaaaaaaaaaiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
07:13:30 <byorgey> I was just telling them how nice you all were =(
07:13:39 <cheater_> byorgey: resistance is futile
07:13:46 <Sgeo> Hello students!
07:13:46 * frerich waves to byorgey's class and wishes to express his condolences ;-)
07:13:54 * Botje waves
07:13:56 <Sgeo> > text "Hello students"
07:13:57 <lambdabot>   Hello students
07:14:03 * cheater_ wonders if byorgey's class will now invade #haskell at least a little bit, could be fun
07:14:05 <Sgeo> I should not have done that
07:14:46 <ion> Dear byorgey’s class: do not bother learning Haskell. PHP is much more elegant.
07:14:58 <Sgeo> > text "This is only a lambdabot trick, and is NOT hello world"
07:14:59 <lambdabot>   This is only a lambdabot trick, and is NOT hello world
07:15:31 <dever> ion: i hear html is where it's at these days
07:15:42 <cheater_> cool, i'm totally getting the hang of this debugging haskell thing
07:15:54 <cheater_> thanks again Sgeo/etc
07:15:57 <ion> @where e_10
07:15:57 <lambdabot> let(!)=div;f n=1:n:1:f(n+2);w@(x:y)%[a,b,c,d]|t<-a!c,c+d>1,t==b!d=t:w%[10*(a-c*t),10*(b-d*t),c,d]|0<1=y%[x*a+b,a,x*c+d,c]in(2:f 2)%[1,0,0,1]>>=show
07:16:10 <dolio> Forget PHP, use Ur/Web.
07:16:14 <dever> cheater_: what was the solution?
07:16:28 <cheater_> dever: i don't know, it's still running, but i feel i'm closer :p
07:16:34 <cheater_> it was a general observation though
07:16:42 <ion> The e_10 implementation above is a canonical example of good Haskell code.
07:16:45 <cheater_> hanging out in here got me up to speed in a few weeks :)
07:16:52 <dever> cheater_: slowly down the rabbit hole
07:17:03 <cheater_> ion: it also cross-compiles as bash, perl, and befunge.
07:17:07 <Botje> it all starts with fibonaccis and factorials
07:17:25 <Botje> next thing you know you're doing right kan-extensions after hours in lieu of sleeping
07:17:28 <Botje> SAY NO TO LAMBDAS
07:17:37 <dever> LAMBDAS. NOT EVEN ONCE!
07:18:08 <cheater_> @faq can Haskell make byorgey a good teacher?
07:18:12 <lambdabot> The answer is: Yes! Haskell can do that.
07:18:15 <cheater_> !
07:18:24 <Botje> well, that settles it.
07:18:36 <cheater_> is this thing still on
07:18:39 <dever> records are a gateway drug.
07:18:40 * cheater_ taps the microphone
07:18:46 <int-e> > transpose [fix((0:).scanl(+)1),scanl(*)1[1..]]
07:18:47 <Sgeo> @faq Can Haskell be used to determine whether an arbitrary Turing machine halts?
07:18:48 <lambdabot> The answer is: Yes! Haskell can do that.
07:18:48 <lambdabot>   [[0,1],[1,1],[1,2],[2,6],[3,24],[5,120],[8,720],[13,5040],[21,40320],[34,36...
07:19:10 <Botje> Sgeo: it calls out to amazon mechanical turk.
07:19:21 <cheater_> Sgeo: given Goedel's paradox, i'd say that's well within bounds of our logic.
07:20:49 <Sgeo> What did Goldilocks say upon seeing Maybe (b -> Either a b)?
07:21:05 <Sgeo> It's Just Right!
07:21:08 <Sgeo> :t Just Right
07:21:08 <int-e> that's just right.
07:21:09 <lambdabot> forall b a. Maybe (b -> Either a b)
07:21:28 <ion> > cycle "ha"
07:21:29 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
07:21:39 <int-e> > fix error
07:21:40 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
07:21:50 <cheater_> so uh
07:22:05 <int-e> haskell doesn't make sense at all.
07:22:05 <cheater_> how do i go from "22.5" to a Rational without going through a float?
07:22:14 <Sgeo> [Just Right, Just Left]
07:22:17 <cheater_> int-e: haskell doesn't not make no sense never.
07:22:20 <Sgeo> > [Just Right, Just Left]
07:22:20 <ion> > (reads :: ReadS Rational) "22.5"
07:22:21 <lambdabot>   Overlapping instances for GHC.Show.Show
07:22:21 <lambdabot>                              (b -> ...
07:22:21 <lambdabot>   can't find file: L.hs
07:22:30 <Sgeo> ion, eep, sorry
07:22:32 <ion> > (reads :: ReadS Rational) "22.5"
07:22:33 <lambdabot>   []
07:22:42 <ion> > (reads :: ReadS Rational) "22.5%1"
07:22:43 <quicksilver> cheater_: unfortunately, do your own parsing
07:22:43 <lambdabot>   []
07:22:48 <cheater_> yea ion Rational expects %.
07:22:49 <quicksilver> although it's not exactly hard.
07:22:57 <cheater_> quicksilver: LIES!!!!!!!!!!!!!!!!!!!!!!
07:23:17 <ion> > (reads :: ReadS Rational) "22.5/1"
07:23:18 <lambdabot>   []
07:23:20 <ion> meh
07:23:28 <cheater_> i know right
07:23:32 <int-e> > (reads :: ReadS Rational) "111 % 3"
07:23:33 <lambdabot>   [(37 % 1,"")]
07:23:54 <cheater_> @hoogle Decimal
07:23:55 <lambdabot> Data.Char DecimalNumber :: GeneralCategory
07:23:55 <lambdabot> package Decimal
07:23:55 <lambdabot> Text.Parsec.Token decimal :: GenTokenParser s u m -> ParsecT s u m Integer
07:24:09 <Sgeo> It should be possible to break on the ., then transform that into a string with %
07:24:18 <int-e> > 23.5 :: Rational
07:24:19 <lambdabot>   47 % 2
07:24:22 <cheater_> oo
07:24:28 <cheater_> int-e: is Rational better?
07:24:39 <cheater_> er
07:24:43 <cheater_> wait, mindfuck.
07:24:51 <cheater_> i forgot you added no quotes.
07:25:01 <ClaudiusMaximus> @hoogle readFloat
07:25:02 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
07:25:16 * hackagebot hedis 0.2 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.2 (FalkoPeters)
07:25:16 <cheater_> int-e: so how do i go from String to an infinite-precision decimal number?
07:25:42 <int-e> cheater_: yeah if I had a point it was that the Read instance might be reasonably expected to accept, say 2.3 and turn it into 23/10.
07:25:43 <ClaudiusMaximus> > (readFloat :: ReadS Rational) "22.5"
07:25:44 <lambdabot>   [(45 % 2,"")]
07:25:59 <cheater_> int-e: aha
07:26:23 <quicksilver> > let parseRat s = (let (h,'.':t) = break (=='.') s in (read h % read t)) in parseRat "22.5" :: Rational
07:26:25 <lambdabot>   22 % 5
07:26:32 <quicksilver> ClaudiusMaximus: oh, good one.
07:26:36 <ion> readFloat? Nice.
07:26:37 <quicksilver> ClaudiusMaximus++
07:26:40 <int-e> quicksilver: ouch :)
07:26:46 <ClaudiusMaximus> > (readSigned readFloat :: ReadS Rational) "-22.5"
07:26:47 <lambdabot>   [((-45) % 2,"")]
07:27:21 <Sgeo> @hoogle readsigned
07:27:21 <lambdabot> Numeric readSigned :: Real a => ReadS a -> ReadS a
07:28:16 <hpc> @src readSigned
07:28:16 <lambdabot> Source not found. :(
07:29:18 <hamilyon-> @hoogle readFloat
07:29:19 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
07:29:45 <ion> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Numeric.html#readSigned
07:35:07 <cheater_> ClaudiusMaximus: the problem is that this goes through Float
07:35:09 <cheater_> which ain't good.
07:35:26 <shirt> IORefs are threadsafe and writes to them are atomic, right?
07:35:37 <ion> It doesn’t go through Float.
07:35:39 <quicksilver> shirt: yes.
07:36:41 <quicksilver> readFloat does not use any floating point, despite its name
07:36:47 <shirt> quicksilver: thanks. is the order of writing to multiple IORefs from a single thread guaranteed to be consistent when read from other threads? (i am worried about cpu instruction reordering)
07:36:49 <quicksilver> perhaps readDecimal would have been a better choice of name.
07:37:17 <quicksilver> shirt: interesting question :)
07:37:17 <ion> or readRealFrac
07:37:48 <ion> If you want atomicity, use STM.
07:38:21 <shirt> ion: i need minimal overhead
07:39:01 <quicksilver> write assembly code then.
07:39:25 <quicksilver> but make sure you have the manual for the exact CPU you plan to use handy. This reorder stuff is subtle.
07:41:04 <Sgeo> How worried should I be about observability of order of locking of MVars?
07:41:11 <Sgeo> Is that as unstable as IORef writing?
07:41:41 <shirt> quicksilver: well that's why i'm asking about haskell :) maybe it's locking IORefs anyway, which should guard against instruction reordering
07:41:45 <int-e> shirt: Speaking for ghc, I think reads may be reordered on the program level. writes have a subsequent call to an external function, so that may not happen. The CPU can still reorder stuff, of course.
07:41:57 <bgamari> On this note, are MVars better optimized than IORefs?
07:42:25 <bgamari> I did some tests a few days ago which suggested they might be in the case of ghc
07:42:30 <bgamari> Which I was quite surprised by
07:42:55 <int-e> bgamari: better optimised in what respect? how are you using them?
07:44:23 <bgamari> int-e: Just a tight loop of modifies from multiple threads
07:44:53 <shirt> int-e: thanks
07:45:22 <int-e> bgamari: using atomicModifyIORef, I suppose, in which case threads may waste a lot of time spinning in order to win the compare-and-swap race.
07:45:37 <hpaste_> “Ben Gamari” pasted “MVar microbenchmark” at http://hpaste.org/56375
07:45:51 <cheater_> how do i pattern match something like this?  median [x] ++ xs ++ [y] = median xs
07:46:05 <hpaste_> “Ben Gamari” pasted “IORef microbenchmark” at http://hpaste.org/56376
07:46:11 <hpc> cheater_: you don't
07:46:19 <cheater_> then what do i do ?? :(
07:46:29 <hpc> > last [1,2,3,4,5]
07:46:31 <lambdabot>   5
07:46:46 <cheater_> that doesn't help me
07:46:56 <cheater_> i want the middle part without the first and last item
07:46:57 <bgamari> int-e: Regardless of whether the threads are updating the same or different refs/vars, the mvar benchmark always seems to win
07:47:07 <cheater_> but only if the list has at least 3 items
07:48:43 <bgamari> int-e: In fact, even in the single-threaded case (no threaded RTS) MVar wins
07:49:47 <hpc> neat
07:50:16 <hpaste_> donri pasted “depends on haskell-src-exts-1.11.1 which failed to install” at http://hpaste.org/56377
07:50:24 <donri> halp?
07:51:53 <donri> is my actual cabal package broken?
07:53:59 <parcs`> https://github.com/ghc/ghc/commit/5508ada4b1d90ee54d92f69bbff7f66b3e8eceef :O
07:54:53 <int-e> bgamari: I think the reason is that atomicModifyIORef builds a larger closure than the modifyMVar version -- if you look at the GC statistics of the two programs you'll find that the productivity is abysmal and much worse for the IORef version.
07:55:01 <parcs`> that'll be very useful for ghci
07:56:29 <Sgeo> Suppose I mapM_ takeMVar [mvar1, mvar2, mvar3, mvar4]. Can I rely on other threads seeing the order of locking correctly?
07:56:32 <cheater_> parcs`: what is the practical usage of that?
07:56:52 <shirt> turns out that the docs for IORef have a section on "Memory Model" with a nice example
07:57:20 <bgamari> int-e: good to know
07:57:24 <Sgeo> parcs`, o.O sounds abusable.
07:57:32 <Sgeo> parcs`, but I guess it simplifies GHCi?
07:58:06 <parcs`> cheater_: when you reload a file with a type error in ghci the bindings won't get lost
07:58:21 <Sgeo> parcs`, oooh
07:58:32 <quicksilver> funny I always thought that trac was a joke
07:59:05 <NapHtaKeRoSene> hi
07:59:06 <NapHtaKeRoSene> should i keep int insquare_p(point2d p, point2d p1, point2d p2), or just consider int insquare(point2d p, rect2d rect) ?
07:59:07 <parcs`> this should be backported to 7.4
08:04:08 <cheater_> @hoogle sort
08:04:10 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
08:04:10 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
08:04:10 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
08:07:19 <Botje> NapHtaKeRoSene: I think you have the wrong channel.
08:09:13 <ion> He keeps having the wrong channel repeatedly.
08:11:56 <NapHtaKeRoSene> okk i see you don't like C
08:12:35 <hpaste_> int-e annotated “IORef microbenchmark” with “IORef+MVar microbenchmark, modified” at http://hpaste.org/56376#a56379
08:13:35 <int-e> bgamari: so in my experiment I find that when there is contention, the IORef outperforms the MVar by an order of magnitude. The main change is to force evaluation of the counter each time it's updated.
08:13:35 <russruss> hey so I haven't used haskell in a while and was never really an expert - what's the most idiomatic way to write simple conditionals inside lambdas?  I could A) use the gross if-then-else sugar, B) don't use a lambda, instead use a named function with pattern matching inside a where clause, or C) use some sort of standard if-then-else function (which I'm not sure exists in the prelude)… which of these seems less bad?
08:14:10 <Botje> russruss: depends on the cases you have and the code that reacts on it
08:14:15 <hpc> russruss: depends on the "shape" of the function, i suppose
08:14:22 <hpc> :t (??)
08:14:23 <lambdabot> Not in scope: `??'
08:14:37 <hpc> @let (t ?? f) p = if p then t else f
08:14:41 <hpc> :t (??)
08:14:43 <lambdabot> Not in scope: `??'
08:14:44 <lambdabot>  Defined.
08:14:46 <hpc> :t (??)
08:14:47 <lambdabot> forall t. t -> t -> Bool -> t
08:15:01 <hpc> :t 5 ?? 10
08:15:02 <lambdabot> forall t. (Num t) => Bool -> t
08:15:19 * hackagebot gearbox 1 - zooming rotating fractal gears graphics demo  http://hackage.haskell.org/package/gearbox-1 (ClaudeHeilandAllen)
08:15:28 <ClaudiusMaximus> ^^ video loop at http://claudiusmaximus.goto10.org/v/compass/2012-01-12_gearbox_v3.ogv 14MB
08:19:05 <paulotruta> WOW...
08:19:28 <asda8> ClaudiusMaximus: really cool :)
08:20:16 <ClaudiusMaximus> :)  eventually i want it to be more interesting (zooming into different gears), but i must not work on it until other things are done
08:20:33 <ion> claudiusmaximus: Nice
08:20:49 <The_Journey> hi, I have a very expensive function f which I am trying to use parMap rpar myList but so far I am getting no speedup in my program compared to when I just do map f myList, can anyone help me?
08:21:31 <hpc> :t parMap
08:21:32 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
08:21:35 <ClaudiusMaximus> The_Journey: are you using ghc -threaded -rtsopts ; ./program +RTS -N
08:22:02 <The_Journey> ClaudiusMaximus: I thought -threaded was all I needed in GHC, I will try that
08:22:18 <hpc> The_Journey: you still have to tell the RTS how many cores to run on
08:24:07 <The_Journey> wow, that actually made it worse
08:24:18 <The_Journey> and I am running a quad-core
08:25:22 * hackagebot hepevt 0.2 - HEPEVT parser and writer  http://hackage.haskell.org/package/hepevt-0.2 (ScottLawrence)
08:25:33 <hpc> The_Journey: did you just do "+RTS -N"? i think you have to do "+RTS -N4", or whatever number of threads you want it to use
08:25:57 <The_Journey> hpc: yes, I ran the program with +RTS -N and with +RTS -N4
08:26:05 <The_Journey> both did worse :(
08:26:10 <hpc> hmm
08:26:35 <hpc> :t rpar
08:26:36 <lambdabot> forall a. a -> Eval a
08:27:47 <Sgeo> Are there any examples of using Data.Reflection somewhere?
08:27:59 <Lycurgus> "just" and "all I"
08:28:49 <The_Journey> Haskell can use "real" threads right? Not emulated ones?
08:29:15 <cheater_> hello
08:29:18 <Sgeo> It can, but you should prefer the emulated ones.
08:29:19 <cheater_> i am inside a do block for a monad
08:29:22 <donri> The_Journey: ghc -threaded
08:29:23 <Sgeo> Unless you need real ones
08:29:26 <cheater_> but i need to use <- from another monad
08:29:28 <Botje> haskell multiplexes haskell threads over real threads.
08:29:29 <cheater_> how do i do this?
08:29:33 <Botje> cheater_: you can't.
08:29:38 <ciaranm> cheater_: monads do not work that way
08:29:42 <Lycurgus> Justin Allei, a product manager at an exciting silicon valley startup ...
08:29:43 <Botje> cheater_: unless you can run the other monad with a run* function
08:29:50 <cheater_> no idea
08:30:13 <cheater_> i'm doing BlazeHtml and want to add multiple paragraphs. i just wanted to start by iterating over a list of strings.
08:30:14 <Botje> well, be more specific then :P
08:30:35 <Botje> okay
08:30:42 <Botje> and what do you do while iterating?
08:31:14 <cheater_> oh it just worked
08:31:18 <cheater_> perfect
08:31:27 <cheater_> i was trying with forM_ but it kinda sorta didn't work
08:31:31 <ChristianS> -t options tells ghc to use real threads, i think
08:31:36 <NapHtaKeRoSene> btw it's in functional form if that makes you feel better
08:31:38 <cheater_> but i think the issue here was that the tutorial was wrong.
08:31:49 <Sgeo> Which tutorial?
08:31:53 <The_Journey> ChristianS: so I pass -t to GHC when I compile?
08:32:19 <cheater_> this worked for me: http://pastebin.com/DCgytmB5
08:32:21 <mauke> The paste DCgytmB5 has been copied to http://hpaste.org/56380
08:32:26 <bgamari> int-e: Ahh
08:32:35 <cheater_> Sgeo: the Blaze Html tutorial, here: http://jaspervdj.be/blaze/tutorial.html
08:32:39 <bgamari> int-e: whoops, laziness bites again
08:32:43 <ChristianS> -threaded
08:32:57 <Enigmagic> The_Journey: try using monad-par instead http://hackage.haskell.org/packages/archive/monad-par/0.1.0.3/doc/html/Control-Monad-Par.html
08:33:09 <cheater_> i had a toHtml in there, but it didn't work. it worked after toHtml was removed. (look at the function "numbers")
08:33:13 <The_Journey> Enigmagic: thank you, I will try that
08:33:38 <jaspervdj> cheater_: I'll look at it and fix it if needed, sorry for the confusion
08:33:40 <Sgeo> cheater_, which part?
08:34:06 <Sgeo> @hoogle docTypeHTML
08:34:07 <lambdabot> No results found
08:34:11 <Sgeo> @hoogle docTypeHtml
08:34:12 <lambdabot> No results found
08:34:29 <Sgeo> lambdabot needs Hayoo
08:35:08 <hpc> @hayoo blarg
08:35:09 <lambdabot> Unknown command, try @list
08:35:15 <quicksilver> or a better hoogle database, Sgeo
08:35:24 <quicksilver> hoogle indexes whatever packages you give it.
08:35:31 <quicksilver> the lambdabot hoogle could be primed with more.
08:35:31 <Sgeo> I don't get why this thing is a monad
08:35:44 <Sgeo> Does Blaze abuse monad..ness for the convenient do syntax?
08:35:46 <quicksilver> Sgeo: it's an abomination
08:35:58 <hpc> Sgeo: yes
08:36:09 <hpc> it's a convenient abomination
08:36:30 <Sgeo> I guess everything is a Writer Blah ()?
08:36:39 <Sgeo> Or something
08:36:40 <hpc> essentially
08:36:40 <Sgeo> ?
08:36:42 <Sgeo> Ok
08:36:48 <Sgeo> That ... isn't too terrible, is it?
08:36:58 * Sgeo might want to do something similar for one of his own things
08:37:31 <dolio> Yes, Writer certainly is an abomination.
08:37:33 <hpc> i used a similar trick for my website, except in IO, so it still had monadic parts
08:37:46 <Sgeo> Is Hayoo down?
08:37:52 <Saizan> "abomination - nothing too terrible" should go in a dictionary
08:37:57 <hpc> haha
08:40:14 <mee> sgeo: downforeveryoneorjustme.com seems to think so
08:40:36 <The_Journey> how may I make my data type be NFData to be used with Control.Monad.Par parMap? I am trying to instance NFData and defining rnf but I am getting the error: "rnf" is not a visible method of NFData
08:40:54 <hpc> @src NFData
08:40:54 <lambdabot> Source not found.
08:41:27 <Sgeo> @hoogle NFData
08:41:27 <lambdabot> Control.Parallel.Strategies class NFData a
08:41:27 <lambdabot> Control.DeepSeq class NFData a
08:41:29 <hpc> :t deepdeq
08:41:30 <lambdabot> Not in scope: `deepdeq'
08:41:34 <hpc> :t deepSeq
08:41:35 <lambdabot> Not in scope: `deepSeq'
08:41:39 <hpc> @hoogle deepseq
08:41:39 <lambdabot> Control.DeepSeq module Control.DeepSeq
08:41:39 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
08:41:39 <lambdabot> package deepseq
08:41:39 <cheater_> Sgeo: the part which says "toHtml"
08:41:50 <hpc> The_Journey: define deepseq, i think
08:41:58 <The_Journey> hpc: and not rnf?
08:42:09 <hpc> The_Journey: you're bumping into the same problem that keeps you from defining monads in terms of join
08:42:18 <cheater_> Sgeo: i removed it and it worked... but it only works with literals. it doesn't work with lists of strings that i got otherwise. it seems i *need* toHtml for that, but using it creates an ambiguous type exception.
08:42:44 <Sgeo> You can fix ambiguous type exceptions by proving a type signature
08:42:50 <Sgeo> *providing
08:43:03 <cheater_> yeah but i'm not sure what the best way to do this is
08:43:08 <cheater_> i mostly code without signatures at all
08:43:11 <quicksilver> those who don't understand overloading are...
08:43:19 <quicksilver> condemned to fiddly ambiguity errors, I guess
08:43:30 <cheater_> so i don't want to provide a full-blown type signature for the function in question (it would be complicated), i just want to inline the signature somewhere.
08:43:36 <The_Journey> hpc: I am getting the error deepseq is not a visible method of NFData
08:43:39 <Sgeo> cheater_, you can!
08:43:45 <Sgeo> > 1 + (1::Int)
08:43:47 <lambdabot>   2
08:44:23 <Enigmagic> The_Journey: how did you import NFData?
08:44:54 <cheater_> Sgeo: i know, but i'm not sure how to do it in *this* code
08:44:57 <cheater_> it's a bit crazy.
08:45:00 <The_Journey> Enigmagic: ah, for some reason I thought it was in the same package >_<
08:45:01 <Enigmagic> The_Journey: use 'import Control.DeepSeq' or 'import Control.DeepSeq (NFData(..))'
08:45:01 <cheater_> let me post something.
08:45:20 <russruss> hey sorry for the beginner question… I didn't see anything on google… is there a shorthand from the prelude for \x -> [x]?
08:45:25 <russruss> err hoogle rather
08:45:47 <clsmith> return?
08:45:56 <hpc> http://hackage.haskell.org/packages/archive/deepseq/latest/doc/html/src/Control-DeepSeq.html#deepseq
08:45:58 <ion> pure if you’ve imported Control.Applicative
08:46:05 <cheater_> http://pastebin.com/Xxqf4PJd
08:46:07 <mauke> The paste Xxqf4PJd has been copied to http://hpaste.org/56381
08:46:26 <russruss> clsmith, ion: thanks, both work :-)
08:46:33 <Sgeo> cheater_, and exact error message?
08:46:37 <russruss> I should have thought of that :-P
08:46:45 <cheater_> 1 sec
08:46:52 <ion> And the robot function ;-)
08:47:00 <Sgeo> > [] 'a
08:47:01 <lambdabot>   <no location info>:
08:47:01 <lambdabot>      lexical error in string/character literal at end o...
08:47:01 <Sgeo> > [] 'a'
08:47:03 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> t'
08:47:03 <lambdabot>         against inferred...
08:47:04 <Sgeo> darn
08:47:31 <Sgeo> Actually, that's kind of obvious, thinking about it
08:47:34 <ion> > (;[]) 'a'  -- You might not want to actually use this. :-P
08:47:36 <lambdabot>   <no location info>: parse error on input `;'
08:47:37 <srhb> Hum, how do I zip with function application?
08:47:44 <ion> > (:[]) 'a'  -- You might not want to actually use this. :-P
08:47:45 <lambdabot>   "a"
08:47:49 <Sgeo> srhb, zipWith
08:47:50 <cheater_> http://pastebin.com/vfRSWmC5
08:47:52 <mauke> The paste vfRSWmC5 has been copied to http://hpaste.org/56382
08:48:03 <geekosaur> zipWith ($) ?
08:48:14 <srhb> Doh, obviously. Thanks.
08:48:42 <Sgeo> cheater_, try giving H.toHtml a type signature
08:48:50 <cheater_> how?
08:48:51 <quicksilver> zipWith ($) is a mini-epiphany I think
08:48:55 <Sgeo> or the getMetrics
08:48:59 <cheater_> (H.toHtml :: whatever) ?
08:49:11 <cheater_> getMetrics returns [String] i guess
08:49:13 <cheater_> let me try
08:49:13 <srhb> quicksilver: No kidding.
08:49:22 <quicksilver> and its friend zipWith ($x)
08:49:31 <srhb> ooooh
08:49:41 <clsmith> there ought to be a program which looks through your code looking for, say, monadic data types, and converts your functions to be more idiomatic
08:49:46 <quicksilver> grok those too and suddenly you understand a lot about higher order functions and haskell and expressiveness and generally how it all works neatly.
08:49:47 <srhb> Why don't I see these things on my own >_<
08:49:47 <cheater_> yup, typing getMetrics worked!
08:49:48 <Sgeo> cheater_, OverloadedStrings makes it (IsString s) => [s] unless you make it more specific
08:49:50 <cheater_> thanks a lot Sgeo
08:49:54 <Sgeo> You're welcome
08:49:56 <ion> > ZipList [pred, id, succ] <*> ZipList [150, 250, 350]
08:49:57 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
08:49:57 <lambdabot>    arising ...
08:50:00 <cheater_> you're like a magician
08:50:03 <quicksilver> clsmith: HLint does a little of that, I think
08:50:08 <ion> > getZipList $ ZipList [pred, id, succ] <*> ZipList [150, 250, 350]
08:50:09 <lambdabot>   [149,250,351]
08:50:10 <clsmith> i say this because i wrote a compiler in haskell and it's progressed into a whole bunch of spaghetti and recursive functions
08:50:10 <cheater_> EXCEPT a wizard
08:50:27 <The_Journey> how can I force GHC to recompile and link a file?
08:50:34 <geekosaur> -fforce-recomp
08:50:35 <ion> I don’t get the lack of a Show instance for ZipList.
08:50:39 <The_Journey> thank you
08:50:51 <hpc> you can also delete the .o and .hi files associated with it
08:51:52 <The_Journey> man, using Control.Monad.Par still gives the same time as map f myList
08:52:36 <Enigmagic> The_Journey: how much work are you doing in the map function?
08:53:18 <The_Journey> the f is a very expensive function, it is using hmatrix to minimize a function with 510 parameters
08:53:58 <The_Journey> and I am mapping a over a list of about 1000 elements
08:54:08 <danr> 510 arguments  to a function??
08:54:30 <The_Journey> the non-threaded version gives me 32s, the threaded one with Control.Monad.Par gives me 52s, and the one with parMap gives me 55s
08:56:30 <Enigmagic> The_Journey: is it using up all the cores?
08:56:39 <The_Journey> Enigmagic: how can I verify that?
08:57:02 <Enigmagic> The_Journey: simplest thing to do is run "+RTS -sstderr" and check the output when it's done (or you hit ctrl-c)
08:57:21 <Enigmagic> The_Journey: sometimes the threaded versions have terrible GC overhead
08:57:52 <Enigmagic> The_Journey: other times... it could just be the c code in hmatrix doing allocations or something like that, where switching to a different allocator (like tcmalloc) would help
08:58:36 <The_Journey> Enigmagic: what am I looking for in the output?
08:58:46 <The_Journey> after running with +RTS -sstderr
08:59:10 <Enigmagic> The_Journey: it'll dump out allocation and scheduling information. you want to look at the 'MUT' and 'GC' times mostly..
09:00:27 <hpaste_> dsfdsfsd pasted “sdfsdf” at http://hpaste.org/56383
09:00:45 <The_Journey> Enigmagic: this is my output http://hpaste.org/56383
09:01:11 <The_Journey> Parallel GC work balance: -nan (0 / 0, ideal 1), does that mean it did not actually use any threads?
09:02:20 <Saizan> that means the GC didn't run in parallel, the fact that only Task 2 has any MUT times means the work hasn't been done in parallel either
09:02:30 <dgpratt> I've been playing around with QuickCheck; it's been going well, but then I decided to package these one-off tests into a test suite of sorts...
09:02:56 <dgpratt> ...to that end, I cabal installed test-framework and test-framework-quickcheck
09:02:58 <Saizan> The_Journey: you probably want to use one of the chunked variants of parMap or similar
09:03:10 <The_Journey> ah, I only ran the program with +RTS -sstderr, I didn't run it with +RTS -sstderr -N4
09:03:26 <Saizan> ah, that also matters
09:03:42 <Enigmagic> i do wish -threaded builds defaulted to +RTS -N
09:04:14 <dgpratt> I noticed that it installed QC v1.2 (I had QC 2.4); why does test-framework require an old version of QC?
09:04:36 <Enigmagic> dgpratt: you want test-framework-quickcheck2
09:04:48 <dgpratt> Enigmagic: ah! ok, thanks much
09:06:00 <The_Journey> here is my output http://hpaste.org/56384 when ran with -sstderr -N4
09:06:39 <The_Journey> so it's 53s, but the non-threaded one only took 33s
09:08:17 <Enigmagic> The_Journey: looks like the GC is at fault
09:08:38 <The_Journey> the GC is taking 67.8% of the time...?
09:08:45 <Enigmagic> try adding -gq1 -A2m
09:09:04 <The_Journey> Enigmagic: what do those options do?
09:09:52 <The_Journey> Enigmagic: I am getting unknown options when I passed those into GHC
09:10:07 <Enigmagic> The_Journey: disables parallel gc for gen0 and increases the time between collections
09:10:31 <cheater_> hey what is the "catchall" for case expressions?
09:10:36 <cheater_> it's not "otherwise" right?
09:10:50 <Sgeo> Read a Haskell tutorial?
09:11:02 <Enigmagic> The_Journey: what version of ghc are you using?
09:11:16 <The_Journey> Enigmagic: The Glorious Glasgow Haskell Compilation System, version 7.0.3
09:11:26 <Arnar> grr.. is fail in the Monad class ?? >(
09:11:31 <Arnar> > runState (do { fail "err"; put 10 }) 0
09:11:34 <lambdabot>   ((),10)
09:11:49 <Sgeo> Arnar, yes, but it shouldn't be
09:11:52 <Enigmagic> The_Journey: oh, it should be -qg1 not -gq1
09:12:04 <Arnar> Sgeo: I know.. the above is using fail from Id..
09:12:08 <Arnar> which naturally does...
09:12:12 <Arnar> *nothing*
09:12:30 <Sgeo> Arnar, it is?
09:12:36 <cheater_> Sgeo: you're right. i shall repent.
09:12:49 <Arnar> I believe so, not sure how else it happens
09:13:29 <The_Journey> ugghh..., now my program starts segfaulting again when I use those flags
09:13:31 <Sgeo> It makes no sense for it to be happening from Id
09:13:38 <Sgeo> It might be that fail doesn't do anything in State
09:13:49 <Arnar> Sgeo: State is just StateT .. Id
09:13:55 <Sgeo> > runState (do { fail "err" >>= put }) 0
09:13:56 <lambdabot>   ((),*Exception: err
09:14:17 <parcs`> yay laziness
09:14:53 <parcs`> > runState $ fail "err" >> modify id
09:14:54 <lambdabot>   Overlapping instances for GHC.Show.Show (s -> ((), s))
09:14:54 <lambdabot>    arising from a us...
09:15:03 <Enigmagic> The_Journey: something bigger seems broken..
09:15:06 <The_Journey> Enigmagic: I finally got an output: http://hpaste.org/56385, does that mean it is getting better? it is 35s now but it is no speedup over the non-threaded version of 33s
09:15:15 <parcs`> > (`runState` ()) $ fail "err" >> modify id
09:15:16 <lambdabot>   ((),*Exception: err
09:16:57 <Enigmagic> The_Journey: yah it's not running very much in parallel, hence no speedup
09:17:53 <The_Journey> Enigmagic: but it is running some things in parallel right?
09:18:11 <The_Journey> but why is my program segfaulting when I pass in those flags? I don't understand :(
09:18:33 <Enigmagic> The_Journey: yeah a teensy bit
09:18:51 <Enigmagic> there is a bug in some code you're using, it shouldn't segfault
09:20:01 <yitz> > case False of {True -> "yep"; _ -> "nope, hit the catch-all"} -- cheater_
09:20:02 <lambdabot>   "nope, hit the catch-all"
09:20:12 <koral> hi, is there any trick to get the equivalent behavior as sequence, but for tuples ?
09:20:33 <The_Journey> Enigmagic: I don't understand, my non-threaded version did not segfault for the many times I ran it
09:20:37 <yitz> koral: don't use a tuple for that
09:20:46 <The_Journey> and it did not segfault before I passed in those flags
09:20:58 <Enigmagic> The_Journey: wasn't it segfaulting last night?
09:21:14 <The_Journey> Enigmagic: yes, but I figured out the error was in my code
09:21:19 <The_Journey> it wasn't hmatrix
09:21:31 <koral> yitz: I must use a tuple since the elements' types don't match
09:22:11 <yitz> koral: create a data type that can hold any of the kinds of things that need to be inside, then use a list of those.
09:22:22 <Sgeo> Do you know anything about the types?
09:22:38 <Sgeo> If you didn't, you wouldn't even be able to sequence
09:23:02 <Enigmagic> The_Journey: well if it's the GC crashing it will show up in gdb
09:23:27 <Enigmagic> though i suspect it's something else
09:23:37 <yitz> koral: e.g., a list of Either, if there are only two possibilities. but even then, better to create a more expressive type.
09:23:46 <The_Journey> Enigmagic: I'll check my code again
09:24:15 <koral> Sgeo: yes I know precisely what are the types
09:24:46 <Enigmagic> The_Journey: ok, well i gotta run though... time to head up to the office
09:25:04 <Sgeo> koral, do you know the number of them statically?
09:25:12 <donri> is Cabal broken? http://hpaste.org/56377
09:25:22 <koral> yitz: that would do the trick but semantically the data type you're suggesting to create would have no sense
09:25:34 <yitz> koral: why?
09:25:39 <koral> Sgeo: yes
09:26:23 <koral> yitz: there is only one place in my whole code where such data type would be used
09:27:07 <yitz> donri: oh dear. looks like you have accidentally tried to install a new copy of one of libraries that came with ghc. that's a no-no.
09:27:34 <Sgeo> Is it so many that you can't manually do (\(a,b,c) -> do a' <- a; b' <- b; c' <- c; return (a', b', c')), or something? (Note: My idea should not be taken as canonical good style)
09:27:58 <rwbarton> @type liftM3
09:27:59 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
09:28:02 <rwbarton> @type liftM3 (,,)
09:28:03 <lambdabot> forall a1 a2 a3 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a3 -> m (a1, a2, a3)
09:28:12 <danr> and then uncurry3
09:28:15 <yitz> donri: you may not have ordered it explicitly; occasionally cabal makes the unfortunate decision to do that when solving dependencies. that is a way in which cabal is broken, yes.
09:28:27 <donri> yitz: i think it broke after upgrades from fedora; could the fedora packages be broken?
09:28:30 <Sgeo> o.O
09:29:03 <yitz> koral: but in that one place, those are exactly the semantics you need, from what you have described so far.
09:29:22 <yitz> donri: i have no experience with fedora.
09:29:28 <koral> Sgeo: no it's not, but I just had the feeling Haskell masters did think of a nicer way to write that
09:29:40 <yitz> donri: can you afford to clean everything out and try again?
09:29:57 <Sgeo> ^^see what rwbarton and danr said
09:29:59 <donri> yitz: i've done so multiple times with variations :)
09:30:26 <donri> i've tried uninstalling as many fedora packages as possible, and i've tried having all ghc packages installed, etc
09:30:28 <yitz> koral: there are very deeply sophisticated ways to fight with the type system and force it to do something like that, resulting in code that only gurus will be able to read.
09:30:42 <yitz> koral: well, not that bad.
09:30:59 <donri> and the same .cabal built fine a few days ago before fedora upgrades
09:31:41 <yitz> donri: i mean re-installing ghc, to start with a clean package registry. that's where the breakage is.
09:32:33 <donri> ok
09:34:07 <Sgeo> I ... think I want something similar to Hugs's TREX
09:34:12 <Sgeo> What are my options on GHC?
09:42:26 <Philippa> Sgeo: it won't be pain-free, but there are record systems built on HList. I don't think you can do TREX's lacks predicates in GHC at all, though
09:42:39 <Palmik> Hmm, is there some equivalent to :set -package for executable project?
09:42:55 <Sgeo> Philippa, I don't know much about TRex, so I doubt I'll miss itr
09:42:57 <Sgeo> *
09:42:59 <Sgeo> *it
09:43:14 <c_wraith> Palmik: you mean just using -package on the ghc command line?
09:44:22 <Sgeo> Philippa, on top of HList, or is there stuff in HList directly?
09:44:27 <Palmik> c_wraith, I meant :set -package some-library in GHCi but for Executable cabal project, but :load Main did what I wanted.
09:44:29 <drull95> i just thought of something; is it right to think of a limit as the fixpoint of an approximation procedure?
09:46:54 <drull95> i guess not because you never actually arrive at a fixpoint
09:47:02 <drull95> that makes sense
09:47:59 <Sgeo> Is there any eta on extensible records stuff in GHC?
09:48:40 <tty7> @(==) isNumber isDigit
09:48:40 <lambdabot> Unknown command, try @list
09:48:43 <tty7> @list
09:48:44 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:49:54 <bobry> folks, I'm relatively new to haskell, can anyone advise on a good unit testing framework?
09:50:13 <drull95> > (==) isNumber isDigit -- ?
09:50:15 <lambdabot>   *Exception: (==): No overloading for function
09:51:59 <ion> bobry: QuickCheck for most stuff, HUnit for the rest.
09:52:01 <frigga1> bobry: test-framework and HUnit
09:52:24 <bobry> well, that's the two I've googled -- is test-framework any better than HUnit?
09:52:33 <Sgeo> Is http://twanvl.nl/blog/haskell/overloading-functional-references basically lenses?
09:52:35 <bobry> from what I see, it supports both property and unit tests
09:52:53 <ion> bobry: You’ll use test-framework to run QuickCheck and HUnit tests.
09:53:03 <bobry> ah, it's just a wrapper
09:53:04 <bobry> nice
09:53:06 <bobry> thanks ion
09:53:31 <parcs`> @check liftA2 (==) isNumber isDigit
09:53:33 <lambdabot>   "Falsifiable, after 30 tests:\n'\\12838'\n"
09:55:55 <Sgeo> :t isNumber
09:55:56 <lambdabot> Char -> Bool
09:59:41 <tty7> > putStrLn "\12838"
09:59:42 <lambdabot>   <IO ()>
10:00:55 <Sgeo> > text "\12838"
10:00:57 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
10:01:14 <Sgeo> Prelude Foreign.C Control.Applicative> putStrLn "\12838"
10:01:15 <Sgeo> ㈦
10:01:20 <twanvl> Sgeo: yes, lenses == functional reference == fist class labels
10:01:34 <ion> I like fist class labels.
10:02:17 <ion> ㈦ U+3226 PARENTHESIZED IDEOGRAPH SEVEN
10:05:26 * hackagebot vty 4.7.0.8 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.7.0.8 (CoreyOConnor)
10:13:20 <The_Journey> would it be logically correct to surmise that if my program segfaults 50% of the time and works fine the other 50%, then there must be a non-deterministic elements in my program, and that only those elements can cause the program to crash?
10:13:41 <taruti> no
10:13:52 <ion> I take it nothing else keeps crashing?
10:14:01 <rostayob> does anybody have experience with Hipmunk (haskell bindings to chipmunk)?
10:14:10 <The_Journey> ion: what do you mean?
10:14:25 <The_Journey> taruti: where is my logic incorrect?
10:14:33 <ion> the_journey: Exactly what i asked. :-) I take it your program is the only thing on your system that keeps crashing?
10:14:39 <The_Journey> ion: yes
10:15:10 <taruti> The_Journey: it might depend on e.g. address space randomization or somesuch and the program as Haskell sees is deterministic
10:16:10 <The_Journey> taruti: but that seems to be OS-specific, how about excluding that?
10:17:29 <The_Journey> if all pure Haskell functions are deterministic, then how can they cause the non-deterministic behavior of my program? There have to be non-deterministic elements in my program, and only those elements can cause the crashes?
10:18:22 <rostayob> The_Journey: head [] crashes. head [1] doesn't.
10:18:38 <rostayob> (disclaimer: i'm not sure what you're talking about)
10:18:50 <The_Journey> rostayob: but that would throw an exception, not segfaults
10:19:01 <rostayob> The_Journey: oh, a segfault in haskell is not nice
10:19:05 <Saizan> also it'd happen 100% of the time
10:19:08 <The_Journey> ^
10:19:58 <The_Journey> I am trying to decide whether it is my program that is causing the random segfaults or is it the hmatrix I am using that is causing the segfaults
10:20:29 <NapHtaKeRoSene> pointinrect or PointInRect or point_in_rect ?
10:20:31 <NapHtaKeRoSene> ;/
10:20:34 <NapHtaKeRoSene> ;/
10:20:34 <NapHtaKeRoSene> ;/
10:20:39 <Saizan> if hmatrix is the only one doing FFI it's likely the culprit
10:23:38 <NapHtaKeRoSene> or pointInRect ?
10:24:02 <koeien> NapHtaKeRoSene: for which purpose? it matterns whether you identifiers start with a capital
10:24:34 <koeien> in the values domain: values (including functions) start with a lowercase, data constructors start with an uppercase letter
10:24:38 <NapHtaKeRoSene> koeien<< for general purpose checking if 2d point is in rectangle range
10:25:06 <koeien> in the types domain: types/type constructors start with an uppercase character, type variables with lowercase
10:25:16 <mceier> NapHtaKeRoSene: isPointInRectangle  :P
10:25:17 <nand`> is there any type t for which fmap ≠ liftM?
10:25:18 <koeien> the usual way in haskell is pointInRect
10:25:27 * hackagebot serialport 0.4.3 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.4.3 (JorisPutcuyps)
10:25:40 <tazjin> There needs to be a warning on haskell.org saying "Warning: Haskell is addictive"
10:25:42 <koeien> nand`: all sane types have this.
10:26:02 <tty7> tazjin: absolutely.
10:26:05 <nand`> koeien: I'm just wondering, since a monad by definition contains a functor (along with two natural transformations), why even bother having liftM distinct from fmap?
10:26:14 <koeien> nand`: historial reasons
10:26:18 <koeien> historical*
10:26:32 <koeien> note that Functor is not a superclass of Monad, for example
10:26:43 <The_Journey> I think I just convinced myself to use Haskell over C++/Java by using non-determinism to trace bugs :)
10:27:03 <hpc> nand`: if Monad was written today, i think it would be something like
10:27:27 <hpc> class Applicative m => Monad m where join, (>>=), return :: stuff
10:27:34 <hpc> nand`: but that would break quite a bit of code
10:27:42 <ion> No
10:28:10 <ion> Sorry, i read too hastily (from the other side of the room) and missed the all-important join actually being there. :-)
10:28:14 <alistra> i still don't understand what kind of code Applicative makes nicer
10:28:18 <hpc> ion: ;)
10:28:23 <alistra> it always looks worse imo
10:28:23 <alistra> :P
10:28:28 <roconnor> alistra: reader monad code
10:28:51 <alistra> like the source of it, or using the monad?
10:28:52 <ion> I use <*> and liftA2 all the time.
10:28:56 <hpc> ion: wait, we are both wrong
10:28:58 <roconnor> I use applicative functions whenver I can myself
10:29:06 <hpc> class ... where join, (>>=) :: stuff
10:29:10 <hpc> ion: return = pure
10:29:14 <alistra> roconnor: do you have any nice example at hand?
10:29:14 <donri> i think the point is that applicative can be used to look a lot like plain function application
10:29:15 <ion> hpc: Indeed
10:29:22 <roconnor> alistra: let me look
10:29:27 <donri> just sprinkle some <*> and <$> in the code
10:29:30 <koeien> yeah applicative notation is nice
10:29:54 <nand`> <*> on the ((->) a) applicative makes for some interesting combinations
10:30:20 <roconnor> alistra: oh I use it a lot with the Get monad of cereal:
10:30:40 <alistra> don't know what that is
10:30:56 <roconnor> mkPoint <$> get <*> get
10:31:14 <koeien> also parsers are often nicely written with applicative notation
10:31:21 <roconnor> basically says to deserialize a point, deserialize it's first arugment and then it's second argument and put it together with mkPoint.
10:31:34 <roconnor> ya, I guess deserialization is essentially parsing
10:31:35 <hpc> parsers are even nicer when you use Alternative as well
10:31:41 <koeien> yeah + alternative
10:31:42 <hpc> which depends on Applicative
10:32:02 <parcs`> in yesod if you have "data User = User Text Int (Maybe Text)" you can generate an HTML form with "User <$> areq textField <*> areq intField <*> aopt textField"
10:32:07 <parcs`> tell me that isn't nice :)
10:32:23 <alistra> @src Applicative
10:32:23 <lambdabot> class Functor f => Applicative f where
10:32:23 <lambdabot>     pure  :: a -> f a
10:32:23 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
10:32:28 * mike-burns shrugs
10:32:48 <ben_m> === bookmark so I know where to start reading my log, because this talk about Applicative is interesting but I'm busy in StarCraft :[
10:33:09 <hpc> there's a memoization package somewhere that has a type like memo :: (a -> b) -> stuff -> IO (a -> b)
10:33:10 <Sgeo> http://hackage.haskell.org/package/records why the build failure?
10:33:26 <mike-burns> ben_m: weechat takes care of that for you. irssi has a plugin that takes care of that for you.
10:33:27 <Sgeo> http://hackage.haskell.org/packages/archive/records/0.1.1.5/logs/failure/ghc-7.2 wtf?
10:33:35 <alistra> @src <$>
10:33:35 <lambdabot> f <$> a = fmap f a
10:33:38 <hpc> @hoogle IO (a -> b)
10:33:38 <koeien> Sgeo: it's apparently not ready for ghc 7.2
10:33:38 <lambdabot> Data.Generics.Aliases unGQ :: GenericQ' r -> GenericQ r
10:33:38 <lambdabot> Data.Generics.Schemes everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
10:33:38 <lambdabot> Data.Generics.Schemes everythingBut :: (r -> r -> r) -> GenericQ (r, Bool) -> GenericQ r
10:33:44 <koeien> does it also fail on 7.0?
10:34:09 <ben> mike-burns: What irssi plugin do you use for that?
10:34:19 <ben> I always just note down times and then use /sb goto 12:30 or whatever
10:34:20 <rwbarton> ghc-7.2 uses base-4.4 but the dependency on base excludes 4.4
10:34:24 <MarcWeber> Does anybody have experience with SOAP and Haskell? Are those libraries providing support mature?
10:34:41 <mike-burns> ben: Don't remember; I switched to weechat.
10:34:45 <ben> right :)
10:34:58 <roconnor> alistra: basicially applicative notation is good for begin a generic liftMn without having to write out every possible liftM2 liftM3 liftM4 ...
10:35:03 <roconnor> *for being
10:35:16 <alistra> @src liftM2
10:35:17 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:35:20 <ben> mike-burns: is it's native jabber support good?
10:35:23 <roconnor> @src liftA2
10:35:23 <lambdabot> liftA2 f a b = f <$> a <*> b
10:35:26 <roconnor> @src liftA3
10:35:27 <lambdabot> Source not found. My pet ferret can type better than you!
10:35:28 <alistra> woah
10:35:35 <alistra> i was looking for something like that
10:35:42 <alistra> lol
10:36:05 <mike-burns> ben: I hear good things but I haven't tried it.
10:36:09 <roconnor> well if liftA3 existed it would be liftA3 f a b c = f <$> a <*> b <*> c
10:36:14 <alistra> so if you have a no-monad function
10:36:16 <ninja2> cw 3 vs 3
10:36:28 <alistra> and due to a recent lawsuit you have to rewrite it to use monads
10:36:56 <Sgeo> :t runState
10:36:57 <lambdabot> forall s a. State s a -> s -> (a, s)
10:36:58 <alistra> f a b c d e can be now f <$> a <*>b <*> c  <*> d  <*> e
10:37:00 <hpc> haha alistra
10:37:06 <roconnor> alistra: more or less
10:37:09 <alistra> winning
10:37:17 <alistra> oh my god
10:37:28 <Sgeo> > runState ((++) <$> get <*> get) "Blah"
10:37:29 <alistra> suddenly this is one of the most useful typeclasses
10:37:34 <lambdabot>   mueval: ExitFailure 1
10:37:34 <lambdabot>  mueval: Prelude.undefined
10:37:37 <Sgeo> o.O
10:37:43 <alistra> why nobody says that in the tutorials about Applicative
10:37:48 <roconnor> alistra: basically the applicative laws let you rewrite any applicative expression into that canonical form.
10:38:03 <roconnor> f <$> a1 <*> ... <*> an
10:38:08 <alistra> cool
10:38:13 <alistra> no more
10:38:14 <Sgeo> alistra, be careful if the function you're using on the left of <$> is itself in the applicative
10:38:27 <nand`> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
10:38:29 <nand`> for some fun stuff
10:38:33 <alistra> ma <- a; mb <- b; mc <- c; return $ f ma mb mc
10:38:35 <Sgeo> Say it's something like putStrLn. Then you end up with an IO (IO ())
10:38:41 <roconnor> alistra: ya, no more of that crap
10:39:13 * Sgeo might be excessively focused on that because it bit him once
10:39:23 <roconnor> Sgeo: :D
10:39:26 <koeien> just join it :)
10:40:13 <Sgeo> The thing is, it typechecked, so I didn't realize there was a problem at first, until runtime when the program failed to work
10:40:14 <nand`> or sequence it
10:40:41 <mike-burns> alistra: We distract people with monads so we can keep Applicative for ourselves.
10:41:07 <roconnor> Sgeo: O_o
10:41:18 <alistra> lyah's images and colors are irritating
10:41:21 <roconnor> Sgeo: did you have top level type signatures?
10:41:33 <koeien> Sgeo: ghc would warn in a do-block
10:41:39 <dolio> Instead of 'x <- m ; y <- n ; z <- o ; pure (f z x y y x)' you can simply write '(\x y z -> f z x y y x) <$> m <*> n <*> o'. Isn't that great?
10:41:43 <Sgeo> Not for main. Hmm, I may have missed the warning
10:41:57 <alistra> well most of the applicative examples aren't really making something nicer
10:42:00 <Sgeo> Should main have a top-level type signature?
10:42:01 <koeien> it says "use _ <-"
10:42:01 <alistra> like the monad example
10:42:06 <koeien> Sgeo: optionally.
10:42:16 <roconnor> Sgeo: everything should have a top-level signature
10:42:24 <roconnor> (even though I don't always do that)
10:42:36 <rwbarton> @pl \x y z -> f z x y y x
10:42:36 <lambdabot> flip =<< (flip .) . join . (flip .) . flip . flip f
10:43:06 <ben_m> rwbarton, that's such an improvement! :P
10:43:07 <roconnor> Of course real programers *start* with a top-level siganture and do type directed program refinement to produce their code.
10:43:26 <rwbarton> @pl \x y z -> f x y z z y
10:43:27 <lambdabot> join . (flip .) . flip flip id . (ap .) . f
10:43:35 <alistra> TDD
10:43:38 <hpc> real programmers tell grad students what to write, then go for an extended lunch
10:43:39 <Sgeo> Is it ever useful for main to have a type signature other than main :: IO ()?
10:43:40 <alistra> type driven developement
10:43:46 <koeien> Sgeo: no
10:43:51 <roconnor> alistra: yep!
10:44:20 <roconnor> Sgeo: arguablely main should have type IO Void ... but I'm told this is an extreme view.
10:44:28 <rwbarton> Void?
10:44:33 <rwbarton> oh
10:44:37 <c_wraith> newtype Void = Void Void
10:44:43 <koeien> should putStrLn also have it, then?
10:44:43 <rwbarton> that does seem unnecessarily extreme, yes
10:44:55 <koeien> putStrLn "hello", i mean
10:45:03 <dgpratt> is there a 'is subset of' function around with type "Eq a => [a] -> [a] -> Bool"?
10:45:04 <Sgeo> Wouldn't all IO () need to be replaced with IO Void?
10:45:05 <roconnor> Sgeo: the idea being every program should either be forever or end with a call to System.Exit
10:45:06 <c_wraith> koeien: no, and that's why it's a silly assertion
10:45:08 <Sgeo> Under that proposal?
10:45:21 <Sgeo> Oh
10:45:23 <c_wraith> roconnor: I defy you with my "return undefined"
10:45:24 <roconnor> Sgeo: no, just main
10:45:37 <Sgeo> Ok, I see
10:45:39 <koeien> Void cannot be constructed
10:45:46 <c_wraith> sure it can.  fix Void
10:45:51 <koeien> yeah, undefined. sure.
10:45:55 <Sgeo> Is there a difference between newtype Void = Void Void and data Void?
10:46:00 * edwardk waves hello
10:46:10 <hpc> Sgeo: you can pattern match on a data
10:46:12 <c_wraith> the latter requires an extension
10:46:16 <edwardk> Sgeo: the former is haskell 98
10:46:17 <roconnor> Sgeo: the newtype version is legal Haskell 98
10:46:27 <hpc> oh, the empty data declaration
10:46:29 <tikhonjelvis> dgpratt: I think isInfixOf is what you're looking for.
10:46:38 <hpc> i thought you meant "data Void = Void Void"
10:46:59 <edwardk> data Void = Void !Void works too but its not quite perfect =)
10:47:00 <roconnor> data Void is legal Haskell 2010?
10:47:38 <Sgeo> What would be the type of System.Exit.
10:47:47 <roconnor> @type System.exit
10:47:48 <lambdabot> Not in scope: `System.exit'
10:47:51 <koeien> ExitCode -> IO Void
10:48:00 <roconnor> @hoogle exit
10:48:00 <lambdabot> System.Exit data ExitCode
10:48:01 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
10:48:01 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
10:48:01 <edwardk> ExitCode -> IO a works as well
10:48:11 <dgpratt> tikhonjelvis: I'm thinking of something where "ac" `op` "abc" == True
10:48:17 <rwbarton> and similarly you could just require main to be polymorphic
10:48:25 <edwardk> i tend to prefer that to Void when its able to be anything. results in fewer uses of random combinators to point out absurdity
10:48:27 <tikhonjelvis> dgpratt: Oh, that's what you meant.
10:48:32 <koeien> dgpratt: \xs ys -> all (`elem` ys)
10:48:51 <dgpratt> koeien: that'll work :) thanks
10:48:53 <edwardk> as a rule take Void as an argument and return a polymorphic a
10:49:07 <edwardk> then you can instantiate the result as Void if you want to
10:49:24 <dgpratt> @pl \xs ys -> all (`elem` ys)
10:49:24 <lambdabot> const (all . flip elem)
10:49:26 <roconnor> ya, I'm not entirely sure how isomorphic forall a. IO a and IO (forall a .a) are
10:49:28 <Sgeo> edwardk, main :: IO a?
10:49:51 <Sgeo> Or IO Void?
10:49:52 <roconnor> Sgeo: ya, that is edwardk's proposal
10:49:56 <dgpratt> @pl \ys -> all (`elem` ys)
10:49:56 <lambdabot> all . flip elem
10:50:07 <edwardk> IO a
10:50:21 <roconnor> Sgeo: but this is kinda academic; I don't think anyone is too serious about it.
10:50:49 <edwardk> i personally don't like it for main, but just in the spirit of the current discussion
10:51:09 <rwbarton> but then I won't get to define a function named exFalsoQuodlibet!
10:51:41 <roconnor> edwardk: I still think forall a. IO a and IO (forall a .a) are not the same, but I'm not entirely sure where they would differ.
10:52:32 <edwardk> roconnor: in this case its not a problem because IO actions really only hold 'one result' so you can distribute
10:52:39 <rwbarton> I think they are the same because IO is a functor
10:52:53 <roconnor> rwbarton: you think?
10:53:12 <rwbarton> if I want to go   forall a. IO a -> IO (forall b. b)  I can instantiate a = forall b. b
10:53:23 <hpc> :t (return 5) :: IO (forall a. a)
10:53:24 <lambdabot>     Illegal polymorphic or qualified type: forall a. a
10:53:24 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
10:53:24 <lambdabot>     In an expression type signature: IO (forall a. a)
10:53:35 <hpc> :t (return 5) :: IO a
10:53:36 <lambdabot>     Could not deduce (Num a) from the context ()
10:53:36 <lambdabot>       arising from the literal `5' at <interactive>:1:8
10:53:36 <lambdabot>     Possible fix:
10:53:40 <rwbarton> if I want to go   IO (forall b. b) -> forall a. IO a  then for each a I can fmap with the projection (forall b. b) -> a
10:53:46 <edwardk> Given  limitR :: Adjunction f u => (forall a. u a) -> u (forall a. a)
10:53:53 <edwardk> limitR = leftAdjunct (rightAdjunct (\(x :: forall a. a) -> x))
10:54:05 <edwardk> follows from preservation of limits
10:54:05 <hpc> :t (return 5) `asTypeOf` (undefined :: IO (forall a. a))
10:54:07 <lambdabot>     Illegal polymorphic or qualified type: forall a. a
10:54:07 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
10:54:07 <lambdabot>     In an expression type signature: IO (forall a. a)
10:54:13 <hpc> :t (return 5) `asTypeOf` (undefined :: IO a)
10:54:14 <lambdabot> forall t. (Num t) => IO t
10:54:21 <hpc> voila: difference
10:54:30 <rwbarton> I am worried I am doing something wrong here
10:54:43 <edwardk> and going back is easy
10:55:38 <b0fh_ua> Hi all!
10:55:52 <koeien> hi
10:55:52 <edwardk> you need that preservation of limits to move the forall both in and out.
10:56:03 <rwbarton> yeah that's what worries me
10:56:10 <b0fh_ua> I defined class "Printable a", now I want to define implementation of [Printable a] - how can I do it?
10:56:17 <edwardk> moving it out is doable with any functor
10:56:21 <dmos> Is there a type indexed Map in Haskell available somewhere?
10:56:26 <sipa> b0fh_ua: you mean Printable [a] ?
10:56:26 <koeien> class Printable a => Printable [a], you mean?
10:56:33 <koeien> err, instance*
10:56:34 <b0fh_ua> so i can use operations defined in Printable on list of Printables
10:56:52 <b0fh_ua> sipa: perhaps yes, but a is Printable itself
10:57:00 <koeien> yup like i said
10:57:01 <sipa> what koeien said
10:57:31 <rwbarton> but why can't I "move the forall in" just by setting a = forall b. b
10:57:37 <sipa> knowing dutch, "what koeien said" really sounds funny...
10:57:40 <silver_> can type classes be used instead of existential types? in my mind typeclasses are collections of type, and ET gives same impression, I wonder if ET can be thought as convenience  extension
10:57:56 <silver_> _just_ convenience
10:58:00 <edwardk> rightAdjunct absurd :: Adjunction f u => f Void -> Void -- is the same trick using preservation of colimits for left adjoints
10:58:01 <b0fh_ua> sipa, koeien - so I need to define yet another class for Printable [a] ?
10:58:07 <b0fh_ua> or I didn't get you
10:58:08 <koeien> b0fh_ua: another instance
10:58:11 <koeien> not another class
10:58:25 <b0fh_ua> koeien: instance Printable [a] where ... ?
10:58:35 <koeien> b0fh_ua: yeah, including   Printable a =>
10:58:48 <sipa> b0fh_ua: Printable is a class, it is a property of a type
10:59:01 <sipa> you want to state, that when a belongs to Printable, [a] also belongs to it
10:59:02 <sipa> right?
10:59:20 <sipa> so operations from Printable that work on a, also work on lists of a
10:59:54 <dolio> (\x -> x) :: (forall a. f a) -> f (forall a. a)
11:00:22 <dolio> fmap (\x -> x) :: Functor f => f (forall a. a) -> forall a. f a
11:00:28 <rwbarton> Yeah.
11:00:28 * hackagebot ircbot 0.1.5 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.1.5 (JeremyShaw)
11:00:37 <pshrmn> cabal is giving me this error "base-4.4.1.0 was excluded because of the top level dependency -any" when I try to install the package repa. I tried installing it on a empty cabal setup, but got the very same error. Any ideas?
11:00:44 <rwbarton> Why does this conflict with my intuition about it having to do with the functor commuting with limits
11:00:45 <dolio> Is (\x -> x) . fmap (\x -> x) the identity, and swapping them?
11:01:13 <edwardk> neat
11:01:30 <dcoutts> pshrmn: it's a bad message, it really means that it needs an installed instance of base, the source version on hackage will not do
11:01:37 <tikhonjelvis> pshrmn: I just solved that by specifying an older version of repa, I think. I'm not sure if that was the optimal choice though.
11:02:08 <dcoutts> pshrmn: probably the issue is simply that the package you want needs a different version of base, which means a different version of ghc since base cannot be upgraded
11:02:39 <rwbarton> well one direction is definitely the identity
11:03:12 <The_Journey> is there a way to force evaluation in Haskell?
11:03:12 <edwardk> it is fairly easy if you think of (forall a. a) as Void
11:03:14 <b0fh_ua> sipa: did i miss something?
11:03:34 <hpc> The_Journey: evaluate, or rnf, or seq, or rwhnf, or...
11:03:45 <edwardk> id :: (forall a. f a) -> f Void
11:03:56 <The_Journey> :t seq
11:03:57 <lambdabot> forall a t. a -> t -> t
11:04:01 <edwardk> fmap absurd :: f Void -> forall a. f a
11:04:09 <koeien> > seq 1 2
11:04:09 <hpc> > 5 `seq` 7
11:04:10 <lambdabot>   2
11:04:10 <lambdabot>   can't find file: L.hs
11:04:14 <koeien> > seq undefined 2
11:04:15 <lambdabot>   *Exception: Prelude.undefined
11:04:28 <edwardk> er Functor f => f Void -> forall a. f a
11:04:31 <rwbarton> oh wait.
11:04:39 <The_Journey> so seq a b would force b to be evaluated?
11:04:49 <rwbarton> this "limit" is over a diagram with an initial object, so, yeah.
11:04:54 <koeien> seq x y tests whether x is _|_, if it is, the value of seq x y is _|_, otherwise y
11:05:02 <edwardk> *nods*
11:05:14 <koeien> a good example of seq use is in foldl'
11:05:17 <pshrmn> @dcoutts : Thanks, an older version works.
11:05:17 <lambdabot> Unknown command, try @list
11:05:20 <rwbarton> tried writing down a toy example and thought "hmm, how come I haven't seen this kind of limit before" :)
11:05:22 <dolio> It's somewhat less obvious that fmap void is the identity.
11:05:24 <koeien> @src foldl'
11:05:25 <lambdabot> foldl' f a []     = a
11:05:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:05:59 <The_Journey> ah ok, I see, thank you
11:06:21 <monochrom> a lambdabot @dcoutts command would be nice actually :)
11:06:35 <edwardk> dolio: agreed
11:06:55 <monochrom> also @list is outdated
11:08:01 <monochrom> don't tutorials cover how to force evaluation?
11:08:47 <rwbarton> isn't fmap absurd = id a functor law?
11:09:04 <tikhonje`> Depends on the tutorial, I imagine. I don't remember any of the ones I read talking about forcing evaluation.
11:09:16 <rwbarton> since absurd :: Void -> Void = id
11:09:38 <dolio> Yes.
11:11:10 <rwbarton> or do you mean the composition   (forall a. f a) -> f Void -> (forall b. f b)
11:11:42 <dolio> When you're doing the IO Void -fmap absurd> forall a. IO a -instantiate> IO Void, it's fairly obvious.
11:11:47 <rwbarton> right
11:11:50 <dolio> The other direction is less obvious.
11:12:24 <nand`> why isn't (a <*> b) just defined as: do f <- a; x <- b; return (f x)
11:12:29 <nand`> wouldn't this work for all monads?
11:12:41 <c_wraith> nand`: that's how ap is defined, and it works for all monads
11:12:42 <monochrom> not in the gentle introduction, not in LYAH, probably not in RWH. I guess it's upon my shoulder now.
11:12:49 <dolio> Not all Applicatives are Monads.
11:12:52 <c_wraith> nand`: but applicative is more general than monad
11:12:52 <hpc> nand`: (<*>) isn't defined for monads
11:14:33 <koeien> nand`: there are applicatives which are not monads
11:14:41 <hpc> see: ZipList
11:14:43 <koeien> although i must confess that i only know of one example
11:14:57 <The_Journey> is there any good tutorial on API design in Haskell?
11:15:18 <hpc> The_Journey: don't think so; probably a list of guidelines though
11:15:26 <The_Journey> hpc: ok, thank you
11:15:40 <monochrom> API design is a special case of negotiation between two stakeholders.
11:16:13 <ion> the_journey: “Do unto others what you would have them do unto you.”
11:16:25 <monochrom> look for a tutorial on peaceful resolution of conflicts
11:17:33 <rwbarton> so this less obvious condition in turn reduces to "x :: forall a. f a" meaning that x is a natural transformation from the functor * to the functor f
11:17:57 <ion> And “Avoid making unnecessary typeclasses” which the original passage failed to include.
11:18:34 <rwbarton> @free x :: f a
11:18:35 <lambdabot> Extra stuff at end of line
11:18:45 <rwbarton> @free f a
11:18:46 <lambdabot> Extra stuff at end of line
11:18:57 <rwbarton> it's not going to like this, is it
11:20:24 <rwbarton> I guess I don't have a good enough understanding of what x :: forall a. f a is supposed to mean when f is not a functor to assign a truth value to this
11:20:41 <kuznero> Hi, All!
11:21:29 <dolio> @free IO a
11:21:30 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:21:34 <dolio> @free x :: IO a
11:21:34 <lambdabot> $map_IO f x = x
11:21:53 <rwbarton> Oh
11:22:11 <rwbarton> @free x :: F a
11:22:11 <lambdabot> $map_F f x = x
11:23:08 <rwbarton> I guess it knows F is a functor because I used the letter F.
11:23:16 <danr> was there some conclusion between the differences of forall a . IO a and IO (forall a . a) ?
11:23:18 <nand`> @free x :: [a]
11:23:18 <lambdabot> $map f x = x
11:23:55 <nand`> ^- doesn't that only hold true if f == id?
11:24:09 <nand`> =*
11:24:10 <hpc> @free x :: a -> a
11:24:11 <lambdabot> f . x = x . f
11:24:33 <shachaf> nand`: What other function could f be?
11:24:39 <rwbarton> hmm, so can I turn every haskell type constructor of one argument into a functor on Hask^op x Hask by splitting the occurrences of the variable into negative and positive positions? then "forall a." is an end?
11:24:50 <nand`> seems like a peculiar letter for id to me
11:25:04 <rwbarton> nand`: "x :: [a]" there means "x :: forall a. [a]".
11:25:11 <danr> @free g :: a -> b -> a
11:25:11 <lambdabot> f . g x = g (f x) . h
11:25:12 <dolio> Yes.
11:25:38 <danr> @free z :: (a -> a) -> a -> a
11:25:38 <lambdabot> f . g = h . f => f . z g = z h . f
11:25:52 <danr> whoa, what is this magic?
11:26:05 <danr> is it from Wadler's paper?
11:26:09 <hpc> yes
11:26:15 * danr goes read Wadler's paper
11:27:03 <roconnor> @free sortBy
11:27:04 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
11:27:08 <roconnor> this is one of my favourite
11:27:30 <cheater_> why?
11:27:42 <roconnor> though it is more clearly written as (forall x y. g x = h (f x) (f y)) => $map f . sortBy g = sortBy h . $map f
11:27:55 <roconnor> cheater_: it feel a little non-trival
11:28:00 <copumpkin> that's cool
11:28:07 <roconnor> (forall x y. g x y = h (f x) (f y)) => $map f . sortBy g = sortBy h . $map f
11:28:12 <cheater_> ok
11:28:53 * danr is amazed
11:29:19 <danr> (of such trivialites ^^)
11:29:32 <roconnor> and in particular
11:29:54 <roconnor> map f . sortBy (\x y -> h (f x) (f y)) = sortBy h . map f
11:30:41 <dolio> map f . sortBy (h `on` f) = sortBy h . map f
11:30:42 <roconnor> of course, after thinking about it for a few minutes, it feels obviously true.
11:30:50 <roconnor> dolio: ya, that is better
11:30:54 <danr> @free foldr
11:30:55 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
11:31:15 <hpc> dolio: when put like that, it does seem obvious
11:31:25 <danr> dolio: yeah nice explanation
11:31:29 <roconnor> danr: that would be foldr-map fusion I think
11:32:11 <roconnor> er, I think.
11:32:12 <danr> roconnor: aha!
11:32:17 * roconnor isn't sure anymore
11:32:28 <dolio> It's better, I think.
11:32:50 <ion> @free foldr
11:32:51 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
11:32:51 <roconnor> oh maybe it is more general than foldr-map fusion
11:32:59 <roconnor> foldr-map fusion is when g is set to id
11:33:05 <rwbarton> right
11:33:17 <rwbarton> and g is taking care of the accumulator
11:33:37 <danr> @free mapAccumL
11:33:38 <lambdabot> (forall x. $map_Pair f h . k x = p (f x) . g) => $map_Pair f ($map h) . mapAccumL k y = mapAccumL p (f y) . $map g
11:33:39 <copumpkin> pretty cool :)
11:34:11 <copumpkin> @free zipWith
11:34:12 <lambdabot> (forall x. h . k x = p (f x) . g) => $map h . zipWith k xs = zipWith p ($map f xs) . $map g
11:35:18 <danr> @free fix
11:35:19 <lambdabot> f . g = h . f => f (fix g) = fix h
11:35:28 <roconnor> I'm pretty good with free theorems now.  I used them a lot in my recent techincal report to simplify a lot of proofs.
11:35:32 * hackagebot hbro 0.8.0.0 - A minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-0.8.0.0 (koral)
11:35:34 * hackagebot hbro-contrib 0.8.0.0 - Third-party extensions to hbro.  http://hackage.haskell.org/package/hbro-contrib-0.8.0.0 (koral)
11:35:44 <danr> roconnor: link, please? :)
11:35:58 <rwbarton> @free free :: Ptr a -> IO ()
11:35:58 <lambdabot> $map_IO $id . free = free . $map_Ptr f
11:36:07 <copumpkin> lol
11:36:17 <hpc> haha
11:36:18 <roconnor> danr: http://arxiv.org/abs/1103.2841v1  <-- in the appendix
11:36:18 <copumpkin> @free unsafeCoerce :: a -> b
11:36:19 <lambdabot> g . unsafeCoerce = unsafeCoerce . f
11:36:25 <copumpkin> excellent, excellent
11:36:26 <roconnor> danr: the v1 is important in that link
11:36:45 <parcs`> @free on
11:36:46 <lambdabot> (forall x. g . k x = p (f x) . f) => f . q = f1 . h => g . on k q y = on p f1 (h y) . h
11:36:59 <roconnor> danr: even still, the proofs are long and tedious and not machine checked :(
11:37:06 <copumpkin> roconnor: what's wrong with v2?
11:37:23 <parcs`> @free ($)
11:37:23 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:37:27 <roconnor> copumpkin: it is the conference edition so all the technical details are removed
11:37:32 <copumpkin> aha
11:37:35 <copumpkin> where'd you submit it?
11:37:40 <parcs`> @free flip
11:37:41 <lambdabot> Expected variable or '.'
11:37:43 <ion> @free id
11:37:44 <lambdabot> f . id = id . f
11:37:45 <roconnor> copumpkin: Workshop on Generic Programming.
11:37:49 <copumpkin> cool
11:37:50 <Sgeo> @free apply :: (a -> b) -> a -> b
11:37:51 <lambdabot> g . h = k . f => g . apply h = apply k . f
11:37:55 <roconnor> copumpkin: there was a big todo about it and the ACM and copyright
11:39:22 <roconnor> hmm, maybe it is only Appendix F that is long and tedious
11:39:47 <roconnor> I'd like to see other people proofs of the composition law for applicative functors.
11:40:04 <roconnor> cause mine are always huge jumbles of symbol shuffling.
11:40:18 <copumpkin> :O
11:40:32 <roconnor> that make heavy use of lambdabot's pointless function
11:40:39 <rwbarton> composition law?
11:41:09 <ion> @type (<*>) (<*>)
11:41:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (f (a -> b) -> f a) -> f (a -> b) -> f b
11:41:15 <ion> @type (<*>) (<*>) (<*>)
11:41:16 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
11:41:16 <lambdabot>     Probable cause: `<*>' is applied to too few arguments
11:41:16 <lambdabot>     In the second argument of `(<*>)', namely `(<*>)'
11:41:19 <Sgeo> @free fmap
11:41:20 <lambdabot> Expected variable or '.'
11:41:21 <roconnor> that pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
11:41:41 <Sgeo> @free fmap :: (Functor f) => (a -> b) -> f a -> f b
11:41:42 <lambdabot> Extra stuff at end of line
11:41:55 <Sgeo> @free fmap ::  (a -> b) -> f a -> f b
11:41:56 <lambdabot> Extra stuff at end of line
11:42:24 <Sgeo> @free fmap ::  (a -> b) -> (f a) -> (f b)
11:42:25 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
11:42:28 <ion> You’ll need to make the fs uppercase, and it’ll probably output $map_F or something.
11:42:34 <roconnor> SG11: the free theorem for fmap proves that for every type constructor has at most one functor instance.
11:42:36 <roconnor> er
11:42:37 <Sgeo> @free fmap ::  (a -> b) -> F a -> F b
11:42:37 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
11:42:39 <roconnor> Sgeo: ^^
11:43:09 <roconnor> Sgeo: or that any two functor instances of the same type constructor are equal
11:43:43 <danr> @free fst
11:43:44 <lambdabot> f . fst = fst . $map_Pair f g
11:44:18 <danr> is map_Pair (***)?
11:44:29 <roconnor> @type (***)
11:44:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:44:44 <roconnor> danr: ya, intantiated at the (->) arrow
11:44:52 <danr> roconnor: thanks :)
11:44:53 <monochrom> no, but \f -> f***f
11:45:18 <monochrom> sorry, yes
11:45:34 * monochrom blames the bifunctor
11:47:17 <monochrom> an application of @free fst: http://groups.google.com/group/comp.lang.haskell/msg/a1444af2476a6a53
11:48:39 <danr> monochrom: ah, interesting
11:48:52 <monochrom> in Java, Python, ... their fst does not necessarily give back the first element, since they have various versions of "type case".
11:49:41 <parcs`> @free P.flip
11:49:41 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:49:49 <parcs`> :t Prelude.flip
11:49:50 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:49:52 <parcs`> @free Prelude.flip
11:49:52 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:50:03 <hpc> @free flip :: (a -> b -> c) -> b -> a -> c
11:50:03 <hpc> (a -> b -> c) -> b -> a -> c
11:50:04 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
11:50:14 <hpc> argh, keyboard
11:50:41 <monochrom> isn't Haskell exciting?
11:50:56 <erus`> has anyone got any stats on haskell popularity / time ?
11:51:18 <daimrod> TIOBE ?
11:51:47 <Enigmagic> t*1.0000000008
11:51:55 <ion> erus: About thirteen pops a second.
11:52:02 <Enigmagic> soon we will take over the world
11:52:34 <monochrom> I don't think there is such stats
11:52:51 <erus`> platform downloads ?
11:52:53 <monochrom> ah, but wait, you can estimate by crawling reddit and stackoverflow
11:53:20 <alistra> erus`: http://steve-yegge.blogspot.com/2010/12/haskell-researchers-announce-discovery.html
11:53:32 <b0fh_ua> http://hpaste.org/56394 - can somebody please advice, how can I specify a list of both String and functions (OptionsMap -> String) as argument to buildOptions?
11:53:33 <monochrom> haha
11:53:50 <erus`> alistra: i remember when i read that a year ago or so i thought it was about me
11:54:24 <alistra> well it's about right ;P
11:54:51 <roconnor> I really don't like yegge's haskell post.
11:55:07 <roconnor> it is apparent to me that he doesn't know enough about haskell to properly joke about it
11:55:11 <alistra> feeling insulted?
11:55:21 <roconnor> I, of course, prefer my jokes:
11:55:56 <monochrom> perhaps to some extent, jokes on ___ relies on not knowing ___ enough
11:56:20 <Jeanne-Kamikaze> so... has anyone managed to link a haskell library with a C static library built by the same cabal package? Google doesn't help, and my knowledge of Distribution.Simple is quite limited.
11:56:33 <roconnor> http://www.haskell.org/pipermail/haskell-cafe/2009-January/053892.html
11:57:10 <monochrom> for example, you know "math" jokes that are really just word plays like sin x / n = 6. it relies crucially on not knowing enough math
11:57:59 <roconnor> monochrom: I guess you are right
11:58:09 <ion> lim₍₈→₉₎ √(8) = 3
11:58:20 <roconnor> But when yegge says: "That, or it was an off-by-1 error not detectable by our type system," Van Der Linde added. "But we don't, uh, like to dwell on, I mean with good unit testing practices we can, um... sorry, I need to get some water."
11:58:38 <roconnor> I can't help but think than anyone doing integer indexing in Haskell is doing it wrong.
11:58:46 <roconnor> and then it just becomes unfunny to me :)
11:59:25 <roconnor> because clearly he is trying to poke at the inadequecies of the type system.
11:59:41 <roconnor> and the type system is inadquate and you could poke fun at it.
12:00:01 <Silvah> :t poke
12:00:02 <lambdabot> Not in scope: `poke'
12:00:15 <shachaf> Yes, it's pretty much unfunny.
12:00:23 <shachaf> There are much better criticisms one could make of Haskell.
12:01:05 <Silvah> Like, for example, the fact that Haskell is poor at hash tables!
12:01:14 <roconnor> *lol*
12:01:48 <monochrom> there is only one math joke I know that is a result of really knowing math. a phd student invented a new class of rings (i.e., the usual ring axioms plus his own axioms), and they have really nice properties. it's his thesis, and he presented it at his defense. a prof asked, "what are some examples of this kind of rings?" the student couldn't give one. the prof went to the blackboard and showed that the only example was {0}.
12:02:02 <Silvah> What's the type of 'poke', anyway?
12:02:06 <roconnor> monochrom: that's no joke
12:02:33 <shachaf> monochrom: I always heard that it turned out that there were no examples.
12:02:53 <Jeanne-Kamikaze> Silvah, poke is in Foreign.Storable
12:03:12 <Jeanne-Kamikaze> hoogle is your friend: http://www.haskell.org/hoogle/
12:03:23 <monochrom> anyway, kudos for the Bool haddock!
12:03:48 <danr> wow. theorems for free is quite the paper
12:03:56 <roconnor> monochrom: too bad I got the arrows backwards :(
12:04:27 <danr> i also find it very interesting that Wadler refers to other papers with models for lambda calculus, I have not encountered that before
12:04:27 <Silvah> poke :: Ptr a -> a -> IO ()
12:04:35 <danr> </mumble>
12:05:30 <Silvah> I can never get the arguments right.
12:05:33 * hackagebot haskell-mpi 1.2.0 - Distributed parallel programming in Haskell using MPI.  http://hackage.haskell.org/package/haskell-mpi-1.2.0 (DmitryAstapov)
12:05:52 <Silvah> I always think it's the other way around, dunno why.
12:06:03 <roconnor> danr: every closed cartesian category is a model of the lambda calculus
12:06:05 <roconnor> ... so I'm told
12:06:28 <dolio> Which lambda calculus?
12:07:02 <roconnor> dolio: *the* lambda calculus. :)
12:07:14 <Silvah> Some more boring theory? Nice.
12:07:16 <pdxleif> The one with the lambdas?
12:08:12 <roconnor> actually, I think it is only the Simply Typed Lambda Calculus that I'm refering to
12:08:22 <dolio> Yes.
12:08:43 <dolio> Simply typed lambda calculus with products is roughly the internal language of Cartesian closed categories.
12:09:08 <danr> yes, indeed. in Wadler's paper he's refering to System F
12:10:00 <nand`> “The Perl lists are brimming with discussions about the value of adding monads to Perl. "We don't really know what they do, but it doesn't make sense _not_ to have something in Perl," said Perl hacker Landon Ricketts.”
12:10:00 <nand`> haha
12:10:21 <danr> nand`: nice!
12:10:32 <dolio> For untyped lambda calculus, you need categories with objects that are self-exponential and stuff like that.
12:11:55 <roconnor> dolio: great scott!
12:12:29 <dolio> Haskell has those, of course.
12:12:42 <dolio> newtype U = In (U -> U)
12:13:03 <b0fh_ua> Can somebody please tell me if it is possible to create a list of types belonging to same class?
12:13:29 <koeien> b0fh_ua: you'd need an existential type
12:13:31 <Jeanne-Kamikaze> you mean type class ?
12:13:32 <Jeanne-Kamikaze> yeah
12:13:47 <koeien> (provided I interpret your question correctly.)
12:13:54 <dolio> Also 1 ~= 1^1 is easy, but that's trivial.
12:14:07 <Jeanne-Kamikaze> b0fh_ua, http://www.haskell.org/haskellwiki/Existential_type
12:14:26 <b0fh_ua> koeien: like if I have "class Printable a where ..." and implementations of it for String and (String->String), then I want to create list of items of type String and (String->String)
12:14:37 <b0fh_ua> I don't think that existential types would work there
12:14:42 <monochrom> of course, untyped lambda calculus has D = D^D written all over it. or D = stuff + D^D which doesn't help.
12:14:45 <danr> dolio: do you know of an example where a datatype data U = In (U -> U) | ... (with possibly more constructors) is useful?
12:14:58 <koeien> you can use Either String (String -> String) in this case
12:15:01 <koeien> or an existential,
12:15:11 <b0fh_ua> koeien: how to use existential?
12:15:26 <koeien> data PrintableData = forall a. Printable a => PrintableData a
12:15:33 <b0fh_ua> koeien: http://hpaste.org/56394
12:15:39 <b0fh_ua> that is the code I'm working with
12:15:40 <dolio> danr: Not off hand.
12:16:01 <roconnor> dolio: don't you use it to implement the untyped lambda calculus?
12:16:12 <dolio> I don't do that. :)
12:16:27 <dolio> Actually, interpreting lambda calculus typically involves products, too.
12:16:51 <roconnor> danr: I think if you pick up a book on domain theory you will see that sort of contruction
12:16:56 <dolio> So I think the typical categories for untyped lambda calculus end up with an object U such that U x U ~= U ~= U^U.
12:17:30 <danr> roconnor: yes i guess it could be used as a translation from some lambda calculus AST to a domain
12:17:39 <danr> but I'm not sure what to use it for when the translation is done
12:17:50 <roconnor> danr: you want to write a domain such that everything is either a function, or a pair, or a disjoint sum or an atom
12:18:07 <monochrom> isn't self-reference exciting? :)
12:18:19 <danr> roconnor: sounds reasonable
12:18:25 <roconnor> data U = Fun U -> U | Prod U U | SumL U | SumR U | Atom Atom
12:18:41 <danr> and compile ::  Expr -> U ?
12:19:00 <monochrom> compile :: U -> U :)
12:19:13 <b0fh_ua> koeien: not sure how to define operations for PrintableData then
12:19:17 <ion> decompile :: U -> U
12:19:39 <koeien> b0fh_ua: you can only use functions from the type class on that
12:19:53 <b0fh_ua> koeien: not sure that I did understand
12:19:53 <danr> yeah, that's what I'm wondering too, what to do with a U?
12:20:16 <b0fh_ua> koeien: so I don't need to declare instance of this class?
12:20:48 <monochrom> I was joking. depending on what you mean by compile, Expr->U may be right
12:20:55 <roconnor> danr: maybe you use it for denotation semantics and evaluate some expression and pray you get an Atom out
12:21:08 <monochrom> someone has to execute U, of course
12:21:20 <danr> roconnor: of course! thanks
12:21:34 <danr> at least you don't really want a Fun object out
12:21:37 <monochrom> just like in the real world you have compile :: C -> X86. well, some one has to execute the X86.
12:21:37 <aristid> monochrom: execute :: U -> U? :)
12:21:54 <monochrom> I'm hoping execute :: U -> IO ()
12:22:17 <danr> roconnor: wouldn't you need application in the domain too?
12:22:19 <monochrom> it's all interpreters all the way down
12:22:31 <roconnor> danr: I think application is only in Expr
12:22:35 <ion> execute :: X86 -> State Semiconductors ()
12:22:39 <roconnor> danr: I'm not sure though
12:23:09 <ion> QuantumState Semiconductors ()
12:23:13 <danr> roconnor: hmm, but how else would you translate an application from Expr?
12:23:24 <rwbarton> you'd evaluate it
12:23:43 <roconnor> eval (Appl f e) = case (eval f) of Fun ff -> ff (eval e)
12:23:56 <danr> rwbarton: ok so we would rather define denotate :: Eval -> U than compile :: Eval -> U? if you get the difference
12:23:59 <aristid> roconnor: wouldn't Fun need to have Expr on the right hand side, then?
12:24:26 <danr> aristid: no, ff has type U -> U
12:24:50 <monochrom> oh what fun it is to ride in a one-type lambda cal, hey!
12:24:58 <monochrom> err, s/ride/write/
12:25:15 <aristid> danr: but you can't have parameter-dependent function applications, then?
12:25:50 <danr> aristid: what do you mean?
12:26:31 <aristid> danr: say, \u -> f u u
12:26:38 <aristid> danr: how'd that be represented?
12:27:50 <roconnor> \(f :: U -> U -> U)  -> Fun (\u -> f u u)
12:28:22 <roconnor> or if f :: U then
12:29:04 <roconnor> \(f :: U)  -> Fun (\u -> let Fun ff = f in let Fun fff = ff u in fff u)
12:29:27 <danr> aristid: what roconnor said ;)
12:30:34 <ion> \(u :: u) -> u (\u -> u u u = u u u u u = u u u u u u)
12:30:40 <dgpratt> I'm thinking it would be cool if there were a simple, general way to partially specify a function type and let Haskell figure out the rest
12:30:58 <alistra> rest of the type
12:31:03 <alistra> or rest of the function
12:31:03 <monochrom> many people has wanted that
12:31:05 <roconnor> dgpratt: that would be cool
12:31:07 <dgpratt> I know you can achieve this with scoped type signatures
12:31:12 <dgpratt> alistra: the type\
12:31:12 <hpaste_> chrisdone pasted “tramp” at http://hpaste.org/56395
12:31:14 <ion> For more information, http://uncyclopedia.wikia.com/wiki/AAAAAAAAA!
12:31:42 <tty7> alistra: rest of the function would be cool :D
12:31:54 <alistra> tty7: agda
12:31:54 <dgpratt> tty7: theorems for free?
12:31:55 <aristid> roconnor: wait, using haskell to represent stuff is evil
12:32:06 <aristid> roconnor: well... you know what i mean
12:32:10 <alistra> dgpratt: doesn't haskell like
12:32:11 <monochrom> wait, that looks like javascript
12:32:14 <alistra> do this already
12:32:16 <alistra> look
12:32:38 <alistra> :t (\x y z -> (x y) z)
12:32:39 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
12:32:41 <alistra> magic
12:32:46 <alistra> of figuring types out
12:33:01 <roconnor> alistra: now try that with polymorphic recursion
12:33:02 <dgpratt> alistra: it may, I'm certainly not the world's foremost Haskell expert :)
12:33:35 <tty7> alistra: no, i mean like "doSomethingIWantToDoWithThatInput input = ..." and haskell completes that ;)
12:34:01 <alistra> roconnor: well you can't figure types out if they're not solvable :P
12:34:28 <roconnor> alistra: there are solution to polymorphic recursion, but there is no longer a unique most general solution IIRC.
12:34:31 <alistra> i have a vim binding, that pastes a function type into the file
12:35:08 <alistra> roconnor: well, why would you want a specific one then, is haskell supposed to read your mind?
12:35:09 <alistra> :|
12:35:38 <roconnor> alistra: but the entire type signature is complates, so it would be nice to give a partial type, and let haskell figure out the rest.
12:35:44 <alistra> tty7: agda works that way
12:35:44 <monochrom> oh! chrisdone's "tramp" means trampolining
12:35:49 <alistra> if you supply the type tty7
12:35:52 <roconnor> just like dgpratt wants
12:36:34 <monochrom> I write "main =" and the editor completes that. probably to "main = return ()"
12:36:40 <alistra> roconnor: can you give an example of polymorphoc recursion
12:36:56 <alistra> because i still don't know where the problem is
12:37:06 <monochrom> at the current level of technology, #haskell is your program completion algorithm
12:37:13 <roconnor> alistra: the most natural ones come from using non-uniform recursive types.
12:37:25 <roconnor> but presumablly the internet has some examples
12:37:26 * roconnor looks
12:37:26 <monochrom> data X a = X (a, a)
12:37:29 <alistra> i don't know what those word mean
12:37:34 <alistra> non-uniform
12:37:42 <alistra> in this context
12:38:00 <roconnor> monochrom gives an example of a non-uniform (recursive) data type.
12:38:06 <aristid> monochrom: why not a newtype, or data X a = X a a?
12:38:18 <roconnor> er
12:38:24 <alistra> so when it's uniform?
12:38:34 <roconnor> monochrom meant data X a = Foo (X (a,a))
12:38:43 <monochrom> oh, oops
12:38:55 <aristid> oh
12:38:59 <dolio> @type let f [_] = 1 ; f _ = f [()] in f
12:39:00 <lambdabot> forall t. (Num t) => [()] -> t
12:39:18 <roconnor> but better is data PerfectBinTree a = Leaf | Node (PrefectBinTree (a,a))
12:39:23 <monochrom> data X a = Foo (X (a,a)) | Fou  to make it useful
12:39:33 <danr> dolio: fancy strict constant 1 function? :)
12:39:38 <roconnor> er
12:39:43 <roconnor> but better is data PerfectBinTree a = Leaf a | Node (PrefectBinTree (a,a))
12:40:02 <ion> FordPrefectBinTree
12:40:07 <alistra> roconnor: ok, and the functions don't type by defau;t?
12:40:26 <roconnor> PerfectBinTree a is a type that has exactly 2^n leaves for some n
12:40:43 <dolio> @type let f 0 v = show v ; f n v = f (n-1) (v, v) in f
12:40:44 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, a)
12:40:44 <lambdabot>       Expected type: t -> (a, a) -> String
12:40:44 <lambdabot>       Inferred type: t -> a -> String
12:40:46 <roconnor> alistra: I beleive recursive functions will not type by default.
12:40:59 <dolio> @type let f :: Show a => Int -> a -> String ; f 0 v = show v ; f n v = f (n-1) (v, v) in f
12:40:59 <lambdabot> forall a. (Show a) => Int -> a -> String
12:41:08 <roconnor> alistra: try writing the depth function and see if you get an error
12:41:24 <roconnor> I guess I should try too
12:41:26 <alistra> roconnor: @ 2^n doesn't seem right
12:41:49 <monochrom> depth (Leaf a) = 1; depth (Node t) = 1 + depth t; try this
12:42:49 <roconnor> oh poo, it compiled
12:42:55 <roconnor> maybe flatten would be better
12:44:26 <alistra> ok
12:44:32 <alistra> 1.hs:4:20:
12:44:32 <alistra>     Occurs check: cannot construct the infinite type: t0 = (t0, t0)
12:45:11 <Enigmagic> and don't forget about RankN types :D
12:47:45 <roconnor> ah good, depth doesn't work without a type signature
12:47:51 <alistra> uh
12:47:53 <alistra> and why is that?
12:47:58 <roconnor> I just messed up my type the first time
12:48:01 <alistra> i mean are there any variants?
12:48:02 <alistra> for this?
12:48:03 <roconnor> alistra: polymorphic recursion
12:48:07 <roconnor> alistra: that is when
12:48:30 <roconnor> alistra: you make a recursive call to a polymorphic function but are using a different instance of the polymorphic variable than the one you were called with.
12:48:40 <alistra> i see
12:48:44 <alistra> but i ask why, not when
12:48:58 <dolio> It's a (necessary) defect of the Hindley-Milner inference algorithm.
12:49:17 <roconnor> type inference for polymorphic recursion is either undecidable or there is no unique most general type or H-M sucks.
12:49:20 <roconnor> I forget which
12:50:01 <Enigmagic> alistra: or there is just no way to know at compile time, like in this (from a real world app): http://hpaste.org/56397
12:50:05 <aristid> roconnor: if it was just H-M sucks, the one of the simons would certainly have implemented it anyways as a language extension :)
12:50:14 <alistra> well if it's undecidable there's nothing we can do :D
12:50:48 <c_wraith> roconnor: well, the MLs entirely forbid polymorphic recursion.  So it has to be a limitation in what can be inferred.
12:50:50 <alistra> Enigmagic: undecidable usually meanst not way to know at compile time :D
12:51:06 <theddy> anyone know a way to run a function that returns (Maybe a) inside a do block for MaybeT?
12:51:46 <Enigmagic> alistra: yeah
12:51:58 <dolio> To do polymorphic recursion, you need to annotate your definition with the proposed type (and check it). Hindley-Milner doesn't include that.
12:52:01 <aristid> :t runMaybeT
12:52:01 <lambdabot> Not in scope: `runMaybeT'
12:52:13 <roconnor> theddy: maybe mzero return
12:52:20 <roconnor> @type maybe mzero return
12:52:21 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
12:53:07 <roconnor> theddy: hmm, that might not work properly in every case though.
12:53:27 <theddy> MaybeT is not monadplus...
12:53:31 <theddy> .
12:53:33 <hunz_brazil> :t liftM
12:53:33 <theddy> ?
12:53:34 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:53:43 <roconnor> @type MaybeT . return
12:53:44 <lambdabot> Not in scope: data constructor `MaybeT'
12:54:00 <aristid> theddy: you have Maybe and want MaybeT?
12:54:10 <aristid> i understood your question the opposite way
12:54:22 <roconnor> theddy: how about MaybeT . return
12:54:30 <theddy> I have maybe and want maybeT
12:54:55 <aristid> oh, ok
12:54:58 <roconnor> I think that will work
12:55:11 <hunz_brazil> just return . return won`t work?
12:55:15 <Philippa> roconnor: it's undecidable in the absence of annotations, yeah
12:55:33 <roconnor> Philippa: I figured you'd know the answer
12:55:55 <Philippa> there are some interesting chunks of the problem that're decidable given intersection types
12:56:09 <Philippa> (and that's probably even higher on "I figured you'd know something like that"!)
12:56:13 <hunz_brazil> :t return
12:56:14 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:56:29 <hunz_brazil> :t MonadT
12:56:30 <lambdabot> Not in scope: data constructor `MonadT'
12:57:36 <danr> roconnor: is the tex version of multiplate available somewhere? I would like to see how you do the code listings :)
12:57:54 <roconnor> hunz_brazil: MaybeT :: m (Maybe a) -> MaybeT m a
12:58:17 <roconnor> danr: it is written in TeXmacs; I could send you the sources to that though.
12:58:18 <hunz_brazil> ops, I spelled MonadT
12:58:38 <alistra> @hoogle MaybeT
12:58:39 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
12:58:39 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
12:58:39 <lambdabot> Control.Monad.Trans.Maybe newtype MaybeT m a
12:58:49 <hunz_brazil> MaybeT is also a Monad, so "return . return" should do the trick… right?
12:58:55 <roconnor> danr: As I recall I do the code listings painfully by hand
12:59:03 <roconnor> hunz_brazil: nope
12:59:25 <sipa> roconnor: considered lhs2tex?
12:59:31 <danr> roconnor: feel free to send it to danr \at student.chalmers.se
12:59:39 <hunz_brazil> :t let f a = Just a; g = liftM f in g
12:59:40 <lambdabot> forall (m :: * -> *) a1. (Monad m) => m a1 -> m (Maybe a1)
12:59:44 <roconnor> sipa: I don't use TeX
13:01:05 <roconnor> danr: you want the sources to v1 right?
13:01:56 <theddy> :t MaybeT . return
13:01:58 <lambdabot> Not in scope: data constructor `MaybeT'
13:02:09 <danr> roconnor: yes please, that's the version I am reading now
13:02:21 <hunz_brazil> :t let x = Just 1 in return x
13:02:22 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m (Maybe t)
13:02:53 <roconnor> danr: done
13:03:00 <theddy> roconnor: You were right with that one
13:04:48 <erus`> whats the T bit at the end mean?
13:04:55 <koeien> transformer
13:05:17 <alistra> erus`: like the big truck-people
13:05:21 <alistra> from the cartoon
13:05:26 <danr> roconnor: thank you!
13:05:34 <hunz_brazil> erus`: http://en.wikibooks.org/wiki/Haskell/Monad_transformers
13:05:35 <erus`> :|
13:05:46 <alistra> erus`: it's EXACTLY like that
13:09:57 <erus`> @hoogle guarf
13:09:58 <lambdabot> No results found
13:09:59 <erus`> @hoogle guard
13:10:00 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
13:10:00 <lambdabot> Language.Haskell.TH.Syntax data Guard
13:10:00 <lambdabot> Language.Haskell.TH data Guard
13:11:52 <koeien> @src guard
13:11:53 <lambdabot> guard True  =  return ()
13:11:53 <lambdabot> guard False =  mzero
13:15:19 <parcs`> > let f = let ?a = ?a + 1 in ?a in let ?a = 5 in f
13:15:20 <lambdabot>   6
13:16:12 <parcs`> > let f = let ?a = ?a + 1; ?a = ?a + 1 in ?a in let ?a = 5 in f
13:16:13 <lambdabot>   6
13:19:22 <parcs`> > let f = let ?a = ?a + 1 in let ?a = ?a + 1 in ?a in let ?a = 5 in f
13:19:24 <lambdabot>   7
13:28:20 <JoeyA> Does hoogle data --all download hoogle info for everything on Hackage?
13:28:48 <erus`> can i test bindings inside a where clause in ghci somehow?
13:29:40 <monochrom> no
13:30:43 <XexonixXexillion> Is there a predefined function to turn a word into a list of bytes?
13:30:56 <XexonixXexillion> sorry, list of bits
13:31:27 <tech2> XexonixXexillion: how would you represent a bit?
13:32:02 <parcs`> XexonixXexillion: on hackage somewhere
13:32:13 <XexonixXexillion> probably with something like data Bit = On | Off
13:33:08 <carpi> I hav a function that has multiple pattern matching definitions and after the last definition I am using a where clause to define a few local functions. Are these local functions accessible to the other pattern matching definitions above?
13:33:20 <carpi> because ghci seems to throw and error
13:33:28 <koeien> unfoldr (\x -> if x == 0 then Nothing else Just (mod x 2, div x 2))
13:33:45 <rwbarton> they only apply to the specific pattern-matching clause they are attached to
13:33:54 <koeien> you can use case if you don't want that
13:33:56 <rwbarton> since in general they could depend on the values matched in that pattern
13:34:12 <koeien> or helper functions
13:34:19 <koeien> XexonixXexillion: ^
13:34:34 <carpi> helper functions?
13:34:40 <carpi> how do i define helper?
13:34:49 <rwbarton> as in, move your local functions to the top level
13:34:50 <koeien> i mean, restructure your code a bit
13:35:06 <rwbarton> or other restructurings are possible, yes
13:35:33 <carpi> thanks.. for the clarification.. i think ill try the case first
13:35:52 <shachaf> Hmm, I always thought that "where" was per-=-sign.
13:35:55 <shachaf> I guess it isn't, quite.
13:36:17 <shachaf> > let f x | x == 4 = y | otherwise = y where y = x
13:36:18 <lambdabot>   not an expression: `let f x | x == 4 = y | otherwise = y where y = x'
13:36:22 <shachaf> > let f x | x == 4 = y | otherwise = y where y = x in f 5
13:36:23 <lambdabot>   5
13:36:24 <shachaf> > let f x | x == 4 = y | otherwise = y where y = x in f 4
13:36:25 <lambdabot>   4
13:36:33 <rwbarton> I guess they are inside the top-level pattern match, but outside pattern guards, if you use those
13:37:12 <shachaf> > let f x | Just n <- x = y | n <- 4 = y where y = n in f 4
13:37:13 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
13:37:13 <lambdabot>    arising from the lite...
13:37:19 <shachaf> > let f x | Just n <- x = y | n <- 4 = y where y = n in f (Just 4)
13:37:20 <lambdabot>   n
13:37:28 <shachaf> Blah.
13:37:29 <rwbarton> :)
13:37:46 <rwbarton> Well, that answers that.
13:37:56 <shachaf> I'd prefer "not in scope: n"
13:38:38 <rwbarton> That's what you get for writing non-hygienic code! Only use freshly allocated symbols.
13:38:42 <rwbarton> I recommend random unicode letters.
13:39:11 <shachaf> There's still a possibility of collisions.
13:39:20 <shachaf> Clearly what we need in Haskell is GENSYM.
13:39:47 <rwbarton> @pl let f x | Just n <- x = y | n <- 4 = y where y = n in f
13:39:47 <lambdabot> (line 1, column 9):
13:39:47 <lambdabot> unexpected "|"
13:39:47 <lambdabot> expecting pattern or "="
13:40:00 <carpi> is it possible to perform case pattern matching on multiple arguments?
13:40:10 <carpi> as in case x y of 1 2 -> True?
13:40:13 <shachaf> carpi: You can case (x,y) of (1,2)
13:40:16 <koeien> case (x,y)
13:40:17 <geekosaur> not like that but . that
13:40:32 <koeien> (technically you're still pattern matching on one argument)
13:40:37 * hackagebot snowglobe 1 - randomized fractal snowflakes demo  http://hackage.haskell.org/package/snowglobe-1 (ClaudeHeilandAllen)
13:40:38 <ClaudiusMaximus> ^^ video sample at http://claudiusmaximus.goto10.org/v/ifsnobuts/2012-01-12_snowglobe_v4.ogv (31MB)
13:40:42 <monochrom> fresh variables is always a good idea
13:40:57 <carpi> so pattern matching always happens only on one argument? or is that too simplistic?
13:41:16 <geekosaur> case only applies to a single expression, yes
13:41:21 <shachaf> carpi: It's not so much "simplistic" as "doesn't make any sense", at least without clarification.
13:41:30 <shachaf> What does "one argument" mean?
13:41:40 <koeien> one value
13:41:41 <pdxleif> "a value"?
13:41:42 <rwbarton> well, in function bindings you can pattern match on multiple things at once
13:41:58 <monochrom> case has only one argument. but don't equate case with all possible pattern-matching syntax
13:42:09 <conal> ClaudiusMaximus: yow. beautiful!
13:42:30 <carpi> thanks.. so  i guess i was wrong )
13:42:37 <ClaudiusMaximus> conal: thanks! the code isn't ;)
13:43:04 <conal> ClaudiusMaximus: then make it so! pretty on the inside & outside.
13:43:11 <shachaf> 31MB. :-(
13:43:38 <conal> ClaudiusMaximus: nicely anti-aliased.
13:43:39 <ClaudiusMaximus> conal: have to work on other things more urgently...
13:43:49 <conal> ClaudiusMaximus: :)
13:44:04 <ClaudiusMaximus> conal: but maybe in a couple of months i'll have time
13:44:14 <carpi> i reckon i can't do something like "case (x y) of (1 2) -> True".. the ',' are mandatory?
13:44:23 <koeien> yes
13:44:27 <geekosaur> carpi:  pedantically, the pattern matching in function declarations desugars to case statements; case is the primitive operation
13:44:38 <geekosaur> (x y) would be function application
13:44:39 <koeien> carpi: it's a tuple
13:44:40 <rwbarton> "case (x y) of" means you are applying the function x to y
13:44:41 <ClaudiusMaximus> shachaf: the code is 17kB and runs forever (or until Int overflow, maybe)
13:44:57 <rwbarton> ClaudiusMaximus: how long does it take to render?
13:45:11 <conal> ClaudiusMaximus: hooray for algorithmic compression.
13:45:33 <carpi> thanks for the clarifications - )
13:45:58 <ClaudiusMaximus> rwbarton: realtime on my desktop, almost realtime on my laptop - there was some jitter in previous versions but i overcame it by amortizing the fractal rendering into a set number of passes each frame
13:46:29 <monochrom> you can do "f 1 2 = True"
13:46:36 <Manehattan> Let's say I have a MonadState where the state actually changes little over a lot of time, will that lead to memory being filled up or is the ghc smart enough not to replace the state with a copy of itself?
13:46:49 <The_Journey> what is the difference between rpar Strategy and rseq Strategy for evaluation?
13:47:24 <monochrom> perhaps rpar is more parallelized
13:47:25 <koeien> Manehattan: ghc is quite smart. this reason is why we use trees often, more often than hash tables
13:47:52 <The_Journey> monochrom: how so?
13:48:06 <koeien> because of immutability data can be shared
13:48:08 <monochrom> ghc is not smart enough to do destructive update of tree nodes
13:48:15 <koeien> that's true
13:48:25 <monochrom> but we don't want it anyway
13:48:30 <Feuerbach> Manehattan: it's not even smartness; there's simply no reason to duplicate the state if it's not changed
13:49:39 <The_Journey> I'm not sure I understand the difference between the rpar, rdeepseq, and rseq strategies for evaluation, can anyone help me?
13:50:03 <monochrom> trees are more FP-friendly. we find that some trees are competitive compared to other people's hash tables.
13:50:28 <monochrom> (you can contrive a slow tree, sure. that is not the point.)
13:51:58 <monochrom> and more recently, you don't even have to give up the "hash" part, just the "table" part. see unordered-containers
13:57:32 <c_wraith> tibbe made an interesting point...  You can treat patricia trees kind of like sparse arrays that cover the entire range of Int values
13:58:36 <c_wraith> if you think of them that way, the unordered-containers structure becomes a lot more hashtable-like
14:12:09 <conal> ClaudiusMaximus: have you tried snowglobe on mac os x?
14:13:00 <conal> ClaudiusMaximus: i'm able to compile but then i get "GLUT: Warning in snowglobe: GL error: invalid framebuffer operation", repeatedly, and the the snowflakes appear to be replaced by their complements (i.e., opaque background & transparent foreground).
14:15:08 <redheadphones> i'm trying to install lambdabot locally and on `runhaskell Setup configure` it seems to be looking in the wrong place for deps. i have them installed in ~/.cabal, but it can't find them.
14:15:30 * redheadphones is new to haskell
14:15:41 <redheadphones> is it maybe something with my path?
14:17:32 <da-x> is there a strict version of the IO monad's bind (>>) ? i.e one that prevents me from getting stack space overflow when foldM on a mutable array...
14:20:00 <ClaudiusMaximus> conal: no - i haven't access to any OS X machines - thanks for the report, it's probably something to do with floating point textures?  hard to debug that stuff...
14:20:04 <monochrom> redheadphones: see my http://www.vex.net/~trebla/haskell/sicp.xhtml for "global" and "user". you can just focus on the first section. if you use Setup, it means "global"
14:21:25 <erus`> haskell is the best stackoverflow tag for whoring points :)
14:21:38 <geekosaur> if it's using x11, there are some opengl bugs in the version of x11.app on lion
14:21:39 <ClaudiusMaximus> conal: for reference, both my test machines are linux with nvidia proprietary drivers
14:22:19 <hpaste_> Carpi pasted “replaceable?” at http://hpaste.org/56400
14:22:20 <carpi> is it possible to replace the list comprehension in that function with some other construct or function? ^^^
14:22:33 <carpi> maybe map?
14:22:45 <redheadphones> monochrom, i see. is there an option on `cabal install` to draw from a local dir?
14:22:56 <monochrom> yes, just type "cabal install"
14:23:42 <redheadphones> monochrom, sweet, appreciated
14:27:22 <monochrom> sum (do { years <- [1901..2000], months <- [Jan .. Dec], guard (isSunday 1 months years); return 1 })
14:27:41 <monochrom> err
14:27:49 <monochrom> sum (do { years <- [1901..2000]; months <- [Jan .. Dec]; guard (isSunday 1 months years); return 1 })
14:29:12 <carpi> what is guard? could you please tell me?
14:29:51 <ciaranm> guards! guards!
14:29:54 <ciaranm> in lyah
14:30:11 <rwbarton> you can direct such queries to lambdabot
14:30:14 <rwbarton> @src guard
14:30:14 <lambdabot> guard True  =  return ()
14:30:14 <lambdabot> guard False =  mzero
14:30:18 <carpi> ciaranm: yes.. but that is '|'
14:30:37 * hackagebot iterio-server 0.1 - Library for building servers with IterIO  http://hackage.haskell.org/package/iterio-server-0.1 (AmitLevy)
14:30:42 <carpi> what is guard? is '|' just a symbol for guard?
14:30:53 <ciaranm> oh, maybe it's in with the MonadPlus stuff
14:30:57 <ciaranm> it's in there somewhere
14:32:24 <rwbarton> mzero is a MonadPlus method, yes.
14:33:13 <rwbarton> The function guard is what lambdabot says. No direct relation to guards ('|').
14:33:37 <ciaranm> http://learnyouahaskell.com/a-fistful-of-monads
14:33:41 <ciaranm> in there
14:33:43 <carpi> my bad.. so, with do notation.. it means im using a monda?
14:33:48 <carpi> *monad
14:33:59 <ion> > do "foo" :: String
14:34:00 <lambdabot>   "foo"
14:34:07 <Peaker> > do 5
14:34:09 <lambdabot>   5
14:34:10 <rwbarton> ion aside, yes.
14:34:11 <ion> Sorry, Strings are actually monads. :-P
14:34:17 <ion> Too tired.
14:34:21 <ion> > do 5 :: Integer
14:34:22 <lambdabot>   5
14:34:23 <rwbarton> Peaker aside, yes.
14:34:23 <Peaker> > do 'c'
14:34:24 <lambdabot>   'c'
14:34:42 <hpaste_> tty7 pasted “Primes with Data.Set” at http://hpaste.org/56403
14:34:51 <Peaker> rwbarton: I was actually curious for myself whether "do" had some hint to the type inference :)
14:35:14 <ion> If the do expression contains “;” or a line change, you’re definitely using a monad.
14:35:40 <ion> If it doesn’t, the “do” does nothing and you’ll get a warning from HLint.
14:35:51 <tty7> ion: that's basically the code you linked yesterday, only with Data.Set instead of infinite lists
14:36:28 <carpi> is there something i have to import to use "guard"? ghci says "Not in scope": guard
14:36:30 <tty7> it seems like that one is a little faster for n = 10,000 actually
14:36:33 <Peaker> so with no hlint warnings on code -- "do" definitely suggests use of a monad
14:36:38 <ion> @hoogle guard
14:36:38 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
14:36:38 <lambdabot> Language.Haskell.TH.Syntax data Guard
14:36:38 <lambdabot> Language.Haskell.TH data Guard
14:36:43 <Peaker> @index guard
14:36:44 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:36:44 <tty7> but it becomes slower than the list version for n = 10^6
14:37:11 <Peaker> is the rationale behind RWS performance? I sometimes used it for convenience, but it feels a bit dirty to use it
14:37:43 <monochrom> yes, it's probably less redundant than stacking ReaderT, WriterT, StateT
14:37:45 <geekosaur> I think RWS predates monad transformers; it's from the original monad paper, isn't it?
14:37:47 <tty7> which is obvious, because it checks for divisibility not only for the primes up to sqrt n in isPrime, but all odd numbers
14:38:00 <tty7> s/for/by
14:38:07 <ion> I was just about to point that out. :-)
14:38:12 <tty7> ;)
14:38:43 <tty7> but creating a Set everytime to keep it like the list version slows down everything as well :/
14:38:53 <Peaker> monochrom: why is stacking them "redundant"? what makes these particular 3 special? Why not make one for ReaderT, ContT, and other combos?
14:39:11 <Peaker> geekosaur: interesting!
14:39:19 <Peaker> geekosaur: satisfying explanation, at least :)
14:39:21 <tty7> so it seems that Data.Set can't improve the efficiency of the algorithm used
14:39:27 <monochrom> "redundant" is my way of saying "inefficient". I don't know the rest.
14:39:30 <rwbarton> for one thing R/W/S all commute with each other
14:39:41 <da-x> is there any way that when I do 'forM_ [x..y] some_action' where y - x > 100000000 I won't get a stack space overflow?
14:39:48 <Peaker> da-x: hey :)
14:39:53 <da-x> hey Peaker
14:39:58 <da-x> late night haskell frustrations
14:40:39 <monochrom> every "inefficiency" comes from redundancy, for example linear search over a sorted array is "inefficient" because it does redundant operations
14:40:42 <Peaker> da-x: your problem is specific to monads with strict binds, I believe
14:40:55 <Peaker> da-x: I filed this: http://hackage.haskell.org/trac/ghc/ticket/4219
14:41:17 <da-x> ah! good to know
14:41:22 <Philippa> Peaker: R/W/S all fit a pattern with additional monoidal structure where there's only one continuation involved - and things that fit that pattern commute with each other
14:41:45 <Peaker> da-x: basically the "solution" is to use a hand-coded variant of sequence that is tail-recursive in that case :-(
14:41:50 <Peaker> da-x: (more of a workaround)
14:42:01 <mmirman> Is tryhaskell.org not working?
14:42:04 <rwbarton> forM_ doesn't build a list though.
14:42:24 <Peaker> @src sequence_
14:42:24 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:42:28 <rwbarton> But yes, it will depend on what monad you are using
14:42:46 <da-x> I'm using the IO monad
14:43:51 <monochrom> forM_ [x..y] (\_ -> putStrLn "")  does this overflow?
14:43:54 <rwbarton> "forM_ [1..10000000000] (const return ()) :: IO ()" seems to be running in constant space here (in ghci)
14:43:56 <Peaker> hmm.. sequence_  does seem equivalent to the "tail recursive" definition (actually it's not tail recursive in any case, since the tail call is a bind, but in the sequence case, ghc can use the almost-tail-call one)
14:44:23 <monochrom> it seems some_action is guilty
14:44:25 <Peaker> da-x: what is "some_action"?
14:44:51 <monochrom> blame assignment is not for non-experts
14:45:16 <rwbarton> Sadly.
14:45:27 <da-x> Peaker: I'm iterating over a large mutable array, doing readArray on each element and incrementing IORef Int counters. After the forM_ ends, I'm printing those counters
14:45:38 <rwbarton> oh
14:46:25 <monochrom> after the forM_ ends, the IORef contains the unevaluated huge expression (1+(2+(3+... or something.
14:46:33 <rwbarton> When you say "incrementing IORef Int counters", what you're actually doing is replacing the value in the IORef with a thunk that says "add 1" with a pointer to the previous value.
14:46:46 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml for simpler examples
14:47:10 <monochrom> (1+(1+(1+... actually. or ...+1)+1)+1)
14:47:37 <da-x> Thought about this, so I used this: strictModifyIORef r f = do x <- readIORef ; writeIORef r $ x `seq` f x
14:47:39 <monochrom> my page doesn't say how to fight it yet. but you can writeIORef v $! (n+1)
14:47:49 <rwbarton> Well.
14:47:50 <da-x> (it didn't help)
14:48:03 <rwbarton> Now you are writing a thunk which says "When you evaluate me, evaluate x and then evaluate x + 1".
14:48:07 <rwbarton> That doesn't help.
14:48:11 <da-x> OH
14:48:37 <rwbarton> You want to evaluate the new value before you pass it to writeIORef.
14:48:42 <Peaker> da-x: I suggest avoiding seq and using ! and $! when possible, they're much much nicer (at least IMO)
14:48:44 <rwbarton> monochrom's $! does this
14:49:00 <Peaker> da-x: for example:  writeIORef r (f $! x)
14:49:14 <Peaker> da-x: or: writeIORef r $! f x
14:49:15 <rwbarton> (or more precisely, you want to make sure that n+1 is evaluated before the writeIORef action occurs)
14:49:39 <da-x> Yes! Forgot about it. Just modified to 'writeIORef r $! f x' and it fixed the problem.
14:50:15 <Peaker> some better memory diagnostic tools could help ghc immensely.. even if they give up performance they'd usually be helpful (as a special build)
14:50:18 <rwbarton> $! is nicer, but it is another (small) layer of abstraction to deal with when learning about strictness
14:50:38 * hackagebot structured-mongoDB 0.1 - Structured MongoDB interface  http://hackage.haskell.org/package/structured-mongoDB-0.1 (DeianStefan)
14:50:52 <monochrom> writeIORef r (f $! x)  builds you a huge unevaluated expression (f $! (f $! (f $! ... (x).  similarly writeIORef r (x `seq` f x)
14:51:50 <monochrom> it is the same reason why const () (f (f (f 0)) `seq` 4)  nothing happens
14:51:51 <Peaker> could be nice to have a "strict IORef" -- and then perhaps even allow unpacking it..
14:52:48 <c_wraith> Peaker: there's http://hackage.haskell.org/package/strict-concurrency for MVar and Chan...  but IORef is just more primitive than them.
14:53:50 <c_wraith> actually, given that that package is only wrappers, it could do the same thing with IORef.
14:54:15 <monochrom> strict-mutatancy
14:54:33 <c_wraith> strict STRefs
14:54:34 <rwbarton> mutatancy?
14:54:36 <c_wraith> !
14:54:41 <rwbarton> Is that the evil magical force of mutation?
14:54:48 <monochrom> so it rhyms with concurrency
14:55:06 <Peaker> c_wraith: can't get the unpacking though
14:55:25 <c_wraith> can't unpack them so long as they're polymorphic
14:55:25 <Peaker> da-x: me and Yair are steadily working on what is now named "Bottle" (as a temp name)
14:55:38 * hackagebot dclabel 0.0.4 - The Disjunction Category Label Format  http://hackage.haskell.org/package/dclabel-0.0.4 (DeianStefan)
14:55:38 <Peaker> da-x: yesterday and today we were working on a large GUI refactoring (still not complete...)
14:55:40 * hackagebot lio 0.1.0 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.1.0 (DeianStefan)
14:56:20 <da-x> Peaker: I'll check the logs
14:56:38 <Peaker> da-x: the big refactor is still in flux, we only push when it's presentable :)
14:57:36 <monochrom> some day, I should impersonate a beginner, and ask, "the type signature Int->Int is causing my program to use 2GB heap, how should I change the type to use less memory"
14:58:34 <Peaker> if Haskell had unlifted type products, then changing the type to () would be a valid answer :)
14:58:45 <JoeyA> monochrom: Have you tried using jQuery?
14:58:48 <Peaker> lifted type products really spoil a lot of fun
14:58:57 <monochrom> no, I haven't
14:59:15 <JoeyA> (I was answering your beginner question ;-) )
14:59:34 <dolio> You can't have unlifted products without fixing seq or making evaluation very complicated.
14:59:36 <JoeyA> Q: How much wood would a wood chuck chuck if a wood chuck could chuck wood?  A: tias
14:59:38 <dolio> Not that I'm against fixing seq.
15:00:03 <Dread> I have a total nooby question. Why does this function oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]        need the $
15:00:40 <monochrom> because someone was saving on parentheses. (sum . takeWhile (<10000) . filter odd . map (^2)) [1..]
15:00:49 <JoeyA> Is it possible to get Haddock to fully index all the (documented) packages installed on my system?  hoogle data only downloads stuff, it seems.
15:00:51 <funktronic> @src takeWhile
15:00:51 <lambdabot> takeWhile _ []                 =  []
15:00:51 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
15:00:51 <lambdabot>                    | otherwise =  []
15:01:29 <JoeyA> > (read . show $ 123) :: Int
15:01:31 <lambdabot>   123
15:01:35 <JoeyA> > (read . show 123) :: Int
15:01:36 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:01:36 <lambdabot>         against inferred ty...
15:01:36 <rwbarton> if you write sum . takeWhile (<10000) . filter odd . map (^2) [1..], it will mean sum . takeWhile (<10000) . filter odd . (map (^2) [1..]) -- but that's not what you want (e.g. (map (^2) [1..]) is not a function)
15:01:44 <Dread> Thanks monochrom that was helpfull
15:01:57 <JoeyA> . binds tighter than $, whereas application binds tighter than both.
15:09:47 <Dread> rwbarton++
15:18:18 <hpaste_> wilfredh pasted “Type error in trivial Yesod” at http://hpaste.org/56404
15:19:36 <wilfredh> my code is probably littered with bad practices, but could someone help a newbie out? http://hpaste.org/56404 I don't understand why the type error occurs.
15:21:30 <Peaker> dolio: why would it be so awful to have seq be a no-op on products?
15:21:52 <Peaker> dolio: the semantics of WHNF penetrate abstractions anyway
15:21:53 <nooodl> hi. is there some function to change one element in a list and return the new one? say, "replaceAt [1,2,3,4] 1 99" is [1,99,3,4]
15:22:02 <nooodl> i can't find anything like it using hoogle
15:22:30 <Peaker> dolio: You could also explicitly lift the product (wrap it in Identity) if you want to allow callers to force some part of your computation
15:23:07 <Peaker> nooodl: I have my own "nth" combinator that it usable for that...
15:23:30 <hpaste_> Peaker pasted “nth” at http://hpaste.org/56405
15:23:30 <nooodl> nth?
15:23:36 <Peaker> http://hpaste.org/56405
15:23:45 <dolio> Peaker: It wouldn't be awful at all. Good luck convincing people to change it.
15:23:56 <nooodl> oh, hmm
15:24:05 <Peaker> @let nth 0 f (x:xs) = f x : xs ; nth n f (x:xs) = x : nth (n-1) f xs
15:24:06 <lambdabot>  Defined.
15:24:20 <Peaker> > (nth 2 . const) 100 [1,2,3,4]
15:24:22 <lambdabot>   [1,2,100,4]
15:24:50 <dolio> It does complicate seq's implementation in GHC, certainly.
15:25:01 <Peaker> nooodl: instead of replacing -- nth does modifying, which can be used to replace if you compose it with const
15:25:01 <dolio> seq x y = case# x of _ -> y
15:25:16 <Peaker> dolio: I'm quite ignorant of what goes inside ghc...
15:25:33 <dolio> Case statements in the core language always evaluate.
15:25:38 <nooodl> > nth 2 (const 100) [1,2,3,4]
15:25:40 <lambdabot>   [1,2,100,4]
15:25:51 <Peaker> > nth 2 (*100) [1,2,3,4]
15:25:51 <shachaf> > nth 2 100 [1,2,3,4]
15:25:53 <lambdabot>   [1,2,300,4]
15:25:53 <lambdabot>   [1,2,100,4]
15:26:05 <Peaker> shachaf: don't confuse people with Caleskell :)
15:26:08 <nooodl> shachaf, magic
15:26:09 <shachaf> Anyway, indexing into lists often means that you're doing something wrong.
15:26:37 <nooodl> i'm building word search puzzles and need to place a [Char] into a [[Char]]
15:27:16 <JoeyA> Where do you want it to go?
15:27:16 <Peaker> > (nth 1 . nth 2) (*100) [[1,2,3,4,5],[10,20,30,40,50]]
15:27:18 <lambdabot>   [[1,2,3,4,5],[10,20,3000,40,50]]
15:27:27 <Peaker> @where SEC
15:27:27 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
15:27:42 <Peaker> nooodl: the nice thing about (nth n) is that it is a "semantic editor combinator", so it composes with other SECs
15:28:12 <dolio> Peaker: So, GHC's core language has a built-in way to reveal that products aren't really unlifted.
15:28:18 <dolio> Whether or not it's exposed.
15:28:44 <nooodl> JoeyA, it should be random eventually, but for now i'm writing a function that takes a [[Char]], (x, y) index tuple, and a String, an returns a new [[Char]]
15:29:01 <nooodl> anyway, i couldn't think of another way to do this
15:29:54 <nooodl> maybe arrays instead of lists?
15:31:05 <Peaker> dolio: well, "evaluating" a product could just be a no-op then in the underlying evaluation engine?
15:31:28 <Peaker> nooodl: with (nth x . nth y . const)  you've got the function you need :)
15:31:39 <Peaker> nooodl: but maybe an array with in-place changes, or a Map could work better
15:31:47 <Peaker> (more likely to be better performance-wise)
15:32:45 <nooodl> oh, maybe a map of ((x, y), (word, direction)) pairs would work
15:33:39 <JoeyA> You could create a mutable array (e.g. IOArray), fill it with empty cells (or perhaps random letters), and paint in words on top of it.  The reason I'd recommend using IO instead of ST is because it's a bit easier to generate random numbers in IO.  Of course, this is a rather imperative approach.
15:33:56 <nooodl> ...or ((x, y), letter) if i want to stay sane
15:34:00 <nooodl> ew, IO
15:34:14 <JoeyA> What's wrong with IO?
15:34:19 <Peaker> nooodl: what operations do you want to support?
15:35:06 <nooodl> i don't know, i expected something cleaner. if i'll use IO i might as well make this in something that's not haskell
15:35:31 <c_wraith> IO is clean.
15:35:35 <c_wraith> often, anyway
15:35:39 <Peaker> nooodl: can you describe your solution in more detail?
15:35:45 <c_wraith> You can do very interesting things with IO
15:35:53 <Peaker> nooodl: I'm sympathetic to your rejection of IO -- it's a good instinct in general :)
15:36:10 <c_wraith> You want to constrain IO more than eliminate it
15:36:12 <nooodl> Peaker, what do you mean by "operations", exactly
15:36:15 <Peaker> if you use *very* pervasive IO, I agree you don't get much out of Haskell
15:36:16 <JoeyA> nooodl is working on a word search generator, if I understand correctly.
15:36:25 <nooodl> yep
15:36:40 <Peaker> nooodl: you want to generate a random board of letters with certain words in it, for the users to find?
15:36:47 <nooodl> indeed
15:36:55 <Peaker> nooodl: no need to search that board then?
15:36:57 <c_wraith> oh.  well, yeah, that shouldn't need IO
15:37:45 <nooodl> well, i'll need to place the words so that they don't cross each other incorrectly
15:37:48 <Peaker> nooodl: well, I'd generate a list of non-overlapping positioned words, first, then generate a board with letters from these words, or random as filler
15:38:11 <JoeyA> A naïve algorithm might be: 1) Initialize the board to "empty"  2) Place words in random locations.  If there is an incompatible overlap (i.e. the word changes an already-placed letter), pick somewhere else to put the word (blacklisting the current position using a Map or something).
15:38:11 <Peaker> nooodl: you could have a Set of positions that are already occupied, and randomize locations until they don't collide
15:38:42 <nooodl> JoeyA, i was planning to do something like that, indeed
15:40:24 <JoeyA> It might be tricky to do this in a purely functional manner, since the plane of cells representation is central to the problem.
15:40:37 <Peaker> nooodl: data Location = Location { size :: Int, start :: Position, direction :: Direction },  and    positions :: Location -> [Position]   and then use a    RandT (State (Set Position))    computation to generate all the locations
15:41:15 <Peaker> nooodl: data Position = Position { x, y :: Int }
15:41:31 <Peaker> (deriving Eq, Ord, and any needed others, of course)
15:41:47 <JoeyA> The benefit of using a Map (Int, Int) (Maybe Char) is that it provides non-destructive update.  This might be a good idea, if your algorithm needs to backtrack.
15:41:59 <nooodl> JoeyA, it's probably more suited for an imperative style, but I like a good challenge now and then
15:42:02 <JoeyA> It's a tad heavy, though (one map entry for every character).
15:43:15 <jamil_1> hi all
15:43:15 <nooodl> the puzzles probably won't be that big; i don't expect much more than 20x20 or so. i think i'll try a Map
15:43:23 <jamil_1> haskell noob here
15:43:48 <jamil_1> wonder why I am getting a parse error: http://paste.pocoo.org/show/534021/
15:44:05 <Peaker> nooodl, JoeyA: Why not keep a [Location] and just a Set of occupied positions for quick testing of overlap?
15:44:39 <kqr> do any of you guys use haskell like many people use python or ruby? for prototyping of stuff and quick scripting and stuff?
15:44:45 <nooodl> working with direction is pretty annoying
15:45:00 <JoeyA> That's a good idea.  You'll need the list of word positions, anyway.
15:45:03 <Peaker> jamil_1: "(Node u)" pattern-matches Node with 1 field, but it's defined with 3
15:45:22 <Peaker> nooodl: direction can simply be position (with (-1 -1 .. 1 1) in it)
15:45:42 <XexonixXexillion> jamil_1: Although once you fix that, you'll probably get a type error
15:45:48 <Peaker> kqr: yeah, though Python has some advantages in the quick scripts department
15:45:48 <Pseudonym> kqr: I prototype just about every moderately complicated algorithm in Haskell first.
15:46:09 <Peaker> kqr: mostly to do with eco-system, interactive shell, and less to do with the language -- so these advantages may soon disappear
15:46:11 <Pseudonym> But admittedly I write more moderately complicated algorithms for a living than many people do.
15:46:23 <XexonixXexillion> jamil_1: actually never mind, I misread the code
15:46:31 <kqr> yeah. i really like haskell and i would like to become better at it, but most of the stuff i do is prototyping and quick scripting
15:46:35 <Peaker> nooodl: and if you have a Num instance on Position -- you just need to do: take size (iterate (+direction) start)
15:46:56 <Peaker> nooodl: to generate all the positions, which you can then search for overlap
15:47:27 <Peaker> kqr: Haskell has some nice advantages in that domain (quick one liners take you much much further than Python)
15:47:54 <nooodl> kqr, i recommend using haskell for math-y things. project euler is awesome using haskell, for example
15:48:04 <kqr> hm
15:48:05 <Peaker> kqr: I find the Haskell APIs to do standard/simple IO things much more annoying than Python's, though :(
15:48:19 <kqr> Peaker, haha, yeah, that's one of the things i've noticed
15:48:36 <kqr> Peaker, i was hoping once you grow accustomed to the io monad those discomforts would fade away
15:48:38 <nooodl> interact is really nice sometimes
15:49:07 <Peaker> kqr: The IO type is not a problem once you're accustomed, it's actually quite convenient to use
15:49:20 <kqr> Peaker, so what's annoying?
15:49:23 <jamil_1> nah, its compiling now
15:49:23 <dolio> Peaker: No, I expect that'd be unacceptable for performance reasons. You'd just have to arrange to not expose the evaluate primitive to the surface language.
15:49:35 <Peaker> kqr: the problem for me is: A) very elaborate/annoying import syntax in conjunction with very long module names   B) Useful IO functions scattered over many of these modules
15:49:56 <nooodl> ah well, i'll think about this later, going to bed now. thanks Peaker, JoeyA
15:49:57 <JoeyA> hSetBuffering stdout LineBuffering
15:50:11 <kqr> Peaker, right
15:50:11 <Pseudonym> I'm pretty sure there's nobody who's happy with the Haskell module syste,./
15:50:14 <Pseudonym> system
15:50:23 <Pseudonym> Could be worse. At least it's got one.
15:50:27 <Peaker> Haskell should just copy Python's import syntax
15:50:32 <Peaker> it's much nicer
15:50:46 <wilfredh> If anyone could take a glance at http://hpaste.org/56404 and tell me what obvious thing I'm missing?
15:50:55 <Pseudonym> That wouldn't fix the semantic problems, only the syntactic ones.
15:50:58 <JoeyA> Haskell's gonna be so great in 2020.
15:51:13 <Pseudonym> Oh, prime has a release date now, JoeyA?
15:51:19 <JoeyA> I don't know :P
15:51:20 <Peaker> wilfredh: you're trying to readFile in a "Handler" computation, you probably meant to liftIO that
15:51:29 <c_wraith> Peaker: are you aware you can import multiple modules with the same qualified name?  Sometimes, that can make those problems vanish
15:51:29 <jamil_1> wow!
15:51:41 <Peaker> c_wraith: that is actually horrible IMO :)
15:51:46 <Pseudonym> Any decade now.
15:51:46 <JoeyA> I'm saying in practice, modules I'm interested in using won't be construction yards anymore ;-)
15:51:48 <jamil_1> bfs in 4 lines
15:51:53 <jamil_1> pretty neat :)
15:51:59 <Peaker> c_wraith: one of the main points of module systems is to avoid silly namespace clashes
15:52:03 <wilfredh> Peaker: much appreciated :)
15:52:26 <JoeyA> And Haskell will get Erlang-style distributed computing pretty soon.
15:52:30 <Peaker> c_wraith: Haskell's import syntax (and culture!) actually misuse imports in the worst way as to encourage as many clashes as possible despite having modules
15:53:11 <Peaker> Using same module name for multiple imports will clash if they add a name you're using to the other module
15:53:16 <JoeyA> Peaker: Are you referring to, say, ByteString or Map's use of list API names like 'null' and 'map' ?
15:54:00 <Peaker> JoeyA: nah, I think these are ok because they encourage people to use qualified or at least closed-unqualified imports, which IMO should be the only options
15:54:25 <Peaker> JoeyA: in Python, there's  from some_module import *   and it looks and feels as dirty as it actually is: Messing up the namespace with unknown future names
15:54:35 <Peaker> in Haskell, "import SomeModule" looks clean but it is just as dirty
15:55:07 <c_wraith> I think part of the reason for this is how unwieldy it is to use qualified operators
15:55:20 <Peaker> c_wraith: closed-unqualified imports are ok too
15:55:52 <c_wraith> but amazingly bad annoying to type (like, I was amazed how much it annoyed me after a while)
15:56:10 <dolio> Yes, it's awful.
15:56:11 <c_wraith> Also, a surprisingly large contributor to version-control churn.
15:56:13 <Peaker> c_wraith: you mean annoying to add the operator on top?
15:56:36 <c_wraith> yeah, and just the extra sets of parens for operators
15:56:45 <Peaker> c_wraith: yes, that's a terrible artifact of keeping revisions on a textual representation of code
15:58:27 <ion> I got this great idea of trying to modify Haskell code’s heap directly from C code called via FFI for shits and giggles (who wouldn’t want to be able to modify pure values?). After stumblind around the GHC include files i managed to dereference a StablePtr and read the correct Int value from its payload, but modifying it doesn’t seem to change the value on the Haskell side. I guess something along the way makes a copy. :-P
15:58:33 <c_wraith> I think I'd feel better about it if you could just import operators without parens.  I don't know why, but it feels so much worse to me to say import Control.Applicative ((<$>)) than it would to say import Control.Applicative (<$>)
15:59:24 <c_wraith> And it's not like there's any ambiguity in that context.
16:01:16 <XexonixXexillion> Is there a sane reason why monads in haskell are not required to be functors?
16:01:54 <ion> xexonix: A historical accident. We’d love to see it fixed but that would break a lot of existing code. :-\
16:03:13 <XexonixXexillion> is that also the reason why I must define a monad in terms of bind as opposed to join?
16:03:13 <dmwit> Wait, it would break existing code?
16:03:29 <dmwit> Where has somebody declared an instance Monad that's doesn't also have an instance Functor?
16:04:03 <c_wraith> dmwit: it happens
16:04:19 <Peaker> dmwit: I'm sure it happens a lot when people use: "deriving (Monad, ...)"
16:04:33 <Peaker> dmwit: (I know I add "deriving" clauses on a per-need basis)
16:04:38 <ddarius> ion: I don't think it would actually break that much code.
16:04:41 <ion> dmwit: Well, when fixing Monad etc. one might as well fix everything that’s wrong with it. That would mean depending on Applicative and removing return for instance.
16:04:55 <Peaker> but fixing all the breakage would be more trivial than the breakage every new ghc version does anyway :)
16:05:00 <dmwit> Oh. Well, that would indeed break a lot of things.
16:05:26 <Peaker> we can have an automatic fixer script for Haskell sources :)
16:05:51 <dmwit> ghc --upgrade-from 7.2
16:05:52 <Peaker> run GHC -- if it complains about a missing Functor instance, paste one right next to the Monad instance. If this causes duplicate instances, delete the offending duplicates
16:05:55 <ion> xexonix: “join” in the typeclass would be another thing that would be nice to have in hindsight.
16:06:51 <c_wraith> yeah, after the changes to Num in GHC 7.4
16:06:52 <ion> xexonix: But for now, m >>= f = join' (f <$> m) where { join' = … } isn’t too bad.
16:06:52 <shachaf> Peaker: I think th epoint is to maintain compatibility with the Report.
16:06:54 <Peaker> cyclically defined methods are annoying though -- giving no warning or error when they cause an infinite loop
16:06:58 <shachaf> Of course, they've given up on that already.
16:07:15 <c_wraith> It's hard to believe that making Monad depend on Functor would be more breakage than that
16:07:29 <Peaker> c_wraith: what changed in Num?
16:07:37 <shachaf> Peaker: The Eq constraint is gone.
16:07:40 <dmwit> Peaker: It doesn't depend on Show and Eq now.
16:07:47 <shachaf> Oh, also Show?
16:07:49 <Peaker> cool! :)
16:07:51 <dmwit> um
16:07:56 <dmwit> I'm not 100% on that, let me check.
16:07:59 <Peaker> so pattern matching on nums just adds the constraint?
16:08:05 <c_wraith> right
16:08:09 <ion> c_wraith: Well, depend on Applicative, since that’s where we’d get “pure”, and stuff like liftM2 should be at most deprecated aliases to liftA2 etc.
16:08:10 <shachaf> Peaker: Really? Just breaking the spec like that is "cool"?
16:08:36 <Peaker> shachaf: the spec is not worth much now, IMO... GHC has no viable alternative in sight anyway
16:08:46 <Peaker> Haskell is not really much more than GHC
16:08:55 <dmwit> Peaker: Yes, Show is removed as well.
16:09:26 <Peaker> GHC should be the spec :)
16:09:30 <ion> heh
16:09:46 <Peaker> to make a relevant compiler, you'd have to emulate ghc anyway
16:10:39 <dmwit> Peaker: OCaml does that, and I think it's really bad.
16:10:50 <Peaker> dmwit: Haskell does that, it only pays lip service to the spec :)
16:11:08 <int80_h> could someone give me a hand installing ghc 7.0.4 on ubuntu 11.04? It's supposed to be in the repositories, but I can't figure out how to install
16:11:10 <Peaker> Maybe I'm missing something, but it seems the Haskell spec is ignored by everyone
16:11:21 <shachaf> Peaker: I think it was only added in Ubuntu 11.10
16:11:24 <int80_h> I mean 11.10
16:11:24 <shachaf> s/Peaker/int80_h/
16:11:26 <shachaf> Oh.
16:11:32 <shachaf> apt-get install ghc?
16:11:33 <ion> int80_h: haskell-platform
16:11:37 <shachaf> Or that.
16:11:37 <dmwit> apt-get install ghc?
16:11:41 <int80_h> ghc is ghc 7.0.3
16:11:48 <dmwit> ah
16:11:49 <shachaf> Oh.
16:11:51 <shachaf> Do you care?
16:11:56 <Peaker> Does anyone write modern Haskell "to the spec" in the expectation to port it to non-ghc?
16:12:09 <int80_h> shachaf, yes bcause I want the latest haskell-platform. It needs 7.0.4
16:12:33 <int80_h> Maybe I don't need the latest haskell-platform. But I don't want to run into problems because I'm not updated.
16:12:49 <shachaf> int80_h: If you ever need specific updated packages you can always just install them in ~/.cabal.
16:13:18 <int80_h> shachaf, true that. Maybe I'll just go with 7.0.3
16:14:20 <XexonixXexillion> Whilst I'm complaing about limitations of haskell; why does Num require abs and signum. Did it never occur to them that there may be kinds of numbers that it makes no sense to allow those on?
16:14:53 <dmwit> XexonixXexillion: Just switch to the numeric prelude now and get it over with.
16:15:12 <Peaker> is the numeric prelude the one where all the classes are named C?
16:15:25 <dmwit> I think so, yes.
16:15:36 <Peaker> Damn TH
16:16:23 <rwbarton_> don't you mean HT?
16:16:23 <XexonixXexillion> I like template haskell, it's how I can easily implement mod types
16:16:30 <ion> int80_h: On boxes with older distro releases i’ve added ~/.ghc/bin and ~/.cabal/bin to PATH, installed GHC from http://www.haskell.org/ghc/download_ghc_7_0_4#x86linux to ~/.ghc and cabal from http://www.haskell.org/cabal/download.html to ~/.cabal and installed whatever else i’ve needed with cabal. That has been rather painless.
16:17:00 <ion> And clean since i don’t even need superuser credentials.
16:17:31 <Peaker> rwbarton_: both :)
16:35:53 <XexonixXexillion> when the numeric prelude defines the law for additive groups "a + negate a === 0", do they actually mean "a + negate a === zero"?
16:37:32 <redheadphones> i can't seem to get rid of "Could not find module `ShowIO':" errors when using ">" on my install of lambdabot. i read around and it looks like a version issue of mtl between lambdabot and mueval. how might i fix this?
16:37:50 <shachaf> XexonixXexillion: Those are probably equivalent?
16:39:16 <XexonixXexillion> Not in the case I have...
16:40:42 <JoeyA> Is it better to say StateT (Changes, Doesn'tChange) m a, or StateT Changes (ReaderT Doesn'tChange m) a ?
16:40:56 <ddarius> The latter.
16:40:56 <XexonixXexillion> I think I'll just assume zero fits the laws. Otherwise a * (b - b) is going to be an error
16:40:58 <JoeyA> I'd think the first one would be more efficient.
16:43:53 <rwbarton> they must mean a + negate a === zero, yes, 0 doesn't make in general here
16:44:19 <shachaf> I assumed it was an overloaded literal thing.
16:44:27 * shachaf hasn't actually looked at the Numeric Prelude.
16:44:37 <rwbarton> I don't think you can overload 0 to a different type than 1
16:44:51 <rwbarton> or for that matter 2
16:44:55 <shachaf> Oh.
16:45:06 <shachaf> In that case, yes. :-)
16:45:19 <JoeyA> Meh, I'm just going to use StateT (Changes, Doesn'tChange) m a.  No raptor yet.
16:45:43 <JoeyA> (I only care about the monad's representation in about two places, anyway)
16:45:46 <shachaf> JoeyA: I wonder waht the point of asking was. :-)
16:46:35 <JoeyA> Well, StateT Changes (ReaderT Doesn'tChange m) a seems heavier (e.g. two >>= instances to go through).  I'm wondering how heavy, though.
16:52:45 <JoeyA> One thing I like about Haskell versus C++ is that abusing language features tends to give more satisfying results.
16:53:31 <monochrom> that seems to be a criterion for drugs rather than languages :)
16:53:40 <JoeyA> hahaha
16:53:56 <JoeyA> Haskell has been like a drug to me, in retrospect.
16:54:14 <Pseudonym> Caffeine makes me more productive.
16:54:16 <Enigmagic> i skipped haskell and went straight to heroin
16:54:21 <JoeyA> lol
16:54:31 <XexonixXexillion> I skipped heroin and went straight to haskell
16:54:50 <JoeyA> Heroin - the purely functional <qualifier> <qualifier> programming language.
16:55:25 <monochrom> there is a web programmer who started with ruby, skipped haskell, went straight to agda
16:55:26 <Enigmagic> and less socially awkward than common lisp
16:55:46 <sipa> monochrom: damn he fell deep
16:56:03 <monochrom> he goes to ruby meetings to show agda code for web apps
16:56:18 <ion> Does he have talk videos online?
16:56:40 <monochrom> I don't know. I forgot his name or url or stuff. but other people here know.
16:57:31 <XexonixXexillion> There are few things better in the world than nicely written agda code, but there are also few things more frustrating than writing it
17:03:57 <copumpkin> XexonixXexillion: I love writing it
17:05:31 <XexonixXexillion> copumpkin: I like writing it too, but that doesn't stop it from being frustrating
17:06:05 <copumpkin> I mostly get frustrated by bugs in it :P
17:15:47 <dgpratt> I like the fact that Agda exists; if I ever learn all there is to know about Haskell, it's good to know there's something else I can obsess over
17:17:40 <copumpkin> dgpratt: it's actually cleaner in many ways than haskell, so for learning some of the more advanced things it might even be easier
17:17:54 <copumpkin> not sure that hypothesis gets tested much though
17:18:53 <shachaf> copumpkin: I think explaining Rank-N types in terms of Agda-style polymorphism is much simpler than whatever explanations people usually give.
17:19:03 <dgpratt> copumpkin: that's interesting; I think of it as being more expressive, but not 'cleaner'
17:19:27 * shachaf notes that he doesn't actually know Agda or anything.
17:19:37 <dgpratt> copumpkin: well, until just now...now I think of it as cleaner, too
17:21:09 <dmwit> Haskell (well, GHC) has lots of hacks built in to deal with the fact that it doesn't have dependency: GADTs, type families, and functional dependencies spring to mind first.
17:21:20 <dmwit> Those are all done with basically the same mechanism in Agda.
17:21:24 <dgpratt> dmwit: good point
17:21:36 <dmwit> (And that mechanism is "function application", one you already know. =)
17:24:09 <dgpratt> the problem with Agda (or so it seems to me) is that the learning curve is even that much steeper at the start than Haskell, which itself is regarded as being pretty steep
17:24:41 <XexonixXexillion> to be honest though, the learning curve of haskell is not actually that steep
17:25:24 <dgpratt> of course, this is my impression standing at the bottom of the Agda mountain, whereas I've managed to make some headway with Haskell :)
17:26:55 <Peaker> da-x: if you're as insane as I am and still up, you can pull.. it finally works with the new cursor model :)
17:27:15 <XexonixXexillion> One advantage haskell has over agda is that there are a lot more haskell tutorials
17:27:26 <Peaker> XexonixXexillion: it's much much steeper than learning a new syntax, which most people think a new language is about
17:27:28 <shachaf> The disadvantage is that they're all bad.
17:27:39 <Peaker> shachaf: isn't LYAH good?
17:27:54 <shachaf> I don't know if LYAH is good.
17:28:02 <shachaf> "all" was an exaggeration.
17:28:22 <XexonixXexillion> I've seen students actually learn things from LYAH, so it seems to work
17:28:54 <dgpratt> XexonixXexillion: probably so; I'm still recovering from more than a decade of programming VB 6 :)
17:29:37 <dgpratt> XexonixXexillion: my 10 year old, otoh, doesn't seem to find it very difficult :) (not that I've pushed it that far with her)
17:30:10 <Peaker> disappointingly, I know about 4-5 people who read LYAH, some even excited by it, but the concepts didn't sink in, and they "lost it at Monads"
17:30:30 <Peaker> I think people try to learn by pure reading without trying things out, and apparently the brain does not work that way
17:30:32 <dgpratt> Peaker: that is dissapointing
17:30:55 <shachaf> My impression of LYAH isn't all that great, but that's probably because I've only seen the parts of it that are confusing enough that people have come in here to ask about them.
17:30:56 <Peaker> maybe LYAH doesn't encourage people to do exercises enough
17:31:07 <shachaf> I think Hutton's book is a good introduction, though.
17:31:27 <dgpratt> shachaf: which one is that?
17:31:55 <shirt> type Machine = (a -> Input -> (Output, a)
17:32:05 <shirt> "a" is the memory of the machine
17:32:06 <Peaker> a coworker of mine says "we all learn by doing" -- and many people try to learn Haskell by reading
17:32:25 <Peaker> shirt: Input -> State Memory Output
17:32:35 <shirt> how can i have a list containing different types of machines, each paired with it's memory, and then map the list over an Input?
17:32:42 <shachaf> google hutton haskell book
17:32:47 <shachaf> @google hutton haskell book
17:32:49 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
17:32:50 <lambdabot> Title: Programming in Haskell
17:32:51 <shirt> Peaker: the memory needs to be polymorphic
17:32:52 <shachaf> That one.
17:33:15 <mlh> Peaker, which chapter are monads introduced or metnioed in LYAH?
17:33:51 <dgpratt> shachaf: oh, yeah, I watched the videos Erik did on that
17:33:53 <XexonixXexillion> mlh: I think it's 12
17:34:05 <monochrom> people definitely try too much reading and not enough doing when learning IO or monads
17:35:19 <dgpratt> speaking of Erik, I think it was a little slice of genius to cloak monads in query syntax in .Net
17:35:24 <Peaker> shirt: You could have:  data Machine = Machine (Input -> (Output, Machine))
17:35:39 <Peaker> shirt: capture the machine memory in the lambda there
17:35:57 <shirt> Peaker: hm... interesting
17:36:31 <Peaker> Erik said some weird things in an interview... "OO is more powerful than functional programming, because you pass vtables with multiple methods, instead of passing just one function as in HOFs"
17:36:42 <Peaker> (I'm paraphrasing, but it was along those lines)
17:37:08 <dgpratt> Peaker: yeah some of the things he said about OO vs Functional I just couldn't figure
17:37:20 <shirt> what interview is this/
17:37:27 <XexonixXexillion> Open question: When people ask you what a monad is, how do you respond?
17:37:33 <ion> Erik who?
17:37:41 <monochrom> @quote array
17:37:41 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
17:37:46 <monochrom> is my response
17:37:50 <dgpratt> XexonixXexillion: I respond, let me introduce you to Cale...
17:38:15 <dgpratt> ion: Erik Meijer
17:38:17 <ion> @quote ndofu
17:38:18 <shachaf> XexonixXexillion: Oh, come on. Isn't it bad enough that people ask that question -- you have to meta-ask it?
17:38:18 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
17:38:30 <monochrom> haha
17:39:33 <XexonixXexillion> I do like that quote
17:39:43 <Peaker> I'm actually curious to finally understand the wadler quote sometime :)
17:40:02 <mlh> speaking generally; non-mathematicians like to see a motivation/reason for something to be able to understand the mathematical concept
17:40:20 <mlh> people throw up a block of WHY when presented with monads
17:40:49 <Peaker> that's why it should be built by example, from repetitive combinators to their generalization
17:41:03 <XexonixXexillion> An endofunctor is simply a functor that maps a category to itself
17:41:09 <dgpratt> I feel like I *almost* understand that quote, but I strongly suspect that feeling is deceptive
17:41:09 <monochrom> at a crossroad you meet an angel (always tells the truth) or demon (always lies). the crossroad gives you two choices of roads, one to heaven, one to hell, and only the angel or demon knows which is which. if you ask "how would you answer if I asked 'what is a monad?'", what will happen?
17:41:19 <Peaker> XexonixXexillion: Ok, what is the category of endo-functors?
17:41:51 <XexonixXexillion> Peaker: The category of all things that map to their own category
17:41:53 <Peaker> monochrom: you're supposed to ask one to tell you what the other says, so you get a predictable number of negations :)
17:42:07 <Peaker> XexonixXexillion: but categories are supposed to have arrows, not just objects?
17:42:59 <Peaker> XexonixXexillion: category of endofunctors explains what objects are there, does it have no arrows?
17:43:06 <ion> monochrom: Hahaha
17:43:25 <dgpratt> Peaker: mebbe it's those natural transformation thingies
17:43:43 <ion> @remember monochrom at a crossroad you meet an angel (always tells the truth) or demon (always lies). the crossroad gives you two choices of roads, one to heaven, one to hell, and only the angel or demon knows which is which. if you ask "how would you answer if I asked 'what is a monad?'", what will happen?
17:43:43 <lambdabot> I will never forget.
17:43:49 <Peaker> I don't really know CT.. I will learn it sometime
17:44:13 <Cale> Yeah, the arrows are natural transformations
17:44:22 <Cale> and there's actually still a little more to explain
17:44:33 <Cale> since you can't just have a monoid object in any old category
17:44:37 <Cale> it has to be a monoidal category
17:44:59 <Cale> The monoid operation on objects in that category is composition of functors, with unit being the identity functor
17:45:11 <shachaf> Peaker: You're supposed to ask one what the other one would say? Why?
17:45:21 <Peaker> shachaf: at least iirc :)
17:45:24 <shachaf> "what would you say if I asked you?" works just as well.
17:45:35 <Peaker> shachaf: ah, right multiply number of negations by 2 :)
17:46:58 <shachaf> Anyway, the "monoid in the category of endofunctors" thig makes intuitive sense to me, more or less.
17:47:11 <XexonixXexillion> Doesn't the wadler definition of monads also include comonads?
17:47:13 <russruss> the monoid operation is of course join
17:47:15 <Cale> To paint the picture for you, basically, a monoid in the monoidal category of sets with cartesian product on objects is a set M which has a unit, which is a function eta: 1 -> M, and it has a multiplication which is a function mu: M x M -> M
17:47:28 <russruss> in the case of haskell monads
17:47:37 <Cale> and those satisfy left and right identity laws and an associativity law
17:48:28 <Saizan> join is the multiplication of the monoid object
17:48:52 <Cale> and in the case of a monoidal category of endofunctors, you have a functor M together with natural transformations eta: 1 -> M  (which has components a -> M a for each object a) and mu: M . M -> M (which has components M (M a) -> M a for each object a)
17:49:11 <Cale> and the laws are perfectly analogous
17:49:18 <shachaf> Cale: "has components"?
17:49:26 <roconnor> 1 maps to Identity, M maps to the monad type consturctor  and . -> . maps to forall a. . a -> . a
17:49:28 <Cale> Yeah, the components of the natural transformation
17:49:57 <roconnor> and . x . maps to Compose . .
17:50:26 <Saizan> lots of dots around here
17:50:38 <roconnor> I should be using middot
17:50:40 <djahandarie> Around here -> . ?
17:50:45 <rwbarton> (.) . .
17:50:54 <ion> .….
17:50:57 * shachaf wonders if he's missing out on something by having Unicode being broken.
17:51:14 <roconnor> 1 maps to Identity, M maps to the monad type consturctor  and · -> · maps to forall a. · a -> · a and · x · maps to Compose · ·
17:51:34 <shachaf> Yep, I'm pretty sure I am.
17:51:42 <roconnor> middot is iso-latin-1
17:52:01 <shachaf> Yes, but only code points <128 are working.
17:52:09 <roconnor> :(
17:52:12 <monochrom> you can always look at the channel log in a web browser. the topic has the channel log url
17:52:23 <shachaf> True.
17:52:50 <shachaf> Something messes up reading the channel logs in my browser.
17:53:10 <monochrom> you have to tell the web browser which encoding to use. do try both latin-1 and utf-8
17:53:25 <shachaf> Ah, my browser wasn't treating it as UTF-8.
17:53:50 <shachaf> Latin-1? More like Evil-1.
17:55:39 <monochrom> middot was in iso-latin-1 but you could be sending out either the byte \xb7 or the two bytes \xc2 \xb7 depending on encoding. the latter is utf-8, at which point a receiver that assumes iso-latin-1 will get one junk byte.
17:55:55 <shachaf> Right.
17:56:22 <monochrom> the former is iso-latin-1, at which point a receiver that assumes utf-8 will get one junk byte, too.
17:57:14 <XexonixXexillion> Why hasn't this all been standardised yet...
17:57:20 <shachaf> Is \xb7 a valid first byte in UTF-8?
17:57:32 <monochrom> they have all been standardized. both of them. are you happier?
17:58:03 <XexonixXexillion> It isn't 1990 anymore... why are all things not encoded in either UTF-8 or UTF-16 /rant
17:58:18 <shachaf> There's no excuse for anything to be encoded in UTF-16.
17:58:42 <shachaf> Well, unless "at least it's not ISO-8859-1" is an excuse.
17:59:14 <XexonixXexillion> apparently it's nicer for east asian scripts
17:59:27 <shachaf> Nicer than what?
17:59:30 <shachaf> It's not fixed-width.
17:59:31 <monochrom> \xb7 is not a valid first byte in utf-8
17:59:46 <XexonixXexillion> nicer than utf-8
17:59:48 <shachaf> Er, maybe "fixed-width" is a font thing, not an encoding thing.
18:00:28 <monochrom> no, the aim of utf-16 is no longer fixed-width. (was.) but still more concise for east asian scripts
18:01:27 <ion> Which is important because CJK plaintext data takes so much expensive disk space.
18:02:11 <monochrom> it comes down to which languages you care about
18:03:46 <XexonixXexillion> To be honest, I'll just be happy when I can browse the web without my web browser constantly inferring the wrong encoding
18:04:16 <monochrom> it's hard to infer
18:06:08 <XexonixXexillion> I know... but I'd just like to turn it onto utf-8 and leave it. Character encoding should not still be a problem in 2012
18:06:09 <monochrom> many Chinese people still use big5 or gb2312 for Chinese. that much is fine if their "text/html; charset=" were right. but what they actually do: "text/html; charset=iso-8859-1"
18:06:35 <monochrom> there is no inference to talk about if the author simply lies
18:07:00 <Cale> Why would they lie?
18:07:06 <Cale> Is there a good reason to have that wrong?
18:07:23 <monochrom> yes, if they lie, they don't have to do research.
18:07:35 <XexonixXexillion> They probably just used a html template with the wrong charset
18:07:56 <XexonixXexillion> and don't realise/care
18:09:55 <irene-knapp> it might provide some margin of protection against the great firewall, but who knows :)
18:09:58 <koninkje> [A
18:10:15 <irene-knapp> probably not though - but hey, at least it makes work for whoever maintains it
18:10:26 <XexonixXexillion> What encoding does the Haskell Char type use?
18:10:43 <monochrom> unspecified. unexposed.
18:10:50 <irene-knapp> XexonixXexillion: it's a codepoint, not an encoded character
18:11:56 <monochrom> Char is not a Bit instance, so you will never know
18:12:21 <XexonixXexillion> that's what unsafeCoerce is for :p
18:12:42 <lispy> hi
18:12:54 <shachaf> Well! If it isn't lispy!
18:12:57 <monochrom> in practice, the number of the codepoint is stored internally, for GHC
18:13:09 <monochrom> s/of/for/
18:13:17 <lispy> shachaf: it isn't, I checked ;)
18:13:22 <The_Journey> hi, how may I resolve circular dependency of modules?
18:13:28 <shachaf> lispy: Oh. :-(
18:13:40 <shachaf> @google haskell circular dependency of modules
18:13:41 <lambdabot> http://www.haskell.org/haskellwiki/Mutually_recursive_modules
18:13:41 <lambdabot> Title: Mutually recursive modules - HaskellWiki
18:13:59 <lispy> The_Journey: the best way is to introduce a new module that breaks the cycle
18:13:59 <shachaf> Like that.
18:14:12 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
18:14:19 <lispy> The_Journey: but some haskell compilers have implementation specific tricks (like .hs-boot modules)
18:14:46 <The_Journey> but the most elegant solution would be to create another module?
18:14:51 <monochrom> the GHC user guide is valuable reading material. read it cover to cover.
18:14:55 <shachaf> The wiki page has the additional advantage of mentioning alternatives like parameterization.
18:15:03 <lispy> The_Journey: well, it's the most portable and the easiest to maintain, IMO
18:54:40 <lispy> oh axiom of choice...
18:55:20 <shachaf> "The axiom of choice for the discerning mathematician"
19:01:49 <monochrom> create a programming language called "the axiom of choice". use it to win the ICFP contest. get them to announce "the axiom of choice is the programming language of choice for the discriminating programmer" :)
19:02:15 <monochrom> then do it for "the continuum hypothesis" next year :)
19:04:06 <irene-knapp> monochrom: hahaha nice hahaha
19:04:11 <irene-knapp> the hard part, of course, is winning the contest
19:06:17 <monochrom> make it a logic language, like mercury. make it better than mercury. that may help.
19:06:45 <monochrom> after all, the name says "choice"...
19:07:36 <lispy> When you want to prove something the axiom of choice is false.
19:08:03 <lispy> (not sure if that pun will come across...I mean that with false as an axiom you can prove anything)
19:08:15 <irene-knapp> ah
19:08:15 <irene-knapp> cute
19:08:34 <monochrom> oh haha, now I get it!
19:08:43 <lispy> might help if I change something to anything
19:09:02 <lispy> or everything?
19:09:13 <monochrom> don't make it too obvious :)
19:15:24 <paulotruta> hi ppl :) I need a little explanation about something
19:15:45 <paulotruta> i know the int type is for intiger number with a limit
19:16:23 <paulotruta> but if i do something as read (NULL) :: Int
19:16:31 <paulotruta> is this possible?
19:16:40 <lispy> paulotruta: what is NULL?
19:16:42 <companion_cube> you will get an exception
19:16:56 <companion_cube> > read "FOOBAR" :: Int
19:16:57 <lambdabot>   *Exception: Prelude.read: no parse
19:17:16 <irene-knapp> > data Void = NULL
19:17:17 <lambdabot>   <no location info>: parse error on input `data'
19:17:22 <paulotruta> yup, that is exactly my problem
19:17:31 <paulotruta> cause i'm parsing some things from a text file
19:17:44 <lispy> > (listToMaybe . readS) "NULL" :: Maybe Int
19:17:45 <paulotruta> and i'm reading an year field
19:17:45 <lambdabot>   Not in scope: `readS'
19:18:06 <paulotruta> and i want the year information to be int
19:18:07 <lispy> paulotruta: when you say NULL do you mean that the input is "" ?
19:18:12 <companion_cube> for any serious parsing, I think read is too limited
19:18:14 <paulotruta> but sometimes the year field is empty
19:18:22 <paulotruta> or has a string "-"
19:18:43 <paulotruta> i'm not using read, it was just to give the example
19:18:56 <paulotruta> yes lispy
19:18:58 <paulotruta> "" or "-"
19:19:04 <irene-knapp> I don't think anyone is too sure what your question is
19:19:24 <irene-knapp> you probably want to return a Maybe Int, instead of an Int
19:19:30 <companion_cube> paulotruta: then your parsing function should be  String -> Maybe Int
19:19:36 <koninkje> In general for parsing stuff, you will have the parser return Maybe Foo, and then you'll have a function which sanity checks the results and gets rid of the Maybe layer
19:20:18 <lispy> > (listToMaybe . reads) "NULL" :: Maybe Int
19:20:19 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:20:19 <lambdabot>         against inferred type ...
19:20:50 <paulotruta> i see... i'll try the Maybe Int aproach
19:21:06 <irene-knapp> > (listToMaybe . reads) "NULL" :: Maybe (Int, String)
19:21:08 <lambdabot>   Nothing
19:21:09 <lispy> lambdabot: seems to be ignoring me in private chat
19:21:17 <irene-knapp> > (listToMaybe . reads) "42" :: Maybe (Int, String)
19:21:19 <lambdabot>   Just (42,"")
19:21:24 <irene-knapp> > (listToMaybe . reads) "42.5" :: Maybe (Int, String)
19:21:25 <lambdabot>   Nothing
19:21:48 <irene-knapp> ? so why pray tell does it have the String in the return type if it isn't going to use it?  oh well ><
19:21:58 <lispy> > (fmap fst . listToMaybe . reads) "42" :: Maybe Int
19:22:00 <lambdabot>   Just 42
19:22:29 <lispy> > (listToMaybe . reads) "42 some blah" :: Maybe (Int, String)
19:22:30 <lambdabot>   Just (42," some blah")
19:22:31 <monochrom> because "42a" does what you want
19:22:33 <irene-knapp> oh
19:22:47 <irene-knapp> but wait
19:23:01 <irene-knapp> weird
19:23:02 <BMeph> irene-knapp: Or, in other words, "you're doing it wrong." ;)
19:23:07 <irene-knapp> BMeph: haha okay
19:23:08 <lispy> I'm actually not sure why "42.5" returns (42, "")
19:23:11 <monochrom> Int, Double probably share the same parser
19:23:24 <lispy> That seems like a bug but I'd have to read the docs
19:23:35 <irene-knapp> lispy: no, it returns Nothing
19:24:01 <irene-knapp> lispy: anyway yes, I think it's a bug
19:24:10 <lispy> Oh, I misread the scrollback
19:24:10 <irene-knapp> lispy: unless it's documented in which case it's a bad feature :)
19:24:30 <monochrom> Int, Double probably share the same parser. the parser slurps all of "42.5", of course. then reject it if you're doing Int
19:24:37 <irene-knapp> yes, certainly
19:24:38 <lispy> I guess it read too much and then couldn't just return an int
19:24:42 <irene-knapp> that would explain it
19:24:54 <lispy> it 'reads' too much I should say :)
19:24:54 <irene-knapp> but not excuse it :)
19:25:06 <irene-knapp> quite so
19:27:32 <lispy> ?remember lispy When you want to prove anything, the axiom of choice is false.
19:27:32 <lambdabot> It is stored.
19:28:55 <monochrom> I am wrong about Int and Double sharing the same parser. it is read itself. read calls lex. no instance coding can change that.
19:29:02 <monochrom> now, what does lex do?
19:29:09 <monochrom> > lex "42abc"
19:29:09 <lambdabot>   [("42","abc")]
19:29:43 <paulotruta> i think i discovered the problem
19:29:47 <paulotruta> i hav this function
19:30:02 <monochrom> > lex "42.5"
19:30:03 <lambdabot>   [("42.5","")]
19:30:07 <monochrom> that is why
19:30:21 <irene-knapp> fair
19:30:41 <paulotruta> seqtomusic s = Music (s !! 1) (read(s !! 2)) (s !! 3) (s !! 4) (s !! 5) (read(s !! 6))
19:30:44 <lispy> monochrom: oh, and lex's behavior seems pretty reasonable at the lexer level.
19:30:55 <paulotruta> but what is there is no (s !! 6) ?
19:31:06 <paulotruta> thats why it gives an error
19:31:33 <paulotruta> when i have info about the year in the text file, the function works
19:31:42 <lispy> paulotruta: (!!) is an easy way to insert bugs into a program.
19:31:45 <monochrom> actually, I am slightly wrong again. read calls lex. but you were doing reads, which doesn't call read. in practice, I guess the instance codes for Int and Double call lex after all. they share the same lexer.
19:31:47 <paulotruta> but when there's not, (only 5) it crashes
19:32:21 <LoliShana> What does 'lex' stand for?
19:32:22 <lispy> paulotruta: you can get a similar, but often less error-prone, result by using pattern matching
19:32:30 <irene-knapp> lexically analyze
19:32:58 <LoliShana> Right, is there a tl;dr explanation or am I going to have to go to Wiki, open an article, and end up with 80 Wiki tabs open?
19:33:14 <paulotruta> i know, now that i think about that... this function was not made by me but rather by a teacher of mine
19:33:16 <irene-knapp> turn from text into slightly-more-structured text
19:33:30 <lispy> seqtomusic (one:two:three:four:five:six:_) = Music one (read two) three four five (read six)
19:33:35 <tikhonjelvis> I think you just take your text and turn it into a stream of tokens.
19:33:39 <monochrom> no, you are going to buy/borrow and then read a 500-page book on compilers instead
19:33:48 <monochrom> 80 wiki pages won't do
19:34:04 <LoliShana> monochrom: any you recommend? I have a 24/7 library 50 metres from home
19:34:05 <tikhonjelvis> What would a good book be?
19:34:22 <tikhonjelvis> The class at my school doesn't have a book at all.
19:34:26 <paulotruta> but what if there is no 6?
19:34:38 <lispy> paulotruta: then the pattern fails to match
19:34:47 <lispy> paulotruta: so you may need more than one pattern
19:34:56 <paulotruta> yes, it does not parse, and it crashes
19:35:36 <monochrom> actually, it's pretty easy. lexer splits "fun x = x*(2+me)" into "fun", "x", "=", "x", "*", "(", "2", "+", "me", ")". that is all. it simplifies the rest of the parsing job.
19:35:40 <lispy> tikhonjelvis: the dragon book and the tiger book are both known for being classic compiler texts
19:35:49 <paulotruta> yup i see, the probem is that i have a type Media = Music { name :: String ... } | Video { name :: String ... }
19:36:00 <paulotruta> and the Music has 7 elements
19:36:04 <tikhonjelvis> Heh, there's a copy of the dragon book at home in Russian. I don't want to read it though.
19:36:12 <paulotruta> and the Video 6 elements
19:36:20 <paulotruta> and even when using pattern match
19:36:32 <LoliShana> lispy: Is it was too difficult to read on first year CS?
19:36:37 <LoliShana> way*
19:36:46 <lispy> tikhonjelvis: I told my copy of the dragon book because the type setting was ugly :)
19:36:49 <lispy> er, sold
19:36:58 <lispy> LoliShana: for most students, yes
19:37:02 <paulotruta> if the year field on the text file does not exist, it falls to be parsed to Video, and does not output in the end xD
19:37:22 <LoliShana> I couldn't read SICP if that's an indication.
19:37:28 <brainproxy> anyone can recommend an academic paper or other write-up which explores relationship between REST and functional programming?
19:37:52 * lispy runs away to study term rewriting
19:37:59 <paulotruta> well... gess i'm going to experiment a little more
19:38:02 <paulotruta> :)
19:38:25 <hamilyon|coo> > (fmap fst . listToMaybe . reads) "NULL" :: Maybe Int
19:38:27 <lambdabot>   Nothing
19:38:38 <LoliShana> Last book on compilers I opened had 3 floppies inside of it, so I decided to leave it for later...
19:38:52 <paulotruta> another question, maybe a stupid one :P
19:39:03 <Pseudonym> LoliShana: Which one was that? Holub?
19:39:04 <paulotruta> when was the first music made?
19:39:13 <Pseudonym> paulotruta: Prehistory.
19:39:26 <monochrom> at the big bang
19:39:28 <Pseudonym> Since hominids discoverd that hitting things or plucking bowstrings made sound.
19:39:34 <LoliShana> Pseudonym: No idea, we (Uni) have a large choice on compilers, yet only 1 book on Haskell
19:39:42 <LoliShana> Even worse, it relies on Windows library
19:39:46 <paulotruta> heheheh i mean that exists in digital format :P After 1280 ?
19:39:54 <LoliShana> 'The Haskell School of Expression'
19:40:07 <Pseudonym> paulotruta: We have Ancient Greek music still.
19:40:08 <monochrom> at the time the first finger (digit!) appeared
19:40:08 <irene-knapp> the cosmic microwave background exists in digital format
19:40:31 <LoliShana> I thought that sound doesn't expand in vacuum, which would mean that Big Bang would not really be music...
19:40:32 <tikhonje`> If you count Cage's 4'33" as music, it's been around forever :)
19:40:37 <LoliShana> Might be REALLY wrong here though.
19:40:53 <paulotruta> ok that was a stupid question hahahaha
19:40:53 <monochrom> the big bang was not vacuum. far from it
19:40:55 <irene-knapp> LoliShana: the Big Bang is played in the microwave spectrum, see
19:41:09 <LoliShana> monochrom: go on
19:41:25 <monochrom> THE END
19:41:35 <monochrom> (or is it THE BEGINNING?)
19:41:41 <LoliShana> dum dum dum!
19:41:44 <irene-knapp> it's the end of the beginning
19:41:45 <Pseudonym> THE BEGINNING of THE END
19:42:02 <Pseudonym> Vacuum isn't a vacuum.
19:42:19 <monochrom> anyway the big bang was full of particles, I have problems calling that vacuum
19:42:20 <tikhonjelvis> gnab gib would be the end
19:42:38 <Pseudonym> Was it full of particles, though?
19:42:50 <Pseudonym> I would imagine that at high enough energies, you wouldn't have "particles" as such.
19:42:59 <LoliShana> I should probably refine my idea of a vacuum.
19:43:30 <monochrom> full of good stuff, then
19:44:26 <LoliShana> Christ, emergin 1 of 10, back if 3 days.
19:53:14 <paulotruta> normalize :: [String] -> [String] ; normalize [] = "0" ; normalize (x:xs) = x:(normalize xs) ... What is wrong with this function?
19:53:19 <paulotruta> it is gving me an error
19:53:27 <paulotruta> Expected type: [String]
19:53:33 <paulotruta> Inferred type: [Char]
19:53:49 <LoliShana> Doesn't that mean it's nested?
19:54:15 <LoliShana> http://en.wikipedia.org/wiki/Principles_of_Compiler_Design             <- is this it?
19:55:15 <Eduard_Munteanu> paulotruta: [String] = [[Char]], do you really want that?
19:56:05 <Eduard_Munteanu> paulotruta: what's 'normalize' supposed to do?
19:56:45 <paulotruta> receives a list of strings (ie. ["hello", "how", "are"]
19:57:00 <paulotruta> and returns ["hello", "how", "are", "0"]
19:57:24 <monochrom> normalize [] = ["0"]
19:57:39 <Mongey> hey guys, just wondering why this doesn't work .... https://gist.github.com/1604724
19:57:39 <Eduard_Munteanu> > ["hello", "how", "are"] ++ ["0"]
19:57:41 <lambdabot>   ["hello","how","are","0"]
19:57:46 <LoliShana> "hello":"how":"are":"you":[]? Like so?
19:58:03 <paulotruta> ho, i see
19:58:41 <LoliShana> oops, "you" wasn't in the example...
19:58:52 <Eduard_Munteanu> Heh.
19:59:06 <paulotruta> i though that putting "0" the compiler understanded
19:59:11 <monochrom> return (partial ++ [input])
19:59:14 <paulotruta> because if you do it with Int
19:59:18 <Eduard_Munteanu> Damn pattern-matchy brain :)
19:59:20 <paulotruta> it works
19:59:40 <LoliShana> paulotruta: Give an example with Int?
19:59:55 <Mongey> monochrom: awesome thanks.
20:00:05 <Eduard_Munteanu> paulotruta: the compiler doesn't even try to understand if the types don't match.
20:00:19 <Mongey> monochrom: how come return needs to be there? is it because it's IO ?
20:00:25 <paulotruta> n :: [Int] -> [Int] ; n [] = 0; n (x:xs) = x:(n xs)
20:00:25 <monochrom> yes
20:00:55 <monochrom> @let n :: [Int] -> [Int] ; n [] = 0; n (x:xs) = x:(n xs)
20:00:56 <lambdabot>  <local>:9:46:
20:00:56 <lambdabot>      Ambiguous occurrence `n'
20:00:56 <lambdabot>      It could refer to either `L...
20:01:18 <monochrom> @let mono :: [Int] -> [Int] ; mono [] = 0; mono (x:xs) = x:(mono xs)
20:01:19 <lambdabot>  <local>:9:35:
20:01:19 <lambdabot>      No instance for (Num [Int])
20:01:19 <lambdabot>        arising from the liter...
20:02:23 <paulotruta> @let mono :: [Int] -> [Int] ; mono [] = [0]; mono (x:xs) = x:(mono xs)
20:02:24 <lambdabot>  Defined.
20:02:35 <Eduard_Munteanu>  @let mono :: [Int] -> [Int] ; mono [] = 0 :: Int; mono (x:xs) = x:(mono xs)
20:02:48 <paulotruta> ok... i think i'm too tired to think correctly if i'm failing with this :(
20:02:52 <monochrom> yeah, it has to be [0], therefore it has to be ["0"]
20:03:06 <Eduard_Munteanu> Poor lambdabot.
20:03:11 <Eduard_Munteanu> @let mono :: [Int] -> [Int] ; mono [] = 0 :: Int; mono (x:xs) = x:(mono xs)
20:03:11 <lambdabot>  <local>:10:0:
20:03:11 <lambdabot>      Duplicate type signature:
20:03:11 <lambdabot>        <local>:10:0-21: mono ::...
20:03:13 <monochrom> @undefine
20:03:15 <Eduard_Munteanu> Ah no, poor me :)
20:03:23 <Eduard_Munteanu> (extra space)
20:03:31 <LoliShana> I thought that [0] wouldn't go into [Int] but [[Int]]?
20:03:40 <shachaf> What's wrong with (++[0])?
20:03:51 <monochrom> dunno
20:04:00 <LoliShana> shachaf: Isn't ++ inefficient?
20:04:06 <Eduard_Munteanu> LoliShana: how so?
20:04:12 <monochrom> but I wouldn't want to map [x,y,0] to [x,y,0,0]
20:04:15 <Eduard_Munteanu> :t [0]
20:04:15 <lambdabot> forall t. (Num t) => [t]
20:04:20 <Eduard_Munteanu> :t [0 :: Int]
20:04:21 <lambdabot> [Int]
20:04:24 <paulotruta> you are right :)
20:04:26 <LoliShana> Eduard_Munteanu: Well, this is only what I read but apprently it makes a copy of the list, every time you use it.
20:04:49 <monochrom> I would want to map [x,y] to [x,y,0] and [x,y,0] to [x,y,0]. so at the end I still have to write my own recursion anyway
20:05:17 <shachaf> LoliShana: It will have to copy the spine of its left argument, yes. Just like "mono" is doing.
20:05:31 <Eduard_Munteanu> LoliShana: only the spine is recreated. The idea is it has to go over the whole list, but if you want to arbitrarily snoc to a list, there's no more efficient way.
20:05:31 <LoliShana> shachaf: Right.
20:05:34 <shachaf> It's impossible not to do that. That's the point.
20:05:52 <LoliShana> Ah, I see. Sorry, really new to Haskell...
20:05:56 <Eduard_Munteanu> You'd have to use a different data structure for efficient snoc-ing.
20:05:58 <monochrom> but I guess you could examine last xs instead
20:06:10 <Eduard_Munteanu> (appending, I mean)
20:07:30 <Eduard_Munteanu> Seqs support efficient appending to both ends, if you're interested in that sort of stuff.
20:08:21 <LoliShana> I'm interested in everything. Well, except in what I have to actually be doing at the moment.
20:11:17 <monochrom> the space of your interest has a singularity
20:12:02 <LoliShana> I am not sure what that means but I am guessing that it means that I am interested in a specific area.
20:19:37 <Eduard_Munteanu> Unfortunately, that means there's an event horizon preventing you from actually looking into it :P
20:20:09 <LoliShana> Eduard_Munteanu: Would that 'event horizon' be things like lazyness and lack of resources?
20:21:17 <Eduard_Munteanu> Maybe, nobody can escape laziness. :)
20:21:29 <LoliShana> laziness*, right.
20:21:58 <LoliShana> There is this great website a clever collegue of mine linked me to recently, the very first quote describes what I mean: http://www.structuredprocrastination.com/
20:28:14 <Sgeo> About Yesod:
20:28:15 <Sgeo> <cythrawll> question i have... how does the signature prevent hijacking if the signature is in the same cookie?
20:28:15 <Sgeo> <cythrawll> if someone hijacks the cookie, they'll have the signature as well.
20:29:08 <parcs`> the cookie is specific to an ip
20:29:38 <c_wraith> how does that help, if you steal it from someone behind the same NAT as you?
20:30:21 <parcs`> in that case it doesn't
20:30:36 <c_wraith> and honestly, those are the easiest people to steal cookies from
20:30:44 <c_wraith> unsecured wifi networks
20:31:09 <monochrom> you can walk to their desks and open their jars
20:31:26 <monochrom> and find rats
20:31:54 <c_wraith> noted:  monochrom stole the cookie from the cookie jar.
20:33:11 <mlh> monochrom: ion Peaker shachaf ; if you like that puzzle you might like http://en.wikipedia.org/wiki/Knights_and_Knaves and Raymond Smullyan's puzzle books
20:33:21 <mlh> OT -- but just reminded me of it
20:34:30 <monochrom> in fact, you also like: http://www.cs.toronto.edu/~trebla/eq-wiltink.pdf , a paper I smuggled out of a pay wall
20:36:55 <monochrom> you meet Mr. P, a knight or a knave. P says, "if I am a knight, I'll eat my hat."
20:37:12 <shachaf> monochrom: I am reminded of http://lesswrong.com/lw/ne/the_parable_of_the_dagger/
20:38:19 <monochrom> let k stand for "P is a knight", and h stand for "P will eat his hat". the information we have is formalized as (k iff (k implies h))
20:40:01 <monochrom> (k iff (k implies h)) = (k iff (k iff (k and h))) = ((k iff k) iff (k and h)) = (k and h)
20:40:17 <monochrom> "iff" is associative. he is a knight and he will eat his hat.
20:40:30 <LoliShana> As knights do.
20:41:08 <LoliShana> I went from compiler article on Wiki to a pdf about beetles being attacted to 370ml beer bottles in Australia. Thanks guys.
20:41:46 <LoliShana> attracted*
20:42:41 <tikhonjelvis> Now you just have to apply that knowledge when you write a compiler--have it compile your program *and* attract beetles.
20:42:47 <mlh> shachaf: nice.
20:43:03 <mlh> LoliShana: 375ml; I don't think we have 370
20:43:29 <LoliShana> mlh: The article said 370mL, also called 'studdies'
20:43:31 <tikhonjelvis> And 5ml of beer is quite a lot if you're a beetle :)
20:43:34 <LoliShana> Let me find a link...
20:43:37 <mlh> I also like the notion of exploding heads in http://en.wikipedia.org/wiki/The_hardest_logic_puzzle_ever
20:43:38 <XexonixXexillion> should be stubbies
20:43:45 <LoliShana> Yes, stubbies.
20:44:10 <LoliShana> http://onlinelibrary.wiley.com/doi/10.1111/j.1440-6055.1983.tb01846.x/pdf             Hopefully this will work.
20:45:17 <XexonixXexillion> a stubby is 375mL
20:45:46 <paulotruta> OMFG ... :P
20:46:36 <LoliShana> You will have to provide a citation that proves that in 1980, a stubbie was 375mL and not 370mL.
20:47:00 <LoliShana> "Douglas (1980) published a photograph of a male buprestid beetle (Julodimorpha bakewelli White)
20:47:03 <LoliShana> attempting to copulate with a 370 mL beerbottle (a "stubbie"). We have recently observed this to be quite a
20:47:06 <LoliShana> common occurrence in the Dongara area of Western Australia.
20:47:09 <LoliShana> "
20:48:38 <LoliShana> "The capacity of a stubby is generally somewhere between 330 ml (11.6 imp fl oz; 11.2 U.S. fl oz) and 375 ml (13.2 imp fl oz; 12.7 U.S. fl oz). The Canadian stubby bottle was traditionally 341 ml (11.5 U.S. fl oz; 12.0 imp fl oz) while the U.S. longneck was 355 ml (12.0 U.S. fl oz; 12.5 imp fl oz). "
20:48:56 <LoliShana> Seems that there is no standard for this. There should be one.
20:49:09 <mlh> yep 375 is chosen because its 3/8 of a litre and closee to the old standard in fl oz.
20:49:45 <conal> any haskell-src-exts users here? i'm looking for a way to add minimal parens automatically right before or during pretty-printing.
20:49:54 <LoliShana> 3/8 seems like a pretty random number...
20:50:37 <XexonixXexillion> I haven't seen any stubbies that aren't 375mL currently, but I suppose 30 years ago it is quite feasible that they were slightly smaller
20:51:07 * DanBurton wonders what "stubby" has to do with Haskell
20:51:56 <LoliShana> DanBurton: Well, I got to a "stubby" from Lexical Analysis which was mentioned here, but I do apologise for off-topic.
20:52:21 <JoeyA> I noticed a strange bug involving Data.Serialize.  If I say runGetPartial remaining "hello", it returns Done 5 "hello"
20:52:41 <conal> ah -- perhaps it's applyFixities (http://hackage.haskell.org/packages/archive/haskell-src-exts/1.11.1/doc/html/Language-Haskell-Exts-Fixity.html#v:applyFixities)
20:52:56 <JoeyA> However, if I say runGetPartial (B.length `fmap` get) "hello", I get Partial _
20:53:12 <JoeyA> remaining = B.length `fmap` get  -- definition directly from Data.Serialize.Get
20:58:44 <paulotruta> see ya :)
21:00:37 <dustmote> i'm very new; what's the deal with "main"? does it's type always have to be IO (), requiring that it start with a do?
21:00:53 <tikhonjelvis> Just because it's an IO () doesn't mean it has to start with do.
21:01:04 <tikhonjelvis> So you can do something like
21:01:12 <tikhonjelvis> main = putStrLn "blarg"
21:01:19 <shachaf> dustmote: Its type can be IO a for any a.
21:01:36 <shachaf> But what the "a" is is ignored.
21:01:43 <shachaf> Except for a bug in runghc, if you're using runghc.
21:02:09 <dustmote> but i can't do something like... main = map (+1) [1,2,3] ... right?
21:02:25 <tikhonjelvis> yeah, you have to have a result in IO
21:02:44 <dustmote> or make calls to my local functions, unless i (a) sequence them or (b) make them have IO too?
21:03:07 <mzero> main = print $ map (+1) [1,2,3]
21:03:10 <tikhonjelvis> umm, what exactly do you mean by "sequence" in this case?
21:03:27 <tikhonjelvis> You can use your pure functions, you just have to have some way of outputting the answer
21:03:34 <tikhonjelvis> otherwise the program probably isn't very useful
21:04:38 <mzero> print, for example is a function that takes a pure result, and creates an IO action that prints it to stdout
21:04:58 <shachaf> A pure IO action, moreover. :-) The word "pure" is a little redundant.
21:06:01 <mzero> the value print takes can be computed via your local functions with all the joyful laziness and non-sequenced-ness of functional programming, and all not in IO
21:06:03 <dustmote> okay.. that makes sense.. a program has a bit of impure io to print the result of a pure calculation..
21:06:14 <tikhonjelvis> exactly
21:06:21 <mzero> true dat, shachaf - "pure" is sort of a silly term to be using
21:06:43 <Cale> The impure part is in the runtime system which executes the IO action called main, and carries out all the effects described along the way
21:07:00 <tikhonjelvis> We can just say that pure = not IO for this conversation :)
21:07:06 <Cale> Or, you should think of it that way at least, even if the implementation doesn't work quite like that.
21:07:18 <tikhonjelvis> I think talking about how IO values are technically pure is more than a little confusing at the very beginning.
21:07:36 <dustmote> and i am at the beginning ;)
21:07:46 <Cale> It's specifically the execution of IO actions which is effectful (or impure), the IO actions themselves are harmless. :)
21:07:56 <Cale> (they're just descriptions of things which could be done)
21:08:00 <shachaf> tikhonjelvis: Yes, but it's important to understand what IO actions are.
21:08:14 <shachaf> Otherwise you'll just be misinformed and wrong. You wouldn't want to be wrong, would you?
21:08:21 <mzero> well, one needs to get used to the idea that you can manipulate IO actions - as data - without "executing" them:
21:08:27 <tikhonjelvis> shachaf: that's true. However, you run into a chicken and egg sort of problem
21:08:28 * shachaf "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
21:08:45 <tikhonjelvis> to be correct you have to understand, but to understand you need something simple to start with
21:09:22 <shachaf> tikhonjelvis: Fortunately correct things can be simple.
21:10:12 <mzero> main = sequence_ $ map snd $  filter ((<3).fst) $ [ (2, putStrLn "hello"), (5, putStrLn "goofball"), (1, putStrLn "world") ]
21:10:15 <tikhonjelvis> That's true. The problem is that I'm really bad at guessing what's simple for other people.
21:10:42 <shachaf> @src mapM_
21:10:43 <lambdabot> mapM_ f as = sequence_ (map f as)
21:11:24 <mzero> so there, we've built up some IO values, and the combined them with non-IO values, manipulated them via the non-IO functions filter and map --- and finally combined the results into a single IO action (via sequence_)
21:11:36 <mzero> only that final action, main, gets run -
21:11:49 <shachaf> FSVO "only"
21:12:24 <mzero> shachaf: yes, but I was trying to point out that one should learn to be comfortable using non-monadic functions on things like IO actions
21:12:56 <shachaf> I mean that, in particular, (putStrLn "hello") and (putStrLn "world") also get run.
21:13:52 <mzero> yes, as part of the combined action returned by sequence_ ... indeed ... we all agree.... and we're probably straying far from what dustmote was asking about!
21:14:07 <mzero> :-) are we helping there, dustmote ?
21:14:31 <dustmote> i'm still digesting mzero's example a few lines up..
21:15:13 <shachaf> That example seems needlessly confusing. Maybe not if you're sufficiently familiar with the rest of it.
21:15:23 <shachaf> Really the best way to learn IO in Haskell easily is to know the rest of Haskell well.
21:15:45 <tikhonjelvis> Except you need just a little bit of it to do *anything* with the rest of the language.
21:15:53 <shachaf> No, you can use ghci.
21:15:54 <tikhonjelvis> Unless you're going to just sit in GHCi, I guess.
21:16:14 <tikhonjelvis> Which is probably not a bad option.
21:16:24 <shachaf> I think a good way to teach Haskell IO to someone is to tell them "here's Haskell, the pure language that you're already somewhat familiar with; think about how you might represent IO in it".
21:17:19 <shachaf> Where there are many different solutions, including main :: String (output-only), main :: String -> String (interact), main :: [Response] -> [Request] (1.early-style), main :: Action where data Action = Exit | PutChar Char Action | GetChar (Char -> Action) | ..., and so on.
21:17:32 <DanBurton> shachaf: any good tutorials that you know of that take that approach?
21:17:33 <dustmote> i'm using it for a class where i'll be manipulating datasets in complex ways -- i used python last semester and found it needlessly complicated, and now i'm trying to ramp-up haskell enough to do something like read file, functionally analyze, write file
21:17:47 <DanBurton> to IO, I mean
21:17:52 <tikhonjelvis> The first one I thought of when I was learning was an infinite stream type thing.
21:18:05 <shachaf> DanBurton: If I say "no", you won't take that as your cue to write one, I hope?
21:19:32 <dustmote> anyhow, my question has been answered.. :) thank yo uall
21:40:49 <tikhonjelvis> What's the standard directory structure for test files? I've looked at some random projects on GitHub and everybody seems to do it differently.
21:42:05 <kuznero> Hi, All!
21:42:14 <Sgeo> Hi
21:43:07 <kevinm416> Hi, new user here. I'm having problems importing Data.String.Utils in ghci. Is there anything else I need to install first?
21:45:08 <kuznero> kevinm416: you will need to install MissingH package
21:45:22 <kuznero> As far as I remember...
21:47:13 <BMeph> I like this:
21:47:17 <BMeph> "Let us not forget, however, that "side effect" is a phrase we use to describe effects we do not like. There are no side effects. There are only effects."
21:47:34 <kuznero> :)
21:47:43 <kevinm416> kuznero: Ah, I do see MissingH on the Hackage page for Data.String.Utils. Is this something I install with cabal?
21:48:11 <kuznero> kevinm416: yes, just try> cabal install MissingH
21:49:19 <conal> BMeph: nice. source?
21:51:02 <kevinm416> kuznero: thanks, worked perfectly :)
21:51:19 <BMeph> conal: Believe it or not, Gary North. (Look him up, and you'll understand the first part.)
21:51:20 <kuznero> welcome ! :)
21:51:40 <BMeph> Its context was in political economics, and yet...it fits. :)
21:52:00 <Sgeo> o.O what's the difference between forceMaybe and fromJust?
21:52:13 <Sgeo> http://hackage.haskell.org/packages/archive/MissingH/1.1.1.0/doc/html/Data-Maybe-Utils.html
21:52:18 <Sgeo> Besides a different error message
21:53:01 <tikhonjelvis> They're from different packages, aren't they? I've only ever seen fromJust.
21:54:00 <tikhonjelvis> Yeah, I have no idea why that's there.
21:55:12 <Sgeo> forceMaybeMsg could be useful, I guess, but it's trivially forceMaybeMsg = fromMaybe . error
21:55:16 <Sgeo> I think
21:55:20 <Sgeo> :t fromMaybe . error
21:55:21 <lambdabot> forall a. [Char] -> Maybe a -> a
21:59:54 * conal googles
22:01:24 <conal> BMeph: got it
22:02:16 <BMeph> conal: My one-word summary - "Sobering"> :/
22:44:39 <koral> hi, when will haddock support packages where there is both a program and a library, the former requiring the latter ?
22:47:04 <DanBurton> koral: you could ask on the mailing list
22:47:11 <DanBurton> koral: see the bottom of http://www.haskell.org/haddock/
22:47:32 <koral> I will
22:47:37 <DanBurton> koral: or check the Trac stuff
23:40:13 <pshrmn> How can I use an refer to an infix operator (such as !!) like Prelude.!!?
23:40:46 <shachaf> pshrmn: Just like that.
23:40:52 <FUZxxl> It depends.
23:40:57 <FUZxxl> What is your GHC version?
23:41:07 <FUZxxl> It changed in Haskell 2010
23:41:08 <shachaf> FUZxxl: In what way does it depend?
23:41:15 <FUZxxl> before, it was like Prelude.(!!)
23:41:15 <pshrmn> 7.0,3
23:41:33 <FUZxxl> Or maybe after....
23:41:35 <shachaf> FUZxxl: I've never heard of it being Prelude.(!!)
23:41:44 <shachaf> And anyway pshrmn was asking about infix usage.
23:41:45 <FUZxxl> maybe that's what they want it to make
23:41:51 <FUZxxl> maybe...
23:42:07 <shachaf> I don't see why. Prelude.(!!) doesn't make sense.
23:42:11 <FUZxxl> AFAIK the wanted to fix the [ Foo .. bar ] vs. [Foo..Bar]] ambiguity
23:42:21 <shachaf> > [1,2,3] Prelude.!! 1
23:42:22 <lambdabot>   2
23:42:36 <FUZxxl> [True..False]
23:42:39 <FUZxxl> > [True..False]
23:42:40 <lambdabot>   A section must be enclosed in parentheses thus: (`True..` False)Not in scop...
23:42:43 <FUZxxl> > [True ..False]
23:42:44 <lambdabot>   []
23:43:05 <FUZxxl> (const Prelude.. id) 0
23:43:08 <FUZxxl> > (const Prelude.. id) 0
23:43:10 <lambdabot>   Not in scope: `Prelude..'
23:43:16 <FUZxxl> (const Prelude.(.) id) 0
23:43:23 <FUZxxl> :i (.)
23:43:29 <FUZxxl> >(const Prelude.(.) id) 0
23:43:32 <FUZxxl> > (const Prelude.(.) id) 0
23:43:32 <lambdabot>   Not in scope: data constructor `Prelude'
23:44:38 <ddarius> FUZxxl: That would just replace it with a Just.(#) /= Just . (#) ambiguity.
23:46:21 <ddarius> Writing (Prelude.(!!)) would also be a bit stupid.
23:48:09 <Blkt> good morning everyone
23:54:44 <pshrmn> Would it be a dumb idea to create a 2D array by merging a boxed and unboxed array togther?
23:55:21 <pshrmn> and by array I mean vector like type Foo =(Boxed.Vector (Unboxed.Vector Int))
23:56:00 <c_wraith> why not just use a single unboxed vector?
23:56:27 <c_wraith> and just have a function on hand that converts from multiple coordinates to a single coordinate?
23:56:37 <pshrmn> growing and shrinking would be slow pain
23:57:14 <c_wraith> that's true, but not a common requirement.
23:57:15 <Peaker> ddarius: I think Prelude.(!!) would already be prefix form
23:57:26 <c_wraith> If that's one of your requirements, well, ok, maybe not such a bad idea
