00:08:01 <sopvop> So, I need to build a new list by prepending inside fold.  Should I go reverse . foldl'  (building new list with prepend inside fold) or foldr . reverse? The second one looks better to me.
00:08:11 <elliott> tikhonjelvis: attoparsec is similar to parsec, but there are some differences
00:08:19 <elliott> for instance, every parser backtracks, so "try" is unnecessary
00:08:23 <tikhonjelvis> ah
00:08:48 <elliott> also, of course, attoparsec only works on bytestring and text, not string :)
00:09:06 <elliott> and attoparsec supports incremental parses which parsec doesn't
00:09:23 <elliott> but there's none of the language stuff that parsec has, and the error messages aren't as good (as a design trade-off)
00:09:56 <tikhonjelvis> Hmm, I have to admit I haven't bothered with the language stuff anyhow. Of course, I've only done relatively trivial things.
00:10:12 <tikhonjelvis> I'll just use attoparsec next time I need to parse something then.
00:13:32 <jeltsch> tikhonjelvis: Hi, I don’t know if you have noticed that the natural-numbers package has received quite a few updates, mostly fixing bugs.
00:13:47 <tikhonjelvis> that's good
00:13:53 <jeltsch> There is one issue left, however.
00:14:32 <jeltsch> Pattern matching against negative literals doesn’t work, because Haskell’s method for this relies on negative numbers to exist, as far as I know.
00:14:56 <jeltsch> I will see if I can do something about this, but I fear it might not be possible. :-(
00:14:58 <tikhonjelvis> Well, it doesn't make sense anyhow...
00:15:08 <jeltsch> In a way, yes.
00:15:53 <jeltsch> But matching a natural number against a pattern -5 should maybe not result in a runtime error, but just in the pattern match to fail.
00:16:32 <tikhonjelvis> In a perfect world it'd be a static error
00:16:36 <jeltsch> I mean, case 5 of { -5 -> "minus five"; 5 -> "plus five" } should maybe return "plus five" instead of a runtime error.
00:16:57 <tikhonjelvis> But given those two choices, ignoring the -5 does make more sense.
00:17:12 <jeltsch> On the other hand, a pattern -5 is nonsense for natural numbers.
00:17:19 <jeltsch> A static error would be good here indeed.
00:17:51 <jeltsch> While the above case expression gives a runtime error, swapping both cases would result in an expression that succeeds.
00:18:08 <jeltsch> That’s weird, I’d say.
00:18:52 <jeltsch> The problem is that a negative pattern actually causes negation of the value matched against it, not of the number in the pattern (5 in this case).
00:19:14 <jeltsch> This is actually a weird behavior, which just happened to be okay for the usual number types.
00:20:13 <hpaste> Palmik pasted “GHC.Generics test” at http://hpaste.org/56989
00:20:17 <tikhonjelvis> How does this work for other types like Word?
00:20:35 <tikhonjelvis> Oh, never mind, I see.
00:22:44 <Palmik> Hi guys, have anyone here worked with the GHC.Generics? I have the code http://hpaste.org/56989 here, what troubles me is the part where I work with selectors. I use genericToBSON recursively now, but I would like to say something like this: http://hpaste.org/56990 which does not work.
00:23:42 * jeltsch wonders where the Haskell reports describes pattern matching with negative literals.
00:24:18 * jeltsch is annoyed that he wrote “reports” instead of “report”. ;-)
00:24:30 <elliott> Well, there are multiple :)
00:30:45 <jeltsch> Does anybody know where the Haskell report describes how negative patterns are matched against?
00:31:15 <jeltsch> I couldn’t find anything about this in the report, but I think there was some discussion on some Haskell-related mailing list at some point.
00:31:49 <Sgeo> So, Erlang port of do notation. Guess what misfeature of Haskell's they port over?
00:32:08 <Palmik> OK, got it :) This is the correct way for anyone wondering http://hpaste.org/56991
00:32:55 <tikhonjelvis> Sgeo: fail?
00:32:57 <Palmik> Sorry, without the "GenericToBSON (K1 i a), " :)
00:33:19 <Sgeo> fail
00:33:32 <tikhonjelvis> self-referencing
00:34:02 <elliott> Sgeo: Being able to recover from failed pattern-matches in do-notation is not a misfeature.
00:34:22 <elliott> I doubt Erlang has typeclasses, so there's no way for it to have made the same mistake as Haskell, at least unless they were trying really hard.
00:34:48 <c_wraith> Erlang doesn't really even have more than 3 types
00:34:55 <c_wraith> well, ok, that's undercounting
00:35:08 <tikhonjelvis> I've always seen it referred to as dynamically typed.
00:35:24 <Sgeo> They said that they did something hacky to get something like typeclasses, I'm not really sure. Not finished reading.
00:35:25 <Sgeo> https://github.com/rabbitmq/erlando
00:35:25 <c_wraith> But there are like tuples, symbols, a few numeric types, and a couple string types
00:35:27 <mm_freak> why is that a misfeature anyway?
00:35:44 <mm_freak> it's implemented in an unfortunate way, but it's certainly not a misfeature
00:36:21 <c_wraith> Why *should* pattern-matching in a <- function differently from pattern-matching in a let?
00:36:39 <c_wraith> The only real answer I can get for that is "It allows you to write clever code"
00:36:50 <c_wraith> Which isn't compelling to me.
00:36:52 * hackagebot hlint 1.8.21 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.21 (NeilMitchell)
00:36:54 <mm_freak> in do-notation you have enough context to handle pattern match failures
00:37:01 <mm_freak> you don't have that in let-bindings
00:37:01 <tikhonjelvis> c_wraith: I dunno, I've always liked that justification.
00:38:35 <c_wraith> perl allows you to write clever code.  Heck, it allowed me to write some of the stupidest clever code I've ever done.
00:38:42 <frerich2> I might be missing something, but is this really specific to "do" notation? I thought it's generic to all monads (which exploit this with more or less success).
00:38:43 <c_wraith> But that's not a compelling reason for me to use it.
00:38:51 <frerich2> > [x | (x:xs) <- ["Foo", "", "Bar"]]
00:38:51 <lambdabot>   "FB"
00:39:01 <c_wraith> frerich2: it's specific to do notation and comprehensions
00:39:08 <tikhonjelvis> I'm conflicted about perl: it feels like I should dislike it, but it's fun.
00:39:10 <c_wraith> frerich2: only places where <- is used
00:39:30 <tikhonjelvis> Comprehensions are basically the same as do notation anyhow, no?
00:39:48 <c_wraith> almost, though it turns out they're desugared very differently
00:40:12 <c_wraith> also, GHC's new monad comprehension extension adds a bunch of interesting stuff that's not in do notation
00:40:13 <tikhonjelvis> Is that basically an implementation detail?
00:40:16 <jeltsch> tikhonjelvis: My comment “The problem is that a negative pattern actually causes negation of the value matched against it, not of the number in the pattern (5 in this case).” might actually be wrong.
00:40:18 <tikhonjelvis> Like?
00:40:32 <tikhonjelvis> jeltsch: Did you find the appropriate bit in the report?
00:40:41 <c_wraith> I'm not sure on the details, but it's a bunch of stuff designed for handling ordering and grouping.
00:40:51 <jeltsch> Even if the value in the pattern is negated, it will fail.
00:40:55 <c_wraith> basically, it came out of research done for using LINQ for SQL
00:40:59 <mm_freak> c_wraith: a counterjustification is:  "haskell allows you to handle failed pattern-matches where there is enough context"
00:41:00 <jeltsch> I didn’t find anything in the report regarding negation.
00:41:12 <mm_freak> so in do-notation you can handle, in let-bindings you can't
00:41:14 <tikhonjelvis> c_wraith: Oh, I heard something about that. Should be interesting.
00:41:50 <jeltsch> But at least for non-negated integer patterns, the report says that fromInteger is applied to the pattern.
00:41:53 <mm_freak> i'd just move 'fail' out of Monad
00:41:56 <jeltsch> This is the problem.
00:42:02 <mm_freak> it becomes to where it originally came from:  MonadZero
00:42:05 <elliott> c_wraith: do notation is the *only* way to overload pattern matching.
00:42:09 <tikhonjelvis> fromInteger?
00:42:15 <mm_freak> and in fact i'd extend this to arrow notation, too, where we have ArrowZero
00:42:16 <mm_freak> it'
00:42:19 <elliott> c_wraith: Without a way to overload pattern matching, several patterns become extremely awkward to express.
00:42:19 <jeltsch> tikhonjelvis: Yes.
00:42:23 <mm_freak> it's about the feature i'm missing most with arrows
00:42:27 <elliott> c_wraith: Also, do you object to [x | Just x <- xs]?
00:42:27 <tikhonjelvis> jeltsch: makes sense
00:42:35 <c_wraith> elliott: I object to that strenuously
00:42:40 <elliott> Really?
00:42:42 <c_wraith> It's cute, but that's all
00:42:44 <jeltsch> So the pattern -5 is probably transformed to a natural and the comparison happens with naturals. But fromInteger (-5) :: Natural fails.
00:42:48 <tikhonjelvis> jeltsch: That's what I would have guessed it did.
00:42:49 <elliott> We might as well just get rid of list comprehensions, then...
00:42:57 <c_wraith> no, list comprehensions are great.
00:43:01 <jeltsch> It should be the other way round.
00:43:11 <tikhonjelvis> How do you mean?
00:43:15 * Sgeo vaguely wonders if c_wraith objects to PatternGuards
00:43:18 <jeltsch> Apply toInteger to the value matched against the pattern, than c
00:43:23 <elliott> OK, so, do you want to have to write a specific function for every single pattern-match you want to do? i.e. foo (Left (a,0)) = return a; foo _ = mzero?
00:43:24 <jeltsch> then comparing integers.
00:43:26 <tikhonjelvis> ah
00:43:28 <c_wraith> just treat something that's written as an irrefutable pattern as an irrefutable pattern
00:43:39 <tikhonjelvis> didn't think of that
00:43:52 <elliott> Saying "it's only useful for cute stuff" isn't really a compelling reason to remove the ability to overload one of the most important and primitive language constructs.
00:43:54 <jeltsch> But this wouldn’t work for fractional numbers, so you couldn’t match them against integer literals. :-(
00:44:04 <c_wraith> elliott: if people wrote/used eliminators more often, that wouldn't be an issue.
00:44:06 <mm_freak> Sgeo: apparently c_wraith objects to everything…  let's just return to the core language of haskell
00:44:08 <jeltsch> The point is this:
00:44:11 <elliott> Consider the list monad. Why is guard (isJust x) ok but not Just y <- x?
00:44:16 <c_wraith> Sgeo: nah, PatternGuards are fine.
00:44:16 <mm_freak> convenience features are bad
00:44:20 <jeltsch> We want to be able to match fractionals against integer patterns.
00:44:26 <jeltsch> Actually, all numbers.
00:44:30 <elliott> You can build failing computations with booleans but not arbitrary patterns. That's ugly.
00:44:47 <jeltsch> Usually, the respective numeric type is somehow larger than Integer.
00:44:56 <jeltsch> Contains also non-integers.
00:45:07 <dreixel> Palmik: let me know if you run into trouble with GHC.Generics
00:46:15 <c_wraith> PatternGuards are fine because if it doesn't match, you just go to the next case.  It's, you know, pattern matching.  Like as in pattern matching.
00:46:36 <c_wraith> There are no extra rules, just extra expressiveness
00:47:00 <jeltsch> But Natural is smaller than Integer.
00:47:10 <mm_freak> jeltsch: nope
00:47:25 <jeltsch> So applying toInteger to the expression would make more sense than applying fromInteger to the pattern?
00:47:30 <jeltsch> mm_freak: nope?
00:47:36 <mm_freak> jeltsch: they are the same size
00:47:38 <tikhonjelvis> jeltsch: But how would it know whether it was bigger or smalelr?
00:48:04 <jeltsch> tikhonjelvis: It cannot know, unfortunately, I think.
00:48:29 <jeltsch> mm_freak: Natural and Integer are not of the same size in that one value set is a subset of the other.
00:48:46 <Palmik> dreixel, alright :) I wanted to ask, whether I can distinguish these two (http://hpaste.org/56993) instances with some tag.
00:48:51 <jeltsch> tikhonjelvis: Note that a related problem exists also with, say, Double.
00:48:51 <elliott> That's a rather unconventional definition of "size".
00:49:14 <jeltsch> In a way, Double is larger. It contains also non-integer numbers.
00:49:17 <mm_freak> jeltsch: you can very well write a fromInteger function that maps all integers to natural numbers
00:49:19 <elliott> c_wraith: ah, so it's OK for patterns written as irrefutable to have special recovery behaviour, but only if it's on the LHS of =?
00:49:23 <mm_freak> jeltsch: uniquely that is
00:49:39 <tikhonjelvis> mm_freak: Yes, but in general, fromInteger is supposed to return the *same* number in a different type.
00:49:49 <jeltsch> But in another way, Double is smaller, since it cannot represent large Integers.
00:49:50 <c_wraith> elliott: what special recover behavior? If it doesn't match, it goes to the next pattern. What's special?
00:49:53 <elliott> I think it's overly cutesy. You should have to write everything as case statements. Even *that* recovers from failing patterns, but one has to make some concessions to cute tricks...
00:50:03 <mm_freak> tikhonjelvis: for some "same"
00:50:13 <elliott> c_wraith: let Left x = Right 42 in ... -- crashes the program
00:50:21 <elliott> f (Right 42) where f (Left x) = ...; ... -- might not crash the program!
00:50:27 <tikhonjelvis> If they weren't a reasonable "same" pattern matching them would just be weird.
00:50:28 <elliott> It's not standard irrefutable pattern-matching behaviour.
00:50:29 <elliott> Compare:
00:50:34 <mauke> > let Left x = Right 42 in ()
00:50:34 <lambdabot>   ()
00:50:36 <elliott> do Left x <- Right 42; ... -- might not crash the program
00:50:43 <elliott> mauke: OK, OK, x `seq` ...
00:51:16 <mm_freak> tikhonjelvis: you can make it such that you can't observe the difference
00:51:19 <jeltsch> elliott: Maybe this is a different issue. Our problem is that patterns like -5 cause a call to fromInteger, which might abort the program.
00:51:41 <mm_freak> tikhonjelvis: then you have a Natural type you can use as an Integer type
00:51:50 <jeltsch> tikhonjelvis: So this would also result in a runtime error: case 1 :: Double of { 10000000000000000000000000000 -> "very large"; _ -> "okay"
00:52:19 <jeltsch> It would try to convert 10000000000000000000000000000 to Double, which would result in a runtime error.
00:52:24 <c_wraith> > fromInteger 10000000000000000000000000000 :: Double
00:52:25 <lambdabot>   1.0e28
00:52:25 <elliott> jeltsch: I think that's a different discussion entirely.
00:52:31 <c_wraith> jeltsch: that's not a runtime error
00:52:42 <jeltsch> elliott: Okay, sorry.
00:52:49 <dreixel> Palmik: doesn't that code work already? with OverlappingInstances
00:52:51 <jeltsch> c_wraith: What is it then?
00:52:54 <tikhonjelvis> Yeah, two conversations just got interleaved. A perfect example of IO gone wrong :)
00:53:02 <c_wraith> it's a double value.
00:53:08 <mm_freak> lol
00:53:17 <c_wraith> it happens to even exactly represent the input, in this case
00:53:19 <jeltsch> c_wraith: You mean, 10000000000000000000000000000 is not large enough?
00:53:31 <jeltsch> @10000000000000000000000000000 :: Double
00:53:31 <lambdabot> Unknown command, try @list
00:53:35 <jeltsch> @list
00:53:35 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:53:38 <c_wraith> There are no runtime errors with doubles
00:53:38 <mm_freak> in any case, if there is a vote to improve pattern matching in do-notation, i'll vote for a separate MonadZero class
00:53:54 <mm_freak> if there is a vote to remove handling altogether, i'll strongly vote NO!
00:53:55 <tikhonjelvis> I tried doing that with 1e100000000000 but it just froze :(
00:54:01 <c_wraith> > 100000000000000000000000000000000000000000000000000000000000000000000000 :: Double
00:54:02 <lambdabot>   1.0e71
00:54:04 * jeltsch wonders what the shortcut for lambdabot expression evaluation is.
00:54:12 <jeltsch> Ah, okay.
00:54:13 <tikhonjelvis> >
00:54:21 <jeltsch> Okay.
00:54:33 <tikhonjelvis> Yay, killed GHCi trying to match my number.
00:54:35 <jeltsch> case 1 :: Double of { 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 -> "very large"; _ -> "okay" }
00:54:37 <c_wraith> > 1 / 0 :: Double
00:54:38 <lambdabot>   Infinity
00:54:39 <elliott> Honestly, fail isn't even the worst thing in the Prelude.
00:54:46 <c_wraith> Infinity isn't a runtime error
00:54:47 <mm_freak> > (2^100 :: Double) + 1 == 2^100
00:54:48 <lambdabot>   True
00:54:56 <jeltsch> > case 1 :: Double of { 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 -> "very large"; _ -> "okay" }
00:54:57 <lambdabot>   "okay"
00:55:03 <jeltsch> Hmm.
00:55:11 <tikhonjelvis> Yay for the floating point standard.
00:55:12 <jeltsch> > 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 :: Double
00:55:12 <mm_freak> jeltsch: what are you expecting?
00:55:12 <lambdabot>   1.0e89
00:55:18 <jeltsch> How large is Double?????
00:55:18 <c_wraith> jeltsch: there are no error cases in floating point arithmetic
00:55:23 <c_wraith> 64 bits
00:55:26 <jeltsch> Ah, okay.
00:55:33 <mm_freak> jeltsch: the exponent size matters
00:55:35 <c_wraith> (in GHC, etc, etc)
00:55:35 <tikhonjelvis> It just gets less and less accurate as your numbers get bigger.
00:55:45 <jeltsch> So in the “worst” case, it is just a NaN, which is not equal to 1.
00:55:50 <jeltsch> So the match just fails.
00:55:50 <elliott> jeltsch: By your reasoning, shouldn't "f x | x == chr 3589734859345 | otherwise = ..." execute ..., because x is not the character 3589734859345, which is valid in UniWTFcode?
00:55:53 <frerich2> Is this behaviour of lambdabut truncating the output after some time (in e.g. repeat 'x') a custom patch? I noticed that other installations don't truncate so early (they seem to go up to the maximum IRC message size, 512 bytes).
00:55:55 <mm_freak> > floatRange (undefined :: Double)
00:55:56 <lambdabot>   (-1021,1024)
00:55:56 <elliott> (Say chr is overloaded.)
00:56:12 <mm_freak> > 2^1024 :: Double
00:56:12 <lambdabot>   Infinity
00:56:13 <jeltsch> I know that the exponent matters.
00:56:14 * elliott agrees that in principle a negative or fractional pattern should just fail for naturals, but doesn't think it makes sense as a computable thing in general.
00:56:16 <mm_freak> > 2^1023 :: Double
00:56:16 <lambdabot>   8.98846567431158e307
00:56:19 <jeltsch> With size, I meant the “size” of the set3
00:56:24 <jeltsch> set3 → set
00:56:53 <elliott> I wasn't talking about the size (if that was in reply to me).
00:57:22 <elliott> I'm just saying that expecting to be able to check a value against an arbitrary other value of a type we decide to identify as a supertype isn't really realistic.
00:57:31 <mm_freak> elliott: i agree, and some people seem to forget:  some haskell programmers use haskell for practical stuff
00:57:34 <jeltsch> elliott: It was in reply to mm_freak.
00:58:11 <elliott> mm_freak: What's that in reply to?
00:58:13 <elliott> jeltsch: ah
00:58:16 <elliott> so much interleaving :)
00:58:19 <mm_freak> elliott: about fail
00:58:52 <elliott> mm_freak: Right. Well, I do think fail is an ugly kludge... it's just that I'd rather fix the rest of the Prelude before worrying about minor things like that :)
00:58:57 <jeltsch> elliott: It might not be realistic. The better solution would be to have a separate class for naturals (an Integral analog), for which negative patterns are ruled out statically.
00:59:12 <elliott> fail probably doesn't stop anyone getting stuff done; partiality of basic functions does because of all the bugs it causes.
00:59:24 <elliott> jeltsch: Yes, I'd like that.
00:59:35 <Palmik> dreixel, well, I have something like this http://hpaste.org/56994 and I would expect for "toBSON (Test "aa" "5" (Test0 "bb"))" to work (since String is instance of Val). Instead I get "No instance for (Val Test0)" but Test0 is instance of ToBSON, si the second instance of the selector should pick it up (and it does if I make String instance of ToBSON and remove the Val based selector instance).
00:59:42 <tikhonjelvis> More finely grained numeric type classes would make me happy.
00:59:44 <elliott> jeltsch: A subclass of Integral, presumably.
00:59:54 <jeltsch> elliott: Yes!
01:00:03 <jeltsch> > 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000 :: Ratio Int
01:00:03 <lambdabot>   0 % 1
01:00:04 <elliott> tikhonjelvis: Statements like that are why nobody ever actually agrees on a concrete incremental proposal :P
01:00:25 <donri> the real bad thing about partial functions is the lack of tracebacks for runtime errors
01:00:37 <jeltsch> > case 0 of { 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000 -> "not correct"; _ -> "correct" }
01:00:37 <lambdabot>   "correct"
01:00:44 <elliott> "OK, so we've agreed that for a natural typeclass, we need to have an algebraic numeric typeclass hierarchy, make Applicative a superclass of Monad, and add dependent types."
01:00:50 <mm_freak> elliott: i don't have a problem with having some way to fail…  ideally it would be in a separate type class like MonadZero or MonadFail
01:00:51 <donri> well... not getting the runtiem error in the first place is of course best
01:01:02 <tikhonjelvis> Also, actually dealing with those errors is actually *more* difficult than just learning how to use Maybe.
01:01:07 <jeltsch> > case 0 :: Ratio Int of { 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000 -> "not correct"; _ -> "correct" }
01:01:07 <lambdabot>   "not correct"
01:01:08 <jeltsch> lambdabot:   "correct"
01:01:20 <elliott> mm_freak: I don't think we're disagreeing :)
01:01:24 <jeltsch> > case 0 :: Ratio Int of { 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000 -> "not correct"; _ -> "correct" }
01:01:25 <lambdabot>   "not correct"
01:01:42 <elliott> I meant fail's presence in Monad is of course bad, it's just that the Prelude has a lot worse stuff in it.
01:01:45 <jeltsch> tikhonjelvis, mm_freak: So such a problem as with Natural also exists with Ratio Int?
01:01:48 <mm_freak> ok =)
01:01:50 <tikhonjelvis> The moral of this story is that computer suck with numbers :)
01:02:02 <jeltsch> Well, this is related to the wrap-around of Int, of course:
01:02:23 <elliott> Haskell 2012 proposal: Remove numbers, rename Bool to Bit.
01:02:29 <frerich2> tikhonjelvis : I think computers rock at calculations, but they suck at mathematics.
01:02:35 <jeltsch> > 2^64
01:02:36 <lambdabot>   18446744073709551616
01:02:41 <elliott> Anyone who wants to pretend they can represent anything other than a fixed-size sequence of bits on a computer gets to implement their own folly.
01:02:49 <jeltsch> > case 0 :: Int of { 18446744073709551616 -> "not correct"; _ -> "correct" }
01:02:50 <lambdabot>   "correct"
01:03:05 <elliott> frerich2: I would say it's the opposite!
01:03:08 <jeltsch> Strange!
01:03:23 <elliott> frerich2: Computers can't do simple calculations on the real numbers precisely, but mathematics is just symbol-manipulation, and computers are excellent at that.
01:03:27 <jeltsch> case 0 :: Word64 of { 18446744073709551616 -> "not correct"; _ -> "correct" }
01:03:28 <mm_freak> > (0 :: Int) == maxBound + 1
01:03:28 <lambdabot>   False
01:03:43 <jeltsch> > case 0 :: Word64 of { 18446744073709551616 -> "not correct"; _ -> "correct" }
01:03:43 <lambdabot>   "not correct"
01:03:43 <tikhonjelvis> To be fair, you couldn't do most of those calculations by hand either.
01:03:46 <mm_freak> > (0 :: Word) == maxBound + 1
01:03:47 <lambdabot>   True
01:03:59 <mm_freak> > (0 :: Int) == 2^32
01:04:00 <lambdabot>   False
01:04:02 <mm_freak> > (0 :: Int) == 2^64
01:04:03 <lambdabot>   True
01:04:21 <frerich2> elliott: I think computers can do all sorts of calculations if you choose to represent the values appropriately, but maybe this is a really lame argument now that I think about it.
01:04:35 <jeltsch> Considering all this weird behavior, a pattern match for naturals that results in a runtime error instead of a pattern match failure seems to be not so problematic. :-)
01:05:08 <tikhonjelvis> Just take a leaf from C and call it "undefined behavior".
01:05:24 <elliott> frerich2: Yes, but then it reduces to just symbols.
01:05:29 <jeltsch> At least, I’ll add a note to the docs of the natural-numbers package, stating that you shouldn’t match against negative literals or so.
01:05:33 <elliott> 2 = (zero, zero, one, zero)
01:06:01 <tikhonjelvis> That's more or less what type-level numbers look like anyhow, isn't it?
01:06:14 <tikhonjelvis> Except they use Church numerals, I guess.
01:06:30 <elliott> You can do binary too. But I think Haskell had lost all relevance in that thread :)
01:06:33 <frerich2> elliott: I'm not sure, but I suspect we agree even though we approach the situation from different angles.
01:06:40 <hpaste> VoQn pasted “Is List Literal with Number liar ?” at http://hpaste.org/56995
01:06:56 <VoQn> hi
01:08:16 <elliott> frerich2: I think it's just a choice of terminology, perhaps, or the layers we're perceiving things at. Sure, everything is bit-shifting at the lowest level, but anything that a computer can calculate with is a finite sequence of bits, and it can only do approximate calculations with anything that isn't; compare the fact that a proof checker can verify statements about the real numbers *precisely* with only a finite number of symbols, which is ver
01:08:16 <elliott> y much in the realm of mathematics and not calculation.
01:08:56 <tikhonjelvis> elliott: It's just a clever form of lossless compression.
01:12:26 <c_wraith> well.  there are computable reals, which allow arbitrary-precision computation of a superset of the algebraic numbers. It's true that it's always finite, but it's not bounded ahead of time.
01:12:43 <c_wraith> however, computable reals are terrible for things like... comparison operations
01:13:05 <c_wraith> because you can only operate on them extensionally.
01:14:26 <c_wraith> If you restrict yourself to sets like algebraic numbers, you can use intensional methods to make those operations computable.
01:14:50 <c_wraith> though decimal output will always only be an approximation
01:15:55 <frerich2> elliott: I think in the end it comes down to a sequence of bits being just, like, a burrito.
01:16:23 <elliott> frerich2: Whoa.
01:16:27 <elliott> I'm enlightened.
01:16:44 <tikhonjelvis> Aha, we have the new superclass for all the numbers now!
01:17:16 <elliott> class Burito b -- burritos are the maximally generic concept, and so no methods are imposed
01:18:55 <mikeplus64> I like burritos!
01:21:52 * hackagebot natural-numbers 0.1.0.1 - Natural numbers  http://hackage.haskell.org/package/natural-numbers-0.1.0.1 (WolfgangJeltsch)
01:22:59 <merijn> Any recommended intro papers on lenses?
01:23:17 * jeltsch is happy that hackagebot is online again.
01:24:32 <mm_freak> merijn: i learned them from the haddock docs
01:24:40 <mm_freak> it's not complicated
01:24:58 <tdammers> mm_freak: it's not complicated, but confusing
01:25:06 <donri> merijn: http://happstack.com/docs/crashcourse/AcidState.html#ixset_lens
01:25:20 <donri> merijn: http://www.scs.stanford.edu/11au-cs240h/notes/zipper.html
01:25:21 <tdammers> such as, which lenses package should I use? how do I use lenses, pragmatically?
01:25:28 <donri> you should use data-lens
01:25:29 <mm_freak> data-lens
01:26:00 <tdammers> yeah, figured this much by now ;)
01:26:18 <tdammers> links are looking good though, b/m'd
01:34:06 <merijn> donri: Thanks
01:41:19 <Leif_Bork> Hellu, can I serialize cyclic data types in Haskell?
01:43:52 <c_wraith> Leif_Bork: only if you use some technique which can observe the cycle
01:44:32 <Leif_Bork> c_wraith: How do you mean?
01:46:03 <c_wraith> a cyclic value is usually indistinguishable from a non-cyclic infinite value in haskell, thanks to referential transparency
01:46:52 * hackagebot CV 0.3.4 - OpenCV based machine vision library  http://hackage.haskell.org/package/CV-0.3.4 (VilleTirronen)
01:47:10 <c_wraith> but there are ways to augment structures such that cycles can become detectable.
01:47:30 <c_wraith> the generic name for those techniques is "observable sharing"
01:47:37 <Leif_Bork> Aah
01:47:53 <merijn> c_wraith: Hmm,  how do you actually implement cycle detection in haskell? In C you'd use the hare and tortoise algorithm but that becomes impossible without the ability to detect whether 2 references are identical, I think
01:48:13 <elliott> merijn: you get the ability to detect that
01:48:15 <elliott> with StableNames
01:48:20 <elliott> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/System-Mem-StableName.html
01:48:28 <c_wraith> www.ittc.ku.edu/~andygill/talks/20090903-hask.pdf
01:48:37 <c_wraith> goes into quite a bit of detail on the implementation
01:48:43 <c_wraith> and yes, it's based on stablenames
01:48:57 <Leif_Bork> Thank you
01:49:15 <c_wraith> here's the associated full paper, not just the presentation: www.ittc.ku.edu/~andygill/papers/reifyGraph.pdf
01:50:26 <c_wraith> oh, and a handy library on hackage that contains the implementation: http://hackage.haskell.org/package/data-reify
01:50:41 <Leif_Bork> Great
01:53:30 <elliott> Leif_Bork: you might want to consider just representing your structure with the cyclic nature explicit
01:53:36 <merijn> c_wraith: Yeah, I think StableNames would also make the hare and tortoise algorithm possible. Although that one is a bit useless if your data is infinite :p
01:53:39 <elliott> the behaviour of observable sharing is entirely dependent on compiler optimisations
01:53:54 <c_wraith> merijn: it won't ever return the wrong answer in that case!
01:53:57 <elliott> so most of the time a more explicit representation is probably preferable
01:54:19 <merijn> c_wraith: True, I didn't say the algorithm become wrong, just useless ;)
01:54:26 <merijn> s/become/became
01:54:45 <merijn> Or becomes, whatever. Screw this English business >.>
01:54:48 <c_wraith> actually, it will eventually run out of memory
01:55:55 <c_wraith> but yeah, the tortoise and hare algorithm is only guaranteed to terminate for data. codata makes it cry.
01:56:43 <Leif_Bork> elliott: How do you mean?
01:56:52 * hackagebot CabalSearch 0.0.1 - Search cabal packages by name  http://hackage.haskell.org/package/CabalSearch-0.0.1 (JohanBrinch)
02:10:38 <elliott> Leif_Bork: Well...
02:10:46 <elliott> With observable sharing, you can distinguish
02:10:52 <elliott> (repeat x) and (1 : repeat x)
02:10:56 <elliott> erm
02:10:58 <elliott> (repeat x) and (x : repeat x)
02:11:11 <elliott> A compiler is of course fully free to translate between the two, since they're equivalent.
02:11:29 <elliott> In general, optimisation can change whether structures are shared or not, so the graph result you get from observable sharing can change depending on them.
02:13:06 <srhb> I have some text documents (configuration files of various formats) wherein I want to replace certain values. I'd like to make templates of them and fill in values with Haskell. Is there a good way of going about this?
02:13:31 <unknownwarrior> hey guys
02:14:49 <unknownwarrior> on this page: http://www.haskell.org/tutorial/io.html there is an example how to read files, but ghci tells me that for example openFile isnt in scope. do i have to import something to make this work?
02:15:09 <srhb> unknownwarrior: import System.IO?
02:15:19 <srhb> Or is it just System, hmm
02:15:33 <srhb> unknownwarrior: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
02:16:04 <unknownwarrior>  srhb: thank you, its System.IO ;)
02:16:07 <srhb> unknownwarrior: Hoogle is the place to find out these things: http://www.haskell.org/hoogle/?hoogle=openFile
02:19:20 <elliott> unknownwarrior: you'll find that tutorial is very out of date
02:19:29 <elliott> all the module names will be wrong, since it predates hierarchical modules
02:19:40 <elliott> (circa 1998)
02:21:50 <everythingWorks> how can i suppress those output warnings? http://ideone.com/nIBOo
02:22:11 <everythingWorks> I mean: What's the actual problem? The type is deferred to int. That's okay and i dont care :D
02:22:51 <dschoepe> everythingWorks: It just tells you that it has to chose a type for 10 itself, and chooses Integer
02:23:20 <dschoepe> If you don't want that, you'd have to give one yourself, like `dbl (10 :: Integer)'
02:23:43 <srhb> Does anyone have a comment on which simple String template system to use?
02:24:03 <dschoepe> or restrict the type of dbl to `Integer -> Integer", but that's not very elegant
02:24:31 <dschoepe> srhb: I once used http://hackage.haskell.org/package/template, but that's _really_ simple.
02:24:45 <dschoepe> So it might lack some functionality you need.
02:26:12 <donri> dschoepe: quasiquotes does that better, for example http://hackage.haskell.org/package/interpolatedstring-perl6
02:26:41 <elliott> srhb: Compile-time or runtime?
02:26:43 <everythingWorks> dschoepe: what do you recommend to do?
02:26:47 <elliott> i.e. interpolated strings or actual templates?
02:26:54 <elliott> There's http://hackage.haskell.org/package/HStringTemplate for the latter.
02:27:29 <everythingWorks> calling it with dbl (10 :: Integer) ?
02:27:57 <dschoepe> everythingWorks: I think that there's no need to fix a warning that only occurs in ghci
02:28:31 <srhb> elliott: runtime, I think. I mean, I want to have a compiled command that given arguments will produce a file based on a template with values plopped in from the command argument or some kind of interaction
02:28:32 <donri> everythingWorks: give dbl a type signature
02:28:35 <dschoepe> If you later use it like that in your main function, I'd give it the type explicitly
02:28:52 <everythingWorks> donri: You mean the Integer -> Integer thing? :D
02:29:05 <donri> sure
02:29:08 <everythingWorks> Sorry, im kinda new to this :/
02:29:14 <everythingWorks> but i really like it :D
02:29:41 <elliott> srhb: Oh, you can interpolate runtime values.
02:29:50 <everythingWorks> both ways work, thanks!
02:29:54 <elliott> srhb: I just mean -- do you want the template embedded in your program, or loaded externally?
02:29:58 <merijn> everythingWorks: The problem is that your code only uses literal numbers, which are overloaded in Haskell (i.e. 10 can bet Int, Integer, Float, Double, etc), in this code you enver specified what the type of any of those numbers are
02:30:04 <elliott> i.e. something like perl/bash/whatever heredocs, or an actual template system?
02:30:18 <donri> srhb: do you need looping constructs and such?
02:30:19 <Cale> Whoa, how did everythingWorks get those warnings in the first place?
02:30:24 <dschoepe> donri: That's a more specific type than necessary though. "Num a => a -> a" would be the most general type, I think.
02:30:24 <Cale> I've never seen those :)
02:30:33 <everythingWorks> meriijn: Can i somehow specify that i accept ALL numeric types?
02:30:51 <Cale> everythingWorks: dbl :: (Num a) => a -> a
02:31:20 <merijn> everythingWorks: It already does that, it's just that you are calling it with "10" as argument (which can also be any type), so it has to pick one of the possible ones
02:31:29 <Cale> everythingWorks: Are you running GHC with -Wall or something?
02:31:54 <donri> you mean ghci with -Wall?
02:31:58 <Cale> (or yes, ghci)
02:32:08 <donri> i think i've gotten that warning too, and i have :set -Wall in my .ghci
02:32:13 <merijn> everythingWorks: If the surrounding program has a more specific type (for example, you give it an Integer rather than 10, which is Num a) then the warning should go away
02:32:14 <everythingWorks> Cale: I dont know, im running it currently within Eclipse
02:32:25 <Cale> oh, Eclipse is probably adding -Wall to the commandline
02:32:35 <Cale> -Wall is *very* noisy and obnoxious
02:32:42 <Cale> I tend not to use it
02:32:55 <everythingWorks> Ugh, okay
02:32:59 <donri> I tend to set -Wall and then selectively silence specific warnings
02:33:21 <Cale> Though it's good for running specially to clean things up at some point
02:33:40 <everythingWorks> What exactly does dbl :: (Num a) => a -> a mean?
02:33:53 <Cale> It means that for any type a which is an instance of the class Num
02:33:53 <everythingWorks> For any numeric type a, take an a as argument and return a value of type a?
02:33:53 <donri> Num  is a "type class"
02:33:55 <ChristianS> a think using -Wall is a good idea, as is using hlint
02:34:08 <Cale> dbl will take a parameter of type a and produce a result of type a
02:34:18 <Cale> yes, exactly
02:34:28 <everythingWorks> okay
02:34:46 <donri> Num defines the functions like + etc
02:34:50 <Cale> ChristianS: Yeah, but I think using -Wall *like you use hlint* is more what you're probably better off doing usually
02:34:50 <everythingWorks> May it be that ">" operator is not defined for all numeric types?
02:35:02 <dschoepe> ChristianS: Heeding every hlint warning is not always a good idea though.
02:35:05 <everythingWorks> -> http://ideone.com/pEnus
02:35:18 <Cale> everythingWorks: ah, that is true as well
02:35:22 <Cale> sorry about that
02:35:30 <Cale> I didn't look too closely at your program :)
02:35:31 <merijn> everythingWorks: > is defined for the class Ord, most (note, not all) Numeric types are instances of Ord
02:35:32 <donri> yea I tend to run hlint and selectively silence it too
02:35:39 <Cale> (Ord a, Num a) => a -> a  then :)
02:35:56 <ChristianS> dschoepe: can you give examples? i tend to find the default hlint rule set quite reasonable
02:36:01 <everythingWorks> merijn: Which [numeric] types do not implement Ord?
02:36:07 <Cale> Complex Double
02:36:09 <Cale> for example
02:36:23 <Cale> A square matrix type wouldn't
02:36:49 <merijn> everythingWorks: You can define new instances of Num. Suppose someone defines a Num instance for matrices, then you wouldn't necessarily have an ordering for those
02:36:53 <everythingWorks> complex and matrices are replicable, but "double"?
02:37:04 <Cale> hmm
02:37:04 <cheater> how do you define new orders?
02:37:06 <dschoepe> ChristianS: I think there were some cases where I didn't want to do an eta reduction that hlint suggested, to keep it consistent with some other function, iirc.
02:37:14 <merijn> cheater: By defining a new instance of Ord?
02:37:16 <everythingWorks> merijn: kk
02:37:19 <cheater> k
02:37:31 <Cale> everythingWorks: Complex numbers don't have a standard ordering (or any ordering which is particularly compatible with the arithmetic operations in a nice way)
02:37:37 <cheater> could i use the new order with Int?
02:37:41 <donri> the redundant do warning from hlint can be annoying for some EDSLs
02:37:41 <Cale> everythingWorks: neither do matrices
02:38:05 <dschoepe> ChristianS: But I agree that the warnings make a lot of sense in most cases
02:38:05 <everythingWorks> Cale: What about double?
02:38:09 <donri> the use camelCase warning for test suites where you have prop_foo etc
02:38:11 <everythingWorks> I think they do have a clear ordering
02:38:11 <Cale> Double has an ordering
02:38:17 <Cale> Complex Double doesn't
02:38:29 <cheater> let's say i want even numbers to always be bigger than odd numbers, and otherwise follow normal inequality
02:38:30 <everythingWorks> Oh. I thought you meant "complex does not, double does not"
02:38:34 <Cale> Complex is a type constructor and it takes as a parameter the type of numbers to use for the components
02:38:46 <cheater> how would i code this so that i can have two ints and compare them with > and < ?
02:38:47 <tikhonjelvis> cheater: You would usually use newtype for something like that.
02:38:51 <cheater> ok
02:39:00 <tikhonjelvis> E.g. newtype WeirdNumber = WeirdNumber Integer
02:39:17 <cheater> and newtype creates what
02:39:17 <donri> also fun: hlint -h {Dollar,Generalise}
02:39:22 <cheater> an instance of Ord, yes?
02:39:31 <tikhonjelvis> Well, you would have to write the instance yourself for it.
02:39:32 <cheater> i mean i was told to use newtype and to make a new instance of Ord
02:39:36 <cheater> i am not sure how those connect
02:39:43 <merijn> cheater: No, a new datatype identical to the old, but without inheriting class instances
02:39:51 <Cale> cheater: it creates a genuinely new datatype, which you would then be free to write your own typeclass instances for
02:39:52 <merijn> That way you can define a new Ord instance for the newtype
02:40:08 <tikhonjelvis> teamwork :)
02:40:10 <cheater> ok those typeclass instances would be functions
02:40:12 <merijn> Otherwise you'd have to use OverlappingInstances, I think?
02:40:16 <cheater> one of those functions would be < yes?
02:40:20 <Cale> yes
02:40:21 <merijn> cheater: Yes
02:40:21 <daniel31415> Bon appetit - people from europe :)
02:40:26 <daniel31415> @botsnack
02:40:26 <lambdabot> :)
02:40:43 <cheater> so i'ld do newtype whatever where (<) = ...       right?
02:41:01 <tikhonjelvis> No
02:41:16 <tikhonjelvis> First, you'd create your new type: newtype WeirdInt = WeirdInt Int
02:41:26 <tikhonjelvis> Then you'd say instance Ord WeirdInt where ...
02:41:28 <merijn> "newtype WeirdNumber = Integer; instance Ord WeirdNumber where ..." (I may have botched the syntax here)
02:41:42 <cheater> ok
02:41:53 <cheater> now let's say i have in my code a 2 :: Int
02:41:57 <cheater> and a 3 :: Int
02:41:58 <merijn> Does a single constructor newtype need a constructor?
02:42:02 <cheater> and i want to use my new < for them
02:42:04 <cheater> how do i do that?
02:42:16 <luite> merijn: yes, and you an't make newtypes with multiple constructors
02:42:21 <luite> +c
02:42:22 <tikhonjelvis> cheater: You'd have to use them as 2 :: WeirdInt
02:42:24 <merijn> Ah
02:43:00 <tikhonjelvis> You'd also have to make it an instance of Num.
02:43:05 <cheater> tikhonjelvis: but i already have some other code spitting out Int
02:43:15 <tikhonjelvis> ah
02:43:27 <tikhonjelvis> Well, in that case, I don't think you can change the behavior of <
02:43:33 <cheater> tikhonjelvis: how?
02:43:39 <cheater> do i just overwrite it?
02:43:41 <tikhonjelvis> You can write your own version like |<|
02:43:50 <tikhonjelvis> I don't think you can
02:44:00 <cheater> well i can inside a let block, right
02:44:25 <merijn> You can hide the < function, but then any code using it would break
02:44:26 <mauke> cheater: in that case you could just use another name
02:44:50 <cheater> mauke: but what if a new name would not fit with the rest of my article
02:45:20 <cheater> merijn: k
02:45:27 <tikhonjelvis> Well, you should change either the type or the function if you want to change the behavior.
02:45:27 <cheater> but yeah, ok
02:45:42 <cheater> so if i then have a function which is Ord a => a -> ...
02:46:04 <cheater> if passed a WeirdNumber instead of Int, and if that code uses < on the a..
02:46:09 <cheater> it would use my new < then, right?
02:46:15 <tikhonjelvis> yes
02:46:20 <cheater> ah ok, i see the use now
02:46:22 <cheater> that's pretty cool
02:46:26 <tikhonjelvis> yes
02:46:45 <cheater> is it fair to say that a typeclass serves as an API?
02:46:53 <srhb> elliott, donri: Sorry, I was interrupted. The configuration does include several of the "same type" of value, if that's what looping constructs means. The template should be loaded externally, yes. It is rather big and xml'y.
02:46:56 <cheater> which the instances are implementations of?
02:47:04 <srhb> But only parts of it are xml, so pure xml handler won't work
02:47:04 <tikhonjelvis> yeah
02:47:07 <cheater> thanks
02:47:10 <cheater> that's very helpful
02:47:12 <tikhonjelvis> It can also have default implementations.
02:47:15 <cheater> ok
02:47:19 <cheater> that's pretty cool
02:47:32 <tikhonjelvis> So for Eq you can implement either == or /= or both.
02:47:45 <tikhonjelvis> If you only implement one, the other will just be its opposite.
02:47:45 <cheater> what if two typeclasses have the same function name "inside" them
02:47:47 <merijn> cheater: An important difference is that typeclasses can contain more than just functions
02:47:59 <merijn> Example, the minBound and maxBound values
02:48:05 <merijn> > minBound :: Word8
02:48:06 <lambdabot>   0
02:48:11 <merijn> > minBound :: Int
02:48:11 <cheater> yeah they can contain values
02:48:11 <lambdabot>   -9223372036854775808
02:48:13 <tikhonjelvis> More generally, they can changed not only based on arguments but based on return type.
02:48:14 <cheater> whatever values they are right
02:48:36 <tikhonjelvis> So you can have a function TypeClass a => Int -> a in a type class.
02:48:42 <merijn> cheater: Yes, although the mostly only make sense if the value depends on the type it instantiates :p
02:49:03 <merijn> For a perverse, but interesting, application of this you can look at the Real World Haskell chapter on regexes
02:49:04 <cheater> ok
02:49:06 <tikhonjelvis> So read always takes a String and gives you whatever is appropriate.
02:49:35 <cheater> gotcha
02:49:39 <cheater> let's say two typeclasses have "foo" defined
02:49:49 <cheater> they're typeclasses Quux and Zarr
02:50:02 <tikhonjelvis> That's just going to be the same as having two normal foo functions.
02:50:15 <cheater> can my type Fnord be an instance of Quux and Zarr?
02:50:18 <cheater> at the same time?
02:50:59 <mauke> cheater: yes
02:51:13 <cheater> what happens then if i call foo?
02:51:25 <Jafet> There are two foos; you have to use qualified names
02:51:28 <mauke> cheater: class methods aren't "contained" in the class
02:51:36 <mauke> cheater: they're global names
02:51:47 <mauke> so you'd have to define them in two different modules
02:52:00 <cheater> what if i try to define them in the same module?
02:52:01 <merijn> Quux.foo and Zarr.foo, otherwise name collision, I think?
02:52:13 <merijn> cheater: Name collision
02:52:14 <Jafet> GHC beats you with a burrito
02:52:26 <mauke> cheater: what happens if you do 'foo = "hello"; foo x = 2 * x' in the same module?
02:53:11 <Jafet> .oO( instance IsString (Integer -> Integer) )
02:53:14 <cheater> let's say i did instance Quux Fnord where foo = ... and right under that i did instance Zarr Fnord where foo = ...
02:53:24 <cheater> i get a name collision from the second one?
02:53:32 <Jafet> Actually it wouldn't work anyway.
02:53:35 <mauke> hmm, good question actually
02:53:40 <mauke> cheater: try it!
02:53:56 <cheater> i have to split in a sec
02:54:02 <cheater> and i won't have those notes in the office
02:54:08 <cheater> but when i come in i'll get back to it
02:54:15 <cheater> it's fairly interesting
02:54:43 <Jafet> I expect you have to qualify foo anyway
02:55:16 <Jafet> So this question... begs the question
02:55:34 <cheater> ok
02:55:35 <cheater> i'm off
02:55:36 <cheater> ttyl
02:56:49 <merijn> Ok, I was reading this part on lenses (http://www.scs.stanford.edu/11au-cs240h/notes/zipper.html) and I seem to have missed a crucial step
02:57:07 <merijn> Everything makes sense up to the point where they mention that lenses can be composed
02:57:28 <donri> merijn: Control.Category
02:57:58 <dibblego> merijn: instance Category Lens
02:58:17 <merijn> The example right above it already shows the ability to compose "(ptX . lnEnd) l", so what did we gain by making Lens an instance of Category?
02:58:34 <donri> merijn: you can compose the setter too
02:58:50 <merijn> Ah, so you can compose the setter without the Category instance?
02:59:15 <merijn> s/can/can't
03:01:59 <donri> merijn: with lenses, you can't compose either without Category because Prelude.(.) is only for functions
03:02:15 <donri> merijn: without lenses, you can compose record getters because they are functions
03:02:28 <donri> merijn: but without lenses, you have to use the cumbersome record update syntax for setting
03:02:54 <merijn> Oh wait, one of the values in that example is just the accessor, not the lens >.>
03:02:59 <donri> foo { bar = baz { x = y } } vs (x . bar) = y $ foo
03:03:41 <donri> uh s/=/^=/
03:04:33 <Leif_Bork> elliott: Thank you
03:05:24 <donri> actually it's even worse: foo { bar = bar foo { x = y } }
03:11:11 <edsko> any suggestions on how to work around "ghc: panic! (the 'impossible' happened)
03:11:11 <edsko>   (GHC version 7.4.0.20120119 for x86_64-apple-darwin):
03:11:11 <edsko> 	divide by zero"
03:11:17 <edsko> when building cabal-install with ghc 7.4 on Mac OSX?
03:11:42 <elliott> sounds like a bug
03:12:04 <edsko> sure does :)
03:16:39 <Jafet> You could use GHC 7.2...
03:17:18 <Jafet> I'd be suspicious of using that GHC for anything else anyway
03:17:40 <edsko> Yes, I could, but I want 7.4 :)
03:18:19 <edsko> Want to play with the new version of threadscope
03:18:22 <edsko> which requires 7.4
03:25:08 <edsko> @Jafet. Hmmmmmmmm. I think you may be right :-)
03:25:08 <lambdabot> Unknown command, try @list
03:25:35 <edsko> Jafet: Hmmmmmmm. I think you may be right.
03:25:36 <edsko> Prelude> 1.05
03:25:36 <edsko> *** Exception: divide by zero
03:25:36 <edsko> Prelude> 1.04
03:25:41 <edsko> (hangs completely)
03:26:15 <elliott> 1.04 is a very complicated number.
03:26:25 <edsko> :-D
03:26:28 <elliott> After all, it's (n/0) - 0.01 (for some unknown n).
03:26:42 <edsko> lol
03:41:56 * hackagebot CabalSearch 0.0.2 - Search cabal packages by name  http://hackage.haskell.org/package/CabalSearch-0.0.2 (JohanBrinch)
04:08:56 <Palmik> dreixel, hi I'm here again with another question. I have this code http://hpaste.org/57001 where I would like to know the constructor name of certain type, but "(conName (undefined :: M1 C c a r))" seems to cause problems.
04:11:11 <EvilMachine> hello everybody :)
04:11:45 <EvilMachine> this drives me crazy: apparently the utf8-string library doesn’t offer the ord- and chr-like functions for utf8?
04:12:08 <EvilMachine> Like: Int64 -> [Word8]
04:12:20 <EvilMachine> Or: Int64 -> ByteString
04:12:25 <EvilMachine> that would be ok too
04:12:32 <Jafet> Data.Text.Encoding
04:12:38 <EvilMachine> ah.
04:12:40 <EvilMachine> lol
04:12:47 <EvilMachine> thanks Jafet. didn’t think of that!
04:12:49 <Jafet> I wrote it once too, it's a one-liner
04:12:50 <EvilMachine> :D
04:13:10 <EvilMachine> Jafet: yes, i just looked at http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/src/Codec-Binary-UTF8-String.html#encode
04:13:41 <EvilMachine> Of course re-inventing the wheel feels dirty for a reason. ;)
04:15:09 <tdammers> Jafet: it feels like most things are one-liners in haskell...
04:15:26 <Jafet> If you turn off word-wrap.
04:15:28 <merijn> Well, they are
04:15:46 <dreixel> Palmik: try something like replacing your if statement with a "let r = if ... in r"
04:15:53 <EvilMachine> tdammers: still has nothing on Piet, where code is *literally* made out of colorful lines. :P
04:15:54 <dreixel> and then use `conName r`
04:15:57 <merijn> We just make them multi liners by defining functions rather than defining everything with lambda's and lets :p
04:16:25 <Jafet> If (schwartzianTransform sortBy compare length) should be equivalent to (sortBy (compare `on` length)), and (schwartzianTransform maximumBy compare length) should be equivalent to (maximumBy (compare `on` length)), how can I implement schwartzianTransform?
04:16:57 <Jafet> I'm up to schwartzianTransform g p f xs = <something> snd . g (p `on` fst) . map (\x -> (f x, x)) $ xs
04:17:15 <Jafet> The problem is, <something> is map for sortBy and id for maximumBy
04:17:21 <EvilMachine> merijn: or pointfree/-less style ;)
04:18:29 <Palmik> dreixel, still the same error with "let r = (if (cname == (conName (undefined :: M1 C c a r))) then maybe Nothing (Just . M1) (genericFromBSON doc) else Nothing) in r"
04:18:51 <dreixel> Palmik: you should replace the undefined by r
04:20:18 <Palmik> Ahh, the error changed, let me see if I can get it right now. :)
04:21:40 <Palmik> dreixel, hmm, 'r' is Maybe in that context and thus "Couldn't match type `Maybe' with `M1 C c1 a1'"
04:21:56 * hackagebot hinduce-missingh 0.0.0.0 - Utility functions  http://hackage.haskell.org/package/hinduce-missingh-0.0.0.0 (RobertHensing)
04:22:01 <dreixel> Palmik: oh, yes
04:22:33 <dreixel> anyway, this is not the best way to do it because it gives the impression that you're relying on laziness
04:22:35 <Palmik> I honestly can not wrap my head around the "let r = ... in r" :)
04:22:49 <dreixel> but you aren't. You just want to get the type of the result, and use that as an argument to conName
04:23:04 <dreixel> conName takes a value argument but it doesn't look at it. All that matters is its type
04:23:23 <merijn> Palmik: Why not?
04:23:27 <Palmik> yep, that's why I tried to use undefined with the type.
04:23:46 <merijn> oh, wait. I missed something I see :p
04:23:55 <dreixel> yes, that was good, but it's not easy to write the type because in `M1 C c a r` you don't know what the `r` is
04:25:32 <dreixel> Palmik: undefined `asTypeOf` (M1 (genericFromBSON doc)) should work too
04:27:34 <exFalso> good day, is there a way to manually instantiate the Typeable1 class?
04:28:02 <everythingWorks> How may i do this: "(length list) / 2"
04:28:23 <exFalso> `div`
04:28:25 <rostayob> everythingWorks: either using 'div' if you want an integer, of with fromIntegral
04:28:34 <int-e> `div` or fromIntegral (length list) / 2
04:28:43 <everythingWorks> div works :D
04:28:59 <rostayob> exFalso: exFalso you can't
04:29:04 <everythingWorks> fromIntegral works too, thanks :D
04:29:19 <rostayob> exFalso: iirc
04:29:31 <exFalso> the auto-deriving complains that the type arguments must have kind *
04:30:03 <rostayob> exFalso: well, there you go
04:30:04 <merijn> everythingWorks: The difference is that div is Integer division, while fromIntegral converts an Integer into another Numeric value
04:30:13 <rostayob> exFalso: section 7.5.3 of the ghc manual
04:30:23 <rostayob> "n instance of Typeable can only be derived if the data type has seven or fewer type parameters, all of kind *. The reason for this is that the Typeable class is derived using the scheme described in Scrap More Boilerplate: Reflection, Zips, and Generalised Casts . (Section 7.4 of the paper describes the multiple Typeable classes that are used, and only Typeable1 up to Typeable7 are provided in the
04:30:24 <int-e> exFalso: that suggests that you can't provide a manual instance either, because type classes require their inhabitants to have some specific kind.
04:30:25 <rostayob> library.) In other cases, there is nothing to stop the programmer writing a TypableX class, whose kind suits that of the data type constructor, and then writing the data type instance by hand."
04:30:34 <everythingWorks> merijin: That's what i really needed, thanks :D
04:31:06 <merijn> everythingWorks: So div will return an integer while fromIntegral converts "length list" into another numeric which can be divided and return a float, rational or something else, depending on the context
04:31:27 <cheater_> are newtypes and types the same thing?
04:31:50 <rostayob> int-e: ? the problem is not a mismatching kind, the problem is that you can only derive instances for *
04:31:57 <int-e> > genericLength [1..5] / 2 -- another option. genericLength works for any inhabitant of the Num class.
04:31:58 <lambdabot>   2.5
04:32:06 <merijn> cheater_: Type is a synonym, newtype is an actual newtype that is implemented the same as the old type, afaik
04:32:14 <exFalso> but as i understand that suggests that we could instantiate it manually
04:32:32 <rostayob> exFalso: yes, you can
04:32:40 <merijn> cheater_: i.e. "type String = [Char]" lets String and [Char] be used interchangably, while the same does not hold for "newtype String = String [Char]"
04:33:29 <rostayob> exFalso: oh wait...
04:34:14 <cheater_> can i create a newtype which does not have any arguments?
04:34:31 <cheater_> can i do newtype Ztring = Ztring ?
04:34:44 <rostayob> cheater_: did you try?
04:34:54 <cheater_>     The constructor of a newtype must have exactly one field
04:34:54 <cheater_>       but `Ztring' has none
04:34:58 <cheater_> i have
04:35:00 <rostayob> cheater_: looks like you can't!
04:35:05 <everythingWorks> How can i request console input, e.g. a number
04:35:10 <exFalso> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html#g:4
04:35:17 <everythingWorks> like: "How old are you: " < enter number here
04:35:19 <exFalso> i'll try to use those :)
04:35:21 <cheater_> how can i create a type which does not have arguments?
04:35:30 <rostayob> cheater_: data Foo = Foo
04:35:34 <arcatan> hey, was it so that with GHC 7.4 we're going to get the ability to declare new types in GHCi?
04:35:47 <rostayob> arcatan: yes
04:35:54 <exFalso> you can also just say data Foo
04:35:57 <rostayob> everythingWorks: readLine and read
04:35:57 <cheater_> everythingWorks: maybe check out my tutorials, cheater.posterous.com    they contain a lot of the basic stuff regarding input and output
04:36:03 <exFalso> but you wont be able to construct it then
04:36:04 <merijn> everythingWorks: "getLine" reads a String from stdin, you can use read to turn the data into some other value (read blindly assumes you enter the proper input, though)
04:36:04 <rostayob> exFalso: that's a data declaration with no constructors
04:36:23 <everythingWorks> kk, thanks
04:36:46 <ppseafield> cheater_: IIRC Newtypes compile to the type or tuple of types in the declaration, but the compiler still counts them as a separate type for the purposes of type checking
04:36:56 * hackagebot layout 0.0.0.0 - Turn values into pretty text or markup  http://hackage.haskell.org/package/layout-0.0.0.0 (RobertHensing)
04:37:13 <rostayob> ppseafield: that's correct yes. newtypes are isomorphic to their contained type
04:37:16 <Palmik> dreixel, hmm, I still get the same error.
04:37:22 <cheater_> ppseafield: what i have just read said the opposite
04:37:25 <rostayob> so the compiler can just treat them as their inner type
04:37:41 <int-e> rostayob: are you using standalong deriving? I just saw that data Foo1 a = Foo1 a deriving Typeable works, but you have to write (the more logical) deriving instance Typeable1 Foo1  when using standalone deriving.
04:37:41 <rostayob> but they define a... new type
04:37:46 <cheater_> ppseafield: the wiki page says the data types, even if constructed as if isomorphic, are not, whereas newtypes can be interchanged, and typematching happens without any overhead
04:37:59 <Palmik> dreixel, but it's weird, I'm using this for inspiration https://github.com/ozataman/snap-extension-mongodb/blob/master/src/Snap/Extension/DB/MongoDB/Generics.hs it basically does the same but with Generics.Regular and the trick with undefined works there.
04:38:01 <rostayob> int-e: deriving Typeable works, deriving Typeable1 doesn't
04:38:07 <cheater_> ppseafield: the wiki page for newtype that is http://www.haskell.org/haskellwiki/Newtype
04:38:38 <int-e> rostayob: yes, but for standalone deriving it's the other way around.
04:39:11 <rostayob> int-e: ah
04:39:13 <int-e> rostayob: (using ghc 7.2.1)
04:39:47 <rostayob> int-e: I'm using 7.0.4 and the manual is pretty clear in saying that Typeable1 cannot be derived
04:40:09 <rostayob> int-e: I think that what it does is deriving a instance Typeable a => Typeable (Foo a) where ...
04:40:47 <int-e> rostayob: hmm. but data Foo1 a = Foo1 a deriving Typeable  derives a Typeable1 instance in 7.2.1 ... and in 7.0.3 as well
04:41:41 <int-e> and has the same difference between standalone and "immediate" (is there a better word for this?) deriving
04:41:56 * hackagebot layout 0.0.0.1 - Turn values into pretty text or markup  http://hackage.haskell.org/package/layout-0.0.0.1 (RobertHensing)
04:42:30 <rostayob> int-e: uh, you're right
04:42:37 <wyfrn> is there a way to map over a record under certain conditions ... e.g. when all elements belong to the same typeclass
04:42:40 <dreixel> Palmik: it should work. Can you show me your code and the error?
04:42:47 <merijn> everythingWorks: A simple example program: "main = do { age <- getLine; print $ "Next year you will be: " ++ (show . (+1) . read) age}"
04:42:48 <rostayob> int-e: yeah sorry, misunderstanding on my part...
04:42:59 <rostayob> exFalso: I'm stupid, GHC will automatically derive up to Typeable7
04:43:38 <exFalso> well as long at the type arguments are *
04:43:52 <exFalso> in my case i'm trying to derive typeable for a transformer
04:44:16 <Palmik> dreixel, sure http://hpaste.org/57003
04:44:18 <rostayob> exFalso: correct, but that has nothing to do with the deriving thing
04:44:33 <dreixel> Palmik: actually...
04:44:47 <rostayob> it's simply that kinds in haskell are not polymorphic
04:45:05 <dreixel> Palmik: it's much easier than that. It should work with your original code, just add ScopedTypeVariables to the extension list.
04:45:24 <rostayob> exFalso: so the 't' in 'class Typeable1 t' gets the kind '* -> *'
04:45:51 <ppseafield> cheater_: http://stackoverflow.com/questions/6970662/multi-parameter-newtype-faked-with-a-tuple
04:46:05 <exFalso> yes
04:46:15 <Palmik> dreixel, you are right. It compiles now, thanks.
04:46:19 <exFalso> i managed to do it, not sure it's correct though
04:46:44 <mm_freak> wyfrn: nope
04:46:47 <exFalso> http://hpaste.org/57004
04:47:01 <ppseafield> cheater_: Aha. This is the thing I was actually looking for! http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell
04:47:43 <mm_freak> wyfrn: of course if all components are of the same type and that type is a parameter, you can make your record type a functor instance
04:47:47 <rostayob> exFalso: you can't instantiate Typeable manually
04:47:58 <rostayob> I mean I guess you can but it's dangerous
04:48:12 <rostayob> exFalso: did you check a sample output? the names must be qualified
04:48:21 <rostayob> exFalso: you can see deriving instances with -ddump-deriv
04:48:37 <exFalso> the names will be qualified
04:48:52 <exFalso> i didnt specify the package name for now thats it
04:48:56 <rostayob> exFalso: well ok then :P
04:49:15 <exFalso> fingers crossed, safe casting here we come :D
04:49:20 <exFalso> thanks fot hte help!
04:49:50 <rostayob> exFalso: you're a haskell terrorist anyways
04:49:52 <rostayob> :)
04:50:00 <exFalso> haha
04:50:08 <exFalso> this package will be awesome
04:50:26 <rostayob> exFalso: is it the arbitrary dimensional proximity thing?
04:50:43 <exFalso> rostayob: no, it's the shell-generator thing
04:50:53 <rostayob> exFalso: what's a shell generator?
04:51:13 <exFalso> rostayob: basically you can just give it haskell functions and it will generate a shell where you can use them
04:51:28 <exFalso> figures out the types, completion and all
04:51:50 <rostayob> that's interesting
04:51:56 * hackagebot hinduce-classifier 0.0.0.0 - Interface and utilities for classifiers  http://hackage.haskell.org/package/hinduce-classifier-0.0.0.0 (RobertHensing)
04:51:58 * hackagebot pointless-haskell 0.0.8 - Pointless Haskell library  http://hackage.haskell.org/package/pointless-haskell-0.0.8 (HugoPacheco)
04:54:18 <byorgey> exFalso: sounds neat!
04:54:26 <everythingWorks> where actually here is the problem? http://ideone.com/g1CR7
04:55:22 <everythingWorks> ugh, i think the eclipse interpreter was stuck for a while and wasnt re-interpreting the code. I think it works kinda well
04:56:57 * hackagebot pointless-lenses 0.0.9 - Pointless Lenses library  http://hackage.haskell.org/package/pointless-lenses-0.0.9 (HugoPacheco)
04:56:59 * hackagebot pointless-rewrite 0.0.3 - Pointless Rewrite library  http://hackage.haskell.org/package/pointless-rewrite-0.0.3 (HugoPacheco)
04:57:01 * hackagebot multifocal 0.0.1 - Bidirectional Two-level Transformation of XML Schemas  http://hackage.haskell.org/package/multifocal-0.0.1 (HugoPacheco)
04:57:26 <frerich2> everythingWorks : putStrLn . show == print
04:57:53 <everythingWorks> frerich2: thanks for the hint
04:57:54 <byorgey> everythingWorks: also, you can use 'readLn' which combines getLine and read
04:58:14 <byorgey> not sure why it's  "getLine" but "readLn"
04:59:32 <merijn> everythingWorks: You can simplify to this http://ideone.com/EmKL1 but other than that that code should work fine, maybe it's Eclipse acting up?
05:00:32 <merijn> Or, probably even better: http://ideone.com/JfkL7
05:00:53 <frerich2> merijn: Or just 'readLn >>= print . (*2)'
05:00:57 <everythingWorks> i assume $ means "see the whole rest as 1 argument"
05:01:01 <everythingWorks> is this correct?
05:01:05 <merijn> everythingWorks: Pretty much
05:01:10 <merijn> @src ($)
05:01:10 <lambdabot> f $ x = f x
05:01:19 <everythingWorks> @src(.)
05:01:19 <lambdabot> Unknown command, try @list
05:01:31 <everythingWorks> what means this point often seen between functions, by the way? :D
05:01:47 <Saizan> @src (.)
05:01:47 <lambdabot> (f . g) x = f (g x)
05:01:47 <lambdabot> NB: In lambdabot,  (.) = fmap
05:02:15 <merijn> everythingWorks: Function application binds stronger than operators, which can be annoying. ($) is the same as applying a function, but since it has the lowest priority avoids binding so closely
05:02:55 <merijn> In other words "print integerInput * 2" is parsed as "(print integerInput) * 2", whereas "print $ integerInput * 2" turns into "print (integerInput * 2)"
05:03:19 <everythingWorks> yep, i understand/ood. :D
05:03:22 <merijn> (.) has the type "(b -> c) -> (a -> b) -> (a -> c)
05:03:54 <merijn> It just combines two functions into a single function
05:04:25 <cheater_> ok so i've figured out this typeclass instance thing
05:04:27 <cheater_> thanks to u guys
05:04:35 <cheater_> thanks a lot Cale / mauke / merijn
05:04:39 <everythingWorks> merijn: okay, thanks
05:06:14 <merijn> everythingWorks: In my earlier example "(show . (+1) . read) age" is the same as doing "show (1 + (read age))", but haskell people hate parentheses :p
05:06:37 <ChristianS> otherwise, they would be programming lisp
05:06:52 <everythingWorks> heh, nice one :P
05:06:57 * hackagebot hinduce-classifier-decisiontree 0.0.0.0 - Decision Tree Classifiers for hInduce  http://hackage.haskell.org/package/hinduce-classifier-decisiontree-0.0.0.0 (RobertHensing)
05:06:58 <merijn> everythingWorks: The trick is to read the functions in the dots from right to left, "first read, then (+1), then show"
05:07:40 <merijn> Aside from the dots I would argue the code using (.) is much nicer to read in my example
05:07:45 <merijn> eh
05:07:59 <merijn> Aside from the parentheses. Today is a bad day for my typing skills :(
05:08:41 <ChristianS> merijn: though technically, there aren't less parenthesis in "(show . (+1) . read) age" than in "show (1 + (read age))"
05:09:10 <merijn> ChristianS: No, but you could use $, which I didn't in my original example because that didn't work in the context
05:09:29 <merijn> And I figured it'd be more logical to keep my example consistent
05:09:56 <ChristianS> merijn: right, and i agree it's generally nicer using . (and $ where appropriate)
05:12:02 <everythingWorks> merijn: I, personally like the snd version more. Most likely, because i think its clearly understandable, because im coming from an imperative world. I like the dot approach too and will use it if its common, thus :D
05:12:20 <everythingWorks> http://ideone.com/AmJ3G :D
05:12:51 <donri> @hpaste
05:12:51 <lambdabot> Haskell pastebin: http://hpaste.org/
05:13:18 <merijn> everythingWorks: Well, the dot lets you do things like "incrementAge = show . (+1) . read" (note: no argument)
05:13:32 <merijn> It is also convenient when using map to do something to a list
05:13:53 <everythingWorks> merijn: Ah, yeah, i know this map thing! :D
05:13:59 <merijn> "map (show . (+1) . read)"
05:14:24 <merijn> Without the dot you would have to write "map (\x -> show (1 + (read x)))"
05:16:59 * hackagebot hinduce-examples 0.0.0.0 - Example data for hInduce  http://hackage.haskell.org/package/hinduce-examples-0.0.0.0 (RobertHensing)
05:21:31 <tdammers> point-free is especially nice if you combine it with partial application
05:21:44 <tdammers> i.e., you can define functions in terms of other partially applied functions
05:22:30 <tdammers> something like:
05:22:30 <tdammers> f :: a -> b -> c
05:22:30 <tdammers> f a = f1 a . f2 . f3
05:26:26 <frerich2> tdammers: 'f a = f1 a . f2 . f3' is not point free - notice how 'a' is mentioned on the right hand side.
05:26:43 <tdammers> b isn't though
05:26:56 <tdammers> note f's type
05:27:19 <frerich2> tdammer: Maybe this would be a good moment to say that 'f' is point *less* but not point *free* ;-)
05:27:33 <tdammers> point taken (pun intended)
05:27:35 <Jafet> tdammers should concede the point.
05:27:44 <tdammers> that would be pointless
05:28:12 <dmwit> Jafet gets my vote for best use of that pun in that particular 10-second interval.
05:28:29 <danr> @pl \a -> f1 a . f2 . f3
05:28:29 <lambdabot> (. (f2 . f3)) . f1
05:28:40 <tdammers> ^ yeah.
05:30:43 <hpaste> wyfrn pasted “Irrefutable Pattern” at http://hpaste.org/57005
05:30:48 <wyfrn> would anybody please take a look at my code ... i don't know waths wrong with the <compute> function ... i got an irrefutable pattern issue
05:31:19 <dmwit> Well, you're only using one irrefutable pattern. So I'd look there if I were you.
05:32:26 <danr> wyfrn: your list ss is probably shorter than two elements
05:32:35 <dmwit> or longer
05:32:41 <danr> or longer!
05:34:26 <wyfrn> dooesn't then _ mean that there can be any number of items?
05:35:08 <dmwit> No.
05:35:21 <frerich2> wyfrn: No, it means that there's exactly one element - but you don't care about it.
05:36:51 <wyfrn> oh ... how can i express such a pattern? ((_:):s:[])?
05:37:08 <wyfrn> ((_:_):s:[])?
05:37:20 <merijn> That is a list of lists
05:37:26 <frerich2> wyfrn: You want to get the last item in a list using pattern matching?
05:37:31 <merijn> @hoogle [a] -> Integer -> [a]
05:37:31 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
05:37:31 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
05:37:31 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
05:37:36 <dmwit> You can use the "last" function.
05:37:39 <wyfrn> frerich2: yes
05:37:42 <dmwit> But it's a bit silly, isn't it?
05:37:43 <merijn> hmm, not what I was looking for
05:37:57 <nicoo> wyfrn: _ denotes that there can be any value here; (almost) nothing to do with lists
05:37:58 <dmwit> Since that function puts "head y" as the last element every time.
05:38:43 <dmwit> So why not just skip the (\(x, y) -> x ++ [head y]) nonsense and just match the tuple instead?
05:38:49 <everythingWorks> How can i sum up tuples?
05:39:00 <dmwit> > (3,4) + (5,6)
05:39:01 <lambdabot>   (8,10)
05:39:08 <everythingWorks> like: (sum (1,2,3))
05:39:09 <dmwit> ;-)
05:39:15 <dmwit> > sum [1,2,3]
05:39:16 <lambdabot>   6
05:39:17 <everythingWorks> dmwit: almost, meant sth different :/
05:39:22 <everythingWorks> dmwit: thats a list..
05:39:32 <tromp> > curry (+) (2,3)
05:39:33 <lambdabot>   Overlapping instances for GHC.Show.Show
05:39:33 <lambdabot>                              (b -> ...
05:39:41 <tromp> > uncurry (+) (2,3)
05:39:41 <lambdabot>   5
05:39:43 <dmwit> > let f (x,y,z) = x + y + z in f (1,2,3)
05:39:43 <lambdabot>   6
05:39:56 <everythingWorks> :] thanks
05:40:32 <frerich2> @hoogle (a -> b -> c -> d) -> (a, b, c) -> d
05:40:32 <lambdabot> No results found
05:40:48 <dmwit> ?hackage tuples
05:40:48 <lambdabot> http://hackage.haskell.org/package/tuples
05:40:51 <frerich2> Hm, I suspected there's uncurry3 or so
05:40:57 <wyfrn> dmwit: yes thats a much better idea
05:41:08 <dmwit> There is such a function in there.
05:41:41 <everythingWorks> What's the recommended documentation for functions? Is it http://zvon.org/other/haskell/Outputprelude/uncurry_f.html ?
05:41:53 <statusfailed> Parsec question: how should I structure "match anything until p" where p is some arbitrary parser?
05:41:55 <everythingWorks> Still, i can't get out much of this "documentation" :/
05:41:57 <donri> @hackage base
05:41:57 <lambdabot> http://hackage.haskell.org/package/base
05:42:05 <donri> everythingWorks: ^
05:42:26 <quicksilver> I generally use : http://www.haskell.org/ghc/docs/latest/html/libraries/
05:42:27 <merijn> You can also use Hoogle to find the docs for specific functions
05:42:37 <donri> everythingWorks: also http://lambda.haskell.org/platform/doc/current/start.html
05:42:41 <quicksilver> which is not just base, but everythign that comes with GHC
05:43:07 <donri> everythingWorks: what OS are you using?
05:43:27 <everythingWorks> windows.
05:43:32 <everythingWorks> What does it mean "curried function"
05:43:52 <everythingWorks> I think the documentation is kindly poor on this, isnt it?
05:43:56 <quicksilver> a curried function is one that looks like a -> b -> c -> d -> e
05:44:05 <tromp> function accepting one argument and returning a function of remaining args
05:44:05 <quicksilver> rather than (a,b,c,d) -> e
05:44:25 <quicksilver> the documentation does not attempt to explain general functional programming terminology
05:44:42 <quicksilver> good tutorials/books should cover that
05:44:52 <everythingWorks> yep, thanks
05:45:01 <merijn> Speaking of which, what are you reading right now?
05:47:02 * hackagebot socks 0.2.0 - Socks proxy (version 5) implementation.  http://hackage.haskell.org/package/socks-0.2.0 (VincentHanquez)
05:51:15 <everythingWorks> merijn: http://learnyouahaskell.com/starting-out
05:52:05 <merijn> everythingWorks: That should cover currying/uncurrying at some point, IIRC
05:54:12 <statusfailed> Okay, how do I write a parsec rule to match "<literallyAnythingHere>;" without specifying that <literallyAnythingHere> doesn't contain a ; ?
05:55:05 <statusfailed> or can I not do that :\
05:56:30 <statusfailed> oh, I think I want "notFollowedBy"
06:00:06 <statusfailed> oh, not quite :\
06:00:17 <tdammers> currying is actually a really simple concept, it's just hard to see through the syntax cruft most programming languages require
06:14:29 <Botje> statusfailed: noneOf ";", maybe?
06:14:52 <Botje> statusfailed: although your parser should match something more specific than that.
06:21:57 <davv3> hey, im trying to write a recursive function that spawns a binary tree i.e calls itself twice with different arguments. in C i would simply put the calls between {} what is the haskell way of doing this?
06:22:36 <shachaf> Calls itself and does what with the return values?
06:22:57 <byorgey> davv3: if both recursive calls generate binary trees, then you need to take those two binary trees and put them together into one binary tree to return
06:23:46 <byorgey> e.g.  if your tree type is  data Tree a = Empty | Node a (Tree a) (Tree a)   then you could do something like  foo x = Node (x*2) (foo (x+1)) (foo (x+2))
06:24:00 <byorgey> davv3: also, even in C you would need to do this.
06:24:19 <byorgey> unless the C function was just *printing out* some stuff, in which case simply sequencing the two calls would be enough.
06:24:20 <shachaf> byorgey: I think davv3 just means that the function call structure forms a binary tree.
06:24:34 <byorgey> shachaf: oh, that could be.
06:24:39 <Botje> davv3: can you give a more concrete explanation of what you're trying to do?
06:25:02 <davv3> i can write the concept code in C if it helps.
06:25:03 <Arnar> anyone know the "libncurses.so: file too short" error when loading readline-1.0.1.0?
06:25:11 <davv3> it is really simple.
06:25:13 <shachaf> I think Botje is correct that instead of guessing, we should ask what davv3 what they're trying to do.
06:25:27 <merijn> davv3: A short C example would help, yes.
06:25:51 <davv3> give me a few minutes, have to reboot also. thank you
06:27:01 <statusfailed> Botje: I wanted to allow any parser without having to make it specify that
06:27:18 <byorgey> shachaf: I agree. I thought I *did* understand, but now I see that I probably didn't.
06:27:34 <statusfailed> is there a way to parse the output of ' noneOf ";" ' ?
06:27:50 <statusfailed> or is that a really bad idea
06:28:07 <statusfailed> yeah, could I just parse the string output? :D
06:29:39 <Botje> statusfailed: ideally you supply parsers that cannot match ; to begin with ..
06:31:42 <rwbarton> if this is for a C-like language, consider that you may have e.g. string literals containing embedded ;s
06:34:09 <Botje> sure, but they're the "stringparser"'s problem
06:35:47 <statusfailed> Botje: oh, I think he meant that even if I could force the arbitrary parser not to match a ;, then it would be invalid in some cases
06:35:54 <statusfailed> either way: A Bad Idea
06:43:43 <Baughn> What would be the best way to coerce a Data.ByteString.Char8 to a Data.ByteString?
06:44:04 <quicksilver> there is no need to coerce anything Baughn
06:44:07 <quicksilver> they are the same type.
06:44:26 <quicksilver> if they appear to be different types you probably have a strict/lazy conflict, not a Char8/Word8 conflict.
06:44:35 <Baughn> ..yes, that's exactly it. >_>
06:45:25 <luite> hehe that confused me at first too, annoying reexported types :p
06:46:25 <davv3> http://hastebin.com/gafequtehi.pl
06:46:45 <Saizan> i think it would've been better to have strict/lazy with different names
06:47:32 <Eduard_Munteanu> Saizan: you'd need different names for functions as well, though
06:47:56 <luite> or a type class
06:47:57 <davv3> would spawn a binary tree from the arguments returning 1 until reaching 0,0
06:48:26 <Eduard_Munteanu> Yeah, though stuff like folds can't go into e.g. a Foldable instance.
06:48:27 <Saizan> Eduard_Munteanu: you'd need that to import unqualified, but i don't see a problem with importing qualified
06:49:00 <Saizan> Eduard_Munteanu: different names for types would provide less confusion and better type errors by themselves
06:49:26 <hpaste> merijn pasted “Recursion” at http://hpaste.org/57007
06:49:39 <merijn> davv3: As far as I can tell it boils down to that paste?
06:49:47 <Eduard_Munteanu> Hm, yeah, that makes sense.
06:50:33 <cpennington> Has anyone used data.derive with a mix of automatic and manual intance derivations, in a side-by-side module?
06:50:34 <davv3> merijn: yes
06:50:59 <davv3> it is the gist of what i am trying to implement in haskell
06:51:02 <quicksilver> davv3: http://hastebin.com/lubiyugede.pl
06:51:05 <cpennington> I'm running into an issue where 'derive' can't find the types in the adjacent 'Types' module
06:51:11 <quicksilver> davv3: is a more of less direct translation of what you wrote
06:51:12 <merijn> davv3: That is a working implementation in Haskell :p
06:51:19 <quicksilver> but I removed the mutable variable 'v'
06:51:26 <quicksilver> because it wasn't terribly useful
06:51:33 <Saizan> cpennington: did you import it ?
06:51:41 * quicksilver compares it to merijn's solution
06:51:59 <merijn> oh, doh
06:52:01 <quicksilver> no, I think merijn misread your code
06:52:04 <merijn> I failed the x > 0 check
06:52:12 <merijn> Imagine I put some guards there :p
06:52:21 <quicksilver> well you need to add the two together
06:52:28 <quicksilver> because if they're both >0 they both get added
06:52:51 <quicksilver> davv3: my answer make sense?
06:53:18 <cpennington> Saizan: yes
06:53:25 <danr> if P and Q are chain complete / admissible predicates, subsets of a CPO, is then P -> Q admissible?
06:53:29 <merijn> hastebin is terribly slow here, btw
06:53:49 <quicksilver> merijn: ironic :)
06:53:51 <luite> hastebin still hasn't loaded here
06:54:00 <luite> oh it just did
06:54:12 <hpaste> quicksilver pasted “answer to davv3” at http://hpaste.org/57008
06:54:26 <quicksilver> ^^ for the hastebin-impaired
06:54:35 <davv3> quicksilver: yeah hastebin is killing me >(
06:54:43 <rwbarton> you don't even need the outer if/then/else
06:54:48 <merijn> davv3: hpaste.org is much nicer :)
06:54:58 <quicksilver> rwbarton: you mean pattern matching would be more idiomatic?
06:55:09 <quicksilver> if so then, of course, my objective was to translate directly.
06:55:17 <rwbarton> No, I mean the 'then' and 'else' branches will compute the same value :)
06:55:33 <rwbarton> But yes, that is a good direct translation
06:55:38 <quicksilver> oh yes good point.
06:55:40 <magicman> recurse _ _ = 0 >_> <_<
06:55:43 <davv3> quicksilver: mind pasting it @ hpaste.org?
06:55:46 <quicksilver> I did.
06:55:51 <quicksilver> davv3: http://hpaste.org/57008
06:55:58 <rwbarton> magicman: heh, fair enough!
06:56:21 <magicman> (but yeah, not very educational in this case :p)
06:57:18 <merijn> I feel this should be doable without the ugly if/then/else, but I don't quite see how yet
06:57:41 <cpennington> Saizen: {-# OPTIONS_DERIVE --append --import Dibels.Types #-}
06:57:53 <quicksilver> well rwbarton correctly observed that the outer if is not needed
06:58:00 <quicksilver> even if it was, it would be more natural as a pattern match
06:58:05 <quicksilver> I don't find the two inner ifs ugly at all
06:58:18 <quicksilver> in fact I think that's a pretty good example of when I would choose to use if.
06:58:19 <davv3> quicksilver: definetly makes sense :) .. fmap is function map?
06:58:27 <quicksilver> davv3: functor map
06:58:29 <cpennington> Saizen: and yet, when I run derive, I get the error "Can't find data type definition for GradeLevel" (where GradeLevel is defined in Dibels.Types)
06:58:42 <quicksilver> davv3: it's because getArgs returns IO [String] not [String]
06:59:07 <quicksilver> that version will crash with an exception if you give it anything other than two integers
06:59:14 <hpc> :t fmap
06:59:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:00:17 <quicksilver> and as magicman points out the answer is always zero
07:00:20 <davv3> cool
07:00:24 <quicksilver> sometimes a very slowly calculated zero :)
07:00:27 <quicksilver> but that probably wasn't the point
07:00:31 <quicksilver> it was only an example of recursion.
07:00:38 <davv3> appreciate it
07:02:23 <Saizan> cpennington: i suspect you also have to put "import Dibels.Types" in the module itself
07:02:37 <Saizan> cpennington: but i've only used derive with TH
07:02:40 <davv3> do i need to import anything for getArgs?
07:02:40 <cpennington> Saizan: yup, I have it there as well
07:02:52 <cpennington> Saizan: Ok, maybe I'll try the TH route
07:03:14 <Saizan> @hoogle getArgs
07:03:14 <lambdabot> System.Environment getArgs :: IO [String]
07:03:14 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
07:03:49 <davv3> System.IO ?
07:04:25 <Saizan> System.Environment
07:04:27 <quicksilver> davv3: or just System
07:04:30 <quicksilver> oldskool.
07:04:33 <quicksilver> import System
07:04:44 <cpennington> Saizan: that did it. Thanks
07:05:40 <davv3> quicksilver: thanks much! now to rtfm a bit about functors :)
07:06:39 <Eduard_Munteanu> @where typeclassopedia
07:06:39 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:06:49 <Eduard_Munteanu> davv3: you might find that ^^ useful.
07:07:32 <hpc> there's also good lyah chapters for Functor, Applicative, Monad
07:08:49 <davv3> nice!
07:09:25 <Entroacceptor> @where lyah
07:09:26 <lambdabot> http://www.learnyouahaskell.com/
07:12:43 <mekeor> @where rwh
07:12:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:13:31 <hpc> do there exist any functors that do not have an applicative instance?
07:14:29 <Entroacceptor> I bet they exist
07:14:40 <djanatyn> the haskell time types are pretty pleasant to work with
07:15:27 <Entroacceptor> I still get nightmares about PHP's
07:15:29 <hpc> djanatyn: indeed, until you have to convert from haskell time to unix time
07:16:38 <quicksilver> hpc: utcTimeToPOSIXSeconds ?
07:17:59 <hpc> quicksilver: ...fml
07:18:33 <quicksilver> #fwp
07:18:56 <hpc> posixtime even has a Num instance, argh
07:19:06 <hpc> so many hours of my life wasted
07:19:10 <hpc> lol
07:19:28 <ion> :-)
07:19:46 <merijn> hpc: I consider all programming hours spent on time and calendars wasted
07:21:16 * cmccann explains how time zones are like burritos
07:21:53 <cmccann> just kidding, monads are way easier to understand than time and calendars will ever be
07:22:11 <merijn> way easier is an understatement
07:23:25 <hpc> that's what i like about perl
07:23:31 <hpc> all times start as unix timestamps
07:23:44 <hpc> then you can convert them to (year, month, day, ...) tuples
07:23:54 <hpc> or just do math on them
07:24:35 <nand`> lambdabot is back!
07:24:46 * nand` hugs lambdabot
07:25:14 <cmccann> merijn, I think the only things that can compare are dealing with floating point or unicode
07:25:28 <cmccann> this is why I prefer to avoid programs that work with dates/times, numbers, or text
07:25:32 <hpc> cmccann: floating point is simple: you never get the accuracy you want
07:25:35 <cmccann> and stick with simple things, like concurrency or category theory
07:25:54 <hpc> unicode is simple: if you can't pass ασδηγπο;ιεηρ to your program, change the encoding of stdin
07:25:59 <everythingWorks> Whats the ` sign called?
07:26:04 <hpc> everythingWorks: backtick
07:26:09 <everythingWorks> ty
07:26:13 <merijn> cmccann: Unicode is fairly simple
07:26:16 <ion> (or the grave accent)
07:26:25 <everythingWorks> ion: yep, its grave accent :D
07:26:52 <everythingWorks> wiki says: Grave accent. It's called backtick or backquote in programming, only :)
07:27:09 <merijn> cmccann: If you know how it works you only need to worry about the encoding when the data comes in or goes out. And most protocols have defined ways of determining the encoding
07:27:28 <merijn> Floating points are, of course a huge pain in the rear
07:28:36 <merijn> @quote quicksilver double
07:28:36 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
07:28:36 <lambdabot> will stab you in the back with a mantissa
07:28:47 <cmccann> heh
07:28:55 <ion> hah
07:29:01 <hpc> at least Float is upfront about not giving you the right answer
07:29:26 <hpc> > 0.1 + 0.2 :: FLoat
07:29:26 <lambdabot>   Not in scope: type constructor or class `FLoat'
07:29:29 <hpc> > 0.1 + 0.2 :: Float
07:29:29 <lambdabot>   0.3
07:29:34 <ion> Float gives you exactly the answer you requested.
07:29:51 <merijn> Most people just don't realise they're requesting the wrong thing :p
07:30:01 <hpc> heh
07:30:30 <hpc> i like how python has bigints but not bigfloats
07:30:43 <hpc> so you take your hugeass number and add 0.5 to it, and it dies
07:30:50 <cmccann> merijn, which is also how people get into trouble with unicode, by altering a piece of text and expecting that to follow simple rules :P
07:30:53 <merijn> Serves you right
07:34:11 <cmccann> hpc, obviously the correct approach would be to declare that the int is large enough that a float wouldn't retain anything after the decimal point anyway and just silently discard the 0.5
07:35:46 <mekeor> is there a function which does the same as: \f x -> f x x -- ?
07:35:54 <cmccann> join? :D
07:36:03 <mekeor> @src join
07:36:03 <lambdabot> join x =  x >>= id
07:36:05 <cmccann> > join (+) 2
07:36:06 <lambdabot>   4
07:36:10 <cmccann> > join (*) 3
07:36:10 <lambdabot>   9
07:36:10 <mekeor> cool, thanks
07:37:32 <qpu> is there a ghci command similar to @src ?
07:38:07 <qpu> :t join
07:38:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:38:17 <hpc> qpu: :info or :browse, perhaps
07:38:53 <cmccann> qpu, trying to figure out how that join example works? :P
07:38:57 <qpu> yeah
07:39:05 * mekeor also doesnt understand
07:39:15 <cmccann> do you know what the monad in question is?
07:39:35 <qpu> no, i suspect it's something lambdabot has and i haven't imported :]
07:39:44 <cmccann> it's ((->) r)
07:39:49 <cmccann> i.e. functions from a type
07:40:01 <cmccann> the reader monad, minus the newtype wrapper
07:40:04 <ion> qpu: http://heh.fi/haskell/functors/#function-instance
07:40:06 <hpc> mekeor: :list identifier -- only works on interpreted source
07:40:13 <Eduard_Munteanu> Well, lambdabot runs Caleskell, not Haskell :P
07:40:20 <cmccann> it's a standard instance
07:40:23 <guerrilla> does lambdabot log #haskell?
07:40:32 <hpc> guerrilla: other bots log #haskell
07:40:56 <hpc> lambdabot might too; i haven't looked too deeply at the source
07:41:02 <hpc> @hackage lambdabot -- if you care
07:41:02 <lambdabot> http://hackage.haskell.org/package/lambdabot -- if you care
07:41:10 <quicksilver> lambdabot doesn't.
07:41:30 <guerrilla> ok
07:42:18 <cmccann> qpu, mekeor: so thinking of it in terms of Reader, if some functions all have a first argument of a single type, that's the "environment" type from Reader
07:42:40 <cmccann> and you can combine them by taking a single argument of the shared type and passing it to all of them
07:43:37 <cmccann> the "ask" function from Reader is just id, and pure/return is const
07:44:19 <hpc> and (=<<) is more-or-less ($), iirc
07:44:32 <cmccann> and since join collapses two layers of a monad to a single one, it duplicates the argument as above
07:44:40 <cmccann> hpc, not quite
07:44:47 <hpc> @src (->) (>>=)
07:44:47 <lambdabot> f >>= k = \ r -> k (f r) r
07:45:13 <hpc> @src (->) (<*>)
07:45:13 <lambdabot> (<*>) f g x = f x (g x)
07:45:19 <hpc> huh
07:46:01 <cmccann> :t \f k r -> k (f r) r
07:46:02 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t -> t2) -> t -> t2
07:46:29 <cmccann> note that (=<<) = ($) for the identity monad, maybe that's what you're thinking of
07:47:03 * hackagebot bson-generics 0.0.1 - Generics functionality for BSON  http://hackage.haskell.org/package/bson-generics-0.0.1 (PetrPilar)
07:51:16 <cmccann> hpc, oh btw, re: functors that aren't applicative--most product types qualify
07:51:35 <hpc> orly?
07:51:52 <cmccann> you usually can't conjure up arbitrary values in pure and then combine values in (<*>) while satisfying the laws
07:52:04 <cmccann> unless you have extra constraints on the other type, or it has certain properties
07:52:08 <lpsmith> http://stackoverflow.com/questions/5989457/haskell-ffi-support-for-functions-with-variadic-arguments
07:52:23 <hpc> oh, that you can't
07:52:25 <cmccann> e.g. ((,) a) is a functor but not applicative (or monad)
07:52:29 <hpc> forall e. (e ,), yeah
07:52:33 <cmccann> if you give the "a" a monoid constraint it is
07:52:43 <hpc> but Functor isn't so constrained
07:52:46 <cmccann> right
07:52:51 <hpc> so yeah, good catch
07:53:00 <shachaf> cmccann: The "(or monad)" there is kind of redundant, I think.
07:53:05 <lpsmith> At the bottom of the page, Simon Marlow quotes the Haskell 2010 spec:  "Note that for a C function defined to accept a variable number of arguments, all arguments beyond the explicitly typed arguments suffer argument promotion."    What is argument promotion?
07:53:22 <quicksilver> argument promotion is a C concept, lpsmith
07:53:47 <quicksilver> all integral types become int, all floating point types become <answer elided because I don't know C ABIs>
07:53:56 <cmccann> shachaf, just emphasizing the point since that's obviously almost the writer monad
07:54:45 <quicksilver> if I'm not mistaken K&R C did argument promotion on all functions which didn't have prototypes.
07:54:52 <lpsmith> quicksilver, ahh I see
07:54:53 <quicksilver> but I could well be mistaken, my C is rubbish.
07:55:13 <lpsmith> My C is... middling.
07:55:34 <lpsmith> Definitely don't know it well enough to be any kind of expert.
07:56:07 <lpsmith> But I can usually find my way around without too much trouble.  My biggest weakness is that I don't know what is undefined behavior and what is not.
07:56:20 <cmccann> hpc, I think you can also have problems when a sum type uses the functor's type parameter in different branches
07:56:45 <cmccann> it's not always clear how (<*>) should combine things when you have two different constructors
07:56:59 <quicksilver> yes, how would you define (Left f) <*> (Right x)
07:57:27 <cmccann> quicksilver, I think in that case it might work to be consistently biased in one direction
07:57:40 <cmccann> and then ensure that pure produces the less-favored side
07:57:43 <cmccann> I think
07:57:46 <quicksilver> (in a way which is compatible with teh functor instance : fmap f (Left x) = Left (f x); fmap f (Right x) = Right (f x) )
07:57:50 <quicksilver> I don't think so, cmccann
07:58:11 <quicksilver> oh, you think (Left f) <*> (Right x) = Left (f x)
07:58:12 <quicksilver> hmm
07:58:35 <cmccann> quicksilver, and (Right f) <*> (Left x) = Left (f x) also
07:58:41 <cmccann> and then pure = Right
07:59:08 <cmccann> which is an identity on choice of constructor in (<*>)
07:59:11 <quicksilver> not pure = Left ?
07:59:27 <quicksilver> pretty sure you need pure = Left there.
07:59:44 <cmccann> quicksilver, no, you want (pure f <*> Left x) = Left x, (pure f <*> Right x) = Right x
07:59:58 <bertolo> :t map
07:59:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:59:59 <everythingWorks> Someone here using Eclipse? :]
08:00:05 <quicksilver> cmccann: ah
08:00:11 <bertolo> hi all :>
08:00:17 <quicksilver> cmccann: you mean (f x) on the RHS both times.
08:00:19 <quicksilver> but, ah.
08:00:28 <everythingWorks> Can't figure out how to disable those stupid warnings, which seem to occur by "-Wall".
08:01:57 <everythingWorks> I mean, the options page looks like this: http://dl.dropbox.com/u/6559846/hopt.PNG
08:02:36 <quicksilver> I very rarely hear people who know about eclipsefp
08:02:40 <quicksilver> in this channel
08:02:46 <quicksilver> (I do hear people asking about it of course)
08:03:08 <frerich> hello bertolo
08:03:36 <everythingWorks> quicksilver: Hm.. I think eclipse would go kinda well, what are most inhere using, thus? Vim? :D
08:03:37 <donri> everythingWorks: you could try passing the extra compiler option -W
08:03:50 <everythingWorks> donri: yeah, already tried, without success :/
08:03:51 <merijn> everythingWorks: Most use vim or emacs I think
08:14:31 <jonh321> anonymous deface fbi site -> http://imgchili.com/show/4392/4392629_british81.jpg
08:15:02 <srhb> Amazing how those things are targeted.
08:15:44 <qpu> everythingWorks: maybe you could write a wrapper script that eclipse calls instead (e.g., ghci.sh) and have that call ghci for you and discard the -Wall option
08:19:12 <everythingWorks> qpu: I'll think about it, thanks :D
08:21:36 <matthiasgorgens> :t ***
08:21:36 <lambdabot> parse error on input `***'
08:21:42 <matthiasgorgens> :t (***)
08:21:42 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:23:18 <matthiasgorgens> Can I coax the type-system to accept something like (action1 *** action2) :: (a,b) -> m (c,d) ?
08:23:34 <matthiasgorgens> I.e. convert from (m a, m b) to m (a, b) easily?
08:24:12 <copumpkin> not directly
08:24:16 <copumpkin> but Kleisli does that
08:25:09 <copumpkin> @ty (undefined *** undefined) :: Monad m => Kleisli m (a, b) (c, d)
08:25:09 <lambdabot> forall (m :: * -> *) a b c d. (Monad m) => Kleisli m (a, b) (c, d)
08:25:17 <matthiasgorgens> copumpkin: thanks, I'll have a look.
08:25:54 <matthiasgorgens> I'm asking because I want to transfer the map (f *** g) listOfTuples or map (f &&& g) list to the mapM version.
08:26:02 <matthiasgorgens> + idiom.
08:27:05 <hpc> :t mapM
08:27:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:27:17 <hpc> matthiasgorgens: use the Kleisli arrow
08:27:29 <hpc> oh, mentioned above
08:27:36 * hpc lrns2scrollback
08:28:16 <matthiasgorgens> hpc, thanks anyway. :o)
08:28:23 <hpc> :t uncurry (liftM2 (,)
08:28:23 <lambdabot> parse error (possibly incorrect indentation)
08:28:25 <hpc> :t uncurry (liftM2 (,))
08:28:26 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
08:28:40 <matthiasgorgens> hpc, I also discovered that.
08:29:43 <matthiasgorgens> :t fmap (uncurry (,))
08:29:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f (a, b)
08:29:55 <matthiasgorgens> oops.
08:31:50 <alistra> > 1.0/998001.0
08:31:50 <lambdabot>   1.002003004005006e-6
08:32:04 <alistra> > (1.0/998001.0)*100000000000
08:32:05 <lambdabot>   100200.3004005006
08:32:10 <alistra> > (1.0/998001.0)*100000000000000000000000000000000000000000000000
08:32:10 <lambdabot>   1.002003004005006e41
08:32:15 <alistra> meh trimming
08:32:20 <hpc> > 1.0/998001.0 :: CReal
08:32:21 <lambdabot>   0.000001002003004005006007008009010011012
08:32:34 <alistra> Cereal
08:34:20 <erus> In system f you have to pass type to polymorphic function
08:34:38 <erus> In Haskell you don't. How and why?
08:34:58 <hpc> erus: haskell doesn't use system F
08:35:48 <nand`> haskell uses a restricted set of system F which allows type inference
08:36:03 <nand`> namely HM
08:37:44 <erus> But.. But... The wikipidia
08:37:55 <nand`> https://en.wikipedia.org/wiki/System_F#Use_in_programming_languages
08:38:30 <nand`> oh seems like what I said isn't quite accurate either
08:38:35 <quicksilver> haskell doesn't "use" system F, really
08:38:55 <quicksilver> system F doesn't have a obvious way to account for typeclasses, although there are encodings.
08:39:12 <quicksilver> GHC uses a model based on FC with explicit equalities.
08:39:18 <quicksilver> JHC uses a slightly different model.
08:39:54 <qpu> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC
08:41:15 <nyingen> @quote
08:41:16 <lambdabot> jml says: A wise man once said, "the program isn't debugged until the last user is dead".
08:42:00 <monochrom> heh
08:44:05 <jml> Now that I think of it, he said "isn't fully debugged"
08:44:44 <mm_freak> what's a good module tree root for number-theoretic algorithms?
08:45:24 <mm_freak> NumberTheory.*?  Algorithm.*?  MyPackageName.*?
08:46:20 <hpc> Number.
08:46:28 <monochrom> http://hackage.haskell.org/package/arithmoi uses Math.NumberTheory
08:46:52 <danr> NumberTheory.Sieve.Phi is used too
08:47:03 <danr> Math.NumberTheory sounds reasonable for me
08:47:09 <hpc> ^
08:47:16 <shachaf> Seems redundant.
08:47:22 <mm_freak> that's such a mouthful…
08:47:40 <monochrom> http://hackage.haskell.org/package/Numbers uses Data.Numbers
08:47:44 <danr> yeah maybe a bit verbose
08:48:09 <hpc> in any event, Math.* is a good start
08:51:01 <mm_freak> i'll go with Math.MyPackageName.*
08:58:01 <lpsmith> danr, I rereleased NumberSieves so that it's Math.Sieve.Phi
09:00:36 <lpsmith> mm_freak, you may be interested in this:  https://github.com/lpsmith/NumberTheory
09:00:49 <danr> lpsmith: sounds good :)
09:00:54 <lpsmith> though the implementations are a lot slower than I'd like
09:02:55 <lpsmith> what really needs to happen is that somebody needs to put more complete bindings to the GMP algorithms for starters
09:03:32 <lpsmith> that way we have fast modular exponentiation,  etc.
09:03:58 <mm_freak> lpsmith: thanks a lot, but i have already implemented them =)
09:04:07 <matthiasgorgens> mapM (runKleisli (Kleisli a &&& Kleisli b)) [1,2,3] works.
09:04:29 <mm_freak> lpsmith: my implementations are very fast…  in fact they outperform PARI/GP
09:04:36 <matthiasgorgens> hpc, copumpkin, is there any way to make it nicer?
09:04:59 <mm_freak> lpsmith: if you're interested, i can upload the library today
09:05:00 <matthiasgorgens> hpc, copumpkin, a and b are functions with something like a -> IO b
09:05:15 <copumpkin> what's the overall type you want?
09:05:34 <matthiasgorgens> copumpkin: asking me?
09:05:45 <copumpkin> yeah
09:05:55 <hpc> :t \a b l -> mapM (runKleisli (Kleisli a &&& Kleisli b)) l
09:05:55 <lambdabot> forall a (m :: * -> *) c c'. (Monad m) => (a -> m c) -> (a -> m c') -> [a] -> m [(c, c')]
09:05:57 <lpsmith> mm_freak, that sounds awesome
09:06:28 <lpsmith> though that sounds a little suspect for e.g. modexp as I'm pretty sure pari/gp uses the gmp
09:06:46 <lpsmith> that would be quite impressive to implement modexp significantly faster than the gmp
09:06:50 <mm_freak> lpsmith: overall algorithm speed is better than PARI/GP
09:07:12 <mm_freak> an individual exponentiation is going to be about the same speed, but i didn't implement that one myself…  i'm just using (^)
09:07:28 <lpsmith> there is more here,  though a lot of it isn't of general interest,  and what is there is often slower than I'd like
09:07:29 <lpsmith> https://github.com/lpsmith/NumberTheory/blob/master/old/NumberTheory.hs
09:08:12 <hpaste> MatthiasGoergens pasted “Kleisli, how?” at http://hpaste.org/57011
09:08:20 <matthiasgorgens> copumpkin: I want to simplify stuff like in the paste.
09:08:49 <matthiasgorgens> (and forget the frist line that defines `item' in the paste.  that was just an attempt.)
09:08:56 <mm_freak> matthiasgorgens: you can't really…  but you can write your own monad-specific combinators
09:09:05 <mm_freak> the ones from Category are already there
09:09:10 <mm_freak> (<=<) and return
09:09:26 <mm_freak> and arr corresponds to fmap
09:09:33 <hpaste> MatthiasGoergens annotated “Kleisli, how?” with “Kleisli, how? (annotation)” at http://hpaste.org/57011#a57012
09:10:11 <mm_freak> matthiasgorgens: the other combinators can be quite easily implemented in terms of Applicative
09:10:50 <hpc> :t arr
09:10:50 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
09:10:59 <mm_freak> :t let c1 *=* c2 = \(x, y) -> liftA2 (,) (c1 x) (c2 y) in (*=*)
09:11:00 <lambdabot> forall t (f :: * -> *) a t1 b. (Applicative f) => (t -> f a) -> (t1 -> f b) -> (t, t1) -> f (a, b)
09:11:16 <mm_freak> but i'd just use applicative style instead of that
09:12:04 <mm_freak> lpsmith: thanks for sharing
09:12:19 <mm_freak> lpsmith: skimming through it it appears that i have implemented fast versions of most of them =)
09:12:32 <matthiasgorgens> mm_freak: interesting, thanks.
09:12:48 <hpc> :t flip `asTypeOf` arr
09:12:49 <lambdabot> forall b b1. (b1 -> b1 -> b) -> b1 -> b1 -> b
09:13:43 <erus`> hpc, sorry i was using irc on my phone whilst on the train
09:13:51 <erus`> you said haskell is not system f
09:13:58 <erus`> i thought it was based on system f
09:14:20 <lpsmith> mm_freak, is this on github or something similar yet?
09:14:46 <mm_freak> lpsmith: not yet…  i'll stabilize the interface and then upload to hackage
09:14:55 <mm_freak> right now it's a pretty experimental project
09:18:17 <Kanisterschleife> hi. I want to install "process" via cabal, but runProcess.h is missing. I don't know which library I have to install now
09:18:55 <dmwit> You should not install process via cabal.
09:19:29 <Kanisterschleife> dmwit: Oh ok. How do I know this? I am new and thought I should better install all haskell related packages via cabal
09:20:04 <dmwit> You should attempt to change the installation of any of the packages that come with GHC.
09:20:13 <Saizan> *shouldn't
09:20:18 <dmwit> um, yes
09:20:31 <dmwit> If you would like to upgrade those, upgrade GHC instead.
09:21:06 <Kanisterschleife> dmwit: I don't understand what you mean. Originally I wanted to install hsc2hs via cabal, but process was missing, to I tried to install process via cabal, too.
09:21:21 <dmwit> What is the output of ghc-pkg list process?
09:22:39 <Kanisterschleife> /usr/local/lib/ghc-7.0.4/package.conf.d\n process 1.0.1.5
09:22:57 <dmwit> ...looks like you have process installed to me. ;-)
09:23:13 <dmwit> (You'd better give a few more details: what's cabal's exact error message when trying to install hsc2hs?)
09:23:20 <Kanisterschleife> ok
09:23:20 <dmwit> ?hpaste
09:23:20 <lambdabot> Haskell pastebin: http://hpaste.org/
09:23:56 <Kanisterschleife> dmwit: but by the way, how do I know what I should install via cabal?
09:24:18 <Saizan> Kanisterschleife: hsc2hs is also shipped with ghc, btw
09:24:53 <dmwit> Kanisterschleife: I think you shouldn't attempt to install any package listed here:
09:24:59 <cmccann> Kanisterschleife, I think the usual rule is "install everything via cabal, except for things you shouldn't be installing at all"
09:25:00 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/
09:25:13 <dmwit> (The right-hand column lists the package name.)
09:26:07 <Saizan> or "ghc-pkg list --global" on an installation where you haven't installed anything globally yourself
09:26:19 <Kanisterschleife> dmwit, cmccann: Okay
09:26:54 <hpaste> Kanisterschleife pasted “cabal install hsc2hs” at http://hpaste.org/57014
09:27:15 <Saizan> (btw, i used to be able to install process separately quite fine, though it does make you more likely to bump into dependency problems, and anyhow it seems the build is broken now)
09:27:26 <dmwit> Kanisterschleife: Perhaps you need to add `process' to the build-depends in your .cabal file.
09:27:57 <dmwit> Kanisterschleife: Try "cabal unpack hsc2hs" if you'd like to create a directory with the .cabal file in it.
09:28:25 <dmwit> Kanisterschleife: If you change the dependencies of the package, make *sure* you bump the version number to one that will never be available on Hackage.
09:28:33 <Saizan> Kanisterschleife: are you sure you need to install hsc2hs separately? how did you install ghc?
09:31:41 <Kanisterschleife> Sorry if this is stupid, but I just wanted to look up the template_hsc.h file to see that hsc2hc does, just for better understanding; as it doesn't seem to exist on my machine, I thought hsc2hs was missing. However, the binary is there. So probably I just had to get the source via "cabal unpack hsc2hs", and not to install it
09:32:41 <Saizan> not stupid, and it's not your fault that one needs to know these guidelines to avoid later problems with cabal
09:33:08 <Saizan> we just tried to prevent your installation from breaking :)
09:34:35 <Kanisterschleife> Saizan: Ok I think everything is fine now, as hsc2hs already seems to be installed, and after unpacking its source via cabal unpack I can also look up the template_hsc.h file
09:34:58 <Kanisterschleife> thank you all
09:36:34 <Saizan> the hsc2hs package on hackage seems unmaintained
09:37:56 <tommd> yep - I just ran across that yesterday.
09:39:08 <Saizan> it'd be more accurate to use http://darcs.haskell.org/hsc2hs/ or the source tarball of ghc as a reference
09:44:30 <aszlig> hm, in HsOpenSSL there is just writePKCS8PrivateKey... and i'm using "certificate" with Network.TLS, so it expects the private key to be PKCS1 - what would be the cleaner solution -> creating a binding for PEM_write_bio_PrivateKey and using it or just ASN.1-parse the PKCS8 and return a PrivateKey? or even better: am i missing something? :-)
09:48:44 <aszlig> ah, as a side-note: the project i'm working on consists of a master daemon and a slave daemon and the master may have external dependencies such as the openssl library, but slave has to have no ext library depends
09:49:37 <aszlig> ... which is why i'm using Network.TLS =)
09:54:43 <Number6> Hey. On Debian, what packages do I need apart from haskell-platform? I'm getting some errors when running cabal install cabal-install
09:55:51 <c_wraith> gmp, maybe?
09:56:13 <c_wraith> anything other than random guessing would require some information about *what* errors
09:57:45 <hpaste> Number6 pasted “Debian 6 ” at http://hpaste.org/57015
09:58:08 <Number6> That hpaste has the output from cabal
09:58:24 <Twey> What would you recommend as a representation of a 32-bit signed integer for use in interfacing with C?
09:58:34 <Clint> Number6: you should backport the ghc from wheezy to squeeze
09:58:59 <aszlig> Number6: cabal-install compiled and installed fine
09:59:24 <aszlig> you need a new base
09:59:50 <frerich> @botsnack
09:59:50 <lambdabot> :)
09:59:53 <Number6> azaq23: From backports?
10:00:13 <Enigmagic> Twey: CInt ?
10:00:41 <aszlig> Number6: which release of debian are you using?
10:00:53 <Number6> azaq23: Squeeze / 6
10:00:54 <aszlig> unfortunately there are no backports available of ghc
10:01:00 <Twey> Enigmagic: Is that guaranteed to be 32-bit?  I thought it depended on architecture
10:01:17 <Enigmagic> Twey: CSize is arch dependent
10:01:22 <Enigmagic> CInt/CLong are fixed
10:01:30 <Twey> Oh, okay… cool, thanks
10:01:41 <aszlig> Number6: but they should install without any other dependencies from wheezy
10:06:20 <Number6> aszlig: Ok. I'll add in the Wheezy source, and update
10:06:42 <aszlig> Number6: mh, but no dist-upgrade or upgrade ;-)
10:06:54 <aszlig> Number6: you could also install the yesod-packages from debian
10:07:15 <aszlig> Number6: or cabal-install an older release of yesod
10:09:21 <frerich> Does anybody know a good package for generating text-mode interfaces (think 'top' or IRC clients)? I tip-toed around hscurses so far, but simpler stuff like System.Console.ANSI doesn't seem to work too well in the Mac OS X terminal. :-/
10:10:58 <aszlig> frerich: what about vty?
10:11:18 <Enigmagic> vty looks better in hackage but i haven't used either
10:11:52 <frerich> aszlig: Cool, I wasn't aware of that, I'll give it a try. Thanks for the pointer!
10:12:16 <aszlig> you could use vty and vty-ui, which is a collection of widgets for vty
10:14:02 <Number6> aszlig: The debian version of yesod is in Wheesy :-)
10:15:35 <frerich> aszlig: Hm, I see. I don't think I need that much fancyness, I just try to do something like a 'file browser' which shows the file contents in the topmost 22 lines, then a separator bar, then an empty line at the bottom for me to enter commands (like 'pageup' or 'quit'). I can't seem to find a good way to update the topmost 22 lines without clearing the whole screen.
10:16:39 <frerich> aszlig: I hoped ANSI would do the job, but it seems that at least the Mac OS/X terminal doesn't really support that. At least not as good as I had hoped.
10:16:54 <Clint> no, the macos x terminal is pretty terrible
10:17:04 <Clint> and so is their xterm, in different ways
10:29:25 <alkoma> hi, I've just completed building ghc-7.2.2 - everything went smoothly.  Do I need to reinstall Cabal to go with it, or can I just use the one that go with haskell-platform?
10:29:34 <eyebloom> Is there an equivalent to Data.Set.deleteFindMax in set theory/ set algebra?
10:29:58 <c_wraith> alkoma: the "cabal" binary works fine across a range of ghc versions
10:30:55 <alkoma> c_wraith: do I need to do any configuration change so Cabal will use the new ghc binary instead of the old one?  Or just update PATH is enough?
10:31:19 <monochrom> PATH is enough
10:31:23 <c_wraith> alkoma: the path is sufficient. It will take care of everything else
10:31:36 <alkoma> great! thanks
10:33:06 <k0ral> hi there, I have a function f :: IO () which makes use of an IORef, and I want f to create this IORef the first time it is called and reuse it for each further call to f
10:33:30 <monochrom> that is hard
10:34:01 <k0ral> hard means possible, so should I keep hope on this ?
10:34:08 <k0ral> or is it *that* hard ?
10:35:58 <cmccann> k0ral, it's usually not what you actually want to do
10:36:08 <monochrom> one way is unsafePerformIO
10:36:38 <k0ral> cmccann: let me reformulate my need then
10:36:38 <cmccann> you can construct a function that does what you want inside IO easily enough
10:36:55 <cmccann> but I don't think you can define one at the top level without top-level IO, which requires cheating with unsafePerformIO
10:36:59 <k0ral> monochrom: I'm frightened by this "unsafe" and don't want to get into such things
10:37:38 <cmccann> the top-level IO thing is a well-known hack and is sometimes the best solution, but I'd avoid it when possible
10:37:49 <k0ral> I'm using dyre to make it possible for users to configure my application
10:38:13 <k0ral> and I want to expose a function f to users
10:38:25 <k0ral> as the f :: IO () I described earlier
10:38:30 <k0ral> but
10:38:38 <mm_freak> k0ral: if you find a nice way to do that, i'd be very interested
10:38:43 <k0ral> let's forget for now the need for creating an IORef inside f
10:38:50 <mm_freak> i tried that for a long time, before giving up
10:38:59 <k0ral> mm_freak: I shall keep you posted :)
10:39:19 <cmccann> I don't know enough about dyre to help... but that begins to sound like the kind of situation where resorting to the unsafePerformIO top-level IO hack may be the least-bad solution
10:39:23 <k0ral> mm_freak: but it sounds like I won't have much success
10:39:58 <k0ral> so let me carry on
10:40:23 <k0ral> I want users to be able to use f but it needs an IORef
10:40:43 <k0ral> and I find it quite (not to say very) ugly to let the user create the IORef
10:40:54 <k0ral> since I don't expect users to know how the f works
10:41:17 <monochrom> that can be encapsulated
10:41:18 <k0ral> besides that, I have a dozen of f-s
10:41:32 <k0ral> so I would have the user create a dozen of IORef
10:41:35 <mm_freak> k0ral: if you find a way to do that, you solve a big theoretical problem i'm having =)
10:41:50 <k0ral> mm_freak: well, at least I'm not asking a silly question, for once :)
10:42:12 <k0ral> monochrom: what do you mean ?
10:42:29 <mm_freak> hehe…  i think a question can't be silly, unless you deliberately make it silly =)
10:42:45 <monochrom> the user has to call a procedure to create something, before passing that something to f. the user doesn't know what's inside something.
10:42:45 <mm_freak> (when i said, "there are no stupid questions", i was proven wrong)
10:42:50 <mkscrg> does anyone know of a good hash ring implementation on hackage?
10:43:02 <cmccann> k0ral, you could wrap it up as something like getf :: IO (IO ()) where the IORef is created first, and the resulting IO () value does what you want
10:43:15 <cmccann> in some situations at least
10:43:23 * cmccann doesn't know how the dyre stuff works
10:43:43 <k0ral> cmccann: it's fairly simple: the configuration file is the main function
10:44:14 <k0ral> and instead of providing a program, you provide a library which the user may call in its main from the configuration file, with proper parameters
10:44:37 <k0ral> dyre just makes the process easier
10:44:48 <k0ral> with automatic recompilation when the configuration changes
10:45:15 <cmccann> and the (IO ()) action you want should be available to the "config" program, and then used by the "real" program?
10:45:27 <hpaste> nand pasted “Euler Project 26” at http://hpaste.org/57016
10:45:47 <k0ral> monochrom: that's not completely satisfying but that's the best I could imagine for now
10:47:00 <k0ral> cmccann: yes, the library basically provides a kind of "launchProgram" function you must feed with parameters, and those parameters may include hook functions  e.g.
10:47:22 <everythingWorks> hey
10:47:43 <everythingWorks> What does this guy "Daniel" mean with his answer? Which ".ghci" file does he mean? :) http://stackoverflow.com/questions/9022431/reduce-eclipse-type-warning-level/9023441#9023441
10:47:59 <matthiasgorgens> k0ral: yes, that's the way xmonad works.
10:48:01 <cmccann> k0ral, yeah, so you need to give "create stuff" action(s) that the config program has to call, the results of which are fed in to the real program
10:48:15 <k0ral> matthiasgorgens: indeed, except that they don't use dyre but do it manually
10:48:16 <monochrom> Daniel wrote "~/.ghci"
10:48:31 <everythingWorks> monochrom: do you know what it means on windows? :D
10:48:59 <cmccann> k0ral, there are many ways you can abstract over the details or shuffle the interface around but it all boils down to what monochrom suggested
10:49:09 <k0ral> problem is
10:49:24 <k0ral> f is supposed to retrieve this IORef
10:49:30 <everythingWorks> I cannot find any ".ghci" file within my home directory there  :/
10:49:32 <k0ral> so it must be stored in a global state structure
10:49:46 <k0ral> which the real program uses to feed f
10:50:15 <cmccann> k0ral, you can't define everything globally
10:50:32 <k0ral> so how would you pass around the IORef to f ?
10:50:42 <k0ral> I mean, inside the real program (as you call it)
10:50:57 <monochrom> /Users/you/AppData/Roaming/ghc/ghci.conf but it depends on which Windows
10:51:26 <cmccann> k0ral, I'd consider something like making "f" a field in an explicit global state record, and providing an action to the config program that creates that record with all the IORefs needed
10:51:36 <cmccann> then pass the resulting structure in to the library portion
10:51:42 <cmccann> stick it in a Reader monad or something
10:51:46 <nand`> monochrom: for future reference that's %appdata%\ghc
10:51:49 <nand`> which is backwards compatible too
10:52:02 <Palmik> Hmm, is it possible to get the number of constructors certain data type has using GHC.Generics?
10:52:38 <k0ral> cmccann, monochrom: the problem in what you're telling me is: f is user-provided
10:52:53 <everythingWorks> monochrom: such a file does not exist. I created one. It works. You're genius, thanks! :D
10:52:56 <k0ral> it may use IORef-s, or not
10:53:50 <monochrom> if the user wrote f, the user worries how many IORefs and MVars and TVars it uses, and it is none of your business anyway
10:53:50 <k0ral> cmccann, monochrom: so I have no way to know how many, neither of which types, are the IORef-s
10:54:03 <k0ral> monochrom: I was expecting this reply
10:54:11 <k0ral> monochrom: I prepared a counter :D
10:54:29 <cmccann> k0ral, keep in mind that you can use partial application to "hide" an IORef
10:54:44 <k0ral> I'm working for hbro, and as in xmonad, I created a hbro-contrib package to gather helper functions
10:54:47 <cmccann> but I'm still not sure about the details of what you're doing and don't really have time to consider it in greater depth, sorry
10:55:10 <k0ral> I want users to be able to use those helper functions without knowing their internal mechanisms
10:55:13 <alpounet_> k0ral, how did xmonad solve the problem you have (if applicable) ?
10:55:26 <k0ral> f is one of these helpers
10:55:48 <monochrom> xmonad does ReaderT BigRecord IO or something like that
10:56:08 <k0ral> alpounet_: I have absolutely no idea, and I would be very interested in getting an xmonad-maintainer's piece of advice
10:56:18 <monochrom> the BigRecord probably hides 3 IORefs, 4 MVars, and a bunch of Strings
10:56:35 <k0ral> yeah but say one of xmonad-contrib functions needs an additionnal IORef
10:57:33 <k0ral> how do they do ?
10:57:34 <ceii> k0ral, that's awkward to deal with in XMonad. People eitehr use unsafePerformIO to create their ref, or store stuff in a string property of the root window.
10:57:39 <ceii> either*
10:58:03 <k0ral> cmccann: no problem, thanks for your time :)
10:58:30 <k0ral> why is this unsafePerformIO unsafe ?
10:59:01 <monochrom> it is probably safe. the real problem is the singleton pattern
11:00:03 <davv3> 66
11:00:06 <ceii> k0ral: unsafePerformIO has type IO a -> a, which is obviously dangerous. When used to initialize top-level resources it's considered safe though
11:00:22 <Peaker> I wouldn't consider it safe then
11:00:24 <mornfall> ceii: To an extent. :-)
11:00:35 <Peaker> The benefits of using unsafePerformIO for that purpose too are miniscule
11:00:42 <k0ral> or maybe you could imagine another way of solving my problem ?
11:00:46 <k0ral> without any IORef ?
11:00:54 <matthiasgorgens> The name unsafePerformIO just means "Dear Programmer, I can't guarantee safety here.  Please make sure you know what you are doing.  Sincerely, The Compiler."
11:01:01 <matthiasgorgens> I.e. you have to provide the guarantee.
11:01:04 <k0ral> :D
11:01:16 <k0ral> I never trust the programmer (= me)
11:01:18 <mornfall> matthiasgorgens: Well, you don't. People write buggy programs all the time.
11:01:26 <mornfall> :-)
11:01:44 <Peaker> k0ral: why don't you make: makeThingie :: IO Thingie, and export all your functions with:  Thingie -> ... ?
11:01:47 <ceii> at any rate, what about keeping a big "Map String Dynamic" in a single IORef? Extensions each use a unique String key (like the module name) to access their part of the data.
11:01:56 <Peaker> k0ral: then, Thingie can internally contain your IORefs or what not?
11:02:25 <Peaker> k0ral: I joined after you asked your question so I'm not sure I understand what you want to do
11:02:40 <k0ral> ceii: is that really working ?
11:02:51 <k0ral> I mean: have you ever seen a program doing this ?
11:03:11 <k0ral> Peaker: given your answer I think you got it
11:03:25 <ceii> k0ral, no, but I've always thought XMonad should
11:03:35 <k0ral> Peaker: but the problem is Thingie is user-dependent
11:03:54 <Peaker> k0ral: Can you show an example?
11:04:08 <k0ral> ceii: there's a drawback: the compiler won't be able to detect collisions
11:04:21 <k0ral> there will be runtime problems
11:04:28 <ceii> k0ral, yes, the uniqueness of keys is entirely up to convention
11:05:05 <k0ral> Peaker: it's too long to show, unless you have some time to spend to read some code; instead, I would use the comparison with xmonad; do you know it ?
11:05:08 <matthiasgorgens> You can use a monad to produce unique values. ;o)
11:05:13 <matthiasgorgens> (Not appropriate at all here.)
11:05:29 <ceii> also, and this is important in the case of XMonad, Dynamics can't be deserialized. This means you can't restore that part of the state on application restart.
11:05:53 <CodeWeaver> Okay.  I'm mangling .cabal files to force a project to build with libraries it was not necessarily tested on.  MAJIKAL HACQUERY FTW
11:06:15 <k0ral> ceii: that wouldn't be a problem in my case
11:06:19 <CodeWeaver> And now, I return to trying to understand the monad, arrow, and applicative stuff you guys keep talking about.
11:07:06 * hackagebot ekg 0.3.0.1 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.0.1 (JohanTibell)
11:08:40 <k0ral> I think I'm heading towards the map solution
11:10:38 <mm_freak> k0ral: what is your application?
11:10:46 <k0ral> mm_freak: hbro and hbro-contrib
11:11:09 <b0fh_ua> Hi all, what is the best way to generate lots of strings in haskell? randomly by some dictionary. Is there any hackage for that?
11:11:46 <mm_freak> k0ral: i mean the specific IORef thing you wanted
11:12:30 <k0ral> mm_freak: in which use case you mean ?
11:12:37 <mm_freak> b0fh_ua: with a dictionary, you would usually just read the strings into some data structure like Set and then randomly remove elements from it
11:12:43 <tgeeky> b0fh_ua: a good strategy might be to create some word or sentence type, and use QuickCheck to generate arbitrary (words) or (sentences)
11:12:55 <matthiasgorgens> b0fh_ua: try quickcheck?
11:13:03 <monochrom> k0ral: Once upon a time, people thought that the DNS lookup lib just needed one singleton for options, and they did exactly that, a few global variables for the options, a few procedures to set them. Then multi-threading came along, and that scheme became thread-unsafe. Now the lib has obsoleted the scheme (the procedures for setting the global variables are now abort("don't use me")). The new scheme makes you first call a pr
11:13:03 <monochrom> ocedure to create a fresh record of config variables, then you use that record for changing options and doing DNS lookups. The singleton pattern is so passe. I say this not in protest of unsafePerformIO (it's perfect safe for this), but in caution of the singleton mindset --- it will hurt later.
11:13:06 <mm_freak> b0fh_ua: but there are better ways, if you don't need the random permutation
11:13:09 <matthiasgorgens> or you want them from the dictionary?
11:13:11 <alkoma> b0fh_ua: i don't know about haskell, but google for markov chain, there are some fun program that generate whole book
11:13:14 <tgeeky> b0fh_ua: and a good source of words might be 'lexical word finder'
11:13:14 <mm_freak> k0ral: nevermind
11:13:36 <mm_freak> for markov chains there are multiple packages on hackage
11:13:41 <b0fh_ua> mm_freak: basically I need to fill up records of `00+ fields with some data, chosen randomly
11:13:45 <mm_freak> but markov chains don't really play well with dictionaries
11:14:03 <b0fh_ua> ideally it couldhave some meaning, likf names, fake e-mail addresses, street addresses etc
11:14:13 <tgeeky> b0fh_ua: yes.
11:14:23 <mm_freak> b0fh_ua: would you mind duplicates and randomly generated words?
11:14:24 <tgeeky> b0fh_ua: the best strategy is to use QuickCheck, and it's Arbitrary data type
11:14:43 <alkoma> mm_freak, correct, it generate new text based on prob. of n-gram from the input.
11:14:47 <b0fh_ua> mm_freak: it doesn't matter
11:14:56 <mm_freak> b0fh_ua: then indeed markov chains might be very useful
11:14:57 <tgeeky> b0fh_ua: if you're a little more brave and/or mathematically inclined, there's an article on generating exactly the sort of thing you're talking about.
11:15:02 <mm_freak> there are quite a few packages on hackage for that
11:15:07 <b0fh_ua> tgeeky: shoot :)
11:15:19 <tgeeky> b0fh_ua: let me find it. one second.
11:15:23 <b0fh_ua> thanks!
11:15:34 <b0fh_ua> I need this data in order to generate some 'load' to be tested with search engine
11:15:51 <mm_freak> b0fh_ua: then definitely use a markov chain =)
11:15:53 <b0fh_ua> so basically I need to supply some rules that 10% of records must match given criteria
11:15:54 <tgeeky> yes
11:15:59 <tgeeky> that is a markov thing
11:16:06 <tgeeky> b0fh_ua: here is the paper: http://web.mit.edu/~ezyang/Public/p61-canou.pdf
11:16:17 <b0fh_ua> mm_freak: the nature of data is that it doesn't use fulltext search
11:16:25 <mm_freak> b0fh_ua: do you need a library or would a program suffice?
11:16:35 <b0fh_ua> it is simply large set of fields to be checked with equals/greater than/less than
11:16:42 <b0fh_ua> mm_freak: program is ok
11:16:54 <mm_freak> b0fh_ua: then check this out:  http://hackage.haskell.org/package/detrospector
11:16:55 <b0fh_ua> just need to quickly get huge CSV file :)
11:17:31 <k0ral> monochrom: I'm not sure I got the whole points of the story
11:17:33 <startling> Is there a parser generator better than happy? I like the yacciness of it, but I can't get past its obtuse error messages.
11:17:39 <mm_freak> when you need a library, there is this one:  http://hackage.haskell.org/package/markov-chain
11:17:44 <mm_freak> but the library is slower than the program
11:17:56 <mm_freak> or wait, until i'm finished with my own markov chain implementation =)
11:18:05 <monochrom> the point is that you will one day move towards passing around a record of IORefs, encapsulated or not
11:18:08 <k0ral> monochrom: do you mean that they used a dynamic map first and obsoleted it then
11:18:10 <k0ral> ?
11:18:30 <otters> pardon the probable ignorance of my question, but if you have a function that returns an IO a, is it possible to transform the result into a Maybe a depending on whether the action causes an exception or not?
11:18:43 <monochrom> no, the old scheme used a singleton global IORef, in Haskell-speak
11:19:10 <alkoma> "bull-shit generators"  - quoted the markov-chain document   ;)
11:19:11 <k0ral> monochrom: fine, but how should I deal with the fact that such record is user-dependent ?!
11:20:14 <nand`> otters: not safely, afaik
11:20:14 <k0ral> otters: I would say IO (Maybe a) since you can't get a out of IO
11:20:23 <otters> aw
11:20:36 <monochrom> I don't understand that. Apparently, if something is so user-dependent, the user should deal with it, you have no capability to deal with it anyway
11:20:37 <otters> yeah, I was just wondering whether you could get it out of the IO or not
11:20:41 * otters grumps
11:20:46 <Sgeo> @hoogle IO a -> IO (Maybe a)
11:20:46 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
11:20:46 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
11:20:46 <lambdabot> Prelude Just :: a -> Maybe a
11:20:56 <Sgeo> @hoogle try
11:20:56 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
11:20:56 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
11:20:56 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
11:21:19 <Sgeo> The third one is probably the one to use
11:21:26 <Sgeo> @hoogle Either a b -> Maybe b
11:21:26 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
11:21:26 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
11:21:26 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
11:21:43 <copumpkin> :t either (const Nothing) Just
11:21:43 <lambdabot> forall a a1. Either a1 a -> Maybe a
11:21:49 <k0ral> monochrom: user-dependent means the user chooses the function, but may not have implemented it
11:22:18 <k0ral> monochrom: and some of the function choices would use IORef-s, others would not
11:22:29 <k0ral> monochrom: so in your program you don't know how many IORef-s to expect
11:22:35 <monochrom> ok, the author of the function deals with its problems
11:23:03 <k0ral> :)
11:23:33 <monochrom> it is a necessity since it is not like a caller can use reflection to read the source code of the callee.
11:23:52 <b0fh_ua> mm_freak: the package doesn't build here.
11:24:03 * roconnor wonder if he will be a better Haskell programmer if he understands comprehension categories
11:24:07 <b0fh_ua> mm_freak: 'Use -XTypeSynonymInstances if you want to disable this'
11:24:17 <b0fh_ua> looks like needs to be patched )
11:24:38 <mm_freak> getting the same error
11:24:50 <mm_freak> perhaps write a bug report to the author
11:25:09 <mm_freak> Maintainer: Keegan McAllister <mcallister.keegan@gmail.com>
11:25:33 <donri> @seen kmc
11:25:33 <lambdabot> Unknown command, try @list
11:25:37 <donri> preflex: seen kmc
11:25:37 <preflex>  kmc was last seen on #haskell-blah 1 minute and 25 seconds ago, saying: cheater you should ask in #haskell
11:25:54 <kmc> <ceii> k0ral: unsafePerformIO has type IO a -> a, which is obviously dangerous. When used to initialize top-level resources it's considered safe though
11:25:56 <mm_freak> kmc: what a nice coincidence =)
11:25:56 <kmc> not by me
11:25:57 <k0ral> monochrom: indeed, my problem is, as author of the function, I must tell the user "if you want to use my wonderful function you must first create an IORef, insert it inside the record of IORef-s that is passed around inside the real program"
11:26:22 <kmc> http://hackage.haskell.org/trac/ghc/ticket/5558 http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
11:26:23 <mm_freak> kmc: when compiling detrospector using GHC 7.0.3 i get a missing extension error
11:26:23 <k0ral> monochrom: and I just happen to find this "dependency" ugly
11:26:30 <mm_freak> kmc: it requires TypeSynonymInstances
11:26:36 <kmc> ok
11:26:39 <kmc> thanks for the bug report!
11:26:49 <mm_freak> thank b0fh_ua…  he discovered it
11:27:00 <b0fh_ua> mm_freak: and fixed :)
11:27:03 <b0fh_ua> locally
11:27:05 <roconnor> @seen edwardk
11:27:05 <lambdabot> Unknown command, try @list
11:27:10 <copumpkin> roconnor: need him?
11:27:13 <roconnor> preflex: seen edwardk
11:27:13 <preflex>  edwardk was last seen on #haskell 11 days, 23 hours, 33 minutes and 7 seconds ago, saying: look in Data.Bits for complement
11:27:19 <roconnor> copumpkin: not urgently
11:27:41 <k0ral> kmc: I'm still wondering which of the map String Dynamic and unsafePerformIO is the least {unsafe,ugly,unpure}
11:27:46 <copumpkin> roconnor: alright
11:27:54 <b0fh_ua> kmc: btw detrospector -? doesn't work for me
11:27:56 <kmc> i didn't read the whole preceding discussion
11:28:15 <kmc> but how are they alternatives? even if you have a Map String Dynamic, you have to get that map to every function
11:28:16 <mm_freak> b0fh_ua: try --help
11:28:20 <mm_freak> b0fh_ua: or -\?
11:28:23 <kmc> "doesn't work"
11:28:26 <hpaste> nand pasted “Euler Project 27” at http://hpaste.org/57020
11:28:37 <nand`> How to best parallelize the code I just posted?
11:28:39 <mm_freak> b0fh_ua: your shell interprets -? as a pattern
11:28:45 <b0fh_ua> mm_freak: --help does work, thanks
11:28:45 <kmc> b0fh_ua, could you explain how it "doesn't work"?
11:28:56 <nand`> It comes down to the “maximumBy”, but my “comparing snd” function is both associative and commutative
11:29:39 <b0fh_ua> kmc: it doesn't recignize -? but it may be problem with my shell
11:29:46 <cheater_> hi
11:29:52 <b0fh_ua> mm_freak: btw I think that this app is not what I'm looking for :(
11:29:54 <k0ral> kmc: I amready have a state monad for that
11:30:01 <k0ral> s/amready/already
11:30:04 <_Mikey> :o
11:30:13 <kmc> b0fh_ua, "doesn't recognize" is not any better than "doesn't work".  what output do you expect, and what output do you get?
11:30:14 <cheater_> can i have a function <> such that          f a b c d e == a <> f b c d e   ?
11:30:22 <b0fh_ua> because it generates text - and I need to generate CSV with lots of different fields. Splitting text doesn't help much
11:30:27 <kmc> mm_freak, ah, it seems the problem is that Data.HashMap.HashMap became a type synonym (for Data.HashMap.Map)
11:30:28 <mm_freak> b0fh_ua: feed it some example strings and it will give you an arbitrarily long stream of strings of that kind
11:30:32 <b0fh_ua> kmc: I expect help screen
11:30:41 <mm_freak> b0fh_ua: you might need to postprocess that stream, but it's basically what you want
11:30:46 <b0fh_ua> and I get zsh: no matches found: -?
11:30:49 <b0fh_ua> so it's up to my shell
11:30:50 <mm_freak> kmc: ah, ok
11:30:52 <kmc> ah, yes
11:30:54 <kmc> i was actually thinking of switching to unordered-containers
11:31:08 <mm_freak> b0fh_ua: that's not a bug in detrospector, that's a zsh problem
11:31:17 <b0fh_ua> mm_freak: I know :)
11:31:23 <kmc> well it's kind of a bug if my program wants arguments that can't be easily typed at the shell
11:31:33 <kmc> but so do many standard unix utilities
11:31:40 <kmc> anyway thanks for pointing that out
11:31:45 <mm_freak> kmc: that's cmdargs' default for the help switch
11:31:47 <kmc> i wanted to use -h but couldn't for some reason?
11:31:52 <kmc> it's been a while
11:32:09 <mm_freak> kmc: see helpArg
11:32:11 <lpsmith> it'd be nice to have crit-bit trees or similar for Haskell
11:32:16 <mm_freak> in CmdArgs.Implicit
11:32:24 <Kanisterschleife> Hi. When compiling the source in the pastebin below, Haskell always warns me that the two pattern matches overlap. In fact, when I start the programm, I always get "Released" both on press and release event. What am I doing wrong?
11:32:27 <hpaste> Kanisterschleife pasted “grabKey” at http://hpaste.org/57021
11:32:49 <kmc> lpsmith, where can i read about crit-bit trees?
11:33:04 <lpsmith> http://cr.yp.to/critbit.html
11:33:10 <Zamarok> What is the most concise way to write code that adds c to (a, b) ?
11:33:12 <lpsmith> I'd have use for looking up strings by prefix
11:33:12 <mm_freak> cheater_: i don't think so
11:33:21 <mm_freak> cheater_: application has the highest operator priority
11:33:40 <Zamarok> making (a, b, c)
11:33:51 <mauke> kmc: do you german?
11:33:58 <mm_freak> cheater_: although you can define this:  a <> f b c d e = f a b c d e
11:34:06 <kmc> mauke, nein
11:34:09 <arcatan> Kanisterschleife: keyRelease and keyPress are both variables - any value of evType will bind to the first one.
11:34:50 <startling> have any of you used llvm-py?
11:34:56 <nand`> :t uncurry (,,) -- Zamarok
11:34:56 <lambdabot> forall a b c. (a, b) -> c -> (a, b, c)
11:35:03 <lpsmith> mauke, I think you are getting confused with ksf
11:35:12 <mm_freak> it's curious how many python question come up here
11:35:25 <mauke> http://translate.google.de/translate?sl=auto&tl=en&js=n&prev=_t&hl=en&ie=UTF-8&layout=2&eotf=1&u=http%3A%2F%2Fmauke.hopto.org%2Fstuff%2Fpapers%2F1968-gwehenberger-formatted.txt
11:35:28 <mauke> :-D
11:36:22 <mauke> ooh, the poor diagrams
11:36:30 <startling> oh man, wrong window, sorry.
11:37:30 <lpsmith> I ask for help on non-haskell topics semi-regularly in this channel or -blah,  and often get more helpful responses here than in a more topical channel.
11:37:46 <lpsmith> Though usually I ask about non-haskell things in -blah
11:37:49 <Zamarok> nand`: I think that does the opposit of what I want
11:37:57 <Kanisterschleife> arcatan: I don't understand; I want to check whether evType equals keyPress or keyRelease; all three are values of type EventType http://hackage.haskell.org/packages/archive/X11/1.5.0.1/doc/html/src/Graphics-X11-Types.html#keyPress
11:38:10 <Ngevd> Can you do something like:
11:38:15 <Ngevd> type Year = Int
11:38:21 <Ngevd> instance Show Year where
11:38:24 <Ngevd> ?
11:38:35 <nand`> :t flip $ uncurry (,,) -- Zamarok
11:38:35 <lambdabot> forall a a1 b. a -> (a1, b) -> (a1, b, a)
11:38:44 <aristid> Ngevd: newtype might be what you want.
11:38:58 <Ngevd> Thanks
11:38:59 <luite> Ngevd: nope, there is an extension TypeSynonymInstances, but that won't work if there's already an instance
11:39:12 <Saizan> Kanisterschleife: in your case expression you are shadowing the definition of keyPress from the X11 package
11:39:47 <Saizan> Kanisterschleife: because every lowercase identifier in a pattern is considered to be a new fresh variable
11:39:53 <Zamarok> oh.. wow Haskell is awesome
11:40:16 <Saizan> Kanisterschleife: you've to use an explicit comparison function instead, like (==) if the type is an instance of Eq
11:40:45 <mekeor> (how) can i shorten that?:  \x y -> gcd (round x) (round y)
11:41:03 <hpaste> arcatan annotated “grabKey” with “grabKey (annotation)” at http://hpaste.org/57021#a57022
11:41:09 <mekeor> hi funktronic :)
11:41:12 <hpc> mekeor: gcd `on` round
11:41:15 <hpc> :t gcd `on` round
11:41:16 <lambdabot> forall b a. (Integral b, RealFrac a) => a -> a -> b
11:41:18 <mekeor> @src on
11:41:18 <lambdabot> (*) `on` f = \x y -> f x * f y
11:41:22 <hpc> @hoogle on
11:41:22 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:41:22 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
11:41:22 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
11:41:26 <k0ral> hey, process package won't compile: I'm getting the same error as in hackage http://hackage.haskell.org/package/process-1.1.0.0
11:41:35 <hpc> (on is one of my favorite functions)
11:41:36 <funktronic> mekeor: WHO ARE YOU
11:41:39 <k0ral> any clue ?
11:41:47 <mekeor> funktronic: just another haskeller. :)
11:42:09 <mekeor> don't be paranoid/afraid, friend :9
11:42:11 <mekeor> :)
11:42:14 <hpaste> Saizan annotated “grabKey” with “grabKey (annotation)” at http://hpaste.org/57021#a57023
11:42:28 <mekeor> hpc: thank you :)
11:42:50 <hpc> k0ral: http://haskell.1045720.n5.nabble.com/GHC-5449-Build-failure-with-ghc-7-2-1-Missing-or-bad-header-file-runProcess-h-td4756688.html
11:43:14 <kmc> mm_freak, ok, i got -h added.  thanks for your help
11:43:26 <OceanSpray> can somebody explain to me how to typecheck recursive definitions?
11:43:28 <kmc> i'll do a release today, depending on one or two other changes i want to make
11:43:38 <kmc> OceanSpray, did you read _Typing Haskell in Haskell_?
11:43:41 <Saizan> Kanisterschleife: like that http://hpaste.org/57021#a57023
11:43:44 <OceanSpray> kmc, yes
11:43:52 <mm_freak> kmc: you're welcome
11:43:53 <Kanisterschleife> Saizan, arcatan: wow, thank you :-)
11:43:58 <OceanSpray> there was a bit too much haskell-specific stuff mixed in there
11:44:15 <mm_freak> kmc: how is the performance of detrospector?  and why didn't you make a library out of it?
11:44:16 <OceanSpray> which made their explanation rather hard to understand fully
11:44:30 <mm_freak> kmc: performance compared to, say, the markov-chain package
11:44:51 <OceanSpray> I'm looking for a simpler solution, one that assumes only a basic hindley-damas-milner type system
11:44:51 <kmc> the performance is good
11:45:18 <kmc> i don't have numbers though
11:45:36 <kmc> it's vastly less general than the markov-chain library
11:45:53 <kmc> it's specialized for unicode text
11:45:54 <Saizan> OceanSpray: you've to extend the context with the recursive binding, considering its type a monotype
11:46:09 <kmc> mm_freak, if you want to learn more about it, read this article: http://mainisusuallyafunction.blogspot.com/2010/10/tour-of-real-toy-haskell-program-part-1.html
11:46:51 <Saizan> OceanSpray: you'll still do the generalization step after you've done with its body though
11:46:52 <kmc> i didn't make a library because it seemed like more work and was not part of my goals
11:46:54 <bgamari> What values does the type a () b have?
11:47:02 <everythingWorks> is (x:[]) the same as (x:_) ?
11:47:07 <OceanSpray> Saizan, what do you mean by monotype?
11:47:08 <hpc> everythingWorks: no
11:47:17 <kmc> mm_freak, i quite like the 'neolog' mode :D
11:47:20 <bgamari> For instance, in http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/Control-Arrow.html#t:ArrowMonad
11:47:24 <everythingWorks> hpc: no?
11:47:26 <mm_freak> kmc: well, i'm implementing my own markov chain library with some additional features…  one big problem of the pure markov chain approach is that it can't react to context
11:47:27 <hpc> everythingWorks: the first is "list with one element", the second is "list with at least one element"
11:47:29 <k0ral> hpc: oh, thank you
11:47:44 <k0ral> I'm really running out of luck today, always spotting unresolved problems...
11:47:46 <everythingWorks> hpc: oh, sorry me for this stupid mistake, of course, thanks :D
11:47:47 <bgamari> Ooops, never mind
11:48:07 <kmc> detrospector is just a toy, it's not a general purpose implementation of markov chains or anything like that
11:48:15 <hpc> k0ral: you might be able to fix it with a bit of editing; there's a couple of suggested fixes in the thread
11:48:16 <Saizan> OceanSpray: one that's not been generalized / whose type variables won't be replaced with fresh ones when you use the function
11:48:27 <mm_freak> kmc: i see
11:48:59 <k0ral> hpc: how comes there has been no news since 11/11 ?
11:49:07 <kmc> if i were writing it today, i might make a library
11:49:12 <kmc> back then I was less sure of my API design skills
11:49:15 <hpc> k0ral: no clue
11:49:23 <kmc> but anyway it would be a fairly specialized library
11:49:39 <lpsmith> I've grown less sure of my API design skills over time.
11:49:51 <lpsmith> Maybe it's just that I worry about it too much.
11:50:15 <hpc> lpsmith: the way i design an API is to think "what do i want programs that use this to look like?"
11:50:21 <OceanSpray> Saizan, okay I think I get what you're saying
11:50:23 <k0ral> hpc: the fixes aren't valid for process package
11:50:26 <lpsmith> Yeah, I try to do that too
11:50:42 <lpsmith> I still usually am better at improving existing APIs,  assuming they aren't a total mess
11:51:12 <Saizan> OceanSpray: oh a simpler way to put it: as if it was a lambda bound variable
11:51:14 <cheater_> mm_freak: why don't you make the output of the markov chain a context-aware function?
11:51:27 <cheater_> rather than just a boring string.
11:52:22 <OceanSpray> Saizan, so I typecheck as if I'm typechecking a function with extra parameters that represent the recursively appearing names,
11:52:33 <startling> do any of you folks use happy? it seems hopelessly broken. None of the examples I can find work; they all just give `Parse error` on the last line.
11:52:43 <OceanSpray> and afterwards, I unify the constraints
11:53:03 <hpc> startling: i think parsec is more popular for parsing than parser generators in haskell
11:53:39 <hpc> (if you are trying to learn general parsing in haskell)
11:53:57 <startling> hpc: yeah, but parsec just leaves me a in a muddled mess about grammar rules. yacc-style things are a little more intuitive to me, bizarrely enough.
11:54:03 <cheater_> what do you mean by "parser generators in haskell"?
11:54:12 <Saizan> OceanSpray: yeah, one of those contraints will equate the type of the function with the one ofthe extra parameter
11:54:29 <Saizan> OceanSpray: once you've solved that you can do the usual let generalization
11:54:59 * mekeor just discovered "fix" and is fascinated. "fix" is really powerful.
11:55:05 <startling> eh, maybe I'll try parsec with a lexer.
11:55:11 <Saizan> OceanSpray: do you know prolog?
11:55:23 <hpc> OceanSpray: one way to typecheck recursive functions is to postulate fix :: (a -> a) -> a, then typecheck rec args = fix $ \rec -> body
11:55:48 <everythingWorks> Why this works: l (_:xs) = ... but l (xs:_) wont?
11:55:58 <Sgeo> > fix (\fact n -> if n == 0 then 1 else n * fact (n - 1)) 5
11:55:59 <lambdabot>   120
11:56:14 <OceanSpray> Saizan, no
11:56:19 <hpc> everythingWorks: in the second example, "xs" is a single element of the list
11:56:24 <Sgeo> in (x:xs), x is just one element.
11:56:24 <cheater_> everythingWorks: because lists may be infinite.
11:56:30 <hpc> so your function doesn't typecheck, or whatever
11:56:55 <monochrom> why would you even mutate your program from l (_:xs) to l (xs:_)?
11:56:56 <Sgeo> cheater_, how is that in any way relevant?
11:56:57 <hpc> it would be easier to give a more exact answer with the definition of l
11:56:59 <everythingWorks> hpc: and in the first xs is the entire list but the first element?
11:57:00 <hpc> @where hpaste
11:57:00 <lambdabot> http://hpaste.org/
11:57:02 <rwbarton> l (xs:_) does "work", of course, it just apparently doesn't mean what you think it does.
11:57:07 <hpc> everythingWorks: indeed
11:57:10 <cheater_> Sgeo: reminds him why : is not symmetric
11:57:27 <elliott> You can have infinite structures built out of a symmetric (:).
11:57:30 <cheater_> you can't reliably get "the end" of a list.
11:57:39 <Sgeo> The equivalent is also not symmetric in languages that don't have infinite lists
11:57:41 <cheater_> you can have a lot. you don't.
11:58:01 <nand`> > let l (xs:_) = xs in l "foo"
11:58:01 <lambdabot>   'f'
11:58:03 <cheater_> Sgeo: what are you getting at?
11:58:08 <nand`> > let l (_:xs) = xs in l "foo"
11:58:09 <lambdabot>   "oo"
11:58:24 <hpc> @src head
11:58:24 <lambdabot> head (x:_) = x
11:58:24 <lambdabot> head []    = undefined
11:58:27 <hpc> @src tail
11:58:27 <lambdabot> tail (_:xs) = xs
11:58:27 <lambdabot> tail []     = undefined
11:58:47 <everythingWorks> thanks :D
11:59:00 <kmc> mm_freak, i just ran some tests, I'm generating text from a 5-char history chain at about 420 kB/s
11:59:01 <Sgeo> cheater_, that infinite lists is not the reason for that
11:59:15 <kmc> (it's utf8, mostly ASCII characters, so that's about the same number of chars/s)
11:59:23 <mm_freak> cheater_: not sure what you mean
11:59:24 <Sgeo> Although I guess you could argue from the point of view of lists of unknown length. But that's not infinite
11:59:38 <kmc> this is much faster than I've ever needed for any purpose
11:59:41 <mm_freak> kmc: sounds reasonable
11:59:44 <cheater_> Sgeo: not the direct reason, but one way to remind yourself.
11:59:52 <nand`> cheater_: s/because/keep in mind/
11:59:54 <mm_freak> kmc: i found that IntervalMap is very useful for randomly selecting the next character
11:59:58 <kmc> though I'm sure one could do it much faster than that
12:00:02 <kmc> cool
12:00:10 <kmc> that makes sense
12:00:33 <kmc> i could switch to an approach like this: http://blog.sigfpe.com/2012/01/lossless-decompression-and-generation.html
12:01:01 <hpc> @hoogle IntervalMap
12:01:01 <lambdabot> No results found
12:01:53 <mm_freak> kmc: with the IntervalMap you actually save integer probabilities like:  [3, 1, 2]
12:02:23 <mm_freak> then you make an interval [0, 3) for the first character, [3, 4) for the second, [4, 6) for the third
12:02:27 <kmc> *nod*
12:02:31 <kmc> what I'm doing now is also integer-based
12:02:33 <Ngevd> The existence of otherwise annoys me because I feel obliged to use it in guards when True is shorter and just as good
12:02:46 <mm_freak> finally you just generate a random number in the interval [0, 6) and pick the corresponding element from the IntervalMap
12:02:52 <mm_freak> that seems very fast
12:02:59 <hpc> Ngevd: otherwise is the best "keyword" ever :P
12:03:07 <monochrom> use True then
12:03:17 <mm_freak> Ngevd: you don't need to
12:03:21 <mm_freak> f x y | … = …
12:03:23 <mm_freak> f x y = …
12:03:23 <Ngevd> But True turns green!
12:03:30 <kmc> mm_freak, I'm doing something similar with 'split' on an IntMap
12:03:50 <mm_freak> kmc: yeah, i thought about that, but that needs two operations:  one split and one maxView
12:03:53 <kmc> mm_freak, http://mainisusuallyafunction.blogspot.com/2010/10/tour-of-real-toy-haskell-program-part-2.html#representing-distributions
12:03:58 <mm_freak> with the IntervalMap you need only one lookup
12:04:03 <everythingWorks> Im currently getting 2 warnings about non-exhaustive pattern matches, but i can't figure out what it really means. Maybe you can keep me in the right direction: http://ideone.com/Mrtto
12:04:37 <hpc> everythingWorks: in 'head', what happens when you pass an empty list?
12:04:53 <hpc> everythingWorks: and in length2', what happens when you pass a list with length > 1
12:04:53 <monochrom> the first one is normal. you don't have a story for empty lists
12:04:56 <elliott> Ngevd: otherwise is nicer than True anyway.
12:04:56 <mm_freak> everythingWorks: also:  tail [x] = []
12:05:02 <elliott> Unless you're golfing.
12:05:17 <everythingWorks> hpc: head' solved :D
12:05:44 <monochrom> the second one is a real omission. what happens to lists like 3:(1:(4:[]))?
12:05:59 <Sgeo> Erlang just uses true for that
12:06:08 <Sgeo> No otherwise there
12:06:10 <Sgeo> >.>
12:06:12 <hpc> everythingWorks: hint: [a, b, c] = (a:b:c:[])
12:06:25 <elliott> = (a:(b:(c:[])))
12:07:42 <monochrom> pattern [x] matches values like [1], [True] only.
12:07:57 <dolio> > otherwise
12:07:58 <lambdabot>   True
12:08:02 <monochrom> does not match [True, False]
12:08:05 <tromp> >return  'h':'a':succ 'k'
12:08:17 <hpc> > let f [x] = x in f [True]
12:08:17 <lambdabot>   True
12:08:21 <hpc> > let f (x) = x in f [True]
12:08:21 <lambdabot>   [True]
12:08:29 <tromp> >return  $  'h':'a':succ 'k'
12:08:38 <tromp> > return  $  'h':'a':succ 'k'
12:08:38 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:08:38 <lambdabot>         against inferred ty...
12:09:02 <tromp> >  'h':'a':return 'k'
12:09:03 <lambdabot>   "hak"
12:09:13 <c_wraith> :t (:)
12:09:14 <lambdabot> forall a. a -> [a] -> [a]
12:09:28 <c_wraith> notice that the first argument to : is a single item, the second argument is a list
12:10:25 <mm_freak> i prefer not to write a pattern for the "otherwise" case, where possible
12:10:31 <mm_freak> uhm
12:10:31 <everythingWorks> k, thanks! :)
12:10:33 <mm_freak> not a guard i mean
12:10:41 <mm_freak> i write a new pattern instead =)
12:10:50 <hpc> everythingWorks: http://ideone.com/wKbiX -- SPOILERS
12:11:26 <everythingWorks> hpc: yep, i actually used (_:xs) :D
12:11:31 <monochrom> http://www.vex.net/~trebla/tmp/f.hs
12:12:15 <Ngevd> Can anyone recommend a GUI thingy for making probgrams with GUIs?
12:12:35 <hpc> Ngevd: gvim :P
12:12:35 <Ngevd> Library
12:12:44 <hpc> oh, library :D
12:13:10 <c_wraith> gtk2hs?
12:13:18 <c_wraith> sdl?
12:13:22 <c_wraith> what sort of gui?
12:13:41 <Ngevd> I dunno
12:14:00 <c_wraith> well, those two libraries have very different purposes.
12:14:09 <c_wraith> you probably mean something like gtk2hs
12:14:26 <c_wraith> but now that I've said that, you'll mention a game idea. :)
12:14:34 <hpc> haha
12:14:55 <hpc> Ngevd: if you want buttons and textboxes and shit, gtk2hs would be ideal
12:15:02 * Sgeo is vaguely aware of Glade
12:15:03 <Ngevd> Yes, that is what I want
12:18:03 <clsmith> does anyone know the name, or some resource, which talks about how you can distinguish what can be code and what must be data when compiling some typed lambda calculus? i'm kinda grasping at straws, but there has to be some kind of thing about this :/
12:19:05 <clsmith> something about constructors / destructors or so maybe
12:21:45 <CodeWeaver> Okay, anybody tried to get gtk installed via cabal?  I keep running into this:
12:21:45 <CodeWeaver> pkg-config package glib-2.0 is required
12:21:45 <CodeWeaver> but I can't figure out how to get that library.
12:22:04 <dylukes> What OS are you on?
12:22:08 <CodeWeaver> OSx
12:22:16 <scooty-puff> do you have fink or macports?
12:22:17 <dylukes> Do you have homebrew (or macports) installed?
12:22:19 <CodeWeaver> ports
12:22:25 <dylukes> port install glib
12:22:31 <CodeWeaver> Did that.  Didn't work.
12:22:33 <mkscrg> i need a balanced tree implementation like Data.Map, but which provides access to the tree structure. is this available or do i need to write it?
12:22:33 <dylukes> and gtk+
12:22:40 <CodeWeaver> port glib not found.
12:22:49 <CodeWeaver> Tried glib2 and that was found but didn't solve the problem.
12:23:01 <Ngevd> Doesn't work on Windows either
12:23:02 <dylukes> Try glib1
12:23:03 <dylukes> :)
12:23:08 <scooty-puff> mkscrg: not sure how good template haskell is at subverting encapsulation, maybe mess with that?
12:23:13 <CodeWeaver> It can't be THAT easy, dylukes.
12:23:16 <dylukes> CodeWeaver: Try it.
12:23:18 <dylukes> :)
12:23:28 <CodeWeaver> Its started building.
12:23:31 <CodeWeaver> If this works I'll eat my hat.
12:23:39 <dylukes> Pics or it didn't happen.
12:23:41 <CodeWeaver> Also I'll hang my head in shame for not thinking o that.
12:23:50 <dylukes> ;P
12:23:58 <dylukes> It's okay, I just checed the macports website.
12:24:05 <dylukes> I wouldn't have guessed myself otherwise.
12:24:24 <elliott> Er, glib is on version 2, for what it's worth.
12:24:34 <Ngevd> cabal: Error: some packages failed to install:
12:24:39 <CodeWeaver> v1 is apparently what I need for some projects.
12:24:58 <Ngevd> glib-0.12.2 failed during the configure step. The exception was:
12:25:00 <clsmith> a less vague question: can anyone recommend any papers on abstract interpretation?
12:25:05 <Ngevd> ExitFailure 1
12:25:22 <CodeWeaver> Okay, where's my hat....
12:25:59 <dylukes> CodeWeaver: ;D
12:26:05 <CodeWeaver> punk. :D
12:26:08 <CodeWeaver> Also thanks.
12:26:09 <otters> can pointless not handle case statements
12:26:12 <dylukes> elliott raises a good point though.
12:26:21 <dylukes> It may fail.
12:26:23 <dylukes> Perhaps the cabal package should be amended to check for glib2.
12:26:36 <dylukes> So on my list of smart things I've done today:
12:26:45 <dylukes> I overwrote the OS X system C++ :D
12:26:51 <sm>  woo
12:26:53 <dylukes> Deleted that /usr/bin/include/c++/v1
12:27:04 <dylukes> replaced it with top of trunk libc++.
12:27:15 <dylukes> (same for /usr/bin/lib/libc++.1.dylib and friends)
12:27:47 <mekeor> why is 'head []' not defined as '[]' ?
12:27:55 <clsmith> type error
12:27:57 <dylukes> Because [] doesn't have a head.
12:28:09 <CodeWeaver> unoff with 'is unhead!
12:28:10 <mekeor> clsmith: oh, of course, yes hehe
12:28:27 <dylukes> clsmith: It's a runtime error, not a type error.
12:28:32 <kmc> damn it, why did i have to write this code all clever-like
12:28:37 <kmc> now i can't modify it without getting confused
12:28:40 <dylukes> You need dependent types and length observed lists to make it a type error.
12:28:44 <dylukes> kmc: Can I see :D?
12:28:45 <clsmith> dylukes: head [] = [] would be a type error
12:28:49 <mekeor> dylukes: he wanted to say that "head [] = []" would be…
12:28:55 <dylukes> ah... well yeah. true.
12:28:59 <dylukes> :P
12:29:04 <mekeor> :)
12:29:15 <dylukes> That's ONE way to look at it >.>
12:29:26 <dylukes> The other is to throw dependent types at it until it works.
12:31:59 <rasfar> Is it possible to obtain the RHS of a data declaration from the type name? I'm trying to chase recursive types programmatically. Do I need TH?
12:32:47 <elliott> TH or GHC Generics or syb
12:33:21 <parcs`> :t (take 1, listToMaybe)
12:33:22 <lambdabot> forall a a1. ([a] -> [a], [a1] -> Maybe a1)
12:34:32 <kmc> dylukes, it's not that interesting, it's just like three nested folds
12:34:34 <rasfar> So I have options it seems...  I tried Data.Typeable and Data.Data (that's syb right?) but I need to provide completely-applied data constructors at each step, which was defeating my purpose.
12:34:43 <kmc> which we say is good Haskell style
12:34:48 <dylukes> kmc: what?
12:34:52 <rasfar> Would you recomment TH over GHC Generics for this sort of this.  (Thanks elliott btw.)
12:34:55 <kmc> but now my brain is folded in knots
12:35:07 <dylukes> Go read some oleg.
12:35:09 <kmc> because I last worked on this code a year and a half ago
12:35:24 <kmc> whereas I think a less clever solution of explicit recursion would have been obvious immediately
12:35:32 <dylukes> http://okmij.org/ftp/Algorithms.html#dyn-epistemology
12:35:46 <kmc> what?
12:35:53 <kmc> what does that have to do with anything
12:35:58 <dylukes> "How to zip folds: A library of fold transformers (streams)"
12:36:07 <dylukes> Sorry, scroll down.
12:36:20 <clsmith> i assume listToMaybe can cause a runtime error?
12:36:31 <dylukes> clsmith: why would you assume that?
12:36:53 <clsmith> lists of 2+ members? does it just drop 'em or something?
12:37:01 <kmc> > listToMaybe "xyz"
12:37:02 <lambdabot>   Just 'x'
12:37:08 <dylukes> yeah, it returns Just head
12:37:11 <dylukes> or Nothing
12:37:15 <dylukes> if it's []
12:37:20 <dylukes> @src listToMaybe
12:37:20 <lambdabot> listToMaybe []        =  Nothing
12:37:20 <lambdabot> listToMaybe (a:_)     =  Just a
12:37:21 <clsmith> oh, that's weird, but fair enough
12:37:22 <dylukes> :|
12:37:24 <rasfar> Alright TH it is...
12:37:30 <clsmith> i'd call that safeHead or something :p
12:37:41 <clsmith> i swear runtime errors should be illegal, unless explicitly errored by the programmer...
12:38:32 <clsmith> so the compiler would either check that it's impossible for xs in head xs to be [], or else require the programmer to handle either case
12:38:56 <kmc> dylukes, I'm not sure what makes you think that oleg paper is relevant, given the little information i've given you
12:39:03 <dylukes> kmc: It involves folds.
12:39:04 <clsmith> (or at least warn you, i guess. not knowing just makes me uneasy.)
12:39:06 <dylukes> And Oleg is magic.
12:39:09 <kmc> oh wow some haskell code involving folds
12:39:15 <dylukes> It might confuse you so much,
12:39:22 <dylukes> you suddenly understand your own code.
12:39:33 <dylukes> Haskell code rarely involves folds kmc.
12:39:34 <dylukes> Don't be silly.
12:39:42 <Ralith> clsmith: that's dependent typing
12:39:46 <kmc> dylukes you're annoying me right now, although I can't precisely explain why
12:40:02 <dylukes> You're probably just frustrated with your code.
12:40:03 <dylukes> Sorry mate.
12:40:08 <clsmith> Ralith: no it isn't
12:40:17 <NothingMan65> Drama!
12:40:18 <clsmith> Ralith: well, it kind of is i guess
12:40:24 <Ralith> by definition :P
12:40:41 <clsmith> Ralith: well, the compiler checking would be dependent typing
12:40:44 <kmc> dylukes, it's a #haskell trope to make a wild guess about what someone's problem is, then send them some incomprehensible gibberish paper
12:40:49 <Ralith> that's what I was referring to.
12:40:51 <dylukes> kmc: :)
12:40:54 <clsmith> Ralith: the compiler just refusing to handle any possible runtime error wouldn't
12:40:58 <kmc> as it happens I'm not really asking for advice with my folds
12:41:02 <Ralith> I'm not sure what you mean by that
12:41:07 <dylukes> I know, it wasn't in earnest anyways.
12:41:10 <kmc> yeah
12:41:11 <dylukes> I have no idea what that paper is about.
12:41:24 <dylukes> I just pulled it out of my ass/okmji.org
12:42:39 <CodeWeaver> Here's a question.  If I wanted to map two lists together, or fold them, I guess, in a manner such that either one of them or the other of them (or both?) were consumed to produce elements lazily in a new list, what might be a good approach?  A specific case might be the 'merge' operation in 'mergesort'.  I resorted to explicit recursion.
12:43:25 <clsmith> CodeWeaver: do you mean zip / zipWith?
12:43:35 <CodeWeaver> The problem with that is it brings the elements in in pairs.
12:43:40 <dylukes> CodeWeaver: can you give an example?
12:43:44 <CodeWeaver> That means both would be consumed at the same rate.
12:43:55 <clsmith> oh! i see what you want
12:44:17 <CodeWeaver> Like I said, the standard 'merge' operation of merging two sorted lists into one sorted list, is a good example of a more general sort of 'map'/'fold' problem involving more than one input.
12:44:33 <monochrom> "merge" is a peculiar consumer and is better off written afresh
12:44:56 <CodeWeaver> Sure.  Just wondering what approaches others might use other than the trivial manually recursive solution.
12:45:18 <clsmith> i think he just wants to be able to 'pull' items from one or other of these lists, depending on what comes out
12:45:39 <CodeWeaver> Essentially.  Lazy potentially infinite lists in, lazy potentially infinite list out.
12:45:54 <CodeWeaver> But where the input lists are not necessarily consumed at the same rate.
12:46:21 <clsmith> CodeWeaver: i'd just have a function with like, merge (x:xs) (y:ys) | x == y = merge xs ys | x < y = x : merge xs (y:ys) or whatever
12:46:22 <CodeWeaver> I think I have enough skill to write a generalized sort of function for these kinds of partial zip maps.
12:46:36 <tempire> haskell n00b just finished reading learnyouahaskell.  next step: web framework.  recommendations for which one a beginner to start with?
12:46:38 <CodeWeaver> I see.
12:46:39 <elliott> CodeWeaver: I'm not sure that recursion has enough guiding structure to be reasonably abstractable.
12:46:48 <elliott> tempire: the popular ones are snap, yesod and happstack
12:47:27 <dylukes> tempire: Unlike most languages web frameworks, keep in mind,
12:47:31 <CodeWeaver> maybe not, Elliot, but you could maybe have a function passed in that takes in both input elements and produces a result that says which stream to advance.  Its *sort* of an unfoldr I guess.
12:47:31 <kmc> any opinions on 'hashmap' vs 'unordered-containers'?
12:47:34 <dylukes> Haskell's can mostly be mixed and matched.
12:47:43 <kmc> dylukes, that's very common in other languages too
12:47:47 <dylukes> kmc: a hashmap is an implementation, an unordered container is a type of interface?
12:48:00 <kmc> dylukes, I'm referring to two hackage packages with those names
12:48:03 <kmc> it seems like the latter is getting more love
12:48:08 <dylukes> like, a hashmap is a way to implement an unordered-container.
12:48:10 <kmc> and will some day do hash-array mapped tries
12:48:12 <c_wraith> @hackage hashmap
12:48:13 <lambdabot> http://hackage.haskell.org/package/hashmap
12:48:19 <dylukes> (though, there are many ways to implement hashmaps :P)
12:48:32 <tempire> oh, snap has the prettiest website
12:48:33 <tempire> sold!
12:48:39 <c_wraith> kmc: I think unordered-containers is officially a successor to hashmap
12:49:04 <c_wraith> as in, tibbe started with Milan's work, and improved it
12:49:13 <kmc> ok, that was my impression too
12:49:31 <kmc> unordered-containers is already a little faster in my use case, but I expect it to improve more than the other
12:49:36 <kmc> the API is nicer in some ways and less nice in others
12:50:30 <dylukes> At least tempire is honest about his decision making process.
12:50:35 <dylukes> :P
12:50:52 <donri> he's not the first to base it on the website design
12:51:02 <donri> personally i like the simplicity of the happstack site :)
12:51:08 <c_wraith> tempire: by the way, #snapframework is semi-active, and a good place to ask snap-specific questions.
12:51:28 <tempire> dylukes: truth.  ease of accessibility.  I reserve the right to change my mind once my pallet for haskell is more developed.
12:51:36 <kmc> dylukes, for example Pylons is one of the most popular Python "frameworks", and it describes itself as "A lightweight framework that allows several database, templating, user interface, and dispatch options."
12:51:44 <clsmith> one could suggest that since it's a web framework, the best website is by the best, and therefore most experienced (?) web developer, and therefore the best framework developer. <.<
12:51:48 <kmc> it's very common to mix and match these pieces, in any language
12:51:54 <dylukes> kmc: true true.
12:53:02 <clsmith> is there a haskell lib which just handles http & dispatch?
12:53:15 <donri> wai?
12:53:15 <c_wraith> several
12:53:19 <rpglover64> I'm using phantom types and I'm trying to derive Ord. Halp.
12:53:23 <elliott> WAI + some routing lib?
12:53:36 <rpglover64> (Coming up with minimal example now)
12:53:53 <c_wraith> I mean, if you ignore the snaplet stuff, the minimal use of Snap is really just http + dispatching
12:53:57 <stepkut> clsmith: so, one could become the best web framework by simplying hiring the best graphic designer?
12:54:12 <clsmith> stepkut: shhh
12:54:13 <c_wraith> stepkut: indubiably
12:54:17 <clsmith> hmm, WAI looks okay
12:54:52 <donri> well, http://denied.immersedcode.org/ was an april's fools and got a lot of people excited
12:55:19 <elliott> WAI is what Warp is based on
12:55:33 <clsmith> i was thinking of something like Webmachine
12:55:47 <AndroUser> When is ghc 7.4 scheduled to be released?
12:56:30 <c_wraith> AndroUser: when the bugs are all fixed. It's currently in release candidates
12:56:42 <kmc> i'm giving up on understanding my rat's nest of folds, and am modifying the code by a purely mechanical equational reasoning
12:56:47 <kmc> this seems like both a success and a failure
12:56:53 <CodeWeaver> I tried building 7.4 from 7.2.2 on OSX.  Got divide by zero error in haddock somewhere.  Submitted a bug report.
12:57:01 <CodeWeaver> Hopefully they fix that. ;)
12:57:05 <elliott> c_wraith: All the bugs?
12:57:11 <kmc> GHC on OS X is often fucked
12:57:13 <c_wraith> *all* the bugs
12:57:15 <clsmith> all the bugs. it will be *flawless*
12:57:25 <elliott> I guess it'll come out on December 21st, then.
12:57:29 <kmc> haha
12:57:31 <kmc> elliott++
12:57:34 <CodeWeaver> kmc: That may be true, but I like to try to help out.   I just wish I was remotely capable of going in there and fixing it myself.
12:59:00 <alkoma> i am trying to install Cabal on a freebsd machine, and got this: dependencies are missing: base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.5
12:59:17 <hpaste> “Alex R” pasted “Phantom Types deriving” at http://hpaste.org/57026
12:59:31 <alkoma> the dependencies for base look messed up
13:00:14 <rpglover64> Any suggestions?
13:01:08 <alkoma> I have ghc-7.2.2 on the machine and it comes with base-4.4.1 and unix-2.5  -  any suggestion how to get the install going?
13:01:30 <CodeWeaver> Monkeying with the .cabal dependencies and hoping?
13:01:40 <CodeWeaver> I'm doing that to get a project to build, but htere's no guarantee it'll work
13:02:11 <monochrom> alkoma: http://is.gd/LXRBhh (all archs not just mac)
13:02:12 <DanBurton> rpglover64: you're "Alex R"?
13:02:16 <rpglover64> yes
13:02:25 <rpglover64> (Sorry; I should have made that clear)
13:02:36 <CodeWeaver> So here's a question of learning…. I consider myself competant enough with Haskell to write any arbitrary program, though obviously not necessarily elegantly… in other words, I can get by with recursion, pattern matching, do-notation, maps, folds, and unfolds, and strictness and laziness don't bother me *too* much.  I can work with monads enough to get sequences of 'actions' performed, in IO, and in at least one case in ST.  While
13:02:39 <CodeWeaver> Sorry for the big text
13:02:44 <DanBurton> why a class? Why not just data Type = Bar | Baz ?
13:03:04 <rpglover64> Cause I want it at the type level and I can't use GHC 7.4
13:03:11 <tommd> CodeWeaver: It cut off after "in ST.  While"
13:03:33 <CodeWeaver> Thanks tommd
13:03:34 <CodeWeaver> While I love learning the academia behind some of this stuff, I'm more of a pragmatic life-long imperative software developer stretching out….. where would the gurus here suggest I advance my learning in Haskell?
13:03:58 <ehuber> try monkeying with yesod or happstack if you like web stuff?
13:04:07 <kmc> CodeWeaver, did you read all of RWH?
13:04:39 <CodeWeaver> I can.  I thought I'd try writing a language parser, or implementing a haskell-based Turtle Graphics package of my own.  I've done similar things in other languages.
13:04:43 <kmc> read RWH, and then think of something you want to make and make it
13:04:49 <kmc> CodeWeaver, http://prog21.dadgum.com/80.html
13:05:00 <mekeor> shouldn't i generally be able to replace "do { foo <- monadicFunc; let bar = func foo; ... }" with "do { let bar = monadicFunc >>= func; ... }" ?
13:05:11 <CodeWeaver> Is that likely to stretch my understanding of the language itself?  Problem is, I can do quite a few things not adding to my language skills at all.
13:05:37 <kmc> RWH covers many things you did not mention
13:05:41 <CodeWeaver> kmc:  What's funny is I've given out that advice before to other budding young programmers I've tutored.  I wonder why its so hard to direct it at myself. :D
13:05:49 <kmc> http://book.realworldhaskell.org/read/
13:06:05 <CodeWeaver> Alright, alright.  You've made your (very good) point.
13:06:09 <CodeWeaver> :D:D
13:06:09 <MostAwesomeDude> Port a library you already wrote in another language into Haskell.
13:06:10 <kmc> foreign function interface, concurrency, parallelism, STM
13:06:22 <MostAwesomeDude> Find something that interests you on Hackage. Contribute a patch to it.
13:06:23 <kmc> these are important things if you want to get work done in haskell
13:06:28 <CodeWeaver> Ooh, I did try a little parallelism.  Got mergesort parallelized.  Classic.
13:06:40 <tommd> How about a network stack?
13:06:46 <CodeWeaver> Also I solved the dining philosopher's problem.
13:06:51 <mekeor> How about my question?
13:06:53 <CodeWeaver> Hilarious fork-stabbiness ensued.
13:06:59 <tommd> The world is dying for a good COPE implementatio on top of tun/tap!
13:07:20 <elliott> mekeor: no
13:07:22 <MostAwesomeDude> mekeor: Not really.
13:07:30 <elliott> mekeor: say monadicFunc :: m a
13:07:34 <mekeor> hm. why not? what didnt i understand ?
13:07:34 <elliott> then foo :: a
13:07:35 <mekeor> okay.
13:07:37 <mekeor> yes
13:07:39 <elliott> say func :: a -> b, then bar :: b
13:07:40 <elliott> but!
13:07:43 <elliott> in your second example
13:07:49 * mekeor listens
13:07:50 <elliott> bar probably doesn't even type
13:07:53 <elliott> :t (>>=)
13:07:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:08:01 <elliott> you probably want "fmap func monadicFunc":
13:08:03 <elliott> :t fmap
13:08:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:08:07 <elliott> since you're running a _pure_ function over the result
13:08:13 <elliott> however, even then it won't work, because it'll be bar :: m b
13:08:18 <elliott> you need the <- to actually extract the value
13:08:25 <elliott> i.e. bar <- fmap func monadicFunc
13:08:28 <mekeor> didn't understand/use fmap/functors yet...
13:08:35 <elliott> mekeor: fmap f m is just m >>= return . f
13:08:54 <mekeor> ah
13:09:05 <kmc> mekeor, you should understand functors before you try to understand monads
13:09:11 <kmc> because a monad is a functor with some extra capabilities
13:09:13 <elliott> basically the problems are that you're using a pure function, but the right hand side of (>>=) is meant to return a monadic value
13:09:24 <elliott> and also that you're binding a pure variable, but it's an action, so you have to use <- to extract a value
13:09:44 <elliott> i agree with kmc though
13:09:54 <mekeor> okay.  thanks anyway :)
13:10:30 <mekeor> are "functors" and "applicative functors" the same?
13:10:34 <kmc> no
13:10:40 <kmc> an applicative functor is a functor with some extra capabilities
13:10:50 <kmc> a monad is an applicative functor with some other extra capabilities
13:10:53 <kmc> read Typeclassopedia
13:10:57 * mekeor shouldn't ask too much questions. he is sorry for that.
13:10:57 <elliott> yeah
13:11:02 <elliott> mekeor: http://www.haskell.org/haskellwiki/Typeclassopedia will help you a lot
13:11:12 <mekeor> alright
13:11:18 <CodeWeaver> Ahahahahahah "Typeclassopedia"
13:11:33 <CodeWeaver> *reads*
13:11:46 <aristid> CodeWeaver: what's so funny about it? oO
13:11:52 <CodeWeaver> I don't know.  Just makes me giggle.
13:11:58 <CodeWeaver> Totally reading it
13:12:49 <kmc> @pl let inc Nothing  = Just 1; inc (Just n) = Just $! (n+1) in inc
13:12:49 <lambdabot> (line 1, column 38):
13:12:49 <lambdabot> unexpected "n"
13:12:49 <lambdabot> expecting operator or ")"
13:13:15 <monochrom> CodeWeaver has found a treasure
13:15:02 <kmc> @pl \n -> Just $! (n+1)
13:15:02 <lambdabot> (Just $!) . (1 +)
13:16:23 <CodeWeaver> CodeWeaver has earned 50 experience points!
13:16:35 <elliott> kmc: hmm, what's that for?
13:16:59 <kmc> goes to IntMap.alter eventually
13:17:04 <elliott> insertWith?
13:17:25 <elliott> insertWith (+) k 1 or such
13:17:34 <elliott> oh, insertWith'
13:18:40 <lpsmith> is there a way to re-build all packages that are automatically findable that depend on a package you upgrade?
13:19:41 <donri> there's --upgrade-dependencies
13:21:14 <elliott> that's dependencies, not dependents
13:21:27 <lpsmith> right
13:22:09 <lpsmith> it'd be really handy to have an --upgrade-dependents,  so that when I recompile some base package I don't have to go through ghc-pkg check and recompile all the broken packages
13:22:38 <elliott> cabal should just reinstall every package whenever you do anything
13:22:40 <elliott> it'd save time
13:22:52 <elliott> since you end up doing it anyway :)
13:22:53 <lpsmith> except that would take a long time
13:23:17 <lpsmith> It should try to not recompile packages that don't need to
13:24:28 <erus`> is there anyway to implement sub types? IE data A = A B C    and D = (all A constructors) and more
13:24:52 <Axman6> not without a wrapper around A
13:25:31 <cheater_> why do you need that wrapper
13:25:39 <Axman6> also thats not really a subtype is it? my understanding of subtypes ois that they are a subset of another type (like data SmallInt = Int(0..64)
13:25:58 <cheater_> he's thinking in terms of subclasses
13:26:09 <elliott> lpsmith: compiling packages already takes a long time :P
13:26:40 <Axman6> elliott: fixing things when cabal breaks takes longer >_<
13:27:19 <dcoutts__> lpsmith: the thing we're working on will mean that installing new versions of packages never breaks existing installed packages
13:28:53 <donri> what is it you're working on?
13:29:12 <elliott> Axman6: See, it wouldn't break if it just reinstalled all your packages from scratch.
13:30:57 <Axman6> i do wish cabal was more smart about upgrading things by default
13:30:57 <lpsmith> dcoutts__,  that would be awesome
13:31:17 <lpsmith> Although I still think such functionality would be useful
13:31:21 <Axman6> dcoutts__: whats the progress of that?
13:32:30 <lpsmith> Also, we need a way to incrementally update hackage.haskell.org/00-index.tar.gz
13:32:52 <bluemonkey>  /join #python
13:33:03 <Axman6> no
13:33:05 <Axman6> >_>
13:35:04 <elliott> bluemonkey: /quit
13:35:30 <donri>  /amsg I'm a COBOL programmer.
13:39:20 <Veinor> dcoutts__: oh man, that'd be great
13:40:00 <rasfar> Once more before I dive into TH:  If I have a type declared
13:40:03 <rasfar> data T = C1 T1 | C2 T2_1 T2_2
13:40:12 <rasfar> I want a function chaseTypes(T) => [[T1],[T2_1,T2_2]] (or chaseTypes("T") => [["T1"],...].  Is TH the best way to go?
13:40:28 <rasfar> If anyone would care to share an implementation of "chaseTypes" that would be sweet...
13:40:30 <dcoutts__> lpsmith: yes, that's independently useful
13:41:01 <dcoutts__> lpsmith: we have a design for incrementally updating the hackage index if you want something to hack on :-)
13:41:38 <lpsmith> dcoutts__,  I wouldn't be able to get around to it for at least 2 months,  but after that,  sure, I would be interested :)
13:41:51 <dcoutts__> Axman6: we have a design (essentially do what nix does, plus some ghc-specific things) and if we're lucky the IHG might agree to pay for some work on it
13:42:08 <Axman6> dcoutts__: sounds excellent =)
13:42:21 <dcoutts__> lpsmith: well I'll undoubtedly have available tasks for you or anyone else now or in two months time :-)
13:43:09 <lpsmith> dcoutts, do you have a link for the design of incremental index updates,  or could you email it to me?   Assuming that nobody else gets to it first,  having it in the back of my mind for a few months would probably help...
13:43:38 <dcoutts__> lpsmith: ah, that reminds me, I need to fix the cabal/hackage trac
13:43:42 <dcoutts__> there's a ticket for it
13:44:05 <donri> yes please do, i have cabal bugs to report and no one is listening on cabal-devel :P
13:44:36 <dcoutts__> lpsmith: the idea is to use HTTP tricks to get the tail of the uncompressed version of the file, and to append only when updating, plus a reliable fallback mechanism in case the whole tar file is rewritten
13:44:37 <elliott> Wouldn't something like an rsync server work as a simple solution to incrementally updating it? I guess that adds an external dependency...
13:45:06 <dcoutts__> elliott: right, that's the problem, windows users don't have rsync, plus it means you can no longer host on a simple dump http server
13:45:25 <gwern> @quote
13:45:25 <lambdabot> FogCreek says: Since throwing away a large code base and starting from scratch is typically a bad idea, the final decision was to have an intern write a compiler to translate a subset of ASP into
13:45:25 <lambdabot> PHP.
13:45:27 <hpaste> erus` pasted “code” at http://hpaste.org/57028
13:45:32 <lpsmith> elliott, that's what I suggested.  I also don't know if rsync manages gzipped files properly;  the gzipping kind of gets in the way of rsync
13:45:41 <erus`> is that a suitable type structure for system F ?
13:45:54 <elliott> lpsmith: well rsync can do compression itself
13:45:55 <erus`> well typed lambda calc with polymorphism
13:46:03 <elliott> dcoutts__: Right. There is zsync, which operates over HTTP.
13:46:16 <elliott> It might be easy to copy its algorithm, although I forget how it goes.
13:46:23 <lpsmith> elliott, right, but I don't know if rsync is smart enough to uncompress-recompress.
13:46:25 <elliott> That works with gzipped files somehow IIRC.
13:46:27 <dcoutts__> it's not a complex one we've got
13:46:36 <dcoutts__> we're not solving the general problem of syncing
13:46:41 <elliott> lpsmith: Why not store the file uncompressed on the server?
13:46:43 <elliott> dcoutts__: right
13:47:02 <dcoutts__> we can simplify by only appending to the index, and the .tar format is designed for appending
13:47:16 <lpsmith> elliott, sure, I'm not saying it's an insurmountable problem :)
13:47:53 <lpsmith> Just one that a naive use of rsync might not handle correctly, that's all.  But I'm not super-familiar with rsync
13:48:06 <dcoutts__> in the usual case we simply get the tail of the .tar file and do a hash check to make sure we've got the whole correct contents
13:48:19 <dcoutts__> if the hash check fails, we GET the entire file from scratch
13:48:36 <dcoutts__> that'd happen if the index got rewritten rather than just appended to
13:49:09 <elliott> (Does cabal-install support --hyperlink-source yet? I forgot if that patch got added or not.)
13:49:30 <rostayob> elliott: I've been waiting for that.
13:49:55 <elliott> There was a patch. I don't know what happened to it.
13:50:35 <dcoutts__> elliott: no, not yet. I've been somewhat reluctant to add ad-hoc flags like this without a scheme for how to do it properly, though perhaps I should just do it and change it later
13:51:00 <elliott> yeah, i appreciate not wanting to cruft up ~/.cabal/config... but source links are *really* useful
13:51:13 <lpsmith> the index is getting big enough that we also need to start consider how to index into it,  so that we can speed up the calculating-dependencies phase
13:51:14 <elliott> (why not just turn on --hyperlink-source unconditionally? :P)
13:51:36 <rostayob> yeah docs and source should be the default
13:51:45 <dcoutts__> elliott: oh yeah, so it's worse since it affects the ~/.cabal/config which is persistent, not just the command line
13:52:01 <elliott> dcoutts__: bah :) why would you ever want to turn off source links?
13:52:19 <dcoutts__> elliott: hscolour is not part of the platform, so many people will not have it installed
13:52:29 <rasfar> chaseTypes("T") = ... ? :) -- probably I should look into reify? sigh
13:52:29 <dcoutts__> and then you get the problem of how to handle the error
13:52:29 <elliott> dcoutts__: --hyperlink-source works without hscolour
13:52:33 <elliott> it just doesn't highlight the sourec
13:52:35 <elliott> *source
13:52:57 <dcoutts__> elliott: oh, is that a new thing in that patch?
13:53:04 <elliott> no, that's how it's always been, no?
13:53:14 <dcoutts__> perhaps I'm misremembering
13:53:35 <elliott> the only downsides I can think of is a few milliseconds of extra processing on top of the seconds haddock takes, and a tiny amount of disk space to store the source code (especially tiny compared to ghc's output...)
13:55:51 <elliott> dcoutts__: hmm, seems you are right
13:56:01 <dcoutts__> my understanding was that it would fail if hscolour was not installed, which is reasonable since if you want it highlighted then but it doesn't and no errors are reported then it's really confusing
13:56:04 <donri> what's the patch do? i already have --hyperlink-source in cabal haddock
13:56:09 <elliott> couldn't cabal-install just depend on hscolour? it's tiny!
13:56:11 <elliott> :p
13:56:17 <elliott> donri: lets you set it for "cabal install"
13:56:20 <dcoutts__> elliott: it's not part of the platform
13:56:38 <dcoutts__> and it's GPL'd iirc, so we'd have to have that licencing discussion
13:56:40 <Nisstyre> Do I want redis, redis-hs, or redis-simple ?
13:56:44 <elliott> oh, so it is
13:56:48 <elliott> annoying
13:57:09 <elliott> although, calling an _external_ program is pretty far from the realms of GPL vio
13:57:14 <donri> can't you do that with --haddock-options?
13:57:26 <Nisstyre> ie: which redis library on hackage is the most useful?
13:57:29 <donri> or cabal install doesn't have that either eh
13:58:06 <dcoutts__> elliott: no but I mean to get it included into the platform so that cabal-install can depend on it, we'd need to agree our platform licensing policy
13:58:23 <donri> --PROG-options=OPTS            give extra options to PROG  # no, cabal install has it
13:58:29 <bgamari> Nisstyre: hedis
13:58:44 <bgamari> Nisstyre: I was really disappointed with the rest of them
13:59:01 <Nisstyre> bgamari: okay, thanks
13:59:02 <bgamari> Nisstyre: hedis has good documentation, is quite complete, and the most haskell-ish of the bunch
13:59:05 <Nisstyre> you saved me a lot of time
13:59:05 <elliott> dcoutts__: ah
13:59:10 <elliott> red tape :(
13:59:41 <donri> Nisstyre: do you have existing data in redis / need interop with existing software?
13:59:48 <donri> Nisstyre: if not, i suggest acid-state instead of redis
13:59:51 <Nisstyre> donri: no, I'm writing something from scratch
13:59:56 <Nisstyre> and I want to use redis to store my data
14:00:12 <donri> why?
14:00:24 <bgamari> donri: I don't think acid-state can compete with redis in terms of performance
14:00:43 <Nisstyre> donri: well, because I don't have much that I want to store, and I want it to be fast
14:00:51 <bgamari> it seems that acid-state is designed to be convenient, not necessarily fast
14:01:09 <donri> uhm, acid-state is all in memory in the same process as your app
14:01:18 <dcoutts__> bgamari: why do you think it couldn't be as fast?
14:01:23 <Nisstyre> I'll look at acid-state as well
14:01:29 <Nisstyre> as long as it stores it in memory it's fine for me
14:01:32 <elliott> donri: What's wrong with using redis?
14:01:45 <bgamari> dcoutts__: The ACID guarantees, perhaps?
14:01:50 <dcoutts__> bgamari: I mean in terms of comparison of their design / approach etc
14:01:54 <bgamari> I must say, I could be completely wrong
14:02:04 <donri> elliott: i didn't say that :)
14:02:08 <elliott> donri: fair enough
14:02:16 <donri> i just like acid-state, and they solve similar problems
14:03:02 <dcoutts__> bgamari: my guess would be that acid-state would be hard to beat for single threaded performance but probably scales less well with large numbers of concurrent clients
14:03:08 <donri> and acid-state does it in the same process, with type safety/pure data structures
14:03:45 <bgamari> dcoutts__: Fair enough. I'll give it a try for my next data-munging task
14:03:50 <donri> plus ixset gives you arbitrary indexing
14:04:00 <dcoutts__> but then you only use acid-state in a single process, so the number of concurrent clients you can serve from a single multi-core box isn't in the same league as many clients all talking to a single redis DB server
14:04:33 <bgamari> donri: Ooh, I hadn't seen ixset before. Very nice
14:04:35 <donri> well, acid-state has a network backend these days
14:04:52 <donri> but no sharding or such
14:04:55 <dcoutts__> donri: oh interesting
14:05:29 <erus`> > 1 :: Int + 2 :: Int
14:05:29 <lambdabot>   <no location info>: parse error on input `::'
14:05:38 <erus`> > (1 :: Int) + (2 :: Int )
14:05:38 <lambdabot>   3
14:05:44 <erus`> :t (1 :: Int) + (2 :: Int )
14:05:44 <lambdabot> Int
14:06:05 <rasfar> \me (spent whole of yesterday mucking around in Data.Typeable and Data.Data with no joy on this problem)
14:06:56 <donri> what problem?
14:07:55 <kallisti> erus`: only one type annotation is required
14:08:00 <kallisti> > (1 :: Int) + 2
14:08:01 <lambdabot>   3
14:08:10 <erus`> kallisti: i thought it would return a Num :|
14:08:12 <kallisti> the type of (+) infers that 2 is Int
14:08:14 <erus`> im eing a doughnut today
14:08:18 <kallisti> :t (+)
14:08:18 <lambdabot> forall a. (Num a) => a -> a -> a
14:08:26 <kallisti> they're all the same a
14:08:40 <erus`> type classes rewrite the term like a forall
14:08:51 <rasfar> donri: getting a function such as "chaseTypes" described above...
14:09:08 <kallisti> erus`: huh?
14:09:10 <rasfar> probably my whole approach is wrong, but must start someplace.
14:09:19 <tibbe> I wish Colloquy had a good way to jump to the messages that someone sent you when you're away. Right now I only know that someone said something but not what.
14:09:37 <cheater_> try /lastlog ?
14:09:39 <kallisti> the typeclass constraint applies to the variable a in the above type. so every a in the type is constrained to be a single type with an instance of Num.
14:09:43 <cheater_> perhaps.
14:09:47 <rasfar> given  data T = C1 T1 | C2 T2_1 T2_2
14:10:09 <erus`> kallisti: a => a   applied to a Bool becomes a Bool -> Bool in the same was a Num => n -> n
14:10:17 <rasfar> I want a function chaseTypes(T) => [[T1],[T2_1,T2_2]] (or chaseTypes("T") => [["T1"],...].  Is TH the best way to go?  Anyone got a one-liner for this?
14:10:24 <erus`> Num n => n *
14:10:39 <elliott> rasfar: What is T1?
14:10:39 <erus`> and i mean a => a becomes a Bool
14:10:47 <kallisti> erus`: erm I don't know what a => a is.
14:10:56 <elliott> rasfar: Actually I should ask a better question.
14:11:00 <rasfar> Say, Int.  Or another alg. datatype.
14:11:01 <elliott> rasfar: What are you trying to accomplish with chaseTypes?
14:11:57 <kallisti> erus`: but yes the type inference algorithm will determine that each of the a's in the type is in fact one concrete type.
14:12:20 <kallisti> erus`: when it's applied, that is.
14:12:24 <erus`> yup
14:12:29 <erus`> i had a brain freeze
14:12:35 <rasfar> Ultimately, I am trying to visualise parse trees.  I use Haskell.Syn.Exts to parse, then I embellish and otherwise transform the tree, then share it with a C graphics frontend.
14:13:14 <rasfar> Each time the grammar changes and I update my system, I have to make onerous manual adjustments.
14:13:31 <kallisti> :t round
14:13:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:13:42 <rasfar> I'm trying to automate.  Another approach is to try to use the source code for haskell-syn-exts directly.
14:13:56 <kallisti> erus`: when you're dealing with numeric conversion in an actual program, usually something like :: Int is going to do anything. instead you usually want fromIntegral to go from Integral to Num, or round/floor/ceiling to go from floating RealFrac to Integrals
14:13:57 <elliott> rasfar: Have you considered SYB?
14:14:04 <elliott> It simplifies AST transformations like that a lot.
14:14:07 <kallisti> erus`: *isn't going to do anything
14:14:16 <elliott> Assuming I understand what you're doing.
14:14:21 <erus`> kallisti: i dont think you understand my issue :)
14:14:25 <rasfar> But basically, starting from the datatype Module, should be able to spit out the whole grammar as declarations.  How hard could that be in Haskell?!
14:14:37 <bgamari> donri: Does IxMap not have a Serialize instance?
14:14:45 <bgamari> donri: Bah, IxSet rather
14:15:03 <bgamari> Ahh, it has a SafeCopy instance
14:15:05 <kallisti> erus`: I wasn't aware there was an issue, I just saw you using :: Int to disambiguate types.
14:15:23 <rasfar> elliott: as said when you mentioned SYB before, is that not Data.Typeable and Data.Data?  Spent all yesterday.  Can do some things, but requires full-applied constructors, which is not going to be convenient...
14:16:00 <elliott> rasfar: It's also Data.Generics.* from the syb package building on top of Data.Data.
14:16:10 <elliott> rasfar: Well, I'm really confused as to what you want. Your question implies you want some kind of reflection mechanism to inspect the type structure of your Haskell program at runtime, but further information says that you're processing /other/ Haskell code at runtime.
14:16:23 <elliott> I'm not sure whether you're mixing layers up or I am :)
14:17:29 <rasfar> Yeah, exactly, I want reflection on Haskell.Syn.Exts in order to build my system.  The system then consumes arbitrary Haskell programs and visualises them.
14:18:00 <rasfar> Data.Generics, I'll look at that too.  Although TH "reify" sounds promising, except that there's something about the type system datatypes not being available at runtime?
14:18:27 <elliott> rasfar: OK. I think it would be easier to figure out what you actually need if it wasn't Haskell at both layers, because I'm still a bit confused as to what layer you want to apply syb at (to analyse your own type or to transform over the Haskell AST types). Can you pretend your program processes C code instead of Haskell so I can understand better? :P
14:18:45 <rasfar> I've rebuilt the system about 4 times now, with version changes of the grammar...  It's a very stressful process, I am trying to get above it...
14:19:03 <kallisti> C visualizer. can't unseen.
14:19:42 <kallisti> erus`: did you have an actual question that I missed somewhere? :P
14:20:39 <kallisti> I was kind of just rambling.
14:21:05 <rasfar> elliott: I wish I could, but if the language wasn't Haskell where would i find the grammar in a form like Haskell.Syn.Exts? :)
14:21:43 <tomprince> elliott rasfar: Is the goal to have a running program, and have it be able to take string like "Control.Monad.forM" and get a representation of it?
14:22:05 <rasfar> I really appreciate the help btw, yesterday was aweful.  I could look at Generics and come back.
14:22:38 <rasfar> I really can't explain more clearly than with my small model datatype; once more:
14:23:01 <rasfar> given  data T = C1 T1 | C2 T2_1 T2_2
14:23:14 <Zamarok> Best way to get the alpha numeric value of a character? As in f 'a' = 1; f 'c' = 2; et cetera
14:23:29 <rasfar> I want a function chaseTypes(T) => [[T1],[T2_1,T2_2]] (or chaseTypes("T") => [["T1"],...].
14:23:38 <rasfar> Something like "reify T" (I know nothing about Template Haskell yet)...
14:23:40 <Zamarok> without pattern matching the whole alphabet lol
14:23:41 <elliott> rasfar: I really don't think that's actually what you want, though :)
14:23:53 <elliott> If you are parsing Haskell source at runtime, you'll want to analyse the AST to extract that information.
14:24:01 <elliott> Or are you parsing... the program's source code itself at runtime?
14:24:09 <rasfar> You are probably right.  Probably, I should rewrite the whole Haskell backend, it is old and super naive.
14:24:20 <elliott> Zamarok: ord c - ord 'a' + 1?
14:24:46 <Jafet> Lots of lol
14:26:00 <Zamarok> actually this: let alphaValue c = ord c - 96
14:26:19 <pdxleif> Heya
14:26:30 <pdxleif> Is there a version of liftM2 or related
14:26:32 <rasfar> At runtime, the program inputs an arbitrary Haskell module, and generates a visualisation.  I want to have the AST types available at each node, in addition to other vis-related data.
14:26:37 <pdxleif> where I can do liftM2 (++) (Just [1]) (Just [5..7])
14:26:59 <Jafet> > liftM2 (++) (Just [1]) (Just [5..7])
14:27:00 <pdxleif> And not have the whole thing be Nothing if one of those Maybies is Nothing?
14:27:01 <lambdabot>   Just [1,5,6,7]
14:27:31 <elliott> Zamarok: :(
14:27:33 <elliott> ord 'a' is nicer.
14:27:34 <rasfar> Maybe it would be best if I think about it more, look at TH a bit and Generics, and come back in a day or two...
14:27:43 <hpc> @src liftM2
14:27:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:27:45 <pdxleif> Same deal as Control.Applicative:  (++> <$> Just [1] <*> Just [5..7]
14:27:47 <elliott> pdxleif: What do you want it to be if one of them is Just?
14:27:52 <elliott> Just that list?
14:28:13 <elliott> > let app xs ys = (++) <$> xs <*> ys <|> xs <|> ys in app (Just [1,2,3]) Nothing
14:28:16 <lambdabot>   Just [1,2,3]
14:28:16 <elliott> that works but is ugly
14:28:18 <elliott> oh wait
14:28:21 <Jafet> That is the Monoid instance
14:28:27 <Jafet> > Nothing ++ Just [1,2,3]
14:28:28 <lambdabot>   Just [1,2,3]
14:28:38 <elliott> caleskell >:|
14:28:43 <elliott> > (Nothing :: Maybe [a]) ++ Nothing
14:28:44 <pdxleif> I have a maybe of a single item, and a maybe of a list, and I want an Maybe of List of whatever I have (combined), or a Nothing if both are empty/None
14:28:44 <lambdabot>   Nothing
14:28:46 <hpc> :t \f x y -> f <$> x <*> y <|> x <|> y
14:28:46 <lambdabot> forall a (f :: * -> *). (Alternative f) => (a -> a -> a) -> f a -> f a -> f a
14:28:47 <Axman6> >>>>>:|
14:28:48 <elliott> pdxleif: Okay, just use `mappend`.
14:28:55 <elliott> Oh.
14:28:56 <Jafet> Failskell?
14:28:58 <elliott> Of a single item?
14:29:01 <elliott> You said (++) :P
14:29:08 <pdxleif> FWIW, I'm actually doing this in Scala...
14:29:15 <elliott> > fmap pure (Just 42) `mappend` Just [1,2,3]
14:29:16 <lambdabot>   Just [42,1,2,3]
14:29:20 <hpc> pdxleif: perhaps you should be asking in #scala
14:29:27 <elliott> pdxleif: Haskell library functions will not help you in Scala...
14:29:39 <pdxleif> Well, most of them seem ported via Scalaz
14:29:42 <rasfar> elliott: I could just add for clarity, this chaseTypes -- I'm applying it to Language.Haskell.Syn.Exts.Module (and then recursively), in order to keep my system up to date with grammar changes in a robust way.
14:29:54 <rasfar> No need for chaseTypes on the inputs to the system for visualisation.
14:30:00 <pdxleif> What if the people in #scala give me an imperative solution?
14:30:08 <elliott> rasfar: Hmm... does haskell-src-exts seriously change its grammar that often?
14:30:13 <rasfar> YES
14:30:16 <elliott> The Haskell syntax is pretty static...
14:30:21 <elliott> And *lots* of packages use haskell-src-exts.
14:30:26 <pdxleif> Maybe I should just use do-notation across the Maybe...
14:30:47 <elliott> rasfar: Anyway, I would suggest trying to use syb on the ASTs themselves to simplify your processing, but you *could* do some kind of freaky TH metaprogramming to generate your code, I suppose.
14:30:49 <rasfar> The grammar changes, but describes basically the same language. :(
14:31:08 <elliott> rasfar: If you've just been using Data.Data, http://hackage.haskell.org/package/syb will make your life a lot easier.
14:31:11 <elliott> e.g. http://hackage.haskell.org/packages/archive/syb/0.3.6/doc/html/Data-Generics-Schemes.html
14:31:33 <rasfar> thanks a bunch, I feel there are some excllent leads there!
14:31:47 <elliott> Hmm, wait, what is Language.Haskell.Syn? Not haskell-src-exts.
14:32:23 * hackagebot redis 0.12 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.12 (AlexanderBogdanov)
14:32:25 <rasfar> To my dismay: I meant "Src" every time I wrote "Syn".
14:32:31 <elliott> Ah :)
14:33:20 <rasfar> (probably I should rewrite the whole backend in TH)
14:34:05 <elliott> I'm honestly not sure what your backend does at all :P
14:34:56 <pantsman> pdxleif, with scalaz you can use ApplicativeBuilder, like some(1) |@| some(List(2, 3)) apply (_ :: _) == Some(List(1, 2, 3))
14:36:03 <rasfar> elliott: lol, join the club!
14:43:38 <ddarius> :t liftA2 (:)
14:43:39 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f [a] -> f [a]
14:44:20 <pdxleif> pantsman: Thanks - that's closer.  But it still has the behaviour of <*> or liftM2 in that if either is None, the whole thing is None
14:45:04 <pdxleif> Maybe I should flatten things down to a list to append, then build back up to Maybe List ...
14:45:12 <elliott> ddarius: That doesn't handlet he "one being Nothing" case.
14:45:18 <pdxleif> Or just use... *gasp* pattern matching.
14:45:26 <elliott> pdxleif: Does scalaz have Monoid?
14:45:43 <pdxleif> Dunno, it has Semigroup
14:45:47 <pantsman> it does
14:45:51 <pdxleif> But I thought mappend isn't defined for Maybe
14:45:52 <elliott> pdxleif: Good enough.
14:45:56 <elliott> Oh.
14:46:01 <pantsman> you could do some(List(1)) |+| some(List(2, 3)) for example
14:46:05 <elliott> Right.
14:46:39 <elliott> Except it's some(1) and some(List(2,3)) so it's fmap pure x |+| y, whatever "fmap pure" is in Scala.
14:46:52 <pantsman> pure is List
14:47:16 <pantsman> or, in scalaz, there is probably an instance of the Pure trait for List
14:47:22 <pdxleif> Yeah, scala seems to be missing a pure/return in general...
14:47:39 <elliott> no return type overloading?
14:47:47 <elliott> such quaint little languages
14:47:55 <pdxleif> No parameterized constructor, or whatever
14:48:04 <pantsman> with scalaz, 1.pure[List]
14:48:17 <elliott> What's fmap?
14:48:21 <pdxleif> pantsman: |+| looks perfect - Thanks!
14:48:30 <pantsman> |+| is mappend basically
14:48:49 <pantsman> well, not basically, it just is
14:49:45 <pdxleif> Huh - didn't know you could mappend two Maybies...
14:49:52 <pdxleif> learn something new every day
14:51:12 <kallisti> mplus as well.
14:51:54 <kallisti> pdxleif: you can only mappend two Maybes if the underlying type has a Monoid instance as well.
14:52:02 <kallisti> mplus however works as a sort of logical disjunction.
14:52:27 <kallisti> > Nothing `mplus` Nothing `mplus` Just 3 `mplus Nothing `mplus` Just 4
14:52:27 <lambdabot>   <no location info>: parse error on input `Nothing'
14:52:39 <kallisti> > Nothing `mplus` Nothing `mplus` Just 3 `mplus` Nothing `mplus` Just 4
14:52:39 <lambdabot>   Just 3
14:53:55 <kallisti> which is useful in situations where you're only concerned with whether or not one of the possible alternatives succeeds. In this case, the MonadPlus instance for Maybe is equivalent to its Alternative instance as well.
14:54:24 <kallisti> (I think that's true of most applicative monads actually..)
14:54:34 <ddarius> :t fmap ((++) . toList)
14:54:34 <lambdabot> Not in scope: `toList'
14:54:41 <ddarius> :t fmap ((++) . Data.Foldable.toList)
14:54:41 <lambdabot> forall (t :: * -> *) a (f :: * -> *). (Data.Foldable.Foldable t, Functor f) => f (t a) -> f ([a] -> [a])
14:55:17 <ddarius> :t fmap . (++) . Data.Foldable.toList
14:55:18 <lambdabot> forall (f :: * -> *) (t :: * -> *) a. (Functor f, Data.Foldable.Foldable t) => t a -> f [a] -> f [a]
14:57:26 <pantsman> elliott, fmap pure x |+| y would be something like: (x map (_.pure[List])) |+| some(y)
14:57:29 <pantsman> so, a bit boilerplatey
14:57:41 <pantsman> err, s/some(y)/y/
14:57:53 <pantsman> where x = some(1) and y = some(List(2, 3)) I mean
14:58:01 <erus`> @hoogle const
14:58:01 <lambdabot> Prelude const :: a -> b -> a
14:58:01 <lambdabot> Data.Function const :: a -> b -> a
14:58:01 <lambdabot> Control.Applicative Const :: a -> Const a b
14:58:32 <elliott> pantsman: wouldn't map (List) work?
14:58:44 <elliott> maybe i misinterpreted you :)
14:58:50 <elliott> (scala is weird. why "some" but "List"?)
14:58:58 <pdxleif> yeah, map (List(_)) would work
14:59:09 <pantsman> elliott, sure
14:59:21 <pantsman> what pdxleif said
14:59:44 <pdxleif> some is just a scalaz helper for Some - uh, a function that wraps the type constructor?
14:59:58 <pantsman> some has a return type of Option instead of Some
15:00:16 <Axman6> what is Some then?
15:00:30 <elliott> a class, I bet
15:00:36 <Axman6> >_____<
15:00:38 <elliott> I think they do "ADTs" with classes
15:00:44 <Axman6> thats horrible
15:00:45 <pdxleif> ADT's are implemented with OO subtyping in Scala
15:01:08 <pantsman> the more specific type of Some causes problems with type inference I guess
15:01:09 <elliott> what's the problem, throwing paradigms at each other and removing parts that look vaguely similar at random is the bset language design process ever
15:01:15 <elliott> *best
15:01:45 <Axman6> sounds like it
15:01:54 <Axman6> i'll stick to haskell nontheless
15:01:55 <hpaste> erus` pasted “Typed lambda calculus type-checker with polymorphism ” at http://hpaste.org/57031
15:02:01 <pdxleif> Think of it as an almost-superset of Java and ML?
15:02:23 <elliott> pdxleif: is that meant to make it sound better?!
15:02:25 <pdxleif> Or ML implemented in Java, or something something...
15:02:57 <pdxleif> Uh... well, if you're porting existing Java or ML-family codebases, you don't have to think about it much.
15:03:14 <pdxleif> Writing new code, maybe you have a few too many choices.
15:03:29 <pantsman> it's better than not having typeclasses and higher-kinded types
15:03:30 <elliott> porting java and ml codebases to a single language? compelling
15:04:38 <cmccann> scala seems more like the cartesian product of haskell and java, the features of both as well as every possible way they can interact in combination
15:05:24 <pantsman> it is what it is... it has crap type inference and all sorts of warts from java interoperability
15:05:56 <pantsman> but, the jvm must still have some allure, or we wouldn't bother
15:05:57 <pdxleif> At my work we have an existing Haskell codebase, which is generally easy enough to port to Scala - then it can share the runtime with with existing Ruby codebases ran on JRuby...
15:06:32 <elliott> someone needs to write an up-to-date haskell/JNI bridge to save these poor porters :)
15:06:48 <pdxleif> I was looking at Frege / OpenQuark
15:07:01 <pdxleif> But those look scary for use in production
15:07:10 <elliott> Nothing sufficiently Haskell-like will run happily on the JVM.
15:07:30 <cmccann> though for what it's worth, implementing algebraic sum types using subtyping is actually "reasonable"--if you take apart the objects and think of them as functions, it amounts to each subclass reifying one branch of the pattern match
15:08:21 <cmccann> I say reasonable with scare quotes because it's far more complicated than it should be to do it that way, like church-encoding all your data types or whatever
15:08:36 <elliott> you could do ADT as an interface exposing a destructor
15:08:39 <cmccann> but it is the correct way to represent it, as far as such things go
15:08:42 <elliott> that's probably more reasonable
15:09:37 <cmccann> the OO approach of using inheritance instead of multi-way conditionals for flow control corresponds pretty closely to using pattern matching instead of conditionals in an ML-style language
15:09:56 <cmccann> there's a sort of duality involved, related to the expression problem
15:10:58 <elliott> I think the solution to the expression problem is to outlaw change.
15:11:16 <cmccann> just outlaw programming
15:11:18 <cmccann> that'll fix it
15:12:25 <etpace> @hoogle (a -> b) -> [a] -> Maybe a
15:12:25 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:12:25 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
15:12:25 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
15:13:15 <sipa> etpace: if you want to outlaw change, write your program in Haskell, compile it to assembly, and distribute the assembly as source code
15:13:22 <sipa> ehm, Eliel
15:13:25 <sipa> ehm, elliott
15:13:44 <elliott> cmccann: or electricity
15:13:48 <elliott> more trouble than it's worth
15:13:51 <cmccann> yes
15:16:20 <Jafet> How can I buy groceries without change?
15:19:55 <ddarius> sipa: That hardly stops change.
15:20:42 <b0fh_ua> Hi all, I have several lists of Strings and I want to use quickcheck in order to generate list of lists with random data from supplied lists. Where do I start?
15:21:06 <b0fh_ua> for example I know how to create Gen String from elements ["a","b","c"] - but what next?
15:27:08 <ddarius> mapM
15:31:01 <b0fh_ua> ddarius: ?
15:31:42 <b0fh_ua> elements [1,2,3] :: Gen Int
15:41:15 <b0fh_ua> weird
15:46:52 <psye> is this real? -> http://adf.ly/50eZt
15:47:10 <maurer> Anyone know how to build statically linked (including libc and libgmp) ?
15:48:13 <parcs`> -static
15:48:22 <parcs`> wait no, -optl-static
15:48:29 <elliott> maurer: -optl-static -optl-lpthread
15:48:59 <elliott> note that glibc can't "fully" statically link but i don't know if ghc uses any of the parts that are dlopen-based
15:49:55 <parcs`> if you build with -threaded you don't need -optl-lpthread
15:50:53 <maurer> elliott: Dumps out _huge_ numbers of errors.
15:51:53 <maurer> Seems that -optl-lpthread didn't work right, because most of them are missing pthreads functions
15:52:13 <MostAwesomeDude> You might need to have the requisite static libraries available.
15:52:26 <parcs`> try with -threaded
15:54:00 <elliott> maurer: oh, -optl-pthread maybe
15:54:05 <maurer> parcs`: Now builds, but on startup loops infinitely with 100%cpu
15:54:05 <elliott> (no l)
15:55:57 <maurer> Wiht -optl-pthread bulid completes, it's static
15:56:05 <maurer> But it loops forever on launch
15:56:10 <maurer> The dynlinked version does not.
15:58:26 <maurer> (and yes, this is still on the same system, so it shouldn't be the dlopen bug)
16:02:24 * hackagebot scope 0.8.0.0 - An interactive renderer for plotting time-series data  http://hackage.haskell.org/package/scope-0.8.0.0 (ConradParker)
16:02:29 <maurer> On tracing it, it appears to just be mmaping new memory in a tight loop
16:04:00 <mm_freak> is there a preferred library for fast arithmetic and factorization of polynomials over GF(p)?
16:07:24 * hackagebot scope-cairo 0.8.0.0 - An interactive renderer for plotting time-series data  http://hackage.haskell.org/package/scope-cairo-0.8.0.0 (ConradParker)
16:07:32 * ddarius chooses p = 2.
16:07:33 <kallisti> mm_freak: http://hackage.haskell.org/package/arithmoi-0.2.0.1  these modules are pretty good
16:07:38 <kallisti> I don't know of others.
16:15:05 <parcs`> > True ()
16:15:05 <lambdabot>   Couldn't match expected type `() -> t'
16:15:05 <lambdabot>         against inferred type `GHC.B...
16:15:21 * dainanaki just used unsafeCoerce, unsafePerformIO, and castPtr willy-nilly.
16:15:26 <parcs`> ah, ghc 7 says "The function `True' is applied to one argument, but its type `Bool' has none"
16:15:35 <parcs`> apparantly everything _is_ a function!
16:16:03 <kallisti> ..
16:16:04 <kallisti> :P
16:19:17 <parcs`> as of ghc 7 anyway
16:19:56 <kallisti> yes ghc 7 employs the new function-oriented paradigm.
16:20:32 <kallisti> suitable for large-scale enterprise solutions.
16:20:44 <sipa> does it compute in the cloud?
16:21:11 <kallisti> yes the entire compiler now has a web app frontend.
16:21:12 <parcs`> it's web scale if that's what you're asking
16:21:26 <sipa> web 3.0 i presume?
16:21:47 <kallisti> Maybe higher. what version are we on now?
16:21:50 <irene-knapp> I suppose this joke is simultaneously too soon and too tired
16:21:56 <irene-knapp> so I guess I won't make it
16:22:11 <dainanaki> I think the web ought to have the same version as GHC
16:22:14 <dainanaki> naturally.
16:22:15 <irene-knapp> haha
16:26:01 <mm_freak> kallisti: uh…  if only i'd have seen that library earlier…
16:26:17 <mm_freak> kallisti: do you know anything about its efficiency?
16:26:36 <kallisti> I know it's designed to be efficient but I don't know how to compares to other factorization techniques.
16:26:40 <kallisti> or what technique it uses, even.
16:26:51 <kallisti> s/to compares/it compares/
16:29:31 <mm_freak> kallisti: it's a useful library and thanks anyway, but it doesn't have what i'm looking for
16:29:39 <mm_freak> i'm looking for polynomial factorization
16:29:46 <mm_freak> not integer factorization
16:30:34 <kallisti> mm_freak: yeah I thought it may be the wrong one.
16:30:43 <kallisti> because you mentioned polynomials
16:31:30 <kallisti> hm I'm not finding anything for polynomials.
16:32:41 <mm_freak> anyway, thanks a lot…  that library saves me a lot of work =)
16:35:53 <mokus_> mm_freak: that's something i've been meaning to add to the polynomials library but haven't yet... if you happen to feel like hacking on one i could include it, but i don't foresee having the time to do it in the near future
16:38:48 <Veinor> @tell kmc have you considered changing shqq so it doesn't have to deal with escaping and instead using System.Posix.Process
16:38:48 <lambdabot> Consider it noted.
16:45:01 <mm_freak> mokus_: i guess i'll do it myself then and just share the code with you…  once you include it in your library, i will just depend on it =)
16:46:20 <mokus_> mm_freak: sounds good
16:47:25 * hackagebot biostockholm 0.2 - Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal).  http://hackage.haskell.org/package/biostockholm-0.2 (FelipeLessa)
16:48:08 <micahjohnston> @type fmap fmap fmap
16:48:09 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:48:14 <micahjohnston> @type fmap fmap fmap fmap fmap fmap fmap
16:48:14 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
16:49:23 <micahjohnston> @type fmap fmap fmap id fmap fmap fmap
16:49:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:49:27 <micahjohnston> cool
16:54:52 <mm_freak> arithmoi gave my library a major speed boost when dealing with primes…  this is great
17:11:21 <jjg> anyone know why I'd be getting a hang/memory leak when compiling with ghc 7.0.4?  It starts linking packages and gets to ffi-1.0 and just hangs and starts consuming a bunch of memory.  I'm on ubuntu 11.10 64bit
17:12:28 <nkpart> Is there a way to specify a minimum required ghc version in a cabal file?
17:13:19 <DanBurton> nkpart: yes I believe so
17:13:24 <elliott> if something I forget
17:13:26 <monochrom> linking takes forever. try the gold linker. one way is to use the ubuntu binutils-gold package. actually, the package doesn't contain the gold linker --- you already have it as /usr/bin/ld.gold --- the package just changes symlink /usr/bin/ld to point to it
17:13:26 <elliott>   buildable: False
17:17:25 * hackagebot zoom-cache 1.2.1.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-1.2.1.0 (ConradParker)
17:18:10 <nkpart> elliott: Thanks
17:18:25 <nkpart> used:  if impl(GHC >= 7.2.1) etc.
17:20:49 <herpladee> Are you fucking kidding me?
17:20:49 <herpladee> risk.nuke?
17:21:54 <dainanaki> huh?
17:22:12 <elliott> herpladee: what
17:27:20 <nyingen> @nuke
17:27:20 <lambdabot> Unknown command, try @list
17:29:00 <herpladee> elliott, uh i have no idea, i was typing that in my browser
17:29:04 <herpladee> somehow it jumped in here
17:29:19 <herpladee> sorry!
17:29:40 <elliott> Don't worry; I can't believe that risk.nuke either.
17:29:48 <herpladee> i know!
17:29:52 <herpladee> unbelievable
17:35:38 <ddarius> The Prisoner's Dilemma was created -after- Nash equilibria?  Really?
17:40:20 <mm_freak> ddarius: is that surprising?
17:41:21 <danlndi> SPJ is like the Tony Robbins of Haskell
17:42:34 <danlndi> I listen to one of his talks and I get the feeling that programming in Haskell is my life's purpose
17:43:11 <ddarius> That's pretty impressive because I don't think Tony Robbins talks about Haskell at all.
17:43:33 <danlndi> I mean I listen to SPJ
17:43:47 <Sgeo> Why is #erlang so DEAD?
17:44:47 <danlndi> it's hard to overstate the impact of good evangelism for the community
17:45:17 <irene-knapp> I could easily overstate the impact of good evangelism for the Haskell community
17:45:31 <irene-knapp> "Bad evangelism for the Haskell community is the leading cause of slow, painful death in North America."
17:45:37 <elliott> ddarius: You clearly don't pay enough attention.
17:45:44 <irene-knapp> "Without good evangelism for the Haskell community, the Allies would have lost WW2."
17:45:52 <irene-knapp> -- credit Dave Barry :)
17:46:43 <tsuraan__> suppose I have the ByteString "\NUL\NUL\NUL\SOH", is it possible to use attoparsec to parse it as a big-endian int32?
17:46:53 <ddarius> elliott: That's one potential interpretation.
17:47:08 <irene-knapp> tsuraan: I can do that without attoparsec, or indeed any library
17:47:09 <irene-knapp> > const 1
17:47:10 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
17:47:10 <lambdabot>    arising from a use of `...
17:47:13 * ddarius returns to reading about game theory experiments.
17:47:13 <elliott> tsuraan__: sure, but http://hackage.haskell.org/package/cereal is probably better
17:47:15 <irene-knapp> > const 1 :: Int32
17:47:16 <lambdabot>   Couldn't match expected type `GHC.Int.Int32'
17:47:16 <lambdabot>         against inferred type ...
17:47:17 <elliott> or some other serialisation library
17:47:20 <elliott> *deserialisation
17:47:24 <irene-knapp> > const 1 :: Int
17:47:24 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:47:24 <lambdabot>         against inferred type ...
17:47:26 <irene-knapp> bah
17:47:28 <Axman6> ...
17:47:33 <irene-knapp> anyway, you get the joke
17:47:35 <Axman6> const takes two argument -_-
17:47:42 <irene-knapp> yes, fine, I realized that :)
17:48:09 <danlndi> irene-knapp: hmmm... I'm not sure overstatement is the same as just making stuff up
17:48:22 <irene-knapp> danldni: welllllll okay, that's fair I suppose
17:48:29 <irene-knapp> but they are statements and they are over the top!
17:48:35 <tsuraan__> elliott: Is there a resumable library like cereal?  that's what I'm using now, and it's a pain because when I have incomplete data, it has to re-parse the entire string (which generally isn't quite a simple as a 32-bit int)
17:49:00 <elliott> tsuraan__: ah. the older binary works with lazy bytestrings, but you'd have to use lazy IO to do resumption with it
17:49:04 <irene-knapp> > const 1 (Data.ByteString.pack "\nul\nul\nul\soh")
17:49:05 <lambdabot>   <no location info>:
17:49:05 <lambdabot>      lexical error in string/character literal at chara...
17:49:08 <irene-knapp> > const 1 (Data.ByteString.pack "\nul\nul\nul\soh") :: Int
17:49:09 <lambdabot>   <no location info>:
17:49:09 <lambdabot>      lexical error in string/character literal at chara...
17:49:25 <elliott> tsuraan__: well, just read 4 bytes and do the arithmetic with attoparsec... it might be slow though
17:49:31 <irene-knapp> > const 1 (Data.ByteString.pack ['\nul', '\nul', '\nul', '\soh'])
17:49:32 <lambdabot>   <no location info>:
17:49:32 <lambdabot>      lexical error in string/character literal at chara...
17:49:36 <elliott> you could read four bytes into something appropriately castable like an array
17:49:42 <elliott> oh, big-endian
17:49:44 <irene-knapp> anyway, yeah, more seriously
17:49:48 <CodeWeaver> Meh, getting a really weird error building gtk. :/
17:50:07 <irene-knapp> you really don't need attoparsec to do this
17:50:13 <tsuraan__> it seems weird that attoparsec doesn't have any parsers for integer types, since it says it's meant for dealing with network protocols and complicated binary formats
17:50:18 <irene-knapp> just use BS.take and BS.unpack
17:50:27 <tsuraan__> I figured I was just missing something :)
17:50:31 <irene-knapp> fair
17:50:47 <Axman6> tsuraan__: you sure there's no getWord32BE in attoparsec like in binary or cereal?
17:51:03 <Axman6> @hoogle getWord32BE
17:51:03 <lambdabot> No results found
17:51:10 <Axman6> @hoogle getWord32
17:51:10 <lambdabot> No results found
17:51:13 <Axman6> hmm
17:51:13 <tsuraan__> Axman6: I figured there would be, but I can't find anything like that
17:51:20 <tsuraan__> I think it's getWord32be
17:51:23 <tsuraan__> @hoogle getWord32be
17:51:23 <lambdabot> No results found
17:51:26 <tsuraan__> heh
17:51:47 <tsuraan__> yeah, I am currently using ByteString.take and cereal, but it's ugly, and attoparsec looks cool
17:51:56 <tsuraan__> well, ByteString.splitAt, really
17:52:26 <elliott> tsuraan__: http://hackage.haskell.org/package/attoparsec-binary
17:52:34 <elliott> dunno if it's up to date with latest attoparsec though
17:53:01 <tsuraan__> oh, perfect
17:53:07 <tsuraan__> I'll give that a shot
17:53:10 <elliott> oh
17:53:13 <elliott> tsuraan__: it doesn't do anything clever
17:53:23 <elliott> just the naive thing
17:53:35 <elliott> also attoparsec seems to have had several 0.x releases since it was last updated
17:54:28 <tsuraan__> I wouldn't be surprised if it still works though; it looks realy simple, like you said
17:54:45 <tsuraan__> I'll see how that compares with what I'm doing
17:54:47 <tsuraan__> thanks!
17:56:37 <CodeWeaver> When building gtk, anybody ever had the error "ghc: could not execute: /Developer/usr/bin/gcc" come out of nowhere?
17:57:03 <hpc> CodeWeaver: sounds like a mac thing
17:57:10 <CodeWeaver> Yes, it is.
17:57:17 <hpc> no clue
18:03:09 <dcoutts__> nkpart: it's typically not necessary to specify a minimum ghc, it's more common to specify minimum library versions
18:03:32 <dcoutts__> you only need it if you're trying to work around some ghc bug, or change in behaviour
18:15:34 <eyebloom> How does one show a single backslash?
18:15:51 <elliott> show howso?
18:16:22 <eyebloom> "\\" + show 2
18:16:29 <hpaste> “Thorsten Lorenz” pasted “Conduit StatusException” at http://hpaste.org/57032
18:16:38 <shachaf> eyebloom: What are you trying to do?
18:17:09 <dainanaki> eyebloom, if you want a string that has a single \, "\\"
18:17:13 <thlorenz> I'm using http conduit to download a png
18:17:13 <eyebloom> Print a lamdba in an embedded expression.
18:17:23 <dainanaki> >"\\"
18:17:31 <thlorenz> and pasted the code here: http://hpaste.org/57032
18:17:52 <thlorenz> unfortunately, I don't seem to be able to catch the status exception
18:18:00 <elliott> > text "\\"
18:18:00 <lambdabot>   \
18:18:02 <eyebloom> "\\" does not work within show
18:18:08 <elliott> "Within" show howso?
18:18:40 <eyebloom> I'd like to show "\x"
18:18:46 <thlorenz> Instead the app crashes with "StatusCodeException (Status {statusCode = 404, statusMessage = "Not Found"}) ..."
18:18:52 <dainanaki> eyebloom, it's already a string...
18:19:04 <thlorenz> what am I doing wrong?
18:19:05 <eyebloom> as in "\\"+show x
18:19:10 <eyebloom> sorry
18:19:16 <eyebloom> "\\" ++ show x
18:19:28 <dainanaki> or, '\\' : show x
18:19:36 <dainanaki> more efficient that way.
18:19:42 <eyebloom> Sure
18:19:45 <elliott> eyebloom: You're doing nothing wrong.
18:19:47 <elliott> What isn't working?
18:20:02 <eyebloom> I get two slashes instead of one.
18:20:08 <shachaf> dainanaki: "more efficient"?
18:20:12 <shachaf> eyebloom: No, you only get one.
18:20:20 <shachaf> eyebloom: It's showing two for the same reason that you're typing two.
18:20:20 <elliott> eyebloom: Are you doing this in GHCi?
18:20:22 <elliott> If you get back
18:20:24 <elliott> "\\foo"i
18:20:30 <shachaf> Try sticking putStrLn in front of it.
18:20:32 <elliott> it's just because ghci shows it in a form you can input
18:20:37 <elliott> shachaf: putStrLn $, specifically/
18:20:43 <elliott> Argh, I can't type right now.
18:20:44 <eyebloom> I see
18:20:44 <dainanaki> shachaf, concatenating lists is O(length n1 + length n2), consing is O(1)
18:20:54 <elliott> dainanaki: n = 1.
18:20:56 <maurer> dainanaki: False.
18:20:58 <ddarius> GHC runs show on it before displaying.
18:21:01 <shachaf> dainanaki: No, it's O(length n1).
18:21:02 <maurer> O(lenth n1)
18:21:05 <shachaf> Which is 1.
18:21:10 <eyebloom> Can stop GHCi from doing that?
18:21:14 <thlorenz> when I point it at a bogus url that doesn't exist at all, I'm able to catch the error, but when the site actually exists and can't find it, the exception falls through
18:21:18 <shachaf> "\\foo"i is what you get in GHCi. If you were using GHC you'd just get "\\foo".
18:21:19 <elliott> eyebloom: Yes, put "putStrLn $" in front to print out the string.
18:21:27 <ddarius> eyebloom: No.  How should it show 1 or a Tree?
18:23:14 <shachaf> supershow :: (Typeable a, Show a) => a -> String; supershow x = case cast x of Just s -> s; Nothing -> show x
18:23:51 <ddarius> fromMaybe (show x) (cast x)
18:24:07 * ddarius leaves running @pl on that as an exercise to the reader.
18:24:25 <maurer> @pl fromMaybe (show x) (cast x)
18:24:25 <lambdabot> fromMaybe (show x) (cast x)
18:24:28 <maurer> Welp.
18:24:48 <shachaf> maurer: You might need to add \x -> in front.
18:24:53 <shachaf> But I don't think it'll work.
18:24:59 <maurer> @pl \x-> fromMaybe (show x) (cast x)
18:24:59 <lambdabot> liftM2 fromMaybe show cast
18:25:43 <shachaf> Oh.
18:25:49 * shachaf was thinking of something else.
18:26:52 <hpaste> “Thorsten Lorenz” annotated “Conduit StatusException” with “Conduit StatusException (annotation)” at http://hpaste.org/57032#a57033
18:27:39 <thlorenz> Can anyone help me with catching the StatusException please?
18:28:37 <ddarius> Player A can choose Up or Down and Player B can choose Left or Right.  If (Up, Right) or (Down, Left) is chosen, Player B gets $2 and Player B gets $1.  If (Down, Right) or (Up, Left) is chosen, Player B gets $2 but Player A gets $1 in the first case and $3 in the second.  What strategy should Player A adopt?
18:29:39 <dainanaki> always choose up?
18:29:53 <ddarius> In the first case, it should be Player A get $2 and Player B gets $1.
18:31:02 * Axman6 needs to draw pictures to figure it out
18:31:19 <elliott> Player A should bribe Player B.
18:31:46 <dainanaki> if player A chooses up each time, player A will always get $2 or $3
18:31:49 <Axman6> "If we play this right, we can both get $2 each turn)
18:31:50 <ddarius> I screwed this up I think.
18:33:13 <CodeWeaver> Isn't this basically the prisoner's dillema?
18:33:28 <CodeWeaver> dilemma.
18:33:31 <CodeWeaver> Can't spell anymore.
18:33:33 <jklvxnasd> do they see each other's move?
18:34:21 <ddarius> Damn, I need to draw this to describe it right.
18:34:30 <byorgey> did anyone else get a message telling them that they needed to confirm their haskell-cafe subscription due to excessive bounces?
18:36:30 <ddarius> Okay, let me try to describe this again correctly.  Player A gets $3 if (Up, Left) is chosen and Player B gets $1.  Player A gets $2 if (Down, Right) is chosen and Player B gets $1.  In the remaining cases, Player A gets $1 and B $2.
18:37:46 <ddarius> They show their moves simultaneously.  The game is played only once.  There is no coordination.
18:43:06 <russellw> ddarius, looks like the optimal strategy is random, where player a chooses up somewhat more than half the time, unless I'm missing something?
18:45:43 <ddarius> russellw: Let's say I changed $3 to $1,000,000.  How much further from 50/50 should it be?
18:48:25 <russellw> I'm too lazy to do exact calculations, but off the top of my head I would say on the order of a million to one
18:49:21 <ddarius> russellw: If I'm Player B and I know that, why would I choose anything other than Right all the time (not out of malice, just because that will get me the $2.)
18:50:40 <dainanaki> because you'd be a dick to do that for two dollars.
18:51:13 <russellw> If I know you are going to do that, I would choose down. So it pays you to at least once in a blue moon go for left, just to put a little bit of uncertainty into it
18:51:35 <russellw> I'm assuming each player is only trying to maximize his own winnings and doesn't care about anything else, based on the no coordination condition
18:52:02 <dainanaki> yeah, sorry, I know my reasoning isn't very mathematical
18:52:17 <mm_freak> i recently read that there are two basic strategies for such games:  the game-theoretic one and the superrational one
18:52:36 <mm_freak> the superrational stragety assumes that the other player will do the same in a symmetric game
18:52:50 <russellw> dainanaki, but you are right of course that if we took it not as a mathematical problem but as a real life problem, you would coordinate and agree to go for the million and share it
18:53:26 <ddarius> russellw: You can remove coordination in real-life.
18:53:48 <russellw> mm_freak, yeah, that was Hofstadter - he's aiming for the right end result, but he's wanting the mathematics to do more than it really will. I think dainanaki's approach is more realistic
18:53:48 <mm_freak> the scenario doesn't allow such a coordination
18:54:12 <russellw> ddarius, you can, but it takes a great deal of effort and doesn't happen very often - look at how much effort governments have to put in to maintaining witness protection programs
18:54:20 <dainanaki> I think the stakes would have to be higher in Player B's favor for B to choose Right, even without coordination
18:54:34 <russellw> So I think it's fair to say that most of the time in real life there is a way to coordinate
18:54:48 <ddarius> russellw: You can add time limits to easily thwart that.
18:55:14 <russellw> ddarius, under lab conditions, sure. But time limits so stringent as to really prevent coordination don't often happen by accident
18:55:23 <mm_freak> this is a purely theoretical scenario, in which no interaction between the two players is possible
18:55:35 <mm_freak> and this can very well be a real life scenario
18:56:04 <ddarius> russellw: If I pick two people randomly on two IRC channels and make the offer and say you have 1 minute to choose.  The possibility of coordination occurring is extremely low.
18:56:29 <ddarius> There are plenty of ways to make coordination either not worthwhile or infeasible.
18:56:32 <russellw> mm_freak, as a theoretical scenario, I think the optimal strategy is random as I said. If it happened in real life and I was the second player, I would just damn well give the first player the million and hope he felt like returning some of the favor. If not, well so what? I'm out one dollar. Big deal
18:56:53 <dainanaki> precisely
18:57:02 <elliott> One minute is long enough for collusion, I think.
18:57:08 <elliott> At least if the stakes are that high.
18:58:14 <ddarius> elliott: I think it would take you a lot longer than one minute for the two users to figure out who they are.  And I could assert that I will retract the offer if I detect coordination making simply broadcasting an unusable option.
18:58:21 <ddarius> This is regardless of the stakes.
18:58:37 <elliott> Oh, if they don't know who the other is, sure.
18:59:02 <elliott> ddarius: I just meant that people are more likely to rush to coordinate over a million dollars than five. :p
19:00:44 <cmccann> trying to find loopholes in "no coordination" is missing the point of questions like this
19:01:18 <cmccann> think of them as a model for what happens in the limit as "cost of coordination" goes to infinity
19:01:37 * elliott wasn't trying to find loopholes and agrees it's silly.
19:02:23 <ByronJohnson> 1\la
19:02:39 <coeus> hey, nice game!
19:03:31 <coeus> i think, the optimal strategy for A is not 50/50.
19:04:26 <coeus> there is no nash-aequilibrium, but there is always a mixed-nash-e.
19:06:24 <ddarius> Given Player A will choose Up with probability p, let's calculate the probability q Player B should choose Left to maximize pay-off.  The expected pay off is then 1pq + 1(1-p)(1-q) + 2p(1-q) + 2(1-p)q.  Differentiating w.r.t. q and setting to zero, we get 1-2p = 0, i.e. unless p = 0.5 the maximum is at the edges, either when q = 0 or q = 1.  When q is 0 we get 1+p and when q is 1 we get 2-p. So if p is greater than 0.5
19:06:24 <ddarius> , q should be 0.
19:08:38 <coeus> no, p and q influence each other.
19:08:47 <ddarius> No they don't.
19:08:54 <ddarius> Well they do.
19:09:19 <ddarius> But asserting that Player A's strategy is fixed to choosing Up with probability p, as I did, they don't.
19:10:21 <ddarius> The point of that calculation is that if, as Player B, I know that Player A will choose Up by -any- amount, it is in my interest to -always- choose Right (and symmetrically for a preference for Down.)
19:10:35 <nkpart> dcoutts__: Yeah I'm working around this: http://hackage.haskell.org/trac/ghc/ticket/5025, still exists in 7.0.4, fixed in 7.2.1 at the least
19:12:47 <ddarius> The mixed Nash equilibrium for this game is for each player to choose 50/50 regardless of how high (or how low as long as it's greater than the "losing" pay-off) I make the (Up, Left) pay-off.
19:14:51 <ddarius> What seems to happen in practice with real humans is that real players prefer Up and prefer Right.  I.e. the person in Player A's role almost always goes after the larger pay-off and is almost always foiled (and in a manner that makes the expected value much less than the 50/50 strategy.)  The most ironic thing is that this happens even when the game is iterated.
19:14:57 <coeus> ((["up","down"]!!a,["left","right"]!!b),zip "3112" "1221" !! (2*a+b)
19:15:13 <coeus> )
19:17:38 <eyebloom> I've been debating this in my mind: could you say that Haskell does or does not have the ability to evaluate itself as say Python does?
19:18:26 <elliott> What do you mean by "evaluate itself"?
19:18:36 <ddarius> eyebloom: Haskell is Turing-complete.  It can "evaluated itself" by definition.  eval is just a function.
19:18:37 <elliott> Haskell has no standard eval function, but you could implement one.
19:19:22 <byorgey> there is the 'hint' package which provides something like 'eval'.
19:19:27 <dainanaki> eyebloom, If you're actually looking to interpret haskell code in haskell, I recommend checking out hin on hackage
19:19:28 <eyebloom> It can't compile itself though.
19:19:34 <dainanaki> *hint
19:20:00 <byorgey> eyebloom: what does that mean?  GHC is written in Haskell.
19:20:26 <eyebloom> I'm saying a Haskell program lacks the ability to compile arbitrary code.
19:20:33 <eyebloom> Not that python can do that.
19:20:35 <ddarius> You don't even need to be Turing-complete to compile yourself.
19:20:44 <ddarius> Compilation is just a function.
19:20:55 <elliott> eyebloom: Of course a Haskell program can compile arbitrary code.
19:21:04 <elliott> GHC compiles arbitrary code.
19:21:05 <byorgey> eyebloom: if a compilation process is computable, then you can write a Haskell program to do it.
19:21:08 <elliott> (OK, arbitrary Haskell code.)
19:21:34 <byorgey> eyebloom: however, if you mean that most *specific* Haskell programs lack the ability to compile arbitrary code, I agree.  For example, an implementation of the Fibonacci numbers cannot compile anything.
19:21:38 <ddarius> elliott: Actually it doesn't compile arbitrary Haskell code, but it does compile the vast majority of Haskell 2010, plus quite a bit of other things.
19:21:51 <coeus> eyebloom, haskell can interpret itself, but it allows compilation. it can jit-compile itself faster than lisp jit-compiles from lisp to lisp.
19:22:10 <elliott> ddarius: Close enough.
19:22:18 <ddarius> elliott: Agreed.
19:22:21 <coeus> which does not imply jit-compilation to machine code.
19:22:40 <eyebloom> Right, what I'm saying is the language lacks compilation of itself as a standard part of it's runtime.
19:22:52 <ddarius> eyebloom: That's a totally different statement.
19:23:18 <eyebloom> Understood, as I said I'm debating this in my mind.
19:23:19 <coeus> python lacks compilation.
19:23:41 <ddarius> Python lacks a standard, therefore Python can't do anything.
19:23:51 <coeus> lol
19:24:01 <elliott> Python has an executable standard called CPython.
19:24:03 <dainanaki> eyebloom: and indeed, if you change that statement from referring to the language to the language as implemented by GHC, then you're wrong.
19:24:16 <eyebloom> Let's not get in a Python vs Haskell debate I think we are all on the side of Haskell.
19:24:28 <elliott> There's a debate?
19:24:33 <eyebloom> :)
19:24:36 <elliott> dainanaki: GHC doesn't link itself into programs by default, does it?
19:24:51 <dolio> No. That'd be pretty silly.
19:24:57 <dainanaki> not by default, but it provides the functionality to do so.
19:25:04 <dainanaki> as a library
19:25:43 <coeus> it is possible to write a python script, that compiles
19:25:45 <eyebloom> The same facility that compiles a python program to bytecode, is available to compile an arbitrary string in every python program.
19:25:46 <coeus> haskell.
19:26:18 * ddarius tries to get wifi-radar to compile an arbitrary string.
19:26:56 <monochrom> you should change the question to: "how to convert from String to a?"
19:26:59 <ddarius> (That actually would not be too hard.)
19:27:10 <coeus> via sewing machine?
19:27:13 <eyebloom> What is the library that allows a ghc to run within a haskell program?
19:27:25 <dainanaki> ghc
19:27:37 <eyebloom> makes sense.
19:27:58 <dainanaki> try doing ghc-pkg list from the command line, and you'll see it as a globally available library
19:28:09 <monochrom> the package name is "ghc", the module names are "GHC" etc. find it in the docs that come with GHC.
19:28:24 <coeus> System.Cmd
19:28:32 <dainanaki> you just have to specify it as a dependency.
19:28:52 <dainanaki> the relevant portion is here: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.2.2/GHC.html
19:29:12 <monochrom> http://www.haskell.org/haskellwiki/Ghc_as_a_library has some tips
19:29:22 <elliott> http://hackage.haskell.org/package/hint is probably more generally useful
19:29:26 <elliott> for doing something like eval
19:29:28 <eyebloom> Can its output be then be called from within the program?
19:30:05 <elliott> You can evaluate functions and call them, IIRC.
19:30:37 <eyebloom> That's glorious.
19:31:18 <eyebloom> Why isn't it used by many of the embedded language researchers?
19:31:24 <dainanaki> eyebloom: here's a somewhat broken rake-like thing that I wrote a while ago using hint: https://github.com/iand675/Zoom
19:31:59 <dainanaki> It's pretty ugly, but it is an example of the sort of thing you can do.
19:35:11 <mm_freak> i've just written a little prisoner's dilemma game
19:35:19 <mm_freak> if you're interested:  telnet ertes.de 4000
19:35:20 <mm_freak> =)
19:35:59 <mm_freak> or alternatively:  nc ertes.de 4000
19:36:42 <monochrom> I got jailed for a year!
19:37:05 <monochrom> the 2nd time, just 1 month
19:37:29 <mm_freak> hah
19:37:31 <mm_freak> i'm free =)
19:37:35 <monochrom> the 3rd time, one year
19:38:13 <monochrom> the way around the dilemma is to go on vandetta on you after I come out, or even before
19:38:14 <elliott> It's not happy with my input.
19:38:16 <elliott> Using telnet.
19:38:25 <Clint> it just keeps repeating "Please type either "betray" or "coop"." at me
19:38:28 <elliott> Yeah.
19:38:39 <ddarius> monochrom preemptively kills all his coordinators.
19:38:40 * elliott tries nc.
19:38:50 <mm_freak> note:  if one player closes the connection, the other player is just kicked off
19:39:08 <monochrom> oh, so that's how to go on vandetta!
19:39:11 <eyebloom> I'm also getting the same repeating "betray" or "coop"
19:39:12 <elliott> Okay, it works with nc.
19:39:21 <elliott> telnet must be sending control code stuff
19:39:25 <shachaf> elliott: telnet sends CRLF
19:39:26 * monochrom is smart to begin with nc!
19:39:29 <elliott> "The other made the mistake to trust you.  You are set free."
19:39:31 <elliott> HA HA HA
19:39:40 <Clint> handle line endings better
19:39:52 <ddarius> The purpose of this exercise was for mm_freak to find out who the hardcore users are.
19:40:00 <monochrom> haha
19:40:04 <monochrom> and to kill them
19:40:11 <elliott> The only reason I didn't start out with nc was that I somehow haven't installed it on this machine yet. :(
19:40:23 <ddarius> elliott: Maybe you installed socat instead.\
19:40:30 <elliott> mm_freak: You should iterate this.
19:40:47 <mm_freak> i should make it listen only on IPv4…  it seems to have a little problem with IPv6
19:41:46 <mm_freak> it's just quick-n-dirty code
19:41:56 <mm_freak> thought it might be nice to see what people actually decide =)
19:42:06 <mm_freak> apparently most people in the real world go with cooperating
19:42:32 <monochrom> yes, because what I said about vandetta
19:43:15 <startling> is there an easy way to use Parsec on a list of data type instances rather than a list of characters?
19:43:18 <elliott> mm_freak: real world = #haskell
19:43:19 <monochrom> you have to model the "real world" scenerio with a bigger, more iterated game.
19:43:24 <elliott> Most people in #haskell know about prisoner's dilemma.
19:43:30 <mm_freak> true
19:43:34 <elliott> Real world, not so much.
19:43:53 <elliott> monochrom: (do you mean vendetta?)
19:43:58 <monochrom> yes
19:44:03 <elliott> Someone just duped me. :(
19:44:39 <coeus> nice, double-coop.
19:44:50 <monochrom> however, on IRC where there are fewer ways and/or lower probability of reprise, the prisoner's dilemma may be accurate enough
19:45:17 <mm_freak> nice double-betrayal =)
19:45:34 <monochrom> although it is not very often that the ops pick two persons and intimidate "get banned for 1 year or 1 month"
19:45:58 <monochrom> (the ops just ban for life. kind of)
19:46:03 <elliott> (you know what to do!)
19:46:07 <coeus> i've found the mixed-nash-aeq. in that 3112-game.
19:46:26 <mm_freak> that might be an interesting experiment…  i guess people will make entirely different decisions, when facing a possible channel ban
19:46:34 * elliott volunteers.
19:46:54 <coeus> player A chooses 50/50, player B 33/66.
19:49:23 <hpaste> “Ertugrul Söylemez” pasted “Prisoner's dilemma outcomes” at http://hpaste.org/57034
19:49:32 <mm_freak> if anyone cares
19:49:40 <mm_freak> see paste
19:50:17 <elliott> Oh no, I've been statisticised.
19:50:36 <coeus> 25x coop, 15x betr
19:50:37 <mm_freak> no, it's just randomly generated =)
19:50:59 <mm_freak> wow, bad PRNG
19:51:15 <mm_freak> alright…  dilemma server is closed
19:51:56 <mm_freak> thanks for participating =)
19:51:56 <coeus> function returns real random number, i did throw that dice myself.
19:52:54 <ddarius> If Player B prefers an option, by the same argument as before, it is in Player A's interest to always choose the option that foils Player A.
19:53:10 <mm_freak> i mostly betrayed
19:53:18 <ddarius> s/Player A\./Player B./
19:53:30 <mm_freak> conforming to the game-theoretic player's choice
19:54:52 <ddarius> mm_freak: In iterated prisoner's dilemma, tit-for-tat performs well.  Also, cooperate until betrayed then betray from that point on is a Nash equilibrium if I remember correctly.
19:56:24 <mm_freak> ddarius: with the assumption that the game will be played infinitely many times?
19:56:55 <ddarius> mm_freak: With the assumption that the player's will not know when the game will be ended.
19:57:43 <mm_freak> does the PD even have a nash equilibrium?
19:57:52 <mm_freak> in the iterated case
19:57:52 <ddarius> If the players know when the game will end, then betraying on the last move is the dominant strategy at which point betraying on the move before is and so forth.
19:58:52 <scooty-puff> does -ddump-deriv just show some generic text for anyone else?
19:59:03 <elliott> Generic text like what?
19:59:16 <mm_freak> if you always betray, the game's outcome will highly depend on the strategy of your adversary
19:59:31 <scooty-puff> Derived from the representation type
19:59:44 <scooty-puff> er, "Derived from the representation type"
20:13:38 <zzo38> I made up a different kind of Arrow, instead of Arrow class I split it into two classes and are more generalized.
20:13:56 <NihilistDandy> They should call you Robin Hood
20:14:16 <zzo38> class (Category c1, Category c2) => CatFunctor c1 c2 where { funct :: c1 x y -> c2 x y; };
20:14:43 <zzo38> class Category c => CatArrow c p where { arr1 :: c x y -> c (p x z) (p y z); arr2 :: c x y -> c (p z x) (p z y); (*+*) :: c x y -> c x' y' -> c (p x x') (p y y'); (&|&) :: c x y -> c x y' -> c x (p y y'); fanout :: c x (p x x); };
20:14:48 <zzo38> Minimal definition: (*+*) and fanout
20:16:02 <zzo38> arr1 = (*+* id); arr2 = (id *+*); f *+* g = arr1 f >>> arr2 g; f &|& g = (f *+* g) . fanout; fanout = id &|& id;
20:17:26 <zzo38> Does this instance seems correct to you?   instance CatArrow Lens (,) where { Lens x *+* Lens y = Lens $ \(a, b) -> store (flip peek (x a) *** flip peek (y b)) (pos $ x a, pos $ y b); fanout = Lens $ store snd . join (,); };
20:17:44 <ddarius> zzo38: Your "CatFunctor" class does not correspond to a very coherent class of functors.
20:18:03 <zzo38> ddarius: What do you mean by that?
20:19:06 <ddarius> To the extent that the class can be viewed as capturing a notion of "functor" it means "an identity-on-objects functor between two categories with the same set of objects but potentially different arrows."
20:20:36 <zzo38> The Category class always has the same objects anyways, though.
20:22:01 <ddarius> zzo38: The "identity-on-objects" part is really the most awkward part.  However, your class doesn't correspond to just the identity-on-objects functors for the reason you specify.\
20:23:58 <zzo38> Explain better?
20:24:49 <ddarius> As far as I can tell, CatFunctor is a non-sequitur.  CatArrow is just Arrow with (,) abstracted out and the only example you've provided just chooses p = (,) anyway.
20:25:30 <zzo38> To emulate ArrowChoice, you use the CatArrow on the dual category with Either instead of (,) and I did make the DualCategory wrapper for that purpose
20:25:45 <zzo38> Here is the other example:
20:26:11 <zzo38> instance CatArrow (->) (,) where { (*+*) = (***); fanout = join (,); };  instance CatArrow (DualCategory (->)) Either where { DualCategory x *+* DualCategory y = DualCategory (x +++ y); fanout = DualCategory (id ||| id); };
20:27:09 <zzo38> So, this is one example that does not have p = (,)
20:27:59 <ddarius> Yes, the notion of Arrows is based on the notion of a premonoidal category but specialized to (,) (probably to make it simpler and Haskell 98.)  Both (,) and Either induce a monoidal (and thus premonoidal) structure on a category.
20:28:27 <ddarius> (or rather the categorical product and coproduct (with the nullary cases) do in general.)
20:31:43 <zzo38> The Arrow class is less generalized due to Haskell 98 and other reasons, yes. It does mean that only first needs defined. I just made it generalized and not require a functor from (->)
20:35:51 <zzo38> What exactly are you attempting to imply? I have heard that other people wanted Arrow without arr, too (although I came up with the idea independently before then).
20:37:16 <zzo38> Since arr is removed, that mean instead of being specialized to (,) you can remove that, therefore you can use the same class for the purpose of ArrowChoice as well
20:45:30 * edwardk waves hello
20:45:30 <lambdabot> edwardk: You have 5 new messages. '/msg lambdabot @messages' to read them.
20:45:45 <shachaf> edwardk!
20:46:21 <edwardk> heya
20:47:11 <zzo38> edwardk: Did you make the "data-lens" package? Is my CatArrow for Lens correct? (I made up a CatArrow class similar to Arrow, but does not include arr and can use types other than (,) as well)
20:47:38 <edwardk> zzo38: look at the categories package ;)
20:47:54 <edwardk> but it'd be hard to wire it up wrong ;)
20:48:09 <koninkje> edwardk: where are your codensity monads living these days?
20:48:16 <edwardk> kan-extensions
20:48:43 <koninkje> Oh, that's right
20:48:56 <ozataman> what's a good, performant transformer to give a monad stack short-circuiting behavior? Would ErrorT work reasonably well?
20:49:00 <elliott> We need an edwardkoogle to find all the split-up parts of category-extras :)
20:49:03 <koninkje> I knew there's a reason I just rolled my own for unification-fd
20:49:17 <koninkje> (portability, H98,...)
20:49:19 <zzo38> edwardk: OK I look at categories package. It doesn't have anything with lenses?
20:49:24 <b0fh_ua> hi, what is the easiest way to deal with Random generator if I need to call it several times within a function?
20:49:34 <b0fh_ua> use State monad ?
20:49:35 <edwardk> zzo38: it predates the lenses package
20:49:47 <ddarius> ozataman: Use Codensity.
20:50:01 <edwardk> elliott: dmwit spent part of hac boston building a new category-extras as a meta-package that documents what got sent where
20:50:03 <zzo38> edwardk: I don't see any Arrow either
20:50:06 <edwardk> not sure if he pushed it
20:50:26 <edwardk> zzo38: it doesn't redefine arrow, but what you described is roughy the CCC class from that package
20:50:29 <ddarius> Also he made a diagram of the dependencies.
20:50:32 <elliott> edwardk: heh
20:50:44 <ozataman> ddarius: from the mmtl package?
20:50:54 <edwardk> ozataman: kan-extensions
20:51:32 <edwardk> koninkje: did you ever get around to looking at that patch i sent which cleaned up the type parameters in unification-fd?
20:51:49 <zzo38> edwardk: OK! I didn't know that. (I did post my code above, before you connected to this channel; in case that help you to answer my question)
20:52:05 <koninkje> edwardk: I think it might've gotten lost somewhere
20:52:10 * koninkje looks around for it
20:52:14 <edwardk> zzo38: not here for long
20:52:20 <edwardk> koninkje: its probably on my github
20:53:15 <ozataman> edwardk: are there any examples/resources for Codensity?
20:53:28 <zzo38> What is not here for long?
20:53:31 <edwardk> ozataman: any example for Cont where they don't use callCC ;)
20:53:55 <edwardk> zzo38: i meant that i wasn't going to be around long enough tonight to chasing through logs =)
20:54:10 * ski shifts unconfortably
20:54:19 <ozataman> edwardk: thanks, let me do some digging :)
20:54:27 <koninkje> edwardk: Found it.
20:54:28 <edwardk> just popped on to let dolio know that i added a bunch of stuff to our compiler
20:54:54 <zzo38> This is my code:    instance CatArrow Lens (,) where { Lens x *+* Lens y = Lens $ \(a, b) -> store (flip peek (x a) *** flip peek (y b)) (pos $ x a, pos $ y b); fanout = Lens $ store snd . join (,); };
20:55:03 <zzo38> Now you don't have to look at the logs
20:55:11 <koninkje> edwardk: there's been an inquiry about making the anticipated unification-tf fork. So I'll take a look at the patch and roll it in when I get around to that
20:55:57 <edwardk> i also have another variant somewhere that makes a change in the core ADT to support HMF style higher rank unification
20:56:04 <elliott> ski: try resetting
20:56:27 * ski smiles
20:56:49 <zzo38> It has other methods too but the minimal definition is (*+*) and fanout
20:57:31 <zzo38> I don't know the similarity to CCC
20:58:59 <zzo38> Can you explain it better?
20:59:05 * ski doesn't see an `app' or a `curry'
21:01:52 <koninkje> edwardk: send me a patch for the HMF stuff and I'll see about fitting it in
21:03:13 <edwardk> i don't think i ever got it to a place where it really fit your api
21:03:23 <koninkje> hrmm.
21:03:52 <koninkje> Well, now it's on my radar. I'll take a look at the paper and see if I can come up with something once I have a few round tuits
21:03:55 <edwardk> zzo38: the type of *+* is?
21:04:01 * ddarius might call zzo38's "CatArrow" class a presemigroupal category with dup.
21:04:30 <zzo38> edwardk:  (*+*) :: c x y -> c x' y' -> c (p x x') (p y y');
21:04:46 <zzo38> fanout :: c x (p x x);
21:06:36 <edwardk> so (*+*) is bimap http://hackage.haskell.org/packages/archive/categories/0.58.0.5/doc/html/Control-Categorical-Bifunctor.html ?
21:07:15 <zzo38> edwardk: O, yes, that is it.
21:07:29 <edwardk> and fanout is 'diag' http://hackage.haskell.org/packages/archive/categories/0.58.0.5/doc/html/Control-Category-Cartesian.html
21:08:16 <zzo38> Yes, that is that, too.
21:08:17 <edwardk> given those you might want to explore the space around those combinators for other things of interest to you
21:08:44 <edwardk> ok
21:08:55 <zzo38> OK
21:09:03 <edwardk> now that that connection is made, your fanout is illegal =)
21:09:13 <edwardk> it should violate the lens laws
21:09:30 <zzo38> I did not read anything about lens laws! But I did think of that anyways
21:10:12 <zzo38> And yes, if that is the case I can see how it could violate
21:10:13 <edwardk> the lens laws are that they form a costate comonad coalgebra, which translates into english as 'you get back what you put in, and putting has no other side-effects on any other part of the whole'
21:11:03 <edwardk> There is no forall a. Lens a (a,a) lens, because you only have room for one 'a' in the whole, but you extracted 2.
21:11:08 <copumpkin> edwardk: roconnor was looking for you before, by the way
21:11:12 <zzo38> I did think of this: For a lens (x) then    extract . runLens x = id   And that still seems to follow?
21:11:18 <edwardk> so get after putting can only get one of them back
21:11:42 <edwardk> there are 3 laws when stated in terms of get and put
21:12:07 <zzo38> Then you should mention them in the module file for lens
21:12:26 <edwardk> i had them somewhere. apparently they got dropped when it got broken out into a separate package
21:13:08 <zzo38> But is    extract . runLens x = id    one of them?
21:14:57 <edwardk> sounds right
21:16:39 <zzo38> But I do notice that some classes do mention laws that don't need, such as MonadPlus. The left zero law is redundant (because it is implied by the monad laws), and the right zero law does not apply to all monads. In addition, not all instances will make it form a monoid anyways (the MonadPlus instance for IO is not a monoid, but I made one which is)
21:18:20 <edwardk> zzo38: MonadPlus is actually 2 classes in disguise. look at the MonadPlus reform proposal on the wiki
21:18:52 <edwardk> there are two sets of semantics for it. depending on if you have 'Left Catch' or the 'Left (sic) Distributive' law
21:19:26 <zzo38> edwardk: In my opinion the only laws needed is the monoid laws. The left zero law is implied by the monad laws.
21:19:36 <edwardk> zzo38: then you miss the point. ;)
21:19:51 <edwardk> the ability to distribute or catch is important
21:20:00 <zzo38> Distribute or catch meaning what?
21:21:05 <edwardk> mplus a b >>= k = mplus (a >>= k) (b >>= k)     or mplus (return a) b = return b  -- one of those laws should hold
21:21:06 <zzo38> Can you add classes with MonadPlus as a requirement but no additional methods, to tell you that they have the ability to distribute or catch?
21:21:26 <edwardk> for some, both hold
21:22:21 <edwardk> but without either, i would argue that your MonadPlus is an astraction that has nothing to do with Monad
21:22:24 <dolio> = return a, you mean
21:22:26 <edwardk> er abstraction
21:22:32 <edwardk> dolio: yeah
21:22:49 <edwardk> and should just be Plus or FunctorPlus ;)
21:23:18 <edwardk> which is available [00:37] edwardk (~edwardk@209-6-38-72.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com) joined the channel.
21:23:18 <edwardk> [00:37] Topic is ["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://bit.ly/5mwtRQ",  "admin/spam
21:23:19 <edwardk>  issues: #haskell-ops"]
21:23:19 <edwardk> [00:37] Set by copumpkin on December 17, 2011 5:06:48 PM EST
21:23:19 <edwardk> [00:37] edwardk waves hello
21:23:19 <edwardk> [00:37] Website is http://www.haskell.org/
21:23:19 <edwardk> [00:37] conal (~conal@173-166-248-200-stockton.hfc.comcastbusiness.net) joined the channel.
21:23:31 <dolio> Wow.
21:23:42 <copumpkin> whoopsie daisy :P
21:23:51 <edwardk> er http://hackage.haskell.org/packages/archive/semigroupoids/1.2.6/doc/html/Data-Functor-Plus.html =)
21:24:09 <copumpkin> edwardk: I dunno, the other paste was pretty informative too
21:24:33 <edwardk> irception
21:24:46 <elliott> I dunno, I personally think that <edwardk> which is available [00:37] edwardk (~edwardk@209-6-38-72.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com) joined the channel.
21:24:52 <edwardk> as you nest irc in irc in irc, things get very slow
21:26:16 <edwardk> elliot: but clearly [01:17] elliott: I dunno, I personally think that <edwardk> which is available [00:37] edwardk (~edwardk@209-6-38-72.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com) joined the channel.
21:26:57 <elliott> edwardk: I'd quote that, but you spelled my name wrong.
21:27:03 * elliott can't encourage such things.
21:27:21 <edwardk> elliott: but clearly [01:17] elliott: I dunno, I personally think that <edwardk> which is available [00:37] edwardk (~edwardk@209-6-38-72.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com) joined the channel.
21:28:22 <copumpkin> elliotts seem very particular about getting the correct number of Ls and Ts
21:28:33 <copumpkin> it would help if people would standardize on a spelling of it
21:28:37 <elliott> edwardk: Well, I can agree that <edwardk> elliott: but clearly [01:17] elliott: I dunno, I personally think that <edwardk> which is available [00:37] edwardk (~edwardk@209-6-38-72.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com) joined the channel.
21:28:48 <elliott> Soon we'll reach the length limit and millions will die.
21:29:02 <elliott> copumpkin: Our spelling is wildly disadvantaged! The Haskell community is our only refuge.
21:30:31 <shachaf> "eliot" is the one true spelling of that name.
21:32:13 <elliott> shachaf: You upset conal.
21:32:29 <shachaf> :-(
21:32:39 <shachaf> preflex: seen elliottt
21:32:39 <preflex>  elliottt was last seen on #haskell 13 days, 5 hours, 23 minutes and 44 seconds ago, saying: mikeplus64: you can use (+) x y, if that's what you're after
21:32:42 <shachaf> That's a pretty good spelling.
21:36:18 <startling> w
21:36:31 <startling> oops, thought this was vim.
21:36:46 <dolio> Why didn't you type :w, then?
21:37:06 <dolio> You must have thought it was ed.
21:38:12 <shachaf> dolio: Might've been vim in Ex mode.
21:39:24 <mzero> or perhaps startling just wanted to move over a word
21:41:51 * ddarius pipes IRC into vim and sees what gets produced.
21:42:36 <shachaf> ddarius: Given that IRC doesn't tend to have Esc characters, I imagine that it'll be IRC logs, for the most part.
21:43:07 <elliott> shachaf: IRC doesn't start with "I".
21:43:08 <elliott> *i
21:43:34 <shachaf> elliott: Hence "for the most part".
21:43:37 <edwardk> elliott: but you'll hit an insert character soon enough
21:43:45 <shachaf> There's possibly be some junk at the beginning or something.
21:44:22 <shachaf> iIaAsSC(c<movement>)R and so on would all work.
21:44:29 <elliott> But if there's a : before an insert...
21:44:40 <elliott> Then it might take a while for things to get un-stuck enough.
21:44:53 <shachaf> Eh, just until the next newline.
21:45:56 <dibblego> can someone please tell me why this fails to build with ghc-7.2 but is fine with ghc-7.0.4? http://hackage.haskell.org/packages/archive/OSM/0.6.1/logs/failure/ghc-7.2
21:46:23 <elliott> dibblego: TypeSynonymInstances used to permit instances that expanded to things requiring FlexibleInstances
21:46:28 <elliott> (but GHC would still reject the expanded form)
21:46:35 <elliott> Now you have to specify FlexibleInstances explicitly if you want to do that.
21:46:43 <edwardk> elliott: clearly you need to change your nick to a command you can get past a vim interpreter. and start all your sentences with something executable
21:46:44 <dibblego> ah ok so I should add FlexibleInstances to cover 7.2?
21:46:48 <dibblego> right thanks
21:47:16 <elliott> edwardk: It is my solemn duty.
21:47:23 <elliott> :!rm -rf ~
21:47:31 <elliott> --to mess things up.
21:47:33 <edwardk> yep. you need to switch to ellott
21:47:48 <shachaf> edwardk: 'o' is an insertion command too.
21:47:58 <edwardk> elltt
21:48:28 <shachaf> Are we piping raw IRC or pretty-printed IRC?
21:48:32 <shachaf> Raw IRC has a lot of colons.
21:48:42 <lpsmith> ghc can't unpack enumerations?
21:48:51 <elliott> It can't?
21:49:09 <edwardk> 1G10000dd:  w!  what was that?
21:49:23 <ddarius> It doesn't really make sense.  That said, small enumerations will be in the tag bits.
21:49:33 <lpsmith> Apparently it can't
21:49:35 <lpsmith> that's unfortunate
21:49:52 <elliott> I just *knew* copumpkin is Obama
21:49:59 <NihilistDandy> It all makes sense now
21:50:17 <edwardk> yep. and adds a lot of credence to the birth certificate issue
21:51:14 <elliott> They were just looking in the wrong place all along.
21:51:22 <ddarius> The real tip off is the hair.
21:52:00 <monochrom> I can't believe Obama added me on Google+!
21:52:21 <ddarius> monochrom: It is a campaign year.
21:52:46 <elliott> I guess this explains why copumpkin keeps talking about his job as the President.
21:52:51 <elliott> I thought that was quite odd.
21:53:03 <copumpkin> lol
21:53:47 <shachaf> What a 1%er.
21:54:05 <copumpkin> just can't help it, you know?
21:54:14 <monochrom> "occupy the pumpkin"
21:54:28 <elliott> monochrom: you fool! that'll _support_ him
21:54:31 <elliott> he's a copumpkin, after all
21:54:43 <elliott> As if the birth certificate wasn't bad enough, TRICKED AGAIN
21:54:48 <tensorpudding> the pumpkin in opposition
21:55:17 <NihilistDandy> cooccupy, then
21:55:29 <NihilistDandy> Unless you're preoccupied
21:55:43 <Axman6> i was going to ask if cooccupying the pumpkin is the same as occupying the copumpkin
22:00:50 <NihilistDandy> edwardk: Mind if I ask for some Agda guidance?
22:01:11 <edwardk> NihilistDandy: copumpkin or dolio could probably help you more than I can
22:12:27 * hackagebot OSM 0.6.2 - Parse OpenStreetMap files  http://hackage.haskell.org/package/OSM-0.6.2 (TonyMorris)
22:17:50 <CodeWeaver> Once again I'll ask in case anybody knows:  Anybody seen "ghc: could not execute: /Developer/usr/bin/gcc" when attempting to build gtk or wxHaskell?
22:18:29 <elliott> It sounds like your gcc is broken.
22:18:36 <elliott> Try reinstalling GHC or Xcode?
22:19:27 <CodeWeaver> Reinstalling XCode now.  Will try also reinstalling GHC.  Funny thing is, I can use that gcc on the command line (at least issue it flags), and it symlinks over to gcc-llvm-4.2
22:29:13 * ddarius fails at writing problems down today.
22:30:01 <Sgeo> http://hackage.haskell.org/packages/archive/erlang/0.1/doc/html/Foreign-Erlang.html#11
22:30:07 <Sgeo> fromErlang doesn't look safe
22:30:15 <Sgeo> Shouldn't it be ErlType -> Maybe a?
22:30:42 <elliott> Sgeo: Why?
22:31:02 <elliott> Hmm, seems that the instances actually are partial.
22:31:04 <Sgeo> Because a specific ErlType may or may not be, say, a String
22:35:45 * ddarius partially retracts his last statement.
22:36:20 <shachaf> You succeeded?
22:36:29 <elliott> * ddarius pipes IRC into vim and sees what gets produced.
22:36:31 <elliott> Consider it retracted.
22:36:41 <elliott> Oh, no, the last one was hair-related.
22:36:44 <elliott> Oh!
22:36:49 <elliott> Ignore me.
22:40:00 <Sgeo> Permission to slap the author of Foreign.Erlang?
22:40:16 <ddarius> And elliott says I don't pay attention.
23:00:50 <startling> any recommendations for gui libraries? I'm almost always on *nixes.
23:01:58 <tikhonjelvis> I think wx is a good option. But I can't get it to build myself, so you should probably ignore my advice :)
23:08:27 <startling> heh.
23:08:34 <micahjohnston> wx and qt seem good for cross-platform, and there's perhaps gtk if you're on *nix?
23:08:37 <micahjohnston> I know little
23:09:04 <micahjohnston> then there's all the experimental frp things like wxfruit and other stuff that probably isn't a good idea for production
23:09:07 <tikhonjelvis> On Linux, wx ends up using GTk anyhow.
23:09:12 <startling> Yeah, gtk might be good.
23:09:24 <tikhonjelvis> I think all the interesting frp things also use wx as the back-end.
23:09:26 <Ralith> gtk is as cross-platform as anything
23:09:46 <tikhonjelvis> Unfortunately it's relatively ugly on my computer :(
23:09:49 <startling> hey,is there any way to compose two whatever -> Boolean functions using or?
23:10:15 <startling> I can use lambdas but that's kind of a pain.
23:10:37 <shachaf> > liftM2 (||) odd (==2) 3
23:10:38 <lambdabot>   True
23:10:39 <shachaf> > liftM2 (||) odd (==2) 4
23:10:40 <lambdabot>   False
23:10:41 <shachaf> > liftM2 (||) odd (==2) 2
23:10:42 <lambdabot>   True
23:10:56 <shachaf> @pl \f g x -> f x || g x
23:10:56 <lambdabot> liftM2 (||)
23:11:39 <micahjohnston> > (||) <$> const False <*> const True $ 3
23:11:40 <lambdabot>   True
23:11:46 <startling> neat, thanks.
23:12:04 <micahjohnston> you can use liftM2, or liftA2, or <$> and <*>
23:12:21 <shachaf> > (or .: sequence) [odd,(==2)] 3
23:12:22 <lambdabot>   True
23:12:23 <shachaf> > (or .: sequence) [odd,(==2)] 4
23:12:24 <lambdabot>   False
23:12:28 <micahjohnston> the second two options require Control.Applicative and I think the first requires Control.Monad
23:12:40 <micahjohnston> :t sequence
23:12:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:12:53 <arcatan> :t (||) <$> const False
23:12:54 <lambdabot> forall b. b -> Bool -> Bool
23:13:04 <micahjohnston> > sequence [const 1, const 2] 3
23:13:04 <lambdabot>   [1,2]
23:15:02 <micahjohnston> :t (.:)
23:15:02 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
23:15:20 <hpaste> Kanisterschleife pasted “mpd lib” at http://hpaste.org/57040
23:15:22 <micahjohnston> oh, two-deep functors?
23:15:39 <Kanisterschleife> hi. I experience a problem with Haskell MPD Library. Executung the above, is suddenly stops after 10-20 calls
23:17:22 <Kanisterschleife> did somebody of you face this "unstability", too?
23:18:01 <Axman6> what is MPD? i've never heard of it
23:18:14 <Kanisterschleife> Axman6: music player daemon
23:20:20 <Kanisterschleife> A music server which can be communicated with through TCP, and that is what the mpd library is doing
23:21:19 <Algo> That awkward moment when your brand spankin' new algorithm, the one that you thought would result in an awesome breakthrough, turns out to result in a never-ending loop
23:24:36 <tikhonjelvis> Unfortunately it's relatively ugly on my computer :(
23:24:45 <tikhonjelvis> Oops, wrong buffer
23:25:01 <tikhonjelvis> All of them look and behave like shells :(
23:25:14 <Algo> tikhonjelvis: :\
23:25:40 <tikhonjelvis> And my habit is to quickly switch to a buffer and run the previous command.
23:27:24 <micahjohnston> > (+1) .: [[1]]
23:27:25 <lambdabot>   [[2]]
23:27:27 <micahjohnston> cool
23:28:30 <micahjohnston> > (fmap.fmap) (+1) [[1]]
23:28:31 <lambdabot>   [[2]]
23:28:42 <micahjohnston> > (+1) .: (+) 3 4
23:28:42 <lambdabot>   No instance for (GHC.Num.Num (f (g a)))
23:28:42 <lambdabot>    arising from a use of `e_1134' a...
23:28:47 <tikhonjelvis> :t .:
23:28:48 <lambdabot> parse error on input `.:'
23:28:53 <tikhonjelvis> :t (.:)
23:28:53 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
23:29:05 <micahjohnston> > (+1) .: (+) $ 3 4
23:29:05 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:29:05 <lambdabot>    arising from a use of `...
23:29:18 <micahjohnston> > ((+1) .: (+)) 3 4
23:29:19 <lambdabot>   8
23:29:25 <micahjohnston> :D
23:30:01 <micahjohnston> so .: = fmap fmap fmap
23:30:09 <micahjohnston> I should go to sleep
23:30:16 <tikhonjelvis> Nah
23:31:06 <Oxryly> > (+1) .: [[1]]
23:31:08 <lambdabot>   [[2]]
23:31:29 <Oxryly> wha?
23:32:17 <Oxryly> > (+1) 1
23:32:18 <lambdabot>   2
23:32:31 <Oxryly> : 1 2
23:32:34 <Oxryly> > : 1 2
23:32:34 <lambdabot>   <no location info>: parse error on input `:'
23:36:20 <mmaruseacph2> Oxryly: try this
23:36:27 <mmaruseacph2> > (:) 1 2
23:36:28 <lambdabot>   No instance for (GHC.Num.Num [t])
23:36:28 <lambdabot>    arising from a use of `e_112' at <inte...
23:36:31 <mmaruseacph2> > (/) 1 2
23:36:32 <lambdabot>   0.5
23:36:50 <mmaruseacph2> > (.:) 1 2
23:36:51 <lambdabot>   No instance for (GHC.Show.Show (f (g b)))
23:36:51 <lambdabot>    arising from a use of `M658029...
23:36:57 <mmaruseacph2> > (/) 1 [2]
23:36:57 <lambdabot>   No instance for (GHC.Real.Fractional [t])
23:36:57 <lambdabot>    arising from a use of `e_112' ...
23:37:00 <mmaruseacph2> > (.) 1 [2]
23:37:01 <lambdabot>   [1]
23:37:09 <mmaruseacph2> > (:) 1 [2]
23:37:10 <lambdabot>   [1,2]
23:38:35 <mmaruseacph2> > (.) 1 [2]
23:38:36 <lambdabot>   [1]
23:38:40 <mmaruseacph2> why does this work?
23:38:44 <mmaruseacph2> > :t (.)
23:38:44 <lambdabot>   <no location info>: parse error on input `:'
23:38:53 <mmaruseacph2> @t (.)
23:38:53 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:38:59 <mmaruseacph2> @type (.)
23:39:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:39:05 <mmaruseacph2> @type (.) 1 [2]
23:39:06 <lambdabot> forall b. (Num b) => [b]
23:39:09 <mmaruseacph2> @type (.) 1
23:39:10 <lambdabot> forall a b (f :: * -> *). (Num b, Functor f) => f a -> f b
23:39:19 <mmaruseacph2> ah, I understand now
23:39:26 <tikhonjelvis> You can just do :t by itself, coincidentally.
23:39:27 <tikhonjelvis> :t id
23:39:28 <lambdabot> forall a. a -> a
23:40:05 <mmaruseacph2> :t (.)
23:40:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:40:17 <mmaruseacph2> it is different from what GHCi reports
23:40:30 <tikhonjelvis> It's an overloaded version.
23:40:33 <mmaruseacph2> I though that it should be function composition
23:40:36 <mmaruseacph2> aah
23:40:40 <mmaruseacph2> now I understand
23:40:46 <mmaruseacph2> @todo
23:40:46 <lambdabot> 0. SamB: A way to get multiple results from a google search
23:40:46 <lambdabot> 1. dons: improve formatting of @dict
23:40:46 <lambdabot> 2. dons: write Haskell Manifesto
23:40:46 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
23:40:46 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
23:40:48 <lambdabot> [31 @more lines]
23:41:01 <mmaruseacph2> cool :)
23:41:09 <shachaf> #haskell-overflow
23:41:13 <shachaf> (Or /msg lambdabot)
23:42:34 <_pw_`> t
23:43:53 <mmaruseacph2> sorry
23:45:39 <hamilyon> @source (:)
23:45:39 <lambdabot> (:) not available
23:46:21 <ChristianS> (:) is built-in
23:46:29 <shachaf> @src []
23:46:29 <lambdabot> data [] a = [] | a : [a]
23:47:28 * hackagebot HsASA 0.2 - A haskell interface to Lester Ingber's adaptive simulating annealing code  http://hackage.haskell.org/package/HsASA-0.2 (MalcolmWallace)
23:53:42 <ChristianS> ah, you have to query for the type name, not the constructor name?
23:54:51 <shachaf> There isn't all that much rhyme or reason to @src. It's just a key->value database.
23:54:54 <shachaf> Updated by hand.
23:55:14 <ChristianS> oh, i see
