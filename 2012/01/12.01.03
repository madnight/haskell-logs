00:00:02 * Sgeo still has not structured a large application
00:00:19 <Sgeo> And can only imagine that I'd make a type Application = StateT MyStructure IO or something
00:00:44 <ddarius> Sgeo: I suspect your definition of "large" and mine differ.
00:00:59 <Sgeo> By large, I mean anything beyond a small script
00:01:01 <Sgeo> >.>
00:02:09 <The_Journey> I want to have a function that will build up a list of [b] from a given function fooBar and everytime I call fooBar, I would get an random output of type b, but I'm not sure what the type of fooBar is and how to make it do something like that
00:02:56 <Sgeo> That list is, in a certain sense, a random output
00:03:00 <Sgeo> </useless>
00:03:05 <Sgeo> Well, no, the list's not random
00:03:36 <The_Journey> well, not random output of type, rather non-deterministic to the caller
00:03:37 <Sgeo> The_Journey, where would you use this "random output"?
00:03:56 <Sgeo> The_Journey, but that would make the caller nondeterministic, and anything that calls the caller nondeterministic.
00:04:23 <The_Journey> right, unless fooBar has some kind of state...?
00:04:24 <Sgeo> Functions in Haskell are deterministic, but there's a way to sort of ..
00:04:46 <shachaf> The_Journey: I recommend giving up on the idea of a non-deterministic function.
00:04:54 <Sgeo> There's a way to sort of write code, acting as if it's non-deterministic, when it's really deterministic.
00:04:56 <shachaf> Instead, you should say what you're actually trying to do.
00:05:19 <Sgeo> BRB
00:06:07 <Jafet> The_Journey: you want to read Real World Haskell, chapter 14.
00:06:33 <Jafet> And you might find it a bit difficult to understand. So before that, you might want to read chapters 1, 2, 3, and so on, till chapter 13.
00:06:49 <Sgeo> > do { a <- [1, 2, 3]; b <- [10,11,12]; return (a+b) }
00:06:49 <Jafet> And why stop there? You can continue reading chapter 15...
00:06:50 <lambdabot>   [11,12,13,12,13,14,13,14,15]
00:07:25 <Sgeo> The_Journey, look at my code. Inside the do block, a can be considered to be treated as though it has any of values 1 2 or 3, and b can be treated as though it has any of values 10, 11, or 12
00:07:52 <Sgeo> The result of this do block is another list, which, if it were used in a similar way, could act like any of the values in there
00:08:08 <Sgeo> I hope I'm not hurting :/
00:08:38 <The_Journey> I guess I will change the structure of my code. What is the best way to pick an element randomly from a list?
00:08:43 <Veinor> bleh
00:08:54 <Sgeo> The_Journey, to output it?
00:08:58 <Sgeo> The_Journey, or to do what with it?
00:09:33 <The_Journey> Sgeo: uhh... to do a calculation? Like pick an element randomly from [1,2,3,4,5] and multiply it with 3...?
00:09:48 <Sgeo> The_Journey, like this?
00:10:02 <Sgeo> > (3 *) <$> [1,2,3,4,5]
00:10:03 <lambdabot>   [3,6,9,12,15]
00:10:10 <Sgeo> My result is another list.
00:10:15 <shachaf> That doesn't look very random.
00:10:23 <arw> "Warning: -#include and INCLUDE pragmas are deprecated: They no longer have any effect" <- is there any replacement for those pragmas or does ghc somehow find the function prototype by magic?
00:10:23 <shachaf> The_Journey: What are you actually trying to do?
00:10:42 <shachaf> arw: Does GHC need the function prototype?
00:10:54 <shachaf> You specify the type of the function when you import it, don't you?
00:10:55 <arw> shachaf: no idea
00:11:07 <Veinor> "The -#include flag and INCLUDE pragma are now deprecated and ignored. Since version 6.10.1, GHC has generated its own C prototypes for foreign calls, rather than relying on prototypes from C header files.
00:11:20 <Sgeo> The_Journey, my resulting list also represents "non-deterministically one of the values in the list", even though it's not actually random.
00:11:29 <The_Journey> shachaf: I don't know how to put it other than that...? Say I want a function like this f :: (Num a) => [a] -> a, where I want to pick an element randomly from [a] and multiply it with 3?
00:11:38 <arw> ah, so it doesn't cross-check anything with the real header files? good to know...
00:11:49 <shachaf> The_Journey: That function is not a function and therefore impossible to write.
00:11:51 <Sgeo> The_Journey, are you ok with returning another list from your "multiply it with 3" function?
00:12:14 <shachaf> The_Journey: Why do you want to do that? What are you *actually* trying to do?
00:12:22 <The_Journey> print it
00:12:33 <Jafet> This stereo has a phase error.
00:12:44 <The_Journey> print the output of f [1,2,3,4,5]?
00:13:05 <The_Journey> where f is the function that randomly picks an element from a list and multiply it with 3
00:13:15 <The_Journey> is there no way to do that...?
00:13:41 <Sgeo> The_Journey, get the list that results from multiplying every element by 3, then print a random result from that list
00:13:48 <shachaf> Not with a function.
00:13:56 <The_Journey> shachaf: with what then?
00:14:01 <Sgeo> You can output a random element of a list
00:14:06 <shachaf> Sgeo: You seem preoccupied with multiplying every element of the list by 3.
00:14:23 <shachaf> The_Journey: You can generate random numbers using an IO action, for instance.
00:14:45 <Jafet> f xs = xs !! 4 -- Munroe, R.
00:14:54 <The_Journey> shachaf: I'm not sure how that will help me with writing f though
00:15:05 <shachaf> The_Journey: What is f?
00:15:53 <Veinor> i think what The_Journey wants is f :: (Num a) => [a] -> IO a
00:16:33 <Veinor> :t randomRIO
00:16:33 <The_Journey> ok, say I don't use a function to do it, say I just want to randomly pick an element from the list [1,2,3,4,5] and multiply it with the number 3 and print the output, how would I do that?
00:16:34 <lambdabot> forall a. (Random a) => (a, a) -> IO a
00:16:59 <Jafet> This DSS theatre has a phase error.
00:17:04 <Veinor> @type \xs -> do {index <- randomRIO (0, length xs); return $ xs !! index }
00:17:05 <lambdabot> forall a. [a] -> IO a
00:17:29 <Veinor> @type \xs -> do {index <- randomRIO (0, length xs); return $ 3 * (xs !! index) }
00:17:30 <lambdabot> forall a. (Num a) => [a] -> IO a
00:18:59 <hpaste> Veinor pasted “tripler” at http://hpaste.org/56021
00:19:07 <Veinor> ^^^^
00:19:57 <DanBurton> if you need repeated random access, it is recommended you don't use plain old lists. use a Seq instead or something
00:20:27 <The_Journey> Veinor: what would the type of randomTripler be?
00:20:37 <Veinor> (Num a) => [a] -> IO a
00:20:44 <The_Journey> ah ok, thank you very much
00:20:48 <Veinor> the IO is because random computation deals with the 'rest of the world'
00:21:19 <ddarius> Where the "rest of the world" in this case, is probably some piece of global state.
00:21:38 <Jafet> Unfortunately, The_Journey, while it may well be possible to explain random number generation and IO and functions to you in a hundred lines of irc, we seem to have not succeeded. I suggest Real World Haskell, chapter 14.
00:22:11 <opqdonut> :t sample . elements
00:22:12 <lambdabot> forall a. (Show a) => [a] -> IO ()
00:22:18 <DanBurton> if you want to implement a generic "random" function, you might want to let it take a random generator as input and produce a new one as output
00:22:21 <Sgeo> @hoogle sample
00:22:22 <lambdabot> Control.Concurrent.SampleVar module Control.Concurrent.SampleVar
00:22:22 <lambdabot> Control.Concurrent.SampleVar data SampleVar a
00:22:22 <lambdabot> Text.Html sample :: Html -> Html
00:22:28 <Sgeo> :t sample
00:22:29 <lambdabot> forall a. (Show a) => Gen a -> IO ()
00:22:31 <opqdonut> that's how you do it using QuickCheck's Gen
00:22:32 <Sgeo> :t elements
00:22:33 <lambdabot> forall a. [a] -> Gen a
00:23:00 <The_Journey> Jafet: to be honest, Real World Haskell isn't the most entertaining thing to read in the world.
00:23:12 <opqdonut> I think it's brilliant
00:23:14 <Veinor> i kind of want to just see if i can get cabal commit access
00:23:15 <Jafet> And irc is more entertaining?
00:23:18 <Veinor> and plow through a bunch of the old bugs
00:23:27 <Veinor> because seeing 3-year-old bugs makes me sad
00:23:31 <Sgeo> The_Journey, have you read Learn you A Haskell?
00:23:55 <Sgeo> Veinor, there's a bug in hSetBuffering stdin on Windows
00:24:01 <Sgeo> That's been for a while
00:24:18 <The_Journey> Sgeo: I have read it, but the Monad stuff is just too abstract for me. I've been trying to avoid it when writing stuff in Haskell
00:24:35 <Veinor> Sgeo: yeah, stuff like that
00:24:44 <Veinor> it just makes me feel like nobody uses haskell at all which is saddening
00:24:54 <Veinor> and that cabal-install doesn't work right on 7.2
00:24:56 <Sgeo> Apparently, no one uses Haskell on Windows?
00:25:01 * Sgeo angers
00:26:06 * Veinor grumble grumble grumble
00:26:11 <Jafet> On Windows, ghci is my calculator.
00:29:12 <hoqhuuep> Jafet, now that you mention that... it might be a cool idea to map the calculator button on my keyboard to GHCi... hmm
00:29:50 <rwbarton> what is hSetBuffering stdin NoBuffering supposed to do exactly? it doesn't seem to put the terminal into raw mode.
00:30:35 <Sgeo> Or maybe it was stdout
00:30:38 <Jafet> Raw and visceral
00:30:43 <shachaf> rwbarton: It doesn't?
00:30:52 <quicksilver> it stops the IO layer buffering it
00:30:53 <lambdabot> quicksilver: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:30:55 <rwbarton> no, and I wouldn't expect it to... that is another thing.
00:30:56 <Jafet> stdin is not a terminal.
00:30:57 <quicksilver> it doesn't stop your terminal buffering
00:31:00 <rwbarton> right.
00:31:06 <Guest1083> rwbarton: It should remove the input buffer, but I think you'll still have to press enter to send things
00:31:06 <shachaf> It seems to stop my terminal buffering.
00:31:10 <shachaf> Unless I'm misunderstanding.
00:31:18 <rwbarton> are you testing in ghci?
00:31:21 <shachaf> No.
00:31:23 <Jafet> To adjust your terminal, use stty.
00:31:46 <rwbarton> my program is main = do { hSetBuffering stdin NoBuffering; hSetBuffering stdout NoBuffering; getLine >>= putStrLn }
00:32:07 <rwbarton> aha, getLine isn't lazy IO
00:32:10 <shachaf> rwbarton: Try getChar.
00:32:17 <rwbarton> yep
00:32:18 <shachaf> Right. getLine will get a line.
00:32:35 <shachaf> Thank the $WHATEVER.
00:32:38 <rwbarton> I switched to getContents and now I see what you see.
00:32:48 <shachaf> Lazy I/O. :-(
00:32:56 <rwbarton> ITYM ":D".
00:33:08 <rwbarton> Anyways, I'm disturbed that hSetBuffering stdin NoBuffering actually does this.
00:33:52 <Jafet> You're disturbed that hSetBuffering stdin NoBuffering sets the buffering mode for stdin to have no buffering?
00:34:26 <rwbarton> No, I'm disturbed that it calls ioctl().
00:34:26 <Sgeo> Jafet, I'm disturbed when it doesn't do that on Windows.
00:34:37 <Jafet> Oh, heh
00:34:38 <shachaf> Jafet: I think rwbarton is disturbed that the two types of buffering -- Handle buffering and terminal buffering -- are conflated.
00:34:43 <rwbarton> yep.
00:34:50 <Jafet> That might be disturbing.
00:34:59 <rwbarton> if I call setbuf(stdin, NULL); or whatever in C, that doesn't happen.
00:35:52 <rwbarton> (My understanding is that setbuf(stdin, NULL); actually does nothing whatsoever, but that's a different matter)
00:37:00 <rwbarton> so I have a hard time considering its failure to do this on Windows to really be a bug
00:37:45 <rwbarton> Perhaps this is just me expecting Haskell to be the same as C when I shouldn't, though.
00:38:20 <Sgeo> http://hackage.haskell.org/trac/ghc/ticket/2189
00:39:00 <rwbarton> It seems to me like there should be a separate (ideally non-OS-specific) interface for "disable terminal buffering".
00:39:45 <Jafet> ncurses. For when one curse is not enough.
00:39:52 <shachaf> Does setBuffering do this in general for Handles?
00:40:00 <shachaf> How does it decide when to do it or not do it?
00:40:23 <arw> does it know about terminfo or stuff?
00:40:36 <rwbarton> I would imagine when it determines that the handle is an input handle and is connected to a terminal
00:42:11 <bss03> My hoogleing skills are failing me.  How do I get the 4-byte IEEE floating point representation of a Float?  Also, the other way 'round.  I am trying to serialize/deserialize a file format that uses that.
00:42:36 <bss03> http://www.ennex.com/~fabbers/StL.asp#Sct_binary <-- the file format.
00:43:49 <opqdonut> bss03: just a sec
00:44:08 <quicksilver> bss03: http://hackage.haskell.org/package/data-binary-ieee754-0.4.2.1
00:44:15 <opqdonut> http://stackoverflow.com/questions/8601030/how-can-i-convert-between-float-and-word8/8601410
00:44:34 <opqdonut> cereal-ieee754 also
00:44:55 <opqdonut> oh, "cereal-ieee754 belongs now to cereal"
00:45:02 <rwbarton> From strace it looks like it does an ioctl(handle, TCGETS, &buf) and if that doesn't return ENOTTY and it was a reading handle, it munges some bits in buf and does a TCSETS.
00:45:47 <Jafet> rwbarton: with the best of intentions, naturally
00:46:18 <bss03> Darn, was hoping the Haskell-Platform had something.
00:46:46 <bss03> Still, thanks opqdonut and quicksilver.
00:46:57 <Sgeo> Hold on
00:46:59 <rwbarton> yes, it's likely that if someone writes "hSetBuffering stdin NoBuffering", they would like this to happen
00:47:09 <Veinor> i really dislike version dependencies
00:47:14 <bss03> I'll either use cereal or duplicate that little bit of code.
00:47:25 <shachaf> Hmm, hSetBuffering actually calls isatty().
00:47:29 <rwbarton> It's a little DWIMmy for my taste, though.
00:47:43 <Veinor> i'm trying to cabal install darcs and it's breaking because i have unix-2.5
00:48:01 <rwbarton> shachaf: Yeah, what I wrote must be the implementation of isatty in libc.
00:48:07 <rwbarton> The first half, that is
00:48:18 <rwbarton> that also explains why it does two TCGETSs
00:49:02 <rwbarton> (Well, actually it does five.)
00:49:02 <shachaf> rwbarton: «-- 'raw' mode under win32 is a bit too specialised (and troublesome for most common uses), so simply disable its use here.»
00:50:24 <gienah> Veinor: darcs can be convinced to build with unix-2.5: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-vcs/darcs
00:50:47 <Veinor> yeah, i just decided to install from repo
00:51:11 <gienah> Veinor: hopefully darcs can build from darcs
00:52:14 <Veinor> :v
00:52:44 <Veinor> i guess the question is
00:52:49 <Veinor> why is cabal-install at 0.13.3 in the darcs repo
00:52:53 <rwbarton> shachaf: My impression from reading http://hackage.haskell.org/trac/ghc/ticket/2189 is that Windows just doesn't provide a terminal mode which is ordinary file IO but also character-at-a-time.
00:52:53 <Veinor> but only at 0.10 on hackage?
00:53:13 <shachaf> rwbarton: Sounds like a Windowsy thing not to provide.
00:53:16 <ski> @hoogle encodeFloat
00:53:16 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
00:53:17 <ski> @hoogle decodeFloat
00:53:17 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
00:53:28 <ski> bss03 : not sure whether you want that or something else
00:54:03 <erus`> How long can i go not  programming without losing my mad skills?
00:54:07 <ski> hm, i suppose not quite that
00:54:20 <Veinor> in particular 0.13.3 actually builds on 7.2, i think
00:54:25 <bss03> ski: Nah, that's not using IEEE encoding, which I need.
00:54:49 <Sgeo> > encodeFloat 2 2
00:54:50 <lambdabot>   8.0
00:54:53 <Sgeo> > encodeFloat 2 4
00:54:54 <lambdabot>   32.0
00:55:00 <Sgeo> > encodeFloat 3 4
00:55:01 <lambdabot>   48.0
00:55:01 <bss03> ski: Thanks though; I'll probably fake it for now and use cereal.
00:55:15 <gienah> Veinor: the cabal-install included in ghc 7.4.1-rc1 is 0.13.3
00:55:21 <bss03> decodeFloat pi
00:55:25 <bss03> > decodeFloat pi
00:55:25 <Veinor> ahh
00:55:25 <lambdabot>   (7074237752028440,-51)
00:55:29 <ski> > encodeFloat (-1) 2
00:55:29 <lambdabot>   -4.0
00:55:33 <Veinor> ok, as long as 7.4 fixes things, i'm happy
00:55:47 <bss03> > decodeFloat (pi :: Float)
00:55:48 <lambdabot>   (13176795,-22)
00:56:03 <ski> > encodeFloat 2 (-3)
00:56:03 <lambdabot>   0.25
00:56:31 <gienah> Veinor: I built darcs 2.5.2 with patches with ghc 7.4.1-rc1 (and submitted the patches)
00:56:34 <yitz> @type decodeFloat
00:56:35 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
00:57:00 <ski> (erus` : maybe try programming on paper ?)
00:57:33 <bss03> > 7074237752028440 * 2 ^^ (-51)
00:57:34 <lambdabot>   3.141592653589793
00:57:47 <erus`> ski: what will that achieve ?
00:57:57 <Rc43> Hi, guys.
00:59:18 <yitz> erus`: why aren't you programming?
00:59:19 <lambdabot> yitz: You have 1 new message. '/msg lambdabot @messages' to read it.
00:59:58 <erus`> yitz: I havnt had the urge to for a month or so now.
01:00:29 <ski> erus` : well, i was supposing that you for some time wouldn't have access to a computer
01:00:52 <ski> lo, Rc43
01:02:58 <yitz> erus`: write some poetry
01:03:54 <erus`> I think its the anxiety pills im on, making me really lazy
01:08:49 <Jafet> You need pills to be lazy?
01:09:01 <Jafet> My sympathies.
01:09:35 <silver> don't be :S
01:58:40 <shachaf> edwardk: Is comonad.com supposed to be down, by the way?
02:06:53 <bss03> That's annoying.  The haskell2010 package has a System.IO that doesn't contain nativeNewline :(
02:24:41 <bss03> > f $ x $ y
02:24:42 <lambdabot>   Couldn't match expected type `a -> b'
02:24:42 <lambdabot>         against inferred type `Simple...
02:28:29 * Sgeo copy-pastes and manipulates a bunch of code produced by that other thing
02:35:15 <Sgeo> int sequence[3][3]
02:35:28 <Sgeo> That should be a Ptr CInt or a Ptr (Ptr CInt)?
02:36:54 <bss03> Ptr CInt, pretty sure.
02:38:48 <quicksilver> ptr cint, yes. multidimensional arrays in C are just shorthand for arithmetic
02:38:52 <quicksilver> they are not arrays of pointers.
02:38:56 <bss03> int (*sequence[3])[3] is the other way.
02:39:31 <Sgeo> Ok, thanks
02:39:42 <Sgeo> Thought HSFFIG made a mistake
02:40:02 <Sgeo> (I'm not using it anymore due to dependency issues, but I am copy/pasting the code it generated earlier)
02:47:56 <etpace> hmm, does anyone know what the notation of a union symbol with a + in it usually means?
02:48:28 <quicksilver> direct sum or occasionally disjoint union
02:48:42 <quicksilver> it's one of those symbols that authors feel free to redefine though
02:49:10 <etpace> hmm, its not defined -- i think its disjoint union in this context
02:49:22 <etpace> as theyve redefined square union
02:49:28 <etpace> which ive seen as disjoint before
02:50:25 <etpace> http://gallium.inria.fr/~naxu/research/arity.pdf figure 6, (let) if it helps
03:02:08 <rtharper> If I hav a 64-bit processor, is there any reason not to use the 64-bit haskell platform?
03:02:20 <rtharper> (on OS X)
03:03:06 <irene-knapp> I can conceive of a reason - it might be around memory efficiency, say - but you should probably be using it, yes
03:05:08 <Jafet> The old oh no, my Strings use forty bytes per character instead of twenty?
03:05:14 <irene-knapp> yes, that
03:05:24 <mrcarrot> is there a way to do a cabal install of an older version of something from hackage?
03:05:51 <bss03> mrcarrot, yes cabal supports specifying a particular version.
03:06:22 <mrcarrot> bss03: do you happen to know how? "man cabal" is not existing
03:06:24 <Kanisterschleife> Hi. I have a data type Flag and want to make the type Flag -> Bool an instance of Eq. What's wrong with "instance Eq (Flag -> Bool) where ..." ?
03:06:35 <bss03> mrcarrot: cabal install --help
03:07:05 <arw> Jafet: seriously? really? forty bytes?
03:07:33 <irene-knapp> well, it's two machine words for the cons cell's pointers and one for its constructor, right
03:07:43 <irene-knapp> and then one machine word for the character's constructor and one for its data
03:07:47 <irene-knapp> and each machine word is eight bytes
03:07:59 <bss03> mrcarrot: "cabal install binary-0.2" could work, even though "cabal install binary" will give version 0.5.0.2
03:08:00 <irene-knapp> the exact numbers are not quite that because I don't remember all the details
03:08:10 <irene-knapp> but yes, it's pretty bad :( you should use ByteString or Text for anything nontrivial
03:08:24 <mrcarrot> bss03: thanks
03:09:53 <Kanisterschleife> Can somebody explain me what's wrong with "instance Eq (Flag -> Bool) where ... "?
03:10:14 <bss03> Kanisterschleife: Oh, sure, it violates the langauge spec.
03:10:15 <quicksilver> Kanisterschleife: haskell98 has some simplistic restrictions on the shape instances may take.
03:10:28 <quicksilver> there is a non-controversial extension to lift them
03:10:35 <quicksilver> FlexibleInstances
03:10:44 <irene-knapp> okay, but even FlexibleInstances doesn't allow function types, does it?
03:10:55 <bss03> Will flexible instances work here?
03:11:14 <Kanisterschleife> bss03, quicksilver: Oh ok... I didn't know that. What's the reason one exlcudes such types like a -> b?
03:11:23 <bss03> I do know you'll have to spell (Flag -> Bool) as ((->) Flag Bool), for silly reasons.
03:11:38 <Jafet> There's an extension for that too
03:11:57 <merijn> This is starting to sound like an Apple commercial
03:12:03 <Kanisterschleife> bss03: is -> treated like a type constructor with two free variables?
03:12:05 <merijn> "There's an extension for that!"
03:12:07 <quicksilver> Kanisterschleife: the people writing the langauge standard imagined that instances for parametric types should be parametric.
03:12:10 <irene-knapp> the basic reason to exclude them originally, I imagine, was that there was no previous implementation
03:12:20 <irene-knapp> well, -> /is/ a type constructor with two free variables
03:12:33 <irene-knapp> just, one with a special meaning
03:13:13 <Kanisterschleife> irene-knapp: ok
03:13:25 <quicksilver> bss03 is quite wrong about ((->) Flag Bool)
03:13:29 <Kanisterschleife> bss03: instance Eq ((->) Flag Bool) doesn't work
03:13:33 <quicksilver> instance Eq (Flag -> Bool) where works fine
03:13:37 <bss03> Kanisterschleife: There's also the problem of having an instance for a -> a and an instance for Int -> Int.  If you do that, you need another extension.
03:13:51 <irene-knapp> well, those are overlapping instances
03:13:52 <quicksilver> with appropriate extension
03:14:13 <irene-knapp> two instances, one for Int -> Bool and one for Char -> Bool, for example, ought to work fine
03:14:15 <quicksilver> bss03: if you need that, you're screwed. That extension is a bug.
03:14:48 <quicksilver> this compiles fine, anyhow ; http://hpaste.org/56026
03:15:07 <Kanisterschleife> Hm, I cannot follow you all so quickly :-) Is there any way to define (==) for a type like Flag -> Bool? I tried instance Eq (Flag -> Bool) and instance Eq ((->) Flag Bool) so far
03:15:07 <quicksilver> it does *also* compile fine if you spell it ((->) Flag Bool)
03:15:24 <quicksilver> but there's nothing wrong with the normal spelling
03:15:38 <Kanisterschleife> Ok, I missed the "flexible instances"
03:15:39 <Jafet> merijn: what's Apple for -fglasgow-exts?
03:16:08 <irene-knapp> yeah, put {-# LANGUAGE FlexibleInstances #-} as the first line of your source file
03:16:10 <irene-knapp> to turn it on
03:16:18 <bss03> Oh, hrm, that's a change, I think.  I never tried it myself, but I seem to remember the Monad ((->) a) instance being spelled that way.
03:16:24 <Kanisterschleife> irene-knapp: yes, just tried it, and now it's fine
03:16:26 <irene-knapp> great
03:16:27 <bss03> Maybe that was just because it was partial application.
03:16:40 <maltem> it is
03:17:11 <Kanisterschleife> thank you all!
03:18:21 <Sgeo> Is there a list of extensions with whether they're non-controversial or evil somewhere?
03:18:26 <bss03> So, no type constructor sections? -- I guess that's why I need TupleSections for (,x) and (x,) ;)
03:18:45 <McManiaC> http://npaste.de/JUT4/ my list layout GHC extension – what do you guys think? :)
03:18:51 <Sgeo> bss03, that sounds like a different concern?
03:19:03 <arw> i get "accept: resource exhausted (Too many open files)", so my program is leaking file descriptors. any chance to find out where?
03:19:42 <merijn> arw: Are you using lazy IO?
03:19:49 <bss03> Well, there's at least 5 extensions that are barely extensions anymore:
03:20:08 <bss03> PatternGuards, NoNPlusKPatterns, RelaxedPolyRec, EmptyDataDecls, ForeignFunctionInterface, and Haskell2010.
03:20:13 <arw> merijn: yes, but i'm also using hClose after forcing the rest of the IO.
03:20:25 <bss03> > (,2) 1
03:20:25 <lambdabot>   Illegal tuple section: use -XTupleSections
03:20:45 <arw> merijn: but eradicating hGetContents could be a good idea anyways.
03:21:06 <frerich> Hi, I just read a simple but (IMHO) interesting question on StackOverflow: somebody writes 'what I am trying to do is have a function like this: f (a:b:c:d:is) = ... but be able to refer to a:b:c:d without writing it again'. My first thought was "as-patterns" but it turns out 'f (e@(a:b:c:d):xs)' won't work since that means that the argument is a list of lists. Does anybody know if this is possible using pattern
03:21:06 <frerich>  matching (I think it isn't) and if it isn't - why?
03:21:08 <Sgeo> bss03, but that's not a type, so that has nothing to do with type constructor sections. I guess that's the joke
03:21:15 <merijn> arw: See it as an opportunity to learn iteratees (then again maybe not, I haven't really gotten around to it :p)
03:22:15 <bss03> frerich: a:b:c:d isn't a valid haskell expression, which is why you can't match it or use it elsewhere.
03:22:15 <Jafet> frerich: occurs check
03:22:31 <irene-knapp> well, it IS a valid Haskell expression, but with d as a list
03:22:36 <arw> merijn: no, i'd rather see it as an opportunity to do everything with strict IO and also to implement timeouts for the IO since its on network sockets.
03:22:52 <maltem> frerich, it isn't because a prefix of a list is not a subexpression of it
03:22:58 <bss03> Sorry, the a:b:c:d part of a:b:c:d:e is not a valid haskell expression.
03:23:06 <irene-knapp> yeah
03:23:09 <bss03> d can't be both :: a and :: [a].
03:23:24 <quicksilver> also you can't as-pattern anything except the whole pattern anyway, can you?
03:23:30 <irene-knapp> yes, you can, qs!
03:23:32 <irene-knapp> I do it all the time!
03:23:37 <quicksilver> oh, interesting
03:23:45 <koeien> > let (x:(y@(z:zs)) = [1,2,3,4] in y
03:23:46 <lambdabot>   <no location info>: parse error on input `='
03:23:51 <koeien> > let (x:(y@(z:zs))) = [1,2,3,4] in y
03:23:52 <lambdabot>   [2,3,4]
03:23:55 <irene-knapp> you can't as-pattern a subfragment unless that fragment is itself a valid pattern? which it usually is, just not in this case :)
03:24:07 <bss03> > l@(h:t@(n:_) = [1,2,3] in n
03:24:07 <lambdabot>   <no location info>: parse error on input `='
03:24:14 <bss03> > let l@(h:t@(n:_) = [1,2,3] in n
03:24:14 <lambdabot>   <no location info>: parse error on input `='
03:24:18 <quicksilver> irene-knapp: not "valid pattern" but "syntactically correct sub-pattern" then.
03:24:19 <bss03> > let l@(h:t@(n:_)) = [1,2,3] in n
03:24:20 <lambdabot>   2
03:24:24 <irene-knapp> yes, indeed, rather
03:24:27 <bss03> > let l@(h:t@(n:_)) = [1,2,3] in t
03:24:28 <lambdabot>   [2,3]
03:24:29 <bss03> > let l@(h:t@(n:_)) = [1,2,3] in l
03:24:29 <lambdabot>   [1,2,3]
03:24:50 <Jafet> @quote best.view
03:24:51 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
03:25:57 <bss03> Wow, I'm a bit surprised that parsed. :P
03:27:39 <Sgeo> Someone else who wrapped this library for C# is doing C# async stuff with it
03:28:02 <Sgeo> Should I continue on my goal to just use threads, or might there be a reason for me to try to find an equivalent in Haskell?
03:28:27 <merijn> Sgeo: Equivalent of what?
03:28:39 <Sgeo> C#'s async stuff
03:28:41 <merijn> Asynchronous library?
03:29:09 <merijn> Doesn't exist in haskell because the runtime already uses epoll/select/kqueue for blocking IO by threads
03:29:28 <koeien> (i.e. it's not necessary)
03:29:42 <koeien> forkIO is very lightweight
03:29:50 <Sgeo> I mean to treat stuff that uses callbacks as though it was synchronous without threading
03:30:11 <Sgeo> Making this library threadsafe in and of itself is not lightweight
03:30:27 <Sgeo> (As in, it will slow the library down, since I have to lock and do some operations every operation)
03:30:36 <bss03> Wasn't there a blog post in December about re-inversion of control.
03:30:39 <merijn> Sgeo: Ah, so you want to use a non-threadsafe library from multiple threads in haskell?
03:30:51 <merijn> bss03: Not December, but yes
03:30:58 <merijn> You mean the OpenGL one, I think
03:30:59 <Sgeo> merijn, fake synchronous programming with a non-threadsafe asynchronous library
03:31:18 <bss03> Basically using the Cont monad to write OpenGL code "sans" callbacks.
03:31:42 <merijn> Sgeo: Just have a single thread responsible for interacting with the asynchronous library and have haskell communicate all things through that one thread?
03:31:44 <Sgeo> merijn, why does the person who do that use Cont instead of threading
03:31:45 <Sgeo> ?
03:32:05 <merijn> Sgeo: OpenGL expects to always be called from the same OS thread
03:32:08 <opqdonut> the Cont OpenGL thing is awesome
03:40:38 <Sgeo> Are MVars appropriate if I need to atomically do IO?
03:40:56 <koeien> you want to have mutual exclusion?
03:41:07 <Sgeo> takeMVar, blah, putMVar
03:41:09 <Sgeo> Yes
03:41:09 <bss03> That or STM are, I think, the basic methods.
03:41:09 <koeien> then you can use an MVar (), yes
03:41:21 <Sgeo> bss03, I thought I can't do IO inside an STM?
03:41:26 <koeien> IO in STM is not "safe", in the sense that it could be executed more than once
03:41:49 <koeien> Sgeo: it's possible with an unsafePerformIO-function, but it's unsafe.
03:42:00 <merijn> So you just need to make sure your IO actions are idempotent :p
03:42:15 <Sgeo> The action in question is idempotent, as it turns out
03:42:22 <koeien> anyway, MVar () is the better solution
03:42:28 <bss03> koeien: I thought STM was specifically "wired" to detect unsafePerformIO and reject it when atomically is called.
03:42:48 <Sgeo> Ok
03:42:52 <koeien> bss03: there is unsafeSTMToIO or something.
03:44:46 <Kanisterschleife> What concepts of category theory apart from categories, functors, monads are are of importance in computer science or especially Haskell?
03:45:33 <merijn> Kanisterschleife: http://reperiendi.wordpress.com/2007/11/03/category-theory-for-the-java-programmer/
03:45:40 <bss03> I've heard talk of catamorphisms and anamorphisms (generalized fold-ish stuff).
03:46:44 <koeien> yes F-algebras
03:46:45 <Kanisterschleife> I know category theory well but don't know how widespread it's applications in CS are, that's why I ask.
03:47:16 <arw> Kanisterschleife: the applications are somewhat more widespread than the understanding and terminology.
03:48:05 <Kanisterschleife> arw: What do you mean by that?
03:49:00 <arw> people use mathematical constructs without knowing what they are called or what the theoretical background is.
03:49:10 <Kanisterschleife> ok
03:50:35 <maltem> arguably, category theory is the science that gives everything a theoretical background
03:51:21 <arw> best example: database people using relational algebra. "what the hell is that? i only know tables and select"
03:52:21 <bss03> Relational algebra is a lot prettier than the stuff that some of my previous workplaces have called SQL.
03:53:38 <arw> yes, thats a symptom of SQL implementers not knowing about the algebra part and stupidly hacking on it till it does stuff :)
03:54:29 <arw> (also, there is of course useful stuff that doesn't fit the theory)
03:59:33 <dibblego> @type \p a s -> if p then return a else fail s
03:59:34 <lambdabot> forall a (m :: * -> *). (Monad m) => Bool -> a -> String -> m a
03:59:48 <dibblego> @type \p a -> if p then return a else mzero
03:59:49 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => Bool -> a -> m a
03:59:55 <dibblego> is this in the standard library?
04:00:37 <merijn> @hoogle (MonadPlus m) => Bool -> a -> m a
04:00:37 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
04:00:37 <lambdabot> Control.Exception assert :: Bool -> a -> a
04:00:38 <lambdabot> Control.OldException assert :: Bool -> a -> a
04:00:50 <merijn> dibblego: Apparently not :p
04:01:06 <MostAwesomeDude> @hoogle when
04:01:07 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
04:01:07 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
04:01:07 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
04:01:55 <bss03> :t either fail return
04:01:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => Either String a -> m a
04:02:35 <bss03> :t \p a s -> either fail return $ if p then Right a else Left s
04:02:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => Bool -> a -> String -> m a
04:03:00 <bss03> diblego: ^^ maybe like that?
04:04:33 <bss03> :t either error id
04:04:34 <lambdabot> forall b. Either [Char] b -> b
04:06:20 <koeien> :t guard
04:06:21 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:06:30 <koeien> > guard True >> return 3
04:06:31 <lambdabot>   No instance for (GHC.Show.Show (m t))
04:06:31 <lambdabot>    arising from a use of `M8082205435...
04:06:36 <koeien> > guard True >> return 3 :: Maybe Integer
04:06:37 <lambdabot>   Just 3
04:06:41 <koeien> > guard False >> return 3 :: Maybe Integer
04:06:42 <lambdabot>   Nothing
04:13:49 <exFalso> good day
04:13:49 <exFalso> i have a weird problem. running this trivial program http://pastebin.com/44Tn7Wav in ghci with ":run main argument" will print the expected ["argument"].
04:13:49 <exFalso> however when one first does ":break main" and then ":run ..." and ":continue" it prints [].
04:13:49 <exFalso> does anyone know why this happens?
04:13:51 <mauke> The paste 44Tn7Wav has been copied to http://hpaste.org/56027
04:15:49 <exFalso> :break seems to make it "forget" about cli arguments...(?)
04:24:58 * hackagebot kqueue 0.1.2.2 - A binding to the kqueue event library.  http://hackage.haskell.org/package/kqueue-0.1.2.2 (ErikHesselink)
04:28:23 <yitz> exFalso: worked for me
04:28:59 <yitz> but it actually didn't stop, it just ran right through even after i set that breakpoint.
04:54:24 <mrcarrot> i am trying out of curiousity leksah. is it normal that the first collecting of information about packages takes really, really long time. i have now been waiting maybe 5 mintures and got it to about 30%
04:59:44 <hpc> what does this error mean? http://hpaste.org/56029
05:00:00 <hpc> im getting it in ghc 7.0.4
05:00:13 <hpc> the exact same code was warning-free in 6.12
05:01:07 <byorgey> hpc: it's a warning that is displayed by mistake
05:01:28 <hpc> heh
05:01:30 <byorgey> it's just a warning that potential optimizations are not being performed
05:01:58 <hpc> ill just remember to ignore it then
05:02:02 <byorgey> yep
05:02:51 <hpc> and with that out of the way, im finally done upgrading this computer to debian testing
05:02:58 <hpc> everything from before is reinstalled and running
05:19:18 <Sgeo> There's nothing wrong with writing custom marshaling functions for non-Storables, right?
05:33:02 <ww_> hi
05:33:26 <byorgey> hi ww_
05:34:31 <ww_> i'm reading "learn you a haskell for great good"
05:35:03 <quicksilver> good idea.
05:35:56 <hpc> well that was brief
05:36:19 <quicksilver> but he will surely achieve great good none the less
05:36:25 <opqdonut> maybe he just wanted to announce it
05:36:29 <opqdonut> come out of the closet, kinda
05:37:21 <byorgey> hahaha
05:37:44 <byorgey> announcing it in #haskell hardly counts as coming out of the closet.
05:38:12 <byorgey> it's like telling the other person in the closet that you are in a closet.
05:38:36 <dgpratt> byorgey: :-)
05:39:19 <mokus> maybe that was to announce he's coming _into_ the closet
05:39:25 <mux> it was so that we could reach his family to explain them, in case they don't hear about him for several months
05:39:37 <mux> a bit like "if you don't hear from me in 1 hour, tell my wife I loved her"
05:40:02 <benj_> I spent most of my christmas holiday reading LYAH
05:40:13 <benj_> I tried to learn a bit of coq, too
05:40:35 <dgpratt> benj_: Coq?! :-O
05:40:57 <benj_> that might be more of a coming-out-of-the closet moment, if there were a book called "get you some coq", and you announced to everyone, "I'm getting me some coq"
05:41:22 <mokus> for great good!
05:41:38 <byorgey> hehehe
05:47:45 * frerich snickers
05:48:29 <Botje> coq with barbecue sauce. hmmmm :)
05:51:34 <McManiaC> byorgey: http://hackage.haskell.org/trac/ghc/ticket/5744
05:51:55 <Yrogirg> How do I sum two IO A? So (return a) + (return b) was return (a + b)?
05:52:20 <McManiaC> Yrogirg: (+) <$> ioa <*> iob
05:52:23 <McManiaC> ;D
05:52:55 <Yrogirg> McManiaC, what package is it?
05:53:07 <McManiaC> Control.Applicative
05:53:15 <byorgey> it's in the base package
05:53:27 <McManiaC> oooor you could simply do the old fashioned way do { a <- ioa; b <- iob; return (a+b) }
05:53:54 <Yrogirg> no, I'll try applicative, thank you
05:54:08 <quicksilver> liftM2 (+) ioa iob
05:54:13 <quicksilver> might be easier to read in this case
05:54:24 <quicksilver> the <$> <*> way is definitely worth knowing though.
05:54:53 <byorgey> McManiaC: nice!
05:58:55 <Yrogirg> what's the difference between liftM2 and liftA2 ?
05:59:23 <opqdonut> :t liftA2
05:59:24 <Sgeo> liftM2 only works for Monads, liftA2 is supposed to work for all applicatives
05:59:24 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
05:59:25 <quicksilver> in your example, Yrogirg, nothing at all.
05:59:27 <opqdonut> :t liftM2
05:59:28 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:59:34 <Sgeo> In theory, when both are defined, they're supposed to be exactly the same.
05:59:45 <opqdonut> yeah, what Sgeo said
05:59:45 <quicksilver> but liftA2 is slightly more general since in principle Applicatives are a wider class than Monads
06:00:04 <geekosaur> but for historical reasons (meaning, Applicative didn't exist at the time) not all Monads are Applicatives
06:00:10 <byorgey> in practice, when both are defined, if they're not exactly the same #haskell will break your knees
06:00:49 <quicksilver> or attack you with analogies about broken glass
06:01:01 <Sgeo> analogies about broken glass?
06:01:11 <Sgeo> I've never seen such an analogy
06:01:13 <geekosaur> (the same applies for Functor's fmap vs. Monad's liftM, btw)
06:01:27 <quicksilver> @quote quicksilver.*glass
06:01:28 <lambdabot> No quotes match. :(
06:01:36 <quicksilver> @quote quicksilver.*Overlapping
06:01:36 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
06:01:39 <quicksilver> :(
06:01:43 <quicksilver> well, it's gone
06:01:48 <hpc> @quote glass
06:01:48 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
06:01:48 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
06:02:33 <quicksilver> oh, it's not gone.
06:02:38 <quicksilver> but regexp search doesn't work any more?
06:03:03 <Saizan> i think the author is not part of what the regex searches
06:03:18 <mokus> i'm pretty sure @quote treats the author as a separate field, so you want something like @quote quicksilver glass
06:03:26 <quicksilver> @quote broken.*glass
06:03:26 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
06:03:26 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
06:03:26 <hpc> @quote quicksilver glass
06:03:27 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
06:03:27 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
06:03:29 <quicksilver> aha.
06:03:34 <quicksilver> live and learn.
06:03:34 <hpc> yay
06:03:40 * Sgeo prods quicksilver with an Incoherent Instance
06:04:01 * quicksilver dissipates and reforms elsewhere
06:04:28 * Sgeo actually has no idea what IncoherentInstances does, except it's an extension to OverlappingInstances
06:11:00 <gavri> I was learning about applicative functors and I keep coming across how applicative functors sequence actions. I don't see it though. at least not with the basic examples involving <$> and <*>
06:11:14 <gavri> how do I understand the sequencing aspect of this whole thing?
06:11:21 <gavri> what exactly is sequenced with:
06:11:36 <gavri> (^) <$> 3 <*> 4
06:12:08 <hpc> gavri: in that case, nothing is sequenced
06:12:13 <hpc> gavri: here's a better example
06:12:29 <hpc> printAndReturnSucc = putStrLn "succ" >> return succ
06:12:33 <Kanisterschleife> Trying to install xmobar via cabal I get the error line: "Unsupported extension: DoAndIfThenElse". Can somebody tell me what could be wrong here?
06:12:39 <hpc> printAndReturnFive = putStrLn "five" >> return 5
06:12:53 <hpc> gavri: printAndReturnSucc <*> printAndReturnFive prints
06:12:55 <hpc> succ
06:12:56 <hpc> five
06:13:06 <hpc> and then returns 6
06:13:07 <Saizan> Kanisterschleife: your version of ghc
06:13:19 <gavri> so it's sequenced since one part of the expression depends on the other?
06:13:22 <Saizan> Kanisterschleife: or cabal maybe
06:13:26 <gavri> isn't that true of any kind of function application?
06:13:53 <hpc> gavri: it "sequences" in the same sense as (>>=)
06:13:58 <mokus> it's sequenced because in monads that model "doing things", it causes the things to be done in left-to-right order
06:13:59 <koeien> Kanisterschleife: you need to upgrade ghc and/or cabal
06:14:11 <mokus> er, s/monads/applicatives/
06:14:17 <Kanisterschleife> Saizan, koeien: I installed both cabal and ghc via apt-get from stable repos
06:14:18 <hpc> also that
06:14:28 <koeien> Kanisterschleife: debian stable?
06:14:31 <Kanisterschleife> koeien: yes
06:14:37 <koeien> that's probably too old, yes :(
06:14:38 <gavri> so things are always sequenced, but here the direction is explicit?
06:14:50 <Kanisterschleife> koeien: Hm, and how can I upgrade?
06:14:58 <koeien> Kanisterschleife: install GHC from haskell.org/ghc
06:15:03 * hackagebot continued-fractions 0.9.1.1 - Continued fractions.  http://hackage.haskell.org/package/continued-fractions-0.9.1.1 (JamesCook)
06:15:14 <koeien> after that, install the haskell platform
06:15:15 <Kanisterschleife> koeien: ... or is this a bad idea? won't I mix stable and unstable then?
06:15:37 <koeien> Kanisterschleife: GHC installs in /usr/local.
06:15:38 <gavri> hpc, mokus: so things are always sequenced, but here the direction is explicit?
06:15:48 <koeien> Kanisterschleife: /usr/local is reserved, debian won't touch that
06:16:49 <mokus> gavri: in regular function calls, things are not explicitly sequenced by their definitions, but rather implicitly sequenced depending on details about how they are used
06:17:06 <Kanisterschleife> koeien: Hm ok. Sorry for these noob questions, but what way would you suggest now to install ghc? Is there some debian repo on haskell.org where I can get ghc from, or should I download it as a tarball and install by hand?
06:17:37 <hpc> Kanisterschleife: depends on what version you want; if you need the latest, download from haskell.org
06:17:51 <mokus> gavri: applicative functors (and monads, more so) allow you to explicitly sequence actions as a part of their definition
06:17:52 <koeien> Kanisterschleife: download the tarball, unpack, ./configure, make install
06:17:52 <hpc> if you want an easier install at the expense of some minor datedness, apt-get it
06:18:07 <Kanisterschleife> koeien: I will try
06:18:12 <hpc> don't compile from source - it's a pain in the ass and not necessary
06:18:36 <koeien> Kanisterschleife: yeah you can just download the binary package, make sure to select the correct architecture
06:18:51 <koeien> (you can compile from source -- it's possible but just slower and unnecessary)
06:19:00 <gavri> I get how it happens with monads since the second argument to bind depends on the first argument's evaluation
06:19:10 <gavri> I don't get how it's true of applicative functors though
06:19:21 <gavri> I'll look at those examples
06:19:26 <gavri> and figure it out
06:19:27 <hpc> gavri: it happens in the definition of (<*>)
06:19:31 <koeien> Kanisterschleife: be sure to download version 7.0.4
06:19:45 <Kanisterschleife> koeien: and not 7.2.2?
06:20:02 <hpc> gavri: you know how sequencing for monads works, so this might help
06:20:18 <hpc> gavri: fm <*> xm = do
06:20:21 <Kanisterschleife> koeien: Should I reinstall haskell-platform, too? I also installed it via apt-get
06:20:22 <hpc>   f <- fm
06:20:26 <hpc>   x <- xm
06:20:27 <mokus> gavri: I don't think it's _necessary_ in the case of applicative functors, and I personally wouldn't have put any emphasis on it - it's got more to do with the fact that (I believe) they are defined to require (<*>) to coincide with "ap" in the case where the applicative functor is also a monad
06:20:29 <hpc>   return (f x)
06:20:51 <Saizan> tbf, "sequencing" is not really relevant for all the applicative functors, or all the monads even, but it's common enough
06:21:01 <hpc> gavri: that's the definition of (<*>) for all applicatives that are also monads
06:21:17 <koeien> Kanisterschleife: yes
06:21:38 <koeien> Kanisterschleife: but first you need GHC 7.0.4 (not 7.2.2)
06:21:52 <Kanisterschleife> koeien: First, GHC 7.0.4, then haskell-platform?
06:21:56 <koeien> yes
06:22:08 <quicksilver> haskell-platform includes GHC
06:22:14 <quicksilver> you don't need to install GHC first
06:22:16 <srhb`> Are seq and $! used for basically the same thing?
06:22:18 <koeien> quicksilver: for linux you need to install the binary separately no?
06:22:20 <koeien> srhb`: yes.
06:22:28 <koeien> @src ($!)
06:22:28 <lambdabot> f $! x = x `seq` f x
06:22:31 <quicksilver> I didn't think so. Perhaps I was wrong.
06:22:34 <hpc> @src seq
06:22:35 <lambdabot> Source not found. Sorry.
06:22:40 <koeien> seq is a primitive
06:22:44 <srhb`> Hah, I hadn't thought of that. Thank you.
06:23:10 <gavri> hpc, mokus, Saizan, thanks for all the help
06:23:27 <Kanisterschleife> quicksilver, koeien: I'm confused. If I had nothing installed yet, what would be the way to go to get a reasonably new version of GHC and haskell-platform?
06:23:40 <koeien> Kanisterschleife: follow the instructions on http://hackage.haskell.org/platform/linux.html
06:24:08 <koeien> the fact that you have a GHC already is not relevant
06:25:02 <Kanisterschleife> koeien: ok there I'm guided to the debian repo page, and stable doesn't seem to be enough. How can I install the unstable version without crashing my system due to the mixture of stable and unstable?
06:25:38 <koeien> Kanisterschleife: sorry. i meant the instructions under the heading "build from source"
06:25:39 <Kanisterschleife> koeien: by the way, thank you for your help! I'm very unsure about these things when it comes to things not in the stable repo
06:26:31 <koeien> Kanisterschleife: np
06:26:38 <Kanisterschleife> koeien: Ah, ok. So first ghc7.04 binary, and then haskell-platform from source. I'll try it! :-)
06:26:54 <koeien> yup. let us know if you run into trouble
06:27:27 <Sgeo> Why is haddock not making any files?
06:27:37 <Sgeo> n/m
06:28:39 <sefb1704> hello, i got a big problem. when i erase my types it compiles and if i add them like haskell tells me (:t function name and just copy what haskell gives me) it says: context differ in length ...
06:28:55 <sefb1704> when matching the type signatures
06:28:57 <koeien> sefb1704: could you paste your code?
06:28:58 <koeien> @hpaste
06:28:58 <lambdabot> Haskell pastebin: http://hpaste.org/
06:29:06 <sefb1704> okey
06:29:06 <koeien> + paste the error message
06:30:44 <hpaste> sefb1704 pasted “Mytextadventure” at http://hpaste.org/56036
06:31:49 <hpaste> sefb1704 annotated “Mytextadventure” with “Mytextadventure (annotation)” at http://hpaste.org/56036#a56037
06:32:14 <sefb1704> i added the error code at the very bottom
06:33:13 <Botje> sefb1704: why not use Int instead of that overly generic time?
06:33:15 <Botje> *type
06:34:02 <koeien> lol i must say that this is the first time i've seen this error message.
06:34:10 <koeien> but yeah, I'd use Integer there
06:34:21 <koeien> that's probably what you want.
06:34:41 <mokus> IIRC you can get past the "contexts differ in length" error with the RelaxedPolyRec language extension
06:35:08 <Saizan> yeah, the error says so
06:35:22 <mokus> it's got to do with a fairly obscure rule in the Haskell Report that's intended to make it easier to write haskell compilers
06:35:55 <Sgeo> "After describing a structure this way, you get a corresponding Haskell type as an instance of class Storable."
06:36:14 <Saizan> sefb1704: basically, you can turn on the extension without any problem
06:36:15 <Sgeo> Is there a way to suppress the Storable instance declaration in bindings-dsl?
06:36:15 <sefb1704> umm .. so what do i have to change?
06:36:41 <Saizan> put {-# LANGUAGE RelaxedPolyRec #-} at the top of your file
06:37:19 <koeien> sefb1704: what i would do is decision :: [Item] -> [Char] -> Int -> [Char] -> IO ()
06:37:19 <sefb1704> turn?
06:37:39 <sefb1704> okay, thanks i will try
06:38:12 <Kanisterschleife> koeien: I downloaded the ghc-7.0.4 binary and unpacked it. What should I do now?
06:38:20 <danr> sefb1704: seems like a nice game. I like the line "In addition, you died."
06:38:39 <sefb1704> danr: y i tried to make it funny
06:39:33 <koeien> Kanisterschleife: after tar zxvf ghc-... ; cd ghc-...; ./configure ; sudo make install
06:39:44 <xplat> i wonder why RE2 doesn't support simple things like (?|) and (?#).  i can understand not supporting (?<>) or (?'') because they're just different syntax for (?P<>), but the others ...
06:40:15 <koeien> "The signature contexts in a mutually recursive group should all be identical" ; what is meant by a "group" here? Is it a set of functions?
06:41:26 <Sgeo> I guess I could force myself to ignore the Storable instance.
06:41:29 <Sgeo> But that seems ugly
06:41:31 <xplat> also the lack of (?=) and (?!) is disturbing, and those assertions are actually regular and can be perfectly supported by a finite automaton, although they actually involve work
06:41:37 <Saizan> koeien: yeah, or other definitions
06:41:55 <koeien> Saizan: "group" is confusing terminology (for me, at least)
06:42:09 <Sgeo> How do I tell bindings-dsl and/or hsc2hs that there are no alignment rules?
06:42:21 <Sgeo> Or, everything's just bunched together?
06:42:39 <Sgeo> (I have a #pragma pack (1) here)
06:42:59 <Kanisterschleife> koeien: Ok, ghc7.0.4 is installed. I will download the haskell platform source now
06:43:12 <koeien> Kanisterschleife: ok.
06:43:17 <Kanisterschleife> koeien: again ./configure and make install?
06:43:47 <koeien> Kanisterschleife: in this case you need a "make" step in between
06:44:46 <iorivur> I got unfriendly error message when I execute a binary I have compiled and it was compiled successfully,
06:45:01 <koeien> iorivur: namely?
06:45:03 <iorivur> like this  test: toChar: Can't happen: Bad input: 16383
06:45:40 <iorivur> How do I get traceback like debug message?
06:46:05 <Kanisterschleife> koeien: "The openGL C library" is required. Do you know which debian package provides this?
06:46:28 <quicksilver> libmesagl-dev or something like that
06:46:51 <Kanisterschleife> quicksilver: thank you, probably libgl1-mesa-dev then
06:46:56 <koeien> Kanisterschleife: libgl1-mesa-dev
06:47:06 <iorivur> in my code, there is no 'toChar' function, so it is considered a function from a library call this.
06:47:26 <iorivur> I want to know which did.
06:47:46 <hpc> libgl1-mesa-dev
06:47:53 <koeien> iorivur: is your code small enough to paste?
06:48:12 <iorivur> yes,
06:48:15 <koeien> @hpaste
06:48:16 <lambdabot> Haskell pastebin: http://hpaste.org/
06:50:06 <iorivur> http://pastebin.com/VNksmrPY
06:50:08 <mauke> The paste VNksmrPY has been copied to http://hpaste.org/56038
06:50:18 <quicksilver> I think iorivur's error is from Codec.Binary.Base64.String
06:50:38 <quicksilver> I think that because of https://www.google.com/search?hl=en&q=toChar%3A%20Can't%20happen%3A%20Bad%20input
06:50:45 <iorivur> Thanks quicksilver
06:50:49 <bgamari> Is it not possible to do a monadic map (mapM) over Data.Set?
06:50:56 <bgamari> It's not Traversable so I'm at a bit of a loss
06:51:16 <iorivur> I will test around it.
06:51:19 <Saizan> use toList and fromList
06:51:44 <bgamari> Saizan: Why is it that it doesn't have a Traversable instance?
06:52:19 <hpc> because a Set has no ordering
06:52:23 <Saizan> because of the Ord context i guess
06:52:27 <hpc> also that
06:52:38 <bgamari> hpc: Fair enough
06:52:57 <hpc> the Ord context would make the type of mapM strange
06:53:19 <Saizan> Map doesn't have an "ordering" either but you get a Traversable instance for it :)
06:54:12 <bgamari> Perhaps this is another case where constraint kinds might help?
06:55:03 * hackagebot gamma 0.9.0.2 - Gamma function and related functions.  http://hackage.haskell.org/package/gamma-0.9.0.2 (JamesCook)
06:55:18 <roconnor> bgamari: yes constraint kinds solves this problem
06:55:21 <Saizan> yeah, though i wonder if they are going to modify the existing classes or provide new more generics ones
06:55:35 <bgamari> Saizan: I've been wondering the same thing
06:56:51 <erus`> where is the haskell package that implements strong AI?
06:57:10 <hpc> erus`: over there -->
06:57:14 <hpc> oops, it's gone
06:57:19 <hpc> perhaps it saw you ;)
06:57:55 <erus`> It has a single function String -> IO String
06:57:58 <tponthieux> mmmm strong AI
06:58:05 <dmwit> And that's just the package that implements the strong AI. Wait until you see how fast the strong AI itself runs!
06:58:06 <erus`> that sends the string over telnet to me and then i respond
06:58:39 <nexx> doesn't sound very strong
06:59:28 <monad> Short Question: What does the sign '#' in the following type-signature mean?
06:59:29 <monad> data STArray s i e
06:59:29 <monad>   = GHC.Arr.STArray !i !i !Int (GHC.Prim.MutableArray# s e)
06:59:32 <erus`> i think elderscrolls games would be much more fun with strong ai
06:59:57 <hpc> monad: it's a magic hash
07:00:17 <dmwit> monad: It's just part of the name MutableArray#
07:00:17 <monad> @hpc: that means?
07:00:17 <lambdabot> Unknown command, try @list
07:00:19 <Eduard_Munteanu> I don't think it's a magic hash, just a name for Prim stuff.
07:00:22 <hpc> monad: it indicates unboxed types, which are scary low-level magic
07:00:29 <dmwit> dmwit: It doesn't mean anything more than the M in MutableArray#.
07:00:32 <monad> ok thank you
07:00:34 <hpc> ah, or what Eduard_Munteanu said
07:00:38 <dmwit> err...
07:00:43 <Eduard_Munteanu> @src Int
07:00:43 <lambdabot> data Int = I# Int#
07:00:52 <dmwit> That was meant to be aimed at monad, not at me. =P
07:00:57 <monad> :-)
07:00:59 <quicksilver> well it *is* a Magic Hash, by definition
07:01:07 <quicksilver> but it's also true that it's not particularly magical
07:01:10 <quicksilver> it's just a naming convention
07:01:13 <Eduard_Munteanu> quicksilver: doesn't that refer only to stuff like 5#?
07:01:15 <quicksilver> == GHC internal
07:01:36 <quicksilver> Eduard_Munteanu: no, MagicHash is the extension which permits # in identifiers at all (in that file)
07:01:42 <Eduard_Munteanu> Oh, hm.
07:01:46 <quicksilver> ...including all the weird special cases like 5# and "hello"#
07:01:50 <hpc> Eduard_Munteanu: heh, that reminds me of the most ridiculous optimization ive ever come up with
07:02:07 <hpc> toInteger (I# x) = J# x
07:02:12 <quicksilver> Eduard_Munteanu: in real haskell, # is a valid operator so a# b would be parsed as (#) a b
07:02:41 <quicksilver> > let (#) = (+) in 5# 6
07:02:42 <lambdabot>   <no location info>: parse error on input `)'
07:02:47 <quicksilver> :(
07:02:48 <Saizan> hpc: don't you mean S# x ?
07:02:54 <hpc> Saizan: right, that
07:02:54 <nh2> is there a way to clean up old/unused versions of cabal packages?
07:03:15 <hpc> quicksilver: i think lambdabot has the magic hash extension turned on
07:03:29 <quicksilver> hpc: yes, hence the :(
07:03:40 <quicksilver> Eduard_Munteanu: that would be 11, in a real haskell interpreter.
07:03:52 <Eduard_Munteanu> nh2: cleanup is usually done by removing the ~/.cabal and ~/.ghc altogether and reinstalling what you need
07:04:19 <Saizan> or ghc-pkg unregister to be more selective (but leaving there the files)
07:04:50 <nh2> uh, I hoped for something like apt-get autoremove
07:04:51 <quicksilver> or donate your old computer to a #haskell hacker and buy a fresh one and install haskell platform on that?
07:05:35 <hpc> donate it to me!
07:05:48 <etpace> How do you guys develop large/reasonably complex haskell programs? I currently seem to start top-down, where I write a function with the assumption of helper functions existing and then just explicitly typing the helper functions and putting them as undefined and going from there. Im interested in how others work to design/develop programs and ifa nyone uses a more test driven or behaviour driven method
07:06:28 <koeien> i do not have exp with large haskell programs, but i tend to start bottom-up
07:06:44 <koeien> define the data structures, elementairy functions on them, and slowly compose
07:06:46 <hpc> etpace: i do that sometimes, but it generally ends up being "type-level bottom-up"
07:06:56 <quicksilver> I think both approaches are valuable
07:07:09 <quicksilver> bottom up to build yourselve a natural language of types and basic operations
07:07:13 <roconnor> etpace: I usually start bottom up, implementing modules of functionality, first by defining types for the data I want.
07:07:14 <quicksilver> (and then some "less-basic" operations)
07:07:15 <hpc> where i define the types i want, then define functions from the top down, then fill in with the only possible values that can fit those types
07:07:23 <etpace> Hmm, thats true, I definteitly think about the types first
07:07:27 <hpc> bottom-up++
07:07:30 <etpace> and also the API if im building an EDSL
07:07:37 <quicksilver> then top-down for actual "application design" once you already have the the basic in place
07:07:45 <krakrjak> I use both aproaches.  When working in the library I'm writing elementary functions.  When I'm in the driver or main code I build top-down with undefined functions until I can flesh them in.
07:08:09 <koeien> yeah, a hybrid approach is common I suppose
07:08:17 <etpace> how do you guys introduce tests/quickcheck properties? before you write code or after?
07:08:29 <etpace> larger tests or unit?
07:08:35 <etpace> I find i feel almost silly writing uunit tests sometimes
07:08:38 <hpc> when i wrote my website, i started with the goal of implementing functions that enabled a very specific style of coding
07:08:44 <etpace> as the functions are small they are most definitely not wrong
07:08:45 <hpc> and kinda worked from the "middle out"
07:08:48 <nh2> etpace: I recently had a good experience writing data structures first, then writing a lot bdd tests in hspec, and then implementing button up. This has the happy-making effect of you seeing more and more things go green.
07:08:52 <krakrjak> Haskell is the first language that allows both to be so easily expressed and explored.
07:08:57 <roconnor> etpace: I don't test :(
07:09:00 <krakrjak> that I've used...
07:09:04 <koeien> roconnor only proves.
07:09:09 <etpace> haha
07:09:28 <Eduard_Munteanu> Starting with the helpers and interfaces is useful when it's unclear what those should look like.
07:09:46 <Eduard_Munteanu> Though this isn't Haskell-specific.
07:09:57 <etpace> how would your bdd tests look like nh2?
07:10:10 <etpace> I foudn writing tests more than nearly full-stack to feel almost trivial
07:10:34 <etpace> ive also found thinking of useful props for quickcheck very hard
07:10:52 <Kanisterschleife> koeien: Took a long time, but now it's finished. No error :-) cabal is now located in /usr/local/bin/cabal. However, typing "cabal" in the console gives /usr/bin/cabal not found, though /usr/local/bin is in the PATH. Why that?
07:11:05 <roconnor> etpace: I wrote quickcheck properites for my colour library, but more so that I could document the properties.  Quickchecking them was simply a somewhat useful side-effect.
07:11:11 <quicksilver> Kanisterschleife: 'rehash' or 'hash -r'
07:11:15 <quicksilver> depending on your shell
07:11:24 <ezyang> Lack of algebraic properties may be a code smell for poor API design.
07:11:30 <koeien> Kanisterschleife: login/logout, or rehash.
07:11:51 <roconnor> ezyang: I wish more people believed that.
07:11:51 <Kanisterschleife> quicksilver, koeien: ah ok, worked :-)
07:11:53 <koeien> Kanisterschleife: bash didn't pick up on the change yet
07:11:55 <etpace> how about something quite systems heavy, such as code generation ezyang?
07:12:00 <quicksilver> ezyang: or just a sign that the right algebra has not yet been developed? :)
07:12:21 <etpace> the current properties ive only really thought were useful is that x == parse . prettyPrint x
07:12:24 <Kanisterschleife> koeien: Now I have ghc 7.0.4 and haskell-platform. Should I update to ghc 7.2.2 now, or is this not necessary?
07:12:34 <koeien> Kanisterschleife: no, GHC 7.2.x is more of a "tech preview"
07:12:36 <ezyang> etpace: Ugh, well, with codegen you're saddled with the stupid x86 instruction set, so that's a bit harder to do.
07:12:38 <Eduard_Munteanu> FIXME: wait until P = NP is proven and implement this more efficiently :P
07:12:42 <roconnor> merge-associatively laws for revision control, etc.
07:12:44 <koeien> haskell platform is tied to a GHC version, just use GHC 7.0.4
07:13:13 <roconnor> Eduard_Munteanu: no need to wait; we have already have algorithms that solve NP-complete problems in P time if P = NP.
07:13:20 <frerich> ezyang: Ok, since I couldn't find a simple explanation online, I give up - I have to ask: what are 'algebraic properties'?
07:13:21 <Eduard_Munteanu> Right. :)
07:13:33 <etpace> and executewithGHC x == executewithMyCompiler x, but they are too large for thousands of quickcheck tests I think
07:13:50 <ezyang> frerich: Maybe I should write a blog post about this :^)
07:13:52 <krakrjak> 7.0.4 works great.  You can build git using it if you really want to try some bleeding edge Safe Haskell and Data Parallel Haskell.
07:14:01 <etpace> although i could see optimisation passes on the AST would be good candidates for q uickcheck properties
07:14:06 <krakrjak> git=git repo of ghc
07:14:14 <ezyang> frerich: Basically, they're things like (a + b) + c = a + (b + c)
07:14:19 <Eduard_Munteanu> roconnor: though it's not a complete recipe IIRC, otherwise you could use it to test the hypothesis I guess.
07:14:43 <Kanisterschleife> koeien: Ok, so now everything is ready for installing programs like xmonad and xmobar via cabal, isn't it?
07:14:43 <ezyang> or fmap f . fmap g = fmap (f . g)
07:14:56 <frerich> ezyang: Ah, I see.
07:15:07 <etpace> why is that intrinsically a sign of good api design?
07:15:09 <nh2> etpace: my project was a compiler, so we had a nice lexer -> parser -> checking/transformation -> codegen stack, where one part built upon the other. We usually built hspec helper functions making its "it" function more specific, e.g. for parser tests "itParses [someProgramCodeString] [someASTdataStructure]"
07:15:18 <ezyang> etpace: Verification against a reference implementation is always a great and easy property to check.
07:15:25 <Eduard_Munteanu> krakrjak: 7.0 isn't exactly bleeding edge
07:15:34 <Eduard_Munteanu> Oh, nvm, misread.
07:15:39 <etpace> ah how appropriate nh2, im asking about my project, which is a compiler
07:15:42 <ezyang> etpace: It simplifies reasoning about usage of the API (oh, I know that bit is equivalent to this simpler expression), and makes the API more constrained.
07:15:47 <roconnor> frerich: here is an example from my colour library: opaque c1 `over` c2 == c1
07:16:06 <krakrjak> Eduard_Munteanu: np, I didn't say like it was in my head :)
07:16:14 <etpace> do you have a link to the source so I can see how your tests look? mine are very much full stack, ie, run sample programs make sure they have expected output
07:17:49 <roconnor> blend (1-o) c2 c1 == blend o c1 c2
07:17:52 <frerich> roconnor: Hm, I see. Is that an analogy to the neutral element (like 'x + 0 = x' or 'x * 1 = x')?
07:17:58 <frerich> roconnor: The over function, I mean.
07:18:04 <hpc> frerich: similar
07:18:13 <hpc> frerich: you should take a look at Monoid
07:18:21 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html
07:18:40 <nh2> etpace: Higher in the stack, e.g. on the full compiler level, we used hspec with hunit (for impure tests) to compare against a reference implementation. We made ~50 example files and generated hspec "it" specs by running through the file system, comparing our output to the reference one. As ezyang suggested, these kind of reference-check tests were extremely rewarding because of the little effort and much automatisation.
07:18:49 <roconnor> frerich: ya, it has something to do with an absorbtion law, but it is different from a neutral element.  transpent is the neutral element for over.
07:18:55 <hpc> it defines mempty and mappend (imagine, a '0' and a '+') such that x + (y + z) == (x + y) + z
07:18:57 <Eduard_Munteanu> frerich: more like a zero element in a ring
07:18:57 <roconnor> c `over` transparent == c
07:19:03 <hpc> and x + 0 == 0 + x == x
07:19:05 <roconnor> transparent `over` c == c
07:19:29 <koeien> Kanisterschleife: yup
07:20:11 <Kanisterschleife> koeien: great, it worked. thank you very much! :-)
07:20:44 <nh2> exFalso: thanks
07:20:47 <etpace> these example files ranged in complexity, allowing to locate bugs? from testing an if statement to testing n queens?
07:23:08 <nh2> etpace: yep, and of course also containing some files that are expected to not compile to see if we comply to our spec
07:23:51 <etpace> I think I should flesh out my tests of each part of my stack
07:25:03 * hackagebot happstack-server 6.4.6 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.4.6 (JeremyShaw)
07:25:12 <nh2> etpace: I especially liked the "it" helper functions because we used their input to be both input to the tested programs and BDD "description of the expected", so that in the red/green test log you could directly see what actual input is ok/fails
07:28:39 <sefb1704> okey im bag again
07:28:51 <nh2> etpace: the only problem I encountered is data type rewriting. For one part in the stack, we at some point found our basic data types to not fit what we actually wanted to do, and this meant refactoring all the tests to fit the new data model. This was tedious because it could not be done automatically (search/replace was not enough) - a (non-text based) tool for refactoring/migrating data structures would be cool
07:29:12 <sefb1704> u
07:29:25 <nexion> is a tail call equally efficient if it's inside a catch, or will the handler data need to be kept on the stack for each recursion?
07:29:49 <dmwit> Tail calls don't work like that (in Haskell).
07:30:03 <sefb1704> umm one question, how do i have to change this type: decision :: [Item] -> [Char] -> a -> [Char] -> IO() if  a should be Numeric and Read? when i try it i get an error ;(
07:30:03 * hackagebot random-fu 0.2.1.1 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.1.1 (JamesCook)
07:30:26 <koeien> sefb1704: decision :: (Num a, Read a) => ...
07:30:44 <dmwit> sefb1704: Try leaving the type annotation off and see what type is inferred. =)
07:32:23 <sefb1704> y i get the new error : Contexts differ in length       (Use -XRelaxedPolyRec to allow this)     When matching the contexts of the signatures for
07:32:26 <nh2> anyone using IPPrint? I cannot import it after installation
07:32:34 <nexion> dmwit, so would having a recursive call inside a catch be using more and more memory as time passes?
07:32:36 <koeien> sefb1704: add {-# LANGUAGE RelaxedPolyRec #-} to the top of your file
07:32:59 <sefb1704> this sounds totally odd. why do i need this?
07:33:02 <koeien> the reason that this is necessary is slightly obscure
07:33:33 <sefb1704> so i add this: LANGUAGE RelaxedPolyRec ?
07:33:58 <koeien> all members of a set of mutually recursive functions need to have the same context length. (a "context" is a set of type class requirements)
07:34:03 <c_wraith> no, the punctuation is necessary
07:34:04 <koeien> sefb1704: including the {-# and #-}
07:34:37 <dmwit> nexion: Being inside a catch or not should not affect the memory usage.
07:34:43 <dmwit> sefb1704: Why don't you post a bit more context?
07:34:54 <dmwit> sefb1704: Requiring RelaxedPolyRec seems a bit odd for a beginner's code.
07:35:14 <dmwit> sefb1704: It's likely you have an error elsewhere, and that adding RelaxedPolyRec will only make you more confused.
07:35:32 <sefb1704> okey i will post it, because adding the line also doesnt help
07:36:18 <koeien> dmwit: yeah, I think s/he wants a monomorphic type
07:36:57 <hpaste> sefb1704 pasted “Mytextadventure” at http://hpaste.org/56039
07:38:07 <Eduard_Munteanu> Is there any reasonable way to use Haskell to write Android apps? Even indirectly, through code generation, some DSL...?
07:38:29 <dmwit> sefb1704: You must also add the Num/Read context to openbag's type, probably.
07:39:03 <dmwit> sefb1704: err... ignore that
07:39:08 <dmwit> sefb1704: Give me a bit to read.
07:39:15 <koeien> Eduard_Munteanu: i would doubt that without a lot of work
07:39:28 <c_wraith> Eduard_Munteanu: I think someone's done it.  sort of, slightly
07:39:33 <sefb1704> dmwit: this also doesnt work ^
07:39:40 <sefb1704> okey np
07:39:59 <Eduard_Munteanu> I see, thanks. I take it it's not really usable right now.
07:41:16 <dmwit> sefb1704: Umm... you're sometimes calling "function" with two arguments, and sometimes with three.
07:41:19 <dmwit> What gives?
07:41:39 <sefb1704> :O i call it with three? normally only with 2
07:41:52 <sefb1704> i give function a list and then a string
07:42:24 <dmwit> sefb1704: Ah, I think I see what's going on.
07:42:39 <dmwit> sefb1704: Check out the block labeled "second level: village".
07:42:55 <dmwit> sefb1704: Here is the only place you use the thing with type (Num a, Read a) => a.
07:43:04 <dmwit> sefb1704: But you pass it to "function" as its second argument.
07:43:24 <dmwit> "function"'s second argument isn't a (Num a, Read a) => a, it's a String!
07:43:51 <dmwit> So decision's type probably ought to be something like "decision :: [Item] -> String -> String -> String -> IO ()".
07:43:53 <nh2> sometimes I really don't understand cabal. ghc-7.0.3 requires containers ==0.4.2.0 however containers-0.4.2.0 was excluded because ghc-7.0.3 requires containers ==0.4.0.0
07:44:25 <dainanaki> Is there any way to forward-declare data types in Template Haskell? I'm trying to write some code that can potentially generate corecursive data type declarations, but TH doesn't handle not-yet-existing datatypes.
07:45:04 * hackagebot IntervalMap 0.2.1 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.2.1 (ChristophBreitkopf)
07:45:07 <sefb1704> um i checked out the block but i dont understand what you want to tell me .. i use function correctly i think
07:45:56 <dmwit> Okay, before I was trying to be the compiler, and failed like three times in a row.
07:46:03 <dmwit> So now I asked the compiler instead.
07:46:08 <dmwit> My compiler accepts your file as-is.
07:46:14 <dmwit> What version of GHC are you using?
07:46:42 <sefb1704> damn ;( i dont know i downloaded it from the internet, got a linux distribution wait a sec
07:46:59 <tehgeekmeister> so i was in here yesterday trying to figure out why an iteratee based approach to a thing i was doing (https://gist.github.com/gists/1553455) was so slow compared to the original perl script i ported it from, for fun
07:47:06 <tehgeekmeister> think i figured out what's going on
07:47:14 <sefb1704> 6.12.1
07:47:30 <sefb1704> afk i will be right back
07:47:34 <Cale> sefb1704: That is an impressive type error :D
07:48:04 <dmwit> sefb1704: Well, I recommend upgrading to GHC7. Perhaps you hit a bug in 6.12.
07:48:07 <tehgeekmeister> there's the nasty many appends in a row problem going on in splitWhen, i think
07:48:18 <sefb1704> dmwit: okey thanks i will try
07:48:22 <tehgeekmeister> don't know how it could be fixed, though
07:49:33 <Cale> sefb1704: Try replacing the 'a' in the type signature for decision with Integer, and remove the class context
07:49:53 <sefb1704> Cale: okey i will try, but i am afk now
07:49:56 <Cale> sefb1704: So  decision :: [Item] -> [Char] -> Integer -> [Char] -> IO ()
07:52:38 <bytter> can someone give me an hint if the haskell type system is able to solve the following problem?
07:53:08 <bytter> I'm trying to model a typed dataflow language…
07:53:14 <bytter> so, basically, you have Nodes
07:53:20 <bytter> and Connections between Nodes
07:53:30 <bytter> Nodes are polimorphic
07:53:55 <bytter> and Connections ensure that Nodes connect to other nodes based on simple type bounds
07:54:11 <koeien> so, like a colored petri net
07:54:24 <bytter> koeien: exactly
07:54:27 <bytter> now my question
07:54:51 <bytter> suppose I start to add connections to a list
07:54:58 <bytter> a -> b, b -> c, etc
07:55:44 <bytter> now, could the compiler statically ensure me that, given the already added connections to the list, a new connection c -> d is type invalid?
07:56:56 <dolio> How do you know that c -> d is invalid based on a -> b, b -> c, etc.?
07:57:22 <bytter> imagine that C accepts Integers
07:57:53 <dolio> Okay, I'm imagining that.
07:58:00 <dainanaki> Me too.
07:58:05 <bytter> and A produces integers
07:58:12 <bytter> B accepts a polimorphic type
07:58:27 <bytter> hence, a -> b, b -> c would be valid, because B would be bound to Integer
07:58:58 <quicksilver> I'm pretty sure the answer to your question is going to be 'Yes', bytter . Although your example isn't making sense to me so far.
07:59:00 <bytter> now, imagine that a is a float, but c still only accepts integers
07:59:21 <dolio> Is b then specialized to integer? or can it be reused for other things?
07:59:35 <bytter> dolio: it's specialized because of a -> b
08:00:33 <dolio> I mean, can you use both a -> b and c -> b, where a and c produce different types?
08:00:42 <bytter> yes
08:00:46 <dolio> Okay.
08:02:53 <dolio> I'm going to say it's possible to do this. I doubt it will be easy, though.
08:03:06 <byorgey> bytter: I'm quite confident that you could model this using the Haskell type system.  However, it will probably take a lot of fiddling to get the design right.
08:03:31 <dainanaki> I'm tempted to say that it sounds like GADTs might be what bytter is looking for.
08:03:44 <byorgey> it may also require some nontrivial type-level programming, depending on what sorts of features you want to support.
08:03:53 <quicksilver> dainanaki: GADTs might be at the wrong level
08:03:59 <mah_b_> like `data CL a b = Single (Connection a b) | forall c. Cons (Connection a c) (CL c b)'?
08:04:34 <dmwit> GADTs are at both levels!
08:04:37 <dmwit> How can they be wrong.
08:04:40 <dmwit> =P
08:04:52 <byorgey> mah_b_: yeah, I was just going to write something like that.
08:04:54 <dainanaki> quicksilver, agreed. It's hard to give good advice given the vagueness of the problem though.
08:05:01 <byorgey> but what if you want to support nodes with multiple inputs or outputs?
08:05:04 * hackagebot polynomial 0.6.5 - Polynomials  http://hackage.haskell.org/package/polynomial-0.6.5 (JamesCook)
08:05:28 <erus`> has any Haskell to javascript compilation work been done in the last few months?
08:05:29 <byorgey> now you have type-level lists of types, etc.
08:06:38 <quicksilver> erus`: I suspect not; I think https://github.com/sviperll/ghcjs is the most recent effort.
08:09:16 <dmwit> bytter: ...did you ever explain how you know that c -> d is invalid based on a -> b, b -> c?
08:09:38 <dmwit> s/a -> b, b -> c/a -> b, b -> c, etc./
08:11:26 <bytter> dmwit: uh… because d may accept, for example, a float
08:11:43 <bytter> dmwit: since b is polymorphic, you never known if c -> d is valid or not
08:11:49 <bytter> dmwit: until you establish the type of b
08:14:53 <dolio> If b is polymorphic, and you have a -> b and d -> b, how do you know which connection b -> c uses? Or are you keeping track of multiple compositions of these things?
08:15:21 <dolio> If the latter, something like what mah_b_ wrote might be the answer, and is simpler than what I first thought you meant.
08:16:04 <quicksilver> according to my understanding of bytter, b is constrained by all its connections
08:16:21 <quicksilver> so if a -> b and d -> b and b -> c then b's type must be compatible with a,d *and* c
08:16:28 <quicksilver> if not, type error is expected/required
08:16:49 <quicksilver> so bytter wants unification
08:17:15 <quicksilver> reified unification in haskell is not very easy, unless you have a hack where you can just embed yourself onto haskell's own unifier
08:17:39 <Saizan> you could cast a Monomorphism Restriction spell on b
08:17:41 <dolio> Yeah, that's what I first thought. That'd also require checking that either a or d constraint b to be compatibile with c, though, if I'm not mistaken.
08:17:46 <dolio> Which is a lot of work.
08:19:14 <dolio> That is, if you have a -> b, d -> b, b -> c, you're checking that either c . b . a or c . b . d is type correct.
08:19:21 <dolio> Essentially.
08:19:55 <dolio> But then, if c . b . a is, and c . b . d isn't, I don't understand what happens if you enter b from d. You can't go out via c then.
08:21:10 <dolio> And he said that you could use the polymorphic things at multiple types, which leans toward checking separate compositions, not that there exists a valid composition in your set.
08:23:39 <byorgey> the question is whether a, b, and c are "node identifiers" (so a -> b, d -> b, b -> c describes a graph with four nodes and three edges) or just names for (reusable) nodes, so it describes three separate one-edge graphs.
08:24:16 <quicksilver> this is like quantum computing
08:24:27 <quicksilver> #haskell will solve every conceivable variant of bytter's problem
08:24:33 <byorgey> hahaha
08:24:36 <quicksilver> until he returns and collapses our waveforms towards the relevant one
08:25:37 <sefb1704> Cale: nice, it works :)
08:25:49 <byorgey> sometimes solving every conceivable variant of someone's problem is simply more efficient than finding out what they actually want.  And it's certainly more fun. ;)
08:26:00 <sefb1704> dmwit: thank you alot for looking at my code so closely :
08:26:02 <sefb1704> :)
08:30:04 * hackagebot erf-native 1.0.0.1 - Native Haskell implementation of the interface from the erf package  http://hackage.haskell.org/package/erf-native-1.0.0.1 (JamesCook)
08:30:06 * hackagebot Glob 0.7 - Globbing library  http://hackage.haskell.org/package/Glob-0.7 (MattiNiemenmaa)
08:31:44 <PatrickRobotham> How do I delay a program until the user presses a button?
08:32:02 <dmwit> PatrickRobotham: getLine or getChar
08:32:19 <dmwit> If you want it to continue before they press enter, you'll need to change the buffering as well.
08:32:36 <dmwit> hSetBuffering stdin NoBuffering -- or similar; check the type of hSetBuffering to get it right
08:32:59 <Sgeo> dmwit, except on Windows
08:33:07 <dmwit> Windows can suck a nut.
08:33:16 <PatrickRobotham> dmwit: Thanks :)
08:34:24 <luite> is there a way to do this on windows?
08:35:05 <hpc> wait what?
08:35:24 <hpc> i thought on windows it was just a different default buffering
08:36:50 <quicksilver> hpc: the problem is a bit more subtle (I learn today)
08:36:55 <luite> hmm I don't know, i don't use windows very often, but I need the "press any key to continue" thing somewhere :)
08:37:07 <luite> and it would be nice if it worked
08:37:11 <quicksilver> on unix-like OSes haskell's standard IO library conflates "unbuffered IO" with "set the terminal to raw"
08:37:19 <quicksilver> which is suprising if you understand these things
08:37:29 <quicksilver> but, possibly, desirable if you don't think too deeply
08:37:35 <quicksilver> that same hack (or feature) fails on windows.
08:38:18 <quicksilver> see http://hackage.haskell.org/trac/ghc/ticket/2189 for details.
08:38:33 <Sgeo> quicksilver, is there a way to set terminal to raw on both?
08:38:45 <Sgeo> Instead of hSetBuffering stdin NoBuffering?
08:39:12 <quicksilver> if there is, I don't know what it is
08:39:20 <quicksilver> I've never used windows
08:42:47 <byorgey> mokus: so what's new in the latest release of 'polynomial'?
08:44:46 <bytter> quicksilver is right.
08:44:52 <bytter> what I want is unification...
08:45:04 * hackagebot numeric-prelude 0.3 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.3 (HenningThielemann)
08:45:31 <bytter> although I had the feeling that Hindley–Milner wold be enough...
08:45:58 <mokus> byorgey: it just adds Eq contexts all over the place for GHC 7.4
08:46:04 <byorgey> mokus: oh, ok =)
08:47:07 <mokus> byorgey: I've got an update going on a back-burner to duplicate the Num-based interface to a version using only VectorSpace/AdditiveGroup, but I'm not happy enough with it to release yet
08:47:19 <byorgey> mokus: ah, I see
08:47:46 <byorgey> bytter: Hindley-Milner type systems are often implemented in terms of unification.
08:48:13 <bytter> byorgey: so, wouldn't the haskell type system be enough for that problem?
08:49:26 <byorgey> bytter: any Haskell type checker does unification.  The question is whether you can encode things in such a way that you get the unifier to do the particular work you want.
08:50:04 * hackagebot sample-frame-np 0.0.3 - Orphan instances for types from sample-frame and numericprelude  http://hackage.haskell.org/package/sample-frame-np-0.0.3 (HenningThielemann)
08:57:10 <Rc43> Guys, how to make nested cabal packages? Like 'cool-project', 'cool-project-common', 'cool-project-plugins'?
08:57:53 <tgeeky> Rc43: make cool-project, put dependencies in that .cabal file for cool-project-common, cool-project-plugins
08:58:04 <tgeeky> Rc43: check out 'diagrams' project for reference
08:59:09 <Rc43> tgeeky, so it is normal to make a lot of packages for one project? I meen, it will not disturb anybody?
09:00:47 <byorgey> Rc43: sure, it is normal.
09:01:09 <Rc43> ok, thanks
09:01:23 <byorgey> It especially makes sense when some of the pieces may be usable in other contexts, or when some of the pieces are "optional"
09:03:03 <mdmkolbe> Are there any libraries for hooking into GHC's type checker?  (e.g. if I want my Template Haskell code to determine what to generate based on some relationship between types)
09:03:14 <nh2> I want to write a repl-based terminal program in the style of fdisk, parted, the interactive git commands and so on, with numbers and letters to select commands. Any recommended libraries?
09:03:58 <nh2> I'm using Haskeline so IO so far, but something for this kind of "menu style" would be nice
09:03:59 <acowley> Does anyone have a working example of using hsc2hs's #def form? I think I'm using it right, and cabal builds my library, but then I end up with symbols not found when linking a final executable
09:04:42 <byorgey> mdmkolbe: the GHC API should let you do that
09:07:32 <mdmkolbe> byorgey: thx, that was the keyword I needed
09:15:05 * hackagebot roots 0.1.1.1 - Root-finding algorithms (1-dimensional)  http://hackage.haskell.org/package/roots-0.1.1.1 (JamesCook)
09:15:30 <Rc43> Can I import module, if I had only .hi and .o files?
09:15:36 <hpc> Rc43: yes
09:15:42 <hpc> but you do need both
09:17:46 <Rc43> hpc, why such thing can fail? http://pastebin.com/84RtKATQ
09:17:48 <mauke> The paste 84RtKATQ has been copied to http://hpaste.org/56047
09:18:27 <monochrom> I think you still need the .hs file just for timestamp check
09:18:50 <hpc> that might be it
09:18:56 <Rc43> timestamp?
09:19:05 <hpc> or an improperly named module, or something
09:19:07 <monochrom> "do I need to recompile?"
09:19:43 <dmwit> TIL about ls -1
09:20:20 <hpc> i think it's the same as ls | echo
09:20:40 <dmwit> No, not quite.
09:20:47 <dmwit> For example, ls | echo doesn't give me colors.
09:21:02 <dmwit> Also, you probably meant ls | cat.
09:21:04 <hpc> er, ls | cat
09:21:07 <hpc> yeah, that
09:21:56 <Saizan> if you install the modules as a package with ghc-pkg you can use them without the .hs, the most convenient way is to make a .cabal package and cabal install that
09:22:20 <Rc43> Why ghc breaks compiling instead of recompiling all?
09:22:48 <hpc> Rc43: --make enables extra magic, if that's what you need
09:22:59 <Rc43> I want to place hs' into separate package, install package and use it for other packages. So hs' will be unavailable.
09:23:28 <Rc43> hpc, --make with makefile?
09:23:36 <hpc> doesn't need a makefile
09:23:42 <hpc> nor will it use any if there is one
09:23:55 <hpc> it follows dependencies and some other stuff that i forget atm
09:24:04 <hpc> and produces an executable
09:24:21 <Rc43> hpc, nothing improved
09:24:45 <Rc43> hpc, everything is the same as without `--make`, I mean.
09:26:16 <acowley> oh man, how disappointing
09:26:19 <dmwit> I think we're missing something basic here.
09:26:21 <acowley> this is just broken between hsc2hs and cabal
09:26:36 <dmwit> Rc43: How are you packaging it?
09:26:54 <Rc43> dmwit, now I am testing it without packages
09:27:53 <acowley> http://hackage.haskell.org/trac/hackage/ticket/245
09:28:34 <Saizan> Rc43: if you want ghc to use .hi and .o files without the corresponding .hs file you _have to_ register a package with ghc-pkg containing those
09:29:04 <Rc43> Saizan, ok, thanks. I will try with cabal.
09:35:05 * hackagebot splines 0.3 - B-Splines, other splines, and NURBS.  http://hackage.haskell.org/package/splines-0.3 (JamesCook)
09:35:07 * hackagebot synthesizer-core 0.5 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.5 (HenningThielemann)
09:35:27 <hpc> hehe, that spines description sounds like an infomercial
09:35:36 <hpc> splines! splines! more splines than your manifold has room for!
09:35:41 <mokus> hehe
09:38:17 <hpc> B-splines, NURBS, beziers! all in one place!
09:38:23 <hpc> :D
09:38:50 <Rc43> How can I make all modules in package be exposed?
09:38:57 <mokus> yea, and a few others brewing but not included yet because i haven't taken the time to work out the conversions to/from b-splines
09:39:37 <Saizan> Rc43: list them in exposed-modules:
09:40:05 * hackagebot synthesizer-dimensional 0.6 - Audio signal processing with static physical dimensions  http://hackage.haskell.org/package/synthesizer-dimensional-0.6 (HenningThielemann)
09:40:06 <Rc43> Saizan, can I do it without listing them all?
09:40:13 <Rc43> Saizan, default or something else
09:40:20 <Saizan> Rc43: nope
09:44:00 <acowley> I guess I can run hsc2hs manually. So I'm finally at the point where I'm wrapping cabal with a Makefile.
09:44:42 <c_wraith> acowley: why's cabal failing to run hsc2hs properly?
09:44:54 <c_wraith> ah, I see
09:44:59 <acowley> c_wraith: it doesn't handle stub .c files generated by hsc2hs
09:45:02 <c_wraith> I found your link to the trac ticket
09:45:05 * hackagebot midi-alsa 0.1.2 - Convert between datatypes of the midi and the alsa packages  http://hackage.haskell.org/package/midi-alsa-0.1.2 (HenningThielemann)
09:45:12 <acowley> they're sitting there under dist, but not linked into the .o
09:45:26 <acowley> so you have to manually run hsc2hs in your src directory and add the generated .c to your cabal file
09:45:41 <acowley> the last little pain is that hsc2hs needs to link in any necessary libraries
09:45:53 <acowley> which is something cabal usually does for you, but now I have to specify manually
09:46:29 <matobet> @pl \fileName outFileName -> unlines . reverse . lines <$> readFile fileName >>= writeFile outFileName
09:46:29 <lambdabot> (. writeFile) . (>>=) . (unlines . reverse . lines <$>) . readFile
09:47:50 <acowley> you can do that more tidily
09:50:55 <acowley> Is dcoutts the only person who works on cabal-install?
09:56:10 <Rc43> -Werror says about critical errors or just about warnings?
09:56:40 <Rc43> Or it blocks build if there are warnings?
09:58:48 <dmwit> The latter; -Werror turns warnings into errors, instead.
09:59:41 <Rc43> dmwit, ok
10:00:05 * hackagebot synthesizer-alsa 0.4 - Control synthesizer effects via ALSA/MIDI  http://hackage.haskell.org/package/synthesizer-alsa-0.4 (HenningThielemann)
10:00:22 <Rc43> now I want to run some command before build. Have I use makefile or there is something lighter?
10:01:14 <acowley> that is the light way
10:01:54 <Rc43> and I can use Setup.hs, but it is wrong way, right?
10:02:31 <Rc43> acowley, if it is available to just type in project.cabal `run megacommand` then it is lighter.
10:02:35 <acowley> Rc43: I think that is the heavy way, but it has the advantage of keeping the whole build system within in cabal
10:04:56 <BMeph> acowley: So, does that make 'shake' the middle way? :)
10:05:29 <acowley> BMeph: probably, but I haven't had a chance to try it out yet. Is it as minimal as make for things like running a command before building?
10:05:40 * BMeph has never used, and barely heard of, 'shake', by the way.
10:06:28 <BMeph> acowley: From the video presentation I watched, it seems to bill itself as "a 'make' that does the right thing".
10:07:44 <acowley> BMeph: that's my understanding, too, but -- and I'm probably hopelessly naive here -- I only find make to get unwieldy when I need to do something complicated
10:08:28 <gwern> > 300 * 0.25
10:08:29 <lambdabot>   75.0
10:08:50 <gwern> > 300 * 0.25 * 0.3
10:08:51 <lambdabot>   22.5
10:09:10 <gwern> > 300 * 0.25 * 0.7
10:09:11 <lambdabot>   52.5
10:13:14 <creativuties> what differs Haskell from somethings else?
10:13:18 <creativuties> like Perl or python
10:13:25 <creativuties> to get real work done
10:13:33 <creativuties> some small to medium projects
10:13:44 <creativuties> and also some scripts so automate some tasks
10:14:27 <daimrod> creativuties: do you know python or perl ?
10:14:27 <muep> creativuties: I am very inexperienced in haskell, but I'd say laziness of computation and immutability of values
10:15:02 <daimrod> creativuties: if so, why don't you just try haskell ? you'll by yourself.
10:15:31 <creativuties> daimrod, yes i know python and some perl
10:15:58 <creativuties> but i dont think that it has some market value or at least not many opensource project or companys are using it
10:16:51 <Botje> creativuties: and? learning haskell will make you a better programmer, even if you never write a letter of haskell again
10:17:14 <creativuties> Botje, better in what?
10:17:34 <bas_> programming and thinking about programming
10:18:22 <bas_> and it's very nice for command-line scripts and text processing
10:18:47 <creativuties> bas_, it is?
10:18:55 <bas_> yes I use it for that purpose at work
10:19:27 <acowley> I finally cleaned the bitrot off of my OpenCV library, what a hassle that was.
10:19:34 <bas_> python too
10:19:41 <bas_> but my haskell scripts never ever break
10:19:50 <bas_> so I prefer haskell
10:21:03 <acowley> note: Results may vary. It is possible to have bugs in Haskell code.
10:21:28 <bas_> sure it is, but I find it more difficult to break stuff in haskell
10:21:52 <creativuties> bas_, pretty nice
10:22:06 <creativuties> can you post some script for me to see :) ?
10:22:08 <acowley> I know, I'm just the fine print on the enthusiastic haskell recommendation and I'm here to perform my duty :)
10:22:51 <bas_> I'm not on a box with access to them now, but haskell.org has some good tuts on command-line stuff
10:23:55 <Yrogirg> is there an evaluate function, but of type IO a -> IO a, not evaluate :: a -> IO a ?
10:24:28 <acowley> :t (>>= evaluate)
10:24:28 <lambdabot> Not in scope: `evaluate'
10:24:45 <Yrogirg> or how do you turn a -> IO a into IO  a -> IO a
10:25:01 <parcs`> :t (=<<)
10:25:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:25:19 <Yrogirg> oh, ok
10:30:50 <Patrek> I have to pattern match on a large ADT that doesn't use record syntax, is there any solution to this? for example : data D = C1 Int String Int Bool  | C2  \n f:: D -> D \n f (C1 a b c d) = C1 a b (c+2) d \n f x = x
10:31:21 <Cale> Patrek: what's going on with that syntax...
10:31:30 <Cale> errr
10:31:35 <Cale> oh, \n isn't lambda n
10:31:36 <Cale> lol
10:31:43 <Patrek> :)
10:32:16 <Cale> um... that looks correct, is it not working?
10:32:47 <Patrek> it works but in a large ADT it is really a big boilerplate !
10:33:03 <Cale> okay
10:33:05 <cheater> hi
10:33:15 <Cale> Well, maybe the design of your type can be improved?
10:33:15 <cheater> what is the best optparse clone for ghc?
10:33:31 <Cale> Or perhaps you can split it up into higher order functions in some fashion?
10:33:43 <Patrek> hmmm, how?
10:33:46 <BMeph> cheater: The one you're about to write - go, cheater, make us proud! ;)
10:33:51 <cheater> nope
10:33:55 <cheater> that would be very incorrect of me
10:33:59 <cheater> i am not an academic
10:34:27 <cheater> in fact i would not even generalize it to be both optparse and a graph database
10:34:38 <cheater> so it would meet with very cold reception by the community
10:35:06 * hackagebot llvm-extra 0.3 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.3 (HenningThielemann)
10:35:21 <Cale> Patrek: well, it's not easy to say without a real example... There's not much you could do with that the example you gave which would be particularly useful
10:36:35 <Cale> I suppose I could write  modifyC f x = case x of C1 a b c d -> C1 a b (f c) d; v -> v
10:36:44 <Patrek> Cale: pattern matching on a function over  http://hackage.haskell.org/packages/archive/haskell-src-exts/1.11.1/doc/html/Language-Haskell-Exts-Syntax.html
10:36:46 <Cale> and then your function becomes  modifyC (+2)
10:36:54 <Patrek> *for
10:37:11 <Cale> oh, okay
10:37:30 <Patrek> I was thinking of more generic cleaner way, lenses?
10:37:33 <Cale> Well... hmm... there's SYB :P
10:37:49 <Cale> Note that there are Data instances for all of those types
10:38:09 <tehgeekmeister> is there a way that, when profiling, after adding cost centers to all my code, i can add cost centers to a library that appears to be causing most of the slowdown in my code?
10:38:45 <Cale> which means that you can use the Data.Generics combinators like everywhere and everything
10:38:58 <c_wraith> tehgeekmeister: only by editing the source of that library.  Which isn't too hard for anything from hackage
10:39:06 <Rc43> does cabal-dev work with hooks?
10:39:28 <Patrek> Cale: yep, but the problem is that I am targeting specific path not "everywhere"
10:39:44 <Patrek> I cannot do type-directed generics like biplate
10:39:53 <tehgeekmeister> c_wraith: right, so i edit it and rebuild both my stuff and the package?
10:41:04 <KorriX> > return "test"
10:41:04 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
10:41:05 <lambdabot>    arising from a use ...
10:41:08 <c_wraith> tehgeekmeister: you'll need to cabal install the package, then rebuild your program
10:41:40 <KorriX> how to print string in haskell (putStrLn "test" :: String has type mismatch) ?
10:42:32 <Patrek> any survey on Template Haskell based lenses?
10:42:47 <Cale> KorriX: that's because it's not a String
10:42:51 <Cale> KorriX: It's an IO ()
10:42:52 <KorriX> i know
10:42:59 <KorriX> but how to change type ?
10:43:07 <KorriX> i forgotten method to do that
10:43:08 <Cale> KorriX: What are you trying to do?
10:43:15 <Cale> "test" :: String
10:43:20 <Cale> putStrLn :: String -> IO ()
10:43:25 <Cale> putStrLn "test" :: IO ()
10:43:27 <rwbarton> maybe you're looking for   putStrLn ("test" :: String)  ?
10:43:41 <KorriX> map over list of strings and print every element
10:43:47 <tehgeekmeister> c_wraith: right, so i edit the source of the package, use cabal to rebuild, and then rebuild my program
10:43:57 <Cale> mapM putStrLn listOfStrings
10:44:03 <Cale> or mapM_
10:44:05 <KorriX> mapM !
10:44:08 <KorriX> this is it
10:44:18 <KorriX> thank you very, very much !
10:45:07 * hackagebot synthesizer-llvm 0.3 - Efficient signal processing using runtime compilation  http://hackage.haskell.org/package/synthesizer-llvm-0.3 (HenningThielemann)
10:45:42 <cheater> is GetOpt a good module to use?
10:46:58 <Botje> I like forM_ more than mapM_ for some reason.
10:48:13 <c_wraith> Botje: I prefer it whenever I want to write the function inline.
10:48:26 <acowley> if you've got your list bound to a short identifier but want to use an anonymous function for the loop body, forM_ can be syntactically cleaner
10:48:28 <c_wraith> Botje: when there's already a function that exists, I prefer mapM_
10:48:52 <acowley> or, put another way, exactly what c_wraith said
10:53:51 <cheater> @type getContents
10:53:52 <lambdabot> IO String
10:53:55 <cheater> @src getContents
10:53:56 <lambdabot> getContents = hGetContents stdin
10:55:07 * hackagebot vector-bytestring 0.0.0.1 - ByteStrings as type synonyms of Storable Vectors of Word8s  http://hackage.haskell.org/package/vector-bytestring-0.0.0.1 (BasVanDijk)
11:09:50 <cheater> hi
11:10:58 <cheater> i'm trying to follow this guide: http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt but it seems to be off. For example there's no definition of OptDescr that i can find (doesn't seem to be in the imports either) and the definition of "options" seems to be missing parens... can someone confirm that is the case?
11:11:18 <cheater> i might time out but i'll reconnect
11:12:00 <Rc43> Guys, why hooks can do nothing?
11:12:27 <shachaf> What?
11:12:48 <cheater> the hooks... they do nothing!
11:12:48 <Rc43> cabal hooks
11:12:51 <jamiltron> I like hat question.
11:13:12 <jamiltron> that question, although liking the hat question is just as good.
11:13:21 <cheater> jamiltron: what is your favorite hat? do you know when hats were invented? what is the biggest hat in the world?
11:13:41 <Rc43> :D
11:13:56 <Rc43> Really, they must work.
11:14:02 <Rc43> build-type: Simple
11:14:15 <Rc43> main = defaultMainWithHooks $ simpleUserHooks { preBuild = myPreBuild }
11:14:49 <Saizan> Rc43: you need build-type: Custom
11:15:07 * hackagebot libcspm 0.2.0 - A library providing a parser, type checker and evaluator for CSPM.  http://hackage.haskell.org/package/libcspm-0.2.0 (ThomasGibsonRobinson)
11:15:09 * hackagebot cspmchecker 0.2.0 - A command line type checker for CSPM files.  http://hackage.haskell.org/package/cspmchecker-0.2.0 (ThomasGibsonRobinson)
11:15:10 <Rc43> Oh! It works: runhaskell Setup.hs build
11:15:45 <Saizan> yeah, that way it'll work, but if you use cabal-install it won't unless you have build-type: Custom
11:15:47 <Rc43> Saizan, Resolving dependencies... cabal: internal error: unexpected package db stack
11:16:07 <Yrogirg> a question not about Haskell, how do you read "∃! " in English ?
11:16:20 <koeien> "there does not exist" ?
11:16:23 <Saizan> exists unique
11:16:29 <koeien> ah yes, disregard.
11:17:21 <Rc43> Saizan, yes, custom is right, but it fails now =/
11:18:33 <Rc43> Saizan, he =/ It seems, that only cabal-dev fails. cabal is ok
11:21:23 <Rc43> Storing binary utility in package is awful? I want to attach thrift binary to generate code; it is long way to build it.
11:23:49 <c_wraith> Rc43: better to just list the utility in the build tools section, and let people installing the package worry about installing it
11:51:02 <shachaf> Huh, "... -> forall b. ..." is valid syntax without parentheses.
11:51:37 <Saizan> why so surprised?
11:51:47 <shachaf> I expected parentheses to be required.
11:52:38 <shachaf> @ty let foo :: (forall p. ((forall q. p -> q) -> p) -> p) -> forall a b. ((a -> forall x. x) -> b) -> Either a b; foo ccc cg = ccc (\k -> Right (cg (\a -> k (Left a)))) in foo
11:52:39 <lambdabot> forall a b. (forall p. ((forall q. p -> q) -> p) -> p) -> ((a -> forall x. x) -> b) -> Either a b
11:53:33 <crossfader> hi there
11:53:41 <shachaf> G'day.
11:54:35 <crossfader> i m absolutely new to haskell, a learning program brought me here after i tried to translate a simple recursion from (scheme) to haskell
11:54:49 <byorgey> crossfader: welcome!
11:54:58 <byorgey> crossfader: feel free to ask questions here
11:55:07 * hackagebot snaplet-hdbc 0.7.2.1 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.7.2.1 (JurrienStutterheim)
11:56:08 <crossfader> well my first question would be, if i m fine with hugs for testing, my disk is almost full and ghc is a huge amount of data
11:57:30 <byorgey> crossfader: it's true, ghc is quite large
11:57:30 <mjrosenb> crossfader: err, are you asking if you should install ghc?
11:57:36 <KorriX> How to make 'imperative' table like this:
11:57:36 <KorriX> a = [0,0,0]
11:57:36 <KorriX> a[x] = sth
11:57:36 <KorriX> a[y] = sth
11:57:36 <KorriX> a[z] = sth
11:57:36 <KorriX> return a
11:57:37 <KorriX> functional way ?
11:57:55 <koeien> i'm not sure what you mean by "table", a map?
11:58:01 <KorriX> list
11:58:03 <KorriX> normal list
11:58:12 <koeien> > [1,2,3,4]
11:58:13 <rwbarton> looks like he means an array
11:58:13 <lambdabot>   [1,2,3,4]
11:58:17 <shachaf> koeien: You don't.
11:58:22 <shachaf> s/koeien/KorriX/
11:58:22 <byorgey> crossfader: hugs should be fine for learning when you're just starting out.  just be aware that it is not maintained anymore
11:58:29 <shachaf> KorriX: What do you actually want to do?
11:58:36 <crossfader> :(
11:58:52 <bss03> KorriX: Probably IntMap or Sequence depending on what you want to do with it.
11:59:08 <mjrosenb> crossfader: you may not be able to get the latest libraries, and I think that ghc's error messages are more understandable than hugs, but all in all, it should not be impossible to use hugs
11:59:16 <KorriX> i have list like [[], [], []] and information head of with sublist put where
11:59:47 <byorgey> crossfader: just keep using hugs until you run into some unsurmountable problem.  By that time you will like Haskell so much that you will not mind shelling out for a larger hard drive ;)
11:59:49 <crossfader> mjrosenb, i don t think I m able to start a bigger project with haskell
11:59:56 <KorriX> and i am trying to make it like that: foldl someFunction [[1..n], [], []] (listOfMoves n)
11:59:56 <bss03> KorriX: You'll probably want to do your impreative actions in the State or Writer Monad.
12:00:29 <byorgey> shachaf: ah, the old story about the devil and a billion dollars, eh?
12:00:35 <KorriX> someFunction need to create new list [[],[],[]]
12:00:38 <mjrosenb> crossfader: by libraries, I mean Data.List, which just has a bunch of list utilities, and is incredibly useful for even one liners
12:00:54 <mjrosenb> crossfader: well, s/even/particularly/
12:01:01 <bss03> mjrosenb: foldl' ++
12:01:08 <crossfader> it s more, that I m about to learn basics, to be able to read haskell code, and to express simple mathematical problems in haskell
12:01:33 <byorgey> mjrosenb: you can't use Data.List with hugs??
12:01:56 <mjrosenb> byorgey: you can, but iirc, the one they ship does not have all of the functions that ghc's Data.List has.
12:01:57 <bss03> Korrix: are you doing towers of Hanoi?
12:02:04 <KorriX> yes :D
12:02:26 <KorriX> and i want to do it pure functional
12:02:35 <byorgey> mjrosenb: oh, I guess there are some functions that have been added more recently (e.g. permutations)
12:02:36 <bss03> Korrix: If so, just use the same type there, no need for advance data structures or monads.
12:02:47 <byorgey> crossfader is unlikely to run into those in particular.
12:02:51 <mjrosenb> byorgey: yup.
12:03:05 <mjrosenb> hrmm, i think System.IO also got some new stuff recently
12:03:08 <byorgey> crossfader: it should be fine.
12:03:10 <mjrosenb> that I ran into big time
12:03:46 <byorgey> crossfader: just so you know, if you ask questions in here later (and you should), people are likely to say "why are you using hugs? use ghc instead"
12:03:48 <crossfader> is it possible, that a programm i write in hugs, does not work in ghc?
12:03:49 <Jafet> hugs probably remains an excellent calculator.
12:03:52 <byorgey> crossfader: so you should feel free to ignore them.
12:04:11 <bss03> KorriX: each move will look something like this \[(h:t), d@(i:_), _] | | h <= i -> [t, (h:d), _] | otherwise = error "Bad move".
12:04:13 <byorgey> crossfader: it may be technically possible, but it's extremely unlikely.
12:04:16 <koeien> crossfader: very unlikely
12:04:55 <mjrosenb> crossfader: yes, but the chances that *you* will write such a program are small
12:05:17 <mjrosenb> crossfader: namely |let f x = x in (f True, f 13)|
12:05:20 <Jafet> byorgey, I'll start early! "why will you not be using hugs? aim to use ghc instead"
12:05:28 <mjrosenb> crossfader: will work in the latest hugs, but not in the latest ghc
12:05:29 <bss03> KorriX: You'll pattern-match on the move and the current value of the list to determine what to do.
12:05:55 <KorriX> this is solution that I wanted :D
12:05:59 <KorriX> thanks, very much
12:06:19 <byorgey> crossfader: moreover, if you do happen to write such a program, fixing it to work in GHC will be very easy
12:06:32 <bss03> Either that, or you'll have each move actually be a function (Ord a => http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a)
12:06:45 <bss03> Either that, or you'll have each move actually be a function (Ord a => [ [a] ] -> [ [a] ])
12:06:49 <Rc43> c_wraith, how should I add my build tool? If I just type build-tools: thrift it says that it doesn't know about thrift.
12:07:12 <roaldfre> Question: can parMap be fused/streamed(as much as possible)? (I'm having a space leak using parMap rdeepseq [hugeList], but it consumes nicely if I remove the parMap)
12:07:24 <crossfader> :( I can not imagine what this function will do :(
12:07:53 <Jafet> roaldfre: what does fused/streamed mean?
12:08:06 <c_wraith> Rc43: oh, hmm.  I forgot it needs to be things cabal understands. that is a problem
12:08:39 <roaldfre> it may be a slight wrong terminology
12:08:54 <rwbarton> you should focus on your actual question
12:08:56 <Rc43> c_wraith, how to get what cabal understands?
12:09:07 <roaldfre> what happens is that the list fed as an argument to parMap gets put in memory in its entirety
12:09:09 <c_wraith> Rc43: I'm not sure.
12:09:19 <roaldfre> instead of parMap consuming it piece by piece as we go allong
12:09:29 <crossfader> I check out two dirfferent haskell interpreters and both behave in a completely different wa... the online try haskell modules uses functions hugs dowsn t know :/
12:09:33 * mjrosenb wonders if the online haskell interpreter could be changed into something where you are actively editing a file that gets reloaded constantly, rather than having it just be a ghci session
12:09:33 <rwbarton> that's necessary for the "par" part, surely?
12:09:46 <rwbarton> I mean you are asking it to evaluate the whole list in parallel...
12:09:47 <acowley> roaldfre: parallelizing folds is harder than maps
12:10:00 <rwbarton> so how can it consume the list one element at a time...
12:10:18 <rwbarton> you might want one of the "windowed" strategies
12:10:37 <roaldfre> I'm asking to evaluate it in parallel, but each tread should not need the full list present..
12:10:40 <roaldfre> ah
12:10:43 <Jafet> roaldfre: are you simply using "space leak" to mean "it uses more RAM than I have"?
12:10:55 <roaldfre> hmm, I did not know such things existed (windowed strategies), will look into those, thanks!
12:10:57 <acowley> roaldfre: what you typically want to do in these situations is a recursive decomposition of the fold where the recursive calls can run in parallel
12:11:17 <byorgey> crossfader: you may just have to import some additional modules into hugs, I am not sure what tryhaskell lets you do
12:11:31 <byorgey> crossfader: if you give us some specific examples we may be able to help
12:11:56 <crossfader> the sort function
12:12:02 <crossfader> for instance...
12:12:11 <byorgey> crossfader: yes, that is from the Data.List module which is probably not loaded in hugs by default
12:12:22 <byorgey> crossfader: try typing  import Data.List   at the hugs prompt
12:12:37 <byorgey> then you should be able to use sort
12:12:45 <roaldfre> acowley: I don't quite see what you mean. Btw, the implementation that uses it is a rasterizer and I'm parallelizing over  the pixels (ie render multiple pixels simultaneously)
12:13:25 <roaldfre> oh
12:14:18 <roaldfre> and I'm inside the state monad where I need to drag along some state (random generator seed) -- but I can create an arbitrary number of such generators in advance, so that shouldn't be a problem (nvm)
12:15:04 <bgfulisblf> Does lambdabot not understand let and where expressions?
12:15:11 <KorriX> by the way: is there any method to read input into list cell ?
12:15:20 <acowley> roaldfre: the typical (if unrealistic) example is summing a list of numbers. This is typically a linear operation, but if your numbers were kept in a binary tree then you could imagine each node of the tree being an addition, and each subtree being evaluated in parallel.
12:15:36 <drull95> what's it called when a tilde shows up in a type context?
12:16:15 <acowley> drull95: an equality constraint
12:16:38 <drull95> thanks, now i know what to search for
12:17:11 <crossfader> i anyway i pasted the code i try to translate into Haskell here: http://pastebin.com/ux29nGxM
12:17:13 <mauke> The paste ux29nGxM has been copied to http://hpaste.org/56049
12:17:16 <byorgey> drull95: http://www.haskell.org/haskellwiki/GHC/Type_families#Equality_constraints
12:17:38 <drull95> yep, got it, thanks :)
12:17:43 <roaldfre> acowley: hmm, I'll ponder that for a bit ... (I'm going to have a look at those 'windowed' strategies that rwbarton mentioned, I assume he means 'parListChunk'?)
12:17:52 <rwbarton> that sounds right
12:17:57 <acowley> roaldfre: yes I think that's what he meant
12:18:14 <rwbarton> the one that means that demanding the first element of the list only spawns the computation of the first N elements
12:18:18 <rwbarton> rather than every element
12:18:21 <mjrosenb> crossfader: do you have your attempt to translate it to haskell?
12:18:25 <drull95> it seems i've come to a  point in my haskell skills where i can't seem to avoid the various extensions
12:18:31 <acowley> rwbarton: that is indeed the chunky version
12:18:39 <drull95> encountered a few new ones lately
12:18:39 <rwbarton> hm
12:18:45 <byorgey> drull95: =)
12:18:53 <drull95> am gonna have to sit down with the ghc manual :)
12:19:02 <roaldfre> whoops, should have scrolled down further, there's also parbuffer for lazy lists -- exactly what I need! (hopefully) :-)
12:19:03 <crossfader> no mjrosenb, i need to know more about basic expressions and functions
12:19:05 <byorgey> crossfader: looks like a good starting goal
12:19:06 <Jafet> drull95: welcome to Glasgow.
12:19:30 <crossfader> i don t even know how to express this recursion in a let binding
12:19:32 <byorgey> Glorious Glasgow!
12:19:46 <rwbarton> oh yeah, that sounds like the one I was thinking of. The documentation is less helpful than it might be, though.
12:19:48 * mjrosenb is not sure what fn and fn2 do in scheme; only knows lisp
12:20:17 <rwbarton> fn = f and fn2 = g
12:20:18 <Jafet> rwbarton: you're supposed to infer everything from the types
12:20:30 <byorgey> crossfader: the same way you do in Scheme.  'let' in Haskell is the same as 'letrec' in Scheme.
12:21:24 <crossfader> aah that s great, can i let 2 values bound in the same expression?
12:22:23 <byorgey> crossfader: yes
12:22:33 <byorgey> crossfader: let { x = blah; y = blah } in blah
12:22:46 <c_wraith> crossfader: every name bound in the same let expression has all the other names in that same expression in context, too.  For mutual recursion, and such.
12:23:08 <mjrosenb> oh hey... those are being bound...
12:23:16 <byorgey> > let { x = 1 : y; y = 2 : x } in x
12:23:17 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
12:23:20 <roaldfre> acowley, rwbarton: thanks for the tips, guys! It runs in constant space now! :-)
12:23:31 <roaldfre> (using parBuffer)
12:23:33 <acowley> roaldfre: with parBuffer? That's great!
12:23:40 <acowley> roaldfre: how is the speedup?
12:23:58 <roaldfre> I'm getting a clean 2x speedup on my dual core :-)
12:24:04 <c_wraith> impressive
12:24:09 <drull95> grr, im reading handbook on constraint programming and trying to build monadiccp, getting real excited and now i can't focus
12:24:12 <c_wraith> a full 2x speedup with 2 cores isn't that common
12:24:15 <drull95> grah, why does this always happen
12:24:17 <drull95> to me
12:24:38 <rwbarton> roaldfre, nice
12:24:41 <c_wraith> drull95: lack of practice at being excited and focusing at the same time?
12:24:54 <roaldfre> I'm doing buckets of 1000 pixels per 'job' (each core gets 1000 pixels), which is big enough a job to keep the scheduling/syncing overhead minimal
12:25:42 <drull95> c_wraith, maybe. i'm going to go for a run, maybe if i tire myself out i will be able to sit still and read
12:25:59 <mjrosenb> roaldfre: that sounds like sensible code that the compiler should be able to do for you :(
12:26:34 <rwbarton> it really doesn't...
12:27:17 <rwbarton> unless you were to do some JIT sort of thing
12:27:54 <roaldfre> those buckets are still from when 1 was having space leaks, will try to do without them and see if GHC is sufficiently smart (though distributing a single pixel over each tread will kill performance to only a 1x speedup (ie no speedup))
12:28:02 <roaldfre> from when I*
12:29:53 <crossfader> so i could find many procedures from scheme in haskell yet, even if i still consider the syntax weird
12:30:56 <Jafet> Also, many of them should no longer be considered procdures
12:31:15 <Jafet> They are simply functions
12:32:33 <roaldfre> Yup, I still need the buckets (otherwise I'm only loading my cpu by ~115% instead of ~190% with the buckets -- though I need some more tests)
12:32:37 <crossfader> in scheme functions were called procedures, i don t know why
12:32:57 <Jafet> setcar!, for example, is a procedure that is clearly not a function
12:35:04 <crossfader> in the begining most of my definitions started with begin, today i usually don t use (begin)
12:35:50 <crossfader> rather (let) and i m glad to see, that the "let" handling is not much different in Haskell
12:36:06 <koeien> it's more like letrec
12:36:26 <crossfader> :)
12:36:28 <koeien> > let f 0 = 1; f x = f (x-1) + 1 in f 37
12:36:29 <lambdabot>   38
12:36:54 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in (take 10 evens, take 10 odds)
12:36:54 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18],[1,3,5,7,9,11,13,15,17,19])
12:37:01 <roaldfre> koeien: do you speek Dutch?
12:37:05 <koeien> roaldfre: yes
12:37:16 <roaldfre> ahzo, vandaar de naam :-)
12:37:43 <tsousa> does anyone can help me solve the problem number 4 in the euler project? Find the largest palindrome that is the product of the two 3 number digits
12:37:43 <crossfader> ik kan niet goed nederlands...
12:37:44 <tsousa> ?
12:38:09 <koeien> > let x = 3 in let x = x + 1 in x -- does not terminate, x is being shadowed
12:38:13 <lambdabot>   mueval-core: Time limit exceeded
12:38:35 <crossfader> mijn nederlands is nog meer slecht dann mijn weten van Haskell
12:39:48 <koeien> tsousa: sure, did you start / what do have now?
12:39:51 <roaldfre> haha :-)
12:40:06 <crossfader> maar ik begrijp well, alleen praten kan ick niet goed
12:40:08 <tsousa> koeien, what is the stuff i am not seeing a way of doing that
12:40:43 <koeien> tsousa: well, for example, can you compute all products of three-digit numbers?
12:40:56 <tsousa> koeien, yes
12:41:11 <The_Journey> how would I reshape a linear list into a 3-D list given three integers?
12:41:20 <koeien> excellent, can you find, given a number, its decimal representation?
12:42:54 <tsousa> koeien, that no
12:43:32 <koeien> there is a very easy solution but it depends on the fact that we use decimals
12:43:36 <koeien> > show 3383
12:43:37 <lambdabot>   "3383"
12:44:04 <tsousa> koeien, how can i convert it?
12:44:10 <koeien> to what?
12:44:55 <tsousa> convert to decimals
12:45:33 <koeien> so: 123 -> [1,2,3]  ?
12:46:07 <tsousa> koeien, how is that what you were talking about
12:46:11 <tsousa> yes that i know
12:46:47 <Rc43> Ok, guys. So I have done a package with code generation. How can I make this package expose modules with prefix? E.g. now they are exposed like 'Megamodule', but I want 'CoolProject.Megamodule'.
12:47:01 <Jafet> > digitToInt <$> show 3383
12:47:02 <lambdabot>   [3,3,8,3]
12:47:23 <koeien> so you have all pairs of three-digit numbers, a function that computes the decimal representation of a number
12:47:29 <Jafet> Of course, doing it this way does not teach you any high school math, which is the primary goal of project euler
12:47:31 <tsousa> what is <$> ?
12:47:34 <crossfader> hmm, [2..8] kann er lesen, [2..8,10] nicht :(
12:47:38 <koeien> tsousa: in this case, map
12:47:49 <koeien> crossfader: [2,4..10]
12:47:59 <Rc43> I can do it with script, but ...
12:48:17 <koeien> tsousa: now, can you write a function that detects if a list is a palindrome?
12:48:22 <Saizan> Rc43: change the names in the module headers and put the file in a CoolProject directory
12:48:36 <tsousa> koeien, i can use the function reverse
12:48:43 <crossfader> oops, sorry i m so tired i started write german :/
12:48:43 <koeien> tsousa: yes
12:48:48 <Saizan> *files
12:48:51 <Rc43> Saizan, All code is generated
12:49:04 <Rc43> Saizan, I can't change it
12:49:22 <koeien> tsousa: so can you find all products whose decimal representation is a palindrome?
12:49:29 <Saizan> Rc43: and you've no way to control the module names?
12:49:59 <tsousa> koeien, yes
12:50:05 <koeien> tsousa: then, you just need to find the longest one. hint: use maximumBy
12:50:13 <Rc43> Saizan, I can walk generated files at the build moment and change headers, but it is awful.
12:50:25 <rwbarton> don't you just want the largest one? even easier
12:50:27 <Jafet> GHC ist lieber weiblich
12:50:40 <koeien> rwbarton: ah yes, that's even easier, yes.
12:50:49 <Rc43> Saizan, but I should look at generation util, may be it gives opportunity to change names
12:50:50 <Saizan> Rc43: the tool you're using for generation doesn't let you control the names?
12:51:08 <tsousa> koeien, yes but how can i find the number that are multiple to give the palindrome
12:51:37 <koeien> maximum (filter (isPalindrome . decimalRepresentation) allProducts)
12:52:00 <Rc43> Saizan, it seems, no
12:52:49 <Rc43> Saizan, cabal can't modify module names?
12:53:34 <Saizan> Rc43: no
12:53:34 <tsousa> koeien, but having a list with all the produt will not be that eficient
12:53:56 <rwbarton> tsousa, sure it will, why do you say it won't
12:54:04 <KorriX> how to must haskell to tail [] = [] :) ?
12:54:06 <koeien> ah but that list is never constructed completely in memory
12:54:10 <koeien> KorriX: drop 1
12:54:26 <KorriX> head [] = [] ?
12:54:33 <koeien> KorriX: that won't typecheck in general
12:54:33 <rwbarton> no
12:54:46 <KorriX> > head []
12:54:46 <lambdabot>   *Exception: Prelude.head: empty list
12:54:49 <tsousa> rwbarton, computate all of the 3 digit numbers?
12:54:53 <KorriX> i want to get empty list
12:55:01 <koeien> KorriX: that's not possible. that won't typecheck.
12:55:12 <Jafet> > maximum [ (x,y,x*y) | x <- [100..999], y <- [x..999], (==) <*> reverse $ show $ x*y ]
12:55:14 <Philonous> > (take 1 [1..5], take 1 [])
12:55:14 <lambdabot>   (924,962,888888)
12:55:15 <lambdabot>   ([1],[])
12:55:17 <koeien> what you probably want is listToMaybe (better called safeHead)
12:55:18 <rwbarton> > map head ["hello", "world", "", "bye"]
12:55:19 <lambdabot>   "hw*Exception: Prelude.head: empty list
12:55:25 <koeien> > listToMaybe [3,4,5,6]
12:55:26 <lambdabot>   Just 3
12:56:28 <koeien> :t head
12:56:29 <lambdabot> forall a. [a] -> a
12:56:38 <crossfader> how do i declare functions which depend on 2 arguments?
12:56:46 <koeien> crossfader: look up "currying"
12:56:53 <rwbarton> f x y = ...
12:56:59 <koeien> basically all functions in haskell take exactly 1 argument.
12:57:18 <koeien> f 1 2 reads as (f 1) 2
12:57:41 <koeien> Integer -> Integer -> Integer  is equivalent to Integer -> (Integer -> Integer)
12:57:59 <koeien> so f :: Integer -> Integer -> Integer; f 1 :: Integer -> Integer and f 1 2 :: Integer
12:58:07 <crossfader> yea, so i can write  (f x y) x+y   ????
12:58:53 <koeien> you can write f x y = x + y
12:58:54 <rwbarton> what's that supposed to mean?
12:59:02 <crossfader> ah well
12:59:03 <koeien> in a haskell-file, at top-level
12:59:06 <crossfader> sorry
12:59:11 <rwbarton> Also, a single question mark is sufficient to indicate your intent
12:59:31 <crossfader> i guess i m too fixed on brackets :(
13:00:14 <shachaf> byorgey: ?
13:02:10 <byorgey> shachaf: the proof of LEM from Peirce's law
13:02:34 <rwbarton> you can add extra parentheses for grouping when you're starting out and not sure of the precedence rules yet. you can even write using prefix syntax like ((+) x y), though people will look at you funny for doing that. at some early point though you should learn where parentheses are and are not needed.
13:02:49 <The_Journey> is there a function that will get me a list of [IO StdGen]?
13:02:51 <shachaf> byorgey: What's the context?
13:02:58 <byorgey> shachaf: see www.cs.tufts.edu/~nr/cs257/archive/phil-wadler/dual.pdf
13:03:10 <rwbarton> shachaf: The billion dollar devil thing
13:03:17 <hughfdjackson> do people tend to unit test in haskell?
13:03:25 <hughfdjackson> or is quickcheck king?
13:03:32 <shachaf> I was talking about it in another channel yesterday, but I don't think you're there.
13:03:43 <byorgey> shachaf: you pasted the code in here earlier.
13:03:45 <acowley> So now I want to come up with a demo using OpenCV, OpenCL, and OpenGL together. I bet it can be awesome and < 50 lines.
13:03:54 <shachaf> byorgey: Oh! Right.
13:04:02 <byorgey> shachaf: you were talking about parsing of 'forall' without a paren in front, but I recognized the code =)
13:04:08 <acowley> hughfdjackson: Unit testing is great and well supported
13:04:23 <hughfdjackson> :D yay
13:04:43 <hughfdjackson> (i hope you don't think me lazy for not looking these things up - i tend to come here once all my other work is done and i'm tired)
13:04:56 <shachaf> byorgey: I used a demonstration with a machine and an orange.
13:05:10 <shachaf> byorgey: But I think the billion dollars and the devil is better. :-)
13:05:14 <byorgey> =)
13:05:25 <mm_freak> lazysmallcheck is great for testing, but unfortunately it's quite incomplete
13:05:40 <hughfdjackson> what tool ought i to be looking at?
13:05:55 <acowley> hughfdjackson: use test-framework in conjunction with quickcheck and hunit
13:06:06 <hughfdjackson> acowley: duly noted ^_^
13:06:52 <mm_freak> quickcheck and hunit are the common tools, but there are other tools, too
13:06:57 <shachaf> byorgey: That line isn't LEM, though.
13:07:11 <mm_freak> personally i prefer the smallcheck family of libraries over quickcheck
13:08:48 <Phlogistique> is there a simple idiom for a = if isJust b then fromJust b else if isJust c then fromJust c else if isJust d then fromJust d... ?
13:09:04 <shachaf> @ty let lem :: (forall p. ((p -> forall q. q) -> p) -> p) -> Either (a -> forall b. b) a; lem ccc = ccc (\k -> Left (\v -> k (Right v))) in lem
13:09:05 <lambdabot>     Illegal polymorphic or qualified type: forall b. b
13:09:05 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
13:09:05 <lambdabot>     In the type signature for `lem':
13:09:07 <cheater> hi
13:09:11 <shachaf> @ty let lem :: (forall p. ((p -> forall q. q) -> p) -> p) -> forall b. Either (a -> b) a; lem ccc = ccc (\k -> Left (\v -> k (Right v))) in lem
13:09:12 <lambdabot> forall a b. (forall p. ((p -> forall q. q) -> p) -> p) -> Either (a -> b) a
13:09:18 <shachaf> ImpredicativeTypes. :-(
13:09:18 <cheater> sorry about the disconnects i think my internet works now
13:09:28 <mauke> > Just 1 `mplus` Just 2
13:09:29 <lambdabot>   Just 1
13:09:32 <rwbarton> Phlogistique: fromMaybe defaultCase $ msum [b,c,d,...]
13:09:34 <koeien> Phlogistique: mplus
13:09:43 <koeien> msum
13:09:47 <zachk> is there an idiom for: take x (repeat b) ???
13:09:54 <mauke> head (catMaybes [...] ++ z)
13:09:54 <Phlogistique> koeien rwbarton thanks
13:09:55 <koeien> zachk: replicate x b
13:09:57 <shachaf> Phlogistique: Please don't use isJust+fromJust. :-(
13:10:02 <rwbarton> what is today, use multiple question marks day
13:10:08 <Phlogistique> shachaf: that's why I asked
13:10:12 <zachk> koeien: thank you :-D
13:10:20 <shachaf> Phlogistique: You can still use pattern-matching, even not knowing the idiom.
13:10:25 <shachaf> rwbarton: You got a problem with that???
13:10:40 <Phlogistique> shachaf: yes, but it would have been longer to explain on IRC
13:10:59 * shachaf sighs. fromJust is an Evil function.
13:11:46 <mauke> can I fold this with fromMaybe?
13:12:18 <Derrick_> Excluding haskell, what is the next best programming language to do mathematical computation?
13:12:32 <mauke> :t foldr fromMaybe
13:12:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
13:12:34 <lambdabot>       Expected type: Maybe a
13:12:34 <lambdabot>       Inferred type: a
13:12:36 <rwbarton> :t foldr (flip fromMaybe) ?x
13:12:37 <lambdabot> forall b. (?x::b) => [Maybe b] -> b
13:12:48 <Phlogistique> Derrick_: FORTRAN
13:13:11 <mauke> I like that
13:13:13 <Derrick_> Phlogistique> what about Python?
13:13:15 <koeien> Derrick_: that's a bit difficult to answer. python has good bindings to some lin. alg packages
13:13:28 <rwbarton> "mathematical computation" is a broad area also
13:13:42 <koeien> R is very useful for statistics
13:13:58 <rwbarton> e.g. do you want to do statistics, numerical computations with matrices, symbolic integration, abstract algebra etc. etc.
13:14:05 <koeien> FORTRAN has compilers that produce efficient code
13:14:10 <Derrick_> Debating whether I should learn Scala or Python after Haskell
13:14:28 <cheater> python
13:14:51 <cheater> it has a better stdlib and is integrated in most of the important OSes, kinda like a new C
13:14:53 <Phlogistique> Derrick_: how about Ruby? It has monads! http://ick.rubyforge.org/
13:15:05 <cheater> how about php
13:15:10 <rwbarton> mauke: oh, this foldr (flip fromMaybe) takes the last Just value though
13:15:13 <Axman6> APL?
13:15:14 <koeien> cheater: out! heretic!
13:15:18 <Axman6> COBOL!
13:15:24 <cheater> koeien: you misunderstood.
13:15:25 <rwbarton> I think?
13:15:37 <rwbarton> > foldr (flip fromMaybe) 1 [Just 2, Nothing, Just 3]
13:15:38 <lambdabot>   2
13:15:41 <rwbarton> oh I guess not
13:15:47 <aninhumer> INTERCAL!
13:15:55 <Derrick_> I've tried ruby, python's syntax seems easier. But that is just me nitpicking
13:16:00 <Jafet> aninhumer: PLEASE NO
13:16:00 <krakrjak> C++ with good libraries...  Still combersome compared to Haskell, but efficient.
13:16:38 <Derrick_> Side Question: How do I make my name appear in red?
13:16:45 <rwbarton> You don't
13:16:55 <mauke> huh?
13:17:01 <mauke> use a red pen
13:17:12 <hughfdjackson> make sure its dry wipe
13:17:17 <rwbarton> personally I find most uses of foldl/foldr harder to understand than alternatives unless the operation is associative or really naturally the action of a monoid on something
13:17:17 <aninhumer> Whenever I go back to a f(x,y) syntax language now I really miss partial application :/
13:17:18 <hughfdjackson> :| otherwise you may regret it
13:17:26 <Axman6> Derrick_: how much haskell do you know btw?
13:17:38 <Derrick_> A week's worth
13:17:48 <shachaf> rwbarton: foldr tends to be clearer than foldl, I think.
13:18:00 <Derrick_> Stumbled on this channel via tryhaskell.org
13:18:04 <koeien> yeah foldr is pretty clear since it just replaces the constructors
13:18:17 <Axman6> because, if you've just started, it might be years before you 'know haskell' to a level where you're bored and what a new languages (though the ones you've mentioned are uninteresting compared to haskell)
13:18:31 * Saizan has used induction principles directly often enough that finds both fairly clear
13:18:41 <rwbarton> well, foldr (flip fromMaybe) x is very obfuscated compared to fromMaybe x . msum, to me
13:19:07 <Derrick_> Axman6_: I tend to jump around before finding a specific language; haskell seems to be my favorite. While python is a close second
13:19:51 <shachaf> Derrick_: You're probably much too early to be picking favourites. :-)
13:19:53 <Saizan> rwbarton: ah, yeah, because msum is an higher-level operation
13:20:12 <cheater> python is the language with the best development methodology, displayed homogenously by a large majority of the community
13:20:13 <Derrick_> shachaf_: True.
13:20:19 <cheater> haskell is missing a lot of that
13:20:27 <cheater> hence, learn python and improve your haskell
13:21:02 <hpaste> “John Lien” pasted “Boyer-Moore  majority voting algorithm” at http://hpaste.org/56052
13:21:09 <rwbarton> I guess here foldr feels "macro-ish" in that I'm not going to reason about it without expanding its definition anyways
13:21:27 <rwbarton> so for me, it doesn't save any conceputal complexity
13:21:28 <shachaf> rwbarton: You mean "function-ish"?
13:21:30 <rwbarton> no
13:21:54 <shachaf> I just think of foldr as replacing (:) with f and [] with z, as is the standard explanation.
13:21:56 <Derrick_> Does anyone have any preference for a haskell IDE? I been playing around with ghci and editing my programs in notepad with the :e function and then reloading them. Kind of tedious
13:21:59 <shachaf> That's not equivalent to expanding its definition.
13:22:01 <tsousa> what is wrong in this code? http://dpaste.com/681093/
13:22:02 <cheater> vim
13:22:05 <koeien> Derrick_: i use vim.
13:22:09 <shachaf> Derrick_: That's what I do, except not with notepad.
13:22:21 <cheater> you can get my vimrc if you want, it is more than adequate for haskell editing
13:22:30 <Derrick_> Any links?
13:22:32 <mauke> tsousa: precedence
13:22:41 <shachaf> Derrick_: There's no point to using vim if you're not familiar with it.
13:22:43 <mauke> $ applies functions. == doesn't return a function.
13:22:44 <koeien> tsousa: your $ is wrong, this parses as (x*y == reverse) ...
13:22:44 <shachaf> Just find a simple editor.
13:22:47 <Derrick_> I run the Haskell platform off my USB so would VIM world with that?
13:22:48 <Phlogistique> 22:50:40  * shachaf sighs. fromJust is an Evil function. <- also, why? If it is easy to prove that it won't fail, what's wrong?
13:22:56 <mauke> Derrick_: yes
13:23:09 <tsousa> mauke, koeien so how can i fix it?
13:23:09 <shachaf> Phlogistique: That you're the one doing the proving, instead of the compiler.
13:23:20 <Derrick_> shachaf_: Got to learn sometime, right?
13:23:41 <shachaf> Derrick_: Are you learning Haskell or learning vim? I use vim myself, but I recommend picking one of those.
13:23:43 <koeien> tsousa: well, reverse (map digitToInt (show x*y)) is a list of digits
13:23:44 <Rc43> Saizan, sed -i.origin 's/module\ /module\ PREFIX./g' generated/HReal/Ifaces/*
13:23:55 <Saizan> you don't expand direct recursion to understand what it does, you use induction, same goes for foldr
13:24:01 <shachaf> There are plenty of good editors for Windows.
13:24:28 <koeien> tsousa: you probably want something like
13:24:44 <rwbarton> shachaf: I guess a way of saying how it's "macro-ish" is--when was the last time you saw foldr passed as an argument to something
13:24:52 <Derrick_> shachaf_: Haskell. Just thought learning vim would save me time down the line when coding haskell
13:24:57 <rwbarton> rather than "foldr f z" or at least "foldr f"
13:24:59 <koeien> [x*y | x <- [100..999], y <- [x..999], let ds = map digitToInt (show (x*y)), ... ]
13:25:07 <shachaf> rwbarton: So? That's true of a lot of functions.
13:25:12 <rwbarton> I don't think so
13:25:17 <shachaf> Hmm.
13:25:21 <rwbarton> it's not true of msum for instance, I passed it to (.) above
13:25:44 <shachaf> How often to you pass (!!) to functions?
13:25:52 <Cale> :t let swing f c a = f ($ a) c in swing foldr
13:25:53 <lambdabot> forall a t. t -> a -> [a -> t -> t] -> t
13:25:54 <rwbarton> Isn't (!!) Evil????
13:26:03 <shachaf> rwbarton: True. :-)
13:26:10 <shachaf> rwbarton: foldr is a three-argument function, which is probably the main reason you don't pass it around.
13:26:16 <rwbarton> Hmm
13:26:36 <shachaf> Do you pass "map" around?
13:26:38 <Cale> :t let swing f c a = f ($ a) c in swing map
13:26:39 <lambdabot> forall a b. [a -> b] -> a -> [b]
13:26:47 <mjrosenb> rwbarton: i've used functions that take either foldr or foldl as the method of accumulating a list it generates
13:26:51 <Cale> :t let swing f c a = f ($ a) c in swing partition
13:26:51 <lambdabot> forall a. [a -> Bool] -> a -> ([a -> Bool], [a -> Bool])
13:27:17 <shachaf> mjrosenb: You can't pass plain foldr/foldl, though, because the argument order is reversed. :-)
13:27:31 <shachaf> @ty foldl.flip
13:27:32 <lambdabot> forall a b. (b -> a -> a) -> a -> [b] -> a
13:28:20 <crossfader> how do i write if conditions?
13:28:27 <mjrosenb> shachaf: well in a *sane* language, they have the same argument order :-p
13:28:30 <DanBurton> > if True then 3 else 4
13:28:31 <lambdabot>   3
13:28:38 <mdmkolbe> What does "instance Eq (a Int) where" mean?  GHC accepts it but I can think of no meaning for it
13:28:40 <crossfader> ah thx
13:28:52 <DanBurton> crossfader: parenthesize to taste
13:28:53 <mercury^> Cale: I like your swing.
13:29:02 <shachaf> mjrosenb: Oh?
13:29:04 <shachaf> > foldl f z [a,b,c]
13:29:05 <lambdabot>   f (f (f z a) b) c
13:29:09 <shachaf> > (foldl.flip) f z [a,b,c]
13:29:11 <lambdabot>   f c (f b (f a z))
13:29:13 <mjrosenb> shachaf: namely, sml.
13:29:17 <shachaf> There's some sense to the argument order being flipped, I think.
13:29:19 <mauke> mdmkolbe: it looks like it means any type constructor * -> * yields an instance of Eq when applied to Int
13:29:21 <koeien> crossfader: there is "if", but more idiomatic is | in definitions
13:29:26 <mauke> which should basically clash with everything
13:29:39 <shachaf> mjrosenb: Let me just look that up in the SML spec.
13:29:41 <koeien> crossfader: f x | even x = div x 2;   | odd x = 3*x + 1 -- example
13:30:06 <shachaf> mjrosenb: Anyway foldr and foldl behaviour is completely different in a lazy language.
13:30:41 <tsousa> koeien, 88888 is not the answer
13:30:42 <tsousa> meh
13:31:48 <mdmkolbe> mauke: that sound like madness (cf. type functions and synonyms)
13:32:02 <koeien> tsousa: that's correct, I get a different result
13:32:05 <aninhumer> Hmm, where can I find information about Caleskell? google is surprisingly unhelpful on this topic
13:32:36 <mauke> haha
13:32:43 <rwbarton> mdmkolbe: type functions don't exist, type synonyms are expanded earlier
13:32:44 <mauke> aninhumer: it's an in-"joke"
13:32:48 <koeien> tsousa: probably they meant the maximal number, not a maximal-length palindrome
13:32:54 <aninhumer> mauke: I see?
13:33:17 <mauke> aninhumer: some people use "Caleskell" to mean "Haskell + the libraries imported by lambdabot"
13:33:35 <rwbarton> mdmkolbe: (if by type functions you mean type families, those fall under type synonyms for this purpose)
13:33:45 <tsousa> koeien, the maximal number formed by two three digit numbers
13:33:46 <shachaf> rwbarton: Type constructors are type functions. :-)
13:33:52 <rwbarton> "a Int" unifies with anything that is a type constructor applied to Int
13:34:04 <aninhumer> mauke: I'd also read something about a modified Prelude?
13:34:06 <rwbarton> shachaf: well, kind of
13:34:11 <rwbarton> the terminology is sort of poor all-around
13:34:15 <shachaf> Yep.
13:34:16 <Phlogistique> is there a way to factorize a condition on the binding for several variables? for exemple I got default :: Maybe a; let { a = liftM blahA default; b = liftM blahB default; c = liftM blahC default}
13:34:20 <aninhumer> unless that just means more imports
13:34:21 <rwbarton> e.g. a Int could be Int -> Int
13:34:33 <mauke> aninhumer: I think it uses the standard Prelude
13:34:39 <rwbarton> but is (->) Int a "type constructor"?
13:35:42 <mdmkolbe> rwbarton: ok, that is slightly less mad, but it still feels dirty (it's like it's breaking some sort of referential-transparency principal at the type level)
13:35:59 <rwbarton> I don't see what you mean
13:36:12 <shachaf> rwbarton: It's a type function at any rate. :-)
13:36:13 <aninhumer> On a similar topic, what happened to Haskell 2011/12?
13:36:28 <c_wraith> 11 was canceled, 12 is in process
13:36:33 <rwbarton> shachaf, I assume when people say type function they usually mean something like /\ a . F (G a)
13:36:38 <tsousa> koeien, it's my third value 906609
13:36:44 <tsousa> i dont know why
13:36:52 <shachaf> Could one say that a "constructor" is something that takes an argument but can't be reduced when applied?
13:37:01 <crossfader> i m getting so tired
13:37:14 <crossfader> i guess i won t get ready with it today
13:37:15 <shachaf> That would make both Foo and Foo 5 a constructor, in data Foo = Foo Int Int
13:37:19 <crossfader> :(
13:37:28 <shachaf> No, that doesn't work with the standard definition.
13:38:09 <rwbarton> mdmkolbe: a type is either a built-in type (or something defined with data/newtype) or the application of a type term to another type term
13:38:13 <Saizan> if you define f a () = (); then f 5 can't be reduced
13:38:42 <rwbarton> mdmkolbe: "instance Num (a Int) where ..." tries to define an instance for all those types of the second variety where the second type term is "Int"
13:39:35 <shachaf> instance Num (an Int). Grammar, please.
13:39:50 <rwbarton> this application is a structural thing, though... I can really take apart [Int] into [] and Int. that's related to why there are no type functions
13:40:11 <rwbarton> maybe that's what your "referential-transparency" is referring to
13:40:47 <mdmkolbe> rwbarton: I don't know what you mean about the "structural thing"
13:40:53 <shachaf> rwbarton: You can take (Just 5) into Just and 5 too.
13:41:05 <rwbarton> I mean it's like data Type = AtomicType | Application Type Type
13:41:32 <rwbarton> not just data Type = ????? where [] is just some old function from Types to Types
13:41:52 <rwbarton> am I making any sense?
13:42:47 <rwbarton> given a type you can ask whether it is an application of something to something else, and if so it is such an application in a specific, well-defined way
13:43:04 <mdmkolbe> rwbarton: yeah, but I guess part of what bugs me is that with "Type", you can't pattern match against "a Int".  You have to match against a particular constructor
13:43:19 <rwbarton> it's like a pattern match against Application _ Int
13:43:40 <mdmkolbe> rwbarton: fair point
13:44:26 <rwbarton> now of course, you won't be able to really do anything with a value if you just know it has a type like "a Int", so you may have some trouble defining (==)
13:44:36 <rwbarton> I think that wasn't your question though
13:44:48 <mdmkolbe> rwbarton: I'm used to thinking "data Type where [] :: Type -> Type; Int :: Type; etc."
13:45:25 <rwbarton> think about what happens when I write "return 3 :: [Int]"
13:45:34 <mdmkolbe> (nah, that wasn't my question (though I'm sure Oleg could think of soemthing useful to do with it))
13:45:45 <rwbarton> I know   return :: a -> m a
13:46:07 <rwbarton> in order to figure out what 'm' is I need to know that since 'm a = [] Int' we must have 'm = []' and 'a = Int'
13:46:09 <Mkman> i cant assign a list comprenhesion to a variable? like a = [...] ?
13:46:33 <monochrom> I can. what did you try, exact verbatim?
13:46:40 <shachaf> Mkman: There's no such thing as "assignment" or "variable". :-)
13:46:49 <shachaf> You sound confused. What are you actually trying to do?
13:46:58 <monochrom> oh, just s/assign/bind/
13:47:02 <mdmkolbe> rwbarton: I see what you mean
13:47:12 <xplat> good old "Can't happen" errors
13:47:24 <Mkman> shachaf: i need to find the maximum of a list of value
13:47:26 <Mkman> values
13:47:28 <xplat> we programmers don't know the meaning of the word 'impossible'!
13:47:36 <xplat> (literally, we don't know what it means)
13:47:44 <Mkman> so i want to assign it to a variable and then check
13:48:22 <koeien> Mkman: are you in ghci?
13:48:36 <koeien> Mkman: then use  "let"
13:48:40 <koeien> Mkman: e.g.  let x = 37
13:48:50 <Mkman> koeien: no main = do
13:48:58 <koeien> then also
13:49:06 <koeien> main = do { let x = 37; print x } -- eg
13:50:03 <Mkman> koeien: yes i didnt know that it also required the let keyword in a file
13:50:04 <Mkman> thanks
13:50:20 <koeien> Mkman: in do-blocks it does
13:50:39 <mdmkolbe> Mkman: the top level of "ghci" is actually in a do-block
13:50:53 <koeien> mdmkolbe: it's slightly more magical than that
13:51:41 <Mkman> nice :)
13:52:00 <byorgey> koeien: nonetheless, it's a good first approximation.
13:52:24 <byorgey> I doubt Mkman really needs to know the particular differences at this point.
13:52:30 <koeien> fair enough
13:53:34 <monochrom> I doubt the majority here care about need-to-know
13:53:53 <monochrom> the majority here defines helpful = chatty and information overload
13:55:04 <mdmkolbe> monochrom: so the questioners expect lazy-eval and the answerers give eager-eval?
13:55:16 <KorriX> if i have type "IO [[a0]]" how to extract [[a0]] ?
13:55:27 <rwbarton> @wiki Introduction to IO
13:55:28 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:55:35 <monochrom> in fact I just read someone said "sometimes solving every conceivable variant of someone's problem is simply more efficient than finding out what they actually want." a few hours ago
13:55:45 <rwbarton> KorriX: read that
13:56:08 <KorriX> it is not about that
13:56:13 <KorriX> i return some value
13:56:16 <KorriX> using return
13:56:24 <KorriX> and return pack it into IO functor
13:56:27 <rwbarton> monochrom: plus, the former can be parallelized over several responders, while the latter is limited by the person asking the question
13:56:34 <KorriX> i want to unpack it
13:56:42 <monochrom> mdmkolbe, the questioners expect to tell 0 information and the answerers expect to tell infinite information. if you just ask "hi, what should I do?" you will get good advice
13:57:04 <shachaf> KorriX: Your question doesn't make sense.
13:57:14 <shachaf> KorriX: foo :: IO a doesn't contain an "a".
13:57:23 <shachaf> KorriX: Read about how IO works.
13:57:29 <KorriX> IO is not a functor ?
13:57:32 <KorriX> like Maybe ?
13:57:33 <koeien> IO is a functor, yes
13:57:35 <shachaf> IO is a functor.
13:57:42 <mauke> IO is not like Maybe
13:57:48 * shachaf "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
13:57:51 <koeien> but functors don't allow in general "extraction". Maybe is special in that regard
13:57:52 <hpc> IO is like a waffle
13:58:26 <shachaf> hpc: Come on.
13:58:35 <hpc> shachaf: okay fine, a pancake
13:58:39 <Phlogistique> Hi
13:58:39 <shachaf> hpc: Is it really necessary to make these jokes every single time someone is actually confused about something?
13:58:39 <c_wraith> hpc: tasty with syrup on it?
13:58:43 <Phlogistique> What should I do?
13:58:45 <shachaf> It doesn't help in the least.
13:58:52 <shachaf> KorriX: Read "intrduction to IO".
13:58:56 <shachaf> @google introduction to IO haskell
13:58:58 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:58:58 <lambdabot> Title: Introduction to IO - HaskellWiki
13:59:10 <koeien> KorriX: are you following a tutorial / book? there is probably a chapter on I/O in Haskell
13:59:19 <KorriX> yes, i do
13:59:34 <rwbarton> KorriX: btw this is the most frequently asked question about haskell
13:59:57 <KorriX> i am trying to fold some list - and put some output when folding
13:59:57 <rwbarton> so you can assume that our answers are in fact what you are looking for
14:00:14 * hackagebot postgresql-simple 0.0.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.0.1 (LeonSmith)
14:00:15 <koeien> (IO is admittedly confusing for people coming from other languages)
14:00:15 <KorriX> my fold function is 'do' construction
14:00:17 <monochrom> rwbarton, problem-solving will always be limited by the person who thinks up the problem. the faster he/she learns how to think up and clarify a problem, the better.
14:00:29 <mauke> KorriX: 'do' doesn't mean much
14:00:37 <mauke> KorriX: that's like saying "my function uses == somewhere"
14:01:16 <KorriX> but when i am returning something in foldl (using return) i get type missmatch
14:01:27 <hpc> :t foldl'
14:01:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:01:42 <shachaf> KorriX: The type mismatch indicates that you're trying to do somethig nonsensical.
14:01:53 <hpc> :t foldl' (\m x -> putStrLn x >> m)
14:01:54 <lambdabot> forall b. IO b -> [String] -> IO b
14:02:43 <KorriX> function = do
14:02:43 <KorriX> ...
14:02:43 <KorriX> retrun [[1],[2],[3]
14:02:43 <KorriX> foldl function [[2],[3],[4]] (someList)
14:02:54 <KorriX> and return is IO action
14:03:02 <KorriX> only returning something
14:03:13 <KorriX> and fold starting value is normal list
14:03:14 <hpc> KorriX: could you hpaste the code you have and the results you want?
14:03:17 <hpc> @where hpaste
14:03:17 <shachaf> KorriX: That does nothing and is probably very far from what you want.
14:03:17 <lambdabot> http://hpaste.org/
14:03:18 <Saizan> return doesn't work like in imperative languages, btw
14:03:19 <koeien> KorriX: do you know what "return" does? where did you read it?
14:03:25 <shachaf> KorriX: You should read an introduction to how IO works in Haskell.
14:03:38 <KorriX> yes
14:03:45 <KorriX> i know how io works !
14:03:55 <koeien> ok. then please paste your code
14:03:56 <koeien> @hpaste
14:03:56 <lambdabot> Haskell pastebin: http://hpaste.org/
14:04:14 <Saizan> shachaf: he might not even want to do I/O here
14:04:24 <hpaste> KorriX pasted “Problem” at http://hpaste.org/56053
14:04:30 <KorriX> http://hpaste.org/56053
14:04:34 <shachaf> KorriX: The question "how do I extract [a0] from IO [a0]?" seems to indicate that you should read more about it.
14:04:35 <KorriX> :)
14:04:55 <KorriX> i mean type conversion
14:05:01 <hpc> KorriX: perhaps this will help:
14:05:13 <hpc> KorriX: right now you want to get an 'a' from an 'IO a'
14:05:16 <rwbarton> (hoping for foldM rather than a burrito analogy)
14:05:24 <hpc> KorriX: presumably you will apply it to some 'a -> b' at some point
14:05:27 <shachaf> KorriX: "converting" IO x to x isn't only impossile, it's nonsense.
14:05:35 <shachaf> (Well, to be more precise, it's *possible* but nonsense.)
14:05:40 <hpc> KorriX: so instead of yoinking stuff out of IO, you bring your funtions to the action
14:06:12 <hpc> KorriX: ie, make the function 'a -> b', then apply it to something of type '(a -> b) -> (IO a -> IO b)'
14:06:13 <koeien> KorriX: is there any reason other than debugging/tracing for using IO ?
14:06:20 <hpc> which "lifts" the function to act on IO actions
14:06:34 <koeien> KorriX: (for your use case)
14:06:44 <shachaf> Sigh... #haskell
14:06:46 <KorriX> printing hanoi towers like asciiart
14:07:05 <monochrom> consider data USEconomy a = U (a -> USEconomy a). you can't extract Money from USEconomy Money. in fact, all you can do is insert more coins.
14:07:06 <koeien> KorriX: I see, and you want all the intermediate steps?
14:07:14 <KorriX> yes
14:07:26 <mm_freak> is there a way to give the type of a certain value a name without constraining it?  something like:  \(x :: exists t. t) -> …
14:07:38 <mm_freak> sort of like a scoped type alias
14:07:47 <koeien> KorriX: the "haskell way" to do this is to make a function  hanoi initialState = [state0, state1, state2, state3, ...]
14:07:57 <koeien> this function is pure and completely devoid of IO.
14:08:00 <jdlasd> or to use scanl
14:08:22 <monochrom> mm_freak: no, there isn't. darn.
14:08:27 <koeien> then, you write a function that prints a hanoi tower, something like ([Int], [Int], [Int]) -> String
14:08:28 <KorriX> koeien - it is good idea
14:08:32 <KorriX> thans
14:08:37 <koeien> this is also pure and completely devoid of IO.
14:08:53 <mm_freak> hmm…  too bad
14:09:09 <koeien> at the end, just write something like putStrLn (map prettyPrint (hanoi initialState))
14:09:26 <koeien> KorriX: this way you separated the IO from the pure functions, they are far easier to test and reason about
14:10:05 <koeien> also composition of pure functions is nicer. this is a better solution in many ways
14:10:32 <KorriX> but it is a little bit crazy that language must me to change some syntaxtical construction into another one, only because of 'purity'
14:10:55 <mm_freak> KorriX: it doesn't
14:11:10 <koeien> no, values are very different from IO actions
14:11:13 <monochrom> crazy is in the eyes of the beholder
14:11:17 <Saizan> it'll force you to change much more, don't worry :)
14:11:31 <koeien> it's not *required* by the way.
14:11:35 <koeien> it's just better design
14:11:40 <mm_freak> KorriX: the syntax is the same, but the types are different, and you will learn to love this distinction =)
14:12:04 <monochrom> "x = x + 1" is another kind of crazy
14:12:46 <hpc> KorriX: the nice thing about "pure" values is that they never change
14:12:59 <hpc> KorriX: and pure functions always return the same value for every input
14:13:19 <mm_freak> s/pure //
14:13:40 <hpc> mm_freak: hence the quotes
14:13:57 <KorriX> general problem is how to fmap on sth with printing some debug
14:14:09 <KorriX> without changing whole application :D
14:14:17 <koeien> for debugging, use Debug.Trace
14:14:33 <hpc> @quote debug.trace
14:14:34 <lambdabot> No quotes match. Do you think like you type?
14:14:37 <hpc> @quote oasis
14:14:37 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
14:15:40 <mm_freak> or use the type system for antibugging
14:18:05 <etpace> Does anyone know of a run-time datastructure for a compiled functional language that supports "multiple application" (ie, f x y z, applies x y z in one closure, rather than building three)? My first attempt of (&code, fv list) only works for single application, and my attempt at mmulti application is about 3x slower than haskel (bottlenecking on a cmp and br), even though it is strict
14:20:18 <mm_freak> etpace: is it a curried language?
14:20:36 <monochrom> I think GHC does that as much as it can.
14:21:22 <shachaf> @google how to make a fast curry
14:21:23 <lambdabot> http://research.microsoft.com/~simonpj/papers/eval-apply/
14:21:23 <lambdabot> Title: How to make a fast curry
14:21:26 <etpace> yes mm_freak
14:21:32 <etpace> aha, great
14:21:35 <mm_freak> because in a curried language a closure can be represented as a partially applied function
14:22:25 <etpace> my current attempt is something like fvalue = (&launcher, prev args, prev arg len) and then comparing in the launcher if weve seen enough args and passing through, or storing if we havnt
14:22:29 <etpace> which is the source of the bottleneck
14:23:02 <etpace> can you elaborate a bit mmfreak? I think all of my closures are partially applied functions, as they ahve been lambda lkfted
14:23:37 <mm_freak> so it's not a bottleneck of closures in particular?
14:23:55 <etpace> no, rather building partially applied functions
14:24:08 <etpace> but it seems this paper by spj is what im looking for :)
14:27:32 <etpace> ahh this paper is indeed right on target, thank you shachaf, if only i found it earlier
14:37:32 <kfish> hi etpace
14:38:52 <Phlogistique> wouldn't it be interesting to tell the compiler "run this at compile time" for any pure binding?
14:39:04 <monochrom> yes
14:39:23 <Phlogistique> and is it possible?
14:39:25 <hpc> that happens for some things
14:39:41 <hpc> it's not possible in general
14:39:42 <monochrom> yes
14:39:59 <koeien> do you want the compiler to terminate?
14:40:05 <monochrom> no
14:40:41 <Phlogistique> for exemple it would be cool to be able to do thing = fromRight $ parse myParser "" "Blah"
14:40:53 <Phlogistique> and get the exception immediatly if there is a parse error
14:41:14 <hpc> i think you can use template haskell to run arbitrary haskell at compile time
14:41:18 <monochrom> use hugs. execution happens at compile time. :)
14:41:19 <Phlogistique> yes
14:41:41 <Phlogistique> monochrom: with runHaskell too
14:41:42 <monochrom> also type errors happen at run time, so everyone is happy!
14:41:54 <monochrom> @quote monochrom hugs
14:41:54 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
14:41:54 <hpc> heh
14:42:15 <Phlogistique> would using $! be sufficient to evaluate this during the program startup?
14:42:40 <monochrom> no, not necessarily at startup, but still earlier than lazy
14:42:52 <Phlogistique> when is that?
14:43:01 <hpc> sometimes it might trick the strictness analyzer into calculating it at compile time
14:43:07 <monochrom> depends on the rest of program.
14:43:11 <rwbarton> fromRight $! x isn't any different from fromRight x in theory
14:43:22 <The_Journey> is there a fast library in Haskell for optimization of nonlinear functions?
14:43:27 <hpc> in theory, practice works just like theory
14:43:29 <rwbarton> but yeah it might trigger an optimization conceivably
14:44:06 <Phlogistique> rwbarton: what I was hoping for is more of an early failure than an optimization
14:44:14 <monochrom> n = sin 0; main = seq n (do ...)  is likely to evaluate sin 0 and store in n near startup, near enough in practice
14:44:38 <rwbarton> you could put "evaluate thing" as the first line of main
14:44:44 <rwbarton> yeah
14:45:20 <monochrom> in denotational semantics, denotation is the same as operation. ... :)
14:46:04 * monochrom doesn't like the "in theory, theory is the same as..." cliche though. in *whose* theory?
14:46:35 * monochrom has an explanation why people love that cliche so much
14:46:41 <mokus> in my theory, "theory" is the same as ['t','h','e','o','r','y']!
14:48:11 <Phlogistique> also rwbarton what's "evaluate"? http://hackage.haskell.org/packages/archive/monoid-transformer/latest/doc/html/Data-Monoid-State.html#v:evaluate
14:48:14 <Phlogistique> ?
14:48:17 <rwbarton> nope
14:48:19 <rwbarton> @hoogle evaluate
14:48:20 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
14:48:20 <lambdabot> Control.Exception evaluate :: a -> IO a
14:48:20 <lambdabot> Control.OldException evaluate :: a -> IO a
14:48:52 <monochrom> people love every oppotunity to stab theories because schools teach theories dry and people had a bad taste
14:49:02 <rwbarton> Phlogistique: Control.Exception.evaluate
14:49:28 <monochrom> s/had a bad taste/got a bad impression/
14:49:56 <mokus> yea, just like they hate type systems because the ones they've been exposed to are utter crap
14:50:31 <blackdog> monochrom: nothing quite as practical as a good theory
14:51:14 <rwbarton> Phlogistique: the other option would be to compute at compile time using Template Haskell as mentioned earlier. that's much more involved, though possibly worthwhile depending on your application
14:51:49 <Phlogistique> rwbarton: yes
14:52:27 <Phlogistique> My use case was simple syntactic sugar for a list of things I happened to be writing a parser for
15:16:45 <alistra> > Just read it
15:16:45 <lambdabot>   Not in scope: `it'
15:16:50 <alistra> > 5
15:16:51 <lambdabot>   5
15:16:52 <alistra> > Just read it
15:16:52 <lambdabot>   Not in scope: `it'
15:16:55 <alistra> meh
15:17:47 <Jafet> @let it = 5
15:17:48 <lambdabot>  Defined.
15:17:51 <Jafet> > Just read it
15:17:52 <lambdabot>   Couldn't match expected type `t1 -> t'
15:17:52 <lambdabot>         against inferred type `Data....
15:18:33 <alistra> @let it = "lol"
15:18:34 <lambdabot>  <local>:10:0:
15:18:34 <lambdabot>      Multiple declarations of `L.it'
15:18:34 <lambdabot>      Declared at: <local>...
15:18:40 <koeien> @undef
15:18:46 <Jafet> @pl \a b -> bird b a
15:18:46 <lambdabot> flip bird
15:18:47 <alistra> @undef if
15:18:49 <alistra> @undef it
15:18:55 <hpc> @undefine
15:19:00 <alistra> @undefine it
15:19:02 <hpc> it can only drop everything
15:19:05 <koeien> @unlet
15:19:07 <lambdabot>  Defined.
15:19:14 <alistra> @let it = "lol"
15:19:15 <lambdabot>  Defined.
15:19:31 <alistra> Just $ read it
15:19:34 <alistra> >Just $ read it
15:19:36 <alistra> > Just $ read it
15:19:37 <lambdabot>   Just *Exception: Prelude.read: no parse
15:19:55 <alistra> meh, i'm bored already, why doesn't it have it like ghci has?
15:19:58 <aristid> @let it = "()"
15:19:58 <lambdabot>  <local>:3:0:
15:19:58 <lambdabot>      Multiple declarations of `L.it'
15:19:58 <lambdabot>      Declared at: <local>:...
15:20:28 <aristid> alistra: because each statement is run in isolation, unlike in ghci
15:20:50 <alistra> well it would solve the @let
15:20:58 <alistra> it would just me > let
15:21:08 <alistra> be*
15:22:26 <aristid> alistra: it's a deliberate decision
15:22:50 <Phlogistique> http://codepad.org/xYgvV6tj
15:23:14 <alistra> saying that's better than grammars with happy ^
15:23:17 <alistra> lol
15:24:06 <Phlogistique> is there a better way to express [A [B]] where [] means optional?
15:24:36 <monochrom> happy: "I can parse, I am happy". parsec: "I can parse, I am more than happy"  XD
15:25:07 <alistra> well the whole point for the parser is not to have much logic in it
15:25:18 <monochrom> I think optional (A >> optional B) is good enough
15:25:37 <Phlogistique> monochrom: I need to get the results of parsers A and B though
15:25:57 <hpc> monochrom: :D
15:26:30 <monochrom> optional (do { a <- A; mb <- optional B; return (a, mb) })
15:27:24 <monochrom> the return type is Maybe (AType, Maybe BType)
15:27:27 <Phlogistique> that's what I did; however, I get a Maybe (a, Maybe b) value, that I have to decompose to a (Maybe a, Maybe b) valye
15:27:31 <Phlogistique> *value
15:27:51 <Phlogistique> that's not very nice
15:28:14 <monochrom> the very structure of [A [B]] corresponds exactly to Maybe (A, Maybe B) and not (Maybe A, Maybe B)
15:28:34 <monochrom> [A] [B] would be what I call (Maybe A, Maybe B)
15:29:59 <monochrom> @djinn Maybe (a, Maybe b) -> (Maybe a, Maybe b)
15:29:59 <lambdabot> f a =
15:29:59 <lambdabot>     case a of
15:29:59 <lambdabot>     Nothing -> (Nothing, Nothing)
15:29:59 <lambdabot>     Just (b, c) -> case c of
15:29:59 <lambdabot>                    Nothing -> (Nothing, Nothing)
15:30:01 <lambdabot>                    Just d -> (Just b, Just d)
15:30:34 <monochrom> it can be done with loss of information
15:30:40 <hpc> eeew
15:31:08 <Axman6> hmm, odd choice there
15:31:16 <rwbarton> can't it also be done without loss of information?
15:31:23 <Axman6> if you have the a, why not return it?
15:31:29 <monochrom> I guess it can also be done without loss of information. (Maybe a, Maybe b) is a superset
15:32:18 <aristid> is there a rule for djinn to prefer a version with no loss of information?
15:32:22 <monochrom> anyway just modify my "return (a, mb)" to whatever you like to return
15:32:34 <aristid> if not, why would you expect it to choose such
15:32:54 <monochrom> I think djinn's code just makes a covenient choice (convenient for djinn's author)
15:33:39 <rwbarton> djinn has some heuristics that make it prefer "interesting" values over say f a = (Nothing, Nothing)
15:33:54 <aristid> rwbarton: interesting.
15:35:25 <rwbarton> the only thing it's guaranteed to do is give you some total function of the requested type, if one exists, and otherwise fail
15:36:03 <Phlogistique> monochrom: well, again, that's precisely what I did
15:36:22 <Phlogistique> (see http://codepad.org/xYgvV6tj
15:36:40 <Phlogistique> thanks for your insights
15:44:36 <jakky>  /j openbox
15:44:39 <jakky> OOF
15:45:54 <Phlogistique> http://codepad.org/FWDsS0Eo
15:46:16 <Phlogistique> That's the cleanest I managed
15:52:51 <tehgeekmeister> why do the string data structures in haskell all have o(n) append?
15:53:06 <hpc> tehgeekmeister: [Char] does
15:53:08 <Phlogistique> tehgeekmeister: because they are linked lists
15:53:10 <hpc> DString doesn't
15:53:12 <hpc> nor does Text
15:53:21 <tehgeekmeister> hpc: no, string does, i checked.
15:53:25 * tehgeekmeister double checks
15:53:32 <shachaf> hpc: Why doesn't Text?
15:53:36 <Axman6> of course string does
15:53:43 <hpc> tehgeekmeister: String = [Char]
15:53:46 <Axman6> it's a linked list of Char
15:53:50 <hpc> DString /= String
15:53:57 <tehgeekmeister> hpc: text has o(n) append according to the docs.)
15:54:20 <shachaf> Anyway, you should understand what DString is before using "just because it's O(1)".
15:54:35 <HugoDaniel> O(1) can be slower than O(n)
15:54:41 <HugoDaniel> keed that in mind
15:54:45 <HugoDaniel> s/keed/keep
15:54:50 <shachaf> Particularly when n is 0.5.
15:54:51 <ddarius> C strings have O(n) append.
15:54:59 <HugoDaniel> shachaf: :)
15:55:01 <ddarius> As do Pascal style strings.
15:55:02 * Axman6 was just about to say that...
15:55:13 <Axman6> Ropes probably don't
15:55:14 <c_wraith> tehgeekmeister: if you want fast appends, you really want a structure more like a Rope than a String
15:55:33 <ddarius> Axman6: No, they don't.
15:56:17 <Axman6> O(log(n)) right? It's been a while since I looked at exactly how you implement a Rope
15:56:31 <tehgeekmeister> well, the problem i'm tracing down (i'll get more solid data on this tonight, once i get home), is that splitWhen in Data.Enumerator.Text is *really* slow, and it seems to be because of repeated appends to build chunks into contiguous blocks of text.  that and calling toStrict on lazy texts for every chunk.  trying to figure out how that could be improved upon.
15:56:34 <hpc> Ropes are funky trees, iirc
15:56:59 <c_wraith> Axman6: where n is the number of chunks, not the number of characters.
15:57:05 <Axman6> yeah
15:57:40 <shachaf> You can use a lazy Text with O(n) append where n is the number of chunks, I imagine.
15:58:16 <tehgeekmeister> yeah, i'm wondering why the current implementation makes it strict on every single chunk
15:58:44 <c_wraith> sounds like a bug
15:58:47 <tehgeekmeister> probably because you know you'll evaluate every chunk anyway, by the nature of splitWhen
15:58:50 <tehgeekmeister> you have to
15:59:33 <Axman6> Lazy Text is basically just a list of strict Text right?
15:59:38 <c_wraith> lazy has more advantages than just leaving chunks unevaluated, in a case like this.
15:59:49 <c_wraith> it allows you to keep chunks if they're unchanged
15:59:52 <c_wraith> Axman6: yes
16:00:00 <tehgeekmeister> ah, now that's a nice benefit
16:01:03 <c_wraith> Still, it's fully possible for Data.Enumerator.Text to have some silly code in it.
16:01:15 <Axman6> it sounds quite likely
16:01:29 <no1special> Hi all -- why does (*4.2) have type Fractional a => a -> a and not Num?
16:01:45 <koeien> because not all nums are fractional.
16:01:45 <shachaf> no1special: Because 4.2 is Fractional.
16:01:46 <koeien> :t 4.2
16:01:47 <lambdabot> forall t. (Fractional t) => t
16:01:56 <Axman6> no1special: because 4.2 can only become a fractional number, not just any Num
16:02:02 <koeien> e.g. Integer is a Num, but not a Fractional
16:02:42 <no1special> so then why doesn't *4 get Integral?
16:02:47 <Axman6> tibbe: for fun, you might like to have a look at conduit and see if it's got better performance
16:02:59 <Axman6> because 4 has type Num a => a
16:03:01 <Axman6> :t 4
16:03:02 <lambdabot> forall t. (Num t) => t
16:03:08 <koeien> no1special: because not all Integrals are Nums, e.g. Float
16:03:09 <c_wraith> Axman6: I think that was a mis-completion there
16:03:09 <Axman6> > 4 :: Double
16:03:10 <lambdabot>   4.0
16:03:40 <alpounet_> @type (*4)
16:03:41 <lambdabot> forall a. (Num a) => a -> a
16:03:47 <Axman6> c_wraith: about what? I'm just curious to see if the implementations do less silly things (assuming they're implemented at all)
16:03:50 <Saizan> koeien: itym not all Nums are Integrals?
16:04:06 <c_wraith> Axman6: I think you said tibbe when you meant tehgeekmeister
16:04:09 <Axman6> uh, yes, it was. sorry tibbe, meant tehgeekmeister
16:04:41 <koeien> Saizan: yes, thanks
16:04:50 <Axman6> koeien: All Integrals are Nums, but not the other way
16:05:07 <shachaf> Axman6: "All Integrals"?
16:05:18 <shachaf> I think that statement confuses types, values, and type classes. Or something.
16:05:20 <Axman6> as in all members of the Integral class
16:05:21 * hackagebot hatt 1.4.0.2 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.4.0.2 (BenedictEastaugh)
16:05:28 <Axman6> yeah, i was being lazy
16:05:31 <Axman6> @src Integral
16:05:32 <lambdabot> class  (Real a, Enum a) => Integral a  where
16:05:32 <lambdabot>     quot, rem, div, mod :: a -> a -> a
16:05:32 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
16:05:32 <lambdabot>     toInteger           :: a -> Integer
16:05:59 <tehgeekmeister> Axman6: conduit?
16:06:08 <Axman6> @hackage conduit
16:06:08 <lambdabot> http://hackage.haskell.org/package/conduit
16:06:15 <Axman6> @google yesod conduit
16:06:16 <lambdabot> http://www.yesodweb.com/blog/2011/12/conduits
16:06:17 <lambdabot> Title: Conduits
16:07:03 * ddarius isn't sure Stokes theorem is a Num.
16:07:33 <Axman6> the second link will be useful (it's part of a series, you might want to read the first article in the series if you're interested in ResourceT, which looks after resources for you by making sure they get freed, even if there are exceptions)
16:08:45 <no1special> hm. so if 4 and 4.2 are not typed concretely as Integer and Double, then why are foo and bar in let foo = 4; bar = 4.2
16:09:04 <koeien> the monomorphism restriction
16:09:15 <koeien> + defaulting rules
16:09:18 <c_wraith> no1special: if there's no further information about the type of a polymorphic constant, they get defaulted.
16:09:30 <c_wraith> thanks to the monomorphism restriction, of course.
16:09:40 <no1special> interesting
16:09:59 <c_wraith> however, there's often further information, in the form of context that allows a more specific type to be inferred
16:10:11 <c_wraith> :t take
16:10:11 <lambdabot> forall a. Int -> [a] -> [a]
16:10:17 <c_wraith> > take 3 "hello"
16:10:17 <lambdabot>   "hel"
16:10:36 <no1special> i see
16:10:36 <c_wraith> It infers that the constant 3 must be an Int in that case, due to how it's used
16:10:52 <no1special> so can 3 take any other type elsewhere?
16:11:00 <c_wraith> well, any type that's an instance of Num
16:11:00 <koeien> any type that's an instance of Num
16:11:11 <koeien> this can include your own types
16:11:35 <koeien> in fact, 3 really means fromInteger 3
16:11:50 <no1special> ah
16:11:55 <koeien> :t fromInteger
16:11:55 <lambdabot> forall a. (Num a) => Integer -> a
16:12:02 <ddarius> > fix fromInteger
16:12:06 <lambdabot>   mueval-core: Time limit exceeded
16:12:16 <hpc> > fix error -- i have solved all bugs ever
16:12:17 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:13:33 <no1special> so in (*4.2) why can it remain polymorphic, and not Double?
16:14:09 <ddarius> 4.2 means fromRational 4.2
16:14:35 <Axman6> :t (*(fromRational 4.2))
16:14:35 <c_wraith> no1special: it depends on the context, and whether the monomorphism restriction applies
16:14:36 <lambdabot> forall a. (Fractional a) => a -> a
16:15:17 <shachaf> Also, fromInteger = const
16:15:22 <shachaf> > fromInteger 3 "foo"
16:15:23 <lambdabot>   3
16:15:24 <c_wraith> Prelude> let x = (* 4.2)
16:15:24 <c_wraith> Prelude> :t x
16:15:24 <c_wraith> x :: Double -> Double
16:15:30 <mdmkolbe> Is there something in the GHC API that lets me parse types (i.e. of type "String -> Type").  I'd use [t| ... |] but I want to allow free type variables in the name (e.g. "a -> a" should be valid, not just "forall a. a -> a") and with [t| ... |] that throws an (AFAICT) uncatchable error
16:16:02 <c_wraith> Using it like that forced the monomorphism restriction to apply.
16:16:18 <no1special> i see. makes sense.
16:16:44 <tehgeekmeister> Axman6: thanks, saved those
16:16:46 <tehgeekmeister> gotta head out
16:17:29 <no1special> then what is the advantage to having constants be polymorphic (besides, say, letting them take my own types)?
16:18:18 <koeien> besides that? saves some type conversion
16:18:34 <koeien> e.g. take (fromInteger 3) vs take 3
16:18:47 <koeien> since take expects an Int, not an Integer
16:18:51 <c_wraith> It's pretty much just for convenience of using literals
16:19:06 <monochrom> polymorphic 0 and polymorphic + are due to the same reason
16:20:21 * hackagebot xturtle 0.0.2 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.2 (YoshikuniJujo)
16:21:10 <no1special> I see. Thanks for the help, everyone.
16:21:46 <Eduard_Munteanu> mdmkolbe: yeah, the GHC API or haskell-src stuff
16:22:15 <mdmkolbe> Eduard_Munteanu: yeah, but where?  I'm having trouble navigating the APIs
16:22:29 * Eduard_Munteanu looks
16:23:28 <Eduard_Munteanu> mdmkolbe: this looks like a place to start... http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/Type.html
16:23:51 <Eduard_Munteanu> See splitFunTy and all that stuff
16:31:30 <Sgeo> Is Binding.* the module namespace for low-level bindings?
16:32:11 <Sgeo> Err, Bindings.*
16:32:44 <Axman6> there's no solid rules. some people use System.Foo.*
16:40:06 <cl1> do y'all know what IoC containers are? I mean like full blown usage with interceptors and AOP?
16:40:21 <cl1> do you even need such a construct in functional programming?
16:42:23 <Axman6> IoC?
16:43:33 <cl1> IoC is Inversion of Control and AOP is aspect oriented programming
16:45:10 <cl1> an IoC container like castle windsor allows you to get good separation of concerns, but it also requires that you know the api in order to do things that otherwise could be done with plain old object oriented code
16:45:32 <Axman6> sounds like it could be related to iteratees
16:45:45 <Axman6> but, i can;t tell from your description
16:45:58 <hpc> you can do inversion of control in functional style with CPS
16:46:16 <cl1> cps?
16:46:23 <hpc> continuation passing style
16:46:33 <monochrom> thus the jargon war begins
16:46:33 <Phlogistique> any tutorial on writing lenient/heuristic parsers?
16:46:38 <hpc> monochrom: :P
16:47:10 <cl1> my mom says my resume looks like the alphabet all mixed up
16:47:37 <mauke> > head . cake
16:47:37 <hpc> cl1: as well it should
16:47:38 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
16:47:48 <Phlogistique> last time I went to a job interview, the interviewer said "Haskell? What is that?"
16:48:01 <Phlogistique> I answered it's a programming language.
16:48:33 <alistra> and he laughed at you?
16:48:55 <alistra> lol nobody uses that, code in java
16:49:00 <Phlogistique> he asked me about my hobbies
16:49:13 <Phlogistique> afterwards.
16:51:08 <alistra> it's somewhat weird to program as a hobby
16:51:14 <alistra> if you go to a programmer job
16:51:17 <alistra> i don't know why
16:51:36 <hpc> when i interviewed for my current job, i didn't know how to pronounce "haskell"
16:51:49 <hpc> he thought i said "pascal" and was this close to dismissing me out of hand
16:52:07 <alistra> where are you from, lol
16:52:09 <cl1> actually some people expect you to do it as a hobby. It shows that you enjoy doing it
16:52:23 <Phlogistique> alistra: when someone from the sales department says that, I answer that his job is giving phone calls to clients; but that doesn't make it strange for him to call up his friends during the week end
16:52:26 <hpc> alistra: i think you can whois me and see clearly enough :P
16:52:30 <aristid> hpc: how did you pronounce it?
16:52:40 <hpc> has-CAL
16:53:04 <aristid> hpc: but it has an e there, not an a :)
16:53:05 <alistra> ~juzz@ip98-169-33-6.dc.dc.cox.net
16:53:17 <Axman6> not has-KEL? that's how I've usually heard it pronounced by people who are new to it
16:53:18 <alistra> how is it clear
16:53:22 <Phlogistique> Haskell is Asskell in French; no room for confusion.
16:53:29 <hpc> hehe
16:53:39 <aristid> Axman6: huh? how do people pronounce it who are not new to it
16:53:50 <Phlogistique> aristid: "Curry"
16:53:50 <aristid> Axman6: mentally, i always say has-KELL
16:53:53 <alistra> Sofia? or is it just the freenode node
16:53:55 <monochrom> cl1: I have a story to tell, but it requires you to know the notation \c f -> f 1 (f 0 c)
16:54:01 <Axman6> i say it more like has-kul
16:54:27 <cl1> monochrom .. okay?
16:54:33 <aristid> Axman6: and what's the difference?
16:54:55 <Axman6> ul sound not el
16:55:25 <aristid> Axman6: you probably don't use a real u (where real refers to the german U sound) :)
16:55:35 <cl1> monochrom, i understand the syntax
16:55:40 <alistra> well i should learn the international phonetic alphabet some time in the future
16:55:43 <Axman6> 'uhl' is that clearer?
16:55:45 <aristid> Axman6: also, english pronunciation of words is fucked up :P
16:55:51 <Axman6> yeah man
16:55:55 <aristid> Axman6: no, not clearer
16:56:08 <cl1> aristid, like the queen's english or american?
16:56:31 <alistra> canada has a queen?
16:56:32 <Axman6> has-KELL, the e as in bet, has-KUL, the u as in button
16:56:34 <aristid> cl1: all of them
16:56:39 * cl1 speaks texan
16:56:46 <Eduard_Munteanu> Somewhat like "rascal" would be my guess.
16:56:49 <Axman6> canada does have a queen
16:57:05 <Axman6> Eduard_Munteanu: Harskell? :P
16:57:09 <aristid> Axman6: why would you pronounce haskell like rascal? that makes no sense!
16:57:25 <Eduard_Munteanu> Not that part, har har :)
16:57:29 <Eduard_Munteanu> @yarr
16:57:29 <lambdabot> Gangway!
16:57:30 <Axman6> (given rascal has at least two common pronounciations)
16:57:46 <Eduard_Munteanu> Oh.
16:57:57 <homie> weeeeeh ?
16:57:59 <alistra> i think the pronounciation of haskell is like monads
16:58:05 <aristid> we should simply pronounce Haskell the german way. that's not ambiguous.
16:58:12 <alistra> or is it the other way around
16:58:13 <homie> canada ?
16:58:23 <aristid> alistra: it's a space burrito
16:58:33 <monochrom> I have a list to give you. the list is actually [1,0]. but I don't want to give you in that form. I give you instead a function e0 (I put "\c f -> f 1 (f 0 c)" in e0, but you don't know that yet). what good is that function? one example: upon receiving my e0, you compute e0 5 (+). that means you plug addition (+) into f and plug 5 into c, and you get 1+(0+5). that is how you could use e0: instead of me listing items to you, y
16:58:33 <monochrom> ou pass in operators to use the undisclosed items
16:58:33 <alistra> yup
16:58:38 <Axman6> even though i've heard monad should be pronounced moh-nad, i still say mon-ad
16:59:42 <alistra> it's a common misconception
16:59:44 <Axman6> aristid: how is the german way pronounced?
16:59:45 <alistra> it's manet
16:59:48 <alistra> not monad
16:59:55 * Eduard_Munteanu fails to see how you could pronounce it as mon-ad
17:00:07 <alistra> http://en.wikipedia.org/wiki/%C3%89douard_Manet look it up
17:00:08 <monochrom> or I could give you another function e0 = "\c f -> f 3 (f 1 c)". if you compute e0 5 (+), you get 3+(1+5). so generally you can compute the sum of my undisclosed list plus 5.
17:00:09 <Axman6> Eduard_Munteanu: because that's how it's spelt...
17:00:38 <aristid> Axman6: the first part is Has like in Husky
17:00:40 <cl1> monochrom, very interesting
17:00:42 <worldsayshi> Hello anyone. I'm working with HOpenGL at the moment and I'm wondering if there is a way to run it without having the main thread consumed. Some way to allow me to run commands for re-drawing the window from interactive prompt without having to kill the application first.
17:00:58 <cl1> monochrom, inversion of control FP style
17:01:01 <alistra> monochrom: isn't just making a newtype Lolhiddenlist a = L [a] not deriving Show
17:01:02 <aristid> Axman6: the second part is kell like in .. well, kell
17:01:17 <Axman6> aristid: kell whymes with well?
17:01:19 <monochrom> "\c f -> f 1 (f 0 c)" is an inversion-of-control container. it has the essence of the list [1,0], but to extract that you have to pass it functions
17:01:30 <Axman6> rhymes even
17:01:31 <aristid> Axman6: yes, mostly
17:01:47 * Eduard_Munteanu now thinks of "wall"
17:02:06 * aristid thinks of Life Of Brian
17:02:27 <Axman6> aristid: well here at elast, i've only ever heard it pronounced as has-KUL, as in a school, but shorter
17:02:36 <worldsayshi> My question may be to specific but general methods may apply
17:02:49 <ab500> I'm just learning haskell, and I'm falling in love with it.
17:03:07 <Axman6> ab500: glad to hear
17:03:09 <alistra> gay
17:03:18 <alistra> :P
17:03:41 <Eduard_Munteanu> worldsayshi: you could tell the main thread to do a redraw.
17:03:44 <ab500> bwaha, no this is the first time programming has made me furrow my eyebrows and hurt my head in a while, I take it that's a good thing.
17:03:46 <alistra> lol how is that for supporting community
17:03:53 <aristid> Axman6: english really should get itself some phonetic spelling.
17:04:14 <cmccann> alistra, programming languages don't typically have a gender, so that's probably inaccurate technically
17:04:24 <Eduard_Munteanu> aristid: I wonder if IPA would be enough
17:04:31 <Axman6> aristid: there's a metalanguage for it... i just don't know it (and i'm pretty sure that putty would fail to show the symbols)
17:04:32 <aristid> Eduard_Munteanu: probably
17:04:41 <Eduard_Munteanu> Is there a common IPA for all languages even?
17:04:43 <aristid> Eduard_Munteanu: the only problem is that it looks weird
17:04:54 <alistra> cmccann: so you can't say that haskell is the opposite gender of ab500's gender, can you?
17:05:12 <Eduard_Munteanu> (or do they have overlapping phonemes?)
17:05:29 <aristid> Eduard_Munteanu: IPA is probably not fully precise.
17:05:38 <Eduard_Munteanu> cmccann: Haskell Curry has a gender ;)
17:05:39 <aristid> Eduard_Munteanu: but it oughta be good enough for english spelling.
17:05:43 <Eduard_Munteanu> *had
17:05:57 <worldsayshi> Eduard_Munteanu: But as run the mainLoop command I will lose control of the command line. A callback wont do.. I wish to remain in the command line while also running the main loop... eh
17:07:52 <monochrom> cl1: "iteratee" and "enumerator" are that idea on steroid. they may actually be more complicated than just "on steroid" because they also do fine-grained control of I/O. what their containers contain: stuff to be read from a file. what the user passes in: a procedure that deals with "a batch of data is read successfully, here is the data", a procedure that deals with "eof is reached", and a procedure that deals with "error ha
17:07:52 <monochrom> ppens"
17:08:05 <Eduard_Munteanu> worldsayshi: you could run mainLoop on a different thread I guess
17:08:21 <worldsayshi> Ideally rather than having a main loop I would order a single draw operation
17:08:23 <worldsayshi> hmm
17:08:25 <Axman6> so I'm having a look at a new language called Clay, seems quite interesting. among some other features (some nice, some too C++ish), it seems to allow inline LLVM assembly
17:08:43 <worldsayshi> But I'm not sure that is possible with opengl
17:08:48 <worldsayshi> *hopengl
17:09:04 <cl1> monochrom, that makes sense
17:09:12 <Eduard_Munteanu> worldsayshi: wait, I see what you mean. Though I'm not a (H)OpenGL expert... should be possible to interrupt the main loop with a timer.
17:09:15 <worldsayshi> Then I wouldn't have to deal with multiple threads
17:09:24 <cl1> so iteratee wraps the data, and you just provide the methods
17:09:48 <cl1> monochrom, very interesting
17:09:53 <Axman6> worldsayshi: threads are lovely in haskell. and i believe OpenGL stuff has to be run from the main thread, so if you want a responsive app, you'll want to do the processing in other threads
17:10:06 <aristid> preflex: seen ezyang
17:10:06 <preflex>  ezyang was last seen on #haskell 9 hours, 54 minutes and 37 seconds ago, saying: etpace: It simplifies reasoning about usage of the API (oh, I know that bit is equivalent to this simpler expression), and makes the API more constrained.
17:10:20 <cl1> monochrom, kind of like an abstract class that has the implementation for all except a few parts, except in FP you don't have to inherit anything
17:10:56 * Eduard_Munteanu should look at HOpenGL himself
17:11:04 <worldsayshi> But if I completely interupt the main loop the window should get destroyed...
17:11:32 <worldsayshi> Hmm, this is probably to complex to get a simple answer to..
17:12:12 <ben> > fromIntegral 349234 :: Word8
17:12:31 <Eduard_Munteanu> worldsayshi: why?
17:12:35 <ben> lambdabot :(
17:12:37 <worldsayshi> And Eduard_Munteanu yes I will probably have to read up on threads a bit. I was hoping I didn't need threads
17:12:55 <Eduard_Munteanu> I don't think you specifically need threads.
17:12:55 <ben> is fromintegral defined to behave like modulo here
17:13:00 <Axman6> worldsayshi: you send the main loop events in something like an MVar, and if it's empty, you just keep drawing what you have, otherwise you you get the new event, and update the screen accordingly
17:13:06 <Eduard_Munteanu> Hooking stuff into the rendering loop might do as well.
17:13:14 <Axman6> ben: i believe it does, yes
17:13:19 <Axman6> > 1+1
17:13:19 <Eduard_Munteanu> (if exposed by HOpenGL)
17:13:32 <Axman6> bah, when did lambdabot die
17:13:37 <rwbarton> 8 minutes ago
17:14:43 <Eduard_Munteanu> Wait... what mainLoop? All I can find is http://hackage.haskell.org/package/OpenGL-2.4.0.1, and if that's just a binding it should be your task to write a render loop.
17:14:48 <worldsayshi> Hmm, ah, I see what you mean. I only need to share a state variable holding the shapes in question with the render loop.
17:15:32 <worldsayshi> Then I just need to redraw regularly using that state variable
17:16:07 <worldsayshi> I don't know that much about threads in Haskell yet, that's what confused me...
17:17:01 <Eduard_Munteanu> @google haskell threads
17:17:04 <Eduard_Munteanu> Bah.
17:17:10 <worldsayshi> Yup. Thanks!
17:17:21 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
17:17:25 <Axman6> worldsayshi: threading in haskell is really quite easy, and fun
17:17:55 <Axman6> worldsayshi: you might also want to look at gloss, unless this is an exercise in playing with OpenGL
17:17:59 <Eduard_Munteanu> And in case you're wondering, yeah, you want explicit threads like in other languages, not 'par' stuff.
17:18:02 <worldsayshi> I happened to miss the concurrency lecture :)
17:18:34 <Axman6> 'the' concurrency lecture? i feel sorry for you if you've only been given one :(
17:19:04 <worldsayshi> Yea, I thought about par, and that didn't fit at all, therefore confusion. :)
17:19:50 <worldsayshi> Yeah, I'm going for advanced functional next semester if as planned.. :)
17:22:51 <Axman6> worldsayshi: where?
17:23:49 <worldsayshi> Axman6: Chalmers, Göteborg
17:24:08 <Axman6> ah ok. they do some interesting haskell stuff there if i remember rightly
17:25:24 <Sgeo> Would an IsString (IO CString) instance make sense, or is that a bad idea.
17:25:39 <c_wraith> Why IO?
17:25:50 <Sgeo> @hoogle newCString
17:26:08 <Sgeo> Because newCString :: String -> IO CString
17:26:13 <Sgeo> It needs to allocate memory
17:26:30 <c_wraith> allocation is no big deal.  Allocation outside the ghc heap, on the other hand
17:26:49 <parcs`> Sgeo: it doesn't really help much
17:28:02 <rwbarton> yeah, especially since you have to free the CString yourself later
17:28:35 <worldsayshi> Axman6: Gloss, ah, nice. Seem to fit my needs at the moment very well. Maybe to well. Not forcing me to learn concurrency.
17:28:42 <parcs`> i would use withCString instead
17:30:16 <monochrom> I have a better idea. instance IsString ((CString -> IO a) -> IO a) where fromString = withCString
17:30:37 <monochrom> now you can write: do { ... ; "hello" (\cstring -> ...); ... }
17:30:44 <Axman6> "Hello" $ (\str -> ...)? gross :P
17:30:59 <monochrom> I present this idea for sarcasm.
17:31:03 <ion> How beautifully devious.
17:31:50 <rwbarton> instance IsString (ContT a IO CString)
17:33:08 <monochrom> anyway, if you had "instance IsString (IO CString)", how would you use it? I bet it's going to be do { x <- "hello"; ... ; free x }. saves a bit of typing, sure. doesn't clarify anything.
17:38:29 <ben> Which magic number is 9223372036854775807?
17:38:45 <rwbarton> 2^63-1
17:38:47 <parcs`> what about IsString CString where fromString = unsafePerformIO . fmap unsafeForeignPtrToPtr . (newCString >=> newForeignPtr finalizerFree)
17:38:49 <ben> oh it's maxBound :: Int
17:38:58 <monochrom> > Numeric.showHex 9223372036854775807 ""
17:39:07 <monochrom> is dead
17:39:16 <ben> I'm looking at ghc-core output for the first time and there's an explicit check for that in my loop
17:39:28 <rwbarton> are you using `mod` or `div`?
17:41:07 <rwbarton> or actually, it could come from something like [1..]
17:42:07 <ben> I made an explicit loop function because I wanted to see how it compares to forM_ [0...size]
17:42:15 <ben> apparently the check is from succ
17:42:36 <Axman6> pizzaplane: doesn't that have the nasty side effect of freeing the pointer earlier than it should be?
17:42:44 <Axman6> uh, parcs`
17:43:26 <HalfWayMan> Query: Looking for a Haskell programmer that was in the city of Leeds in the UK on Friday 30th Decemeber?
17:44:24 <ben> I just found out about ghc-core and now I feel dumb for using -fext-core and reading .hcr files
17:48:31 <ben> i'm not very good at cabal
17:49:56 <HalfWayMan> ben: You're not alone.
17:50:00 <ben> I wanted profiling a while back so I enabled library-profiling in .cabal/config
17:50:16 <ben> now I can't cabal-install gtk2hs anymore because of some cabal shenanigans
17:50:23 <ben> maybe I should go to the gentoo guys
17:51:41 <monochrom> so some of your packages have profiling and some do not. that's why.
17:51:55 <timemage> ben, have you enabled the haskell overlay?  dunno if they still do that these days.
17:52:48 <ben> monochrom: I would expect to be able to cabal install --reinstall packages without cabal throwing its hands up and leaving me hanging
17:57:36 <ben> I guess my mistake is mixing distro-package-manager-installed haskell packages with cabal-install'd packages, but I don't understand why I can't reinstall all the packages as my user
17:59:39 <Eduard_Munteanu> ben: you could use the 'profile' USE flag on Haskell ebuilds
17:59:57 <Eduard_Munteanu> Also, don't cabal install stuff globally.
18:00:12 <ben> Yeah I mean user-locally
18:00:32 <Eduard_Munteanu> Well, if that's the problem you can erase ~/.cabal and ~/.ghc and start from scratch.
18:00:35 <ben> profile use-flag is on but I guess the packages that ship with ghc don't respect it
18:00:49 <ben> Yeah but I already started from scratch and got in the same mess
18:01:27 <monochrom> eh? packages that ship with ghc already has profiling built
18:01:45 <monochrom> of course unless gentoo breaks that
18:02:02 <c_wraith> well, debian does
18:02:10 <c_wraith> so gentoo might also!
18:03:30 <mjrosenb> c_wraith: there is a USE flag for profiling.
18:03:46 <Eduard_Munteanu> Hm.
18:04:07 <Eduard_Munteanu> Maybe it doesn't use profiling if you don't use +binary for ghc?
18:06:09 <Eduard_Munteanu> Also make sure you emerged --newuse if you just enabled profile globally.
18:06:30 <ben> No, I've had it on for a while.
18:07:11 <ben> [4~Right now I can't build pango because it can't satisfy -package Cabal-1.10.2.0 even though that just installed
18:07:35 <ben> I'm not sure why it keeps reinstalling cabal's dependencies process and directory every time I as much as look at it
18:07:35 <augur> oh man did i miss the conversation on how to pronounce "haskell"?
18:07:36 <augur> D:
18:07:59 <Eduard_Munteanu> Yes, our linguist should settle this :P
18:08:05 <c_wraith> augur: and me completely getting the definition of stressed syllables backwards.
18:08:33 <augur> well i can tell you the CORRECT way to pronounce it is /ˈhæskəl/
18:08:41 <augur> stress on the first syllable
18:09:03 <Eduard_Munteanu> Next somebody asks you how to read that :)
18:09:06 <JuanDaugherty> ass-kill and hassle are my faves
18:09:07 <djahandarie> I've always put stress on the kell :(
18:09:19 <djahandarie> However I'll fix my evil ways
18:09:20 <augur> first syllable has the same as hassle (thank you JuanDaugherty)
18:09:33 <augur> second syllable is the same as the cle in cycle
18:10:20 <augur> JuanDaugherty, david haskellhoff
18:10:24 * Eduard_Munteanu now wonders if there's any difference between "rascal" and "cycle"
18:10:34 <augur> aha!
18:10:38 <augur> Eduard_Munteanu has the right word
18:10:42 <augur> it is the same as rascal
18:10:47 <augur> but with an h instead of an r
18:10:50 <hpaste> ben pasted “cabal errors, please advise” at http://hpaste.org/56057
18:12:33 <Sgeo> I have a C function that takes a struct, but Haskell doesn't seem to like the foreign declaration
18:12:40 <parcs`> i put stress on both syllables
18:12:42 <mauke> Sgeo: correct
18:13:00 <Sgeo> mauke, so what do I do?
18:13:06 <mauke> Sgeo: write a wrapper that takes a pointer
18:13:28 <Sgeo> ??
18:13:30 <Sgeo> On the C side?
18:13:32 <mauke> yes
18:13:43 * Sgeo would rather avoid writing C-side code if possible
18:13:55 <mauke> kids these days
18:14:05 <JuanDaugherty> rly
18:14:24 <ben> i never had this sort problem with cpan, you guys!!
18:14:26 <mauke> in ocaml you'd have to write all of the ffi binding stuff in C
18:14:31 <ben> sorta*
18:14:38 <mauke> and in perl you wouldn't even have a ffi
18:14:52 <ben> no i meant cabal stuff
18:16:01 <monochrom> the output of "ghc -v" may scare you
18:16:39 <ben> As long as cabal refsuses to sort out its mess I won't even get to invoke ghc
18:16:43 <mike-burns> We had FFI in Perl.
18:16:51 <monochrom> interpreters like perl and ruby have no early problems with version mismatch, yes.
18:17:02 <mike-burns> And ben is right, this is silly, but I don't know how to fix the larger problem.
18:17:15 <Sgeo> mauke, do I have any other alternatives?
18:18:52 <monochrom> fragile dependency is a problem specific to compilers and especially acute with cross-module optimizers. see my http://www.vex.net/~trebla/haskell/sicp.xhtml#hash
18:19:10 <mike-burns> cabal-dev is a solution, yeah?
18:19:19 <monochrom> it's easy for you to say "perl doesn't have this problem" because perl doesn't even need an ABI
18:19:41 <monochrom> use hugs. then you will not have cabal failures either.
18:19:43 <ben> I wonder if hugs has this problem
18:19:46 <ben> efb
18:20:35 <MarcWeber> ben: If you still have issues give nixpkgs a try. I can offer you a SSH account so that you can try whether it fixes your issue before installing anything ..
18:22:00 <monochrom> in exchange for interpreters' lack of install-time errors due to version-abi mismatch, you gain runtime errors due to version mismatch not detected at install time. should I congratulate you?
18:22:30 <monochrom> and I am pretty sure you did run into cpan package runtime errors of that kind
18:22:54 <monochrom> like I said, if you like to postpone type errors until run time, use hugs
18:23:04 <mike-burns> The "this is solved in CPAN, c'mon!" is the same level of snark that we gave out with "pfft, your hashtables cause DoS problems?".
18:23:13 <ben> no but i think i installed a great total of ten packages with cpan, or so
18:23:25 <ben> i just wanted to bring up perl because perl was on topic but nobody was talking about my problem anymore
18:23:32 <monochrom> I don't even cite hashtable DoS problems, mike-burns.
18:23:45 <mike-burns> Sure, yeah.
18:24:27 <mike-burns> I guess my point is: Ruby, Perl, and Scala don't have people complaining about this, so let's see if we can find a solution too.
18:24:50 <monochrom> kill most GHC optimizations. that's a start.
18:25:02 <ben> if cabal-dev is a solution i suppose that's good enough for me
18:25:46 <monochrom> oh wait, the emphasis is on "don't have people complaining". I guess there is an easier solution centred around that.
18:25:56 <monochrom> kill people who complain? :)
18:25:57 <mike-burns> Yup; kickban complainers.
18:26:01 <mike-burns> Heh.
18:26:47 <monochrom> anyway my point really is this is not solved in cpan. it's just hid under another rug.
18:27:07 <mike-burns> Fair enough.
18:27:12 <mike-burns> Is cabal-dev a solution, though?
18:27:46 <monochrom> I haven't tried. most people say yes. a few people say not entirely
18:28:12 <mike-burns> That's what I hear. I need to try sometime soon; my cabal is all screwy for each of my projects.
18:28:16 <ben> nuking ~/.ghc/ and starting from scratch got me out of my immediate mess but I already did that last week and somehow got back into the mess and don't even remember how
18:28:17 <mike-burns> Maybe tomorrow I'll have time.
18:31:10 <monochrom> cabal-dev only does: different package environment for different projects, so you don't have a dilemma "my xml project wants parsec-2, my cobol project wants parsec-3". within one package environment for one project, if you are an upgrade whore and add inconsistencies, cabal-dev can't save you from that
18:31:15 <Sgeo> In hsc, does {- and -} comment out #declarations?
18:31:49 <mike-burns> I need the thing that cabal-dev does, and pronto.
18:32:11 <Sgeo> Can I switch to cabal-dev after having made a mess of installed packages?
18:32:32 <Axman6> cabal-dev is for use with single projects, so yes
18:36:22 <ben> thanks for the link monochrom
18:38:14 <ben> Would a reasonable stopgap solution be to have the ghc-pkg register sanity check disallow shadowing global packages with user packages?
18:39:09 <monochrom> that helps part of the problem
18:39:31 <ben> Assuming that my distro packages aren't ignoring the sanity checks to begin with
18:39:37 <monochrom> the other part is completed by either cabal or ghc-pkg refusing to "upgrade" altogether
18:39:56 <ben> ah
18:40:03 <mike-burns> I'd prefer to go from one consistent state to the next. Is that unreasonable?
18:40:34 <kwartzlab> Why does http://pastie.org/3122398 consume all my RAM, but http://pastie.org/3122401 does not?  They seem basically the same to me
18:40:35 <monochrom> going from one consistent state to another is a very orchestrated effort
18:40:37 <ben> so you'd specify a set of packages you want and cabal would have to go and rebuild possibly all of them as you upgrade any?
18:40:51 <ben> instead of installing/upgrading packages indvidually
18:41:05 <mike-burns> Well I can already specify a set of packages.
18:41:31 <mike-burns> @src minimum
18:41:47 <mike-burns> Oh. RIP lambabot.
18:42:01 <rwbarton> foldl1 min
18:42:45 <monochrom> a set of packages to add, but also a set of packages to unregister before that
18:42:52 <mike-burns> kwartzlab: Because foldl1 uses all your RAM.
18:43:06 <ben> I didn't mean set of packages to add but set of packages to have installed
18:43:08 <kwartzlab> mike-burns: why does it?  it doesn't seem like it should...
18:43:14 <ben> i mean uh
18:43:51 <ben> instead of cabal install foo, you'd do cabal add-to-installed-set foo; cabal rebuild or something
18:43:52 <mike-burns> kwartzlab: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
18:45:12 <Cale> Yeah, if you use foldl1' min it should run fine
18:45:23 <rwbarton> kwartzlab: your min'' checks which of "current" and "head" is less before proceeding to the next element of the input list. minimum = foldl1 min just builds up a huge expression min x0 (min x1 (min x2 ...)) and storing that expression is what consumes your RAM.
18:45:38 <rwbarton> er, not that expression
18:45:42 <rwbarton> but a similarly bad one
18:46:04 <Cale> Or: simply compile your program using minimum instead
18:46:20 <Cale> The strictness analyser is smart enough to sort this out.
18:46:33 <kwartzlab> Cale: I did use minimum, which uses foldl1 :P   oh, you mean compile with -O2 ?
18:46:36 <rwbarton> is it?
18:46:38 <Cale> If you compile with optimisations
18:46:53 <Cale> yes, I just tried it
18:46:56 <ben> is case <# a b of False -> ... ; True -> ... where b is a literal necessarily any slower than case a of b -> ... ; _ -> ...?[1;5C[1;5C[1;5C[1;5C[1;5C[1;5C[1;5C[1;5C[1;5C[1;5C[1;5C[1;5C
18:46:57 <rwbarton> neat
18:47:07 <ben> uhh sorry about that line noise
18:47:50 <monochrom> ok, suppose you say "replace X-1 by X-2, rebuild everything that needs rebuild". you have Y, Y depends on X-1, can't be rebuilt against X-2 because of an incompatible type. how does the computer know, and what should the computer do?
18:47:58 <rwbarton> ben: i'd guess not, since hopefully one will become a jump-if-less-than and the other a jump-if-equal?
18:48:23 <monochrom> it begins to sound like a complicated system of transactions, trying, committing, rolling back
18:49:20 <ben> well the alternative is explaining the issue to an idiot like me every other week in here
18:50:18 <mike-burns> That's what we do.
18:50:32 <mike-burns> If we didn't do that, we'd have to shut #haskell down!
18:51:02 <monochrom> category theory would fill the vacuum
18:51:56 <monochrom> anyway, at the end, the way I move from one consistent state to the next is: install the next version of haskell platform
18:52:14 <kwartzlab> Cale: ok, just tried with -O2 and it worked.  cool
18:52:31 <mike-burns> I use a ton of Hackage packages. I love 'em.
18:52:55 <bss03> Is there some typeclass that has fmap, but where the first argument is a non-polymorphic endomorphism?
18:54:52 <monochrom> such as "class Gunther g where gun :: (Bool -> Bool) -> g Bool -> g Bool"?
18:55:38 <bss03> Sort of.
18:55:56 <bss03> But with g having kind *, not * -> *.
18:56:28 <monochrom> "class Gunther g where gun :: (Bool -> Bool) -> g -> g"?
18:56:33 <bss03> class Mappable c e | c -> e where map :: (e -> e) -> c -> c
18:57:22 <bss03> (fundep optional)
18:57:53 <monochrom> I think I haven't seen it in libraries
19:02:34 <arw> accept: resource exhausted (Too many open files) <- hm, i'm still leaking file descriptors.
19:03:10 <arw> somebody recommended yesterday to do away with lazy IO, which I thought I did by using hGetContents from Data.ByteString.
19:05:18 <arw> might socketToHandle somehow be responsible? should one rather use sockets instead of handles?
19:06:37 <cl1> haskell does not have implementation inheritance correct?
19:06:59 <c_wraith> haskell doesn't have any sort of inheritance like popular OO languages have
19:07:07 <Axman6> thank goodness
19:07:11 <c_wraith> implementation or subtyping relationships
19:07:34 <cl1> c_wraith, it has parametric polymorphism
19:08:10 <c_wraith> cl1: which is pretty much completely independent of anything you might call "inheritance"
19:08:27 <c_wraith> cl1: it's closer to java generics, C++ templates, etc.
19:08:41 <c_wraith> none of which are features called "object-oriented"
19:09:20 <cl1> c_wraith, generics in c# is parametric polymorphism, maybe not on the level that haskell has (no type classes) but it is still parametric polymorphism
19:09:25 <The_Journey> is there any numeric library in Haskell that can optimize a function using Conjugate Gradient?
19:09:41 <cl1> my question is: how do you deal with the situation where a Person is also a Patient?
19:09:41 <mike-burns> Parametric polymorphism isn't inheritane.
19:09:44 <mike-burns> c
19:10:20 <c_wraith> cl1: yes, that's my point.  Where some languages have both inheritance and parametric polymorphism (of a sort), the two are completely unrelated features.
19:10:21 <mike-burns> cl1: Typeclasses?
19:10:27 <cl1> mike-burns, i said nothing of the sort
19:11:12 <cl1> mike-burns, you know like Functor, Monad, etc. those are type classes, c# doesn't have that
19:11:16 <Axman6> mike-burns: beginners tend to think that using type classes for things like that is a good idea, but quickly realise it's usually not
19:11:36 <worldsayshi> Q: Can I have global IORefs or MVars?
19:11:49 <cl1> so how do you deal with my proposed situation in functional programming?
19:11:54 <mike-burns> I haven't the foggiest what cl1 is trying to do. Maybe typeclases solves it.
19:12:01 <Axman6> worldsayshi: you can, but it's usually not a good idea
19:12:16 <Axman6> cl1: you haven't very clearly proposed anything yet
19:13:09 <cl1> in c#, if someone is a Person and also more specifically a Patient, you generally inherit a Patient object from a Person object. In functional programming you don't do that. What would you do instead?
19:13:19 <cl1> i'm trying to change the way I aproach things
19:13:25 <mike-burns> Try harder.
19:13:26 <worldsayshi> What I want to do is to manipulate an MVar that is read inside a threaded gui loop in the command line.
19:13:30 <ben> What about how the exception hierarchy is modelled?
19:14:04 <Axman6> worldsayshi: you'd create it in main, and pass it to the threads that need it, assuming you're still talking about the OpenGL stuff from before
19:14:28 <worldsayshi> yea.
19:14:40 <arw> cl1: create a person record/structure. create a patient record, containing a person record. similar as in C or database design.
19:14:54 <mike-burns> cl1: That's an implementation detail of how some people write OO in C#. That's not really a Haskell question.
19:14:58 <worldsayshi> Seems I would have to do a lot of boilerplate in the command line then..
19:15:00 <rwbarton> cl1: i'm a little skeptical of your example because a Patient is not a kind of Person, a person may be a patient in zero or more ways
19:15:19 <Axman6> worldsayshi: why?
19:15:25 <mike-burns> cl1: What is the function you're trying to write?
19:15:26 <rwbarton> if I have another subclass Doctor, what do I do when a doctor is also a patient
19:15:28 <arw> cl1: with the added advantage and complication that non-tree-structured relations are possible and easy
19:17:00 <dropdrive> Hi, is data F = F !Double the same as newtype F = F Double?
19:17:05 <rwbarton> if you want to store data about all the patients and doctors at your hospital, then you'd have a Patient record and a Doctor record each containing a Person field as arw says
19:17:06 <worldsayshi> v <- newEmptyMVar; startThread v; changeVar v
19:17:18 <worldsayshi> oh - more
19:17:32 <rwbarton> dropdrive, not exactly the same
19:17:35 <worldsayshi> changeVar v "mynewContent"
19:17:49 <rwbarton> let's say I write   data F = F !Double   newtype G = G Double
19:17:55 <cl1> I don't want to try to do OO in FP. My example is a trival OO concept. I need to think differently. Approach the problem from a different direction.
19:18:04 <cl1> arw, and that is common in FP?
19:18:13 <worldsayshi> Let me rephrase that
19:18:15 <arw> cl1: no idea, i'm new to this.
19:18:15 <rwbarton> then   case undefined of F _ -> () === undefined   but   case undefined of G _ -> () === ()
19:18:37 <cl1> arw, me too if you haven't noticed, well functional programming anyways
19:18:44 <arw> cl1: i can tell you that its very common in C and in databases :)
19:18:52 <irene-knapp> actually, medical information isn't that simple even if you only have those three tables
19:18:52 <cl1> arw, yes, i know
19:18:56 <irene-knapp> because some doctors are also patients
19:19:12 <irene-knapp> sorry, I know, unimportant.  my father works in that field :)
19:19:25 <tgeeky> irene-knapp: I think we can safely ignore those cases.
19:19:32 <rwbarton> dropdrive: other than that they are the same, they both have _|_ plus a value for each non-_|_ Double
19:19:34 <irene-knapp> I agree, for this purpose, haha
19:19:34 <tgeeky> surely they'll just find other ways to get medical care
19:19:36 <worldsayshi> sharedVar <- newMVar "Hello World" ; startGUI sharedVar; changeVar sharedVar "Hello again";        Something like that
19:19:40 <irene-knapp> hahaha
19:19:51 <dropdrive> rwbarton: Okay, thanks.
19:20:01 <rwbarton> but we think of bottom for F as _|_ and bottom for G as G _|_
19:20:08 <cl1> irene-knapp, actually at work we have to deal with exactly those cases. I used person and patient in my example, but that is a naive implementation
19:20:20 <arw> irene-knapp: yes, thats a general problem of OO modelling with inheritance. you need to squash everything into some hierarchy, no matter whether it fits or doesn't...
19:20:35 <mike-burns> Prefer composition, etc.
19:20:39 <irene-knapp> cl1: gotcha, yes :) I knew they were real and important cases in non-example situations, hehe
19:20:41 <mike-burns> Either way, we don't do that in Haskell.
19:20:46 <worldsayshi> rather; it would be nice to: startGuiThread; change "HelloWorld"
19:21:38 <cl1> mike-burns, so what do you do in haskell? that's what i'm asking
19:22:07 <worldsayshi> Axman6 <- I should probably call
19:22:25 <mike-burns> cl1: We tend to deal with the behavior and let that guide the data.
19:22:29 <Axman6> cl1: give us a more broad application and we'll tell you how we'd implement it. what you're asking us to do is something we wouldn't do in FP usually
19:24:15 <mike-burns> cl1: Also, the composite pattern is a sum type in Haskell. That may be helpful to know.
19:24:16 <cl1> well in c# there would be a method, lets call it MailLetters that takes a Person as its parameter. In c# it may get passed a Doctor, Patient, or a Contact object, they all inherit from Person. the method creates letters from a template using the Person information passed in and then prints them to be mailed.
19:25:03 <mike-burns> data Person = Doctor | Patient | Contact
19:25:20 <Axman6> worldsayshi: mkWorldChanger :: IO (a -> IO (), MVar a); mkWorldChanger = do {ref <- newEmptyMVar; return (putMVar ref, ref)}; main = do { (change,ref) <- mkWorldChanger; forkIO (handler changer); mainLoop ref }; handler changer = do { changer "Hello"; changer "World"}
19:25:44 <companion_cube> data Person = Me | Others
19:26:20 <rwbarton> cl1: the simplest thing would be to have a function mailLetters that takes a Person record
19:26:42 <rwbarton> when you want to call it on a Patient, use some function to get the Person underlying that Patient (probably a record field accessor)
19:26:52 <Axman6> data Person = Person {firsName, lastName :: String, age :: Int, personType :: PersonType}; data PersonType = Doctor | Patient | Bum
19:28:19 <cl1> i see
19:28:21 <ben> class PersonClass p where { toPerson :: p -> Person }; sendLetter :: PersonClass p => p -> Letter -> MagicalMailMonad ()
19:28:25 <ben> *hides*
19:28:47 <cl1> lol @ MagicalMailMonad
19:29:30 <Axman6> there's no need for a class
19:29:50 <Axman6> makeAddress :: (a -> Person) -> a -> Letter
19:30:01 <Axman6> s/Address/Letter i guess
19:30:26 <cl1> Axman6, class would be overkill?
19:30:28 <rwbarton> even less need for that... just write Person -> Letter
19:30:30 <Axman6> yes
19:30:44 <Axman6> yeah, that too
19:30:46 <mike-burns> And we'd probably write something like    mailLetter $ formatPersonLetter $ thePerson
19:30:48 <mike-burns> Yeah.
19:31:02 <worldsayshi> Axman6: Thanks! I'm going to have to try that some..
19:31:27 <mike-burns> That's what I'm saying: Person would be some sum.
19:31:31 <cl1> mailLetter $ formatPersonLetter $ convertToPerson myPersonWhoIsADoctor ?
19:31:40 <Axman6> worldsayshi: it's used commonly for logging, you have an IO function that returns a function that will do the logging however you like
19:31:56 <rwbarton> names aside, yes
19:32:31 <Axman6> so, you could have a different logger for writing to a file or over the network, but they'd have the same interface
19:33:20 <worldsayshi> hmm
19:34:04 <hpaste> mike-burns pasted “Person Doctor Patient” at http://hpaste.org/56058
19:34:04 * cl1 thinks on this abit
19:34:25 <mike-burns> cl1: http://hpaste.org/56058 - this is what I would do, at first blush.
19:35:37 <Axman6> worldsayshi: remember, think functionally, use functions!
19:36:11 <cl1> mike this particular letter mailer only cares about the name (going off of your example) and would produce the same letter for each person most likely [Person] -> Letter
19:36:30 <arw> .oO( and now for the "You are a doctor with $num years of experience, you should know that your $complaint is stupid!" )
19:37:19 <cl1> but I think I get the concept
19:37:21 <arw> though i really can't think of a good solution for that one.
19:37:38 <mike-burns> arw: Not having Doctor and Patient be separate types.
19:37:45 <rwbarton> this is just one option
19:38:30 <Axman6> cl1: it seems to me that that kind of program would do best using a database, where you'd have a table of people, and a table of doctors, which references the people, as well as adding the extra data, and a table for patients etc
19:40:13 <hpaste> mike-burns annotated “Person Doctor Patient” with “Person Doctor Patient (annotation)” at http://hpaste.org/56058#a56059
19:40:38 <mike-burns> cl1: That's the same thing but with the same string for both Person types.
19:40:47 <mike-burns> I'm interested in seeing rwbarton 's hpaste.
19:41:05 <Sgeo> @hoogle CInt -> Integer
19:41:19 <mike-burns> lambdabot is dead. Patient Zero.
19:42:44 <hpaste> rwbarton pasted “Person Doctor Patient alternative” at http://hpaste.org/56060
19:42:48 <rwbarton> something like this i guess
19:43:13 <mike-burns> Ah, true.
19:44:09 <rwbarton> this way you have a way to write functions that work only on Doctors or only on Patients, but what you lose is the ability to stuff both Doctors and Patients into the same list and recover which you had
19:46:56 <mike-burns> Oh right, I'm tired. Catch ya later.
19:47:05 <cl1> laters @ mike-burns
19:47:12 <arw> damned. exceptions...
19:49:09 <arw> it leaks file descriptors because I took the 'just ignore it' approach instead of proper error handling...
19:50:33 <arw> there should be a 'you laziness will bite you'-warning from the compiler for every call where exceptions are not immediately handled.
19:50:37 <arw> ;
19:50:54 <cl1> printLetter :: (a -> String) (a -> String) a
19:51:56 <cl1> printLetter name address person = Letter ("hello" ++ (name person) ++ " we have recently added.. blah blah blah") (address person)
19:52:13 <cl1> how about that? am I thinking functionally now?
19:52:26 <Bynbo7> better
19:53:05 <cl1> Axman6, only better?
19:53:58 <ski>   printLetter :: (a -> String) -> (a -> String) -> a -> Letter  -- ?
19:54:11 <cl1> ski, yes
19:54:28 * ski wonders what the point of the `a' is here
19:54:44 <ski>   printLetter :: String -> String -> Letter  -- i.e., why not this ?
19:55:06 <cl1> ski .. point made
19:55:42 <ski> i mean, the former might be preferable in some special context -- but lacking any such, the latter seems easier and simpler
19:56:33 * ski isn't really sure what cl1 is doing, though
19:57:46 * cl1 is trying to figure out how you would approach something in a functional programming language when you don't have inheritence, but you think in objects inheriting objects.
19:58:03 <djahandarie> Stop thinking.
19:58:29 <djahandarie> </borderline_useless_advice>
19:58:51 <Axman6> cl1: what have you been using to learn haskell?
19:59:04 <cl1> real world haskell
19:59:14 <cl1> i'm not much further into it than when I was last here
19:59:37 <hoqhuuep> What other programming experience do you have?
19:59:40 <cl1> I just keep thinking, how would I solve this functionally in lots of situations, and have no answer
20:00:46 <wavewave> hi
20:00:47 <djahandarie> cl1, it's usually something like make data types for your various types of data, and then write transformations inbetween them.
20:01:18 <djahandarie> There's almost always a way to represent your data without inheritence.
20:01:18 <wavewave> then functorize.
20:01:19 <cl1> hoqhuuep, about 15 years of object oriented programming.
20:01:48 * ski . o O ( `mailLetters :: Person -> ?' )
20:02:47 <cl1> i just spent the last 4 days learning all the intricate details of an IoC container and how you can use it for aspect oriented programming. I'm not happy with what you have to do in order to get all of that (but that's another story not related to this chat room)
20:02:47 <monochrom> apart from "don't think inheritance" I don't have any constructive advice. note I don't say "don't think objects". you can certainly have a record of data and operations, that's an object, and you already do that in the prototype kind of oop
20:02:49 <rwbarton> cl1, my impression is that you are not starting from an actual problem but rather from the way you would model a situation in OO
20:03:00 <Axman6> cl1: i'd recommend LYAH, it's a much better introduction to Haskell than RWH
20:03:30 <arw> is there something like 'return' in procedural languages? like "abort this function, we are done here"?
20:03:35 <cl1> rwbarton, yes, that is exactly what I'm doing. Axman6 I made it monads, and realized i had forgoten very basic things becuase all i did was read. rwh has excersices
20:03:42 <ski> arw : no
20:04:02 <c_wraith> arw: that doesn't even really make *sense* in haskell's world.  There isn't a set evaluation order
20:04:04 <djahandarie> sendLetters :: Person -> MailDirections; executeDirections :: MailDirections -> IO (); mailLetters = executeDirections . sendLetters -- ? Damn verbs.
20:04:04 <ski> arw : there is `callCC', if you really want it (doubtful)
20:04:11 <monochrom> if you use recursion, or rather, since you use recursion, as long as you don't recurse, you're already returning
20:04:43 <ski> "this function" isn't well-defined
20:04:44 <cl1> rwbarton, i was hoping I would get a "no don't do that, do this" answer instead
20:05:25 <arw> ski: right, too non-specific. specifically, its about something in IO, so there is an execution order.
20:05:31 <monochrom> look for the source code of "lookup" for an example of "early exit"
20:05:39 <ski> cl1 : i would maybe try to start writing signatures for the operations you want to have, then try with a shallow or a deep embedding
20:05:59 <ski> arw : details ?
20:06:17 <monochrom> same story with IO. if you don't recurse, you're already exiting.
20:06:27 <wavewave> cl1: hmm. first, haskell can represent inheritance.. it's not just as useful as parameterized types in most cases.
20:06:59 <arw> ski: i'm setting up a network connection with a sequence of 'socket; connect; readStuff; close'. every one of those could cause an exception, thereby making the following stuff useless.
20:07:14 <arw> ski: is a nested block of 'try' the best option for this?
20:07:21 <rwbarton> cl1, I think it is better to start with "how do I solve [some specific problem]", when learning any new language, not "how do I design a setup where I can solve any of an ill-defined set of future problems"
20:07:22 <Axman6> arw: look at ResourceT:
20:07:45 <Axman6> http://www.yesodweb.com/blog/2011/12/resourcet
20:07:53 <rwbarton> both because you won't have the experience to think about the latter yet, and because you'll have an easier time asking questions about what you are doing
20:09:27 <wavewave> rwbarton: I think asking a question like cl1 is a kind of unlearning step.. It's quite natural to ask.
20:09:43 <rwbarton> yes, perhaps
20:09:59 <rwbarton> but I don't think you can hope for a very enlightening answer
20:10:08 <arw> Axman6: cool, thanks.
20:10:24 <wavewave> later, the experienced feel it's rather obvious in many cases.
20:10:55 <cl1> wavewave, thank you
20:11:05 <wavewave> cl1: my advise is to try to think about a simple type first.
20:11:28 <wavewave> inheritance  or whatever is a secondary concept after all.
20:11:49 <ski> preflex: xseen lambdabot
20:11:50 <preflex>  lambdabot was last seen on freenode/#haskell 3 hours, 14 minutes and 24 seconds ago, saying: Gangway!
20:12:24 <Sgeo> What, exactly, does this snippit from the GHC manual mean?
20:12:24 <Sgeo> -optl-Wl,-rpath,'$ORIGIN'
20:12:29 <wavewave> in oop, you define a class with the first line of defining parent class.. that's why you first consider inheritance from the beginning.
20:12:48 <monochrom> something about getting dynamic linking to work
20:13:14 <monochrom> it means passing -Wl,-rpath,'$ORIGIN' to the linker
20:13:36 <wavewave> cl1: just think you have no parent classes in your oop language.
20:13:38 <ski> arw : in some cases, something like <http://hackage.haskell.org/package/EitherT> could also be useful
20:15:06 <wavewave> cl1: and also set all your member functions free outside the boundary of class.
20:15:31 <monochrom> functions want to be free? :)
20:15:32 <cl1> wavewave, i get the functions part. I do alot of service oriented stuff
20:15:53 <Sgeo> <interactive>: Prelude.chr: bad argument: 1769173061
20:16:02 <wavewave> cl1: I understand typical situations definitely.
20:16:14 <ski> theorems want to be free.
20:16:48 <wavewave> cl1: but I tell you first to deconstruct artificial methodology in oop.
20:17:07 <wavewave> that makes much sense in oop.. but not necessary in fp.
20:17:40 * cl1 listens
20:17:48 <wavewave> usually you feel you need inheritance because language itself needs such definition.
20:18:00 <wavewave> parent classes, method.. something like that..
20:18:13 <wavewave> but in fact.. that's not very necessary.
20:18:27 <wavewave> for example.. method is nothing but a function whose first argument is that object.
20:19:21 <wavewave> parent / child relationship is also some kind of sharing the same subset of functions among types.
20:20:21 <wavewave> once you deconstruct those oop methodology, now focus on the relationship between types.
20:20:45 <monochrom> ah, the unbundling helps
20:20:54 <wavewave> and don't hesitate make new types.
20:21:51 <wavewave> in oop, since a class usually has lots of method, it's heavy in concept.. so people tend to hesitate to create a new type.
20:22:14 <Younder> Why is your newsgroup so totally devoid of life. (comp.lang.haskell) ?
20:22:59 <wavewave> once you set free all slave method functions inside a prison of class, types are amazingly light concept.. whenever you need, you can make a new type with a single line.
20:23:12 <c_wraith> Younder: because people use the mailing list, this irc channel, and stack overflow
20:23:30 <monochrom> it is not "my" newsgroup
20:23:42 <wavewave> so just make it.. then you will find a pattern...
20:24:17 <Younder> c_wraith,  Well obviously I use IRC too.. But for mor lengthy discussions I prefer a newsgroup.
20:24:36 <c_wraith> most people don't.  hard to have a conversation by yourself.
20:24:40 <monochrom> comp.lang.haskell was created at the twilights of usenet altogether.
20:24:52 <wavewave> for example, if your calculation involves sequential unbound operation... you will create a type similar to list.
20:25:08 <Younder> c_wraith, that much I have gathered.
20:25:27 <arw> Younder: nobody uses usenet anymore, so no new people will use usenet, since its empty, so nobody uses usenet...
20:25:30 <rwbarton> there's a newsgroup?
20:25:37 <Sgeo> Is there a way to compile or load into GHCi such that it will give line numbers when  exceptions occur?
20:25:40 <wavewave> cl1: when pattern arises, parametrize it.
20:25:49 <cl1> wavewave, i see what you mean
20:25:59 <monochrom> comp.lang.functional had years of active haskell activity. comp.lang.haskell was created too late
20:26:16 <cl1> wavewave, so its not such a big deal to have a Doctor type and a Contact type that both have name and address
20:26:19 <dmwit> :t lookup
20:26:21 <dmwit> :t maybe
20:26:27 <Younder> arw: not true. I stull am active in comp.lang lisp and sci.math. (though not very)
20:26:31 <cl1> my function doesn't care and it should just take two string parameters
20:26:45 <wavewave> cl1: yes!
20:27:38 <arw> Younder: yes, but as a general trend usenet is shrinking.
20:27:43 <cl1> or better yet tuples then I could map my function over a list of tuples
20:27:58 <wavewave> cl1: later when your vocabulary become mature, you will make combinatorically many types using combination of other parameterized types.
20:28:10 <Younder> Anyhow thank O'Sullivan , Goerzen and Stewart for Real World Haskell. It is a gosend.
20:28:19 <Younder> godsend
20:28:45 <wavewave> cl1: for example, tuple is the most basic parametrized type.
20:29:12 <cl1> wavewave, i see
20:29:35 <cl1> in c# tuple is Tuple<T1,T2>
20:29:46 <cl1> i love me some generics
20:30:18 <Axman6> ew
20:30:27 * hackagebot persistent-postgresql 0.6.1.3 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.6.1.3 (MichaelSnoyman)
20:30:30 <Axman6> (T2,T2) is all you need! =)
20:30:49 <wavewave> cl1: people here advise you to focus on problem first.. because good data type designs often arise from good algorithm.
20:31:11 <wavewave> cl1: making a new type is no problem.
20:31:25 <wavewave> cl1: we love to make any kind of data types.
20:32:22 <Axman6> make ALL the data types!
20:32:51 <wavewave> cl1: also logical relation between types are expressed very well in various ways in haskell
20:32:56 <Axman6> making new interesting data types is one of the more fun things to do when learning haskell
20:33:09 <wavewave> inheritance is just only a small example.
20:33:45 <wavewave> haskell is the most powerful mainstream language in expressing data type relations.
20:34:37 <wavewave> but it's rather difficult to see before learning some basics. so do not worry about it from the beginning.
20:35:01 <cl1> wavewave, I have big problems to solve, so its hard not to do that
20:35:50 <Younder> Anyone got 'The art of computer programming'4A Combinatorial algorithms?
20:36:25 <wavewave> cl1: from my experience, if you have some big urgent problem, do not try too much to use advanced concept before you fully internalize them
20:37:05 <Younder> wavewave, what do you mean?
20:37:35 <JoeyA> Dang, I gotta get this done by tomorrow.  Hey, I wonder what Arrows are...
20:37:45 <Younder> sound like a short
20:38:02 <cl1> wavewave, we are safe for now. all my big problems must be solved with c#. I would like to introduce functional programming at work, but until I get a MUCH better handle on it, that will not happen
20:38:10 <Younder> JoeyA, The would be category Theory.
20:38:16 <Younder> them
20:38:20 <JoeyA> @hoogle Control.Arrow
20:38:32 <wavewave> Younder: nothing special... just take step by step.
20:38:38 <JoeyA> > where is lambdabot?
20:38:44 <cl1> I would have to create a solution to a specific problem set to even think about proposing any functional programming. and that won't be easy
20:38:44 <Axman6> dead
20:38:44 <monochrom> heaven
20:38:56 <djahandarie> He's dead, Jim.
20:38:58 <djahandarie> I mean Joe.
20:39:00 <Axman6> Cale: lambdabot is dead again
20:39:39 <Younder> So we need to write another one, or will it resurrect soon?
20:39:43 <wavewave> cl1: I see.. then you need even more better internalization.
20:39:52 <JoeyA> You could start with a small problem that Haskell is particularly well-suited for.
20:40:23 <wavewave> cl1: you cannot persuade others if you dont' convince yourself.
20:40:24 <JoeyA> For example, finding anagrams in a list of words.
20:40:30 <JoeyA> Or something something big integers.
20:41:31 <wavewave> cl1: so step by step.. good thing is usually you will encounter much of FP concepts fairly early when you try to solve some modest sized problem anyway.
20:42:05 <Younder> JoeyA, Welll Haskell's GHC uses the multi-precision lib from gnu I belive. Why not for floating point as well?
20:42:26 <Axman6> Younder: there's CReal
20:43:01 <Axman6> also, i think GMP only works on Integral types right?
20:43:08 <monochrom> because too many people ask "why not" and too few people implement
20:43:29 <wavewave> my advise is especially to say 'do not make monad transformer from the beginning if you don't understand it well' ;-P
20:44:20 <djahandarie> I would not recommend CReal for anything where you actually need performance.
20:45:13 <Sgeo> Does forkIO clobber getArgs?
20:45:27 <monochrom> no
20:46:10 <c_wraith> forkIO barely does anything.
20:46:19 <wavewave> using simple pure functions and types in functional programming is already usually much better than c# design in many cases.
20:47:02 <JoeyA> For projects involving heavy string manipulation, database access, or concurrency, don't expect Haskell to save time unless you're already proficient in the language.
20:47:51 <cl1> wavewave, i do higher order functions in c# already quite a bit, and i find them much more flexible than other ways
20:47:58 <ski> @botsnack
20:47:58 <lambdabot> :)
20:47:59 <djahandarie> Heavy string manipulation (parsing?) and concurrency are both done very well by Haskell though. Better than any other language I can think of.
20:48:16 <djahandarie> Well, Erlang does concurrency pretty well.
20:48:36 <monochrom> JoeyA means it takes some time to learn enough first
20:48:38 <djahandarie> I agree it takes time to get profecient with it though.
20:48:48 <cl1> doesn't anything powerful?
20:49:00 <djahandarie> Just thought it was weird that those were the things cited... not sure I'd consider them the most complex things either.
20:49:09 <wavewave> cl1: good. I think persuading your colleague from the need of higher order function is the best
20:49:18 <Younder> I love using Haskell for recursive descent parsing.
20:49:22 <djahandarie> Parsec is honestly not too bad as an intro to a number of the abstractions as well.
20:49:25 <cl1> any powerful programming concept that is, guns are pretty powerful and don't take alot of time to learn
20:49:33 <JoeyA> For hacky string manipulation, if you don't know Haskell well, you might be better off using Perl, for instance.
20:49:50 <djahandarie> I wouldn't use Haskell for anything hacky
20:49:52 <monochrom> yeah, I was thinking "what about push-button thermonuclear war?" :)
20:49:52 <JoeyA> I wrote a simple time log parser for myself in Haskell.  It parses things like:
20:49:57 <JoeyA> @in 12:29 AM
20:49:58 <lambdabot> Maybe you meant: index instances instances-importing id wn
20:50:00 <JoeyA> @out 1:03 AM
20:50:00 <lambdabot> Maybe you meant: bug ft let quit run
20:50:05 <JoeyA> It's 441 freaking lines
20:50:14 <Younder> LR(n) is overrated use a LALR(n) parser insted.
20:50:27 <JoeyA> (way more than it ought to be)
20:50:30 <Younder> instead
20:50:52 * ski . o O ( `LL(n)' ? )
20:51:11 <monochrom> "1. tic tac toe  2. chess  3. global thermonuclear war"  3  "please enter target cities: "
20:51:46 <Younder> monochrom, war games?
20:51:59 <JoeyA> monochrom: A program should do one thing, and do it well.
20:52:26 <JoeyA> Oh yeah, I remember that joke now
20:52:37 <monochrom> granted, the kid first had to learn how to program a computer and moden to cold-call all possible phone numbers...
20:53:14 <JoeyA> I saw it in a Macintosh game a long time ago.
20:54:06 <JoeyA> (it was a collection of board games, with one of the choices being "Global Thermonuclear War"
20:54:15 * ski . o O ( <http://en.wikipedia.org/wiki/Nuclear_War_%28video_game%29> )
20:54:17 <cl1> I have to deal with not one, but several programs that do one thing well. but each one doesn't do much of anything by itself
20:54:40 <Younder> monochrom, Acutuall there was a Captian Crunch who had created that sotware at the time. The depiction of hacking, including the war calling, was pretty accurate.
20:54:40 <cl1> distributed programming is fun
20:56:25 <augur> ski: whats the future of programming languages
20:56:59 <JoeyA> Flying cars are going to kill a *lot* of people.
20:57:10 <Younder> augur, nobody knows
20:58:21 <augur> i was asking ski! :|
20:58:28 <Younder> augur, but Haskell and Mathematica have set the standards.
20:58:38 <JoeyA> For what?
20:59:04 <Younder> augur, true but I actually write compilers.
20:59:17 <cl1> Younder, for what languages?
20:59:17 <augur> all the more reason to not trust you!
20:59:18 <augur> :p
21:00:03 <Younder> cl1: I am writing a language I have called Formula.
21:01:23 <cl1> Younder, this one? : http://dl.acm.org/citation.cfm?id=110893
21:01:58 <Younder> cl1: no
21:02:45 <ski> augur : <http://lambda-the-ultimate.org/classic/message6509.html>
21:04:16 <cl1> Younder, just as well. I should probably focus my efforts on learning haskell right now
21:04:17 <Younder> cl1: I am using Category Theory and modern Type Theory to produce the first compiler that can verify i'ts program without extra dressing. Or at least that is the idea. functional, closer to Mathematica than Haskell, but typed-
21:04:57 <cl1> Younder, sounds interesting
21:07:53 <Younder> cl1: I love it.
21:08:21 <cl1> I would hope so, you are writing it!
21:09:17 <Younder> cl1: Yeah, I never thought it would be so challenging, so much fun.
21:10:21 <blackdog> i'm looking for a declarative non-turing-complete JSON-ish to JSON-ish conversion language in Haskell - something like XSLT but for json. any ideas?
21:10:45 <Younder> blackdog, javascript ;)
21:11:00 <blackdog> pretty sure that's turing complete:)
21:12:29 <blackdog> (and yes i know xslt is too, but i don't think this one needs to be - i'd like to be able to run submitted programs safely without having to worry about sandboxing)
21:13:11 <MarcWeber> blackdog: why not create your own?  delkey foo.bar  add_string foo.bar.baz "abc"  move yoo[3] new_location .. ?
21:13:49 <blackdog> MarcWeber: that's the next option, but i was hoping someone would pipe up with "ah, that's just FooBarXyzzy"
21:14:04 <cl1> blackdog, what is wrong with running a script from inside your program?
21:14:07 <blackdog> i've reinvented enough square wheels
21:14:16 <MarcWeber> blackdog: Talk about your use case..
21:14:17 <blackdog> cl1: user-submitted scripts
21:14:22 <MarcWeber> Which kind of changes do users have to make?
21:15:30 <cl1> if your script engine doesn't give them the ability to directly access memory locations (like javascript), and provides no support for reading from or writing to disk, you should have no problem
21:15:49 <arw> cl1: either you use eval in javascript which is a security problem, or you write a JSON parser, which is easier in haskell...
21:16:29 <arw> cl1: and you can always to a while(1); DoS attack.
21:16:34 <blackdog> cl1: you can still DoS it by writing an infinite loop
21:16:36 <blackdog> yes, that
21:16:43 <blackdog> maybe i'm overthinking it.:)
21:16:43 <Axman6> blackdog: i wonder whether there's a nice lense implementation. i'm probably wrong...
21:16:47 <cl1> true
21:16:51 <blackdog> Axman6: thanks, i'll think about that
21:17:26 <Axman6> blackdog: i think you'd end up with stuff like modifyPath f ["foo","bar","baz"] or something
21:17:39 <Axman6> i don't know enough about XSLT to know what you'd want to do though
21:21:57 <cl1> blackdog, http://goessner.net/articles/jsont/
21:22:31 <companion_cube> does anyone know how to parse HTTP queries on a server socket? I can't find how to make the 'regular' networking API with Handle work with Network.HTTP and its bizarre HandleStream
21:23:08 <cl1> omg its midnight
21:23:51 <Sgeo> Hypothetically, if Monads had to be instances of Functors, could I use my definition of >>= to define fmap?
21:24:19 <ski> yes
21:24:28 <monochrom> you also need return
21:24:47 <Sgeo> (My actual situation is wanting to define show in terms of .. wait
21:25:06 <Sgeo> Will anyone yell at me if I make an Exception instance where Show isn't a thing that can make a new one?
21:25:26 * ski doesn't understand the question
21:25:40 * Axman6 failed to parse that
21:26:06 <Sgeo> I want the show of my type to not be its actual representation as an Int, but as explanatory text
21:26:28 <cmccann> that's not really what Show is supposed to be for, of course
21:26:29 <Axman6> where does Int come into it?
21:26:30 <ski> that's probably bad, yes
21:26:57 <cl1> i'm not good at FP and i can say that is bad
21:27:13 <cl1> you do not want to give consumers of your code something that works unexpectedly
21:27:33 <Axman6> newType MyException = MyException Int; instance Show MyException where show (MyException n) = case n of 0 -> "Ok"; 1 -> "EOF" etc?
21:27:35 <cmccann> not that every Show instance out there is well-behaved or even vaguely sensible
21:27:35 <Sgeo> Axman6, the library I'm wrapping gives return codes that are ints
21:27:41 <Sgeo> Axman6, yes
21:28:14 <Sgeo> And I want to convert from that into throwing exceptions
21:28:17 <monochrom> Show for exception types can be more explanatory, yes
21:28:44 <cl1> make an exception type that takes an int as its parameter and implement show for that
21:28:49 <Axman6> especially since the types you usually use for Exceptions are almost always used just for exceptions
21:29:05 <Axman6> so the Show instance should be useful, rather than something you'd expect to read using the Read class
21:29:10 <cmccann> > show (putStrLn "??")
21:29:11 <lambdabot>   "<IO ()>"
21:29:11 <ski>   data MyException = Ok | EOF | ... | deriving (Eq,Enum,Show,Read)  -- ?
21:29:40 <Sgeo> ski, hmm, maybe I should do that instad
21:29:41 <Sgeo> instead
21:29:51 <Axman6> in this case you still need to convert from Int to MyException anyway
21:30:03 <Sgeo> My own enum instance?
21:30:06 <Axman6> which may or maynot be a pain in the arse =)
21:30:18 <ski> @type toEnum
21:30:19 <lambdabot> forall a. (Enum a) => Int -> a
21:30:39 <Axman6> and leave succ and pred untouched?
21:30:50 <ski> you can derive `Enum', if you're ok with it using contiguous numbers starting from zero
21:30:50 * Axman6 -> home
21:33:38 <cl1> Sgeo, sure, give ski the credit for recommending an exception type :P
21:35:04 <cl1> well it's been fun, but i need to go to bed
21:35:16 <cl1> don't do anything I wouldn't do, and if you do, do it twice!
21:49:07 <Sgeo> Maybe instead of defining both toEnum and fromEnum, I should make an IntMap, define that, and define toEnum and fromEnum in those terms?
21:49:34 <Sgeo> Otherwise, I'd have to do everything twice
22:09:09 <mbuf> is there any specific grammar associated with buildDepends? particularly for IntersectVersionRanges, and UnionVersionRanges. Any, Wildcard seem to be consistent
22:15:22 <mcnster> anyone know if hackage considers version 0.1.0.0 > 1.0.0 ?
22:16:24 <kfish> afaiu 1.0.0 == 1.0.0.0, so no
22:17:28 <c_wraith> no, they're distinct.
22:17:50 <c_wraith> and 1.0.0 > 0.1.0.0
22:17:50 <mcnster> hmmm
22:18:08 <c_wraith> they're parsed into a [Int], and compared as such
22:19:02 <mcnster> c_wraith, ty :)
22:19:24 <kfish> c_wraith, do you agree with what i wrote? (i'm only 90% sure ;-)
22:19:50 <c_wraith> well, you didn't even use the same numbers mcnster did.
22:19:54 <c_wraith> but also, you're wrong.
22:20:09 <c_wraith> > compare [1, 0, 0] [1, 0, 0, 0]
22:20:10 <lambdabot>   LT
22:20:24 <kfish> i was just talking about his 1.0.0 number, saying that it is treated as 1.0.0.0, and is thus greater than 0.1.0.0
22:20:38 <c_wraith> oh.  well, that's half right.
22:20:42 <mcnster> > compare [1,0,0] [0,1,0,0]
22:20:43 <lambdabot>   GT
22:20:53 <kfish> ok, so adding a .0 to an existing version makes a new, greater version
22:20:58 <c_wraith> yes
22:21:05 <mcnster> (just checking).  thanks again.
22:21:08 <kfish> i'd say i was 90% right lol
22:28:56 <bmh> Is it possible to define a set of typeclass methods in terms of one another in such a way that obliges (at compile time) an instance to provide a concrete implementation?
22:32:50 <srhb> bmh: Do you mean subclassing_
22:33:16 * Sgeo feels weird
22:33:29 <Sgeo> Maybe instead of being lazy, I should write a script to write some Haskell code for me
22:33:33 <Sgeo> Instead of doing this
22:33:44 <Sgeo> (error "Network.Activeworlds.RC.fromEnum: " ++ (show rc) ++ " is unknown. This is a bug in RC, please report it.")
22:34:54 <bmh> srhb: perhaps I have terminology muddled. What I'm thinking is a typeclass "Animal a" with walks :: a -> Bool and flies :: a -> Bool, where walks = not.flies and flies = not.walks, but `instance Animal Bird` would need to define flies = True
22:35:28 * hackagebot copilot 2.0.4 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0.4 (LeePike)
22:35:35 <Twey> Sgeo: Template Haskell is the answer!
22:35:56 <srhb> bmh: Out of my league I'm afraid, perhaps someone else knows.
22:36:06 <Twey> bmh: Unfortunately not
22:36:14 <Twey> bmh: Eq is an example of such a class
22:37:04 <bmh> Twey: oh and Ord, you have a zoo of functions defined in terms of each other. But there's no compile time enforcement of a concrete function?
22:37:33 <Twey> No, I'm afraid not… you just get an infinite loop by default
22:37:40 <Twey> Show too
22:37:55 <bmh> thought so. Oh well. Thanks
22:39:52 <srhb> Twey: So where are the actual definitions of (==) and (/=) for Eq?
22:40:43 <srhb> Twey: In every instance?
22:44:03 <yitz> srhb: yes, at least one must be redefined in every instance. otherwise, the infinite loop created by the default implementations remains.
22:44:47 <srhb> yitz: Right, thanks.
22:44:56 <yitz> srhb: that is explained in the haddock documentation for the class ("Minimal implementation: ...") but not enforced in any way by the compiler.
22:45:26 <srhb> yitz: Is there an explanation of why it's not enforced? Those loops seem rather strange as a default behaviour.
22:46:30 <yitz> srhb: no reason. there just isn't any way of requiring it. if you have a detailed proposal for how to add such a feature to the language, please let us all know. :)
22:46:40 <srhb> Right, okay.
23:20:29 * hackagebot xml-catalog 0.5.0 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-0.5.0 (MichaelSnoyman)
23:23:36 <Sgeo> I just encountered something similar to show . read
23:23:51 <Sgeo> Just threw in a type signature, works now, I guess I should stop being so scared of it
23:26:21 <hughfdjackson> I was having a discussion (mostly ill informed) w/ Mortchek over in #javascript about pong in haskell
23:26:55 <hughfdjackson> we're used to our mutable state, so (i personally) would normally maintain a mutable list of entities, and use that to represent game state
23:27:26 <hughfdjackson> =/ we were scratching our brain how you could do it declaratively, and basically the only solution we came up with was to pass the entire state of the world back from one step to the next
23:27:28 <hughfdjackson> is that the gist of it?
23:27:38 <yitz> hughfdjackson: you would do a similar thing in haskell, using some kind of state monad
23:28:10 <yitz> hughfdjackson: obviously the entire thing doesn't get copied. in the object code, it's just a pointer.
23:28:11 <Mortchek> yitz, would that basically mean you reconstruct an entire new state before discarding the old one?
23:29:29 <yitz> Mortchek: semantically, yes. in practice, no. generally, a new version of a data structure only involves replacing a pointer or two in the object code.
23:30:06 <hughfdjackson> yitz: so we're protected from evil imperative thoughts by the language, and wastefulness by the compiler?
23:30:07 <rwbarton> Mortchek: the new state can share those parts that are unchanged with the old state
23:30:12 <hughfdjackson> :3 that sounds like  a win win
23:30:13 <Mortchek> yitz, so that's a type of optimization done specifically on monads?
23:30:37 <yitz> Mortchek: no, it's a general feature of functional programming
23:30:38 <rwbarton> nope, it has nothing at all to do with monads
23:31:00 <Sgeo> What happens when threads get involved in the mix?
23:31:15 <rwbarton> nothing special
23:31:15 <hughfdjackson> yitz, rwbarton :D thanks a lot - this clears up a lot for me
23:31:36 <Sgeo> Well, I guess the addition of threading into a StateT using application forces you to actually think about the issues
23:31:37 <rwbarton> since all the data is immutable, it can be shared
23:31:40 <Sgeo> Which may be a plus
23:31:45 <Mortchek> Indeed, thanks yitz and rwbarton.
23:32:08 <dmwit> Sgeo: Modifications to the state in one thread do not appear in the other thread.
23:32:18 <dmwit> "modifications"
23:32:36 <Sgeo> dmwit, right, so if you wanted to do that, you'd need something like STM or IO-based mutable variables?
23:32:47 <Sgeo> Forcing you to actually think
23:33:06 <yitz> Sgeo: with stm you often don't have to think as much :)
23:33:10 <dmwit> Yes, it would need to be IO-based.
23:33:28 <Sgeo> yitz, but it forces you to think to use STM, is my point, I think.
23:33:37 <dmwit> You still need to be careful with STM, as I discovered to my chagrin the one time I tried to write a toy in STM. =P
23:33:48 <Sgeo> o.O
23:34:10 <yitz> dmwit: "Don't try this at home, kids."
23:34:46 <dmwit> STM is beautiful because it never deadlocks, and any transaction that goes through goes through atomically.
23:35:00 <dmwit> Unfortunately, it's ugly because transactions might fail to go through forever -- it can livelock.
23:35:22 <yitz> dmwit: i.e., starvation
23:35:30 <hughfdjackson> a follow up question of sorts.. what's the simpliest means of displaying graphics / getting keyboard input in haskell (were i to want to make pong for a learning excerise/kicks)?
23:35:32 <dmwit> yeah
23:35:56 <dmwit> hughfdjackson: Take your pick of SDL, GTK, wxWidgets, OpenGL.
23:36:00 <dmwit> Use whichever one you know.
23:36:06 <rwbarton> does gloss handle keyboard input?
23:36:11 <Sgeo> On a related note, which is easiest to learn?
23:36:22 <yitz> hughfdjackson: or html5
23:36:30 <hughfdjackson> yitz: w/ haskell? :S
23:36:32 <dmwit> gloss appears to have a G.G.I.Game
23:36:42 * hughfdjackson does a lot of html5 gaming stuff ;)
23:36:44 <dmwit> So gloss seems like a decent choice as well, if you don't already know one of the above.
23:36:54 <hughfdjackson> in javascript, that is :3
23:37:19 <hughfdjackson> does haskell have a GUI based on html5?
23:37:24 <yitz> hughfdjackson: use one of our nice web frameworks and fast lightweight web servers. you can run it locally, without a server.
23:37:27 <rwbarton> yitz: how would that work, have the server compute each successive frame
23:37:39 <yitz> rwbarton: ask hughfdjackson :)
23:37:42 <hughfdjackson> rwbarton: yes ;)
23:37:47 <hughfdjackson> except for not normally
23:37:57 <hughfdjackson> :3 if you run it locally, sure
23:38:11 <hughfdjackson> :D get beyond that and you end up in trouble territory
23:38:16 <rwbarton> locally would work, true. that sounds almost sensible actually
23:38:35 <Mortchek> Servers computing graphical frames? Sounds like trouble.
23:38:42 <dmwit> There is a not_recommended directory in the 7.4 release candidate download page. -_-
23:38:59 <hughfdjackson> Mortchek: eh, andrewjbaker and i were discussing thing
23:39:00 <hughfdjackson> *this
23:39:23 <hughfdjackson> on the clientside, i have a wrapper around canvas that will take json RPC calls and execute them
23:39:27 <Mortchek> hughfdjackson, isn't it pretty much always more efficient just to send entity data and have the client decide how to draw them together?
23:39:31 <hughfdjackson> so you don't have to send over the whole state, just canvas instructions
23:39:35 <dmwit> Mortchek: Seen broadway...?
23:39:37 <rwbarton> it'd be semi-reasonable if you send some kind of vector format that gets rendered by the client, yes
23:39:41 <dmwit> http://blogs.gnome.org/alexl/2011/03/15/gtk-html-backend-update/
23:39:44 <Mortchek> dmwit, I have seen bits of it.
23:39:48 <hughfdjackson> Mortchek: yea, and that way the game logic will be back end
23:39:55 <hughfdjackson> ^^ just no rendering stuff..
23:40:10 <hughfdjackson> js rendering stuff i'm more than happy to do.. this actually sounds like a usable idea for learning
23:40:15 <hughfdjackson> yitz++
23:40:18 <hughfdjackson> erm..
23:40:25 <hughfdjackson> *throws yitz a beer*
23:40:26 <hughfdjackson> :D cheers
23:40:26 <Mortchek> Right. In my opinion, the server shouldn't care how the client renders it anyway, as long as it chooses a correct interpretation of the data.
23:40:29 <yitz> @karma yitz
23:40:29 <lambdabot> You have a karma of 1
23:40:35 <yitz> hughfdjackson: thanks!
23:40:49 <yitz> i'll happily take the beer as well
23:40:55 <Sgeo> Client should, if performance wasn't an issue, only see what it should be allowed to see
23:41:05 <rwbarton> @karma you
23:41:05 <lambdabot> you has a karma of 0
23:41:05 <Sgeo> But with hypothetical 3d stuff...
23:41:50 <Mortchek> Yeah, I imagine it's not very efficient to determine exactly which things are in direct view.
23:41:55 <hughfdjackson> Mortchek: you're right for performance reasons
23:42:16 <Mortchek> And especially if the server sends things to the client exactly as it needs them.
23:42:19 <rwbarton> I hope the next demo in this video is a web browser
23:42:32 <hughfdjackson> RCanvas was more an experiement to allow other languages to use canvas' power/accessability
23:42:42 <hughfdjackson> and also to allow protected IP
23:42:47 <hughfdjackson> :D and for kicks
23:42:55 <hughfdjackson> in general use, i agree whole heartedly though
23:44:08 <Mortchek> I guess it would probably be more work to implement interpreters for those languages on top of JS.
23:50:45 <Sgeo> How efficient is pattern matching on Ints compared to looking up Ints in an IntList?
23:50:56 <ezyang> I think someone needs to write "MonadIO considered harmful"
23:51:37 <ezyang> Sgeo: I'm not sure, but pattern match will either be implemented as a jump table or a bunch of conditionals
23:51:38 <frerich> s/someone needs to/I will/ <-- that's the spirit!
23:51:53 <ezyang> Well, I'd like to see someone concur :-)
23:52:16 <frerich> I do!
23:52:45 <frerich> Not so much because I know much about MonadIO, but more because I don't know it yet and would like to avoid doing silly things :)
23:53:09 <rwbarton> I concur that MonadIO should be considered harmful. I think.
23:53:32 <rwbarton> if it's about the suggestion to change the type of putStr to MonadIO m => String -> m () and so on.
23:54:00 <ezyang> The point is MonadIO isn't powerful enough to do correct IO programming, which handles exceptions, masking, etc.
23:54:19 <rwbarton> ah yes
23:57:06 <ezyang> Uhh, http://www.yesodweb.com/blog/2011/08/monad-control doesn't have anything to do with the monad-control package, right?
23:57:33 <ezyang> Oh, wow, monad-base is a lovely abstraction.
23:57:38 <ezyang> Too bad it doesn't work with Cont.
23:58:16 <mm_freak> ezyang: MonadIO is only for lifting, while monad-control gives you certain control structures
23:58:20 <mm_freak> see also the lifted-base package
23:59:33 <mm_freak> MonadIO is not harmful, unless you also consider MonadTrans as harmful
