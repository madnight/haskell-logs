00:00:08 * shachaf doesn't know anything about libffi.
00:00:56 <Enigmagic> they use libffi as a unix-ish platform agnostic way to allocate an executable/writable page
00:01:10 <shachaf> Oh, that's all it's used for?
00:01:46 <shachaf> No, it looks like it does more than that.
00:02:05 <johnw> if Haskell is using libffi, shouldn't it possible to call varargs functions?
00:02:16 <johnw> s/Haskell/GHC
00:02:33 <Enigmagic> johnw: why would it need libffi to do that?
00:02:57 <johnw> because calling varargs varies greatly among platforms
00:03:03 <randomclown> Jafet: I think declaring a separate class for printing should be the ideal solution here, ty
00:03:12 <johnw> on amd64 in particular, it requires highly non-trivial code
00:03:24 <shachaf> A niftier trick would be exporting varargs functions.
00:03:51 <johnw> well, I can call printf from GHC pretty easily if I use bindings-libffi to setup the varargs and dispatch the call
00:04:02 <shachaf> It's non-trivial code but it's still just a calling convention you need to implement once.
00:04:07 <johnw> so I was wondering why that dispatches wasn't automatically a part of the FFI syntax
00:05:06 <Enigmagic> johnw: GHC already emits C code in some cases. If they ever switched over completely to LLVM it would also be trivial to support varargs on most platforms.
00:05:25 <johnw> LLVM doesn't have varargs support
00:06:06 <shachaf> It doesn't?
00:06:08 <Enigmagic> hmm?
00:06:11 <johnw> no, it's all done in Clang
00:07:13 <johnw> see, in my day job I'm writing a compiler backend using LLVM, and I just ran into the need to call varargs functions...
00:09:07 <Ralith> johnw: you're aware that LLVM's vararg intrinsics are nonfunctional, right?
00:09:17 <Ralith> (or has that changed?)
00:09:48 <johnw> according to #llvm the community is very open to factoring the ABI code from Clang, just no one has come up with the right design
00:10:06 * Ralith was there for that conversation
00:10:08 <johnw> the Clang ABI handling (including varargs) is too dependent on clang::Type
00:10:28 <johnw> I haven't even tried the llvm intrinsics, after that conversation
00:11:15 <johnw> I'm going to use libffi as my stop gap until we decide what to do in the long run
00:11:43 <johnw> but learning about libffi led me to realize that one could use that to call varargs C functions from Haskell
00:11:57 <johnw> and aha, I found bindings-libffi :)
00:12:10 <Enigmagic> i guess i got lucky since llvm on solaris and linux seemed to work with ccall varags functions just fine
00:12:18 <johnw> don't how to how to deal with the type-safety stuff, though
00:12:51 <johnw> Enigmagic: yeah, it all depends on what type arguments you're passing, and how many
00:13:01 <johnw> amd64 does all kinds of register allocation tricks for floats and stuff
00:13:06 <johnw> it's many pages in the ABI spec
00:13:19 <shachaf> @google nelhage amd64
00:13:20 <lambdabot> https://github.com/nelhage
00:13:53 <logix_> hi i'm a newbie on haskell
00:14:00 <shachaf> @google nelhage amd64 abi
00:14:01 <lambdabot> http://blog.nelhage.com/2010/10/amd64-and-va_arg/
00:14:01 <lambdabot> Title: Made of Bugs » amd64 and va_arg
00:14:19 <johnw> ohh, thanks sachaf
00:14:49 <shachaf> I always forget to xor rax,rax before printf.
00:15:05 <johnw> shachaf: do you work on compilers too?
00:15:11 <shachaf> Nope.
00:15:19 <johnw> you code in assembly?
00:15:22 <shachaf> Rarely.
00:15:27 <johnw> you were being facetious?
00:15:34 <shachaf> No.
00:15:44 <shachaf> I sometimes write small assembly programs, mostly to test things.
00:15:46 <Enigmagic> johnw: well glad i don't have to maintain that code anymore ;-) this was on solaris x86_64
00:15:49 <johnw> ah
00:16:00 <johnw> Enigmagic: i just abandoned my solaris machine this week
00:16:06 <shachaf> Doesn't Solaris x86_64 use the amd64 ABI?
00:16:14 <johnw> finally got tired of fighting constant uphill battles
00:16:34 <Enigmagic> shachaf: yes, so it probably will break sometime (if it's not already broken)
00:16:49 <Enigmagic> aka: glad i don't work there anymore
00:17:06 <johnw> ah, the joy of leaving bad code behind :)
00:17:43 <Enigmagic> don't worry, they're writing new bad code on linux now instead of solaris
00:18:18 <pharaun> weee! was able to get conduit up to 300MiB/s
00:18:28 <johnw> pharaun: what was the trick?
00:18:54 <pharaun> johnw: apparently conduit did not like the ed2k hash size, so i end up playing around and dropped it to (40*1024*8) for conduit (in bits)
00:19:15 <pharaun> still cannot get it to match the speed of my own impl but i'm not sure why yet but i'm happy for now at the 300MiB/s of conduit
00:19:39 <pharaun> still faster than most harddrive arrays are going to be anyway so this should be enough :)
00:21:02 <johnw> my array is 400MB/s
00:21:04 <pharaun> johnw: sorry not ed2k hash size, to be more exact - ed2k blocksize which is 9500*1024
00:21:06 <johnw> so you're depriving me of 25% :)
00:21:12 <pharaun> johnw: yeah mine can hit 330-400
00:21:30 <pharaun> i still have the regular file read impl which is quite a bit faster ;)
00:22:28 <johnw> you mean, if you have enough RAM
00:22:37 <pharaun> indeed
00:22:40 <nand`> I'm a bit confused. When building this package, I get ‘Not in scope: type constructor or class `Pixel'’ even though it's imported from Graphics.X11.Xlib; and the exact same line (a data-definition) runs fine in GHCi after the same imports
00:22:49 <nand`> oh, wait, I have an idea
00:23:02 <johnw> i'm trying bytestring-mmap on my test program now
00:23:11 <johnw> the great thing is that my library doesn't need to change to use it
00:23:12 <pharaun> johnw: ah well, i think i should shelf this for the moment, its good enough and i still got lots of other stuff to work on, probably will revisit when i'm better at performance stuff and conduit stuff
00:23:17 <johnw> i love that about Haskell
00:23:28 <pharaun> haha yeah
00:23:41 <pharaun> hows the mmap version working for you?
00:23:45 <johnw> one sec
00:32:56 <osa1> uh, nickserv is offline ..
00:33:34 <Jafet> That's ok, lambdabot is still around.
00:34:06 <shachaf> @where sneaky
00:34:06 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
00:35:30 <osa1> well, lambdabot can't help me post #concatenative ;-(
00:38:52 * ddarius needs to rewrite this all in vector notation.
00:44:28 * ddarius also needs to implement Kalman smoothing.
00:48:21 <akamaus> hi! Can I get, say a sizeOf of a type represented as Name in TH macro?
00:58:13 <Heffalump> does the new kind stuff in GHC 7.6 make it possible to write a proof of the associativity of Nat = Z | S Nat ?
01:07:23 --- mode: wolfe.freenode.net set +o ChanServ
01:11:38 * hackagebot VKHS 0.1.4 - Provides access to Vkontakte social network, popular in Russia  http://hackage.haskell.org/package/VKHS-0.1.4 (SergeyMironov)
01:29:31 <randomclown> how does one "unfold" a tree?
01:29:48 <randomclown> a list to a tree
01:32:05 <mm_freak_> randomclown: suppose data Tree a = Leaf a | Branch (Tree a) a (Tree a)
01:32:18 <mm_freak_> unfold :: a -> (a -> Either b (a, b, a)) -> Tree b
01:32:28 <mm_freak_> suppose data Tree a = Leaf a | Branch (Tree a) (Tree a)
01:32:32 <mm_freak_> unfold :: a -> (a -> Either b (a, a)) -> Tree b
01:32:39 <mysticc> @hoogle Graphics.UI.WX
01:32:39 <lambdabot> package wx
01:32:39 <lambdabot> package wxAsteroids
01:32:39 <lambdabot> package wxcore
01:32:58 <pordan30> are you looking for the inverse of a function that folds a tree to a list in some order?
01:32:58 <shachaf> mm_freak_: I think you would have data Tree a = Leaf | Branch (Tree a) a (Tree a)
01:33:42 <pordan30> if you are working with search trees, you can just fold element insertion over a list
01:34:26 --- mode: wolfe.freenode.net set +o ChanServ
01:34:32 <mm_freak_> shachaf: i chose a tree type, where the unfolder doesn't look like []'s unfoldr =)
01:34:48 <shachaf> Maybe (a,b,a)!
01:34:57 <mm_freak_> shachaf: exactly
01:35:15 <mm_freak_> that one doesn't show the difference as clearly as the unfolder for my Tree examples
01:35:30 <Jafet> Hmm, what does unfold look like for Free?
01:35:39 <johnw> how do I use a type variable within a function that does not appear in any of my arguments?
01:35:53 <mm_freak_> Jafet: you can't unfold Free
01:39:43 * Jafet visualises nonexistence
01:39:55 <johnw> i have a function taking a that needs to cast to a b that is related to a
01:40:05 <johnw> like, if a Blob, b should be C'git_blob
01:40:29 <Enigmagic> johnw: look at type families
01:40:37 <dmwit> casting doesn't exist
01:40:52 <dmwit> If the two types are equal, you're set. If they're not, write a function that translates between the two types.
01:40:54 <johnw> castPtr :)
01:41:09 <johnw> hmm
01:41:14 <johnw> there's an idea!
01:41:14 <johnw> thanks
01:41:31 <mm_freak_> johnw: castPtr is a conversion function in the sense dmwit just explained ;)
01:41:41 <dmwit> castPtr doesn't change the data the pointer is pointing to.
01:41:42 <johnw> ah
01:42:00 <johnw> i can't overload though
01:42:07 <johnw> so the function case doesn't help me
01:42:14 <johnw> reading about type families..
01:42:27 <dmwit> Maybe you could post some code...?
01:42:31 <johnw> sure
01:42:31 <mm_freak_> how would type families help?
01:42:45 <mm_freak_> i don't see the connection
01:42:47 <hpaste> johnw pasted “Object.hs” at http://hpaste.org/74781
01:42:51 <johnw> see lookupObject'
01:42:52 <dmwit> Before we even know the problem, it's hard to tell what will help.
01:43:01 <johnw> and how it now casts to C'git_object
01:43:11 <johnw> I need the cast to vary based on what a is
01:43:23 <johnw> (a could be one of 5 types)
01:43:48 <Enigmagic> looks like one type not 5?
01:44:04 <johnw> i haven't written all the users of createObject' yet
01:44:12 <johnw> just the one that type checks with that example
01:44:17 <akamaus> can anyone explain why this gives me a parse error: e <- runQ [|do {x <- [1]; let y = 2; return (Just x) } |]
01:44:34 <akamaus> it parses if I replace let with let .. in
01:44:44 <johnw> if I don't use the type annotation, the alloca is of the wrong type
01:45:09 <dmwit> Perhaps let { y = 2 };
01:45:13 <johnw> oh, mabye not
01:45:17 <dmwit> Though I would expect what you have there to work just fine, too.
01:45:22 <johnw> i just removed the type annotation and things worekd OK
01:45:28 <dmwit> > do { x <- [1]; let y = 2; return (Just x) }
01:45:29 <lambdabot>   <no location info>: parse error on input `}'
01:45:33 <nand`> yeah I think that parses as let { y = 2; return (Just x) }}
01:45:35 <johnw> dunno why the pre-refactoring case gave me an issue...
01:45:37 <dmwit> huh
01:45:39 <Enigmagic> johnw: i mean that you're only constructing values of a single type (Object)
01:45:43 <dmwit> > do { x <- [1]; let { y = 2 }; return (Just x) }
01:45:44 <lambdabot>   [Just 1]
01:45:50 <nand`> dmwit: lack of indenting bites you in single liners like that
01:45:56 <johnw> Enigmagic: do you want to see Blob.hs?
01:46:04 * dmwit nods agreeably
01:46:14 <Enigmagic> johnw: sure
01:46:28 <hpaste> johnw pasted “Blob.hs” at http://hpaste.org/74782
01:46:46 <johnw> I want to rewrite lookupBlob in terms of lookupObject'
01:47:57 <akamaus> dmwit, thanks, it works!
01:48:10 <mysticc> How to specify in cabal file to disable optimizations ?
01:49:34 <Enigmagic> johnw: something more than calling lookupObject' and pattern matching on the results?
01:50:16 <johnw> for blobs I need to use a suite of functions based on "blob"
01:50:25 <johnw> and so on for trees, commits, tags
01:50:34 <johnw> these are the specialized versions of lookupObject (no ')
01:50:51 <mysticc> Can I see what ghc command cabal used for compiling when I do cabal build ?
01:51:31 <akamaus> johnw, I'm curious, why are you parsing Git's data structures? What's your idea?
01:51:41 <Enigmagic> johnw: if you know the type use a typeclass
01:52:00 <johnw> ok
01:52:09 <johnw> but then I still have to write the same function 4 times
01:52:18 <johnw> the whole point is to generalize the common code
01:52:37 <johnw> akamaus: I'm providing a high-level interface to libgit2
01:52:47 <johnw> so that you can process/analyze/modify git repositories
01:52:54 <johnw> it facilities building GIt utilites
01:53:14 <akamaus> great :)
01:53:21 <Enigmagic> johnw: i suspect most of the code is common so it wouldn't need to be duplicated
01:53:46 <johnw> i think i found my ansewr
01:54:00 <johnw> one of my arguments is now a function, and that functions type can contain tnhe type variable!
01:56:12 <Enigmagic> yeah
02:10:55 <johnw> it works!!
02:10:56 <johnw> yay
02:11:11 <johnw> learned a ton about FFI tonight
02:11:35 <Enigmagic> sweet
02:12:28 <Enigmagic> i'm writing an Alternative instance for complicated trades :(
02:15:16 <hpaste> johnw pasted “smoke-test.hs” at http://hpaste.org/74783
02:15:25 <johnw> that's my final interface, for tonight
02:16:44 <Enigmagic> johnw: fyi Data.Text.IO has a putStr that doesn't need unpacking
02:17:23 <johnw> you see, in C++ I was using libgit2 and found it just a bit too low-level, so I wrapped an OO API around it.  But it had its own uglinesses and I realized how well the problem of managing a DAG maps to the functional domain.  That is what encouraged me to try again, this time in Haskell
02:17:51 <johnw> especially a fundamentally immutable DAG, like the Git data store
02:17:56 <johnw> Enigmagic: oh, nice, thanks
02:19:46 <johnw> and I need for this library to be efficient over huge repositories (millions and millions of Git objects), so I'm very interested to see how well Haskell can solve this problem
02:20:15 <johnw> shachaf: you awake?
02:20:32 <Enigmagic> wouldn't be my first choice for a haskell project but it can scale pretty well to large volumes of data.
02:20:48 <johnw> i think so too, from what I've seen
02:20:52 * shachaf beeps
02:21:00 <johnw> it's all in the art of knowing where to apply strictness
02:21:09 <johnw> shachaf: I wondered how you would write some code
02:21:22 <hpaste> johnw pasted “getBlobContents” at http://hpaste.org/74784
02:21:30 <johnw> something about that function feels inherently ugly to me
02:21:46 <Enigmagic> i dunno about that, it's more about how to structure code so that you don't need to apply that many strictness annotations
02:22:00 <johnw> Enigmagic: yes, that's part of what I meant by "art"
02:22:12 <johnw> using a light touch for large results
02:22:15 <shachaf> You probably shouldn't do foo^.bar^.baz
02:22:26 <johnw> no?  but I thought being lensy was good?
02:23:07 <shachaf> foo^.bar.baz
02:23:13 <johnw> ahh
02:24:30 <shachaf> Anyway, I'm not sure what's going on there.
02:24:57 <johnw> someone has given me a blob
02:25:13 <johnw> it may or may not have a hash yet, depending on whether it's been written to the repository or not
02:25:30 <johnw> it may or may not have a non-empty ByteString, depending on whether it's contents have been requested or not
02:26:05 <johnw> and it may or may not have an associated libgit2 object, depending on if any operation has occurred that made creation of such an object needful
02:26:20 <nobdrais1ntone> Is Daniel Santa Cruz here? What happens with Haskell Weekly News: Issue 244?
02:27:27 <johnw> depending on the composition of the blob, in some cases I can answer the request for contents right away, in other I need to read the contents, and in the third case I need to load the blob from scratch from the repo
02:30:05 <johnw> i have all these special cases because since objects are immutable in the git store, I don't need to carry all these values around in memory.  Once you write a blob to disk, I drop the bytestring from the blob (well, I return a new blob +hash -bytestring), because I know I can always get those same contents back again later if need be
02:30:59 <johnw> i really would like to use a lazy bytestring to model that deferred reading, but they don't play with at all with withCString
02:31:09 <johnw> play well
02:35:25 <shachaf> Is this an mmapped file or something?
02:35:30 <shachaf> What's blobPtr?
02:48:42 <johnw> no, not mmappd
02:48:48 <johnw> a blobPtr is a libgit2 git_blob*
02:49:10 <johnw> time for bed, good night all
02:51:41 * hackagebot svndump 0.4.2 - Library for reading Subversion dump files  http://hackage.haskell.org/package/svndump-0.4.2 (JohnWiegley)
02:56:43 * hackagebot Workflow 0.7.0.4 - Monad transformer for thread state persistence and workflow patterns  http://hackage.haskell.org/package/Workflow-0.7.0.4 (AlbertoCorona)
03:01:41 * hackagebot thrist 0.3 - Type-threaded list  http://hackage.haskell.org/package/thrist-0.3 (GaborGreif)
03:21:41 * hackagebot MFlow 0.0.5.3 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.0.5.3 (AlbertoCorona)
03:34:33 <akamaus> I've almost completed my TH code for deriving Storable instances and data types with known binary layout. Unfornunately, I've run into some name-related problem. The code: http://hpaste.org/74785, the compiler error message emmited for a test declaration: http://hpaste.org/74786 . Can you please give any hints?
03:51:42 * hackagebot alpha 0.9.0.1 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9.0.1 (MarcCoiffier)
03:57:55 <Sgeo> I am now really pissed off at the author of clojure.algo.monads
03:58:13 <Sgeo> It has a macro for do notation. That macro wraps the last item in an implicit return.
04:04:14 <Saizan> Sgeo: it's a macro for monad comprehensions then :)
04:06:10 <randomclown> best way to construct a tree from a [(Int,Int)] of [(id,parent)]?
04:07:29 <randomclown> maybe a Map?
04:11:11 <Saizan> with a map from nodes to childrens it should be easy
04:12:20 <Saizan> once you know which one is the toor
04:12:23 <Saizan> *root
04:18:57 <cal> ?src transpose
04:18:57 <lambdabot> transpose []             = []
04:18:57 <lambdabot> transpose ([]   : xss)   = transpose xss
04:18:57 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
04:20:12 <hiptobecubic> I don't think my definition would have been that nice
04:26:23 <kuribas> Are there cases where it is better to calculate a formula numerically than using the explicit formula?
04:27:56 <Entroacceptor> kuribas: what do you mean with "numerically"?
04:28:10 <kuribas> Entroacceptor: Using the Newton method for example.
04:28:13 <srhb> By numerical approximation.
04:28:35 <srhb> I can't think of a good reason to not use a closed form solution if you have one.
04:28:48 <srhb> Unless of course it's much more expensive than the numerical one.
04:28:53 <srhb> (For whatever precision you need)
04:31:30 <kuribas> For example, when adding and subtracting a large number in floating point, you can loose precision...
04:31:36 <Nereid> solving a large linear system is a good one
04:33:05 <Nereid> there's an explicit formula for solutions to Ax = b (like Cramer's rule if A is square), but
04:33:15 <Nereid> generally you're much better off using gaussian elimination or some other technique.
04:34:48 <Entroacceptor> and I'm still not sure what this has to do with floating point precision or haskell
04:35:20 <kuribas> Not really haskell, but programming related...
04:38:40 * Nereid ponders what the right generalization to cramer's rule is for non-square systems...
04:40:19 <kuribas> Using a closed form solution for a quadratic equation may be numerically unstable: people.csail.mit.edu/bkph/articles/Quadratics.pdf
04:40:46 <kuribas> Though their solution is to use another closed form, not a numerical approximation...
04:41:53 <kuribas> Entroacceptor: And that has to do with limited floating point precision.
04:43:36 <Entroacceptor> ah, now I see where you're coming from
04:45:19 <Entroacceptor> but if you're caring of precision limits, there are libraries for that
04:46:42 <Entroacceptor> or you can calculate the precision loss for each computation step
04:46:58 <Entroacceptor> I've done that for physics experiments, not fun :)
04:51:55 <Sgeo> > do [1,2,3] >>= \a -> [a, a]
04:51:56 <lambdabot>   [1,1,2,2,3,3]
04:52:18 <fmap> How can I convert UTCTime to ClockTime?
04:52:38 <hiptobecubic> > do [1,2,3] >>= const []
04:52:39 <lambdabot>   []
04:53:38 <solomatov> Hello. I experience the following error during cabal install.. . Does anybody know what it is?
04:53:39 <solomatov>  --env=std required
04:54:13 <solomatov> Here is gist with complete log https://gist.github.com/3727478
05:01:44 * hackagebot blaze-markup 0.5.1.1 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.1.1 (JasperVanDerJeugt)
05:01:49 <hiptobecubic> If i want to test a collection of properties, is there a better way than mapM_ ?
05:06:47 <Sgeo> > do a <- [[1, 2, 3], [4, 5, 6]]; a
05:06:48 <lambdabot>   [1,2,3,4,5,6]
05:06:58 <Sgeo> > do a <- [[1, 2, 3], [4, 5, 6]]; b <- a; return b
05:06:59 <lambdabot>   [1,2,3,4,5,6]
05:08:48 <kanedank> Hey, how would I enable something like M-. for haskell?
05:09:31 <psi`> kanedank: install hasktags
05:11:44 * hackagebot digestive-functors-heist 0.5.1.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.5.1.0 (JasperVanDerJeugt)
05:16:44 * hackagebot hakyll 3.4.2.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.4.2.0 (JasperVanDerJeugt)
05:29:30 <parcs`> kanedank: for ghci?
05:31:44 * hackagebot idris 0.9.3 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.3 (EdwinBrady)
05:40:50 <teneen> Control.Applicative is not in the standard haskell report?
05:41:44 * hackagebot ReadArgs 1.2 - Simple command line argument parsing  http://hackage.haskell.org/package/ReadArgs-1.2 (NoahEasterly)
05:42:33 <teneen> Can there exist an Haskell implementation which does not contain Applicative built-in?
05:43:20 <hiptobecubic> Isn't pretty much everything just a library of haskell functions?
05:43:25 <hiptobecubic> except IO ()?
05:44:01 <robstewartuk> Hm hackage is not generating haddock documentation for my package: http://hackage.haskell.org/package/rdf4h-1.0.0
05:44:17 <robstewartuk> Build failure on ghc 7.6: cabal: Error: some packages failed to install:
05:44:17 <robstewartuk> MissingH-1.1.1.0 failed during the building phase.
05:44:52 <robstewartuk> MissingH-1.1.1.0 has been built on hackage, but only for ghc 7.4: http://hackage.haskell.org/package/MissingH-1.1.1.0
05:44:54 <robstewartuk> ?
05:46:33 <gienah> robstewartuk: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/missingh/files/missingh-1.1.1.0-ghc-7.6.patch
05:47:27 <robstewartuk> gienah: ok... is this patch going to be applied to MissingH upstream to land in hackage ?
05:48:39 <gienah> robstewartuk: you just reminded me to open a pull request :-)
05:48:56 <robstewartuk> great! :-)
05:55:18 <gienah> robstewartuk: done: https://github.com/jgoerzen/missingh/pull/11
05:55:37 <robstewartuk> gienah: wow, great stuff thanks. Their last commit was about 8 months ago.
05:56:00 <robstewartuk> Hopefully they'll quickly merge and upload to hackage 1.1.1.1 :-)
05:57:06 <gienah> robstewartuk: yeah that would make it easier (for cabal users, me has missingh-1.1.1.0 installed on gentoo)
05:58:52 <robstewartuk> There are 81 immediate dependencies on MissingH http://packdeps.haskellers.com/reverse
05:59:05 <robstewartuk> And probably many more that recursively depend on these 81.
05:59:28 <robstewartuk> So, as ghc 7.6.1 is with us, the sooner they merge the better.
06:00:42 <gienah> robstewartuk: yeah of course that's why I need to patch it, one of the deps app-portage/hackport is used to create gentoo ebuilds of haskell packages
06:01:24 <robstewartuk> oh!
06:01:43 <robstewartuk> TIL hackport is used to create gentoo ebuilds of haskell packages
06:01:45 * hackagebot stylish-haskell 0.5.0.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.0.0 (JasperVanDerJeugt)
06:02:57 <Nereid> gienah: I didn't know you could put type annotations in patterns.
06:03:28 <robstewartuk> Nereid: which line number and module ?
06:04:03 <Nereid> robstewartuk: everywhere.
06:04:04 <Nereid> in the diff.
06:04:05 <gienah> Nereid: its the ScopedTypeVariables extension which is commonly used for Control.Exception stuff
06:04:15 <Nereid> ahh.
06:05:05 <Nereid> I need to learn how to use git properly.
06:05:32 <gienah> Nereid: as without ScopedTypeVariables I think I would have needed to do more code changes to introduce where functions with type signatures for the Control.Exception stuff, so ScopedTypeVariables seems easier
06:06:29 <Nereid> gienah: well, maybe in something like
06:06:50 <Nereid> case fn of Left (_ :: T) -> ...
06:07:09 <Nereid> you could change that to case fn :: Either T whatever of Left _ -> ...
06:07:10 <Nereid> ?
06:08:11 <gienah> Nereid: I'm not really sure
06:08:49 <Nereid> or would that still need ScopedTypeVariables
06:09:34 <gienah> Nereid: I'm not sure, but if you tried to compile it then ghc tells you if it needs ScopedTypeVariables
06:09:40 <Nereid> true
06:09:50 <Nereid> and I need sleep
06:09:50 <Nereid> :)
06:10:04 * gienah is sleepy too
07:12:41 <Inigovd> clear
07:41:47 * hackagebot darcsden 1.0 - Darcs repository UI and hosting/collaboration app.  http://hackage.haskell.org/package/darcsden-1.0 (SimonMichael)
07:49:57 <sm> hurrah
07:53:40 <nand`> :)
08:00:24 <sm> also, http://hub.darcs.net is open for general use, all welcome
08:20:47 <eikke> is there any way to install criterion with ghc-7.6.1? Looks like something is broken (during cabal install it seems to use the Paths feature, but Paths_criterion fails to compile due to `catch' not being available)
08:21:52 <Saizan> maybe with a newer Cabal/cabal-install, since Paths_$pkg is autogenerated
08:22:00 <edwardk> eikke: what verson of cabal are you using?
08:22:24 <eikke> w00ps. 0.10.2 appareantly
08:22:38 <eikke> on the other hand, I tried to update, and that failed due to 'directory'
08:22:47 <edwardk> air-2:lens ekmett$ cabal -V
08:22:47 <edwardk> cabal-install version 0.14.0
08:22:49 <edwardk> with that it works
08:23:23 <edwardk> andyeah, i don't think you can build cabal while already running 7.6.1
08:23:39 <eikke> right...
08:23:47 <edwardk> the recipe i know that works is to make sure you have a current cabal when you are running 7.4.1 and then update to 7.6.1 =/
08:23:50 <eikke> strange thing is: cabal info cabal says -> Versions installed: 1.16.0
08:24:05 <eikke> ok
08:24:14 <eikke> luckily I have a 7.4.1 around as well ;-)
08:24:28 <edwardk> yep. i get the same thing. for a while i was on something fairly ancient myself when working in 7.6.1
08:24:47 <Saizan> cabal info cabal is talking about the Cabal library
08:24:54 <Saizan> not cabal the executable
08:25:02 <edwardk> hopefully when this all gets bundled together for the platform release all of these issues will be addressed
08:25:05 <eikke> I know, will update lib and cabal-install now
08:25:14 <Saizan> don't update lib.
08:25:21 <eikke> oh
08:25:36 <Saizan> well, 1.16.0 should be the newest i guess
08:25:53 <Saizan> anyhow the problem is that your cabal executable is built against an older version of the lib
08:26:04 <eikke> cabal install --with-ghc=ghc-7.4.1 cabal-install
08:26:07 <eikke> cabal: cannot configure unix-2.4.2.0. It requires base >=4.2 && <4.4
08:27:02 <Saizan> "cabal install --cabal-lib-version=1.16.0 criterion" should work btw
08:27:28 <eikke> will try that, thanks
08:27:40 <Saizan> (assuming ghc-7.6.1 is just ghc)
08:27:45 <eikke> wow. sweet.
08:31:49 * hackagebot monarch 0.8.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.8.0.0 (NoriyukiOhkawa)
08:34:39 <ddarius> @google "A unifying review of linear gaussian models"
08:34:40 <lambdabot> http://authors.library.caltech.edu/13697/1/ROWnc99.pdf
08:34:40 <lambdabot> Title: A Unifying Review of Linear Gaussian Models
08:35:25 <ddarius> @google "Switching Kalman Filters"
08:35:26 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.32.5379
08:35:27 <lambdabot> Title: CiteSeerX — Switching Kalman Filters
08:36:49 * hackagebot xmlhtml 0.2.0.3 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.0.3 (GregoryCollins)
08:36:51 * hackagebot stringbuilder 0.2.0 - A monadic builder for multi-line string literals  http://hackage.haskell.org/package/stringbuilder-0.2.0 (SimonHengel)
08:37:11 <Saizan> eikke: cabal install -w ghc-7.4.1 cabal-install-0.14.0 seems to work btw
08:43:38 <Eduard_Munteanu> ddarius: are you reading on engineering topics lately? Signal processing, maybe control systems?
08:45:53 <ddarius> Eduard_Munteanu: I got a software defined radio recently.
08:47:15 <Eduard_Munteanu> Ah, sounds like fun.
08:49:34 <ddarius> Eduard_Munteanu: I've generally been interested in signal processing and, to a lesser extent, control theory for the last decade or so, but I've more emphasized audio and image processing, sound synthesis, and a bit of control theory.  Now I'm more focusing on digital communications, which, as you might imagine has had a lot of work done in it recently.
08:50:25 <ddarius> (Oh and electrical engineering was another motivation.)
08:50:39 <ddarius> (Earlier motivation.)
08:50:48 * ddarius <3 signal processing.
08:53:07 <ion> ditto
08:53:48 <ion> I was writing a software synthesizer years ago, but i never finished the project. I’d like to start it again some day. I did get some audio out of it already, though.
08:54:23 <ddarius> ion: There's a fairly interesting paper on square wave synthesis (i.e. additive synthesis using square waves) from some years back.
08:54:52 <ddarius> J. O. Smith has a lot of fun articles on physics-based sound synthesis.
08:54:53 <jmcarthur> does anybody know of a good package to use that has a type class for partial orderings? i have found a few, but they all seem to be for problem domains that aren't relevant to what i'm doing. i'm hoping somebody knows of a more generic package
08:55:37 <ion> ddarius: I was integrating band-limited impulse trains to implement square and sawtooth waves.
08:55:38 <ddarius> class PartialOrd a where compare' :: a -> a -> Maybe Ordering
08:55:56 <jmcarthur> that's basically what i'm looking for, yes.
08:56:09 <ion> ddarius: I’ll have to look up square wave synthesis, that sounds interesting.
08:56:11 <jmcarthur> i could define my own, but i'm hoping to be able to just reuse code
08:56:37 <ddarius> ion: It's just super, super easy to generate square waves in a digital system (either hardware or software) so they are nicer than sinusoids.
08:57:15 <Algorith> > pl \ xs ys -> sort (xs ++ ys)
08:57:16 <lambdabot>   <no location info>: parse error on input `\'
08:57:17 <ddarius> Of course, you get some high frequency noise that you don't get with normal approaches, but that's easy enough to deal with.  The output system will probably already deal with it "accidentally".
08:57:44 <jmcarthur> @pl \ xs ys -> sort (xs ++ ys)
08:57:44 <lambdabot> (sort .) . (++)
08:57:45 <ion> I keep finding articles about using additive synthesis of sine waves to generate square waves, not generating stuff out of square waves.
08:58:13 <ddarius> ion: You could have done some (crappy but not completely horrible) speech synthesis with the system you were using by IIR filtering pulse trains.
08:58:13 <Jafet> Presumably square waves are better for digital synthesizers
08:58:28 <ion> Hmm, http://smc.afim-asso.org/smc05/papers/SossioVergara/Salerno2.pdf
08:58:55 <ddarius> ion: Yes.  He has a few other related papers.
08:59:29 <ion> http://johan.kiviniemi.name/tmp/syna-20040729.ogg
08:59:41 <geekosaur> ion, last I checked you just treat it like a sine wave, then use a low pass filter to remove the harmonics.  depending on what you're doing you might need some internal low pass filtering as well
08:59:43 <jfischoff> Is there a repa WAVE or MP3 file format loader that works in an analogous way to the repa-devIL, i.e. loads the samples into a foreign c array?
08:59:54 <ion> geekosaur: Alright, makes sense.
09:00:17 <geekosaur> (a square wave is basically a sine wave with "infinite" odd harmonics at zero crossings)
09:00:20 <ion> yeah
09:02:19 <Algorith> I can't seem to comprehend why 'sort . (++)' doesnt work, is it because of partial application, where only the first of the two arguments to (++) actually gets applied before passing the result on to sort?
09:02:48 <ddarius> @src (.)
09:02:48 <lambdabot> (f . g) x = f (g x)
09:02:48 <lambdabot> NB: In lambdabot,  (.) = fmap
09:02:49 <hpc> :t sort . (++)
09:02:50 <lambdabot>     Couldn't match expected type `[a]' against inferred type `m -> m'
09:02:50 <lambdabot>     Probable cause: `++' is applied to too few arguments
09:02:50 <lambdabot>     In the second argument of `(.)', namely `(++)'
09:02:56 <hpc> :t sort .: (++)
09:02:57 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
09:03:03 <hpc> (.:) = (.) . (.)
09:03:31 <hpc> > (sort .: (++)) [1, 2, 6] [3, 5, 7]
09:03:33 <lambdabot>   [1,2,3,5,6,7]
09:04:02 <jfischoff> :t (.:)
09:04:03 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
09:04:05 <cmccann> :t ((<<<) >>> (<<<)) sort (++)
09:04:06 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
09:04:13 <cmccann> pf, (.:), who needs it
09:04:17 <ion> I take it there are no aliasing issues with the additive square wave stuff? Just generating a single square wave with “\phase -> if phase > 0.5 then 1 else -1” will sound crappy because that will result in aliasing; that’s why i used BLITs.
09:04:33 <hpc> jfischoff: it's also definable as (fmap . fmap), or "two-deep fmap"
09:04:46 * jfischoff nods
09:04:58 <ion> algorith: (f . g) x = f (g x); (sort . (++)) x = sort ((++) x)
09:06:18 <Algorith> thanks, :) I guess it should inspect the type more carefully next time
09:07:01 <jfischoff> :t (.) . (.) . (.)
09:07:02 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
09:07:20 <jfischoff> ugh Caleskell
09:08:05 <cmccann> jfischoff, all the more reason to use my "back and forth" operators!
09:08:28 <Jafet> :t let dot = (Prelude..) in dot `dot` dot `dot` dot
09:08:29 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
09:08:35 <hpc> caleskell is way more fun with an even number of (.), iirc
09:08:36 <nand`> let (<><) = (<<<) >>> (<<<) in ...
09:08:38 <ddarius> ion: You can cancel out some of the high frequency noise by simply synthesizing at a higher frequency which will be easier since there will be less computational demand, but ultimately you will need a low pass filter somewhere, though that somewhere might be the impulse response of the output system.
09:08:43 <hpc> :t fmap fmap fmap fmap fmap fmap
09:08:44 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
09:08:49 <hpc> :t fmap fmap fmap fmap fmap fmap fmap fmap
09:08:50 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
09:09:06 <ddarius> ion: Synthesizing at a higher rate allows you to use a simpler low pass filter even if you do have to explicitly make one.
09:09:08 <hpc> :t fmap fmap fmap fmap fmap
09:09:09 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
09:09:38 <otters> :t fmap (fmap fmap)
09:09:39 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f2 (f1 (a -> b)) -> f2 (f1 (f a -> f b))
09:10:54 <jfischoff> cmccann: I just can't get into <<< and >>>
09:11:43 <cmccann> how so?
09:12:00 * nand` .oO( (<>><) = (<><) >>> (<<<) -- who's to say perl should have the monopoly on fish operators? )
09:12:20 <jfischoff> just don't see a need I guess
09:12:26 <ion> ddarius: aye
09:12:32 <maukd> does perl have fish operators?
09:12:57 <cmccann> well, (<<<) is nice if you don't want to deal with hiding Prelude's (.).
09:13:13 <pr> :t (<<<)
09:13:14 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
09:13:18 <otters> so I want to create a tool that helps visualize operator precedence, and I was thinking of using Template Haskell to parse some arbitrary expression
09:13:19 <cmccann> and even then, they're occasionally useful as low-precedence composition
09:13:20 <jfischoff> yeah I guess so
09:13:25 <otters> but you can't have unbound variables in [e| ... |]
09:13:25 <cmccann> kind of like ($) as low-composition application
09:14:11 <jfischoff> otters: maybe src-exts-meta then
09:14:14 * cmccann would be inclined to use (<|) and (|>) as low-precedence application for visual similarity, but those are kinda taken
09:14:36 <otters> hmmmm
09:15:24 <cmccann> in other news, not needing : for type operators is growing on me
09:15:49 <cmccann> the type signatures in my toy linear logic implementation look a lot cleaner now!
09:16:14 * jfischoff wishes he knew more about linear logic
09:16:32 <cmccann> it's just (insert appropriate abstract nonsense here)!
09:16:35 <otters> jfischoff: awesome, that's exactly what I need
09:17:06 <cmccann> though actually, the polycategory way of looking at it lends itself very well to a haskell implementation, and is what I did
09:17:10 <otters> does this module know operator fixity?
09:17:44 <Z`> hey people. if I have 2 lists x,y, with doubles, and I'd like to calculate x^y, that is each element of x powered to respective element of y, is there a function, besides map, that I could use?
09:17:54 <pr> isn't linear logic some kind of temporal logic
09:17:55 <pr> ?
09:17:55 <jfischoff> otters: cool, never used it but there is also src-exts which is a full haskell parser
09:18:15 <Philippa> pr: it's a substructural logic
09:18:18 <cmccann> pr, you might be thinking of modal logic
09:18:24 <otters> oh, dear
09:18:32 <otters> it gets confused by a >> b >> c =<< d
09:18:40 <pr> oh i was thinking of "linear time temporal logic"
09:18:42 <cmccann> linear logic is usually described as a logic of resource use, but that's a little eh
09:18:57 <Eduard_Munteanu> Z`: zipWith
09:19:01 <Eduard_Munteanu> :t zipWith
09:19:02 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:19:25 <cmccann> the main idea being that you can't duplicate or discard things in linear logic by default
09:19:29 <otters> oh, wait, GHC itself gets confused by that expression
09:19:35 <otters> okay, looks like we're still good
09:21:49 <Z`> Eduard_Munteanu: thanks, it worked
09:22:31 <kingleoric> anyone want a wireshark lib?
09:26:50 * hackagebot hedn 0.1.5.1 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.5.1 (AlexanderBondarenko)
09:29:13 <allsystemsarego> let thrd = \(x, y, z) -> z -- Am I defining this function correctly?
09:30:57 <Eduard_Munteanu> allsystemsarego: you can also say   let thrd (x, y, z) = z
09:31:12 <allsystemsarego> Eduard_Munteanu, thanks
09:32:55 <allsystemsarego> but then I give it "thrd {5, 6, 7}" and it says "parse error on input `5'", any ideas?
09:33:03 <allsystemsarego> oh wait
09:33:10 <allsystemsarego> wrong parens
09:34:21 <Eduard_Munteanu> allsystemsarego: yep, coming from Erlang? :)
09:34:48 * Eduard_Munteanu is asking since their tuples use '{' and '}'
09:35:01 <allsystemsarego> Eduard_Munteanu, no, I just fat-fingered this one :D
09:42:37 <ddarius> cmccann: s/(insert appropriate abstract nonsense here)/the internal logic of a symmetric monoidally closed category/
09:42:45 <ddarius> If you drop symmetry, you'll get an ordered linear logic.
09:43:07 <cmccann> yeah, I couldn't recall. the polycategory thing seems a more natural way of looking at it to me.
09:43:47 <ddarius> Multicategories or polynomial categories?
09:44:08 <cmccann> neither?
09:44:30 <cmccann> a generalization of multicategories though.
09:45:32 <cmccann> also, is a symmetric monoidally closed category enough? I thought you needed a bit more than that to get linear logic.
09:46:04 <djahandarie> ddarius, you should chat with fotc about signals some time. He knows what's up. And is usually in this channel, but looks like he had to sign off.
09:46:04 <ddarius> cmccann: It depends on what else you want.  If you want exponentials, for example, you'll need a comonad.
09:46:20 <djahandarie> cmccann, you specifically get multiplicative intuitionistic linear logic.
09:46:23 <ddarius> cmccann: SMCCs will give you a multiplicative fragment.
09:46:39 <cmccann> the exponentials are sort of orthogonal, not worried about that
09:47:11 <cmccann> and yeah, I'm thinking of full "classical" linear logic other than the exponentials
09:47:53 <ddarius> Well, you can make it a *-autonomous category to get perp.
09:48:17 * cmccann is still not sure why "intuitionistic linear logic" is called that
09:50:31 <jfischoff> do lax monoidial categories correspond to a particular logic?
09:51:25 <mysticc> @hoogle unsafeCoerce
09:51:25 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:51:36 <djahandarie> What's a lax monoidal category?
09:52:19 <sixohsix> heyy edwardk, you here?
09:52:30 <edwardk> yeah, whats up?
09:53:04 <sixohsix> i have a proposal for Lens. As a noob to lenses I want to do two very simple things: make lenses, use them to get, and use them to set.
09:53:23 <sixohsix> one of these things shows up on the Hackage page: how to make them.
09:53:28 <edwardk> lens, ^., .~
09:53:46 <jfischoff> djahandaries: lax monoidal functors are Applicative Functors, I guess the category is related somehow ;p
09:53:47 <edwardk> you want it more prominent on the haddock?
09:53:51 <sixohsix> in which order do the operators work?
09:53:55 <sixohsix> edwardk: yes, please!
09:54:13 <edwardk> sixohsix: fair enough. i did a pass over the readme, btw, and it covers just that
09:54:19 <djahandarie> jfischoff, lax is a property of the functor, not of any category.
09:54:34 <jfischoff> djahandarie: ok
09:55:01 <edwardk> sixohsix: https://github.com/ekmett/lens#examples
09:55:15 <edwardk> sixohsix: that kind of starts off with how to use them without much consideration of the types
09:55:43 <jfischoff> djahandarie: so this so I thought they were a thing http://ct2010.disi.unige.it/slides/Weber_CT2010.pdf
09:56:55 <sixohsix> edwardk: oddly enough, the Hackage package page for Control.Lens links to the GitHub wiki, which doesn't have those examples. Linking to that excellent readme would be better.
09:57:04 <sixohsix> (at least examples not immediately visible)
09:57:38 <edwardk> the github wiki should have an exact copy of those examples in the Examples page. i'll make sure the main page links to them
09:57:53 <djahandarie> jfischoff, it's possible they are a thing, but it's not something I've seen before.
09:58:02 <edwardk> or, heck, its a wiki, you could do it ;)
09:58:04 * jfischoff nods
09:58:35 <ski> cmccann : because it's more like intuitionistic logic than classical logic ?
09:59:16 <sixohsix> edwardk: well I could but at this stage in my understanding i'd probably insert lies into the docs.
09:59:21 <cmccann> "classical" linear logic already seems more like intuitionistic logic than classical logic to me...
09:59:24 <sixohsix> not on purpose mind you
09:59:36 <edwardk> sixohsix: i was mostly meaning edit the main page to link to add a link to wiki/Examples
09:59:44 <edwardk> but no worries =)
10:00:09 <sixohsix> okay, so the setter operator… assuming my object is "data" and the attribute is "_foo", how do I do a set?
10:00:25 <sixohsix> i see there is also a set function… which is slightly different
10:00:32 <nand`> foo .~ bar
10:02:06 <sixohsix> oh wow
10:02:07 <sixohsix> i see
10:02:32 <sixohsix> The UML diagram on the Lens homepage tells me none of this. :P
10:02:57 <edwardk> sixohsix: set and .~ are the same operation
10:02:59 <nand`> it shows .~
10:03:14 <nand`> set, (.~) :: Setter a b c d -> d -> a -> b
10:03:19 <nand`> in the top-right box
10:03:26 <edwardk> _2 .~ "world" $ ("hello","friend")
10:03:41 <edwardk> set _2 "world" ("hello","friend")
10:04:42 <edwardk> When you see the parameters a b c d, a is the 'old value for the whole thing', c is what you can read from it, d is what you are writing back into it as the part, and b is the modified whole with the part c replaced with a d.
10:05:13 <monochrom> onoes
10:06:23 * ski would have named it `Setter a0 a1 b0 b1', then
10:07:17 <Philippa> "source, read, written, target"?
10:10:26 <ski> `Setter source target read written' afaiu
10:11:14 <Philippa> d'oh, yes, shows how much attention I'm paying. Still, the idea got across apparently
10:12:46 <ski> .. well, what you said matched the ordering `a',`c',`d',`b' in which edwardk explained them above
10:14:18 <sixohsix> (set foo "asdf" data) -- set the 'attribute' foo to "asdf" in the 'object' data (producing an updated version of data).
10:14:50 <sixohsix> now all the quoted words need to be transformed from my crappy OO speak to Haskell speak. :)
10:15:09 <maukd> data is a keyword
10:16:38 <startling> why isn't Data.Map a Category instance? couldn't it be?
10:17:15 <ski> what would the identity be ?
10:17:17 <nand`> I'm not sure how you'd write id :: Map a a
10:17:34 <startling> oh, hm, that's very true
10:18:46 <sixohsix> maukd: ah, you are right. well, that example won't work.
10:19:48 <ski> sixohsix : s/attribute/field/,s/object/value/
10:21:35 <latro`a> in principle you could add a constructor
10:21:38 <latro`a> to Map
10:21:41 <latro`a> for Id
10:21:45 <sixohsix> (set foo "asdf" v) -- set the field foo to the value "asdf" of the value v, producing an updated v.
10:21:51 <sixohsix> better
10:22:03 <latro`a> doing that would be sort of the "free identity" and then the composition is straightforward
10:22:24 <latro`a> Id . m = m; m . Id = m; m . n = ...
10:22:46 <latro`a> not sure if I'm babbling nonsensically
10:23:07 <startling> latro`a, no, that makes sense
10:23:26 <latro`a> (to clarify this would also require modifying the whole interface; for example you'd have to add "lookup x Id = Just x")
10:23:59 <startling> mhm
10:24:42 <startling> you wouldn't be able to have "union" either, though
10:24:43 <ski> (itym s/interface/implementation/)
10:26:18 <ski> i suppose you would have to be able to start from both an empty map, as well as an identity one
10:26:51 * hackagebot stm-orelse-io 0.1 - Choose between the return value of an STM operation and an IO action.  http://hackage.haskell.org/package/stm-orelse-io-0.1 (GardSpreemann)
10:26:53 * hackagebot select 0.3 - Wrap the select(2) POSIX function  http://hackage.haskell.org/package/select-0.3 (GardSpreemann)
10:30:43 <hpaste> lpvb pasted “derp” at http://hpaste.org/74791
10:30:57 <lpvb> can anyone tell me what's wrong with that ^
10:31:03 <lpvb>     Couldn't match expected type `L.ByteString'
10:31:05 <lpvb>                 with actual type `IO L.ByteString'
10:31:16 <lpvb> in first argument of hasElfMagic
10:31:39 <maukd> missing argument
10:31:48 <lpvb> ?
10:32:11 <lpvb> oh
10:32:13 <lpvb> lol
10:32:18 <lpvb> my bad
10:33:45 <td123> does anyone know of any crm / businessy type applications written in haskell?
10:33:45 <lambdabot> td123: You have 1 new message. '/msg lambdabot @messages' to read it.
10:39:57 <Mandarin> Can someone explain this sentence about common beginner problems with recursion: "lazy evaluation often shifts the burden from the stack to the heap"? Link to original article: http://fpcomplete.com/ten-things-you-should-know-about-haskell-syntax/
10:41:52 * hackagebot vacuum-graphviz 2.1.0.1 - A library for transforming vacuum graphs into GraphViz output  http://hackage.haskell.org/package/vacuum-graphviz-2.1.0.1 (AustinSeipp)
10:42:03 <nand`> common methods of implementing lazy languages store partially evaluated values on the heap
10:43:02 <monochrom> that statement is false. my http://www.vex.net/~trebla/haskell/lazy.xhtml shows you how you can shift from stack to both heap and stack
10:43:07 <Mandarin> I think I don't really understand the difference between stack and heap. Is stack a FIFO data type?
10:44:15 <akamaus> did anyone try to compile glut with ghc-7.6.1?
10:44:30 <nand`> akamaus: yes
10:44:52 <akamaus> nand`, compilation fails for me
10:45:00 <nand`> akamaus: it does for me as well :)
10:45:08 <akamaus> nand`, did you fix it?
10:45:14 <nand`> no
10:45:17 <nand`> I can give it a try if you want
10:45:32 <startling> Mandarin, it's a computer architecture / low-level C thing. the stack is an area of memory with instructions for pushing and popping to and from. The heap is everything else
10:46:08 <startling> Mandarin: typically function calls are made by pushing a "stack frame" to the stack containing local variables. when the function returns, it pops its stack frame from the stack
10:46:10 <akamaus> nand`, well, I need to do some visualization, glut is badly needed.
10:46:21 <startling> Mandarin: and thus returns to its caller.
10:46:42 <Mandarin> startling: are for example lists stored on the heap?
10:46:48 <akamaus> nand`, do you get the similar message? http://hpaste.org/74792
10:46:54 <startling> Mandarin, it depends on a lot of stuff
10:47:22 <monochrom> there are also other times when the burden is shifted from the stack to nothing
10:47:42 <startling> Mandarin: also, the stack is set up by the loader / C runtime and the heap is made with syscalls and, indirectly, malloc
10:48:04 <nand`> akamaus: oh; no, I get a dependency failure on containers; btw fixing that error is easy: just change Bits b to (Bits b, Num b)
10:48:35 <Mandarin> startling: so the stack size can change during runtime but not the heap size?
10:48:44 <nand`> akamaus: the git version builds fine for me, fwiw
10:48:44 <startling> Mandarin, no, other way around
10:48:45 <monochrom> all in all, laziness cannot be simplified to "shift burden from stack to heap". learn laziness for real.
10:49:06 <nand`> laziness has nothing to do with stacks or heaps
10:49:08 <Mandarin> startling: ah. typo thanks
10:49:09 <nand`> those are implementation details
10:49:17 <startling> yeah, that ^
10:49:42 <ski> startling : you could dynamically change the space allocated for the stack at run-time, as well ..
10:49:56 <startling> ski, yeah. it's kind of unusual, though, isn't it?
10:50:39 <nand`> akamaus: https://github.com/haskell-opengl/GLUT/commit/1fffcb7b6ede42805e72c8c10cdebc5c0f04d5d0
10:50:46 <nand`> the relevant commit, if you want it as patch
10:51:10 <akamaus> nand`, I've successfully built version from git. Thanks!
10:51:16 <Mandarin> To wrap it up; the stack stores instructions and function calls while the heap stores thunks?
10:51:20 <ski> startling : perhaps
10:51:31 <maukd> instructions on the stack?!
10:51:43 <maukd> what is this, buffer overflow exploitation 101
10:51:48 <geekosaur> Mandarin, 'wrap it up' suggests you've decided everything you've just been told is noise?
10:51:56 <akamaus> can we ping a maintainer? I guess updated package is needed.
10:51:59 <ski> Mandarin : the stack is typically for storing "what to do next"
10:52:01 <monochrom> the stack part is wrong. read my http://www.vex.net/~trebla/haskell/lazy.xhtml
10:52:19 <nand`> akamaus: it might be sensible to -r1 it with the patch included
10:52:26 <nand`> oh
10:52:28 <startling> Mandarin, no, the stack stores no instructions, just local variables for the current instructions to use
10:52:34 <nand`> uh, forgot I am not in #gentoo-haskell
10:52:49 <akamaus> nand`, -r1?
10:52:50 <ski> startling : and return adresses
10:53:00 <startling> oh, yes
10:53:01 <nand`> akamaus: I'm guessing the maintainer will submit it as glut-2.4 eventually
10:53:27 <monochrom> everything I said is noise because I did not include destination nicknames
10:54:32 <kingleoric> anyone here play with wiresharek?
10:54:40 <kingleoric> wireshark
10:54:43 <kingleoric> anyone would like haskell bindings?
10:55:02 <jfischoff> what's wireshark?
10:55:24 <nand`> iirc it's some utility for analyzing network packets at a low level
10:56:30 <monochrom> GHC 7.4 grows stack lazily
10:56:45 <Mandarin> ski: I'm sorry for the confusion, but I don't understand what startling meant with: "the stack is an area of memory with instructions for pushing and popping to and from"
10:57:21 <nand`> Mandarin: it's a machine-specific hardware detail, really
10:57:54 <monochrom> also, unused stack is GCed. both this and growing have a coarse granularity, default 32KB
10:58:40 <monochrom> except, there is a default cap, 8MB, but you can change that
10:59:00 <monochrom> also, it's 8MB per thread. every thread enjoys its own stack
10:59:08 <luite> monochrom: is chunked stack just about allocation? or does it also make minor gc faster?
10:59:23 <nand`> monochrom: OS thread or GHC thread?
10:59:28 <monochrom> also, thread means green thread, the forkIO kind. you can have 10000 green threads all sharing the same OS thread
10:59:28 <luite> ghc thread
10:59:59 <monochrom> I don't know whether it makes minor gc faster. probably not.
11:00:33 <luite> monochrom: do you know anything else about the ghc gc? i'm wondering how to deal with updated thunks that point from the older generation to the newer
11:00:56 <monochrom> I don't know anything about GHC GC
11:01:51 <luite> hm guess i'll ask in #ghc later
11:02:13 <monochrom> anyway, as Fate pulls pranks on you, stacks are obtained from the heap, for GHC
11:03:09 <monochrom> you don't need laziness to shift the burden from stack to heap. you just need your own RTS. you can do it for C.
11:03:30 <kobsu> kingleoric: what you can do with wireshark lib? i have only used the software available for windows
11:03:34 <maukd> (C has neither stack nor heap)
11:04:03 <kingleoric> i just ate a family pizza. not good :)
11:04:16 <monochrom> sure. but you can do it for your own implementation of C
11:05:50 <ski> Mandarin : i'm not quite sure either what startling meant by that ..
11:07:23 <sixohsix> is there a clever combination of "over" and "mapped" to do an update in the IO monad. modify a field with (a -> IO a)?
11:07:30 <maukd> "there are instructions that push/pop things on the stack"
11:08:17 <paolino> @hoogle over
11:08:17 <lambdabot> Control.Exception.Base Overflow :: ArithException
11:08:17 <lambdabot> Control.Exception Overflow :: ArithException
11:08:17 <lambdabot> Control.OldException Overflow :: ArithException
11:09:32 <sixohsix> over is from Control.Lens, lens package.
11:10:07 <edwardk> sixohsix: you probably want traverse
11:10:13 <edwardk> sixohsix: thats what its for ;)
11:10:21 <edwardk> sixohsix: note 'traverse' from Data.Traversable is a value traversal ;)
11:10:58 <edwardk> and rather than mapped you can always use %%~ on a traversal.
11:11:34 <edwardk> traverse.traverse %%~ putStrLn $ [["hello","world]]
11:11:48 <edwardk> note that %%~ is just 'id'
11:11:52 * hackagebot Shellac-haskeline 0.2.0.2 - Haskeline backend module for Shellac  http://hackage.haskell.org/package/Shellac-haskeline-0.2.0.2 (JudahJacobson)
11:13:14 <sixohsix> yes, i probably do want that.
11:13:41 <sixohsix> Haskell is like Lego except that every piece has differently shaped nubs on the bottom.
11:14:05 <merijn> If I want to do curses like stuff what's the best haskell library for that?
11:14:34 <merijn> sixohsix: For a second I thought you meant the Lego proof assistant and was really confused :p
11:14:40 <nand`> there are a few curses bindings, I don't know which is the best but iirc they all have some issues; there's also vty which attempts to provide a pure-haskell alternative
11:14:52 <sixohsix> merijn: I am using hscurses right now. It is not exactly great, but it does work.
11:15:09 <sixohsix> provided you know that only wAddStr will support unicode, and all the others are pure evil.
11:15:09 <nand`> some comparisons here https://cheater.posterous.com/haskell-curses
11:15:19 <merijn> nand`: I don't specifically want curses, I just want to do GUI stuff in the terminal, essentially
11:15:35 <sixohsix> so then you want curses :)
11:15:55 <sixohsix> there is a pure haskell one called vty but its interface is a bit… umm, interesting.
11:16:14 <nand`> besides the ones on that page there's also ncursesw which I think doesn't have its own package, I'm not exactly sure if it's a complete curses binding or just a partial binding intended to augment one of the others
11:16:15 <merijn> sixohsix: Well, if nand` says vty is a grounds up haskell one I can at least take a look
11:16:47 <nand`> afaik none of the above are entirely as easy to use / high level as I'd like
11:17:09 <merijn> bah
11:17:21 <merijn> iow I might just have to roll my own :p
11:17:22 <nand`> I want something like gloss :)
11:18:13 <nand`> but some of the points in http://www.haskell.org/haskellwiki/Library/VTY sound interesting
11:20:33 <nand`> there's also http://hackage.haskell.org/package/vty-ui but I think I read mixed things about that
11:21:31 <akamaus> how to convert Float to GLFloat?
11:22:04 <maukd> realToFrac?
11:22:30 <akamaus> maukd, yep! :)
11:26:58 <merijn> sixohsix, nand`: The wiki page for VTY actually sounds the most promising, afaict
11:27:57 <startling> what lens do I do to read/modify a Maybe value?
11:28:55 <nand`> traverse
11:28:55 <edwardk> startling: traverse works for updating it, ^? can get a maybe back when you have a traversal, there are lots of things you can do with maybe
11:29:10 <sixohsix> merijn: yeah… but all those underscores??
11:30:21 <merijn> sixohsix: It's not that bad (mind you, I come from Python/C background, so I'm used to that style :p)
11:30:55 <sixohsix> merijn: I also come from a Python background, but I know those underscores just ain't right.
11:31:24 <sixohsix> but let me know if it goes well.
11:31:44 <sixohsix> my curses code is highly compartmentalized so that some day I can replace it with something less horrible.
11:32:21 <startling> edwardk, nand`: thanks
11:32:41 <merijn> Now I just need to find a nice FRP library to use it with :p
11:33:07 <startling> sixohsix: I know the feeling. :(
11:33:20 <merijn> Is netwire the latest/greatest FRP library?
11:35:37 <sixohsix> (traverseOf field function value), that's what I want! cool.
11:35:54 <nand`> traverseOf = id
11:37:33 <sixohsix> ...........what?
11:39:13 <nand`> hmm
11:39:24 <nand`> a %%~ b %%~ c $ d %%~ e %%~ f $ g
11:39:35 <nand`> screw parentheses!
11:40:45 <hpaste> MrLemao pasted “Using simple logger monad” at http://hpaste.org/74796
11:41:34 <nand`> usually you'd have runLogger as the field name and execLogger = snd . runLogger
11:41:51 <mrlemao1> I don't understand why : runLogger $ record "Hi Mom" >> record "Bye Mom"   is able to concat the two msgs in ((),["Hi Mom","Bye Mom"])
11:42:08 <mrlemao1> isnt the pure value ignored with >> ?
11:42:21 <nand`> (>>) doesn't ignore its left hand side
11:42:40 <nand`> what you're ignoring is the ()
11:43:24 <mrlemao1> I see.
11:45:19 <maukd> "Hi Mom" isn't the pure value
11:46:04 <mrlemao1> So record "Hi Mom" will return Logger (), which wraps ((), ["Hi Mom"]). () is the pure value and the param that is ignored in (>>) ?
11:46:31 <latro`a> merijn, to my knowledge netwire is the most robust for the stuff it's for but others are better at other stuff
11:46:40 <latro`a> and in particular reactive banana is the place to be for FRP GUIs
11:47:22 <nand`> I have yet to figure out how to apply netwire to real world problems other than cool hello world demos
11:49:01 <coyoda> How do I get around this error?
11:49:03 <coyoda> cabal: Couldn't read cabal file "iteratee/0.8.9.3/iteratee.cabal"
11:49:14 <mrlemao1> Ok, so I want to "see" this. How do I print the param to >>= e.g.:  record "Hi Mom" >>= \x -> do show x; return x
11:50:03 <merijn> latro`a: So what *is* the stuff that netwire is for? :p
11:50:05 <maukd> you look at the type
11:50:28 <monochrom> what is "record"? also, I don't understand the question
11:50:34 <nand`> monochrom: record = tell
11:50:49 <mrlemao1> monocrhrom: see http://hpaste.org/74796
11:50:59 <monochrom> "show" seems to be ill-present there
11:51:12 <nand`> it is; I think he wanted record (show x)
11:51:39 <mrlemao1> yes, I am coming from java so I was trying to trace the execution of this to see what is going on. Not sure the approach that is taken in haskell to trace this
11:52:10 <monochrom> don't trace execution. or evaluation. not for this problem.
11:52:27 <nand`> personally, I wouldn't call anything in haskell ‘execution’ other than what the RTS does with main
11:52:51 <merijn> mrlemao1: What do you expect "do show x; return x" to do?
11:53:06 <merijn> Because that looks like a type error to me...
11:53:24 <monochrom> do { let {x = "Hi Mom"}; record x; return x } ?
11:53:30 <nand`> > do show 3; return 'a'
11:53:31 <lambdabot>   "a"
11:53:36 <nand`> > do show 3000; return 'a'
11:53:37 <lambdabot>   "aaaa"
11:53:52 <monochrom> or, if you want to use >>= ...
11:54:12 <monochrom> let {x = "Hi Mom"} in record x >>= \_ -> return x
11:54:59 <mrlemao1> merijn: there is a hole in my thought process with basic monadic functions that I am trying to figure out. I read (>>) as ignore the pure value wrapped in the monad but I don't see how the [] is passed between record "Hi Mom" >> record "Bye Mom"
11:55:37 <latro`a> what monad is this?
11:55:40 <monochrom> I don't understand why "record s = Logger ((), [s])"
11:55:40 <mrlemao1> I see record "Hi Mom" returning "record s = Logger ((), [s])"
11:55:43 <nand`> latro`a: Writer [String]
11:55:50 <merijn> mrlemao1: All values are pure, >> does not ignore the first value passed to it
11:56:22 <mrlemao1> merijn: humm, I guess I need to read the impl of (>>) again…
11:56:36 <latro`a> I think you're misunderstanding what the "value" and the "effect" are in Writer
11:56:39 <monochrom> I guess I understand now
11:56:43 <merijn> mrlemao1: "a >> b" is "a >>= \_ -> b"
11:57:11 <merijn> mrlemao1: So the value is not used, but not ignored, because >>= still inspects a
11:57:20 <nand`> though, perhaps confusingly, pure x >> y = y
11:57:22 <monochrom> "record s1 >>= \_ -> record s2"  the >>= will do the concatenation
11:57:28 <nand`> maybe that's what you meant by “ignores the pure value”
11:57:54 <monochrom> screw >>. it's just a glorified >>=
11:58:25 <mrlemao1> If I execute: runLogger $ record "Hi Mom" >> record "Bye Mom" I get : ((),["Hi Mom","Bye Mom"]) but how the ["Hi Mom"] was concatenated with [ "Bye Mom"]?
11:58:36 <mrlemao1> that's the confusing part to me
11:58:40 <nand`> because ++
11:58:49 <nand`> in line 16
11:59:06 <parcs`> mrlemao1: expand the definition of >>=
11:59:11 <pikhq> mrlemao1: The result of 'record "Hi Mom"' is simply not *fed to* 'record "Bye Mom"'.
11:59:24 <pikhq> mrlemao1: This is different from it being ignored.
11:59:40 <monochrom> you're looking at ["hi mom"] ++ ["bye mom"]
11:59:44 <mrlemao1> I see.
11:59:49 <pikhq> mrlemao1: You can view it kinda like record("Hi Mom");record("Bye Mom"); in a C-esque language.
12:00:22 <pikhq> With >>= it'd be vaguely like x = record("Hi Mom");record("Bye Mom", x);
12:00:39 <monochrom> record "hi mom" = Logger ((), [s])
12:00:51 <mrlemao1> so (a, w) = execLogger m extracts the value from the monad, then n      = k a  is never executed because I am using (>>), then  (b, x) = execLogger n extracts the value from the right side and finally it combines both with (++)
12:01:18 <monochrom> er, record "hi mom" = Logger ((), ["hi mom"]).  see the () there?
12:01:30 <nand`> it comes out to something like:  let (a, w) = ((), ["Hi Mom"]); (b, x) = ((), ["Bye Mom"]) in (b, w ++ x)
12:01:53 <monochrom> so, Logger ((), ["hi mom"]) >>= \y -> ... y is ()
12:02:12 <mrlemao1> I see. There is a layer of "io" there between the underlying value and the exposed Logger a that performs this
12:02:14 <monochrom> and of course you want to ignore () because it is useless
12:02:25 <nand`> there is a layer of "io" <- what?
12:02:35 <mrlemao1> sorry I didnt mean real IO
12:02:49 <mrlemao1> hides by adding/removing
12:03:18 <monochrom> I think at this stage it is premature to "explain in your own words"
12:03:32 <mrlemao1> :-) well, I have to start somewhere
12:03:49 <monochrom> yes, start with actual code and actual results
12:04:05 <monochrom> actual experiments and actual observations
12:04:33 <mrlemao1> nand`: earlier you mentioned runLogger vs execLogger. What was that?
12:04:34 <monochrom> use observations to refute all of your hypotheses
12:05:05 <mrlemao1> monochrom: yes, wise advice
12:05:08 <nand`> mrlemao1: I'm just noting that the convention used by other monads quite similar to the Logger from your paste use ‘run-’ for what you call ‘exec-’, and ‘exec-’ for something else.
12:05:17 <nand`> but this is a convention only
12:05:53 <monochrom> the process of learning is the process of finding out you are wrong here, wrong there, wrong again, wrong subtlely, wrong also here... after a million iterations, you get it
12:06:06 <mrlemao1> nand`: but that is also important I think specially to understand other code. And what is the usual meaning for exec- and run- why do I need them? To inspect I monad?
12:06:37 <nand`> I generally find it easier to read a book to learn what things are actually like rather than making my own guesses and observations and drawing false conclusions constantly
12:07:16 <mrlemao1> I was actually following Real World Haskell.
12:07:33 <monochrom> actually, I read a book, too
12:08:58 <mrlemao1> sorry to bother with another question, but if I am experimenting with ghci how can I see the implementation of >>=, for instance, in other modules/libraries?
12:09:11 <mrlemao1> do I need to find the sources out of band?
12:09:20 <monochrom> book fast-forwards you. spares you a lot of "obviously" wrong hypotheses. that's all it can do. but a book is finite. it cannot be complete. you will still have infinitely many wrong hypotheses
12:09:29 <startling> mrlemao1: yeah, I think so.
12:09:41 <startling> mrlemao1: the other thing you could do is have a local lambdabot and use @src
12:09:48 <startling> but lambdabot seems difficult to set up
12:09:59 <startling> @src Maybe (>>=)
12:09:59 <lambdabot> (Just x) >>= k      = k x
12:10:00 <lambdabot> Nothing  >>= _      = Nothing
12:10:03 <nand`> lambdabot was straightforward to set up here
12:10:07 <nand`> I just installed it and that was it
12:10:50 <nand`> @src Writer (>>=)
12:10:50 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:11:18 <monochrom> also, whatever the book tells you, you should still design experiments to try to refute it. when you see that the experiments do not refute it despite trying, you learn finally
12:12:52 <mrlemao1> monochrom: indeed re: a book. Quite often we rush through books don't actually solidify the concepts correcting the misconceptions as you pointed out.
12:13:04 <merijn> mrlemao1: One of the easier ways to do that is to search Hoogle and click the "source" link for the function you're interested in
12:14:13 <TheBrayn> https://gist.github.com/211954962ed4c89934eb polymorphism.hs:18:19: parse error on input `putStrLn' <- What's wrong here?
12:14:22 <}Dimoni> hi there
12:14:41 <shachaf> TheBrayn: The "then" part of the "if" isn't in a "do" block.
12:15:05 <TheBrayn> how do I put them in the do block?
12:15:26 <shachaf> "do" is the usual way to do that.
12:15:35 <mrlemao1> cabal install lambdadot … "The following packages are likely to be broken by the reinstalls"  I guess I have to use cabal-dev or something like that
12:15:44 <nand`> let me just point out that your way of doing things is very non-idiomatic
12:15:47 <nand`> (re: TheBrayn)
12:16:11 <nand`> instead of checking to see if argv is nonempty and then extracting its head, it's much cleaner (and safer!) to pattern match
12:16:13 <monochrom> after "then", you need a new "do"
12:16:24 <TheBrayn> nand`: yeah might be
12:16:33 <TheBrayn> but I don't know ho pattern matching works yet
12:16:51 <shachaf> foldr f z l = if null l then z else f (head l) (foldr f z (tail l))
12:16:59 <monochrom> have you seen "case argv of [] ->" ?
12:17:34 <nand`> case argv of num:_ -> putStrLn (sayMe num); [] -> hPutStr stderr ...
12:18:07 <monochrom> "if null l then z else f (head l) (foldr f z (tail l))" happily has subtlely different strictness from the usual foldr definition
12:18:20 <monochrom> oh wait, no, same strictness, nevermind
12:19:26 <merijn> hmm, I'm still unsure what netwire application is, is it for generic FRP too or should I stick with reactive banana?
12:20:00 <nand`> might want to ask mm_freak_
12:20:06 <Sgeo> I am starting to think that everyone who attempts to copy ideas from Haskell into Clojure is an idiot.
12:20:11 <monochrom> perhaps netwire and reactive banana cover a lot of common applications?
12:20:31 <Sgeo> The equivalent of Just "Nothing" is not a good way to define Nothing
12:20:33 <nand`> <elitist>Sgeo: exactly, why are they using clojure?</elitist>
12:20:42 <monochrom> I mean, your question sounds like "if one lib covers this application, then another lib does not"
12:20:50 <merijn> Sgeo: Save time and generalise that statement to "I am starting to think that everyone is an idiot."
12:20:52 <coyoda> How do you get around the corrupted iteratee cabal file?
12:21:19 <mrlemao1> nand` monochrom merijn latro `a: thanks for your help here!
12:21:28 <monochrom> you're welcome
12:22:10 <merijn> monochrom: Someone earlier mentioned "I think netwire is good for what it's good at", but I'm unsure what that is... :p
12:22:28 <monochrom> wait, are you saying that some clojure people are mapping haskell's (Nothing) to clojure's (Just "Nothing")? complete with the string part?
12:22:46 <monochrom> ha, I wouldn't give such a tautological answer
12:22:53 <Sgeo> monochrom, not a string, a symbol
12:23:00 <merijn> monochrom: So I'm a bit unsure what the current state of the art FRP library I should pick is :p
12:23:29 <monochrom> does netwire's haddock mention some applications?
12:23:29 <nand`> I wasn't aware there was one state of the art FRP library; I always thought there were multiple with different strengths
12:23:38 <Sgeo> This person defines a Maybe monadic value as a container, essentially. If the container contains ::nothing, the monadic value is treated as Nothing, otherwise, it's Just valueinthecontainer
12:24:44 <nand`> I want to see him port Either a b
12:24:47 <monochrom> symbol is better than string. I'll write 'Nothing for the symbol version. so they are doing (Just 'Nothing)?
12:24:57 <}Dimoni> bye!
12:25:11 <geekosaur> coyoda, it's not currupt as I understand it, just requires a newer version of cabal-install
12:25:16 <Sgeo> yeah
12:25:44 <monochrom> they are not understanding that Maybe is like a bounded List
12:26:18 <merijn> nand`: Maybe, but I don't see a good comparison/survey anywhere
12:26:26 <nand`> me neither
12:26:37 <nand`> I've never used FRP beyond running demos
12:26:49 <monochrom> even idiots do not model the empty list as "cons nothing". even idiots who keep harping the "container" rhetoric. List is a container too, and it still can be "nil".
12:28:33 <Sgeo> And algo.monads, the more popular monadic library, basically treats non-nil values as Just-y and nil as Nothing
12:28:58 <Sgeo> My first impression of the other thing, the one I described before, was that it gets it right, but it doesn't
12:29:05 <startling> @pl \x -> view (lookup k) x >>= hushRight
12:29:05 <lambdabot> (hushRight =<<) . view (lookup k)
12:32:18 <monochrom> well, I sympathize with you who have to work with dysfunctional definitions in clojure and everywhere
12:38:31 <Sgeo> I think.... it might not actually be a problem
12:38:40 <Sgeo> (algo.monads is still a problem)
12:39:36 <Sgeo> After all, the fact that it's a container containing a symbol could be considered an implementation detail, as long as that symbol isn't usable outside of that context
12:40:20 <shachaf> The question is whether you can distinguish Nothing from Just Nothing.
12:40:36 <Sgeo> I believe you can
12:42:27 <nand`> or, in this case, Nothing from Just ::nothing
12:43:08 <Sgeo> Nothing _is_ Just ::nothing
12:43:20 <Sgeo> That's how Nothing is implemented here
12:43:56 <nand`> so clojure Maybe's version of  return ::nothing >>= f  violates monad laws ?
12:44:31 <Sgeo> It would, yes, but if ::nothing is considered to be usable only by the library, and not something that users can provide
12:44:43 <Sgeo> Then return ::nothing shouldn't be considered to be writable
12:45:33 <coyoda> geekosaur: Hmmm, yeah I am using an old version.  But the newer version of cabal-install won't install for some reason.
12:45:44 <coyoda> It wants an old version of unix and base.
12:47:37 <coyoda> Oh, never mind.  When I specify the version explicitly it looks like it's working.
12:50:01 <Sgeo> If someone did the equivalent of fromJust Nothing, then used that result, things would break.
12:50:23 <Sgeo> But, fromJust Nothing is generally break-y anyway
12:51:02 <Sgeo> In algo.monads, return for Maybe is id
12:51:05 <Sgeo> I wish I was joking
12:53:44 <johnw> you know what I just realized I'm grateful for?  Haskellers don't use the words "design pattern"
12:54:05 <yukifag> Hello everyone. Is it possible to create (with ghc) static library that has some internal state invisible from outside?
12:54:20 <johnw> yukifag: yes, it's possible
12:57:03 <yukifag> johnw: Can you give me link? Is it a common technique or hacking needed?
12:57:18 <johnw> maybe you can elaboratie a bit more on your design
12:58:51 <yukifag> johnw: I want to create some 'computation core' in haskell linkable with c.
12:59:16 <johnw> so you want a collection of pure functions that are callable from C?
12:59:35 <johnw> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
13:00:34 <yukifag> Unfortunely they aren't pure. This problem requeres some state.
13:01:13 <johnw> then you may need to use unsafePerformIO
13:02:36 <merijn> @quote design.patterns
13:02:37 <lambdabot> PeterOtten says: [re: design patterns] When most of your code does nothing in a pompous way that is a sure sign that you are heading in the wrong direction.
13:02:41 <merijn> aww...
13:02:43 <merijn> wrong quote
13:02:51 <merijn> @quote emu design.patterns
13:02:51 <lambdabot> emu says: design patterns are what you choose for wallpaper and carpets
13:02:55 <merijn> :)
13:03:41 <merijn> yukifag: Would it be acceptible to have an extra argument on the C side representing your state?
13:03:59 <yukifag> john: I can't figure out how unsafePerformIO may help.
13:04:20 <yukifag> john: Yes it is OK.
13:04:26 <shachaf> That the problem requires state doesn't mean that it should be invisible and global.
13:05:02 <merijn> yukifag: You could store your state in an IORef/MVar/whatever, then convert it to a StablePtr and require C to pass you that StablePtr on every call
13:05:57 <yukifag> merijn: OK, seems reasonable.
13:06:00 <johnw> huh, this is interesting: yukifag: in your libraryhu
13:06:04 <johnw> http://hackage.haskell.org/packages/archive/global-variables/1.0.1.1/doc/html/Data-Global.html
13:06:47 <merijn> yukifag: Check out Foreign.StablePtr, it has a functions to get a StablePtr for arbitrary structure and functions to cast to/from void pointers that you can pass to C and back
13:07:17 <monochrom> perhaps you don't even need IORef etc
13:07:32 <mm_freak_> edwardk: once again i thought about how to represent vector spaces, but i'm more and more concluding that a Num constraint would actually be the best option
13:07:47 <mm_freak_> because the comonad itself doesn't actually need the vector space properties
13:07:50 <merijn> monochrom: True, it depends on his usecase. Although you probably don't want to continually get/use different pointers for the state
13:07:57 <johnw> I guess Haskell doesn't offer a way to register a value as "never to be GC'd", and then give you a way to grab a handle to that value from within a different set of IO actions
13:08:12 <merijn> johnw: That's exactly what StablePtr does :p
13:08:13 <mm_freak_> @tell edwardk once again i thought about how to represent vector spaces, but i'm more and more concluding that a Num constraint would actually be the best option…  because the Space comonad itself doesn't actually need the vector space properties
13:08:13 <lambdabot> Consider it noted.
13:08:13 <johnw> if you could, he wouldn't need state passing
13:08:15 <johnw> aha
13:08:28 <yukifag> merijn: OK, this is suitable. Thanks a lot.
13:09:30 <monochrom> I understand the convenience of singleton mutable variable. I sometimes do it too. haskell or c or whatever. the consideration is universal
13:09:32 <johnw> merijn: on the next call into my library, how do I gain access to that stableptr again?
13:10:31 <monochrom> then I learned something from the DNS library. it used to have singleton mutable variable for config options, too. then, one day, it became unreliable in the presence of multi-threading!
13:10:46 <edwardk> mm_freak_: i usually do make them instances of Num
13:10:46 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
13:10:55 <edwardk> @messages
13:10:55 <lambdabot> mm_freak_ said 2m 41s ago: once again i thought about how to represent vector spaces, but i'm more and more concluding that a Num constraint would actually be the best option… because the Space
13:10:55 <lambdabot> comonad itself doesn't actually need the vector space properties
13:11:05 <Heffalump> I'm trying to make darcs into a library at the moment and globals are making it really painful
13:11:25 <johnw> yukifag: one way to avoid state passing, albeit ugly, would be to use a C helper library that is linked *in* your Haskell library, which manages a global state that holds onto a StablePtr
13:11:28 <monochrom> so, the library received an overhaul. now, every entry point requires you to provide a pointer to a record of config options
13:11:36 <mm_freak_> edwardk: usually?  so you implemented Space(T)?
13:11:41 <JonathanDoe> Open Condom Star!
13:11:46 <JonathanDoe> Not a Sauna Air!
13:11:55 <merijn> johnw: You need to explicitly pass it from C, that's the usual approach
13:11:55 <JonathanDoe> Not a Sauna Air!
13:11:56 <JonathanDoe> Not a Sauna Air!
13:11:59 <monochrom> so! yes! every procedure requires you to passing in state
13:12:01 --- mode: ChanServ set +o monochrom
13:12:10 <johnw> so, my C-lib-in-Haskell-lib trick would avoid that
13:12:18 <monochrom> I guess I'm too slow
13:12:23 <johnw> because you can give the state a persistant name in C
13:12:33 <johnw> c'get_global_state :: StablePtr a
13:12:37 <Heffalump> johnw: there are hacks you can use in Haskell to do it too (involving unsafePerformIO and NOINLINE)
13:12:40 <johnw> c'set_global_state :: StablePtr a -> IO ()
13:12:54 <yukifag> johnw: That was my first idea. I didn't like it much :)
13:13:04 <johnw> Heffalump: that's where I was getting at with my unsafePerformIO comment, I just didn't know exactly how :)
13:13:08 <Heffalump> but unless you're doing something that wraps a genuinely global resource, IMO it's a very bad idea
13:13:23 <monochrom> so, I'm saying, it's fashionable to passing around state explicitly. in C. not just Haskell.
13:13:31 <Heffalump> http://www.haskell.org/haskellwiki/Top_level_mutable_state
13:13:32 <monochrom> s/passing/pass/
13:13:38 <johnw> ah, thank you!
13:13:56 <johnw> I love knowing that these tricks exist, and then finding ways to never use them :)
13:14:18 <maukd> @hackage reflect
13:14:18 <lambdabot> http://hackage.haskell.org/package/reflect
13:14:40 <maukd> @hackage reflection
13:14:40 <lambdabot> http://hackage.haskell.org/package/reflection
13:17:16 <monochrom> and now, I would like to break johnw's heart by saying:
13:17:25 <monochrom> the State-Passing Design Pattern!
13:17:56 * merijn throws eggs at monochrom
13:19:50 <monochrom> customers who bought that also like: the Continuation-Passing Design Pattern!
13:20:38 <merijn> The "Do Everything In IO" Pattern :p
13:21:29 <monochrom> more seriously, credit must go to hpc for: https://plus.google.com/102208456519922110915/posts/LXxRByiCMV4
13:21:32 <merijn> (That's the pattern I end up using a lot xD)
13:22:33 * ski . o O ( The Unabstracted-Abstractions Design PAttern ! )
13:23:11 <merijn> The "Floral Pattern" design pattern :p
13:23:42 <johnw> Design Paradigms are next
13:24:44 <sixohsix> Metapatterns.
13:24:57 <johnw> hmm.. I'm using hsenv as follows: hsenv --ghc=$HOME/dl/ghc-7.6.1-x86_64-apple-darwin.tar.bz2 --dont-share-cabal-cache
13:24:58 <sixohsix> What patterns are found in good patterns?
13:25:04 <nand`> Is there an example of something useful that can be done with type-level lists?
13:25:05 <johnw> but whenever I try to install any package, I get:
13:25:10 <hpaste> hiptobecubic pasted “Why can't QuickCheck generate these?” at http://hpaste.org/74798
13:25:10 <johnw> Bad interface file: /Volumes/Data/Products/tmp/ghc76/.hsenv_ghc76/ghc/lib/ghc-7.6.1/base-4.6.0.0/Prelude.hi
13:25:11 <johnw>         mismatched interface file versions (wanted "7042", got "7061")
13:25:24 <hiptobecubic> It just hangs forever.
13:25:25 <johnw> seems like it's still trying to use stuff from GHC 7.4.2?
13:25:48 <hiptobecubic> If i remove the "complexEnough" combinator then it works, but obviously doesn't do what i want
13:25:59 <merijn> nand`: I'm working on one :p
13:26:07 <typoclass> sixohsix: all the abstractions in haskell are the proper ones. all the abstractions in java are ridiculous clownery.
13:26:23 <dncr> i can't express how angry i am that cabal-install is not designed so that you can always reinstall your way forward out of DLL hell.
13:26:34 <merijn> nand`: I don't have time to extract the enlightening bits right now, but if you remind me somewhere this week I'll write an example for you based on what I'm doing
13:27:11 <nand`> the HList example from the GHC docs looks like ‘heterogeneous list’ but I can't seem to, eg., write a length function
13:27:18 <sixohsix> typoclass: Java patterns are a good way to convince bad programmers to use abstraction without scaring them.
13:27:34 <hiptobecubic> sixohsix, no they aren't
13:27:40 <sixohsix> It would be better to make them better programmers tho.
13:27:42 <sixohsix> No?
13:28:16 <hiptobecubic> they are a good way to get bad programmers to write a lot of code that is totally contrived and senseless and performs like ass
13:28:20 <typoclass> sixohsix: sure, in case it wasn't clear, my comment was sarcastic
13:28:36 <hiptobecubic> good programmers can use them just fine, but they didn't need you to tell them that
13:29:01 <johnw> dncr: I'm considering getting Nix or 0install working here, just so I can abandon cabal-install
13:29:12 <dncr> johnw: mm
13:29:25 <sixohsix> I guess im lucky enough to never have worked with bad programmers, then.
13:29:29 <johnw> i mean, there ARE alternatives
13:29:41 <johnw> https://github.com/MarcWeber/nixpkgs-haskell-overlay
13:29:42 <nand`> I use portage myself
13:29:55 <dncr> johnw: i will check it out
13:30:24 <dncr> out of the hackagedb and into the street
13:30:28 <johnw> the only downside to Nix is that it wants to build/install the non-Haskell dependencies using nix too
13:30:44 <nand`> and portage has been exceptionally good at not breaking everything when it comes to haskell
13:32:42 <johnw> link to portage?
13:32:46 <johnw> @google haskell portage
13:32:47 <lambdabot> http://www.haskell.org/haskellwiki/Gentoo
13:32:47 <lambdabot> Title: Gentoo - HaskellWiki
13:33:12 <johnw> ah, I'm not using Linux
13:33:41 <nand`> portage is written in python; though I'm not terribly sure how cross-platform it is
13:34:06 <nand`> if you're hugely adventurous you could try porting it to windows for haskell usage though ;)
13:34:18 <johnw> no
13:34:29 <johnw> i don't like enormous jobs that just "get me back to zero"
13:34:56 <dncr> well cabal-install loves them
13:35:04 <johnw> lol
13:35:17 <johnw> i've rebuilt "world" I think 9 times this week
13:35:49 <johnw> i now use cabal-dev almost everywhere, just so I can keep working when my main cabal breaks
13:36:09 <johnw> the other day I had a real whack-a-mole problem
13:36:22 <johnw> X couldn't find Y-<some hash>
13:36:31 <johnw> so I rebuilt X, and then Y couldn't find Z-<some hash>
13:36:40 <johnw> when I rebuilt Z, then X couldn't find Y-<some hash> again
13:36:41 <johnw> it was crazy
13:36:46 <dncr> i'm in the middle of a back-and-forth right now
13:37:08 <nand`> I've never run into breakage like that, despite daily exhibiting the sort of behavior that I'm told would lead me into them with great enthusiasm
13:37:24 <nand`> and I only rebuild world when updating GHC
13:37:30 <typoclass> johnw: i had that once as well! don't recall how i solved it, i think i uninstalled a great deal of packages, then reinstalled them
13:38:03 <typoclass> cabal is not in a good state :( i wonder if it's getting worse or better over time. somebody told me the other day that it's currently making a step up
13:38:07 <Cale> johnw: It helps to give all the packages on the commandline to cabal install at once.
13:38:40 <schovi> Hello. How to simply in haskell do following. Download zip file from given url, unzip it and with iconv convert to utf8. In terminal i can do `curl http://forms.mpsv.cz/uir/files/Verze_42/ADR00446.ZIP | gzip -d -c | iconv -f CP1250 -t UTF8 > xxx.txt`
13:38:43 <schovi> thanks !
13:38:48 <johnw> Cale: it's knowing which list to give that's the real problem
13:39:22 <johnw> schovi: are you asking us to write the program for you?
13:39:25 <Cale> johnw: Yes, but at least, once you've gone through that whack-a-mole loop once, you have another option :)
13:39:26 <nand`> portage comes with a tool, ‘haskell-updater’ that searches for any packages with rebuilt deps or ones built against older versions of GHC and automatically rebuilds them, in the correct order
13:39:34 <dncr> i have two local packages that are not on hackage.  when i install one it breaks the other one.
13:39:35 <nand`> I imagine that cabal-install augmented with haskell-updater would be nearly as good
13:39:47 <dncr> i have no idea why.
13:39:55 <typoclass> nand`: portage is gentoo's package manager?
13:40:00 <nand`> typoclass: yeah
13:40:20 <schovi> johnw: not necessarily. Maybe how can i call command how i wrote it and use result in haskell.
13:40:43 <johnw> there are many ways to solve that problem, schovi
13:40:47 <Cale> schovi: There are bindings to curl, zlib and iconv on hackage, for one.
13:41:10 <Cale> Of course, you could also just run those same programs using System.Cmd and pipe the data through them.
13:41:25 <johnw> or use conduits, or use hshshellscript, or use shelly, etc.
13:41:29 <typoclass> schovi: hello. a good starting point would be the package 'http-conduit' http://hackage.haskell.org/packages/archive/http-conduit/1.6.0.2/doc/html/Network-HTTP-Conduit.html . there is also a conduit to decode utf8 (i think it's in the package 'conduit'). i bet there's some conduit for unzipping things
13:41:44 <johnw> zlib-conduit
13:41:51 * dncr will now manually look for package version bumps
13:41:55 <Cale> I wonder why conduit is so popular all of a sudden.
13:42:04 <Cale> I should really look at it sometime.
13:42:06 <johnw> it's an excellent design pattern
13:42:22 <typoclass> schovi: conduits are roughly similar to shell pipes
13:42:58 <johnw> Cale: I'm wondering whether conduit is the thing to invest time in, because it's more practical; or pipes, because it's more "correct" (for some definition of correct) and keeps improving
13:43:36 <maukd> return (return ()), fuck yeah
13:43:50 <johnw> maukd: void return
13:43:51 <typoclass> Cale: i dunno really, i recommended http-conduit since it worked for me (the curl stuff did some funky global-state stuff and sometimes segfaulted; with the plain http package i had some other complaint that i can't recall at the moment)
13:44:04 <dncr> you just need to find the right virtual space to put them to a death match in
13:44:06 <schovi> johnw Cale typoclass: many hints. thanks you guys. Gonna experiment with it.
13:44:12 <dncr> BearVShark-0.0
13:44:21 <maukd> :t void
13:44:23 <lambdabot> Not in scope: `void'
13:44:34 <johnw> it's in Control.Monad
13:44:34 <ski> @djinn f :: Void -> a
13:44:35 <lambdabot> Cannot parse command
13:44:37 <Cale> johnw: To be honest, I frequently think that all these iteratee-like I/O libraries are a bit weird and questionably complex in implementation.
13:44:39 <ski> @djinn Void -> a
13:44:39 <lambdabot> f = void
13:44:52 <maukd> johnw: not in mine
13:44:57 <johnw> void x = x >> return ()
13:45:07 <dncr> Cale: what do you do for fast constant-space IO?
13:45:08 <johnw> ah, I'm using 7.4.2
13:45:10 <maukd> :t return >> return ()
13:45:11 <lambdabot>     Ambiguous type variable `m' in the constraint:
13:45:11 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:0-5
13:45:11 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
13:45:16 <merijn> Cale: Well, they seem to cover the usecase for iteratees, without actually needing a brain transplant to be able to use them :p
13:45:17 <johnw> oops :)
13:45:18 * ski thinks that ought to be called `ignore' or something, instead
13:45:35 <johnw> void return ()
13:45:48 <Cale> dncr: I usually don't need my I/O to be blisteringly fast, and the usual Haskell IO library is more than good enough for me.
13:45:53 * johnw agrees with ski
13:45:58 <maukd> :t (return >> return ()) ()
13:45:59 <johnw> ignore = void
13:45:59 <lambdabot>     Ambiguous type variable `m' in the constraint:
13:45:59 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:1-6
13:45:59 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
13:46:01 * nand` thinks _ <- is less verbose than ignore $
13:46:01 <johnw> solved!
13:46:09 <maukd> johnw: still ambiguous
13:46:11 <typoclass> Cale: haven't really looked at http-conduit's implementation much, but to use, it's pleasantly easy. and a big plus is that it's well-documented (even with code examples), which is not to be taken for granted
13:46:17 <johnw> maukd: you haven't specified which monad to use
13:46:26 <maukd> :t return (return ())
13:46:27 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (m ())
13:46:29 <maukd> I don't need to
13:46:30 <merijn> Cale: Speed is not usually an issue for me, but space usage and dealing with exceptional behaviour is
13:46:31 <johnw> oh
13:46:33 <johnw> ok
13:46:36 <johnw> never mind me then
13:46:48 <johnw> :t (return >=> void) ()
13:46:49 <lambdabot> Not in scope: `void'
13:46:56 <johnw> :t (return >=> (return ())) ()
13:46:56 <dncr> Cale: meaning you just use strict IO for fast and lazy IO for constant space (ignoring the annoyances of lazy IO)?
13:46:56 <lambdabot>     Couldn't match expected type `m c' against inferred type `()'
13:46:57 <lambdabot>     In the first argument of `return', namely `()'
13:46:57 <lambdabot>     In the second argument of `(>=>)', namely `(return ())'
13:47:02 <Cale> I see things like  (>+>) :: Monad m => Pipe l a b r0 m r1 -> Pipe Void b c r1 m r2 -> Pipe l a c r0 m r2, and it quickly makes me wonder whether I really need this.
13:47:09 <Cale> dncr: yes
13:47:13 <dncr> ya
13:47:21 <merijn> Cale: Looks like the average edwardk library to me? xD
13:47:41 <nand`> an edwardk library surely would involve more MPTCs
13:47:47 <edwardk> merijn: =P
13:47:48 <Cale> merijn: But edwardk builds all his libraries on abstractions from mathematics which I already understand.
13:47:59 <johnw> :t return
13:48:00 <edwardk> cale++
13:48:00 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:48:01 <johnw> :t void
13:48:02 <lambdabot> Not in scope: `void'
13:48:05 <Cale> All the iteratee libraries are new poorly-understood abstractions.
13:48:07 <johnw> :t return ()
13:48:08 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
13:48:27 <typoclass> merijn: no, if he'd written it, it would be (>+>) :: Monad m => Pipe a b c d e f -> Pipe Void b c d e f -> Pipe a b c d e f :-P
13:48:43 <dncr> well we don't take kindly to not using the latest not-yet-figured-out-already-being-displaced technology around here ;)
13:48:49 <merijn> Cale: I don't think mathematics has an existing module for dealing with real world IO? :p
13:48:57 <Cale> merijn: Indeed
13:49:07 <maukd> merijn: monads!
13:49:07 <johnw> i guess you need return (return ())
13:49:18 <merijn> I don't know where I got the word module from in that sentence...
13:49:25 <merijn> I must be tired...
13:49:33 <Cale> merijn: But jumping in and building things with 6 type parameters before it's even really clear that we need 6 type parameters seems a bit much.
13:49:34 <johnw> you mean math can't just do import?
13:49:46 <nand`> at the top of a paper: import "wadler" Monads
13:49:47 <merijn> typoclass: I always find that naming the first 26 variables is easy, after that it becomes tricky...
13:50:15 <nand`> merijn: real men use t0 t1 t2 ...
13:50:19 <typoclass> merijn: greek letters, then persian, then arabic. what's your problem.
13:50:21 <merijn> Cale: tbh I haven't used pipes before, only conduits (and even then only xml-conduit, html-conduit and http-conduit)
13:50:26 <dncr> the first 65000 infix operators..
13:50:28 <merijn> typoclass: You forgot Hebrew
13:50:34 <Cale> merijn: I took that from the conduit library though.
13:50:41 <typoclass> merijn: nobody can read that stuff
13:50:41 <DT`> typoclass, you forgot chinese.
13:50:53 <johnw> اسم واریابل
13:50:53 <nand`> chinese doesn't have letters
13:51:29 <Cale> merijn: Apparently, type Conduit i m o = Pipe i i o () m ()
13:51:36 <Cale> (obviously)
13:51:39 <johnw> woohoo, 6!
13:51:46 <wyfrn> is there a join for functors ?
13:51:51 <johnw> let's make Indexed Pipes, with 8!
13:51:55 * hackagebot sousit 0.3 - Source/Sink/Transform: An alternative to lazy IO and iteratees.  http://hackage.haskell.org/package/sousit-0.3 (MarioSiegenthaler)
13:51:57 <Cale> wyfrn: Functors which happen to be monads, yes
13:51:58 <nand`> wyfrn: then they wouldn't be functors
13:52:03 <nand`> err
13:52:03 <maukd> wyfrn: if your functor can join, it's a monad
13:52:07 <nand`> I'm talking nonsense
13:52:10 <Cale> They don't stop being functors when they become monads.
13:52:22 <Cale> (well, if it can join and return)
13:52:26 <nand`> wyfrn: there are functors that can't be monads, for example
13:52:48 <dncr> sousit, another one!
13:53:12 <Cale> I guess you could consider functors with an associative join but no return
13:53:16 <johnw> wow, it's a crowded design space
13:53:25 <johnw> Data.SouSiT, really?
13:53:27 <Cale> semigroupads
13:53:30 <wyfrn> ok thx
13:53:43 <hiptobecubic> Can anyone comment on my quickCheck test? I am trying to stop my (arbitrary :: Gen Form) from growing exponentionally in complexity and causes the test functions to diverge, but when I try to limit it, it is unable to make a single arbitrary value any more. It just hangs forever. http://hpaste.org/74798
13:53:59 <hiptobecubic> causing*
13:54:05 <DrSyzygy> Ohai hiptobecubic
13:54:08 <nand`> Cale: as opposed to monoidads ? :)
13:54:11 <hiptobecubic> DrSyzygy, :) hello again
13:54:19 <hpaste> applicative pasted “hlist length, version XXXI” at http://hpaste.org/74799
13:54:21 <Cale> nand`: yes
13:54:50 <applicative> nand`: heres a dubious hlist length, ^^^ tons of boilerplate
13:55:04 <hiptobecubic> DrSyzygy, I cleaned up our 3 hour chat on monads from a few months ago. After 15 times reading it, it's starting to make sense :)
13:55:13 <DrSyzygy> ooooh, I had one of those with you?!
13:55:16 <Cale> I wonder if with all the type-level lists and such, whether we'll be able to have Control.Operad in the near future.
13:55:18 <DrSyzygy> Did it help eventually?
13:55:22 <Cale> edwardk: get on it!
13:55:25 <johnw> hiptobecubic: link? :)
13:55:36 <hiptobecubic> johnw, to the discussion?
13:55:44 <ski> nand` : `data IOReadRef a = forall b. IORR (IORef b) (b -> a)' ?
13:55:50 <edwardk> cale: i've tried to get operads to be useful in haskell a couple of times. gave up
13:55:51 <johnw> yeah
13:56:03 <johnw> clearly, one cannot read too much about monads
13:56:24 <nand`> ski: what was that a reply to?
13:56:33 <ski> nand` : "for example"
13:56:46 <nand`> ah
13:56:57 <nand`> Const is a simpler example
13:57:16 <merijn> Sometimes I'm saddened by the fact that types disappear at runtime :\
13:57:32 <hiptobecubic> DrSyzygy, johnw, it's less about monads and more about category theory, but here: https://gist.github.com/3729716
13:57:37 * merijn wants runtime dispatch based on types...
13:58:00 <Heffalump> merijn: type classes/existentials give you that
13:58:01 <ski> merijn : surely, that way lies madness !
13:58:11 <DT`> merijn, GADTs?
13:58:12 <merijn> Heffalump: Not for what I want
13:58:22 <nand`> applicative: yuck :(
13:58:23 <merijn> DT`: How do GADTs do that?
13:58:27 <Heffalump> what do you want?
13:58:29 <lispy> existential type classes?
13:58:37 <applicative> nand`: it's a bit of  a trial.
13:58:47 <hiptobecubic> By 'cleaned up' I meant 'removed unrelated lines'. Not really 'made presentable'.
13:58:50 <johnw> and for my next trick, I will make types reappear at runtime!
13:59:01 <DT`> merijn, data Blah a where BlahInt :: Int -> Blah Int; ...
13:59:07 <johnw> hiptobecubic: even better
13:59:09 <hiptobecubic> I suppose just coloring lines by nick would be enough to make it a reasonable read
13:59:10 <merijn> Heffalump: I had a really nice design using GADTs to tag a record datatype with a phantom type indicating whether it was a Control or Data record
13:59:21 <merijn> DT`: That's the *cause* of my problem, not a solution
13:59:28 <nand`> applicative: I'm just sort of curious whether type lists etc. have some motivating use cases or whether it was just “let's implement them because we can and see what we can do with it”
13:59:36 <merijn> Heffalump: Which was nice, until I realised I could no longer send both record types through the same Chan
13:59:45 <merijn> Heffalump: Because their types differed
13:59:57 <Heffalump> merijn: an existential would cure that
14:00:05 <merijn> Heffalump: I tried that, but it doesn't
14:00:15 <applicative> nand`: I'm not sure what the uses are, people liked them when they were uglier, before DataKinds, so who knows
14:00:18 <merijn> Because how would you unwrap back to the proper type when you read a record?
14:00:56 <ski> match on the GADT constructor ?
14:01:17 <Heffalump> data Wrapped where Control :: Record Control -> Wrapped ; Data :: Record Data -> Wrapped
14:01:20 <johnw> nand`: C++ uses type lists to good effect all over the place
14:01:24 <Heffalump> (i.e. what ski said)
14:01:26 <merijn> Heffalump: I had "data Record' = Record' forall a. Record a" (or whatever the correct syntax is), but then how would you write a function "readChan :: Chan ? -> IO (Record r)"
14:02:04 <Heffalump> you can't, but you can write readChan :: Chan Record' -> (forall r . Record r -> IO a) -> a
14:02:20 <applicative> there was some talk at the ICFP about some Template Haskell library that derives all the needed singleton types and type families to do this sort of nonsense.
14:02:28 <merijn> Heffalump: IO a you mean, right?
14:02:34 <Heffalump> yes, sorry
14:03:26 <hiptobecubic> If no one has invested any of their highly valued time into looking at that quickCheck problem i'll just head off to bed and try again tomorrow. My eyes are drooping
14:03:29 <merijn> Heffalump: hmm, maybe that'd work. But the extra work makes the idea seem counterproductive
14:03:37 <hpaste> dancor pasted “fails w/ no error even on clean config?: cabal install syb-with-class ” at http://hpaste.org/74800
14:03:51 <merijn> Heffalump: I might as well drop the phantom type in "Record r" and use the normal ADT then
14:04:14 <Cale> I want type-level Data.Map pls.
14:04:37 <applicative> nand`: it's a bit dull http://www.youtube.com/watch?v=rLJ_YyVRKzs&feature=plcp
14:04:41 <DrSyzygy> Damn, I seemed to have made sense back when, hiptobecubic
14:04:59 <Heffalump> merijn: the question is whether you want the safety elsewhere
14:05:02 <hpaste> dancor annotated “fails w/ no error even on clean config?: cabal install syb-with-class ” with “fails w/ no error even on clean config?: cabal install syb-with-class  (annotation)” at http://hpaste.org/74800#a74801
14:05:06 <Heffalump> if you don't, then obviously there's no point
14:05:08 <hiptobecubic> DrSyzygy, it was a good talk.
14:05:13 <typoclass> Cale: it's called a function. takes a key, gives a value. kthxbai :-)
14:05:14 <Heffalump> if you want it everywhere but for Chans, this seems the right apprach
14:05:38 <Heffalump> For what it's worth, darcs does this kind of thing heavily and it works well in practice
14:05:41 <hiptobecubic> DrSyzygy, The "numbers can be morphisms" revelation was much appreciated.
14:06:25 <merijn> Heffalump: Yeah, but if I had runtime type I wouldn't need all this, I could just have "Chan (Record r)" and dispatch based on whatever type record I happen to get out of it :p
14:06:30 <Cale> typoclass: Well, sure, kinda hard to do insertions and deletions, but possible to get by.
14:06:58 <Heffalump> you could, but I don't see how the GADT is much overhead
14:07:21 <merijn> Heffalump: I need to think of a new datatype name + constructor names :p
14:07:25 <Heffalump> that gives you a constrained runtime type for basically three lines of code to define the type, and an extra token to do the wrapping when you use the Chan
14:07:26 <merijn> Thinking of names is *hard*
14:07:35 <Heffalump> darcs uses Sealed, FWIW
14:07:58 <DrSyzygy> merijn: Call it Doris. Or Janet.
14:08:06 <DrSyzygy> Call it JAnet! And one of the constructors can be Brad!
14:08:57 <Cale> I'm thinking it would be really nice to have Map Nat * at the type level for doing stuff like keeping track of the types of graph nodes in a heterogeneously typed code graph.
14:09:27 <Cale> (so you could avoid unsafeCoerce, hopefully!)
14:10:12 <squidz> what's the most popular noSQL being used in haskell right now? I know ACID-state is popular but as far as I know it doesn't provide true persistence right?
14:10:25 <merijn> squidz: Eh...define true persistence?
14:10:27 <Cale> squidz: what do you mean by "true persistence"?
14:10:38 <merijn> squidz: It persists to disk with journaling, seems true enough to me
14:10:45 <Cale> (I would say it does provide persistence, and that's about it.)
14:10:46 <mm_freak_> squidz: what does "ACID" tell you?
14:10:50 <squidz> storing data outside of memory
14:11:07 <Cale> squidz: You don't get the D in ACID without that.
14:11:16 <mm_freak_> in particular the D
14:11:20 <merijn> squidz: That is true by definition for anything ACID :p
14:11:42 <Cale> squidz: What acid-state does *not* do, is provide some uniform mechanism for querying your data.
14:11:46 <merijn> The D stands for Durability, meaning that it should with stand application and machine crashes
14:11:56 <Cale> squidz: Your data is some Haskell datastructure (of your choosing)
14:12:14 <Cale> and if you want to be able to do traditional-style queries on it, you can use IxSet or the like.
14:12:17 <merijn> Cale: *serialisable* haskell datastrcuture of your choosing :p
14:12:20 <squidz> oh i guess it is persistent, but what I want to avoid is storing everything in memory
14:12:23 <Cale> merijn: indeed
14:12:55 <mm_freak_> squidz: acid-state by itself can't help you with that…  you would resort to one of the traditional DBMSes out there
14:13:10 <merijn> RAM is cheap anyway ;)
14:13:21 <monochrom> true persistence means the data survives the next big crunch and big bang :)
14:13:30 <squidz> because I know that some people are using MongoDB, but is that the most popular NoSQL=?
14:13:41 <mm_freak_> monochrom: it does anyway…  information is preserved =P
14:13:49 <johnw> what about Redis?
14:14:12 <squidz> Ive heard some stuff about Redis
14:14:28 <monochrom> I don't think anyone here has hard statistics on popularity
14:14:46 <squidz> but not sure why it seems to appeal to the haskell community in comparison to CouchDB which is programmed in Erlang
14:15:02 <gertc> when using `Data.Map.Lazy Map k a` can i have duplicate keys?
14:15:12 <monochrom> no
14:15:15 <Cale> All the NoSQL stuff right now just scares me. It's like, people have half of the right idea, ditch SQL because it's kinda bad. But they do so in exactly the opposite of the direction I want to go. I want *more* structured data, not less.
14:15:59 <mm_freak_> yeah, NoSQL usually comes with NoSchema
14:16:04 <mm_freak_> which i consider a hazard
14:16:06 <squidz> Cale: and nobody is doing that nowadays?
14:16:12 <mm_freak_> squidz: acid-state is =)
14:16:24 <merijn> Cale: So Node.js gives you a heartattack too? :p
14:16:36 <gertc> damn i need duplicate keys to be able to do map reduce stuff with acid state
14:16:46 <mm_freak_> node.js is poor man's snap framework
14:17:02 <hpaste> applicative pasted “hlist length, version XXXII” at http://hpaste.org/74802
14:17:04 <Cale> merijn: Node.js is just a joke
14:17:05 <merijn> node.js is an elaborate practical joke, imo :)
14:17:15 <merijn> Cale: Not all people seem to think that, unfortunately
14:17:21 <applicative> nand`: much better, I was distracted by other cases I'd tried
14:17:25 <merijn> Cale: I recommend you avoid reading Hacker News :)
14:17:31 <Cale> Oh, I already do
14:17:37 <pharaun> acid-state is ? nosql
14:17:52 <pharaun> i haven't played with it yet but i'm probably going to soon for a web-project
14:18:00 <merijn> pharaun: It's definitely not SQL :p
14:18:01 <applicative> nand`: this case only involves indirection by an existential
14:18:05 <gertc> no its jsut a list dat is svaed on your hard disk
14:18:24 <Cale> acid-state is nosql in the direct sense that it has nothing to do with SQL, but it otherwise bears very little relationship with all the other NoSQL libraries.
14:19:02 <mm_freak_> pharaun: acid-state's query language is haskell itself
14:19:06 <squidz> does anybody know if there is work being done on being able store outside the limits of ram space with acid-state?
14:19:07 <mm_freak_> so it's inherently NoSQL
14:19:08 <cmccann> node.js is the thing where they painfully reinvent clumsy ways to do stuff that's been well-understood for years but people use it because of the hype, right?
14:19:12 <nand`> applicative: interesting
14:19:23 <merijn> cmccann: Sounds about right
14:19:23 <Cale> gertc: It's not a list. It's an arbitrary Haskell datastructure which has an instance of a class that says how to serialise (and possibly some instances for migration of old data as well).
14:19:32 <pharaun> merijn: hahaha i know :) but i guess i was asking if it was being classified as nosql but, like does it have all of the nosql problems
14:19:58 <pharaun> i was looking and it "sorta" of have a schema via what you put in and it has versioning of the schema
14:20:00 <merijn> pharaun: Well, unlike most NoSQL things it is actually fully ACID, so
14:20:16 <gertc> cale: that was the long version :)
14:20:18 <pharaun> that's what i figured, so its a "nosql" but not like the "nosql" that most people refer to?
14:20:33 <Cale> pharaun: yeah
14:20:36 <pharaun> and i want a fully ACID datastore
14:20:49 <pharaun> so its usually sql for me, seems like acid-state is going to be interesting one for me to look at
14:21:21 <squidz> Im asking about all the noSQL stuff because I really want to get into it, but one of my worries with NoSQL is the lack of powerful querying. Is this not even a problem with acid-state?
14:21:27 <merijn> pharaun: As Cale pointed out earlier, you have no querying provided, but you could just stuff a Map in there
14:21:28 <statusfailed> Has this conversation spawned from the Go article?
14:21:40 <Cale> statusfailed: nope
14:21:50 <Cale> (at least not as far as I saw)
14:22:10 <statusfailed> Ah, ok. I was just enjoying the flames :)
14:22:11 <squidz> no I started asking about noSQL because my work probably needs to use it
14:22:27 <statusfailed> What for?
14:22:31 <gertc> just invent a mapper and a reducer your self and you have a perfect nosql solution, acid-sate just make sure that your data is safe
14:22:35 <nand`> squidz: from what I can tell, acid-state has you define your own query semantics
14:22:35 <pharaun> merijn: that still works for me, a map or what so not would work, is the map like lazy loaded?
14:22:37 <squidz> social networking application
14:22:50 <pharaun> or is it a little bit more involved than that?
14:23:12 <nand`> like, you could implement the relational algebra and you'd end up with a (safer, nicer) copy of SQL, I'm guessing
14:23:18 <pharaun> i have a project in which a fullsql db is a massive overkill
14:23:21 <Cale> squidz: I have the same situation, we're going to be rewriting skedge.me's backend in Haskell, and need to decide on something to store data in.
14:23:23 <pharaun> so i was hoping to do acid-state
14:23:39 <merijn> pharaun: It is kept in memory
14:23:56 <pharaun> merijn: acid-state? i thought it was also persisted to disk
14:23:59 <pharaun> hence ACID
14:24:14 <pharaun> at least from my reading of the tutorial on acid-state in happstack
14:24:24 <squidz> Cale: For a big project, im not sure acid-state is enough, but for smaller stuff it seems fine. And itÄs really interesting
14:24:25 <merijn> pharaun: ACID state keeps all state/data in memory, it persists to disk *too*, but that is for persistence/saving over program termination
14:24:33 <nand`> there are multiple backends for acid-state fwiw
14:24:41 <nand`> but when loaded, all data is in memory
14:25:02 <squidz> nand`: what kind of backends?
14:25:08 <gertc> i am trying to implement a reducer for acid state but then i need a Map that stores duplicate keys. Any sugestions pleas?
14:25:25 <nand`> squidz: the normal file-based backend, a ‘remote server’ backend and a dummy (memory) backend for testing
14:26:06 <pharaun> oh ok, thanks merijn nand`
14:26:10 <merijn> pharaun: From how I understood it, it reads state from disk, keeps it in memory and any changes are logged to a journal on disk. When you checkpoint or exit the current full state is saved. When you crash it reads the old state and replays the change/update log to get back a persistent version of your latest state
14:26:19 <Cale> gertc: Map A (Set B)?
14:26:41 <Cale> gertc: Or perhaps just Map A [B]
14:26:42 <merijn> pharaun: So it doesn't load the data from disk on demand, but just always keeps it in RAM
14:26:52 <nand`> Set B seems more appropriate
14:27:46 <gertc> ok and B is like ("gert","invoice")?
14:28:37 <dncr> ok new plan: i'm going to add constraints for "installed" and the exact version number to my ~/.cabal/config for every haskell package that comes in the ubuntu ghc package
14:28:37 <gertc> so i can have a hole bunch of ("gert","invoice2") right?
14:28:40 <Cale> gertc: I don't really understand your problem. You said you wanted a Map structure that could store duplicate keys, so I assumed you mean you wanted to store multiple values at the same key.
14:28:51 <gertc> yes
14:29:06 <gertc> example take my name as key
14:29:08 <Cale> gertc: So store a list or set of values at each key, and the problem is solved? :)
14:30:33 <gertc> ok thinking...
14:30:35 <pharaun> merijn: oh ok, that solves the lazy load question :) well my dataset is going to be small enough so in-memory datastore would work good enough
14:30:38 <pharaun> thanks
14:31:41 <Cale> These days, there are not many applications where you can't afford to buy enough memory to store your whole database in memory.
14:31:57 <Cale> (or rent it)
14:32:52 <hiptobecubic> indeed
14:32:59 * nand` wonders if such burdens should install fall upon the operating system instead, the application thinking the entire file is in memory
14:33:11 <merijn> Some of us are cheap people who rent 5 dollar VPSes with almost no RAM... :p
14:33:18 <hiptobecubic> :)
14:33:19 <nand`> like me!
14:34:42 <gertc> performace is going to suck if B get huge? `Map A [B]` for example if B represents all invoices and my mapreducer need to find al gert keys in B
14:42:55 <gertc> do you all use list to store something with dublicate key's? No fancy tree like something?
14:43:22 <Cale> gertc: My first recommendation was Set
14:43:23 <nand`> I've never needed to store duplicate keys but if I did, I'd use Set
14:43:32 <maukd> I never store something with duplicate keys
14:44:04 <nand`> hmm
14:44:38 <roconnor> merijn: where do I get a $5 VPS?
14:45:02 <johnw> serveraxis.com is $7
14:45:41 <merijn> roconnor: I have to check what the URL was, a colleague linked me a French VPS starting from $1 a month
14:46:30 <gertc> http://www.ovh.com/fr/cloud/instances/index.xml
14:47:23 * cmccann sighs. reddit is going to be all kinds of fun today, isn't it.
14:47:32 <gertc> learnig Set just a sec :)
14:49:32 <merijn> roconnor: I can't find the original link I had, but these guys have one for 1.5 pounds (so something like $3?) http://www.minivps.co.uk/
14:50:13 <roconnor> :)
14:51:07 <hiptobecubic> 96MB Ram guaranteed!
14:53:54 <startling> why can't I use a Ord k => k -> Simple Lens (Tree k a) (Maybe a) as the definition for "at" in lens? I get this indecipherable type error: http://hpaste.org/74805
14:54:48 <edwardk> You need to supply an indexed traversal. not a traversal
14:55:02 <edwardk> its relatively easy to do
14:55:15 <edwardk> just modify your definition slightly
14:55:23 <startling> edwardk, what makes that different from an indexed traversal?
14:55:25 <merijn> edwardk: I swear, in a little while you'll be answering people before they've phrased their problem/question...
14:55:25 <edwardk> look at the implementations of At for Map, HashMap and IntMap
14:56:02 <roconnor> edwardk: how does haddock interact with the template haskell from lens?
14:56:12 <edwardk> you want Ord k => k -> SimpleIndexedLens k (Tree k a) (Maybe a)
14:56:23 <startling> heh, the `lens` docs come up when I start to type hackage in my address bar
14:56:57 * hackagebot data-lens-template 2.1.7 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.7 (RussellOConnor)
14:56:58 <edwardk> roconnor: template haskell generates code that does into the hi file, so haddocks see it. sadly you can't use TH to generate haddock comments in the generated code, but instances show up these days
14:57:44 <edwardk> startling: basically all you have to do is wrap your existing code in a call to index and pass the key to the function the user gives you
14:57:59 <ddarius> copumpkin: Have time from your hard studying to do dinner near Porter Square tomorrow evening?
14:58:32 <startling> edwardk, the lens i have right now is made with the function "lens" and a getter and setter. should I use "index" there instead?
14:58:42 <roconnor> edwardk: so there is no way to add haddock comments for genereted lenses?
14:58:51 <edwardk>  index $ \ f m -> (`go` m) <$> f k (IntMap.lookup k m)    -- instead of  \ f m -> (`go` m) <$> f (IntMap.lookup k m)
14:58:55 <copumpkin> ddarius: sure thing :)
14:59:11 <edwardk> roconnor: sadly, no
14:59:27 <roconnor> ok
15:00:14 <edwardk> startling: index isn't quite like lens, but it gets used to make indexed lenses and traversals
15:00:40 <dncr> is it good form for any package to work and be buildable w/ the library versions in haskell platform, if possible?
15:01:04 <edwardk> dncr: when possible i try to keep my code platform compatible with the last 1 or 2 platforms
15:01:23 <dncr> that is, is it evil to put later version-constraints just because later is available
15:01:28 <dncr> edwardk: ah coll
15:01:29 <dncr> cool
15:03:21 <johnw> if I have a data declaration "data Ref a", how do I specify that all occurrences of "Ref a" in my program mean "(Stringable a) => Ref a"?
15:03:35 <kallisti> johnw: you don't
15:03:46 <johnw> i have to repeat it everywhere?
15:03:47 <kallisti> you write Stringable a => Ref a
15:03:58 <latro`a> you can make another type with a constraint, I think
15:04:11 <kallisti> constraints on data declarations do not infer constraints automatically
15:04:14 <kallisti> they only require a constraint
15:04:19 <kallisti> which makes you job even more annoying, usually.
15:04:26 <johnw> GADTs don't solve this?
15:04:39 <edwardk> johnw: you don't. you should repeat it everywhere. trust me. there are GADT-like ways to encode it, but you don't want to do it
15:04:59 <johnw> i just want users to be able to use String/Text/Text.Lazy/Bytestring/Bytestring.Lazy, whatever, as long as I can stringify the argument to withCString
15:05:00 <Enigmagic> it's better to put the constraint on the functions
15:05:04 <johnw> so I made a Stringable type class
15:05:13 <johnw> edwardk: ok, good enough fro me
15:05:18 <Enigmagic> and it's also better to just use Text :P
15:05:23 <edwardk> johnw: sure. then you should plumb the constraints to the use sites
15:05:46 <johnw> I thought about just using Text, but I feel it's an unnecessary restriction
15:05:55 <johnw> my library itself doesn't need Text
15:05:57 <edwardk> the issue is that if you put the constraint on the type it locks you out of a lot of useful classes
15:05:58 <startling> edwardk, so what do I use "index" on? the type signature doesn't tell me anything
15:06:00 <kallisti> Text is not all the right type.
15:06:02 <johnw> I just need to get a "String" down to withCString
15:06:12 <kallisti> s/all/always/
15:06:16 <johnw> enforcing Text just so I can convert it later seems arbitrary
15:06:41 <johnw> hence, Stringable a :)
15:06:53 <Enigmagic> well converting "ByteString -> String" isn't really a great option either
15:07:00 <johnw> no, but now they have the choice
15:07:03 <edwardk> startling: pass index a function of type forall f. Functor f => (key -> value -> f newvalue) -> container -> f newcontainer  and use that as the value of 'at' for your type
15:07:07 <ski> johnw : i think you can say `data Ref :: * -> * where MkRef :: Stringable a => ... -> Ref a' -- however the `Stringable a' constraint will only be in scope after you've matched on the constructor
15:07:14 <johnw> if, for example, they're using attoparsec to rip in SHA1s from a file
15:07:19 <dncr> ok i think i win.  now if anything ever tries to leave haskell platform packages then cabal-install will die and tell me.
15:07:31 <johnw> actually, I may optimize for the bytestring case
15:07:41 <Enigmagic> johnw: wouldn't you want the API to take bytestrings then?
15:07:56 <edwardk> ski: you can say that but its a bad idea 99% of the time
15:08:04 <johnw> I create WithCStringable, I can use unsafeUseAsCStringLen
15:08:06 <edwardk> hence my 'you probably shouldn't' comment ;)
15:08:12 <dncr> if anything tries to change version or do a second install of the same version package
15:08:15 <johnw> Enigmagic: because maybe you want String, or Text
15:08:35 <johnw> who knows what "source" these SHA1s may come from
15:08:41 <Enigmagic> johnw: right, i just don't see how converting it to a string is helping.
15:08:42 <ddarius> We should get rid of String.
15:08:51 <johnw> Enigmagic: I have to, to use withCString
15:08:53 <edwardk> ddarius: *shudder*
15:09:00 <kallisti> linked lists: bad for Haskell
15:09:06 <Enigmagic> johnw: don't use withCString then. Text and ByteString have equivalent APIs
15:09:15 <kallisti> (:P)
15:09:21 <johnw> they can call C functions that expect CString?
15:09:53 <startling> edwardk: ah, neat
15:10:11 <dncr> it works!
15:10:15 <ddarius> ByteString is specifically designed to be readily useable with foreign functions.
15:10:27 <johnw> yes
15:10:29 <kallisti> Enigmagic: it doesn't sound like he's converting everything to String in order to accomplish this.
15:10:36 <johnw> but it's not always the most convenient thing to enforce on users
15:10:55 <Enigmagic> johnw: yes. in the case of Text you need to figure out the encoding though. if the function actually works with UTF-16 you can use Data.Text.Foreign.useAsPtr, otherwise use encode to convert it to a ByteString first
15:10:56 <johnw> I want users to be able to use any of the 5 string types, and I will find the most optimal way to get it to C
15:11:39 <ddarius> An alternative would be just to take the CStrings directly and leave the conversion to someone else.
15:11:52 <johnw> wow
15:11:59 <johnw> and that would render my user community to about 1 I think
15:12:15 <johnw> the whole idea of this library is to abstract away the ugly C FFI
15:12:34 * merijn thinks the C FFI is pretty nice
15:13:04 <johnw> example usage: lookupBlob repo "fa46be6"
15:13:20 <johnw> making user create a CString just to call that function is unthinkable
15:13:27 <Enigmagic> johnw: a typeclass is fine, just use the correct API to get a CString/CStringLen for each type
15:13:42 <johnw> Enigmagic: yeah, that's why I'm making WithCStringable now
15:14:37 <johnw> for Text, it's just withCStringable = withCString . toString
15:14:43 <johnw> but for ByteString, it can be much more optimal
15:15:06 <kallisti> johnw: I would recommend converting Text to Bytestring instead
15:15:29 <johnw> with E.encodeUtf8?
15:15:36 <Enigmagic> johnw: yeah
15:15:40 <johnw> cool, I'll do that
15:15:46 <sinelaw> 'sup with hackage? is it down?
15:15:53 <Nereid> works for me
15:16:18 <sinelaw> cabal update doesn't work
15:16:22 <sinelaw> oh wait
15:16:24 <sinelaw> now it does :)
15:16:30 <kallisti> johnw: Text -> String -> CString is a bit more roundabout than Text -> ByteString -> CString
15:17:14 <slack1256> is unsafe to define your own instances of Typeable (as said by harper)
15:17:26 <slack1256> is also unsafe to define you own instances of Data?
15:17:39 <slack1256> (Data as in Data.Data)
15:18:51 <Cale> slack1256: It shouldn't be a problem.
15:19:45 <Cale> slack1256: And Harper wasn't the first one to discover this. Typeable's basically always known to be unsafe if you write instances by hand, even by the people who put it in.
15:19:50 * ddarius thinks slack1256 means Data.Data.Data
15:20:44 <slack1256> ddarius: your are correct
15:20:57 * ddarius remembers the days before deriving (Typeable)
15:21:07 <slack1256> Cale: so hand-rolled instances of Data should be okay?
15:21:34 <Cale> slack1256: Yeah, I believe they should be fine. I don't really know why you'd *want* to write one by hand, but you can't do anything unsafe with it.
15:22:27 <slack1256> Cale: I usually don't think I know how to use a class until i write a instance with it. is just for educational purposes.
15:22:32 <johnw> what's the best way to convert BL.ByteString -> BS.ByteString?
15:22:44 <ddarius> concat . toChunks
15:22:45 <shachaf> SB.concat . LB.toChunks
15:22:48 <johnw> thanks
15:23:18 <nwf> Speaking of Data.Typeable, would anything break if "instance Typeable" were prohibited outright in favor of only DerivingDataTypeable?
15:23:33 <ddarius> Code that has explicit instances would break.
15:24:28 <Cale> As far as I know, there's not much good reason to write your own instance apart from GHC not being able to derive one for you. I don't recall off hand any case where I needed Typeable and couldn't get a derived instance though...
15:24:45 <ddarius> GHC should always be able to derive Typeable.
15:28:49 <latro`a> is there anything not deliberately used for unsafeness that would break?
15:29:26 <thetallguy1> Is there  a GHC option that's like -M, but more unixy?  I.e., just list dependent files?
15:30:44 <Sgeo> :t (&&&)
15:30:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:30:59 <Sgeo> :t (***)
15:31:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:34:37 <hpaste> johnw pasted “Stringable.hs” at http://hpaste.org/74807
15:34:42 <johnw> that seems to do just the trick
15:35:44 <kallisti> honestly I don't understand why lazy/strict bytestrings don't have a typeclass
15:35:54 <kallisti> they have essentially the same interface.
15:36:02 <kallisti> same with lazy/strict text
15:38:29 * ski wants ML-style module signatures ..
15:39:56 * ddarius wants something better than ML-style module signatures.
15:40:13 * cmccann wants a pony!
15:40:23 <ddarius> @hackage pony
15:40:24 <lambdabot> http://hackage.haskell.org/package/pony
15:40:30 <cmccann> :D
15:40:35 <pharaun> :D
15:40:37 <cmccann> I thought that was copumpkin's pony or something though.
15:40:54 <johnw> if I find my hand reaching for unsafePerformIO, should I chop it off?
15:41:00 <wyfrn_> how to write a strict version of modifyIORef? the latest base package is not available on arch right
15:41:08 <kallisti> johnw: yes
15:41:11 <wyfrn_> + now
15:41:17 <cmccann> johnw, sure, but the hand won't actually be severed until some random thunk gets forced.
15:41:38 <kallisti> johnw: if you'd like I can show you an example of a FFI-based API that uses unsafePerformIO
15:41:39 <johnw> my C lib has this 20 byte data structure, it's pure, immutable, all the good stuff, but all the functions that compare them, check for zero, etc., are all in IO
15:41:41 <kallisti> and it goes horribly wrong.
15:41:58 <johnw> I either have to replicate all that functionality in Haskell to make a pure version that's convertable to the C version, or I can call the C versions with unsafePerformIO
15:42:25 <kallisti> if the C code is referentially transparent it /might/ not matter.
15:42:28 <cmccann> well, better make sure that the C functions you're calling are actually safe to use that way.
15:42:31 <johnw> yes, it is
15:42:36 <Enigmagic> johnw: or you can remove the IO from the foreign import...
15:42:48 <Enigmagic> it makes it pure!!
15:42:49 <johnw> a SHA1 isn't going to change :)
15:42:49 <Enigmagic> :o
15:42:51 <johnw> it damn well shouldn't
15:42:58 <johnw> haha
15:43:02 <johnw> can I really do that?
15:43:05 <Enigmagic> yeah
15:43:07 <cmccann> johnw, but does the function have any dependency on mutable state?
15:43:09 <johnw> oh!
15:43:14 <johnw> cmccann: no, none at all
15:43:23 <ddarius> It gets interpreted as a use of unsafePerformIO.
15:43:28 <cmccann> so it's completely thread safe and all that sort of stuff?
15:43:32 <johnw> yes
15:43:41 <johnw> these are just values, only they are allocated on the heap
15:43:43 <cmccann> then yeah that's basically the original reason unsafePerformIO exists.
15:43:48 <johnw> ok
15:43:58 <ddarius> unsafePerformIO has documentation...
15:44:01 <cmccann> just be sure you understand the C code well enough to know that it'll work.
15:45:02 <JoeyA> Make sure any objects the unsafePerform'd IO don't ever disappear prematurely.
15:45:14 <JoeyA> the IO uses, that is
15:45:40 <johnw> hmm
15:46:18 <johnw> what I'm not sure of is whether the alloc'd blocks will always outlive the call in the thunk
15:46:43 <johnw> so I think I should write a Haskell version
15:46:50 <johnw> it's a 20-byte bytestring
15:46:59 <JoeyA> ForeignPtr can be used to ensure such objects are garbage collected.  That's what ByteString does.
15:47:07 <johnw> yes, I'm using ForeignPtr
15:47:13 <johnw> type Oid = ForeignPtr C'git_oid
15:47:14 <sinelaw> how do I tell cabal that it needs to install certain native libraries for the install to succeed? I added pkgconfig-depends but then the build just fails on hackage
15:47:29 <sinelaw> I want it to build succesfully on hackage somehow
15:47:34 <kallisti> sinelaw: you need to use your distros package tools
15:47:40 <JoeyA> johnw: You're aware of cryptohash, right?
15:47:42 <kallisti> cabal doesn't handle anything but Haskell code.
15:47:59 <gertc> supose i have a Data.Set like [(joe,tomatos),(gert,bananas),(gert,aples),(gert,patatos)] how do i extract [(gert,banans),(gert,aples),(gert,patatos)] and [(joe,tomatos)] ?
15:48:06 <kallisti> oh, right, and pkgconfig-depends
15:48:11 <sinelaw> kallisti, so what do you do for such a lib to get it to compile on hackage?
15:48:17 <merijn> kallisti: And C code :p
15:48:23 <Enigmagic> sinelaw: you gotta email the hackage maintainer and ask for him to install it for you. i've done this a couple times.
15:48:24 <JoeyA> gertc: A Set cannot have duplicate keys.
15:48:34 <sinelaw> Enigmagic, seriously?
15:48:38 <johnw> JoeyA: yeah, but I have this C lib I have to work with
15:48:41 <JoeyA> You could say Map String [String] instead.
15:48:45 <sinelaw> that kinda sucks for him/her
15:49:03 <gertc> doh! but that was my first question :)
15:49:14 <Enigmagic> sinelaw: yeah. i wouldn't want random people installing packages on any servers i manage.
15:49:24 <jmcarthur> or you do what GLFW-b does and include all necessary C, if licensing allows
15:49:39 <sinelaw> Enigmagic, it should have a sandbox for building stuff
15:49:40 <jmcarthur> it's easier for end users that way anyway
15:49:44 <JoeyA> johnw: As long as you are sure the interleaved IO will work correctly for its entire lifetime, you should be fine.
15:49:51 <jmcarthur> it may be hard to do though, depending on what you need
15:50:22 <Enigmagic> sinelaw: perhaps for hackage 3? :P
15:50:28 <Enigmagic> 10 more years
15:50:29 <gertc> but the set element is (gert,...) so it is not going to be a duplicate
15:51:42 <gertc> a set element can be a tulpe or list right?
15:52:51 <JoeyA> gertc: Perhaps you could use Map String [String] instead?  E.g. Map.fromList [("gert", [...]), ("joe", [...])]
15:53:02 <JoeyA> (That is, have your data already sorted out to begin with)
15:53:28 <mm_freak_> apropos Set:  when you have a create-once/query-a-lot set generated from a non-sorted source, it's very fast to create a Vector, sort (Data.Vector.Algorithms.Heap) it and perform binary search (Data.Vector.Algorithms.Search)
15:53:43 <mm_freak_> that's at least true for unboxed vectors of Ints
15:54:15 <mm_freak_> that outperforms IntSet by a large factor
15:56:06 <gertc> JoeyA, that would be my mapreduce result from a large acid state
15:56:57 <gertc> but i need to start from a big bag of (x,y) data
15:57:36 <aristid> mm_freak_: interesting.
15:57:41 <johnw> JoeyA: how about this:
15:57:43 <hpaste> johnw pasted “Oid.hs” at http://hpaste.org/74810
15:58:09 <aristid> mm_freak_: what's up with netwire 4 btw? :P
15:58:36 <mm_freak_> aristid: code is finished, working on the tutorial…  you can start using it and gimme feedback along the way =)
15:58:47 <mm_freak_> aristid: darcs get http://darcs.ertes.de/netwire/
15:59:03 <aristid> mm_freak_: oh you should link that darcs repo in your cabal file
15:59:13 <mm_freak_> oh, indeed, thanks
15:59:46 <aristid> mm_freak_: i don't really have a use for it right now, but i recently wanted to point somebody to netwire who asked for FRP options
16:01:15 <aristid> mm_freak_: you only created the darcs repo after work on 4.0 was already under way? looks like the oldest commit is from mid august
16:01:25 <mm_freak_> yeah
16:01:32 <mm_freak_> it's not based on netwire 3
16:01:47 <aristid> you know that rewrites are evil?!
16:01:54 <mm_freak_> yes, but it was necessary
16:02:05 <JoeyA> johnw: That looks fine.  But why is equalOid so generic?
16:02:09 <mm_freak_> netwire 3 is beautiful on its surface, but really ugly under the hood
16:02:15 <JoeyA> I'd recommend making Oid a newtype, so you can write an Ord instance.
16:02:18 <mm_freak_> netwire 4 is beautiful inside and outside =)
16:02:30 <JoeyA> (well, Eq and Ord instances)
16:02:35 <aristid> mm_freak_: could you at least re-use some of the higher-level netwire 3 code?
16:02:38 <JoeyA> Where compare = compareOid
16:02:43 <johnw> JoeyA: ahh, that's what I wanted to do
16:03:08 <johnw> how do I make Oid a newtype if it uses no dependent types?
16:03:18 <mm_freak_> aristid: if you worked with a type alias for your wire the type signatures will be the same, but some of the prefab wires have changed their interface
16:03:21 <JoeyA> What do you mean?
16:03:28 <mm_freak_> aristid: but it should be easy to adapt
16:03:32 <JoeyA> It's just: newtype Oid = Oid (ForeignPtr C'git_oid)
16:03:44 <johnw> for some reason, I think newtype required a type parameter
16:03:48 <merijn> mm_freak_: Does it have good documentation too? :p
16:03:54 <JoeyA> Better yet, define that newtype and have your bindings use it directly.
16:04:06 <mm_freak_> merijn: full haddock documentation (as always), and a tutorial is on its way
16:04:22 <mm_freak_> merijn: also my haddock docs are exceptionally comprehensive =)
16:04:31 <ski> johnw : the *data* constructor requires (exactly) one argument, yes. the *type* constructor doesn't
16:04:50 <JoeyA> foreign import ccall "git_oid_cmp" c'git_oid_cmp :: Oid -> Oid -> IO CInt
16:05:07 <JoeyA> Err
16:05:18 <johnw> i can't change the FFI call
16:05:27 <johnw> that's all auto-generated stuff, and I want to avoid editing it
16:05:28 <merijn> mm_freak_: I wanted to networking + terminal GUI, but someone else said I should use reactive-banana for GUIs. Do you see any difficulty in doing it with netwire?
16:05:31 <JoeyA> Nevermind, what I meant is: newtype COid = Ptr C'git_oid
16:05:45 <johnw> ah
16:05:51 <JoeyA> Err, COid (Ptr C'git_oid)
16:05:56 <johnw> Ord ForeignPtr just uses the underlying Ptrs
16:06:10 <mm_freak_> merijn: yes…  you will have to write the GUI wrapper yourself right now…  there is a ready-made wx wrapper for reactive-banana
16:06:32 <JoeyA> But COid can't have an Ord instance, since the buffers might be freed prematurely.
16:06:58 <merijn> mm_freak_: Like I said I want to do terminal GUI stuff (so probably Vty or curses), which doesn't have a ready-made wrapper anyway, I think?
16:07:19 <mm_freak_> merijn: oh, i misread…  in that case i definitely recommend netwire
16:07:30 <johnw> hrpmh
16:07:38 <JoeyA> But I was recommending something different: use the newtype COid in your lowest-level binding to clarify the role of the parameter and to guard against misuse by your higher-level binding.
16:07:41 <ski> johnw : your  if c < 0 then LT else if c > 0 then GT else EQ  could be just  c `compare` 0
16:07:55 <merijn> mm_freak_: ok, bed time now. I'll yell at you if I get stuck with the haddock docs ;)
16:08:01 <JoeyA> But I guess you can't do that with the tool you're using.
16:08:03 <johnw> ski: cool!
16:08:14 <mm_freak_> merijn: great, i'm looking forward to your feedback =)
16:08:18 <mm_freak_> good night
16:08:22 <johnw> dunno why I didn't think of that
16:08:24 <ski> > map (`compare` 0) [-2 .. 2]
16:08:25 <lambdabot>   [LT,LT,EQ,GT,GT]
16:09:00 <johnw> JoeyA: if I have my newtype Oid = ForeignPtr C'git_oid, how do I "get at" the ForeignPtr now?
16:09:07 <johnw> I can't pass it to withForeignPtr anymore
16:09:14 <sinelaw> does anyone know what happened to Data.IntMap.Lens ?
16:09:23 <JoeyA> By the way, I really really hate {-# OPTIONS_HADDOCK hide #-}
16:09:26 <sinelaw> since version 2.7 it's gone
16:09:28 <JoeyA> http://www.haskell.org/hoogle/?hoogle=ForeignPtr
16:09:33 <JoeyA> First link is a 404
16:09:39 <ski> johnw : match, or use a selector
16:09:48 <edwardk> sinelaw: it didnt have anything left in it once i made At a class, and added classes for TraverseMax, TraverseMin and TraverseWithIndex
16:10:05 <ski> johnw : also i think you mean  newtype Oid = MkOid (ForeignPtr C'git_oid)
16:10:07 <JoeyA> johnw: It's newtype Oid = Oid (ForeignPtr C'git_oid)
16:10:13 <gertc> hmm filter ((== fst x) . fst) should do it i think
16:10:22 <JoeyA> You do this: compareOid (Oid a) (Oid b) = withForeignPtr a $ ...
16:10:47 <aristid> :t (==) `on` fst
16:10:48 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
16:11:08 <sinelaw> edwardk, so what should i do? I have a package that references it
16:11:19 <JoeyA> groupBy ((==) `on` fst), maybe?
16:11:19 <johnw> ah, that worked
16:11:21 <edwardk> sinelaw: remove the reference, the code should still work
16:11:22 <Nereid> @type (&&) <$> ((==) `on` fst) <*> ((==) `on` snd)
16:11:23 <lambdabot>     Couldn't match expected type `Bool'
16:11:23 <lambdabot>            against inferred type `(a, b) -> Bool'
16:11:23 <lambdabot>     Probable cause: `on' is applied to too few arguments
16:11:25 <Nereid> oops.
16:11:32 <Nereid> duh.
16:11:39 <edwardk> sinelaw: what method did you need out of it? they are all provided by Control.Lens now
16:11:44 <hpaste> johnw pasted “Oid.hs (2)” at http://hpaste.org/74811
16:11:55 <Nereid> nm
16:12:10 <sinelaw> edwardk, at
16:12:25 <edwardk> sinelaw: at is exported by Control.Lens now its in the At class
16:12:38 <sinelaw> edwardk, ok
16:12:42 <edwardk> look in Control.Lens.IndexedLens for the code
16:14:30 <sinelaw> edwardk, what about IntSet.Lens.contains?
16:16:43 <edwardk> contains is in Control.Lens as well
16:16:53 <edwardk> and generalized to work with IntSet, HashSet, and Set
16:17:13 <sinelaw> ok
16:17:19 <edwardk> when in doubt if i removed a module its contents were generalized and exported from Control.Lens ;)
16:41:59 * hackagebot network-multicast 0.0.7 - Simple multicast library  http://hackage.haskell.org/package/network-multicast-0.0.7 (AudreyTang)
16:46:10 <johnw> @pl (\x y z -> f x y z w)
16:46:10 <lambdabot> flip flip w . (flip .) . f
16:46:18 <johnw> yeah, um, no
16:48:52 <Raheem> Anyone here interested in making sketches for an upcoming game???
16:51:14 <zalzane> dat k-line
16:55:14 <lightquake> i'm still not sure if i want to use hsenv or cabal-dev.
16:55:30 <fragamus> Is there any way to use Haskell for IOS development?  Emit C code perhaps?
16:55:46 <shapr> fragamus: I know iPwn studios was doing that. I dunno about their environment.
16:56:38 <lightquake> i think i like cabal-dev with sandboxer the most, to be honest, but that's probably personal bias
16:56:40 <c_wraith> ask Cale about that.
16:57:46 <lightquake> wasn't someone working on a system where you have one gigantic immutable package database?
16:58:14 <Cale> ask Stephen Blackheath (blackh) about that
16:59:55 <Cale> fragamus: and yes, there's a cross compiling "toolchain" mode in GHC for that purpose. I believe it should be available publically in 7.6 already, but I'm not 100% sure how to use it on my own :)
17:00:27 <Cale> Stephen was responsible for that stuff, and you should definitely talk to him if you're interested in doing Haskell on iOS or other ARM platforms.
17:00:31 <luite> does that toolchain work with TH somehow?
17:00:31 <fragamus> Thanx
17:01:01 <Cale> luite: I'm not sure if TH is fully supported or not. There was a bunch of discussion about how to accomplish that.
17:03:33 <linux2342> Is there any way to print a variables type within a funciton?
17:03:42 <luite> Cale: ah. i'm working on ghcjs which is sort of a cross compiler, it currently builds native code along with javascript to support TH, was wondering if there's some better approach :)
17:05:07 <Cale> linux2342: Types are compile-time phenomena and don't exist at runtime unless they're explicitly encoded somehow.
17:05:25 <Cale> linux2342: There is a type class called Typeable for this purpose, but what are you trying to accomplish?
17:05:59 <linux2342> Cale: I'm just trying to find an easy way to debug my functions.
17:06:01 <typoclass> linux2342: you might be interested in ":t" in ghci
17:06:04 <typoclass> :t map
17:06:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:06:20 <linux2342> I know about :t, but that doesn't help me inside functions.
17:07:03 <Cale> linux2342: You can guess at a type signature in your program, and if you're wrong, GHC will print out what it thinks the type is.
17:07:07 <typoclass> linux2342: so you're interested in what type ghc inferred for stuff you defined in 'let' or 'where'?
17:07:13 <lightquake> ah, so you want to get, for example, the type of myMap in let myMap = map in myMap succ [1,2,3]
17:07:27 <maukd> :t ?myMap succ [1,2,3]
17:07:28 <lambdabot> forall t a t1. (?myMap::(a -> a) -> [t1] -> t, Enum a, Num t1) => t
17:07:50 <maukd> :t map ?succ [1,2,3]
17:07:51 <lambdabot> forall a b. (?succ::a -> b, Num a) => [b]
17:08:07 <linux2342> Ok, I'll try using :t again. Thanks.
17:08:42 <lightquake> yeah, you can use implicit parameters. the other option is to do pick a type that's obviously wrong and do this
17:08:51 <Cale> linux2342: I'm saying try attaching a signature like (... :: Integer) to the thing which you wanted to know the inferred type of.
17:08:52 <lightquake> > let f = (map succ) :: Int in f [1,2,3]
17:08:53 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:08:53 <lambdabot>         against inferred type ...
17:09:14 <linux2342> Ah I see.
17:09:17 <Cale> linux2342: if it's actually an Integer, that'll succeed, and if not, then GHC will tell you the inferred type.
17:09:31 <Cale> Here's blackh now :)
17:09:41 <typoclass> linux2342: lambdabot didn't print the full error message there, but ghc will
17:09:42 <Cale> fragamus: ^^
17:09:44 <lightquake> i really want to integrate that into my an IDE :/
17:09:50 <lightquake> s/my//
17:10:41 <lightquake> haskell has a really powerful type system, but it seems like there's very little support for it in emacs, which is a shame
17:11:11 <maukd> :t map (succ `asTypeOf` ?foo) [1,2,3]
17:11:12 <lambdabot> forall a. (Enum a, ?foo::a -> a, Num a) => [a]
17:11:36 <lightquake> oh, the asTypeOf thing is really clever
17:14:32 <lightquake> i wish you could tell ghc to just typecheck something
17:14:51 <randomclown> @pl \x -> (temp ++ show x)
17:14:51 <lambdabot> (temp ++) . show
17:15:46 <lightquake> maybe there's something in the ghc api for it
17:15:56 <gwern> yeah
17:16:20 <gwern> look at mueval, for example, with the type flag. or look at lambdabot's :type
17:16:50 <lightquake> neat
17:17:42 <maukd> will ghc 8 support -fignore-errors?
17:18:32 <lightquake> -fignore-errors?
17:18:59 <lightquake> oh, i thought that was a real flag for a second
17:21:58 <lightquake> gwern: what's the type flag?
17:22:15 <gwern> lightquake: dunno, that's what the --help flag is for
17:22:23 <gwern> I write this stuff down so I don't have to remember it
17:22:41 <lightquake> fair enough :v
17:23:07 <lightquake> but yeah it looks like it should be doable. if GHC has a way of getting at the parsed AST before typechecking i can even modify it to add the `asTypeOf` myself
17:25:05 <luite> you can also extract the types from the ast after typechecking
17:27:02 <luite> (although it's a bit involved since not every node has type information)
17:27:14 <lightquake> what nodes don't have type information?
17:27:52 <luite> uh i forgot, but i did write some code to reconstruct it
17:28:31 <lightquake> although, i think eventually i might want to support getting the type of an arbitrary subexpression
17:28:36 --- mode: wolfe.freenode.net set +o ChanServ
17:28:55 <lightquake> as opposed to the type of a single node
17:29:43 <luite> yeah that's what i wrote the code for, it's not quite finished though
17:30:01 <lightquake> ah neat
17:35:43 <dfeuer> =
17:35:48 <dfeuer> Sorry about that.
17:37:58 <monochrom> ghc 8 will support -fdefer-kind-errors :)
17:38:19 <sipa> -funsafe-typelevel-IO
17:38:19 <c_wraith> haha
17:38:41 <c_wraith> type-level IO.  that sounds fun, safe or not.
17:38:59 <cmccann> personally I'm just waiting for an extension that demotes types to the value level, so that we can finally have natural numbers.
17:39:19 <shachaf> @remember cmccann personally I'm just waiting for an extension that demotes types to the value level, so that we can finally have natural numbers.
17:39:19 <lambdabot> Done.
17:39:26 <cmccann> :D
17:40:13 <johnw> c_wraith: CL has macro iO :)
17:40:43 <shachaf> And Template Haskell can do IO. It's not the same.
17:40:50 <johnw> ah
17:42:11 <c_wraith> do the lisps have runtime macro expansion?
17:42:18 <johnw> yes
17:42:22 <c_wraith> that's cool
17:42:25 <johnw> macroexpand
17:42:43 <latro`a> the way I learned it
17:42:45 <thetallguy1> lisps have runtime everything
17:42:47 <latro`a> lisps just don't even have run/compile time
17:42:57 <latro`a> that distinction just doesn't even exist
17:43:04 <Dodek> latro`a: that's not true.
17:43:11 <monochrom> @quote monochrom hugs
17:43:11 <lambdabot> No quotes match. Just what do you think you're doing Dave?
17:43:42 <latro`a> it's exaggerated
17:43:44 <latro`a> but closeish
17:45:29 <parcs`> sipa: IOW -XTemplateHaskell
17:47:14 <parcs`> oops shachaf beat me to it
17:57:52 <johnw> i think lift f x should be f $$ x
17:57:59 <johnw> and so on far $$$, etc.
17:58:22 <johnw> although I guess it has to be lift $ f x?
17:58:41 <johnw> i'm lifting the monadic value, not the function
17:58:43 <startling> johnw, why not just use applicative style?
17:58:51 <johnw> it can lift?
17:59:08 <johnw> my question relates to monad transformers
17:59:28 <startling> johnw: fn <$> a <*> b rather than liftM2 fn a b
17:59:38 <startling> oh, you're talking about liftIO and friends, aren't you
17:59:42 <johnw> yes
18:01:53 <otters> what exactly is a "statement"
18:01:56 <otters> data Stmt = BindS Pat Exp | LetS [Dec] | NoBindS Exp | ParS [[Stmt]]
18:02:01 * hackagebot hlibgit2 0.5.0 - Low-level bindings to libgit2.  http://hackage.haskell.org/package/hlibgit2-0.5.0 (JohnWiegley)
18:02:03 <otters> from Language.Haskell.TH.Syntax
18:02:07 <otters> and I have no idea what that represents
18:02:17 <startling> @hoogle (a -> b) -> (a -> b) -> [a] -> [b]
18:02:17 <lambdabot> Data.Generics.Aliases extQ :: (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q
18:02:17 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
18:02:17 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
18:02:44 <startling> otters, maybe lines in `do` ?
18:02:59 <otters> It appears to be part of a Guard
18:03:10 <otters> where Guard is NormalG Exp | PatG [Stmt]
18:03:40 <otters> And I'd thinking using "let" and such in guards would be covered by NormalG Exp
18:03:55 <otters> Oh, wait, pattern guards.
18:04:54 <ski> > [x | x <- [0 .. 9] , let y = x `mod` 2 in y /= 0 , let z = x `mod` 3 , z /= 0]
18:04:55 <lambdabot>   [1,5,7]
18:05:33 <ski> otters : note that the former is a `let ... in ...', while the latter is a `let ...'
18:05:39 <otters> Right
18:05:58 <ski> i think the former would be a `NormalG', while the latter a `PatG' (containing a `LetS')
18:07:25 <otters> so what exactly is ParS?
18:08:03 <ski> perhaps it's used in `[x + y | x <- [0 .. 3] | y <- [4 .. 7]]', not sure
18:08:14 <otters> no, that's covered in CompE
18:08:26 <otters> ParS is part of a guard
18:08:56 <otters> eh, I'll just use "error" for that eventuality and figure it out then
18:12:47 <pharaun> heh no documentation for hlibgit2
18:13:14 <pharaun> i noticed some modules lists the modules but have no links/docs
18:15:38 <otters> ski: I think you're right, it might be a comprehension
18:16:06 <otters> I actually don't know how CompE works because a list comprehension has two separate parts before and after |
18:16:11 <otters> but CompE just holds [Stmt]
18:19:18 <geekosaur> monad comprehension?
18:19:39 <otters> I'll use error ._.
18:20:07 <centrinia> o_O
18:20:20 <otters> no, I mean, to output the contents of CompE during runtime
18:20:24 <otters> so that I can figure out what's going on
18:22:01 <cmccann> trying to figure out what CompE means in TH?
18:22:53 <cmccann> have you looked at the source where CompE is defined? there's a few more details there.
18:24:55 <otters> no, I haven't
18:25:08 <otters> oh, wow, there's an explanation right at the top
18:25:12 <cmccann> http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/src/Language-Haskell-TH-Syntax.html#Exp
18:25:13 <otters> christ
18:25:29 <randomclown> should stateT wrap errorT or errorT wrap stateT
18:26:19 <cmccann> looks like most of that is actual haddock comments but for future reference sometimes there's more info buried in comments that haddock doesn't see
18:27:00 <cmccann> randomclown, should I lock my front door when I'm on the inside of it, or the outside?
18:28:34 <YayMe_> cmccann: Both, you just can't trust that schroedingers poison isn't on the other side!
18:28:47 <cmccann> good point, better avoid doors entirely.
18:32:27 <startling> how do I compose a list of Simple Lens a (Maybe a) ?
18:32:36 <edwardk> you don't
18:32:43 <edwardk> not as a lens
18:32:53 <edwardk> as a fold, you can, or as a traversal you can
18:33:01 <cmccann> obviously if you have a bunch of lenses you need to build a telescope instead
18:33:06 <startling> edwardk, why can't it be a lens?
18:33:43 <copumpkin> cmccann: oddly enough, a telescope is a real thing in dependent contexts!
18:33:50 <edwardk> startling: because it quotients out information. i only have one maybe to tell me the state of 7 distinct maybes
18:33:51 <copumpkin> we need to get ed to make dependent lenses
18:33:56 <cmccann> hahaha
18:34:20 <edwardk> startling: consider the base case. you have two maps. a Map k (Map k v)
18:34:32 <shachaf> A telescope is a list where the types of later elements can depend on values of earlier elements, right?
18:34:51 <edwardk> startling: now if i insert with this lens, i'm putting an element in the element of the first map that i found, _or making one if that entry didn't exist_
18:34:53 <edwardk> note the or
18:35:01 <Rotaerk> isn't a telescope a tool used to look at distant objects?
18:35:07 <edwardk> now if i go to undo that by setting the target to Nothing, i've lost that information
18:35:13 <edwardk> and so can't meet the lens laws
18:35:15 <startling> edwardk: oh, I see
18:35:33 <edwardk> i have to choose to do one of two things, and both violate the laws
18:35:55 <edwardk> now if you have some kind of trie structure that maintains some invariants about how the nested maps are used, you might be able to justify a lens
18:36:01 <edwardk> but in the general case you can't
18:40:03 <dncr> so there's the TH stuff to derive Data.Generics.SYB.WithClass.Basics.Data; no ghc extension that does it?
19:00:50 <nejucomo> Ok...  so I can curl an https address just fine, and using tcpdump I see many packets.
19:01:05 <jozy> How can I create list of list of integers, so have all way of set I can create from list of integer in same order. For example if I have list like [1,2,3,4] , I will get list like [[1234], [1,234] [12,34] [123,4] [1,2,34], [123,4], [12,3,4], [1,2,3,4] ] :/
19:01:29 <nejucomo> However, when I use Network.HTTP.Conduit (simpleHTTP), it hangs apparently indefinitely.
19:01:47 <nejucomo> I see some ssl packets (much fewer than the curl case).
19:02:09 <nejucomo> Where can I learn about debugging haskell?  Specifically, debugging a library, rather than my own code.
19:02:12 <nejucomo> Do I need to build the library myself?
19:03:28 <dmwit> DataKinds are better than I realized.
19:03:38 <dmwit> I keep reaching for typeclasses and then realizing I don't need them.
19:04:12 <dmwit> nejucomo: Yes, debugging library code involves having the library source lying around.
19:04:25 <dmwit> You can use the ghci debugger then from within the directory containing the library's source.
19:04:54 <nejucomo> Thanks.
19:05:18 <dmwit> jozy: What have you tried?
19:05:22 <centrinia> :t partition
19:05:24 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:05:31 <shachaf> dmwit: Hooray for not needing type classes.
19:06:05 <centrinia> jozy, research set partitions.
19:06:21 <nejucomo> These links (first hits from a query) seems to be about debugging ghc itself, or using gdb to debug crashes: http://hackage.haskell.org/trac/ghc/wiki/Debugging http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode
19:06:21 <dmwit> shachaf: http://stackoverflow.com/a/12443788/791604 if you want to see what I mean, odd numbers are my first instinct and even numbers are the classless versions
19:06:34 * nejucomo searches for ghci debugger.
19:06:45 <dmwit> ?google ghci debugger
19:06:46 <lambdabot> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/ghci-debugger.html
19:06:46 <lambdabot> Title: 2.5.�The GHCi Debugger
19:06:51 <dmwit> that looks good
19:07:33 <nejucomo> I installed http-conduit via cabal.  Doesn't that compile from source?  I don't suppose the source is lying around somewhere?
19:07:50 * nejucomo checks cabal config to see if it's possible to always keep source...
19:08:04 <Jafet> .cabal/packages/hackage.haskell.org/http-conduit*
19:08:06 <dmwit> nejucomo: It does compile from source; however, having installed the library from source is not sufficient. You must actually have the source available for ghci to inspect.
19:08:20 <dmwit> nejucomo: You can make a directory with the unpacked source via "cabal unpack http-conduit".
19:08:58 <maukd> :t let foo [] = []; foo [x] = [[[x]]]; foo (x : xs) = concatMap (\cs@(ch : ct) -> [[x] : cs, (x : ch) : ct]) (foo xs) in foo
19:08:59 <lambdabot> forall t. [t] -> [[[t]]]
19:08:59 <dmwit> You need to either start ghci from within the appropriate directory or add a flag (perhaps -i?) telling ghci where to look.
19:09:11 <maukd> > let foo [] = []; foo [x] = [[[x]]]; foo (x : xs) = concatMap (\cs@(ch : ct) -> [[x] : cs, (x : ch) : ct]) (foo xs) in foo "abcd"
19:09:12 <lambdabot>   [["a","b","c","d"],["ab","c","d"],["a","bc","d"],["abc","d"],["a","b","cd"]...
19:09:32 <nejucomo> dmwit: That's what I was looking for.  I assume this is similar to "apt-get source $package".  Am I guaranteed to always get the exact source I have installed?
19:09:50 <maukd> > let foo [] = []; foo [x] = [[[x]]]; foo (x : xs) = concatMap (\cs@(ch : ct) -> [[x] : cs, (x : ch) : ct]) (foo xs) in foo "abc"
19:09:51 <lambdabot>   [["a","b","c"],["ab","c"],["a","bc"],["abc"]]
19:09:53 <nejucomo> I would rather keep the actual source the installed library was build from, rather than refetching something hopefully similar.
19:09:55 <dmwit> No, I suppose not, though you can ask for the source of a specific version in the usual way.
19:10:00 <nejucomo> Ok.
19:10:03 <dmwit> cabal unpack http-conduit-0.0.0 or whatever
19:10:08 <cmccann> hm. my toy linear logic stuff seems to be working except that it's a huge pain to actually run a linear function.
19:10:14 <nejucomo> Thanks a lot for the tips!
19:10:27 <cmccann> fortunately I didn't have any actual plans to use this for anything, so ha.
19:10:58 <shachaf> maukd++
19:11:13 <maukd> I'm not happy with the base cases
19:11:47 <dmwit> cmccann: www.monoidal.net/papers/qhaskell.pdf
19:12:07 <shachaf> Is that base case necessary in order to make the pattern match always be (:)?
19:12:14 <shachaf> Hmm, no.
19:12:38 <shachaf> Oh, yes.
19:13:25 <cmccann> dmwit, ooh that looks neat.
19:13:30 * cmccann saves the pdf to read later.
19:13:48 <shachaf> > let foo [] = [[]]; foo (x : xs) = concatMap (\cs -> [[x]:cs] ++ (case cs of [] -> []; (ch : ct) -> [(x : ch) : ct])) (foo xs) in foo "abcd"
19:13:50 <lambdabot>   [["a","b","c","d"],["ab","c","d"],["a","bc","d"],["abc","d"],["a","b","cd"]...
19:13:51 <shachaf> But that's ugly too.
19:14:09 <jfischoff> is it possible, perhaps unsafely, to load a file into contiguous block of memory as fast as C (between friends)?
19:14:10 <cmccann> there really isn't enough stuff about linear logic out there. :[
19:14:49 <rwbarton> jfischoff, there's mmap-bytestring
19:15:07 <rwbarton> it will mmap a file and point a bytestring at the result
19:15:17 <dmwit> cmccann: Also of interest in that paper: I believe this is the example I keep forgetting how to find of a functional dependency that can't be readily translated into a type family.
19:15:32 <maukd> jfischoff: how do you do it in C?
19:15:32 <jfischoff> rwbarton: thanks I'll check it out
19:15:59 <cmccann> dmwit, not trickery involving overlapping instances I assume?
19:16:05 <shachaf> Note that mmap probably doesn't interact very well with the GHC IO manager (maybe).
19:16:11 <dmwit> nope
19:16:35 <jfischoff> maukd: specifically in this case I would start by heading the header of a file (about 40 bytes) and then allocate a buffer for the rest of the file and copy it into it
19:16:50 <maukd> that's not very specific
19:17:14 <cmccann> dmwit, anyway, my toy linear logic stuff is much simpler than that, heh
19:17:23 <dmwit> =)
19:17:34 <nejucomo> Hrm.  Ok, next snag: this library uses the c preprocessor, but when I try :l in ghci various C macros are not defined...
19:17:38 <dmwit> Yes, it's hard work to embed one type checker in a another.
19:17:43 <hpaste> “Jonathan Fischoff” pasted “loading a wave file with c” at http://hpaste.org/74813
19:17:45 <dmwit> Possibly simpler just to write the other type checker. =P
19:17:55 <nejucomo> Namely MIN_VERSION_base
19:18:05 <shachaf> @let fold1 :: b -> (a -> [a] -> b) -> [a] -> b; fold1 z f [] = z; fold1 z f (x:xs) = f x xs
19:18:06 <lambdabot>  Defined.
19:18:07 <dmwit> nejucomo: Ah, that is a snag.
19:18:10 <shachaf> Does that function have a name?
19:18:12 <jfischoff> maukd: ^ fyi: I haven't even tried to run the code yet
19:18:13 <nejucomo> How can I determine what value was used for that macro when cabal built this package?
19:18:17 <dmwit> It should be possible to cabal build and then use the source from the dist/ directory instead.
19:18:20 * nejucomo looks at the cabal build log.
19:18:34 <nejucomo> dmwit: Good idea.
19:18:55 <jfischoff> maukd: look at the loadWave function
19:18:57 <dmwit> shachaf: don't think so
19:19:15 <rwbarton> some people call it "list"
19:19:31 <shachaf> I thought "list" would be foldr.
19:19:32 <cmccann> dmwit, I'm not doing anything fancy with types here, just a direct implementation. could make linear implication a Category instance except the kind doesn't match. :T
19:19:33 <nejucomo> It rubs my fur a bit wrong that the cpp is used instead of something more syntax-aware.  Can one accomplish the same things with template haskell?
19:19:39 <rwbarton> no, foldr is foldr :)
19:19:39 <nejucomo> I'm not familiar with the latter.
19:19:44 <shachaf> I guess in the case on nonrecursive types they're indistinguishable.
19:19:51 <rwbarton> yeah
19:20:02 <shachaf> I always thought of "maybe" and "either" and "bool" as folds.
19:20:06 <shachaf> Rather than this weird one-level thing.
19:20:43 <Cale> nejucomo: You generally wouldn't do the same things with Template Haskell, I think.
19:21:03 <cmccann> foldr, maybe, either, &c. all give you church encodings
19:21:15 <nejucomo> When I try :l from ./dist/build/ I get "module `Network.HTTP.Conduit' is a package module".  Is this an import/export resolution problem?
19:21:18 <cmccann> if you finagle the argument order a bit, at least
19:21:20 <shachaf> cmccann: Right, but the non-recursive ones also give you this other encoding.
19:21:37 <shachaf> Well, calling it an "encoding" is a bit strange.
19:21:51 <rwbarton> encoding in terms of itself
19:21:53 <maukd> let's call it "scott"
19:21:53 <shachaf> Hmm, I guess this is a CPSed uncons?
19:21:55 <Cale> nejucomo: CPP has one advantage over TH, which is that it's exceedingly simple. People use it for deciding which large blocks of code to use based on compile-time options, rather than really for expanding macros.
19:22:03 <maukd> that's a fine name
19:22:03 <cmccann> yeah, was gonna say, isn't that a scott encoding?
19:22:07 <rwbarton> yes, it is a top-level pattern match
19:22:11 <Cale> nejucomo: (at least in Haskell-land)
19:22:15 <shachaf> uncons :: [a] -> Maybe (a,[a])
19:22:17 <cmccann> which happen to coincide with church encodings for non-recursive types
19:22:22 <shachaf> Is that what Scott encoding is?
19:22:31 <nejucomo> Cale: I agree it's simple and widely used which are good, but it has some annoying failure modes.
19:22:35 <dmwit> ?hackage first-class-patterns
19:22:35 <lambdabot> http://hackage.haskell.org/package/first-class-patterns
19:22:39 <Cale> I think I actually have seen something use CPP macros, though that's a bit weird. :)
19:22:41 <nejucomo> It's still a universe better than M4 though!
19:22:44 <cmccann> if memory serves me, but other people probably remember better
19:22:52 <Cale> nejucomo: Basically most people stick to #ifdef
19:23:27 <nejucomo> I almost want first-class language syntax for conditional compilation.
19:23:35 <nejucomo> -but I haven't carefully thought how that would work.
19:26:48 <nejucomo> Could I be getting this "module `Network.HTTP.Conduit' is a package module" error because ghci is not looking in the current directory but is finding the cabal-installed version?
19:27:20 <Cale> yes
19:27:22 <nejucomo> A google search for that phrase hasn't panned out.
19:27:25 <nejucomo> Ok.
19:27:38 <Cale> Do you have a directory called Network in your current directory?
19:27:55 * nejucomo double checks.
19:28:13 <Cale> (or are you *in* the directory called Network?)
19:28:31 <nejucomo> Yes.  Ah, I see the problem...
19:28:48 <nejucomo> I'm in ./dist/build and I just assumed Network contained sources, but it does not.
19:29:12 <nejucomo> I need to figure out how to tell cabal to run the preprocessor and then stop at that stage, leaving the source somewhere.
19:29:59 <nejucomo> Since cabal builds from source (at least sometimes?) it would be quite useful to a: keep the source around, and b: include source reference info in the package db for easy debugging.
19:30:10 <nejucomo> -probably as an optionally configured feature.
19:32:03 * hackagebot tagstream-conduit 0.5.3 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.3 (YiHuang)
19:33:55 * nejucomo is reading cabal's setup foo commands to see if there's a "do cpp then stop" command...
19:34:31 <dmwit> eh, shouldn't you be in dist/src not dist/build?
19:34:48 <nejucomo> There is no ./dist/src.
19:35:15 <dmwit> seems as good a reason as any not to be there
19:38:50 <Fuuzetsu> I'm trying to compile the newest available ghc but it always breaks on docs with parsing errors such as docs/users_guide/runtime_control.xml:470: parser error : Entity 'lsqb' not defined
19:39:44 <Fuuzetsu> both git and nightly builds do that
19:42:20 <gienah> Fuuzetsu: I don't really know, maybe it might need more texlive stuff.
19:43:03 <gienah> Fuuzetsu: maybe you can workaround it with stuff like: echo "BUILD_DOCBOOK_PDF  = NO"  >> mk/build.mk
19:43:14 <gienah> Fuuzetsu: like in: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-lang/ghc/ghc-7.6.1.ebuild
19:43:32 <gienah> Fuuzetsu: and: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-lang/ghc/ghc-9999.ebuild
19:43:55 <Fuuzetsu> noted...
19:44:25 <Fuuzetsu> didn't think 7.6 made it into the overlay now
19:44:41 <gienah> Fuuzetsu: yeah, just no KEYWORDS
19:45:28 <gienah> Fuuzetsu: and some stuff like glib does not build with >=ghc-7.6.1
19:45:48 <Fuuzetsu> oh?
19:46:38 <hpaste> gienah pasted “glib 0.12.3.1 build fails with ghc 7.6.1” at http://hpaste.org/74814
19:48:39 <Fuuzetsu> would you not recommend updating then?
19:50:01 <gienah> Fuuzetsu: I guess its hard for me to recommend it when I know there is about 100 pkgs that fail to build, but some stuff like the current yesod does build
19:50:28 <nejucomo> Well, for my purposes I think it will be easier/faster to modify the library source and put printfs in various places.  :-/
19:51:54 <Cale> Fuuzetsu: also, if you do update, compiling GHC yourself is a pretty pointless thing to do unless you're modifying the source.
19:52:23 <Cale> You need a working GHC binary to compile GHC anyway, so why not just grab the latest binary?
19:52:30 <Fuuzetsu> Cale: such is the way of Gentoo
19:52:41 <nejucomo> -or use deduction.  Both https urls return JSON.  Both successfully curl.  One succeeds with Network.HTTP.Conduit (simpleHTTP), but the other hangs.
19:52:52 * Cale <-- blames Gentoo for the heat-death of the universe
19:53:07 <nejucomo> One has "content-type: text/html" and the other "content-type: application/json; charset=utf-8"
19:53:36 <Fuuzetsu> hey, 90C doesn't make me sweat THAT much
19:53:43 <Cale> It's pointless to recompile things to (hopefully!) obtain the same result as you could just download.
19:53:49 <nejucomo> I'm using simpleHTTP to return a Text though, so I don't see how http-conduit could get confused that way.
19:53:54 <nejucomo> The charset could be related...
19:54:01 <Fuuzetsu> e-peen
19:54:07 <gienah> Cale: on Gentoo its necessary to build ghc from source (using an earlier gentoo ghc binary) unless a binary is available. I think there might be a ghc 7.6.1 gentoo amd64 binary.
19:54:43 <Cale> gienah: At one point I actually made sure that gentoo had a current binary package for GHC (and they did)
19:54:56 <Fuuzetsu> I'll be sticking to ~7.4.2 for now
19:55:00 <Cale> But that was a long time ago, it's possible their policy has changed.
19:55:26 <Cale> It would be silly to distribute an old GHC binary that people would have to get and install in order to compile the latest.
19:55:44 <gienah> Cale: no, we have gentoo ghc 7.6.1 binarys for amd64 and x86 so far, and other platforms with ghc 7.4.1 that can be used to hopefully build 7.6.1 on other platforms
19:55:56 <Cale> Even if you're insisting on compiling it, you might as well compile it with the latest GHC.
19:57:00 * nejucomo compiles ghc.  ;-)
19:57:19 <nejucomo> Yes, I'm "one of those" people.
19:57:32 <Fuuzetsu> dev-lang/ghc Available versions:  (~)6.10.4-r1 (~)6.10.4-r1[1] 6.12.3 6.12.3[1] 6.12.3-r2 6.12.3-r2[1] (~)7.0.4 (~)7.0.4[1] (~)7.4.1 (~)7.4.1[1] (~)7.4.1-r1 (~)7.4.1-r1[1] (~)7.4.2[1] **7.5.20120608[1] **7.5.20120615[1] **7.5.20120711[1] **9999[1]
19:57:44 <lightquake> is there a way to print a textual representation of a Q [Dec]?
19:57:48 <nejucomo> -with a distaste for ever running binaries (except for debian packages).
19:58:11 <adanuseam> here here
19:58:29 <nejucomo> But lately I've realized I *also* don't want to "automatically install" unsigned packages, which makes me sad for cabal and python's pip.
19:58:42 <nejucomo> (And most packaging systems...)
19:59:17 <Fuuzetsu> can't you force it to ask?
19:59:27 <dmwit> ...a distaste for ever running binaries?
19:59:31 <dmwit> Surely that can't be right.
19:59:42 <maukd> can I upload a malicious build script to hackage and own the server?
20:00:16 * adanuseam sets up his camera
20:00:23 <adanuseam> we've got the making of a good film right here :o
20:00:27 <gienah> Fuuzetsu: that list of ghc versions looks out of date
20:00:59 <Fuuzetsu> gienah: I synced 5 mins ago
20:01:26 <Fuuzetsu> ACCEPT_KEYWORDS="~x86"
20:01:53 <dmwit> Cale: (One good reason not to just grab the binary is if your version of gmp doesn't match HQ's.)
20:02:45 <Cale> dmwit: Yeah, that whole situation sucks.
20:02:58 <Cale> dmwit: But I think I'd rather just grab a GMP binary
20:03:20 <gienah> Fuuzetsu: I guess your sync didn't really work, the current list of ghc versions is here: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-lang/ghc
20:03:20 <copumpkin> omg talk of GMP?
20:06:49 <Fuuzetsu> No idea why it doesn't come up...
20:07:29 <gienah> Fuuzetsu: maybe it needs: git pull --rebase
20:08:52 <Fuuzetsu> worked it out
20:10:10 <gienah> Fuuzetsu: we have a channel: #gentoo-haskell
20:11:46 <Fuuzetsu> I was in there... Might have forgotten to add it to auto-join...
20:11:58 <Fuuzetsu> [I] dev-lang/ghc Available versions:  (~)6.10.4-r1 (~)6.10.4-r1[1] 6.12.3 6.12.3[1] 6.12.3-r2 6.12.3-r2[1] (~)7.0.4 (~)7.0.4[1] (~)7.4.1 (~)7.4.1[1] (~)7.4.1-r1 (~)7.4.1-r1[1] (~)7.4.2[1] **7.6.1[1] **7.7.20120806[1] **9999[1]
20:12:02 <Fuuzetsu> ~
20:12:04 <Jafet> cd gmp* && ./configure CFLAGS='-O99 -march=native -f-f-f-fast-math -fomit-instruction-pointer'
20:12:20 <shachaf> -fomit-instruction-pointer
20:12:25 <gienah> Fuuzetsu: that looks better
20:12:26 * shachaf hopes GCC implements that.
20:13:19 <lightquake> shachaf: ha
20:13:24 <maukd> gcc -Larry -Wall -malign-double
20:14:04 <Jafet> I wonder if you can build gmp with -ftree-parallelize-loops.
20:21:52 <randomclown> @pl \x y -> x /= '|' && y /= '|'
20:21:52 <lambdabot> (. ('|' /=)) . (&&) . ('|' /=)
20:22:44 <pdxleif> pretty
20:22:47 <shachaf> @pl \x y -> [x,y] /= "||"
20:22:47 <lambdabot> flip flip "||" . ((/=) .) . (. return) . (:)
20:23:04 <randomclown> @pl \x y -> x == y && y /= '|'
20:23:04 <lambdabot> (`ap` ('|' /=)) . ((&&) .) . (==)
20:23:28 <shachaf> @pl \x y -> ('|','|') /= (x,y)
20:23:28 <lambdabot> ((('|', '|') /=) .) . (,)
20:23:32 <pr> > ["ab", "cd"] /= "ab"
20:23:33 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:23:33 <lambdabot>         against inferred ty...
20:23:34 <shachaf> There y'go, crystal-clear.
20:27:16 <Jafet> :t curry(('|','|')==)
20:27:16 <lambdabot> Char -> Char -> Bool
20:27:39 <shachaf> There's always that.
20:27:46 <lightquake> @pl \x y -> f x && f y
20:27:46 <lambdabot> (. f) . (&&) . f
20:28:18 <shachaf> @src on
20:28:18 <lambdabot> (*) `on` f = \x y -> f x * f y
20:29:14 <Fuuzetsu> :t curry
20:29:15 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:37:49 <mysticc> @hoodle reactimate
20:37:49 <lambdabot> No results found
20:54:48 <randomclown> hehe runIdentity $ runErrorT $ evalStateT driver 0
21:05:16 <dncr> if you want "instance MyClass MyData" in a separate module, which should the module name descend from? (1) Data.MyData.MyClassInstance, or (2) Data.MyClass.Instances.MyData?
21:05:47 <dncr> Data.Generics.SYB.WithClass.Instances.Text does (2)..
21:08:22 <mm_freak_> :t runIdentity . runErrorT
21:08:24 <lambdabot> forall e a. ErrorT e Identity a -> Either e a
21:08:30 <mm_freak_> :t runError
21:08:31 <lambdabot> Not in scope: `runError'
21:09:14 <mm_freak_> ErrorT e Identity is just a very weird Either e
21:09:55 <mm_freak_> dncr: there is no standard there, except that you should probably avoid orphan instances
21:11:37 <dncr> hm http://www.haskell.org/pipermail/libraries/2008-August/010399.html
21:12:31 <Rotaerk> hmm, is there a thorough book on haskell that doesn't rely so heavily on unnecessarily complicated examples (which is what real world haskell does)
21:12:58 <cmccann> complicated examples in what sense?
21:13:30 <cmccann> most of the stuff in RWH seemed straightforward to me, assuming the reader already knows how to program in something other than Haskell.
21:14:11 <Rotaerk> RWH just felt extremely slow, because all the haskell information is dilluted with unrelated information required to understand the examples
21:14:15 <thetallguy1> Rotaerk: I'm guessing you want Simon Thompson's book
21:14:23 <dncr> oh there's warnings for orphan instances?
21:14:26 <dncr> hmhmhm
21:14:44 <cmccann> ah, ok. dunno, lots of people like LYAH.
21:14:48 <cmccann> haven't read it myself though.
21:14:57 <cmccann> there's always the "gentle introduction" ;]
21:15:14 <Rotaerk> LYAH seemed incomplete last I checked it
21:15:20 <Rotaerk> at least, not as thorough as RWH
21:15:29 <thetallguy1> Rotaerk: There's also Graham Hutton's book
21:15:38 <Rotaerk> thanks, will check them out
21:19:57 <ddarius> The Gentle Introduction is definitely undiluted and is comprehensive for Haskell 98, but it doesn't go into "Haskell in practice" as it was written as a companion to the Report.
21:20:03 <ddarius> The Report is also pretty readable.
21:21:56 <Rotaerk> hmm well i learned F# from the specification, might as well do haskell too
21:23:06 <ddarius> As I said, the main problem with that is that "real" Haskell uses quite a few extensions and "non-standard" libraries.  A large part of learning Haskell is understanding the libraries.  The language itself is pretty minimal in many ways.
21:24:19 <latro`a> "real" doesn't even require getting all that advanced
21:24:20 <latro`a> even just mtl
21:24:26 <latro`a> is extension-heavy
21:24:34 <latro`a> and is pretty much omnipresent, to my knowledge
21:24:38 <latro`a> (or some variant like transformers)
21:26:45 <Rotaerk> ddarius, and would you say RWH is thorough in the sense of covering "real" haskell?
21:27:58 <Rotaerk> and is there something else you would consider thorough yet undilluted
21:28:19 <Rotaerk> or were you saying that's the case for Gentle Introduction, and making a distinction between "real" haskell and "haskell in practice"
21:30:56 <cmccann> "Haskell in practice" is largely defined as "GHC with a bunch of extensions enabled".
21:32:10 <Jafet> That also happens to be the definition of Haskell in theory.
21:32:14 <mgsloan> ddarius: Yeah, I saw a presentation where Oleg got mostly linguistics oriented people to understand almost all of Haskell 98 in a few 1hr classes
21:32:27 <mgsloan> the language is simple if you ignore the prelude
21:32:34 <mgsloan> (and other libraries)
21:33:01 <ddarius> Rotaerk: RWH is no longer comprehensive (if it was ever) but is probably the closest thing to covering the libraries and extensions people actually use.
21:33:33 <Rotaerk> hmm k
21:33:39 <cmccann> Haskell according to the standard is much simpler, and makes a fine starting point to later learn Haskell as it's used in practice
21:34:06 <ddarius> Typeclassopedia is a decent addendum to any resource.
21:34:13 <cmccann> very much so.
21:34:58 <ddarius> The GHC User Manual does, of course, cover all implemented extensions and is comprehensive.
21:44:31 * ddarius likes how signal processing literature just blithely uses (though usually defines) z^-1 for delays, something someone new to the field would have no hope of understanding.
22:02:58 <aa_> hi, I'm a newbie, pretty much. I want to write a project where I create behaviour from a static definition. If I was doing it with Python, say, I might dynamically create a class and add some methods to it. How would I do something like that in haskell?
22:03:39 <aa_> I know I should probably pick an easier starter project, but well, it has to be something I am interested in, right?
22:04:54 <kallisti> aa_: store functions within whatever data structure is applicable
22:11:05 <aa_> kallisti: that makes sense, ok, thanks. And I could just createthis functions as partial applications of something
22:11:36 <kallisti> aa_: sure
22:12:01 <aa_> ok thanks, I'm on my way
22:20:47 <randomclown> @pl \(x,y) -> (x, drop 1 y)
22:20:48 <lambdabot> second (drop 1)
22:21:03 <randomclown> :t second
22:21:04 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
22:21:20 <Jafet> a = (->)
22:56:15 <johnw> I'm going to split my higher-level types (Data.Git) out from hlibgit2.  Should I call the library git, data-git, or gitlib?
22:57:01 <shachaf> You're splitting out the types as their own library from another library?
22:57:05 <johnw> yes
22:57:15 <johnw> hlibgit2 will be just the FFI bindings
22:57:22 <shachaf> Why?
22:57:41 <johnw> it's far more stable than what I'm working on, and my code has far more depedencies
22:58:01 <johnw> and I can imagine people wanting to use the FFI bindings without my higher-level types
22:58:59 <shachaf> mm_freak_: Q: When is your key not secret?
22:59:01 <shachaf> A: When it's private!
22:59:13 <mm_freak_> =)
22:59:19 * shachaf contributes meaningfully.
22:59:44 <lightquake> i wonder why the fannkuch benchmark on the shootout is so much worse than the others
22:59:52 <johnw> shachaf: any recommendation on the name?
23:03:16 <shachaf> johnw: Not really.
23:03:30 <johnw> I think using "git" is a little presumptuous
23:03:35 <johnw> so I'll go with "gitlib"
23:03:35 <shachaf> "git" seems a little presumptuous unless it's -- yes.
23:03:41 <johnw> haha
23:07:08 * hackagebot hlibgit2 0.6.0 - Low-level bindings to libgit2.  http://hackage.haskell.org/package/hlibgit2-0.6.0 (JohnWiegley)
23:09:23 <pharaun> i kinda of like data-git but gitlib could work
23:09:43 <johnw> i'm open to suggestion
23:09:50 <johnw> having created the repo yet
23:10:09 <lightquake> ghit :V
23:11:41 <Jafet> Bon ghit
23:17:08 * hackagebot stringable 0.1.0 - A Stringable type class, in the spirit of Foldable and Traversable  http://hackage.haskell.org/package/stringable-0.1.0 (JohnWiegley)
23:17:23 <shachaf> johnw: Uh-oh.
23:17:32 <shachaf> I don't know what that is but it sounds like a terrible idea. :-(
23:18:40 <johnw> i don't suppose you're going to clarify
23:19:08 <shachaf> Maybe if I had some use cases for the type class. :-)
23:19:20 <johnw> well, I didn't create it just to create something
23:19:30 <shachaf> There's probably no point in arguing about the merits of that type class in general, though.
23:19:35 <johnw> this filled a need
23:20:01 <johnw> I want Data.Git to mostly agnostic of which string type people use to pass me SHA1 strings, etc.
23:20:09 <shachaf> Looking at it in particular, I *will* say that that ByteString thing looks wrong.
23:20:20 <johnw> ok?
23:20:21 <shachaf> ByteStrings aren't strings (of characters), they're bytes.
23:20:57 <johnw> yes, but they are convertable to/from strings
23:21:03 <shachaf> In many different ways.
23:21:19 <shachaf> UTF-8 is better than "everything's just ASCII, right?", but it's certainly not what all ByteStrings contain. Or even most.
23:21:25 <Jafet> Data.Stringable.Char8
23:21:38 <johnw> i just found myself needing to pass 4 different types to withCString, and I got tired of duplicating the conversion code all over the place
23:21:47 <johnw> especially when the function doesn't even need to know what type the incoming string is
23:21:48 <lightquake> i will say that one of my least favorite things about haskell is interop between libraries that expect a String/BS/Text
23:22:25 <shachaf> Yes, it's annoying. Most of the annoyingness is unnecessary.
23:22:28 <johnw> shachaf: yes, that is true, I make a bad assumption that all BS's that one wants to convert to/from strings contain UTF8
23:22:49 <lightquake> shachaf: so how do you suggest it be fixed?
23:23:15 <shachaf> What's some concrete code that's improved by this Stringable thing?
23:23:21 <Jafet> Since they all suck, you make your own string type..
23:23:33 <shachaf> lightquake: Well, some of it can't easily be fixed, because strings of bytes *aren't* strings of characters.
23:23:39 <lightquake> right
23:23:46 <lightquake> i agree that ByteString is necessary
23:23:58 <shachaf> lightquake: For example, a filename in UNIX is "a sequence of any bytes other than 0 or 47".
23:24:07 <lightquake> it's more String vs Text
23:24:12 <shachaf> By convention in Linux this encodes a UTF-8 name.
23:24:21 <hpaste> johnw pasted “stringToOid” at http://hpaste.org/74816
23:24:47 <johnw> that function is called from user code, and I don't see a need to "nail down" which string type gets passed
23:24:51 <lightquake> also, silly option: UseText typeclass, with a family such that UseText String = Text, UseText String -> a -> String = Text -> a -> Text
23:25:17 <lightquake> er, UseText (String -> a -> String)
23:25:48 <Jafet> useText :: (String -> a -> String) -> (Text -> a -> Text)
23:26:45 <lightquake> yeah
23:27:23 <lightquake> useText f = \s a -> pack (f (pack s) a)
23:28:17 <Jafet> What is that good for anyway
23:28:30 <Saizan> lightquake: one of those has to be unpack
23:28:44 <lightquake> er, yeah
23:28:47 <lightquake> pack (f (unpack s) a)
23:29:19 <lightquake> you pack when String appears in a negative position, and unpack when it's positive
23:29:21 <Saizan> though if i have a Text i'm not sure i want to expand it into a String to call a function
23:29:22 <johnw> the other thing I like Stringable for is not having to remember the efficient way to do all the various conversions
23:29:33 <johnw> now I can just S.fromText :: Text -> a
23:29:45 <lightquake> Jafet, Saizan: the point would be as a wrapper around an external API
23:29:45 <Saizan> lightquake: the other way around
23:30:10 <Jafet> lightquake: why not (String -> String) -> (Text -> Text)
23:30:11 <shachaf> lightquake: That sounds like a lens/isomorphism/something.
23:30:14 <Jafet> Which is equivalent
23:30:43 <lightquake> shachaf: it does, yeah
23:30:52 <shachaf> Or (String->Text,Text->String)!
23:31:02 <ddarius> @hackage newtype
23:31:03 <lambdabot> http://hackage.haskell.org/package/newtype
23:31:05 <Jafet> shachaf: shocking
23:31:17 <lightquake> Jafet: because this way if f is String -> [Int] -> [IO ()] -> Bool -> (String -> Int) -> String, you don't have to worry about doing all the partial application yourself
23:31:26 <lightquake> (this isn't a serious suggestion)
23:31:52 <ddarius> lightquake: a isn't going to unify with everything in the middle.
23:31:56 <lightquake> Saizan: is it? i can never remember which side is positie and which is negative
23:31:58 <Jafet> You can't use f in useText
23:32:08 * hackagebot gitlib 0.1.0 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.1.0 (JohnWiegley)
23:32:15 <lightquake> well
23:32:36 <Saizan> Jafet, ddarius: lightquake is not proposing a single function, but a typeclass with associated type family
23:32:39 <lightquake> my point was that i'd use some type family hackery so that useText :: (CanUseText t) => t -> UseText t
23:33:10 <Saizan> lightquake: negative is on the left side of (->)
23:33:15 <Jafet> What about (String -> String -> String)
23:33:38 <lightquake> Saizan: so is the String in String -> Bool -> Bool positive or negative?
23:33:53 <Jafet> Next you'll have useTextN and fifty extra type signatures
23:33:57 <Saizan> lightquake: negative, that's String -> (Bool -> Bool)
23:34:06 <lightquake> ah, right
23:34:16 <lightquake> Jafet: not if i use type families!
23:34:27 <shachaf> Negative is on the left side of an odd numbers of (->)s.
23:35:06 <lightquake> UseText String = Text; UseText (a -> b) = UseText a -> UseText b
23:35:51 <lightquake> and UseText a = a
23:35:59 <lightquake> i think this will work with OverlappingInstances
23:36:14 <Saizan> type families aren't allowed to overlap
23:36:37 <lightquake> aw
23:36:43 <lightquake> my house of cards has collapsed all around me :(
23:37:04 <Saizan> functional dependencies do :)
23:37:09 * hackagebot cipher-aes 0.1.2 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.1.2 (VincentHanquez)
23:37:45 <lightquake> i think the better thing to do would actually be to use some kind of lens
23:39:22 <blackdog> is there a sensible way of writing an attoparsec parser that accepts alphabetic identifiers, but excludes some keywords?
23:40:36 <Saizan> parse the identifier, then fail if it's a keyword?
23:40:56 <Saizan> you might need try, i never remember if it's that much like parsec
23:42:45 <blackdog> Saizan: so you can explicitly call 'fail'?
23:43:11 <Saizan> blackdog: mzero might be more appropriate
23:43:26 <Saizan> i'm sure there's a failing parser
23:44:33 <blackdog> Saizan: ok. i thought there might be, but a cursory glance didn't show it. i'll play with mzero.
23:44:46 <shachaf> Is mzero OK with that?
23:44:59 <Saizan> http://hackage.haskell.org/packages/archive/attoparsec/0.10.2.0/doc/html/Data-Attoparsec-Types.html#t:Parser <- in fact it seems fail wouldn't work
23:47:34 <ddarius> Saizan: Why do you say that?
23:48:25 <Saizan> ddarius: "throws an exception" makes me thing of calls to error
23:48:33 <zalzane> hory shit
23:48:54 <Saizan> but i'm wrong
