00:00:09 <johnw> ah, interesting
00:00:16 <johnw> it allocates 11gb right away
00:00:20 <johnw> and then it gradually shrinks away
00:00:50 <johnw> like, within the first 100ms, max heap is reached
00:01:11 <johnw> and the profiler is blaming foreach
00:01:20 <johnw> so let me read that more closely
00:04:53 <mysticc> http://hpaste.org/74666 .. why g shows no error but f does ?
00:04:57 <mysticc> http://hpaste.org/74666 .. why g shows no error but h does ?
00:06:25 <pharaun> johnw: hm well we have the $!! all over the code now so that might be pushing it out
00:06:44 <johnw> true
00:06:47 <johnw> still looking
00:07:05 <pharaun> sure by all means :) was just pointing out
00:10:38 <pharaun> just ran the profiler to get the -hc graphs and its really funky looking
00:11:02 <pharaun> looks like sawtooth spikes then fall spikes then fall
00:12:50 <johnw> you still have your evaluate?
00:13:12 * hackagebot vacuum 2.1.0.0 - Graph representation of the GHC heap  http://hackage.haskell.org/package/vacuum-2.1.0.0 (AustinSeipp)
00:13:14 <pharaun> i don't think so let me recompile to make sure
00:13:14 * hackagebot VKHS 0.1.2 - Provides access to Vkontakte social network, popular in Russia  http://hackage.haskell.org/package/VKHS-0.1.2 (SergeyMironov)
00:13:16 * hackagebot vacuum 2.1.0.1 - Graph representation of the GHC heap  http://hackage.haskell.org/package/vacuum-2.1.0.1 (AustinSeipp)
00:14:01 <pharaun> i commented out the evalulate in the foreach part
00:14:26 <pharaun> johnw: yeah its still looking saw toothy
00:14:36 <pharaun> ARR_WORDS
00:14:45 <pharaun> which is internal to the ByteString i think?
00:16:06 <johnw> still reading
00:20:41 <johnw> so, updateEd2k is definitely holding onto all the data from the file
00:20:46 <johnw> i just can't figure out why!
00:21:00 <johnw> i'm missing something basic
00:22:38 <pharaun> http://stackoverflow.com/a/6354722/326077 ?
00:22:53 --- mode: wolfe.freenode.net set +o ChanServ
00:23:16 <johnw> i'm trying to make sure we never hold on to any part of the bytestring
00:23:22 <johnw> which we still are
00:23:22 <pharaun> yeah
00:26:18 <johnw> aha
00:26:41 <johnw> got it
00:26:49 <johnw> now just let me make sure i understand
00:26:55 <johnw> it uses 20mb now, consistently
00:27:39 <mysticc> http://hpaste.org/74666 .. How type inference works in this case ?
00:27:42 <pharaun> \o/
00:28:57 <Hadaka> I need very trivial command line argument parsing - cmdargs, options or parseargs?
00:29:12 <pharaun> Hadaka: i've been using cmdargs, its pretty nice
00:29:12 <johnw> pharaun: ok, squashed it!
00:29:19 <pharaun> johnw: :o awesome!
00:29:23 <johnw> let me apply it to your virgin sources, to be sure
00:29:44 <Hadaka> google seems to come up with most hits for cmdargs
00:30:19 <pharaun> Hadaka: yeah i'be been using it for about 2-3 days now, its pretty nice, i think i'll stick with it so far, it has fancy stuff, but even the basics was fairly easy to pick up imho
00:31:07 <johnw> ok, you just needed one deepseq, and one seq, after all
00:31:12 <johnw> in updateEd2k
00:31:19 <johnw> newCtx a xs = Ctx $!! (L.init xs ++ [(newHash a xs, newLength a xs)])
00:31:27 <johnw> that makes updateEd2k strict
00:31:31 <johnw> then, in foreach
00:31:34 <johnw> foreach fh $! updateEd2k ctx a
00:31:39 <johnw> that makes foreach strict
00:31:42 <johnw> and that's all you needed
00:32:00 <johnw> without the first one, we hold onto every chunk
00:32:07 <johnw> without the second one, we hold onto every chunk, just in a different way :)
00:32:12 <johnw> now, i'll parallelize
00:32:26 <pharaun> johnw: AHA! :) <3 thanks
00:32:46 <johnw> so, we're at 23 secs now
00:32:50 <pharaun> so the foreach was tricking us in thinking we didn't get it all in ed2k
00:32:53 <johnw> which is the speed of my hard drive
00:32:58 <johnw> so i'm not expecting much gain
00:33:01 <pharaun> yeah
00:33:13 * hackagebot dsmc 0.1.0.0 - DSMC library for rarefied gas dynamics  http://hackage.haskell.org/package/dsmc-0.1.0.0 (DmitryDzhus)
00:33:31 <pharaun> johnw: i can probably dump this file into a tmpfs to keep it in ram which should let us see how fast it can get :p
00:33:38 <johnw> sure
00:35:07 <pharaun> confirmed (the memory is now flatlined) :D
00:44:52 <killy9999> I'm trying to wrap my head around reader monad
00:45:06 <killy9999> how do I glue functions together using >>= ?
00:45:39 <pharaun> killy9999: like "foobar >>= (\x -> bar x)" for example
00:45:55 <pharaun> the do notation is syntax sugar for this basically
00:46:15 <pharaun> killy9999: as of the reader monad, what is troubling you about it?
00:46:41 <killy9999> pharun: I'm trying something like this: 3 >>= (+2)
00:46:46 <killy9999> and this gives an error
00:47:17 <Twisol> That would work under the Identity monad, I think.
00:47:48 <Twisol> Not so much Reader.
00:47:48 <Twisol> > runIdentity $ (Identity 3) >>= (+2)
00:47:49 <lambdabot>   No instance for (GHC.Num.Num (Data.Functor.Identity.Identity a))
00:47:50 <lambdabot>    arising...
00:48:01 <Twisol> brb, ghci
00:48:11 <hpaste> killy9999 pasted “reader monad” at http://hpaste.org/74668
00:48:15 <dibblego> > (+1) >>= (*) $ 4
00:48:16 <pharaun> johnw: any luck? or still nomming on it? :)
00:48:17 <lambdabot>   20
00:48:22 <killy9999> how do I desugar this?
00:48:38 <johnw> still nomming
00:48:45 <johnw> @pl (\_ -> return ())
00:48:45 <lambdabot> const (return ())
00:48:52 <dibblego> @undo do a <- (*2); b <- (+10); return (a+b)
00:48:52 <lambdabot> (* 2) >>= \ a -> (+ 10) >>= \ b -> return (a + b)
00:48:52 <johnw> @pl const (return ())
00:48:52 <lambdabot> const (return ())
00:49:27 <killy9999> hm... is there a way to avoid explicit lambdas?
00:49:35 <killy9999> after all, these are sections
00:49:52 <dibblego> @type liftA2 (+) (*2) (+10)
00:49:53 <lambdabot> forall a. (Num a) => a -> a
00:50:38 <killy9999> dibblego: thanks
00:52:20 <Twisol> > runIdentity $ (return 3) >>= (return . (+ 2))
00:52:22 <lambdabot>   5
00:52:50 <killy9999> though I still don't see how could I use reader monad to use e.g. a common parameter (some sort of environment) for all functions
00:53:16 <sordina> I'm trying to build happy. The weird thing is that I can load Setup.hs in ghci fine, but I can't build it with cabal.
00:53:35 <sordina> "Module `System.IO.Error' does not export `try'"
00:53:54 <sordina> Would this be being caused by a base constraint or something?
00:54:01 <Twisol> killy9999: Normally you might do something like f (g (h 3)), right? This is just f $ g $ h $ 3, using the uber-handy application function.
00:54:21 <opqdonut> many people prefer to write that as: f . g . h $ 3
00:54:28 <Twisol> opqdonut: it's for a reason!
00:54:45 <killy9999> Twisol: OK, so 3 acts as common parameter, right?
00:55:05 <pharaun> killy9999: no the $ is a way to avoid doing ()'s
00:55:05 <killy9999> I still don't see how this is related to reader monad
00:55:12 <Twisol> No, just the parameter to h. Sorry, not used to explaining in #haskell.
00:55:13 <dibblego> f x (g x (h x (i x)))
00:55:18 <Twisol> I'm getting there :S
00:55:26 <killy9999> ok,I'm waiting
00:55:46 <Twisol> If you move that to Identity monad, it looks like readIdentity $ f =<< g =<< h =<< return 3
00:56:07 <Twisol> the extra 'return' and 'readIdentity' just serve to make it monadic
00:56:13 <Twisol> and =<< is just >>= with the arguments flipped
00:56:26 <Twisol> sorry, *runIdentity
00:56:41 <Twisol> now, we want to give a common parameter
00:56:59 <Twisol> runReader 42 $ f =<< g =<< h =<< return 3
00:57:31 <Twisol> This requires a little explanation. In Identity, f, g, and h are just (a -> b), (b -> c), etc. functions.
00:57:47 <Twisol> In Reader, they're (z -> a -> b), (z -> b -> c), etc.
00:58:11 <killy9999> so 42 is that "z", right?
00:58:51 <dibblego> if you find yourself writing: f (g x) x free in x then you might want reader
00:58:58 <Twisol> Right.
00:58:58 <Twisol> The monad lets us compose/chain functions, ignoring that first parameter.
00:58:58 <Twisol> Sort of future-currying
00:59:11 <dibblego> f (g (h x) x) x
00:59:12 <killy9999> awesome
00:59:17 <dibblego> f (g (h (i x) x) x) x
00:59:17 <Twisol> killy9999: Did that help?
00:59:18 <killy9999> this slowly starts to make sense
00:59:42 <killy9999> Twisol: yes, but I need to think about that a little more
00:59:57 <Twisol> killy9999: I find it useful to think of >>= and =<< as similar to $ in what they do. They just hide a bit of extra machinery.
01:00:03 <killy9999> I still don't see why I can't do runIdentity $ (+2) =<< return 3
01:00:27 <Twisol> Because (+2) doesn't return an Identity value
01:00:32 <Twisol> it returns a raw value
01:00:38 <Twisol> you need (return . (+2) =<< return 3
01:00:47 <Twisol> plus an extra parenthesis there D:
01:00:54 <killy9999> hah!
01:00:56 <killy9999> works
01:01:07 <killy9999> I'm saving this log
01:01:18 <Twisol> newtype wrapping/unwrapping is a bit tiresome, but it becomes a fact of life.
01:03:08 <bartavelle> I usually read links from http://contemplatecode.blogspot.fr/ on thursday, after LWN
01:03:16 <bartavelle> why isn't it updated ? this is ruining my morning
01:03:19 <startling> killy9999, fmap is more useful there
01:03:32 <startling> killy9999, fmap (+ 2) (return 3)
01:03:43 <Twisol> startling: at that point, just use an Applicative
01:03:47 <dibblego> return . f =<< x can be written: fmap f x
01:03:54 <startling> Twisol, oh, also true
01:03:56 <johnw> pharaun: making this concurrent is turning out to be non-trivial
01:04:06 <pharaun> oh dear
01:04:09 <startling> killy9999, return (+ 2) <*> return 3 does the same thing
01:04:17 <johnw> i need to make a mapOverChunks function
01:04:19 <Twisol> startling: but if one wants to understand monads, it can be useful to entertain obvious solutions :)
01:04:46 <nand``> Is there some super-abstract plotting API like  plot :: (Double -> Double) -> IO ()  anywhere?
01:04:54 <Twisol> nand-prime-prime?
01:04:56 <nand``> Eg. something like wolframalpha which figures out a "nice" display size as well
01:05:10 <pharaun> johnw: the basic idea is to take "chunk" then parallel md4 each chunk?
01:05:10 <startling> Twisol, fmap on monads was a revelation for me, I try to pass it on. :)
01:05:15 <Twisol> startling: true!
01:05:20 <pharaun> johnw: or are we going to take a different approach
01:05:32 <nand``> ah, send the answer to nand`
01:05:34 <johnw> yeah
01:05:37 <Ralith> nand``: Double -> Double doesn't seem like enough info to infer a domain and range.
01:05:40 <johnw> read in 9MB * cores
01:05:43 <Twisol> startling: but I'd prefer pure rather than return if using <*> XD
01:05:48 <johnw> do all N md4s
01:05:52 <johnw> then assemble them as we would have before
01:05:59 <pharaun> oooo nice
01:05:59 <johnw> taking that approach now
01:06:40 <startling> Twisol, that does make assumptions, yeah
01:06:44 <dibblego> fmap f (pure x) can be rewritten: pure (f x)
01:06:53 <startling> dibblego, well duh
01:07:09 <Twisol> startling: and pure x <*> y is just x <$> y
01:07:15 <bartavelle> johnw, entering the conversation without any context, but if you have your chunks in a list, you can parmap
01:07:32 <johnw> bartavelle: it's all IO actions
01:07:39 <bartavelle> ah
01:07:43 <johnw> pharaun: this is really just a map/reduce, isn't it
01:07:50 <bartavelle> I usually use workers commanded by channels in that case
01:08:03 <startling> Twisol: you already vetoed my fmap okay
01:08:13 * hackagebot lca 0.2.2 - O(log n) persistent on-line lowest common ancestor calculation without preprocessing  http://hackage.haskell.org/package/lca-0.2.2 (EdwardKmett)
01:08:15 * hackagebot dsmc-tools 0.1.0.0 - DSMC toolkit for rarefied gas dynamics  http://hackage.haskell.org/package/dsmc-tools-0.1.0.0 (DmitryDzhus)
01:08:17 * Twisol cackles.
01:08:36 <pharaun> johnw: pretty much, map out the whole file in 9.27MiB chunk, then the reduce step, return first md4 if file is < 9.27MiB otherwise, md4 cross all of the md4 hash of each 9.27MiB so yeah its a map-reduce
01:10:10 <bartavelle> the cool thing when you use channels like that is that it is obvious to distribute on other computers
01:10:43 <johnw> pharaun: how I merge two Ctxs?
01:10:56 <johnw> can Ctx be a Monoid?
01:11:03 <bartavelle> MD4 ctx ?
01:11:07 <johnw> yeah
01:11:08 <pharaun> bartavelle: yes
01:11:12 <bartavelle> you can't
01:11:15 <bartavelle> mathematically
01:11:19 <bartavelle> this has to be sequential
01:11:23 <johnw> i have a sequential series
01:11:30 <johnw> how do I add 1 + 2?
01:11:39 <pharaun> bartavelle: ed2k basically takes 9.27MiB chunks out of the file and do md4 of each chunk
01:11:45 <bartavelle> ah ok
01:11:55 <Jafet> nand: Plot[] has a type resembling (SymbolicFunction Dom Codom -> GraphicsOptions -> VectorGraphics)
01:11:57 <startling> johnw: there's this handy function called (+)
01:12:05 <Jafet> (Double -> Double) is useless.
01:12:06 <pharaun> the final step is reducing which is in sequence running a master md4 over *all* of the children md4
01:12:13 <johnw> startling: does it work on MD4.Ctx?
01:12:28 <johnw> pharaun: finish this function fro me: \(Ctx xs) (Ctx ys) ->
01:12:35 <johnw> I want to make a merged Ctx
01:12:51 <pharaun> johnw: can your promise that ys is always after xs?
01:12:52 <bartavelle> what does that mean ?
01:12:54 <johnw> yes
01:12:57 <startling> johnw: oh no idea. just saw "how do I add 1 + 2?"
01:13:05 <pharaun> you will need a 3rd Ctx, the master Ctx
01:13:11 <johnw> xs is the master
01:13:15 <johnw> ys is the "next in series"
01:13:18 <pharaun> ohh k
01:13:56 <pharaun> johnw: alright see finalizeEd2k - I just do - foldl MD4.update MD4.init ((next md4 from the file))
01:14:03 <pharaun> but basically
01:14:32 <pharaun> \(Ctx xs) (Ctx ys) -> MD4.update xs (MD4.finalize ys)
01:14:53 <pharaun> the finalize step for MD4 spits out a bytestring which is the hash
01:15:34 <johnw> what's the return value from MD4.update?
01:16:12 <pharaun> a MD4.Ctx
01:19:16 <johnw> ok, I have this:
01:19:18 <johnw> https://gist.github.com/3712833
01:19:25 <johnw> but it gives me a type error that makes no sense to me
01:19:28 <johnw> sample.hs:22:23: Not in scope: data constructor `Ctx'
01:19:34 <johnw> how is that not in scope?
01:19:59 <startling> johnw, the constructor can be different than the type
01:20:06 <johnw> but it's data Ctx = Ctx
01:20:14 <johnw> and exported Ctx(..)
01:20:22 <startling> huh
01:20:28 <johnw> yeah
01:20:32 <johnw> exactly :)
01:20:36 <Twisol> forgive the silly question, but are you sure you're importing it?
01:20:42 <johnw> import           Crypto.Hash.Ed2k (ED2K, hashlazy, initEd2k, updateEd2k, finalizeEd2k, Ctx)
01:20:45 <pharaun> pardon me, there is two Ctx, one is Ctx for ed2k, one is Ctx for md4, but i imported md4 qualified as MD4
01:20:45 <johnw> oh
01:20:46 <johnw> duh
01:21:03 <johnw> didn't import Ctx(..)
01:21:06 <startling> hehe
01:21:11 <Twisol> ^_^;
01:21:16 <pharaun> happens
01:21:48 <Twisol> (off-topic, it scares me how often things in FP boil down to application and composition)
01:21:54 <merijn> Organisational question, when writing a library should I make sure I put it in a top level module that makes sense (i.e. Language for my runtime system) or just have it at the top level?
01:22:27 <startling> Twisol, even composition boils down to application
01:22:38 <startling> Twisol: (assuming lambda)
01:22:49 <Twisol> startling: yeah, I derived that myself earlier
01:22:52 <dmwit> There is only lambda and application. Sometimes let.
01:23:40 <simon> is there an example of <+> being used?
01:23:45 <startling> Twisol, have you read anything about combinatory logic?
01:23:53 <startling> @hoogle (<+>)
01:23:54 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
01:23:54 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
01:23:54 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
01:24:15 <Ralith> huh, thought that was mplus
01:24:21 <Twisol> something like (.) (f) (const g) ()
01:24:29 <Twisol> startling: Not really. I've heard of it.
01:24:52 <startling> Twisol, there's this cool book called To Mock a Mockingbird that derives a turing-complete system from application and lambda
01:25:25 <startling> well, I'm sure there are a lot of books like that, but this one is really fun and approachable
01:26:55 <killy9999> Speaking of "To Mock a Mockingbird"
01:27:25 <killy9999> am I the only one who has problems with deriving proofa about birds?
01:27:40 <johnw> pharaun: in my function, the Ctx xs and Ctx ys are Ed2k.Ctx
01:27:41 <killy9999> I'm able to follow solutions, buyt I have problems to come up with them by myself
01:27:44 <johnw> not MD4.Ctx
01:27:49 <johnw> how do I merge those?
01:27:58 <Twisol> startling: Hmm, I'll check it out!
01:28:30 <johnw> anyway, this is what I ended up with:
01:28:33 <johnw> https://gist.github.com/3712858
01:28:35 <johnw> i'm gonna stop now
01:28:42 <pharaun> johnw: <3
01:29:01 <pharaun> i should be able to figure out the merging and all of the rest :)
01:29:05 <pharaun> this looks nice :D
01:29:26 <johnw> i'm not sure yet whether it will actually be parallel
01:29:36 <startling> killy9999, yeah, it's definitely a learned skill
01:29:39 <johnw> parMap is an opportunistic parallelizer
01:30:20 <startling> killy9999, a helpful thing I did was read a few chapters, work through the given solutions, and then go back to the beginning and re-do them without the solutions
01:30:37 <pharaun> johnw: aha, still worth checking out :) and that's a good kickstart for me to work on paralleling more stuff
01:31:59 <killy9999> startling: that's what I did, but felt a bit like cheating
01:32:11 <pharaun> johnw: thanks so much for all of the help
01:32:30 <johnw> sure!
01:33:02 <johnw> at least we got the space leak sorted
01:33:05 <Enigmagic> pharaun: also, deepseq is not required for constant memory usage. regular old bang patterns and no (++) do just fine: https://gist.github.com/991267d37661d49299fa
01:33:16 <johnw> i want to get faster at fixing those
01:33:19 <johnw> so it was great practice, thank yo
01:33:20 <johnw> u
01:33:23 <startling> killy9999: meh. I do it pretty often; seems like it takes a few days of doing proofs before I really get back up to speed
01:33:48 <pharaun> johnw: np, it was also educational for me, i had the general gut feeling of where the ed2k was but wasn't aware of the foreach one, it was educational (regarding deepseq)
01:34:20 <pharaun> Enigmagic: aha the axs@(!bang) stuff?
01:34:31 <johnw> there's nothing deepseq is doing you can't do with enough seq's, it just saves a lot of time and ugliness
01:34:46 <killy9999> um.. does anyone remember a link to a page that logs this channel in real time?
01:34:48 <Enigmagic> pharaun: yes. rather than using (a++[b]) use (b:a) then (reverse yourList) in finalize.
01:35:18 <Enigmagic> pharaun: and the !'s will evaluate the head, which you can do instead of using deepseq to evaluate the tail
01:35:31 <johnw> type inference is amazing
01:35:51 <Enigmagic> johnw: deepseq has a lot of overhead for large data structures, like lists.
01:35:57 <Enigmagic> particularly when you just want to force one element
01:36:09 <pharaun> Enigmagic: for 11gb file its ~1,100ish element list
01:36:18 <johnw> I can use "alloca $ \ptr ->", and it figures out from way deep down when I expect ptr to be, and therefore how large the allocation should be
01:36:24 <pharaun> and from my understanding, once something has been reduced to rnf its skipped quickly
01:36:27 <johnw> Enigmagic: sure, by design :)
01:36:55 <Enigmagic> pharaun: yes, but it's still inspecting 1100 elements in a linked list (which has poor memory locality)
01:37:02 <Enigmagic> vs 1 element with good locality
01:37:16 <pharaun> true
01:37:33 <pharaun> i was pondering about flipping the list and couple of other things but was more worried about figuring out the space leak
01:37:43 <pharaun> but i think i'm starting to understand it all a bit better
01:37:49 <johnw> great!
01:38:00 <johnw> the first ones take hours
01:38:04 <pharaun> yeah
01:38:06 <Enigmagic> yes, but they're related. since you just wanted to force the head... flipping the list makes it easy.
01:38:07 <pharaun> that was my first time actually
01:38:16 <merijn> Do I always have to explicitly write the entire hierarchy in a module name?
01:38:35 <merijn> I.e. Foo/Bar/Baz.hs always needs "module Foo.Bar.Baz where"?
01:39:03 <johnw> > let x = [(undefined, undefined)] in x `seq` ()
01:39:04 <lambdabot>   ()
01:39:06 <johnw> > let x = [(undefined, undefined)] in x `deepseq` ()
01:39:07 <lambdabot>   Not in scope: `deepseq'
01:39:14 <johnw> well, with deepseq that would be an error
01:39:29 <pharaun> Enigmagic: you do have a point, i'm still picking up on the language, i'm used to focusing on one piece at a time, rather than the whole thing a whole
01:39:51 <Enigmagic> johnw: try that with an infinite list ;)
01:40:07 <johnw> deepseq would never terminate
01:40:28 <johnw> i think deepseq as a kind of "fmap eval"
01:40:37 <johnw> where eval forces strictness
01:40:45 <Enigmagic> deepseq is not a great choice when you know the value you want to force
01:41:05 <johnw> seq just forces the top level, aka WHNF
01:41:19 <killy9999> answer to self: http://tunes.org/~nef/logs/haskell/12.09.13
01:41:58 <johnw> deepseq = NF
01:42:52 <srhb> Why is deepseq not available in the Prelude_
01:43:06 <pharaun> Enigmagic: isn't bang pattern basically seq?
01:43:24 <pharaun> i'm looking at the bang pattern ticket/whatever on the haskell wiki
01:43:28 <Enigmagic> pharaun: basically yes
01:43:50 <simon> @pl \ (a, b, c) -> a
01:43:51 <lambdabot> (line 1, column 8):
01:43:51 <lambdabot> unexpected ","
01:43:51 <lambdabot> expecting letter or digit, operator or ")"
01:43:51 <lambdabot> ambiguous use of a non associative operator
01:47:20 <Athas> In GHC 7.4, I'm getting the error "No instance for (Monad (Either String))" on code that used to work.  What's going on?
01:47:36 <Athas> I'm importing Prelude (and Data.Either for good measure, where's the instance supposed to be defined), but it still gives me the error.
01:47:50 <mikeplus64> Athas: try import Control.Monad.Instances
01:48:24 <Athas> That works.  Strange, isn't the instance defined in Data.Either?
01:48:29 <Enigmagic> pharaun: another thing to try out would be to move the MD4.update calls from finalizeEd2k into updateEd2k when a new block is being hashed
01:48:42 <mikeplus64> Athas: nope
01:49:05 <Enigmagic> pharaun: then you're context could just be two MD4.Ctx's and an Int
01:49:08 <JMassapina> Hello all
01:49:34 <Enigmagic> your
01:49:39 <Enigmagic> late :|
01:49:44 <charliesome> are there any security issues with compiling (but not executing) untrusted haskell code?
01:49:57 <bartavelle> is the GHC trac used by ghc developpers ?
01:49:57 <mikeplus64> charliesome: with TH enabled, yes
01:50:10 <mikeplus64> charliesome: TH can execute anything (including IO)
01:50:13 <merijn> Can I write GADTs with record syntax?
01:50:22 <merijn> If so, how?
01:50:24 <Enigmagic> merijn: no
01:50:33 <pharaun> Enigmagic: yeah! i was thinking about that but i decided to go with the simplest approach that works and then go from there
01:50:36 <charliesome> mikeplus64: thanks for letting me know
01:50:38 <merijn> Enigmagic: :(
01:50:41 <pharaun> Enigmagic: already got a nice set of test suite ready to verify :)
01:50:47 <charliesome> mikeplus64: if i disable TH, should I be ok?
01:50:48 <mikeplus64> charliesome: but i think there is a flag to disable it somewhere ...
01:50:50 <mikeplus64> yeah
01:50:53 <mikeplus64> i think so
01:50:55 <charliesome> alright cheers
01:52:20 <xz> what are good ways to use haskell as a REST client?
01:53:31 <killy9999> How do I check type of (>>=) in ghci, but for some particular monad?
01:53:41 <killy9999> I mean I want to see specialized type, not the general one
01:53:45 <charliesome> mikeplus64: looks like TH is disabled by default, so that's a good thing
01:53:48 <johnw> good question!
01:54:14 <mikeplus64> killy9999: :t (value of that type >>=)
01:54:14 <rfw> killy9999: substitute Monad m for whichever monad it is?
01:54:29 <killy9999> but how?
01:54:35 <killy9999> :t (>>=) :: IO String does not some to be correct syntax
01:54:36 <lambdabot>     `IO' is applied to too many type arguments
01:54:36 <lambdabot>     In an expression type signature:
01:54:36 <lambdabot>       IO String does not some to be correct syntax
01:54:46 <Mandarq> @quote Kukkua
01:54:46 <simon> @pl find (\ (x, y) -> y == z))
01:54:46 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
01:54:46 <rfw> (>>=) is Monad m => m a -> (a -> m b) -> m b
01:54:47 <lambdabot> (line 1, column 26):
01:54:47 <lambdabot> unexpected ")"
01:54:47 <lambdabot> expecting variable, "(", operator or end of input
01:54:47 <killy9999> :t (>>=) :: IO String
01:54:48 <Mandarq> Good.
01:54:49 <lambdabot>     Couldn't match expected type `IO String'
01:54:49 <lambdabot>            against inferred type `m a -> (a -> m b) -> m b'
01:54:50 <lambdabot>     In the expression: (>>=) :: IO String
01:55:00 <Mon_Ouie> :t (IO >>)
01:55:01 <rfw> so (>>=) for IO is IO a -> (a -> IO b) -> IO b
01:55:01 <lambdabot> Not in scope: data constructor `IO'
01:55:05 <Mandarq> lambdabot, use pastebin.
01:55:08 <simon> @pl \ (x, y) -> y == z
01:55:09 <lambdabot> ap (==) snd
01:55:17 <mikeplus64> killy9999: that isn't the right type, substitute the m in Monad m => m a -> (a -> m b) -> m b with IO
01:55:34 <killy9999> yes, I know, but hoiw do I tell ghci to do that for me?
01:55:35 <mikeplus64> ie (>>=) for IO :: IO a -> (a -> IO b) -> IO b
01:55:37 <pharaun> Enigmagic: fwiw that 2 hash approach is how i implemented the ed2k hash in a different language for a different project
01:55:52 <merijn> I'm having a brain fart, I can't remember what the typeclass that implements def is called/where it is defined
01:56:01 <merijn> I thought Data.Default, but apparently that doesn't exist..
01:56:08 <Enigmagic> @hackage data-default
01:56:08 <lambdabot> http://hackage.haskell.org/package/data-default
01:56:33 <merijn> Enigmagic: Thanks!
01:57:00 <mikeplus64> killy9999: you can't, it should really be intuition for you, but you can sort of if you take a value of the type, apply it, and see what the type is
01:57:01 <Enigmagic> pharaun: the upside is that you'd probably have used a datatype other than a tuple... and then adding strict fields is much less painful than bang patterns
01:57:18 <mikeplus64> :t ( (undefined :: IO a) >>= ) -- eg killy9999
01:57:19 <lambdabot> forall a b. (a -> IO b) -> IO b
01:57:22 <Enigmagic> (bang patterns would still be required, just less of them)
01:57:50 <killy9999> mikeplus64: well, that solution omits the type of first parameter
01:57:55 <pharaun> Enigmagic: yeah
01:58:15 * hackagebot storablevector 0.2.8.2 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.8.2 (HenningThielemann)
01:58:19 <xz> any recommendations for writing a client in Haskell to connect to a RESTful API?
01:58:21 <mikeplus64> killy9999: so it's important to build a mental intuition of how it works :)
01:58:36 <killy9999> mikeplus64: it's not always intuitive for me what the type should be e.g. for (-> r)
01:58:52 <Twisol> killy9999: I just do :t (>>=) in ghci, copy it into my text editor, and replace 'm' with the Monad instance.
01:59:00 <Twisol> it's annoying but it works
01:59:03 <vodik> is hackage down atm?
01:59:24 <killy9999> I'm trying to work that out using pencil & paper, but it would be nice for ghci to confirm that I understand everything correctly
01:59:25 <Twisol> vodik: http://www.downforeveryoneorjustme.com/hackage.haskell.org
01:59:46 <Twisol> vodik: It's up for me and DFEOJM. :(
01:59:47 <mikeplus64> :t ((undefined :: a -> a) >>=)
01:59:49 <lambdabot> forall a b. (a -> a -> b) -> a -> b
01:59:50 <vodik> well that url isn't working for me
01:59:55 <vodik> Twisol: i think my isp derped
01:59:57 <vodik> ty
02:00:02 <Twisol> vodik: sounds like you have a DNS issue :X
02:00:31 <pharaun> Enigmagic: johnw thanks you two, this has been an very educational night!
02:00:46 <merijn> Achievement unlocked: Crashed GHC \o/
02:00:51 <mikeplus64> :t pred >>=
02:00:52 <lambdabot> parse error (possibly incorrect indentation)
02:00:53 <merijn> "ghc: panic! (the 'impossible' happened)"
02:01:00 <mikeplus64> :t (pred >>=)
02:01:01 <lambdabot> forall a b. (Enum a) => (a -> a -> b) -> a -> b
02:01:21 <mikeplus64> :t (pred >>= succ)
02:01:21 <vodik> Twisol: maybe i'll just reset my router. changing to google dns didn't fix anything
02:01:21 <Enigmagic> pharaun: np
02:01:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
02:01:22 <lambdabot>     Probable cause: `succ' is applied to too many arguments
02:01:22 <lambdabot>     In the second argument of `(>>=)', namely `succ'
02:01:29 <mikeplus64> :t (pred >>= succ)
02:01:30 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
02:01:30 <lambdabot>     Probable cause: `succ' is applied to too many arguments
02:01:30 <lambdabot>     In the second argument of `(>>=)', namely `succ'
02:01:32 <mikeplus64> oops
02:01:50 <mikeplus64> :t (pred >>= (\x -> succ))
02:01:51 <lambdabot> forall a. (Enum a) => a -> a
02:03:15 * hackagebot hedn 0.1.3.0 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.3.0 (AlexanderBondarenko)
02:04:47 <hiptobecubic> @unpl nubBy (((==0).).rem)
02:04:47 <lambdabot> nubBy (\ e h -> (rem e h) == 0)
02:04:48 <Nevin> Hi, I am pretty new to Haskell. I want to know a data modeling question
02:05:53 <Nevin> If the data will be stored in database, and I am modeling a shop -1---*- products relationship
02:06:32 <Nevin> should I denormalize the data model in Haskell so I only store the FK? or model with nested data?
02:12:25 <johnw> yay
02:12:35 <johnw> my Data.Git types wrapping hlibgit2 are actually starting to work!
02:13:04 <pharaun> haha i saw (your github repo)
02:13:25 <johnw> yeah, but now I can do this:
02:13:25 <johnw> writeBlob $ createBlob repo (E.encodeUtf8 (T.pack "Hello, world!\n"))
02:13:38 <pharaun> nice :D
02:13:41 <johnw> and it hides all the grossness of using the C FFI API directly
02:13:53 <pharaun> i might have to ahem borrow that library someday, been wanting to muck with git eventually
02:13:58 <johnw> otherwise, you have to use lots of alloca and withCString, and checking error codes, etc.
02:14:06 <pharaun> that's just icky
02:14:12 <johnw> it's VERY icky
02:14:18 <johnw> and you have to be very cautious
02:14:35 <johnw> but this library will wrap libgit2 not only at a higher-level, but as efficiently as I can
02:15:03 <johnw> so you if you create a tree, and then add a blob to it, the minimum amount of work/memory will take place to reflect that change to the repository
02:15:26 <johnw> that means keeping some housekeeping object in memory, of type C'git_treebuilder, but that will be kept invisible to the user
02:15:40 <johnw> all you'll have to do is use updateTree path object tree
02:15:50 <johnw> and then call writeTree on the result
02:16:07 <johnw> (which will return a new Tree with hash value set)
02:16:53 <simon> @pl \ (a, b) (c, d) -> (a+c, b+d)
02:16:54 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
02:16:59 <simon> (I just thought that was funny.)
02:17:04 <johnw> plus, although the types have to interact with IO in many ways, I'm determined that analysis algorithms can be kept completely pure
02:17:51 <hpaste> killy9999 pasted “Not in scope error” at http://hpaste.org/74670
02:17:53 <simon> are there any libraries for something like vector addition?
02:18:05 <merijn> Ok, I already said it yesterday, but I'll repeat: GADTs are freaking amazing :D
02:18:06 <killy9999> what am I doing wrong?
02:18:24 <alpounet> simon, for linear algebra, you have for example the hmatrix library
02:18:39 <johnw> merijn: what are you using them for?
02:18:41 <pharaun> johnw: how are you keeping it invisible?
02:18:49 <ivanm> killy9999: why are you using package imports?
02:19:04 <ivanm> and the constructor is StateT, not State
02:19:05 <johnw> pharaun: I hold IO actions in my data types, that only come into play if you do something like writeTree
02:19:05 <killy9999> ivanam: because I have to packages that have that module
02:19:07 <merijn> johnw: Mostly to provide all sorts of static guarantees together with DataKinds
02:19:09 <ivanm> just as the error says :)
02:19:31 <simon> alpounet, how about if I wanted to compose two two-tuples pairwise in other ways?
02:19:34 <merijn> johnw: i.e. I have some datatypes where not all functions on that datatype know how to deal with every constructor
02:19:43 <pharaun> johnw: aha i see
02:19:46 <killy9999> ivanm: if I change State to StateT I get error about incorrect kind
02:19:55 <pharaun> anyway night yah all
02:19:56 <ivanm> killy9999: not _all_ of them
02:19:58 <johnw> night
02:20:01 <ivanm> just the teims you're using it as a constructor
02:20:02 <johnw> time for me to hit the hay too
02:20:11 <ivanm> namely, line 8 column 7 and line 11 column 10
02:20:14 <merijn> johnw: I'll paste an example for you
02:20:14 <ivanm> just as the error messages say
02:20:15 <alpounet> simon, if i remember well, conal elliott has written a vector space library too
02:20:19 <mikeplus64> killy9999: i think you want to use return
02:20:34 <ivanm> mikeplus64: no he doesn't
02:20:49 <simon> killy9999, how about if you remove the qualified keyword?
02:20:57 <hpaste> merijn pasted “GADTs + DataKinds!” at http://hpaste.org/74671
02:21:04 <ivanm> simon: that's not the problem
02:21:24 <merijn> johnw: In that example I can use the RecType kind to control and enforce that functions only receive records they know how to deal with :)
02:21:43 <johnw> ooh
02:21:53 <johnw> this is *exactly* what I need for my Git library
02:22:06 <Hadaka> silly question about cmdargs - how can I make an argument mandatory, so that there's an error if it is not given?
02:22:12 <johnw> because mainly I deal with Blob/Tree/Commit
02:22:13 <hpaste> killy9999 annotated “Not in scope error” with “Not in scope error (annotation)” at http://hpaste.org/74670#a74672
02:22:20 <johnw> but sometimes I need to accept an Object
02:22:23 <killy9999> still doesn't work...
02:22:37 <merijn> johnw: :)
02:22:41 <johnw> Right now I have BlobO TreeO and CommitO as constructors
02:22:44 <johnw> but it's fugly
02:22:55 <ivanm> killy9999: same error?
02:22:59 <ivanm> or different error?
02:23:15 * hackagebot data-accessor 0.2.2.3 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.2.3 (HenningThielemann)
02:23:20 <ivanm> I still don't understand why you think you want package imports...
02:23:22 <johnw> merijn: could you help express what I have in terms of this usage?
02:23:37 <killy9999> ivanm: different one
02:23:39 <simon> killy9999, pop = St.State $ \(x:xs) -> (x,xs) -- it seems what you want is to return a value.
02:23:40 <johnw> see https://github.com/jwiegley/hlibgit2/blob/master/src/Data/Git.hs
02:23:57 <johnw> line 122 is where I have my ugly sum type
02:24:01 <hpaste> killy9999 annotated “Not in scope error” with “Not in scope error (annotation) (annotation)” at http://hpaste.org/74670#a74673
02:24:13 <ivanm> killy9999: well..... ? ;)
02:24:26 <johnw> although I wonder if maybe even GADTs aren't going to help me
02:24:39 <killy9999> iavnm: if I remove package import I get Ambiguous module name `Control.Monad.State': it was found in multiple packages: mtl-2.1.1 monads-tf-0.1.0.0
02:24:48 <Hadaka> &= opt (error "required")?
02:25:15 <mikeplus64> i think the problem is that Control.Monad.State does not export a State data constructor, you want to use StateT, and then pop would look like pop = StateT $ \(x:xs) -> return (x, xs)
02:25:20 <mikeplus64> killy9999:
02:25:29 <merijn> johnw: Sure
02:25:35 <ivanm> killy9999: so either hide monads-tf, or use a Cabal file to specify it
02:25:39 <Hadaka> doesn't work atleast straight away
02:25:41 <ivanm> ghc-pkg hide monads-tf-0.1.0.0
02:25:53 <killy9999> mikeplus64: bingo!
02:26:00 <killy9999> adding returns solves the problem
02:26:11 <killy9999> now I have to figure out why :)
02:26:22 <killy9999> seems that LYAH is not up to date
02:26:28 <mikeplus64> because StateT :: (s -> m (a, s)) -> StateT s m a
02:26:35 <mikeplus64> where does lyah have that?
02:26:38 <merijn> johnw: How do you want to restrict what people can do?
02:26:43 <mikeplus64> notice the m (a, s) :)
02:26:59 <johnw> merijn: I guess I can't know at compil etime
02:27:00 <killy9999> mikeplus64: in chapter 13
02:27:08 <merijn> johnw: Why not?
02:27:09 <johnw> but thanks for looking
02:27:24 <ivanm> mikeplus64: oh, sorry, you were right; I normally don't write explicit state functions and forgot about it being a _transformer_
02:27:36 <johnw> Because when you readObject :: Hash -> Object, I can't type that at compile-time
02:27:42 <johnw> at runtime it could be any of 4 things
02:27:43 <mikeplus64> ivanm: yeah, np
02:27:53 <johnw> Hash -> IO Object
02:28:05 <johnw> damn, Repository -> Hash -> IO Object
02:28:06 <merijn> johnw: The question is more: Do you have multiple combinations (i.e. some functions that only accept Tree/Commit, others that only accept Commit/Blob, etc.)?
02:28:13 <johnw> yes
02:28:19 <johnw> you can see my TreeOrBlob type
02:28:36 <mikeplus64> killy9999: hm, you're right, LYAH's State definition is out of date
02:28:46 <johnw> Git has the notions of things called "commitish" and "treeish" too
02:28:56 <johnw> a Commit is Treeish
02:29:04 <merijn> johnw: You could even encode that in the types, although it'd be a bit more complex than my current example
02:29:08 <johnw> and Tag is Commitish
02:29:18 <merijn> I'm not sure you can implement a sensible notion of "read", though
02:29:23 <johnw> yeh
02:29:35 <merijn> johnw: Unless you happen to know in advance what you'll be reading?
02:29:45 <johnw> i won't know at all
02:29:53 <johnw> although there will be time that I do
02:29:56 <merijn> johnw: Actually, I guess you could
02:30:06 <johnw> for those I was going to have readCommit
02:30:13 <johnw> which will throw an exception if the thing read isn't actually a commit
02:30:14 <merijn> You could just peak at the start to see what it is, then dispatch on that to call the right read
02:30:16 <mikeplus64> killy9999: probably should email the LYAH author about it
02:30:32 <johnw> anyway, thanks for looking
02:30:37 <johnw> time for sleepy bye now :)
02:30:53 <merijn> johnw: For what you'd want you'd need a type level set of capabilities, which is possible but not something I have to time to write for you now :p
02:30:55 <mikeplus64> killy9999: http://learnyouahaskell.com/faq see here
02:31:59 <killy9999> mikeplus64: good idea, I will
02:32:43 <ivanm> mikeplus64: is BONUS describing _a_ state monad or is he trying to describe the state monad as found in mtl/transformers though?
02:32:56 <merijn> killy9999: StateT is not the correct constructor for State values...
02:33:10 <merijn> :t StateT
02:33:11 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
02:33:15 * hackagebot alsa-seq 0.6.0.1 - Binding to the ALSA Library API (MIDI sequencer).  http://hackage.haskell.org/package/alsa-seq-0.6.0.1 (HenningThielemann)
02:33:16 <mikeplus64> ivanm: trying to describe what mtl exports
02:33:17 <merijn> :t State
02:33:19 <lambdabot> Not in scope: data constructor `State'
02:33:24 <ivanm> mikeplus64: ahhhhh
02:34:14 <killy9999> merijn: ?
02:34:18 <merijn> killy9999: Judging from your types you want "state" instead of StateT
02:34:38 <jfischoff> @tell Peaker I think you'll like this: http://www.youtube.com/watch?v=pqtqaL_ojpk&feature=plcp
02:34:38 <lambdabot> Consider it noted.
02:34:44 <merijn> killy9999: Your lambda's are not in a monad
02:35:02 <merijn> killy9999: Look at StateT, the function given to it should have type "s -> m (a, s)"
02:35:09 <merijn> killy9999: Yours have "s -> (a, s)"
02:35:12 <merijn> :t state
02:35:14 <lambdabot> forall s a. (s -> (a, s)) -> State s a
02:35:22 <merijn> :t StateT
02:35:24 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
02:36:36 <killy9999> merijn: yeah, seems right...
02:37:23 <killy9999> everyone in this channel always seems to be right, but I always need some time to figure out why
02:37:48 * killy9999 is getting inferiority complex
02:38:13 * timthelion has a long standing superiority complex.  And hands some overconfidence to killy9999 
02:38:15 * hackagebot sox 0.2.2.2 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.2.2 (HenningThielemann)
02:38:50 <merijn> killy9999: :p
02:39:07 <merijn> killy9999: If it's a consolation, I still feel that way :p
02:41:04 <killy9999> merijn: no, that only makes it even more obvious to me how little I know
02:41:20 <killy9999> TTT
02:42:35 <hpaste> killy9999 pasted “T.T.T.” at http://hpaste.org/74674
02:43:33 <Botje> do you mean the latin translation of WWW there?
02:43:36 <frerich> killy9999: That's a nice one :-)
02:45:03 <killy9999> frerich: The Little Schemer list Piet Hein's grooks as a further reading ;)
02:45:22 <vodik> hmm, can anyone point me to a change log or any resourced about whats changed with the FFI in ghc 7.6? im trying to compile glib and i get this: http://ix.io/2Zq
02:46:14 <timthelion> Have I not yet pointed out how half assed STM is? IO version of newTVar. This is useful for creating top-level TVars using unsafePerformIO, because using atomically inside unsafePerformIO isn't possible.
02:46:20 <vodik> the relevant code: {# pointer GDestroyNotify as DestroyNotify #}
02:46:21 <vodik> foreign import ccall "wrapper" mkDestroyNotifyPtr :: IO () -> IO DestroyNotify
02:46:25 <vodik> fuck
02:46:35 <vodik> ment to paste this: http://ix.io/2Zr
02:46:42 <vodik> sorry
02:47:10 <amosr> hmm
02:47:38 <timthelion> that was a quote from the haddock for newTVarIO...
02:48:09 <amosr> damn it. I had that issue a while ago
02:48:27 <amosr> but just cabal unpack'd and fixed it, and now I can't remember what the fix was
02:49:44 <vodik> amosr: damn
02:51:57 <vodik> what return type is a foreign declratiion supposed to have?
02:52:09 <vodik> afaik it has to be in IO
02:53:47 <ksf> is there, apart from GF, a parser that supports completition out of the box?
02:54:02 <ksf> uulib does error-correcting, but that's not really the same.
02:55:58 <amosr> vodik: I just did a diff and apparently I changed nothing. magic, huh
02:56:17 <vodik> amosr: ghc 7.6?
02:56:25 <amosr> ah.. head
02:56:50 <vodik> hmmm
02:56:55 <amosr> but it was a month ago or something that I had that problem
02:57:41 <killy9999> can I use cabal to download a source of some package?
02:57:57 <ivanm> killy9999: do you mean Cabal or cabal-install ?
02:58:00 <alpounet> killy9999, cabal unpack the-package
02:58:46 <killy9999> ivanm: cabal-install
02:59:06 <ivanm> then what alpounet said :)
03:02:18 <timthelion> I love stm...
03:05:37 <Reko> So I'm using the record update syntax. But I want to do something like newFoo = oldFoo { x = True }, where x is (Foo -> a). This doesn't work. What should I do?
03:06:28 <shachaf> Reko: Use lenses.
03:06:34 <Reko> OK
03:06:44 <shachaf> @google ekmett lens
03:06:46 <lambdabot> https://github.com/ekmett/lens
03:06:55 <shachaf> That URL has some documentation. :-)
03:07:00 <Reko> Thanks.
03:08:33 <vodik> amosr: i figured it out, but im not confident its correct
03:08:45 <vodik> changed mkDestroyNotifyPtr :: IO () -> IO DestroyNotify
03:08:47 <amosr> vodik: what'd you get?
03:09:06 <vodik> mkDestroyNotifyPtr :: (Ptr () -> IO ()) -> IO DestroyNotify
03:09:30 <vodik> but it builds
03:09:49 <amosr> excellent
03:10:48 <vodik> lots more errors
03:10:57 <vodik> so lets see if i can get this done
03:14:39 <hpaste> killy9999 pasted “How to desugar threeCoins?” at http://hpaste.org/74675
03:15:22 <merijn> killy9999: You can privmsg lambdabot with @undo to desguar do notation
03:15:48 <merijn> @undo do { a <- randomSt; b <- randomSt; return (a,b) }
03:15:48 <lambdabot> randomSt >>= \ a -> randomSt >>= \ b -> return (a, b)
03:16:03 <killy9999> hm... that's what I came up with
03:16:09 <killy9999> but somehow I can;t make this work
03:16:29 <merijn> :t liftA2 (,) randomSt randomSt
03:16:30 <lambdabot> Not in scope: `randomSt'
03:16:30 <lambdabot> Not in scope: `randomSt'
03:16:47 <merijn> :t let randomSt = state random in liftA2 (,) randomSt randomSt
03:16:49 <lambdabot> forall a b s. (Random a, RandomGen s, Random b) => StateT s Identity (a, b)
03:17:07 <killy9999> how should I run this from ghci?
03:17:25 <killy9999> runState randomSt >>= \a -> randomSt >>= \b -> return (a,b) $ mkStdGen 33
03:17:30 <killy9999> this does not work...
03:17:59 <merijn> killy9999: Parenthesis?
03:18:21 <merijn> killy9999: That parses as "(runState randomSt) >>="
03:18:40 <merijn> let randomSt = state random in runState randomSt >>= \a -> randomSt >>= \b -> return (a,b) $ mkStdGen 33
03:18:45 <merijn> :t let randomSt = state random in runState randomSt >>= \a -> randomSt >>= \b -> return (a,b) $ mkStdGen 33
03:18:47 <lambdabot>     Couldn't match expected type `s -> a'
03:18:47 <lambdabot>            against inferred type `State s1 a1'
03:18:47 <lambdabot>     In the first argument of `(>>=)', namely `randomSt'
03:19:00 <merijn> :t let randomSt = state random in runState (randomSt >>= \a -> randomSt >>= \b -> return (a,b)) $ mkStdGen 33
03:19:02 <lambdabot> forall a a1. (Random a1, Random a) => ((a, a1), StdGen)
03:19:47 <killy9999> hm...
03:21:00 <killy9999> ambigious type variables...
03:21:06 <amosr> > let combs xs = case xs of { [] -> []; x:xs -> repeat x `zip` xs ++ combs xs } in combs [1,2,3,4]
03:21:08 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
03:21:18 <amosr> does that have a name?
03:21:19 <merijn> killy9999: ambiguous? How so?
03:21:59 <killy9999> one moment
03:22:46 <hpaste> killy9999 pasted “Ambigious type variables” at http://hpaste.org/74676
03:23:49 <killy9999> fixed
03:24:04 <killy9999> of course it's ambigious
03:24:12 <killy9999> I didn't specify return type...
03:24:14 <killy9999>  :: ((Int,Int), StdGen)
03:24:35 <merijn> killy9999: Yeah :)
03:25:21 <killy9999> I'm still impressed by that liftM2 (,) solution
03:25:26 <merijn> :)
03:25:31 <killy9999> need to figure out how this works
03:25:38 <merijn> :t liftA2
03:25:39 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
03:25:45 <merijn> :t liftM2
03:25:46 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:25:46 <killy9999> I mean how does it maintain the state
03:25:54 <merijn> @src liftA2
03:25:54 <lambdabot> liftA2 f a b = f <$> a <*> b
03:25:58 <merijn> @src liftM2
03:25:59 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:26:07 <killy9999> ah, OK
03:26:34 <merijn> killy9999: liftM is just implemented to do the monad unwrapping for you :)
03:26:48 <merijn> (or applicative for liftA2, which is usually better since it's more general)
03:26:50 <killy9999> impressive
03:27:07 <t7> anyone got 3 mins to do a quick code review?
03:28:14 <hpaste> merijn pasted “GADT code duplication” at http://hpaste.org/74677
03:28:31 <merijn> Anyone that can help my simplify/reduce the redundancy in the code I just pasted?
03:38:46 <fmap> merijn: thanks, your example explained me why i want -XDataKinds
03:40:21 <merijn> fmap: :)
03:40:41 <merijn> I only learned of DataKinds yesterday and I already love it :p
03:41:12 <fmap> yeah, previously i had a bunch of empty data declarations, data kinds seem cleaner
03:43:09 <t7> it works
03:43:15 <t7> bottum up hindley milner
03:43:17 <t7> :D
03:43:28 <t7> i really need to make the code more sensible
03:53:53 <merijn> Is there a way to avoid having to fully qualify modules while importing?
03:54:30 <merijn> i.e. if I have a hierarchy of Foo.Bar can I have modules in Foo.Bar import each other without specifying "Foo.Bar" for each one?
03:54:57 <ivanm> no
03:55:16 <ivanm> not unless you bother writing some kind of preprocessor or something, anyway :p
03:55:34 <merijn> Bummer
03:57:07 <benmachine> merijn: keep your module names simple!
03:57:56 <merijn> benmachine: I'm thinking of just moving them mostly at the top level without bothering with an appropriate place in the hierarchy
03:58:56 <benmachine> merijn: cf. this article I wrote: http://www.haskell.org/haskellwiki/User:Benmachine/Overqualified_modules
04:02:31 <Reko> I need to work with a large number of booleans, I'd use bitflags in C. What should I use?
04:02:56 <ivanm> Reko: either booleans or a specialised data type
04:03:01 <timthelion> Reko: don't use Booleans.  Use a data constructor that better describe the values.
04:03:06 <ivanm> what are you doing that you need a large number of booleans?
04:03:22 <timthelion> s/describe/describes/
04:03:25 <ivanm> because as timthelion is hinting at, you're quite possibly going at it the wrong way
04:03:32 <Reko> Hmm... I suppose a datatype would work, yes
04:04:23 <Reko> I'm building an IRC server as a learning excercise, and wondering how to store the user mode.
04:04:47 <timthelion> Reko: data UserMode = Active | Away | ect.
04:04:56 <timthelion> Like that?
04:05:03 <Reko> No, like +abcd etc
04:05:29 <ivanm> you could have a list of possible states
04:05:32 * timthelion doesn't know anything about usermodes in IRC
04:05:34 <typoclass> reko: that's going to be only 10 or 20 modes, right? you'll be fine with a list
04:05:42 <ivanm> or the explicitly boring way of record data type with named fields for the possible options
04:05:57 <Reko> Yeah, that looks most sensible for now.
04:06:00 <shachaf> typoclass: A list isn't very nice for that.
04:06:22 <shachaf> The type is way too big.
04:06:27 <typoclass> shachaf: a list of the UserModes that timthelion suggested?
04:06:41 <ivanm> Reko: are all these modes independent?
04:06:46 <Reko> Yes
04:06:53 <shachaf> At least you'd want Set and not a list.
04:07:03 <Reko> https://www.alien.net.au/irc/usermodes.html <-- you can get idea of the number here
04:07:05 <shachaf> It's still annoying, though.
04:07:08 <typoclass> shachaf: hm, ok point
04:07:39 * shachaf doesn't actually know a good Haskell solution to the problem that "bitflags in C" solves. :-(
04:07:48 <shachaf> I've wondered about that before.
04:07:58 <Reko> Heh, funny idea... I could use a string, if I wanted to be weird. Just test if "i" or whatnot is in a mode string
04:08:08 <Reko> But I think that would be a little strange.
04:08:12 <ivanm> the only thing I've seen is RWH wrapping data types around bitflags from FFI :)
04:08:20 <ivanm> Reko: not to mention dodgy...
04:08:25 <shachaf> Reko: That's even worse. :-(
04:08:25 <Reko> Yeah.
04:08:31 <ivanm> that's even worse than using a list of a specified data type
04:08:36 <shachaf> Of course you can make a type like data Foo = Foo { active :: Bool, away :: Bool }
04:08:40 <shachaf> But that's not very nice either.
04:08:44 <Reko> shachaf: That's what I'm doing now
04:08:58 <ivanm> if you construct the data type in the order that you'd want the fields to be printed, then it's just a matter of map fieldToChar . Set.toList to get a printed list
04:09:26 <shachaf> timthelion: data LightPosition = Off | On is hardly better than data Bool = False | True
04:09:33 <shachaf> It has most of the same evilness as Bool.
04:09:55 <Reko> Bool is evil?
04:10:00 <shachaf> Yes.
04:10:06 <shachaf> E.g.
04:10:10 <shachaf> @google boolean blindness
04:10:11 <typoclass> Reko: has recently been discovered :-)
04:10:11 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
04:10:11 <lambdabot> Title: Boolean Blindness « Existential Type
04:10:19 <shachaf> And other things along those lines.
04:10:27 <ivanm> shachaf: it's better in the "which damn Bool field is _this_ meant to be?" case :)
04:10:39 <benmachine> shachaf: but surely LightPosition is what you're supposed to do to avoid boolean blindness
04:10:41 <ivanm> especially if you don't use record fields and blindly pattern match solely on the constructor
04:10:41 <merijn> Where should I submit GHC bug reports and how minimal does my reproducing case need to be?
04:10:48 <shachaf> benmachine: Not really.
04:10:59 <shachaf> It leaves you with almost all the same problems.
04:11:02 <benmachine> merijn: http://hackage.haskell.org/trac/ghc/ and, well, do the best you can
04:11:12 <benmachine> if you have some huge horrible testcase that's better than none at all
04:11:16 <typoclass> ivanm: i'm thinking not so much about printing, but about the logic. "if the guy is an admin, allow xyz". that'd involve an "Admin `elem` modes". it's not great, but i don't think it's unbearable either
04:11:26 <benmachine> shachaf: so what's your solution?
04:11:55 <ivanm> typoclass: well, Set would be better for that then list :)
04:12:17 <shachaf> benmachine: The solution to e.g. "case null l of False -> ...; True -> ...head l...tail l..." isn't "case null l of Empty -> ...; NonEmpty -> ...head l...tail l...", it's "case l of [] -> ...; (h:t) -> ...h...t..."
04:12:30 <ivanm> benmachine: he said he didn't really know a good solution for what bitfields do in C
04:12:36 <shachaf> Er, I got the Bools backwards.
04:12:42 <typoclass> ivanm: right, obviously, it's my dementia again
04:12:45 <shachaf> The point stands. :-)
04:12:50 <benmachine> shachaf: I see what you're saying, but I don't think that stuff is /always/ avoidable
04:13:03 <shachaf> benmachine: Not in Haskell, at least. :-)
04:13:10 <dibblego> do not use (Bool, a) but instead Either a a
04:13:15 <merijn> benmachine: Well, a couple hundred lines and around 10 files. I can reduce that somewhat with almost no effort. But making it more minimal than that would take more time than I can invest right now
04:13:31 <benmachine> merijn: the more you do the more likely it will be fixed
04:13:33 <shachaf> I don't think Either a a is significantly worse or better than (Bool,a)
04:13:42 <shachaf> Well, it has fewer _|_s, which is good.
04:13:46 <mysticc> Whats the problem with this http://hpaste.org/74681 .. Functional Dependencies and type infernces ..
04:13:50 <mysticc> *inferences
04:15:25 <shachaf> mysticc: I expect it's one of those "unification happens before resolving instances"-style things.
04:15:56 <shachaf> Does this issue come up in actual code for you?
04:16:11 <typoclass> shachaf: lists, Either, Bools ... is there any data type you're happy with?
04:16:21 <shachaf> typoclass: Lists are great*!
04:16:27 <shachaf> * Well, they're OK.
04:16:30 <mysticc> shachaf: It is simplified form of the code.
04:16:30 <shachaf> I like Either.
04:16:50 <shachaf> I also like Bool, if you treat it like it is.
04:17:02 <timthelion> shachaf: lists are awful. We should replace them with the phantom typed list of List NonEmpty and List Empty!
04:17:03 <mysticc> Maybe I like Either of List or Bool
04:17:08 <ivanm> shachaf: * most of the time
04:17:09 <ivanm> ?
04:17:10 <ivanm> :p
04:17:33 <shachaf> timthelion: That's pretty useless.
04:17:40 <timthelion> shachaf: No more errors!
04:17:40 <shachaf> At least index them by length or something.
04:17:51 <shachaf> Plenty more errors.
04:17:55 <mysticc> shachaf: What is "unification happens before resolving instances", Is there any resource to look ?
04:18:06 <shachaf> mysticc: Probably, but it's 04:17.
04:18:37 <mysticc> shachaf: Too early for you :P
04:25:58 <benmachine> I tried to devise a system of List Infinite and List Finite but iirc it didn't work
04:26:01 <hirsch_> Is it possible to create a type-based mapping from types to ints? I want something like 8Bit -> 1,  16Bit -> 2, 32Bit -> 4, FBit -> 4 without pattern matching
04:26:29 <benmachine> hirsch_: type class?
04:26:55 <benmachine> hirsch_: see the approach taken by Data.Fixed
04:26:56 <hirsch_> benmachine: I'm a noob, how?
04:27:11 <benmachine> hirsch_: well, do you know how to use type classes in general?
04:27:13 <hirsch_> benmachine: ok, i'll take a look
04:27:34 <hirsch_> benmachine: yes, I hope ;-)
04:27:58 <benmachine> hirsch_: ah, well, the trick here is to use a phantom type, I think
04:28:03 <benmachine> that's what Data.Fixed does
04:28:30 <hirsch_> benmachine: ok, good keywords
04:28:41 <hirsch_> benmachine: thanks
04:29:24 <benmachine> hirsch_: have a look at http://hackage.haskell.org/packages/archive/tagged/0.4.2.1/doc/html/Data-Tagged.html
04:29:51 <benmachine> hirsch_: that's the sort of phantom type I'm talking about
04:30:17 <benmachine> hirsch_: I'd use that with something like 'class NumBytes b where numBytes :: Tagged b Integer'
04:30:40 <hirsch_> ok, i see
04:31:18 <benmachine> hirsch_: instance NumBytes 8Bits where numBytes = Tagged 1
04:31:26 <benmachine> (leaving aside the fact that 8Bits isn't a valid type name :) )
04:31:54 <hirsch_> ;-)
04:32:19 <benmachine> hirsch_: then other instances like that, then you use something like unTagged (numBytes :: Tagged SomeType Integer) and you get an Integer which is different depending on what SomeType is
04:33:03 <hirsch_> aha, ok I'll try it out
04:34:21 <ray__> hi all
04:36:15 <applicative> hi ray__
04:36:38 <_flow_> I am having a problems trying to combine the STM and Maybe monad. Maybe it's not the right approach. Basically I want to do something like this: http://hpaste.org/74682
04:41:13 <donri> _flow_: are you doing something to isMaybeOk after binding it?
04:44:15 <_flow_> donri: yes, could that be a problem? there are still some old code parts after that
04:44:49 <donri> it would be a problem if you didn't; do constructs must end in an expression which such a binding is not
04:46:10 <_flow_> donri: the do block ends with an return
04:49:30 <merijn> Any volunteers with 7.4/7.6 willing to try and compile something for me to see if they can reproduce my GHC crash?
04:50:58 <hiptobecubic> merijn, i have 7.4.2
04:51:12 <hiptobecubic> > sequence [even, odd] 4
04:51:29 <hiptobecubic> Is that in the (-> r) monad or the [] monad?
04:51:40 <hiptobecubic> also, what happeend to lambdabot?
04:52:00 <hiptobecubic> @type Just 4
04:52:12 <hiptobecubic> Oh we're splitting. nevermind
04:53:04 <Botje> hiptobecubic: (-> r)
04:53:16 <Botje> since sequence :: [m a] -> m [a]
04:53:20 <Jafet> :t sequence
04:53:25 <hpc> 07:52 < Spock> ?type \f -> sequence [even, f] 4
04:53:26 <hpc> 07:53 <@Data> forall a. Integral a => (a -> Bool) -> [Bool]
04:53:30 <hpc> (from another network)
04:53:38 <hpc> so yes, it's the ((->) r) monad
04:54:16 <Jafet> How did Botje give the type before I asked for it?
04:54:36 <donri> @check \x -> map ($ x) [even, odd] == sequence [even, odd] x
04:54:42 <merijn> hiptobecubic: Can you grab the tar file here and run "cabal configure && cabal build" (which should build succesfully)
04:54:49 <Jafet> "Ok, passed 500 tests."
04:54:54 <hpc> lol
04:55:13 <hiptobecubic> merijn, where?
04:55:28 <merijn> hiptobecubic: eh, my bad http://staff.science.uva.nl/~meryn/
04:56:01 <hiptobecubic> What's the deal with ij <=> y anyway?
04:56:03 <merijn> hiptobecubic: And then, after building edit Task.hs and change "lift . apply boxfun pattern" to "\rec -> lift . apply boxfun pattern $ rec" and run cabal build again
04:56:19 <merijn> hiptobecubic: UvA administration are a bunch of noobs :p
04:56:23 <hiptobecubic> and then I see  ÿ on some handwritten sign in front of a restaurant and i just give up hope
04:56:47 <Botje> Jafet: because Botje is not a Botje :P
04:56:47 <merijn> The second cabal build should (if my minimal test is correct) panic GHC
04:57:18 <merijn> At least on 7.4, not sure about 7.6 because I don't have it installed
04:57:45 <hiptobecubic> merijn, updating cabal....
04:58:19 * hackagebot ghc-heap-view 0.3.0.2 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.3.0.2 (JoachimBreitner)
04:58:33 <merijn> hiptobecubic: The cabal version required might be to high, but I didn't feel like figuring out the lowest necessary cabal version too :p
04:58:54 <hiptobecubic> well, actually updating cabal's db, then transformers and mtl
05:01:31 <hpaste> typoclass pasted “ghc panic caused by merijn's test case” at http://hpaste.org/74684
05:01:43 <typoclass> merijn: ghc 7.4.2 panics ^^
05:02:02 <hiptobecubic> indeed
05:02:49 <merijn> \o/
05:02:56 <merijn> I found a bug, I'm so proud :p
05:03:02 <hiptobecubic> :)
05:03:23 <hiptobecubic> merijn, patch it, then you get your gold star.
05:05:38 <merijn> Completely unrelated question, how do I export a typeclass from a module? Or do I just export the functions defined in it?
05:05:51 <Botje> typeclasses are automatically exportd
05:05:57 <Botje> you can't not export them
05:06:02 <hpc> instances are automatically exported
05:06:18 <hpc> classes and their methods are something like.... i forget
05:06:21 <hpc> check the source for Prelude on hackage
05:07:14 <benmachine> Botje: no that's instances
05:07:31 <benmachine> I think type classes are just TypeClass(..)
05:07:37 <benmachine> you can definitely export them and also not
05:08:44 <Botje> oh, misheard then.
05:09:25 <merijn> GHC.Classes doesn't export classes :\
05:11:06 <merijn> Apparently you just write the class name in the export list
05:22:22 <jonathan-ut7> hello
05:22:35 <fmap> merijn: http://hackage.haskell.org/trac/ghc/ticket/6025
05:22:55 <jonathan-ut7> I wonder if I found a typo in the GHC 7.6.1 release notes
05:23:20 * hackagebot ghc-vis 0.3.2 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.3.2 (DennisFelsing)
05:24:02 <jonathan-ut7> In the user guide actually. At http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/defer-type-errors.html in "7.13.1. Enabling deferring of type errors" it says "evaluating x will result in a runtime type error" — should that be "evaluating z" ?
05:24:31 <merijn> fmap: Ah, bleh :p
05:24:59 <mysticc> jonathan-ut7: Try and see :P
05:25:29 <mysticc> Whats the problem with this http://hpaste.org/74681 .. Functional Dependencies and type inferences .. ??
05:25:30 <jonathan-ut7> mysticc: updating right now :)
05:43:09 <cyanoacry> nickse
05:45:29 <hpaste> applicative annotated “error.lhs” with “error.lhs (annotation)” at http://hpaste.org/74681#a74685
05:45:44 <applicative> mysticc: maybe it's  just that the compiler prefers typefuns to fundeps or whatever the nicknames are ^^^
05:50:09 <merijn> mysticc: Disclaimer, I'm not sure I understand fundeps well enough for this to be correct: It's because the fundep uniquely determines c, i.e you can't have "instance Foo Char Float", but could have "instance Foo Int Double"
05:50:26 <merijn> mysticc: As a result "Foo Int a" is not sufficient to determine (a ~ Float)
05:51:11 <merijn> mysticc: On the other hand, the type family one works because "Bar Int" has one, *unique* result
05:52:42 <hpaste> marcot pasted “Memory leak and strictness” at http://hpaste.org/74686
05:53:03 <marcot> Hi.  I'm having a problem trying to understand how can I make this toy program strict so that it will not memory leak.
05:53:06 <Athas> So, what's the type you're supposed to use when writing FFI wrappers for C functions accepting ints?
05:53:15 <Athas> CInt doesn't work anymore.
05:53:20 * hackagebot pqc 0.6 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.6 (KidoTakahiro)
05:54:19 <mikeplus64> Athas: what do you mean, doesn't work any more?
05:54:57 <marcot> What can I do to make the code more strict and stop the program from keeping the whole files in memory?
05:56:37 <Athas> mikeplus64: "Unacceptable argument type in foreign declaration: CInt"
05:56:52 <Athas> It's GHC upgrade time again, so code breaks.
05:57:36 <luite> Athas: it does, you just need to import CInt(..) instead of CInt from the module, constructors need to be in scope now for it to be used in FFI
05:57:54 <Athas> Oh, alright, thanks.
05:58:04 <Athas> I do recall reading something like that once.
06:01:49 <merijn> cabal complains that DataKinds is not a existing extension?
06:05:00 <mysticc> merijn: Sorry I was disconnected .. what were you saying ..
06:05:35 <shapr> Good Morning #Haskell!
06:06:03 <hpaste> typoclass pasted “extensions and cabal, irc log 7 sept 2012” at http://hpaste.org/74687
06:06:09 <typoclass> merijn: ^^
06:06:30 * typoclass yawns in the general direction of shapr :-)
06:06:43 <mysticc> http://hpaste.org/74681
06:06:46 <shapr> oh hai typoclass!
06:06:47 <mysticc> ^^ luite
06:06:51 <shapr> @localtime typoclass
06:07:10 <typoclass> shapr: it's 15:06 here :)
06:07:46 <mysticc> Perfect time to yawn
06:08:35 <typoclass> that's the spirit. it is _always_ time to nap
06:08:58 <shapr> It's 08:08 here.
06:09:07 <shapr> I need to check my NTP settings..
06:10:09 <merijn> typoclass: bummer
06:10:21 * typoclass wonders why stupid pidgin doesn't even answer those 'time' requests. it's not like the time of day is some secret private information
06:10:37 <mysticc> merijn: Even after adding something like | a->c , c->a .. It doesn't work .... Also I think a -> c means given a you can find c uniquely not the other way round ..
06:11:56 <merijn> mysticc: You might be right, I'm not sure :
06:12:27 <merijn> hmm
06:12:49 <merijn> Having to "cabal clean && cabal configure" after every build is slowing me down >.>
06:13:21 * hackagebot hedn 0.1.4.1 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.4.1 (AlexanderBondarenko)
06:15:57 <clsmith> hmm. Data.Map has instance Ord k => Monoid (Map k v), but i want to define instance (Ord k, Monoid m) => Monoid (Map k m). i don't suppose there's any way to do that without creating a data wrapper?
06:21:16 <parcs`> do you really need a Monoid instance? you can just do Map.unionWith mappend
06:21:43 <beanmachine> clsmith: no, there is no way without using newtype
06:21:54 <_flow_> is there a naming convention about maybe types? I think I read somethink like fooM or mFoo somewhere
06:22:15 <donri> mfoo seems common
06:22:19 <beanmachine> _flow_: what do you mean by maybe types?
06:22:27 <donri> often more elegant to use the maybe function instead
06:22:28 <beanmachine> donri: really? like where?
06:22:30 <_flow_> Maybe a
06:22:40 <beanmachine> _flow_: sure, but that already has a name :)
06:22:47 <donri> beanmachine: mfoo <- someMaybeComputation; case mfoo of Just foo -> ...
06:22:53 <parcs`> ghc uses foo_maybe
06:23:07 <beanmachine> so, we're talking about naming *values* of maybe type?
06:23:19 <_flow_> yes value names
06:23:23 <donri> yep. learn to read between the lines ;)
06:23:39 <beanmachine> donri: people should learn to ask precise questions :P
06:24:06 <hpaste> hirsch_ pasted “Data.Tagged” at http://hpaste.org/74689
06:24:08 <beanmachine> _flow_: normally, I'd name them without regard to their type as such
06:24:27 <beanmachine> I'd say there's no universal convention
06:24:29 <hirsch_> beanmachine: I don't get it
06:24:32 <clsmith> parcs`: yeah, i just hoped to have a Monoid instance with mappend = Map.unionWith mappend. seemed neat. :p
06:24:49 <fmap> what if you decide to change `Maybe a' to `Either String a' in the future?
06:24:57 <hirsch_> beanmachine: I don't understand how to unwrap the tagged value
06:24:57 <fmap> rename all variables?
06:25:02 <mysticc> clsmith: overlappingInstances extension ?
06:25:15 <hirsch_> beanmachine: http://hpaste.org/74689
06:25:26 <beanmachine> hirsch_: yeah, I'm looking at it
06:25:33 <beanmachine> hirsch_: I'm not 100% clear what you want to do
06:26:16 <beanmachine> hirsch_: what's the PixelType type for?
06:28:27 <merijn> Is there a type level undefined?
06:28:53 <mm_freak_> merijn: you can define one, if you enable UndecidableInstances
06:29:02 <merijn> mm_freak_: That doesn't sound like what I want...
06:29:15 <mm_freak_> then you should elaborate
06:29:22 <hirsch_> beanmachine: I have a pixelchannel (grey -> 1 and RGB -> 3) and channelbytes  (8bit -> 1, 16bit -> 2...) now i want a datatype pixeltype which can calculate the pixel size by using channels * pixelbytes
06:29:58 * benmachine wonders for how long he's had the wrong name
06:30:07 <merijn> mm_freak_: Ok, I have a set(list, whatever) of known length (i.e. I use type level naturals) and I want to define a class "get" that is defined for all Nat smaller than the length of the list...
06:30:40 <mysticc> benmachine: Since the beginning of Time ..
06:30:42 <mm_freak_> merijn: example?
06:30:51 <benmachine> mysticc: haven't had a name at all for that long
06:31:10 <benmachine> hirsch_: I still don't get it, why do you want a type that computes something? why not just a value?
06:31:24 <benmachine> (like, a function)
06:31:27 <mm_freak_> merijn: i mean, give me an application of that
06:32:12 <mm_freak_> merijn: do you want an indexing operation, where the index can't be out of range?
06:32:33 <merijn> mm_freak_: No, hold on. Lemme think of a good explanation
06:32:43 <mysticc> merijn: Have you checked out ghc 7.6 .. I think they have operators at type level with which you can do that easily (IIRC)
06:32:53 <hirsch_> I thought it can be done in a generic way at compile time  (PixelType (RGB Bit16)) -> 6
06:33:05 <merijn> mm_freak_: I have an interface where I have a bunch of functions of arbitrary arity (but known types) whose arguments should come from containers (Records)
06:33:21 <merijn> mm_freak_: So I have an apply function that statically verifies my pattern against the functions type
06:34:23 <benmachine> hirsch_: oh, ok, I see what you're saying
06:34:28 <merijn> mm_freak_: i.e. "apply :: Pattern p -> Fun p -> Record -> IO ()" where p is a [*] that I use to accept functions of the proper type as second argument (Fun is a typefun that turns p into a function type)
06:34:31 <benmachine> hirsch_: I wouldn't worry too much about whether or not it happens at compile time
06:34:37 <hirsch_> benmachine: I'm used to it in C++ metaprogramming
06:35:56 <merijn> mm_freak_: Now I want to be able to have a set of patterns and functions, which is easy enough to do (same as for patterns, but use [[*]]), so now I want to write "get (undefined :: 5) patternset" and get back the 5th function in the set, with the appropriate type
06:36:15 <hirsch_> benmachine: and I assumed it's also possible in haskell
06:36:27 <donri> @ask edwardk a stupid question; is there a dual of "to", that makes a write-only lens out of a setter function (a -> b -> a) or similar?
06:36:27 <lambdabot> Consider it noted.
06:37:10 <benmachine> hirsch_: well, the computation may or may not be done at compile time; if you /really needed/ it done at compile time you could do that, but I don't think it's worth the bother
06:37:37 * mysticc thinks mm_freak_  has left merijn alone for his type meditation .. 
06:37:54 <merijn> mm_freak_: Writing a type fun that is "Nat -> PatternSet s -> *" is easy, but writing get is a problem (since get's type is "? -> PatternSet s -> Result ? s" where ? should work for all Nat smaller than the size of the set)
06:38:36 <merijn> mm_freak_: I know how to define get for *all* Nat, just not how to do it for all Nat smaller than PatternSet s's size
06:39:13 <merijn> mysticc: 7.4 also has type level operators (but no promoted literals and comparison yet)
06:39:29 <mysticc> merijn: Are you on 7.4 or 7.6 ?
06:39:35 <merijn> 7.4
06:40:33 <hpaste> benmachine annotated “Data.Tagged” with “Data.Tagged (annotation)” at http://hpaste.org/74689#a74690
06:40:45 <kanedank`> I want to use parsec on a file with non ascii values, is that possible?
06:40:53 <maukd> kanedank`: sure, why not?
06:41:17 <Cale> kanedank`: Shouldn't require anything special.
06:41:42 <kanedank`> I'm wondering because in the rwh example I see: eol = char 'x'
06:41:56 <kanedank`> how would I create a eol from a hex value such as 0xff?
06:42:13 <Cale> :t '\xff'
06:42:14 <lambdabot> Char
06:42:25 <benmachine> hirsch_: http://hpaste.org/74689#a74690 does that annotation make things any clearer?
06:42:27 <benmachine> hirsch_: note that I need to give times3 an explicit type signature so that it chooses the right ChanBytes instance
06:42:29 <kanedank`> Cale: thanks!
06:42:32 <maukd> > '\255'
06:42:33 <lambdabot>   '\255'
06:42:50 <donri> > chr 0xff
06:42:51 <lambdabot>   '\255'
06:42:56 <Cale> > '\xff' == '\255'
06:42:57 <lambdabot>   True
06:42:58 <hirsch_> benmachine: Ah, ok
06:43:16 <hirsch_> benmachine: thank you
06:43:48 <maukd> > "\xf\ \f" == "\xf\&f"
06:43:49 <lambdabot>   True
06:44:39 <maukd> for bonus points, make \& show up in 'show' output
06:45:00 <Cale> > show "\SO\&H"
06:45:01 <lambdabot>   "\"\\SO\\&H\""
06:45:08 <mm_freak_> merijn: index :: Nat n -> List n a -> a  -- does this help?
06:45:08 <Cale> > "\SO\&H"
06:45:09 <lambdabot>   "\SO\&H"
06:45:19 <mm_freak_> oh, no, it doesn't
06:45:28 <maukd> Cale++
06:45:44 <ParahSailin_> @type chr
06:45:45 <lambdabot> Int -> Char
06:46:12 <benmachine> ok I just got a flood of messages all at once
06:46:16 * benmachine glares at freenode
06:46:20 <mm_freak_> merijn: index :: (m :<= n) => Nat m -> List n a -> a  -- does this help?
06:46:47 <merijn> mm_freak_: What's the m :<= n bit?
06:46:55 <mm_freak_> merijn: (:<=) is a type class
06:47:18 <donri> > maxBound >= ord maxBound
06:47:19 <lambdabot>   True
06:47:21 <merijn> mm_freak_: That's exactly what I needed but couldn't find
06:47:36 <mm_freak_> merijn: because you'll have to define it =)
06:47:58 <merijn> mm_freak_: Oh, I think I know already
06:48:42 <lpvb> some Java and C++ people keep asking me why type classes and ADTs are more powerful than OOP interfaces and generics/templates?
06:49:00 <maukd> they aren't more powerful than templates
06:49:04 <maukd> templates are too powerful
06:49:25 <lpvb> O.o
06:49:26 <maukd> and generic types are pretty much subsumed by parametric types
06:50:33 <typoclass> lpvb: i think the problem there is the word powerful. assembler is more powerful than anything. no memory safety, no type safety, no nothing
06:50:35 <lpvb> so what advantages do typeclasses and adt's have over C++ and Java?
06:50:42 <lpvb> okay
06:50:48 <lpvb> what advantages
06:50:51 <maukd> sanity
06:51:34 <companion_cube> lpvb: the ability to have the type several times in a signature
06:51:37 <maukd> what's a good link for the "expression problem"?
06:51:48 <companion_cube> as in  class Eq where (=) :: a -> a -> bool
06:51:57 <companion_cube> Eq a*
06:52:26 <lpvb> but you can do that with java generics?
06:52:27 <companion_cube> also, the ability to make a type defined elsewhere an instance of your typeclass
06:52:31 <maukd> lpvb: how?
06:53:30 <merijn> Ah, bollocks!
06:53:38 <companion_cube> lpvb: with generics you could do  interface Eq<A> { bool eq(A); }, maybe
06:53:43 <merijn> I forgot "(->) :: * -> *" :(
06:54:01 <companion_cube> but then every class C that implements the interface should implement Eq<C>
06:54:01 <benmachine> merijn: * -> * -> * itym
06:54:16 <maukd> (->) :: (->) * ((->) * *)
06:54:18 <Cale> class Read a where read :: String -> a
06:54:36 <lpvb> something like <T extends Eq & Ord> ?
06:54:59 <maukd> lpvb: that only looks like one T
06:55:03 <maukd> Cale: I can sort of do that in C++
06:55:15 <merijn> benmachine: Yeah, but you get what I mean :p
06:55:28 <alpounet> maukd, there's a haskell wiki page about the expression problem iirc
06:55:46 <benmachine> merijn: try not to wonder too hard what those symbols in between the stars are :P
06:55:50 <merijn> How would I write a type "Nat -> *" which lets me use the Nat in the type?
06:56:05 <lpvb> maukd: one T?
06:56:15 <yitz> maukd: you are saying a lot of very intelligent things today. you sound almost like mauke.
06:56:22 <merijn> i.e. I have a class "class (m :: Nat) :<= (n :: Nat)
06:56:24 <maukd> std::map<std::string, std::vector<std::size_t> >::const_iterator it; // unrelated but amusing
06:56:29 <companion_cube> it's the daemon version of mauke
06:56:43 <merijn> And want to write this function "getPattern :: (m :<= n) => PatternSet s n -> m -> Get m (PatternSet s n)"
06:56:54 <yitz> companion_cube: no, the daemon version of mauke just copies pastebins to hpaste.
06:56:55 <maukd> merijn: data Nat = Z | S Nat
06:56:59 <merijn> But of course that one is wrong, because m is not *
06:57:00 <maukd> merijn: IIRC
06:57:12 <maukd> er, wait
06:59:40 <Cale> merijn: data Vec :: Nat -> * -> * where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
06:59:40 <Cale> You mean like that?
06:59:40 <merijn> Cale: sorta-ish, but I don't have the recursion that Vec uses to create the Nat value
06:59:40 <Cale> lpvb: Here's another one that too many people take for granted, that doesn't even involve classes: sum types.
06:59:40 <merijn> Cale: Did you see the class/function I just wrote?
06:59:40 <Guest77111> \o/ managed to deploy my web application to my i386 debian server
06:59:40 <lpvb> Cale: what does that mean?
06:59:52 <Cale> lpvb: data Either a b = Left a | Right b
07:00:00 <Cale> lpvb: any data declaration involving |
07:00:25 <merijn> Cale: i.e. the only reason I want to have the Nat m in the type is to compute the proper return type of my function
07:00:31 <Cale> lpvb: Everyone uses product types (tuples/records/what-have-you) of nullable values to approximate sums
07:00:36 <lpvb> how does that give an advantage over the other languages?
07:00:42 <Cale> lpvb: and then you end up with situations like the one I'm in right now
07:00:57 <tdammers> 3 failed build attempts, and I now have a build server that's half debian stable and half testing, but it actually works.
07:01:12 <Cale> Where your data isn't supposed to have both field A and field B, but mysteriously you have a couple hundred records in your database where both are filled in
07:01:15 <Cale> and you have to deal with it
07:01:42 <typoclass> cale: you mean, the drawback is that in c for example, you'd have to do "this int is the result, but if it's negative, then it's an error instead"? in haskell that would just be Either Int Int
07:01:51 <Cale> typoclass: No, not just that
07:02:43 <yitz> tdammers: it seems like it works. until the next time you try to install something, or updates come in.
07:02:49 <maukd> typoclass: data Expr = Literal Int | Sum Expr Expr
07:02:55 <Cale> Here's the problem I'm currently dealing with. I have a bunch of Event records, and each may have a recurrenceBaseId (which indicates that this is an exception to a recurring event) or an rrule (which explains how this base recurring event occurs)
07:03:06 <tdammers> yitz: I actually went the semi-recommended route, with apt-pinning and all that
07:03:07 <Cale> An event is not supposed to ever have both
07:03:25 <Cale> But in my case, our database somehow has 218 such events
07:03:42 <tdammers> first I tried building everything with a ghc 6 toolchain, but couldn't get quasiquotes working correctly
07:03:44 <yitz> tdammers: a little better. but not much. and very awkward. i learned my lesson after i tried that once.
07:03:44 <Cale> and in 206 of those, the rrule in the child is not the same as the rrule in the parent
07:04:04 <Cale> and so I'm left trying to figure out what the heck this even means from our users' perspective
07:04:12 <tdammers> yitz: it's only the build server, and it sits on a VM. The actual production server is plain debian stable
07:04:15 <Cale> because from a technical perspective, it's not supposed to happen
07:04:24 <tdammers> (except for one library which I copied over manually)
07:04:38 <yitz> tdammers: ok, good luck to you. enjoy. ;)
07:04:43 <tdammers> certainlyh.
07:04:50 <typoclass> cale: right. basic sql can't represent that afaik, so you'd have an int. "it's either 1 or 2 or 3"
07:05:00 <Sculptor> hi
07:05:04 <Cale> and so, if the data were represented properly, we'd have two cases in the event datatype
07:05:13 <Cale> (actually probably more)
07:05:34 <tdammers> (it's a web-based document writer btw, with real-time preview and based on pandoc)
07:05:50 <Cale> We'd have one case for base recurrences, and another case for exceptions (this is being generous and assuming we don't have recursive types which would be even better)
07:06:08 <Cale> and then this problem would systematically be impossible
07:08:42 <Cale> (Which I guess is why we're going to rewrite this whole thing in Haskell)
07:09:04 <Cale> (a million reasons like that one)
07:09:33 <merijn> I don't suppose I can write "data Wrap :: Nat -> * where Wrap :: Wrap n"?
07:09:35 <yitz> Cale: if it's not practical for you to normalize your db model, you need to use a trigger to prevent such a record from being inserted
07:09:43 <kanedank`> why is the type for Text.Parsec.Token.symbol "String -> ParsecT s u m String" on Hackage and "GenTokenParser s u m -> String -> Text.Parsec.Prim.ParsecT s u m String" in my ghci?
07:10:46 <tdammers> kanedank`: different Parsec version maybe?
07:11:51 <maukd> @hackage parsec
07:11:52 <lambdabot> http://hackage.haskell.org/package/parsec
07:11:53 <kill10000> hm
07:12:12 <benmachine> kanedank`: it's because it's a record field
07:12:29 <maukd> kanedank`: because you're misreading the documentation
07:12:45 <benmachine> kanedank`: GenTokParser is a record type, with a field symbol of type String -> ParsecT s u m String
07:12:46 * killy9999 wonders when, how and why his nick got changed from killy9999 to kill10000
07:12:49 <Cale> yitz: it's not well-designed, it's some ORM auto-generated garbage, but yes, that's a good idea
07:13:22 <benmachine> kanedank`: hence you get an automatically defined accessor function, also called 'symbol'
07:14:03 <merijn> \o/
07:14:16 <merijn> Well, I managed to write the function I wanted :p
07:14:40 <merijn> Not sure anymore whether I'm becoming a genius are a deranged maniac, but at least my stuff compiles :p
07:14:48 <kanedank`> heading = between (char '[') (char ']') (many $ noneOf "]") is equivalent to heading = between (char "[) (symbol "]") (many $ noneOf "]")
07:14:54 <tdammers> merijn: then ship it already ;)
07:15:17 <Cale> yitz: I'm not sure the version of mysql this thing is using even supports triggers though, lol
07:15:21 <merijn> tdammers: Not done yet
07:15:22 <kanedank`> sorry: heading = between (symbol "[") (symbol "]") (many $
07:15:22 <kanedank`>             noneOf "]")
07:16:23 <maukd> char '[' *> many (noneOf "]") <* char ']'
07:16:46 <maukd> \[[^\]]*\]
07:17:03 <yitz> Cale: eww mysql no wonder
07:17:38 <Cale> yitz: But even before it's a problem with mysql it's a problem with most OO languages, including the especially shitty one that we're using.
07:17:45 <Cale> (lol groovy)
07:17:54 <benmachine> kanedank`: they are not equivalent, I don't think
07:18:12 <benmachine> kanedank`: or... I suppose they might be, depending on how your tokenizer behaves
07:18:50 <Cale> Scala has case classes and that's about it as far as support for sum types in typed-OO-land go.
07:19:58 <yitz> Cale: yeah relational theory isn't all that bad. but if the db design follows an OO design, it's the cart leading the horse.
07:19:59 <Cale> Oh, I guess I really shouldn't ignore O'Caml but it's really a functional language first anyway :)
07:20:50 <Cale> yitz: I would prefer a categorical design over a relational one.
07:21:21 <tdammers> OO code that manipulates relational data structures idiomatically isn't the end of the world
07:21:27 <yitz> Cale: agreed.
07:21:27 <Cale> But yeah, you can get by with a relational DB if you can add enough constraints
07:21:52 <tdammers> the party starts when clueless OO dumbnuts start designing "relational" databases
07:22:01 <Cale> tdammers: yes
07:22:23 <tdammers> (or "frameworks" that pretends the data isn't relational at all)
07:23:17 <Cale> We've inherited this ridiculous groovy/grails codebase that is so full of wtf code that it just needs to be wholesale replaced with something better.
07:23:52 <sipa> better rewrite it in PHP!
07:24:08 <tdammers> sipa: and then when you're done, rewrite PHP itself!
07:24:17 <sipa> good idea
07:24:21 <maukd> hphp
07:24:38 <yitz> Cale: what about clojure?
07:24:58 <Cale> yitz: I WANT TYPES
07:25:39 <maukd> what was that typed lisp called?
07:26:23 <yitz> maukd: ML
07:26:32 <tdammers> most lisps are typed, just not statically so.
07:26:34 * yitz ducks
07:26:55 <maukd> tdammers: that doesn't count as typed
07:27:18 <tdammers> well, static typing doesn't help much in an interpreted context, does it?
07:27:25 <maukd> you're crazy
07:28:33 <kowey> anyone here work on the haskell-related packages for MacOS X Homebrew?
07:28:46 <kowey> if so it'd be great if you could have a look at http://article.gmane.org/gmane.comp.version-control.darcs.user/26538
07:28:59 <Cale> yitz: There's no real need for the JVM here of course. If we were going to do the transition piecemeal then we'd probably use Scala just to be able to have types. Honestly, just rewriting in plain Java would be an improvement. But we're going to do it in Haskell, because tbh, very little about this server is really all that complicated in principle, and just rewriting it will be easier in the long run.
07:29:19 <maukd> ah, I meant Qi
07:33:12 <Cale> (Fixing bugs in this code is hell though, as it's essentially unreadable, because methods frequently do extra junk that their name doesn't suggest they ought to, things are broken into methods stupidly, where most methods only get called from one place, and code is copy/pasted when something actually has to be done in more than one place. You basically just have to run the code and watch very carefully in the debugger,
07:33:12 <Cale>  and hope that there isn't some concurrency going on higher up the call stack, or it just skips some of your breakpoints randomly.)
07:38:12 <marksd> Hey all. Working on a project that requires strict concurrency ( see http://tinyurl.com/HsStrictConcurrency ). Anyone have experience with the strict-concurrency package? Any other suggestions to resolve this issue?
07:39:19 <applicative> kowey: ah yes, this came up the other day on here. Is it enough to add --lame-env when installing gcc or maybe ghc?
07:39:26 <Cale> marksd: hmm
07:39:39 <hiptobecubic> Cale, sounds pretty great.
07:39:54 <raichoo> when using parsec: what do you import and why? Text.Parsec or Text.ParserCombinators.Parsec?
07:39:58 <Cale> marksd: try (const True $!) as the filter
07:40:48 <marksd> Doesn't const only receive one arg?
07:40:58 <Cale> raichoo: Text.Parsec, because the latter path is deprecated
07:41:12 <Cale> raichoo: (and only exists for backwards compatibility with old projects)
07:41:15 <marksd> Cale: esn't const only receive one arg?
07:41:24 <raichoo> Cale: Thanks :)
07:41:27 <Cale> :t const
07:41:28 <lambdabot> forall a b. a -> b -> a
07:41:39 <Cale> :t const True
07:41:40 <lambdabot> forall b. b -> Bool
07:41:45 <Cale> :t (const True $!)
07:41:46 <lambdabot> forall a. a -> Bool
07:42:55 <marksd> :t $!
07:42:56 <lambdabot> parse error on input `$!'
07:43:00 <Cale> :t ($!)
07:43:01 <lambdabot> forall a b. (a -> b) -> a -> b
07:43:12 <Cale> f $! x = x `seq` f x
07:43:29 <marksd> Cale: I see.
07:43:34 <kowey> applicative: thanks, I'm afraid I'm really just forwarding this along
07:43:40 <Cale> So it causes x to be evaluated before producing f x as the result
07:43:49 <kowey> applicative: I do use Homebrew, but not for Haskell stuff :-)
07:44:02 <maukd> f $!! x = (x `seq` f) x
07:44:05 <kowey> was just hoping some helpful package maintainer would send mxcl a patch of some sort :-)
07:44:08 <Cale> marksd: In this case, I suppose we could also just use (`seq` True) as the predicate :)
07:44:24 <Cale> (that's identical)
07:45:45 <applicative> kowey: think  the homebrew ghc and haskell platform are a menace, but it would be good if the 'platform installer' allowed you to just get the gcc from them rather than the accursed  XCode
07:46:01 <applicative> I think, rather
07:46:36 <Cale> marksd: I'm interested to know if the performance improves then. I think it's likely that you get better performance because the evaluation of a non-const predicate is forcing the evaluation of the things you're filtering. However, this will only force evaluation to weak head-normal form (i.e. up to determining the outermost data constructor), which may or may not be enough evaluation.
07:47:38 <kowey> I'm rather out of the loop, and reluctant to upgrade my XCode 4.3 or Lion machine myself
07:47:59 <kowey> getting this mail on the darcs-users list was a helpful reminder to me what the perspective of say a ruby programmer might be
07:48:13 <marksd> Cale: Well, I'm going to try it out.
07:48:32 <kowey> when wanting to install a haskell tool “buh, I don't want to mess with this stuff, so homebrew!”
07:48:45 <marksd> Cale: However, clients of my code define the predicate, so using strict-concurrency is likely a better case. Don't want to force clients to use predicates of a certain form if we can avoid it :)
07:49:30 <Cale> marksd: well, you can put that strictness into the code which is calling the predicate instead
07:50:02 <lispy> kowey: what's the problem? That you have to install Apple's gcc?
07:50:09 <Cale> marksd: i.e. if you get the predicate p from the client, apply it with  p $! x  instead of  p x
07:50:16 <hpaste> Adnauseam pasted “cast9s ” at http://hpaste.org/74693
07:50:32 <adnauseam> fuuuuu
07:50:34 <adnauseam> why
07:50:49 <adnauseam> i'm somewhat lost with this http://hpaste.org/74693
07:51:01 <marksd> Cale: Turns out it's not enough. The problem is with writeChan, not the predicate.
07:51:06 <adnauseam> the error is at the bottom of the hpaste
07:51:12 <applicative> lispy: no, its that the new homebrew haskell platform gives you trouble when you call the gcc  http://article.gmane.org/gmane.comp.version-control.darcs.user/26538
07:51:31 <Cale> adnauseam: castSum result  looks ill-typed
07:51:50 <Cale> adnauseam: did you want  castSum (result:xs) ?
07:52:08 <adnauseam> mm, yes
07:52:18 <Cale> marksd: hmm
07:52:20 <adnauseam> i'll add the () and see what happens
07:52:34 <Cale> marksd: What type of data are you writing into the channel?
07:52:34 <lispy> applicative: the solution seems easy, don't use homebrew :)
07:53:14 <maukd> :t mfix
07:53:15 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
07:53:15 <merijn> applicative: What's so accursed about XCode?
07:53:26 <maukd> :t mfix :: (() -> STM ()) -> STM ()
07:53:27 <lispy> applicative: their development style scares me, so maybe I'm just biased (being told that part of the install involves a chmod to a system wide dir just isn't right)
07:53:27 <lambdabot> Not in scope: type constructor or class `STM'
07:53:27 <lambdabot> Not in scope: type constructor or class `STM'
07:53:47 <applicative> merijn: I just meant its big, and people wanting to install haskell platform make all kinds of mistakes installing
07:53:54 <merijn> ..
07:54:06 <merijn> Go to AppStore, search XCode, click install :p
07:54:22 <applicative> lispy: you can install homebrew locally ( I don't in fact :) )
07:54:27 <merijn> I guess the new version has one extra step of selecting "install commandline tools"
07:54:40 <applicative> merijn: it always had  that step
07:54:42 <applicative> or often
07:54:57 <hpaste> toothbrush0 pasted “lambda calculus factorial” at http://hpaste.org/74694
07:55:03 <toothbrush0> hi all. I'm trying to define a factorial function using only lambda calculus, but I'm getting stuck on defining "predecessor" and "factorial" functions...
07:55:05 <applicative> of course, those are all we want -- I think just gcc maybe some associated libraries like libgmp?
07:55:47 <marksd> Cale: data Event =  Added FilePath UTCTime
07:56:05 <marksd> Cale: Added ... | Modified ... | Removed ...
07:56:12 <applicative> merijn: also, I've never used the AppStore that's another reason I keep not upgrading my old laptop...
07:56:56 <Cale> marksd: Okay, so evaluating one of those will cause it to be evaluated enough to know that it's Added or Modified or Removed, but perhaps not enough to know that the path or timestamp are, if those would involve more evaluation.
07:57:07 <Cale> what*
07:58:23 * hackagebot fb 0.12 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12 (FelipeLessa)
07:58:24 <Cale> marksd: I believe the writeChan c x  in strict-concurrency is the same as just writing   writeChan c $! x
07:58:25 * hackagebot fb 0.12.2 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12.2 (FelipeLessa)
07:58:27 * hackagebot yesod-recaptcha 1.1.0.1 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.1.0.1 (FelipeLessa)
07:58:38 <Cale> marksd: and that should be the only difference between that and the usual Chan
07:59:04 <maukd> predecessor n = snd (pred n) where pred Z = (Z, Z); pred (S n) = let m = fst (pred n) in (S m, m)
07:59:33 <Cale> marksd: so if you replace your call to writeChan with that, it should work the same as if you'd used the strict-concurrency package
07:59:36 <toothbrush0> maukd: you're using lets though
07:59:41 <maukd> toothbrush0: and?
07:59:45 <toothbrush0> i'd prefer to just stick to lambda calculus
07:59:57 <maukd> let x = y in z ==> (\x -> z) y
08:00:03 <toothbrush0> true
08:00:13 * toothbrush0 has d'oh moment :)
08:01:11 <toothbrush0> maukd: now to get rid of the pattern matching... thing is, i'm prototyping in haskell, but actually, I want to be able to express factorial in my own Lam/App/Var AST
08:01:36 <toothbrush0> which happens to be well-typed, which is a pain in this case; fix is posing a problem too...
08:02:00 <Cale> marksd: oh, no wait a minute
08:02:10 <Cale> marksd: The documentation for that package lies :)
08:02:21 <marksd> Cale: how so?
08:02:28 <Cale> marksd: it's the same as using rnf on the data, and then putting it into the channel
08:02:33 <Cale> not just seq :)
08:03:12 <Cale> (the top of the docs say that it evaluates just to WHNF, but this isn't the case)
08:03:24 * hackagebot hissmetrics 0.4.0.1 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.4.0.1 (FelipeLessa)
08:04:12 <Cale> errrrr
08:04:28 <Cale> wait, no
08:04:35 <maukd> toothbrush0: represent types as their own catamorphism
08:04:39 <Cale> wtf, why is it demanding an NFData instance?
08:05:01 <toothbrush0> maukd: just for interest sake, did you see the hpaste I sent?
08:05:04 <Cale> okay, no, I take it back, this really is just the same as using $!
08:05:05 <maukd> ah, no
08:05:07 <toothbrush0> 16:57 < hpaste> toothbrush0 pasted “lambda calculus factorial” at http://hpaste.org/74694
08:05:10 <toothbrush0> 16:57 < hpaste> toothbrush0 pasted “lambda calculus factorial” at http://hpaste.org/74694
08:05:13 <toothbrush0> 16:57 < hpaste> toothbrush0 pasted “lambda calculus factorial” at http://hpaste.org/74694
08:05:21 <Cale> except that it requires an NFData instance for no good reason
08:05:24 <toothbrush0> oops, sorry :(
08:05:39 <kowey> lispy: ah yeah that was sort of the discovery from that darcs-users thread for me.  Non-haskellers on Mac will reach for Homebrew
08:05:50 <kowey> lispy: or $insert-pkg-mgr here
08:06:02 <maukd> toothbrush0: your fix isn't lambda calculus
08:06:10 <maukd> and you can't directly write LC in Haskell
08:06:25 <toothbrush0> maukd: hm, i see
08:06:31 <toothbrush0> because of the type requirements?
08:06:36 <maukd> yes
08:06:39 <toothbrush0> ok
08:06:52 <toothbrush0> at least it's right that I'm failing then, that's an encouragement
08:06:59 <toothbrush0> and indeed, fix was dubious
08:07:02 <maukd> there's a trivial embedding in Perl, though :-)
08:07:03 <Cale> Well, I believe you can always insert newtypes such that the untyped lambda calculus terms will typecheck
08:07:06 <toothbrush0> haha
08:07:14 <kowey> (it's a discovery on the order of “people will try to doubleclick .hs files to make them install“)
08:07:27 <toothbrush0> well, I'm aiming to implement this in Agda, in my lambda-AST, which is even more restrictively-typed
08:07:32 <toothbrush0> so that's probably futile
08:07:54 <kowey> (ie. where you forget how implicit certain things are for you, like “just grab the HP binary“ or “open a terminal")
08:08:25 * hackagebot yesod-fb 0.1.2 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.1.2 (FelipeLessa)
08:08:28 * hackagebot yesod-auth-fb 1.2.2 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.2.2 (FelipeLessa)
08:08:40 <marksd> Cale: Huh. $! does not fix the writeChan case.
08:08:57 <Cale> marksd: But strict-concurrency works somehow?
08:09:13 <marksd> Cale: That's correct.
08:10:30 <Cale> marksd: what code is this in?
08:10:48 <donri> it seems to me performance-oriented libraries add INLINE under every single function, what's up with that? why isn't it the default behavior of the compiler if it's so useful?
08:13:09 <Cale> marksd: the handleEvent in System.IO.FSNotify.Linux?
08:13:31 <yitz> kowey: i reach for macports. but yeah.
08:13:43 <marksd> Cale: https://github.com/gregwebs/hfsnotify/tree/strict-concurrency
08:15:51 <Cale> marksd: Where are you actually importing Control.Concurrent.Chan.Strict there?
08:16:01 <Cale> oh, I see
08:16:07 <marksd> Cale: We're only testing against OSX for now.
08:20:58 <merijn> What does "orphan instance" mean?
08:21:07 <Cale> marksd: and so this writeChan chan event on line 48 of Polling.hs, it doesn't fix things the same way if you use a normal Chan and writeChan chan $! event ?
08:21:25 <maukd> merijn: an instance unrelated to the type or the class
08:21:31 <Cale> merijn: An instance which is in a module that is not the module where either the datatype or the class are defined
08:21:34 <maukd> nah, too ambiguous
08:22:30 <merijn> Cale, maukd: Right, thanks
08:22:49 <Cale> merijn: Once instances are orphaned like that, it's possible to write two different instances for the same type and class
08:22:56 <merijn> Is that error silenceable?
08:23:11 <Cale> merijn: However, modules which make two different decisions about which instance to import can never be used together
08:23:22 <robstewartuk> /msg bos bos Where did `elem` disappear to in Data.Text in `text' ? It
08:23:22 <robstewartuk>      was there in v0.4, but not in 0.11.2.3 ?
08:23:24 * hackagebot regex-compat-tdfa 0.95.1 - Unicode Support version of Text.Regex, using regex-tdfa  http://hackage.haskell.org/package/regex-compat-tdfa-0.95.1 (KidoTakahiro)
08:24:04 <Cale> merijn: It's not an error is it?
08:24:09 <merijn> Eh, warning I mean
08:24:23 <marksd> Cale: It's difficult to test the Polling implementation. Most platforms automatically build against the OS-specific implementation.
08:24:39 <Cale> marksd: hmm
08:24:53 <Cale> marksd: That's the only place you're using strict-concurrency though?
08:25:07 <hirsch_> I have a datatype: "data CompType    = Int8 | Int16 | Int32 | Int64 | Float deriving (Show, Eq, Storable)" and I want to call Foreign.Storable.sizeOf but ghc says:  Image.hs|9 col 77 error| Can't make a derived instance of `Storable CompType':
08:25:07 <Cale> oh, there's a change here in OSX as well
08:25:07 <hirsch_> ||   `Storable' is not a derivable class
08:25:07 <hirsch_> || In the data type declaration for `CompType'
08:25:08 <Cale> I see
08:25:51 <Cale> hirsch_: You'll have to write your own instance of Storable if you define your own type
08:25:54 <mysticc> Why do I need Rank2Type to declare something like type Foo = Show a => Maybe a ? Whats Rank has to do here ?
08:26:22 <hirsch_> Cale: But all Constructors are Storable?
08:26:37 <Cale> hirsch_: not without a Storable instance they're not
08:26:56 <Cale> hirsch_: you need to say how they get encoded into memory from the C library's point of view
08:26:59 <hirsch_> Cake: They all have instances
08:27:14 <Cale> hirsch_: hm?
08:27:24 <rwbarton> what's a Constructor
08:27:36 <hirsch_> Int8 has a Storable instance
08:27:42 <Cale> hirsch_: what you have defined is the same as   data CompType = A | B | C | D | E deriving (Show, Eq, Storable)
08:27:44 <maukd> hirsch_: you're not using Int8
08:27:52 <solomatov> Hi! I am reading theorems for free by Wadler, but it feels overly complicated to me. Can anyone recommend something similar but more readable?
08:28:12 <Cale> hirsch_: except that you have named your data constructors differently (with names that happen to be the same as names of types)
08:28:13 <rwbarton> solomatov, unfortunately nothing is really free
08:28:32 <Cale> hirsch_: since they're values and not types, they're in a different namespace, so there's no clash
08:28:41 <hirsch_> Cale: ah ok
08:28:50 <solomatov> rwbarton: I understand :) But I want to learn more about free theorems
08:28:51 <Cale> hirsch_: but the Int8 you just defined has nothing to do with the existing Int8
08:29:08 <solomatov> I tried googling and found almost nothing. T
08:29:11 <hirsch_> Cale: What I really want is a typelist
08:29:22 <Saizan> solomatov: maybe look for papers on parametricity, there might be some of your taste :)
08:29:40 <solomatov> Saizan: ok will try
08:30:05 <hirsch_> Cale: How can I create a set of types that are allowd
08:30:35 <rwbarton> hirsch_, what are you trying to do
08:30:44 <Cale> hirsch_: You could write something like  data CompType    = Int8 Int8 | Int16 Int16 | Int32 Int32 | Int64 Int64 | Float Float
08:31:05 <rwbarton> e.g., allowable in what context
08:31:12 <hirsch_> Cale: Ok that's an idea
08:31:39 <Cale> hirsch_: and then have an instance of Storable which uses the Storable instances for each of those types, probably along with writing an extra integer tag to say which case it is
08:32:24 <Cale> (because it's pretty useless to try reading one of those things if you can't tell whether you're trying to read an Int8 or a Float)
08:32:34 <rwbarton> alternatively you may want a type class
08:32:46 <Cale> yeah, it's not entirely clear what's going on here :)
08:33:30 <Cale> hirsch_: presumably you're writing an FFI binding?
08:33:33 <rwbarton> for example, if all you want to do with these types is store/load them to/from memory, Storable already exists for that purpose
08:34:09 <Cale> hirsch_: what exactly are you trying to accomplish? :)
08:34:19 <hirsch_> Cake: I try to write a binding to an imageprocessing library
08:34:43 <Cale> btw, my name is Cale
08:35:17 <Cale> hirsch_: okay, so what is it that you need this type for?
08:35:36 <Cale> (why don't you know which of these types of number you have?)
08:36:36 <hirsch_> Cale: it's a field in the Image record
08:36:40 <Cale> Presumably when you load or store an image, the image format is going to precisely determine which of these types of data you'll be using at every point.
08:37:06 <Cale> aha, so you *really* want to store a tag saying which type of data is going to be used?
08:37:23 <Cale> Presumably the C library has an enum?
08:37:23 <maukd> ahahaha, "Cake"
08:37:41 <rwbarton> Cale: you mean it's not Ca<tab>?
08:37:57 <hirsch_> Cale: like an enum but in two dimensions (PixelType and ComponentSize) and I want to calculate the Pixelsize
08:38:09 <Cale> It is Ca<tab> if your IRC client is smart
08:38:30 <rwbarton> oh wait so maybe you really did mean data CompType    = Int8 | Int16 | Int32 | Int64 | Float?
08:39:17 <rwbarton> like a C enum { comp_type_int8, comp_type_int16, comp_type_int32, comp_type_int64, comp_type_float }; ?
08:39:57 <hirsch_> rwbarton: yes kindof but with the associated byte sizes
08:40:09 <rwbarton> I don't know what that means
08:40:19 <Cale> hirsch_: Okay, *which* image library? :)
08:40:22 <hirsch_> rwbarton: I thougt I can calculate them with sizeOf
08:40:24 <rwbarton> you can always write a function
08:40:29 <Cale> (so we can just look at it)
08:40:37 <hirsch_> Cale: internal, commercial
08:40:39 <rwbarton> not unless you do something more clever
08:41:02 <Cale> hirsch_: Can you paste the definitions of the C types which you're trying to reflect on the Haskell side?
08:41:11 <atriq> I'm reading the GHC user guide
08:41:20 <hirsch_> rwbarton: I wanted to avoid this messy boilerplate code
08:41:21 <rwbarton> right, or how would you do what you are trying to do in C
08:41:21 <atriq> Is Heirarchial module names really an extension?
08:41:27 <Cale> hirsch_: because it's really really unclear what you're trying to do here
08:41:45 <Cale> atriq: It's an extension to Haskell 98
08:41:47 <Cale> atriq: yes
08:41:52 <paolino> @hoogle Array i (Array i a) -> Array (i,i) a
08:41:52 <lambdabot> No results found
08:42:01 <Cale> (but it's one which was adopted directly into the standard)
08:42:05 <atriq> So is the section in the GHC User's Guide relevant now Haskell 2010 is a thing?
08:42:15 <rwbarton> hirsch_: somehow you have to tell it that 0, or whatever is the C representation of "Int8", corresponds to Int8 or at least a 1-byte data type
08:42:17 <Cale> I dunno, maybe.
08:42:28 <atriq> "GHC supports a small extension to the syntax of module names: a module name is allowed to contain a dot .."
08:42:30 <Cale> Haskell 2010 is kind of a thing
08:42:31 <rwbarton> I suggest you get something working first and then worry about reducing boilerplate...
08:43:19 <rwbarton> often getting a working version clarifies what exactly you are trying to do and how to do it more simply
08:44:02 <hirsch_> Cale: I'm not so far, assume I have an Image consisting of Pixels. A pixel can consist of (1 Gray, 3 RGB, 4 RGBA) channels and these channels habe components in (8, 16, 32, 64, float) representation, so I have 12 combinations that are possible
08:44:17 <Cale> yes, okay
08:44:30 <Cale> and so you have some C structure describing your pixel format
08:44:32 <Cale> right?
08:44:51 <rwbarton> that you are trying to read with Storable
08:44:58 <hirsch_> Cake: forget the C part, I'm talking of the haskell representation of the image
08:45:26 <Cale> Then we're not going to worry about Storable at all
08:45:30 <Cale> because you don't need it?
08:45:31 <hirsch_> The haskell imterface
08:45:53 <hirsch_> Cale: Sure, for calculating the image size for example
08:46:04 <Cale> Uhh...
08:46:06 <Cale> What?
08:46:09 <ski> paolino : it might be irregular
08:46:18 <rwbarton> he wants to use sizeOf rather than writing a 5-line function
08:46:32 <hirsch_> for the serialization and deserialization which comes later
08:46:40 <hirsch_> rwbarton: correct
08:46:51 <rwbarton> but he will have to write a 5-line function to serialize/deserialize this tag anyways so...
08:47:05 <Cale> Well, okay, you can use sizeOf, but you'll be using *existing* instances of sizeOf
08:47:07 <Cale> not a new one
08:47:32 <Cale> Because you'll know which type of data you're using
08:47:35 <hirsch_> I want to avoid the boilerplate code for all type combinations
08:47:52 <rwbarton> combinations?
08:47:56 <Cale> Because presumably your image type will be parametrised by it
08:48:20 <monochrom> hrm, where is Haskell Weekly News? :)
08:48:21 <Cale> So you'll be applying sizeOf to a value of whatever type your image type is parametrised by
08:48:21 <hirsch_> RGB 8, RGB 16, RGB 32, Grey F ...
08:48:34 <rwbarton> can't you just... multiply
08:48:35 <hirsch_> Cake: yes
08:48:44 <Cale> Yeah, you should just be multiplying
08:48:58 <Cale> I don't really understand
08:49:01 <dfordivam> hello
08:49:20 <hirsch_> rwbarton: that's what I'm trying to do, and I didn't want to hardcode the bytesizes, I used existing types
08:49:21 <akamaus> hi! I know there are some libraries for marshalling of C data types. But what's about the following task? Say, I want to write a storable instance for a record. The binary representation of the record is not dense, there are gaps of different sizes between the fields.  I can easily write a Storable instances by hand, but it started to get boring. Any ideas how to automate it?
08:49:26 <Cale> Are you trying to save one multiplication by having a table lookup? If so, that is absurd.
08:50:31 <hirsch_> Cake: no, all I wanted to do it using sizeOf ComponentType instead of a creating a dumb table
08:50:39 <Cale> akamaus: There's c2hs which will write Storable instances for you. I'm not totally certain how it deals with gaps
08:50:57 <Cale> I'm not Cake!
08:50:58 <Cale> lol
08:51:03 <hirsch_> upps
08:51:15 <sipa> hirsch_: tip: use Ca<tab>
08:51:29 <monochrom> yes, Ca<tab> gives you Cake
08:51:34 <hirsch_> sipa: haha I used it
08:51:36 <osfameron> the Cale is a lie!
08:51:52 <Cale> monochrom: Not in my IRC client, because it orders by last spoken.
08:52:01 <monochrom> unless you use better software that chooses "recently spoken"
08:52:02 <nand`> never assume all clients are sane
08:52:04 <hirsch_> Cale: wow
08:52:06 <nand`> that is a dangerous thing to do
08:52:15 <monochrom> yes Cale I use such better software, too
08:52:44 <monochrom> do not underestimate the number of people who use inferior software
08:53:43 <rwbarton> anyways what Cale is saying is presumably you will end up with a representation like data Image p a = Image { width :: Int, height :: Int, pixels :: [[p a]] } -- or something less awful
08:54:03 <hirsch_> Ah, one more thing: How can I restrict the allowed types
08:54:10 <rwbarton> where p might be data RGB a = RGB a a a, and a might be Int16
08:54:28 <hirsch_> That was also a reason for my CompType datatype
08:55:03 <rwbarton> restrict as necessary when a function needs a restriction
08:55:48 <rwbarton> using a specific type or a type class
08:59:00 <nand`> ‘restrict the allowed types’ sounds like DataKinds
08:59:07 <nand`> disclaimer: I only read the last few messages
08:59:38 <rwbarton> you can also play games like data CompType a where Int8 :: CompType Int8; Int16 :: CompType Int16; ...
09:00:13 <mysticc> @hoogle Get
09:00:13 <lambdabot> Prelude getChar :: IO Char
09:00:13 <lambdabot> System.IO getChar :: IO Char
09:00:13 <lambdabot> Prelude getContents :: IO String
09:06:58 <benmachine> mysticc: are you looking for binary or cereal?
09:11:34 <junis> greetings fine people ... what's the modulo operator
09:11:42 <atriq> mod
09:11:46 <atriq> > 7 `mod` 3
09:11:47 <lambdabot>   1
09:11:53 <junis> thank you
09:11:57 <atriq> No problem :)
09:12:11 <ski> > (-7) `mod` 3
09:12:12 <lambdabot>   2
09:12:20 <mysticc> @hoogle MonadState
09:12:20 <lambdabot> Control.Monad.State.Class class Monad m => MonadState s m | m -> s
09:12:21 <lambdabot> Control.Monad.State.Lazy class Monad m => MonadState s m | m -> s
09:12:21 <lambdabot> Control.Monad.State.Strict class Monad m => MonadState s m | m -> s
09:14:34 <ski> paolino : what should the bounds of the output array be if the input array is empty ?
09:14:41 <deech> Hi all, I'm fairly comfortable with Haskell and Java and have recently taken a position working in Scala full-time. Are there any tutorials that ease the transition?
09:16:36 <mysticc> @hoogle StateT
09:16:36 <lambdabot> Control.Monad.State.Lazy StateT :: (s -> m (a, s)) -> StateT s a
09:16:36 <lambdabot> Control.Monad.State.Strict StateT :: (s -> m (a, s)) -> StateT s a
09:16:36 <lambdabot> Control.Monad.Trans.State.Lazy StateT :: (s -> m (a, s)) -> StateT s m a
09:17:04 <ski> @index StateT
09:17:04 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS
09:19:13 <atriq> @unmtl StateT s m a
09:19:13 <lambdabot> s -> m (a, s)
09:19:23 <atriq> @mtl s -> m (a, s)
09:19:23 <lambdabot> Maybe you meant: ft map msg pl unmtl url
09:19:26 <atriq> :(
09:20:02 <atriq> @help map
09:20:02 <lambdabot> map. #haskell user map
09:20:08 <atriq> @map
09:20:08 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
09:20:21 <atriq> 404?
09:20:37 <monochrom> oh, that's an old url
09:21:00 <atriq> @where map
09:21:00 <lambdabot> http://www.haskell.org/haskellwiki/HaskellUserLocations
09:29:01 <donri> aristid, sent from their ipad
09:29:43 <edwardk> one of these days i should get around to removing that signature ;)
09:29:44 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
09:30:10 <edwardk> donri: re dual of 'to' look at 'sets'
09:30:28 <donri> edwardk: but sets has the wrong type i think?
09:30:43 <donri> i want "lens" without the first argument
09:30:43 <edwardk> donri: thats because what you asked for isn't enough to give you a setter
09:31:03 <edwardk> that isn't something i can build because i can't compose those
09:31:07 <edwardk> how do you put two of those together?
09:31:17 <aristid> donri: uh, i'm not actually using my ipad rightnow
09:31:17 <donri> duno :)
09:31:28 <satish> hi
09:31:44 <donri> aristid: aristid-ipad?
09:31:45 <edwardk> donri: to set into the composition of two things requires you to do a limited form of reading from the first lens
09:31:55 <edwardk> donri: 'sets' and Setter capture that precisely
09:32:08 <donri> edwardk: i had a feeling, thus why i called the question stupid :) just thought i should confirm
09:32:13 <edwardk> by giving you basically the power of the Functor laws
09:32:15 <edwardk> np
09:32:24 <edwardk> i racked my brain on this one for a couple days
09:32:33 <aristid> donri: it just seems to sometimes like to wake up, and because irc was the last thing i had in the foreground, it just wakes up
09:32:52 <aristid> donri: so yes, aristid-ipad is me
09:33:28 <donri> aristid: aha :) -- sent from my custom built PC using xchat on fedora
09:34:12 <aristid> donri: i'm writing this from my ubuntu-running thinkpad:)
09:34:48 <donri> (it amazes me how people aren't more upset about apple sending spam to your contacts from your email accounts)
09:35:28 <donri> heh, didn't ubuntu patch evolution to set "sent from ubuntu" as default signature?
09:35:36 <donri> but i think they removed it before release
09:35:42 <aristid> donri: maybe continue in #haskell-blah?
09:35:47 <donri> true, sorry
09:36:26 <mysticc> @hoogle Word32 -> Int
09:36:27 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
09:36:27 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
09:36:27 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
09:36:56 <aristid> donri: i don't use evolution, and i don't use apple's email client on the iPad. so no spammy signatures there. i also don't think i use any apps that spam my contacts with unwanted messages.
09:37:43 <donri> mysticc: fromIntegral?
09:38:25 * hackagebot regex-compat-tdfa 0.95.1.1 - Unicode Support version of Text.Regex, using regex-tdfa  http://hackage.haskell.org/package/regex-compat-tdfa-0.95.1.1 (KidoTakahiro)
09:39:37 <xz> does the let syntax in do notation accept arbitrary patterns, or only single variables?
09:40:02 <WranglingWombat> try it :)
09:40:14 <xz> WranglingWombat: I have a syntax error, but it's not obvious where it's coming from
09:40:22 <WranglingWombat> it should work
09:40:44 <donri> heh, fromIntegral is the 119th result in hoogle for that type
09:41:04 <atriq> :t fromIntegral
09:41:06 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:41:24 <atriq> @hoogle (Integral a, Num b) => a -> b
09:41:25 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
09:41:25 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
09:41:25 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
09:41:39 <atriq> I make it the first
09:41:53 <xz> hmm, can I put the rhs of the let expression on the line below?
09:42:08 <donri> xz: any pattern, but beware that it will easily be refutable
09:42:17 <rwbarton> if you indent it then yes
09:42:29 <rwbarton> needs to be more indented than the pattern actually
09:42:36 <rwbarton> let (x,y) =
09:42:37 <xz> I have let (x,y) =\n  case something of\n      ...
09:42:41 <rwbarton>      ^start here
09:42:43 <xz> maybe I don't have enough indent
09:42:55 <donri> xz: 'case' needs to be indented more than '(x,y)'
09:43:04 <dmwit> case must start after the ( in (x,y), and the patterns in case must start after the c in case
09:43:26 <donri> reason being that you can have multiple bindings without repeating 'let'
09:43:27 <dmwit> ...actually, I wonder if that's quite precise.
09:43:28 <rwbarton> if it was equally indented, it would be the start of a new binding in the same let group
09:43:28 * dmwit tests
09:43:36 <xz> dmwit: thanks, that fixed it
09:43:42 <xz> rwbarton: thanks
09:44:52 <dmwit> seems imprecise
09:45:45 <dmwit> The patterns in the case merely need to be indented more than the patterns in the let (they can even be indented exactly the same as the 'c' in case).
09:45:53 <dmwit> (or less than the 'c' in case)
09:46:35 <donri> incidentally, if you use vim2hs a simple =ip would have fixed that let binding
09:49:55 <donri> ... although it would've indented it correctly as you typed it in the first place
09:50:17 <monochrom> > do { x <- [Just 0]; let { Just y = x }; return y }
09:50:18 <lambdabot>   [0]
09:50:28 <monochrom> works
10:03:23 <Hadaka> I have [(a, b)] - I want [(a, [b])] with the entries grouped in to a list by equivalence of member a - something like groupBy but not quite
10:04:12 <xz> is there a shorter way to write do { x <- m ; let y = f x } ?
10:05:18 <xz> i guess something like y <- lift f m
10:05:31 <donri> y <- fmap f m
10:05:31 <rwbarton> y <- fmap f m -- or y <- f <$> m, etc.
10:05:42 <xz> cheers
10:06:18 <rwbarton> Hadaka, you can use M.assocs . M.fromListWith (++) after converting [(a, b)] to [(a, [b])] by wrapping each b in a one-element list
10:06:36 <rwbarton> assuming you have an Ord instance for a
10:07:54 <copumpkin> fmap (fmap pure)
10:08:10 <Hadaka> rwbarton: hmmh, right
10:08:11 <rwbarton> or fmap fmap fmap pure
10:09:07 <lispy> :t fmap fmap fmap pure
10:09:08 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Applicative f2) => f (f1 a) -> f (f1 (f2 a))
10:11:21 <fryguybob> > map (fst . head &&& map snd) . groupBy ((==) `on` fst) $ [('a',1),('a',2),('b',3),('b',4)]
10:11:23 <lambdabot>   [('a',[1,2]),('b',[3,4])]
10:11:40 <Hadaka> fryguybob: thanks! :D
10:12:26 <rwbarton> that assumes the input is already sorted on the first field
10:12:30 <rwbarton> but yeah
10:14:45 <rwbarton> it is more efficient if you do know that
10:15:15 <Hadaka> well, this is a short list, I can sort it first, too
10:15:35 <Hadaka> but dear god I don't grok arrows
10:16:12 <Hadaka> the groupBy is obvious, as is the outer map
10:17:05 <Hadaka> fst . head also is clear and map snd too, but I don't get how &&& manages to make pairs out of them or handle them in any sane way
10:17:06 <fryguybob> :t let f = (&&&); g = ((fst . head) `f` map snd) in f
10:17:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:17:07 <rwbarton> you don't really need to understand arrows, most uses of functions like (&&&) are just for the (->) arrow
10:17:19 <t7> anyone know of an algorythm that allways places points on a circle as far away from the last ones as possible ? like 12 o clock -> 6 o clock -> 3 o clock -> 9 o clock -> 1.30 ....
10:17:44 <copumpkin> just add half mod total
10:18:12 <copumpkin> :t (`mod` 12) . (+ 6)
10:18:13 <lambdabot> forall a. (Integral a) => a -> a
10:18:30 <Jello_Raptor> t7: floor(ax^(-b) mod t)
10:18:44 <copumpkin> > (`mod` 12) . (+ 6) . [12,6,3,1.50]
10:18:44 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:18:45 <lambdabot>    `GHC.Real.Integral a'
10:18:45 <lambdabot>   ...
10:18:47 <copumpkin> pfft
10:18:57 <t7> map?
10:18:57 <fryguybob> Hadaka: I failed to monomorphize that, but (&&&) :: (b -> c) -> (b -> c') -> b -> (c, c') in that instance.
10:19:00 <Jello_Raptor> choose a -b, x , and t how you wish
10:19:05 <copumpkin> (.) should be map
10:19:28 <Hadaka> fryguybob: thank god you failed 'cos I didn't understand what bit what the output was :-)
10:19:42 <Hadaka> ah!
10:20:07 <benmachine> copumpkin: that wouldn't help, surely
10:20:21 <copumpkin> > (+6) . [1,2,3,4]
10:20:23 <benmachine> copumpkin: you're trying to mod 1.5, is your problem (maybe a full stop where you wanted a comma?)
10:20:23 <lambdabot>   [7,8,9,10]
10:20:24 <fryguybob> If you have monomorphism on, then in GHCI that will give you the specific type.  Someone else might have a nice trick to do that in general.
10:20:26 <Hadaka> toLower &&& toUpper is the same as \x -> (toLower x, toUpper x)
10:20:28 <t7> > floor(1 * 2 ^(-3) `mod` 12)
10:20:28 <Hadaka> more or less
10:20:29 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:20:29 <lambdabot>    `GHC.Real.RealFrac t'
10:20:29 <lambdabot>   ...
10:20:55 <copumpkin> benmachine: oh, I forgot that mod doesn't like nonintegral types, even though it should
10:21:06 <fryguybob> Hadaka: Right.
10:21:14 <benmachine> copumpkin: who are you to tell mod who it should like :P
10:21:27 <copumpkin> :(
10:21:30 <rwbarton> mod'
10:21:31 <Hadaka> fryguybob: now it makes perfect sense! thanks!
10:21:32 <fryguybob> :t let (f &&& g) x = (f x, g x) in (&&&)
10:21:34 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
10:21:38 <copumpkin> :t mod'
10:21:38 <benmachine> :t mod'
10:21:39 <lambdabot> forall a. (Real a) => a -> a -> a
10:21:39 <lambdabot> forall a. (Real a) => a -> a -> a
10:21:41 <copumpkin> aha
10:21:43 <copumpkin> much bettar
10:25:43 <copumpkin> > decodeFloat (5 :: CReal)
10:25:44 <lambdabot>   *Exception: CReal.decodeFloat
10:30:59 <Jello_Raptor> hmm, how would you create a process server in haskell? take a list of time intensive processes, run as as many as the processor allows at once, and respond to asyncronous requests as to the queue location and percent completeion of each process.
10:31:05 <Jello_Raptor> i'm just not sure how to structure it.
10:33:11 <lpvb> can I have multiple versions of the same library?
10:33:27 <lpvb> I updated to network-2.3.1 and I need network-2.3.0
10:33:57 <rwbarton> You can have multiple versions installed, yes
10:34:15 <rwbarton> You can't link a single program (or library) against multiple versions of the same package
10:34:19 <int-e> in theory, yes; in practice, it tends to cause trouble. why do you need 2.3.0?
10:34:31 <Heffalump> is there any prospect of that being fixed?
10:34:32 <lpvb> I don't know it says it expects 2.3.0
10:34:41 <lpvb> I think it's the other library that I depend on
10:34:44 <lpvb> that needs 2.3.0
10:35:01 <lpvb> Couldn't match expected type `network-2.3.0.14:Network.URI.URI'
10:35:04 <lpvb>                 with actual type `Network.URI.URI'
10:35:34 <rwbarton> you are trying to use two versions of network at the same time
10:35:35 <int-e> oh. you have broken packages, I guess, run ghc-pkg check
10:35:56 <int-e> or as rwbarton says, you actually have two versions
10:36:11 <lpvb> lots of doesn't exist or isn't a file warnings
10:36:14 <lpvb> int-e
10:36:29 <lpvb> for haddock-html and haddock-interfaces
10:37:43 <dncr> ok i have a bunch of datatypes for language AST.  since there are a lot of both, i had statement datatypes in one file and expression datatypes in another.
10:38:27 <int-e> lpvb: I think those warnings are harmless. but you should probably rebuild everything that depends on network, or remove the newer version again :-/ the symptom you have indicates that you're trying to use two versions of the network library in the same program (otherwise, ghc usually does not qualify type names with package names)
10:38:39 <dncr> but now i need to add anonymous functions which is the first "expression" type that will reference "statements".  so that's a cyclic dependency for my haskell modules.
10:38:51 <dncr> should i just put everything in one file?
10:38:54 <rwbarton> lpvb: my guess is you are using some package that depended on and thus installed 2.3.0 since it was the latest version of network at the time
10:38:56 <lpvb> int-e: how do I remove the new network and download the old one?
10:39:01 <rwbarton> and now you have a new version of network
10:39:03 <rwbarton> as well
10:39:09 <int-e> lpvb: the old one still seems to be installed
10:39:10 <rwbarton> and ghci is loading that one
10:39:23 <rwbarton> but the other package is linked against network-2.3.0
10:39:40 <int-e> lpvb: so it's just about unregistering the new one, hopefully.
10:39:46 <lpvb> so, packages will break everytime I install newer versions of libs?
10:39:56 <int-e> (if you don't actually *need* the new one, of course)
10:40:22 <rwbarton> you could also try reinstalling whatever the other package is
10:40:22 <lpvb> how do I remove the new one?
10:40:30 <lpvb> I don't see anyhting in cabal --help
10:40:45 <rwbarton> ghc-pkg unregister -- but likely something else is depending on it
10:40:47 <Heffalump> ghc-pkg unregister network-2.3.1
10:40:49 <int-e> ghc-pkg unregister network-2.3.1 (is there another subversion?)
10:40:56 <rwbarton> unless you installed it yourself but that doesn't seem likely
10:41:06 <int-e> (ghc-pkg will warn which packages break if any)
10:41:50 <int-e> Heffalump: "I updated to network-2.3.1 and I need network-2.3.0"
10:42:04 <int-e> so maybe we're lucky
10:42:12 <lpvb> rwbarton, Hadaka, int-e: that solved my problem
10:42:13 <lpvb> thanks
10:42:29 <rwbarton> now you might have a new problem :)
10:55:57 <timthelion> Idiomatically idiotic haskell: nub $ map sort $ permutations list -- A list of the ordered permutations of a list.  It works...
10:56:48 <rwbarton> wut
10:57:06 <timthelion> rwbarton: Sometimes an obvious solution is quite inefficient.
10:57:07 <rwbarton> > nub $ map sort $ permutations [1,2,3]
10:57:08 <lambdabot>   [[1,2,3]]
10:57:32 <rwbarton> is this what you wanted?
10:57:36 <timthelion> yes :/
10:57:42 <rwbarton> seems a lot less obvious than
10:57:48 <rwbarton> > (:[]) $ sort $ [1,2,3]
10:57:49 <lambdabot>   [[1,2,3]]
10:57:52 <timthelion> I know :(
10:58:06 <timthelion> I'm an idiot
10:58:45 <timthelion> > {-and in the end I *really* wanted-} inits $ sort $ [3,2,1]
10:58:46 <lambdabot>   [[],[1],[1,2],[1,2,3]]
10:58:57 <timthelion> well the tail of that.
10:59:21 <timthelion> Why does inits return an empty list first?
10:59:25 <timthelion> inits []
10:59:29 <timthelion> > inits []
10:59:30 <lambdabot>   [[]]
10:59:53 * timthelion doesn't see how that's a good design decision.
11:02:13 <ParahSai1in> > chr 256
11:02:14 <lambdabot>   '\256'
11:02:27 <benmachine> timthelion: depends what you think inits means, if it means "list of initial segments" I don't see why [] is not an initial segment of every list
11:02:54 <timthelion> benmachine: well it's not. it's only ever a terminal segment!
11:03:06 <timthelion> benmachine: 1:2:3:[] -- where is the []? At the end.
11:03:29 <rwbarton> where is the [1]
11:05:15 <donri> edwardk: where did Data.Map.Lens go?
11:05:24 <edwardk> what would be in it? =)
11:05:49 <edwardk> at is in the At class now, and there are traverseMin and traverseMax in classes in IndexedTraversal
11:05:50 <timthelion> > {-rwbarton: that's irrelivant.  It should be the same as-} let list = [1,2,3] in map (\n->take n list) [1..length list]
11:05:51 <lambdabot>   [[1],[1,2],[1,2,3]]
11:06:02 <rwbarton> why not [0..length list]
11:06:09 <rwbarton> start at 0, more natural
11:06:12 <timthelion> rwbarton: that's an error
11:06:16 <edwardk> so once i got done with that, and adding TraversableWithIndex there was nothing left in the module
11:06:17 <benmachine> rwbarton: I see what you did there
11:06:22 * timthelion ends this conversation.
11:06:22 <rwbarton> what error
11:06:44 <donri> edwardk: ah, thanks
11:07:01 <timthelion> > {-rwbarton: well I guess it's not actually an error but-} take 5 [1,2,3]
11:07:02 <lambdabot>   [1,2,3]
11:07:27 <timthelion> rwbarton: sorry, just being an idiot
11:07:47 <timthelion> rwbarton: Really, I just mixed up index out of bounds stuff with what I was thinking.
11:08:12 <timthelion> rwbarton: but no, there is not actually any logical reason for such behavior.
11:08:51 <benmachine> timthelion: like I said, [] is an initial segment of every list
11:08:56 <benmachine> there's no logical reason to leave it out
11:09:55 <timthelion> benmachine: except that the users of the function inits usually don't want it. and it's easier to add back in than to remove.
11:10:59 <benmachine> timthelion: have you asked any users other than yourself?
11:12:14 <timthelion> benmachine: do I have to?  It seems quite obvious.  I think you are just defending a standard because you feel like it.  I don't think that you actually care.
11:13:00 <benmachine> timthelion: you have to if you want to say "users" and be honest. I am not particularly defending the standard, I am just trying to show you why your arguments sound unconvincing to me
11:13:05 <rwbarton> it hardly sounds obvious to me
11:13:30 <rwbarton> anyways it is just as easy to remove (tail) as it is to add ([]:)
11:14:29 <timthelion> rwbarton: But tail is an incomplete function. And every time one uses an incomplete function one must think, whether they are passing it arguments within their domain.
11:14:44 <rwbarton> ugh not this again
11:15:12 <timthelion> and as to it being obvious.  The thing I'm doing, mapping against the inits, is not a "specific case" it applies to the class of useses of the inits function which is likely the most common usage.
11:17:16 <benmachine> timthelion: use drop 1, then
11:18:50 <timthelion> benmachine: while drop 1 is complete, it has unexpected behavior associated with it as well.  drop 100000220009999 [] == []
11:19:03 <benmachine> timthelion: I expect that behaviour :P
11:19:06 <mysticc> @hoogle Gen a -> a
11:19:06 <lambdabot> Prelude id :: a -> a
11:19:07 <lambdabot> Data.Function id :: a -> a
11:19:07 <lambdabot> GHC.Exts breakpoint :: a -> a
11:19:30 <timthelion> benmachine: you tortured soul
11:19:30 <benmachine> timthelion: http://code.google.com/codesearch#search/&q=inits%20lang:^haskell$&sq=&type=cs I had a look at this
11:19:31 <Cale> timthelion: How is that unexpected?
11:19:54 <benmachine> timthelion: it seems to support your argument inasmuch as many of the uses of inits are also used with tail
11:20:02 <timthelion> Cale: well it's not in the category of obvious and logical behaviors.  No one would be "sure" of that untill they had typed it into ghci.
11:20:09 <benmachine> timthelion: however what it mostly shows is that way more people define inits than use it :P
11:20:25 <Cale> timthelion: dropping any number of elements from an empty list should result in an empty list
11:20:27 <benmachine> timthelion: so maybe it's not even a very useful function in the first place
11:20:43 <benmachine> timthelion: what is obvious or logical is subjective
11:21:13 <Cale> the less expected thing would be that  drop 4294967297 [1..10] = [2,3,4,5,6,7,8,9,10]
11:21:35 <Cale> (depending on machine architecture)
11:22:55 <Cale> and drop (2^64) is practically the identity function, unless you have a really weird implementation :)
11:23:35 <rwbarton> how about a flag "-fint-is-integer"
11:24:15 <Heffalump> > map product (inits [1..5])
11:24:16 <lambdabot>   [1,1,2,6,24,120]
11:24:31 <dncr> normalizeChord cc c = init . minimum $ zipWith (++) (tails c') (inits c')
11:24:40 <dncr> seems to be my only use of it!
11:25:05 <benmachine> @check \xs -> head (tails xs) == xs
11:25:06 <lambdabot>   "OK, passed 500 tests."
11:25:11 <benmachine> @check \xs -> head (tails xs) == (xs :: [Integer])
11:25:13 <lambdabot>   "OK, passed 500 tests."
11:25:18 <dncr> https://github.com/dancor/uke-chords/blob/master/src/AllChords.hs
11:26:12 <dmwit> dncr: Hm, could you not just normalizeChord notes = sort notes? ;-)
11:26:29 <dncr> i probably need better variable names
11:27:14 <dncr> but it normalizes to a standard form that collapses together inversions and transpositions
11:28:34 <benmachine> well, I can see what zipWith (++) (tails c') (inits c') does at least
11:28:44 <benmachine> it produces all the cycles of the list
11:29:03 <rwbarton> timthelion, what should tails [1,2,3] obviously produce
11:29:04 <benmachine> and uses the fact that the first elements of inits is []
11:30:07 <dncr> is it kewler than (take (length l) $ cycle l)
11:30:55 <rwbarton> I think you left out something there
11:31:03 <rwbarton> take (length l) $ cycle l is l
11:31:19 <dncr> :t cycle
11:31:20 <lambdabot> forall a. [a] -> [a]
11:31:39 <dncr> i did..
11:31:53 <timthelion> rwbarton: well the argument for tails not having the empty list is less strong.  But there is little argument FOR it having one.
11:32:16 <otters> who says there aren't any good IDEs for haskell
11:32:23 <otters> it's only taken me 22 hours to install leksah so far
11:32:27 <benmachine> timthelion: I think the argument for it is that it gives the meaning of the function a simpler description
11:32:29 <dncr> lol
11:32:40 <rwbarton> benmachine, right
11:32:41 <benmachine> timthelion: inits xs is all the ys such that xs = ys ++ zs for some zs
11:32:46 <dncr> will haskell compilation always be way too slow?
11:32:59 <benmachine> tails likewise, except the ++ is the other way around
11:33:17 <timthelion> benmachine: with the ++ part, no?
11:33:38 <benmachine> timthelion: I don't understand that comment
11:33:44 <drewr> I'm trying to understand the relationship between cabal and debian packaging
11:33:47 <dncr> ok well is there a cooler way to do (zipWith (++) (tails l) (inits l))?
11:33:52 <johnw> drewr!
11:33:59 <drewr> it's clearly installed things to some cabal-aware location, but nothing works
11:34:04 <rwbarton> dncr, I think it's a pretty good way
11:34:08 <dncr> ok
11:34:13 <drewr> `ghc-pkg check` spews out errors
11:34:21 <drewr> johnw: hi!
11:34:27 <johnw> drewr: I find it very hard to keep ghc-pkg check quiet
11:34:38 <timthelion> dncr: well that's a relatively good argument I guess...
11:34:53 <dmwit> ?where sicp
11:34:53 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | "Structure and Interpretation of Computer Programs"
11:34:56 <drewr> xmonad complains about dependencies not being installed that at least seem to be there in part (just interface files)
11:34:57 <dncr> timthelion: it is my only use that i could find
11:35:03 <dmwit> um
11:35:21 <dmwit> http://www.vex.net/~trebla/haskell/sicp.xhtml
11:35:27 <benmachine> dncr: you could do it with cycle, something like, let l = length xs in take l (map take l) (tails $ cycle xs)
11:35:28 <dmwit> johnw, drewr: ^^
11:35:57 <dmwit> ?where+ sicp http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | "Structure and Interpretation of Computer Programs" | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
11:35:57 <lambdabot> Done.
11:36:00 <merijn> johnw: I found a bug!
11:36:06 <dncr> timthelion: i think i have gotten caught on the [] before.  but it's like the least of the ways i'm terrible at haskell
11:36:08 <dmwit> Can a \bot op ?flush that finally?
11:36:08 <drewr> dmwit: thanks; is it common for debian's global setup to be broken?
11:36:14 <dmwit> I think it's been added like eight times by now.
11:36:17 <johnw> merijn: :)
11:36:22 <johnw> dmwit: hi
11:36:24 <dmwit> drewr: Only if you don't know what you're doing.
11:36:26 <dmwit> johnw: hi
11:36:30 <rwbarton> another use is
11:36:36 <drewr> dmwit: haha; I haven't messed with it!
11:36:42 <rwbarton> > [ (x, y) | (x:xs) <- tails "123", y <- xs ]
11:36:43 <lambdabot>   [('1','2'),('1','3'),('2','3')]
11:36:46 <drewr> this is just a few `aptitude install`s later
11:36:47 <merijn> johnw: c2hsc parses "void (*foo)(int, intptr_t *)" as "FunPtr (CInt -> Ptr IntPtr)"
11:36:53 <rwbarton> that one doesn't care about whether [] is in the list or not though
11:36:55 <dmwit> Then that's very unusual, yes.
11:37:08 <merijn> johnw: The correct type would be "FunPtr (CInt -> Ptr IntPtr -> IO ())"
11:37:15 <drewr> wondering if wheezy's support hasn't gotten enough eyeballs yet
11:37:23 <dmwit> If you only run debian's package management stuff, and never cabal, you should not need to know anything, and should complain to the packager if that's not true.
11:37:28 <johnw> merijn: oops!
11:37:33 <johnw> I hate that FunPtr handling code
11:37:39 <merijn> johnw: :p
11:37:44 <johnw> ok, i'll add it to the list
11:38:09 <merijn> I haven't looked into fixing it, though. If you can say approximately where you deal with FunPtr's I might have a look later on
11:38:18 <drewr> dmwit: I was trying to go that route thinking it would be most stable but afraid I'll have to go the other
11:38:21 <Clint> drewr: what seems to be the problem?
11:38:32 <drewr> never had this kind of trouble with haskell platform+cabal on OS X
11:39:09 <drewr> Clint: this kind of thing: http://p.draines.com/1347559005590a52a9e0f.txt
11:39:28 <drewr> though lots of packages just don't seem to work
11:39:50 <johnw> merijn: that job is done by applyDeclrs, line 494 in Main.hs
11:39:59 <typoclass> rwbarton: if i'm reading that correctly, (x:xs) discards the [] that tails gave back, so that code isn't a use of the empty list (more like an un-use)
11:40:19 <rwbarton> yeah, as I said < rwbarton> that one doesn't care about whether [] is in the list or not though
11:40:20 <Clint> drewr: works fine for me; what does ghc-pkg list say?
11:40:25 <rwbarton> I was just listing a use of tails
11:40:36 <johnw> also, function pointers do not return IO ()
11:40:47 <johnw> or if they do, I need to add that
11:40:58 <johnw> see applyDeclrs, and appendFunc
11:41:01 <typoclass> rwbarton: oh, i haven't caught that message, sorry
11:41:10 <johnw> the former handles FunPtr, the latter handles top-level function types
11:41:14 <Clint> drewr: and which architecture are you on?
11:41:36 <drewr> Clint: x86_64-linux-7.4.1
11:42:28 <johnw> (they both call the same underlying code to get the "argument list" and the "return type"
11:42:30 <drewr> Clint: it lists lots of things; I seem to be getting somewhere by force-reinstalling things to ~/.cabal, but that clearly shouldn't be necessary
11:42:44 <Clint> it's not
11:42:47 <Clint> i have nothing in ~/.cabal
11:43:11 <Clint> you've got libghc-xmonad-contrib-dev 0.10-3+b3?
11:43:52 <uniquenick> is there a standard function to apply a function to part of a tuple, and return the whole tuple?  Like if I have (1,1), and I want to add 1 to the first element and get back (2,1)?
11:44:05 <merijn> johnw: The docs say "the return type is a marhallable foreign type OR has the form IO t where t is a marshallable foreign type or ()"
11:44:11 <dmwit> > first (+1) (1,1)
11:44:12 <lambdabot>   (2,1)
11:44:16 <drewr> Clint: yep, and -doc and -prof
11:44:19 <gertc> is TypeFamilies deprecated?
11:44:27 <merijn> johnw: The problem is that the return type of FunPtr's depends on their purities
11:44:30 <merijn> gertc: No
11:44:44 <typoclass> uniquenick: yes the 'first' function from Control.Arrow
11:44:50 <johnw> so how do you know when to use IO and when not to?
11:44:54 <merijn> johnw: So you can't really automatically determine them (unless you default to IO t for unsanfe)
11:44:56 <Clint> drewr: if you nuke ~/.ghc and ~/.cabal and it still doesn't work, something is clearly wrong
11:45:15 <gertc> is monads-tf deprecated?
11:45:23 <Clint> i hope so
11:45:45 <merijn> johnw: Well, void should be "IO ()" always, because void functions obviously have side effects. For other functions it's not really to know unless you know what the function does and whether its pure
11:45:52 <benmachine> uniquenick: Control.Arrow.first
11:45:57 <benmachine> oh
11:46:00 <benmachine> someone else got there first
11:46:04 <benmachine> damn my skimreading
11:46:24 <drewr> Clint: oh!  I had forgotten about ~/.ghc
11:46:25 <merijn> johnw: IO t is safer though, as that works for both pure/non-pure functions. Where as making a non-pure function non-IO is unsafe
11:46:27 <typoclass> "someone else got there ... (puts on sunglasses) ... Control.Arrow.first"
11:46:30 <gertc> has TypeFamilies anything to do with monads-tf or are they non related?
11:47:00 <merijn> gertc: TypeFamilies is a GHC extension, the tf part of monads-tf implies that it uses TypeFamilies, but otherwise they're unrelated
11:47:02 <drewr> Clint: couldn't figure out why pkg check was complaining about ~/.cabal :-)
11:47:08 <Clint> aha
11:47:14 <drewr> looks like clearing that out fixed it
11:47:48 <Clint> whew
11:47:58 <gertc> so no need to skip packges that use TypeFamilies?
11:48:16 <gertc> like acid state for example
11:48:18 <rwbarton> no
11:48:22 <rwbarton> where did you get this idea?
11:48:31 * hackagebot zlib-enum 0.2.3 - Enumerator interface for zlib compression  http://hackage.haskell.org/package/zlib-enum-0.2.3 (MalteSommerkorn)
11:48:34 <gertc> the internet :)
11:48:36 <merijn> gertc: They're fairly new, so I don't know what gave you the idea that they're deprecated
11:48:39 <drewr> Clint: thanks :-)
11:48:44 <Clint> np
11:49:39 <gertc> http://stackoverflow.com/questions/12237831/why-use-multiparamtypeclasses-in-a-monadstate comment on the bottom
11:49:49 <gertc> about monad-tf
11:49:56 <gertc> and fd and mtl
11:51:20 <rwbarton> if monads-tf is deprecated it isn't because TypeFamilies is deprecated
11:51:20 <merijn> gertc: Ah, no. That was just for one package
11:51:40 <rwbarton> it's because several packages were using the same module and type names and that had to change one way or another
11:51:57 <merijn> gertc: The reason not to use typefamilies for a package like monad-tf is that TypeFamilies are a GHC only extension (and only fairly new GHC versions)
11:52:29 <merijn> gertc: The monads-fd implementation is more portable (think of compilers like Hugs, UHC, etc. though I'm not sure it works with those)
11:53:04 <merijn> gertc: But many Hackage packages are GHC only anyway, so using TypeFamilies is not specifically bad if you don't mind only working on GHC
11:54:13 <gertc> Are other compilers planning on implemting TypeFamelies?
11:54:27 <gertc> or do they have a reason not to ?
11:54:51 * timthelion still doesn't undestand what's wrong with GHC.
11:55:15 <rwbarton> most people don't really care about compilers other than GHC
11:55:17 <gertc> nothing :) i just like one big happy famelie that puls on the same side :)
11:55:44 <rwbarton> or at least, don't actually use compilers other than GHC
11:55:52 <merijn> gertc: GHC is really the only haskell compiler that really matters
11:55:57 <monochrom> this week's official compiler is GHC
11:58:43 <badabing> I want to on a as low level as possible connect 2 people over the internets so they can message each other. How would I do that? I would connect people via TCP/IP I assume?
11:59:31 <lpsmith> badabing, if you want "as low level as possible",  why are you using TCP?
11:59:49 <geekosaur> type families are not deprecated.  the early attempt to reimplement the MTL via type families is deprecated, because as yet type families have some shortcomings compared to functional dependencies, and there's no consensus about how to deal.
12:00:01 <badabing> lpsmith: ok what is the lowest?
12:00:12 <lpsmith> badabing, plain IP
12:00:17 <badabing> ok
12:01:08 <badabing> would it be hard?
12:01:22 <geekosaur> oyyyy, this discussion is going nowhere fast...
12:01:49 <lpsmith> but,  using IP means you have to deal with dropped/out of order/fragmented packets.
12:01:55 <geekosaur> erm
12:02:03 <gertc> but in the future it will be typefamelie style or functional dependancies rigth?
12:02:06 <monochrom> the lowest level is to set up antennas on both sides
12:02:20 <badabing> well staing in softwareland
12:02:20 <geekosaur> you're actually talking about UDP.  IP is a bit more complex, and requires special privileges
12:02:20 <monochrom> or use pigeons
12:02:20 <lpsmith> badabing, it might be interesting to implement something over SCTP
12:02:31 <lpsmith> I've been meaning to play with SCTP at some point
12:03:11 <geekosaur> the lowest level (that you an accomplish in general software) is some form of bit banging to a hardwaredevice, which means reimplementing some largeish fraction of kernel device drivers.
12:03:24 <geekosaur> how deep were you planning to dive down tht "lowest level" rabbit hole?
12:03:52 <badabing> well i just want to have a program that people could download and connect to other people via
12:03:53 <monochrom> never trust "the lowest level" or "explain like I'm a 5-year-old"
12:04:20 <badabing> so it is not superimportant thT UIS THE LOWEST LEVEL. just getting experience with datacom and protocols
12:04:31 <lpsmith> badabing, then use TCP
12:04:34 <badabing> maybe i should do TCP/IP not just plain IP
12:04:49 <ParahSai1in> i think this is not the channel to be asking your question to
12:04:50 <timthelion> badabing: you mean, conects people, like in terms of super glue?
12:05:10 <timthelion> badabing: wires going into their brain? Direct hypothalamus to hypothalamus connection?
12:05:34 <monochrom> learn sockets, udp, tcp/ip
12:05:55 <badabing> monochrom: y
12:05:58 <badabing> yes
12:06:08 <monochrom> take a course on computer networks. read Tananbaum's book
12:07:02 <lpsmith> badabing, but please for the sake of all that is holy,  use a proper framing protocol in your TCP/IP protocol.
12:07:20 * lpsmith has spent too much time working with TCP/IP protocols that don't
12:08:25 <lpsmith> I'd suggest something semi-standard,  such as prefixing each message with a 4-byte binary integer that says how long the message is.
12:08:31 * hackagebot fb 0.12.3 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12.3 (FelipeLessa)
12:09:28 <merijn> lpsmith: \n\r line termination :p
12:09:50 <lpsmith> That way you don't have to deal with quoting issues inside your message,  and it's standard enough that e.g. Erlang supports it out of box.
12:11:38 <lpsmith> merijn, one protocol I've worked with recently used a mixture of STX/ETX serial-style framing,  terminating XML messages with \r,  and nothing at all
12:12:33 <lpsmith> I eventually gave up on trying to implement it "correctly",  and just did what every other program that implements this protocol does:   just take whatever the sockets API gives you back at one time as a single message
12:12:50 <lpsmith> Which is a horrible abuse of TCP, but...
12:13:46 <lpsmith> (The consequences of this is that I can't send messages too quickly,  so I put a sleep statement in my program every time I send a message.
12:14:29 <lpsmith> So \n\r would actually be a major step up.
12:16:29 <luite> lpsmith: sounds like in 6 months you might get a typoclass moment
12:16:36 <timthelion> lpsmith: I recently tried to implement a serial protocol. The arduino has a serial buffer, that silently overflows causing dropped packets.  On top of this, the USB controller for the arduino clone I use also has such a buffer.  Which means that I ended up in the situation of even with ACKs after ever byte I still had lost bytes...
12:16:56 <timthelion> luite: a typoclass moment?
12:17:13 <luite> quote from haskell-blah, i hope it's ok :)
12:17:16 <luite> 18:28  * typoclass opens a source code file last touched 6 months ago
12:17:16 <luite> 18:28 < typoclass> *WHY*? why, world? why is it like that?
12:17:17 <luite> 18:29 < typoclass> it sends a "give me your status" command to the other guy, then waits 3.3 seconds, and sends another one?
12:20:40 <pdxleif> @hoogle b -> (a -> m1 b) -> m2 a -> m1 b
12:20:41 <lambdabot> No results found
12:21:25 <lpsmith> luite, yeah I only put the IO thread to sleep for 10 milliseconds.   Because I *was* sending messages fast enough that the other side would interpret two messages as a single message.
12:33:32 * hackagebot Workflow 0.7.0.1 - Monadic transformer for persistence in threads. and workflow patterns  http://hackage.haskell.org/package/Workflow-0.7.0.1 (AlbertoCorona)
12:42:11 <MagneticDuck_> what's the advantage of using gtk2hs or wxWidgets over using a more high level approach like grapefruit?
12:42:50 <shachaf> That it works*, I assume.
12:43:12 <MagneticDuck_> I came to haskell to get things done in a high level, unlike other languages like C..
12:43:33 <MagneticDuck_> are high level GUIs easier to use generally?
12:43:36 <typoclass> *not available in alaska and hawaii. allow 7-63 days for shipping. may not actually work.
12:44:05 <MagneticDuck_> x)
12:44:35 <MagneticDuck_> *is not actually a high level GUI binding, but a wild cougar
12:44:36 <geekosaur> MagneticDuck_, grapefruit etc. are kinda research projects as yet.  FRP's still sorting itself out
12:44:38 <jethr0> MagneticDuck_: one sec
12:45:00 <MagneticDuck_> geekosaur: what's the most practical at the moment?
12:45:39 <MagneticDuck_> FG looks good too...
12:45:47 <jethr0> i chose gtk2hs because it was packaged better. both gtk2hs and xwwidgets are multiplatform and very imperative
12:45:53 <MagneticDuck_> I'm learning gtk2hs, looks cool
12:45:55 <geekosaur> that I couldn;t really tell you.
12:46:00 <MagneticDuck_> however, sometimes I feel like I'm programming in C
12:46:01 <MagneticDuck_> x)
12:46:11 <hiptobecubic> i think the problem with gtk2hs was the implicit global state
12:46:19 <hiptobecubic> that was the complaint i read, anyway
12:46:23 <jethr0> grapefruit, frp, etc. are imho not yet ready for production code. the learning curve is steep and some functionalities probably require to jump through hoops
12:46:24 <MagneticDuck_> I'm not using a functional language to use "do" notation all day
12:46:25 <hiptobecubic> although i don't see how to avoid it
12:46:29 <geekosaur> you kinda are.  problem is native idiom for such things is not well defined yet (tht's FRP research).
12:46:31 <MagneticDuck_> hm
12:46:40 <geekosaur> although the opengl packages seem to be going a different direction?
12:47:38 <Cale> Move as much of your program as possible into a pure model of what is supposed to happen (which is GUI-independent)
12:47:41 <jethr0> yes, i agree. the thin wrapper around the interface is annoying, but then again a fully functional style causes headaches as well
12:47:55 <jethr0> took me hours and hours to get a simple pong game working in frp...
12:48:07 <Cale> and then it doesn't matter so much that the binding to GTK exposes a lot of the underlying C-like library design.
12:48:44 <Cale> jethr0: which FRP library?
12:49:03 <jethr0> i found it actually quite nice to program opengl with actions. you could mix and match and use meta-operators before actually executing
12:49:05 <MagneticDuck_> Cale: yes, that's a good idea
12:49:19 <MagneticDuck_> I'll probably end up using gtk2hs and doing most of my work in the pure world
12:49:24 <jethr0> Cale: this was quite a while ago, i'd have to check
12:49:39 <jethr0> yampa
12:49:48 <Cale> ah, okay
12:50:05 <jethr0> i just dove into it and had serious trouble wrapping my head around describing all possible paths at once ;)
12:50:11 <Cale> ah
12:50:21 <jethr0> and integrating mouse movements over time to get the current position ;)
12:50:29 <Cale> So you spent most of your time on the arrow code rather than on figuring out the arguments to reactimate? :)
12:50:48 <jethr0> i think it's a beautiful model, but it's very painful to adapt to coming from a more sequential background
12:51:15 <MagneticDuck_> hm
12:51:28 <jethr0> yes, i guess. i just found it incredibly confusing to change the path through the program as a function of the inputs. very very weird
12:51:36 <MagneticDuck_> I think that the interface will guide the underlying structure too, so I want something nice and functional
12:52:46 <jethr0> i still can't imagine how people ever built games in hardware, and programming in frp felt a little bit like that. somehow describing all possible game states in a static structure...
12:53:08 <Cale> Well, you do that when you write an imperative program too
12:53:22 <MagneticDuck_> yeah
12:53:38 <Cale> It's just that you can forget to update some things in response to changes in other things then :)
12:54:00 <MagneticDuck_> and you might not even deal with everything at once
12:54:09 <MagneticDuck_> erm
12:54:10 <MagneticDuck_> same thing
12:54:14 <Cale> whereas FRP kinda forces you to work out all the ways that something can be changed and merge them together at one point
12:54:47 <jethr0> as i said it was a painful experience also because i was completely lacking any theoretical background. just jumped right in and managed a pong game ;)
12:55:12 <jethr0> and people complain monads are head-racking... *tststs*
12:55:38 <MagneticDuck_> heh
12:55:42 <MagneticDuck_> I got over that a while ago
12:56:40 <hpaste> janiczek pasted “memoization” at http://hpaste.org/74702
12:56:42 <janiczek> hi guys ... :) having problem with memoization from this article: http://www.nadineloveshenry.com/haskell/memofib.html#memoize ... more specifically, I'm trying to make it work with function with more arguments...
12:57:36 <jethr0> janiczek: what problem are you having
12:58:08 <janiczek> jethr0: the compiler yells at me because of typematching
12:58:20 <jethr0> what does it yell?
12:58:38 <jethr0> could you add a type signature for "add"?
12:58:39 <Cale> janiczek: So you just want  add x y = memoizeM addM (x,y) ?
12:58:41 <hpaste> janiczek annotated “memoization” with “memo errors” at http://hpaste.org/74702#a74703
12:59:14 <janiczek> Cale: something like that, probably
12:59:23 <Cale> try it
12:59:46 <jethr0> that would have been my next suggestion ;)
13:00:01 <Cale> oh
13:00:02 <Cale> also
13:00:11 <janiczek> throws different errors right now
13:00:11 <Cale> return $ f' ((x-1), (y+1))
13:00:15 <Cale> can't possibly be right
13:00:27 <janiczek> what should it be?
13:00:29 <Cale> also the type signature for addM is wrong
13:00:50 <otters> do I have to install the 64-bit version of haskell platform in order to install cabal packages that require system libraries that are 64-bit only?
13:01:07 <Cale> do v <- f' (x-1,y+1); return v
13:01:19 <hiptobecubic> otters, probably
13:01:32 <otters> fuck
13:01:39 <otters> so the last 24 hours have been for nothing
13:01:51 <hiptobecubic> well i'm just guessing
13:02:04 <otters> well, might as well give it a shot
13:02:10 <Cale> what cabal package is like that?
13:02:24 <otters> leksah
13:02:33 <otters> it wants gtk+, glib, pango, libjpeg, gtk-mac-integration, etc.
13:02:35 <glguy> otters: the 32-bit compiler will produce 32-bit binaries which will use 32-bit libraries
13:02:36 <hpaste> janiczek annotated “memoization” with “new addM” at http://hpaste.org/74702#a74705
13:02:42 <otters> glguy: I guess that makes sense
13:02:55 <hiptobecubic> if you hav them
13:03:00 <otters> okay, so...
13:03:05 <otters> if I just install 64-bit haskell platform now
13:03:10 <otters> do I need to reinstall all my cabal packages
13:03:35 <Heffalump> yes
13:03:36 <Cale> janiczek: delete the type signature of addM
13:03:42 <otters> son of a bitch
13:04:00 <janiczek> Cale: oh, works. :D
13:04:01 <glguy> otters: please keep your outburst to yourself :)
13:04:04 <Cale> (you can ask ghci for what it infers)
13:04:06 <otters> sorry glguy
13:04:47 <janiczek> cale: how do I load a file into ghci so I can check the :t ?
13:04:54 <Cale> ghci myfile.hs
13:05:08 <janiczek> oh. :) thanks
13:05:16 <maukd> :l thefile
13:05:22 <Cale> or that, yes
13:05:37 <Cale> (oddly, I basically never use :l)
13:05:43 <maukd> same here
13:05:48 <maukd> but I use :r a lot
13:05:54 <Cale> yep
13:06:14 <maukd> *Matrix> :r
13:06:15 <janiczek> addM :: (Eq t, Monad m, Num t, Num t1) => ((t, t1) -> m t1) -> (t, t1) -> m t1
13:06:15 <janiczek> don't understand it exactly right now, but at least that memo problem is solved :)
13:06:38 <maukd> ooh, a new ghc
13:06:44 <maukd> (separate Eq constraint)
13:07:06 <Cale> janiczek: well, you can replace t and t1 with Int
13:07:06 <MagneticDuck_> hey, is there an easy way to get gtk2hs using diagrams?
13:07:22 <MagneticDuck_> get a diagram-created image in a gtk2hs program?
13:07:32 <Cale> janiczek: and you should see what's wrong with the signature you gave: it was missing an m in the result type
13:12:27 <otters> I'm getting a miscellaneous "the installer encountered an error that caused it to fail" on the 64-bit HP installer
13:12:31 <otters> Mac OS X 10.8.1
13:14:54 <otters> I would paste an install log, but well... :|
13:15:40 <peter`> good evening! Haskell newbie here, scratching head with Array in data declaration...
13:16:25 <otters> oh, it was just a registration failure. Never mind, everybody! we're good
13:18:39 <peter`> I'm trying to define a Board data, with a 3x3 Array as field. But can't get it to compile? What am I doing wrong here?
13:19:22 <rwbarton> well, what are you doing, apparently it's wrong :)
13:19:30 <rwbarton> you can't specify the size of an Array in the type
13:19:44 <maukd> peter`: I can't see your code from here
13:19:57 <typoclass> peter`: welcome to #haskell. you can put your code on hpaste, along with the error message(s)
13:19:59 <typoclass> @where hpaste
13:20:00 <lambdabot> http://hpaste.org/
13:20:12 <typoclass> folks can then help you better
13:20:53 <peter`> data Board = { sides :: [Side], tiles :: <an array of x,y positions> } deriving ...
13:21:06 <maukd> you can't use '<' in types
13:21:35 <peter`> the <> is where I want the correct thing to come... it's a placeholder.
13:21:50 <maukd> so ... what were you trying to compile if you don't have real code?
13:22:27 <peter`> OK, be patient, this is my 1st time on IRC. I'll see I a can put a minial example on pastebot.
13:22:53 <MagneticDuck_> hey, question.. I'm trying to get something done with gloss (darn me, right) and it can't find the displayInWindow function, even though I loaded Graphics.Gloss, which loads fine
13:22:55 <MagneticDuck_> it's not a typo
13:23:45 <MagneticDuck_> has the names changed?
13:24:19 <typoclass> MagneticDuck_: could it be a version issue? maybe you're using an older gloss which doesn't have that function. try "import Graphics.Gloss" in ghci and then ":browse Graphics.Gloss" to verify
13:24:33 <MagneticDuck_> I just installed it..
13:24:36 <MagneticDuck_> from hackage
13:24:41 <MagneticDuck_> but I'll try that
13:25:17 <rwbarton> there doesn't seem to be a "displayInWindow" in gloss. http://hackage.haskell.org/packages/archive/gloss/1.7.5.2/doc/html/doc-index-D.html
13:25:30 <typoclass> MagneticDuck_: hm ok. still might be that you haven't run 'cabal update' in a while ... you can try 'cabal info gloss' to get the installed version. make sure ... oh!
13:25:42 <typoclass> rwbarton: right. i was looking at http://hackage.haskell.org/packages/archive/gloss/1.3.4.1/doc/html/Graphics-Gloss.html#v:displayInWindow which has it
13:25:47 <Caelum> How do I install a package in ghc?
13:25:51 <MagneticDuck_> I did it yesterday
13:25:56 <rwbarton> I imagine there is a replacement function
13:26:07 <MagneticDuck_> Caelum: run Setup.hs
13:26:12 <typoclass> MagneticDuck_: so it's the reverse actually. the function was present in old versions, but they have removed or renamed the function
13:26:13 <MagneticDuck_> ghc --make Setup.hs
13:26:13 <maukd> depends on your definition of "in"
13:26:17 <rwbarton> e.g. see http://hackage.haskell.org/packages/archive/gloss/1.7.5.2/doc/html/Graphics-Gloss.html
13:26:22 <rwbarton> main = display (InWindow "Nice Window" (200, 200) (10, 10)) white (Circle 80)
13:26:25 <MagneticDuck_> ah
13:26:25 <MagneticDuck_> thanks
13:26:27 <rwbarton> right at the top, is that what you want
13:26:30 <MagneticDuck_> yes
13:26:57 <geekosaur> um.  there's more to it than just running Setup.hs... I'd recommend "cabal install" (without package name) in the package directory
13:26:58 <rwbarton> google likes giving you the wrong version of a package as the top result, watch out for that
13:27:38 <Caelum> MagneticDuck_: oh I thought there was some kind of network installer, I see
13:27:42 <rwbarton> it particularly likes to give me the ghc user manual from 6.6
13:27:48 <MagneticDuck_> Caelum: yes there is
13:27:53 <MagneticDuck_> you can do "cabal install _"
13:28:10 <MagneticDuck_> or download the package from wherever (github for instance) and run "cabal install" in the directory
13:28:22 <Caelum> MagneticDuck_: ahh awesome, thank you
13:28:29 <MagneticDuck_> cabal is awesome, right?
13:28:31 <MagneticDuck_> ;D
13:28:33 <teneen> What's an orphan instance?
13:28:33 <MagneticDuck_> usually..
13:28:33 * hackagebot bound 0.5 - Haskell 98/2010 Locally-Nameless Generalized de Bruijn Terms  http://hackage.haskell.org/package/bound-0.5 (EdwardKmett)
13:28:55 <hpaste> peter pasted “Array in data definition” at http://hpaste.org/74706
13:29:15 <peter`> code's up
13:29:16 <MagneticDuck_> oh great, gloss has bugs for linux
13:29:17 <MagneticDuck_> >:|
13:29:32 <MagneticDuck_> or does it
13:29:40 <peter`> BTW, nice system :-)
13:30:12 <maukd> peter`: that would be (Int, Int)
13:30:12 <MagneticDuck_> awesome
13:30:13 <MagneticDuck_> no bugs
13:32:34 <peter`> OK, thanks. I'm so used to have numbers as indices that this was too obvious :-)
13:32:54 <dmwit> teneen: It's an instance of a type that's in a different module than both the definition of the type and the definition of the class.
13:33:03 <dmwit> uh, instance of a *class
13:33:14 <dmwit> ?wiki orphan instance
13:33:14 <lambdabot> http://www.haskell.org/haskellwiki/orphan_instance
13:33:34 <MagneticDuck_> like, if you were to make instance (Ord a) => Ord [a]
13:33:38 <MagneticDuck_> which nobody cares about
13:33:39 <MagneticDuck_> erm
13:33:45 <MagneticDuck_> that's not an instance is it?
13:33:52 <teneen> dmwit: Ohh ok. Thanks a lot :)
13:33:54 <dmwit> Yes, it's an instance.
13:33:57 <rwbarton> > "abc" < "dab"
13:33:58 <lambdabot>   True
13:34:15 <MagneticDuck_> :O
13:34:22 <MagneticDuck_> I suppose so
13:34:38 <MagneticDuck_> I was reading about making tuples Ord instances the other day in the Monad.Reader..
13:34:48 <MagneticDuck_> are they really in the Prelude?
13:34:59 <MagneticDuck_> > ('a', 'b') > ('a', 'c')
13:35:00 <lambdabot>   False
13:35:07 <MagneticDuck_> okey then
13:35:08 <MagneticDuck_> never mind
13:35:09 <MagneticDuck_> x)
13:35:20 <c_wraith> Well.  lambdabot has a lot more than Prelude imported
13:35:24 <MagneticDuck_> yeah
13:35:26 <MagneticDuck_> > 1 2
13:35:27 <lambdabot>   1
13:35:30 <MagneticDuck_> ~_~
13:35:31 <MagneticDuck_> I hate that
13:35:40 <MagneticDuck_> where is that useful?
13:35:58 <maukd> MagneticDuck_: writing functions
13:36:06 <MagneticDuck_> example?
13:36:06 <rwbarton> Ord for tuples is standard too of course
13:36:11 <maukd> > (sin + cos) 0.6
13:36:12 <lambdabot>   1.3899780883047137
13:36:19 <rwbarton> very useful
13:36:35 <MagneticDuck_> aahh
13:36:56 <donri> > ((+) <$> sin <*> cos) 0.6
13:36:57 <lambdabot>   1.3899780883047137
13:36:59 <maukd> > deriv (sin + cos) 0.6
13:37:00 <lambdabot>   0.26069314151464296
13:37:02 <maukd> > deriv (sin + cos) x
13:37:03 <lambdabot>   1 * cos x + 1 * negate (sin x)
13:37:13 <sipa> :t deriv
13:37:14 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
13:37:49 <maukd> > (deriv . deriv) (sin + cos) x
13:37:51 <lambdabot>   1 * (1 * negate (sin x)) + 1 * negate (1 * cos x)
13:38:05 <rwbarton> > (deriv * deriv) (sin + cos) x
13:38:06 <lambdabot>   (1 * cos x + 1 * negate (sin x)) * (1 * cos x + 1 * negate (sin x))
13:38:32 <maukd> > (deriv ^ 2) (sin + cos) x
13:38:33 <lambdabot>   (1 * cos x + 1 * negate (sin x)) * (1 * cos x + 1 * negate (sin x))
13:39:18 <maukd> do we have Num (IO a) yet?
13:41:10 <startling> haha
13:41:13 * Eduard_Munteanu wonders about Monad m => Num (m a)
13:41:53 <startling> (Enum a, Enum b) => Num (a -> b) ???
13:41:57 * johnw wonders about those who wonder about such things
13:42:21 <maukd> Eduard_Munteanu: you can do it for every Applicative
13:42:46 <Eduard_Munteanu> I guess it makes some sense, yeah.
13:43:33 * hackagebot bound 0.5.0.1 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.5.0.1 (EdwardKmett)
13:46:32 <edwardk> i find it kind of sad that in this day and age i can't embed an iframe with slides in it, into either haddock or github flavored markdown. =(
13:47:22 <Eduard_Munteanu> Heh, nice package description.
13:47:46 <edwardk> i wanted something less scary than " Haskell 98/2010 Locally-Nameless Generalized de Bruijn Terms"
13:48:11 <Eduard_Munteanu> edwardk: is that something along the lines of "Nameless, Painless"?
13:48:42 <Eduard_Munteanu> @google nameless painless
13:48:44 <lambdabot> http://nicolaspouillard.fr/publis/nameless-painless.pdf
13:48:44 <lambdabot> Title: Nameless, Painless
13:48:48 <edwardk> nicer
13:49:09 <edwardk> this factors out the polymorphic recursion pattern once and for all, so you just give me a monad and i deal with the capture issues for you
13:50:17 <edwardk> so its more painless than his painless approach ;)
13:50:37 <edwardk> also i further generalize generalized de bruijn to deal with simultaneous substitution
13:50:53 <edwardk> but you an view the approach pouillard talks about as a precursor to this
13:51:01 <edwardk> er you can
13:51:17 <benmachine> does anyone here have any opinions on how idiom brackets should work with infix applications?
13:51:54 <paolino> hello, it's seems there is no way to invert Ix.range function. (a,a) -> [a]. How am I supposed to create new bounds for a generic Ix instance ?
13:52:28 <edwardk> paolino: you want to take a [a] -> (a,a) ?
13:52:42 <maukd> :t range
13:52:43 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
13:52:55 <maukd> paolino: huh?
13:53:18 <maukd> :t (head &&& last)
13:53:19 <lambdabot> forall c. [c] -> (c, c)
13:53:20 <edwardk> paolino: in general you can't invert that operation, because at best you can give a range that covers it
13:53:40 <maukd> > range (2, 1)
13:53:41 <lambdabot>   []
13:54:04 <rwbarton> I don't understand what "invert Ix.range function" has to do with "create new bounds for a generic Ix instance"
13:54:36 <paolino> rwbarton I'm trying to write chunkArray
13:54:48 <maukd> @hoogle chunkArray
13:54:48 <lambdabot> No results found
13:54:53 <rwbarton> ah
13:54:56 <paolino> for Ix i
13:55:00 <rwbarton> "why didn't you say so" :)
13:55:04 <paolino> :)
13:55:11 <rwbarton> what are you going to do for (Int,Int)
13:56:17 <paolino> ok, Ix i is too generic
13:58:00 <paolino> I will try Enum i
13:59:32 <purerhyme> hello, I'm just testing :P
13:59:55 <hpaste> peter annotated “Array in data definition” with “Array in data definition (annotation)” at http://hpaste.org/74706#a74708
14:00:53 <maukd> missing parens
14:01:09 <rwbarton> also missing argument to array
14:01:10 <peter`> grrr, can't understand what's going on... probably obvious, but can't see it. http://hpaste.org/74706#a74708
14:02:31 <rwbarton> and an array of Ints has to contain Ints
14:02:37 <rwbarton> it can't just randomly not contain things
14:02:46 <rwbarton> you can use Maybe Int for that
14:03:12 <peter`> OK, makes sense.
14:03:23 <maukd> or you could just use a Map
14:04:05 <peter`> That's probably more understandable than an array. Strange world... :-)
14:04:06 <pdxleif> Since String is Monoid - I'm wondering is there a general way to get from Monoid m => Maybe m -> m
14:04:21 <pdxleif> Where it just gives you the identity of the Monoid if it's Nothing?
14:04:29 <benmachine> pdxleif: fromMaybe mempty?
14:04:38 <rwbarton> also something with Foldable
14:04:46 <benmachine> rwbarton: oh, true
14:04:49 <rwbarton> @type (Foldable f, Monoid m) => f m -> m
14:04:50 <benmachine> that's actually just "fold"
14:04:50 <lambdabot> parse error on input `=>'
14:04:54 <rwbarton> @hoogle (Foldable f, Monoid m) => f m -> m
14:04:55 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
14:04:55 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
14:04:55 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
14:04:57 <rwbarton> indeed it is
14:04:59 <benmachine> > fold (Just "hello")
14:05:00 <rwbarton> :)
14:05:00 <lambdabot>   Not in scope: `fold'
14:05:03 <benmachine> :(
14:05:08 <donri> > Data.Foldable.concat (Just "hi")
14:05:09 <lambdabot>   "hi"
14:05:09 <benmachine> damn it, lambdabot
14:05:15 <paolino> rwbarton, I think Data.List.Split.chunksOf n (range x) is not so bad with (Int,Int)
14:05:16 <donri> > Data.Foldable.concat Nothing :: String
14:05:17 <lambdabot>   ""
14:05:17 <pdxleif> Hmm, sounds like I could make a utility function of that.
14:05:25 <benmachine> donri: concat, huh
14:05:44 <rwbarton> is that just fold specialized to m = String?
14:05:55 <paolino> > range ((1,1),(3,3))
14:05:56 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:06:01 <benmachine> rwbarton: m = [a], looks like
14:06:06 <rwbarton> oh of course
14:06:14 <donri> :t Data.Foldable.concat
14:06:15 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t [a] -> [a]
14:07:19 <hiptobecubic> @src range
14:07:19 <lambdabot> Source not found.
14:08:15 <hiptobecubic> i guess it's just a double list comprehension
14:08:35 <paolino> edwardk, I don't understand the "at best", sorry
14:09:58 <edwardk> paolino: i lost the context
14:10:18 <paolino> ops, its the ranfe function
14:10:22 <paolino> range
14:10:52 <edwardk> oh
14:10:53 <paolino> if an instance could implement (a,a) -> [a], how it can't implement the inverse ?
14:10:58 <hiptobecubic> @check \lx ly hx hy -> range ((lx,ly), (hx,hy)) == [(x,y) | x <- [lx..hx], y <- [ly..hy]]
14:10:59 <lambdabot>   "OK, passed 500 tests."
14:11:21 <johnw> @check x = x
14:11:22 <lambdabot>   Parse error at "=" (column 3)
14:11:28 <johnw> @check f x = f x
14:11:28 <lambdabot>   Parse error at "=" (column 5)
14:11:29 <edwardk> paolino: what i mean is you can't get a (a,a) that covers exactly the elements in the [a], you can get a list that covers that list, but it isn't a proper inverse
14:11:31 <pdxleif> Data.Foldable.concat doesnt' seem to represent a generic "orZero" function the way fromMaybe mempty does.
14:11:42 <Twey> paolino: Because (x, y) can always become [x, y], but the type [a] includes []
14:11:56 <benmachine> pdxleif: what about "fold"?
14:11:58 <rwbarton> wait let's just go back to your example
14:12:02 <rwbarton> > range ((1,1),(3,3))
14:12:03 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:12:06 <rwbarton> suppose I split into chunks of 2
14:12:12 <rwbarton> second chunk is [(1,3),(2,1)]
14:12:28 <rwbarton> good luck finding x and y such that range (x,y) = [(1,3),(2,1)]
14:12:38 <maukd> > (head &&& last) [(1,3),(2,1)]
14:12:39 <lambdabot>   ((1,3),(2,1))
14:12:44 <pdxleif> @type Data.Foldable.fold
14:12:45 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
14:13:20 <pdxleif> clever stuff
14:13:57 <pdxleif> That's not the foldl1 I'm used to.
14:14:54 <paolino> ok, I can't feel confortable with a sequential think that cannot be chunked, but I think I understand the point
14:15:44 <rwbarton> well you can turn the indices of the rectangular array into a list and then chunk that, you just can't turn it back into a rectangular array...
14:15:47 <janiczek> is using "sum $ map (... something that returns `m Integer`) [0..9]" wrong when using monads? m = Monad
14:15:57 <hiptobecubic> @src fix
14:15:57 <lambdabot> fix f = let x = f x in x
14:16:14 <janiczek> fix instead of map?
14:16:23 <paolino> mapM
14:16:36 <paolino> and fmap sum
14:17:08 <c_wraith> you really want a sequence in there
14:17:22 <c_wraith> ah, I see.  That's what the mapM is for
14:17:38 <janiczek> uh ... fmap sum $ mapM (...) [0..9] ?
14:17:53 <c_wraith> yep
14:18:04 <paolino> :t \f -> fmap sum . mapM f
14:18:05 <lambdabot> forall a (f :: * -> *) a1. (Num a, Functor f, Monad f) => (a1 -> f a) -> [a1] -> f a
14:18:17 <c_wraith> though that's the same as:  sum <$> mapM (...) [0..0]
14:18:30 <janiczek> oh! works!
14:18:30 <janiczek> thanks
14:18:34 * hackagebot fast-tagsoup 1.0.2 - Fast parser for tagsoup package  http://hackage.haskell.org/package/fast-tagsoup-1.0.2 (VladimirShabanov)
14:18:42 <janiczek> had to add Functor m into type declaration, but works then :)
14:18:58 <paolino> you can use liftM
14:21:46 <ParahSai1in> @pl enumerate x = zip x [0..]
14:21:46 <lambdabot> enumerate = flip zip [0..]
14:23:57 <johnw> flip zip!
14:24:30 <Ralith> hee
14:25:47 <c_wraith> :t enumerate
14:25:49 <lambdabot> Not in scope: `enumerate'
14:26:01 <c_wraith> Hmm.  I guess no one named it because the zip is so easy
14:26:28 <paolino> rwbarton, I think chunking is a dimension dipendent operation, so Ix i is too open. Maybe a concrete type for Ix i using Nat as argument, or some wizardry :)
14:29:21 <rwbarton> (Enum i, Ix i) should be okay, if you assume something reasonable about range
14:29:43 <rwbarton> like range (x, y) = enumFromTo x
14:29:44 <rwbarton> y
14:34:57 <paolino> The other side is I cannot ask a one dimensional index as function context
14:35:32 <janiczek> uhm ... how to use Debug.Trace.trace from inside "do" block? gosh, I should really re-read some monad tutorials :)
14:35:57 <maukd> the same way you use it outside
14:36:08 <maukd> what kind of "do" block is this?
14:36:59 <paolino> @hoogle trace
14:37:00 <lambdabot> Debug.Trace module Debug.Trace
14:37:00 <lambdabot> Debug.Trace trace :: String -> a -> a
14:37:00 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
14:37:08 <janiczek> myFn = do { answer <- something; return answer }
14:37:16 <janiczek> so i should just prepend trace ("xyz") before the answer?
14:37:19 <benmachine> yes
14:37:21 <benmachine> er
14:37:29 <benmachine> before 'return answer'
14:37:32 <maukd> janiczek: yes, but what's the type?
14:37:41 <benmachine> or before 'something' depending on when you want it to have the effect
14:38:09 <rwbarton> you could also just use print
14:38:20 <rwbarton> if it's a do block in IO
14:38:25 <janiczek> yeah print will probably do better
14:38:25 <rwbarton> which I guess was maukd's question
14:38:31 <janiczek> its not io block
14:38:31 <benmachine> mm
14:38:37 <janiczek> nonbouncyM :: (Monad m, Functor m) =>
14:38:38 <janiczek>             ((Int, Int, Dir, Int, Bool) -> m Integer)
14:38:38 <janiczek>           -> (Int, Int, Dir, Int, Bool) -> m Integer
14:38:44 * benmachine blinks
14:38:48 <janiczek> and the error is Could not deduce (m ~ (->) a0)
14:38:48 <janiczek>     from the context (Monad m, Functor m)
14:38:51 <janiczek> yeah. :D
14:38:54 <benmachine> that's very odd
14:39:03 <benmachine> oh, well, trace won't fix your type errors
14:39:13 <rwbarton> he's doing some memoizing thing so the argument is the memoized version
14:39:20 <benmachine> hpaste your code?
14:39:39 <janiczek> benmachine: wait, I will try the print first - maybe it will work
14:39:48 <benmachine> janiczek: it won't if it's not IO
14:40:04 <rwbarton> you probably didn't use enough parentheses
14:40:19 <maukd> janiczek: that means you're missing a function argument somewhere
14:40:33 <benmachine> or perhaps you have one too many?
14:43:03 <rwbarton> while it is an interesting exercise to try to find the simplest error that will produce a given error message, it would be much easier if you just provided your code along with the error message
14:44:03 <timthelion> rwbarton: you can get paid good money to find simple errors if you're good at it :D
14:44:05 <maukd> > let foo :: (Monad m) => m (); foo = do { length; return () } in foo
14:44:06 <lambdabot>   Couldn't match expected type `m' against inferred type `(->) [a]'
14:44:06 <lambdabot>    `m' is...
14:44:22 <dgcSfUw> ttbap qtzec pqqqf :
14:44:22 <pUX> lnacl zywic etasi :
14:44:22 <cvufQWqbAqP> uttwx waprx ecsox :
14:44:22 <RkolMVHKr> rrqet laagg wrujd :
14:44:22 <DfadcJLXb> nqoei mzhif darpy :
14:44:22 <fnWtmR> zcsmx dhsrs pauyg :
14:44:23 <OdOWTgYGKqzc> ridky zrkou ntarl :
14:44:23 <rxbkpJZtozb> pmvez rtmid iuxrj :
14:44:23 <YADSbVP> itrad kzacp bfgjs :
14:44:23 <CafwVFSY> pgbei oyrgz kuhwe :
14:44:36 <YRobIvptiV> xyqto nwbau ayesh :
14:44:40 <pUX> kffsx qwxeb lrted :
14:44:40 <dgcSfUw> phmfm sinae inyjv :
14:44:40 <VaubJ> gdmmm bfxtq vhbax :
14:44:40 <IYmfnpO> vtocf kjfoe kllvb :
14:44:40 <DfadcJLXb> lldtd mgqfr watiz :
14:44:40 <JMYYchi> jtndb nvxve idcpc :
14:44:40 <fEv> nylvq zxujg eirfw :
14:44:40 <fnWtmR> ofwxv jydpg fnnja :
14:44:40 <kzLfLMhoCur> gyqqz aoedu ykklv :
14:44:40 <mivVgcmNnBEu> feoed saylm ysknt :
14:44:44 --- mode: ChanServ set +o maukd
14:44:44 --- mode: maukd set +r
14:44:51 <maukd> sorry for this
14:44:56 <QluKvoyjQ> fwidr esdpe mlwbl :
14:44:57 <puLA> upqum lojms kpyqr :
14:45:01 <timthelion> What's going on?
14:45:07 <maukd> some kind of flooding
14:45:21 <hpaste> janiczek pasted “trace” at http://hpaste.org/74709
14:45:24 --- mode: maukd set -o maukd
14:45:26 <janiczek> surely it's something stupid ..
14:46:13 <badabing> What could someone do with my ipaddress?
14:46:14 --- mode: ChanServ set +o maukd
14:46:14 --- mode: maukd set +b *!~Denizimmm@*
14:46:54 --- mode: maukd set -o maukd
14:47:06 <geekosaur> run nmap against you looking for open ports
14:47:11 <timthelion> thanks maukd
14:47:18 --- mode: ChanServ set +o maukd
14:47:18 --- mode: maukd set -r
14:47:32 <rwbarton> what's +r do
14:47:36 <maukd> janiczek: yeah, you're missing trace's second argument
14:47:58 --- mode: maukd set -o maukd
14:48:07 <janiczek> oh ... and if I don't want to return anything?
14:48:12 <maukd> janiczek: ?
14:48:17 <janiczek> well with the trace
14:48:21 <badabing> geekosaur: and with open ports they can enter my computer?
14:48:23 <maukd> that makes no sense
14:48:45 <geekosaur> janiczek, if that's Debug.Trace.trace, it's intended to be used in the middle of an expression
14:49:03 <rwbarton> @type trace
14:49:04 <timthelion> badabing: yes.  But if you have a sane operating system(I think both arch linux and debian do this) you won't have ANY open ports unless you enabled them by hand.
14:49:04 <lambdabot> Not in scope: `trace'
14:49:09 <rwbarton> @type Debug.Trace.trace
14:49:11 <lambdabot> forall a. String -> a -> a
14:49:31 <janiczek> aha! i put it after the "answer <-" and it seems to work
14:49:34 <rwbarton> trace s e = e but print s when e is evaluated
14:49:49 <timthelion> badabing: windows leaves open ports for support services and service discovery services, but they are all theoretically secured in such a way that you cannot be hacked.
14:49:55 <janiczek> so it forced a return when I did it on its own row
14:49:57 <janiczek> line*
14:49:58 <janiczek> :D
14:50:02 <geekosaur> supposedly.
14:50:08 <badabing> i have win 7
14:50:16 <janiczek> thats where that "(->) a0" or what was it came from
14:50:47 <rwbarton> well it thought "trace whatever" was an action because you put it on a line by itself in a do block, but "trace whatever" is a function
14:50:57 <geekosaur> haskell is functional.  a partially applied function (leaving off a parameter) is perfectly sensible, but won't typecheck where you did it
14:51:30 <timthelion> badabing: I have not read the source code to any windows based operating system, nor have I done any in depth binarry analisys.  I cannot confirm or deny any security vulnerabilities at this time.
14:52:13 <geekosaur> badabing, I will note that there have been several emergency patches recently for windows 7
14:52:16 <bezZdihYCT> wdnih uzynq djgdv :
14:52:16 <bezZdihYCT> tsuzj ljfyd noxrm :
14:52:18 <bezZdihYCT> nsmuv rtcsc ipqjh :
14:52:19 <bezZdihYCT> sqcod pzvie cehij :
14:52:21 <bezZdihYCT> vsidr acnvr uatna :
14:52:22 <bezZdihYCT> mtowv smcss nihxa :
14:52:22 <maukd> there we go
14:52:23 <MoVQLYPqSa> pibdn tjwhb qfvlz :
14:52:23 <LDMgoMv> duplf rcrcc bdgbe :
14:52:23 <jEI> yvxlv rsjpw moipv :
14:52:24 <bezZdihYCT> kymab dblmb uqenm :
14:52:25 <IedXRpSnWqJ> ovysi jxfms cobqj :
14:52:25 <MoVQLYPqSa> fmpby mwykq fxqav :
14:52:25 <CVDLePLIHvNS> krvjb thlud polth :
14:52:25 <aUmZKsZnaxy> kfmbf xjkrw wmxnl :
14:52:25 <jEI> dqepo feiso moytt :
14:52:25 <bezZdihYCT> fsbmd ytwdf isjds :
14:52:25 <LDMgoMv> qguor edims flaii :
14:52:26 <MostAwesomeDude> @where ops
14:52:26 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
14:52:26 <aUmZKsZnaxy> knmwl zqnfi xolrm :
14:52:26 <jEI> ljgoc tkqtq zwijk :
14:52:26 <uTjAdD> ayiap hzadl iwkdv :
14:52:30 --- mode: ChanServ set +o maukd
14:52:30 --- mode: maukd set +r
14:53:10 --- mode: maukd set -o maukd
14:53:13 <MostAwesomeDude> That was kind of bizarre.
14:53:20 <Sweden_jack> Yeah it was
14:53:45 <Botje> almost as weird as those russian radio station that constantly read out numbers
14:54:21 <maukd> Sweden_jack: ah, so you can still speak
14:55:02 <Sweden_jack> Was there any doubt?
14:55:10 <timthelion> Botje: I haven't heard of those.
14:55:26 <MostAwesomeDude> timthelion: https://en.wikipedia.org/wiki/Numbers_station
14:55:32 <maukd> we're +r now and you're not identified, so you probably couldn't rejoin if you left
14:55:59 <Sweden_jack> Oh well, this isn't my usual nickname; I just happen to be in Sweden
14:56:04 <maukd> and something's not quite right here because I'm seeing double joins
14:59:46 <Swizec> how can I convince haskell that a constant is Fractional?
14:59:56 <maukd> what do you mean?
15:00:00 <rwbarton> it is
15:00:04 <Swizec> I have x = 0.7
15:00:10 <maukd> go on
15:00:13 <Swizec> and it complains in other parts that it can't deduce Fractional into Double
15:00:20 <maukd> no, what does it actually say?
15:00:21 <timthelion> I don't see any double joins maukd.
15:00:24 <Swizec> because I compare something to this X
15:00:28 <maukd> timthelion: I know
15:00:43 <Twisol> I saw some double joins
15:01:04 <maukd> timthelion: client issue on my end, should be fixed now
15:01:57 <Swizec> maukd http://pastebin.com/PWKzc77S
15:02:01 <maukd> The paste PWKzc77S has been copied to http://hpaste.org/74710
15:02:41 <timthelion> It seems that someone is trying to attack freenode.  Or perhaps use it as a medium for broadcasting messages.  Perhaps the number station theory is right.
15:02:44 <maukd> monomorphism restriction
15:02:57 <benmachine> maukd: are you sure?
15:03:11 <rwbarton> seems very likely
15:03:14 <maukd> benmachine: what else could it be?
15:03:21 <MostAwesomeDude> Yeah, just declare that constant as a Double.
15:03:29 <hbIppo> wait, I think I was afk for a while
15:03:33 <rwbarton> no, declare it as Fractional a => a
15:03:36 <benmachine> maukd: the type signature of the function says fitness is polymorphic, but it's not used polymorphically
15:03:37 <rwbarton> or whatever the type class is
15:03:37 <hbIppo> what? number stations? on irc?
15:03:38 <rwbarton> @type 0.7
15:03:39 <lambdabot> forall t. (Fractional t) => t
15:03:41 <maukd> MostAwesomeDude: that's exactly not how it works
15:03:43 <benmachine> maukd: ohh, wait
15:03:48 <benmachine> maukd: sorry, yes, I see
15:03:51 <MostAwesomeDude> maukd: You're right.
15:04:08 <benmachine> Swizec: give an explicit type signature to mutate_threshold
15:04:14 <timthelion> hbIppo: there was some weird flooding a while back, that's all.
15:04:16 <monochrom> right, MR restricts mutate_threshold to be Double, and then "should" wants it to be general
15:04:18 <Swizec> benmachine how do I do that?
15:04:33 <benmachine> Swizec: mutate_threshold :: Fractional a => a
15:04:38 <rwbarton> just like you did for should
15:04:42 <benmachine> Swizec: put that above its definition
15:04:51 <monochrom> actually you can put it below, too
15:04:53 <benmachine> Swizec: that says "this is a polymorphic constant"
15:05:01 <monochrom> in fact, put it on almost any line :)
15:05:05 <benmachine> monochrom: you can also put it somewhere else entirely. but don't, because that's silly
15:05:11 <monochrom> hehe
15:05:25 <Swizec> oh cool, I thought that only works for functions :D
15:05:32 <monochrom> "x, y, z :: Fractional a => a" is pretty handy
15:05:34 <Swizec> and I guess a constant is a function sort of anyway
15:05:35 <rwbarton> nothing special about functions
15:05:38 --- mode: ChanServ set +o maukd
15:05:38 --- mode: maukd set +b *!~soe@*
15:05:50 <Swizec> now randomR complains ...
15:05:51 <maukd> Swizec: constants aren't functions
15:06:05 <monochrom> every definition can be given a type signature. function definition is a special case
15:06:10 --- mode: maukd set -r
15:06:18 <maukd> brace yourself
15:06:23 <benmachine> Swizec: when you do 'main :: IO ()', main is not a function
15:06:27 <monochrom> value definition is also a special case
15:06:50 --- mode: maukd set -o maukd
15:07:09 <monochrom> the general case is pattern definition. "pattern = body", e.g., (Just x, f) = (Just 5, \x -> x && x)
15:07:32 <benmachine> monochrom: I'm pretty sure you can only give type signatures to names, though
15:07:38 <benmachine> or, well, comma-separated lists of names
15:07:49 <Swizec> fascinating
15:08:00 <monochrom> yes that's true. "x :: Integer" and "f :: Bool -> Bool", separately
15:08:20 <zungaloca> How to update haskell
15:08:26 <maukd> which haskell?
15:08:27 <monochrom> how do you mean?
15:08:34 <zungaloca> GHC
15:08:42 <benmachine> zungaloca: depends how you got it in the first place
15:08:47 <monochrom> that's easy. download a new one, install
15:09:02 <zungaloca> Cabal dont update
15:09:12 <zungaloca> In mac os x
15:09:14 <monochrom> right, Cabal not responsible for GHC
15:09:30 <zungaloca> Cabal cant update it i though
15:09:38 <monochrom> right, Cabal not responsible for GHC
15:09:52 <rwbarton> maybe some day
15:10:42 <zungaloca> Ok thanks
15:10:56 <monochrom> download a new one. follow install instructions. make a few decisions as to which directory to put it in, whether you want to keep the old one, etc etc
15:11:07 <timthelion> Botje: Thanks for telling me about number stations. I think I have a new favorite "genre of experimental electronic music" :D  http://archive.org/details/ird059
15:11:24 <monochrom> my definition of IQ: 100/(how many times I say it before you understand) = 50
15:12:05 <benmachine> monochrom: are you still keeping 100 as the standard
15:12:54 <monochrom> yes, seems convenient to, people like all fractions scaled to percentages
15:12:55 <benmachine> monochrom: what if I interrupt you one-sixtieth of the way through your explanation
15:13:04 <Botje> timthelion: \o/
15:13:20 <monochrom> oh! then you have the IQ of 600, and I congratulate you :)
15:13:36 <benmachine> :D
15:13:48 <maukd> what if I don't understand that equation?
15:14:03 <monochrom> but in reality you have to take average. you don't perform at 600 all the time. after averaging, you're probably at 200 or 150
15:14:37 <benmachine> monochrom: well, you are quite unfairly using a message-based protocol, which makes it significantly trickier :P
15:15:38 <typoclass> iq = 100 / (how often you repeat the same thing in the same words after it has been established that he doesn't understand that)
15:16:17 <monochrom> yes, over IRC, it's hard to measure the number of times if you need less than 1 time
15:16:53 <monochrom> (but I will believe you if you say you only read 1/6 of my line and you already know what I'm up to)
15:17:22 <meiji11> is IntMap a good priority queue for use in something like djikstra's algorithm?
15:17:42 <monochrom> however, if someone clearly makes me say a thing 3 times, you have a pretty good interval (2,3]
15:17:47 <timthelion> meiji11: what if I have to read what you say 3 or 4 times, but I only have to ask once, and you only have to explain once?
15:18:22 <meiji11> I.. don't know?
15:18:31 <monochrom> heh wrong nick completion :)
15:19:09 <monochrom> I count that as 1. smart of you to process it thoroughly. I respect that
15:19:13 <timthelion> monochrom: there is something wrong with my completion.  Normally it completes to the nick that spoke most recently, but when I press m + tab I get meiji11
15:20:14 <monochrom> IntMap's find-min is not O(1)
15:20:29 <timthelion> perhaps if two nicks are both talking relatively close to eachother than it switches to some alphabetic ordering.  Too smart for it's own good IRSSI
15:20:54 <badabing> monochrom: log(N) ?
15:20:57 <monochrom> yes
15:21:51 <meiji11> ouch.
15:22:04 <monochrom> but IIRC something else in Dijkstra's algorithm does not like heaps either
15:22:52 <benmachine> monochrom: IntMap is bounded so everything is O(1) >_>
15:22:59 <monochrom> haha ok!
15:23:31 <hpc> heh
15:23:37 <benmachine> the serious point behind that being, I'm not sure if asymptotics are relevant at that scale
15:23:38 <badabing> i dont get the joke
15:29:54 <djahandarie> IntMap's findMin is O(min(n,W)). And O(min(n,W)) = O(1). So it's not a "joke" to say that it's O(1) really, because it really is.
15:30:19 <c_wraith> because there's an upper bound on the number of entries that can be in an IntMap
15:30:25 <c_wraith> upper bounds always mean O(1)
15:30:35 <benmachine> well, pedantically, yes
15:30:38 <maukd> no, because W is small
15:31:05 <c_wraith> W is the log of the maximum number of entries
15:31:13 <benmachine> but if you are going to say that you might as well discard asymptotic analysis altogether because it's fairly often possible to get a bound on your data structures
15:31:33 <dolio> W is the integer word size.
15:31:43 <benmachine> djahandarie: (isn't there meant to be a log in there somewhere?)
15:31:44 <c_wraith> Which happens to be the log of the maximum number of entries
15:31:51 <monochrom> W is a boson.  <duck>
15:32:50 <dolio> Yeah, I actually missed "maximum" in there somehow.
15:33:07 <Botje> a boson duck? is that any good?
15:33:30 <monochrom> more tender than a hadron duck
15:37:01 <latro`a> ...dammit
15:37:04 <latro`a> now I want thai duck
15:37:07 <latro`a> you guys suck
15:37:08 <latro`a> :(
15:37:25 <hpaste> badabing pasted “sockets send me a msg” at http://hpaste.org/74711
15:37:42 <Botje> thai duck? never heard of that subatomic particle.
15:38:18 <latro`a> it has a unique quantum flavor
15:38:20 <latro`a> called curry
15:38:34 <latro`a> no other subatomic particles have that flavor
15:39:42 <Botje> makes sense
15:39:47 <Botje> dammit, now I want curry as well.
15:40:00 <Botje> and I just had some, five hours ago
15:40:34 <monochrom> how can you pull off with "import socket"? wait, is this even haskell?
15:41:00 <badabing> Anyone here wanna run a python script against my server and send me a message?
15:41:14 <badabing> http://hpaste.org/74711
15:44:39 <badabing> ok thats a enough
15:44:40 <badabing> ty
15:44:48 <badabing> who sent?
15:45:33 <badabing> who sent all those y's?
15:45:48 <kyagrd> yes | telnet 109.58.18.219 8080 > /dev/null
15:46:00 <badabing> ok
15:47:14 <badabing> it was a little to highlevel though
15:47:33 <badabing> just importing socket and shipping stuff to an address, doesnt teach me anything real
15:57:58 <startling> badabing, what do you mean "doesnt teach me anything real"?
16:02:16 <badabing> startling: well im just using a lib. i dont have to really code anything that i didnt know how to
16:02:34 <badabing> id like to mess more directly with tcp and iå
16:02:36 <badabing> ip
16:08:24 <startling> badabing, why?
16:11:44 <badabing> to learn
16:11:59 <badabing> there the C socket API that everything is based on
16:12:14 <badabing> all other lnags socket libs i mean are based on that
16:12:23 <startling> badabing, you could read their source code
16:12:32 <MostAwesomeDude> badabing: Sockets suck, learn protocols.
16:12:36 <badabing> but i want to go deeper than that but maybe thats not possible because sockets are provided by the OS
16:12:58 <MostAwesomeDude> badabing: Do you feel that this will somehow improve your ability to write networking code? :3
16:13:07 <badabing> MostAwesomeDude: but how do I communicate if i dont use sockets? how do i use the protocol?
16:13:53 <badabing> MostAwesomeDude: well since i have no ability to write networking code... :) i have tanenbaums book 5th edition so i will work through that slowly
16:14:13 <MostAwesomeDude> badabing: That's a good way to learn the low-level stuff.
16:14:32 <MostAwesomeDude> badabing: I would suggest that you get familiar with whichever networking libraries are useful and good in your language of choice.
16:14:35 <ippo> badabing: studying how a socket is implemented will improve your code as much as learning how to design the clutch of your car will make you a better driver
16:15:01 <ippo> (but sure it will be very interesting)
16:15:40 <badabing> MostAwesomeDude: whats a good way? reading tanenbaums book?
16:16:00 <badabing> i dont get how to use just protocols. how would i connect to another computer?
16:16:12 <shapr`> badabing: dpkt and scapy are good tools for that.
16:16:22 <startling> I've got a Result a. is there a way I can make Alternative a => Result a an instance of Alternative?
16:16:33 <shapr`> badabing: They're both written in Python, but if you combine them with wireshark, you can learn and do fun thinsg.
16:18:08 <shapr`> badabing: wireshark lets you look at the bits-level detail of a connection, dpkt and scapy let you build connections by hand.
16:18:29 <MostAwesomeDude> badabing: The canonical protocol implementation for Python is Twisted: http://twistedmatrix.com/trac/
16:18:52 <MostAwesomeDude> There's not a good one for Haskell (yet), but there's been some pretty cool recent work in that direction. Pipes and conduits are getting there.
16:19:23 <shapr`> Which protocol are we discussing? Jag forstar inte :-(
16:19:42 <startling> shapr`, the metaprotocol
16:20:16 <ivanm> startling: you mean a protocol for protocols?
16:20:52 <startling> ivanm, precisely
16:20:59 <badabing> but how is the connection estblished if not sockets are used?
16:21:32 <ivanm> pixies
16:21:34 <ivanm> :p
16:22:33 <shapr`> badabing: a connection is an imaginary thing that you pretend exists
16:23:22 <startling> sort of like types
16:25:22 <benmachine> startling: re: your Alternative question, remember that instances of Alternative are type constructors, not types
16:25:37 <benmachine> (like Maybe, not like Maybe a)
16:25:40 <startling> benmachine, yeah, I unserstand why it's not allowed
16:25:53 <startling> I'm just wondering if there's some magic extension that'll allow it. :S
16:26:09 <benmachine> startling: probably not. why do you want it?
16:26:44 <ivanm> almost sounds like you want applicative transformers...
16:26:54 <ivanm> startling: so you have something like "Result Maybe" ?
16:26:56 <benmachine> there's no such thing, because applicatives just compose :P
16:27:23 <startling> no, I just want to be able to do empty = Result empty
16:27:39 <startling> well, there's another type variable in there too
16:27:43 <startling> which is a Monoid
16:27:45 <badabing> ok i missed whatever was sauid
16:27:53 <startling> so empty = Result mempty empty.
16:28:04 <badabing> if not connectinc with sockets, how is a connection achieved?
16:28:37 <benmachine> startling: why not just Monoid a => Monoid (Result a), then mempty = Result mempty mempty?
16:28:50 <ivanm> benmachine: sounds too sensible... :p
16:29:01 <startling> benmachine, I already have that.
16:29:14 <sipa> badabing: using a layer on top of it, i presume
16:29:19 <benmachine> startling: so why would you want Alternative as well?
16:29:21 <geekosaur> badabing, I think the point was more than doing things the low level way is usually doing them the painful and stupid way; high level libraries exist for a reason
16:30:05 <benmachine> startling: I think you might be able to hack it with GADTs if you can change the definition of Result, but I assume you can't
16:30:32 <benmachine> startling: actually, I'm pretty sure what you want to do doesn't make sense at all, thinking about it >_>
16:30:42 <benmachine> startling: I'm still not sure why you want to do it
16:31:22 <startling> yeah, not sure this makes a whole lot of sense
16:35:56 <zungaloca> what is a space leak
16:36:43 <ivanm> zungaloca: when your program hangs on to memory much longer than it should or you'd expect
16:37:04 <ivanm> so over time more and more memory builds up and you might run out of memory
16:37:15 <zungaloca> howww
16:37:29 <ivanm> e.g. foldl vs foldl'
16:37:37 <ivanm> @google haskell space leak
16:37:38 <lambdabot> http://www.haskell.org/haskellwiki/Memory_leak
16:37:39 <lambdabot> Title: Memory leak - HaskellWiki
16:39:22 <badabing> geekosaur: yes but if i want to learn the low level way? but is sockets the lowest level? it seems a bit to easy.
16:40:22 <benmachine> badabing: the levels keep going down until you hit the kernel
16:40:28 <benmachine> or further, if you're sufficiently dedicated
16:40:38 <zungaloca> thnx
16:40:40 <geekosaur> sockets is the lowest level the OS typically exposes; lower level on POSIXish systems still goes through sockets but requires you to implement more and more of the protocol  yourself, until you reach the point wher eyou need to write device driver code in the kernel
16:40:44 <ivanm> if you want to be low level, you need to first design a system to exchange communications electronically from one physical location to another...
16:40:45 <ivanm> :p
16:40:52 <nand`> the levels keep going down until you need a microphysics degree
16:41:09 <ivanm> though if you're interested in protocols I guess you could always use IP over pigeons...
16:41:11 <benmachine> SOCK_RAW is tedious enough already
16:41:36 <geekosaur> at a guess I'd say you have this idea of how to learn things, and it's making incorrect assumptions about how the world works
16:42:02 <monochrom> ivanm: indeed, earlier today, I said "set up antennas on both sides, or use pigeons"
16:42:44 <badabing> geekosaur: ok whats that idea and what are incorrect assumptions?
16:42:45 * geekosaur notes that he knows something about the lowest levels --- and it has nothing to do with software
16:43:00 <monochrom> I also suggested "take a course on computer networks. read Tanenbaum's book"
16:43:06 <geekosaur> *sigh* that you even asked that question might be proof that you are off course
16:43:31 <benmachine> geekosaur: that's not really a helpful response :P
16:43:45 <geekosaur> the lowest level of this stuff is the stuff of electrical engineering, not of programming
16:43:54 <nand`> ^
16:43:56 <geekosaur> benmachine, "show me the lowest level" is not a sane question
16:44:20 <geekosaur> I have no real idea how to answer this, except to try to point out that it's entirely the wrong question
16:44:23 <robstewartuk> Does hackage or some other service have the function to tell me how many packages depend on some package X ?
16:44:28 <badabing> i know it is electrial, but im asking for the lowest level software
16:44:29 <robstewartuk> (also on hackage)
16:44:40 <benmachine> geekosaur: sometimes just going "you're wrong" is hardly an improvement on saying nothing at all
16:44:42 <rwbarton> @google hackage reverse dependency
16:44:43 <lambdabot> http://packdeps.haskellers.com/
16:44:43 <lambdabot> Title: Hackage dependency monitor
16:44:47 <monochrom> the lowest level software is hack your OS
16:44:48 <benmachine> badabing: but why?
16:44:52 <nand`> then perhaps the device driver wasn't too far off
16:44:52 <robstewartuk> rwbarton: cheers
16:44:58 <nand`> there's a Haskell network driver somewhere :P
16:45:00 <maukd> microcode
16:45:07 <maukd> you know you want it
16:45:18 <badabing> well i want to learn datacommunication, what is the best way to go about it? just go through tanenbaums book?
16:45:31 <monochrom> that is a start
16:45:47 <monochrom> also, I did not and will not say "just"
16:45:53 <geekosaur> the lowest level software is kernel device drivers.  the lowest level usermode software is sockets (on posix at least).  sockets are designed to support things other than standard networking and are more fiddly that you probably care about, unless you plan to read Stevens while writing socket code --- and in that case I would recommend C instead of Haskell
16:46:18 --- mode: ChanServ set +o maukd
16:46:18 --- mode: maukd set -b *!~Denizimmm@*
16:46:23 <zungaloca> nice stuff http://blog.ezyang.com/2011/05/space-leak-zoo/
16:46:58 --- mode: maukd set -o maukd
16:47:11 <badabing> ok
16:47:13 <robstewartuk> rwbarton: hm, this isn't quite what I'm looking for. For a given package X, I want to see how many other packages depend on X.
16:47:20 <badabing> anyway ill work through tanenbaum
16:47:24 <ivanm> maukd: if you're here, does this mean we can expect preflex and its magical seen plugin back sometime soon?
16:47:24 <rwbarton> there is a link to that on the page I think
16:47:33 <rwbarton> http://packdeps.haskellers.com/reverse
16:47:57 <robstewartuk> perfect cheers! :-)
16:48:37 * hackagebot applicative-quoters 0.1.0.6 - Quasiquoters for idiom brackets and an applicative do-notation  http://hackage.haskell.org/package/applicative-quoters-0.1.0.6 (BenMillwood)
16:50:55 <monochrom> there is some contradiction between "I want to learn for real" and "I want to stay software"
16:52:32 <monochrom> at least with today's common software architectures. their whole point is to virtualize, to abstract, to shield you from real. all these OSes and device drivers and layers and APIs
16:53:03 <monochrom> the very three letters A P I has "shields you from real" written all over them
16:53:22 <monochrom> well, the I part already says that
16:53:37 * hackagebot applicative-quoters 0.1.0.7 - Quasiquoters for idiom brackets and an applicative do-notation  http://hackage.haskell.org/package/applicative-quoters-0.1.0.7 (BenMillwood)
16:56:59 * geekosaur is actually wondering if the right answer here is to point them at KA9Q :p
16:58:45 <badabing> so protocols like bittorrent and xmpp and VoiP, are they built on top of TCP/IP and sockets?
16:59:38 <maukd> bittorrent is built on top of http, pretty much
16:59:44 <maukd> hmm, no
16:59:48 <maukd> the tracker protocol is
17:00:16 <geekosaur> on TCP/IP, yes.  on sockets, ultimately so because that;s the OS interface, but sane programmers use higher level interfaces
17:00:28 <monochrom> bittorrent has several parts using several things
17:00:39 <badabing> but http is built on tcp ip
17:00:48 <parcs`> there's a udp bittorrent tracker protocol too
17:00:58 <rwbarton> voip probably works over udp I would think?
17:01:09 <geekosaur> generally
17:01:24 <badabing> but udp doesnt guarantee delivery!
17:01:28 <geekosaur> it's not a protocol where you want stalling because of a dropped packet, it's better to soldier on
17:01:31 <monochrom> let me just talk about what I know. smtp, pop, and imap are on top of tcp
17:01:42 <rwbarton> nothing can guarantee delivery
17:01:45 <maukd> http is not built on tcp/ip
17:01:50 <maukd> http is on data streams
17:02:02 <maukd> it's just that tcp provides streams over the internet
17:02:06 <rwbarton> the question is what do you do when delivery fails
17:02:17 <badabing> how funny if a phone conversation didnt end up in the right order ;)
17:02:21 <monochrom> irc is on top of tcp too
17:03:55 <monochrom> you should study both tanenbaum's book (or equivalent) and stevens's book. in any order you like. also, expect to take 4-8 months
17:04:22 <badabing> 4-8 months of free time study?
17:05:12 <monochrom> that is, general knowledge of computer networks, and details of tcp/ip implementation
17:05:34 <monochrom> it's 4-8 months for a full-time university student
17:05:42 --- mode: ChanServ set +o maukd
17:05:43 --- mode: maukd set -b *!~soe@*
17:05:51 <monochrom> the slower students, maybe years or never
17:06:23 --- mode: maukd set -o maukd
17:08:20 <badabing> ok i look at uni courses and they are 2 months part time. so then you get nowhere?
17:09:46 <monochrom> 2 months part time sounds too short to be good
17:11:04 <monochrom> when I was in school, it was 3 consecutive courses, altogether about 8 months. and that was only good for the general knowledge part (you may call it "theory"). no practical implementation detail
17:11:22 <badabing> what uni?
17:11:31 <monochrom> city university of hong kong
17:11:57 <badabing> are you born there or you studied as a foreign student?
17:12:03 <monochrom> born there
17:12:10 <badabing> i have a friend going there next semester
17:12:11 <monochrom> (why?)
17:12:22 <badabing> you still live there?
17:12:29 <monochrom> no
17:12:34 <badabing> it is a very interesting place
17:12:36 <badabing> to small?
17:13:49 <badabing> what is the stevens guys full name?
17:14:03 <geekosaur> W. Richard Stevens
17:14:31 <monochrom> the books are "TCP/IP Illustrated"
17:15:09 <startling> oh, that's an excellent book
17:15:14 <monochrom> oh, not just that, also "unix network programming"
17:15:19 <startling> the one with the pixellated meerkat?
17:15:39 <pnielsen> are list subscription requests moderated now?
17:15:54 <monochrom> depends
17:15:55 <pnielsen> I've been trying to subscribe, both via interface and email, for 3 weeks now
17:16:02 <pnielsen> with a new email
17:16:10 <pnielsen> no answer whatsoever
17:16:34 <pnielsen> haskell, haskell-cafe
17:18:10 <monochrom> I don't think they are human-moderated
17:18:38 * hackagebot bindings-sane 0.0 - FFI bindings to libsane  http://hackage.haskell.org/package/bindings-sane-0.0 (ClintAdams)
17:18:40 * hackagebot tagged 0.4.3 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.4.3 (EdwardKmett)
17:18:57 <edwardk> (enabled polykind support for 7.6.1)
17:27:47 <maukd> Timestamp -> M.Map Target Timestamp -> [(Target, Message)] -> Either (Maybe NominalDiffTime) (Message, M.Map Target Timestamp, [(Target, Message)])
17:27:50 <maukd> this is disgusting
17:31:41 <Cale> Either maybe a nominal difference in times, or ...
17:32:05 <ddarius> Either (Maybe a) NominalTimeDifference
17:32:28 <shachaf> ddarius: 17:27 <maukd> Timestamp -> M.Map Target Timestamp -> [(Target, Message)] -> Either (Maybe NominalDiffTime) (Message, M.Map Target Timestamp, [(Target, Message)])
17:33:07 <avpx> type synonyms are your friend here, IMO
17:33:25 <maukd> indeed, otherwise you'd see a lot more S.ByteStrings in there
17:33:25 <shachaf> I doubt type synonyms are the answer.
17:41:34 <MostAwesomeDude> Hey, I need a dependent-type sort of thing. I have data Vertex = Vertex Integer Integer; data Box = Box Vertex Vertex -- and I want to guarantee that the second vertex is always greater than the first vertex.
17:41:47 <MostAwesomeDude> Do I need a fully dependent type for this, or is there some hack which I'm not aware of?
17:42:08 <ivanm> MostAwesomeDude: smart constructors
17:42:26 <MostAwesomeDude> ivanm: But there's no type-level guarantee I can craft?
17:42:44 <hpc> MostAwesomeDude: only if you secretly hate yourself :P
17:42:48 <ivanm> MostAwesomeDude: maybe with type-level Integers if you can assign some Vertex -> Integer mapping
17:42:48 <sipa> not unless you're ready to use type-level naturals
17:43:16 <hpc> you can encode integers with type-level nats, then use those
17:43:23 <shachaf> MostAwesomeDude: This problem is similar to wanting an unordered pair of "Vertex"es.
17:43:48 <MostAwesomeDude> So IOW not without lots of self-loathing.
17:43:55 <ivanm> shachaf: unordered? do you mean ordered?
17:44:17 <ivanm> MostAwesomeDude: the type-level natural stuff is relatively new, so if you're not really familiar with it you might want to wait a couple of GHC versions
17:44:24 <shachaf> ivanm: You know, not ordered.
17:44:45 <ivanm> shachaf: how is what he wants similar to wanting them unordered? with unordered, is there any restrictions?
17:45:28 <MostAwesomeDude> Well, I guess for now I'll just be careful with how I build things.
17:45:30 <shachaf> ivanm: An unordered pair of naturals numbers, for example, is almost the same thing as an ordered pair of natural numbers where the first number is smaller than the second.
17:45:53 <MostAwesomeDude> I've got a big chunk of lenses that operate on Boxes, and I don't wanna annotate every single one with this check. (Although I guess I could...)
17:46:06 <edwardk> MostAwesomeDude: ?
17:46:20 <ivanm> edwardk: was it the word "lenses" that got your attention?
17:46:23 <MostAwesomeDude> Probably.
17:46:32 <edwardk> ivanm: probably
17:46:40 <ivanm> shachaf: but how does that relate to encoding the < in the type system?
17:46:47 <ivanm> or am I missing something from your explanation?
17:47:13 <shachaf> ivanm: What I actually mean is ≤, not <.
17:47:23 <shachaf> ivanm: But it has the same number of inhabitants, right?
17:47:44 <ivanm> yes
17:47:48 <shachaf> If you had an unordered pair of naturals, you could treat it as an ordered-pair-where-the-first-is-smaller.
17:47:57 <ivanm> sure
17:48:06 <shachaf> For example "fst" would be "min".
17:48:28 <shachaf> Anyway the point is "talking about unordered pairs in the type system is hard, so talking about this is probably hard too".
17:48:34 <ivanm> shachaf: oh, wait, are you saying to have a 2-element set?
17:48:49 <ivanm> I thought you just meant (a,b) and you don't know whether a >= b or b > a
17:48:59 <MostAwesomeDude> How expensive would it be to tag each Box as being either valid or invalid: data Box = BadBox ... | GoodBox ... -- and then do the conversion only when needed? Or maybe two types? data BadBox = ...; data Box = ...;
17:49:08 <shachaf> ivanm: Yes, that's what an unordered pair is. :-)
17:49:19 <shachaf> MostAwesomeDude: That seems really hacky.
17:49:23 <MostAwesomeDude> Kind of like how people do dirty/clean data in templating.
17:49:25 <ivanm> shachaf: OK, what you were saying makes more sense now :)
17:49:27 <MostAwesomeDude> shachaf: Yeah, it does.
17:49:36 <ivanm> I was thinking un-ordered in the Ord sense *facepalm*
17:49:38 <shachaf> MostAwesomeDude: Dirty/clean data is very different.
17:49:42 <ivanm> MostAwesomeDude: GADTs?
17:49:46 <shachaf> ivanm: Oh. No, not that.
17:49:52 <shachaf> ivanm: You can all it doubly-ordered, I guess.
17:49:56 <ivanm> *nod*
17:50:02 <shachaf> It's an "Ord"ered ordered pair!
17:50:25 <ivanm> shachaf: which is even more embarassing considering that I need to encode unordered pairs using ordered "pairs" for graph implementations :p
17:50:38 <MostAwesomeDude> ivanm: I'm trying to stay away from GADTs except in cases where there's no other solution. I don't mind lots of types.
17:50:54 <ivanm> MostAwesomeDude: I believe GADTs are the usual solution to the "I don't know if this thing is verified or not"
17:51:21 <shachaf> ivanm: You can call the greengrocer and place an order. That'll convert their unordered pears into ordered pears!
17:51:41 <shachaf> MostAwesomeDude: GADTs are good. :-(
17:52:02 <shachaf> MostAwesomeDude: Certainly a phantom type would be a better way of doing what you're suggesting than BadBox | GoodBox.
17:52:09 <ivanm> *groan*
17:52:14 <ivanm> @slap shachaf
17:52:14 * lambdabot orders her trained monkeys to punch shachaf
17:52:25 <ivanm> @remember shachaf You can call the greengrocer and place an order. That'll convert their unordered pears into ordered pears!
17:52:25 <lambdabot> It is stored.
17:52:49 <MostAwesomeDude> shachaf: Yeah, I was thinking of using Tagged.
17:53:09 <shachaf> MostAwesomeDude: But even nicer would be never to have invalid data.
17:53:17 <ivanm> MostAwesomeDude: but then you can't have a list of mixed values
17:53:18 <MostAwesomeDude> shachaf: I know, right?! :3
17:53:40 <shachaf> MostAwesomeDude: ...Inhabiting your type, I mean.
17:53:45 <MostAwesomeDude> ivanm: I'm okay with that. I can't think of a time where I'd want to have a lot of Boxes and only be able to use some of them.
17:54:09 <MostAwesomeDude> shachaf: But I still can't have any dependent types in a GADT, right? So how would a GADT really help here?
17:55:00 <shachaf> What does a GADT have to do with it?
17:55:29 <shachaf> Is pandoc broken with GHC 7.6?
17:55:29 <MostAwesomeDude> Okay, let's try again. So if I went the GADT route, how would that help, exactly?
17:56:10 <ivanm> MostAwesomeDude: you were asking about having tagged values as to validity
17:56:21 <ivanm> instead of encoding the constraint in the type system
17:58:26 <MostAwesomeDude> ivanm: Hm. I'm trying to picture the data type.
17:58:43 <ivanm> @google haskell gadt string dirty
17:58:45 <lambdabot> http://www.haskell.org/haskellwiki/GADT
17:58:45 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
18:01:35 <MostAwesomeDude> Hm, data Box v v valid where Box :: v -> v -> Box v v True; BadBox :: v -> v -> Box v v False -- or something like that?
18:04:08 <ivanm> well, you can't use True/False IIUC
18:04:21 <shachaf> You can use True/False with -XDataKinds.
18:04:27 <ivanm> oh, right
18:04:48 <shachaf> Er, but it wouldn't "Box v v valid"
18:05:14 <shachaf> data Box v (valid::Bool) where Box :: v -> v -> Box v True; BadBox :: v -> v -> Box v False
18:05:18 <shachaf> Or something.
18:06:37 <MostAwesomeDude> This doesn't seem that different from, say, Tagged GoodBox (Box v) or another phantom type solution.
18:07:06 <shachaf> That's exactly a phantom type solution.
18:07:47 <ivanm> shachaf: do you even need the True/False there, as you can distinguish by constructor?
18:07:58 <ivanm> or whatever the GADT term is for the Box/BadBox
18:08:30 <MostAwesomeDude> So what kind of runtime overhead would I see for this? I dunno if it's obvious, but this is a game, so I don't wanna commit to something hilariously spendy.
18:08:57 <MostAwesomeDude> I imagine it'd be roughly the same as checking vertex validity every time I use a box, right?
18:09:05 <shachaf> Phantom types don't have any runtime overhead.
18:09:05 <ivanm> depends how you're doing it
18:09:12 <shachaf> The sum type will have overhead, certainly.
18:09:19 * shachaf isn't sure what MostAwesomeDude is doing anymore.
18:09:25 <ivanm> but as someone said earlier, your best bet is to ensure that you always create valid boxes to begin with :)
18:09:54 <wds> hi all
18:09:59 <aupif> hello, all.
18:10:02 <wds> :)
18:10:05 * ivanm waves idly in wds' general direction
18:10:06 <wds> I just installed haskell
18:10:16 <wds> it's great
18:10:27 <shachaf> jaspervd1: Is blaze-* supposed to not work with bytestring-0.10?
18:10:29 <wds> so wanted to drop in and say hi / thanks
18:11:02 <MostAwesomeDude> ivanm: Well, let's say I have a good, valid Box with a width of 10, but then I decide to shrink its width by 10 later on for some reason. Now it's got width 0 and it's invalid. I'd have to perform that check when I revalidate it, I guess.
18:11:22 <liyang> shachaf: jaspervd1 is on holiday right now.
18:11:42 <MostAwesomeDude> And then I'd have to figure out how I care to handle bad boxes; it would defeat the point if I wrote fixBox :: Tagged BadBox (Box v) -> Tagged GoodBox (Box v)
18:11:43 <ivanm> MostAwesomeDude: sure, use a Maybe around the shrinking with mapMaybe or something
18:11:49 <shachaf> liyang: Ah.
18:11:51 <ivanm> shachaf: does bytestring-0.10 have the new builder?
18:12:00 <ivanm> since it's not on hackage and I don't have 7.6 installed I can't tell
18:12:08 <shachaf> ivanm: I don't know.
18:12:11 <aupif> shachaf! omg, what up bro? We met at thet stripe hackathon.
18:12:24 <aupif> I was the guy working with stephen balaban
18:12:47 <shachaf> aupif: Oh, hi!
18:12:54 <MostAwesomeDude> Okay, thanks guys. I'm gonna mosey off to dinner and mull over this some more. Now that I know dependent types, the non-dependent solutions feel so...inelegant. Guess that's life, huh?
18:13:50 <Jafet> Welcome to the more elegant age.
18:14:00 <shachaf> Those who would give up essential type independence for a little temporary type safety deserve neither independence nor safety.
18:14:28 <MostAwesomeDude> Quoted.
18:14:31 <shachaf> aupif: Are you doing Haskell things these days?
18:14:49 <ivanm> shachaf: what do you mean by "essential type independence"?
18:15:05 <liyang> @remember shachaf Those who would give up essential type independence for a little temporary type safety deserve neither independence nor safety.
18:15:05 <lambdabot> Done.
18:15:14 <Jello_Raptor> hmm, is there some way in a pattern match to get labels for the first element, second element and the tail of an array?
18:15:31 <ivanm> Jello_Raptor: "labels" ?
18:15:33 <Jello_Raptor> (including the second element)
18:15:43 <copumpkin> liyang: have you converted tsuru to agda yet?
18:15:43 <ivanm> Jello_Raptor: but unless you convert to a list, you can't pattern match an array AFAIK...
18:15:43 <Jello_Raptor> capital all@(x:xs) =
18:15:57 <Jello_Raptor> like all, x, and xs in that
18:16:03 <shachaf> Jello_Raptor: all@(x:xs@(x':xs'))
18:16:08 <liyang> copumpkin: 'fraid not. We actually need the code to run, not just typecheck. :(
18:16:09 <shachaf> Except please with better names.
18:16:18 * ivanm seconds shachaf's plea
18:16:29 <copumpkin> liyang: damn. Can't you make lots of money by just normalizing terms in the typechecker?
18:16:30 <aristid> indeed, this is better: as@(b:bs@(c:cs))
18:16:42 <aupif> shachaf: yep, I started just solving a bunch of things of project euler with Haskell, and now I'm just trying to find a cool project to work on
18:16:48 <shachaf> a@(a':a''@(a''':a''''))
18:16:57 <aristid> shachaf: that's good too
18:17:10 <copumpkin> data BuyHighSellLow : Strategy -> Set where ...
18:17:10 <liyang> copumpkin: we might be able to prove it, but that's not quite the same thing is it…
18:17:11 <aupif> shachaf: I took a break and did lisp for a while so I could give that a proper chance, but I like Haskell way more.
18:17:21 <copumpkin> runStrategy : forall s -> BuyHighSellLow s -> IO ()
18:17:40 <shachaf> runStrategy _ _ = return ()
18:17:41 <copumpkin> whoops, \top
18:17:46 <aupif> shachaf: currently, I'm just learning how to deal with cabal :(
18:17:47 <shachaf> Formally proved!
18:18:00 <shachaf> You don't deal with cabal. Cabal deals with you.
18:18:17 <MostAwesomeDude> Oh, one more thing: If somebody tries to call a function with bad data, and there's no useful thing to return there, is there a way I could blame my caller for passing bad data?
18:18:21 <aupif> shachaf: what are you working on these days? still strace?
18:18:33 <edwardk> aupif: write a haskell compiler. its what all the cool kids do to learn the language.
18:18:34 <copumpkin> liyang: oh well, maybe next year when Agda becomes even more awesomer
18:18:40 * hackagebot linear 0.2 - Linear Algebra  http://hackage.haskell.org/package/linear-0.2 (EdwardKmett)
18:18:44 <liyang> copumpkin: definitely!
18:18:48 <shachaf> aupif: Hah, I didn't end up doing that much with that. I should get back to it.
18:19:04 <copumpkin> whoa, edwardk and linear algebra now
18:19:08 <ivanm> MostAwesomeDude: return a Maybe?
18:19:09 <djahandarie> Oh man, edwardk is doing linear algebra now too?
18:19:11 <copumpkin> is there anything he will not do
18:19:14 <aupif> edwardk: where should I start? Have you done it?
18:19:17 <MostAwesomeDude> ivanm: I guess that'll have to do.
18:19:18 <ivanm> copumpkin: documentation? :p
18:19:24 <copumpkin> ivanm: you clearly haven't seen his more recent work
18:19:31 <copumpkin> docs up the wazoo
18:19:34 <ivanm> oh, right, he's started
18:19:41 <copumpkin> I have to sift through the human crap to read the types
18:19:46 <edwardk> djahandarie: i've had the lib for a while. but it was originally part of 'physics'. acowley asked me to break it out and has been using a lot of the quaternion and plucker space stuff
18:19:47 <ivanm> copumpkin: OK, making his libraries useable by the average haskeller? ;)
18:20:31 <edwardk> aupif: well, writing a type checker/interpreter exposes you to a lot of haskell. you learn how to use parsing libraries, how to think about unification, which is just generally useful when you start reasoning about other haskell code, etc.
18:20:32 <copumpkin> "X can't be bothered to learn Y, so Y should be less awesome to make it easier for X to not learn"
18:20:43 <copumpkin> ivanm: like that, you mean?
18:21:14 <ivanm> copumpkin: I admittedly haven't looked at his latest stuff to see said documentation, but I kept getting confused in the past whenever edwardk tried telling me about his libraries :)
18:21:19 <edwardk> aupif: the main place i would start is with benjamin pierce's book "types and programming languages". the examples in his book are all in ML, but transcoding them to haskell can be quite a learning exercise
18:21:29 <ivanm> so I was aiming more at tutorials, etc. which might very well already be in his documentation
18:21:38 <copumpkin> he even has UML diagrams!
18:21:41 <shachaf> I've never written a type checker! I should do that.
18:21:42 <copumpkin> I bet you haven't seen those before in haskell
18:21:59 <ivanm> copumpkin: ZOMG! :o
18:22:04 <djahandarie> I need to do some crazy UML diagrams for my classes this semester.
18:22:12 <ivanm> copumpkin: I thought UML was only for OO!
18:22:17 <djahandarie> UML diagrams 'up the wazoo' as copumpkin would say.
18:22:25 * copumpkin bows
18:22:34 <sabalaba> aupif: heyo
18:22:37 <copumpkin> anyway, back to being productive
18:22:38 <edwardk> ivanm: skim the readme, wiki and haddocks of https://github.com/ekmett/lens  http://ekmett.github.com/lens/
18:22:41 <copumpkin> have fun y'all
18:22:43 <aupif> sabalaba: sup, bro
18:23:05 <aupif> edwardk: k, that book sounds good. I'll check it out. Thanks for the suggestion.
18:23:08 <ivanm> ZOMG!
18:23:09 <zungaloca> it is possible to make a function return two values at the same time
18:23:17 <avpx> zungaloca: You can return a pair of values
18:23:20 <ivanm> edwardk: who are you, and what have you done with the real edwardk???
18:23:34 <edwardk> ivanm: i've even gone back and started documenting old packages, adding doctests, test suites, benchmarks, etc.
18:23:36 <copumpkin> I was just asking him that today at work
18:23:48 <shachaf> edwardk: But not trifecta, eh?
18:24:10 <shachaf> sabalaba: I got back to Palo Alto today, by the way.
18:24:12 <edwardk> shachaf: actually trifecta is on the short list to do soon. we started rewriting parts of our compiler in haskell. ;)
18:24:21 <zungaloca> func x xs = minimum x maximum xs
18:24:21 <zungaloca> ??
18:24:25 <ivanm> edwardk: wait, you aren't dying, are you? :o
18:24:31 <shachaf> zungaloca: (minimum x,maximum x)?
18:24:46 <edwardk> ivanm: not that i know of, but that could explain this strange documentation instinct
18:24:51 <ivanm> heh
18:24:59 <aupif> edwardk: what are you working on nowadays, then?
18:25:01 <ivanm> OK, have you been visited by any ghosts late at night then? ;)
18:25:10 <zungaloca> sweet THNX
18:25:11 <sabalaba> shachaf: cool, I might be down there later this week.
18:25:32 <shachaf> sabalaba: bahaskell is at Stanford next week.
18:25:36 <ivanm> edwardk: I'd read more than the initial part of the lenses documentation on hackage if firefox would un-freeze... :/
18:25:40 <shachaf> (Couldn't figure out a venue in SF for this month.)
18:26:08 <shachaf> roconnor will be talking about something or other.
18:26:14 <polo> oh, hi there
18:26:31 <edwardk> aupif: i work on a lot of stuff. currently i'm building a rather large library for dealing with lenses and fairly generic ways to traverse data structures in haskell and on nice bindings to MPFR so i can use them for some fun models that arise in physics
18:27:16 <edwardk> ivanm: =P
18:27:49 <polo> well, where should a haskell newbie start?
18:27:50 <edwardk> aupif: http://github.com/ekmett gives a pretty good cross section of stuff i'm working on these days
18:28:02 <ivanm> @where LYAH
18:28:02 <lambdabot> http://www.learnyouahaskell.com/
18:28:06 <ivanm> polo: ^^ ?
18:28:16 <polo> oh, thank you
18:28:39 <edwardk> polo: learn you a haskell is a great resource. if you've done a lot of programming before you might also want to look at real world haskell
18:28:42 <edwardk> @where rwh
18:28:42 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:29:16 <polo> edwardk: actually I haven't. I'm a programming newbie and just entered a CS course in my uni
18:29:24 <ivanm> @where tutorials
18:29:24 <lambdabot> http://haskell.org/haskellwiki/Tutorials
18:29:25 <polo> lambdabot: thanks for that
18:29:40 <geekosaur> that could actually be a good thing, less to unlearn :)
18:30:17 <startling> do we know of anyone who learned haskell as their first language?
18:30:28 <liyang> Start with LYAH then. There's also Hutton's Programming in Haskell which is less informal.
18:30:32 <copumpkin> startling: I think dons did
18:30:38 <edwardk> startling: there have been a few people on here who did. i can't remember nicks off hand
18:30:42 <shachaf> _Programming in Haskell_ is great.
18:30:43 <polo> geekosaur: my uni requires us to learn C but I've been somewhat bummed out by it. Actually I've been thinking of leaving CS and going to law school for other reasons but I won't give up on programming.
18:31:16 <geekosaur> they start with C?  oy.  you get to learn low level and high level programming at the same time...
18:31:52 <edwardk> ivanm: any luck with firefox? =P
18:32:04 * liyang doesn't get commission for mentioning Programming in Haskell, just though he'd point out.
18:32:15 <ivanm> edwardk: crashed
18:32:17 <startling> did they do better or worse than people who had done imperative languages before?
18:32:29 <ivanm> trying to see if 15.0.1 builds yet (had problems with xulrunner the other day but didn't have time to patch)
18:32:33 <startling> polo, yeah, C is an especially bad language
18:32:35 <polo> I should learn C nevertheless, I plan on switching to linux
18:32:38 <ivanm> liyang: _sure_ you don't
18:33:15 <edwardk> sok, grahamhutton gets a commission when folks read Programming in Haskell, so its all good. ;)
18:33:18 <startling> polo: lots of people *should* learn C (it's useful) it's just painful
18:34:04 <avpx> IMO, programmers should get to know a lot of programming languages.
18:34:27 <avpx> C is a good language to know
18:35:19 <liyang> Yes, C is the universal assembly language.
18:35:32 <shachaf> C is not an assembly language at all.
18:35:40 <edwardk> clearly everyone should have to write 6502 assembly for years without any sort of structured editor. it builds character. worked for me. made me quite the character.
18:35:45 <maukd> assembly coders tend to suck at C
18:35:47 <geekosaur> C is useful because (a) most system APIs are ultimately written in C, so even if you're using them in a higher level language you';ll often run into stuff best explained by the low level interface, and (b) most kernels are written in C.  but it doesn;t even have first class strings
18:35:57 <nand`> ghc-pkg: unrecognized option `--global-conf=/var/tmp/portage/dev-haskell/vec-0.9.9/temp/empty.conf' <- was this changed?
18:36:20 <polo_> connection timed out :(
18:36:31 <geekosaur> C is useful because (a) most system APIs are ultimately written in C, so even if you're using them in a higher level language you';ll often run into stuff best explained by the low level interface, and (b) most kernels are written in C.  but it doesn;t even have first class strings
18:36:39 <liyang> Well, it's the lowest-level language common (in both senses) to almost all architectures.
18:37:30 <geekosaur> edwardk, oh, does that explain how I turned out? :p
18:38:19 <liyang> edwardk: made you run away from that kind of work? I used to write DSP assembly for mobile multimedia…
18:38:43 <geekosaur> I suspect DSP assembly is somewhat saner.
18:39:17 <liyang> I suppose, mainly because people are actually expected to write a lot of it by hand.
18:39:25 <polo_> the "tryhaskell.org" tutorial is attractive
18:40:05 <edwardk> liyang: actually no. i stayed at a painfully low level for a long time, even did some chip design work to go lower, and then wandered back into that space when all the simd stuff started hitting mainstream cpus. now the only thing i tend to use it for is lots of lock-free data structure stuff
18:41:14 <polo_> what is the recommended IDE around these parts?
18:41:22 <ivanm> not to use one ;)
18:41:24 <edwardk> makes me appreciate the ability of languages like haskell to isolate you from those details
18:41:32 <ivanm> most people here tend to use Emacs or Vim
18:41:34 <edwardk> polo_: i use vim
18:41:42 <ivanm> there's also leksah, eclipsefp, some support in kdevelop, etc.
18:41:51 <ivanm> and some mystical IDE being developed by FP complete
18:42:01 <avpx> Hehe
18:42:02 <Lutin`> I could never get leksah to work in windows
18:42:09 <liyang> edwardk: definitely.
18:42:11 <parcs`> polo_: there is no de facto haskell ide. use whatever you're most comfortable with, or try out leksah and yi
18:42:40 <polo_> thank you
18:42:41 <liyang> polo_: vim or emacs has more uses than just editing Haskell code; worth learning in their own right.
18:42:58 <hamishmack> Lutin`: did you use the binary installler or build it yourelf?
18:43:03 <polo_> seems like I should try vim
18:43:10 <Lutin`> binary installer
18:43:16 <Lutin`> Which is probably why!
18:43:18 <Lutin`> lol
18:43:27 <hamishmack> Lutin`: Did you file a bug report?
18:43:29 <Lutin`> I mean it would run
18:43:37 <Lutin`> But I couldn't get the package viewer to work
18:43:46 <Lutin`> Or other such things
18:44:19 <Lutin`> Nah I spend most of my time in Linux anyways I just tried it because I don't have vim in windows
18:44:28 <hamishmack> Most ocommon causes of that are mismatching GHC versions and...
18:44:30 <Lutin`> And I don't want to deal with cygwin and everything
18:44:39 <maukd> Lutin`: why don't you just install vim?
18:44:42 <hamishmack> needing to run ghc-pkg recache
18:45:13 <Lutin`> Because I want vim and tmux and zsh :[
18:45:17 <YayMeie> oops typo in my name
18:45:20 <YayMeie> oh well
18:45:22 <maukd> 1 out of 3 isn't bad
18:45:46 <YayMeie> Is the actor model hard to get your head around?
18:45:51 <Lutin`> I don't boot into windows very often
18:46:17 <ivanm> YayMeie: I don't think the actor model is explicitly used all that much in Haskell
18:47:09 <hamishmack> Lutin`: Next time you do can you check that ghc version in your PATH matches the binary installer and see if ghc-pkg list is warning of issues
18:47:52 <hamishmack> Lutin`: if it is not one of those two things it would be great if you could file a bug report
18:49:40 <Lutin`> Well it installs
18:49:50 <YayMeie> ivanm: I never heard someone really talk about it with haskell, I was just asking in here because people here seem to know their shit
18:51:46 <YayMeie> I'm guessing it's not that hard, but curious for some input. Going to go poke around with erlang a bit I suppose to try and see if I can't get my head on it
18:55:19 <Lutin`> hamishmack: Yeah I think it's just the module browser
18:55:20 <Lutin`> Doesn't show imports
18:55:28 <Lutin`> Or anything under system
18:56:07 <Lutin`> I've tried ghc-pkg rebuild
18:56:30 <Lutin`> recache*
18:58:42 <hamishmack> Lutin`: What GHC are you using?
18:59:09 <Lutin`> Aha!
18:59:15 <Lutin`> It says packageInfo not found
18:59:25 <Lutin`> for all my packages
18:59:36 <Lutin`> 7.4.1
19:01:26 <hamishmack> Can you try this installer… http://leksah.org/packages/leksah-0.12.1.3-ghc-7.4.1.exe (if it is not the one you are already using)
19:01:55 <Lutin`> Ah I'm on 0.12.0.3
19:02:13 <Lutin`> But I did use the 7.4.1 installer. And I'll update it
19:03:39 <hamishmack> It might also be worth deleting your .leksah-0.12 directory to force a rebuild of all your metadata files
19:04:31 <Lutin`> I tried to run the rebuild metadata shortcut in the start menu
19:04:46 <Lutin`> He're I'll take this to #leksah
19:05:06 <YayMeie> somebody else using leksah, I thought I was the only person..
19:06:08 <casion> speaking of such, I'm new to haskell, is there any specific editor(s)/ide(s) people seem to favor?
19:06:09 <nand`> mtl has been removed from the GHC tree and replaced by transformers? What exactly does that mean, and what were the reasons? I'm curious
19:07:47 <startling> casion: lots of people (me included) use emacs and haskell-mode
19:08:01 <Lutin`> There's also haskellmode-vim
19:08:16 <ivanm> and leksah
19:08:18 <ivanm> and eclipsefp
19:08:23 <ivanm> and this is sounding familiar... :p
19:08:44 <ivanm> nand`: they no longer use the mtl package in GHC and use the transformers package presumably
19:08:50 <geekosaur> nand`: mtl1 was an older setup; transformers is a newer, more flexible one; and mtl2 was a transitional library to ease migration from mtl1 to transformers
19:08:57 <ivanm> as for reasons, maybe they didn't need the extra overhead?
19:09:05 <ivanm> geekosaur: ummm... mtl2 is more than just transformers
19:09:10 <ivanm> it also has the type classes
19:09:12 <hamishmack> YayMeie: You should hop on #leksah too it will increase our membership by 20% :-)
19:09:27 <Lutin`> http://www.reddit.com/r/haskell/comments/ts8fi/haskell_ides_emacs_vim_and_sublime_oh_my_opinions/c4p9vkq
19:10:21 <geekosaur> so if the mtl package is not being used, they also switched to the monads package?  (I'm assuming monads-fd lost the suffix?)
19:11:01 <Lutin`> Well there was mtl and trans
19:11:12 <Lutin`> And then I think they got unified somewhat
19:11:14 <dncr> is there a lib for lists that must be nonempty?
19:11:35 <parcs`> Data.List :)
19:11:41 <nand`> NonEmpty
19:12:01 <dncr> ah cool
19:13:38 <lpvb> how do I do the reverse of liftIO?
19:13:59 <lpvb> from IO a -> m a to m a -> IO
19:14:05 <shachaf> You don't.
19:14:11 <lpvb> O.O
19:14:21 <shachaf> Well, you have runFooT for specific transformers.
19:14:26 <shachaf> But that's a rather different thing.
19:14:40 <geekosaur> what would that do, anyway?
19:15:52 <geekosaur> if you have a MonadIO constraint on m, you can lift an IO action into it; how do you lift random monads into IO?  (it *can* be done in some cases but it involves wrapping the monad's run function around it, which can;t be automated as it's highly specific to each monad)
19:15:58 <rwbarton> funnily enough someone was asking about that a couple days ago
19:16:08 <rwbarton> then I found myself wanting it
19:16:18 <rwbarton> I don't even remember why any more though
19:16:33 <shachaf> "catch"?
19:16:37 <shachaf> Or anything that takes an IO action.
19:16:48 <geekosaur> so for example when I wrote stuff in gtk2hs I had wrappers to use with callbacks which ran my monad stack... but this required slinging the state around in an IORef so it would be updated appropriately)
19:16:56 <rwbarton> oh yeah. I just wanted it for m = Identity and m = IO
19:17:12 <shachaf> You wanted to turn IO a into Identity a?
19:17:18 <rwbarton> no
19:17:19 <YayMeie> casion: I like leksah being new to haskell it makes having a buildable set of files really easy so you can put off figuring out cabal files
19:17:27 <rwbarton> I wanted the opposite of liftIO, for m = Identity
19:17:33 <rwbarton> aka return
19:17:37 <rwbarton> (more or less)
19:17:42 <zungaloca> dont understand func x xs = [x*2|x<-xs]
19:17:42 <YayMeie> casion: Though truth is I haven't used any others
19:17:58 <shachaf> Oh, the opposite of liftIO.
19:18:02 <ivanm> zungaloca: the x in "func x xs" is useless
19:18:11 <ivanm> the [x*2 | x <- xs] is list comprehension
19:18:12 <rwbarton> basically I wanted a generalized interact-like function
19:18:13 <janiczek> can I have datatype with somehow bounded Int? like, [1..20]
19:18:14 <mietek> Hackage?
19:18:26 <geekosaur> hackage seems down from here
19:18:28 <geekosaur> :(
19:18:28 <shachaf> janiczek: Not easily.
19:18:29 <rwbarton> (Foo -> m Foo) -> IO ()
19:18:33 <ivanm> @where hackage-mirror
19:18:33 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
19:18:39 <zungaloca> oooo
19:18:48 <rwbarton> It was a bit silly really.
19:19:09 <YayMeie> are there any actor modules for haskell?
19:19:22 <ivanm> YayMeie: I believe so; part of cloud haskell maybe?
19:19:28 <ivanm> @google haskell actor model
19:19:29 <lambdabot> http://lstephen.wordpress.com/2007/09/08/the-actors-model-and-haskell/
19:19:29 <lambdabot> Title: The Actors Model and Haskell « lstephen
19:20:12 <geekosaur> rwbarton, generalized interact = MonadPrompt or er, what is the other one?  which I can';t check because hackage won't load for me.  monadcontrol?
19:20:29 <rwbarton> no, much more trivial than that
19:21:19 <rwbarton> I wanted to wrap a function on JSON values into a program, but the function may be pure or in IO
19:21:40 <rwbarton> my interact-like function taking care of (de)serialization
19:21:47 <shachaf> Oh, I see.
19:22:09 <shachaf> Isn't "return" the simple way of doing it?
19:22:10 <geekosaur> mm, I do not have access to my wrappers, they're on the external drive and I have no power source for it here :(
19:22:17 <rwbarton> yes
19:22:21 <Lutin`> Does anyone know how big hackage is?
19:22:31 <ivanm> Lutin`: about yay
19:22:45 <ivanm> *holds hands apart*
19:22:48 <geekosaur> ask luite?  but IIRC it's in the single-digit gigabytes
19:23:12 <Lutin`> Hmm
19:23:22 <Lutin`> WHat if we decentralized it somehow
19:23:39 <Lutin`> using P2P
19:23:45 <nand`> distributed file store? :)
19:23:48 <Lutin`> Yes
19:23:52 <ivanm> Lutin`: that's the plan with hackage 2
19:23:58 <ivanm> well, at least mirroring
19:24:16 <nand`> I wouldn't mind giving up some of my storage space for the great good
19:24:17 <ivanm> there have been talks of p2p and there were some torrents at one point IIRC
19:24:39 <nand`> (though my upwards bandwidth will probably limit how useful that will be)
19:24:41 <ivanm> hackage 2 allows for mirrors, and they're planning on migrating to it in the next few weeks if memory serves
19:27:51 <Lutin`> Hmmm
19:28:11 <Lutin`> What webserver does hackage use?
19:28:28 <Lutin`> and/or web library
19:28:32 <parcs`> hackage 2 uses happstack
19:31:59 <dncr> I'm using Parsec.  buildExpressionParser lets you parse nested expressions easily.  But now, in order to not backtrack in one case, I need to parse an expression based on the first sub expression being already parsed.  Any way to get a parseStartingFrom :: Expr -> Parser Expr?
19:33:42 <Lutin`> Ah
19:33:52 <Lutin`> It was Freenet I was thinking of
19:34:41 <null-> this is freenode
19:35:08 <MostAwesomeDude> Aw, hackage is down? :c
19:35:12 <Lutin`> I didn't mistype
19:35:27 <MostAwesomeDude> Oh, no, maybe I'm just doin' it wrong.
19:35:35 <Lutin`> no hackage is down
19:36:05 <dncr> it's quite down
19:36:07 <MostAwesomeDude> Aw. :c
19:36:08 <monochrom> ok, confirmed
19:36:11 --- mode: ChanServ set +o monochrom
19:36:14 <geekosaur> <ivanm> @where hackage-mirror
19:36:14 <geekosaur> <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
19:36:20 --- topic: set to '["hackage down","GHC 7.6.1 http://v.gd/CEBRVo ","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
19:36:29 --- mode: monochrom set -o monochrom
19:36:51 <dncr> http://doj.me/?url=hackage.haskell.com
19:37:02 <dncr> err org
19:37:21 <shachaf> monochrom: You should add a link to the mirror in the topic.
19:37:30 <shachaf> http://comonad.com/reader/2012/hackage-mirror/
19:38:05 <pharaun> oh its down :C
19:38:19 <shachaf> We need to do something about this Hackage thing.
19:38:48 <Lutin`> Changing that doesn't fix browsing it
19:38:54 <Lutin`> From da web
19:39:19 <dncr> at least you can get docs from a local install
19:41:54 <pharaun> why/what's the issue with hackage?
19:42:37 <Lutin`> It's centralized
19:43:05 <pharaun> that does not really answer why it goes down, just wondering what the story is, seems to be a routine thing
19:43:43 <Lutin`> Fair enough. I'm gonna reboot into linux I'm tired of windows :X
19:44:27 <hpaste> prototrout pasted “Can I get the fixpoint of a forall function?” at http://hpaste.org/74716
19:45:43 <hpaste> prototrout annotated “Can I get the fixpoint of a forall function?” with “Can I get the fixpoint of a forall function? (annotation)” at http://hpaste.org/74716#a74717
19:45:55 <lcc> will sicp help me to learn haskell?
19:46:37 <null-> yes
19:46:57 <lcc> will haskell help me to learn C?
19:47:09 <shachaf> prototrout: I don't think you can do it with regular "fix".
19:47:15 <null-> depends on your mom
19:47:40 <lcc> meaning thinking about things in a new way.
19:47:44 <shachaf> prototrout: You can say "canThisBeMadeToWork = bar canThisBeMadeToWork".
19:48:23 <null-> lcc: yeah, you will think/know new things about your mom
19:49:05 <prototrout> shachaf: Hmm, let me check if that works in the "real" code I'm working with.
19:49:28 <shachaf> prototrout: Note that that even that won't work unless you give an explicit type signature.
19:49:37 <null-> lcc: like you now will know why she liked the long long pointer so much
19:49:58 <lcc> wow
19:50:37 <prototrout> shachaf: Aha, I was about to tell you it wouldn't work. Do you know if there's a type-specialized version of fix which will work for that?
19:51:51 <shachaf> prototrout: canThisBeMadeToWork absolutely can't have a type signature?
19:53:06 <prototrout> shachaf: It can, I was just curious. (Editing my code to see if it works at the moment.)
19:53:08 <shachaf> prototrout: If you specialize "fix" enough it can be made to work.
19:53:25 <shachaf> prototrout: E.g. "fixy :: forall f. ((forall a. f a -> a) -> (forall a. f a -> a)) -> (forall a. f a -> a)" would certainly work. :-)
19:53:54 <monochrom> impredicative polymorphism would allow you to go from "fix :: (t -> t) -> t" to "((forall a. ...) -> (forall a. ...)) -> (forall a. ...)". however, GHC doesn't do impredicative polymorphism
19:54:19 <shachaf> Why doesn't it?
19:54:23 <Lutin`> -XImpredicativeTypes
19:54:53 <monochrom> they tried. it was too hard to have it alongside with all the other much more wanted extensions. they gave up
19:55:03 <Lutin`> OH that was ghc 6.10.1
19:55:12 <monochrom> so, some old version of GHC work for it, actually
19:57:17 <lpvb> lol null-
20:02:00 <hpaste> applicative annotated “Can I get the fixpoint of a forall function?” with “Can I get the fixpoint etc” at http://hpaste.org/74716#a74718
20:02:29 <applicative> prototrout: here's a dubious attempt ^^^
20:02:30 <lambdabot> applicative: You have 1 new message. '/msg lambdabot @messages' to read it.
20:03:05 <prototrout> shachaf: Thanks, that worked in the real code as well!
20:03:09 <prototrout> applicative: Looking at it now.
20:03:19 <shachaf> applicative: That seems rather more complicated...
20:03:32 <applicative> shachaf: ha, yes
20:04:06 <applicative> shachaf: I wondered if the type of fix was too narrow, as I see it is from fixy
20:05:31 <applicative> This wrapping doesn't work if you use a record type to do the song and dance; I guess one could have guessed that
20:06:44 <Lutin`> my question is what all would first-order polymorphism mess us/
20:06:47 <Lutin`> up*
20:07:12 <Lutin`> i.e. why can't we have it lol
20:07:38 <shachaf> @brain
20:07:38 <lambdabot> Uh, I think so Brain, but this time, you wear the tutu.
20:09:45 <monochrom> the type of fix is not too narrow. rather, the meaning of "forall t. ... t ..." is, i.e., can t be instantiated to yet another polymorphic type?
20:10:29 <applicative> monochrom: right, It wasn't the right way to put it
20:10:55 <monochrom> if you say yes, you get many interesting and intuitive benefits, but also many interesting and counterintuitive problems and/or costs
20:11:35 <monochrom> and I forgot what problems
20:12:25 <Lutin`> shachaf: I meant to say first-class
20:12:28 <Lutin`> Not first-order
20:13:43 <Lutin`> Ah it's that Hindley-Miller doesn't directly work on it
20:14:12 <Lutin`> Milner*
20:16:57 <Lutin`> So wait isn't first-class polymorphism basically saying we can have a kind (* -> *) -> *
20:17:49 <copumpkin> first-class polymorphism?
20:17:53 <copumpkin> clearly that's dependent types
20:18:14 <Lutin`> Impredicative polymorphism
20:18:37 <Lutin`> I.E. type variables can be polymorphic types
20:20:20 <Lutin`> Ah okay I just didn't know enough about Hindley-Milner is all
20:20:29 <applicative> (* -> *) -> * is a good kind.  data F :: (* -> *) -> * where  F ::  F f ; deriving instance Show (F f)  -- even
20:21:43 <Lutin`> Yeah that's not what I meant now that I think about it
20:22:13 <Lutin`> I was thinking what monochrom was saying
20:22:20 <applicative> lennart a discussed it somewhere
20:22:26 <applicative> http://augustss.blogspot.com/2011/07/impredicative-polymorphism-use-case-in.html
20:23:01 <applicative> he wanted things like var :: RValue a -> IO (forall lr. LR lr => lr a)
20:23:33 <Lutin`> Yes
20:24:46 <dolio> First-class polymorphism means that types with quantifiers are usable in the same ways as other types.
20:24:48 <Lutin`> Because of Hindley-Milner you can only instantiate quantified variables with monomorphic types
20:25:47 <Lutin`> Oh wait this paper is from '07 :X
20:28:22 <Lutin`> nonetheless a good read
20:28:23 <Lutin`> http://goo.gl/FsLGH
20:31:01 <pharaun> what about these guys -> http://hackage.haskell.biz/
20:33:10 <Lutin`> 4 clicks!
20:33:33 <Lutin`> Woah what you can do http://goo.gl/FsLGH.qr
20:33:39 <Lutin`> And it gives you a QR code :O
21:19:58 <johnw> evening
21:22:57 <guidj0s> Is there any widely-adopted way of meaning `certainly (Just a) = a`?
21:23:58 <shachaf> guidj0s: ?
21:24:11 <johnw> fromJust?
21:24:16 <shachaf> You probably shouldn't be using a function like that even if you're sure something is Just.
21:24:45 <shachaf> Better to "let Just x = ..." than "let x = fromJust (...)", for instance.
21:24:45 <johnw> I prefer fromMaybe
21:25:27 * nand` uses fromMaybe often
21:25:38 * rwbarton uses let Just x = ... often
21:26:00 <shachaf> Or case ... of Just x -> ...
21:26:05 <nand`> even if I want an error, I'll do fromMaybe (error "nicer error message than ‘pattern match fail in line xyz’")
21:26:10 <johnw> or \case Just x -> :)
21:26:14 <rwbarton> particularly with pesky parser engine-specific Result types
21:26:24 * shachaf :-( at "\case"'s syntax.
21:26:31 <johnw> really?
21:26:35 <johnw> what don't you like?
21:26:56 <johnw> i'm kind of glad it's not \case of
21:26:56 <nand`> shachaf: I forgot, was it you who would have preferred “case of Just x -> ..” ?
21:29:53 <rwbarton> in this case (heh) you could just use \(Just x) -> ... right?
21:30:03 <rwbarton> lambda case allows multiple patterns?
21:30:19 <shachaf> It does.
21:30:43 <rwbarton> the syntax does look pretty goofy
21:31:06 <rwbarton> hmm
21:31:10 <rwbarton> @type (\False x -> ())
21:31:11 <lambdabot> forall t. Bool -> t -> ()
21:31:48 <rwbarton> I guess it's better to think of \case as a fancy lambda, rather than a fancy case
21:31:51 <shachaf> @
21:31:57 <shachaf> Hmm.
21:32:21 <johnw> MultiWayLambda
21:32:27 <rwbarton> yeah
21:32:41 <rwbarton> @type (\x y | x == y -> ())
21:32:42 <lambdabot> parse error on input `|'
21:32:57 <johnw> is there a library that supports Perl's notion of 'tainted' values?
21:33:10 <shachaf> Unfortunately it's not a multi-way lambda.
21:33:14 <shachaf> Because it only supports one argument.
21:33:31 <johnw> the main features are that all values from IO are tainted, you can only remove taint using a "bless" function, and you cannot pass tainted values to functions in IO
21:33:36 <rwbarton> right
21:34:09 <johnw> I'm thinking it should be easy to implement with the Identity Monad, but I'm wondering if something similar has already been done
21:34:20 <rwbarton> that's basically what it is yeah
21:34:32 <rwbarton> I think someone wrote a blog post about that in fact
21:34:40 <johnw> seems hackage is down again
21:35:14 <guidj0s> The question wasn't about the name, though I appreciate the insight. I merely wondered wether `unboxing` values constructed with Just had some widely-used form.
22:05:59 <johnw> edwardk: ping
22:06:06 <edwardk> pong
22:06:09 <johnw> hey!
22:06:13 <johnw> so, I'm using makeClassy
22:06:20 <johnw> and there are some accessors I want to keep private
22:06:31 <johnw> I don't export them, and this causes warnings from GHC about unused functions
22:06:45 <johnw> what do you do to silence those warnings?
22:06:48 <edwardk> use makeClassyFor and give them names that involve _'s
22:07:01 <edwardk> or just make sure you use them somewhere in the module
22:07:06 <johnw> ah, cool
22:07:21 <johnw> knew you'd have a good answer for that :)
22:07:55 <johnw> if I have two modules Foo.A and Foo.B, can I make a function from A accessible to B, but to no one else?
22:08:17 <edwardk> worst case you can use {-# OPTIONS_GHC -fno-warn-unused-binds #-}
22:09:01 <edwardk> not exactly. you can make 'other-modules' in your cabal file that give you unexported modules that you can use from your other modules but 3rd parties can't use it
22:09:05 <ivanm> johnw: don't export module Foo.A ?
22:09:21 <johnw> oh, my own code doesn't need exports?
22:09:26 <johnw> modules in the same directory have complete visibility?
22:09:37 <ivanm> johnw: modules in the same _package_ can import each other
22:09:39 <edwardk> you should put 'other-modules: ' in the cabal file
22:09:58 <ivanm> but it doesn't mean that people using your library can access every module
22:10:01 <ivanm> as edwardk is saying :)
22:10:07 <edwardk> and put the ones you aren't putting on the 'exposed-modules: ' in that
22:10:14 <johnw> well, I want users to be able to import Foo.A, and see function 'foo' but not 'bar'
22:10:24 <edwardk> if you don't do that you'll get errors when you go to upload to hackage
22:10:27 <ivanm> johnw: you'll need a third module then
22:10:27 <johnw> however, I want Foo.B to be able to import Foo.A, and see both 'foo' and 'bar'
22:10:42 <edwardk> johnw: make Foo.Internal, put all the defs in that, then export some of them through Foo.A
22:11:14 <edwardk> my usual rule of thumb is to actually expose the Internal modules, but not treat them according to the PVP
22:11:15 <johnw> and then put Foo.Internal on other-modules?
22:11:23 <edwardk> if you feel the need.
22:11:50 <edwardk> i try to expose things in such a way that i don't have any sneaky invariants i need to maintain like that ;)
22:11:57 <johnw> how to export all the lenses created for a type by makeClassy?
22:12:15 <edwardk> makeClassy will build a class, like HasFoo(..)
22:12:28 <johnw> it is prefix by Has?
22:12:32 <edwardk> by default
22:12:37 <johnw> very cool
22:12:42 <edwardk> makeClassyFor lets you rename it
22:12:52 <edwardk> so does makeLensesWith
22:17:34 <johnw> does HasFoo depend on the members being named _foo*?
22:18:00 <johnw> I have a class named Base, with _git*, but GHC is telling me that HasBase doesn't exist (even with makeClassy ''Base)?
22:19:48 <johnw> no, that's not it..
22:20:12 <johnw> oh, this is a parameterized type
22:26:53 <johnw> haskell is down hard
22:27:13 <johnw> i meant, hackage.haskell.org
22:27:36 <shachaf> @where hackage-mirror
22:27:36 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
22:27:54 <johnw> I have my own local mirror of the hackage packages
22:28:02 <shachaf> Is there any easy way to mirror Hackage?
22:28:06 <johnw> yes!
22:28:09 <shachaf> All of it, I mean, not just current versions of packages.
22:28:18 <johnw> no
22:28:29 <shachaf> luite: How do you do it?
22:28:39 <johnw> i have every version since the day I started
22:29:18 <johnw> shachaf: I'm using https://github.com/jamwt/mirror-hackage
22:30:27 <johnw> shachaf: I was wrong
22:30:30 <johnw> my mirror is complete
22:30:45 <johnw> I have the lens package from 0.1 to 2.9, about 40 versions
22:31:31 <shachaf> How big is it?
22:31:48 <shachaf> Note: expect to devote 10-15GB to your Hackage mirror as of 2012-08
22:31:58 <johnw> it's 6.75G, 49,425 files
22:32:11 <shachaf> That sounds smaller than 10-15GB
22:32:22 <johnw> it does
22:32:40 <johnw> oh
22:32:44 <johnw> that's real file size
22:32:55 <johnw> i.e., du --apparent-size
22:33:00 <johnw> just regular du reports 11G
22:33:22 <johnw> that's over 4G of slack
22:34:18 <spaceships> \quit
22:36:05 <pharaun> oh johnw btw that parmap solution you suggested, is eating up the ram, but i'm getting ~3.1GiB/s hashing speed
22:36:16 <johnw> how much of an increase is that?
22:36:20 <johnw> and how much ram does it eat?
22:36:32 <pharaun> the non-parmap was ~670MiB/s
22:36:42 <johnw> wow
22:36:46 <pharaun> considering my disks are saturated at 330MiB/s
22:37:06 <pharaun> as of ram, roughly the amount of the file size
22:37:17 <johnw> oh wow, that's worse than I suspected
22:37:19 <pharaun> i can probably play around with deepseq or bangpattern and see but i dunno how much can be done
22:37:23 <johnw> can I see your current code?
22:37:40 <johnw> it should only be using blockSize*threads
22:37:50 <pharaun> for now i tossed out the ed2k and am just doing raw md4 hashing, because the end-hash is the same as the ed2k stuff
22:38:02 <pharaun> and yeah sure, a few second
22:38:04 <johnw> show me show me show me show me
22:38:31 <hpaste> pharaun pasted “parmap hashing” at http://hpaste.org/74721
22:39:25 <johnw> oh, yeah
22:39:59 <johnw> so, each time getChunks is called, it returns a chunk, and a thunk to get the next chunk when requested
22:40:18 <johnw> that thunk holds a pointer to the remainder of the strict bytestring until you evaluate it
22:40:24 <pharaun> ahh right
22:41:17 <johnw> so right away it will read in the whole file, and then slowly free it up chunk by chunk
22:41:17 <pharaun> hmm i put a deepseq here -     let ctxs = parMap rseq (MD4.update MD4.init) (getChunks d $!! (9500*1024))
22:41:29 <johnw> that's only seqs the number
22:41:32 <pharaun> doh
22:41:40 <pharaun> yeah number don't need the seq :)
22:41:54 <johnw> and seq'ing 'd' is meaningless, it's already strict
22:42:11 <pharaun> yeah let me think i want to try to solve it :)
22:42:18 <johnw> ok
22:42:21 <shachaf> But what if you (d `seq` d)? :-)
22:42:31 <johnw> that's a noop
22:43:46 <johnw> because either the whole expression doesn't need to be evaluated, or if it does need to be evaluated, it will evaluate to the same degree that `seq` would
22:43:47 <shachaf> Success!
22:44:31 <johnw> it's like saying, If you need to evaluate me, make sure to evaluate me before you evaluate me :)
22:44:45 <pharaun> johnw: the ballooning is in getChunks?
22:44:53 <johnw> there is no ballooning
22:45:03 <johnw> S.readFile for strict bytestrings means: read the whole file
22:45:15 <pharaun> so nothing i can do about that ?
22:45:23 <pharaun> hmm
22:45:24 <johnw> try a lazy bytestring
22:45:29 <johnw> now that you're not using ed2k
22:47:59 <johnw> I wonder why I can't find lens on Hoogle
22:48:18 <edwardk> not sure how it builds the index, etc.
22:48:23 <MostAwesomeDude> Hoogle only indexes things that it cares about, from a small list of packages.
22:48:28 <johnw> i can find it on my local Hoogle
22:48:28 <MostAwesomeDude> It doesn't know about lens yet.
22:48:38 <johnw> ah
22:48:38 <ivanm> MostAwesomeDude: I believe it now indexes all of hackage, but defaults to HP only
22:48:43 <gienah_> \o/
22:48:45 <johnw> I hoogle data -l all
22:48:57 <ivanm> as for local version... nfi
22:49:01 <Gavilan2> Hi! Architectural/Design question: How do you handle information update in a big application... Like, you have a set of students, and courses, and student groups, etc... how do you handle "changing" the name of a student?
22:49:27 <ivanm> Gavilan2: depends on how you've set everything up
22:50:01 <Gavilan2> ivanm: What do you mean?
22:50:09 <mrotondo> Oh boy. Any thoughts on this runtime error I just got? "serverMain.hs: Static.get: type error: Cannot unify ByteString and ByteString. Failed reading at byte position 1024" I'm sending bytestrings from a 32-bit architecture (iPhone) to 64-bit (os x), but I'm not sure that's pertinent
22:50:16 <rwbarton> I doubt that lenses, data-lens, data-lens-fd, data-lens-ixset, data-lens-template, edit-lenses, edit-lenses-demo, partial-lens, pointless-lenses, and time-lens are all on the small list of packages hoogle cares about
22:50:21 <ivanm> Gavilan2: well, what do _you_ mean with your "big application" ?
22:50:37 <ivanm> Gavilan2: you haven't said how you've designed it
22:50:46 <ivanm> and your question is very hand-wavy
22:51:10 <edwardk> might just be that the hoogle server builds the packages itself and might be running an older ghc
22:51:11 <Gavilan2> ivanm: I mean that there are a lot of references to the student, so the "name change" should be consistent everywhere... After updating the name, you list the student groups, and the name should be updated there too
22:51:17 <edwardk> lens needs 7.2+
22:51:28 <ivanm> Gavilan2: sounds like your DB wasn't designed well
22:51:36 <ivanm> otherwise, do an atomic update of your system
22:51:48 <Gavilan2> ivanm: I don't mean using a db, but just memory....
22:51:59 <ivanm> Gavilan2: is this a) homework? b) anything to do with Haskell?
22:52:04 <rwbarton> ....
22:52:16 <rwbarton> this seems like a perfectly reasonable question
22:52:29 <Gavilan2> Gavilan2: It's not homework, it's not in haskell actually... But I'm working with immutable objects, so it seems like a good place to ask :)
22:52:39 <ivanm> rwbarton: you answer it then, because I don't get what he's asking
22:52:46 <Gavilan2> (Not a lot of ppl work with immutable things)
22:52:53 <johnw> Gavilan2: you make a new student based on the old one, with the new name
22:53:07 <johnw> Gavilan2: newStudent = oldStudent { studentName = newName }
22:53:10 <rwbarton> a common solution is to have your courses contain a list of student ids, and maintain a map of student ids to records about the students
22:53:37 <Gavilan2> johnw: and how do you make sure all "old instances" are replaced with the new instances? you do it by hand? who is responsible (Which module) for that?
22:53:37 <johnw> yeah, or what rwbarton said, make your data set relational
22:53:52 <mrotondo> Gavilan2: I was recently going through this same thought process. rwbarton has it, you need to split up the concepts of the _identity_ of the student (a persistent id) from the current _value_ of the student (which will be stored in a map or db or something)
22:54:12 <mrotondo> and everything else just references the id, as that's all they should really know about
22:54:19 <pharaun> hmm got it to be fully lazy but now i'm having the ages old lazy io issue
22:54:24 <pharaun> of open/closing on a file
22:54:27 <pharaun> hmm
22:54:35 <mrotondo> Gavilan2: rich hickey has some great talks about the difference between identity and value
22:54:43 <Gavilan2> mrotondo: Okay... Let's make another question then... Suppose I have some cached data, to speed up some things...
22:55:05 <Gavilan2> mrotondo: How do I make sure all my caches are considering this new "change"?
22:55:21 <Gavilan2> (I might have a cache with all the names of the students of a course for some reason)
22:55:50 <Gavilan2> My question is actually, how to tell notify all the system that there was a change, and how to make it respond accordingly in an easy way....
22:58:02 <mrotondo> right, you're basically describing a "reactive" system. once you've got everything set up so that students and classes have IDs, and classes are just lists of student IDs, and your actual class and student info are stored in maps from IDs to values, then you could create some reverse index from students to classes, and whenever you update a student's value in that Map, you can check which classes they are in via that index and rebuild
22:58:02 <mrotondo> your "class caches", which are lists of actual student values
22:58:34 <mrotondo> it's not reactive in the "time-based events" way, but you'll have handlers for certain kinds of updates
22:58:52 <pharaun> johnw: converted it to lazy, now running a benchmark will see, still has space leaks but i got a few ideas, may ask for help tho
22:59:30 <mrotondo> Gavilan2: did that make sense at all? I skimped on periods :)
23:00:38 <pharaun> interesting that pretty much destroyed performance
23:00:49 <johnw> how much memory did it use?
23:01:04 <pharaun> lower at start but still slowly growing over time up to 10gb, still not done
23:01:12 <johnw> yeah
23:01:15 <johnw> because it's not strict yet
23:01:19 <pharaun> so performance has dropped badly
23:01:26 <pharaun> yeah i put a putSTrLn in for now
23:01:31 <johnw> changes the rseq to rdeepseq
23:01:32 <rwbarton> you can also have your caches lazily evaluated
23:01:33 <pharaun> to force it to eval
23:01:38 <pharaun> johnw: rdeepseq? k
23:02:00 <Gavilan2> mrotondo: My problem is how to do that, in an elegant way...
23:02:38 <Gavilan2> It's a problem I've seen in many big systems, and I've never seen a solution I find adecuated...
23:02:52 <johnw> because what I think is happening is that the call to MD4.update is returning a thunk holding onto a chunk of the file
23:03:00 <pharaun> yeah
23:03:12 <johnw> your parMap is then building a list of thunks for you -- in parallel :)
23:03:29 <hpaste> pharaun pasted “lazy-bytestring with rdeepseq” at http://hpaste.org/74722
23:03:31 <johnw> so you need to make the evaluation of MD4.update strict
23:03:33 <mm_freak_> Gavilan2: could you summarize your problem?
23:03:53 <mm_freak_> (the backlog is too long)
23:03:59 <mrotondo> Gavilan2: I'd say change your code to use IDs and indexes (Maps) from IDs to values, and everything else should flow pretty smoothly from that. Also remember that just because you're storing the same "value" in multiple places doesn't mean you are taking up more memory, Haskell is smart :)
23:04:15 <johnw> IO (String) == IO String
23:04:18 <rwbarton> summary is "he has a graph and wants to rename vertices"
23:04:34 <mm_freak_> traverse, replace?
23:04:39 <johnw> pharaun: I don't think you want hashlazy
23:04:45 <johnw> or is that required for lazy bytestrings?
23:04:59 <pharaun> lazy bytestring -> strict bytestring hash
23:05:09 <ivanm> rwbarton: OK, I never got that from how he described it
23:05:23 <pharaun> unless i do some sort of toChunks to convert from lazy to strict but then i end up with [[]]'
23:05:35 <rwbarton> well the issue is just what data representation is appropriate so that you don't have to visit every edge when renaming a vertex
23:05:46 <pharaun> anyway i don't think its working quite right cos its hashing a 11gb in ~12.76uS according to criterion
23:06:21 <mm_freak_> in any case Gavilan2's problem sounds like he has a data structure and wants to traverse it
23:06:27 <johnw> haha
23:06:35 <ivanm> rwbarton: hence why I was asking him earlier how it was designed
23:06:42 <rwbarton> but that is his question
23:06:45 <rwbarton> how should it be designed
23:06:48 <ivanm> use IDs rather than meaningful values for nodes
23:06:57 <mm_freak_> why IDs?
23:07:01 <ivanm> rwbarton: definitely didn't get that; my impression was "I have a system, now how do I do this"
23:07:15 <ivanm> mm_freak_: so there's no meaning behind them so you should never need to change them
23:07:16 <rwbarton> < Gavilan2> Hi! Architectural/Design question:
23:08:04 <rwbarton> is why I assumed this
23:08:13 <mm_freak_> ivanm: i don't know the application, but that sounds like an arbitrary suggestion…  unless you have any reason to name items, the item can be identified by the entirety of information contained in it
23:09:12 <mm_freak_> IMO well-defined systems don't need identifiers…  identifiers are hacks
23:09:17 <ivanm> mm_freak_: sure; but my approach to dealing with graphs is to use arbitrary identifiers so you can manipulate the values at the nodes without needing to propogate changes in identifiers everywhere
23:09:32 <rwbarton> the reason is so that you can update the structure without having to traverse the entire thing...
23:09:37 <Gavilan2> mm_freak_: My problem is that when there is an update in the real world, a lot different parts of the system might need to "act"...
23:09:42 <ivanm> and rwbarton described his question being about changing the node values in a graph :)
23:09:49 <mm_freak_> Gavilan2: that's a reactive system
23:09:56 <rwbarton> more of a paraphrase or an analogous problem
23:10:05 <ivanm> rwbarton: *nod*
23:10:08 <Gavilan2> mm_freak_: My problem is how to design a system, so it's easy to inform every time one of those happens, and do it in an elegant, easy, way... which brings more solutions than problems...
23:10:21 <mm_freak_> Gavilan2: FRP
23:10:21 <hpaste> pharaun pasted “newest paste,” at http://hpaste.org/74723
23:10:24 <Gavilan2> mm_freak_: How to implement an effective and elegant reactive system then
23:10:34 <mm_freak_> Gavilan2: FRP (functional reactive programming)
23:10:34 <pharaun> johnw: ^ I've replaced hashlazy with a foldl'
23:10:40 <Gavilan2> mm_freak_: Fibre-reinforced plastic?
23:11:00 <Gavilan2> thanks, I'll read about that!
23:11:04 <ivanm> but it also sounded like Gavilan2 was talking about an in-memory DB
23:11:07 <pharaun> johnw: type checks and does not eat up any memory however it completes in 12uS on a 11gb file, i think that's a little... too fast :)
23:11:12 <johnw> hmm
23:11:16 <mm_freak_> Gavilan2: you mentioned it's not in haskell…  FRP is really ugly in other languages
23:11:26 <johnw> i think this is more complicated than necessary
23:11:35 <ivanm> mm_freak_: is it non-ugly in Haskell yet? ;-)
23:11:42 <mm_freak_> ivanm: yes
23:11:56 <johnw> i'd go back to what you that worked
23:11:56 <pharaun> johnw: the parallel map approach or the lazy -> strict thing for the hasher part?
23:12:07 <johnw> are you saying that just using rdeepseq had no effect?
23:12:12 <Gavilan2> mm_freak_: I just need to get my hands on the right idea... If it's the right idea, I'll be able to make a good implementation about it....
23:12:19 <mm_freak_> ivanm: i'm the proud inventor of the wire category and the author of netwire ;)
23:12:29 <ivanm> I know :)
23:12:36 <Gavilan2> mm_freak_: Do you know any simple yet powerfull sample source code of FRP?
23:12:43 <johnw> you shouldn't need a sub-fold
23:12:44 <mm_freak_> ivanm: darcs get http://darcs.ertes.de/netwire/
23:12:52 <ivanm> I admittedly haven't really looked at FRP since Conal first started posting stuff
23:12:54 <mm_freak_> to see non-ugly FRP in action =)
23:13:01 <pharaun> johnw: seems so, i just forced it by (do; a <- test3 filename; putStrLn a) and its now actually evaling it but its taking forever so the performance seems worse
23:13:05 <ivanm> mm_freak_: I hear more about apfelmus' stuff though; how does netwire compare?
23:13:22 <johnw> wait
23:13:22 <ivanm> though FRP seems rather useless for me with the stuff I tend to hack on :)
23:13:24 <pharaun> johnw: hm i'm just not sure how to do the lazy to strict, the MD4 api only takes strict
23:13:33 <johnw> you had a version that worked really fast, but used lots of mem
23:13:35 <mm_freak_> Gavilan2: well, first of all FRP is a concept, not a library, and there are many implementations
23:13:37 <pharaun> johnw: yes
23:13:44 <mm_freak_> Gavilan2: you would normally use an FRP /library/
23:13:48 <johnw> then the only change you made was from rseq -> rdeepseq, and it got slower?
23:13:54 <Gavilan2> mm_freak_: Do you know any good one to check?
23:14:00 <pharaun> johnw: no i converted it to lazy bytestring
23:14:03 <mm_freak_> ivanm: netwire is more powerful and faster…  reactive-banana on the other hand has a ready-made GUI library
23:14:10 <ivanm> *nod*
23:14:15 <pharaun> to try to address the memory thing because of readFile
23:14:16 <johnw> what happened when using lazy bs was your only change?
23:14:17 <ivanm> are there actually benchmarks about it being faster?
23:14:47 <mm_freak_> ivanm: only my own benchmark…  netwire gets well beyond 200 million FPS
23:14:49 <pharaun> johnw: it "ran" but it ran in 12uS but if i then print out the hash it then sits there forever eating up more and more memory at 100% on all cores
23:14:59 <johnw> can you e-mail me the whole current code again, back when it was really fast but read strictly?
23:15:02 <ivanm> mm_freak_: *nod*
23:15:05 <pharaun> johnw: sure
23:15:28 <mm_freak_> ivanm: in particular the main bottleneck is calculating the time delta using diffUTCTime
23:15:36 <ivanm> heh
23:15:46 <mrotondo> (Nobody has any clues about "type error: Cannot unify ByteString and ByteString. Failed reading at byte position 1024", huh?)
23:16:10 <ivanm> mrotondo: context?
23:16:40 <mrotondo> I'm sending bytestrings over the network, from a 32-bit to a 64-bit architecture. That's about all the context I can figure out right now with hackage down
23:16:44 <mm_freak_> ivanm: but performance isn't really the main advantage…  the main advantage is the wire category, where events can be encoded elegantly
23:16:55 <ivanm> mrotondo: as in source code, complete error message, etc. :)
23:17:14 <mm_freak_> ivanm: "pressed" . keyDown SpaceKey <|> "not pressed"
23:17:23 <mm_freak_> ivanm: yes, that's actual netwire 4 code =)
23:17:28 <mrotondo> it's a runtime error, and this is the full and only line of output (from the server, the 64-bit machine) "serverMain.hs: Static.get: type error: Cannot unify ByteString and ByteString. Failed reading at byte position 1024"
23:17:40 <ivanm> mm_freak_: I know that apfelmus seems to be pushing reactive-banana as a beginners FRP library; is netwire comporable to pick up?
23:17:49 <ivanm> and you're using a string as a function? :/
23:17:57 <ivanm> lemme guess, you're abusing OverloadedStrings?
23:18:02 <mm_freak_> ivanm: not yet…  i'm working on the tutorial
23:18:05 <mm_freak_> yes, i am
23:18:19 <mm_freak_> i'm also abusing Num:  10 + time + 3*noise
23:18:20 <mm_freak_> =)
23:18:36 <ivanm> mm_freak_: is it abuse in the sense of you're parsing the String, or just wrapping it into a function?
23:18:48 <mm_freak_> just wrapping…  the instances are sound
23:18:56 <mm_freak_> fromString = pure . fromString
23:18:57 <ivanm> ahhh, fair enough :)
23:19:06 <ivanm> I was worried you were doing something like mysql-simple :)
23:19:29 <ivanm> mrotondo: you don't have source?
23:19:39 <rwbarton> 10 + time + 3*noise doesn't even look like abuse to me.  too much physics maybe
23:19:56 <mm_freak_> yeah =)
23:20:02 <ivanm> mrotondo: at a guess, it could be strict vs lazy bytestrings...
23:20:15 <mm_freak_> 10 + (integral . (5 * time)) + 4*noise
23:20:23 <mm_freak_> perhaps that looks more like abuse ;)
23:20:26 <Gavilan2> mm_freak_: I'm reading about the FRP... My problem is how to define the network in an elegant non intrusive way....
23:20:36 <pharaun> johnw: sent :)
23:21:04 <mm_freak_> Gavilan2: "the network"?
23:21:09 <mrotondo> ivanm: I'm still digging through the source trying to figure out where the error is even coming from. Thanks for the tip. Another bit of context is that it totally works when the connection is from my computer to itself, the problem happens when it's between my phone & computer.
23:21:35 <ivanm> mm_freak_: considering that I was at one stage trying to abuse Num to let me do ` 0 [ Label "hi", Color (X11Color Blue) ] ' for Dot code, not really :p
23:21:51 <mm_freak_> ivanm: ;)
23:21:58 <mrotondo> I shouldn't be asking for help without more info, I was just baffled by "Cannot unify ByteString and ByteString" and thought maybe it was a recognizable type of error
23:22:01 <johnw> ok
23:22:04 <ivanm> mrotondo: I would start by grepping through the source of your app and also the libraries you use for the error message
23:22:08 <johnw> i'm rebuilding my Cabal universe just now
23:22:11 <ivanm> specifically "cannot unify"
23:22:12 <Gavilan2> mm_freak_: How to "produce" the events... and how to receive in the proper places... (And what are the proper places)
23:22:13 <johnw> so it'll be a while before I have any results
23:22:25 <mm_freak_> mrotondo: i didn't really follow, but note that there are two ByteString types
23:22:36 <mm_freak_> mrotondo: one is from Data.ByteString, the other from Data.ByteString.Lazy
23:22:42 <ivanm> because unless you're doing dynamic code compilation using plugins or something, I can't see that it's a type error issue from GHC...
23:23:18 <Gavilan2> thanks for your help!
23:23:20 <mrotondo> Okay, thanks
23:23:45 <mm_freak_> Gavilan2: you have a network of signal functions (wires)…  either your wires are monadic and you carry the events around implicitly or you actually pass them as signals…  events are wires that act like the identity wire, but my inhibit
23:23:58 <pharaun> johnw: heh np, i'll keep on playing around with it
23:24:17 <johnw> i'd get lazy bytestring working, without making any other changes
23:24:25 <johnw> then move on to the next problem
23:24:30 <pharaun> sure
23:24:48 <mm_freak_> Gavilan2: the tutorial is not yet finished, but you may want to fetch the netwire 4 repository and build with haddocks
23:25:10 <mm_freak_> then look into the docs for Control.Wire
23:25:12 <mrotondo> As a separate source of angst, does anyone know an ETA for hackage coming back up?
23:25:17 <mm_freak_> you'll find a quickstart tutorial there
23:25:17 <Hadaka> continuation of earlier questions - I have [(a, b)] and a -> IO c - and I want to map the list sequentially creating [(c, b)]
23:25:23 <johnw> mrotondo: lol
23:25:26 <johnw> you and me both
23:25:36 <ivanm> @where hackage-mirror
23:25:36 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
23:25:36 <johnw> until then:
23:25:45 <johnw> like how I timed that? :)
23:25:45 <Gavilan2> mm_freak_: Thanks! I was only looking for the idea... I'm actually "implementing" this in another language :)
23:25:46 <Hadaka> so basically, I want mapM on the first element of a pair in a list
23:26:11 <Hadaka> I am guessing arrows will come to my rescue again :-)
23:26:16 <mrotondo> johnw:
23:26:18 <mrotondo> :)
23:26:22 <shachaf> Hadaka: Why arrows?
23:27:02 <Hadaka> shachaf: because I got introduced to &&& last nite
23:27:02 <ivanm> Hadaka: mapM (first f) ?
23:27:11 <shachaf> Oh, that's just (->)
23:27:11 <mm_freak_> Gavilan2: netwire 4 will make you hate the other language ;)
23:27:23 <shachaf> Not "Arrows", just an arrow, and the boring one at that.
23:27:23 <mm_freak_> ivanm: if you add some Kleisli and runKleisli =)
23:27:33 <mm_freak_> or perhaps a 'join'
23:27:34 <Gavilan2> mm_freak_: I don't hate languages... I hate people....
23:27:38 <shachaf> I guess there's Kleisli.
23:27:53 <ivanm> mm_freak_: oh, right
23:28:22 <shachaf> @ty \f -> mapM (\(a,b) -> (,b) <$> f a )
23:28:23 <lambdabot> Illegal tuple section: use -XTupleSections
23:28:23 <ivanm> let f' (a,b) = do a' <- f a; return (a', b) in mapM f'
23:28:23 <ivanm> ;)
23:28:25 <shachaf> @ty \f -> mapM (\(a,b) -> (\x -> (x,b)) <$> f a )
23:28:26 <lambdabot> forall t t1 a (m :: * -> *). (Functor m, Monad m) => (t -> m a) -> [(t, t1)] -> m [(a, t1)]
23:28:38 <shachaf> Hadaka: You can do it like that.
23:28:44 <shachaf> (,b) is nice if you have tuplesections.
23:28:52 <shachaf> Oh, and there's something called "strength" which might help you.
23:29:01 <shachaf> But it's probably too obscure to actually use.
23:29:17 <paolino> hackage ?
23:29:19 <shachaf> That's "strength" as in "strong monad".
23:29:29 <shachaf> @where hackage-mirror (see topic)
23:29:29 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
23:29:48 <ivanm> shachaf: you don't like ((,) b) ?
23:29:49 <ivanm> wait, you need to flip it
23:29:49 <ivanm> and you don't like flip
23:29:50 <ivanm> but still, no Arrows
23:30:03 <shachaf> ivanm: (\x -> (x,b)) is much nicer than (flip (,) b)
23:30:12 <Hadaka> hrm
23:30:24 <Hadaka> I don't like anything which requires me to add -X something :(
23:30:47 <shachaf> OK, so don't use the TupleSectiosn version.
23:30:53 <shachaf> (But language extensions aren't so bad.)
23:31:58 <Hadaka> but yeah, thanks for the solution!
23:33:11 <startling> ugh, why isn't TupleSections in the language?
23:33:55 <johnw> can you section (:)?
23:34:01 <shachaf> Of course.
23:34:04 <johnw> > (:[a]) b
23:34:04 <shachaf> @quote eat.a.comment
23:34:04 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
23:34:05 <lambdabot>   [b,a]
23:34:28 <johnw> then why no tuple sections by the same measure?
23:34:37 <c_wraith> tuples aren't operators.
23:34:38 <shachaf> (,) isn't an operator.
23:34:39 <shachaf> (:) is.
23:34:46 <johnw> oh
23:34:58 <startling> johnw, (1, 2, 3) wouldn't work if tuples were operators
23:34:59 <Hadaka> (a,b,c)
23:35:34 <shachaf> tibbe: Did you hear that next week's bahaskell is in the south bay?
23:35:49 <shachaf> Also, we have roconnor.
23:36:02 <johnw> what are the dates and times?
23:36:09 <Nereid> so
23:36:17 <Nereid> I have no idea if what I'm doing is a good idea, but
23:36:18 <johnw> my business partner lives in Somerville
23:36:23 <Nereid> I installed ghc 7.6.1 on a fresh system
23:36:25 <Nereid> and uh
23:36:28 <shachaf> Wed, 19th, at 19:00.
23:36:33 <shachaf> johnw: This is "bay area", as in CA.
23:36:34 <Nereid> I'm trying to getting a working cabal-install.
23:36:34 <johnw> location?
23:36:46 <johnw> isn't bahaskell boston area haskell?
23:36:50 <shachaf> Nereid: Good luck. :-(
23:36:52 <ivanm> Nereid: the git version might
23:36:54 <shachaf> Nope, that's BostonHaskell.
23:36:54 <ivanm> that's about it
23:37:06 <Nereid> ivanm: I tried that, both master and cabal-1.16. both don't work.
23:37:09 <Nereid> I mean
23:37:12 <johnw> Nereid: you'll have to build "cabal" with 7.4.2
23:37:17 <pharaun> johnw: got the lazy one to work, its not eating up and holding on memory, but i'm forcing it via putStrLn for now. but surprisingly its actually slower than the single threaded version
23:37:18 <ivanm> Nereid: then it might not be available yet
23:37:23 <Nereid> they compile and all, but they don't actually work when I run them.
23:37:25 <ivanm> it took a while for 0.14 to come out
23:37:26 <pharaun> and slower than the strict version
23:37:31 <johnw> pharaun: sure, it should be
23:37:39 <mm_freak_> :t :t \f -> mapM (liftM2 (liftM . flip (,)) snd (f . fst))
23:37:40 <lambdabot> parse error on input `:'
23:37:40 <johnw> thousands of disk reads compared to one
23:37:45 <mm_freak_> :t \f -> mapM (liftM2 (liftM . flip (,)) snd (f . fst))
23:37:46 <lambdabot> forall a1 (m :: * -> *) a b. (Monad m) => (a -> m a1) -> [(a, b)] -> m [(a1, b)]
23:37:47 <johnw> the next trick to try is bytestring-mmap
23:37:55 <shachaf> Thanks, mm_freak_. thmm_freak_
23:37:55 <Nereid> oh well, guess I'll have to install 7.4.2 for now
23:37:58 <pharaun> johnw: hah k
23:38:03 <pharaun> mmap um let's see
23:38:03 <Nereid> just for cabal-install. =(
23:38:09 <pharaun> dangit hackage is down
23:38:15 <ivanm> @where hackage-mirror
23:38:15 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
23:38:23 <mm_freak_> shachaf: ?
23:38:25 <pharaun> i like to use the webdoc :)
23:38:32 <pharaun> never bothered to set it up locally
23:38:33 <johnw> hoogle isn't down
23:38:41 <shachaf> mm_freak_: Oh, I thought that was a joke @pling.
23:38:44 <johnw> oh, duh
23:38:49 <johnw> it sure is
23:38:50 <pharaun> johnw: yes :)
23:38:57 <pharaun> it searches fine but it links to hackage docs
23:39:05 <johnw> well, cabal install from luite's mirror
23:39:09 <johnw> than browse the haddock docs locally
23:39:12 <mm_freak_> shachaf: i actually wrote that one by hand
23:39:44 <mm_freak_> it isn't too hard to read
23:39:46 <Hadaka> oh btw, does anyone care about the karma stuff here anymore? or is it just needless spam?
23:39:46 <shachaf> mm_freak_: I thought so. But still.
23:40:00 <mm_freak_> Hadaka: let's see
23:40:03 <mm_freak_> @karma edwardk
23:40:03 <lambdabot> edwardk has a karma of 13
23:40:06 <mm_freak_> it's spam
23:40:19 <pharaun> johnw: yeah i'm getting it now i really should setup a local copy
23:40:25 <Hadaka> heh, thanks
23:40:25 <startling> Hadaka++
23:40:36 <shachaf> Hadaka: Every line spoken in this IRC channel is sacred and must be permitted in writing by the #haskell committee.
23:40:37 <johnw> ,Hadaka++
23:40:54 <ivanm> shachaf: permitted or preserved?
23:41:09 <shachaf> ivanm: I mean the resources of the channel.
23:41:25 <ivanm> ahhh
23:41:30 <shachaf> There exists a natural number N such that only N lines will ever be spoken in here!
23:41:34 <ivanm> since when have we had a #haskell committee? :p
23:42:13 <mm_freak_> :t \f -> mapM (liftM2 (liftM2 (,)) (return . snd) (f . fst))
23:42:14 <lambdabot> forall a2 (m :: * -> *) a b. (Monad m) => (a -> m a2) -> [(a, b)] -> m [(b, a2)]
23:42:18 <mm_freak_> that one is nicer
23:42:28 <mm_freak_> and wrong
23:42:35 <johnw> ivanm: there's #haskell-ops
23:42:44 <mysticc> How to use remote repo to install packages ?
23:42:46 <ivanm> johnw: yes, but are they a _committee_?
23:42:47 <mm_freak_> :t \f -> mapM (liftM2 (liftM2 (,)) (f . fst) (return . snd))
23:42:48 <lambdabot> forall a1 (m :: * -> *) a b. (Monad m) => (a -> m a1) -> [(a, b)] -> m [(a1, b)]
23:42:53 <mm_freak_> there we go
23:43:07 <ddarius> edwardk: So your plan for Haskell adoption is to write Haskell in languages that aren't Haskell, say "Man, these languages suck, this would be super easy in Haskell", and then use the Haskell you started with reproducing functionality at an "unbelievable" rate.
23:43:29 <ivanm> ddarius: sounds like a decent plan... :p
23:43:30 <pharaun> is this a silly question but - is there console version of haddock or does it always generates webpates
23:43:31 <mm_freak_> :t \f -> mapM (\(x, y) -> liftM2 (,) (f x) (return y))
23:43:32 <lambdabot> forall t a1 a2 (m :: * -> *). (Monad m) => (t -> m a1) -> [(t, a2)] -> m [(a1, a2)]
23:43:37 <mm_freak_> perhaps this one is the nicest of all
23:43:40 <ivanm> almost like the speed loops for instant productivity increases!
23:43:49 <ivanm> pharaun: web pages
23:43:55 <ivanm> but you can do a local hoogle install
23:43:56 <pharaun> ivanm: dangit alright
23:44:02 <ivanm> or do :browse inghci
23:44:05 <ivanm> *in ghci
23:44:07 <Hadaka> :D is #haskell-ops like #anonops? raining DDOS on lesser languages?
23:44:15 <johnw> pharaun: actually, a local hoogle can give you a ":doc" command in your ghci
23:44:21 <johnw> so you can say ":doc parMap"
23:44:24 <johnw> I use this
23:44:29 <pharaun> johnw: ooo nice
23:44:43 <ivanm> Hadaka: nah, I think #haskell-ops dates back to when someone was blocked here but couldn't get in to ask to be unblocked
23:44:48 <pharaun> guess its time to invest some time into doing a local hoogle and all
23:44:54 <pharaun> johnw: didn't you have a blog post of this
23:44:55 <ivanm> so you can go to #haskell-ops to seek help from someone that has ops here
23:44:59 <johnw> yes
23:45:07 <johnw> http://newartisans.com/2012/09/running-a-fully-local-hoogle/
23:45:16 <johnw> i *love* it
23:45:16 <ivanm> johnw: hoogle stores documentation?
23:45:23 <Hadaka> well, #haskellops should definitely be a thing
23:45:35 <johnw> a .hoo file is all the haddock docs from a package's modules
23:45:42 <johnw> not in HTML form, mind you
23:45:47 <johnw> in Haddock form
23:45:48 <Hadaka> they might actually be functional!
23:45:49 <Hadaka> (har har)
23:46:16 <johnw> try doing: cabal install --haddock-hoogle sometime
23:46:20 <johnw> you'll get a .txt file
23:46:25 <ivanm> johnw: why do you describe doing a bootstrap in that post?
23:46:40 <ivanm> oh, you had cabal-install installed locally?
23:46:44 <johnw> yes
23:46:53 <johnw> i don't use the platform
23:47:17 <ivanm> neither do I
23:47:20 <johnw> i've hacked up my bootstrap.sh quite a bit
23:47:22 <startling> @pl \a b -> Result ((mappend `on` _errors) a b)
23:47:22 <lambdabot> (line 1, column 31):
23:47:22 <lambdabot> unexpected "_"
23:47:22 <lambdabot> expecting space or simple term
23:47:26 <ivanm> I just install cabal-install from my package manager
23:47:28 <johnw> just now I hacked it to use my local Hackage mirror
23:47:29 <startling> @pl \a b -> Result ((mappend `on` errors) a b)
23:47:29 <lambdabot> (Result .) . (mappend `on` errors)
23:47:31 <Ralith> I've got a segfault resulting from in a foreign lib (certainly resulting from my misuse of it); how can I trace it?
23:47:36 <ivanm> johnw: does hoogle still insist on saving state to /usr/share ?
23:47:38 <Ralith> (gdb provides nothing of use)
23:47:41 <ivanm> that's when I stopped using it locally
23:47:43 <johnw> ivanm: not for me
23:47:47 <startling> @pl \a b -> Result ((mappend `on` errors) a b) ((mappend `on` result) a b)
23:47:47 <lambdabot> ap (ap . (Result .) . (mappend `on` errors)) (mappend `on` result)
23:47:48 <Ralith> resulting from a call into*
23:47:50 <startling> ew
23:48:00 <ivanm> (and it got worse when it wanted to install a web platform when I was only using it for command-line invocation)
23:48:03 <ivanm> dind't know about --info though
23:48:36 <johnw> i like that local hoogle can do colorized queries too
23:48:43 <johnw> i have that mapped to :h in my ghci
23:48:46 <Ralith> johnw: btw, the wrapper is progressing nicely; if you're still planning on contributing, the numeric comparison bits would be a nice start
23:49:02 <johnw> Ralith: I won't have time anytime soon, Ralith
23:49:14 <johnw> I'm trying to finish hlibgit2 now, and then I'll be doing hsubconvert
23:49:27 <Ralith> aw
23:49:27 <johnw> and meanwhile, I've got work to actually do too
23:49:46 <Ralith> perhaps when the time comes for the nice monadic rewrite.
23:50:13 <johnw> to use which monad?
23:50:21 <johnw> oh, you mean to provide a DSL?
23:51:02 <Ralith> johnw: I mean just to provide a slightly haskellier interface to the IR builder.
23:52:11 <Ralith> it behaves very much like a writer monad, if I'm not misremembering those.
23:52:54 <Ralith> I believe we could even build a pure interface to it.
23:53:26 <pharaun> johnw: i got mmap thing running i'm going to play with it :)
23:53:57 <Ralith> mmap <3
23:55:00 <johnw> what would be nice is a more functional way to build PHInodes
23:55:14 <pharaun> johnw: holyshit
23:55:31 <pharaun> 35s for 100x 1gb file and its stable memory usage
23:55:35 <Ralith> johnw: what do you have in mind?
23:55:40 <johnw> :)
23:55:51 <pharaun> i'm going to ramp up the file size to see how it works out
23:55:56 <johnw> Ralith: just musing; they're a pain to do in C++
23:56:17 <johnw> pharaun: i bet you can get it faster with the right amount of strictness
23:56:27 <Ralith> I have addIncoming :: Value -> [(Value, BasicBlock)] -> IO ()
23:56:37 <johnw> pharaun: because I bet you're still building thunks in parallel, and then executing them after serially
23:56:40 <Ralith> that makes it pretty painless
23:56:46 <pharaun> johnw: yeah i believe so, just need to play with it and try to keep on teaching myself about it
23:56:56 <Ralith> I'm not sure you can substantially improve on that, beyond hiding the IO.
23:56:57 <pharaun> strictness is still tricky for me
23:57:03 <Ralith> and making the types stronger
23:57:33 <johnw> Ralith: I'm not sure what I mean just yet
23:58:03 <pharaun> johnw: yeah i think you are right its still faster than the older stuff but only up to 1.3GiB/s
23:58:10 <johnw> yeah
23:58:13 <pharaun> the complete strict version was up to 3.2GiB/s
23:58:15 <johnw> show me the new stuff
23:58:20 <pharaun> so yeah there's some stuff i can do to tweak
23:58:27 <pharaun> johnw: not much to see but sure
23:58:47 <johnw> if you rdeepseq, what happens now?
23:59:07 * Ralith envisions buildPhi :: [(Value a, BasicBlock)] -> BasicBlockBuilder (Value a)
23:59:38 <pharaun> hmm
23:59:39 <johnw> Ralith: I want BasicBlocks to be monads, and you can compose them to get a phiNode
23:59:49 <pharaun> claiming 7s let's see
