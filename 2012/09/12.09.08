00:02:03 <Cale> > fix ((1:) . (>>= \x -> [1+x,1/(1+x)]))
00:02:05 <lambdabot>   [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.33333...
00:02:10 <Cale> > fix ((1:) . (>>= \x -> [1+x,1/(1+x)])) :: [Rational]
00:02:12 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
00:02:12 <hpaste> startling pasted “relations” at http://hpaste.org/74433
00:02:22 <startling> ^ anyone know of anything like this elsewhere in haskell?
00:02:23 <Cale> ^^ positive rationals
00:02:54 <startling> Cale: heh
00:03:12 <AfC> Cale: thanks. Yeah, the background compatibility thing is a bugaboo for me, I think: if you've got newer code that encounters an older document, it still needs to be able to read it.
00:03:25 <startling> it *feels* kind of lensy
00:03:41 <edwardk> ?
00:03:42 <Cale> AfC: well, of course, if *you* can handle absent elements
00:03:55 <startling> edwardk: do you get notified when anyone says `lens`?
00:04:00 <edwardk> yes
00:04:03 <startling> heh
00:04:15 <edwardk> this has led to an alarmingly high false positive rate these days ;)
00:04:18 <Cale> AfC: then everything is okay :)
00:04:21 <AfC> Cale: so I'm more leaning towards a "build up whatever you can best effort" sorta mindset, but I'm trying to at least allow for the possibility
00:04:33 <AfC> Cale: that some Haskell functional lateral thinking hotness will rescue me from the straitjacket of my perfectly serviceable but oh so last week imperative programming experience.
00:04:35 <startling> edwardk: anyway, now that you're here: do you have anything like http://hpaste.org/74433?
00:05:23 <edwardk> startling: nope
00:05:26 <AfC> Cale: anyway, good advice. I'll have a go on a micro case
00:05:49 <startling> edwardk: k, thanks anyway
00:06:23 <edwardk> only relation-ish code i have had on hackage is some nascent support for allegories in category-extras that was rather poorly thought out
00:06:56 <startling> are allegories like this?
00:07:07 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Allegory.html
00:07:37 <Cale> startling: They're almost, but not quite, entirely unlike that.
00:07:45 <edwardk> cale: hah
00:08:00 <startling> heh
00:08:13 <Jafet> Might as well add Enumerable a => Relation a, because suggest enumerates a
00:08:18 <edwardk> startling: http://en.wikipedia.org/wiki/Allegory_(category_theory)
00:08:53 <Jafet> And perhaps not call it Relation
00:09:19 <startling> Jafet: what would you call it?
00:09:56 <Jafet> Personally, I would call it a name that implies that it's not very useful
00:10:25 <startling> heh
00:10:39 <startling> yeah well
00:13:11 <Cale> data Multivalued a b = Multivalued { apply :: a -> [b], test :: a -> b -> Bool }
00:13:32 <Cale> You could define a Control.Category instance for those, presumably...
00:14:58 <startling> Cale: yeah, I was thinking about it
00:15:04 <startling> ooh, didn't realize it could have two types
00:18:06 <Cale> actually, no you couldn't, because Eq
00:19:12 <startling> Cale: I can make `eq` a Relation a a, though, no?
00:19:54 <Cale> Yes, it's just a problem with making an id for Category, which is required to be totally polymorphic in the type a
00:20:33 <Cale> You can make  eq :: (Eq a) => Relation a a
00:21:01 <Cale> (which is the identity multivalued function)
00:21:21 <startling> oh, understood
00:21:27 <startling> I don't know what (.) could be anyway
00:24:42 <Cale> f . g = Multivalued { apply = apply f <=< apply g, test = \x z -> any [test f y z | y <- apply g x] }
00:24:45 <Cale> something like that
00:25:04 <startling> oh, huh, that's interesting
00:25:33 <startling> @hoogle (Foldable f, Eq e) => f e -> e -> Bool
00:25:33 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
00:25:33 <lambdabot> Data.Foldable notElem :: (Foldable t, Eq a) => a -> t a -> Bool
00:25:33 <lambdabot> Prelude (/=) :: Eq a => a -> a -> Bool
00:41:00 <startling> hmmm, isomorphisms can't be a Category, can they?
00:41:23 <startling> :t id
00:41:25 <lambdabot> forall a. a -> a
00:41:30 <startling> :t Control.Category.id
00:41:31 <lambdabot> forall (cat :: * -> * -> *) a. (Control.Category.Category cat) => cat a a
00:41:37 <startling> oh wait, yes they can
01:49:15 <Rc43> > groupBy (\l r -> l == "1" && length r == 2) ["1","33","44","2"]
01:49:16 <lambdabot>   [["1","33","44"],["2"]]
01:49:26 <Rc43> > groupBy (\l r -> l == "1" && (length r == 2 || r == "2")) ["1","33","44","2"]
01:49:27 <lambdabot>   [["1","33","44","2"]]
01:49:36 <Rc43> Is it a bug or a feature?
01:49:57 <Rc43> (Equality is checked obly for the first in the list and "current".)
01:50:34 <Rc43> So, not in `groupBy f list` f is True not for all pairs of elements in sublists, but for the first and any other.
01:51:00 <Rc43> *last message without first "not"
02:21:39 <fmap> > groupBy (>) [2,0,1,0,2,0]
02:21:40 <lambdabot>   [[2,0,1,0],[2,0]]
02:22:02 <fmap> Rc43: You expect result to be [[2,0],[1,0],[2,0]]?
02:23:29 <Rc43> fmap, I have expected latter, yes; but it is corner case. I just misunderstood purpose of this function.
02:24:37 <timthelion> Anyone here know anything about the pyfagor language?
02:28:39 <csabahruska> Hi!
02:28:45 <csabahruska> I'd like to introduce our new blog about LambdaCube3D development. http://lambdacube3d.wordpress.com/
02:29:20 <cjay> yay
02:30:29 <csabahruska> Check the videos of Quake 3 and Stunts demos! ;)
02:32:44 <timthelion> csabahruska: so what model are you guys using for state? FRP?  IORefs?
02:32:57 <csabahruska> FRP
02:33:37 <timthelion> Cool :)
02:33:42 <timthelion> glad to see it actually works.
02:33:50 <timthelion> which FRP? Your own, bannana, wire?
02:34:09 <csabahruska> elerea
02:34:33 <timthelion> haven't heard of it yet.  Will read up.
02:35:11 <hiptobecubic> Why does this have such crazy fisheye lens action?
02:35:23 <timthelion> hiptobecubic: I was going to ask the same :/
02:35:36 <timthelion> csabahruska: that's not how a car flips when it runs into a tenis court ;)
02:37:02 <cjay> probably because many q3 players use a fov of around 110 degrees
02:37:37 <csabahruska> yep, it's probably the FOV :P
02:38:28 <hiptobecubic> it's really extreme
02:38:35 <hiptobecubic> also on the stunts one
02:38:45 <csabahruska> feel free to comment ;)
02:38:56 <csabahruska> on the blog
02:39:29 <cjay> how is LambadCube3D related to GPipe's way of doing things? I see it does not use GPipe
02:40:04 <cjay> but both seem to allow purely functional code on the gpu
02:40:32 <akosch> I recently learned about GADTs, it looks like one could write a nice DSL for generating SQL statements using them. Has anyone ever done this or have I found a new hobby project?
02:40:47 <hiptobecubic> akosch, there are quite a few sql dsls i think
02:41:28 <csabahruska> cjay: both are purely functional, but GPipe is Shallow Embedded DSL
02:42:10 <akosch> hiptobecubic: I want something minimal, not something fancy like haskelldb (and I want to see if GADTs offer an advantage)
02:42:17 <csabahruska> while LambdaCube3D will be a standalone DSL, but at the moment it is temporarily a Deep Embedded DSL
02:43:04 <csabahruska> LambdaCube3D performance is much better than GPipe, and it more feature rich also
02:43:57 <cjay> I see
02:47:15 <timthelion> csabahruska: I am also working on a data flow language. But mine is general purpose and not "pure".  Rather than having a "computational frequency" of each node.  I use STM so that nodes can passively listen to eachother.  When a node is updated, it sends a message down a channel.  Listener nodes, listen to the channels of the nodes they are listening to in an 'orElse' statement. This means that no part of the graph ever needs to be updated
02:50:51 <psii> akosch: http://blog.felipe.lessa.nom.br/?p=68 is a very recent approach
03:00:15 <akosch> psii: thanks, this looks interesting!
03:36:36 <faradi> Hi guys, does any1 know some big / interesting or open source project done with Haskell?
03:36:47 <faradi> kinda wondering if its only used for education...
03:37:55 <typoclass> faradi: how about xmonad
03:38:04 <lpvb> faradi: all over hackage
03:38:06 <bitonic> psi: that is... weird.  I'm much rater prefer a GADT solution with a type checked ADT for SQL
03:38:23 <lpvb> faradi: http://hackage.haskell.org/packages/archive/pkg-list.html
03:38:31 <arbn> faradi: Pandoc is interesting, IMO.
03:38:39 <lpvb> also, github is a nice place to check
03:39:11 <faradi> Thanks alot, will give them a ""google" :)
03:42:07 <psi> bitonic: well, I only posted the link here, because it was one of the newest posts on reddit and well received. I didn't look at the workings behind it, because sql is not my thing atm. So I can't comment on the pros and cons of this api design.
03:42:35 <bitonic> psi: OK :)
03:47:20 <psi> bitonic: but maybe it has to be like this, in order to stay on top of persistent.
03:47:37 <bitonic> psi: nah.
03:48:14 <bitonic> psi: but it has to be like this to be that type-safe, probably.  but I'd rather have something simpler and a bit less type safe
03:50:23 <psi> bitonic: then writing your own quick project-specific library could be the smartest way. very fast to write and to tailor to your needs.
03:50:47 <bitonic> psi: yeah, that too
03:50:54 * bitonic has lost a bit of faith in types lately
03:52:19 <psi> as long as it is just a bit ;)
03:54:25 <randomclown> I need to implement an impertative style algorithm that operates on a Map of Strings to Sets of String. The algorithm addes elements to the Sets during every iteration, and is finished when no Sets are changed after the iteration. What's the best way to do this in haskell?
03:55:25 <bitonic> psi: it's just that I find myself more and more comfortable with erlang
03:55:30 <randomclown> It is a major pain because both sets and maps are immutable
03:56:03 <faradi> what is the meaning of an algorithm being imperative...
03:56:06 <bitonic> randomclown: have you verified that the pure containers (in `containers' and `unordered-containers') are not fast enough?
03:56:20 <bitonic> assuming that you really need to rely on a table
03:58:04 <randomclown> bitonic: Performance doesn't matter much but I just can't see a way of doing this elegently
03:58:23 <bitonic> randomclown: just use an hashmap or whatever to store you're values
03:58:23 <randomclown> since everytime I changed a mapped set the map has to change as well
03:59:03 <bitonic> randomclown: well, your algorithm is probably going to be a recursive function along the lines of `foo :: Map -> Result', initialised as `foo emptyMap'
03:59:12 <bitonic> at each iteration you update the map
03:59:48 <randomclown> How would you check that the sets are changed or not?
03:59:54 <bitonic> what do you mean?
04:00:11 <bitonic> maybe if you explain the algorithm I can help you better :)
04:00:39 <randomclown> Building first sets for LL(1) grammar
04:01:30 <bitonic> so you have to build a parsing table or something like that
04:01:57 <randomclown> Yesh
04:03:09 <bitonic> I forgot the details, but I don't see how Haskell makes things a problem.  The only difference is that your table is going to be immutable, as an argument
04:03:54 <bitonic> and if you want you can have a mutable table in ST anyway.  but that's probably not needed
04:04:07 <faradi> <randomclown> what do you understand under the statement "imperative algorithm"?...
04:05:01 <randomclown> faradi: it just means it's designed for a non-functional language in mind
04:05:31 <faradi> ic
04:05:33 <faradi> 10x
04:05:39 <hiptobecubic> is there such thing as a non imperative algorithm? Wikipedia just calls it "A step by step procedure for calculations."
04:05:47 <bitonic> randomclown: I don't see why you would say that.  I mean it's building a table, which you can do easily in Haskell
04:05:55 <bitonic> it doesn't inherently rely on mutability
04:07:03 <foobar23> Are software patents in programming language research ethical, not sure?
04:07:14 <foobar23> http://en.wikipedia.org/wiki/Category:Computer_scientists_who_contributed_to_software_patents
04:07:36 <benmachine> foobar23: some people are of the view that software patents aren't ethical at all
04:07:43 <benmachine> some other people are of different views!
04:07:51 <timthelion> foobar23: they certainly aren't ethical, when it's a firm that gets them, but the government/a university that sponsored the research !
04:08:08 <faradi> <foobar23> you could patent just about anything, as long as it took some original idea and not pure logic to make it
04:08:09 <benmachine> it's not the sort of question you can expect an objective unbiased answer on
04:08:12 <timthelion> benmachine: like me :D
04:08:29 <benmachine> what's not original about pure logic >_>
04:09:20 <faradi> <benmachine> -> alot of ppl can come up with the same result ;)
04:09:21 <foobar23> hm, ok
04:09:28 <timthelion> faradi: I always, was of the opinion, that pattents shouldn't be granted on grounds of origionality, but rather on the grounds of how hard it was to make the discovery.  New polymers aren't orrigional, but can cost millions to develop.  Esoteric programming languages are origional, but can be invented in a matter of weeks.
04:09:40 <benmachine> faradi: they might do! but they might all paint the same thing as well :P
04:10:19 <benmachine> actually coming up with good and useful logical reasoning is not straightforward
04:11:10 <faradi> I wonder if the guy, who invented the transistor, had it patented :D
04:11:37 <solirc> benmachine: I somehow thought that most computer scientists/programmers see software patents as a means of "hurting innovation", no?
04:11:47 <bitonic> faradi: they surely did patent it
04:11:55 <solirc> The is this famous memo of bill gates.
04:12:04 <benmachine> solirc: many people see them as doing that, yes
04:12:43 <benmachine> solirc: I don't know much about the subject, but I think they're probably right
04:12:45 <faradi> I bet at some point there has been something like "I invented all those cool things". "Yeah? I invented PANTENTING. And I pantented all your things, so your stuff are MY STUFF now!"
04:12:48 <benmachine> but that's not to say there isn't a counterargument
04:13:08 <solirc> benmachine: I'm listening.
04:13:17 <eikke> faradi: then that's a prior art case
04:13:45 <benmachine> solirc: I suppose people who support patents would argue that they're necessary to profit from your inventions
04:13:55 <benmachine> and since, after all, everyone in the world is motivated exclusively by money
04:14:02 <benmachine> if there weren't patents there wouldn't be inventions!
04:14:17 <solirc> ah, here it is: "If people had understood how patents would be granted when most of today's ideas were invented, and had taken out patents, the industry would be at a complete standstill today..."
04:14:32 <solirc> ^ Bill Gates, 16 May 1991
04:16:53 <solirc> 20 years later, and I guess we are pretty close :D
04:17:01 <benmachine> :)
04:17:59 * timthelion would support patents, if they where based on the "right sell licence to an idea" rather than "the right to a monopoly over an idea."
04:18:16 <hiptobecubic> timthelion, who decides the fair price?
04:18:34 <timthelion> hiptobecubic: that's a difficult question.  One I haven't been able to answer.
04:18:59 <faradi> isnt it the owner of the patent?
04:19:09 <timthelion> hiptobecubic: but in the case of like pinch zoom with apple.  Pinch zoom shouldn't be monopolized by apple, apple should be forced to sell licence.
04:19:18 <timthelion> faradi: right now.  Which sucks :(
04:19:30 <hiptobecubic> Sure, but if you don't have a way to determine pricing, then it's back to being useless.
04:19:51 <hiptobecubic> I would support patents too if they didn't have any of the problems associated with them.
04:20:27 <solirc> hiptobecubic: lol
04:20:38 <faradi> well, pinch zoom is nice...as well as the mouse and the keyboard...
04:20:43 * solirc would support patents, if they were not patents.
04:20:47 <faradi> nobody came up with that idea, so...
04:22:31 <faradi> http://www.null-hypothesis.co.uk/science/strange-but-true/patent-lunacy/top_ten_bizarre_crazy_patents
04:22:33 <faradi> o_O :P
04:22:57 <ivanm> for all those people that say gestures like that are "intuitive", I keep never realising what's possible until I do the wrong thing or google them
04:23:02 <timthelion> hiptobecubic: my feeling on pinch zoom, is that it didn't cost apple enough to develop that in order for it to be worth a patent.  But my aunt mixes polymers in a lab.  They might spend a year or two changing the ratios untill it's just right, and then patent that.  Surely that's usefull to society. and there's not a good way(other than being funded by the government) to support that kind of research without some kind of intelectual propert
04:23:06 <Hail_Spacecake> how is printf implemented in haskell?
04:23:23 <ivanm> Hail_Spacecake: have you tried reading the source code?
04:23:24 <Hail_Spacecake> the type is String -> r
04:23:26 <ivanm> it's right there...
04:23:31 <timthelion> ivanm: watch the ads. Ads are educational.
04:23:42 <hiptobecubic> timthelion, what if my aunt is a much better chemist and only needed 100 bucks and three tries to make it?
04:23:43 <ivanm> Hail_Spacecake: and the `r' is determined by a type class, which has many possible instances
04:23:46 <ivanm> e.g. Int -> r
04:23:47 <Hail_Spacecake> so that's a good question, when I do something like import Text.Printf
04:23:57 <Hail_Spacecake> how do I find out the source file corresponding to it?
04:24:02 <hiptobecubic> timthelion, is that more or less patentable?
04:24:07 <absence> i tried compiling hello world for gloss with the latest haskell platform on windows. when i run it, it segfaults. is this a common problem?
04:24:10 <timthelion> hiptobecubic: very fair point.  I don't have an answer :(
04:24:13 <typoclass> ivanm: there's a difference between being intuitive and looking intuitive. apple is extremely good at the latter.
04:24:14 <Hail_Spacecake> like, where is the standard place to put that in a linux system?
04:24:16 <ivanm> Hail_Spacecake: if you enabled building documentation with hscolour support, there's a link on the documentation
04:24:29 <timthelion> hiptobecubic: but you have to admit, that kind of research IS expensive!
04:24:30 <ivanm> Hail_Spacecake: note that the documentation on hackage is built with that option
04:24:38 <ivanm> absence: I hope not
04:24:55 <ivanm> absence: maybe you need a newer or older version of gloss?
04:25:16 <hiptobecubic> timthelion, some things are expensive. yes. But i don't see how that makes them more patent worthy.
04:25:42 <Hail_Spacecake> I have the version of ghc(i) in my distro's package manager
04:25:43 <timthelion> hiptobecubic: how would you supose that kind of research is funded?  Government grant?
04:26:00 <hiptobecubic> Valuable ideas which cost very little to produce seem better to me, why would we only incentivize expensive ones.
04:26:11 <typoclass> Hail_Spacecake: note that on all the pages like http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Printf.html there's links labeled "source". that said, printf is definitely funky in haskell
04:26:36 <ousado> the world is not in a shape that allows mankind to make knowledge how to do things efficiently private
04:26:37 <typoclass> Hail_Spacecake: here is some more discussion http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
04:26:37 <hiptobecubic> timthelion, that is one way, yes. But there are many many many fields with enormous barriers to entry. We don't give them special help either.
04:26:44 <ivanm> Hail_Spacecake: which distro?
04:26:53 <absence> ivanm: i installed it just now, so i assume i have the latest
04:27:06 <Hail_Spacecake> ivan arch
04:27:10 <Hail_Spacecake> *ivanm
04:27:22 <absence> gloss-1.7.5.2
04:27:24 <ivanm> check /usr/share/doc/ghc-<version>/html/libraries/index.html
04:27:35 <ivanm> and check if they build the docs with hscolour support
04:27:50 <ivanm> absence: I know that some people have had problems with newer versions of gloss on older versions of GHC
04:28:01 <ivanm> I don't have a working gloss install atm though, so I can't check
04:28:01 <timthelion> hiptobecubic: I too would like to see more government funded research, and especially more OPEN government funded research.  I feel robbed every time I see that some technology was funded by a grant, but then the private firm ended up with ownership of the patent :(
04:28:16 <absence> ivanm: how old is older?
04:28:24 <absence> ivanm: i have 7.4.1
04:28:25 <ivanm> absence: 1.6.*
04:28:30 <hiptobecubic> timthelion, yes. that should be flatly illegal
04:28:33 <ivanm> oh, this was 6.12 I think
04:28:34 <timthelion> hiptobecubic: which happens to be true for 100% of the patents in my feild(accessability techonology)
04:29:27 <hiptobecubic> the problem, though, is that even if the government pays for the research, why would you do it? What is the point of research if not to gain an advantage over competitors?
04:30:31 <timthelion> hiptobecubic: Well you wouldn't do the reaserch in that case, the government would...
04:30:32 <ivanm> hiptobecubic: knowledge?
04:30:32 <typoclass> hiptobecubic: i think you have a very corporatist view on that question
04:30:51 <Jeanne-Kamikaze> ^
04:30:52 <bitonic> this is a discussion for -blah
04:31:05 * timthelion goes back to programming.
04:32:54 <cinimod> How do I tell if I have a 64 bit install of ghc or a 32 bit install?
04:35:49 <ivanm> cinimod: maxBound :: Int
04:35:52 <ivanm> > maxBound :: Int
04:35:53 <lambdabot>   9223372036854775807
04:35:58 <ivanm> ^^ lambdabot has a 64bit GHC
04:36:08 <hiptobecubic> Why is there no max bound for float or double?
04:36:13 <hiptobecubic> > maxBound :: Float
04:36:14 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
04:36:15 <lambdabot>    arising from a use of...
04:36:23 <ivanm> hiptobecubic: because there is no maximum possible value except for infinity?
04:36:41 <hnsz> Why can't a function be part of several typeclasses?
04:36:45 <ivanm> (as a wild guess; I've forgotten most of my classes on how floating point numbers are defined)
04:36:55 <ivanm> hnsz: because how do you know which version of the function you want?
04:37:10 <hiptobecubic> ivanm, is there a simple way to get the largest non-infinity value?
04:37:20 <ivanm> nfi
04:37:26 <hnsz> ivanm: I thought that could depend on which class a type is an instance of
04:37:41 <ivanm> hsnz: and if the same type is an instance of both classes?
04:38:06 <cinimod> Ok I seem to have a 32 bit install which is disappointing
04:38:12 <hnsz> ivanm: well that is true
04:38:38 <ivanm> cinimod: why so? apparently 64bit can take up more memory
04:38:51 <ivanm> but I don't think the 64bit version is any faster, unless you're using Int64 or something
04:39:13 <timthelion> ivanm: 64 bit can reference more memory. it shouldn't take more.
04:39:15 <cinimod> https://gist.github.com/2420144
04:39:31 <cinimod> I want to install GTK
04:39:32 <timthelion> ivanm: and the 64 bit version will certainly be faster.
04:39:45 <ivanm> timthelion: the size of an Int on 64bit is bigger than the 32bit version, is it not?
04:40:10 <ivanm> and why would 64 bit necessarily be faster? (not saying you're wrong; I freely admit I could be mistaken)
04:40:15 <hnsz> ivanm: Now I can't use (*) for anything unless it is conceptually like a number (could be a good thing;)).
04:40:21 <timthelion> ivanm: yes it is. but how many ints do you have?
04:40:31 <ivanm> hnsz: see one of the alternate preludes like YAP
04:40:43 <ivanm> if you're not using * for multiplication, don't import it
04:40:50 <ivanm> timthelion: hmmm?
04:41:19 <ivanm> cinimod: and you can't use that to build it on 32bit?
04:42:03 <cinimod> "on lion (and snow leopard i suppose), make sure you are using a 64 bit install of ghc"
04:42:12 <timthelion> ivanm: it is faster, because there are different operation widths in the CPU. So an opperation might have a bit width of say 20.  This opperation takes the same ammount of time on a 32 bit and 64 bit CPU. But with an opperation who's bit width is more than 32, than that operation takes 4 times as long(don't quote me on that).  It must do some bit of the opperation.  Trade out into a register, and then do the seccond half.
04:42:18 <hnsz> ivanm: Thanks :) I don't want to discard the numberclass so I'm guessing I'm doing it wrong :D
04:42:38 <ivanm> cinimod: sure, but that could just be because he didn't check it on 32bit versions
04:42:41 <ivanm> have you tried any way?
04:43:04 <cinimod> Nope but I can
04:43:21 <ivanm> timthelion: so how does that imply that a 64bit compiled version is faster than a 32bit compiled version?
04:45:40 <timthelion> ivanm: It has to do more operations to do the same thing.
04:45:46 <timthelion> on 32 bits
04:45:55 * timthelion is trying to find you a side by side compairison
04:46:19 * osfameron keeps reading "timthelion" and reading it to rhyme with "triskelion"
04:46:25 <ivanm> osfameron: heh
04:46:47 <ivanm> timthelion: but if the bit width is the same and a single 64bit operation fits into it, wouldn't a 32bit operation fit into it as well?
04:47:17 <ivanm> most comparisons I've seen have been about 64bit versions being able to address more memory, but often having a slight speed penalty
04:47:42 <timthelion> ivanm: 32 bit can address more memory too, with a speed penalty.
04:47:52 <ivanm> sure
04:48:17 <ivanm> but with GHC, Int on 64 > Int on 32
04:54:10 <randomclown> @pl \x -> (first x) == False
04:54:10 <lambdabot> (False ==) . first
04:54:29 <Jafet> class Mult a b c | a b -> c where (*) :: a -> b -> c
04:54:32 <Jafet> :t first
04:54:33 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
04:54:51 <Jafet> @check \x -> (x == False) == x
04:54:53 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\n"
04:55:00 <Jafet> @check \x -> (x == False) == not x
04:55:01 <lambdabot>   "OK, passed 500 tests."
04:55:56 <timthelion> ivanm: Here is the only side by side I could find, and it's biased towards x64 http://delphi.cz/img/chasm64/chasm64.png
04:56:08 <timthelion> ivanm: but it does show how in some cases x64 is faster.
04:56:23 <ivanm> reading assembly means nothing to me :p
04:56:44 <ivanm> timthelion: I'm assuming that it's trying to show that you can take advantage of a 64bit bus to combine two smaller bit operations?
04:57:08 <ivanm> if so, can you do that on the same CPU whilst compiling as 32bit?
04:57:22 <ivanm> that seems to be demonstrating the advantages of 64bit _cpus_ rather than compiling as 64bit
04:57:53 <ivanm> also, it doesn't say what to do if neither CPUX86 or CPUX64 is defined :p
04:58:20 <randomclown> easiest way to find the first non equal element in a list?
04:58:28 <timthelion> ivanm: no, you cannot take advantage of that on a 64 bit cpu compiling as 32 bit.
04:58:35 <ivanm> randomclown: see dropWhile
04:58:41 <randomclown> i.e [1,1,1,1,1,3,3,4,5,6,7 ...]
04:58:52 <randomclown> but I need compare with the previous one
04:58:58 <ivanm> randomclown: group
04:59:08 <randomclown> right
04:59:24 <timthelion> ivanm: 32 bit assembler is a subset of 64 bit assembler.  So if you compile to 64 bit assembler, you can do more things, and potentially write a shorter assember ruitine which means faster execution.
04:59:25 <Jafet> > head . (!!1) . group $ [1,1,1,1,1,3,3,4]
04:59:26 <ivanm> though you could also do a dropWhile after pattern matching to ensure a non-empty list
04:59:27 <lambdabot>   3
04:59:42 <ivanm> Jafet: why not head . head . tail ? :p
04:59:51 <Jafet> More strokes.
04:59:53 <ivanm> timthelion: *nod*
05:00:07 <ivanm> timthelion: but do compilers take advantage of that kind of stuff?
05:00:13 <ivanm> and how likely is it that that can be done?
05:00:29 <Jafet> > group[0..]!!1!!0
05:00:29 <ivanm> last I checked, not many people chose to write stuff in assembler nowadays ;p
05:00:30 <lambdabot>   1
05:00:57 <ivanm> > group (replicate 20 1) !! 1 !! 0
05:00:58 <lambdabot>   *Exception: Prelude.(!!): index too large
05:00:59 <ivanm> :p
05:01:14 <ivanm> > group (repeat 1) !! 1 !! 0
05:01:18 <lambdabot>   mueval-core: Time limit exceeded
05:01:43 <Jafet> > head . head . tail $[[]]
05:01:45 <lambdabot>   *Exception: Prelude.head: empty list
05:01:51 <timthelion> ivanm: people don't write in assembler, but of course a good compiler will be able to generate more efficient assembly code for x64 than fir x86
05:02:13 <ivanm> timthelion: so, is that the case with GHC?
05:02:17 <randomclown> what about when the list stops changing
05:02:32 <randomclown> [1,3,4,5,6,2,2,2,2,2]
05:02:34 <randomclown> want 2
05:02:36 <ivanm> I can't recall seeing anyone bothering to benchmark 32 vs 64bit
05:02:42 <timthelion> ivanm: I hope !
05:02:46 <ivanm> randomclown: why are you wanting this?
05:02:58 <randomclown> convergence
05:03:00 <timthelion> ivanm: the ghc devs would have to be very stupid not to take advantage of it.
05:03:04 <Jafet> :t until
05:03:05 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
05:03:08 <ivanm> randomclown: that doesn't say why you're doing it
05:03:11 <ivanm> is this homework?
05:03:19 <randomclown> nope
05:03:23 <ivanm> OK, just checking :)
05:03:37 <int-e> ivanm: often 32 bit wins for pointer chasing computations. that's not saying that it should win -- the main reason is the higher memory footprint of pointers.
05:03:38 <timthelion> ivanm: and if you are using gcc's own optimizer(which if I recall correctly, is done with -O2) then certainly
05:03:44 <randomclown> I can write it out recursively, not sure if doable with prelude and data.list
05:03:52 <ivanm> > let single [_] = True; single _ = False in head . head . dropWhile single $ group [1,3,4,5,6,2,2,2,2,2]
05:03:53 <lambdabot>   2
05:04:04 <ivanm> int-e: right, that's what I was trying to refer to
05:04:21 <ivanm> timthelion: *nod*
05:04:35 <ivanm> randomclown: like that?
05:04:40 <timthelion> I see :/  but x64 *should* be faster..
05:04:44 <randomclown> yeah something like that
05:05:36 <Jafet> The ontological argument for CPU speed
05:05:50 <timthelion> Jafet: ?
05:06:25 <int-e> bigger number = better ;)
05:06:36 <Jafet> "Oh, it should be faster."
05:07:09 <Jafet> > fst.head $ dropWhile (/=) $ [1,3,4,5,6,2,2,2,2,2]
05:07:11 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
05:07:11 <lambdabot>         against inferred type ...
05:07:27 <Jafet> > fst.head $ dropWhile (/=) $ zip <*> tail $ [1,3,4,5,6,2,2,2,2,2]
05:07:28 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
05:07:28 <lambdabot>         against inferred type ...
05:07:37 <ivanm> needs an uncurry?
05:07:38 <Jafet> > fst.head $ dropWhile (uncurry (/=)) $ zip <*> tail $ [1,3,4,5,6,2,2,2,2,2]
05:07:39 <timthelion> Jafet: but in this case, it really actually logically should be faster.  Even checking two UTF-8 chars for equality is like a third the number of steps on x64...
05:07:40 <lambdabot>   2
05:07:50 <Jafet> I need an uncurry.
05:08:07 * Jafet looks for some water
05:08:11 <int-e> timthelion: I don't follow
05:08:12 <ivanm> had one too many curries last night, did you? :p
05:08:23 <ivanm> Jafet: I think milk is meant to be better
05:08:42 <Jafet> It is, but it leaves a terrible aftertaste
05:08:46 <ivanm> int-e: I think he means in a sufficiently smart compiler
05:08:46 <int-e> (But maybe I'm missing some bit shuffling trickery that I should learn)
05:08:51 <ivanm> Jafet: raijta?
05:09:01 <ivanm> lassi?
05:09:29 <Jafet> I don't have any of that nearby...
05:09:38 <int-e> ivanm: I'm happy to argue this on the assembly level. I just don't see how having more than 32 bits helps here.
05:09:40 <Jafet> Possibly some fruit is at hand
05:09:42 <ivanm> Jafet: cucumbers?
05:09:49 <Jafet> Nope
05:09:50 <timthelion> int-e: If you are checking for equality, in a string.  You can load more than one character into the same register...
05:11:09 <Jafet> If your program is bottlenecked by memcmp, you should be using a different data representation.
05:11:17 <int-e> ok, assuming we're comparing code points. the main work will be determining how many bytes one needs to compare.
05:11:42 <Jafet> I have never heard of any kind of program that is necessarily constrained by pointer size
05:12:19 <timthelion> Jafet: did you ever use adobe photoshop on a 32 bit system :)
05:12:23 <int-e> Jafet: Heh, remember the good old DOS days with tiny and large programming models?
05:12:58 <Jafet> Perhaps when we get 256-bit address spaces, we'll need near and far pointers again.
05:13:11 <int-e> (I have not personally had trouble with the 32 bit limit so far, but I can imagine several applications where a larger address space will be required.)
05:13:35 <Jafet> int-e: I mean constrained by the fact that 64-bit pointers are larger than 32-bit pointers.
05:13:46 <timthelion> but IMO, adress space isn't the biggest thing with 64 bits.  it's faster arithmatic.
05:14:03 <Jafet> If your program does integer arithmetic.
05:14:25 <int-e> Jafet: well it's unfortunate that for single applications the next reasonable step after upgrading memory to 4 GB is to upgrade to more than 8 GB :)
05:14:29 <timthelion> if your program does floating point arithmatic than the difference should be obvious.
05:14:44 <int-e> Jafet: (maybe due to bad programming. I'll grant that.)
05:15:27 <Jafet> I'm still waiting for cheap 8GB sodimms
05:15:28 <timthelion> int-e: I generally have a rule.  That I need 1 gb for everything I do, and 7 gb for firefox...
05:16:01 * timthelion really doesn't get how firefox manages to be so bad...
05:16:32 <Jafet> Space leaks.
05:16:50 <timthelion> Jafet: after what, 14 versions?
05:17:06 <Jafet> Version number means nothing. Consider Ubuntu
05:17:14 <timthelion> I restart my computer once a week, and firefox once a day!
05:17:37 * timthelion isn't familiar with recent versions of Ubuntu
05:17:46 <int-e> there's hope for getting the best of the two worlds under Linux: http://kernelnewbies.org/Linux_3.4#head-039c9d273884c9639937c10d68b4a3214869eb4b
05:18:06 <Jafet> They're just as bad as the older versions you may have unfortunately become familiar with
05:19:27 <int-e> timthelion: I need 6 GB to build AFP for Isabelle.
05:19:58 <Jafet> int-e: does that linux feature improve actual programs?
05:20:03 <timthelion> Jafet: there was no problem, except that I had to reinstall every 6 months.
05:20:30 <timthelion> int-e: I'll respond to that statment once I google AFP and Isabelle
05:20:51 <Jafet> You built the entire afp?
05:20:56 <int-e> Jafet: I only discovered it two days ago (I missed the news a year ago), so I still haven't actually tried.
05:21:20 <Jafet> @goog archive of formal proofs
05:21:20 <lambdabot> Maybe you meant: google googleit
05:21:21 <int-e> Jafet: hmm, no, not all of it. I'd have to check which parts.
05:21:24 <Jafet> @google archive of formal proofs
05:21:26 <lambdabot> http://afp.sf.net/
05:21:26 <lambdabot> Title: Archive of Formal Proofs
05:21:41 <timthelion> int-e: Advertiser Funded Programming of a Porn site?  According to the relevant links clicked on my favorite search engine
05:22:07 <int-e> Jafet: are you aware that there's a #isabelle? (mostly quiet, but with more people that might change)
05:22:22 <Jafet> Not until now
05:22:24 <int-e> timthelion: ouch
05:22:37 <Jafet> (Well, channels exist once someone enters them)
05:22:43 <ivanm> timthelion: wouldn't that be AFPP ?
05:22:58 <timthelion> ivanm: :P
05:58:46 <insitu> hello I am trying to define filter as a catamorphism but without success
06:04:00 <ivanm> insitu: any prticular reason _why_ ?
06:04:11 <insitu> fun ?
06:04:38 <insitu> really, I am trying (once more) to understand some stuff from bananas and co.
06:04:51 <timthelion> insitu: :O
06:05:07 <lyonart77> ciao a tutti
06:05:33 <lyonart77> !list
06:05:36 <lpvb> bananas?
06:05:44 <timthelion> insitu: you are aware that trying to understand reactive bananna may be harmfull to your health.
06:05:58 <lpvb> whats wrong with reactive banana
06:05:58 <notdan> > let filter' f lst = foldr (\x acc -> if (f x) then (x:acc) else acc) [] lst
06:05:59 <lambdabot>   not an expression: `let filter' f lst = foldr (\x acc -> if (f x) then (x:a...
06:06:06 <notdan> > filter' f lst = foldr (\x acc -> if (f x) then (x:acc) else acc) [] lst
06:06:07 <lambdabot>   <no location info>: parse error on input `='
06:06:10 <notdan> erh
06:06:17 <timthelion> lpvb: have you seen the examples?
06:06:24 <insitu> yes.
06:06:25 <notdan> > foldr (\x acc -> if (f x) then (x:acc) else acc) [] lst $ odd [1..10]
06:06:26 <lambdabot>   Not in scope: `lst'
06:06:37 <notdan> > \f lst -> foldr (\x acc -> if (f x) then (x:acc) else acc) [] lst $ odd [1..10]
06:06:38 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
06:06:42 <insitu> so i thing, I have seen this: http://hackage.haskell.org/packages/archive/pointless-haskell/0.0.8/doc/html/src/Generics-Pointless-Examples-Examples.html#filterCata
06:06:45 <lpvb> > let filter' f lst = foldr (\x acc -> if (f x) then (x:acc) else acc) [] lst in filter' (<5) [1..10]
06:06:46 <notdan> ok, well, you got the idea, insitu
06:06:47 <lambdabot>   [1,2,3,4]
06:06:57 <notdan> thanks lpvb
06:07:20 <insitu> no, really I dont :-) Because I know that definition. The one I am looking for is the one using directly cata:
06:07:37 <insitu> > newtype Rec f = In { out :: (f (Rec f)) }
06:07:37 <insitu>  
06:07:38 <lambdabot>   <no location info>: parse error on input `newtype'
06:07:40 <lpvb> timthelion: No, but I thought FRP was a good answer to event programming in haskell?
06:08:23 <timthelion> lpvb: they say that.  But then again. no one has ever actually made an FRP application with reacitve bananna...
06:08:40 <notdan> hm
06:08:46 <insitu> > cata :: Functor f => (f a -> a) -> (Rec f -> a)
06:08:46 <insitu> cata h = h . fmap (cata h) . out
06:08:46 <insitu>  
06:08:47 <lambdabot>   `f' is not applied to enough type arguments
06:08:47 <lambdabot>  The first argument of `L.Rec' ...
06:10:24 <lpvb> > let cata :: Functor f => (f a -> a) -> (Rec f -> a); cata h = h . fmap (cata h) . out; in cata (\Just x -> x)
06:10:26 <lambdabot>   `f' is not applied to enough type arguments
06:10:26 <lambdabot>  The first argument of `L.Rec' ...
06:10:56 <insitu> do not know how to define Rec f in here...
06:11:52 <lpvb> what is Rec
06:12:10 <insitu> recursive definition of a functor. Often called Mu I guess.
06:12:10 <lpvb> :i Rec
06:12:19 <lpvb> @src Rec
06:12:19 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
06:12:19 <insitu> :i Mu
06:12:32 <insitu> ah great
06:12:47 <insitu> not very familiar with IRC, I fear
06:13:07 <lpvb> bots aren't the IRC protocol
06:13:31 <insitu> I know. I wanted to say I am not very familiar with haskell on IRC
06:13:35 <lpvb> > let cata :: Functor f => (f a -> a) -> (Rec (f a) -> a); cata h = h . fmap (cata h) . out; in cata (\Just x -> x)
06:13:36 <lambdabot>   Couldn't match expected type `L.Rec (f a)'
06:13:36 <lambdabot>         against inferred type `L...
06:13:40 <ivanm> :k Rec
06:13:41 <lambdabot> * -> *
06:13:47 <Jafet> @src Mu
06:13:47 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
06:13:53 <ivanm> lpvb: :t and :k work, but :i doesn't
06:13:53 <insitu> which obviously includes understanding lambdabot
06:15:03 <insitu> So given data L a l = Nil | L a l deriving Show
06:15:04 <insitu>  
06:15:13 <insitu> One can define type List a = Rec (L a)
06:17:49 <Franciman> hey people, where can I find swierstra duponchel paper about their arrow parser?
06:18:11 <ivanm> Franciman: google? :p
06:18:22 <Franciman> I have already tried but can't seem to find :(
06:18:57 <Franciman> ivanm, do you know its title?
06:19:07 <Franciman> maybe using the title I'll get more results
06:19:08 <ivanm> no idea which paper you're referring to :)
06:19:10 <merijn> Franciman: Did you use Google or Google Scholar?
06:19:14 <Franciman> google
06:19:29 <merijn> Franciman: You are likely to have more luck on Google Scholar
06:19:38 <merijn> Or, alternatively, citeseerx
06:20:42 <Franciman> great I found it, thanks so muhc
06:20:44 <Franciman> *much
06:22:52 <insitu>  > let cata :: Functor f => (f a -> a) -> (Mu f -> a); cata h = h
06:22:52 <insitu>        . fmap (cata h) . out; in cata (\Just x -> x)
06:23:01 <insitu> :t cata
06:23:02 <lambdabot> forall (f :: * -> *) a. (Functor f) => (f a -> a) -> Mu f -> a
06:24:04 <Jafet> :t cata fromJust
06:24:05 <lambdabot> forall a. Mu Maybe -> a
06:24:49 <Jafet> This doesn't sound like a very interesting function
06:25:14 <insitu> hmm, it is a generalized fold actually
06:26:11 <dolio> I think he means cata fromJust.
06:26:14 <dolio> And it isn't.
06:26:24 <insitu> really not.
06:26:25 <ivanm> dolio: interesting or a generalised fold? ;)
06:27:07 <dolio> It's 'f Nothing = error "fromJust" ; f (Just x) = fromJust (f x)'
06:27:10 <dolio> Isn't interesting.
06:27:51 <dolio> Oh, wait, it's 'f (Just x) = f x'
06:28:10 <ivanm> so.... it's only useful for Just (Just (Just (Just ... ) ) ) ?
06:28:18 <dolio> No, it's not useful there, either.
06:28:18 <ivanm> s/useful/non-error-causing/
06:28:35 <dolio> Unless you think spinning forever is more useful than throwing an exception.
06:28:41 <ivanm> yeah, I realised "useful" wasn't the term as soon as I hit enter :p
06:28:55 <Jafet> I stopped thinking after Mu Maybe -> a
06:29:44 <insitu> but it is useful for recursive datatypes, which maybe is not
06:30:33 <insitu> well, useful as in "makes your head ache when you try to think too hard about it but some people write thesis about it"
06:30:45 <Jafet> Origami nuts...
06:30:45 <ivanm> and edwardk loves it? :p
06:31:20 <byorgey> insitu: no one is denying that cata is useful.
06:31:26 <byorgey> it's cata fromJust  which isn't useful.
06:32:00 <Jafet> If you ask me, I think cata isn't very useful either
06:32:08 <insitu> :-)
06:32:10 <Jafet> I've never used it, at least
06:32:11 <ivanm> @type cata head
06:32:12 <lambdabot> forall a. Mu [] -> a
06:32:22 <ivanm> just as useless?
06:32:44 <insitu> :t head
06:32:45 <lambdabot> forall a. [a] -> a
06:33:12 <dolio> cata head is 'walk to the left-most leaf of the tree, and then throw an error.'
06:33:12 <byorgey> any function of type  forall a. (something that does not involve a) -> a   probably won't be winning any awards for usefulness, let's put it that way
06:33:15 <Jafet> Mu k is pretty useless for most k
06:33:27 <Jafet> You probably want Mu (k a)
06:33:33 <ivanm> Jafet: for which k _is_ it useful for?
06:33:38 <byorgey> Jafet: what?
06:33:56 <dolio> Mu Maybe is natural numbers.
06:33:57 <byorgey> there's nothing wrong with  Mu Maybe   and   Mu [] .
06:34:18 <byorgey> Mu []  is  rose tree shapes.
06:34:46 <Jafet> Exactly what I said! Pretty but useless.
06:35:01 <ivanm> Jafet: not _precisely_ what you said...
06:35:11 <byorgey> natural numbers are useless?
06:35:37 <ivanm> byorgey: how do you use Mu Maybe as naturals?
06:36:04 * Craps waves to everybody
06:36:15 <ivanm> since when did we have card games here?
06:36:17 <Jafet> Tediously
06:36:18 <ivanm> ;)
06:36:24 <byorgey> > let toInt = cata (maybe 0 succ) in toInt (Mu (Just (Mu (Just (Mu (Just (Mu Nothing)))))))
06:36:25 <lambdabot>   Not in scope: data constructor `Mu'Not in scope: data constructor `Mu'Not i...
06:36:34 <byorgey> oh, it's In
06:36:53 <byorgey> > let toInt = cata (maybe 0 succ) in toInt (In (Just (In (Just (In (Just (In Nothing)))))))
06:36:55 <merijn> :t cata
06:36:55 <lambdabot>   3
06:36:56 <lambdabot> forall (f :: * -> *) a. (Functor f) => (f a -> a) -> Mu f -> a
06:37:06 <ivanm> huh
06:37:37 <byorgey> ivanm: at each level you have either Nothing (representing zero) or Just wrapped around another Mu Maybe (representing successor)
06:37:48 <ivanm> yup, got it now
06:39:31 <Jafet> data Fix f = Fix (f (Fix f))
06:39:48 <int-e> Jafet: as one data point regarding whether this x32 ABI helps in practice, https://sites.google.com/site/x32abi/ has a comparison for two SPEC benchmarks (181.mcf and 186.mcf) that is consistent with the "best of two worlds" goal. The paper reports a 13.4% average speedup on the SPEC2000 C benchmarks compared to 64 bit mode. They have no number for the 32-bit compatibility mode, but the diagrams indicate that they usually...
06:39:54 <int-e> ...beat that mode, too, and significantly if the program makes use of 64 bit integers.
06:41:02 <int-e> (Or perhaps I missed the number.)
06:42:20 <Jafet> int-e: interesting
06:42:36 <Jafet> Depending on how contrived the benchmark is, the difference could probably be higher
06:54:51 <Z`> hey people, when I write: newtype State s a = (s -> (a,s)) why :t State is (s -> (a, s)) -> State s a, and not State s a -> (s -> (a,s)) ?
06:55:10 <Z`> I missed the constructor State (s -> ...)
06:55:13 <ivanm> Z`: because that's the type of the State constructor
06:55:19 <ivanm> the type State doesn't have a type
06:55:26 <ivanm> but it does have kind * -> * -> *
06:55:27 <Z`> a ha!
06:55:36 <Z`> so :t State returns the type of the constructor
06:55:45 <Z`> thanks ivan
06:55:48 <Z`> ivanm: *
06:56:05 <ivanm> if you _call_ the constructor the same as the type, yes :)
06:58:10 <Z`> so the constructor accepts functions that map s to (a,s) and returns a State type ?
06:58:21 <ivanm> yes
06:58:55 <rwbarton> it is a data constructor for the type State s a so naturally it returns a value of type State s a :P
06:59:09 <rwbarton> or "constructs" a value...
07:08:58 <applicative> @type Left
07:08:59 <lambdabot> forall a b. a -> Either a b
07:20:23 * hackagebot haskell-src-meta 0.6 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6 (BenMillwood)
07:23:39 <luite> benmachine: thanks :)
07:24:12 <benmachine> luite: oh, were you a person who wanted that?
07:24:15 <benmachine> I forget these things :P
07:24:54 <benmachine> luite: oh wait, probably going to do an 0.6.0.1
07:25:14 * benmachine hasn't put generating haddock into his testing sequence yet
07:27:00 <luite> benmachine: yeah i use jmacro in ghcjs, which i ported to 7.6.1 :) jmacro uses haskell-src-meta
07:27:15 <benmachine> oh, fair enough
07:34:35 <benmachine> hmph, haddock doesn't store its interface files in versioned directories
07:34:42 <benmachine> so I can't test multiple versions of haddock
07:36:11 <insitu> @byorgey so maybe you can help me defining filter with cata ?
07:36:12 <lambdabot> Unknown command, try @list
07:36:25 <insitu> @list
07:36:25 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:36:42 <benmachine> insitu: because of lambdabot we tend not to use @ to address people in here
07:37:09 <insitu> sorry,
07:37:52 <otters> I don't even think @nick will ping most people
07:38:31 * benmachine nudges hackagebot 
07:40:23 * hackagebot haskell-src-meta 0.6.0.1 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.1 (BenMillwood)
07:40:47 <insitu> spoiled by twitter, I guess
07:41:38 <insitu> I am still stuck with my filter
07:44:31 <benmachine> insitu: what do you mean by cata exactly?
07:45:23 <insitu> > cata :: Functor f => (f a -> a) -> (Mu f -> a)
07:45:23 <insitu> cata h = h . fmap (cata h) . out
07:45:23 <insitu>  
07:45:25 <lambdabot>   Overlapping instances for GHC.Show.Show ((f a -> a) -> L.Mu f -> a)
07:45:25 <lambdabot>    aris...
07:45:35 <benmachine> oh right
07:45:48 <insitu> I was trying to define filter using cata
07:46:03 <benmachine> as in, list filter?
07:46:06 <insitu> yes
07:46:14 <benmachine> ok so can you define lists using Mu?
07:46:19 <insitu> yes
07:46:27 <benmachine> what f do you use?
07:46:33 <insitu> learning.
07:46:43 <insitu> understanding some papers I read.
07:46:46 <benmachine> err
07:46:47 <insitu> fun.
07:46:56 <benmachine> I think you may have misunderstood my question
07:47:01 <benmachine> I have no idea what question you're answering :P
07:47:11 <insitu> ah! sorry,
07:47:26 <insitu> yes, I see my mistake
07:47:34 * obk pings edwardk
07:47:42 * edwardk is pinged.
07:47:44 <obk> edwardk: I have a mystery on my hands: https://github.com/ekmett/lens/issues/36
07:48:00 <obk> shachaf just tested it and on his machine, it works fine.
07:48:01 <insitu> you mean the f in Functor f
07:48:11 <rwbarton> Has anyone here used LENSES??
07:48:18 <benmachine> insitu: I mean, when you are defining lists with Mu, you use some functor
07:48:19 <obk> We are buffled by why :i At doesn't show any instances.
07:48:22 <rwbarton> I have a slightly complicated task and I'm wondering whether there is a lens library that is a good fit for it
07:48:25 <benmachine> I want to know which functor you're using
07:48:35 <edwardk> ghci> fromList [("hello",12)] ^. at "hello"
07:48:36 <edwardk> Just 12
07:48:42 <insitu> data L a l = Nil | L a l deriving Show ; type List a = Mu (L a)
07:48:50 <obk> edwardk: Exactly.
07:49:01 <edwardk> obk: that was me running it. hrmm
07:49:03 <benmachine> insitu: ok, cool
07:49:13 <edwardk> rwbarton: i'm fond of 'lens' personally =P
07:49:32 <edwardk> obk: do you have multiple versions of containers installed?
07:49:32 <rwbarton> Basically I have a JSON object with one field that is a list of "widgets", I have an IO function that "improves" a widget, and I want to improve all the widgets in the object and write out the rest of the object unmodified
07:49:47 <rwbarton> are lenses at all appropriate here?
07:50:14 <insitu> benmachine I do not see how I can define a sensible (f a -> a) function that I could pass
07:50:16 <obk> edwardk: Yes, I tried installing containers-0.5.0.0 which failed miserably.
07:50:22 <insitu> to cata for defining filter
07:50:30 <obk> I am using 0.4.2.1
07:50:30 <benmachine> insitu: yeah, honestly I don't know the answer either, but I reckon it can be done
07:50:32 <edwardk> rwbarton: probably. you can make a lens that can visit the field, and a traversal that can walk the list (with traverse), compose them, and then use it with the io action
07:50:47 <rwbarton> @hackage lens
07:50:47 <lambdabot> http://hackage.haskell.org/package/lens
07:50:54 <insitu> benmachine I am pretty sure it can be done, just trying to reconstruct it
07:51:03 <rwbarton> ok, I will let you know if I get stuck!
07:51:09 <edwardk> e.g. (yourlens.traverse) (yourioaction) yourjsonobject
07:51:10 <benmachine> insitu: ok so we get cata :: (L a l -> l) -> (Mu (L a) -> l), right?
07:51:33 <rwbarton> traverse is a lens function or from Traversable?
07:51:34 <insitu> benmachine found this definition http://hackage.haskell.org/packages/archive/pointless-haskell/0.0.8/doc/html/src/Generics-Pointless-Examples-Examples.html#filterCata but it does not help much because it uses some more cryptic operators
07:51:35 <edwardk> obk: when you use ghc-pkg list | grep containers what shows up?
07:51:43 <edwardk> rwbarton: Data.Traversable.traverse is a legal Traversal
07:51:49 <benmachine> insitu: and we know what we want l to be, because we want to get a list out
07:51:49 <rwbarton> ah okay
07:51:50 <edwardk> thats in base =)
07:52:17 <benmachine> insitu: yeah, ignore that
07:52:26 <edwardk> i should probably write some json lenses/traversals
07:53:06 <edwardk> obk: i'm wondering if at ghci your problem is you are getting different versions of the packae and so the instances for one aren't showing up when using the other
07:53:14 <obk> edwardk: I unregistered containers 0.5.0.0 and now it works.
07:53:21 <insitu> benmachine exactly. I can define filter' to be like this:
07:53:24 <edwardk> then that was it =)
07:53:30 <insitu> filtr :: (a -> Bool) -> L a l -> L a l
07:53:30 <insitu> filtr p Nil     = Nil
07:53:30 <insitu> filtr p (L a l) | p a = L a l
07:53:30 <insitu>                 | otherwise = Nil
07:53:33 <insitu>  
07:53:53 <edwardk> rwbarton: what json lib are you using
07:54:11 <insitu> benmachine cata (filter' p) does not typecheck
07:54:16 <obk> edwardk: I am eagerly waiting the day I can use containers-0.5.0.0, probably with ghc-7.6, and presumably whatever version of lens will be current that happy day.
07:54:29 <benmachine> insitu: indeed it does not, so don't do that then :P
07:54:36 <rwbarton> aeson
07:55:26 <edwardk> obk: what version of lens are you on?
07:55:36 <benmachine> insitu: ok so our ultimate goal is filterCata :: (a -> Bool) -> Mu (L a) -> Mu (L a), right?
07:55:57 <benmachine> where filterCata p = cata (helper p), and we need to define helper
07:56:29 <edwardk> funny, we pushed up an answer at the same instant =)
07:56:57 <insitu> benmachine: yes.
07:57:12 <benmachine> insitu: ok, so first, what's the type of helper?
07:57:37 <obk> edwardk: Actually I am using data-lens, but I just installed lens-2.6.1 in the hope of migrating to it. I'm running some tests and creating an HUnit test file that demonstrates using "common" scenarios - my developers aren't advanced, and anyway reverse-engineering the "recipes" from the documentation isn't always trivial ;-)
07:57:41 <benmachine> insitu: I mean, there's only one thing it can be, if we set it up like this
07:57:48 <edwardk> rwbarton: hrmm, going to take a look at aeson and see if i can put together a few traversals/lenses
07:57:49 <insitu> :t cata
07:57:50 <lambdabot> forall (f :: * -> *) a. (Functor f) => (f a -> a) -> Mu f -> a
07:58:00 <rwbarton> great, thanks
07:58:05 <edwardk> obk: let me know if you get stuck. i'm happy to help
07:58:18 <obk> edwardk: Will do. Thanks!
07:58:27 <latro`a> @src cata
07:58:27 <lambdabot> Source not found. Do you think like you type?
07:58:29 <latro`a> :|
07:59:30 <insitu> benmachine: this implies that helper :: (a -> bool) -> (L a -> Mu (L a))
07:59:47 <hpc> cata f (Mu xs) = f (fmap (cata f) xs)
07:59:54 <hpc> :k Mu
07:59:55 <lambdabot> (* -> *) -> *
08:00:01 <obk> edwardk: One thing I am missing is something I called ".:" (not sure what the right thing would be). It basically means "flip", allowing me to write: record .: foo .~ 4 instead of foo .~4 $ record. Am I missing something in lens, or do I need to define it myself?
08:00:02 <hpc> :t let cata f (Mu xs) = f (fmap (cata f) xs) in cata
08:00:03 <lambdabot> Not in scope: data constructor `Mu'
08:00:08 <benmachine> insitu: 'L a' isn't a type
08:00:10 <hpc> :t let cata f (In xs) = f (fmap (cata f) xs) in cata
08:00:11 <lambdabot> forall (t :: * -> *) b. (Functor t) => (t b -> b) -> Mu t -> b
08:00:15 <hpc> ha!
08:00:16 <benmachine> insitu: L has two type parameters, remember
08:00:23 <insitu> benmachine: right
08:00:24 * hackagebot hscolour 1.20.3 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.20.3 (MalcolmWallace)
08:00:25 <edwardk> obk: that one i don't provide
08:00:26 <obk> edwardk: Another thing I am missing are ++~ and ++= :-)
08:00:39 <edwardk> obk: Data.Monoid.Lens.<>~
08:00:41 <hpc> :t cata join
08:00:42 <lambdabot> forall (f :: * -> *) a. (Monad f, Functor f) => Mu f -> f a
08:00:49 <hpc> ooh
08:00:58 <insitu> benmachine: should it be helper :: (a -> bool) -> (L a l -> Mu (L a))
08:01:11 <benmachine> insitu: no
08:01:26 <benmachine> insitu: think of what the 'a' variable is in the cata call
08:01:28 <insitu> benmachine: no
08:01:30 <latro`a> having trouble doing the type inference in my head for cata -_-
08:01:35 <edwardk> tryng to think if there is a good place i could put your $$ operator or whatever it should be called
08:01:41 <benmachine> latro`a: I'm not doing it in my head :P
08:01:54 <edwardk> .: are a couple of pretty valuable symbols to lose and they don't fit the semiotics of lens
08:01:58 <latro`a> I know, but if I can't do it in my head I have some trouble seeing why it should be what it is
08:02:06 <latro`a> in particular why the first argument is t b -> b
08:02:33 <edwardk> obk: can you put in a feature request for something like .: with an example type signature on the issues page?
08:02:43 <benmachine> latro`a: it's a bit weird
08:02:47 <latro`a> or I guess rather why fmap (cata f) xs is a t b
08:02:48 <obk> edwardk: Sure.
08:02:57 <insitu> benmachine: helper p should be (a -> bool) -> (f a -> a) for some f
08:03:00 <latro`a> because doesn't that make xs a t (t b)
08:03:05 <latro`a> or is that the whole point
08:03:17 <obk> edwark: Let me tinker with it a bit (precedence and so on) and submit a concrete proposal.
08:03:20 <benmachine> insitu: hmm, I don't think so
08:03:24 <insitu> benmachine: then a should be Mu (L a)
08:03:36 <benmachine> insitu: I think you're getting your a's confused here :P
08:03:37 <benmachine> or I am
08:03:51 <edwardk> sure, you may want to include the precedence motivations as well. i've got a good guess at a precedence for it
08:03:59 <edwardk> it'd be nice to see we converged =)
08:04:01 <insitu> benmachine: but type of cata if clear
08:04:04 <insitu> :t cata
08:04:05 <lambdabot> forall (f :: * -> *) a. (Functor f) => (f a -> a) -> Mu f -> a
08:04:05 <benmachine> insitu: ok let's stick to the type of list elements being a, and say cata :: (f b -> b) -> (Mu f -> b)
08:04:13 <benmachine> insitu: or vice versa, I don't mind
08:04:14 <obk> edwardk: BTW, why <>~ and not ++~ ? Is it because ++ is only defined for lists? Arguably ++ should mean mappend...
08:04:26 <edwardk> (<>) is in Data.Monoid as an alias for mappend.
08:04:47 <obk> edwardk: I guess so. One more thing for the cheat sheet for my developers.
08:04:51 <hpc> is Mu anywhere on hackage?
08:05:05 <latro`a> istr it's like Data.Fix or something
08:05:16 <latro`a> but I'm probably wrong
08:05:28 <edwardk> i could probably be talked into adding ++~, <++~, ++=, and <++= to Data.List.Lens
08:05:35 <edwardk> especially if there was a patch that added them ;)
08:06:00 <edwardk> but they should be the actual list (++) rather than the monoidal version in Data.Monoid.Lens
08:06:27 <edwardk> that way if people wanted to use them for instance selection, etc. it would work
08:07:21 <insitu> benmachine: I think I have some glimpse on what's going on
08:07:59 <benmachine> insitu: I think I have the solution
08:08:44 <benmachine> insitu: also I realised we don't actually need to pass p to helper
08:08:57 <benmachine> insitu: we can have filterCata p = cata helper where helper = ...
08:09:00 <insitu> benmachine: type of helper p should be L a (Rec (L a)) -> Rec (L a)
08:09:25 <benmachine> insitu: that sounds about right (assuming Rec = Mu)
08:09:43 <insitu> oh, sorry. I used Rec because that's what is used in the paper I am reading
08:09:53 <hpaste> peteretep pasted “Error” at http://hpaste.org/74440
08:09:55 <benmachine> insitu: 'sfine, I can cope :P
08:10:05 <peteretep> Hi, I'd like some help understanding the above
08:10:13 <peteretep> I'd have thought that my type class declarations for the data type
08:10:14 * benmachine runs :%s/Mu/Rec/g
08:10:23 <insitu> so helper :: (a -> Bool) -> L a (Mu (L a)) -> Mu (L a)
08:10:24 <peteretep> Insist that x can do Eq and Show
08:10:36 <peteretep> But it seems that I also need to declare those in my function definitinos
08:10:45 <benmachine> peteretep: datatype contexts don't do what you want them to do
08:10:59 <peteretep> benmachine: OK. Is there any way to get this behavior?
08:10:59 <benmachine> peteretep: it's generally acknowledged, in fact, that datatype contexts don't do much useful at all
08:11:12 <peteretep> benmachine: I don't want to have to type out the classes for every function
08:11:13 <benmachine> peteretep: they are eventually going to be removed from the language
08:11:28 <benmachine> peteretep: well, there are a couple of GHC extensions that can help you out
08:11:45 <peteretep> I want to stick within the pure language
08:11:51 <peteretep> If the answer is "no", I guess that's ok :)
08:11:53 <benmachine> peteretep: just type them out then :P
08:12:02 <benmachine> peteretep: you *can* make the two constraints into one
08:12:09 <peteretep> benmachine: How so?
08:12:38 <benmachine> peteretep: by doing something like, class ShowEq a; instance (Show a, Eq a) => ShowEq a
08:12:53 <benmachine> peteretep: actually, even that might require extensions, although fairly innocuous ones
08:13:12 <edwardk> rwbarton: hrmm the nicest version of a traversal/lens for json really wants me to go add a whole new concept to lens. thinking about how best to address embedding/projection pairs ;)
08:13:12 <peteretep> benmachine: I'll look in to that, thanks
08:13:16 <hpc> if you use sufficiently ridiculous extensions, you can even do something like
08:13:23 <hpc> ShowEq a = (Show a, Eq a)
08:13:26 <hpc> iirc
08:13:38 <benmachine> hpc: well, type ShowEq a = (Show a, Eq a)
08:13:39 <hpc> (probably "type ShowEq ..."
08:13:43 <hpc> yeah, that
08:13:44 <c_wraith> yes, the ConstraintKinds extension allows that
08:13:59 <benmachine> and GADTs would allow you to actually put the dictionary in the data type which is what you wanted
08:14:03 <benmachine> anyway.
08:14:23 <benmachine> insitu: I was helping you, I haven't forgotten; but in any case defining "helper" once you have the type is fairly easy
08:14:57 <insitu> benmachine: yes. no pb, just crawling my way into it. Think I got it tooo
08:15:13 <benmachine> insitu: cool :) without any recursion in helper, right?
08:15:26 <insitu> benmachine: of course !
08:15:35 <benmachine> insitu: awesome
08:15:50 <edwardk> peteretep: in general constraints on data types like that _never_ do what you want them to do. it merely ensures when you go to call the constructor that you know those properties hold. it _doesnt_ do the GADT thing and bundle them with the constructor, so you get no value out of it
08:15:54 <insitu> benmachine: wait a minute, still not done
08:16:09 <edwardk> peteretep: this is why we removed them from the language. they aren't in the current language standard
08:16:15 <peteretep> edwardk: Noted, thanks
08:16:21 <edwardk> they are a historical accident of how 'seq' used to work
08:16:37 <hpc> edwardk: ooh, do tell
08:16:41 <hpc> i haven't heard that story
08:16:58 <benmachine> edwardk: is this to do with strictness annotations in data types?
08:17:05 <edwardk> hpc: Seq used to require a class. its all in the history of haskell paper
08:17:20 <hpc> oh, that one; i have heard the story then
08:17:26 <edwardk> benmachine: exactly. to put a ! annotation in then you'd have to have to be able to derive an instance of Seq for the type of the field
08:18:16 <insitu> benmachine: ok got it
08:18:22 <benmachine> insitu: 'k
08:18:26 <edwardk> when they ripped that out of the language, the original motivation for those annotations died, and it only lived on in a couple of misguided constraints on Data.Complex, etc.
08:18:28 <insitu> filter' :: (a -> Bool) -> L a (Rec (L a)) -> Rec (L a)
08:18:28 <insitu> filter' p Nil                 = In Nil
08:18:28 <insitu> filter' p (L a l) | p a       = In (L a l)
08:18:28 <insitu>                   | otherwise = l
08:18:31 <insitu>  
08:19:02 <benmachine> insitu: yeah, that's pretty much what I got (although if you want to paste that much stuff, you should really use hpaste.org)
08:19:11 <benmachine> (not least because it gets lost otherwise)
08:20:03 <insitu> benmachine: you are definitely right. My irc etiquette is really lame
08:20:25 <insitu> benmachine: that's really enlightening!
08:20:39 <insitu> benmachine: looks like I got some epiphany today
08:20:41 <benmachine> insitu: yeah that was fun for me to do too :P
08:20:54 <benmachine> I've been vaguely aware of the technique but not actually used it as such
08:21:04 <benmachine> it's pretty neat
08:21:28 <insitu> benmachine: really. I am trying to understand this from a soft eng perspective
08:21:48 <insitu> benmachine: not sure it really helps write great software though
08:21:50 <benmachine> heh
08:21:58 <benmachine> maybe, maybe not
08:22:11 <benmachine> I'm a mathematician so I don't mind :)
08:22:35 <insitu> benmachine: anyway, thanks a lot for your help. Would not have groked it without.
08:22:39 <astropirate> i'm a magician
08:22:40 <benmachine> np
08:23:05 <latro`a> all haskellers are magicians ;P
08:23:18 <insitu> benmachine: and you were right, I was confused by the 'a' type variable
08:23:24 <astropirate> heh i'm a newbie i'm afraid :(
08:23:31 <insitu> in cata's signature
08:23:38 <hpc> latro`a: except for Oleg; his code is cold hard mysticism
08:23:39 <hpc> :P
08:23:51 <timthelion> hpc: link?
08:24:01 <firstclassfunc> what is haskell's biggest perk?
08:24:12 <timthelion> firstclassfunc: lol
08:24:39 <astropirate> Sorry if this is offtopic..., but coming for "web" background (JS, Node.js, PHP, etc) background, is there much in terms of Freelance work with Haskell?
08:24:54 <timthelion> hpc: who is this oleg guy?
08:25:00 <firstclassfunc> timthelion: OK, top five perks
08:25:02 <hpc> http://okmij.org/ftp/README.html
08:25:52 <timthelion> firstclassfunc: learn it and find out !
08:26:54 <firstclassfunc> yeah, I suppose...
08:27:28 <Jeanne-Kamikaze> astropirate: I don't think so
08:27:35 <timthelion> hpc: damn, that guy's nerdier than I
08:27:51 <astropirate> Jeanne-Kamikaze, i was afraid of that.. :(
08:28:29 <benmachine> astropirate: I imagine some people don't care what you write it in
08:28:58 <timthelion> astropirate: free lance is all about selling things to people who don't know what a programming language IS!  Go out there and start charging 1000$ for simple websites from people who won't ask because they don't know the diference.
08:29:52 <Jeanne-Kamikaze> but if it's freelance, won't they want it in a language that can be read by others, in case they need further development ?
08:30:14 <astropirate> ^ i was about to bring that up
08:30:20 <timthelion> Jeanne-Kamikaze: your grandmothers flower parlor doesn't.
08:30:43 <hpc> timthelion: i don't think grandparents is a sustainable business model ;)
08:30:43 <astropirate> timthelion, well, if i was doin a simple website, nothing beats wordpress/modx etc
08:30:48 <astropirate> 10 minuts of setup
08:30:57 <astropirate> and i'm good to go
08:31:15 <monochrom> on vworkers.com most postings ask for specific languages like php
08:31:16 <timthelion> hpc: something like 30% of europe is old and has memory problems!
08:31:23 <timthelion> hpc: you think that's not sustainable?
08:32:23 <astropirate> haskell needs marketting XD
08:32:44 <firstclassfunc> is there any money to be made in haskell?
08:33:06 <Jeanne-Kamikaze> if you work for yourself, probably
08:33:07 <astropirate> firstclassfunc, i'm trying to figure that out myself
08:33:07 <benmachine> firstclassfunc: there are definitely people who do haskell for their day job
08:33:19 <timthelion> firstclassfunc: well first you have to define an instance of the Mint monad...
08:33:23 <benmachine> cf. Galois Inc.
08:36:22 <blunder_brain> With all the press about haskell lately I think you will see it cropping up more and more
08:36:39 <blunder_brain> I know we are considering using it at my company
08:37:01 <blunder_brain> And I have written a dmeo .apk parser in it (apk is the android executable file format)
08:37:11 <blunder_brain> *demo
08:38:07 <blunder_brain> apparently bump is using it as well http://bu.mp/company/openings
08:44:13 <obk> edwardk: What is the verdict on some variant of Data.Maybe.Lens ?
08:44:33 <edwardk> obk: what would it do?
08:44:52 <edwardk> obk: traverse can be used to traverse the value in Maybe you know =)
08:45:32 <edwardk> this is why there is traverseAt, its just at composed with traverse
08:45:50 <obk> edwardk: If I have a Map, a key known to be in it, and I want to access it or to apply a modification function to it. Currently "at" will return "Just value" and I want to apply a value->value function to it.
08:46:04 <edwardk> obk: look at traverseAt
08:46:10 * obk is looking
08:46:28 <edwardk> that is exactly what it does
08:46:28 <edwardk> traverseAt "hello" +~ 1 $ ...
08:46:43 <edwardk> will add one to the hello entry in the map if its there, and do nothing if it is not
08:47:15 <structuralist> Making sure I have this straight… is "newtype Expr1 = Expr {fold1 : forall val. Alg val -> val}" conceptually the same as "type Expr1 = exists val. Alg val -> val" ?
08:47:17 <edwardk> but if it didn't exist you could have used
08:47:26 <edwardk> at "hello" . traverse
08:48:05 <edwardk> nope. that forall is a real forall
08:48:11 <edwardk> structuralist: if you had
08:48:32 <edwardk> data Expr1 = forall val. Expr { fold1 :: Alg val -> val } -- then you'd have an existential
08:48:45 <structuralist> ah… okay thanks
08:48:46 <Lutin`> Well good morning #haskell
08:48:48 <rwbarton> you basically have forall/exists backwards in your question
08:48:58 <edwardk> forall in the argument is universal before the constructor is existential
08:50:14 <hpc> :t succ
08:50:15 <lambdabot> forall a. (Enum a) => a -> a
08:50:23 <hpc> > succ ((False, False), (False, False))
08:50:25 <lambdabot>   No instance for (GHC.Enum.Enum
08:50:25 <lambdabot>                     ((GHC.Bool.Bool, GHC.Boo...
08:50:28 <hpc> damn
08:52:12 <edwardk> hpc: if one of those had an infinite domain how would it know how to update the next? how woud it know how far 'back' to reset if one wasn't bounded?
08:52:38 <rwbarton> apparently lens doesn't actually build in 7.2, despite specifying base >= 4.3
08:53:10 <edwardk> rwbarton: can you paste the error into an issue on github.com/ekmett/lens/issues
08:53:11 <edwardk> ?
08:53:23 <rwbarton> sure, one sec
08:53:34 <edwardk> 7.2 is sort of the bastard child since it was never actually shipped in a platform
08:54:08 <hpc> edwardk: yeah, that's true
08:54:13 <edwardk> so the only folks who have 7.2 are folks who needed bugfixes over 7.0.x but it has lots of stuff that doesn't work
08:54:24 <hpc> edwardk: i was really hoping for an instance of SOME kind though, even if it has other constraints
08:55:00 <edwardk> hpc: i think it comes down to the fact that there isn't a good canonical choice, so they don't make any
09:00:14 <hpc> i just wrote 16 cases
09:00:22 <Lutin`> Not enough!
09:00:32 <hpc> le gasp!
09:01:07 <Lutin`> So my roommate's crazy girlfriend threw a rock through my windows last night cause she thought it was his
09:01:55 <hpc> be a good citizen and deliver the rock to its correct destination
09:02:35 <hpc> edwardk: the horrible thing is, i am going to have to write those 16 cases again, only subtly different
09:03:00 <hpc> i haven't worked out a better way of doing it, so i figure i will see what i find in real code
09:03:14 <hpc> and refactor based on that
09:11:29 <obk> edwardk: Some (perhaps not so common) cases I am having a hard time to create are (i) <%~ (same as <.~, returns (newValue, updatedContainer) and (ii) something similar to <.~ and <%~, but return the *original* value instead of the updated one.
09:12:22 <edwardk> you can extract the old value by using %%~ with the (,) e functor
09:12:42 <edwardk> foo %%~ (\x -> (x, x + 1))
09:13:09 <obk> edwardk: This is why I need the cheat sheet... creating one teaches me a lot :-)
09:13:19 <edwardk> and <%~ should be there
09:13:47 <edwardk> ghci> :t (<%~)
09:13:47 <edwardk> (<%~) :: LensLike ((,) d) a b c d -> (c -> d) -> a -> (d, b)
09:14:25 <obk> edwardk: So it is. Don't know how I missed it. Sorry.
09:14:31 <edwardk> obk: np
09:14:52 <edwardk> obk: if you added a page to the wiki with some of the operators in it in a cheatsheet form, i'd be happy to contribute to it
09:16:20 <obk> edwardk: I will definitely contribute it, with a .: proposal (or whatever it should be called)
09:19:19 <edwardk> maybe $. and then <$.> can be used for its flipped functorial analogue?
09:21:57 <edwardk> infixr 1 $. would let it nest inside $'s.
09:22:58 <edwardk> hrmm. foo $. bar .~ baz $. quux .~ quaffle    should become (foo $. bar .~ baz) $. quux .~ quaffle -- so i guess i was wrong. infixl 1
09:24:34 <edwardk> makeClassyFor clsName funName fields = makeLensesWith $ lensRules $. lensField .~ (`lookup` fields) $. lensClass .~ const (Just (clsName, funName))
09:25:16 <edwardk> of course there it reads more like >>
09:25:34 <edwardk> and that matches the fixity of it
09:25:39 <edwardk> so infixl 1 $>> ?
09:25:52 <edwardk> makeClassyFor clsName funName fields = makeLensesWith $ lensRules $>> lensField .~ (`lookup` fields) $>> lensClass .~ const (Just (clsName, funName))
09:26:19 <edwardk> and then the functorial version can be <$>>
09:26:44 <ParahSailin_> @t infixl
09:26:44 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:26:56 <ParahSailin_> :t infixl
09:26:57 <lambdabot> parse error on input `infixl'
09:29:43 <latro`a> parahSailin_, infix declarations aren't functions
09:29:48 <k0ral> hello
09:31:14 <k0ral> I work with Network.URI and I would like to hardwrite an URI in the code
09:31:47 <k0ral> I didn't find better than creating a String, parsing it and unwrapping the Maybe monad
09:32:12 <k0ral> is there another way to write directly an URI in the code ?
09:33:02 <k0ral> the ideal would be to have the String parsed at compilation time so that ill-formatted uris prevent compilation
09:40:13 <monochrom> I can see the data type "URI" and its constructor and field names etc
09:41:46 <hiptobecubic> It's always simple things like the definition of "split" here that make me feel like an amateur. http://en.literateprograms.org/Merge_sort_(Haskell)
09:41:50 <geekosaur> hm.  I was unsurprised to find web-routes-quasi was from yesod; also unsurprised that it's already deprecated...
09:42:04 <k0ral> monochrom: right, but it's quite tedious to use those, I would prefer write a bare String and have it parsed at compile time
09:42:18 <hiptobecubic> this lazily counting by twos to split the list in half without an extra traversal and without knowing the size of the list is very clever I think
09:43:04 <hiptobecubic> I did the second version when I wrote out mergesort myself
09:57:22 <juliohm> I found a comment in a haskell function surrounded by @...@, what is this feature?
09:57:48 <juliohm> There is some IDE that will convert the expression inside to show a LaTeX form?
09:58:33 <Sculptor> earmuffs
09:58:37 <Sculptor> j/k - don't have a clue
09:59:17 <donri> juliohm: haddock converts those to html
09:59:34 <juliohm> Interesting, thanks donri.
10:00:38 <donri> @@ is for code with markup
10:00:38 <lambdabot>  is for code with markup
10:00:43 <donri> wat
10:00:54 <juliohm> I really want to start using Haskell in my new projects, but the world is dominated by C++ and Python and i don't know how well suited Haskell is for working with daily I/O operations like reading user specs from files, data tables, etc.
10:01:32 <donri> juliohm: haskell is the world's finest IO language
10:01:33 <juliohm> And the overhead it imposes on high-performance applications where copies are very expensive.
10:01:33 <tylerkahn> juliohm you mean something like this: http://imgur.com/Q0MaU.png
10:02:05 <donri> tylerkahn: vim2hs eh :)
10:02:12 <juliohm> tylerkahn, it's nice, i saw some Haskell code in the past and this UTF feature is really nice.
10:02:13 <tylerkahn> donri: hehe yep!
10:02:22 <juliohm> This is a VIM plugin?
10:02:24 <juliohm> Nice!
10:02:28 <tylerkahn> juliohm: yep pretty nice
10:02:41 <juliohm> let me inspect it...
10:03:18 <juliohm> What plugins do you use for Haskell programming with VIM? I know there is a IDE for Haskell, i don't played with it yet.
10:04:01 <donri> vim2hs, syntastic, cumino, hdevtools, ghcmod, probably others
10:04:25 <juliohm> it seems vim2hs is a huge plugin
10:04:28 <donri> textobj-indent
10:04:53 * juliohm is bookmarking all them. :)
10:04:53 <donri> juliohm: or well structured? :)
10:05:10 <donri> other vim addons like to throw everything in a single file that is then loaded every time you open a file or something
10:05:42 <tylerkahn> i need to spend a day reorganizing my vim plugin/vimrc layout
10:06:12 <donri> https://github.com/dag/dotfiles/blob/master/.vim/vundle.vim here are all vimscripts i use listed
10:06:19 <tylerkahn> oh you use vundle
10:06:40 <tylerkahn> i'm using pathogen but vundle seems cleaner
10:06:56 <juliohm> i didn't knew vundle, i also use pathogen
10:10:43 <beaky> hello
10:11:05 <beaky> apart from ghc itself, what else should I have if I want to hack in haskell?
10:11:19 <beaky> are there any dedicated Haskell IDEs/Debuggers, for example?
10:11:40 <donri> ghci is a debugger that comes with ghc
10:11:48 <donri> you probably want to install the haskell-platform
10:12:11 <donri> that includes cabal which you can then use to get more stuff
10:12:30 <beaky> How do I build Haskell projects?
10:12:35 <bitonic> beaky: cabal
10:14:08 <beaky> so I need to create a .cabal file?
10:14:11 <juliohm> Haskell platform is really nice, it comes with everything a user needs.
10:14:20 <applicative> beaky, a single file with main.hs is built with ghc --make main.hs -o myexec
10:14:22 <juliohm> I forget the name of a Haskell IDE.
10:14:42 <applicative> there is leksah,  but fancy vim and emacs support
10:14:46 <donri> leksah, eclipsefp
10:15:26 <applicative> beaky if your directory is organized ok, the command 'cabal init' will ask you the questions to make the .cabal file
10:16:47 <beaky> wow it's better than autotools ^^
10:17:10 <applicative> beaky: runhaskell my.hs interprets the file after the fashion of python foo.py
10:17:42 <beaky> right
10:18:18 <applicative> but making a cabal file is nice for anything more than 1 module, there is also cabal clean and so on
10:19:32 <donri> and as soon as you're depending on other packages, dependency resolution will work better with a .cabal file
10:19:48 <juliohm> applicative, yes, i think is leskah
10:20:12 <juliohm> i tried it once, very briefly, i have to try it again in the future. Seems a great IDE
10:23:38 <obk> edwardk: I am basically done with samples for record fields and map keys. I am having a hard time figuring out a lens that accesses the n-th list element? 'at' and 'traverseAt' don't work...
10:24:02 <edwardk> 'element'
10:24:10 <applicative> beaky: one main thing  you want to set up is some form of easy back and forth between your editor and ghci
10:24:21 <edwardk> i cant be 'at' because you can't set it to Nothing =)
10:24:48 <obk> edwardk: You could to delete the n-th element from the list...
10:25:00 <beaky> applicative: I use vim ^^
10:25:03 <edwardk> it wouldn't be a legal lens
10:25:15 <edwardk> i should be able to chain two edits and get the same meaning as doing it in one step
10:25:23 <obk> edwardk: Which rules would it break?
10:25:28 * hackagebot shake 0.3.1 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.1 (NeilMitchell)
10:25:49 <edwardk> there is a lens fusion law like fmap f . fmap g = fmap (f . g) that gets violated
10:26:05 <obk> edwardk: Oh, I see, you mean "delete 5th element" means that any update the indices >= 5 after that are affected. I'm not certain this is a killer problem...
10:26:05 <edwardk> over l f . over l g = over l (f . g)
10:26:15 <edwardk> no, any update to that same element
10:26:24 <edwardk> it is a problem. the whole package only works because of these laws
10:26:25 <applicative> beaky: then the vim haskell machinery will take care of it.  there are a zillion users around here.
10:26:58 <edwardk> set l Nothing . set l Nothing is not the same as set l Nothing under your proposed lens
10:27:01 <obk> edwardk: Sure, that problem as well. Ok, I can see some logic in that. But what if I want to just replace the n-th element, or apply a function to it?
10:27:21 <edwardk> there are traversals for it, you can use element and elementsOf
10:27:36 * obk is looking them up.
10:27:42 <edwardk> i'm just explaining why [] can't be an instance of At
10:27:45 <applicative> beaky ReinH has been making intro to haskell videos with his swank vim skills
10:29:32 <edwardk> backback
10:29:50 <edwardk> (hadn't realized i wasn't plugged in)
10:30:36 <beaky> i want to watch those
10:31:11 <edwardk> ghci> element 2 +~ 1 $ [1,2,3,4,5]      ==> [1,2,4,4,5]
10:33:39 <applicative> beaky http://haskelllive.com/
10:33:39 <edwardk> obk: ghci> iwhere (==2) *~ 10 $ [1,2,3,4,5]    ==> [1,2,30,4,5]
10:34:20 <beaky> awesome videos
10:34:26 <beaky> there's only two :(
10:34:36 <edwardk> the difference between those is that element gives you a lens and assumes the element at that position is present, while iwhere and iwhereOf yield a traversal
10:34:37 <obk> edwardk: That is so cool! It seems to me that the next Haskell book, whatever it is, will have a very large chapter on lenses!
10:35:05 * obk adds this to the examples
10:35:40 <edwardk> i've been trying steadily to extend the set of lenses and operations i offer over them, but i've also been trying very hard to stick to my principles that only 'real' lenses and traversals should be admitted.
10:35:59 <edwardk> i find that it forces me to right my thinking about things
10:37:07 <Sculptor> beaky, what videos
10:38:05 <obk> edwardk: I keep getting the feeling that I should modify my code to be lenses in many places instead of doing "direct manipulation", and that it would make things better. But there's a fierce learning curve of all the existing lens building blocks you created...
10:38:14 <beaky> Sculptor: the http://haskellive.com videos
10:38:23 <Sculptor> good job. thanks
10:38:28 <edwardk> obk: i freely admit that i made something with a steep learning curve. =)
10:38:31 <beaky> a series on Haskell Programming by ReinH
10:38:38 <edwardk> obk: i'm happy to add examples to the code, btw.
10:38:59 <edwardk> obk: patches that add more doctests that explain things to users are eagerly accepted. there are lots of them in there now, but there could be easily 4x as many
10:39:02 <obk> edwardk: Actually, if there was an example next to each function, it would make things much easier...
10:39:03 <Sculptor> beaky, 3 ls
10:39:09 <Sculptor> haskeLLLive
10:39:12 <Sculptor> thanks
10:39:33 <edwardk> obk: all the >>>'s in there are actual doctests, that get run by the test suite. if you submit more of them, they'll almost surely go in
10:39:50 <edwardk> it helps me because i get regression testing, and it helps users because they get examples
10:39:55 <obk> Hmmm - I wrote HUnit tests. I will need to convert.
10:40:17 * obk will finish the list of tests first and then see.
10:40:44 <edwardk> if you have an hunit test suite you want to add, toss it in the tests folder and add it to the test-suite list in the cabal file and send a patch ;)
10:40:52 <edwardk> i already have 3 other test suites, whats one more
10:43:08 <applicative> edwardk: did you see the new pipe type, or rather proxy type in the new version of the pipes library
10:43:25 <edwardk> applicative: i talked to tekmo about it, but haven't gone through it
10:43:49 <applicative> its Either (Store a b x) (Store c d x) using the three place Store
10:44:02 <edwardk> not surprised
10:44:34 <edwardk> thats very close to my old bidirectional protocol before lens started. i split things into using those indexed stores to describe asymmetric coroutines
10:45:20 <applicative> you use it as b -> FreeT m ( /\ x ->Either (Store a b x) (Store c d x)) r so to speak
10:46:02 <applicative> i was trying to think of it in terms of the more recent lenses without too much progress
10:47:14 <edwardk> sure. its messages forward or backwards
10:47:30 <applicative> yeah
10:47:31 <edwardk> the ones i had were slightly more complicated because there was an uglier protocol used to ensure progress
10:51:10 <jmcarthur> Store a b x = (a, b -> x)  ?
10:51:39 <applicative> yeah
10:51:57 <jmcarthur> i've found that type useful many times, on my own. what package is that in?
10:52:27 <applicative> in his post  edward gives the isomorphism between LensFamily and d -> Store a b x
10:52:38 <edwardk> jmcarthur: its in Control.Lens.Internal as Context
10:53:27 <edwardk> along with the instance c ~ d => Comonad (Context c d a), etc.
10:53:28 <jmcarthur> applicative: interesting, especially since Proxy is typically used in a kleisli arrow form
10:54:02 <edwardk> applicative: re lenses i don't think there is much you can exploit there. they just happen to use the same characterization
10:54:24 <edwardk> i suppose it opens the door to driving that sort of traversal off the other encodings of Store
10:54:59 <edwardk> e.g. newtype Store c d a = Store { runStore :: forall f. Functor f => (c -> f d) -> f a }
10:55:01 <applicative> which is 'that sort of traversal'?
10:55:20 <kanedank> when I see a => b -> c it's always the same as (a => b) -> c, right?
10:55:34 <edwardk> i mean you could build bidirectional pipes/machines using that store i just mentioned
10:55:41 <applicative> kanedank: yes
10:55:43 <edwardk> it'd be kinda silly but you could ;)
10:55:48 <applicative> no!
10:55:50 <applicative> sorry
10:55:55 <jmcarthur> kanedank: not necessarily
10:56:01 <edwardk> kanedank: no its not
10:56:07 <jmcarthur> kanedank: consider:    Read a => String -> a
10:56:14 <applicative> the => has precedence
10:56:31 <kanedank> so that would be (Read a => String) -> a, right?
10:56:33 <edwardk> a => b -> c  = a => (b -> c) not the other way associativity
10:56:36 <applicative> what precedes it gives the conditions under which what follows it makes sense
10:56:45 <applicative> kanedank:
10:56:47 <applicative> no
10:57:11 <applicative> Read a => String -> a means Read a => (String -> a)
10:57:24 <jmcarthur> :t read
10:57:25 <lambdabot> forall a. (Read a) => String -> a
10:57:28 <applicative> i.e. if a is Readable then you get a function String -> a
10:57:33 <jmcarthur> :t read :: (Read a => String) -> a
10:57:34 <lambdabot>     Couldn't match expected type `(Read a) => String'
10:57:34 <lambdabot>            against inferred type `String'
10:57:34 <lambdabot>       Expected type: (Read a) => String
10:57:45 <aristid> :t undefined :: (forall a. Int -> (Ord a => a))
10:57:46 <lambdabot> forall a. (Ord a) => Int -> a
10:57:52 <jmcarthur> :t read :: Read a => (String -> a)
10:57:53 <lambdabot> forall a. (Read a) => String -> a
10:58:42 <edwardk> read 'p => x' as 'given a constraint 'p' , i can get you a value x'. read 'a -> b' as 'given a value a i can give you a b'. now, a => b -> c  becomes 'given a constraint a, and given a value b, i can give you a value c'    to get that && meaning, you need to associate to the right.
10:59:14 <applicative> kanedank: when you find a type with blah -> (blah => blah) -> blah -- i.e. a constraint => in the middle, this tends to be a little fancy
10:59:17 <edwardk> there are a few very advanced scenarios where you want to use the other associativity but you can effectively ignore that they exist for the next few years ;)
11:00:08 <aristid> applicative: does it ever even make sense without RankNTypes or similar?
11:00:23 <applicative> I was going to say that but wasn't sure
11:00:24 <edwardk> aristid: you really need rank n or constraint kinds to make that sensible
11:00:51 <aristid> otherwise the constraint can be factored to the outside
11:01:13 <edwardk> actually you only need GADTs
11:01:26 <edwardk> because there you get scenarios where you cant legally factor that
11:03:35 <applicative> kanedank: so in my own perception, usually => just seems purely syntactic;  it appears just once in a signature;  it divided the 'real' type signature, which follows, from the statement of the conditions under which it makes sese
11:03:38 <edwardk> aristid: the example of Dict from Data.Constraint in my constraints package can be reimplemented monomorphically for a particular constraint type, say, Eq. then you can define something like the :- i use there and the \\ operator.
11:03:43 <applicative> divides
11:04:18 <edwardk> that would yield you something like (\\) :: Eq a => (Eq b => r) -> EntailsEq a b -> r
11:04:32 <edwardk> and that uses only GADT resolution
11:05:15 <edwardk> and you can make values of EntailsEq a [a], etc.
11:05:23 <aristid> edwardk: Dict itself does use ConstraintKinds though?
11:05:41 <edwardk> aristid: Dict does, but you can make a monomorphic version like i said
11:05:59 <edwardk> data EqDict :: * -> * where EqDict :: Eq a => EqDict a
11:06:14 <aristid> i see
11:06:20 <edwardk> newtype EntailsEq a b = Entail (Eq a => EqDict b)
11:06:30 <edwardk> that requires only GADTs
11:07:52 <edwardk> and then pattern matching on the GADT for EntailsEq in that (\\) i gave above brings into scope the obligation Eq a => EqDict b -- which you can discharge with the Eq a in scope from the signature, and then pattern matching on the EqDict inside of that brings into scope the Eq b that you can use to discharge the Eq b constraint in (Eq b => r), giving you an r.
11:10:42 <aristid> edwardk: so i think it's fair to say that this is a relatively contrived example
11:11:24 <edwardk>  well, it just shows that you can wind up with them using only GADTs. this example is a bit contrived, but i've needed slightly more complicated versions of the same thing in the past
11:11:43 <aristid> :t undefined :: a -> (forall x. Ord x => x)
11:11:44 <lambdabot> forall a x. (Ord x) => a -> x
11:12:14 <edwardk> thats positive position
11:12:30 <aristid> :t undefined :: a -> ((forall x. Ord x => x) -> a)
11:12:31 <lambdabot> forall a. a -> (forall x. (Ord x) => x) -> a
11:12:41 <edwardk> :t undefined :: (forall x. Ord x => x) -> a
11:12:42 <lambdabot> forall a. (forall x. (Ord x) => x) -> a
11:13:11 <edwardk> :t undefined :: (Ord a => a) -> a
11:13:12 <lambdabot> forall a. ((Ord a) => a) -> a
11:13:44 <edwardk> foralls float left over ->'s unlike any other constructor
11:13:59 <edwardk> e.g. forall x. [x] is very different than [forall x. x]
11:14:21 <edwardk> but forall x. y -> x  and y -> forall x. x   are the same thing
11:14:45 <aristid> they are technically constructors?
11:15:16 <edwardk> (->) is a rather special type constructor
11:15:17 <aristid> i would have considered them type-typed parameters
11:15:53 <edwardk> that terminology i think is rather distinctively your own ;)
11:16:17 <aristid> edwardk: it's more analogy than terminology
11:16:54 <aristid> edwardk: it's just the {A : Set} -> A i'm comparing to. perhaps i'm not using the best words
11:17:28 <edwardk> well, [forall x. x] requires ImpredicativeTypes which ghc kinda sucks at right now
11:18:36 <edwardk> (for good reason, they don't play well with other features that IMHO are more valuable)
11:18:36 <edwardk> though that makes me sad, because impredicative types would be a _huge_ win for lens.
11:19:18 <applicative> edwardk: what, you think my idea of explaining the new tekmo pipeline as the composition of a sequence of lenses each of which gives rise to a new lens according to how it gets hit, is a mad scheme?
11:19:47 <edwardk> applicative: no, just don't see how it encodes correctly =)
11:19:58 <applicative> no, i got lost too.
11:20:01 <aristid> applicative: is the new pipes stuff released already?
11:20:17 <aristid> the newest released version seems to be 2.3
11:20:21 <applicative> aristid: yes, what i'm thinking of appeared a couple of days ago
11:20:29 * hackagebot monarch 0.7.0.1 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.7.0.1 (NoriyukiOhkawa)
11:20:55 <aristid> applicative: the PipeF type seems to be unchanged in 2.3? i must be missing something
11:21:06 <applicative> it's awfully simple after all this talk about not being able to talk back to the 'source' and soon
11:21:35 <applicative> aristid: it's  the other module: ProxyF
11:21:59 <aristid> i see
11:22:03 <applicative> there is a different Pipe explanation that depends on it, and the Frame business is deprecated.
11:22:07 <edwardk> applicative: i wonder if he ran into all the problems i did. because that thing didn't compose nicely for me
11:22:44 <structuralist> Is "(exists t. a t) -> b t" the same as "forall t. (a t -> b t)" ?
11:22:51 <edwardk> there is an applicative that you can use on the pipe category that pipes doesn't expose that you can't write once you add that
11:22:56 <ddarius> structuralist: No.
11:22:58 <edwardk> no.
11:23:13 <aristid> oh god Proxy has _six_ type parameters
11:23:20 <aristid> *gasp*
11:23:23 <applicative> structuralist: the second t in the first one is free
11:23:49 <edwardk> applicative: the applicative structure i have on 'Process' in machines becomes illegal when you allow backchannel communication
11:24:12 <edwardk> but also note that this doesn't preclude another machine input type that supports that kind of communication
11:25:26 <applicative> hm, the point of the second store is to send requests upward, he seems to think it's as unproblematic as sending responses downward, choose your orientation
11:25:52 <edwardk> it is
11:26:00 <edwardk> but you lost another mode of composition by adding it
11:26:07 <edwardk> its one that he doesn't provide
11:26:11 <applicative> aristid: the six parameters aren't as alarming as they seem, though they are alarming
11:26:11 <edwardk> but its one i use a lot =)
11:26:15 <aristid> applicative: so does Proxy replace the whole Pipe business?
11:26:19 <applicative> aristid: yes
11:26:39 <aristid> applicative: well 6 parameters means i'm perpetually confused which is which :P
11:26:57 <applicative> he has a new synonym for Pipe, but also the old Pipe is in the separate module if I remember
11:27:07 <applicative> Pipe is a one way Proxy
11:27:26 <aristid> oh the proxy tutorial begins by using Proxy as if it was Pipe
11:27:41 <edwardk> i had a working version of this model at hac boston, but the loss of the ability to feed the same input into two processes, and merge their answers applicatively hurt, because that was my 'out-branching' story.
11:28:02 <applicative> edwardk: and this is what he is missing too?
11:28:06 <edwardk> you'd merge in like i do in machines now, but branch out using the applicatives
11:28:09 <edwardk> yes.
11:28:21 <edwardk> he never offered that form of composition, so of course he doesn't miss it ;)
11:28:23 <applicative> there's no zip
11:28:33 <edwardk> exactly
11:28:55 <applicative> I dimly remember when there was just iteratee and enumerator libraries
11:29:11 <applicative> some biological users dumped enumerator for iteratee on this ground
11:29:36 <applicative> but it was over my head at the time
11:29:36 <ddarius> But the mechanical users were more forgiving.
11:30:15 <applicative> ddarius: right they dont have to mix their dna together
11:30:52 <aristid> applicative: and just to make things more interesting, the pseudo-category formed by Proxy is in the type a -> Proxy foo, right?
11:31:11 <applicative> yes,
11:31:56 <applicative> Proxy foo is a monad ,  a -> Proxy x y a x m r is  a category,
11:32:04 <applicative> i think thats right
11:32:10 <applicative> wait
11:32:34 <applicative> Proxy w x y z m is a monad
11:33:04 <applicative> y -> Proxy w x y z m r is a category
11:34:38 <applicative> of w x y z the outer two are the message you send up and down respectively; the inner two are what they send you
11:35:47 <benmachine> < aristid> applicative: well 6 parameters means i'm perpetually confused which is which :P <-- clearly what we need are type-level records
11:36:02 <beaky> hello
11:36:16 <aristid> benmachine: hah.
11:36:16 <beaky> are there pdf versions of Real World Haskell or LYAH?
11:36:17 <applicative> hi beaky
11:37:07 <monochrom> 6 parameters are a lot :)
11:37:21 <luite> i think the paper LYAH book comes with a pdf
11:37:23 <aristid> applicative: hmm, Proxy somehow feels almost imperative to this noob
11:37:25 <Clint> you could generate a pdf from the rwh source
11:37:29 <monochrom> there are ebook versions of both, but you have to pay
11:37:42 <applicative> aristid: you mean the name?
11:38:04 <aristid> applicative: the model of explicitly requesting responses
11:38:08 <beaky> where can I buy the ebooks
11:38:26 <applicative> he is going with imperative  metaphors.  Beats the frame metaphor though
11:39:02 <monochrom> amazon has kindle version
11:39:43 <monochrom> wait, someone sells LYAH for $193 ?!
11:39:56 <hpc> was that a netsplit?
11:40:04 <applicative> well, its worth it
11:40:11 <aristid> applicative: is the functionality of Proxy equivalent to that of Frame+Pipe?
11:40:14 <monochrom> I detected no netsplit
11:40:33 <applicative> aristid: it's supposed to solve everything
11:40:51 <applicative> I didn't have enough time to figure out Frame before this came out :)
11:40:55 <aristid> applicative: including error handling?
11:41:19 <applicative> error  handling is supposed to be forthcoming
11:41:36 <applicative> i think it isn't supposed to affect the types.
11:43:01 <applicative> aristid: The main contributions of the next release are going to be: A standard interface for pipe morphisms and pipe transformers (i.e. functors between pipe types) A suite of extensions that use this interface, most notably ones that extend pipes with error handling and parsing (If time permits): Tools for optimizing away the overhead of these transformations at compile time
11:43:27 <aristid> that'll be 3.0?
11:44:00 <aristid> applicative: and the pipe transformers will extend ProxyF?
11:44:46 <applicative> by pipe types he means conduit iteratee enumerator, I think
11:45:01 <Z``> I have a function that takes 1 argument and returns another function, but if I apply it like:     (f x) y , haskell errors saying that f cannot be applied to 2 arguments. Hints ?
11:45:16 <aristid> applicative: so Proxy is too powerful for that?
11:45:19 <applicative> its a little confusing, aristid http://www.reddit.com/r/haskell/comments/zg7ev/pipes23_bidirectional_pipes/c652hci
11:45:28 <Nereid> Z``: show us the code
11:45:30 * hackagebot bamstats 0.2 - A program to extract various information from BAM alignmnet files.  http://hackage.haskell.org/package/bamstats-0.2 (KetilMalde)
11:45:48 <Z``> Nereid: I'm ashamed :P Let me think about it for a while
11:45:51 <Nereid> and (f x) y is the same as f x y
11:45:58 <Nereid> at least, what's the type of f?
11:46:19 <Nereid> it had better be x -> y -> z for some x,y,z
11:46:21 <Z``> f :: a -> m b
11:46:23 <Nereid> (same as x -> (y -> z))
11:46:27 <Nereid> yeah, m b isn't a function.
11:46:44 <applicative> ddarius: there's biological user who rejected enumeratee  ^^^
11:47:17 <beaky> eeekk
11:47:30 <beaky> sorry cat walked on keyboard
11:47:32 <applicative> eeekk?
11:47:33 <aristid> applicative: i always hated enumerators and enumeratees in the old framework where only iteratees were first-class and everything else was inversion of control.
11:47:58 <monochrom> Eeek the Cat walked the keyboard
11:48:08 <applicative> aristid: me to but I concede this is because my brain is feeble
11:48:19 <applicative> me too, rather
11:48:38 <monochrom> what is the new framework?
11:48:44 <aristid> monochrom: pipes and stuffs
11:48:49 <monochrom> ah, thanks
11:49:03 <aristid> monochrom: where iteratees are just one special case (the Sink)
11:50:26 <aristid> applicative: so right now for practical applications i think conduits are still more attractive, but if pipes get all their promised glory, the decision will be difficult
11:51:43 <applicative> yeah, it will be clearer in  a couple of months, if things go as planned.  I wish he also had organizational genius, it would be pleasing to join his little army and make some ancillary libraries
11:51:59 <applicative> organizational genius as well, I mean
11:52:45 <aristid> applicative: it'll be really interesting once http client and server libraries exist for pipes
11:53:39 <applicative> what it's not enough that he exports type called Client and Server?
11:53:45 <applicative> types
11:54:02 <edwardk> now i just need to finish machines and sweep both of them aside ;)
11:54:28 <aristid> edwardk: you'll surely win, with 8 type parameters :P
11:54:38 <edwardk> aristid: heh
11:54:45 * applicative noticed machines but has so far refused to look thinking he'll be buried
11:54:56 <edwardk> applicative: its actually quite simple
11:56:37 <aristid> edwardk: interesting that Machine uses Monad m => and not Identity like most monad transformers
11:56:58 <edwardk> i find this leads to a saner model.
11:56:59 <aristid> but MachineT has just four type parameters?
11:57:18 <edwardk> you can always then compose a pure machine with a machine transformer, without having to lift it,etc.
11:57:25 <edwardk> and it means that the simple stuff keeps simple signatures
11:57:33 <aristid> edwardk: would using Monad m => also work for other monad transformers, or is this specially for MachineT?
11:58:01 <edwardk> aristid: it would work for the mtl, etc. but it requires a rank 2 type
11:58:21 <edwardk> and you occasionally wind up with situations where you still need to dumb it down to t Identity a
11:58:36 <applicative> Step needs a Skip x  constructor so I can write machine fusion  version
11:58:42 <edwardk> but they are few and far between
11:59:26 <edwardk> applicative: then you have to worry about quotienting out the placements of those nodes in every use-site
11:59:48 <edwardk> that is a big burden to place on users of the library.
12:00:21 <applicative> probably, I did it with the old pipe library.  the burden on the user would have been immense....
12:00:32 <aristid> edwardk: so Step looks like PipeF, but with an additional Stop constructor
12:00:56 <edwardk> aristid: pretty much. but notice the 'k' used for awaiting
12:01:14 <edwardk> also note that plans are built up CPSd, and then compiled to machines
12:01:33 <edwardk> you write a plan in monadic style, the using repeatedly or one of the other compilation combinators to get a machine out of it
12:01:41 <applicative> I was going to say, k is clearly the joker in edwardk 's pack
12:02:14 <edwardk> when k = (->) or (==) you get a very traditional pipe/conduit model
12:03:15 <aristid> edwardk: where you have a Category instance
12:04:00 <edwardk> aristid: there is one on Machine that uses instance (Monad m, k ~ Is) => Category (MachineT m k)
12:04:18 <aristid> edwardk: oh the Source is genius! by using forall k. you make sure it's impossible to give the Await constructor
12:04:24 <edwardk> aristid: yep
12:04:55 <edwardk> aristid: the reason for the rank3 type in plan for how i encode await is so that Source doesn't have to have _any_ constraint on k
12:05:13 <edwardk> that enables it to work without crazy defaulting
12:05:50 <aristid> edwardk: now PlanT is crazy CPS'd :P
12:06:16 <aristid> edwardk: you should write a GHC extension that CPSes types for you, so stupid people like me can read them.
12:06:21 <edwardk> aristid: yes, but its to make it so type inference works right on Source, and so that big plans don't slow down asymptotically
12:07:10 <edwardk> aristid: if you compose something with >+> and then >>= the result, you get a huge asymptotic hit with pipes. its not O(1).
12:08:25 <aristid> edwardk: and that's where Plan comes in?
12:08:43 <aristid> edwardk: a normal MachineT still takes that asymptotic hit, if used directly?
12:08:44 <edwardk> aristid: yeah. you can build plans and >>= is always cheap
12:08:58 <edwardk> Machines don't have the argument to use >>= at all.
12:09:02 <Ferdirand> @type (>+>)
12:09:03 <lambdabot> Not in scope: `>+>'
12:09:19 <edwardk> so there is a sapir whorf issue. you can't express the slow thing ;)
12:10:02 <aristid> fair nuff
12:10:26 <aristid> edwardk: so why not always use PlantT if it's faster to >>=?
12:10:37 <aristid> or possible at all.
12:10:54 <edwardk> because machines give you cheaper access to the outermost constructor to determine what you are doing next
12:10:54 <edwardk> plans give you cheaper access to construction
12:10:59 <applicative> Ferdirand: he was referring to pipe composition which is defined differently in different attempts to realize this idea
12:11:47 <edwardk> i _might_ be able to make a usable cps'd machine that can derive the correct asymptotics. i can provably not derive a non-cps'd plan that does though ;)
12:11:55 <Ferdirand> applicative: well, i'm trying to follow the discussion but this is all way over my head, don't mind me
12:12:28 <edwardk> Ferdirand: basically 'machines' uses a much more complex encoding in order to get faster asymptotics for common operations.
12:12:48 <applicative> its about edwardk s plan for total domination in the pipe / iteratee/ enumerator library competition
12:12:53 <aristid> edwardk: so the idea is to have small parts that are composed monadically as PlanTs and then converted to Machines?
12:13:14 <edwardk> aristid: yep. you get the convenience of monadic syntax to build up machines, then you get the convenience of a category to compose them
12:13:22 <monochrom> "edwardk: The Rise of The Machines"
12:13:40 <edwardk> aristid: and you can generate machines from other models as well. e.g. there are Mealy and Moore Machines as well.
12:13:48 <applicative> edwardk: tekmo plans of a ghc plugin to get rid of unnecessary bings
12:13:50 <applicative> binds
12:13:59 <edwardk> i wish him luck
12:14:15 <applicative> haven't seen too much  use of the plugins infrastructure
12:14:51 <Zaphod_Beeblebro> hello?
12:14:56 <edwardk> i've actually been thinking about ripping out the  fixed point initial encoding of machines entirely and switching to a fully cps'd form
12:15:11 <applicative> the strictness plugin was pretty amusing
12:15:14 <edwardk> but it has the downside that it takes an already difficult to understand API and makes it nigh impenetrable to most people
12:15:25 <aristid> edwardk: you'd keep the Plan type though?
12:15:29 <applicative> if there's cps involved i wont use it
12:15:32 <edwardk> yep
12:15:36 <applicative> not because cps is wrong
12:16:04 <aristid> applicative: but?
12:16:05 <Zaphod_Beeblebro> i wished to create a program in haskell, but it redirected to a ton of other things, and my only experience in coding is from pascal.Which other language do you recomend me to review at in order to get haskell more clear?
12:16:11 <applicative> why is  cps such torture.
12:16:42 <applicative> Zaphod_Beeblebro: what redirected  you to a ton of other things
12:17:08 <edwardk> applicative: the general goal is that the cps'ing should be invisible to you. thats why you build machines from plans.
12:17:23 <Zaphod_Beeblebro> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
12:17:27 <applicative> Zaphod_Beeblebro: elementary haskell is surely among the most straightforward of programming languages
12:17:48 <applicative> @where lyah
12:17:48 <lambdabot> http://www.learnyouahaskell.com/
12:17:54 <Zaphod_Beeblebro> does haskell has any sort of gui like delphi is for pascal?
12:18:07 <applicative> no, you need an editor
12:18:27 <Zaphod_Beeblebro> notepad++ for instance?
12:18:28 <applicative> you can also open the  ghci and just start defining things
12:18:53 <applicative> Zaphod_Beeblebro: yes, a lot of the good haskellers use Notepad++ on windows
12:18:56 <aristid> applicative: i guess it'll take a few years until I/O in haskell is settled into a semi-comfortable state
12:19:31 <applicative> aristid: I hadn't noticed any difficulty with 'lazy io' but I'm not an industrial user....
12:20:19 <applicative> Zaphod_Beeblebro: I think they configure it to make it easy.  Have you installed the haskell platform?
12:20:25 <edwardk> honestly i tend to just write my io using io ;)
12:20:51 <applicative> IO a rocks
12:20:58 <aristid> i stream my http responses using Source like a good boy :P
12:21:21 <applicative> aristid: you're so *professional*
12:21:47 <aristid> applicative: i know right!
12:22:02 <applicative> olegite zombie!
12:22:02 <aristid> hmm that statement is ambiguous
12:22:58 <applicative> Zaphod_Beeblebro: you need the Haskell Platform (a monster download) Notepad++ and the command prompt.
12:23:26 <applicative> Zaphod_Beeblebro: inside the command prompt if you type ghci.exe you can follow the examples in the Learn You a Haskell  tutorial
12:23:50 <hnsz> Zaphod_Beeblebro: There is a page about that on the haskell wiki. one sec
12:23:51 <Zaphod_Beeblebro> thanks applicative, i already installed the platform
12:23:54 <applicative> Zaphod_Beeblebro: there is a micro tutorial that is like the ghci here http://tryhaskell.org/
12:25:53 <applicative> Zaphod_Beeblebro: then you're ready.
12:26:26 <hnsz> Zaphod_Beeblebro: http://www.haskell.org/haskellwiki/Windows
12:26:40 <hnsz> Zaphod_Beeblebro: You're on windows correct?
12:29:02 <hnsz> Zaphod_Beeblebro: When you use GHCi you can set an editor of choice with :set editor "<path to editor executable>" you can use :edit :reload :main
12:29:36 <Zaphod_Beeblebro> okay hnsz, gimme a second to type that in cmd :P
12:30:04 <hnsz> Zaphod_Beeblebro: In ghci itself
12:35:41 <applicative> edwardk: you are saying that your sources can be zipped together, at least under suitable conditions
12:36:23 <edwardk> applicative: yes
12:36:31 <edwardk> well, not my sources
12:36:40 <edwardk> though that happens through tees, and wyes
12:37:05 <edwardk> i can zip together two processes that want to run on the same input
12:37:06 <hiptobecubic> 7.6.x is out now, should I still be reporting bugs in 7.4.2? I can't upgrade yet.
12:37:46 <applicative> right, like combining folds
12:38:10 <applicative> I haven't figured this out clearly
12:40:04 <applicative> oh i see the T type is dedicated to this purpose
12:40:11 <Z``> I'm trying to write an execState :: State s a -> s -> s.  I thought to write it as execState f s = f s, but that isn't right it seems
12:40:16 <Z``> any hints?
12:40:37 <benmachine> Z``: well, you need to unpack the State
12:40:45 <benmachine> using either pattern matching or runState
12:40:46 <edwardk> applicative: yep. a Tee is a machine build on a 'T' for input and is used to merge inputs
12:40:55 <Z``> like let (a, s) = f ?
12:40:57 <aristid> :t runState
12:40:59 <lambdabot> forall s a. State s a -> s -> (a, s)
12:41:02 <edwardk> applicative: that gives you a machine where you can deterministically block on either of two input sources
12:41:13 <benmachine> Z``: no... do you understand how State works?
12:41:18 <edwardk> otoh, a 'Wye' lets you do non-deterministic blocking
12:41:21 <Z``> benmachine: yes
12:41:31 <benmachine> Z``: run me through your understanding briefly
12:41:36 <anotherone> someone knows a web server with haskell cgi????
12:41:48 <edwardk> e.g. it allows you to block waiting with a "just give me an input from either the left or the right, whatever is available." style as well
12:41:54 <Clint> anotherone: what?
12:42:02 <Z``> type state is a state transition function, a function that maps s to a tuple (a, s)
12:42:06 <aristid> edwardk: do you use Machine for something if you don't use it for I/O?
12:42:09 <anotherone> i'd like to use a web server with haskell support
12:42:09 <ParahSailin_> yesod
12:42:17 <anotherone> unless lua or php
12:42:27 <aristid> ParahSailin_: yesod is not a web server
12:42:30 <hnsz> LUA!
12:42:31 <hnsz> :D
12:42:33 <edwardk> aristid: we use it here for processing data from sql queries, etc.
12:42:40 <anotherone> lua is wonderful really
12:42:49 <aristid> edwardk: so it's still stream processing
12:42:52 <anotherone> but i'd like to try haskell now
12:42:53 <hnsz> LUA is too nice :)
12:42:53 <ParahSailin_> aristid, he's asking a dumb answer, im giving the dumb answer he's looking for
12:43:10 <edwardk> aristid: yeah
12:43:12 <aristid> ParahSailin_: no, there are better answers i think
12:43:13 <anotherone> lua easy light powerful perfect
12:43:18 <aristid> like warp, which is a haskell web server
12:43:24 <anotherone> warp?
12:43:32 <aristid> @hackage warp
12:43:32 <lambdabot> http://hackage.haskell.org/package/warp
12:43:45 <anotherone> thank you guys
12:44:09 <Clint> mighttpd2 is another haskell web server
12:44:17 <anotherone> i never guessed that one day i will see a language so powerful than C is
12:44:23 <anotherone> and functional language
12:45:08 <anotherone> mighttpd2
12:45:14 <anotherone> thank you guys
12:45:15 <aristid> edwardk: for the actual I/O you don't need the whole pipe/machine/conduit/iteratee/orange juice stuff, but once you do stream processing it starts being practical IMHO. i suppose your machine stuff is as always more powerful than everything else.
12:46:54 <edwardk> aristid: pipes and conduits have given more thought to how to deal with resource finalization, etc. so its not a pure win for machines yet ;)
12:47:33 <raek> Z``: if you define State as "newtype State s a = S (s -> (a, s))", and a function f has type "s -> (a, s)", then "f" is not of type "State s a", but "S f" is.
12:47:59 <Z``> I wrote it as: execState (State f) s = let (v, s') = f s in s'
12:48:12 <raek> to run a state transition your runner function must first extract the function ("f") from the wrapper ("S")
12:48:32 <Z``> raek: thanks, that was a key information I was missing (that f is not of type State s a)
12:48:53 <applicative> aristid: did you understand the objection mr lato made to all these inadequately oleglike libraries, viz:
12:48:54 <applicative> The traditional design of an iteratee package is to provide enumerators that wrap access to a cursor in a closure, preventing the cursor from leaking.  Packages like pipes or conduit that require a monadic region for safe access to input hold the cursor as data and don't provide enumerators-as-closures.  In essence they evolved from cursor to enumerator back to cursor
12:48:59 <aristid> edwardk: wouldn't PlanT and MachineT work just fine with any regions/resource library?
12:49:13 <edwardk> probably
12:49:18 <aristid> applicative: i did not read that objection until 1 second ago
12:49:22 <raek> Z``: only the 'type' keyword intoduces type synonyms. definitions that use 'data
12:49:38 <raek> ' and 'newtype' introduce completely new types
12:49:49 <applicative> http://johnlato.blogspot.com/2012/06/understandings-of-iteratees.html for what it's worth.  I couldn't understand the objections he considered decisive
12:50:10 <edwardk> like i said, they have given it more thought than i have. there are probably a few places i could add some better combinators for making it easier to use though
12:50:22 <applicative> He thinks 'stream processing' is of no interest, that has nothing to do with the real problem
12:50:30 <raek> so if you would had written "type State s a = s -> (a, s)", then f would have been of type State s a
12:50:31 <aristid> applicative: kind of weird given that one of the impulses for this whole conduit stuff was unhappiness with resource finalization with the enumerator library
12:52:31 <aristid> applicative: and i think enumerators in the iteratee model are hard to use. what's wrong with monadic regions?!
12:52:33 <raek> Z``: this definition looks good to me.
12:52:42 <Z``> thanks raek
12:55:18 <raek> Z``: also, you might want a version that keeps the value produced by the transition
12:55:56 <applicative> he thinks monadic regions are necessary to handle 'resource management' for output, but iteratees already solved it for input.
12:56:02 <raek> in this case the running function only removes the State wrapper
12:56:31 <raek> :t runState
12:56:32 <lambdabot> forall s a. State s a -> s -> (a, s)
12:57:23 <Z``> raek: I wrote evalState that returns v. Do you mean that? (  evalState (State f) s = let (v, s') = f s in v )
12:57:23 <raek> some people define the State data type as a record to get this runState extraction function for free
12:57:24 <Z``> ah no
12:57:25 <Z``> ok, I will write runState too
12:58:02 <aristid> applicative: in context i don't read it as a devastating critique
12:58:37 <Z``> ok, that was easier. runState (State f) s = f s
12:58:47 <applicative> aristid: yeah, it doesn't seem so, but I wondered if he had hold of some genuine desiderata I hadn't grasped yet
12:59:28 <raek> Z``: you can even remove s from both the LHS and the RHS :)
12:59:29 <aristid> applicative: well it's true that input resource management is implicit with iteratees because there is no explicit source cursor that could ever be leaked
12:59:37 <aristid> applicative: but i think that also reduces expressiveness
13:00:15 <Z``> raek: oO mind blowing
13:03:57 <raek> these "interactive tutorial seesions" seem to start spontaneously every now and then in this channel...
13:04:06 <nolrai> What does "package vector-0.9.1-5feabc311645326f59f50b0ea9890e1a is shadowed by package vector-0.9.1-04dd5c58c224b03a4dc90091cf93a01" mean?
13:04:54 <benmachine> nolrai: you probably have one installed locally and one installed globally, and it's telling you ghc can only see one of them
13:05:02 <benmachine> or, well, ghc only uses one of them
13:05:32 * hackagebot xdot 0.2 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2 (DennisFelsing)
13:05:45 <nolrai> huh..but they shuld be the same package right? Why would it matter?
13:06:46 <nolrai> I'm trying to get Agda to work..would uninstalling one of them somehow fix it?
13:07:13 <nolrai> (Oh I bet apt-get installed the Agda stuff in a werid place...or something?)
13:07:53 <hpaste> Z` pasted “Avoid intermediate variables” at http://hpaste.org/74444
13:08:03 <Z``> can anyone hint me on this one --^
13:08:21 <aristid> nolrai: it probably installed it globally, and you already had a local vector
13:08:36 <aristid> nolrai: it's best to avoid mixing apt-get and cabal install for the most part
13:09:27 <nolrai> that makes sense. I just needed to install agda-mode for emacs, aprarently, and that is a apt-get install.
13:10:18 <nolrai> Anyone here know how to use agda with out using emacs? Is that posible?
13:10:34 * hackagebot ghc-vis 0.3 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.3 (DennisFelsing)
13:11:31 <aristid> nolrai: agda-mode comes with cabal install Agda
13:11:46 <aristid> nolrai: it ends up in $HOME/.cabal/bin then
13:12:19 <applicative> nolrai: I think you would be in for what is called a world of pain
13:12:23 <aristid> nolrai: agda without emacs is _technically_ possible but not reasonable.
13:12:31 <raphie> I heard there's a GHCi bot in here
13:12:40 <applicative> nolrai: I get by with knowing about 6 general emacs keybindings
13:12:44 <aristid> raphie: lambdabot.
13:12:50 <applicative> > take 3 "raphie"
13:12:51 <lambdabot>   "rap"
13:12:56 <raphie> sweet
13:12:59 <raphie> > last [1,2..]
13:13:03 <lambdabot>   mueval-core: Time limit exceeded
13:13:11 <raphie> ahh
13:13:24 <raphie> thanks aristid!
13:13:38 <applicative> you can talk to it separately
13:15:07 <raek> Z``: one moment
13:15:26 <applicative> nolrai: there is a huge amount of back and forth between you and the typechecker, so some integration with an editor is needed. The choice of emacs, I dont know.
13:16:24 <nolrai> Well I guess knowing emacs is probobly more useful then knowing Agda..so I can look at it as homework sort of.
13:16:24 <hpaste> raek annotated “Avoid intermediate variables” with “Avoid intermediate variables (annotation)” at http://hpaste.org/74444#a74445
13:16:36 <aristid> applicative: emacs is certainly extensible enough to allow it, that's an advantage
13:17:00 <aristid> applicative: and i'm glad it's emacs and not eclipse.
13:17:02 <Z``> raek: take your time.thanks
13:17:47 <k0ral> hello
13:18:04 <applicative> nolrai: that was my attitude. Like I said mostly you just need emacs knowledge for saving and navigation, the agda specific bindings are here http://wiki.portal.chalmers.se/agda/agda.php?n=Docs.EmacsModeKeyCombinations
13:18:16 <raek> Z``: I just realized I didn't check what the actual question was...
13:18:41 <k0ral> I'm having conflicts between record fields name, I currently prefix with various number of underscores "_" to distinguish each version, but I find it quite ugly
13:19:02 <Z``> raek: question is how I could avoid the use of a temp variable (1st version), and calling runState (2nd version)
13:19:07 <Z``> and=or*
13:19:11 <k0ral> A { _a :: X }, B { __a :: X}, C { ___a :: X }
13:19:26 <k0ral> is there a better solution to this conflict problem ?
13:19:54 <shachaf> Yes. Anything is better than n _s. :-(
13:20:21 <applicative> k0ral: but why not give eveything more descripting names
13:20:27 <applicative> descriptive
13:20:33 <benmachine> k0ral: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields maybe?
13:20:40 <hiptobecubic> How does one represent XOR in ascii?
13:20:53 <hiptobecubic> I guess  /=  kind of works
13:21:10 <raek> well, you could improve my version by replacing "(State g) = m v; in g s'" with just "in runState (m v) s'"
13:21:18 <benmachine> hiptobecubic: ^ is sometimes used, but can be confused with exponentiation
13:21:37 <raek> since runState unwraps a state transition function
13:21:51 <hiptobecubic> benmachine, good enough. thanks
13:21:58 <k0ral> applicative: of course I could, but it would mean prefixing every field with the record name, that makes it unecessarily verbose
13:23:02 <k0ral> applicative: couldn't GHC infer which field I'm referring to using the context type ?
13:23:09 <raek> Z``: also your second commented version looks like this: "let ...; (w, s'') = runState (f v) s' in (w, s'')", which can be replaced by just "let ...; in runState (f v) s'"
13:23:28 <applicative> k0ral: it does a bit as benmachine noticed
13:23:36 <Z``> thanks raek -- will simplify it
13:23:45 * applicative hasn't used DisambiguateRecordFields
13:23:49 <raek> these is no need to break up a pair into w and s'', just to make the same pair again
13:23:54 <benmachine> applicative: the record extensions are underrated
13:24:03 <benmachine> unfortunately this one is probably not quite what you want
13:24:17 <Z``> raek: ah, just saw your annotation. Thanks!
13:24:43 <applicative> benmachine: yeah, I hated them til I discovered RecordWildCards.  I'm waiting for the others to make sense
13:24:54 <benmachine> applicative: I like puns
13:26:31 <k0ral> how unsafe is DisambiguateRecordFields extension ?
13:27:00 <benmachine> k0ral: unsafe? it's purely syntactic, as far as I can tell
13:27:32 <k0ral> benmachine: so why isn't it enabled by default ?
13:27:33 <benmachine> k0ral: well, not *quite*. but it could easily be implemented as a source transformation
13:27:47 <benmachine> k0ral: well, why isn't TypeSynonymInstances enabled by default?
13:27:59 <benmachine> k0ral: because GHC is a standards-compliant compiler (...mostly)
13:28:03 <chico39_> someone knows the card is to quit smoking? http://reducercard.xopie.com
13:29:12 <benmachine> ok I don't get DisambiguateRecordFields at all
13:29:13 <parcs`> must.. not.. click obvious spam link.. /s
13:29:39 <geekosaur> @where ops
13:29:39 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
13:30:24 <hpaste> raek annotated “Avoid intermediate variables” with “Avoid intermediate variables (annotation) (annotation)” at http://hpaste.org/74444#a74447
13:30:26 <k0ral> benmachine: would lenses help on that matter ?
13:30:32 <benmachine> oh I'm silly
13:30:41 <raek> Z``: cleaned up version ^
13:30:46 <benmachine> k0ral: erm. unclear
13:31:24 <Z``> raek: looks very nice.thanks
13:31:37 <benmachine> k0ral: it's... possible, but I can't imagine it'd be pretty
13:32:24 <benmachine> k0ral: presumably your types have other fields as well?
13:32:44 <raek> Z``: in the last version you can neatly read that running the compound transition involves running the first one and then running second one, which you get by applying f to the value of the first one
13:33:01 <k0ral> benmachine: indeed
13:33:33 <k0ral> benmachine: plus they're all instance of a class that has also a conflicting "member function" name
13:33:34 <Z``> raek: how did you align the equations at = ? my emacs mode is hating me
13:34:06 <raek> Z``: oh, I did that manually... :)
13:34:16 <benmachine> k0ral: sounds crazy :P
13:34:22 <Z``> raek: ok :D (looks very clean, thanks!)
13:34:28 <raek> please tell me if you find out how to do it, though :)
13:34:36 <Z``> haha, ok. sure thing!
13:34:40 <benmachine> k0ral: the only thing you could do with lenses would be to create a typeclass so that you could overload the lens name
13:34:49 <benmachine> k0ral: that would be ok but still not very pretty
13:34:55 <benmachine> k0ral: and would introduce ambiguity
13:35:21 <benmachine> k0ral: DisambiguateRecordFields maybe together with RecordWildCards can get you much of the way there except
13:35:40 <benmachine> DisambRF seemingly needs a module per record :/
13:35:43 <benmachine> not sure what the deal with that is
13:36:19 <k0ral> alright, I'll try to make my way with those extensions, thank you
13:36:33 <benmachine> it probably won't be helpful
13:36:37 <benmachine> it's very *nearly* helpful
13:36:39 <benmachine> but not quite there
13:38:03 <k0ral> GHC is still unhappy even with the Disambiguate... extension, when using the same function name between a record field and a typeclass function
13:41:06 <strager> I have three functions: c :: A -> B -> m C ; a :: m A ; b :: m B
13:41:32 <strager> I thought I could combine them with `ap` or (<*>) but the types don't match.
13:41:43 <strager> How do I combine them properly?
13:41:59 <shachaf> @ty (join .) .: liftM2
13:42:00 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
13:42:20 <strager> hmm, thought I tried that; lemme try again
13:42:22 <parcs`> join (liftM2 c a b)
13:42:47 <strager> that works.  Wonder what I was doing wrong last time.
13:42:49 <strager> Thanks.
13:51:58 <Soultaker> suppose I have a list of Maybe Int's, how can I take the maximum of the values that aren't Nothing, such that the result is (Just x) if there is a result or (Nothing) if all elements of the list are Nothing?
13:52:18 <Soultaker> e.g. f [Nothing, Just 3, Nothing, Just 7, Nothing, Just 1] should return (Just 7)
13:52:27 <Soultaker> and e.g. f [Nothing,Nothing,Nothing]  should return Nothing
13:52:36 <kanedank> what would the type signature of a function that prints out a data structure layout? foo -> IO ()?
13:52:48 <shachaf> Soultaker: If there was a "maximum" function that returned a Maybe it would be nicer.
13:52:57 <shachaf> @ty catMaybes
13:52:58 <lambdabot> forall a. [Maybe a] -> [a]
13:53:17 <lispy> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/promotion.html#promoted-literals
13:53:19 <shachaf> @ty \ms -> case catMaybes ms of [] -> Nothing; ns -> Just (maximum ns)
13:53:20 <lambdabot> forall a. (Ord a) => [Maybe a] -> Maybe a
13:53:20 <Soultaker> yes, I tried to use catMaybe, but that doesn't work for all-Nothing
13:53:26 <lispy> type level nats are usable now
13:53:40 <Soultaker> shachaf: hmm, that's the nicest way?
13:53:47 <shachaf> Soultaker: If you want to use the library function "maximum" you'll have to check for [] yourself.
13:54:07 <ddarius> mconcat . map (Option . Max)
13:54:10 <Soultaker> well I just want the maximum; I'm happy with something along the lines of fold max or something too
13:54:13 <shachaf> Soultaker: It'd be nicer to have a safeMaximum :: Ord a => [a] -> Maybe a
13:54:53 <Soultaker> ddarius: I'm not sure I understand that; where do Option and Max come from?
13:55:10 <ddarius> @hackage semigroups
13:55:10 <lambdabot> http://hackage.haskell.org/package/semigroups
13:55:54 <applicative> > let  ms = [Nothing, Just 2, Just 1] in maximum [x | Just x <- ms]
13:55:55 <lambdabot>   2
13:56:08 <shachaf> ddarius++
13:56:41 <shachaf> Maybe something like fmap getMax . getOption . mconcat . map (Option . Just . Max), though...
13:57:07 <Soultaker> that doesn't look very simple either :p
13:57:30 <ddarius> @hackage newtype
13:57:30 <lambdabot> http://hackage.haskell.org/package/newtype
14:00:41 <typoclass> > let f [] = Nothing ; f xs = Just (maximum xs) in f $ catMaybes [Just 4, Nothing, Just 7, Nothing, Nothing] -- Soultaker, has anyone proposed the obvious thing yet? works for empty and all-Nothing lists
14:00:43 <lambdabot>   Just 7
14:01:11 <shachaf> typoclass: That's what I did above, with an inlined f.
14:02:09 <typoclass> er right, in the @ty. sudden-onset blindness.
14:02:28 <Soultaker> that seems reasonably readable; I was hoping there was something even simpler since it seems a reasonably basic operation
14:02:53 <shachaf> Soultaker: It would be nice if the standard library had more safe functions.
14:03:19 <Soultaker> definetely, that could have helped me here.
14:03:26 <Soultaker> *definitely
14:03:32 <parcs`> > maximum [Nothing, Just 3, Nothing, Just 7, Nothing, Just 1]
14:03:33 <lambdabot>   Just 7
14:03:58 <applicative> > foldr max Nothing [Nothing, Just 1, Just 2]
14:03:59 <lambdabot>   Just 2
14:04:06 <Ferdirand> > minimum [Nothing, Just 0, Just 1]
14:04:07 <lambdabot>   Nothing
14:04:09 <Ferdirand> it's a trap
14:04:10 <shachaf> Oh, hah.
14:04:20 <Soultaker> oh, that works?
14:04:23 <typoclass> is there an Ord instance for Maybe ...?
14:04:28 <shachaf> Soultaker: Maybe's Ord instance happens to work for that.
14:04:33 <shachaf> Because Nothing < Just _
14:04:40 <Soultaker> hmm, I see
14:04:41 <nolrai> Why is there no cabal remove comand?
14:04:50 <shachaf> Soultaker: Note that that'll still crash if you give it an empty list.
14:04:54 <shachaf> (As opposed to all-Nothing.)
14:04:55 <parcs`> nolrai: because cabal is not a package manager
14:05:01 <applicative> > foldr max Nothing []
14:05:02 <lambdabot>   Nothing
14:05:03 <Soultaker> hmm, in this particular case that would actually work for me
14:05:11 <shachaf> Well, applicative's thing won't.
14:05:24 <typoclass> nolrai: good question, maybe it should have one ...
14:05:40 <parcs`> nolrai: use ghc-pkg unregister or ghc-pkg hide if you want to remove a package (this won't remove its files)
14:05:41 <applicative> > foldr min Nothing []
14:05:42 <lambdabot>   Nothing
14:06:09 <nolrai> ,parcs`: okay..that makes sense..so..uh..hmm. How do I get rid of the librarys that "apt-get install agda-mode" installed?
14:06:31 <nolrai> ahh..that should work.
14:06:45 <BMeph> shachaf: It'd be nice if the Prelude had both more safe, and safer, functions. ;)
14:07:53 <parcs`> nolrai: uh, apt-get ??
14:07:58 <typoclass> dumb question -- a polymorphic function maximum' which can yield either a "Maybe a" or an "a" is impossible, because that would be a kind error, right. but doesn't the new thing now have kind polymorphism?
14:08:25 <shachaf> typoclass: That's not a kind error, is it?
14:09:26 <hiptobecubic> i don't think so
14:09:27 <shachaf> It's an evil thing, but not particularly a kind error.
14:10:13 <typoclass> hm, i think you're right. all i know is, a long while ago i tried to implement it and failed for whatever reason. i remembered it as a kind error, but i think my brain has misfiled that
14:10:15 <hiptobecubic> maximum' pred structure = ...  could result in that
14:10:34 * hackagebot VKHS 0.0.1 - Provides access to VkontakteAPI (Popular Russian social network)  http://hackage.haskell.org/package/VKHS-0.0.1 (SergeyMironov)
14:10:35 <typoclass> shachaf: not evil! it's grate!
14:10:36 * hackagebot VKHS 0.0.2 - Provides access to VkontakteAPI (Popular Russian social network)  http://hackage.haskell.org/package/VKHS-0.0.2 (SergeyMironov)
14:10:38 * hackagebot gutenberg-fibonaccis 1.0.2 - The first 1001 Fibonacci numbers, retrieved from the Gutenberg Project.  http://hackage.haskell.org/package/gutenberg-fibonaccis-1.0.2 (JustinHanekom)
14:10:45 <hiptobecubic> typoclass, unless you main the SAME function could return a Maybe a or just an a, which is a type error i gues
14:10:51 <hiptobecubic> guess. *
14:11:39 <typoclass> hiptobecubic: well a plain function wouldn't work, yes. it'd clearly involve typeclasses
14:12:44 <nolrai> gahh ghc-pkg hide does nothing for my problem!
14:13:05 <Ferdirand> can you define a type of kind * -> * that would be an identity ?
14:13:35 <hiptobecubic> right so if the maximum works over some parametric container type like [Int] or Map Int (Maybe Double) then I don't see how it's an error at all?
14:13:53 <Ferdirand> and if so, could you make it a monad defining fail = error ?
14:14:54 <nolrai> help please: http://hpaste.org/74451
14:15:15 <applicative> whoa gutenberg-fibonaccis 1.0.2 have to update right away
14:15:33 <applicative> the most awesome package on hackage
14:15:34 * hackagebot floatshow 0.2.3 - Alternative faster String representations for Double and Float,  String representations for more general numeric types.  http://hackage.haskell.org/package/floatshow-0.2.3 (DanielFischer)
14:17:49 <hiptobecubic> Ferdirand, Id a = Id a for example? There is already an identity monad, but how would you know what a 'failure' is in that case? Also 'fail' is apparently not monadic, just an ugly shortcut as an appeal to practicality.
14:18:16 <Ferdirand> Id a = a
14:18:35 <hiptobecubic> I don't think that works. a is not a data constructor
14:18:48 <Ferdirand> well the constructor gets in the way
14:18:49 <benmachine> applicative: ...
14:19:03 <benmachine> applicative: "The fibsLen function returns the number of Fibonacci numbers - |in the first1001Fibs list."
14:19:10 <nolrai> newtype ID a = a works I belive.
14:19:16 <Peaker> nolrai, try "import Agda.<tab><tab>"
14:19:19 <Ferdirand> the idea was that if you have something like in the libs that does Monad m => .... -> m a
14:19:42 <benmachine> nolrai: you need a constructor
14:19:46 <Ferdirand> which does fail on failure or return blah on success
14:20:05 <hiptobecubic> nolrai, no
14:20:13 <Ferdirand> can it be done to have something where fail = error and return = id
14:20:25 <JoeyA> Is there a nice abstraction generalizing this?  newtype Foo a = Foo (IO (a, Foo a))
14:20:26 <benmachine> Ferdirand: I don't believe so
14:20:35 <JoeyA> Foo is a machine you keep running and running, that spits out IO values.
14:20:51 <JoeyA> Kinda like forall s. Foo (StateT IO s a)
14:20:53 <hiptobecubic> well error has any type you want
14:21:06 <Ferdirand> but that probably would make the type system completely unpredictible or something horrible along that line that is way above my understanding
14:21:15 <benmachine> JoeyA: I've used something similar before. I think it might be the StreamT monad
14:21:17 <JoeyA> It's not really a Mealy machine because there's no input.
14:21:19 <benmachine> er
14:21:23 <benmachine> monad transformer
14:21:29 <hiptobecubic> and return = id, is the definition from Control.Monad.Identity
14:21:37 <benmachine> it's like the "real" ListT only it never ends
14:21:39 <nolrai> Perker: I get literal tabs not tab compleat.
14:21:45 <Ferdirand> hiptobecubic: yes, but then you get an Identity a out, not an a
14:22:01 <Ferdirand> so you still have to unpack it
14:22:08 <Ferdirand> err, maybe it's not that bad, after all
14:22:11 <hiptobecubic> Ferdirand, you can't have a monadic value that isn't in the monad as far as I know
14:22:20 <hiptobecubic> I don't see how that makes any sense
14:22:47 <Ferdirand> yes, the question was wether it was possible to make the identity monad implicit
14:22:54 <benmachine> I don't think os
14:22:55 <benmachine> so
14:22:59 <Ferdirand> i don't think so either
14:23:05 <Ferdirand> it was just a stupid thought experiment
14:23:07 <benmachine> I could imagine a system in which it would be possible
14:23:09 <JoeyA> Well, I don't want list-monad-like nondeterminism, if that's what StreamT would imply.
14:23:12 <benmachine> it's not a terrible idea
14:23:15 <JoeyA> By the way, is StreamT defined anywhere?
14:23:18 <benmachine> but it probably can't be done
14:23:36 <benmachine> JoeyA: not that I know of, and if it were it might not be like that
14:23:37 <hiptobecubic> I'm usually pretty reluctant to state anything flatly because some dark wizard finds a counter example with some magic, but this seems pretty clear
14:23:51 <benmachine> JoeyA: it's different to the list monad though - there's no concat on streams, so no concatMap
14:24:15 <hiptobecubic> why is there no concat on streams?
14:24:20 <benmachine> hiptobecubic: but the identity functor is a monad in the category sense
14:24:29 <benmachine> hiptobecubic: infinite streams, I'm talking about
14:24:41 <benmachine> hiptobecubic: doesn't make much sense to glue them end-to-end if they don't have an end :)
14:25:14 <hiptobecubic> benmachine, so there's no concat in the same sense that there's no concat on infinite lists, then?
14:25:44 <benmachine> hiptobecubic: right
14:25:45 <JoeyA> I suppose I could turn it into an Automaton (Kleisli IO) by introducing a dummy input.
14:25:53 <dmhouse> so how does bind work in the stream monad if it's not concatMap?
14:25:57 <benmachine> JoeyA: why would you do that, though?
14:26:09 <hiptobecubic> benmachine, Identity is a monad, yes. But the question was about using it implicitly without having to "run" it
14:26:14 <benmachine> dmhouse: I think join takes the diagonal
14:26:22 <JoeyA> E.g. newtype Foo a b = Foo (a -> IO (b, Foo a b))
14:26:27 <benmachine> hiptobecubic: right, but if the true identity functor were expressible in haskell it would do that
14:26:30 <dmhouse> benmachine: ah, that's a nice way of thinking about it
14:26:34 <benmachine> hiptobecubic: it isn't though
14:26:39 <JoeyA> Which would be a Mealy machine on top of IO.
14:26:59 <JoeyA> benmachine: I guess so I can compose it or something, I don't know.
14:27:10 <benmachine> JoeyA: you can't compose it if there isn't any input
14:27:22 <benmachine> I mean, there's not much point
14:27:54 <hiptobecubic> benmachine, well now we're above my pay grade. Except for a few minor excursions, my only real exposure to category theory has been in the context of Haskell.
14:28:12 <hiptobecubic> Which is to say, I have had no real exposure to category theory :)
14:28:16 <JoeyA> Well, with a Mealy Arrow, I can use arrow notation and such, and have it wrap up state for me automatically.
14:28:34 <benmachine> hiptobecubic: I've never done a formal CT course
14:28:41 <benmachine> hiptobecubic: so I'm sure I'm not far ahead of you
14:29:07 <JoeyA> Without similar type classiness for a machine that spits out values, it's more tedious.
14:29:26 <JoeyA> Hmm, unless I make a monad providing a "yield" operation.
14:29:53 <JoeyA> and require the action to never terminate (or if it does terminate, have the consumer treat it as stopped).
14:29:55 <dmhouse> so m >>= f is (f m[0])[0], (f m[1])[1], (f m[2])[2], ...
14:30:15 <hiptobecubic> benmachine, well can you explain what you mean then? Why should the Identity monad not produce values of type Identity a?
14:30:34 * hackagebot VKHS 0.0.3 - Provides access to Vkontakte (popular Russian social network) API  http://hackage.haskell.org/package/VKHS-0.0.3 (SergeyMironov)
14:30:49 <ddarius> :t ala
14:30:50 <benmachine> hiptobecubic: the Identity monad does
14:30:50 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
14:31:06 <ddarius> @let underF' p f = fmap unpack . f . fmap p
14:31:07 <lambdabot>  Defined.
14:31:14 <benmachine> hiptobecubic: but the Identity monad is not a true identity functor in the sense that a is not equal to Identity a
14:31:20 <hiptobecubic> benmachine, ah, but the functor does not, that's all you're saying?
14:31:41 <benmachine> hiptobecubic: hypothetically, you could have an identity type function that would then form a reasonable monad
14:31:45 <ddarius> underF' Max $ ala' Option foldMap Just
14:31:48 <hiptobecubic> benmachine, ok sure. I can accept that
14:31:52 <benmachine> such that f a *was* a, rather than just being isomorphic
14:32:09 <benmachine> hiptobecubic: it's reasonable to ask if Haskell supports that, but I'm pretty sure it doesn't
14:32:37 <hiptobecubic> Ok bed
14:33:16 <dmhouse> is anyone at icfp next week?
14:33:28 <dmhouse> or haskell 2012
14:35:34 * hackagebot lhs2tex 1.18.1 - Preprocessor for typesetting Haskell sources with LaTeX  http://hackage.haskell.org/package/lhs2tex-1.18.1 (AndresLoeh)
14:36:41 <ddarius> djahandarie: Why are overF's and underF's types so strict?
14:38:24 <dolio> @type overF
14:38:25 <lambdabot> Not in scope: `overF'
14:38:28 <dolio> @type overF'
14:38:29 <lambdabot> Not in scope: `overF''
14:38:38 <ddarius> @hoogle overF
14:38:38 <lambdabot> Control.Exception.Base Overflow :: ArithException
14:38:38 <lambdabot> Control.Exception Overflow :: ArithException
14:38:38 <lambdabot> Control.OldException Overflow :: ArithException
14:39:06 <typoclass> shachaf: yo, i think i know why you earlier said it'd be evil for a function to polymorphically give either Nothing+Just or crash+value. the reason is, you couldn't say anymore "head is smelly" and grep through the codebase for head. you'd have to carefully inspect each use individually if it's safe
14:39:46 <ddarius> typoclass: No you wouldn't.  You would just say "foo is smelly".
14:40:12 <startling> is there a formalization of injections, surjections, and bijections somewhere?
14:40:17 <startling> *in haskell
14:40:26 <typoclass> ddarius: right, but you'd have to ensure each use of foo is the Maybe variant, not the other. this involves manual checking.
14:40:47 <ddarius> typoclass: No you wouldn't.  You would just treat foo like head.
14:41:14 <ddarius> Whether it's safe or not would be irrelevant.  Many uses of head are safe, but you'd have to check each use.
14:48:36 <benmachine> startling: not really, except in that data constructors are automatically injective
14:51:58 <typoclass> ddarius: what i meant is this. suppose a function safeHead that gives a Maybe. suppose my program uses it 50 times, and uses head 50 times. i'd likely grep for 'head' and take a critical look at each use, but likely it's unnecessary for safeHead. if safeHead and head were now conflated, i'd have 100 uses to check, instead of 50. hence my opinion that it's useful to have two different names
14:52:13 <startling> yeah. is there a standard package or something for marking functions as injective/surjective/bijective and then doing stuff with them?
14:52:26 <startling> I know `lens` has some isomorphism stuff, but.
14:52:55 <benmachine> startling: oh, it's possible, but I don't know about it
14:53:07 <startling> k. Guess I'll do it myself, then
14:53:57 <Nereid> startling: maybe it's worth noting that injective functions have left inverses
14:53:59 <benmachine> startling: well, hold on
14:54:04 <Nereid> and surjectives have right inverses
14:54:21 <Nereid> so...
14:54:40 <benmachine> startling: http://hackage.haskell.org/package/partial-isomorphisms what's this
14:54:46 <benmachine> maybe this is interesting
14:55:16 <Ferdirand> sorry, what does left/right inverse mean for functions ?
14:55:26 <startling> Ferdirand: composition on sides of (.)
14:55:32 <Nereid> Ferdirand: g is a left inverse of f if g . f = id
14:55:43 <Ferdirand> aah, duh
14:55:44 <Ferdirand> of course
14:55:48 <startling> Nereid: yeah, right now I'm marking them with inverses
14:56:00 <startling> Nereid: data Injection a b = Injection (a -> b) (b -> Maybe a)
14:56:08 <startling> data Surjection a b = Surjection (a -> b) (b -> [a])
14:56:15 <Nereid> why Maybe?
14:56:15 <startling> data Bijection a b = Bijection (a -> b) (b -> a)
14:56:45 <Nereid> why not Injection (a -> b) (b -> a), where Injection f g is required to satisfy g . f = id
14:57:01 <startling> Nereid: because then there's only one of them
14:57:02 <dmhouse> because b might be "bigger" than a
14:57:11 <Nereid> that's fine
14:57:31 <dmhouse> take e.g. the embedding of naturals into integers
14:57:45 <Nereid> so, f :: Naturals -> Integers.
14:58:00 <startling> Nereid: right. so the inverse could do whatever it wants with -1
14:58:04 <Nereid> you take g :: Integers -> Naturals, where g n = n if n is natural, and some arbitrary thing if n isn't.
14:58:06 <Nereid> yes, it could.
14:58:07 <startling> Nereid: that is, map it to any Natural
14:58:15 <dmhouse> Nereid, right, but how unnatural
14:58:17 <Nereid> left inverses are far from unique.
14:58:36 <dmhouse> Nereid: what if a is empty?
14:58:37 <startling> Nereid: yes. for my purposes it's more useful to have one canonical left inverse
14:58:46 <dmhouse> i guess this is now not a question about haskell because haskell has no empty types
14:59:11 <Nereid> dmhouse: right, that.
14:59:21 <startling> same with Surjection (a -> b) (b -> [a])
14:59:27 <Nereid> [a]
14:59:28 <Nereid> :(
14:59:35 <startling> Nereid: why?
14:59:40 <dmhouse> but giving the minimal left inverse seems nicer than giving a total function and having to make some arbitrary decisions
14:59:41 <benmachine> dmhouse: depends on how you're thinking
14:59:41 <Nereid> lists are ordered.
14:59:49 <ddarius> startling: Because ordering and duplication shouldn't matter.
14:59:54 <startling> Nereid: ah, yeah, there's that
14:59:55 <Nereid> and duplication too.
14:59:57 <dmhouse> benmachine: what do you mean?
15:00:06 <startling> but Set can't be infinite
15:00:12 <benmachine> dmhouse: well, people often think about the total subset of haskell, in which there are empty types
15:00:34 <benmachine> startling: Set also has the Ord requirement
15:00:52 <dmhouse> benmachine: sure, but the point is, one can extend any (b -> Maybe a) to a total (b -> a) just by taking bottom in all the Nothing cases
15:00:53 <startling> benmachine: indeed
15:01:05 <Nereid> dmhouse: but bottom is gross.
15:01:09 <benmachine> dmhouse: but you wouldn't *want* to :P
15:01:15 <dmhouse> yes, exactly!
15:01:24 <dmhouse> so isn't it better to give the minimal, partial function :)
15:01:43 <benmachine> dmhouse: huh
15:01:55 <benmachine> dmhouse: because we don't want it to be partial?
15:02:03 <dmhouse> i don't really mean partial
15:02:17 <dmhouse> i mean partial in the sense of having a codomain of Maybe a instead of a
15:02:22 <benmachine> sure
15:03:01 <dmhouse> my point is: i think it's nicer to define an injection type by giving as witness the minimal, "partial" (in the above sense) left inverse
15:03:15 <benmachine> dmhouse: that's fair enough
15:03:18 <dmhouse> rather than one extended in some arbitrary fashion, or even in a canonical fashion but returning bottoms
15:03:20 <Nereid> fine, but what about surjections?
15:03:21 <startling> yeah, that's my thinking
15:03:44 <startling> Nereid: you return a collection of the elements that are mapped to b
15:03:53 <Nereid> what is a collection?
15:04:06 <startling> Nereid: a list in this case, but no, that's not perfect
15:04:14 <ddarius> The point of a left inverse is that you won't apply it to elements outside the restricted domain in the first place, which is why it can be arbitrary.
15:04:15 <benmachine> startling: should at least be a nonempty list :)
15:04:17 <benmachine> (a, [a])
15:04:21 <startling> benmachine: true enough
15:04:32 <Nereid> what ddarius said.
15:04:47 <dmhouse> you still have arbitrariness there, though, because you need to decide on an order of that list
15:04:59 <startling> ddarius: but you can derive the left inverse from a b -> Maybe a
15:05:11 <ddarius> There is no "the left inverse"
15:05:18 <startling> *a left inverse
15:05:19 <startling> whatever
15:05:35 * hackagebot gutenberg-fibonaccis 1.0.3 - The first 1001 Fibonacci numbers, retrieved from the Gutenberg Project.  http://hackage.haskell.org/package/gutenberg-fibonaccis-1.0.3 (JustinHanekom)
15:05:52 <startling> and a b -> Maybe a is more useful in some cases
15:05:54 <dmhouse> i guess this is kind of standard
15:05:59 <ddarius> In many cases you will have a left inverse a priori, furthermore you are doing a bunch of packing and checking etc. for cases that should never happen.
15:06:00 <dmhouse> computers have no real way of expressing orderlessness
15:06:15 <startling> yeah. :/
15:06:27 <startling> also wtf re: * hackagebot gutenberg-fibonaccis
15:07:23 <Nereid> I still think you could just go with any right inverse as a witness to surjectivity.
15:07:37 <Nereid> because the particular choice shouldn't matter.
15:07:54 <dmhouse> hmm, what makes you say that?
15:08:09 <startling> no, I *want* to know where it's ambiguous
15:08:17 <Nereid> ??
15:08:20 <startling> I'm not only going to be using it as a right inverse
15:08:51 <startling> the idea is that I'm writing a parser library where you can say "generate some input that will give me X"
15:08:56 <ddarius> A better representation of a surjection for that purpose would be an equivalence relation.
15:09:03 <ddarius> Or equivalence classes.
15:09:34 <startling> and there may be many such inputs or there might not be any
15:09:49 <dmhouse> given, say, data Surjection a b = S (a -> b) (b -> (a, [a])), one has a particular right inverse (project out the first element of the pairs), and also one knows where there is a choice to be made (look at the second element of the pair and see if it's nonempty)
15:09:51 <Nereid> startling: but if there is one, then any right inverse will give you one.
15:10:02 <startling> Nereid, but only one
15:10:33 <Nereid> ok, so
15:10:38 <Nereid> why do you need surjections at all?
15:10:52 <startling> Nereid: predicates are surjections
15:11:01 <Nereid> given f :: a -> b, write something like g :: b -> [a], where g b is like the preimage of b under f.
15:11:15 <dmhouse> startling: hmm, what's your definition of a predicate?
15:11:15 <Nereid> and you might have g b = [].
15:11:15 <startling> *for any type with > 2 members
15:11:35 <startling> dmhouse: a -> Bool for any a such that |a| > 2
15:11:36 <ddarius> const True isn't a predicate?
15:11:45 <startling> ddarius: sure it is
15:11:47 <dmhouse> startling: right, what about that ensures surjectivity?
15:12:00 <Nereid> const True is quite non-surjective
15:12:27 <startling> hmm, yeah, maybe surjectivitity isn't quite the concept I've got
15:12:57 <Nereid> startling: I might be assuming things, but I'd say that for your application it would just suffice to have some preimage function like I described above.
15:13:06 <Nereid> where preimages may or may not be empty
15:13:17 <startling> mhm
15:13:19 <ddarius> I have no idea what you are going for there.  A predicate is a function A -> Bool for some A.  There are no further requirements.
15:13:57 <startling> I was asked for my definition !
15:13:58 <Nereid> as a bonus, your function is injective if preimages never have more than 2 things.
15:14:06 <Nereid> more than 1 thing.
15:14:08 <Nereid> at least 2 things.
15:15:02 <Nereid> although if you're using a list, you might end up with duplicates, so that might not be such a good idea.
15:15:45 <ddarius> startling: Which you haven't provided, but I did say I don't know what you are going for.  I.e. I have no idea what extra condition you feel a predicate should have.
15:16:07 <startling> ddarius: I was wrong, predicates are not surjections
15:16:22 <Nereid> and they need not be defined on sets with at least 2 members.
15:16:58 <dmhouse> projections are surjections (dually embeddings are injections)
15:17:39 <dmhouse> so given data Foo = MkFoo { unFoo :: <type> }, MkFoo is an injection and unFoo is a surjection
15:18:13 <dmhouse> that's a bit trivial, i guess, since Foo and <type> are isomorphic
15:18:19 <dmhouse> eh, i'm not sure this is really going anywhere interesting
15:19:30 <startling> heh, enumerable comes with an Eq instance for (Enumerable a, Eq b) => a -> b
15:19:36 <ddarius> dmhouse: You are vaguely leading towards retractions and sections and embed/project paris.
15:19:37 <startling> cheeky
15:20:01 <ddarius> dmhouse: You also will eventually lead to the fact that embed . project is idempotent.
15:20:40 <Nereid> startling: huh, how does that work?
15:20:59 <startling> Nereid: it enumerates over the domain
15:21:04 <startling> Nereid: and checks equality
15:21:22 <Nereid> oh, I didn't read the whole sentence.
15:21:35 <Nereid> I missed "an Eq instance for"
15:21:43 <startling> oh ha
15:22:15 <dmhouse> is there an Enumerable a => Eq a instance? (i don't know the Enumerable class)
15:22:39 <dolio> Instances don't work that way.
15:22:57 <ddarius> Even if they worked that way, that wouldn't make sense.
15:23:02 <startling> dmhouse: it'd need UndecidableInstances
15:23:09 <startling> but yeah dunno how that would work
15:23:29 <ddarius> startling: UndecidableInstances wouldn't help.
15:23:29 <dmhouse> err, right. Thinking about it again, that's nonsense
15:23:48 <startling> ddarius: *ghc would complain and suggest UndecidableInstances
15:23:58 <startling> dunno if it would help or not
15:25:21 <gertc> State { runState :: (s -> (a,s)) }
15:25:43 <gertc> i expected State { runState :: (s -> a s) }
15:25:54 <startling> gertc, a s?
15:26:12 <gertc> (a,s)? :)
15:26:27 <MostAwesomeDude> Huh, Enumerable is kind of silly.
15:26:33 <startling> MostAwesomeDude: but useful!
15:26:39 <MostAwesomeDude> startling: Oh?
15:26:57 <dmhouse> well, a value of type State a is computation that needs some state to figure out what to do, and when it has that state, it yields a value of type a and a new value of the state
15:27:15 <dmhouse> gertc, does that make more sense? Or: why were you expecting "a s??
15:27:17 <startling> MostAwesomeDude: I'm writing types for functions a -> b with an associated b -> [a]
15:27:26 <MostAwesomeDude> startling: Aha.
15:27:29 <ddarius> dmhouse: Because he doesn't know the notation for pairs.
15:27:39 <JoeyA> Where is the source repo for the arrows package?
15:27:52 <JoeyA> darcs get http://code.haskell.org/~ross/arrows appears to be outdated.
15:28:33 <startling> JoeyA: do you mean Control.Arrow? it's in `base`
15:28:45 <JoeyA> No, the arrow transformers library
15:28:53 <JoeyA> http://hackage.haskell.org/package/arrows-0.4.4.0
15:28:58 <mietek> Is there a standard Haskell function which corresponds to POSIX umask(2)?
15:29:01 <startling> disregard that, then
15:29:11 <JoeyA> darcs has 0.4.1.2, Hackage has 0.4.4.0
15:29:12 <mietek> setFileCreationMask?
15:29:35 <mietek> Right, never mind.
15:29:41 <gertc> just a sec testing somthing first before i say somthing realy stupid
15:37:47 <startling> @src const
15:37:47 <lambdabot> const x _ = x
15:38:40 <startling> can const be generalized for any Category?
15:41:50 <startling> also: is there a type for non-empty lists somewhere?
15:42:01 <startling> (with all the associated instances already written)
15:43:23 <benmachine> startling: no, const cannot be generalised for any Category
15:43:29 <benmachine> there are some quite exotic categories around
15:43:51 <benmachine> a type for non-empty list, probably
15:44:51 <benmachine> startling: in fact I've found three :P
15:44:57 <benmachine> http://hackage.haskell.org/package/NonEmpty
15:45:10 <benmachine> http://hackage.haskell.org/package/NonEmptyList
15:45:14 <benmachine> http://hackage.haskell.org/packages/archive/semigroups/0.8.4/doc/html/Data-List-NonEmpty.html
15:45:21 <gertc> ok State { runState :: (s -> (a,s)) } nevermind the a s for now until i invent my fState s a or somthing :)
15:45:25 <benmachine> there might be more
15:45:32 <startling> benmachine: heh, thanks!
15:46:38 <startling> the semigroup one looks the best
15:46:40 <benmachine> yeah
15:54:55 <benmachine> edwardk: I feel like some functions in Data.List.NonEmpty are partial but not obviously so, should be documented (e.g. words, unwords)
15:55:08 <edwardk> benmachine: send a patch. i'll take it
15:55:22 <benmachine> k
15:55:28 <zzing> Is hackage down for anyone?
15:55:45 <benmachine> zzing: seems to work
15:56:07 <zzing> hmm, it was just working. But then stopped suddenly from working.
15:56:24 <zzing> ok, its back
15:57:03 <zzing> Is anyone familiar enough with hamlet to know if it is possible to create new tags such that they are replaced with some real html output?
15:58:28 <arbn> zzing: Why not just use widget interpolation?
15:58:44 <arbn> ^{...}
15:59:12 <zzing> arbn, widgets can be nice for sure, but in some ways I would like to be able to have things look more like html.
15:59:26 <gwern> @quote html
15:59:26 <lambdabot> urxvt-transparency says: http://lists.schmorp.de/pipermail/rxvt-unicode/2008q1/000552.html
15:59:30 <ddarius> You could use heist.
15:59:35 <gwern> huh
15:59:58 <zzing> ddarius, I am firmly using hamlet. Quite a different use heist is.
16:00:24 <gwern> @forget urxvt-transparency http://lists.schmorp.de/pipermail/rxvt-unicode/2008q1/000552.html
16:00:25 <lambdabot> Done.
16:00:27 <gwern> @flush
16:02:21 <arbn> zzing: You really just want to do HTML substitution from a function for a <...> instead of a ^{...} ?
16:02:39 <zzing> arbn, mostly.
16:03:02 <zzing> Semantics I suppose.
16:03:42 <arbn> I would guess there is no way to do that. Hamlet's TH code always provides that functionality, but through a different quasiquotation syntax. Overloading the syntax would complicate the TH code significantly.
16:05:01 <arbn> Those templating languages are designed to be almost overly simple.
16:05:16 <zzing> arbn, does it have specific tags that it converts into blaze or something of that nature?
16:05:36 * hackagebot sym 0.1.1 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.1.1 (AndersClaesson)
16:05:37 <zzing> I should say specific tags, or does it convert tag names by convention...
16:07:07 <arbn> zzing: Not sure about converting to Blaze. You might want to ask in #yesod.
16:09:10 <zzing> #yesod has only tumbleweed going through it :-(. I post on the mailing list through google groups though, it is likely a good place to ask there.
16:09:43 <arbn> zzing: Yeah. Snoyman often gives answers on the mailing list.
16:11:59 <zzing> Starting to get cold out! It has hit 20 today.
16:13:48 <edwardk> @tell obk .: went in as |> to match f#, scala, etc.
16:13:49 <lambdabot> Consider it noted.
16:16:07 <edwardk> |> actually works really well with lens code
16:16:28 <edwardk> foo |> bar .~ "hello" |> quux .~ "world"
16:16:49 <startling> I've got a bunch of small types and I'd like to have a larger union type of them. What's the best way to do that? Explicitly specify the union type and have a bunch of junk constructors? Make an IsUnionType class with toUnion?
16:17:08 <edwardk> its a strong enough visual separator, and it fits the semantics those who come from f# or scala would expect
16:17:19 <edwardk> and it has the same fixity as >>
16:17:46 <ivanm> startling: I tend to use large sum types
16:18:03 <ivanm> GHC doesn't like them though, and it takes a while to compile :s
16:18:27 <startling> heh
16:18:29 <edwardk> i tend to build explicit constructors for the tupled up bundle of my types, and/or use lenses to find them
16:18:43 <edwardk> well, for sums thats more awkward
16:19:00 <edwardk> trying to figure out how to add embedding/projection pairs to lens
16:22:27 <gentleben> i had a haskell |> that i used alot when i started so the code went in the correct direction
16:27:14 <edwardk> gentleben: it helps a bit mostly with chained setters
16:27:34 <edwardk> looks a tiny bit more like setting a fields in a record
16:27:42 <edwardk> and the effects get ordered the right way
16:28:12 <benmachine> edwardk: should I just change the type of words to NonEmpty Char -> [String]?
16:28:22 <benmachine> edwardk: likewise unwords
16:28:44 <benmachine> (although unwords has only one input that I can find that causes an error)
16:28:48 <edwardk> hrmm, don't remember the partiality problem
16:29:03 <benmachine> edwardk: words throws an error on input consisting entirely of whitespace
16:29:04 <edwardk> its that you can give it a single space or something?
16:29:07 <benmachine> including the empty string
16:29:24 <edwardk> well, it shouldn't get the empty string, but the input of whitespace i can see being probematic =)
16:29:29 <benmachine> unwords crashes on (return "")
16:29:36 <benmachine> oh, yeah, ykwim :P
16:29:51 <edwardk> whats the type of unwords there?
16:30:01 <benmachine> unwords :: NonEmpty String -> NonEmpty Char
16:30:08 <edwardk> ah
16:30:09 <benmachine> hmm
16:30:25 <edwardk> that should probably be NonEmpty (NonEmpty Char) -> NonEmpty Char
16:30:25 * benmachine ponders unwords :: NonEmpty (NonEmpty Char) -> NonEmpty Char
16:30:31 <edwardk> that would fix the latter safely
16:30:39 <benmachine> yeah
16:30:44 <benmachine> but I wonder what it's even for anyway :p
16:30:58 <edwardk> then maybe the former can become NonEmpty Char -> [String] or Maybe (NonEmpty Char) ?
16:31:26 <benmachine> hmm
16:31:29 <edwardk> i get a lot of people who use it because it is the most complete non-empty list implementation in terms of list-like methods
16:31:29 <benmachine> well
16:31:36 <benmachine> how about I do a patch that is only documentation changes
16:31:37 <mietek> System.Posix.Resource doesn't seem very user-friendly
16:31:42 <benmachine> because there are plenty of those
16:31:51 <edwardk> i'll definitely take that one
16:31:56 <benmachine> then we worry about how we can block the holes afterwards
16:32:02 <edwardk> feel free to fix up words and unwords too
16:32:27 <edwardk> but if you send that in a second patch i can make a doc only minor release, and a major update release
16:32:34 <benmachine> yeah, sounds sensible
16:32:56 <benmachine> P.S. I'm also excising the term "stream" from the docs everywhere
16:33:02 <edwardk> heh
16:33:05 <benmachine> did you perchance borrow the docs from somewhere else :P
16:33:19 <edwardk> i think i renamed everything at some point before moving it into this package
16:33:25 <benmachine> ah, right, okay
16:33:26 <edwardk> it was in streams or something
16:34:12 <edwardk> i did rather shamelessly acquire methods from other packages though
16:34:16 <edwardk> thats why there are so many authors listed
16:34:22 <benmachine> heh fair enough
16:37:56 <typoclass> mietek: haven't used it, but from the docs it seems fairly straightforward to me ...? could use some Show instances maybe
16:42:05 <kanedank> what would the type be of a function that purely does side effects? I basically want to make a special putStrLn for a data structure
16:44:24 <typoclass> :t putStrLn
16:44:25 <lambdabot> String -> IO ()
16:44:33 <typoclass> kanedank: probably IO (), as in "YourData -> IO ()". however, you may want to use show instead. if you provide an "instance Show YourData where show yd = ..." to convert it to String, you can just use the regular print on YourData
16:45:48 <maurer> So, I'm trying to use cabal's ability to let a package have an executable depend on the library it provides
16:46:08 <maurer> However, I am getting an error saying it can't satisfy its recurisve depency
16:46:53 <maurer> Any ideas what may be going wrong/what I should look at?
16:48:47 <maurer> https://github.com/maurer/executable/ is the source that I expect to build but which instead complains about the self loop
16:48:49 <typoclass> maurer: maybe you accidentally made the executable depend on the executable? maybe even as executable -> library -> executable -> ... no idea really
16:49:13 <maurer> typoclass: How would I tell it I only want it to depend on the library
16:50:59 <benmachine> you can't depend on an executable anyways
16:51:47 <maurer> https://github.com/maurer/executable/blob/master/executable.cabal
16:51:51 <maurer> is the cabal file in question if it helps
16:52:27 <benmachine> maurer: what's the error?
16:52:43 <benmachine> maurer: GHC/cabal version?
16:52:45 <maurer> <command line>: cannot satisfy -package-id executable-0.1
16:52:54 <maurer> cabal-install version 0.8.0
16:52:56 <maurer> using version 1.8.0.2 of the Cabal library
16:53:03 <maurer> The Glorious Glasgow Haskell Compilation System, version 6.12.1
16:53:11 <typoclass> benmachine: the problem is probably that the executable has "build-depends: executable", i.e. executable.cabal, i.e. that file itself
16:53:25 <maurer> typoclass: Yes, but there was a feature added that did this in 1.8 iirc
16:53:30 <benmachine> typoclass: that's intentional
16:53:42 <benmachine> maurer: hmm. did the library fail to build?
16:53:53 <maurer> Doesn't look like it
16:53:54 <maurer> Building executable-0.1...
16:53:54 <maurer> Registering executable-0.1...
16:53:58 <maurer> displayed before the error
16:54:03 <benmachine> maurer: try cleaning and doing it again?
16:54:04 <maurer> Which sounds like the library should have built
16:54:12 <typoclass> benmachine: oh. looked very weird to me
16:54:19 * typoclass should shut up a little more
16:54:25 <maurer> Yeah, library built, but same error
16:54:55 <benmachine> maurer: huh, weird
16:55:34 <benmachine> I'm sure I've done this before
16:55:47 <benmachine> can't for the life of me remember where though
16:58:27 <maurer> benmachine: Hm, just tried it on another machine, builds clean
16:58:34 <maurer> So it is a misconfig of some sort
16:59:08 <typoclass> maurer: compare the ghc and cabal versions
17:00:31 <pharaun> how do i unwrap or promote the 'GenParser Char st a'? IE [GenParser Char st a] -> GenParser Char st [a] ?
17:00:52 <benmachine> pharaun: er, that example in particular you use sequence
17:00:56 <benmachine> but you don't unwrap it
17:01:00 <benmachine> you just use sequence
17:01:23 <typoclass> maurer: oh, do you have an executable-0.1 package installed already? maybe it's having trouble overwriting/depending on the already present package. try bumping the version number
17:01:26 <benmachine> I guess the way to think of it is, instead of getting the values out, you're putting the list constructors in
17:01:52 <pharaun> benmachine: hm? got an example?
17:02:01 <benmachine> pharaun: of what?
17:03:06 <hpaste> pharaun pasted “example” at http://hpaste.org/74456
17:03:23 <pharaun> benmachine: ^ that's what i am doing now, i guess i'm not sure what you mean by putting the list constructor in?
17:04:30 <benmachine> pharaun: don't worry about it, it was a strange analogy
17:05:13 <kanedank> what is the "sortGT" thing called in the first answer here?: http://stackoverflow.com/questions/2349798/in-haskell-how-can-i-use-the-built-in-sortby-function-to-sort-a-list-of-pairst
17:05:19 <benmachine> pharaun: so this isn't typechecking?
17:05:24 <kanedank> I don't think it's a function because it doesn't have '=', only guards
17:05:39 <pharaun> yeah - Couldn't match expected type `GenParser Char st (IntMap.IntMap ParseVal)' -> with actual type `IntMap.IntMap (GenParser Char st0 ParseVal)'
17:05:57 <benmachine> kanedank: it does have =, they're inside the guards
17:06:00 <pharaun> it wants to put the GenParser Char st inside the map, i understand why, but what i'm struggling with is how to make it not do that
17:06:20 <benmachine> pharaun: ok, are you familiar with do notation?
17:06:37 <pharaun> do blah xyz? yeah
17:07:09 <pharaun> i just try to avoid it cos i think it usually leads to a cleaner better code here but if i have to i can make use of the do
17:08:00 <benmachine> pharaun: well, there are ways to do it
17:08:32 <benmachine> pharaun: but the simplest way is do-notation
17:08:39 <pharaun> fair enough
17:08:52 <benmachine> by "simplest" I mean "requires least explaining from me" :P
17:09:00 <pharaun> i can figure out the rest :D
17:09:20 <pharaun> i just think i need a initial boot kicking to get my mind in gear with this one
17:11:17 <pharaun> benmachine: oh i replace the (x, parsingValue y) tuple part with (do z <- parsingValue y then return (x, z) ?
17:11:28 <benmachine> pharaun: you can do that
17:11:52 <benmachine> pharaun: if you don't like do-notation, then you could do something like ((,) x) <$> parsingValue y
17:12:12 <pharaun> oh *groan*
17:12:14 <pharaun> thanks :)
17:16:08 <mietek> typoclass: http://pastie.textmate.org/private/iolvxnrm34c2zd7al4qhjg
17:17:01 <mietek> typoclass: it's just a very thin layer on an unfriendly POSIX API
17:21:14 <typoclass> mietek: oh, i see your point
17:33:48 <VoidTrip> Howdyy'all
17:35:10 <pharaun> benmachine: thanks, that kicked me in the head, i got the poc to work, going to clean it up all pretty now
17:35:23 <benmachine> pharaun: :) np
17:36:33 <VoidTrip> Introductions and stuff; I'm learning Haskell in a class, and some parts of it are confusing me. I heard about this channel in the Learnyouahaskell.com tutorial.
17:36:37 <VoidTrip> nice to meet y'all
17:36:44 <monochrom> hi
17:36:57 <VoidTrip> what i'm wondering
17:37:00 <VoidTrip> right now at least
17:37:11 <VoidTrip> is how I can take things like `nub`
17:37:21 <gertc> if runstate takes 2 parameters how can the type defenition be like State { runState :: (s -> (a,s)) } where runstate only takes 1?
17:37:24 <VoidTrip> and implement them without using Data.list
17:38:21 <monochrom> you want to write your own version of nub?
17:38:28 <VoidTrip> well, more like have to
17:38:40 <VoidTrip> I want to use the regular version
17:38:45 <VoidTrip> cuz it's much less of a pain in the ass
17:39:11 <monochrom> remember that you always have recursion at your disposal
17:39:46 <VoidTrip> alright
17:39:55 <VoidTrip> so as I'm going through the list
17:40:10 <VoidTrip> if I see an element that exists in the list before it, i remove it
17:40:15 <VoidTrip> does that make sense?
17:42:33 <typoclass> VoidTrip: yeah, it's a possibility i would say
17:42:52 <VoidTrip> alright
17:42:59 <startling> is there a typeclass for membership checking? I realize you can use Foldable, but Data.Foldable.elem is O(n), isn't it?
17:43:17 <gertc> what am i thinking wrong if i expect State { runState :: (a -> s -> (a,s)) }
17:43:32 <startling> @src State
17:43:33 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:43:45 <latro`a_> runState :: State s a -> s -> (a,s)
17:43:57 <latro`a_> when using record syntax, the type inside the record doesn't include that first argument
17:44:00 <startling> gertc: the function only depends on the state
17:44:23 <latro`a_> a -> s -> (a,s) are the Kleisli arrows for State, if that helps
17:44:39 <startling> oh wait, no it doesn't, disreagard that
17:44:43 <latro`a_> (rather, they would be if we didn't use type constructors)
17:44:54 <latro`a_> no, you were right
17:45:05 <latro`a_> the function inside a State value only takes a state as an argument
17:46:06 <startling> ah, okay
17:46:12 <startling> yeah, I see what confused me
17:46:32 <monochrom> for this reason, we hold it self-evident that every function takes just 1 parameter
17:46:41 <latro`a_> lol
17:46:56 <latro`a_> I still kinda boggle a little, that if you uncurry/remove constructors
17:46:58 <monochrom> runState has always taken exactly 1 parameter
17:47:00 <latro`a_> (<=<) = (.)
17:47:20 <latro`a_> and no, this isn't blatantly obvious just because (<=<) is a "composition" operator
17:47:33 <latro`a_> because it isn't true for many many other monads
17:48:03 <hpaste> gertc pasted “State { runState :: (s -> (a,s)) }” at http://hpaste.org/74459
17:48:13 <gertc> http://hpaste.org/74459
17:48:22 <zzing> Haskell: Leave no imperative programmer behind.
17:49:21 <monochrom> you are not realizing what "newtype State s a = State { runState :: (s -> (a,s)) }" really means. there is a straightforward recipe.
17:49:32 <startling> @pl (\x -> g x >>= i)
17:49:33 <lambdabot> (i =<<) . g
17:49:40 <startling> meh
17:49:59 <latro`a_> @pl is annoyingly mechanical (also I know that this is going to trigger @pl)
17:49:59 <lambdabot> is annoyingly mechanical (also I know that this is going to trigger @ pl)
17:50:05 <monochrom> straightforward recipe: "newtype T = Ctor { field :: S }" means field :: T -> S
17:50:27 <startling> latro`a_: sometimes it's astoundingly clever though
17:50:38 <monochrom> now just plug and chug. do not "think". let the symbols do the work. runState :: State s a -> (s -> (a,s))
17:50:38 <latro`a_> true
17:51:12 <monochrom> runState takes 1 parameter and takes 2 parameters. there is no contradiction. State s a -> (s -> (a,s))
17:51:14 <parcs`> > 2^12
17:51:15 <lambdabot>   4096
17:51:39 <startling> like:
17:51:41 <startling> @pl \x -> (>>= return . x)
17:51:41 <lambdabot> fmap
17:56:24 <gertc> monochrom, runState :: State s a -> (s -> (a,s)) this needs allot of compile time in my head... hold on
17:58:22 <latro`a_> it shouldn't, as it's just a direct substitution into the desugaring of record syntax
17:58:23 <gertc> ok runstate generates a function that takes teh second parameter... hmmm
17:58:56 <startling> gertc: it just takes the function out of the State
17:59:31 <latro`a_> that is, if you do data Foo a = Bar {field :: a}, you've made a type constructor Foo, a data constructor Bar, a way to pattern match on values like (Bar x), as well as a function field :: Foo a -> a
17:59:38 <startling> gertc: look at data N = N { getN :: Integer }. getN (N 12) == 12, so getN :: N -> Integer
18:00:24 <startling> or even data Wrap a = Wrap { unwrap :: a }
18:01:16 <startling> @hoogle N n => n a -> a -> Bool
18:01:17 <lambdabot> Warning: Unknown class N
18:01:17 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
18:01:17 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
18:09:28 <benmachine> edwardk: https://github.com/ekmett/semigroups/pull/7
18:09:43 <edwardk> benmachine: great!
18:10:01 <benmachine> if you have any problems with it in the next ten minutes, they get fixed tonight :)
18:10:06 <benmachine> otherwise I go to bed :P
18:10:29 <edwardk> i'll merge it in as soon as i get this batch of changes into lens ;)
18:11:11 <startling> @pl \f a b -> not (f a b)
18:11:11 <lambdabot> ((not .) .)
18:11:31 <startling> @pl \a b -> not (f a b)
18:11:31 <lambdabot> (not .) . f
18:13:42 <gertc> Foo a = Bar a     field (Bar field) = field
18:13:52 <gertc> yes i got it :)
18:14:42 <gertc> thx
18:15:26 <gertc> data Person = Person { firstName :: String ...
18:15:59 <gertc> when i look back at this examples i see that its not :: Person -> String
18:16:17 <gertc> but just :: String
18:17:27 <startling> gertc, you're wrong
18:18:20 <gertc> wait making example
18:21:10 <hpaste> gertc annotated “State { runState :: (s -> (a,s)) }” with “State { runState :: (s -> (a,s)) } (annotation)” at http://hpaste.org/74459#a74460
18:21:21 <gertc> http://hpaste.org/74459
18:23:13 <hpaste> gertc annotated “State { runState :: (s -> (a,s)) }” with “State { runState :: (s -> (a,s)) } (annotation) (annotation)” at http://hpaste.org/74459#a74461
18:25:07 <gertc> any change i could convince haskell to not drop the first parameter in record syntax :)
18:26:12 <gertc> s/change/chance
18:28:31 <pharaun> any advice -> mapM (parsingValue . snd) (idxList mask) -> generates [ParseVal], i'm trying to get [(Int, ParseVal)] ?
18:29:18 <startling> pharaun: mapM (id &&& parsingValue) (idxList mask)
18:29:28 <startling> (&&&) is from Control.Arrow
18:29:31 <pharaun> oh didn't know of the &&&
18:29:35 <pharaun> thanks
18:29:38 <startling> er wait, that's wrong
18:29:43 <pharaun> hm?
18:30:19 <startling> :t second
18:30:20 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
18:30:39 * hackagebot gutenberg-fibonaccis 1.0.4 - The first 1001 Fibonacci numbers, retrieved from the Gutenberg Project.  http://hackage.haskell.org/package/gutenberg-fibonaccis-1.0.4 (JustinHanekom)
18:30:49 <startling> mapM (second parsingValue) (idxList mask) is what you want
18:30:59 <startling> > second (+ 1) ("a", 2)
18:31:00 <lambdabot>   ("a",3)
18:31:27 <startling> `second` is from Control.Arrow, too.
18:31:41 <MostAwesomeDude> Waait, somebody just has a package with Fibonacci numbers? I don't get it.
18:31:58 <startling> MostAwesomeDude: me neither
18:32:11 <nand`> moreover
18:32:17 <nand`> 5 separate versions for it?
18:32:25 <startling> MostAwesomeDude: they're from the gutenberg project, though! that's trustworthy
18:32:47 <pharaun> startling: hmm
18:33:03 <nand`> I
18:33:06 <nand`> oh god
18:33:17 <nand`> the source code is a bit.. what?
18:33:19 <startling> I don't get why they wouldn't just calculate them if they're only using 1001
18:33:51 <MostAwesomeDude> Oh, and it's GPLv3.
18:33:58 <startling> heh
18:34:26 <ddarius> @hoogle copysign
18:34:26 <lambdabot> No results found
18:34:55 <nand`> apparently it used to be BSD3 but they decided to change it because, hey, numbers should be free, right?
18:35:05 <pharaun> startling: arugh
18:35:11 <pharaun> does not typecheck
18:35:17 <gogozeppeli> Hi
18:35:27 <startling> :t 1 : 1 : map (+) (zip <$> tail $ fib)
18:35:28 <lambdabot> Not in scope: `fib'
18:35:28 <tgeeky> i like my numbers free range and medium reare
18:35:49 <startling> > let fib = 1 : 1 : map (+) (zip <$> tail $ fib) in take 5 fib
18:35:50 <lambdabot>   Couldn't match expected type `[a]'
18:35:50 <lambdabot>         against inferred type `[b] -> [(...
18:36:11 <startling> > let fib = 1 : 1 : map (\(a,b) -> a + b) (zip fib (tail fib)) in take 5 fib
18:36:12 <lambdabot>   [1,1,2,3,5]
18:36:19 <startling> > let fib = 1 : 1 : map (\(a,b) -> a + b) (zip fib (tail fib)) in take 1001 fib
18:36:20 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:36:27 <startling> all done
18:36:36 <hpaste> pharaun pasted “annoying type” at http://hpaste.org/74462
18:36:38 <nand`> > fix ((1:) . scanl (+) 1)
18:36:40 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:37:13 <benmachine> the best bit is how they have a thing that calculates the length of the list of the first 1001 fibonacci numbers
18:37:15 <nand`> (0:), technically; the first fibonacci number is 0, right?
18:37:30 <benmachine> nand`: fairly immaterial
18:37:38 <tgeeky> benmachine: 1042!
18:37:55 <benmachine> tgeeky: 1042 factorial?? :O
18:37:58 <MostAwesomeDude> > fix ((0:) . scanl (+) 1)
18:38:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:38:06 <tgeeky> no!
18:38:18 <tgeeky> 1001 - 1 + the universal number
18:38:18 <startling> @pl zip fib (tail fib)
18:38:19 <lambdabot> zip fib (tail fib)
18:38:38 <Jafet> > product [1..1042]
18:38:39 <lambdabot>   980328306565084261178642975020117002441055214724560259098861497660637969678...
18:39:08 <pharaun> i hate parsec type sometime
18:40:19 <Cale> pharaun: the problem is with second
18:40:20 <nand`> “put in a function in case the list is ever changed” <- in case, yknow, the first 1001 fibonacci numbers start to differ over the course of time
18:40:44 <pharaun> Cale: ugh
18:41:24 <Cale> pharaun: you're trying to mapM a function on pairs over some list
18:41:35 <Cale> pharaun: But pairs don't form a monad
18:41:58 <Cale> (at least not unless the first type of the pair is a monoid)
18:42:09 <Cale> (and they're certainly not GenParser)
18:42:18 <pharaun> second type in the pair is a monoid i think (GenParser
18:42:42 <pharaun> ahem, it should be returning "parsec type" [(int, "parsed out value")]
18:42:43 <Cale> You *probably* want parsingValue . snd ?
18:42:57 <pharaun> Cale: that works but
18:43:02 <pharaun> then i have no way to get the fst
18:43:25 <startling> fibsLen = length first1001Fibs
18:43:28 <startling> ...
18:43:40 <Cale> But maybe it would be best just to write something like   foo mask = forM (idxList mask) $ \(n,t) -> do v <- parsingValue t; return (n,v)
18:44:32 <Jafet> Perhaps that package should be renamed to acme-fibs.
18:44:49 <Cale> pharaun: It's possible to simplify that, but whether it's worthwhile to simplify it is questionable :)
18:45:01 <slack1256> to format text, I usually do the formatting in a String with show instance
18:45:29 <slack1256> is this bad practice? and is there a way to pass this directly to for example Data.Text without the string step?
18:46:07 <Cale> slack1256: It's reasonable, so long as the Strings don't become a performance bottleneck.
18:46:30 <benmachine> slack1256: some types can be converted directly to Text, but many can't
18:46:43 <Cale> slack1256: If you want to do more complicated things, you might find yourself interested in using a prettyprinting library
18:46:51 <Cale> like wl-pprint on Hackage
18:47:05 <Cale> http://hackage.haskell.org/package/wl-pprint
18:47:29 <slack1256> somewhere I read that Show/Read where intended to cheap-serialize so that 'read . show = id'
18:47:49 <Cale> slack1256: They tend not to be *that* cheap
18:47:58 <nand`> cheap as in programmer overhead, I guess
18:48:02 <slack1256> so do formatting (as some datatypes do on hackage) in a Show instance seems wrong
18:48:09 <pharaun> Cale: that worked much better :D <3 and yeah i think i'm happy with that format you gave me
18:48:11 <slack1256> yes cheap as in programmer overhead.
18:48:30 <Cale> The intention is *usually* that Show instances produce source code which could reconstruct the value. Sometimes that's not possible.
18:48:39 <nand`> I think one common pattern is for Show instances the produce something that looks like Haskell source code to produce it
18:48:43 <nand`> to*
18:48:58 <nand`> but that's not a property you can rely on in general
18:49:02 <Cale> Yeah
18:49:10 <benmachine> mostly Show instances produce whatever the heck they want >_>
18:49:17 <nand`> ^
18:49:31 <nand`> Show is really meant as a form of programmer aid
18:49:42 <Cale> The main important thing for Show instances is that what they produce is helpful for debugging, yeah.
18:49:42 <nand`> eg. something for GHCi to output
18:49:45 <Cale> right
18:49:45 <Jafet> I have a type here where only read.show.read = read holds
18:50:27 <Cale> Jafet: what about show . read . show = show?
18:50:29 <nand`> so there are values that cannot be parsed by ‘read’?
18:51:03 <Jafet> Cale: I have a constructor that can decorate the printed string
18:51:28 <Jafet> read won't produce that constructor, so it allows that identity
18:53:53 <nand`> hmm.. weak head normal form = evaluated as far as possible but may not be fully applied; head normal form = evaluated as far as necessary to determine the constructor; normal form = evaluated as far as possible ?
18:54:34 <Jafet> HNF reduces under a closure
18:54:42 <wabash> Hey, friendly haskellers.
18:54:42 <wabash> How wrong-headed of me would it be to use Haskell for something that's all about mutability? Say, evolutionary algorithms?
18:54:48 <Jafet> WHNF stops at the first constructor or at a closure
18:55:02 <startling> wabash, haskell is all about mutability !
18:55:10 <nand`> nonsense
18:55:15 <nand`> haskell is all about equality
18:55:21 * centrinia installs GHC on my Raspberry Pi.
18:55:26 <wabash> startling: I see.. well, most of the + things I see for haskell have to do with immutability
18:55:26 <Zaphod_Beeblebro> guys i have a small question
18:55:28 <Jafet> Mutants are equals, man.
18:55:30 <pharaun> Cale: anyway to further my understanding, only reason second would had worked was if the first value in the tuple was mondaic ?
18:55:32 <carter> hey all, whats the cpp macro for conditionally including some source based upon the ghc version?
18:55:39 <wabash> Zaphod_Beeblebro: Betcha someone has a big answer.
18:55:40 * hackagebot semigroups 0.8.4.1 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.8.4.1 (EdwardKmett)
18:55:44 <carter> #if  .... #endif
18:55:45 <Zaphod_Beeblebro> can i attach a SQL database to a Haskell executable?
18:55:52 <Cale> Jafet: Define a category structure on your type where there is a unique arrow x -> y when y can be obtained from x by deleting some occurrences of that constructor. Then read . show becomes a monad on that category. :)
18:56:12 <edwardk> Zaphod_Beeblebro: no
18:56:14 <Zaphod_Beeblebro> attach and make the program checks info inside it
18:56:16 <carter> i'm doing it subtly wrong and i'm forgetting where good examples are lying around
18:56:28 <wabash> startling: and nand`:   can you guys elaborate?
18:56:30 <carter> edwardk: off hand to you know of a good example ?
18:56:38 <edwardk> Zaphod_Beeblebro: you can probably use some kind of sqlite binding or something
18:57:04 <edwardk> carter: #if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ < 704  .. #endif
18:57:18 <edwardk> 704 is 7.4  -- you can't see minors with that scheme
18:57:23 <Jafet> Cale: yay
18:57:33 <tgeeky> edwardk: that confused me for a solid month
18:57:38 <Cale> pharaun: The problem is that mapM wants a function a -> m b, while second :: (a -> b) -> (c,a) -> (c,b), so if we try mapM (second f), that means a -> m b = (c',a') -> (c',b') for some types a, b, a', b', c'
18:57:39 <Jafet> I already have that arrow, I think
18:57:44 <nand`> edwardk: that seems odd to me
18:57:55 <startling> wabash: we like mutability so much that we make you spell out each explicit step !
18:57:57 <carter> thanks edwardk
18:57:58 <edwardk> nand`: consider ghc 6.12
18:58:10 <tgeeky> 6012!
18:58:10 <nand`> edwardk: I'd really not have them in the same number
18:58:13 <Cale> pharaun: so a = (c', a'), and then m b = (c', b'), and that second equality is unlikely to hold
18:58:27 <edwardk> nand`: its too much of a PITA to do lexicographical versioning if they are separated
18:58:29 <startling> wabash: nah, I don't think it'd be hard. move to ST if you're worried about performance; each iteration would be a state -> state function
18:58:37 <Cale> pharaun: Unless m = (,) c', and b = b'
18:58:38 <wabash> startling: so... would haskell be problematic to use for -------------   ST?
18:58:39 <nand`> edwardk: that just means the CPP macro system is limited
18:58:41 <Zaphod_Beeblebro> is there a database that haskell can edit and check regularly?
18:58:43 <tgeeky> yeah
18:58:44 <edwardk> nand`: yes
18:58:45 <tgeeky> nand`: yeah
18:58:55 * ddarius believes the Givens rotation pseudo-code on Wikipedia is wrong.
18:58:58 <tgeeky> hopefully one day we have genuine support for versioning
18:59:16 <nand`> edwardk: eg. if they allowed tuple types + an appropriately defined comparison operator; it wouldn't be too much of a pain to do #if GHC_VERSION > (6,12,0)
18:59:26 <startling> nand`: haha types in CPP
18:59:37 <wabash> that's funny.
18:59:41 <Jafet> cpphs: NOW TYPE SAFE
18:59:41 <Zaphod_Beeblebro> is there someway to enable color highlighting in ghc?
18:59:42 <wabash> startling: what's ST?
18:59:44 <edwardk> nand`; (,) in c is already overloaded to a more sinister purpose ;)
18:59:46 <startling> wabash: http://www.haskell.org/haskellwiki/Monad/ST
18:59:53 <wabash> thank you.
18:59:56 <wabash> Is it effecient?
19:00:02 <startling> wabash: yes, that's the idea
19:00:12 <nand`> wabash: lots of things can be done in haskell to deal with mutability problems
19:00:23 <wabash> ok, good.
19:00:25 <Cale> edwardk: What if traders were legally allowed to publish bids and offers with arbitrary computable real prices?
19:00:31 <nand`> wabash: from the simple (tail calls) to the complex (concurrent
19:00:41 <nand`> (concurrent, safe mutations, ST, arrays, etc.)*
19:00:44 <Zaphod_Beeblebro> skynet is coded in haskell?... :P
19:00:48 <edwardk> Cale: trying to figure out how to avoid the high frequency trading problems caused by the quantization?
19:01:10 <Jafet> Cale: continuously time-varying, too
19:01:39 <Cale> edwardk: It was just something amusing I thought about the other day. You'd end up with all these computational time-wasting strategies.
19:01:41 <edwardk> Cale: you'd have to worry about someone being evil and putting in a bit that you can't finish calculating if its value equal with a bit from a competing firm ;)
19:01:45 <edwardk> er bid
19:01:47 <ddarius> edwardk: No, he's trying to create new problems.
19:01:55 <edwardk> yep
19:01:57 <Jafet> (First we invoke the axiom of consumer choice...)
19:01:57 <edwardk> thats where i was going
19:02:04 <Zaphod_Beeblebro> sorry, wrong time for a joke i guess :P anyway good night!
19:02:09 <mmos> I just upgraded from Haskell Platform 2010 to 2012. One of my modules used "import System" and used the 'system' function. I am now getting an error: "Could not find module 'System'. It is a member of the hidden package haskel98-2.0.0.1'"
19:02:41 <mmos> this is on Windows 7, by the way
19:02:44 <nand`> wabash: for example, I could sum up a list by remembering a 0 and mutating that for each element of the list, stopping when I reach the end. I can express this in Haskell: let go [] n = n; go (x:xs) n = go xs (x+n); sum xs = go xs 0
19:02:51 <edwardk> Cale: well, honestly? if i was presented with a bunch of these bids i'd start evaluating them all in parallel. the crazy complex long ones that i can't bother comparing with one another i'd eventually just reject, they are wasting my time and resources
19:03:02 <Jafet> mmos: System.Cmd.system
19:03:14 <Jafet> Or tell ghc to use the (deprecated) haskell98 package
19:03:30 <nand`> Jafet: haha
19:03:33 <edwardk> no point bargain hunting past a point, and the reason the HFT guys bid fast is because of the quantization and winner-gets-all-nature of making the market first
19:04:10 <edwardk> if you add all the computable real nonsense to it, you break up the quantization, but you make a host of other problems
19:04:31 <Cale> I think we should do this just to watch people write really good libraries for working with computable reals
19:04:39 <Cale> lol
19:05:00 <benmachine> can't we just make finance turn-based :(
19:05:12 <edwardk> but even just adding a dozen decimal places to the currencies would probably break the existing logjam and make better markets with smoother walls
19:05:18 <Cale> Of course, they'd probably never get released to the public
19:05:19 <Jafet> It's turn-based for consumers.
19:05:29 <edwardk> benmachine: yes, you wait your turn while everyone else steals your money ;)
19:05:50 <benmachine> edwardk: sounds legit
19:06:13 <nand`> finance should be based on die rolls
19:06:20 <edwardk> benmachine: well, the HFT guys just make the spread from doing the whole market making thing. its not _that_ big of a deal that they exist and are faster than you ;)
19:06:21 <Jafet> To some extent it is
19:06:31 <Jafet> Futures trading
19:06:46 <tgeeky> as long as some people get preferred access to markets, then they can go fuck themselves.
19:07:12 <tgeeky> unless someone really smart can explain to me how that's fair
19:07:17 <mgsloan> it would be kinda cool, imho, if the stock market was something reasonable like 1 min quantization
19:07:35 <mgsloan> give humans a fair chance against computers 'n such
19:07:40 <edwardk> tgeeky: you have to have a market to able to trade something. having _someone_ willing to put up a bid-ask spread gives you the ability to trade it at all.
19:07:45 <benmachine> mgsloan: with my zero knowledge of finance, I agree
19:07:57 <nand`> humans have all the fair chance they want
19:07:58 <benmachine> mgsloan: I'm not sure how you'd stop everyone from just constantly and brutally cheating, though
19:08:07 <nand`> it's just their responsibility to develop appropriately smart algorithms
19:08:17 <tgeeky> edwardk: right, I'm pissed that some people can pay a few thousand dollars to operate on a 25ms window or whatever they get
19:08:21 <Jafet> mgsloan: computers have no chance at all, they are run by humans
19:08:23 <tgeeky> and "the rest of us" are out cold
19:08:27 <mgsloan> yeah, I've played with the stock market a bit (or vice versa), but pretty ignorant of it
19:08:29 <edwardk> i'm not saying the HFT guys are angels, or that the current system is good, but the fact that they exist doesn't really prevent you from profitably trading
19:08:40 <Jafet> tgeeky: unless you also pay a few thousand dollars?
19:08:57 <benmachine> edwardk: but what if instead of them having money, I had it instead
19:09:01 <benmachine> edwardk: what then
19:09:01 <mgsloan> benmachine: well, that's a problem either way ;)
19:09:05 <wabash> nand`: thank you for the example
19:09:13 <tgeeky> Jafet: it doesn't matter how much it costs, it's that it costs
19:09:16 <mgsloan> (the brutal cheating)
19:09:17 <wabash> nand`: In the end, this basically iterates and sums?
19:09:22 <benmachine> mgsloan: true
19:09:34 <nand`> wabash: it keeps calling itself until it reaches the end of the list, yeah
19:09:41 <nand`> you can see that as a sort of ‘iteration’
19:09:52 <benmachine> edwardk: basically it's this whole "people who are not me having money" thing that gets on my nerves
19:09:59 <edwardk> benmachine: from what market? someone has to set up the bid-ask spread, and if you don't have the HFT guys there, then that spread is going to be built slower, and since its made slower and with less surety the spread will be larger, because you go to some guy standing around on a floor calling out numbers
19:09:59 <tgeeky> benmachine: hehe
19:10:37 <mgsloan> benmachine: yeah, "people who are not me having money, and having no predilections towards spending it on making nifty Haskell things"
19:10:46 <edwardk> benmachine: the wider spread dries up liquidity and grinds trading in your chosen community to a halt, so even if you know the true value of something "a little bit better than the market", you can't capitalize on that knowledge
19:11:00 <edwardk> having the HFT guys there at least means you can trade on smaller bits of knowledge
19:11:17 <edwardk> er s/community/commodity
19:11:19 <ddarius> benmachine: If you had all the money, money would have no value.
19:12:40 <Jafet> The capitommunist utopia?
19:12:51 <edwardk> benmachine: and humans running the process cost a hell of a lot more than the machines. you can set up a bunch of servers each set up to provide more or less blind spreads on 50 different things or you can have one human doing a couple of things.
19:13:31 <ddarius> That's why historic downtown New York hotels are now solid masses of computational machinery.
19:13:42 <edwardk> pretty much
19:14:36 <benmachine> edwardk: sure, that's all fairly reasonable
19:15:11 <tgeeky> hm
19:15:15 <tgeeky> EMP in new york
19:15:21 <Cale> Though, being able to trade on smaller bits of knowledge is also kind of weird, because it's unclear that anyone actually has knowledge which is at that scale.
19:15:23 <edwardk> it took me a while until i actually understood the HFT space enough that i didn't despise it for existing. ;) now, there is a certain stupidity to the winner-takes-all nature of it for who puts in a bid at a given price and all the games you can play with putting in prices you don't plan to honor, etc.
19:15:23 <tgeeky> economic devestation
19:15:56 <edwardk> Cale: well, think of it this way, if i have a slightly better model than the rest of the market does, i should be able to communicate that information to the market
19:15:57 <benmachine> tgeeky: isn't the usual method of deploying an EMP a nuclear bomb?
19:16:09 <benmachine> in which case, well, yes. devastation of more than one kind :P
19:16:21 * ddarius should learn the precedence of (@>)
19:16:29 <tgeeky> benmachine: yes, and yes :)
19:16:32 <edwardk> Cale: if i can't communicate that information to the market then the market is more inefficient because of the bad bid-ask spread
19:16:32 <edwardk> ddarius: from Control.Comonad?
19:16:39 <ddarius> edwardk: No, from hmatrix.
19:16:42 <edwardk> ah
19:17:04 <nand`> what's @> in Control.Comonad?
19:17:07 <tgeeky> benmachine: one of the scariest scenarios is a pair of high altitude 15 MT EMP-tweaked devices.
19:17:16 <tgeeky> Two of them could knock out both coasts entirely
19:17:22 <edwardk> Cale: the way you communicate that sort of information to the market is by buying and selling, grabbing options, etc.
19:17:30 <Cale> edwardk: And the idea is that you'll lose money if your model is actually not better after all?
19:17:33 <benmachine> tgeeky: fortunately enough there's an ocean in between me and either coast
19:17:37 <edwardk> if the spread is too wide, its not worth doing any of those things
19:17:41 <edwardk> Cale: yep
19:17:56 <benmachine> tgeeky: and I'm absolutely certain that an entire continent of electronics being wiped out would not ruin my life indirectly at all.
19:18:08 <ddarius> tgeeky: Two of them can cover the entire US solidly and entirely.  One can cover like 3/4 of the US.
19:18:08 <tgeeky> benmachine: hehe, yes. Only the people in the very middle of the country would survive. Well, all people would survive, but all electronics would go.
19:18:19 <tgeeky> ddarius: yep. I have the studies to prove it :)
19:18:20 <ddarius> benmachine: It depends on the continent.
19:18:31 <benmachine> ddarius: nooo not the antarctic :(
19:18:35 <Cale> edwardk: Well, in the long run, that is the expected case, anyway
19:18:38 <tgeeky> ddarius: there are probably more EMP-tweaked weapons that we'd like to admit
19:19:01 <edwardk> cale: sure. you need to have enough money in the game to smooth over short term bumps ;)
19:19:09 <tgeeky> this is the reason that people with ICBMs are so much scarier than people with nukes
19:19:20 <tgeeky> (alone)
19:20:02 <carter> tgeeky: if there was an EMP this comming week, you'll have a hitman after you fast 'cause i'll know it was you
19:20:03 <carter> :)
19:20:41 <mgsloan> time to build a house-sized faraday cage, methinks
19:20:43 <benmachine> carter: do you know any hitmen who are contactable by post? :P
19:21:09 <carter> benmachine: no, but I know a lot of athletic computer scientists who'd be grumpy
19:21:14 <Cale> edwardk: I wonder if there's a way to systematically de-emphasise "cheesy" strategies which are short-term gambles with bad long-term expectations.
19:21:23 <benmachine> carter: athletic computer scientists? we know different people
19:21:25 <byorgey> benmachine: do you know any hitmen with an email address?
19:21:33 <carter> haha
19:21:52 <carter> byorgey: the world champ at whack a mole?
19:21:57 <carter> he's a hit man
19:21:57 <benmachine> byorgey: admittedly, no. is there a murdering.stackexchange?
19:22:00 <byorgey> hehe
19:22:34 <edwardk> Cale: most of those strategies involve someone going short improperly hedged and having unbounded downside risk, so they take themselves out of the market =P
19:22:39 <carter> ironically, the whack a mole champ has mob connections
19:23:14 <mgsloan> maybe whacking moles is a similar skill to whacking people
19:23:20 <ddarius> Yay unbounded downside risk!
19:23:20 <Cale> edwardk: I mean, you sort of have the fact that there are bad long-term expectations already putting some pressure to not do those things, but, in all the partial information games I know, there are always going to be some players who want to end the game quickly with either a large win or complete loss.
19:23:44 <carter> edwardk Cale :  i've heard some anecdots about how other traders treated the Knight Trading bug opportunistially
19:24:09 <nand`> this conversation feels like it would be better suited for #haskell-blah
19:24:11 <Cale> (rather than playing the game skillfully for a guaranteed win in the long run()
19:24:28 <carter> basically it seems that people in finance are moreso "anti" professional towards their competitors
19:24:46 <carter> nand` : does the haskell blah channel exist?
19:24:52 <nand`> carter: yes
19:25:00 <edwardk> nand`: point taken
19:25:01 <geekosaur> #haskell-blah is the standard offtopic channel, yes
19:25:59 <carter> on an related note: seems that the date type for getModificationTime has changed in 7.6.1
19:26:00 <benmachine> there is more leniency when actual haskell conversatio is quiet, though
19:26:05 <benmachine> +n
19:28:31 <stew> is someone else using scion-mode in emacs.  is it just me or is it completely broken?
19:29:19 <stew> many commands seem to result in "parse error"
19:29:42 <stew> which seems to be the server telling me that it doesn't recognize any of the verbs
19:30:19 <pharaun> Cale: hm, wouldn't (mapM (second f)) work if the input is (c, (m a)) and the f also take (a -> m b) which is really ((m a) -> m (m b)) ?
19:31:12 <Cale> pharaun: it works in exactly the case that I said it would -- when m = (,) t for some type t.
19:32:44 <pharaun> Cale: (,) is a monadic type?
19:33:59 <pharaun> hm its not
19:34:39 <Cale> pharaun: (,) m is a monad when m is a monoid.
19:39:07 <Cale> pharaun: specifically,  return x = (mempty, x),  fmap f (u,x) = (u, f x), and join (u, (v, x)) = (mappend u v, x)
19:39:33 <gogozeppeli> I have a question about Haskell. Does anyone know where I can find this one document detailing the history of the design and creation of Haskell?
19:39:43 <ddarius> @google "History of Haskell"
19:39:45 <lambdabot> http://www.haskell.org/haskellwiki/History_of_Haskell
19:39:45 <lambdabot> Title: History of Haskell - HaskellWiki
19:40:27 <pharaun> Cale: i think i kind of get it, i'm reading up on monoids now to make sure
19:42:26 <Cale> pharaun: as an example, you could take m = [String], with mempty = [], and mappend = (++)
19:43:17 <geekosaur> @google wearing the hair shirt
19:43:18 <lambdabot> http://en.wikipedia.org/wiki/Cilice
19:43:18 <lambdabot> Title: Cilice - Wikipedia, the free encyclopedia
19:43:22 <geekosaur> bah
19:43:25 <geekosaur> @google wearing the hair shirt haskell
19:43:26 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/haskellretrospective.pdf
19:43:26 <lambdabot> Title: Wearing the hair shirt Wearing the hair shirt
19:44:55 <gogozeppeli> Huh... I didn't expect to find these on Microsoft's website
19:45:35 <pharaun> Cale: aha i'm probably just slow, i'll mull on this for a while, thanks :)
19:45:51 <gogozeppeli> Thanks
19:53:52 <geekosaur> gogozeppeli, SPJ works for Microsoft Research along with a number of other key Haskell people
19:55:19 <pharaun> Cale: well thanks, that exposed me to some new aspects (monoids, and etc) :)
19:55:34 <Cale> pharaun: cool :)
19:56:27 <Cale> pharaun: It's probably worth pointing out that this is the same thing as the Writer m monad
19:57:23 <pharaun> yeah am currently reading up on the writer stuff and bouncing off to finger trees :p
19:57:45 <Cale> Ah, finger trees are really cool
19:58:21 <Cale> Monoidally indexed trees deserve a lot more attention from computer science in general.
19:58:35 <Cale> Are you looking at the paper about them?
19:58:51 <Cale> (i.e. http://www.soi.city.ac.uk/~ross/papers/FingerTree.pdf)
19:59:59 <pharaun> not that one just yet, just getting some higher level familiarity on the subject first
20:01:29 <byorgey> yeah, read apfelmus's blog post on it first
20:01:41 <pharaun> haha yeah i am
20:01:48 <byorgey> ok, good =)
20:03:07 <Cale> pharaun: The finger trick that they use to give constant-time access to both ends of the structure is nice, but I think the real nice thing to take away from that paper is the idea of a tree structure built on a sequence of leaves whose branch nodes are labelled with values of some monoid, where the idea is that there is some function assigning "summary" values in that monoid to each of the values stored in the leaves,
20:03:07 <Cale>  and each branch of the tree holds the monoidal composition of all its leaves.
20:04:00 <Cale> The fact that the monoid has a unit gives us a way to assign a value to an empty tree, and the fact that it's associative means that we can rebalance the tree as we please without having to recompute many of the summaries.
20:05:01 <Cale> Almost everywhere that you're using a tree in order to obtain some performance benefit fits in as an example of this somehow.
20:05:20 <Cale> (throughout computer science)
20:07:03 <Cale> For a simple example of a sequence datastructure, you could use the monoid of natural numbers under addition, and assign every leaf the value 1, so that the branch nodes each get labelled with the size of the tree (how many leaves)
20:07:36 <pharaun> Cale: so on the monoid part, if i change/rebalance the tree, i only need to recompute what changed?
20:08:07 <Cale> yeah
20:08:47 <Cale> pharaun: and you even get to avoid recomputing the summary on the root
20:09:10 <Cale> pharaun: because the operation is associative, you can just steal the summary that the previous root had when you rotate the tree
20:10:41 * hackagebot simple-config 1.0.0 - Simple config file parser generator  http://hackage.haskell.org/package/simple-config-1.0.0 (YusukeNomura)
20:10:43 * hackagebot lens 2.7 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-2.7 (EdwardKmett)
20:11:25 <Cale> edwardk: what's new? :)
20:11:35 <Cale> (in lens)
20:11:49 <edwardk> Cale https://github.com/ekmett/lens/blob/master/CHANGELOG.markdown
20:12:47 <pharaun> Cale: oh i think i get it now... ie you have tree that is like (from the blog) (v1 <> v2) <> (v3 <> v4) now thanks to the associativity/(monaids?) i can have the tree look like say v1 <> (v2 <> (v3 <> v4)) and i'm still good on the root summary, etc?
20:13:09 <Cale> pharaun: right
20:14:15 <pharaun> so when i rebalance the tree, i just update the changed value, and done, the rest of the value would hold true thanks to being monaids
20:14:22 <Cale> monoids*
20:14:28 <Cale> actually, there's just one monoid
20:14:28 <pharaun> sorry
20:14:44 <Cale> and all the values v1,...,v4 are elements of that monoid
20:14:45 <edwardk> cale: mostly improvements to the api, a few more operators, making the type signatures for some of the lens combinators more general so users can avoid passing around two copies of the same lens, and a huge number of extra tests.
20:15:00 <pharaun> tests++
20:15:07 <Cale> cool
20:17:00 <Cale> edwardk: heh, I was thinking the other day it's kinda funny how many op~ operators there are, and now there are more :)
20:17:18 <pharaun> how readable is the finger paper?
20:17:28 <pharaun> this is probably the first paper that i've tried to read in recent memory
20:17:33 <edwardk> the +~, etc operators?
20:17:33 <Cale> Pretty readable, though you might find yourself wanting to skim some bits of it
20:17:39 <Cale> edwardk: yeah
20:18:02 <Cale> edwardk: Isn't %~ enough?
20:18:13 <edwardk> Cale: +=, etc. is really really convenient
20:18:35 <edwardk> and you need more than just %~, you need at least %%~ as well
20:19:04 <edwardk> plus, some of these can work with setters, but the <+=  variants need a lens (or occasionally a traversal)
20:19:14 <edwardk> and they give you back the result of having set that part
20:19:31 <edwardk> all of which can be implemented with %%~ by a smart enough user
20:20:24 <Cale> But, for instance, instead of writing foo += 5, I could always just write foo %= (+5), which is really not much less convenient, no?
20:21:33 <Cale> Well, I guess it's nice :)
20:25:45 <edwardk> i find it rather inconvenient =P
20:25:53 <edwardk> and yes, you could do that
20:26:12 <Clint> is there a superlensy way of doing liftA2 (&&) ("LOCK" `elem`) ("UNLOCK" `elem`) . _allowedMethods ?
20:26:48 <edwardk> Clint: not off hand
20:27:11 <Clint> ok
20:27:30 <edwardk> cale: you can always just write all of these combinators directly using the lens of course ;)
20:27:59 <edwardk> runIdentity . _2 (Identity . (+1))  -- but at what point is that uglier? =)
20:28:32 <Cale> as soon as you have to mention the functor, it's uglier :)
20:28:51 <Cale> but yes, I see your point
20:29:09 <edwardk> well, when you use %%~ to extract the value you modified, you needed to pick (,) e as the functor, and plumb the answer out to it as well as the result
20:29:16 <Cale> I guess I'm still used to writing things like  modify (+5)
20:29:27 <edwardk> rather than use: fresh = id <+= 1
20:29:34 <Cale> so it doesn't seem so onerous to me
20:30:20 <edwardk> well, ballSpeed.both *= speedMultiplier   reads a bit nicer to me than random parens and an operator
20:30:36 <edwardk> ballSpeed.both %= (*speedMultiplier) is noisy by comparison
20:38:40 <edwardk> ultimately i think the main value of the combinators offered is their overall consistency operator~ or operator=   with a <operator~ and <operator= variant for 'also returning what was worked on'
20:38:59 <edwardk> so the vocabulary for them is relatively small
20:39:40 <edwardk> %= is actually one of the few operators people tend to gripe at me about, because its not a classic c-like operator ;)
20:55:32 <Ferdirand> [5~[5~[6~[6~
20:55:33 <Ferdirand> [29~^.
20:55:46 <Ferdirand> oops, sorry about that
21:10:51 <martint> is there a name for inductive-ish data structures where the values don't necessarily have unique representations in terms of the data constructors, i.e. set-as-list
21:23:08 <nand`> edwardk: arguably I think for that fresh = id <%= succ is prettier
21:23:11 <nand`> fresh <- I mean
21:24:44 <pharaun> a question. say you have "if count [1..] > 3 then foo else baz" the [1..] is an infinite list, is haskell lazy eval intelligent enough to abort once the count is greater than 3 ?
21:25:04 <shachaf> Haskell lazy evaluation isn't intelligent at all.
21:25:17 <shachaf> It follows very simple rules.
21:25:28 <pharaun> badly worded i guess, but i mean once you are past 3 there's no point in continuing that computation
21:25:31 <parcs`> pharaun: nope
21:25:36 <shachaf> If you're using Int or Integer, it won't.
21:25:52 <shachaf> If you're using lazy naturals, it probably will (but you would know if you were).
21:25:56 <parcs`> pharaun: you can do 'if length (take 4 [1..]) > 3 then'
21:26:24 <pharaun> shachaf: parcs` thanks, that's what i figured :)
21:26:31 <pharaun> parcs`: yeah that certainly would work :)
21:26:52 <pharaun> shachaf: i was mainly wondering if you could do that kind of tweak internally in the compiler
21:27:03 <nand`> there are other things that may seem logical to a human but the semantics have no way of knowing, eg consider [ x*2 | x <- [1..], x < 5 ]
21:28:10 <shachaf> pharaun: The semantics of Int/Integer prevent you from doing it.
21:28:13 <nand`> pharaun: compiler tweaks and the like should not change semantics
21:28:34 <shachaf> The behavior of a program (terminating or non-terminating, for example) shouldn't be affected by internal compiler optimizations.
21:29:03 <Playground> Is there anything like getChar, but which does not print the character?
21:29:31 <shachaf> Playground: hSetEcho
21:29:31 <parcs`> Playground: hSetEcho
21:29:36 <shachaf> @yarr
21:29:36 <lambdabot> I'll keel haul ya fer that!
21:29:50 <parcs`> @quote
21:29:51 <lambdabot> syntaxglitch says: writing DRM isn't possible in Haskell, since it doesn't actually do anything useful GHC simply optimizes it away
21:30:53 <parcs`> is ghc smart enough to constant fold 'null [ () | a <- [1..], b <- [1..], c <- [1..], n <- [3..], a^n + b^n == c^n ]'
21:32:06 <nand`> I'm not sure if it should do that; what if the property you're checking takes a few years to find the first example?
21:35:25 <Nisstyre-home_> parcs`: umm, that will never yield True...
21:35:31 <Nisstyre-home_> I assume you know that already?
21:35:53 <Nisstyre-home_> oh wait
21:35:56 <Nisstyre-home_> maybe it will
21:36:40 <Nisstyre-home_> oh no, it won't
21:36:41 <nand`> no, since it'd have to reach the end of all lists for that
21:36:44 <Nisstyre-home_> I misread the code
21:37:07 <nand`> it also won't reach false either, since it's testing 1^3 + 1^3 == 1^3, followed by 1^4 + 1^4 == 1^4, ...
21:37:07 <dysinger> who's working on an update for cabal-install for ghc 7.6? should I tackle that or do you think it's already in the works?
21:37:12 <Nisstyre-home_> nand`: I assume Fermat's last theorem applies for all numbers
21:37:31 <Playground> shachaf, parcs`: Sorry, I was away, thank you.
21:37:57 <Nisstyre-home_> nand`: right, it'll never evaluate to anything I guess
21:38:19 <nand`> oh
21:38:24 <nand`> I think parcs` was joking, now that I think about it
21:38:26 <parcs`> dysinger: it's in the works, according to the git log
21:38:27 <popl> Nisstyre-home_: FLT applies for all Z+
21:38:29 <Nisstyre-home_> nand`: me too
21:38:40 <parcs`> yes i was making a funny
21:38:45 <Cale> huh, where's preflex?
21:38:46 <dysinger> parcs`:  sweet thanks - was just cloning
21:38:48 <nand`> these kinds of things slip past me when it's 6:30 in the morning
21:38:50 <popl> sorry, ℤ+
21:39:06 <popl> I need to map those to something.
21:39:22 <nand`> ℤ⁺, aka ℕ ?
21:39:22 <Nisstyre-home_> popl: so it only applies to integers?
21:39:29 <Nisstyre-home_> positive ones that is
21:39:35 <nand`> or is 0∉ℤ⁺
21:39:42 <Nisstyre-home_> yeah, aka naturals
21:39:48 <Nisstyre-home_> or does that include 0?
21:39:55 <nand`> I don't know. I presume positive excludes 0
21:40:42 <popl> 0 is not positive or negative
21:40:49 <popl> it is sad
21:41:12 <nand`> as far as I'm concerned, there are three signs: positive, zero and negative
21:42:26 <pharaun> well with computers there's +- 0
21:42:33 <nand`> not necessarily
21:42:34 <arbn> Whether zero is in ℕ is a matter of taste/problem-domain, right?
21:43:35 <popl> sorry -- I am incorrect. only the exponents are explicitly gt 2.
21:43:38 <popl> http://mathworld.wolfram.com/FermatsLastTheorem.html
21:43:40 <nand`> arbn: afaik the question of how to denote the various ℕ and ℤ-like sets either including or excluding 0 has been a matter of inconsistency; but I generally consider 0 to be in ℕ
21:44:32 <Nisstyre-home_> Well, fwiw, Bertrand Russell includes it in Introduction to Mathematical Philosophy when he goes over Peano's axioms
21:45:10 <Nisstyre-home_> I can't remember if he says "positive integers" or "natural numbers" though
21:45:21 <Nisstyre-home_> probably the latter
21:45:36 <nand`> yeah including 0 gives ℕ some nice properties, such as giving rise to a monoid freely generated under addition by 0 and 1; which is essentially what peano numbers are
21:45:41 <Cale> I wonder if FLT is undecidable in PA.
21:45:42 <arbn> Well, if you're using Peano's axioms to bootstrap natural numbers, you really need 0 to be one. :P
21:46:00 <Cale> The proof uses ZFC + Universes
21:46:15 <Nisstyre-home_> arbn: well, as he points out in the book, they really can be anything that satisfies the properties needed
21:46:22 <Nisstyre-home_> they don't have to be numbers
21:46:24 <Playground> Is there any reason why the usual IOs are not actually "(MonadIO m) => m"s?
21:46:51 <Playground> Lifting IO all the time is too cumbersome.
21:47:05 <Cale> Playground: because the point of MonadIO is that you can turn plain IO things into things in your more structured monad
21:47:25 <Cale> So if you have a plain IO thing, you can just write it as one, and use liftIO on it.
21:47:32 <nand`> Playground: there are some approaches to a prelude with classes for anything and everything
21:47:57 <Nisstyre-home_> arbn: the most mind-fucky thing about the Peano axioms is how they give rise to proof through induction
21:48:17 <nand`> from what I can tell, they aren't too well received because the extra generality gives rise to a lot of ambiguous type errors, not to mention type complexity throughout
21:49:17 <Playground> Is there any way to replace the standard Prelude with my own, then?
21:49:22 <Cale> Nisstyre-home_: is it really mind-fucky to include induction as an axiom?
21:49:27 <arbn> Nisstyre-home_: That's interesting. This in "Introduction to Mathematical Philosophy", id est, "A few big ideas from PM for sane people"?
21:49:49 <Nisstyre-home_> Cale: the understanding why it allows for proof through induction is
21:49:55 <arbn> This is in*
21:49:58 <Nisstyre-home_> at least to me it is
21:49:58 <Playground> (Actually, my Prelude would be a reorganization of the existing one, I would not write it from scratch.)
21:50:11 <Nisstyre-home_> arbn: this was after he wrote PM I think, whilst he was in prison
21:50:21 <nand`> Playground: you can import the existing Prelude hiding the names you want to redefine
21:50:24 <Cale> Nisstyre-home_: well, maybe I'm looking at a different set of axioms from you...
21:50:25 <Nisstyre-home_> arbn: it was meant to be a "plain English" introduction to some of the ideas of PM\
21:50:28 <Nisstyre-home_> *PM
21:50:36 <arbn> Nisstyre-home_: Right. That's what I meant. :P
21:50:49 <Cale> Nisstyre-home_: But usually one of the axioms of PA is almost directly "induction has to work"
21:51:31 <Nisstyre-home_> Cale: "Any property which belongs to 0, and also to the successor of every number which has the property, belongs to all numbers."
21:51:45 <Cale> yeah
21:53:18 <Nisstyre-home_> Cale: the mindfuck, for me, comes when realizing how that can be used
21:53:48 <Nisstyre-home_> http://people.umass.edu/klement/imp/imp.html#chapter1
21:55:03 <Nisstyre-home_> and the "generalized" version he gives: This becomes: Any property which belongs to x0, and belongs to xn+1 provided it belongs to xn, belongs to all the xs.
21:55:05 <Playground> @hoogle hSetEcho
21:55:06 <lambdabot> System.IO hSetEcho :: Handle -> Bool -> IO ()
21:55:06 <lambdabot> GHC.IO.Handle hSetEcho :: Handle -> Bool -> IO ()
21:55:26 <Playground> @hoogle stdin
21:55:27 <lambdabot> System.IO stdin :: Handle
21:55:27 <lambdabot> GHC.IO.Handle.FD stdin :: Handle
21:55:34 <Cale> Nisstyre-home_: Are you familiar with the more general form of induction on sets with an appropriate ordering?
21:55:44 <Nisstyre-home_> Cale: yes, somewhat
21:56:07 <Nisstyre-home_> Cale: he covers ordering in a later chapter
21:57:49 <dobblego> is there a coliftIO :: m a -> IO a?
21:58:11 <shachaf> Doing what?
21:58:22 <Cale> dobblego: not in the libraries
21:58:35 <Cale> dobblego: You could define a class for operations like that, I suppose.
21:59:00 <Cale> (but it's hard to imagine too many useful instances)
21:59:58 <dobblego> in a similar effort as: colift: ComonadTrans f => t f a -> f a
22:00:03 * sipa wonders what coliftIO [1,2,3] would do
22:00:07 <dobblego> yeah, but one is enough for me :)
22:00:47 <rwbarton> that one is even harder to imagine
22:00:59 <rwbarton> sipa, something with threads maybe? :)
22:01:17 <dobblego> [] is not a comonad, but does have extend
22:01:27 <nand`> but IO isn't a comonad, why should be in the comonad transforming hierarchy?
22:01:28 <shachaf> rwbarton: I'd rather have deterministic nondeterminism.
22:01:57 <Cale> Nisstyre-home_: If you have a set S with a relation <= on it, satisfying the property that any nonempty subset A of S has a minimal element m, that is, there is no x in A with x <= m, then induction will work with respect to that "ordering" (even if we require none of the other usual properties of a total or partial ordering)
22:01:59 <rwbarton> that sounds difficult
22:02:25 <rwbarton> oh, I assumed f was still a monad
22:02:41 <rwbarton> "MonadCotrans" (though really all the terminology here is awful)
22:02:46 <dobblego> perhaps s/IO/OI — sorry didn't think it through a lot
22:03:00 <shachaf> What's OI?
22:03:04 <dobblego> I use comonad transformer quite a lot
22:03:08 <Nisstyre-home_> Cale: okay, that makes sense
22:03:30 <edwardk>  OI is something you can safely ignore because it doesn't work in haskell
22:03:51 <sipa> coIO?
22:03:55 <dobblego> @google codata and comonads in haskell
22:03:57 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.5169&rep=rep1&type=pdf
22:03:57 <lambdabot> Title: Codata and Comonads in Haskell1
22:04:29 <edwardk> basically OI isn't sound because of every functor in haskell is strong
22:04:36 <edwardk> er because every
22:05:34 <rwbarton> oh, edwardk, I didn't forget to post the 7.2 lens build error, I just suddenly became busy for 14 hours
22:05:41 <rwbarton> do you still want it?
22:05:46 <edwardk> sure
22:05:59 <edwardk> can you check to see what lens 2.7 says too?
22:06:01 <rwbarton> can you remind me of the issues url?
22:06:13 <rwbarton> or i can just hpaste
22:06:14 <edwardk> github.com/ekmett/lens/issues
22:06:35 <edwardk> the issue will act as a reminder for me to do something
22:06:39 <rwbarton> ok
22:06:42 <shachaf> rwbarton: Is that GHC 7.2?
22:07:00 <rwbarton> yeah
22:07:03 <shachaf> Why are you using GHC 7.2?
22:07:12 <rwbarton> I dunno
22:07:13 <shachaf> I thought people weren't really supposed to use that.
22:07:27 <shachaf> "technology preview" or something like that that people say when something doesn't work.
22:07:29 <rwbarton> it was the most recent version the last time I upgraded ghc? :)
22:07:41 <Cale> Nisstyre-home_: In particular, if A is any subset of S such that whenever all x <= y are in A, then y is in A as well, we can prove that A = S. Specifically, if A is not equal to S, then we can consider the set S \ A = { x in S : x not in A }. This must then be nonempty, and so it'll have some minimal element m. But that means that for all x <= m we have x in A (or else m wouldn't be minimal), and so by assumption, m i
22:07:41 <Cale> s in A as well, which is a contradiction.
22:07:43 <rwbarton> it seems to pretty much work
22:07:48 <Cale> Nisstyre-home_: and so S = A :)
22:08:25 <Cale> Nisstyre-home_: This is a form of induction which will work, even on larger infinite sets than the natural numbers :)
22:08:28 <rwbarton> @hackage lens
22:08:29 <lambdabot> http://hackage.haskell.org/package/lens
22:08:36 <shachaf> rwbarton: What are you talking about? Even "lens" doesn't build!
22:08:40 <shachaf> (I hear.)
22:08:56 <rwbarton> true
22:09:18 <rwbarton> that is probably because lens is too new though, not because ghc 7.2 was too new :)
22:10:02 <Cale> oh, sorry, I should have used < for the relation :P
22:10:12 <Cale> <= is suggestive in the wrong way :P
22:10:32 <Nisstyre-home_> Cale: yeah, that makes some sense
22:10:43 <Nisstyre-home_> my eyes are kind of bleary atm though
22:10:55 <rwbarton> edwardk: hmm, I just did cabal update but "$ cabal install lens-2.7 # cabal: There is no available version of lens that satisfies ==2.7"
22:11:19 <edwardk> rwbarton: odd
22:11:22 <rwbarton> yeah
22:11:34 <edwardk> rwbarton: i uploaded it to hackage just an hour or two ago
22:12:31 <rwbarton> where does cabal keep its package database? the one cabal update updates
22:13:37 <edwardk> probably in ~/.cabal
22:13:40 <rwbarton> oh, i found it, .cabal/packages/hackage.haskell.org/00-index.tar
22:13:47 <rwbarton> yeah it's not there
22:14:04 <rwbarton> does that file only get updated every few hours maybe?
22:14:26 <rwbarton> on hackage I mean
22:14:39 <luite> no it's updated instantly
22:15:16 <luite> although i think in some cases the upload log is updated before the archive is actually available
22:15:31 <rwbarton> well http://hackage.haskell.org/packages/archive/00-index.tar.gz doesn't have lens-2.7 but http://hackage.haskell.org/package/lens-2.7 exists
22:15:45 <edwardk> interesting
22:15:47 <luite> hmm
22:16:03 <rwbarton> I can just manually download the .tar.gz like a caveman
22:17:10 <Cale> lol, like a caveman
22:17:11 <rwbarton> er, where is Control.Lens.Combinators supposed to be
22:17:23 <Saizan> you can cabal install $url_of_a_tarball, iirc
22:17:23 <edwardk> rwbarton: hrmm did that not get packaged?
22:17:25 <edwardk> woops
22:17:29 <edwardk> let me try again
22:18:21 <rwbarton> Saizan: ah yes, that does seem to work
22:19:46 <Playground> @hoogle Char -> Int
22:19:47 <lambdabot> Data.Char digitToInt :: Char -> Int
22:19:47 <lambdabot> Data.Char ord :: Char -> Int
22:19:47 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
22:20:56 <edwardk> rwbarton: guessing what happened is i uploaded it, it was missing a file, and it refused to put it in the package index
22:21:22 <rwbarton> sounds likely yeah
22:21:27 <td123> is control.exception in ghc 7.6.1 replaced with extensible-exceptions?
22:21:32 <rwbarton> not exactly the ideal behavior
22:21:38 <edwardk> i just pushed 2.7.0.1
22:23:36 <rwbarton> okay, same build error as lens-2.6 except the line number changed by 1
22:23:55 <edwardk> can you hpaste?
22:24:02 <rwbarton> https://github.com/ekmett/lens/issues/41
22:24:28 <edwardk> oh, yeah that needs 7.4 i think =)
22:24:33 <rwbarton> might actually be the sort of problem shachaf was talking about
22:24:42 <edwardk> that is really something that 7.2 didnt have
22:25:54 <edwardk> i'll bump the lower bound on base. what version of base shipped with 7.2?
22:26:05 <rwbarton> base-4.4.0.0
22:26:19 <edwardk> so base 4.5 is probably what i need to require
22:26:54 <edwardk> i can probably make it 7.2 compatible with some work
22:27:03 <rwbarton> that is basically the outcome i expected. though won't 7.2 users just get an old version that has the looser base constraint
22:27:10 <rwbarton> rather than a proper error
22:27:18 <rwbarton> but, meh
22:27:21 <edwardk> yeah
22:28:00 <rwbarton> if i saw that error, and then saw i was getting an old version and the new version had a higher base constraint, i would figure it out
22:28:19 <edwardk> let me see if i can get 7.2 to work. do you mind pulling a few times from the github repository to test to make sure i get it right?
22:29:25 <rwbarton> sure, i can do that
22:30:09 <edwardk> k. adding some checking for whether or not MPTC default signatures are legal and will only turn them on on new ghcs
22:30:45 * hackagebot lens 2.7.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-2.7.0.1 (EdwardKmett)
22:32:18 <rwbarton> what does this do anyways, I can give a default method with a refined type and it only applies when the type matches?
22:32:28 <edwardk> yeah
22:32:37 <edwardk> i use it to avoid writing a lot of boilerplate
22:32:46 <edwardk> to make 7.2 happy i need to put in all that boilerplate
22:33:12 <edwardk> its mostly a dozen lines of 'ifoldMap = ifoldMapOf itraversed' etc.
22:35:02 <edwardk> ok, pushing
22:35:45 * hackagebot math-functions 0.1.1.2 - Special functions and Chebyshev polynomials  http://hackage.haskell.org/package/math-functions-0.1.1.2 (BryanOSullivan)
22:35:49 <edwardk> git clone https://github.com/ekmett/lens.git and build it from there, see what happens.
22:36:26 <rwbarton> okay, now there is an exciting new error...
22:36:30 <edwardk> oh?
22:36:54 <hpaste> rwbarton pasted “lens on ghc 7.2.1” at http://hpaste.org/74463
22:39:24 <edwardk> ah, i can probably flip that to use infixE instead
22:39:48 <edwardk> it'll just take a little code =)
22:41:52 <edwardk> pull and try again
22:42:16 <edwardk> er apparently i gave it the wrong fixity
22:42:47 <rwbarton> okay now you have an orphan instance Applicative Q warning, and 7.2 doesn't have (<>)
22:43:03 <rwbarton> first is in Control.Lens.TH, second in Data.Data.Lens
22:43:08 <edwardk> hrmm, where do i use (<>)? ah
22:43:17 <edwardk> the orphan instance you're stuck with
22:43:20 <rwbarton> ok
22:43:25 <edwardk> i can fix the (<>)
22:43:37 <edwardk> and i need to fix the associativity of the infixE expression i built
22:43:39 <rwbarton> there are two
22:43:41 <rwbarton> right
22:44:18 <pharaun> just how old is 7.2 anyway
22:44:45 <edwardk> its a year and a half or so, its a couple platforms ago =)
22:44:57 <rwbarton> about a year
22:45:00 <edwardk> and it was never officially folded into a platform
22:49:35 <edwardk> hrmm, this'll take a couple minutes, reassociating it is tricky
22:50:30 <rwbarton> well you don't have to do this on my behalf. i can just upgrade
22:50:39 <rwbarton> but if you want to, I am happy to keep testing
22:51:26 <edwardk> i might as well get it to work
22:51:40 <edwardk> if it turns out to be too bad, then i can put a floor under the versioning at 7.4
22:51:52 <edwardk> but the main thing i want is that whatever the package claims to support it should actually support
22:52:07 <rwbarton> yeah
22:52:14 <edwardk> so either way i want it to build clean or fail clean on 7.2 ;)
22:55:51 <edwardk> ok. i think i've got it. pushing
22:56:25 <edwardk> pushed. try now
22:57:38 <rwbarton> success!
22:57:55 <edwardk> k. going to ship this to hackage, but it'll unfortunately be a major version bump =/
22:58:33 <pharaun> edwardk: 3.* ?
22:58:42 <edwardk> 2.8
22:58:52 <edwardk> x.y.z, x and y are major versions
23:04:32 <pharaun> ah k
23:08:06 <Cale> edwardk: make it 3.0 and then with every subsequent release, no matter how small, bump the largest version number, rendering the other two unused, like Firefox.
23:08:14 <edwardk> =)
23:08:54 <shachaf> Make it 3.0 and then never change the major version number again.
23:08:56 <shachaf> Like Linux.
23:09:10 <edwardk> i want to shrink the required export list for the user for 3.0, so they can export just HasFoo(..) and hopefully have embedding projection pairs and a few other things before i go 3.0 =)
23:09:15 <shachaf> (You could've done the 2.6.x-3.0 swtich!)
23:09:24 <edwardk> shachaf: heh
23:12:37 <edwardk> rwbarton: http://hdiff.luite.com/cgit/lens/commit?id=2.8 summarizes the changes
23:18:44 <DireWombat> hi, I have a version of "lines" that allows escaping the newlines with a backslash (and the backslash with a backslash),
23:18:50 <DireWombat> and I'd like to write it without explicit recursion but in a way that preserves laziness so that I can apply it to large files
23:19:17 <scshunt> ... why?
23:19:39 <DireWombat> so I want to parse large (GB sized) text files
23:20:08 <scshunt> why no recursion though?
23:20:09 <DireWombat> I want the laziness so I don't have to hold it in memory
23:20:26 <startling> is there a standard library with a Ring typeclass?
23:20:38 <DireWombat> I want the lack of explicit recursion because it's good style, and hopefully I can use the Data.Text higher order functions
23:20:46 * hackagebot lens 2.8 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-2.8 (EdwardKmett)
23:20:55 <startling> DireWombat, doesn't Data.Text have a fold or too?
23:20:58 <startling> *two
23:20:58 <scshunt> DireWombat: why is lack of recursion good style?
23:21:30 <startling> DireWombat: the reason lack of recursion is good style is because it can usually be written better with a fold
23:21:33 <DireWombat> Data.Text has folds, but the left fold isn't lazy
23:21:44 <DireWombat> and the right fold doesn't allow me to pass the escape status right
23:22:02 <startling> DireWombat, "pass in escape status right"?
23:22:24 <DireWombat> "whether the next character has been escaped" goes from left to right
23:22:39 <startling> DireWombat: so does foldr
23:23:11 <startling> @src foldr
23:23:11 <lambdabot> foldr f z []     = z
23:23:11 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:23:22 <startling> compare:
23:23:25 <startling> @src foldl
23:23:25 <lambdabot> foldl f z []     = z
23:23:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:24:05 <startling> > foldr (:) [1, 2, 3]
23:24:06 <DireWombat> I don't think you can pass "state" from a leftwards call to f to a rightwards call to f
23:24:06 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
23:24:06 <lambdabot>    arising from a use ...
23:24:26 <startling> DireWombat, they're all rightwards ??
23:24:37 <scshunt> > foldr (:) [] [1, 2, 3]
23:24:38 <lambdabot>   [1,2,3]
23:24:45 <startling> scshunt: oh right, heh
23:24:46 <DireWombat> when you call foldr, the function can't pass state right
23:25:03 <DireWombat> because the rightwards evaluations have already occured
23:25:14 <startling> DireWombat: you have them backwards, I think
23:25:14 <Cale> wat
23:25:24 <startling> DireWombat: foldr starts at the left and goes right
23:25:39 <scshunt> he's right even if he has the details wrong
23:25:42 <DireWombat> x1+(x2+(x3+k))
23:25:44 <Cale> foldr f z (x:xs) immediately calls f and it passes it x and (foldr f z xs)
23:25:53 <scshunt> DireWombat: this just means you have to get creative
23:26:01 <dobblego> foldr f z x replaces every (:) with f and [] with z in x
23:26:02 <Cale> and only if f decides to look at its second parameter will it continue the foldr
23:26:20 <Cale> > foldr (\x y -> x) 0 [1..]
23:26:22 <lambdabot>   1
23:26:28 <DireWombat> yup
23:26:53 <startling> oh, I think I see what he means
23:26:57 <DireWombat> I'll hpaste an example
23:27:02 <hpaste> DireWombat pasted “Example” at http://hpaste.org/74466
23:27:08 <startling> DireWombat: yes, you just have to get creative
23:27:26 <rwbarton> it would be better style not to get creative
23:27:48 <DireWombat> the first thing is what I do, but it uses explicit recursion, so I have to convert the Data.Text into Char strings and can't use the Data.Text combinators
23:28:01 <rwbarton> well, perhaps there is a particularly clever way to do it but i find it hard to imagine
23:28:08 <copumpkin> oh shit, a dire wombat
23:28:12 <copumpkin> this does not bode well
23:28:17 <DireWombat> I'm a close relative to the Drop Bear
23:28:23 <Jafet> You can use Text.uncons.
23:28:27 * copumpkin runs for the hills
23:28:39 * startling connects with ssh.
23:28:40 <Jafet> However, its performance is pretty horrible from what I remember
23:28:45 <DireWombat> hmm
23:31:01 <Cale> Is this thing the same as lines . filter (/= '\\') ?
23:31:03 <rwbarton> can't you simplify example_ by matching on '\\':x:xs, '\n':xs, x:xs
23:31:16 <rwbarton> get rid of the Bool parameter
23:31:26 <Cale> What is the intention of this code?
23:31:37 <DireWombat> Cale, it's intended to function like lines
23:31:48 <DireWombat> except that a backslash before a newline escapes the newline
23:32:02 <DireWombat> (and a backslash before a backslash escapes the backslash)
23:32:06 <Cale> I see
23:32:27 <Cale> hmm
23:32:29 <DireWombat> rwbarton - yes, that's better but it's just an example
23:33:01 <DireWombat> I bumped into multi-gigabyte files at work so I whipped out haskell :)
23:33:34 <rwbarton> well that is one of the advantages of explicit recursion, you can do fancier pattern matching
23:33:39 <DireWombat> I had just claimed to a coworker that you should avoid explicit recursion, so I'm trying to get rid of it here :)
23:34:12 <rwbarton> @type foldr
23:34:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:34:17 <Cale> I think you can still use span
23:34:19 <Cale> recursively
23:34:25 <rwbarton> you can move the "Bool -> " into b i think
23:34:25 <DireWombat> rwbarton - yep, but if I could write this in terms of common combinators, I could switch from Char strings to Data.Text
23:34:30 <Cale> There's an efficient span for Data.Text
23:34:49 <DireWombat> @type span
23:34:50 <rwbarton> and "pass state to the right" that way
23:34:50 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:35:20 <Jafet> Lovely span, wonderful span
23:35:22 <Cale> It produces the longest prefix of the list which satisfies the predicate, and then the rest.
23:35:24 <Jafet> span is underrated
23:35:29 <rwbarton> but yeah, span is likely to be a lot more efficient unless your file is mostly backslashes and newlines :)
23:35:42 <Jafet> It will probably be as efficient even then
23:36:03 <DireWombat> haven't seen span before!
23:36:16 <rwbarton> @src lines
23:36:16 <lambdabot> Source not found. It can only be attributed to human error.
23:36:21 <startling> @src span
23:36:21 <lambdabot> span _ xs@[]                     =  (xs, xs)
23:36:21 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
23:36:21 <lambdabot>                   | otherwise    =  ([],xs)
23:36:35 <startling> > span (> 2) [1, 2, 3, 4]
23:36:36 <lambdabot>   ([],[1,2,3,4])
23:36:57 <Cale> > span (<3) [1,2,3,4]
23:36:58 <lambdabot>   ([1,2],[3,4])
23:37:10 <Cale> > span (/= 3) [1,2,3,4]
23:37:11 <lambdabot>   ([1,2],[3,4])
23:37:25 <startling> oh, it splits after it gets a False?
23:37:30 <DireWombat> I guess I'd use span within an unfold or something
23:37:35 <DireWombat> I'll give it a try right now
23:37:57 <Cale> > span (/= '\\') "There's backslashes in them thar hi\\s.
23:37:58 <lambdabot>   <no location info>:
23:37:58 <lambdabot>      lexical error in string/character literal at end o...
23:38:01 <Cale> > span (/= '\\') "There's backslashes in them thar hi\\s."
23:38:02 <lambdabot>   ("There's backslashes in them thar hi","\\s.")
23:38:43 <rwbarton> you could also potentially use the regular lines and then paste lines that end in \ back together
23:39:09 <rwbarton> afterwards, remove \s
23:39:11 <DireWombat> the actual problem is parsing tabular data separated by tabs and newlines
23:39:13 <Jafet> By the way, dropWhile p is one stroke more than snd.span p.
23:39:25 <DireWombat> with lots of within-cell escaped tabs and newlines
23:40:14 <bos> DireWombat: you want to replace "\n" with "\\\n" ?
23:40:24 <DireWombat> bos - the other way round
23:40:51 <Cale> bos: He wants a function like 'lines' but where newlines can be escaped by preceding backslashes
23:40:55 <Jafet> bos: (Text.pack "\\\n")
23:41:28 <Jafet> Oh, nevermind
23:41:34 <Cale> (and backslashes can be escaped by preceding backslashes too)
23:41:59 <tylerkahn> can someone help me understand what this means? http://imgur.com/wqWUT from my reading he's saying that a concrete category is one where the objects are sets and the arrows are morphisms (homomorphisms?) between the sets
23:42:38 <tylerkahn> i'm getting this from http://www.haskell.org/haskellwiki/User:Michiexile/MATH198/Lecture_1
23:42:56 <Cale> tylerkahn: Yes.
23:42:58 <Jafet> Category theory on imgur?
23:43:05 <tylerkahn> Jafet: screenshot heh
23:43:11 <Cale> tylerkahn: That guy's writing style though...
23:43:24 <tylerkahn> i know that's a particularly weirdly written blurb
23:43:25 <Cale> Holy shit that first sentence is annoying to parse :)
23:43:27 <tylerkahn> the rest isn't like that
23:43:29 <tylerkahn> lol
23:43:47 <ddarius> @google "Abstract and Concrete Categories"
23:43:49 <lambdabot> http://katmat.math.uni-bremen.de/acc/acc.pdf
23:44:31 * ddarius thinks he should provide a stopping condition for this imperative matrix algorithm loop.
23:44:43 <bos> DireWombat:  oh, so you've got that nasty problem of context sensitivity. yuck.
23:45:15 <DireWombat> bos - yeah, but I want to solve it in haskell :D
23:45:20 <tylerkahn> Cale am i missing anything though, the wiki page on concrete categories talks about faithful functors and stuff. does the explanation i gave mean the same thing?
23:45:22 <DireWombat> real world problem and all that
23:45:46 <Jafet> For simple parsing like this, span works well on most inputs
23:46:34 <DireWombat> Jafet - yeah, just trying to work out how to insert the context sensitivity
23:46:40 <Cale> tylerkahn: The thing is, as category theorists, this definition of a concrete category where we say that the objects are sets and the arrows are functions is extremely unsatisfying to us, because category theory is not meant to talk about what the objects and arrows *are*.
23:47:26 <bos> if these backslashes are common, you'll get nastyish performance
23:47:32 <Jafet> You're only interested in '\n' and '\\', so span on either and then do something based on what you got
23:47:57 <DireWombat> Jafet - yep, trying to wrap that up in a list combinator
23:48:05 <scshunt> 'concrete category' is a hack
23:49:37 <Cale> tylerkahn: So in order to make the definition a bit more morally sound, instead of talking about what the objects and arrows *are*, we'd rather say that a concrete category is a category together with a mapping which assigns sets and functions to those objects and arrows in a particular way.
23:49:53 <tylerkahn> Cale: ah i think i do get that. kind of funny at first glance to talk about categories (something supposed to be very general) in terms of their Set of objects
23:50:27 <tylerkahn> thank you for the explanation!
23:50:37 <Cale> tylerkahn: well, it's okay to talk about the set of objects, it's not okay to look inside those objects and say that those are sets
23:51:21 <tylerkahn> ah ok. clearer now. right the underlying nature of the objects shouldn't matter to us
23:51:27 <Cale> yeah
23:53:25 <Cale> tylerkahn: Something which might not be obvious is that every (small) category can be turned into a concrete category in some fashion as well.
23:54:19 <tylerkahn> heh i only learned what a proper class was a few hours ago. still processing that
23:54:22 <mikeplus64> with the ffi, i can do foreign import ccall "math.h sin" sin :: Double -> Double, which will work fine, but i expected the type to have to be CDouble -> CDouble - what other types can be automatically coerced like this?
23:54:47 <Cale> tylerkahn: small categories are the ones with merely a set of objects and where the arrows between any two objects are a set
23:55:00 <Cale> So you don't have to worry so much about proper classes :)
23:55:06 <Cale> (in this case)
23:55:51 <tylerkahn> haha k. this is great! thanks for your help. really awesome that i can ask questions about this stuff and get feedback
23:56:30 <scshunt> mikeplus64: CDouble is actually a newtype of Double
23:56:56 <scshunt> I don't know why the coecion works; possibly a bug?
23:56:57 <mikeplus64> that's surprising - i thought it would be the other way around
23:57:06 <Cale> What we do is to take our (small) category C, and define a category which for each object X in C, we have an object [X] = { f: T -> X, T in C }, i.e. our replacement for the object X in C is a *set* of arrows into X from everywhere in the category.
23:57:50 <Jafet> mikeplus: ghc doesn't do C type checking
23:58:14 <Cale> and then if a: X -> Y is an arrow in C, we send that to the function [X] -> [Y] which sends each f: T -> X in [X] to  a . f: T -> Y in [Y]
23:58:22 <Jafet> Try foreign import sin :: Int -> Int
23:58:35 <mikeplus64> Jafet: yeah, but it still surprises me that it works (not just at compile time)
23:59:02 <Cale> tylerkahn: this faithfully represents all the behaviour of our category C as a category whose objects are sets and whose arrows are functions.
23:59:05 <mikeplus64> Jafet: with foreign import ccall "math.h sin" sin :: Int -> Int
23:59:08 <mikeplus64> i just get 0
23:59:10 <mikeplus64> always
23:59:13 <Jafet> Well, it's rather unusual if your ghc uses a different representation of Double and CDouble
23:59:20 <tylerkahn> Cale: processing what you wrote atm
23:59:21 <Jafet> I get garbage values
23:59:23 <tylerkahn> Cale haha
23:59:27 <Cale> tylerkahn: So being a concrete category vs just being a small category is "nothing special"
23:59:29 <mikeplus64> Jafet: what ghc do you use?
23:59:45 <Jafet> 7.4 on amd64
23:59:48 <mikeplus64> (i use arch linux's (should be vanilla) ghc 7.4.2
23:59:50 <mikeplus64> )
23:59:59 <Jafet> This one goes through cygwin
