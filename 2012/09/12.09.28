00:18:30 <ehamberg> AfC: http://www.reddit.com/r/haskell/comments/102t49/hiw_2012_simon_peyton_jones_ghc_status_update/c6a12lj ;)
00:29:10 <johnw> is there a way to tell Cabal to never build a particular executable (in this case, my doctests runner) with profiling, even when --enable-executable-profiling has been given?
00:29:54 <startling> what's wrong with "mappendTo ls b = ls <>~ view ls b" using `lens`?
00:30:07 <Rc43> Hi, guys.
00:30:11 <Rc43> What is UUAG?
00:30:17 <startling> I get "Couldn't match expected type `Accessor c0 d0' with actual type `Mutator c0'", but can't a lens be both an Accessor and a Mutator?
00:30:31 <Rc43> I can't google it. (Can find uuag.com, but can't open it somehow.)
00:30:38 <johnw> startling: doesn't view apply a lens?
00:30:47 <Rc43> It is related to haskell (have seen about it in a blog.)
00:30:51 <johnw> ls <>~ (view ls b) ?
00:31:02 <johnw> no, that shouldn't be needed...
00:31:23 <startling> johnw: same thing
00:31:25 <frerich> Rc43: I googled for 'UUAC Haskell' and found http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter#Running_the_UUAG which explains "I'll introduce attribute grammars using the syntax of the Utrecht University Attribute Grammar system or UUAG "
00:32:30 <Rc43> frerich, oh, I ignored this link first time
00:33:51 <johnw> yay, +RTS -xc told me exactly what my problem was!
00:34:30 <startling> johnw, huh, works with Rank2Types and a type signature
00:34:39 <johnw> well, that's interesting
00:34:43 <johnw> what does <>~ do?
00:34:53 <startling> what about "mappendOn :: Monoid b => Simple Lens a b -> a -> a -> a" needs Rank2Types?
00:34:54 <johnw> mappends the lens target with x?
00:35:05 <johnw> i don't even grok Rank2Types yet
00:35:19 <startling> johnw: _1 <>~ "!" $ ("hello", 2) -- ("hello!", 2)
00:35:26 <johnw> ah, ok
00:35:44 <dmwit> startling: At a guess: expand Simple and you'll know.
00:35:48 <startling> johnw, neither do I. :)
00:36:30 <startling> dmwit, "mappendOn :: Monoid b => Lens a a b b -> a -> a -> a"
00:37:04 <startling> gets me "Illegal polymorphic or qualified type: Lens a a b b"
00:41:15 <startling> ghci's telling me I need another extension (-XImpredicativeTypes) for "mappendLenses a b = foldr (flip mappendOn b) a"
00:41:17 <startling> weird, man
00:41:30 <frerich> Is there a way to trace the execution of a Parsec parser? Sometimes I don't decide on a grammar up-front but just rush ahead and write a parser, only to then find that they don't combine as I intended (too many newlines eaten or something). It would be nice to have a trace of how the input is consumed.
00:44:05 <startling> I just want a way to derive Monoid for data types where each field has a lens. :(
00:53:48 * hackagebot stringable 0.1.1 - A Stringable type class, in the spirit of Foldable and Traversable  http://hackage.haskell.org/package/stringable-0.1.1 (JohnWiegley)
01:03:02 <mcstar> whats the preferred reactive library these days?
01:03:24 <mrcarrot> Can anyone tell in what format passwd.rc should be in (lambdabot)
01:03:55 <mrcarrot> I would want it to use nickserv.
01:22:15 <cark> on ghc 7.4.1 the pragma {-# PolyKinds #-} is not recognized ?
01:23:21 <mmaruseacph2> isn't it {-# LANGUAGE PolyKinds #-} ?
01:23:34 <cark> ah stupid me
01:23:37 <cark> thanks =)
01:23:48 <mmaruseacph2> no prob
01:38:49 * hackagebot gluturtle 0.0.1 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.1 (YoshikuniJujo)
01:43:50 * hackagebot gluturtle 0.0.2 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.2 (YoshikuniJujo)
01:57:57 <Rc43> Is there thing like "case" from Data.Typeable, but for type classes?
01:58:03 <Rc43> *like "cast"
01:58:56 <startling> Rc43, what would that do?
01:59:47 <lrvick> join #css
01:59:50 <lrvick> woops
02:01:22 <Jafet> @wn cascade
02:01:23 <lambdabot> *** "cascade" wn "WordNet (r) 3.0 (2006)"
02:01:23 <lambdabot> cascade
02:01:24 <lambdabot>     n 1: a small waterfall or series of small waterfalls
02:01:24 <lambdabot>     2: a succession of stages or operations or processes or units;
02:01:24 <lambdabot>        "progressing in severity as though a cascade of genetic
02:01:25 <lambdabot> [9 @more lines]
02:01:50 <Rc43> startling, I talked about something like "cast x :: (Maybe ShowRep)", but I got now that `cast x` without explicit type annotation works like I want
02:02:02 <Rc43> startling, so, no problem now
02:02:03 <Jafet> @jargon cascade
02:02:04 <lambdabot> *** "cascade" jargon "The Jargon File (version 4.4.7, 29 Dec 2003)"
02:02:04 <lambdabot> cascade
02:02:04 <lambdabot>  n.
02:02:04 <lambdabot>  
02:02:04 <lambdabot>     1. A huge volume of spurious error-message output produced by a compiler
02:02:06 <lambdabot> [9 @more lines]
02:02:20 <startling> Rc43: ah, understood
02:02:23 <startling> @jargon style
02:02:24 <lambdabot> No match for "style".
02:02:26 <Jafet> It's actually a strange name to have.
02:03:08 <Jafet> "Cascade" normally has poor connotations
02:03:50 * hackagebot aws-sdk 0.1.1.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.1.1.0 (YusukeNomura)
02:04:19 <startling> Jafet: "cascading" implies layers, though
02:04:22 <startling> @wn cascading
02:04:23 <lambdabot> No match for "cascading".
02:05:15 <bitonic> criterion is so great
02:05:29 <Jafet> Perhaps they wanted the name to evoke a cutesy zen garden waterfall
02:06:31 <mcstar> @jargon jargon
02:06:31 <lambdabot> No match for "jargon".
02:06:36 <startling> Jafet: http://www.csszengarden.com/
02:06:38 <sopvop> god, I hate exceptions. just wrapped bunch of IO exception trowing funcs into  catch -> Either, and life has become so much easier.
02:06:39 <mcstar> there is no match for jargon
02:06:58 <startling> sopvop: ikr
02:07:07 <Jafet> Yes, I know about the cutesy zen garden.
02:07:10 <sopvop> lkr?
02:07:18 <startling> "i know, right?"
02:07:26 <mcstar> i kan relate
02:07:27 <startling> sucks that readFile isn't IO (Maybe x)
02:07:38 <bitonic> css zen garden was great.
02:07:48 <bitonic> I mean it still exists but it's dead now
02:08:03 <startling> this one is cool! http://www.csszengarden.com/?cssfile=/213/213.css&page=0
02:08:22 <Jafet> sopvop: in other words, you rewrote try?
02:08:25 <Jafet> :t try
02:08:27 <lambdabot> Not in scope: `try'
02:08:32 <Jafet> :t Control.Exception.try
02:08:33 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
02:08:55 <sopvop> sort of
02:09:04 <GnomeStoleMyBike> Hi All
02:09:12 <sopvop> On the other hand, (/) :: Fractional a => a -> a -> Either DivisionByZero a would be horrible
02:09:13 <bitonic> is there a package with random-related functions, e.g. "shuffle list"?
02:09:33 <Jafet> @hackage random-shuffle
02:09:33 <lambdabot> http://hackage.haskell.org/package/random-shuffle
02:09:49 <startling> sopvop, "Maybe a" would be great though
02:09:55 <bitonic> Jafet: thanks
02:09:59 <bitonic> oleg!
02:10:10 <Jafet> sopvop: some languages make you write that
02:10:22 <Jafet> Not sure if agda's one of them
02:10:31 <startling> guarding against division-by-zero feels like the canonical use-case for Maybe. :(
02:10:50 <sopvop> I thought agda is not posing itself as 'general purpose' language anyway
02:11:02 <Jafet> spoon does exactly this, startling
02:11:04 <Jafet> @hackage spoon
02:11:04 <lambdabot> http://hackage.haskell.org/package/spoon
02:11:15 <ion> spoon is evil
02:11:16 <zomg> There is no spoon was a lie?
02:11:37 <Jafet> ion: what would you have then, teaspoon??
02:12:16 <startling> Jafet: interesting but I'm mostly whining how haskell itself doesn't do this
02:12:34 <Jafet> (/) isn't haskell, it's part of the library
02:12:45 <frerich> startling: Maybe it would be nicer to change the signature so that you can't pass a zero in the first place (in which case you have to catch this condition on the caller side)
02:12:49 <Jafet> You're free to make your own prelude
02:12:51 <startling> sorry, s/haskell/the prelude
02:13:02 <startling> frerich, yay dependent typing
02:13:05 <dcoutts_> johnw: can you explain why you'd want to always turn off profiling for one executable?
02:13:10 * sopvop secretly s/catch/try/ . Should learn base better.
02:13:38 <merijn> sopvop: L2H (Learn to Hoogle) ;)
02:13:43 <startling> Jafet: yes, but
02:13:51 <sopvop> merijn: true dat
02:14:43 <merijn> Haskell's ZeroMQ bindings look decent, but man I need to StateT-ify this stuff instead of the annoying explicit context passing using lambda's...
02:14:51 <Philonous_> Jafet:  Just because a compiler opts to implement something in the form of a library doesn't mean it's not part of haskell
02:17:03 <Jafet> It's not in the "language" section
02:17:15 <Jafet> (Nitpick: neither is a "compiler")
02:17:34 <Philonous_> Sure, part 6 "predefined types and classes"
02:17:38 <Jafet> Oh wait, prelude is in "language" section
02:17:44 <sopvop> > isInfinite $ 1/0+123 of In -- (/) is not that bad
02:17:45 <lambdabot>   <no location info>: parse error on input `of'
02:17:55 <sopvop> oh
02:18:03 <sopvop> > isInfinite $ 1/0+123 -- (/) is not that bad
02:18:04 <lambdabot>   True
02:18:17 <Jafet> > 0%0/0
02:18:18 <lambdabot>   *Exception: Ratio.%: zero denominator
02:18:58 <Rc43> Hmm, somehow `let f x = case cast x of Just a -> show a ; Nothing -> "<no rep>"` works fine in ghci, but gives error while compiling. Error is about ambigous type variable (Show a or Typeable a).
02:19:17 <Rc43> Signature of f is `Typeable a => a -> String`.
02:19:23 <Botje> Rc43: yes, GHCi has more aggressive defaulting.
02:19:34 <sopvop> why 0%0/0 - is not a NaN?
02:19:41 <Rc43> Botje, what is defaulting?
02:19:51 <Rc43> Botje, can I get same behaviour?
02:19:58 <Botje> add an explicit type annotation
02:20:01 <Jafet> So after all the trouble to add asynchronous exceptions to haskell, people don't want them.
02:20:14 <Rc43> Botje, even with it doesn't work.
02:20:38 <Botje> Rc43: can you show code?
02:20:40 <Jafet> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
02:20:45 <sopvop> jafet: IMO They have their use, but libraries should try to avoid relying on them so much.
02:21:11 <Jafet> If you have something strange going on, you may need extra type annotations
02:21:32 <Jafet> @type 0%0
02:21:33 <lambdabot> forall t. (Integral t) => Ratio t
02:21:56 <sopvop> numbers in haskell are not just floats and ints :)
02:21:57 <Jafet> Actually, that incorrect division example is wrong.
02:22:08 <Jafet> > 0%1 / 0
02:22:09 <lambdabot>   *Exception: Ratio.%: zero denominator
02:24:04 <hpaste> Rc43 pasted ‚ÄúTypeable and Show problem‚Äù at http://hpaste.org/75431
02:24:18 <Rc43> Botje, http://hpaste.org/75431
02:24:54 <startling> man, why is there no easy way to derive Monoid?
02:25:00 <Botje> Rc43: isn't the a in your code completely unrelated from the a in your type?
02:25:01 <Botje> :t cast
02:25:02 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
02:26:20 <sopvop> startling: how is it supposed to work?
02:26:47 <Jafet> data Integer ... deriving Monoid
02:26:49 <startling> sopvop: I'd like to be able to do it for "data Lists a b = Lists [a] [b]", at least
02:26:51 <Rc43> Botje, what you mean by "related"? a in type doesnt' have to be Show, but can.
02:26:56 <startling> Jafet: :)
02:27:07 <Rc43> Botje, and in GHCi this code works
02:27:26 <sopvop> startling: monoid for that is just 3 lines of code anyway.
02:27:32 <Rc43> Botje, oh, I see
02:28:17 <Jafet> mappend for (m a, m b) is both (++)
02:28:43 <Jafet> Except Lists isn't actually a pair, and for some reason (both) isn't in the standard library
02:28:48 <Rc43> Botje, but how to fix it?
02:28:49 <startling> sopvop, but I've got a bunch of fields
02:29:31 <sopvop> well that can work if all fields are monoids. Who wants to write -XDeriveMonoid for next ghc release?
02:29:53 <Jafet> That is only one possible monoid instance.
02:30:01 <sopvop> ok
02:30:08 <sopvop> -XDeriveOnePossibleMonoid
02:30:21 <startling> Jafet, deriving Show only derives one possible Show instance
02:30:25 <startling> same with Ord and Eq
02:30:30 <ew0> ok, I just wrote some code with a monad inside a monad
02:30:41 <ew0> I guess I really unterstood how they work now
02:30:44 <startling> ew0: yay
02:31:00 <sopvop> ew0: don't forget write a monad tutorial now :)
02:31:02 <ew0> it is a State monad with a LP monad
02:31:05 <Jafet> You often want a different Monoid instance, but not a different Show instance.
02:31:16 <Jafet> @instances Monoid
02:31:16 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:31:19 <startling> Jafet, then you wouldn't derive Monoid
02:31:19 <Botje> Rc43: no idea
02:31:32 <ew0> ow, don't worry. I'm so excited I'll be preaching haskell gospel to my friends for a year
02:31:40 <Jafet> Uhh, okay, you can talk to the trac.
02:31:49 <sopvop> whoa, (a -> b) is a monoid?
02:31:54 <ew0> 7 am here
02:31:55 <startling> ew0, time to learn monad transformers!
02:31:55 <ew0> gn
02:31:58 <startling> sopvop: caleskell
02:31:59 <Jafet> If b is a monoid, yes.
02:32:01 <ew0> ow yeah!
02:32:10 <ew0> I think I actually did one
02:32:16 <ew0> a half ass one
02:32:18 <Jafet> The same reason that (a ->) is a functor
02:33:00 <Jafet> Actually, (a, b) is a monoid...
02:33:03 <ew0> with a return (sequence_ $ mapM someMonadicOps)
02:33:05 <maukd> startling: caleskell?
02:33:14 <Jafet> > ("fgs", [1]) ++ ("fds", [2])
02:33:16 <lambdabot>   ("fgsfds",[1,2])
02:33:24 <Jafet> So that's your Lists instance already written.
02:33:52 <startling> maukd: isn't it?
02:34:46 <Jafet> I'd check in ghci, but my ghci is also caleskell
02:35:13 <sopvop> I don't get that caleskell thing
02:35:45 <zomg> Caleskell? Did Cale make a fork of Haskell? =)
02:35:57 <startling> oh, I guess it's in Data.Monoid.
02:36:00 <merijn> zomg: No, it refers to some redefinitions in lambdabot
02:36:11 <zomg> Oh right, thought it sounded familiar
02:36:23 <merijn> zomg: Such as (.) == fmap, (++) == mappend, etc
02:36:31 <startling> zomg: yes, it refers to some redefinitions in lambdabot
02:37:21 <sopvop> @source lambdabot
02:37:21 <lambdabot> lambdabot not available
02:37:39 <sopvop> @hackage lambdabot
02:37:39 <lambdabot> http://hackage.haskell.org/package/lambdabot
02:38:12 <Lamen> sopvop: http://code.haskell.org/lambdabot/
02:38:24 <sopvop> Whoa, lambdabot has extensively documented modules :(
02:38:46 <Jafet> caleskell doesn't define any new instances, I think
02:38:53 <sopvop> Lamen: Thanks
02:38:59 <Jafet> Except maybe Show (a -> b), unless that's from quickcheck
02:39:32 <Lamen> sopvop: You're welcome :)
02:40:02 <sopvop> Monoid (a -> b) is from base
02:40:55 <startling> Jafet: Num d => Num (a -> d)
02:41:02 <sopvop> But I don't get what it does
02:41:14 <startling> sopvop:
02:41:24 <maukd> startling: that's a normal module
02:41:28 <maukd> NumInstances IIRC
02:41:39 <startling> > (const [] `mappend` const [1, 2, 3]) "whatever"
02:41:40 <lambdabot>   [1,2,3]
02:41:53 <merijn> hmmm, I guess there's no way to autolift IO into a MonadIO instance?
02:42:13 <sopvop> startling: kind of useless
02:42:32 <startling> > (const ['a'] `mappend` id) "!"
02:42:33 <lambdabot>   "a!"
02:42:59 <startling> maukd: o rly. color me surprised
02:43:20 <Jafet> That is another instance, and it's from the vector-space library to satisfy the function Num instance which is a technicality to satisfy some other thing
02:43:21 <maukd> > sortBy (comparing length `mappend` compare) (words "das salz verzehrt den leib des mohren")
02:43:22 <lambdabot>   ["das","den","des","leib","salz","mohren","verzehrt"]
02:43:51 <Jafet> Incidentally, the reason lambdabot can't print functions is because those instances overlap
02:44:24 <Ralith> :t compare
02:44:25 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
02:45:01 <sopvop> that looks useful. next haskell book should be about such 'patterns'
02:46:52 <startling> > fold [return take <*> fib] "hello, world!" where fib@(_:fs) = 0 : 1 : zipWith (+) fib fs
02:46:53 <lambdabot>   <no location info>: parse error on input `where'
02:47:25 <startling> > let fib@(_:fs) = 0 : 1 : zipWith (+) fib fs in fold [return take <*> fib] "hello, world!"
02:47:26 <lambdabot>   Not in scope: `fold'
02:48:02 <startling> > let fib@(_:fs) = 0 : 1 : zipWith (+) fib fs in Data.Foldable.fold [return take <*> fib] "hello world"
02:48:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
02:48:03 <lambdabot>         against inferr...
02:48:06 <startling> man
02:48:11 <Jafet> > map (`take` "hello, world!") $ fix ((0:) . scanl (+) 1)
02:48:13 <lambdabot>   ["","h","h","he","hel","hello","hello, w","hello, world!","hello, world!","...
02:48:28 <startling> Jafet: :)
02:49:03 <bitonic> is there a way to have a criterion benchmark with a "preparation" step, that we need for the test but shouldn't be taken into account towards the time?
02:49:18 <startling> Jafet: I wanted to show a use for Monoid b => Monid (a -> b), though.
02:49:25 <Jafet> The usual method is to `evaluate' this preparation.
02:49:33 <sopvop> this contest in clever oneliners makes me feel stupid. I'll go code something useful instead.
02:49:43 <bitonic> Jafet: how does that help?
02:49:44 <Jafet> do evaluate (nf prep); criterionMain ...
02:50:01 <bitonic> no, I want to redo the preparation at each sample
02:50:12 <resure> How can I quickly explain why other programmers must learn functional languages like Haskell?
02:50:38 <Jafet> I don't know. You could sample the preparation separately and subtract it
02:50:49 <zomg> resure: because they will become better programmers for doing so =)
02:50:51 <bitonic> evaluating before doesn't matter that much since the first sample will force it and will be taken out
02:51:03 <sopvop> resure: the only quick way is the kick in the face. They can't argue that!
02:51:04 <bitonic> Jafet: yeah, that was my plan B
02:51:05 <startling> resure: let myMap = fromList [(1, "k")] in lookup 2 >>= (,) lookup 3
02:51:26 <startling> resure: or Just Nothing
02:51:33 <startling> Maybe is really powerful, though
02:51:51 <bitonic> resure: why would programmers *have* to learn FP?
02:52:01 <bitonic> you can't convince them of something untrue
02:52:14 <ion> People convince people of something untrue all the time.
02:52:15 <Jafet> bitonic: why not?
02:52:22 <resure> bitonic: to become better programmers of course )
02:52:44 <bitonic> because most day job programmers will be fine without.  they definitely don't *need* FP.
02:52:47 <sopvop> Maybe got me hooked on haskell. Also - i got monads from Maybe monad instance explanation.
02:53:21 <resure> sopvop: monads are hard for beginners
02:53:50 <bitonic> I think "you should learn FP because..." is a better approach then "you must learn FP" ehe
02:53:51 <startling> resure: not true!
02:53:57 <Jafet> Guido doesn't need lambda, why should you?
02:54:00 <resure> startling: why?
02:54:16 <resure> bitonic: yes, you are right
02:54:17 <companion_cube> Jafet: guido doesn't need types either ;)
02:54:17 <startling> resure: Just 12 >> Nothing >> Just 13 is simple
02:54:55 <sopvop> resure: Once you understand compostion of regular functions, currying and a bit about typeclasses - it is easy. Trying to understand monads before that is hard sure.
02:54:59 <Jafet> @quote syntaxfree polymorphism
02:54:59 <lambdabot> syntaxfree says: it isn't polymorphism per se, but walks like polymorphism and quacks like polymorphism.
02:55:00 <bitonic> resure: I think the best thing about Haskell is that you learn a lot of abstract concepts while having fun
02:55:09 <bitonic> and great community
02:55:23 <resure> Another question that some programmers ask me: why not clojure?
02:55:37 <RawProduce> or OCaml
02:55:53 <bitonic> resure: there is no good answer to that, I'm sure clojure is fun as well
02:55:53 <startling> resure: 1) types, 2) takes a few minutes to get a repl running
02:55:55 <Jafet> Why did you tell them "not clojure"?
02:56:16 <sopvop> My new puthon code has map (lambda x: garbled(x), ..) everywhere. The next guy is gonna hate me.
02:56:35 <startling> sopvop, listcomps yo
02:56:56 <Jafet> sopvop: that is counterproductive
02:57:02 <resure> Final question: what is the best place to start with Haskell for Ruby programmer?
02:57:08 <startling> resure, LYAH
02:57:25 <resure> startling: and after that?
02:57:39 <startling> resure, typeclassopedia
02:57:46 <startling> resure: LYAH is long, though
02:57:47 <Jafet> A Rails user will find Real World Haskell familiar.
02:57:59 <solirc> resure: LYAH is the recommended introduction now, but many people I know got started with YAHT
02:58:24 * sopvop started with RWH
02:58:29 <solirc> resure: == Yet an other Haskell tutorial
02:59:24 <mmaruseacph2> lyah is the easiest of them
02:59:44 <sopvop> The really scary thing for haskell beginner trying to understand someone else code is the operators.
02:59:53 <resure> solirc:  startling bitonic sopvop thanks
02:59:57 <startling> sopvop: heh
03:00:36 <sopvop> I still remember that: Oh, so it's just a function written inline!!! and then got hit with fixity.
03:01:00 <Jafet> Really? We don't even have things like eskimo operator.
03:01:33 <Rc43> Must `deriving instance SomeClass (T a)` work only with some enabled extension?
03:01:39 <Rc43> I got it from here: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/deriving.html
03:01:57 <Rc43> But ghc talks that cannot parse `deriving instance`
03:02:12 <quicksilver> StandaloneDeriving , if I remember rightly.
03:02:15 <startling> sopvop, thrice (+) a = a + a + a
03:02:31 <quicksilver> Rc43: that very document says "GHC now allows stand-alone deriving declarations, enabled by -XStandaloneDeriving"
03:03:02 <startling> sopvop: notice that (+) is an argument. :)
03:03:59 <sopvop> yup
03:04:50 <sopvop> but after all other languages like c++ or python where operator selection is limited. Your first thought is "how the hell these haskell guys remember all that? What a horrible language!". But it's just a library function.
03:06:32 <Rc43> quicksilver, I have tried it
03:09:16 <domedir> *
03:10:21 <quicksilver> Rc43: it should work. How did you try it?
03:10:45 <Rc43> quicksilver, will provide you the code in few minutes
03:10:56 <mcstar> > map (\c -> ord (chr c - 13)) "Qvq lbh abgvpr gung bar bs gur zbhagnvaf qvfnccrnef"
03:10:57 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:10:57 <lambdabot>         against inferred type ...
03:11:08 <mcstar> > chr 'f'
03:11:10 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:11:10 <lambdabot>         against inferred type ...
03:11:14 <mcstar> > ord 'f'
03:11:15 <lambdabot>   102
03:11:23 <mcstar> > map (\c -> chr (ord c - 13)) "Qvq lbh abgvpr gung bar bs gur zbhagnvaf qvfnccrnef"
03:11:24 <lambdabot>   "Did\DC3_U[\DC3TUZice\DC3ZhaZ\DC3UTe\DC3Uf\DC3Zhe\DC3mU[TZaiTY\DC3diYaVVeaXY"
03:13:07 <osfameron> you have to wrap
03:13:36 <Rc43> quicksilver, oh, it works; I have tried it without newline and with tab, so ghc couldn't parse it.
03:13:38 <osfameron> is there a nice tr/// function in haskell?
03:14:05 <Jafet> No, because haskell doesn't have mixfix operators.
03:14:34 <startling> osfameron: you could hack one up, though
03:14:42 <ion> > let rot start end amount n | n >= start && n <= end = (((n - start) + amount) `mod` (end - start + 1)) + start | otherwise = n in map (chr . rot (ord 'A') (ord 'Z') 13 . rot (ord 'a') (ord 'z') 13 . ord) "Grfgvat."
03:14:44 <lambdabot>   "Testing."
03:14:53 <osfameron> Jafet: yeah, I did say *function* ;-)
03:15:08 <startling> using (#/) and (/#), for example
03:15:10 <osfameron> you can implement mixfix operators as 2x functions quite easily.  e.g. ? :
03:15:37 <osfameron> well, you have to rename `:` obviously
03:16:47 <Jafet> > let tr xs ys = map $ \c -> case elemIndex c xs of Just i -> ys !! i; _ -> c in tr ['a'..'z'] (['n'..'z']++['a'..'m']) "grfg."
03:16:49 <lambdabot>   "test."
03:16:57 <startling> haha
03:17:17 <quicksilver> Rc43: good :)
03:18:00 <Rc43> quicksilver, but it seems for (T a) I can't declare Typeable, only Typeable1 for T =/
03:18:27 <osfameron> Jafet: shiny
03:18:33 <bitonic> what the hell.  I was benchmarking by inserting elements and then looking them all up in my map.  now I defined a NFData instance and I just do `rnf', and it's slower!
03:18:40 <bitonic> 6 times slower
03:19:11 <niko> .129
03:19:25 <bitonic> or is it...
03:21:11 <bitonic> yes.  boh
03:21:31 <mmaruseacph2> what was the reason?
03:22:00 <Rc43> Is there real-world example of GADTs usage?
03:22:16 <Rc43> I am trying to do something with them, but always get additional problems with types.
03:22:33 <mmaruseacph2> Rc43: http://stackoverflow.com/questions/3859200/real-world-use-of-gadt
03:22:49 <Rc43> mmaruseacph2, have seen :)
03:23:22 <rtharper> Rc43: maybe ask dreixel?
03:23:23 <mmaruseacph2> ah :)
03:23:29 <mmaruseacph2> my bad then
03:23:29 <bitonic> Rc43: yes, there is.  the most evident is to write more type safe DSLs
03:23:30 <rtharper> he's my go-to GADT man
03:24:40 <Rc43> mmaruseacph2, I also got this link http://www.cs.nott.ac.uk/~nhn/Publications/icfp2005.pdf from somewhere; didn't look yet
03:25:27 <Rc43> bitonic, I am trying to make language with them, too ; everything is ok while I should produce values of GADT or pattern match them
03:25:43 <Rc43> bitonic, common example with evaluation of GADT is pretty, yes
03:26:11 <Rc43> rtharper, everything can be  solved with GADT? :)
03:26:31 <rtharper> Rc43: I dunno about that, depends on how much you want to depend on the type system ;)
03:26:50 <bitonic> Rc43: the advantage is that you can add more type information.  E.g. you might have an `Expr a' GADT where the `a' indicates the type that you get by evaluating it
03:27:38 <Rc43> bitonic, yeah, I am doing the same now
03:29:24 <Rc43> bitonic, evaluation of GADT value is OK; but parsing not so good, but it can be solved; but I can't write Show instance for GADT, because in arguments of Expr I have other exprs ant their args are arbitrary
03:29:54 <dreixel> Rc43: I use GADTs in a rather non-trivial way for modelling musical harmony: http://dreixel.net/research/pdf/fmmh.pdf
03:30:27 <bitonic> Rc43: parsing has nothing to do with GADTs themselves.  I'm not sure I get what problems you're having with Show
03:31:10 <Rc43> bitonic, so if we have ADT value then we know all type parameters of its components, but if we have GADT we can have any other parameters in sub-values
03:31:10 <dreixel> Rc43: there was a thread on a mailing list about uses of GADTs recently: http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/22422
03:31:43 <Rc43> dreixel, thanks, will read soon; do you write music in haskell?
03:32:14 <dreixel> Rc43: no, it's modelling only. We basically generate trees from musical harmony
03:32:31 <dreixel> Rc43: other people do write music in Haskell, though, I can mention a couple if you're interested
03:33:22 <Rc43> dreixel, interesting, but not now; have seen some things in haskell, want to try in future
03:34:21 <Rc43> dreixel, can you explain, what is modelling of musical harmony?
03:34:39 <Rc43> dreixel, what denote trees ?
03:35:35 <Rc43> dreixel, is harmony like a function Note -> [Tone] ?
03:36:07 <Rc43> *Tone -> [Tone]
03:36:23 <dreixel> Rc43: maybe you can browse through the paper quickly? it'll do a better job at explaining the concept than what I can quickly type in here...
03:37:27 <Rc43> dreixel, ok, I tried it, but too hastily; now I see that it explains this
03:38:52 * hackagebot acid-state 0.8.1 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.8.1 (DavidHimmelstrup)
03:44:55 <max___> hi
04:22:14 <maukd> preflex: seen mauke
04:22:14 <preflex>  mauke was last seen on #perl 26 days, 22 hours, 43 minutes and 23 seconds ago, saying: where's your sudo?
04:22:21 <bitonic> is it possible to specialise a class method instance?
04:22:36 <maukd> a what?
04:23:46 <dmwit> yeah, what?
04:25:18 <maukd> preflex: quote
04:25:21 <preflex>  <luke-jr> apeiron: yes, CPAN is stupid.
04:25:22 <bitonic> a class method in a class instance :P
04:25:32 <maukd> I repeat: a what?
04:25:43 <maukd> preflex just lost half of its brain
04:25:58 <bitonic> `instance Class Foo where; method = <...>', I want to specialise `method'.
04:27:37 <maukd> that ';' doesn't belong there
04:27:44 <maukd> what do you mean by "specialise"?
04:30:42 <bitonic> maukd: {-# SPECIALISE ... #-}
04:31:11 * bitonic goes to have lunch
04:32:33 <dmwit> Does {-# SPECIALIZE method :: Foo -> whatever #-} not work?
04:34:17 <dmwit> {-# SPECIALIZE (==) :: Int -> Int -> Bool #-} works, so your thing should, too.
04:34:25 <dmwit> If not, hpaste. ;-)
04:35:27 <bitonic> oh.  it seems to.
04:35:37 <bitonic> well.  sorry about that, I was assuming it wouldn't.
04:37:11 <maukd> presuming makes a pres out of u and ming
04:37:43 <dmwit> It's a good thing he didn't presume anything, then.
04:42:53 <matthiasgorgens> does ghc have any requirements on glibc (or similar)?
04:45:44 <hpc> matthiasgorgens: a couple, but i forget exactly what they are
04:46:14 <maukd> I hear it won't run without a libc
04:46:28 <hpc> it needs libgmp for Integer
04:47:22 <matthiasgorgens> ok.
04:47:32 <matthiasgorgens> is there a list somewhere?
04:48:43 <matthiasgorgens> There are some snippets on http://www.haskell.org/ghc/download_ghc_7_4_1
04:48:46 <matthiasgorgens> but nothing comprehensive.
05:03:12 <echosystm> hi guys im planning to learn haskell as my first functional language
05:03:27 <hiptobecubic> echosystm, a fine choice
05:03:36 <echosystm> there is one thing im particularly interested to know about though - how side effects (eg. IO) are done in a language like this
05:03:49 <echosystm> does anyone know of something i can read that will explain this in lay terms?
05:04:04 <companion_cube> you can read learn you a haskell
05:04:08 <companion_cube> @where lyah
05:04:08 <lambdabot> http://www.learnyouahaskell.com/
05:04:57 <hiptobecubic> echosystm, lyah is great. It will explain what you need to know.
05:05:13 <echosystm> ok
05:05:18 <echosystm> thanks
05:05:21 <opqdonut> lyah is nice, but it lacks exercises
05:05:33 <opqdonut> so you'll need to come up with your own :)
05:05:54 <hiptobecubic> true, but it's more of a well structured reference i think
05:06:04 <echosystm> what are the best kind of use cases for a language like this?
05:06:12 <hiptobecubic> you can always find some puzzle problems to work on somewhere
05:06:18 <echosystm> i know thats a bit of a loaded question, but humour me :P
05:06:19 <hiptobecubic> 99 problems, proj euler, etc
05:06:46 <hiptobecubic> echosystm, decidable problems!
05:09:39 <companion_cube> nah, decidable problems are borin
05:09:41 <companion_cube> boring
05:12:14 <maukd> IO is done by turning executable statements into data structures
05:12:34 <maukd> that is, instead of executing a 'print' statement or whatever, you construct a value that symbolizes "I want to print something"
05:12:47 <maukd> i.e. you're working at a meta-level here
05:12:54 <echosystm> i see
05:12:54 <int-e> companion_cube: heh, that would make a lot of games boring. chess, for example (which you may find boring, but I bet decidability is not the reason.)
05:12:59 <maukd> of course that doesn't actually do anything
05:12:59 <echosystm> so a monad is what you use to do that?
05:13:01 <maukd> no
05:13:06 <maukd> forget about monads
05:13:09 <echosystm> ok
05:13:26 <maukd> this is purely about IO (the type defined in the standard libraries)
05:13:40 <maukd> where was I?
05:13:50 <maukd> oh yeah, these values don't actually do anything, of course
05:14:12 <maukd> so you hand them off to the runtime system, which (not being written in haskell) can actually do stuff
05:14:26 <echosystm> i see
05:14:33 <maukd> this is fine for static output, but for input you need another trick
05:14:50 <maukd> these "statement values" can embed callbacks
05:14:55 <echosystm> what do you mean not being written in haskell?
05:15:12 <maukd> so after the runtime system has e.g. read some bytes from a file, it calls back into the (pure) haskell system
05:15:36 <maukd> well, haskell itself is pure
05:15:47 <maukd> but the runtime system has to interact with C libraries and the real world
05:17:02 <echosystm> why cant you do stuff in haskell itself?
05:17:28 <maukd> no side effects
05:17:37 <echosystm> i see
05:17:43 <echosystm> so where do monads come into this
05:17:51 <maukd> accidentally
05:18:12 <echosystm> can you use monads to "actually do stuff" in haskell?
05:18:13 <maukd> that is, Monad is a fairly abstract and general interface description
05:18:15 <maukd> no
05:18:34 <maukd> it turns out that IO and Monad ... overlap, sort of
05:18:48 <maukd> well, the Monad interface is really small, it's just 'return' and '>>='
05:18:53 <maukd> and IO implements it
05:19:01 <maukd> but so do lots of other types, such as lists
05:19:32 <maukd> but Monad isn't magic; it's a class provided by an ordinary library
05:19:39 <notdan> Monads are just a nice patter that Haskell make heavy use of
05:19:48 <maukd> @src Monad
05:19:48 <lambdabot> class  Monad m  where
05:19:48 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:19:49 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:19:49 <lambdabot>     return      :: a -> m a
05:19:49 <lambdabot>     fail        :: String -> m a
05:20:01 <companion_cube> int-e: I don't know, chess probably has some hard problems, like the existence of a winning strategy from a given position
05:20:05 <maukd> just four operations
05:20:21 <maukd> (>>) isn't technically necessary; it has a default implementation in terms of (>>=)
05:20:27 <maukd> and 'fail' shouldn't even be in there, grr
05:20:57 <int-e> companion_cube: it's a finite game, unless you generalize it to arbitrary board sizes.
05:21:37 <efie> I implemented and algorithm which calculates probabilities for words, I choose the type "Double" for the probability. Regarding how "good" the probabilty should be calculated I can say how long the algorithm should iterate. But for long interations, I get the error "NaN". Does this occur when I divide a number by a very little number, which Haskell then considers to be 0? Do you know how I could fix this?
05:21:42 <companion_cube> you can have infinite sequences of moves
05:21:58 <companion_cube> well, there is the 50 moves rule :/
05:21:59 <maukd> efie: NaN isn't an error, it's a number
05:22:11 <maukd> it stands for Not a Number
05:22:15 <maukd> (but it's lying!)
05:22:42 <maukd> efie: you can get NaN by taking the square root of a negative number
05:22:46 <maukd> or by subtracting two infinities
05:22:51 <int-e> companion_cube: no, there's the 50 moves rule (and even if you could have such infinite moves, the underlying graph would be finite.)
05:23:00 <maukd> > 1/0
05:23:01 <lambdabot>   Infinity
05:23:04 <maukd> > 1/0 - 1/0
05:23:05 <lambdabot>   NaN
05:23:10 <efie> or by dividing by 0?
05:23:10 <maukd> > 0/0
05:23:11 <lambdabot>   NaN
05:23:16 <maukd> dividing 0 by 0, that is
05:23:19 <maukd> otherwise you get infinity
05:23:20 <int-e> companion_cube: but let's stop or move to #haskell-blah.
05:23:27 <kuribas> It's a sort bottom for numbers?
05:25:04 <fmap> efie: why do you use Double?
05:25:58 <efie> fmap: I thought that if I don't have enough precision, Haskell might consider really small numbers to be 0, and therefore I could get 0/0, so NaN
05:26:55 <fmap> efie: yes, but why do you use Double for really small numbers?
05:27:00 <byorgey> efie: if you make a number small enough it will indeed become zero.  But it has nothing to do with Haskell, it's just the IEEE standard for floating-point arithmetic.
05:27:15 <echosystm> ok im confused
05:27:27 <byorgey> echosystm: about what?
05:27:40 <echosystm> in lyah, it says doubleMe x = x + x, shouldnt that be let doubleMe x = x + x ?
05:27:45 <echosystm> to define a function
05:27:49 <maukd> echosystm: no
05:27:55 <byorgey> echosystm: at the ghci prompt you have to write   let ...
05:27:55 <maukd> (this isn't OCaml)
05:28:02 <echosystm> oh
05:28:04 <echosystm> i see
05:28:05 <byorgey> echosystm: but in a .hs file you just write   doubleMe x = x + x
05:28:16 <echosystm> why is that?
05:28:33 <byorgey> echosystm: no good reason, really
05:28:48 <byorgey> echosystm: basically, the ghci prompt is sort of like one big do-block
05:28:52 <byorgey> but that's not a good reason
05:29:07 <echosystm> are there any other instances where ghci isnt the same as running code line-by-line ?
05:29:22 <byorgey> echosystm: yes, lots.
05:29:30 <byorgey> echosystm: for instance, at the ghci prompt you can write expressions
05:29:40 <byorgey> you can't just put expressions by themselves in a .hs file
05:29:44 <echosystm> ok
05:29:55 <maukd> echosystm: do you know C?
05:30:09 <echosystm> i know java :-)
05:30:33 <efie> fmap: well if I have something like 0.003/0.004 (just an example) I want to get 0.75 as a result and not NaN
05:30:48 <echosystm> ruby perl js php objective-c... all the usual resume languages
05:30:53 <efie> therefore I do need more precision, dont I?
05:31:03 <Lajjla> So, the sources on monadic values all disagree, some say you can see them as data 'describing computations', others say you cannot see them as anythingf and you should just see the function 'putStrLn' as a function that has a side effect when sequenced inside the IO monad, so what's the deal?
05:32:19 <companion_cube> it's more like putStrLn "foobar" returns a value that describes how to print "foobar" on a line
05:32:23 <byorgey> efie: no.
05:32:29 <byorgey> > 0.003/0.004
05:32:30 <lambdabot>   0.75
05:32:46 <byorgey> efie: that is well within the accuracy of Double.
05:33:09 <efie> byorgey: yes, thats why I said it was an example :)
05:33:10 <Lajjla> companion_cube, that is what some sources claim and I see no reason why you can't see it like that, but some other sources claim you can absolutely not see it like that, but don't bother to explain why not.
05:33:29 <byorgey> efie: to get NaN you would have to be talking about values like  0.000 ... hundreds of zeros ... 0003
05:33:36 <Lajjla> It seems to be a value to me though, you can store it in a list, throw it away, make an instance of 'show' for it if you want.
05:34:00 <byorgey> efie: and I can't see any good reason why you would need values like that.
05:34:00 * hackagebot monoid-extras 0.2.1.0 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.2.1.0 (BrentYorgey)
05:34:02 <maukd> echosystm: javascript is actually pretty helpful here
05:34:13 <byorgey> efie: which makes me think your NaNs are due to a bug, not to insufficient precision.
05:34:34 <companion_cube> Lajjla: I'm curious, who says there is no way to see putStrLn this way?
05:34:38 <maukd> echosystm: ajax (that is, asynchronous XMLHttpRequest) is very similar to Haskell's IO system
05:34:51 <echosystm> i see
05:34:52 <companion_cube> putStrLn "foobar" really is a IO (), which is the description of a side effect
05:34:54 <efie> byorgey: yeah, I will check the code again, thanks :)
05:35:00 <companion_cube> and yes, you can put it in a list, and do stuff with it
05:36:36 <maukd> echosystm: and if you know about context in perl, Haskell has something similar but more general and powerful
05:37:04 <efie> byorgey: I was just wondering because result of the algorithm is what I expect and becomes better with more iterations, until the point when I get NaN
05:37:49 <byorgey> efie: ah, interesting
05:39:08 <Lajjla> companion_cube, I would agree, but I found many sources and people who say there are issues with that, but never explained to me such an issue, I'll see if I can find some.
05:39:45 <companion_cube> well, I don't see any problem with it :/
05:40:04 <companion_cube> and you can do stuff like   let a = putStrLn "foo" in a >> a >> a,  to perform the action three times
05:41:58 * byorgey also agrees with Lajjla and companion_cube, and would be interested in seeing any such sources which say otherwise
05:42:13 <Lajjla> Yeah, or chainAllTheThings [] = return () ; chainAllTheThings (x : xs) = x >> chainAllTheTHings xs ;, so I don't get it.
05:42:26 <byorgey> Lajjla: you get it perfectly.
05:42:35 <companion_cube> chainAllTheThings is also called sequence ^^
05:42:38 <companion_cube> :t sequence
05:42:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:42:47 <companion_cube> or sequence_
05:43:28 <byorgey> I suspect the sources you saw were trying to make some emphasis which is somewhat different than what you got out of it.  But I'd have to see them.
05:43:54 <Lajjla> byorgey, I must admit to have a hard time googling them, but I somet imes find them, or people that claim that thing.
05:44:07 <Lajjla> To me at least, a monadic value is just a datum which the runtime interprets
05:44:26 <Lajjla> hughfdjackson, hey sweety.
05:44:36 <byorgey> Lajjla: or perhaps they were written aimed at someone with very different confusions than you.
05:45:03 <byorgey> Lajjla: anyway, so far your understanding seems perfectly fine to me, so just ignore them =)
05:45:11 <byorgey> there are lots of bad monad tutorials out there.
05:45:13 <Lajjla> Well, they typically say 'Some people would say that monadic values are descriptions of computations but this is a na√Øve understanding' or something like that and don't explain why.
05:45:14 <Lajjla> But okido.
05:45:33 <Lajjla> @quote Kukkua
05:45:33 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
05:49:01 * hackagebot regex-applicative 0.2.1 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.2.1 (RomanCheplyaka)
05:50:07 <hiptobecubic> I hate the way packages are named
05:50:33 <hiptobecubic> and how it's completely unrelated to the library path
05:51:23 <hiptobecubic> you know you want Data.Legs.Prosthetic, but you don't know what to install without searching hayoo
05:52:20 <hvr> hiptobecubic: doesn't cabal offer a way to search packages which contain certain modules?
05:52:30 <maukd> hiptobecubic: that's just a bug in cabal
05:53:04 <dcoutts> bug? no it's a lacking feature
05:53:12 <hiptobecubic> well it's terrible
05:53:51 <hiptobecubic> And then it turns out the package was called "cyborgia-major-0.0.2.1"
05:54:05 <maukd> dcoutts: a pretty major missing feature
05:54:27 <dcoutts> patches accepted
05:54:32 <hvr> dcoutts: it would help, if 'cabal list' had a way to list the module names, just as 'cabal info' does... then one could pipe it into 'less' at least
05:54:34 <alpounet> hah
05:54:48 <maukd> in perl I can just say 'cpan LWP::Simple' and it figures out that it has to get libwww-perl for me
05:55:12 <dcoutts> maukd: I agree, it'd be nice
05:55:30 <dcoutts> and it's not that hard, just one of many features that need to be implemented
05:55:44 <hvr> maukd: and what does it do, if multiple packages provide the module?
05:55:52 <alpounet> it actually hasn't happened that much to me to know the module i need but not the package
05:57:22 <marcot> Hi.  Is there a simple way to run an IO function for a limited period of time, exiting with error if the time limit was exceeded?
05:57:40 <marcot> something like: runWithLimitedTime :: Int -> IO a -> IO (Maybe a)
05:57:53 <maukd> hvr: I don't know. that hasn't happened yet
05:58:03 <tibbe> marcot: you can use the timeout function to write that function
05:58:10 <tibbe> marcot: the new async library might also have something
05:58:14 <maukd> @hoogle timeout
05:58:15 <lambdabot> System.Timeout module System.Timeout
05:58:15 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
05:58:15 <lambdabot> System.Event type TimeoutCallback = IO ()
05:58:48 <marcot> tibbe: Thanks, that's the exact type of timeout.
05:58:56 <tibbe> mrcarrot: np
05:59:00 <tibbe> marcot: np
05:59:13 <hvr> marcot: jfyi, timeout uses microseconds...
05:59:24 <marcot> The first hit on hoogle.  I should have searched there.
05:59:30 <hvr> (I'm just saying this, because it confuses at first sometimes)
05:59:30 <marcot> hvr: ok, thanks.
06:06:15 <hiptobecubic> @src (>=>)
06:06:15 <lambdabot> Source not found. My mind is going. I can feel it.
06:06:37 <echosystm> removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
06:06:38 <hiptobecubic> is it just composition?
06:06:45 <echosystm> removeNonUppercase s = filter (`elem` ['A'..'Z']) s
06:06:57 <echosystm> which of those would be more likely to be used in the real world?
06:07:04 <maukd> filter isUpper
06:07:17 <maukd> well, or filter (inRange ('A', 'Z')) for ASCII
06:07:48 <echosystm> it seems like this list comprehension stuff is cool but hard to read
06:07:58 <benmachine> I would not use list comprehensions for that
06:08:00 <hiptobecubic> echosystm, i think the second is more readable, but you'd see maukd's example in use
06:08:05 <echosystm> the 2nd one makes more sense to me
06:08:23 <benmachine> list comprehensions have their place, but usually for things more involved than that
06:08:30 <hiptobecubic> echosystm, they are better for complicated things, like when you need to reuse arguments in multiple functions
06:08:30 <benmachine> things with more than one <-
06:08:37 <echosystm> ok cool
06:08:40 <hiptobecubic> echosystm, also that
06:08:48 <maukd> > (\st -> do c <- st; guard (c `elem` ['A' .. 'Z']); return c) "Hello, World!"
06:08:49 <lambdabot>   "HW"
06:09:02 <maukd> who needs list comprehensions when you have do-notation?
06:09:08 <benmachine> a fair question :)
06:09:58 <hiptobecubic> that is terrible
06:10:09 <hiptobecubic> @pl (\st -> do c <- st; guard (c `elem` ['A' .. 'Z']); return c)
06:10:09 <lambdabot> (line 1, column 19):
06:10:09 <lambdabot> unexpected ";"
06:10:10 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
06:10:52 <maukd> need @undo first
06:13:34 <jdnavarro> I need a function doing something like: f 100 -> [100, 99, 97, 93, 85, 69, 37...] (it doubles the decrease for each step)
06:14:04 <jdnavarro> what would be a functional way to do it? an instance of Enum?
06:15:20 <benmachine> jdnavarro: just write a recursive function
06:15:24 <maukd> :t scanl
06:15:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
06:15:36 <Botje> > take 10 $ scanl (-) 100 $ iterate (*2) 1
06:15:37 <lambdabot>   [100,99,97,93,85,69,37,-27,-155,-411]
06:15:41 <maukd> > scanl (-) 100 [1 ..]
06:15:42 <lambdabot>   [100,99,97,94,90,85,79,72,64,55,45,34,22,9,-5,-20,-36,-53,-71,-90,-110,-131...
06:15:59 <jdnavarro> maukd: great
06:16:05 <maukd> except I did it wrong
06:16:17 <maukd> Botje wins this round
06:16:30 <Botje> woo! what do I win? a \cookie?
06:16:55 <maukd> U+1F36A (f0 9f 8d aa): COOKIE [üç™]
06:16:59 <jdnavarro> Botje: :)
06:17:30 <jdnavarro> thanks
06:17:32 <Botje> maukd: it kind of looks like a rupee from Zelda.
06:18:00 <maukd> U+20A8 (e2 82 a8): RUPEE SIGN [‚Ç®]
06:22:39 <JuanDaugherty> the rupee html is seldom rendered correctly, I use an image file
06:23:21 <JuanDaugherty> http://meansofproduction.biz/images/rupee.png
06:28:48 <hiptobecubic> > scream "hello world"
06:28:49 <lambdabot>   Not in scope: `scream'
06:28:52 <hiptobecubic> awwww
06:30:19 <mikeplus64> > let scream = (++ " !!!") . map toUpper in scream "hello world"
06:30:21 <lambdabot>   "HELLO WORLD !!!"
06:30:46 <hiptobecubic> maukd, do you have unicode search or something?
06:30:54 <maukd> hiptobecubic: yes
06:31:34 <hiptobecubic> maukd, nice
06:31:55 <hiptobecubic> mikeplus64, we had a nice implementation of screaming that abused the [] monad. I don't remember it now though
06:32:33 <atriq> > yell "hello world"
06:32:34 <lambdabot>   Not in scope: `yell'
06:32:40 <atriq> > shout "hello world"
06:32:41 <lambdabot>   Not in scope: `shout'
06:32:42 <atriq> :(
06:34:12 <maukd> hiptobecubic: if you want it, download http://paste.scsys.co.uk/208615?tx=on and save as .html
06:34:57 <maukd> > transpose (words "hello world")
06:34:59 <lambdabot>   ["hw","eo","lr","ll","od"]
06:35:09 <maukd> > concat (transpose (words "hello world"))
06:35:10 <lambdabot>   "hweolrllod"
06:36:02 <hiptobecubic> maukd, wow
06:36:23 <Morgawr> hey guys, yesterday I had asked about a gtk2hs tutorial and I noticed there's a huge lack of in-depth tutorial... However I was able to find this http://www.muitovar.com/gtk2hs/index.html I'm just sharing in case someone else is interested and had troubles finding a good tutorial :)
06:38:01 <dcoutts> Morgawr: perhaps email the gtk2hs devs and tell them to link it from the documentation page on their site
06:38:11 <hiptobecubic> maukd, this is nice
06:38:42 <Morgawr> dcoutts: maybe I will, I'm just getting through the tutorial now and see how recent and updated it is (since both the "official" gtk2hs tutorial and the glade one are very old and use deprecated/broken functions)
06:38:55 <Morgawr> if it's a good one, I'll probably see if I can mail it/warn them about it
06:39:05 <maukd> hiptobecubic: you mean the unicode search? it can search by literal text, codepoint numbers, or description
06:39:14 <alpounet> Haskell GUI libraries need some love, mostly documentation-wise
06:39:46 <hiptobecubic> I wish i had a font that could display all of these...
06:40:43 <Morgawr> the gtk2hs API is pretty good, but I'm still a newbie and I find it hard to learn how to work with it by just looking at the API (well, it just takes too long)
06:40:43 <Morgawr> overall yeah, GUI development with gtk2hs is really nice and polished (the little I can achieve), it really needs more love
06:40:43 <hiptobecubic> U+1F63C (f0 9f 98 bc): CAT FACE WITH WRY SMILE [üòº]
06:40:43 <alpounet> Morgawr, are the examples from RWH already outdated?
06:40:43 <hiptobecubic> U+1F63B (f0 9f 98 bb): SMILING CAT FACE WITH HEART-SHAPED EYES [üòª]
06:40:43 <dcoutts> Morgawr: this is useful feedback, make sure the gtk2hs devs get the feedback (ie email the list)
06:41:31 <Morgawr> alpounet: I've read both RWH and LYAH, finished LYAH and got around halfway through RWH. I don't know if it handles GUI/gtk2hs but I know that RWH is very outdated (and sometimes broken) in some parts (Which is why I abandoned it and moved over to LYAH)
06:42:03 <alpounet> yeah i know about a few broken parts too
06:42:04 <hiptobecubic> I had the same experience
06:42:21 <alpounet> i know that the way gtk2hs must be installed has changed since then too
06:42:26 <hiptobecubic> wasted hours figuring out Exception before i realized it wasn't my fault
06:42:27 <alpounet> but i don't know if the API has changed
06:42:43 * sopvop has made a MonadEither typeclass, to make working with newtype wrappers over EitherT more pleasant.
06:44:11 <hiptobecubic> unicode is weird
06:44:14 <hiptobecubic> U+1F63D (f0 9f 98 bd): KISSING CAT FACE WITH CLOSED EYES [üòΩ]
06:44:30 <nicoo> hiptobecubic: Not Unicode itself
06:45:26 <nicoo> But the people who keep filling additionnal pages with useless symbols, so as to justify the continued existence of their workgroup
06:45:51 <liyang> I don't think that's Unicode being weird. It's Japan.
06:46:57 <hiptobecubic> U+1F4A9 (f0 9f 92 a9): PILE OF POO [üí©]
06:47:08 <frerich> Yep. Japan.
06:47:12 <liyang> Yup.
06:47:19 <hiptobecubic> Are you sure? Might be germany
06:47:54 <liyang> Mobile phone kaomoji.
06:48:16 <frerich> IIRC there's an iPad app which adds these symbols to your keyboard, too.
06:48:28 <hiptobecubic> lol this are great
06:48:31 <hiptobecubic> these*
06:48:35 <hiptobecubic> U+1F625 (f0 9f 98 a5): DISAPPOINTED BUT RELIEVED FACE [üò•]
06:48:46 <hiptobecubic> Just in case, you know? They have everything here
06:49:07 <Morgawr> mmm.. all gtk2hs tutorials/examples use "onClicked button $ do (etc etc)" but in their API all the onXXXX functions are deprecated and from what I could understand the better way would be to do "button `on` buttonPressEvent $ tryEvent $ do (...)"
06:49:22 <Morgawr> however that looks way uglier and harder to handle (gotta handle all separate mouse buttons and stuff)
06:49:30 <Morgawr> do you think it would be a problem to use the deprecated API?
06:49:36 <liyang> That's why they've been added to Unicode, so people can continue to use these when e-mailing each other from their phones.
06:49:58 <nicoo> liyang: Japan doesn't exists
06:50:17 <liyang> nicoo: then where am I living?!
06:50:39 <hiptobecubic> Morgawr, import hiding that function and redefine it yourself in terms of new api
06:51:22 <nicoo> liyang: You are part of a conspiracy aiming to make people believe Japan exists, so as to explain away all unexplainable weirdness by ¬´ Because Japan ¬ª
06:51:23 <hiptobecubic> onClicked button = button `on` buttonPressEvent . tryEvent    -- or something
06:51:30 <Morgawr> hiptobecubic: mmm.. that sounds a bit tricky, could you provide a small example? Like, I import onClicked and then redefine it as "button `on` etc etc"?
06:51:35 <Morgawr> ahh
06:51:48 <hiptobecubic> Morgawr, import WhateveRLibrary hiding (onClicked)
06:51:51 <Morgawr> the problem is that the handling of such an event is totally different
06:52:18 <Morgawr> in onClicked you handle the click event, in buttonPressEvent you have to handle the button pressed and all its modifiers
06:52:31 <Morgawr> (which I'm still trying to understand how since I don't quite get the API for the mouse clicking )
06:52:38 <liyang> nicoo: lies! („Éé‡≤†Áõä‡≤†)„ÉéÂΩ°‚îª‚îÅ‚îª
06:52:47 <hiptobecubic> Morgawr, I really have no idea unfortunately. I haven't used gtk2hs. Just making suggestions :)
06:53:20 <hiptobecubic> Morgawr, if you always handle the modifiers the same way, then you can just include them in onClicked
07:01:58 <Kipper> l
07:02:10 <atriq> l indeed
07:12:03 <mietek> Why does cabal-dev install-deps warn about "packages likely to be broken by the reinstalls"?
07:12:11 <mietek> I thought cabal-dev would install deps into the local sandbox
07:12:20 <Quantumplation> I'm developing a space-based economy simulation that's going to serve as the foundation for a game.  I have "stars" that have resources, and you can create conduits to ship resources between them.  A star should know what conduits it has (incoming and outgoing), but a conduit should know what it's start and end destination are.  This creates a cyclic dependency if I want to break them into multiple files.  How could I solve 
07:12:48 <byorgey> mietek: it's warning you about packages in the sandbox which are likely to be broken.
07:13:10 <byorgey> even sandboxed packages have feelings, you know.
07:13:48 <nicoo> Quantumplation: A way to do so is having one of them to be polymorphic
07:13:48 <mietek> byorgey: :)
07:13:53 <mietek> What's the local sandbox directory name?
07:14:03 * hackagebot warp-tls 1.3.1 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.3.1 (MichaelSnoyman)
07:14:05 * hackagebot gluturtle 0.0.3 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.3 (YoshikuniJujo)
07:14:09 <byorgey> mietek: cabal-dev
07:14:22 <byorgey> mietek: rm -rf cabal-dev is fine if you want to start fresh
07:14:52 <mietek> byorgey: thanks for confirming. So, I *am* starting fresh.
07:15:11 <mietek> And yet...
07:15:44 <Quantumplation> nicoo: Oo, thanks! I can make conduits polymorphic over what they ship between.
07:15:55 <mietek> byorgey: http://pastie.textmate.org/private/zgk3jhsszpq6asywpwle9w
07:16:37 <merijn> Quantumplation: Even better when you later decide to add space stations you can immediately have conduits between stations ;)
07:16:52 <Quantumplation> *nods* and make "ShippingDestination" a typeclass :D
07:17:14 <byorgey> mietek: and you're telling me you *don't* have a cabal-dev directory?
07:17:37 <mietek> byorgey: that's right, I just wiped it again
07:17:51 <mietek> byorgey: running this command creates a new one with a packages file and not much else
07:18:23 <fmap> does cabal-dev use globally installed packages?
07:18:27 <byorgey> mietek: running what command?
07:18:33 <mietek> byorgey: cabal-dev install-deps
07:18:51 <efie> could you tell me if there is a function for this pattern http://hpaste.org/75440 ?
07:19:19 <mietek> byorgey: this just creates the following:
07:19:19 <mietek> cabal-dev/cabal.config
07:19:19 <mietek> cabal-dev/packages/00-index.cache
07:19:19 <mietek> cabal-dev/packages/00-index.tar
07:19:20 <mietek> cabal-dev/packages-7.4.1.conf/package.cache
07:19:20 <efie> applying a monadic function n times ...
07:19:50 <byorgey> oh, hmm, yes, maybe it's because by default cabal-dev copies in some packages to start?  i.e. ones that come with the platform, or something like that
07:19:57 <byorgey> I am not sure
07:20:10 <matthiasgorgens> efie: a foldr, probably.
07:22:57 <efie> matthiasgorgens: what would be the list I would fold over?
07:24:02 <matthiasgorgens> efie: logWb n sp wb = foldr (=<<) (return wb) $ replicate n (updateWBuch2 sp)
07:24:07 <matthiasgorgens> something like this.
07:24:38 <efie> matthiasgorgens: oh,oh I'll think about it thanks :)
07:28:03 <Quantumplation> I don't suppose there's a way to make only one of the constructors of a data type polymorphic?
07:28:56 <Morgawr> okay this is weird.. I'm reading the gtk2hs API and it talks about a "signalEmitByName" if I want to generate signals pogrammatically (or whatever you spell it), however such thing doesn't seem to exist.. I checked hoogle, I checked google, I checked everywhere and I can't seem to find any reference (except the API comment) about "signalEmitByName"... any idea?
07:30:34 <ClaudiusMaximus> Morgawr: seems missing, at least http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=signalemitbyname doesn't find anything useful
07:31:05 <matthiasgorgens> efie: new version:
07:31:07 <matthiasgorgens> logWb :: Int -> Satzpaare -> Woerterbuch -> Writer [String] Woerterbuch
07:31:07 <matthiasgorgens> logWb n = foldr (<=<) return . replicate n . updateWBuch2
07:31:08 <Morgawr> well this is a bummer...
07:31:34 <matthiasgorgens> but that's just point-less. :o)
07:31:54 <efie> matthiasgorgens: <=< looks weird, I haven't come across this yet
07:32:04 <matthiasgorgens> @hoogle (<=<)
07:32:04 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
07:33:21 <matthiasgorgens> but I have a hunch you don't want the semantics of your current version in the first place.
07:33:25 <fmap> Quantumplation: you may want to take a look at GADTs
07:33:35 <Morgawr> so if I wanted to generate an entryActivate event when clicking on a button using gtk2hs... there's no way?
07:33:55 <applicative> @type foldr (<=<) return
07:33:56 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
07:34:02 <ousado> anyone here using frege, or not using it for some reason despite having to target the JVM?
07:34:04 <matthiasgorgens> efie: it looks strange that the parameter (sp :: Satzpaare) doesn't change from one call of logWb to the next.
07:35:05 <Quantumplation> fmap: GADT's confuse and scare me every time I read about them.
07:36:00 <efie> matthiasgorgens: updateBuch2 needs sp as a paramter, what else could I do?
07:36:48 <matthiasgorgens> no, it's fine.
07:37:01 <matthiasgorgens> I just had a hunch that these were not actually the semantics you wanted.
07:37:08 <matthiasgorgens> but you know that better than I do. :o)
07:37:24 <efie> matthiasgorgens: thanks :)
07:37:35 <matthiasgorgens> efie: there's a general lesson in the (replicate n) portion:
07:38:29 <matthiasgorgens> in haskell instead of creating a specific control structure (i.e. your recursion), you can generally create a data structure (replicate n) and then use a standardized combinator (i.e. foldr).
07:39:45 <efie> matthiasgorgens: that's good to know
07:40:15 <matthiasgorgens> efie: monad-loops is a nice package to look into.
07:53:09 <xrchz> how come readFile x returns the file contents but withFile x ReadMode hGetContents does not?
07:53:27 <Morgawr> okay.. stupid haskell question, what if I want to run a function that returns a IO () inside a code that expects a Bool return? How do I encapsulate it?
07:53:28 <xrchz> I thought they were both the same amount of lazy, so equal
07:53:39 <Morgawr> (I might be getting confused with monads)
07:53:57 <okxhol> Morgawr, you cant' (except if you hack with unsafePefformIO)
07:54:05 <Morgawr> mmm
07:54:09 <xrchz> Morgawr: you could lift the whole thing into IO
07:54:28 <xrchz> Morgawr: i.e. rather than expect a Bool, make it expect IO Bool
07:54:34 <Morgawr> I think I'm getting very confused at all this gtk2hs stuff..
07:54:48 <Cale> xrchz: the reason is that with hGetContents, you are *not* allowed to close the filehandle
07:54:57 <Cale> xrchz: which withFile will
07:55:09 <xrchz> Cale: woah really?
07:55:24 <xrchz> ok so how do I write a program that has one function that can read the contents of a file
07:55:28 <xrchz> another function can write to that file
07:55:29 <Cale> xrchz: hGetContents (for String I/O) does some magic
07:55:30 <xrchz> and I want to compose them
07:55:45 <xrchz> but also want them separately at other times
07:55:54 <xrchz> I want them to be atomic on the file bascially
07:56:01 <Cale> xrchz: tbh the easiest way is to use strict I/O, like strict ByteString or Text
07:56:26 <xrchz> humm but I have stuff set up expecting a String...
07:56:32 <alpounet> BS.unpack
07:56:48 <xrchz> and now I have to learn all the APIs for strict I/O...
07:56:57 <Cale> However, this is actually bad policy in general (in any language) -- you should always write to a new file, and then copy it over the old one.
07:56:58 <xrchz> is there no other simple way with existing stuff in stdlibs?
07:57:05 <Cale> (or move)
07:57:07 <alpounet> the API is the same iirc
07:57:21 <xrchz> Cale: how come?
07:58:20 <Cale> For one because it means that the file will always appear complete to an external observer.
07:58:36 <Cale> Many OSes can make that 'move' look atomic
07:58:56 <Cale> So that you don't have a partial file for a while.
07:59:25 <Cale> and it's also just generally harder to mess up :)
07:59:50 <xrchz> hmm... will it also enable me to avoid strict i/o, or even better just use prelude functions?
08:00:12 <Morgawr> can somebody help me out a second? I have issues trying to figure out how to obtain the button pressed from this function http://hackage.haskell.org/packages/archive/gtk/latest/doc/html/Graphics-UI-Gtk-Abstract-Widget.html#v:buttonPressEvent
08:00:16 <Cale> yes
08:00:24 <Morgawr> I need to find out if the left button was pressed or not
08:00:29 <xrchz> ok i'll try writing out to a temp file then moving
08:00:46 <Cale> xrchz: The problem with doing this sort of thing with lazy I/O is that you'll be reading from the input file as you're writing the new one
08:01:00 <Cale> xrchz: but if the new one is the same file, then you end up with a mess
08:02:00 <rwbarton> if your computer gets unplugged while writing the output you won't lose both the input and the output files
08:02:07 <alpounet> xrchz, unless the file is big and you have to somehow "incrementally operate on it", strict i/o isn't bad here
08:02:20 <xrchz> what's bad is having to figure out how to import it and use it :p
08:02:47 <xrchz> is there stuff for moving files in prelude or System.IO or something?
08:02:58 <rwbarton> @hoogle rename
08:02:58 <lambdabot> System.Posix.Files rename :: FilePath -> FilePath -> IO ()
08:02:58 <lambdabot> System.Directory renameDirectory :: FilePath -> FilePath -> IO ()
08:02:58 <lambdabot> System.Directory renameFile :: FilePath -> FilePath -> IO ()
08:03:01 * xrchz is lazier than haskell
08:03:02 <alpounet> juste import the strict ByteString or the Text module qualified, and then BS.readFile/T.readFile.etc
08:03:03 <Quantumplation> Can't seem to get these damned cyclic dependencies out of here: http://hpaste.org/75443
08:03:08 <xrchz> cheers
08:03:12 <Cale> Morgawr: eventModifier :: HasModifier t => EventM t [Modifier]
08:03:29 <Cale> Morgawr: the buttons are values of type Modifier
08:03:35 <xrchz> alpounet: ok i might try that if this doesn't work. sounds like i should be writing to a temp file and moving it either way though.
08:03:55 <Morgawr> Cale: so I just apply that to my button?
08:04:00 <Cale> Morgawr: so you can run that action and then look in the list to see what button if any was being pressed
08:04:06 <Morgawr> mmm
08:04:30 <rwbarton> Quantumplation, one common approach is to stuff all the types into a single Types.hs
08:04:53 <rwbarton> Quantumplation: however I also wonder whether you really want this kind of cyclic datastructure? (apologies if I am missing past context)
08:05:56 <Cale> Morgawr: This stuff looks a little crazy type-wise, but it actually makes some amount of sense once you get it. Different classes of events have tags like EButton, EConfigure, EExpose, EFocus, etc.
08:06:17 <Cale> Morgawr: Then those tags belong to various typeclasses to say which data they make available to handlers
08:06:23 <Quantumplation> I'm making an economic simulator that's going to serve as the foundation for a game.  So, Stars have buildings which consume resources and produce other resources as output, and you can move those resources between planets.  In order to move things between two stars, you need to build a jumpgate at each of those two stars
08:06:54 <Cale> Morgawr: and the actions for getting that data actually check that you're in a handler for an event which will provide that data
08:06:56 <Quantumplation> A conduit needs to know it's start and end destination, a star needs to know incoming and outgoing conduits, and a jumpgate needs to know what conduit is assosciated with it (so if it gets destroyed, it can also destroy the conduit)
08:07:17 <rwbarton> the problem is imagine what happens if you try to add a building at a Star
08:07:29 <Cale> (which is what the HasModifier constraint on eventModifier does)
08:07:42 <Morgawr> Cale: I know this might be too much to ask but could you provide a small example? All I need is to check, after a "buttonPressEvent" happened, if the LeftButton was held or not
08:07:47 <rwbarton> if you have a Conduit out of that Star, the Conduit will still be referring to the old Star
08:07:51 <Morgawr> I just don't understand how I would code such thing
08:08:02 <Morgawr> I can't find code examples on the web
08:08:56 <Cale> on buttonPressEvent $ do ms <- eventModifier; if Button1 `elem` ms then ... else ...
08:09:05 <Cale> oh, oops
08:09:19 <Cale> myObject `on` buttonPressEvent $ do ...
08:09:37 <Morgawr> mmm okay, this is helpful.. lemme check if I can get it to work :)
08:12:20 <Cale> Morgawr: btw, in the handler itself, you'll need to liftIO to execute general IO actions
08:12:34 <Cale> (because it'
08:12:34 <Morgawr> Cale: mm this is weird.. if I'm inside the if/then/else construct I can't do "liftIO $ widgetActivate chatEntry" (which is what I need to do)
08:12:38 <Cale> it's not in the IO monad)
08:12:40 <Morgawr> because it says the function is not applied to enough arguments
08:12:51 <Cale> errr
08:13:02 <Morgawr> like, this is my code
08:13:02 <Morgawr> http://hpaste.org/75444
08:13:05 <Morgawr> without the if/else
08:13:14 <Morgawr> if I add the if/else then the code stops working
08:13:29 <Cale> um, can I see your new code?
08:13:35 <zomg> Haskell is hard, let's go shopping!
08:13:36 <zomg> =)
08:13:37 <Quantumplation> rwbarton: couldn't you do something like: http://hpaste.org/75445
08:13:38 <Cale> You might also just want 'when'
08:13:41 <osfameron> shopping is hard!
08:13:44 <zomg> lol
08:14:03 <Cale> What is tryEvent btw?
08:14:23 <Cale> oh, I see
08:14:35 <Morgawr> http://hpaste.org/75446 this is my new code
08:14:36 <rwbarton> Quantumplation: what about all the other conduits that refer to those stars
08:14:40 <Morgawr> which yeah, obviously tells me to use when
08:14:50 <Quantumplation> rwbarton: oh right
08:14:51 <Cale> oh, you indented that incorrectly
08:14:51 <Quantumplation> hrm
08:15:05 <Cale> whoops
08:15:18 <Quantumplation> i guess I'd need some kind of StarID that the conduit refers to? :-S
08:15:20 <rwbarton> you're going to need some notion of Star identity
08:15:20 <Morgawr> Cale: how so?
08:15:22 <rwbarton> yeah
08:15:28 <Cale> oh, also, you missed a 'do'
08:15:28 <perfwill> I still don't get how function signatures work, anybody has a link, article, docs or something about it?
08:15:33 <Cale> if foo
08:15:35 <Cale>    then bar
08:15:38 <Cale>    else quux
08:15:47 <Cale> ^^ that's how you lay out if :)
08:15:49 <rwbarton> you certainly have a "domain notion" of Star identity already
08:16:04 <hpaste> Cale annotated ‚Äúnew code :D‚Äù with ‚Äúnew code :D (annotation)‚Äù at http://hpaste.org/75446#a75448
08:16:04 <rwbarton> Star A is the same as Star B if adding a building to A causes B to gain a building as well
08:16:06 <Morgawr> ahh
08:16:06 <Quantumplation> rwbarton: what do you mean?
08:16:13 <Quantumplation> ah
08:16:20 <rwbarton> not "Star A is the same as Star B if they have the same buildings, ..."
08:16:52 <Cale> Morgawr: also, inside the 'then' you had two actions, which you need to glue together with 'do' otherwise, it'll parse as one being a parameter to the other
08:16:54 <Quantumplation> I could use their positions as their identifier (not depicted in the code snippet cause I wanted to focus on the important parts)
08:17:06 <Morgawr> yeah, thanks, I'm still a newbie with this stuff
08:17:08 <rwbarton> so a common solution is to use a Map from some kind of identifier (e.g. an Int or whatever) to Stars
08:17:22 <rwbarton> and have a Conduit store identifiers
08:17:26 <Quantumplation> *nods* stars are already stored in an octree, so position is great.
08:17:30 <Cale> perfwill: hmm... most tutorials should discuss that...
08:17:40 <Morgawr> Cale: how would I write it using when, instead?
08:17:42 <alpounet> perfwill, what is it that you don't understand about them?
08:17:42 <Cale> perfwill: Is there something in particular which is bothering you?
08:18:15 <hpaste> Cale annotated ‚Äúnew code :D‚Äù with ‚Äúnew code :D (annotation) (annotation)‚Äù at http://hpaste.org/75446#a75449
08:18:22 <perfwill> for example
08:18:28 <perfwill> I write this simple code
08:18:39 <perfwill> let f a b = a + b
08:18:43 <perfwill> its type is
08:18:49 <perfwill> f :: Num a => a -> a -> a
08:18:52 <Cale> right
08:18:54 <perfwill> I don't get it
08:18:57 <centrinia> :t \a b -> a+b
08:18:58 <lambdabot> forall a. (Num a) => a -> a -> a
08:19:08 <Quantumplation> things have to be "numbers" to be added.
08:19:10 <Morgawr> Cale: do I need to import something for "when"? it says not in scope
08:19:11 <matthiasgorgens> perfwill: do you know how to put the parens?
08:19:22 <perfwill> how?
08:19:23 <matthiasgorgens> @hoogle when
08:19:23 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
08:19:23 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
08:19:23 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
08:19:26 <Cale> That says, for any type a, when a belongs to the type class Num (i.e. a is a type of numbers)...
08:19:33 <matthiasgorgens> Morgawr: Control.Monad
08:19:43 <Cale> then f takes a parameter of type a, and another parameter of type a, and produces a result of type a
08:19:46 <Morgawr> oh, thanks.. sorry for the stupid questions
08:19:53 <matthiasgorgens> perfwill: you can write the type as: (Num a) => a -> (a -> a)
08:19:56 <alpounet> perfwill, is it the "Num a" that bothers you?
08:20:12 <alpounet> or the general syntax
08:20:27 <perfwill> no, it's the "->" and a bunch of "a"'s that bothers me
08:20:32 <matthiasgorgens> :t \(a,b) -> a + b
08:20:33 <lambdabot> forall t. (Num t) => (t, t) -> t
08:20:43 <Cale> Let's start with assuming  f :: Integer -> Integer -> Integer
08:20:51 <Cale> if you write in a file, say
08:20:56 <Cale> f :: Integer -> Integer -> Integer
08:20:59 <Cale> f x y = x + y
08:21:04 <Cale> it will accept the code
08:21:11 <Cale> and f will have that type
08:21:22 <Cale> You might wonder why there are two ->'s
08:21:29 <matthiasgorgens> (perfwill, the a -> a -> a version is just more general.  the Integer -> Integer -> Integer is easier to understand, first.)
08:21:54 <okxhol> matthiasgorgens, except for someone with a background in maths
08:22:13 <matthiasgorgens> okxhol: why?
08:22:25 <matthiasgorgens> okxhol: with a background in math you'll be apalled at the Num typeclass.
08:22:43 <matthiasgorgens> okxhol: and'll wish for Groups, Rings and Fields.
08:23:05 <Cale> perfwill: The reason is that every function in Haskell secretly takes exactly one parameter
08:23:18 <perfwill> oh
08:23:27 <okxhol> in maths + is a law for abelian group, not for integer :)
08:23:34 <Cale> perfwill: If you write a function with more parameters, then you are really writing a function which takes the first parameter, and produces another function.
08:23:43 <Cale> When you write a type like:
08:23:46 <Cale> A -> B -> C -> D
08:23:53 <Cale> the -> associates to the right, so that means
08:23:59 <Cale> A -> (B -> (C -> D))
08:24:03 <Cale> and when you write
08:24:03 <matthiasgorgens> okxhol: yeah, but (+) is not in Abel but in Num.  and that's worse than just restricting it to Integer. :o)
08:24:04 <Cale> f x y z
08:24:12 <Cale> the function application associates to the left, so that means
08:24:16 <Cale> ((f x) y) z
08:24:22 <perfwill> let me think...
08:24:25 <perfwill> thanks a lot guys
08:24:52 <okxhol> matthiasgorgens, yes, but the mathematician, understand that Num is a structure
08:25:00 <Cale> Initially, you can just think of A -> B -> C -> D as meaning "A function of three parameters A, B, C, which produces a D"
08:25:13 <matthiasgorgens> okxhol: I'm a mathematician. :o)
08:25:22 <Cale> but it's equally valid to think of it as a function which takes two parameters A,B and produces a function C -> D
08:25:30 <matthiasgorgens> and I understand that Num was chosen for pragmatic reasons.
08:25:45 <Cale> or as a function which takes one parameter of type A and produces a function (B -> C -> D)
08:25:48 <matthiasgorgens> Cale: thanks for putting in the hard work while we geek out.
08:25:52 <perfwill> so how is a "=>" different from a "->"?
08:26:01 <matthiasgorgens> perfwill: completely different.
08:26:08 <Cale> well...
08:26:13 <matthiasgorgens> it's probably not a good coincidence that they look kind of similar.
08:26:18 <Cale> It's not entirely unrelated!
08:26:27 <matthiasgorgens> Cale: yeah.
08:26:30 <luite> acutally the thing before => becomes a sort of implicit parameter
08:26:42 <Cale> But yeah, the thing before the => is a type class constraint
08:26:49 <Cale> If you haven't been introduced to type classes yet...
08:26:57 <Cale> Consider something like a function sort
08:27:10 <matthiasgorgens> :t sort
08:27:11 <lambdabot> forall a. (Ord a) => [a] -> [a]
08:27:12 <Cale> whose job it is to sort a list, giving another list
08:27:18 <kamekura> I guess you have to understand monomorphic type signatures, then fully polymorphic, then signatures with constraints
08:27:36 <Cale> Obviously, it would be annoying if we needed to write sorting algorithms separately for each type of data
08:27:42 <Cale> right?
08:27:46 <perfwill> yeah
08:28:02 <Cale> But if you want to use a type variable to express that sort works on many types, you might initially write something like:
08:28:05 <Cale> sort :: [a] -> [a]
08:28:12 <Cale> but this doesn't quite work either
08:28:23 <Cale> because not all types have < comparison
08:28:43 <matthiasgorgens> e.g. it's hard to compare functions.
08:28:46 <Cale> So we need a way to say that 'a' isn't just any type
08:29:17 <Cale> and that's the job of type classes, to restrict the types over which type variables range
08:29:28 <Cale> So as you've already seen, we get
08:29:29 <perfwill> so the "a" in this signature f :: Num a => a -> a -> a
08:29:35 <perfwill> actually refers to a type
08:29:36 <Cale> sort :: (Ord a) => [a] -> [a]
08:29:40 <perfwill> instead of a param?
08:29:42 <perfwill> right?
08:29:46 <Cale> which means that a must be an Ord-ered type
08:29:48 <rwbarton> right
08:29:53 <rwbarton> for example, a could be the type Integer
08:30:05 <Cale> yes, a is a type, an arbitrary type which belongs to the type class Num
08:30:13 <perfwill> ok
08:30:17 <perfwill> it's much clearer
08:30:18 <perfwill> :D
08:30:23 <perfwill> thanks Cale
08:30:25 <Cale> Num itself defines the basic operations on numbers (and a few non-basic ones...)
08:30:52 <Cale> Let's start with Eq, since it's probably the simplest example to begin with:
08:30:55 <Cale> class Eq a where
08:31:02 <Cale>   (==) :: a -> a -> Bool
08:31:08 <Cale>   (/=) :: a -> a -> Bool
08:31:18 <Cale>   x /= y = not (x == y)
08:31:29 <Cale>   x == y = not (x /= y)
08:31:48 <Cale> this defines two operations (==) and (/=), which take two parameters, and produce a Bool result
08:32:13 <Cale> and also provides default definitions for == and /= in terms of each other, so you only need to implement one of the two
08:32:23 <Cale> (if you implement neither, you'll get an infinite loop)
08:32:43 <matthiasgorgens> and that is bad.
08:33:07 <Cale> perfwill: and then types become instances of this class using instance declarations, inside which the actual implementation of (==) or (/=) or both is provided
08:33:14 <Cale> instance Eq MyType where
08:33:24 <Cale>   x == y = .... something to decide if they're equal ...
08:33:31 <perfwill> so basically
08:33:38 <perfwill> you talking about
08:33:45 <perfwill> the type a
08:33:54 <perfwill> must be an instance of Number
08:33:59 <perfwill> or something like
08:34:05 <perfwill> a derivative of it
08:34:05 * hackagebot multiarg 0.6.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.6.0.0 (OmariNorman)
08:34:07 <perfwill> ?
08:34:22 <Cale> yes, it has to have an instance of this typeclass Num
08:34:25 <Saizan> http://www.haskell.org/pipermail/glasgow-haskell-users/2012-February/021939.html <- does anyone know how to fix this error? or been succesful at installing a 32bit ghc on 64bit linux?
08:34:30 <perfwill> I'm familiar with OOP, so it's familiar tome
08:34:31 <Cale> class Num a where
08:34:31 <kartoffelbrei> kinda, but don't mix it up with OOPs class instances
08:34:36 <xrchz> can ghc move a file atomically if the source is in tmpfs and the target is on the hard disk? using System.Directory.renameFile causes a runtime error
08:34:47 <perfwill> I'll learn more about it
08:34:49 <Cale> well, our 'class' is more like Java's 'interface' if you want to make a comparison
08:34:51 <xrchz> unsupported operation: Invalid cross device link
08:34:57 <perfwill> yeah
08:34:58 <Cale> But typeclasses are very powerful
08:35:05 <perfwill> i'm also familiar with interfaces
08:35:08 <Cale> They let you do some things you may not expect
08:35:10 <Cale> for example
08:35:13 <Cale> class Read a where
08:35:20 <geekosaur> xrchz, can you explain how you think an atomic move across filesystems is supposed to work?
08:35:21 <Cale>   read :: String -> a
08:35:38 <xrchz> ok what about if I give up on 'atomic'?
08:35:39 <geekosaur> because the concept is rather contradictory and most OSes don't even try
08:35:39 <pnielsen> perfwill: it's easier to think about if you think of types as implementing interfaces (by making a type an instance of a class) than looking at the name "class"
08:35:41 <Cale> (that's not the actual definition of the Read class, it's a bit of an oversimplification)
08:36:03 <Cale> perfwill: This will let us parse strings based on which type is *demanded* of the result
08:36:11 <Cale> > read "56" :: Integer
08:36:12 <lambdabot>   56
08:36:16 <Cale> > read "56" :: Double
08:36:17 <lambdabot>   56.0
08:36:21 <Cale> > read "56" :: Complex Double
08:36:22 <lambdabot>   *Exception: Prelude.read: no parse
08:36:26 <Cale> heh
08:36:31 <Cale> > read "56 :+ 5" :: Complex Double
08:36:32 <lambdabot>   56.0 :+ 5.0
08:36:41 <Cale> > read "[1,2,3]" :: [Integer]
08:36:41 <xrchz> geekosaur: basically, is there some analog of renameFile that will just move the file?
08:36:42 <lambdabot>   [1,2,3]
08:36:45 <Lajjla> > read "56" :: []
08:36:46 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
08:36:53 <Lajjla> Oh
08:37:02 <Lajjla> > read "56" :: [Int]
08:37:03 <lambdabot>   *Exception: Prelude.read: no parse
08:37:12 <perfwill> yeah
08:37:14 <perfwill> it's ok, i haven't digged into it yet, I'm just wondering about the fucking syntax of function signatures :D
08:37:20 <Cale> perfwill: okay
08:37:23 <perfwill> about type classes
08:37:26 <Cale> So yeah, there's a class
08:37:29 <Cale> class Num a where
08:37:32 <perfwill> i thinkit wouldnot be hard to me
08:37:32 <perfwill> :d
08:37:33 <Cale>   (+) :: a -> a -> a
08:37:38 <Cale>   (*) :: a -> a -> a
08:37:44 <Cale>   fromInteger :: Integer -> a
08:37:53 <Cale>   negate :: a -> a
08:37:58 <Cale>   ... some other stuff ...
08:38:06 <perfwill> So basically "f :: Num a => a -> a -> a"
08:38:07 <perfwill> means
08:38:12 <perfwill> a function f
08:38:19 <perfwill> that takes two params
08:38:33 <perfwill> of type a of type Num
08:38:40 <perfwill> and returns a param of type a
08:38:43 <perfwill> right?
08:38:44 <perfwill> :D
08:38:46 <Morgawr> do you guys think this could be a bug/problem in gtk2hs? For buttons you have the signal "buttonActivated" but for entries you have "entryActivate" (see: no final 'd'). Isn't this an inconsistency?
08:38:48 <geekosaur> the platform doesn't have one aside from the aspects used by cabal-install, I'm afraid; easiest solution is probably shell out to the native file move command.
08:38:49 <Cale> yeah, though Num itself isn't a type
08:39:01 <perfwill> yeah
08:39:05 <perfwill> interface maybe
08:39:06 <perfwill> :D
08:39:19 <Cale> and note how this lets us say that the types have to match
08:39:26 <perfwill> thanks a lot for the help
08:39:39 <Cale> If (this is not valid syntax) it was  f :: Num -> Num -> Num
08:39:56 <perfwill> yeah
08:39:57 <perfwill> :D
08:40:06 <Cale> then you wouldn't know if the parameters' types matched or the result matched the types of the parameters or what
08:40:24 <bookerz> So, say I've got a function sumOfSqs and for some reason want use a memoized version the squaring function (sq :: Int -> State Cache Int).
08:40:29 <bookerz> How do I preserve the state over all calls to sq while leaving sumOfSqs :: [Int] -> Int?
08:40:52 <Quantumplation> is there any way to take the default implementation of deriving Show and then override one particular constructor?
08:42:12 <Quantumplation> i.e. i have data Building = Refinery | Shipyard | Jumpgate{ conduit :: Conduit }, and I want Refinery and Shipyard to still use the default show behavior, but provide custom implementation for Jumpgate.
08:42:17 <Cale> bookerz: what is this Cache type?  Basically, you need to be a bit clever about how you're defining the function sumOfSqs so that the cache is outside of the lambda which takes the list parameter
08:42:23 <allsystemsarego> bookerz, maybe by using an accumulator
08:42:36 <Cale> oh
08:42:39 <bford> can anyone have a quick look at some arrows code for me? I'm writing an FRP module for fay, but I can evaluate what I think I should be able to in ghci: https://github.com/boothead/fay-frp/blob/master/Tests.hs
08:42:56 <Cale> er, you mean you just want to preserve the calls to sq inside a single call to sumOfSqs?
08:43:04 <bford> frp library is here: https://github.com/boothead/fay-frp/blob/master/Language/Fay/FRP.hs
08:43:31 <bookerz> Cale: nod
08:43:49 <bookerz> Cale: It's ok if sumOfSqs initializes sq's state
08:43:49 <Cale> bookerz: Okay, well, it would help if I knew what Cache was
08:44:02 <bookerz> Cale: I've been playing with Map Int Int
08:44:07 <Cale> ah, right
08:44:34 <Cale> So you'd write  sumOfSqs = runState sumOfSqs' (Map.empty)
08:44:46 <Cale> err
08:44:53 <Cale> So you'd write  sumOfSqs xs = runState (sumOfSqs' xs) (Map.empty)
08:45:01 <bookerz> allsystemsarego: certainly an accumulator would get the job done, but this is also an opportunity for me to learn how to use the State monad
08:45:21 <ceii> don't you just want sumOfSqs ns = evalState (mapM sq ns) emptyCache
08:45:24 <ceii> ?
08:46:22 <bookerz> so all the calls to sq need to live in the State monad, too
08:46:50 <bookerz> that makes sense
08:47:48 <bookerz> I think I can run with that -- thanks!
08:48:08 <ceii> you're welcome
08:48:15 <Cale> sq' x = do ms <- gets (lookup x); case ms of Nothing -> (let y = sq x in do modify (insert x y); return x);  Just y -> return y
08:48:36 <Cale> sumOfSqs' [] = return []
08:48:53 <Cale> actually, no
08:49:01 <frerich__> Hi, a while ago somebody mentioned a github link to the sources which were used to generate the nice HTML version of RWH visible at http://book.realworldhaskell.org/read/ - does anybody happen to have that link?
08:49:17 <Cale> sumOfSqs' xs = fmap sum . mapM sq' $ xs
08:49:47 <Cale> (btw, I have a hard time believing that this is going to be more efficient than just doing this naively)
08:50:01 <Cale> (but only because squaring is such a fast operation generally)
08:50:18 <bookerz> nod -- it's not really squaring that I'm trying to cache... but sumOfSqs and sq is something that's easy to communicate
08:50:48 <bookerz> So then sumOfSqs' :: [Int] -> State (Map Int Int) Int
08:50:59 <bookerz> And I just need to evalState the value out of it
08:51:31 <bookerz> sumOfSqs x = evalState (sumOfSqs' x) Map.empty
08:51:59 <frerich__> For the record: I found the sources to RWH on bos' github account at https://github.com/bos/rwh
08:59:54 <noviceprogrammer> hello
09:00:52 <Eduard_Munteanu> noviceprogrammer: hi
09:14:06 * hackagebot tamarin-prover 0.8.2.1 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.8.2.1 (SimonMeier)
09:14:08 * hackagebot direct-sqlite 2.1 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.1 (IreneKnapp)
09:14:34 <kamekura> hi. I unpacked a package with 'cabal unpack'. how can I test  it back after having edited it? I mean, either a command to pack it then run cabal install, or something else
09:15:56 <rwbarton> you can 'cabal install' (no package name required) from the directory with the .cabal file
09:16:12 <rwbarton> or 'cabal build' if you don't want to install it yet
09:16:15 <alpounet> or just "cabal configure && cabal build" if you want to check the package builds fine without installing
09:16:18 <bitonic> remind me:  why can't I put a class constraint to the LHS of a `=>' with a variable what is not on the `rhs'?  e.g. `class Foo a b => Class a'.  this would be useful especially if `class Foo a b | a -> b', so I know what `b' is, and I don't have to add another parameter to `Class'
09:16:33 <kamekura> thanks!
09:17:09 <kamekura> I'm too impatient, typed 'cabal install' before seeing your 2nd comment...
09:17:18 <rwbarton> i worried about that :P
09:17:31 <kamekura> but it's ok, the build will probably fail anyway
09:17:54 <kamekura> its wx by the way
09:18:02 <rwbarton> ah yeah, safe bet then :)
09:18:18 <kamekura> wx-0.13.2.1 seems to be broken
09:18:52 <rwbarton> I heard some advice to increment the version number in the .cabal file so cabal doesn't get your modified version confused with the real one but I don't know whether that is important
09:19:16 <kamekura> it's not installed currently
09:20:31 <alpounet> bitonic, maybe the fact that b is determined by a isn't propagated to Class?
09:21:02 <benmachine> bitonic: I thought you could if you had FlexibleContexts on?
09:21:10 <rwbarton> does it really not work when you have the functional dependency?
09:21:13 <bitonic> alpounet: what do you mean with "propagated"?  you get a simple scoping error if you try to do what I described: `Not in scope: type variable `sym''
09:21:22 <alpounet> sym being 'b' ?
09:21:41 <bitonic> rwbarton: I have `class ListLike full sym => Search container full algo | container -> full , container -> algo where'.  `full -> sym', and it doesn't work
09:22:26 <bitonic> oh.
09:22:29 <bitonic> right, flexiblecontexts.
09:22:41 <bitonic> still doesn't work
09:23:42 <rwbarton> I don't really understand why but I can't say I'm totally surprised. You wouldn't have this problem with associated types thouguh
09:23:57 <bitonic> rwbarton: you mean with type families?
09:24:00 <rwbarton> yes
09:24:14 <bitonic> true.  but I can't change `ListLike'.
09:24:17 <rwbarton> oh
09:25:30 <Sculptor> hi!
09:25:53 <bitonic> this is weird, and annoying
09:25:53 <rwbarton> I suppose you have to add sym as a parameter to Search then. pretty ugly
09:26:01 <bitonic> rwbarton: that's what I have now, yes
09:26:18 <Sculptor> just trying to be friendly, bitonic
09:26:30 <bitonic> Sculptor: hi Sculptor ^_^
09:26:35 <shapr> hi Sculptor !
09:26:39 <Sculptor> !
09:26:46 <bitonic> you're not weird/annoying.  GHC is.
09:26:46 <shapr> Sculptor: Are you learning Haskell?
09:27:01 <Sculptor> i'm procrastinating my way into it, yeah
09:27:28 <bitonic> story of my life
09:27:41 <Sculptor> i'm using learnyouhaskell.com atm
09:29:07 * hackagebot direct-sqlite 2.2 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.2 (IreneKnapp)
09:29:13 <dada-cetacean> could anybody familiar with the differences between Learn You A Haskell and Real World Haskell elucidate the differences between the two books?
09:30:06 <geekosaur> LYAH is about lenring Haskell; RWH is about making what you've learned practical
09:30:15 <geekosaur> learning, even
09:30:25 * geekosaur looks at fingers suspiciously
09:31:49 <Sculptor> geekosaur, and RWH is
09:33:01 <geekosaur> sorry, are you asking about the abbreviation?  the question was about (L)earn (Y)ou (A) (H)askell and (R)eal (W)orld (H)askell
09:34:24 <Sculptor> i knew what LYAH was
09:34:25 <Sculptor> thanks
09:42:56 <bitonic> rwbarton: <http://article.gmane.org/gmane.comp.lang.haskell.cafe/100692> I suspect that the reason is simply that there is no syntax to refer to things on the RHS of the => in a class declaration
09:43:00 <bitonic> so it's uselesse
09:44:07 * hackagebot citeproc-hs 0.3.5 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.5 (AndreaRossato)
09:44:27 <Morgawr> where can I find liftIO? hoogle says it's in Network.CGI, is this correct or should I import a different module?
09:44:53 <bitonic> Morgawr: Control.Monad.Trans
09:44:58 <bitonic> @hoogle liftIO
09:44:59 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
09:44:59 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
09:44:59 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
09:45:10 <bitonic> well.  maybe that second one.
09:45:22 <Morgawr> are those the same?
09:46:01 <bitonic> Morgawr: no I was wrong, it's in the second one
09:46:10 <bitonic> <http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/doc-index.html>
09:46:37 <bitonic> ah, no, Control.Monad.Trans too
09:46:42 <bitonic> <http://hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/Control-Monad-Trans.html>
09:46:58 <bitonic> it's the wonderful transformers-mtl namespace universe
09:47:01 <Morgawr> yes but I know it works with Network.CGI as well, are those the same?
09:47:11 <bitonic> Morgawr: I don't know
09:47:44 <rwbarton> presumably
09:47:51 <bitonic> yeah, just checked
09:48:03 <rwbarton> if you import both and don't get an "ambiguous name" error or whatever then they are the same
09:59:07 * hackagebot arbtt 0.6.4 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.6.4 (JoachimBreitner)
10:04:10 * hackagebot sqlite-simple 0.2.0.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.2.0.0 (JanneHellsten)
10:11:00 <kamekura> rwbarton, wx built!
10:11:58 <kamekura> it was missing some constraints for wx-core
10:14:08 * hackagebot bindings-DSL 1.0.16 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.16 (MauricioAntunes)
10:39:37 <Morgawr> hey guys, since I couldn't find any gtk2hs tutorial about handling signals the correct way (Aka not-deprecated), I wrote this small article/tutorial myself http://morgawr.not-a-number.net/2012/09/28/haskell-with-gtk2hs-introduction-to-handling-events/ feel free to comment if you see something wrong with it :D (I'm far from good with Haskell myself)
10:41:06 <KirinDave> c_wraith: Hey, do you mind terribly if I blog briefly about your fizzbuzz example and the conversation we had?
10:41:43 <c_wraith> go ahead.  Just be kind about how much of a jerk I can be. :)
10:41:55 <KirinDave> No no.
10:42:07 <KirinDave> My initial reaction due to the confusion over MonadComprehension syntax is what I want to talk about.
10:42:11 <c_wraith> ah
10:42:48 <ClaudiusMaximus> Morgawr: looks good to me :)   is there a non-deprecated version of onDestroy too for quitting, is my only question?
10:42:58 <KirinDave> c_wraith: I'll probably break down the types and explain why it works, too.
10:43:22 <Morgawr> ClaudiusMaximus: you know, I was thinking about it right after I published that. I have no idea, I will look into it
10:43:25 <ClaudiusMaximus> Morgawr: or maybe onDestroy isn't deprecated, it's all a bit complicated, that gtk2hs stuff
10:43:26 <KirinDave> c_wraith: Because you're right, it's a very good example of a simple problem that is useful for judging your mastery of basic concepts.
10:43:47 <geekosaur> ClaudiusMaximus, afaik what's deprecated is onXXX vs. `on` XXX
10:44:25 <geekosaur> that is, they now use the same signal data that is used elsewhere in gtk+ instead of being distinct
10:44:27 <pnielsen> KirinDave: please link when done. Sounds interesting.
10:45:21 <Cale> KirinDave, c_wraith: which implementation was this?
10:46:04 <c_wraith> Cale: I used MonadComprehensions with the Maybe monad, and the Maybe monoid to combine things
10:46:49 <c_wraith> main = mapM putStrLn [ fromMaybe (show x) $ mappend ["fizz" | x `rem` 3 == 0] ["buzz" | x `rem` 5 == 0] | x <- [1..100] ] -- possible typos present here
10:50:35 <bitonic> c_wraith: I think you're missing a bracket
10:50:53 <bitonic> ah no.  the $.
10:51:32 <c_wraith> I make no guarantees I didn't retype it wrong :)
10:52:02 <bitonic> nah I just put it in.  it just looks weird because I'm not used to the generalised comprehensions
10:52:09 <bitonic> I should get used to them maybe
10:55:43 <KirinDave> Btw, offhand
10:55:48 <KirinDave> Is there a cleaner way to do thsi in args processing?
10:55:49 <KirinDave>   upTo <- fmap (fromMaybe 100 . fmap read . listToMaybe) getArgs
10:55:52 <KirinDave> I mean, I can read it fine
10:55:59 <KirinDave> Just curious if I am missing a convenience function.
10:57:00 <c_wraith> not that I can think of offhand.  Though you might find it easier to read using <$> instead of the first fmap
11:02:17 <jfischoff> I just realized something rather elementary in retrospect. If you have write f . g $ x instead of f $ g x, and g is a class functions, you can get better type inference with the first.
11:02:47 <jfischoff> for instance f . universeBi $ x will type check but f $ universeBi x will not
11:03:01 <jfischoff> assuming f has concrete types
11:03:41 <DrPete> $ does not type check? i thought it was just application with a different precedence
11:03:51 <byorgey> jfischoff: hmm, why is that?
11:04:23 <jfischoff> so universeBi is a -> [b]
11:04:27 <jfischoff> and I guess
11:04:40 <jfischoff> its doesn't know the what the b is in the second
11:04:46 <jfischoff> but it does in the first
11:04:53 <Cale> uhhh
11:05:19 <sm> any OS X Lion users, would appreciate if you could smoke-test new hledger[-web] mac binaries at http://hledger.org/DOWNLOAD.html
11:05:21 <Cale> @hoogle universeBi
11:05:21 <lambdabot> No results found
11:05:31 <Cale> where is that? Is that a Biplate thing?
11:05:35 <jfischoff> yeah
11:05:44 <jfischoff> you would think neil would have indexed it
11:06:37 <Cale> ah, is biplate even on hackage?
11:06:44 <Cale> there's multiplate
11:06:47 <jfischoff> it in uniplate
11:07:00 <jfischoff> http://hackage.haskell.org/packages/archive/uniplate/1.6.7/doc/html/Data-Generics-Biplate.html
11:07:01 <Cale> Oh, right
11:07:34 <kamekura> KirinDAave, perhaps 'maybe 100 read' instead?
11:07:37 <rwbarton> I still don't understand how what you are saying could ever happen
11:07:59 <jfischoff> I'm gathering from the reaction that what I described is not expected behavior
11:08:13 <rwbarton> unless there is some higher-rank polymorphism going on, then it is possibly expected
11:08:13 <Cale> jfischoff: I'm really interested, if it is happening for a good reason
11:08:24 <rwbarton> but it doesn't sound like there is
11:08:35 <jfischoff> I've RankNTypes turned on
11:08:37 <Cale> jfischoff: I've run into a rare case where f $ g x will work but f . g $ x won't
11:08:43 <Cale> but the other way around is interesting
11:09:04 <rwbarton> Cale: involving higher-rank polymorphism?
11:09:13 <kamekura> KirinDave: perhaps 'maybe 100 read' instead?
11:09:47 <Cale> rwbarton: yeah, there's that, and then I've also had it turn up in the presence of GADTs, probably equivalently.
11:10:13 <Cale> (I'm not sure about exactly why)
11:10:35 <rwbarton> neither do I but it sounds vaguely plausible :)
11:12:15 <kamekura> .
11:13:03 <ClaudiusMaximus> hugs dislikes runST $ do ...   but ghc accepts it, fwiw
11:13:36 <geekosaur> ghc has a specific hack for the runST case, I think?  or did in earlier versions
11:14:17 <noviceprogrammer> hello
11:14:23 <ClaudiusMaximus> i recall vaguelly something along those lines, but in code i wanted to be portable the runST (do ....  \n  )  wasn't too much of a burden, just boring to change
11:14:24 <noviceprogrammer> how would you use Qt under Haskell?
11:19:10 * hackagebot snaplet-sqlite-simple 0.2.0 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.2.0 (JanneHellsten)
11:20:06 <kamekura> noviceprogammer: you can find hsqml for QtQuick on hackage
11:20:14 <mysticc> Whats difference between runghc and runhaskell
11:20:33 <kamekura> I think there's another qt package but not on hackage
11:20:42 <rwbarton> runhaskell is most likely a symlink to runghc
11:20:47 <DrPete> lrwxrwxrwx 1 root root 6 Jun  6 05:03 /usr/bin/runhaskell -> runghc
11:20:51 <rwbarton> unless possibly you have another haskell interpreter installed
11:22:49 <mysticc> thanks
11:36:16 <jfischoff> ah it made no difference between f . g $ x and f $ g x once I fixed the other type errors in the file.
11:36:51 <jfischoff> They both work once the file could completely compile, but have when there were a bunch of error only the first worked
11:37:25 <shachaf> > let x = return 5 in id . runST $ x
11:37:26 <lambdabot>   Cannot match a monotype with `forall s. GHC.ST.ST s a'
11:37:27 <shachaf> > let x = return 5 in id $ runST x
11:37:28 <lambdabot>   5
12:04:11 * hackagebot happstack-server 7.0.6 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.0.6 (JeremyShaw)
12:12:21 <fho> Quick question: is "followedBy a b = a >>= \x -> a >> return x" or something similiar implemented in the Parsec library? I can't find it ...
12:13:23 <atriq> Do you mean "a >>= \x -> a >> b >> return x"?
12:13:35 <atriq> I don't think so, it would be useful, though
12:14:19 <shachaf> I suspect fho means
12:14:31 <shachaf> @ty let foo a = a >>= \x -> b >> return x
12:14:32 <lambdabot> <no location info>:
12:14:32 <lambdabot>     not an expression: `let foo a = a >>= \x -> b >> return x'
12:14:33 <shachaf> @ty let foo a = a >>= \x -> b >> return x in foo
12:14:34 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
12:14:34 <lambdabot>     In the first argument of `(>>)', namely `b'
12:14:34 <lambdabot>     In the expression: b >> return x
12:14:41 * shachaf sighs.
12:14:46 <shachaf> @ty let foo a b = a >>= \x -> b >> return x in foo
12:14:47 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> m a1 -> m a
12:14:56 <shachaf> @ty (<*)
12:14:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:14:58 <atriq> Ah, yes
12:15:05 <atriq> Hmm
12:15:11 <shachaf> fho: That.
12:15:15 <atriq> @hoogle (<*)
12:15:15 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
12:15:15 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:15:15 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:15:34 <fho> is was thinking about a combinator that lets me define something like: node `followedBy` spaces ... to deal with whitespace after something important
12:16:09 <fho> <* it is?
12:16:13 <atriq> node <* spaces
12:16:21 <shachaf> Hoogle would even tell you about it.
12:17:07 <ParahSa1lin> @hoogle (>.<)
12:17:07 <lambdabot> No results found
12:17:15 <ParahSa1lin> @hoogle (>.>)
12:17:15 <lambdabot> No results found
12:17:17 <fho> atriq: shachaf: thanks ... is was just looking in the Parsec documentation
12:17:30 <atriq> Yeah, I've been looking for the same
12:17:34 <atriq> I wish I saw that
12:19:11 * hackagebot happstack-server 7.0.7 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.0.7 (JeremyShaw)
12:20:21 <stepcut> wow, what a crappy description for happstack-server
12:20:23 <fho> would be easier if it would be reexported as followedBy ;)
12:20:26 <stepcut> someone should fix that
12:23:03 <bitonic> now that I have `monad-shuffle', is there a package to pick n elements out of a list at random?
12:36:06 <t7> is there a name for   S n + m ‚â° n + S m   ?
12:39:12 * hackagebot ghc-dup 0.1 - Explicitly prevent sharing  http://hackage.haskell.org/package/ghc-dup-0.1 (JoachimBreitner)
12:41:01 <bitonic> t7: I think you meant to say that in #agda
12:41:11 <t7> yes i did sorry all
12:42:20 * bitonic has neglected agda recently
12:42:27 * copumpkin slaps bitonic 
12:42:33 <bitonic> ehe
12:43:21 <ski> t7 : .. perhaps you could call it `S+' (and `Z+' would then be the proof of `Z + m = m')
12:47:53 <imu96> hello
12:48:29 <imu96> i was just wondering if someone could tell me what the differences between haskell and scala are and what you would use them for that you would not use the other for
12:48:38 <bigfg> hello, i'm wondering if there's any library that deals with geometric data? i'm trying to avoid coding something twice
12:49:01 <stew> imu96: you would use scala when you are stuck on the JVM and haskell otherwise
12:49:14 <copumpkin> imu96: haskell has a well thought-out type system, scala's is pretty ad-hoc
12:49:26 <copumpkin> imu96: but yeah, what stew said
12:49:37 <ClaudiusMaximus> bigfg: try 'diagrams' perhaps, but "geometric data" is somewhat vague
12:49:42 <imu96> stew: so i would use haskell if i wanted to make an app for say, android, and haskell for everything else?
12:49:42 <bitonic> what's wrong about the JVM?
12:50:06 <bigfg> ClaudiusMaximus, for example, vertex in 2d
12:50:12 <ClaudiusMaximus> bigfg: you can use the core libraries without having to install the libs to visualizing anything, probably
12:50:23 <imu96> i also went to the haskell website to see when i would use an imperative language vs a functional language
12:50:34 <byorgey> I doubt the diagrams core libraries would really be all that useful for simply working with geometric data.
12:50:38 <imu96> i'm afraid i do not understand when i would use 1 over the other
12:50:42 <byorgey> bigfg: what do you want to do with this data?
12:50:47 <bigfg> really i just need to do some basic computational geometry
12:50:57 <stew> bitonic: a lack of pure functions and a lack of TCO
12:50:58 <bigfg> though could be interesting to do it in haskell
12:51:22 <bitonic> stew: a lack of pure functions?  the TCO thing is annoying, yes, but it's still a great platform
12:51:34 <imu96> when would i use go and when would i use haskell for example?
12:51:58 <byorgey> bigfg: there are lots of packages on Hackage for doing low-dimensional linear algebra
12:52:13 <byorgey> bigfg: just go on hackage.haskell.org/ and search for "linear algebra"
12:52:45 <bigfg> i'm more interested in working closer to a geometry visualization library than to a linear algebra library
12:53:16 <stew> bitonic: i don't mean pure, but functions at all.  on the jvm you cannot have a function that isn't attached to a a class.  when you create a function in scala it gets compiled to an anonymous object with an apply method
12:53:17 <bigfg> and really for what i need to do now i could just refactor everything at some other point, but maybe i can save up a lot of work straight from the start
12:53:33 <byorgey> bigfg: what exactly do you want to compute/visualize?
12:53:37 <bigfg> ie, i was checking the raw openGL bindings but there is no geometric data there
12:54:03 <bigfg> (at least i couldn't see any pure data being manipulated... a lot of IO of course when you're pushing data to the GPU...)
12:54:15 <bitonic> stew: that doesn't prevent you from building a pure language on top of it
12:54:38 <bitonic> I mean criticising Scala because of the JVM seems a bit silly
12:54:50 <bitonic> scala doesn't even want to be pure anyway
12:54:51 <stew> bitonic: sure
12:54:51 <bigfg> i want to work from trapezoidal and other type of geometrical decompositions and use that for an application
12:55:44 <bigfg> i need to visualize the total and partial stuff i make, opengl is good for that, i only need to visualize two dimensional stuff
12:56:58 <byorgey> bigfg: hmm, well, you might actually find diagrams interesting then
12:57:02 <byorgey> @where diagrams
12:57:02 <lambdabot> http://projects.haskell.org/diagrams/
12:57:22 <bigfg> wow, this looks pretty awesome :)
12:57:29 <byorgey> =)
12:58:31 <nand`> is there an implementation of law-conforming join on ZipLists anywhere?
13:05:08 <jfischoff> So I have a closed universe of types a,b,c and functions a -> b, b -> c. What I would like provide this information to the compiler in someway so I can convert the from a -> c without explaining how. Barring TH is there a way I can achieve this?
13:05:57 <Nisstyre> jfischoff: can you re-type that in English?
13:06:56 <jfischoff> s /What I would/ What I would to do
13:07:32 <sclv_> oh man the new generics are *hard* to work with
13:07:40 <sclv_> i thought syb was bad.
13:07:40 <sclv_> nope
13:08:01 <sclv_> they're sort of cool, but they expose so much freaking structure
13:08:43 <jfischoff> sclv_: I found the aseon generics code helpful
13:09:00 <sclv_> like an Int turns into M1 D D_Int (M1 C C_Int (M1 S NoSelector (K1 R Int))
13:09:16 <byorgey> nand`: no, it is impossible
13:09:25 <byorgey> nand`: it can be done only for infinite ZipLists
13:09:55 <sclv_> and a string becomes M1 D D1[] (M1 C C1_0[] U1 :+: M1 C C1_1[] (M1 S NoSelector (K1 P Char) :*: M1 S NoSelector (K1 R [Char])))
13:09:59 <sclv_> which is like whUT
13:10:07 <byorgey> haha wat
13:10:16 <sclv_> that's the Rep of a string in GHC.Generics
13:10:27 <Nisstyre> damn
13:10:36 <jfischoff> I try not to look at those
13:10:51 <sclv_> i was hoping to go lighter weight than just grabbing aeson's generic code and repurposing it
13:11:00 <sclv_> but its pretty rough going
13:11:10 <nand`> byorgey: you sure? I always thought it was possible
13:11:24 <sclv_> I basically think we need a library of combinators over reps that package up common recursion patterns.
13:11:33 <nand`> if you take the diagonal of the largest square subsection (rather than the largest possible diagonal)
13:11:48 <rwbarton> I heard it was possible and believed it for a while but then quickcheck found a counterexample
13:11:57 <sclv_> but I'll need to get a handle on more stuff about how they actually work first
13:12:09 <nand`> shame
13:12:11 <rwbarton> at least, to the thing you mentioned
13:12:45 <nand`> ah fine, I'll write a non-join operator of type [[a]] -> [a] to just pick out the diagonal then
13:13:02 <jfischoff> sclv_: Oh I don't know if aeson's code will be that helpful.
13:13:46 <sclv_> has any library but aeson done anything real with the new generics code?
13:13:48 <byorgey> nand`: I always forget what it is that breaks
13:13:57 <byorgey> but it does have to do with the lengths of the lists.
13:14:02 <sclv_> i remember it was years before syb got any real uptake
13:14:24 <sclv_> same path for this i imagine -- a few intrepid souls figure out the right patterns and then eveyone else sort of follows their lead
13:14:42 <swarley> I read LYAHFAGG a while ago, anything more suited to someone who's had experience in procedural/oo programming experience?
13:14:44 <jfischoff> sclv_: there is the generic deepseq
13:14:50 <sclv_> like aeson's syb descends from jsons which was done orig by lennart ages ago
13:14:51 <bgamari> anyone have any hints on how to debug infinite blocking on an MVar?
13:15:09 <swarley> its been a long time since i've used haskell and i'm looking to take it for another whirl
13:15:25 <byorgey> swarley: what are you looking to do with Haskell?
13:15:35 <bgamari> I can't seem to get -xc to point at which MVar operation is actually blocking
13:15:39 <sclv_> bgamari: don't use put and take directly on mvars. rewrite to use withMVar and other friendly things, if possible :-)
13:15:47 <byorgey> swarley: there's "Real World Haskell" if you want to do various real-worly things
13:15:53 <byorgey> *worldy
13:15:54 <swarley> I'm not sure, use as a general purpose language I would think. I'm using ruby/c regularly now a days
13:15:55 <jfischoff> sclv_: I used aeson's code to write my own, its the only code I've looked at
13:16:01 <byorgey> @where rwh
13:16:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:16:06 <sclv_> alternately insert a println before every time you block on an mvar
13:16:13 <sclv_> and just see which one is the "winner"
13:16:45 <sclv_> haha yes deepseq-generic's code is waay too simple for my needs
13:16:59 <sclv_> because you don't need to thread any information back up
13:17:02 <swarley> I deal with a lot of code with IO as well, any links with a good explanation on (and i'm thinking this is what they're called, its been a while) actions?
13:17:26 <sclv_> like 2/3 of the value of syb was that it isn't just the raw classes, but a whole bunch of generic traversal helpers and patterns
13:17:34 <sclv_> i don't see any of that infrastructure for GHC.Generics
13:17:48 <sclv_> (any grad students listening? there's def a paper in this :-))
13:18:43 <bgamari> sclv, Yeah, I think the println suggestion is probably more realistic here
13:19:05 <sclv_> i seriously haven't written a take or put mvar in years
13:19:10 <thoughtpolice> sclv_: the only other thing i can think of is cereal; it can use GHC.Generics to derive Serializable instances for you
13:19:11 <sclv_> like i just trained myself to use the "safe" subset
13:19:23 <sclv_> thoughtpolice: thanks, i'll take a look
13:19:50 <jfischoff> sclv_: the trick in the aeson's code that was helpful for me is the use of "advanced overlapping" to convert from a list of values to the final value iirc.
13:19:58 <jfischoff> huh underline
13:20:18 <sclv_> yeah ick i really don't want overlapping
13:20:37 <sclv_> i'll pay the code dup cost to avoid it
13:20:47 <bgamari> sclv, False alarm, a worker thread was crashing but the error was lost in the noise
13:23:03 <tomprince> Is there any way to use field names in record syntax, with out having to have unqualified imports, or qualifying the names?
13:24:14 * hackagebot primitive 0.5 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.5 (RomanLeshchinskiy)
13:24:34 <copumpkin> whoa, roman is alive
13:25:37 <thoughtpolice> whoa, copumpkin is coalive
13:25:46 <thoughtpolice> what's colife like, as opposed to normal life?
13:25:51 <copumpkin> bettar
13:26:27 <thoughtpolice> reversing all your arrows does sound like a nice change of pace
13:29:13 <danr> nice!
13:29:14 * hackagebot vector 0.10 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10 (RomanLeshchinskiy)
13:29:17 <danr> oops
13:29:19 <danr> mischan
13:30:58 <copumpkin> w00t, new vect0r
13:31:02 <jfischoff> roman thinks safe haskell is a joke for some reason
13:31:13 <sclv_> safe haskell is misnamed and sort of confusing
13:31:32 <jfischoff> I know very a little about it
13:31:39 <sclv_> i think it is a good idea, but i get why ppl are put off by it
13:31:40 <Cale> Why is it misnamed?
13:31:52 <sclv_> because "safe" is too overloaded already
13:32:19 <Cale> What would you call it?
13:32:32 <sclv_> like memory safe vs. crash safe vs. type safe vs. "safe" in that it does what it promises
13:32:33 <monochrom> not-unsafe :)
13:32:36 <thoughtpolice> NotUnsafeHaskell
13:32:43 <avpx> -XOverloadedWords
13:32:51 <sclv_> I like TrustyHaskell but nobody else really does
13:32:57 <sclv_> because its about introducing levels of trust into code
13:33:04 <sclv_> or TrustedHaskell
13:33:10 <sclv_> but security ppl say "trust" is too overloaded too
13:33:16 <thoughtpolice> it kind of is :P
13:33:46 <geekosaur> is it safe like not unsafePerformIO?  like not rtsopts?  like Perl/Ruby taint mode?
13:34:13 <sclv_> I also suggested ResponsibleHaskell at one point
13:34:18 <thoughtpolice> yeah, no unsafePerformIO, no template haskell, overlapping instances, etc. but it's not "safe" in the sense you cannot say, launchZeMissiles, unless you give clients some kind of restricted IO monad
13:34:50 <avpx> sclv_: I like "Trusted," but I don't see why the choice is significant.
13:35:06 <thoughtpolice> it really just seems to ban most of the questionable stuff you can use to outright break type safety, but it doesn't really ensure 'safety' like "code that deadlocks or doesn't hang your system" or whatnot. also, safe haskell feels like an extension i cannot ignore, despite it being one i don't use
13:35:07 <sclv_> just because people are like "you want me to mark this as safe, but i don't think it is safe!"
13:35:11 <thoughtpolice> and i'm not sure how i feel about that
13:35:25 <sclv_> it lets you do IO, it is not safe!
13:35:28 <sclv_> etc.
13:35:39 <sclv_> HonestHaskell, maybe :-)
13:35:44 <avpx> Sure, but will you really correct these misconceptions by changing the name?
13:35:48 <sclv_> like if you are going to do IO, IO will be in the type signature :-)
13:35:49 <geekosaur> the big problem is we've already had the rtsopts stuff introduced "for safety" and now here is Safe Haskell which is about some *different* notion of safety
13:35:50 <monochrom> does it mean you may like to say "type-safe haskell"?
13:36:04 <sclv_> except haskell is already type safe son that's confusing
13:36:10 <sclv_> erm s/son/so
13:36:24 <swarley> lol, i thought you were laying down some ghetto law there for a second
13:36:34 <sclv_> oh dear
13:39:02 <ski> sclv_ : .. except `unsafePerformIO' is not type-safe
13:39:14 * hackagebot json 0.7 - Support for serialising Haskell to and from JSON  http://hackage.haskell.org/package/json-0.7 (IavorDiatchki)
13:43:56 <nand`> is there a library that would let me define a few simple, possibly rotated/translated/scaled vector shapes (eg. polygons) and let me render them out to a [[Pixel]] ?
13:46:46 <nand`> I was thinking something like gloss would be perfect, except that gloss doesn't let me actually render a Picture out in a pure fashion, other than by displaying it
13:48:21 <ParahSa1lin> have a weird problem that would be difficult to isolate, but wondering if anyone might have initial insight
13:48:57 <ParahSa1lin> i have large text files that i do some parsing on, and then write bytestrings to handles four lines at a time
13:50:01 <ParahSa1lin> from the code it looks as if, all files should have a divisible by 4 number of lines, but the final line is always the first of the set of 4 lines
13:50:22 <ParahSa1lin> im using lazy bytestrings
13:58:55 <nand`> @pl \f x -> f (f x)
13:58:55 <lambdabot> join (.)
13:59:34 <lispy> nand`: so you want a rasterizer? You could use opengl (maybe gloss too) and render to a buffer instead of the screen and then extract the pixel values
13:59:49 <lispy> nand`: IIRC, SDL also provides this
14:00:26 <nand`> lispy: in principle, something like that, yeah. In particular, I'm looking for the ‚Äòsimplest‚Äô solution, the one where I have to write the least lines of code to get what I want
14:00:40 <nand`> ideally I just want to define the polygon and call at most half a dozen functions to get my [[Pixel]]
14:00:57 <nand`> efficiency is not a concern
14:01:09 <lispy> nand`: look at diagrams
14:01:38 <lispy> nand`: http://projects.haskell.org/diagrams/
14:01:58 <byorgey> diagrams can't currently give you a [[Pixel]]
14:02:17 <lispy> byorgey: is that a 'simple' matter of having the right backend?
14:02:27 <byorgey> yes
14:02:41 <nand`> byorgey: can it deliver a reasonable approximation that I could convert to a [[Pixel]], or perhaps operate on directly instead?
14:02:52 <byorgey> diagrams is great for defining polygons though =)
14:03:28 <byorgey> nand`: there is a cairo backend.  If you can figure out how to get from a cairo Render action to [[Pixel]], that would work
14:03:32 <byorgey> I don't know if it's possible
14:03:56 <byorgey> but of course cairo is doing that behind the scenes.
14:04:23 <byorgey> nand`: why do you want [[Pixel]] ?
14:04:33 <nand`> I also actually only revealed half the story. The reason I want a [[Pixel]] is because I'm performing some post-computation on the rasterized image(s), on a row-by-row basis. (I could, in principle, be satisfied by [Row] but I may want column-by-column later on)
14:04:49 <nand`> however, if I can instead lift this post-computational logic to diagrams or similar instead, I can skip the [[Pixel]] altogether
14:04:52 <lispy> nand`: or use a fragment shader w/opengl
14:04:59 <byorgey> right.  What kind of post-computation?
14:05:09 <lispy> (opengl negates the idea of minimal api and learning)
14:05:21 <nand`> lispy: it should fit into 50 lines at most, is the idea
14:05:29 * lispy nods
14:05:43 <nschoe> Hi here.
14:05:49 <Ralith> opengl is awesome for drawing triangles and modifying framebuffers very quickly
14:05:52 <lispy> I guess I should just say, "Oh man. There are 1001 ways to do this. It's hard to pick one :)"
14:06:08 <Ralith> I wouldn't use it for things outside that
14:06:24 <lispy> nand`: I wish you the best in this as I'm about to run away again.
14:06:26 <nand`> byorgey: I have an ‚Äòanimation‚Äô; of type Time -> Image; and I want to render this animation out for a bunch of different time values, then compose a resulting image by mixing together rows from the images obtained at different time inputs
14:07:01 <nand`> in effect, to simulate something like a ‚Äòrolling shutter‚Äô effect; where an image is modified while it's slowly read out
14:07:07 <byorgey> hehe, I see
14:07:33 <gfredericks> why should newtype be a separate thing?
14:07:35 <byorgey> I don't think you can do that easily with diagrams.
14:07:40 * gfredericks is learning him a haskell (for great good)
14:07:52 <byorgey> nand`: try gloss though.  It does have some support for bitmaps.
14:08:15 <byorgey> gfredericks: why shouldn't it?
14:08:29 <MostAwesomeDude> gfredericks: You mean, why are there both "data" and "newtype"?
14:08:35 <byorgey> gfredericks: if you want something that isn't a separate thing, we have 'type' for making type synonyms
14:08:36 <gfredericks> yes, since
14:08:40 <byorgey> ahh
14:08:54 <byorgey> you meant separate from 'data'?
14:08:59 <nand`> byorgey: I have no idea how I'd approach this problem in gloss. I can't seem to find any sort of Picture -> ...  other than the big IO functions for display/animate/play, but none of them let me compose the resulting image out of different time values
14:09:11 <gfredericks> since newtype Foo = Foo (bar :: Baz) is mostly equivalent to data Foo = Foo (bar :: Baz)
14:09:15 <byorgey> nand`: yes, perhaps you can't then
14:09:35 <byorgey> nand`: I guess it's not surprising that gloss doesn't have a way to rasterize vector stuff
14:10:24 <nand`> my next approach would be to simplify the actual use case to an overlapping series of rotated rectangles, and use trigonometry to rasterize those ‚Äòby hand‚Äô for arbitrary angles
14:10:36 <nand`> which would probably be simpler than writing a wrapper around OpenGL
14:11:27 <nand`> still a chunk of work I'd like to avoid if at all possible, though
14:12:49 <nand`> gfredericks: they have some slightly different semantics
14:13:06 <nand`> which can be largely advantageous in the cases where they're used
14:13:17 <gfredericks> nand`: I read in the book about differences wrt undefined, but that didn't seem compelling enough to justify a separate thing
14:13:36 * gfredericks doesn't even know why undefined should be a thing
14:13:45 <nand`> in general, the undefined thing is a result of, or rather allows newtypes to be completely ‚Äòfree‚Äô
14:14:05 <nand`> there's no runtime overhead associated with newtypes in GHC, because it can forget all about them at compile time as newtype constructors don't carry any information
14:14:22 <gfredericks> right but couldn't it also optimize newtype-equivalent data declarations in the same way?
14:14:40 <gfredericks> without forcing the programmer to think about the difference?
14:14:45 <nand`> undefined is a thing in Haskell largely because Haskell is turing complete; if you take away the ability to express undefined, you take away turing completeness
14:15:03 <gfredericks> O_O that is not obvious to me at all
14:15:05 <nand`> gfredericks: no, because those ‚Äòoptimizations‚Äô would change semantics
14:15:40 <gfredericks> maybe I need to start with understanding undefined
14:16:02 <nand`> gfredericks: ‚Äòundefined‚Äô pretty much simply means ‚Äòan expression that won't ever finish evaluation‚Äô, if you take away undefined; you're forcing every single expression to evaluate - and as we all know, the halting problem is undecidable on turing complete languages so it becomes impossible to verify or compile such programs
14:16:18 <davean> nand`: Um? I can write a turing machine without undefined
14:16:26 <davean> nand`: It might never complete, but it is defined
14:16:43 <nand`> davean: that's the ‚Äòundefined‚Äô we're talking about; defined, but won't ever complete
14:16:53 <nand`> eg. undefined = undefined
14:17:03 <Ralith> davean: as in, _|_
14:17:13 <Ralith> not the 'undefined' keyword.
14:17:20 <Ralith> per se.
14:17:21 <nand`> undefined isn't a keyword in haskell
14:17:25 <gfredericks> nand`: why would the program running forever not be an acceptable behavior?
14:17:39 <davean> gfredericks: please see halting problem
14:17:41 <gfredericks> turing machines are turing complete and they don't have a reified 'undefined'
14:17:50 <tgeeky> @src undefined
14:17:51 <lambdabot> undefined =  error "Prelude.undefined"
14:17:55 <Ralith> oh right
14:17:58 <gfredericks> davean: I'm well familiar with it
14:18:00 <Ralith> you know what I meant :P
14:18:26 <davean> gfredericks: So, they can run forever, they can't determine if they they'll terminate
14:18:39 <maukd> template<typename T> T undefined() { return undefined<T>(); }
14:18:59 <gfredericks> davean: oh I think you may be on my side of the discussion and I accidentally sounded against you
14:19:13 <Philippa> gfredericks: the problem is you don't actually pass values around in Haskell - you pass terms which might evaluate to values or might not terminate
14:19:17 <davean> gfredericks: you could not include "unending = unending" but you could always write it in a turing complete language
14:19:39 <davean> gfredericks: I'm ... not sure what side I'm on, I'm a bit confused as to the sides :)
14:20:01 <davean> The actual haskell "undefined" definately isn't needed
14:20:06 <davean> error isn't needed
14:20:08 <gfredericks> Philippa: that doesn't make it obvious to me why undefined should be a thing; as davean has pointed out, you can't even know that something won't terminate for sure, so it seems like you couldn't really use the thing
14:20:35 <gfredericks> davean: so you sound sure that nand`'s claim of "not turing-complete w/o undefined" is wrong?
14:20:53 <Philippa> gfredericks: you do need a way to talk about those terms that don't terminate though. Undefined is, er, defineable without having to be a primitive - but some people talk about undefined and _|_ (the 'value' we use for non-terminating stuff) as equivalent
14:20:55 <davean> gfredericks: well, there seems to be confusion as to what undefined he means
14:21:01 <Philippa> (strictly speaking, they're not and nand` is being sloppy)
14:21:31 <davean> gfredericks: I definately think nand`s arguements are bad, but that might be a lack of clarity in his terminology
14:21:41 <gfredericks> I'm gonna go have a drink; thanks guys :)
14:22:39 <nicoo> Philippa: Even *not* strictly speaking; the value of a variable can be undefined (not in Haskell) at a given point, yet the fonction around it could have completely defined and deterministic emantic
14:22:45 <nand`> gfredericks: you mean the compiler running forever?
14:23:51 <Philippa> nicoo: "the value of a variable" is a category error - variables are bound to terms which may or may not be values
14:24:19 <Philippa> but yes, we have such a semantics (for the most part) and that's exactly why _|_ exists
14:25:27 <nicoo> Philippa: Yes, and I specified ¬´ not in Haskell ¬ª (and *yes*, y = some_infinite_loop() doesn't bothers me)
14:33:57 <bgamari> Is there any convenient way to back out what fraction of time threads spend blocking on an MVar from an eventlog?
14:35:02 <hpc> bgamari: put a cost center on the functions that block MVars
14:35:27 <hpc> myTakeMVar = takeMVar; {-# cost center blah blah #-}
14:35:36 <hpc> -- should probably work
14:36:06 <bgamari> does the event log record which CC the program blocks in?
14:37:05 <Cale> bgamari: the idea is that it records the entire amount of time the program spends inside that cost-centre, so it ought to include the time that it blocks
14:37:45 <Cale> (as to whether it actually does, it's probably easier to try it and see)
14:38:14 <bgamari> Cale, Does threadscope not show this information?
14:38:58 <Cale> I haven't even tried threadscope yet. You'd think I would have, haha :)
14:42:33 <bgamari> Cale, hpc: unfortunately I really don't see anything in ghc-events' output which suggests that the cost-center is recorded
14:42:38 <bgamari> correct me if I'm wrong
14:42:52 <Cale> bgamari: hmm
15:16:06 <bgamari> Cale, Is there any way to show in the event log when MVars are put?
15:16:55 <bgamari> Cale, It shows when threads block, but it's tough saying what's going on without knowing exactly when the MVar is taken/put
15:17:39 <Polarina> Does anyone know of a version of ghc-gc-tune that actually works?
15:18:18 <Polarina> I get "ghc-gc-tune: Can't parse GC stats: blah..."
15:19:33 <thoughtpolice> Polarina: it's a pretty simple bug, IIRC i have a fix for it sitting on one of my machines
15:19:47 <thoughtpolice> i can grab it later
15:19:54 <Polarina> thoughtpolice, I'd be nice to have. :)
15:44:05 <Polarina> How do I compile my program with a default heap size ("-H128m"), without having to enable --rtsopts?
15:52:44 <lightquake> edwardk: what exactly is the point of makeClassy in Control.Lens?
15:53:04 <hiptobecubic> it's a formality
15:53:14 <hiptobecubic> heyoooooo!!! thanks folks. i'll be here all night
15:53:20 <hiptobecubic> tip your waitresses
15:53:21 <lightquake> Polarina: pass -with-rtsopts="-H128" to ghc
15:53:25 <lightquake> er, -H128M
16:09:14 <edwardk> lightquake: what do you mean?
16:09:31 <edwardk> lightquake: makeClassy can save you a huge amount of code
16:10:01 <ippo> quick, stupid question
16:10:14 <ippo> how can I write " new IRC client" in camelCase?
16:10:18 <lightquake> edwardk: i believe you, i'm just not sure what the use case is
16:10:26 <lightquake> neither newIRCClient or newIrcClient
16:10:36 <ippo> I know, they are all terrible
16:10:46 <lightquake> newInternetRelayChatClient!
16:11:01 <edwardk> data V2 = V2 { _e1, _e2 :: Int }; makeClassy ''V2; data V3 = V2 { _e12 :: V2, _e3 :: Int }; makeClassy ''V3; instance HasV2 V3 where v2 = e12
16:11:05 <ippo> ugh :S
16:11:10 <ippo> I guess newClient will do
16:11:22 <edwardk> lightquake: makeClassy makes up a class for the type. so you can do things like have other instances of HasFoo
16:11:41 <lightquake> ah, ok
16:11:42 <edwardk> in the above code I was able to overload e1, e2  so that they work with both V2 and V3
16:11:57 <edwardk> this is pretty nice when you go to do something like work with complex state
16:12:53 <edwardk> because you can just makeClassy for something like your localization settings, or compiler configuration, or whatever, and then build a composite state and just scribble out a couple of HasLocalization, HasCompilerOptions instances, etc. and call the methods that only need those specific features
16:13:24 <edwardk> this helps you avoid requiring extra features from the monad that your method doesn't need just for convenience and leads to more composable code
16:13:33 <lightquake> cool :)
16:14:12 <lightquake> on an unrelated note, one of the things i miss the most about OO languages is the fact that in python, foo.name and bar.name don't collide namespaces
16:14:33 <edwardk> the limitation of makeClassy is that, at least for right now, it only works with unparameterized types
16:14:46 <edwardk> well, this lets you pun a bit easier
16:15:10 <edwardk> but the namespace collision is the price we pay for other goodness, so its worth it i think
16:15:49 <lightquake> tdnr!
16:33:30 <nand`> if IRC Daemon is abbreviated IRCd, would it be fair to call an IRC Client an IRCc?
16:34:04 <pnielsen> no
16:34:27 <pnielsen> irc would be more naturally. Just like telnet and telnetd, or ssh and sshd
16:34:32 <pnielsen> s/naturally/natural/
16:35:11 <Nisstyre-laptop> nand`: "ircd" ends with a glottal stop, I guess, so that makes it seem more natural
16:35:42 <nand`> ‚Äòeye are sea dee‚Äô
16:35:55 <pnielsen> and pronuncing "cc" is ugly
16:35:57 <pnielsen> :)
16:36:30 <pnielsen> I don't think I've seen "c" used like "d" for daemon. ircClient/irc-client would be better imo
16:37:01 <Nisstyre-laptop> pnielsen: I guess if you made "cc" into one sound it would be better
16:37:07 <Nisstyre-laptop> but then it would just be "irc"
16:37:32 <nand`> maybe you could speak the ‚Äòc‚Äô at half speed :)
16:37:34 <pnielsen> irceeeeee
16:37:36 <pnielsen> haha
16:37:51 <pnielsen> I, R to the double-C
16:38:00 <Nisstyre-laptop> how about "i r double c"
16:38:07 <pnielsen> ^5 Nisstyre-laptop
16:38:10 <Nisstyre-laptop> or "ir2c"
16:38:19 <pnielsen> irc^2
16:38:20 <ben_m> i r c squared
16:38:22 <pnielsen> lol
16:38:34 <pnielsen> this is getting uncomfortable
16:38:39 <ion> I‚Äôm pretty sure the original IRC client binary was named ‚Äúirc‚Äù and the original IRC daemon was named ‚Äúircd‚Äù.
16:38:53 <pnielsen> ion: yeah, all the UNIX clients/daemons are like that
16:39:16 <Nisstyre-laptop> it's actually interesting why "ircc" seems unnatural
16:39:20 <Nisstyre-laptop> I can't explain it
16:39:33 <Nisstyre-laptop> maybe just the lack of English words that end in c
16:39:46 <pnielsen> if it was as commonplace as "d" I guess it wouldn't feel that strange
16:39:55 <Nisstyre-laptop> "irdd" would sound nicer
16:40:32 <ion> There was a follower to irc named ircii. I used that back in the day.
16:40:52 <ion> Well, ircII, but the binary was in lowercase IIRC.
16:40:54 <Nisstyre-laptop> "i r seee"
16:41:17 <nand`> irE/m
16:41:43 <Nisstyre-laptop> okay I need to get some work done
16:42:05 <ion> Oh. It seems it isn‚Äôt even in lowercase. It‚Äôs /usr/bin/ircII in the Debian package.
16:42:57 <nand`> I'd have checked, but apparently not a single user of the ‚Äòe-file‚Äô system has ever installed ircii
16:43:01 <glguy> Do programs using gloss necessarily use nearly 100% CPU? Is there a way to optimize rendering when things aren't changing?
16:55:08 <edwardk> lightquake: i am severely underwhelmed by the power of TDNR
16:55:28 <copumpkin> lol TDNR sux
16:56:35 <ddarius> copumpkin: What are you talking about?!  It's a much needed solution for the dire problem of having to type a few extra characters.  Semantics be damned!
16:57:06 <lightquake> haha
16:57:39 <lightquake> yeah TDNR in and of itself seems like a pretty awful idea
16:58:32 <dylukes> Does anyone else here use Text.Groom oftren?
16:58:36 <dylukes> I find it kind of invaluable.
16:59:08 <lightquake> never used it
16:59:36 <dylukes> it just throws in newlines here and there to make output legible.
16:59:46 <dylukes> (it's a simplistic pretty printer)
16:59:49 <lightquake> oh, nice
17:01:51 <benmachine> I don't like TDNR either
17:17:20 <Polarina> What library can I use to do matrix-matrix and matrix-vector multiplications?
17:17:37 <latro`a_> hmatrix is probably fastest
17:17:41 <latro`a_> albeit also probably painful
17:18:20 <Polarina> latro`a_, something not GPL licensed?
17:18:38 <latro`a_> ...?
17:18:56 <Polarina> hmatrix is GPL licensed.
17:19:02 <latro`a_> this is bad why?
17:19:33 <Polarina> Don't know. People here just seem to not like GPL.
17:22:06 <ddarius> latro`a_: Why do you think hmatrix would be painful?
17:22:34 <latro`a_> people sometimes have issues with installing LAPACK, and the API itself is meh
17:22:40 <hpc> Polarina: it makes static linking hard
17:22:56 <latro`a_> meh not because it's bad, it's just inherently not great because of issues from LAPACK itself
17:25:49 <swarley> does real world haskell have a git repo with latex source?
17:26:23 <BMeph> Does RWH have a darcs repo with laTeX source? ;√æ
17:26:37 <swarley> :p whatever
17:26:43 <BMeph> Or should that be "LaTeX"? ;)
17:26:43 <Cale> latro`a_: Well, it's just that almost everything in the Haskell world is BSD licensed.
17:26:51 <swarley> i think it's LaTeX
17:27:17 <swarley> http://en.wikibooks.org/wiki/LaTeX/Paragraph_Formatting
17:27:18 <swarley> yeah
17:27:22 <swarley> LaTeX
17:27:22 <dylukes> hrm
17:27:24 <latro`a_> ic cale
17:27:24 <latro`a_> but
17:27:36 <latro`a_> since it uses LAPACK that might force the issue?
17:27:36 <applicative> there is a repo with the docbook and so on github.com/bos/rwh
17:27:43 <dylukes> so I have something like a list of A's, where A contains a [B], and I want to do [A] -> Map B [A]
17:27:44 <latro`a_> idk how licensing works with FFI stuff
17:27:52 <dylukes> so I essentially want to invert the mapping.
17:27:58 <swarley> applicative, thank you
17:28:09 <dylukes> Is there any efficient functional algorithm for this.
17:28:34 <rwbarton> according to wikipedia LAPACK is also released under a version of the BSD license
17:29:05 <Cale> dylukes: I doubt there's anything better than folding over the list and inserting a bunch of elements into the map for each A
17:30:14 <hpc> yeah, i can't think of anything faster either
17:30:26 <hpc> if there was a way, it would have to deal with Map internals
17:30:31 <hpc> and... ew
17:31:09 <ddarius> It's GSL that causes the problem for hmatrix.
17:31:29 <latro`a_> ahh
17:32:14 <dylukes> Yeah‚Ä¶ it just feels like incrementally building a Map is not exactly efficient. but oh well.
17:32:48 <latro`a_> it's more efficient if your input is sorted
17:32:59 <hpc> @src fromList
17:33:00 <lambdabot> Source not found. I am sorry.
17:34:03 <gfredericks> nand`: I did not mean the compiler running forever, no
17:34:17 <hpc> fromList :: Ord k => [(k,a)] -> Map k a
17:34:17 <hpc> fromList xs
17:34:17 <hpc>   = foldlStrict ins empty xs
17:34:17 <hpc>   where
17:34:18 <hpc>     ins t (k,x) = insert k x t
17:34:20 <applicative> Polarina, obviously you should use repa ... http://hackage.haskell.org/packages/archive/repa-algorithms/3.2.2.1/doc/html/Data-Array-Repa-Algorithms-Matrix.html
17:34:23 <applicative> http://code.ouroborus.net/repa/repa-head/repa-examples/examples/MMult/src-repa/
17:34:31 <hpc> incrementally building the Map is the only way, it seems
17:35:31 <Eduard_Munteanu> Hrm, haussholder :: Field a => a -> Vector a -> Matrix a, that should be householder I guess.
17:35:40 <Eduard_Munteanu> Speaking of hmatrix.
17:36:42 <Polarina> applicative, thanks, I'll take a look into that.
17:37:40 <Cale> Who is writing all this code with the tabs in it?
17:38:21 <Cale> lol, mixed tabs and spaces
17:38:23 <hpc> Cale: if we wanted that kind of code, our mascot would be a tabbycat!
17:39:05 <Cale> (the repa examples)
17:39:16 <applicative> yes, he's tab mad.
17:40:01 <applicative> but then, so is oleg
17:40:25 <gfredericks> I just read the haskell wiki article on 'Bottom' and still cannot understand why 'undefined' should exist
17:40:28 <Cale> oleg'uses'identifiers'like'this
17:40:57 <applicative> so do I, but then I regret it
17:41:09 <Cale> gfredericks: If you have general recursion, you can't stop bottom from existing.
17:41:25 <ddarius> > ord'a'
17:41:25 <gfredericks> Cale: when does it get used?
17:41:26 <lambdabot>   Not in scope: `ord'a''
17:41:35 <ddarius> > ord 'a'
17:41:36 <lambdabot>   97
17:41:50 <applicative> gfredericks: general recursion?
17:41:54 <Cale> 'undefined' is useful for testing whether part of an expression is evaluated
17:41:57 <gfredericks> applicative: undefined
17:42:02 <Cale> > const 5 undefined
17:42:03 <lambdabot>   5
17:42:08 <gfredericks> Cale: that doesn't make it sound necessary
17:42:21 <gfredericks> you said "you can't stop bottom from existing" -- why not?
17:42:22 <Eduard_Munteanu> > const 5 (fix id)
17:42:23 <lambdabot>   5
17:42:36 <Cale> because
17:42:37 <latro`a_> because of the halting problem
17:42:45 <Cale> undefined = undefined
17:42:58 <applicative> gfredericks: like Cale said, the alternative is restriction on recursive definition
17:43:03 <Cale> even if exceptions didn't exist, you could write that
17:43:21 <copumpkin> not in Agda
17:43:23 <copumpkin> just use agda
17:43:23 <gfredericks> Cale: okay so you're saying we can't stop someone from defining it?
17:43:25 <Cale> in earlier Preludes, undefined was liek this:
17:43:30 <Eduard_Munteanu> copumpkin++
17:43:31 <gfredericks> not that it absolutely has to be in Prelude?
17:43:31 <Cale> undefined | False = undefined
17:43:37 <Eduard_Munteanu> :)
17:43:39 <Cale> gfredericks: right
17:43:43 <applicative> gfredericks: as copumkin says, there are superior language which do without this nonsense
17:43:46 <applicative> languages
17:43:51 <gfredericks> Cale: okay; so the only reason it's in prelude is because it's useful
17:43:52 <copumpkin> lol
17:43:53 <Cale> It doesn't *have* to be in the Prelude, but it is handy.
17:43:55 <copumpkin> not sure I'd say superior
17:44:02 <copumpkin> but very different
17:44:05 <hpc> applicative: there is only one true languages
17:44:11 <gfredericks> I'm still not sure why people keep tying it to the halting problem
17:44:18 <applicative> hpc indeed
17:44:28 <Cale> gfredericks: because it's nontermination
17:44:42 <Cale> (which happens to be a lot faster than actually looping)
17:44:47 <Eduard_Munteanu> gfredericks: is  foo = foo   defined? Does it halt?
17:44:49 <hpc> gfredericks: bottom represents "things without defined value"
17:45:04 <Eduard_Munteanu> How about <contrived example>?
17:45:06 <hpc> which happens to be both "it explodes instead of computing to a thing"
17:45:12 <hpc> and "it never actually computes to anything"
17:45:28 <copumpkin> gfredericks: yeah, it isn't really the halting problem
17:45:28 <gfredericks> okay so undefined is this thing which represents nontermination
17:45:37 <MostAwesomeDude> In addition to the recursion problem, wouldn't a lack of bottom also mean that all functions must be total?
17:45:39 <gfredericks> by being self referential and thus not resolvable
17:45:41 <Eduard_Munteanu> Not necessarily nontermination.
17:45:45 <Philippa> gfredericks: case let foo = foo in foo of {_|_ -> neverEvaluates; x -> ...}
17:45:50 <rwbarton> non-(normal-termination)
17:46:02 <Eduard_Munteanu> But partiality at large.
17:46:03 <gfredericks> MostAwesomeDude: it's not obvious to me what "a lack of bottom" means in this context; mostly I was wondering why it should be included
17:46:05 <hpc> gfredericks: nontermination is one kind of bottom, essentially
17:46:06 <Cale> MostAwesomeDude: right
17:46:54 <Cale> gfredericks: undefined is just a convenient way of writing the least defined value of any type
17:47:07 <Cale> (which is an honest value, semantically)
17:47:10 <gfredericks> when I encountered 'undefined' in LYAH my impression was it functioned similarly to nulls; but I'm thinking that's not true at all
17:47:15 <Cale> There are lots of things in between...
17:47:17 <MostAwesomeDude> gfredericks: I mean, if you don't have a bottom, then you might have a real problem defining things like head :: [a] -> a
17:47:25 <Cale> > length [undefined, undefined, undefined]
17:47:26 <lambdabot>   3
17:47:31 <hpc> gfredericks: if you squint a bunch, there's similarities
17:47:32 <copumpkin> MostAwesomeDude: clearly that means that function should not exist
17:47:43 <MostAwesomeDude> copumpkin: Hey, you already converted me. :3
17:47:45 <applicative> head would be rejected  by the totality checker
17:47:47 <hpc> mostly of the "programmers pretend it isn't there" variety
17:47:53 <Eduard_Munteanu> gfredericks: not at all, you can't test for undefinedness
17:47:53 <copumpkin> I can prove head false
17:47:53 <Cale> > length (undefined : undefined : undefined : undefined)
17:47:54 <lambdabot>   *Exception: Prelude.undefined
17:47:55 <copumpkin> in Agda
17:47:57 <benmachine> copumpkin: isn't it related to the halting problem inasmuch as the halting problem tells us no Turing-complete language can be total?
17:47:57 <Philippa> hpc: *null = undefined
17:48:00 <Cale> > length (take 3 (undefined : undefined : undefined : undefined))
17:48:01 <lambdabot>   3
17:48:14 <MostAwesomeDude> benmachine: Well, "complete and consistent."
17:48:28 <gfredericks> okay, I think I understand the issue better. Thank you folks.
17:48:29 <benmachine> MostAwesomeDude: hmm?
17:48:35 <copumpkin> benmachine: the halting problem says you can't write a decider for halts?(p ) :P
17:49:00 <benmachine> copumpkin: if that answers my question I am too poorly educated to know it :P
17:49:20 <copumpkin> benmachine: well, I was correcting the statement hiding in your question :P
17:49:29 <copumpkin> the halting problem doesn't tell us that
17:49:32 <Philippa> metanote: can people please remember that we need to think about _|_ as opposed to "oh, it didn't terminate" due to non-strictness, not just the existance of non-termination per se? Not everyone who's confused by it will realise that
17:49:41 <Dread> [a -> a] -> a -> a    Does GHC automatically know to just mutate a single copy of 'a' rather than create new 'a's?
17:49:58 <benmachine> copumpkin: hmm.
17:50:08 <copumpkin> benmachine: does a description of a nonterminating program in a provably terminating one count?
17:50:12 <Eduard_Munteanu> Dread: mm, what function do you have in mind?
17:50:26 <benmachine> copumpkin: umm, what does that mean?
17:50:27 <Eduard_Munteanu> The type doesn't make it clear.
17:50:30 <applicative> copumpkin: of course not
17:50:44 <hpc> Dread: the optimizer might be able to figure that out, depending on how things inline and whatnot
17:50:48 <applicative> you're just emulating turing completeness, you fraud
17:50:54 <copumpkin> benmachine: in Agda we have the partiality monad that lets us describe nonterminating computations
17:51:04 <hpc> Dread: best to do some testing and know for sure
17:51:16 <copumpkin> benmachine: you can't write an evaluator for the type in Agda itself, but you can prove things about it
17:51:30 <Cale> Dread: it's not entirely clear what you mean by that, I think
17:51:32 <benmachine> copumpkin: oh, right. but Agda still isn't Turing-complete, no?
17:51:46 <applicative> well, this Agda evidently isn't very expressive then...
17:51:53 <Dread> Apply list of (a -> a) to an 'a'  essentially mutating a value with a list of functions
17:51:54 <Cale> Dread: GHC usually won't just mutate things in-place
17:52:02 <benmachine> copumpkin: insofar as, there is a computable function f such that I can't write an agda program that takes n and outputs f n
17:52:10 <copumpkin> benmachine: I dunno, what does that mean? :P if I can embed a complete description of all programs that you could construct in a TC language, then is it any weaker?
17:52:20 <Cale> Dread: but it is very good at picking up short-lived garbage
17:52:39 <hpc> applicative: the partiality monad is pretty awesome
17:52:45 <benmachine> copumpkin: being able to describe those programs is different from being able to run them, surely
17:52:53 <applicative> yes I know about it hpc
17:53:20 <hpc> oh, nvm :P
17:53:29 <copumpkin> benmachine: I can run them arbitrarily deeply, as long as I don't let them go forever
17:53:49 <copumpkin> benmachine: I don't see a particularly meaningful distinction, honestly :P
17:54:08 <jmcarthur> Dread: ghc has a bump allocator for the minor heap. it's just a matter of writing into the heap sequentially followed by a pretty quick minor gc once it fills up. modifying in place might be a little faster, but probably not enough to justify the effort of implementing the operation.
17:54:10 <benmachine> copumpkin: okay, but what about that other test that I mentioned? are there functions such that I can't write an Agda program that computes that function?
17:54:16 <jmcarthur> *into the minor heap
17:54:31 <benmachine> copumpkin: "computes" in the sense of, you know, I enter a thing in a terminal and it spits out a thing in a terminal
17:54:46 <Dread> Thanks Cale, hpc, and jmcarthur
17:54:50 <jmcarthur> Dread: it's basically reasonable to think of the minor heap as about as expensive as the stack
17:54:56 <applicative> benmachine: you can call them functions...
17:54:58 <benmachine> copumpkin: so, I guess the function in question would have to be one where I can't prove that it terminates in n steps for any n, but I can prove it terminates
17:54:59 <jmcarthur> (it's a bit more expensive than that, but not terribly so)
17:54:59 <dolio> Can Haskell do IO?
17:55:05 <Eduard_Munteanu> I think mutating in-place could be quite a bit faster, depending on the application.
17:55:08 <latro`a_> @faq Can Haskell do IO
17:55:09 <lambdabot> The answer is: Yes! Haskell can do that.
17:55:11 <copumpkin> benmachine: sure, but take Haskell and its treatment of IO, for example. Conceptually, you can't do anything useful in Haskell either, without a runtime that "executes" your main IO action
17:55:16 <applicative> @faq can haskell do IO?
17:55:16 <lambdabot> The answer is: Yes! Haskell can do that.
17:55:25 <Eduard_Munteanu> GC-ing the mess doesn't sound really cache-friendly, for one thing.
17:55:33 <benmachine> copumpkin: all right, but surely the ability to "execute" general recursive functions in Agda would also give the ability to loop infinitely
17:55:34 <applicative> latro`a_: you type too fast
17:55:39 <jmcarthur> Eduard_Munteanu: right. for some applications it would probably be significantly faster, but i claim that the analysis would be very hard
17:55:42 <latro`a_> nah, too slow
17:55:48 <benmachine> copumpkin: and *that* is because of a roughly HP-type argument
17:55:49 <latro`a_> I've slowed down over time
17:55:52 <latro`a_> made more and more mistakes
17:55:53 <copumpkin> benmachine: yeah, but like haskell pushes IO out to the runtime, agda can push nontermination out
17:55:54 <latro`a_> need to practice
17:56:21 <benmachine> copumpkin: ok fair enough, but what that says to me is that Agda can choose between totality and guaranteed termination
17:56:23 <copumpkin> benmachine: so in practice, we can write just about everything, with enough tedium
17:56:34 <benmachine> copumpkin: which is great, I love a language that can make that choice, but it's still a choice
17:56:34 <hpc> benmachine: in a sense, the nontermination monad is the "i can't prove this is false" data structure
17:56:38 <jmcarthur> Eduard_Munteanu: i don't know for sure, but i speculate that a minor gc is not *that* cache unfriendly
17:56:53 <jmcarthur> Eduard_Munteanu: most of the work is in the stack and the minor heap
17:57:09 <benmachine> copumpkin: I'm not trying to insult Agda here :P I'm just trying to defend my understanding of the relevance of the halting problem
17:57:09 <Eduard_Munteanu> jmcarthur: btw, does it do in-place mutation *at all*? I mean, I can see how it could fire depending on what the strictness analyzer says.
17:57:17 <hpc> benmachine: i think you mean partiality and totality?
17:57:26 <benmachine> hpc: eerr, yes
17:57:30 <Eduard_Munteanu> Assuming you used unboxed types and whatnot.
17:57:30 <benmachine> well, no
17:57:36 <benmachine> I mean completeness and totality, I guess
17:57:39 <hpc> ah
17:57:48 <benmachine> I don't want to "choose" partiality
17:57:54 <jmcarthur> Eduard_Munteanu: i bet the native code gen does a little of that, and the llvm backend almost certainly does, but i doubt ghc does anything like that earlier intermediate representations
17:57:57 <benmachine> but I'm forced to have partiality if I also want everything total
17:58:05 <jmcarthur> *like that in earlier
17:58:17 <hpc> benmachine: incompleteness, you mean?
17:58:30 <hpc> partiality = "this is undefined for some inputs"
17:58:32 <dolio> No partial functions pass Agda's termination checker, in theory.
17:58:33 <copumpkin> benmachine: the agda program is still total, much like the haskell program is still pure :P
17:58:33 <benmachine> hpc: no, I'm just phrasing badly :P
17:58:37 <hpc> heh
17:58:40 <Eduard_Munteanu> Ah, I see.
17:58:46 <benmachine> hpc: by "everything total" I mean "all the total functions"
17:58:55 <copumpkin> benmachine: but there are certainly things we can't prove in agda
17:59:01 <benmachine> hpc: I can either have not all total functions, or I can have all total functions and some partial ones
17:59:20 * hackagebot aws-sdk 0.1.2.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.1.2.0 (YusukeNomura)
17:59:33 <hpc> it's late anyway, so i will leave this discussion in better hands :P
17:59:51 <copumpkin> benmachine: the way agda can deal with partiality is very very close to how haskell deals with IO
18:00:05 <benmachine> copumpkin: yes, I know, I've had this explained to me before :P
18:00:22 <benmachine> copumpkin: and the way I think about it is close to the way I think about IO
18:00:29 <Eduard_Munteanu> Yay for the partiality monad.
18:00:47 <JoeyA> :t foldr1
18:00:47 <lambdabot> JoeyA: You have 1 new message. '/msg lambdabot @messages' to read it.
18:00:48 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:00:49 <benmachine> inasmuch as you can construct your pure IO recipes in Haskell, but in order to *understand* them you have to form an impure model of the way IO executes
18:00:57 <copumpkin> benmachine: so are you saying "oh but there are some things (like printLn) that we can't write as pure functions!" :P
18:01:03 <rwbarton> come on
18:01:06 <applicative> if the new MIT language for images is 'pure' and 'functional' why does it look like this:  http://halide-lang.org/
18:01:07 <rwbarton> he is asking a specific question
18:01:09 <jmcarthur> i am not completely convinced that partiality as a monad is the nicest way to approach it
18:01:19 <applicative> I wonder if D Turner can be hired to give lessons
18:01:23 <JoeyA> What would be a good name for this function?  (a -> b -> b) -> (a -> b) -> [a] -> b
18:01:39 <JoeyA> Like foldr1, but lets you have different a and b types by applying a function to the initial value.
18:01:41 <rwbarton> what are the functions Integer -> Integer you can write in agda, they aren't all the computable ones
18:01:54 <jmcarthur> JoeyA: so fold composed with map?
18:02:15 <jmcarthur> oh wait, not quite...
18:02:16 <copumpkin> rwbarton: yes, and I'm arguing that you can write all the others as Integer -> Integer _|_
18:02:17 <JoeyA> No, the function is only applied to the base (last) item.
18:02:24 <rwbarton> right but that wasn't the question!
18:02:59 <copumpkin> alright, then no, agda's termination checker is obviously not omniscient
18:03:05 <JoeyA> This is an analogy, though.  Elm has this function: foldp ::(a -> b -> b) -> b -> Signal a -> Signal b
18:03:21 <copumpkin> it's basically a simple heuristic
18:03:25 <jmcarthur> that seems like a more reasonable fold to me
18:03:54 <JoeyA> It lets you make a Signal that uses state when processing input values.
18:04:05 <jmcarthur> i guess that is more of a scan than a fold
18:04:05 <Eduard_Munteanu> But as with all languages and safety nets and so on, you take the chance it will reject at least *some* valid (in some way) programs.
18:04:09 <benmachine> copumpkin: so, basically, I think it's reasonable to think of the Halting Problem as a reason why _|_ has to exist in Haskell
18:04:17 <JoeyA> The problem is, you can't have your initial value come from the source Signal.
18:04:29 <benmachine> copumpkin: (subject to the constraint that Haskell is a TC language)
18:04:46 <JoeyA> Meaning if you have newtype Auto a b = Auto (a -> (b, Auto a b))
18:04:57 <benmachine> copumpkin: in Agda you don't really make _|_ not exist, you just make it go into the partiality monad instead of in your normal types
18:05:00 <JoeyA> You can't use foldp to implement Auto a b -> Signal a -> Signal b
18:05:06 <benmachine> copumpkin: or at least, that's my understanding
18:05:32 <Eduard_Munteanu> benmachine: no, _|_ is really _|_ in Agda, that is, an empty set.
18:05:37 <Eduard_Munteanu> s/set/type/
18:05:41 <copumpkin> _|_ is a different meaning there
18:05:48 <copumpkin> _|_ as least defined value vs. _|_ as empty type
18:05:52 <copumpkin> it's annoying
18:06:03 <applicative> it's a menace
18:06:04 <rwbarton> it's not called Void?
18:06:10 <benmachine> it's conceptually sound though, isn't it?
18:06:19 <benmachine> they're both minimal elements, just of different posets
18:06:23 <applicative> Half the types in Agda are empty
18:06:29 <Eduard_Munteanu> But the least defined value doesn't have a name either.
18:06:37 <benmachine> Eduard_Munteanu: doesn't mean it doesn't exist :)
18:06:43 <Eduard_Munteanu> You can't pretend there's some 'undefined' you can plug in.
18:07:31 <jmcarthur> i think turing completeness as a constraint for a programming languages is not as useful as it is often made out to be
18:07:34 <jmcarthur> *language
18:07:37 <swarley> Setup: At least the following dependencies are missing:
18:07:37 <swarley> mtl -any, regex-posix -any
18:07:44 <swarley> i just used cabal to install those
18:07:51 <swarley> why do they show up as missing?
18:08:12 <rwbarton> did you sudo cabal install?
18:08:16 <swarley> yes
18:08:18 <rwbarton> don't do that
18:08:19 <geekosaur> that's why
18:08:22 <dcoutts> swarley: use cabal to install the thing you want, no need to use Setup
18:08:28 <geekosaur> sudo cabal install put them in root's private packages
18:08:33 <swarley> ah
18:08:43 <geekosaur> don't use sudo with cabal unles syou know what youre doing
18:08:50 <swarley> kk
18:08:56 <benmachine> jmcarthur: I agree, ftr
18:08:57 <swarley> if i dont i get this
18:08:58 <swarley> cabal: /home/swarley/.cabal/share/doc/regex-posix-0.95.2: permission denied
18:09:00 <jmcarthur> there are many things expressible in turing complete languages that are completely useless, and yet similar enough to useful programs that they might be accidentally written.
18:09:05 <copumpkin> benmachine: my point was more that if you can get a language that lets you write/embed all programs in it, without "accidentally" introducing _|_ into all types, then that suggests that it doesn't really explain it
18:09:14 <Eduard_Munteanu> jmcarthur: in some way, it's just as useful as dynamic/weak typing is to static/strong typing
18:09:21 <jmcarthur> to be honest, i'm not quite sure what the core of this discussion really is
18:09:33 <geekosaur> (it's rarely a good idea to do so; there are valid uses for it, but they make recovery from some kinds of package conflicts nearly impossible without nuking your entire ghc installation)
18:09:48 <dcoutts> swarley: it's got the wrong permissions because you accidentally did a sudo cabal install before, so you installed files as root, but in your home dir
18:09:50 <applicative> swarley: because it already exists but you don't have privilege to overwrite it
18:10:32 <rwbarton> you could sudo chown -R swarley.swarley /home/swarley/.cabal
18:10:34 <dolio> Phone call for Swarls Barkley.
18:10:38 <swarley> ah, i just chown'd .ghc and .cabal and that fixed it
18:10:46 <jmcarthur> Eduard_Munteanu: i have a much stronger position on weak types. i don't even understand why they are given their own classification. they are just broken types.
18:10:49 <swarley> dolio, i have all of my magazines sent to Swarhili
18:11:03 <Eduard_Munteanu> Heh, fair.
18:11:24 * applicative is glad to hear reputable people speak in favor of sudo chown -R swarley.swarley /home/swarley/.cabal 
18:11:33 <benmachine> copumpkin: hmm. but even though you don't have _|_ in all types, you've got to have something a bit like it /somewhere/
18:12:01 <benmachine> applicative: I'm even more in favour of setting root-cmd so it's not necessary in the first place
18:12:14 <benmachine> or even just installing user so root never even gets involved :P
18:12:21 <benmachine> anyway I am going to bed
18:12:22 <copumpkin> benmachine: we can write nontermination explicitly in the partiality monad, but we need to write in the type that we might use it
18:12:28 <jmcarthur> benmachine: why do you have to have _|_?
18:12:39 <Fuuzetsu> Hey. Can someone explain what does fix f = let x = f x in x   achieve?
18:13:09 <shachaf> Fuuzetsu: Do you understand "let x = 1 : x in x"?
18:13:09 <applicative> its a curiosity of my setup that I, and cabal, can't call the gcc except as root
18:13:09 <jmcarthur> oh, do you mean that if agda is expressive enough to describe turing complete programs then it's expressive enough to describe _|_?
18:13:31 <dolio> It's easy to write undefined in the partiality monad.
18:13:35 <jmcarthur> right
18:13:38 <Fuuzetsu> will it forever prepend 1?
18:13:39 <dolio> undefined = delay undefined
18:13:43 <jmcarthur> you just keep producing delays
18:13:52 <applicative> Fuuzetsu: fix frequently doesn't acheive anything
18:14:02 <applicative> > fix (+1)
18:14:06 <lambdabot>   mueval-core: Time limit exceeded
18:14:07 <dolio> Part of the question is: why do you care if something is Nat -> Nat _|_ vs. Nat -> Nat.
18:14:15 <dolio> If you're running it, you don't care.
18:14:19 <copumpkin> hey, fix (1+) used to work when lambdabot had naturals
18:14:32 <applicative> > fix 1
18:14:33 <dolio> If you're using it in a type, you care.
18:14:33 <lambdabot>   1
18:14:33 <shachaf> lambdabot had naturals?
18:14:46 <copumpkin> :k Natural
18:14:47 <lambdabot>     Not in scope: type constructor or class `Natural'
18:14:51 <copumpkin> that used to say *
18:14:52 <copumpkin> :(
18:14:52 <bigfg> Fuuzetsu, fix f = f (fix f)
18:15:12 <applicative> > fix (1 :)
18:15:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:15:21 <jmcarthur> dolio: i might care if i want to use something like unamb or lub with it. having _|_ would give me an identity element, which is pretty convenient
18:15:22 <dolio> So, the distinction only ultimately matters for things that you want to compute during static checking.
18:15:46 <dylukes> :<
18:15:47 <jmcarthur> this is clearly an argument of convenience, of course, not of actual need
18:15:48 <dylukes> this is painfully slow...
18:15:52 <dylukes> I need a better algorithm.
18:15:54 <copumpkin> and if I really wanted to, I could run the partial computation for 10000000 "iterations" and return a default value if it doesn't finish in time
18:15:55 <applicative> Fuuzetsu: what's the  list that's such that its the same as putting a 1 in front of it.
18:15:57 <swarley> what is _|_?
18:16:02 <copumpkin> I probably wouldn't do that though :P
18:16:08 <jmcarthur> swarley: you've asked the big question
18:16:11 <dolio> jmcarthur: I meant more, why do you need Nat -> Nat over Nat -> Nat _|_.
18:16:18 <dolio> jmcarthur: Not the reverse.
18:16:21 <jmcarthur> ah i see
18:16:25 <bigfg> swarley, usually here we call it 'womb'
18:16:35 <dylukes> I should be able to get O(n) :\
18:16:43 <zomg> bigfg: the finger
18:16:45 <swarley> also i just installed mtl and regex-posix and i still get the error
18:16:46 <zomg> lol
18:16:59 <swarley> Setup: At least the following dependencies are missing:
18:16:59 <swarley> mtl -any, regex-posix -any
18:17:00 <Fuuzetsu> errr... infinite list of 1?
18:17:14 <swarley> bigfg, that raises so many more questions
18:17:14 <applicative> swarley: cabal clean?
18:17:34 <swarley> how do i use it?
18:17:37 <bigfg> swarley, trust me, it doesn't raise *nearly enough* questions
18:17:51 <rwbarton> is that because runhaskell Setup.hs defaults to global? I forget
18:17:56 <swarley> it said cabal: No cabal file found
18:17:58 <applicative> Fuuzetsu: yes!
18:18:02 <jmcarthur> dolio: i don't need Nat -> Nat over Nat -> Nat _|_, i think, but i might need A==B over A==B _|_
18:18:06 <rwbarton> what are you trying to install anyways?
18:18:17 <swarley> i'm trying to build the rwh book
18:18:21 <rwbarton> oh.
18:18:27 <jmcarthur> dolio: i take that back
18:18:34 <jmcarthur> dolio: i'm either computing it or i'm not, either way
18:18:49 <rwbarton> that sounds like it could be A Project.
18:19:03 <rwbarton> given that the README.building is 4 years old
18:19:44 <swarley> so i did cabal clean
18:19:45 <swarley> what now?
18:19:46 <dolio> jmcarthur: Well, if you have a type family T : Nat -> Set, Having f : Nat -> Nat _|_ isn't going to be good for you if you want to use it in an index to T.
18:19:50 <Fuuzetsu> That took solid brainpower. Then a follow up question. Was there an update to lambdabot recently? @pl a o e u = a (o e u) used to produce "((.) . (.))" (or (.:))but now it produces "fix ((.) . (.))"
18:20:10 <MostAwesomeDude> I didn't think lambdabot knew about (.:).
18:20:12 <rwbarton> are you in the tools/ directory? what does 'cabal build' do there?
18:20:14 <shachaf> Fuuzetsu: No, you're just not doing what you think you're doing.
18:20:14 <applicative> https://github.com/bos/rwh/blob/master/tools/tools.cabal is a little old
18:20:18 <jmcarthur> swarley: _|_ is pronounced "bottom" and represents an expression that does not terminate. it's meaningful in haskell due to non-strict evaluation, which means that just because you've bound something to an identifier doesn't imply that the work is already done
18:20:19 <Fuuzetsu> MostAwesomeDude: it doesn't
18:20:24 <MostAwesomeDude> @pl a o e u = a (o e u)
18:20:24 <lambdabot> a = fix ((.) . (.))
18:20:27 <MostAwesomeDude> Huh.
18:20:35 <dolio> But if all you care about is, "can I write a program and have it executed at runtime," it's fine.
18:20:51 <Fuuzetsu> it's something someone in here came up with (shachaf I believe)
18:20:56 <swarley> so _|_ islike an infinite list?
18:21:00 <swarley> is like*
18:21:11 <jmcarthur> swarley: no, _|_ is like never even producing the first element of the list
18:21:12 <copumpkin> I guess the partiality monad to IO monad comparison breaks down right about there
18:21:18 <swarley> oh..
18:21:24 <copumpkin> because normally I can lift any pure function into IO and run it anyway
18:21:26 <shachaf> Fuuzetsu: What you wrote there is a recursive function. You probably didn't intend to write a recursive function.
18:21:31 <swarley> i sure wish this would build
18:21:41 <copumpkin> but I can't just lift my "pure type" into the partiality monad and run my typechecker partially
18:21:46 <jmcarthur> swarley: you can still bind such an expression to an identifier and pass it as arguments to functions and such
18:21:49 <jmcarthur> @src undefined
18:21:49 <lambdabot> undefined =  error "Prelude.undefined"
18:21:49 <rwbarton> Fuuzetsu: also, a generally safe answer to "was there an update to lambdabot recently" is "no"
18:21:53 <jmcarthur> bah
18:21:56 <Fuuzetsu> hehe
18:22:02 <jmcarthur> swarley: example:     undefined = undefined
18:22:13 <jmcarthur> perhaps a confusing example, actually
18:22:13 <shachaf> @remember rwbarton also, a generally safe answer to "was there an update to lambdabot recently" is "no"
18:22:13 <lambdabot> It is forever etched in my memory.
18:22:19 <shachaf> rwbarton: Now prove yourself wrong!
18:22:24 <rwbarton> Best part is a new lambdabot won't have that memory!
18:22:25 <ddarius> The partiality monad should also be commutative.
18:22:34 <jmcarthur> swarley: a different example:     x = x+1 :: Int
18:22:46 <ddarius> rwbarton: Nor the old lambdabot.
18:22:51 <rwbarton> :(
18:23:21 <applicative> @pf a o e i u = (o (e i u))
18:23:21 <lambdabot> Maybe you meant: bf pl
18:23:27 <shachaf> @flush
18:23:28 <applicative> @pl a o e i u = (o (e i u))
18:23:28 <lambdabot> a = (.) . (.)
18:23:30 <shachaf> @yarrr
18:23:30 <lambdabot> Get out o' me way, yeh landlubber
18:23:36 <jmcarthur> dolio: i might be willing to accept a type checker that doesn't necessarily terminate though
18:23:43 <swarley> hm..
18:23:49 <dolio> Well then, why bother making the distinction?
18:24:10 <jmcarthur> dolio: i thought i was kind of supporting your point, not refuting it
18:24:11 <ddarius> Also, non-terminating things at the type level introduces a lot of awkwardness.
18:24:27 <swarley> soooooo
18:24:41 <swarley> cabal configure and cabal build sort of work..
18:25:06 <swarley> blah except it doesnt
18:25:15 <jmcarthur> ddarius: what kind of awkwardness? i believe what you said, but can't think of any examples
18:25:22 <applicative> swarley: mine breaks at the last minute with     Unacceptable argument type in foreign declaration: CInt
18:25:48 <ddarius> You now -have- to normalize whereas before you could, in theory and in some systems, get away without reaching normal form or even evaluating at all.
18:26:02 <swarley> mien breaks here
18:26:02 <swarley> AutoID.hs:35:31: Not in scope: `runState'
18:26:12 <swarley> mine*
18:26:26 <ddarius> This means the type checker has to do a lot more work even if your types are actually all defined.
18:26:29 <swarley> using cabal build in tools/
18:26:31 <jmcarthur> right
18:26:50 <jmcarthur> i guess i just see that as a clearly defined negative rather than as something awkward
18:26:52 <applicative> swarley: there will be unpleasantness even if you get the right packages because of the hsc file
18:27:16 <swarley> ugggh
18:27:20 <jmcarthur> maybe i was making some assumptiong about what you meant by awkward, like "difficult to reason about"
18:27:30 <swarley> if i run `make
18:27:40 <jmcarthur> (i could see that, too, though)
18:27:48 <swarley>  in en/ i get the error about mtl and regex-posix
18:27:51 <ddarius> It will certainly become more difficult to reason about, but that seems obviosu.
18:28:01 <jmcarthur> yeah
18:28:30 <ddarius> jmcarthur: You may find NuPRL interesting if you haven't looked at it before.
18:28:31 <swarley> i just want a pdf of the book...
18:28:36 <swarley> e_e
18:29:31 <rwbarton> @google real world haskell filetype:pdf
18:29:32 <applicative> swarley: I'm afraid it hasn't been touched for several ghc's
18:29:33 <lambdabot> http://fldit-www.cs.uni-dortmund.de/~peter/RealWorldHaskell.pdf
18:29:43 <rwbarton> not THE pdf though
18:30:12 <swarley> does that mean all of the examples wont work?
18:30:13 <applicative> hah the pdf links take you to the website
18:30:19 <swarley> also rwbarton thank you a bunch
18:30:29 <swarley> it gave me the pdf
18:30:39 <swarley> oh
18:30:52 <applicative> swarley: several of the examples in the examples dir wont work, but the reasons will be known to people here. They can explain the curiosities
18:31:06 <jmcarthur> ddarius: thanks for the recommendation. heard of it, but never have it attention before
18:31:12 <jmcarthur> *gave
18:31:16 <swarley> oh good
18:31:52 <applicative> swarley: there are changes in parsec and the standard libraries and so on, but all trivial
18:31:53 <swarley> so, i know you guys get this a lot probably but, why haskell? (i'm not going to compare languages i just want the strong points of haskell)
18:32:22 <pnielsen> swarley: http://www.haskell.org/haskellwiki/Why_Haskell_matters
18:32:25 <shachaf> swarley: We get it so much that it's in the FAQ.
18:32:27 <shachaf> @where faq
18:32:27 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:32:28 <swarley> oh neat
18:32:34 <pnielsen> swarley: and http://www.haskell.org/haskellwiki/Introduction
18:32:52 <pnielsen> links galore
18:33:02 <rwbarton> also discussed in a pdf file you recently downloaded
18:33:05 <ddarius> swarley: What prompted you to come here in the first place?
18:33:30 <jmcarthur> swarley: my reasons for liking haskell can be summarized as "it makes code relatively easy to reason about", but that's a very distilled version of why i like it
18:34:30 <pnielsen> ddarius: ironically, for me it was the "Haskell: That Girl You Know" story. Luckily I've avoided going (completely) back to my regular gal
18:35:41 <pnielsen> "Chances are, you're going to go back to your regular gal. Haskell's just too much for any one man, probably.  She leaves a trail of broken, brainy, embittered PhDs and former programmers behind her." I remember something like "Challenge accepted." going through my mind
18:35:55 <pnielsen> turned out to be much less scary :)
18:36:20 <pnielsen> at least, that's what got me interested in Haskell. The links above were what convinced me to learn it.
18:36:40 <jmcarthur> swarley: let's put it this way. i recently solved a problem in haskell in a matter of about three minutes, then ported it to another language. the port took me *two hours* to write because it was much more finnicky. this is a much more extreme case than i think most programs are, but it's demonstrative of the gains to be had by pure and non-strict programming (in this case, the big gains were mostly
18:36:42 <jmcarthur> due to non-strictness)
18:37:22 <shachaf> I came into this channel because where else would I find ddarius?
18:37:35 <pnielsen> swarley: I constantly have a feeling of "damn, this is elegant" using Haskell. As long as you're reasonably disciplined, code written in Haskell is performant and extremely easy to maintain.
18:38:09 <jmcarthur> also the haskell version of that program was less than ten lines long, and the port was around 100
18:38:42 <shachaf> jmcarthur: What's the problem and what was the other language?
18:39:03 <ddarius> The real question would: So why didn't you just use the Haskell?
18:39:11 <jmcarthur> shachaf: i can't say what the problem was because i am now using a simple version of it as an interview question
18:39:32 <pnielsen> ddarius: I'll wager it was due to work constraints :)
18:39:35 <jmcarthur> ddarius: because i was going to use it as an interview question and needed to see how hard it would be in a common language
18:39:48 <pnielsen> ah, maybe not
18:39:49 <shachaf> jmcarthur: Don't make me get an interview with you!
18:40:16 <jmcarthur> shachaf: the other language was actually OCaml, but written in a style typical of most mainstream languages
18:40:30 <swarley> i've liked the syntax of haskell for a while
18:40:39 <swarley> but in reading the FAQ
18:40:45 <swarley> curiosity if getting the best of me
18:40:48 <swarley> i've got to know
18:40:50 <zzing> Has anyone read "An Introduction to Category Theory" by Simmons?
18:40:54 <swarley> Also known as "C cast". GHC Haskell has a way to do this, but I dare not speak its name.
18:40:57 <jmcarthur> constrained myself to not use lazy or other forms of delayed evaluation, allowed myself to use mutable data structures, etc.
18:40:58 <shachaf> jmcarthur: Oh, Jane St.?
18:41:10 <swarley> what's the "C cast"?
18:41:11 <ddarius> zzing: I think I read part of it years ago.
18:41:17 <swarley> i mean, i know how to cast in C
18:41:39 <zzing> I want to know if it is any good. I want a good light intro on category theory without burning my wallet. $30 is a nice price.
18:41:40 <shachaf> swarley: It's that.
18:41:51 <swarley> wait seriously
18:41:53 <swarley> like
18:41:58 <swarley> (Double)1
18:41:59 <swarley> ?
18:42:00 <jmcarthur> shachaf: yes, although now i feel like i should clarify for the casual reader that we don't necessarily require that interview candidates use OCaml
18:42:05 <pnielsen> swarley: 1 :: Double
18:42:07 <ddarius> zzing: Oh, then I don't think I've read it.
18:42:07 <shachaf> More like (double*)&x
18:42:18 <pnielsen> swarley: a type assertion
18:42:21 <swarley> thaaaaaaat's ugly
18:42:26 <ddarius> jmcarthur: That would be cruel and unusual.
18:42:38 <Ralith> pnielsen: C casts aren't type assertions.
18:42:48 <ddarius> And type assertions cast nothing.
18:42:49 <pnielsen> Ralith: but his example was a type assertion
18:42:54 * shachaf is surprised that a piece of code is 1/10th the size in Haskell than OCaml.
18:42:59 <swarley> i've never tried OCaml
18:43:01 <pnielsen> or type conversion
18:43:03 <ddarius> pnielsen: No, it wasn't.
18:43:06 <swarley> i use Ruby/C/D
18:43:06 <Ralith> pnielsen: his example was neither C nor Haskell, so I'm not sure what it was.
18:43:09 <pnielsen> alright :)
18:43:12 <jmcarthur> shachaf: i was surprised too. it's normally not quite that different
18:43:23 <swarley> Ralith, i was just trying to figure out what he meant
18:43:25 <jmcarthur> shachaf: like i said, the main difference was the laziness
18:43:34 <shachaf> jmcarthur: You should come up with a new interview question and tell us this one!
18:43:40 <ddarius> swarley: You should learn E.
18:43:45 <swarley> since i said "C cast" and he said that's what it was i assumed it *was* a C cast
18:43:47 <pnielsen> swarley: you should probably read a little more about Haskell. You will rarely need this.
18:43:54 <jmcarthur> i had to go for a wildly different structure to get the same kind of algorithm
18:44:06 <swarley> yeah the FAQ just sparked my interest
18:44:20 <swarley> i have done one or two things in haskell
18:44:25 <swarley> a good while ago though
18:44:33 <jmcarthur> shachaf: if the question is ever retired, i'll bring it back up for you
18:44:51 <swarley> i never became proficient with it though
18:45:01 <swarley> so i lost almost all of my knowledge
18:45:03 <pnielsen> Either way, you'll probably find yourself asserting the type of a literal (::) much more than you will "casting" it
18:45:28 <jmcarthur> shachaf: alternatively, you could apply ;)
18:45:40 <swarley> ddarius, why E?
18:45:50 <ddarius> jmcarthur: Where do you work?
18:45:52 <swarley> i cant tell if that's a joke or not lol
18:46:11 <jmcarthur> shachaf: for the record, i also made up a question that is extremely hard to implement in haskell and much easier in other languages, especially OO ones
18:46:15 <jmcarthur> ddarius: jane street
18:46:21 <shachaf> jmcarthur: And that one's also secret?
18:46:26 <jmcarthur> yeah :\
18:46:32 <ddarius> jmcarthur: Ah.  So the cruel and unusual punishment comes after you're hired.
18:46:33 * shachaf is more curious about that one, actually.
18:46:44 <swarley> jmcarthur, can i ask what the question was?
18:47:01 <ddarius> swarley: I reject the law of the excluded middle.
18:47:10 <jmcarthur> swarley: sorry, i can't answer that
18:47:14 <swarley> :(
18:47:26 <shachaf> You can ask as much as you want, swarley.
18:47:31 <jmcarthur> ddarius: i don't understand the jab
18:47:33 * swarley just got done doing a lot of programming in ruby
18:47:34 <shachaf> If that makes you feel better.
18:48:06 <shachaf> jmcarthur: <jmcarthur> shachaf: yes, although now i feel like i should clarify for the casual reader that we don't necessarily require that interview candidates use OCaml <ddarius> jmcarthur: That would be cruel and unusual.
18:48:17 <jmcarthur> ah i see
18:48:33 <swarley> should i try OCaml some time?
18:48:45 <swarley> never even seen an example
18:48:50 <pnielsen> jmcarthur: why the switch to OCaml? You used Haskell previously, right?
18:48:52 <ddarius> For all X, the answer to "Should I try X some time?" is yes.
18:48:59 <jmcarthur> swarley: in my opinion, if you learn haskell you will never have much of a reason to learn ocaml unless it's for a job or something
18:49:05 <swarley> AH
18:49:08 <jmcarthur> pnielsen: i still do, at home
18:49:12 <swarley> _.lowercase
18:49:17 <pnielsen> jmcarthur: by you I mean Jane St., sorry
18:49:28 <pnielsen> I thought I saw a few talks about Haskell from Jane St. May be mistaken.
18:49:32 <jmcarthur> swarley: well, ddarius is right, no reason not to at least look into it and form your own opinion
18:49:44 <jmcarthur> pnielsen: nah, they were OCaml, for sure
18:49:49 <swarley> ddarius, i think that goes awry at BrainFuck
18:50:05 <ddarius> I don't think so.
18:50:08 <jmcarthur> i think brainkfuck is a great language to learn
18:50:09 <pnielsen> swarley: people say it so much that it's almost cliche, but it's true: Learning Haskell will make you a better programmer, even if you don't use Haskell
18:50:17 <pnielsen> jmcarthur: my bad
18:50:25 <shachaf> pnielsen: It might make you a worse programmer.
18:50:37 <pnielsen> shachaf: because you're angry that you're not using Haskell?
18:50:51 <jmcarthur> brainfuck a good demonstration of how little is necessary to make a programming language. it also teaches you the value of abstraction
18:51:10 <swarley> yeah, i aim to learn haskell to a near fluent use. Given, i don't lose time within the months it will take
18:51:12 <ddarius> It also teaches you the value of not Peano numbers.
18:51:24 <swarley> what about LOLCODE?
18:51:29 <pnielsen> CAN HAZ STDIO?
18:51:30 <swarley> :p
18:51:34 <jmcarthur> swarley: touche
18:51:34 <swarley> KTHXBAI
18:51:39 <shachaf> pnielsen: Because you're thinking about types all the time, perhaps.
18:51:40 <pnielsen> learning Haskell is time better spent
18:51:59 <swarley> yeah. I need a break from the usual
18:52:29 <swarley> i can code ruby without thinking generally. So i figured coming from an OO language this would give me the most challenge
18:52:40 <pnielsen> shachaf: I haven't noticed a detriment in my performance using languages with inferior type systems, but maybe I haven't used Haskell enough
18:52:45 <swarley> it was either this or tcl
18:52:48 <swarley> HAHA JUST KIDDING
18:52:54 <swarley> i would never use TCL
18:52:58 <pnielsen> swarley: "Haskell or node.js"
18:53:05 <swarley> lolol
18:53:27 <swarley> i wish V8 had a system type interpreter
18:53:29 * ddarius isn't sure which is slower between (the primary implementations of) Ruby and Tcl.
18:53:37 <swarley> uh tcl
18:53:38 <pnielsen> shachaf: it does annoy me though, that I can't express as much with types
18:53:48 <swarley> ruby 1.9.3 is a lot faster
18:53:49 <jmcarthur> swarley: once you get used to using haskell, you will notice that you apparent ability to code ruby without thinking isn't actually so. going back to ruby, you will find that you are thinking *very hard*, and always were. at least, that was my experience trying old languages after getting used to haskell
18:53:58 <ddarius> swarley: That's what I though, but ruby impresses me sometimes.
18:53:58 <pnielsen> to be fair, TCL is all strings. Ruby is hardly fast, though
18:54:11 <swarley> pnielsen, when was the last time you used ruby? :p
18:54:28 <swarley> it had i think a 200% speed up from 1.8 to 1.9
18:54:48 <ddarius> Ruby needs a -lot- more than a 200% speed up...
18:54:51 <jmcarthur> 200% faster isn't fast considering where it was
18:54:55 <pnielsen> swarley: I use ruby pretty regularly. Anecdotally, and judging from virtually all benchmarks out there, Ruby is orders of magnitudes slower than a language like Haskell, Java, C, Go, etc.
18:55:09 <pnielsen> swarley: Like 40x slower
18:55:21 * shachaf wonders whether any languages matches the description "like Haskell, Java, C, Go, etc."
18:55:40 <jmcarthur> Haskell, Java, C, and Go, at least
18:55:53 <pnielsen> C++ and D? :)
18:55:56 <jmcarthur> assuming that was an implicit "or" rather than an implicit "and"
18:56:07 <pnielsen> it was an or
18:56:17 <swarley> pnielsen, you're comparing an interpreted language with compiled/bytecode languages
18:56:37 <pnielsen> swarley: Haskell can be interpreted if you want it to. In production, it isn't
18:56:44 <swarley> still
18:56:55 <swarley> i'm assuming haskell isn't generally dynamically evaluated
18:56:57 <pnielsen> swarley: Ruby is slow compared to most other dynamic languages too, e.g. Python
18:57:08 <swarley> yes it is
18:57:10 <swarley> however
18:57:12 <ddarius> As far as I know, the only (AST) interpreter for Haskell was Hugs.
18:57:26 <swarley> python has had a lot more time to be optimized
18:57:33 <ddarius> As has Tcl.
18:57:51 <swarley> tcl feels like coding in mSL
18:58:19 <pnielsen> swarley: Ruby was released 4 years after Python
18:58:24 <jmcarthur> most language implementations have a VM of some sort, compiled or not, which can make study of compiled languages rather like studying the runtime of interpreted languages. i also think there is little stopping languages that are typically interpreted from actually being compiled.
18:58:27 <swarley> that's still time
18:58:48 <pnielsen> swarley: http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php
18:58:50 <pnielsen> Perl is slower :)
18:58:52 <swarley> well yes there is rubinus
18:59:11 <pnielsen> I know the shootout should be taken with a grain of salt, but in my experience this is a pretty accurate place for Ruby
18:59:19 <benmachine> jmcarthur: I've always thought the ability to support an eval() function must defeat a lot of what usually goes on in compilation
18:59:41 <benmachine> jmcarthur: in that you have to keep symbolic names for everything around, and scopes intact
18:59:43 <swarley> lol @ fortran
18:59:44 <benmachine> unmolested
18:59:56 <benmachine> but I guess you can still do some things, at least to the rest of the code
18:59:58 <jmcarthur> benmachine: it defeats many of the gains, sure. this applies to Haskell, too
19:00:00 <pnielsen> swarley: check out Lisp :)
19:00:09 <dolio> Lisp does way better than Ruby does.
19:00:09 <swarley> i've seen lisp
19:00:16 <dolio> Under the same constraints.
19:00:27 <pnielsen> or Erlang
19:00:48 <swarley> well
19:00:52 <jmcarthur> wow, ghc isn't doing so hot in the shootout these days
19:00:53 <swarley> at the end of the day
19:01:12 <swarley> perl6 is still slower at least :) (rakudo)
19:01:13 <pnielsen> jmcarthur: nope, used to be next to C/C++ IIRC
19:01:18 * jmcarthur considers trying some micro-optimization
19:01:28 <dolio> Most of the shootout code is probably bit rotted.
19:01:34 <pnielsen> dolio: nah
19:01:35 <applicative> jmcarthur: there are a lot of curiosities.  I was trying to figure out one the other day.
19:01:36 <ddarius> What dolio said.
19:01:36 <jmcarthur> pnielsen: well, it was pretty high up there, but i think C++ was still a clear victor
19:01:43 <ddarius> I doubt many have been significantly looked at in years.
19:02:06 <pnielsen> ddarius, dolio: most language authors take writing performant benchmarks for the alioth shootout pretty seriously since so many people make decisions based off of it (even though making decisions based on one benhcmark suite is clearly wrong)
19:02:20 <jmcarthur> fannkuch-redux :(
19:02:26 <dolio> I'm talking about the Haskell code.
19:02:27 <ddarius> pnielsen: Yes, as did the Haskell community, particularly dons, several years ago.
19:02:31 <pnielsen> jmcarthur: Yeah, if I recall it was after C++
19:02:53 <dolio> Nobody's worked on the Haskell code seriously in years, unless they've been doing it in secret.
19:02:57 <pnielsen> if nobody looks at them anymore, sure
19:03:04 <pnielsen> somebody should
19:03:06 <pnielsen> :)
19:03:11 * pnielsen cheers on jmcarthur
19:03:21 * BMeph nominates pnielsen!
19:03:30 <pnielsen> hah, yeah, I'll do that
19:03:34 <pnielsen> It'll be Ruby, Perl, then GHC Haskell
19:03:37 <bigfg> what do i need to install for Diagrams.Backend.Cairo.CmdLine_
19:03:38 <bigfg> ??
19:03:40 <YayMe> dolio: Did I just hear you exclaim haskell is not actively being developed?
19:03:50 <pnielsen> YayMe: just the alioth benchmarks
19:03:50 <jmcarthur> i'll take a look at fannkuch-redux
19:04:01 <bigfg> i already installed cairo, diagrams, gtk2hs
19:04:17 <YayMe> pnielsen: Oh. I was going to say, I should hope people are still working on Haskell, and I would be really surprised if not
19:04:20 <dolio> And occasionally GHC makes changes that slow down code written in a certain way to cause nice things to happen.
19:04:24 <pnielsen> YayMe: yeah, don't worry
19:04:34 <byorgey> bigfg: that module is in the diagrams-cairo package
19:04:40 <dolio> And makes nice things happen to other code.
19:04:52 <pnielsen> I like when nice things happen
19:05:04 <byorgey> bigfg: which you should have gotten automatically if you did 'cabal install diagrams'
19:05:11 <bigfg> requested packages are already installed
19:05:12 <byorgey> bigfg: are you having a specific problem?
19:05:24 <benmachine> YayMe: GHC is developed at somewhat break-neck speed
19:05:33 <bigfg> well i'm not being able to find this CmdLine file
19:05:50 <swarley> meh, i never said haskell was slow, nor ruby was fast. Just said it was *faster* :p
19:05:53 <ddarius> The entire Haskell ecosystem is going at break-neck speed.
19:05:59 <YayMe> yeah it seems it
19:06:05 <byorgey> bigfg: can you paste your code along with the error message somewhere (e.g. hpaste.org)?
19:06:06 <YayMe> which is why I found that a strange statement
19:06:06 <swarley> although, does anyone program in fortran anymore?
19:06:12 <bigfg> swarley, ruby is a piece of crap
19:06:12 <rwbarton> bigfg: also where is the code from
19:06:19 <shachaf> It *was* going at break-neck speed.
19:06:23 <shachaf> Then it broke its neck.
19:06:27 <bigfg> rwbarton, from http://projects.haskell.org/diagrams/manual/diagrams-manual.html#preliminaries
19:06:30 <shachaf> (That happens when you go at break-neck speed.)
19:06:32 <swarley> bigfg, language wars never end well. i'm not trying to start one either lol
19:06:36 <benmachine> shachaf: you can break your neck more than once
19:06:40 <ddarius> swarley: Probably a -lot- more people than people writing Haskell.
19:06:44 <benmachine> shachaf: so many vertebrae, so little time
19:06:52 <rwbarton> ah I see
19:06:59 <bigfg> swarley, this is not a language war, because ruby is not a language
19:07:01 <dolio> Ruby has a real call/cc. Therefore it's superior to Haskell.
19:07:17 <benmachine> swarley: a lot of academic science programming is done in fortran, I hear
19:07:17 <swarley> okay, so you mean MRI
19:07:18 <pnielsen> swarley: many people
19:07:21 <ddarius> Maybe one day Agda will get a real call/cc.
19:07:33 <pnielsen> bigfg, swarley: Ruby is a language for a framework
19:07:39 <swarley> what
19:07:43 <swarley> oh rails
19:07:48 <swarley> no rails can suck a dick
19:07:48 <pnielsen> Rails makes Ruby.
19:08:00 <bigfg> crappy web programming makes ruby?
19:08:00 <applicative> jmcarthur: yes fannkuch is the one that was baffling.  It used to be fast, but I guess was tuned to ghc-6.8 or something
19:08:14 <pnielsen> bigfg: Can definitely say that about node.js
19:08:17 <swarley> rails is like, the pain in my ass that will never be lifted
19:08:20 <bigfg> can you unambiguously determine what this code does? `puts puts`
19:08:24 <pnielsen> bigfg: that's essentially a product for people who don't know better
19:08:29 <byorgey> bigfg: also, feel free to join #diagrams
19:08:32 <shachaf> bigfg: It puts puts.
19:09:02 <jmcarthur> applicative: it looks like it's just list manipulation with no parallelism, to me
19:09:04 <bigfg> shachaf, the only way to answer is with a tautology i see
19:09:07 <jmcarthur> kind of naive, in fact
19:09:12 <bigfg> byorgey, ok :)
19:09:39 <applicative> wait, am i mixing them up? i mean http://shootout.alioth.debian.org/u64q/program.php?test=fannkuchredux&lang=ghc&id=3
19:09:43 <shachaf> bigfg: (Isn't it pretty unambiguous, though?)
19:10:01 * ddarius is pretty sure Agda with a real call/cc would be superior to Agda without.
19:10:20 <bigfg> shachaf, that's my point, but it is valid ruby, which is also my point (ie, it sucks)
19:10:39 <shachaf> bigfg: ?
19:10:41 <dolio> Except delimited continuations are even better than call/cc.
19:10:55 <jmcarthur> applicative: the one linked from http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=ifc is http://shootout.alioth.debian.org/u64q/program.php?test=fannkuchredux&lang=ghc&id=1
19:10:58 <dolio> So forget call/cc.
19:11:03 <bigfg> this is not a matter of 'understanding the context of execution'. this is illegible, garbage code no matter how you look at it
19:11:09 <copumpkin> dolio: you mean free monads?
19:11:19 <dolio> ...
19:11:20 <shachaf> bigfg: I'd expect it to print two newlines. Which it does.
19:11:34 <bigfg> shachaf, unless... `puts = 3; puts puts`
19:11:43 <shachaf> Oh, yes, that.
19:11:46 <ddarius> dolio: True dat.
19:11:47 <jmcarthur> applicative: interesting. the one you linked is faster. i wonder why the slower one is the one it shows
19:11:51 <applicative> jmcarthur: right, that's the point I was surprised by. The simple one you  notice is now doing better than the other, super fancy optimized c-like one, which times out
19:11:58 <jmcarthur> oh?
19:12:02 <jmcarthur> maybe i misread something
19:12:02 <dolio> Actually, you can do shift/reset as a free monad.
19:12:07 <dolio> Unlike call/cc, I think.
19:12:21 <swarley> well you can be annoyingly specific and use STDIO.puts
19:12:33 <swarley> errr
19:12:35 <swarley> $>.puts
19:12:39 <jmcarthur> applicative: ah you're right
19:12:44 <ddarius> > let puts :: forall a. a -> a; puts x = x in puts puts
19:12:45 <hpaste> bfig pasted ‚Äúerror diagram‚Äù at http://hpaste.org/75463
19:12:45 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:12:46 <lambdabot>    arising from a use of `...
19:13:25 <swarley> well the other thing about that example, is hoping that you know what puts is before hand
19:13:36 <dolio> Because Andrej Bauer did shift/reset in Eff, and all the effects in there are free monads.
19:13:51 <jmcarthur> applicative: what are the rules on libraries? is it just ghc standard libraries or the platform or some other collection? i can't find anything on this on the web site
19:14:36 <applicative> jmcarthur: my impression is that he has the platform and is willing to cabal install even; just from things dons said in the past
19:15:05 <jmcarthur> ah cool
19:15:24 <applicative> dons represents him as sympathetic and reasonable
19:16:21 <jmcarthur> even if some disagree with that, you have to admit he's in an impossible position
19:17:14 <applicative> yes.  I once had the idea that it was in some sense unreasonable but I think dons' attitude was correct
19:18:12 <pnielsen> on a related note, can somebody tell me "Why Agda?" (vs. Haskell)?
19:18:20 <pnielsen> broad strokes
19:18:42 <applicative> strange? wonderful?
19:18:45 <dolio> Fancier types.
19:18:47 <pnielsen> I see somebody talking about Agda inhere several times per day
19:18:50 <pnielsen> Maybe I should just take a look at it :)
19:18:55 <bigfg> swarley, which puts?
19:19:05 <bigfg> `puts (puts puts {puts; puts puts})` ?
19:19:10 <pnielsen> applicative: that's very scary coming from a haskeller :)
19:19:17 <swarley> the first puts would be Kernel.puts if you want to be anal about it
19:19:29 <dolio> And 'well typed programs can't go wrong' in even stronger ways.
19:19:34 <bigfg> really? you mean like i can't shadow the definition?
19:19:58 <startling> what's a nice synonym for "return" for languages where "return" is a keyword?
19:20:01 <swarley> i mean a sensible programmer wouldnt use multiple puts
19:20:02 <dolio> (Or, well typed and termination checked.)
19:20:10 <applicative> pnielsen: the IO aspect is a little undeveloped
19:20:25 <applicative> pnielsen: unless your idea of IO is complaints from the typechecker
19:20:40 <dolio> I wouldn't necessarily use Agda for real programs, though.
19:20:41 <bigfg> swarley, a sensible programmer would stay the hell away from ruby too
19:20:46 <YayMe> I've been reading Steve Yegge's old blog posts lately, I haven't felt I should care about Ruby at all until reading the stuff he says. Seems like a smart fella but I'm not convinced. I was just reading a post of his where he did an example of why Ruby is good, he started saying "If you want to list all the words in a dictionary that start with Q in order of size and alphabetically" Before scrolling down I thought for a moment and came
19:20:46 <YayMe> up with this in my head: map sort $ map (\n -> filter ((==n) . length) someDict) [1..] but then I scroll down and see 20 lines of imperative code
19:21:16 <swarley> And a sensible programmer would drop it because i already said i didn't want to fight over languages..
19:21:17 <YayMe> I was expecting to see some ruby translation similar to what I wrote, but nope.
19:21:25 <bigfg> i wrote a ruby compiler, i can tell you exactly when it went bad: everywhere
19:21:31 <swarley> i'm not here on a pilgrimage
19:21:42 <bigfg> then stop comparing haskell to ruby
19:21:45 <swarley> i'm not..
19:21:59 <swarley> i literally never compared the two
19:22:18 <swarley> i'm here because i'm learning haskell lol
19:22:43 <jmcarthur> yeah, bigfg, i think you must have misinterpreted something. i haven't read anything swarley said as being a comparison of ruby and haskell
19:22:57 <YayMe> I think I'm going to go play with Ruby myself as I'm curious and read many people who seem to know what they're doing actually like it a lot, but the example I read made one thing clear, haskell sure has changed the way I think about doing some things.
19:23:16 <pnielsen> jmcarthur, bigfg: the temperature rising was probably due to a collective effort
19:23:17 <shachaf> YayMe: To be fair, your code is wrong.
19:23:24 <dolio> I don't think you should take anything Steve Yegge writes seriously.
19:23:38 <YayMe> shachaf: I figured so, but I'm guessing it's nearly right and easily corrected if I popped it into ghci
19:23:44 <pnielsen> applicative: I see. So a more formal/strict type system, very cool for proofing, but not nearly as real-world as Haskell.
19:23:55 <bigfg> yeah sorry it is just that i hate ruby and the whole programming hippie movement
19:24:28 <swarley> i don't *love* ruby, its just the language i can use the most easily as of present
19:24:31 <bigfg> ruby is everything that's wrong with programming multiplied by itself in a multidimensional ball of suck
19:24:31 <YayMe> shachaf: It was written off the top of my head in here, the general idea is right no?
19:24:48 <pnielsen> bigfg: It's sad that node.js makes Ruby look good :)
19:24:59 <bigfg> (don't take it personal... unless your name is Yukihiro)
19:25:10 <swarley> lol no i'm not matz
19:25:14 <shachaf> YayMe: It would, uh, probably work...
19:25:23 <shachaf> Other than the "starts with Q" bit.
19:25:45 <shachaf> But it's a pretty terrible way of doing it. :-(
19:25:51 <YayMe> Oh yeah I was going to add a filter on for that
19:25:57 <shachaf> And it also doesn't do everything his code does.
19:26:14 <pnielsen> YayMe: Haskell is the best language for oneliners that I've ever used
19:26:27 <pnielsen> YayMe: and, surprisingly, a lot of them are readable
19:26:31 <pnielsen> at least if you don't ask questions in #haskell
19:26:55 <clsmith> i must admit it makes me cry when people claim that dynamic languages are better than static, as though /not checking for obvious errors at compile-time/ but instead erroring out at run-time can *ever* be a good thing. <.<
19:26:59 <pnielsen> although, to be fair, it usually boils down to something very elegant
19:27:39 <clsmith> there are tears.
19:27:45 <pnielsen> clsmith: We need to be agile. Web scale, continuous integration, RESTful frameworks and evented loops. DRY and KISS and also other acronyms
19:28:15 <swarley> clsmith, oh no i would love to have type assurance in ruby. I think static typing can be great for most situations
19:28:38 <bigfg> wait... what?
19:28:41 <shachaf> @quote _pizza_
19:28:41 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
19:28:52 <YayMe> haha
19:28:54 <bigfg> ruby is based on 'fuck everyone, just hack it'
19:28:55 <clsmith> lol
19:29:06 <swarley> okaaay..
19:29:08 <pnielsen> clsmith: http://vooza.com/ (view "Radimparency") sums it up pretty well
19:29:32 <shachaf> YayMe: Fortuantely there's an even shorter one-liner for "sort by length then alphabetically".
19:29:42 <YayMe> shachaf: well I'm sure there's some better haskelly way to do it if mine's so awful, but I'm also sure the better way is at least as terse if not more so
19:29:48 <swarley> i was just saying that having a java style object type declaration would be nice
19:29:55 <shachaf> 02:43 <maukd> > sortBy (comparing length `mappend` compare) (words "das salz verzehrt den leib des mohren")
19:29:57 <bigfg> barf
19:30:24 <bigfg> i like haskell typeclasses better
19:30:39 <shachaf> Haskell type classes are the devil.
19:30:54 <bigfg> really? why do you say so?
19:31:12 <pnielsen> (Unique) constructors/record syntax made me a little uncomfortable at first, but now I like it, and lenses make it less annoying
19:31:56 <pnielsen> once you understand that they're function it becomes very powerful
19:31:58 <YayMe> swarley: what are you talking about? haskell's ADT records (let's get it out of the way: everyone dislikes the record function scoping thingy, I know) are just as complete as a java class sans the methods for which type classes actually do a better job
19:31:59 <pnielsen> functions*
19:32:14 <pnielsen> YayMe: he's talking about java objects for Ruby, not Haskell
19:32:21 <YayMe> o
19:32:24 <shachaf> That sounds off-topic.
19:32:24 <swarley> no i think haskell is perfect as is
19:32:44 <YayMe> Ruby doesn't have classes?
19:32:49 <swarley> it does
19:32:52 <shachaf> In fact the last few pages of conversation in here have been off-topic.
19:32:56 <swarley> but objects aren't bound to them
19:33:12 <shachaf> You might prefer to talk about Ruby in #ruby-lang. :-)
19:33:14 <YayMe> shachaf: conversation in here is pretty frequently off topic
19:33:29 <pnielsen> shachaf: so which alioth benchmark are you going to improve? :)
19:33:31 <swarley> shachaf, it was in reference to "i must admit it makes me cry when people claim that dynamic languages are better than static, as though /not checking for obvious errors at compile-time/ but instead erroring out at run-time can *ever* be a good thing. <.<"
19:33:39 <shachaf> pnielsen: Huh?
19:33:52 <pnielsen> We can discuss that
19:33:53 <swarley> i didn't mean to spark a whole off topic conversation anyway :p
19:33:57 <shachaf> swarley: That sounds like someone is either preaching to the choir or trying to start a flame war. Neither is particularly appealing.
19:34:16 <Nisstyre-laptop> swarley: the whole point is that it avoids having to do type checking
19:34:21 <Nisstyre-laptop> at compile time that is
19:34:29 <swarley> i'm not against type checking
19:34:30 <swarley> i like it
19:34:38 <swarley> i'm not the author of the post
19:34:49 <swarley> that i was referencing
19:36:55 <newsham> in fairness on the dynamic languages front, there are things you cannot express in a tractable type system
19:37:01 <YayMe> shachaf: I'm curious what is the more appropriate way to do that? I always like seeing the proper way to do haskell stuff since I never stumble into it
19:38:06 <Nisstyre-laptop> newsham: unless you're willing to wait 2^100 years for my program to compile >.>
19:38:12 <Nisstyre-laptop> s/my/your/
19:39:48 <BMeph> me believes that there is a difference between not having to do type checking, and not doing type checking...
19:40:00 * BMeph believes that there is a difference between not having to do type checking, and not doing type checking...
19:40:19 <BMeph> Le sigh.
19:43:39 <clsmith> newsham: yes, but that doesn't stop you from typechecking the basics
19:43:51 <clsmith> (they don't do /any/)
19:47:39 <YayMe> Does anyone here know if ruby has function composition?
19:48:13 <jmcarthur> i'm sure you could define it, but it might be awkward to use
19:48:21 <YayMe> so it doesn't come with it
19:48:53 <mapreduce> Possibly not the most authoritative channel on Ruby.
19:49:15 <shachaf> YayMe: I'm sure #ruby-lang knows.
19:49:21 <YayMe> mapreduce: Yes, but I went to #ruby-lang to ask and I guess not just anyone can talk in there
19:49:25 <Lamen> @remember maukd > sortBy (comparing length `mappend` compare) (words "das salz verzehrt den leib des mohren")
19:49:26 <lambdabot> I will never forget.
19:49:36 <shachaf> lambdabot: ?
19:49:36 <lambdabot> Maybe you meant: . ? @ activity activity-full admin all-dicts arr ask b52s babel bf bid botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add
19:49:37 <lambdabot> djinn-clr djinn-del djinn-env djinn-names djinn-ver do docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber flush foldoc forget fortune
19:49:37 <lambdabot> fptools free freshname ft gazetteer get-shapr ghc girl19 google googleit gsite gwiki hackage help hitchcock hoogle hoogle+ id ignore index instances instances-importing irc-connect jargon join karma
19:49:37 <lambdabot> karma+ karma- karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on nixon oeis offline
19:49:37 <lambdabot> oldwiki palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc
19:49:38 <lambdabot> read reconnect remember repoint run shootout show slap smack source spell spell-all src tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc
19:49:40 <lambdabot> topic-tail topic-tell type undefine undo unlambda unmtl unpf unpl unpointless uptime url v vera version vote web1913 what where where+ wiki wn world02 yarr yhjulwwiefzojcbxybbruweejw yow
19:49:41 <mapreduce> YayMe: http://blog.moertel.com/articles/2006/04/07/composing-functions-in-ruby
19:49:43 <shachaf> ...Oops.
19:49:48 <shachaf> Lamen: ?
19:49:52 <mapreduce> ..nazi?
19:50:17 <shachaf> mapreduce: Corrects people's spelling without being asked, I think.
19:50:22 <mapreduce> haha
19:50:37 <Lamen> shachaf: Thought that one is a very good one-liner...
19:50:39 <shachaf> @nazi-on
19:50:39 <lambdabot> Spelling nazi engaged.
19:50:51 * YayMe pondres
19:50:54 <shachaf> Lamen: Yes, but it's a very common one.
19:50:55 <Lamen> worth remembering
19:51:20 <shachaf> I don't think it's maukd's in particular.
19:51:23 <rwbarton> zgyohistomorphic prepormorphism
19:51:25 <mapreduce> I thnik this cuold have an inserve affect on the chnanel.
19:51:35 <shachaf> I think it's broken.
19:51:36 <shachaf> @nazi-off
19:51:36 <lambdabot> Spelling nazi disengaged.
19:52:02 <Lamen> @forget maukd > sortBy (comparing length `mappend` compare) (words "das salz verzehrt den leib des mohren")
19:52:02 <lambdabot> Done.
19:52:30 <Lamen> shachaf: my bad. remembered locally :)
19:54:19 <Lamen> Has someone already started something like "my favorite Haskell one-liner collection" or "common Haskell idioms"?
19:54:25 <shachaf> Yes.
19:55:30 <Lamen> where can I find it, please!
19:55:40 <clsmith> shachaf: someone is in an offish mood ~
19:56:08 <shachaf> clsmith: Yes. :-(
19:56:22 <shachaf> But that's what #haskell is for, right?
19:56:34 <clsmith> not as far as i know
19:59:46 <YayMe> shachaf: only if writing haskell makes you feel better
20:05:03 <shachaf> @djinn Not (Not (Not a)) -> Not a
20:05:03 <lambdabot> f a b = void (a (\ c -> c b))
20:05:29 <chrisb> any manatee users here?
20:06:06 <copumpkin> I only use dugongs myself
20:07:01 <shachaf> copumpkin: What about sea lions?
20:07:22 <copumpkin> nah, only sirenia
20:11:11 <applicative> hm the stream type has changed in the vector package
20:11:42 * applicative  experiences a crisis
20:11:44 <ddarius> "Compressive sensing is also referred to in the literature by the terms: compressed sensing, compressive sampling, and sketching/heavy-hitters."
20:15:20 <bgamari> Is there any reason why this wouldn't work?
20:15:21 <bgamari>     (s,s') `deepseq` return ()
20:15:35 <bgamari> Would the optimizer optimize this out?
20:15:52 <shachaf> That depends on what "work" means.
20:16:16 <shachaf> You should ask ddarius about deepseq, though.
20:16:53 <Cale> bgamari: no, that'll work, so long as the types of s and s' are appropriate for deepseq
20:17:05 <shachaf> deepseq is often not what you want.
20:17:12 <shachaf> Unless you want the devil. Because deepseq is the devil.
20:17:43 <bgamari> I'm trying to concurrently evaluate some expressions before passing them to a thread that is serializing my state updates
20:17:53 <bgamari> yet it seems like the state update thread is too busy
20:18:28 <bgamari> I really want to ensure that the worker thread has done everything it can do before it passes on the state update request
20:18:31 <bgamari> hence the deepseq
20:20:01 <bgamari> Cale, What do you mean by "are appropriate for deepseq"?
20:20:33 <applicative> NFData instances?
20:21:35 <bgamari> hmm, I guess "deriving (NFData)" won't do the right thing, eh?
20:21:55 <bgamari> in the case of a newtype with GeneralizedNewtypeDeriving
20:22:12 <shachaf> I'd expect it to do what you intend with GeneralizedNewtypeDeriving.
20:22:14 <shachaf> Why wouldn't it?
20:22:29 <bgamari> yeah, I suppose so
20:22:49 <bgamari> I guess newtype Hi = Hi Int deriving (NFData) would just get the instance for Int
20:23:02 <bgamari> crap
20:23:08 <bgamari> well that's not good
20:23:16 <bgamari> maybe these Map updates are more expensive than I thought
20:23:36 <shachaf> ?
20:24:30 <Xezlec> Hello
20:24:38 <bgamari> shachaf, My state is in a Data.Map.Map
20:24:47 <applicative> hell Xezlec
20:24:56 <bgamari> the worker thread computes a state update request
20:25:05 <Xezlec> I'm trying to learn Haskell and am surprised by the type system
20:25:06 <shachaf> Please excuse applicative. He's always like that.
20:25:07 <Jafet> deriving NFData works mostly by coincidence.
20:25:26 <bgamari> and passes the forced state update request to the diffWorker
20:25:32 <applicative> sorry Xezlec! I'm keyboard challenged....
20:25:40 <bgamari> which then perform the update on the global state
20:25:44 <bgamari> performs*
20:25:53 <Xezlec> applicative: Maybe you don't have the right keyboard
20:25:55 <shachaf> bgamari: deepseqing a Map is going to traverse the whole thing
20:26:07 <bgamari> shachaf, I don't deepseq the map
20:26:15 <Cale> Xezlec: Feel free to ask any questions you might have.
20:26:16 <applicative> Xezlec: I melted my space bar, it makes things complicated
20:26:33 <bgamari> shachaf,  https://github.com/bgamari/bayes-stack/blob/v2/BayesStack/Core/Gibbs.hs#L49
20:26:40 <Xezlec> applicative: I appreciate someone who enjoys a challenge.
20:26:53 <bgamari> that should explain it better than english ever could
20:26:54 <Xezlec> but that's a drastic thing to do
20:28:04 <Xezlec> Anyway what I was wondering: when you look at how Either is defined as an instance of Functor, it really has to use Right as the mapped side
20:28:26 <Cale> yes
20:28:37 <shachaf> Xezlec: Yep. You'd have to use a flipped newtype or something to use Left.
20:28:38 <Xezlec> Because you cn't flip the arguments to the type constructor
20:28:45 <bgamari> shachaf, ModelState (ms) contains several maps
20:28:50 <shachaf> The order of type parameters is important.
20:28:57 <Xezlec> newtype?  is that something I don't know about?
20:29:10 <gwern> @remember camccann you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
20:29:11 <lambdabot> Okay.
20:29:15 <gwern> @quote debug
20:29:15 <lambdabot> dons says: disable the type checker in ghc for 6 months and we'd have 5 debuggers at the end of it :)
20:29:22 <gwern> @quote debug
20:29:23 <lambdabot> lennart says: the best way of debugging is to understand your code
20:29:27 <gwern> bah, whatever
20:29:28 <gwern> @flush
20:29:35 <bgamari> shachaf, Setting uu is usually a pretty small (but difficult to compute) value
20:29:36 <shachaf> gwern: He's called "cmccann" around here.
20:29:54 <gwern> shachaf: yeah well that wasn't *from* 'round here, stranger
20:30:14 <shachaf> gwern: Well, I am rubber, you are glue!
20:30:26 <shachaf> And that's not how @remember works.
20:30:34 <shachaf> @forget camccann you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
20:30:34 <lambdabot> Done.
20:30:37 <Xezlec> Anyway, coming from C++ I guess I expected the type system to be Turing-complete, but it seems there ain't much in the way of meta-functions that manipulate types
20:30:38 <shachaf> @remember cmccann you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
20:30:38 <lambdabot> It is forever etched in my memory.
20:31:03 <shachaf> Xezlec: The type system is Turing-complete if you turn on enough extensions.
20:31:10 <shachaf> But being Turing-complete isn't a desirable property in a type system.
20:31:15 <applicative> Xezlec: if you want to bring something under a type class like Functor but in a new way, you 'newtype it', saying newtype Or b a = Or (Either a b) then writing your functor instance
20:31:18 <shachaf> Well, not fundamentally desirable, at least.
20:31:51 <gwern> @flush
20:32:01 <Xezlec> shachaf: why not?  It seems like the swapping arguments and such would be useful things to do
20:32:08 <Cale> Xezlec: newtype is similar to data, but you can only have one constructor with one field, and it has slightly different semantics when pattern matching such that the compiler is able to boil away the constructors so they don't use space at runtime.
20:32:28 <Cale> (it can just implement the new datatype with whatever representation the old one had)
20:32:33 <shachaf> Xezlec: It makes things complicated.
20:32:36 <shachaf> (Impossible.)
20:32:38 <Xezlec> Cale: ok, I see
20:32:38 <ddarius> Boiled code has no flavor.
20:32:56 <Xezlec> Hm.
20:33:08 <YayMe> ddarius: is that the problem with java?
20:33:26 <Xezlec> Well if impossible is too complicated for your taste...
20:33:28 <Cale> Xezlec: Remember that you want to be able to infer the types of things as well, not just to check programmer-given types
20:33:31 <applicative> so in this case you would go on , instance Functor (Or a) where fmap f (Or (Left a)) = Or (Left (f a)) etc, which is a bit tiresome but otherwise the class system would go to hell
20:34:28 <Xezlec> would providing a way to flip the arguments really damn the type system?  it's hard to see how
20:34:49 <applicative> Xezlec: you wouldn't want two opposed Functor instances for Either.
20:35:01 <applicative> Xezlec: there are other classes, eg. Bifunctor
20:35:39 <Cale> Xezlec: suppose you wrote both fmap instances, and I write something like  fmap (+1) (Left 4)
20:35:39 <applicative> instance Bifunctor Either where bimap f g (Left a ) = Left (f a); bimap f g (Right b) = Right (g b)
20:35:41 <applicative> if you like
20:35:55 <Cale> Xezlec: what is the result? Which instance does it select?
20:36:05 <Xezlec> I'm not saying have two instances
20:36:10 <shachaf> Cale: Nondeterministically both of them!
20:36:40 <shachaf> Xezlec: Someone might define another instance later.
20:36:42 <Xezlec> I'm saying if I were writing Either the first time, I would want to choose which argument it presented to Functor
20:36:56 <Xezlec> shachaf: Then error out, just like usual
20:36:56 <ion> shachaf: And if it‚Äôs an Either Integer String, the String is coerced into an Integer before the (+1).
20:37:02 <ddarius> shachaf: If it's both of them, it wouldn't be very non-deterministic.
20:37:07 <applicative> Xezlec: then you would swap what you call left and right.
20:37:30 <bgamari> Is there any way to label a thread with a name?
20:37:40 <gwern> ThreadId?
20:37:43 <rwbarton> @type forkIO
20:37:44 <lambdabot> Not in scope: `forkIO'
20:37:45 <bgamari> for identification in the eventlog
20:37:47 <bgamari> yeah, alright
20:37:48 <Xezlec> applicative: unless I have another typeclass that I want to use it with that has the opposite problem
20:38:04 <bgamari> I was hoping there'd be something a bit more descriptive than ThreadId
20:38:38 <shachaf> ThreadYoudWhat?
20:38:56 * Xezlec laughs slowly
20:39:02 <Cale> Xezlec: what you're talking about would be useful, but in order to do it, you'd probably want type level lambda
20:39:10 <applicative> Xezlec: I guess if there were so called type level
20:39:15 <applicative> like Cale said
20:39:16 <Jafet> ThreatId
20:39:22 <Cale> Xezlec: and type level lambda makes type inference quite difficult
20:39:40 <Xezlec> OK I don't know what that is but it sounds badass by anme alone
20:39:47 <Xezlec> *name
20:39:51 <shachaf> Xezlec: Type classes are overrated anyway.
20:40:12 <applicative> Functor is not over rated
20:40:57 <Cale> applicative: Good on you, standing up for your parent class.
20:40:59 <ddarius> So says applicative.
20:41:00 <Xezlec> Oh you mean lambda functions that work on types.  Now I got ya
20:41:06 <applicative> exactly, Cale
20:41:33 <shachaf> bgamari: Are you sure "fork $NUMBER_OF_CAPABILITIES threads" is something you're supposed to be doing?
20:41:40 <Xezlec> So, I guess my answer is
20:42:14 <Xezlec> Yes, I want type level lambda, and I don't care if that makes inference difficult.  I want it now.  Now now now now now.
20:42:21 <johnw> lol
20:42:25 <rwbarton> you will care
20:42:29 <johnw> are you missing C++ MPL?
20:42:30 <shachaf> Xezlec: #agda
20:42:41 <Cale> Xezlec: You can use newtype
20:43:02 <Xezlec> Yeah, honestly I probably would never need it
20:43:13 <Xezlec> It just seemed weird
20:43:21 <Cale> Xezlec: which is about as inconvenient, in that you'll be forced to write the newtype's data constructor about as often as you'd otherwise have been forced to give an explicit type signature
20:43:26 <Xezlec> johnw: basically
20:44:10 <Cale> Xezlec: tbh, there is something nice about, whenever you see something which is a Functor instance, knowing which of the parameters is the one it's functorial in.
20:44:10 <johnw> just asking, but have you seen template haksell?
20:44:17 <Cale> Xezlec: (it's always the last one, of course)
20:44:30 <shachaf> Template Haskell :-(
20:44:47 <Xezlec> johnw: no
20:44:56 <johnw> oh yeah, that's the third in the Schacha Trifecta
20:45:11 <shachaf> Schachacha
20:45:24 <ion> Srirachaf
20:45:34 <shachaf> TH is a thing which is sometimes justifiable to use, but not really something to bring up in this context.
20:45:34 <Xezlec> Cale: but now whenever I make a type constructor with multi args I'm gonna be self-conscious about which one should come last
20:45:39 <bgamari> shachaf, I hope so
20:45:44 <johnw> Xezlec: well, C++ MPL is more used to produce custom code at compile-time, than it is to do type-level equational reasoning, from what I've seen; and TH let's you produce whatever code you want at compile-time, consequences be damned
20:45:46 <applicative> Xezlec: emphatically yes
20:45:53 <Cale> Xezlec: You also should be self-conscious about this for all your function definitions
20:46:15 <Cale> Xezlec: order the parameters to functions in increasing order of expected rate of change :)
20:46:19 <johnw> shachaf: haha
20:46:22 <shachaf> Cale: I like to sort the parameters by the lengths of the type names.
20:46:51 <shachaf> Then I get a nice little triangle in the signature.
20:46:58 <johnw> shachaf: coming from the C++ world, some of the thing that I cause me to reach for TMP are the kinds of things that TH solves; I'm not looking at TH from a Haskell perspective
20:46:59 <applicative> Xezlec: it needn't be functorial in all the parameters; I recommend putting the functorial one last
20:47:04 <Xezlec> The thing is, functions I can flip.  Types, there's no way around really
20:47:17 <bgamari> shachaf, Is there a reason I shouldn't?
20:47:24 <shachaf> johnw: What's TMP?
20:47:28 <YayMe> can you not flip a data constructor?
20:47:28 <shachaf> Oh.
20:47:29 <johnw> Template Meta-Programming
20:47:38 <Cale> Xezlec: well, no, you could write a flipping newtype :)
20:47:40 <applicative> data Flip phi a b = Flip (phi b a)
20:47:41 <johnw> MPL = Boost's Meta-Programming Library
20:47:46 <applicative> newtype rather
20:48:08 <Cale> newtype Flip f a b = Flip { unFlip :: f b a }
20:48:19 <Cale> nice to add in an extractor :)
20:48:30 <applicative> ick curly brackets
20:48:34 <applicative> it cant be helped
20:48:39 <Jafet> type Flip f a b = f b a
20:48:39 <johnw> from the Haskell side, the only thing I can see using TH for is to avoid mindless boilerplate that can't be avoided any other way
20:48:39 <shachaf> bgamari: It's possible that I don't quite understand what's going on here. :-)
20:48:47 <johnw> (like how Lens uses it)
20:48:48 <ddarius> newtype Flip f a b = Flip { flop :: f b a }
20:48:56 <Xezlec> applicative: but if someone hands me an Either value, then I have to convert it to a flipped Either value, right?
20:49:10 <Cale> Xezlec: yes, but the conversion is free
20:49:22 <Xezlec> orly?
20:49:39 <Jafet> Cale the car salesman
20:49:43 <Cale> (it gets compiled away to nothing by the compiler)
20:49:57 <Xezlec> Well that's a relief anyway.
20:50:09 <Xezlec> Oh right cause statis type system.  gotcha.
20:50:15 <Xezlec> *static
20:50:20 <applicative> this is why unboxed tuples cant be wrapped in a newtype for example.
20:50:26 <shachaf> map unFlip isn't free. :-)
20:50:28 <Cale> and you can think of the introduction of the Flip and unFlip as being comparable to the stuff you'd have to write with type level lambdas
20:50:42 <shachaf> (Well, maybe it is as a special case.)
20:50:43 <applicative> Xezlec: no, it's a special case for the newtype declaration.
20:50:56 <shachaf> Set.map unFlip certainly isn't free.
20:51:16 <ew0> hey
20:51:20 <shachaf> johnw: I'm of the opinion that when a C++ programmer who's new to Haskell comes in and asks "how do I do $THING_YOU_MIGHT_DO_IN_C++?", answering the question is often not the correct thing to do.
20:51:23 <ew0> what about this: "No instance for (MonadIO Data.Functor.Identity.Identity)"
20:51:28 <applicative> shachaf: you should have unflipped them while producing the list
20:51:33 <Cale> shachaf: then again, you can always Flip/unFlip the elements later
20:51:33 <Xezlec> applicative: oh... I was thinking it was just a basic optimization for when the compiler knows where something is going at compile time
20:51:43 <shachaf> applicative:
20:51:45 <shachaf> Er.
20:52:01 <Cale> (or earlier)
20:52:15 <shachaf> At compile time or earlier!
20:52:27 <Xezlec> shachaf: if it makes you feel any better, what I was really after was elegance, and I think maybe the newtype thing gives me that
20:52:31 <johnw> shachaf: you know, in one way I agree with that, in the sense of "it's better to learn the right way first".  But being the kind of person who often asks that question, I find it's encouraging sometimes just to know that it CAN be done the wrong way, and to learn that it's wrong by doing it
20:52:33 <Cale> I mean in the chain of data dependencies
20:52:37 <applicative> there's plenty of that, Xezlec, but there is a special rule in the language specification about 'newtype'.
20:53:00 <shachaf> applicative: There's no special rule that says newtype is optimized down to nothing. :-)
20:53:14 <johnw> shachaf: that way there's an immediate connection between what I know, and what I can do, which will eventually break down and become new knowledge and what I *should* do
20:53:17 * applicative has no idea what it could mean with e.g. newtype Void = Void {void :: Void}
20:53:17 <shachaf> Just a rule that makes it very easy to do so.
20:53:38 <Jafet> Operational semantics is a mirage.
20:53:57 <Xezlec> what's a operational semantics?
20:54:01 <johnw> it is a well-defined mirage, though?
20:54:09 <shachaf> johnw: It can take a long time to break some old habits.
20:54:15 <johnw> Xezlec: defining how the compiler *behaves*
20:54:26 <Xezlec> oh
20:54:36 <shachaf> johnw: Half the point of learning Haskell is new way of thinking about things.
20:54:43 <applicative> shachaf: I didn't say anything about what newtypes were compiled to.
20:54:51 <johnw> shachaf: and the other half is sticking with it to learn those things :)
20:54:59 <johnw> I gave up on Haskell twice, mind you
20:55:04 <ddarius> Actually the Report states that newtype should have the same representation as its underlying type, albeit it has no way to enforce that.
20:55:50 <dolio> Well, it has no way to enforce anything it says.
20:55:56 <Cale> Also, unlike type synonyms, newtype may be used to define recursive types. The constructor N in an expression coerces a value from type t to type (T u1 ... uk). Using N in a pattern coerces a value from type (T u1 ... uk) to type t. These coercions may be implemented without execution time overhead; newtype does not change the underlying representation of an object.
20:56:12 <Xezlec> wow that does sound unenforceable
20:56:13 <dolio> It doesn't have goons like copumpkin does.
20:56:27 <hpaste> ion pasted ‚Äúnewtype Void‚Äù at http://hpaste.org/75464
20:56:30 <shachaf> copumpkin has goons?
20:56:38 <applicative> of course he does
20:56:40 <dolio> He's a loan shark.
20:56:42 <copumpkin> dolio: watch it buddy. I know where you live.
20:56:45 <shachaf> Oh, good point.
20:56:45 <ddarius> dolio: You could make a series of tests for various aspects of the Report, but there is no test you could make that would distinguish a "conforming" implementation from a "non-conforming" implementation for this.
20:56:52 <shachaf> copumpkin: Wait, dolio isn't one of your goons?
20:57:15 <copumpkin> don't be revealin mah trade secrets
20:57:17 <Xezlec> Surely a language specification shouldn't try to tell the compiler writer how to write their code
20:57:32 <shachaf> Surely they do.
20:57:34 <copumpkin> shachaf: I offered him the job but he turned it down
20:57:44 <shachaf> dolio: Want to be my goon?
20:57:49 <shachaf> I have five dola to extract from copumpkin.
20:57:50 <ddarius> copumpkin: You should get some goons to change his mind.
20:57:52 <Xezlec> Just what the language constructs should observably do
20:57:54 <dolio> I'm too lazy to be a goon.
20:58:08 <shachaf> lightquake: How about you? I heard you were a goon.
20:58:09 <copumpkin> ddarius: good idea
20:58:09 <applicative> that's a little confusing, ion ....
20:58:15 <Jafet> Xezlec: wait, you use C++?
20:58:25 <Xezlec> well..
20:58:36 <Xezlec> C++ specs are ignored by everyone anyway
20:58:48 <Xezlec> sort of
20:59:07 <shachaf> That doesn't stop people from seeing the world through C++-colored specs.
20:59:13 <Xezlec> lol
20:59:21 * ddarius sees the world through C++.
20:59:34 <Jafet> C++ specs, correcting farsightedness since 1998
20:59:38 * YayMe is glad he doesn't have to worry about C++ and continues to pray for it's inevitable demise
20:59:56 <Xezlec> If you use Mac, Win, or Linux, you're definitely seeing through C/C++
21:00:04 <Cale> Xezlec: Your language specifications actually say what things do? How pedestrian, real language specifications only give conditions on the mathematical objects that language constructions correspond to in a conforming denotational semantics.
21:00:05 <shachaf> @quote C/C++
21:00:06 <lambdabot> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
21:00:08 <shachaf> @quote C/C++
21:00:09 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
21:00:33 <Jafet> Haskell/HTML
21:00:38 <mapreduce> "I did Haskell in univers.. ah, I think it might have been Pascal"
21:00:48 <shachaf> Cale: Conale?
21:00:51 <ion> Hascal
21:01:02 <Xezlec> fwiw I currently write pure C89 at work
21:01:04 <ion> skichaf
21:01:04 <applicative> Hascale
21:01:15 <mapreduce> How do you make it pure?
21:01:41 <Xezlec> well... ok, maybe not pure in the strictest puritanical sense
21:01:42 <shachaf> Purity Of Essence
21:01:50 <shachaf> Peace On Earth
21:01:52 <applicative> Xezlec: excellent, you can use the FFI whenever you're irritated by something
21:02:34 <bigfg> i'm having trouble cleaning up ghc packages after they somehow broke
21:02:34 <Xezlec> Let me put it this way: I get slapped if I use a variadic macro
21:02:45 <shachaf> Rightly so.
21:02:49 <johnw> Xezlec: that's close to what I do too
21:02:50 <bigfg> i'm getting regex-pcre as broken in ghc-pkg check. how can i fix that?
21:02:53 <shachaf> @slap Xezlec
21:02:53 <lambdabot> I don't perform such side effects on command!
21:02:56 <Xezlec> hey, variadic macros are handy
21:02:58 <johnw> sigh
21:03:02 <bigfg> (i tried `cabal install regex-pcre --reinstall` and didn't work)
21:03:03 <johnw> someday I will be free of C
21:03:10 <shachaf> When did this channel turn into ##c?
21:03:11 <applicative> ghc-pkg unregister regex-pcre ?
21:03:19 <shachaf> Let's go back to the topic at hand: copumpkin's goons.
21:03:27 <bigfg> ok, i'll try. then reinstall everything?
21:03:31 <applicative> bigfg: you can't just go through cabal
21:03:46 <bigfg> what else do i need to do after this?
21:03:51 <Xezlec> Sorry, sorry.  Back to template haskell...
21:03:52 <Jafet> Error: invalid preprocessing directive #haskell
21:04:10 <bigfg> still getting this:   Warning: library-dirs: /usr/lib/haskell-packages/ghc/lib/regex-pcre-0.94.2/ghc-7.0.4 doesn't exist or isn't a directory
21:04:25 <shachaf> preflex: seen dcoutts
21:04:26 <preflex>  dcoutts was last seen on #haskell 2 hours, 54 minutes and 46 seconds ago, saying: swarley: it's got the wrong permissions because you accidentally did a sudo cabal install before, so you installed files as root, but in your home dir
21:04:42 <swarley> well then
21:05:21 <shachaf> dcoutts_: What's going on with cabal-install under 7.6?
21:06:30 <osa1> is it safe to allocate memory with alloca and then return the value with peek ? I mean do I need that allocated pointer after alloca returns if I use peek to get the value ?
21:06:53 <YayMe> what are the chances C++ will die for enterprise software within the decade?
21:07:02 <Xezlec> Zero
21:07:06 <YayMe> balls.
21:07:08 <shachaf> #c++ will probably know.
21:07:28 <YayMe> shachaf: call me crazy but I think they might not have an objective opinion
21:07:49 <Xezlec> Then try #objectivec
21:07:58 <shachaf> YayMe: Neither do we. But at least it's not off-topic there.
21:08:15 <YayMe> Xezlec: take that to #irony, you're being off-topic
21:08:47 <Xezlec> #puns you mean
21:08:55 <mapreduce> #antimony
21:09:09 <YayMe> I'm not that bright, I probably shouldn't be giving any form of direction in general
21:09:30 <ddarius> osa1: Once you have the value, you have the value.
21:09:37 <osa1> ddarius: thanks
21:10:00 <Xezlec> As long as we all use C-based OSes with C-based APIs, C is immortal
21:10:19 <shachaf> Linux doesn't have a C-based API.
21:10:28 <Xezlec> shachaf: since when?
21:10:39 <shachaf> Well, it depends on what you mean by "C-based".
21:10:43 <YayMe> Xezlec: Yeah, but I was referring to C++ in enterprise. It'll live forever in drivers and plausibly game stuff
21:11:05 <shachaf> Maybe #enterprise knows.
21:11:48 * YayMe shuts up because silence is actually on topic for haskell considering that's usually all anyone hears about it
21:11:48 <Xezlec> YayMe: when you write code for a C API, you need to use C to get the maximum power.  Most of the time.
21:12:43 <shachaf> Certainly the system call calling convention in Linux is completely different from the C calling convention.
21:13:10 <Xezlec> Wow, you're really going to defend this position?
21:14:26 <Xezlec> I talk to the kernel through glibc.  Until FSF maintains a Haskell port of it, I don't think they're on equal footing wrt the OS interface
21:14:38 <Jafet> Beware, shachaf, they have bangalores.
21:14:56 <Jafet> And flamethrowers.
21:14:59 <Xezlec> Not that I'm disparaging Haskell
21:15:16 <johnw> C API?
21:15:20 <Xezlec> Just saying, realistically, you wanna conquer the world, you have to build an OS.
21:15:22 <johnw> don't you mean Platform ABI?
21:15:38 <shachaf> The Linux ABI is stable.
21:15:50 <shachaf> More stable than the glibc ABI. :-)
21:16:16 <YayMe> Xezlec: what gives you that idea at all? Did linus turn out to run the world and I didn't know?
21:16:19 <shachaf> (This isn't the situation in e.g. Windows, where the way you're supposed to make "system calls" is through C function calls.)
21:16:24 <Xezlec> I'm not necessarily talking about the ABI, no.
21:16:30 <johnw> and even Linux is just using, for example, the AMD64 ABI on most Intel/AMD processors
21:16:45 <johnw> which is extremely stable
21:17:03 <johnw> Xezlec: well, the ABI is what C compiles down to
21:17:13 <johnw> that's what, for example, libffi targets
21:17:16 <shachaf> I think w'all mean something different by "ABI".
21:17:20 <shachaf> Anyway this is off-topic.
21:17:24 <Xezlec> Can't respond fast enough
21:17:43 <johnw> if you doubt me, trying building a va_arg function in a non-C language, or calling it from one :)
21:18:19 <Jafet> Okay, I'm not sure who is trolling any more.
21:18:22 <johnw> shachaf: what's the topic again?
21:18:23 <Xezlec> I know what an ABI is, I just think it's reductive to say "oh I can support that ABI.  Done."
21:18:45 <Xezlec> There is a whole ecosystem around that interface.
21:18:59 <Xezlec> And it all speaks C.
21:19:25 <johnw> the ABI defines what the calling conventions are for a platform, it's what the compiler must conform to when producing code in object file sections (which are assembled by the linker based on yet another standard)
21:19:39 <johnw> it doesn't all speak C.  "cdecl" is just one calling convention
21:19:51 <Xezlec> I know what an ABI is.  You don't have to lecture me.
21:20:06 <shachaf> #not-haskell would be a good channel for this.
21:20:10 <shachaf> I'm sorry for starting it.
21:20:28 <Jafet> xezlec: you don't have to be lectured. Shut up.
21:20:39 <johnw> well, being a compiler writer this kind of playing loose with terminology gets me started.  i'll just let it go
21:20:43 <Xezlec> Calling conventions have almost nothing to do with it
21:21:11 <Xezlec> Jafet: what did I say?
21:21:18 <Jafet> Rather too much.
21:21:24 <Xezlec> I gather that
21:21:45 <Xezlec> I want to be a better person, so I'd like to know what it was so I can know not to do it next time
21:23:07 <YayMe> does Yesod or Warp have facilities for WebSockets? (Is that on topic for ya shachaf?)
21:23:34 <Xezlec> Alright, well, I apologize.
21:23:38 <shachaf> YayMe: I'm sure #haskell-web would be a better channel for that question.
21:23:43 <shachaf> (It really exists!)
21:23:59 <shachaf> Also #yesod and #warp (or whatever they were called).
21:24:18 <YayMe> right, sorry, I'll stop disturbing you then..
21:27:47 <Jafet> @quote einstein
21:27:47 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
21:28:15 <ion> > cycle "HA"
21:28:16 <johnw> shachaf: how many #haskell offshoots are there?  you seem to know them all!
21:28:16 <lambdabot>   "HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHA...
21:28:28 <Jafet> alis should know about them.
21:28:31 <rwbarton> ask #haskell-irc-channel-enumeration
21:28:34 <johnw> yay, I just used zipWith ($) for reals :)
21:28:42 <johnw> rwbarton: lol
21:28:55 <shachaf> johnw: Every channel on Freenode is a #haskell offshoot.
21:29:18 <shachaf> @let zap = zipWith ($)
21:29:19 <lambdabot>  Defined.
21:29:50 <shachaf> rwbarton: Who says the set of #haskell offshoots is countable?
21:30:00 <johnw> :t zap
21:30:01 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
21:30:04 <shachaf> (Other than the IRC RFC.)
21:30:11 <rwbarton> pretty sure their names are all finite distinct strings of unicode characters
21:30:17 <rwbarton> er
21:30:19 <rwbarton> distinct finite strings
21:30:26 <ion> @type (<*>) `on` ZipList
21:30:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
21:30:27 <lambdabot>       Expected type: f (a -> b)
21:30:27 <lambdabot>       Inferred type: f a
21:30:28 <chrisb> after asking alis, i count 36
21:30:29 <johnw> not quite close to: http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/Control-Functor-Zap.html#v:zap
21:30:53 <ion> @type \fs xs -> getZipList (ZipList fs <*> ZipList xs)
21:30:54 <lambdabot> forall a a1. [a -> a1] -> [a] -> [a1]
21:31:01 <chrisb> not counting #haskel
21:31:18 <ion> There‚Äôs a #haskel?
21:31:26 <ddarius> chrisb: I'm sure you are missing some.
21:32:35 <chrisb> ddarius: you are right, a search of "list *haskel* lists even more!
21:32:38 <johnw> shachaf: I want to make a Prelude that's oriented toward Category, Applicative, Foldable, Traversable, etc.  Does such a "higher-order prelude" already exist?
21:32:47 <chrisb> ddarius: i started with "list #haskel*
21:32:56 <shachaf> johnw: Too many of them.
21:33:02 <johnw> any you like?
21:33:05 <shachaf> Nope.
21:33:13 <shachaf> (Not surprised, eh?)
21:33:27 <johnw> well, I figured if YOU liked one, it would be conservative enough to be worth considering
21:33:55 <johnw> I also want it to use Text and Filesystem.Path
21:33:56 <shachaf> johnw: At least that selection of classes is better than some that I've seen.
21:34:04 <johnw> guess I'll just make one for my own projects
21:34:13 <johnw> the import lists in even my simplest utilities are getting silly
21:34:26 <johnw> I'm too hooked on for and traverse now :)
21:34:33 <johnw> (thanks to you, actually!)
21:35:22 <shachaf> To me? Why?
21:37:09 <bgamari> hmm, well, things start getting slower above 8 threads, yet all of my workers are busy and productivity is still 95%
21:37:38 <ddarius> Do you have more than 8 cores?
21:38:13 <bgamari> I have 24 cores
21:38:18 <jfischoff> are there limitations on the return type of a FFI imported function?
21:38:42 <shachaf> jfischoff: Limitations like what?
21:38:49 <maukd> jfischoff: yes
21:39:13 <jfischoff> can the function return a struct?
21:39:18 <maukd> no
21:39:26 <maukd> the FFI doesn't support structs
21:39:36 <maukd> (or enums AFAIK)
21:39:38 <bgamari> ddarius, The distribution of time in the profile doesn't even appear to change
21:39:52 <maukd> vararg functions are out, too
21:39:58 <maukd> as are macros
21:40:14 <shachaf> maukd: Doesn't GHC 7.6 have some sort of macro support?
21:40:22 <jfischoff> maukd: what's the workaround?
21:41:14 <pnielsen> bgamari: less performance gain with the same utilization is usually a sign that there's a higher contention/synchronization overhead
21:41:16 <maukd> jfischoff: write a wrapper function in C, FFI that
21:41:28 <maukd> shachaf: oh, no idea
21:41:36 <shachaf> Release notes confirm it.
21:41:46 <bgamari> pnielsen, but in this case I would suspect frequent STM retries or idle threads
21:42:03 <maukd> my knowledge is still based on 7.0.4
21:42:15 <pnielsen> bgamari: retry synchronization sounds plausible, but I'm no expert
21:42:28 <bgamari> pnielsen, Unfortunately the event log doesn't show any
21:43:06 <maukd> (7.2 was described as an intermediate release on the way to 7.4, 7.4 apparently has some program-breaking bugs, and IIRC Cale called 7.6.1 a technology preview)
21:43:28 <pnielsen> bgamari: interesting. You should ask in #ghc
21:43:29 <jfischoff> maukd: hmm, I'm trying to understand the memory ownership situation. It would seem like I need to store the struct on the C side and the pass it a la Storable or something similar. (This is my first attempt at this stuff).
21:43:31 <shachaf> maukd: What program-breaking bugs?
21:43:40 <jfischoff> maukd: is that reasonable?
21:43:43 <shachaf> I don't think 7.6.1 is a "technology preview".
21:43:46 <maukd> shachaf: I don't remember
21:43:57 <bgamari> pnielsen, I think I'll have to
21:43:59 <maukd> I just saw mentionings in this channel
21:44:20 <shachaf> jfischoff: You could make a wrapper that gets a pointer to put the struct return value in.
21:44:32 <shachaf> maukd: Being able to "data" in ghci is pretty great!
21:45:01 <maukd> jfischoff: struct foo bar(void);  void bar_wrapper(struct foo *ptr) { *ptr = bar(); }
21:45:12 <jfischoff> ah
21:45:13 <johnw> shachaf: you told me that mapM_ = traverse_
21:45:15 <shachaf> What maukd said.
21:45:21 <maukd> foreign import bar_wrapper :: IO (Ptr Foo)
21:45:22 <shachaf> johnw: I did?
21:45:29 <johnw> and forM_ = for_, and how to use for to peek at Maybe values
21:45:31 <johnw> yeah, you did!
21:45:35 <johnw> thanks so much for that
21:45:41 <shachaf> johnw: I don't remember that.
21:45:42 <johnw> you made me a believer in Foldable/Traversable
21:45:46 <maukd> bar :: IO Foo; bar = alloca $ \p -> do bar_wrapper p; peek p
21:45:48 <shachaf> I don't know if I've ever used for_
21:45:51 <ddarius> Every major release of GHC is a "technology preview" for something.
21:45:51 <johnw> checking my log...
21:46:02 <Cale> maukd: Every GHC goes through a technology preview phase
21:46:15 <shachaf> I'm not much of a believer in Foldable.
21:46:19 <Cale> which gradually peters out at the library support comes up
21:46:24 <Cale> as&
21:46:41 <maukd> yeah, I have 7.6.1 now
21:46:56 <johnw> oh, it was liyang
21:47:02 <ddarius> shachaf: Don't worry.  I don't think Ron Hubbard is much of a believer in Scientology.
21:47:07 <johnw> and ivanm
21:47:13 <maukd> my gentoo used to have 7.0.4 but debian is still on 6.12, which is unbearable
21:47:15 <jfischoff> maukd: thanks
21:47:19 <johnw> funny that I kept thinking it was you
21:47:23 <maukd> so I installed the latest version in my home
21:47:32 <shachaf> maukd: Debian testing is 7.4.1.
21:47:41 <maukd> which promptly broke a few of my libraries
21:47:47 <shachaf> Alternatively: Debian is testing 7.4.1.
21:47:51 * maukd shakes fist at Prelude.catch
21:47:54 <johnw> I use: for_ <some Maybe value> $ \x -> blah blah blah, when I'm not in the Maybe monad
21:47:58 <johnw> well, sometimes
21:48:18 <shachaf> johnw: Oh, is that whenJust?
21:48:30 <maukd> flip fmap?
21:48:43 <maukd> actually ...
21:48:44 <shachaf> Neat.
21:48:44 <johnw> shachaf: yeah, but whenJust doesn't bind the value, does it?
21:48:51 <shachaf> "whenJust" doesn't exist.
21:49:00 <maukd> is there a library that provides what used to be Prelude.catch?
21:49:06 <johnw> Control.Monad.Loops, isn't it?
21:49:07 <johnw> bbiab
21:49:17 <maukd> it's a bit annoying having to define it myself every time
21:49:25 * hackagebot gluturtle 0.0.4 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.4 (YoshikuniJujo)
21:49:27 <shachaf> Yay, F.for_ or T.for is whenJust_ or whenJust
21:49:32 <shachaf> maukd: What was its type?
21:50:04 <maukd> :t catch
21:50:05 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
21:51:06 <ion> Ooh, hackagebot URLs are back.
21:52:02 <maukd> learninghaskell: hi! are you learning haskell?
21:52:50 <learninghaskell> haha.. yeah.. giving it a try for the 2nd time..
21:52:54 <ion> maukd: hi! are you mauking d?
21:53:25 <shachaf> maukd: When will mauke be back?
21:53:34 <maukd> ion: no, put I've got my i on it
21:53:40 <maukd> but*
21:54:16 <maukd> shachaf: maybe never or next week
21:54:24 <AfC> bgamari: can you tell us something about the nature of the application you're working on? [sounds fascinating]
21:55:02 <bgamari> AfC, I'm writing a Gibbs sampling framework for learning graphical probabilistic models
21:55:31 <copumpkin> bgamari: have you spoken to edwardk? he was talking about this at length a few months ago
21:55:45 <ion> I just started studying PGMs in the free online class.
21:55:46 <AfC> bgamari: 24 cores is non-trivial. Multi-CPU NUMA machine? Or are you running this on AWS, or...?
21:55:48 <bgamari> copumpkin, Yes, we discussed this at Boston Haskell last year
21:55:52 <copumpkin> ah okay :)
21:56:09 <bgamari> He's looking at a slightly different class of problem
21:56:30 <bgamari> AfC, I have access to a cluster
21:56:33 <bgamari> I'm running on one node
21:56:52 <bgamari> Given the nature of the problem, I can pretty much only scale out to one node
21:57:19 <bgamari> AfC, But I was hoping to at least saturate a note
21:57:22 <bgamari> node*
21:57:31 <bgamari> and continue to scale reasonable
21:57:34 <bgamari> reasonably*
21:58:54 <bgamari> We also have a 48 core machine
21:59:59 <bgamari> AfC, In principle this problem should scale nicely assuming snip some data dependencies
22:00:01 <bgamari> which I have done
22:01:33 <AfC> bgamari: I daresay Simon Marlow would be interested in your code as a test case. Performance fall offs at high thread and/or capability count are a big deal at the moment.
22:02:05 <pnielsen> Idd, definitely get somebody to note in #ghc or submit an issue to Trac
22:03:01 <bgamari> AfC, I've chatted with him a couple of times over the last few days regarding a few issues
22:03:06 <bgamari> I guess I should bring up this one
22:03:21 <pnielsen> or that
22:03:35 <AfC> bgamari: excellent
22:10:24 <jfischoff> If I want cabal to compile a C file do I need to do anything besides setting the C-Sources option, for example ==> C-Sources: cbits/Wave.c? Because, it doesn't appear to work...
22:11:03 <maukd> how does it fail?
22:11:29 <jfischoff> just doesn't seem to compile the file
22:11:42 <maukd> how can you tell?
22:12:16 <jfischoff> well I don't see it passing the passing the file to gcc in the spew that results
22:12:26 <jfischoff> and I don't see a .o file being produced
22:12:46 <jfischoff> it also complains it can't find the symbol
22:12:58 <jfischoff> in the C file that I am compiling
22:13:26 <maukd> I don't see my C files mentioned either
22:13:34 <jfischoff> hmm
22:13:51 <jfischoff> okay maybe something else is wrong‚Ä¶ let me dig around
22:14:09 <maukd> .o files are in dist/build/$X/$X-tmp/cbits/
22:14:20 <maukd> but it links fine here :-)
22:15:19 <jfischoff> cool
22:17:06 <jfischoff> hmm I don't see much in the build directory
22:17:18 <jfischoff> just Wave_hsc_make.o and Wave.hs
22:17:27 <jfischoff> along with autogen
22:17:37 <jfischoff> now cbits :(
22:17:53 <maukd> no directory named after your project?
22:18:13 <maukd> oh, maybe it's different for libraries?
22:18:15 <jfischoff> no
22:18:24 <maukd> I'm looking at the preflex build dir
22:20:57 <jfischoff> okay that was silly
22:21:28 <evancz> Hello! I am trying to use Control.Concurrent.Chan
22:21:36 <jfischoff> had w when I needed a W
22:21:40 <evancz> and running into some odd behavior
22:21:56 <evancz> specifically, pre-emption is not happening
22:22:10 <evancz> which kind of defeats the purpose of concurrency
22:22:34 <evancz> does anyone know what kind of functions never block and which ones do?
22:22:46 <evancz> I have only been able to come up with stuff that never blocks
22:23:02 <dmwit> Are you using the threaded runtime?
22:23:05 <evancz> e.g. naive fib function, sum [0..2^n]
22:23:07 <evancz> yeah
22:23:13 <evancz> -N2
22:23:25 <dmwit> Are you compiling with -threaded?
22:23:48 <evancz> yeah, and checking to see how many cores are recognized with GHC.Conc
22:23:50 <maukd> foreign calls can block. this includes things like flock()
22:24:03 <maukd> and tight loops with no allocation
22:24:11 <maukd> but that should eat 100% cpu
22:24:13 <shachaf> flock can flock as well as block
22:24:46 <evancz> so why is fib blocking
22:25:08 <evancz> is that a "tight loop"?
22:25:12 <dmwit> To directly answer your question: many of the concurrency primitives (takeMVar, putMVar, readChan, etc.) block; system calls and FFI functions can block; and yes, tight loops with no allocation as maukd said.
22:25:27 <jfischoff> maukd: yay! got it to compile. Now to actually write my Storable instance ;p
22:25:28 <dmwit> But to address something else: Haskell threads are never pre-empted. Threading in Haskell is cooperative.
22:25:42 <evancz> wait really?
22:25:47 <dmwit> (...which is why tight loops with no allocation block: the cooperation points are at allocation.)
22:25:49 <jfischoff> is there some way to derive Storable instances?
22:25:51 <rwbarton> I think "block" is being used inconsistently
22:26:05 <johnw> shachaf: good to know
22:26:06 <evancz> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#g:14
22:26:19 <shachaf> "co√∂perative", but GHC-generated code tends to be pretty co√∂perative.
22:26:31 <shachaf> It can yield at every allocation and so on.
22:26:34 <johnw> shachaf: for and for_ work for any Foldable, so they generalize whenJust, forM, etc.
22:26:38 <dmwit> evancz: "More specifically, a  thread may be pre-empted whenever it allocates some memory" <- I call that cooperative
22:26:39 <evancz> so what qualifies as allocation?
22:26:47 <dmwit> constructors allocate
22:26:50 <ddarius> It's pretty hard to write non-trivial Haskell code that doesn't allocate.
22:27:02 <rwbarton> I would think that fib n = fib (n-1) + fib (n-2) would allocate
22:27:12 <evancz> yeah, me too!
22:27:13 <rwbarton> sum [0..2^n] very well might not allocate
22:27:19 <evancz> I'll try something that uses ADTs
22:27:29 <rwbarton> though I guess it would because lists don't have stream fusion?
22:27:38 * ddarius thinks the most likely scenario is evancz is misdescribing the problem.
22:27:45 <dmwit> I'm with ddarius.
22:27:47 <dmwit> Show us some code.
22:27:51 <shachaf> I'm with dmwit.
22:28:15 <evancz> ok, one second
22:28:58 <hpaste> Evan pasted ‚ÄúConcurrent FRP‚Äù at http://hpaste.org/75466
22:29:17 <boothead> I'm having some problems with replicating arrows in such a way as to avoid typeclasses (for fay). Can anyone take a look at https://github.com/boothead/fay-frp/blob/master/Tests.hs#L111 please?
22:29:25 <boothead> the FPR module is here: https://github.com/boothead/fay-frp/blob/master/Language/Fay/FRP.hs
22:29:37 <evancz> expensiveComp is what I am using to test
22:29:54 <evancz> the code sets up a system of nodes each working on a part of the FRP system
22:30:08 <evancz> normally each node needs to wait for all of its dependencies to update
22:30:23 <evancz> so the synchronization causes some blocking
22:30:43 <dmwit> Is this really the simplest code you can cook up that behaves differently than you would expect?
22:30:45 <evancz> but the Async primitive means "don't block for these dependencies"
22:30:51 <evancz> oops
22:30:52 * shachaf wonders what's with all the ()s
22:30:57 <evancz> I can do an easier one
22:31:12 <evancz> I am coming to concurrency from Concurrent ML
22:31:29 <shachaf> Ah, ML. :-)
22:31:31 <evancz> this is the style used there
22:31:45 <evancz> I can try a simpler thing
22:31:47 <evancz> hold on
22:32:51 <boothead> dmwit: was that for me?
22:32:58 * ddarius ignored CML for a while but was quite impressed when he finally read Reppy's thesis.
22:33:05 <dmwit> boothead: no
22:33:17 <evancz> Yeah! his work is great!
22:34:17 <dmwit> boothead: I don't even know what question you asked.
22:34:43 <dmwit> (Even after reading your messages and looking at your links.)
22:36:07 <dmwit> Even less helpfully: "Yes, someone can take a look at that link. NEXT QUESTION"
22:36:32 <shachaf> dmwit: Prove it!
22:36:41 <dmwit> I did! You just don't know I did.
22:36:44 <rwbarton> proof is provided at that link
22:37:05 <shachaf> rwbarton++
22:37:10 * shachaf can't argue with that logic.
22:37:12 <boothead> dmwit: more specifically then :-) this doesn't evaluate in ghci: evalList ballPos $ repeat (10, 200), but looking at the cleaned up version from the original leonidas code blog the same snippet does
22:37:50 <dmwit> What's the exact error? How small can you make the code and still get that error?
22:38:00 <boothead> this is the other version: https://github.com/shangaslammi/frp-pong/blob/master/Pong/Game.hs
22:38:56 <boothead> dmwit: the error is that in one version I get a never ending stream of BallPos and in mine I get "[" printed in gchi, but nothing else.
22:39:19 <boothead> I've tried my version of loopC with other code and it evaluates.
22:40:37 <boothead> the problems seems to be in the >>> batBounce *** wallBounce part. That's never being hit because there's an ffi call in batBounce that raises an error if you're not in a javascript context
22:42:10 <dmwit> I sort of doubt that (1) loopC can be expected to do anything reasonable with strict coroutines and (2) anything with an FFI call can be made sufficiently lazy.
22:42:36 <boothead> dmwit: I've also taken my ballPos function and pasted it into Game.hs verbatim and it still produces values
22:43:17 <dmwit> huh, neat
22:43:21 <boothead> I'm not sure why my version of loopC is strict?
22:44:35 <dmwit> I don't think your version of loopC is strict. I think the thing you're passing to loopC is strict.
22:46:01 <dmwit> Then again, all of that is just a guess based on basically no evidence.
22:46:14 <dmwit> I know next to nothing about FRP in general and actually nothing about fay in particular.
22:47:32 <boothead> dmwit: I've been staring at it for the last day or so and I can't find that bit. I've tried the factorial arrow : loopC (mul >>> (arr id &&& delay 1)) in my code and it does what I expect
22:48:52 <evancz`> I guess my question is best rephrased as, "what is the simplest function that allocates memory and takes a long time to run?"
22:49:25 <boothead> AFAIK, when I'm doing this in ghci fay has nothing to do with it (apart from using Fay's re-impmentations of the prelude stuff)
22:49:33 <evancz`> everything I think of is too simple (and thus never gets pree
22:49:37 <dmwit> evancz`: I still think you're asking the wrong question.
22:49:39 <evancz`> *pre-empted
22:49:53 <dmwit> Show us the simplest code you can write that doesn't behave the way you expect.
22:49:55 <dmwit> Then we'll talk.
22:50:18 <evancz`> okey dokey
22:51:52 <dmwit> boothead: I think this is probably a good exercise for you, too: how short and self-contained can you make your file while still having it misbehave?
22:52:28 <dmwit> (For me, half the time I'm learning something new, just doing that exercise is enough to point me in the right direction. The other half of the time #haskell finds out just how much of an idiot I can be. ;-)
22:52:59 <boothead> haskell is supreme at pointing out my idiocy! :-)
22:55:23 <johnw> what's sad is that it makes my idiocy seem immutable
22:56:24 <boothead> johnw: as long as it's not strict too..!
22:56:36 <johnw> hmm... I do get called a lazy idiot...
23:00:12 <pnielsen> dmwit: that's definitely the best way to find the source of the problem, although ironically it's often the last thing I try
23:00:57 <pnielsen> utter frustration followed by a *thud* from a facepalm
23:03:37 <johnw> what are "field puns"?
23:04:20 <dmwit> Foo { a = a } can be written Foo { a }
23:04:36 <johnw> ahh
23:06:32 <ion> Huh. That‚Äôs a bit evil.
23:07:00 <dmwit> Not as evil as wildcards.
23:07:05 <dmwit> Foo { .. }
23:07:18 <dmwit> Now tell me: exactly what variables just got bound?
23:07:53 <johnw> if I have a C FFI struct value 'foo' with a field a, how is haskell do I do "foo.a"?
23:07:56 <johnw> s/is/in
23:08:02 <dmwit> You don't.
23:08:11 <dmwit> You call a C function for that.
23:08:24 <johnw> i have to call a C function to access a struct field?
23:08:25 <dmwit> (Alternately, you use one of the FFI generators like c2hs/hsc2hs.)
23:09:01 <johnw> my .hsc file has a #starttype foo_t for this type
23:09:11 <johnw> I guess I'm wondering what the function's generated name is then
23:09:20 <thoughtpolice> you can use Storable to marshal it to an actual ADT
23:09:27 <hpaste> Evan pasted ‚ÄúPre-emption question‚Äù at http://hpaste.org/75467
23:09:44 <thoughtpolice> i think recent GHCs can generate some FFI boilerplate for macros/struct definitions with the -XCApiFFI extension
23:09:49 <dmwit> johnw: Read the documentation for #peek
23:09:49 <thoughtpolice> (or something like that)
23:09:57 <johnw> ok, I'm looking at #peek and Storable
23:10:23 <johnw> do I use #peek in my .hsc file, or my .hs file that uses the bindings?
23:10:28 <dmwit> evancz`: Okay, this looks more like something I can read. Give me half a tick.
23:10:37 <dmwit> johnw: in .hsc
23:10:51 <evancz`> ok :D Sorry for the giant mess of code before!
23:10:57 <johnw> dmwit: I'm guessing that Bindings-DSL's #starttype is doing all the peek mapping for me
23:11:08 <johnw> oh, duh, I'll just look at the generated .hs file
23:11:29 <johnw> there we go: c'foo'a
23:11:41 <johnw> and p'foo'a
23:12:20 <johnw> the latter is what I really wanted: p'foo'a :: Ptr (C'foo) -> Ptr (<type of a>)
23:12:24 <evancz`> the goal is to have `expensiveComp` not block the other computation
23:13:25 <evancz`> I cannot tell if I am doing it wrong (wrong assumptions?) or if I just do not know what it means to "allocate memory"
23:13:26 <johnw> yes, and hsc2hs even generates the Storable instance fro me
23:13:33 <dmwit> evancz`: Ah, I bet I know what's confusing you.
23:13:59 <dmwit> evancz`: You think the thread writing to the chan is performing expensiveComp, but actually it's just writing a thunk and the thread doing the *printing* is the one forcing the thunk and doing the expensive computation.
23:14:28 <evancz`> No kidding!
23:14:49 <evancz`> So everything is piling up on the `reportChan`?
23:14:55 <evancz`> and then getting computed there
23:14:59 <evancz`> hmm.
23:15:07 <dmwit> The simple fix is to just write "writeChan outChan $! f v" on line 8.
23:15:24 <evancz`> Ok! I'll try it and see what happens.
23:17:06 <evancz`> Damn! I was two characters off! :P Also, a whole mindset off when I forgot about laziness!
23:17:16 <evancz`> well, thank you for your help!
23:17:19 <dmwit> (Of course, you'll need to be more careful than that if the thing you're writing to the channel is more exciting than just an Integer or whatever. But that should at least explain what's happening so you know what to do to fix things the way you like them.)
23:19:09 <pnielsen> $!! / deepseq might be an easy solution, but it can be problematic
23:19:21 <evancz`> Hmm, the values getting written to the channel can be anything. Does that mean I'll need to do `deepseq` on everything that gets passed around?
23:19:36 <evancz`> what is the problematic part?
23:19:50 <evancz`> no infinite data structures?
23:19:58 <dmwit> No, it just means you have to think a bit about exactly when you want the computations and subcomputations to be done.
23:20:00 <evancz`> or libs that assume laziness
23:20:24 <dmwit> It's not always the case that you want the writing thread to evaluate the thing fully. Sometimes you just want spine-strictness or some other crazy thing.
23:21:13 <evancz`> I think in my case I want to localize the stated computations to their corresponding threads
23:21:26 <evancz`> but yeah, I see what you mean
23:24:07 <pnielsen> actually, the description for deepseq is: "This package provides methods for fully evaluating data structures ("deep evaluation"). Deep evaluation is often used for adding strictness to a program, e.g. in order to force pending exceptions, remove space leaks, or force lazy I/O to happen. It is also useful in parallel programs, to ensure pending work does not migrate to the wrong thread."
23:24:12 <pnielsen> :)
23:25:22 <evancz`> I am sort of surprised to see laziness in this context actually!
23:25:36 <evancz`> I mean, I guess that is clear from me not having any clue that that was the problem
23:26:07 <evancz`> I guess making writeChan lazy by default gives more flexibility?
23:26:14 <dmwit> right
23:27:30 <ddarius> I doubt this was considered.  There's just nothing making writeChan strict and no necessary reason why it would be.
23:28:15 <Cyan6> is there a way to have an infinite list stop once it hits a certain point?
23:28:37 <Jafet> @remember Cyan6 is there a way to have an infinite list stop once it hits a certain point?
23:28:38 <lambdabot> Okay.
23:28:43 <pnielsen> Cyan6: use any operation that only evaluates n items of the list
23:28:52 <ddarius> Since you could easily go either way, deciding what it should've been would have been mostly bikeshedding.
23:30:06 <dmwit> Cyan6: Define "certain point".
23:30:15 <dmwit> (If "certain point" is computable, then the answer is yes.)
23:30:15 <Cyan6> 400000
23:30:17 <evancz`> I think the strict version is strictly less expressive
23:30:31 <dmwit> Cyan6: "take 400000" will work
23:30:58 <evancz`> so it'd be weird to have that be the default
23:31:06 <Cyan6> i'm saying when it reaches an element with a value greater than "a certain value", eg. 4000000, close the list
23:31:20 <Jafet> Evaluating things is less expensive than not evaluating them?
23:31:21 <dmwit> Cyan6: "takeWhile (<400000)" will work
23:31:25 <Jafet> Sounds about right
23:31:28 <ddarius> evancz`: You are wrong, and I personally think the strict version is probably the right default, but it isn't that big a deal.
23:31:47 <Saizan> evancz`: however you want to enforce strictness you can defeat it with a data Lazy a = Lazy a wrapper
23:31:57 <Cyan6> dmwit that sounds perfect :P
23:33:26 <Cyan6> thanks!
23:34:15 <Jafet> > "expressive" == "expensive"
23:34:16 <lambdabot>   False
23:34:18 <Jafet> Hmm
23:36:06 <evancz`> I didn't know you could circumvent strictness like that!
23:36:29 <evancz`> I think the strict version is the right default too.
23:36:42 <evancz`> but I was trying to rationalize why it is this way
23:37:35 <evancz`> It seems like a big deal to me that computations can escape their threads in this way, but I guess it is too late to know
23:37:42 <Jafet> I'm pretty sure most people who use MVar and Chan don't use it as if it is WHNF-strict.
23:37:56 <Jafet> They use it as if it's lazy, or NF-strict.
23:38:17 <ddarius> I'm pretty sure most people don't think about this.
23:38:19 <Jafet> The latter can't really be implemented.
23:38:37 <Jafet> Most people have not needed to think about this yet
23:38:38 <Saizan> http://hackage.haskell.org/package/strict-concurrency <- these are WHNF-strict
23:38:57 <Saizan> ah, no, NF-strict
23:39:27 * hackagebot hit 0.4.0 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.4.0 (VincentHanquez)
23:39:45 <evancz`> is WHNF-strict total strictness?
23:39:57 <evancz`> i.e. evaluated all the way to a value?
23:39:59 <Saizan> nope, Weak Head Normal Form
23:40:14 <Jafet> WHNF-strict is what is usually meant by "strict".
23:40:21 <Jafet> It's rarely strict enough.
23:40:25 <Saizan> it's "just the outer layer"
23:40:40 <evancz`> lol, ok, so NF-strict is the truly strict one?
23:40:45 <Saizan> yep
23:40:50 <evancz`> ok!
23:41:13 <Saizan> NF is a bit of a misnomer though? it's not like we evaluate under lambdas
23:41:27 <evancz`> right, right
23:41:36 <Jafet> Just sit back, sir, and enjoy the show.
23:41:51 <Saizan> i guess it depends on which rewriting rules you allow :)
23:41:51 <evancz`> maybe, "everything that can be evaluated is evaluated"
23:42:30 <Saizan> anyhow we have NFData as a typeclass so it's quite fine to say NF to mean this
23:42:34 <Jafet> NFData is correctly named because it doesn't have instances for closures.
23:43:15 <Saizan> no instance for (a -> b) ?
23:43:38 <Jafet> Or anything containing values of that type.
23:44:45 <Saizan> Jafet: it's there, actually http://hackage.haskell.org/packages/archive/deepseq/1.3.0.0/doc/html/Control-DeepSeq.html#t:NFData
23:45:15 <Jafet> Well, in that case, it's badly named.
23:49:00 <ddarius> This strict-concurrency package is simultaneously more and less insane than I thought.
23:49:20 <pnielsen> that's comforting and upsetting
23:51:14 <Saizan> ddarius: how so?
23:51:41 <Saizan> btw, the reading operations for Chan have a NFData a => contenxt but don't seem to use it
23:51:46 <ddarius> Saizan: You and it's documentation are correct in that it reduces things only to WHNF.  Which is definitely more sane than using rnf.
23:51:51 <ddarius> Saizan: Bingo.
23:52:02 <ddarius> Saizan: The NFData contexts are completely spurious and misleading.
23:52:20 <ddarius> As well as potentially limiting.
23:52:32 <Cale> Maybe throw in an Ord context just to make it really confusing.
23:53:58 <ddarius> Also, I suspect the implementation of the operations is wrong.
23:54:27 <Saizan> hah, i didn't even look at the writing ops
23:55:26 <evancz`> wait, `writeChan chan v` from strict-concurrency is not the same as `writeChan chan $!! v`
23:55:42 <Saizan> ?type ($!!)
23:55:43 <lambdabot> Not in scope: `$!!'
23:56:30 <ddarius> evancz`: No, which is good (but surprising from the types) because that would be crazy.
23:56:33 <evancz`> It's the stricter ($!)
23:56:33 <evancz`> which is the stricter ($)
23:56:47 <pnielsen> ?type deepseq
23:56:48 <lambdabot> Not in scope: `deepseq'
23:56:57 <pnielsen> oh
23:57:16 <evancz`> why would it be crazy?
23:57:36 <evancz`> surprise infinite loops when it encounters infinite data structures?
23:59:56 <ddarius> evancz`: Say you pass a list of length n through a chain of k channels, which is a quite natural thing to happen in message passing systems, then you will do O(nk) work, though only the first time is something -maybe- necessary.  The remaining k-1 times will be completely wasteful.
