00:29:54 <DMWIT> mklinik: Maybe install a different version of iteratee; upgrade cabal-install; or take a look at iteratee.cabal and see if you can spot the error yourself.
00:37:05 <Saizan> cabal update could also help
00:37:41 <mklinik> DMWIT: the cabal version I have suffers from http://hackage.haskell.org/trac/hackage/ticket/811. Trying to update cabal gives me dependency errors with base, but installing iteratee from source with removed test-suite section seems to work.
00:40:55 <mklinik> but anyway, thanks!
00:41:29 <MHD> What are the implied relationships between GHC extensions: -XMonoLocalBinds, -XMonomorphismRestriction, -XMonoPatBinds
00:42:34 <DMWIT> I don't think any of them implies any of the others.
00:43:18 <MHD> Okay, so could I run with NoMonomorphismRestriction, MonoLocalBinds and MonoPatBinds?
00:43:30 <DMWIT> Sure.
00:58:44 <MHD> When you use >50 ghc extensions, are you even writing haskell code anymore>
00:58:54 <MHD> s/>/?/
00:59:23 <startling> MHD: then it's glaswegian haskell
00:59:55 <MHD> "I know Haskell, Glaswegian Haskell, C, Ruby ..."
01:00:11 <MHD> Some of them are really useful in production code
01:00:18 <Ke> ghc-7.6 doesn't even support standard haskell anymore
01:00:22 <Ke> if it ever did
01:00:50 <mapreduce> Glaswegian Haskell dies younger and pisses on its own front door?
01:00:55 <sHACHAF> What's new in 7.6 in that regard?
01:01:03 <Ke> oldexceptions removed
01:01:43 <sHACHAF> Ah.
01:01:49 <startling> mapreduce: it carves those creepy joker smiles in peoples' faces
01:01:50 <sHACHAF> There are also some other things, like Num superclasses.
01:02:31 <Ke> but do they break compatibility or just add ghc haskell as a superset of haskell2010?
01:02:58 <zzing> Probably be six months before we have 7.6 on a platform/
01:04:10 <Ke> platform is irrelevant
01:04:34 <frerich> heh, shachaf is *still* on the uppercase trip? :-)
01:04:37 <frerich> AWESOME!
01:04:55 <Ke>    10 NOT F77 AWESOME
01:08:41 <johnw> shachaf: what's a "superclass"?
01:10:00 <LordBrain> superclass in oo speak is a parent class, in type classes it's placed in the constraint part of the declaration
01:12:08 <startling> frerich: he's starting to calm down
01:12:53 <sHACHAF> @google what's a superclass in haskell
01:12:53 <lambdabot> http://www.haskell.org/tutorial/classes.html
01:12:54 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
01:13:34 <Z`> Hi people. I just read about liftM2 which is cool. Is there anything that extends to N arguments ?
01:14:02 <sHACHAF> f <$> a <*> b <*> c <*> d = liftM3 f a b c
01:14:09 <DMWIT> Yes, return f `ap` x `ap` y `ap` z
01:14:12 <Z`> wow, many new symbols there :P
01:14:22 <sHACHAF> <$> = liftM
01:14:23 <Z`> I think I should read about applicative functors ?
01:14:25 <sHACHAF> <*> = ap
01:14:42 <sHACHAF> Z`: Applicative functors are "things you can do liftMn on"
01:15:04 <LordBrain> except they aren't necessarily monads
01:15:08 <sHACHAF> (Regular functors are "things you can do liftM1 on".)
01:16:01 <LordBrain> fmap and fmapn technically, because liftM is restricted to monad..
01:16:38 <sHACHAF> "technically" it's not fmapn because there's no such thing as fmapn.
01:17:08 <Z`> I was hoping I could do something like:  liftMn (,) 100 rndGen, and create a list of 100 random pseudo numbers created by my statefull random generator
01:17:21 <Z`> (ofcourse syntax is wrong, I'm just being schematic)
01:17:29 <LordBrain> yeah
01:17:38 <LordBrain> there's no liftMn either
01:17:39 <startling> Z`, that's not what liftM does
01:18:02 <sHACHAF> Z`: (,) is fixed to be a two-element tuple.
01:18:05 <sHACHAF> @ty (,)
01:18:06 <lambdabot> forall a b. a -> b -> (a, b)
01:18:15 <sHACHAF> However, you can make a hundred-element *list*.
01:18:16 <johnw> liftM = fmap
01:18:20 <sHACHAF> replicateM 100 rndGen
01:18:22 <Z`> ah right
01:18:26 <Z`> wow
01:18:30 <sHACHAF> @Ty replicateM
01:18:30 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
01:18:33 <sHACHAF> @ty replicateM
01:18:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
01:18:52 <Z`> yeh, sorry, I was generating tuples of rands previously and got carried away
01:18:58 <Z`> nice to see there's a replicateM
01:19:00 <Z`> :)
01:21:48 <johnw> I must say, having a fully local Hoogle is *nice*
01:26:37 <johnw> wow, I actually had need of the Cont monad
01:27:10 <johnw> and I used it as a transformer over the state monad, I'm scared at myself
01:28:18 <johnw> I feel like (`runContT` return) $ callCC $ \exit -> do .. is an idiom that should be represented by something more compact...
01:28:30 * hackagebot c2hsc 0.3.0 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.3.0 (JohnWiegley)
01:34:59 <MHD> johnw: Template Haskell to the rescue?
01:49:58 <startling> can anyone think of a neat monad to build a static blog compiler around? :)
01:53:16 <johnw> let's make a Metaphor monad
01:53:30 <MHD> Metaphor?
01:53:32 <startling> johnw: the Metaphor monad is like a monad tutorial
01:53:47 <johnw> oh, the Tutorial Monad is a long time coming
01:53:49 <MHD> Oh god why
01:54:01 <johnw> MHD: exactly
01:54:31 <johnw> and beware it's dual, the Cometaphor, or Analogy Comonad
01:54:42 <MHD> class (Monad m) => MonadMetaphor m where { incomprehension :: m a }
01:54:49 <johnw> startling: it's not a Simile monad, I'm sorry
01:54:58 <johnw> it's not "like" anything
01:55:00 <MHD> johnw: Analogies is already a thing in category theory
01:55:14 <johnw> MHD: :)
01:55:32 <MHD> or are they?
01:55:33 <johnw> I'm sure that I myself am in category theory, somewhere
01:55:35 <MHD> I think I was thinking of Allegories
01:55:53 <MHD> The whole universe is math
01:55:53 <MHD> literally
01:55:55 <startling> johnw: wow, good job! you know no one takes a concept seriously unless you're a stickler for terminology
01:55:59 <johnw> haskell.org is back to being really slow again
01:56:59 <johnw> uploading to Hackage is going at like 2 KB/s
01:57:03 <johnw> if that
01:59:52 <bartavelle> oh yes it is crawling :(
01:59:54 <startling> johnw: ah, must be the monomorphism restriction
01:59:57 <startling> you know how it is
02:00:30 <johnw> i have to know how it is, it's only got the one way of seeing it
02:01:09 <bartavelle> it is not only slow, it fails with an error 500
02:02:02 <johnw> oh, you're right
02:02:10 <johnw> my upload got 500, but my hackage mirror says it was there
02:02:44 <johnw> yeah, it's there: http://hackage.haskell.org/package/c2hsc-0.3.1
02:03:03 <bartavelle> same
02:03:13 <johnw> and now upload says "already present"
02:03:22 <johnw> I wonder if the IRC bot  will announce it
02:03:30 * hackagebot hsfacter 0.1.0.3 - A small and ugly library that emulates the output of the puppet facter program.  http://hackage.haskell.org/package/hsfacter-0.1.0.3 (SimonMarechal)
02:03:32 * hackagebot c2hsc 0.3.1 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.3.1 (JohnWiegley)
02:03:35 <bartavelle> it did :)
02:03:39 <startling> haha
02:03:50 <johnw> is one of you Simon?
02:03:53 <bartavelle> me
02:03:56 <johnw> aha!
02:04:03 <johnw> i wanted to hug you for your work on language-puppet
02:04:09 <bartavelle> really ???
02:04:12 <johnw> I'm a huge puppet fan, and Haskell fan, but not so much on the Ruby
02:04:22 <MHD> What is language-puppet
02:04:26 <MHD> ?
02:04:26 <bartavelle> I figured I was the only one interested in doing this
02:04:27 <johnw> yeah, I was reading up on your stuff, and all your blog posts, earlier today
02:04:40 <johnw> MHD: the beginnings of an all-Haskell implementation of Puppet
02:04:45 <bartavelle> despite the fact that it is obviously superior to the puppet version ;)
02:04:59 <t7> ah cool
02:05:04 <johnw> I've wished Puppet were in Haskell for a long time
02:05:12 <bartavelle> MHD, right now I use it daily as a system to check my manifests and templates on my local host
02:05:15 <startling> what's puppet do?
02:05:24 <t7> config
02:05:26 <johnw> i mean, an idempotent system built of declarations is... functional by design!
02:05:32 <bartavelle> startling, it is an incredibly useful configuration management system
02:05:38 <t7> automagicly configers lots of puters
02:05:45 <startling> oh, neat
02:05:51 <johnw> you declare what your system should look like, and puppet makes it look like that; rinse, wash, repeat
02:05:59 <bartavelle> johnw, yes ! but puppet isn't, and I realized it only recently when they released the official documentation
02:06:27 <bartavelle> for example puppet doesn't try to resolve variables that are declared after a statement
02:06:34 <bartavelle> except it is unclear what "after" means
02:06:42 <johnw> the puppet concept needs to be freed from RUby
02:06:46 <johnw> Ruby is such a terrible language for the job
02:06:55 <bartavelle> a terrible language for just about everything
02:06:58 <startling> s/the/every
02:06:59 <johnw> for scripting and DevOps, fine, but for long-running system processes, it really blows
02:07:18 <bartavelle> for anything where you need correctness
02:07:22 <bartavelle> or performance
02:07:27 <MHD> heh
02:07:28 <johnw> I imagine Haskell could compile catalog in milliseconds
02:07:38 * qwr likes perl for small scripting ;)
02:07:41 <bartavelle> my implementation is ~ 10x faster
02:07:47 <bartavelle> but I haven't started optimizing
02:07:52 <MHD> I actually like Ruby for small scripting
02:07:52 <johnw> yeah, exactly, lol
02:07:54 <bartavelle> also it is my first "real" haskell program
02:08:03 <johnw> MHD: I switched to Haskell from Ruby for my scripting
02:08:12 <johnw> I still use zsh for the really small stuff
02:08:12 <t7> i would rather die than write code in ruby or python
02:08:23 <johnw> t7: but how do you really feel?
02:08:30 * hackagebot puppetresources 0.1.2 - A program that displays the puppet resources associated to a node given .pp files.  http://hackage.haskell.org/package/puppetresources-0.1.2 (SimonMarechal)
02:08:38 <johnw> bartavelle: well, keep up the good work; I'll be keeping an eye on it!
02:08:39 <MHD> johnw: gotta make a quasi quote for running bash snipptes
02:08:51 <johnw> MHD: if you do, please send it my way
02:08:57 <johnw> MHD: I do like that about RUby
02:09:34 <johnw> ok, fixed a ton of bugs in c2hsc today, still a few more, but time to sleep now
02:09:56 <t7> is this haskell puppet thing on github/darcsden?
02:10:06 <bartavelle> t7, not yet
02:10:15 <johnw> see http://lpuppet.banquise.net/
02:10:25 <bartavelle> I am a bit embarrased by the first commit messages, will have to clean history first
02:10:39 <bartavelle> it is on hackage obviously, but you won't have the history
02:10:52 <startling> bartavelle: what's it say?
02:11:27 <bartavelle> startling, a lot of fumbling basically, noob discovering haskell, and probably half of it is in french
02:11:35 <startling> haha
02:12:24 <bartavelle> but you can still have a good laugh with the parser, that's the part I wrote first, and I didn't even realize the "do" notation was syntactic sugar
02:12:36 <bartavelle> didn't even realize I was in the Parsec monad too
02:13:27 <startling> I've been there!
02:13:40 <startling> parsec was what got me to haskell
02:13:47 <timthelion> bartavelle: don't worry.  Half of my commit messages are either "going to bed", "if it builds, ship it", and "no longer blocks on MVar opperation."  I don't understand why people rant about the non professionality of commit messages when they are pulling up shit on some developer.  But don't listen to the jerks.
02:14:04 <bartavelle> timthelion heh
02:14:10 <Botje> bartavelle: but you stuck to it and made something cool/useful, so yay to you!
02:14:22 <startling> "deleted all that shit, let's try again"
02:14:26 <startling> "oops, nothing compiles
02:14:31 <timthelion> startling: exactly
02:14:44 <startling> "emacs put a newline there"
02:14:53 <bartavelle> heh
02:14:59 <timthelion> "It parses, now for the type erros, YAAAAAYYYYY!"
02:15:41 <johnw> type errors can still be brutal for me
02:15:48 <startling> same here
02:15:51 <johnw> like >1 hour spent just getting one line of code to compile
02:15:55 <MHD> "I have no idea what my initial idea was anymore"
02:15:59 <johnw> it's getting better, for certain, but every once in a while...
02:16:17 <johnw> that happens to me earlier today
02:16:34 <johnw> had a [m a] and wanted to intersperse it with an a within an m, and oh boy, it got wicked
02:16:53 <MHD> :t intersperse
02:16:54 <lambdabot> forall a. a -> [a] -> [a]
02:17:12 <johnw> I ended up with: (do let declNames = sequence $ map cdeclTypeName decls ++ [pure baseType]; argTypes <- intercalate " -> " <$> (filter (/= "") <$> declNames); return $ "FunPtr (" ++ argTypes ++ ")")
02:17:16 <Botje> johnw: well, the point where you're no longer confounded by type errors is the day you get monads :)
02:17:37 <johnw> monads, nested fmaps, pure, omg
02:17:44 <johnw> i couldn't even have read that two weeks ago
02:18:10 <startling> fmap fmap fmap was a breakthrough for me
02:18:30 <Botje> johnw: heh, i'm still parsing it :)
02:18:35 <johnw> :t (fmap fmap fmap)
02:18:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:18:45 <MHD> :t fmap fmap fmap
02:18:46 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:18:50 <MHD> mindshare!
02:19:19 <Botje> johnw: you could simplify a bit by doing ... (declNames ++ [baseType]) in the second line
02:19:41 <Botje> johnw: and (not . null) looks nicer to me than (/= "")
02:19:45 <johnw> declNames is in the monad, baseType sin't
02:20:10 <Botje> johnw: yes, so you tack it on as a pure value in the intercalate thing
02:20:10 <johnw> Botje: good point, I am using String
02:21:03 <MHD> what is that snippet even supposed to do?
02:21:28 <timthelion> I wasn't saying that I'm never confounded by type errors.  It's just that, at least you know which line their on.   Onlike some indentation error that's actually a missing paren.  Or when GHC decides something isn't in block mode because it's interpreted the currly brackets to mean ; mode.
02:21:42 <timthelion> s/their/they're/
02:21:47 <johnw> it takes a C function type declarator in the language-c AST, and renders it as a Bindings-DSL FFI type signature
02:21:59 <johnw> so, int foo(int, int) becomes CInt -> Cint -> Cint
02:22:07 <Botje> johnw: oh, and you can combine the two pure functions in the intercalate thing
02:22:28 <MHD> johnw: Why not skip a beat and have it generate haskell AST?
02:22:28 <Botje> intercalate " -> " . filter (not . null) <$> declNames -- or something like that?
02:22:35 <johnw> ooh
02:22:58 <johnw> yes, that's much nicer
02:23:02 <johnw> argTypes <- intercalate " -> " . filter (not . null) <$> declNames
02:23:31 <johnw> err, what you said :)
02:24:34 <johnw> MHD: can it?
02:25:54 <MHD> johnw: If you want you can make a quasi-quote [$cfun| int foo (int, int) |] that automatically makes the apprpriate foreign function interface
02:26:27 <johnw> oh, no, these declarations are all in project header files that I don't control
02:26:34 <johnw> I don't actually need to ever type in the C signature
02:26:45 <MHD> ok
02:26:47 <johnw> c2hsc's job is to take any old C header file, and dump out 95% of a .hsc
02:26:57 <MHD> kk
02:27:17 <Reko_> johnw: if you want something which uses the preprocessor to an insane degree, https://github.com/CObjectSystem/COS
02:27:37 <johnw> insanity with the preprocessor is nothing I Fancy
02:27:57 <Reko_> heh. weren't you testing its preprocessor facilities or something?
02:28:36 <sHACHAF> You really should rename it before you have any users.
02:29:03 <startling> what's wrong with c2hsc?
02:29:33 <sHACHAF> There's already an unrelated thing called "c2hs".
02:29:49 <sHACHAF> There's enough confusion and ambiguity in this context. :-(
02:30:39 <johnw> so, there's .hs and .hsc
02:30:43 <johnw> that's the same amount of confusion
02:31:16 <Reko_> call it 'autoc' or something?
02:31:32 <johnw> Botje: got it down to: renderList str xs = intercalate str . filter (not . null) <$> xs
02:31:41 <johnw> now the code that uses it is looking comprehensible
02:32:59 <startling> hmm, makeLenses doesn't seem to be in `lens` anymore?
02:33:10 <startling> well, Control.Lens anyway
02:34:16 <startling> no, it is. weird, dunno why it's not importing
02:34:21 <johnw> the fact that there's a c2hs meant that the very first thing I googled for (and didn't find) was c2hsc, because I wanted to go from a .c file to a .hsc file.  I named it after my first thought of what to look for
02:53:31 * hackagebot c2hsc 0.3.2 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.3.2 (JohnWiegley)
03:14:00 <sqrt_> Do I need to import something before using "type" for defining a new type in my program?
03:14:51 <mikeplus64> sqrt: no (unless your type synonym depends on something that isn't already imported)
03:18:23 <dottedmag> I am reading Milner's "A Theory of Type Polymorphism in Programming", and got lost in section "A Simple Applicative Language and Its Types". What is necessary to read before to understand "semantic domains", "semantic function" etc?
03:18:25 <logicalguy> hi, is there a library for querying excel databases? thanks.
03:18:33 * hackagebot QuasiText 0.1.2.3 - A QuasiQuoter for Text.  http://hackage.haskell.org/package/QuasiText-0.1.2.3 (MikeLedger)
03:19:04 <ion> or Photoshop databases
03:21:30 <tdammers> you can open most photoshop databases using MS Paint, and almost all the queries will just work
03:22:55 <ivanm> logicalguy: I don't believe anyone has bothered to write a package that understands excel files in Haskell
03:23:00 <ivanm> convert it to csv first maybe?
03:23:23 <danr> Maybe Lennart Augustsson has
03:23:30 <sqrt> mikeplus64: Ah, thanks. Removing my imports took care of the error.
03:23:33 * hackagebot QuasiText 0.1.2.4 - A QuasiQuoter for Text.  http://hackage.haskell.org/package/QuasiText-0.1.2.4 (MikeLedger)
03:24:05 <ivanm> @google haskell excel
03:24:06 <lambdabot> http://neilmitchell.blogspot.com/2007/03/hsexcel.html
03:25:52 <timthelion> Is it possible to pattern match against variables?   let f = "hi" in case "hi" of f -> 1 ; _ -> 2
03:26:02 <timthelion> obviously that doesn't work.
03:26:03 <ivanm> well, SpreadsheetML by lispy will let you _create_ files that you can open in excel...
03:26:05 <logicalguy> thanks
03:26:11 <ivanm> timthelion: no
03:26:20 <ivanm> timthelion: use a guard with == ?
03:26:30 <ivanm> (in the case statement)
03:26:36 <timthelion> ivanm: OK.  Somehow that only occured to me imediately after asking.
03:26:45 <ivanm> heh
03:27:09 <ivanm> timthelion: I got caught by that for ages in my first Haskell project; I had an alias for Nothing and expected pattern matching to work for it; took me a while to debug that :p
03:27:26 <timthelion> hehe
03:28:41 <timthelion> yes, it is a bit confusing for newbies that any sequence of letters starting with a lower case one = *...  Took me a while to realise that doing case foo of "something" -> ... ; otherwise -> ... was actually binding any value to the name otherwise.  Always thought otherwise was a keyword.
03:30:06 <ivanm> yup
03:32:44 <hpaste> “Dark Magus” pasted “Binarize” at http://hpaste.org/74283
03:33:07 <statusfailed> Is the function in "foldl1 f xs" a monoid?
03:33:45 <ivanm> statusfailed: well, first of all, values are monoids...
03:33:48 <byorgey> statusfailed: I don't understand your question.
03:34:05 <ivanm> but in the sense of "is it of type a -> a -> a", then yes
03:34:09 <byorgey> no, a monoid is an algebraic structure
03:34:24 <ivanm> byorgey: well, I meant more that a type could be an instance of Monoid
03:34:31 <ivanm> just expressed it really poorly
03:34:35 <statusfailed> I don't mean the Monoid type, sorry
03:34:38 <byorgey> ivanm: I agree with that =)
03:34:47 <ivanm> byorgey: the poor expression? ;)
03:35:05 <byorgey> ivanm: hehe, I mean that types can be instances of Monoids... but both =)
03:35:24 <byorgey> statusfailed: what did you mean then?
03:35:34 <ivanm> statusfailed: so if you're asking if it's a closed binary operation, then yes
03:35:46 <statusfailed> ok, so a monoid is a set (the values a type 'a' can have), plus a binary operation (in this case f)
03:35:50 <ivanm> well, f would be the operator on the monoid
03:35:55 <ivanm> statusfailed: yes
03:36:04 <ivanm> oh, you need an identity as well
03:36:08 <byorgey> statusfailed: plus an associative binary operation, plus an identity element
03:36:22 <timthelion> Who is the trac administer?
03:36:25 <statusfailed> oh right, derp
03:36:31 <statusfailed> so it depends on 'a'
03:36:36 <ivanm> and you need to assure associativity
03:36:36 <statusfailed> in (a -> a -> a)
03:36:39 <ivanm> so it also depends on f
03:36:41 <statusfailed> and that
03:36:45 <statusfailed> ok right :P
03:36:48 <byorgey> statusfailed: the type of the first argument to foldr1 makes it a binary operation on some type.
03:36:56 <byorgey> but there's no requirement for it to be associative.
03:36:59 <ivanm> timthelion: ummm.... contact the haskell.org committee?
03:37:04 <statusfailed> ok, makes sense
03:37:13 <ivanm> byorgey: or have an identity
03:37:31 <byorgey> right.
03:37:56 <timthelion> ivanm: track is curently behaving very iradically, should probably be taken offline quickly before it screws itself up.
03:38:12 <ivanm> timthelion: well, the haskell.org committee runs all the web stuff
03:38:26 <ivanm> can't recall who's in it atm though
03:38:39 <byorgey> we don't really "run" all the web stuff, actually
03:38:45 <statusfailed> ok, this is a bit of a vague followup, but what would be the equivalent structure for "fold"?
03:38:49 <statusfailed> i.e. (a -> b -> a)
03:39:04 <byorgey> there's a separate admin team
03:39:05 <statusfailed> or maybe that question doesn't make sense :\
03:39:20 <byorgey> statusfailed: the question doesn't make sense.
03:39:24 <ivanm> byorgey: what doesn't the haskell.org committee run (or at least is in charge of)?
03:39:26 <statusfailed> dammit! :D
03:39:32 <danil> statusfailed: if you have an identity and the operation is associative, you could call it a monoid action
03:40:04 <byorgey> ivanm: hmm?
03:40:14 <byorgey> danil: oh, that's a good point.
03:40:25 <ivanm> byorgey: you said there's a separate admin team; do you mean separate from the haskell.org committee?
03:40:35 <byorgey> yes
03:40:39 <statusfailed> danil: I think that's what I was trying to ask :)
03:40:41 <statusfailed> thanks!
03:40:59 <timthelion> byorgey: do you know who I should contact?  It was telling me there where some kind of database errors, and that I should contact the administrator.
03:41:32 <ivanm> byorgey: who then, and for what?
03:42:03 <byorgey> you know what, honestly, I don't remember, but I probably should
03:42:27 <byorgey> timthelion: I guess ivanm's suggestion is probably best -- email the haskell.org committee and hopefully one of them will know who to direct you to.
03:42:44 <byorgey> committee at haskell.org
03:43:14 <ivanm> byorgey: you're not referring to the non-existent Haskell Cabal, are you? ;-)
03:44:11 <byorgey> hehe
03:46:08 * timthelion gives up.
03:46:31 <timthelion> Anyone who wants you to subscribe to a mailing list just to submit a bug report is just being evil.
03:47:59 <benmachine> timthelion: which trac, anyway?
03:49:11 <timthelion> benmachine: I wanted to submit a "bug" in STM to ghc trac, since I saw that there are "library" bugs there.  But "library" isn't in any of the dropdown boxes.  The stm package maintainer is "libraries@haskell.org" which is useless to me.
03:49:27 <timthelion> because libraries@haskell.org just tells me I'm not subscribed to the list.
03:49:33 <benmachine> timthelion: ah, hmm.
03:51:11 <benmachine> timthelion: Component: libraries (other)?
03:51:36 <timthelion> The problem, is that the guy who did TChans did a really half assed job at something, and if he doesn't fix it quick, it'll be cemented in the type system forever, to everyone's pain.  The problem is there is not a difference at the type level between a broadcastChan and a normal chan, so reading from a broadcast chan causes the non informative runtime error STM blocked indefinitely.
03:52:05 <sHACHAF> You are free to build your own abstractions on top of TChan.
03:52:06 <ivanm> well, STM has been out for a few years...
03:52:26 <benmachine> yeah it's either too late or it never will be :P
03:52:30 <timthelion> benmachine: I don't see libraries in the Component dropdown
03:52:45 <timthelion> ivanm: broadcast chans where added one minor version ago.
03:52:46 <benmachine> timthelion: are you at hackage.haskell.org/trac/ghc ?
03:52:56 <benmachine> oh, that makes more sense
03:52:56 <timthelion> benmachine: yes
03:53:10 <benmachine> oh um well
03:53:11 <benmachine> I do :P
03:53:17 <benmachine> it's near the bottom
03:53:22 <benmachine> can you scroll down
03:54:17 <ivanm> ahhh, fair enough
03:54:19 <timthelion> benmachine: I see it now.  Maybe it's a firefox bug.  I use very large text, and firefox is crap at rendering with 300% magnification sometimes.
03:54:28 <timthelion> thanks though
03:54:35 <ivanm> timthelion: so getting it fixed quick before the next platform is released would be a good idea
03:54:54 <timthelion> ivanm: yes!
03:55:53 <ivanm> timthelion: try emailing Simon Marlow; he's the one that uploaded the last version in July
03:56:11 <sHACHAF> Or asking him here on IRC...
03:56:53 <ivanm> sHACHAF: it might be a timezone thing, but I don't recall seeing him all that much here
03:57:21 <sHACHAF> But if the "bug" is in released TChan APIs, that's probably not something that's going to change.
03:58:27 <ivanm> *shrug* can't hurt to ask
03:58:51 <timthelion> sHACHAF: it was added in 2.4(the current version) and wasn't in 2.3 this is the only chance to fix the mistake.  You can't just cement something in without ANY testing!
03:59:11 <timthelion> And even a better error message than "blocked indefinitely" would help
03:59:20 <sHACHAF> I don't know that this is a bug.
04:00:13 <timthelion> sHACHAF: it's clearly done wrong.
04:00:46 <benmachine> timthelion: do you have a proposal to replace it?
04:01:59 <timthelion> benmachine: all we need is a typeclas for "writableTChan" and "readableTChan" and make TChan an instance of both and a new type, BroadCastTChan an instance of just one of them.
04:02:15 <timthelion> that shouldn't break any current code.
04:02:21 <sHACHAF> No, we definitely don't need that.
04:02:25 <benmachine> timthelion: it will complicate the API though
04:02:41 <benmachine> typeclasses are not really the solution here, I don't think
04:03:10 <sHACHAF> Here's a value equivalent to writeTChan: (a -> STM ())
04:03:14 <benmachine> (and it probably could break code)
04:03:23 <sHACHAF> To a WriteTChanable thing, that is.
04:03:28 <benmachine> sHACHAF: ah, now that's interesting
04:03:49 <benmachine> if all you can do to a TChan is write it and duplicate it, you might as well just provide a duplicated copy of it and a partially applied write
04:04:53 <timthelion> benmachine: how does that break code?
04:05:41 <benmachine> timthelion: well, I'd need to see an implementation to be sure; I was going on the general assumption that introducing typeclasses can change type signatures and introduce ambiguity
04:05:56 <benmachine> but in this case I admit ambiguity is unlikely to be a problem
04:06:01 <sHACHAF> It doesn't need to break things to be a bad change.
04:06:40 <timthelion> sHACHAF: well the current situation is bad.
04:06:52 <sHACHAF> Perhaps.
04:07:48 <timthelion> Nothing irks me on this channel, more than the dual oppinion that haskell is both perfect, and that it's impossible to fix the obvious problems with things "because it's impossible to do right"
04:08:06 <timthelion> if it's impossible to do things right, than haskell is not perfect.
04:08:28 * sHACHAF has no idea what you're going on about.
04:08:40 <benmachine> timthelion: it's very very far from perfect
04:08:45 <tdammers> I guess it's more that Haskell works best on problems that *have* a correct solution
04:09:08 <benmachine> timthelion: there probably IS a better solution, but it probably isn't the first thing that springs into your head
04:09:32 <benmachine> timthelion: because people have thought about this at least a little, and there are usually reasons why things are the way they are
04:09:54 <benmachine> timthelion: so just have a little caution and humility, and then go ahead and propose what you like
04:09:59 <timthelion> benmachine: if they had thought about it at least a little, than they would have at least changed the error.
04:10:14 <benmachine> timthelion: it's not even necessary that you DO propose a replacement, it's just likely to make things way easier
04:13:05 * timthelion is just irked, because a simple error that the type checker SHOULD have caught just cost him the entire morning and some of last night :(
04:13:58 <sHACHAF> Feel free to make a wrapper on top of TChan.
04:14:04 <sHACHAF> These primitves are designed to be wrapped over.
04:14:37 <timthelion> sHACHAF: I will personally never make the mistake again.  I report bugs to help others.
04:16:23 <timthelion> sHACHAF: so why would I want to make a wrapper?  Title it nonBrokenTChan on hackage ???  What kind of BS is that?
04:16:45 * timthelion appologizes for everything he says right now, because he's pissy from debugging.
04:16:51 <sHACHAF> You're just a h8r.
04:18:37 <timthelion> :D
05:03:50 <nand`> Is there a language extension or other sort of setting that allows multi-line string literals without needing to place \ before every linebreak?
05:04:15 <ivanm> nope
05:04:22 <sHACHAF> You can probably use quasiquotes for it.
05:04:25 <ivanm> there are some packages that let you embed files externally
05:04:43 <ivanm> nand`: I've also used concat with a list of Strings
05:04:51 <ivanm> (or unlines or unwords)
05:04:54 <nand`> ‘unlines’, surely
05:05:04 <ivanm> depends on how I'm doing it
05:05:17 <nand`> fair enough
05:06:16 * typoclass sometimes wishes haskell would offer a python-ish """ syntax
05:06:46 <ivanm> yeah
05:07:25 <ivanm> especially since haskell-mode for emacs doesn't grok multi-line string literals using \
05:07:37 <hpc> vim groks it, but only sometimes
05:08:33 <hpc> typoclass: you can probably do some TH
05:08:39 <hpc> [string|blahblahblah
05:08:42 <hpc> blahblahblah]
05:08:53 <ivanm> there's a few different String/Text quasiquoters around
05:09:19 <typoclass> hm interesting, i'll hit hackage
05:11:39 <benmachine> typoclass: http://hackage.haskell.org/package/string-quote-0.0.1 for e.g.
05:12:17 <typoclass> oh nice. thanks benmachine
05:12:23 <typoclass> nand`: ^^ check that out
05:12:52 <benmachine> there are also some which support interpolation, I think
05:13:06 <nand`> benmachine: thanks
05:13:15 <nand`> interpolation?
05:14:32 <hpc> like perl's "your total is $total dollars"
05:14:36 <benmachine> yeah
05:14:38 <benmachine> that sort of thing
05:14:42 <typoclass> nand`: if you have «let x = "blah" ; y = [s| ... want to access x from in here ...|]»
05:14:48 <nand`> oh
05:15:52 * typoclass thinks that the string quasiquoter is useful even without interpolation
05:16:42 <hpc> i could probably use that too
05:16:48 <hpc> for my website
05:24:31 <typoclass> so, "import Data.Bits ; popCount 6" gives 2 on my i686 linux system. this buddy of mine with a 64-bit mac gets "popCount 6 = 6". any ideas?
05:24:59 <ivanm> what is popCount meant to be?
05:25:04 <Ferdirand> count the 1 bits
05:25:20 <typoclass> yup. "Return the number of set bits in the argument. This number is known as the population count or the Hamming weight."
05:25:55 <typoclass> (32 vs 64 bit might even be a red herring, i was just guessing)
05:25:57 <sHACHAF> typoclass: Bug.
05:26:18 <sHACHAF> It was fixed in a newer version of the package.
05:26:19 <typoclass> sHACHAF: uh-oh :(
05:26:27 <sHACHAF> Precedence error.
05:26:29 <sHACHAF> Sorry. :-(
05:26:34 <sHACHAF> Which type are you using?
05:26:43 <ivanm> yeah, I was about to ask which Bits instance the 6 is
05:26:44 <typoclass> ooooh that thing with the parens? i think i heard about it
05:26:48 <ivanm> I would guess Integer
05:26:58 <ivanm> sHACHAF: how is there a precedence error in "popCount 6" ?
05:27:02 <ivanm> or do you mean in the implementation?
05:27:08 <typoclass> ivanm: in the implementation
05:27:09 <sHACHAF> Yes, the implementation.
05:27:22 <hpc> moral of the story: when in doubt, parenthesize
05:27:33 <hpc> also test your damn code
05:28:02 <amosr> when in doubt, or when unboxed
05:29:46 <typoclass> yeah. "when making a widely-used library, such as base, try to have a unit test, or maybe even several. doesn't have to be fancy. even the most basic test is better than no test, and would have caught that."
05:30:18 <sHACHAF> But, like, type systems, dude!!!
05:31:25 <nand`> @hoogle (a -> b -> m c) -> m a -> m b -> m c
05:31:26 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
05:31:26 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
05:31:26 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
05:31:31 <frerich> Actually, I'm a bit surprised how many people use "popCount". In all the years I worked as a software developer, I don't think I ever needed to count the '1' bits in some value. Is there some common use case for it (except maybe parity bits)?
05:31:40 <deech> In the new 7.6 release if I defer type errors can I still load the program into GHCI and step through it in the debugger?
05:31:40 <deech>  
05:31:52 <typoclass> sHACHAF: yes, the type system can replace 70% of the unit tests, but i don't think all of them
05:32:09 <gensymv> does haskell has a "set" (apart from the Data.Set)  where lookup is O(1)?
05:32:20 <gensymv> *have a set
05:32:51 <hpc> gensymv: search for "hash", and you will likely find it
05:32:55 <hpc> if it exists
05:33:25 <maukd> gensymv: IntSet?
05:33:54 <gensymv> hpc, i found a hashset but that apparently is some sort of balanced binary tree
05:33:55 <mm_freak> Array Int Bool
05:33:58 <hpc> HashMap Foo (), also works
05:34:06 <hpc> if the key exists, it's in the set
05:34:17 <maukd> ByteString
05:34:29 <gensymv> maukd, thanks I am looking in to that right now
05:34:33 <maukd> gensymv: why?
05:34:59 <ivanm> there's also that data structure which was done in RWH which is good for spell checking, etc. though there's some uncertainty with that
05:35:00 <sHACHAF> hi maukd
05:35:04 <sHACHAF> Are you mauke?
05:35:09 <mm_freak> i wonder what's wrong with Set's O(log n) lookup time
05:35:10 <maukd> sHACHAF: yes
05:35:21 <sHACHAF> maukd: What happened?
05:35:26 <maukd> I got decremented
05:35:28 <typoclass> uh, this was the buddy who i was trying to sell haskell to. now i'm getting disillusioned myself. they fixed popCount, but not by adding a test :( http://hackage.haskell.org/trac/ghc/ticket/5872
05:35:41 <sHACHAF> maukd: You used to be in a lot of channels and preflex used to be around.
05:35:45 <sHACHAF> What happened to preflex?
05:35:52 <mm_freak> maukd++
05:35:54 <gensymv> maukd, i thought that was what i wanted apparently that is also a tree
05:36:24 <mm_freak> gensymv: what's wrong with Set?
05:36:38 <maukd> sHACHAF: hardware failure
05:36:45 <sHACHAF> Ah.
05:36:48 <sHACHAF> Is everything lost?
05:36:56 <gensymv> mm_freak, construction is O(n*lg n), lookup is O(lg n)
05:37:13 <mm_freak> gensymv: construction can be O(n)
05:37:16 <maukd> no, I have (probably intact) copies of my source code and preflex's brain
05:37:26 <gensymv> mm_freak: the list isn't sorted.
05:37:36 <mm_freak> my question is:  what's wrong with the logarithmic term?
05:38:09 <gensymv> mm_freak, i am "translating" something i wrote in python to haskell
05:38:27 <gensymv> mm_freak, the python version outperforms the haskell version
05:38:48 <gensymv> mm_freak, i think the lookups and set constructions are the reason
05:39:06 <fmap> Data.HashTable probably has O(1) lookup, but it's in IO
05:39:06 <gensymv> mm_freak, i am repeatedly building sets, so it is the bottleneck of the algo.
05:39:10 <JuanDaugherty> am I misconstruing or does the Haskell culture, as a mass, take the type signature to be the only interesting thing about a function?
05:39:14 <mm_freak> could you show the code?
05:39:21 <gensymv> ofc.
05:39:28 <mm_freak> because i'm very sure Set isn't the reason
05:39:56 <mm_freak> it just takes some getting used to to use it properly =)
05:40:02 <ivanm> JuanDaugherty: the behaviour and what it does does tend to pique our curiousity upon occasion ;)
05:40:05 <typoclass> JuanDaugherty: maybe not the *only* thing, but yeah, it's pretty important
05:40:08 <ivanm> mm_freak: it does? :/
05:40:37 <hpaste> gensymv pasted “n queens” at http://hpaste.org/74288
05:40:39 <Ferdirand> JuanDaugherty: of course not, type signatures do not cover denotational semantics !
05:40:43 * Ferdirand has no idea what that means
05:40:49 <hpaste> gensymv pasted “nqueens” at http://hpaste.org/74289
05:40:59 <sHACHAF> JuanDaugherty: The better your types, the more you care about types and the less you care about values.
05:41:04 <typoclass> JuanDaugherty: especially in the sense of: on a haddock page, the type signatures are the important part and the prose text is fluff. (i'm not very comfortable with that btw.)
05:41:12 <JuanDaugherty> (sorry forgot about #haskell-blah)
05:41:27 <typoclass> no, this channel is the right place
05:41:31 <ivanm> JuanDaugherty: except it _is_ about Haskell
05:41:32 <sHACHAF> JuanDaugherty: In a language (+library) with a sufficiently good type system, you care entirely about the type, because any type is equivalent to any other type.
05:41:35 <sHACHAF> Er.
05:41:36 <ivanm> so it's off-topic in -blah ;)
05:41:46 <sHACHAF> Any function implementing a type is equivalent to any other function implementing it.
05:42:02 <ivanm> but Haskell's isn't quite that good?
05:42:12 <Yuu-chan> @hoogle a -> [a]
05:42:13 <lambdabot> Prelude repeat :: a -> [a]
05:42:13 <lambdabot> Data.List repeat :: a -> [a]
05:42:13 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
05:42:13 <maukd> sHACHAF: at that point your programming language *is* types
05:42:15 * JuanDaugherty is confused, that seemed to belong in -blah.
05:42:17 <typoclass> sHACHAF: sure is. e.g. popCount 4.5.0.0 vs. later ones
05:42:22 <maukd> sHACHAF: and you're simply looking at source code
05:42:42 <ivanm> JuanDaugherty: if it's about Haskell, it belongs here
05:42:47 <ivanm> if it isn't about Haskell, it belongs in -blah
05:42:52 <sHACHAF> maukd: Types can completely specify the behavior of a program without specifying its implementation.
05:43:20 <typoclass> sHACHAF: but not normally in haskell
05:43:26 <sHACHAF> I'm not talking about Haskell.
05:43:26 <Yuu-chan> zipWith (==) [1,1..] (repeat 1)
05:43:32 <Yuu-chan> > zipWith (==) [1,1..] (repeat 1)
05:43:33 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
05:43:34 <sHACHAF> Haskell is only a cheap plastic imitation of that. :-)
05:44:00 <sHACHAF> Imagine something like a quickcheck test suite, except it's all checked statically by the type system.
05:44:58 <typoclass> sHACHAF: yes, given an infinitely powerful type system ...
05:45:04 <sHACHAF> Anyway, your average Haskell value matters quite a lot.
05:45:47 <sHACHAF> But you still get some information in the types.
05:45:53 <sHACHAF> Particularly with parametricity and all that.
05:48:22 <gensymv> mm_freak: here is the python version for comparison: http://bpaste.net/show/M1cZAIQbA4Zj3OT43HcX/
05:50:42 <gensymv> mm_freak: any ideas?
05:52:27 <mm_freak> gensymv: first i need to understand the code =)
05:53:16 <gensymv> mm_freak: it solves the n queens problem, that is it places n queens on a nxn chessboard with no queens attacking each other
05:53:58 <ivanm> @google haskell n-queens
05:54:00 <lambdabot> http://en.literateprograms.org/Eight_Queens_puzzle_(Haskell)
05:54:00 <lambdabot> Title: Eight Queens puzzle (Haskell) - LiteratePrograms
05:56:53 <mm_freak> gensymv: i can look into it later
06:52:32 <matthiasgorgens> would it be possible to have operators that have different priority on the lift than on the right?
06:53:03 <maukd> theoretically yes
06:56:33 <benmachine> but precedence is annoying enough as it is
06:57:25 <maukd> \ -> already works like that
06:57:42 <maukd> a + b + \_-> c + d
07:01:49 <statusfailed> how (if at all) is a monad related to a monoid?
07:02:10 <thirsteh> they sound similar
07:02:19 <statusfailed> haha
07:02:20 <benmachine> statusfailed: monads are related to mathematical monoids
07:02:31 <benmachine> they're not really related to Haskell monoids so much
07:03:16 <statusfailed> benmachine: The monoid class seems almost exactly the same as what wikpedia describes?
07:03:26 <statusfailed> except maybe the laws aren't enforced
07:03:35 <benmachine> statusfailed: yeah except that it's only for combining values
07:03:39 * hackagebot monarch 0.4.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.4.0.0 (NoriyukiOhkawa)
07:03:50 <benmachine> Monad is kind of a monoid of type constructors
07:03:52 <n-dolio> There is a generalization of monoids in category theory. Monads fall under that generalization.
07:04:31 <statusfailed> so there's not a particularly simple relationship? I'll just suck it up and read then :)
07:04:46 <benmachine> statusfailed: the relationship is not interesting to a haskell programmer
07:04:56 <benmachine> it is interesting to a mathematician or theorist
07:05:17 <benmachine> but it requires some considerable background knowledge to make sense
07:05:23 <Lutin`> I must be one of those then
07:05:35 <statusfailed> I'm just really interested for the sake of it, not because I need to use the type classes
07:05:46 <mizu_no_oto> See <=< :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
07:05:51 <benmachine> statusfailed: oh, well, fair enough
07:06:03 <statusfailed> completely valid warning though :)
07:06:29 <statusfailed> mizu_no_oto: are those the 'adjoint functors' i've been puzzling over?
07:06:31 <benmachine> statusfailed: in that case, one definition is "a monad is a monoid in the category of endofunctors"
07:06:53 <statusfailed> .... shit :D
07:06:55 <benmachine> statusfailed: basically what that boils down to is that the function "join" is a way of combining layers of monad
07:06:58 <benmachine> :t join
07:06:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:07:15 <benmachine> so that's a sort of monoidal operation
07:07:25 <statusfailed> join == m >>= id ?
07:07:32 <benmachine> yes
07:07:42 <statusfailed> hah, i've been writing >>= id all this time
07:07:46 <benmachine> but when you tlak about monads in maths, join is actually usually what you use to define it
07:07:57 <statusfailed> oh, ok
07:08:05 <benmachine> because m >>= f = join (fmap f m)
07:08:20 <statusfailed> ah! makes sense!
07:08:40 <statusfailed> well, when I replace everything with the list monad anyway :p
07:08:50 <benmachine> if you formulate the monad laws in terms of join
07:09:09 <benmachine> the monad laws basically say that if you have m (m (m a)) then it doesn't matter whether you join the inner m or the outer m first
07:09:18 <benmachine> i.e. join (join m) is the same as join (fmap join m)
07:09:33 <benmachine> so that's how join is a bit monoidy
07:09:46 <statusfailed> oh, so 'join' is the function of the monoid?
07:09:54 <benmachine> not... exactly
07:09:58 <benmachine> I'm being super informal here
07:10:00 <Cale> well, yes :)
07:10:06 <benmachine> partially because I've forgotten the details
07:10:25 <benmachine> plus I haven't even actually done a category theory course yet
07:10:25 <Cale> join corresponds to multiplication, abstractly
07:10:27 <benmachine> that's next term :P
07:10:32 <statusfailed> well lots of missing puzzle pieces in my brain are being found, so it's very useful
07:10:32 <Cale> and return corresponds to the identity
07:10:40 <statusfailed> Cale: as in the 'dot' of the monoid?
07:10:46 <Cale> yeah
07:10:57 <statusfailed> what was an endofunctor again?
07:11:07 <statusfailed> maps back into same category?
07:11:10 <benmachine> yes
07:11:10 <Cale> yes
07:11:16 <statusfailed> a -> m a
07:11:20 <statusfailed> er, m b
07:12:04 <statusfailed> so it's a monoid (join, return) on the category of endofunctors (a -> m b)
07:12:07 <statusfailed> I think?
07:12:15 <Cale> If you think about the classical description of a monoid, you have some set M, and you have some identity 1 in M, and multiplication mu: M x M -> M satisfying unit and associativity laws.
07:12:40 <Cale> m is the endofunctor here, not the maps a -> m b
07:12:45 <benmachine> statusfailed: I think your notion of endofunctor is weird
07:12:50 <statusfailed> yes, probably :D
07:13:01 <Cale> though you can also do this differently and say that you get a category structure
07:13:09 <Cale> (the Kleisli category)
07:13:20 <statusfailed> I did lots of C++ when I was younger and often think of "functor" to be equivalent to "function" :|
07:13:50 <benmachine> statusfailed: do you know the definition of a category?
07:14:20 <statusfailed> nope
07:14:36 <Cale> Oh, let's cover that basic detail first then :)
07:14:53 <Cale> So a category C consists of:
07:15:31 <Cale> 1) A collection of objects of C, called Ob(C) (this might be a set, but could also if you're into the technical details be a proper class)
07:16:15 <Cale> 2) For each two objects X and Y in Ob(C), a collection of arrows C(X,Y). When f is an arrow in C(X,Y), we write f: X -> Y.
07:16:48 <maukd> is this just a relation?
07:17:11 <nand`> you mean C(X,Y) ? or f ?
07:17:12 <statusfailed> Why is 'f' not called a function?
07:17:19 <Cale> because it might not be a function
07:17:24 <nand`> statusfailed: because some arrows have nothing to do with functions
07:17:28 <maukd> C(X,Y)
07:17:37 <statusfailed> I thought a function was just something mapping something to something else
07:17:42 <nand`> maukd: I was under the impression that a relation can have each pair occur only once
07:17:44 <earthy> and you have arrow composition, right, in categories?
07:17:45 <maukd> wait, I'm thinking it wrong
07:17:59 <nand`> (you can have multiple arrows between the same two objects, by contrast)
07:18:03 <statusfailed> basically, what's the difference between a function / morphism / arrow / map
07:18:14 <Cale> maukd: C(X,Y) is closer to being a whole set of things for each X and Y (in fact, it can be bigger than a set will allow, but that's a technicality)
07:18:14 <rwbarton> it would be a relation if every C(X,Y) was either empty or a singleton set, and if he wasn't going to add pieces of structure (3) and (4) and axioms (5) and (6)
07:18:29 <nand`> C(X,Y) is a relation in poset categories
07:18:35 <earthy> i.e. for each arrow f : X -> Y, g : Y -> Z there should be an arrow h : X -> Z ?
07:18:57 <maukd> yes
07:19:11 <Cale> earthy: yes, and that's written g . f
07:19:31 <nand`> statusfailed: an arrow could be something like ≤ which has little to do with functions or maps
07:19:35 <earthy> good. my mind hasn't withered too much from doing dull line of business stuff then.
07:19:38 <maukd> so ... closed under composition?
07:19:39 <Cale> earthy: Note, not all compositions will be distinct, it just has to give some arrow X -> Z
07:19:56 <Cale> (such that the laws I'm about to describe are satisfied)
07:20:15 <nand`> closed and total under composition
07:20:24 <earthy> cale: yeah, so e.g.  given f: X -> Y, f' : X ->Y , g: Y -> Z, g': Y-> Z, such that f != f' and g != g' you may have g' . f' == g . f
07:20:40 <Cale> earthy: yes
07:20:44 <earthy> for some interpretation of != and ==, obviously
07:21:11 <Cale> 4) For each 4 objects, W, X, Y, Z, and arrows f: Y -> Z, g: X -> Y, and h: W -> X, the compositions f . (g . h) and (f . g) . h must be equal.
07:21:32 <earthy> ah!
07:21:37 <maukd> assocativity
07:22:14 <Cale> 5) For each object X, there is an identity arrow id_X: X -> X, such that for any object Y and arrows f: X -> Y, g: Y -> X, we have f . id_X = f, and id_X . g = g.
07:22:22 <benmachine> earthy: in fact you probably will have that, say with g' = r . q, f' = p, g = r, f = q . p
07:22:30 <Cale> and that's it :)
07:22:45 <mux> I thought this was #haskell and not ##categorytheory
07:22:54 <Cale> statusfailed: So a category is like an abstraction of the setting of sets and functions.
07:23:01 <benmachine> mux: sure, but they're related
07:23:16 <byorgey> mux: if this were ##categorytheory we would not be discussing the definintion of a category.
07:23:27 <Lutin`> ^
07:23:31 <statusfailed> Cale: hang on, where was 3?!  :D
07:23:39 <mux> benmachine: many things relate to haskell. to some extent, any other programming language does.
07:23:49 <nand`> I see categories as an extension of monoids to ‘composable things’, which are like monoids but you can't compose everything with everything
07:24:09 <nand`> statusfailed: totality, I believe he left it out since it was covered between the lines
07:24:13 <nand`> as in, between Cale's lines
07:24:14 <byorgey> nand`: yes, you can think of categories as "typed monoids"
07:24:48 <byorgey> in the sense that a monoid is "untyped" since you can compose anything with anything else
07:24:55 <nand`> unityped :)
07:25:05 <byorgey> but a category introduces "types" (the objects) which restrict what compositions you can do.
07:25:09 <statusfailed> nand`: totality?
07:25:19 <Cale> statusfailed: right you are, sorry, lol
07:25:22 <byorgey> sure, untyped = unityped =)
07:25:27 <Cale> statusfailed: you can renumber them :)
07:25:30 <nand`> statusfailed: given f :: X -> Y and g :: Y -> Z; g.f ∈ Hom(C)
07:25:46 <nand`> or rather, g.f ∈ C(X,Z)
07:25:56 <Cale> oh, yeah
07:26:13 <Lutin`> You said it earlier: [10:19:56] <nand`> closed and total under composition
07:26:24 <statusfailed> oh sorry, I didn't know what that meant
07:26:31 <Cale> Right, 3 was supposed to be the the existence of composition
07:26:43 <Cale> but it sort of got blended in
07:26:46 <nand`> note that categories share most of those properties with monoids (associativity, totality, closure, identity)
07:26:49 <statusfailed> so C(X,Z) can be infinite?
07:26:49 <Cale> rather than being clearly stated
07:26:54 <rwbarton> "closed under composition" is not really the right terminology, that suggests there is a pre-existing composition C(Y,Z) x C(X,Y) -> something else containing C(X,Z) and the axiom is that it lands in C(X,Z)
07:27:00 <nand`> statusfailed: FSVO infinite
07:27:04 <statusfailed> FSVO?
07:27:07 <nand`> for some value of
07:27:14 <Cale> C(X,Z) can even be a proper class, which is larger than any set :)
07:27:33 <nand`> statusfailed: consider the category ℕ, it has as many arrows as there are natural numbers
07:27:41 <statusfailed> nand`: as in "one of the sizes of infinity"?
07:27:43 <Cale> (i.e. you can have it be an arbitrary predicate on sets, deciding whether or not sets belong to C(X,Z))
07:27:50 <statusfailed> like, integer infinite, but not real infinite?
07:27:59 <benmachine> totality and closure are weird axioms, it's like, you have this operation, and then totality and closure are axioms saying, look, this really *is* an operation
07:28:01 <Lutin`> nand`: What are the arrows in that category
07:28:19 <nand`> statusfailed: as in “yes, but foundational issues can arise when you start dealing with infinities and sets”
07:28:33 <statusfailed> ok, I'm going to ignore any issues there then :P
07:28:34 <Cale> statusfailed: there are a bunch of mathematical legal issues regarding the sizes of these things if we want to get into really serious technical details
07:28:44 <nand`> I'm not too sure on the specifics, but as Cale mentioned they can be proper classes; categories are also distinguished based on this sort of thing (small categories, large categories etc.)
07:29:03 <nand`> Lutin`: the natural numbers
07:29:04 <statusfailed> I just meant because if g.f  ∈ C(X,Z), then h.g.f  ∈ C(X,Z')
07:29:05 * benmachine is personally of the view that category theory needn't bog itself down with all that stuff as such
07:29:19 <Cale> small categories are categories which only a *set* (even an arbitrarily large infinite set) of objects, and where C(X,Y) is always a set.
07:29:20 <statusfailed> I'm going to avoid infinities for now then :D
07:29:29 <Cale> Nono, ordinary infinities are fine
07:29:33 <Lutin`> nand`: But I thought the objects were the naturals
07:29:43 <nand`> Lutin`: nope
07:29:48 <nand`> Lutin`: not in ℕ
07:29:53 <Cale> The tricky thing is because we want to be able to say there's a category whose objects are all sets, and where C(X,Y) is the set of functions X -> Y
07:30:02 <nand`> (ℕ,0,+) I should say
07:30:08 <statusfailed> ah maths, only when discussing you will I hear "ordinary infinities"
07:30:09 <statusfailed> :D
07:30:31 <Cale> So, since there is no set of all sets, this is a problem, technically
07:30:38 <statusfailed> is this russell's paradox?
07:30:43 <Cale> Not quite
07:30:51 <benmachine> it's somewhat related
07:30:52 <rwbarton> (some) category theorists write e.g. Bℕ for the category with a single object * and morphisms ℕ
07:30:55 <nand`> statusfailed: totality itself doesn't imply infinite, since arrows can be equal; eg. consider id . f = f; the composition is defined, but it's not a separate arrow
07:31:10 <Cale> Russell's paradox has to do with there being a set of all sets which don't contain themselves as an element.
07:31:14 <nand`> statusfailed: indeed, categories can exist with very small numbers of arrows, including 0
07:31:29 <benmachine> the fact that there is no set of all sets is a consequence of one way of avoiding russel's paradox
07:31:46 <benmachine> (it's not actually the /only/ way of avoiding russell's paradox)
07:32:26 <statusfailed> So in summary: the number arrows in C(X,Y) can be anywhere from 0 to SVO infinite
07:32:29 <statusfailed> ?
07:32:55 <Cale> yes
07:33:16 <Cale> In fact, there's also something called the category of spans of sets
07:33:21 <Cale> Whose objects are again sets
07:33:42 <maukd> what is a set?
07:33:48 <Cale> and where the arrows X -> Y are choices of a set Z, together with functions Z -> X and Z -> Y
07:34:25 <Cale> (and the composition is a funny thing I'm not sure I want to get into right now)
07:35:05 <nand`> statusfailed: I can demonstrate a category in which exist X, Y such that C(X,Y) has the same number of arrows as any natural number; namely Set - C({a},{b₁,b₂..bn}) has exactly n arrows
07:35:10 <Cale> But there are so many choices of a set Z with those arrows that there isn't even a set of all the choices, because there's too many. :)
07:35:35 <nand`> so that pretty much covers the ‘can be anywhere from 0 to infinity’ bit
07:36:11 <statusfailed> wait, if there's an identity morphism, shouldn't it be at least 1?
07:36:20 <statusfailed> oh, it's any two objects
07:36:21 <statusfailed> nevermind
07:36:25 <Cale> statusfailed: C(X,X) is always inhabited
07:36:40 <benmachine> ...assuming there are any X, presumably?
07:36:46 <statusfailed> sorry, what does inhabited mean? :)
07:36:52 <benmachine> statusfailed: contains anything
07:36:54 <Cale> has an element
07:36:57 <benmachine> nonempty
07:37:06 <maukd> someone lives there
07:37:16 <Cale> Okay, so some examples...
07:37:32 <nand`> benmachine: it's true even if there are no X
07:37:37 <nand`> vacuously so
07:37:41 <benmachine> nand`: I suppose so
07:37:42 <statusfailed> oh, it's inhabited because there is an identity arrow
07:37:43 <statusfailed> derp
07:37:51 <statusfailed> waiiiit
07:37:58 <statusfailed> yes
07:38:07 <Cale> You know that a monoid is a set M together with a function M x M -> M called multiplication, with an identity element and such that multiplication is associative.
07:38:11 <nand`> basic examples of categories: 0 and 1
07:38:26 <nand`> 0 is the empty category; 1 is the trivial category
07:38:32 <Cale> Now consider a category with only one object, (call it *, say), so all the arrows go * -> *
07:39:15 <statusfailed> So C(*,*) == {id} ?
07:39:23 <nand`> no
07:39:23 <Cale> This is still required to have a composition, combining arrows f, g: * -> * into other arrows (f.g): * -> *
07:39:26 <maukd> statusfailed: unlikely
07:39:31 <statusfailed> ... dammit
07:39:33 <nand`> but C(*,*) ⊇ {id}
07:39:37 <Cale> and it's required to have an identity id_*: * -> *
07:39:43 <statusfailed> nand`: what's that little guy in the middle there ?:)
07:39:48 <maukd> statusfailed: consider Int -> Int
07:39:51 <nand`> ‘superset of’
07:40:00 <statusfailed> oh, I think the font mangled it
07:40:02 <Cale> and composition is required to be associative
07:40:11 <Lutin`> nand`: HOw'd you type that
07:40:21 <nand`> by pressing F2, if that helps
07:40:32 <Cale> So, for any monoid (M,*), we can make a one-object category, whose arrows are the elements of M, and whose composition is the multiplication in the monoid.
07:40:43 <Lutin`> Damn that doesnt ;P
07:40:52 <Cale> and vice-versa, we can take a one-object category, and its arrows will form a monoid under composition
07:40:52 <nand`> and whose identity is the identity of the monoid
07:40:57 <Lutin`> I would kill for an IRC client that would display LaTeX
07:40:58 <Cale> right
07:41:05 <maukd> damn, I can only type ⊂ and ⊃
07:41:17 <Cale> statusfailed: okay?
07:41:17 <statusfailed> Cale: just to clarify: our category has only one object, *. That means there is only one arrow- which is equal to the identity. Is that wrong?
07:41:25 <benmachine> Lutin`: I use http://www.w3.org/TR/MathML2/bycodes.html and ctrl-shift-u hex sequence
07:41:29 <Cale> statusfailed: No, one object, many arrows from that object to itself
07:41:36 <maukd> statusfailed: consider Int -> Int
07:41:39 <Cale> statusfailed: Which means that any two arrows are composable, basically
07:41:40 <benmachine> (actually, ctrl-shift-hex sequence, this terminal is weird)
07:41:46 <nand`> (it is perhaps interesting to note that category-like constructs also readily arise from semigroups and groups, the little and big brothers of monoids: they're called semicategories (or semigroupoids) and groupoids)
07:42:09 <statusfailed> Hm. How do you have more than one arrow if there's only one object?
07:42:18 <Cale> statusfailed: For example, we have the category with one object, and whose arrows are all real numbers, and where composition is addition
07:42:27 <nand`> statusfailed: C(*,*) can be infinitely large, remember?
07:42:35 <statusfailed> I think I have fundamentally misunderstood something
07:42:35 <Lutin`> statusfailed: Because arrows are not functions!
07:42:40 <statusfailed> ^ I think that's it
07:42:44 <Cale> So for example, 6: * -> *, and 10: * -> * will compose to give 16: * -> *
07:42:56 <benmachine> Lutin`: but even when they are, you can have more than one arrow
07:43:05 <statusfailed> I don't understand how a real can correspond to an arrow
07:43:10 <Lutin`> Well I think what I mean to say
07:43:23 <benmachine> the key point is that the "type" of an arrow doesn't tell you what arrow it is
07:43:30 <Cale> statusfailed: The arrows can be anything we want them to be, so long as composition is defined, is associative, and has an identity
07:43:30 <rwbarton> arrows are whatever we say they are, go back to part 2) of the definition of a category
07:43:35 <maukd> statusfailed: consider Int -> Int
07:44:14 <Cale> statusfailed: So, in this case, all those things are true, because addition of any two real numbers is defined, it is associative, since (a + b) + c = a + (b + c)
07:44:20 <Cale> and there's an identity, namely 0
07:44:21 <statusfailed> is that category definition written down anywhere? I should've copy/pasted
07:44:25 <statusfailed> I mean in a link
07:44:51 <Lutin`> Yeah lol [10:19:56] <nand`> closed and total under composition
07:44:53 <Lutin`> WHoops
07:44:55 <Lutin`> http://en.wikipedia.org/wiki/Category_(mathematics)#Definition
07:44:57 <Cale> http://en.wikipedia.org/wiki/Category_(mathematics) -- there's a definition here with ever-so-slightly different notation
07:45:02 <rwbarton> http://ncatlab.org/nlab/show/category#with_a_family_of_collections_of_morphisms_12
07:45:04 <Lutin`> I keep switching my clipboards
07:45:16 <nand`> statusfailed: if it helps, you could consider a category ℕ' with object Integer and arrows like the Haskell functions (1+), (2+), etc.; with the usual composition:  identity is now (0+) since (0+) . (n+) = (n+); and composition readily associates
07:45:17 <Cale> they write hom(a,b) where we'd write C(a,b)
07:45:23 <statusfailed> I'm reading the wiki one actually, it's just this that was confusing me: "a class hom(C) of morphisms, or arrows, or maps, between the objects"
07:45:30 <maukd> Cale: when I treat reals as arrows of some object, is that like phantom arrows?
07:45:38 <statusfailed> I guess I'm still having trouble seeing how a real can be"an arrow between the objects"
07:45:39 <Cale> statusfailed: Yeah, they also lump all the arrows together
07:45:51 <Cale> maukd: what do you mean phantom?
07:46:05 <Lutin`> I like your link rwbarton
07:46:07 <Cale> statusfailed: The definition of a category doesn't ever say that the arrows have to be functions
07:46:20 <maukd> Cale: it's like they're tagged/indexed/something by objects but the underlying implementation is just a number
07:46:23 <statusfailed> so the "between the objects" is misleading?
07:46:27 <Lutin`> statusfailed: look at rwbarton's link
07:46:34 <nand`> what does ‘between’ have to do with functions?
07:47:09 <maukd> newtype Foo a b = Foo Real
07:47:21 <Cale> statusfailed: It can be a little confusing when we reduce the picture to having only one object, and have many arrows between that object and itself, I suppose.
07:47:29 <Cale> statusfailed: But that's also allowed.
07:48:10 <Cale> statusfailed: From the category point of view, we don't look *inside* the arrows themselves. All the structure is provided by which objects and arrows exist, and how the arrows compose to give other arrows.
07:48:11 <statusfailed> I'm feeling pretty thick, but I still don't understand how, say, "10" can be "a morphisms from x to y"
07:48:22 <statusfailed> a morphism*
07:48:22 <Cale> statusfailed: because we say it is
07:48:26 <Lutin`> ^
07:48:29 <statusfailed> ok- so what is x and what is y?
07:48:41 <nand`> something and something, respectively
07:48:41 <Cale> statusfailed: We're providing this data when we define a category
07:48:45 <earthy> statusfailed: whe have an object, say 'reals' and 10 : reals -> reals
07:48:54 <Cale> statusfailed: So we can make the objects and arrows be whatever we like
07:49:14 <Cale> They don't have to be sets and functions
07:49:20 <statusfailed> wait, so 'reals' is a single object in your whole category?
07:49:27 <Cale> yes, in his category
07:49:28 <earthy> statusfailed: the number arrow is not unlike the number objects in e.g. smalltalk
07:49:32 <Cale> Let's take another example...
07:49:37 <Lutin`> Hmm
07:49:49 <Lutin`> Or peano numbers?
07:49:52 <statusfailed> So earthy's category might be (for example) the category of Haskell types...?
07:49:55 <statusfailed> or am I way off
07:50:07 <earthy> statusfailed: um... that is kinda way off :)
07:50:10 <statusfailed> ok nevermind then.
07:50:11 <statusfailed> :D
07:50:16 <Cale> statusfailed: Well, let's hope not, the category of Haskell types should be way larger than that :)
07:50:22 <Lutin`> statusfailed: Just think about it this way
07:50:24 <nand`> Lutin`: that's just ℕ again
07:50:34 <Lutin`> It doesn't matter what the arrows are as long as they follow rules
07:50:38 <maukd> newtype Arrow a b = Arrow Real;  x :: Arrow () (); x = Arrow 3
07:50:41 <Lutin`> They can be numbers
07:50:44 <Lutin`> THey can be cows
07:51:12 <Cale> statusfailed: Let's say we have again a one-object category, and let the arrows consist of all strings on the alphabet {a,b,c,...,z}
07:51:16 <nand`> (isn't it essentially limited to sets via the definition ?)
07:51:16 <rwbarton> maukd: with data kinds and kind polymorphism you could even make 'a' and 'b' range over the kind '() rather than *, then you have a true one-element category
07:51:18 <maukd> compose :: Arrow b c -> Arrow a b -> Arrow a c; compose (Arrow x) (Arrow y) = Arrow (x + y)
07:51:24 <Cale> statusfailed: and take composition to be concatenation
07:51:27 <maukd> rwbarton: ooh, nice
07:51:28 <rwbarton> (if I have the syntax right)
07:51:33 <Cale> statusfailed: and the empty string to be the identity
07:52:27 <saml> can i help you?
07:52:28 <statusfailed> Cale: does it make sense to ask what the object in the category is?
07:52:54 <Cale> statusfailed: No. In fact, it's super-irrelevant in this case. The objects only exist to help us say which arrows will compose.
07:52:55 <statusfailed> it seems like it doesn't matter
07:53:13 <rwbarton> it's like asking what the vertices of a graph "are"
07:53:15 <nand`> statusfailed: the general trend of categories is to focus less on what the objects are, and focus instead on what the arrows are
07:53:23 <Cale> and if they all compose, then the lone object doesn't really do much except to tell us to go ahead and compose them :)
07:53:26 <statusfailed> ok, that is making more sense- I was thinking the other way around
07:53:58 <maukd> phantoms \o/
07:54:08 <maukd> they're just tags on the arrows
07:54:09 <nand`> no, the objects are just like literal encodings of the arrow graph; it's the arrows themselves that you're interested in
07:54:10 <Cale> Okay, so other extreme, let's look at categories with many objects, but at most one arrow between any two of them
07:54:27 <Cale> and to do that, I'm going to say what a preorder is
07:54:35 <statusfailed> oh, and that explains why you can have arbitrarily many arrows- because you can define as many as you want
07:54:38 <Lutin`> statusfailed: YOu can think of a category as a directed graph with multiple edges
07:54:42 <statusfailed> which sounds really obvious now
07:54:51 <Lutin`> With a rule of how to compose those edges to get a new one
07:55:21 <Lutin`> not sure if that helps focus on the arrows, but
07:55:23 <statusfailed> Lutin`: and in this case, our digraph has arrows all going back to the (single) node?
07:55:27 <Cale> A preorder is a set S with a relation <= such that for any x in S, we have x <= x (reflexivity), and for any x, y, z in S, whenever x <= y and y <= z, we have x <= z (transitivity)
07:55:33 <maukd> let's say I take a bunch of objects and turn each object into its identity arrow. do I have a category now?
07:55:42 <rwbarton> maukd, yes
07:55:44 <Lutin`> statusfailed: yes
07:55:46 <nand`> statusfailed: in the monoid example yeah, there's only one node
07:55:53 <rwbarton> it is called a discrete category
07:55:57 <Cale> If we have a preorder (S, <=), we can make a category whose objects are the elements of S
07:56:17 <Cale> and for which there's a unique arrow x -> y iff x <= y
07:56:31 <nand`> maukd: yes, that's pretty much what a set would be in CT terms
07:56:41 <Cale> So the presence or absence of arrows tells us whether or not the relation is true
07:56:44 <nand`> (thus showing that they're generalizations)
07:56:52 <Lutin`> statusfailed: There is the category Set in which the objects are sets and a morphism f:x→y is a function from the set x to the set y.
07:57:09 <Lutin`> I think that's what you were trying to fit to earlier
07:58:16 <statusfailed> Cale: ok, that makes sense- but how can it be used?
07:58:28 <statusfailed> Lutin`: oh, I think you're right
07:58:34 <Cale> statusfailed: Well, all the usual orderings happen to be preorders too
07:58:48 <Cale> statusfailed: So we get lots of examples of categories like this
07:59:12 <maukd> wait, any set can be preordered, right?
07:59:12 <Cale> For example, we can again take the real numbers, they're ordered in a way which satisfies those two axioms for a preorder
07:59:19 <maukd> and if you preorder now ...
07:59:23 <Cale> and so we can form a category whose objects are the real numbers
07:59:30 <Lutin`> Honestly rwbarton
07:59:35 <Cale> and for which there's a unique arrow x -> y whenever x <= y
07:59:37 <Lutin`> That link you posted was perfect
07:59:47 <statusfailed> yeah, that link is very useful
07:59:53 <Cale> yeah, this one? http://ncatlab.org/nlab/show/category#with_a_family_of_collections_of_morphisms_12
08:00:01 <rwbarton> a wiki about category theory written by category theorists is a good resource for category theory yes :)
08:00:01 <Lutin`> Yeah, the entire page
08:00:10 <Cale> haha
08:00:11 <Cale> yes
08:00:16 <nand`> Cale: categories in which each pair of objects has exactly one arrow form a partial order (in addition to a preorder), don't they?
08:00:32 <Lutin`> Well I mean I can understand everything in it :D
08:00:40 <Cale> statusfailed: Note that in a category like this, composition is trivial, because whenever we need to define it, there is a unique arrow to define as the composite
08:00:43 <Lutin`> They expect -just- enough previous knowledge
08:00:54 <Cale> nand`: Not necessarily
08:01:20 <Cale> nand`: For example, we can have a category with three objects, a,b,c, and arrows a -> b, b -> c, c -> a, as well as identities
08:01:29 <Cale> and those give a preorder, but not a partial order
08:01:52 <Lutin`> I really like category theory...so much abstraction~
08:02:01 <Cale> oh, right, we also need the other direction of all those, but that's implied :)
08:02:16 <Cale> c -> b is the composite of c -> a and a -> b, for instance
08:02:51 <statusfailed> wait; why do we need the other direction?
08:02:54 <statusfailed> you mean c -> a?
08:03:03 <nand`> but then A and B have two distinct arrows between them (a -> b) and the implied (b -> a), thus violating the initial condition
08:03:11 <Cale> yeah
08:03:19 <Cale> er
08:03:30 <statusfailed> doesn't the existence of c -> a mean c <= a ?
08:03:36 <Cale> statusfailed: Indeed :)
08:03:47 <statusfailed> but it's... not?
08:03:57 <statusfailed> wat :|
08:03:58 <Cale> statusfailed: The reason these are called preorders is that they still allow some stuff which we usually don't like about orderings
08:04:01 <nand`> in a preorder, a ≤ b ∧ b ≤ a can be true
08:04:15 <Cale> Specifically, it's allowed for a <= b and b <= a and those two not to be equal
08:04:22 <nand`> for a≠b
08:04:38 <statusfailed> double wat
08:04:39 <Lutin`> statusfailed: Don't get confused, he was showing a contridiction in nand`'s statement
08:04:45 <Lutin`> Cale was earlier
08:04:46 <statusfailed> oh right
08:04:51 <statusfailed> ok, I jumped in halfway
08:05:16 <nand`> I wasn't aware there was a contradiction in my statement
08:05:27 <Lutin`> I don't mean it was in the statement
08:05:28 <nand`> it was a contradiction in Cale's counterexample
08:05:37 <Lutin`> That's what I meant to convey
08:05:40 <Lutin`> Worded it wrong
08:05:41 <nand`> I see
08:06:10 <Cale> Wait, one of my examples was contradictory? :)
08:06:22 <Cale> Oh, right, this isn't a partial order
08:06:32 <nand`> Cale: you gave a -> b, b -> c, c -> a as a counterexample to “categories in which each pair of objects has exactly one arrow form a partial order”
08:06:39 * nand` types slowly
08:06:40 <Cale> yes
08:06:48 <Cale> okay, so...
08:07:05 <Cale> statusfailed: How much mathematics have you had?
08:07:28 <Cale> statusfailed: Basically every branch of mathematics contributes at least one or two big examples of categories
08:07:29 <nand`> A) not enough, B) not enough, C) not enough
08:08:00 <statusfailed> haha, true ^
08:08:21 <statusfailed> I have a CS/EE degree, but not much stuff like this
08:08:26 <Lutin`> Yeah no matter how many math classes I take I never feel like I'm closer to knowing it all because there's always something I don't
08:08:30 <nand`> I'd prefer to formulate it the other way around, categories can be used to reason about examples in every branch of mathematics
08:08:36 <Cale> statusfailed: For example, there's a category of vector spaces, and linear transformations between them, a category of topological spaces and continuous maps, a category of metric spaces and contraction mappings, groups and group homomorphisms, rings and ring homomorphisms, graphs and graph hom... you get the idea :)
08:08:58 <statusfailed> sure :)
08:09:03 <nand`> Lutin`: and then there's topology
08:09:14 <Lutin`> I took topology
08:09:16 <Lutin`> I don't remember it
08:09:29 <nand`> it means you retained your sanity
08:09:32 <Cale> Basically throughout mathematics, we study various sorts of objects, and various structure-preserving mappings between those, and those all provide examples of categories.
08:09:48 <Lutin`> I got throught the course but it never clicked
08:09:48 <nand`> there's a category of categories
08:09:58 <nand`> surely that's an example that doesn't invoke dependencies :)
08:10:18 <Cale> Right, now, we have these things called categories, we want to be able to say what are the structure-preserving transformations between them
08:10:28 <Cale> and we're getting back to the original line of discussion
08:10:34 <Cale> What is a functor?
08:10:55 <statusfailed> an arrow?
08:10:59 <Cale> Given two categories C and D, a functor F: C -> D
08:11:05 <statusfailed> oh right
08:11:10 <nand`> a functor is an arrow in the category of categories, yes
08:11:10 <Cale> assigns to each object X in C, some object FX in D
08:11:16 <nand`> but not in any others
08:11:18 <Cale> and to each arrow a: X -> Y in C
08:11:25 <Cale> an arrow Fa: FX -> FY in D
08:11:32 <Cale> such that:
08:11:42 <Cale> F(id_X) = id_(FX) for every object X in C
08:12:58 <Cale> and for every three objects in C, X, Y, Z and arrows u: Y -> Z, and v: X -> Y (i.e. every pair of arrows in C which compose), we have F(u . v) = (Fu) . (Fv)
08:13:16 <nand`> (note that the laws of functors are the same as the laws of monoid homomorphisms; namely f e = e' and f (a*b) = f a * f b)
08:13:40 <nand`> to perhaps provide a somewhat convenient example
08:13:46 <nand`> fmap id = id; fmap (f.g) = fmap f . fmap g
08:13:47 <Cale> Right, so if we restrict this to one-object categories, we get monoid homomorphisms
08:14:18 <Cale> If we restrict this to preorder categories (with at most one arrow between any pair of objects), we get monotone increasing functions.
08:14:32 <nand`> and for sets, we get total functions :)
08:14:34 <Sculptor> hi
08:14:43 <Cale> sorry, what?
08:15:07 <nand`> functors on sets as discrete categories are just set functions
08:15:35 <Cale> oh, right, we didn't talk about the discrete and indiscrete categories, but yeah
08:15:40 <Cale> Those are good examples too :)
08:15:46 <nand`> it was mentioned earlier a few times
08:15:49 <Cale> oh, okay
08:16:09 <Lutin`> I love that one word cloud of #haskell where the most used word was 'just'
08:16:52 <nand`> would it be accurate to say that functors generalize the concept of homomorphisms; in that a functor over an X represented as a category tends to be an X homomorphism ?
08:17:26 <Cale> mmm...
08:17:41 <Cale> I guess if you're able to represent X as a category
08:17:43 <nand`> though I guess ‘X’ and ‘represented as’ are a bit ambiguous here
08:18:01 <rwbarton> it seems more like a condition of what you would want to mean by "represent as a category"
08:18:03 <identity> If I wanted to write an ircbot for a specific purpose on one channel that I frequent, should I be looking into iteratees for IO from the network or would lazy IO be "safe enough"?
08:18:06 <Cale> You would want the homomorphisms on X to be functors in order for that representation to be any good
08:18:12 <nand`> oh
08:18:14 <nand`> no, I'm wrong
08:18:30 <statusfailed> identity: I think there's an IRC library, just fyi
08:18:41 <Lutin`> nand`: If X is the arrows then yes
08:18:50 <statusfailed> Cale: still trying to figure out the examples, heh
08:18:54 <identity> statusfailed: I took a look at a couple -- they could be somewhat limited in a few cases
08:19:02 <statusfailed> but thanks for the explanation so far :D
08:19:09 <Cale> statusfailed: no problem :)
08:19:11 <Lutin`> As a functor is a homomorphism with respect to the mapping of arrows
08:19:25 <nand`> suppose an algebra X with operator · and laws Y that are a superset of the monoid laws; a functor over X represented as a single-object category doesn't have to retain all of the Y laws the way an X homomorphism would
08:19:37 <Cale> statusfailed: So in Haskell, we have a class for endofunctors -- functors from the category of Haskell types and functions to itself.
08:19:41 <Lutin`> True..
08:19:51 <Cale> statusfailed:  class Functor f where fmap :: (a -> b) -> (f a -> f b)
08:19:58 <nand`> it only needs to retain the monoid laws, in particular
08:20:02 <Cale> statusfailed: f here is the mapping on objects (which are types)
08:20:18 <Cale> statusfailed: and fmap provides the mapping on arrows (which are Haskell functions)
08:20:29 <statusfailed> woah, hang on there :D
08:20:38 <Lutin`> statusfailed: You mean Functor is the mapping on objects
08:20:41 <rwbarton> homomorphisms don't retain laws, they retain structure
08:20:50 <Lutin`> Oh wait
08:20:51 <Cale> Lutin`: wait
08:20:53 <Lutin`> Nevermind
08:20:59 <Cale> ah, okay
08:21:20 <Lutin`> I just remembered something about the type constructor being the mapping between objects
08:21:23 <Lutin`> For something
08:21:33 <rwbarton> a homomorphism of monoids that happen to be commutative is the same as a homomorphism of commutative monoids
08:21:37 <nand`> rwbarton: couldn't you consider laws as an interpretation of structure?
08:21:49 <benmachine> identity: personally, I'd use strict IO
08:21:59 <nand`> and a homomorphism preserving structure by consequence preserves laws
08:22:05 <benmachine> identity: by "I'd use" I mean "that's what I did when I did that" :P
08:22:17 <identity> benmachine: I see. So that's iteratee or conduit or whatever?
08:22:25 <benmachine> identity: no, just hGetLine et al
08:22:31 <identity> benmachine: oh
08:22:34 <identity> like that
08:22:40 <identity> I could just do that, aye
08:22:42 <identity> that will probably work
08:22:50 <benmachine> it's way simpler than anything else
08:23:06 <benmachine> it's not as "clean" in that you usually have to mix your IO with all your other stuff
08:23:09 <mm_freak> "strict IO" is kind of confusing
08:23:15 <benmachine> but it's simplest and safest and easiest to understand
08:23:19 <identity> Aye. It looks like it would take me more time understanding conduit/etc than to write the program
08:23:34 <Lutin`> Yo mm_freak
08:24:02 <benmachine> identity: I think what I had was a reading-thread that just constantly read things and then put then in an mvar
08:24:14 <benmachine> and a writing-thread which constantly read from a different mvar and then wrote those things
08:24:22 <identity> benmachine: I was thinking along those exact lines
08:24:33 <benmachine> if I were doing it again these days I might try STM
08:24:34 <rwbarton> nand`: I don't understand. What do you think it means for example for a monoid homomorphism to "preserve the law" forall a b. a*b = b*a
08:24:34 <statusfailed> Cale: ok, so: the Functor type class is an Endofunctor on the category of haskell types?
08:24:44 <benmachine> but possibly only because STM sounds cool than it actually being necessary :P
08:25:11 <identity> I'll stick to what I know so I don't get lost in a bunch of new libraries I'd have to grok and then end up going "f it" heh
08:25:15 <identity> benmachine: Thanks!
08:25:25 <benmachine> np :)
08:26:21 <Cale> statusfailed: It classifies endofunctors... that is, the instances are all examples of endofunctors on the category of Haskell types
08:26:23 <gavilancomun>  /msg NickServ identify
08:26:57 <statusfailed> Cale: oh right, gotcha- because you can have different structures
08:27:00 <benmachine> ...but not all genuine-endofunctors are Haskell-Functors?
08:27:01 <statusfailed> if that makes sense...
08:27:16 * benmachine seems to be hyphen-y today
08:27:18 <nand`> rwbarton: I'm not really sure about that myself
08:27:18 <Cale> benmachine: That's a good question :)
08:27:29 <rwbarton> well it doesn't mean anything :P
08:27:34 <nand`> benmachine: all Hask endofunctors are Haskell functors
08:27:44 <rwbarton> or if it does mean something, it is satisfied automatically
08:28:13 <benmachine> nand`: weeeelll, but you can only define instances of Functor for type constructors, and type constructors are automatically injective
08:28:27 <benmachine> so that doesn't seem like it would cover all cases
08:28:42 <nand`> oh, I see what you mean
08:28:48 <Cale> benmachine: right, at the very least, we're leaving out all the constant functors
08:28:54 <nand`> yeah
08:29:15 <nand`> I retract my claim
08:29:23 <Cale> statusfailed: and yes
08:29:26 <rwbarton> you can do what you want if you add structure rather than laws, though
08:29:54 <tromp_> rather off-topic, but does anyone know a source for high quality scientific prints i could order to decorate the offices?
08:29:55 <Cale> statusfailed: Most of our instances of Functor can be thought of in some abstract way as being container types for which we can apply a function to all the elements of the container.
08:30:13 <statusfailed> Cale: that's kind of how i'm coming at it, but I felt as though it was "wrong" somehow
08:30:21 <nand`> rwbarton: on the other hand I'm not sure what the ‘structure’ of monoids means
08:30:46 <benmachine> tromp_: if you're sufficiently liberal with your concept of scientific, http://www.topatoco.com/merchant.mvc?Screen=PROD&Store_Code=TO&Product_Code=QW-INFOGRAPHIC&Category_Code=QW-PRINTS
08:30:46 <rwbarton> I mean the operations and their arities
08:30:57 <Cale> statusfailed: Or if you don't like that in some cases like IO, they're computations for which we can apply a function to all the results to get another computation.
08:31:06 <benmachine> tromp_: (i.e. no, I don't know of one :P)
08:31:24 <dfordivam> hello all
08:31:50 <Cale> statusfailed: and in between those two views, a function (e -> a) can be thought of as both a container (indexed by elements of type e, and holding elements of type a), and a computation
08:31:55 <nand`> rwbarton: oh, like f(a*b) = f a * f b ?
08:32:09 <rwbarton> nand`: for example I could talk about 'monoids with reversal' which have an added operation r(-) with r(ab) = r(b) r(a) and r(1) = 1
08:32:20 <Cale> statusfailed: and we can apply a function (a -> b) to all the "elements" by composition, giving a function (e -> b)
08:32:22 <rwbarton> and then a monoid homomorphism f may or may not satisfy r(f(x)) = f(r(x))
08:32:25 <rwbarton> nand`, yes
08:32:33 <clsmith> can i sanity-check my understanding of functors? for each a & b there is a F(a) and F(b) for which a morphism (a->b) may be lifted (F(a)->F(b))?
08:33:02 <nand`> now that I think back about it, preserving structure is completely what I originally thought of, not laws - I was confusing myself with misplaced words
08:33:08 <clsmith> and pointed functors also provide the morphism for (a->F(a))? :p
08:33:19 <byorgey> clsmith: yes, and also the lifting preserves the identity morphism and composition
08:33:38 <nand`> (my original intuition was of homomorphisms as Ω-morphisms for some signature Ω)
08:33:40 <clsmith> byorgey: yeah. okay, i think i've finally understood those ones.
08:34:18 <byorgey> clsmith: congrats =)
08:34:38 <clsmith> :D
08:36:28 <Cale> statusfailed: So, coming to terms with all this structure so far?
08:36:36 <statusfailed> Cale: ok I think I get Functor- the way you define fmap defines how the structure is preserved, and its argument is an arrow in the category of types, x. So fmap's definition is basically "how do I turn an arrow into a functor"?
08:36:56 <statusfailed> oh, I didn't use x... :D
08:37:01 <Cale> statusfailed: Well... hang on :)
08:37:06 <statusfailed> dang
08:37:09 <Cale> statusfailed: suppose we have
08:37:14 <Cale> data Maybe a = Nothing | Just a
08:37:18 <Cale> then we get:
08:37:23 <Cale> instance Functor Maybe where
08:37:29 <Cale>   fmap f Nothing = Nothing
08:37:34 <Cale>   fmap f (Just x) = Just (f x)
08:37:51 <Cale> Here, we would say that Maybe is a functor
08:38:11 <Cale> Maybe takes types and gives other types
08:38:21 <Cale> i.e. it's the mapping-on-objects part of the functor
08:38:43 <Cale> and this instance of the Functor class tells us what the mapping on arrows is
08:38:57 <Cale> If I have some function a -> b, I can get a function Maybe a -> Maybe b
08:39:00 <Cale> by applying fmap
08:39:23 <Lutin`> Ah yeah that's what I was thinking of earlier Cale
08:39:30 <Cale> (A functor really consists of both the mapping on objects and the mapping on arrows)
08:39:31 <statusfailed> this was your Fv -> Fu from earlier...?
08:40:07 <Cale> For every arrow a: X -> Y, the functor assigns some Fa: FX -> FY
08:40:17 <Cale> was what I said to correspond to this, I believe :)
08:40:41 <Cale> <Cale> Given two categories C and D, a functor F: C -> D
08:40:42 <statusfailed> and "fmap" is how you assign some Fa: FX -> FY
08:40:44 <Cale> <Cale> assigns to each object X in C, some object FX in D
08:40:47 <Cale> <Cale> and to each arrow a: X -> Y in C
08:40:48 <Lutin`> Wait
08:40:48 <Cale> <Cale> an arrow Fa: FX -> FY in D
08:40:51 <Cale> <Cale> such that:
08:40:52 <Cale> <Cale> F(id_X) = id_(FX) for every object X in C
08:40:55 <Cale> <Cale> and for every three objects in C, X, Y, Z and arrows u: Y -> Z, and v: X -> Y (i.e. every pair of arrows in C which compose), we have F(u . v) = (Fu) . (Fv)
08:41:04 <Cale> statusfailed: yes
08:41:14 <Lutin`> Isn't the point :: a -> f a in Control.Functor.Pointed the same as pure/return?
08:41:21 <nand`> yes
08:41:25 <Lutin`> Bah
08:41:31 <nand`> but there aren't any laws that govern it for Pointed alone
08:41:37 <Cale> So the type constructor itself plays the role of the functor on objects, and the implementation of fmap says what the functor does on arrows
08:41:50 <identity> benmachine: I have another question for you, if you have time. Did you use ByteString or just String? What would be reasons to use one over the other? Unicode, etc?
08:41:54 <nand`> but if your Pointed is also Applicative/whatnot it has to be the same
08:42:08 <benmachine> identity: I probably used String, but only because I didn't know any better
08:42:33 <identity> benmachine: So using string is not a good idea?
08:42:39 <Cale> If we were super-hardcore about keeping to mathematical tradition, we'd write Maybe f instead of fmap f
08:42:50 <Cale> reusing the name of the functor for the mapping on arrows
08:42:56 <nand`> String has an Unicode alphabet, ByteString has a Word8 alphabet - big semantic difference
08:42:58 <benmachine> identity: I'm... not sure. I don't think IRC has any defined encoding, but UTF-8 is most common
08:43:03 <Cale> But that's not really possible in the Haskell syntax
08:43:03 <nand`> if you want ‘efficient but unicode’, see Text
08:43:31 <Cale> statusfailed: clearer?
08:43:48 <benmachine> identity: I'd say stick to String, unless it turns out that unicode decoding errors are causing you problems
08:43:58 <identity> alright, thanks again!
08:44:13 <benmachine> identity: that's not an authoritative answer though, that's just what I reckon :P
08:44:29 <statusfailed> Cale: Yep
08:44:38 <benmachine> identity: in principle String is never really the "right" type, but it's the most convenient and probably fine for your purposes
08:44:43 <identity> yeah, but I was thinking the same, but decided to ask in case someone could come up with big pros/cons
08:44:45 <Lutin`> identity: And for the most part you can switch between the two fairly easily
08:44:52 <identity> Lutin`: Indeed!
08:45:22 <Cale> statusfailed: Now, to really attack the original concern, which was about what monads are and how they're like monoids in any sense, I'll need to introduce even more concepts
08:45:24 <statusfailed> Cale: i already asked this, but I can't remember what the answer was- a haskell Functor f is actually an endofunctor, right?
08:45:25 <nand`> String is the ‘right’ type when manipulating strings as (linked) lists of characters
08:45:28 <statusfailed> Sure :)
08:45:33 <Cale> statusfailed: yes
08:45:39 <statusfailed> ok cool, fire away!
08:45:58 <Cale> Okay, so now if we have two parallel functors F, G: C -> D
08:46:12 <benmachine> nand`: ok sure but human text isn't a list of characters, really - unicode normalisation and weird corner cases tend to screw that up
08:46:13 <nand`> is this ‘from Category to Monads in 2 hours’?
08:46:14 <Cale> we can also define mappings between those! :)
08:46:15 <rwbarton> Until Control/Category.hs gets {-# LANGUAGE KindPolymorphism #-} :)
08:46:19 <Lutin`> Are cofunctors the same as contravariant functors?
08:46:20 <Cale> nand`: lol, yes
08:46:24 <Cale> Lutin`: yeah
08:46:28 <Lutin`> k
08:46:43 <mm_freak> i'd use Text nowadays for text protocols, not String
08:46:48 <benmachine> Cale: I thought the dual of a functor was a functor
08:46:52 <benmachine> so a cofunctor is just a functor
08:46:52 <mm_freak> the encoding/decoding part is explicit, which is a good idea
08:46:59 <mm_freak> also Text is fast
08:47:08 <rwbarton> "cofunctor" is an old-fashioned term
08:47:12 <benmachine> mm_freak: yes, I'd do the same if I cared about performance or pedantry :P
08:47:14 <statusfailed> Cale: parallel meaning they both map from C to D?
08:47:24 <Cale> statusfailed: yes
08:47:33 <mm_freak> benmachine: you should
08:47:38 <statusfailed> okay, and we can define mappings between the functors?
08:47:43 <rwbarton> and old-fashioned terminology is not always very sensible
08:47:44 <statusfailed> oh, these are the 'adjoint functors'?
08:47:48 <mm_freak> String is a bad idea for anything networking
08:47:53 <Lutin`> benmachine: contravariant functor is a funtor on the dual category
08:48:00 <nand`> benmachine: human text would faithfully be some fiendishly complex sequence of words (perhaps with intermingled data like smileys, ascii diagrams and so forth)
08:48:01 <ciaranm> statusfailed: adjoint is something else
08:48:02 <Cale> A natural transformation η: F -> G consists of, for each X in C, an arrow η_X: FX -> GX in D, such that...
08:48:05 <mm_freak> String is slow and unpredictable
08:48:12 <benmachine> mm_freak: arguably I should care about pedantry, but I should also care about making my life easier
08:48:16 <benmachine> mm_freak: unpredictable?
08:48:20 <statusfailed> ciaranm: damn, just looked it up ... :D
08:48:28 <identity> mm_freak: How would that work with the Network.Socket functions?
08:48:28 <mm_freak> benmachine: do you know what getChar does?
08:48:35 <identity> Would I have to be doing explicit conversions everywhere?
08:48:37 <benmachine> mm_freak: and for many applications, including an IRC bot, slow isn't a problem at all
08:48:43 <ciaranm> statusfailed: for adjoints you have functors A -> B and B -> A that have certain nice properties
08:48:47 <Cale> For any arrow a: X -> Y in C, we have that η_Y . Fa = Ga . η_X
08:48:52 <mm_freak> identity: normally you would use a stream processing abstraction like conduit/enumerator
08:48:57 <Cale> and this is where IRC starts to really fail us
08:49:05 <benmachine> identity: probably you'd read bytestrings off the socket but immediately convert them
08:49:07 <Cale> because I can't draw the diagram to make this pretty
08:49:13 <Cale> So let me get you a link
08:49:14 <mm_freak> identity: it feeds you ByteString and you connect it to a conduit/enumeratee that gives you a Text
08:49:14 <benmachine> identity: with Network.Socket.ByteString
08:49:18 <nand`> note that many of the operations you can do with Strings can be done easily with something like Text; except perhaps something like monadic replacements
08:49:26 <identity> mm_freak, benmachine: I see.
08:49:30 <benmachine> mm_freak: we already dismissed those things for being overkill :P
08:49:38 <nand`> but traversing, mapping, splitting etc. other common things you would do with String are available for Text as well
08:49:45 <mm_freak> they are not overkill…  they make your life easier
08:49:46 <identity> There's also Data.Text.pack/unpack, I see
08:49:55 <mm_freak> i don't see how String makes /anything/ easier
08:49:59 <Cale> http://ncatlab.org/nlab/show/natural+transformation
08:50:16 <benmachine> mm_freak: mostly familiarity is what makes String easy
08:50:21 <nand`> mm_freak: pattern matches, arguably
08:50:25 <benmachine> and those
08:50:32 <mm_freak> OverloadedStrings gives you pattern matches
08:50:45 <benmachine> it doesn't give you uncons pattern matches
08:50:53 <benmachine> bwim x:xs
08:50:55 <nand`> eg. something like '!':y:z:_
08:51:08 <Z`> Why is Control.Monad.State empty in the hackage site ?
08:51:15 <nand`> though note that pattern matches like those are probably not the best/right solution to a problem
08:51:16 <mm_freak> ViewPatterns gives you that
08:51:28 <Z`> Ah there's a link to .Lazy
08:51:30 <identity> I probably don't need those kind of pattern matches
08:51:30 <Lutin`> Cale: I'm trying to follow along too, but my class just finished and I have to go between buildings. Could you kind of go through the progression from functor to monad?
08:51:38 <Lutin`> And I can look it up on that site
08:51:38 <Cale> statusfailed: they named things a little differently there, but you can see the squares -- when we say a diagram of a bunch of objects and arrows commutes, it means that every path through the diagram which starts and ends at the same objects, if we compose the arrows in it together, we get the same result
08:51:55 <benmachine> mm_freak: ViewPatterns has some noise associated with it
08:51:59 <identity> What I do need is reliable decoding to utf8
08:52:02 <identity> and it seems text can do that
08:52:11 <nand`> so can string
08:52:11 <identity> and attoparsec does Text it seems
08:52:12 <benmachine> identity: what do you mean by reliable?
08:52:16 <Cale> Lutin`: Well, we need natural transformations, and then a monad is just an endofunctor together with some natural transformations satisfying some laws.
08:52:21 <mm_freak> in any case, on the bottom line Text will have been more convenient and also more reliable
08:52:25 <Lutin`> Alright
08:52:25 <Cale> Lutin`: But if we want to see the relationship with monoids
08:52:27 <identity> benmachine: I just remember, when I did something like this before, that I would get garbled output
08:52:33 <mm_freak> the problem with String is that it's unprecticable for networking
08:52:38 <identity> I'm not sure if it was because of locale differences from users or something
08:52:39 <identity> but yeah
08:52:41 <Cale> Lutin`: we need to know what a monoidal category is (one with a monoid-like operation on objects)
08:52:44 <nand`> mm_freak: Text can't represent infinite strings, can it?
08:52:56 <mm_freak> nand`: lazy Text can, but you wouldn't want to
08:52:56 <Cale> and inside of monoidal categories, we can define monoid objects
08:53:06 <Lutin`> Cale: ANd bicategories?
08:53:06 <Cale> and the monoid objects in Set will be ordinary monoids
08:53:08 <benmachine> identity: imo if you get garbled output it's because you're doing the wrong thing to it, and no choice of data type will save you from that :P
08:53:19 <identity> benmachine: I don't remember it in detail
08:53:24 <identity> I caused a lot of grief, at any rate
08:53:32 <Cale> while the monoid objects in a category of endofunctors (and natural transformations) will be monads
08:53:33 <identity> (I wasn't doing anything to it, as such, IIRC)
08:53:35 <identity> But never mind that
08:53:41 <Lutin`> I think I can figure it out from that site, and I'll come back and pick your brain later :P
08:53:44 <mm_freak> String can give you garbage without doing anything wrong, but simply by not understanding its semantics
08:53:55 <mm_freak> i repeat:  don't use String for networking
08:54:12 <benmachine> mm_freak: you didn't elaborate on what the problem with getChar was
08:54:20 <identity> What I'm basically doing is loop { line <- readLine; msg <- parseMessage line; passToConsumers msg; }
08:54:21 <mm_freak> benmachine: what does it do?
08:54:32 <statusfailed> Cale: Hm, i'm not sure what is meant by F(x) -> G(x)
08:54:37 <benmachine> mm_freak: it reads enough data to decode a character, and then gives you that character
08:54:52 <nand`> identity: Text provides getLine :: IO Text
08:54:52 <mm_freak> benmachine: what does it do exactly?  how do you know what it does?
08:54:55 <Cale> statusfailed: okay, so F and G are functors C -> D, and X is an object of C
08:55:02 <Cale> or x is an object of C, rather
08:55:07 <statusfailed> oh wait, is it just the F-functor-mapped x can be mapped to the G-functor-mapped x?
08:55:15 <benmachine> mm_freak: what are you getting at?
08:55:15 <Cale> statusfailed: and so F(x) is an object of D
08:55:22 <Cale> and so is G(x)
08:55:23 <benmachine> mm_freak: what is unsatisfactory about my description?
08:55:32 <mm_freak> benmachine: getChar (or hGetChar) reading exactly one latin-1 byte is also a valid implementation
08:55:37 <statusfailed> ok, so F(x) -> G(x) we call α_x
08:55:39 <identity> nand`: It's from the network.
08:55:47 <statusfailed> does it necessarily exist?
08:55:52 <benmachine> mm_freak: ...depends on your criterion for "valid"
08:56:01 <identity> Anyway, thanks for all the advice. I'll try my hand at Text. Nothing wrong with learning something new, anyway, and it doesn't look like it's too bad :)
08:56:03 <nand`> identity: then it sounds like all of your operations can be readily s/String/Text/g'd
08:56:06 <Cale> statusfailed: right, we're picking for each object x, such an arrow. It might not exist, which would foil our attempt to create a natural transformation.
08:56:18 <mm_freak> benmachine: one that you might get in other GHC versions or other compilers (and that actually happens)
08:56:18 <statusfailed> ah ok
08:56:19 <benmachine> identity: yeah, in fairness the text api is actually pretty nice
08:56:43 <benmachine> mm_freak: aiui the interpretation I gave has been current for at least three major GHC versions
08:56:55 <benmachine> mm_freak: arguably before then it was outright wrong
08:56:59 <benmachine> hence why it was changed
08:57:11 <mm_freak> also network-conduit/network-enumerator give you ready-made stream producers, and there is attoparsec-conduit/attoparsec-enumerator for parsing easily…  there is really no good argument for String in networking
08:57:13 <Cale> statusfailed: A wide class of natural transformations are provided in Haskell by polymorphic functions.
08:57:28 <mm_freak> benmachine: it wasn't wrong…  it was just bad
08:57:38 <benmachine> mm_freak: that seems like an odd distinction
08:57:53 <mm_freak> let me state it this way
08:57:58 <mm_freak> you're making dangerous assumptions
08:58:02 <Cale> statusfailed: If we have Haskell (endo)functors F and G, a natural transformation will, for each type t, give us a function F t -> G t
08:58:17 <Cale> statusfailed: and of course, that's what polymorphic functions of type  forall t. F t -> G t  will do
08:58:33 <parcs`> oh jeez, base16-bytestring only accepts lower-case literals :(
08:58:39 <mm_freak> most of the time (terminal input/output, etc.) those assumptions are fine, but for networking they can bite you really hurtfully
08:58:52 <benmachine> mm_freak: why is there a difference when networking is involved?
08:59:23 <mm_freak> benmachine: because you must not make assumptions for networking…  do you really want your protocol implementation's semantics to depend on your LANG variable?
08:59:49 <mm_freak> that's just one example
08:59:51 <Z`> If I'd like to implement my self the State Monad, how should I start?    instance State mySM where ... ?
09:00:02 <mm_freak> Z`: first implement the State type
09:00:08 <mm_freak> newtype State s a = …?
09:00:10 <maukd> Z`: data MyState s a = ....
09:00:10 <statusfailed> Cale: is "maybeToList" a natural transformation?
09:00:13 <benmachine> mm_freak: well, but implementing the IRC protocol is sketchy anyway
09:00:16 <Z`> thanks
09:00:19 <Cale> statusfailed: yes!
09:00:23 <statusfailed> yaaay :D
09:00:30 <Cale> And moreover, if our polymorphic function is say, u :: forall t. F t -> G t, then we want for every pair of types A and B, and function f :: A -> B, for it to be the case that fmap f . u = u . fmap f
09:00:42 <benmachine> mm_freak: the encoding of the text is, I believe, not terribly well-defined
09:00:45 <Cale> That's what that square diagram looks like in Haskell
09:00:46 <jfischoff> statusfailed: cool
09:00:49 <mm_freak> benmachine: it's particularly bad for IRC, because IRC assumes octets with no encoding at all…  the proper choice for IRC is ByteString, not even Text
09:00:57 <Cale> (note that all the subscripts vanish because of typeclass magic)
09:01:18 <benmachine> mm_freak: IMO the proper choice for IRC is to impose additional assumptions based on common practice
09:01:20 <Cale> but it turns out that polymorphism *forces* this to be true
09:01:29 <mm_freak> Z`: side note, don't import Control.Monad.State
09:01:55 <mm_freak> benmachine: not for the raw protocol handling…  you will have to do that when you /interpret/ messages (like a bot or a GUI)
09:02:01 <statusfailed> Cale: hang on, which subscripts?
09:02:17 <maukd> mm_freak: but the raw protocol is awful to handle with bytes
09:02:39 <mm_freak> maukd: why?
09:02:46 <Cale> statusfailed: the ones on alpha in the diagram on that page
09:02:57 <maukd> because it's all ascii and bytes are just numbers
09:03:08 <statusfailed> oh, right!
09:03:11 <statusfailed> I get you
09:03:34 <Cale> statusfailed: in Haskell, we can write alpha_y . F(f) = G(f) . alpha_x   as   alpha . fmap f = fmap f . alpha
09:03:39 <statusfailed> forall means we don't have to define a huge number of α_x
09:03:43 * hackagebot grid 1.1 - Tools for working with regular grids\/graphs\/lattices.  http://hackage.haskell.org/package/grid-1.1 (AmyDeBuitleir)
09:04:23 <mm_freak> maukd: you have the various *.Char modules for that
09:04:28 <benmachine> mm_freak: in the context of IRC, it doesn't matter if your protocol stuff depends on your LANG variable
09:04:34 <benmachine> at least, not really
09:04:39 <nand`> yeah, the forall. is the Haskell way of representing what's categorically a family of arrows, one for each type
09:04:47 <Z`> Would MyState be a tuple of a state and a return value ?
09:05:12 <nand`> surely a Parser generalized to ByteStrings can readily work with stuff like string "PRIVMSG"
09:05:16 <Cale> statusfailed: Of course, it also means we don't get to say what it does on separate types separately
09:05:18 <nand`> with XOverloadedStrings
09:05:26 <Cale> statusfailed: like we could in the real category-theoretic definition
09:05:43 <Cale> statusfailed: but on the up-side, we also don't have to check that the law holds, it holds for free.
09:05:49 <mm_freak> benmachine: really?  an hGetLine-based IRC implementation can fail terribly under windows
09:06:05 <Cale> brb, making a cappuccino
09:06:14 <benmachine> mm_freak: that's only a problem if you plan to use windows :P
09:06:37 <statusfailed> Cale: ooh, coffeebreak :D
09:06:42 <nand`> ‘this implementation is bad, but I choose to use it because it works for me’
09:06:45 <benmachine> mm_freak: even then, I'd be skeptical at "fail horribly"; surely it's not that big of a deal to write code that adjusts?
09:07:25 <mm_freak> benmachine: it is, because you can't
09:07:44 <benmachine> mm_freak: oh, well, I've never tried because I didn't need to
09:08:02 <mm_freak> anyway, my main message is:  don't use String for networking
09:08:08 <nand`> mm_freak: surely you can make String-ified versions of all the Text-based networking functions, though
09:08:16 <benmachine> mm_freak: anyway, I'm not disputing that text is in general better, just that it's possible to write code that does the job with String
09:08:21 <mm_freak> nand`: what would be the point of that?
09:08:45 <nand`> mm_freak: none - but it shows that the problem you are describing is not inherent to the string type
09:08:55 <benmachine> and in the context of an IRC bot I assume (perhaps naively) that it's not going to be a big deal
09:08:56 <mm_freak> benmachine: of course it's possible, but you're giving up predictability, because from system to system you can't know how you have to configure the Handle
09:09:15 <mm_freak> nand`: it's inherent to System.IO
09:09:33 <benmachine> mm_freak: out of interest, does openBinaryFile even make sense as a concept?
09:09:37 <benmachine> (in your view)
09:10:23 <mm_freak> well, what System.IO calles "binary mode" is in fact "latin-1 mode"
09:10:34 <benmachine> hmm
09:10:42 <benmachine> "but also with no fiddling of line endings"
09:10:43 <nand`> mm_freak: ah, so I don't misunderstand, your argument is ‘don't use strings for networking (because the string APIs are bad)’, as opposed to ‘don't use strings for networking (because the string type is bad)’ ?
09:11:02 <mm_freak> benmachine: what does hGetLine do for a handle in binary mode?
09:11:16 <mm_freak> nand`: yeah
09:11:21 <benmachine> mm_freak: honestly I don't even know. I'd assume you're not supposed to use it
09:11:41 <mm_freak> although String itself may also be bad…  in the best case it's just slow, in the worst it opens you up to various DoS attacks
09:11:45 <nand`> I'd expect it to read to the end of the file
09:12:18 <mm_freak> benmachine: so you end up writing sinks/iteratees/pipes and parsers anyway
09:12:27 <mm_freak> which even more invalidates String as a valid candidate
09:12:37 <benmachine> mm_freak: now I'm confused
09:12:59 <mm_freak> benmachine: IRC is line-based…  you're not allowed to use hGetLine…  what do you do?
09:13:14 <benmachine> mm_freak: I don't use the handle in binary mode, so I am allowed to use it
09:13:44 <mm_freak> well, i hope to have established that that's a bad idea for serious applications
09:13:53 <benmachine> oh, that I'd agree with
09:13:59 <benmachine> I just assumed the application in question wasn't very serious
09:14:26 <mm_freak> again a dangerous assumption when you're trying to help other people =)
09:14:44 <benmachine> I'm a dangerous man
09:14:49 * benmachine skateboards down a mountainside
09:15:30 <benmachine> I get what you're saying but I think that overwhelming people who ask for help can be just as dangerous
09:15:53 <mm_freak> even for non-serious applications running on your own machine you're now trusting freenode (or the server in question) not to blow your machine up
09:16:00 <benmachine> "you want to connect to an IRC server? right, you'll need bytestring, text, network, network-conduit, attoparsec-conduit..."
09:16:28 <benmachine> "you'll need to understand at least three distinct packages/concepts before you receive your first byte"
09:16:46 <benmachine> mm_freak: blow it up? really?
09:16:58 <benmachine> surely the worst-case scenario is your application crashes
09:17:08 <mm_freak> at least you should tell them:  for serious applications you have to learn a few further things…  you know why there are so many security holes in networking applications…  because people get them wrong
09:17:18 <mm_freak> the worst case is your system crashes
09:17:26 <benmachine> how can freenode crash my system?
09:17:49 <benmachine> oh, hmm, I think I can see how
09:17:50 <benmachine> I mean
09:17:55 <nand`> I'm not sure that's an upper bound on the worst thing that can happen
09:17:56 <mm_freak> by violating the IRC specifications and sending you a very long string for a few minutes or hours depending on your internet speed
09:18:01 <benmachine> nand`: raptor attack
09:18:11 <nand`> for all you know, the haskell implementation or operating systems have open vulnerabilities
09:18:36 <benmachine> mm_freak: point taken about sending you a long string, although I trust freenode not to do that and don't think that's unreasonable of me
09:18:48 <Ferdirand> for all you know your ip stack has a remotely exploitable vulnerability
09:19:01 <benmachine> mm_freak: if the haskell implementation or operating system have open vulnerabilities, I'm screwed anyway
09:19:12 <mm_freak> yes, but that's not the point
09:19:21 <mm_freak> that's a vulnerability in your application, not in other layers
09:19:41 <mm_freak> of course that's again not String's fault, but hGetLine's
09:19:51 <maukd> ulimit
09:19:51 <benmachine> mm_freak: if the implementation or OS has vulnerabilities, it's not my application's fault
09:19:52 <nand`> my point half-being that using String can, due to eg. filling the memory, trigger other exploits that Text perhaps would not
09:20:10 <benmachine> oh wait
09:20:18 <benmachine> I think I read one of the things nand` said as coming from mm_freak
09:20:24 <mm_freak> =)
09:20:37 <Z`> I wrote:   data MyState s a = MyState s a deriving Show  .  what would be the next step towards reimplementing the state monad ?
09:20:38 <benmachine> nand`: yeah but it's easy to write Text code that'll do the same thing, imo
09:20:39 <mm_freak> hGetLine happily reads forever unless you use +RTS -M
09:20:47 <benmachine> Z`: that's not the right type
09:21:12 <mm_freak> Z`: that's wrong
09:21:19 <Z`> why ?
09:21:26 <nand`> because it's not the state monad
09:21:33 <mm_freak> newtype State s a = State (s -> (a, s))
09:21:55 <mm_freak> a value of type State S A is a function from an S to an A and another S
09:22:01 <Z`> ok
09:22:01 <mm_freak> nothing more, nothing less
09:22:38 <mm_freak> Z`: now before trying to write Monad, first write 'put' and 'get'
09:22:49 <mm_freak> put :: s -> State s ()
09:22:52 <mm_freak> get :: State s s
09:23:20 <Z`> so: data MyState s a = MyState (s -> (a,s)) ?
09:23:30 <mm_freak> that's fine, although newtype would be better
09:23:42 <Z`> ok, I'll use newtype,thanks
09:24:00 <mm_freak> good, now again, don't try to implement Monad now…  first implement get and put
09:24:04 <Z`> I'll try to write put + get, and be back later . thanks
09:24:17 <mm_freak> have fun =)
09:26:01 <statusfailed> I still think the state monad is inaccurately named :\
09:26:13 <mm_freak> statusfailed: what would you name it?
09:26:17 <statusfailed> state transition monad?
09:26:25 <mm_freak> StateTransition?
09:26:30 <statusfailed> bit wordy I guess
09:26:35 <mm_freak> yeah
09:26:50 <mm_freak> Transition could be a good name
09:27:04 <statusfailed> or "stateful" maybe?
09:27:35 <statusfailed> it's not that bad, it just confused the hell out of me for a while :D
09:27:44 <nand`> I think State is well named
09:28:03 <mm_freak> how about Mapping, then write type WhileProducing a b = a b
09:28:08 <Z`> Shouldn't first write: instance Monad MyStateMonad where ... and write the put and get functions as part of that ?
09:28:14 <mm_freak> put :: s -> Mapping s `WhileProducing` ()
09:28:21 <mm_freak> Z`: no
09:28:35 <Z`> then where would I be saving the state ? or from where would I be returning it ?
09:28:39 <Cale> statusfailed: okay, so Monad :)
09:28:44 <statusfailed> woo :D
09:28:50 <mm_freak> Z`: the Monad class does not include get and put anyway, but you really shouldn't start with the Monad instance…  it will give you headaches, before you understand how State actually works
09:28:57 <mm_freak> Z`: understanding get and put will help you understand how it works
09:29:09 <mm_freak> then you can move on to Monad (or perhaps first Functor)
09:29:29 <mm_freak> Z`: that's your misunderstanding…  State does not /save/ anything anywhere
09:29:44 <mm_freak> it's a state transition function
09:29:55 <mm_freak> a value of type State S A really represents a function of type S -> (A, S)
09:30:13 <Cale> statusfailed: If C is any category, then a monad on C consists of (T,eta,mu) where T is a functor C -> C, and eta and mu are natural transformations, with eta: 1 -> T, where 1 is the identity functor (sending each object and arrow to itself), and  mu: T^2 -> T
09:30:20 <Z`> how do I extract S from a function S -> (A, S) ?
09:30:32 <mm_freak> Z`: you first give it an S
09:30:34 <maukd> Z`: you don't
09:30:37 <nand`> it's not a comonad
09:30:39 <Cale> So, for each X in C, we have  eta_X: X -> TX, and mu_X: T(TX) -> TX
09:30:41 <mm_freak> then it gives you another S back
09:31:04 <Cale> and then these are required to satisfy a few laws
09:31:34 <Z`> well, it should be something like:  get = MyState (\s -> (s, s)) ?
09:31:44 <mm_freak> Z`: correct =)
09:31:49 <mm_freak> now implement 'put'
09:32:02 <Z`> yupi!
09:33:46 <Cale> Just to increase the level of familiarity a notch
09:33:51 <Cale> eta = return
09:33:54 <Cale> and mu = join
09:34:09 <Cale> (in case that wasn't clear from the types)
09:34:22 <statusfailed> Cale: sorry, had to go away for a sec there... reading now :)
09:34:39 <Cale> So, let's think about the laws that we want, once you're finished reading :)
09:35:18 <Cale> We can almost guess them just from the structure of the setup, which is something that tends to happen more and more as you get into category theory.
09:35:28 <Z`> put news = MyState (\s -> (..., news s)) ?
09:35:40 <Z`> ... could be the void () ?
09:35:45 <mm_freak> Z`: no
09:35:54 <mm_freak> Z`: 'put' ignores the current state and returns a new one
09:36:06 <Z`> ah
09:36:12 <Z`> let me read the signature again
09:36:26 <Z`> put :: s -> State s ()
09:37:07 <mm_freak> what's the only valid value for the first tuple component?
09:37:22 <mm_freak> State s () = State (s -> ((), s))
09:38:13 <Z`> put new old = ( (), new )
09:38:22 <mm_freak> 'put' takes only one argument
09:38:39 <mm_freak> and it produces a state transition function of type State s ()
09:38:40 <Z`> ah right, put new = ( (), new ) then ?
09:38:44 <Z`> oh, wrong
09:38:46 <mm_freak> that's a type error
09:38:53 <mm_freak> put new = State (…)
09:39:20 <mm_freak> the function inside the parentheses takes the current state, ignores it and returns a new one
09:39:32 <mm_freak> think of it as a state transition function that produces a value of type () along the way
09:39:42 <Z`> ah right, put new = MyState (\current () -> ( (), new) ) then ?
09:39:50 <Z`> sorry
09:39:54 <Z`> ah right, put new = MyState (\current -> ( (), new) ) then ?
09:40:00 <mm_freak> yeah, that's right
09:40:16 <mm_freak> do you understand that function?
09:41:13 <Z`> yeh, kind o
09:41:13 <Z`> f
09:41:22 <mm_freak> ok, now implement 'modify'
09:41:27 <mm_freak> you're not yet ready for Monad =)
09:41:33 <mm_freak> modify :: (s -> s) -> State s ()
09:42:03 <Z`> looks scary
09:42:26 <mm_freak> 'modify' takes a function and produces a state transition function that maps the given function over the state value
09:42:26 <Z`> could I cheat and use get + put ?
09:42:35 <maukd> Z`: I'd say yes
09:42:37 <statusfailed> Cale: ok, i'm with you
09:42:38 <mm_freak> right now you can't, because you don't have Monad =)
09:42:39 <nand`> you could, yes, but that's not the point
09:42:44 <maukd> oh, right
09:42:50 <nand`> also what mm_freak said
09:43:07 <mm_freak> you need Monad to cheat like that
09:43:12 <Cale> statusfailed: Okay, so suppose we start out at TX, we can get to TTX in two different ways using eta
09:43:13 <nand`> well, you can always do it manually
09:43:15 <Z`> ok, let me think about it for 10 minutes and bbiab :P
09:43:24 <nand`> but implementing it directly ought to be much easier
09:43:31 <mm_freak> Z`: start like this:  modify f = MyState (\s -> …)
09:43:32 <Cale> statusfailed: We can just straightforwardly apply eta_(TX): TX -> T(TX)
09:43:49 <mm_freak> Z`: it should take the current state 's' and the updated state should be 'f s'
09:43:54 <Z`> mm_freak: and here 's' would be the (s -> s) ?
09:43:57 <Cale> statusfailed: or we can apply T(eta_X): TX -> T(TX)
09:44:04 <Z`> ah no, that is f
09:44:05 <mm_freak> Z`: no, f :: s -> s, s :: s
09:44:12 <Z`> kk
09:44:16 <Cale> statusfailed: In Haskell, these are return and fmap return respectively.
09:44:43 <mm_freak> Z`: by now you should have noticed how State is actually entirely pure =)
09:44:56 <mm_freak> it emulates a hidden mutable variable simply by encoding a state transition function
09:44:57 <Cale> statusfailed: and then from T(TX), we can get back to TX by applying mu_X
09:45:19 * nand` thinks one should be fluent in passing around state manually before learning/writing/etc. State
09:45:33 <Cale> statusfailed: And so we want both of these things to be equal, and in fact, the same as just taking the identity TX -> TX
09:45:38 <mm_freak> nand`: that's why he's writing get/put/modify before even thinking about implementing Monad
09:46:00 <mm_freak> i want him to understand what State is first before attempting to make it a monad
09:46:13 <Cale> statusfailed: and so those are the left and right unit laws, depending on which way we decide to use eta in the beginning
09:46:20 <nand`> mm_freak: I wasn't talking about Z` in particular, I just meant to say that knowing that/how/why State is pure shouldn't come as a surprise at that point
09:46:48 <mm_freak> yeah…  but often people have to actually go through implementing State to get that
09:46:53 <mm_freak> it was that way for me
09:47:07 <Cale> statusfailed: You can think of eta_(TX) as sticking an extra T on the left, and T(eta_X) as sort of sneaking a T in on the right instead, and then mu collapses the two T's back into one again
09:47:41 <Cale> statusfailed: To see it concretely, in the case of the list monad, we have return v = [v]
09:47:52 <Z`> probably wrong, 1st attempt:  modify f = MyState (\s -> ( f s, () ) )
09:47:54 <statusfailed> Cale: ok, that makes sense- T(eta_X) 'injects a T around each object', whereas eta_(TX) wraps everything in a T....
09:47:54 <nand`> maybe it was different for me because of LYAH, which iirc introduced State as just an abstraction of state-passing techniques it explores much earlier on
09:47:59 <Cale> yes
09:48:00 <mm_freak> Z`: almost right
09:48:05 <statusfailed> to use horribly vague language :D
09:48:28 <mm_freak> Z`: the way it is it's currently a type error
09:48:41 <Cale> So, say, in the list monad, if X = Integer, and T = [] we have  return [1,2,3] = [[1,2,3]], while  fmap return [1,2,3] = [[1],[2],[3]]
09:48:57 <Cale> and then join = concat
09:49:02 <Z`> f :: s -> s so f s :: s
09:49:13 <mm_freak> Z`: that's correct
09:49:16 <mm_freak> but not the point =)
09:49:24 <Z`> and s, () is also a valid type MyState
09:49:25 <Z`> hm
09:49:26 <Cale> and we want to be able to concat on both of those lists to be able to get back what we started with
09:49:28 <mm_freak> the state transition function returns an ((), s), not an (s, ())
09:49:34 <Z`> ooops
09:49:45 <maukd> a "typo"
09:49:57 <Cale> good so far?
09:50:02 <statusfailed> Cale: yep
09:50:02 <Z`> probably right, 2nd attept:  modify f = MyState (\s -> ( (), f s ) )
09:50:07 <Cale> So that sort of says that eta and mu have to interact nicely
09:50:10 <mm_freak> Z`: well done =)
09:50:14 <Z`> thanks! :D
09:50:15 <maukd> Z`: looks good to me
09:50:17 <Cale> We also want mu to interact nicely with itself, in the following way
09:50:24 <mm_freak> Z`: now implement stateId :: a -> State s a
09:50:37 <maukd> can I call it pure instead?
09:50:48 <Cale> If we start at TTTX, we can get to TTX by applying mu_(TX), collapsing the outer two T's
09:50:54 <mm_freak> call it whatever you want…  i call it according to State's kleisli category
09:51:02 <saml> is TTTX the best monad
09:51:07 <Z`> stateId a = MyState (\s -> (a,s )) ?
09:51:10 <Cale> or we can get to TTX by applying T(mu_X), collapsing the inner two T's
09:51:12 <mm_freak> Z`: correct
09:51:14 <Cale> saml: T is the monad here
09:51:20 <maukd> what's next? fmap?
09:51:40 <mm_freak> Z`: now stateMap :: (a -> b) -> State s a -> State s b
09:51:40 <statusfailed> Cale: with you so far
09:51:40 <nand`> what about get :: State s s
09:51:45 <Cale> statusfailed: and then in either case, we can get to TX from there by applying mu_X
09:51:50 <mm_freak> nand`: he has that already
09:51:53 <nand`> oh ok
09:51:57 <Cale> statusfailed: and we want these two ways to get from TTTX to TX to be the same
09:52:02 <mm_freak> Z`: that one is a bit more involved
09:52:07 <Z`> hey stateMap reminds of fmap where :: (a -> b) -> f a -> f b
09:52:13 <mm_freak> Z`: exactly =)
09:52:20 <Z`> I should use a functor for stateMap ?
09:52:20 <statusfailed> Cale: This sounds a lot like a puzzle I did once...
09:52:33 <Cale> So if we start with a list of lists of lists, and we join . join, that should be the same as join . fmap join
09:52:37 <mm_freak> Z`: when you have a working stateMap, you can implement Functor like this:  fmap = stateMap
09:52:40 <mizu_no_oto> As an aside:  Why have "Data State s a = State (s -> (a,s))" instead of "type State s a = s -> (a,s)"?  Is it just to allow encapsulation (by not exporting the State constructor), or is there another reason?
09:52:50 <nand`> Z`: that functor has to come from somewhere; meaning you have to write fmap yourself - stateMap is that implementation
09:53:02 <mm_freak> mizu_no_oto: to later allow the Functor and Monad instances to be written
09:53:04 <Z`> ah ok
09:53:22 <mm_freak> Z`: start like this:  stateMap f (State g) = State (…)
09:53:24 <mizu_no_oto> >_<
09:53:46 <mm_freak> s/State/MyState/
09:53:49 <statusfailed> Cale: yeah I think I can see that
09:53:53 <Cale> statusfailed: Very abstractly, this last law is similar to associativity
09:54:33 <Cale> and the first two laws are similar to the left and right unit laws of a monoid
09:54:36 <srhb> mizu_no_oto: Hehe. I felt like that too when I totally followed your question and then went "instance... uh"
09:54:44 <Cale> and it's actually possible to formalise the connection
09:55:08 <statusfailed> Cale: which are the left/right unit laws?
09:55:17 <statusfailed> oh, the identity ?
09:55:18 <maukd> hey, there is a Monad instance for (->). it just doesn't match State
09:55:45 <nand`> statusfailed: the join . return = id = join . fmap return  bits
09:55:46 <Cale> That  mu_X . eta_(TX) = id and mu_X . T(eta_X) = id
09:56:23 <statusfailed> oh, these are monad laws, or monoid laws?
09:56:27 <Cale> which in Haskell are written join . return = id and join . fmap return = id
09:56:30 <Cale> they're monad laws
09:56:42 <statusfailed> oh ok
09:56:45 <Cale> oh
09:56:51 <Cale> If you want to know for a monoid
09:57:02 <nolrai> is "let new = f old in modify (first $ const new)" better some how then "modify (first f)" ?
09:57:19 <Cale> Let's write the definition of a monoid in a particularly suggestive way
09:57:42 <Z`> I'm not sure I will be able to write stateMap
09:57:46 <Cale> A monoid is a set M together with operations eta: 1 -> M (where 1 is a one-element set), and mu: M x M -> M
09:57:52 <maukd> nolrai: what is old?
09:57:55 <nand`> nolrai: the former doesn't make an awful lot of sense, where does ‘old’ come from?
09:58:16 <mm_freak> Z`: stateMap f (State g) = State (\s0 -> let (x, s1) = g s0 in …)
09:58:22 <nand`> unless you mean get >>= old -> let ...  in which case I'd say the latter is much superior
09:58:25 <nolrai> earlier theres a "old <- getTheOneIWant"
09:58:27 <nand`> \old -> *
09:58:38 <Cale> say 1 = {*}, just so we have a name for the one element of our set :)
09:58:57 <mm_freak> Z`: 'g' is a state transition function, and you want to give it the current state and apply 'f' to its result while not touching the resulting state
09:59:09 * nand` would probably go with _1 %= f these days
09:59:19 <Cale> So we want mu(eta(*),a) = a
09:59:45 <nolrai> nand`: is that too me?
09:59:58 <nolrai> * to
10:00:02 <nand`> yeah, for modify (first f)
10:00:07 <Cale> and we want mu(a,eta(*)) = a
10:00:24 <Cale> and mu(mu(a,b),c) = mu(a,mu(b,c))
10:01:36 <Cale> and if we try to make these definitions points-free, we'll end up with something very reminiscent of the laws we have in the monad case
10:02:09 <nolrai> \source (%=)
10:02:11 <notdan> Hm, I was trying to make a timer the other night, and I've seem to have enounted a problem. Everything works fine wshen I am in ghci, but once I complie a stand alone app various weird things happen. The way I do timer is forkIO + threadDelay. And it seems that the scheduler actually runs my thread with a delay, sometimes a really long one
10:02:24 <nolrai> @source (%=)
10:02:24 <lambdabot> (%=) not available
10:02:40 <nolrai> \hoogle (%=)
10:02:47 <nolrai> @hoogle (%=)
10:02:47 <lambdabot> No results found
10:02:50 <saml> notdan, code?
10:02:52 <mm_freak> notdan: depending on what your other threads are doing you may need to compile with -threaded
10:03:05 <mm_freak> notdan: otherwise context switches occur only in certain spots
10:03:23 <notdan> well, besides the main thread I have GUI (gtk2hs) thread
10:03:37 <mm_freak> notdan: yes, you need -threaded then
10:03:44 <Cale> So if we start out at M, this is isomorphic to 1xM, and we can apply eta on the left to get to MxM, and then mu to get back to M
10:03:55 <Cale> and the first law says that should be the identity
10:03:58 <mm_freak> notdan: my recommendation is to always compile with -threaded
10:04:04 <hpaste> Dan pasted “timer” at http://hpaste.org/74293
10:04:13 <notdan> saml: ^
10:04:16 <notdan> mm_freak: ok, thanks
10:04:27 <nand`> mm_freak: ‘always’ meaning?
10:04:31 <Cale> Or, we can use the fact that M is isomorphic to Mx1, and apply eta on the right to get to MxM, and then mu to get back to M, and that should be the identity map as well
10:04:34 <mm_freak> nand`: always
10:04:42 <mm_freak> that word has a fairly simple definition =)
10:05:03 <nand`> heh, but the context varies - always for his code, always when using forkIO, always in general?
10:05:12 <Cale> and if we start out at MxMxM, we can apply mu to the left two to get to MxM, and then mu again to get to M
10:05:16 <mm_freak> i always compile with -threaded
10:05:29 <Cale> or we can apply mu to the right two to get to MxM and then mu again to get to M
10:05:35 <nand`> what disadvantages does -threaded have?
10:05:35 <mm_freak> i'm not counting on my libraries not to use forkIO somewhere
10:05:36 <Cale> and those two ways are meant to be equal
10:05:38 <saml> notdan, do you want something that does something every N seconds?
10:05:45 <mm_freak> nand`: a larger RTS
10:06:06 <statusfailed> Cale: okay, so Monad's eta (return) corresponds to the monoid identity, and its associative binary operation corresponds to Mu
10:06:06 <Cale> statusfailed: So hopefully that's not too horribly confusing and you can spot some similarity there between how monads and monoids are set up
10:06:10 <notdan> saml: yeah; basically
10:06:10 <Cale> yeah
10:06:14 <statusfailed> Yep, that makes a lot of sense
10:06:33 <Cale> The one element set is replaced by the identity functor
10:06:48 <Cale> and the Cartesian product of sets is replaced by composition of functors
10:06:57 <statusfailed> right
10:07:25 <notdan> mm_freak: sorry, i can't seem to google it; how can i add a ghc compile flag into my project .cabal file?
10:07:40 <nand`> statusfailed: now you can say with full confidence that “monads are just monoids in the category of endofunctors, duh”
10:07:48 <Cale> We can generalise this, defining categories having some sort of operation on objects, which is associative (perhaps only up to isomorphism), and which has a unit with respect to that operation on objects
10:08:02 <plat0> Is it possible to delete/free STRefs?
10:08:07 <Cale> almost turning the objects of the category into their own monoid of sorts :)
10:08:12 <notdan> oh nvm,, I've found it
10:08:13 <notdan> sorry
10:08:20 <Cale> and then we can define monoid objects inside such a monoidal category
10:08:28 <Cale> and ordinary monoids will be monoid objects in Set
10:08:38 <Cale> and monads will be monoid objects in a category of endofunctors :)
10:09:27 <luite> benmachine: have you started making haskell-src-meta compatible with th 2.8?
10:09:36 <Cale> more precisely, I should say in the monoidal category (Set, ×, 1)
10:09:53 <benmachine> luite: nope
10:09:59 <Cale> and the monoidal category of endofunctors, with composition and the identity functor as the monoidal operation :)
10:10:35 <Cale> statusfailed: The details of this get slightly hairy with all the isomorphisms, but you can look on Wikipedia or ncatlab for the full thing
10:10:47 <Cale> http://en.wikipedia.org/wiki/Monoidal_category
10:11:01 * nand` still has that page open
10:11:07 <Cale> http://ncatlab.org/nlab/show/monoidal+category
10:11:24 <luite> benmachine: ah i just got it to compile, but i commented out a few things that i think i shouldn't have :)
10:11:27 <Z`> mm_freak: I'm not very familiar with let,in. does let (x, s1) = g s0, extract the result of g s0, which is of type (a, s) and then maps it to x and s respectively ?
10:11:42 <benmachine> luite: I don't have an RC of GHC around, but you're welcome to show me what you've got
10:12:21 <luite> oh i downloaded ghc-7.6.1-src.tar.bz2
10:12:32 <luite> i think that's going to be the release unless something bad happens
10:12:49 <benmachine> oh right
10:13:25 <Cale> statusfailed: The nice thing about category theory is that whenever you're exploring some new branch of mathematics (or even just a new programming language), you can start to ask whether the things you're working with form a category somehow, and since they usually do in one way or another, you can start to ask whether all sorts of widgets which can be defined in any category exist in your setting, and usually these t
10:13:26 <Cale> hings turn out to be important or useful concepts.
10:13:26 <benmachine> but I've got 125 packages on 7.4.2 :(
10:13:45 <parcs`> > 32*64000/1024
10:13:46 <lambdabot>   2000.0
10:14:53 <luite> benmachine: 7.6.1 isn't really ready for production though, perhaps the compiler is, but hackage isn't
10:15:01 <luite> everything seems to break...
10:15:22 <plat0> Z`: yes (or rather x and s1)
10:15:46 <benmachine> luite: I'm not too worried, I seem to have nine versions of GHC installed
10:15:50 <Cale> Category theory is all about providing these unifying notations which can be studied for their own sake, but also transplanted into new settings. Originally, people had higher hopes for being able to transplant theorems from one area of mathematics to another, and while there's a bit of that, the more useful aspect of it has mainly been the change in philosophical approach to new settings.
10:15:51 <statusfailed> Cale: Does the category have to be endofunctors because the associative binary operation is (a -> a -> a) ?
10:16:32 <Cale> statusfailed: Well, if C and D are any two categories, we get a category of functors C -> D, and natural transformations between them
10:16:42 <Cale> i.e. the objects of the category are functors C -> D
10:16:43 <luite> benmachine: hehe, you beat me, i only have seven :)
10:16:48 <Cale> and the arrows are natural transformations
10:17:08 <Cale> statusfailed: However, to get that additional monoidal category structure, we want to be able to compose any two of our functors
10:17:16 <Cale> statusfailed: and for that, we need them to be endofunctors
10:17:32 <Cale> We want things like T(T(TX)) to make sense, after all
10:17:36 <benmachine> luite: I probably don't need 7.0.1, 7.0.2, 7.0.3, *and* 7.0.4 >_>
10:18:18 <luite> i'm trying to abandon 7.0 now, and to base my new ghcjs code generator on ghc 7.6 :)
10:18:19 <Cale> Or, more abstractly, T^3
10:18:31 <Cale> (the functor which applies T three times)
10:19:03 <Cale> statusfailed: make sense?
10:19:16 <luite> I'm excited to get this thing going, i really want live graph reduction in the browser :)
10:19:28 <nand`> :)
10:19:37 <statusfailed> In other words, in order to _define_ a monoid on a category of functors, the functors must be endofunctors so that they can be composed
10:19:44 <statusfailed> Cale: I think so?!?!
10:19:44 * nand` is just fiddling around with compiling graph reducers into other languages himself
10:19:49 <Cale> yes
10:19:53 <statusfailed> wooo :D
10:20:10 <statusfailed> I think i'm there! I'm gonna write some tidy notes so I don't forget it all :D
10:20:28 <statusfailed> Thanks Cale, you're awesome!
10:20:32 <luite> nand`: do you know a good graph layouter for javascript?
10:20:38 <Cale> statusfailed: So not only do categories themselves form a category Cat with functors being the arrows, each bundle of arrows Cat(C,D) isn't just a collection, but itself has a category structure
10:20:48 <nand`> luite: I don't know anything about javascript
10:20:54 <nolrai> dolio: you around?
10:20:56 <nand`> (my target is C#)
10:21:03 <luite> ah
10:21:04 <Cale> statusfailed: and so Cat is (at least morally) a 2-Category :)
10:22:05 <statusfailed> hang on, just trying to grok the second part of that....
10:22:41 <nolrai> Cale: what's the catagory structure of Cat(C,D)?
10:22:52 <luite> nand`: step by step reduction seems relatively simple to do, since i already have a trampoline and that function knows the top of the thing that's being reduced. it's just replacing the trampoline function with one that walks the heap every step, and renders it to some nice graph
10:23:00 <luite> but i'm sure i'm overlooking a lot of things :p
10:23:03 <Cale> nolrai: The objects are functors C -> D, and the arrows are natural transformations between those parallel functors
10:23:33 <statusfailed> Cale: oh yeah! that's the step I was missing
10:23:44 <nand`> luite: I take it your implementation is not spineless (unless I'm misunderstanding)?
10:24:11 <statusfailed> Is it possible to have a set of objects which can't form a category?
10:24:24 <Cale> statusfailed: So if we think of objects as being points, and arrows as being one-dimensional line segments between those points, the arrows between the arrows are like 2-dimensional sheets
10:24:54 <Cale> statusfailed: nope, if S is any set, we can always form the category whose objects are the elements of S, and which only has the identity arrows
10:25:10 <Cale> which is called the discrete category
10:25:23 <nolrai> statusfailed: objects no, because you can always define arrows, even if they are trivial. Now your arrows might fail to associate..or ID might not always exist,
10:25:28 <Cale> (because it's all separated into points)
10:25:41 <luite> nand`: hmm, you got me there, that looks like a major complication :) (because it is)
10:25:42 <mm_freak> notdan: GHC-Options: -W -threaded
10:25:46 <luite> nand`: spineless
10:25:59 <mm_freak> Z`: 'let' is just a scoped definition, something you could have written on the top level
10:26:02 <nand`> then I'm probably misunderstanding
10:26:04 <Cale> statusfailed: We can also form a category whose objects are the elements of S, and for any two objects x and y, there is exactly one arrow x -> y
10:26:20 <Cale> statusfailed: and this is called the indiscrete category on S
10:26:40 <mm_freak> Z`: "let (x, s1) = g s0 in …" means that (x, s1) is the result of applying g to s0 and is in scope after the 'in'
10:26:41 <nand`> but ‘walking the heap at every step’ and ‘rendering it to some nice graph’ sounds like following a spine to me
10:26:43 <statusfailed> Cale: this is ripe ground for some punnage
10:27:19 <Cale> statusfailed: You can think of the objects in the case of the discrete category as being "as different as possible" -- to the point that they're not even comparable in any sense, there are no arrows from one to another.
10:27:29 <luite> nand`: yeah but that was just me being stupid...
10:27:48 <Cale> and in the case of the indiscrete category, the objects are "as similar as possible" -- they are all isomorphic, and there's a unique way to go from one to the next.
10:27:48 <statusfailed> Cale: and indiscreet where there are arrows from each to all
10:28:08 <statusfailed> Cale: so the indiscreet category is quite promiscuous, like a fully connected graph?
10:28:49 <Cale> heh, yes
10:28:52 <nand`> luite: here's what my target code looks like right now (it doesn't do updates yet but I have an idea of how to do them; I'm trying to piece things together myself before consulting books as much as possible) http://bpaste.net/show/43917/
10:29:00 <Cale> "indiscrete"
10:29:18 <luite> nand`: hehe that's a whole lot more prettier than my output
10:29:22 <statusfailed> What do you call the category of swingers? indiscrete!
10:29:22 <statusfailed> :D
10:29:32 <statusfailed> Cale: I like my spelling more ;D
10:29:32 <Cale> Though of course, you can pun about the distinction between indiscreet and indiscrete
10:29:46 <saml> hey, after doing forkIO,  how can I wait for the forked io to finish?
10:29:59 <statusfailed> Cale: that's the best I could do, sorry :P
10:30:03 <saml> threadId <- forkIO someAction;    and this thread quits right away.
10:30:07 <saml> I'm doing that in main
10:30:19 <saml> do I have to use MVar
10:30:29 <mm_freak> saml: if the main thread exits, all threads exit
10:30:32 <notdan> mm_freak: what does -W stand for? warnings/
10:30:37 <Cale> saml: Make a new MVar filled with () before forking
10:30:39 <mm_freak> notdan: yeah
10:30:44 <notdan> mm_freak: okay, thanks :)
10:30:47 <mm_freak> a healthy set of warnings
10:30:48 <Cale> saml: takeMVar in the forked thread
10:30:59 <Cale> saml: and try to putMVar in the main thread
10:31:14 <Cale> or vice-versa
10:31:15 <mm_freak> putMVar in the forked thread
10:31:37 <statusfailed> Cale: thanks very much again for that
10:31:37 <Cale> You can start with an empty MVar, try to putMVar in the forked thread, and takeMVar in the main thread
10:31:43 <Cale> statusfailed: no problem
10:32:00 <Cale> statusfailed: You might also be interested in watching TheCatsters videos on YouTube
10:32:08 <statusfailed> I'm going to head home, but that was probably the best intro to category theory I could have asked form :)
10:32:12 <Cale> also this book: http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
10:32:15 <statusfailed> I'll check it out
10:32:16 <statusfailed> and that :D
10:32:31 <luite> nand`: http://hpaste.org/74294
10:32:40 <statusfailed> Right, best head off
10:32:43 <statusfailed> Cale: thanks again!!
10:32:57 <Cale> quite welcome!
10:33:12 <paolino> hello, I cannot understand why populate x = const x `fmap` mempty is not compiling
10:34:03 <paolino> it gives an error about ambiguity check, asking me a signature
10:34:05 <Z`> mm_freak:  \s0 -> let (x, s1) = g s0 in (f x, s1) ?    (don't tell the correct answer)
10:34:16 <nand`> luite: that looks much closer to something I'd expect from GHC; my implementation has nothing to do with GHC unfortunately - it's just a compiler for extremely simplified variant of the STG
10:34:30 <rwbarton> @type let populate x = const x `fmap` mempty in populate
10:34:31 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monoid (f a)) => a1 -> f a1
10:34:40 <rwbarton> probably the monomorphism restriction?
10:34:47 <paolino> I tried
10:34:47 <rwbarton> oh wait
10:34:49 <luite> nand`: yeah i convert from the ghc stg, similar to the regular code generator that generates Cmm
10:34:56 <rwbarton> you have an argument on the left hand side, derp
10:35:02 <paolino> sure
10:35:19 <luite> nand`: calling convention is more or less the same as cmm, but there are a few differences
10:35:19 <mm_freak> Z`: yes
10:35:20 <rwbarton> well, it is clearly something about the rest of the code that does not compile
10:35:22 <nand`> luite: how are you reprocessing the ghc stg? -ddump-stg or do you plug your code directly into the internals?
10:35:31 <luite> nand`: ghc api
10:35:36 <mm_freak> Z`: now you're ready for Monad =)
10:35:37 <nand`> ah
10:35:42 <paolino> rwbarton, it's a toplevel definition
10:35:49 <luite> nand`: -ddump-stg doesnt give enough information
10:35:53 <rwbarton> well what is the error
10:35:56 <Z`> mm_freak: I very much appreciate your patience (and the other attendants of the channel)
10:36:26 <paolino>     Could not deduce (Monoid (f a0))
10:36:27 <paolino>       arising from the ambiguity check for `populate'
10:36:27 <paolino>     from the context (Functor f, Monoid (f a))
10:36:38 <luite> nand`: for example whether some argument is a known function that you can jump to directly, or an unknown thing so that you have to call stg_ap_* first
10:36:47 <rwbarton> oh
10:36:49 <rwbarton> right
10:37:11 <luite> nand`: you can always do the slow thing and always go through the arity check (that the current ghcjs codegen does)
10:37:17 <Z`> mm_freak: what now ? :P I forgot what we were trying to achieve :P
10:37:29 <rwbarton> it doesn't know what type a to use mempty at (mempty :: m a) because fmap (const x) makes that type disappear
10:37:35 <Z`> ah,yes. instance Monad MyState ?
10:37:39 <rwbarton> but, different a could have different Monoid (m a) instances
10:37:54 <rwbarton> so there is a real ambiguity
10:38:17 <luite> nand`: the code there is a bit wrong, i'm building the closure layout info tables now, so that the garbage collector knows what things to follow, but those are inserted in the wrong place :)
10:38:53 <paolino> rwbarton, thanks
10:39:04 <nand`> luite: you're implementing your own GC and stuff? I'm just relying on C#'s garbage collection to get rid of unneeded closures for me
10:39:33 <nand`> (I'm also relying on it for building the closures in the first place; I don't address the heap directly)
10:39:41 <latro`a> wouldn't that mempty issue be solved with an mzero analogue?
10:40:20 <latro`a> (this isn't the mzero variant with mzero >>= _ = mzero, mind)
10:40:27 <luite> nand`: oh yeah the older ghcjs generator also did that, this is basically an experiment to see if this approach is better. it makes it easier to support some things that are really difficult to support with the regular javascript garbage collector, like weak refs
10:40:35 <nand`> luite: ah, I see
10:40:41 <nand`> yeah that does sound worth a try
10:40:55 <nand`> shame javascript doesn't have malloc and pointer dereferencing, huh? :)
10:41:01 <luite> yeah i had hoped that my try was a bit simpler
10:41:20 <luite> :p
10:41:33 <paolino> rwbarton, do I need to sign mempty ?
10:41:39 <luite> problem is that it's more or less a complete rewrite this way
10:41:54 <luite> nand`: a pointer is a pair of an array and an index in my implementation
10:42:26 <MostAwesomeDude> So how would I swap two items in a list?
10:42:31 <nand`> what does the array point to? just the free var list?
10:42:33 <nand`> err
10:42:36 <nand`> what is the array*
10:42:55 <luite> nand`: oh a closure is a special pointer, that's just an index to the heap array
10:43:41 <rwbarton> paolino: that would be one thing to do, probably easiest with ScopedTypeVariables
10:43:45 <saml> notdan, https://gist.github.com/3640892
10:44:04 <luite> nand`: these other pointers are for supporting bytestring and stuff
10:44:17 <nand`> ah
10:44:46 <luite> i think the array primops will also just use javascript typed arrays, not the heap array
10:44:53 <luite> but i haven't implemented them yet for this one
10:45:07 <luite> should be possible to do canvas drawing with repa then
10:46:49 <nand`> I could probably switch to F# instead of C# for my target, then I can make use of tail calls, name shadowing and other niceties; specifically with tail calls I can probably compile case..of expressions down to a dead simple method, without needing an extra return table or stuff
10:47:17 <nand`> luite: heh, that sounds neat
10:48:57 <latro`a> MostAwesomeDude, you really really shouldn't
10:49:06 <latro`a> ixmap is an elegant way to do that with Array, however
10:49:44 <latro`a> eh, elegant-ish
10:50:37 <dford> Me viewing Bryan O Sullivan's key note speech http://cufp.org/videos/keynote-real-world-haskell
10:50:46 <dford> Its interesting
10:51:07 <MostAwesomeDude> latro`a: Okay, so if I have an algorithm that draws a list of things in order, and order matters, how should I swap around those things?
10:51:23 <latro`a> do you know how many things you're dealing with?
10:51:56 <latro`a> also, how do you know which ones to swap, by index?
10:52:50 <MostAwesomeDude> Yeah, randomly picked indices.
10:52:56 <latro`a> and you know the length too?
10:53:08 <MostAwesomeDude> Well, it's a finite list.
10:53:16 <latro`a> finite but you don't know the length a priori?
10:53:19 <benmachine> MostAwesomeDude: you could try Data.Sequence
10:53:29 <latro`a> yeah Sequence might do some good
10:53:30 <benmachine> from containers
10:53:48 <MostAwesomeDude> Hm.
10:54:05 <poisonarms> I'm having a pretty hard time learning Haskell. Especially when it comes to how I should create a type signature. Often I get an error that mentions a type signature, I try adding it, same kind of error. Take for instance the following function: http://hpaste.org/74295 - Using Num instead of Integral throws an error. Is there an "easy" way to know before hand what kind of type signature I should use? I also cannot figure out why t
10:54:50 <latro`a> mapWithIndex (\k x -> if k == i then j else if k == j then i else k)
10:54:54 <latro`a> erm
10:54:55 <newsham> type signatures are often optional.  you can write the code without a signature and ask haskell what the type signature should be
10:54:56 <latro`a> bah
10:55:22 <benmachine> poisonarms: your message got cut off at "also cannot figure out why t"
10:55:40 <poisonarms> benmachine: Sorry: I also cannot figure out why this same function does not work with Num. Isn't (-) defined in Num?
10:55:48 <latro`a> mapWithIndex (\k x -> if k == i then xs `index` j else if k == j then xs `index` i else x)
10:55:53 <latro`a> or something
10:55:58 <benmachine> poisonarms: you'll need Ord
10:56:09 <benmachine> poisonarms: what error messages are you getting?
10:56:11 <nand`> you're comparing with <
10:56:17 <poisonarms> nand`: Ah!
10:56:20 <poisonarms> That makes sense.
10:56:22 <nand`> Num no longer requires Ord or something
10:56:29 <nand`> that is
10:56:31 <nand`> it's no longer a superclass
10:56:39 <benmachine> nand`: no, you're thinking of Eq and Show
10:56:45 <benmachine> Num and Ord were never linked
10:56:48 <nand`> okay
10:56:51 <benmachine> but Integral implies Ord via Enum
10:57:15 <latro`a> if Num and Ord were linked then you'd be unable to do things like the function Num instance
10:57:32 <newsham> ?type let f x -> if x <= 0 then [0] else x : f (x-1) in f
10:57:33 <lambdabot> parse error on input `->'
10:57:38 <poisonarms> benmachine: When I change the type signature to use Num instead of Integral, I get http://pastebin.com/Ma95FPha
10:57:38 <newsham> ?type let f x = if x <= 0 then [0] else x : f (x-1) in f
10:57:39 <lambdabot> forall a. (Ord a, Num a) => a -> [a]
10:57:48 <benmachine> latro`a: or more to the point, the Complex instance
10:57:50 <nand`> yeah you're right
10:57:53 <poisonarms> And I still haven't learned how to effectively read Haskell's error messages yet.
10:57:56 <poisonarms> ;-;
10:58:23 <newsham> reading haskell error messages takes some practice
10:58:30 <benmachine> poisonarms: ah, well, what it's saying here is that if you want to pattern-match against 0, you need to be able to equate things
10:58:35 <nand`> ‘Cannot deduce (Ord a)’ <- it doesn't know how to compare ‘a’s
10:58:41 <newsham> in fairness that error message is pretty clear :)
10:58:51 <poisonarms> I see.
10:58:58 <sfogarty> Is there a way to make a type 'undefined' in haskell, as we can make functions undefined? I am trying to provide a homework and set of tests cases that will compile out the bat.
10:59:01 <newsham> it says you need to say that "a" needs to be "Ord" and "Eq"
10:59:12 <benmachine> poisonarms: so the two messages are saying to you, I can't prove that a is Eq or Ord, and I need it to be those things, because you've used it like it is
10:59:23 <newsham> > let f = undefined in f 25
10:59:24 <lambdabot>   *Exception: Prelude.undefined
10:59:26 <poisonarms> I see I see.
10:59:29 <poisonarms> Okay
10:59:55 <sfogarty> great for functions, newsham, not so great for types. I may have to have separate test files for each type they work with
10:59:57 <poisonarms> So then if I do: countDown :: (Num a, Ord a, Eq a) - It should be okay?
11:00:00 <benmachine> sfogarty: no, but if you give some examples of where you'd use it we might be able to show you something else that works
11:00:16 <nand`> poisonarms: yes. that's also redundant, because Ord a implies Eq a
11:00:21 <poisonarms> Ahh
11:00:25 <newsham> sfogarty: oh for types.   if its a type signature you can just leave it unspecified and let haskell figure it out
11:00:41 <sfogarty> is there a prefered #haskell pastebin-like-thing?
11:00:43 <newsham> if you want a data type, you could define a data type with no constructors (so long as you're not using them yet)
11:00:48 <poisonarms> sfogarty: hpaste.org
11:01:02 <newsham> or even provide a dummy constructor
11:01:26 <newsham> ?type let f x = if x <= 0 then [0] else x : f (x-1) in f
11:01:27 <lambdabot> forall a. (Ord a, Num a) => a -> [a]
11:01:37 <newsham> sfogarty: like that.   except you dont really need the "forall a."
11:01:46 <roconnor> > complement 0x36
11:01:47 <lambdabot>   Ambiguous type variable `a' in the constraint:
11:01:47 <lambdabot>    `Data.Bits.Bits a'
11:01:48 <lambdabot>      a...
11:02:03 <newsham> (Eq a, Ord a, Num a) => a -> [a]     would also be fine, but as nand says you can skip the "Eq a" when using "Ord a"
11:02:11 <poisonarms> Does anyone know of any good online Haskell books other than LYAH? I have a hard time following this guy's explanation of a lot of things because I feel like he assumes everyone learning Haskell is a mathematician.
11:02:16 <roconnor> > traverseFor bit complement 0x36
11:02:17 <lambdabot>   Not in scope: `traverseFor'
11:02:22 <newsham> poisonarms: you can always ommit the typ esignature (or comment it out) and then ask ghci what the type should be
11:02:29 <benmachine> poisonarms: a good way to find out about type classes, btw, is the :i command in ghci
11:02:36 <newsham> poisonarms: go find the online version of "real world haskell"
11:02:40 <hpaste> “Seth Fogarty” pasted “Homework of undefines” at http://hpaste.org/74296
11:02:42 <benmachine> poisonarms: if you do :i Ord you can see that it has Eq in there
11:02:51 <Jeanne-Kamikaze> I'm not a mathematician and I think LYAH is the best first book
11:02:57 <newsham> and learning haskell is a lot like learning mathematics if you are not a mathematician :)
11:03:19 <sfogarty> benmachine: newsham: I want to provide a homework something like that paste, so I can write a test file that operates on their functions even when they have written them yet
11:03:55 <sfogarty> er, haven't written them yet
11:03:58 <newsham> data BST a = DummyConstructorForBst
11:04:01 <nand`> learning haskell is somewhat like learning basic algebra, you get introduced to the model of reasoning centered around definitions and semantic equalities; as opposed to state mutation or control flow
11:04:24 <benmachine> nand`: it doesn't *need* to be like that
11:04:24 <nand`> I'd say it requires a mathematical mind - but not necessarily a mathematical education
11:04:26 <sfogarty> That could work.
11:04:30 <roconnor> @type showBin
11:04:31 <lambdabot> Not in scope: `showBin'
11:04:53 <newsham> gotta run.. good luck!
11:05:07 <nand`> (but then again, I'd say learning any programming language requires a mathematical mind)
11:06:16 <Twisol> #haskell, I've got a dilemma. I'm currently studying for a BS in CS, but with 10 years of programming experience I don't feel like I'm learning anything new. I'm most interested in the mathy side of programming, like Haskell and category theory and lambda calculus, but I can't find anything in the CS program along those lines. I'm thinking of either changing to a Mathematics degree or transferring elsewhere - are either of those ideas shortsighted?
11:06:53 <benmachine> Twisol: have you got a decent mathematics background?
11:07:04 <benmachine> my mathematics degree was good fun but it was *hard*
11:07:38 <Jeanne-Kamikaze> can't you just buy a book ?
11:07:41 <Twisol> benmachine: Not sure how to answer that - I've taken up to Calculus II, and I really really enjoy what I've learned of group theory
11:08:53 <benmachine> Twisol: *shrug* that's probably fine - I just meant to imply that it's probably not something you just jump into for fun :P
11:08:58 <poisonarms> newsham: Yea I've noticed, haha, and I was never good at math in school.
11:10:03 <Twisol> benmachine: *shrug* I enjoy math in general. If I didn't, I probably would be staying the heck away from a math degree.
11:10:18 <notdan> saml: why do we need to use MVars?
11:10:22 <benmachine> Twisol: yeah, fair enough. I am doing a notoriously hard course, as well
11:10:32 <Twisol> hehe, fun.
11:11:01 <benmachine> my maths degree was loads of fun, but I don't think that's useful information :P
11:11:07 <sfogarty> Twisol: A PL class should introduce you to at least lambda calculus, and if you have seminars they might go into category theory. Look at theory of computation and algorithms for more mathy fun stuff.
11:11:39 <saml> notdan, i don't know.. so that main will not exit
11:12:22 <danil> Twisol: There are a lot of mathy CS subfields that aren't very much like programming language theory -- machine learning, computational geometry, complexity theory...
11:12:22 <sfogarty> But CS is not going to get into the 'deep maths' of a mathematics degree
11:12:22 <Ralith> Twisol: undergrad CS education mostly sucks
11:12:41 <sfogarty> compgeom is fun :)
11:13:36 <sfogarty> Twisol: Also, what year are you in? With 10 years of programming experience, the intro sequence will suck, but your discrete math class should be at least a little interesting.
11:13:41 <Twisol> I'm looking at the course catalog, and nothing jumps out as being especially interesting until the graduate level. So +1 to Ralith.
11:13:50 <Twisol> catalog: http://catalog.csun.edu/colleges/college-of-engineering-and-computer-science/computer-science-2/courses/
11:14:02 <Twisol> sfogarty: Third semester
11:14:31 <notdan> saml: sorry, I am a complete noob @ System.Concurrent
11:14:47 <hpaste> daniel_- pasted “im bad at ADT's (need feedback)” at http://hpaste.org/74297
11:14:48 <notdan> saml: but thank you for a good example :)
11:15:03 <Ralith> Twisol: some univs will let you take grad courses with instructor permission, but be certain you have the prereqs.
11:15:21 * Ralith studied group theory and computational algebra that way
11:17:01 <Twisol> I guess I could muck with the program that way, but that's why I'm wondering whether I should just change gears.
11:18:59 <sfogarty> Twisol: discrete structures, advanced data structures (if it isn't implementaiton-oriented), automata, concepts of PL are your best bet. Doesn't look like you have a good mathy algorithms class there
11:19:51 <sfogarty> oh, and 615 if you can get into it
11:20:15 <sfogarty> maybe 630
11:20:51 <sfogarty> Twisol: that doesn't look significantly less mathy than most other curricula. Some places (UIUC) have really good senior theory classes, but that's only one course.
11:21:37 <Twisol> sfogarty: I've been eyeballing those 6** classes, yeah.
11:22:09 <Twisol> 282 (adv. data structures) is very implementation oriented. I'm taking it now
11:22:15 <sfogarty> bleh.
11:22:41 <sfogarty> 310 is your best bet then
11:22:45 <SLi> Is it normal for $binary +RTS -sstderr to say "Productivity -27.5% of total user, -26.5% of total elapsed"? (I don't know what productivity means here, but negative productivity for my program sounds bad :-)
11:23:30 <johnw> daniel_-: you also can make your own data structure a Monad
11:23:43 <johnw> if you need to chain DSPs
11:24:01 <sfogarty> Twisol: look at a double major, or minor in mathematics? (or major in math, minor in CS?)
11:24:46 <Twisol> sfogarty: I've also been considering that option. Unfortunately, CSUN has a unit cap, per-semester and overall
11:25:07 <Twisol> currently, only 16 units can be taken per semester, and you have to complete your program <= 140 units
11:25:33 <Twisol> the CS program already covers 120 of those :/
11:25:47 <sfogarty> soooo, you get 8 free
11:25:54 <sfogarty> That's kind of obnoxious.
11:26:15 <Nereid> and you can't get special permission to take more?
11:27:13 <Twisol> Nereid: They have processes in place, but the caps are financially-driven. They can't break a certain level without losing a chunk of state funding.
11:27:44 <Twisol> (this is where I remind you that I'm not a spokesperson for the uni, and I could be totally wrong)
11:28:04 <sfogarty> and this is why I'm glad I didn't end up working at a CSU (not that I even remember which one I applied to)
11:29:15 <sfogarty> Twisol: talk to your advisor, and find a good prof in math to talk to as a 'secondary advisor'. You aren't going to get tha tmuch math in CS: at most 4-5 courses.
11:30:14 <sfogarty> If you want to go into academia, Math is a great degree. If you want to go into industry, at least a minor in CS is very helpful, but you can probably swing it with a math degree and significant (i.e. with references) work on external code projects.
11:30:38 <sfogarty> that being said: I am not an expert
11:30:44 <sfogarty> I've never actually /been/ in industry :)
11:30:54 <Twisol> Heh, any advice is appreciated.
11:31:29 <sfogarty> there should be people to talk to at the university.
11:38:46 <t7> It would be nice if there was some deriving class thing that lets you label branches/leafs in a tree implicitly
11:39:51 <t7> i dont wanna label every item in my AST with debugging info
11:41:20 <adnam> t7: i was doing something like that at some point
11:41:41 <krey_> o/, I'm trying to understand what the Eilenberg-Moore category for a monad is. I know the Kleisli category is important, but I can't really see what an algebra for a monad 'does'
11:42:36 <adnam> for creating hierarchical error messages
11:43:17 <Saizan> krey_: try figuring out what an algebra for the list monad corresponds to
11:44:18 <beaky> hello
11:44:25 <Saizan> krey_: knowing that [a] is the free monoid is a big hint
11:45:10 <johnw> Saizan: what does "free" mean in that sentence?
11:45:13 <beaky> is there a function that takes two lists of the same size and returns a list of pairs of each element?
11:45:38 <johnw> beaky: zip
11:46:09 <beaky> ah exactly what I needed ^^
11:46:14 <fmap> @hoogle [a] -> [b] -> [(a,b)]
11:46:14 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
11:46:14 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
11:46:14 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
11:46:15 <Cale> krey_: Have you looked at what the algebras for the list monad are?
11:46:25 <beaky> awesome!
11:46:43 <Cale> krey_: They are exactly monoids, and list-monad-algebra morphisms are exactly monoid homomorphisms
11:46:44 <Twisol> Is it possible to derive any monad by getting the free monad of a functor?
11:47:03 <Saizan> johnw: it free X means that it's a structure that satisfies the laws of X but nothing more
11:47:06 <Cale> Twisol: no, not all monads are free (most are not)
11:47:31 <johnw> Saizan: wow, that was really clear, thank you
11:47:33 <Twisol> Cale: thanks
11:47:51 <krey_> Cale, Saizan: give me a few minutes, I'll try to prove this
11:47:51 <johnw> so a free monad supports the monad laws, but doesn't "do" anything
11:48:13 <Cale> Twisol: However, free monads can kinda stand in for non-free ones, because you can apply interpretations which treat different terms in the free monad in the same way.
11:49:13 <johnw> so in a way, the canonical Hello World program is a free program
11:49:28 <johnw> it demonstrates that a language works, without providing any functionality
11:49:56 <Cale> It prints something to the screen though!
11:50:24 <johnw> it satisfies the law that program must have some kind of side effect :)
11:51:28 <Saizan> free monads are ASTs more or less
11:51:39 <sopvop1> Threre is so much talk about free monads. Read bunch of blogs, still don't get how to use it.
11:51:47 <Saizan> the functor tells you which operations you are allowed to use :)
11:52:21 <sopvop> is it good or bad?
11:54:11 <beaky> How do you write a Qt application with haskell?
11:54:24 <beaky> is it by invoking a separate C++ library?
11:54:33 <beaky> or is it through Haskell modules?
11:54:34 <edwardk> sopvop: free monads are for people who are too lazy to think of the final encoding of their monad and just want to get an AST out of it to manipulate later ;)
11:54:35 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:54:42 <johnw> Saizan: yes, i blogged about that use of them
11:54:43 <edwardk> @messages
11:54:43 <lambdabot> cheater said 26m 12s ago: btw I figured it out already ;)
11:55:21 <johnw> beaky: http://hackage.haskell.org/trac/summer-of-code/ticket/1116
11:56:53 <edwardk> mind you i'm often that lazy person
11:56:54 <Twisol> Off-the-wall question: does anyone use a whiteboard, pen&paper, etc. for designing parts of their code?
11:56:54 <sopvop> beaky: there are no useful bindings to qt. (or any large c++ library)
11:57:31 <edwardk> Twisol: we have a room where 3 walls are covered in whiteboard paint, and then that is covered over in a layer of haskell ;)
11:57:37 <Twisol> :D
11:57:56 <Twisol> "whiteboard paint" - I need to get me some of that
11:58:12 <Lutin`> omg
11:58:15 <Lutin`> edward
11:58:16 <edwardk> i recommend putting down a coat of magnetic primer first
11:58:21 <Dashkal> Twisol: <3 my whiteboard
11:58:23 <Lutin`> That is my dream room
11:58:27 <edwardk> then you can stick panels of whiteboard markers, etc to it
11:58:35 <Lutin`> I do all my work on whiteboards
11:58:42 <edwardk> they didn't do that here, but a buddy of mine did that in his home office
11:58:42 <sopvop> Napkin and gnawed pencil are my tools.
11:58:43 <johnw> edwardk: sounds exactly like the inside of my mind right now
11:58:49 <Twisol> Glad to see I'm not alone in my whiteboardery
11:58:55 <krey_> Saizan, Cale: I could do with a small hint
11:59:01 <johnw> edwardk: I'm hungering to master Codensity.  Do you have more articles?
11:59:23 <edwardk> johnw: you read through kan-extensions i, ii, and iii?
11:59:34 <johnw> yeah, but you are a dense writer for someone at my skill level
11:59:45 <johnw> too much info too fast for little me
12:00:01 <edwardk> the best way i know to learn codensity is to actually try to write it by hand
12:00:04 <johnw> I need a "here's a real problem I had, here's how I solved it with Codensity" type intro
12:00:08 <edwardk> e.g. sit down and work out the monad, etc.
12:00:16 <johnw> yeah, that approach doesn't help me very much I've found
12:00:23 <Saizan> krey_: given the algebra f :: [M] -> M, you should be able to define Monoid M just by applying f to appropriate lists
12:00:24 <edwardk> ok, well, lets take a concrete example =)
12:00:26 <johnw> I need to apply, not master the definition (at first)
12:00:31 <johnw> oh, wait, I don't have time just yet
12:00:31 <edwardk> we can make a monad for probability theory
12:00:35 <johnw> but I'll ask you later tonight :)
12:00:46 <johnw> right now I have a C problem to solve over in boring land
12:01:07 <edwardk> newtype P a = P [(Double,a)] where we are given that doubles in the list sums to 1.
12:01:17 <Cale> krey_: one thing which is worth pointing out I suppose is that the monad laws don't really encode the monoid laws -- the monoid laws are already implicit in the structure of lists
12:01:24 <edwardk> return a = P [(1, a)]   -- etc
12:01:38 <johnw> edwardk: I know nothing about probability theory either
12:01:43 <johnw> think code monkey
12:01:48 <johnw> not math jock
12:01:52 <Twisol> Are there any good guides to building a monad? I see that every monad appears to have a set of primitive operations, but I don't really know how to go about designing a monad.
12:01:59 <edwardk> this is rather inefficient for many operations, you can take the free monad of that, and then take codensity of that to make it fast to explore the space of possible probabiilities
12:02:04 <johnw> I can dereference a pointer like nobody's business, but I don't know which category it belongs to!
12:02:08 <Sculptor> imperative programming does look inferior now
12:02:38 <edwardk> another example of a free monad, is to build asymmetric coroutines or callbacks
12:02:45 <Cale> krey_: The basic idea of monad algebras is that the elements of your monad sort of specify a kind of "abstract syntax" for some kind of algebraic object, where things that are supposed to be axiomatically identified by whatever rules your algebraic objects have are already identified in that syntax.
12:02:49 <johnw> Twisol: determine what three things mean: putting a value into your monad, mapping a function over your monad, and merging two nested monad (m (m a) -> m a)
12:02:56 <edwardk> but once you've done so (>>=) becomes expensive, codensity fixes the asymptotic performance of that
12:03:12 <johnw> Twisol: once you get an intuitive feel for what those *mean* in terms of your monad, then you'll understand a lot about what the rest means, like >>
12:03:41 <Cale> krey_: and then when you pass to the algebra, you have an evaluation map, M A -> A which takes an "expression" in whatever syntax the monad implies, and "evaluates" it down to a value.
12:04:03 <johnw> Twisol: for example, take a list: (1) a => [a], (2) map f [a], (3) concat [[a]]
12:04:17 <edwardk> johnw: another good example is that you can use codensity to make code that you write in the basic newtype Tree a = Bin (Tree a) (Tree a) | Tip a  monad more efficient
12:04:25 <Cale> krey_: and the fact that this evaluation has to be compatible with the identity sort of gives you a way in which elements of A can be seen as expressions on their own
12:04:28 <johnw> edwardk: yeah, I saw that in your article
12:04:39 <Twisol> johnw: This presupposes that I know that my monad is a list (or other X where X is a data type)
12:04:45 <johnw> I do understand what Codensity solves, I just don't know how to apply it to code I might write
12:04:54 <johnw> Twisol: I was just giving an example
12:05:05 <Twisol> johnw: I know - my point is I don't know what my datatype is yet
12:05:13 <johnw> Twisol: ah, then don't think about Monads yet
12:05:15 <Twisol> just a vague sense of what it should do
12:05:36 <edwardk> johnw: write the code without codensity, and when you find you are building something up with >>= but not inspecting it, change the code to just work with MonadFree put an 'improve' call in before using it
12:05:45 <johnw> model your problem in the most straightforward way possible, then decide if context is needed, and if chaining of context is needed
12:05:54 <Saizan> Twisol: free monads help there, you get a monad just by defining the operations you want, then you'll worry later about how you are going to interpret them
12:05:54 <Cale> krey_: and then the fact that it has to be compatible with the monad multiplication (join) gives you a way to encode laws about how expressions collapse in the structure of join
12:05:58 <johnw> edwardk: that's it, just 'improve'?
12:06:04 <edwardk> johnw: thats whay i mostly do
12:06:08 <edwardk> er what
12:06:11 <johnw> edwardk: cool
12:06:25 <johnw> edwardk: in my blog post on free monads, where would I put the improve call?
12:06:28 <Cale> krey_: if that makes any sense at all :)
12:06:36 <Cale> krey_: are you familiar with, say, rings?
12:06:40 <edwardk> link again?
12:06:46 <Cale> or vector spaces?
12:06:56 <Cale> Those examples are particularly telling
12:06:58 <edwardk> i know i was there once, but i've since lost it ;)
12:07:07 <johnw> edwardk: I think I know why Comonads are less popular
12:07:09 <Cale> (after the monoid one)
12:07:13 <edwardk> johnw: ?
12:07:42 <edwardk> comonads are less popular because they serve a less pressing need, don't have sugar, and have no use in the IO story that was the killer app for monads.
12:08:04 <krey_> Cale: oops, I'm late for dinner, but I'd like to chat about this next time, thanks
12:08:04 <edwardk> if we hadn't needed a way to deal gracefully with IO, haskell probably wouldn't have monads today
12:08:21 <johnw> edwardk: because most of the typical data types one uses do not provide total definitions for extract: Nothing -> ⊥, [] -> ⊥, Left a -> ⊥, etc.
12:08:43 <edwardk> that too, there are only two types in the Prelude that can be made instances of Comonad.
12:08:50 <johnw> exactly
12:08:52 <edwardk> And only one of them using only the Prelude
12:09:17 <johnw> so, the fact that Comonad doesn't come with existing analogues to stuff that one uses everyday (the way Monad does), makes it harder to appreciate their use until you've already started coding them yourself
12:09:57 <edwardk> johnw: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.2323 goes through using codensity, though janis didn't know about the existence of codensity and just reasoned about it as if he was talking about a funny form of 'Cont'
12:10:11 <johnw> Comonad seems to be the "killer app" for stream processing, but that's not something everyone does
12:10:22 <edwardk> i started pushing the codensity name in the months that followed that paper
12:10:32 <johnw> cool, thanks!
12:10:52 <edwardk> the 'improve' name is taken from his paper
12:11:26 <johnw> also, the Store Comonad is pretty awesome, I think more people should know about it
12:11:27 <edwardk> there are two other ways to improve the performance of free monads, other than codensity that are equivalent in power
12:11:34 <johnw> what?
12:11:45 <Twisol> Question… What are academic papers? Are they discoveries or improvements? Or can they just be discussion/synopsizing? Etc.
12:11:45 <nand`> so I was wondering why my graph reducer was evaluating three > (two + one) to true - turns out I accidentally defined three as three = succ three instead of three = succ two. Don't you just love nonstrict languages? :)
12:11:48 <edwardk> there is heinrich apfelmus's 'operational monad' approach, which is effectively Free (Coyoneda f), and my church encoded free monad
12:12:04 <edwardk> both get the same asymptotic wins as switching to Codensity (Free f) from Free f
12:12:19 <Cale> Twisol: They can be all of those things
12:12:48 <edwardk> Twisol: most academic papers are discoveries and improvements, but there are plenty of the other type as well
12:12:59 <Twisol> Alright, thanks
12:14:02 <johnw> ah, I saw operational and thought it was just another definition of Free
12:14:12 <johnw> I didn't realize it provided the asymptotic gain
12:14:31 <edwardk> yeah, me neither at first
12:14:35 <Cale> Twisol: They are communications of the work that someone has been doing, which usually involves something new. There's some appreciation out there for improving the exposition of already known things though.
12:14:49 <Twisol> Cale: That's a great explanation.
12:14:51 <edwardk> we actually use the operational version of free in scala, because that is the only version that actually works with scala's stack model
12:15:22 <edwardk> in fact to work with _any_ monad in scala, you should trampoline it through the operational monad. ;)
12:15:33 <edwardk> otherwise it crashes on large traversals, etc.
12:17:21 <donri> edwardk: so, you have two separate "indexed" packages now?
12:17:57 <edwardk> i do?
12:18:29 <donri> @hackage indexed
12:18:29 <lambdabot> http://hackage.haskell.org/package/indexed
12:19:10 <edwardk> !#*
12:19:18 <johnw> what is an indexed monad?
12:19:24 <edwardk> i guess reiner packaged up my old code from category-extras
12:19:31 <donri> hah
12:19:40 <edwardk> i'll need to rename mine or ask him if i can tromple his
12:21:44 <johnw> is f . g the same as (f fmap) g or f (fmap g)?
12:21:54 <johnw> i guess it would have to be the latter
12:21:59 <johnw> @src (.)
12:21:59 <lambdabot> (f . g) x = f (g x)
12:21:59 <lambdabot> NB: In lambdabot,  (.) = fmap
12:22:07 <Cale> johnw: I guess you could say monoid is to monad what category is to indexed monad.
12:22:11 <Cale> in a particular way :)
12:22:20 <johnw> Cale: tell me that again in about a year ;)
12:22:41 <benmachine> johnw: fmap f g, surely
12:22:51 <johnw> oh, thanks
12:22:53 <johnw> f `fmap` g
12:22:55 <Cale> johnw: I'm assuming you're staring at http://hackage.haskell.org/packages/archive/indexed/0.1/doc/html/Control-Monad-Indexed.html
12:22:56 <johnw> that's what I had meant to say
12:23:01 <johnw> Cale: yes
12:23:03 <edwardk> emailed him
12:23:05 <Cale> johnw: In particular, focus on ireturn and ibind
12:23:06 <johnw> staring is a good word
12:23:42 <edwardk> Cale: well, the new indexed monad style is different, its just monads on a category with objects of kind k -> * instead of kind *
12:24:04 <edwardk> then you get back traditional monads when k is the unit kind ()
12:24:06 <johnw> oh, sure, I get that: g is a mapping from a -> b, so fmapping f onto it "passes in" an a and "extracts" a b
12:24:09 <Cale> johnw: The idea is that there are these two extra type parameters on m and they have to line up as you compose things together.
12:24:22 <edwardk> and you get 'HFunctor's in the Neil Ghani sense when k = *, etc.
12:24:25 <johnw> Cale: what do those extra parameters do?
12:24:45 <edwardk> johnw: consider state
12:24:55 <edwardk> newtype State s a = State (s -> (a, s))
12:24:59 <edwardk> if i split 's' into two parameters
12:24:59 <Cale> johnw: anything you want -- a good example is provided by an analogue to the State monad whose state type is allowed to change
12:25:06 <edwardk> newtype State i j a = State (i -> (a, j))
12:25:16 <johnw> oh, I see
12:25:19 <edwardk> then i can let the type of my state change between steps
12:25:25 <johnw> it is indexed on the state type
12:25:31 <johnw> that's pretty good
12:25:37 <edwardk> newtype Store i j a = Store (j -> a) i
12:25:47 <johnw> some days, I can actually sound like I understand this stuff
12:26:43 <johnw> newtype Writer i j a = Writer [j] a
12:26:49 <johnw> oops
12:26:51 <edwardk> not quite.
12:27:04 <johnw> guess it needs both types on the right to be indexable
12:27:08 <edwardk> newtype Writer k i j a = Writer (k i j, a)
12:27:14 <johnw> ah
12:27:19 <donri> so do you still need rebindable syntax for this new encoding?
12:27:22 <edwardk> now instead of parameterizing on a monad, you pick a category
12:27:23 <johnw> sure, it need a function to provide the morphism
12:27:28 <Cale> monoid*
12:27:40 <edwardk> er yeah instead of parameterizing on a monoid ;)
12:28:03 <johnw> I feel like I'm in the set of moronoids
12:28:14 <edwardk> so Writer (->) i j a   is Writer (i -> j) a
12:28:24 <edwardk> you have a function and a value
12:28:32 <edwardk> and you are composing functions as you >>=
12:28:45 <edwardk> now the one parameter version is slightly different
12:28:49 <edwardk> we instead make up something like
12:28:58 <edwardk> type f ~ g = forall a. f a -> g a
12:29:11 <edwardk> and then we just repeat the definitions for monad, etc. using ~>
12:29:12 <edwardk> er
12:29:19 <edwardk> type f ~> g = forall a. f a -> g a
12:29:52 <edwardk> class IMonad m where ireturn :: a ~> m a; ibind :: (a ~> m b) -> (m a ~> m b)
12:30:00 <edwardk> notice the ~>'s
12:30:18 <edwardk> then you get things like
12:30:32 <edwardk> data Store s a i = Store (s ~> a) (s i)
12:30:41 <edwardk> which all occurs 'one level up'
12:30:56 <johnw> you're losing me now
12:31:10 <Twisol> sometimes I wonder if it would be easier to explain this stuff on a virtual whiteboard
12:33:02 <johnw> ~> means, this is a function type where you give me one value-in-context, and I give you another value-in-context?
12:33:05 <edwardk> johnw: well, this version of things is trickier than the 2-parameter version. the 2-parameter version is sort of obvious, but a lot of manual plumbing
12:33:12 <Cale> I've often thought that it would be nice to have an almost Mathematica-style IRC, if that makes sense, with miniature whiteboards interspersed with lines of text.
12:33:22 <edwardk> listToMaybe :: [] ~> Maybe
12:33:31 <johnw> Cale: that sounds amazing, actually
12:33:43 <edwardk> that takes forall a. [a] -> Maybe a
12:33:48 * hackagebot rpc-framework 2.0.0.0 - a remote procedure call framework  http://hackage.haskell.org/package/rpc-framework-2.0.0.0 (MatthewMirman)
12:33:53 <johnw> edwardk: gotcha
12:33:54 <edwardk> > Data.Maybe.listToMaybe [1,2,3]
12:33:55 <lambdabot>   Just 1
12:34:14 <johnw> > Data.Maybe.listToMaybe []
12:34:15 <lambdabot>   Nothing
12:34:15 <edwardk> ~> is a 'natural transformation'
12:34:33 <johnw> @hoogle [a] -> Maybe [a]
12:34:34 <lambdabot> Prelude cycle :: [a] -> [a]
12:34:34 <lambdabot> Data.List cycle :: [a] -> [a]
12:34:34 <lambdabot> Prelude init :: [a] -> [a]
12:34:35 <donri> edwardk: maybe would be better to use & for Cat over % for sake of Ratio?
12:34:37 <edwardk> so instead of return being a function, we have natural transformations instead.
12:34:51 <luite> Cale: have people run a ghclive session next to their irc window :)
12:34:53 <edwardk> donri: & i need elsewhere for product
12:34:58 <donri> aye
12:35:06 <edwardk> because i have two forms of product
12:35:14 <edwardk> for sequential and parallel indexing product
12:38:50 * hackagebot rpc-framework 2.0.0.1 - a remote procedure call framework  http://hackage.haskell.org/package/rpc-framework-2.0.0.1 (MatthewMirman)
12:38:52 * hackagebot rpc-framework 2.0.0.2 - a remote procedure call framework  http://hackage.haskell.org/package/rpc-framework-2.0.0.2 (MatthewMirman)
12:43:01 <johnw> ok, I have C-h C-i in haskell mode (the binding for "show docs for symbol") now doing the following: if the symbol is known, take me to the Haddock docs; otherwise, see if it's the name of a module and take me to those Haddock docs; otherwise, query for it in my local Hoogle, starting the local server if necessary
12:44:46 <zzzzzbogus> hi! Are there any reasons why class Monoid m => CommutativeMonoid m is not there on Hackage?
12:45:21 <maukd> zzzzzbogus: what's it good for?
12:47:03 <zzzzzbogus> I have a function which breaks if called with a non-commutative monoid. So I want to point that to library users using types. It's similar in spirit to type Amount = Float
12:48:04 <benmachine> zzzzzbogus: that's not really that common a use case; it's fine but I'm not surprised it's not widespread
12:49:19 <roconnor> is a . ⊥ = ⊥ in CPOs?
12:49:20 <zzzzzbogus> yeah I encountered it when I attempted to design a Bag which doesn't expose internal element order to clients
12:49:33 <Twisol> What does "Illegal polymorphic or qualified type" mean? I have this type: (TelnetActor m) => ByteString -> m r -> (m r, TResult)
12:49:37 <roconnor> where . is function compositon
12:49:44 <johnw> what is CPOs?
12:49:51 <roconnor> johnw: complete partial orders
12:49:55 <johnw> ah
12:50:08 <edwardk> zzzzzbogus: there are commutative monoids in my algebra package, but its pretty invasively hard to use ;)
12:50:14 <hiptobecubic> Can someone tell me why this passes all tests?   quickCheck ((\x y -> isPrefixOf x y == isInfixOf x y) ::  String -> String -> Bool)
12:50:24 <roconnor> er nevermind
12:50:39 <roconnor> I actually want to consier ⊥ . a
12:50:44 <zzzzzbogus> edwardk: on hackage? what is the name?
12:50:50 <roconnor> which is more clearly equal to  ⊥
12:50:58 <edwardk> zzzzzbogus: another option to avoid exposing ordering, is to require the end user to give you an ordering, or a random number generator to extract elements
12:50:59 <maukd> hiptobecubic: because almost all random strings aren't infixes of each other
12:51:03 <edwardk> zzzzzbogus: 'algebra'
12:51:16 <edwardk> zzzzzbogus: i am fairly unimaginative when it comes to naming
12:51:25 <hiptobecubic> maukd, ah ok. so it's coincidence
12:51:28 <maukd> @check (\x y -> isPrefixOf x y == isInfixOf x y) :: String -> String -> Bool
12:51:29 <lambdabot>   Couldn't match expected type `GHC.Base.String
12:51:54 <maukd> @check (\x y -> isPrefixOf x y == isInfixOf x (y :: String))
12:51:55 <edwardk> zzzzzbogus: look at 'Commutative' and 'Abelian'  for multiplicative and additive commutative monoids respectively
12:51:55 <lambdabot>   "OK, passed 500 tests."
12:52:47 <hiptobecubic> so it's not testing things like   x = "b"  y = "ab"
12:52:55 <zzzzzbogus> edwardk: both these methods involve extra computations, not every object can be reasonably ordered (e.g. functions), and finally I need my Bag to be polymorphic as it's a special kind of non-determinism monad :)
12:53:03 <johnw> if x starts y, then x is in y
12:53:10 <johnw> that's what you're testing
12:53:12 <hiptobecubic> because it seems like in 500 tests, you might want to try something small like that.
12:53:38 <edwardk> zzzzzbogus: the random number supply approach works fine with polymorphic bags containing functions
12:53:56 <edwardk> zzzzzbogus: its just responsible for shuffling them as it emits them
12:54:23 <edwardk> and notably the same approach works when you go to extract from a cycle, etc. or other combinatorial species
12:55:06 <hiptobecubic> johnw, but if x is in y, it doesn't necessarily start y. there should be cases where prefix fails, infix doesn't, so == fails and the test fails.
12:55:48 <johnw> oh, I see
12:56:01 <maukd> @check (\x y -> isPrefixOf x (y ++ x) == isInfixOf x (y ++ (x ::String)))
12:56:03 <lambdabot>   "Falsifiable, after 1 tests:\n\"\\185776\"\n\"\\867278\\187030\"\n"
12:56:31 <johnw> @pl (\x y -> f x y == g x y)
12:56:31 <lambdabot> ap (ap . ((==) .) . f) g
12:57:18 <maukd> @pl curry (\z -> uncurry f z == uncurry g z)
12:57:18 <lambdabot> curry (ap ((==) . uncurry f) (uncurry g))
12:57:37 <johnw> :t curry
12:57:38 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:57:46 <hiptobecubic> maukd, what's going on there? You're appending just to ensure that isInfixOf will succeed?
12:58:13 <maukd> :t curry (liftA2 (==) (uncurry ?f) (uncurry ?g))
12:58:14 <lambdabot> forall a b c. (Eq c, ?f::a -> b -> c, ?g::a -> b -> c) => a -> b -> Bool
12:58:50 <hiptobecubic> :t ?f
12:58:51 <lambdabot> forall t. (?f::t) => t
12:58:52 <zzzzzbogus> edwardk: the problem is that I need bags having same elements but in different order to be indistinguishable without using unsafe methods. Hiding the order by only allowing folding with commutative monoids seemed a good solution to me.
12:59:03 <hiptobecubic> What is ?f  ?
12:59:18 <maukd> :t curry (on (liftA2 (==)) uncurry ?f ?g)
12:59:19 <lambdabot> forall a a1 b. (Eq a, ?f::a1 -> b -> a, ?g::a1 -> b -> a) => a1 -> b -> Bool
12:59:29 <johnw> ah, golfing in #haskell...
12:59:33 <maukd> curry on, my wayward son
12:59:34 <nand`> luite: constructors and case..of implemented now :)  http://bpaste.net/show/43961/
13:00:09 <johnw> > (==) `on` f $ a
13:00:10 <lambdabot>   Precedence parsing error
13:00:10 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
13:00:23 <johnw> > on (==) f $ a
13:00:24 <lambdabot>   Ambiguous type variable `b' in the constraints:
13:00:24 <lambdabot>    `SimpleReflect.FromExpr ...
13:00:34 <johnw> > on (==) ?f $ a
13:00:36 <lambdabot>   Overlapping instances for GHC.Show.Show
13:00:36 <lambdabot>                              (Simpl...
13:00:43 <Eduard_Munteanu> hiptobecubic: implicit parameters
13:01:01 <luite> nand`: ah
13:01:03 <edwardk> zzzzzbogus: i'm not saying not to also support the commutative monoid reduction, just saying that its useful to also support random element order extraction and ordered extraction, both of which form commutative monoids in their own right
13:01:10 <Twisol> Why does ghci tell me that this is an illegal type? (TelnetActor m) => ByteString -> m r -> (m r, TResult)
13:01:23 <edwardk> (though its much faster to implement them directly)
13:01:31 <edwardk> gotta go
13:01:34 <luite> nand`: i already have those, but still need to do pap
13:01:52 <luite> and i think some of my argument handling is wonky
13:02:06 <luite> ghc requires void arguments and i have some argument types that don't fit in a javascript var
13:02:13 <Eduard_Munteanu> Twisol: what dpes it say exactly?
13:02:21 <Twisol_> sorry, DC'd right after I sent that
13:02:39 <Eduard_Munteanu> Twisol_: ^^
13:02:43 <JuanDaugherty> you didn't miss anything
13:02:55 <hpaste> Twisol pasted “Type error” at http://hpaste.org/74304
13:03:11 <zzzzzbogus> edwardk: and I cannot have Eq => or Ord => because the Bag must be a monad.. It's actually a problem of Levels monad from implementation of level-monad library, I'm looking if there are viable alternatives to violation of monad laws
13:03:50 <Twisol_> Eduard_Munteanu: pasted
13:03:59 <maukd> Twisol: what's line 57?
13:04:28 <hpaste> Twisol annotated “Type error” with “Type error (annotation)” at http://hpaste.org/74304#a74305
13:04:50 <Eduard_Munteanu> 'In the definition of data constructor `More'" - hm?
13:05:07 <maukd> Twisol: m is not in scope
13:05:07 <Twisol> grabbed the wrong line :/
13:05:16 <Eduard_Munteanu> Twisol: right, makes sense now
13:05:21 <c_wraith> Do you need an extension beyond MagicHash to pattern-match against unboxed tuples?
13:05:41 <Tom____> Hello! :)
13:05:43 <Twisol> maukd: so what effect does the `(TelnetActor m) =>` bit have? :/
13:05:53 <Tom____> nospace [3 + 4^ 2] = [3+4^2]  >nospace [] = [] >nospace (space:rest) >		| (space == " ") 	= "" ++ nospace:rest >		| otherwise		= space : nospace rest
13:05:58 <maukd> Twisol: it puts a constraint on m
13:05:59 <Eduard_Munteanu> Twisol: it's a rank-2 type, you get an implicit forall there
13:06:05 <maukd> Twisol: the problem is, there is no m
13:06:23 <Tom____> can anyone help me
13:06:56 <Tom____> f
13:07:06 <Eduard_Munteanu> Tom____: use a pastebin and explain the problem
13:07:14 <maukd> Tom____: with what?
13:07:17 <Tom____> ok
13:07:20 <Eduard_Munteanu> And don't use tabs :)
13:07:30 <Twisol> maukd: there's an "m Bool" present in the type signature; what do you mean there's no m?
13:07:47 <maukd> Twisol: the variable m is not defined anywhere
13:07:50 <edwardk> zzzzzbogus: building with the monad works fine. i'm talking about the extraction operation
13:07:58 <Eduard_Munteanu> Twisol: it's not an argument to the type constructor
13:08:08 <Tom____> http://pastebin.com/EgTXbakP
13:08:19 <edwardk> zzzzzbogus: i mean you can implement a Bag with newtype Bag a = Bag [a] -- just by not exporting the constructor.
13:08:31 <Twisol> How does my situation differ from this? (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:08:33 <Tom____> I wanna make a list with no spaces if the user types spaces
13:08:51 <Twisol> Oh wait I see
13:09:06 <Eduard_Munteanu> Twisol: think about More's type
13:09:07 <maukd> Twisol: that never happened
13:09:26 <Twisol> maukd: ?
13:09:36 <maukd> Twisol: that line isn't real code
13:09:47 <edwardk> that is equivalent to any newtype Bag a = Bag (forall r. CommutativeMonoid r => (a -> r) -> r) --like definition you can come up with
13:10:09 <Twisol> maukd: I typed :t (>>=) into ghci and it gave me that type signature for (>>=). Anyways I see the problem now.
13:10:37 <maukd> Twisol: ok?
13:10:39 <Tom____> whois Tom_____
13:10:44 <Eduard_Munteanu> Twisol: do you understand why that's a rank 2 type?
13:10:52 <Twisol> Eduard_Munteanu: That part, no
13:11:19 <edwardk> by not exporting the constructor, you can safely implement your commutativeFold, etc. and know nobody can depend on the ordering except by lying to you about commutativity
13:11:20 <zzzzzbogus> edwardk: I wanted to hide the constructor and expose reduce :: CommutativeMonoid m => (a -> m) -> Bar a -> m
13:11:20 <Tom____> http://pastebin.com/EgTXbakP
13:11:27 <Eduard_Munteanu> Twisol: data TResult = More ((TelnetActor m) => ByteString -> m Bool -> (m Bool, TResult)) |  Upgrade ByteString
13:11:31 <Eduard_Munteanu> Oops.
13:11:45 <edwardk> zzzzzbogus: i get that. =)
13:11:56 <Eduard_Munteanu> Twisol: what if I write it as... data TResult = More (forall m. (TelnetActor m) => ByteString -> m Bool -> (m Bool, TResult)) |  Upgrade ByteString
13:12:37 <Twisol> Eduard_Munteanu: I don't know what a rank 2 type is. ~_^ I guess I'm leaving a hole in the type definition, so that makes it invalid.
13:12:54 <Eduard_Munteanu> No, it's a valid type if you enable Rank2Types.
13:12:59 <edwardk> zzzzzbogus: I've implemented this type before. I was just mentioning a couple of additional operations you might consider offering because they are a PITA to implement through the commutative-monoid-only api ;)
13:13:15 <maukd> Twisol: you need to decide whether it's a universal or an existential type, though
13:13:33 <Eduard_Munteanu> maukd: here it's not an existential
13:13:43 <Tom____> I would appreciated if someone see my no space funtion at http://pastebin.com/EgTXbakP
13:13:44 <maukd> well, then
13:13:47 <Twisol> no no, this makes sense - parameterizing TResult over m clarifies things
13:14:00 <henk> Hi, I’m trying to figure out a problem with gpg. I suspect the problem is with gpgme somewhere, so I’m trying to test that somehow. As I find almost no software using it (apart from what I already try to use anyway) I thought I’d try with haskell. I’m rather new to haskell though. How do I use the gpgme bindings in ghci? I have the file
13:14:01 <maukd> Tom____: sorry, I'm not going to visit pastebin.com
13:14:03 <henk> /usr/lib/haskell-packages/ghc/lib/bindings-gpgme-0.1.4/ghc-7.4.1/Bindings/Gpgme.hi which I guess I need to load somehow, correct?
13:14:13 <Tom____> why not maukd?
13:14:14 <zzzzzbogus> edwardk: your algebra-3.0 seems to miss the docs. No wonder I couldn't find it myself :) BTW the problem in question is http://spivey.oriel.ox.ac.uk/mike/search-jfp.pdf , it says "it is necessary to use streams of bags, ignoring the order of elements in each layer, if the composition operator >>= is to obey the associative law"
13:14:15 <Eduard_Munteanu> Heh, maukd
13:14:25 <Twisol> since I want to be able to supply any TelnetActor that implements a certain set of actions, the monad being used better be explicitly noted
13:14:37 <Eduard_Munteanu> Tom____: hpaste is probably a better option
13:14:40 <Eduard_Munteanu> @where hpaste
13:14:40 <lambdabot> http://hpaste.org/
13:14:41 <edwardk> random selection can be implemented via an implicit slowdown of a perfect shuffle
13:14:46 <maukd> Tom____: it is against my religion
13:15:14 <Tom____> Ah ok i wanna know why not pastebin?
13:15:26 <edwardk> zzzzzbogus: grab the docs from http://hackage.haskell.org/package/algebra-2.1.1.2 the 3.0 package was pushed out of order with one of its deps and haddocks didn't build
13:15:32 <Tom____> Did they something wrong ?
13:15:36 <maukd> ads, ugly, fucks with your paste
13:15:38 <lispy> henk: usually you would load a .hs or .lhs file.
13:16:04 <hpaste> Tom pasted “nospace” at http://hpaste.org/74307
13:16:08 <lispy> henk: .hi files are interface files output by the compiler so that it has enough information to use already compiled modules when it's compiling other modules
13:16:16 <edwardk> gotta run
13:16:42 <lispy> henk: Normally you can do: ghci foo.hs
13:17:15 <lispy> henk: but...if the bindings have dependencies you probably need all the configuration information in the cabal file...
13:17:19 <sfogarty> I'm using HUnit, and trying to hPutStr stderr strings before each runTestTT, but they do not come out unless I end them with a '\\n'. hFlush does not seem to help.
13:17:28 <maukd> Tom____: I see 2 errors
13:17:32 <henk> lispy: oh, ok, thank you. I seem to have misunderstood something then …
13:17:39 <Tom____> Which ones maukd?
13:17:46 <Twisol> Eduard_Munteanu: It's still failing, unfortunately. :/ http://hpaste.org/74308
13:17:54 <lispy> henk: but if you already installed it with something like, 'cabal install gpgme' then you should be able to type "import Foo" inside ghci
13:18:00 <maukd> Tom____: probably the same ones your compiler sees
13:18:21 <lispy> henk: probably something like import Bindings.Gpgme in this case
13:18:24 <Tom____> ok...
13:18:43 <maukd> Twisol: you can't put a class constraint there
13:19:07 <maukd> Tom____: did you have a specific question or something?
13:20:48 <henk> lispy: TBH I have no idea what cabal is, I simply installed everything aptitude search ~dhaskell~dgpg showed me ;) I just tried 'import Bindings.Gpgme' and ghci responded with '*** Parser:'. I have no idea what it tries to tell me … Thanks for your help :)
13:20:59 <zzzzzbogus> edwardk: ha! you separated Commutative into a separate typeclass. I though about that as an option. Is it the multitude of classes only thing that makes usage hard?
13:21:45 <Eduard_Munteanu> Twisol: could you explain what TResult is / how it's supposed to work?
13:21:57 <merijn> henk: cabal is a package/dependency manager for haskell packages
13:22:04 <lispy> henk: hmm...You might need ghci -package <PackageName> first
13:22:06 <Eduard_Munteanu> Also, what mauke said.
13:22:22 <lispy> henk: but I wouldn't expect a parse error if you're just missing the -package bit
13:22:36 <lispy> henk: if you want to put the parse error at hpaste.org maybe we can help more?
13:23:21 <Twisol> Eduard_Munteanu: I'm writing a Telnet library. Given a chunk of text, the library will execute actions on a monad implementing the TelnetActor typeclass, and return the state of the parser at the end of the chunk along with the monad.
13:24:13 <Tom____> maukd i got only one error
13:24:27 <maukd> ok
13:24:36 <maukd> so ... fix it?
13:25:02 <Tom____> yeah i make it
13:25:07 <henk> lispy: oh, I overlooked the ghci prompt is saying 'Prelude Bindings.Gpgme> ' now and what I said the parser responded with was actually everything it responded with. No error message. So I guess it loaded okay. <TAB> also shows all the functions the docs mention. I’ll see how far I get from here, thank you very much for your time :)
13:25:13 <henk> merijn: Thanks to you too :)
13:25:15 <Eduard_Munteanu> Twisol: why do you need that constraint there? Can't you just say   ByteString -> m r -> (m r, TResult m r)?
13:25:26 <Tom____> maukd you said 2 errors
13:25:31 <Tom____> i got only one
13:26:09 <Twisol> Eduard_Munteanu: I don't know. :) I'm relatively new to Haskell. I put that there because I thought that's what I needed to ensure what I wanted.
13:26:09 <maukd> I see
13:26:33 <lispy> henk: cool!
13:26:42 <nexx> can someone give me an ip for a good DNS server? Mine seems to be down.
13:26:51 <lispy> ?faq can Haskell rock the gpg?
13:26:51 <lambdabot> The answer is: Yes! Haskell can do that.
13:27:01 <tdammers> 8.8.8.8 / 8.8.4.4 google DNS
13:27:10 <lispy> nexx: does 4.4.4.4 work?
13:27:10 <tdammers> unless you have privacy issues
13:27:51 <Eduard_Munteanu> If you're on Linux it's pretty easy to run your own.
13:27:57 <maukd> 4.2.2.1 IIRC?
13:28:00 <Ferdirand> nexx: run your own recursive resolver. You need it for dnssec anyway
13:28:24 * nand` has net-dns/bind-9.9.1_p2-r2 running locally
13:28:36 <hpaste> Tom pasted “nospace” at http://hpaste.org/74311
13:28:54 * roconnor routes all his packets with ! paths
13:29:56 <maukd> Tom____: nospace : rest
13:30:05 <maukd> rest is a string
13:30:08 <maukd> nospace is a function
13:30:15 <maukd> you're trying to cons a function onto a string
13:30:27 <maukd> that's an error. you can only cons chars
13:30:34 <maukd> (that's what the error message means, btw)
13:30:36 <Tom____> ok
13:30:53 <Tom____> Did you understand what i want with this function?
13:31:05 <maukd> yes, remove all spaces from an input string
13:31:10 <Tom____> Right
13:31:16 <timthelion> Num has + - * `div`...  Is there a typeclass for types that only have + and - ?
13:32:05 <Tom____> So can you give me a tip ?
13:32:24 <timthelion> Tom____: use filter
13:32:33 <Cale> I agree, use filter :)
13:32:56 <maukd> Tom____: er. do you understand anything of what you're doing?
13:33:18 <maukd> this looks like homework, and you're just sitting there waiting to be spoonfed
13:33:28 <Tom____> No
13:33:41 <Tom____> Just a moment i correct the mistakes
13:33:45 <c_wraith> exciting warnings from GHC: "Warning: Bindings containing unlifted types should use an outermost bang pattern:"
13:35:04 <johnw> :t listToMaybeAll
13:35:04 <lambdabot> Not in scope: `listToMaybeAll'
13:35:18 <nexx> 4.4.4.4 and 4.2.2.1 didn't worked. Google does. thanks @all
13:36:19 <nexx> Eduard_Munteanu Ferdirand had a BSD with my own, but I have to repair the hardware
13:37:55 <c_wraith> johnw: what type signature are you looking for?
13:38:20 <hpaste> Tom pasted “nospace” at http://hpaste.org/74312
13:38:36 <Tom____> So corrected and i test it now
13:39:30 <Tom____> no errors
13:40:22 <Twisol> maukd, Eduard_Munteanu: Thanks, the code is working now. It's horrific, but it works.
13:41:44 <hpaste> Tom pasted “no space” at http://hpaste.org/74313
13:43:14 <Cale> Tom____: btw, "" ++ xs = xs
13:43:24 <Cale> Tom____: so you don't have to write that
13:43:32 <Tom____> ok
13:43:40 <sHACHAF> You probably want to take the (sp:) off, though.
13:43:40 <Tom____> i am a little desperated now
13:44:07 * sHACHAF looks back -- is this homework or something?
13:45:55 <Tom____> Why do you ask if homework or not
13:46:28 <timthelion> Tom____: it seems silly to do someone's homework for them.  Homework is to teach YOU, not us.  We already know how to filter a string :)
13:46:40 <Tom____> I didnt ask please write a function for me. I make it in my own but I am not good at it
13:46:54 <maukd> Tom____: do you know any other programming language?
13:46:54 <Tom____> So i need help
13:47:13 <Tom____> does it matter maukd?
13:47:16 <maukd> yes
13:47:19 <maukd> that's why I asked
13:47:35 <Tom____> and if i write no?
13:47:47 <maukd> wat
13:47:52 <Twisol> no need to be defensive :)
13:48:04 <maukd> this is getting too tedious
13:48:21 <Tom____> -.-
13:48:22 <maukd> you're unwilling to provide information or think for yourself
13:48:40 <maukd> where's the fun in that
13:49:10 <Tom____> It is so hard to ask someone for help?
13:49:36 <Cale> Tom____: You misunderstand, they just want to be careful that if it's a homework assignment not to spoil the answer.
13:49:49 <merijn> maukd: Unfortunately autodidactism (is that even a word? xD) can't be taught >.>
13:49:56 <Cale> Tom____: One important distinction you seem to be missing is that Char and String are two different things, and you need separate notation for them.
13:50:10 <Tom____> Ok
13:50:13 <Cale> If you want the character for a space, you write ' '
13:50:30 <Tom____> I know what strings are but not chars
13:50:32 <Cale> " " is a string with one character which is a space, which is syntax sugar for ' ' : []
13:50:48 <timthelion> Cale++
13:50:54 <maukd> Tom____: apparently
13:51:02 <Cale> When you write "hello", it really means  'h' : ('e' : ('l' : ('l' : ('o' : []))))
13:51:11 <maukd> Tom____: note that "help me" is not a question
13:51:22 * timthelion thinks Cale would be a good daddy/mommy if they aren't one already.
13:51:27 <Tom____> Ok Cale
13:52:27 <Eduard_Munteanu> timthelion: maybe we should have a adopt-a-newb program here :D
13:52:53 <Tom____> Cale
13:52:56 <Cale> Tom____: Char values are the single characters, and strings are lists of them
13:53:20 <Cale> Tom____: You can more generally test if a character is whitespace using the isSpace function from Data.Char
13:53:41 <johnw> Cale: are you still the guy to ask about running Lambdabot?
13:53:42 <Twisol> Eduard_Munteanu: I'd sign up for that!
13:53:51 <Tom____> I see it
13:54:02 <Cale> johnw: I run lambdabot myself, but I don't maintain the code for it.
13:54:09 <johnw> ah
13:54:12 <Cale> johnw: I just run the lambdabot instance in this channel.
13:54:22 <johnw> I'm trying to debug when I never get a prompt from -e offline
13:54:25 <Cale> (and various other channels on freenode)
13:54:26 <johnw> s/when/why
13:54:40 <Cale> I've never really used the offline mode
13:54:56 <johnw> i'm finding reading the code a bit impenetrable
13:55:08 <sHACHAF> Write a replacement.
13:55:12 <johnw> like, there is an initDoneMVar, but no reference to it anywhere
13:55:16 <Cale> yeah, we need a new lambdabot :P
13:55:23 <Cale> (and a maintainer!)
13:55:26 <timthelion> johnw: and isn't it easier to host an IRC server on localhost?
13:55:27 <johnw> sorry, my plate is a little overfull already
13:55:28 <Clint> base it on simpleirc or something
13:55:45 <johnw> timthelion: yes, but harder to integrate with haskell-mode the way I want to
13:55:50 <sHACHAF> johnw: Fix your editor's search.
13:56:01 <sHACHAF> johnw: What do you want lambdabot integrated with haskell-mode for?
13:56:04 <timthelion> johnw: ?  Why not just use hint or something for that?
13:56:35 <merijn> timthelion: I guess you mean hlint?
13:56:44 <sHACHAF> There are exactly two references to initDoneMVar: One to create it and one to put it in a record.
13:56:46 <johnw> I want to have two interactive REPLs going: ghci, with all the modules of my current project loaded; and lambdabot, who is kind of a universal question/answer session
13:56:50 <nexx> maybe 4.4.4.4 and 4.2.2.1 work, but my provider seems unable to reach most of the internet at the moment
13:57:01 <johnw> I can ask it @pl and other questions and get back responses, without needing to load extra stuff into my ghci
13:57:11 <maukd> GOA?
13:57:23 <johnw> shachaf: I can't figure out how it gets set, or what it accomplishes
13:57:24 <sHACHAF> johnw: @pl exists on its own.
13:57:31 <johnw> shachaf: I know that, and I currently use it
13:57:32 <sHACHAF> So does Hoogle.
13:57:33 <Cale> johnw: I usually just go to my IRC client if I have something to ask @pl :)
13:57:37 <timthelion> merijn: No, I mean hint.  Haskell Interactive.  It's like lambdabot.  Here's an example http://pnyf.inf.elte.hu/fp/Economic_en.xml
13:57:40 <johnw> but I'd rather have a tidy little lambdabot, thank you
13:57:50 <johnw> Cale: I'm very often offline
13:57:51 <sHACHAF> johnw: Are we looking at different code? It gets set at the "initDoneMVar <- io newEmptyMVar".
13:58:03 <johnw> shachaf: and then what happens?
13:58:14 <sHACHAF> And then it gets put into the record.
13:58:22 <Tom____> Cale could you describe me how isSpace exactly works?
13:58:24 <johnw> yeah, like I said, impenetrable
13:58:35 <johnw> I can't figure out how it actually starts *doing* anything
13:58:39 <sHACHAF> johnw: Huh?
13:58:58 <johnw> I see this, as the body of the mainLoop:
13:58:59 <sHACHAF> initDoneMVar is a lexical variable, man.
13:59:00 <johnw> do asks ircInitDoneMVar >>= io . flip putMVar ()
13:59:00 <johnw>            asks ircQuitMVar >>= io . takeMVar
13:59:00 <johnw>            fail "don't write to the quitMVar!"
13:59:12 <timthelion> :t isSpace
13:59:13 <Cale> Tom____: isSpace c is True when c is a whitespace character like ' ', or '\n' (newline), or '\t' (tab), and a handful of others and False otherwise.
13:59:13 <lambdabot> Char -> Bool
13:59:17 <sHACHAF> Oh. That's not even the same variable name.
13:59:20 <johnw> so, um, yeah, what the heck is that all doing that accomplishes something?
13:59:42 <Tom____> thx
13:59:47 <johnw> it very well might be my lack of experience with event-driven Haskell code in a monad
13:59:53 <timthelion> Tom____: is space takes one character, and returns True if it is a white space(like Cale says) and False if it is not.
14:00:02 <Cale> > filter isSpace ['\0'..]
14:00:03 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
14:00:12 <Cale> ^^ a list of the whitespace characters :)
14:00:45 <timthelion> > filter isSpace ['.'..]
14:00:47 <lambdabot>   "\160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201\8202\8239...
14:00:56 <johnw> shachaf: so, what I'm trying to figure out right now is why replLoop in OfflineRC.hs is never being evaluated
14:01:09 <johnw> but I can't connect the dots between mainLoop and the code in that file
14:01:34 <Cale> Tom____: by using filter and negating the result of isSpace, we can pick out characters which aren't whitespace
14:01:35 <johnw> because it's not imperative, it's hard for me to tell what's going on
14:01:36 * timthelion wonders why lambdabot's show is converting from Unicode to unicode ascii sequences...  Remembers that IRC "technically" isn't unicode.
14:01:53 <hpc> timthelion: it's the show instance for strings
14:01:58 <Cale> > filter (not . isSpace) "hello, world!    there's       a  bunch \t \v of spaces here."
14:02:00 <lambdabot>   "hello,world!there'sabunchofspaceshere."
14:02:28 <hpc> > text "∀x. ∃y. x × y ≠ ∅" -- unicode
14:02:28 <Tom____> My desire is to program a derivation
14:02:29 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
14:02:35 <hpc> oh, there's that too
14:02:49 <johnw> I wonder if it's the use of readline that's bugging...
14:02:58 <Tom____> And my first thought was to kill these whitespaces
14:03:15 <sHACHAF> johnw: Oh, well, you can stick some prints in it to see where it's stopping...
14:03:23 <johnw> yeah, doing that now
14:03:33 <sHACHAF> This code is a bit of a mess but we already knew that about lambdabot.
14:03:58 <sHACHAF> The initDoneMVar thing looks OK to me. It does readMVar on it, which is like take + put
14:05:11 <johnw> shachaf: thanks for looking
14:05:41 <sHACHAF> johnw: You can expect any plugin which isn't actively being used in Freenode-lambdabot to be completely broken.
14:05:58 <johnw> when I load Lambabot.hs in ghci, I get this: https://gist.github.com/3644748
14:06:07 <johnw> even though there is an instance MonadError for it
14:06:08 <johnw> why would that be?
14:06:43 <sHACHAF> Maybe it's a versions-of-mtl conflict thing?
14:06:48 <sHACHAF> Cale: If someone writes a lambdabot replacement which is mostly backwards-compatible, will you run it?
14:06:53 <johnw> yeah, very likely
14:07:04 <johnw> i'd be happy to run lambdabot, fwiw
14:07:38 <sHACHAF> The question isn't about running it so much as having it "approved".
14:07:54 <lispy> sHACHAF: I don't see why not, but I have to be honest I never understood the most recent redesign for lambdabot
14:08:07 <sHACHAF> lispy: "the most recent" being in 2007 or so, right?
14:08:23 <sHACHAF> It's such a mess. :-(
14:08:25 <lispy> sHACHAF: For me the most important thing is that it be reasonably trustworthy to run it
14:08:36 <lispy> it's on my server afterall
14:08:47 <sHACHAF> Ooh, let's combine a lambdabot-writing contest with an underhanded code contest!
14:08:53 <timthelion> lispy: are you aware of http://pnyf.inf.elte.hu/fp/Economic_en.xml
14:09:09 <lispy> timthelion: probably not. Loading it now
14:09:19 <sHACHAF> There are plenty of prepackaged tools for doing the actual Haskell evaluation.
14:09:25 <sHACHAF> I don't think we need to mess with that.
14:09:26 <lispy> timthelion: I don't admin lambdabot, Cale does that, FWIW
14:09:28 <timthelion> lispy: try to beg the code out of that guy.  I want his code too!
14:10:31 <lispy> timthelion: heh. I think current lambdabot does use hint
14:10:33 <johnw> shachaf: how come ghci is having mtl problems, but cabal build isn't?  the .cabal file for lambdabot is specifying mtl>2, and I'm using mtl-2.1
14:10:46 <lispy> But the thesis is that hint is slow and s/he made it efficient?
14:10:52 <sHACHAF> johnw: ghc-pkg list mtl
14:11:07 <johnw> I have 1.1.1.1, 2.1 and 2.1.2
14:11:17 <lispy> johnw: You probably wouldn't run into this if you used cabal-dev instead.
14:11:20 <Cale> sHACHAF: sure, why not?
14:11:21 <Cale> :)
14:11:23 <sHACHAF> lispy: I think lambbdabot uses m{u,oo}eval.
14:11:31 <johnw> i still need to learn how to use cabal-dev
14:11:43 <sHACHAF> johnw: So it's probably using both of those.
14:11:47 <sHACHAF> 2.1 and 2.1.2
14:11:50 <sHACHAF> Just to be annoying.
14:11:51 <timthelion> lispy: but given that there was a question of trustworthyness, and that is a site that's been up a while without problems.  I think his/her code is trustworthy.
14:11:52 <lispy> sHACHAF: mueval and hint are mutually exclusive?
14:12:04 <Cale> sHACHAF: Well, provided it's more reliable, but that's likely to be the case.
14:12:14 <johnw> ok, I changed the use of readline in lambbdabot to putStr/readLn, but didn't help, so adding traces further up...
14:12:16 <Cale> mueval uses hint
14:12:20 <daniel_-> whats it called when you do automatic unpacking of a data types accessors in a function?
14:12:24 <sHACHAF> lispy: Oh, yes.
14:12:38 <sHACHAF> daniel_-: RecordWildCards?
14:12:43 <johnw> only a few things are using 2.1.2
14:12:48 <lispy> timthelion: Maybe? To be honest, that doesn't sound like a great justification for trustworthiness.
14:12:49 <daniel_-> ye, i forgot how to do it
14:13:19 <johnw> hmm.. HTTP is using mtl 1.1.1.1
14:13:26 <johnw> cabal hell it is
14:13:43 <lispy> no need for cabal hell, we have cabal-dev!
14:13:58 <timthelion> or hellno, I think I'll try hellno next.
14:14:34 * timthelion does a google image search on "cabal hell"
14:14:48 <johnw> where is a good tutorial on cabal-dev?
14:15:19 <lispy> johnw: try this: http://www.reddit.com/r/haskell/comments/f3ykj/psa_use_cabaldev_to_solve_dependency_problems/
14:15:59 <johnw> is there a general tracing feature in Haskell, like "show me every function you evaluate?"
14:16:27 <johnw> lispy: thanks!
14:17:16 <timthelion> johnw: Not that I know of.  Though there could be, given how the profiler works.
14:17:36 <timthelion> johnw: Debug.Trace does a good job if you are willing to add things manually.
14:18:09 <Lutin`> Dammit lispy
14:18:20 <timthelion> johnw: and you might be able to put together a template haskell function that would put traces everywhere.
14:18:32 <Lutin`> I opened up that link to read it then once I was done started surfing reddit again
14:18:51 <Lutin`> almost forgot what I was doing
14:19:54 <timthelion> Lutin`: we really ought to have "Say no to reddit and internet news" campaigns in school.  I mean gosh, at least smoking crack cocain can get you laid.
14:21:15 <Lutin`> Seriously
14:23:55 <lispy> Lutin`: hehe
14:25:22 <lispy> some parts of reddit are great though. I often enjoy r/dependent_types, r/math, r/gamedev, and sometimes r/coding
14:25:41 <lispy> But yeah, /r/funny and the lot are just time sinks :)
14:25:42 <Lutin`> Oh don't get me wrong
14:25:55 <hpc> /r/fifthworldproblems is hysterical
14:26:02 <Lutin`> I am a hardcore redditor
14:26:15 * sHACHAF suspects this is not the channel for that.
14:27:35 * lispy goes back to debugging this antlr generated parser
14:31:09 <johnw> shachaf: as far as I can tell, it never gets past lockRC
14:31:20 <johnw> I have: lockRC >> trace "Hello" (finallyError (mapM_ feed cmds) unlockRC)
14:31:31 <johnw> if I put the trace out the lockRC call, I see it
14:31:36 <johnw> s/out/outside
14:32:07 <hpaste> daniel_- pasted “meh, rigid type variable” at http://hpaste.org/74314
14:33:07 <maukd> daniel_-: remove type signature; retry; report results
14:33:19 <daniel_-> which type signature?
14:33:28 <Lutin`> of Setup
14:33:35 <maukd> line 3
14:33:46 <Yiq> "The CAN protocol provides a hamming distance of 6, i.e. in CAN data frames five randomly spread bit-errors as well as a 15-bit burst-error are detected." Wouldnt that be 6 randomly spread bits? And how can it discover a 15-bit burst+
14:34:01 <daniel_-> lol i did not even think of that
14:34:08 <daniel_-> it worked
14:34:13 <daniel_-> thanks maukd
14:34:21 <maukd> :t setup
14:34:22 <lambdabot> Not in scope: `setup'
14:34:25 <maukd> optionally paste it in
14:34:26 <daniel_-> ye
14:35:18 <daniel_-> a question when loading something with GHCI and i want to access something that is not exported
14:35:23 <Lutin`> Well I mean
14:35:29 <daniel_-> do i have to remove all the exports or is there a special way?
14:35:30 <Lutin`> You can just replace a with CSReq
14:36:17 <daniel_-> Lutin` but it wont be a CSReq for example Minecraft :: Service
14:37:06 <Lutin`> Ohh
14:37:12 <Lutin`> Wait
14:37:18 <Lutin`> Is Service a typeclass
14:38:03 <daniel_-> data Service = CS  | Minecraft deriving (Eq, Show, Read)
14:38:31 <danil> daniel_-: what type do you intend 'body' to be?
14:38:51 * hackagebot unordered-containers 0.2.2.1 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.2.1 (JohanTibell)
14:38:53 * hackagebot pipes 2.3.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-2.3.0 (GabrielGonzalez)
14:38:53 <maukd> daniel_-: :l *foo.hs
14:39:29 <daniel_-> its supposed to be different for each service
14:39:46 <daniel_-> since each service will construct the processes with different needs of arguments etc
14:40:16 <Lutin`> Yes but
14:40:27 <Lutin`> Service should be a typeclass instead imo
14:40:56 <Lutin`> Because it seems all you want is the constraint that the input is a service
14:41:16 <daniel_-> ye
14:41:20 <Lutin`> idk I could be wrong that's just how I program
14:41:33 <daniel_-> depending on the service different things should happen
14:41:33 <startling> so what's the best way to create a lens in `lens`?
14:41:47 <Lutin`> daniel_-: Plus that way other people can create services
14:41:57 <Lutin`> You just require they implement certain functions
14:42:02 <Lutin`> Like setup for instance
14:42:14 <Lutin`> So then you can do
14:42:22 <danil> daniel_-: the type signature "setup :: Service -> a -> ..." means setup has to work with any type a that the caller chooses; the type error you were getting was because the implementation assumed a particular type (CSReq) for the second argument
14:42:33 <Lutin`> Yes
14:43:30 <startling> also wow `lens` is cool
14:43:31 <Lutin`> You can tell the compiler to make something specific, but you can't tell it to make it abstract at least without exts
14:44:41 <daniel_-> typeclass i guess will be the best choice
14:44:59 <daniel_-> just need to figure out how i will do it
14:46:39 <johnw> cabal-dev install for lambabot also fails.  Right after installing hoogle-3.1, it dies telling me that hoogle ==3.1 is missing :(
14:46:40 <danil> daniel_-: there are several ways to do what you want.  The simplet is to have a data ServiceReq = CS CSReq | ... and only pass one argument; you could also make Service a GADT (data Service r where CS :: Service CSReq; setup :: Service r -> r -> ...) or use a typeclass.
14:46:59 <startling> johnw: are you doing a lambdabot tutorial too? :)
14:47:39 <hpc> johnw: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13
14:48:03 <hpc> there's honestly no reason to not install hoogle globally
14:48:12 <hpc> except maybe if the depends mess up other stuff
14:58:16 <daniel_-> everytime i find myself rewriting parts due to finding better ways in this program it gets smaller yet can do more
15:00:01 <timthelion> How do I declare a standard instance for a newtype?  newtype Foo = Foo String (Eq) didn't work :(
15:00:28 <sHACHAF> timthelion: The same way you do it for data.
15:00:34 <timthelion> daniel_-: eventually, you'll just end up with 80 chars of symbols, that no one can read or understand.
15:00:42 <timthelion> daniel_-: but works perfectly :)
15:00:54 <timthelion> sHACHAF: so what's wrong with my syntax pray tell?
15:01:57 <danil> forgot the "deriving"
15:02:07 * timthelion hits himself over the head.
15:02:11 <daniel_-> Lutin` ehm i guess i have to go from my data Service = CS | Minecraft to using data CS = CS so i can make each a instance?
15:02:31 <Lutin`> What
15:02:32 <timthelion> danil: thanks :)
15:02:44 <Lutin`> OH
15:04:01 <Lutin`> wow
15:04:18 <Lutin`> i can't think right now brb
15:04:45 <nkpart> Is there a way to suppress warnings in GHC on a case-by-case basis?
15:05:04 <sHACHAF> nkpart: Not on a finer granularity than files, I think.
15:07:05 <daniel_-> the feel when you want to do a change but know you will break so much :/
15:07:26 <Lutin`> I like danil's suggestion then
15:08:02 <nkpart> sHACHAF: righto, thanks
15:09:13 <SLi> If I have something like data Foo = Foo { fieldA :: Something, fieldB :: Something } and a variable foo :: Foo with long lifetime, is there some way to evaluate (fieldA foo) at some point and throw the value away so that it's not stored for the entire lifetime of foo?
15:12:40 <SLi> (Or is it stored? I think it is, but I'm not sure :)
15:14:22 <Shachaf> SLi: As long as you have "foo", it'll have a reference to fieldA, so that value won't be GCed.
15:14:23 <SLi> Or, maybe in a more generic form: Is it possible to evaluate a (copy of a?) thunk somehow without replacing the thunk itself in a stored structure
15:14:28 <Shachaf> If that's what you mean.
15:14:34 <SLi> Shachaf, yes, that's what I mean.
15:15:15 <SLi> After a hours-long heap profiling session I think I finally understand why my program behaves badly, but I'm not yet sure how to fix it :)
15:19:03 <startling> SLi: you could set it to undefined
15:19:20 <SLi> Hmm, maybe I could use a weak reference.
15:19:26 <startling> or some other cheap not-useful value
15:21:52 <SLi> Though in this case I know that I'm not going to need the field again (and if I did, it would be nice to have the thunk there...)
15:32:46 <SLi> Hm, there's a recent thread on this problem in haskell-cafe: http://haskell.1045720.n5.nabble.com/A-first-glimps-on-the-NOUPDATE-pragma-td5716826.html
15:33:01 <SLi> At least I get the feeling that I'm not necessarily doing something wrong running into this problem :)
15:40:54 <hpc> that thread is so fail
15:41:11 <hpc> not in content, but everyone is either top-posting, or middle-posting
15:41:24 <hpc> very clever pragma, though
15:43:44 <Lutin`> hpc: Oh god I see what you're saying
15:44:59 <SLi> I think that pragma is not yet in GHC unfortunately. Perhaps there's no way to do that currently without rewriting the code somehow (and since the code is in a library, that will be a small pain :P)...
15:47:32 <statusfailed> Hmm, I can't figure out why my type signature won't work
15:47:36 <hpaste> statusfailed pasted “MonadState type signature” at http://hpaste.org/74319
15:49:07 <danil> statusfailed: evalState doesn't work with an arbitrary MonadState.  (Think about what would have to happen if m were StateT s IO)
15:49:36 <statusfailed> oh, evalState would have to have IO in its type sig?
15:51:16 <hpc> :t evalState
15:51:17 <lambdabot> forall s a. State s a -> s -> a
15:51:22 <statusfailed> ok well that's a problem to start with :p
15:51:23 <Peaker> statusfailed, the State funcs are probably just specializations of the StateT funcs for StateT s Identity
15:51:47 <hpc> the trick is that you don't want evalState returning Identity a when you give it State
15:52:00 <hpc> so evalState is just the "turn this into a function" function
15:52:08 <Peaker> statusfailed, and evalState/evalStateT have pretty specific types.. they can't run just any monad
15:53:30 <statusfailed> so should I just force it to be State s a? I still need to read up on monad transformers :\
15:54:10 <Peaker> statusfailed, just use the inferred type
15:56:48 <statusfailed> Peaker: alright, cheers :)
16:31:12 <Rc43> Hi, guys.
16:31:48 <Rc43> Are there any ghc extensions for `deriving` keyword with type synonyms?
16:32:01 <ivanm> Rc43: yes, but you shouldn't
16:32:09 <ivanm> no, wait, I misread
16:32:10 <ivanm> there aren't
16:32:20 <ivanm> but you can newtype it and then use GeneralizedNewtypeDeriving
16:32:28 <Rc43> I have `data A x = Constr1 a | Constr2 a` and `type B = A String`. And I want B to be (Show,Eq).
16:32:42 <ivanm> Rc43: make A an instance of Show and Eq ?
16:32:48 <baobab> Hi, I have a question regarding Haskell Exceptions. Let's assume that two exceptions are raised at the same time on a thread. Let's assume that the thread can recover from both exceptions. What is it supposed to happen? Is the thread going to receive the exceptions in FIFO order? Will the second exception interrupt the handling of the first exception?
16:33:05 <Rc43> ivanm, yes, but it is redundant code, I think
16:33:10 <ivanm> otherwise, you can create an explicit instance, and ghc[i] will tell you which extension you need, though this generally isn't recommended
16:33:14 <ivanm> Rc43: why?
16:33:52 <johnw> hpc: I can't it to connect to IRC either
16:34:00 <johnw> hpc: lambdabot is locking up during the startup process somehow
16:34:03 <Rc43> ivanm, I need to code manully the way values are showed instead of automatic generation.
16:34:11 <ivanm> Rc43: then don't use Show
16:34:19 <hpc> johnw: you have to edit a config file
16:34:24 <johnw> hpc: I did
16:34:28 <Rc43> ivanm, it isn't a problem, but seems to be unconvinient
16:34:34 <hpc> i forget the syntax; that post is very WIP, for what it's worth
16:34:35 <johnw> and then: lambdabot -e 'rc online.rc'
16:34:35 <johnw>  
16:34:38 <ivanm> the only time you should have a custom Show instance is for cases where the constructors aren't exported
16:34:45 <hpc> hmm
16:34:46 <ivanm> do _not_ use Show for pretty-printing
16:35:04 <hpc> it worked for me in a debian testing VM
16:35:24 <hpc> so for all i know, it's sensitive to the tiniest of horrible system quirks
16:37:20 <Rc43> ivanm, yes, I am talking about it, too; I needn't custom Show instance
16:37:34 <Rc43> ivanm, I want to do it automatically
16:37:41 <ivanm> Rc43: so.... why not derive it for A ?
16:38:51 <Rc43> ivanm, it has generic type
16:39:04 <Rc43> ivanm, or I can use constraints?
16:39:06 <ivanm> so?
16:39:12 <ivanm> Rc43: deriving will take care of that
16:39:25 <Rc43> ivanm, oh, I didn't know
16:39:26 <ivanm> @type \ x -> show (Just x)
16:39:27 <lambdabot> forall a. (Show a) => a -> String
16:39:38 <ivanm> ^^ e.g. how the Show instance for Maybe works
16:39:39 <ivanm> or lists
16:45:06 <hpaste> Rc43 pasted “MetaToken + Monad” at http://hpaste.org/74322
16:45:14 <Rc43> look at this snippet
16:45:17 <tomrom> what should be first steps in haskell for student with little scala knowledge ? Professionaly, I see it much more probable to work with Scala, but I see haskell more suited for learning FP concepts so I want to gain needed skills in haskell.
16:45:39 <Rc43> It is like Maybe, but with text inside.
16:45:59 <shachaf> tomrom: Probably reading an introduction to Haskell. :-)
16:46:34 <shachaf> You can try one of the supposedly "denser" introductions like the Gentle Introduction to Haskell and see if it makes sense.
16:46:37 <shachaf> @where tutorial
16:46:37 <lambdabot> http://www.haskell.org/tutorial/
16:47:04 <tomrom> what particular things you gained from learning haskell applied in professional scala development ?
16:48:11 <shachaf> I don't use Scala, I just hear rumours about it from time to time in here.
16:48:24 <shachaf> Some other people in here use it professionally.
16:48:47 <tomrom> you work with Haskell professionaly ?
16:48:54 * hackagebot unbounded-delays 0.1.0.5 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1.0.5 (BasVanDijk)
16:49:00 <shachaf> Not often. :-)
16:50:07 <Rc43> How can I implement monad transformer for my instance (http://hpaste.org/74322) such way I will be able to parse string inside Free again and get [MetaToken].
16:50:26 <lpvb> tomrom: LYAH!
16:50:29 <Rc43> I want to parse recursively [MetaToken] and flatten it.
16:50:47 <lpvb> @where lyah
16:50:47 <lambdabot> http://www.learnyouahaskell.com/
16:51:14 <lpvb> tomrom: that's a good question to ask edwardk
16:51:31 <lpvb> he uses Scala and Haskell professionally
16:52:04 <tomrom> thx for tip guys
16:52:35 <edwardk> ?
16:53:00 <lpvb> he asked, "what particular things you gained from learning haskell applied in professional scala development ?"
16:53:56 * hackagebot threads 0.5.0.1 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.5.0.1 (BasVanDijk)
16:55:14 <lpvb> how do I sort hackage by most popular packages?
16:55:23 <edwardk> tomrom: most of what i worked on in category-extras is implemented in scala in scalaz. the understanding of monads ports over, case classes are a clunkier form of (G)ADT. an understanding of laziness helps you know how to exploit lazy vals, etc.
16:55:54 <dibblego> scala's laziness is pretty darned broken though
16:56:01 <edwardk> lpvb: i think dons has spit out a report once a year for the last couple of years summarizing what is most popular. hackage doesn't display those stats though
16:56:06 <edwardk> dibblego: totally
16:56:32 <edwardk> you have to bend over backwards to trampoline monads to make them work, etc. and even then there are issues
16:56:32 <lpvb> he hasn't put out a report since 2010
16:56:43 <edwardk> ah, then i'm out of date
16:57:00 <tibbe> are there any known issues with newtypes and Data.Data?
16:57:03 <mmos> is there a quick formula for transforming a linear rnadom distribution into a Gaussian (normal) one?
16:57:06 <edwardk> shoot him an email and ask him how
16:57:09 <edwardk> tibbe: no
16:57:12 <edwardk> tibbe: works fine
16:57:18 <tibbe> edwardk: I'm getting the weirest type error
16:57:25 <edwardk> tibbe: ?
16:57:37 <shachaf> tibbe: Careful, edwardk takes that sort of thing as a challenge.
16:58:05 <tibbe> edwardk: http://hpaste.org/74323
16:58:11 <edwardk> shachaf: i think he's hoping that will be the case ;)
16:58:14 <tibbe> let me add the instance
16:58:35 <mmos> also a RANDOM (not rndadom) distribution
16:58:40 <tibbe> there
16:58:49 <shachaf> edwardk: I mean "a challenge to produce a weirder type error".
16:58:57 <edwardk> thats because HashSet can't have dataCast2 ;)
16:59:04 <shachaf> (I've seen you do it!)
16:59:08 <edwardk> you can implement dataCast1, but not dataCast2
16:59:13 <edwardk> it only has one argument
16:59:32 <tibbe> edwardk: I have no idea how to even use Data, someone wanted an instance
16:59:33 <edwardk> swap the definition you have for dataCast2 to dataCast1 (using gcast1) then take the default def for dataCast2
16:59:51 <edwardk> tibbe: dataCast1 and dataCast2 try to let you change the type args
16:59:57 <edwardk> you only have one type arg on a HashSet
17:00:02 <edwardk> so dataCast2 doesn't make sense
17:00:11 <edwardk> thats why its complaining
17:00:22 <edwardk> for HashMap, etc. it makes sense
17:00:35 <tibbe> let me guess, there's a dataCast3?
17:00:39 <edwardk> paste the instances, i'll happily go through them
17:00:40 <edwardk> no
17:00:42 <edwardk> it stops at 2
17:00:45 <tibbe> works now
17:01:02 <edwardk> did you implement it with the virtual constructor approach i pushed on the libraries list?
17:01:08 <Sgeo> @src or
17:01:08 <lambdabot> or    =  foldr (||) False
17:01:26 <edwardk> or like the old Data.Map instances?
17:01:38 <edwardk> where its just broken when you go to gunfold?
17:02:22 <ion> gunfolding sounds difficult and dangerous.
17:02:46 <edwardk> ion: easy to shoot yourself in the foot if you aren't careful where you aim ;)
17:03:14 <tibbe> edwardk: yes, with virtual constructors
17:03:20 <edwardk> great =)
17:03:31 <edwardk> i wholeheartedly endorse adding this instances =)
17:03:35 <edwardk> er these
17:03:43 <mmos> is there a quick formula for transforming a linear random distribution into a Gaussian (normal) one?
17:04:14 <edwardk> now with lens i'll be able to uniplate/biplate my way through HashSets/HashMaps
17:04:20 <tibbe> :)
17:04:40 <edwardk> i'm planning on concocting the correct version of the virtual constructor stuff to work with GHC.Generics soon
17:04:44 <tibbe> so, I'm supposed to bump the major version of unordered-containers because I added these instances. blew
17:04:52 <hpc> mmos: "squish" the values?
17:04:54 <edwardk> once I do that i'll probably send you a patch for that
17:05:10 <edwardk> yeah, instances are annoying like that
17:05:32 <mmos> hpc: that's what I mean, like some function involving an exponential or log
17:05:44 <hpc> mmos: try a bell curve
17:05:49 <edwardk> basically i want GHC.Generics instances for Data.Map/Data.IntMap as well, but it needs the same virtual constructor style
17:06:03 <hpc> there's probably more math to do beyond that, which i am too tired to think about
17:06:14 <hpc> you can also try #math or something like that
17:06:46 <mmos> hpc: yes, I want do end up with a distributation that resembles the bell curve but I don't know the math of that
17:15:40 <tomrom> how can learning haskell influence my java programming skills ?
17:15:58 <ion> You’ll find Java even more painful.
17:16:03 <hpc> tomrom: not as much as your desire to program java
17:17:16 <johnw> that's a bit like asking if learning Italian will help you to romance girls in German.  You'll just end up wishing they spoke Italian. :)
17:17:48 <tomrom> :)
17:18:05 <ivan`> is there any way to build GHC without a GHC binary? I might be willing to do tedious things
17:18:25 <hpc> ivan`: there's a bootstrap process
17:18:26 <johnw> shachaf: I'm becoming more and more certain that my problem is the result of blocking on an MVar
17:18:35 <ivan`> hpc: I would have a huge pile of C code instead, right?
17:18:40 <lpvb> tomrom: I'd say it would make you want to use the advanced abstractions in Java to realize it doesn't support what you want so you move to scala
17:18:46 <johnw> because once it does lockRC, that's it, nothing else ever happens
17:18:59 <tomrom> unfortunately there aren't many companies around me who appreciate developers skilled in FP..but I like to learn it anyway because I see it as the best way to push my programming&problem solving skills further
17:19:03 <hpc> you wouldn't be writing any code at all
17:19:14 <hpc> i don't know the exact process, but i know it takes forever
17:19:16 <ion> tomrom: Learning Haskell has certainly helped me separate IO code from the code that can be pure in any language.
17:19:29 <hpc> so it won't be doing tedious things as much as waiting for the computer to do tedious things
17:24:04 <ivan`> whether I build with an older GHC or with a pile of generated C code doesn't really change anything about the trusting-trust problem
17:26:36 <johnw> shachaf: it's working!  The cabal-dev did the trick
17:28:45 <Onionnion|Eee> in what ways or situations would a functional language be a better choice than an imperative language (Python)
17:29:43 <Nisstyre_> Onionnion|Eee: it's difficult to say
17:29:47 <hpc> Onionnion|Eee: since you single out python, we can start with instances of functional programming in python itself :P
17:30:43 <Onionnion|Eee> Well I meant Python as-in an example, but Python is what I have most experience with so far and I think I'll make Haskell the next modern language for me to learn
17:30:48 <shachaf> johnw: I don't think I told you to use cabal-dev.
17:31:05 <mm_freak> Onionnion|Eee: i'd say almost always, especially in comparison to python
17:31:19 <shachaf> Onionnion|Eee: Maybe the FAQ will have some answers for your question.
17:31:20 <shachaf> @where faq
17:31:20 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:32:44 <Onionnion|Eee> why do so many people love it so much? gotta ask that from what I'm seeing a lot of
17:33:26 <johnw> shachaf: needless to say, that's what fixed it; so some dependency in my cabal soup was messing with how lambdabot was coded
17:33:37 <Nisstyre_> Onionnion|Eee: well Python is missing a lot of the features that make Haskell unique
17:33:43 <Nisstyre_> such as pattern matching
17:33:59 <Nisstyre_> and template programming (although I'm sure there are libraries for it somewhere)
17:34:35 <Onionnion|Eee> but I also love how humorous so much of the haskell material is
17:34:56 <Onionnion|Eee> kinda like that one ruby guide that's a huge cartoon
17:35:02 <Nisstyre_> Onionnion|Eee: like http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms ?
17:35:08 <lpvb> it's also easy to do parallel calculations
17:35:13 <lpvb> whereas python only has one thread
17:35:21 <hpc> Nisstyre_: i wouldn't call template programming a feature of haskell :P
17:35:24 <hpc> or even a unique one
17:35:27 <Nisstyre_> lpvb: that's correct, but you can do concurrency without parallelism
17:35:51 <Nisstyre_> hpc: I know, I should've said type classes
17:36:03 <lpvb> if you're looking to make something concurrent or parallel to speed things up, python will drag you down
17:36:03 <Nisstyre_> but you can get that sort of ad-hoc polymorphism with duck typing, kind of
17:37:06 <Nisstyre_> lpvb: btw, that's not a feature of Python specifically
17:37:17 <lpvb> feature?
17:37:18 <Nisstyre_> it's a feature of CPython, the reference implementation
17:37:28 <Nisstyre_> lpvb: I mean it's not a part of the language
17:37:36 <lpvb> yea, but that is the most common implementation
17:37:38 <marty1> if you could give one advice to programmer starting to learn haskell, what would it be ?
17:38:13 <Nisstyre_> lpvb: well hopefully that will start to change with things like PyPy and Stackless
17:38:27 <hpc> marty1: brace yourself... for LEARNING!
17:38:35 <Nisstyre_> marty1: be open minded
17:38:50 <Nisstyre_> marty1: also patient
17:39:30 <marty1> I'd like to start learning it but lack of job opportunities kinda stops me and pushes me out of it, so motivation goes down..
17:40:08 <marty1> I'd like to motivate myself with reasonable, pragmatic facts of what can I gather from learning it
17:40:20 <sipa> marty1: don't assume that the way to solve problems, is by trying to make it do what you're used to
17:43:54 <marty1> soo, how would you motivate me to learn Haskell :) ?
17:44:43 <Nisstyre_> marty1: I wouldn't?
17:44:48 <hpc> marty1: tantalizingly vague statements about the language
17:44:52 <hpc> and burrito jokes
17:45:02 <Clint> noting that pants are optional
17:46:28 <arbn> marty1: There are many sites noting the advantages of advanced type systems, laziness, and the functional pardigm. Google is your friend.
17:47:03 <Nisstyre_> marty1: if you're new to functional programming then you should learn Racket first imho
17:47:28 <marty1> hpc: I didn't wan't to tantalize, the ways I can realize myself professionaly in Haskell are quite limited though in my geographical context.
17:47:37 <arbn> Nisstyre_: I second that. Scheme to Haskell is a smooth and pleasant ride, IMO.
17:50:02 <amosr> if you're not sure whether you want to learn haskell, why not just start reading LYAH and keep reading if you like it?
17:50:02 <slack1256> guys do I understand extensible exceptions?
17:50:13 <slack1256> When you throw an exception is really an existential type of the class exception
17:50:14 <slack1256> which has a typeable constrain. So when catching them you can constrain them to
17:50:16 <slack1256> an expected datatype with 'cast' undercover thanks to them being an instance of
17:50:17 <slack1256> typeable
17:50:39 <slack1256> wow sorry for the crocked output. never again i promise.
17:51:22 <marty1> amosr: gonna have a look immediately.. I am quite hesitant person as you can see :)
17:51:36 <arbn> marty1: You should learn Haskell because you're an awesome developer whose passion for excellence is deeper than a desire for wealth and professional success. :P
17:52:26 <slack1256> arbn: that in fact applies to any learning :-)
17:52:39 <geekosaur> nertz.  learning haskell will help you as a developer in general and make you worth more
17:52:47 <Nisstyre_> marty1: http://docs.racket-lang.org/getting-started/index.html
17:52:50 <Nisstyre_> give that a try first
17:53:09 <Nisstyre_> from the sounds of it, you don't have much experience with FP
17:53:16 <marty1> arbn: very nice, thank you
17:53:25 <marty1> no I don't , to be honest
17:53:44 <marty1> I just need to push myself to learn it and don't think about professional benefits at all cost
17:54:09 <Nisstyre_> marty1: http://en.wikipedia.org/wiki/Referential_transparency_(computer_science)
17:54:51 <marty1> Nisstyre_: i am familiar with that concept, at least I think so :)
17:55:06 <Nisstyre_> marty1: okay, well that is one of the fundamentals
17:55:15 <marty1> and what are the others
17:55:19 <marty1> from your point of view ?
17:55:25 <Nisstyre_> marty1: everything (almost) in Haskell is referentially transparent
17:55:37 <Nisstyre_> marty1: I couldn't give you a precise list
17:56:03 <latro`a> technically everything is, but the things that are only technically referentially transparent don't really count
17:56:35 <latro`a> as in, a reference still points to the same "thing", but if the "thing" changes then that distinction is of no import
17:57:34 <Nisstyre_> marty2: if you really want to get into the fundamentals then check out: http://mitpress.mit.edu/sicp/
17:57:42 <arbn> latro`a: We can say that Haskell provides good tools for making as much as possible referentially transparent.
17:58:02 <latro`a> absolutely
17:58:31 <latro`a> just saying, you could quibble that technically even IORefs are transparent because where the reference is to doesn't change, but that distinction doesn't mean anything in practical terms
17:59:21 <hpc> no, you quibble by saying the ugly is hidden behind that most magical of IO monad rugs
17:59:26 <latro`a> lol
17:59:36 <latro`a> you mean under?
17:59:38 <latro`a> or curtains?
17:59:42 <arbn> Yeah. Beginners are often confused by the fact that the Haskell language technically doesn't include side-effects, and yet Haskell programs are side-effectful. :P
17:59:45 <hpc> this is a very strange rug
17:59:50 <latro`a> lol
17:59:57 <latro`a> you hang it vertically, because it's the IO monad
18:00:00 <latro`a> totally makes sense
18:00:09 <latro`a> all the other monads go on the floor
18:00:14 <latro`a> but the IO monad goes on the wall
18:00:17 <Nisstyre_> monads all the way down?
18:00:44 <arbn> Pay no attention to the IO behind the curtain...
18:01:22 <marty2> arbn: side effectful ? How should I interpret that ?
18:02:49 <arbn> marty2: Just believe the noble lies that the beginner tutorials tell beginners. Haskell is a functionally pure language, but real programs require effects that aren't merely pure functions. Haskell does a really good job of making these effects very natural and easy to reason about in a functional way.
18:02:52 <hpc> marty2: you know how in any other programming language, sqrt(4) is sqrt(4) is sqrt(4)?
18:02:55 <hpc> no matter what day of the week
18:03:36 <hpc> but when you open a file, the results depend on what's in the file, which in this case wasn't written to because you ate chinese and couldn't go to work today
18:03:53 <hpc> side-effectful code is code whose result depends on what you had for lunch
18:04:09 <marty2> :) makes sense
18:06:43 <marty2> what are your tips to start expressing part of programs into meaningful composable functions ? are there any methodics, tips.. ?
18:07:10 <hpc> one easy pattern is when you see f (g (h x)) or similar
18:07:23 <hpc> you can factor it to (f . g . h) x
18:08:01 <hpc> using (.), which is function composition
18:08:47 <marty2> so f (g (h x)) is equivalent to (f . g . h) x ?
18:08:51 <marty2> semantically
18:08:56 <hpc> yeah
18:09:04 <latro`a> (f . g) x = f (g x)
18:09:08 <marty2> okay
18:09:12 <latro`a> ^will actually compile in GHC, iirc
18:09:19 <hpc> latro`a: that's the definition
18:09:20 <latro`a> but fails to parse in NHC or something
18:09:34 <hpc> that might even be in the report
18:09:35 <latro`a> (despite the report saying it should parse)
18:10:10 <marty2> is it possible to write something like rand() in haskell ?
18:10:24 <arbn> marty2: Yes.
18:10:35 <latro`a> as a pure function no, but there are mechanisms to get random numbers yes
18:10:38 <hpc> it won't have the type you would naively expect
18:10:49 <hpc> because it needs to know the state of your RNG
18:10:57 <marty2> RNG ?
18:11:01 <latro`a> random number generator
18:11:27 <latro`a> either some system internal shenanigans, in which case you need IO, or a deterministic RNG, in which case you need a parameter for the current state of the RNG
18:11:38 <latro`a> in neither case do you just get rand :: Double
18:11:45 <latro`a> nor rand :: () -> Double
18:13:45 <marty2> what you think is hardest to grasp when you start learning haskell ?
18:14:15 <hpc> at the veeeeery beginning, syntax of parameters to things
18:14:31 <hpc> functions have parameters, types have parameters, parameters have parameters
18:14:42 <lpvb> marty2: doing things without variables and loops
18:14:43 <hpc> and it can all turn into a big blur fairly quickly
18:15:06 <lpvb> marty2: defining what something is instead of the steps to do it
18:15:39 <marty2> hehe you've mentioned things that I've picked also as the hardest when I took FP course at uni
18:16:11 <marty2> since then, I am still beginner who bothers more experienced folks at IRC :P
18:16:32 <lpvb> Monads were fairly easy to understand, I don't know why everyone said otherwise...
18:16:42 <lpvb> oh
18:16:47 <lpvb> also laziness
18:16:56 <lpvb> hard to reason
18:17:11 <marty2> what is the simplest explanation and most accurate 'definition' of monad you've encountered ?
18:17:36 <lpvb> the simplest definition is the haskell code
18:17:41 <latro`a> the two are probably not the same thing
18:17:43 <lpvb> also the most accurate
18:17:49 <latro`a> also, lpvb, not really
18:17:49 <marty2> every piece of haskell code is monad ?
18:17:54 <ParahSailin_> @src (>>=)
18:17:54 <lambdabot> Source not found. :(
18:18:00 <latro`a> it's not too hard to write down an invalid monad that typechecks
18:18:07 <ParahSailin_> @src [] (>>=)
18:18:08 <lambdabot> xs >>= f     = concatMap f xs
18:18:31 <ParahSailin_> @src IO (>>=)
18:18:31 <lambdabot> m >>= k     = bindIO m k
18:19:51 <arbn> marty2: Importantly, don't believe those people who will tell you that monads are like boxes, burritos, curtains, alchemy, pipes, etc. That really confused me as a beginner and delayed learning.
18:20:15 <hpc> monads are like exactly what they are
18:20:18 <marty2> right now I read http://en.wikipedia.org/wiki/Monad_(functional_programming)
18:20:28 <latro`a> the container analogy initially isn't that bad
18:20:34 <latro`a> if it isn't stretched too far
18:20:39 <marty2> In http://en.wikipedia.org/wiki/Functional_programming, a monad is a structure that represents http://en.wikipedia.org/wiki/Computation.
18:20:44 <hpc> container and computation are good analogies, but they contradict each other at times
18:20:50 <marty2> quite abstract, but I can get some sense of it
18:21:01 <hpc> or cause mental tension if you don't fully grasp laziness
18:21:12 <latro`a> I think container is easier to understand at first, computation is closer to the truth, but that the real truth is neither
18:21:21 <rwbarton> "container" has rather little to do with the monad part (as opposed to the functor part)
18:21:29 <latro`a> ehhh
18:21:35 <latro`a> depends on the monad
18:21:39 <latro`a> join can be pretty naturally containery
18:21:44 <latro`a> []'s join especially
18:21:47 <rwbarton> no
18:21:59 <rwbarton> the abstraction of "container" does not have any information which relates to monads
18:22:18 <latro`a> "take every element of every box in the box and put them together into a new box"
18:22:22 <latro`a> is concat
18:22:27 <latro`a> sounds containery to me
18:22:38 <ion> marty2: Monad in Haskell is defined by return :: Monad m => a -> m a and (>>=) :: Monad m => m a -> (a -> m b) -> m b for whom there are three laws. I guess that’s as simple and accurate as you can go.
18:22:40 <latro`a> in a roundabout way this applies elsewhere as well
18:23:11 <arbn> What I don't like about these analogies is that they don't sound very functiony, and monads are a very functiony (really arrowy) idea.
18:23:18 <latro`a> true
18:23:48 <latro`a> introducing it with <=< is more function
18:23:48 <latro`a> y
18:23:51 <latro`a> but less useful
18:24:03 <marty2> ion: how this definition should be read ? I am not familiar with syntax and its meanings
18:24:23 <latro`a> marty2: he just gave the types of the two functions that the monad typeclass provides
18:24:39 <lpvb> marty2: return takes a type 'a' and wraps it into a Monad a
18:24:53 <latro`a> wraps it into an m which is an instance of Monad
18:25:13 <latro`a> so takes an Int and puts it in a list, for example
18:25:19 <latro`a> 2 -> [2]
18:25:33 <lpvb> marty2: (>>=) takes a monad 'a' and feeds it to a function which expects just 'a' and transforms it into a Monad of any other type 'b', and then returns Monad 'b'
18:25:55 <arbn> The idea of a functor as a mapping between two categories isn't that bizarre. I kind of wish some monad tutorial would introduce the simplest notion of a category, and use that.
18:26:30 <marty2> lpvb: thx, makes sense :)
18:26:31 <ion> lpvb: “A monad ‘a’” is a bit… misleading.
18:26:44 <marty2> arbn: isn't functor something from category theory ?
18:26:58 <hpc> also, nothing "takes a monad"
18:27:05 <hpc> :t return
18:27:06 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:27:09 <hpc> 'm' is the monad
18:27:13 <hpc> the type itself
18:27:17 <dolio> It's hard for me to see how functors have anything more to do with containers than monads.
18:27:19 <hpc> not values of type 'm a'
18:27:38 <latro`a> dolio: fmap is rather containery, the function acts on whatever is inside
18:27:48 <latro`a> join can be less containery depending on the monad
18:27:56 <ion> latro`a: fmap reverse getLine
18:28:10 <latro`a> eh, still containery, the box is just weird
18:28:14 <dolio> You haven't looked at enough functors.
18:28:22 <rwbarton> dolio, yes, that's true
18:28:24 <arbn> marty2: A functor is a mapping that associates objects with objects and arrows with arrows. So, it's a transformation from one category to another.
18:29:16 <latro`a> in the context of haskell a functor is a mapping from *every* haskell type "a" to a new haskell type "f a" which replaces *every* haskell function "f" with a new haskell function "fmap f"
18:29:26 <rwbarton> but I also don't think monads have anything more to do with containers than functors
18:29:29 <latro`a> I should probably say a Functor
18:29:40 <marty2> what should I imagine under the term 'category' ? any real world example ?
18:30:02 <rwbarton> some monads are containers, sure.  that does not mean one should try to understand monads by understanding containers
18:30:15 <latro`a> most common categories are in some way analogous to objects as sets and arrows as functions
18:30:23 <dolio> rwbarton: Yes, I agree.
18:30:47 <rwbarton> whereas trying to understand monads by understanding computations is productive, at least in retrospect
18:31:06 <lpvb> I think Monads are more verb-like than noun-like, so saying they are containers is confusing
18:31:37 <latro`a> but a category just has a collection C of objects, a collection A of arrows, where each arrow has a domain in C and a codomain in C, and where each arrow can be "composed" in a way that changes the domain/codomain in the obvious way
18:31:52 <arbn> marty2: A very easy category is one which has, as arrows, functions between sets and, as objects, sets. But, a category is a very abstract notion where the "things" (objects) and the transformations between then (arrows) could be almost anything.
18:31:56 <hpc> lpvb: perhaps more like adverbs
18:32:13 <arbn> between them*
18:32:29 <marty2> arbn: sounds very abstract
18:32:33 <latro`a> in haskell we have the category Hask, where C contains each haskell type a and A contains each haskell function a->b
18:32:50 <arbn> latro`a: You forgot Unit and the identity arrow as requirements of a category.
18:32:52 <dolio> rwbarton: Although, lots of algebra stuff to do with monads is going to look containery, and that's a significant part of the beginner stuff you see of them in mathematics at least.
18:32:53 <lpvb> hpc: I agree, adverb then
18:32:56 <latro`a> I know, arbn
18:32:59 <latro`a> that was deliberate
18:33:04 <latro`a> also, Unit?
18:33:20 <dolio> Moreso than mappings between categories.
18:33:52 <latro`a> the identity arrow was omitted on purpose, because the description was already getting long; I have no idea what you mean by Unit
18:34:03 <latro`a> iirc unit is the category theory term for return, which is DEFINITELY not in every category
18:34:48 <pheaver> I've noticed that the swap and unsafeSwap functions in the (mutable) vector library are terribly inefficient. they have to allocate memory to hold both values that you're swapping. when benchmarking some code that uses mutable vector, it was allocating a ton of memory in the swap function. i had to rewrite everything to use low level prim functions from GHC.Exts and GHC.Prim to get the memory profile under control. does anyo
18:34:48 <pheaver> have any insight into this?
18:35:06 <rwbarton> dolio: You mean the monads whose algebras are various familiar algebraic structures?
18:35:15 <dolio> Yes.
18:35:26 <dibblego> take a student who has fallen for the "monads are somehow related to containers" disassociation and try to teach them the state monad — now do same for a null student, observe the result
18:36:10 <dolio> rwbarton: And free algebraic structures tend to be 'containers' of a sort.
18:36:30 <rwbarton> take this example though--why is (,) w a monad only when we equip w with a monoid structure
18:36:34 <arbn> latro`a: f . 1A = f = 1B . f for all f : A -> B
18:36:38 <rwbarton> how do I justify that in terms of containers?
18:36:50 <latro`a> that's not unit
18:37:03 <latro`a> that's the identity arrow behaving as an identity to .
18:38:45 <rwbarton> I think the idea that a type constructor is really a "thing"--the sort of thing that might be the head of an instance--is the biggest conceptual difficulty in understanding monads
18:39:05 <latro`a> one of the big hurdles, definitely
18:39:17 <latro`a> also part of the problem is our convention of naming type and data constructors the same
18:39:33 <latro`a> at first pattern matching may actually look like *TYPE* matching
18:39:34 <arbn> latro`a: I was taught that a category has to have an "identity object", which is called the unit, but maybe I'm confused. That's not always quite the same as the identity arrow, is it?
18:39:35 <rwbarton> and certainly containers are among the most familiar examples of type constructors
18:39:53 <latro`a> arbn: nope, there is an empty category
18:40:15 <rwbarton> arbn, maybe you're thinking of a monoidal category?
18:41:07 <arbn> Ah. I'm not sure. I'll look into it and de-confuse myself. :)
18:43:57 * hackagebot pureMD5 2.1.2 - A Haskell-only implementation of the MD5 digest (hash) algorithm.  http://hackage.haskell.org/package/pureMD5-2.1.2 (ThomasDuBuisson)
18:45:10 <rhodesd> I'm wondering, is ghc 7.6 stable enough to try out type-level literals?
18:51:08 <applicative> rhodesd: there is a candidate release version with prebuilt binaries, just put it in a directory and try it...  I havent used GHC.TypeLits yet
18:52:19 <rhodesd> oh great! thanks applicative
18:53:24 <applicative> oh here it  is  http://www.haskell.org/ghc/dist/7.6.1-rc1/
18:54:08 <rhodesd> thanks, I was snooping around haskell.org earlier today, could only find 7.4
18:56:11 <MostAwesomeDude> Hey, those of you using Uniplate. How would I dig through a structure to find a singlething, and then *remove* it from the structure? I want to pull out certain global objects and stash them in an outside struct.
19:02:53 <roconnor> MostAwesomeDude: Uniplate isn't designed to remove things from structures.  It only does replacement.
19:03:03 <roconnor> You can replace (Just x) with Nothing though.
19:03:22 <roconnor> MostAwesomeDude: maybe I misunderstand what you mean by remove
19:04:11 <roconnor> MostAwesomeDude: that said, you can often get a traversable (aka a uniplate) to (Maybe Foo) more often than you might think.
19:07:32 <MostAwesomeDude> roconnor: Hmm. Well, I've got lots of things that have [Expr] inside. I guess I could match those and then rewrite them if I see my target things inside the list.
19:16:22 <MostAwesomeDude> If I have a bunch of pure transformations, and I want to raise fatal errors from inside, is there a better thing I can do than just calling error?
19:17:38 <ddarius> dibblego: What operation is the null student the zero of?
19:18:12 <dibblego> the one without preconceptions
19:22:49 <Ralith> MostAwesomeDude: the Either monad
19:39:13 <MostAwesomeDude> Ralith: Yeah, I guess I could do that.
20:01:13 <johnw> anyone here have any opinion on pipes vs conduit?
20:02:52 <Clint> i've only used the latter
20:04:07 <johnw> I'm designing a type library for Git objects that are backed by the hlibgit2 FFI.  I have a situation where objects are "managed" by libgit2, and need to be freed during finalization.  What is the best abstraction for this sort of thing?  This is what led me to reading about frames
20:05:31 <johnw> also, the hlibgit2 finalizer for each Git object needs to be evaluated in the IO monad, but I don't want user's code littered with IO just so that it's there when needed
20:12:51 <startling> man, where's edwardk when you need him?
20:13:53 <purefn1> startling: mention comonads and he'll magically appear
20:14:40 <Cale> johnw: Isn't that kinda what ForeignPtr is for?
20:15:06 <ddarius> purefn1: The magic word is "lens".
20:16:05 <Cale> johnw: http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Foreign-ForeignPtr-Safe.html
20:16:12 <johnw> reading...
20:21:27 <startling> ddarius: I mentioned lenses earlier! didn't work
20:23:45 <roconnor> lenses!
20:26:01 <dolio> He turned off comonad because I kept abusing it.
20:26:20 <johnw> maybe he's writing colens
20:48:59 * hackagebot hlibgit2 0.3.1 - Low-level bindings to libgit2.  http://hackage.haskell.org/package/hlibgit2-0.3.1 (JohnWiegley)
20:49:41 <startling> johnw: outting c2hsc to work?
20:49:44 <startling> *putting
20:50:16 <johnw> yeah :)
20:50:25 <johnw> the bug list is getting small
20:50:35 <johnw> it's still only ever going to do at best 90% of the job
20:51:49 <dino-> So today I was browsing pages on Paul Graham's website, and I came upon this old one http://paulgraham.com/accgen.html
20:51:51 <startling> what stuff doesn't it get?
20:52:00 <dino-> The Haskell solution in this list seemed kind of.. sub-optimal?
20:52:12 <shachaf> dino-: The Haskell answer to that question is probably "ask a different question".
20:52:12 <dino-> Depending on whether the problem requires mutation of some state or not, I was thinking one of these would be better
20:52:15 <dino-> by far:
20:52:16 <startling> dino-: (b) that's incremented by, not plus.
20:52:23 <dino-> foo n i = n + i
20:52:24 <startling> dino-, it requires mutation
20:52:31 <dino-> goo = \i -> execState $ modify (+ i)
20:52:32 <startling> dino-: (b) that's incremented by, not plus.
20:52:37 <johnw> wtf?
20:52:47 <startling> whoops, didn't mean to say that again
20:52:53 <johnw> foo n = \i -> n + i?
20:52:57 <shachaf> dino-: Neither execState nor (+) are direct answers.
20:53:07 <johnw> foo n = (n+)
20:53:11 <startling> johnw: (b) that's incremented by, not plus.
20:53:18 <dino-> startling: Ok, the, State monad. Still less crazy than that IORef business, no?
20:53:35 <startling> dino-: yeah, I was thinking about that too
20:53:35 <johnw> how is incremented by different?
20:53:39 <startling> johnw: mutates
20:53:48 <dino-> Agree, it's kind of a meh problem to begin with
20:53:53 <startling> yeah
20:53:54 <shachaf> dino-: This question is about having hidden mutable state.
20:54:04 <startling> or just one poorly suited to haskell
20:54:05 <johnw> oh
20:54:06 <shachaf> A whole lot of Haskell is about avoiding mutable state or making it explicit.
20:54:07 <dino-> And there's really no point to haveing that hidden state.
20:54:13 <Cale> import IOExts
20:54:15 <johnw> i see, every time you call you get a different answer
20:54:16 <dino-> shachaf: Totally agree. Avoid to begin with
20:54:18 <Cale> wow :)
20:54:33 <Cale> I wonder how old that is
20:54:37 <shachaf> Which is why the Haskell answer to this question is probably "ask a different question". :-)
20:54:38 <dino-> Cale: I think 2002
20:54:49 <dino-> No, that's wrong, I think the Blub thing is 2002
20:54:56 <Cale> http://www.haskell.org/ghc/docs/5.02/set/sec-ioexts.html
20:55:44 <arbn> As is usual for PG, the question strongly favors LISP dialects. :P
20:56:22 <shachaf> "Write a program that parses S-expressions and evaluates them as Arc code using the minimal number of token"
20:56:25 <Cale> However, I think this PG article is better than most, because at least it's mostly code as opposed to hot air.
20:56:26 <shachaf> s/.$/s"/
20:56:50 <Cale> (otoh, it also was mostly not written by him, either, by the looks of it)
20:57:47 <dino-> But I like that answer here, with a question: Are you asking me to mutate a stored value for no reason? And, if so, you're requirements are wrong.
20:57:59 <dino-> s/you're/your/
20:58:27 <brutal_chaos> I am trying to play with http-conduit, however when I try out the basic http://pastebin.com/75Gj1gCs from http://www.yesodweb.com/book/http-conduit I receive 'getAddrInfo: does not exist (error 10093).' 10093 WSANOTINITIALISED happens when WSAStartup is not performed (http://msdn.microsoft.com/en-us/library/aa924071.aspx). Anyone have an idea as to how I can get this to work?
20:58:34 <shachaf> No, *you're* requirements!!!
20:58:41 <startling> @hoogle a -> (a, a)
20:58:42 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
20:58:42 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
20:58:42 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
20:58:50 <jfischoff> Is there an inclusive or type in use, like Or a b = First a | Second b | Both a b?
20:58:51 <dino-> I am requirements and so can you
20:59:08 <shachaf> jfischoff: A common name is These.
20:59:10 <startling> I'd just do "fn state = double (state + 1) where double a = (a, a)
20:59:16 <Cale> brutal_chaos: there's this extra thing you have to do to initialise the network library on windows...
20:59:16 <shachaf> data These a b = This a | That b | These a b
20:59:25 <jfischoff> shachaf: thank
20:59:27 <jfischoff> s
20:59:28 <brutal_chaos> Cale: how do I do that?
20:59:28 <startling> jfischoff: writing it now. :)
20:59:29 <shachaf> jfischoff: Not in the standard library, though.
20:59:52 <Cale> brutal_chaos: Wrap your whole program in  withSocketsDo $ ...
21:00:00 <roconnor> startling: both += 1?
21:00:02 <Cale> http://hackage.haskell.org/packages/archive/network/2.3.1.0/doc/html/Network.html
21:00:21 <roconnor> startling: oh wait nevermind
21:00:34 <Cale> I don't exactly know why the RTS doesn't just handle that on Windows.
21:00:44 <shachaf> join (,) . (+1)
21:00:51 <shachaf> @yarr
21:00:51 <lambdabot> I'd like to drop me anchor in her lagoon
21:00:59 <johnw> :t join (,)
21:01:00 <lambdabot> forall a. a -> (a, a)
21:01:14 <startling> johnw: oh, I always forget about join
21:01:17 <johnw> :t (,)
21:01:18 <lambdabot> forall a b. a -> b -> (a, b)
21:01:26 <brutal_chaos> Cale: and if this isn't strictly supposed to run on windows?
21:01:29 <shachaf> startling: Don't actually use join. :-(
21:01:35 <startling> @pl fn s = join (,) (state + 1)
21:01:35 <lambdabot> fn = const (join (,) (state + 1))
21:01:36 <johnw> shachaf: is join working on (->) r in this case?
21:01:38 <brutal_chaos> Cale: won't that fail on other platforms?
21:01:40 <shachaf> johnw: Yes.
21:01:41 <startling> shachaf: why not?
21:01:46 <Cale> brutal_chaos: withSocketsDo is the identity function on other platforms
21:01:50 <shachaf> join :: m a -> m (m a) ==> join = (r -> a) -> r -> r -> a
21:01:52 <Cale> brutal_chaos: So it's harmless.
21:01:59 <brutal_chaos> sweet, thanks
21:02:17 <johnw> :t join (\x y z -> x y z)
21:02:18 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
21:02:18 <lambdabot>     Probable cause: `x' is applied to too many arguments
21:02:18 <lambdabot>     In the expression: x y z
21:02:31 <shachaf> johnw: That's just join id
21:02:32 <johnw> :t join (\x y z -> x + y + z)
21:02:33 <lambdabot> forall a. (Num a) => a -> a -> a
21:02:40 <johnw> :t join (\x y -> x + y)
21:02:41 <lambdabot> forall a. (Num a) => a -> a
21:02:45 <johnw> ok
21:03:01 <johnw> i'm trying to intuit what join on a function means
21:03:11 <shachaf> join f x = f x x
21:03:15 <johnw> > join (+) $ 2
21:03:16 <lambdabot>   4
21:03:24 <johnw> > join (+) $ a
21:03:25 <lambdabot>   a + a
21:03:28 <startling> > join (+) 2
21:03:29 <lambdabot>   4
21:03:30 <arbn> Does anyone know what the present state of HOC is?
21:03:30 <johnw> ok, that's pretty damn cool
21:03:32 <shachaf> Whoops, I gave the wrong type for join.
21:03:36 <shachaf> I was thinking of cojoin.
21:03:51 <shachaf> join :: m (m a) -> m a ==> join :: (r -> r -> a) -> r -> a
21:03:58 <shachaf> Now you can figure out what join does from the type.
21:04:03 <Cale> join x in general means to run x, and then run its result, and in the function monad, running a function means applying it to the parameter to which the overall function has been applied
21:04:05 <johnw> it turns a binary function into a unary that dups its args
21:04:15 <shachaf> (The cojoin I gave above only works if r is a monoid.)
21:05:06 <johnw> Cale: that's a great explanation, thank you
21:05:18 <Cale> arbn: Last I checked, unmaintained.
21:05:24 <startling> what's the best way to write a lens?
21:05:31 <johnw> so join (+) a => (+a)a
21:05:39 <startling> johnw: right
21:05:42 <johnw> startling: are you trying to get edwardk to come online?
21:05:55 <Cale> arbn: however, my information may be out of date
21:06:01 <startling> johnw: well, I'm trying to figure out how to write a lens in his `lens` package
21:06:03 <johnw> that makes more sense than my dup intuition
21:06:22 <johnw> it's always better to be able to visualize in terms of a composition of function applications
21:07:07 <arbn> Cale: There have been no commits since 2010, so I'm guessing that's right. I guess it would take a lot of work to get it into a good state again, which is a shame.
21:07:18 <startling> arbn: what is hoc?
21:07:32 <arbn> startling: Objective-C bindings for Haskell.
21:07:39 <startling> arbn: oh
21:07:42 <johnw> startling: oh, I thought you were just using the magic word :)
21:07:53 <startling> arbn: I think there's a curse involved
21:08:01 <johnw> arbn: has objc changed much since then?
21:08:22 <startling> arbn: any bindings to objective c or cocoa in any language will see a flurry activity for a short time and then remain unmaintained forever
21:08:32 <johnw> haha
21:08:34 <johnw> that is so true
21:08:40 <johnw> MacRuby keeps limping along, though
21:08:45 <startling> johnw: limping
21:08:56 <Cale> startling: the most basic way is just to use the lens function
21:09:06 <Cale> startling: and apply that to a getter and setter
21:09:12 <arbn> johnw: They never got it working with the garbage collection introduced in Objective-C 2, which might be an issue. I can't really test it right now, which is why I was wondering if anyone has dusted it off recently.
21:09:13 <startling> Cale: ah, okay
21:09:40 <shachaf> startling: You can also do it the functory way!
21:11:02 <shachaf> Here's a lens for the first element of a 2-ple: _1 k (a,b) = (\a' -> (a',b)) <$> k a
21:12:30 <startling> shachaf: oh, interesting
21:12:55 <startling> shachaf: this corresponds more closely to their types, too.
21:13:06 <Cale> type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
21:13:11 <shachaf> That corresponds exactly to their types.
21:13:33 <johnw> how is that different from _1 k (a,b) = (k a, b)?
21:14:00 * hackagebot esqueleto 0.1 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.1 (FelipeLessa)
21:14:08 <startling> johnw: it fmaps over k a
21:14:08 <shachaf> johnw: That's a setter, not a getter.
21:14:26 <startling> johnw: fmap fn x is not the same as fn x
21:14:35 <johnw> gotcha
21:15:46 <shachaf> johnw: In particular, the two functors that you typically use here are Identity and Const.
21:15:58 <shachaf> newtype Const a b = Const a
21:16:13 <shachaf> In the case of Const, the fmap does nothing at all. :-)
21:19:53 <Cale> Or in the case of this library, they're renamed to Accessor and Mutator
21:19:59 <johnw> shachaf: i love learning subtle stuff like this
21:20:06 <Cale> so as to be more suggestive of their use
21:20:27 <Cale> (and provide error messages which are more suggestive of what's wrong)
21:20:38 <shachaf> johnw: Notice how you can make something just a getter or just a setter just by restricting its type.
21:21:06 <shachaf> Also notice how you can compose these things with plain old (.), and that id is the identity lens.
21:21:28 <johnw> yeah, it's pretty awesome stuff, I admit
21:21:38 * shachaf isn't sure whether that's actually a good idea.
21:21:53 <johnw> the amount of coolness you get from Haskell without having to hack in new syntax is one of its most amazing aspects, in my opinion
21:22:19 <Cale> shachaf: Whether what is a good idea?
21:22:29 <Cale> The fact that you can compose these things as functions?
21:22:36 <shachaf> Cale: Having lenses be plain functions instead of some kind of newtype with a Category instance.
21:22:49 <shachaf> It gives you various nice things but it's also kind of a hack.
21:22:50 <Cale> I actually find it kind of refreshing, myself :)
21:23:27 <Cale> I still don't actually know what Control.Category *is* really.
21:23:41 <johnw> Cale: that's comforting to hear
21:23:46 <johnw> neither do I
21:24:10 <johnw> isn't just a type class for id and (.)?
21:24:14 <DMWIT> yes
21:24:14 <Cale> johnw: Well, there's the basic answer that it's just a typeclass for id and (.)
21:24:16 <Cale> yes
21:24:37 <Cale> But I mean in terms of abstracting it to a categorical point of view on things
21:24:39 <DMWIT> So long as (.) is associative and has id as the identity.
21:24:40 <johnw> I guess that would allow a certain arrow type to be composable with (.), as long you hide the Prelude..
21:24:52 <Cale> It's not straightforwardly the definition of a category.
21:24:55 <DMWIT> Yes, (->) is a Category instance.
21:24:57 <startling> Prelude.(.) and Prelude.id should just be Category.(.) and Category.id. :(
21:24:59 <shachaf> Cale: Typed monoid?
21:25:07 <ddarius> startling: (Prelude..)
21:25:16 <startling> ddarius: hm?
21:25:22 <Cale> shachaf: It *might* be sort of a category-object on Hask.
21:25:30 <DMWIT> startling: You just got the syntax wrong a tiny bit.
21:25:36 <YayMe> Quick question, starting with: data Foo a = Foo a deriving Ord
21:25:40 <DMWIT> startling: It's (Prelude..) not Prelude.(.)
21:25:53 <YayMe> how do I implement the declaration for Ord Foo a ? don't know off hand the syntax
21:25:54 <Cale> shachaf: (.) has this interesting bunch of naturality constraints because of the polymorphism in its type
21:26:06 <ion> The declaration?
21:26:19 <lightquake> YayMe: the deriving Ord implements it for you automatically
21:26:22 <DMWIT> YayMe: You've already implemented Ord for it by adding "deriving Ord" at the end.
21:26:24 <YayMe> what's the syntax real quick?
21:26:34 <ddarius> Cale: It's at least a category object (fudging a little, the little most people like to fudge)
21:26:35 <YayMe> lightquake: Nope. compiler error
21:26:55 <DMWIT> YayMe: Show us the actual code and the actual error.
21:26:56 <DMWIT> ?hpaste
21:26:56 <lambdabot> Haskell pastebin: http://hpaste.org/
21:27:05 <Cale> YayMe: instance Ord a => Ord (Foo a) where compare (Foo x) (Foo y) = compare x y
21:27:08 <shachaf> YayMe: If you read the error carefully, it'll tell you what to do.
21:27:17 <ddarius> shachaf: Reading is for losers.
21:27:19 <lightquake> ... oh, right
21:27:24 <lightquake> can't have Ord without that
21:27:34 <shachaf> ddarius: Oh no. :-(
21:27:41 <Cale> YayMe: Assuming that you want to remove the deriving Ord from the data declaration
21:27:46 <startling> DMWIT: oh what, why?
21:27:59 <shachaf> Cale: That'll fail with the same error as the "deriving Ord". :-)
21:28:01 <DMWIT> "why" is a terrible question to ask about syntax
21:28:05 <DMWIT> The answer is always "because".
21:28:15 <startling> DMWIT: oh
21:28:24 <startling> DMWIT: it's a special thing with ., then?
21:28:33 <DMWIT> No, all operators are the same.
21:28:38 <YayMe> thanks Cale, I couldn't remember the syntax off hand, I've been writing f# for my functional fix lately
21:28:46 <DMWIT> > (Prelude.+) 3 5
21:28:46 <ddarius> The name of the qualified operator is Prelude..
21:28:46 <startling> whaaat
21:28:47 <lambdabot>   8
21:28:51 <DMWIT> > Prelude.(+) 3 5
21:28:52 <lambdabot>   Not in scope: data constructor `Prelude'
21:29:02 <startling> whaaat
21:29:12 <ddarius> As ugly as it is, it is more consistent to do it this way.
21:29:38 <Cale> YayMe: Oh, right, Ord is a subclass of Eq, so make sure you provide an instance of that as well.
21:30:00 <ddarius> > 1 `Prelude.take` "foo"
21:30:01 <lambdabot>   "f"
21:30:19 <lightquake> > (`Prelude.take`) 1 "foo"
21:30:21 <lambdabot>   <no location info>: parse error on input `)'
21:30:28 <Cale> YayMe: instance Eq a => Eq (Foo a) where Foo x == Foo y = x == y
21:30:28 <lightquake> not sure if i'm disappointed or relieved at that
21:30:29 <shachaf> For some strange reason you can't say (`foo`)
21:30:40 <YayMe> yeah, cale eq I did that too
21:30:42 <shachaf> Which is completely inconsistent, since you can say (`foo` y) and (x `foo`)
21:30:44 <YayMe> I gots it, thanks!
21:30:49 <lightquake> disappointed then
21:31:02 <ion> > (42 `succ`)
21:31:03 <lambdabot>   43
21:31:15 <ddarius> It seems completely reasonable to outlaw (`foo`).
21:31:22 <shachaf> > let (!) x = product [1..x] in (5!)
21:31:23 <lambdabot>   120
21:31:31 <shachaf> ddarius: Why?
21:31:40 <Cale> shachaf: because it's silly
21:31:53 <Cale> shachaf: (`foo`) would mean the same thing as foo
21:31:58 <ddarius> It doesn't seem like it would ever be anything other than a mistake and it's not something a code generator is likely to output.
21:32:11 <ddarius> > let in 3 -- Unlike this.
21:32:12 <lambdabot>   3
21:32:18 <ion> Outlawing it potentially complicates the parser, and it’s the programmer’s job to not write silly code.
21:32:20 <geekosaur> (`(`(`(`(`(`(`foo`)`)`)`)`)`)`)
21:32:27 <shachaf> Cale: So?
21:32:28 <lightquake> geekosaur: haha
21:32:40 <shachaf> (`(foo)`) is completely different.
21:32:41 <ddarius> ion: I don't think so, and it is the compiler's job to help catch errors.
21:32:56 <shachaf> `` isn't for expressions, it's for identifiers.
21:33:03 <shachaf> And "foo" is an identifier.
21:33:17 <shachaf> And (<operator>) turns an operator into a prefix thing.
21:33:38 <shachaf> And "`foo`" is an operator.
21:33:40 <DMWIT> `(long expression)` should totally be allowed
21:33:53 <hpaste> YayMe pasted “tree ikmplementation” at http://hpaste.org/74327
21:34:05 <YayMe> Trying to learn an avl tree, how's this for an implementation of a tree data structure to start attempting balancing algorithms etc: http://hpaste.org/74327
21:34:26 <YayMe> Stupidly over-complicated?
21:34:36 <DMWIT> um, kind of terrible?
21:34:38 <Cale> YayMe: It's not recursive enough.
21:34:43 <DMWIT> This tree can contain at most two values.
21:34:52 <shachaf> That tree is not a tree.
21:35:01 <YayMe> haha
21:35:05 <ddarius> shachaf: Sure it is.
21:35:06 <YayMe> right.. there's that
21:35:12 <YayMe> just a very small one
21:35:13 <Cale> Maybe start with  data Tree a = Tip | Branch a (Tree a) (Tree a) deriving (Eq, Ord, Show)
21:35:13 <ddarius> A stubby tree, but still a tree.
21:35:16 <ion> Call it Bonsai.
21:35:36 <YayMe> I was meaning to allow a to be Tree
21:35:40 * ddarius doesn't see why the tree needs to be an instance of Eq or Ord.
21:35:50 <YayMe> but if one Node has Tree for it's type, every node needs Tree for it's type, no?
21:36:18 <Cale> YayMe: I suppose you could do something like construct the tree type as an explicit fixed point of a functor
21:36:26 <lightquake> too fast!
21:36:34 <DMWIT> Oh, you're going to add the recursion back in manually? I wouldn't really recommend that for a learning exercise about AVL trees.
21:36:44 <Cale> YayMe: and use   data Mu f = In { out :: f (Mu f) }
21:36:50 <DMWIT> It's fine for a learning exercise about fixpoint types, though.
21:36:55 <Cale> YayMe: But that's a more advanced tactic
21:37:15 <ddarius> This tree type wouldn't work well for an AVL tree anyway.
21:38:43 <YayMe> The recursive type where of Tree a where a :: Tree was just the first thought I had for making a tree
21:47:32 <YayMe> Is it presumed when I read about a "balanced binary tree" that it's sorted accurately, or just that it's evenly balanced save for the bottom tier
21:48:05 <shachaf> If something says "balanced" it means it's balanced.
21:48:31 <YayMe> Doesn't mean it's sorted though?
21:48:58 <ddarius> shachaf: Also, does it mean it's green?
21:48:58 <Cale> YayMe: Usually that's implied by the "search tree" part.
21:49:01 * hackagebot esqueleto 0.2 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2 (FelipeLessa)
21:49:15 <YayMe> Cale: So if it doesn't say "search" tree it's not implied to be sorted?
21:49:22 <Cale> rigth
21:49:24 <Cale> right*
21:49:58 <YayMe> 10 years of writing large CRUD apps for corporotocracy and I've never had to touch any of this stuff.. makes me feel like a retard again to not know such basic shit
21:50:12 <YayMe> Better late than never
21:51:48 <YayMe> I've got Knuth's the art of computer programming vol 1 Fundamental Algorithms, that a good book to start learning algorithm design and analysis from?
21:52:38 <Cale> YayMe: Something which deserves more attention are monoidally indexed trees. Almost every instance of using trees throughout computer science is in some way also using a monoid to label the branch nodes of the tree. The fact that the monoid has a unit means that we can handle the empty tree case uniformly, and the fact that it's associative means that we can rebalance the tree without having to recompute summaries of s
21:52:38 <Cale> ubtrees.
21:52:44 <YayMe> Looks old as sin, but I'm guessing most of this stuff hasn't changed much
21:53:14 * ddarius wonders if Church covered trees.
21:53:17 <Lamen> Hi, everybody. Just read an article on "differences between partial application and currying", here goes my question: does "+ 1" count as "partial application" or "currying"? TIA
21:53:31 <YayMe> Lamen: partial application
21:53:43 <ddarius> + 1 counts as a syntax error.
21:54:03 <frio> horrific flame bait
21:54:38 <Cale> Lamen: (+ 1) is section syntax, and it desugars to (\x -> x + 1), it is more closely related to partial application than to currying
21:54:39 <YayMe> Lamen: Currying would be plus = (+) and then plus 1 2
21:54:48 <Lamen> oopsby saying "+ 1",  I mean let f = (+) 1, in that sense.
21:54:59 <Cale> Lamen: Yeah, *that's* partial application
21:54:59 <shachaf> YayMe: That's not what currying would be.
21:55:15 <YayMe> shachaf: No?
21:55:28 <Cale> Currying is the process of taking a function of multiple parameters, and turning it into a function which takes a single parameter and produces another function as its result.
21:55:37 <ddarius> Currying is what curry does.
21:55:38 <YayMe> oh right
21:56:09 <Twisol> Cale: You mentioned monoidally indexed trees. That sounds really interesting - do you know of any references I can read?
21:56:09 <shachaf> > length "+ 1" -- no syntax error!
21:56:10 <lambdabot>   3
21:56:27 <Cale> Twisol: Oddly enough, the only reference I have is the Finger Tree paper
21:56:37 * ddarius doesn't find that odd.
21:56:47 <Cale> Twisol: Which is *bizarre* because this is like an idea which ought to be from the 1960's or even earlier
21:56:51 * ddarius didn't write "'+ 1'"
21:57:05 <Cale> But it's not, it's like, a couple years old
21:57:17 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
21:57:26 <shachaf> ddarius: Now '+ 1' is a syntax error.
21:57:28 <ddarius> If only computer scientists knew anything about monoids.
21:57:35 <Cale> ddarius: lol
21:57:43 <ion> > length "'+ 1'"
21:57:44 <lambdabot>   5
21:57:44 <shachaf> I know a guy who can get you monoids cheap.
21:57:52 <Twisol> I can see how something like a trie would be monoidally indexed, but what about a BST?
21:57:59 <ion> Meh, i just pirate my monoids.
21:58:00 <Cale> It's not like the entirety of the theory of formal languages is essentially the theory of monoids or anything.
21:59:01 * hackagebot esqueleto 0.2.1 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2.1 (FelipeLessa)
21:59:07 <Lamen> ButI've heard that functions in haskell are actually unary functions, so ain't no such thing as "currying" at all?
21:59:15 <ddarius> Currying is what curry does.
21:59:21 <ion> @type curry
21:59:22 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:59:23 <ddarius> Cale: You can't expect people familiar with regular expressions to know about monoids.
21:59:26 <Cale> Lamen: Well, we also have tuples
21:59:35 <shachaf> curry :: (Pair a a -> b) -> a -> a -> b
21:59:38 <shachaf> Er.
21:59:41 <shachaf> curry :: (Pair a -> b) -> a -> a -> b
21:59:57 <ion> curry :: (Pair a b -> c) -> a -> b -> c
22:00:27 <Lamen> ddarius: now I see what you meanstupid me :)
22:00:38 <lpvb> what does "subject to fusion" mean?
22:01:06 <shachaf> @google nuclear fusion
22:01:07 <lambdabot> http://en.wikipedia.org/wiki/Nuclear_fusion
22:01:07 <lambdabot> Title: Nuclear fusion - Wikipedia, the free encyclopedia
22:01:17 <ddarius> lpvb: It means "you need to provide more contexts to your questions".
22:01:32 <startling> wow, makeLenses is clever
22:01:32 <Twisol> guessing Data.Text functions
22:01:49 <startling> it even works for incomplete field functions
22:02:23 <lpvb> Data.Text functions
22:02:38 * ddarius should find a new Conor talk.
22:02:39 <Cale> Twisol: BSTs are more or less indexed by the Last monoid.
22:03:01 <shachaf> There should be a Least monoid.
22:03:04 <Cale> Twisol: I guess that's not *quite* an identical structure, but it's more or less equivalent.
22:03:37 <lpvb> Forget my quesiton, I see where they explain it
22:03:56 <Cale> Twisol: and you can get priority-queues by indexing using another Maybe-like monoid which takes the max of the priorities
22:05:02 <Cale> (and has a representation of -infinity)
22:05:32 <Twisol> and Maybe just checks for Nothing before deferring to the inner monoid?
22:05:57 <shachaf> Defer to your inner monoid!
22:05:58 <Cale> Well, I don't mean that it's actually Maybe
22:06:02 <shachaf> (Should be your inner semigroup.)
22:06:07 <Twisol> :P
22:06:14 <Cale> (but yes, that's what the instance of Monoid for Maybe does)
22:06:15 <Twisol> Cale: Just trying to find my footing.
22:06:22 <Cale> So something like:
22:06:45 <Cale> data Prio a = MinusInfinity | Prio a
22:06:54 <Cale> instance (Ord a) => Monoid (Prio a) where
22:07:05 <Cale>   mempty = MinusInfinity
22:07:18 <Cale>   mappend MinusInfinity p = p
22:07:24 <Cale>   mappend p MinusInfinity = p
22:07:34 <shachaf> Isn't there a Data.Monoid.Max or something that does that?
22:07:37 <Cale>   mappend (Prio p) (Prio q) = Prio (max p q)
22:07:47 <ddarius> > Max mempty
22:07:48 <lambdabot>   Not in scope: data constructor `Max'
22:07:58 <Cale> shachaf: I don't think so, but it would be a nice idea.
22:08:00 <ddarius> > Data.Monoid.Max mempty
22:08:01 <lambdabot>   Not in scope: data constructor `Data.Monoid.Max'
22:08:04 <ddarius> @hoogle Max
22:08:05 <lambdabot> Prelude max :: Ord a => a -> a -> a
22:08:05 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
22:08:05 <lambdabot> Prelude maxBound :: Bounded a => a
22:08:05 <shachaf> Looks like there isn't.
22:08:33 <Cale> There is Last though
22:08:37 <ddarius> @google site:hackage.haskell.org inurl:package/semigroups Max
22:08:38 <lambdabot> No Result Found.
22:08:52 <Twisol> Cale: And by "indexed" it means that it's the search "key" used to find a value?
22:09:04 <shachaf> Aha, semigroups has it.
22:09:20 <shachaf> https://github.com/ekmett/semigroups/blob/master/Data/Semigroup.hs#L205
22:09:26 <randomclown> @pl \x -> f x x
22:09:26 <lambdabot> join f
22:09:34 <Cale> Twisol: yeah, you have some way to take the elements stored at the leaves of the tree, and turn them into values in your monoid
22:09:57 <shachaf> Oh, that's not the same Max.
22:09:57 <Cale> Twisol: and then whenever you combine subtrees, you mappend their monoidal summaries
22:10:27 <shachaf> @let sam = min
22:10:29 <lambdabot>  Defined.
22:10:33 <Twisol> This is interesting, because I just recently found that Java's Collection<E> interface defines that find() takes an Object, not necessarily an E. So you can pass anything so long as its equals method handles Es gracefully.
22:10:40 <shachaf> @ty let n = (&&&) in (sam `n` max)
22:10:41 <lambdabot> forall b. (Ord b) => b -> (b -> b, b -> b)
22:10:53 <ddarius> shachaf: What other Max are you thinking of?
22:10:57 <shachaf> Hmm, not quite the function I was thinking of.
22:11:03 <Cale> Twisol: For just a sequence datatype, you would "measure" each element into a monoid value by just giving it the value 1, and using the additive monoid
22:11:13 <Cale> Twisol: and then your summaries are the sizes of the trees
22:11:37 <Cale> Twisol: which means that (assuming balancing), you can efficiently get to the kth element
22:11:47 * ddarius should play Sam & Max Hit the Road again.
22:11:49 <shachaf> ddarius: The one that Cale defined, with the Maybe.
22:11:53 <Cale> by examining the size on the left subtree
22:12:21 <ddarius> shachaf: Yes, that would be Option . Max.
22:12:35 <shachaf> Right.
22:12:52 <shachaf> Except composition like that is always such a hassle.
22:12:59 <Twisol> Cale: I'm having a tough time visualizing concrete values for the tree sizes and how they'd be used.
22:13:09 <shachaf> Twisol: Concrete and trees don't mix.
22:13:13 <Twisol> :P
22:13:16 <Cale> Twisol: If you know how many leaves each subtree has
22:13:41 <Twisol> Oh.
22:13:42 <Cale> Twisol: then you can tell whether the kth leaf is in the left or right subtree
22:13:51 <ddarius> "Today I found Java's collection library is horribly broken.  So... same old, same old."
22:13:52 <Twisol> if k > size then right subtree, else left subtree
22:14:06 <Twisol> ddarius: That was my reaction too.
22:14:09 <Cale> yeah, where size is the size of the left subtree
22:14:21 <Twisol> Cale: Okay, that makes sense.
22:14:54 <ddarius> shachaf: We should implement type level higher order pattern unification as that paper a while back suggested.
22:15:04 <shachaf> Which paper?
22:16:59 <Cale> Twisol: and you can also do efficient interval trees (representing a set of intervals in R, say), by ordering the intervals by their lower endpoints, and measuring the interval (a,b) using (Last (Just a), Prio b)
22:17:10 <ddarius> Maybe it was something simpler than pattern unification.
22:17:29 <Twisol> Cale: I'll be honest, you lost me with that one. I see the pattern though!
22:17:30 <ddarius> @google "Type Classes with More Higher-Order Polymorphism"
22:17:31 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.7505
22:17:31 <lambdabot> Title: CiteSeerX — Type Classes With More Higher-Order Polymorphism
22:17:58 <shachaf> Cale: That sounds nifty.
22:18:11 <Cale> Twisol: So, for any subtree, we know what the largest low endpoint in that subtree is, and we know that the largest high endpoint is.
22:18:16 <Twisol> Cale: Can I assume such a thing would be useful for, say, checking if the mouse is within one of several bounding boxes?
22:18:27 <Cale> Twisol: yes
22:18:46 <Cale> Twisol: Or, say, trying to schedule appointments
22:18:49 <stj> is it possible to call functions out of scope (at least in ghci), like function g in this example? f x = g x + 1 where g x = x + 3
22:18:51 <Twisol> hmm, yes
22:19:03 <stj> I find it very annoying to move inner function outside when testing and then back again
22:19:06 <ddarius> Exercise to the reader: Generalize this to represents GiSTs.
22:19:17 <shachaf> stj: That's not out of scope.
22:19:31 <shachaf> stj: Well, outside the body of f it is. And you can't call it outside of f, if that's what you're asking.
22:19:42 <stj> oh :(
22:19:57 * shachaf wonders why that's sad.
22:20:04 <ddarius> In general, g could depend on something in f so that wouldn't even make sense.
22:20:24 <Twisol> if it can live on its own, it probably should
22:20:28 <Cale> Twisol: So there's this large wealth of datastructures which you can describe all at once like this
22:20:32 <shachaf> If you want a definition to be top-level accessible, and it happens not to use anything in f, make it a top-level definition.
22:20:43 <shachaf> If one of those isn't true, then it doesn't make sense for it to be top-level accessible.
22:20:50 <Cale> Twisol: and you'll note that we've also abstracted the interface here from the strategy used to balance the trees
22:20:59 <Twisol> Cale: This whole thing reminds me a bit of functors and free monads, too.
22:21:42 <stj> shachaf: yes, but I often write helper functions named "go", which pollute the namespace :)
22:22:09 <Twisol> there are only two truly difficult problems in computer science
22:22:13 <Twisol> cache invalidation and...
22:22:29 <Cale> Twisol: the fact that the indices are monoidal lets us do practically whatever we want to balance the tree, or in the case of FingerTrees, we weirdly pull the subtrees at the two ends upward to make them easier to access, and the thing looks... well, it's graph theoretically still a tree, but it's not what you'd usually think of as one in CS :)
22:22:36 <shachaf> Twisol: Coming up with new jokes?
22:22:45 <Twisol> It's not a new one :)
22:22:50 <shachaf> I noticed.
22:23:00 <Twisol> I thought it was relevant.
22:23:25 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.pdf
22:23:31 <Cale> very very cool paper
22:23:44 <Twisol> Cale: I can't even visualize the weird pulling up thing.
22:23:54 <Twisol> Thanks for the link!
22:23:56 <Cale> (look on page 4)
22:24:01 <Cale> There's a picture of it
22:24:05 <stj> another annoying thing is: I write code, load it in ghci, do some changes, try to load but it fails, then I'm stuck with nothing while I'd like to at least have the previous version of valid code loaded -- does that happen to you and how do you handle it?
22:24:13 <Twisol> Cale: That looks like a spider :|
22:24:19 <ddarius> You try shachaf.
22:24:55 <shachaf> @yarr
22:24:55 <lambdabot> Swab the deck!
22:25:00 <shachaf> How's that?
22:25:11 <stj> in that case I often revert back to old code so I can test more and then redo changes :|
22:25:21 <Cale> Twisol: The cool thing about finger trees, is that you get O(1) access to both ends, and you can split them at an arbitrary point (which you usually use the monoidal information to locate), in time which is proportional to the log of the smaller side of the split.
22:25:42 <shachaf> @quote ddarius
22:25:42 <lambdabot> ddarius says: [I] didn't say that that category theory was safe for work.
22:25:51 <Cale> Twisol: and so you can access them at an arbitrary point in that amount of time as well.
22:27:14 <Twisol> Cale: It is a little reminiscent of zippers.
22:27:20 <Cale> Yeah, a little
22:27:31 * ddarius doesn't believe that "quote."
22:27:34 <Cale> Twisol: and so Data.Sequence is based on finger trees, and there's also a more general version on Hackage
22:28:02 <Twisol> I should probably read up a little on 2-3 trees.
22:28:16 <Cale> http://hackage.haskell.org/package/fingertree-0.0.1.1
22:28:56 <Cale> I also wrote a little example here (purely for the sake of example, the PSQueue library is more efficient): http://hackage.haskell.org/package/fingertree-psqueue
22:29:06 <startling> how do I get with a lens from `lens`?
22:29:33 <Cale> startling: ^.
22:29:57 <Cale> startling: myValue ^. myLens
22:30:02 <startling> is there a not-infix version?
22:30:05 <shachaf> view
22:30:21 <Cale> yeah, view
22:30:24 <startling> ah, thanks
22:30:25 <QinGW> afternoon
22:30:58 <Cale> and there's .~ and set
22:31:01 <Cale> for setting
22:31:10 <shachaf> λ> view _1 (1,2) Loading package array-0.4.0.0 ... linking ... done. Loading package deepseq-1.3.0.0 ... linking ... done. Loading package containers-0.4.2.1 ... linking ... done. Loading package bytestring-0.9.2.1 ... linking ... done. Loading package semigroups-0.8.3.2 ... linking ... done. Loading package transformers-0.3.0.0 ... linking ... done. Loading package comonad-3.0.0.1 ... linking ... done. Loading package contravariant-0.2.0.2 ...
22:31:16 <shachaf> ... ... linking ... done. Loading package distributive-0.2.2 ... linking ... done. Loading package semigroupoids-3.0 ... linking ... done. Loading package comonad-transformers-3.0 ... linking ... done. Loading package mtl-2.1.2 ... linking ... done. Loading package comonads-fd-3.0 ... linking ... done. Loading package filepath-1.3.0.0 ... linking ... done. Loading package text-0.11.2.2 ... linking ... done. Loading package hashable-1.1.2.3 ... ...
22:31:21 <Cale> shachaf: lol
22:31:22 <shachaf> ... linking ... done. Loading package parallel-3.2.0.3 ... linking ... done. Loading package pretty-1.1.1.0 ... linking ... done. Loading package template-haskell ... linking ... done. Loading package unordered-containers-0.2.1.0 ... linking ... done. Loading package lens-2.6.1 ... linking ... done. 1
22:31:27 <shachaf> Ah, edwardk.
22:31:56 <ddarius> shachaf: That's what GHCi looks like for pretty much everything nowadays.
22:32:11 <Cale> Is there a way to turn those messages off, I wonder...
22:32:19 <lpvb> I can't convert a String literal -> Lazy.ByteString?
22:32:58 <Cale> lpvb: There are many ways to do that.
22:33:09 <shachaf> Cale: Yes, turning down the verbosity.
22:33:14 <rwbarton> you certainly can convert, but for starters you need to pick an encoding
22:33:20 <shachaf> ghci -v0
22:33:22 <Cale> lpvb: The simplest (and least correct) way is to use  Data.ByteString.Lazy.Char8.pack
22:33:28 <shachaf> Hey, it's an rwbarton.
22:33:33 <rwbarton> howdy
22:33:45 <Twisol> I think this should work too: Data.Text.Encoding.encodeUtf8 . T.pack
22:33:55 <Cale> lpvb: But this will mangle any characters with value over 255
22:33:57 <Twisol> *Data.Text.pacl
22:33:58 <Twisol> *pack
22:34:11 <Cale> yeah, you really want to use Data.Text
22:34:23 <Cale> if you're converting from String
22:34:30 <Twisol> though I'm not sure whether it returns a strict or lazy ByteString
22:34:33 <shachaf> Cale: When you tell people "this is the simplest way to do X", they'll just do that.
22:35:53 <ddarius> The simplest and less incorrect way is to use const empty
22:36:01 <Cale> lol
22:36:36 <Cale> lpvb: So the actually-good way to do this, is to use Data.Text.Lazy.pack, and then one of the functions from here: http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text-Lazy-Encoding.html
22:36:53 <Twisol> well that makes sense. >_<
22:36:54 <Cale> which will turn the Text into a ByteString according to one of the UTF encodings.
22:37:08 <shachaf> What if I want to use UTF-7?
22:37:12 <lpvb> Cale: this works for String literals?
22:37:17 <Cale> lpvb: yes
22:37:24 <Cale> It works for an arbitrary String
22:37:52 <lpvb> String literals are polymorphic constants?
22:37:58 <Twisol> Could one enable OverloadedStringLiterals and rely on that to convert literals to lazy bytestrings?
22:38:00 <Cale> ... not usually
22:38:04 <shachaf> λ> T.pack "\55296"
22:38:04 <shachaf> "\65533"
22:38:10 <Cale> But they are if you turn on said extension.
22:38:19 <shachaf> Twisol: No, because ByteStrings aren't character strings.
22:38:21 <BMeph> shachaf: I think you meant: WTF-7? ;þ
22:38:55 * ddarius uses UTF-1.
22:39:02 <startling> eth is a much better emoticon mouth
22:39:12 <startling> :ð
22:39:18 <shachaf> ddarius: The "real" UTF-1 or the one where to encode codepoint n you have n 1 bits followed by a 0 bit?
22:39:23 <Twisol> sHACHAF: Data.ByteString[.Lazy].Char8 defines an IsString instance
22:39:27 <Cale> lpvb: It's important to realise that ByteString isn't really a representation of character strings, it's really what it sounds like: a sequence of bytes.
22:39:32 <shachaf> Twisol: A broken one.
22:39:39 <Twisol> okay.
22:39:42 <shachaf> Twisol: If you use it it makes you racist, I think.
22:39:47 <Twisol> wat
22:40:20 <shachaf> Twisol: Sorry. :-(
22:40:24 <rwbarton> @hackage iconv
22:40:25 <lambdabot> http://hackage.haskell.org/package/iconv
22:40:28 <rwbarton> shachaf: ^ :P
22:40:29 <Cale> lpvb: String on the other hand, being a list of Unicode characters, isn't straightforward to convert directly into a sequence of bytes.
22:40:58 <startling> Twisol: it throws out anything above ascii
22:41:17 <lpvb> Cale: thanks
22:41:18 <Cale> lpvb: When you use the various String IO primitives, they do locale-specific conversion (which you can control using the TextEncoding-related stuff in System.IO)
22:41:36 <startling> or does it truncate? I don't remember
22:41:39 <lpvb> I'll keep that in mind
22:42:01 <shachaf> rwbarton: OK, what if I want UCS-2.625?
22:42:25 <startling> shachaf: maybe you should question your wants
22:42:38 <Cale> shachaf: THEN WRITE IT YOURSELF
22:42:39 <startling> shachaf: might be time for some introspection
22:42:42 * shachaf wrote an actual UCS-2.625 implementation for Data.Text.
22:42:52 <ddarius> shachaf: I'm not sure which of those is less efficient.
22:42:58 <startling> shachaf: for fun?
22:43:14 <shachaf> That's the thing edwardk mentioned once where you pack three 21-bit codepoints in a 64-bit machine word, with an extra bit left over.
22:43:54 <startling> wow
22:44:04 <ddarius> Why would you waste a bit?
22:45:00 <Cale> ddarius: To future-proof it by providing a way to specify that the codepoints are longer and the next word has their continuations.
22:45:18 <Cale> :D
22:45:21 <shachaf> I was going to hide useful things in the extra bits.
22:45:38 <ddarius> Also, what if I only want one codepoint?
22:46:03 <shachaf> Feel free to only use one codepoint.
22:46:06 <Twisol> sHACHAF: Steganography, eh?
22:46:22 <shachaf> I'm not sure why you're calling me that, tWISOL.
22:46:49 <Cale> SHACHAF YOU KNOW VERY WELL WHY
22:46:56 <Twisol> >_<
22:46:57 <lpvb> Cale: so when I'm working with binary IO, I get ByteStrings which I need to convert to Text types?
22:47:09 <shachaf> lpvb: You need to decode the bytes into text, yes.
22:47:13 <Cale> lpvb: yes
22:47:15 <shachaf> If they represent text.
22:47:17 <lpvb> okay
22:47:25 <Twisol> The idea of "binary" is that you're explicitly saying there's no encoding, it's just bytes.
22:47:50 <Twisol> and it's up to you to layer back on any meaning you want
22:47:59 <Botje> bv
22:47:59 <rwbarton> there's also Data.Text.IO which is about what it sounds like
22:48:31 <ddarius> rwbarton: Ha ha ha, why would I use a function to read text if I wanted to read text?
22:48:33 <rwbarton> if you are really just trying to do text io
22:48:40 <rwbarton> :(
22:48:41 <Gnar_> Hello.
22:49:18 <shachaf> @yarr Gnar_
22:49:18 <lambdabot> Arr! Me ship be the biggest brig in the port!
22:52:49 <rwbarton> can you mix Data.Text.IO functions and Data.ByteString IO functions on the same handle?
22:53:38 <ddarius> With these new GHC IO functions, you may have to do something, but besides that, why wouldn't you?
22:54:03 * hackagebot QuasiText 0.1.2.5 - A QuasiQuoter for Text.  http://hackage.haskell.org/package/QuasiText-0.1.2.5 (MikeLedger)
22:54:30 <Twisol> new IO functions?
22:56:54 * ddarius thinks it may be best to cast his problem as a model selection problem.
22:57:14 <shachaf> (model_selection_problem_t)problem
23:00:16 <Enigmagic> at least use reinterpret_cast<>
23:00:37 <shachaf> I think that's a syntax error in C.
23:00:49 <shachaf> Hmm, maybe not.
23:00:50 <Enigmagic> C should have better casts
23:01:40 <shachaf> reinterpret_cast<x>(y) is prefectly valid C.
23:01:51 <Dtgr> no, it's not.
23:01:53 <shachaf> Unless x is a type, of course.
23:01:54 <Dtgr> that's c++
23:02:01 <shachaf> Dtgr: No, I'm talking about C.
23:02:08 <Enigmagic> :P
23:02:31 <shachaf> typedef int x; x foo(x x) { return x; } is also valid C!
23:03:11 <Dtgr> there's no reinterpret_cast in c
23:03:11 <Dtgr> sorry
23:03:23 <Dtgr> well, there is, but the syntax is different
23:03:24 <shachaf> Dtgr: int reinterpret_cast = 0; int x = 1; int y = 0;
23:03:36 <shachaf> reinterpret_cast<x>(y) == 1
23:04:02 <startling> :D
23:04:43 <rwbarton> is int a keyword or something
23:04:47 <startling> shachaf: that'll be useful for writing polyglots !
23:04:50 <Pseudonym> It's valid C/C++. After all, everyone knows that C/C++ is a language.
23:04:55 <BMeph> shachaf: -1, in some jueeisdictions. :þ
23:05:09 <BMeph> Er, *jurisdictions.
23:05:20 <Enigmagic> @karma c
23:05:20 <lambdabot> c has a karma of 1
23:05:25 <Enigmagic> @karma c/c
23:05:25 <lambdabot> c/c has a karma of 254
23:05:40 <Cale> http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html
23:05:41 <Pseudonym> @karma karma karma karma karma chameleon
23:05:41 <lambdabot> karma has a karma of 0
23:05:49 <Pseudonym> Worth a check.
23:05:58 <Enigmagic> karma++
23:06:00 <startling> c/c++
23:06:03 <BMeph> Pseudonym: Eh, it comes and goes... ;þ
23:07:33 <johnw> if I define a function fromChar :: Char -> Int, and call it with a literal character, will GHC be able to constant fold?
23:07:47 <shachaf> johnw: Try it out!
23:08:12 <johnw> you want me to read the assembly?
23:08:14 <Twisol> Constant fold?
23:08:22 <johnw> inline the result
23:08:29 <Twisol> Ahh.
23:08:45 <Cale> johnw: -ddump-simpl and you'll be able to see the intermediate representation after the simplifier has run over it
23:08:52 <Pseudonym> I would say that it depends how you write the function.
23:08:54 <shachaf> johnw: Reading the Core is probably sufficient.
23:09:22 <startling> oh, btw: does id cost anything? does a $ b produce a longer thunk than a b?
23:09:29 <shachaf> johnw: But in general when you have specific questions about what the optimizer does, being able to look at what the optimizer does is a good way to answer that sort of question.
23:09:37 <Pseudonym> Having said that, don't forget that if you make it a CAF, it will be evaluated at most once.
23:09:38 <shachaf> startling: a $ b should be optimized into a b
23:09:44 <johnw> shachaf: I kind of wanted to hear "yes" or "no" :)
23:09:46 <shachaf> startling: But map id xs may not be optimized into xs.
23:09:55 <startling> shachaf: k. good to know
23:10:28 <Pseudonym> shachaf: map id xs should be optimised to a deforested something. So it might be, actually.
23:10:39 <shachaf> Pseudonym: OK, fmap id foo
23:12:34 <startling> oh also: does OverloadedStringLiterals run at runtime or compiletime?
23:12:47 <shachaf> The extension runs at a compile-time.
23:12:48 <Cale> I wonder where the rest of the C/C++ RFEs went. They were pretty funny.
23:12:56 <shachaf> All it does is turn "foo" into (fromString "foo")
23:13:06 <startling> shachaf: k, that's what I meant to ask
23:13:49 <shachaf> startling: Whether the fromString will "happen at compile-time" probably depends on a bunch of things.
23:14:02 <Ralith> How do I convert a Double to a CDouble?
23:14:43 <Cale> Ralith: realToFrac is the really correct way
23:15:21 <Ralith> kk
23:15:57 <Cale> Ralith: If that turns out to be a bottleneck, it's typically possible to use a rewrite rule which turns the realToFrac into an unsafeCoerce.
23:16:00 <shachaf> @hoogle Double -> CDouble
23:16:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:16:00 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
23:16:00 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
23:16:09 <Cale> shachaf: LOL
23:16:16 <shachaf> Trusty old @hoogle.
23:16:30 <startling> can't you unsafeCoerce anything?
23:16:47 <Ralith> Cale: it won't
23:16:47 <Cale> startling: yes, but it'll usually crash
23:16:48 <shachaf> @hoogle Cale -> Shachaf
23:16:49 <lambdabot> Warning: Unknown type Cale
23:16:49 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:16:49 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
23:17:02 <startling> why doesn't unsafeCoerce show up for every hoogle?
23:17:15 <shachaf> It probably does, if you're looking for a function.
23:17:16 <startling> shachaf: you must be more well-known than Cale
23:17:20 <shachaf> And you look far enough.
23:17:27 <Cale> startling: It's just a matter of where in the list it appears
23:17:58 <Pseudonym> Maybe it's that Cale is naturally covariant.
23:17:58 <startling> @hoogle [Int] -> IO [[[String]]]
23:17:59 <lambdabot> No results found
23:18:36 <startling> @hoogle Int -> Map
23:18:37 <lambdabot> Did you mean: Int -> Map a a
23:18:37 <lambdabot> Prelude (!!) :: [a] -> Int -> a
23:18:37 <lambdabot> Data.List (!!) :: [a] -> Int -> a
23:18:52 <Pseudonym> @hoogle Int -> Map Int Int
23:18:53 <lambdabot> Data.Map singleton :: k -> a -> Map k a
23:18:53 <lambdabot> Data.Map deleteAt :: Int -> Map k a -> Map k a
23:18:53 <lambdabot> Data.Map updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
23:19:07 <shachaf> @hoogle+
23:19:07 <lambdabot> Data.Map delete :: Ord k => k -> Map k a -> Map k a
23:19:07 <lambdabot> Data.Map adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
23:19:07 <lambdabot> Data.Map updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
23:19:08 <shachaf> @hoogle+
23:19:08 <lambdabot> Data.Map adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
23:19:08 <lambdabot> Data.Map update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
23:19:09 <lambdabot> Data.Map alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
23:19:09 <shachaf> @hoogle+
23:19:11 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
23:19:13 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
23:19:13 <shachaf> Keep going in /msg.
23:19:15 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
23:19:21 * shachaf overspammed. :-(
23:29:04 * hackagebot egison 2.4.2 - An Interpreter and Compiler for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.4.2 (SatoshiEgi)
23:32:09 <johnw> has anyone had the problem of ghc-pkg recache not updated their package.cache?
23:32:27 <lpvb> which packages are imported by default?
23:32:39 <lpvb> System.*?
23:32:48 <shachaf> System.* isn't a package.
23:32:48 <donri> lpvb: just Prelude
23:33:06 <lpvb> The IO monad instance is defined in System.IO
23:33:32 <shachaf> No, it's defined in GHC.Base.
23:33:36 <shachaf> But what does that have to do with it?
23:33:37 <startling> lpvb: and it's imported into Prelude
23:33:46 <lpvb> startling: oh okay
23:41:01 <lpvb> where do I see a list of deprecated Prelude stuff?
23:41:36 <lpvb> also, are all packages beside Prelude not included with GHC?
23:41:58 <startling> lpvb: all the packages included with ghc are in the package `base`
23:42:07 <startling> lpvb: dunno what you mean by "deprecated Prelude stuff"
23:42:11 <Cale> wait, what?
23:42:17 <Cale> GHC comes with more than base, doesn't it?
23:42:32 <startling> I don't think so?
23:42:48 <startling> I could be wrong though
23:42:52 <lpvb> startling: deprecated functions like catch
23:42:58 <shachaf> GHC comes with a lot more than base.
23:43:01 <Cale> Do ghc-pkg list
23:43:02 <lpvb> startling: and Prelude is in bsae?
23:43:04 <Cale> you'll see
23:43:04 <lpvb> base*
23:43:40 <ddarius> First rule of Probability Club: All problems are model selection problems.
23:43:45 <Cale> (provided you only install packages as user, all the stuff which came with GHC will be separated)
23:44:02 <startling> oops, guess I'm wrong
23:44:42 <startling> lpvb: no idea where you'd look for deprecated functions
23:44:43 <lpvb> says my ghc came with xmonad
23:44:48 <Cale> heh
23:44:50 <beaky> besides map, fold, and filter, what are some very handy higher-order functions I must know like the back of my hand?
23:44:54 <lpvb> I guess it was installed when I installed xmonad
23:44:56 <Cale> Well, perhaps you installed xmonad globally
23:47:23 <startling> beaky: lenses
23:48:01 <beaky> lenses are new to me; what are they?
23:48:59 <startling> beaky: https://github.com/ekmett/lens/wiki/Tutorial
23:49:00 <dibblego> beaky: http://hackage.haskell.org/package/lens
23:49:04 * hackagebot simple-sendfile 0.2.7 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.7 (KazuYamamoto)
23:49:10 <BMeph> Lenses: They're lens-tastic! ;þ
23:49:35 <beaky> ah so they are like getters?
23:49:52 <beaky> and pseudo setters?
23:50:05 <johnw> i wonder what we're all going to get excited about next, after lenses
23:50:12 <beaky> lenses are awesome
23:50:22 <lpvb> johnw: braces
23:50:24 <beaky> is cons a lens?
23:50:25 <startling> beaky: yep, but more general
23:50:32 <startling> beaky: cons?
23:50:56 <beaky> the : function
23:51:30 <startling> beaky: I wouldn't call it a lens, and you definitely can't use it like a lens
23:51:46 <dibblego> head can be made a lens
23:51:57 <dibblego> a "partial lens" in data-lens parlance
23:52:06 <beaky> right
23:52:31 <dibblego> a traversal in lens parlance
23:52:36 <beaky> so apart from reduce and recursion, how do you perform iteration in a functional programming language like haskell?
23:52:45 <startling> beaky: folds mostly
23:53:09 <startling> beaky: most (all?) explicit recursion can be done with a fold
23:53:17 <beaky> foldl ftw
23:53:29 <dibblego> startling: foldr = []
23:53:52 <startling> dibblego: hm?
23:54:37 <dibblego> {-# LANGUAGE RankNTypes #-}
23:54:37 <dibblego> data List a = List (forall b. (a -> b -> b) -> b -> b)
23:54:42 <dibblego> List is isomorphic to []
23:55:08 <startling> dibblego: you lost me. :)
23:55:16 <beaky> so in a non-strict functional language like haskell, foldl (printMyName) [1..10] is as efficient as the C style `for (i = 0; i < 10; ++i) puts(beaky_name);`?
23:55:35 <beaky> or will [1..10] make it consume 10 times more memory?
23:55:43 <startling> beaky: I wouldn't use foldl there
23:55:46 <dibblego> startling: the foldr function is the same thing as a list i.e. you can write any function with foldr where you could otherwise use a list
23:55:49 <startling> beaky: i'd do replicateM
23:56:08 <dibblego> startling: this is true for all "fold" functions (maybe, either)
23:56:10 <startling> dibblego: oh, I see what you mean
23:56:11 <beaky> right
23:56:33 <beaky> how does replicateM work?
23:56:47 <startling> beaky: I don't think [1..10] would consume much more memory
23:56:49 <dibblego> beaky: in what sense? it just... works right?
23:56:52 <startling> :t replicateM
23:56:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
23:57:08 <startling> @src replicateM
23:57:08 <lambdabot> replicateM n x = sequence (replicate n x)
23:57:26 <startling> :t sequence
23:57:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:57:31 <dibblego> boo
23:57:34 <beaky> so it's recursion?
23:57:39 <dibblego> @type Data.Traversable.sequenceA
23:57:40 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
23:57:49 <startling> beaky: no. it calls `replicate`, not `replicateM`
23:58:07 <dibblego> beaky: replicateM runs the given monadioc effect n times and collects their result
23:58:09 <startling> > replicate 3 "hello"
23:58:10 <lambdabot>   ["hello","hello","hello"]
23:58:23 <shachaf> > replicateM 3 "hello"
23:58:24 <lambdabot>   ["hhh","hhe","hhl","hhl","hho","heh","hee","hel","hel","heo","hlh","hle","h...
23:58:37 <startling> shachaf: >:(
23:58:37 <beaky> right
23:59:01 <dibblego> > replicateM 3 (*2) 8
23:59:02 <lambdabot>   [16,16,16]
23:59:03 <startling> shachaf: that's pretty cool actually
23:59:06 <beaky> so I foldL putStrLn replicateM 3 "beaky" ?
23:59:14 <startling> huh?
23:59:24 <startling> > replicateM (putStrLn "beaky")
23:59:25 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:59:25 <lambdabot>         against inferred type ...
23:59:38 <startling> > replicateM 3 (putStrLn "beaky")
23:59:39 <shachaf> beaky: You might want to read an introduction to Haskell syntax before using replicateM.
23:59:39 <lambdabot>   <IO [()]>
23:59:46 <beaky> right
23:59:53 <beaky> I'm still in chapter 2 of LYAH
