00:00:19 <companion_cube> mysticc: listings
00:03:54 <liyang> mysticc: lhs2TeX, and manual %format directives.
00:09:44 <Lamen> ÖI wonder if there's something like "lazy as pattern" in Haskell? :-P
00:10:21 <Lamen> combining both lazy pattern & as pattern
00:10:30 <Lamen> or there is one?
00:11:05 <Cale> Lamen: You can use both ~ and @ together
00:14:11 <Lamen> Cale: silly me! Written: ~xs'@(x:xs) right? Should've permuted that, thanks!
00:16:01 <Cale> Lamen: yeah, the ~ always needs to go around whatever constructor in the pattern you want to make lazy. You can also nest them in various weird ways that basically never come up.
00:16:22 <Nereid> is there any reason to write the pattern x@y ?
00:16:24 <Nereid> ever
00:16:36 <Cale> Where y is a simple variable?
00:16:38 <Nereid> yes
00:16:48 * liyang has done that before.
00:16:49 <Cale> Basically no
00:16:54 <Nereid> I'm full of silly questions today.
00:16:54 <Cale> but I guess you can
00:17:14 <Cale> > let f x@y = x + y in f 5
00:17:16 <lambdabot>   10
00:17:29 <kosmikus> you can even write x@y@z ...
00:17:33 <Nereid> indeed.
00:18:00 <liyang> When I've wanted to fill multiple fields of a record with the same value, with RecordWildCards.
00:19:11 <Cale> > let fun a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z = [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z] in fun 'A'
00:19:12 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAA"
00:19:18 <Nereid> lol
00:19:27 <Nereid> > let f (x@y)@z = 5 in f 9
00:19:28 <lambdabot>   <no location info>: parse error on input `@'
00:19:32 <Nereid> heh.
00:19:40 <Nereid> > let f x@(y@z) = 5 in f 9
00:19:41 <lambdabot>   5
00:19:42 <Nereid> yeah.
00:19:49 <Nereid> as I thought.
00:20:11 <Cale> liyang: oh wow
00:20:26 <Nereid> liyang: ah.
00:20:30 <Cale> haha, I hadn't thought of the interaction with RecordWildCards :)
00:20:35 <Nereid> that's cute.
00:22:09 <theplanet> what does that command do Nereid
00:22:17 <Nereid> what command.
00:22:26 <theplanet>  let f x@(y@z) = 5 in f 9
00:22:35 <Nereid> > let f x@y@z = (x,y,z) in f 5
00:22:36 <lambdabot>   (5,5,5)
00:22:52 <Nereid> it's a pointless use of @.
00:23:32 <Cale> theplanet: for any variable x and pattern p, the pattern x@p is a pattern which matches against p (binding whatever variables are in there), but also binds the whole matched thing to x
00:23:33 <Nereid> I guess one could expand it like this:
00:23:36 <hpaste> Lamen pasted ‚ÄúParentheses balancing‚Äù at http://hpaste.org/75400
00:23:47 <Nereid> let x@p = a in b
00:23:49 <Nereid> is the same as
00:23:59 <Nereid> let { x = a; p = x } in b
00:24:00 <Cale> > let x@(y:ys) = [1,2,3] in (x,y,ys)
00:24:00 <Nereid> or so?
00:24:01 <lambdabot>   ([1,2,3],1,[2,3])
00:24:05 <Lamen> Let me describe my question more precisely
00:24:09 <Nereid> (where p is a pattern)
00:24:33 <Nereid> (and x is a variable and a,b are expressions)
00:24:38 <Cale> Nereid: yeah, I suppose you can!
00:25:11 <Lamen> I want to combine this (')':cs) case togetherÖso I guess I need lazy pattern to handle the "" case
00:25:36 <Cale> Lamen: wait, what?
00:26:04 <Lamen> I've pasted my codeÖjust a simple "parentheses balancing" problem
00:26:44 <Cale> Lamen: Note that the pattern ~p always "succeeds" in matching, and then fails with an exception later if some variable bound in p is used and the pattern didn't actually match
00:27:02 <Cale> Lamen: So you usually only want to use ~p in the case that you *know* p will match
00:27:29 <Lamen> Cale: I was trying to check null ps' in the first patternÖ
00:28:03 <Lamen> sorry in guard statement
00:29:23 <Lamen> balanced (')':cs) ~ps'@(p:ps)
00:29:23 <Lamen>               | null ps'  = False
00:29:33 <Lamen> that was my first attempt
00:29:43 <Nereid> ps'@~(p:ps)
00:29:49 <Nereid> would mean what you want it to mean.
00:29:59 <Nereid> but I don't like it.
00:30:06 * liyang has done horrible things with multiple @s and ViewPatterns.
00:30:40 <liyang> Nereid: you need a space between the @ and ~.
00:30:53 <Cale> Lamen: your second list argument is morally a natural number
00:31:22 <Cale> Lamen: You seem to have made this more complicated than it needs to be
00:31:57 <Cale> There are only two cases for (')':cs)
00:32:17 <Nereid> > let x@~(y:ys) = [1] in (x,y,ys)
00:32:18 <lambdabot>   Not in scope: `ys'
00:32:23 <Nereid> > let x@(~(y:ys)) = [1] in (x,y,ys)
00:32:24 <lambdabot>   ([1],1,[])
00:32:28 <Cale> Either you have  balanced (')':cs) ""  which is False, as you have there
00:32:29 <Nereid> > let x@ ~(y:ys) = [1] in (x,y,ys)
00:32:30 <lambdabot>   ([1],1,[])
00:32:32 <Nereid> weird.
00:32:45 <Nereid> > let x@~(y:ys) = [1] in (x,y)
00:32:46 <lambdabot>   (x,y)
00:32:51 <Nereid> what
00:32:55 <Cale> or you have balanced (')':cs) (')':ps) in which case the result is the same as balanced cs ps
00:33:05 <Nereid> someone explain this
00:33:34 <basdirks_> While cleaning out our office yesterday I found me a Toshiba laptop from 1994 running MS DOS 6.22
00:33:43 <basdirks_> is there any haskell compiler that will run on it? : D
00:33:57 <Cale> > (x,y) -- Nereid
00:33:58 <lambdabot>   (x,y)
00:34:02 <Nereid> Cale: yeah I get that part
00:34:06 <Nereid> but why isn't it binding anything?
00:34:13 <Cale> It's binding @~
00:34:19 <Nereid> what
00:34:33 <Cale> > let x @~ y = x^2 + y^2 in 5 @~ 6
00:34:33 <Nereid> oh dear.
00:34:34 <lambdabot>   61
00:34:36 <Nereid> haha.
00:35:23 <Nereid> I didn't know you were allowed to put a space around @ though.
00:35:26 <Nereid> > let x @ y = 5 in (x,y)
00:35:27 <lambdabot>   (5,5)
00:35:45 <danr> how do you make an @-pattern and an irrefutable pattern at the same time then? :/
00:35:54 <Nereid> danr: space or parentheses
00:36:02 <Nereid> as I just did above
00:36:13 <danr> x@(~(y,z)) ?
00:36:17 <Nereid> yeah
00:36:21 <danr> Nereid: ok, ty
00:36:21 <Nereid> or x @ ~(y,z)
00:36:58 <danr> ah the important thing is that @ and ~ doesn't become the operator @~
00:37:01 <danr> interesting
00:37:02 <Nereid> yeah
00:37:03 <Cale> Nereid: for a while GHC's parser had a little bug in it, and you could write a program which would compile in any case but do different things based on whether you had the buggy parser. The bug was that the pattern x --> y would start a comment at the -- rather than defining the operator -->
00:37:03 <Lamen> Cale: you're right! Thanks for pointing that out
00:37:16 <Nereid> Cale: haha
00:37:37 <Nereid> -- has to be followed by whitespace to be a comment, right?
00:37:51 <Cale> It has to be followed by a non-symbol character
00:37:54 <Nereid> ah.
00:37:58 <Nereid> so --a is still a comment.
00:38:01 <Cale> right
00:38:12 <Nereid> damn syntax.
00:38:19 <Cale> but --| isn't, if you've ever used haddock
00:38:33 <Lamen> But what liyang said suddenly got meÖthat tiny little spaceÖthat's why I got "Parse error in pattern" before
00:38:35 <Nereid> I've seen haddock.
00:39:04 <Nereid> > let x@y:z = [1] in (x,y,z)
00:39:05 <lambdabot>   (1,1,[])
00:39:07 <Nereid> yeah.
00:39:08 <Cale> basdirks_: hmmmm!
00:39:40 <Cale> basdirks_: I don't know if there are any Haskell compilers which will straight up run on MS-DOS
00:41:09 <Cale> I wonder how hard it would be to get hugs to run
00:41:13 <Cale> It's written in C.
00:41:28 <hpaste> Lamen annotated ‚ÄúParentheses balancing‚Äù with ‚ÄúParentheses balancing (annotation)‚Äù at http://hpaste.org/75400#a75401
00:41:53 <liyang> Cale: it must have worked under DOS at some point, given its vintage.
00:42:17 <Lamen> hopefully it's now better than beforeÖ :-p
00:44:00 <Cale> basdirks_: Maybe ask on the haskell-cafe mailing list and one of the real old timers will be able to pull something pre-Haskell-98 out.
00:44:13 <basdirks_> cool, will do
00:48:04 <Cale> http://www.haskell.org/ghc/download_ghc_029 is the oldest GHC available on the download page, but it seems to only claim support for unixy systems
00:51:26 <basdirks_> hm
00:51:56 <basdirks_> I didn't inspect what ports the machine has yet, but the only physical media it accepts is floppy disks ^^
00:53:03 <Cale> I didn't even bother with a CD/DVD drive in my computer now :)
00:53:44 <basdirks_> yes, but I doubt this one (it's sitting at home now) has an internet connection
00:54:33 <Cale> yeah, it might take some act of heroism to get it onto a network
00:54:50 <liyang> Trumpet Winsock!
00:55:50 <augur> edwardk: can you summarize your unnatural transformations post in twitter size or less? :x
00:55:59 <edwardk> dolio wrote it
00:56:08 <edwardk> see author name? =)
00:56:34 <edwardk> basically "parametricity is not always the right notion of naturality"
00:57:07 <edwardk> with a concrete example of a functor for which the parametric solution is not the right condition to be natural
00:57:10 <augur> oh, well then, dolio!
00:57:11 <augur> :P
00:57:27 <edwardk> dolio has had you on /ignore for ~6 months i think ;)
00:57:37 <nomeata> Hi. Is there a testing library on hackage that is suited for running tests that are defined by a stand-alone-haskell program and possibly expected output?
00:57:41 <augur> really? huh. crazy.
00:57:56 <nomeata> Ideally it could test my library without installing it. Similar to how the GHC test suite works, I guess.
00:58:22 <augur> edwardk: so its saying that forall a. f a -> g a is not sufficient for being a natural transformation from f to g?
00:58:42 <augur> in many cases it is but that in some cases its not?
00:59:05 <edwardk> the functor in question is between hask and kleisli_M for some monad
00:59:49 <augur> aha ok.
01:00:10 <augur> so parametricity isnt sufficient for certain far-side categories
01:01:42 <Cale> There's something which kind of bothers me about the way we have to treat a lot of categorical concepts in Haskell. It seems we often end up smashing things down and folding them up into concepts which are vastly less general -- perhaps moreso than simple specialisation to Hask would at first suggest. But when we do this, we seem to get these things which still let us understand the more general concept surprisingly we
01:01:42 <Cale> ll, which is odd.
01:01:58 <Cale> (given how much we've stomped on them)
01:02:39 <augur> Cale: probably an advantage of analogistic thinking
01:03:21 <augur> if you can squint your eyes and pretend that things behave the way that you prefer to think of them, then as long as the way you reason is formally ok, you should get good results
01:03:42 <Cale> At least sometimes :)
01:03:53 <augur> want to think of exponential objects as function spaces? go for it, as long as the intuitions you use dont require inherently function-related properties
01:04:03 <Cale> right
01:04:52 <augur> i think CT is really revealing that a lot of those intuitions aren't inherently tied to particular things
01:04:58 <augur> tho some definitely are
01:05:06 <Cale> I have this vague feeling that there's something more going on than just that though.
01:05:17 <augur> oh?
01:05:42 <edwardk> well it seems to reveal that CT is rather more first order than perhaps it should be
01:06:03 <edwardk> its more natural to think of things all fibered or bundled up the way parametricity gives it to us many times
01:08:09 <Spockz> isn't there a way to install dependencies in parallel with cabal install?
01:08:25 <Spockz> I've heard some people talking about it but I can't find out how
01:09:14 <Cale> Spockz: interesting question. I've never attempted that.
01:09:45 <edwardk> Spockz: there are recent commits to add a -j N flag to cabal install
01:10:13 <Spockz> edwardk: yes but they will be in .16 right? Not in .14?
01:10:34 <edwardk> probably i don't know the versioning, just the patch =)
01:11:01 <Spockz> ok, so we'll just have to wait a little bit longer
01:11:08 <Spockz> a parallel GHC would be awesome :P
01:19:11 <viorel> Hi all. I would like to ask a newbie's question. If there is a better channel for Haskell beginners, please let me know
01:19:20 <Cale> viorel: You're in the right place :)
01:19:21 <opqdonut> this is it
01:19:27 <viorel> I am doing an exercise in "The Haskell Road to Logic"
01:19:55 <viorel> I have the solution, just I know that many times in Haskell you can get more elegant solutions
01:20:11 <viorel> so, the exercise is to define a function substring
01:20:22 <viorel> we are already given a function prefix
01:20:38 <Cale> Do you have tails?
01:20:41 <viorel> prefix xs ys is true if xs is a prefix of ys
01:20:58 <viorel> here's my primitive implementation of substring:
01:21:31 <viorel> substring xs [] = False
01:21:40 <viorel> substring xs (y:ys) | prefix xs (y:ys) = True
01:21:47 <viorel>                     | otherwise = substring xs ys
01:21:58 <Jafet> > [] `isInfixOf` []
01:21:59 <lambdabot>   True
01:22:07 <Cale> You probably want substring [] [] to be True, yeah
01:22:27 <viorel> great, thanks
01:22:29 <opqdonut> but otherwise, that's a  pretty good solution, IMO
01:22:37 <viorel> I did not realize I missed that edge case
01:22:40 <Cale> viorel: So, one nice way to do it
01:22:54 <viorel> also, thanks Jafet
01:22:57 <Cale> Is to use tails:
01:23:07 <Cale> @src tails
01:23:07 <lambdabot> tails []         = [[]]
01:23:07 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
01:23:25 <Cale> > tails "hello"
01:23:27 <lambdabot>   ["hello","ello","llo","lo","o",""]
01:23:55 <Cale> You can then apply prefix xs to each of the tails of ys, and see if any of those is True
01:24:16 <Cale> So  substring xs ys = any (prefix xs) (tails ys)
01:24:34 <viorel> beautiful
01:25:01 <Jafet>              = fmap tails . any . prefix
01:25:12 <Cale> hah
01:25:23 <Jafet> (obligatory)
01:25:31 <Jafet> Actually flip fmap
01:25:41 <Cale> @pl substring xs ys = any (prefix xs) (tails ys)
01:25:41 <lambdabot> substring = (. tails) . any . prefix
01:26:01 <Cale> yeah, I don't know how much I care for that, but it can be done
01:26:08 <viorel> thanks Jafet, Cale, lambdabot
01:26:46 <Cale> viorel: Feel free to ask lots of questions here
01:26:46 <viorel> I don't really understand all these, but I am writing this down
01:27:12 <viorel> thanks Cale
01:27:14 <Cale> viorel: yeah, removing the parameters from functions by force can produce hard-to-read code sometimes
01:27:15 <whald> > reverse "emoclew er'uoy"
01:27:16 <lambdabot>   "you're welcome"
01:27:22 <whald> :-)
01:27:36 <viorel> :)
01:27:54 <Cale> viorel: The basic idea is that if we can cleverly put some definition in the form  f x = (g . h) x
01:28:02 <whald> has the "total time" at the top of an profiling report anything to do with the wallclock time? or what the unix "time" command says?
01:28:06 <Cale> viorel: then we can "cancel the x" and get f = g . h
01:28:42 <Cale> viorel: So in our case, we had  substring xs ys = any (prefix xs) (tails ys)
01:28:55 <Cale> which is the same as (any (prefix xs) . tails) ys
01:29:10 <Cale> substring xs ys = (any (prefix xs) . tails) ys
01:29:20 <Cale> So  substring xs = any (prefix xs) . tails
01:29:33 <viorel> nice
01:29:49 <viorel> this is very nice
01:29:51 <Cale> but then getting rid of the xs requires some trickery
01:29:58 <viorel> I understand tails
01:30:09 <viorel> I need to understand any and .
01:30:14 <Cale> okay
01:30:17 <viorel> I understand simplification
01:30:18 <Cale> (f . g) x = f (g x)
01:30:34 <Cale> (.) is composition of functions
01:30:35 <viorel> ah, so the dot is simply the function composition
01:30:37 <Cale> yeah
01:31:03 <Cale> any p xs = or (map p xs)
01:31:09 <mcstar> also, you can end sentences with it
01:31:11 <Cale> are you familiar with map?
01:31:35 <viorel> great
01:31:37 <Cale> oh, it's soon :)
01:31:44 <viorel> this "any" is very intuitive
01:32:11 <Cale> map f [] = []
01:32:13 <viorel> yes, I've used map in python (although my understanding is that list comprehensions are preferred)
01:32:16 <Cale> map f (x:xs) = f x : map f xs
01:32:41 <Cale> or if you take list comprehensions as primitive:
01:32:48 <Cale> map f xs = [f x | x <- xs]
01:33:05 <viorel> this is nice
01:33:28 <Cale> (list comprehensions are syntax sugar for concatMap, so you could also see that as defining map using concatMap)
01:33:56 <Cale> okay, and then finally
01:34:07 <Cale> or [] = True
01:34:11 <mcstar> some messy things fit list comprehensions well, but i wouldnt say it is preferred
01:34:11 <Cale> er
01:34:14 <Cale> or [] = False
01:34:15 <viorel> ok, I'll read about concatMap
01:34:25 <Cale> or (x:xs) = x || or xs
01:34:30 <Cale> which is the same as
01:34:38 <Cale> or = foldr (||) False
01:35:01 <Cale> concatMap is morally the same thing as
01:35:11 <Cale> concatMap f xs = concat (map f xs)
01:35:23 <Cale> but you could also implement it directly by recursion
01:35:32 <frerich> Hrm, I just read "In Haskell, there's a datatype called Ordering, consisting of values LT, EQ and GT (for "less than", "equal", and "greater than"), which is used as the result of various operations to express how two things compare." on Reddit - all fine, very easy. The next sentence though: "It is an instance of Monoid under the following operation" makes me regret agreeing to tak e a full-time job instead of
01:35:32 <frerich>  finishing my studies. "instance of X under the following operation" must be some typical math expression?
01:35:56 <Cale> frerich: Okay, so there's this type class Monoid
01:35:58 <frerich> Something being 'under an operation' seems odd.
01:36:10 <Cale> ah, yeah, that's my mathy-speak shining through :)
01:36:30 <frerich> Cale: Err wait - you wrote that? :-)
01:36:58 <Cale> The c in cgibbard is Cale, yes :)
01:37:08 <Jafet> Is the "following operation" mappend?
01:37:16 <Cale> you can just take that as "using the following operation as the operation which Monoid specifies"
01:37:37 <Cale> frerich: It's like "under the influence of"
01:37:49 <Cale> that sort of "under"
01:38:17 <frerich> Cale: I *think* what you meant is that 'Ordering' can be considered an instance of Monoid if there's also a function '++' such that 'LT ++ y = LT', 'GT ++ y = GT' and 'EQ ++ y = y'.
01:38:20 <frerich> Cale: Hm I see
01:38:22 <Cale> yeah
01:38:36 <Cale> You use that ++ as the mappend operation
01:38:49 <Cale> and EQ as mempty
01:39:07 <frerich> Why is it called "mappend"? "appending" seems a little to... "concrete" (as opposed to abstract).
01:39:14 <Cale> heh, yeah
01:39:22 <Cale> But it's not far off the mark
01:39:28 <mcstar> <> == mappend
01:39:33 <mcstar> bit less concrete
01:40:49 <Cale> The list monoid is in some sense a "most general" monoid though
01:41:17 <Cale> It's like concatenation satisfies the monoid axioms and basically nothing else.
01:41:54 <frerich> For the list monoid I could use '++' instead of, well, the ++ in the example for Ordering and '[]' instead of EQ?
01:41:58 <Cale> yeah
01:42:03 <frerich> HHmmmm
01:42:20 <Cale> The rules for a monoid instance are that
01:42:23 <Cale> [] ++ ys = ys
01:42:33 <Cale> xs ++ [] = xs
01:42:43 <Cale> and xs ++ (ys ++ zs) = (xs ++ ys) ++ zs
01:42:47 <mcstar> well, if you do something meaningful when mappend, you will do something similar to list append, wont you? i mean for any monoid
01:42:49 <Cale> (in list notation)
01:43:23 <Cale> You'll do something which is like a list append followed by some associative operation combining the elements of the lists :)
01:43:25 <theplanet> haskell seems very difficult to understand
01:43:35 <Cale> theplanet: What are you having trouble with?
01:43:57 <theplanet> just the source i see coming from this channel
01:44:08 <Cale> theplanet: Ah, well, there's a lot of fancy machinery which people use, that isn't necessarily intrinsic to Haskell.
01:44:27 <frerich> Cale: So '++' should be "associative" and there should be a 'neutral valie'? So for, say, numbers I could use '+' and '0'. Or actualy '*' and '1'. Or for booleans I could use '&&' and 'True' or '||' and 'False'?
01:44:36 <Cale> yes
01:44:40 <Cale> absolutely
01:45:12 <theplanet> Cale, haskell can do the fibonacci sequence super-fast. MUCH faster than any other language, how come?
01:45:19 <mcstar> or set up a rendering 'pipeline' in drawingcombinators :)
01:45:34 <companion_cube> theplanet: wait, what?
01:45:34 <Jafet> Haskell was designed from the ground up to compute fibonacci numbers
01:45:35 <Cale> theplanet: um, that's more a matter of which algorithm that you're using than anything
01:45:37 <frerich> Cale: Ok but now I wonder - what's the usefulness of abstracting these properties away into a class? :-) Are there functions which are equally useful no matter what instance of 'Monoid' they are applid to?
01:45:53 <Cale> theplanet: If you use a good algorithm, you can make it fast in any language.
01:45:59 * frerich looks whether he can find functions with 'Monoid m => ...' in the signature.
01:46:08 <Cale> frerich: Well, the rest of my comment explains one benefit
01:46:19 <theplanet> strange
01:46:25 <Cale> frerich: Because we have these general monoid instances which construct new instances from old ones
01:46:34 <frerich> Cale: Oh sorry, I got dragged away from the Reddit page. now that I figured your second sentence out (ahem...) I'll return to it. :-)
01:46:51 <Cale> frerich: We get a monoid operation on functions (e -> e -> Ordering)
01:46:53 <whald> in a profiling report, does the "excludes profiling overheads" mean only to the "total alloc" or to the "total time" as well?
01:47:04 <mcstar> theplanet: some 'slow' algorithms can become fast because of lazyness and sharing, but haskell in itself is not 'fast'
01:47:08 <Cale> frerich: which is exactly the sort of function which you'd plug into sortBy
01:47:11 <Jafet> > sortBy (comparing length `mappend` compare) ["abc", "abd", "abcd"]
01:47:12 <lambdabot>   ["abc","abd","abcd"]
01:47:29 <Cale> frerich: So we get a "little algebra" of comparison operations which can be combined
01:48:00 <Cale> > sortBy (comparing length) (words "here is a list of words to sort just by length")
01:48:02 <lambdabot>   ["a","is","of","to","by","here","list","sort","just","words","length"]
01:48:26 <Cale> > sortBy (comparing length `mappend` compare) (words "here is a list of words to sort by length and then alphabetically")
01:48:27 <lambdabot>   ["a","by","is","of","to","and","here","list","sort","then","words","length"...
01:48:28 <theplanet> sortBy is a built-in function?
01:48:38 <Cale> theplanet: It's in Data.List
01:49:06 <Cale> comparing, which is a little invention of mine, you'll find in Data.Ord
01:49:07 <frerich> Well I guess it can be considered a nice trait of Haskell that you can get some good benefits out of using the language even without having a math background. I've been working as a software engineer for the last 12 years but only now I start to regret that I skipped some university education in favor of money and 'real world problems'. ;-)
01:49:13 <theplanet> how do i load data.list?
01:49:22 <Cale> theplanet: import Data.List
01:49:42 <theplanet> Cale, where can i find the source code for Data.List?
01:50:11 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sortBy
01:50:13 <mcstar> haskell.org -> reference -> choose module -> click source
01:50:30 <theplanet> thanks!
01:50:45 <mcstar> Cale: it is too convenient to give them the address!
01:53:01 <Cale> theplanet: You'll also note that commented out near there is a bunch of other versions of sorting which were compared with the implementation being used
01:53:25 <augur> edwardk: are there videos of the last hacbo talks?
01:53:39 <augur> or was it a bohac meeting
01:53:48 <augur> i cant keep these hac things straight
01:54:36 <theplanet> are there any languages that can do what haskell does, just as easily?
01:54:39 <theplanet> maybe fortran?
01:55:05 <Cale> fortran is old and writing programs in it is much less fun
01:56:19 <Cale> theplanet: If you want languages similar to Haskell, you might look at Clean, or a bit more distantly, the various languages in the ML family (OCaml and SML mainly)
01:56:52 <Cale> theplanet: and then if you want something even more mind-bending, you can look at Agda
01:56:57 <mcstar> fortran has its use
01:57:35 <FastCars> Maybe Fortran?
01:57:49 <mcstar> but yeah, if you are not in an environtment, when you need to write it, than probably it is not worth to be concerned about it
01:58:03 <mcstar> fastcars: eh?
01:58:25 <FastCars> I am merely intruiged by that qualifier I suppose.
01:59:20 <mcstar> oops, then*
01:59:31 <Cale> "z0LTROMiNATOR", really?
01:59:56 <z0LTROMiNATOR> Sounds like a good name for a space alien from a bad B-movie?
02:00:17 <opqdonut> I like it
02:00:32 <mcstar> a b-movie is either bad or a cult classic
02:00:48 <z0LTROMiNATOR> I am z0LTROMiNATOR from the planet z0LTROMoida IV, and I praesent you with the infinite realities of the fourth dimension (church choir)
02:05:33 <Cale> theplanet: I kinda wish I could tell you that there were really a lot of languages which were pretty much as good as Haskell, but there are a lot of features that Haskell has which other languages haven't really picked up on yet. However, I don't know how much experience you have programming, so it's kind of hard to explain convincingly why these things are good and people should care about them.
02:07:11 <Cale> theplanet: Basically, Haskell has a lot of features which are geared toward helping you not write bugs, and catch bugs before the program runs, rather than trying to sort out why the program is buggy after the fact.
02:07:12 <z0LTROMiNATOR> On the other hand there's also a lot of features other languages have that haskell hasn't yet picked up so yeah, different languages are different
02:07:23 <frerich> Cale: The trick shown in your Reddit comment is really funky but I must admit that I'm very tempted to just memorize that I can chain orderings by using the Monoid instances for Ordering and "Monoid b => Monoid (a -> b)" and then using 'mappend'. I think I will can remember this trick but I suspect I'll eventually forget why it works... :-}
02:07:42 <frerich> s/I will can/I will/
02:08:03 <Cale> frerich: Well, okay. Another good reason for Monoid's existence is things like the Writer monad
02:08:37 <frerich> I already noticed that it's considered "immoral" in Haskell-land to use stuff without understanding them 100% :-}
02:08:38 <Cale> frerich: which uses the monoid operation in the definition of bind, and the unit in the definition of return
02:08:46 <Cale> Well...
02:09:05 <mcstar> you wont get very far if you needed to achive 100% understanding all the time
02:09:07 <Cale> Actually, I think it's *more* immoral to use things in non-Haskell land without understanding them 100%
02:09:17 <Cale> *far* more immoral
02:09:36 <Cale> The types of things in Haskell tell you a lot more about what they don't do than the types of things in most programming languages.
02:09:52 <mysticc> @hoogle word8hex
02:09:52 <lambdabot> No results found
02:09:56 <Cale> When I write imperative OO code, I have to constantly program defensively.
02:09:56 <frerich> Cale: Probably, but then - most languages I saw didn't abstract things away that much so - at least for me - understanding them wasn't as difficult.
02:10:26 <merijn> Cale: Speaking of haskell features catching on... Did you see Stroustrup's suggestion for pattern matching in C++? :p
02:10:40 <zomg> frerich: I don't understand any of this shit. I must be haskell-satan
02:10:41 <zomg> lol
02:10:42 <Cale> merijn: lol, and the crappy benchmarking that they did, yeah :)
02:10:52 <z0LTROMiNATOR> I'm sure that won't make C++'s grammar even more complicated
02:11:06 <zomg> I kid, I do understand some of it but not all :p
02:11:09 <companion_cube> isn't it a template library?
02:11:11 <z0LTROMiNATOR> I swear, one of these days, type errors in C++ programs when making a first person shooter video game are going to result intoa  fully functioning chess engine
02:11:27 <mcstar> haskell hasnt picked up on uncontrolled mutation, what a shame (sic)
02:11:30 <Cale> frerich: There's a lot more abstraction, but ultimately that abstraction does what every abstraction does: it lets you ignore details of how some things work.
02:11:42 <frerich> zomg: I try to understand everything I use at least once, but then I eventually forget the "why" and just remember the "how" :)
02:11:50 <merijn> mcstar: Sure it has. It's called IO and IORef's
02:12:14 <mcstar> why is that uncontrolled?
02:12:36 <merijn> oh, in that case: unsafePerformIO :p
02:12:43 <mcstar> yeah, but ... :)
02:13:20 <Cale> frerich: If I'm writing code in pick-your-favourite-imperative-OO-language, I need to constantly be aware of how every method I call is going to affect the state of the program. Things can have complicated interactions, and testing them in isolation is nearly impossible.
02:13:28 <Cale> (though some people are daring enough to try)
02:13:46 <osfameron> "nearly impossible" is an overstatement
02:14:13 <Cale> Sorry, that should have been "actually impossible".
02:14:35 <osfameron> *sigh*
02:15:21 <frerich> Cale: I concur, but that's a matter of how expressive your type system is, no? However, a stronger type system *allows* you to express more abstract behaviour safely but it doesn't force you. But what I'm seeing is that the stronger the type system is, the higher the level of abstraction gets (which allows greater code reuse it seems but it also tends to make things have surprising effects)
02:15:25 <Cale> Moreover, if I want to understand what effects something might have, I have essentially no recourse but to look at its source code.
02:15:32 <mcstar> anyone done motion blur with the accum buffer in haskell? :D
02:16:39 <Cale> frerich: The potential for effects is encoded in the types though, which means you don't necessarily have to look at the implementation to understand a lot about what something can't do.
02:19:20 <Cale> frerich: I will admit that there can be some surprising ways that things fit together, but ultimately, most of the ways that things surprise you are pleasant ones, because the abstractions impose laws which means that things are going to behave sensibly.
02:20:22 <frerich> Cale: I'd like to point out that I'm very pleased how approachable (and understandable) you are despite having been into this stuff all the way to the chin (and maybe even deeper? :). A good counter-example of the "Lost in abstraction, never managed to touch ground again" stereotype ;-)
02:20:28 <Cale> The only exceptions I can think of are performance-related issues (which are hard in basically any system I can think of)
02:21:22 <Cale> I work hard at explaining and reexplaining stuff all the time.
02:21:33 <basdirks_> what papers would you recommend to understand the ideas behind Haskell?
02:21:43 <basdirks_> the basics
02:21:44 <Nereid> Cale: isn't that why people write blog posts or so? :v
02:22:04 <Cale> Nereid: See, but then if I have a blog post that I can point people to, I can be lazy
02:22:09 <Nereid> exactly
02:22:12 <Cale> Nereid: and just point people at the blog post
02:22:25 <Cale> rather than explaining it again, and having my presentation become more polished over time
02:22:34 <Nereid> heh
02:23:16 <merijn> basdirks_: By "ideas behind" are you referring to implementation or theory? (Or both?)
02:23:33 <edwardk> augur: i have the video but i haven't figured out a good way to get it carved up for youtube yet
02:23:54 <augur> edwardk: :(
02:24:18 <edwardk> augur: the main issue is the latter is ~20gb, and is having trouble transferring ;)
02:24:37 <augur> edwardk: compress it!
02:24:48 <edwardk> the problem is getting it _off_ the ipad in the first place =P
02:25:06 <Cale> APPLE OWNS THIS VIDEO NOW
02:25:09 <edwardk> the tools for transferring crash
02:25:24 <edwardk> i finally got the previous one off
02:25:39 <augur> edwardk: oh wow. why doesnt finder just work?
02:25:43 <augur> surely that should be fine
02:25:44 <sopvop> what, ipad can't samba/nfs?
02:25:49 <edwardk> augur: one would think
02:25:55 <edwardk> sopvop: one would think ;)
02:26:00 <augur> edwardk: send me your ipad, ill give it a try
02:26:02 <basdirks_> merijn: theory
02:26:04 <augur> =x
02:26:05 <edwardk> augur: =P
02:26:36 * sopvop does not buy gadgets anymore.
02:27:05 <edwardk> i also have another boston haskell talk on an old camcorder i need to buy new cables for
02:27:13 <edwardk> (i lost them during the move)
02:29:21 <basdirks_> merijn: by "ideas behind" I mean that which allow one to reason about programs
02:29:40 <basdirks_> in a more rich manner than I am able to now
02:29:43 <basdirks_> ^^
02:38:07 <merijn> basdirks_: I guess the usual recommendation is Types and Programming Languages
02:38:11 <merijn> @where tapl
02:38:11 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
02:38:20 <basdirks_> thank you
02:39:48 <RawProduce> @slap tyl with PHP
02:39:48 <lambdabot> I won't; I want to go get some cookies instead.
02:42:19 <Botje> RawProduce: I think the Geneva convention has something to say about taht
02:43:12 <YayMe> Wow, the algorithm design manual is umpteen times easier to understand than taocp vol1 (so far)
02:43:15 <RawProduce> Botje: it's OK, it was in the name of jihad
02:46:07 <merijn> YayMe: There's also Intro To Algorithms by Cormen, et al. which is a few steps easier than TAoCP (but still very comprehensive and in-depth)
02:46:55 <YayMe> merijn: Yeah, trouble is that one's like $60 and I happen to have a garage sale copy of taocp while algorithm design manual is free online
02:46:59 <Jafet> It is quite easy to design algorithms.
02:47:43 <YayMe> merijn: is the algorithm design manual not as comprehensive or effective on the topic as intro by cormen?
02:47:53 <bitonic> merijn: few steps?  CLRS is actually readable
02:48:15 <Jafet> flip (map . flip (map . (sum .) . zipWith (*)) . transpose)
02:48:21 <Jafet> There, I just designed an algorithm
02:51:58 <YayMe> bitonic: CLRS?
02:52:21 <Cale> Jafet: :D
02:52:43 <Cale> @unpl flip (map . flip (map . (sum .) . zipWith (*)) . transpose)
02:52:43 <lambdabot> (\ b c -> map (\ f -> map (\ v -> sum (zipWith (*) f v)) (transpose c)) b)
02:54:05 <sopvop> I have a function (constructor really). Quite long one, like a -> b -> c -> d -> Foo but with 10 args. is there an easy way to turn it into   c -> d -> a -> b -> Foo? switch first to arguments to become last, without long reordering function.
02:54:25 <Cale> sopvop: that's kinda what lambda is for
02:54:43 <sopvop> That lambda is kind of long :) I though maybe there is a clever way
02:54:59 <Cale> there's probably some horrible sequence of flips
02:55:05 <Jafet> sopvop: there are 10! permutations of the arguments, so there isn't much shorter way than just writing one out
02:55:52 <Jafet> One might also ask if your constructor really needs 10 arguments
02:56:14 <bitonic> YayMe: yes
02:56:37 <frerich> Maybe there is an 'uncurry10' or something and then there's a trick on tuples?
02:57:02 <YayMe> bitonic: Let me rephrase, what is CLRS?
02:57:08 <sopvop> It's a record from database, it should be like that
02:57:39 <Jafet> There are 10! permutations. Whatever trick you use needs to have about 10 things in it
02:58:53 <YayMe> in OO when I have a method taking too many parameters, I create an object which the method excepts. perhaps for haskell you should use a record
02:59:03 <YayMe> s/except/accept/f
02:59:30 * YayMe wishes dreaming in code didn't wake him at 2:00 this morning
03:00:38 <sopvop> I got it! I use it in applicative to parse db record. so
03:00:43 <sopvop> @type :t \a b -> (,,,,) <$> pure 'c' <*> pure 'd' <*> pure 'e' <*> pure a <*> pure b
03:00:44 <lambdabot> parse error on input `:'
03:00:48 <sopvop> @type  \a b -> (,,,,) <$> pure 'c' <*> pure 'd' <*> pure 'e' <*> pure a <*> pure b
03:00:49 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => a -> a1 -> f (Char, Char, Char, a, a1)
03:01:01 <imeredith> YayMe: heh i dont get woken up, i just get very little good rest when its like that
03:01:23 <sopvop> only other way with last two 'pure'
03:01:33 <YayMe> imeredith: Me too usually, but it was particularly bad tonight :|
03:02:55 * hackagebot simple-sendfile 0.2.8 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.8 (KazuYamamoto)
03:04:20 * YayMe probably isn't going to help himself get back to sleep by reading more about algorithms..
03:10:19 <mcstar> heaven! i have motion blur
03:10:40 <YayMe> wiping my glasses usually helps me with that
03:10:43 <RebelBunny> I think Haskell is elegant in some ways but a lot of programs and functions are much more cleanly expressed in a procedural style than functional
03:11:42 <ClaudiusMaximus> @quote best.*imp
03:11:42 <lambdabot> SPJ says: Haskell is the world's best imperative language.
03:11:43 <mcstar> YayMe: not like that, in opengl
03:13:25 <YayMe> Somebody should write a book on haskell wherein it teaches it being written exactly as if you were writing python or C# end to end. Wonder how many people it would trick into realizing SPJ's little truth there. But that person would summarily be flogged for not avoiding success
03:14:23 <efie> I wrote a function "apply :: (a -> a) -> Int -> a -> a" which applies a function n times to a starting value i, for example with n = 2: f(f(i)). does such a function already exist?
03:15:00 <merijn> YayMe: CLRS stands for the first letter of the names of the authors of Intro to Algorithms
03:15:26 <fmap> @type \f n -> (!! n) . iterate f
03:15:27 <lambdabot> forall a. (a -> a) -> Int -> a -> a
03:15:46 <merijn> YayMe: Cormen, Leiserson, Rivest and Stein
03:15:53 <YayMe> merijn: Oh. Is it particularly more comprehensive than the algorithm design manual?
03:15:54 <mcstar> thats more like 'nest' not apply
03:16:11 <merijn> YayMe: I'm not familiar with the algorithm design manual, so I can't say
03:16:40 <efie> fmap: thanks!
03:17:05 <efie> I wonder if this is faster than a simple recursive function?
03:17:09 <efie> or slower
03:17:33 <Jafet> Looking through this "algorithm design manual"...
03:17:52 <RebelBunny> merijn: it's a catalog of algorithms
03:18:08 <Jafet> "This book is not going to emphasize formal proofs of correctness, because they are very difficult to do right and quite misleading if you do them wrong."
03:18:29 <mcstar> http://imgur.com/AR541
03:18:36 <YayMe> nest f n = foldl1 (.) $ repeat n f
03:18:37 <Jafet> "Take-home lesson: The heart of any algorithm is an *idea*."
03:18:47 <Jafet> Wow, I think I'll enjoy this book
03:19:36 <RebelBunny> Jafet: There are lectures vectors associated with that book http://www.cs.sunysb.edu/~algorith/video-lectures/
03:19:39 <RebelBunny> er
03:19:41 <RebelBunny> videos*
03:19:54 <Jafet> "[...] However, you must pick a single criteria."
03:20:04 <Jafet> This book is delightfully bad
03:20:17 <YayMe> Really?
03:20:52 <kallisti> YayMe: replicate n f
03:20:54 <kallisti> not repeat
03:21:05 <YayMe> right
03:21:08 <mcstar> http://imgur.com/AWS7R this is the motion blur
03:21:32 <RebelBunny> Jafet: What makes you say that?
03:21:53 <mcstar> criteria is plural
03:22:40 <RebelBunny> mcstar: so it's a bad book because he's made a typo?
03:22:41 <Jafet> Firstly, judging from the table of contents
03:22:48 <Jafet> It has no discernible structure
03:23:48 <mcstar> RebelBunny: i guess it was just a single example of it being 'delightfully bad'
03:23:52 <Jafet> Ok, well it does
03:23:59 <Jafet> One chapter is called "sorting and searching"
03:24:15 <Jafet> I can't really make out much else, but I would not recommend this book
03:24:50 * mcstar wonders why nobody found the hilbert-morse comparison at least slightly funny...
03:25:32 <Jafet> RebelBunny: if you go to a restaurant and there's a bug in your soup, you probably won't trust the lobster
03:25:52 <Jafet> This is just my opinion after spending five minutes reading the book
03:25:56 <RebelBunny> That's a bit of an exaggeration...
04:08:28 <whald> could it be that there was something changed with how GHC determines which files it has to rebuild for a make? it feels strange with 7.6.1
04:09:12 <ivanm> I doubt it
04:09:19 <ivanm> how do you think it's changed?
04:09:41 <whald> it builds several modules, and then stops because of some error. i fix the problem in exactly that file, and change nothing else
04:10:16 <whald> when i start the "cabal build" then, I'd expect it to continue with the module that failed the last time
04:10:41 <whald> but instead it compiles completely unrelated stuff first
04:11:41 * RebelBunny  punches Haskell in the monads
04:11:54 <whald> also, sometimes i have a "cabal build" go straight thru, and when i run it again it finds some modules it would like to compile anyway. but i canged nothign
04:13:34 <whald> is this to be expected?
04:15:37 <companion_cube> Osazaki's paper on patricia trees seems to imply that red black trees are faster for lookup, it surprises me a bit
04:15:45 <companion_cube> does anyone have more insight on this?
04:17:49 <fmap> whald: do you use TH?
04:17:57 <ClaudiusMaximus> whald: maybe - with cross-module optimisations?  try and narrow it down to a simple reproducible example, could be a bug (7.6.1 is pretty new, right?)
04:18:43 <luv> Prelude> let a = ((.),(.))
04:18:47 <luv> what does this mean? :-)
04:19:15 <luv> what does the dot mean in this contect?
04:19:24 <ClaudiusMaximus> :t ((.),(.))  -- it defines a pair consisiting of the composition operator, twice
04:19:25 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f, Functor f1) => ((a -> b) -> f a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1)
04:19:33 <ClaudiusMaximus> arrgh, bad lambdabot
04:19:44 <ClaudiusMaximus> :t ((Prelude..),(Prelude..))  -- it defines a pair consisiting of the composition operator, twice
04:19:45 <lambdabot> forall b c a b1 c1 a1. ((b -> c) -> (a -> b) -> a -> c, (b1 -> c1) -> (a1 -> b1) -> a1 -> c1)
04:19:57 <certainty> looks like a owl to me
04:20:00 <certainty> :p
04:21:02 <ClaudiusMaximus> > let f x = x + 10 ; g x = x * 10 in (f . g) 1
04:21:04 <lambdabot>   20
04:21:13 <ClaudiusMaximus> > let f x = x + 10 ; g x = x * 10 in (.) f g 1
04:21:15 <lambdabot>   20
04:23:12 <Okasu> https://github.com/Okasu/HCat :3
04:24:40 <whald> fmap, no, i don't use TH
04:25:07 <whald> ClaudiusMaximus, what are cross-module optimizations?
04:25:58 <ClaudiusMaximus> whald: when ghc bes clever and inlines small things from one module into another to allow further optimisations make it go even faster
04:26:17 <ClaudiusMaximus> or something like that, i'm not a ghc hacker :D
04:27:34 <whald> but if module B imports module A (but A does not import B, which would be difficult anyway), how can changing B force a recompilation of A?
04:27:39 <Cale> actually whald, when you say "modules", do you mean "packages"?
04:28:09 <whald> Cale, no, they are modules (as ".hs" files)
04:28:13 <Cale> ah, okay
04:28:32 <Cale> So, there's no complex version dependency resolution going on there
04:30:02 <whald> i don't think so. but GHC gives me a really hard time since i switched to 7.6.1 anyway. I have profiling builds running 2x the speed of regular builds and whatnot. :-/
04:30:07 <Cale> whald: yeah, maybe ClaudiusMaximus is right, and it's recompiling A in order to be able to inline stuff into B
04:30:38 <Cale> 7.6.1 isn't really meant for general consumption yet
04:30:59 <Cale> (though it's good to have people finding problems)
04:31:29 <whald> but 7.4.1 has a bug which got fixed in 7.6.1 only, and i'm affected by this. :-(
04:31:35 <Cale> but the profiling thing sounds like maybe a compiler bug
04:31:49 <Cale> which bug?
04:32:01 <whald> maybe the GHC folks want to include my program in their suite of regression tests :-)
04:32:08 <whald> i'll look it up
04:32:29 <whald> Cale, this one: http://hackage.haskell.org/trac/ghc/ticket/7185
04:33:03 <liyang> When a symbol is marked INLINEABLE (or GHC considers it cheap enough), it includes the RHS into the .hi file so it can be inlined later at the call site.
04:33:15 <fmap> Okasu: nice, how about HLess? :)
04:34:08 <fmap> oh hmm, maybe less can handle colors
04:35:43 <mcstar> (. Y .)
04:36:15 <liyang> fmap: less -R, or export LESS="-R"
04:36:18 <Okasu> fmap: yeah, less can do it by itself
04:38:31 <Okasu> hcat somefile | less -R
04:38:35 <Okasu> works perfectly
04:39:20 <theplanet> what's hcat  a typo?
04:39:40 <Jafet> companion_cube: why do you expect red-black trees to be slower?
04:40:20 <Okasu> theplanet: nah, it's cat variant of mine written in haskell
04:40:33 <Jafet> Okasaki seems to be comparing them in the context of IntMap
04:42:24 <companion_cube> Jafet: well, RBtrees are not specialized for integers
04:42:54 <companion_cube> It may be silly, but I was expecting a specialized structure to be somewhat more efficient
04:42:57 <Jafet> Neither are patricia trees
04:43:13 <t7> (a = b) -> (b = c) -> (a = c)  whats this called
04:43:22 <efie> why do I have to write ((-)1) 2 instead of (-1) 2? (+1) 2 works
04:43:22 <companion_cube> patricia trees for integers?
04:43:41 <frerich> t7: Transitivity?
04:43:58 <Jafet> > (-1) + 1
04:43:59 <t7> ah great thanks
04:43:59 <lambdabot>   0
04:44:26 <Jafet> Of course, ((-)1) isn't the same thing as (+(-1)).
04:45:15 <Jafet> companion_cube: the most probable explanation is that patricia tree lookup contains more code than binary tree lookup
04:45:22 <byorgey> efie: because (-1) parses as the number negative one in parentheses, not as an operator section
04:45:37 <byorgey> efie: this is an ugly corner of Haskell's syntax
04:45:39 <Jafet> And perhaps sml/nj does not optimize bit twiddling code
04:45:45 <z0LTROMiNATOR> t7, that s not transivity
04:45:58 <z0LTROMiNATOR> (a = b) and (b = c) -> a = c i though
04:46:09 <byorgey> > ((-)1) 2
04:46:10 <lambdabot>   -1
04:46:14 <efie> byorgey: ah ok, I understand
04:46:21 <Jafet> P -> Q -> R is equivalent to (P and Q) -> R
04:46:22 <byorgey> efie: the function 'subtract' is provided for this purpose
04:46:30 <byorgey> efie: instead of (-1) you can write (subtract 1)
04:47:05 <byorgey> z0LTROMiNATOR: it is transitivity.
04:47:24 <Jafet> Not on his home planet, perhaps
04:47:29 <byorgey> hehe
04:47:30 <companion_cube> Jafet: and I think AVL trees are faster than RBtrees for lookup, aren't they?
04:47:39 <Jafet> They might be
04:47:45 <companion_cube> I'm looking for an int map with very efficient lookup
04:48:00 <earthy> companion_cube: look into patricia trees
04:48:00 <Jafet> IntMap uses judy arrays
04:48:07 <earthy> that's the other option
04:48:29 <Jafet> I think
04:48:45 <companion_cube> earthy: that's what we are talking about, patricia trees do not seem to be actually faster than RBtrees
04:49:31 <companion_cube> ok, judy arrays look interesting
04:49:38 <Jafet> The implementation in sml/nj was not faster than the implementation of red-black trees in sml/nj in the benchmark that they used
04:49:44 * companion_cube never heard about them before :(
04:50:03 <dada-cetacean> what's a nullary type constructor?
04:50:03 <Jafet> "The implementation is based on big-endian patricia trees."
04:50:42 <Jafet> > Nothing
04:50:43 <lambdabot>   Nothing
04:50:57 <Cale> dada-cetacean: something like Bool which takes no type parameters
04:51:06 <maukd> something of kind *
04:51:38 <frerich> Jafet: Nothing is a data constructor, I think (the type constructor would be 'Maybe a', which isnot nullary)?
04:51:49 <frerich> Err 'Maybe' would be the type constructor, I guess.
04:51:49 <Jafet> companion_cube: a benchmark of IntMap with Map Int, or a tree specialized to Int (which allows you to UNPACK the keys) could be interesting
04:52:12 <hpc> Jafet: there's probably already a few of those
04:52:15 <earthy> I'd be somewhat surprised if a red-black tree would be faster than a patricia tree
04:52:23 <Jafet> hpc: benchmarks? likely
04:52:35 <earthy> at least in cases with more than a few elements
04:52:57 <hpc> frerich: the type constructor is "Maybe", and the type is "Maybe a"
04:53:12 <earthy> and *especially* if you want to perform operations on the map
04:53:20 <earthy> rather than just want the mapping
04:53:20 <hpc> constructor = the thing with the capital first letter
04:54:24 <companion_cube> earthy: I'm interesting in very fast lookups, more than fast insertion or whatnot
04:55:22 <earthy> companion_cube: then a bitarray is fastest.
04:56:10 <Jafet> It ain't necessarily so!
04:57:20 <earthy> jafet: true enough
04:57:49 <earthy> given current memory access patterns for a large keyspace it may actually be slower than a patricia tree
04:58:17 <earthy> but if you have a smallish key space (e.g. 16 bits of key) you're probably fastest
04:58:50 <earthy> but companion_cube is not quite precise enough in his requirements :)
04:58:58 <companion_cube> :D
04:59:11 <companion_cube> wall, very fast lookup, reasonable insertion/deletion :)
04:59:24 <companion_cube> but I will probably stick to patricia trees since I have an implementation avaiable
04:59:34 <earthy> so I'm assuming 'best situation for particular wish' rather than 'general solution' :)
04:59:50 <earthy> Data.IntMap has never struck me as slow in the least
05:01:59 --- mode: ChanServ set +o maukd
05:02:49 <t7> can i apply a function to one side of a \equiv in agda
05:03:59 --- mode: maukd set -o maukd
05:07:13 <hpc> t7: you can use transitivity to apply 'f' to one side, and 'id' to the other
05:07:15 <hpc> maybe
05:07:27 <hpc> with the identity (f x \equiv x)
05:07:30 <t7> i think im being silly
05:08:42 <byorgey> t7: you can apply a function to both sides using 'cong'
05:08:49 <byorgey> but not to only one side.
05:15:52 <mrcarrot> I am trying to get lambdabot to work on openbsd. Right now when I try to evaluate an expression through lambdabot I get this message:
05:16:06 <mrcarrot>  > 1+1                                                                                      [15:11]
05:16:07 <mrcarrot> <lambdabottt>   mueval: Most RTS options are disabled. Link with -rtsopts to enable them.
05:16:34 <Cale> mrcarrot: when you build mueval, make sure to build it with -rtsopts
05:17:04 <mrcarrot> This was what I hoped to get help with. How do I apply that flag?
05:17:33 <isomorphic> This is going to sound like an odd question - but is anybody aware of a way of referencing URIs directly as values within a Haskell program, perhaps as a very small DSL?   Ie,  let a = b + [http://www.example.com/c] ?
05:17:50 <Cale> If you're building with cabal
05:18:12 <Cale> I think you can give the flag --ghc-options=-rtsopts
05:18:31 <byorgey> isomorphic: sounds neat, but I'm not aware of any such thing
05:20:45 <dada-cetacean> is it supposed to be clear from the type of the map function ( (a->b) -> [a] -> [b] ) that it takes two inputs and has one output?
05:20:53 <typoclass> isomorphic: the cheapest way might be "type URL = String", and a slightly less cheap way a newtype. or you could use template haskell. that shouldn't really be hard either
05:21:09 <akamaus> hi, I'm trying to write a test suite for cabalized library. It has some non-exposed modules I want to write tests for. Is it possible without exporting some kind of test api?
05:21:22 <flux> dada-cetacean, yes
05:22:07 <flux> (although you can view it as function (a -> b) -> ([a] -> [b]) as well)
05:22:17 <isomorphic> byorgey:  Thanks.  typoclass:  I was thinking perhaps it would be doable using a type constructor that knows how to construct an appropriate IO String (say) from the URI - does that sound like the right approach?   Users would then prepend their code with the type constructor - so, let a = b + URI "http://www.example.com"  - sane?
05:22:34 <mrcarrot> Cale: Thanks.
05:22:46 <mrcarrot> Now I got a new problem, now I get this message:
05:22:48 <mrcarrot> <lambdabottt>   Could not find module `ShowIO':
05:22:49 <mrcarrot> <lambdabottt>    Use -v to see a list of the files searched for
05:22:53 <dada-cetacean> so because of the left-associativity of functions, I can assume that everything before the last item of the type is an input?
05:23:23 <Cale> dada-cetacean: -> in type signatures associated to the right
05:23:34 <Cale> but yeah, if I understand what you're saying
05:23:43 <Cale> associates*
05:23:48 <Cale> If you have
05:23:52 <Cale> f :: A -> B -> C -> D
05:23:56 <Cale> then that's the same as
05:24:01 <t7> whats that thing in agda where it will never happen
05:24:03 <Cale> f :: A -> (B -> (C -> D))
05:24:13 <Cale> and when you write
05:24:15 <Cale> f x y z
05:24:17 <Cale> it means
05:24:22 <Cale> ((f x) y) z
05:24:24 <dada-cetacean> it folds
05:24:30 <typoclass> dada-cetacean: about your original question, yes, the output is described by "[b]" (in other words a list that contains elements of type 'b'). the first input is (a -> b), which is a function that given an 'a' produces a 'b'. the second input is [a]. you can see that the parens are important in that place.
05:24:34 <Cale> (application associates to the left)
05:24:58 <Cale> You can think of map in two ways
05:25:23 <Cale> One is the way that typoclass just described, as something which takes a function and a list
05:25:45 <Cale> Or you can think of it as something which takes a function (a -> b) and produces a function ([a] -> [b])
05:28:00 * hackagebot DSH 0.7.8.2 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7.8.2 (GeorgeGiorgidze)
05:42:10 <Botje> :t error "foo" + ?x
05:42:11 <lambdabot> forall a. (?x::a, Num a) => a
05:49:59 <mrcarrot> Is there any way to get lambdabot to show the title of a page when pasted into a channel?
05:50:58 <Jafet> @faq
05:50:58 <lambdabot> The answer is: Yes! Haskell can do that.
05:51:28 <mrcarrot> lol. Of course Haskell can do that. I was more interested in to know if it is ready implemented.
05:51:38 <Jafet> I don't think so
05:51:54 <ivanm> it used to do so
05:51:58 <ivanm> but was found annoying IIRC
05:52:05 <ivanm> s/it/she/
05:52:46 <Jafet> (Is it more annoying for it to be annoying or for her to be annoying?)
05:55:30 <ClaudiusMaximus> @google lambdabot haskellwiki shows page title iirc
05:55:32 <lambdabot> http://hackage.haskell.org/packages/archive/lambdabot-utils/4.2.1/doc/html/Lambdabot-Url.html
05:55:32 <lambdabot> Title: Lambdabot.Url
05:56:49 <sopvop> lambdabot is way to smart
05:57:13 * nand` thinks a good URL should contain the title either way
05:57:21 <nand`> or at least give a reasonable approximation of the content
05:57:58 <ClaudiusMaximus> nand`: like data: urls ?
05:58:12 <nand`> I have no idea what that means
05:58:29 <ClaudiusMaximus> nand`: embedding base64 encoded pngs in html pages directly, for example
05:58:58 <nand`> oh. Not the way I meant it :)
05:59:20 <nand`> but for example http://blog.sigfpe.com/2006/11/yoneda-lemma.html contains the title: ‚Äòyoneda lemma‚Äô, as well as useful info like the date
05:59:26 <ClaudiusMaximus> http://tools.ietf.org/html/rfc2397
05:59:34 <Cale> A good URL should encode a PNG of the page title, in a fun-and-friendly typeface
05:59:35 <nand`> it even lets you know that it's a blog post
06:01:12 <mcstar> wasnt there a kde asteroids clone?
06:01:13 <Cale> http://tools.ietf.org/html/rfc2397 is a great URL, because it tells me that this is about rfc2397, and that the document I'm going to receive will be in html format.
06:01:35 <Cale> ;)
06:01:49 <dada-cetacean> when writing out that "add" is equivalent too \x y -> x + y, what does the "\" symbol mean?
06:02:04 <ibid> it' just syntax
06:02:19 <mcstar> 2/3 of a lambda
06:02:20 <Cale> dada-cetacean: It's ascii art for the greek letter lambda, but yes, it's just syntax which starts a function
06:02:23 <ibid> means that what follows is a function, first its parameters and then its body
06:02:39 <dada-cetacean> heh
06:02:43 <Cale> > (\x -> x^2) 5
06:02:44 <lambdabot>   25
06:02:45 <ibid> an unnamed function, actually
06:02:53 <Cale> > map (\x -> x^2) [1,2,3,4,5]
06:02:54 <lambdabot>   [1,4,9,16,25]
06:02:59 <dada-cetacean> so like the #& convention in mathematica?
06:03:00 <typoclass> dada-cetacean: it means lambda (an anonymous function). you write \ , then the parameters, then -> , then the expression (the code)
06:03:05 <Cale> dada-cetacean: yes
06:03:22 <Cale> except that you name the parameters
06:03:32 <Cale> So more like Mathematica's "Function"
06:03:47 <Jafet> U+5C GREEK SMALL LETTER LAMBDA WITHOUT KICKSTAND
06:04:21 <bartavelle> Jafet,  :)))
06:04:26 <danr> Jafet: ^^
06:04:33 <mcstar> bicycle looked at from the back with a kickstand?
06:04:33 <Cale> Function[x, x^2] is roughly equivalent to (\x -> x^2)
06:04:34 <ibid> Jafet: :-D
06:04:50 <mcstar> {x}
06:05:06 <Jafet> https://plus.google.com/109925364564856140495/posts/3WKRQCuKJ7U
06:05:11 <Cale> it actually doesn't need to be a list, for one parameter :)
06:05:16 <mcstar> Cale: oh, i didnt know i dont need the {}
06:05:20 <mcstar> yeah
06:05:29 <Cale> (\x y -> x + y) is roughly equivalent to Function[{x,y}, x + y] though
06:05:43 <mcstar> Cale: mathematica is horrible to program in, too bad
06:05:44 <Cale> But it's really more like Function[x,Function[y,x+y]]
06:06:39 <dada-cetacean> I once tried implementing binary search in Mathematica
06:06:40 <dada-cetacean> it was ugly
06:07:07 <Cale> Mathematica isn't so bad if you restrict yourself to pure functional programming
06:07:13 <mcstar> With/Block/Module, these are unintuitive/wrong and verbose
06:07:18 <bartavelle> Cale, mathematica is horrible
06:07:46 <Jafet> bartavelle: that's what cale just said
06:08:00 <mcstar> Mathematica were a effing awesome product with Haskell as its implementation language
06:08:03 <bartavelle> I didn't get the joke then
06:08:43 <mcstar> mma is equally bad for functional or imperative programming i think
06:09:03 <Cale> Well, it is horrible in general, but it does admit sanely-written programs. So it's kind of like using most lisps.
06:09:25 <dolio> I can't believe what I'm hearing about Xah Lee's favorite language.
06:09:30 <mcstar> a restricted form of CL would be good too
06:10:01 <Cale> dolio: lol
06:10:12 <mcstar> dolio: haskell?
06:10:17 <dolio> Mathematica.
06:10:20 <mcstar> :)
06:10:25 <Cale> Whatever happened to Xah Lee anyway?
06:10:32 <mcstar> cancer
06:10:43 <mcstar> no, thats another guy
06:10:59 <dolio> Well, I don't read comp.lang.functional much, but he was still posting there last time I looked.
06:11:20 <dolio> As he is one of the world's foremost experts on functional programming.
06:11:34 <mcstar> shares the first place with jon
06:12:20 <Cale> lol Jon Harrop
06:12:51 <dolio> @quote xahlee expert
06:12:51 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
06:13:07 <dolio> Top expert, my bad.
06:13:50 <mcstar> once i implemented a lattice gas model simulation in mathematica
06:13:51 <typoclass> i take it he's the world's top expert as far as said expert is concerned, not as far as the world is concerned
06:13:59 <mcstar> i was soo naive
06:14:40 <Cale> dolio: Well, he's still second to Stephen Wolfram who is a master of all computation and is revolutionising science with his insights which are totally his own and not the work of others, and are copyright Wolfram Research.
06:15:00 <dolio> Indeed.
06:15:36 <typoclass> cale: i thought he can compute new knowledge by the megabyte, via his pocket calculator that has some constants built-in
06:15:40 <bford> I'm seeing this error "Failed to copy optional package ghc-binary from system's GHC: ghc-pkg process failed with status 1" when I try to initialize a virthualenv and I end up with only cabal in my .virthualenv/bin directory. Anyone come across this?
06:15:43 <mcstar> wolfram has a collection of interviews of himself on his site
06:15:49 <mcstar> they are super informative
06:16:10 <mcstar> oh, i was naive enough to read his book in its entirety
06:16:12 <matthiasgorgens> mcstar: to get the best interview, you need the best interviewee and the best interviewer.
06:16:19 <alpounet> hah
06:16:45 <matthiasgorgens> they just happen to be the same person. ;o)
06:16:59 <matthiasgorgens> mcstar: may god have mercy on your soul.
06:18:38 <mcstar> it was a long time ago, im a different person now
06:19:10 <mcstar> though, i wish i had learned CL when i first heard about it, not 6 years later
06:19:28 <mcstar> cause that would have led me to learn haskell that much earlier too
06:20:11 <bford> it looks like it's looking for a package called ghc-binary
06:23:13 <Jafet> That's just the package corresponding to the ghc binary.
06:23:22 <jimstutt> cabal-install-0.14.0 install fail with msg "base >-2.0 && < 2.2".
06:24:15 <bford> any idea why it can't find it Jafet?
06:24:44 <Jafet> No
06:26:54 <ivanm> jimstutt: which version of GHC?
06:27:03 <jimstutt> ghc-7.6.1
06:27:10 <ivanm> yeah, that won't work then
06:27:25 <ivanm> you need to wait for a version of cabal-install that's compatible with 7.6
06:27:27 <jimstutt> Aha. Any suggestions?
06:27:38 <jimstutt> Sorry overlapped.
06:27:44 <jimstutt> Will look it up.
06:28:03 <ivanm> either a) downgrade GHC, build cabal-install, upgrade GHC; b) get a pre-built cabal-install binary from elsewhere; c) see if HEAD for cabal-install works
06:28:43 <ivanm> jimstutt: looks like the version on github might work: https://github.com/haskell/cabal/tree/master/cabal-install
06:28:59 <jimstutt> Thanks a lot. You've just saved me from trying to hack the cabal file.
06:29:21 <jimstutt> I'll try the github one, tnx again. :)
06:30:18 <luv> http://hpaste.org/75407
06:30:26 <luv> how cam name can't be of type String there?
06:30:29 <luv> come
06:31:14 <ivanm> luv: can you try removing that type sig?
06:31:36 <alpounet> juste remove the type signature and it should work
06:31:40 <ivanm> but I think it's because if you say "foo :: bar" within a do-bloc, the bar has to be for that monad
06:32:01 <luv> umm ok
06:32:05 <luv> compiles now, indeed
06:32:24 <luv> though - i get a runtime error now. sb: user error (Prelude.readIO: no parse)
06:32:28 <ivanm> also, what you have there looks like a prime candidate for a list comprehension
06:32:33 <ivanm> luv: yeah, use getLine rather than readLn
06:32:41 <benmachine> luv: when you write name :: String in there, it's just the same as if you wrote name on its own
06:32:43 <ivanm> readLn for Strings expects you to quote your value
06:32:44 <luv> oh yeah
06:32:52 <ivanm> bah, not a list comprehension
06:32:52 <benmachine> luv: after all, GHC already knows that name is a String
06:32:55 <ivanm> I meant guards
06:32:58 <luv> i need to enter  "name" if i use readLn
06:32:58 <luv> right
06:33:09 <ivanm> benmachine: well, it infers it _afterwards_ (because of the type of the `elem`)
06:33:27 <benmachine> ivanm: pfft. it can infer it in whatever order it likes :P
06:33:35 <ivanm> heh
06:33:38 <benmachine> type information can travel in all directions
06:33:43 <ivanm> :o
06:33:45 <benmachine> because Haskell is awesome
06:33:56 <benmachine> (I know you know this, but I think it's important to understand)
06:34:05 <ivanm> *nod8
06:34:09 <ivanm> s/8/*/
06:34:16 <t7> "type information can travel in all directions" wut
06:34:29 <ivanm> t7: even out of the screen and into your head!
06:34:34 <benmachine> luv: anyway if you just write "name" as a statement in the IO do-block, GHC will think you're trying to run it as a IO action
06:34:48 <bgamari> How does one move an Acid-State event to a new module?
06:34:51 <luv> fair enough
06:35:13 <bgamari> Apparently the event name encodes the module in which it resides, meaning it is no longer seen after I've moved it
06:35:52 <benmachine> bgamari: I guess you treat it as a change of format and use the upgrade mechanism?
06:36:39 <bgamari> benmachine, Sounds reasonable; I guess it's time to figure out how to use that
06:37:07 <benmachine> t7: what I meant by that is that ambiguity in an expression can be resolved by using parts of that expression somewhere else
06:37:17 <benmachine> t7: it doesn't have to be before or after or near or anything
06:37:34 <t7> oh right
06:37:45 <t7> hindley milner
06:39:04 <benmachine> mm
06:39:24 <benmachine> it can be a source of surprise to some people who are used to 'casts' in other languages being used to fix types at the point of use
06:39:46 <mcstar> is there some easy color conversion utility that for example turns html code to a quadruple of gldouble?
06:43:44 <Cale> mcstar: the colour package
06:43:49 <Cale> http://hackage.haskell.org/packages/archive/colour/2.3.3/doc/html/Data-Colour-SRGB.html
06:45:31 <thoughtpolice> edwardk: what happened to all the Language* modules in the git copy of trifecta? it uses parsers now, but a lot of it vanished. were you planning on reintroducing most of it in parsers?
06:46:20 <bgamari> Is the acid-state author ever around here?
06:46:47 <thoughtpolice> bgamari: yes, Lemmih is here :)
06:46:56 <thoughtpolice> well, occasionally that is
06:47:02 <bgamari> Lemmih, ping
06:47:22 <edwardk> thoughtpolice: there are still some things i plan to port from trifecta's current public release. Language was up in the air at last check, some people didn't like it, but I hadn't figured out a nicer way to do it, and if I were to do Language, I'd rather do it out in parsers itself
06:47:51 <edwardk> that way you can write a Language you can use with attoparsec or parsec, etc.
06:48:01 <thoughtpolice> edwardk: i see, so is trifecta now really just becoming more of a diagnostics framework on top of parsers?
06:48:08 <edwardk> yep
06:48:29 <Lemmih> bgamari: pong.
06:48:37 <edwardk> with 0.90 the model is that you'll use parsers for almost all the interesting combinators, then you can run it on parsec, attoparsec what have you
06:48:56 <bgamari> Lemmih, I'm trying to move a data type stored in acid-state from one model to another
06:48:57 <edwardk> and if you want nice diagnostics you run it in trifecta, and get diagnostics, syntax highlighting, what have you
06:49:19 <thoughtpolice> the highlighting looks like it was put in parsers, no?
06:49:22 <bgamari> Lemmih, Unfortunately, the module name appears to be encoded in the event name
06:49:51 <bgamari> Lemmih, Meaning I get an error of the form, "This method is required but not available: "Main.IncrementEdge". Did you perhaps remove it before creating a checkpoint?"
06:49:53 <edwardk> the annotations were, but they were put there for parsers that support them. its unlikely one written using parsec will ;)
06:50:12 <thoughtpolice> ah
06:50:13 <bgamari> Lemmih, I can't seem to construct a migration to work around this
06:51:01 <edwardk> the other thing this gives you is then the monad transformer support in parsers spreads out to other parser libraries, you can the start to use 'parsers' based parsers for ReaderT'd or StateT'd attoparsec or parsec, etc.
06:52:07 <mcstar> Cale: thanks, i was hoogling for 'color' -_-
06:52:16 <edwardk> I had fun replying to http://www.facebook.com/notes/kent-beck/functional-tdd-a-clash-of-cultures/472392329460303 -- I think I may write up a longer version of my reply as a blog post on thinking about typechecking as proving free theorems once and for all, rather than checking them case by case like TDD.
06:59:55 <bgamari> Lemmih, Any ideas how this might be accomplished?
07:00:15 <Springwight> Hey. Where would be the right place to talk about implementations of functional data structures, not necessarily in Haskell or any particular language?
07:00:48 <Lemmih> bgamari: Create a checkpoint first.
07:02:02 <Eduard_Munteanu> Springwight: maybe #haskell-blah? There was a CS or logic channel around as well.
07:03:31 <bgamari> Lemmih, Alright, I suppose that should have been obvious from the error
07:12:57 <dada-cetacean> from A Gentle Introduction To Haskell: "Suppose bot is defined as bot = bot." How does this indicate that it's a nonterminating expression?
07:13:16 <Morgawr> hello everyone.. I'm interested in trying Haskell to develop some GUI applications, as far as I noticed it seems that Gtk2Hs is the best library out there, however the tutorial is very lacking (lots of TODO sections). Is there a better/more in-depth tutorial out there?
07:13:19 <Botje> to evaluate bot, you must evaluate bot, for which you need to evaluate bot, etc.
07:13:49 <dcoutts_> Morgawr: the examples in the gtk repo are also useful for learning
07:13:52 <Botje> dada-cetacean: it's analogous to defining f x = f x
07:14:06 <Botje> if that is the only clause for f, f <whatever> will never return
07:14:34 <dada-cetacean> so it's an infinite loop which haskell won't actually get stuck in because it's lazy?
07:14:50 <Morgawr> dcoutts_: I will check them out
07:14:59 <Morgawr> was kinda hoping for a more newbie-friendly approach
07:15:23 <dcoutts_> Morgawr: and there's a tutorial thats titled glade but is really general gtk stuff
07:16:29 <Morgawr> dcoutts_: where is it? :o
07:17:05 <dcoutts_> Morgawr: linked from the gtk2hs home page
07:17:06 <dcoutts_> http://projects.haskell.org/gtk2hs/docs/tutorial/glade/
07:17:17 <Morgawr> mmm weird.. I tried to build a gtk2hs example/demo and it doesn't work, this is the error: Could not find module `Data.ByteString.UTF8'
07:17:31 <Cale> dada-cetacean: If you evaluate that bot, then the implementation of Haskell is free to either loop forever, or produce an exception.
07:17:32 <Morgawr> the ByteString package is installed with cabal but it doesn't have an UTF8 type
07:18:02 <dcoutts_> Morgawr: oh some of them depend on extra packages, that one needs the utf8-string package
07:18:10 <dcoutts_> cabal install utf8-string
07:18:16 <Cale> dada-cetacean: GHC will exhibit both of these behaviours at different times (depending on whether you're using the threaded runtime and which version of GHC you have)
07:18:27 <Morgawr> ah ok, cool, I tried doing "cabal info Bytestring.utf8" but couldn't find it... thanks
07:18:57 <dcoutts_> Morgawr: yeah we really should add a search feature to find packages by the modules they contain
07:19:03 <dcoutts_> would be jolly handy
07:21:33 <Cale> dada-cetacean: It can catch certain types of infinite loops and stop immediately. When it enters the code for a thunk (or expression) it rewrites that pointer to point at a piece of code that throws an exception. That way, if it later tries to enter that same piece of code, indicating that it needs to know the value to determine the value, it instead stops dead.
07:22:33 <Cale> (it later rewrites that same pointer to a pointer to code which returns the already-computed value immediately)
07:23:42 <dada-cetacean> Cale: thanks!
07:23:51 <Cale> dada-cetacean: In the threaded runtime, because it can happen that two threads try to evaluate the same value at the same time, this "black hole" strategy isn't good. So instead it uses a "grey hole" approach, where instead of producing an exception, it waits for the value to be computed. If there are no other threads, it'll just wait forever (but at least it will not use any CPU)
07:25:20 <fmap> It's annoying that sometimes busy loops in ghc-compiled programs aren't that "busy" :[
07:25:35 <Cale> Ah, I could have been clearer in my parenthesised statement there -- I mean if it were to successfully compute the value, then it would rewrite that pointer to point to a piece of code which would just return it.
07:25:53 <Cale> fmap: hm?
07:26:54 <Cale> fmap: It's not as if the loop could have produced a value or ever finished here, so I don't see much point in wasting CPU time computing it :)
07:27:40 <fmap> Cale: well, I've spent 30 minutes to deduce what happened
07:27:59 <fmap> 100% cpu load is easier to debug
07:28:20 <Cale> ah, I guess it's more noticeable that something has gone wrong
07:28:56 <Cale> A <<loop>> exception is certainly nicer in that case.
07:29:31 <Cale> It would be nice if it could always (or even almost always) tell whether or not some other thread was actually computing the expression.
07:29:36 <fmap> I'd certainly prefer <<loop>>, but that's undecidable problem anyway  :[
07:30:30 <Cale> Well, the problem that a <<loop>> exception represents isn't undecidable
07:30:48 <Cale> (it just doesn't include all infinite loops)
07:35:16 <quicksilver> Cale: threadscope can, perhaps?
07:35:20 <quicksilver> tools like threadscope, at least.
07:35:44 <nand`> <<loop>> just represents a definite ‚Äòno‚Äô to the halting problem, just like actually returning something represents a definite ‚Äòyes‚Äô
07:35:47 <Cale> quicksilver: I mean, in order to terminate with a <<loop>>
07:35:52 <nand`> there's still a big chunk of ‚Äòmaybe‚Äô
07:38:11 <Cale> quicksilver: Like, if the greyhole could wait some amount of time (like maybe a second or so), and then spend a bit of effort trying to decide whether or not this thunk is actually being evaluated by another worker, and if not, die with an exception, or if so, continue waiting forever until it's ready.
07:39:16 <Cale> But I'm not sure exactly how that mechanism would work, or whether it's possible to make it almost-free.
07:40:27 <nand`> is it possible for threads to greyhole deadlock? ie. one thread depending on a value another thread is currently evaluating and vice versa
07:40:58 <luite> hm, i always thought in the threaded runtime, the blackhole contained the thread evaluating the thunk. then if you enter it and it's you, you <<loop>>, if it's someone else, then you wait
07:41:00 <nand`> that may need to be taken into account when failing with <<loop>>
07:41:11 <luite> oh wait that has nothing to do with threaded runtime
07:42:41 <quicksilver> Cale: *nod*
07:43:40 <Sculptor> hi!
07:44:58 <Eduard_Munteanu> Sculptor: hi
07:45:35 <FireFly> is there a good way to count the number of `True`s in a [Bool]?  Or what would be the recommended way of counting the number of elements in a list matching a given predicate?  I could implement my own helper function easily, of course, but I'm wondering if there's a good built-in that I'm unaware of
07:45:45 <Cale> It's entirely possible that my understanding of the runtime system is a bit off. I'm remembering things from papers I read a good while ago.
07:46:01 <Cale> FireFly: length (filter id xs) ?
07:46:31 <nicoo> FireFly: sum $ map (\ x -> if x then 1 else 0) l
07:47:11 <FireFly> Hm, I like that `filter` one--clever
07:47:30 * quicksilver prefers filter (==True) to filter id
07:47:53 <nicoo> quicksilver: Ewwwww
07:47:55 <osfameron> it's more obvious what you're doing then
07:48:04 <quicksilver> it generalises better to other types
07:48:06 <bitonic> yeah.  it's  readable without context
07:48:10 <quicksilver> filter (==1) or filter (=='c')
07:48:11 <Eduard_Munteanu> quicksilver has a point ;)
07:49:19 <nicoo> quicksilver: Mmh, indeed
07:51:35 <luite> > let xs = [True, False, True] in sum[1|True<-xs]
07:51:36 <lambdabot>   2
07:54:15 <tsou> FireFly: check also elemIndices of Data.List
07:54:34 <dada-cetacean> does the following recursive definition for the fibonacci sequence "fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]" work because list comprehension in Haskell picks out elements fitting the given criteria left-to-right from a list?
07:55:09 <mcstar> > sum (map fromEnum [True, False, True])
07:55:10 <lambdabot>   2
07:55:23 <MostAwesomeDude> dada-cetacean: Well, yes, list comprehensions go from left to right on lists.
07:55:37 <luite> mcstar: hehe cute
07:55:42 <alpounet> dada-cetacean, yes, and it can be shortened to: fib = 1 : 1 : zipWith (+) fib (tail fib) (but you may already know this form)
07:56:05 <FireFly> tsou: yeah, my initial attempt used elemIndices, but I figured there might be a prettier way
07:56:16 <tsou> ok ;)
07:56:36 <fryguybob> > let xs = [True, False, True] in sum[b|(True,b)<-zip xs (iterate (*2) 1)]
07:56:37 <lambdabot>   5
07:57:08 <dada-cetacean> alpounet: that seems way more intuitive, thanks
07:59:30 <bgamari> Hmm, is Data.Set.fromList know to stack overflow on large lists?
07:59:50 <alpounet> how large?
08:00:47 <bartavelle> it should be like a foldl' Set.insert right ?
08:01:28 <mm_freak_> fromList does not stack-overflow
08:01:31 <bgamari> alpounet, 2 million elements
08:01:38 <alpounet> with fromList?
08:01:41 <bgamari> yes
08:01:50 <alpounet> hmm no, it doesn't
08:02:02 <Eduard_Munteanu> Why foldl'?
08:02:02 <alpounet> at least, i've had that order of magnitude of elements in a set before without stack overflow
08:02:03 <mm_freak_> bgamari: sure it's a stack overflow in fromList?
08:02:18 <mm_freak_> Eduard_Munteanu: because otherwise you're just building a huge thunk of insertions
08:02:34 <bgamari> Nope, it actually seems it might be Data.Text that's blowing the stack
08:02:37 <Eduard_Munteanu> So? Is Data.Set strict in any way?
08:02:51 <mm_freak_> Eduard_Munteanu: yes, it's strict on its structure
08:02:57 <bgamari> -xc says the highest stack frame is Data.Text.IO.Internal.readTextDevice
08:02:58 <mm_freak_> so it's effectively strict on all elements
08:03:02 <Eduard_Munteanu> Ah.
08:03:19 <mm_freak_> bgamari: are you constructing once and then reading many times?
08:03:26 <mm_freak_> i.e. you never change it after construction?
08:03:42 <bgamari> mm_freak_, currently I'm just constructing the set and calling Set.size on it
08:03:53 <mm_freak_> bgamari: do you expect to change it ever?
08:03:56 <Morgawr> I know this may sound really newbish but... I'm reading reference code and I wanted to know what some functions do and how they work. I'm looking through the API reference (in this case http://hackage.haskell.org/package/gtk-0.12.3 ), is there a quick way to search without having to check all the pages? I can't find the function I'm using and there's so much stuff...
08:04:12 <alpounet> Eduard_Munteanu, it has to evaluate enough of the values to know where to put them in the tree
08:04:15 <bgamari> mm_freak_, Nope
08:04:22 <mm_freak_> Morgawr: hoogle, hayoo
08:04:37 <byorgey> Morgawr: use hoogle, and tell it to search in a particular package
08:04:39 <byorgey> @where hoogle
08:04:40 <lambdabot> http://haskell.org/hoogle
08:04:40 <mm_freak_> Morgawr: or if you install gtk, you can also ask GHCi
08:04:42 <Morgawr> mm_freak_: but it's not on hoogle
08:04:49 <byorgey> Morgawr: like so:  functionName +package
08:04:56 <Morgawr> ahh
08:04:59 <Eduard_Munteanu> alpounet: well, that alone would still let one use foldr, which is nicer than foldl'.
08:05:03 <mm_freak_> bgamari: in that case i found that using a sorted vector is /much/ faster and smaller
08:05:12 <bgamari> Good to know
08:05:14 <Eduard_Munteanu> But yeah, if strictness is involved, then foldl' is your only option.
08:05:26 <mm_freak_> bgamari: befriend vector-algorithms‚Ä¶  heap sort was the fastest for me
08:05:30 <Morgawr> found it, thanks.. good to know :)
08:05:56 <mm_freak_> bgamari: if you can create the vector sorted right away, even better, but sorting afterwards isn't too bad‚Ä¶  and in vector-algorithms you also find binary search predefined
08:06:09 <bgamari> That being said, I would like to know what's going on here
08:06:39 <bgamari> calling length on the list being fed into fromList is fine
08:06:44 <mm_freak_> bgamari: whatever is going on probably has nothing to do with Set at all
08:07:00 <rwbarton> try length . sort
08:07:06 <mm_freak_> bgamari: instead there probably are intercorrelations between the elements that get fully evaluated while creating the set
08:07:19 <mm_freak_> so i second rwbarton's suggestion
08:07:58 <bgamari> ahh
08:08:05 <bgamari> failed there as well
08:08:09 * hackagebot rank1dynamic 0.1.0.1 - Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types  http://hackage.haskell.org/package/rank1dynamic-0.1.0.1 (EdskoDeVries)
08:08:34 <mm_freak_> bgamari: then make sure that you use finer grained forcing
08:08:52 <mm_freak_> also consider using 'copy'
08:09:01 <mm_freak_> (where it makes sense)
08:10:43 <bgamari> Thanks!
08:24:55 <hpaste> ‚ÄúBen Gamari‚Äù pasted ‚ÄúStack overflow issues‚Äù at http://hpaste.org/75411
08:26:20 <bgamari> Any suggestions for a) fixing the still-present stack overflow; and b) cleaning up the conditionals in the parsing code
08:28:27 <hiptobecubic> bgamari, doesn't look like a' and b' get evaluated? maybe that's growing?
08:28:58 <bgamari> hiptobecubic, I guess that could be
08:29:16 <quicksilver> decimal is from Data.Text.Read
08:29:23 <quicksilver> I don't see how it can 'grow'
08:29:28 <quicksilver> it's not recursive
08:29:37 <quicksilver> stack overflow is from deep thunks...
08:29:54 <bgamari> If I put bangs on the matching of a' and b' nothing changes
08:30:12 <quicksilver> the obvious speculation is that all your "tells" are building a huge Sequence-thunk : but the strict writer is not supposed to do that.
08:30:50 <quicksilver> that's the only think I can see which looks like it could be a nested thunk, though
08:30:58 <bgamari> quicksilver, well, it also stack overflowed before I switched to writer
08:31:33 <quicksilver> maybe Data.Set's mappend is lazy even when you 'seq' it.
08:31:57 <quicksilver> doesn't seem likely though
08:32:01 <quicksilver> it has to compare spines to merge.
08:32:28 <quicksilver> s/Sequence/Set/; # a few lines up, incidentally, but it doesn't matter
08:33:15 <mcstar> there should be versions of when/unless that take an IO Bool as parameters, rather than Bool
08:33:27 <bgamari> quicksilver, Perhaps the ghci debugger will say something useful
08:33:37 <bgamari> assuming it ever finishes
08:34:03 * bgamari really wish there were better tools for diagnosing these sorts of issues
08:36:17 <pordan30> Is there a reason why installing haskell-src-exts using cabal would fail citing dependencies on happy (v1.17 or greater) when happy (v1.18) was installed using cabal just prior?
08:37:21 <bgamari> hmm
08:37:32 <bgamari> Writer [Arc] displays the same overflow
08:37:35 <fmap> pordan30: do you have happy in your PATH?
08:37:39 <dcoutts_> pordan30: if it's not on your path
08:37:41 <geekosaur> pordan30, you don't have ~/.cabal/bin in $PATH
08:39:38 <dada-cetacean> when using an as-pattern, such as "f s@(x:xs) = x:s", what does adding the "s@" between f and (x:xs) do exactly?
08:40:16 <quicksilver> it makes 's' a name for the expression (x:xs)
08:40:17 <int-e> dada-cetacean: give a name (s) to the value matched by the pattern (x:xs)
08:41:09 <int-e> f (x:xs) = x:x:xs would be equivalent but may create a new list cons for the x:xs on the right-hand side.
08:41:36 <pordan30> fmap, dcoutts, geekosaur: that's right; i updated my path but cabal-installed using sudo. that fixed the problem. thanks
08:42:54 <geekosaur> don't use sudo with cabal-install, i tonly leads to pain
08:43:29 <geekosaur> (if you don't use --global tjen it installs in a not so useful place; with --global it will just make your life much more difficult)
08:46:01 <pordan30> not using global installs into unuseful places but using global makes life difficult? so the solution is to pay attention to the install locations?
08:47:56 <geekosaur> so, with cabal-install you can get yourself into messes (less often with th elatest versions but can still happen) where your insralls are inconsistent and break everything.  if you used --global, the solutiuon is to wip out your entire ghc installation
08:48:22 <geekosaur> if you didn;t use --global you can remove your local package stash and still have a working compiler andboot libs (and hopefully Platform)
08:49:00 <geekosaur> the local package stash is per user, so if you use sudo cabal-install without --global it's installed in root's local/private packages, not yours
08:55:30 --- mode: ChanServ set +o maukd
08:55:31 --- kick: average_drifter was kicked by maukd (test)
08:57:31 --- mode: maukd set -o maukd
08:58:30 <pordan30> thanks for the information, geekosaur. it looks like i will need to fix up my packages.
09:09:28 <hiptobecubic> Is there a monadic way to get the "power set" of a list of elements?
09:10:02 <pordan30> there is the classic filterM (const [True,False])
09:10:11 <hiptobecubic> pordan30, oh right, that mess
09:10:25 <hiptobecubic> pordan30, have to remember how the hell that thing works
09:10:35 <maukd> filterM (return [True, False])  -- now with 100% more monads
09:10:47 <maukd> hiptobecubic: oh, that bit is easy!
09:10:56 <maukd> the list monad is multiple parallel universes
09:11:08 <maukd> so you both select and don't select each element
09:11:38 <maukd> and you end up with a bunch of worlds where every possible combination of elements is in the list (or not)
09:11:57 <hiptobecubic> maukd, that is a *great* explanation
09:12:08 <hiptobecubic> suddenly, list makes sense as a monad
09:12:10 <hiptobecubic> thank you
09:12:22 <maukd> ... really? I wasn't sure it made sense to anyone but me :-)
09:12:28 <hiptobecubic> maukd, yes really.
09:12:45 <hiptobecubic> maukd, although mechanically, I don't see how the code actually implements such an idea.
09:12:57 <hiptobecubic> we return [True, False]
09:13:07 <maukd> > do { x <- [1, 2]; y <- "abc"; return (x, y) }
09:13:08 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c')]
09:13:16 <hiptobecubic> but the monad there is actually functions right?
09:13:37 <maukd> in my version the 'return' is from the function monad, yes (and equivalent to 'const')
09:13:48 <maukd> that's because we ignore the element itself
09:14:13 <maukd> @src filterM
09:14:13 <lambdabot> Source not found. :(
09:14:15 <maukd> aw
09:14:40 <maukd> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad.html#filterM
09:15:01 <maukd> every "<-" is an implicit loop
09:15:10 <quicksilver> for each element you say "Yes and No, both"
09:15:15 <quicksilver> irrespective of the element
09:15:19 <quicksilver> that's why it's "const"
09:15:26 <hiptobecubic> maukd, aha
09:15:40 <quicksilver> it's not examining the element - just always including and excluding it.
09:16:02 <hiptobecubic> right
09:16:07 <maukd> > [ x | x <- "abc" ]
09:16:08 <lambdabot>   "abc"
09:16:17 <maukd> > [ x | x <- "abc", p <- [True, False], p ]
09:16:18 <lambdabot>   "abc"
09:16:59 <pordan30> if you are thinking declaratively, like in logic programming, you can read the expression filterM (const [True,False]) xs as: for every possible way p in which the values true and false can be assigned to each element of xs, return the values assigned true in p.
09:17:38 <pordan30> that explanation has always made sense when you think of the list monad as capturing nondeterministic computations, because it maps well to e.g., how you would program something like the powerset of a list in prolog
09:28:17 * hackagebot acid-state 0.7.8 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.8 (DavidHimmelstrup)
09:29:05 <Morgawr> okay... I'm using glade to develop a UI with Gtk for a haskell program, however the latest versions of glade use Gtk3 and there are some differences  that won't work with gtk2hs, is there an updated gtk3 for haskell or am I out of luck?
09:29:43 <Morgawr> specifically I was reading this http://comments.gmane.org/gmane.comp.lang.haskell.gtk2hs/2941
09:31:51 <hiptobecubic> maukd, if we look at the source for filterM
09:31:55 <hiptobecubic> flg <- p x
09:32:04 <hiptobecubic> p is (return [True, False])
09:32:24 <hiptobecubic> @src (-> e) return
09:32:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:32:29 <benmachine> hiptobecubic: const
09:32:34 <benmachine> so p x is [True, False]
09:32:34 <ski> @src (->) return
09:32:34 <lambdabot> return = const
09:33:20 <hiptobecubic> so we flg <- [True, False]
09:33:59 <hiptobecubic> which clones the universe into two, one were flg is true and one where it's false :) ?
09:35:28 <hiptobecubic> and ys <- then forks off another (length xs) universes
09:35:47 <hiptobecubic> well no, another length filterM p xs universes
09:36:20 <hiptobecubic> and in each universe, we either include the element we're considering or we don't
09:40:16 <ski> hiptobecubic : .. reminds me of `exportML : string -> bool' in SML/NJ
09:40:29 <hiptobecubic> ski, what is it?
09:41:17 <ski> hiptobecubic : it takes the current state of the system, stores it in a file named by the string (apparently with architecture added at the end), and then returns `false'
09:41:38 <hiptobecubic> ski, oh wow
09:41:42 <ski> hiptobecubic : then you can start a new process that resumes from that heap, though in that process, the call returns `true'
09:42:18 <maukd> hiptobecubic: yes
09:43:49 <ski> (hiptobecubic : where by "system" i mean "the SML/NJ system", i.e. the process state -- though, for obvious reasons, it can't serialize stuff like mutable cells, open handles, sockets, in a way that those refer to the same resources as in the original process)
09:44:23 <hiptobecubic> ski, of course. But still it's a nice idea
09:44:40 <ski> some Scheme and Common Lisp systems also has this thing
09:44:48 <hiptobecubic> that you can save your program, print it out and mail it to someone as part of the evaluation model :)
09:46:54 <bgamari> ghci uses haskeline, yes?
09:47:11 <ski> typically, this feature is used to create an interactor for some system that has been written in SML -- so you'd write a wrapper that loads the respective modules, then calls `exportML', if the output is `false' the program prints "Success", otherwise it starts the main loop of the program
09:48:00 <ski> (and you can also do stuff like GCing everything from the system, except that which is needed to run the program -- e.g. the compiler needn't be included in the heap image `exportML' creates)
09:50:56 <maukd> perl used to have a similar system, sort of
09:51:41 <maukd> a 'dump' builtin that dumps core
09:51:42 <maukd> then all you need is an 'undump' utility that turns coredumps into executables
09:53:44 <ski> in the case of SML/NJ, you can specify which heap to start with (instead of the default heap, which includes the compiler, and the normal interactor), on the command line
09:58:18 * hackagebot acid-state 0.7.9 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.9 (DavidHimmelstrup)
10:08:43 <noviceprogrammer> hello
10:09:12 <hiptobecubic> noviceprogrammer, hello again
10:09:22 <noviceprogrammer> ^^ hai2u2
10:09:46 <noviceprogrammer> time to learn more about FP
10:10:37 <noviceprogrammer> are Type Classes essetial to FP? What about pattern matching?
10:11:33 <tromp> no; but they're very convenient
10:12:34 <noviceprogrammer> indeed
10:12:49 <mroman> The most essential thing is \
10:13:08 <noviceprogrammer> lambda?
10:13:19 * hackagebot acid-state 0.7.10 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.10 (DavidHimmelstrup)
10:13:31 <tromp> essential is being based on lambda calculus
10:13:59 <noviceprogrammer> so it's an entirely different take on the notion of computation?
10:14:16 <tromp> it's computation by evaluation
10:14:45 <tromp> rather than by state transformation
10:15:27 <noviceprogrammer> so evaluation => reducing complex expressions ultimtely by substituting values?
10:16:36 <tromp> substituting expressions is what lambda calculus is all about
10:17:04 <lpvb> noviceprogrammer: www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
10:17:30 <noviceprogrammer> I don't really know anything about the lambda calculus besides the fact that the term 'lambda expression/function' and the corresponding keywords come from it ^^
10:17:34 <noviceprogrammer> I
10:17:44 <lpvb> you don't need to
10:18:00 <mroman> You can experiment lc in Haskell if you wish to.
10:19:21 <mroman> > ((\a b -> (\f -> f a b)) 5 6) (\a b -> a)
10:19:22 <lambdabot>   5
10:19:25 <mroman> and such.
10:19:38 <noviceprogrammer> so there's a huge difference between the functions in a FP language and `functions` (procedures that take inputs and output values) in procedural programming languages like C and Java?
10:19:50 <mroman> > ((flip . flip id) 5 6) const
10:19:52 <lambdabot>   5
10:20:54 <lpvb> noviceprogrammer: are you trying to learn everything about FP from this IRC?
10:21:27 <mroman> You can think of functions as one big 'expression' I guess.
10:21:33 <noviceprogrammer> just the parts relevant to the Haskell language
10:21:38 <mroman> or function chained together.
10:22:02 <mroman> print 5; print 6; in an imperative language are just two seperate function calls.
10:22:18 <noviceprogrammer> right
10:22:39 <mroman> Which is usually not possible that way in purely functional programming languages.
10:23:20 * hackagebot acid-state 0.8.0 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.8.0 (DavidHimmelstrup)
10:24:12 <mcstar> imperative languages are better, they have arrows, but pure functional languages only have functions... XD
10:24:12 <lpvb> noviceprogrammer: http://www.haskell.org/haskellwiki/Why_Haskell_matters
10:24:25 <noviceprogrammer> was enlightened when I saw that assignment in a conventional language is equivalent to binding to a lambda in a FP language.
10:24:53 <lpvb> except for mutability
10:25:00 <lpvb> binding is still immutable
10:25:05 <noviceprogrammer> ah
10:26:53 <mroman> @unlet let x = 5 in x+x
10:26:54 <lambdabot>   TemplateHaskell is not enabled
10:26:57 <mroman> hm.
10:27:20 <pordan30> Œªx.œÜ reduces to œÜ[x:=y] for any y applied to Œªx.œÜ regardless of where x occurs in œÜ, but x := y; œÜ does not necessarily reduce to œÜ[x := y] because where x occurs in œÜ is now relevant.
10:27:30 <mroman> > (\x -> x + x) 5
10:27:31 <lambdabot>   10
10:27:39 <mroman> > ($5) (join (+))
10:27:40 <lambdabot>   10
10:29:49 <mroman> > (\f -> f $ 5) (\x -> x + x)
10:29:50 <lambdabot>   10
10:29:55 <mroman> So many ways.
10:30:42 <copumpkin> (\x -> x x) (\x -> x x)
10:32:24 <nicoo> copumpkin: Why omega ?
10:32:30 <copumpkin> why not
10:33:02 <nicoo> Well, it is not well-typed in Haskell, AFAIK
10:33:20 * hackagebot dates 0.2.0.2 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.2.0.2 (IlyaPortnov)
10:34:05 <nicoo> hackagebot: You are dating 0.2.0.2 ?
10:34:07 <hpaste> rosie pasted ‚Äúmaptree‚Äù at http://hpaste.org/75415
10:34:11 <nicoo> Is it also a bot ?
10:34:15 <byorgey> hehe
10:34:21 <Philonous> @type let w = (\x -> x x) in w w
10:34:22 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:34:22 <lambdabot>     Probable cause: `x' is applied to too many arguments
10:34:22 <lambdabot>     In the expression: x x
10:34:30 <Philonous> Nope, it's not.
10:34:33 <rosie> Why do I get the error "Not in scope 'f'"?
10:35:08 <Philonous> rosie:  Most likely because f is not in scope
10:35:15 <rwbarton> that is probably not the code producing the error. check the line number
10:35:24 <merijn> rosie: Presumably because f is not in scope? :D Paste the offending code somewhere? :p
10:35:38 <ceii> rosie: looks just fine to me
10:35:47 <ceii> are you sure this is the right part of the file?
10:36:16 <rosie> ceii: thanks, sorry all! wrong file
10:36:33 <byorgey> nicoo, Philonous: however, omega can be encoded in Haskell using  newtype D = D (D -> D)
10:37:03 <rwbarton> @type let w :: (forall a. a -> a) -> (forall a. a -> a); w = \x -> x x in w w
10:37:04 <lambdabot>     Couldn't match expected type `forall a. a -> a'
10:37:05 <lambdabot>            against inferred type `a -> a'
10:37:05 <lambdabot>     In the first argument of `w', namely `w'
10:37:15 <Philonous> byorgey:  Yeah, you can of course do an iso-recursive version
10:37:34 <rwbarton> oh right
10:39:34 <nicoo> byorgey: Of course
10:40:08 <Philonous> Actually, is there a language with equirecrusive data types?
10:40:28 <rwbarton> ocaml supports them if you turn on a compiler option
10:42:01 <nicoo> -rectypes, yes
10:47:05 <mroman> Can you do a loop in data's with that?
10:47:36 <mroman> data Chain a = Next a (Chain a) ?
10:48:22 <Philonous> mroman:  That's called a Stream
10:48:43 <mroman> so I can have three Nexts and then point to the first Next?
10:49:09 <mroman> The only valid thing to do with the definition above is
10:49:12 <mroman> fix (Next 0)
10:49:36 <Philonous> http://hackage.haskell.org/packages/archive/Stream/0.4.6/doc/html/Data-Stream.html
10:50:48 <c_wraith> only valid thing?
10:51:24 <c_wraith> incrementingChain n = Next n $ incrementingChain (n + 1)
10:52:08 <Philonous> REgarding "three Nexts and then point to the first Next?" That's called "tying the knot" http://www.haskell.org/haskellwiki/Tying_the_Knot
10:53:05 <c_wraith> fix $ Next 1 . Next 2 . Next 3
10:53:10 <c_wraith> etc, etc
10:54:34 <food> @pl \x -> if x `mod` 3 == 0 then if x `mod` 5 == 0 then "FizzBuzz" else "Fizz" else if x `mod` 5 == 0 then "Buzz" else show x
10:54:35 <lambdabot> ap (if' . (0 ==) . (`mod` 3)) (flip (flip if' "FizzBuzz" . (0 ==) . (`mod` 5)) "Fizz") `ap` ap (flip if' "Buzz" . (0 ==) . (`mod` 5)) show
10:56:46 <mcstar> i want to hire this guy, come back!
10:58:06 <Mortchek> Well that was rather pointless
10:58:15 <Philonous> Hah, I wish someone would hire me for writing fizzbuzz. "Will write fizzbuzz for food!"
10:59:32 <c_wraith> I'm still not satisfied with any of my formulations of fizzbuzz in haskell.
10:59:50 <mcstar> Mortchek: hehe
10:59:53 <nand`> I think the one I like most is the case (x `mod` 3, x `mod` 5) of (0, 0) -> ... thing
11:00:22 <Philonous> nand`:  No enough arcane Arrow-combinators
11:00:38 <Philonous> Not*
11:00:46 <mcstar> i can solve FizzBuzz for small numbers by hand
11:00:47 <c_wraith> hmm.  maybe with monad comprehensions
11:01:01 <nand`> (\case (0,0) -> ...) . (`mod` 3) &&& (`mod` 5) -- ?
11:01:01 <c_wraith> I could use a maybe comprehension
11:03:07 <MostAwesomeDude> fb x | x `mod` 15 == 0 = "FizzBuzz"; | x `mod` 5 == 0 = "Fizz"; | x `mod` 3 == 0 = "Buzz"; | otherwise = show x
11:03:07 <mcstar> i have a half-working asteroids clone!
11:03:12 <MostAwesomeDude> I'm still okay with that one.
11:03:28 <MostAwesomeDude> But maybe that's too simple and obvious.
11:04:16 <mcstar> 200 lines, and i can shoot them down
11:04:21 <Philonous> @type shift
11:04:22 <lambdabot> forall a. (Bits a) => a -> Int -> a
11:04:24 <mcstar> needs some effects and stuff
11:04:27 <nand`> mcstar: gloss?
11:04:31 <mcstar> ah, no
11:04:34 <mcstar> gloss sucks :)
11:04:40 <mroman> c_wraith: Yeah, I know.
11:04:45 <nand`> mcstar: alternatives to gloss?
11:04:51 <mroman> But I consider that to be the same useless thing ;)
11:04:51 <mcstar> opengl
11:05:20 <mcstar> nand`: gloss is comfortable, but primitive, you can reach the limit of its usefulness quickly
11:05:40 <Philonous> @type pushPrompt
11:05:42 <lambdabot> Not in scope: `pushPrompt'
11:05:44 <mcstar> i did you gloss, at the beginning
11:05:54 <nand`> but I imagine it must be a great match for those simple games, just draw polygons for sprites :)
11:05:58 <mcstar> but things didnt work out, since this is a game, not some animation
11:06:16 <mcstar> you -> use
11:06:52 <mcstar> ive seen a CL asteroids clone, a beginner programmer wrote it, and that motivated me to actually do this in haskell
11:07:02 <mcstar> when i reach the same functionality, ill look at the CL code
11:07:04 <mcstar> and compare
11:07:13 <mroman> I don't need infinite lists.
11:07:26 <mroman> At least I think :)
11:07:43 <nand`> non-infinite lists are useless. all you can do is stuff like [0], [1..], [3, 2, 1], etc.
11:07:59 <nand`> s/non-/not necessarily /
11:07:59 <mroman> In OOP you can have one Object referenced by lots of other objects.
11:08:19 <mroman> Thinking of that
11:08:24 <mroman> I think I can modell my stuff with graphs
11:09:15 <mroman> So I won't need stuff in a data referencing other stuff in itself.
11:10:31 <c_wraith> fizzbuzz x = fromMaybe (show x) $ mappend ["fizz" | x `rem` 5 == 0] ["buzz" | x `rem` 3 == 0]
11:11:00 <c_wraith> That satisfies my desire for regularity
11:11:03 <nand`> cute
11:11:10 <mroman> The question is if one actually could modell a "graph" with data
11:11:30 <c_wraith> however, it uses the instance for Monoid for Maybe that I really consider kind of broken
11:11:30 <mroman> (Not using a graph of course)
11:11:59 <c_wraith> and also, it leans on MonadComprehensions
11:12:21 <nand`> c_wraith: except it's wrong, isn't it? ‚Äòfizz‚Äô for 5
11:12:24 <mroman> e.g A binary tree where a node can point back to the root node or point to any other node in the tree
11:12:34 <mroman> creating different loops in the whole structure.
11:12:37 <c_wraith> nand`: whatever, swap the 3 and the 5.
11:12:52 <c_wraith> nand`: I can't actually remember the problem formulation, so I picked something at random. :)
11:12:56 <nand`> heh
11:13:01 <nand`> I just remember that ‚Äòfizz‚Äô comes first
11:13:07 <nand`> thus 3
11:13:11 <Rc43> Hi, guys.
11:13:15 <kirindave_> Fizzbuzz?
11:13:26 <c_wraith> nand`: well, swapping the 3 and the 5 would do that, then
11:13:44 <c_wraith> I really don't like that monoid instance for Maybe - but it's handy for things like that.  I'm so torn.
11:13:48 <mcstar> c_wraith: you missed the unit tests
11:13:55 <nand`> mroman: you mean like data Tree a = Empty | Bin a (Tree a) (Tree a) ?
11:14:14 <kirindave_> c_wraith: Are you agonizing over the implementation of fizzbuzz? Tell me you're not.
11:14:21 <nand`> c_wraith: liftM2 (++)
11:14:34 <c_wraith> nand`: that won't work
11:14:43 <c_wraith> kirindave_: not anymore! I found an implementation I like
11:14:47 <nand`> oh, right
11:14:50 <kirindave_> Dangiit.
11:14:55 <nand`> yeah, I see the difference in the monoid instance now
11:15:00 <kirindave_> c_wraith: Well then now I am compelled to ask to see it.
11:15:03 <c_wraith> kirindave_: fizzbuzz x = fromMaybe (show x) $ mappend ["fizz" | x `rem` 5 == 0] ["buzz" | x `rem` 3 == 0]
11:15:07 <mroman> http://upload.wikimedia.org/wikipedia/commons/5/5b/6n-graf.svg
11:15:11 <c_wraith> it just needs MonadComprehensions :)
11:15:22 <c_wraith> also, swapping the 3 and the 5
11:15:30 <c_wraith> if you want the answer to be "correct" or whatever
11:16:04 <mroman> ^- You can modell that as a graph
11:16:04 <kirindave_> c_wraith: I was gonna say I was not familiar with the syntax you used there.
11:16:20 <kirindave_> c_wraith: But I guess yeah if it's a monad comprehension that works.
11:16:23 <mroman> with either a Matrix or a List of Edges
11:16:38 <kirindave_> c_wraith: The problem is actually "display from 1-n"
11:16:43 <mroman> In stateful OOP languages you can do it with actual objects.
11:16:47 <mroman> (obviously)
11:16:51 <DrPete> http://www.haskell.org/haskellwiki/Tying_the_Knot this comes up when I search for "cyclic graphs", the Dfa stuff in particular looks interesting
11:16:52 <c_wraith> kirindave_: they've been in GHC for a bit (since 7.2?), but they aren't used much
11:16:58 <kirindave_> c_wraith: And fizz is for 3, buzz is for 5.
11:17:30 <kirindave_> c_wraith: And about half the formulations ask you to print the number if it is not a fizzbuzz, the other ones ask you not to.
11:17:32 <mroman> I guess it is possible with IORef.
11:17:39 <noviceprogrammer> is there a better way of writing the following? sum $ filter (\n -> n /= 3 && n /= 6) [1..10] ?
11:17:50 <noviceprogrammer> > sum $ filter (\n -> n /= 3 && n /= 6) [1..10] ?
11:17:51 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:18:02 <noviceprogrammer> > sum $ filter (\n -> n /= 3 && n /= 6) [1..10]
11:18:03 <lambdabot>   46
11:18:15 <c_wraith> kirindave_: main = mapM putStrLn [ fromMaybe (show x) $ mappend ["fizz" | x `rem` 3 == 0] ["buzz" | x `rem` 5 == 0] | x <- [1..100] ] -- happy now? :P
11:18:21 <nand`> > sum . filter (/= 3) . filter (/= 6) $ [1..10]
11:18:22 <kirindave_> c_wraith: Lol.
11:18:24 <lambdabot>   46
11:18:24 <mcstar> btw, the 'problem' in FizzBuzz is getting the little things right
11:18:39 <kirindave_> There is no deep insight in fizzbuzz
11:18:40 <mroman> > sum . filter (liftM2 (&&) (3 /=) (6 /=)) $ [1..10]
11:18:42 <lambdabot>   46
11:18:47 <noviceprogrammer> sum [x | x <- [1..10], x /= 3 && x /= 6] seems the best
11:18:48 <kirindave_> People try to find it, because they don't understand some people cannot freaking code it.
11:19:02 <Philonous> > sum $ filter (`notElem` [3,6]) [1..10]
11:19:03 <mroman> (This time I win at being the first to mention liftM2)
11:19:03 <lambdabot>   46
11:19:04 <mcstar> that what im saying too
11:19:15 <noviceprogrammer> what is liftM2?
11:19:22 <kirindave_> noviceprogrammer: Welcome to Haskell!
11:19:24 <Philonous> @src liftM2
11:19:24 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:19:25 <mcstar> they would make mistakes, like switching 5 for 3 or alike
11:19:30 <nand`> liftM2 f a b = -- yeah that
11:19:38 <noviceprogrammer> ah
11:19:43 <noviceprogrammer> so it takes two monads
11:20:01 <mcstar> no, its the same monad
11:20:04 <Philonous> noviceprogrammer:  A binary function and two monadic actions
11:20:10 <noviceprogrammer> my mind is exploding
11:20:19 <Philonous> noviceprogrammer:  But of the same monad
11:20:27 <mroman> I would love to see the source for Monad (->)
11:20:29 <c_wraith> kirindave_: sure, but it's a simple problem that I feel like is awkward in haskell, because I can't find the right abstraction for it.  So I keep looking for the right abstractions.  Monad comprehensions at least allow concisely expressing the tests.
11:20:31 <noviceprogrammer> although I think the list comp I wrote is sugar for liftM2
11:20:34 <mroman> but it seems to be very well hidden somewhere in a dark place.
11:20:44 <nand`> if you change ‚Äòbinary‚Äô to ‚Äòdyadic‚Äô then the formulation for liftM would be amusing
11:20:57 <kirindave_> c_wraith: I mean, Int -> String captures the damn thing just fine.
11:21:18 <nand`> mroman: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#Monad
11:21:28 <c_wraith> kirindave_: That's not a very abstract type.  Doesn't tell me a thing about the abstractions in use!
11:21:29 <mcstar> c_wraith: why wont you consider MostAwesomeDude 's solution good enough?
11:21:31 <nand`> it's also not Monad (->)
11:22:04 <mroman> join (+) relies on Monad ((->)r)?
11:22:14 <c_wraith> mcstar: extreme dislike for if and case.  They feel like doing things manually, like I'm missing an important abstraction for working with my data.
11:22:24 <kirindave_> c_wraith: What abstractions? It's like only defined over ints. The only room for abstraction is in the codomain.
11:22:34 <Philonous> mcstar:  "Good enough" is not the point. It's about impressing everybody with how clever you are and how many books about delimited continuations you've read. (At least for me it is)
11:22:40 <mroman> f >>= k = \r -> k (f r) r
11:22:43 <mroman> I see.
11:22:43 <kirindave_> c_wraith: And even that i quite limited .
11:22:49 <nand`> one thing I dislike about the naive formulation is that "fizzbuzz" is repeat, as is the check for mod5 && mod3 (even if reduced to mod15)
11:23:12 <mroman> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2); }
11:23:13 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
11:23:27 <noviceprogrammer> :t [x | x <- [1..10]]
11:23:28 <lambdabot> forall t. (Num t, Enum t) => [t]
11:23:35 <c_wraith> kirindave_: abstraction in the structure of the solution, not in the structure of the inputs
11:23:47 <Philonous> noviceprogrammer:  That's just [1..10]
11:24:27 <kirindave_> c_wraith: I just submit there is little abstraction there to be had. It's a very simple map.
11:24:37 <mroman> Can lambda bot replace >>= with it's definition?
11:24:49 <mroman> that'd be a helpful feature
11:24:54 <noviceprogrammer> :t >>=
11:24:55 <lambdabot> parse error on input `>>='
11:24:57 <rwbarton> what definition
11:25:02 <c_wraith> kirindave_: you say that, yet I found a way to use less logic in my solution by using monoidal structure
11:25:05 <Philonous> :t (>>=)
11:25:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:25:12 <mroman> rwbarton: f >>= k = \r -> k (f r) r <- that definition
11:25:13 <noviceprogrammer> isn't >>= bitshift-right assign?
11:25:13 <rwbarton> or should I say, which definition
11:25:14 <c_wraith> kirindave_: I think that's an improvement
11:25:21 <Philonous> noviceprogrammer:  It's monadic bind
11:25:26 <noviceprogrammer> ah
11:25:37 <noviceprogrammer> so it's like the functional version of assignment
11:25:55 <rwbarton> there isn't any lambdabot feature that will do that kind of type class instance selection and replacement by source, no
11:26:02 <c_wraith> Not quite assignment..  More "doing something with a result, and assigning that result"
11:26:09 <rwbarton> lambdabot's @pl is totally untyped
11:26:10 <Philonous> noviceprogrammer:  No. It's like the monadic version of flip ($)
11:26:20 <mroman> hm.
11:26:24 <int-e> @src [] (>>=)
11:26:24 <lambdabot> xs >>= f     = concatMap f xs
11:26:27 <int-e> @src Maybe (>>=)
11:26:27 <lambdabot> (Just x) >>= k      = k x
11:26:28 <lambdabot> Nothing  >>= _      = Nothing
11:26:35 <int-e> etc, it depends on the monad
11:26:41 <rwbarton> well the exception would be if you can use @type and @djinn
11:26:48 <nand`> @pl \x -> case x of y -> y
11:26:49 <mcstar> im facing a harder challenge now, i want to resolve collisions between asteroids and projectiles succintly
11:26:49 <lambdabot> (line 1, column 19):
11:26:49 <lambdabot> unexpected ">" or "-"
11:26:49 <lambdabot> expecting variable, "(", operator or end of input
11:26:53 <mroman> > (+) >>= (+)
11:26:54 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
11:27:16 <mroman> @src join
11:27:16 <lambdabot> join x =  x >>= id
11:27:42 <int-e> :t succ >>= (+)
11:27:43 <lambdabot> forall a. (Enum a, Num a) => a -> a
11:28:04 <c_wraith> (to my dissatisfaction, the monoidal structure I used is misnamed Maybe.  Maybe's Monoid instance is.. unfortunately inconsistent with its Alternative and MonadPlus instances.  It'd be nice to have a type with that Monoid instance that wasn't Maybe.)
11:28:27 <mroman> > (\r -> id (x r) r)) (+)
11:28:28 <lambdabot>   <no location info>: parse error on input `)'
11:28:33 <mroman> > (\r -> id (x r) r) (+)
11:28:34 <lambdabot>   Couldn't match expected type `t -> a'
11:28:34 <lambdabot>         against inferred type `Simple...
11:28:42 <nand`> c_wraith: FreeMonoid or something?
11:28:54 <nand`> as in, from a semigroup
11:29:03 <rwbarton> MonoidFromASemigroupFactory
11:29:18 <nand`> perfect
11:29:28 <kirindave_> c_wraith: Does your code actually compile?
11:29:32 <c_wraith> kirindave_: yep
11:29:40 <mroman> x >>= id should actually be (\r -> id (x r) r)?
11:29:41 <c_wraith> kirindave_: with the proper imports and extensions enabled :)
11:30:07 <mroman> > (\r -> id ((+) r) r) 5
11:30:08 <lambdabot>   10
11:30:09 <nand`> kirindave_: sure it does http://bpaste.net/show/47984/
11:30:25 <mroman> hm.
11:30:30 <rwbarton> guard (x `rem` 3 == 0) >> Just "fizz" is not that onerous
11:30:39 <mroman> @src liftM2
11:30:39 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:30:44 <kirindave_> Oh that's not what was actually pasted earlier. :)
11:30:54 <nand`> "fizz <$ guard (x `rem` 3 == 0)
11:31:27 <kirindave_> Hmm. Did my client kill the <>'s?
11:31:40 <nand`> c_wraith gave it with mappend instead of <>
11:31:49 <nand`> but that's equivalent, and actually needs an import less
11:32:15 <c_wraith> it's the same operation, so whatever
11:32:32 <c_wraith> (<>) = mappend
11:32:32 <mroman> > (+5) >>= (+) $ 5
11:32:33 <lambdabot>   15
11:32:36 <c_wraith> full source. :)
11:32:36 <mroman> he.
11:33:20 <kirindave_> http://bpaste.net/show/YE6mP2bR0qPzC1LhuP0p/ doesn't seem to.
11:33:32 <kirindave_> Just sayin'.
11:33:33 <mroman> > let mulBy3 x = (+x)>>=(+) in mulBy3 3
11:33:34 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
11:33:35 <lambdabot>    arising from a use of `...
11:33:57 <mroman> > let mulBy3 x = (+x)>>=(+)$x in mulBy3 3
11:33:58 <lambdabot>   9
11:34:09 <kirindave_> Even if you fix my paste error.
11:34:17 <mroman> sweet.
11:34:42 <nand`> kirindave_: the error is in line 1 :)
11:34:59 <c_wraith> oh, should have used mapM_, too
11:35:02 <c_wraith> that was my mistake
11:35:08 <nand`> not that it should matter
11:35:11 <c_wraith> though it wouldn't affect the output of the program
11:35:13 <nand`> that's an ugly file either way
11:35:22 <mroman> > (*5) >>= (*) $ 5
11:35:24 <lambdabot>   125
11:35:43 <nand`> I would go with what I pasted and tack on:  main = print $ map fizzBuzz [1..100]
11:35:46 <c_wraith> kirindave_: you forgot the #s on the pragma
11:35:55 <nand`> unless you want it in ugly line-based output
11:35:59 <mroman> > let threeTimes f x = (f x)>>=f$f in threeTimes (*) 5
11:36:00 <lambdabot>   Occurs check: cannot construct the infinite type: a = a1 -> a -> a1
11:36:05 <kirindave_> Ahh derp
11:36:08 <mroman> > let threeTimes f x = (f x)>>=f$x in threeTimes (*) 5
11:36:09 <lambdabot>   125
11:36:16 <c_wraith> nand`: most of the formulations of the problem I've seen call for line-based output
11:36:16 <kirindave_> That's what I get for not using my emacs env.
11:36:47 <nand`> well the formulation I prefer just asks for :: Integer -> String
11:37:03 <c_wraith> well, that's the only interesting part, yes
11:37:03 <nand`> anything else is an unnecessary implementation detail disjoint to the problem
11:37:13 <mroman> > (join . (flip =<< ((>>=) .))) (-) 1
11:37:15 <lambdabot>   -1
11:37:16 <rwbarton> i'm pretty sure "can you write a loop" is part of what the problem is supposed to be testing :P
11:37:24 <aleksandar> hello
11:37:36 <nand`> bummer, I must have failed that test
11:37:42 <aleksandar> how can I print text in colors
11:37:59 <aleksandar> I tried putStrLn "\033[2;38;5;150m test \033[0m"
11:38:07 <aleksandar> but that turns \033 into !
11:38:15 <nand`> > '\o33'
11:38:16 <lambdabot>   '\ESC'
11:38:32 <kirindave_> I actually had people fail fizzbuzz at my last job doing interviews too
11:38:34 <rwbarton> \033 is decimal
11:38:36 <int-e> > '\27'
11:38:38 <lambdabot>   '\ESC'
11:38:38 <kirindave_> There was one amusing kid
11:38:39 <nand`> 033 is unicode point U+33
11:38:41 <mcstar> you need ^[
11:38:45 <nand`> no?
11:38:52 <kirindave_> Who could do it only in the context of an ERB template.
11:38:57 <rwbarton> > ord '\033'
11:38:58 <lambdabot>   33
11:39:01 <kirindave_> And could not write a standalone program to do it.
11:39:04 <nand`> err, not U+33
11:39:04 <mroman> kirindave_: ?
11:39:06 <nand`> but codepoint 33
11:39:09 <rwbarton> right
11:39:12 <nand`> I forgot U+ is hexadecimal notation
11:39:15 <aleksandar> that works thanks
11:39:16 <tromp> what's ERB?
11:39:26 <mcstar> ^[[44m
11:39:47 <c_wraith> tromp: the template mechanism rails uses
11:39:48 <kirindave_> Embedded Ruby Templates
11:40:00 <kirindave_> Basically nightmare.rb.html
11:40:13 <kirindave_> Although I suppose hamlet templates are only marginally better.
11:40:43 <c_wraith> I guess that's what happens when you have programmers who've only ever worked in the context of rails
11:40:54 <kirindave_> c_wraith: Hah, his history included PHP so...
11:40:57 <kirindave_> SO THERE!
11:41:02 * nand` shudders
11:41:32 <luite> what does it mean? Enterprise Rails Beans?
11:41:39 <c_wraith> I stand corrected!
11:41:45 <kirindave_> luite: What?
11:41:46 <c_wraith> luite: kirindave_ covered that up there
11:41:52 <luite> ah tnx
11:42:20 <luite> doesn't explain the 'B' though?
11:42:41 <whittle> Embedded RuBy.
11:42:46 <rwbarton> Ru-B
11:42:47 <luite> clearly it needs a new meaning
11:42:49 <kirindave_> Oh
11:42:52 <nand`> ‚ÄòEmbedded Ruby templates, Basically nightmare.rb.html‚Äô
11:42:57 <nand`> oh
11:43:00 <kirindave_> No "ERB" is a contraction of "embedded .rb"
11:43:20 <kirindave_> And in case you think that's dumb?
11:43:24 <kirindave_> Yes. It is.
11:45:09 <osfameron> Just Say No to embedded languages in templates
11:46:03 <nand`> yeah, like english
11:48:41 <pnielsen> ew
11:49:02 <c_wraith> yeah, embedding english in html should be forbidden
11:49:28 <pnielsen> kirindave_: 85%+ of the people I interview fail to implement fizzbuzz efficiently, even though they have impressive resumes
11:49:31 <pnielsen> kirindave_: it's really scary
11:50:11 <mroman> > unlines.map(\q->[show q,"FizzBuzz","Fizz","Buzz"]!!(succ.fromMaybe (-1).findIndex(==1).map(fromEnum.(==0).($q))$[(`rem`15),(`rem`3),(`rem`5)]))$[1..100]
11:50:13 <lambdabot>   "1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n1...
11:50:25 <hdev> what are the general ways to do large scale domain modelling in haskell/functional programming in general for a database centric application? i have seen a presentation suggesting event-sourcing + fsm
11:50:26 <pnielsen> asking for their github account and inspecting some code gives a much more accurate impression
11:50:48 <Ferdirand> what's fizzbuzz ?
11:50:58 <stephenjudkins> what's wrong with embedded languages in templates? it's a tool that can be easily abused, sure. but I think there are plenty of other useful tools that are just as easy to abuse...
11:51:00 <pnielsen> mroman: that would fail my interview :p
11:51:04 <mroman> People not capable of implementing FizzBuzz <verb> for a job as a programmer?
11:51:15 <mroman> *apply
11:51:21 <mroman> pnielsen: No fair.
11:51:24 <mroman> It does the job!
11:51:34 <pnielsen> mroman: `mod` 3, `mod` 5 and (`mod3`||`mod5) or `mod` 15, tsk tsk
11:51:35 <mroman> ;P
11:51:44 <pnielsen> 3 and 5 are sufficient
11:51:47 <simon> @pl foldr (\(p,_) acc -> max p acc) (0,0)
11:51:47 <lambdabot> foldr (max . fst) (0, 0)
11:52:00 <nand`> &&, not ||
11:52:12 <pnielsen> yeah
11:52:15 <pnielsen> sorry
11:52:47 <pnielsen> Ferdirand: http://c2.com/cgi/wiki?FizzBuzzTest
11:52:48 <nand`> pnielsen: so what do you have to say about the mappend/MonadComprehensions solution? :)
11:52:56 <pnielsen> Ferdirand: http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html
11:53:22 * hackagebot hs-bibutils 4.15 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-4.15 (AndreaRossato)
11:55:01 <pnielsen> nand`: yeah, that's better :)
11:55:07 <zzing_> I asked some time ago about a book on category theory. There was a book that didn't have many prerequisites and was generally easy do get into. Does anyone know what book I am thinking of?
11:55:09 <int-e> f x = [show x, "Fizz", "Buzz", "FizzBuzz"] !! (gcd x 15 `div` 2 `mod` 4)
11:55:23 <nand`> pnielsen: afraid it might get me fired for ‚Äòusing complicated solutions‚Äô
11:55:57 <pnielsen> nand`: then you should probably /part #haskell
11:56:29 <nand`> I think I'd rather get fired for writing beautiful code than get paid for writing atrocities
11:56:36 <pnielsen> yep
11:56:51 <mcstar> int-e: not complete, you need to print for a range for x, but i like it
11:57:16 <edwardk>  wow, mike stay is a bit of a douche
11:57:33 <int-e> mcstar: main = mapM_ (print . f) [1..100] -- I thought this part was boring. I wanted to highlight the use of gcd.
11:57:59 <int-e> mcstar: and I want putStrLn, of course. sigh.
11:58:22 <mroman> http://codepad.org/sEOxdktr
11:58:37 <mroman> Although using a pair in this case is more elegant.
11:58:39 <edwardk> he deleted the first post when i called him out on the "jquery is a monad" thing, called me a firebreathing haskeller, and has deleted my response on his website where I *agreed* with his new choice of examples.
11:59:19 <pnielsen> edwardk: was "firebreathing haskeller" supposed to be an insult?
11:59:41 <nand`> is that like the dual of a fire-eater?
11:59:51 <edwardk> pnielsen: i basically pointed out his jquery monad failed basic functoriality, let along the monad laws and that made him unhappy enough to rant
12:00:01 <Rc43> Which standard function I should use? I nedd `(a -> Maybe b) -> [a] -> Maybe b`
12:00:20 * edwardk shrugs. i have better things to do.
12:00:26 <mcstar> i hanged wolframalpha
12:00:30 <pnielsen> indeed
12:00:40 <pnielsen> mcstar: haha. favorite pastime of a haskeller
12:00:42 <mcstar> it cant solve my query "solve FizzBuzz goddamnit"
12:00:52 <Rc43> It is >>= iterated until first success.
12:01:13 <mcstar> pnielsen: correction, wannabe haskeller, at least on my part :)
12:01:27 <Rc43> Opposite usage of Maybe.
12:01:35 <int-e> @type msum . map
12:01:37 <lambdabot>     Couldn't match expected type `[m a]'
12:01:37 <mcstar> seriously, WA keeps showing me the progressbar, i think i broke it
12:01:37 <lambdabot>            against inferred type `[a1] -> [b]'
12:01:37 <lambdabot>     Probable cause: `map' is applied to too few arguments
12:02:11 <int-e> :t (msum .) . map
12:02:12 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
12:03:40 <mroman> and then you better not look at my github account :D
12:04:06 <gabor> edwardk: started on IAlternative (this is very messy: https://github.com/ggreif/indexed/blob/master/src/Indexed/Parser.hs)
12:04:34 <pnielsen> mroman: that you had enough passion to make something of your own and put it on github "just cus" is a pretty big plus in my book
12:04:51 <pnielsen> mroman: it doesn't hurt if your code isn't completely terrible, but you've already passed most industry programmers at that point
12:05:27 <Rc43> int-e, thanks
12:05:44 <gabor> edwardk: I still cannot see the light, howto encode that the alternatives can have different indices, and that this must be reflected in the result index
12:06:25 <mroman> If you are refering to my fizzbuzz one liner that one was supposed to be as complicated as possible ;)
12:06:44 <pnielsen> mroman: i'm just referring to your "you better not look at my github"
12:07:09 <gabor> edwardk: not sure whether Conor has this, looking now
12:09:18 <bitonic> is there an `unfoldr' without the list?  I could use `(a -> Maybe ((), a)) -> a -> [()]' but maybe it's there already
12:09:51 <shachaf> bitonic: What, to generate a Nat?
12:10:17 <bitonic> shachaf: no, to get the final `a', which makes me realise that the one I proposed is useless.
12:10:52 <shachaf> So you want (a -> Maybe a) -> a -> a?
12:10:56 <bitonic> precisely
12:11:03 <bitonic> hoogle is silent on that matter
12:11:18 <shachaf> Sounds like you're not giving enough context on why you want it. :-)
12:11:30 <shachaf> For example, is (head . dropWhile notValid . iterate f) OK?
12:11:56 <bitonic> well but that still generates the garbage list
12:12:04 <bitonic> which is what I don't like about these solutions
12:12:46 <bitonic> although it would probably fuse
12:13:46 <shachaf> Even if it doesn't I'm not sure that it would matter that much.
12:14:01 <shachaf> I mean, why do you care? Performance?
12:14:06 <shachaf> Haskell lists ~ loops
12:15:00 <mcstar> hm, a runaway function doest work really well in a soft-realtime game
12:15:25 <shachaf> You can always write it yourself: foo f x@(f -> Nothing)) = x; foo f (x -> Just x') = foo f x'
12:15:36 <bitonic> shachaf: not really, in terms of space
12:15:55 <bitonic> shachaf: yeah
12:16:00 <shachaf> In terms of, like, semantics, man.
12:16:19 <bitonic> aaahhhh :)
12:16:35 <shachaf> It's not as if it's going to allocate the whole list no matter what.
12:16:37 <bitonic> anyway, I think the explicit version will be clearer
12:16:41 <shachaf> It'll be GCed as you iterate through it.
12:16:48 <bitonic> shachaf: well, that's still annoying
12:17:10 <bitonic> in any case what I wanted to avoid is the allocation of something which is garbage
12:17:16 <bitonic> from the beginning
12:17:24 <shachaf> Why?
12:17:32 <bitonic> why?
12:17:54 <bitonic> you can't see why?  that's why deforestation is useful
12:18:40 <shachaf> So this *is* about performance?
12:18:49 <shachaf> @ty fix (\loop x -> maybe x loop (?f x))
12:18:50 <lambdabot> forall b. (?f::b -> Maybe b) => b -> b
12:18:51 <bitonic> well yes
12:19:15 <bitonic> I never said it wasn't
12:20:00 <bitonic> I know how to define it, I was wondering if a combinator existed :)
12:20:03 <shachaf> OK. I'd suggest not caring for now and worrying about it later.
12:20:11 <shachaf> @pl fix (\loop x -> maybe x loop (?f x))
12:20:12 <lambdabot> fix ((`ap` (flip (?) . f)) . flip maybe)
12:20:15 <shachaf> thfix
12:20:25 <shachaf> @pl (\x -> maybe x loop (?f x))
12:20:26 <lambdabot> ap (flip maybe loop) (flip (?) . f)
12:20:36 <shachaf> @pl (\x -> maybe x loop (f x))
12:20:37 <lambdabot> ap (flip maybe loop) f
12:20:43 <shachaf> @pl fix (\loop x -> maybe x loop (f x))
12:20:43 <lambdabot> fix ((`ap` f) . flip maybe)
12:20:49 <mcstar> http://hpaste.org/75418 this is what i came up with, looks terrible
12:21:30 <bitonic> shachaf: I'm not worried.  I just wanted to know if something like this was defined somewhere
12:21:41 <bitonic> because I often need it
12:21:57 <mcstar> problem: given 2 sets of objects, keep only those in the first set and the second set, which do not collide with each other(across sets)
12:22:31 <bitonic> actually, I need `Int -> (a -> a) -> a -> a' even more often.  which is `iterate f x !! n'
12:22:47 <bitonic> but I usually use iterate for that.  for some reason that doesn't annoy me
12:24:08 <shachaf> rosie: Hey, you're alive.
12:24:58 <rosie> shachaf: hey (: back in classes
12:25:58 <int-e> mcstar: which is not quite what your code does - if several particles collide with one actors (or what do a and p stand for?), then only one of the particles is removed.
12:26:47 <Botje> antiparticles?)
12:27:09 <int-e> Botje: could be, good one.
12:28:30 <Rc43> Can I catch exceptions inside Maybe monad?
12:28:46 <Rc43> E.g. from failed `read` application?
12:28:54 <quicksilver> no. Don't use read.
12:28:58 <Rc43> read "asdasd" :: Bool
12:28:58 <quicksilver> use "reads"
12:29:13 <noviceprogrammer> How will learning Haskell make me a better Python | C | C++ | Java | C# programmer
12:29:20 <quicksilver> > reads "asdasd" :: [(Bool,String)]
12:29:21 <lambdabot>   []
12:29:30 <shachaf> GHC 7.6 has Text.Read.readMaybe
12:29:56 <quicksilver> maybeRead s = case reads s of [(v,"")] -> Just v; _ -> Nothing
12:29:59 <quicksilver> ^^ can be useful.
12:30:27 <Rc43> quicksilver, when reads return non-empry string?
12:30:29 <shachaf> So useful it's in the standard library these days!
12:31:02 <nexx> noviceprogrammer you will know how to switch to haskell in those cases :D
12:31:03 <quicksilver> Rc43: when there is a valid parse plus left over data
12:31:15 <quicksilver> > reads "True Blue" :: [(Bool,String)]
12:31:16 <lambdabot>   [(True," Blue")]
12:31:35 <Rc43> > reads "True" :: [(Bool,String)]
12:31:36 <lambdabot>   [(True,"")]
12:31:41 <kirindave_> c_wraith: Upon further considerion (and as usual) you were right, I was wrong. Your version is better. I was just confused by the new syntax.
12:31:50 <Rc43> > reads "True True" :: [(Bool,String)]
12:31:51 <lambdabot>   [(True," True")]
12:32:01 <Rc43> Ooh, the space!
12:32:11 <Rc43> > reads "True,True" :: [(Bool,String)]
12:32:12 <lambdabot>   [(True,",True")]
12:32:24 <Rc43> > reads "True`True" :: [(Bool,String)]
12:32:25 <lambdabot>   [(True,"`True")]
12:33:24 * hackagebot fb 0.12.6 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12.6 (FelipeLessa)
12:36:12 <noviceprogrammer> how do I write a function f x = x * x in a pointfree manner?
12:36:21 <Botje> @pl \x -> x * x
12:36:22 <lambdabot> join (*)
12:36:58 <Botje> (that uses the join :: m (m a) -> m a instance of the ((->) r monad)
12:37:00 <geekosaur> note that pointfree for that kind of thing is usually a pointless obfuscation
12:37:05 <noviceprogrammer> right
12:37:26 <int-e> noviceprogrammer: (^2) may even be readable
12:38:03 <Botje> int-e: hah! of course :)
12:38:30 <Ferdirand> @pl \n ->  (fromMaybe <*> flip lookup ((zip <*> (drop `mappend` take) n ) ['a'..'z']))
12:38:31 <lambdabot> (fromMaybe <*>) . flip lookup . flip (zip <*>) ['a'..'z'] . (drop `mappend` take)
12:38:45 <noviceprogrammer> (.) ftw
12:41:05 <shachaf> > (drop ++ take) 3 "abcdefghi"
12:41:07 <lambdabot>   "defghiabc"
12:41:11 <shachaf> Hah.
12:41:38 <mcstar> int-e: p is for projectile, a is for asteroid, and the chance of multiple projectiles hitting an asteroid is negligible
12:41:47 <rwbarton> and not even caleskell
12:41:48 <mcstar> int-e: the code is correct, i just dont like it
12:42:03 <djahandarie> :t (++)
12:42:05 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:42:19 <rwbarton> oh well that part is, but we have <>
12:42:22 <latro`a> @src mappend (->)
12:42:22 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:42:25 <noviceprogrammer> > let rotate n s = (drop ++ take) n s in rotate 3 "abcdefghi"
12:42:25 <latro`a> eh, bah
12:42:27 <lambdabot>   "defghiabc"
12:42:28 <rwbarton> which actually does help readability imo
12:43:06 <djahandarie> :t (<>)
12:43:07 <lambdabot> Doc -> Doc -> Doc
12:43:36 <djahandarie> Looks like lambdabot is a little behind the times.
12:43:51 <int-e> mcstar: I'd probably write something like  let ps' = filter (\p -> not $ any (p `collidesWith`) as) ps; as' = filter (\a -> not $ any (`collidesWith` a) ps) as  for starters
12:44:11 <mcstar> int-e: the problem is a bit like a set difference, but with elements of different kinds, keep the distinct elements from both sets that doesnt share a property(i.e. collision)
12:44:21 <latro`a> what's the source for (->)'s Monoid instance?
12:44:26 <johnw> :t drop
12:44:28 <lambdabot> forall a. Int -> [a] -> [a]
12:44:29 <johnw> :t (drop ++ take)
12:44:30 <lambdabot> forall a. Int -> [a] -> [a]
12:44:30 <latro`a> I tried making one up and it doesn't match the above
12:44:35 <clahey> So, I've read lyah.
12:44:44 <rwbarton> (f <> g) e = f e <> g e
12:44:47 <clahey> What would you guys suggest for a better understanding of Monads and such?
12:44:48 <int-e> mcstar: but you may not like the semantics (no pairwise elimination) or be worried about performance (that's a pair of double loops for a job that can be done with one)
12:44:52 <latro`a> ah, they apply to the same arg
12:44:53 <latro`a> k
12:44:59 <clahey> Another reading?
12:45:11 <johnw> rwbarton: what confuses me is that f and g both expect 2 arguments
12:45:22 <rwbarton> yes, it uses the instance twice
12:45:29 <latro`a> hm, that means mappend isn't actually a monoid homomorphism?
12:45:29 <johnw> (f <> g) x y = f x y <> g x y?
12:45:43 <clahey> johnw: Of course.
12:45:44 <johnw> oh, I get it
12:45:45 <rwbarton> (f <> g) x y = (f x <> g x) y = f x y <> g x y
12:45:45 <latro`a> i.e. f <> id != f, I...think
12:45:51 <mcstar> int-e: small number of projectiles <= 3, small number of asteroids, 5?, but i think ill keep my, i like succesive elimination
12:45:56 <clahey> Like rwbarton said.
12:46:00 <johnw> ((f x <> g x) y
12:46:01 <mcstar> mine8
12:46:36 <johnw> :t (drop ++ id) a
12:46:37 <lambdabot>     Couldn't match expected type `[a] -> [a]'
12:46:37 <lambdabot>            against inferred type `Int'
12:46:37 <lambdabot>     In the second argument of `(++)', namely `id'
12:46:39 <johnw> > (drop ++ id) a
12:46:40 <lambdabot>   Couldn't match expected type `[a] -> [a]'
12:46:40 <lambdabot>         against inferred type `GH...
12:46:53 <clahey> :t id
12:46:54 <lambdabot> forall a. a -> a
12:47:01 <djahandarie> (drop <> take) 3 "abc" = (drop e <> take 3) "abc" = drop 3 "abc" <> take 3 "abc" = "" <> "abc" = "" ++ "abc" = "abc"
12:47:06 <int-e> mcstar: besides if that's going to be a real asteroids game, you want to be able to split asteroids into multiple parts on collision. that'll be easier to add to your version
12:47:13 <djahandarie> Bah, typo
12:47:14 <clahey> johnw: The two things have to take the same number of arguments.
12:47:15 <mcstar> int-e: yes
12:47:20 <djahandarie> (drop <> take) 3 "abc" = (drop 3 <> take 3) "abc" = drop 3 "abc" <> take 3 "abc" = "" <> "abc" = "" ++ "abc" = "abc"
12:47:29 <johnw> :t (length ++ id) "foo"
12:47:31 <lambdabot>     Couldn't match expected type `Int' against inferred type `[a]'
12:47:31 <lambdabot>     In the second argument of `(++)', namely `id'
12:47:31 <lambdabot>     In the expression: (length ++ id) "foo"
12:47:39 <johnw> oh, and match rte types
12:47:42 <mcstar> int-e: btw, how easy was it to understand what that snippet does?
12:47:42 <johnw> it's too early for me
12:47:46 <johnw> i'll just stop now
12:47:46 <clahey> And the types have to match, yep.
12:47:48 <latro`a> they need to return monoid types
12:47:52 <latro`a> and the same ones
12:48:04 <latro`a> but that doesn't explain why id won't cooperate
12:48:14 <clahey> latro`a: And take the same types.
12:48:16 <mcstar> int-e: i have the feeling that sometimes recursion obfuscates whats going on
12:48:21 <clahey> latro`a: id takes one arg.  drop takes two.
12:48:30 <latro`a> > (drop 2 <> id) "abc"
12:48:31 <clahey> > (drop 3 <> id) "abcdefghi"
12:48:32 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
12:48:32 <lambdabot>         agains...
12:48:32 <lambdabot>   can't find file: L.hs
12:48:33 <int-e> mcstar: hmm, not too hard - the main effort was in checking that remps/ps and remas/as are really treated as sets of items that are being traversed.
12:48:36 <clahey> :t (drop 3 <> id) "abcdefghi"
12:48:37 <lambdabot>     Couldn't match expected type `Doc'
12:48:38 <lambdabot>            against inferred type `[a] -> [a]'
12:48:38 <lambdabot>     In the first argument of `(<>)', namely `drop 3'
12:48:40 <latro`a> why doesn't that work
12:48:40 <mcstar> (i understand whats going on, since i wrote it, but i werent in this position, im not so sure)
12:48:41 <latro`a> oh
12:48:41 <alpounet> use ++, not <>
12:48:43 <latro`a> silly lambdabot
12:48:44 <clahey> :t (drop 3 ++ id) "abcdefghi"
12:48:45 <lambdabot> [Char]
12:48:48 <clahey> > (drop 3 ++ id) "abcdefghi"
12:48:49 <latro`a> > (drop 2 ++ id) "abc"
12:48:50 <lambdabot>   "defghiabcdefghi"
12:48:51 <lambdabot>   "cabc"
12:48:57 <latro`a> k cool
12:49:06 <int-e> mcstar: it does, but haskell programmers are used to that. reading tail recursion as loops become second nature.
12:49:16 <clahey> I'm amused that we're so in sync.
12:49:17 <int-e> *becomes
12:49:45 <clahey> int-e: It's taking me a bunch of work to realize that tail recursion can often be slower in haskell than normal recursion.
12:49:49 <johnw> so, f ++ id != f
12:49:58 <int-e> shachaf: I really like the  drop <> take  :)
12:49:59 <clahey> johnw: No.
12:50:09 <clahey> johnw: f . id is, I think.
12:50:14 <clahey> Yeah, I like that a lot too.
12:50:25 <clahey> :t f + id
12:50:26 <lambdabot>     Ambiguous occurrence `f'
12:50:26 <lambdabot>     It could refer to either `L.f', defined at <local>:5:0
12:50:26 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:74:0-32
12:50:30 <clahey> :t f . id
12:50:31 <lambdabot>     Ambiguous occurrence `f'
12:50:31 <lambdabot>     It could refer to either `L.f', defined at <local>:5:0
12:50:31 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:74:0-32
12:50:34 <rwbarton> f ++ mempty
12:50:49 <rwbarton> where mempty (i didn't give it) is mempty = const mempty
12:51:10 <clahey> > mempty :: Char -> Char
12:51:11 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
12:51:11 <lambdabot>    arising from a use o...
12:51:45 <clahey> Oh, const mempty.  Got it.
12:51:46 <int-e> clahey: right, there's a refined notion that I still call tail recursion - for example, I think of map,  map f (x:xs) = f x : map f xs  as tail recursive in spirit, even though technically it isn't.
12:52:11 <clahey> int-e: It's sort of thunk recursive.
12:52:38 <mcstar> thunk you
12:53:28 <nooodl> :t (++id)
12:53:29 <lambdabot> forall a. (Monoid a) => (a -> a) -> a -> a
12:53:40 <merijn> :t id
12:53:41 <lambdabot> forall a. a -> a
12:53:52 <merijn> oh, wait...
12:54:00 <merijn> ++ in lambdabot is mappend, right?
12:54:02 <Philonous> Caleskel
12:54:03 <Philonous> Yes
12:54:05 <nooodl> yep
12:54:08 <merijn> :p
12:54:20 <clahey> int-e: What it really is is tail recursive in the tail of the return value.
12:54:31 <clahey> int-e: Which is exactly what you want in haskell.
12:54:33 <nooodl> :t (id++)
12:54:34 <lambdabot> forall a. (Monoid a) => (a -> a) -> a -> a
12:54:45 <clahey> :t (.id)
12:54:46 <lambdabot> forall a b. (a -> b) -> a -> b
12:55:06 <Philonous> :t (.)
12:55:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:55:10 <Pip> Hi, before I really start learning Haskell, should I learn C++ in the first place?
12:55:19 <johnw> heck no
12:55:24 <merijn> Pip: Hell no :p
12:55:31 <Philonous> Pip:  It's not necessary or even helpful to learn haskell
12:55:42 <zzo38> What is the Haskell namespace for a hardware description language?
12:55:43 <Philonous> Pip:  In order to*
12:55:45 <merijn> Philonous: I'm assuming you meant C++?
12:56:06 <int-e> zzo38: why not Language. ?
12:56:15 <merijn> zzo38: Check out where the guys from Twente (or was it Eindhoven?) put theirs...
12:56:48 <noviceprogrammer> http://ideone.com/A8sCJ how do i improve this code?
12:57:10 <mcstar> "It's not necessary or even helpful to learn haskell"
12:57:16 <mcstar> Philonous: how can you say that?
12:57:22 <johnw> s/to learn/for learning
12:57:32 <nooodl> > ((++id) reverse [1,2,3], (id++) reverse [4,5,6])
12:57:34 <lambdabot>   ([3,2,1,1,2,3],[4,5,6,6,5,4])
12:57:38 <nooodl> these are actually cool
12:57:43 <zzo38> atriq: OK, does it need any sub name spaces for any purposes?
12:57:45 <rwbarton> mcstar: context; It = learning C++
12:57:55 <zzo38> merijn: What is Twente, Eindhoven?
12:57:55 <Philonous> mcstar:  It's quite easy, really. You just have to mean something else and then be really bad at writing that.
12:57:55 <mcstar> rwbarton: j/k
12:57:57 <int-e> noviceprogrammer: I'd use layout to drop the {} and semicolons.
12:58:09 <merijn> noviceprogrammer: Well, I'd remove the braces and semicolons. But other than that it looks fine
12:58:20 <clahey> Knowing C++ is not useful when learning haskell.
12:58:25 <zzo38> If it is Famicom Hardware Description Language, is Language.FCHDL OK?
12:58:30 <merijn> zzo38: Universities in the Netherlands, one of them was working/uses a haskell EDSL that gets translated into VHDL
12:58:40 <rwbarton> mcstar: sorry, your response fell outside the joke recognition period
12:58:45 <nooodl> noviceprogrammer's code looks a bit like C
12:59:07 <nooodl> zzo38: i'd go for FamicomHDL
12:59:09 <zzo38> noviceprogrammer: I think it is OK, although if using {}; for one part of the code, the module declaration should, too.
12:59:10 <mcstar> rwbarton: right, ill pay attention
12:59:15 <zzo38> nooodl: OK
13:00:01 <zzo38> I do not suggest mixing layout and non-layout in the same file.
13:01:01 <noviceprogrammer> so haskell's curly braces and semicolons are optional? :D
13:01:23 <zzo38> noticeprogrammer: If you use braces then semicolons are required, if you do not use braces then it knows by indentation and line breaks instead.
13:01:30 <noviceprogrammer> right
13:01:45 <noviceprogrammer> wish other languages could be like that *leers at C++*
13:01:48 <mcstar> record update needs {}
13:01:51 <geekosaur> exception:  record update syntax requires... that
13:02:00 <nooodl> noviceprogrammer: it's like python with less colons!
13:02:20 <noviceprogrammer> python doesn't have pattern matching, does it? ^^
13:02:28 <zzo38> noviceprogrammer: Within one file, either use {}; or do not use {}; but do not mix both ways like you did in the code you posted (if you want to use {}; then also put { after the where for the module, and ; after each line; if you don't want, then omit the {}; in the do block; either way is OK)
13:02:36 <merijn> noviceprogrammer: Yes, if you look at the Prelude and other libraries you'll see semicolonless/braceless is the preferred style
13:03:14 <noviceprogrammer> right
13:03:17 <nooodl> what zzo38 said, but without the "using {}; whatsoever" part
13:03:18 <zzo38> I prefer to use braces and semicolons, and a few other people also do, but most Haskell programs use layout instead. However, whichever you do I think it is a bad idea to mix both styles within a single file.
13:03:58 <merijn> noviceprogrammer: The exact details are discussed here (https://en.wikibooks.org/wiki/Haskell/Indentation), but they're mostly obvious (with a few minor caveats that are confusing if you don't read the details ;)
13:04:04 <mcstar> {;} comes handy if your editor cant figure out indentation
13:04:19 <noviceprogrammer> :( hoogle is failing to install on my machine
13:04:30 <Philonous> A better editor comes handy if our editor can't figure out indentation.
13:04:31 <rwbarton> I only know how to use {;} from working with ghci/lambdabot
13:04:43 <zzo38> mcstar: Or if you just prefer {;} style, as some people do.
13:04:45 <Philonous> your*
13:04:57 <mcstar> zzo38: theres a world between us...
13:05:02 <mcstar> :)
13:05:04 <zzo38> Philonous: Yes that too.....
13:05:16 <clahey> I wish my emacs had a haskell mode.
13:05:18 <merijn> noviceprogrammer: I mostly just use the Hoogle webpage
13:05:34 <mcstar> clahey: eh? what do you mean?
13:05:39 <zzo38> clahey: Find one or write one.
13:06:03 <clahey> mcstar: When I type M-x haskell tab tab, nothing shows up.
13:06:03 <Philonous> https://github.com/haskell/haskell-mode
13:06:12 <mcstar> clahey: well, set it up
13:06:16 <mcstar> its easy
13:06:19 <clahey> Philonous: Too much work!
13:06:37 <mcstar> emacs-mode doesnt come with emacs, so your emacs cant have it
13:06:45 <mcstar> noone's can
13:06:51 <Philonous> clahey:  It's on marmelade
13:06:52 <mcstar> f, haskell-mode
13:06:58 <clahey> Oh...
13:07:01 <rwbarton> it can't possibly be more work than indenting haskell by hand
13:07:07 <clahey> It's in apt.
13:07:19 <clahey> Now I look like a fool.
13:07:29 <mcstar> if you use emacs, sooner or later you will have to hack on its config file
13:07:34 <mcstar> but that is the same for vim
13:07:43 <clahey> Oh, I've hacked on my config file some.
13:07:51 <clahey> I've just become lazy in my old age.
13:08:01 <mcstar> then, i cant understand why are you hesitant to set haskell-mode up
13:08:03 <mcstar> nvm
13:08:05 <shoerain> be young, don't be old
13:08:35 <zzo38> In this case of FamicomHDL, it is not intended to compile to VHDL it is supposed to compile to DotFami .cart format, although I suppose it could be made to compile to VHDL and so on as well if you wanted it to.
13:08:40 <clahey> If I can't apt-get install or cabal install or whatever some package, then it doesn't exist, IMO.  :)
13:09:13 <clahey> Are there any good tutorials on writing interactive programs like games or windowing programs in haskell?
13:09:40 <clahey> Forget it, I just did a web search.
13:09:44 <clahey> I should know better.
13:10:27 <mcstar> im wondering if i should write up my experience making this asteroids game
13:10:37 <mcstar> but i think it is too trivial for anyone to benefit from it
13:10:54 <int-e> @quote Ooooh!
13:10:54 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
13:10:54 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
13:11:01 <clahey> mcstar: I doubt that.
13:11:39 <merijn> mcstar: I think it might actually be rather popular
13:12:00 <mcstar> hm, then ill think about it
13:14:31 <noviceprogrammer> > let myLast (x:xs) = if xs == [] then x else myLast xs
13:14:32 <lambdabot>   not an expression: `let myLast (x:xs) = if xs == [] then x else myLast xs'
13:14:42 <noviceprogrammer> how do I improve that line of code?
13:14:59 <rwbarton> use more pattern matching
13:15:03 <Philonous> noviceprogrammer:  Use pattern matching instead of if and (==)
13:15:09 <rwbarton> make it into two lines of code :)
13:15:09 <Rc43> How to dispatch by type class? I want `show' :: a -> String`, which equals `show` for instances of `Show`.
13:15:22 <noviceprogrammer> is that the best solution to the first of the 99 problems of Haskell?
13:15:26 <nomeata> Hi. Is there convenient, do-like syntax for Control.Applicative? An alternative to "pure (\x y -> f x y y) <*> a1 <*> a2"?
13:15:41 <S11001001> nomeata: liftA2
13:16:21 <nomeata> S11001001: no, that is not more convenient than <*>. Something that would allow me to give names to the results and then use them at will in the resulting computation
13:16:54 <nomeata> somethin akin to 'do {x <- a1; y <- a2; return $ f x y y}'
13:17:01 <zzo38> But (unrelated) I also wanted to know, does someone make up the ephemeris programs for Haskell? Including all of the geometry involved, planets, dwarf planet, asteroid, sun, moon, rectangular coordinates, convert to spherical, tropical, sidereal, J2000, ecliptic, equatorial, fixed stars, speed of light, aberration, nutation, etc. It could be useful do with astronomy and astrology related stuff
13:17:02 <copumpkin> nomeata: "idiom brackets"
13:17:08 <int-e> Rc43: you can't. the closest Haskell has is Data.Typeable, which is yet another type class. And you'd still have to maintain your own registry for Show instances.
13:17:10 <copumpkin> nomeata: in the strathclyde haskell enhancement
13:17:24 <copumpkin> nomeata: https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/
13:17:44 <copumpkin> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
13:17:55 <Philonous> nomeata:  SHE is a preprocessor. But hopefully it will come to ghc soon.
13:18:20 <rwbarton> what would it look like with idiom brackets?
13:18:23 <nomeata> hmm, ok. that‚Äôs probaby not worth it yet, but having someting nice in haskell would be good
13:18:27 <rwbarton> wouldn't it be pretty much the same?
13:18:36 <copumpkin> (| f x y |)
13:18:41 <rwbarton> but he doesn't have f
13:18:41 <copumpkin> instead of f <$> x <*> y
13:18:44 <rwbarton> so meh
13:18:45 <int-e> Rc43: There's a deeper reason behind this. Values at runtime do not carry any type information. For example, Nothing will be the same value, regardless of whether it's Nothing :: Maybe Int (which has a Show instance) or Nothing :: Maybe (Int -> Int) (which doesn't). So you need to pass some extra information, like a class dictionary.
13:19:13 <merijn> noviceprogrammer: You can use "(x:[])" (or identically "[x]") to pattern match instead of doing "(x:xs) = if xs == []"
13:19:13 <rwbarton> I think nomeata wants something like do syntax where the RHSs of <- can't use variables bound in the do block and that has to end in return ...
13:19:27 <int-e> Rc43: (at least that's the case in ghc. my answer was implementation specific.)
13:19:33 <clahey> mcstar: I should specify, I doubt that it would be trivial, so I would very much like to see it.
13:19:56 <mcstar> clahey: yeah, i understood
13:20:14 <zzo38> I have tried to find already for a while, the Haskell ephemeris but I found no such things can you help please?
13:20:19 <Philonous> nomeata:  There is do-syntax for arrows, but not for applicative
13:20:42 <rwbarton> seems like it would be pretty easy to implement an 'ado' syntax
13:21:12 <copumpkin> much ado?
13:21:19 <rwbarton> exactly :)
13:21:27 <clahey> mcstar: What are you using for display and input?
13:21:35 <Philonous> copumpkin:  If you put it like that, it's something McBride should be interested in ;)
13:21:43 <mcstar> clahey: glfw
13:22:02 <mcstar> and a touch of drawingcombinators on top of that
13:22:11 <clahey> mcstar: I just learned that there are Haskell -> Javascript compilers.
13:22:24 <clahey> mcstar: I'm super psyched about the idea that I can run the same code on server and client and not use node.js.
13:22:25 <Rc43> int-e, any workarounds? Seems to common issue (default implementation of show).
13:22:29 <mcstar> idk anything about webdev and/or js
13:22:30 <Rc43> *to be
13:23:12 <Philonous> clahey:  Well, there's always been java
13:23:17 <nomeata> rwbarton: yes, that is exactly what I a looking for :-)
13:23:23 <mcstar> clahey: also, it wont compile any haskell code to js
13:23:43 <int-e> Rc43: Not really. What are you really trying to do?
13:24:18 <Rc43> int-e, output of `Expr a` values, where a is arbitrary.
13:24:53 <clahey> mcstar: Not glfw.  fay, ghcjs, whatever.
13:24:57 <Rc43> int-e, in case of `Const a` it is just `a`.
13:25:08 <rwbarton> alternatively if idiom brackets included some special let syntax
13:25:14 <clahey> Philonous: Yeah, but java has never made it to being a first class citizen in the browser.
13:25:20 <clahey> Philonous: It's second class, but not first.
13:25:29 <noviceprogrammer> what makes haskell's type system so great compared to the type systems of languages like C, C++, Java, and C#?
13:25:51 <clahey> noviceprogrammer: Inferred types are nice.
13:26:10 <noviceprogrammer> ah
13:26:48 <tdammers> noviceprogrammer: type inference, fine granularity, separating typeclasses, types, and instances
13:27:50 <copumpkin> Philonous: yes!
13:27:59 <dmwit> How has everybody missed parametric polymorphism?
13:28:02 <Nisstyre> not just type inference, type inference that has many awesome extensions to the original HM algorithm
13:28:04 <Nisstyre> correct?
13:28:09 <dmwit> That shit is dank.
13:28:12 <blackh> noviceprogrammer: The type system pervades the programming experience much more completely than other languages, so what you can do with the type system is much more powerful.
13:28:14 <merijn> tdammers: Type functions! \o/
13:28:42 <int-e> Rc43: You may be able to write a function  Show a => Expr a -> String. Or attach a String to every Const from the start. Or, as a last resort, use Data.Typeable.
13:28:46 <Philonous> dmwit:  C++ has parametric polymorphism
13:29:20 <Nisstyre> well, arguably dynamic languages have parametric polymorphism >.>
13:29:36 <dmwit> Philonous: Does it?
13:30:05 <nand`> basically, Haskell has a fairly powerful type system, which allows you to express increasingly complicated scenarios (statically)
13:30:09 <Philonous> dmwit:  That's what templates are for, no?
13:30:25 <dmwit> Philonous: No. Templates are not parametrically polymorphic: you can distinguish between types using templates.
13:30:30 <acowley> dmwit: Yeah, it's great. You can have a type T, and then assume it's always an int, and, if it is, everything will be cool!
13:31:00 <dmwit> Philonous: e.g. you can write a template that only works if the type you instantiate it at happens to have a frobnosticate() method.
13:32:09 <Rc43> int-e, I used `instance (Show a) => Show (Expr a) where...` as yet
13:32:24 <copumpkin> all my types implement the frobnosticate method
13:32:25 <Philonous> dmwit:  Wouldn't that be rather like a type constraint in haskell?
13:32:35 <Philonous> class*
13:32:42 <dmwit> Philonous: Yes. Constrained types are not parametrically polymorphic, they're ad-hoc polymorphic. =)
13:33:25 <Philonous> The point is, you can have a template that makes no such demand. That would be parametric polymorphic
13:34:24 <clahey> Philonous: If your template doesn't interact with the object inside than it's not doing anything, no?
13:34:29 <clahey> Well, I guess you can assume ==.
13:34:44 <blackh> noviceprogrammer: What nand` said. Also, in Haskell you can easily type-check things you would never even dream of type checking in other languages. So the compiler takes a whole lot of work of checking away from you that you would have to do yourself in other languages. In other words, Haskell lets you concentrate on what you're good at, and the compiler does what it's good at.
13:34:46 <clahey> I guess a list doesn't even need that.
13:34:57 <acowley> clahey: think about Functors in general
13:34:59 <mcstar> lol, i messed something up, when i shoot the asteroid, if fragments into soo many peaces that it freezes the game XD
13:35:02 <mcstar> pieces
13:35:22 <clahey> blackh: I really like that you can know what you want to do, and then search by the type that you know the function is going to be.
13:35:25 <dmwit> Philonous: I suppose. At the very least, it's a bit annoying that the type system doesn't distinguish constrained and unconstrained templates in any way.
13:35:46 <clahey> Is this right?
13:35:47 <clahey> @hoogle a -> b -> c -> (b -> a -> c)
13:35:48 <lambdabot> Network.Socket sendAncillary :: Socket -> Int -> Int -> Int -> Ptr a -> Int -> IO ()
13:35:48 <lambdabot> GHC.IO.Buffer Buffer :: RawBuffer e -> BufferState -> Int -> Int -> Int -> Buffer e
13:35:48 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec vertexAttrib4 :: VertexAttribComponent a => AttribLocation -> a -> a -> a -> a -> IO ()
13:36:03 <clahey> @hoogle forall a, b, c. a -> b -> c -> (b -> a -> c)
13:36:04 <lambdabot> Parse error:
13:36:04 <lambdabot>   forall a, b, c. a -> b -> c -> (b -> a -> c)
13:36:04 <lambdabot>           ^
13:36:21 <alpounet> dmwit, they are waaaay too often constrained
13:36:24 <clahey> @hoogle (a -> b -> c) -> (b -> a -> c)
13:36:24 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
13:36:24 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
13:36:24 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
13:36:29 <clahey> That's what I was looking for.
13:36:59 <clahey> So cool.
13:37:02 <dmwit> ?djinn a -> b -> c -> (b -> a -> c)
13:37:02 <lambdabot> f _ _ a _ _ = a
13:37:05 <dmwit> surprise!
13:37:24 <dmwit> See if you can work out why that's a good implementation of that type, and perhaps a light will go on. =)
13:39:09 <nooodl> that's a great function
13:39:11 <clahey> dmwit: Yeah, I got the parentheses wrong.  I understand why that is a good implementation.
13:39:31 <clahey> I don't understand why it thinks the functions it listed are implementations of that function.
13:39:44 <nooodl> "thirdOutOfFiveConst _ _ a _ _ = a"
13:39:57 <acowley> dmwit: It's like a loquacious identity function
13:40:25 <clahey> jeriRyan _ _ _ _ _ _ a _ _ = a
13:40:40 <dmwit> haha
13:40:48 <acowley> clahey: I define that function in practically every module I write
13:40:59 <dmwit> clahey: Actually, yeah, I don't really understand why it thinks those are good responses, either.
13:41:10 <acowley> though I call it viiofix
13:41:11 <dmwit> clahey: Maybe they're the only functions it could find that had five or more arguments. =)
13:41:48 <dmwit> I didn't get "viiofix".
13:41:56 <dmwit> oh
13:41:56 <rwbarton> @hoogle a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k
13:41:58 <dmwit> now I get it
13:41:59 <acowley> :/
13:42:11 <lambdabot> thread killed
13:42:29 <nooodl> poor bot
13:42:32 <dmwit> ?remember clahey jeriRyan _ _ _ _ _ _ a _ _ = a
13:42:32 <acowley> was lambdabot's response to my apparently inscrutable joke?
13:42:33 <lambdabot> It is forever etched in my memory.
13:42:56 <clahey> acowley: It was a response to rwbarton.
13:43:10 <acowley> clahey: I know‚Ä¶ that was another (inscrutable) joke
13:43:10 <clahey> Where is the code for lambdabot?
13:43:21 <dmwit> ?where lambdabot
13:43:22 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
13:43:28 <clahey> acowley: The first wasn't inscrutable.
13:43:34 <clahey> Just minorly scrutable
13:43:49 <acowley> I can inscrute some of the people all of the time, but not all of the people all of the time?
13:43:57 <acowley> something like that
13:44:15 <dmwit> Only my wife is allowed to inscrute me.
13:44:19 <acowley> I will now make it a point to encourage the use of inscrute as a word, though it does sound like a rather unpleasant thing
13:44:20 <acowley> haha
13:44:26 <acowley> s/unpleasant/pleasant
13:44:38 <clahey> ?quote
13:44:39 <lambdabot> atoll says: dont be such an extremist, how you could you have bugs when incrementing variable
13:45:08 <clahey> My girlfriend refuses to inscrute me.
13:45:38 <acowley> Does anyone know if a type savvy person has written a response to the Learnable Programming essay yet?
13:45:56 <alpounet> edwardk has
13:46:01 <alpounet> oh no
13:46:02 <noviceprogrammer> so data is analogous to C's structs and unions, while class is analogous to java interfaces or C++ abstract bases?
13:46:09 <alpounet> confused two articles
13:46:10 <clahey> acowley: URL?
13:46:11 <acowley> I saw his thing about parametric polymorphism
13:46:20 <alpounet> yeah sorry
13:46:31 <acowley> clahey: http://worrydream.com/LearnableProgramming/
13:46:37 <clahey> noviceprogrammer: I've been trying to kill my idea of "analogous to C or C++ feature"
13:47:07 <acowley> I wrote two tweets on it, and just hope that someone will step up to write something from a different perspective
13:47:12 <dmwit> noviceprogrammer: That's the least horrible of the analogs, if you must draw a relationship to features you know.
13:47:26 <saml> @books
13:47:26 <lambdabot> Unknown command, try @list
13:47:32 <saml> what are good books?
13:47:38 <saml> to write haskell web apps
13:47:46 <noviceprogrammer> read world haskell?
13:47:55 <atriq> Yesod?
13:47:56 <noviceprogrammer> real* world haskell
13:47:58 <saml> to someone who wants to write haskell web apps without background of functional programming
13:48:10 <saml> is 2nd edition out?
13:48:20 <dmwit> Read a tutorial for the language first, then a tutorial for whichever web framework you want to use.
13:48:21 <blackh> noviceprogrammer: Haskell's data is basically the same as a C struct, but class is similar to java interfaces, but different in important ways.
13:48:22 <atriq> Real World Haskell followed by Yesod, Happstack, or Snap
13:49:16 <atriq> Learn You A Haskell could (and possibly should, at least at the beginning) replace Real World Haskell
13:50:19 <jfischoff> hey blackh!
13:50:45 <blackh> jfischoff: Morning!
13:51:06 <jfischoff> anymore iOS nuggets about to drop?
13:51:07 <Philonous> noviceprogrammer:  I recommend against this kind analogy, it will probably confuse you more than help.
13:52:06 <blackh> jfischoff: Not right at the moment. Basically I've got a million things to do, but it's leading up to more iOS work, at which point I'll probably update GHC-iPhone and give it a bit of a workout.
13:52:25 <noviceprogrammer> right
13:52:37 <jfischoff> cool, I know how that goes :)
13:52:55 <jfischoff> blackh: any haskell work in the future?
13:53:06 <blackh> noviceprogrammer: Simon Peyton Jones (the GHC compiler guy) said you need to temporarily unplug the O-O module from your brain while you learn Haskell.
13:53:23 <noviceprogrammer> I don't understand OOP that well
13:53:33 <Philonous> noviceprogrammer:  Lucky you
13:53:41 <blackh> noviceprogrammer: When it comes to learning Haskell, that's a good thing.
13:53:44 <noviceprogrammer> ^_^
13:54:05 <higherorderfun> hi all - I'm looking for the Venn diagram that I've seen SPJ draw which shows: 1) well-typed programs, 2) useful programs. He uses it to explain what the aims of Haskell's type system is - i.e. to make the two sets overlap more.
13:54:36 <blackh> jfischoff: I'm doing somewhere between four and six projects at the moment, mostly Haskell.
13:54:49 <jfischoff> blackh: nice!
13:55:26 <byorgey> higherorderfun: in some sense that is the aim of all type systems.  To carve out a largeish subset of useful programs that are guaranteed not to be bad (for various definitions of bad)
13:55:39 <byorgey> higherorderfun: unfortunately I don't know where to find that Venn diagram.
13:55:53 <dmwit> higherorderfun: http://www.youtube.com/watch?v=iSmkqocn0oQ
13:56:07 <blackh> jfischoff: This guy I know is a web designer and he designed an iPhone game and had trouble with developers. So I said I'd do it if he agreed to let me use it as a test case for using Sodium + GHC-iPhone.
13:56:28 <jfischoff> blackh: :)
13:56:31 <blackh> jfischoff: (Sodium is my FRP system.)
13:56:32 <higherorderfun> dmwit; thanks!
13:56:59 <clahey> What makes haskell better than Ocaml?
13:57:02 <blackh> jfischoff: I even did some work on GHC-JS, but I am spreading myself a bit thin at the moment.
13:57:11 <higherorderfun> dmwit - actually that's not exactly what I'm looking for...
13:57:22 <jfischoff> blackh: how'd that go (GHC-JS)?
13:57:28 <higherorderfun> that's the safe/unsafe vs. useful/useless graph
13:57:40 <clahey> In your opinions, that is.
13:57:57 <higherorderfun> there's another one which is just a Venn diagram (two circles with an interesection)
13:57:58 <clahey> acowley: So what do you think is wrong with that essay?
13:58:23 <tazjin> I'm working on a library to sign Apple's iOS 6 PassBook passes from a Haskell application, but I'm not sure where in the module namespace it should be put. Any ideas? Crypto.PKPass? Web.PKPass?
13:58:29 <Philonous> clahey:  Higher kinded polymorphism
13:58:40 <blackh> clahey: Apparently this: The vibrance of community, the amount of work going into the compiler, and fact that o'caml doesn't have Show instances is apparently a bit of a headache. That what I understand to be the case, but that's not based on personal experience.
13:58:59 <clahey> blackh: Those are all good arguments.
13:59:26 <clahey> I'm still having some trouble imagining how you would implement a game or user interface.
13:59:36 <blackh> clahey: Haskell is innovating overall much faster than O'Caml is at the moment.
13:59:40 <clahey> Do you just have a state which changes?
13:59:55 <clahey> Rather, which gets replaced?
13:59:58 <acowley> clahey: I think it undervalues abstraction over collective operations. There's great empowerment in more declarative programming that seems to be missing there.
14:00:00 <jfischoff> tazjin: how about Just Passbook?
14:00:10 <jfischoff> s /J/j
14:00:33 <blackh> clahey: Also purity and laziness. Purity is IMO a huge, huge benefit, but laziness is part benefit part cost.
14:00:47 <clahey> acowley: I do like a lot of the ideas of declarative programming.
14:00:48 <tazjin> jfischoff: Hmm, it feels odd putting something like that at the "top level"
14:00:51 <pnielsen> clahey: look at STM/TVars. In a game you have some state (what room the player is in, what their hp is) that you might want to store in mutable vars. STM is perfect for that (IMO)
14:01:08 <acowley> I think the author does an awesome job with his visualizations
14:01:18 <jfischoff> tazjin: yeah but the other levels are arbitrary
14:01:26 <acowley> but Haskell is a great example of really dense textual representation that turns out to be hugely flexible
14:02:21 <pnielsen> clahey: you can think of TVars as being points to sometihng, e.g. playerHp :: TVar Int is a pointer to an integer
14:02:25 <pnielsen> pointers*
14:02:26 <clahey> acowley: I think that it would be awesome if you could do something similar for haskell.
14:02:42 <acowley> Yeah, his visualizations are awesome.
14:02:54 <blackh> clahey: A spaceship in a game would generally be a function from input events and information about other elements of the game to what to draw and information that other parts of the game need to know.
14:03:25 <blackh> clahey: Also, it would return a new "copy" of itself with its internal state, that the caller would call next time.
14:03:28 * hackagebot haslo 0.1.3 - Loan calculator engine.  http://hackage.haskell.org/package/haslo-0.1.3 (BartoszWojcik)
14:03:40 <clahey> blackh: And that's fast, despite creating a copy?
14:03:49 <blackh> clahey: Also, look at FRP for implementing games.
14:03:58 <clahey> blackh: The compiler figures out that the original is going to be thrown away and just reuses the space?
14:04:16 <blackh> clahey: There's a cost in copying things all the time, but Haskell is highly optimized for doing that. If you wrote in the same style in C++ it would be slower. (I know this from experience.)
14:04:41 <clahey> blackh: So if you have state in the hundreds of K, it's still fast?
14:04:54 <johnw> yes, in Haskell "copying" is more conceptual than actual much of the time
14:05:07 <dmwit> Only the changed bits get copied.
14:05:21 <dmwit> The bits that stayed the same are immutable, so they can just be pointer-copied.
14:05:25 <pnielsen> clahey: yes, copying "reuses" whatever it can, which is easy since the values can't change
14:05:27 <johnw> in C++ there are times when it's conceptual too (when pass-by-value doesn't actually copy the value), but it's a much rarer optimization
14:06:27 <clahey> So state { changedField = whatever } doesn't copy all the other fields.  It just points to them.
14:06:34 <dmwit> yes
14:06:45 <clahey> Can you do:
14:06:51 <dmwit> rather: they were all pointers anyway, and it copies the pointers
14:06:52 <clahey> state { changedField { subField = whatever } } ?
14:06:54 <rwbarton> it copies the pointers to ... yeah
14:06:58 <dmwit> clahey: yes
14:07:12 <rwbarton> not like that though
14:07:16 <alpounet> acowley, oh come, just imagine the benefits of tweaking your right kan extension with a slider =)
14:07:17 <rwbarton> or can you??
14:07:20 <dmwit> state { changedField = changedField state { subField = whatever } } -- it's a bit less pretty than the syntax you suggested, though
14:07:25 <dmwit> Lenses can improve that a lot.
14:07:46 <clahey> dmwit: But it's still pretty efficient cause you're only copying the bits that changed.
14:08:04 <clahey> But the compiler doesn't notice that it's about to stop caring about the old value and just change it in place?
14:08:07 <acowley> alpounet: a slider to change the definition of jeriRyan _ _ _ _ _ _ a _ _ = a would be great, if not canon
14:08:15 <edwardk> state % changedField.subField .~ whatever
14:08:18 <dmwit> I don't think GHC currently does any linearity analysis to enable in-place mutation, no.
14:08:35 <clahey> That would be cool.
14:08:35 <alpounet> hah
14:08:37 <blackh> clahey: In some cases, yet, but generally not, but the memory allocator is *very* fast. The optimization is improving all the time.
14:08:48 <rwbarton> it is efficient as long as you don't have enormous records with lots of fields
14:08:48 <dmwit> There are papers about how to do this, but there are some important restrictions.
14:09:01 <dmwit> For example, you can't have heap cycles in the paper I'm thinking of.
14:09:15 <clahey> rwbarton: Which if you have a ton of fields you can use sub objects like I described.
14:09:19 <rwbarton> right
14:09:23 <clahey> I need to learn how arrays work.
14:09:29 <rwbarton> then you are building a sort of ad-hoc tree structure
14:09:29 <acowley> I've not made good use of (%) in my lens code, I usually try to write it point free. But I need to make a note to remind me about (%) when it fits.
14:09:47 <dmwit> However, there are several objects (arrays in particular) that have a clean API for writing a mutable algorithm that gives an immutable result without copying the mutable array into an immutable one at the end.
14:09:53 <rwbarton> does lens need an hlint module?
14:09:59 <rwbarton> is that a thing that exists?
14:10:05 <edwardk> rwbarton: for encouraging good lens style?
14:10:08 <rwbarton> yeah
14:10:23 <acowley> I don't know that "good style" is well defined yet
14:10:39 <acowley> but it's a great idea to have something like that
14:10:46 <edwardk> i'm still sort of winging it, trying to figure out the way they "want" to be used if you know what I mean
14:10:46 <clahey> Yeah, say I have a grid of rooms and each room has a certain amount of state and I want to calculate the next set of states, do I have to allocate a new array?
14:10:48 <acowley> to help people transition from record updates to lenses
14:11:00 <clahey> Actually, I have to go.
14:11:02 <pnielsen> clahey: making a MUD?
14:11:22 <clahey> pnielsen: The only thing I'm actively working on is dance software, but I'm trying to learn everything I can.
14:11:34 <edwardk> clahey: for the most part that state will be immutable, so you can share it with the old version
14:11:39 <pnielsen> clahey: it's probably easier to think about (if you're not used to Haskell) is to make playerInRoom a TVar Room or RoomId, and just change that when they move
14:12:09 <blackh> clahey: Don't be afraid to use lots of threads. They're very cheap in GHC.
14:12:29 <dmwit> Easier to implement, maybe, but not easier to think (reason) about.
14:12:30 <acowley> Btw, I wrote some code like beautiful folds and I'm not sure if it corresponds to anything interesting algebraically. Compositions, in particular, I just banged together.
14:12:45 <pnielsen> dmwit: when I say think, I mean understand, not reason
14:12:49 <acowley> Does anyone have any insight into that stuff?
14:12:53 <pnielsen> dmwit: especially for an imperative programmer
14:13:11 <pnielsen> dmwit: although reasoning about STM is a lot easier than IO :)
14:15:48 <clahey> I will have to learn about STM, but I'm still having trouble following it.
14:15:54 <clahey> But I have to go.
14:16:00 <pnielsen> it shines when you have something like a MUD where a player only really needs to synchronize with a small part of the world at a time
14:16:17 <pnielsen> clahey: check out the chapter on STM in Real World Haskell, there is an example about RPG inventories
14:16:59 <pnielsen> at a time, and each connection/player has their own forkIO'd handler*
14:21:26 <yitz> ugh, does lens notation clash with the standard fraction operator?
14:22:02 <yitz> (from Ratio)
14:22:20 <edwardk> yitz: yes. Data.Ratio is not imported by default. If you go out of your way to import it qualify or hide one or the other.
14:22:55 <yitz> edwardk: it's very commonly imported, and when it is, you would certainly not want to have to qualify %.
14:22:56 <Cale> The % thing from Lens isn't important anyway, it's just if you want to write everything backwards
14:23:10 <yitz> Cale: ok.
14:23:34 <yitz> too bad you have to choose between those two though.
14:24:12 <jang> it's ugly, but can you ont alias it on the way in?
14:24:23 <yitz> i guess you had to choose *some* simple operator for that.
14:24:40 <edwardk> yitz: and you can use 3/4 instead just as well. i can't make every operator not collide with every other operator from anywhere. I had %=  and %~, I needed an operator for the a -> (a -> b) -> b. the one that was consistent with the symbology of every other operator was %.
14:25:15 <nomeata> Hi. Is there a way to express concat using foldl with linear runtime?
14:25:18 <yitz> edwardk: makes sense. and makes sense for it to be short. just that.. well, it's a shame that had to happen, that's all.
14:25:48 <acowley> One day edwardk will open pandora's unicode box, and hackage will weep
14:26:41 <edwardk> I could choose |> to be compatible with f#, but then I get a worse problem. I wind up with +=, <+= for chaining version, but then mod-equals becomes |>= and |>~ which are longer and totally unintuitive and worse <|>= is completely alien and doesn't mean what you'd expect at first glance at all
14:26:44 <hpc> nomeata: yes, do it the obvious way
14:26:51 <hpc> nomeata: it takes O(n) space as well though
14:27:12 <nomeata> hpc: foldl [] (++) xss?
14:27:15 <rwbarton> you can use difference lists
14:27:34 <hpc> > foldl (++) [] ["five", "six"]
14:27:36 <lambdabot>   "fivesix"
14:28:06 <edwardk> er what i mean is I have a consistent set of semiotics for the operators i use throughout lens. operator~ for functional assignment operator= for working in state like imperative +=, etc. and <+= or <+~ for 'and also give me the answer'
14:28:28 <nooodl> @src concat
14:28:29 <lambdabot> concat = foldr (++) []
14:28:39 <edwardk> so <|>= becomes either use <|> on the target of the lens, or it becomes use |> on the target of the lens in state and chain the result
14:28:56 <edwardk> so that which was really the only other serious candidate was ruled out
14:29:04 <nomeata> hpc: I belive this would become quadradric in the runtime, as I keep ++‚Äôing something to the end of a ever longer list
14:29:05 <rwbarton> > foldl (\a b -> a . (b ++)) id ["five", "six"] ""
14:29:06 <rosie> I'm trying to figure out the implementation of curry, but I'm not sure how I can give parameters to the function I'm currying‚Ä¶ curry :: ((a,b) -> c) -> (a -> (b -> c))      curry f (a1, a2)  = (f a1) a2
14:29:07 <lambdabot>   "fivesix"
14:29:13 <rwbarton> ^ I think this one is okay
14:29:14 * bgamari and laziness are apparently not on good terms today
14:29:17 <edwardk> that and modification is far too common to move to a 3 character operator
14:29:39 <rosie> that is, it looks like the curry function should only take in one input, which is f. But then I need to be able to apply its parameters one at a time
14:29:55 * applicative is evidently behind the times with Control.Lens , |>~ is a little worrying....
14:30:04 <edwardk> applicative: thats why i don't have it
14:30:23 <edwardk> applicative: i was explaining why the operator is % and not |> ;)
14:30:32 <applicative> oh, good choice, %
14:30:36 <nooodl> rosie: that's "uncurry" you're implementing there
14:30:37 <hpc> nomeata: you are (++)ing to the start of the longer list
14:30:38 <nomeata> rwbarton: I need to think about that; I assume it will build a linear list of thunks, and then work that off, but that would still be linear.
14:30:43 <applicative> I'm not sure why, by I could retain it.
14:30:48 <hpc> so you scan a short head, then cons it to a long tail
14:31:01 <rwbarton> hpc, no
14:31:03 <hpc> > foldl f 0 [x, y, z]
14:31:04 <lambdabot>   Ambiguous occurrence `f'
14:31:04 <lambdabot>  It could refer to either `L.f', defined at <local...
14:31:05 <nomeata> hpc: that‚Äôs with foldr, isn‚Äôt it? That is why concat is defined using doldr
14:31:08 <edwardk> >>> zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
14:31:08 <hpc> > foldl f 0 [x, y, z] :: Expr
14:31:09 <lambdabot>   Ambiguous occurrence `f'
14:31:09 <lambdabot>  It could refer to either `L.f', defined at <local...
14:31:27 <hpc> rwbarton: oh crap, you're right
14:31:37 <hpc> @src concat
14:31:37 <lambdabot> concat = foldr (++) []
14:32:08 * applicative does git pull on lens
14:32:18 <rwbarton> nomeata: right, and the important thing is you can see that the left hand argument of ++ is always an element of your input
14:32:22 <edwardk> makeClassy = makeLensesWith $ lensRules % lensClass .~ const (Just (clsName,funName)) % lensField .~ (`Prelude.lookup` fields)
14:32:38 <edwardk> before i had to do that backwards
14:32:53 <nooodl> @src (.~)
14:32:53 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:33:03 <rosie> noodl: I don't think that implementation returns a function that takes in a tuple. Can you give me a hint for what would the correct implementation look like for either curry or uncury?
14:33:12 <edwardk> (actually makeClassy is uglier)
14:33:23 <nooodl> @type curry
14:33:25 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:33:28 <yitz> jang: yes you could do that too. but both of those meanings of % are basic idioms that should always be spelled consistently.
14:33:40 <nooodl> @type uncurry
14:33:42 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:34:17 <rosie> nooodl: yep, i know the type signatures. my implementation doesn't look like it would match uncurl.
14:34:54 <johnw> edwardk: what is the main reason for makeClassy again?  someone here was asking last night
14:35:02 <johnw> I know it makes a HasFoo that you can use to export lenses conveniently
14:35:03 <rwbarton> rosie, what you wrote is actually a definition of uncurry
14:35:06 <johnw> but is there another reason?
14:35:08 <edwardk> nooodl: l .~ d = runIdentity . l (\_ -> Identity d)
14:35:30 <edwardk> johnw: thats the reason. there is a common idiom of doing this by hand with all the other lens packages
14:35:33 <nooodl> rosie: your "f" argument matches the "(a -> b -> c)" part
14:35:35 <johnw> ah, ok
14:35:46 <johnw> I told him that reason, and for the rest said, "Look for edwardk"
14:36:10 <rosie> er: I watt it to match the (a, b) -> c part, right?
14:36:13 <edwardk> you make a bunch of fields named with _'s, then you go and make the lenses, then you go and make a class, and THEN you go and duplicate all the signatures that would have otherwise been generated and then you copy the bodies
14:36:30 <edwardk> so a few lines of lens code becomes 30 lines of boilerplate.
14:36:35 <edwardk> and its brittle boilerplate
14:36:45 <edwardk> so i wrote makeClassy to do away with it
14:37:21 <edwardk> worse if you aren't careful the boilerplate is combinatorially explosive
14:37:32 <nooodl> rosie: no, it's really fine
14:37:43 <rosie> rwbarton and nooodl: I'll be back in a minute
14:38:16 <Saizan> edwardk: did you have a lib for incremental computation?
14:38:50 <edwardk> data Foo = Foo { _fooX, _fooY, _fooZ :: Double }; makeClassy ''Foo; data Bar = Bar { _barW :: Double, _barFoo :: Foo}; makeClassy ''Bar; instance HasFoo Bar where foo = barFoo
14:39:07 <edwardk> that gives you a 'subclassing' relationship between Bar and Foo where you can now use any Foo specific 'method' on Bar
14:39:23 <edwardk> Saizan: not released on hackage, but github.com/ekmett/revisions
14:39:33 <edwardk> the incremental part is probably not up there yet
14:39:57 <edwardk> but the key incrementalization operation is record :: MonadRev m => m a -> m (a, m a)
14:40:22 <edwardk> which combines with the revision control operations to fork/join and edit versioned variables to give you an incrementalized calculation
14:40:40 <edwardk> i have another monad i should publish to hackage for checkpointing long running evaluations
14:41:02 <edwardk> and one i just started the other day for doing paxos-like agreed upon execution traces
14:42:01 <applicative> man this gasche character on reddit.com/r/haskell is such an ocaml troll. but perhaps one shouldn't complain.
14:42:12 <mizu_no_oto> \j ant
14:47:21 <mcstar> Rosie Hymen
14:47:43 <mcstar> (c.f. Due Date, good comedy)
14:49:12 <teneen> Can I give options to ghc when using "cabal install"?
14:49:21 <johnw> --ghcopts
14:49:25 <dcoutts_> yes,  --ghc-options=
14:49:35 <johnw> oh, or that :)
14:49:44 <teneen> Very nice! thanks
14:49:52 <dcoutts_> teneen: depends if you mean as the person building the package, or as the author of the package
14:49:58 <dcoutts_> it's different in the two use cases
14:50:37 <teneen> dcoutts_: when "cabal install"ing from hackage?
14:51:12 <dcoutts_> ok, and in general cabal supports --$PROG-options for all the programs it uses
14:51:23 <dcoutts_> this is described in the --help output
14:52:48 <teneen> dcoutts_: what if I am the author of the package? I have to give the options when using "cabal build" not "cabal install", yes?
14:53:31 <alpounet> teneen, then you can specify the options in the .cabal file
14:53:38 <dcoutts_> teneen: you can do that. What I was referring to was if the author of the package wants certain options to be used every time by all users
14:53:55 <alpounet> so that users building your package will not have to specify it when calling cabal install
14:54:09 <dcoutts_> teneen: but of course while the author is hacking on the package they can also use options temporarily by using --ghc-options on the configure or build commands.
14:54:58 <dcoutts_> but you can see, they're different use cases: 1. the author knows certain options are always needed,  2. the person building the package wants to use certain options
14:55:30 <teneen> dcoutts_: I see
14:56:23 <teneen> For 1) it's the cabal file and for 2) it's the command line
14:56:31 <dcoutts_> teneen: exactly
14:56:56 <teneen> dcoutts_: Thanks a lot for clarifying.
14:57:14 <teneen> alpounet: Thanks for helping.
14:59:46 <Saizan> edwardk: i guess optimized instances of MonadRecord are the missing incremental part?
15:00:21 <yhager> I'm trying to compile a tool (pacmerge), and I get: Could not find module `System.Directory.Tree'
15:01:18 <Saizan> edwardk: ah, sorry, some are there
15:06:13 <geekosaur> yhager, hayoo tells me it's from the directory-tree package
15:06:30 <merijn> Is there someway to specify in a cabal file which compilers are supported?
15:06:49 <merijn> (i.e. can I make cabal output "ahahahaha" when someone tries to compile it with anything other than GHC? :p
15:06:50 <benmachine> merijn: not as such, but Tested-with is good for giving hints
15:06:56 <benmachine> merijn: oh, I guess you can do that
15:07:03 <yhager> geekosaur: it seems I have that one installed, but maybe not the right version?
15:07:07 <dcoutts_> merijn: we tend to try to do it the other way around, and specify dependencies, such as what language extensions are required
15:07:13 <benmachine> using if impl(ghc >= 7.6) together with Buildable: False
15:07:30 <benmachine> but as dcoutts_ implies that would be lame :P
15:07:33 <merijn> dcoutts_: I have the language extensions in the various hs files, though
15:07:52 <dcoutts_> merijn: and usually that's enough, it's actually rather rare for a package to really depend on ghc, as opposed to merely depending on various language extensions that happen at the present time to be implemented only by ghc
15:07:52 <geekosaur> yhager, if this is a cabalised package you're working with, then it may mean the dependency is missing in the cabal file
15:07:57 <merijn> Is it possible to specify a dependency on them?
15:08:24 <yhager> geekosaur: it's not cabalised, I downloaded the code and run 'ghc --make'
15:08:29 <dcoutts_> merijn: yes, the "other-extensions" field is for listing extensions that your modules use (ie in LANGUAGE pragmas)
15:09:05 <benmachine> dcoutts_: is 'extensions' different from 'other-extensions' in any way?
15:09:10 <dcoutts_> merijn: which is different from the default-extensions (or the old 'extensions' field) which lists extensions that all your modules use (and which need not be listed in LANGUAGE pragmas)
15:09:20 <benmachine> oh right
15:09:23 <dcoutts_> benmachine: extensions = default-extensions
15:09:34 <benmachine> so other-extensions are not enabled by cabal
15:09:35 <geekosaur> then it may be a version issue, possibly.  ghc-pkg find-module System.Directory.List
15:09:41 <dcoutts_> benmachine: right
15:10:00 <merijn> And of course DataKinds isn't actually recognized as a valid extension :p
15:11:11 <dcoutts_> merijn: sadly they forgot to register a bunch of the new 7.6 extensions. I did actually write a test in the ghc testsuite so that this wouldn't happen, but it seemed it got missed.
15:11:41 <merijn> :p
15:11:50 <dcoutts_> it'll be fixed soonish, so that hackage accepts the new extensions, even if your local cabal warns
15:12:04 <dcoutts_> merijn: btw, it's only a warning locally, not an error
15:13:09 <merijn> Yeah, I noticed
15:36:55 <rosie> Why is this the wrong implementation of curry? curry :: ((a,b) -> c) -> (a -> (b -> c))   curry f (a1, a2) = (f a1) a2
15:38:01 <centrinia> :t \f (a1,a2) -> (f a1) a2
15:38:02 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t1) -> t2
15:38:26 <centrinia> Because your f shouldn't take a pair.
15:38:32 <centrinia> :t curry
15:38:33 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:38:47 <centrinia> :t uncurry
15:38:48 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:38:54 <centrinia> You implemented uncurry. :p
15:39:06 <centrinia> :t \f a b -> f (a,b)
15:39:07 <lambdabot> forall t t1 t2. ((t, t1) -> t2) -> t -> t1 -> t2
15:39:46 <benmachine> rosie: I think you have the type signature for curry and the implementation of uncurry
15:40:21 <centrinia> what he said.
15:40:55 <benmachine> centrinia: I only meant to augment your comments :P
15:57:14 <ew0> I just built my first useful state monad =D
15:57:38 <ew0> I saw a really nice lecture in youtube about monads
15:57:41 <monochrom> congratulations
15:57:47 <ew0> from some university
15:58:06 <monochrom> is that the "catsters" series of videos
15:58:26 <ew0> I don't know. The geezer seemed to be involved with the creation of haskell.
15:58:36 <ew0> He shouted whenever he read something in CAPS.
15:58:56 <monochrom> I see, then it is not the catsters. but whatever you like and understand is cool
15:59:31 <monochrom> (it is a woman in the catsters' monad lecture :) )
15:59:40 <ddarius> It's two people.
15:59:48 <ddarius> Well, not for monads.
15:59:58 <ddarius> Actually, the monads lectures are really entertaining.
16:00:03 <johnw> i'd love an O'Reilly book on lenses
16:00:13 <ew0> I started to watch one by a lady on the blackboard
16:00:22 <ew0> but she scared me out of her lecture in the first 2 minutes
16:00:57 <ew0> https://www.youtube.com/watch?v=XovXFGWPSRE&feature=relmfu
16:01:01 <ew0> this was the one I liked
16:01:04 <monochrom> my gravity lens predicts that an o'reilly book on lenses will be outdated the day it reaches amazon.com
16:01:23 <monochrom> (just as two haskell books did)
16:01:24 <Eduard_Munteanu> Ah, Wadler.
16:01:42 <ew0> books? who gets their information from books these days
16:01:43 <monochrom> lady on the blackboard is exactly the catsters one :)
16:01:51 <ew0> facebook and youtube are the best learning tools ever
16:02:13 <ew0> xD
16:02:35 <monochrom> I still get my information from books today. also, I am writing one, too. mine is a PhD thesis
16:03:16 <monochrom> I bought Richard Bird's new book recently, to celebrate finishing the first draft of my thesis
16:03:17 <ew0> Well, me too. But in my life I read like only ~50 phd thesis.
16:03:20 <Eduard_Munteanu> monochrom: what's it on? I'm just curious what sort of research you're doing.
16:03:32 <ew0> If you compare with the fact I watch 50 youtube videos/day.
16:03:34 <monochrom> it is on lazy timing!
16:03:41 <johnw> it's odd that http://brandon.si/code/haskell-state-of-the-lens/ doesn't even mention edwardk's package
16:03:59 <ew0> Maybe we are targeting a null audience.
16:04:42 <applicative> hah, wadler. You picked the right tutor ew0
16:04:55 <monochrom> Richard Bird's good book: http://www.amazon.com/Perils-of-Functional-Programming/dp/0521513383/
16:05:19 <benmachine> johnw: there's like two edwardk packages in that list :P
16:05:31 <benmachine> johnw: neither of them are 'lens' but that's probably because lens is relatively new
16:05:53 <applicative> that page is totally out of date, it's a few months old by now
16:06:44 <ew0> Here in my uni, if you have 1-2 journal articles, you just put them on a binder and you don't need to write a thesis.
16:06:46 <johnw> i guess I didn't realize it was *that* new
16:07:29 * applicative preferred Bird's http://www.amazon.com/Functional_Pearls_before_Swine/dp/0521513383/
16:07:51 <Eduard_Munteanu> ew0: interesting, although I guess it depends on the scope and quality of your research
16:08:04 <applicative> johnw you are an early adopter!
16:08:31 <monochrom> 1 journal article is already almost a phd thesis. 2 definitely exceeds it. IMO this is a more productive way to get a phd
16:09:14 <monochrom> I mean, like, you output serious publications and you don't waste time writing yet another document containing the same thing again
16:09:15 <ew0> Yeah. But what would be even more productive wold be a nice github account.
16:10:32 <ew0> It is really hard to judge the quality of a PHD. There is no price for it.
16:10:59 <ew0> PHD thesis should be judged by the market.
16:11:13 <johnw> absolutely not
16:11:17 * Cale squints
16:11:22 <johnw> the market gauges what people want now, not what they will want
16:11:44 <ew0> not really, johnw, interest rates provide this balance.
16:11:47 <Cale> Who cares what the monetary value of a Ph.D. thesis is?
16:11:55 <johnw> and PhD's should be, by definition, reaching into new areas
16:11:58 <ew0> the problem is that interest rates are way bellow they would naturally be
16:12:27 <johnw> I don't think the Fed should have anything to do with balancing the value of PhD work :)
16:12:35 <benmachine> Cale: well, if you don't have money, how are you going to buy happiness?
16:12:36 <ew0> it actually does
16:12:59 <ew0> research activities are a long term investment
16:13:09 <ew0> low interest rates and high inflation predate long term investment
16:13:35 * hackagebot toysolver 0.0.2 - Assorted decision procedures  http://hackage.haskell.org/package/toysolver-0.0.2 (MasahiroSakai)
16:14:17 <dmwit> What if the most efficient thing is not the most desirable thing?
16:14:37 <ew0> That's why there's the price system
16:14:49 <Cale> You do a Ph.D. in order to study something you have an interest in with the support of an advisor who is well-versed in that area. It shouldn't really matter to you what it's worth to anyone else, and it shouldn't matter what it's worth to you monetarily.
16:15:42 <Cale> There's a much more important way in which it's valuable: you learn something and advance human knowledge in some way.
16:15:59 <Eduard_Munteanu> It's hard to tell what it's worth unless people are actually buying / selling them (not to mention assuming you can lump all PhDs together).
16:15:59 <Cale> How much that is as a dollar amount seems completely irrelevant.
16:16:01 <ew0> Cale, this has imense monetary value.
16:16:19 <Eduard_Munteanu> What it's worth wrt price, that is.
16:16:24 <Cale> ew0: But even if it had zero monetary value, that doesn't matter.
16:16:36 <ddarius> Surely PhD theses are a fungible commodity.
16:17:17 * Eduard_Munteanu . o O (phdcoins!)
16:17:29 * ddarius only jests.  It's Master's theses that are fungible commodities.
16:17:32 <ew0> A dollar ammount after a certain point has no value for the researcher
16:17:40 <ew0> but it must have a minimum
16:17:58 <Eduard_Munteanu> ew0: I think you're looking for utility rather than price
16:17:59 <ew0> after all, we need to eat
16:18:01 <Cale> If the primary reason you're doing a Ph.D. is financial, you probably shouldn't be doing one.
16:18:22 <ew0> prices reflection both utility and scarceness of resources
16:18:28 <ew0> prices reflect*
16:18:43 <Cale> http://www.smbc-comics.com/index.php?db=comics&id=2745#comic
16:19:51 <ew0> The primary reason I'm doing my PHD is to contribute to society. But it is very hard to judge the value of the contribution.
16:20:13 * johnw agrees with Cale
16:20:25 <Eduard_Munteanu> If it's even an economic good.
16:20:49 <johnw> i always thought PhD's were knowledge for knowledge's sake, and if some of them lead to valuable results, great, but if not, fine
16:21:15 <johnw> there's value in exploration, period
16:21:33 <ew0> if you don't achieve valuable results, being them positive or negative, you don't get a PHD
16:21:43 <johnw> that's too short-sighted
16:21:55 <johnw> what if it takes 4 PhDs in series to lead to that amazingly valuable 5th
16:22:27 <Earnestly> In an ideal world. But funding is required
16:22:33 <ew0> Each one of them had theyr marginal revenue
16:22:36 <ew0> their
16:22:57 <mcstar> knowledge for knowledge's sake is well, entertainment
16:23:05 <mcstar> the world needs more than entertainment
16:23:10 <rosie> Why is this not the correct implementation of curry? curry f = \a b -> f (a, b)
16:23:34 <shachaf> @ty let foo f = \a b -> f (a,b) in foo
16:23:34 <benmachine> rosie: what makes you think it is incorrect?
16:23:35 <lambdabot> forall t t1 t2. ((t, t1) -> t2) -> t -> t1 -> t2
16:23:36 <shachaf> @ty curry
16:23:37 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:23:38 <MostAwesomeDude> rosie: Why not: curry f a b = f (a, b)
16:23:41 <johnw> mcstar: then what's the space program for?
16:23:42 <shachaf> Looks fine to me.
16:24:13 <johnw> shachaf: is @ty different from :t here?
16:24:20 <shachaf> johnw: Yes -- it works in /msg
16:24:21 <mcstar> johnw: preparation for interplanetary mining operations
16:24:36 <shachaf> Other than that it should be the same.
16:24:51 <benmachine> mcstar: nah. it's for impressing people
16:24:59 <benmachine> whether the dirty commies or the schoolkids :P
16:25:02 <mcstar> im not impressed
16:25:13 <benmachine> you're not in the majority
16:25:14 <Jafet1> http://uncyclopedia.org/wiki/British_Moon-landing
16:25:24 <blackh> johnw: geopolitical propaganda
16:25:44 <mcstar> honestly? we need fusion
16:25:55 <mcstar> not the iter kind, possibly
16:25:57 <SLi> Hmm. Somehow I'm guessing Haskell may have a larger portion of PhD users than any other programming language with remotely comparable or larger popularity. Both in that a PhD who programs in Haskell is more likely to keep programming (in Haskell) than a PhD with lots of C experience to keep programming in C, and newcomers to Haskell are probably also more likely to be or become PhD than newcomers to, say, Java.
16:26:00 <johnw> the space program has been a "look, we can do it" endeavor for decades now, which fits your definition of entertainment, plus we've valued this at many billions of dollars!  So why isn't exploring the knowledge space valuable in its own right by the same token?
16:26:02 <benmachine> guys remember that there is #haskell-blah for discussion the salvation of the word
16:26:05 <benmachine> er world
16:26:07 <MostAwesomeDude> mcstar: The Return to Forever kind?
16:26:07 <mcstar> i hope i can contribute to that some day
16:26:24 <mcstar> MostAwesomeDude: never heard of it
16:26:37 <ew0> sly, probably
16:26:39 <mcstar> im on blah
16:26:42 <ew0> sli*
16:26:45 <MostAwesomeDude> mcstar: Chick Corea's old band. Check it out sometime.
16:26:58 <johnw> benmachine: oh yeah, we can only discuss things of value here ;)
16:27:08 <benmachine> johnw: right :)
16:27:29 <SLi> Too many people no longer have time to write code at all after getting into a high enough position (either academically or in business), and with boilerplate languages like C or Java I don't wonder.
16:30:44 <bgamari> Does anyone know why Data.Map.Strict.findWithDefault is strict in the default?
16:30:55 <bgamari> This seems like a questionable decision (at least in my opinion)
16:31:14 <tgeeky> you questioning it makes it factually questionable!
16:31:24 <bgamari> you have me ther
16:31:26 <bgamari> there*
16:31:31 <hpc> heh
16:31:46 <bgamari> Is there a good reason why you'd want to evaluate the default even when the value is found?
16:31:48 <johnw> lol
16:31:56 <hpc> huh
16:32:21 <Polarina> @src findWithDefault
16:32:21 <lambdabot> Source not found. Just try something else.
16:32:21 <shachaf> bgamari: But it says "Strict" right in the module name!
16:32:26 <hpc> that could just be a case of "it's under .Strict, so shut up and enjoy the extra bottoms"
16:32:26 * shachaf agrees that it's questionable.
16:33:03 <bgamari> fair enough
16:33:16 <dmwit> I think it's questionable that you would have a problem with making findWithDefault strict in the default.
16:33:16 <shachaf> bgamari: It's also questionable whether it should be strict in the key, for an empty Map.
16:33:39 <bgamari> but then we have Control.Monad.Trans.Writer which if I recall correctly isn't strict in some important sense
16:33:54 <bgamari> Writer.Strict that is
16:33:55 <shachaf> I was under the impression that the only difference between .Strict and .Lazy should be value strictness (in the structure itself).
16:34:08 <dmwit> If your default blows up when you evaluate it, it's going to blow up when your key isn't in the map, so you don't really have any guarantees anyway.
16:34:15 <dmwit> Might as well blow up when the key is in the map, too.
16:34:43 <bgamari> dmwit, I was relying on evaluating bottom to crash things when the key wasn't present
16:34:54 <dmwit> ew
16:34:57 <dmwit> Doubly questionable.
16:35:07 <bgamari> go ahead, judge away ;)
16:35:24 <shachaf> dmwit: (foo M.! k) is terrible because you get an uninformative error message.
16:35:25 <SLi> Well, it's possible to write code where the default only blows up when the key is not in the map :p
16:35:37 <shachaf> M.findWithDefault (error "blah") foo k is less terrible
16:35:46 <bgamari> It's error handling for what should be an "impossible" scenario
16:35:53 <shachaf> At least you get a nice error message in the "never happens" case.
16:36:20 <shachaf> bgamari: I know someone who likes to "let Just v = M.lookup foo k", so he gets a pattern match error with a line number.
16:37:08 <bgamari> shachaf, Yeah, I suppose there is that
16:37:12 <Polarina> Or better yet: let ~(Just v) = M.lookup foo k
16:37:39 <shachaf> > let Just v = Nothing in 3
16:37:40 <lambdabot>   3
16:38:02 <SLi> A consequence from my previous lemma that Haskell has more PhD programmers than other languages: A larger portion of Haskell users are more academic than in other languages, tending to abhor ugly real-world problems like bottom values and error handling :P
16:38:15 <johnw> lol
16:38:56 <shachaf> Stating something doesn't make it a lemma.
16:39:07 <jfischoff> SLi: not sure if "real world" programmers pay much attention to error handling
16:39:46 * jfischoff sees many empty catch blocks in the real world
16:39:55 <geekosaur> ^^
16:40:07 <geekosaur> real world programmers ignore error conditions as much as possible
16:40:12 <shapr> jfischoff: Which package has Test.Feat?
16:40:18 <SLi> jfischoff, what you say, it was clearly proven by someone saying "probably" and nobody being silent!
16:40:38 <SLi> Um, I mean, nobody opposing it. :P Too tired.
16:41:17 <jfischoff> shachaf: http://hackage.haskell.org/package/testing-feat-0.2
16:41:30 <shachaf> jfischoff: ?
16:41:32 <SLi> And I meant shachaf
16:41:36 <SLi> Not jfischoff :)
16:41:44 <jfischoff> opps
16:41:49 <jfischoff> shapr^
16:41:59 <shachaf> SLi: It's probably not true.
16:42:02 <shachaf> There you go.
16:42:29 <shapr> jfischoff: obrigado
16:42:48 <benmachine> shapr: does it make it a lemur?
16:42:50 <jfischoff> shapr: :)
16:43:06 <benmachine> err
16:43:11 <benmachine> shachaf: I hate my tab key
16:43:30 <Jafet1> MAP IT TO CAPSLOCK
16:43:39 <SLi> Even with the limitations in my original statement (limiting the comparison to "other languages with reasonably comparable or larger popularity")? ;) (and we're talking about proportions, which was also stated in my original hypothesis :)
16:43:56 <SLi> I do actually think it's fairly likely to be true. But no, not proven.
16:44:04 <benmachine> Jafet1: I mapped my capslock to escape, if that helps
16:44:34 <SLi> benmachine, you must be a vim user.
16:44:40 <SLi> Just guessing. :P
16:45:07 <benmachine> SLi: yep :P
16:45:27 <shapr> I found a neat language written in Haskell: https://github.com/HackerFoo/peg
16:45:45 <shapr> ddarius: Have you seen any other good implementations of postfix stack-based languages in Haskell?
16:46:15 <cmccann> pf, real world programmers handle errors easily, all the time:  "try { foo(); bar(); } catch (Exception e) { }" -- see? simple!
16:47:19 <shachaf> cmccann: I've managed a major reduction in lines of code by not throwing the exceptions in the first place.
16:47:26 <SLi> cmccann, I use abort() (and assert()) in C, and I'm shunned for it. They even make a point of making languages without assert like Go!
16:47:31 <jfischoff> shapr: have you seen this postfix library: http://hackage.haskell.org/packages/archive/concatenative/1.0.1/doc/html/Control-Concatenative.html
16:47:43 <shapr> not yet...
16:47:44 * shapr looks
16:48:34 <cmccann> shachaf, the best form of error handling is not generating errors in the first place. :]
16:48:40 <dmwit> Delaing with errors should be as difficult as possible.
16:49:07 <dmwit> This encourages not creating errors in the first case and thinking hard about how to deal with errors when you absolutely can't avoid them.
16:49:21 <dmwit> Also, I will probably feel exactly the opposite way in a few days, and defend to the death the opposite view on that day.
16:50:20 <monochrom> that depends on whether "error" means programmer's fault or environment surprises
16:50:31 <Jafet1> Err or
16:50:32 * cmccann has a Dijkstra quote along these lines somewhere about not creating bugs being better than debugging
16:50:53 <shapr> jfischoff: This is awesome, but I want example code.
16:52:12 <jfischoff> > bi (>4) (<30) (&&) 21 ==> True
16:52:13 <lambdabot>   Not in scope: `bi'Not in scope: `==>'
16:52:29 <monochrom> David Parnas carefully stays away from the word "error" and says instead "undesirable events"
16:52:29 <jfischoff> hmm not that interesting I guess
16:52:33 * cmccann suspects most errors of the sort that "error handling" handles are of the "not dealing with certain unexpected combinations of input" variety.
16:53:00 <cmccann> where "input" is being abused to include things like reading from global state.
16:53:04 <johnw> i.e., some errors = the code is wrong, other errors = the environment is wrong
16:53:26 <johnw> i'd like writing wrong code to be as impossible as possible
16:53:54 <gwern> > (0+1) / (25+2)
16:53:55 <lambdabot>   3.7037037037037035e-2
16:55:54 <cmccann> serious problems (e.g. computer has caught fire) are not something you can simply "handle", and errors that produce wrong results rather than outright failure aren't really something you can deal with in code at all.
16:56:51 <cmccann> unless there are languages that will throw ThisDoesNotMeanWhatYouThinkItMeansException when you write a program that successfully does the wrong thing.
16:57:00 <cmccann> that would be pretty cool.
16:58:06 <NihilistDandy> Though hopefully that will be handled by an internal ButIKnowWhatYouWereGoingForSoDontWorryAboutItHandler
16:58:13 <Mortchek> Not unless you install a watering can on an arm and write the API for it
16:59:56 <Mortchek> Though, considering the current state of programs that try to do things for you rather than do what you tell them, I think we are a ways off from that sort of behavior
17:00:14 * applicative is having difficulty conceiving c. okasaki asking a question on stackoverflow, but so it seems
17:00:44 <georges> learning Haskell, day 1. Here I go.
17:00:55 <applicative> good luck georges
17:01:04 <NihilistDandy> applicative: Link?
17:01:10 <applicative> http://stackoverflow.com/questions/12496886/how-to-talk-about-companion-objects-vs-regular-objects
17:01:19 <applicative> NihilistDandy: its about scala, which he's teaching
17:01:26 <NihilistDandy> Aha
17:01:32 <monochrom> poor him
17:01:48 <blackh> georges, #haskell is ready to help any time you have a question
17:02:23 <georges> excellent, thank you #haskell.
17:02:36 <applicative> georges: I specialize in explaining the very simple error statements
17:02:52 <alpounet> enjoy your journey georges heh
17:03:13 <georges> I think the real challenge will be to acquire some sort of functional problem solving reflexes
17:03:45 <georges> I am corrupted to the core with the imperative!
17:03:59 <Mortchek> Once you do, you will find for loops painful. Just a heads up.
17:04:01 <cmccann> heh, I like Okasaki's choice of photo for his gravatar.
17:04:35 <blackh> georges: I sympathize. If you try to do everything pure that can be done pure, then Haskell will basically force you into functional thinking.
17:05:01 <alpounet> georges, what material are you using, by the way?
17:06:37 <georges> I have ordered some books " Learn You a Haskell for Great Good" and O'reilly
17:06:44 <georges> any recommendations other than those?
17:07:03 <johnw> good places to start
17:07:03 <shachaf> georges: Hutton's _Programming in Haskell_ is quite good.
17:07:19 <georges> noted
17:07:19 <shachaf> I suspect it's a better introduction than either of those two.
17:07:46 <shachaf> dcoutts confirms it.
17:08:12 <georges> oh, I read about this one. apparently is had a very academic approach in teaching
17:08:17 <georges> *has
17:08:30 <shachaf> I didn't think of it as particularly academic.
17:08:42 <AfC> georges: You'll enjoy LYAH. And RWH will make you feel like you know what you're doing. But it'll still be a while until you get on top of things. Just keep at it patiently.
17:09:13 <georges> ya
17:09:26 <AfC> shachaf: isn't Hutton's book really dated? I mean, sure, you'll learn about Haskell as FP, but Haskell as production language is ... newer.
17:09:32 <alpounet> georges, don't worry, by the time you finish these two, you'll have talked a lot here, asked questions, etc, and you'll have collected hundreds of links to blog posts or wiki entries that will complement the books
17:10:06 <georges> excellent
17:10:16 <georges> I was thinking of diving in with Snap. Is this a terrible idea?
17:10:36 <alpounet> before you have any haskell knowledge at all? yeah i think so
17:10:41 <shachaf> AfC: You're best off learning the former before you learn the latter.
17:11:11 <shachaf> It's dated but for the most part that's not relevant.
17:16:19 <georges> so I can only use a bound variable in a given body? I can't use that variable globally outside the scope of that body?
17:16:39 <blackh> georges: That's right
17:17:24 * shachaf isn't sure what georges means.
17:17:51 <blackh> Well, it's true of variables and type variables that they're only within a limited scope
17:19:01 <monochrom> it's true of almost every sane language
17:19:27 <monochrom> in C: int f(int whee) { .... }  there is no "whee" outside
17:19:41 <cmccann> reverse lexical scoping, variables are only visible outside their binding
17:19:47 <johnw> hah
17:19:47 <cmccann> that sounds fun
17:19:59 <johnw> that sounds like the Tardis monad
17:20:12 <johnw> values appear before they are set
17:20:17 <monochrom> that's like http://spikedmath.com/527.html
17:21:33 <dmwit> http://axisofeval.blogspot.com/2012/07/when-new-language-doesnt-get-lexical.html
17:22:04 <monochrom> hahaha
17:23:12 <jfischoff> hey really captures my feelings of javascript
17:23:22 <parcs`> lol
17:24:18 <georges> I'm interested in Haskell for distributed computing purposes. What other reasons to people have to work with Haskell?
17:24:43 <jmcarthur> georges: code that's easy to reason about
17:24:50 <jfischoff> georges: you can write code very quickly with it, once you get the hang of it
17:25:46 <hpc> it's a great language to learn new things with
17:25:58 <hpc> and sometimes i use it just because it has a library
17:26:07 <hpc> (the true mark of language success)
17:26:30 <georges> does anyone use it professionally here?
17:26:43 <monochrom> I like the language. it's quite uniform. it enables better program structures.
17:27:55 <jfischoff> georges: I am right now
17:28:25 <jfischoff> It can be done but it is risky
17:28:26 <johnw> georges: I use Haskell instead of Python or Ruby for writing command-line utilities.  It's easier to write correct code, the editing/debugging facilities are more powerful (mainly because of types), and the resulting programs startup MUCH faster, and run much faster, and I can do profiling and coverage analysis
17:28:41 <shachaf> georges: Did you see the FAQ? You should see the FAQ.
17:28:42 <shachaf> @where faq
17:28:42 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:28:51 <johnw> plus, I can usually add concurrency to any program with almost no effort
17:29:38 <johnw> I just change my "mapM_" to a "parallel_ $ map", and I'm done (in most cases)
17:29:39 <georges> yeah I've read it, I was just curious to know about the people in this channel
17:30:28 <shachaf> parallel_?
17:30:41 <dmwit> georges: Who do you think wrote the FAQ? (Hint: the people in this channel.)
17:30:44 <johnw> shachaf: in parallel-io
17:30:51 <johnw> it really should be called "concurrent", IMHO
17:31:04 <shachaf> dmwit: Hint: Someone who used to be in this channel, but decided it was so terrible that he quit.
17:31:07 <shachaf> :-(
17:31:32 <jmcarthur> i use ocaml professionally, but it wouldn't have happened without haskell
17:31:38 <ivanm> shachaf: :o who?
17:31:39 <blackh> georges: I use Haskell professionally as much as I can. I occasionally hit 100%.
17:32:03 <ivanm> blackh: don't you work for iPwn? what other lang do you use, objective-c or something?
17:32:06 <pnielsen> I use Haskell professionally, but not as much as I'd like
17:32:12 <shachaf> ivanm: kmc
17:32:18 <shachaf> ivanm: What, they're still around?
17:32:26 <ivanm> he left? :o
17:32:28 <ivanm> how come?
17:33:03 <shachaf> Ask him, not me.
17:33:05 <jmcarthur> i use haskell professionally sometimes, but mainly to port to ocaml. i use agda in the same way sometimes.
17:33:28 <blackh> ivanm: iPwn doesn't have a lot of money at the moment, but we continue to plug away.
17:33:37 <ivanm> blackh: *nod*
17:33:42 <georges> Do you find that you guys tend to use Haskell because of personally preference or because there is a technological need or justification to use it for what you're working on?
17:33:59 <pnielsen> johnw: concurrent does not imply parallel though
17:34:09 <jfischoff> georges: both
17:34:12 <ivanm> shachaf: oh, you meant that he decided the _FAQ_ was terrible that he quit?
17:34:26 <ivanm> I thought you meant he thought the _channel_ was terrible
17:34:29 <shachaf> ivanm: No, #haskell was terrible.
17:34:31 <jmcarthur> georges: i don't think there's a big difference between those two things most of the time. the judgements about technological needs/justifications are often so heavily influenced by preferences anyway
17:34:32 <shachaf> Still is, in fact. :-(
17:34:42 <ivanm> that's news to me
17:35:02 <jmcarthur> kmc left #haskell?
17:35:28 <shachaf> jmcarthur: Yep, a while ago.
17:35:32 <jmcarthur> :(
17:35:39 <jfischoff> shachaf: how was it before?
17:35:49 <Enigmagic> it was worse.
17:35:52 <blackh> georges: The irony of the situation is that the advantages of using Haskell increase with the size of the project. Big projects often could really do with getting into a time machine and causing them to have been retrospectively started in Haskell.
17:36:00 <jfischoff> was it ever good?
17:36:12 <jmcarthur> ... i like #haskell
17:36:26 <dmwit> s/retrospectively/retroactively/
17:37:05 <blackh> georges: Haskell is justified in technical grounds, but often not on commercial grounds. Whether Haskell will hit the big time is something we can't be sure of. It basically depends on Haskell finding some "killer app" and there are several potential areas for this.
17:37:06 <jfischoff> jmcarthur: me too :)
17:37:47 <pnielsen> blackh: finding a killer app, or advancing far enough into the future that you have to write parallel software
17:38:04 <georges> I am enjoying all these predefined functions
17:38:07 <georges> filter is quite sexy
17:38:08 <pnielsen> blackh: although haskell is not the only contender, functional or imperative
17:38:45 <blackh> georges: Haskell's innovations are truly powerful. In some cases they leak into the mainstream without affecting language choice.
17:39:14 <pnielsen> personally I think Haskell will continue to be a language that PL people adore, and borrow ideas from
17:39:27 <blackh> The ideas from Haskell are succeeding, but whether Haskell itself succeeds we don't know yet.
17:39:52 <pnielsen> I'm skeptical that it will ever become as popular as an imperative languagew
17:39:54 <pnielsen> heh
17:40:07 <pnielsen> ^5 blackh
17:40:24 <jfischoff> pneilsen: luckily that doesn't matter
17:41:06 <blackh> Well, when I started in this channel 3/4 years ago it had 600 people, and now it has 900.
17:41:11 <pnielsen> jfischoff: not to me, at least. I don't need Haskell to become more popular than it is now. It's good that it's not less popular, though: having poor library support can be a pain
17:41:28 * jfischoff nods
17:41:32 <pnielsen> jfischoff: it only really bothered me with http/TLS clients so far, but libcurl has sufficde
17:41:38 <pnielsen> sufficed*
17:41:43 <hpc> blackh: your monitor is just upside-down
17:41:47 <jfischoff> ah I know your pain
17:42:15 <dmwit> upside down and also you're looking at it through a mirror...
17:42:45 <cmccann> having a relatively painless FFI to C, which remains the lingua franca for a lot of real-world programming, helps a lot with the library situation.
17:42:51 <alpounet> blackh, didn't you write an arrow tutorial on the haskell wikibook or smth like 2 or 3 years ago?
17:42:54 <pnielsen> indeed
17:43:04 <blackh> alpounet: Yeah.
17:43:12 <cmccann> even if it is annoying when you want a library that should be mostly pure functions...
17:43:26 <alpounet> wow, i don't know how my brain just remembered that, but it did
17:43:28 <hpc> cmccann: you can FFI with a pure type signature
17:43:43 <hpc> no need to unsafePerformIO
17:43:52 <cmccann> hpc, sure. if you're confident that the foreign function can be treated as such.
17:44:04 <bitonic> hpc: well that's basically like using unsafePerformIO.
17:44:17 <bitonic> you don't actually have to type `unsafePerformIO'
17:44:17 <hpc> it's exactly unsafePerformIO
17:44:22 <cmccann> also, it is unsafePerformIO. that's why unsafePerformIO exists, isn't it?
17:45:00 <bitonic> cmccann: not only that.  sometimes you might need unsafePerformIO/unsafeCoerce (they're equivalent in the end)
17:45:16 <bitonic> both for performance reasons and because you might need to convince the compiler of something :P
17:45:24 <copumpkin> you can write unsafeCoerce with unsafePerformIO, but not really vice versa
17:45:40 <copumpkin> unless you just mean pulling out the hidden representation of IO
17:45:47 <bitonic> copumpkin: really?  I think you can, as of GHC
17:45:59 <bitonic> with an IORef
17:46:08 <copumpkin> that's how you write unsafeCoerce with unsafePerformIO
17:46:12 <bitonic> ah
17:46:12 <bitonic> right
17:46:21 <copumpkin> you can construct an unduly polymorphic IORef
17:46:22 <hpc> copumpkin: maybe you could coerce an (IO a) to (IO (IO a)), then join it and coerce back
17:46:25 <copumpkin> and read/write different things to it
17:46:25 <hpc> ?
17:46:50 <bgamari> arg, yet another stack overflow
17:46:53 <copumpkin> hpc: how would you get the data back out?
17:47:10 <bitonic> copumpkin: I'm pretty sure I've seen it done it the other way.  I guess they all rely on how GHC works in one way or another
17:47:48 <bgamari> Are there any tricks for localizing a stack overflow?
17:48:01 <bitonic> copumpkin: yeah once you have a `ref :: IORef a' you're done.  I was quite surprised when I found about that.  first Haskell surprises :)
17:48:08 <bgamari> It only happens with large data sets after several minutes of churning
17:48:17 <hpc> copumpkin: you coerce "up" a level, join, then coerce down
17:48:23 <parcs`> bgamari: compile with -prof and pass +RTS -xc ?
17:48:25 <shachaf> bgamari: Localizing?
17:48:36 <copumpkin> hpc: I don't think that'll do the right thing
17:48:37 <bgamari> and sadly -xc doesn't give a specific enough location
17:49:18 <jfischoff> bgamari: did you have profiling turned on?
17:49:21 <bgamari> I don't actually even see how it's possible for the function -xc is claiming is responsible could blow the stack
17:49:22 <bgamari> yes
17:49:30 <bgamari> -auto-all -caf-all
17:49:50 <Enigmagic> attach gdb
17:49:53 <Enigmagic> dump TSO stack
17:50:30 <jfischoff> Enigmagic++
17:50:49 <shachaf> Enicmagid
17:51:18 <bgamari> Enigmagic, alright
17:52:07 <Enigmagic> bgamari: best to relink with -debug (to get some helper functions for printing rts datatypes)... then set a breakpoint on stg_raisezh and wait.
17:52:23 <bgamari> Enigmagic, -prof is needed here as well?
17:52:45 <Enigmagic> bgamari: it's better if you can
17:54:16 <bgamari> Enigmagic, and -prof?
17:55:19 <Enigmagic> bgamari: -debug links with the debug runtime, -prof makes it so the debugging functions will print out type names
17:55:26 <Enigmagic> so use both if you can, otherwise just use -debug
17:57:32 <johnw> does -auto-all supercede -fprof-auto?
18:01:16 <Enigmagic> johnw: i think it's the other way around
18:03:21 <johnw> there's -prof, -auto, -auto-all, -fprof-auto, and -caf-all
18:03:31 <johnw> I'm very unclear as to their relationship
18:03:40 <johnw> reading http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/prof-compiler-options.html now
18:05:31 <Enigmagic> johnw: -prof selects a profiled build (different ABI), the other flags control automatic generation of profiling annotations
18:05:56 <johnw> what's the difference between -auto-all and -fprof-auto?
18:06:16 <johnw> and should I be using both -fprof-auto and -fprof-auto-calls if I want to use +RTS -xc?
18:06:34 <Enigmagic> johnw: compare it to http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/prof-compiler-options.html
18:06:41 <johnw> good idea
18:06:51 <johnw> ah, I see
18:06:56 <johnw> the -fprof.* is the new hotness
18:12:33 <bgamari> Enigmagic, What does one have to do to get the GHC build system to build the debug RTS?
18:13:03 <Enigmagic> bgamari: did you build your own ghc?
18:13:15 <bgamari> Enigmagic, Yes
18:13:44 <bgamari> It seems like this should involve GhcLibWays in build.mk
18:15:36 <Enigmagic> bgamari: i actually don't know, i've always ended up with one and the regular binary distributions on OSX have it there too
18:16:25 <bgamari> ahh
18:16:30 <Enigmagic> GhcRTSWays += debug
18:16:30 <bgamari> I have the debug rts
18:16:34 <Enigmagic> that looks like it
18:16:38 <bgamari> just not debug and profile
18:17:00 <bgamari> which I guess means GhcRTSWays += debug_p
18:17:01 <bgamari> ?
18:17:45 <Enigmagic> bgamari: well if you have it sans profiling you can probably figure out enough between that and your -xc output from before
18:18:56 <bgamari> Enigmagic, Alright, we'll see what happens
18:19:46 <bgamari> Things get a bit hairy as the thing runs
18:20:10 <Enigmagic> bgamari: hairy = throwing exceptions for flow control?
18:20:11 <bgamari> The program sits at 80% memory usage on my laptop through most of its course before crashing
18:20:19 <Enigmagic> oic
18:20:24 <bgamari> let's just say the music isn't silky smooth
18:21:12 <bgamari> It seems like there hasn't been a whole lot of work in improving the stack overflow situation
18:21:35 <bgamari> ghc's profiler is very nice for space/time leaks
18:22:09 <bgamari> but it seems the existing tools are pretty much useless when it comes to stack overflows
18:22:14 <Polarina> I haven't found the profiler useful for what I've been doing.
18:22:28 <bgamari> Polarina, It depends
18:22:32 <bgamari> sometimes it's just too slow
18:22:38 <bgamari> although that has improved it seems
18:22:52 <cmccann> ok so if I have a newtype wrapper representing a "bottom" type
18:22:55 <cmccann> would "moon" be a reasonable name for the accessor to unwrap a Bottom value?
18:23:00 <cmccann> sounds legit to me
18:23:17 <RawProduce> haha
18:23:42 <Enigmagic> bgamari: one of these days i hope to have enough time to get stack walking working in gdb/lldb
18:23:43 <bgamari> Enigmagic, I guess the debug RTS is much slower than even the profiling RTS?
18:23:46 <RawProduce> foreplay is also a reasonable name
18:24:05 <Enigmagic> bgamari: yes, it's pretty slow. has asserts and whatnot just about everywhere.
18:24:13 <shachaf> The debug RTS is really slow if you turn on the full sanity checking mode.
18:24:42 <bgamari> shachaf, How does one avoid turning on the full sanity checking mode?
18:25:02 <bgamari> I just need debug symbols so I can observe the carnage after the crash
18:25:19 <Enigmagic> bgamari: really there is no need for the debug helper functions to be -debug only. you could probably copy the Printer.c file and compile it as a shared library
18:25:29 <shachaf> bgamari: That mode is an optional RTS flag, I think.
18:27:01 <Enigmagic> bgamari: really it'd be better if they were all in a debugger instead of in the host process. i was working on that for a while but lldb is broken on our linux boxes now so i haven't finished this thing either: https://github.com/alphaHeavy/ghc-lldb
18:27:43 <bgamari> that looks quite nice
18:27:51 <bgamari> Enigmagic, lldb is currently broken upstream?
18:28:07 <bgamari> I can compile lldb if not
18:28:30 <Enigmagic> bgamari: i think it works on ubuntu/rhel... i don't know if those script work with TOT though
18:28:39 * hackagebot list-extras 0.4.1.1 - Common not-so-common functions for lists  http://hackage.haskell.org/package/list-extras-0.4.1.1 (WrenThornton)
18:28:49 <bgamari> Enigmagic, TOT?
18:29:06 <Enigmagic> they're not finished anyways, i had to file a load of bugs against lldb and was planning on working on it again once they were fixed (they're fixed now)
18:29:22 <bgamari> I see
18:29:29 <Enigmagic> bgamari: sorry... lldb/llvm/clang-ism for "top of tree" = head revision
18:29:34 <bgamari> ahh
18:30:27 <Enigmagic> i'm not sure if we're running too new of a kernel or something else but i can't get lldb to attach to a process anymore
18:31:45 <bgamari> shachaf, I think the debug RTS enables some set of assertions always
18:31:56 <bgamari> then you can enable further assertions with command line options
18:32:10 <bgamari> don't see anything to disable them
18:32:11 <shachaf> bgamari: Yep.
18:32:28 <shachaf> One of them does a full heap traversal on every allocation or something ridiculous like that.
18:32:55 <bgamari> -DS I believe
18:33:03 <shachaf> "In particular, sanity checking runs a full scan of the heap to check for dangling pointers (amongst other things), before and after every GC."
18:33:06 <shachaf> Yep.
18:33:12 <shachaf> OK, at least it's not every allocation. :-)
18:33:40 <bgamari> Enigmagic, Is there a good reason why Printer.c isn't in the standard RTS?
18:34:23 <Enigmagic> bgamari: they'd be discarded by the linker
18:34:47 <Enigmagic> but even with some linker changes, i don't know why they're not
18:35:26 <Enigmagic> they do cause runtime access violations if used incorrectly which doesn't make them really useful for debugging
18:35:45 <Enigmagic> hence all that logic should be moved into a debugger instead
18:37:37 <bgamari> ahh
18:37:40 <bgamari> yep
18:39:32 <bgamari> ar
18:39:43 <bgamari> Enigmagic, How close are those scripts to completion?
18:39:48 <ddarius> @arr
18:39:48 <lambdabot> Avast!
18:40:29 <Enigmagic> bgamari: i don't know :-) lldb is a moving target and wasn't documented at all back then
18:40:42 <Enigmagic> and i didn't really know how all the GHC runtime stuff worked yet either
18:41:07 <Enigmagic> at the time it could dump out most objects
18:41:10 <bgamari> I think I'd rather get LLDB running and help move forward an approach which has some future use than waste several hours hacking together a mutant half-debug/halt-normal RTS
18:41:34 * bgamari 's poor SSD
18:41:42 <bgamari> fare well available disk space
18:42:40 <Enigmagic> if you can get a build of lldb working on your OS those scripts might still work without any/many tweaks
18:45:00 <Enigmagic> anyways i'm going to head home, i'll probably be online later if you get stuck
18:45:17 <shachaf> bgamari: What are you trying to do, anyway?
18:45:30 <bgamari> Enigmagic, Thanks!
18:45:49 <bgamari> shachaf, I have a nasty stack overflow
18:46:19 <bgamari> shachaf, I really don't see how the location pointed to by -xc could overflow
18:46:27 * shachaf smells a rat(hole)
18:46:50 <shachaf> bgamari: Where is it happening?
18:49:03 <bgamari> shachaf, https://github.com/bgamari/bayes-stack/blob/v2/BayesStack/Models/Topic/CitationInfluence.hs around line 112
18:49:10 <bgamari> shachaf, So thinks -xc
18:49:45 <johnw> bgamari: when you say, "around line 112", what do you mean by that?
18:49:52 <johnw> is that what the stack trace says?
18:49:55 <ddarius> bgamari: http://www.youtube.com/watch?v=J0c4L-AURDQ
18:50:12 <bgamari> shachaf, modify is working in the strict State monad
18:50:19 <shachaf> Hmm, is this something I can run?
18:50:31 <bgamari> john, The stacktrace says the culprit is randomInitCitedUU
18:50:38 <johnw> can you show me the track?
18:50:40 <johnw> trace?
18:50:44 <bgamari> shachaf, Probably
18:50:59 <johnw> and btw, that doesn'n mean the culprit *is* randomInitCitedUU
18:51:18 <johnw> it could just mean that randomInitCitedUU is the top of the thunk-evaluation chain that leds to your stack overflow
18:51:46 <johnw> sometimes, the function it happens in is completely unrelated to why your stack is overflowing
18:51:47 <bgamari> johnw, sure. give me a moment
18:52:07 <bgamari> ddarius, Thanks!
18:52:57 <johnw> what is calling randomInitialize?
18:53:20 <johnw> my first guess would be to understand what "d" is in your overflowing case
18:53:27 <alpounet> bgamari, mm, interesting stuffs you're working on
18:53:53 <johnw> ddarius: I just watched that last night :)
18:54:56 <johnw> bgamari: mapM_ (randomInitCitedUU d) (S.toList unset)
18:54:57 <bgamari> johnw, randomInitialize
18:55:07 <johnw> this is just a guess, but I think you should make this call strict
18:55:22 <johnw> I think you're building a *gigantic* monadic value
18:55:46 <shachaf> ?
18:56:15 <johnw> he's mapping randomInitCitedUU over a list, and that is itself creating new maps by insertion
18:56:17 <bgamari> johnw: You mean make it, mapM_ (randomInitCitedUU d) $! S.toList unset
18:56:18 <augur> !pl f
18:56:25 <augur> is it @pl?
18:56:34 <johnw> well, it's just a guess, so I wouldn't do anything just yet
18:56:35 <shachaf> augur: It's /msg lambdabot @pl, actually. :-)
18:56:47 <augur> shachaf: well yes, ive been doing that ;P
18:56:59 <augur> i just wanted to check whether it was a channel-specific feature or not
18:57:04 <augur> lambdabot has some of those, you know
18:57:07 <johnw> but when I see lots of mapping and creation of intermediaries without any strictness, I think "lots o' thunks"
18:57:23 <shachaf> bgamari: Bah, the dependencies don't build with GHC 7.6.
18:57:24 <johnw> it really depends on how large "d" is
18:57:27 <bgamari> johnw, my computer is now frantically thrashing so I should be close to having a stack trace ;)
18:57:39 <bgamari> shachaf, I've updated them all
18:57:52 <shachaf> Oh, maybe I just need to cabal update.
18:57:54 <bgamari> you'll find most of the git-based deps on on github
18:58:59 <bgamari> johnw, You are likely right
18:59:09 <bgamari> johnw, some fields of d are quite large
18:59:23 <bgamari> alpounet, Currently I'm just implementing some topic models
18:59:40 <johnw> then add strictness wherever the largeness of d would cause an explosion
18:59:53 <alpounet> that's still pretty fun bgamari
19:00:00 <bgamari> alpounet, But soon I'll hopefully be using this framework for doing experimental data analysis for my research
19:00:13 <shachaf> bgamari: How do I run the code?
19:00:37 <bgamari> alpounet, Definitely
19:00:37 <johnw> usually laziness avoids the need for that, but something you're doing is not lazy enough (probably it's strict in the spine, lazy in the body), so it needs to be strict throughout
19:00:39 <alpounet> bgamari, keep us posted about this (papers/blog posts)
19:00:45 <alpounet> well, me, at least
19:01:19 <bgamari> alpounet, well, there was this: http://people.cs.umass.edu/~dietz/delayer/dietz-cameraready.pdf
19:01:33 <ddarius> Okasaki's book and/or thesis makes a pretty compelling case that the interplay between eagerness and laziness can be subtle.
19:01:38 <SrPx> Any idea why this is happening? http://o7.no/Rml5AK (f x = x * x on tryhaskell.org not working) - I'm new to haskell
19:02:23 <tsou> SrPx: inside ghci use let
19:02:34 <shachaf> tsou: tryhaskell isn't ghci
19:02:34 <bgamari> johnw, ddarius; Yeah, these things are definitely tricky to get right
19:02:48 <shachaf> SrPx: If you type "help" it'll walk you through how tryhaskell works.
19:02:55 <bgamari> I was hoping that after a year of using haskell I'd be better at catching these
19:03:02 <SrPx> shachaf: http://o7.no/Rmli6R
19:03:07 <SrPx> wops, ok, let me see
19:03:13 <shachaf> Step 15, for example.
19:03:28 <bgamari> damn, the kernel just killed my process
19:03:32 <shachaf> You can't define things in tryhaskell.
19:03:39 <alpounet> bgamari, watch johan tibell's talk
19:04:23 <johnw> I think putting that $! where you suggested, and also in the correlative position in randomInitializeCiting, is what I'd try first
19:04:55 <johnw> though $! may be one level too shallow, since you are building a list of calls to fst
19:05:19 <johnw> you want those fst calls evaluated too
19:05:37 <johnw> since you're using mapM_, the actions should be consumed-as-you-go
19:06:09 <bgamari> Johnw, wouldn't a $! there just force the head of the list?
19:06:21 <johnw> yes
19:06:25 <johnw> $!! would do the trick
19:06:48 <johnw> the thing is, I think your list structure is being created in toto
19:06:50 <shachaf> deepseq :-(
19:06:50 <bgamari> but that would evaluate the entire list, then generate and execute the actions, no?
19:07:01 <johnw> but the items in the list are all thunks
19:07:06 <ddarius> DeepSeq and co. are unfettered evil.
19:07:36 <johnw> so $! may not even do anything meaningful there
19:08:11 <johnw> deepseq sometimes saves me from having to find exactly every place where seq is needed
19:08:17 <bgamari> arg
19:08:25 <johnw> even though it adds probably seq in lots of places where it's not
19:08:54 <benmachine> ddarius: not even a little bit fettered?
19:09:21 <bgamari> I just don't see what thunks are being generated
19:09:22 <shachaf> tharred and fettered
19:10:43 <johnw> your S.toList unset is a difference over two keysSets, which are list of fst calls over M.elems calls
19:11:05 <johnw> the question is whether than list being passed to mapM_ is something your program is comsuming lazily, or is it a giant thunk monster?
19:11:29 <bgamari> ahh
19:12:19 <johnw> shachaf: does mapM_ evaluate each f as it goes, or does it basically build a huge a >> b >> c chain and then evaluate it?
19:12:30 <shachaf> @src mapM_
19:12:31 <lambdabot> mapM_ f as = sequence_ (map f as)
19:12:35 <shachaf> @src sequence
19:12:35 <lambdabot> sequence []     = return []
19:12:35 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:12:35 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
19:12:36 <shachaf> @src sequence_
19:12:36 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
19:12:48 <johnw> so, it does call map, bummer
19:12:52 <shachaf> johnw: You can figure it out from that. :-)
19:12:54 <shachaf> Huh?
19:13:09 <johnw> mapM_ f as = sequence_ (map f as)
19:13:22 <shachaf> Yes, lambdabot said that.
19:13:25 <shachaf> Which part is the bummer?
19:13:26 <johnw> which means I have [m a]
19:13:38 <rwbarton> that doesn't mean you have it all at the same time
19:14:04 <johnw> unless the spine of the list is strict, right?
19:14:09 <shachaf> It's not.
19:14:12 <johnw> ah, ok
19:14:17 <johnw> then unbummer
19:14:19 <rwbarton> because it is just a normal list
19:14:25 <ddarius> You can mapM_ over an infinite list.
19:14:39 <ion> mapM_ print [0..]
19:14:41 <johnw> i saw him having a huge list of modify $ M.insert thunks over d
19:14:46 <johnw> but that's not where the problem is
19:15:05 <shachaf> "a huge list" isn't a problem if it's lazy.
19:15:10 <johnw> oh, wait a minute...
19:15:11 <bgamari> I'll have a full stack trace in a moment
19:15:13 <johnw> he's using modify!
19:15:23 <johnw> so his mapM_ is building up a lazy state value
19:15:29 <shachaf> ?
19:15:47 <johnw> mapM_ doesn't return a value, but the monad it's running in is accumulating a series of state changes via modify, right?
19:15:47 <SrPx> So, is there any haskell repl more complete than try haskell?
19:15:58 <bgamari> johnw, It's a strict state monad
19:15:59 <shachaf> Yes, ghci.
19:16:04 <johnw> oh, I missed that part
19:16:28 <SrPx> It must be online
19:16:40 <ion> ssh to a server with ghci
19:16:40 <SrPx> none, I guess ? :/
19:16:43 <johnw> shachaf himself is sometimes a fair approximation to ghci
19:17:18 <johnw> I should get my ghci to just print ":(" whenever I use flip or deepseq
19:17:25 <shachaf> johnw: You mean the "subtly insults you with incomprehensible error messages" part?
19:17:29 <johnw> lol
19:17:46 * shachaf doesn't actually insult.
19:17:57 <shachaf> And ghci's error messages are pretty good.
19:18:02 * ddarius actually insults.
19:18:13 <ion> :set -finsults
19:18:16 <shachaf> I could make a special case for SrPx.
19:18:24 <shachaf> I once got banned from a channel for insulting SrPx.
19:18:32 <johnw> which channel?
19:18:40 * hackagebot word8 0.0.2 - Word8 library  http://hackage.haskell.org/package/word8-0.0.2 (KazuYamamoto)
19:18:45 <shachaf> #stackoverflow
19:18:55 <johnw> didn't even know they had a channel
19:19:07 <shachaf> They don't.
19:19:15 <SrPx> What?
19:19:19 * ddarius wonders if one really needs Terrence Tao to show that you can represent a signal that's well represented in some (known?) basis by less samples than the Nyquist rate would require.
19:19:27 <SrPx> Really? Why did you insult me?
19:19:32 <shachaf> I didn't.
19:20:01 <johnw> a coinsult would be SrPx insulting you, right?  Or would it be praise of SrPx?
19:20:31 <SrPx> SrPx insulting someone won't happen too soon
19:20:46 <johnw> the dual of jealousy is envy
19:21:06 * ddarius awaits proofs flowing from shachaf's fingers.
19:21:13 <shachaf> ddarius: Proofs of what?
19:21:33 <dolio> Small, complete categories are cocomplete.
19:21:38 <shachaf> Oh, yes.
19:21:45 <shachaf> I'm too busy procrastinating on writing an email!
19:21:53 <ddarius> Me too.
19:21:59 <johnw> i'm procrastinating *big time* on deconstructing some furniture
19:22:06 <johnw> i've been successfully not-doing it for 7 hours now
19:22:09 <shachaf> I've been procrastinating on this email for over a month.
19:22:12 <johnw> oh wow
19:22:14 <ddarius> When did Euler live?
19:22:19 <johnw> I once took 7 years to answer an e-mail
19:22:28 <johnw> _and it was on my todo list the whole 7 years_
19:22:46 <hpaste> ‚ÄúBen Gamari‚Äù pasted ‚ÄúStack overflow, oh no!‚Äù at http://hpaste.org/75422
19:22:47 <ddarius> Okay.  He lived about when I thought.
19:22:52 <ddarius> Complex analysis is old.
19:23:00 <bgamari> Stack overflow backtrace: http://hpaste.org/75422
19:23:16 <johnw> you have only 8M of stack?
19:23:21 <johnw> how big is "d"?
19:23:31 <jmcarthur> bgamari: this is a common symptom of insufficient strictness of an accumulator
19:23:55 <bgamari> johnw, but why is the stack even growing?
19:23:57 <johnw> jmcarthur: but his accumulator is in the strict state monad
19:23:59 <jmcarthur> oh this is ongoing
19:24:13 <ddarius> Venkataramani has an surfeit of 'a's.
19:24:14 <bgamari> jmcarthur, yes, it's in principle strict
19:24:17 <jmcarthur> i didn't realize there was already some history about this here
19:24:27 <rwbarton> the strict state monad is not as strict as one might think
19:24:36 <jmcarthur> this is the code? http://hpaste.org/75411
19:25:05 <bgamari> rwbarton, Yes, apparently
19:25:09 <shachaf> I heard the so-called "strict state monad" lets you use a city instead of a state.
19:25:12 <shachaf> Some "strictness".
19:25:36 <bgamari> jmcarthur, https://github.com/bgamari/bayes-stack/blob/v2/BayesStack/Models/Topic/CitationInfluence.hs#L111
19:25:40 <johnw> bgamari: how big is the value t'?
19:25:43 <johnw> because you don't evaluate it
19:25:57 <bgamari> johnw, Just an Int
19:26:07 <johnw> well, it's not being evaluated by M.insert, is it?
19:26:12 <bgamari> johnw, I suppose not
19:26:21 <johnw> try making that M.insert call strict
19:26:24 <bgamari> alright
19:26:29 <johnw> M.insert in $! t'
19:26:38 * shachaf smells a dead chicken.
19:26:39 <johnw> s/in/ni
19:26:43 <johnw> a dead chicken?
19:26:46 <shachaf> Yes.
19:26:52 <johnw> hmm... what does that mean?
19:26:56 <johnw> did a chicken die at your house?
19:27:02 <rwbarton> "modify $ M.insert ni t'" => if your old state was s your new state is M.insert ni t' s, not evaluated
19:27:33 <johnw> rwbarton: even in the strict state monad?
19:27:42 <rwbarton> i am about 90% sure
19:27:47 <johnw> that could be it, then
19:28:00 <rwbarton> if you want that kind of strictness you need something like modify' f = do { s <- get; put $! f s }
19:28:25 <johnw> what about modify $!?
19:28:26 <bgamari> it's certainly worth a try
19:28:29 <rwbarton> the lazy strict monad differs in that it doesn't even do operations that are unneeded to obtain the final state
19:28:33 <rwbarton> johnw, not good enough
19:28:37 <bgamari> johnw, that would just evaluate the lambda, no?
19:28:47 <johnw> ah, yes
19:28:53 <rwbarton> M.insert ni t' is an unsaturated function application, forcing it can do nothing
19:28:56 <rwbarton> (I presume)
19:29:17 <johnw> what is an "unsaturated function application"?
19:29:18 <jmcarthur> yeah modify is indeed non-strict in the state
19:29:32 <jmcarthur> modify f = state $ \s -> ((), f s)
19:29:41 <rwbarton> well I mean insert is defined as insert key val map = ... (or pattern matching on map)
19:29:43 <johnw> so then my original thought that mapM_ would building a big chain of thunks wasn't too far off
19:29:52 <johnw> (thunks in the state, not in the value)
19:29:56 <rwbarton> as opposed to insert key val = (... some expression which evaluates to a lambda ...)
19:30:14 <johnw> rwbarton: oh, I see what you mean
19:30:18 <johnw> it's a partial application
19:30:36 <Cale> It is possible for evaluating partial applications to do work
19:30:42 <rwbarton> I really just mean, M.insert ni t' is manifestly already of the form \map -> ...
19:30:44 <Cale> In this case, probably not though.
19:30:45 <rwbarton> right
19:30:47 <rwbarton> right
19:31:04 <johnw> to which s is applied, but since the put isn't strict, you just end up with an ever-deeper lambda chain
19:31:11 <bgamari> blarg
19:31:31 <rwbarton> > runState (do { undefined; put 3 }) 1
19:31:32 <lambdabot>   ((),3)
19:31:35 <bgamari> it would be really nice is there were a better explanation in the documentation of what exactly is meant by "strict"
19:31:37 <rwbarton> ^ lazy state monad
19:31:48 <johnw> bgamari: shachaf is good at defining it
19:31:53 <johnw> bgamari: he really helped me
19:32:00 <rwbarton> > Control.Monad.State.Strict.runState (do { undefined; put 3 }) 1
19:32:01 <lambdabot>   Not in scope: `Control.Monad.State.Strict.runState'
19:32:10 <shachaf> Defining what?
19:32:14 <rwbarton> well you can try in ghci, it diverges
19:32:26 <johnw> key was getting the difference between normal form, head normal form, weak head normal form, and undefined
19:32:28 <bgamari> not only like "strict in the state", but also examples of which sort of uses are safe and which are not
19:32:30 <johnw> shachaf: strictness
19:32:31 <jmcarthur> i dislike the term "partial application". functions only have one argument in haskell anyway. applications are just applications. i guess i could see using "partial application" to mean something about how a specific implementation might work, though
19:32:40 <shachaf> Oh, "strict". I can say what a "strict function" is, because that's well-defined. But a module called Foo.Bar.Strict could mean anything.
19:32:43 <johnw> jmcarthur: that is a good point, actually
19:32:44 <shachaf> Well, lots of things.
19:32:52 <rwbarton> yes, ghc has a notion of "function arity"
19:33:17 <rwbarton> knowing that if I pass only two arguments to a function of arity 3 this can cause no evaluation yet
19:33:24 <rwbarton> but it's an implementation-specific thing in a sense
19:33:43 <bgamari> even the presence of a function in modify' in Control.Monad.State would be helpful as it would suggest that there is a strict-er operation
19:33:44 <johnw> so saturation means, the function application will result in a value that is not a function?
19:34:01 <ddarius> jmcarthur: I concur for the most part (and tend to be pretty aggressively vociferous about this), but I have provided, at one point, a possible denotational definition of "partial application".
19:34:03 <rwbarton> it means the function application will result in some kind of reducible expression
19:34:13 <rwbarton> Also, I just made up that word
19:34:13 <jmcarthur> ddarius: oh
19:34:15 <jmcarthur> ?
19:34:16 <johnw> reducible = evaluable?
19:34:29 <ddarius> rwbarton: Which word?
19:34:30 <jmcarthur> *oh?    is what i meant...
19:34:42 <rwbarton> unsaturated
19:34:55 <ddarius> I'm pretty sure that's a word.
19:34:58 <rwbarton> I hope but am not sure that it is fairly standard
19:35:04 <johnw> unsaturated is quite common
19:35:08 <johnw> "unsaturated fats"
19:35:12 <rwbarton> and that it means what I want it to mean :)
19:35:18 <johnw> ah
19:36:11 <rwbarton> johnw: reducible as in something other than a lambda-expression, such as a function application or a case expression
19:36:20 <bgamari> here it goes
19:36:23 <johnw> ok, I think I get you
19:36:29 <johnw> bgamari: are you use hp2ps too?
19:36:29 <jmcarthur> johnw: i think what rwbarton means is that saturation means that the function application can perform actual work when evaluated
19:36:48 <johnw> it will help you see how quickly the stack is being consumed, and whether it happens all up-front, or "as it goes"
19:36:56 <rwbarton> *though* i'm pretty sure that ghc's notion of arity is just defined by how many arguments are on the left hand side of the =
19:36:57 <ddarius> jmcarthur: (f x) is a partial application iff f x == (curry (uncurry f) x)
19:37:01 <bgamari> shachat, jmcarthur, johnw, rwbarton, et al, Thanks again for your help
19:37:08 <ddarius> jmcarthur: http://lambda-the-ultimate.org/node/2266#comment-33620
19:37:11 <johnw> shachat!
19:37:20 <johnw> it sounds like the name of a french cat
19:37:24 <johnw> Le Sha Chat
19:37:46 <rwbarton> btw if you encounter the same problem with Writer I'm not sure what you are supposed to do
19:38:38 <johnw> bgamari: let us know if/when/how you fix it!
19:39:01 <johnw> I'm very eager to improve my stack-space-optimizing skills
19:39:05 <rwbarton> aside from switch to a State monad I guess
19:40:17 * cmccann recalls that writing a function with a reduced syntactic arity that returns a function defined in a where clause or such can change performance characteristics under GHC
19:40:41 <rwbarton> I would believe that
19:41:37 <rwbarton> well in general that could affect sharing behavior too, if there are other bindings in the where clause that depend on function arguments
19:41:51 <rwbarton> they won't be recomputed if the "inner lambda" is entered multiple times
19:41:52 <cmccann> yes
19:41:59 <shachaf> Even "(.) f g x = f (g x)" vs. "(.) f g = \x -> f (g x)" can make a difference in GHC, I understand.
19:42:04 <cmccann> that's the part that matters, as far as I know
19:42:40 <cmccann> there might be other differences but sharing stuff defined in terms of fewer arguments is the main thing that I know of
19:42:45 <bgamari> rwbarton, I believe I actually encountered this problem on Writer earlier today
19:43:07 <shachaf> cmccann: That one isn't even GHC-specific -- I'd expect that behavior from any lazy implementation.
19:43:20 <bgamari> rwbarton, there must be a way to improve this situation
19:43:36 <rwbarton> I think MonadLib(?) had even stricter monads
19:43:37 <cmccann> it's GHC-specific in that I don't think any compiler, GHC included, is obligated to behave in any particular way
19:43:47 <bgamari> I know for a fact that this isn't the first time I've wasted several man-hours of folks on #haskell due to misunderstanding strictness of mtl/transformers
19:43:59 <cmccann> it would be legal to apply or remove that transformation as an optimization
19:44:03 <bgamari> I guess the place to discuss it is probably libraries@ though
19:44:20 <jmcarthur> ddarius: it seems to me that that definition only makes sense for certain evaluation strategies
19:44:50 <jmcarthur> although i guess this just wraps back around to the fact that partial application is tied to that anyway
19:44:58 <jmcarthur> hmm... so maybe that is a good definition...
19:45:01 <ddarius> jmcarthur: It's a denotational definition.  Evaluation strategy is irrelevant.  It certainly won't, in general and in many cases, mean what people think it means.
19:45:06 <rwbarton> yeah. newtype WriterT i m a = W { unW :: m (P a i) }
19:45:06 <rwbarton> data P a i = P a !i
19:45:09 <ddarius> It also greatly depends on the semantics of your language.
19:45:11 <jmcarthur> i see
19:45:35 <ddarius> In a total language curry . uncurry = id and so all applications are "partial applications" rendering the term completely devoid of meaning there.
19:45:50 <ddarius> (Other than the type constraints implied.)
19:46:14 <ddarius> In Haskell, curry . uncurry /= id, but mainly because of bottom and seq, so the term is mostly meaningless.
19:46:18 <jmcarthur> so i take it that it's intended to be a proposed definition, not one that specifically matches all existing notions of what it means
19:46:41 <ddarius> In ML, curry . uncurry -really- does not equal id and the definition has a fair amount of import.
19:46:51 <shachaf> ddarius: Because of effects?
19:47:17 <ddarius> jmcarthur: Yes, it's a proposed definition that is observable.
19:47:59 <ddarius> shachaf: Yes.
19:49:01 * cmccann proposes to define "partial application" as "any function application such that, if you call it 'partial application' in #haskell, ddarius won't care enough to argue the point".
19:49:27 <shachaf> cmccann: So there's no such thing as partial application?
19:50:16 <jmcarthur> i have already proposed that there is no such thing :D
19:50:52 <cmccann> I think #haskell is the only place I've ever seen debates about terminology that were actually interesting.
19:50:57 <shachaf> roconnor's slides from last week: http://r6.ca/TypeTheory/BAHUG2012.pdf
19:51:08 <shachaf> Hmm, maybe they're not very useful on their own.
19:51:15 <bgamari> johntromp, Things look good I think
19:51:41 <bgamari> It seems the modify' did the trick
19:52:49 <rwbarton> I see we have Data.Map.Strict.fromListWith now at least, that's an improvement
19:57:01 <rwbarton> put' and modify' could go in an external library using the normal State monad types
19:57:18 <rwbarton> since they can be defined in terms of the MonadState methods
19:57:33 * edwardk waves hello.
19:57:39 <shachaf> hellodwardk
19:57:42 <rwbarton> Writer seems to be trickier
19:59:35 <rwbarton> you can write a tell' for WriterT easily enough, but then how do you fit it into the whole MonadWriter/monad transformer system
20:00:13 <shachaf> You can use a strict mappend, presumably.
20:00:19 <shachaf> (But then you have to use it everywhere.)
20:00:26 <rwbarton> no because nothing is forcing the result of the mappend
20:00:48 <shachaf> Oh, right. I see what you mean. It's just building it up.
20:01:09 <rwbarton> you want a mapM_ tell' to work like a foldl', yeah
20:01:41 <rwbarton> I guess you could introduce a MonadWriterStrict class but that would be really gross since you'd have to add an instance every time mtl gets a new transformer
20:02:11 <shachaf> Well, the whole mtl system is really gross. :-(
20:04:59 <rwbarton> for the same reason you can't add a tell' method to MonadWriter without breaking anyone who defines a monad transformer
20:06:18 <shachaf> Is there really no non-n^2 system for monad transformers?
20:07:02 <ddarius> Various ideas have been proposed but they tend to be either unpleasant to use or incomplete.  Furthermore, there aren't that many basic transformers.
20:07:40 <rwbarton> you could just make tell strict and hope it improves more code than it breaks ;)
20:07:59 <shachaf> rwbarton: Let's do that with foldl!
20:08:10 <rwbarton> Eh... yeah.
20:08:13 <rwbarton> when you put it that way...
20:08:14 <shachaf> Nobody would even notice.
20:08:22 <dmwit> shachaf: I just finished reading "lightweight monadic programming in ML", which you may also be interested in.
20:09:18 <ddarius> shachaf: I think there would be a noticeable improvement.
20:09:47 <ddarius> I would be extremely unsurprised if all code on Hackage exhibited the same or better behavior in all realistic usage.
20:10:39 <shachaf> Might as well go all the way and make the language strict.
20:10:42 <rwbarton> and tell isn't even part of any standard
20:11:32 <ddarius> shachaf: That would definitely break most of the code on Hackage.
20:13:23 <ddarius> Excessive laziness is a common problem in older and/or poor Haskell code including the standard libraries.  After that is excessive strictness.
20:18:03 <rwbarton> I wonder how many packages on hackage use foldl at all
20:18:29 <rwbarton> I guess sum is probably fairly common
20:18:43 <shachaf> A quick search shows quite a few instances.
20:19:00 <shachaf> 116 uses in 104 packages I happen to have extracted.
20:19:14 <shachaf> (Not uniform at all, of course.)
20:19:35 <rwbarton> given that foldl' exists and foldl vs. foldl' is a standard subject in haskell education one might hope that a use of foldl affords some presumption that the author perhaps really wanted foldl rather than foldl'
20:19:49 <rwbarton> whereas tell' doesn't exist
20:20:01 <shachaf> 2 accelerate-0.12.1.0 1 aeson-0.6.0.2 18 Agda-2.3.0.1 6 base-4.6.0.0 5 bytestring-0.9.2.1 1 Cabal-1.14.0 3 cabal-install-0.10.2 17 containers-0.5.0.0 2 cuda-0.4.1.0 2 data-accessor-0.2.2 1 data-lens-template-2.1.2 4 djinn-2011.7.23 1 haskeline-0.6.4.6 2 haskell2010-1.1.0.0 3 HTTP-4000.1.1 5 lambdabot-4.2.3.2 1 language-c-0.4.2 2 lenses-0.1.4 1 linux-ptrace-0.1.2 3 MissingH-1.1.1.0 5 monad-par-0.1.0.1 1 numbers-3000.0.0.0 1 parsers-0.2 1 ...
20:20:07 <rwbarton> agda, really
20:20:07 <shachaf> ... recursion-schemes-2.0 1 snap-core-0.5.3.1 2 template-haskell-2.6.0.0 4 text-0.11.1.3 2 transformers-0.3.0.0 1 trifecta-0.53 3 uniplate-1.6 1 unix-2.4.2.0 11 vector-0.9.1 2 xmonad-contrib-0.9.2 1 yesod-core-0.8.2
20:20:35 <shachaf> Agda programmers know the value of everything and the cost of nothing.
20:20:45 * shachaf suspects the "base" instances of foldl don't really count...
20:21:05 <ddarius> I haven't seen a compelling use of foldl ever.  I've seen uses where it is no worse than foldl', maybe very slightly better do to not having extraneous seqs, but not one where it is necessary or significantly better.
20:21:19 <shachaf> The wiki has a contrived example.
20:21:32 <ddarius> Yes.  I contrived that example.
20:21:40 <ddarius> (Actually, I don't know what's on the wiki now.)
20:22:10 <shachaf> "foldl (?) 1 [2,3,undefined,5,0]"
20:22:30 <ddarius> Okay, that's similar but even more contrived than the example I contrived.
20:22:59 <shachaf> What was yours?
20:22:59 <ddarius> Though presumably (?) is defined and that is executable whereas mine was a sketch, though easy to make executable.
20:23:19 <rwbarton> what's (?), a ? b = b or something?
20:23:23 <shachaf> Was yours "a Num instance with special optimizations"?
20:23:32 <shachaf> Such as x * 0 = 0
20:23:36 <cmccann> the most compelling use of foldl I've seen is as a teaching tool, for demonstrating how laziness can be important.
20:23:36 <ddarius> Yes.
20:23:39 <shachaf> I remember that.
20:24:33 <shachaf> (?) is exactly that function, actually.
20:24:45 <ion> I think i‚Äôve seen (?) defined as (a ? b) True = a; (a ? b) False = b somewhere.
20:24:54 <ddarius> Okay, then it's my contrived example.
20:25:07 <shachaf> > foldl' (flip const) 0 [1,2,undefined,3,4]
20:25:09 <lambdabot>   *Exception: Prelude.undefined
20:25:10 <shachaf> > foldl (flip const) 0 [1,2,undefined,3,4]
20:25:12 <lambdabot>   4
20:25:17 <ion> But it‚Äôs something else in this case.
20:25:17 <ddarius> ion: Usually it's (True ?) = fst; (False ?) = snd
20:25:47 <ion> ddarius: I like the other one more. :-P
20:30:51 <ion> Hmm, swap the True and False, actually. That would match bool, which would match maybe/either.
20:31:15 <shachaf> What about matching if?
20:31:45 <cmccann> "if" has the order of constructors backwards for some bizarre reason.
20:31:51 <ion> bool > if
20:32:05 <shachaf> The reason isn't very bizarre.
20:32:21 <cmccann> @src Bool
20:32:21 <lambdabot> data Bool = False | True deriving (Eq, Ord)
20:32:26 <cmccann> @src Maybe
20:32:26 <lambdabot> data Maybe a = Nothing | Just a
20:32:29 <cmccann> :t maybe
20:32:30 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:32:41 <ion> bool :: a -> a -> Bool -> a
20:33:02 <cmccann> the arguments to maybe match the order of constructors
20:33:04 <cmccann> @src []
20:33:04 <lambdabot> data [] a = [] | a : [a]
20:33:07 <cmccann> :t foldr
20:33:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:33:21 <shachaf> dmwit: ezyang might be interested in that paper.
20:33:23 <cmccann> foldr is also weird. :[
20:38:42 * hackagebot aws-sdk 0.1.0.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.1.0.0 (YusukeNomura)
20:38:55 <ddarius> Google is exactly half as old as me.
20:39:43 <cark> i'm having trouble with the makeLabels macro of HList
20:40:03 <cark>     Multiple declarations of `Foo
20:40:25 <shachaf> ddarius: 1984-10-02?
20:43:41 <ion> > select date 'now' - 2 * (date 'now' - date '1998-09-04');
20:43:42 <lambdabot>   <no location info>:
20:43:42 <lambdabot>      lexical error in string/character literal at chara...
20:43:44 <ion>  1984-08-10
20:44:35 <cark> I want to declare a Table abstraction, and be able to access the data inside it by different indexes, which are only thin wrappers around M.Map. My problem is that I need to have those indexes in a list, while still being able to query these. is HList the solution for that, or are there other means ?
20:45:35 * ddarius is not actually sure how Google decides it's birth date.
20:45:55 <ion> I looked up the ‚Äúfounded‚Äù date on Wikipedia.
20:46:04 <ddarius> The incorporation is listed as "September 4, 1998" on the site.
20:46:06 * cmccann would expect HList to be painfully obsolete these days.
20:46:09 <shachaf> ion: I looked up the cake on google.com
20:46:50 <applicative> cark I see the error, it's hilarious.  Something has changed in TH evidently
20:47:12 <cmccann> HList was always a huge, horrendous hack and now most of the tricks it used are superfluous because of new features in GHC. :T
20:47:12 <cark> =(
20:47:44 <ew0> man, I just traded 300 lines of python code by a massive 5 line foldr
20:47:56 <ew0> and it works!
20:48:06 <ion> ew0: Pastebin both
20:48:14 <cark> cmccann: allright ! that's what i want to hear =) so how could i keep heterogeneous types in a container, and still use these ?
20:48:19 <ew0> can't paste the python
20:48:24 <ew0> jsut a sec
20:48:58 <cark> specifically i can't query my indexes if I use existential types, or dictionaries
20:49:22 <cark> should i investigate generics more ?
20:49:36 <cmccann> cark, I'm actually not sure, I haven't had time to look at several newer extensions GHC added.
20:50:09 <cmccann> I'm also not sure exactly what you're doing with HList, if memory serves me it had a whole bunch of different things tossed in there
20:51:04 <hpaste> ew pasted ‚Äúfsm‚Äù at http://hpaste.org/75423
20:51:11 <cark> cmccann:  well, my indexes are of type (Index r k), and the idea was to have a bunch of these in a traversable structure
20:51:32 <cmccann> but really the core idea is having something like nested tuples to be a "list", along with some sort of trickery to allow manipulating those tuples recursively &c.
20:51:49 <cark> right
20:52:10 <cark> so you're saying i could roll my own ?
20:52:58 <ion> ew0: Needs more empty lines and comments. :-)
20:53:03 <cmccann> so if all you're doing something like walking down a sequence of nested tuples looking for certain pre-defined types that's almost certainly far easier to do with newer extensions than when HList was created
20:53:09 <ew0> =D
20:53:14 <cmccann> and the datakinds stuff might make the whole thing completely superfluous, I'm not sure
20:53:23 <ew0> it took me forever to compile
20:53:58 <ion> ew0: case foo of { Nothing -> bar; Just baz = baz } = fromMaybe bar foo
20:54:09 * cmccann has not had the chance to play with datakinds much at all :[
20:54:39 <ew0> yeah, hpaste already told me that xD
20:54:43 * cmccann likes to define (??) = flip fromMaybe
20:54:46 <cark> the thing is, I can't be just looking for a specific type while navigating my tupples as I could have two indexes with the same type for different fields of my record
20:55:16 <applicative> 'hlists' are one of the examples in the docs for DataKinds http://www.haskell.org/ghc/docs/latest/html/users_guide/promotion.html
20:55:20 <cark> so i need labels, and that's where this gets hairy for newbie me
20:55:27 <shachaf> ion: You're almost as useful as hlint! :-)
20:55:34 <rwbarton> hlint is pretty amazing
20:55:49 <cmccann> cark, you should probably look at the datakinds stuff that applicative kindly linked to
20:55:53 <ddarius> cmccann likes C#.
20:56:03 <cmccann> and see how much of what you need is already there.
20:56:10 <cark> I will, thanks both of you =)
20:56:14 <cmccann> ddarius, it's a useful idiom!
20:57:14 <lispy> What are people using for matrices? I'm especially interested in 2x2,3x3, and 4x4.
20:57:22 <lispy> Do you roll your own? use hmatrix? something else?
20:57:26 <cmccann> what are you doing with them?
20:57:37 <shachaf> Tuples!
20:57:43 <cmccann> if you need to crunch numbers in ways that hmatrix can do, that's a pretty safe choice I expect
20:57:43 <lispy> I'm doing graphics, so that's why 4x4 is really all I need.
20:58:03 <cmccann> if you just need to store them in order to e.g. feed stuff to OpenGL then I dunno
20:58:12 <shachaf> Accelerate! Do it on the GPU!
20:58:13 <lispy> I use hmatrix at work because I needed to take determinants of larger matrices and it seemed fast and accurate
20:58:37 <cmccann> hmatrix is an FFI binding to the same libraries everyone else uses for that stuff
20:58:41 <lispy> cmccann: OpenGLRaw can pass Ptr CInt, IIRC
20:58:50 <cmccann> most of which are in Fortran or something, hahaha
20:59:19 <lispy> I've thought about using Data.Vector and slapping a newtype + indexing operations on the front
20:59:35 <cmccann> well, I was assuming you wanted something more convenient to work with before feeding them to opengl
20:59:38 <lispy> What I use now is just an unpacked representation with a lot of arguments to the data constructor
20:59:54 * cmccann needs to finish his geometric algebra nonsense at some point
21:00:10 <lispy> I'm asking because I may have overlooked something
21:00:11 <cmccann> gotta stop being distracted by this frivolous linear logic tinkering :T
21:00:51 <cmccann> well, I'd expect you can't go too wrong with an unpacked vector
21:00:54 <ion> > (???)
21:00:56 <lambdabot>   WTF
21:01:06 <lispy> I wonder how fast hmatrix is for tiny matricies
21:02:11 * ddarius should one day actually buy a lot of quality books on subjects he is interested in rather than putting things together from a variety of disparate resources.
21:03:43 <carter_> in other news: ghc-mod has now been patched up for 7.6! :)
21:04:07 * cmccann has always found it difficult, as something of an autodidact, to learn how to learn things in a more structured way.
21:05:02 <carter_> lispy: it should be fast enough
21:05:23 <lispy> ddarius: I find the ipad works well for that. I store my ebooks in there and it keeps me from needing to buy lots of book shelves :)
21:05:23 <carter> and theres some pending work to make the core bits bsd rather than gpl
21:05:27 * cmccann suspects that hmatrix is usually going to be "fast enough" for almost anything you throw at it
21:05:36 <carter> cmccann fact
21:05:36 <ddarius> lispy: It's not a storage problem.
21:05:43 <carter> plus alberto is a loverly dude
21:05:46 <carter> *lovely
21:05:47 <lispy> ddarius: It can be for me
21:05:48 <carter> super nice
21:06:04 <lispy> carter: do you use dvorak?
21:06:16 <carter> lispy: no i just make funny typoes when i'm tired :)
21:06:35 <lispy> carter: on dvorak l and r are side by side
21:06:42 <carter> haha
21:06:44 <ion> e and r are next to each other in qwerty.
21:06:54 <carter> lispy: I just make interesting typoes when tired
21:07:17 <carter> lispy: you may have fun trying out the SIMD prim ops on the simd ghc branch
21:07:29 <carter> or playing with that once they get merged in
21:07:56 <lispy> I don't have performance problems at the moment, but this is a ray tracer
21:08:05 <lispy> So given the right scene it will have them :)
21:08:24 <carter> lispy: then jsut use accelerate + a CUDA card
21:08:30 <lispy> (The reason I don't have them now is that it's a sandbox for me to learn how ray tracers work)
21:08:35 <ddarius> lispy: The solution at that point would probably be to improve the algorithm.
21:08:55 <ddarius> Though you can do cool stuff with SIMD and coherent beam tracing.
21:09:15 <lispy> ddarius: even with good algorithms ray tracers get bogged down on interesting scenes.
21:09:16 <ddarius> And eventually memory hierarchy issues become the largest problem.
21:09:40 <ddarius> lispy: You can always make a scene that will be slow.
21:10:08 <lispy> I'm not yet to the point of stochastic tracing methods, but eventually
21:10:14 <lispy> I only work on it a few hours a month
21:10:23 <ddarius> That said, even naive raytracers go reasonably fast nowadays.
21:10:40 <carter> lispy: on the memory hiearchy side there some cool tools that are semi proprietary that i'll be rolling out in a few months
21:10:53 <carter> to make HPC haskell code easier to write
21:11:11 <carter> though some pieces i'll hopefully also get merged into the corresponding / related open source libs
21:11:12 <lispy> carter: are you an academic? industry person? or ?
21:11:19 <carter> lispy: both :)
21:11:31 <ddarius> He's the elusive industrious academic.
21:11:53 <carter> i'm doing a bit of consulting + i'm building some tools on top of haskell for industrial use that have some fun research challenges in their making
21:11:55 <lispy> if you have papers or links send them my way. We have a guy that does HPC and he would find haskell HPC interesting.
21:11:57 <carter> ddarius: if only
21:12:07 <carter> i'm never nearly as industrious as I'd like
21:12:13 <carter> and offen quite lazy
21:12:29 <carter> though i'm pleased with the ghc-mod package patching I helped with :)
21:12:36 <carter> simple as that wee bit of effort was
21:13:04 <carter> ddarius: you were at hacphi right?
21:13:15 <carter> my name <--> handle skils are weak
21:13:50 <carter> my (   ... <-->   ....)
21:13:55 <carter> operator precidence
21:14:42 <ddarius> carter: No, I was at a wedding when HacPhi was going on.
21:14:48 <ion> open(my $fh, '<', 'foo')
21:14:54 <carter> lispy: you may want to ask edwardk when hes around about ray tracers
21:15:02 <carter> he knows sooooo much
21:15:05 <edwardk> lispy and i have talked raytracing
21:15:05 <carter> its breath taking
21:15:06 <shachaf> carter: Were you at HacBoston?
21:15:12 <carter> shachaf: yesss
21:15:18 <carter> edwardk: hello!
21:15:28 <shachaf> Oh, did I meet you there?
21:15:39 <carter> shachaf: i'm the loud dude :)
21:15:44 <shachaf> edwardk?
21:16:01 <shachaf> ddarius was the person who didn't mug me.
21:16:15 <lispy> I think edwardk is working on path tracing. I haven't yet leveled up to path tracing.
21:16:25 <lispy> But our discussion was interesting
21:17:11 <edwardk> variations on metropolis light transport in particular
21:18:14 * lispy doesn't get why mwc-random does everything in PrimState
21:18:35 <lispy> It's actually kind of annoying when you want randomness in pure code
21:20:05 * ddarius vaguely recalls some of the details of the ray tracing algorithm Ed and I talked about.
21:21:24 <alpounet> mersenne-random-pure64 then, maybe?
21:22:53 <startling> what the hell do MonadWriter's "listen" and "pass" do?
21:22:54 <lispy> ah, this is the source of it:
21:23:02 <lispy> -- | State of the pseudo-random number generator.
21:23:03 <lispy> newtype Gen s = Gen (M.MVector s Word32)
21:23:23 <lispy> :t listen
21:23:24 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
21:23:30 <edwardk> ddarius: it evolved quite a bit from there
21:23:55 <ddarius> lispy: You should be able to use unsafeInterleaveIO/ST to get an infinite stream if you so desire.
21:24:08 <startling> lispy, I see the type but I don't understand the semantics
21:24:12 <lispy> startling: From the type it looks like listen lets you peek at the value you are writing"
21:24:37 <ddarius> It lets you peek at the value someone passed to you (it) is writing.
21:25:28 <lispy> :t pass
21:25:29 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
21:25:32 <ddarius> A lot of the operations in MonadWriter are rather adhoc.
21:26:08 <lispy> I'm not sure what pass does, but I guess it transforms the thing you are writing.
21:26:21 <cmccann> note that all these operations that seem to inspect the value being "written" take a pre-existing Writer value as input
21:27:32 <ddarius> edwardk: Compressed Sensing seems interesting.
21:27:53 <startling> oh wait. so listen makes writing go to the output rather than the written state?
21:27:56 <startling> or does it do both?
21:28:35 <edwardk> ddarius: like http://dsp.rice.edu/cscamera ?
21:28:43 * hackagebot wxturtle 0.0.1 - turtle like LOGO with wxHaskell  http://hackage.haskell.org/package/wxturtle-0.0.1 (YoshikuniJujo)
21:28:48 <ddarius> edwardk: Yes.
21:29:26 <carter> compressed senssing stuff is really neat
21:29:49 <Puffton> Hello, dear friends
21:29:56 <startling> in other words: if I "listen someWriter", does it modify the written state?
21:30:28 <ddarius> startling: You know you could always ...
21:30:38 <Puffton> s fi di x y = ((length fi) - 2) * di(x,y) - sum [di(x,z) + di(y,z) | z <- fi]
21:30:54 <Puffton> If fi is a Set, how come I can't use this notation?
21:31:02 <Puffton> z <- fi?
21:31:22 <dmwit> Because Set is not a monad.
21:31:27 <ddarius> Because Set /= [].
21:32:01 <dmwit> Oh, also because you're in a list comprehension and Set is not []
21:32:28 <carter> i've a whole bunch of reading / experiments I want to do in that space
21:32:57 <Puffton> Hm, so is it possible to use a similar notation?
21:33:18 <Puffton> This notation looks very beautiful in this context.. Almost exactly like the mathematical definition :(
21:34:34 <ion> What exactly do you want to do?
21:34:38 <startling> ddarius, I don't know what that means
21:35:04 <startling> Puffton, you can do Set.fromList [whatever comprehension]
21:35:17 <startling> Puffton: but note that you'll have problems with an infinite comprehension
21:35:28 <Puffton> startling, but it also feels a bit ugly :(
21:35:35 <startling> Puffton, sorry!
21:35:44 <Puffton> Thanks anyway! :)
21:35:51 <Puffton> Maybe it's the only solution, I don't know
21:36:38 <startling> Puffton: iirc there's an extension generalizing list comprehensions to arbitrary Monads, but Set isn't a monad.
21:36:39 <Puffton> ion, di is a map of coordinates, I want to sum their possible values, z is a set of all different points.. x = 1 and y = 2.. and z <- [3,4,5,6]
21:37:08 <Puffton> so di(1,3) + di(2,3) etc.
21:37:30 <Puffton> I could also re-write the code a bit if it made things prettier
21:37:41 <startling> doesn't `pass`, like, ruin the point of Writer?
21:38:10 <startling> if I can run arbitrary functions on it, mightn't it as well be State?
21:39:53 <startling> if I'm reading the types correctly, "pass (return $ const mempty)"" empties out the written state
21:41:02 <startling> err, s/const mempty/mempty
21:41:38 <simon> I wonder if monads can be explained in terms of monad tutorials.
21:43:17 <applicative> monad tutorials have bind, but no return
21:44:03 <Ferdirand> we need more monoid tutorials
21:44:05 <simon> I suppose one can learn by counter-examples.
21:44:10 <Ferdirand> to hopelessly confuse the neophyte
21:47:02 <startling> nope, pass doesn't do that
21:47:12 <alpounet> the 2013 trend will be codensity tutorials
21:47:24 <startling> does it only apply the function to stuff written by the same writer?
21:47:27 <ddarius> My dumplings are not pan-fried!
21:47:35 <startling> I'm gonna write a monad tutorial tutorial
21:47:42 <startling> 1) write tutorial
21:47:46 <startling> 2) understand monads
21:47:57 <startling> (second step may not be necessary)
21:48:09 <ion> Monads are like dumplings
21:48:43 <aristid> the firebreathing haskellites are at it again
21:48:44 <ddarius> startling: I suspect the person who wrote "jQuery is a monad" never got to step 2.  Admittedly, they never got to step 1 either...
21:49:03 <startling> ddarius: twisted is a monad too!
21:49:09 <startling> didn't you hear
21:49:58 <ion> IIRC some Twisted module actually did follow the actual monad laws.
21:50:40 <startling> ion: I think it's more that one of the parts is sort of like Cont
21:50:46 <startling> unless we're thinking of different things
21:51:10 <simon> startling, then I'll write the "Monads aren't like Monad tutorials, and many other things."
21:51:33 * ddarius is not sure that it is possible for any code accepting and executing arbitrary higher order functions (perhaps veiled as methods) to guarantee any laws in Python.
21:52:07 <startling> ddarius, nor in haskell
21:53:05 <ddarius> There are quite a few laws I can guarantee in Haskell for HOF accepting code without knowing anything about the HOF except that it is a Haskell function.
21:53:17 <startling> true enough
21:53:35 <johnw> bgamari: nice!  I'm glad it was that simple
21:53:58 <johnw> sometimes map should be called buildThunks
21:54:38 <startling> say I want to destructure some tuple inside a lambda. It seems to be next-to-impossible to line a "where" clause up with a lambda. Is it fine to do "case someFn x y of ((a, fn), e) -> (a, fn e)"?
21:54:46 <startling> or is there some other way?
21:55:25 <applicative> whats wrong with the case there?
21:55:26 <johnw> why would that be bad?
21:55:48 <startling> because I've only got one case and it always matches
21:55:50 <ddarius> case violates OO precepts
21:56:06 <lispy> case is not a part of standard lambda calculus. Therefore it should be avoided. ;)
21:56:17 <applicative> but that's the best kind of case...
21:56:29 <startling> ddarius, C++ is getting it!
21:56:41 <startling> well, sort of
21:56:47 <simon> startling, I prefer case with one match over let any day.
21:57:00 <ddarius> C++ doesn't try to be OO.
21:57:00 <dmwit> startling: use let
21:57:10 <lispy> case C++ of OOP -> error "Use Java/C#"; Procedural -> error "Use C"
21:57:12 <dmwit> let ((a, fn), e) = someFn x y of (a, fn e)
21:57:41 <startling> dmwit, surely you mean s/of/in?
21:57:53 <rking> Java in no way fills the role of C++.  C# even less so.
21:58:07 <shachaf> dmwit: "case" is nicer someone pointed out once.
21:58:12 <ddarius> That slightly changes the semantics.
21:58:31 <startling> let ... of is a thing? what's it do?
21:58:40 <alpounet> no, let ... in is
21:58:40 <rking> If you're going to go for a better OO at least pick a better OO, like Ruby or Smalltalk or Factor or anything.  Java ranks with one of my least favorite systems.
21:59:07 <johnw> rking: why?
21:59:11 <startling> but yeah, a `let` works just as well.
21:59:21 <startling> rking: is Factor OO?
21:59:23 <aristid> startling: it's the -XAcceptTypos extension
21:59:34 <startling> aristid, heh
21:59:57 * lispy thinks "{-# LANGUAGE PedanticIRC #-}" should be in the /topic today
22:00:12 <ddarius> Today?
22:00:16 <startling> I thought it was a typo until "<ddarius> That slightly changes the semantics."
22:00:26 <startling> but I guess that was to something else
22:00:31 <shachaf> @quote pedant
22:00:31 <lambdabot> lament says: I never close <pedant> tags. I just nest them.
22:00:39 <shachaf> @quote pedant
22:00:39 <lambdabot> lament says: I never close <pedant> tags. I just nest them.
22:01:23 <rking> Actually, Factor's OO solves some problems. http://youtu.be/f_0QlhYlS8g describes it (I'd find the time offset but something's screwy with my connection right now)
22:02:04 <startling> rking: I didn't know it was OO at all, just that it was concatenative
22:02:26 <rking> startling: That video is really informative.
22:02:41 <startling> rking, waiting for it to load, slow connection also
22:03:32 * applicative just noticed that the strict-ghc-plugin is on hackage now; it "recursively expands non-recursive let bindings into case bindings"
22:04:10 <lispy> applicative: ah, I always wondered how strict haskell was supposed to work. So they just mean, let is strict.
22:05:09 * startling is pleased that length "Reader" == length "Writer"
22:06:55 <applicative> strictifyExpr :: CoreExpr -> CoreM CoreExpr ; strictifyExpr e@(Let (NonRec b e1) e2) = return $ Case e1 b (exprType e2) [(DEFAULT, [], e2)]
22:07:08 <startling> would it be useful for anyone if I put my ReadWrite monad on hackage?
22:07:36 <applicative> lispy :  https://github.com/thoughtpolice/strict-ghc-plugin/blob/master/Strict/Pass.lhs
22:08:13 <applicative> it's *almost* readable
22:08:22 <startling> would it be too cheeky if I named it cd-rw?
22:09:05 <lispy> startling: I think the standard monad libraries (mtl/monadLib/etc) already have that covered if ReadWrite is a combination of reader and writer
22:09:25 <lispy> startling: but if it's something else then I don't know
22:09:39 <applicative> startling guarantees fewer lifts
22:10:25 <startling> lispy, it's just an instance of mtl's MonadWriter and MonadReader
22:10:34 <startling> applicative: right.
22:11:06 <ddarius> This is useless.
22:13:25 <lpvb> there a convenient way to export all functions in a file?
22:13:45 <ddarius> That's what happens by default.
22:13:49 <startling> lpvb, including imported functions?
22:14:30 <lpvb> just in the file
22:14:54 <startling> lpvb: do "module Whatever where" rather than "module Whatever (...) where"
22:15:13 <lpvb> ok, thought it was private by default
22:15:16 <Puffton> Do I have to use "do" clauses to read from a map avoiding "Maybe"?
22:15:28 <ddarius> You never ever have to use do.
22:15:34 <Puffton> i.e. having it return "Int" rather than "Maybe Int"
22:15:35 <startling> Puffton: you can just use bind and applicative style
22:15:46 <johnw> Puffton: "read from a map"?
22:15:50 <startling> Puffton, what specific thing are you doing?
22:15:57 <startling> johnw: assuming he means Data.Map
22:16:10 <johnw> I'm wondering if he knows about ! vs. lookup, and also fromMaybe
22:16:12 <Puffton> johnw, yes, a map has a number of keys and values, right? reading from them shouldn't be that weird
22:16:25 <liyang_> lpvb: yes, "module Whatever (module Whatever) where
22:16:26 <johnw> Puffton: reading isn't a verb I'm using to hearing in connection with maps
22:17:09 <startling> Puffton, you can use fromMaybe to supply a default, fmap to operate on it, >>= to attach it to an x -> Maybe y
22:17:35 <liyang> Useful if you're collecting together several other modules you want to re-export, as well as everything defined in module Whatever.
22:17:47 <startling> liyang: oh weird
22:18:41 <applicative> Puffton: what do you want to do it there's nothing there? \
22:19:19 <applicative> Puffton: if you have a default there's findWithDefault :: Ord k => a -> k -> Map k a -> a
22:19:32 <applicative> no, forget that
22:20:49 <lpvb> liyang: I can export the names exported in other modules?
22:21:07 <Puffton> I'm implementing an algorithm that takes a set of points {a, b, c, d, e} and a map of distances [((x, y), distance)]
22:21:19 <Puffton> So the distance between the points (x,y) is distance
22:21:23 <applicative> lpvb: yes, following liyang's model
22:21:59 <lpvb> how would I also export all the names defined in that module, in addition to names of other modules?
22:22:11 <lpvb> module MyModule (module OtherModule, ..) where?
22:22:19 <Puffton> There is an algorithm to find the two points that are farthest from the rest of the points,  that goes something like this:
22:22:29 <applicative> yes, here is a spectacular example, lpvb https://github.com/ekmett/lens/blob/master/src/Control/Lens.hs
22:22:32 <Puffton> s fi di x y = ((size fi) - 2) * di(x,y) - sum [di(x,z) + di(y,z) | z <- fi]
22:22:46 <Puffton> think of it as pseudocode for now, since it own't run
22:23:26 <Puffton> where fi is the set of points, di is the map and x and y is a given pair (it will give us the distance to the rest)
22:23:30 <lpvb> applicative: how about the names inside that module?
22:23:44 * hackagebot aws-sdk 0.1.0.1 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.1.0.1 (YusukeNomura)
22:24:04 <lpvb> (if there was any)
22:24:20 <Puffton> My main problem is no matter how I do this, given that I take a set and a map, the code gets pretty messy
22:24:24 <applicative> you would have to mention them explicitly, unless theres something I'm missing
22:24:46 <aristid> oO competition
22:25:46 <Puffton> I will try to get it running ugly-style and then see if it can be cleaned up
22:26:18 <applicative> lpvb, if edwardk had defined x :: Int, x = 1 -- which would be like him ;) --  and wanted it exported he would have to list it, since he started listing exports
22:26:50 <Puffton> but working with Data.Map and Data.Set seems overly complicated in Haskell? :S
22:28:09 <liyang> lpvb: yes. See http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Concurrent.html for example which re-exports Control.Concurrent.MVar &c.
22:28:23 <lpvb> applicative: okay, I figured I just have to define all the names in another module and import it and export that whole module again, leaving the main exporting module free of any definitions
22:28:57 <blackh> Puffton: You might need to abstract it a bit int some sort of "graph" representation.
22:38:45 * hackagebot custom-prelude 0.2.1.0 - My own custom prelude, based off Snoyman's basic-prelude  http://hackage.haskell.org/package/custom-prelude-0.2.1.0 (AnupamJain)
22:40:11 <lpvb> How would I apply a function to all the arguments of a function easily?
22:40:24 <johnw> huh?
22:40:45 <lpvb> like fun1 (succ x) (succ y) (succ z)
22:40:47 <lpvb> but better
22:41:12 <lpvb> where fun1 takes 3 enums
22:41:32 <johnw> fun1 $:: succ ~> succ ~> succ ~> id
22:41:37 <johnw> pointless-fun
22:41:49 <johnw> that yields a functions taking three arguments
22:41:50 <lpvb> what's the $::
22:41:53 <lpvb> and ~>
22:41:57 <johnw> combinators
22:42:09 <dibblego> is there ever a case where let x = e in f x is different to f x where x = e ?
22:42:09 <johnw> f = fun1 $:: succ ~> succ ~> succ ~> id
22:42:16 <johnw> f x y z = fun1 (succ x) (succ y) (succ z)
22:42:26 <johnw> they are equivalent
22:42:38 <ddarius> dibblego: They aren't even in the same syntactic class.
22:42:45 <lpvb> where can I read about combinators?
22:42:55 <johnw> combinators are just functions that take other functions to make new functions
22:43:01 <dibblego> ddarius: how do you mean syntactic class?
22:43:06 <johnw> higher-order function combiners, aka combinators
22:43:16 <lpvb> @hoogle (~>)
22:43:16 <lambdabot> No results found
22:43:20 <ddarius> "combinators" is a mostly meaningless word.  It has a technical definition, but I think most people who use the term "combinator" are unaware of it.
22:43:20 <lpvb> ?
22:43:22 <johnw> lpvb: http://hackage.haskell.org/packages/archive/pointless-fun/1.1.0.1/doc/html/Data-Function-Pointless.html
22:43:25 <ddarius> (Though many are aware of it.)
22:43:27 <lpvb> oh
22:43:32 <lpvb> thanks, johnw
22:43:48 <ddarius> dibblego: let is an expression, where is part of the declaration syntax.
22:43:54 <johnw> it may be that $:: and ~> are too clever by half
22:44:06 <johnw> but they exist because someone else wanted to do the same thing as you just asked :)
22:44:08 <lpvb> half?
22:44:20 <johnw> meaning, too clever for their own good
22:44:46 <lpvb> lol, but I like HOFs
22:44:58 <johnw> I think the lambda (\x y z -> fun1 (succ x) (succ y) (succ z)) is nice and clear
22:45:07 <startling> man, why couldn't local be (r -> s) -> m a -> m a
22:45:41 <ddarius> Clearly the correct quantity is "too clever by Œ≥" but 0.5 is a crude approximation.
22:46:03 <ddarius> startling: Where would s come from?
22:46:13 <Puffton> http://hpaste.org/75425
22:46:19 <Puffton> Wouldn't you guys say this is very messy? :(
22:46:21 <ion> > let f :: Expr -> Expr -> Expr -> Expr; f = fun "f"; g, h, i :: Expr -> Expr; g = fun "h"; h = fun "h"; i = fun "i" in liftA3 f g h i a
22:46:22 <lambdabot>   f (h a) (h a) (i a)
22:46:27 <dibblego> ddarius: sorry, I'm struggling to see the critical difference between the two ‚Äî is there an example that highlights it?
22:46:34 <ion> liftA3 fun1 succ succ succ
22:46:38 <ddarius> > x where x = 1
22:46:40 <lambdabot>   <no location info>: parse error on input `where'
22:46:44 <ddarius> > let x = 1 in x
22:46:45 <lambdabot>   1
22:46:45 <johnw> Puffton: factor out the fromMaybe 0 (Map.location (a, b) c) pattern
22:46:54 <johnw> and it will look a lot clearer
22:47:27 <Puffton> johnw, you mean make a new function for it?
22:47:38 <johnw> yes, using a where clause
22:47:40 <Puffton> like getValue or something
22:47:43 <applicative> dibblego: my understanding was that y = f x where x= e desugars to y = let x = e in f x but ddarius can say
22:48:02 <Puffton> but I would need three calls in the where clause then
22:48:06 <Puffton> because they all use different values
22:48:15 <johnw> the where function can take arguments
22:48:32 <Puffton> ohh ok
22:48:34 <startling> ddarius, yeah, good point
22:48:36 <Puffton> that's cool, will try it
22:48:45 * hackagebot luautils 0.1.1.0 - Helpers for Haskell integration with Lua  http://hackage.haskell.org/package/luautils-0.1.1.0 (AnupamJain)
22:50:48 <Puffton> johnw, so something like this then
22:50:49 <Puffton> http://hpaste.org/75426
22:50:50 <startling> so I want a (MonadReader r m, MonadReader [r] n) => m a -> n [a], but it doesn't seem possible
22:50:59 <johnw> yes, exactly
22:51:10 <johnw> the principle is called DRY, Don't Repeat Yourself
22:51:24 <aristid> :t local
22:51:25 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
22:51:29 <startling> for Monad m => ReaderT r m a -> ReaderT [r] m [a], I've got each m = ask >>= mapM (\x -> withReaderT (const x) m)
22:51:42 <startling> can anyone do any better than that?
22:51:54 <startling> aristid, local doesn't let me change the reading type
22:52:06 <startling> aristid: so I can't change [r] to r
22:52:36 <aristid> :t withReader
22:52:37 <lambdabot> forall r' r a. (r' -> r) -> Reader r a -> Reader r' a
22:52:43 <aristid> :t withReaderT
22:52:44 <lambdabot> forall r' r (m :: * -> *) a. (r' -> r) -> ReaderT r m a -> ReaderT r' m a
22:54:01 <aristid> startling: is that what you want?
22:54:14 <aristid> startling: oh nevermind you already use it
22:54:20 <startling> aristid, :)
22:54:36 <aristid> startling: thanks for reminding me that i'm tired :D
22:54:55 <startling> aristid: it's no trouble!
22:55:07 <startling> @pl mapM (\x -> withReaderT (const x) m)
22:55:07 <lambdabot> mapM (flip withReaderT m . const)
22:55:15 <startling> meh
22:56:12 <dibblego> applicative: I can find no explanation of a difference
22:57:15 <johnw> startling: what's wrong with that mapM?
22:57:24 <johnw> the pointless version is worse imho
22:57:46 <startling> johnw: I was hoping it'd do something clever
22:58:06 <startling> @djinn (MonadReader r m, MonadReader [r] n) => m a -> n [a]
22:58:06 <lambdabot> Error: Undefined type []
22:58:10 <startling> oh right
23:03:01 <applicative> dibblego: as far as I know there isn't a difference between  "y = f x where x= e" and  "y = let x = e in f x"
23:03:24 <applicative> except that let is hideous
23:04:09 <Puffton> http://hpaste.org/75429
23:04:17 <Puffton> Would you guys say I'm going overboard with the imports? Or is that common?
23:04:28 <Puffton> I thought it got so messy if I didn't try to cut it down a bit
23:05:00 <applicative> Puffton: you're importing the Prelude implicitly so 'map' isnt needed
23:05:54 <Puffton> how do you mean?
23:06:20 <applicative> it would be the same if you struck the Data.List line
23:07:06 <Puffton> oh you mean the imports on Data.List is unnecessary?
23:07:36 <johnw> Puffton: here's the imports list for my one-file command-line program: https://gist.github.com/3798190
23:07:38 <johnw> so no, you're not
23:07:41 <applicative> yeah, just because it's the same 'map' the Prelude let in
23:08:08 <johnw> and flymake (in Emacs) warns me the moment I have an unnecessary import too
23:08:10 <Puffton> johnw, I didn't mean the number of imports, just the hiding and all that stuff
23:08:25 <Puffton> instead of just normally importing most of them with "as" and writing the names out in code
23:08:39 <Puffton> like.. "import Data.Map as Map" and "Map.fromList"
23:08:55 <startling> :t \m -> ask >>= map (\x -> local (const x) m)
23:08:56 <lambdabot> forall a (m :: * -> *) a1. (MonadReader [a] [], MonadReader a m) => m a1 -> [m a1]
23:08:56 <johnw> if you're going to do Map.fromList, then import qualified Data.Map as Map
23:09:05 <Puffton> instead of "import Data.Map (fromList)" and "fromList"
23:09:07 <johnw> then you don't have to hide things from other modules as much
23:09:10 <startling> "MonadReader [a] []" is weird, why is that happening?
23:09:31 <johnw> I almost always have import qualified Data.List as L and import qualified Data.Map as M in my code
23:09:51 <applicative> Puffton: you can get them from ghc with -ddump-minimal-imports by the way
23:09:53 <johnw> though I think nowadays that I want Data.List's imports to be default
23:10:09 <johnw> ooh, very cool!
23:10:11 <Puffton> I just thought the code got a bit messier
23:10:31 <Puffton> with the explicite-ness, in writing every call Map.fromList for instance.. although it makes the code a bit clearer too
23:10:36 <johnw> applicative: that didn't work
23:10:41 <Puffton> i.e. easier to see which fromList you are working with
23:11:13 <johnw> oh, it made a file
23:11:14 <johnw> n/m
23:11:31 <arcatan> i think `import qualified Data.Map as M` is pretty common style
23:11:31 <dibblego> startling: as soon as you write, ask >>= map ‚Ä¶ you will get that type
23:11:33 <Puffton> I'll just go with L and M then, and write them out.. they are short enough, and should make it a little clearer what's going on
23:12:46 <arcatan> Puffton: your current style seems pretty clear, anyway
23:13:13 <startling> > :t ask >>= map undefined
23:13:14 <lambdabot>   <no location info>: parse error on input `:'
23:13:24 <startling> :t ask >>= map undefined
23:13:25 <lambdabot>     No instance for (MonadReader [a] [])
23:13:25 <lambdabot>       arising from a use of `ask' at <interactive>:1:0-2
23:13:26 <lambdabot>     Possible fix: add an instance declaration for (MonadReader [a] [])
23:13:39 <startling> dibblego, I don't get it
23:13:45 * hackagebot network-api-support 0.0.1 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.0.1 (MarkHibberd)
23:13:47 <applicative> johnw: ghc -ddump-minimal-imports X.hs works for me.  Maybe it doesn't work for module Main?
23:13:50 <dibblego> @type \f -> ask >>= f
23:13:51 <lambdabot> forall (m :: * -> *) a b. (MonadReader a m) => (a -> m b) -> m b
23:14:01 <applicative> johnw: it makes a file called X.imports
23:14:13 <Puffton> arcatan, yeah but which looks best if you had to choose?
23:14:25 <startling> dibblego, why is [] even a type?
23:14:33 <applicative> johnw: if the internal name of the module is 'module X ...'
23:14:41 <dibblego> @type \f -> ask >>= f -- turn f into (map g) here and you'll get that constraint
23:14:41 <dibblego> startling: it's not, it's a type constructor
23:14:42 <lambdabot> forall (m :: * -> *) a b. (MonadReader a m) => (a -> m b) -> m b
23:14:54 <dibblego> @kind []
23:14:55 <lambdabot> * -> *
23:15:04 <applicative> johnw:  oh i see you saw
23:15:21 <startling> oh! right, map doesn't output a monad.
23:17:52 <johnw> applicative: that ended up rewriting my imports (after massaging) to: https://gist.github.com/3798216
23:17:57 <johnw> very nice, thanks for that pointer!
23:20:07 <ion> Huh, nice. I hadn‚Äôt noticed dump-minimal-imports before.
23:20:37 * startling hands johnw a char *
23:20:51 <johnw> eww, get thee behind me mutating code!
23:21:16 * startling hands johnw a Ptr Char
23:21:23 <johnw> getting warmer
23:21:28 <johnw> i'll take a ForeignPtr
23:21:36 <startling> hehe
23:22:12 <johnw> then then a String, and then a nice, tasty Text... ;)
23:22:22 <johnw> yumm
23:38:55 <augur_> @tell conal http://worrydream.com/LearnableProgramming/
23:38:56 <lambdabot> Consider it noted.
23:48:37 <AfC> I'm watching the video of SPJ's GHC status report at ICFP. In the background there's singing. Sounds like a bunch of drunken vikings, which is exactly what I suspect it is, but Haskell √ó Improv vocals = ?
23:53:46 * hackagebot tamarin-prover 0.8.2.0 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.8.2.0 (SimonMeier)
23:53:48 * hackagebot tamarin-prover-term 0.8.2.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-term-0.8.2.0 (SimonMeier)
23:53:50 * hackagebot tamarin-prover-theory 0.8.2.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-theory-0.8.2.0 (SimonMeier)
23:53:52 * hackagebot tamarin-prover-utils 0.8.2.0 - Utility library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-utils-0.8.2.0 (SimonMeier)
