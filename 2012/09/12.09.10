00:01:18 * hackagebot c2hsc 0.4.0 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.4.0 (JohnWiegley)
00:02:26 * ddarius guesses he could abuse a uniform prior to get simpler math rather than the more proper Jeffrey's prior.
00:02:59 <ddarius> Actually, I can treat it as a location parameter in which case the uniform prior would be the appropriate one.
00:05:29 <mdxbhmt> wait, when hackage says NixOS, this means is only linux compatible?
00:06:21 <johnw> NixOS is a Linux distrubiotn
00:06:24 <johnw> distribution
00:06:36 <pharaun> never heard
00:06:43 <mdxbhmt> aaaah, well, I guess gloss then only work there
00:06:56 <johnw> Nix is a packager manager, which does work across platforms, and NiXOS is a Linux which uses it
00:07:00 <mdxbhmt> darn, and it compiled so nicely
00:07:20 <pharaun> how's conduit performance? possible to do 30+MB/s ?
00:07:23 <sopvop> developing under windows is a pain
00:07:29 <ddarius> pharaun: Yes.
00:07:48 <pharaun> ddarius: k then the problem is with my hasher stuff, thanks guess its time to start to look at porting this to C
00:08:00 <mdxbhmt> sopvop: I'm a fake dev :(
00:09:48 <ddarius> pharaun: Just because you are using conduit doesn't mean your code will instantly be fast, you still need to do sensible things (like chunk appropriately) or use a driver that does sensible things.
00:10:00 <sopvop> If you code for fun only, then install some kind of user-friendly linux (ubuntu, suse or whatever) and us it for fun. If you do it for profit, use the one what pays.
00:10:29 <pharaun> ddarius: yeah i know, i was just wanting to rule it out :) i'm basically doing - digest <- runResourceT $ sourceFile fp $$ sinkHash
00:10:50 <pharaun> which is as far as i'm aware should be doing the right thing performance wise, tho i might need to tweak?
00:11:17 <pharaun> i'm waiting for a profiling run to finish so i can get an idea of where the bottle neck is
00:11:42 <ddarius> I assume sourceFile is implemented to provide good throughput.
00:12:16 <pharaun> import Data.Conduit.Filesystem (sourceFile, traverse) - it should be, im poking at it
00:13:17 <mdxbhmt> pharaun, profiling should show it right away, no?
00:13:32 <pharaun> mdxbhmt: yah i'm profiling on a couple of very large file, taking a while :)
00:17:08 <mdxbhmt> pharaun: I learned quite some haskell coding/optimizing a program to parse a 100mb log files
00:17:22 <mdxbhmt> pharaun:  funny how profiling shows all the things
00:17:53 <pharaun> mdxbhmt: indeed :)
00:19:51 <Saizan> mdxbhmt: the list of distributions is only there to link to distribution-specific packages for that library, it's not saying the package is only supported there
00:34:32 <hpaste> pharaun pasted “profile” at http://hpaste.org/74512
00:35:18 <pharaun> mdxbhmt: ^ just pasted looks like 99% of time is in addFP ? which hm is basically running the conduit source/sink + hasher
00:36:00 <pharaun> but looking at the Crypto.Hash.Ed2k does not seem like much of the cpu time is there at all
00:38:34 <pharaun> 76s for 200mb file seems a little slow :)
00:39:33 <shachaf> Kids these days.
00:39:46 <shachaf> (Unless "mb" is "millibit", that is.)
00:39:54 <pharaun> hah - megabytes
00:39:59 <ddarius> pharaun: You can replace your hash function with a dummy thing that, say, just dumps to a file if you are saving the results of the hash, and that will give you an idea of the overhead of conduit, but I'm sure it will be IO bound at that point and will go as fast as your disk.
00:45:26 <ddarius> Okay, so integrate and dump is the right thing to do if you know the expected signal, it's location, and the signal to noise ratio.
00:53:03 * ddarius thinks he'll go for a run.
00:54:28 <lpvb> is there a tool to autmatically infer and write the type declarations of files?
00:54:55 <pharaun> ouch
00:55:00 <ddarius> I think there's an emacs or vim or Leksah thing that does that.
00:55:32 <pharaun> i just erased the conduit stuff and did a plain file dump into the hasher, got it to do 200mb in .5s
01:17:11 <sopvop> So, there is no way to make Enum instance for GADTs, right?
01:18:33 <Nereid> you can make one yourself, but you can't derive it
01:19:08 <sopvop> I can't, it can't match 'a with WhateverWitness'
01:19:21 <Nereid> ?
01:22:08 <hpaste> sopvop pasted “enum for gadt” at http://hpaste.org/74516
01:23:52 <sopvop> Am I doing something wrong?
01:24:16 <Cale> No, that's correct, the results of toEnum must all be the same type.
01:24:23 <shachaf> dmwit++ for fixing X11 under GHC 7.6!
01:24:40 <Cale> Enum doesn't make much sense unless you really want the [a..b] syntax
01:25:36 <sopvop> Yup, I want it. But guess can make   range :: Foo a -> Foo b -> [Foo c]
01:25:46 <sopvop> But this not going to work anyway
01:26:55 <sopvop> Yeah, I'll need to think another way of doing it.
01:27:11 <Nereid> I would have thought even line 6 would be an error by itself.
01:27:34 <sopvop> More like like 7
01:27:37 <hpaste> carpi pasted “twice computed?” at http://hpaste.org/74517
01:27:39 <Nereid> because you'd have toEnum :: forall a. Int -> Foo a
01:27:39 <carpi> can someone please take a look at my hpaste?
01:28:11 <Nereid> so toEnum 0 ought to be forall a. Foo a
01:28:15 <sopvop> Nereid: oh, right. it actually does error on like 6.
01:28:23 <sopvop> on line 6
01:29:08 <Twisol> copied from carpi's hpaste to make it easier for people to glance at: "--Is the value of 'pre l' computed twice, cos I have used it in two places?"
01:29:08 <Nereid> carpi: I dunno, might depend on the optimization level? you could use Debug.Trace to find out for sure, though
01:29:39 <carpi> Twisol: thanks - )
01:30:11 <Nereid> my guess is yes
01:31:01 <Twisol> My guess is that, because of referential transparency, it's a potential optimization to only compute it once.
01:31:15 <Nereid> sure it is.
01:31:20 <Twisol> but that only says "maybe", so… ^_^
01:34:51 <shachaf> Hah, from the X11 package:    fprintf(stderr, "xmonad: X11 error: %s, request code=%d, error code=%d\n", buffer, ee->request_code, ee->error_code);
01:35:02 * shachaf wonders whether anyone else has ever used it...
01:39:44 <startling> Twisol: it also adds overhead if you're actively memoizing
01:46:47 <t7> what programming project would look good on my CV and help me get a job? A little C compiler? something else?
01:47:27 <mux_> some well known open source project
01:47:34 <rtharper> t7: anything, really
01:47:42 <rtharper> contributing to OSS is one way, but not ht eonly wya
01:47:45 <Dodek> t7: what country do you live in?
01:47:49 <rtharper> if you have some small tools you use as well
01:47:50 <t7> UK
01:47:58 <rtharper> the more you have of your work on GitHub, the better
01:48:06 <rtharper> it also depends on how ideological the company is
01:48:12 <t7> im stuck administering windows server :(
01:48:13 <rtharper> some won't even look at a CV without OSS experience
01:48:23 <rtharper> for others, having any sort of portfolio is a plus because they see you can actually program
01:48:27 <Dodek> t7: isn't it like, very easy to get a job as a programmer anywhere nowadays?
01:48:37 <t7> rtharper: does it count if its OSS that i have started and no one else uses?
01:48:39 <rtharper> Dodek: The UK is not a nice place to try and get a job right now
01:48:43 <rtharper> t7: I would say so
01:48:47 <rtharper> it's about the coe
01:48:48 <rtharper> code
01:48:49 <Dodek> rtharper: why's that so?
01:48:50 <rtharper> and how you think about it
01:49:10 * osfameron has more work than he can handle in the UK at the moment... (not Haskell though)
01:49:23 <Dodek> i never seen anyone care about OSS experience.
01:49:28 <t7> I should probably write stuff for my portfolio in C++/Java :(
01:49:28 <rtharper> I was met with a lot of indifference in the UK market, and offered poor poor poor saslaries
01:49:32 <rtharper> salaries*
01:49:38 <rtharper> it's one of the reasons I moved to Sweden
01:49:52 <Dodek> rtharper: ah, poor salaries.
01:50:03 <mux_> Dodek: I got all my interesting job offers (including Google) thanks to OSS
01:50:13 <rtharper> Dodek: it's also a super shitty place to get a job as a non-EU citizen
01:50:13 <mux_> so I beg to differ :-P
01:50:33 <Dodek> rtharper: i mean, it's very easy to get a job as a programmer, if you don't mind the salary ;)
01:50:51 <Dodek> mux_: i got all my interesting job offers (including Google) regardless of OSS
01:50:54 <Dodek> :)
01:50:58 <rtharper> Dodek: yes, I just spend the last 9 bloody years in Uni and have US-level student loans, I'm not going to take a shite job =p
01:51:00 <johnw> Is there any way to to call varargs C functions from Haskell using Bindings-DSL?
01:51:05 <johnw> the docs don't mention them
01:51:46 <mux_> whatever, OSS is useless on a CV, right.
01:52:03 <ciaranm> entirely depends upon who you're applying to
01:52:14 <ciaranm> there are still companies that see OSS and instantly blacklist you
01:52:22 <ciaranm> you probably don't want to work for those kinds of companies...
01:52:46 <ciaranm> there are other companies who basically use your github as a pre-interview
01:52:47 <lpvb> open source software
01:52:49 <lpvb> ?
01:53:00 <ciaranm> orange shaded sunglasses
01:53:11 <lpvb> better throw mine away
01:53:16 <Dodek> rtharper: heh. i was lucky enough to live in a country that covers university education from taxes.
01:53:34 <lpvb> why would a company blacklist someone for doing open source software
01:53:54 <rtharper> Dodek: for international students? Cuz non of my student loans actually come from my degree in the US
01:54:01 <rtharper> but Oxford sure did clean me out ;)
01:54:09 <ciaranm> lpvb: there are still places that believe the old microsoft FUD that not even microsoft tries any more
01:54:31 <lpvb> what's the microsoft FUD
01:54:45 <Dodek> rtharper: i'm not sure actually, but i'd be surprised if international students had to pay.
01:54:50 <ciaranm> that the GPL is a cancer and if you employ anyone who's worked on OSS then you have to give all your code away for free
01:54:52 <rtharper> Dodek: which country?
01:54:57 <Dodek> rtharper: Poland
01:55:01 <lpvb> haha
01:55:01 <rtharper> Ah, perhaps not
01:55:02 <lpvb> that's dumb
01:55:09 <hnsz> lpvb: Fear Uncertainty Doubt
01:55:10 <rtharper> they just started charging fees here a few years ago
01:55:15 <t7> ASP.net is opensource now
01:55:18 <rtharper> 10,000 EUR for international students in still cheaper than the UK, though ;)
01:56:00 <mux_> OSS != GPL (I do think GPL is a cancer)
01:56:02 <ciaranm> you should try scotland
01:56:15 <ciaranm> no, wait, don't. EU students don't get us extra money.
01:56:16 <rtharper> mux_: I agree ;)
01:56:25 * rtharper is not an EU student
01:56:50 <Dodek> rtharper: by the way, what's the average salary of a skilled programmer in Sweden?
01:56:56 <Phlogistique> well, we're one of the communities who owe the most to Microsoft doing OSS
01:57:31 <Phlogistique> so the old Microsoft FUD does not make much sense for Haskell
01:58:09 <ciaranm> it didn't make sense for anyone
01:58:15 <t7> mux_: you're an apple using cancer tumor
01:58:37 <rtharper> Dodek: how much skill/experience?
01:59:16 <rtharper> Dodek: right out of undergrad, 30,000ish SEK per month
01:59:18 <Dodek> rtharper: say, 3-5 years at top companies
01:59:30 <rtharper> Dodek: high 40,000s/month
01:59:55 <mux_> t7: o_O
02:00:00 <rtharper> (50-60k GBP)
02:00:06 <rtharper> per year
02:00:06 <rtharper> heh
02:00:07 <rtharper> sorry
02:00:11 <Dodek> rtharper: ok. and how much do you need to know swedish language?
02:00:14 <Jafet> I would pay money to have Appel computers
02:00:16 <rtharper> not at all
02:00:26 <mux_> I'm not using a single Apple product
02:00:27 <rtharper> I speak Swedish but my partner doesn't
02:00:30 <rtharper> and he works for Spotify =)
02:00:33 <Dodek> rtharper: and these figures are before taxes, i assume?
02:00:41 <rtharper> Dodek: definitely ;)
02:00:46 <ciaranm> møøse bites can be veri nasti
02:00:51 <Dodek> rtharper: ok, thanks! :)
02:00:53 <t7> gcc inline asm syntax is retarded
02:01:07 <rtharper> Dodek: a fair few FP opportunities her
02:01:07 <rtharper> e
02:01:15 <rtharper> more Erlang than Haskell, but you they exist as well
02:01:58 * hnsz Is sad about the fact that calling them Macintoshes doesn't make apple users cringe anymore.
02:02:05 <rtharper> lolz
02:11:22 * hackagebot c2hsc 0.5.0 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.5.0 (JohnWiegley)
02:36:40 <johnw> ok, that's about everything I'm aware of to do with c2hsc
02:38:04 <merijn> johnw: How experimental is c2hsc supposed to be? I tried using it last week but it wouldn't build at that time
02:38:19 <johnw> it's now only 20% experimental
02:38:29 <johnw> could you try now?  I'm willing to help you fix the problem
02:38:44 <mux_> hmm, the new MultiWayIf extension is pretty cool
02:38:58 <merijn> johnw: Sure, lemme update cabal first
02:39:09 <merijn> mux_: pfft, type level literals, baby!
02:39:17 <johnw> i can see myself using \case, but MultiWayIf, I dunno
02:39:28 <merijn> When will HP ship with 7.6? :p
02:39:37 <mux_> heh
02:39:41 <merijn> case lambda's are also neat, yeah
02:40:23 <watermind> When proving properties P of infinite lists via transfinite induction, it is still not clear to me exactly why we need to prove P(_|_) ... It is clear to me we do need it, but not exactly sure why
02:41:22 * hackagebot c2hsc 0.5.1 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.5.1 (JohnWiegley)
02:42:16 <watermind> wouldn't the lub of a chain of finite non partial lists also be an infinite list?
02:45:02 <johnw> does GHC have any capacity to encode ASTs in .hi files, so that it can compile uses of ad-hoc polymorphism in the context of the module doing the call, to avoid the runtime indirection penalty?
02:45:47 <parcs`> yes ghc does cross-module inlining
02:45:58 <johnw> oh, excellent
02:46:26 <merijn> johnw: Oh, builds and runs now
02:46:43 <johnw> merijn: please log builds on github.com as you find them
02:46:48 <johnw> or pull requests :)
02:47:00 <merijn> However, one big issue: like c2hs it generates type CLong for intptr_t instead of the FFI's IntPtr type
02:47:07 <johnw> the code is thorny until you can think in terms of language-c's AST structures
02:47:09 <merijn> johnw: Lunch time now, I'll look into it a bit later
02:47:30 <johnw> merijn: I'd be happy to fix that, or allow for dynamic translations
02:47:38 <johnw> (probably via some kind of input files)
02:47:39 <johnw> ok
02:49:13 <johnw> parcs`: so if I call sort based on Org, and it's a list of billion integers, the sort is roughly as fast a template-based C++ sort would be (where the optimal code paths are decided at compile-time)?
02:51:54 <ciaranm> johnw: template-based c++ sort is inplace
02:53:33 <johnw> well, you have a point there
02:54:05 <johnw> what I really mean is, will the Ord indirection on (<) be taken out, even though sort was exported from another module?
02:54:23 <johnw> guess I can look at dumpsimpl
02:54:47 <parcs`> johnw: yep
02:56:25 <ciaranm> the utterly weird thing is that sometimes cross-module inlining and lack thereof means code runs faster when you put it in modules
02:56:32 <johnw> yeah, it sure is
02:56:47 <johnw> with -O no, but with -O (<) turns into GHC.Integer.Type.compareInteger
02:56:50 <johnw> very cool
02:58:15 <Spockz> why isn't there something like mapFst :: (a -> b) -> (a,c) -> (b,c) in the Prelude? I've seen a lot of people use it and define it on their own
02:58:30 <shachaf> @ty first :: (a -> b) -> (a,c) -> (b,c)
02:58:31 <lambdabot> forall a b c. (a -> b) -> (a, c) -> (b, c)
02:58:37 <shachaf> In Control.Arrow
02:59:15 <Spockz> hmm why didn't Hoogle tell me about that one
02:59:27 <Spockz> so (,) is an instance of Arrow?
02:59:54 <mux_> @src (,) first
02:59:54 <lambdabot> Source not found.
03:00:18 <Spockz> @ty first
03:00:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
03:01:27 <johnw> Spockz: it's (->) which is an instance of Arrow, not (,)
03:01:56 <johnw> so, a (b, d) (c, d), for functions, is (b, d) -> (c, d)
03:02:00 <Spockz> her yes indeed johnw
03:03:11 <shachaf> @hoogle Eq a => [(a,a)] -> a -> a
03:03:12 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
03:03:12 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
03:03:12 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
03:03:16 <shachaf> Is there such a function?
03:03:28 <shachaf> foo map x = fromMaybe x (lookup x map)
03:03:38 <Spockz> johnw: still sleepy I guess :p
03:04:37 <maukd> :t (fromMaybe =<<) . flip lookup
03:04:38 <lambdabot> forall b. (Eq b) => [(Maybe (Maybe b), b)] -> Maybe (Maybe b) -> Maybe b
03:05:03 <parcs`> <*>
03:05:18 <shachaf> @pl foo map x = fromMaybe x (lookup x map)
03:05:19 <lambdabot> foo = ap fromMaybe . flip lookup
03:05:26 <maukd> very true
03:06:24 * hackagebot curlhs 0.0.2 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.0.2 (KrzysztofKardzis)
03:07:10 <johnw> night
03:11:24 * hackagebot jailbreak-cabal 1.0 - Strip version restrictions from build dependencies in Cabal files.  http://hackage.haskell.org/package/jailbreak-cabal-1.0 (PeterSimons)
03:12:17 <mikeplus64> where is the code repo for bytestring?
03:13:03 <shachaf> @google where is the code repo for bytestring? haskell
03:13:04 <lambdabot> http://darcs.haskell.org/ghc/packages
03:13:12 <shachaf> Looks like it's at http://darcs.haskell.org/bytestring/
03:13:33 <mikeplus64> thanks
03:17:43 <t7> i need dependently typed assembly language
03:17:55 <t7> im gonna break everything writing x86
03:21:24 * hackagebot cabal2nix 1.39 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.39 (PeterSimons)
03:26:19 <sqrt> Can someone recommend an example of an implementation of a Monad?
03:26:38 <Botje> for what purpose?
03:26:43 <shachaf> sqrt: Did you see the FAQ entry on this?
03:26:44 <shachaf> @where faq
03:26:45 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:27:04 <sqrt> shachaf: Thanks, I'll have a look.
03:30:26 <merijn> hmm, any c2hs users around?
03:30:41 <sqrt> Botje: Just trying to understand ... what it is, how it's used, what it's good for and how it relates to monads. But I think I understand that last one now.
03:31:13 <merijn> sqrt: Maybe, Either a, [a]
03:31:21 <Botje> sqrt: "all about monads" or "monads for the working programmer" give you an overview of the different monads
03:31:31 <Botje> they also talk a bit about implementation, i think
03:31:39 <merijn> sqrt: Also State and Reader are some others you could look at
03:32:45 <sqrt> Thanks, merijn, Botje.
03:33:04 <sqrt> Heh. Monads for the working programmer. Funny title!
03:38:56 <merijn> The people writing FFI tools have clearly spent to much time in high level langauge land and not enough in C land >.>
03:42:31 <ddarius> The entire goal of the Haskell FFI is to do as much as possible Haskell-side.
03:43:12 <merijn> ddarius: That's not what I meant, what I mean is that they do things that make my life interacting with C harder then it needs to be
03:44:19 <merijn> ddarius: c2hs, c2hsc and a bunch of other tools for deriving the usual boilerplate all resolve "intptr_t" to CLong (because that happens to be the implementation on my macbook), instead of doing the smart thing and resolving it to IntPtr (from Foreign.Ptr)
03:44:57 <merijn> As a result I'm now forced to handwrite my boilerplate or post-process it with sed (which would require me to hook that into cabal somehow), either way wasting a ton of time for no good reason
03:48:40 <merijn> The reason appears that language-c and c2hs both don't consider "intptr_t" a primitive C type, fixing language-c seems to be an unreasonable task since I can't even get a basic grip on how it works from the code and waiting for it's maintainer to fix it would take to long for me
03:52:38 <ddarius> It's probably just historical accident that never got fixed.  c2hs was developed around the time intptr_t was officially added to C.
04:04:25 <int-e> merijn: is there any case where c2hs does such a mapping for a typedef? After all, intptr_t is just a typedef  from stdint.h.
04:06:07 <merijn> int-e: I dunno, I don't think so
04:06:24 <merijn> int-e: But on the other hand "intptr_t is just a typedef from stdint.h" is wrong
04:06:39 <merijn> The fact that all current compilers implement intptr_t that way is an implementation detail
04:06:56 <merijn> C implementations are free to have a built-in primitive type for intptr_t
04:07:45 <merijn> Considering the fact that the type is required by C99 and that the FFI has special types for them seems enough to warrant a special case to me
04:08:59 <benmachine> merijn: can you just throw fromIntegrals around?
04:09:03 <benmachine> *can't
04:10:13 <shachaf> @ty maybe (return ())
04:10:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
04:10:16 <shachaf> @hoogle (Monad m) => (a -> m ()) -> Maybe a -> m ()
04:10:17 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
04:10:17 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
04:10:17 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
04:10:37 <merijn> benmachine: Then I'd have to write marshalling code for my marshalling code and I might as well just write the original marshalling code by hand
04:11:41 <merijn> shachaf: Man, I use that function *all the time*, I ended up implementing it as "withJust" and copying that into most of my own projects
04:12:08 <shachaf> In this case I think I want the flip of it.
04:12:14 <shachaf> @ty flip $ maybe (return ())
04:12:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> (a -> m ()) -> m ()
04:12:25 <shachaf> merijn: You should send a message to libraries@ so they put it in Control.Monad!
04:12:32 <shachaf> I hear they might actually listen to that sort of thing.
04:13:02 <maukd> 'return ()' could be shortened to 'def', maybe
04:13:48 <merijn> shachaf: I wrote it as:
04:13:48 <merijn> withJust :: (Functor m, Monad m) => Maybe a -> (a -> m b) -> m ()
04:13:49 <merijn> withJust m f = maybe (return ()) (void . f) m
04:14:06 <shachaf> Yep, that.
04:15:17 <Ferdirand> how about 'done'
04:15:23 <benmachine> shachaf: I've never spent the time to work out the libraries process, is it just e-mailing people these days?
04:15:39 <shachaf> Hmm, xmonad calls it "whenJust".
04:15:40 <benmachine> I should write that thing to go in template-haskell
04:15:47 <shachaf> benmachine: Well, it's a mailing list.
04:15:49 <shachaf> There's a wiki page on the process.
04:15:51 <lpvb> do overlapping instances still happen when you give a special type a newtype wrapper?
04:16:04 <benmachine> lpvb: newtypes are, well, new types
04:16:14 <benmachine> lpvb: they are different from the underlying type, that's the whole point of them
04:16:20 <benmachine> lpvb: so they are good for avoiding overlap
04:16:39 <lpvb> but they provide a minimal performance overhead right?
04:16:46 <merijn> lpvb: None
04:17:05 <merijn> lpvb: newtypes are exactly identical to the underlying type at runtime
04:17:21 <benmachine> merijn: in fairness, they can stop some optimisations from firing
04:17:26 <lpvb> but they still work for avoiding overlapped instances?
04:17:28 <benmachine> especially RULES
04:17:34 <lpvb> then how are they exactly identical
04:17:35 <benmachine> so like, map id can be turned into id
04:17:44 <benmachine> lpvb: *at runtime*
04:17:46 <merijn> lpvb: Yes, newtypes basically only exist at compile time/type check time
04:17:57 <benmachine> lpvb: they are different at compile time and then the difference is thrown away when your program actually runs
04:18:09 <lpvb> okay
04:18:12 <merijn> lpvb: Once the typechecker concludes everything works out the constructor is thrown away for the compiled code
04:19:36 <lpvb> so in what case would someone use OverlappingInstances over newtype?
04:20:49 <benmachine> lpvb: personally, I would never use OverlappingInstances
04:20:59 <benmachine> lpvb: but other people might disagree
04:21:10 <lpvb> so you can always use newtype to avoid overlap?
04:21:50 <merijn> lpvb: Well, newtypes prevent you from using the value as argument to a function that requires the original type
04:24:21 <ddarius> :t for_
04:24:23 <lambdabot> Not in scope: `for_'
04:24:32 <ddarius> :t Data.Traversable.for_
04:24:33 <lambdabot> Not in scope: `Data.Traversable.for_'
04:24:37 <ddarius> @hoogle for_
04:24:38 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
04:24:51 <typoclass> merijn: not sure, but have you tried http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/implementing.html#id315561 ?
04:26:04 <ddarius> :t Data.Foldable.for_ :: (Applicative m) => Maybe a -> (a -> m b) -> m ()
04:26:06 <lambdabot> forall a (m :: * -> *) b. (Applicative m) => Maybe a -> (a -> m b) -> m ()
04:26:14 <merijn> typoclass: tbh I haven't read that match of the c2hs documentation as I was completely unable to follow what the hell was going on
04:28:26 <typoclass> merijn: i've just been bumbling around with code like "{#pointer * intptr_t as IntPtr foreign nocode#}", but honestly -- http://memeblender.com/wp-content/uploads/2012/01/i-have-no-idea-what-im-doing-dog-flying-helicopter.jpg
04:28:29 <merijn> typoclass: Which, tbh, applies to most of the FFI tools I've attempted to use >.>
04:29:15 <merijn> I've looked into c2hs, hsc2hs, bindings-DSL and c2hsc, but I'm just randomly fiddling with bits and hoping it ends up compiling...
04:30:21 <typoclass> merijn: a tried and true approach
04:31:12 <shachaf> Often tried, rarely true.
04:31:13 <benmachine> gotta fiddle those bits
04:31:16 <shachaf> Particularly when FFIs are involved.
04:31:34 <benmachine> shachaf: well, it's truly awful, if that helps :P
04:31:39 <benmachine> (jk)
04:31:55 <merijn> shachaf: The FFI itself is completely intuitive and easy to use
04:32:21 <merijn> shachaf: It's the C-to-Haskell mapping of datatypes that's screwing up my ability to do anything whatsoever
04:32:34 <shachaf> merijn: Right.
04:32:41 <shachaf> Do you prefer to call that FDI?
04:32:46 <shachaf> At any rate it's very annoying.
04:33:00 * typoclass giggles at FDI
04:33:06 <merijn> I just want to map a trivial struct to a haskell datatype with the appropriate FFI types and so far I've spend 2.5 days without much progress :\
04:33:26 <merijn> (Well, c2hs finally worked, until I wanted to use intptr_t)
04:33:33 <shachaf> @hoogle Maybe a -> Maybe b -> Maybe (a,b)
04:33:34 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)
04:33:34 <lambdabot> Control.Monad.Trans.RWS.Lazy execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
04:33:34 <lambdabot> Control.Monad.Trans.RWS.Strict execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
04:33:41 <shachaf> I *don't* want the liftM2 behavior here.
04:33:47 <ddarius> What do you want?
04:33:52 <shachaf> I want Just-if-either-is-Just.
04:33:56 <Saizan> {#pointer intptr_t as IntPtr nocode #} might be what you want
04:33:57 <shachaf> With a default value.
04:33:58 <shachaf> Er.
04:34:02 <shachaf> What I want isn't actually possible.
04:34:08 <shachaf> That explains why it doesn't exist.
04:34:09 <typoclass> shachaf: have you tried randomly fiddling with bits until it compiles?
04:34:56 <shachaf> I have f :: a -> Maybe a, g :: b -> Maybe b, and I want to make foo :: (a,b) -> Maybe (a,b) such that foo returns Just if either f or g does.
04:36:34 <Saizan> \(a,b) -> let ma = f a; mb = g b; in liftM2 (,) ma mb `mplus` fmap (b,) ma `mplus` fmap (a,) mb  -- ?
04:37:14 <shachaf> Well, yes.
04:37:29 <shachaf> I don't think that use of mplus saves me anything over doing it by hand.
04:38:17 <shachaf> @djinn (a,b) -> (Maybe a,Maybe b) -> Maybe (a,b)
04:38:18 <lambdabot> f (a, b) (c, d) =
04:38:18 <lambdabot>     case c of
04:38:18 <lambdabot>     Nothing -> Nothing
04:38:18 <lambdabot>     Just e -> case d of
04:38:18 <lambdabot>               Nothing -> Just (e, b)
04:38:18 <ddarius> So you want to return Nothing even though you do have a default for both Maybes?
04:38:20 <lambdabot>               Just f -> Just (a, f)
04:38:34 <shachaf> djinn++
04:39:20 <merijn> Saizan: It would be, if it wasn't an syntax error :\
04:39:28 <shachaf> ddarius: I have functions f and g that usually just return their argument but occasionally fiddle with it.
04:39:42 <merijn> Saizan: {#pointer only works for pointer types, which intptr_t is not according to c2hs
04:39:45 <shachaf> Instead of explicitly checking, I thought I'd use a Maybe to represent that.
04:39:59 <shachaf> (Checking that new /= old, that is.)
04:40:24 <Saizan> shachaf: djinn has fooled you
04:40:47 <shachaf> Anyway I was wondering about the more general function but it looks like this doesn't make that much sense in the more general case.
04:40:51 <shachaf> Saizan: Oh, so it did.
04:40:55 <shachaf> djinn-- # fooling me
04:41:28 <shachaf> I guess at the "Just f ->" point its heuristic doesn't care about a vs. e.
04:41:28 <ddarius> shachaf: Okay, so you want Nothing returned when neither modifies either to indicated that the compound didn't modify anything.
04:41:38 <shachaf> ddarius: Right.
04:44:00 <benmachine> shachaf: at the Just f point it has already used e but not a
04:44:07 <benmachine> shachaf: so it makes sense to put a in there
04:44:10 <shachaf> benmachine: Oh, right.
04:44:22 <shachaf> So it's not just arbitrary.
04:44:29 <benmachine> I don't think so
04:44:37 <benmachine> it tries to use all the arguments if it can
04:44:40 <shachaf> Right.
04:44:44 <benmachine> hence not just giving you const (const Nothing)
04:45:57 <benmachine> it's guessed sensibly, but it hasn't guessed your guess
04:46:10 <benmachine> you'd want a bigger Nothing branch, I guess
04:46:17 <benmachine> (first Nothing branch)
04:46:20 <Saizan> also, that djinn code gives nothing even when d is not Nothing, so it's really another function
04:52:23 <JuanDaugherty> this channel has increased typical user count 42% since I first started using about 6 years ago
04:52:48 <merijn> Where do I find cabal documentation that's reachable? This one appears to be dead: http://www.haskell.org/cabal/release/rc/doc/libraries/Cabal/Distribution-Simple.html
04:53:25 <typoclass> merijn: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Simple.html
04:53:54 <merijn> Clearly the user guide of cabal isn't using Yesod and it's static URL validation :p
04:54:44 <Saizan> merijn: for the API you can check hackage
04:54:48 * merijn sighs
04:54:56 <merijn> Sometimes I prefer make and shell scripts...
04:55:29 <sjamaan> Hi.  I'm trying to cross-compile ghc to NetBSD/amd64 but running into some trouble at the start
04:55:39 <merijn> I just want to smash a sed in the build process and now I have to spend an afternoon learning cabal to learn how to do that :\
04:55:49 <sjamaan> I ran ./configure --enable-hc-boot --build=x86_64-netbsd --host=x86_64-linux --target=x86_64-netbsd  and got:
04:55:53 <sjamaan> configure: Building in-tree ghc-pwd
04:55:55 <sjamaan> ./configure[3786]: : cannot execute - Is a directory
04:55:58 <sjamaan> configure: error: Building ghc-pwd failed
04:56:11 <sjamaan> I copied /bin/pwd to utils/ghc-pwd/ghc-pwd, like the instructions at http://hackage.haskell.org/trac/ghc/wiki/Building/Porting say
04:59:09 <typoclass> sjamaan: are there any clues which directory it's mistaking for a binary? you could try increasing verbosity, or maybe even do "strace ./configure ..."
05:00:25 <sjamaan> typoclass: No clues so far.  I'm trying an alternate method, via http://git.cielonegro.org/gitweb.cgi?p=build-hc-pkg.git
05:00:32 <sjamaan> Let's see if that works better
05:00:49 <Ornedan> !status mediocrity
05:01:36 <Ornedan> whoops, wrong channel
05:07:48 <merijn> I swear, sometimes programming is just to depressing to bother with...
05:08:17 <merijn> ls
05:08:28 <Adeon> did you consider alternative hobbies
05:09:18 <merijn> Adeon: Yeah, I'm thinking of jabbing forks in my eye as an alternative
05:11:27 * hackagebot simple-config 1.1.0 - Simple config file parser generator  http://hackage.haskell.org/package/simple-config-1.1.0 (YusukeNomura)
05:12:41 <mikeplus64> how would one go about making a calling convention for the ghc ffi?
05:20:22 <Peaker> Why does "cabal build" *always* re-link the executable, whereas "ghc --make" only does so if needed?
05:35:46 <benmachine> if I want to write an application that is leap-seconds correct, is there any standard place to get that information from?
05:36:56 <clsmith> hm, is there any kind of simple Core interpreter i could use to prototype things before i have to tackle with ghc proper?
05:37:21 <sjamaan> typoclass: I removed the pwd build from the configure script and pass in GHC_PWD=pwd, but now it's complaining it can't find ghc-pkg.  It looks like it needs an extant ghc to build, but that's not really what the instructions are saying
05:38:10 <clsmith> i guess if not it shouldn't be *too* hard to rustle one up (he says naively)
05:40:12 <typoclass> benmachine: if you mean the leap second tables, i bet those are being published by all kinds of standards organizations, BIPM, naval observatory, etc.
05:42:17 <typoclass> ... erm, for the past, that is. for the future, nobody knows. new leap seconds are announced at 6 months notice, or 12 or whatever
05:42:59 <asante> how should i rebuild proken packages, ghc-pkg lists me? cabal install $package-name?
05:44:05 <typoclass> benmachine: (also, are you absolutely sure you need leap seconds? it seems like an awful lot of complexity for no significant gain ...)
05:44:53 <benmachine> typoclass: I'm bitter because a recent leap second crashed my server
05:45:12 <benmachine> I mean, I know my application isn't going to do that if I ignore them
05:45:13 <benmachine> but still
05:45:38 <kstt> hello, how would you solve this problem please ? There are units of computations that are stored in a shared collection for caching purpose, in case they are needed later. These computations are both CPU-intensive and memory consuming, so units that have not been used for some time must be cleared of. The naive solution I have so far is : store Last Date of Usage along with the unit, dedicate a thread to traverse all units every mi
05:45:38 <kstt> or so, and remove those that are older than the maximum admissible age. This works but does not look very elegant. Any better idea ?
05:46:26 <earthy> kstt: what you're describing is a simple least-recently-used cache
05:46:26 <ion> Computers’ internal clocks shouldn’t know about crap like leap seconds. They should be monotonic and leap seconds should only be handled by the code that renders the timestamp into a human-readable time.
05:46:40 <kstt> earthy: exactly yes
05:47:02 <benmachine> ion: that's a reasonable but false expectation :P
05:47:25 <ion> Yeah, i know that is not the case. That’s why i said “should”. :-P
05:48:33 <kstt> earthy: or, to be exact, with a small variation : in case of no usage at all, the cache must eventually become empty. That means that I can't rely on a new insertion event to push out the oldest item.
05:48:57 <earthy> ah, yes
05:49:03 <kstt> that's the reason for the asynchronous clearing loop.
05:50:49 <kstt> what I'm looking here is ideas to leverage the best of haskell concurrency strenghts to implement that better than just this dumb clocking loop
05:54:41 <typoclass> benmachine: honestly, use ntp to synchronize your system time every few days, and if it sometimes adjusts by an extra second, so be it. i bet the little quartz clock in your server is a ten times bigger source of error than leap seconds, so ntp or an equivalent will be needed anyway
05:54:53 <typoclass> benmachine: do you have more information how the leap second crashed your server?
05:55:31 <benmachine> typoclass: no, it's not just my server and I think someone else investigated
05:56:07 <benmachine> typoclass: what *I'm* doing is writing a program which, given today's date and a future date, tells you how far away it is
05:56:21 <benmachine> well, a future date and time
05:56:43 <benmachine> if you want to be perfectly accurate on that, you /do/ need to know if there are any leap seconds between then and now
05:56:54 <benmachine> I'm fine with not being perfectly accurate in practice
05:57:03 <benmachine> but in principle I'd like to know if there's a good way to solve the problem
05:57:18 <benmachine> the thing is the time library is set up to deal with leap seconds
05:57:47 <benmachine> and to parse a dat file of them
05:58:05 <benmachine> I just don't have that dat file
05:58:22 <benmachine> it would be nice if there was a standard location on disk and, like, a system package
05:58:25 <benmachine> that kept it up-to-date
05:58:32 * benmachine shrug
05:58:34 <typoclass> benmachine: right. if (for nerd cred or whatever) you do need single-second precision over spans of several years, then that's impossible, because future leap seconds are announced at some months notice. you'd have to know all the future leap seconds
05:58:50 <typoclass> benmachine: right, that'd be good
05:58:53 <benmachine> typoclass: not over several years, but over several weeks
05:58:56 <benmachine> would be nice
05:59:13 <benmachine> anyway, programming is hard, I'm going shopping
05:59:40 <typoclass> benmachine: while you're at the shop, grab me a leap second ...
05:59:48 <kstt> benmachine: there is a philosophical question of the date of things in the future
05:59:48 <merijn> Is there a lookup up for maps that will insert a default value if the key isn't found?
05:59:55 <benmachine> typoclass: how about I just leap, and it takes a second
06:00:05 <kstt> merijn: findWithDefault ?
06:00:08 <arcatan> hmm, i wonder why there's no OS X installer for GHC 7.6.1 as there used to be for the previous versions
06:00:21 <merijn> kstt: Doesn't update the map
06:00:46 <merijn> kstt: It just returns said default, and I want to return it *and* insert for future lookups
06:00:53 <merijn> (think memoisation)
06:01:08 <benmachine> merijn: insertLookupWithKey?
06:02:21 <merijn> benmachine: heh, I read that twice without understanding it does what I want >.>
06:02:47 <benmachine> merijn: the docs have an example of how to define insertLookup using it
06:02:50 <typoclass> benmachine: anyway, afaiu your code would have to periodically download a table or announcement of leap seconds. either you feed it into the TAI module in Data.Time, or if you want to do it yourself, you'd have to check if your span covers a leap second and then add or subtract 1 second from it
06:02:51 <benmachine> which might be what you want
06:03:08 <benmachine> typoclass: I was planning to use the TAI module
06:04:12 <typoclass> benmachine: yeah. last i looked, it had code to parse files that contain leap second tables, but it stopped short of actually including one of those tables
06:04:26 <benmachine> typoclass: right, because any such table would fall out of date
06:04:53 <benmachine> typoclass: so it would be nice if there was a standard location on a system where you could get "the most up-to-date table available" or whatever
06:07:42 <typoclass> yeah, but otoh, with enough time, any source code file falls out of date ;) a table file with one new line every 12 months would probably be among the slower-changing files in base
06:15:42 <nus> arcatan, http://www.haskell.org/ghc/dist/7.6.1/ghc-7.6.1-x86_64-apple-darwin.tar.bz2 ?
06:16:30 <nus> oh, you mean a .pkg
06:16:42 <arcatan> yes
06:17:36 <sarfraz> Hello, can someone help me with my paste? The answer must be simple but can't see it...
06:17:44 <sarfraz> http://hpaste.org/74526
06:18:43 <ion> You have indented the import lines.
06:18:44 <Jetbeard> sarfraz, I think I see the problem, let me test it out quickly
06:19:27 <Jetbeard> oh yeah, the import lines are indented, that'll break things
06:19:55 <Jetbeard> but also, oneOf isn't right
06:20:05 <sarfraz> i feel stupid...
06:20:17 <sarfraz> how?
06:20:40 <Jetbeard> (||) has type Bool -> Bool -> Bool
06:21:00 <Jetbeard> but you're applying it to two values of type (String -> Bool)
06:21:06 <Jetbeard> and hoping to get a (String -> Bool) out of it
06:21:18 <sarfraz> oh ok
06:21:25 <sarfraz> thanks ;)
06:22:46 <Jetbeard> The simple way to define it would be oneOf x = (x /= ".") || (x /+ "..")
06:22:52 <Jetbeard> uh, typo
06:23:04 <maukd> oneOf = const True
06:23:05 <Jetbeard> You could also define it point-free as oneOf = not . (`elem` [".", ".."])
06:23:26 <ion> (\x -> foo x || bar x) == liftA2 (||) foo bar
06:23:27 <maukd> oneOf = (`notElem` words ". ..")
06:24:02 <Jetbeard> okay, once again, everybody knows more than me :)
06:24:16 <sarfraz> ok cool thx
06:25:09 <sarfraz> what does liftA2 do?
06:25:36 <Ptival> :t liftA2
06:25:37 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
06:26:57 <Jetbeard> sarfraz, as far as the current example is concerned, I think this would be a suitable minimal definition
06:26:58 <Jetbeard> liftA2 c f g x = (f x) `c` (g x)
06:27:42 <Ptival> yes
06:27:54 <Jetbeard> so in your case it turns a function of type (Bool -> Bool -> Bool) into a function of type (String -> Bool) -> (String -> Bool) -> (String -> Bool)
06:28:55 <typoclass> sarfraz: 99% the same as liftM2. the difference is that it works for Applicatives, not only Monads, so if you ever need to use something that is an Applicative but no Monad, ...
06:30:59 <Jafet> @instances Applicative
06:31:00 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
06:31:07 <Jafet> @instances-importing Control.Applicative Applicative
06:31:07 <lambdabot> ((,) a), ((->) a), Const m, ContT r m, Either e, ErrorT e m, IO, Maybe, ReaderT r m, StateT s m, WrappedArrow a b, WrappedMonad m, WriterT w m, ZipList, []
06:32:58 <sarfraz> ok I'm not too good with functor and monads but I think I see. thx again
06:41:29 * hackagebot file-embed 0.0.4.5 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4.5 (MichaelSnoyman)
06:47:19 * hackagebot clientsession 0.8.0.1 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.8.0.1 (MichaelSnoyman)
06:51:50 <merijn> I need an in memory blob of Word8, what's the best way to get that? I could use the FFI malloc functions, but then I need to free them myself, isn't there a way to get the RTS to do the GC for me?
06:53:09 <kstt> isn't that a bytestring ?
06:53:56 <Jafet> Data.Storable Data.Array.UArray Data.ByteString
06:54:00 <ineff> Hello everyone
06:54:16 <merijn> kstt: No, because afaik bytestrings are not guaranteed to be a single consecutive piece of space and I need to pass said memory to C
06:54:40 <merijn> I think I want mallocForeignPtrBytes or one of the other Foreign.ForeignPtr functions
06:56:07 <typoclass> merijn: i think i saw some "alloca" functions, either in Foreign.Whatever or in Xlib
06:56:24 <merijn> typoclass: Yeah, but you need to manually free those
06:56:25 <Jafet> @hoogle alloca
06:56:25 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
06:56:25 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
06:56:25 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
06:56:29 * hackagebot http-conduit 1.6.0.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.6.0.2 (MichaelSnoyman)
06:56:58 <Jafet> Clever
06:57:03 <merijn> typoclass: I found mallocForeignPtrArray which allocates memory with a finalizer (i.e. haskell will do the GC for me when the pointer stops being used)
06:57:28 <typoclass> merijn: more or less ... you pass it the computation which can use the memory as long as it runs. it's like a "withHandle $ \h -> do ..." function
06:58:02 <merijn> alloca does something different, btw. alloca allocates "on the stack"
06:58:32 <Jafet> Hi, I want to malloc in haskell but I don't want to write the free
06:58:39 <Jafet> Please help xoxo
06:58:59 <maukd> merijn: wat
06:59:26 <Jafet> You can attach a finalizer to any ForeignPtr
06:59:38 <typoclass> merijn: what i meant is, i'm pretty sure that with alloca you don't need any calls to free. it may or may not be what you meant
07:00:01 <Rc43> Hi, guys.
07:00:02 <merijn> maukd: That's what it does in C, the FFI equivalents are semi-similar in that they automatically free when their function argument returns
07:00:27 <Rc43> When we really need CPS?
07:00:37 <Jafet> You don't want to manually free, and you don't want to use something that does automatic free
07:00:38 <merijn> typoclass: Yeah, but you can only use those once, I think. Where I need to keep the memory around for a while
07:00:46 <Jafet> u mad dawg?
07:00:47 <merijn> Jafet: I do, that's what I just said
07:01:08 <merijn> Jafet: Where did I say I don't want an automatic free? I already said I found mallocForeignPtr >.>
07:01:20 <Rc43> I just write a function for parsing nested expressions with brackets with CPS, but then I realized that I could just use function returning a tuple of result and remainder of a string.
07:01:42 <Rc43> *wrote
07:02:20 <Jafet> Ok. But giving a solution and then continuing is a convention for rejecting the solution
07:03:28 <timthelion> Is it possible to mark a bit of memory in linux as being "unimportant"?  Say I have a moimized list which is faster to read from memory, but could just as easilly be computed... Is there a good way to tell the kernel to keep the memory arround only if there is a lot of memory availiable, but to discard it if memory runs low?
07:03:50 <bartavelle> what do you mean by "discard" ?
07:03:52 <typoclass> timthelion: madvise? not sure
07:04:02 <Sculptor> hey
07:04:05 <geekosaur> madvise(MADV_DONTNEED)
07:04:20 <timthelion> typoclass, geekosaur, thanks, I'll look into it.
07:04:21 <Jafet> I thought all memory in linux was considered unimportant
07:04:22 <merijn> Jafet: I was just responding to typoclass separately from my own answer
07:04:28 <bartavelle> it isn't actually discarded, and if it is memoized, it means you need it to be hot
07:04:32 <bartavelle> or not exist at all
07:04:33 <Jafet> Except possibly kernel memory
07:05:23 <timthelion> well I'd like it to actually be de-alocated.  Like if we have a thunk in GHC runtime, the thunk could be reverse updated.
07:05:27 <Jafet> rc43: that doesn't sound like CPS
07:05:45 <geekosaur> Jafet, it can all be jettisoned under some circumstances but even so there are some preferences.  it will try to avoid recycling the most recently used memory, for example, and MADV_DONTNEED is a way to tell it not to apply that ti a particular chunk of memory
07:05:47 <Jafet> Your bracket parser never returns?
07:06:00 <typoclass> Jafet: unimportant in the sense of "can be swapped out", but that's different from being deallocated
07:06:35 <Jafet> I guess this means jokes about overcommit are getting old
07:06:44 <bartavelle> timthelion, then it is not kernel related, but runtime related
07:06:54 <bartavelle> it is not os dependant at all
07:07:50 <bartavelle> MADV_DONTNEED will not do what you want at all
07:07:53 <geekosaur> oh, yeh, deallocation is different and up to the app.
07:08:07 <timthelion> bartavelle: no no, you don't understand. It MUST be kernel related!  You see, if I have two applications running, say firefox and openoffice.  And firefox had cached images in memory that could easilly be re-requested from the server.  Then it would actually WANT to tell the KERNEL that those images could be free-ly de-alocated if the kernel needed memory for open-office.
07:08:30 <bartavelle> but your runtime has to understand it has been de allocated
07:08:37 <geekosaur> MADV_DONTNEED controls whether a chunk of physical memory will be possibly swapped out, then given to some other process.  it does not affect its presence in process virtual memory at all
07:08:56 <timthelion> bartavelle: of course.  You could, for example, have a special function for accessing such memory.
07:09:19 <Rc43> Jafet, when I meet ')' I call new parsing function which takes joining function as continuation. It is necessary for avoiding searching insertion point of parsed subexpression.
07:09:27 <Rc43> Jafet, I will paste code now.
07:09:42 <geekosaur> timthelion, that can't be done by thekernel.  it has to be done by the application; the kernel has no clue that a given chunk of memory has that meaning
07:10:13 <Jafet> geekosaur: pooh, not until we add another few system calls
07:10:19 <timthelion> geekosaur: What you mean to say is "unfortunately that usefull bit of functionality has yet to be implemented in lunux :)"
07:10:21 <bartavelle> it could be possible for some process to send a message to subscribed applications telling them it would be nice if they freed some memory
07:10:30 <geekosaur> timthelion, sorry, no.
07:10:44 <bartavelle> but you can do it yourself
07:10:49 <bartavelle> just check free memory
07:11:05 <bartavelle> and stop referencing stuff if it reaches a threshold
07:11:12 <geekosaur> this requires tight coordination between the OS and the app, because the OS could only know this stuff for itself by having the app implemneted solely as system calls
07:11:15 <geekosaur> think about it
07:11:19 <Jafet> rc43: the latter is how combination parsers generally work (eg. Read)
07:11:23 <bartavelle> then hope for the GC to remove it, and memory to be contiguous enough so that pages are actually released
07:11:30 <timthelion> bartavelle: that doesn't work nearly as well. because then every process would constantly be de-allocacting to allow firefox to enarge it's cache...  You need a way of policing the system.
07:11:48 <bartavelle> timthelion, you write the policing system, so it is easy
07:11:58 <bartavelle> (to realize this is a hard problem)
07:12:00 <Rc43> Jafet, ok, so why not to use tuples? (May be parsec works such way.)
07:12:17 <Jafet> :t reads
07:12:18 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:12:24 <Jafet> There, the tuple
07:12:24 <timthelion> bartavelle: I never said it was easy.  I just said that it cannot be done with the naive implementation of looking at "free"
07:12:34 <geekosaur> and I'm vaguely reclaling research indicating that for all but a few specialized usages, this kind of thing actualy works out to be inefficient
07:12:41 <hpaste> Rc43 pasted “CPS brackets parsing” at http://hpaste.org/74528
07:12:43 <Jafet> parsec hides the tuple in a monad instance
07:12:52 <bartavelle> timthelion, then you can look at each process memory usage and write your policy based on that
07:13:01 <bartavelle> it doesn't have to be in kernel land
07:13:12 <bartavelle> and I'd say it better not be
07:13:13 <Rc43> Jafet, yes; but what difference?
07:13:14 * timthelion gives up on the conversation
07:13:31 <Rc43> Jafet, http://hpaste.org/74528
07:14:37 <geekosaur> timthelion, that's probably for the best then.  I'm sure you have a good idea of what you want, but you have no idea of how the kernel/userspace boundary makes it difficult to impossible
07:14:44 <Jafet> CPS is harder to write and usually you don't need its flexibility
07:15:05 <Jafet> Look at how that code has to plumb cont through everything
07:15:10 <geekosaur> sure there are ways to do it.  either move the kernel into the process or the process into the kernel...
07:15:35 <geekosaur> or take a huge context switching hit that except in strange cases swamps the positive effects
07:15:50 <bartavelle> add some new messages to dbus
07:16:27 <Rc43> Jafet, can you give me an example or say what can I read about CPS advantages? When it is irreplaceable?
07:16:29 * hackagebot authenticate 1.3.1.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.1.1 (MichaelSnoyman)
07:16:31 * hackagebot wai-app-static 1.3.0.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.0.1 (MichaelSnoyman)
07:16:33 * hackagebot wai-extra 1.3.0.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.0.1 (MichaelSnoyman)
07:16:35 * hackagebot warp-tls 1.3.0.1 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.3.0.1 (MichaelSnoyman)
07:16:38 * hackagebot mime-mail-ses 0.2.0.5 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.0.5 (MichaelSnoyman)
07:17:55 <Jafet> I don't know any reading material. But CPS is useful as a mental model for writing certain programs.
07:20:29 <merijn> If I use TypeFamilies can I use the defined type functions outside of the scope of their class? i.e. "class Foo a where type FooType a :: *" and then use FooType in any type signature as long as FooType is in scope
07:21:33 <Jafet> How else would you use them
07:21:40 * hackagebot monad-logger 0.2.0.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.2.0.1 (MichaelSnoyman)
07:21:42 * hackagebot yaml 0.8.0.2 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.8.0.2 (MichaelSnoyman)
07:22:44 <merijn> Jafet: Only in the scope of the type family?
07:23:07 <merijn> i.e. within the class declaration
07:25:26 <larsrh> Anybody got experience with HFuse? (Investigating how to implement a file system in Haskell)
07:26:30 * hackagebot shakespeare 1.0.1.2 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.1.2 (MichaelSnoyman)
07:27:05 <Jafet> Hm, it seems that data family constructors are only available to the instance
07:27:13 <larsrh> On a related note, I think I'm going to need a "route" library (user specifies path mappings like "attr/author/*" -> listByAuthor where listByAuthor :: String -> [Item])
07:27:21 <larsrh> Is there such a library which is not tied to any web framework?
07:28:46 <Jafet> Another tagging file system?
07:29:10 <larsrh> Quite.
07:31:18 <larsrh> Jafet: I happily take input though, so it'd be nice if you could give me some links to other tagging file systems
07:31:30 * hackagebot funcmp 1.7 - Functional MetaPost  http://hackage.haskell.org/package/funcmp-1.7 (PeterSimons)
07:34:08 <Jafet> It is strangely unfortunate that I don't know about any
07:36:03 <larsrh> Jafet: Then why "another"? :)
07:36:54 <Jafet> I did mention it is strange.
07:38:17 <Jafet> This is the sort of thing that seems trendy and there are always a few research papers on it, but there is never a well developed implementation
07:38:49 <larsrh> I "implemented" such a thing in C++ as my Bachelor's thesis, now I'm planning to try harder
07:40:25 <larsrh> (just as a hobby project, that is)
07:41:30 <larsrh> If it turns out to fail, well then, I still gained some Haskell experience (which is the ultimate goal I guess)
07:41:40 <Jafet> I think you could get surprisingly far with a fuse veneer to a relational database.
07:42:29 <atriq> I think I'm beginning to grok control-lens
07:46:30 * hackagebot dtd 0.6.1 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-0.6.1 (MichaelSnoyman)
07:47:09 <atriq> By thinking of it as a setter that is also a getter
07:47:21 <atriq> What do Const r and Identity have in common?
07:47:29 <atriq> A bunch of instances!
07:47:44 <atriq> The simplest of which that is useful in this context is Functor!
07:51:32 * hackagebot html-conduit 0.1.0.1 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-0.1.0.1 (MichaelSnoyman)
07:51:34 * hackagebot uri-conduit 0.5.0.1 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-0.5.0.1 (MichaelSnoyman)
07:51:36 * hackagebot xml-conduit 1.0.3.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.0.3.1 (MichaelSnoyman)
07:51:38 * hackagebot xml-hamlet 0.4.0.1 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.1 (MichaelSnoyman)
07:51:58 <benmachine> instance Functor (Const r) where fmap _ = unsafeCoerce
07:52:11 <benmachine> (jk)
07:52:25 * Clint wonders about the use case for a URI conduit.
07:52:35 <benmachine> (strictly speaking, safe, but not recommended)
07:53:26 <atriq> benmachine, have you seen the evil program I wrote?
07:53:36 <benmachine> atriq: no
07:53:44 <atriq> http://hpaste.org/raw/71201
07:54:01 <lpvb> that can be fixed with vim
07:54:09 <lpvb> no
07:54:11 <lpvb> it's evil
07:54:43 <benmachine> atriq: neat
07:55:07 <benmachine> atriq: basically SK combinators with extra stuff to make it typecheck?
07:55:15 <atriq> You're good at this
07:55:20 <atriq> Yeah, that exactly
07:56:30 * hackagebot classy-prelude 0.3.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.3.0 (MichaelSnoyman)
07:56:39 <applicative> the Functor constraint does  make various nutty things possible, e.g.  _1 show (122,'x')   ==> [('1','x'),('2','x'),('2','x')]
07:56:54 <applicative> i mean the Functor constraint in Control.Lens
07:56:56 <atriq> Wow, heh
07:58:03 <MostAwesomeDude> I don't see a problem here. :3
07:59:08 <SLi> Why is there no castToListStore in gtk2hs? How do I read a liststore from a glade-generated model?
07:59:33 <SLi> For example, for windows: mainWindow <- builderGetObject builder castToWindow "main_window"
08:01:32 * hackagebot classy-prelude-conduit 0.3.0.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.3.0.0 (MichaelSnoyman)
08:02:29 <applicative> MostAwesomeDude: no, that one doesn't seem bad, maybe one could be more inventive :)
08:02:55 <atriq> benmachine, I could make it worse much easily
08:03:01 <atriq> But I like the formatting as it is
08:03:02 <benmachine> atriq: that's great to hear
08:03:09 <atriq> The formatting is the most tedious bit
08:03:16 <atriq> (the rest of it is really quite fun)
08:03:18 <benmachine> :P
08:03:25 <benmachine> I can imagine the rest being fun actually
08:04:22 <atriq> For instance, I could replace (>>) with pure (<*>) <*> (pure (pure (pure <*> pure)) <*>)
08:04:34 <MostAwesomeDude> What.
08:04:36 <hpaste> merijn pasted “typeclass hackery” at http://hpaste.org/74534
08:04:41 <atriq> Except I can't
08:04:49 <atriq> GHC doesn't like it
08:05:02 <MostAwesomeDude> :t pure (<*>) <*> (pure (pure (pure <*> pure)) <*>)
08:05:03 <lambdabot>     Ambiguous type variable `f' in the constraint:
08:05:03 <lambdabot>       `Applicative f'
08:05:03 <lambdabot>         arising from a use of `pure' at <interactive>:1:37-40
08:05:10 <merijn> In the code I just pasted GHC can't infer the Foo restriction in my Bar instance declaration, is there any way to get that to work?
08:05:26 <merijn> Or should I just suck it up and add the extra "Foo h" prereq
08:05:26 <atriq> If you make it stick to the ((->) r) Applicative it's equivalent to (*>)
08:07:01 <atriq> merijn, I don't think you can make that work without the prereq
08:07:29 <merijn> oh, duh
08:07:51 <merijn> It's because of the open world allowing for different instances where the restriction does not apply
08:08:03 <merijn> IOW, once again I wish for instance chains xD
08:28:51 <MostAwesomeDude> Aha! My performance problems are solved.
08:29:01 * benmachine takes that out of context
08:29:02 <MostAwesomeDude> I had been measuring FPS using a simple MMA.
08:29:15 * Clint takes that out of context
08:29:17 <MostAwesomeDude> I was wondering why I couldn't break the 42 FPS mark...
08:30:00 <MostAwesomeDude> But it's because my MMA was integral and I was using a large weight.
08:30:16 <MostAwesomeDude> After switching to floats, magically I get 55-59 FPS. Yay!
08:30:31 <Saizan> MMA?
08:31:06 <MostAwesomeDude> Modified Moving Average.
08:31:52 <lpvb> googling for that acronym turns up countless results for mixed martial arts
08:32:01 <MostAwesomeDude> :t \new old -> (19 * old + new) / 20
08:32:02 <lambdabot> forall t. (Fractional t) => t -> t -> t
08:32:35 <MostAwesomeDude> > (\new old -> (19 * old + new) / 20) 60 55
08:32:36 <lambdabot>   55.25
08:33:37 <MostAwesomeDude> The past n values are captured in the old value, weighted by an exponential curve. Turns out that if you tune the curve to e, you can elide all of the funky maths and have this cute little formula instead.
08:33:41 <MostAwesomeDude> This one's for n=20.
08:34:18 <MostAwesomeDude> It's really useful for things like FPS. You can use this formula to smooth out the noise inherent in your timers, and get a relatively stable number.
08:35:01 <mm_freak> MostAwesomeDude: http://darcs.ertes.de/netwire/Control/Wire/Prefab/Analyze.hs
08:35:07 <mm_freak> see the 'avg' wire
08:35:38 <mm_freak> it has exactly that algorithm and gets well beyond a few million FPS
08:36:11 <mm_freak> O(n) space, O(1) time
08:36:45 <MostAwesomeDude> mm_freak: Well, I'm gonna be quite happy with 60 FPS. :3
08:37:09 <Botje> nobody will ever need more than 60FPS.
08:37:10 <mm_freak> well, actually avgAll has that algorithm
08:37:17 <mm_freak> Botje: for graphics
08:37:32 <mm_freak> there are other frame-based applications where you want as many FPS as possible
08:37:43 <MostAwesomeDude> Video encoding, for example.
08:38:19 <mm_freak> btw, for video manipulation i'd use a comonad
08:39:23 <mm_freak> MostAwesomeDude: use 'avg' if you have a sliding window, 'avgAll' if you actually want the mean over all samples ever produced
08:39:37 <mm_freak> avgAll has O(1) space and time
08:39:47 <MostAwesomeDude> mm_freak: Nifty. I'm not quite ready to jump over to netwire, but it's definitely interesting.
08:40:34 <mm_freak> actually there is even a predefined wire for average frames per second called avgFps in that module =)
08:41:45 <MostAwesomeDude> My main concern is that I'm gonna have to write a bunch of stuff to turn SDL's events into FRP events before I can really embrace any FRP.
08:42:23 <mm_freak> well, i'm just finishing the Control.Wire.Trans.Switch module, then i'll release
08:42:31 <mm_freak> after that i'm planning to write netwire-sdl
08:42:39 <mm_freak> so you won't have to do that
08:42:50 <mm_freak> also it's actually quite easy
08:42:57 <hbIppo> @src Maybe fmap
08:42:57 <lambdabot> fmap _ Nothing       = Nothing
08:42:57 <lambdabot> fmap f (Just a)      = Just (f a)
08:59:38 <hbIppo> I want to extend the concept of identity matrix for monoids
08:59:47 <hbIppo> I can use mempty instead of 1
08:59:54 <hbIppo> but what do I use for 0?
09:01:25 <Ferdirand> forgive me if i'm wrong, but don't you need to have at least a ring, if you want to do matrix multiplication ?
09:01:55 <hbIppo> you are probably right... it's been ages since my algebra exam
09:02:04 <hbIppo> I might have the book somewhere, let me check
09:02:13 <gdeest> Ferdirand: a semi-ring is OK, I think
09:03:05 <Ferdirand> gdeest: ah yes, probably.
09:05:54 <hbIppo> mmm
09:05:59 <hbIppo> according to my book
09:06:02 <hbIppo> you need a field
09:06:25 <hbIppo> so definitely no, I can't do this for monoids
09:07:05 <gdeest> hbIppo: No, you definetely do NOT need a field.
09:07:11 <gdeest> Your textbook is too restrictive
09:07:18 <gdeest> But a monoid has only a single law
09:07:21 <gdeest> and youd need to
09:07:28 <gdeest> *two
09:07:31 <gdeest> that settles it
09:07:49 <hbIppo> mmm ok...
09:08:20 <hbIppo> thanks
09:08:32 <hbIppo> and is there any such structure in haskell, by chance?
09:09:06 <gdeest> a "Ring" typeclass, for example ?
09:09:07 <rwbarton> I just use Num
09:09:18 <rwbarton> and don't define abs or signum
09:09:57 <hbIppo> yes, like a Ring typeclass
09:10:10 <hbIppo> Ring is not on Hoogle I see
09:10:13 <hbIppo> so I guess it's a no
09:11:55 <geekosaur> hoogle only does the bootlibs; there's nothing in the bootlibs for it but see for example the numeric-prelude package on hackage
09:12:19 <krakrjak> hbIppo: Numeric-Prelude has a ring
09:12:43 <hbIppo> krakrjak: thanks
09:12:55 <hbIppo> and geekosaur too
09:14:28 <rwbarton> "class C a => C a where" ugh
09:15:19 <Saizan> oh, it's one of those libs
09:15:39 <hbIppo> rwbarton: where is it from?
09:15:44 <rwbarton> numeric-prelude
09:16:02 <rwbarton> in probably every single module
09:16:16 <rwbarton> okay, I guess there has to be at least one that just says "class C a where" :)
09:16:22 <geekosaur> I seem to recall it's filled with ugly hacks because typeclasses don't quite do what it wants.  (for example the two-monoids issue)
09:27:44 <applicative> rwbarton: oh, right the classes and the types are supposed to be exported as Ring.C  Group.C  ? I remember it was maddening
09:31:41 <dncr> when would you prefer Generic over Data/Typeable?  and vice versa?
09:40:27 <Jesin> hi jesyspa
09:40:50 <jesyspa> Er, hello.
09:45:24 <mm_freak> scissor cohands with the edwardk
09:46:33 * hackagebot skein 0.1.0.9 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.9 (FelipeLessa)
09:56:21 <edwardk> mm_freak: is that like the dual of the vulcan greeting?
09:57:09 <edwardk> a sort of 'die quickly and go f yourself'?
10:03:45 <conal> Oops. My blog (http://conal.net/blog) went down due to full disk on server. Back up now.
10:04:13 <benmachine> oh, I noticed that, sorry, I'd've told you but I assumed you knew
10:04:27 * benmachine will assume less in future
10:08:45 <XexonixXexillion> How does haskell know if a unicode character is a letter or a symbol?
10:10:00 <typoclass> > (generalCategory 'F', generalCategory '␣') -- XexonixXexillion: it's from Data.Char, iirc
10:10:01 <lambdabot>   (UppercaseLetter,OtherSymbol)
10:10:18 <typoclass> > generalCategory '+'
10:10:19 <lambdabot>   MathSymbol
10:10:22 <geekosaur> and the definitions are taken from the unicode standard
10:10:25 <benmachine> there's also isAlpha, isSymbol
10:10:35 <XexonixXexillion> > generalCategory '⍴'
10:10:36 <lambdabot>   OtherSymbol
10:11:17 <XexonixXexillion> > map generalCategory "S[⍒⍳⍴S]"
10:11:18 <lambdabot>   [UppercaseLetter,OpenPunctuation,OtherSymbol,OtherSymbol,OtherSymbol,Upperc...
10:11:57 <XexonixXexillion> > generalCategory 'λ'
10:11:58 <lambdabot>   LowercaseLetter
10:12:08 <typoclass> > let (⍳) = (+) in 1 ⍳ 2 -- weird ...
10:12:10 <lambdabot>   3
10:12:48 <arcatan> hmm, did something just happen to hackage.haskell.org dns entry
10:12:59 <XexonixXexillion> > let (⍳) = enumFromTo 1 in ⍳ 5
10:13:00 <lambdabot>   <no location info>: parse error on input `
10:13:38 <XexonixXexillion> > let (⍳) = enumFromTo 1 in (⍳) 5
10:13:40 <lambdabot>   [1,2,3,4,5]
10:13:47 <XexonixXexillion> > let ⍳ = enumFromTo 1 in ⍳ 5
10:13:48 <lambdabot>   <no location info>: parse error on input `
10:14:10 <XexonixXexillion> > let (⍳) = enumFromTo 1 in 5 ⍳
10:14:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:14:45 <XexonixXexillion> how can I write it such that ⍳ 5 is enumFromTo 1 5?
10:15:01 <newsham> make it lowercase
10:15:02 <maukd> no
10:15:04 <mm_freak> edwardk: how would that go?  "quick codiely and cofuck yourself"?
10:15:39 <XexonixXexillion> > generalCategory '⍳'
10:15:40 <lambdabot>   OtherSymbol
10:15:47 <XexonixXexillion> it's a symbol apparently
10:16:04 <typoclass> XexonixXexillion: if the function's name is a symbol, you can use it infix: "argument1 functionname argument2". you need two arguments, however
10:16:30 <XexonixXexillion> can I not have a function which is a symbol and not infix?
10:16:37 <mm_freak> > let (⍳) = enumFromTo 1 in (⍳) 5
10:16:39 <lambdabot>   [1,2,3,4,5]
10:16:59 <typoclass> if you put the name in parens like that ^^ then you can
10:17:00 <mm_freak> XexonixXexillion: you can, with an extension
10:17:39 <mm_freak> > let (⍳) = enumFromTo 1 in (5 ⍳)
10:17:40 <lambdabot>   [1,2,3,4,5]
10:18:05 <mm_freak> apparently lambdabot has that extension enabled
10:18:25 <mm_freak> > let (!) n = product [1..n] in (5!)
10:18:26 <lambdabot>   120
10:19:13 <XexonixXexillion> let (⍋) = sort in ([1,2,5,6,2] ⍋)
10:19:17 <XexonixXexillion> > let (⍋) = sort in ([1,2,5,6,2] ⍋)
10:19:18 <lambdabot>   [1,2,2,5,6]
10:19:44 <typoclass> XexonixXexillion: lambdabot is also available in a private chat window
10:21:00 <XexonixXexillion> typoclass: I also could just use ghci, but it's 3am and my judgement is poor.
10:22:09 <XexonixXexillion> is there anyway to make the symbols prefix instead of postfix?
10:22:20 <mm_freak> XexonixXexillion: not without the result being a function
10:22:44 <typoclass> XexonixXexillion: either put them in parens (), give them another name
10:22:46 <mm_freak> > let (⍋) = const . sort in (⍋ [1,2,5,6,2]) ()
10:22:47 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
10:22:59 <mm_freak> > let (⍋) str _ = sort str in (⍋ [1,2,5,6,2]) ()
10:23:00 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
10:23:00 <typoclass> s/give/or give/
10:23:14 <mm_freak> > let (⍋) _ = sort in (⍋ [1,2,5,6,2]) ()
10:23:16 <lambdabot>   [1,2,2,5,6]
10:25:06 <identity> I can't use Text.Printf.printf with Data.Text? :(
10:25:15 <identity> boo
10:34:45 <XexonixXexillion> What do I have to tell ghc to get (s ⍴) to be valid?
10:36:27 <lpsmith> Unicode rho doesn't work already?  I dunno, I don't really use unicode in my sources.
10:36:38 * hackagebot persistent 1.0.1.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.0.1.1 (MichaelSnoyman)
10:36:40 * hackagebot persistent-mongoDB 1.0.1.0 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.0.1.0 (MichaelSnoyman)
10:36:42 * hackagebot persistent-template 1.0.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.0.0.1 (MichaelSnoyman)
10:36:50 <typoclass> > (generalCategory '⍴', generalCategory 'ρ') -- XexonixXexillion, i think you're using the wrong kind of rho
10:36:51 <lambdabot>   (OtherSymbol,LowercaseLetter)
10:37:21 <typoclass> the first will be treated as infix, the second will be treated as a function name (regular lowercase letter)
10:39:04 <XexonixXexillion> but with the letter I can't have s⍴
10:39:56 <int80_h> hiya
10:40:06 <int80_h> http://hpaste.org/74538
10:41:16 <typoclass> XexonixXexillion: well, that would be parsed as one single function name then (two lowercase letters)
10:41:45 * hackagebot pool-conduit 0.1.0.3 - Resource pool allocations via ResourceT.  http://hackage.haskell.org/package/pool-conduit-0.1.0.3 (MichaelSnoyman)
10:41:47 * hackagebot stream-monad 0.4.0.2 - Simple, Fair and Terminating Backtracking Monad  http://hackage.haskell.org/package/stream-monad-0.4.0.2 (SebastianFischer)
10:42:08 <XexonixXexillion> typoclass: That's what I want to avoid. But I just realised that what I'm trying to do can't work as ⍴⍳ is not ⍴ ⍳
10:43:11 <XexonixXexillion> I was just trying to shoehorn the useful parts of APL into Haskell
10:43:22 <XexonixXexillion> albeit mirrored
10:43:29 <geekosaur> :t (==)
10:43:30 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:43:46 <geekosaur> ^^ int80_h, as stated the above means it is quite impossible
10:44:03 <geekosaur> One and Two are not the same type
10:44:54 <int80_h> geekosaur: Yeah that's wher I got stuck. I was wondering if there was some typr trickery I wasn't aware of that would resolve this problem.
10:44:57 <maukd> @let a === b = cast a == Just b
10:44:58 <int80_h> type, too
10:44:59 <lambdabot>  Defined.
10:45:06 <maukd> > "yes" === 42
10:45:08 <lambdabot>   False
10:45:55 <geekosaur> ^^ there is that, but you can;t do it with Eq (without redefining Eq to be something like the above instead of what the Haskell standard says it is)
10:46:33 <typoclass> int80_h: look at it this way -- things can only be equal if they have the same type and the same value. in haskell, the first part is figured out at compile time, the second at runtime
10:46:58 <lpsmith> How many copies of rho does unicode have?
10:48:39 <hpaste> typoclass pasted “check this, lpsmith” at http://hpaste.org/74540
10:48:48 <sellout42> lpsmith: I count 26 if you include all caps/small and accented forms.
10:48:54 <maukd> lpsmith: I count 26
10:49:01 <maukd> oh, hey
10:49:17 <XexonixXexillion> The one I'm using is APL FUNCTIONAL SYMBOL RHO
10:50:25 <XexonixXexillion> For a more interesting challenge, how many copies of ⎕ are in unicode
10:50:48 <lpsmith> and,  I can maybe accept separate greek, APL, and mathematical rhos,  but all this superscript/font business....
10:50:56 <lpsmith> I'm not sure that belongs in unicode
10:50:57 <sellout42> Cairo was actually the name of and old language I created, based on the χ and ρ calculi. If I had realized there was a ☧ symbol, maybe I would have kept working on it ;)
10:51:14 <sellout42> an* old language
10:51:36 <lpsmith> well,  I think 3 major versions of Rho is what I was looking for.  (or 4?)
10:52:17 <XexonixXexillion> Greek, upper and lower, APL and maths
10:52:24 <XexonixXexillion> so 4
10:52:30 <lpsmith> 3 major variations,  with 25 variations if you acccount for case and math and stuff
10:53:15 <timthelion> XexonixXexillion: Does the cyrilic rho have a different name?
10:53:15 <lpsmith> err,  case, accents, and fonts
10:53:31 <yitz> XexonixXexillion: ¿ǝpoɔ ǝɔɹnos ɹnoʎ uו ǝpoɔוun ʇuɒʍ noʎ op ʎɥʍ
10:53:56 <timthelion> yitz: do you have some app for that?
10:53:57 <XexonixXexillion> yitz: Because it makes it easier to read
10:54:19 <timthelion> XexonixXexillion: For some people. For others no.
10:54:22 <lpsmith> I think we should start writing haskell using only homoglyphs.
10:54:32 <yitz> timthelion: no, not yet at least. typed it in ghci using escape codes.
10:54:55 <lpsmith>  lambda,  and homoglyphic variations thereof,  shall henceforth be the only identifiers allowed
10:54:59 <sellout42> timthelion: You mean “the cyrillic letter that looks like a P?” It’s called “er”.
10:55:00 <timthelion> yitz: you memorized the escape codes for upsidedown unicode ?
10:55:17 <yitz> timthelion: nope have them in a text file
10:55:31 <timthelion> sellout42: well of course it's called "er" but it's also from the greek alphabet, you know.
10:55:31 <XexonixXexillion> > 'р'
10:55:33 <lambdabot>   '\1088'
10:55:53 <timthelion> yitz: you should do an app for it and @let it into lambdabot directly.
10:56:29 <XexonixXexillion> nope, that's not on the list of rho
10:56:30 <yitz> timthelion: that would be fun :) don't have time at the moment though.
10:56:48 <lpsmith> we'll need a homoglyphic prelude, of course
10:57:28 <XexonixXexillion> Why not just use APL? :p
10:57:40 <hpaste> yitz pasted “Upside down Unicode” at http://hpaste.org/74543
10:58:05 <yitz> timthelion: it's missing j at the moment, and no punctuation
10:58:35 <timthelion> hrm
10:59:06 * timthelion bought a nice new SSD, and is wasting his 3000 writes recompiling stuff :/
10:59:35 <lpsmith> homoglyphic haskell would be even more awesome than APL
11:00:10 <yitz> lpsmith: we already have enough rhos for a rho-only dialect of lazy k
11:00:26 <lpsmith> hahaha
11:00:57 <XexonixXexillion> We have enough rhos for every keyword in smalltalk
11:01:30 <XexonixXexillion> Coming soon rhotalk :p
11:02:53 <timthelion> how would one read rhotalk?
11:05:21 <Dodek> timthelion: recompile stuff in ramdisk
11:09:19 <DanBurton> hackage down again?
11:09:23 <timthelion> Dodek: how do I do that with cabal?
11:12:37 <DanBurton> new-hackage down too :(
11:13:07 <timthelion> DanBurton: hackage is up for me
11:13:16 <timthelion> and even fast
11:13:28 <c_wraith> because many people can't reach it.
11:13:31 <c_wraith> that speeds it way up
11:14:41 <Dodek> timthelion: dunno.
11:14:53 <typoclass> third time now in the last few weeks ... :-(
11:16:26 <DanBurton> lol
11:16:45 <DanBurton> well thank goodness for luite's mirror
11:19:06 <hpaste> applicative annotated “Eq instance puzzle” with “Eq instance puzzle (annotation)” at http://hpaste.org/74538#a74544
11:19:15 <applicative> int80_h: ^^^ :)
11:20:22 <applicative> int80_h: woops wrong paste see the next one
11:22:56 <int80_h> applicative: thanks :)
11:24:11 <DanBurton> suppose I want to create a simple bar graph from some data [(Foo, Bar)]. Does diagrams do that, and if so, how?
11:24:51 <DanBurton> byorgey: ^
11:26:46 <fryguybob> DanBurton: You can fairly easily build some thing for that with Diagrams.
11:26:54 <fryguybob> DanBurton: See also: https://groups.google.com/forum/?fromgroups#!topic/diagrams-discuss/t1o7WVoTf2U
11:26:56 <sclv> grrr hackage
11:28:08 <DanBurton> fryguybob: thanks
11:29:28 <DanBurton> this looks pretty. I wonder if it's legit. http://hackage.haskell.biz/
11:32:15 <geekosaur> whois info is just a trifle sketchy IMO
11:33:58 <SeroPositief> Hey, is it possible to create a function f :: [a] -> a that returns the last element of a list in O(1), instead of iterating recursively in O(n)?
11:34:35 <lpvb> no
11:34:36 <geekosaur> not with a standard list, no
11:34:38 <Oejet> SeroPositief: No, not with the type build in list type: [].
11:34:48 <SeroPositief> oh okay
11:35:28 <Eduard_Munteanu> SeroPositief: use Data.Sequence if you need access to both ends efficiently
11:35:42 <SeroPositief> Ah thanks, I'll have a look
11:35:45 <hpaste> int80_h pasted “Type trickery ” at http://hpaste.org/74546
11:39:09 <DanBurton> can't install cairo :( it says it can't find gtk2hsC2hs, even though it is right there in ~/.cabal/bin, which is in my PATH
11:39:54 <typoclass> SeroPositief: however, before you switch data structures or implement one yourself, make measurements if that particular function is indeed a bottleneck in your program
11:40:25 <geekosaur> int80_h, there may be a type-indexed map somewhere, otherwise Data.Typable *might* help as long as they're all nullary constructors
11:40:31 <SeroPositief> Oh no, I'm not trying to solve an existig problem; I was just curious if it was possible at all
11:41:02 <int80_h> geekosaur: what's a nullary constructor?
11:41:23 <geekosaur> the kind of thing you've been using, no parameters.  or like Nothing, as opposed to Just which is unary
11:41:31 <geekosaur> (number of parameters)
11:41:53 <int80_h> geekosaur: Okay I will investigate Typeable
11:41:54 <typoclass> int80_h: is it possible to write that as data Foo = Foo | Bar | Baz? you'd have no trouble putting that in a Map
11:42:20 <int80_h> typoclass: Not possible, the design of the larger program prohibits it.
11:42:47 <KirinDave> .. This can't be right.
11:42:56 <geekosaur> you are probing all the pain points of Haskell program design, misdesigned types are not happy-making
11:43:34 <KirinDave> What the...
11:43:37 <KirinDave> At first I thought maybe hackage was down.
11:43:51 <KirinDave> But I can connect to hackage only when IRC is up. If I quit out I can't load it again.
11:43:57 <KirinDave> How is that even...?
11:43:58 <Lutin`> KirinDave: Your name...I know you
11:44:27 <KirinDave> Lutin`: Perhaps.
11:45:12 <typoclass> int80_h: you could just make 3 Maps, possibly in a tuple. also, it'd help if you told us a little more about the big picture of what you're doing. to me, it so far sounds a little bit 'cart before the horse'
11:45:13 <geekosaur> KirinDave, your IRC connection is configured in a way which brings up a tunnel or proxy connection of some kind?
11:45:18 <KirinDave> geekosaur: No!
11:45:29 <KirinDave> geekosaur: It must be some very weird thing going on with the building's wifi?
11:45:35 <KirinDave> It wasn't down for everyone else, right?
11:45:37 <hpaste> DanBurton pasted “cabal install cairo - baffling error” at http://hpaste.org/74547
11:45:58 <lpvb> does haskell have a real hashmap type?
11:46:10 <c_wraith> many of them
11:46:11 <DanBurton> can anyone explain to me what is going on here? ^
11:46:22 <int80_h> typoclass: okay typoclass, I'll hpaste the "big picture" in a moment. It could be, there's a simpler solution to the overall problem.
11:46:23 <Cale> lpvb: There's an unordered-collections package on hackage which has a hashmap
11:46:29 <DanBurton> lpvb: define "real hashmap"
11:46:30 <geekosaur> KirinDave, not that I've seen.  could however also  possiblybe some ancient on-demand ADSL/dialup with a really short timeout, such that it's droppingbetween page loads and the browser is timing out waiting for it to come back up
11:46:35 <Cale> lpvb: It's sometimes better, and sometimes worse than Data.Map
11:46:38 <lpvb> not a tree
11:46:56 <Cale> A real hashmap can use a tree
11:47:09 <c_wraith> lpvb: you have a really narrow world-view.  broaden your horizons, man! :)
11:47:11 <geekosaur> DanBurton, what's going on there is that programs cannot resilve the literal ~s in your path
11:47:12 <typoclass> DanBurton: use moar verbose (-v3 or something), possibly even strace, to find out what files it's looking for in what places
11:47:15 <Cale> (in this case, it does, it's just a tree with large branching factor)
11:47:22 <geekosaur> only shells can expand ~
11:47:45 <DanBurton> geekosaur: mmm thanks I'll look into that
11:47:46 <lpvb> c_wraith: what should I be looking at?
11:47:57 <Cale> lpvb: look at unordered-containers
11:48:01 <thoughtpolice> Cale: i thought that in most cases, unordered-containers was noticeably faster, i thought tibbe had ironed out most of the inefficiencies
11:48:14 <Cale> thoughtpolice: Well, I thought so too
11:48:15 <typoclass> DanBurton: erm, scratch what i said :) geekosaur is right
11:48:17 <thoughtpolice> although i've no doubt there are workloads where regular containers performs better
11:48:34 <Cale> thoughtpolice: But I mentioned it as an option to someone the other day, and it turned out slower than Data.Map for that guy's program
11:48:44 <Lutin`> copumpkin: Wait what...I just realized I'm following you on a several year old twitter account
11:48:46 <geekosaur> I have a habit of using $HOME (which the shell will expand before setting it, unless you used single quotes) instead of ~ when setting $PATH so I don't have to worry about whether ~ is expanded by that particular version of that particular shell in that particular position... it does vary that much, I'm afraid
11:49:32 <KirinDave> I wish Text.html had some documentation.
11:49:39 <thoughtpolice> Cale: oh, interesting, what was the workload/usage pattern?
11:49:47 <KirinDave> Like, usage.
11:49:53 <Cale> thoughtpolice: I don't actually know, I wish I'd asked :)
11:50:14 <shapr> I started reading bos' statistics library, and quickly realized it's optimized in such a way that it's not immediately readable. Is there something like Naive.* or Readable.* where readability is the goal?
11:50:15 <copumpkin> Lutin`?
11:50:19 <thoughtpolice> hah, well, i'm not entirely surprised :)
11:50:25 <Lutin`> copumpkin: Oh wait #chronic-dev
11:50:49 <KirinDave> Haskell: bringing the world together.
11:50:53 <Lutin`> Small world haha
11:50:58 <Lutin`> You and KirinDave
11:50:58 <shapr> I started writing my own Statistics module that's designed to readable first and foremost, but I'm not sure whether to name it Naive.Statistics or Readable.Statistics
11:51:27 <copumpkin> Lutin`: oh, you mean jailbroken iphone stuff?
11:51:32 <Lutin`> Yeah
11:51:35 <thoughtpolice> shapr: i don't think so, there are some other stats packages though. a good namespace for 'simple, obviously correct models' of other stuff (like stats code) that you could verify against faster implementations would possibly be a good idea though
11:51:36 <timthelion> Well freenode is actually a relatively small comunity... Surprisingly.
11:51:37 <copumpkin> yeah, I've moved on from that :)
11:51:39 <shapr> KirinDave: I'm fond of Text.Blaze.Html
11:51:56 <Lutin`> Yeah I worked on that with you guys for a bit with the ipod touch 2nd gen
11:51:57 <hpaste> DanBurton annotated “cabal install cairo - baffling error” with “cabal install cairo - round two” at http://hpaste.org/74547#a74550
11:51:58 <LadyAurora> shapr: SlowNaiveAndStillUnreadable.Statistics.
11:52:05 <shapr> LadyAurora: Not gonna help me :-P
11:52:11 <thoughtpolice> shapr: in practice, lots of people tend to do similar stuff with quickcheck, where they'll write a basic, slow model, and just keep it around for verification as they try to make faster versions
11:52:19 <shapr> thoughtpolice: Right, that's the namespace I want, what are good options?
11:52:22 <KirinDave> shapr: Dat monad.
11:52:24 <Lutin`> Then I quickly moved on
11:52:38 <Lutin`> I think....my memory doesn't serve me well
11:52:40 <thoughtpolice> shapr: is Pedagogy.* taken? :)
11:52:43 <typoclass> Sensible.Statistics
11:52:49 <shapr> KirinDave: PS. What happened with the Sun JIT on armhf?
11:53:19 <shapr> thoughtpolice: Hm, that might work, except that's not a native US word, it's very European in my experience.
11:53:20 <DanBurton> geekosaur, typoclass: ok, now I'm getting another weird error. What is a pkg-config package, and why can't it find this one? http://hpaste.org/74547
11:53:49 <KirinDave> shapr: Oh it does crazy things.
11:53:51 <hpaste> timthelion pasted “fast median + naive median” at http://hpaste.org/74551
11:53:54 <timthelion> shapr: what exactly are you interested in?  Just the other week I wrote this: http://hpaste.org/74551
11:54:00 <rwbarton> SimpleHaskell, like the Simple English wikipedia
11:54:03 <KirinDave> shapr: There isn't support for those ARM hard floats in the version debian does.
11:54:06 <typoclass> Straightforward.Statistics, Plain.Statistics, Basic.Statistics
11:54:07 <LadyAurora> shapr: screw US
11:54:13 <KirinDave> shapr: I didn't pull the log off the raspberry pi.
11:54:28 <timthelion> shapr: weird comments are because that's from a haskell-cafe thread.
11:54:49 <rwbarton> DanBurton: that means you need to do something like apt-get install [something with lib and cairo and pdf in it]
11:54:50 <typoclass> oh -- Clear.Statistics
11:54:55 * ski . o O ( `Didactic.*' ? )
11:55:03 <shapr> typoclass: I like Clear.*
11:55:06 <timthelion> typoclass: do those packages actually exist?
11:55:14 <thoughtpolice> DanBurton: pkg-config is basically infrastructure used to keep track of what you need to use a library on linux machines. so if you install say, cairo, you can say `pkg-config --libs cairo` and you'll get a list of all the C compiler options you need to link against the cairo libraries. the packages you install need to be registered with pkg-config, and they do that by having a pkg-config file it'll pick up
11:55:19 <typoclass> typoclass: no, i'm making stuff up
11:55:20 <shapr> KirinDave: I may have to try it, I have a Raspbian and an Occidentalis card.
11:55:26 <geekosaur> pkg-config is used to get instructions for compiling against non-Haskell libraries
11:55:27 <geekosaur> at a guess, this looks vaguely linux-ish so you probably have the runtime packages installed but not the link-time packages (typically have -dev or -devel suffix on the package name)
11:55:35 <KirinDave> shapr: It will work fine on occidentals.
11:55:39 <thoughtpolice> DanBurton: cabal uses this, so when you say you need an external library, it knows what options to pass to the C compiler, etc
11:55:40 <geekosaur> but what the OS package is called depends on the exact OS / distribution
11:55:40 <LadyAurora> typoclass: Yeah, Clear sounds nice.
11:55:41 <rwbarton> oh right, and dev too
11:55:45 <KirinDave> Because they use a soft float mode.
11:55:46 <shapr> timthelion: Would be much easier to read if the lines wrapped
11:56:10 <thoughtpolice> DanBurton: you need a cairo-pdf package that has a pkg-config file to register. most linux distros (and even on OS X) will automatically include the pkg-config files for packages like that
11:56:16 <shapr> timthelion: Neat code though
11:56:30 <shapr> timthelion: If these comments wrapped, I think I would enjoy reading the whole thing :-)
11:57:03 <geekosaur> timthelion, what OS/distribution are you using?
11:57:03 <shapr> Also, I need to get back into the habit of writing QC tests before code.
11:57:16 <timthelion> geekosaur: Arch linux
11:57:19 <shapr> I'm using Linux/Poisson :-P
11:57:39 <DanBurton> thoughtpolice: thanks, that's very useful.
11:57:43 <hpaste> int80_h annotated “Type trickery ” with “Type trickery  (annotation)” at http://hpaste.org/74546#a74552
11:57:55 <Lutin`> shapr: Well it's a .lhs file
11:58:02 <DanBurton> thoughtpolice: any idea which package that is on aptitude?
11:58:30 <geekosaur> timthelion, looks like ther's no separate devel package on arch but you do need to install the OS-level 'cairo' package
11:58:31 <DanBurton> hrm I'll just try libcairo-dev and see if that works
11:58:34 <timthelion> shapr: I have a problem with the comment wrapping thing, which is that I'm dyslexic, and use size 20 font.  I only have 60 chars on a full screen terminal.  So if I cut text blocks off at 80 chars, I get 60char+20 char lines.  I have yet to find a good solution, other than just letting the lines be as long as they "should be" and wrapping in the editor.
11:58:40 <thoughtpolice> DanBurton: probably something like cairo-dev
11:58:52 <thoughtpolice> DanBurton: on this 12.04 ubuntu machine i have libcairo-dev available
11:58:58 <thoughtpolice> that should be exactly what you want
11:59:05 <shapr> timthelion: Have you tried the bottom-weighted anti-dyslexic font?
11:59:09 <Lutin`> shapr: http://hpaste.org/raw/74551
11:59:21 <geekosaur> sudo pacman -S cairo
11:59:25 <Lutin`> and timthelion
11:59:26 <geekosaur> or similar
11:59:39 <geekosaur> oh do I have the wrong person now?
11:59:48 <shapr> timthelion: specifically: http://www.dafont.com/open-dyslexic.font and http://www.fastcodesign.com/1664561/dyslexie-a-typeface-designed-to-help-dyslexics-read
11:59:52 * geekosaur may be getting too confused at this point... bleg
11:59:54 <timthelion> shapr: never heard of one.  But I don't think it would work. Because I'm using the term "dyslexic" as a symplification for a more complex sight problem... I'm dyslexic and I have motor problems in my eyes.
12:00:20 <DanBurton> yep libcairo-dev worked! cabal install cairo finally went through without complaints. now let's see if diagrams will install cleanly on top
12:00:20 <sixohsix> dear haskellians, do you feel Lenses are overhyped or actually the next great thing in Haskell?
12:00:37 <sixohsix> i'm trying to decide whether to bring them into a project
12:00:43 <edwardk> if anything i feel they are underhyped ;)
12:00:45 <DanBurton> sixohsix: both
12:00:50 <Lutin`> timthelion: I can suggest Dyslexie
12:00:55 <Lutin`> It helped my cousin a lot
12:00:56 <DanBurton> edwardk: you would :)
12:00:57 <shapr> edwardk: So, who's the primary instigator for Lenses again?
12:01:06 <DanBurton> edwardk: your lens package makes me very excited though
12:01:11 <edwardk> shapr: *whistles innocently*
12:01:28 <MostAwesomeDude> sixohsix: Gotta be honest, they are *massively* improving some of my code.
12:01:43 <sixohsix> are you using the lenses package, or are there others?
12:01:49 <timthelion> Lutin`: shapr I'll look into the font. But the problem remains unsolved, of what to do with the incompatibility of a 60 col terminal and an 80 col standard...
12:01:52 <typoclass> sixohsix: lenses are what will transform haskell into edwardkskell
12:01:54 <edwardk> sixohsix: i wrote data-lens and lens
12:02:02 <Lutin`> hmm
12:02:19 <Lutin`> There should be a terminal
12:02:22 <shapr> timthelion: Buy one of those $350 27" widescreen monitors?
12:02:25 <edwardk> sixohsix: i use lenses very heavily in my code, especially now with all the new traversals and folds stuff in 'lens'
12:02:27 <sixohsix> edwardk: well that's the shortest timeline from installing a package to meeting its inventor ever. hi!
12:02:29 <Lutin`> Where you can set the width but have it scrollable
12:02:29 <c_wraith> Just need a lensy prelude now. :)
12:02:39 <edwardk> c_wraith: its called 'lens' ;)
12:02:41 <Lutin`> Not sure if that would help though
12:02:51 <edwardk> sixohsix: =)
12:02:52 <c_wraith> edwardk: doesn't auto-import!
12:03:09 <timthelion> Lutin`: you want to make me have to scroll horizontally to read!?
12:03:11 <edwardk> sixohsix: note 'lens' is the one i named, not lenses =)
12:03:12 <typoclass> build-depends: base > 4 || lens > 2
12:03:32 <rwbarton> how come http://www.haskell.org/hoogle/?hoogle=lens doesn't include package lens as a result
12:03:34 <sixohsix> edwardk: not "data-lens"?
12:03:42 <Lutin`> timthelion: Oh wait that's what you were saying earlier
12:03:46 <edwardk> sixohsix: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio describes the different lens packages
12:03:48 <Lutin`> timthelion: Sorry :X
12:03:55 <c_wraith> rwbarton: because hoogle only indexes a small subset of hackage for its standard sorts
12:04:05 <typoclass> rwbarton: try hayoo
12:04:08 <edwardk> rwbarton: odd
12:04:17 <timthelion> shapr: heh, sometimes I move up to the big screen laptop.  But why should I have to make such consestions.  There ought to be an easy software solution.  And for me, it's breaking the 80 char standard.  There is really no reason why text should be broken into 80col...
12:04:30 <shapr> thoughtpolice: btw, do you know what other stats packages are available? Are they easier to read than bos' library?
12:04:34 <Lutin`> timthelion: They make things you can put in front of the screen that makes it larger, like a giant lens
12:04:35 <rwbarton> c_wraith: the results include ten other packages with lens in their names
12:04:49 <sixohsix> edwardk: as I see you wrote the very long and thorough answer to the question, let's just cut to the chase. i should use your "lens" package, right? :)
12:05:15 <Lutin`> timthelion: Which could possibly allow smaller font? I don't know I'm shooting in the dark :[
12:05:22 <DanBurton> how does hoogle decide which hackage packages to index? is it just the HP?
12:05:34 <typoclass> int80_h: what you could perhaps do is do define your operations like "preValidate :: JobID -> CurrentPhase -> ... ; preValidate id PHASEONE ... = ...". if i'm understanding the paste correctly, so far there's nothing that would really require a typeclass
12:06:14 <edwardk> sixohsix: pretty much ;)
12:06:18 <timthelion> Lutin`: for now I'm rather content.  Perhaps I'll write a script that converts between 80col "standard" text and text of paragrpah lenght lines.
12:06:36 <timthelion> s/lenght/length/
12:07:01 <sclv> so i hear there are godaddy service outages. guess that's whats screwing up haskell.org dns?
12:07:19 <thoughtpolice> shapr: i haven't read any of them, but i've noticed there are a few on there (i think there's hstatistics and another)
12:07:35 <thoughtpolice> sclv: yeah, i've heard about that all morning. they're apparently having lots of problems today i think
12:08:30 <Guest84436> well i cant get any work done without godaddy name servers
12:08:46 <Igloo> haskell.org DNS has nothing to do with godaddy AFAIK
12:08:55 <shapr> oh hai Igloo !
12:09:02 * shapr hugs Igloo 
12:09:06 <Igloo> Hey shapr  :-)
12:09:20 <sclv> Igloo: thanks for clearing that up. it was a wild guess :-)
12:12:01 <int80_h> typoclass: I thought that keeping these operations methods in a type class would be a good way to document. Anyone coming in could look at that class and know what they needed for a Phase to work.
12:12:38 * DanBurton is tired of waiting for cabal
12:12:55 <int80_h> typoclass: I'm re-evaluating that decision though, it seems I'm making things unessecarily complicated.
12:13:03 <DanBurton> Preprocessing library gtk-0.12.3.1... is it supposed to take this long?
12:13:24 <typoclass> int80_h: you mean, you have 3 typeclasses for the 3 phases, so that you can see at a glance "for phase 2, you need these 11 functions"?
12:14:14 <dmwit> DanBurton: It takes a long time, yes.
12:14:49 <DanBurton> I just have to think about how awesomesauce it is going to be once it finally installs
12:14:59 <fryguybob> DanBurton: There is always the svg backend for diagrams.
12:15:07 <typoclass> int80_h: and yes, i think you're right that the typeclass in this case makes things unnecessarily complicated :)
12:15:54 <int80_h> typoclass: I'm going to use a record of functions instead.
12:16:38 <int80_h> typoclass: no the idea was that for new phases that needed to be written, I wanted to communicate clearly what was expected.
12:16:41 <hpaste> timthelion annotated “fast median + naive median” with “fast median + naive median (annotation)” at http://hpaste.org/74551#a74555
12:16:51 <timthelion> shapr: http://hpaste.org/74551  Is that less broken?
12:17:13 <timthelion> shapr: nope, sorry, moment
12:17:32 <dmwit> If you're just doing it for diagrams, you probably only need cairo, not gtk.
12:17:33 <typoclass> int80_h: sure, records of functions sounds good
12:18:40 <hpaste> timthelion annotated “fast median + naive median” with “fast median + naive median (annotation)” at http://hpaste.org/74551#a74556
12:19:08 <KirinDave> Huh. Text.Blaze.HTML is actually quite nice.
12:19:24 <timthelion> shapr: the preformance problem with the non naive algorithm ended up that you have to compile with -O2 in order to actually get it to preform. Once you compile with -O2 the non-naive code is indeed faster :)
12:19:35 <KirinDave> I'm sort of surprised >> can be used that way. I guess it's just a logger at the end of the day.
12:20:18 <lpvb> How many levels of optimization does GHC have?
12:20:24 <LadyAurora> 3
12:20:29 <LadyAurora> 0, 1 and 2
12:20:32 <lpvb> lol
12:20:35 <shachaf> KirinDave: Right, (w,) is a monad when w is a monoid.
12:20:47 <lpvb> was about to ask it the index started at 0
12:21:03 <KirinDave> shachaf: And the result is pretty nice.
12:21:08 * timthelion loves haskell, mostly because he doesn't have to worry much about indexes and off by one errors.
12:21:16 <lpvb> so -O1 is different than -O?
12:21:25 <LadyAurora> No.
12:21:41 <lpvb> now I'm confused
12:21:44 <shachaf> KirinDave: It's a bit of an abuse of (do) notation. But at least it doesn't rbeak the monad laws.
12:21:47 <badabing> > [1,2,3] !! 5
12:21:49 <lambdabot>   *Exception: Prelude.(!!): index too large
12:21:56 <badabing> what was that an index error?
12:22:12 <timthelion> badabing: but you hardly ever *need* to grab an element by index...
12:22:17 <KirinDave> shachaf: Well it is documented with examples. More than can be said of Text.HTML. That's gotta count for something.
12:22:20 <ski> > [1,2,3] !! 2
12:22:22 <lambdabot>   3
12:22:31 <LadyAurora> lpvb: -O0 is the default, -O1 is also known as -O, and there's -O2.
12:22:35 <KirinDave> shachaf: The types for Text.Html are not as helpful for actual use as they should be.
12:23:10 * shachaf doesn't know much about HTML generation in Haskell.
12:23:15 <timthelion> > let g=[1,2,3];f n = f $ g !! n in f 0
12:23:21 <lambdabot>   mueval: ExitFailure 1
12:23:21 <lambdabot>  mueval: Prelude.undefined
12:23:46 <timthelion> > let g=[1,2,2];f n = f $ g !! n in f 0
12:23:51 <lambdabot>   mueval: ExitFailure 1
12:23:51 <lambdabot>  mueval: Prelude.undefined
12:23:59 <LadyAurora> lol
12:24:15 <timthelion> why isn't the seccond one time limit exceded?
12:25:03 <timthelion> > let g=[1,f 0,f 1];f n = g !! n in f 0
12:25:04 <lambdabot>   1
12:25:07 <timthelion> :)
12:25:21 <timthelion> > let g=[1,f 0,f 1];f n = g !! n in f 2
12:25:22 <lambdabot>   1
12:26:53 <maukd> :t \cf -> fix (\r -> fmap (\f -> f r) cf)
12:26:55 <lambdabot> forall b (f :: * -> *). (Functor f) => f (f b -> b) -> f b
12:27:12 <ski> > loeb [const 1,(!! 0),(!! 1)] !! 0
12:27:14 <lambdabot>   1
12:27:20 <maukd> :t loeb
12:27:20 <ski> > loeb [const 1,(!! 0),(!! 1)] !! 2
12:27:21 <lambdabot> forall (f :: * -> *) a. (Functor f) => f (f a -> a) -> f a
12:27:22 <lambdabot>   1
12:28:06 <sixohsix> stupid question… what's the function from (a -> b) -> (a -> m b)
12:28:26 <maukd> :t (return Prelude..)
12:28:27 <ski> @type (return .)
12:28:28 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
12:28:29 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
12:28:40 <LadyAurora> My eyes.
12:28:41 <maukd> @pl \cf -> fix (\r -> fmap (\f -> f r) cf)
12:28:41 <lambdabot> fix . flip (fmap . flip id)
12:28:52 <LadyAurora> Take that to /query.
12:29:03 <sixohsix> doh right. thanks.
12:29:36 <maukd> :t fix . flip (fmap fmap flip ask)
12:29:38 <lambdabot> forall b. (b -> b) -> (b -> b) -> b
12:29:50 <timthelion> LadyAurora: /query?
12:29:58 <maukd> :t fix . flip (fmap fmap (flip ask))
12:30:00 <lambdabot> forall b (f :: * -> *). (Functor f) => f (f b -> b) -> f b
12:30:38 * timthelion would google it, but apparently things identified by having a symbol in them are ungooglable now, because google is smarter than he is and can tell that timthelion didn't actually wish to search for /query but query.
12:30:45 <LadyAurora> timthelion: or /msg or however it's called in your IRC client.
12:30:55 <bos> shapr: my library is pretty readable, i'd have thought
12:31:12 <bos> shapr: also, the other stats packages mostly are not code you'd want to use
12:31:42 <shapr> bos: For my "intro to stats" class, I'm looking for code that is primarily readable, and works as a second priority.
12:32:20 <shapr> Though admittedly, works correctly is necessary :-)
12:33:04 <shapr> bos: I looked at Sample.hs and I don't yet know enough stats to know why you're using Vectors.
12:33:10 <ericmj> @pl \g f x -> g x (f x)
12:33:11 <lambdabot> ap
12:33:12 <bos> for efficiency
12:33:31 <bos> lists are, as you know, not fast
12:33:36 <shapr> Right
12:34:01 <krakrjak> :t fix
12:34:02 <lambdabot> forall a. (a -> a) -> a
12:34:04 <shapr> I'm writing my own version that uses lists, slow as they are, because that seems easier to read, to me at least.
12:34:12 <krakrjak> hrm... not that helpful for me.
12:34:26 <shapr> @src fix
12:34:26 <lambdabot> fix f = let x = f x in x
12:34:39 <krakrjak> ty
12:35:16 <Ferdirand> hurray, i'm finally grokking (.) as a prefix/postfix operator, and all the associated pointfree plumbing
12:35:27 * Ferdirand is happy
12:35:31 <johnw> krakrjak: perhaps apropos: http://newartisans.com/2012/09/the-fix-combinator-and-recursive-lambdas/
12:36:05 <maukd> Ferdirand: we can fix that
12:36:19 <maukd> (fmap fix return)
12:36:34 <johnw> Ferdirand: (. foo) . (bar) should send you running away in fear again
12:36:44 <johnw> oops, meant (. foo) . bar
12:36:46 <copumpkin> maukd: what happened to mauke
12:36:50 <krakrjak> :t (.)
12:36:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:36:54 <shachaf> Ferdirand: Don't use . as prefix and postifx. :-(
12:37:04 <krakrjak> that doesn't match my ghci...
12:37:08 <maukd> copumpkin: hardware failure
12:37:09 <shachaf> Will writing out a few points kill you?
12:37:13 <copumpkin> poor mauke!
12:37:24 <typoclass> copumpkin: got decremented
12:37:32 <copumpkin> > succ "mauke"
12:37:33 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
12:37:34 <lambdabot>    arising from a use of `...
12:37:36 <Eduard_Munteanu> maukd++
12:37:40 <copumpkin> dammit
12:37:41 <willem> hello, im having trouble trouble compiling a haskell SDL app on windows, compiling the equivalent c program with mingw gcc works. could somebody help me?
12:37:41 <shachaf> maukd: Will mauke ever be back?
12:37:57 <rlpowell> OK, I *must* be doing something wrong, because no-one would use Data.Text if this was idiomatic: concat [pack "Component path ", unComponentPath path, pack "could not be found."] ("unComponentPath path" is Text type) (and I want a Text type result because the library wants it)
12:38:12 <maukd> shachaf: it is a mystery
12:38:13 <krakrjak> johnw: thanks for the link.
12:38:21 <Cale> willem: I'm not on Windows, but if you can describe your problem more, perhaps I can suggest something?
12:38:37 <bos> rlpowell: {-# LANGUAGE OverloadedStrings #-}
12:38:50 <maukd> rlpowell: I'd probably write me a printf
12:39:17 <bos> also http://hackage.haskell.org/package/text-format
12:39:19 <rlpowell> bos: I have that on; it won't accept: "foo" ++ bar ++ "baz", where bar is a text.
12:39:25 <rlpowell> I can find the exact error if you like.
12:39:27 <bos> rlpowell: of course it won't
12:39:31 <bos> ++ is for lists
12:39:39 <rwbarton> (but so is concat?)
12:39:42 <ByronJohnson> rlpowell: ++ only works on lists; what I like to do is bind ++ to mappend
12:39:43 <rlpowell> Then how does overloaded strings help me?
12:39:43 <johnw> shapr: Have you seen BlogLiterately?  It's amazing
12:39:52 <willem> Cale: thank you, when i compile the program, the following string is repeated across several lines: "C:/MingW/lib/libmingwex.a(pformat.o):pformat.c:(.text+0x3f4): undefined reference to `__chkstk_ms'"
12:39:54 <shachaf> rlpowell: import Data.Monoid and use "<>" instead of "++".
12:40:02 <nand`> I thought Data.Monoid had ++ too
12:40:09 <bos> rlpowell: well since your complaint was underspecified, i didn't know which part you were reacting to
12:40:13 <shachaf> Which is approximately what ByronJohnson said, except in the standard library.
12:40:23 <johnw> I do all my blogging with it now; and since I get to write all the posts as literate Haskell, I'm a bit more certain they are closer to correctness :)
12:40:27 <bos> yes, <> is your friend
12:40:35 <nand`> oh, no, I defined that locally
12:40:41 <rlpowell> bos: Fair enough; "I want to turn some raw text and some Text into a Text; how do I do that in a non-sucky way?"
12:40:48 * rlpowell looks up <>
12:40:53 <johnw> rlpowell: what is the type of raw text?
12:40:54 <ByronJohnson> Oh, I never noticed <>.  Neat.
12:41:01 <bos> "foo" <> myFunction thingy <> "bar"
12:41:13 <Cale> willem: what's your GHC commandline?
12:41:38 <rlpowell> johnw: Actual literal text in my code, i.e. "Here's a Text: " ++ text ++ " <-- see it?", except not that.
12:41:38 <shachaf> (<>) = mappend. It's like (++) but for any monoid (a "monoid" is "a type that can ++ed and has []", more or less).
12:41:45 <willem> ghc -o sdl-test sdl-test.hs -lSDL
12:42:01 <johnw> rlpowell: you can use OverloadableStrings and default (Text)
12:42:04 <johnw> that's what I do
12:42:05 <Cale> try  ghc --make sdl-test
12:42:12 <johnw> then "foo" :: Text
12:42:54 <willem> it spits out the same errors
12:43:07 <rlpowell> johnw: So, what, like: concat ["foo" :: Text, text, ...  ?
12:43:14 <bos> rlpowell: no
12:43:18 <johnw> now, I mean the type of literal strings will be Text
12:43:20 <bos> rlpowell: just use <>
12:43:22 <johnw> s/now/no
12:43:41 <johnw> "foo" <> text, should just work
12:43:50 <rlpowell> *nod*
12:43:50 <rlpowell> 'k.
12:43:51 <willem> i have also tried ghc sdl-test.hs -o sdl-test -lmingw32 -lSDLmain -lSDL
12:44:05 <rlpowell> bos: I thought johnw was suggesting something different, I wasn't ignoring your suggestion.  :)
12:44:10 <bos> rlpowell: the reason concat is not working for you is that the types don't match
12:44:22 * shachaf wonders whether <> should be infixl or infixr for text.
12:44:26 <bos> somewhere inside your expression
12:44:30 <shachaf> Probably some kind of clever fusion takes care of it anyway?
12:45:05 <bos> shachaf: fusion for multiple appends is not good
12:45:15 <Cale> willem: I tried googling the error message, and found this: http://stackoverflow.com/questions/1137323/qt-mingw32-undefined-reference-errors-unable-to-link-a-lib
12:45:18 <bos> you get O(n^2) behaviour
12:45:25 <geekosaur> willem, possibly the -lmingw32 needs to be moved to the end; -l is position dependent (because linkers are historically stupid and need manual intervention to deal with symbol resolution loops)
12:45:29 <shachaf> bos: Aw. :-(
12:45:29 <ByronJohnson> http://permalink.gmane.org/gmane.comp.lang.haskell.cvs.libraries/14437 — Ah, <> is more recent than I thought
12:45:34 <Cale> willem: It sounds like perhaps SDL was compiled with a non-gcc compiler?
12:46:07 <geekosaur> indeed, that'spossible too
12:46:22 <bos> shachaf: it's a difficulty of stream fusion in general
12:46:37 <shachaf> bos: Makes sense.
12:47:20 <hpaste> sss pasted “ss” at http://hpaste.org/74559
12:47:30 <willem> Cale: do you mean the SDL.dll file?
12:47:48 <willem> geekosaur: ill try compiling it like that
12:49:15 <geekosaur> willem, it may not help.  I looked at that symbol again, I think it's looking for a function from the MSVCRT, which is not compatible with mingw
12:50:05 <willem> hmm... so what should i do? install a different c compiler?
12:51:55 <geekosaur> you need an SDL that wasn't built with MSVCRT... at least currently, there is no ghc that works with MSVC (I think there's someone working on it?)
12:53:54 <statusfailed> What does the | in "class (Monad m) => MonadReader r m | m -> r where" mean?
12:54:04 <sclv> it introduces functional deps
12:54:11 <statusfailed> wot
12:54:19 <sclv> it means MonadReader r m sutch that the m uniquely determines the r
12:54:39 <sclv> http://www.haskell.org/haskellwiki/Functional_dependencies
12:54:39 <statusfailed> uniquely determines? Sorry, still don't follow
12:54:41 <statusfailed> oh
12:54:41 <statusfailed> thanks
12:54:42 <statusfailed> hehe
12:54:53 <willem> geekosaur: i followed this tutorial: http://www.animal-machine.com/blog/2010/04/a-haskell-adventure-in-windows/ . the author got it working in a virtualbox environment with what i believe to be the mingw compiler (he used the sdl-mingw packages)
12:55:51 <ski> statusfailed : it means that for each `m' there can be at most one `r' with an instance for `MonadReader r m'
12:58:03 <ski> statusfailed : in formulaic terms, `forall m. unique r. MonadReader r m', which is equivalent to `forall m r0 r1. (MonadReader r0 m,MonadReader r1 m) => r0 = r1' (if we have both an instance `MonadReader r0 m' and an instance `MonadReader r1 m', then `r0' and `r1' has got to be the same type)
12:58:38 <shachaf> ski: whoa, dude, "unique".
12:58:46 <statusfailed> to be honest "whoa" in general
12:59:02 <shachaf> "unique" on its own wouldn't be sufficient to express all fundeps, right?
12:59:23 <ski> statusfailed : the the type system will not allow you to declare instances `MonadReader r0 m', `MonadReader r1 m', with `r0' and `r1' being different types
13:00:24 <willem> statusfailed, have you ever dealt with injective functions? fundeps are kind of like that
13:00:25 <ski> statusfailed : the practical gain of all this is that the type system can *assume* that if it has inferred constraints `MonadReader r0 m', `MonadReader r1 m', then `r0' and `r1' has *got* to be the same type -- this can greatly reduce ambiguity, avoiding ambiguity errors
13:00:39 <geekosaur> willem, actually I am seeing that it is not related to msvc, but to gcc not finding its internal library (-lgcc which is automatically applied during linking)
13:00:45 <geekosaur> not sure how to fix it though :(
13:00:46 <ski> shachaf : you need `forall' as well, yes
13:00:49 <statusfailed> willem: not really, sorry :)
13:01:06 <statusfailed> ski: I'm still trying to understand this in context of MonadReader, but it seeeeeeems to be making sense
13:02:01 <shachaf> ski: Well, I mean forall+unique.
13:02:05 <ski> statusfailed : the idea is that for any monad `m', there ought to be at most one "environment" type `r', which can be accessed with `ask' (and `asks') and locally changed with `local'
13:02:10 <ski> @type ask
13:02:11 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
13:02:12 <ski> @type local
13:02:14 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
13:02:24 <ski> shachaf : example ?
13:02:24 <willem> geekosaur: hmm... any idea what i should do then?
13:02:56 <ski> (shachaf : note that `unique a b. P a b' can't be expressed with an iterated `unique')
13:03:02 <geekosaur> not really, I'm not that familiar with windows development
13:04:14 <geekosaur> willem, one thing you might try is appending -lgcc to the link line (after -lmingw32)
13:04:18 <statusfailed> ski: so the constraint isn't actually necessary as such?
13:05:12 <geekosaur> statusfailed, it's never strictly necessary; it does save you from needing to provide lots of extra type annotations
13:05:21 <willem> geekosaur: i tried, but to no avail :(
13:05:46 <geekosaur> ok, I'm afraid I don't know how to help then :(
13:05:56 <willem> geekosaur and Cale: thank you for your time, but i think i am simply going to remove everything and reinstall it more carefully
13:06:48 <statusfailed> oh wait, the matrix example made sense
13:06:53 <ski> statusfailed : itym s/constraint/functional dependency/
13:07:23 <statusfailed> ski: oops, yeah
13:07:45 <shachaf> ski: Oh, hmm.
13:13:24 <ski> shachaf : anyway, consider `class Foo a b c d | a b -> c , a d -> b c', this translates into `(forall a b. unique c. exists d. Foo a b c d) /\ (forall a d. unique b c. Foo a b c d)', which amounts to `(forall a b c0 c1 d0 d1. Foo a b c0 d0 /\ Foo a b c1 d1 => c0 = c1) /\ (forall a b0 b1 c0 c1 d. Foo a b0 c0 d /\ Foo a b1 c1 d => b0 = b1 /\ c0 = c1)'
13:13:56 <LadyAurora> Holy moly.
13:14:25 <statusfailed> I have to agree :D
13:15:48 <shachaf> ski: Makes sense, though it doesn't seem like that sort of thing could be very usable in Haskell.
13:16:23 <ski> i'm not sure about which sort of thing you mean ..
13:16:46 <shachaf> I mean, if you had first-class "unique" in some way, using it instead of fundeps.
13:19:27 <ski> ah, i see what you mean
13:19:47 <ski> i was just using `unique' above as a means of explaining what FDs meant
13:22:12 <statusfailed> ski: got it now, thanks
13:23:08 <aluink> anyone have success in installing the unix package in cygwin?
13:23:56 <aluink> i have tons of cygwin stuff in my path and still cabal continues to not recognize this as a valid unix environment
13:24:24 <ski> statusfailed : ooc .. i assume you're not familiar with some basic relational database theory ?
13:24:46 <statusfailed> ski: Only in a very vague way :)
13:24:47 <geekosaur> aluink, cygwin can only do so much to make windows look like unix, and more commands won't help if it's some missing POSIX API
13:25:44 <aluink> geekosaur: agreed. however, the package claims it's possible. so I was looking for someone who knows *how*
13:25:53 <jaen> Hi, is it me only, or is hackage down? I was trying to get packages for gnome-panel xmonad applet and bam ; /
13:26:15 <ski> statusfailed : anyway, the functional dependencies in relational database theory are basically the same thing as here
13:26:32 <aluink> jaen: wfm
13:27:29 <jaen> aluink: heh, can I get ip then to ping, pretty please?
13:27:29 <aluink> jaen: are you able to get any other package?
13:27:48 <jaen> I can't access the website at all, not only the dbus package
13:29:14 <aluink> jaen: i can't ping from here, but the IP I'm resolving for hackage.haskell.org is 66.193.37.204
13:29:46 <aluink> jaen: and I can pull it up in chrome, so I'm assuming I'd be able to ping
13:29:47 <statusfailed> ski: ok, makes sense
13:30:14 <aluink> jaen: unless of course hackage blocks pings ;)
13:30:21 <jaen> aluink: thanks, it looks like the connection drops after 10 or so bounces, oh well ; /
13:30:44 <aluink> jaen: sounds like you need a proxy atm
13:31:01 <ski> statusfailed : .. including that normalization of relations suggested by functional dependencies can also be useful for type classes
13:31:17 <jaen> aluink: yeah, I'll try one probably, thanks ; )
13:32:32 <johnw> shapr: ping
13:34:10 <johnw> httping http://www.haskell.org/hackage works fine here
14:02:20 <widith> does anyone have experience with libpcap (Network.Pcap) ? I'm trying to create a session and print out the packets but there are very little examples
14:02:47 <edwardk> getting ready to push out a new version of 'free'. can someone git clone https://github.com/ekmett/free and cabal install it to sanity check me? =)
14:03:27 <edwardk> Added free applicatives and the moved the church-encoded free monad from kan-extensions
14:03:43 <lispy> edwardk: I'm using cabal-dev, attmpting now
14:03:49 <shachaf> edwardk: It builds, at least.
14:04:00 <edwardk> shachaf: thats promising =)
14:04:01 <lispy> not the most recent ghc, either
14:04:09 <lispy> edwardk: builds for me under cabal-dev
14:04:13 * shachaf doesn't like cabal-installing from git repositories.
14:04:17 <lispy> ghc-7.4.1
14:04:21 <edwardk> lispy: sok. it should be fairly compatible with old versions
14:04:28 <shachaf> ghc-7.6.1
14:04:38 <shachaf> lispy: Get with the times, man.
14:04:42 <shachaf> Deferred type errors!
14:04:55 <shachaf> (And some other uninteresting nonsense.)
14:04:58 <lispy> I already have emails asking when packages I maintain will work with 7.6x
14:05:13 <lispy> "Um, I haven't even _installed_ it yet..."
14:05:27 <edwardk> lispy: all of mine were converted more or less the day after the release candidate
14:05:54 <edwardk> the only one that took a while to get right is lens and thats because the 'right way' to generate inline pragmas from template haskell changed like 3 times in 7.6
14:06:00 <timthelion> lispy: it's not even in arch yet!
14:06:05 <lispy> I'm always worried about breaking order versions. I should probably setup some VMs with different ghcs, but hey. I'm lazy :)
14:06:27 <timthelion> lispy: no one cares about debian stable users. don't bother.
14:06:47 <edwardk> my rule of thumb is that by default i'll support the last platform or two, and i'll go farther back if someone wants to work with me on it
14:07:16 <Igloo> lispy: Given the choice of supporting the latest version or an older version, IMO the latest version is almost always the better choice
14:07:20 <lispy> timthelion: Well, it would be good for me to at least test against the current HP release and whatever bleeding edge version is out there (recall that the HP intentionally lags behind the ghc releases)
14:07:22 <edwardk> the logical extreme is semigroups and reflection that work clear back to hugs and base 2. ;)
14:07:29 <Igloo> As you can much more reasonably require people to upgrade than to downgrade
14:07:30 <timthelion> my rule of thumb, is that if someone wants to use legacy software, they can always click on the OLD tarbal on hackage and use that.
14:08:46 <timthelion> Like rather than forcing the GTK and python guys to make gtk3 and python3 compatible with the old versions.  We just all run two versions of those packages.
14:09:46 <timthelion> Though I probably shouldn't praise the python guys, because they didn't even bother making the "linker(if there even is such a thing in python) capable of "linking" new programs with python2 libraries.
14:11:43 * hackagebot free 3.2 - Monads for free  http://hackage.haskell.org/package/free-3.2 (EdwardKmett)
14:16:43 * hackagebot ad 3.1.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.1.2 (EdwardKmett)
14:16:45 * hackagebot keys 3.0.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-3.0.1 (EdwardKmett)
14:17:00 <johnw> what is a keyed functor?
14:17:32 <edwardk> keys is a fairly old package of mine i had to push because its dependencies got updated
14:17:43 <johnw> is free recent?
14:17:44 <edwardk> it basically supplies combinators for lookup, etc. in a fairly general way
14:17:56 <edwardk> free is also old, but more maintained =)
14:18:00 <johnw> oh, a predecessor to lens?
14:18:03 <edwardk> keys is a ball of mud that was useful
14:18:43 <edwardk> i use it in representable-functors, but then, lenses provide another notion of representability that while slightly less canonical is more useful
14:21:47 * hackagebot hsqml 0.1.0 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.1.0 (RobinKay)
14:21:49 * hackagebot hsqml-morris 0.1.0 - HsQML-based implementation of Nine Men's Morris  http://hackage.haskell.org/package/hsqml-morris-0.1.0 (RobinKay)
14:21:51 * hackagebot tag-bits 0.1.1.2 - Provides access to the dynamic pointer tagging bits used by GHC.  http://hackage.haskell.org/package/tag-bits-0.1.1.2 (EdwardKmett)
14:22:06 <johnw> merijn: ping
14:24:45 <ski> edwardk : your `Key' looks perhaps remniscent of elasticity of demand ..
14:24:53 <edwardk> ?
14:25:58 <ski> `(<#$>) :: Keyed f => (Key f -> a -> b) -> f a -> f b' applies the function to each element, together with the path/index/key to it, yes ?
14:26:25 <edwardk> i'd forgetten about that combinator, but yes =)
14:26:43 * hackagebot speculation 1.4.1.2 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.4.1.2 (EdwardKmett)
14:26:45 * hackagebot representable-functors 3.0.0.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-3.0.0.1 (EdwardKmett)
14:27:38 <Peaker> <#$> sounds like a very bad name for a combinator :)
14:28:11 <edwardk> Peaker: hah some of the other ones in lens look like swearing, or overhead views of animals or trilobytes too ;)
14:28:13 <ski> well, if `E' is elasticity of demand (`E f x = x * D f x / f x'), then `E Stream = Const Nat'
14:28:15 <shachaf> What was that <#$> combinator called?!
14:28:52 <Peaker> greedy hash
14:29:07 <kanedank> why doesn't 'map putStrLn ["hello","foo"]' work?
14:29:17 <shachaf> kanedank: It does work. It just doesn't do what you think.
14:29:35 <ski> .. in SML, there's  val mapi : (int * 'a -> 'b) -> 'a vector -> 'b vector
14:29:46 <ski> @type map putStrLn ["hello","foo"]
14:29:48 <lambdabot> [IO ()]
14:29:53 <shachaf> @ty sequence_
14:29:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
14:30:03 <shachaf> Well, sequence_ :: [IO a] -> IO ()
14:30:04 <ski> kanedank : you get a list of (unexecuted) `IO'-actions
14:30:18 * shachaf wonders what a list of executed IO actions would be.
14:30:31 <edwardk> shachaf: oh the carnage!
14:30:37 * ski executes shachaf
14:30:40 <ski> (:
14:31:06 <shachaf> Oh, hey, it's ski!
14:31:09 * shachaf didn't notice.
14:31:20 <ski> hiya shachaf
14:32:01 <ski> kanedank : `sequence_' takes a list of actions, and returns a new action that, when executed, will execute all the actions in the list (in order) (and throw away their results)
14:32:20 <ski> kanedank : if you want to keep the results, you can use `sequence :: [IO a] -> IO [a]'
14:33:10 <ski> kanedank : finally, `mapM_ f actionList' is a shorthand for `sequence_ (map f actionList)' (and `mapM f actionList' is a shorthand for `sequence (map f actionList)')
14:36:43 * hackagebot adjunctions 3.0.0.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-3.0.0.1 (EdwardKmett)
14:36:45 * hackagebot representable-tries 3.0.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-3.0.1 (EdwardKmett)
14:36:47 * hackagebot kan-extensions 3.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.1 (EdwardKmett)
14:37:04 <monochrom> edwardk strikes again :)
14:37:20 <monochrom> (have you tested them on GHC 7.6.1?)
14:37:22 <edwardk> monochrom: was convinced to add stuff to 'free'. its in the middle of the hierarchy
14:37:32 <edwardk> and yeah there are a few 7.6.1 updates in there
14:41:44 * hackagebot machines 0.1.2 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.1.2 (EdwardKmett)
14:42:27 <kanedank> ski: I don't understand the difference between mapM_ and mapM (or I guess sequence_ and sequence)
14:42:53 <johnw> one results in IO (), the other in IO [a]
14:43:09 <johnw> _ = I don't care about the results
14:43:13 <johnw> (in this case)
14:43:43 <johnw> if you find yourself writing: _ <- mapM f xs, then just write mapM_ f xs
14:44:57 <kanedank> ah, okay
14:45:03 <kanedank> thanks guys!
14:45:27 <ski> kanedank : `mapM' (and `sequence') will (assuming no sufficiently smart compiler optimizations) construct a list of results, `mapM_' (and `sequence_') won't
14:45:43 <monochrom> mapM and mapM_ have different costs. for IO.
14:46:01 <ski> @src sequence
14:46:01 <lambdabot> sequence []     = return []
14:46:02 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:46:02 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
14:46:06 <ski> @src sequence_
14:46:06 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:46:44 * hackagebot recursion-schemes 3.0 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-3.0 (EdwardKmett)
14:48:23 <ski> yes, as monochrom is indicating, for `IO', `sequence_' is basically tail-recursive (i.e. an iterative process), while `sequence'
14:48:26 <ski> isn't
14:49:00 <cleantc>  having expressions e1,e and e',  why  "case (K e1) of { K x -> e; _ -> e' } == (\x -> e) e1" holds for constructor K defined by data but not for it being defined by newtype? http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-610022
14:51:52 <larsrh> Is it possible to use yesod-routes standalone (i.e. without Yesod)?
14:51:57 <rwbarton> doesn't it also hold for a newtype? by (k) and (j)
14:52:12 <rwbarton> oh wait
14:52:23 <rwbarton> (k), (i) and (j)
14:52:44 <larsrh> such that someone declares a file containing the route syntax, I pass Yesod a string, and it calls the specified function for me
14:52:48 <monochrom> you will also need (a). e1 is not necessarily a variable alone
14:55:29 <monochrom> although, I don't know how to use it :)
14:56:06 <cleantc> why a special case? in (q)  wouldn't it be enough to state for both K and N ?
14:56:44 <rwbarton> probably it is presented this way to make it more obvious that all the cases are covered
14:56:50 <rwbarton> first newtype, then data
14:57:10 <monochrom> I guess there is no harm in taking e1 as a variable
14:57:35 <cleantc> I am just worried about the lazy vs strict behavior of newtype definitions
14:57:50 <Heffalump> anyone know of a way of finding reverse dependencies of a hackage package, given that revdeps.hackage.haskell.org is down (as is the page in Roel's own webspace)?
14:58:04 <johnw> is there a Haskell library that will let me evaluate functions on another host over ssh?  As in: evalOverThere "remotehost" f x?  I'm assuming all the values back and forth must be serializable, and that the same code should exist on both sides
14:58:36 <rwbarton> that is (l) vs. (r)
14:58:53 <hpc> johnw: if you don't mind it basically being "eval", you can make something with hint
14:59:02 <hpc> (Haskell INTerpreter)
14:59:11 <johnw> hpc: sure, I was just wondering if it already existed
14:59:33 <hpc> there's a caveat, which is that you basically end up linking all of GHC into your code
15:00:20 <monochrom> (l) and (r) are how newtype and data differ in strictness
15:00:44 <frio> johnw: that's in erlang's bag 'o tricks
15:00:52 <monochrom> and I lag :)
15:01:08 <johnw> frio: I guess I want a haskell-erlang package then :)
15:03:56 <cleantc> I am doing syntactic transformation (desugaring), therefore I am not dealing with the bottom case, so I wonder if I can use all the transformations without separating data and newtype constructors
15:04:53 <johnw> frio: I guess I want CloudHaskell
15:14:41 <Z`> hey people. suppose I'd like to have a tree, where each node could point to an arbitrary large number of other nodes. How would I define my type ?
15:15:27 <ski> maybe `data Tree a = Node a [Tree a]' ?
15:15:29 <johnw> check if Data.Tree satisfies your needs?
15:15:30 <shachaf> Tree a = Tree a [Tree a]?
15:15:35 <ski> @type Node
15:15:37 <lambdabot> forall a. a -> Forest a -> Tree a
15:15:48 <ski>   type Forest a = [Tree a]  -- in there
15:15:58 <sclv> great thread, can't follow any of it: http://mathoverflow.net/questions/106560/philosophy-behind-mochizukis-work-on-the-abc-conjecture
15:15:59 <sclv> :-)
15:16:04 <Z`> [Tree a] is a list of trees ?
15:16:19 <ski> Z` : it's the type of list of trees of `a's, yes
15:16:23 <sclv> not haskell, i know, but this is the channel i felt it was worth sharing it with
15:16:28 <shachaf> A tree is a list of trees.
15:17:29 <Z`> ok,thanks
15:18:08 <ski> iirc, this is often known as a "rose tree"
15:18:39 <monochrom> the other pasture has more rose trees
15:19:22 <badabing> > catMaybe [Just 5, Nothing]
15:19:23 <lambdabot>   Not in scope: `catMaybe'
15:19:31 <badabing> > catMaybes [Just 5, Nothing]
15:19:33 <lambdabot>   [5]
15:19:44 <Z`> ah really? it has a special name? neat
15:20:25 <shachaf> I prefer: data Tree = Tree [Tree]
15:21:09 * ski . o O ( `data Tree a = Node a (Tree (Tree a))' )
15:21:23 <johnw> Z`: also, Data.Tree already provides this type
15:21:35 <monochrom> yikes
15:21:54 <Z`> ok, reading on Data.Tree
15:22:27 <Z`> data Tree a = Node { ... <- I'm not familiar with this notations. Is it an algebraic data type ?
15:22:38 <ski> it's record notation
15:22:44 <monochrom> it is. record syntax.
15:22:53 <Z`> ok, then I'll read on record syntax. Thanks.
15:23:05 <ski>   data Stream a = Cons {head :: a,tail :: Stream a}
15:23:12 <ski> basically is shorthand for
15:23:20 <ski>   data Stream a = Cons a (Stream a)
15:23:20 <shachaf> ski: That's a weird type.
15:23:26 <ski>   head :: Stream a -> a
15:23:30 <ski>   head (Cons a _) = a
15:23:36 <ski>   tail :: Stream a -> Stream a
15:23:41 <ski>   tail (Cons _ as) = as
15:23:58 <latro`a> s/basically//
15:24:03 <ski> Z` : plus some more notation for constructing and updating records
15:24:29 <latro`a> 's exactly that, with the syntax for creating a new record from an old one
15:24:34 <latro`a> s/`s/it's
15:24:37 <ski> shachaf : saw it in a paper which talked some about non-regular types
15:24:43 <ski> (Wadler, iirc)
15:24:51 <latro`a> the latter sugar is actually quite heavy
15:24:52 <Z`> and which one is the data constructor ?
15:24:57 <latro`a> Cons
15:25:05 <latro`a> head and tail are field accessor functions
15:25:06 <Z`> I mean in the record syntax
15:25:12 <latro`a> Cons
15:25:17 <latro`a> record syntax doesn't change that
15:25:24 <monochrom> "data Tree a = Node a (Tree (Tree a))" exemplifies polymorphic recursion
15:25:27 <ski>   Cons {head = a,tail = as}  -- also works as a pattern
15:25:44 <ski>   myStream {head = newHead}  -- record update
15:25:47 <latro`a> wait
15:25:52 <latro`a> you can match on a record like that?
15:25:56 <latro`a> like
15:25:57 <ski> of course
15:26:05 <latro`a> f (Cons {head = a}) = a
15:26:06 <monochrom> in fact...
15:26:10 <latro`a> is exactly head
15:26:11 <latro`a> ?
15:26:11 <Z`> confusing at 1st sight :/
15:26:12 <shachaf> monochrom: I still find polymorphic recursion very suspicious.
15:26:15 <johnw> monochrom: with that type, how do you ever terminate the definition?
15:26:17 <shachaf> Something doesn't feel right about it.
15:26:18 <monochrom> > case Just 4 of Just{} -> "success"
15:26:19 <lambdabot>   "success"
15:26:37 <ski> > case Node () [] of Node {rootLabel = a,subForest = as} -> (a,as)
15:26:38 <lambdabot>   ((),[])
15:26:43 <latro`a> that's really cool, means you can avoid having to call the field accessors
15:26:51 <latro`a> and instead say on the LHS which fields you need for your function
15:26:58 <monochrom> ah, that type does not have a base case. you can add a base case if you like
15:27:04 <latro`a> also means you can name the fields that you accessed on the LHS instead of, say, in a where
15:27:13 <latro`a> I will have to start using this :D
15:27:29 <ski> latro`a : and even pattern-match with non-trivial patterns on the components of the record
15:27:44 <latro`a> right, right
15:27:45 <latro`a> nice
15:28:05 <Z`> what would be an example of a simple Data.Tree initialisation/construction ?
15:28:22 <monochrom> Node 4 []
15:28:33 <Z`> thanks
15:28:39 <monochrom> Node 4 [Node 5 [], Node 6 []]
15:29:14 <shachaf> leaf = (`Node` [])
15:29:54 <badabing> > [1..10]
15:29:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:30:16 <dncr> does "deriving Generic" allow you to do anything that "deriving (Data, Typeable)" doesn't?
15:30:18 <Z`> and how would you append nodes into an already constructed tree ?
15:31:03 <Z`> Say I let x = Node 4 []; and I'd like to end up with Node 4 [Node 5 [], Node 6 []]
15:32:09 <monochrom> case ... of Node x _ -> Node x [Node 5 [], Node 6 []]
15:32:26 <monochrom> sorry for clashing x
15:32:32 <monochrom> case ... of Node v _ -> Node v [Node 5 [], Node 6 []]
15:33:02 <Z`> ok, so with pattern matching. thanks
15:34:09 <Z`> what if I wanted to add that deeper into the treee. Like: let x = Node 1 [Node 2 [Node 3 []]]
15:34:23 <Z`> and turn it into : let x = Node 1 [Node 2 [Node 3 [Node 4]]]]
15:34:35 <monochrom> write a recursion
15:34:53 <Z`> ok
15:46:36 <Z`> Is there a tree like data structure that is unidirectional?
15:47:14 <Z`> perhaps a Graph ?
15:47:18 <shachaf> What's a unidirectional tree?
15:47:34 <monochrom> I thought Data.Tree was already unidirectional
16:13:42 <dgpratt> since this seems to be a quiet moment, perhaps its a good time to ask a CT-related question I've been pondering...
16:13:59 <dgpratt> from Wikipedia: The empty set is the unique initial object in the category of sets; every one-element set (singleton) is a terminal object in this category; there are no zero objects.
16:14:10 <dgpratt> my question is why?
16:14:47 <ski> why which ?
16:14:56 <dgpratt> to ask a more specific question, why aren't empty sets also terminal objects?
16:15:29 <dgpratt> ski: just not sure what about the nature of empty sets makes them initial and what about the nature of singleton sets makes them terminal
16:15:41 <dgpratt> ski: at this point it seems kind of arbitrary
16:15:45 <ski> for `{}' to be a terminal object, it would need to be the case that for every object `A' there is a unique function `<>_A : A >---> {}'
16:15:46 <rwbarton> do you know the definition of initial/terminal?
16:15:55 <ski> (total function)
16:16:32 <dgpratt> rwbarton: trying to understand the same
16:17:35 <rwbarton> there's nothing arbitrary about it, having an initial/terminal object is not extra structure. either a set is an initial/terminal object or it's not, according to the definition
16:17:43 <ski> dgpratt : do you know categorical product/coproduct yet ?
16:17:59 <dgpratt> ski: no, not really
16:18:03 <ski> ok
16:18:24 <dgpratt> ski: actually, your previous explanation is starting to make sense...I think
16:18:31 <rwbarton> as opposed to some other kinds of operations we can put on a category, where there is a choice of operation
16:18:33 <dgpratt> I just need to ponder it a bit more
16:18:39 <ski> there is a unique morphism *from* an initial object to any object you like
16:18:51 <ski> there is a unique morphism *to* a terminal object from any object you like
16:19:10 <widith> How do you pattern match against the data types from Data.Word?
16:19:27 <ski> if `I' is an initial object, this morphism is often written like `[]_A : I >---> A'
16:19:40 <widith> I'm reading it and seeing stuff like Data Word8 = W8# Word#
16:19:44 <ski> if `T' is an terminal object, this morphism is often written like `<>_A : A >---> T'
16:20:03 <rwbarton> widith: using fromInteger, probably (or implicitly like case w of 3 -> ...)
16:20:15 <ski> sometimes they (both of them) are written as `!_A' instead (`!' to emphasize the uniqueness, i suppose)
16:20:37 <ski> dgpratt : and commonly the subscript `_A' is omitted
16:20:42 <rwbarton> W8# Word# means a Word8 contains an unboxed Word, you probably don't want to pattern match against this
16:20:56 <dgpratt> ski: I see
16:24:33 <ski> dgpratt : you could ponder initial objects in the category of sets with *partial* functions; the category of sets with (binary) relations between them; the category `Group'/`Grp' of groups with group homomorphisms; the category `Top' of topological spaces; the category `Vect_K' of vector spaces over a specific given field `K' with linear transformations between them;
16:25:27 <dgpratt> ski: yes :) I felt I had the best chance of understanding if I focused on the set perspective first
16:26:16 <ski> the category of directed graphs (allowing loops, and possibly multiple parallel edges) with graph homomorphisms; the category of "dynamical systems", where each object is a set together with an endofunction, and morphisms "commute" in the "obvious" way
16:27:39 * ski thinks the two latter are nice simple example settings for the basic CT concepts
16:29:23 <ski> (the book "Conceptual Mathematics: a First Introduction to Categories" by William Lawvere,Steve Schanuel in 1997 uses those a lot)
16:31:03 <timthelion> > {-In ghci, with Data.Either loaded.  This failes telling me there is No instance for (Monad (Either a0)) -} sequence [Right ""]
16:31:04 <lambdabot>   Right [""]
16:32:22 <geekosaur> I think that's expected?  it's in Control.Monad.Instances
16:32:23 <MostAwesomeDude> timthelion: I'm finding that instance in Control.Monad.Instances.
16:32:40 <ski> timthelion : you can also try `Data.Either'
16:33:04 <timthelion> ski: I did...
16:33:06 <ski> (oh, you said "with Data.Either loaded" -- ok, strange)
16:33:16 <timthelion> MostAwesomeDude: thanks :) works
16:33:31 <MostAwesomeDude> Sure.
16:33:44 <timthelion> according to the haddock Data.Either has an instance: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either
16:34:09 <Z`> Suppose I have a line of the form "string1 string2 string3", how could I extract each string in each one variable ?
16:34:26 <MostAwesomeDude> timthelion: Maybe it's only in newer bases?
16:34:28 <timthelion> > unwords "oh my lambda!"
16:34:30 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:34:30 <lambdabot>         against inferred ty...
16:34:33 <rwbarton> timthelion: are you running ghc 7.6?
16:34:47 <timthelion> rwbarton: 7.4.2 here.
16:34:56 <ski> > let [string1,string2,string3] = "string1 string2 string3" in (string1,string2,string3)
16:34:57 <lambdabot>   (*Exception: <interactive>:3:4-56: Irrefutable pattern failed for pattern [...
16:35:12 <rwbarton> oh
16:35:16 <Z`> mind that the line has type IO String :P
16:35:17 <MostAwesomeDude> timthelion: base 4.5.x.x doesn't have it in Data.Either; it's a recent thing apparently.
16:35:18 <ski> > let [string1,string2,string3] = words "string1 string2 string3" in (string1,string2,string3)  -- forgot `words' :)
16:35:19 <lambdabot>   ("string1","string2","string3")
16:35:25 <rwbarton> did you "import Data.Either" or ":m +Data.Either"
16:35:42 <timthelion> rwbarton: import Data.Either
16:36:13 <rwbarton> my understanding is that "import" at the ghci prompt doesn't get instances from modules that are imported into the module you imported
16:36:21 <rwbarton> which afaict is a bug
16:36:28 <BMeph> > words "oh my lambda!"
16:36:29 <lambdabot>   ["oh","my","lambda!"]
16:36:40 <BMeph> timthelion: ^ That? :)
16:36:43 <timthelion> rwbarton: thanks
16:36:47 <timthelion> BMeph: yes.
16:36:48 <ixmatus> @undo do values <- table printGenerated values saveGenerated values
16:36:48 <lambdabot>  Parse error at end of input
16:36:54 <Z`> but words operates on String not IO String
16:37:07 <ixmatus> erp
16:37:15 <timthelion> Z`: then you have to bind the IO String to a string.
16:37:19 <BMeph> @type fmap words
16:37:20 <lambdabot> forall (f :: * -> *). (Functor f) => f String -> f [String]
16:37:41 <ixmatus> @undo do values <- table; printGenerated values; saveGenerated values;
16:37:41 <lambdabot> table >>= \ values -> printGenerated values >> saveGenerated values
16:37:41 <BMeph> Z`: Pretend the "f" above means "IO"... :)
16:38:39 <Z`> thanks :)
16:42:15 <ixmatus> quick question
16:42:34 <ixmatus> when is it considered idiomatic to use de-sugared do notation
16:42:38 <ixmatus> and when is it not?
16:42:59 <ixmatus> I would assume large binding blocks should use do notation for the easier to-read format, and de-sugared for little one-liners?
16:43:16 <ski> first, if it's desugared, then it isn't `do'-notation
16:43:23 <shachaf> ixmatus: do for one-liners is fine sometimes.
16:43:31 <monochrom> use your feeling. it is sufficient.
16:43:32 <shachaf> It's often even better to use higher-level combinators.
16:43:39 <ski> instead of saying
16:43:53 <ski>   do temp <- frob
16:44:00 <ski>      x <- barf temp
16:44:03 <ski>      ...
16:44:05 <ski> you can say
16:44:14 <ski>   do x <- barf =<< frob
16:44:16 <ski>      ...
16:44:37 <ixmatus> ski interesting
16:46:00 <ixmatus> shachaf I considered that yes - which is sort of why I'm asking here to get a feel for how much more experienced haskell programmers view the situation
16:46:21 <ixmatus> ski's answer was (I assume) a good example of what you were meaning
16:46:32 <shachaf> ixmatus: You haven't described a situation. :-)
16:46:34 <ski> if you have any specific code you're wondering about, you're free to show it
16:46:59 <shachaf> ski's example is just using >>= -- I'm suggesting that you can also use other things, like fmap and liftM2 and ap and so on.
16:47:19 <ixmatus> nothing in particular that I want critiqued or to show, it was just a general thought that popped in my head whilst writing a small program
16:47:25 <ixmatus> shachaf oh okay
16:48:53 * ski sometimes writes `blah x ...   = do return (...)', aligning `=' and 'do' with other defining equations
16:49:00 <ixmatus> in case you are curious, this is the code I was working on; it feels like I'm using the do notation and de-sugared syntax properly; let me know if it isn't
16:49:01 <hpaste> ixmatus pasted “do and desugared” at http://hpaste.org/74567
16:49:30 <latro`a> not sure why case up there
16:49:44 <latro`a> also
16:49:48 <latro`a> m >>= return . f = fmap f m
16:49:52 <ski> ixmatus : just so you know, you could use `if ... then ... else' instead of `case ... of True -> ...; False -> ...'
16:50:13 <shachaf> I'd probably use do-notation for generatePrintSave
16:50:22 <latro`a> or, if you don't have a Functor constraint (silly historical reasons make it so Monad isn't a subclass of Functor) you can say m >>= return . f = liftM f m
16:50:35 <latro`a> IO has a Functor instance so I'd encourage the former
16:50:41 <shachaf> generatePrintSave = do { values <- table; printGenerated values; encodeFile "tabula-recta.bytestr" values }
16:50:46 <ski>   table = liftM (fromRight . generate) newGenIO
16:50:49 <ixmatus> latro`a okay
16:50:54 <latro`a> and yeah I like do notation for generatePrintSave
16:50:58 <ixmatus> shachaf gotcha
16:51:00 <shachaf> Yes, and what they said.
16:51:07 <ixmatus> great input, thank you guys
16:51:11 <ski> (or `fmap' or `(<$>)' instead of `liftM', if you prefer)
16:51:17 <ixmatus> I didn't realize there was so much more I could do to it :-p
16:51:36 <shachaf> Also, your program has a race condition if the files gets deleted after you check if it exists. :-)
16:51:47 <latro`a> iirc IO's Functor instance is actually *defined* as m >>= return . f
16:51:58 <latro`a> since bindIO and returnIO are the "primitives"
16:52:25 <ski> ixmatus : are you sure `generate' never monadically returns a value of shape `Left ...' ?
16:53:01 <ixmatus> ski the only other shape would be an error - which I should check for; I was going to deal with that later
16:53:16 <latro`a> speaking of Either in the IO monad
16:53:18 <ixmatus> it would only come up if the disk weren't accessible or something like that
16:53:32 <ski> ixmatus : anyway, if i ignore the `return' in `newGenIO >>= return . fromRight . generate', i would still write it as `return . fromRight . generate =<< newGenIO', to get the ordering more sensible
16:53:37 <latro`a> I have a little handy function that I use when I know I should *eventually* get a Right, but might not get it the first time
16:53:52 <shachaf> ixmatus: You probably shouldn't use the name "join" for a function.
16:53:58 <shachaf> (I think your join is Data.List's intercalate.)
16:53:59 <latro`a> eitherCycle lf rf m = either (\l -> lf l >> eitherCycle lf rf m) =<< m
16:54:03 <latro`a> err
16:54:05 <latro`a> dammit
16:54:07 <shachaf> Haskell has some strange names.
16:54:09 <latro`a> eitherCycle lf rf m = either (\l -> lf l >> eitherCycle lf rf m) rf =<< m
16:54:10 <ixmatus> shachaf I don't, it's from another module
16:54:15 <shachaf> latro`a: You're making things too complicated.
16:54:20 <rwbarton> also there's unlines
16:54:21 <ski> @type let eitherCycle lf rf m = either (\l -> lf l >> eitherCycle lf rf m) rf =<< m in eitherCycle
16:54:23 <lambdabot> forall a (m :: * -> *) a1 b b1. (Monad m) => (a -> m a1) -> (b -> m b1) -> m (Either a b) -> m b1
16:54:32 <shachaf> unlines and unwords, yes.
16:54:40 <shachaf> Though unlines isn't the same as intercalate "\n".
16:54:44 <rwbarton> ah I didn't see the one on line 19
16:55:06 <ski> latro`a : the `a1' there looks lonely ..
16:55:14 <latro`a> it isn't :)
16:55:15 <shachaf> Ruby's "join" is called "intercalate", Ruby's "times" is called "replicateM_", Ruby's "each" is called "forM_".
16:55:28 <shapr> bos: In any case, I'm certainly not criticizing your Statistics library :-)
16:55:46 <latro`a> @type let eitherCycle lf rf m = either (\l -> lf l >> eitherCycle lf rf m) rf =<< m in eitherCycle putStrLn return
16:55:47 <lambdabot> forall b. IO (Either String b) -> IO b
16:55:55 <dolio> > unlines ["hello"]
16:55:55 <latro`a> ^may illustrate the idea a bit better
16:55:57 <lambdabot>   "hello\n"
16:56:07 <ski> latro`a : the `()' is dropped on the ground :)
16:56:22 <latro`a> that would be the idea, yeah, but the IO still happens
16:57:02 * ski would attempt to make a version which passes on the monadically returned value from the `lf l' action, and rename the other operation with a `_'
16:57:14 <ixmatus> why is if-then-else preferred up there over case?
16:57:14 <Z`> ah mm .. in order to read all lines of a file .. do I use recursion ?
16:57:14 <latro`a> hm?
16:57:31 <latro`a> readFile should give you a whole string, delimited by newlines
16:57:33 <ixmatus> I'm coming from erlang land where the case notation is preferred over if
16:57:44 <Z`> I was using hGetLine
16:57:57 <latro`a> hGetContents is probably what you wanted
16:57:58 <Z`> what if the size of the file is gigantic ?
16:58:00 <latro`a> ah
16:58:01 <monochrom> yes you can use recursion or anything that works
16:58:11 <latro`a> well, hGetContents will proceed lazily
16:58:18 <latro`a> but space usage in haskell is...subtle
16:58:28 <monochrom> also, hGetLine is not free of the "what if the line is gigantic" same problem
16:58:29 <hpc> hGetContents is even subtler
16:59:07 <widith> I'm using the data type Ptr from Foreign.Ptr and I want to access the item a inside Ptr a. I can't pattern match against it though
16:59:36 <shachaf> widith: You probably want peek from Foreign.Storable
16:59:37 <monochrom> you can't. use "peek" or something along that line. and do it in IO
16:59:39 <rwbarton> there is no a "inside" a Ptr a
16:59:46 <rwbarton> @type peekPtr
16:59:46 <shachaf> And what rwbarton said.
16:59:47 <lambdabot> Not in scope: `peekPtr'
16:59:47 <bos> widith: there is no "item a inside"
16:59:50 <rwbarton> @type readPtr
16:59:51 <lambdabot> Not in scope: `readPtr'
16:59:53 <rwbarton> oh
16:59:56 <rwbarton> @hoogle Ptr a -> IO a
16:59:57 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
16:59:57 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
16:59:57 <lambdabot> Network.Socket.Internal peekSockAddr :: Ptr SockAddr -> IO SockAddr
16:59:57 <ski> @type let eitherCycle lf rf s m = either (\l -> lf s l >>= \s -> eitherCycle lf rf s m) (rf s) =<< m in eitherCycle
16:59:59 <lambdabot> forall a a1 (m :: * -> *) b b1. (Monad m) => (a -> a1 -> m a) -> (a -> b -> m b1) -> a -> m (Either a1 b) -> m b1
17:00:08 <shachaf> @ty Foreign.Storable.peek
17:00:10 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
17:00:12 <latro`a> what's the s for?
17:00:26 <widith> ah ok thanks
17:00:55 <ski> latro`a : it's the monadic result from `lf s l'
17:01:11 <latro`a> but what does it default to when you're calling locally
17:01:33 <latro`a> like, my usual use case is eitherCycle putStrLn return; what's the s in that situation?
17:01:50 <ski> latro`a : it could e.g. be used to keep track of how many times `m' as "failed", and possibly store some information accumulated by the calls to `lf'
17:01:59 <latro`a> ah interesting
17:02:03 <latro`a> but if you just don't care
17:02:09 <latro`a> then it can be ()
17:02:11 <latro`a> harmlessly
17:02:12 <latro`a> right?
17:02:22 <ski> @type let eitherCycle_ lf rf m = either (\l -> lf l >> eitherCycle_ lf rf m) rf =<< m in eitherCycle_  -- :)
17:02:24 <lambdabot> forall a (m :: * -> *) a1 b b1. (Monad m) => (a -> m a1) -> (b -> m b1) -> m (Either a b) -> m b1
17:03:06 <ski> latro`a : you're quite right. i was just wondering whether the generalization which doesn't ignore the intermediate result might be useful
17:03:17 <latro`a> @type let eitherCycle lf rf s m = (\l -> lf s l >>= \s -> eitherCycle lf rf s m) (rf s) =<< m in \lf rf m -> eitherCycle lf rf () m
17:03:18 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
17:03:18 <lambdabot>     Probable cause: `=<<' is applied to too many arguments
17:03:18 <lambdabot>     In the expression:
17:03:23 <latro`a> uh
17:03:39 <latro`a> oh
17:03:39 <latro`a> duh
17:03:45 <latro`a> @type let eitherCycle lf rf s m = either (\l -> lf s l >>= \s -> eitherCycle lf rf s m) (rf s) =<< m in \lf rf m -> eitherCycle lf rf () m
17:03:47 <lambdabot> forall a (m :: * -> *) b b1. (Monad m) => (() -> a -> m ()) -> (() -> b -> m b1) -> m (Either a b) -> m b1
17:03:52 <latro`a> eh, isomorphic
17:04:00 <latro`a> wait
17:04:01 <latro`a> m ()
17:04:15 <latro`a> I guess it's still basically isomorphic, since the m a1 I had before I could never do anything
17:04:46 <latro`a> anyway, for the actual purpose I was using, this isn't useful, but this could be very nice for other monads
17:04:54 <latro`a> as it stands my eitherCycle isn't very useful outside IO
17:05:16 <latro`a> for example with Maybe it will either succeed or loop infinitely
17:05:30 <widith> If I have something of type (Ptr Word8), how do I access Word8 ? Its not of type storable
17:06:28 <ski> latro`a : state monads
17:07:11 <latro`a> yup
17:07:18 <latro`a> that was the useful example I had in mind :)
17:08:00 <Z`> If I have an IO [String] how do I get a [String] ?
17:08:01 <ski> i suppose an expression monad might work as well
17:08:09 <ski> Z` : no
17:08:49 <latro`a> you're thinking about it the wrong way; you bind the IO [String] to a function which uses the [String] that comes from it
17:08:59 <ski> what you can do is to use `do'-notation, like e.g.
17:09:23 <ski>   do myListOfStrings <- myIOListOfStrings
17:09:32 <ski>      ..(myListOfStrings)..
17:09:45 <Z`> ok
17:10:27 <latro`a> note that you then can't use the [String] outside that do block, unless it's part of the return value of the overall IO action
17:10:40 <ski> (and this will desugar to a call to `(>>=)' -- sooner or later you'll want to figure out how that operator works -- but if you just want to get things working atm, it can wait)
17:11:28 <Z`> I'd like to pass [String] into a function outside of the IO monad to do some work
17:11:40 <ski> that shouldn't be a problem
17:11:55 <ski> the last line of the `do'-expression above could e.g. be
17:11:56 <Z`> but I would have to return IO () ?
17:12:01 <Z`> from that function ?
17:12:03 <ski>   print (nonIOFunction myListOfStrings)
17:12:05 <ski> or
17:12:09 <ski>   return (nonIOFunction myListOfStrings)
17:12:23 <ski> Z` : it has to be `IO Something', yes
17:12:32 <Z`> thank you
17:12:50 <Z`> is calling main recursively like:  maind = do { ... main } a bad thing in itself ?
17:12:54 <ski> no
17:12:58 <Z`> ok
17:13:23 <Melvar> I have just used sequence . intersperse (putChar "\n") and it feels great. I just keep finding more and more ways everything fits together.
17:14:06 <ski> (sometimes it can be nicer to use a specific higher-order combinator, like `mapM_',`forM_',`foldM',&c. .. but doing such tail-recursion isn't by itself bad -- just like using `goto' in C isn't inherently bad)
17:14:39 <ski> Melvar :)
17:15:03 <Melvar> (putChar '\n') of course.
17:15:15 <monochrom> @type sequence . intersperse (putChar '\n')
17:15:16 <lambdabot> [IO ()] -> IO [()]
17:15:29 <monochrom> sequence_ may be even greater
17:15:31 <shachaf> I think recursion in Haskell is more common than goto in C.
17:15:44 <ski> Melvar : ooc, how does the action list you're passing into that look like ?
17:15:48 <shachaf> Idioms like fix $ \loop -> do ...; when blah loop
17:15:51 <Melvar> Ahyes, didn’t think of the return.
17:16:49 <Jafet> Why do you have [IO ()] anyway
17:16:59 <Z`> why is hGetContents h, invalidates my handler after it finishes ?
17:17:14 <monochrom> I don't understand the question
17:17:35 <monochrom> one handler cannot serve two masters
17:17:41 <ski> Z` : `hGetContents' turns the handle into a semi-closed state, it will be closed when the EOF is reached (or the rest GC:ed)
17:17:46 <monochrom> err, one handle cannot serve two masters
17:18:04 <ski> Z` : you shouldn't `hClose' a `Handle' passed to `hGetContents'
17:18:09 <Z`> ok
17:18:17 <Jafet> Especially IDE disk handles
17:20:01 <Melvar> ski: It goes something like flip map xs $ \x -> do … . I used forM and returned a value (a [String] to pass to putStr . intercalate "\n") before, but this way allowed me to catch exceptions more conveniently.
17:25:14 <ski> ok
17:25:56 <ski>   (`map` xs) $ \x -> do ..x..  -- an alternative
17:26:20 <Melvar> Thanks.
17:28:49 <hpaste> rosie pasted “closures” at http://hpaste.org/74568
17:29:06 <rosie> I'm trying to write up an explanation of closures. I'm not 100% sure about it. Could you let me know what you think?
17:29:32 <nand`> “a closure is a function that creates a new function” disagree
17:30:39 <hpc> i would say closures are just a fancy name for how lexical scope interacts with first-class functions
17:30:40 <nand`> for example, x^y is a closure - it doesn't get calculated right away due to nonstrict semantics, so it closes over the free variables x and y in a reducible expression
17:31:08 <monochrom> it's so long.     just kidding!
17:31:28 <nand`> at any rate, I think ‘closure’ is an implementation detail
17:31:52 <monochrom> closure is the created thing, not the creator
17:32:57 <nand`> loosely speaking, a closure is an expression with certain values filled in
17:33:11 <nand`> (that are free in the definition)
17:33:27 <Melvar> I feel slightly uncomfortable with the map section now. Maybe I’ll use (<$> xs) instead … though I more often use that in place of liftM than map …
17:33:52 <nand`> isn't there a flip map somewhere?
17:34:06 <ski> @let pam = flip map
17:34:07 <lambdabot>  Defined.
17:34:13 <hpc> nand`: in the traverse modules somewhere
17:34:24 <Melvar> Shouldn’t it be named for?
17:34:28 <nand`> Data.Traversable.for
17:34:29 <nand`> yeah
17:34:48 <nand`> oh, but that's not quite the thing - it's more general
17:34:52 <nand`> (in two ways)
17:35:05 <ski> > pam [100,200] $ \x -> pam [0,1,2] $ \y -> x + y
17:35:07 <lambdabot>   [[100,101,102],[200,201,202]]
17:36:05 <nand`> the Data.Traversable naming schemes are a bit hairy
17:36:11 <nand`> forM/for/mapM/traverse stuff
17:36:12 <edwardk> > Data.Traversable.for [100,200] $ \x -> Data.Traversable.for [0,1,2] $ \y -> x + y
17:36:13 <lambdabot>   No instance for (GHC.Show.Show (f [[b]]))
17:36:13 <lambdabot>    arising from a use of `M804500...
17:36:32 <nand`> edwardk: add Identity?
17:36:35 <t7> danr: why is no-one following your contracts repo? its really cool stuff
17:36:41 <edwardk> oh, derp
17:37:02 <nand`> for = forM, strangely enough
17:37:15 <nand`> (not exactly, but reasonably close)
17:37:48 <danharaj> What does `*` mean in an -hy heap profile?
17:38:20 <johnw> t7: where is it?
17:38:40 <t7> https://github.com/danr/contracts
17:39:04 <t7> i think this is a really important step forward. Could add some extra safety to other languages too
17:39:12 <t7> kinda like fstar from microsoft
17:39:29 <johnw> t7: have you seen http://contracts.scheming.org/?
17:39:35 <Melvar> I will just use flip map because I’m pretty sure I’ll know what it means when I look again in two weeks or so. Not confident of the same with (`map` xs).
17:40:12 <t7> johnw: yeah, err... its not the same :)
17:41:10 <johnw> is there a document to go with danr/contracts?
17:42:06 <ski> Melvar : then i suppose i shouldn't suggest any  foo `flip` bar  to you ..
17:42:58 <johnw> so, I can see the contract ensure that head is not used on an empty list
17:43:03 <johnw> is this something that gets checked at runtime?
17:44:05 <ski> johnw : yes, contracts are checked at run-time
17:44:26 <johnw> is there any documentation anywhere for it?
17:45:34 <hpaste> rosie annotated “closures” with “closures (annotation)” at http://hpaste.org/74568#a74569
17:45:48 <rosie> Thanks all for your help! Is this explanation better?
17:46:53 <Melvar> ski: I guess if foo or bar are sufficiently-high-precedence expressions themselves?
17:48:05 <ski> johnw : perhaps <http://docs.racket-lang.org/guide/contracts.html>,<http://docs.racket-lang.org/reference/contracts.html>,<http://www.eecs.northwestern.edu/~robby/pubs/papers/ho-contracts-icfp2002.pdf> ?
17:49:28 <Nafai> tl;dr, are these Eiffel-style contracts?
17:50:12 <ski> @type let foo = \kons as -> foldr kons `flip` as in foo . foo
17:50:14 <lambdabot> forall b a. (a -> b -> b) -> [[a]] -> b -> b
17:51:01 <ski> Nafai : inspired by them, but not exactly like that, aiui -- they support contracts on higher-order functions, properly assigning blame in the right place if a contract fails
17:52:04 <ski> Melvar : so  foo  in  foo `flip` bar  needs to take two arguments
17:53:32 <rosie> any opinions on the explanation of closures?
17:53:52 <t7> ski: no contracts are not checked at run time
17:54:00 <t7> lol did you even look
17:54:08 <hbIppo> @src Writer [String] tell
17:54:08 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:54:27 <t7> it uses an SMT solver to inductively test the contract ahead of time
17:54:40 <hbIppo> @src (Writer [String]) tell
17:54:40 <lambdabot> Source not found. You speak an infinite deal of nothing
17:55:10 <hpc> @src Writer tell
17:55:10 <lambdabot> Source not found.
17:55:17 <Nafai> ski: nice
17:55:35 <Axman6> :t tell
17:55:37 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
17:55:57 <c_wraith> tell is more or less: tell v = first $ mappend v
17:56:25 <hbIppo> thanks for the help
17:56:30 <c_wraith> or is that backwards?  v is the second argument, isn't it?
17:56:32 <nand`> c_wraith: flip mappend
17:56:35 <c_wraith> yeah
17:56:49 <nand`> hmm, reverse writer anywhere?
17:57:01 <nand`> though you can just use the Dual of the monoid
17:57:11 <nand`> or whatever that newtype is called
17:57:33 <c_wraith> Just use only commutative monoids.  Then it's equivalent either way!
17:58:56 <hbIppo> oh ok I made it
18:00:27 <ski> t7 : i've not looked at <https://github.com/danr/contracts> no. i was talking about the system in Racket
18:02:56 <t7> ah, well check it out its awesome
18:22:31 * shapr waves his cane
18:22:39 <shapr> I remember when this channel had zero members!
18:22:56 <c_wraith> then you came along and ruined the beauty of the silence
18:23:00 <shapr> pretty much
18:23:03 <arbn> shapr: Really?
18:23:08 <shapr> arbn: yes, really
18:23:11 <c_wraith> shapr founded this channel.
18:23:14 <arbn> Cool.
18:23:37 <c_wraith> mostly by tricking academics into thinking other academics were using it
18:23:42 <shapr> c_wraith: exactly
18:23:46 <c_wraith> Which, as soon as two joined at the same time, became true!
18:23:51 <shapr> c_wraith: it's an early example of tying the knot
18:23:57 <c_wraith> haha
18:24:24 <shapr> One of classmates in my Programming Languages class got Haskell, so he's joined here once or twice, but he said they're always talking about supergenius stuff.
18:24:42 <arbn> shapr: Ooh.
18:24:47 <Nafai> I don't understand stuff here about half the time
18:25:01 <shapr> Nafai: I don't understand the recent lenses discussion at all, so about the same here.
18:25:14 <c_wraith> Somewhere along the line, I absorbed enough to understand this channel most of the time. Basically osmotic learning.
18:25:23 <c_wraith> I was sure lost at the start, though
18:25:26 <edwardk> shapr: what do you want to know about lenses?
18:25:29 <typoclass> shapr: what was the lenses discussion about?
18:25:30 <Ralith> c_wraith: that's half the reason I join IRC channels like this
18:25:35 <Ralith> osmotic learning owns
18:25:48 <shapr> edwardk: You know my standard question, how can I use them to improve my daily code?
18:25:50 <c_wraith> edwardk: do you have notifications set whenever someone says lens?
18:26:03 <shapr> what can I *DO* with 'em that makes 'em better than the alternatives?
18:26:04 <edwardk> c_wraith: yes
18:26:19 <c_wraith> Well, that explains that.
18:26:20 <Nafai> the reason I stick around although not understanding stuff is I know that if I put enough effort in, there are people here like edwardk that would take the time to help me understand
18:26:53 <typoclass> c_wraith: his lair has a 20-foot screen with a world map that lights up
18:27:01 <nand`> c_wraith: I like to think he's just always present
18:27:28 <edwardk> shapr: did you see the pong example?
18:27:36 <startling> shapr: data X a b = { _one :: a, _two :: b}; makeLenses ''X; and then you can do `over one (+ 1)` and `over two (+ 2)` and so on
18:27:43 <shapr> edwardk: No, could you link it again?
18:27:45 <startling> that's the way they've helped me the most
18:27:47 <nand`> startling: two +~ 2
18:28:02 <startling> nand`: yeah. `over` is more useful in general, though
18:28:13 <nand`> over = %~ ?
18:28:15 <edwardk> https://github.com/ekmett/lens/blob/master/examples/Pong.hs#L114 see that and the surround lines
18:28:23 <edwardk> nand`: yes
18:28:45 <c_wraith> mostly, lenses are an abstraction of...  changing how you're looking at data, in the broadest sense...  that have a bunch of nice properties
18:29:23 <c_wraith> You get the most use out of them when you can take advantage of the abstraction by writing generic code that doesn't care *what* lens it has.
18:30:48 <nand`> I like line 208
18:32:06 <c_wraith> or when you can take advantage of lens utility functions to create functions to pass to other higher-order functions.  That's why they're particularly handy for record update, record update syntax being decidedly non-first-class.
18:35:52 <edwardk> shapr: the main advantages to working with lenses and traversals is that you get a huge menagerie of combinators that you can use with a similarly huge menagerie of different lenses, traversals, isomorphisms, etc., so you get a lot of ways to put together some very simple pieces
18:39:42 <tylerkahn> "A subcategory D ⊆ C is full if D(A,B) = C(A,B) for all objects A,B of D." this means that for all A,B in D, the set of morphisms between A and B in D = the set of morphisms between A and B in C
18:39:46 <tylerkahn> right?
18:45:17 <shapr> edwardk: Can you show an example written in 'plain' Haskell and the same thing written with lenses? I just don't get it.
18:45:24 <shapr> Wait, you have a blog post lens tutorial, right?
18:45:42 <edwardk> shapr: lookup k m   vs.   m^.at k
18:45:56 <edwardk> shapr: that doesn't seem like such a big deal at first
18:46:33 <edwardk> but you can also write back to it
18:46:47 <edwardk> at k .~ Just 10 $ m
18:46:48 <lispy> edwardk: I thought the point of lenses wasn't so much the projection but making record labels first class. In particular to make it so that updates could be higher-order
18:47:07 <edwardk> lispy: well, record fields are kind of the bread and better of lenses.
18:47:33 <edwardk> (("hello","world"),"!!!")^._1._2
18:47:54 <lispy> I think your example of k .~ Just 10 $ m, gets at what I mean
18:47:55 <liyang> But you can make more exotic kinds of baked goods too.
18:48:31 <edwardk> now, one of the interesting things that lens lets you do over and above what the other lens packages is that you can use traversals and setters as well as much lenses
18:48:45 <edwardk> both +~ 10 $ (1,2)    ==> (11,12)
18:48:46 <lispy> I haven't looked at lenses, but I know they would help simplify my 6502 implementation, so I have a TODO item to study up.
18:49:33 <lispy> my implementation uses lots of records and a specialized state monad
18:49:37 <edwardk> note both is a traversal, not a lens, but it composes with lenses or other setters or getters or folds with (.)
18:50:06 <lispy> > both (+1) (1,2)
18:50:07 <lambdabot>   Not in scope: `both'
18:50:09 <nand`> there are lots of incredibly cool things you can golf together with lenses
18:50:19 <edwardk> mapped.both +~ 2 $ [(1,2),(3,4)]    ==> [(3,4),(5,6)]
18:50:42 <edwardk> lispy: both f (a,b) = (,) <$> f a <*> f b
18:50:55 <edwardk> looks like a definition for traverse ;)
18:51:09 <lispy> :t (<*>)
18:51:09 <edwardk> :t let both f (a,b) = (,) <$> f a <*> f b
18:51:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:51:11 <lambdabot> <no location info>:
18:51:11 <lambdabot>     not an expression: `let both f (a,b) = (,) <$> f a <*> f b'
18:51:16 <edwardk> :t let both f (a,b) = (,) <$> f a <*> f b in both
18:51:17 <lambdabot> forall t (f :: * -> *) a. (Applicative f) => (t -> f a) -> (t, t) -> f (a, a)
18:52:30 <nand`> what is ‘ignored’ useful for?
18:52:45 <edwardk> > let both f (a,b) = (,) <$> f a <*> f b; over l f = runIdentity . l (Identity . f) in over both (+1) (1,2)
18:52:48 <lambdabot>   (2,3)
18:54:35 <edwardk> > let both f (a,b) = (,) <$> f a <*> f b; over l f = runIdentity . l (Identity . f); foldMapOf l f = getConst . l (Const . f) in foldMapOf both Sum (1,2)
18:54:38 <lambdabot>   Sum {getSum = 3}
18:55:03 <edwardk> > let both f (a,b) = (,) <$> f a <*> f b; over l f = runIdentity . l (Identity . f); foldMapOf l f = getConst . l (Const . f) in foldMapOf (traverse.both) Sum [(1,2),(3,4)]
18:55:04 <lambdabot>   Not in scope: `traverse'
18:55:12 <edwardk> > let both f (a,b) = (,) <$> f a <*> f b; over l f = runIdentity . l (Identity . f); foldMapOf l f = getConst . l (Const . f) in foldMapOf (Data.Traversable.traverse.both) Sum [(1,2),(3,4)]
18:55:14 <lambdabot>   Sum {getSum = 10}
18:55:43 <edwardk> notice traverse is a traversal, both is a traversal, their composition is a traversal, so you can use foldMapOf, over, etc. all the combinators that work with traversals on them
18:55:56 <edwardk> nand`: its mostly used when putting together other traversals
18:56:06 <edwardk> nand`: as a base case, etc.
18:56:56 * lispy tries, in vain, to resist the urge to rewrite this fortran lexer/parser/analysis in Haskell. Java/C++ can be maddening.
18:57:15 <nand`> come to think of it, :: Traversal a a c d would have me thinking f g x = x <$ g x
18:57:39 <nand`> (might as well be a lens)
18:57:42 <shapr> lispy: I have that class next term... write a parser in C++ for some random language.
18:57:52 <shapr> lispy: I know it's gonna make me cry :-(
18:58:21 <lispy> shapr: will they also ask you to write a parser in brainfuck?
18:58:39 <nand`> a brainfuck parser in brainfuck
18:58:43 <nand`> step towards a self-hosting brainfuck interpreter
18:58:43 <lispy> shapr: comp. sci. masochism 101?
18:58:45 <shapr> I doubt it, my instructor would fail someone instantly if they used the f-word in class.
18:58:50 <Jafet> shapr: http://pikersden.eu/~eclipser/err.txt
18:59:38 <lispy> Jafet: wow
18:59:47 <lispy> template errors really are the worst
18:59:49 <djahandarie> And they said GHC was bad :)
19:00:31 <sipa> nand`: how about a brainfork interpreter in brainfuck?
19:00:59 <lispy> shapr: It's just a shame to take sometihng as elegant as parsing and make it an exercise in tedium by forcing students to use C++. FWIW, I had to use Java for my first "build a parser" class in undergrad.
19:01:33 <lispy> shapr: the best lesson was: Never use java to write a parser :)
19:01:36 <shapr> Jafet: looks like fun
19:01:43 <shapr> lispy: haha, I agree
19:02:04 <Jafet> Well, spirit is a library for parser combinators
19:02:21 <nand`> lispy: step one is to port parsec
19:02:33 <Jafet> It's not very different from parsec, but you probably want to pipe g++ through head.
19:03:17 <BMeph> lispy: Lesson Learned? ;)
19:03:27 <lispy> nand`: I'm kind of torn about parsec. I think writing your own mini-parsec is a great exercise for learing Haskell. I'm not sure I want to use parsers written in it if a proper grammar exists and can be put through a parser generator.
19:04:25 <lispy> nand`: the reason is simply that a high level specification of your grammar is easier to study and reason about. Parsec, for all it's coolness, makes it hard to infer your grammar.
19:05:25 <lispy> Now, since I was talking about Fortran, I might have to use parsec because I don't know if you could write a GLR parser that handles the older fortran standards.
19:05:29 <Ralith> are there any good grammar-oriented parsing libs for haskell?
19:05:40 <lispy> Ralith: happy is GLR
19:05:56 <Nereid> but happy is a parser generator
19:06:00 <lispy> or whatever the acronym Im' thinking of is
19:06:12 <lispy> Maybe I didn't understand Ralith's question
19:06:13 <edwardk> lispy: its lalr and glr, yes
19:06:31 <Ralith> lispy: I'm interested in a library; something that operates within haskell.
19:06:44 <lispy> Ralith: what does it take as input?
19:06:52 <Jafet> parsec lets you parse things without caring about grammar theory.
19:07:05 <Ralith> C lets you program things without caring about purity.
19:07:07 <edwardk> Ralith: there is no recursive ascent or otherwise glr parser combinator library in haskell that works as a library. its pretty hard to build one
19:07:18 <Ralith> edwardk: ah well.
19:07:35 <edwardk> Ralith: well, there isn't a library for that sort of stuff in c either ;)
19:07:50 <Jafet> edwardk: conceptually hard?
19:08:05 <Ralith> edwardk: right, I was just making the point that not having to care about things isn't always for the best.
19:08:08 <edwardk> there are tools for building them, and the reason is you need to know at compile time a lot about the transitions ;)
19:08:40 <edwardk> Jafet: yes. i've been fiddling with a library of GLL parser combinators for haskell off and on for a year or so
19:09:26 * lispy is a witness to edwardk's claim
19:09:52 <lispy> I recall you calling me at one point and talking about a (monoid based was it?) parser combinator
19:10:06 <lispy> that must have been 2009
19:10:18 <edwardk> lispy: yeah that was one of my earlier designs
19:11:01 <lispy> I think I was confusing you a little bit during that call. I say monoid like I do monad, which appears to go against the grain.
19:11:22 <lispy> moe-nad moe-noid
19:11:37 <lispy> I guess it's supposed to be moe-nad and mon-oid
19:11:43 <edwardk> yeah
19:11:56 <johnw> Mo Nad, and Ma Noid
19:12:06 <johnw> it's like a family
19:12:10 <lispy> heh
19:12:19 <Jafet> Nad-chan and Noid-chan
19:12:21 <shapr> Where do weak freyd categories fit in there? :-(
19:12:59 <monochrom> stir-freyd vegetables and beef
19:13:17 <nand`> so moe
19:13:18 <edwardk> shapr: nowhere, if you want to get anything done ;)
19:13:23 <shapr> ha
19:13:52 <dmwit> Yeah, everybody but lispy and me pronounces monoid incorrectly.
19:15:20 <edwardk> sok, ddarius and shapr are the only two i know who pronounce haskell as haSKELL with a prounounced empHASSIS on the second syllABLE.
19:15:39 <shapr> edwardk: I don't do that anymore :-P SPJ retrained me
19:15:46 <edwardk> shapr: yay!
19:16:12 <int80_h> where can I find the definition of (,). I've seen it before, thought it was the infix for pure but I can't find it.
19:16:36 <edwardk> int80_h: (,) is the built in constructor for a product
19:16:36 <shapr> @source (,)
19:16:36 <lambdabot> (,) not available
19:16:38 <rwbarton> it's the tuple constructor... (,) a b = (a,b0
19:16:41 <rwbarton> *)
19:16:43 <edwardk> > (,) 1 2
19:16:44 <lambdabot>   (1,2)
19:17:00 <edwardk> > let (x,y) = (1,2) in x
19:17:02 <lambdabot>   1
19:17:12 <edwardk> > let (,) x y = (1,2) in x
19:17:13 <lambdabot>   1
19:17:15 <int80_h> oh that's all. okay
19:17:41 <thoughtpolice> > let f = (1,) in snd (f 2)
19:17:43 <lambdabot>   Illegal tuple section: use -XTupleSections
19:17:46 <thoughtpolice> aw :(
19:18:02 <thoughtpolice> i didn't think anyone would enable that honestly, i just wanted to try.
19:18:23 <Jafet> > :set -XTupleSections
19:18:24 <lambdabot>   <no location info>: parse error on input `:'
19:18:41 <geekosaur> lambdabot is not ghci
19:19:00 <Jafet> She is much, much more.
19:19:13 <monochrom> and less
19:30:20 <johnw> can I make Data.Text the default for string literals types in ghci?
19:30:36 <shachaf> No.
19:31:19 <johnw> can I make a different monad the "default" in ghci?
19:31:30 <johnw> like, StateT String IO ()?
19:31:50 * hackagebot bytestring-show 0.3.5.3 - Efficient conversion of values into readable byte strings.  http://hackage.haskell.org/package/bytestring-show-0.3.5.3 (DanDoel)
19:32:24 <dmwit> johnw: no
19:32:34 <dmwit> Don't force us to answer "no" a third time. You won't like it.
19:32:38 <johnw> lol
19:32:41 <dmwit> =)
19:32:55 <johnw> can I get you to answer "yes" to this question?
19:33:01 <mm_freak> johnw: no
19:33:01 <monochrom> maybe
19:33:10 <shachaf> Yes.
19:33:17 <dmwit> mu
19:33:30 <typoclass> meow
19:33:36 <mm_freak> 1/sqrt(2) (|yes> + |no>)
19:33:41 <shachaf> ᒨ
19:34:04 <typoclass> shachaf: what kind of a bizarre j is that?
19:34:27 <mm_freak> looks like a flipped L
19:34:45 <Nereid> well I pick 1/sqrt(2) (|yes> + i |no>)
19:34:47 <typoclass> it has a dot as well. might be debris though
19:34:53 <dmwit> U+006969 CAPITAL DOTTED BACKWARDS L
19:34:57 <monochrom> ✓
19:35:32 <Nereid> johnw: you can put -XOverloadedStrings in ghci can't you?
19:35:37 <shachaf> U+0062 LATIN SMALL LETTER REVERSED D
19:35:52 <dmwit> Nereid: That allows Text, but doesn't force it.
19:35:56 <Nereid> sure
19:36:04 <Nereid> I hate ctrl-w
19:36:31 <rking> Nereid: You're trying to use the emacs-like binding but your client (XChat?) is closing the tab?
19:36:36 <Nereid> kvirc, and yes
19:36:46 <johnw> Neired: how do I run default (Text)?
19:36:53 <shachaf> johnw: You don't.
19:36:58 <mm_freak> ctrl-w normally closes tabs in GUIs
19:37:00 <rking> Nereid: weechat is really good, and has a proper ^w
19:37:02 <shachaf> Didn't you see above?
19:37:04 <typoclass> shachaf: that'd be a 'b', dude
19:37:16 <Nereid> rking: I use irssi occasionally
19:37:26 <Nereid> the annoying thing is, kvirc used to erase a word with ^w
19:37:30 <johnw> hey, Nereid, that worked!
19:37:31 <shachaf> typoclass: U+0062 is definitely a LATINS AMLL LETTER REVERSED D.
19:37:32 <johnw> thanks
19:37:37 <rking> I really resent the Windows invasion of Linux keybindings. There was a time when Mozilla had basic ^A, ^E, etc.
19:37:48 <Nereid> johnw: yeah, it uses IsString a => a for string literals
19:37:50 <Nereid> instead of [Char]
19:37:52 <johnw> yep
19:37:55 <johnw> perfect
19:37:59 <johnw> now I can do shelly $ ls "."
19:38:01 <ski> johnw : are you going to either answer no to this question or $PERFORM_EMBARRASSING_FEAT ?
19:38:12 <mm_freak> i think mozilla provides good keyboard control
19:38:12 <johnw> instead of shelly $ ls (fromText $ Data.Text.Lazy.pack ".")
19:38:31 <mm_freak> well, i made the dangerous assumption that by mozilla you mean firefox
19:38:34 <shachaf> Oh, ghci added that in 7.6.
19:38:36 <Nereid> johnw: -XOverloadedStrings just replaces "string literal" with fromString "string literal"
19:39:13 <applicative> does shelly . ls need a Text or String?
19:41:58 <johnw> it needs a FilePath
19:42:01 <johnw> from Filesystem.Path
19:42:37 <Nereid> isn't type FilePath = String
19:42:58 <rking> mm_freak: I was referring to the time back when it was just called Mozilla. I think somewhere around the Firefox rebranding it started making ^A mean "select all"
19:42:59 <johnw> not if it comes from Filesystem.Path
19:43:12 <johnw> most shelly programs import Prelude hiding (FilePath)
19:43:18 <Nereid> oh that FilePath
19:43:24 <rking> mm_freak: But I use Pentadactyl now, and have scarcely been happier with any facelift to any software.
19:43:28 <Ralith> rking: these days it respects the GTK settings, iirc
19:44:05 <jfeser> so, I have a noobish question
19:44:20 <nand`> what was ^A before select all?
19:44:27 <jfeser> I have a list of FilePaths, and I'd like to read the files into a list of Strings
19:44:32 <Nereid> nand`: go to start of line
19:44:35 <nand`> jfeser: mapM readFile
19:44:43 <rking> Ralith: Very cool. I'll look for that.
19:44:50 <Nereid> with ^E going to end
19:44:53 <nand`> Nereid: oh cool, that's neat
19:45:03 <Nereid> it's one of the few I know. :(
19:45:19 <nand`> I still use Home/End for those myself
19:45:21 <Ralith> rking: (and GTK of course has an emacsy option among the defaults)
19:45:25 * Nereid vim user
19:45:59 <Ralith> rking: of course, this produces the confusing situation in which the keybinds active when an input box is hilighted are dramatically different than those active otherwise
19:46:01 <Nereid> zsh has some vi-like input mode but it confused the hell out of me.
19:46:02 <jfeser> I've looked at mapM, but it's telling me that it can't match the expected type [FilePath] with IO [FilePath]
19:46:26 <Clint> most shells have emacs- and vi-like binding sets
19:46:43 <Nereid> jfeser: show us the code?
19:46:49 <Nereid> well
19:46:53 <rking> I've been working on this thing for readline (bash) and also zsh that I call vi-keys+, which is basically vi keys but includes all non-conflicting emacs keys.
19:46:53 <Nereid> actually.
19:47:00 <applicative> jfeser: so you have an IO[FilePath]
19:47:04 <Nereid> yeah.
19:47:15 <jmcarthur> i wish the changes to TypeOperators in ghc 7.6 allowed me to use (|) as a type operator
19:47:22 <rking> It's a bummer that on most terminals, without an escape timeout, you cannot distinguish between Alt+b and Esc,b
19:47:34 <applicative> iofilepathlist >>= mapM readFile  is maybe a little ugly jfeser
19:47:44 <jfeser> :applicative yeah. I mapped over the directory contents list to get a list of full file paths
19:47:57 <Nereid> do { paths <- iopaths; mapM readFile paths }
19:48:13 <Nereid> where iopaths :: IO [FilePath]
19:48:22 <Nereid> same as what applicative wrote.
19:48:32 <applicative> right so you defined an action; so you need to feed it to mapM readFile (with >>= or some equivalent_) if I'm following
19:48:50 <applicative> like Nereid says
19:49:20 <Nereid> because mapM expects a pure list.
19:49:27 <jfeser> ok.  so IO [FilePath] is an action that gets a list of FilePaths
19:49:36 <Nereid> sure
19:50:11 <applicative> jfeser: right, so with do notation you do myfilelist <- iofilelist to 'get the real list'
19:50:21 <Nereid> 'quotes'
19:50:55 <applicative> then you have something you can do a map or mapM or mapM_ over
19:57:15 <edwardk> jmcarthur: or @
19:57:21 <td123> does anyone know where I can read up on where extensible exceptions went in ghc 7.6.1? I've heard they are now in Control.Exception.Base but I can't find any news items for it
19:57:56 <jfeser> think I got it.  once I have the full paths, I use fullPaths >>= (mapM readFile) to get the list of strings.  thanks for the help
20:05:33 <gentleben> whats up with hackage?
20:06:29 <applicative> hackage is being kind to me
20:11:46 <monochrom> seems to respond to me, too
20:16:51 * hackagebot html-conduit 0.1.0.2 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-0.1.0.2 (MichaelSnoyman)
20:16:53 * hackagebot happstack-foundation 0.2.1 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.2.1 (JeremyShaw)
20:18:59 <freakhill> hello, i have a question about embedding a haskell interpreter
20:19:11 <Cale> freakhill: what's your question?
20:19:16 <freakhill> i'm learning haskell and would like to make a text editor
20:19:31 <freakhill> for extensibility purpose, i would like the text editor to be able to evaluate haskell code
20:19:34 <freakhill> like lisp
20:19:52 <freakhill> has something similar already been done?
20:20:04 <Cale> Yes, there's a project called yi
20:20:27 <freakhill> oh, thank you very much!
20:20:47 <freakhill> now i'm off to start on my pet project! :)
20:21:00 <Cale> and the way it does extensibility, from what I understand, is similar to xmonad
20:21:21 <freakhill> that's to say?
20:21:24 <Cale> in that most of the functionality is provided as a Haskell library, and then your configuration file is actually the main program
20:21:38 <freakhill> i see
20:21:44 <freakhill> you make a cut down interpreter
20:21:48 <freakhill> and run in on a script
20:22:06 <Cale> and when you edit that, it stores the current state of the editor, recompiles the program, and then executes it, restoring the state from the new instance
20:22:06 <freakhill> emacs is probably made in a similar way
20:22:16 <freakhill> oh ok!
20:22:19 <Cale> (and you don't end up interpreting anything)
20:22:53 <Cale> Another approach would be to use something like hint, and make a fixed plugin/extension API, with interpreted modules
20:22:58 <hpaste> johnw pasted “Error with a use of ^” at http://hpaste.org/74570
20:23:04 <johnw> Can anyone explicate that error for me?
20:23:11 <johnw> I've scratched my head over it for a while now
20:23:19 <startling> freakhill, emacs isn't similar at all
20:23:26 <johnw> I don't fully understand how numeric literals are handled in Haskell yet
20:23:39 <Tekmo> :t (^)
20:23:41 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
20:23:44 <Tekmo> :t (*)
20:23:45 <lambdabot> forall a. (Num a) => a -> a -> a
20:23:57 <johnw> and 2 isn't Num and Integral?
20:24:03 <johnw> or does it just not know what kind of number it is?
20:24:20 <Tekmo> I think the problem is that it doesn't know which Num or Integral to use
20:24:27 <Tekmo> printf is polymorphic in its argument
20:24:29 <startling> ^yeah
20:24:29 <freakhill> isn' emacs basically a running emacs interpreter that happen to load text editing features??
20:24:30 <liyang> Is it Int, or is it Integer?
20:24:43 <johnw> do I need a type annotation in the arg to printf?
20:24:47 <Tekmo> and the numeric literals are polymorphic in their type
20:24:48 <Tekmo> :t 2
20:24:49 <lambdabot> forall t. (Num t) => t
20:24:51 <Cale> It doesn't know what type the exponent is.
20:24:55 <Cale> :t (^)
20:24:56 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
20:24:56 <johnw> it's Int
20:24:58 <Tekmo> So it doesn't know what type the numbers are
20:25:06 <johnw> well, I don't know either
20:25:07 <tylerkahn> freakhill: emacs is a great operating system lacking only a good text editor
20:25:08 <Tekmo> and thereforre it doesn't know which printf method to invoke
20:25:17 <Tekmo> You can fix this by giving those numbers explicit types
20:25:20 <freakhill> ahah
20:25:21 <Cale> actually, I think it *does* know what type the argument to printf is
20:25:25 <startling> tylerkahn, have you actually used it
20:25:30 <Cale> Just not the exponent
20:25:39 <tylerkahn> startling: heh i kid. i used it a bit for clojure. nothing serious tho
20:25:42 <tylerkahn> i use vim
20:25:42 <johnw> so I have to say 1024^(2 :: Integer)?
20:25:47 <startling> tylerkahn, I bet that joke is older than you are
20:25:55 <tylerkahn> startling: i bet it is!
20:26:02 <Cale> johnw: Ordinarily, numeric defaulting would solve this.
20:26:06 <Tekmo> No, the entire number, I believe
20:26:07 <liyang> johnw: best to do something like import Prelude hiding ((^)); import qualified Prelude; (^) :: Num a => a -> Integer -> a; (^) = (Prelude.^)
20:26:12 <Cale> johnw: Let me see if I can understand why it's not.
20:26:13 <Tekmo> i.e. (1024^2 :: Integer)
20:26:22 <startling> tylerkahn, it bugs me because there's so much shittiness in emacs; largeness is the least of them
20:26:25 <liyang> (Or specialise it even further.)
20:26:49 <freakhill> startling: what does irk you in emacs?
20:26:53 <tylerkahn> startling: i don't even know enough about emacs to point out its faults. i just picked up vim about 2 years ago and am still learning it
20:27:09 <Cale> johnw: How are you compiling this / which extensions are turned on?
20:27:15 <Cale> johnw: That code compiles for me
20:27:19 <johnw> liyang: that certainly works
20:27:26 <rwbarton> johnw: you must have a default () declaration or something
20:27:31 <johnw> I'm using OverloadedStrings and DeriveDataTypeable
20:27:35 <johnw> and default (Text)
20:27:45 <rwbarton> yeah don't do that
20:27:53 <johnw> not doing that is painful in other ways
20:27:54 <Cale> aha!
20:28:07 <startling> freakhill, no real "module" system, no safety/sandboxing, no modal editing. >:(
20:28:08 <Cale> At least do  default (Integer, Double, Text)
20:28:12 <rwbarton> default (Integer, Double, Text)
20:28:24 <johnw> ok
20:28:35 <freakhill> startling: no modal editing is a bad thing?
20:29:07 <johnw> default (Integer, Text) or default (Integer, Double, Text), downgrades the errors to warnings
20:29:12 <Tekmo> Yeah, I think modes are supposed to be bad
20:29:16 <Tekmo> and I'm saying this as a vi user!
20:29:18 <johnw> "Default the following constraint(s) to type `Integer'"
20:29:21 <johnw> Defaulting
20:30:57 <startling> freakhill: yeah, I think so. I really like modal editing.
20:31:35 <cbm80> i can't get cabal-install to compile and install with 7.6.1
20:31:43 <johnw> neither can I
20:31:51 <cbm80> damn
20:31:55 <johnw> but I use the cabal-install binary built by 7.4.2, I can install most things in 7.6.1
20:31:57 <johnw> s/if I
20:32:10 <Tekmo> Report it!
20:32:20 <Tekmo> Do your civic duty!
20:32:33 <cbm80> i was just asking to see if this was a known issue, actually
20:35:58 <Cale> You might need to use the development version of cabal-install
20:36:24 <Cale> Usually it doesn't end up on hackage until around the time the Haskell Platform is released, I think
20:36:40 <Cale> I haven't upgraded GHC yet to try it, so I don't know
20:37:22 <Cale> http://darcs.haskell.org/cabal/
20:37:23 <cbm80> i tried teh version that acatually comes bundled with the source of 7.6.1, and i tried the version that is on github
20:37:57 <Cale> In that case, I don't know
20:38:07 <Cale> it looks like the latest changes here were in April
20:38:36 <cbm80> imho the latest version is here: https://github.com/haskell/cabal
20:38:37 <Cale> I bet dcoutts would know
20:39:02 <Cale> yeah, that's definitely newer
20:39:44 <applicative> cbm80: yeah it looks like the github version requires version 1.17 the the Cabal library. I take it ghc-7.6 has 1.16?
20:39:53 <cbm80> yes
20:40:29 <applicative> cbm80: you would have to reinstall the Cabal libraries before installing cabal-install, which is a somewhat problematic proposition
20:40:37 <cbm80> and there's a deeper change somewhere in there, because even after much fiddling it fails with a nasty typehchecking error
20:40:46 <johnw> edwardk: if I have foo ^. count, and I want to return a foo that has count incremented by one, what's the idiom for that?
20:41:05 <cbm80> applicative: i did. i cleaned out everything and installed everything from scratch
20:41:53 <applicative> if you do ghc-pkg list, what does it say the version of Cabal is?
20:42:29 <cbm80> applicative: 1.16
20:42:56 <Okasu> hello, do you know any not uotdateted haskell opencv bindings?
20:43:07 <applicative> yeah, so to build the github one, it would have to install a new version of the Cabal library, which is tightly integrated with ghc
20:43:21 <Okasu> HOpenCV is completely outdated
20:43:36 <johnw> ah, found %~
20:44:18 <applicative> http://hackage.haskell.org/package/HOpenCV-0.1.2.3 was updated two months ago, or do you mean its out of line with opencv itself
20:44:26 <cbm80> applicative: that is correct. i even tried to install Cabal 1.17 from github *after* i installed the version that is bundeled with ghc, and it still fails
20:44:49 <Cale> johnw: there's also +~
20:45:13 <applicative> yes, cbm80 but what I'm saying is its a generally not a good idea to install Cabal (the library that defined module relations etc)
20:45:32 <applicative> cbm80: the wisdom is that you should stick with the one that come with your ghc.
20:45:53 <applicative> cbm80: do you still have an old version of the cabal-install executable
20:46:01 <cbm80> applicative: yes, i do
20:46:07 <johnw> great
20:46:15 <applicative> ah, it should work fine though.
20:46:48 <cbm80> i'll try it
20:46:54 <applicative> i haven't updated mine  and I'm using some ghc-7.6
20:47:31 <applicative> cabal --version tells me I have cabal-install version 0.14.0 using version 1.14.0 of the Cabal library
20:48:23 <applicative> cbm80 and I havent had trouble at all installing things
20:48:29 <johnw> Cale what if I have two foos, and I want to add the count of both foos together to make a new foo with the combined count?
20:48:34 <johnw> is there a sexy combinator for that?
20:48:40 <cbm80> applicative: ok theh that's probably the best solution for now
20:48:52 <johnw> right now I'm doing count +~ (foo1 ^. count) $ foo2
20:49:06 <applicative> oh cool it works.
20:52:08 <applicative> johnw: for maximum perliness, I think you dont need those parens?
20:52:50 <applicative> count +~ foo1^.count $ foo2
20:53:16 <Okasu> applicative: yep, it doesn;t compiles with opencv 2.4, i'v already fixed it by hacking the source but it nasty anyway
20:53:20 <johnw> there's not a count +~ foo1 <++> foo2 or something?
20:54:41 <applicative> Okasu: I see, it's that it uses opencv 2.3;  I take it you saw http://hackage.haskell.org/package/CV
20:54:56 <applicative> Okasu: which claims to admit 2.4
20:56:26 <WhoNeedszzz> Hey guys
20:57:00 <WhoNeedszzz> What would the type signature be for a function that can accept any Num, but returns Floating?
20:57:22 <applicative> johnw I don't know, but I was wanting the same thing a couple of times just yesterday...
20:57:30 <johnw> (Num a, Floating b) => a -> b ?
20:57:48 <WhoNeedszzz> Well it's also 3 parameters
20:57:59 <WhoNeedszzz> I tried (Num a, Floating b) => a -> a -> a -> b
20:58:03 <WhoNeedszzz> But threw an error
20:58:04 <applicative> forall a b .( Num a ,Floating b) => a -> b
20:58:17 <WhoNeedszzz> areaTriangle :: (Num a, Floating b) => a -> a -> a -> b
20:58:25 <ion> Ah, an error. That clears it up.
20:58:30 <applicative> what was the error?
20:59:00 <WhoNeedszzz> Should it be (Num a, Floating b) areaTriangle :: a -> a -> a -> b ?
20:59:13 <ion> ಠ
21:00:36 <WhoNeedszzz> http://ideone.com/9UInK
21:00:46 <applicative> WhoNeedszzz: no, areaTriangle :: (Num a, Floating b)  => a -> a -> a -> b ; areaTriangle = undefined
21:01:08 <ion> Your error is not in the type signature.
21:01:18 <applicative> does it need Num b too? seems od
21:01:20 <applicative> d
21:01:52 <WhoNeedszzz> http://ideone.com/6EHXg is my function
21:02:18 <WhoNeedszzz> I'm brand new to Haskell :)
21:02:22 <applicative> you must be adding things of different types or something
21:02:47 <ion> (/) takes a “Fractional a => a” and sqrt takes a “Floating a => a”; you’ll need to convert “Num a => a” into one with realToFrac.
21:03:13 <ion> But why do you want to restrict the input into “Num a => a” in the first place?
21:03:31 <Jafet> There is no function (Num a, Floating b) => a -> b anyways
21:03:37 <applicative> WhoNeedszzz: it's fine by itself if you scrap the signature
21:03:46 <applicative> WhoNeedszzz: the inferred signature is areaTriangle :: Floating a => a -> a -> a -> a
21:03:58 <ion> jafet: Ah, indeed.
21:04:04 <applicative> Jafet: yeah, I was trying to construct one
21:04:08 <WhoNeedszzz> but then could you pass integers?
21:04:32 <ion> Yes, by converting them with fromIntegral or realToFrac.
21:04:49 <applicative> WhoNeedszzz: if  it is all Floating , that means (basically)  either Double or Float
21:04:58 <WhoNeedszzz> right
21:05:12 <Jafet> (Num a) means your function has to work for any Num, not some Num.
21:05:17 <WhoNeedszzz> but i'm saying if someone was to call the function would areaTriangle 3 4 6 work?
21:05:32 <ion> “3”, “4” and “6” are polymorphic, it will work directly.
21:05:43 <WhoNeedszzz> Ah yeah i'm still grasping polymorphism
21:06:17 <applicative> WhoNeedszzz: written just like that, it will work, but that's because the compiler will read 3 as 3.000
21:06:18 <ion> The literal “3” stands for something like “fromInteger TheIntegerThree”.
21:06:24 <ion> @type fromInteger
21:06:25 <lambdabot> forall a. (Num a) => Integer -> a
21:07:36 <WhoNeedszzz> ok interesting
21:07:42 <applicative> if you do 'let l = length mystring in  areaTriangle l l l' it will fail, since length is an Int which isn't one of the Floating number types
21:08:20 <applicative> so, a ion is saying, you would do 'let l = fromIntegral (length mystring) in  areaTriangle l l l
21:08:34 <ion> (In this specific case, there’s also genericLength.)
21:09:03 <applicative> ion, right, I chose length as returning an Integral type
21:09:33 <WhoNeedszzz> so http://ideone.com/TQ0XN is fine?
21:10:00 <applicative> WhoNeedszzz: do you think you will apply the functions to Ints/Integers or to Floats/Doubles or do you insist on all
21:10:24 <WhoNeedszzz> Either
21:10:34 <WhoNeedszzz> It's for a class
21:10:44 <WhoNeedszzz> I'm supposed to allow either
21:10:55 <applicative> WhoNeedszzz: yeah.  Remember you don't need the signature at all.  The one you wrote is the one ghci gave me
21:11:20 <WhoNeedszzz> Yeah i think he just wants us to put it for practice
21:12:42 <applicative> @type let areaTriangle a b c = let s = (a+b+c)/2 in sqrt (s*(s-a)*(s-b)*(s-c)) in areaTriangle
21:12:44 <lambdabot> forall a. (Floating a) => a -> a -> a -> a
21:13:02 <Jesin> guys
21:13:24 <Jesin> the newest C and C++ standards require that x%y has the same sign as x, I am saddened
21:13:34 <applicative> @type let areaTriangle a b c = let s = fromIntegral ( a+b+c)/2 in sqrt (s*(s-a)*(s-b)*(s-c)) in areaTriangle
21:13:35 <Jesin> when is that useful?
21:13:35 <lambdabot> forall a. (Integral a, Floating a) => a -> a -> a -> a
21:14:02 <WhoNeedszzz> i'm confused by that one
21:14:02 <applicative> uh oh
21:14:06 <applicative> me too
21:14:12 <applicative> @type let areaTriangle a b c = let s = fromIntegral ( a+b+c)/2 in sqrt (s*(s-a)*(s-b)*(s-c)) in areaTriangle 1 2 3
21:14:14 <lambdabot> forall t. (Floating t, Integral t) => t
21:14:30 <WhoNeedszzz> that doesn't make sense
21:14:38 <arbn> Huh. Interesting type, there.
21:14:53 <applicative> i'm getting fromIntegral in the wrong place
21:15:12 <latro`a> why do you have fromIntegral at all
21:15:14 <applicative> @type let areaTriangle a b c = let s =  (fromIntegral (a+b+c))/2 in sqrt (s*(s-a)*(s-b)*(s-c)) in areaTriangle 1 2 3
21:15:15 <lambdabot> forall t. (Floating t, Integral t) => t
21:15:25 <latro`a> are the side lengths integral?
21:15:28 <latro`a> or what's integral
21:15:50 <latro`a> if the side lengths are integers but you have to use them as floating, just don't force them to be integral
21:16:09 <WhoNeedszzz> the side lengths can be integers or floating
21:16:10 <copumpkin> floatDigits :: a -> IntSource
21:16:10 <copumpkin>   a constant function, returning the number of digits of floatRadix in the significand
21:16:30 <latro`a> you really can't have them be *either* integers or floating
21:16:42 <latro`a> if you're using floating operations like sqrt
21:17:36 <latro`a> using floating operations directly makes them floats; using a fromIntegral call makes them integers
21:18:44 <applicative> latro`a: yea, but how can I put in Integral a b c and get out a Floating result?
21:19:01 <latro`a> sure, but that will involve a fromIntegral
21:19:05 <latro`a> which will force the input to be Integral
21:19:20 <latro`a> the only alternative I can see is to do something like
21:19:41 <applicative> latro`a: right, the trouble was WhoNeedszzz wanted something that he could feed any number type, but of course get something Floating
21:19:51 <latro`a> newtype IntegralAsFloating a = IAF a; instance Integral a => Floating (IntegralAsFloating a) where sin = sin . fromIntegral etc.
21:20:04 <applicative> ick
21:20:09 <WhoNeedszzz> indeed
21:20:25 <latro`a> something like that *will* work, but isn't desirable by any means
21:21:06 <latro`a> (actually I should say: sin (IAF x) = sin (fromIntegral x), etc., but you get the idea)
21:21:52 * hackagebot yesod 1.1.0.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.0.3 (MichaelSnoyman)
21:21:54 * hackagebot yesod-auth 1.1.1.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.1.1 (MichaelSnoyman)
21:23:31 <applicative> latro`a: I get the trouble I was having. In
21:23:34 <applicative> @type let areaTriangle a b c = let s =  (fromIntegral (a+b+c))/2 in sqrt (s*(s-a)*(s-b)*(s-c)) in areaTriangle 1 2 3
21:23:36 <lambdabot> forall t. (Floating t, Integral t) => t
21:23:39 <WhoNeedszzz> So basically i should just keep it the way i have it
21:24:03 <applicative> I was forgetting that a b and c appear in the second part under the square root
21:24:12 <latro`a> yup
21:24:18 <latro`a> and that means they must be Floating
21:24:28 <latro`a> sqrt (1 :: Int) isn't allowed
21:24:56 <applicative> @type let areaTriangle x y z = let [a,b,c] = map fromIntegral [x,y,x]; s =   (a+b+c)/2 in sqrt (s*(s-a)*(s-b)*(s-c)) in areaTriangle 1 2 3
21:24:57 <lambdabot> forall t. (Floating t) => t
21:25:10 <applicative> > let areaTriangle x y z = let [a,b,c] = map fromIntegral [x,y,x]; s =   (a+b+c)/2 in sqrt (s*(s-a)*(s-b)*(s-c)) in areaTriangle 1 2 3
21:25:11 <lambdabot>   0.0
21:25:23 <latro`a> works, except you replaced z with x
21:25:48 <applicative> now there seems to be a little trouble with the definition....
21:25:52 <applicative> hha
21:25:58 <applicative> > let areaTriangle x y z = let [a,b,c] = map fromIntegral [x,y,z]; s =   (a+b+c)/2 in sqrt (s*(s-a)*(s-b)*(s-c)) in areaTriangle 1 2 3
21:25:59 <lambdabot>   0.0
21:26:05 <latro`a> that one *should* be 0
21:26:15 <latro`a> > let areaTriangle x y z = let [a,b,c] = map fromIntegral [x,y,z]; s =   (a+b+c)/2 in sqrt (s*(s-a)*(s-b)*(s-c)) in areaTriangle 3 4 5
21:26:17 <lambdabot>   6.0
21:26:47 <latro`a> which if you check, 1/2*3*5*4/5 = 1/2*3*4=1/2*12=6
21:26:48 <latro`a> so
21:26:50 <latro`a> worked
21:26:54 <applicative> ach I'm too error prone for the d*mn Num class
21:26:56 * hackagebot yesod-core 1.1.1.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.1.2 (MichaelSnoyman)
21:26:58 * hackagebot yesod-form 1.1.1.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.1.1.1 (MichaelSnoyman)
21:27:00 * hackagebot yesod-static 1.1.0.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.1.0.1 (MichaelSnoyman)
21:27:02 * hackagebot tagstream-conduit 0.5.2 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.2 (YiHuang)
21:27:37 <applicative> but can it be what WhoNeedszzz intended?
21:27:59 <latro`a> probably not
21:30:14 <applicative> of course
21:30:52 <applicative> sorry for the panic over my first attempt to get Integral arguments in, WhoNeedszzz
21:31:13 * applicative makes good sense but only in thevery long run
21:31:24 <WhoNeedszzz> ha it's all good
21:31:29 <WhoNeedszzz> i'm fine with my original function
21:31:35 <WhoNeedszzz> It's only the first hw
21:31:43 <WhoNeedszzz> so i doubt he expects us to know all that
21:31:52 * hackagebot http-conduit 1.6.0.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.6.0.3 (MichaelSnoyman)
21:33:47 <WhoNeedszzz> can you not use negative numbers in ranges?
21:34:46 <latro`a> > [1,0..]
21:34:47 <lambdabot>   [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20...
21:35:30 <latro`a> iirc you will have issues if you try to do
21:35:35 <latro`a> > [1..-5]
21:35:36 <lambdabot>   Not in scope: `..-'
21:35:39 <latro`a> er
21:35:42 <latro`a> > [1..(-5)]
21:35:44 <lambdabot>   []
21:35:58 <latro`a> but that is because it's defaulting the step to 1, and seeing that it can't get any elements that way
21:35:59 <latro`a> so
21:36:02 <latro`a> > [1,0..(-5)]
21:36:04 <lambdabot>   [1,0,-1,-2,-3,-4,-5]
21:36:08 <latro`a> and magic happens
21:37:12 <Rotaerk> > [1,1,2,3..]
21:37:14 <lambdabot>   <no location info>: parse error on input `..'
21:37:22 <ion> > [1,0.. -5]
21:37:24 <lambdabot>   [1,0,-1,-2,-3,-4,-5]
21:37:25 <latro`a> that isn't how Enum works
21:37:26 <latro`a> @ ro
21:37:30 <latro`a> * Rotaerk
21:37:34 <Rotaerk> k :P
21:37:49 <Cale> Jesin: That's generally been the case for C and C++, iirc.
21:37:49 <ion> > [3,1,4,1,5,9,2,..]
21:37:50 <lambdabot>   <no location info>: parse error on input `..'
21:38:00 <WhoNeedszzz> well i'm having trouble with this: http://ideone.com/qyMEW
21:38:24 <WhoNeedszzz> When doing addRange -5 0 1 I get: No instance for (Num (Int -> Int -> Int -> Int))
21:38:24 <WhoNeedszzz>       arising from a use of `-'
21:38:28 <Cale> Jesin: It's shitty for programmers, but apparently admits a marginally faster hardware implementation?
21:38:42 <johnw> @pl (\f x y -> f x y)
21:38:42 <lambdabot> id
21:38:44 <latro`a> you need addRange (-5) 0 1
21:38:45 <Cale> Jesin: and so it tends to be what CPUs implement directly
21:38:52 <WhoNeedszzz> ah
21:38:55 <latro`a> the way haskell's - works is irritating
21:39:07 <Cale> why?
21:39:28 <Cale> I guess it's not whitespace sensitive
21:39:31 <latro`a> eh, it's not so bad, but you wind up needing parens around negations; since space is a separator this is inevitable, but it's still annoying
21:39:44 <Rotaerk> should've used a distinct operator for negation
21:39:45 <ion> whoneedszzz: Since function application binds the tightest, that parses as (addRange) - (5 0 1)
21:40:14 <Jesin> > [(-1),(-2),...(-12)]
21:40:15 <lambdabot>   A section must be enclosed in parentheses thus: (... (- 12))Not in scope: `...
21:40:18 <Jesin> > [(-1),(-2),..(-12)]
21:40:19 <lambdabot>   <no location info>: parse error on input `..'
21:40:26 <Cale> > [(-1),(-2)..(-12)]
21:40:27 <latro`a> > [(-1),(-2)..(-12)]
21:40:27 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12]
21:40:28 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12]
21:40:29 <ion> dc uses _
21:40:30 <latro`a> ^
21:40:39 <Jesin> derp
21:40:40 <Rotaerk> think I saw some language that uses ~ for negation
21:40:42 <Jesin> kthx
21:40:42 <latro`a> no , before a ..
21:40:44 <Jesin> .......
21:40:57 <startling> Rotaerk: ocaml i think?
21:41:00 <ion> > [-1, -2 .. -12]
21:41:00 <Jesin> Rotaerk: do you mean mathematical negation, or bitwise logical negation
21:41:01 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12]
21:41:02 <Jesin> oh
21:41:03 <startling> or some other ml
21:41:04 <Jesin> k
21:41:35 <Cale> I rather like the particular compromises that Haskell has made there
21:41:52 * hackagebot packdeps 0.4.0.1 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.4.0.1 (MichaelSnoyman)
21:41:54 * hackagebot wai-handler-devel 1.3.0.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.3.0.1 (MichaelSnoyman)
21:42:40 <applicative> >  enumFromThenTo 1 2 6
21:42:41 <lambdabot>   [1,2,3,4,5,6]
21:43:38 <applicative> >  enumFromThenTo 1 3 6
21:43:39 <lambdabot>   [1,3,5]
21:43:51 <WhoNeedszzz> Man haskell sure is awesome though. We had to do the same functions in Haskell and C...man was the C so stupid
21:44:18 <Cale> WhoNeedszzz: You asked earlier whether there was a way to convert an arbitrary Num to an arbitrary Floating type, and I think there is not. However, for most types in practice, you will only need one of fromIntegral or realToFrac (or something like round/truncate/ceiling/floor)
21:44:46 <Cale> (though those parenthetical ones go the other way)
21:44:51 <ion> or u_____C____e
21:45:01 <Cale> hah
21:46:39 <Cale> unsafeCoerce is technically a solution to every type conversion issue, but practically a solution to very few, and theoretically a solution to even fewer.
21:48:38 <latro`a> I think when you write your own numerical instances, you begin to see the power in the numerical typeclass hierarchy
21:48:56 <latro`a> but also the restrictions that that power requires
21:48:57 <nand`> will somebody kill me if I use ‘monadic function’ to refer to a function with the arity 1, as opposed to a ‘dyadic function’ for arity 2?
21:49:09 <Cale> WhoNeedszzz: For example, if there were such an operation, you'd have to convert some guy's polynomial datatype (which might have an instance of Num) into a Double (which has an instance of Floating), and that doesn't quite make sense.
21:49:30 <Cale> nand`: That would be very awkward in the context of Haskell.
21:49:38 <nand`> ah, outside Haskell
21:49:44 <Jesin> nand`: what's a dyadic function
21:50:10 <Jesin> my functions always take one argument
21:50:11 <Jesin> :p
21:50:20 <Cale> Probably clearer just to say single parameter function.
21:50:21 <nand`> Jesin: a function from the cartesian product of two sets
21:50:35 <Cale> Or unary function.
21:50:48 <Jesin> unary sounds good
21:50:53 <nand`> unary sounds good to me too
21:52:14 <applicative> nand`: that is a standard usage; e.g. in logic a one place predicate is called monadic. e.g. we say, 'Tarski proved the decidablility of the monadic predicate calculus'
21:52:35 <ion> jesin: I’m reminded of Bender’s nightmare.
21:53:34 <rking> ion: I don't know that one. What happens?
21:53:40 <Jesin> Tarski's name is on all sorts of awesome stuff.
21:53:46 <Jesin> I like him.  ^_^
21:54:18 <BMeph> nand`: Using monadic/dyadic will usually "pigeonhole" you as a J/K/APL user, but if you're okay with that, then go for it! :)
21:54:19 <latro`a> lots of awesome people have their name on lots of awesome stuff
21:54:48 <nand`> the only bells that name rings is the Banach-Tarski theorem
21:54:49 <ion> rking: Paraphrased: Bender: “There were ones and zeros everywhere… and I think I saw a two!” Fry: “Now now, there’s no two.”
21:54:50 <latro`a> euler, cauchy, riemann, lebesgue, newton, lagrange
21:54:53 <latro`a> not really leibniz
21:55:06 <latro`a> leibniz needs more shit named after him
21:55:34 <nand`> haskell
21:55:45 <latro`a> I hereby rename Haskell as The Monadology
21:56:00 <akamaus> latro`a, +1
21:56:15 <ion> The Programmer Formerly Known As Simon – Monadology
21:57:24 <Jesin> I don't get it.
21:59:10 <johnw> @pl foldMap id xs
21:59:10 <lambdabot> foldMap id xs
21:59:26 <latro`a> @pl doesn't know semantics, only structure
21:59:27 <lambdabot> (line 1, column 23):
21:59:27 <lambdabot> unexpected ","
21:59:27 <lambdabot> expecting variable, "(", operator or end of input
21:59:32 <latro`a> quiet, you
21:59:51 <johnw> is there an mconcat . map?
21:59:52 <nand`> I think it does some optimizations that arise *while* performing point reduction
21:59:57 <nand`> concatMap
22:00:01 <nand`> (=<<)
22:00:11 <nand`> oh, mconcat
22:00:14 <johnw> yeah
22:00:18 <nand`> foldMap
22:00:28 <donri> latro`a: kleisli?
22:00:33 <latro`a> eh
22:00:34 <latro`a> close
22:00:39 <latro`a> that's the main exception
22:00:40 <donri> no idea how to pronounce that ^_^
22:00:48 <latro`a> oh
22:00:50 <latro`a> you meant the name
22:00:51 <latro`a> nvm
22:01:03 <latro`a> anyway I was just naming random mathematicians as they came to mind
22:01:07 <latro`a> there are plenty more
22:01:13 <ion> (mconcat .: map, but anyway, what nand said)
22:01:14 <johnw> is there a monoid for tuples that mappends both sides?
22:01:33 <nand`> should be
22:01:34 <Cale> That's what the usual monoid instances do
22:01:47 <nand`> instance (Monoid a, Monoid b) => Monoid (a, b) -- Defined in `Data.Monoid'
22:01:57 <ion> > ("a","b") ++ ("c","d")
22:01:57 <johnw> ok, great
22:02:00 <lambdabot>   ("ac","bd")
22:02:06 <Ferdirand> @type fold
22:02:07 <lambdabot> Not in scope: `fold'
22:02:09 <latro`a> the other way is Writer, iirc
22:02:21 <nand`> latro`a: but that doesn't form a monoid
22:02:22 <donri> :t (++)
22:02:24 <lambdabot> forall m. (Monoid m) => m -> m -> m
22:02:35 <donri> lambdabot u so weird
22:02:58 <latro`a> :t (<>)
22:02:59 <lambdabot> Doc -> Doc -> Doc
22:03:04 <donri> ;)
22:03:04 <latro`a> lolwut
22:03:07 <ion> nand: (return,(>=>)) :-P
22:03:19 <donri> probably from "pretty" or something built in
22:05:28 <avpx> http://www.downforeveryoneorjustme.com/hackage.haskell.org <-- This tells me that Hackage is up, but I can't access it
22:05:31 <avpx> Anyone else running into trouble?
22:05:45 <applicative> > foldr (<>) empty $ map text ["hello" , " ", "world"]
22:05:47 <lambdabot>   Ambiguous occurrence `empty'
22:05:47 <lambdabot>  It could refer to either `Control.Applicative...
22:06:00 <Cale> avpx: I can access it
22:06:06 <avpx> Cale: Shucks, I wonder what's wrong.
22:06:07 <applicative> > foldr (<>) (text "") $ map text ["hello" , " ", "world"]
22:06:08 <lambdabot>   hello world
22:06:12 <avpx> Cale: What's its IP?
22:06:23 <applicative> > foldr ($$) (text "") $ map text ["hello" , " ", "world"]
22:06:25 <lambdabot>   hello
22:06:25 <lambdabot>  
22:06:25 <lambdabot>  world
22:06:26 <avpx> applicative: Why use foldr with mappend when you can use mconcat?
22:06:30 <Cale> hackage.haskell.org has address 66.193.37.204
22:06:33 <ion> > text "foo" `mappend` text "bar"
22:06:34 <lambdabot>   No instance for (Data.Monoid.Monoid Text.PrettyPrint.HughesPJ.Doc)
22:06:35 <lambdabot>    arisi...
22:06:43 <ion> eh
22:06:54 <avpx> Cale: It's resolving to 69.30.63.204 on my end. Weird.
22:06:55 <applicative> I  wanted to use the <> of Text.PrettyPrint
22:07:07 <avpx> Ah
22:07:18 <ion> applicative: If it had a Monoid instance, (<>) could have been mappend and it would still have worked.
22:07:25 <donri> lambdabot runs old pretty package
22:07:34 <donri> recent ones have monoid
22:07:37 <applicative> yes
22:07:37 <ion> ok
22:07:42 <applicative> really?
22:08:16 <donri> and IsString :)
22:08:38 <applicative> sure enough
22:09:39 <applicative> mconcat $ ["hello","world"] :: Doc works fine with -XOverloadedStrings.
22:09:50 <applicative> mconcat ["hello","world"] :: Doc, rather
22:09:56 <donri> but you should be using wl-pprint-text :)
22:16:53 * hackagebot shakespeare 1.0.1.3 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.1.3 (MichaelSnoyman)
22:19:50 <WhoNeedszzz> Well thanks all who helped
22:19:54 <WhoNeedszzz> I'm sure i'll be back in here
22:19:55 <WhoNeedszzz> :)
22:22:27 <Jesin> http://www.youtube.com/watch?v=ouvNTlTsyPg
22:34:42 <appamatto> Hello. I can't quite figure out how to do composition of Dynamic functions
22:36:10 <appamatto> Does it require creating enough lambdas to "unwrap" the final function result?
22:37:30 <c_wraith> What do you mean by Dynamic function?
22:38:08 <liyang> Data.Dynamic?
22:38:12 <appamatto> Yes
22:38:21 <c_wraith> How do lambdas help with it?
22:38:29 <appamatto> Oh I see, maybe you only need one lambda
22:38:46 <c_wraith> doesn't it have an apply function?
22:39:03 <liyang> :t dynApp
22:39:04 <lambdabot> Dynamic -> Dynamic -> Dynamic
22:39:05 <appamatto> It has apply but not compose
22:40:09 <c_wraith> so write it.  dynCompose = dynApp $ toDyn (.)
22:40:39 <c_wraith> err.  whoops.  needs a couple more dynApps
22:40:42 <c_wraith> but whatever
22:41:26 <liyang> Are you sure Dynamic is the right thing to use here?
22:41:47 <c_wraith> dynamic is almost never the right thing to use
22:42:29 <appamatto> I'm trying to "supress" the type system since I'm writing a language in haskell
22:42:42 <c_wraith> That really doesn't sound required
22:43:12 <appamatto> Hmm, well my code is contained in lists and they need to be heterogenous
22:43:24 <Cale> appamatto: If you really want to suppress the type system, use unsafeCoerce
22:43:38 <Cale> (but get ready for pain)
22:44:04 <appamatto> Cale, I just want to supress it for the part of the system that evaluates my language's expressions
22:44:21 <appamatto> And I like the runtime checking of Dynamic
22:44:22 <ski> appamatto : use a disjoint union ?
22:44:28 <c_wraith> Why don't you just have an Expression type?
22:44:45 <c_wraith> Or maybe a Value type?
22:44:49 <appamatto> because the expressions are lists of values
22:45:12 <ski> why lists ?
22:45:21 <ski> (maybe you mean nested lists ?)
22:45:22 <Cale> There's no way that your code can handle lists of just *any* types at all
22:46:05 <Cale> If you're making a language implementation, you'll need a representation of values in your language
22:46:08 <appamatto> The language itself has an AST
22:46:26 <appamatto> But when I "compile" it to haskell it doesn't really map cleanly
22:46:37 <Cale> You'll likely have some function  eval :: Expr -> Value
22:47:14 <appamatto> It's a concatenative language, so function composition doesn't mean exactly the same thing
22:47:23 <nobdrais1ntone> Is hackage.haskell.org 69.30.63.204 ?
22:47:36 <Cale> hackage.haskell.org has address 66.193.37.204
22:47:44 <Nereid> ^
22:48:12 <appamatto> For example, how do you write an eval function for the concatenative code [ dup ]
22:48:29 <Cale> Okay, so that has actual effects on a stack
22:48:40 <appamatto> Yes
22:48:58 <Cale> So your evaluator is going to take a stack of Value and produce a stack of Value
22:49:11 <appamatto> I don't want it to just mutate a stack though
22:49:12 <mjrosenb> > scanl1 f [1,2,3,4,5]
22:49:13 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:49:14 <lambdabot>    `SimpleReflect.FromExpr ...
22:49:20 <appamatto> I'm translating it into a graph of haskell functions
22:49:36 <mjrosenb> lambdabot: can you please give me the rest of that error?
22:49:56 <appamatto> So dup compiles to [id, id]
22:50:06 <Cale> uhh...
22:50:13 <Cale> how is that to be interpreted?
22:50:24 <appamatto> Each function is the code for a single output
22:50:37 <appamatto> dup has one input and two outputs, so there are two "id" functions
22:50:56 <Cale> mjrosenb: send lambdabot a private message and the error will be longer
22:51:58 <MostAwesomeDude> appamatto: Are you familiar with how Joy works?
22:52:12 <appamatto> The implementation or the spec?
22:52:16 <Cale> That representation doesn't make sense to me
22:52:41 <MostAwesomeDude> Well, the idea that you have type Stack -> Stack for everything.
22:52:45 <appamatto> Yeah
22:52:54 <appamatto> I don't like that way of doing it because it doesn't seem pure
22:53:15 <MostAwesomeDude> I mean, with appropriately-useful types, it might have type Stack 1 -> Stack 2.
22:53:16 <appamatto> You have to evaluate the code sequentially even if certain code paths don't matter
22:53:22 <Cale> What do you mean? Representing things as pure functions operating on a stack isn't pure enough?
22:53:40 <Cale> hmm
22:54:06 <Cale> So you want to represent stack effect types in your evaluator and take advantage of that?
22:54:18 <joeyh> ghc -e 'putStrLn [minBound..maxBound]' # this is both a lot of fun, and fails in a surprising way
22:54:57 <appamatto> Yes, I want to have reasonable types
22:55:17 <johnw> @pl (\_ -> return ())
22:55:18 <lambdabot> const (return ())
22:55:40 <ski> > length ((id :: [] 1 -> [] 1) [])
22:55:41 <lambdabot>   0
22:56:15 <appamatto> It's easier to think of it in terms of data flow. I'm basically drawing a box around a word with inputs and outputs, but inside the box I separate each code path into separate Haskell functions
22:56:21 <joeyh> something about '\55296' leads to "hPutChar: invalid argument (invalid character)"
22:56:48 <joeyh> ah, I think it's some whole code plane
22:57:05 <mjrosenb> Cale: thanks!
22:57:14 <appamatto> The Haskell type checker isn't going to understand how these boxes compose, so that's why I'm not just lifting Haskell types up to my language level
22:57:27 <MostAwesomeDude> appamatto: Well, instead of raising things to Haskell's types, why not carry around something like: data StackType = StackType Int -- and do your own type-checking?
22:58:35 <appamatto> MostAwesomeDude: Yes, I'm going to do my own type checking once the value level computation is finished
22:59:02 <appamatto> I'm still using Haskell's types at runtime (Dynamic)
22:59:28 <appamatto> I'm guessing that unsafeCoerce is actually pretty unsafe :p
22:59:49 <MostAwesomeDude> Well, it's unsound.
22:59:59 <mjrosenb> hrmm,I assume that I just need to add a type annotation to that, but I don't know how lambdabot does that these days, so I don't actually know what type to tac on :(
23:00:39 <cbm80> should the maintrainers be emailed when i encounter someething on hackage that fails to build with 7.6.1?
23:02:21 <dmwit> yes
23:03:03 <cbm80> that'll be alot of emails :) well two at least
23:03:58 <dmwit> bonus points for sending a patch that fixes it
23:04:53 <cbm80> heh
23:05:43 <Ralith> is 7.6 properly out?
23:06:01 <Cale> Ralith: yes, but it's not likely very usable yet
23:06:09 <Cale> (because libraries need to update)
23:06:57 <Ralith> Cale: what about it breaks so many?
23:07:22 <Cale> I haven't tried it
23:07:58 <Cale> Oh, the TypeOperator thing is going to break practically everything dealing with arrows, which sucks.
23:10:22 <tom__> Good morning! "cabal update" repeatedly fails on me with a time out error. Is this me or is it down?
23:11:08 <dmwit> Several people seem to be having trouble with it. Perhaps some poisoned DNS entry somewhere.
23:11:26 <dmwit> If you point your computer at the right IP (instead of using hackage.haskell.org) it should work fine.
23:11:35 <dmwit> 66.193.37.204
23:12:35 <tom__> Ok, do I have to use my local hosts file to do that or is there some obscure command line parameter available in cabal?
23:13:39 <dmwit> It's not too obscure, I think.
23:13:50 <dmwit> Open up ~/.cabal/config and grep for hackage.haskell.org.
23:14:03 <tom__> Thank you!
23:17:49 <appamatto> How do you import an internal module?
23:24:08 <johnw> is there version of FilePath -> IO [FilePath] (getCurrentDirectory), which returns full pathnames and doesn't return . and ..?
23:24:13 <Okasu> CV seems to be broken too :/
23:24:18 <Okasu> LoadingSaving.lhs: /home/george/.cabal/lib/CV-0.3.6.2/ghc-7.4.2/HSCV-0.3.6.2.o: unknown symbol `wrapExtractMSER'
23:24:34 <johnw> (and which doesn't require to rewrite all my code to use a different filesystem library with its own FilePaths)
23:25:34 <Twisol> johnw: I swear someone asked that a couple weeks ago. Wish I remember where it ended up.
23:27:26 <johnw> i've found 4 different ways to read a directory, and they are all so radically different from the ways of telling whether something is a symlink and what its size is
23:27:29 <johnw> it's rather bewildering
23:32:29 <dmwit> "full pathnames"?
23:32:36 <Twisol> I'm getting an error when I try to supply a (MonadIO m) constraint rather than just specifying IO: http://hpaste.org/74575
23:32:43 <dmwit> filter out "." and "..", that part's easy
23:32:44 <johnw> getContents "foo", with a bar in it, should return ["foo/bar"]
23:33:01 <dmwit> mapM ("foo" </>) -- ?
23:33:12 <johnw> yeah, that's what I ended up doing
23:33:22 <dmwit> or whatever
23:33:24 <johnw> just not the world's most efficient method
23:33:26 <dmwit> liftM (map (...))
23:34:10 <dmwit> Twisol: m (), liftIO?
23:34:49 <dmwit> m () probably not necessary, what is up with that argument?
23:34:53 <Twisol> Oh, I was supposed to use liftIO. That fixed it, thanks!
23:35:17 <Twisol> dmwit: http://hackage.haskell.org/packages/archive/pipes/2.3.0/doc/html/Control-Proxy-Tutorial.html
23:35:21 <Twisol> bidirectional pipes
23:36:55 * hackagebot data-pprint 0.2.1.4 - Prettyprint and compare Data values  http://hackage.haskell.org/package/data-pprint-0.2.1.4 (PeterDivianszky)
23:38:53 <dmwit> I can almost believe having a function from () just for uniformity of always having a function arrow (even if this seems weird at first glance to me). But having two arguments, one of which is a unit, that's thrown away...?
23:39:45 <Twisol> It's essentially a coroutine.
23:40:30 <Twisol> The argument is what's given when resuming; the Server type defines the interface (given () requests, responds with ByteStrings))
23:41:55 * hackagebot yesod-platform 1.1.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.2 (MichaelSnoyman)
23:50:44 <johnw> ah, good old $!!
23:50:49 <johnw> solved my space leak
23:50:56 <ion> $!!!
23:51:08 <johnw> down from >1Gb to <20Mb
23:51:16 <johnw> and just had to change one return
23:52:29 <Ralith> whee
23:54:16 <johnw> i've having to train myself to see seq only going one layer down
23:54:31 <Ralith> you know whnf right?
23:54:49 <johnw> (x,y) `seq` foo isn't the same as (x `seq` x, y `seq` y) `seq` foo
23:54:57 <johnw> yeah, I know about nf, hnf and whnf now
23:55:20 <johnw> and how sometimes you are only building the spine strictly, but not the body
23:55:26 <johnw> that's how I knew where to put the $!!
23:55:38 <Saizan> "x `seq` x" is always just "x"
23:55:44 <Saizan> it doesn't add any strictness
23:55:51 <johnw> that was just for demonstration
23:55:54 <johnw> sorry, it wasn't valid
23:56:04 <shachaf> Being just for demonstration makes it even worse!
23:56:12 * shachaf remembers this discussion with johnw a while ago.
23:56:12 <johnw> x `seq` y `seq` (x, y)
23:56:16 <shachaf> Does it make more sense now?
23:56:21 <johnw> yeah, it actually makes great sense now
23:56:23 <mjrosenb> what would be faster, to take a bytestring, convert it into a list and run mapMaybe f on it a few hundred times, or to run concatMap (\x -> case f x of Nothing -> empty | Just y -> singleton y) on the raw bytestring?
23:56:33 <johnw> especially what you were telling me before and bottom and non-termination
23:56:40 <shachaf> mjrosenb: It would be fastest to benchmark it.
23:56:40 <johnw> s/and bottom/about bottom
23:57:26 <mjrosenb> shachaf: thanks.
23:57:35 <johnw> i'm writing a new utility now which is my first use of lenses!
23:57:44 <johnw> they are coming in mighty handy
23:58:00 <edwardk> johnw: was just about to ask about how it was going =)
23:58:03 <Twisol> Lenses look really awesome. Looking forward to putting them to use at some point.
23:58:08 <johnw> edwardk: I love it!
23:58:12 <johnw> i'll show you in a sec
23:58:16 <dmwit> mjrosenb: shachaf was being snarky but also about as helpful as we can be. We don't know the answer, and the way we'd find out the answer is by benchmarking.
23:58:19 <shachaf> mjrosenb: I have the feeling that wasn't as helpful as I hoped.
23:58:25 <edwardk> i need to spend more time writing examples and documentation for lens
23:58:46 <johnw> right now, #haskell is the best docs
23:58:48 <shachaf> I suspect the way dons would also find out the answer by benchmarking.
23:58:52 <shachaf> johnw: That's terrible.
23:59:02 <Twisol> edwardk: Saw your StackOverflow answer about the lens libraries out there, by the way. Great explanation :)
23:59:14 <edwardk> i'm thinking i'll do talks for boston haskell and maybe while i'm out in SF/mountain view on how to use lenses.
23:59:14 <edwardk> Twisol: thanks =)
23:59:52 <edwardk> shachaf: speaking of which, was it ever determined if the bahaskell meetup will be on a day i can go?
23:59:53 <johnw> when are you talking in boston?
