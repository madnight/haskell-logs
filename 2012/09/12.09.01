00:00:52 <Lutin`> What I take combinator-based to mean is something that is based on composition
00:00:54 <ddarius> shachaf: As a specific example, that definition disallows \f -> f (\x -> x), or perhaps a bit more poignantly, \f g -> f (\x y -> g y x)
00:01:48 <Lutin`> He's just saying that the parsing libraries are based on composing different functions to parse as opposed to monolithic functions
00:02:05 <shachaf> ddarius: Well, if you restrict the set of previous-defined combinators, yes.
00:02:13 <shachaf> I'm not sure why the technical sense is particularly interesting, though.
00:02:47 <ddarius> shachaf: It means your functions have no local environment.
00:03:55 <typoclass> tessier: really, don't worry about the word combinator there. some of the functions in parsec-ish libraries take basic stuff ("char 'f'") as arguments, some of the functions take other functions ("*>") and combine them. those people sometimes call those combining functions 'higher-order functions' or 'combinators'
00:04:02 <ddarius> shachaf: As you pointed out before, it's not a property of semantics (unless you do curtail the a priori combinators severly) but of syntax and operational behavior.
00:04:30 <shachaf> ddarius: Ah.
00:05:34 <ddarius> shachaf: If you do the exercise I suggested before, you'll see what does replace the notion of environment as would be used in, e.g., a closure implementation of functions.
00:07:01 <typoclass> s/those people/people
00:07:25 <shachaf> Which exercise?
00:07:43 <ddarius> Most functions in Parsec are technically first order.
00:08:07 <ddarius> [02:51] <ddarius> It is interesting to compare how defunctionalization, combinators, and closures handle representing higher order functions.""
00:08:22 <shachaf> Oh.
00:08:53 <amiller> okay so i had omitted something, and when i put it back in, everything is okay:
00:08:54 <amiller> remember :: Algebra f m => f (m :< f) -> m :< f
00:08:54 <amiller> remember = phi
00:09:12 <amiller> i don't understand what the type signature does there where i couldn't have just used 'phi' in its place
00:09:30 <amiller> it seems to have something to do with unifying two instances of the f
00:20:34 <otters> > fix ("The real WTF is..." ++)
00:20:36 <lambdabot>   "The real WTF is...The real WTF is...The real WTF is...The real WTF is...Th...
00:23:40 <ddarius> cycle = fix . (++)
00:27:38 <shachaf> cycle = fix fox
00:28:08 <shachaf> > fix fox "fax ("
00:28:10 <lambdabot>   "fax (fax (fax (fax (fax (fax (fax (fax (fax (fax (fax (fax (fax (fax (fax ...
01:07:42 <BackTrack> ？
01:33:40 <hpaste> edwardk pasted “fun type error” at http://hpaste.org/74012
01:35:38 <shachaf> Control.Boost
01:35:42 <startling> edwardk: wow
01:36:03 <edwardk> trying to get 'angelic' binding for comonads to work
01:36:09 <edwardk> and its not pleasant ;)
01:36:09 <shachaf> I don't know that I've ever gotten a GHC internal error from typechecking.
01:36:36 <edwardk> i only get them when i press the limits with polykinds
01:38:33 <edwardk> basically that came from a variation on https://github.com/ekmett/indexed/blob/master/src/Indexed/Functor.hs#L110
01:45:33 <Z`> I'd like to write a function that drops every k'th element of a list
01:45:47 <Z`> how could I hold the current position in the list so as to mod it ?
01:45:56 <Z`> accumulator ?
01:47:06 <mikeplus64> :t fox
01:47:07 <lambdabot> forall t a. (Monoid a) => t -> a -> a
01:47:54 <mikeplus64> @src fox
01:47:54 <lambdabot> Source not found.
01:51:21 <eikke> Z`: you dont need that (for a rather inefficient version at least)
01:51:33 <eikke> Z`: dropNth n = concat . unfoldr (\l -> Just (take n l, drop (succ n) l))
01:52:13 <ddarius> mikeplus64: He was lazier than I thought.
01:52:41 <hiptobecubic> eikke, I can never conjure something up that quickly :(
01:53:35 <hiptobecubic> eikke, although, it hangs at the end of the list
01:54:05 <Z`> I don't understand that :P
01:54:06 <eikke> hiptobecubic: oh, right, of course. Only tested on an infinite one
01:54:34 <hiptobecubic> also, it makes groups of n elements
01:54:43 <hiptobecubic> which is dropping the n+1th element
01:55:00 <mauke> :t map snd . filter fst . zip (replicate (k-1) True ++ [False])
01:55:01 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
01:55:01 <lambdabot>     In the first argument of `replicate', namely `(k - 1)'
01:55:01 <lambdabot>     In the first argument of `(++)', namely `replicate (k - 1) True'
01:55:07 <mauke> :t \k -> map snd . filter fst . zip (replicate (k-1) True ++ [False])
01:55:08 <lambdabot> forall b. Int -> [b] -> [b]
01:55:27 <mauke> needs more cycle
01:55:47 <eikke> oh well. then you might need some manual plumbing anyway :)
01:56:12 <hiptobecubic> mauke, isn't that just "take" ?
01:56:21 <mauke> :t \k -> map snd . filter fst . zip (cycle [replicate (k-1) True ++ [False]])
01:56:22 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[Bool]'
01:56:22 <lambdabot>     In the expression: replicate (k - 1) True ++ [False]
01:56:22 <lambdabot>     In the first argument of `cycle', namely
01:56:47 <mauke> :t \k -> map snd . filter fst . zip (cycle (replicate (k-1) True ++ [False]))
01:56:48 <lambdabot> forall b. Int -> [b] -> [b]
01:56:58 <mauke> > (\k -> map snd . filter fst . zip (cycle (replicate (k-1) True ++ [False]))) 5 "hello, world"
01:57:00 <lambdabot>   "hell, wold"
01:57:13 <hiptobecubic> there it is
01:57:36 <Z`> how could one say anything about their performace on such complex expressions ? (besides running it)
01:57:38 <hiptobecubic> i like the zipping approach for some reason
01:57:48 <mauke> Z`: profiling
01:57:51 <hiptobecubic> Z`, running it.
01:57:55 <ddarius> You like representing numbers in unary?
01:58:10 <hiptobecubic> ddarius, apparently. :)
01:58:33 <mauke> ddarius: what's the alternative?
01:58:51 <hiptobecubic> folding with an accumulator?
01:59:11 <edwardk>     Kind incompatibility when matching types:      i :: x      a1 :: x
01:59:13 <edwardk> =)
02:00:41 <hiptobecubic> actually, the fold looks kind of ugly and I'm not sure that you aren't just obfuscating mauke's solution anyway
02:02:10 <ddarius> > let f n = g n where g k [] = []; g 0 (_:xs) = g n xs; g k xs = g (k-1) xs in f 5 "hello, world"
02:02:10 <lambdabot>   []
02:02:49 <ddarius> > let f n = g n where g k [] = []; g 0 (_:xs) = g n xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
02:02:50 <lambdabot>   "hello worl"
02:03:21 <ddarius> > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
02:03:23 <lambdabot>   "hell, wold"
02:03:45 <mauke> how pedestrian
02:22:20 <ion> > (uncurry (++) . second (drop 1). splitAt 4) "hello, world"
02:22:22 <lambdabot>   "hell, world"
02:24:09 <shachaf> > hi "ion"
02:24:11 <lambdabot>   hi ion
02:26:49 <mauke> @let scream = concat . sequence . words
02:26:50 <lambdabot>  Defined.
02:27:19 <ion> > hi "shachaf"
02:27:20 <shachaf> > scream "hi mauke"
02:27:21 <lambdabot>   hachaf
02:27:22 <lambdabot>   "hmhahuhkheimiaiuikie"
02:27:25 <mauke> > scream "hi shachaf"
02:27:27 <lambdabot>   "hshhhahchhhahfisihiaicihiaif"
02:27:31 <ion> > hi "mauke"
02:27:33 <lambdabot>   hauke
02:27:34 <shachaf> > hi "ion"
02:27:36 <lambdabot>   hion
02:27:38 <shachaf> Yay!
02:28:05 <shachaf> > hi ""
02:28:07 <lambdabot>   h
02:28:39 <mauke> > scream "int i = 0;"
02:28:40 <lambdabot>   "ii=0ii=;ni=0ni=;ti=0ti=;"
02:28:45 <ion> I wonder why hi isn’t in Prelude?
02:29:00 <shachaf> ion: hi name | (n:_) <- name, n `elem` "aeiouy" = "h" ++ name | otherwise = "h" ++ drop 1 name ?
02:29:09 <shachaf> Wait, no.
02:29:16 <shachaf> It does dropBy to a vowel. Or something.
02:29:33 <shachaf> That's a complicated function! What's the source?
02:29:42 <shachaf> Wait, no it's not.
02:30:03 <ion> It’s nothing pretty, @let hi (x:xs) | x `elem` "bcdfghjklmnpqrstuvwxzBCDFGHJKLMNPQRSTUVWXZ" = hi xs; hi xs = text ('h' : xs)
02:30:07 <shachaf> > hi "Yuu-chan"
02:30:09 <lambdabot>   hYuu-chan
02:30:30 <ion> Hmm, true, y can be pronounced like that.
02:30:35 <shachaf> Oh.
02:30:52 <ion> Yuu-chan is difficult. :-P
02:30:53 <shachaf> hi name = "h" ++ dropWhile (`notElem` "aeiouyAEIOUY") name ?
02:31:03 <ion> aye
02:31:20 <ion> Except for u and y depending on how they’re pronounced
02:31:32 <shachaf> Oh.
02:32:03 <shachaf> @let ?isVowel x = x `elem` "aeiouyAEIOUY"
02:32:03 <lambdabot>   Parse error: ?
02:32:05 <shachaf> :-(
02:32:11 <shachaf> So much for dynamic scope.
02:32:41 <shachaf> ion: Your algorithm doesn't quite work for kmc...
02:32:43 <shachaf> Or does it?
02:32:55 <Yuu-chan> > hi "shachaf" -- :-P
02:32:57 <lambdabot>   hachaf
02:34:50 <Yuu-chan> @hoogle fox
02:34:51 <lambdabot> No results found
02:35:41 <shachaf> > hi "larious"
02:35:43 <lambdabot>   harious
02:36:13 <Yuu-chan> hi "atus"
02:36:19 <Yuu-chan> > hi "atus"
02:36:21 <lambdabot>   hatus
02:36:41 <mauke> > hi "ram"
02:36:43 <lambdabot>   ham
02:37:04 <Ke> @src hi
02:37:05 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:38:08 <mauke> @let scream' = unwords . sequence . words
02:38:09 <lambdabot>  Defined.
02:38:12 <Yuu-chan> Tired of high-kind type theory, Haskellians are playing with words
02:38:42 <mauke> > scream' "source not found"
02:38:44 <lambdabot>   "snf sno snu snn snd sof soo sou son sod stf sto stu stn std onf ono onu on...
02:39:10 <shachaf> @brain
02:39:10 <lambdabot> I think so, Brain, but culottes have a tendency to ride up so.
02:41:46 <Yuu-chan> "scream" must be "map toUpper"
02:41:58 <k0ral> hello
02:42:08 <Yuu-chan> > hi "k0ral"
02:42:10 <lambdabot>   h0ral
02:42:32 <k0ral> why isn't (Enum m) => m made instance of Eq ?
02:42:42 <shachaf> scrap toUpper
02:42:51 <shachaf> k0ral: Go ahead and try.
02:43:04 <k0ral> alright...
02:43:20 <mauke> k0ral: because not all instances of Eq are Enum
02:43:25 <Yuu-chan> @pl f g h x = f (g x) (h x)
02:43:25 <lambdabot> f = fix liftM2
02:43:37 <ion> map toUpper is evil.
02:43:58 <k0ral> mauke: err, I was meaning the other way around: every instance of Enum is Eq
02:44:08 <Yuu-chan> :t liftM2
02:44:09 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:44:14 <k0ral> mauke: using fromEnum
02:44:15 <mauke> k0ral: I know
02:44:22 <mauke> my answer still applies
02:44:43 <atriq> Is there an easy way to get Haskell syntax highlighting on Tumblr?
02:45:04 <mauke> .oO( post a screenshot? )
02:45:19 <k0ral> I still don't see why so I'm going to try
02:46:21 <osa1> can anyone help me setting my cabal package development environment? for now I'm running `cabal install` for every change I made and it takes too much time, what are better ways to build a package for fast testing
02:46:30 <Yuu-chan> @let scream'' = liftM2 (map toUpper) (++ "!!!")
02:46:31 <k0ral> I'm getting overlapping instances
02:46:31 <lambdabot>  <local>:5:19:
02:46:31 <lambdabot>      Couldn't match expected type `a2 -> r'
02:46:31 <lambdabot>             agains...
02:46:48 <sheldonh> would you describe this memoized, iterative fibonacci number function's complexity as O(n) in time and O(n) in space, and thus linear? https://github.com/sheldonh/learning-haskell/blob/master/fib/Fibonacci.hs  (note, fibonacci', not fibonacci)
02:48:21 <k0ral> alright, many types are Enum and define their own instance of Eq, so I can't come and say "here is my general definition of Eq for all Enum", is that right ?
02:49:21 <zhulikas> I think it's not memoized
02:49:30 <mauke> k0ral: no, the problem is the types that are not Enum
02:49:32 <mysticc> Is there a function which partitions a list into a list of lists of given length.. like myPartition 3 [1,2,3,4,5,6,7]=[[1,2,3],[4,5,6],[7]]
02:49:44 <mauke> mysticc: yes, in Data.List.Split
02:50:05 <Yuu-chan> @hoogle Int -> [a] -> [[a]]
02:50:06 <lambdabot> Prelude drop :: Int -> [a] -> [a]
02:50:06 <lambdabot> Data.List drop :: Int -> [a] -> [a]
02:50:06 <lambdabot> Prelude take :: Int -> [a] -> [a]
02:50:10 <mysticc> mauke: which package ?
02:50:19 <hiptobecubic> mysticc, "split"
02:50:35 <sheldonh> zhulikas: it carries forward the last 2 values in the series. i thought that qualified as memoization :)
02:51:55 <zhulikas> I think it would qualify if subsequent call to a function would return immediately
02:52:07 <sheldonh> i guess i should just put my big boy pants on and read up on big-o notation :)
02:52:13 <zhulikas> and not iterating everyting again
02:52:51 <sheldonh> zhulikas: ah right. so that makes it recursive instead of iterative. but i think the carrying forward of computed values is memoization, yes?
02:53:11 <sheldonh> zhulikas: hmmm, are you sure you're looking at the *second* function in that file, fibonacci'? :)
02:53:22 <zhulikas> yes, the iterative one
02:53:45 <zhulikas> but I hope somebody would step up on this as my thoughts may be wrong
02:55:18 <sheldonh> zhulikas: as a ruby programmer, i'd call the second function recursive, not iterative. but from what i've seen in SICP so far, this is called iteration because of the shape of the program (as per the trace in the comments)
02:57:52 <matthiasgorgens> sheldonh: iteration is exactly the subset of recursion that has this shape.
02:58:10 <matthiasgorgens> it's just that lots of languages have special purpose constructs that can only express this subset.
02:58:14 <matthiasgorgens> i.e. loops.
02:58:40 <matthiasgorgens> so their practitioners think it special if you use those constructs. :o)
02:59:49 <k0ral> mauke: still don't see how non-Enum types can be of any problem, and clearly the error message I'm getting only mention Enum types
03:00:15 <mysticc> mauke: I still can not find something that suits my need.. suppose I want to split x into 5 lists .. [1,2,3,4,5,6] .. So I want to have 5 lists (equal size if possible)
03:00:36 <mysticc> [[1,2],[3],[4],[5],[6]]
03:01:37 <sheldonh> matthiasgorgens: huzzah! so some of those lectures *is* sinking in! :)
03:04:07 <srhb> mysticc: Did you consider dividing the length by the number of parts you need and doing something with that?
03:04:42 <zhulikas> :}
03:05:01 <zhulikas> and then try that on [1..]
03:05:28 <srhb> Splitting an infinite list into n equal-sized pieces does not make a lot of sense..
03:08:32 <mauke> k0ral: you're defining an instance Eq m
03:08:48 <mauke> k0ral: m is a completely generic type variable. it overlaps with every other instance of Eq
03:12:42 <k0ral> mauke: no, m is instance of Enum
03:12:46 <timthelion> From a preformance standpoint, is it better to mix Chans and TChans when TChans are not needed in all cases?
03:12:47 <mauke> no, it isn't
03:12:48 <k0ral> mauke: I said (Enum m) => m
03:12:52 <mauke> irrelevant
03:12:57 <mauke> you said Eq m
03:13:15 <k0ral> scroll up
03:13:20 <mauke> irrelevant
03:13:20 <k0ral> read again
03:13:22 <mauke> irrelevant
03:13:39 <k0ral> then say why it's irrelevant instead
03:13:46 <mauke> you said Eq m
03:13:55 <mauke> you said some other things in addition, but that doesn't matter
03:14:03 <k0ral> instance (Enum m) => Eq m
03:14:06 <k0ral> that's what I said
03:14:07 <squidz> i was taking a looking at blaze html template and wondering how hard it would be to add ajax capability. Does anybody have any ideas?
03:14:11 <mauke> k0ral: that contains "Eq m"
03:14:12 <squidz> doesnt have to be specific
03:14:21 <mauke> k0ral: the other stuff doesn't matter
03:14:21 <k0ral> mauke: so ?
03:14:30 <k0ral> mauke: does it ?
03:14:40 <mauke> ?
03:15:46 <k0ral> then what's the difference between instance (Enum m) => Eq m and instance Eq m, given "the other stuff doesn't matter" ?
03:16:50 <mauke> k0ral: (Enum m) requires m to be an instance of Enum in addition
03:17:14 <k0ral> mauke: precisely
03:17:15 <mauke> so what you're saying is: "every type m is an instance of Eq! also, every type must be an instance of Enum"
03:18:00 <Z`> Is there a pattern matching for say 'match the 10 first elements of a list '?
03:19:06 <srhb> Z` (a:b:c:d:e:f:g:h:i:j:_)
03:19:07 <zhulikas> a guard with "take 10 list" ?
03:21:51 <k0ral> mauke: to me that meant "every type that is instance of Enum is also instance of Eq", and I used that pattern a lot of times, so if you're telling me I never understood well what it meant, then why is my application behaving exactly how I expect it to, or even compiling at all ?!
03:21:58 <FireFly> @hoogle (a -> a -> b) -> a -> b
03:21:59 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
03:21:59 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
03:22:00 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
03:22:13 <mauke> k0ral: I don't know. what is your application?
03:22:31 <k0ral> imm
03:22:45 <FireFly> Does  \f x -> f x x  have a common name?
03:22:51 <mauke> FireFly: join
03:23:17 <k0ral> hmm, I didn't use this pattern in imm
03:23:22 <FireFly> mauke: oh
03:23:23 <k0ral> I'm using it in hbro
03:23:53 <mauke> where?
03:26:35 <hiptobecubic> I've been advised that instance Foo a => Bar a is a disgusting abomination
03:27:06 <k0ral> mauke: not uploaded yet the local modifications, but I can easily paste you a sample
03:29:00 <k0ral> mauke: https://gist.github.com/3569045
03:29:20 <k0ral> mauke: that is a work in progress
03:29:28 <k0ral> mauke: I'm rewriting hbro completely
03:29:39 <mauke>  UndecidableInstances
03:29:43 <mauke> ಠ_ಠ
03:30:09 <k0ral> yes, and from what I understood, that's not a big deal
03:30:30 <hiptobecubic> k0ral, just use classes instead of instances do what you want
03:30:53 <k0ral> hiptobecubic: what ?!
03:31:23 <mauke> k0ral: it's compiling because you're using UndecidableInstances
03:31:34 <mauke> and also because you only have one instance in each case
03:31:48 <mauke> because any other instance would overlap
03:33:09 <k0ral> mauke: that's why I considered UndecidableInstances as "not a big deal"
03:33:27 <mauke> how does that follow?
03:33:40 <mauke> UndecidableInstances means you can make the type checker loop
03:33:42 <hiptobecubic> k0ral, you are declaring that everything that is Enum is also Eq, which is, if nothing else, probably just wrong.
03:34:10 <bitonic> UndecidableInstances makes the type system turing complete!
03:34:23 <bitonic> apart from that little recursion depth limit...
03:34:38 <k0ral> hiptobecubic: well, Enum is Int thanks to fromEnum, and Int is instance of Eq
03:35:06 <k0ral> bitonic: so anyway, if I happened to mess up with overlapping instances, I would be notified
03:35:22 <k0ral> that doesn't sound like a terrible thing
03:35:32 <bitonic> k0ral: I don't know what you're talking about.  I was just thinking about UndecidableInstances.
03:35:43 <mauke> you can think of classes like functions
03:36:14 <mauke> 'instance (Foo a) => Bar a' corresponds to 'Bar a = Foo a'
03:36:28 <mauke> every instance contributes an equation
03:36:45 <k0ral> but you know, if you provide me with another way to do the same without UndecidableInstances, I would be happy to rewrite everything (again)
03:36:48 <mauke> when the typechecker needs to resolve an instance, it checks all equations simultaneously
03:37:06 <mauke> when it finds a match, it recursively resolves the RHS
03:37:31 <mauke> the crucial point is that the right-hand side doesn't affect instance selection
03:38:17 <mauke> example: instance Eq Int; instance (Eq a) => Eq [a]
03:38:30 <mauke> I think of this as: Eq Int = (); Eq [a] = Eq a
03:39:08 <k0ral> that sounds odd to me, why would "instance (Foo a) => Bar a", which looks like an asymmetric relation, be interpreted like "Foo a = Boo a" which looks like a symmetric one ?!
03:39:19 <mauke> now when I say '[[[42]]] == []', the compiler needs to check 'Eq [[[Int]]]'
03:39:32 <mauke> [[[Int]]] doesn't match Int, but it matches [a]
03:39:47 <mauke> now we recurse to Eq a where a = [[Int]]
03:39:59 <mauke> now we recurse to Eq [Int]
03:40:01 <mauke> now we recurse to Eq Int
03:40:10 <mauke> and Int matches Int (but not [a])
03:40:17 <mauke> and there the whole thing terminates
03:41:11 <sheldonh> ahhhhh. so identity is just a way to say "no transform required" or "as is"
03:41:16 * k0ral is reading carefully
03:41:22 <mauke> k0ral: it's not symmetric if you read it as a function definition
03:41:25 <hiptobecubic> k0ral, so then `data A = B | C; data D = E | F | G`   means that `B == E`?  for all types like that?
03:41:35 <mauke> hiptobecubic: that's a type error
03:41:48 <mauke> hiptobecubic: (==) :: (Eq a) => a -> a -> Bool
03:41:50 <hiptobecubic> mauke, ah yes.
03:42:03 <hiptobecubic> but if you are first mapping them with fromEnum to Int?
03:42:21 <mauke> > fromEnum False == fromEnum ()
03:42:22 <lambdabot>   True
03:42:23 <k0ral> hiptobecubic: you would call == on the Enum, not on the Int
03:42:30 <mauke> hiptobecubic: we already have that
03:43:44 <mauke> k0ral: foo x = bar x; bar x = foo x  -- calling foo leads to an infinite loop
03:43:59 <hiptobecubic> I must have misunderstood something earlier
03:44:00 <mauke> at the type level, this corresponds to: instance (Bar x) => Foo x; instance (Foo x) => Bar x
03:44:17 <hiptobecubic> You made instance Enum a => Eq a where.... ?
03:44:48 <mauke> the normal instance rules rule out infinite loops because they require the types to get "smaller"
03:45:04 <k0ral> mauke: I've read your example and it makes sense to me, however I don't see what's the conclusion of it
03:45:28 <k0ral> mauke: the whole thing terminates, so ? everything is fine, isn't it ?
03:45:54 <mauke> yes, as long as you don't expect to be able to add a second instance
03:46:18 <mauke> and as long as you manually ensure that the typechecker won't go into a loop
03:46:47 <k0ral> it would stop upon looping on a fixed number of cycles, I would then be notified
03:47:03 <k0ral> so if I made something bad, I would be the first to know
03:47:08 <k0ral> wouldn't I ?
03:48:18 <k0ral> and anyway, what do you propose to avoid that undecidable instances thing ?
03:49:06 <mauke> http://hpaste.org/74014 - haha, this caused an internal compiler error in ghc
03:52:39 <mysticc> What is the difference between rem and mod ?
03:53:15 <mauke> > rem 5 (-2)
03:53:16 <lambdabot>   1
03:53:19 <mauke> > mod 5 (-2)
03:53:20 <lambdabot>   -1
03:53:32 <mauke> > mod 5 (-3)
03:53:33 <lambdabot>   -1
03:53:36 <mauke> > rem 5 (-3)
03:53:37 <lambdabot>   2
03:54:18 <mysticc> mauke: For positives they are same ?
03:54:18 <ivanm> @google modulus vs remainder
03:54:20 <lambdabot> http://blogs.msdn.com/b/ericlippert/archive/2011/12/05/what-s-the-difference-remainder-vs-modulus.aspx
03:54:23 <ivanm> mysticc: yes
03:54:28 <ivanm> though rem will be slightly faster
04:19:55 <shachaf> whoa, dude
04:20:01 <shachaf> Pragmas are case-insensitive?
04:20:08 <shachaf> {-# inlinable foo #-}
04:20:14 <shachaf> {-# language PatternGuards #-}
04:21:10 <atriq> {-# lAnGuAgE IncoherentInstances #-}
04:23:13 <Z`> given a list, how could I take its n'th element?
04:23:25 <atriq> (!!)
04:23:26 <srhb> > [1,2,3] !! 2
04:23:27 <lambdabot>   3
04:23:35 <Z`> ohh nice. thanks atriq
04:23:35 <srhb> If there are enough elements...
04:23:39 <srhb> > [1,2,3] !! 3
04:23:40 <lambdabot>   *Exception: Prelude.(!!): index too large
04:24:17 <shachaf> Z`: But if you're doing this more than very rarely it's often a sign that you should be writing your code differently.
04:24:29 <Z`> alright
04:24:43 <Z`> I am trying to partition a list into N long sublists
04:24:56 <Z`> I though I could use partition to do that
04:25:10 <Z`> but I think I hit a dead end
04:26:01 <srhb> @hoogle splitEvery
04:26:01 <lambdabot> No results found
04:26:07 <srhb> @index splitEvery
04:26:07 <lambdabot> bzzt
04:26:09 <srhb> Die!
04:26:22 <srhb> Z`: Check the split package.
04:26:41 <Z`> ok,thanks. although I'd like to do it on my own as well (just for practice)
04:27:31 <srhb> Z`: Have you tried writing a recursive solution?
04:27:37 <Z`> also emacs + haskell-mode does some funny things
04:28:09 <Z`> I'm trying srhb
04:28:48 <srhb> Z`: So you have something along the lines of.. splitEvery n xs = take n xs -- and then what?
04:29:11 <Z`> then I would like to repeat that but beginning at where I stopped
04:29:23 <k00mi> Z`: use splitAt
04:30:05 <srhb> Z`: You can use take and drop and a recursive call. Can you figure out how to do that? What is your base case?
04:30:38 <Yuu-chan> @hoogle Int -> [a] -> ([a], [a])
04:30:39 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
04:30:39 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
04:30:39 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
04:30:47 <Z`> e.g., I'd like splitEvery 3 [1..10] to become [[1,2,3],[4,5,6],[7,8,9],[10]]
04:31:03 <srhb> Z`: Yes, I got that.. So.. splitEvery n [] = ... what?
04:31:10 <Z`> alright, let me read on drop srhb
04:31:19 <Z`> ah
04:31:27 <Z`> = [] I suppose ?
04:31:30 <srhb> Right
04:31:41 <srhb> and splitEvery n xs = take ... what?
04:32:04 <Z`> I don't know
04:32:36 <k00mi> srhb: why use drop and take when splitAt does both for you?
04:32:39 <srhb> You want to take n from the list.. And then cons that onto the recursive partitioning of the rest of the list.
04:32:47 <srhb> k00mi: Because this is more illustrative.
04:33:07 <k00mi> ok
04:33:20 <Z`> I could use ++ I suppose ?
04:33:28 <Z`> (take n xs) ++ a recursive call here
04:33:36 <srhb> Z` Nah, you want each element to be the sublist.. so take n xs : recursive...
04:33:48 <srhb> Z`: Otherwise you're just reconstructing your original list
04:33:59 <Z`> oh, right
04:34:03 <srhb> Z`: Now you need to figure out what the rest of the list is.
04:34:14 <sheldonh> i haven't been enjoying recursive ++, performance-wise
04:34:20 <Z`> the rest of the list is the original minus what I've already taken
04:34:35 <srhb> Z`: Yes, now to find an expression to do that (use drop)
04:34:35 <Z`> so, drop n xs ?
04:34:38 <srhb> Right
04:34:43 <srhb> And put it together, and you're done.
04:34:50 <Z`> ;et me try it to ghci
04:34:53 <Z`> (thanks)
04:34:57 <nooodl> well, it's not just (take n xs) : (drop n xs)
04:35:09 <nooodl> don't forget about the recursion!
04:35:26 <Z`> the dropn n xs should be the argument to the recusive call. right ?
04:35:30 <srhb> Right.
04:35:33 <nooodl> yep
04:35:38 <srhb> It is, after all, the rest of the list.
04:35:40 <Z`> plus the base case
04:35:48 <Z`> so I need a where clause
04:35:51 <srhb> No.
04:35:55 <Z`> ah no, pattern matching
04:35:58 <nooodl> you don't want to change the size, so "splitEvery n (drop n xs)"
04:36:05 <srhb> let splitAt n [] = []; splitAt n xs = ...
04:36:13 <ion> > let foo n (splitAt n -> (as,bs)) | null bs = [as] | otherwise = as : foo n bs in foo 5 [0..11]
04:36:14 <lambdabot>   [[0,1,2,3,4],[5,6,7,8,9],[10,11]]
04:36:43 <srhb> This echo in here is getting worse and worse... Think we really need to put some insulation on the walls.
04:36:43 <srhb> :-)
04:36:57 <shachaf> ion: | null? :-(
04:37:00 <zhulikas> > let splitEvery n l = let s [] = []; s l' = take n l' : s (drop n l') in s l in splitEvery 3 [1,2,3,4,5,6,7,8,9,0]
04:37:01 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[0]]
04:37:13 <Z`> alright!!!! it worked <333333
04:37:24 <srhb> Z`: Now you could try rewriting it using splitAt :)
04:37:29 <shachaf> > let { foo n (splitAt n -> (as,[])) = [as]; foo n (splitAt n -> (as,bs)) = as : foo n bs } in foo 5 [0..11]
04:37:30 <lambdabot>   [[0,1,2,3,4],[5,6,7,8,9],[10,11]]
04:37:43 <Z`> In retrospect it was so easy, but If srhb didn't lead me I wouldn't have figured it out :|
04:37:43 <ion> shachaf: Repetition of splitAt :-(
04:37:45 <nooodl> (can't you write this using a fold, too?)
04:37:49 <shachaf> Wait, that's not even right, is it?
04:37:50 <zhulikas> > let splitEvery n l = let s [] = []; s l' = take n l' : s (drop n l') in s l in (take 5 $ splitEvery 3 [1..])
04:37:51 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]]
04:37:53 <shachaf> > let { foo n (splitAt n -> (as,[])) = [as]; foo n (splitAt n -> (as,bs)) = as : foo n bs } in foo 5 [0..9]
04:37:54 <lambdabot>   [[0,1,2,3,4],[5,6,7,8,9]]
04:38:00 <shachaf> Oh, right.
04:38:09 <srhb> shachaf: Is that a view pattern? Looks funky.
04:38:20 <shachaf> ghc -funky
04:38:35 <srhb> :-)
04:38:43 <shachaf> -funky-math
04:39:04 <shachaf> ...More commonly known as IEEE 754
04:39:24 <ion> > let foo n xs = as : case bs of { [] -> []; _ -> foo n bs } where { (as,bs) = splitAt n xs } in foo 5 [0..11]
04:39:25 <lambdabot>   [[0,1,2,3,4],[5,6,7,8,9],[10,11]]
04:39:27 <hiptobecubic> hmatrix doesn't do loop fusion?
04:40:17 <ion> > let foo _ [] = []; foo n xs = as : foo n bs where { (as,bs) = splitAt n xs } in foo 5 [0..11]
04:40:17 <lambdabot>   [[0,1,2,3,4],[5,6,7,8,9],[10,11]]
04:44:11 <Z`> ok I wrote this:
04:44:18 <Z`> mysplit n [] = []
04:44:30 <Z`> mysplit n xs =  (fst (splitAt n xs)) : (mysplit n (snd (splitAt n xs)))
04:45:06 <Z`> my question is whether haskell would calculate twice the expression splitAt n xs
04:45:34 <Z`> should I worry about such stuff ?
04:46:08 <hiptobecubic> I know there is some quirk about floating out those expressions, if you're worried you can do it manually
04:46:32 <hiptobecubic> let splt = splitAt n xs in (fst splt) : ...
04:46:53 <Z`> a ha.
04:47:00 <Z`> thanks hiptobecubic
04:47:09 <shachaf> No, don't use fst and snd. :-(
04:47:16 <Z`> why ? :\
04:47:23 <shachaf> let (before, after) = splitAt n xs in before : ...
04:47:28 <hiptobecubic> better to pattern match
04:47:37 <shachaf> Pattern-matching is way better than functions when you can use it.
04:47:52 <Z`> when you write (before, after) = splitAt n xs
04:48:00 <Z`> the 'fst' goes to before and the 'snd' to after ?
04:48:24 <Z`> I mean the first item of the tuple to before, and the second to after
04:48:33 <hiptobecubic> Z`, yes.
04:48:36 <shachaf> Yes.
04:48:37 <ion> fst (before, after) = before
04:48:41 <ion> snd (before, after) = after
04:48:53 <Z`> ok and then I can use 'after' and 'before' in the right part of th equation ?
04:49:00 <shachaf> Equation?
04:49:02 <tdammers> fst is useful for when you need to pass it into some other function though
04:49:05 <shachaf> let ... in ...
04:49:14 <shachaf> You can use it in the "in" part of the let-in.
04:49:37 <shachaf> You can also use it in on the right side of the =, but that would just be recursion.
04:49:54 <Z`> I'm not familiar with let..in.. let me read it :P
04:50:02 <shachaf> Z`: How about case-of?
04:50:39 <Z`> I've read about them, but I can't remember them. just a sec
04:50:46 <sheldonh> ha! easy way to figure out why haskell doesn't have a for loop... write one :)
04:51:18 <shachaf> ?
04:51:21 <Z`> ok, case of is like swith-case in C
04:51:42 <shachaf> Z`: Sort of. Except much nicer.
04:52:09 <shachaf> Anyway, I was saying that you can also write case splitAt n xs of (before, after) -> before : ...
04:52:15 <tdammers> sheldon: for lower upper f = mapM_ f [lower..upper]
04:52:31 <hpaste> carpi pasted “timing inconsistency” at http://hpaste.org/74016
04:52:32 <carpi> could somone please tell me whats happening? ^^^^ this entire body of code takes only 512KB of memory in ghci while a simple "3+4" in ghci takes 1.1mb memory?
04:52:33 <tdammers> but you have to specify which kind of for you want, really
04:53:11 <Z`> shachaf: it worked!
04:53:53 <Z`> mySplit n xs = case splitAt n xs of (before, after) -> before : (mySplit n after)
04:54:03 <shachaf> for (init, step, check) body = do { init; fix $ \loop -> do { b <- check; when b (body >> step >> loop) } }
04:56:59 <ion> do r <- newIORef undefined; for (writeIORef r 0, modifyIORef r (+1), (<10) <$> readIORef r) (readIORef r >>= print)
04:57:33 <shachaf> ion: Add a sugar to taste.
04:58:47 <shachaf> ion: Alternatively, you can give the result of init to the other functions.
04:59:43 <JuanDaugherty> so Haskell is really ugly huh? It's one of those beauty in ugliness things?
04:59:44 <ion> That wouldn’t be like the C for loop anymore.
04:59:50 <shachaf> It would be like a C99 loop!
05:00:11 <shachaf> for' (init, step, check) body = do { v <- init; fix $ \loop -> do { b <- check v; when b (body v >> step v >> loop) } }
05:00:17 <shachaf> for' (newIORef 0, (`modifyIORef` (+1)), fmap (<10) . readIORef) (readIORef >=> print)
05:00:53 <shachaf> Looks just like see, doesn't it?
05:01:00 <shachaf> Urgh.
05:01:02 <sheldonh> shachaf: i've been advised to avoid monads as long as possible while learning :)
05:01:03 <shachaf> Like C.
05:01:04 <shachaf> :-(
05:01:11 * shachaf = terrible
05:01:16 <sheldonh> shachaf: so i had for a b f | a > b = [] | otherwise = (f a) : (for (a + 1) b f)
05:01:25 <ion> juandaugherty: Yes, Haskell is really ugly. Even lambdabot agrees.
05:01:30 <ion> @faq Can Haskell be really ugly?
05:01:30 <lambdabot> The answer is: Yes! Haskell can do that.
05:01:49 <shachaf> @src until
05:01:49 <lambdabot> until p f x | p x       = x
05:01:50 <lambdabot>             | otherwise = until p f (f x)
05:01:52 <sheldonh> shachaf: but i realize that this isn't a for loop at all. seeing yours, i should have supported a check and an incremement
05:02:01 <shachaf> sheldonh: No, you shouldn't.
05:02:11 <shachaf> Porting C idioms to Haskell will go badly.
05:02:16 <sheldonh> shachaf: i shouldn't avoid monads as long as possible?
05:02:27 <shachaf> sheldonh: For your entire life, if you can help it.
05:02:28 <sheldonh> shachaf: oh. right. of course not. i'm not implementing it to *use* for anything :)
05:02:39 <ion> sheldonh: You don’t need to understand the concept of monad at the beginning, but you certainly shouldn’t avoid using monads.
05:02:51 <shachaf> ion: It's very difficult to avoid using things that are monads.
05:03:05 <Z`> what is monad ? in greek it means "one", "only", "unique"
05:03:11 <shachaf> Well, maybe you can manage it if you don't import Control.Monad.Instances.
05:03:16 <shachaf> Z`: See the FAQ.
05:03:17 <shachaf> @where faq
05:03:17 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
05:03:24 <zhulikas> @src unless
05:03:24 <lambdabot> unless p s = if p then return () else s
05:03:25 <Z`> thanks
05:03:36 <zhulikas> @src when
05:03:36 <lambdabot> when p s = if p then s else return ()
05:03:41 <OODavo> Is there a way to make non-exhaustive patterns a compile-time error rather than leaving it to be discovered at run-time?
05:03:42 <shachaf> It's the name of a high-level API that applies to many different data types.
05:03:44 <zhulikas> I always mix them up :/
05:03:57 <mikeplus64> OODavo: ghc-mod will yell at you for them
05:04:04 <shachaf> OODavo: Compile with -Wall
05:04:09 <shachaf> (You should do that anyway.)
05:04:10 <zhulikas> nice
05:04:50 <sheldonh> shachaf: it's been instructive to try to implement a functional for, because it exposes a general recursive structure
05:05:38 <Z`> "In short, Haskell programs are pure-functional programs which compute imperative programs." heh
05:06:23 <shachaf> That has to do with IO, not with monads.
05:07:11 <OODavo> mikeplus64: Ah, I'd expected that it would but wasn't getting the warning when Syntastic runs it. Turns out ghc-mod check isn't actually working for me. Some sort of library problem. Thanks for the pointer.
05:07:39 <vu3rdd> I am starting with Haskell and going through learnyouahaskell book.
05:07:55 <vu3rdd> I see this type declaration for take':
05:07:56 <vu3rdd> take' :: (Num i, Ord i) => i -> [a] -> [a]
05:07:56 <srhb> vu3rdd: Welcome :)
05:08:11 <vu3rdd> srhb: thanks. :)
05:08:19 <vu3rdd> Why is Ord being used here?
05:08:34 <vu3rdd> The code I am refering to is here: http://learnyouahaskell.com/recursion
05:08:49 <vu3rdd> There is an explanation there but I didn't get it.
05:09:03 <vu3rdd> similarly -- replicate' :: (Num i, Ord i) => i -> a -> [a]
05:09:05 <Botje> vu3rdd: you need to be able to compare that number to zero
05:09:08 <srhb> vu3rdd: Ordering is required for the <= operator
05:09:09 <ion> It’s using one of the Ord functions against the “i”.
05:10:08 <vu3rdd> oh.. ok. Thanks. I get it.
05:10:25 <srhb> vu3rdd: Try typing :i Ord into ghci and see what it gives you at the very top of the blob
05:11:44 <vu3rdd> srhb: thanks. :)
05:12:52 <srhb> vu3rdd: You can do that for any type or type class and get interesting information :)
05:12:57 <shachaf> srhb: That only happens to work because <= is an instance of Ord.
05:13:04 <shachaf> In general it doesn't.
05:13:19 <shachaf> (Looking at the type of (<=) would, though. If you realize that that's an operator.)
05:13:26 <carpi> why does '3+4' in ghci consume 1.6 MB?
05:13:28 <srhb> Sorry, what?
05:13:57 <sheldonh> my function expects a function argument that returns a Bool (a -> Bool).  is there any shorthang for such an argument, more succinct than \x -> True
05:14:39 <adnam> const True
05:15:36 <srhb> shachaf: What did you mean "in general, it doesn't"
05:15:42 <srhb> shachaf: :i doesn't work in general?
05:15:53 <sheldonh> adnam: wicked, thanks
05:16:12 <OODavo> mikeplus64: ghc-mod -g -Wall test.hs isn't producing any warnings; that file contains f (Just x) = x, so there /should/ be a non-exhaustive pattern warning. :/
05:16:40 <adnam> @pl \x -> True -- sheldonh sometimes @pl is useful :)
05:16:40 <lambdabot> const True
05:17:03 <shachaf> srhb: If we had class Ord a where { compare :: a -> a -> Ordering }; (<=) :: a -> a -> Bool; x <= y = case compare x y of GT -> False; _ -> True, :i wouldn't tell you about <=
05:17:14 <sheldonh> adnam: my ghci doesn't seem to have @pl
05:17:20 <sheldonh> *facepalm*
05:17:35 <adnam> lambdabot query always open is a must
05:17:44 <shachaf> > map length ["\\_ ->", "const"]
05:17:45 <lambdabot>   [5,5]
05:17:52 <shachaf> > map length ["\\_ ->", "const", "\\_->", "pure"]
05:17:53 <lambdabot>   [5,5,4,4]
05:17:56 <sheldonh> the world would be a better place if you could delete what you've said in public
05:18:29 <nand`> > length "\\_->True"
05:18:30 <lambdabot>   8
05:18:32 <nand`> > length "pure True"
05:18:33 <lambdabot>   9
05:20:26 <ion> because golfing is the most important part of real-life programming.
05:20:26 <sheldonh> so here's the mighty for loop (as long as you want your results as a list) http://fpaste.org/qpiM/
05:22:48 <sheldonh> and then [0..9] == for 0 succ (< 10) id
05:22:54 <ion> (map fn . takeWhile while . iterate step) i
05:24:31 * shachaf whiles his whiles away.
05:24:38 <sheldonh> yeah, any for loop that returns a list is going to look a lot like a map. and that was the aha moment. we don't need for loops because we've got functions that much more clearly capture the intent of iteration
05:25:01 <JuanDaugherty> Just watch yo mouf in publicly logged channels
05:25:45 <sheldonh> so if you *try* to implement a for loop, you realize that you're just reimplementing an existing function, or that you've uncovered a whole new iterative metaphor that nobody else has ever thought of
05:26:02 <sheldonh> which, at this stage in the game, is unlikely :)
05:27:28 <shachaf> That for isn't very useful because it can only make decisions about when to stop based on i.
05:28:18 <sheldonh> schlumpi: yes. i thought of passing in (fn i) too, but the caller has access to fn, so she can compose it into step herself, if she likes
05:28:25 <shachaf> Lazy evaluation has this nice coroutine-style decoupling effect.
05:28:28 <sheldonh> shachaf, even. sorry
05:28:43 <shachaf> sheldonh: Eventually you realize that lists *are* loops.
05:28:48 <shachaf> Just as much as they're data structures.
05:29:24 <shachaf> And that's the nicest part of lazy evaluation. But you can't just show it to someone who doesn't know Haskell with a small example. :-(
05:30:32 <sheldonh> shachaf: looking forward to that. early in SICP, the lecturer says "and eventually you'll see the line between data and functions blurring"
05:32:11 <edwardk> woot. i managed to get (almost all of) the polykinded indexed monad stuff to work
05:32:18 <nand`> who needs data structures? true = \x _ -> x; false = \_ y -> y; zero = \_ x -> x; one = \f x -> f x; two = \f x -> f (f x) ...
05:33:56 <edwardk> remarkably the indexed free monads wind up almost as readable as the normal free monads. https://github.com/ekmett/indexed/blob/master/src/Indexed/Monad/Free.hs
05:33:58 <ocharles> edwardk: is this a haskell project?
05:34:01 <ocharles> oh, heh
05:34:12 <edwardk> yeah
05:34:22 <ocharles> how does this compare to index-core or whatever the other current indexed package is?
05:34:26 <shachaf> Polykinded Indexed Monads is the name of edwardk's new band.
05:34:38 <edwardk> its polykinded. and it goes a lot deeper in scope
05:34:41 <Yuu-chan> @pl \f x -> f (f x)
05:34:42 <lambdabot> join (.)
05:34:42 <ocharles> shachaf: comonads, surely
05:34:52 <edwardk> https://github.com/ekmett/indexed/blob/master/src/Indexed/Functor.hs#L95
05:34:52 <ocharles> edwardk: ah cool
05:35:10 <edwardk> indexed applicatives, foldables, traversables, etc.
05:35:14 <Yuu-chan> @pl \f x -> f (f (f x))
05:35:14 <lambdabot> ap (.) (join (.))
05:35:15 <sheldonh> shachaf: you said it wasn't very useful to continue as a function of i. i assumed you meant (fn i) would be useful. did you mean something else that i didn't get?
05:35:27 <edwardk> indexed comonads and i'm adding indexed (co)monad transformers
05:35:47 <edwardk> its also very very dependent on 7.6
05:35:49 <ocharles> edwardk: all this indexed stuff looks really promising, i can't wait til i get round to having a play with it
05:35:56 <shachaf> sheldonh: What I really mean is that there are dozens of different loop constructions depending on what you want to be doing.
05:36:00 <edwardk> (so much so that it needs ghc head, not the release candidate)
05:36:08 <ocharles> i've only read the outrageous arrows paper, and that alone seems worth having
05:36:41 <edwardk> https://github.com/ekmett/indexed/blob/master/src/Indexed/Thrist.hs is the Path example from the kleisli arrows of outrageous fortune paper
05:36:44 <shachaf> edwardk: Oh, that crash was with HEAD?
05:36:55 <edwardk> i've had various crashes with head as we
05:36:57 <edwardk> er well
05:38:06 <shachaf> Is (~>) a type variable?
05:38:12 <shachaf> Or has that change been made?
05:38:30 <edwardk> that change is in 7.6
05:38:36 <edwardk> ~> is a type alias
05:38:48 <shachaf> Ah, f ~> g = forall a. f a -> g a
05:38:49 <edwardk> https://github.com/ekmett/indexed/blob/master/src/Indexed/Types.hs#L37
05:38:52 <edwardk> yep
05:39:04 <shachaf> Naturally.
05:39:17 <edwardk> lets me write stuff like data a == b where Refl :: a == a
05:39:21 <edwardk> i like that one
05:39:32 <shachaf> Oh, there's no conflict?
05:39:43 <edwardk> thats the type level
05:40:00 <shachaf> Right.
05:40:06 <edwardk> infixr 0 $; type ($) a = a -- is also nice
05:40:17 <shachaf> Where's the Agda programmer in you?
05:40:21 <edwardk> hahaha
05:40:27 <edwardk> i killed him
05:40:27 <shachaf> data a ≡ b where Refl :: a ≡ a
05:40:53 <shachaf> Your punishment is that Refl only works at the type level.
05:41:02 <nand`> type ≅ = Isomorphism
05:41:22 <edwardk> i've been planning on using <-> for that actually
05:41:25 <ion> “==” or “:==”?
05:41:29 <edwardk> ==
05:41:35 <edwardk> 7.6 kills the need for :
05:41:43 <ion> Oh, cool.
05:42:06 <edwardk> since this barely compiles with 7.6 i feel no compunction about using 7.6 specific syntax ;)
05:42:44 <ocharles> :)
05:42:49 <sambio> haskell-ar
05:43:00 <edwardk> i can't figure out a nice way to do (!=>) though
05:43:20 <edwardk> it should be the comonadic analogue to (!>=), https://github.com/ekmett/indexed/blob/master/src/Indexed/Functor.hs#L108
05:43:23 <randomclown> how lone before (8=>) function is created
05:43:26 <randomclown> long*
05:44:46 <Athas> Functions are not created, but discovered!
05:50:27 <edwardk> it is rather shockingly difficult to debug kind errors though
05:50:53 <ocharles> does anyone know if something like Traversable t => t (Maybe a) -> t a is a lens?
05:51:24 <edwardk> orcharles: you mean like 'traverse.traverse'?
05:51:25 <ocharles> I want something that can take a list of maybes, and replace every Just a with a Just b, essentially
05:51:40 <ocharles> retaining the rest of the structure
05:51:43 <edwardk> 'traverse.'traverse' is a valid Traversal
05:51:47 <ocharles> cool
05:52:03 <ocharles> :t Data.Traversable.traverse . Data.Traversable.traverse
05:52:04 <lambdabot> forall (f :: * -> *) (t :: * -> *) a b (t1 :: * -> *). (Data.Traversable.Traversable t, Applicative f, Data.Traversable.Traversable t1) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
05:52:10 <edwardk> of course, you can also use mapped.mapped if you just want to update it
05:52:22 <edwardk> mapped.mapped %= foo
05:52:31 <edwardk> or over (mapped.mapped) foo
05:53:12 <edwardk> https://github.com/ekmett/lens/wiki/Derivation
05:53:21 <ocharles> thanks, I will give that a read
05:53:39 <ocharles> I get how to use your lens package to do some really basic stuff, but writing my onw lenses is my next hurdle
05:54:10 <edwardk> i really need to do more documenting
05:54:30 <hpc> is there a better way to do this than with ST?
05:54:47 <hpc> wait, wrong channel, probably
05:55:27 <shachaf> Dozens of other packages go undocumented as edwardk pours soul into Control.Lens, burns out.
05:55:48 <edwardk> hey i took a break and documented hyphenation ;)
05:55:55 <shachaf> I imagine Trifecta would benefit a lot more from documentation efforts. :-)
05:55:57 <hpaste> “free redbox” pasted “http://www.youtube.com/watch?v=ZTqMU3K9pIk  Redbox Promo codes 2012” at http://hpaste.org/74017
05:56:29 <shachaf> hpaste spam? :-(
05:56:36 <edwardk> yeah
05:56:40 <edwardk> i flagged it
05:59:51 <nand`> I'd like a lenses-like post about all of the different parsers, what sets them apart and what their individual strengths and weaknesses are
05:59:59 <nand`> there's probably something like this already
06:00:03 <nand`> if you know of any, I'd appreciate a link
06:00:16 <edwardk> ah, no, mostly my ramblings on here ;)
06:01:11 <shachaf> There's a nice set of slides about something called "trifecta" which doesn't have a whole lot to do with Trifecta.
06:01:28 <ocharles> are there any examples of basic trifecta parsers?
06:01:29 <edwardk> i admit i kind of regret reusing the name
06:01:58 <edwardk> ocharles: https://github.com/DylanLukes/Winchester-STG-Compiler/blob/master/WSC/Parser.hs#L94
06:01:59 <hpaste> hiptobecubic pasted “Why doesn't combi undergo fusion?” at http://hpaste.org/74018
06:02:55 <hiptobecubic> Am I missing something obvious there? "manual" and "combi" should be the same thing right?
06:03:13 <ocharles> nice, so not too far away from normal applicative parsers
06:03:53 <hpc> hiptobecubic: you aren't inlining manual or combi
06:04:08 <hpc> so when it goes to apply fusion rules, it sees (manual . combi)
06:04:14 <hpc> instead of (map foo . map bar . ...)
06:04:38 <hiptobecubic> hpc, why does it compose them?
06:04:41 <hpc> in any event, they won't fuse if you use seq like that :P
06:04:51 <hiptobecubic> i don't want manual and combi to fuse
06:05:04 <hiptobecubic> i want the U.maps to fuse
06:05:11 <hiptobecubic> manual does, combi does not
06:05:11 <hpc> oh
06:05:15 <hiptobecubic> according to dump-simpl
06:05:55 <k0ral> hey, GHC tells me it doesn't find an instance for Default MyType while I did create it
06:06:06 <k0ral> is there any way GHC could miss it ?!
06:06:19 <hpc> k0ral: hpaste?
06:06:29 <hpc> GHC doesn't just "miss" instances
06:06:39 <hpc> hiptobecubic: yeah, no idea then
06:06:47 <hiptobecubic>  hpc i'm boggled
06:06:57 <hpc> oh!
06:07:03 <hpc> are you compiling with -O2?
06:07:14 <hpc> could be that it does the fusion rules, but not the inlining rules
06:07:23 --- mode: wolfe.freenode.net set +o ChanServ
06:08:44 <hiptobecubic> False alarm everyone. I'm retarded.
06:09:03 <hiptobecubic> "Main.combi = Main.manual"
06:10:31 <hpc> hiptobecubic: that doesn't solve the problem of (.+), (.*) behaving as expected though
06:10:50 <hpc> so you're still stuck with writing out the maps yourself, if that matters
06:11:16 <hiptobecubic> hpc, it does solve the problem. The compiler wrote that line, not me.
06:11:43 <hiptobecubic> It just recognized that they were exactly the same function and only made the body once, i guess.
06:11:49 <hpc> oh
06:11:49 <hpc> lol
06:12:15 <hiptobecubic> :)
06:14:31 <sheldonh> ghci is so open-minded: [ x * 2 | x <- [1..], x <= 10 ]      :)
06:15:38 <ivanm> hmmm... if you use Integer, would that list comprehension end?
06:15:44 <ivanm> since it's doing a filter, not a takeWhile
06:16:01 <ivanm> and I didn't think they were that smart that they can determine a strictly increasing list...
06:16:02 <sheldonh> ivanm: i haven't seen it end yet. perhaps i should have waited for it to wrap :)
06:16:27 <ivanm> sheldonh: if it uses Integer (which it will default to), it won't wrap!
06:16:33 <nand`> Int won't wrap either
06:16:42 <ivanm> nand`: no, but it will stop at maxBound
06:16:46 <nand`> yes
06:16:47 <ivanm> with Integer it will never end
06:16:54 <ivanm> > map (*2) . takeWhile (<=10) $ [1..]
06:16:56 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
06:16:56 <sheldonh> ivanm: and so ghci slaves away infinitely, just in case there's a number out there, following 10, that's less than or equal to 10 :)
06:17:03 <ivanm> sheldonh: yup
06:17:26 <sheldonh> very faithful :)
06:26:40 <mun> hi
06:26:55 <mun> if i have a function of type A -> B * C, what does the curried form look like?
06:27:06 <nand`> A -> B * C
06:27:31 <mun> so it's already in curried form?
06:27:31 <shachaf> mun: Currying is transforming A * B -> C into A -> (B -> C)
06:27:39 <shachaf> No.
06:27:49 <shachaf> It's not in "curried" or "uncurried" form. It's just a function.
06:28:00 <shachaf> You might be thinking of something like A -> (B -> C -> r) -> r
06:28:20 <shachaf> (But you're probably not, really.)
06:28:31 <hpaste> ocharles pasted “How to unify resolve and resolve'?” at http://hpaste.org/74019
06:29:01 <ocharles> hey, I'm working a way of composing fairly general database operations with arrows to simplify 'expanding' database access loading stuffs
06:29:14 <mun> right
06:29:15 <shachaf> Too many arrows. :-(
06:29:19 <shachaf> Why are you using Kleisli IO?
06:29:24 <ocharles> I'm pretty happy with where I am atm, but is there a way to combine resolve and resolve' into a single function?
06:29:50 <ocharles> resolve' is only needed as you can see to wrap a value in Identity, so it's in a Functor
06:30:09 <shachaf> I'm not sure what your goal here is.
06:30:23 <shachaf> Is there any instance of Arrow involved other than Kleisli IO and (->)?
06:30:34 <ocharles> no
06:30:42 <ocharles> at least not yet
06:31:16 <shachaf> So why are you doing it that way?
06:31:28 <ocharles> ideally, I want to be able to write resolve (entityData >>> releaseCountry) getCountries, but also resolve (entityData >>> releaseReleaseGroup) getReleaseGroups
06:31:36 <rros> 11%29
06:31:48 <ocharles> but that can't be done because releaseReleaseGroup is a Ref ReleaseGroup, which is not a Functor f => f (Ref a)
06:32:03 <ocharles> shachaf: because I need things like &&&
06:33:17 <shachaf> Are you sure?
06:33:41 <ocharles> the longer term plan is to be able to describe a graph of database queries and dependencies, and have it all wire together for minimal queries. For example, complexRelease should actually load a Release, all Tracks and the release Artist and all track Artists, which should reduce to findRelease, getTracks, getArtists (1 call of each)
06:33:50 <ocharles> but have type (Release, Artist, [(Track, Artist)])
06:34:08 <ocharles> shachaf: i'm happy using arrows for now, that's not really posing a problem right now
06:35:12 <ocharles> sadly I don't think I'm going to be able to figure this out on IRC, it really needs the sketches that I have in front of me to explain it all, so I might rework this for a cafe question :)
06:42:26 <Z`> Why a function reading a character and returning a boolear
06:42:32 <Z`> doesn't have a type of
06:42:38 <Z`> myf :: IO -> Bool
06:42:40 <Z`> and instead has type
06:42:43 <Z`> myf :: IO Bool
06:42:46 <Z`> ?
06:43:23 <hpc> the type (IO -> Bool) says "given a thing of type IO, i can produce a Bool"
06:43:23 <shachaf> Because IO -> Bool doesn't make any sense.
06:43:31 <shachaf> You should read about how IO works in Haskell.
06:43:46 <Z`> I'm reading http://www.haskell.org/tutorial/io.html
06:43:48 <shachaf> @google introduction to io in haskell
06:43:48 <hpc> the type (IO Bool) says "i am a computation that returns a Bool, sensitive to the current state of the world"
06:43:49 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
06:43:49 <lambdabot> Title: Introduction to IO - HaskellWiki
06:43:52 <Z`> and I had that question
06:43:56 <shachaf> Z`: Try that one.
06:44:00 <shachaf> Also see the FAQ:
06:44:01 <shachaf> @where faq
06:44:02 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
06:45:18 <edwardk> preflex: seen roconnor
06:45:18 <preflex>  roconnor was last seen on #haskell-blah 8 hours, 44 minutes and 59 seconds ago, saying: in a chosen plaintext attack secenario
06:45:34 <edwardk> @tell roconnor i think we may be using the wrong definition for 'seek and seeks'
06:45:34 <lambdabot> Consider it noted.
06:45:36 <shachaf> Uh-oh.
06:45:45 <shachaf> Sounds like roconnor didn't make it out of that scenario.
06:45:51 <edwardk> hahaha
06:45:55 <Z`> ah so (IO Bool) is an action, not a function
06:46:21 <shachaf> Z`: Yes. "IO foo" is always an action that you can execute to get a foo.
06:46:51 <Z`> That's why it doesn't follow the notation of functions, where you write a -> b
06:47:02 <shachaf> Yes. It has nothing to do with functions. :-)
06:47:14 <Z`> so sneaky. thanks!
06:47:51 <hpc> Z`: congrats on learning pretty much a solid month of haskell in less than an hour :D
06:48:09 <Z`> LOL
06:50:28 <ocharles> Would a function [[[a]]] -> a form a lens? That is, with this (currently nonexistent) lens I could turn [[[a]]] -> [[[b]]], right?
06:50:40 <ocharles> and a -> a is also a lens (just the identity lens)
06:52:01 <edwardk> going to be a little pedantic. strictly speaking there is no SImple Lens [[[a]]] a because there are no lenses into [a] other than the identity lens. now there are traversals that can go three levels deep like that
06:52:09 <edwardk> but they aren't strictly speaking lenses
06:52:58 <edwardk> you can use 'traverse.traverse.traverse' to walk in 3 levels deep
06:53:33 <ocharles> ok, but is a -> a also a traversal?
06:54:07 <milk_`> hi, anyone knows some good material about using parsec?:)
06:54:23 <edwardk> a -> a is a legal traversal. because you can instantiate id :: a -> a   as forall f. Applicative f => (a -> f a) -> a -> f a
06:54:36 <hpc> milk_`: the documentation on hackage is excellent
06:55:21 <typoclass> milk_`: rwh has a chapter about using parsec to build a csv parser, that's pretty good
06:55:24 <merijn> Suppose I have a mutating graph (of chan's and forkIO threads), what would be the best way to keep a representation of the graph state that I can access globally (FSOV global)?
06:55:26 <typoclass> hpc: do you have a link?
06:55:40 <hpc> @hackage parsec
06:55:40 <lambdabot> http://hackage.haskell.org/package/parsec
06:56:12 <milk_`> i've some trouble using lexeme
06:56:15 <merijn> milk_`: RWH also has a chapter on parsec (it's a bit out of date, there's been a new parsec version, but the overall ideas still apply and the details you can lookup in the docs)
06:56:30 <milk_`>  mainParser  = do{ whiteSpace
06:56:31 <milk_`>                      ; ds <- many (lexeme digit)
06:56:31 <milk_`>                      ; eof
06:56:31 <milk_`>                      ; return (sum ds)
06:56:31 <milk_`>                      }
06:56:46 <milk_`> can't use lexeme like this...
06:57:36 <ocharles> edwardk: an aside, but for some advice on documentation -- I'd find lens easier to understand if the examples were even simpler, and each function had an example of how you'd use it. for example, the example in Control.Lens.Getter.^. assumes the reader is familiar with complex numbers and the 'to magnitude' function
06:57:52 <Botje> milk_`: don't paste in the channel.
06:57:54 <ocharles> so to see where that 2.23... comes from, they have to actually think a bit outside just lenses
06:58:11 <typoclass> milk_`: please use hpaste for code. people can help you better if you include the error message you're getting
06:58:15 <typoclass> @where hpaste
06:58:15 <lambdabot> http://hpaste.org/
06:58:24 <edwardk> ocharles: i'd be happy to add more examples, especialy if they came in the form of a patch ;)
06:58:30 <milk_`> Botje: ok, thanks a lot:)
06:58:36 <edwardk> in all seriousness, i do agree, that more examples would be better
06:58:41 <ocharles> If that was just ((0, "Ponies!"), Just True)^._1^._2 = "Ponies!" I'd understand exactly what was happening :)
06:58:59 <ocharles> i guess it'd help if haddock could link to _1 and _2 as well, so I can just click on them to see what those do
06:59:04 <edwardk>  ((0, "Ponies!"), Just True)^._1._2  -- even
06:59:08 <edwardk> no need to chain ^.
06:59:10 <ocharles> yea. that.
06:59:13 <ocharles> :)
06:59:44 <ocharles> anyway, time to play with traversable and get a feel for them
06:59:50 <edwardk> i'm quite serious about being happy to accept patches that add docs
06:59:57 <ocharles> edwardk: oh also, are you at gsoc this year?
07:00:00 <edwardk> fork, and pull request me
07:00:03 <edwardk> yes
07:00:10 <edwardk> you?
07:00:17 <ocharles> awesome, i should be there again too, so I'll try and grab you and maybe we can chat about improving docs
07:00:32 <ocharles> infact, we might even consider running a session on improving documentation for haskell programmers
07:00:52 <typoclass> hpc: i didn't find the haddock helpful for learning it from scratch, it doesn't tell you at all how things fit together ...
07:00:56 <ocharles> and get some feedback from other haskell users (all... 5 of us? :P) and see what common problems they encounter
07:01:02 <edwardk> lens has easily an order of magnitude more documentation than i'd ever supplied before ;)
07:01:14 <ocharles> it has been noticed and appreciated :p
07:03:24 <Sculptor> wadup
07:05:05 <milk_`> can anyone take a look at the code (http://hpaste.org/74021) and tell me if lexeme is used in the right way? thanks :)
07:05:29 <edwardk> ocharles: did we speak last year at gsoc? i'm having trouble sticking a face to a nick
07:05:39 <ocharles> heh, yes, briefly
07:05:59 <ocharles> I was talking to you about me using copointed and you suggested it probably formed a comonad too
07:06:16 <edwardk> fair enough =)
07:06:17 <ocharles> and then explained a load of stuff that went over my head and I think you showed me something in agda :)
07:06:25 <ocharles> lets see if I have a picture somewhere
07:08:03 <edwardk> hahaha
07:08:14 <ocharles> http://a7.sphotos.ak.fbcdn.net/hphotos-ak-snc6/222663_10150185158256272_5656540_n.jpg is a rather bad picture of yours truly
07:08:30 <edwardk> i vaguely recall
07:08:35 <ocharles> :)
07:08:52 <edwardk> what org were you with?
07:08:57 <ocharles> musicbrainz
07:09:01 <shachaf> ocharles: You should come to bahaskell!
07:09:02 <edwardk> ah
07:09:20 <ocharles> shachaf: details?
07:09:23 <shachaf> We're trying to arrange it to be the Thursday before GSoC weekend and have edwardk do a talk.
07:09:25 <ocharles> (i haven't heard of that)
07:09:36 <shachaf> Are you in the bay area or just visiting for that weekend?
07:09:48 <timthelion> When I have "newtype T = T String; foo=T "Hi" ; what is the best inline method of extracting the string from foo?
07:09:59 <ocharles> both (: I'm staying with my organisation after gsoc, so I can certainly fly in a bit earlier too
07:10:04 <edwardk> i can probably put together a talk on lenses if i can know you guys will have the session on the right day ;)
07:10:22 <edwardk> timthelion: newtype T = T { runT :: String }
07:10:24 <edwardk> then use runT
07:10:30 <shachaf> edwardk: Should I bug them some more about that?
07:10:34 <edwardk> yes
07:10:35 <shachaf> Several people have expressed interest.
07:10:43 <ocharles> shachaf: where should I watch/listen for bahaskell information?
07:10:44 <edwardk> that way i can know to prepare slides =P
07:10:45 <timthelion> edwardk: oh, I can ues record selectors with newtypes :D  Cool..
07:10:59 <shachaf> Surely you mean newtype T = T { _t :: String }; makeLenses ''T
07:11:07 <edwardk> shachaf: hahaha that too
07:11:11 <shachaf> ocharles: bahaskell mailing list.
07:11:13 <shachaf> @google bahaskell
07:11:14 <edwardk> that one i don't recommend though
07:11:14 <lambdabot> http://groups.google.com/group/bahaskell
07:11:14 <lambdabot> Title: Bay Area Haskell Users Group | Google Groups
07:11:18 <ocharles> great, joining now
07:11:25 <edwardk> you'd want to use makeIso ;)
07:11:35 <shachaf> edwardk: Not necessarily...
07:11:43 <shachaf> Depends on what the newtype is supposed to mean.
07:11:48 <shachaf> Well, I guess not.
07:11:50 <sheldonh> i wonder whether there's a haskell community in south africa. afaik, there are only 3 ;)
07:12:01 <sheldonh> (haskell programmers, that is)
07:12:05 <ocharles> i'm still surprised there doesn't seem to be a london user group that's active
07:12:05 <shachaf> Since a lens lets you do pretty much everything Iso would.
07:12:11 <ocharles> there's haskell hoodlums, which I still need to go to sometime...
07:12:14 <edwardk> yeah
07:12:25 <edwardk> except construct one out of whole cloth, which is silly to deny
07:12:37 <shachaf> Right -- looks like he's allowing that anyway.
07:12:52 <timthelion> I'm doing newtype ResolvedDependencies = ResolvedDependencies [String] and newtype UnresolvedDependencies = UnresolvedDependencies [String] just to make my program that much more type strict.  So far, I'm not clear if it's making things better or just more confusing thoug :/
07:13:10 <sheldonh> what's the name of the mathematical process whereby i derive 1/2 from 4/8?
07:13:15 <shachaf> You can use a phantom type to make some functions that operate on either.
07:13:21 <shachaf> sheldonh: Reducing?
07:13:27 <shachaf> Alternatively: The identity function?
07:13:52 <sheldonh> shachaf: google agrees. thanks :)
07:14:59 <hpc> timthelion: data Dependencies a where Resolved :: [String] -> Dependencies Resolved; Unresolved :: [String] -> Dependencies Unresolved
07:15:16 <hpc> now functions can be defined only for resolved/unresolved depends, or for both
07:15:26 <hpc> if they are defined for both, they have to know how to handle both cases
07:15:41 <hpc> and doing the same thing for both cases is verbose
07:17:04 <timthelion> hpc: and how does one create the record selector for the [String] in that case?
07:17:31 <hpc> resolved :: Dependencies a -> Bool
07:17:35 <shachaf> By looking up the GADT record syntax in the GHC manual.
07:17:40 <hpc> resolved (Resolved depends) = True
07:17:42 <shachaf> I can never remember the new one. The old one was better.
07:17:42 <hpc> ...
07:17:46 <hpc> also what shachaf said ;)
07:18:05 <shachaf> hpc: A Bool is a terrible thing to introduce into that program. :-(
07:18:18 <hpc> shachaf: er, yeah i misunderstood the question
07:18:23 <hpc> i thought he meant how do you pattern-match
07:18:30 <shachaf> Anyway you don't really need a GADT, just a phantom type.
07:18:46 <shachaf> newtype Dependencies a = Depenencies [String]
07:18:47 <timthelion> Anything *wrong* with GADT?
07:18:56 <shachaf> Then do everything statically.
07:19:12 <hpc> shachaf: a GADT lets you know if you have or haven't resolved the dependencies, even in the "i don't care either way" case
07:19:12 <shachaf> Polymorphic functions just keep the a polymorphic.
07:19:25 <shachaf> It's not wrong or right, it's different.
07:19:33 <shachaf> It may or may not be what you want. I don't know what you want.
07:19:44 <timthelion> good lord the GADT syntax is a study in ugliness§
07:19:45 <timthelion> !
07:20:05 <hpc> timthelion: it's not as bad as it could be
07:20:24 <shachaf> (Except to join #haskell and talk about how terrible random parts of it are on a fairly regular basis.)
07:20:24 <hpc> after using agda, i kinda prefer it to regular data syntax
07:20:37 * shachaf should go to sleep.
07:20:39 <shachaf> @localtime
07:20:43 <lambdabot> Local time for shachaf is Sat Sep  1 07:20:20 2012
07:20:47 <timthelion> oh, the regular data syntax should be considered a bug! It just encourages bad typing.
07:21:14 <timthelion> shachaf: as in, you just woke up, or you've been awake all night?
07:21:22 <shachaf> Totally, man.
07:21:26 <hpc> haha
07:21:50 <timthelion> shachaf: You're answer was typed even worse than Bool
07:22:23 <shachaf> Bool is a fine type. 2 is a fine number.
07:22:36 <shachaf> Finer than I am answer, at least.
07:22:45 <sheldonh> shachaf: wow, you've been pretty lucid for someone who's been up so long
07:22:57 <shachaf> sheldonh: How do you know how long I've been up?
07:23:03 <shachaf> Anyway, I'm completely not lucid.
07:23:29 <shachaf> Complaining in #haskell is something I can do in my sleep.
07:23:34 <shachaf> :-(
07:25:33 <sheldonh> haha
07:25:59 <sheldonh> shachaf: i assumed a diurnal lifestyle ;)
07:28:55 <beyeran> Anyone else got any problems with installing regex-tdfa?
07:29:48 <sheldonh> gosh. no highest common factor in the stdlib?
07:30:32 <sheldonh> gcd
07:33:45 <ocharles> edwardk: I can't seem to pass a Traversal in to both 'views' and 'over' in the same function. 'views' turns that function into a Getting, but over wants a Setting. Seems to be the Accessor/Mutator newtype that's causing problems
07:33:47 <timthelion> shachaf: was that you answering your own question?
07:33:52 <ocharles> resolve t r toRef mapper = over t r ^>> ( (views toRef return ^>> mapper) &&& returnA ) -- >>^ \(map, v) -> over toRef (map Map.!) v
07:34:03 <ocharles> ^ that's said function, the last part is what I want to work but is commented out
07:34:28 <edwardk> ocharles: write a type signature for the function and explicitly name the argument as a Traversal
07:34:37 <ocharles> ah, so it's just inference getting confused
07:34:53 <edwardk> without the type signature you have to cloneTraversal or pass the arg a a ReifiedTraversal
07:34:58 <edwardk> er as a
07:35:01 <edwardk> yes
07:35:07 <sheldonh> jesus. for a moment, i convinced myself that 0/0 is 1/1
07:35:11 <sheldonh> time for a break
07:35:26 <ocharles> I plan to export this function later, so adding a type sig is fine
07:35:43 <edwardk> what is ^>> ?
07:35:55 <ocharles> a ^>> b = arr a >>> b
07:35:57 <edwardk> oh, nm
07:36:17 <edwardk> yeah took me a second to recognize the arrow func =)
07:36:19 <ocharles> I think I might be able to use some of your passthrough stuff for the 'middle' bit
07:36:53 <hiptobecubic> sheldonh, a/a = 1. qed.
07:36:58 <ocharles> the idea is to transform a Traversal of 'cells' into a Traversal of 'references', then inflate all these references at once, and then 'inflate' the cells into something more complex
07:37:16 <ocharles> i use &&& to split tho input with the map of full objects so I can rethread it all later
07:37:36 <sheldonh> hiptobecubic: i wish i could bottle that feeling :)
07:37:51 <edwardk> btw- did you notice you can use arrow sugar when composing lenses? =)
07:38:50 <ocharles> edwardk: as in >>> and <<< ?
07:38:58 <edwardk> as in the proc sugar
07:39:13 <ocharles> oh, I haven't used that yet :)
07:39:20 <ocharles> i'm not sure how much I like it
07:39:25 <ocharles> (from briefly seeing it)
07:39:26 <parcs`> edwardk: but is it useful?
07:39:29 <edwardk> because lenses are functions, they just happen to be functions from things (c -> f d) to (a -> f b)
07:39:52 <edwardk> parcs`: not with lenses/traversals but with 'multiplates' it starts to pay off
07:40:23 <edwardk> e.g. if you define
07:40:58 <edwardk> _either (f,g) (Left a) = Left <$> f a; _either (f,g) (Right b) = Right <$> g b
07:41:18 <edwardk> then you can use arrow sugar to plumb those indexed algebras in
07:42:17 <edwardk> its rather baroque for that level of complexity, but may pay off when you start with a big multisorted traversal like for statements and expressions
07:45:28 <edwardk> got the one argument version of the store comonad working. next up, the indexed store comonad transformer
07:46:18 * hackagebot tls 0.9.10 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.9.10 (VincentHanquez)
07:46:20 * hackagebot monarch 0.2.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.2.0.0 (NoriyukiOhkawa)
07:49:35 <plat0> Is there a language extension that will allow me to do this:
07:49:37 <plat0> type Kleisli m a b = a -> m b
07:49:40 <plat0> instance Monad m => Category (Kleisli m) where id = return f . g = f <=< g
07:49:57 <sheldonh> in a function signature, how can i say that i expect an Integral? i tried this and failed: reduceFraction :: (Integral, Integral) -> (Integral, Integral)
07:49:58 <plat0> [sorry about the lack of line breaks]
07:50:07 <plat0> It seems I can't partially apply a type synonym
07:50:16 <Botje> sheldonh: Integral isn't a type, it's a type class.
07:50:42 <Botje> sheldonh: you want Integral a => (a,a) -> (a,a)
07:50:47 <geekosaur> plat0, yes, that's expected, a partialy applied type synonym is a type function, and ghc can't cope with those (yet?)
07:50:52 <applicative> sheldon, Integral is a predicate so you write Integral a => (a,a) -> (a,a)
07:51:06 <nand`> LiberalTypeSynonyms?
07:51:12 <nand`> check if that helps
07:51:18 <plat0> geekosaur: so there's no way I can convince it to accept that?
07:51:25 <sheldonh> Botje: "given that a is of a type in type class Integral, take and return a tuple of a's"?
07:51:41 <Botje> yep
07:51:46 <nand`> hmm no I don't think LiberalTypeSynonyms would help
07:51:54 <parcs`> plat0: nope
07:52:00 <parcs`> plat0: use a newtype
07:52:28 <plat0> That disappointing.  Gonna have to do a lot of wrapping and unwrapping then ...
07:52:33 <sheldonh> Botje: will that let me use different types of type class Integral within each tuple? or must i do Integral a, Integral b => (a, b) -> (a, b)
07:52:41 <applicative> plat0: you can also just define everything you need for the type a -> m b ; you already have <=< and so on
07:52:56 <geekosaur> sheldonh, the latter
07:53:02 <geekosaur> extra parens though
07:53:16 <geekosaur> (Integral a, Integral b) => (a,b) -> (a,b)
07:53:36 <sheldonh> geekosaur, Botje: thanks :)
07:53:49 <edwardk> LiberalTypeSynonyms can't be used to make instances
07:53:50 <applicative> plat0: why do you need to bring it under the type class? You can even get do notation with RebindableSyntax NoImplicitPrelude etc
07:54:14 <edwardk> plat0: yes, you need to use the newtypes
07:54:44 <edwardk> plat0: or more often, just use the combinators for m a directly, (>=>) and the like
07:54:48 <applicative> plat0 is evidently familiar with the Kleisli newtype in Control.Arrow or wherever it is
07:56:34 <plat0> This is for exposition rather than direct usage
07:56:49 <applicative> edwardk: here's my lensy definition of the morning: titleCase = (_head %~ toUpper) . (_tail %~ map toLower)
07:57:13 <plat0> I'm writing a short article and would like to introduce a lot of classes and instances demonstrating concepts.
07:57:20 <plat0> But I won't if I have to wrap and unwrap everything.
07:57:28 <edwardk> applicative: hrmm
07:57:32 <plat0> That would hinder more than help.
07:57:32 <applicative> ha
07:57:45 <edwardk> over _head toUpper . over traverseTail toLower ? =)
07:58:51 <applicative> edwardk: you've made a little more progress internalizing the combinators :)
07:58:52 <edwardk> for exposition i would just introduce Kleisli as an arrow, give the definition, then move on
07:58:57 <edwardk> applicative =)
07:59:35 <edwardk> mostly just seek to eradicate ()'s wherever i find them
08:00:14 <applicative> edwardk: yeah, actually >>> have ok precedence for _head %~ toUpper  >>> _tail %~ map toLower
08:00:28 <edwardk> heh
08:00:33 <applicative> >>> and <<< have ok precedence rather
08:01:31 <applicative> anyway, its just nonsense; I was trying to rewrite a toy bot someone wrote to practice the state-related combinators
08:01:51 <applicative> I mean, trying to Control.Lens-ify it
08:01:53 <Z`> wow, I wrote a hello world app and the resultant executable is 808K in size. and objdum -d file, lists like 110K lines
08:02:01 <edwardk> ah
08:02:24 <Z`> does my app have isnide it some haskell runtime or something ?
08:02:38 <applicative> Z`, basically.
08:02:44 <edwardk> Z` yes
08:02:52 <Z`> ok then,thanks!
08:03:04 <applicative> there are various stripping methods, do you think they've been applied
08:03:16 * applicative is ignorant about how they work
08:03:23 <Z`> I don't care for its size, just being puzzled at first glance
08:03:31 <Z`> but not I'm ok,thanks
08:04:25 <applicative> there used to be -fstrip-executables or something, but now maybe its the default or something better is done.
08:05:41 <nand`> remember also it's statically linked so all of the dependencies are pulled in as well
08:06:09 <Yuu-chan> I want to write something useful in Haskell...
08:06:47 <parcs`> so do it!
08:07:20 <hiptobecubic> Yuu-chan, what do you write that's useful in other languages?
08:07:55 <Yuu-chan> Unfortunately I began to learn it too late, otherwise I could use it for university tasks...
08:08:09 <hiptobecubic> rewrite university tasks in haskell
08:10:10 <Yuu-chan> hiptobecubic: I've already graduated :-\
08:10:27 <hiptobecubic> Yuu-chan, so?
08:10:54 <Mon_Ouie> You can rewrite them for learning purposes even if nobody requires you to do it
08:11:51 <Yuu-chan> That's less interesting
08:11:59 <Yuu-chan> But thanks for the idea :)
08:15:53 <Yuu-chan> hiptobecubic: as for the other languages, I use C++ in the job
08:16:14 <Yuu-chan> but nobody will allow me to use Haskell there :-(
08:17:13 <hiptobecubic> so just replicate your c++ lib
08:17:30 <Z`> can you call haskell code from within c++ /
08:17:31 <Z`> ?
08:17:37 <Jeanne-Kamikaze> yes
08:17:37 <timthelion> Yuu-chan: Kind of accademic, but you know Conway's game of life?  It would actually be possible to build a physical circute that acted like this game, where there was just a tiny circute for each cell in conways game(a bit of NAND memory, a clock capacitor, and some switches).  You could use haskell to try to figure out what you could compute with such a board, if you where able to read and write only to the edges of the board :)
08:17:49 <Jeanne-Kamikaze> search for the ffi page on the wiki
08:18:00 <Z`> thanks Jeanne-Kamikaze
08:18:10 <nand`> port haskell libraries to C++ templates
08:18:28 <hiptobecubic> Jeanne-Kamikaze, isn't that for calling c++ from within haskell?
08:18:36 <nand`> hiptobecubic: works both ways
08:18:38 <Jeanne-Kamikaze> and the other way around too
08:18:40 <edwardk> i look forward to the c++ lenses port
08:18:46 <nand`> haha
08:18:59 <nand`> yeah, because the ability to write “a = b” in C++ will be elegant
08:19:00 <hiptobecubic> nothing cpp can't handle
08:19:05 <nand`> or a.b = c
08:19:10 <hiptobecubic> a few #ifdefs here and there
08:19:16 <edwardk> nand` =)
08:19:33 <ion> nand++
08:19:46 <t7> @karma t7
08:19:46 <lambdabot> You have a karma of 2
08:19:53 <t7> what do i start with?
08:19:56 <hiptobecubic> 2
08:19:57 <ion> preflex: karma c
08:19:59 <nand`> -4
08:20:01 <timthelion> @karma timthelion
08:20:01 <lambdabot> You have a karma of 0
08:20:23 <parcs`> @karma c/c
08:20:23 <lambdabot> c/c has a karma of 251
08:20:31 <t7> now irc can be like reddit... :(
08:20:31 <hiptobecubic> timthelion--
08:20:37 <timthelion> @karma haskell
08:20:37 <lambdabot> haskell has a karma of 6
08:20:39 <hiptobecubic> @karma timthelion
08:20:39 <lambdabot> timthelion has a karma of -1
08:20:48 * hiptobecubic cackles
08:20:56 <t7> timthelion++
08:20:57 <timthelion> lambdabot--
08:21:04 <Yuu-chan> timthelion++
08:21:10 <timthelion> @karma lambdabot
08:21:10 <lambdabot> lambdabot has a karma of 7
08:21:11 <t7> @karma lambdabot
08:21:11 <lambdabot> lambdabot has a karma of 7
08:21:22 <ion> Haskell++, the object-oriented version of Haskell
08:21:27 <nand`> @karma xs
08:21:28 <lambdabot> xs has a karma of 0
08:21:32 <nand`> worth a try
08:21:32 <timthelion> t7++
08:21:35 <t7> caHaskell
08:21:38 <ion> the object-oriented version of Haskell that’s nothing like Haskell
08:22:10 <parcs`> @karma krma
08:22:10 <lambdabot> krma has a karma of 0
08:22:11 <parcs`> @karma karma
08:22:12 <lambdabot> karma has a karma of 1
08:22:17 <ion> @karma coma
08:22:17 <lambdabot> coma has a karma of 0
08:22:17 <parcs`> bah
08:22:28 <parcs`> karma--
08:22:34 <parcs`> now karma is worthless
08:22:39 <Yuu-chan> What could be Haskell--? Haskell without typeclasses?
08:22:52 <k0ral> hello, I would like to make "ReaderT A1 (... (ReaderT AN (ReaderT X (ReaderT B1 (... (ReaderT Bn m)...) instance of a class C, for all A1...An and B1...Bn
08:22:53 <timthelion>  The translator is a prototype, and is rather `rough and ready'.
08:22:53 <timthelion>     There are no error messages. If translation fails, look in the translated output to see where the error occurred.
08:22:55 <t7> haskell with explicit typing
08:22:55 <hiptobecubic> what about Core?
08:22:58 <timthelion> from the haskell++ page
08:23:29 <t7> does core have all the types specified?
08:23:30 <nand`> that's a lot of readers
08:23:35 <k0ral> I wrote "instance (Monad m, MonadTrans t) => C (t (ReaderT X m))" but that didn't work
08:23:40 <nand`> t7: I thought Core doesn't have types
08:23:58 <k0ral> why wouldn't that work ?
08:24:02 <nand`> type checking is a high level thing, they get less and less important as you get low level
08:24:30 <parcs`> k0ral: what's X?
08:24:52 <t7> i thought its super important for optimizing?
08:25:36 <k0ral> parcs`: a datatype, does it matter ?
08:26:07 <k0ral> the point is: how do I make any stack of monads that includes ReaderT X an instance of a class C
08:27:21 <hpaste> gabor pasted “Mesh (lists, thrists)” at http://hpaste.org/74026
08:31:52 <applicative> k0ral: could you do something like define the class for the inner thing?  class C phi where c :: forall t . MonadTrans t. t phi x -> x or whatever
08:33:39 <applicative> class C phi psi where c:: forall t MonadTrans t . t (phi psi) x -> x
08:34:02 <k0ral> sorry, I don't understand your question :S
08:34:30 <k0ral> my class C is basically to access elements of the X datatype
08:34:55 <applicative> put  the monadtrans constraint on the function in the class definition, not on the class definition itself
08:35:15 <k0ral> oh
08:35:18 <k0ral> let me try this
08:35:37 <parcs`> k0ral: it will require overlapping instances but: instance Monad m => C (ReaderT X m); instance (C m, MonadTrans t) => C (t m)
08:35:41 <applicative> but maybe I'm not seeing the role of X I was thinking of something else
08:36:05 <hpaste> gabor annotated “Mesh (lists, thrists)” with “Mesh (lists, thrists) (annotation)” at http://hpaste.org/74026#a74033
08:36:12 <k0ral> applicative: err, actually it's not in the class definition, it's in the instance one
08:36:30 <parcs`> k0ral: you basically want MonadReader but for a specific data type?
08:37:18 <k0ral> parcs`: I basically want MonadReader without the functional dependency, because I want to read several things, sometimes all of them, sometimes a subset of them
08:37:32 <edwardk> k0ral: why do you want to make every monad transformer stack an instance of C?
08:37:54 <k0ral> edwardk: every monad transformer stack with ReaderT X within it
08:37:54 <edwardk> k0ral: life without that functional dependency is hell
08:38:04 <k0ral> edwardk: yes but life with it is also hell
08:38:19 <edwardk> if you have multiple environments why not fuse them together into a single environment?
08:38:23 <edwardk> and then asks for parts of it?
08:38:25 <k0ral> edwardk: it forces me to gather all readable things in one single datatype
08:38:35 <edwardk> yes
08:39:01 <edwardk> and you can use lenses or other tools to focus down on the portion of the environment when you don't want to deal with all of it
08:39:33 <k0ral> I would like to write functions that live in the smallest environment
08:39:45 <bobTBuilder> can someone summerize in one paragraph why C++ is not a functional programming language
08:39:49 <edwardk> class HasFoo t where foo :: t -> Foo;    instance HasFoo Foo where foo = id;  then work with (MonadReader t m, HasFoo t) where you need access to a 'Foo'
08:39:56 <edwardk> that lets you live in the smallest environment
08:40:19 <k0ral> edwardk: that's what I did, I have several HasAttribute classes
08:40:21 <edwardk> because when you only need 'Foo' you can work with Foo, but when you also need Bar you can tuple it up into something bigger
08:40:34 <k0ral> edwardk: now I have to give an instance for those classes
08:40:36 <edwardk> and you can use a package like lens to query to shrink to smaller environments
08:41:18 <edwardk> the C one you asked for or you don't like the fact that the balled environment needs instances for them?
08:41:30 <k0ral> edwardk: as I used stacked runReaderT, I have to make the stacked ReaderT monads instance of all HasFoo-like classes
08:41:56 <edwardk> imho stacking multiple readers is a recipe for pain, but knock yourself out
08:42:16 <Yuu-chan> bobTBuilder: there are no first-class functions, only imitations of them
08:42:24 <edwardk> i would far rather 'asks foo' than count lifts
08:42:34 <applicative> bobTBuilder: if C is, why not C++  http://conal.net/blog/posts/the-c-language-is-purely-functional
08:42:56 <k0ral> edwardk: right, but passing the whole environment to a tiny function makes it far less generic
08:43:08 <kuribas> Is there a haskell library for command line editing?
08:43:39 <edwardk> k0ral: you have a HasFoo constraint. just use program to that constraint. the function is now generic. it works for Foo -> a, it works for Bar -> a where HasFoo Bar, etc.
08:43:40 <applicative> kuribas haskeline
08:43:51 <edwardk> it works for ReaderT Bar (StateT Baz IO) a
08:43:53 <applicative> kuribas: or the various bindings to readline et al
08:44:03 <applicative> kuribas: or do you mean something more specialized
08:44:11 <kuribas> applicative: Great, that's what I was looking for!
08:44:22 <kuribas> applicative: No, it will do perfectly.
08:44:42 <edwardk> bar :: (HasFoo t, MonadReader t m) => do x <- asks foo; do more stuff.
08:45:13 <edwardk> that function works over a wide array of transformer stacks and even the simple (->) monad
08:45:41 <k0ral> edwardk: not sure I made my point clear
08:46:07 <k0ral> edwardk: say you have HasA, HasB, HasC, HasD
08:46:11 <applicative> kuribas some idea how to use it might come from looking at one of the users. http://packdeps.haskellers.com/reverse/haskeline I think there's a little demo inside the package if you cabal unpack haskeline
08:46:13 <edwardk> sure
08:46:31 <k0ral> edwardk: in the end you'll have to run your program with an instance for all of them
08:46:35 <edwardk> yes
08:46:52 <edwardk> which is less painful than counting lifts or relying on magic overlapping instances to hopefully disambiguate
08:46:53 <k0ral> edwardk: I'm using a stacked sequence of ReaderT
08:47:14 <k0ral> ReaderT A (ReaderT B (...
08:47:18 <edwardk> yes
08:47:28 <k0ral> I want to make this an instance of each HasX
08:47:30 <edwardk> i got that, i'm just saying its a bad idea
08:47:45 <k0ral> ok so what's the nice way of doing this ?
08:47:51 <k0ral> keeping the HasX classes
08:48:59 <edwardk> HasX works fine, just make one environment. that is an instance of all the classes
08:49:00 <edwardk> the functions that need B and C just program them with (HasB e, HasC e, MonadReader e m) => m Whatever
08:49:15 <edwardk> and then when you kick it all off just make sure you have a data type that has the right instances
08:49:48 <edwardk> now there are no magic overlapping instances, and all the work that went into the mtl to define how MonadReader is working for your
08:49:50 <edwardk> er for you
08:50:03 <k0ral> right, now I have an objection :D
08:50:13 <edwardk> you don't like making that big tuple type
08:50:37 <sheldonh> hmmm... if two numbers have a common denominator, then their product is divisible by that denominator. i wonder if the converse is true
08:50:38 <k0ral> that's not a big deal using your MonadReader, it keeps thing generic so I like it
08:50:46 <k0ral> but
08:51:09 <k0ral> sometimes, I just don't have the whole environment accessible
08:51:20 <edwardk> thats fine
08:51:40 <k0ral> so I just can't build it entirely, I have to use a subset of it which is also instance of HasB and HasC
08:51:43 <edwardk> you can call any function you want that takes the smaller environment, just build another type that has the apropriate instances for what you have
08:52:14 <edwardk> more advanced use would be to parameterize the code on the lenses into your environment
08:52:21 <edwardk> and then you can avoid writing all these instances
08:52:28 <SLi> Hmh. I have a problem. Due to a problem X, I started to wonder about termination analysis for Haskell programs. Then I found a nice paper and a nice set of slides about it and read it. Now I no longer remember what my original problem X was.
08:52:38 <edwardk> SLi: hah
08:52:46 <k0ral> edwardk: you're writing too fast for me to answer :)
08:52:59 <sheldonh> does haskell have a block comment syntax?
08:53:06 <edwardk> sheldonh: {- -}
08:53:20 <k0ral> edwardk: say E is the big environment with everything, and F is a smaller one that is also instance of HasB and HasC
08:53:50 <k0ral> hmmmm
08:54:04 <k0ral> edwardk: damn it you're right, this should work fine
08:54:25 <sheldonh> edwardk: doh, thanks. i've even seen it ued for pragmas (or something that looked like 'em)
08:54:25 <k0ral> I was afraid it would create instances conflicts
08:56:08 <k0ral> edwardk: I'm trying this and I'll come back if it doesn't compile :)
08:56:17 <k0ral> edwardk: thank you
08:56:37 <edwardk> let me give you a long example
08:56:40 <edwardk> using lenses
08:56:44 <edwardk> almost done
08:57:31 <k0ral> edwardk: looking forward to it :)
08:57:48 <edwardk> @hpaste
08:57:48 <lambdabot> Haskell pastebin: http://hpaste.org/
08:58:00 <k0ral> the only thing I could dislike with this solution is that it needs adding a MonadReader instance everywhere
08:58:26 <k0ral> I used to have classes like (ConfigReader m, OptionsReader m, UIReader m)
08:58:52 <k0ral> now I have to transform it to (MonadReader e m, ConfigReader e, OptionsReader e, UIReader e) everywhere
08:59:06 <k0ral> and rename thos XReader to HasX
08:59:09 <k0ral> those*
08:59:17 <hpaste> edwardk pasted “k0ral” at http://hpaste.org/74042
08:59:54 <edwardk> k0ral: that shows how you can cut the pain of writing the HasFoo instances
09:00:02 <edwardk> (the HasArg classes, etc are built by makeClassy
09:00:29 <k0ral> edwardk: yet another reason to rewrite my whole code *again* :) I like it
09:00:32 <edwardk> makeClassy ''Arg builds class HasArg t where arg :: t -> Arg
09:00:38 <edwardk> and makes Arg an instance
09:00:41 <edwardk> and gives you
09:00:49 <edwardk> aX, aY :: Simple Lens Arg Int
09:01:04 <edwardk> query can be used to access portions of the environment through a lens or getter
09:01:11 <edwardk> and aX and aY qualify
09:01:59 <tibbe> I need to represent sharing in a DSL, what options do I have in terms of constructors to add to my AST?
09:01:59 <lambdabot> tibbe: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:02:14 <k0ral> edwardk: is that Template programming ?
09:02:30 <edwardk> tibbe: you can use observable sharing, or you can make a Let constructor, or you can borrow tricks from, say Bound.
09:02:43 <edwardk> personally i'm fond of options a.) and c.)
09:03:01 <tibbe> edwardk: so I will use observable sharing (via pointer eq) but I want to figure out the best representation of that sharing in my AST once I have detected it
09:03:05 <edwardk> the ad package uses observable sharing in the reverse mode, bound is much more accessible and is haskell 98
09:03:13 <edwardk> have you used data-reify?
09:03:35 <tibbe> Type-Safe Observable Sharing in Haskell by Andy Gill
09:03:38 <edwardk> yep
09:03:44 <edwardk> http://ittc.ku.edu/~andygill/papers/reifyGraph.pdf
09:03:45 <tibbe> I will use that
09:03:53 <edwardk> works well if you have a monotyped dsl
09:04:02 <edwardk> you can rebuild it one rank higher if you need better types
09:04:05 <tibbe> but that really only tells me how to find the sharing, I don't really care for his graph representation in the end.
09:04:08 <edwardk> i've done that a few time
09:04:10 <edwardk> er times
09:04:30 <tibbe> I want to convert the graph representation back to a more traditional AST with a Var constructor or some such
09:04:44 <edwardk> the graph itself is crap but its just a placeholder. i would convert from it to something like Bound.
09:05:00 <edwardk> http://hackage.haskell.org/package/bound
09:05:20 <edwardk> there are a number of examples there showing how to deal with capture avoiding substitution and let bindings, etc.
09:05:28 <edwardk> its just a monad transformer
09:05:43 <edwardk> so build a free-like monad for your syntax, and let Scope take care of names for you
09:06:04 <tibbe> hmm
09:06:08 <tibbe> I would have to read it closer
09:06:25 <edwardk>  data Exp a = V a | Exp a :@ Exp a | Lam (Scope () Exp a)  -- forms an untyped lambda calculus
09:06:42 <edwardk>  data Exp a = V a | Exp a :@ Exp a | Lam (Scope () Exp a) | Let (Scope Int Exp a) (Scope Int Exp a) -- forms an untyped lambda calculus with recursive let bindings
09:07:00 <edwardk> once you have it as a graph its easy to spew out a syntax tree
09:07:10 <edwardk> and the scope stuff there lets you deal with instantiation, etc.
09:07:42 <edwardk> without having to worry about screwing it up
09:08:51 <edwardk> https://github.com/ekmett/bound/blob/master/examples/Simple.hs shows a full untyped lambda calculus. https://github.com/ekmett/bound/blob/master/examples/Deriving.hs shows one with pattern matching
09:08:51 <tibbe> edwardk: so once I have the graph, where do I have to put my lets?
09:09:20 <tibbe> the Vars are kinda easy, they go at the nodes pointed to by two or more nodes
09:09:53 <edwardk> consider if you were to expand it into a tree, you want the let to be at the closest containing syntax node that contains all its use sites
09:10:39 <tibbe> right
09:10:46 <tibbe> I will expand it to a tree :)
09:11:06 <tibbe> so I guess the main problem is dealing with name collisions and I guess that's what bound does?
09:11:11 <edwardk> yep
09:11:21 <edwardk> bound takes care of names for you pretty much entirely
09:11:35 <tibbe> it's kinda easy to give all Vars unique names, but I guess the problem comes once I start moving the names around
09:12:05 <edwardk> basically all you write is the core of the monad for your expression type and scope deals with making sure you never have capture problems
09:12:18 <tibbe> right
09:12:19 <tibbe> hmm
09:12:25 <edwardk> https://github.com/ekmett/bound/blob/master/examples/Simple.hs#L57 note the funny >>>='s
09:12:26 <tibbe> my AST is kinda funky
09:12:44 <tibbe> I'm trying to cast it in terms of something more familiar
09:12:44 <edwardk> those are basically using Scope as a monad transformer to deal with names
09:13:08 <edwardk> *nods*
09:14:10 <tibbe> so my AST has "super" operations e.g. : data AST = Concat … | ConcatMap … | GroupByKey ...
09:14:19 <edwardk> doing gpu work?
09:14:32 <tibbe> not quite, the idea is the same
09:15:17 <edwardk> ok
09:15:26 <merijn> Is there a way to see the haskell generated by TH?
09:15:29 <tibbe> now I need to introduce sharing because users might write: let input = concatMap … textFile "foo" in (concatMap f input, concatMap g input)
09:15:37 <edwardk> merijn: -ddump-splices i think
09:15:53 <tibbe> edwardk: so the first thing I will do is to use andy's work to get the sharing back
09:16:31 <tibbe> edwardk: and I'm basically trying to think of a simple way to represent it in the AST. Simple as in "simple for someone who doesn't think about HOAS all day"
09:16:39 <edwardk> *nods*
09:17:05 <tibbe> it feels like I could almost get away with having now scoping lets and just all unique Vars
09:17:11 <tibbe> but I haven't though it true
09:17:17 <tibbe> what if I never introduce any new lets?
09:17:30 <edwardk> you can always just write the boring hoas version but doing analysis on the AST is awkward
09:18:05 <edwardk> if you are doing a very shallow dsl or final encoding the hoas version works great
09:18:18 <edwardk> but the moment you want to do some analysis hoas kind of sucks
09:18:33 <tibbe> so what are my options?
09:18:35 <tibbe> hoas
09:18:37 <tibbe> de bruin
09:18:50 <tibbe> string names and be careful about collisions when moving things around?
09:18:51 <edwardk> bound is secretly locally nameless generalized de bruijn, but you never see it
09:19:07 <edwardk> so you can compare terms for structural equality with (==), etc.
09:19:08 <applicative> @type toChurch
09:19:09 <lambdabot> Not in scope: `toChurch'
09:19:22 <edwardk> and within the debruijn world there are several flavors
09:19:54 <edwardk> depending on if you want to rule out illegal terms where you have more bound variable levels than lambdas, etc.
09:19:55 <tibbe> just to get this to my thick head
09:20:08 <tibbe> what's the problem if I take the graph with sharing a convert each shared node to a Var Unique
09:20:46 <edwardk> Unique in the data-reify sense or in the ghc sense?
09:20:53 <tibbe> um
09:20:58 <tibbe> as a unique number to represent that node
09:21:07 <edwardk> then you need a unique variable supply
09:21:12 <tibbe> basically all I need (I think) is a Map Unique Expr
09:21:14 <edwardk> this is the barendregt convention
09:21:15 <edwardk> actually
09:21:22 <edwardk> i have a good overview of these!
09:21:23 <edwardk> one sec
09:21:36 <tibbe> getting a unique number supply doesn't seem that hard
09:21:38 <edwardk> http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less
09:21:43 <edwardk> it isn't hard
09:22:00 <edwardk> its hard to remember to make sure that you fully substitute everywhere that you need to though when you go and copy a term all the binders have to be renamed
09:22:15 <edwardk> _that_ is a source of epic brain breaking pain
09:22:54 <edwardk> 'the secrets of the ghc inliner' talk a bit about a more intelligent technique they use to make the  barendregt convention suck less
09:23:26 <tibbe> ah
09:23:28 <edwardk> the problem comes in when i go to graft a syntax tree into my syntax tree (aka any time i do substitution) i need to remember to replace all of its binders recursively
09:23:31 <edwardk> this is slow
09:23:34 <tibbe> when would I copy a node?
09:23:49 <tibbe> so inlining is the problem?
09:24:08 <edwardk> the moment you go to instantiate a variable to a tree, e.g. during evaluation when you call a lambda and pass it the body for the var or when you inline, etc.
09:24:20 <tibbe> I feel like I need to re-read some basic material to remember what the problem people trying to solve is
09:24:25 <edwardk> with bound you just call isntantiate
09:24:35 <edwardk> take a look at the slides i linked
09:24:42 <tibbe> I never evaluate my tree
09:24:43 <edwardk> they give a brief overview of other approaches
09:24:48 <edwardk> before i give a nice solution
09:24:51 <tibbe> although I compile it so maybe that comes down to the same thing
09:24:56 <edwardk> yes
09:24:58 <tibbe> reading slides
09:24:58 <edwardk> its the same thing =)
09:26:04 <edwardk> anyways i'm in the process right now of rewriting an entire compiler from the ground up to rip out the barendregt convention and replace it with the technique from bound. that i feel the need to do this should tell you how many hidden gotchas there are in the barendregt approach ;)
09:26:32 <edwardk> we've literally spent weeks debugging subtle issues caused by forgetting to rebind in places
09:26:33 <tibbe> :)
09:26:34 <tibbe> thanks
09:26:45 <edwardk> bound makes that impossible
09:26:53 <edwardk> unbound is another candidate solution
09:26:56 <edwardk> its somewhere in the middle.
09:26:57 <tibbe> so my compiler will be super simple in that I won't inline anything
09:27:01 <edwardk> you need the variable supply
09:27:17 <Enigmagic> i do inlining in llvm instead
09:27:34 * Enigmagic has a simple language :P
09:27:37 <edwardk> so is ours, but we do unification, in type checking, and we graft trees on when doing typeclass instantiation, etc.
09:27:48 <edwardk> all of those things are a form of substitution
09:28:06 <tibbe> edwardk: hmm, why can't I hoist all lets to the top-level if they are created by data-reify?
09:28:12 <tibbe> edwardk: and all names are unique
09:28:12 <edwardk> you can do that too
09:28:20 <edwardk> if you never create any new ones
09:28:25 <tibbe> I don't
09:28:42 <edwardk> it may be a better solution for you honestly
09:29:01 <tibbe> and if lets are top-level all I need is: Graph -> (Expr, Map Name Expr)
09:29:03 * timthelion just compiles to haskell and hopes that ghc is smart enough to optimize what he generates.
09:29:04 <tibbe> and Var constructors
09:29:05 <edwardk> guessing if this isn't for gpu, then its distributed ;)
09:29:13 <tibbe> edwardk: yes
09:29:21 <tibbe> edwardk: Vars correspond to GB/TB files
09:29:31 <tibbe> I don't want to duplicate those computations!
09:29:34 <edwardk> yep
09:29:52 <hpaste> KBme pasted “cabal install --force-reinstalls cabal-install” at http://hpaste.org/74043
09:30:01 <tibbe> the only inlining I can think of is something like this: let x = inputFile "foo" in (x, x)
09:30:06 <edwardk> i have a strongly typed dsl i was putting together for dealing with remote computations, around here somewere, but you probably don't want to start there, its a bit scary comparatively
09:30:13 <tibbe> edwardk: in that case x is just another name for an already existing file
09:30:35 <tibbe> edwardk: mine uses GADTs to represent the strongly typed syntax
09:30:35 <KBme> anyone know why I'm getting this? what do I need to update cabal?
09:30:41 <edwardk> i'll probably be inlining that dsl example into my indexed package
09:30:45 <KBme> this is from a brand new haskell-platform install
09:30:49 <KBme> from source
09:30:54 <applicative> KBme: what version of ghc is it?
09:31:06 <applicative> KBme what platform are you on>
09:31:09 <edwardk> @hpaste
09:31:09 <lambdabot> Haskell pastebin: http://hpaste.org/
09:31:21 <hpaste> edwardk pasted “Remote” at http://hpaste.org/74044
09:31:32 <edwardk> that doesn't have the observable sharing component in it
09:31:33 <KBme> ghc 7.4.1 stable
09:31:37 <edwardk> but it does generate a serializable dsl
09:31:40 <KBme> on linux-gentoo
09:31:44 <tibbe> edwardk: is it correct to say that there are no name capturing problems as long as all name start out unique and I don't introduce any new lets?
09:32:16 <edwardk> well, if you don't do any substitution and you have no binders (like lambda) then yes, it is vacuously true
09:32:28 <edwardk> if you introduce binders, like lambda, then all bets are off
09:32:42 <tibbe> edwardk: my AST would be what I showed you plus Var Unique to capture the sharing at the Haskell level
09:32:45 <timthelion> edwardk: I was thinking a bit about the serializability side of your "cary the computation to the data" concept.  Did you ever try using Hint for that?
09:33:25 <applicative> KBme what version of cabal install is already installed?
09:33:27 <edwardk> timthelion: you could probably do that, its a bit too high level a way to plumb the code around for my taste.
09:34:04 <timthelion> edwardk: high level, but with guaranteed flexibility.  You'll never run into a case where your "dsl" is too specific...
09:34:42 <edwardk> timthelion: but you have no type safety intrinsic to the protocol, you have versioning issues trying to keep both sides in sync, etc.
09:34:54 <edwardk> and you are tossing around plain text
09:35:07 <int80_h> anyone here experienced in stalling reactive-banana-wk for archlinux?
09:35:07 <timthelion> true true and true :)
09:35:13 <int80_h> installing, too.
09:35:31 <timthelion> int80_h: wk or wx?
09:35:43 <applicative> KBme did you install the Haskell Platform libraries with cabal install?
09:35:52 * applicative isn't sure that's possible
09:36:04 <int80_h> timthelion: wx, I got typos a-plenty today. :)
09:36:05 <timthelion> int80_h: I don't have experience, but I'm an Archer, if you tell me the error, I might help.
09:36:14 <edwardk> tibbe: the dsl i pasted has the ability to serialize lambdas so you can actually write functions you want to have execute remotely
09:36:41 <tibbe> edwardk: I'm actually not sending any functions. :)
09:36:47 <edwardk> i don't recommend copying the style, its a bit baroque in terms of plumbing, but i figured it'd give you thoughts =)
09:36:52 <edwardk> fair nuff
09:36:55 <tibbe> edwardk: I'm using the MapReduce trick of running the same binary on all machines
09:37:06 <Enigmagic> timthelion: systems like Dryad (MS/MSR) ship around the full executable with a special main function that selects between the regular program or some specific vertex function when running on a remote machine
09:37:15 <hpaste> ocharles pasted “single traversal” at http://hpaste.org/74045
09:37:19 <edwardk> kinda figured. mapreduce/mpi, etc. =)
09:37:29 <ocharles> edwardk: ok, I gotta give up. I'm trying with the above paste to have a single 't'
09:37:38 <ocharles> but I just can't get the damn thing to type check no matter what I try :(
09:37:50 <ocharles> that getting/setting stuff needs to be replaced by a Traversal, I know that much
09:38:01 <timthelion> Enigmagic: Hell, I just use TCP and pipe java script around :)
09:38:02 <edwardk> oh you are changing the type?
09:38:09 <ocharles> yea
09:38:18 <edwardk> then you'll need to pass in the traversal twice =(
09:38:21 <ocharles> bummer
09:38:25 * timthelion was joking.
09:38:48 <int80_h> timthelion : well, there's an out-of-date wxWidgets AUR that I was told could be bumped using abs. I tried installing from source, and got a boat-load of errors. Would you recommend proceeding with a install from source or attempting to bump up the AUR?
09:39:06 <edwardk> ocharles: basically the site where you get the traversal is where you pick the types for it
09:39:11 <Enigmagic> timthelion: i've seen something similar prototyped before for a large compute grid :|
09:39:23 <Enigmagic> "lets use javascript for ranking search results!"
09:39:25 <Enigmagic> ..
09:39:27 <timthelion> Enigmagic: the node.js people recomend it.
09:39:30 <ocharles> I have a traversal to a 'Ref a', and I need to replace that 'Ref a' with an 'Entity a'
09:39:37 <KBme> applicative, well, all I did till now was make install from haskell platform
09:39:41 <KBme> then add that to path
09:39:44 <KBme> then cabal update
09:39:46 <KBme> then this
09:40:01 <Enigmagic> timthelion: it's event driven, so you know it's good
09:40:06 <ocharles> (and I need to extract all 'Ref a's according to that pointer first to get the 'Entity a's)
09:40:13 <timthelion> int80_h: It depends how much weird FFI stuff there is, but if I recal, it's just a wrapper, in which case your best bet is to get wx running on arch(should be in the main repos) and then install from cabal.
09:40:16 <edwardk> so why can't you do this as an actual traversal?
09:40:23 <edwardk> rather than getting, doing stuff and setting?
09:40:45 <edwardk> you just need to come up with an appropriate Applicative
09:40:50 <applicative> KBme: what is strange is it looks as if cabal install is about to overwrite most of the core and Haskell Platform libraries
09:41:01 <hpaste> KBme pasted “cabal --version for applicative” at http://hpaste.org/74046
09:41:01 <ocharles> edwardk: maybe I can
09:41:27 <ocharles> but the idea is if I have [[Maybe (Ref a)]], I first get [Ref a], send that into my mapper, and then replace [[Maybe (Ref a)]] with [[Maybe (Entity a)]]
09:41:32 <KBme> applicative, yes, I guess that's the default behaviour
09:41:32 <applicative> KBme: oh, but that's the latest version of cabal install, no?
09:41:38 <KBme> maybe
09:41:42 <KBme> but why the error
09:41:43 <KBme> ?
09:41:44 <KBme> then?
09:41:52 <KBme> all I wanted was make sure cabal was latest
09:42:00 <edwardk> the matter is the a (m c1) (Map c d) ?
09:42:03 <edwardk> er mapper
09:42:04 <int80_h> timthelion: the version I need (wxWidgets 2.9.x) is not in the main repos
09:42:07 <KBme> as I said, I got the haskell platform, and installed it into a user prefix
09:42:14 <KBme> $HOME/haskell/prefix to be exact
09:42:22 <ocharles> edwardk: yea, in reality that's Kleisli IO [Ref a] (Map (Ref a) (Entity a))
09:42:37 <KBme> then ran $HOME/haskell/prefix/bin/cabal update; cabal install cabal-install
09:42:49 <edwardk> so why are we mucking this up with Kleisli? =)
09:43:01 <edwardk> do you have more complicated arrows coming later?
09:43:08 <timthelion> int80_h: well don't try to get bananna installed through AUR install what you can through cabal, and try to get wx from AUR.  You know you can just edit the PKG files after you down load them.
09:43:09 <ocharles> mmm, no, I guess not
09:43:16 <ocharles> I haven't actually written any implementations yet
09:43:19 <edwardk> sweet. one sec ;)
09:43:20 <ocharles> just types, for the most part
09:43:37 <ocharles> I can happily change that to [Ref a] -> IO (Map (Ref a) (Entity a))
09:43:53 <int80_h> timthelion: wx is what I am trying to install through AUR, not banana. But the author just made an update that may have solved my problem. brb.
09:43:57 <rosie> What's an efficient way to build up an array as a return value?
09:44:43 <Eduard_Munteanu> rosie: depends on how you want to build that array, any particular thing you had in mind?
09:45:17 <edwardk> m is []?
09:45:25 <ocharles> edwardk: yep
09:45:31 <ocharles> it might be Set later
09:45:35 <applicative> KBme I wonder whether cabal-install is installing to $HOME/.cabal/  does it exist?
09:45:37 <edwardk> k
09:45:43 <edwardk> just working down to the core of the problem
09:45:53 <int80_h> timthelion: crap, wishful thinking on my part. I'm back where I started. So should I begin with trying to update the wxwidgets AUR? Or install from source?
09:45:59 <rosie> Eduard_Munteanu: I'm looping through results from a database
09:46:11 <ocharles> edwardk: yea. it's a bit hard to work with as it's sooo abstract in that paste :)
09:46:25 <edwardk> so you want to take [[Maybe (Ref a)]] to [[Maybe (Entity a)]] using the map generated by a function of the Refs?
09:46:29 <KBme> applicative, yeah, it doesn't install into there
09:46:34 <KBme> err
09:46:42 <KBme> it *does* install in ~/.cabal
09:46:51 <KBme> damn, now I have to add that to my path too
09:46:57 <ocharles> edwardk: that's one example, but this also needs to be able to turn (Ref a) -> (Entity a) too
09:47:02 <ocharles> (with the 'id' traversal)
09:47:06 <edwardk> thats fine
09:47:08 <Eduard_Munteanu> rosie: alright, why do you need an array?
09:47:14 <edwardk> i'm planning on parameterizing over the traversal
09:47:17 <Eduard_Munteanu> I'm trying to understand the problem.
09:47:19 <rosie> er, by array I mean list
09:47:29 <applicative> KBme but that's not where the Platform libraries went, I take it
09:47:30 <Eduard_Munteanu> Ah.
09:47:34 <KBme> applicative, nope
09:47:57 <KBme> I installed into prefix /home/$USER/haskell/prefix
09:48:00 <edwardk> we're going to go use the Bazaar ;)
09:48:06 <int80_h> timthelion : If I should try to install from source, I can paste the erros I got. If AUR, I will proceed and paste the erros from that.
09:48:09 <ocharles> edwardk: ah, with cloneTraversal stuff?
09:48:11 <Eduard_Munteanu> rosie: if you just want to collect results as you go you can use the Writer monad.
09:48:20 <edwardk> more directly actually
09:48:38 <rosie> Edward_Munteanu:  thanks!
09:49:01 <edwardk> what is b -> c2?
09:49:08 <applicative> KBme and ghc-pkg list or whatever shows two databases, one 'global' (ie $HOME/haskell/..) and the other local?
09:49:30 <ocharles> edwardk: if I have a (Entity Release), one (b -> c2) might be (releaseCountry . entityData) :: Entity Release -> Maybe (Ref Country)
09:49:32 <applicative> KBme or wait maybe you haven't cabal installed anything yet.
09:49:48 <edwardk> so that could be factored out and just composed in elsewhere?
09:50:07 <KBme> applicative, when I had that error, that is corrent
09:50:10 <KBme> correct*
09:50:18 <KBme> cabal was the first thing I tried to install
09:50:21 <Eduard_Munteanu> rosie: although you could also just return a list and work it out manually
09:50:36 <rosie> Eduard_Munteanu: what do you mean?
09:50:36 <applicative> KBme but now ghc-pkg list reports about the two package databases?
09:50:58 <edwardk> e.g. resolve :: ([ref] -> IO (Map ref ent)) -> Traversal a b ref ent -> a -> IO b
09:51:08 <ocharles> edwardk: errr, maybe :) that was there because if I have [[Entity Track]], the (b -> c2) tells me how to go from Entity Track -> Ref Artist, for example. Another Traversal tells me how to get from [[Entity Track]] -> Entity Track
09:51:10 <edwardk> with appropriate constraints
09:51:14 <rosie> manually as in make my monad?
09:51:22 <ocharles> so one traversal to say what I want to replace, and one traversal to say how to get from that thing to a keyp
09:51:24 <ocharles> key*
09:51:25 <Eduard_Munteanu> rosie: I mean you could just return a list or pass it around in an accumulator
09:51:55 <applicative> KBme this isn't usually a problem with the standard global setup with libaries in /usr/local/whatever or whatever; the local installs cant damage the global ones.
09:52:41 <applicative> KBme: but I've only had this  problem with a local ghc when I had on reflection an obviously silly setup
09:52:48 <Zariel> Is there anyway I can 'tidy' up the Char in parseSegment in https://gist.github.com/202658a728f6a2647b00
09:53:05 <rosie> Eduard_Munteanu: I see how this works, thanks
09:53:10 <Zariel> so i dont need to do (f s) <+> (g s), so its like f <+> g
09:53:36 <KBme> applicative, well, but if I have the complete platform installed locally?
09:54:25 <ocharles> edwardk: that [[a]] -> a traversal does seem important for 'resolve' as otherwise it can only resolve one thing at a time
09:54:50 <edwardk> one sec. =)
09:54:52 <applicative> KBme yes, but the main thing is two locations for the libraries. Your original HaskellPlatform and ghc libraries like time and haskell98-2.0.0.1 and so on shouldnt be affected, but maybe things are different
09:56:05 <edwardk> this would be easier had i exported ins and outs from Control.Lens.Plated ;)
09:56:24 <edwardk> oh, derp, i can just use partsOf
09:56:50 <applicative> KBme the only time I had difficulty like this was the sillier plan where i directed cabal to use a local ghc in ~/ghc/bin and to put libs in ~/ghc/lib which is obviously a disaster
09:56:57 <edwardk> maybe not
09:57:10 <edwardk> unsafePartsOf :: LensLike (Bazaar c d) a b c d -> Lens a b [c] [d]
09:57:17 <edwardk> unsafePartsOf to the rescue
09:57:37 * ocharles looks that up
09:57:57 * applicative refuses to think about Bazaar yeet
09:57:58 <applicative> yet
10:00:47 <edwardk> somethingresolve :: Ord k => ([k] -> IO (Map k v)) -> Traversal a b k v -> a -> IO b; resolve m l = unsafePartsOf l m' where m' ks = liftM (\kvs -> map (!kvs) ks) m
10:01:04 <edwardk> er something like that
10:01:08 <timthelion> ReinH: Where is the code for episode 2 of HaskellLive?  And why can I not find either the note function anywhere?
10:01:19 <edwardk> that lets unsafeParts of work with the bazaar
10:01:50 <ocharles> where is unsafePartsOf ?
10:01:57 <edwardk> Control.Lens.Plated
10:02:04 <edwardk> its exported by Control.Lens
10:02:12 <ocharles> ok
10:02:20 <edwardk> you'll need a fairly current copy
10:02:31 <ocharles> installed freshly today
10:02:41 <ocharles> I should read Scrap Your Boilerplate at some point I guess
10:02:58 <edwardk> the Plated module is more about uniplate that SYB =)
10:03:21 <edwardk> unsafePartsOf is a generalization of a generalization of the original uniplate combinator
10:03:30 <edwardk> so its kind of tricky to get intuition for
10:03:49 <allsystemsarego> @src >=>
10:03:50 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:04:04 <edwardk> basically what i do there is use unsafeParts of to transform a traversal into a lens, where you are required to preserve the number of elements in the list.
10:04:22 <edwardk> its unsafePartsOf because unlike partsOf it can't deal gracefully with changing the number of elements
10:04:42 <edwardk> but in exchange it can change the type of the elements of the list
10:04:43 <merijn> allsystemsarego: I'm pretty sure it's just "f >=> g = \x -> f x >>= g"
10:04:54 <allsystemsarego> merijn, thanks
10:05:27 <ocharles> edwardk: I see. I'm gonna have a play around and hopefully gain a bit of intuition with this
10:05:41 <edwardk> ocharles: did that version i pasted make sense?
10:05:53 <ocharles> just trying now, turns out I did install today, but with an outdated index
10:05:56 <ocharles> so just updating
10:06:19 <edwardk> resolve m l = unsafePartsOf l m' where m' ks = liftM (\kvs -> map (!kvs) ks) m   -- takes a mapping function like you described, and a traversal. turns that traversal into a lens that looks at all the targets
10:06:42 <ocharles> dosen't seem to type check here
10:06:50 <edwardk> then i probably typod
10:06:58 <edwardk> i need to install lens, real fast one sec
10:07:10 <KBme> applicative, ah, no, I haven't set that in cabal
10:07:11 <ocharles> Couldn't match expected IO [v] with actual type [k] -> [b0] in m'
10:07:28 <edwardk> odd
10:07:53 <int80_h> timthelion: I recieved the error "C compiler cannot create executables". It refers to the config.log for details, and that is rather big.
10:07:58 <edwardk> oh
10:08:12 <edwardk> resolve m l = unsafePartsOf l m' where m' ks = liftM (\kvs -> map (!kvs) ks) (m ks) -- is at least one of the bugs
10:08:23 <edwardk> forgot to apply m to the list of keys!
10:08:26 <timthelion> int80_h: Maybe you're out of luck, I don't know :/
10:08:39 <timthelion> int80_h: leave a comment on the AUR page and wait and see?
10:08:39 <applicative> int80_h: what platform are you using
10:09:34 <applicative> oh its arch
10:09:35 <int80_h> applicative: archlinux.
10:09:35 <ocharles> aside, is liftM == <$> ?
10:09:45 <timthelion> So I use fmap if I have a function (a -> b) that I want to apply to f a.  But what If I have a function (a -> f b) like (\n -> if n > 0 then Right n+1 else Left "OMG") that I want to apply to (Rigth 1) and have the result be (Right 2)?
10:10:10 <timthelion> is >>= what I want?
10:10:32 <edwardk> liftM is <$> but for monads when you don't necessarily know its a functor.
10:10:33 <int80_h> applicative: do you have a recommendation for something else? I'm not tied to arch, I can run a VM.
10:10:38 <edwardk> you could swap to <$> there
10:10:45 <applicative> KBme it occurs to me that maybe everything is okay.  Are you having trouble with cabal install lens pandoc  etc
10:10:52 <edwardk> resolve m l = unsafePartsOf l m' where m' ks = (\kvs -> map (!kvs) ks) <$> m
10:10:57 <ocharles> ah right, even though all monads should be functors, yadada
10:11:30 <ocharles> so that means that (m ks) should produce a list though?
10:11:34 <applicative> int80_h: no, I was just struck by the 'C compiler cannot make executables ' bit, which I get on os x when using a particular configuration of everything
10:11:36 <ocharles> oh wait no
10:11:38 <ocharles> we map over ks
10:12:11 <edwardk> yeah
10:12:28 <edwardk> basically i turn your mapper into a function from [Ref a] -> IO [Entity a]
10:12:36 <edwardk> then we can pass that to our lens
10:12:53 <ocharles> ah
10:13:00 <edwardk> which since we used unsafePartsOf can now take ([Ref a] -> IO [Entity a]) -> a -> IO b
10:13:18 <edwardk> er renaming a appropriately in that ;)
10:13:34 <applicative> int80_h: I wasn't following the preceding bit.  On my old os x laptop I shamelessly over rule it by doing it as superuser despite the fact that it will be installed locally
10:14:14 <int80_h> applicative: yeah I tried installing as root, thinking that was the problem, same error.
10:14:18 <KBme> what's the usual way to upgrade all packages installed by cabal?
10:14:35 <applicative> KBme dont do it
10:14:42 <int80_h> applicative: I'll ask stackoverflow for distor recommendations and install a VM. Beats yak shaving.
10:14:45 <ocharles> edwardk: mmm, still not typing. are you poking around more (ie, should I go grab a drink? :))
10:14:46 <KBme> trying to install xmonad-contrib from darcs and it seems I'm going to have to do a lot of handywork
10:14:47 <int80_h> distro too
10:15:02 <edwardk> one sec. don't leave
10:15:05 <ocharles> sure
10:15:33 <applicative> do ghc-pkg list, copy the second local half , do ghc-pkg unregister foo-x.y.z for each then reinstall with one big command
10:16:22 <applicative> KBme ^^^ like this, somehwere I have halfwit scripts to do it when  I have unpleasantness in ~/.cabal/lib
10:16:23 <monochrom> don't "upgrade". erase and install fresh. see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove . see the whole article
10:16:32 <KBme> ugg
10:16:33 <applicative> like monochrom says
10:16:41 <KBme> thanks
10:17:27 <ozataman> anybody know of an *easy* way to derive MonadTransControl and MonadBaseControl (from monad-control) instances for simple newtype wrappers around ReaderT, StateT, etc?
10:17:45 <KBme> applicative, I also have to remove package versions from the one big install eh?
10:17:46 <applicative> KBme: that page of monochrom s has a lot of good information see also his page about locally installing ghc + haskell platform
10:18:11 <applicative> KBme: yes, you want cabal to be able to reason freely
10:18:23 <edwardk> ok, go get a drink i need to patch up lens to work with ghc head
10:18:38 <ocharles> haha
10:18:38 <KBme> ok thanks
10:18:42 <applicative> KBme: it doesn't really matter, just don't use versions, and don't do cabal update in the middle.
10:18:49 <KBme> yeah
10:18:49 <KBme> ok
10:18:49 <ocharles> edwardk: sorry for derailing your afternoon/evening! :)
10:18:53 <KBme> thanks
10:19:04 <edwardk> np
10:19:18 <dmwit> ozataman: Just follow the types.
10:19:21 <edwardk> just kind of racing to get this in, and to answer a couple other people on other channels/pms =)
10:19:45 <dmwit> ozataman: Unless they're *really* newtype wrappers around an existing thing that has such an instance, in which case, use GeneralizedNewtypeDeriving.
10:20:32 <edwardk> okay, punted everyone else. now let me fix up lens to install on head
10:20:36 <ozataman> dmwit: I don't follow. AS I said, they are newtype wrappers around existing things. GeneralizedNewtypeDeriving fails for MonadTransControl
10:21:52 <dmwit> ozataman: What I remember from when I did it was that I was able to create an instance without understanding anything by just carefully tracking the types of various things and applying/unapplying the newtype wrapper at the appropriate place.
10:22:09 <dmwit> My data family instance (I think there was such a thing?) was also just a simple one-constructor wrapper around the underlying data.
10:22:31 <ozataman> That is of course the typical way you tackle anything in Haskell :-)
10:22:32 <ozataman> right
10:22:43 <ozataman> I wanted to know if there was a way to do it without defining your own instance
10:22:51 <dmwit> I don't think so.
10:22:57 <ozataman> there is some real annoying complexity in monad-control
10:23:20 <ozataman> I don't want to define my own hand crafted instance every time I make a one off newtype wrapper
10:23:22 <ozataman> what a pain
10:24:36 <edwardk> okay, added a temporary --flags=-template-haskell option so i can at least build this thing until i figure out the right incantation to get TH to work correctly the 3 different ways it has been demonstrated to compile under 7.6 =(
10:25:13 <ozataman> dmwit: in any case, thank you for the response
10:25:19 <ozataman> guess I'm out of luck
10:25:28 <tibbe> edwardk: apparently I'm too stupid to use data-reify
10:25:34 <tibbe> why people no include examples
10:25:54 <edwardk> tibbe: check Numeric.AD.Internal.Reverse for an example
10:25:58 <edwardk> in the 'ad' package
10:26:58 <tibbe> my head hurts
10:27:05 <tibbe> so first I need to make a second data type?
10:27:13 <timthelion> tibbe: I share your concern, and also am too afraid that libs without examples are entirely untested :P
10:27:25 <tibbe> timthelion: that's a risk
10:27:43 <edwardk> ocharles: after all that the problem was the kvs were on the wrong side of the !
10:27:58 <edwardk> @hpaste
10:27:58 <lambdabot> Haskell pastebin: http://hpaste.org/
10:28:14 <hpaste> edwardk pasted “for ocharles” at http://hpaste.org/74051
10:28:27 <ocharles> haha
10:28:35 <ocharles> i should have been able to figure that out :$
10:29:01 <tibbe> edwardk: do I have to make recursion in my type explicit via Mu?
10:29:01 <ocharles> lets see then
10:29:18 <edwardk> tibbe: yes and no. you have to make it explicit but you don't have to use something named Mu
10:29:31 <carpi> in the source for the Data.List module, the signature for length is given as "len :: [a] -> Int# -> Int". Could someone please tell me what that '#' means in that context?
10:29:39 <edwardk> or you can manually create a separate base functor
10:29:40 <tibbe> edwardk: I need a lambda calculus example
10:30:06 <ocharles> edwardk: the bit that still confuses me is that this seems like it replaces the exact location of the Ref, not the 'parent' of the Ref
10:30:12 <edwardk> fyi- if you have a GADT you are going to need to duplicate all the code in data-reify you can't use it directly
10:30:13 <nand`> carpi: nothing in particular, it's just another type name; but # is as convention used for GHC internals
10:30:13 <ocharles> or am I making a bad assumption there?
10:30:21 <dmwit> carpi: # is a part of the name of the type; it's typically used in the names of types that are unboxed versions of the non-# type
10:30:23 <monochrom> Int# refers to GHC internal machine int type
10:30:31 <edwardk> ocharles: it does
10:30:45 <edwardk> i didn't bother to understand your old code, just got something like it to typecheck ;)
10:30:57 <tibbe> edwardk: oh the horror. Perhaps I'll just roll my own data-reify
10:31:01 <tibbe> edwardk: for my special case
10:31:11 <tibbe> seems like less work
10:31:21 <ocharles> edwardk: oh right, this is what you meant about 'that can composed elsewhere'
10:31:37 <edwardk> tibbe: yeah
10:31:37 <edwardk> i had my own data-reify like construction before gill wrote his paper. i just switched to his because it was prettier
10:31:46 <carpi> oh .. you mean like internally haskell has different versions of the same types that are available externally?
10:32:02 <monochrom> no, I mean implementation details
10:32:05 <edwardk> ocharles: yeah, you can compose in the look up into the traversal for instance or just compose that outside
10:32:35 <dmwit> carpi: No, Int# is a very different type than Int.
10:32:39 <ocharles> I don't think you can do it in the traversal, but outside seems ok
10:32:56 <carpi> so Int# is not an algebric data type?
10:32:57 <ocharles> the input to the mapper is not necessarily where the result values should be shoved
10:33:00 <monochrom> no
10:33:14 <carpi> okay.. i should read about '#' data types. my questions are silly
10:33:23 <nand`> Int# is treated differently from all other types in the implementation of GHC afaik
10:33:28 <dmwit> Your questions are not silly.
10:33:39 <edwardk> anyways, the key insight is that unsafePartsOf exists and can be used to do any of those 'go get all the things, do something and smash them back in'
10:33:43 <edwardk> style traversals
10:33:45 <ocharles> yea
10:33:57 <carpi> so you mean like ... there is no reason to want to use "int#" in normal haskell code?
10:34:10 <ocharles> edwardk: thanks for sharing your knowledeg!
10:34:11 <ocharles> erm
10:34:13 <carpi> i thought it speedens up the program or something
10:34:13 <ocharles> spelt correctly :)
10:34:18 <monochrom> there is no "'#' data type". but there are GHC primitives. adding # is just a naming convention.
10:34:43 <monochrom> it speeds up, and less portable
10:35:02 <edwardk> if you really wanted to keep the arrow you could do so by just making an arrow->applicative wrapper and passing that through the lens instead of IO
10:35:22 <carpi> ah okay .. im sure there is more to it than I understood. but i've never seen this form before. looks interesting
10:35:53 <monochrom> become a GHC developer. then you will understand
10:36:14 <nand`> where is ‘plusInt’ implemented? Is it a primitive?
10:36:15 <edwardk> going to figure out what got changed in TH on me. there appear to be 3 completely different ways to deal with inlining that i've seen in 7.6 since the release candidate ;)
10:36:16 <dmwit> Being a GHC developer is a sufficient but not necessary condition for understanding.
10:36:50 <carpi> ill be a GHC developer .. ..
10:36:50 <carpi> in a few decades at best
10:37:01 <monochrom> plusInt is a primitive
10:37:36 <applicative> carpi if you define a data type with an Int field, e.g. data D = D Int Int then writing D {-#UNPACK#-} !Int {-#UNPACK#-} !Int does something like putting Int# in those positions, to put it
10:37:44 <applicative> crudely
10:38:59 <applicative> carpi the matter is discussed in some of the tutorials by tibbe
10:40:02 <applicative> carpi eg http://www.slideshare.net/tibbe/highperformance-haskell and various others.  Actually writing #'s in signatures is expert nonsense by comparison.
10:40:48 <carpi> thanks .. but I think i have quite a bit to go before i understnad tibbe or anyone else on this. I'm still banging my head on recursion : )
10:40:58 <dmwit> D Int# Int# is expert nonsense but D {-#UNPACK#-} !Int {-#UNPACK#-} !Int is completely normal behavior?
10:41:15 <monochrom> perhaps you shouldn't be reading Data.List source code
10:41:22 <applicative> dmwit: thats what I was thinking, but maybe it's just that I learned the latter not the former
10:41:41 <carpi> monochrom: i know ... but i was curious )
10:41:49 <dmwit> carpi: I think you should read it if you want.
10:42:09 <applicative> carpi, I wonder if there's an old version of Data.List around somewhere
10:42:12 <dmwit> data Int = I# Int# -- now you know the difference between Int# and Int ;-)
10:42:42 <dmwit> applicative: http://www.haskell.org/onlinereport/list.html
10:43:26 <dmwit> http://www.haskell.org/onlinereport/haskell2010/haskellch20.html#x28-22800020 is probably better
10:43:40 <applicative> carpi, oh yeah dmwits links might be better for looking at
10:43:48 <dmwit> but it doesn't have any code
10:44:00 <monochrom> prioritize your curiosity goals. for some goals, "this is GHC implementation detail" is sufficient for moving on to the real goal
10:44:17 <applicative> dmwit right the second doesnt implement them.
10:44:19 <nand`> some implementation details can be outright misleading
10:44:36 <nand`> especially if you're unfamiliar with the implementation or how it works
10:45:10 <applicative> I think the version of List at the bottom of http://www.haskell.org/onlinereport/list.html is worth carpi's looking at, I don't see the problem.
10:45:26 <monochrom> also, use breadth-first search, not depth-first search, for your curiosity goals
10:46:15 <applicative> ghc's own Data.List will be tailored to its specific list optimization method.
10:46:37 <monochrom> yes, verily, it's why I say "don't read" for most goals
10:46:38 <tibbe> edwardk: is it even possible to convert a GADT to a graph representation?
10:47:40 <tibbe> edwardk: in fact, what would be the type of Var in a GADT?
10:47:47 <tibbe> Var :: Expr e -> Expr e?
10:47:54 <carpi> breadth first learning makes sense otherwise there is a tendency to get discouraged .. exactly what happend the first time i learnt haskel some months ago
10:48:11 <tibbe> edwardk: it ought to retain the type of the expression it replaces no?
10:48:47 <carpi> you guys weren't around this afternoon so ill ask again. This afternoon I wrote a relatively long program that implements the Graham's Scan algorithm. I timed the code on ghci and I got (0.00, 500 kb) and then i timed "3+4" on ghci and i got (0.00, 1.6 mb). can you please tell whats going on?
10:48:53 <timthelion> carpi: aw screw it, Just focus on FRP using the Arrow implementation.  Everything else in haskell is boring.
10:50:28 * timthelion wonders if the FRP people have ever actually written any applications or if they are just ivory tower philosophers who know nothing in reality.
10:50:31 <statusfailed> carpi: how do you time things in GHCI?
10:51:01 <carpi> i just used the ':set +s' flag
10:51:18 <statusfailed> cool :D
10:51:23 <statusfailed> thanks
10:52:02 <statusfailed> I'm not sure what the second item in that tuple is
10:52:26 <rosie> What's a good way to print the inferred type of a value?
10:52:28 <statusfailed> because if you just evalute "1" many times it always ends up being different
10:52:30 <statusfailed> sometimes zero
10:52:43 <Yiq> Is there a blizzard/battlenet/diablo3 freenode channel?
10:52:44 <applicative> rosie, in ghci :t foo
10:53:05 <rosie> applicative: er, in the middle of a haskell file
10:53:10 <statusfailed> ghc-mode?
10:53:13 <applicative> rosie: but do you mean you want something that refers to the Haskell type as a value
10:53:16 <statusfailed> (for rosie)
10:53:24 <statusfailed> or is it "mod"
10:53:31 <rosie> applicative: sorry?
10:53:51 <applicative> rosie: you need to hook up your editor to do something like that, as statusfailed is saying
10:54:00 <statusfailed> rosie: Do you want to just inspect the type by hand, or do you want to use it in your program
10:54:12 <rosie> statusfailed: inspect by hand
10:54:25 <statusfailed> Yeah, then you want something like ghc-mod
10:54:29 <statusfailed> in fact, so do I
10:54:32 <monochrom> there is no way to get the type of an expression that occurs only in the middle of a file
10:54:52 <statusfailed> There's not!? I thought those plugins could do it? :<
10:54:54 <applicative> if you use the debugger you will come to it
10:54:55 <monochrom> err, there are very difficult ways
10:56:13 <applicative> soon we will have Holes in our files, I think this will go together with more  knowledge of these things
10:57:09 <statusfailed> carpi: StackOverflow thinks :set +s is really inaccurate for interpreted programs
10:57:14 <statusfailed> carpi: see here: http://stackoverflow.com/questions/10342217/get-timings-in-ghci
10:58:13 <applicative> rosie if you want to know what should go in a long definition you can just write foo in the relevant position, and then add a where that says foo:: Char; foo = undefined and refine accordingly
10:58:31 <applicative> rosie but I cant tell what you want
10:58:47 <statusfailed> carpi: It also seems to be advising the "Criterion" library: http://hackage.haskell.org/package/criterion
10:59:09 <carpi> statusfailed: thanks ill be lookin into ti
10:59:23 <rosie> applicative: I get "not in scope" when I insert an undefined "foo"
10:59:59 <applicative> you need to write a where clause subordinate to the thing you are defining -- this is in a module right?
11:00:20 <statusfailed> applicative: is the semicolon also necessary?
11:00:25 <statusfailed> or can it be multiple lines
11:01:25 <statusfailed> yes it can :3
11:02:35 <tibbe> Any type hackers around? http://stackoverflow.com/questions/12230088/how-can-i-recover-sharing-in-a-gadt
11:03:33 <edwardk> back
11:03:56 <edwardk> tibbe: you can use observable sharing on a GADT, i've done it before =)
11:03:59 <cocon> Is this the best place to get haskell mode? https://github.com/haskell/haskell-mode
11:04:01 <statusfailed> tibbe: not me, but sweet hat in your SO picture :P
11:04:56 <edwardk> tibbe: the type it has would be the same type it'd have when you represent the ADT without sharing
11:05:45 <monochrom> I think yes, cocon
11:06:29 <tibbe> statusfailed: heh
11:06:40 <rosie> applicative: could you give me an example?
11:06:48 <sm> how do you insert literal HTML content without escaping in HSP ?
11:06:48 <cocon> monochrom: thanks. any idea what version to get?
11:06:56 <tibbe> edwardk: would you mind trying to answer the SO question for everyone's benefit?
11:07:11 <edwardk> which one?
11:07:12 <monochrom> perhaps the latest
11:07:24 <hpaste> applicative pasted “what should foo be?” at http://hpaste.org/74054
11:07:50 <monochrom> chrisdone is here once in a while. perhaps ask him to confirm.
11:07:58 <tibbe> edwardk: http://stackoverflow.com/questions/12230088/how-can-i-recover-sharing-in-a-gadt
11:08:01 <edwardk> this is going to make me package up a copy of my higher rank version of data-reify isn't it? =)
11:08:11 <tibbe> edwardk: maybe :)
11:08:13 <applicative> rosie: the error says that Char isnt a Num type, so we learn that the foo position requires a Num
11:08:21 <tibbe> edwardk: I'm kinda blocked on this for my current project
11:08:41 <edwardk> its fairly straighforward to implement, its just tedious
11:08:45 <sm> answer: the cdata function
11:09:47 <dmwit> "follow the type" appears surprisingly often in my home directory, including a few occurrences in javascript files (!)
11:09:50 <tibbe> edwardk: what I don't understand now (which is probably due to lack of a good understanding of GADTs) is how I can return a Map Name (Ast2 e)
11:10:28 <edwardk> the short version is 'you can't.'
11:10:34 <tibbe> edwardk: because if I later replace a Var by its value, it seems that the static type information was lost by adding it to the Map
11:10:39 <tibbe> edwardk: that's what I thought
11:10:51 <edwardk> you can make an hlist of types that you have ast2's of.
11:10:57 <tibbe> ugh
11:10:58 <edwardk> and you can make them circularly reference each other
11:11:00 <tibbe> no thanks :)
11:11:09 <edwardk> thats what i do in the bottom of that remote dsl i pasted
11:11:31 <tibbe> I think I like to understand what my options are at this point, if the GADT solution is too ugly I might get rid of the GADT in favor of a ADT
11:11:40 <edwardk>  Let :: Vec (Scope (Ix bs) Remote f) bs -> Scope (Ix bs) Remote f a -> Remote f a
11:12:11 <edwardk> i would recommend making the user program with the GADT to get type safety, then dumb it down during sharing analysis
11:12:13 <timthelion> What function takes (==) and [1,2,3,1] and returns [[1,1],[2],[3]]?
11:12:19 <tibbe> I'm afraid I don't quite have enough background to follow
11:12:21 <edwardk> you know it was well-typed
11:12:25 <dmwit> timthelion: groupBy
11:12:31 <dmwit> oh
11:12:32 <dmwit> I misread.
11:12:40 <dmwit> groupBy . sortBy ;-)
11:12:43 <tibbe> edwardk: the user programs using functions that generates values of that GADT, so he/she already has type safety
11:12:45 <timthelion> dmwit: nah, I need a sort in there.  But I was wondering if there isn't one pre built
11:12:53 <edwardk> tibbe: exactly
11:12:59 <timthelion> dmwit: OK OK
11:13:09 <tibbe> edwardk: I could still screw up while performing translations
11:13:21 <edwardk> tibbe: then you can do all the syntax manipulation you want afterwards untyped.
11:13:30 <edwardk> you could
11:13:44 <hpaste> applicative annotated “what should foo be?” with “what should foo be? (annotation)” at http://hpaste.org/74054#a74056
11:13:46 <edwardk> but you can annotate things with their types and add a lint pass
11:13:58 <tibbe> edwardk: my AST include functions, like: data Ast where ConcatMap :: (a -> [b]) -> Ast [a] -> Ast [b]
11:14:00 <edwardk> linting is good enough for the ghc guys ;)
11:14:06 <applicative> rosie here's a more sensible example maybe ^^^
11:14:13 <tibbe> edwardk:  I might do tht
11:14:16 <tibbe> that
11:14:30 <timthelion> > groupBy (==) $ sortBy (\a b-> if a == b then EQ else GT) [1,2,3,1, 1]
11:14:31 <lambdabot>   [[1,1],[3],[2],[1]]
11:14:34 <timthelion> doesn't work :/
11:14:59 <monochrom> (+) and Char?!
11:14:59 <dmwit> > groupBy (==) $ sortBy (\a b-> if a == b then EQ else LT) [1,2,3,1,1]
11:15:00 <lambdabot>   [[1],[2],[3],[1,1]]
11:15:04 <edwardk> the function in concatmap is an honest to goodness function that will be run locally? not some hoas thing?
11:15:05 <dmwit> huh
11:15:10 <statusfailed> isn't that compare function wrong?
11:15:23 <dmwit> Yes, it's pretty wrong. =)
11:15:37 <monochrom> I see, deliberate type errors to demo something
11:15:47 <dmwit> Ah, yes, that is wrong enough to matter.
11:16:00 <statusfailed> > groupBy (==) . sortBy compare $ [1,2,3,1]
11:16:02 <lambdabot>   [[1,1],[2],[3]]
11:16:03 <applicative> > sortBy (\a b-> if a == b then EQ else LT) [1,2,3,1,1]
11:16:05 <lambdabot>   [1,2,3,1,1]
11:16:31 <tibbe> edwardk: it will be run locally
11:16:41 <tibbe> edwardk: on each node
11:16:42 <applicative> > sort [1,2,3,1,3]
11:16:43 <lambdabot>   [1,1,2,3,3]
11:16:46 <edwardk> k, so no ast nodes you need to inspect inside it
11:16:47 <edwardk> yeah
11:16:51 <applicative> > group  $ sort [1,2,3,1,3]
11:16:52 <timthelion> This is a clear bug in sortBy :/
11:16:52 <lambdabot>   [[1,1],[2],[3,3]]
11:16:54 <tibbe> edwardk: right
11:17:07 <tibbe> edwardk: I have an easier time than e.g. accelerate here
11:17:20 <tibbe> edwardk: so you have convinced me to use a plain ADT
11:17:25 <edwardk> sure. my little grid processing dsl has the same problem
11:17:30 <statusfailed> timthelion: eh?
11:17:36 <tibbe> edwardk: no I still need to figure out how to use data-reify :)
11:17:37 <edwardk> build an untyped ADT, and wrap it in a typed one the user programs with
11:17:53 <edwardk> then do sharing on the untyped thing your typed GADT wraps
11:18:01 <tibbe> edwardk: do you really need a typed GADT?
11:18:12 <edwardk> for the end user its nice to have
11:18:16 <tibbe> isn't it enough to have functions like: concatMap :: ...
11:18:24 <edwardk> that works fine as well
11:18:27 <tibbe> right
11:18:32 <edwardk> well
11:18:36 <applicative> (\a b-> if a == b then EQ else LT) -- does't this mean everything is less than everything else?
11:18:42 <edwardk> your concatmap function you dont want it to go from AST -> AST
11:18:44 <edwardk> do you?
11:18:58 <hpaste> rosie pasted “DocValOps” at http://hpaste.org/74057
11:19:04 <tibbe> concatMap :: (a -> b) -> Dist [a] -> Dist [b]
11:19:14 <statusfailed> applicative: Nah, only things that are either less than or greater than
11:19:21 <tibbe> edwardk: the user programs with distributed collections
11:19:26 <edwardk> sure, where Dist is the strongly typed wrapper around the untyped AST
11:19:30 <tibbe> edwardk: conveniently Dist is just the AST
11:19:36 <tibbe> edwardk: today it's a GADT
11:19:37 <rosie> thanks applicative: I'm trying to catch up with you, but I'm having a difficult time figuring out the type that `at` expects. Could you take a look at the hpaste I just posted?
11:19:46 <tibbe> edwardk: but I'm thinking about making it an ADT for the reasons we discussed.
11:19:57 <edwardk> oh, you want it to just make the type arg phantom?
11:20:00 <statusfailed> applicative: I have no problem accepting that 4 < 3, but 3 not > 3
11:20:02 <tibbe> edwardk: I'm not sure what the benefit of having both a GADT and ADT were
11:20:09 <tibbe> edwardk: hmm, oh right
11:20:18 <tibbe> edwardk: so then I might want a GADT
11:20:21 <tibbe> edwardk: or a phantom
11:20:22 <beaky> hello
11:20:23 <edwardk> thats all i was talking about
11:20:25 <edwardk> yes
11:20:26 <tibbe> dunno which one is better
11:20:27 <statusfailed> not <*
11:20:38 <tibbe> equivalent?
11:20:38 <beaky> http://ideone.com/ZL1fx How would you write this Python function in Haskell?
11:21:12 <edwardk> well, depends on how you want to work. th nicest thing for data-reify would be to have an untyped core with a typed wrapper that can just be phantom
11:21:34 <applicative> rosie it says further down that it's supposed to be a FieldName,  which is wrappedsomehow by Identity
11:21:39 <t7> beaky: foreach pixel -> test function
11:21:52 <edwardk> let me cobble together a sketch
11:22:22 <tibbe> edwardk: thanks
11:22:39 <tibbe> @tell edwardk this is what I have
11:22:40 <lambdabot> Consider it noted.
11:22:46 <tibbe> @msg this is what I have
11:22:46 <lambdabot> Not enough privileges
11:22:49 <t7> oh wait you need to parse expression
11:23:09 <rosie> applicative: What about the second parameter, "d"? And what should the "d" and "v" for DocValOps be?
11:23:11 <tibbe> argh!
11:23:31 <Zariel> Oh, parsec state does excatly what i wanted, awesome!
11:23:58 <carter> edwardk tibbe : really enjoying this saturday afternoon chat
11:23:59 <carter> :)
11:24:09 <tibbe> carter: :)
11:25:01 <carter> tibbe: whens your next NYC visit out of curiosity?
11:25:55 <carter> anyways, back to the labor day weekend salt mines for me
11:26:24 <rosie> Where should I install the Haskell mode directory for emacs?
11:29:07 <tibbe> carter: not sure, hopefully this year
11:29:19 <tibbe> rosie: you mean where to download it?
11:29:48 <rosie> I git clone and get a directory. Where do I put it to make sure emacs will recognize it? In a emacs load-path directory?
11:29:49 <carter> tibbe: cool! if its mid oct or later, I can hopefully give yah a demo of the cool stuff i'm (slowly) working on
11:30:02 <tibbe> carter: cool
11:30:13 <tibbe> carter: can't promise anything but I'll let you know if I'm around
11:30:16 <carter> np
11:30:46 <carter> tibbe: i'll be very loud on the internet / having a few examples online of the nifty stuff once I hit alpha
11:30:50 <carter> so no pressue
11:31:06 <timthelion> carter: what are you working on?
11:31:41 <rosie> do I need to make sure emacs will load the Haskell mode file on startup?
11:31:52 <tibbe> carter: cool
11:32:09 <timthelion> rosie: why not ask in #emacs?  They can surely help you.
11:32:20 <rosie> timthelion: ah! sorry
11:32:43 * timthelion hasn't used emacs in a couple years...
11:32:49 <carter> timthelion assassinating Matlab & scipy etc with better tools, while also making sure I can support myself and hopefully a few others working on it full time
11:33:07 <timthelion> carter: a GUI app?
11:33:10 <carter> NO
11:33:16 <carter> :)
11:33:25 <timthelion> cli matlab?
11:33:30 <carter> NO
11:33:31 <carter> Haskel
11:33:33 <carter> l
11:33:35 <carter> :)
11:33:36 <carter> tools
11:33:44 <carter> libraries
11:33:44 <carter> etc
11:33:59 <aristid> that will surely assassinate matlab.
11:34:21 <timthelion> I see
11:34:31 * timthelion is working on a GUI revolution for Haskell :)
11:34:38 <carter> timthelion oh?
11:34:50 <carter> what sort of gui vs ghc-live?
11:35:14 <thetallguy> Wasn't there an Endo functor class around somewhere?
11:35:15 <carter> aristid timthelion : i've actually got some potential enterprise customers lined up
11:35:18 <timthelion> Well I've found out a way to make a new kind of networked state using STM...
11:35:37 <thetallguy> did it get replaced with type equality constraints?
11:35:54 <timthelion> carter: cool
11:35:59 <carter> and then assuming they like the alpha and give me a check
11:36:08 <timthelion> carter: and will it be opensource for us poor folk?
11:36:30 <carter> timthelion: it'll be a 20 dollar distro for students / noncommerical / hbbyists
11:36:37 <aristid> carter: cool. i just don't think you will kill matlab.
11:36:45 <carter> aristid: i don't care
11:36:48 <carter> :)
11:36:55 <aristid> good
11:36:59 <carter> if I can support myself and a few other folks
11:37:02 <carter> attacking hard problems
11:37:08 <carter> and helping smart people better solve their problems
11:37:19 <carter> i'm winnning
11:38:04 <carter> most people use matlab in a million monkeys sort of way
11:39:25 <carter> but yea
11:39:44 <carter> it looks like barring head injury or the liike
11:39:50 <carter> i'll get things into shape mid fall
11:40:29 <carter> and one way or another, whether its commercially viable or not, i'll want to make things accessible for people who aren't writting enterprise checks
11:40:30 <carter> :)
11:40:34 <carter> business is hard
11:40:55 <Zariel> How do I use a String inplace if my data type, i have: data someType = <constructors> | String, but i cant do return (string) in a function returning someType
11:41:08 <carter> thats why i'm procrastinating / taking breaks by trying to do numerical analysis formalization in agda / idris :)
11:42:04 <geekosaur> Zariel, it doesn;t work that way
11:42:19 <geekosaur> String there is a 0-argument constructor, not a String type
11:42:42 <geekosaur> data someType = ... | Str String
11:42:42 <srhb> Zariel: If the last bit was String String, you could.
11:42:44 <nand`> sum types are tagged, you have to name the option
11:42:49 <nand`> like | Str String yeah
11:43:01 <geekosaur> (and return may not be doing what you think it does...)
11:46:19 <t7> System-F vs HM
11:46:33 <t7> im not sure which i prefer
11:47:16 * ddarius needs to do a little bit of math to rederive rank-1 Cholesky update and then I should have a, probably broken, square root scaled unscented Kalman filter.
11:47:30 <monochrom> if you want users to handwrite types everywhere, System-F. if not, HM.
11:48:06 <t7> but in HM you cant have  \(x : forall a. a -> a) -> ...
11:48:20 <monochrom> that is also right
11:48:50 <t7> in reality people tend to write down most of the types anyway
11:49:16 <monochrom> they don't want to
11:49:23 <dolio> It really depends what you mean by that.
11:49:30 <t7> you can infer the types when apply to a function with a known type (?)
11:49:41 <ddarius> People certainly don't annotate every lambda and local binding.
11:49:51 <monochrom> half of those who started with c++ and ended with python are because they don't want to handwrite types, not because they want no types
11:49:55 <ddarius> Not even C# people do that.
11:50:19 <dolio> They also don't manually instantiate all things with polymorphic types.
11:50:34 <dolio> Which is one of the big problems with Scala, there are too many cases where it can't figure that out.
11:50:39 <t7> dolio: you can do some type inference in system f
11:50:57 <t7> yeah but i think scalas issue is more todo with sub-typing
11:51:04 <dolio> Yes.
11:51:46 <dolio> I'm just saying, it's easy to realize how many annotations you're eliding until you start working in a system where you can't.
11:51:54 <dolio> Easy to not realize, even.
11:52:07 <ddarius> A similar thing happens with laziness.
11:53:08 * ddarius thinks he saw (and downloaded?) a paper on formally verifying (basic) Kalman filter code.
11:53:11 * ddarius should read that.
11:53:27 <dolio> Yeah, that's another problem with Scala.
11:53:36 <dolio> You have to annotate all your laziness.
11:54:00 <dolio> And then people forget all the time, so there are tons of functions that are too strict to be useful.
11:54:13 <dolio> Or, useful for some applications.
11:56:24 * hackagebot splice 0.6.1.1 - Cross-platform Socket to Socket Data Splicing  http://hackage.haskell.org/package/splice-0.6.1.1 (CetinSert)
11:58:48 <hpaste> edwardk pasted “for tibbe (part 1)” at http://hpaste.org/74058
11:59:32 <carter> tibbe edwardk : what was the original source example?
12:00:16 <edwardk> that without the MuRef stuff? =)
12:00:16 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
12:00:44 <carter> edwardk yeah
12:00:54 <carter> edwardk so I can apprecaite the difference :)
12:01:01 <edwardk> i don't have it
12:02:24 <carter> ok
12:03:00 <rosie> does anyone use haskell mode in emacs? Do I just put the haskell-mode.el file in an emacs load-path?
12:03:31 <t7> apt-get install haskell-mode worked for me
12:03:42 <t7> it didnt change my .emacs
12:03:58 <t7> but im a vim user i duno wtf emacs is doing
12:04:36 <geekosaur> added it to the shared site-lisp config, probably
12:04:57 <geekosaur> whether other distributions' packages do so is up to the distribution; debian's usually pretty good about such things
12:09:29 <chrisdone> @seen ski
12:09:29 <lambdabot> Unknown command, try @list
12:09:38 <chrisdone> !seen preflex
12:09:38 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
12:09:46 <chrisdone> WHERE'S SKI?
12:10:25 <parcs`> where's preflex?
12:12:04 <Zariel> geekosaur: Hm thanks, the return is the monad return which is returing GenParser Char Char String, ill look into my typing heierachy ..
12:12:50 <chrisdone> hpc: i was doing some updates on it. now it sits idle at 13mb mem usage instead of 150mb
12:18:39 <edwardk> @hpaste
12:18:39 <lambdabot> Haskell pastebin: http://hpaste.org/
12:18:50 <hpaste> edwardk pasted “for tibbe (part 2)” at http://hpaste.org/74062
12:19:11 <edwardk> tibbe: that typechecks at least
12:19:38 <edwardk> i think i flipped the partition
12:20:06 <edwardk> yep, i did
12:20:26 <hpaste> edwardk annotated “for tibbe (part 2)” with “for tibbe (part 2) (annotation)” at http://hpaste.org/74062#a74064
12:26:00 <ocharles> what is (| |) syntax, that seems to be provided by -XArrows?
12:26:17 <carter> ocharles i think thats the applicative notation?
12:26:25 * hackagebot quicklz 1.5.0.11 - QuickLZ compression for ByteStrings  http://hackage.haskell.org/package/quicklz-1.5.0.11 (AustinSeipp)
12:27:07 <ocharles> carter: it does look like idiom brackets, or whatever it was called
12:27:14 <carter> yes, thats what i mean
12:27:44 <edwardk> ocharles: that looks more like idiom brackets
12:27:45 * nejucomo just discovered System.Timeout.
12:27:49 <nejucomo> My mind is slightly blown.
12:28:08 <nejucomo> I don't understand what happens when a timeout triggers.
12:28:09 <edwardk> nejucomo: how so?
12:28:26 <edwardk> basically it gets an exception thrown at it
12:28:38 <nejucomo> For example, I wrote some tests that did: timeout n (putStrLn "foo")
12:28:44 <ocharles> I wish haskell had a way to have 'implied' brackets based on indentation
12:28:47 <nejucomo> In some cases I saw foo printed and Nothing returned.
12:28:49 <startling> ocharles: uh
12:29:01 <ocharles> startling: let me finish :)
12:29:01 <startling> ocharles, what do you mean by "brackets"?
12:29:14 <startling> nejucomo, the Nothings were when it timed out
12:29:17 <ocharles> i'll paste an example
12:29:18 <nejucomo> edwardk: Well, I don't understand async exceptions well, so it sounds like thats where I should focus.
12:29:20 <carter> ocharles: it already has normal brackets inplied
12:29:27 <edwardk> nejucomo: well, it might have finished printing, but not finished returning
12:29:32 <ocharles> i didnt' quite explain myself well
12:29:42 <Reko> I'm using an ADT as an 'enum'. A|B|C etc. How can I decode to it using cereal?
12:29:47 <ddarius> ocharles wants to use layout for parameters.
12:29:52 <nejucomo> startling: Ok, so in general, it is impossible to tell which mutations/IO have occured when using timeout.
12:30:00 <startling> nejucomo: sure
12:30:23 <nejucomo> Ok, without understanding async exceptions and IO carefully, my read world use case is: timeout n (readChan c)
12:30:44 <nejucomo> Is it *ever* possible to deque an item from c, then hit the timeout retuning None, thereby losing the item?
12:30:57 <ocharles> ddarius: yea, i think you understand what I mean
12:30:58 <edwardk> yes
12:31:26 <nejucomo> edwardk: Was that yes to my question?
12:31:31 <edwardk> yes
12:31:35 <nejucomo> ok.
12:31:36 <nejucomo> Hrm.
12:32:11 <nejucomo> I can imagine a multithreaded single consumer queue that handles timeouts without losing items...
12:32:27 <nejucomo> -although my multi-threaded skills are not advanced, especially in haskell.
12:32:30 <ocharles> https://gist.github.com/3584582 something like that...
12:32:36 <nejucomo> Does such a library exist?
12:33:38 <carter> ocharles: thats called use $ :)
12:34:32 <ocharles> carter: i'm actually composing arrows, so $ won't help
12:34:39 <ddarius> nejucomo: If you mean "does the right thing even when asynchronous killed" then you'd have to use ACID-style techniques.  If the timeout functionality is incorporated into the queue, then it's straightforward.d
12:34:50 <carter> ocharles, but is there a $ for arrows?
12:35:02 <carter> it thought there is
12:35:05 <carter> I
12:35:43 <nejucomo> Hm.  Maybe life would be simpler if I just say "messages aren't guaranteed to be delivered."
12:36:00 <ocharles> I've made my own various operators with really really low fixity, but it still doesn't help if I want to 'nest' a larger computation, I don't think
12:36:09 <nejucomo> ddarius: Are you aware of a library that implements this?
12:36:45 <nejucomo> I guess I can write an attempt, though I'm wary of deadlock or other concurrency bugs that are notoriously difficult to test/detect/fix.
12:37:44 <Zariel> programming in haskell makes me actually happy
12:37:53 <nejucomo> Zariel: Me too.  ;-)
12:38:00 <tromp_> me three
12:38:02 <tylerkahn> Has anyone solved this? https://www.interviewstreet.com/challenges/dashboard/#problem/4edb8abd7cacd I can't get more than 7/10 test cases without timing out
12:38:12 <tylerkahn> (using Haskell)
12:38:29 <tromp_> although right now i'm programming in BLC
12:38:31 <dispy> hi. IS there a function like show that a) does not output directly but returns a string and b) does not escape its contents?
12:38:34 <nejucomo> Oh wait a minute...  instead of changing my message delivery guarantees, finding a library, or implementing a concurrent data structure...
12:39:16 <nejucomo> -I can just have a hacky timeout-sometime-later approach by changing the Chan element type to allow a "timeout" entry...
12:39:25 <startling> nejucomo, maybe you could do this with stm?
12:39:43 <ddarius> dispy: id
12:40:03 <nejucomo> startling: Quite possible.
12:40:18 * nejucomo rereads the STM module's intro docs.
12:40:58 <startling> nejucomo: here, I found this random gist: https://gist.github.com/2762191
12:40:58 <ddarius> Yes, STM would be ACID-style techniques.
12:42:40 <dispy> thanks ddarius
12:43:03 <dispy> why isn't (++) available in ghci?
12:43:09 <plat0> If anyone would like to comment on my new "monad tutorial" I would be pleased: "What is a Monad, really? -- (A tutorial for experts)"  http://web.jaguarpaw.co.uk/~tom/blog/2012/09/02/what-is-a-monad-really-2.html
12:43:22 <startling> dispy: it is
12:43:36 <startling> plat0: "a burrito"
12:43:45 <Ralith> more of a fajita, really
12:43:57 <dispy> startling: for me, it isn't. The regular shell displays "+", ghci does not
12:43:57 <typoclass> dispy: paste the code that you tried, and the error message you got
12:44:13 <dispy> typoclass: he simply does not accept + if I type it in ghci. he does not accept it as an input
12:44:22 <startling> ah yes, the little cast iron pan and tortillas on the side really add to the metaphor
12:44:23 <timthelion> Ralith: an enchelata
12:44:26 <gertc> data.map vs data.set? why do both exist?
12:44:37 <dispy> ok but if I copypaste it, I can write it. ;D
12:44:43 <plat0> startling: turns out it's not a burrito :)
12:44:44 <startling> gertc: because maps have keys
12:44:56 <dispy> maps represent relations, sets do not
12:44:57 <Ralith> timthelion: nonsense, the cheese completely ruins the metaphor!
12:45:49 <startling> plat0: oh, you meant "really". ;)
12:46:20 <timthelion> plat0: I approve of the fact that you first say that it is a typeclass.  This is correct.
12:46:22 <startling> gertc: you can derive sets from maps easily, sure, but why would you want to?
12:46:34 <tylerkahn> here's my best attempt at the solution for reference http://hpaste.org/74066
12:47:24 <gertc> startling, just reading http://learnyouahaskell.com/modules#data-set and it was not clear that sets do not have a key vallue
12:49:39 <typoclass> tylerkahn: is the paste complete? where does commonPrefixed come from?
12:49:54 <startling> gertc: ah, sorry. yeah, sets are just "is this thing in this container?", maps are "what's at this key in this container?"
12:49:57 <tylerkahn> typoclass it's actually a built in function in Data.Text
12:50:08 <typoclass> tylerkahn: i see, thanks
12:50:10 <tylerkahn> np
12:52:40 <nejucomo> startling: Thanks for the gist.  I'm chomping through STM api docs now.
12:52:53 <gertc> startling, thx
12:55:17 <typoclass> tylerkahn: gtg now, but i looked at it briefly and the code looks good and clear to me :-/ not sure why there's a failure
12:55:33 <nejucomo> startling: I don't understand what advantage that has over System.Timeout.timeout.
12:55:34 <tylerkahn> typoclass: thanks! yeah idk it's weird
12:55:42 <tylerkahn> it's just timing out
12:55:58 <tylerkahn> it produces the correct answers
12:56:31 <ddarius> plat0: Using a more traditional CT notation, you are saying K(a,b) ~ Set(a, K(1,b)).  Of course, this would be saying a is in Set and K, so we actually need a conversion, call it I : Set -> K.  We now have K(I(a),b) ~ Set(a, K(1,b)) or I -| K(1, -)
12:56:39 <startling> nejucomo, if you use stm and time out, the change will be rolled back
12:56:58 <startling> nejucomo: alternatively (and more accurately), you could say the change never gets committed
12:57:27 <nejucomo> How is that true if killThread interrupts action *after* it produces a result but before atomically is evaluated?
12:58:06 <startling> no idea, didn't really look at the gist
12:58:16 <nejucomo> Basically, STM doesn't help make action safer at all.
12:59:00 <nejucomo> I guess it is similar to an MVar except it has a safe timeout, where if a value is every inserted, timeouts will never drop that value.
12:59:10 <nejucomo> Ok, that's starting to make sense.
13:01:00 * nejucomo wonders if there could be a more general stm timeout: Int -> Stm a -> Stm a  ?
13:01:02 <ddarius> Yes, you attempt to write the value into a variable before the time-out in one thread, then a separate thread reads it after it return normally or exceptionally.
13:01:57 <nejucomo> So the difference from: timeout n (readMVar m)
13:02:00 <geekosaur> Zariel, in that case it's probably okay.  you still need to have tags on that type though, a bare String is in fact unrelated to Strings
13:02:16 <plat0> ddarius: I believe it is saying that K is a Hask-enriched category with coproductt
13:02:26 <nejucomo> -is that the latter may alter the MVar state so that an item is no longer present, and then hit the timeout, then return Nothing, even though an item has been lost.
13:03:18 <nejucomo> Anyway, for now I'm just going to stick scheduled events into the Chan along with other items...  if the queue is very full this will behave horribly.
13:03:32 <nejucomo> And then I'll come back and learn about STM more carefully.  :-/
13:04:19 <nejucomo> Onto another type system question that's been nagging me:
13:05:00 <nejucomo> Is it possible to express a polymorphic function which ordinarily has type: a -> b -> c   -except if a and b are the same type, then c is also that type?
13:05:07 <ddarius> If you are wary of concurrency bugs, you should be using STM.  STM makes it much easier to write correct concurrent code (though it is still possible to have concurrency bugs.)
13:06:52 <plat0> ddarius: Ah right, so what you've done is recovered the adjunction between Set and the Kleisli category of m.  Nice.
13:06:59 <startling> nejucomo: well, in certain cases a -> b -> c covers a -> a -> a. for example, id :: (a -> b -> c) -> a -> b -> c
13:08:02 <nejucomo> startling: I want to express a type which is "takes an a value and a b value and produces an arbitrary c value *unless* a and b are the same type, in which case c must be that type"
13:08:06 <ddarius> plat0: 1 does not generally exist.
13:09:52 <startling> nejucomo: I don't think you can do that
13:10:42 <startling> (in general)
13:11:37 <plat0> ddarius: In K(1,-), 1 just means I(1) doesn't it?
13:11:46 <nejucomo> I asked because I was trying to imagine a "dimensional metric" framework where you can, say, add velocities, or add lengths, or multiple/divide by times, etc... but you could not add a length to a time, or otherwise violate the dimensional analysis.
13:11:53 <nejucomo> -and I wanted static type checking.
13:12:28 <geekosaur> there's a "dimensional" package on hackage
13:13:41 <timthelion> nejucomo: this article solves that problem: https://en.wikibooks.org/wiki/Haskell/GADT
13:14:16 <startling> nejucomo, you could have a separate type for each, of course, each satisfying Monoid
13:14:21 <ddarius> plat0: It actually doesn't really matter what 1 is for this purpose, we could use any object.
13:15:39 <ddarius> Also, the functor I would need certain properties to get back what you had, e.g. being surjective on objects.
13:16:49 <nejucomo> timthelion: Thanks!
13:18:19 <mrlemao1> hello! How do I declare a 'data instance Event MyId … '  (for a data family Event id …') to be an instance of Binary? instance Binary (Event OrderId) causes a compilation error
13:19:41 <mrlemao1> and instance Binary (Event a) seems a bit off since that is the same as the data family declaration and not specific to my data instance
13:19:41 <startling> mrlemao1: do you have it in general for all Event a?
13:19:44 <Zariel> geekosaur: Im going to use Either instead, much clearer at least
13:20:00 <Zariel> Is it "bad form" to custom implement Either to be more clear your domain?
13:20:00 <startling> mrlemao1: otherwise, you can use {-# Language FlexibleInstances #-}, I think
13:20:07 <nejucomo> Neat.  I didn't realize phantom types were possible.
13:20:36 <geekosaur> it's actually good form
13:20:41 <mrlemao1> startling: the idea is that I have one data family for Event a and multiple diff modules can implement their own data instance with their own Binary serialization
13:21:00 <geekosaur> Either is convenient in the sense that it has some predefined tools, but a custom type is generally clearer
13:21:17 * ddarius suspects that the compiler gave some indication of what was wrong...
13:22:37 <ddarius> geekosaur: You could make an isomorphism with Either to get back some of the tools.  asEither :: MyType a b -> (Either a b -> Either c d) -> MyType c d
13:23:08 <mmakowski_> Hi, is this a good place to seek help with debugging cabal install failures?
13:23:09 <startling> geekosaur: you can maybe get some stuff with bifunctor, too
13:23:24 <tylerkahn> mmakowski_ yep
13:25:19 <hpaste> mmakowski pasted “cabal-install failure” at http://hpaste.org/74067
13:26:01 <mmakowski_> right, so my cabal install output is at http://hpaste.org/74067
13:26:10 <mmakowski_> and I fail to see any helpful error message in it
13:26:26 <mmakowski_> where should I be looking next?
13:26:44 <aleksandar> hello
13:27:07 <aleksandar> My friend has just strated programming
13:27:19 <aleksandar> and I am not sure if I should tell him to learn haskell
13:27:24 <aleksandar> first?
13:27:47 <statusfailed> aleksandar: do iiiiit :D
13:28:04 <raichoo> aleksandar: I think it's a great language to start. Show him learnyouahaskell.com
13:28:15 <statusfailed> Yes! learn you a haskell is perfect
13:28:24 <aleksandar> The problem is that he uses windows and I am not sure if he can handle console
13:28:25 <shurikas> that's a nice experiment
13:28:31 <aleksandar> maybe f# because of visual studio
13:28:32 <shurikas> having haskell as first language
13:28:41 <geekosaur> winghci?
13:28:42 <shurikas> aleksandar, eclipseFP is pretty good
13:28:46 <shurikas> I love it
13:29:04 <statusfailed> shurikas: I was actually wondering earlier what it would be like to have Haskell as my first programming language
13:29:11 <statusfailed> probably the result would be that I wouldn't know any others
13:29:26 <aleksandar> You would be looked like alien :D
13:29:38 <aleksandar> looked at*
13:29:48 <shurikas> and wont understand anything
13:30:05 <shurikas> as haskell is like 0.001% of what's happening in programming
13:30:32 <shurikas> I remember learning OOP after procedural (pascal) and it was quite tricky!
13:30:41 <shurikas> but nothing like learning a haskell
13:30:45 <aleksandar> Why do you say that? You can do any kind of stuff in haskell from networking to GUIs and maths...
13:31:04 <statusfailed> aleksandar: sure, but I think he's right in saying you wouldn't grok OOP
13:31:07 <shurikas> indeed. but not many people do that
13:31:37 <aleksandar> OOP is the biggest factor against understading haskell IMO
13:31:59 <shurikas> I think idea of having popular language for work and haskell for hobby is better than being expert in haskell and not knowing any other language
13:32:15 <aleksandar> Yes @shurikas
13:32:22 <statusfailed> I'd much rather work in Haskell
13:32:27 <statusfailed> but it's definitely good to know other languages
13:32:30 <shurikas> statusfailed, me too!!
13:32:38 <shurikas> I'd work for food
13:32:40 <shurikas> and shelter
13:32:40 <statusfailed> haha
13:32:48 <sheldonh> yeah, go back to the beginning. SICP: http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
13:32:49 <ryant5000> well, i'll take this as an opportunity to chime in: i've got a couple open positions if you're in the new york city area :)
13:32:57 <shurikas> but I have to write stupid java for lots of money instead :(
13:32:58 <ddarius> It's good to know many languages regardless.
13:33:03 <ryant5000> 6-month consulting gig, mostly in haskell
13:33:07 <aleksandar> You are lucky
13:33:11 <aleksandar> I have to write java
13:33:12 <statusfailed> ryant5000: I'm moving to Thailand for 3 months to work on personal projects, but after that, fuck yeah
13:33:15 <aleksandar> for small money
13:33:18 <ddarius> shurikas: Want to write much less stupid C# for lots of money?
13:33:25 <shurikas> ddarius, I do!
13:33:31 <aleksandar> @ddarius I would like :D
13:33:31 <lambdabot> Unknown command, try @list
13:33:32 <shurikas> I prefer C# over Java actually
13:33:32 <ryant5000> statusfailed: send me your resume :) ryan@skedge.me
13:33:35 <sheldonh> ddarius: it's not that much less stupid ;)
13:33:45 <aleksandar> F#?
13:33:50 <ddarius> sheldonh: Yes it is actually.
13:34:02 <shurikas> C# supports some nice features
13:34:07 <shurikas> Java doesn't
13:34:15 <statusfailed> ryant5000: awesome, will do. Need to dig that thing out and update it though :D
13:34:26 <ryant5000> shurikas: haha, surely java supports *some* nice features :P
13:34:32 <aleksandar> enums?
13:34:35 <shurikas> :DD
13:34:48 <aleksandar> WTF I am doing.Defendig java :|
13:34:56 <statusfailed> aleksandar: hahahah
13:35:20 <sheldonh> shurikas. ddarius: C# is even further down the wrong road than java, is what i'm suggesting. i'm not disputing that it's "more"
13:35:22 <shurikas> ddarius, so was that an offer or just a suggestion to switch to another popular lang?
13:36:18 <ddarius> shurikas: It was somewhat of an offer, but it is much more difficult if you are not a US citizen.
13:36:28 <shurikas> oh, ok :)
13:36:34 <aleksandar> Listen.
13:36:39 <timthelion> C# + WPF is the nicest language for writting GUI applications currently in existance!
13:36:48 <aleksandar> QML?
13:36:53 <statusfailed> I dunno, I feel like C# has a bunch of features that make it nicer to use than Java
13:37:13 <aleksandar> C# is newer.
13:37:16 <statusfailed> like lambda expressions and extension methods
13:37:34 <aleksandar> java 8 will finnaly get lambdas - that was quick from them
13:37:47 <ddarius> C# 1.0 = Java *.*, but even C# 2.0 was much better and 4.0 has a lot of nice things.
13:37:56 <timthelion> aleksandar: it'll still be owned by Oracle though :P :D
13:38:08 <statusfailed> ddarius: and when you get sick of it, you can always write F# :D
13:38:14 <aleksandar> There are some good things from them like Virtual Box
13:38:30 <statusfailed> aleksandar: I think they bought that
13:38:32 <aleksandar> @statusfailed or Visual Basic :D
13:38:32 <lambdabot> Unknown command, try @list
13:38:36 <timthelion> aleksandar: yes, but they are not a good buisness partner to have!
13:38:39 <statusfailed> hnnnnnng
13:38:40 <ddarius> statusfailed: My experience is that in many ways F# is worse than C# (though it is certainly better in some.)
13:39:06 <aleksandar> I am not much into bussiness :)
13:39:14 <ddarius> But both are evolving quite fast which is the real nice thing about the .NET languages as compared to Java.
13:39:20 <shurikas> ddarius, why does something you offer require US citizenship? government work? :P
13:39:51 <statusfailed> ddarius: I've only used it for parsing some XML, and Either came in really handy- in which cases don't you like it?
13:40:19 <shurikas> I wrote Game Of Life simulation using SVG with F#
13:40:23 <shurikas> and find F# pretty sucky language
13:40:42 <shurikas> it's like ugly brother of C#
13:40:55 <aleksandar> Based on my limited F# experience I can say that is way too OO for functional
13:41:16 <shurikas> I appreciate their attempt to make a FP language, but just can't really enjoy it... :) it's just not pure!
13:41:26 <statusfailed> Yeah, it's definitely not Haskell ...
13:41:31 <shurikas> aleksandar, indeed. multi-paradigm thingie ruined F#
13:41:58 <timthelion> aleksandar: it's rather hard to integrate into .NET without being exceptionally OO. eh
13:42:10 <shurikas> but again it's probably impossible to make a purely functional .NET language as you want to support all the .NET libs and CLR
13:42:11 <hiptobecubic> I still have the feeling that scala is going to the language that makes it
13:42:12 <sheldonh> i think multi-paradigm is the future. the problem is, the industry isn't ready for it. we lack the discipline required to wield multi-paradigm appropriately
13:42:25 <jmcarthur> i think multi-paradigm is a silly idea
13:42:26 <ddarius> statusfailed: It generally tends to be less well supported, it's lambda syntax is much worse than C#'s, it was missing some things that C# had (e.g. LINQ expressions) though it had stuff C# didn't.  It's missing many things from O'Caml that would make it significantly better than C#, so at best, it's only marginally better than C#.  Not usually enough to "switch".
13:42:28 <startling> it's too bad so much effort was expended on OO
13:42:34 <jmcarthur> what is multi-paradigm?
13:42:35 <startling> hiptobecubic: shhh, don't mention scala here
13:42:47 <jmcarthur> what is a paradigm, for that matter?
13:42:52 <sheldonh> jmcarthur: lisp :)
13:43:03 <monochrom> oh no, no this again
13:43:06 <merijn> Haskell is multi paradigm too for that matter
13:43:08 <jmcarthur> i think of lisp as a syntax
13:43:09 <sheldonh> *baddadush*
13:43:10 <shurikas> :D
13:43:15 <aleksandar> ((()))
13:43:20 <ddarius> shurikas: One of our main clients, who is ardently looking for people, does defense work.
13:43:39 <merijn> We have a perfect EDSL for programming imperative IO, seems multi-paradigm to me...
13:43:51 <statusfailed> ddarius: Yeah, I can agree on those... I had a lot of issues getting it to cooperate with my C#.
13:43:52 <monochrom> I know. multi-paradigm means support of sum types :)
13:43:53 <merijn> (Not to mention Chan's and forkIO for CSP/Actor stuff)
13:44:07 <aleksandar> @ddarius Can you explicitelly request a citizen from another country?
13:44:07 <lambdabot> Unknown command, try @list
13:44:32 <shurikas> well, that's a shame :)
13:44:33 <jmcarthur> but these things don't require special language features. only primitives
13:44:42 <sheldonh> merijn: in most of the conversations i've had, when people talk about multi-paradigm, they're talking about multiple approaches. e.g. OOP & FP
13:44:50 <shurikas> I'd gladly live in US for a while
13:44:54 <merijn> jmcarthur: Most people would consider primitives to be language features...
13:45:00 <jmcarthur> FFI?
13:45:08 <sheldonh> shurikas: jesus, where are you from that the usa seems attractive to you right now? :)
13:45:29 <squidz> is it better to handle maybe cases early on or to pass them around
13:45:29 <merijn> sheldonh: Yes, how are imperative and CSP not considereed approaches
13:45:34 <merijn> sheldonh: ?
13:45:40 <monochrom> depends
13:45:43 <shurikas> :D what do you mean by "right now" ? I don't follow current situation out there. But natively from Lithuania, right now living in Denmark
13:46:01 <sheldonh> merijn: i think of object oriented programming as a subset of imperative
13:46:05 <aleksandar> What's the problem in USA?
13:46:07 <merijn> sheldonh: heh
13:46:23 <merijn> OOP is a superset of imperative, isn't it?
13:46:27 <startling> shurikas: job market is kind of pants
13:46:40 <sheldonh> merijn: *shrug* don't think so, no :)
13:46:42 <startling> well, maybe not for software folks
13:46:43 <shurikas> and yet people are offering jobs on IRC to complete strangers :)
13:46:44 <gentleben> startling: not for high end developers
13:46:57 <merijn> startling: Not for good developers :p
13:47:06 <merijn> The job market is always good for good developers :p
13:47:07 <sheldonh> merijn: when you write a 2,000 line bash script, without using objects... that's imperative, right? :)
13:47:09 <gentleben> my linkedin is always full of recruiters
13:47:11 <shurikas> define a good developer
13:47:15 <ddarius> aleksandar: It's probably possible, but, as mentioned, for this particular client, it would drastically reduce the chances of being hired to near zero.  Also, in general, I'm not sure how well our company could handle employees located in different countries, so practically speaking, you'd probably at least have to move to America.
13:47:21 <merijn> shurikas: That's trickier :p
13:47:37 <shurikas> merijn, I am just wondering where should I place myself
13:47:41 <timthelion> sheldonh: I recently saw a thing on Facebook, in the Slovak language(posted by my cousin)  Slovakia:Butter €1.15 minimum wage €325(per month) average wage €750.  Germany: Butter: €0.75 Minimum wage: €1262 Average €3350
13:47:45 <startling> shurikas: someone who can easily get a job !
13:47:50 <shurikas> hah :D
13:47:53 <timthelion> sheldonh: so people in slovakia would certainly wish to.
13:48:04 <merijn> shurikas: If you're in here and understand 40% of the conversation you'd probably at least two sigmas right of average
13:48:11 <aleksandar> @ddarius I was thinking about my cousin who moved to australia after being requested by some company there
13:48:11 <lambdabot> Unknown command, try @list
13:48:12 <merijn> s/you'd/you're
13:48:25 <gentleben> shurikas: here in silicon valley its anyone who know mongoDB and RoR, or has worked at google. THey don't make hiring mistakes
13:48:50 <sheldonh> timthelion: do you happen to know the unemployment and incarceration rates in slovakia? :)
13:48:52 <merijn> RoR is almost as much of a red flag as node.js >.>
13:49:01 <sheldonh> timthelion: minimum wage ain't worth shit if you can't get a job
13:49:14 <merijn> Actually, scratch that. I should restrict my node trolling to -blah
13:49:17 <gentleben> dude node.js enabled parallel programming
13:49:24 <gentleben> haha
13:49:29 * sheldonh vomits.
13:49:33 <Cale> LOL
13:49:44 <tdammers> node.js is a perfect excuse for never learning more than one programming language
13:49:47 <timthelion> sheldonh: Come on, you have to accept that there are countries which have it harder than the US.
13:49:59 <aleksandar> @tdamers true
13:49:59 <lambdabot> Unknown command, try @list
13:50:04 <sheldonh> timthelion: absolutely. sudan's pretty well fucked :(
13:50:05 <tdammers> sheldonh: a job don'
13:50:06 <shurikas> I loved an article somewhere... node.js can do 100k concurrent requests (OMG SO MUCH) and found out like  a couple other frameworks can easily squeeze as much as 500k or 1kk requests
13:50:07 <aleksandar> @list
13:50:08 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:50:12 <tdammers> t mean shit if it doesn't pay your bills
13:50:14 <merijn> No! I said I take it back, let's not circle jerk in node's face here when we could be talking haskell :<
13:50:29 <tdammers> merijn: ok ok
13:50:32 <startling> merijn: web-scale
13:50:38 <aleksandar> So bring Yesod to the table
13:50:40 * tdammers is currently using node.js as part of a haskell project
13:50:57 <gentleben> sheldonh: Do you write haskell and can't get a job? Tons of people are looking for haskell devs, just not necissarily to write haskell
13:51:11 <hpaste> rosie pasted “miking up my cases, lets, and do's” at http://hpaste.org/74068
13:51:19 <plat0> gentleben: They're looking for haskell devs to do what?
13:51:23 * shurikas did some node.js programming for multiplayer html5 games over websockets. Didn't touch it anymore after that
13:51:33 <sheldonh> gentleben: i'm learning haskell to expand my mind. i do other stuff for money :)
13:51:33 <monochrom> miking up?
13:51:35 <rosie> I'm mixing up my cases, lets, and do's. Could I have some quick help?
13:51:39 <rosie> *mixing
13:51:44 <merijn> plat0: Program ocaml, C, python and C# :p
13:51:50 <shurikas> so haskell is a state of mind, not a programming language :))
13:51:55 <plat0> But why do they want Haskell devs?
13:51:55 <shurikas> meaning you will do other language as a haskell dev
13:51:56 <monochrom> firstly, bad indentation
13:52:12 <merijn> plat0: Because haskell devs are teh smartz
13:52:14 <shurikas> but you will be profficient at anything you do
13:52:25 <geekosaur> rosie, first off youyr indentation is wrong.  second, the 'in do ...' at the end is an incomplete expression
13:52:33 <gentleben> sheldonh: recruiters are starting to get that most people who spend the time to learn haskell make really good developers
13:52:38 <sheldonh> gentleben: it strikes me that functional programming makes me think about process MUCH harder, and on a deeper level (well, a deepening spiral, i should say) :)
13:52:38 <monochrom> secondly, line 4, "c <- ..." being the last line of a do-block is disallowed
13:52:53 <tdammers> learning *any* programming language that isn't BASIC is going to expand you programming mind
13:53:10 <shurikas> if I could only land a single job entirely in Haskell I bet that would make me a master programmer
13:53:11 <sheldonh> gentleben: i live in south africa. you've gotta be a moron to struggle to get a job in software here :)
13:53:16 <tdammers> and Haskell is especially valuable because it is so extremely different from Java / C# / C++ / what have you
13:53:28 <monochrom> thirdly, I doubt that you need "in"
13:53:38 <merijn> plat0: Seriously, though. Once you've learned 1 or 2 non-standard non-imperative languages (lisp, erlang, haskell, scala) you're probably A) better than most devs and B) can probably pick up any language easily
13:53:39 <hpaste> tswett annotated “miking up my cases, lets, and do's” with “mixing up my cases, lets, and do's (annotation)” at http://hpaste.org/74068#a74069
13:53:42 <hpaste> rosie annotated “miking up my cases, lets, and do's” with “miking up my cases, lets, and do's (annotation)” at http://hpaste.org/74068#a74070
13:53:45 <gentleben> sheldonh: I don't know about that. I think haskell enforces more rigidty and can lead to more strict development practices
13:53:55 <tswett> rosie: the thing I just pasted should work, if I'm not mistaken.
13:54:15 <sheldonh> gentleben: not sure how we're disagreeing :)
13:54:17 <tswett> It's a nice bit of syntactic sugar.
13:54:23 <tdammers> I think the fact alone that something like haskell attracts you means you *care* about programming
13:54:23 <timthelion> sheldonh: what about a radical open sourcer?
13:54:25 <merijn> plat0: The basic idea is "it is easier to hire smart people and teach them C#/C/python than it is to hire C#/C/python devs and teach them to be smart"
13:54:34 <gentleben> sheldonh: i don't think we are
13:54:37 <sheldonh> timthelion: you mean like sheldonh@FreeBSD.org? :)
13:54:54 <timthelion> sheldonh: like someone that refuses to write closed source code ;)
13:54:59 <plat0> merijn: :)
13:55:11 <tdammers> merijn: or, put differently, "If you want a good C#/C/python programmer, hire a good programmer, not a C#/C/python programmer"
13:55:27 <sheldonh> timthelion: well, there's space for people like that too. but what i've found is that if you're willing to compromise on really sensitive shit, you can get paid to write a LOT of open source
13:55:45 <timthelion> sheldonh: ;)
13:55:49 <gentleben> tdammers: yelp definetly thinks that
13:55:49 <merijn> plat0: I mean, I've gotten jobs offers to program Ruby. I've never programmed ruby in my life, but it seems like it should be easy to pick up
13:55:50 <aleksandar> what's the really sensitive shit?
13:55:51 <rosie> tswett: Thanks!
13:56:01 <gentleben> thats why they sponsor the bay area haskell group
13:56:39 <geekosaur> aleksandar, presumably that means if you're willing to write the code they won't release, they'll let you release a lot of code you might otherwise not be able to
13:56:44 <sheldonh> aleksandar: depends on the business. different owners have different sensitivities. but i guess it's "the stuff we'd be embarrassed about, or think makes us a special sunflower"
13:56:59 <geekosaur> yeh
13:57:04 <aleksandar> ok
13:57:07 <ddarius> shurikas, aleksandar: We do have other clients that don't care about citizenship, and at least some are looking, though some do use Java.  We provide some other interesting opportunities as well, for example, supporting a business idea if we feel it has a good chance of working out relative to the costs (if that interests you).
13:57:59 <sheldonh> anyway, i can't recommend the SICP lectures enough. they're really much more about thinking than they are about LISP, very useful to a haskell learner
13:58:00 <aleksandar> @ddarius I am just looking for info, I cannot do anything untill I am 18, which will be in about a year.
13:58:00 <lambdabot> Unknown command, try @list
13:58:01 <ddarius> shurikas, aleksandar: You'd also be in the same area as edwardk, dolio, copumpkin and they typically are looking for people too, so you'd have two shots.
13:58:29 <shurikas> that sounds really attractive
13:58:46 <edwardk> ddarius also has the best boss i've ever had the privilege of working for
13:58:53 <ddarius> edwardk: Yeah.
13:58:58 <ddarius> He's awesome.  And crazy.
13:59:03 <sheldonh> good bosses are a wonder to behold
13:59:08 <plat0> Who's the boss?
13:59:13 <sheldonh> Angela!
13:59:50 <lcc> sheldonh: what math do you need to know to read sicp? is it only the first few ch's?
14:00:04 <sheldonh> lcc: i'm not reading the book, i'm just watching the video lectures
14:00:28 <lcc> sheldonh: oh ok.
14:00:30 <sheldonh> lcc: i stopped paying attention to maths 3 years from the end of school, and i'm finding it absolutely fine so far (4 lectures in)
14:00:42 <monochrom> you just need as much math as parsing parentheses
14:00:42 <lcc> sheldonh: neat
14:00:46 <sheldonh> lcc: every now and then, i have to pause and check out wikipedia, but mostly not :)
14:00:57 <edwardk> plat0: a guy named matt nowosiadly. met him during the tail end of my ISP/phone company/dot-com days. he's a rather er.. odd individual ;)
14:01:13 <plat0> But a great boss?
14:01:19 <edwardk> but in particular he's very good at keeping crap from flowing down hill.
14:01:20 <edwardk> yeah
14:01:31 <gentleben> i love those mangers
14:01:46 <lcc> I think that the univeristy of berkeley california has sicp webcasts also.
14:02:13 <lcc> I should check them out along with the mit lectures when I get a chance.
14:02:16 <sheldonh> lcc: oh wow. the stuff i'm watching looks like it was from the seventies: http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
14:02:17 <edwardk> ddarius: hrmm, i've been wracking my brain trying to figure out the dual of something. got a sec to take a whack?
14:02:20 <Cale> There's that one square root calculation example, but if you take that on faith, there's not much more
14:02:28 <Cale> (in SICP)
14:02:33 <sheldonh> lcc: spot a link if you find the berkeley ones
14:02:47 <lcc> sheldonh: Yeah I think they are using python now to teach sicp, but if you catch an earlier one you can watch it with scheme.
14:02:50 <startling> isn't there some calculus towards the end of sicp?
14:02:50 <lcc> sure
14:02:53 <shurikas> I love those lectures!
14:02:57 <sheldonh> Cale: no way... you gotta implement it for yourself. it's a great exercise! :)
14:02:58 <ddarius> Cale: The accelerated fib using linear transformations could be a bit involved, but, for better or worse, most of the details are already spelled out for you.
14:03:09 <Cale> oh, right
14:03:11 <sheldonh> Cale: up until then, i'd never really THOUGHT about how i guess a square root
14:03:31 <startling> ^ indeed
14:03:49 * ddarius implemented a sqrt in C++ or Java in a high school class just to make the exercise more interesting (which was probably doing the Pythagorean equation or some bilge like that.)
14:04:00 <Cale> sheldonh: Well, yeah. To be perfectly honest, my actual opinion is that computer science is a branch of mathematics and you have no business trying to learn one without the other.
14:04:11 <sheldonh> gentleben: and that's what i was getting at earlier, btw. when i say FP really makes me think hard about process, it's not a criticism :)
14:04:24 <Cale> But it is possible to try :)
14:04:43 <sheldonh> Cale: all i can do is try :)
14:04:43 * ddarius views mathematics as a branch of computer science.
14:04:47 <shurikas> :D
14:04:54 <ddarius> edwardk: I can look at it.
14:04:59 <Cale> sheldonh: Just be prepared to learn some mathematics while you're at it :)
14:05:03 <gentleben> sheldonh: I think for me it allows more focus on the problem, less about other things
14:05:11 <gentleben> immutability for you
14:05:12 <edwardk> ddarius: https://github.com/ekmett/indexed/blob/master/src/Indexed/Functor.hs#L89 what is the comonadic equivalent?
14:05:15 <sheldonh> Cale: that's part of the fun! making up for what i missed at school :)
14:05:32 <lcc> I'll get that link in a sec
14:05:46 <edwardk> these are 'indexed' in that they are monads and comonads over (k -> *) like conor's kleisli arrows of outrageous fortune approach
14:06:11 <sheldonh> gentleben: yeah, that's what i'm talking about. for the kind of stuff i do, most of the problem is the process. and usually, i don't spend much time thinking about it, which is bad :)
14:07:00 <gentleben> sheldonh: I have done a big mix of both. I am finding I have to spend more time thinking about how GHC works. But tahts with any platform
14:07:02 <gentleben> or VM
14:07:17 <edwardk> type f ~> g = forall x. f x -> g x is the obvious natural transformation alias, and data At :: * -> k -> k -> * where  At :: a -> At a k k
14:07:19 <sheldonh> gentleben: ah yes. that. i'm hoping that goes away with time :)
14:07:20 <Cale> I kind of wish that there was an introductory textbook which I loved as much as Spivak's Calculus but for an area which was a little more directly relevant to programming. There are some course notes on combinatorics which come close, but they're not published widely.
14:07:22 <squidz> i have one function that retrieves html from a url, so IO. my problem is that all further functions that would work with that html pull that IO in. am I suppsosed to drag around the IO context the whole way? im not sure
14:08:16 <gentleben> sheldonh: It won't I don't think. Understanding how a runtime works whether GHC, CLR or JVM ends up being important to building well crafted software
14:08:18 <Cale> squidz: Well, you're going to do something with that HTML... so some function HTML -> A, for some type A, and then what?
14:08:28 <Cale> squidz: probably you're going to do some output, yes?
14:08:29 <gentleben> sheldonh: Its like knowing how to exploit your OS
14:08:44 <sheldonh> Cale: would you recommend Spivak over Apostol?
14:08:56 <Cale> sheldonh: I haven't actually read Apostol
14:09:18 <sheldonh> gentleben: hmmm. yeah, i think you're right. so then... i hope it becomes more intuitive with time :)
14:09:30 <squidz> eventually i will do IO again but what about in between, when i have functions that dont need IO
14:09:41 <lcc> sheldonh: http://webcast.berkeley.edu/series#c,s
14:09:42 <Cale> squidz: Write those without IO :)
14:09:52 <Cale> squidz: and then *use* them from the top-level IO action
14:10:05 <gentleben> sheldonh: On GHC its a documentation problem. There is too much knowledge that is super critical locked into just a few peoples heads
14:10:16 <gentleben> sheldonh: fortunately I work with one of them
14:10:21 <sheldonh> Cale: ah, so you reach out into pure from IO, not the other way around?
14:10:22 <squidz> how do get rid of the IO?
14:10:29 <lcc> http://webcast.berkeley.edu/playlist#c,s,All,3E89002AA9B9879E this is the one that uses scheme
14:10:31 <Cale> sheldonh: right
14:10:40 <sheldonh> Cale: Uncle Bob would be pleased ;)
14:11:31 <sheldonh> lcc: i love free education. wicked, thanks :)
14:11:33 <Cale> squidz: Okay, imagine you have a pure function process :: HTML -> String. You can write:  do html <- readFromURL "http://example.com"; putStrLn (process html)
14:11:55 <edwardk> ddarius: does the problem make sense?
14:12:27 <Cale> squidz: Or even define an intermediate thing in the middle of the do-block, like  ...; let output = process html; putStrLn output
14:12:28 <squidz> Cale: ah duh thanks
14:12:32 <ddarius> edwardk: I think but I've only glanced at it so far.
14:14:15 <edwardk> ddarius: https://github.com/ekmett/indexed/blob/master/src/Indexed/Comonad/Store.hs#L35 gives an instance
14:14:46 <edwardk> i have some thoughts but i don't want to prebias you
14:15:49 <gwern> eureka! my quick 15 minute script to load up my darcs repo, extract a file history, extract the creation date, and fmt it nicely works
14:16:41 <gwern> now all I have to do is "created: " ++ that, and figure out how to insert it into the file
14:22:30 <hpaste> gwern pasted “metadata extraction & annotation” at http://hpaste.org/74071
14:24:21 <gwern> hm... seems to work so far
14:30:53 <timthelion> I know this may seem like an odd question from a non newbie.  But why CAN'T I make a list: [1,2,"hi"] :: [a]... There are still plenty of functions I can preform on this list, such as "reverse, zip, ect"...
14:31:23 <zzing> I am attempting a basic yesod sample as shown in the yesod book (http://hpaste.org/74072) and when I run it, it will give something about newline style changed, and then it says it is listening on port 3000. I go there, and the browser says it cannot connect and the application quits. #yesod is a tumbleweed zone right now, so I ask here. I have no way of knowing what is going on here.
14:31:50 <zzing> timthelion, a list of type [a] must have everything be the same type
14:31:56 <ericmj> timthelion: http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
14:33:13 <timthelion> zzing: Of course I know that.  But it seems like this restriction is unecessary.  There are plenty of valid and usefull programs that could be written using type classes and multityped lists.
14:34:17 <merijn> timthelion: You can actually make such a list fairly easily
14:34:54 <timthelion> merijn: using a data constructor of course "data NumOrString = Number Int | String' String
14:34:55 <startling> timthelion: [Left 1, Left 2, Right "hi"] :: [Either Integer String]
14:35:43 <merijn> timthelion: No, using existential quantification like ericmj just linked
14:36:15 <merijn> Although I'm sure I can make examples in lambdabot...
14:36:18 <timthelion> merijn: OK, I'll read the link some more. I got about a paragraph in and my eyes glazed over.
14:37:10 <merijn> timthelion: That allows you to write stuff like "[forall a . Show a => a]" (maybe slightly different syntax?) and then you can have [1,"hi"], for example
14:37:27 <hpaste> gwern annotated “metadata extraction & annotation” with “metadata extraction & annotation (annotation)” at http://hpaste.org/74071#a74073
14:37:38 <gwern> this versoin should be clearer
14:37:52 <ericmj> timthelion: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types might be easier to understand
14:38:46 <timthelion> ericmj: thanks that is easier :)
14:38:53 * timthelion actually understood the first sentence!
14:38:57 <zzing> timthelion, ok, then go for existential type classes?
14:39:16 <zzing> I used them once, they seemed rather cool
14:49:30 <lucca> That is amazing.
14:56:34 <hpaste> edwardk pasted “2 arg indexed comonads” at http://hpaste.org/74075
15:01:03 <ddarius> edwardk: Your kind for (!>=) looks too polymorphic (?)
15:02:17 <ddarius> Also, switching things around, it seems that you could write, at least, (a -> m b j) -> (m (At b j) ~> m b) which may be clearer.
15:02:18 <edwardk> ddarius: i matched the kleisli paper on that one, instantiating b = (At b' k) you get m (At a j) i -> (a -> m (At b' k) j) -> m (At b' k) i  -- giving you the m i j a -> (a -> m j k b) -> m i k b you'd expect
15:02:45 <edwardk> (!>=) works its (!=>) i don't know how to build
15:03:06 <edwardk> what the comonadic version should be is what has me wracking my brains
15:03:15 <ddarius> Yeah, I somehow thought a was being passed directly to m.
15:03:18 <edwardk> saizan dashed together http://hpaste.org/74074
15:08:12 <ForSpareParts> Bit rusty on my Haskell syntax -- how do I do a pattern match inside of a function? i.e. compute something and pattern match on its result
15:08:49 <Philippa> case
15:09:02 <Philippa> case foo of {Bar -> baz; Quux -> quuuux;}
15:09:12 <ForSpareParts> Philippa, thanks!
15:09:13 <typoclass> ForSpareParts: you could do that in the where clause after the function, or in case-of
15:09:42 <ForSpareParts> typoclass, I think case is what I was looking for.
15:10:08 <ForSpareParts> A lot of this stuff slipped my mind after my last class that used Haskell...
15:14:14 <hpaste> rosie pasted “do” at http://hpaste.org/74076
15:14:45 <rosie> I get "The last statement in a 'do' block must be an expression" from the couple lines of code I posted. Any tips?
15:15:24 <boboy77b> http://www.reddit.com/r/pornvids/comments/z6ypg/tera_patrick_hot_lesbians_on_the_beach/
15:15:56 <ben> rosie: indent it so "return" is aligned with "ldocs" in the previous line
15:16:03 <ben> err
15:16:04 <Zariel> is there a monad which is like Mayube $ Either, Left Right Nothing ?
15:16:19 <ben> why's there so many do-blocks
15:16:24 <rosie> ben: yep I have that. hpaste changes the indentation
15:16:35 <ben> what are you doing with cursor
15:16:37 <rosie> ben: I need to get values out of monads
15:17:03 <merijn> rosie: hpaste doesn't change indentation...are you mixing spaces and tabs?
15:17:23 <ben> "do cursor <- ..." looks like a do-block with a single statement, what is that for?
15:19:02 <hpaste> Cale annotated “do” with “do (annotation)” at http://hpaste.org/74076#a74077
15:19:14 <Cale> oops
15:19:21 <hpaste> Cale annotated “do” with “do (annotation) (annotation)” at http://hpaste.org/74076#a74078
15:21:30 <hayashi> yo dog, so I heard you like annotations in your do notation, so I annotated your annotation so you can do notate while you do notate
15:21:35 <Cale> Zariel: Either (Maybe e) is a monad
15:22:06 <Cale> Zariel: (because Either e is, for any e)
15:23:42 <edwardk> ddarius: got it.
15:23:55 <edwardk> At is the wrong tool for the comonad.
15:24:19 <edwardk> newtype Foo a i j = Foo ((i ~ j) => a)  -- is the right dual
15:24:29 <edwardk> then its easy
15:25:17 <copumpkin> how is that different from data Foo a i j where Foo :: a -> Foo a i i
15:25:47 <edwardk> that says that given a witness of equality for i and j then i can give you an a, otherwise i give you nothing
15:25:59 <copumpkin> oh yeah, sorry
15:26:30 <edwardk> At is the one you wrote, which is useful for monads, but not so great at making indexed comonads =)
15:27:05 <edwardk> I May go with 'Coat'
15:27:16 <Zariel> Cale: Yeah im using that but having Left Just, Left Nothing, Right Just Right Nothing, when Left Right Nothing would be nice
15:27:39 <nejucomo> Can I restrict an algebraic type parameter with a type class without using a GADT?
15:27:41 <Cale> You shouldn't have Right (Just x) or Right Nothing, at least, not necessarily
15:27:57 <Cale> There's only Left (Just e), Left Nothing, or Right x, where x is a successful result
15:28:14 <Cale> nejucomo: Not in any useful way
15:28:20 <ddarius> edwardk: What does
15:28:27 <nejucomo> Ok.
15:28:31 <ddarius> edwardk: What does \f -> iextend (At . f) do?
15:28:45 <edwardk> ddarius: doesn't work. first thing i tried
15:28:56 <edwardk> turns out the obligation is going the wrong way
15:29:11 <edwardk> ddarius: newtype Coat a i j = Coat ((i ~ j) => a)
15:29:14 <edwardk> use Coat, not At
15:29:15 <nejucomo> Is there a typeclass with default :: t ?
15:29:24 <merijn> nejucomo: Yes.
15:29:35 <nejucomo> Or more precisely is there a typeclass or convention for single-valued types?
15:29:42 <merijn> nejucomo: Data.Default
15:29:44 <ddarius> edwardk: Makes sense.
15:29:47 <Cale> nejucomo: You are allowed to write  data (C a) => Foo a = ...
15:29:53 <Cale> nejucomo: But it doesn't do anything useful
15:30:03 <nejucomo> A hoogle for "default :: t" shows a bunch of stuff like posix something something.
15:30:18 <nejucomo> merijn: Ah, thanks.
15:30:32 <nejucomo> I wonder why hoogle for "Default" or "default :: t" didn't show that...
15:30:33 <edwardk> only took 8 hours and giving in and asking you, and a bunch of folks over on agda and finally realizing the At version was hopeless to figure it out ;)
15:30:54 <Cale> nejucomo: It will restrict the type of the data constructors, but you'll still need similar constraints on anything which uses the data.
15:31:07 <edwardk> Now I can have Cokleisli arrows of outrageous fortune
15:31:26 <Cale> nejucomo: If you can get a Monoid instance, that's often better
15:31:42 <Cale> nejucomo: (than just a default)
15:33:03 <Cale> nejucomo: and I suspect that's why there isn't a more popular Default typeclass, because usually if you have some "default" value, you also have some combining operation for which it's the identity.
15:33:32 <merijn> ok, I need some help with type wizardry...I have a type Foo which I have in two variants safe and unsafe. I have a bunch of "Foo -> Foo -> Foo" combinators I want to be able to combine both safe and unsafe foo's together into a new one, with the restriction that if any of the input foo's is unsafe then the output is too
15:33:52 <nejucomo> Cale: I'm using single-valued types, so I wondered if there's some way I can say a type parameter must be (or by convention should be) a single-valued type.
15:34:02 <statusfailed> merijn: That sounds just like a certain Arrow tutorial
15:34:04 <merijn> My initial thought was to do something like "Foo a" with a phantom type, but then I got a bit stuck and now I'm wondering if there's a better type
15:34:05 <edwardk> merijn: just use 'Foo a' and Foo Unsafe' then unification will force you to Foo Unsafe
15:34:13 <edwardk> if you need a Foo Safe, then constrain it on that
15:34:28 <edwardk> and any Foo Unsafe will be denied, but the polymorphic ones will work
15:34:37 <nejucomo> Cale: Can a GADT enforce the typeclass refinement everywhere the type appears?
15:34:41 <merijn> edwardk: No, I want to be able to combine a "Foo Safe" and "Foo Unsafe" into a new "Foo Unsafe"
15:34:52 <twanvl> nejucomo: why do you need more single valued types besides () ?
15:35:12 <edwardk> merijn: thats harder, hence why i was suggesting the alternative. you can do what you want with a messy typeclass but blech
15:35:13 <merijn> edwardk: Without having to write 2^n instances for each combinator to have one for all input type combinations
15:35:34 <nejucomo> twanvl: Because I'm specifically using the types as parameters to distinguish otherwise (structurally) identical types.
15:36:03 <merijn> edwardk: Yeah, I thought I was going to be stuck with a typeclass after starting to think about doing it with phantom types...
15:36:03 <Cale> nejucomo: If you write something like (this is unrealistic)   data Set a where Empty :: Set a; Nonempty :: (Ord a) => a -> Set a -> Set a
15:36:12 <timthelion> Is the State in mtl "the State" or is there another State in base?
15:36:21 <ddarius> edwardk: Swapping powers and copowers At a i j ~ (Id i j)⊗a, CoAt a i j ~ [Id i j, a]
15:36:32 <nejucomo> For example, I want a different "Decimal" type for many different situations (with different "units") and I want type checking to help me ensure I don't add two different units nonsensically.
15:36:41 * timthelion is noticing that State is "non-portable"
15:36:43 <edwardk> timthelion: its 'the state' though its actually in transformers. and just re-exported from mtl with a class
15:36:52 <edwardk> the version in transformers is portable
15:36:57 <timthelion> ok
15:37:01 <edwardk> mtl just adds MonadState
15:37:02 <Cale> nejucomo: Then pattern matching on the Nonempty constructor will relieve you of the need for an Ord a constraint. You'll be allowed to compare values of type a without incurring such a constraint on functions like  minimum :: Set a -> Maybe a
15:37:06 <merijn> edwardk: Although I'm not even sure I know how to do that using typeclasses...
15:37:30 <Cale> nejucomo: without that GADT-ish constraint, you'd end up with minimum :: (Ord a) => Set a -> Maybe a
15:37:31 <nejucomo> Cale: Ok, I think that sounds like what I want.
15:37:45 <nejucomo> Right.
15:38:05 <Cale> I believe you can also do this without the GADT syntax, but it probably needs another extension, because it's not possible in standard Haskell.
15:38:30 <Cale> By putting the constraint on the right of the = sign, before the constructor.
15:38:32 <typoclass> nejucomo: not sure if it's relevant, but just as inspiration -- the time-units package lets you write stuff like "24 :: Second" and "1 :: Hour"
15:38:51 <Cale> Probably requires ExistentialTypes or something, even though it's not really an existential type.
15:38:55 <nejucomo> twanvl: I'm pretty new to this kind of technique so I'm not sure if it's sane/usable/maintainable, but it seems promising once I figure out the requisite type system tricks.
15:39:03 <nejucomo> typoclass: Neat. I'll see how that's implemented...
15:39:07 <ddarius> @hackage dimensional
15:39:07 <lambdabot> http://hackage.haskell.org/package/dimensional
15:39:43 <typoclass> nejucomo: as far as i remember it's plain normal haskell, nothing funky
15:39:56 <ddarius> It's just Num instances for those types.
15:40:04 <Cale> ddarius: The type constraints in that package are impressive and somewhat bewildering :)
15:40:07 <nejucomo> ddarius: Awesome. That's exactly what I want.
15:40:54 <Cale> "My other class context is a Prolog program."
15:41:15 * ddarius should implement Prolog in the type class system.
15:41:23 <ddarius> Actually, I think Oleg partially did that a while back.
15:41:48 * nejucomo clears throat: data Dim l m t i th n j
15:41:53 <shachaf> I thought Oleg's thing was implementing things *in* Prolog in the type system.
15:41:58 <Saizan> "how to exploit hackage as a remote prolog system"
15:42:55 <Cale> nejucomo: length, mass, time, current, temperature, amount of substance, and luminous intensity
15:43:08 <Cale> It seems like one could get by with fewer fundamental dimensions...
15:43:37 <nejucomo> Um... but those aren't the dimensions I want at all.  Is Dimensional limited to those?
15:44:06 <ddarius> I wonder if I could make some pleasant meta-programming system by using rewrite rules as the computational substrate.
15:45:13 * ddarius wonders how fast rewrite rule rewriting is.
15:46:36 <nejucomo> I was hoping for something more general where the application can define arbitrary dimensions.
15:54:03 <squidz> how can i chain two methods together with mapM_ ? examplem mapM f1 f2 [t]
15:54:42 <Dodek> mapM (f1 . f2) l
15:54:49 <shachaf> That depends on the type of f1 and f2.
15:54:56 <squidz> okay maybe i have the wrong function types
15:54:57 <shachaf> You might find (<=<) and (>=>) useful.
15:55:05 <squidz> ill take a look thanks
15:55:48 <ddarius> \z -> generate (ntimes (lambda x (apply f x)) z d4)   ~>   \z -> f (f (f (f z)))
15:56:20 * ddarius should see if that is doable with that syntax or something very close to it.
15:57:03 <shachaf> Expr already does something vaguely similar with free variables.
15:57:24 <shachaf> > iterate f z !! 5
15:57:25 <lambdabot>   f (f (f (f (f z))))
15:57:42 <shachaf> Presumably if you can examine Exprs in lambda, it could be enough.
15:58:38 <ddarius> shachaf: The intent is this is all rewrite rules, i.e. rules for generate, ntimes, lambda, apply.  The result would be actual source code that is immediately compiled.
15:59:31 <shachaf> Hmm, how can you do it with rewrite rules?
16:00:16 <ddarius> shachaf: Surely something like it can be done with rewrite rules, I'd expect.
16:01:08 <ddarius> I wrote a CEK machine in rewrite rules a while back.
16:02:21 <ddarius> Might have to do (var n) or something, or name them explicitly.
16:02:27 <ddarius> Er var x.
16:02:50 <ddarius> Alternatively, I may duck the problem by using a stack language.
16:02:50 <squidz> or i need something like (a->b) -> m (a->b) -> m b
16:03:13 <squidz> is there something like that
16:03:23 <ddarius> That type doesn't make much sense.
16:03:39 <ddarius> I don't think it's the type you meant to write.
16:03:48 <squidz> a -> (a->b) -> m (a->b) -> m b
16:03:53 <squidz> maybe this is what i meant
16:04:04 <shachaf> Probably not.
16:04:51 <ddarius> Maybe you're going for m (a -> b) -> a -> m b ?
16:04:52 <squidz> i have something like this: mapM $ parseUrl putStrLn links
16:05:11 <squidz> where parseUrl :: String -> String
16:05:34 * ddarius recommends not using ($) in the beginning...
16:06:05 <squidz> is it clear what i meant?
16:06:10 <ddarius> No.
16:06:27 <squidz> mapM_ parseUrl putStrLn links
16:06:37 <squidz> where parseUrl :: String->String
16:06:46 <shachaf> Oops, this is GHC 4.08 documentation.
16:06:58 <mikeplus64> mapM_ (putStrLn . parseUrl) links
16:07:12 <mikeplus64> if links :: [String]
16:07:13 <squidz> thats not working for some reason
16:08:14 <mikeplus64> can you paste the code somewhere?
16:08:35 <shachaf> Or give the types of everything involved?
16:08:36 <ddarius> mikeplus64: I don't think he was referring to your code.
16:09:02 <ddarius> But given the complete incoherence of the original code, there are probably nothing but problems in the remainder.
16:09:27 <hpaste> squidz pasted “scraper” at http://hpaste.org/74080
16:10:26 <squidz> i want to use parseUrl in the 14th line
16:11:04 <mikeplus64> could it be that whatever monad that is isn't IO?
16:11:12 <mikeplus64> i don't know hxt or whatever you're using
16:11:40 <squidz> its for handsomeSoup
16:11:45 <squidz> for scraping xml/html
16:12:26 <mikeplus64> what's the error? (i can't be bothered to install handsomesoup and friends)
16:13:23 <squidz> sorry
16:13:26 <squidz> i dont knwo what i was doing
16:13:31 <squidz> because it works now
16:13:34 <squidz> i must have had the order wrong
16:14:01 <squidz> i had to use putstrln . parseUrl
16:14:16 <squidz> before i must have been using parseUrl . putStrLn
16:14:36 <shachaf> Do you understand why it works?
16:14:45 <squidz> yes
16:15:05 <squidz> parseUrl cant do anything with IO
16:15:22 <mikeplus64> (f . g) x = f (g x), not g (f x)
16:15:43 <squidz> thanks
16:20:08 * ddarius hasn't played guitar in so long.
16:21:00 <bammmm> how would you square all numbers in a list in haskell?
16:22:06 <aristid> bammmm: map (^2)
16:22:54 <fmap> > map (join (*)) [1..10]
16:22:55 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
16:23:20 <ddarius> > getProduct . join (zipWith mappend) . map Product $ [1..10]
16:23:22 <lambdabot>   Couldn't match expected type `Data.Monoid.Product a'
16:23:22 <lambdabot>         against inferr...
16:23:45 <ddarius> > map getProduct . join (zipWith mappend) . map Product $ [1..10]
16:23:47 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
16:24:24 <lpvb> > (^2) <$> [1..10]
16:24:25 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
16:24:49 <bammmm> wow
16:24:52 <bammmm> neat
16:25:33 <nand`> > join (zipWith (*)) [1..10]
16:25:34 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
16:25:47 <lpvb> or just
16:25:54 <lpvb> > map (^2) [1..10]
16:25:55 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
16:25:59 <otters> that's clever
16:26:00 <nand`> map (^2) is pretty much the idiomatic way, yeah
16:26:05 <otters> zips a list with itself
16:26:25 <ddarius> otters: It's also silly.
16:28:28 <ddarius> > mempty :: ZipList Int
16:28:29 <lambdabot>   No instance for (Data.Monoid.Monoid
16:28:29 <lambdabot>                     (Control.Applicativ...
16:28:38 <shachaf> (\l -> Data.Array.IArray.elems $ runST $ do { arr <- newListArray (0,length l - 1) l :: ST s (STArray s Int Int); (`fix` 0) $ \loop i -> do { v <- readArray arr i; writeArray arr i (v^2); when (i < (length l - 1)) (loop (i+1))}; iarr <- unsafeFreeze arr; return (iarr :: Array Int Int) })
16:28:53 <lpvb> > mempty :: ZipList Sum
16:28:54 <lambdabot>   `Data.Monoid.Sum' is not applied to enough type arguments
16:28:54 <lambdabot>  The first argume...
16:29:01 <shachaf> That's the best way to square all the elements of a list in Haskell, by far.
16:29:11 <lpvb> > mempty :: ZipList Sum int
16:29:12 <lambdabot>   `Control.Applicative.ZipList' is applied to too many type arguments
16:29:17 <lpvb> > mempty :: ZipList Sum Int
16:29:18 <lambdabot>   `Control.Applicative.ZipList' is applied to too many type arguments
16:29:54 <ddarius> shachaf: You should have implemented a C-style for loop.
16:30:05 <shachaf> ddarius: I did that yesterday.
16:30:21 <shachaf> Admittedly I could've used it here.
16:31:33 <shachaf> Hmm, lambdabot doesn't import Data.Array.ST.
16:32:02 <ddarius> shachaf: Surely you should have.  for(int i = 0; i < a.size(); i++) { a[i] *= a[i] }; would be far more idiomatic and recognizable than this map nonsense.
16:32:07 <ion> @remember shachaf (\l -> Data.Array.IArray.elems $ runST $ do { arr <- newListArray (0,length l - 1) l :: ST s (STArray s Int Int); (`fix` 0) $ \loop i -> do { v <- readArray arr i; writeArray arr i (v^2); when (i < (length l - 1)) (loop (i+1))}; iarr <- unsafeFreeze arr; return (iarr :: Array Int Int) })  That's the best way to square all the elements of a list in Haskell, by far.
16:32:07 <lambdabot> Done.
16:32:40 <shachaf> Oh, now it's gone down in history and I can't change it. :-(
16:33:13 <shachaf> ddarius: I don't think you can do binding easily...
16:34:24 <shachaf> At least I had the good sense to use unsafeFreeze for efficiency.
16:34:43 <nand`> i <- int; for (i =: 0, i < a.size(), (i++)) -- something like that I could see working
16:34:57 <ddarius> shachaf: But surely you trust you infallibility enough to use unsafeWriteArray and unsafeReadArray.
16:35:25 <shachaf> Oh, I didn't see those.
16:35:38 <shachaf> That's because I didn't look at type class methods.
16:36:15 <shachaf> (Actually I had an off-by-one error while writing that code. So it might easily have segfaulted ghci if I'd used unsafeWrite.)
16:36:55 <shachaf> Hah, allowing instance declarations in @let would let you write unsafeCoerce.
16:38:37 <nand`> how is the <IO ()> thing done in mueval? by re-defining IO as some trivial monad and using Typeable or something to show the type argument on it?
16:38:50 <shachaf> No redefinition necessary.
16:38:56 <Cale> It's just a Show instance
16:39:02 <nand`> oh
16:39:05 <ion> shachaf: With Ix or something?
16:39:10 <nand`> right, it doesn't execute or anything either way
16:39:11 <shachaf> ion: With Typeable.
17:01:47 <covi> Does Haskell native libraries provide a 'copyDir' function? If not, is there any package that implements this?
17:02:29 <Taslem> @pl (\x -> f x 3 7)
17:02:30 <lambdabot> flip (flip f 3) 7
17:05:56 <Cale> covi: There's createDirectory and copyFile
17:06:05 <Cale> in System.Directory
17:06:24 <Cale> You'd have to recursively apply those to copy a whole tree. I'm sure there's something on Hackage to do it
17:06:26 <donri> huh, hoogle works for any hackage package if you add +<package> to the search
17:07:14 <applicative> covi http://hackage.haskell.org/packages/archive/Cabal/1.14.0/doc/html/Distribution-Simple-Utils.html#v:copyDirectoryRecursiveVerbose doesn't have all the same possibilities
17:09:16 <typoclass> donri: o_O
17:09:40 <donri> hm not working for every package i'm trying
17:11:16 <Cale> covi: At the very least, you could use the stuff in filemanip System.FilePath.Find to either collect a list of files, or an IO action for copying them all at once.
17:11:40 <geekosaur> Distribution.Simple.Utils is one of the bootlibs
17:11:55 <geekosaur> so I expect it only actually works to constrain searches in the bootlibs, not actually doing a hackage search
17:12:53 <geekosaur> (more precisely Cabal is a bootlib)
17:15:10 <applicative> geekosaur: I probably wasnt understanding what covi wanted, but it does what you'd expect I've found
17:15:34 <geekosaur> oh, I mixed two threads
17:16:35 <applicative> it's presumably for copying during the equivalent of  'make install' so maybe it doesn't take account of everything.  there must be something better around
17:18:40 <osaunders> Is it possible to define a function «isSet :: a -> Bool» that just tells you whether a value is a set?
17:19:06 <ion> isSet = const True
17:20:06 <Automorphism> Hello. I am trying to install reactive using cabal (cabal install reactive), and I get an error saying that the module Control.Comonad could not be found. However, I have previously intalled the comonad package (cabal install comonad). What could be the problem?
17:20:09 <geekosaur> osaunders, static typing means you know if something is a set or not
17:20:40 <shachaf> Automorphism: `ghc-pkg list comonad`?
17:20:55 <tibbe> Automorphism: so cabal install reactive should pull in all its reps so perhaps the command package is broken somehow
17:21:16 <donri> reactive depends on categories-extras with no upper bound, that's your problem
17:21:17 <shachaf> Automorphism: It looks like reactive doesn't specify a dependency on comonad.
17:21:18 <Automorphism> shachaf: There are two versions: 1.1.1.6 and 3.0.0.2
17:21:29 <shachaf> Oh, reactive depends on category-extras.
17:21:39 <shachaf> Which is now deprecated and empty.
17:21:47 <donri> Automorphism: cabal install reactive --constraint=category-extras<1.0
17:22:03 <Automorphism> donri, tibbe, shachaf: Thank you all!
17:22:05 <osaunders> geekosaur: You don’t know whether an «a» is a set or not
17:22:11 <Cale> I will be quite surprised if you can get reactive working.
17:22:22 <geekosaur> osaunders, correct, and you shouldn't
17:22:32 <ion> osaunders: See the XY problem.
17:22:34 <Cale> (at least, without major work put into it)
17:23:05 <shachaf> @tell conal "reactive" depends on "category-extras", which is now obsolete and empty; it should depend on individual packages like "comonad" instead.
17:23:05 <lambdabot> Consider it noted.
17:23:27 <geekosaur> osaunders, there *are* ways to do that.  but, you are not programming in Haskell if you use them
17:23:43 <typoclass> osaunders: what are you trying to do?
17:23:44 <geekosaur> (and indeed their main use is for communicating with dynamic languages such as javascript)
17:24:08 <Automorphism> donri: That command does not work. I tried both --constraint=category-extras<1.0 and --constraint category-extras<1.0 .
17:24:08 <Cale> It's been at least a couple years since reactive has seen an update
17:24:34 <Cale> and even when it built, it wasn't really in the most usable condition
17:24:36 <ion> automorphism: Quoting the parameters appropriately?
17:24:37 <joe9> need some advice please. What do I do to get the top (or ceiling) value from a number: for example, I have 794 and an increment number 100. I want to get 800 from those 2 numbers.
17:24:38 <geekosaur> and while it's possible to write Javascript in Haskell, Haskell makes a lousy Javascript.  works better to write Haskell in Haskell
17:24:38 <shachaf> Oh.
17:24:43 <joe9> Any suggestions, please?
17:24:45 <shachaf> Maybe there are bigger issues, then. :-)
17:24:46 <ion> (<1.0 or <2?)
17:25:16 <Automorphism> ion: My knowledge of bash syntax is very superficial, how would I quote that?
17:25:27 <ion> 'category-extras<1.0'
17:25:30 <Automorphism> Ah!
17:25:32 <Automorphism> Thanks!
17:25:38 <Cale> osaunders: If you have a Typeable constraint on a, then you can...
17:25:45 <osaunders> geekosaur: I have no specific desire to uphold any specific principles for how to program in Haskell any more than I believe is useful. You may think this is foolish and you are entitled to your opinion but please permit me to make my own mistakes
17:26:02 <Clint> isSet = (typeOf1 Set.empty ==) . typeOf1
17:26:03 <nand`> > head $ dropWhile (<794) [0,100..]
17:26:04 <lambdabot>   800
17:26:08 <Cale> osaunders: Remember, types are a compile-time phenomenon -- compilation destroys them.
17:26:36 <Cale> osaunders: Meanwhile, function application is something which primarily occurs at runtime, when type information no longer exists.
17:27:11 <joe9> nand`: thanks.
17:27:12 <osaunders> OK thanks for the pointers
17:27:25 <edwardk> i should send conal a patch. i had a branch of it that switched to comonad
17:27:27 <Cale> osaunders: So the knowledge about whether something was a Set is usually obliterated before a function would have a chance to act on it. This isn't just a practical matter, but also has theoretical implications about the meaning and quality of polymorphism...
17:27:28 <nand`> joe9: I don't know if that's the best way to do things, it's just the first that comes to mind
17:27:31 <Cale> oh, he just quit
17:27:40 <typoclass> > let thresh = 100 in succ (794 `div` thresh) * thresh -- joe9. however, for 500, this will give the value 600. not sure if that's what you want
17:27:41 <lambdabot>   800
17:27:56 <ion> Hah. I misread his original question as “…is set?” instead of “…is a set?” and thought he wanted to know whether it’s undefined.
17:28:50 <joe9> > head . dropWhile (< 794) $ [0, 100 ..]
17:28:52 <ion> > ceiling (794 / 100) * 100
17:28:52 <lambdabot>   800
17:28:53 <lambdabot>   800
17:28:57 <Clint> we'll never know what he actually meant by "set"
17:29:02 <joe9> ion, thanks.
17:29:04 <ion> > ceiling (500 / 100) * 100
17:29:05 <lambdabot>   500
17:31:11 <nand`> ion: your answer works both ways (const True)
17:31:12 <squidz> god i think i love haskell more everyday
17:31:33 <nand`> I think pretty much everything in Haskell is representable by sets
17:43:54 <dmwit> strange
17:44:06 <dmwit> Why does Data.Text.commonPrefixes return a Maybe?
17:48:27 <dmwit> > let thresh = 100 in (794 + thresh - 1) `div` thresh * thresh
17:48:28 <lambdabot>   800
17:48:34 <dmwit> > let thresh = 100 in (500 + thresh - 1) `div` thresh * thresh
17:48:35 <lambdabot>   500
17:48:42 <typoclass> dmwit: yes, seems weird. would be just as plausible to indicate "no match" by returning an empty string
17:48:48 <dmwit> yes
17:51:01 <mnero_> is there a way to wrap a regular haskell function in a FunPtr?
17:51:44 <parcs`> foreign import ccall "wrapper" wrapHaskellFunction :: (a -> b -> c) -> IO (FunPtr (a -> b -> c))
17:52:36 <mnero_> will give that a shot, thanks
17:52:55 <parcs`> make sure to free it after you're done using it with freeHaskellFunPtr
17:52:56 <monadx> seen monad
17:54:35 <shachaf> dmwit: As opposed to empty strings?
17:55:06 <dmwit> yes
18:00:31 <ddarius> Maybe it was to ease Maybe monad usage.
18:01:26 <joe9> dmwit: this seems better: head . dropWhile (< 794)  $ [0, 100 ..] :: Int
18:01:42 <dmwit> joe9: Really? Why?
18:02:17 <joe9> easy to understand for me, dmwit. I am not of your calibre (being sincere). I have seen you here for a while, now.
18:02:20 <dmwit> It looks bad to me; consider applying that function to -150 or 10000
18:02:47 <dmwit> Oh, my version is just a math trick, nothing special.
18:02:51 <dmwit> I can explain it if you like.
18:03:50 <dmwit> The "x `div` thresh * thresh` part is essentially a call to the "floor" function on (x/thresh).
18:04:03 <joe9> dmwit: please, if you can explain it. that would be cool.
18:04:14 <dmwit> ...maybe I'll start even farther back.
18:04:15 <dmwit> actually
18:04:20 <nand`> the first time I read it it looked like `div` (thresh * thresh)
18:04:41 <dmwit> Okay, so here's the big insight (everything else is just details after this): the "div" function is a function that divides, *and then rounds down*.
18:04:48 <dmwit> We're going to exploit the "and then rounds down" part.
18:05:16 <thirsteh> how lightweight are the GHC "threads"? Can I think of them as coroutines/spawn thousands/hundreds of thousands of them? How much overhead for each one, like 4KB memory?
18:05:26 <dmwit> The "and then rounds down" part means that everything in the range [100 .. 199] all maps to 1; [200 .. 299] all maps to 2, [300 .. 399] all maps to 3, etc.
18:05:33 <parcs`> thirsteh: you can spawn millions of haskell
18:05:36 <parcs`> threads
18:05:51 <thirsteh> I should have added "no problem", heh
18:05:56 <dmwit> Now, we don't actually want to map [100 .. 199] to 1, we want to map it to 100.
18:06:00 <nand`> millions might be pushing it I think
18:06:05 <dmwit> Likewise, we want [200 .. 299] to go to 200, not 2.
18:06:09 <parcs`> ok maybe hundreds of thousands
18:06:10 <dmwit> So just multiply by 100 again.
18:06:20 <thirsteh> ok thanks
18:06:21 <ddarius> You can definitely do hundreds of thousands.
18:06:25 <dmwit> At this point, we've got something like "x `div` 100 * 100".
18:06:34 <ddarius> Depending on how much RAM you have, you could do millions.
18:06:50 <dmwit> Now, the next sneaky trick is to figure out how to turn a function that rounds down into a function that rounds up.
18:06:56 <nand`> (how much RAM would I need to spawn a million trivial threads?)
18:07:08 <shachaf> None.
18:07:13 <shachaf> That's the great thing about trivial threads.
18:07:31 <thirsteh> in most other languages with coroutines it's usually a couple KBs per "thread"
18:07:42 <dmwit> This is the addition and subtraction bit.
18:08:03 <ddarius> I believe the default stack size is a page or so, so that's 4KB per thread, so 1,000,000 would require 4GB not counting other overhead.
18:08:19 <joe9> dmwit, that is cool. thanks a lot.
18:08:25 <dmwit> So, we start with a number in the [101..200] range; we want this eventually to end up at 200, which means we need to first put all these numbers into the [200..299] range.
18:08:26 <thirsteh> ddarius: sounds like what I'm used to
18:08:45 <parcs`> nand`: 1.3GB here
18:08:48 <ddarius> thirsteh: From where?
18:08:49 <dmwit> How can we map all the numbers in [101..200] into some number in [200..299]? Easy: add 99 (= 100 - 1).
18:08:55 <joe9> dmwit, you realise that it does not have to be 100, it could be any number.
18:08:58 <dmwit> So this is the (x - thresh + 1) part.
18:09:07 <dmwit> joe9: Of course. It generalizes readily to any other number.
18:09:13 <joe9> dmwit: ok, thanks a lot.
18:09:17 <thirsteh> ddarius: the most recent one would be Go, which also multiplexes its "goroutines"
18:09:28 <joe9> dmwit: that is awesome.
18:09:39 <dmwit> joe9: It's just easier to read a range like [100..199] than it is to read a range like [n * thresh .. (n+1) * thresh - 1]
18:09:42 <dmwit> =)
18:09:42 <joe9> the explanation and the solution are just "wow".
18:10:05 <dmwit> err, s/(x - thresh + 1)/(x + thresh - 1)/ of course
18:10:17 <thirsteh> ddarius: actually I can't think of other languages where it's as easy as "forkIO" and "go"
18:10:22 <shachaf> dmwit: (Easier to get it wrong, too.)
18:10:47 <thirsteh> and STM is a dream
18:11:01 <sbahra> I'm not so sure of that.
18:11:23 <sbahra> Recently I learned about http://software.intel.com/en-us/blogs/2012/02/07/transactional-synchronization-in-haswell/
18:11:40 <sbahra> Makes it seem less of a dream, it will at least enable a lot of nice things assuming it is performant.
18:12:02 <thirsteh> oh I don't mean it is far-fetched
18:12:11 <thirsteh> I mean I already find it wonderful for what I'm doing
18:12:18 <MostAwesomeDude> thirsteh: Why do you think STM is a dream? It's *implemented* today, in several different runtimes.
18:12:42 <dmwit> "dream" meaning "awesome", not "dream" meaning "not yet attainable"
18:12:47 <nand`> (am I the only one who understood ’is a dream’ as ‘is cool’, not ‘is unrealistic’?)
18:12:50 <thirsteh> it's an expression. It means it's great.
18:12:51 <MostAwesomeDude> Oh, I see.
18:12:51 <ddarius> thirsteh: I understood what you meant.  I don't understand everyone else.
18:12:59 <pharaun> haha
18:13:07 <shachaf> I understand everyone but ddarius.
18:13:09 <MostAwesomeDude> Sorry, I'm used to hearing things like "STM will never happen."
18:13:25 <thirsteh> by far the easiest synchronization mechanism I've ever used
18:13:40 <dmwit> sbahra: Is this HTM?
18:13:58 <dmwit> I understand everybody except the people that don't understand themselves.
18:14:06 <sbahra> dmwit: Yes.
18:14:06 <thirsteh> This sentence is false.
18:14:07 <typoclass> ddarius understands everybody who doesn't understand himself
18:14:18 <nand`> what I love about STM is how it takes all of the example algorithms designed to be hard to implement concurrently without problems and makes it all seem to painfully straightforward
18:14:20 * thirsteh laughs as the channel explodes
18:14:42 <shachaf> Haswell has all sorts of exciting things.
18:14:52 <nand`> I keep misreading Haswell as Haskell
18:14:56 <ddarius> dmwit: Hardware transactional memory preceded software transactional memory, so it would just be TM.
18:15:00 <sbahra> It's going to fuck me for a bit, I heard they are bumping VMA bits to 56 from 48 :-P
18:15:23 <shachaf> sbahra: Are you doing things with those bits or something?
18:16:00 <ddarius> nand`: That was the purpose of Keir Fraser's thesis.
18:16:05 <sbahra> ddarius: Why this distinction? I've seen it referred to as HTM.
18:16:13 <parcs`> 1000000 million ghc threads require 1.6GB of ram, nice
18:16:22 <thirsteh> didn't database transactions precede all of these things?
18:16:26 <nand`> parcs`: 1 trillion?
18:16:29 <ddarius> parcs`: All blocked or are some dying?
18:16:42 <dmwit> 1000000 million is a lot of millions
18:16:59 <sbahra> shachaf: Yes, unfortunately using them has some very nice advantages (primarily 50% reduction memory usage in one commonly used data structure).
18:17:15 <thirsteh> I remember a lecture by someone who said something like, "It's great that the 70's database papers were so obscure; it means we can invent all the things they talked about and call it new"
18:17:37 <shachaf> 2^56 bytes is 64 PB
18:17:41 <shachaf> That's a lot of bytes.
18:17:45 <ddarius> There were a lot more than database papers that were obscure (or not) that are being reinvented and called new.
18:17:52 <parcs`> ddarius: they were all simultaneously blocking on an mvar if that's what you mean
18:18:09 <ddarius> But, yeah, I'm pretty confident DB research dwarves many other fields.
18:18:11 <sbahra> shachaf: But 2^8 is 1 byte :)
18:18:26 <shachaf> Er, yes.
18:18:40 <sbahra> I'll have to implement run-time support for both, there are cases where I would still be able to leverage this.
18:18:44 <shachaf> It's still a lot.
18:18:47 <sbahra> I wish I could use Haskell for this sort of thing :)
18:18:57 <thirsteh> ddarius: yeah. It's really interesting how most of progress in comp.sci. happened in those decades
18:19:06 <sbahra> shachaf: This is for a map. Rules out storing things like domains/etc...
18:19:32 <parcs`> nand`: oops no unfortunately
18:19:45 <ddarius> s/many/most if not all/
18:20:43 <thirsteh> ddarius: this is the one -- pretty good: http://www.youtube.com/watch?v=0slg39aJTok
18:24:05 <mnero_> what does this piece actually do: 'foreign import ccall "wrapper"'?
18:24:27 <mnero_> wrapper is a magic string?
18:24:59 <parcs`> yeah
18:25:52 <rosie> In emacs, using ghc-mod, when I hit C-cC-c, the buffer says "Syntax check with GHC". How do I run it?
18:25:54 <parcs`> it's just what ghc names the magical c function that makes FunPtrs for you
18:26:48 <mnero_> So somewhere out there is some C code that ghc has and lets you make calls to, and wrapper is one of the functions.
18:29:30 <parcs`> i'm not sure how it works under the hood
18:31:07 <nanotech> I'm trying to write a polymorphic free monad transformer, but can't quite get the types worked out. Is existential quantification the right thing to use to get polymorphism?
18:31:16 <nanotech> I'll paste the code I have so far
18:31:27 <hpaste> nanotech pasted “free-poly-print.hs” at http://hpaste.org/74087
18:40:59 <byorgey> nanotech: why use  exists a. Show a?  Why not just store a String?
18:41:50 <nanotech> byorgey: because this is a convoluted exercise for a more practical problem :)
18:41:53 <edwardk> or at least an Int -> ShowS
18:42:52 <nanotech> I'm seeing if it's possible to move a whole mostly-IO program I have out of IO with transformers
18:43:52 <Cale> nanotech: It's almost always possible to do something similar to "just using a String"
18:44:28 <byorgey> nanotech: what package is Control.Monad.Trans.Free from?
18:44:34 <edwardk> i used to use lots of existentials, now they just turn into a couple of functions in a data type somewhere
18:44:37 <edwardk> 'free'
18:45:00 <nanotech> Cale: right. I don't really doubt it's possible, just need to figure out how
18:45:29 <nanotech> transformers-free, actually
18:45:51 <edwardk> ah, the one in free subsumes that one =P
18:46:00 <edwardk> (same type, more instances)
18:46:10 <nanotech> oh, well then
18:47:14 <edwardk> are you trying to so with PrinfF:
18:47:18 <edwardk> er
18:47:24 <edwardk> i accidentally a word or 3
18:48:01 <edwardk> data PrintF a = PrintF (Int -> ShowS) a -- covers your existing usecase
18:48:49 <edwardk> prnt x = liftF $ Print (`showsPrec` x) ()
18:49:08 <edwardk> and it dithes the need for rank n and existentials
18:49:16 <edwardk> er ditches
18:49:18 <edwardk> can't type today
18:49:40 <byorgey> nanotech: it compiles for me if I remove the Show s  constraint from runPrintT
18:50:35 <byorgey> you definitely don't need any constraints on s because it's a phantom parameter
18:50:38 <nanotech> edwardk: thanks, I'll try that
18:50:47 <nanotech> byorgey: oh nice. knew I was missing something
18:53:11 <nanotech> I'll see which method works better in the target code
19:05:31 <vamega> Hi
19:05:38 <jaredj> 'ey
19:05:48 <vamega> I'm making at attempt to learn Haskell
19:05:59 <jaredj> right-o
19:06:00 <byorgey> excellent!
19:06:04 <byorgey> how may we assist you
19:06:07 <vamega> So I picked up a copy of learn you a haskell have started reading it
19:06:21 <vamega> but I'm not sure I'm internalizing the stuff in the book
19:06:56 <byorgey> vamega: how much practicing have you been doing?
19:07:00 <vamega> So I was wondering if #haskell is aware of any problems that I could attempt to tackle while going through the book
19:07:01 <vamega> Lets see
19:07:31 <byorgey> vamega: you could try http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
19:07:32 <startling> vamega: I liked http://www.haskell.org/haskellwiki/99_questions
19:07:37 <startling> byorgey: jinx
19:07:42 <byorgey> hehe
19:07:44 <vamega> I've got through the first 7 chapters of LYAH
19:08:15 <byorgey> vamega: if you like discrete math/number theory, there's also Project Euler
19:08:24 <vamega> About to start working on Info and output
19:08:45 <vamega> Yeah, I've tackled Project Euler using other languages.
19:08:48 <byorgey> vamega: of course the best is probably to pick some little pet projects and try coding them in Haskell
19:09:13 <vamega> byogey - Yeah thats how I did things when learning other things
19:09:28 <vamega> however in other situations there was usually one way of doing things
19:09:33 <startling> writing "real" code in haskell is enormously helpful
19:09:44 <pharaun> ++ writing "real" code helped me a large amount
19:09:56 <vamega> with haskell I fumble trying to figure if one method is more useful than another?
19:10:11 <vamega> How complex would you say writing a FTP server in Haskell would be?
19:10:16 <startling> writing list reverse functionsis all well and good, but it takes practice to learn how to do useful things
19:10:55 <vamega> Or implementing an IRC bot?
19:11:14 <pharaun> vamega: what i do is i write something, does it work, ok great, i commit that then i attempt to refine it to be better/more functional, then repeat
19:11:45 <pharaun> lots of my first attempt code are pretty bad, but the biggest thing that helps me is to get it to compile, work then i can start cleaning it up and making it better :)
19:11:55 <ArthurM> read a lot of source code.
19:12:04 <pharaun> that too ^
19:12:46 <mm_freak> @karma writing
19:12:46 <lambdabot> writing has a karma of 0
19:13:29 <mm_freak> @karma
19:13:29 <lambdabot> You have a karma of 2
19:14:16 <mm_freak> vamega: implementing an FTP server is difficult, but that's not haskell's fault =)
19:14:24 <mm_freak> an IRC bot should be reasonably easy
19:14:34 <startling> vamega: irc sucks. don't do it unless you're already familiar with the protocol
19:15:29 <jaredj> speaking of reading code - what's something that uses parsec with state?
19:15:43 <pharaun> parsec ?
19:15:57 <pharaun> doh, panodoc my bad
19:16:03 <pharaun> tho i don't know if it has state
19:16:05 <mm_freak> and to be fair, implementing any networking application in haskell is /comparably/ easy…  haskell even beats erlang in that regard, but you will need some experience to do it properly
19:16:24 <rosie> In emacs, using ghc-mod, when I hit C-cC-c, the buffer says "Syntax check with GHC". How do I run it?
19:16:31 <vamega> startling - is irc that complex of a protocol?
19:17:57 <BMeph> @karma chameleon
19:17:57 <lambdabot> chameleon has a karma of 0
19:18:02 <mm_freak> vamega: it's easy to write a standards-compliant IRC client, but that wouldn't be a useful one =)
19:18:31 * BMeph nods...it comes and goes.
19:18:38 <mm_freak> vamega: IRC is poorly designed and doing a /useful/ IRC implementation is difficult, but it's easy to write a simple bot
19:19:19 <pharaun> could even do a simple webapp with something like happstack/yesod/snap
19:19:52 <vamega> Pharun - I can think of a few webapps I'd like to implement
19:20:04 <vamega> How hard is it to get into writing web apps
19:20:08 <startling> vamega: it's not so much complex as poorly-defined and -designed. Plus there are a bunch of nonstandard things on top of it
19:20:22 <vamega> And if you're familiar with Learn you a Haskell
19:20:34 <startling> vamega: (irc, that is)
19:20:35 <vamega> how much of it should I read before I attempt an undertaking like a web app?
19:20:50 <startling> vamega: to applicative, at least
19:21:20 <vamega> startling, I see, that makes sense thanks
19:21:38 <vamega> Great I'll get to reading then.
19:21:43 <vamega> Another question
19:22:00 <vamega> I have what I consider to be a fairly good background in Math.
19:22:40 <vamega> I'm comfortable with number theory, and have am fairly good and graph theory
19:23:07 <vamega> But how would I go about learning the background behind catergory theory?
19:23:22 <vamega> What area of math does it stem from, group theory I'd imagine?
19:23:53 <startling> vamega: set and group theories, yeah
19:24:41 <vamega> Thanks, I think I'd like to learn the background to so much of Haskell once I wrap my head around the language.
19:24:49 <vamega> Thanks everyone
19:25:07 <vamega> * goes off to read more "Learn you a Haskell", he'll be back.
19:27:31 <jaredj> surprising, ohloh seems to track _who_ uses a piece of oss but not _what_ other oss projects use it?
19:29:24 <jaredj> do people quit using parsec quickly as their speed needs scale up?
19:30:34 <pharaun> i'm happy with parsec here, i don't really have any huge speed needs (small slow client network library)
19:30:52 <jaredj> aha, and is your parser stateful?
19:31:54 <jaredj> this is poor etiquette, i should just ask my question
19:33:18 <jaredj> i'm parsing gschem schematics, where, for example, a component could have several attributes. C "resistor 1" \n { \n T "10 ohms" \n } or so.
19:33:42 <jaredj> so when i see the {, i want to start collecting attributes. this sounds like state.
19:34:40 <yubiwasabi2> What apps are being made using Haskell?
19:34:41 <byorgey> jaredj: it doesn't sound like state to me.
19:34:50 <jaredj> *eyebrow* please elaborate.
19:35:20 <pharaun> jaredj: my parser as it is right now is mostly state-free its the lower layer (network stack) that is stateful
19:35:23 <jaredj> yubiwasabi2: darcs, the revision control system that should have won but didn't have a Finn on its side.
19:35:42 <byorgey> jaredj: presumably the parser for the inside of the { ... } is just something like 'many attribute'  where 'attribute' is a parser that can parse any attribute
19:35:46 <pharaun> well darcs does have some problems (performance, the last time i heard) but that was a long time ago :)
19:36:02 <pharaun> yubiwasabi2: there is - xmonad, yesod, happstack, snap, couple of games
19:36:04 <byorgey> jaredj: the only issue is how to wrangle all attributes into the same type so you can return them in a list.
19:36:08 <yubiwasabi2> and enterprise use of Haskell?
19:36:13 <pharaun> yubiwasabi2: and a bunch of others
19:36:23 <yubiwasabi2> games? which games?
19:36:32 <jaredj> byorgey: yes.
19:36:35 <pharaun> yubiwasabi2: enterprise is a tricky one, they can't always disclosure usage but it exists
19:36:46 <pharaun> yubiwasabi2: couple of 3d demo/quake alike games
19:36:53 <byorgey> jaredj: alternatively, if you have a record full of Maybe values, you can make a Monoid out of it and have the attribute parser return a record with all Nothings except a single Just corresponding to whichever attribute it saw
19:37:11 <byorgey> then just mconcat all of them to get a record with all the attributes seen
19:37:18 <jaredj> this is what i tried last time but i was missing the Monoid business
19:37:29 <yubiwasabi2> Haskell vs C++
19:37:36 <yubiwasabi2> What are the benefits?
19:37:38 <pharaun> now you're just trolling
19:37:42 <ArthurM> lol dude
19:37:43 <ArthurM> really?
19:37:50 <yubiwasabi2> yes really
19:37:54 <byorgey> it's a fair question.
19:38:15 <byorgey> yubiwasabi2: a strong and expressive type system, first class functions, no side effects
19:38:19 <yubiwasabi2> I want to know from the people who uses it not from some web page
19:38:36 <pharaun> hows it different from what is up on the webpage?
19:38:40 <byorgey> to name some of the (IMO) most important.
19:38:49 <pharaun> that webpage was written by people who uses the language :)
19:39:42 <pharaun> byorgey: curious, how do you use mconcat to get a record from a list of values ?
19:39:55 <byorgey> jaredj: see the first half of this post: http://byorgey.wordpress.com/2008/04/17/collecting-unstructured-information-with-the-monoid-of-partial-knowledge/
19:40:04 <byorgey> pharaun: no, you use mconcat to get a record from a list of records
19:40:05 <ArthurM> @yubiwasabi2 I personally like it because it allows me to work at a higher level of abstraction than most other languages, but it can still be blazingly fast.
19:40:05 <lambdabot> Unknown command, try @list
19:40:35 <yubiwasabi2> Thanks
19:40:38 <pharaun> byorgey: oh as in i "emit" a list of record from the parser, and each record has various field filled, then mconcat collapses it into a record with all fields filled out?
19:40:43 <byorgey> pharaun: you translate each value into a record which has Nothing in all the fields except the one field corresponding to that value
19:40:50 <byorgey> pharaun: exactly
19:40:52 <yubiwasabi2> Thanks byorgey
19:40:54 * ddarius wonders what the properties of the outer product of a vector with itself are w.r.t. diagonalization.
19:40:54 <pharaun> ahh gotcha
19:40:56 <pharaun> thanks byorgey
19:49:26 <jaredj> byorgey: so the only reason you went into the preorders and sets was so you could write your own criteria about which facts are your favorites, right?
19:51:17 <jaredj> so. leave the collection of partially-parsed things to parsec, that's not "state." "state" is .. only when i want my parser to behave differently depending on what it's seen?
19:52:58 <byorgey> jaredj: yeah, all the stuff about preorders and sets was just theoretically interesting.  I don't think I'd actually use it in real code.
19:53:07 <jaredj> ic
19:53:42 <jaredj> that post may make possible the completion of my OFX parser, long broken
19:53:48 <byorgey> jaredj: having your parser behave differently depending on what it's seen is the power given to you by the Monad interface.  It does not require state.
19:54:19 <byorgey> jaredj: really, you never *need* state.  Occasionally it can make things more convenient.
19:54:39 <byorgey> But such instances are (in my experience) rare
19:54:44 <jaredj> and parsec supports it for those rare occasions
19:54:56 <byorgey> I have written lots of parsec parsers and I think perhaps I've used state once
19:55:09 <byorgey> right
19:55:28 <byorgey> and I guess because it's not hard to support, so they figured why not add it
19:55:38 <byorgey> anyway, I'm off to bed
19:55:41 <byorgey> good luck with your parser!
19:56:51 <pharaun> oh yeah that reminds me, do you have any good advice
19:57:22 <jaredj> no
19:57:43 <jaredj> :)
19:57:50 <pharaun> on how to parse and stuff repeative data into records? ie - "foo|bar|blaz|datestamp" -> record { name: foo, where: bar, how: blaz, date: datestamp } ?
19:57:59 <pharaun> sorry hit enter too quickly :)
19:58:20 <jaredj> "foo|bar|blaz|datestamp" is a line of input, yes?
19:58:23 <pharaun> right now i'm just extracting each value between the |'s then storing them into a var then at the end stuffing it all into a record, but that seems repeative
19:58:29 <ddarius> You can use record types positionally.
19:58:30 <pharaun> yeah
19:58:37 <ddarius> Record constructors I mean.
19:58:42 <pharaun> ddarius: yeah i am doing that right now "record a b c d"
19:59:01 <rlpowell> I've found a bug in a library that I currently get with cabal ; I'd like to fix the bug.  How do I tell cabal to use a local source repo for a particular library?
19:59:04 <pharaun> but i was wondering if there was a good way to do the parsing -> value in a non-repeating manner
19:59:20 <ddarius> So record <$> parseName <*> parseWhere <*> parseHow <*> parseDate
19:59:32 <pharaun> oh
19:59:34 <pharaun> *facepalm*
19:59:37 <pharaun> thanks :)
19:59:44 <jaredj> wha
20:00:37 <parcs`>  @hoogle Storable a => (Ptr a -> IO ()) -> IO a
20:00:44 <parcs`> @hoogle Storable a => (Ptr a -> IO ()) -> IO a
20:00:44 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
20:00:44 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
20:00:45 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
20:02:11 <jaredj> whow.
20:03:54 <jaredj> has anyone ever tried to make a GPL with a definition of 'linking' that makes sense in Haskell?
20:04:10 <jaredj> er. LGPL?
20:06:23 <ParahSailin_> ##copyfree not copyleft
20:07:18 <pharaun> ddarius: ahh better, that works great <3 forgot bout applicative
20:10:06 <nanotech> jaredj: MPL looks like a possibility
20:16:09 <carter> ddarius one obvious property is its symmetric :)
20:16:23 <ddarius> Hence being diagonalizable
20:16:27 <zzing> Is there anything going on in the US today that would involve fireworks? I am hearing something that might be that, but I am curious
20:16:44 <carter> i've a few tomes where I can dig up all the properties
20:16:49 <carter> if you really liked
20:16:57 <ddarius> Labor day is coming up, but that's rarely a fireworks thing, not that Americans need much excuse to blow things up.
20:17:16 * carter stares at numerical algorithms haskell etc all day every day
20:17:17 <carter> :)
20:17:29 <ddarius> Really?
20:17:32 <zzing> I am in Windsor, ON by the bridge going over to Detroit, and for about ten minutes on and off there have been these bangs, some even feeling like percussions
20:17:36 <zzing> bizarre
20:17:36 <ddarius> (re staring at code)
20:18:54 <startling> zzing: memorial day is monday
20:19:12 <zzing> startling, is that special to them enough for fireworks?
20:19:23 <startling> zzing: yeah
20:19:36 <zzing> ok, then it is safe enough :P
20:19:44 <zzing> I am not within visible distance to know for certain about what it was
20:19:48 <startling> zzing: more like "long weekend, let's grill and get drunk and shoot fireworks!"
20:20:03 <zzing> hehe
20:24:25 <pharaun> pretty much
20:25:30 <carter> ddarius: ok, more like i'm working very hard (albeit slowly) at how to make it easier to them them in a high level way thats fast and easy and encourages things being correct
20:25:36 <carter> and that people would actualy use
20:27:32 <startling> er, I meant labor day of course
20:31:57 <dmwit> Well, none of the tests fail now. But some of them don't terminate any more. =P
20:32:13 <pharaun> heh
20:32:29 <startling> dmwit, prove it
20:32:55 <dmwit> I will, just as soon as I figure out why. =)
20:33:06 <dmwit> (It's possible this attempt will never terminate.)
20:33:13 <thirsteh> startling: call me if he does
20:33:18 <thirsteh> startling: http://en.wikipedia.org/wiki/Halting_problem
20:33:22 <dmwit> You guys.
20:33:35 <dmwit> The halting problem does not mean that you can't prove that any program doesn't terminate.
20:33:46 <dmwit> It means you can't check whether all programs terminate or not.
20:33:47 <thirsteh> true, it's just a general analysis
20:33:57 <thirsteh> but I thought it was moderately amusing
20:35:23 <pharaun> but dmwit should still try to generalize his proof ;)
20:35:44 <startling> thirsteh: that was the joke. :)
20:36:21 <thirsteh> startling: I couldn't tell if it was intentional or not, but since this is #haskell I guess I should have known better
20:37:18 <pharaun> heh #haskell is only for srs bsns
20:46:59 <jaredj> Dear diary: tonight I was in #haskell. It was a good discussion, if somewhat halting at times.
20:47:12 <startling> ;p
20:47:19 <jaredj> nanotech: thanks. i haven't read that one yet.
20:56:03 <ddarius> Ugh, hmatrix is going to kill me.
21:10:05 <carter> ddarius: whats it doing to you pray tell?
21:13:51 <Lajla> There used to be a #haskell-social channel or something,where is it?
21:14:00 <startling> Lajla: #haskell-blah
21:14:09 <Lajla> I approve of that name
21:14:35 <Lajla> bigger than I remember, meh
21:15:46 <carter> ddarius : ie whats the frustration with hmatrix? :)
21:19:10 <startling> #haskell is the only place use i.e. correctly.
21:19:14 <startling> *people use
21:20:06 <jaredj> high praise :)
21:20:39 <covi> getDirectoryContentsRecursive is in Distribution.Simple.Utils rather than System.Directory or System.FilePath. This is confusing.
21:22:14 <Lajla> @quote kukkua
21:22:14 <lambdabot> No quotes match. Maybe you made a typo?
21:22:19 <Lajla> @quote Kukkua
21:22:19 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
21:23:19 <covi> Darn I want to know what continuations are. Any recommendation for start?
21:24:15 <startling> covi: do you know scheme?
21:27:34 <covi> startling: I just started to learn that.
21:29:09 <startling> covi: http://community.schemewiki.org/?call-with-current-continuation
21:29:42 <yubiwasabi2> my mom said not to hang out with the Haskell crew, because they are to functional
21:30:22 <Lajjla> covi, ehhh
21:31:01 <Lajjla> Well, every language has continuations I guess, what makes scheme unique is that it has 'first class contiuations', as in, you can capture the conceptual idea thereof and pass them around as first class objects. Haskell's type system praevents this from happening in the truest sense.
21:31:19 <Lajjla> http://en.wikipedia.org/wiki/Continuation
21:31:33 <ddarius> The type system doesn't prevent this from happening.
21:31:52 <ddarius> SML/NJ has first class continuations and has pretty much the same type system as Haskell.
21:32:14 <Lajjla> Haskell aslo has 'first class continuations', but not in the scheme way as far as I know.
21:32:40 <Lajjla> I once read an argument why and what would go wrong, god knows if I can remember what it was though, but maybe I'm wrong.
21:33:00 <Lajjla> People tend to be wrong about haskell, and more often than not when they are it's a matter of definition of what is 'true continuation' I guess.
21:33:58 <ddarius> Unless they are very strongly controlled, first-class continuations destroy purity.
21:34:34 <Lajla> They mainly destroy code readability.
21:34:41 <Lajla> first class continuations are considered harmful.
21:35:23 <Lajla> covi, but ehh, say you have an expression x * y + z, x * y is computed first, the 'continuation' of that exprsesion is basically '* y', as in, what happens with the result of that exprssion, where it continues.
21:36:15 <Lajla> Sounds extremely boring but it's a way to model programming logic as basically a very large number of 'continuations', which basically leads to the 'continuation passing style' of compilers which basically don't have a call stack, gives you TCO for free.
21:36:38 <startling> covi: in its most primitive implementation, each function gets the next function to call as an argument
21:36:57 <covi> startling: what does that mean? like currying?
21:37:17 <startling> covi: so rather than x n = n + 3, you have x n fn = fn (n + 3)
21:37:18 <Lajla> Yeah, see it like ehh, if you have a 'return statement' in a function, do away with that, and replace it with calling a function with the return value as argument that basically repraesents what would happen aftyer the return statement
21:37:45 <Lajla> covi, technically, currying and CPS are mutally exclusive since in the most technical definition, CPs requires each function to have at least two arguiments.
21:38:13 <Lajla> One of the arguments being the' continuation'.
21:38:18 <ddarius> Lajla: It doesn't give you tail call optimization at all.  It turns all calls into tail calls, so it eliminates the stack (by representing it as linked closure environments.)
21:38:26 <startling> Lajla: what about nullary functions?
21:38:26 <covi> Alright. I see it's an old concept.
21:38:32 <startling> covi: yeah.
21:38:54 <startling> covi: you can do it very nicely with a reader or state monad
21:38:54 <Lajla> ddarius, well, the fact that those compilers don't have a call stack give you TCO I mean.
21:39:19 <startling> I always accidentally implement continuations writing javascript. :S
21:39:21 <Lajla> startling, well, some definitions of CPS actually use those for if/then/else logic.
21:39:29 <ddarius> Lajla: Only if they do TCO already.
21:39:51 <startling> Lajla: yeah, cps doesn't give you tco. it makes you need tco really badly in fact
21:40:06 <Lajla> ddarius, well, let me put it like this, if you are writing a compiler in CPS, it's harder to actually give it a call stack than to not give it one.
21:40:45 <Lajla> As in, you don't need a call stack if your code is first transforemd to CPS
21:40:46 <ddarius> Lajla: No it isn't.  Just call the continuations like any (C) function.  I assure you, it will use call stack.
21:40:54 <Lajla> Of course
21:41:07 <Lajla> But that's not what I said.
21:41:16 <ddarius> Lajla: You don't need a call stack, but calls are still not tail call optimized unless you tail call optimize them.
21:41:47 <Lajla> Obviously, but assembly doesn't give you a call stack on its own or even knows what function calls are natively.
21:41:57 <ddarius> It is no harder or easier to implement TCO whether or not you use CPS.
21:42:06 <Lajla> What I'm saying is that if you make a compiler transform to CPS. You don't even need to concern yourself with making a callstack in your run time
21:42:22 <Lajla> In that sense it gives you TCO "for free", as in, it's very easy to make it that way, as well as first class continuations
21:42:56 <Lajla> It's harder to not get TCO than to get TCO if you first transform your code to CPS (unless of ycourse you compile to another language and use that runtime and that language doesn't have TCO)
21:42:58 <ddarius> Lajla: You didn't need to worry about that anyways unless you went out of your way to reify the stack.  Again, CPS doesn't make implementing TCO any easier.
21:44:06 <Lajla> I beg to differ, as I said, if you have CPS you don't even need to make a call stack in your run time, if you don't have it and you don't make a call stack, well, then functions can't return.
21:44:12 <ddarius> I guess if you are extremely uniform and never call system/foreign functions, then you don't have to worry about the non-tail call case, and can just immediately translate all calls to jumps rather than knowing that they are tail calls.
21:44:23 <Lajla> Indeed
21:44:32 <Lajla> That's the point of CPS, it guarantees that all calls are tail calls
21:44:44 <startling> Lajla: what? no it doesn't
21:44:58 <Lajla> Yes it does, in a program in CPS, every call is a tail call.
21:45:01 <Lajla> That's the idea of CPS.
21:45:04 <ddarius> startling: Yes it does.  It doesn't make them optimized, but they are all in tail position (except the ones that aren't.)
21:45:18 <Lajla> If they aren't all in tail position it's not true CPS.
21:45:34 <startling> oh, I see what you mean
21:45:43 <Lajla> So whatever you use in your runtime  to handle function calls doesn  need to consider non tail calls and therefore can simply be gotos that transport variables.
21:45:43 <startling> hmm, never thought about / realized that
21:45:54 <Lajla> Which gives you TCO in a very straightforward and easy manner.
21:46:15 <Lajla> Assuming you have a program in full cPS, it's harder to make it stack overflow than it is to not make it stack overflow basically.
21:46:58 <ddarius> Except that in reality, you 1) have other things you need to call and 2) recognizing tail calls is a trivial syntactic property so it's not like it was hard anyway.
21:47:49 <ddarius> Also, in many cases, it's desirable to minimize the code that is actually CPS because the hardware stack is much more efficient (in most cases) than a chain of closure environments (or however you represent free variables.)
21:47:52 <Lajla> I don't know, a lot of things that don't use CPS had to use pretty creative things to get TCO, especially if they compile to C, but then again, if you compile to C my point is pretty moot, I was talking to assembly.
21:49:51 <ddarius> I would say most compilers that use CPS representations internally do so to either implement continuations or simply as a variant of administrative normal form because another property of CPS is all intermediates get named.
21:50:24 <poliquin> Could some kind soul help me with a toy Monad?
21:50:27 <ddarius> But again, CPS is not the same as having first-class continuations, it's a means of implementing/understanding them.
21:50:28 <hpaste> poliquin pasted “Monad Woes” at http://hpaste.org/74092
21:51:22 <Lajla> ddarius, indeed.
21:52:23 <Lajla> I'm not sure if it's that much more efficient, I read some debate on why Racket doesn't use it but god knows if I can remember.
21:52:35 <Lajla> I do know that apparently the only reason Python doesn't have TCO is because of descriptive error messages.
21:52:48 <startling> Lajla: it's more complicated than that
21:52:52 <ddarius> Lajla: That's the only credible argument, not the only reason...
21:53:23 <startling> poliquin, don't put constraints on data
21:53:31 <Lajla> That's apparently what Guido keeps repeating when people bring it up.
21:53:54 <Lajla> And who would not trust a Dutchman with a beard like Dijkstra?
21:54:04 <Lajla> Seems legit
21:54:07 <poliquin> startling, I think I tried that already.
21:54:10 <lightquake> i've decided that guido doesn't actually know things about functional programming
21:54:11 <ddarius> Lajla: Plenty of people have provided a variety of ways to mitigate that problem.  Guido is just not interested in it.
21:54:14 <startling> poliquin: try it again
21:54:25 <ddarius> poliquin: What you are defining is not a monad.
21:54:27 <Lajla> Ohh, conspiracy theories.
21:55:19 <startling> Lajla: pypy has an interesting approach, though
21:55:21 <poliquin> startling, I tried it and it complains about Ord since I'm using (<)
21:55:36 <Lajla> startling, what is it?
21:55:56 <Lajla> And meh, whenever I work in python I just feel it tries to be a worse javascript.
21:56:02 <poliquin> ddarius, I tried to make it a Monad :-)
21:56:06 <startling> poliquin: so add an Ord constraint to the place you get the thing that you < on
21:56:20 <shachaf> Lajla: If you look at the original design documents for Python, that's written there.
21:56:27 <shachaf> "Goal 2: Be a worse JavaScript"
21:56:40 <Lajla> Ahahah
21:56:56 <startling> Lajla, lemme try and find a source. the upshot is that calls are basically free
21:56:57 <jaredj> Lajla: what's worse than javascript?
21:57:02 <poliquin> startling, it wants the Ord constraint on (>>=) which is a system define
21:57:10 <Lajla> Python sort of got itself stuck I feel, like ehh, how they added the conditional expression.
21:57:17 <tswett> poliquin: I'm pretty sure that a Monad must be able to take any type whatsoever.
21:57:25 <ddarius> poliquin: I'm saying even if you get it to compile, what you are defining fails the monad laws in ways that make it non-sensical.  In fact, it's just a non-sensical thing to attempt to make into a monad.
21:57:26 <pharaun> Lajla: what do you mean by stuck?
21:57:31 <startling> yeah, you need to be able to return anything
21:57:35 <Lajla> jaredj, well, in Javascript you have x ? y : z, that sort of amkes sense, in ypthon you have y if x else y, that is bizarre
21:57:38 <tswett> poliquin: Guard can't take any type whatsoever; it can only take types that are both Num and Ord.  So, you can't make it an instance of Monad.
21:58:02 <Lajla> pharaun, I mean that they added so much syntactic elements that ti's hard to add new ones without being ambiguous or causing other problems
21:58:03 <startling> Lajla: huh?
21:58:11 <Lajla> Yeah, the conditional expression of python
21:58:13 <pharaun> Lajla: ah
21:58:17 <jaredj> (yes, yes, the problem is the DOM not the language)
21:58:18 <Lajla> It was added later
21:58:28 <poliquin> Ok .. I'll go back to the drawing board .. I was trying to start from ground zero.
21:58:31 <pharaun> Lajla: hence all of the breaking change for py3 ?
21:58:33 <Lajla> (lambda in python can only have xpressions and for a long time there was no conditional expression)
21:58:35 <ddarius> jaredj: Javascript certainly has its problems.
21:58:37 <startling> Lajla: no, how is " y if x else y" more bizzare than x ? y : z
21:58:38 <poliquin> More reading I guess is in order.
21:58:38 <startling> ?
21:58:46 <MostAwesomeDude> Could guys take it to #python?
21:58:47 <jaredj> Lajla: yes, foo if bar else baz sucks.
21:58:49 <poliquin> Thanks very much for the comments!
21:59:01 <Lajla> startling, it's most unintuitive that the condition is in the middle
21:59:10 <tswett> You could say it's rather...
21:59:16 * tswett puts on sunglasses and makes the obvious pun.
21:59:25 <Lajla> For generations, the condition has been the first, then the true arm, then the false arm.
21:59:30 <jaredj> Lajla: yes, lambda also sucks. or rather, statements vs expressions suck
21:59:37 <Lajla> Yeah
21:59:46 <Lajla> but they couldn't just make the conditional statement also an expression a la algol
21:59:53 <Lajla> Because indenting eh.
22:00:00 <shachaf> Instead of #python, how about #/dev/null?
22:00:11 <shachaf> That's a good channel for talking about how bad other languages are.
22:00:17 <jaredj> spoilsports
22:00:34 <tswett> So, I've been pondering how many data types in Haskell are practically impossible to store.
22:00:36 <jaredj> oh well i have to take it to #zzz anyway
22:00:51 <startling> tswett: lots
22:00:57 <ddarius> tswett: Serialize you mean?
22:00:58 <tswett> s/how/the fact that/
22:01:01 <tswett> ddarius: yeah.
22:01:04 <startling> oh
22:01:06 <startling> yeah
22:01:07 <tswett> Int -> Int, for example.  If a Haskell function is given an Int -> Int, it has no reasonable way of determining everything about it.
22:01:18 <startling> too bad we can't have function inspection
22:01:23 <ddarius> tswett: That's true is most languages.
22:01:27 <ddarius> It's also a good thing.
22:01:27 <startling> tswett: sure you do! mapping over the domain
22:01:33 <tswett> IO Int, as well.  And, a bit more amusingly, Socket.  It doesn't really make sense to store a Socket.
22:01:38 <ddarius> tswett: Not that [Int] also has problems.
22:01:48 <startling> tswett: IO anything, tbh
22:02:03 <startling> tswett: also, lots of monads are functions under the covers
22:02:11 <ddarius> tswett: Again, it's generally true that serializing a Socket or a Handle doesn't make sense well beyond Haskell.
22:02:19 <tswett> And this makes me think of how some languages, like Coq, have types that can scarcely be said to contain data at all.
22:02:22 <ddarius> s/Not/Note/
22:02:44 <tswett> For example, there's a type called RealNumber that can, in theory, hold any real number.  Including uncomputable ones.
22:02:49 <startling> anyway, it would be cool if we could mark or prove injectivity and surjectivity
22:03:18 <tswett> You could define a type representing sets within ZFC.
22:03:52 <tswett> And that makes me wonder, does Haskell have any types that can't be serialized because they don't actually contain data?
22:04:01 <ddarius> data Void;
22:04:04 <startling> tswett, IO
22:04:27 <tswett> ddarius: on the contrary.  serialize _ = undefined; serializes that one perfectly.
22:04:44 <ddarius> tswett: You mean deserializes.
22:05:12 <tswett> serialize :: Void -> ByteString; serialize _ = undefined
22:05:21 <tswett> Looks to me like it serializes.
22:05:35 <ddarius> That certainly doesn't produce something I can write to afile.
22:05:48 <ddarius> serialize :: (Int -> Int) -> ByteString; serialize _ = undefined
22:06:05 <mikeplus64> serialize _ = error "you cannot meaningful serialize Void"
22:06:11 <ddarius> mikeplus64: Sure you can.
22:06:18 <tswett> Sure it does.  Give me a valid value of Void that it does not serialize correctly...
22:06:32 <tswett> Though I have to say, I prefer this implementation for some purposes:
22:06:34 <ddarius> tswett: serialize should be a total function.
22:06:46 <tswett> serialize :: Void -> ByteString; serialize = unsafeCoerce
22:06:56 <tswett> ddarius: it is.  const undefined is total over Void.
22:07:00 <startling> serialize (x :: Void) = "void"
22:07:01 <ddarius> Say I want to serialize with a representation of the type being serialized, then serialize _ = pack "Void"
22:07:05 <lightquake> tswett: give it a value that it does serialize correctly!
22:07:11 <startling> ddarius: :)
22:07:32 <tswett> lightquake: I'd have to think about it for a while.  ^_^
22:07:45 <ddarius> tswett: No, const undefined is certainly not total.
22:08:43 <shachaf> ddarius: (const undefined :: Void -> Void)?
22:08:55 <shachaf> Or :: Void -> a, I guess.
22:08:57 <ddarius> shachaf: const undefined :: Void -> ByteString
22:09:21 <shachaf> Why is that "not total"?
22:09:23 <tswett> ddarius: how about this one, then.
22:09:39 <ddarius> shachaf: Because it is undefined for an argument.
22:09:39 <tswett> serialize :: Void -> ByteString; serialize | False = undefined
22:09:57 <tswett> ddarius: now it doesn't matter that undefined isn't total, because it's never used.
22:10:28 <Saizan> tswett: i think ddarius is only caring about the extensional properties of such a function
22:11:18 <shachaf> ddarius: Which argument?
22:11:25 <ddarius> undefined
22:11:37 <shachaf> Ah.
22:11:42 <ddarius> It is completely reasonable to have serialize :: Void -> ByteString produce a ByteString.
22:11:54 <shachaf> Fair enough.
22:12:11 <ddarius> To follow Robert Harper, the fact that all types in Haskell contain bottom has problems.
22:12:32 <tswett> This makes it difficult to serialize Bool.
22:12:54 <pharaun> bottom is the inverted T ?
22:12:59 <lightquake> yep
22:14:08 <tswett> Mostly-unrelatedly, the STM monad seems utterly impossible to implement.
22:14:10 <ddarius> The more interesting case that I alluded to earlier is [Int] is not (fully) serializable because you can't generally serialize things like repeat 0.
22:14:25 <shachaf> tswett: Why?
22:14:36 <ddarius> tswett: It's non-trivial, well, to do it well, but it's obviously possible.
22:14:49 <ddarius> It's actually completely trivial to do a shitty job.
22:15:10 <tswett> Yeah, just use a semaphore that atomically raises and then lowers.
22:15:21 <startling> ddarius, you just serialized it !
22:15:37 <shachaf> ddarius: You mean with a global lock?
22:15:42 <ddarius> startling: Hence saying "things like".
22:15:43 <ddarius> shachaf: Yes.
22:15:59 <lightquake> every haskell value can be serialized! just capture the state of the CPU/memory at the moment you want to serialize it
22:16:02 <shachaf> There's a pure-Haskell implementation of STM in some issue of TMR.
22:16:32 <tswett> Hm.  And now I can't figure out what seemed so impossible about it.
22:16:36 <startling> seems like it'd be pretty easy to write an inefficient implementation
22:16:53 * ddarius recommends Keir Fraser's thesis.
22:16:57 <tswett> ST, on the other hand, seems pretty impossible to implement.
22:17:22 <Saizan> it's a bitch to get it to typecheck
22:17:37 <ddarius> tswett: It is impossible to implement that without using unsafeCoerce or changing the API (or using equivalent things like IORefs).
22:17:59 <dolio> Well, STM has the same problem, then.
22:18:37 <Saizan> ST is doable in a language with internalized parametricity
22:18:40 <ddarius> dolio: Under those assumptions, yes, but it's reasonable to implement STM on top of IO and to use IORefs.
22:19:13 <tswett> I guess ST with unsafeCoerce seems pretty easy.
22:19:44 <ddarius> Whereas it's less reasonable to do the same thing (and would require unsafePerformIO) to do the same for ST and have it elucidate much.
22:20:04 <tswett> type ST s a = IO a; type STRef s a = IORef a; newSTRef = newIORef; readSTRef = readIORef; writeSTRef = writeIORef; runST = unsafePerformIO
22:20:54 <tswett> I think that's a perfectly valid implementation, but it didn't actually elucidate anything.
22:20:54 <dolio> That's not the implementation with unsafeCoerce.
22:20:54 <ddarius> tswett: It's pretty much the actual implementation.
22:20:59 <tswett> dolio: true.
22:21:07 <ddarius> IORefs are special cases of STRefs.
22:21:10 <ddarius> (In GHC)
22:22:14 <tswett> Now, is there any particular reason we can't convert from IO to ST RealWorld?
22:22:15 <tswett> It's not obvious how things would go wrong.
22:22:15 <dolio> Saizan: It is?
22:22:15 <ddarius> @hoogle stToIO
22:22:15 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
22:22:15 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
22:22:15 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
22:22:31 <tswett> @hoogle ioToST
22:22:31 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
22:22:31 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
22:22:31 <lambdabot> GHC.Conc.Sync unsafeIOToSTM :: IO a -> STM a
22:22:40 <tswett> Not quite what I was after.
22:22:45 <ddarius> @hoogle Primitive
22:22:45 <lambdabot> Graphics.Rendering.OpenGL.GLU.Tessellation Primitive :: PrimitiveMode -> [AnnotatedVertex v] -> Primitive v
22:22:45 <lambdabot> Graphics.Rendering.OpenGL.GLU.Tessellation data Primitive v
22:22:46 <lambdabot> package primitive
22:22:52 <ddarius> @hackage primitive
22:22:52 <lambdabot> http://hackage.haskell.org/package/primitive
22:24:04 <ddarius> @src IO
22:24:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:24:07 <tswett> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:24:54 <tswett> newtype ST s a = ST (STRep s a); type STRep s a = State# s -> (#State# s, a#)
22:25:14 <Saizan> dolio: http://code.haskell.org/~Saizan/ST/ST.agda <- i got this, the universe can't contain ST itself though if you want to keep the whole thing terminating
22:25:36 <pharaun> a dumb question - Is there a better way to express this - flag <- many1 digit ; let word8Flag = fromInteger $ read flag :: Word8
22:26:03 <Saizan> dolio: the irrelevance is mostly used to show the proofs i get from parametricity aren't computationally relevant
22:26:42 <lightquake> pharaun: word8Flags <- fromInteger . read <$> many1 digit
22:27:00 <pharaun> lightquake: thanks! doh forgot the . :)
22:27:04 <Saizan> > read "0" :: Word8
22:27:05 <lambdabot>   0
22:27:14 <shachaf> fromInteger <$> read <$> many1 digit
22:27:16 <Saizan> > read "1000" :: Word8
22:27:17 <lambdabot>   232
22:29:49 <shachaf> fmap fmap fmap fmap fmap fromInteger read (many1 digit)
22:29:58 <shachaf> How do you get rid of those last parentheses?
22:30:09 <covi> shachaf: $?
22:30:17 <tswett> So it seems like with GHC, at least, it would be completely possible to define the functions getWorld :: IO (State# RealWorld) and putWorld :: State# RealWorld -> IO ().
22:30:20 <shachaf> No, that still has parentheses, they're just implied.
22:30:40 <ddarius> @google okasaki flattening combinators
22:30:42 <lambdabot> http://www.westpoint.edu/eecs/SitePages/Chris%20Okasaki.aspx
22:30:42 <lambdabot> Title: Department of Electrical Engineering and Computer Science - Chris Okasaki
22:30:46 <shachaf> I want the tree to be the shape of a list.
22:31:11 <Saizan> ?pl \x y -> fmap fmap fmap fmap fmap fromInteger read (x y)
22:31:11 <lambdabot> (fmap (fmap fromInteger read) .)
22:31:25 <amiller> shachaf, like a rose tree?
22:31:28 <Saizan> not helping
22:31:31 <tswett> So what would happen if you ran do putStr "one"; world <- getWorld; putStr "two"; putWorld world; putStr "three"?
22:31:33 <shachaf> ddarius: 404
22:31:41 <shachaf> amiller: No, like a linked list.
22:31:44 <ddarius> shachaf: I just went to it and it worked fine.
22:31:54 <shachaf> ddarius: The website is OK but the PDF it links to isn't.
22:31:56 <ddarius> Or do you mean the specific paper link.
22:32:13 <ddarius> @google okasaki flattening combinators -west -point
22:32:14 <lambdabot> http://catamorphism.net/fpb/haskref.cgi?query=entry&key=journals/jfp/Okasaki03
22:32:26 <pharaun> > read "100" :: Word8
22:32:27 <lambdabot>   100
22:32:36 <pharaun> > fromInteger 100 :: Word8
22:32:37 <lambdabot>   100
22:33:19 <shachaf> amiller: I mean a tree of the form (Branch (Leaf a) (Branch (Leaf b) (Branch (Leaf c) (Leaf d))))
22:33:25 <shachaf> ...Or something like that.
22:33:34 <Saizan> tswett: i think GHC would then be free to run putStr "three" befor putStr "two"
22:33:59 <Saizan> tswett: i.e. the optimizer wouldn't see why not
22:35:23 <ddarius> @google techniques for embedding postfix languages in haskell
22:35:24 <shachaf> Aha: http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp03flat.pdf
22:35:25 <lambdabot> http://dl.acm.org/citation.cfm?id=581690.581699
22:35:25 <lambdabot> Title: Techniques for embedding postfix languages in Haskell
22:35:54 <shachaf> amiller: (Er, except the tree I described has maximal parentheses. But the point stands.)
22:36:23 <amiller> but who's counting :p
22:37:49 <ddarius> @google Ralf Hinze typed antiquotation
22:37:51 <lambdabot> http://www.cs.ox.ac.uk/ralf.hinze/publications/Quote.pdf
22:37:51 <lambdabot> Title: FUNCTIONAL PEARL Typed Quote/Antiquote Or: Compile-time Parsing
22:41:07 <tswett> Saizan: that makes sense.
22:41:23 <tswett> It wouldn't be guaranteed to skip over "two", but it wouldn't be prohibited from doing so, either.
22:41:39 <isBEKaml> hi, how do I make a library that's already available on my filesystem accessible to cabal (this is directly from haskell platform) ? https://gist.github.com/3595096
22:41:49 <hpaste> pharaun pasted “word8” at http://hpaste.org/74093
22:42:06 <pharaun> I'm trying to understand that type error, i tried to put in :: Word8 in various spot
22:42:09 <pharaun> and it keeps on choking
22:43:12 <dmwit> isBEKaml: "Perhaps you need to add `haskell98' to the build-depends in your .cabal file."
22:43:25 <dmwit> isBEKaml: Though, really, the right thing is probably to migrate the source code to hierarchical modules instead.
22:43:33 <dmwit> i.e. import System.IO instead of IO
22:43:43 <Saizan> tswett: though maybe not, because to get to putWorld you can't really ignore putStr "two"
22:44:14 <isBEKaml> dmwit: I saw that, but didn't want to add a cabal dependency, since this worked out of the box with ghc 6.12.3
22:44:26 <Saizan> tswett: we'd have to inline stuff and do some strictness analysis :)
22:44:28 <tswett> Saizan: well, I just tried it.
22:44:35 <tswett> It did, in fact, output "two".
22:45:55 <dmwit> I am too lazy to explain the details of the base/haskell98/haskell2010 trifecta. Just Google it.
22:45:55 <lightquake> pharaun: you can either put the :: Word8 on the left side, and enable ScopedTypeVariables
22:45:56 <isBEKaml> dmwit: yes, Pugs.Compat.Posix uses *both* System.IO and IO. `import IO; import System.IO `
22:46:41 <lightquake> or do something like word8Flags <- fromInteger . read <$> many1 digit :: Parsec something Word8
22:46:48 <dolio> Saizan: Interesting. I think I have a rough idea of what's going on.
22:46:56 <lightquake> where 'Parsec something' is replaced by... whatever monad that is
22:47:02 <isBEKaml> dmwit: Okay, this is the first time I'm building haskell stuff on windows. GHC 6.12.3 was on slackware linux
22:47:11 <pharaun> lightquake: ahh i see doh
22:47:14 <dmwit> This is not related to operating system.
22:47:24 <lightquake> pharaun: also, I think that you can replace fromInteger . read with just read
22:48:14 <shachaf> Well, that depends on your Num and Read instances.
22:48:25 <lightquake> well, yes
22:48:32 <lightquake> in this specific case, i think it works
22:48:42 <tswett> data MutVar# s a;
22:48:47 <tswett> I'm not sure what I was expecting.
22:49:02 <pharaun> i was able to get it to work via - word8Flag <- fromInteger <$> read <$> many1 digit :: GenParser Char st Word8
22:49:27 <lightquake> yeah, the readsPrec instance for Word8 just invokes fromInteger internally
22:49:30 <pharaun> I'm trying to stay away from GHC extension if possible/reasonably :)
22:49:57 <lightquake> meh, ScopedTypeVariables is pretty low on the list of evilness; iirc it's only off by default because enabling it would break some code
22:50:09 <lightquake> wait, no it wouldn't because of explicit forall
22:50:25 <ddarius> Extensions are typically not on unless requested.
22:51:06 <Saizan> dolio: i was a bit disappointed that i couldn't get away without the fixed universe
22:51:15 <dmwit> It's off by default because it's not in the spec. =)
22:51:27 <dolio> Is that necessary?
22:51:34 <dolio> Or just because of size?
22:53:51 <dolio> If it's necessary, then I'm less excited.
22:54:18 <dolio> Because I know you can do it with Typeable, but that's not implementing ST's signature.
22:55:29 <Saizan> i'm not actually comparing tags though, it's just that a Set instead of an U would give me a parametricity theorem with some fresh predicates which i don't know how to handle
22:56:07 <randomclown> what does | r -> a mean in "class BuildList a r | r -> a where"
22:56:19 <dolio> Oh.
22:56:33 <ddarius> randomclown: It's a functional dependency.
22:56:36 <shachaf> randomclown: Functional dependency.
22:56:50 <dolio> Saizan: Okay, that's what it looked like you were doing.
22:57:08 <randomclown> right
22:58:01 <dolio> Showing that your integer indexing scheme worked out because something that works forall s can't generate its own indices based on s or something.
22:58:13 <dolio> Er, natural.
22:59:51 <Saizan> yes, i'm showing that calls to read and write must be "well-scoped" with new being the only binder
23:01:03 <Saizan> so i don't have to check type tags, type-correctness is ensured by the context
23:03:29 <Saizan> the trick is that when you expand the context with a new you want to know the old references keep being well-scoped, and that's why i have the "FreesExp" stream
23:04:44 <Saizan> i don't remember where to point in the code to show how this gets hard without the universe
23:10:16 <dmwit> Okay, right, so: threeSeconds v = do { done <- newEmptyMVar; forkIO (threadDelay 3e6 >> putMVar done False); forkIO (evaluate v >> putMVar done True); takeMVar done }
23:10:50 <dmwit> Sort of works, except if it takes more than three seconds, it keeps running and never notices that it's about to block on a garbage-collected MVar.
23:11:14 <dmwit> (So threeSeconds returns, but another thread is still pegging a core.)
23:11:16 <dmwit> wat do
23:12:38 <Enigmagic> let v' = System.Timeout.timeout 3e6 (evaluate v)
23:12:39 <Enigmagic> ?
23:12:55 <dmwit> ...neat
23:33:32 <sheldonh> the real world haskell book introduces anonymous functions *way* too late
23:34:48 <n00b6502> it doens't need them as much because of currying perhaps
23:35:51 <sheldonh> hmmm, mebbe. i'm finding it much easier to play around in ghci now that i know the lambda syntax
23:37:08 <sheldonh> i suppose any haskell book has to deal with the challenge that syntax in ghci is different from that in source files, and RWH opts for getting into source files as quickly as possible
23:37:19 <n00b6502> currying is more elegant,where it can be done,since one doesnt ahve to name a temporary
23:37:45 <n00b6502> (ah.. of course not just currying, but composition)
23:38:15 <sheldonh> n00b6502: i agree. i would be careful about lambda abuse in source code, because of the risk of reduced readability. but in ghci, they're incredibly useful for exploring functions that take functions :)
23:38:27 <ddarius> sheldonh: Recent versions of GHC have dramatically expanded the language GHCi accepts.
23:38:32 <hpaste> rosie pasted “map” at http://hpaste.org/74095
23:38:40 <ddarius> n00b6502: currying is what curry does.
23:38:59 <n00b6502> partial application / currying / whatever its called
23:39:00 <startling> ddarius: getting a language named after you?
23:39:06 <sheldonh> ddarius: i think the big stumbling block for newcomers is the behaviour of let in ghci :)
23:39:16 <ddarius> startling: He has, at least, two languages named after him.
23:39:41 <startling> oh huh
23:39:44 <ddarius> sheldonh: With luck, the input syntax will change in GHCi to be identical to Haskell in the not too distant future.
23:39:53 <rosie> I would like to include a few statements of a monad may times, by mapping over a list, and then outputting those lines of the monad… Does that make sense? Essentially I want the result of the map to be not an array, but a series of statements in a do block. How can I achieve that?
23:40:20 <startling> rosie: mapM
23:40:28 <startling> :t mapM
23:40:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:40:35 <sheldonh> ddarius: that will be a improve the learning experience appreciably :)
23:40:44 <startling> rosie: also sequence
23:40:47 <startling> :t sequence
23:40:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:41:32 <ddarius> n00b6502: "(Partial) application" is what you wanted.  Though "partial" application is just application.
23:41:33 <startling> rosie: all in Control.Monad
23:42:34 <rosie> startling: awesome. works, thanks
23:43:21 <n00b6502> couldn't be arsed typing "partial application" where "currying" would get the point across, although thanks for drawing me in to waste even more keystrokes
23:43:34 <startling> lol
23:50:22 <amiller> so, does anyone want to predict what the difference will be between Monad m => Trunk :. m   and  Monad m => m :. Trunk?
23:51:08 <amiller> i've made it all the way through with one of those, but it was a learning experience since i wasn't sure where each step led
23:51:52 <Cale> What is Trunk?
23:52:07 <amiller> data Trunk x = Tip | Bin x x
23:52:51 <amiller> also Functor Trunk where fmap _ Tip = Tip; fmap f (Bin x y) = Bin (f x) (f y)
23:53:27 <ddarius> amiller: That's the only possible functor implementation that satisfies the laws.
23:53:29 <Cale> and I assume you have something like  newtype (f :. g) a = C (f (g a))
23:53:49 <amiller> ddarius, good point, does that make it the free functor?
23:54:01 <ddarius> amiller: No.
23:56:59 <amiller> hrm, i suppose any datatype with arity 1 would be a functor for the same reason
23:57:43 <ddarius> amiller: No, that's not the case either.
23:57:55 <sheldonh> datatype with arity. that's not something you hear very often in ruby :)
23:58:10 <amiller> it's probably not something you hear a lot in haskell either, i don't know what i'm doing :p
23:58:22 <amiller> (not that that will stop me)
23:58:25 <sheldonh> :)
23:58:37 <sheldonh> amiller: don't worry, when you need to learn more, haskell will let you know ;)
23:58:56 <ddarius> But certainly all regular data types are functors in only one way which is extremely systematic.
23:59:40 <ddarius> But newtype X a = X (a -> a) is not a functor at all nor is newtype C a = C (a -> Bool), though the latter is a contravariant functor.
