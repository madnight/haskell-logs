00:00:13 <kallisti> but inheritance is not a single technique
00:00:22 <kallisti> which is a pretty major difference.
00:01:12 <meiji11> yeah, typeclasses seem much cleaner than C++ style inheritance. even java, with only single inheritance, is kind of a nightmare..
00:01:53 <hpaste> startling pasted “Lenses into Maybe (Either a b)” at http://hpaste.org/74894
00:02:01 <startling> can anyone write these more nicely?
00:02:36 <startling> The `case` is pretty ugly, but anything else I came up with was super verbose.
00:02:44 <kallisti> what kind of lens?
00:02:51 <startling> I `lens` lens.
00:02:57 <startling> *A `lens` lens.
00:04:17 <startling> the trickiest part is that "set left Nothing" shouldn't modify a Just (Right x), in order to follow the lens laws.
00:04:46 <Nereid> Maybe (Either a b) is isomorphic to Either (Maybe a) b.
00:05:17 <ivanm> Nereid: is it? I can see applying different reasonings to Maybe (Either a b) than Either (Maybe a) b
00:05:29 <Nereid> they're both 1 + a + b
00:05:42 <ivanm> oh, is this specifically for lenses?
00:05:47 <startling> Nereid, sure, how's that relevant?
00:05:48 <shachaf> And now you've got 13 tens and you take away 7 and that leaves 5.
00:05:56 <Nereid> startling: so if you have a lens for Either then you're done.
00:06:04 <startling> Nereid, not true
00:06:10 <Nereid> via that iso
00:06:11 <Nereid> why not?
00:06:19 <startling> Nereid, you can't follow the lens laws with a general lens for either
00:06:36 <edwardk> startling: there are two traversals for Either, but alas, no lenses =)
00:06:54 <startling> edwardk: exactly! but there are two lenses for Maybe (Either a b)
00:07:03 <shachaf> edwardk: What a traversty!
00:07:04 <startling> Nereid, what happens if you "set left Nothing" where left is a Simple Lens (Either a b) (Maybe a) ?
00:07:12 <edwardk> traverseLeft :: Traversal (Either a b) (Either c b) a c
00:08:24 <Nereid> startling: yeah I'm dumb.
00:09:02 <Nereid> dunno why I thought there were lenses for Either.
00:09:30 <shachaf> I guess lenses aren't great at sum types.
00:09:49 <Nereid> dumb idea: Maybe (Either a b) + (a,b) is isomorphic to (Maybe a, Maybe b).
00:09:57 <Nereid> does this help?
00:09:58 <Nereid> who knows
00:09:58 <shachaf> edwardk: Is there a dual of lenses that works for the dual of products? :-)
00:10:02 <Nereid> probably doesn't
00:10:11 <mgsloan> shachaf: traversals are pretty good at sum types :D
00:10:25 <edwardk> Nereid: there is a lens for Either, given a lens into a, and a lens into b, both that return the same type c, then you can have a lens into (Either a b) its called merging in 2.9   and there is merged :: Lens (Either a a) (Either b b) a b
00:10:39 <startling> Nereid, then you can have (Just a, Just b), which is nonsensical for my application
00:10:52 <startling> it's really just a trinary Maybe.
00:10:57 <Nereid> I know.
00:11:04 <Nereid> I did say it was a dumb idea.
00:11:28 <edwardk> shachaf: probably not. you can work with something like multiplate though.
00:11:51 <startling> anyway ya'll, any suggestions? http://hpaste.org/74894
00:12:45 <startling> am I alone in feeling like "case (e, m) of..." is a dirty hack?
00:14:35 <edwardk> i think left and right aren't legal lenses
00:14:51 <startling> edwardk, which law do they break?
00:15:09 <startling> edwardk, I went through them all and played with them, but I may have missed something
00:16:00 <edwardk> start with Maybe (Right b), set left Nothing, then read, what do you get?
00:16:25 <startling> Maybe (Right b)
00:16:49 <edwardk> er set left Nothing (Just (Right b))^.left /= Nothing. you violate the set/view law
00:16:59 <edwardk> setting and then getting, should get back what you set
00:17:17 <startling> edwardk, view left (Just (Right b)) *is* Nothing
00:17:53 <Fuuzetsu> @src ($!)
00:17:53 <lambdabot> f $! x = x `seq` f x
00:18:10 <edwardk> ok i picked the wrong law that is broken then =)
00:18:15 <edwardk> one of them is borked though
00:18:55 <startling> edwardk, I'm not seeing it
00:19:15 <edwardk> the problem isn't in the Nothing case, its in the Just case. you're losing some information about b.
00:19:32 <edwardk> you need two law applications to find it though.
00:19:57 <startling> edwardk, oh?
00:20:05 <edwardk>  you need the fact that setting twice should be the same as second the second way once.
00:20:17 <mgsloan> I think "Maybe These" would be lensable to Maybes https://github.com/isomorphism/these/blob/master/Data/These.hs#L51
00:20:27 <Nereid> right
00:20:29 <shachaf> @where these
00:20:29 <lambdabot> data These a b = This a | That b | These a b
00:20:33 <mgsloan> (this is trivial from it being equivalent to (Maybe a, Maybe b))
00:20:34 <Nereid> so setting Just (Right x) and then Nothing
00:20:37 <Nereid> would do the wrong thing
00:20:43 <shachaf> Maybe (These a b) = (Maybe a,Maybe b)
00:20:45 <startling> edwardk, in which case isn't it the same as setting the second way once?
00:20:49 <edwardk> mgsloan: i find that much more likely
00:21:04 <Nereid> start with Just (Right 1)
00:21:11 <Nereid> er
00:21:15 <Nereid> I'm looking at right.
00:21:23 * mgsloan always did like these
00:21:24 <shachaf> Nereid: That's where Goldilocks went wrong.
00:21:28 <Nereid> set Just 2, you get Just (Right 2).
00:21:34 <Nereid> set Nothing, you get Just (Right 2).
00:21:44 <Nereid> meanwhile, just setting Nothing gives you Just (Right 1).
00:21:47 <Nereid> oops, right isn't a lens
00:21:50 <edwardk> startling: it'll probably be something like: set left Nothing (set left "hello" (Just (Right 10)))
00:22:02 <Nereid> or something like that.
00:22:23 <edwardk> er set left Nothing $ set left (Just "hello") $Just (Right 10)
00:22:28 <Nereid> so as I said
00:22:37 <Nereid> Maybe (Either a b) is isomorphic to Either (Maybe a) b
00:22:54 <Nereid> so if there's no lens for Either
00:23:05 <Nereid> then that suggests there shouldn't be one here either.
00:23:07 <Nereid> ??
00:23:07 <startling> edwardk: I get Nothing; doesn't that follow that law?
00:23:15 * hackagebot MFlow 0.1.5.2 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.1.5.2 (AlbertoCorona)
00:24:02 <startling> Nereid, you're wrong
00:24:03 <edwardk> startling: gah, i suck at picking the laws that are at issue. ;) one sec. let me actually load this thing up
00:24:05 <Nereid> m, edwardk's thing works too.
00:24:16 <Nereid> startling: I didn't claim it to be a proof. in any case your thing isn't a lens :s
00:24:41 <startling> edwardk: well, I'm not convinced that a law is being broken. :)
00:24:48 <startling> Nereid, huh?
00:24:59 <Nereid> setting a Just and then a Nothing should be the same as setting Nothing.
00:25:00 <edwardk> i am. give me a minute and i'll prove it to you in all my muzzy-headed sleepy glory =P
00:25:07 <startling> Nereid, it is
00:25:07 <shachaf> edwardk: I think you mean "hand-wave", not "hand-waive", in https://github.com/ekmett/lens/wiki/Derivation
00:25:22 <shachaf> Though hand-waiving works too. :-)
00:25:24 <edwardk> shachaf: then fix it. its a wiki
00:25:34 <startling> edwardk, do you have a set of quickcheck tests that check whether the lens laws are being followed? that might be useful
00:25:49 <shachaf> edwardk: Do I have edit access?
00:25:54 <edwardk> startling: yes in the tests folder
00:25:57 <edwardk> shachaf: yes
00:26:07 <shachaf> Hmph, fine.
00:26:13 <edwardk> shachaf: its maintained as a git repo, so i can revert any destructive edits
00:26:45 <startling> edwardk, isLens ?
00:27:02 <edwardk> startling: sounds right
00:27:34 <shachaf> put left (get left "foo") "bar" (Just (Right "foo")) ?
00:27:44 <shachaf> Er.
00:27:53 <shachaf> With the obvious errors removed.
00:28:20 <startling> shachaf, I can't tell which parts aren't errors
00:28:42 <shachaf> let a = Just (Right "foo") in put left (get left a) a
00:29:04 <Nereid> ok look
00:29:11 <Nereid> let a = Just (Right 1)
00:29:22 <Nereid> set left Nothing (set left (Just 2) a) = Nothing
00:29:28 <Nereid> set left Nothing a = Just (Right 1)
00:29:29 <edwardk> startling: isLens fails for your left
00:29:40 <edwardk> Just (Right False)
00:29:40 <edwardk> {_->Nothing}
00:29:42 <edwardk> {_->Just 0}
00:30:14 <edwardk> i'm adding it as a failing test case ;)
00:30:24 <Nereid> lol
00:30:28 <startling> edwardk: >:(
00:30:46 <startling> edwardk: I'm not sure what those three lines mean. care to elucidate?
00:31:24 <edwardk> startling: haven't gotten that far yet =P but the fact that you fail the quickcheck isn't a good sign =P
00:31:39 <Nereid> I just gave an example where it fails though.
00:31:49 <startling> edwardk, have you tested the tests? ;)
00:32:00 <edwardk> Nereid: good example
00:32:08 <shachaf> Ugh, the thing I said was still wrong.
00:32:11 <edwardk> startling: take Nereid's example
00:32:15 <shachaf> Anyway people figured it out.
00:32:40 <edwardk> its actually the same one that quickcheck found and that i argued should exist above
00:34:06 <edwardk> startling: the quickchecks for lens are pretty much obviously correct. they literally are the laws transliterated
00:34:14 <startling> oh, I see what's wrong
00:34:14 <edwardk> lens_set_view l a = set l (view l a) a == a
00:34:24 <edwardk> lens_view_set l a b = view l (set l b a) == b
00:34:28 <startling> edwardk, yeah, I was kidding.
00:34:31 <edwardk> setter_set_set l a b c = set l c (set l b a) == set l c a
00:34:48 <shachaf> What makes the laws "correct", by the way?
00:34:58 <Nereid> something about a coalgebra for the store comonad.
00:35:10 <shachaf> I mean, they're things that should apply, but where did that particular set come from?
00:35:25 <Nereid> as in
00:35:28 <Nereid> a lens is that
00:35:41 <startling> edwardk, I don't like that law.
00:35:47 <edwardk> shachaf: they follow naturally from a number of intuitions. you can state them directly because they have obvious meansings that 'you didn't change anything else'. they come from the costate comonad coalgebra. they arise from the laws for a Traversal and the 'laws' for a Getter given parametricity
00:35:50 <Nereid> they're just the comonad coalgebra laws
00:35:51 <edwardk> startling: too bad =P
00:35:52 <Nereid> :v
00:36:00 <startling> edwardk: D:
00:36:17 <edwardk> shachaf: all of these derivations give you the same laws
00:36:18 <Nereid> oh right, costate is store.
00:36:27 <shachaf> edwardk: Fair enough.
00:36:49 <Nereid> I don't fully understand parametricity.
00:36:58 <Nereid> and I want to.
00:37:00 <edwardk> shachaf: the fact that all of those derivations yield the exact same laws helps me have a lot more confidence in them
00:37:07 <shachaf> Right.
00:37:13 <Nereid> wadler's paper didn't do it for me? or maybe I need to read it again?
00:37:22 <Nereid> or is there another paper I should read
00:37:23 <shachaf> I don't know all the derivations but that makes me more confident too. :-)
00:37:23 <edwardk> Nereid: free theorems are amazing tools, but they are hard to get started with
00:37:49 <startling> edwardk, anyway, where do you recommend I go with this, then? Turns out this abstraction is *really* useful for my code
00:38:00 <edwardk> Nereid: janis voightländer has a nice paper on free theorems in the presence of seq
00:38:39 <edwardk> startling: well, you can a.) ignore the lens laws and do it anyway, or b.) try to make a hedge that it is only a valid lens when longer paths aren't present in the data structure.
00:39:19 <edwardk> or c.) try to restructure your tree so that its legal losing the invariants that no path to a value is a prefix of another path.
00:39:35 <edwardk> but i think we talked about the fact that that isn't useful to you
00:39:40 <startling> mhm
00:40:36 <startling> edwardk, what do longer paths have to do anything?
00:40:38 <edwardk> Nereid: janis' paper was when they finally clicked for me i think
00:41:05 <edwardk> startling: your key structure is something like a Trie with values only at the leaves, no?
00:41:26 <edwardk> if you permitted intermediate values, then you can restore the lens laws trivially
00:42:00 <edwardk> data Trie k a = Trie (Maybe a) (Map k (Trie a)) -- that has easy lenses for working with 'at', etc.
00:42:23 <edwardk> the problem comes in when you go to impose this extra restriction that its
00:42:48 <shachaf> A trie with values only at the leaves? That sounds strange.
00:42:51 <edwardk> data Trie k a = Trie (Map k (Either a (Trie k a)))
00:42:54 <shachaf> Er, I guess Data.IntMap is an example of that.
00:43:00 <shachaf> So not that strange.
00:43:34 <edwardk> the extra restriction is intuitively where everything goes to hell.
00:44:20 <startling> shachaf, I'm trying to represent morphisms between filesystem hierarchies
00:44:35 <startling> edwardk: yeah. how do long paths change anything, though?
00:44:36 <shachaf> Morphisms than ever before.
00:44:39 <edwardk> my usual preference would be to let the data structure be shaped by the exigencies of 'what makes a nice lens', and then impose the restrictions that you have no file paths that are prefixes of another path externally
00:45:01 <startling> edwardk, that might be possible
00:45:05 <hpaste> MAD pasted “Lens abuse” at http://hpaste.org/74895
00:45:19 <MostAwesomeDude> edwardk: ^^ I have abused lens in horrible horrible ways.
00:45:21 <edwardk> startling: because the problem you have is that if you set a prefix of a pre-existing path, then you forget the longer paths that were associated with it.
00:45:23 <Nereid> edwardk: cool, I put it on my list of stuff to read.
00:45:24 <startling> MostAwesomeDude: me too!
00:45:25 <Nereid> thanks.
00:45:40 <MostAwesomeDude> Could I get some feedback on whether there is a way I could do things better?
00:45:40 <startling> edwardk, oh, understood
00:45:49 <edwardk> startling: aha. so here's the idea
00:45:55 <edwardk> use the simpler structure i just gave
00:46:12 <edwardk> and then when you go to use it, just ignore paths that have something set that is a prefix
00:46:23 <edwardk> then the lens laws are all preserved throughout
00:46:24 <startling> edwardk, "data Trie k a = Trie (Maybe a) (Map k (Trie a))"?
00:46:27 <edwardk> yeah
00:46:37 <startling> edwardk, yeah, hmm
00:47:40 <startling> edwardk, I guess I feel like there should be a kind of thing that makes fewer promises than lenses
00:47:58 <edwardk> you can write an indexed fold of the tree that retrieves only the 'a' that have the shortest paths
00:48:28 <edwardk> shortPaths :: IndexedFold [k] (Trie k a) a
00:48:57 <startling> yeah
00:49:05 <startling> anyway, it's getting too late for writing haskell
00:49:12 <startling> edwardk, thanks for all your help, as always
00:49:14 <edwardk> startling: i've not found such a thing that permits what you want that you can actually reason about =P
00:51:53 <startling> edwardk, I'm sure you'll fulfill all my whims someday
00:52:10 <edwardk> startling: =)
00:55:16 <shachaf> I'd be OK with just being able to reason and off about it.
00:57:50 <startling> shachaf: :/
01:02:34 <startling> edwardk, so what am I supposed to do with "Trie n (Map.empty)"?
01:02:48 <edwardk> what about it?
01:03:58 <startling> edwardk, there's nothing I can do with it and if I try to retrieve only the 'a' that have shortest paths, I just get 'n'.
01:04:50 <edwardk> n = Just "hello" or something or n = Nothing?
01:05:03 <edwardk> Trie Nothing Map.empty is the empty tree. no contents.
01:05:18 <startling> err, yeah, I meant "Trie (Just n) Map.empty"
01:10:16 <startling> oh, if the root is "x" then that would be the file "x", not the directory "x". hmm, interesting
01:10:17 <lightquake> oh neat
01:10:26 <lightquake> apparently ghc-mod can tell you the type of things inside where-bindings
01:10:33 <startling> lightquake: o rly
01:10:36 <lightquake> yeah
01:10:46 <startling> that would be insanely useful
01:10:53 <lightquake> now if only it wasn't slow
01:11:04 <lightquake> (which is why i want to do the daemonization rewrite)
01:19:43 <johnw> lightquake: how do you enable that?
01:21:37 <johnw> ah, ghc-show-tpe
01:21:56 <johnw> wow, it really is kind of slow
02:02:43 <merijn> Can I only reexport things when I have an explicit export list?
02:02:57 <johnw> you can rexport whole modules
02:03:13 <hpaste> johnw pasted “Git.hs” at http://hpaste.org/74899
02:03:15 <johnw> example ^
02:03:43 <johnw> there is also a trick where you import all the modules "as X", and then just re-export "module X"
02:04:16 <fmap> haddock doesn't like that trick :[
02:04:18 <merijn> Yes, but that's not what I asked
02:04:35 <merijn> Because I want to know whether I can reexport without having an explicit list for local symbols
02:04:56 <merijn> i.e. export every definition in the module + some external ones without having to exhaustively list all local names to export
02:05:37 <fmap> merijn: you can have a wrapper module that imports yours and re-exports as X
02:06:15 <merijn> Yes, but then I might as well list everything explicitly
02:06:34 <merijn> I don't see any real value in adding a wrapper module for nothing
02:06:53 <merijn> The wrapper just means duplicating the reexported imports with no gain
02:08:20 <fmap> no, your module doesn't have explicit export list, wrapper module re-export your module and external one
02:08:31 <fmap> or I don't understand the problem completely
02:10:09 <merijn> fmap: Yes, but my own module needs the external ones to compile. So I duplicate the import list to save the export list
02:12:49 <kuribas> I want to make a program that produces a vector font from a metafont source file.  Would anyone want to help?
02:13:49 <merijn> kuribas: It is unlikely people are up for contributing until you get at least some work started, but if you get stuck with Haskell issues people here can probably help you with those
02:15:16 <luite> what format do you want to convert them to?
02:15:39 <kuribas> I was thinking ufo (universal font format) would be the simplest to generate.
02:15:52 <kuribas> And then you could use fontforge to generate the font files.
02:17:24 <kuribas> merijn: I am quite sure I could code it myself, but it would take a long time.
02:18:11 <kuribas> merijn: I am already looking at the math to draw an outline from a bezier curve, and to remove bezier intersections.
02:18:16 <kuribas> (overlap)
02:21:02 <merijn> kuribas: My point was just that people tend to be more willing to commit their time to helping you after you've demonstrated at least some motivation to do the work.
02:21:34 <t7> whats a class of things that can be folded over or mapped
02:21:37 <t7> like a tree ?
02:21:38 <merijn> kuribas: If you have a basic framework with lots of details missing that's a lot more interesting to contribute to than just vague plans and ideas
02:21:49 <Baughn> t7: Foldables?
02:22:04 <Baughn> kuribas: Or, to put it another way: I could write a program like that pretty easily, if I wanted to. But if I did, why should I involve you?
02:22:30 <Baughn> kuribas: The traditional answer to that one is "money", of course. :P
02:22:52 <kuribas> I could make a git repository to get started.
02:23:01 <quicksilver> t7: "Foldable" is folded over, "mapped like a tree" is just Functor, probably, but could be Traversable.
02:24:22 <hirsch_> I try to use xml-hamlet for creating XML text. I enabled QuasiQuotes but I still get a parse error. How can I create a String from [xml | <TAG>|]?
02:24:46 <kuribas`> merijn: Yes, I agree with you.
02:25:16 <kuribas`> If I'd get payed, I would do the whole thing myself :)
02:25:22 <mm_freak_> t7: depends on your notion of 'folding'…  Foldable is basically a fancy ToList
02:25:48 <mm_freak_> t7: about the most generic class-bound type of folding can be found in Data.Data
02:26:18 <quicksilver> I think Data.Data's notion is different, rather than more generic.
02:26:27 <quicksilver> well it's more "Generic" with a capital G perhaps :)
02:26:38 <mm_freak_> i'm fine with that =)
02:26:54 <mm_freak_> anyway, i don't think any of those are folding at all, because i think of folding as bird defined it
02:28:03 <mm_freak_> using an associated type you can probably define a class for bird-foldable data structures
02:29:36 <merijn> johnw: So I'm looking into the c2hsc issue I had with FunPtr's, but I'm not entirely sure where to look, maybe you can help a bit?
02:30:18 <t7> keeping all the debugging information is an AST is really ugly
02:31:22 <johnw> sure
02:31:28 <johnw> remind me of the issue?
02:31:44 <merijn> johnw: void functions don't get IO () as return type
02:31:51 <johnw> ah, yes
02:32:05 <sithisbitch> void function doesn't exist in haskell :)
02:32:31 <ocharles> Data.Void says otherwise :)
02:32:32 <ivanm> @hoogle void
02:32:32 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
02:32:32 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
02:32:32 <lambdabot> package void
02:33:00 <merijn> johnw: I'm looking at line 494 where it writes out "FunPtr (" ++ arglist ++ ")", the last value (i.e. return type) seems to be coming from the baseType argument of applyDeclrs
02:33:03 <johnw> void       foo24(void (*foo)()); -> #ccall foo24 , FunPtr () -> IO ()
02:33:07 <johnw> yes, I see it now
02:33:33 <johnw> merijn: so, what I do in this case is call language-c directly (parseC) and get the AST for the type under consideration
02:33:36 <hpaste> “Ertugrul Söylemez” pasted “A proper Foldable class” at http://hpaste.org/74900
02:33:54 <mm_freak_> quicksilver, t7: i think this is a proper Foldable class
02:33:59 <johnw> I bet some bit of code somewhere is too dependent on the ordering of AST elements
02:34:11 <merijn> johnw: Like I said earlier, it is probably undecidable to select between "IO a" and "a" as return types for C functions (IO a being the safe choice) but for void functions the return type is clearly unambigous :)
02:34:21 <johnw> or, it's not sensitive to the complete lack of a type in the case of returning void
02:34:45 <johnw> yeah, users are meant to massage the results
02:34:50 <johnw> i'm just saving them typing, not work
02:36:15 * merijn is trying to make it safe him work too :>
02:37:30 <ghorn> what sort of work does the haskell platform need before release?
02:37:36 <ghorn> is there an issue list somewhere?
02:37:47 <johnw> merijn: so, the issue is that "baseType" is ""
02:38:23 <johnw> which comes from calling fullTypeName' on the declSpecs for the function pointer
02:38:47 <johnw> you see this: fullTypeName' _ [] = return ""
02:39:00 <johnw> that's the case that need smartening
02:39:13 <johnw> the decl specifiers list is empty (which makes complete sense)
02:39:30 <johnw> and in *this* case we need that to mean "IO ()"
02:39:35 <johnw> but not in all cases
02:39:51 <johnw> or maybe so
02:39:53 <johnw> give it a try!
02:40:20 <johnw> oh, no
02:40:23 <johnw> it's this:
02:40:26 <johnw> typeName (CVoidType _) _   = return ""
02:40:36 <johnw> void are rendering to naught
02:40:46 <akamaus> hi all
02:40:59 <johnw> which is appropriarte, for a void argument
02:41:34 <johnw> we may need a state boolean to let typeName know that we're in the return type case, not the argument case
02:42:01 <johnw> alternatively...
02:42:27 <akamaus> I've found what my TH code I wrote for ghc-7.6 doesn't compile under ghc-7.4. To fix it I have to change one import. Is there an easy way to make some kind of conditional compilation what will work with ghci?
02:42:57 <johnw> merijn: I think I have your fix
02:43:09 <merijn> johnw: The ugly hack solution is to treat a baseType of "" as "IO ()" in the function rendering code and leave the rest alone :p
02:43:17 <hpaste> johnw pasted “patch to applyDeclrs” at http://hpaste.org/74902
02:43:18 * hackagebot MFlow 0.1.5.3 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.1.5.3 (AlbertoCorona)
02:43:28 <johnw> yep
02:43:31 <johnw> that's exactly what I did
02:43:36 <johnw> I don't think it's that bad of a hack
02:43:48 <akamaus> Something like cabal macros but without a cabal :)
02:43:48 <johnw> baseType shouldn't be "" if we're rendering a FunPtr
02:43:54 <merijn> johnw: No, it's not that bad
02:44:30 <merijn> Also, the result means I don't need to manually massage the hsc file after generation \o/
02:44:44 <johnw> yeah, I *do* want to avoid that as much as I can
02:44:51 <johnw> I regenerate my files often too
02:44:53 <merijn> Anyway, lunch now. I'll double check it works after I get back
02:44:58 <johnw> I use Git right now to help me throw away the bad stuff
02:45:05 <johnw> I tried it on a test here
02:48:18 * hackagebot c2hsc 0.6.2 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.6.2 (JohnWiegley)
02:51:27 <KBme> hello
02:51:37 <t7> Data.Set can actually be really cool if you hide some of the prelude
02:51:44 <KBme> what do people usually use to store configuration in haskell?
02:52:54 <fmap> KBme: inside haskell program or outside of it?
02:53:09 <simon_w> Hi, I'm using handleSourceError to catch type errors and am wondering if there's some way to get some context with the errors?
02:53:11 <KBme> errr?
02:53:22 <KBme> fmap, what do you mean?
02:53:39 <fmap> same question actually
02:53:49 <KBme> to store configuratin of a haskell program
02:54:40 <KBme> I guess I should just shut up and check up on the json libraries
02:58:38 <Baughn> http://www.webpronews.com/japanese-scientists-indirectly-invent-virtual-girlfriends-2012-09?utm_source=Science_sidebar <- Japan, you...
02:58:43 <Baughn> Okay, this is pretty impressive.
03:13:11 <edsko> anybody around who's played with weak references?
03:18:09 <madjestic> hey guys.  I have created my definition of (+) operator for Bools (for things like True + True = True, etc).  For it to work I need to hide existing Prelude ((+)) operator.  I was wondering if there's a way to keep the original (+) functionality and extend it with mine?
03:19:24 <madjestic> i.e. the original (+) operator is undefined for the type (+) :: Bool -> Bool -> Bool - can not Haskell magically choose between the 2 definitions, based on type signature difference?
03:19:48 <eikke> madjestic: (+) is in Num, so you'd need to create a Num instance for Bool. Yet I'm not sure you actually want that. What's the problem with (&&) anyway?
03:20:15 <xeviox> hi guys, this more a general question on functional programming, but as I try to dive a bit into haskell it's hopefully the right place to ask... How are big lists / arrays are handled in functional programming? From my current understand changing a value in the list means to copy the hole list with just that value changed...
03:20:23 <merijn> madjestic: The original (+) is defined as "Num a => a -> a -> a", in other words "a -> a -> a" for all a that are instances of Num. You could make a Bool instance for Num (but you shouldn't!) and then that would work
03:20:44 <sithisbitch> why not, we can use the Ring structure of boolean
03:20:48 <merijn> xeviox: No, you're forgetting that lists are immutable, so the compiler reuses parts of the old list
03:21:23 <merijn> xeviox: For example, if you modify a value halfway you copy the initial half of the list, but after the changed value you just point back to the last half of the original list
03:21:59 <madjestic> merijn, eikke the question is more of an academic value, rather than practical.  I want to see if that's doable and if yes, how
03:22:17 <merijn> xeviox: Similarly, a function "foo y (x:xs) = y:xs" does not need to copy all of xs for the new list. Just create the "y:" pointer and then point to the xs part of the original list
03:22:26 <madjestic> thanks, I will looks into instancing Num
03:23:08 <merijn> xeviox: That's not possible in something like C or Java (because what if someone changed the list!), however in haskell (and other pure languages) it is not a problem, remember that the list was immutable anyway
03:23:21 <xeviox> merijn: thanks, that is possible for linked lists, but what's the point for arrays? Or doesn't you use arrays in functional programming?
03:23:32 <xeviox> ok
03:23:41 <xeviox> makes sense
03:23:46 <xeviox> thank you
03:24:00 <merijn> xeviox: In arrays you'd be forced to copy (unless your compiler determines there is only one reference, in which case it could theoretically modify in place)
03:24:02 <osfameron> edsko: do weak references exist in haskell?!
03:24:17 <xeviox> but that also means that I have to copy the hole list if I change the last value of the list, right?
03:24:30 <merijn> xeviox: Yes
03:24:38 <xeviox> ok
03:24:50 <xeviox> thank you!
03:24:51 <merijn> xeviox: Although in practice in haskell you don't actually copy until you inspect the resulting list (laziness)
03:24:51 <quicksilver> xeviox: but there are other more sophisticated structures.
03:25:07 <Ro> wont the poerformance go down when you do a lot of copying?
03:25:08 <edsko> osfameron: yup. System.Mem.Weak
03:25:09 <quicksilver> xeviox: Data.Sequence doesn't have to copy "very much" no matter where you modify.
03:25:38 <quicksilver> Ro: yes, excessive copying is a potential performance problem.
03:25:43 <xeviox> quicksilver: ok so the problem is addressed with special data structures..
03:25:44 <Ro> sorry, my hands do not listen to me :)
03:25:51 <xeviox> thank you guys :D
03:25:52 <eikke> and vector doesn't create intermediate copies of possible thanks to fusion
03:25:52 <merijn> xeviox: And of course also provides arrays with mutable updates (hidden behind a pure interface), should you need them
03:25:55 <quicksilver> on the other hand fast allocation and fast GC is a powerful thing.
03:26:18 <quicksilver> temporary allocations which remain in cache may turn out to be 'free'.
03:26:27 <merijn> Ro: Also, while the extra copying costs you a lot, immutability also provides lots of powerful optimisation opportunities
03:26:29 <osfameron> edsko: ah ok.  I wasn't sure how weak refs fitted with pure data structures... but it looks like they're run in IO ()
03:27:20 <edsko> yes, they are
03:28:19 * hackagebot sgd 0.1.0 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.1.0 (JakubWaszczuk)
03:28:29 <merijn> Can I have a cabal build-depends that depends on a cabal installed binary?
03:28:41 <ivanm> no
03:28:45 <merijn> Bugger
03:28:45 <ivanm> best you can do is build-tools
03:28:59 <ivanm> and that just checks if they're in the $PATH
03:29:04 <ivanm> no version checking AFAIK
03:29:30 <merijn> Unfortunate, it seems cabal should be able to verify which tool version I've installed if the install is managed by cabal...
03:29:46 <ivanm> well, it's not really _managed_...
03:30:01 <ivanm> and there's no standardised way of parsing --version
03:30:09 <ivanm> merijn: which tool were you thinking of dep'ing on?
03:30:11 <merijn> ivanm: Actually, even build-tools won't work
03:30:33 <ivanm> well, it will bitch if that tool isn't in the $PATH
03:30:39 <merijn> "setup: Unknown build tool c2hsc"
03:30:48 <ivanm> :o
03:30:52 <merijn> It is in my PATH, because which returns it
03:31:04 <ivanm> merijn: where is it in your PATH?
03:31:11 <ivanm> and are you using ~ or $HOME in your PATH definition?
03:31:15 <ivanm> cabal-install doesn't like the former
03:31:50 <merijn> "$ which c2hsc" -> "/Users/merijn/Library/Haskell/bin/c2hsc"
03:32:43 <merijn> I have another cabal issue, btw
03:32:48 <ivanm> how are you defining PATH?
03:32:49 <ivanm> oh?
03:33:21 * hackagebot monad-codec 0.0.1 - Monadic conversion between complex data structures and unique integers  http://hackage.haskell.org/package/monad-codec-0.0.1 (JakubWaszczuk)
03:33:22 <merijn> The bindings-DSL package installs some header files, but afaict there's no way to tell where without manually inspecting where cabal is dumping files and setting C_INCLUDE_PATH
03:33:37 <ivanm> ugh
03:33:44 <merijn> ivanm: It's set in my .profile
03:34:15 <ivanm> merijn: sure, but how are you specifying the Library/Haskell/bin/ directory?
03:34:50 <merijn> "~/Library/Haskell/bin"
03:35:00 <ivanm> use $HOME, not ~
03:35:03 <ivanm> I did say that earlier :)
03:35:12 <merijn> But that should be expanded by the shell anyway?
03:35:13 <hpaste> t7 pasted “help me make this pretty :3” at http://hpaste.org/74904
03:35:24 <ivanm> so update your .profile, source it, then try cabal install again
03:35:31 <ivanm> merijn: nope
03:35:44 <ivanm> I forget the details; bash does it when you're using bash, but cabal-install is bypassing it or something
03:36:21 <ivanm> t7: I'd be tempted to use ViewPatterns for minView
03:36:30 <ivanm> and then guards
03:36:47 <merijn> hmm, brb then. sourcing .profile in my shell isn't really possible
03:37:17 <ivanm> there's also PatternGuards, but opinion is split over how pretty that is
03:38:08 <merijn> Still fails
03:38:11 <watermind> am I alone thinking datatype promotion would be better made explicit?
03:38:17 <ivanm> merijn: huh
03:38:24 * ivanm has nfi then
03:38:28 <merijn> watermind: Nope
03:38:36 <ivanm> I'm just going to say it's an OSX thing then :p
03:38:40 <merijn> watermind: Collisions between type/constructors sucks
03:38:48 <ivanm> watermind: what do you mean?
03:38:53 <watermind> merijn: is there any suggestion for some syntax to make this promotion explicit?
03:40:33 <watermind> ivanm: eg. instead of having Zero for both value cons and type, having to explicitely syntactically promote Zero to type
03:40:47 <merijn> ivanm: That with DataKinds it is impossible to tell whether "data Nat = Zero | Succ Nat" is a kind/type combo or type/value combo
03:40:55 <ivanm> ahhhh
03:41:01 <ivanm> I haven't played with DataKinds yet
03:41:25 <watermind> ivanm: I don't have any brilliant suggestions for the syntax though
03:43:24 <merijn> ivanm: "One problem is that not all build-tools correspond to haskell packages. Some do some don't. We have a hard coded list of them at the moment"
03:44:26 <ivanm> ahhhhh
03:44:28 <ivanm> that sucks
03:44:34 <merijn> Supposedly you can add more in Setup.hs, but there's no mention anywhere *how*
03:44:44 <ivanm> merijn: see how gtk et. al. do it?
03:45:09 <mm_freak_> watermind: if there is name collision, there is special syntax for referring to the promoted variants
03:45:18 <mm_freak_> i always forget what it is, but it's there =)
03:46:18 <mm_freak_> merijn: with your type there is no confusion anyway, it's rather about types like this one:  data Optional = Optional | NonOptional
03:46:32 <mm_freak_> now Optional is both a data and a type constructor
03:46:33 <simon_w> Hi, I'm using handleSourceError to catch type errors and am wondering if there's some way to get some context with the errors? I'm hoping to get the location of the constraint(s) that the failed type didn't unify with
03:47:28 <certainty> hmm, what function must a type implement to be a proper instance of Ord? I suspected compare, but ghci tells me that: `compare' is not a (visible) method of class `LogLine'
03:49:14 <mm_freak_> certainty: huh?  are you asking about Ord or LogLine?
03:49:34 <mm_freak_> for Ord it's 'compare', and i don't know the LogLine class
03:49:47 <merijn> ivanm: gtk has a rather large voodoo like setup.hs
03:49:52 <certainty> mm_freak_: i want my LogLine type to be an instance of Ord
03:50:08 <mm_freak_> certainty: yes, but your error message is about a type /class/ LogLine
03:50:14 <ivanm> merijn: yeah, well.... :)
03:50:22 <mm_freak_> you're probably writing something like this:  instance LogLine …
03:50:36 <certainty> mm_freak_: oh yeah, i flipped the Arguments :/
03:51:05 <certainty> mm_freak_: thanks for pointing that out
03:51:13 <mm_freak_> you're welcome =)
03:51:18 <merijn> ivanm: I can't be the first to want to add custom build tools :\
03:54:44 <t7> @hoogle (a -> b -> c) -> m a -> b -> m c
03:54:44 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:54:45 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:54:45 <lambdabot> Data.IntMap intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
03:55:25 <t7> :t (>>=)
03:55:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:55:45 <t7> i need backwards <$>
03:56:14 <t7> flip fmap style thing
03:56:18 <t7> is that a thing?
03:57:12 <Ferdirand> @hoogle a -> (a -> b) -> b
03:57:12 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
03:57:13 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
03:57:13 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
03:57:43 <t7> this is my code:    (@@ s) <$> solve (map (solve s) cs)          -- its as readable as:        scs @@ s
03:58:25 <mm_freak_> :t (<$$>)
03:58:26 <lambdabot> Not in scope: `<$$>'
03:59:22 <mm_freak_> when would you flip fmap?
03:59:29 <t7> {-# LANGUAGE StrongAI #-}
03:59:56 <merijn> I guess I'm out of luck with finding the bindings-DSL include directory as well, I guess?
04:00:49 <certainty> how do i check that a type has been created with a certain value constructor, but i don't care about the arguments? That is i don't really want to match against (X _ _ _) and (Y _). Instead i just want to make sure that the argument i have has been created using X or Y. Does that make sense?
04:01:36 <merijn> certainty: Use record wild cards
04:01:44 <merijn> {..} will match any number of fields
04:01:59 <certainty> merijn: thanks, very much. I didn't know about those, yet.
04:11:19 <merijn> I have two datatypes representing lists, any suggestions what I could use as alternative constructor names instead of Cons/Nil?
04:11:55 <matthiasgorgens> merijn: Head, Tail
04:11:59 <matthiasgorgens> but why do you need those?
04:12:10 <matthiasgorgens> merijn: Front, Rest
04:12:25 <merijn> matthiasgorgens: GADTs that mess with the types
04:12:38 <merijn> The kinds don't match up otherwise
04:12:51 <matthiasgorgens> oh, ok.
04:13:49 <merijn> Roughly this: "data Pattern :: [*] -> * where Nil :: Pattern '[]; Cons :: h -> Pattern t -> Pattern (h ': t)"
04:14:11 <merijn> The other is similar, but has kind "[[*]] -> Nat -> *"
04:15:37 <t7> @hoogle (a -> a) -> Int -> a -> a
04:15:38 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
04:15:38 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
04:15:38 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
04:16:00 <t7> >iterateN 10 (+ 1) 0
04:16:02 <t7> > iterateN 10 (+ 1) 0
04:16:03 <lambdabot>   Not in scope: `iterateN'
04:16:28 <Jafet> :t Seq.iterateN
04:16:29 <lambdabot> forall a. Int -> (a -> a) -> a -> Seq.Seq a
04:16:35 <Jafet> > Seq.iterateN 10 succ 0
04:16:36 <lambdabot>   fromList [0,1,2,3,4,5,6,7,8,9]
04:17:04 <mikeplus64> @hoogle (a -> Maybe b) -> (b -> c) -> Maybe c
04:17:04 <lambdabot> No results found
04:17:38 <mikeplus64> :t fmap ($ undefined)
04:17:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f b
04:17:55 <t7> stress testing my typechecker :3
04:28:51 <t7> 400 secs todo 1000 nested lets in ghci
04:29:10 <t7> t8006 -> t8006 :D
04:30:10 <watermind> why are Quickchek modifiers such as Positive part of the Quickcheck librarie and not in some more generic Data hierarchy ?
04:30:35 <merijn> Does MMR also apply for let bindings in a monad?
04:30:42 <watermind> Positive seems like something that would be pretty useful in other non quickcheck related contexts
04:31:56 <watermind> merijn: what do you mean? doesn't the mmr apply in value definitions?
04:33:31 <watermind> if you have a value as part an expression (inlcuding a binding operator) then its type should be inferred from the context
04:33:43 <merijn> I have a let binding "let foo = bar 1 2" which has as type "(forall p . Pattern p -> a) -> a" but "foo length" and "foo xyzzy" returns a type error, because the return types of length and xyzzy don't match
04:34:18 <Jafet> @undo do let x = y; z
04:34:18 <lambdabot>  Parse error at end of input
04:34:21 <Jafet> @undo do let x = y; z;
04:34:21 <lambdabot>  Parse error at ";" (column 16)
04:34:25 <Jafet> @undo do let {x = y}; z;
04:34:26 <lambdabot> let { x = y} in z
04:37:19 <merijn> hmm, even weirder
04:37:23 <watermind> merijn: right I thought you meant bind as in >>=
04:37:48 <merijn> This typechecks "f (\p -> foldPattern p values addRecord (Rec empty empty empty))"
04:38:06 <merijn> But this is a type error: "f foldPattern values addRecord (Rec empty empty empty)"
04:41:42 <watermind> merijn: it makes sense
04:42:09 <watermind> merijn: your type is (forall p . Pattern p -> a) -> a
04:44:24 <watermind> merijn: oh the 2nd doesn't typecheck
04:44:31 <watermind> I don't know :S
04:45:02 <watermind> does "f foldPattern" typecheck?
04:45:14 <merijn> Yeah
04:45:28 <benmachine> those two are different expressions, why should they type check >_>
04:45:29 <watermind> and what is the return type?
04:45:43 <benmachine> (and yes, the MR applies to do-notation let bindings)
04:46:10 <benmachine> watermind: the reason why Positive is not in some more generic Data hierarchy is that it's not particularly useful there
04:46:36 <watermind> benmachine: they are different but in both the arguments have type Pattern p -> a, for some a
04:59:23 <mm_freak_> merijn: wow, that is an interesting type
04:59:31 <mm_freak_> i didn't know that [] gets promoted by DataKinds
04:59:59 <mm_freak_> really weird though
05:00:53 <merijn> mm_freak_: I dunno if it is, but 7.4 and 7.6 have '[] and ': as part of the promoted literals
05:01:08 <merijn> mm_freak_: Same for integer literals and strings
05:01:53 <merijn> mm_freak_: When I finish this coding I plan to write up an article about as a sort of "guided tour" to GHC type extension and how to use them practically in a non-trivial example
05:02:56 <merijn> So far I've got covered: DataKinds, Rank2Types, GADTs, TypeFamilies, TypeOperators, KindSignatures, MultiParamTypeClasses and FlexibleInstances
05:03:05 <merijn> I'm starting to feel like edwardk :p
05:04:05 <mm_freak_> merijn: how do you construct a type-level Integer?
05:04:24 <merijn> Just "undefined :: 2" afaik
05:04:37 <mm_freak_> that's a syntax error (GHC 7.4.2)
05:04:37 <merijn> But 7.6 doesn't have type level comparison for Nat yet, so it's a bit useless atm
05:04:49 <merijn> Promoted ints and strings are only in 7.6 afaik
05:04:53 <mm_freak_> i see
05:04:54 <merijn> 7.4 only has lists
05:04:55 <mm_freak_> too bad
05:05:09 <merijn> Which are already pretty neat
05:06:38 <mm_freak_> print (3 :< "blah" :< Nil)
05:06:44 <mm_freak_> feels /really/ weird
05:06:50 <mm_freak_> that it works i mean
05:07:02 <mm_freak_> data List :: [*] -> * where Nil  :: List '[] (:<) :: a -> List xs -> List (a ': xs)
05:07:11 <mm_freak_> data List :: [*] -> * where Nil  :: List '[]; (:<) :: a -> List xs -> List (a ': xs)
05:08:14 <mm_freak_> HList is finally obsolete =)
05:09:08 <merijn> mm_freak_: I'm doing dirty things with that :p
05:09:09 <Botje> it's not dead, it's resting!
05:10:36 <mm_freak_> if we had type-level Set, that would really start to make things weird and amazing
05:12:06 <mm_freak_> but i guess existentials are still more beautiful
05:12:15 <Jafet> Haskell. Now with agda
05:14:51 <mm_freak_> {-# LANGUAGE Bugs #-}
05:15:49 <Cale> mm_freak_: Does  print (3,("blah",()))  feel weird? :)
05:15:56 <merijn> I guess there's no way to write a fold that iterates over two things in parallel without doing it explicitly? (It's not a list, zo zip doesn't work)
05:17:23 <mm_freak_> Cale: good point
05:17:38 <mm_freak_> still weird that they are the constructors of a single type
05:18:05 <mm_freak_> merijn: what are the types of those two "things"?
05:18:18 <merijn> One is my polymorphic pattern, the other a list
05:18:23 <merijn> I have essentially this:
05:18:42 <mm_freak_> you can do it with polymorphic recursion
05:18:59 <merijn> Pattern p -> val -> (forall x . PatEntry x -> val -> a -> a) -> a -> a
05:19:29 <merijn> I know how to write it, but I already have "fold :: Pattern p -> (forall x . PatEntry x -> a -> a) -> a -> a"
05:19:40 <merijn> I was wondering whether I could express the former in terms of the latter
05:20:48 <mm_freak_> well, you could set val = (), but that's kinda arbitrary
05:21:52 <mm_freak_> what's the purpose of val anyway?  it looks redundant
05:22:21 <merijn> mm_freak_: It gets inserted into the a value
05:22:38 <merijn> oh
05:22:40 <merijn> typo
05:22:46 <merijn> Second argument should be [val]
05:23:26 * hackagebot network 2.4.0.1 - Low-level networking interface  http://hackage.haskell.org/package/network-2.4.0.1 (JohanTibell)
05:23:29 <merijn> So "combine (Cons h t) (v:vs) f x = combine t vs f (f h v x)"
05:24:01 <mm_freak_> i doubt that it's possible, the same way 'zip' can't be expressed in terms of foldr
05:36:46 <kjmitch> Why doesn't "let" evaluate on the Try Haskell in-browser interpreter?
05:37:09 <ivanm> kjmitch: how are you trying to do it?
05:37:31 <ivanm> oh, you mean to define functions?
05:37:46 <ivanm> probably because it isn't designed to do so :)
05:38:27 <kjmitch> I tried 'let s x y z = x z ( y z )' without single quotes, it returns 'not an expression'
05:38:43 <ivanm> yes, the tryhaskell interpreter doesn't seem to allow you to define functions
05:38:49 <kjmitch> So it's not sophisticated enough?
05:38:53 <kjmitch> Okay
05:38:55 <ivanm> @type let s x y z = x z (y z) in s
05:38:56 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
05:39:05 <ivanm> kjmitch: probably also a timing/scoping issue
05:39:43 <kjmitch> I was trying to get confirmation on the type, so if that works, that's all I need, then
05:40:42 <kjmitch> Looks like @type doesn't work either, but now I know what to expect from the in-browser model
05:40:45 <kjmitch> thanks
05:42:42 <sopvop> > map (intercalate "/") . tail $ inits ["foo", "bar", "baz"] -- I love haskell
05:42:44 <lambdabot>   ["foo","foo/bar","foo/bar/baz"]
05:43:18 <kjmitch> Unrelated question, since this looks like the general #haskell irc node: is there a standalone way to use the haskell platform? it isn't installed on my university's computers and that would be a good workaround
05:43:24 <ivanm> sopvop: you should be using </>, etc. from System.FilePath though...
05:43:43 <ivanm> kjmitch: install it into your home account if it's a *nix setup?
05:43:54 <ivanm> or else install it at home and ssh in?
05:44:32 <kjmitch> Windows machines for general campus, I think the few linux machines have it already
05:44:45 <kjmitch> I'll see about that, thanks
05:44:56 <sopvop> ivanm: It's not for directories, but for directory-like things. But thanks, I didn't know about </>
05:45:24 <ivanm> sopvop: well, it will help make your code work cross-platform :)
05:47:23 <merijn> If I need to add multiple entries to an IntMap, what's the best approach? Adding entries one by one or collecting all new entries in an IntMap and then doing union?
05:47:56 <ivanm> hmmm
05:48:17 <ivanm> if you're doing union, be sure of the size, since there's an advantage to having the larger one first IIRC
05:49:04 <merijn> It's semantically important which is first, so that's not relevant
05:49:13 <merijn> (Due to what gets overridden)
05:50:01 <Botje> merijn: doing a union is potentially faster.
05:50:14 <Botje> but I think union is just implemented as foldl insert
05:50:25 <Botje> feh, it's semantically more appropriate as well :)
05:51:27 <Jafet> On Windows, you should be able to install ghc to your home directory as well.
05:51:28 <merijn> Right now I'm building up the map first, folding over a list and then union the result. I could fold and insert directly on the initial map and skip the union but I'd have to restructure
05:56:41 <benmachine> merijn: if you're only worried about performance, profile it?
05:56:50 <benmachine> maybe the function takes 0.5% of your runtime in any case :P
06:01:22 <merijn> @pl \x -> liftA2 (+) (lookup x y >> Just 1)
06:01:22 <lambdabot> liftA2 (+) . (>> Just 1) . flip lookup y
06:04:47 <benmachine> merijn: you may be interested in <$
06:05:07 <benmachine> merijn: although to me that looks equivalent to (lookup x y >>) . fmap (+ 1)
06:05:09 <merijn> :t (<$)
06:05:10 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
06:05:36 <benmachine> > 7 <$ ["hello", "there", "world"]
06:05:37 <lambdabot>   [7,7,7]
06:05:53 <merijn> > Just 2 <$ Just 1
06:05:54 <lambdabot>   Just (Just 2)
06:06:30 <merijn> The lookup fmap looks better, yeah
06:07:22 <benmachine> 's clearer what you mean
06:28:20 <Expez> I'm using the hmatrix package, which overloads * and I'm trying to do 'foo = (bar :: Double) * (baz :: Matrix Double). When I compile I get the error that it expected the second argument to (*) to be another double. Scaling matrices works fine in ghci. What gives?
06:29:28 <JordiGH> A question to y'all who like category theory. Is there much diagram-chasing applicable to Haskell? Can someone think of an example?
06:29:30 <maukd> @hackage hmatrix
06:29:30 <lambdabot> http://hackage.haskell.org/package/hmatrix
06:29:39 <merijn> Expez: Do you type "bar" in ghci or a number?
06:29:50 <byorgey> @type (*)
06:29:51 <lambdabot> forall a. (Num a) => a -> a -> a
06:29:58 <byorgey> Expez: (*) still expects two arguments of the same type
06:30:06 <Expez> merijn: I tried with a number.
06:30:24 <merijn> Expez: Numberic literals get coerced to proper type automatically
06:30:25 <byorgey> Expez: I suspect that in ghci one of the arguments is polymorphic, and hence can be automatically converted to the type of the other
06:30:47 <maukd> Expez: where does hmatrix overload *?
06:30:51 <merijn> Expez: so "2 * (baz :: Matrix Double)" is different from "(2 :: Double) * (baz :: Matrix Double)"
06:32:21 <Expez> maukd: http://dis.um.es/profesores/alberto/material/hmatrix.pdf here it says the * operator is overloaded and works on each element
06:33:01 <Expez> merijn: Thanks, that does make sense.
06:33:02 <byorgey> JordiGH: see the last few pages of the paper "Applicative Programming with Effects"
06:33:53 <maukd> Expez: it says no such thing
06:34:16 <JordiGH> Functors here mean arrows in the category of categories, right? Not function-like objects in OOP?
06:34:31 <byorgey> JordiGH: right
06:34:33 <Expez> maukd: in the quick reference it says 'element by element'
06:34:59 <byorgey> JordiGH: function-like objects in OOP we just call "functions" =)
06:35:15 <byorgey> (because they are already first-class)
06:35:32 <maukd> Expez: but not "overloaded"
06:38:04 <alpounet> byorgey, actually, it's common in C++ to call "functor" classes/structs that provide an overloading of operator()
06:38:17 <alpounet> oh nvm i've misread what you wrote
06:38:29 <JordiGH> alpounet: Not just C++.
06:38:31 * hackagebot hako 0.3.0 - A mako-like quasi-quoter template library  http://hackage.haskell.org/package/hako-0.3.0 (TobiasDammers)
06:38:56 <byorgey> alpounet: right, we agree, I meant that in *haskell* we call those things functions
06:39:16 <alpounet> byorgey, yeah, i of course got what you meant after having answered
06:39:23 <Expez> maukd: How is it not overloaded if * is made to work on matrices instead of instances of Num?
06:39:41 <maukd> Expez: because that's not what happens
06:39:46 <byorgey> Expez: (*) is already overloaded by definition, since it is a member of the Num typeclass
06:39:47 <maukd> Expez: matrices are instances of Num
06:39:55 <maukd> that is all
06:40:02 <alpounet> byorgey, by the way, cool that your monoid paper gave rise to the occasion of giving a talk about it
06:40:17 <alpounet> JordiGH, what other language(s) use that terminology?
06:40:24 <byorgey> alpounet: uh, yes, that was the idea all along =)
06:40:55 <JordiGH> alpounet: Pretty much all of them: http://en.wikipedia.org/wiki/Function_object
06:40:59 <Expez> maukd: I see
06:42:13 <alpounet> oh i wasn't suspecting "functor" was used too in other OOP languages
06:42:20 <dylukes> maukd: you need fund eps.
06:42:35 <Expez> So, In my expression foo = bar * baz, can I force bar to morph into the appropriate matrix, as happens automagically in ghci?
06:42:49 <maukd> JordiGH: that article doesn't support your claim
06:42:59 <dylukes> Mat m n x Mat n p -> Mat m p
06:43:03 <JordiGH> maukd: Grep for "functor".
06:43:16 <dylukes> and type level nats for good measure
06:43:17 <maukd> JordiGH: I did
06:43:31 <alpounet> the Java section uses "functor"
06:43:39 <JordiGH> Oh, fine, nobody else uses it but C++. Let's hate C++ for using the word "functor".
06:44:07 <isson> i have a question. when haskell evaluate the value, it see the type, if that type is IO , haskell evalute to the value that is a pointer to a IO function, if that type is not IO, haskell just evaluate that value. is right?
06:44:35 <Botje> IO values are values like any other.
06:44:49 <Botje> @quote /bin/ls
06:44:49 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
06:44:54 <maukd> alpounet: yes, but that's the wikipedia article, not the language
06:45:08 <flux> jordigh, I bet they chose to call their things functors just because they had heard the word and it sounded cool :/. why not otherwise call them "function objects", that would describe them so much better.
06:46:06 <parcs`> i bet that's why mathematicians chose the word functor too
06:46:12 <JordiGH> flux: I feel the same way about Haskell's use of category theory. It looks so foreign from the category theory I studied in school. They emphasise completely different things, and I can't even tell if they're talking about the same things.
06:46:40 <JordiGH> Natural transformations are supposed to reign supreme, but they seem to be delegated to appendices instead.
06:48:07 <JordiGH> maukd: People using the word in Python: http://www.gossamer-threads.com/lists/python/dev/768857
06:48:16 <isson> evaluation means that reduction to a value. when getLine is evaluated , getLine is reducted to what ?
06:48:21 <JordiGH> People using it for Ruby: http://samdanielson.com/2007/9/3/closures-vs-function-objects-in-ruby
06:48:41 <alpounet> isson, a value of type "IO String" (such as 'getLine') is just a recipe for getting a String through the IO monad, which may imply using side effects to get the String. However, on its own, it's just a value like more usual values. it'll only potentially be "forced" (meaning: it'll only actually do the IO) when you'll write "x <- getLine" or "getLine >>= ..."
06:48:50 <JordiGH> In lisp: http://stackoverflow.com/questions/9662226/what-does-illegal-argument-in-functor-mean-in-common-lisp
06:49:22 <Botje> prolog also uses the name 'functors' for records.
06:50:29 <maukd> alpounet: your use of "forced" is :-(
06:50:52 <alpounet> yeah
06:50:59 <alpounet> should replace "forced" with "executed"
06:51:26 <isson> thanks alpounet
06:51:27 <isson> :-)
06:52:36 <quicksilver> alpounet: also, merely writing "x <- getLine" doesn't make anything happen
06:53:00 <quicksilver> what makes it happen is asking the haskell compiler to "actually run this IO action" which is normally by connecting it to main
06:53:31 <quicksilver> > do x <- getLine; return ("This didn't happen: " ++ x)
06:53:33 <lambdabot>   <IO [Char]>
06:53:39 <maukd> JordiGH: the python thread has one person using it in the C++ sense (explicitly named as such: "I believe that's how they're defined in the C++ world"), the rest seems to be a discussion of "functor" in the mathematical or haskelly sense
06:54:36 <quicksilver> it does seem to be a fairly common LISP usage though
06:54:36 <JordiGH> maukd: That's nice.
06:54:49 <quicksilver> I wonder where the bogus use of functor came from
06:55:05 <isson> quicksilver : you mean, until main is executed , haskell never forced the value of IO type, it will be always unforced . is right?
06:55:14 <quicksilver> isson: no, that's not what I mean.
06:55:40 <quicksilver> isson: just because 'forced' is the wrong word.
06:55:48 <quicksilver> well mostly for that reason.
06:55:51 <quicksilver> the word is executed.
06:56:47 <flux> I can't really find the word 'functor' being used for non-ml-languages in google prior to 2000, but it could be the limits of their index
06:57:23 <flux> but already at 2001 there's sgi stl documentation talking about functions objects, functors :)
06:57:26 <maukd> JordiGH: the ruby blog post uses "functor" to refer to lambda functions, as far as I can tell
06:57:43 <JordiGH> maukd: That's also nice.
06:58:10 <maukd> the lisp error is good, though
06:59:20 <maukd> JordiGH: so ... by "pretty much all languages" do you mean "some implementations of Common Lisp"?
06:59:29 <JordiGH> maukd: That's even nicer.
06:59:35 <maukd> what
06:59:42 * ski . o O ( uses of the word "functor" in C++,SML,Haskell,Prolog at <http://www.catonmat.net/blog/on-functors/> )
06:59:56 <maukd> JordiGH: what is going on?
06:59:58 <frerich2> maukd: haha
07:00:04 <JordiGH> maukd: Functors.
07:00:31 <frerich2> maukd: I'd like to steal that "by pretty much all languages..." line the next time some colleague in the tea kitchen starts ranting about languages
07:01:00 <nikita-0> quicksilver: C++/LISP "functor" is grammatically plausible though: it's an agent noun, like "actor".
07:01:25 <maukd> JordiGH: yes, and you claimed that pretty much all languages use "functor" like C++
07:01:33 <JordiGH> maukd: True.
07:01:38 <maukd> which I don't think is true
07:01:43 <JordiGH> That's also true.
07:01:58 <maukd> JordiGH: so what were the links for?
07:02:12 <JordiGH> maukd: To show people using the word "functor" for other languages.
07:02:41 <maukd> but that's 1) irrelevant and 2) they don't do that
07:02:48 <JordiGH> maukd: False.
07:02:55 <maukd> how?
07:03:13 <JordiGH> Because you didn't tell very far.
07:03:22 <JordiGH> You read enough to support your worldview.
07:03:26 <maukd> I don't understand what that means
07:03:30 <JordiGH> And facts aren't going to convince you otherwise.
07:03:42 <JordiGH> In the absence of facts, your worldview will persist until you find other facts to support it.
07:03:51 <JordiGH> So, it's all very nice.
07:04:20 <isson> quickssilver : i think haskell do not know about Maybe type. it is just one of many others type. but haskell knows about IO type. haskell treat IO type specially. is right?
07:04:25 <maukd> I'd say that's obviously wrong because the lisp example did convince me
07:04:52 <Eduard_Munteanu> isson: no
07:05:08 <JordiGH> maukd: The Ruby example explicitly says "function object" and names the function that produces function objects "make_functor".
07:05:12 <quicksilver> isson: almost "no"
07:05:23 <quicksilver> isson: the language doesn't treat the IO type any differently
07:05:27 <JordiGH> maukd: But you just saw a lambda and decided they meant lambdas with "functors".
07:05:28 <isson> almost ?
07:05:35 <JordiGH> maukd: That's as far as you could tell. I don't think you tried to tell very far.
07:05:37 <quicksilver> however the compiler and/or runtime system has some special support for IO
07:05:50 <quicksilver> but this is in some sense 'outside' the language
07:05:56 <quicksilver> or at least, it's a very separate part.
07:06:08 <maukd> JordiGH: "make_functor" is in essence a curried function. it's a function that returns a lambda
07:06:13 <JordiGH> maukd: That's nice.
07:06:29 <maukd> JordiGH: so yes, they did mean lambdas with "functors"
07:06:29 <JordiGH> I bore of this, ttyl. Have your last word while I'm away.
07:06:38 <quicksilver> how peculiar.
07:06:59 <maukd> and all of this only addresses "2) they don't do that"
07:07:17 <maukd> the more important point is "1) irrelevant"
07:07:39 <maukd> the question was: what *languages* use this terminology?
07:09:43 <quicksilver> seems like some LISPs and C++
07:09:55 <quicksilver> and prolog uses the word in a different way.
07:12:06 <DT`> I've never heard Lisps call lambdas ``functors''.
07:12:27 <DT`> just C++.
07:14:04 <Clint> fyi, that guy is an asshole and a troll
07:14:48 * ski isn't sure about the latter
07:15:26 <maukd> DT`: isn't the whole point that C++ doesn't have lambdas and has to use "functors" instead? :-)
07:15:45 <ben> It has lambdas now~
07:15:49 <kranius> i heard C11x supports lambdas
07:15:56 <maukd> C++0xB
07:16:14 <ben> They're not quite as convenient as you might hope since they aren't garbage-collected closures, but e
07:16:17 <ben> eh*
07:17:41 <isson> in haskell documemnt, "sin 1" is evaluated in compile time, but "getLine" is executed from the main, but i think "sin 1" must be executed to evaluted to the value. i am confused..:-) ..
07:18:23 <nikita-0> kranius: no, C doesn't support them, but gcc does have nested functions as an extension, which is sort of lambda without upward funarg.
07:18:28 <maukd> sin 1 is not evaluated at compile time
07:18:35 <maukd> sin 1 can't be executed
07:18:37 <rwbarton> execution and evaluation are different things
07:18:44 <rwbarton> in Haskell, anyway
07:19:35 <isson> i mean "executed" is really executed.
07:20:13 <isson> i know haskell distinguish execution and evaluation.
07:20:25 <rwbarton> like maukd said, sin 1 is not the sort of thing that can be executed at all
07:21:13 * maukd ponders the obvious Num instance
07:22:47 <Sculptor> hello there
07:22:50 <isson> but,. i can write a function fast_sin function in C , and haskell  evaluate fast_sin . but, it is really "executed" to evaluate the value. is wrong?
07:23:45 <maukd> isson: what do you mean by "really executed"?
07:23:59 <Jafet> Non-operational semantics
07:24:16 <quicksilver> isson: in erms of the distinction we're trying to make, it depends on the type.
07:24:28 <quicksilver> if you import fast_sin from C as Double -> Double, then it's evaluated
07:24:33 <isson> haskell will jump to the code fast_sin to evalute the value.
07:24:39 <quicksilver> if you import it as Double -> IO Doble then it's executed.
07:24:50 <quicksilver> you can choose which, when you FFI import.
07:24:58 <quicksilver> you should only use the non-IO one for pure functions.
07:25:12 <maukd> isson: that's not what we mean, though
07:25:31 <maukd> of course all machine code is "executed"
07:25:43 <maukd> but haskell isn't defined in terms of machine code
07:25:55 <rwbarton> (also if your "sin" function is one you foreign imported from C then "sin 1" is definitely not evaluated at compile time!)
07:26:31 <copumpkin> sin is evaluated by god
07:26:43 <quicksilver> well haskell (the language) doesn't specify what gets evaluated at compile time.
07:26:47 <copumpkin> something like that, anyway
07:26:53 <quicksilver> GHC evaluates very very little at compile time
07:27:06 <quicksilver> but you could certainly have an entirely reasonable haskell compiler which chose to evaluate 'sin 1' at compile time.
07:27:19 <maukd> only if you can't observe it, though
07:28:16 <isson> hmm...
07:28:28 <isson> haskell is too difficult to me :-)
07:29:09 <maukd> isson: do you know any other languages?
07:29:10 <Cale> isson: Ask questions!
07:29:28 <rwbarton> I wrote "x :: Double -> Double; x y = sin 1" and ghc -O2 didn't even produce a function in the .o file :)
07:29:31 <isson> x86 assembly, c/c++,java, c#...delphi
07:29:38 <isson> and lisp..
07:30:00 <Cale> isson: Are you trying to understand what GHC will do when compiling an expression like  sin 1  ?
07:30:18 <Cale> isson: Or when compiling  sin x  where x is, say, read from user input?
07:30:35 <isson> no. but i want to understand it.
07:30:43 <maukd> understand what?
07:30:48 <lpvb> constant pure functions aren't compiled down to constant values?
07:31:08 <maukd> lpvb: all functions are pure
07:31:27 <Cale> It's not always the case that GHC will evaluate constants at compile time, but for some, it will.
07:31:27 <isson> cale <cale> isson: Are you trying to understand what GHC will do when compiling an expression like  sin 1  ?
07:31:32 <Sculptor> isson, delphi - there's your problem, ma'am
07:32:07 <Cale> If you're interested in what happens in the intermediate language after simplification of your program, you can -ddump-simpl
07:32:21 <merijn> With GADTs where different constructors produce different types, GHC can't infer that all remaining constructors are the same?
07:32:22 <Cale> (i.e. add that as a commandline option while compiling your program)
07:32:26 <maukd> Sculptor: what, and "c/c++" is fine? :-)
07:32:51 <Sculptor> i don't see you in #c@efnet anymore. jasabella is sad
07:33:16 <isson> cale : where i can obtain the detailed informaion more than you saied
07:33:23 <merijn> i.e. I have 2 groups of constructors resulting in different phantom types. Matching all of one group won't let me collapse all the remaining ones into a single match?
07:33:36 <Cale> isson: hmm, well, there's the GHC user's guide
07:33:50 <isson> hmm.. ok
07:33:56 <Cale> isson: A lot of this is internal to GHC, and not terribly well documented, and of course, subject to change.
07:34:06 <Cale> (the intermediate representation of your program)
07:34:47 <Cale> Strictly speaking, Haskell (the language) doesn't specify a distinction between what happens at compile time and at runtime.
07:35:02 <Cale> and so it doesn't matter what GHC does
07:35:02 <ghorn> can anyone recommend a package for interprocess communication?
07:35:26 <Cale> In practical terms, if you really care, you can usually find out if GHC is doing some optimisation or not.
07:36:01 <ghorn> i'm looking at haskell-zeromq
07:36:58 <isson> cale : i don't want to understand the optimisation yet :-), i wanna ....
07:37:26 <Clint> ghorn: stm, depending on what you want to do
07:37:35 <isson> cale : but i wannot understance the haskell exactly..
07:37:38 <isson> understand
07:38:18 <isson> i am poor english.:-) . i wanna understand the haskell exactly ~
07:38:55 <ghorn> Clint: i want to send ADTs to a visualizer running in a separate process
07:40:27 <ghorn> I can't run opengl stuff from ghci so I'll have a visualizer waiting for messages running standalone
07:40:56 <Clint> ah
07:41:38 <isson> i have a another question. in haskell. the "evaluation" means that reduction to a value. it doesn't matter in runtime or compile time. is right?
07:42:06 <ski> reduction of expression, but yes
07:42:44 <isson> yes. reduction of expression to a value.
07:42:55 <isson> thanks ski :-)
07:43:11 <av> does anyone know of any optical simulation algorithms implemented (or otherwise useable from within) haskell?
07:45:37 <merijn> @pl \s -> runIdentityT . writeStream s
07:45:37 <lambdabot> (runIdentityT .) . writeStream
07:52:35 <merijn> Wait...where clauses only scope over one pattern? :(
07:52:58 <merijn> eh, pattern is the wrong word, I guess
07:53:13 <Jafet> Equation
07:53:45 <frerich2> merijn: Yeah, what I usually do is to replace multiple equations with one using 'case'. Not pretty. :-/
07:54:30 <Jafet> Just do the prime dance
07:54:36 <Jafet> foo = foo' where
07:55:20 <ski> something like SML's `local <decls> in <decls> end' would be nice to have in Haskell
07:56:28 <Cale> Hey, this is weird: http://hackage.haskell.org/package/tagsoup-0.12.8 -- it displays a module "Text.HTML.Download", but the link is broken.
07:56:35 <merijn> Actually, with lambdacase it's not even that bad
07:56:38 <rwbarton> Cale: yes, I encountered that
07:56:49 <rwbarton> it has to do with build flags
07:57:38 <rwbarton> if you cabal install tagsoup -fdownload (or something like that, check the .cabal file) you will get a helpful message telling you Text.HTML.Download is deprecated and how to use Network.HTTP instead
07:58:22 <rwbarton> (when you try to use Text.HTML.Download, that is)
07:58:54 <demonoid_com> what is  haskell vs c/c++ :DDDDDDDDDDDDD
07:59:01 <demonoid_com> c/c++ winsss :DDDD
07:59:24 <maukd> demonoid_com: the only existing implementation of C/C++ is written in Haskell
07:59:37 <maukd> FSVO "implementation" and "C/C++"
07:59:41 <Cale> maukd: Do you have a link to that implementation?
07:59:55 <Cale> maukd: I remember reading the requests for enlightenment on it.
07:59:58 <demonoid_com> maukd:yes do you?
08:00:02 <Cale> but they're no longer online
08:00:14 <Cale> (except for the 0th, which is in the archive)
08:00:20 <maukd> demonoid_com: what?
08:00:32 <hpaste> merijn pasted “Code duplication sadness” at http://hpaste.org/74906
08:00:48 <demonoid_com> maukd: Do you have a link to that implementation?
08:00:48 <Cale> http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html -- this link is dead :(
08:00:49 <maukd> Cale: it's somewhere in my backup files (and it uses a parser library that doesn't exist anymore)
08:00:50 <merijn> Any suggestions how to eliminate some of the repetition there?
08:01:30 <Cale> http://web.archive.org/web/20090331163943/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html -- but this is here
08:02:05 <int-e> merijn: can you combine the last three lines into one? (or are there more clauses following?)
08:03:19 <merijn> int-e: That's what I thought, but GHC complains
08:03:30 <int-e> merijn: and it looks a bit like you can write  writeStream (_, s) rec = lift . putMVar s $ wrapRec rec
08:03:37 <int-e> oh, those are GADTs?
08:03:45 <rwbarton> how about writeStream (_, s) item = lift . putMVar s $ itemWrapper item where itemWrapper (Rec t b f) = WrapData ; ...
08:03:46 <merijn> The constructors are from a GADT (and so is the wrapper)
08:03:57 <rwbarton> oh
08:04:15 <maukd> Cale: see the 7 last pastes on hpaste.org
08:04:32 <maukd> wow, this is some old code
08:04:44 <int-e> merijn: then it's just possible that the code can't be refactored nicely, since unpacking the constructor has an effect (of bringing certain dictionaries into scope) even though that's not visible.
08:05:27 <latro`a> at the very least you can do writeStream (_,s) rec = lift . putMVar s $ helper rec
08:05:37 <rwbarton> hard to believe those dicts could be used by "lift . putMVar s $" though?
08:05:49 <int-e> rwbarton: right
08:06:02 <latro`a> actually
08:06:03 <rwbarton> so your original suggestion should be fine
08:06:11 <latro`a> writStream (_,s) = lift . putMVar s . helper
08:06:15 <latro`a> *write
08:06:23 <latro`a> where helper ...
08:07:31 <latro`a> oh nvm, rwbarton already suggested that
08:07:58 <rwbarton> after int-e did :)
08:08:16 <latro`a> lol
08:08:17 <latro`a> indeed
08:08:27 <int-e> @quote fugue
08:08:27 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:09:40 <merijn> The helper helps a little, I guess
08:10:39 <rwbarton> well if there is a separate reason why each WrapControl application typechecks, you can't really expect to not have to repeat WrapControl
08:11:37 <merijn> Unrelatedly (or semi-relatedly)
08:11:53 <Ornedan> Is it possible to modify only a subset of the elements of a repa array?
08:12:05 <merijn> Is there a way to get the "MonadTrans t, Monad (t IO)" constraint I have on many functions to look nicer?
08:12:27 <rwbarton> can you just use MonadIO m / liftIO?
08:12:51 <merijn> oh, maybe
08:13:33 <quicksilver> a 'MonadTrans' constraint is a sign you've done something too concrete.
08:13:44 <merijn> :t liftIO
08:13:46 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
08:13:59 <quicksilver> it's quite harsh to restrict to only "t IO"
08:14:12 <quicksilver> (and this is the problem that classes like MonadIO are designed to solve)
08:16:04 <yyyymmdd> sss
08:16:42 <osfameron> you missed HHMM
08:17:09 <yyyymmdd> :-)
08:18:11 <latro`a> incidentally
08:18:17 <latro`a> DAE think we should have damned metric time already?
08:18:33 <osfameron> DAE?
08:18:37 <latro`a> does anyone else
08:18:44 <osfameron> ah
08:19:21 <maukd> Cale: ok, Haskell code starts at http://hpaste.org/74907 and sample programs at http://hpaste.org/74914
08:19:27 <maukd> is this useful in any way?
08:19:42 <latro`a> say, 100 seconds to a minute, 100 minutes to an hour, 10 hours to a day, and then unfortunately we're pretty stuck with 365 days to a year by the universe
08:19:51 <latro`a> and then renormalize the second accordingly
08:20:03 <lightquake> > renormalize the second
08:20:04 <lambdabot>   Not in scope: `renormalize'Not in scope: `the'
08:20:10 <lightquake> :(
08:20:22 <osfameron> 12 is a nice number to divide though
08:20:28 <latro`a> ...
08:20:30 <latro`a> wat
08:20:31 <osfameron> "it's 2.5 past 3" is far less pretty
08:20:36 <Cale> maukd: I really just want to be able to link people to the language when they talk about C/C++
08:20:49 <latro`a> 12 has one more prime factor than 10
08:21:03 <latro`a> also you probably would just report time in hours/minutes anyways
08:21:09 <latro`a> it's 3:75
08:21:11 <latro`a> sorta thing
08:21:14 <Cale> maukd: After all, it's apparently one of the most popular languages, it's only right that it have an online presence of some sort.
08:23:38 * hackagebot Elm 0.4.0.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.4.0.1 (EvanCzaplicki)
08:23:40 * hackagebot simple-log 0.1 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.1 (AlexandrRuchkin)
08:28:42 * hackagebot elm-server 0.4.0 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.4.0 (EvanCzaplicki)
08:28:44 * hackagebot SDL 0.6.4 - Binding to libSDL  http://hackage.haskell.org/package/SDL-0.6.4 (DavidHimmelstrup)
08:49:53 <Philippa_> 'lo
08:50:20 <Philippa_> edwardk: know where I can find a "for idiots^Wtired people" guide to building a comonad out of a datatype being viewed as a directed container?
08:51:04 <edwardk> Philippa_: well, you can always use the cofree comonad
08:52:51 <Philippa_> edwardk: which I guess at least puts me in STFW territory at least :-)
08:52:53 <Philippa_> right, shall do so
08:53:04 <edwardk> STFW?
08:53:32 <maukd> search the fucking web
08:53:34 <Philippa_> Search The Web
08:53:42 <ClaudiusMaximus> hi!  i've been away for two months, what's new in Haskell-land?
08:53:55 <edwardk> ah
08:54:06 <edwardk> well, the 'free' package provides the cofree comonad and some haddocks for it
08:54:14 <Philippa_> ClaudiusMaximus: hah! I've been nearasdammit away for much longer than that so I have no clue!
08:54:15 <edwardk> though the haddocks for 'free' are a lot more verbose.
08:54:22 <edwardk> @hackage free
08:54:23 <lambdabot> http://hackage.haskell.org/package/free
08:54:42 <Philippa_> edwardk: I'm on a train, on GPRS, FWIW
08:54:58 <edwardk> ClaudiusMaximus: Lenses and Traversals
08:54:58 <Philippa_> (will be back on line longer-term sometime this evening, but I'm going gaming for a spot first)
08:55:36 <ClaudiusMaximus> Philippa_: cool, good to see you - is there any south east england haskell event planned any time soonish?
08:56:26 <Philippa_> ClaudiusMaximus: dunno, I'm out of the planning loop for those by now
08:56:41 <ClaudiusMaximus> edwardk: nice, will have to look them up when i get a chance - meanwhile i have to prepare an artist talk for 2nd october, which is kinda rushed after 2 months without computer/internet/etc
08:56:48 <Philippa_> I mean, I'm heading home from Cambridge? But the only haskell connection is rather tenuous
08:56:59 <ClaudiusMaximus> Philippa_: sure, planning is no fun
08:57:50 <ClaudiusMaximus> or rather, less fun than hacking on code and myriad other things
08:58:27 <Philippa_> yeah. I mean, it's more fun than dealing with certain people in the aftermath of this year's ICFP, but still
08:58:34 <Philippa_> I can think of a lot of things that are
09:00:56 <watermind> long shot but anyway, I remember seeing a small article by dijkstra I think, on the design of programming languages, appart from dismissing functional programming he talked about design decisions like  :=  being a better choice than = for assignemt since it is assymetrical
09:01:16 <watermind> does this ring a bell to anyone?
09:01:22 <watermind> I can't seem to find it :(
09:07:23 <matthiasgorgens> watermind: sorry, I don't know it, either.  I wonder whether a syntactic distinction between assignment and binding would help people in imperative languages, too.
09:08:34 <osfameron> why did he dismiss FP?
09:09:00 <NihilistDandy> Impractical, opaque, arcane...
09:09:03 <lpsmith> so is cosin evaluated by cogod?
09:09:45 <lpsmith> oh, the message I was responding to was from quite a while ago :-D
09:10:25 <Philippa_> matthiasgorgens: it's more useful when binding is also useful, of course
09:10:36 <Philippa_> otherwise you just get "it's all assignment, who cares?"
09:10:50 <lpsmith> Dijkstra wasn't always right.   I don't agree that basic causes brain damage for example,  it got a whole generation or three of programmers started
09:10:54 <Philippa_> otherwise: we know it is, people still use it when writing highly imperative haskell
09:11:41 <Philippa_> Dijkstra dismissed the FP of his day. Also, is that FP=Functional Programming or FP = that one language?
09:11:58 <lpsmith> I dunno
09:12:00 * byorgey got started in BASIC.
09:12:10 * quicksilver got started in PASCAL
09:12:13 * lpsmith got started with BASIC too
09:12:18 <quicksilver> maybe it's the capitals that are important, not the language.
09:12:23 <lpsmith> pascal was my second language
09:12:23 * Clint got started with BASIC and is still scarred
09:12:24 <lpsmith> lol
09:12:46 <matthiasgorgens> Philippa_: I guess you make declaration special in the case that binding isn't too useful.
09:12:52 <Philippa_> I nominally started with Pascal and spent a lot more time with basic. Both were problems, really
09:13:00 <lpsmith> it took a little while to adapt to the lack of line numbers,  but it didn't take too much longer after I'd adapted to pascal to realize that it was a much better language
09:13:05 <matthiasgorgens> Philippa_: though, e.g. C still make a special case out of binding function arguments.
09:13:22 <lpsmith> and the realization that some languages were better than others was a good lesson to have early in life,  I guess
09:13:24 <byorgey> "HASKELL is a pure, functional, strongly typed language featuring a name with all capitals, so it is suitable for beginners"
09:13:40 <Mortchek> matthiasgorgens, what is that special case?
09:13:45 <rwbarton> byorgey: interesting, I should try this HASKELL language some time
09:13:57 <osfameron> beginners seem to prefer PERL to Perl also
09:14:08 <matthiasgorgens> Mortchek: int myFunction(int variable1) binds variable1.
09:14:14 <nikita-0> There is a Dijkstra paper (one of EWDs), where he discusses the famous Backus Turing lecture about FP.
09:14:18 <matthiasgorgens> variable1 = someValue does assignment.
09:14:29 <nikita-0> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD692.html
09:14:29 <matthiasgorgens> osfameron: as long as it runs on UNIX.
09:14:46 <Jafet> @remember byorgey HASKELL is a pure, functional, strongly typed language featuring a name with all capitals, so it is suitable for beginners
09:14:46 <lambdabot> I will never forget.
09:14:52 <lpsmith> well, the earliest basics do tend to be spelled BASIC... I'm not so sure about Pascal though.   I've not seen that in all caps that often.
09:15:04 <osfameron> LOGO was in all caps iirc
09:15:08 <matthiasgorgens> FORTRAN, too.
09:15:09 <Mortchek> matthiasgorgens, are you referring to a syntactical or semantic special case?
09:15:09 <Philippa_> Hackers' Abstract Symbolic...?
09:15:14 <int-e> and INTERCAL
09:15:15 <matthiasgorgens> Mortchek: syntatict.
09:15:20 <Mortchek> Ah, I see.
09:15:22 * matthiasgorgens can't spell.
09:15:31 <Philippa_> Pascal was never an acronym
09:15:37 <Philippa_> (or other abbreviation)
09:15:39 <luite> C is also caps ;)
09:15:48 <luite> +aal
09:15:49 <luite> all
09:15:50 <matthiasgorgens> Philippa_: the SK in HASKELL stands for the SK[i] calculus.
09:16:03 <osfameron> ...Komputing Electronical Language Language
09:16:12 <int-e> hmm :) http://acronyms.thefreedictionary.com/PASCAL
09:16:20 <maukd> C is a recursive acronym
09:16:40 <matthiasgorgens> maukd: and not a very productive one.
09:17:00 <nikita-0> C is Corecursive.
09:17:26 <lpsmith> C is the ultimate recursion
09:17:31 <quicksilver> Philippa_: indeed, but the all-caps spelling was nonetheless popular for a while.
09:17:32 <watermind> matthiasgorgens: somewhat related to that Robert Harper from CM chooses the term "assignables" for mutable variables and reserves varibales for those in lambda terms
09:18:02 <quicksilver> I think maybe *all* programming language were assumed to be all-caps at a certain phase in the development of the field
09:18:06 <Jafet> Veryables
09:18:07 <matthiasgorgens> watermind: might be a good choice.  in Haskell we call them MVars and TVars and so on. :o)
09:18:24 <matthiasgorgens> quicksilver: plankalkuel was never all-caps.
09:18:29 <watermind> matthiasgorgens: yes but if you program in C you call them variables
09:18:35 <quicksilver> matthiasgorgens: :)
09:18:37 <lpsmith> I prefered to spell Pascal as Turbo Pascal.
09:18:37 <byorgey> I think maybe all *text* was assumed to be all-caps at a certain phase in the development of the field.
09:18:42 <matthiasgorgens> watermind: yes.  one might do that.
09:18:45 <watermind> matthiasgorgens: he sticks to assignables even in the context of imperative programming
09:18:59 <int-e> lpsmith: as long as you don't spell it Delphi :P
09:19:06 <matthiasgorgens> watermind: ok.  though that'll just confuse the people you talk to, if you aren't careful.
09:19:08 <newmind> if you're coding on punch cards, every bit counts
09:19:18 <watermind> matthiasgorgens: he talks to his students :P
09:19:29 <quicksilver> "The only characters in the punched-card character set were upper-case letters, digits, and a few punctuation marks. That's why programming language names were always spelled with all caps. (Plus they are mostly acronyms.)"
09:19:37 <quicksilver> (from http://www.cse.buffalo.edu/~shapiro/Courses/CSE305/Notes/notes2.html )
09:20:01 <watermind> matthiasgorgens: also note that tons of languages these days have imperative features and lambda terms, so it really is useful to distiguish them
09:20:06 <byorgey> quicksilver: hah, nice
09:20:11 <newmind> also, there were mobile punch card... punchers? => first PDA
09:20:14 <lpsmith> int-e, nah,  I'd moved on to C and C++ at that point.   But not for long before I hated every language I then knew
09:20:23 <matthiasgorgens> watermind: yes.  though in, say, C, you can re-assign arguments.
09:20:53 <matthiasgorgens> lpsmith: we also hate haskell. just on a higher level.
09:20:56 <watermind> matthiasgorgens: what do you mean by that?
09:21:05 <watermind> re-assign arguments that is
09:21:34 <killy9999> a stupid question: where do I find source of standard prelude? except for hackage
09:22:02 <matthiasgorgens> watermind: if you have int f(int i)
09:22:03 <lpsmith> killy9999, Haskell 98 report?
09:22:10 <matthiasgorgens> then you can do i=23; in the body of the function.
09:23:51 <killy9999> lpsmith: thanks!
09:24:00 <killy9999> I knew this has some simple answer
09:24:11 <killy9999> anyway, I'll go with Haskell 2010 report
09:25:46 <jfischoff> hmm, what is the best way to handle generate one of two mutually recursive types with Template Haskell?
09:26:14 <jfischoff> Do I need to have the types topologically sorted?
09:27:07 <quicksilver> that's a good question.
09:27:35 <quicksilver> if you dump out the whole bunch in a single splice it shouldn't matter should it?
09:28:03 <jfischoff> the problem is where do I put the handwritten one
09:28:17 <jfischoff> do I need to have that in the slice too?
09:30:01 <quicksilver> oh you have a handwritten one which mutually recurses with a TH-generated one?
09:30:06 <jfischoff> yes
09:30:11 <jfischoff> and vice a versa
09:30:22 <quicksilver> well 'mutually' covers vice versa :)
09:30:28 * jfischoff realizes that was obvious
09:30:32 <jfischoff> :)
09:30:34 <quicksilver> I believe you're going to have to dump them in the same splice
09:30:40 <jfischoff> crap
09:30:51 <quicksilver> unless you're prepared to consider unwrapping the recursion via an Mu-like operator
09:30:58 <quicksilver> well, or just by adding a parameter
09:31:00 <jfischoff> go on
09:31:06 <jfischoff> ah
09:31:09 <quicksilver> data Foo = Bar | Baz Baz
09:31:23 <quicksilver> data Baz = Frib | Foo Foo
09:31:29 <quicksilver> ^^ mutually recursive
09:31:38 <quicksilver> data Foo t = Bar | Baz t
09:31:41 <jfischoff> yep
09:31:41 <quicksilver> ^^ standalone
09:31:47 <jfischoff> that is a good work around
09:31:50 <quicksilver> but "Foo Baz" will recover the recursion.
09:32:23 <jfischoff> hmm
09:32:41 <jfischoff> well that still might be problematic
09:35:45 <watermind> matthiasgorgens: yes that would be an assignable, C doesn't have variables because it doesn't have lambda terms/closures
09:36:47 <watermind> matthiasgorgens: at least that's how interpreted his explanation...
09:37:30 <watermind> matthiasgorgens: now if you have languages where the 'variables' in lambda terms can be assigned new values within the closure body, then I have no idea what to call them :P
09:42:48 <tromp_> i think scheme calls them variables:)
09:50:20 <merijn> @pl \x v -> f x (g x v)
09:50:20 <lambdabot> liftM2 (.) f g
09:52:16 <Ferdirand> @type (f . g)
09:52:17 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, SimpleReflect.FromExpr (f a), Functor f) => f b
09:52:46 <clahey_> :t flip
09:52:47 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:53:03 <Ferdirand> wait, what ??
09:53:10 <merijn> Wow, Caleskell is making everything nice and readablea gain :p
09:53:16 <byorgey> @type Prelude.flip
09:53:17 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:53:23 <Ferdirand> oh, that makes sense
09:53:24 <thoughtpolice> edwardk: https://github.com/ghc/ghc/commit/8a9a7a8c42da3adb603f319a74e304af5e1b2128 ! :D
09:53:25 <merijn> Ferdirand: lambdabot has some more general definitions for some functions
09:53:37 <byorgey> Ferdirand: lambdabot has some strange generalized stuff built in
09:53:40 <Ferdirand> merijn: yes i know, first time I see the flip one though
09:53:43 * hackagebot angel 0.3.3 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.3.3 (JamieTurner)
09:53:45 * hackagebot zippo 0.2 - A simple lens-based, generic, heterogenous, type-checked zipper library  http://hackage.haskell.org/package/zippo-0.2 (BrandonSimmons)
09:53:49 <byorgey> which is fun to play with but sometimes confusing for beginners.
09:53:58 <merijn> :t (f Prelude.. g)
09:53:59 <lambdabot>     Ambiguous type variable `b' in the constraints:
09:53:59 <lambdabot>       `Show b' arising from a use of `f' at <interactive>:1:1
09:53:59 <lambdabot>       `SimpleReflect.FromExpr b'
09:54:18 <Ferdirand> > (drop ++ take) 5 ['a'..'z']
09:54:20 <lambdabot>   "fghijklmnopqrstuvwxyzabcde"
09:57:41 <Ornedan> Is it possible to only alter the contents of a particular element of a repa array?
10:02:51 <mietek> @djinn m a -> m b -> m (a, b)
10:02:52 <lambdabot> -- f cannot be realized.
10:03:03 <mietek> Huh?
10:03:17 <Ferdirand> @type liftM2 (,)
10:03:18 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
10:03:37 <EvanR> im getting the feeling that its more idiomatic in ruby to use exceptions for basic 'failure conditions' rather than a maybe-like or either-like type
10:03:44 * hackagebot grid 2.0 - Tools for working with regular grids\/graphs\/lattices.  http://hackage.haskell.org/package/grid-2.0 (AmyDeBuitleir)
10:03:44 <EvanR> which annoys me
10:03:46 <mietek> Ferdirand++
10:03:53 <nand`> what if you use exceptions to implement maybe/either ?
10:04:07 <EvanR> if its in the implementation thats irrelevant
10:04:22 <EvanR> im talking about using them directly
10:04:28 <EvanR> rather than a maybe/either interface
10:08:20 <watermind> so church gave a negative answer to hilberts problem based on the _untyped_ lambda calculus, right?
10:09:00 <watermind> but his system based on untyped lambda calculus was inconsistent
10:09:19 <watermind> so how can he have used that?
10:10:17 <mcstar> remind me, what was exactly hilbert's problem?
10:10:25 <atriq> Excerpt from evil program I'm writing:
10:10:36 <watermind> decidability procedure for proofs in 1st order logic
10:10:40 <atriq> 0.0(0.0(0 0.0)(0.0(0 0)(0.0(0 0.0)(0.0(0(0.0(0.0 0 0)))0))))(0 0)
10:11:09 <mcstar> and church answered that at around the same time as turing?
10:11:28 <watermind> the year before
10:11:56 <byorgey> watermind: Church's proof wasn't expressed IN the lambda calculus
10:12:20 <jnhnum1> unrelated question: how do callbacks from C into haskell get scheduled?  I'm trying to use hinotify, but if the main haskell program terminates, I don't think it will receive a callback?
10:12:26 <byorgey> it showed that there is no way to decide equivalence of lambda calculus terms.
10:12:34 <watermind> byorgey: yes I understand that, but the method was showing that you could not prove 2 lambda terms to be equivalente, in general
10:12:37 <mcstar> the word problem?
10:12:40 <byorgey> the consistency of the lambda calculus as a logic doesn't enter into it at all.
10:12:50 <byorgey> watermind: right
10:13:04 <watermind> byorgey: but what is the relation between lambda terms and first order logic, since the first is inconsistent and the second isn't?
10:13:23 <Cale> watermind: He's only using the lambda calculus as a definition of what it means to effectively compute something in that case.
10:14:03 <Cale> watermind: The connection between lambda calculi and logic is essentially this:
10:14:04 <mcstar> ah, he used lambda calculus as a vehicle to algorithmify first order logic?
10:14:32 <Cale> When you prove that A -> B in logic, you assume that A is true, and construct a proof of B based on that assumption
10:14:32 <byorgey> watermind: whether two lambda calculus expressions are equivalent can be formulated as a statement in first order logic
10:15:21 <byorgey> oh, hmm, actually, I'm not sure
10:15:28 <byorgey> that's how Turing's proof goes
10:15:33 <dented42> I vaguely remember reading a paper (or part of a paper) that talked about several strategies that were considered for generating variable names and avoiding collisions in GHC, does anyone remember which paper it was?
10:15:35 <watermind> Cale: yes I understand Curry Howard (I think), and I understand how lambda notation provides a method for proof simplification
10:15:43 <Cale> When you write a function of type A -> B, you assume that you have a value x of type A, and construct from it an expression y of type B, and then the lambda term \x -> y is your function
10:15:46 <Cale> right
10:15:50 <byorgey> whether a TM halts or not can be formulated as a statement in first order logic.
10:16:22 <Cale> So, the reason that untyped lambda calculus is considered inconsistent is that there is a construction of a fixpoint operator in it.
10:16:32 <Cale> Which would have type (A -> A) -> A
10:16:32 <watermind> Cale: yes
10:16:41 <Cale> and that can be applied to the identity to prove anything
10:16:47 <watermind> Cale: the usual example being fix (~)
10:16:53 <watermind> with ~ being NOT
10:17:08 <merijn> @pl \x -> f x . g x
10:17:08 <lambdabot> liftM2 (.) f g
10:17:17 <Cale> watermind: or even just fix id, will do nicely
10:17:24 <watermind> Cale: true :)
10:17:29 <companion_cube> but why do you type untyped lambda calculus... ?
10:17:38 <EvanR> :t fix id
10:17:39 <lambdabot> forall a. a
10:17:51 <EvanR> > fix id 9
10:17:55 <lambdabot>   mueval-core: Time limit exceeded
10:18:28 <Cale> companion_cube: In order to show how its terms denote "proofs" in a way which turns out to be inconsistent, and so it (the untyped lambda calculus) turned out to be unsuccessful as a logic.
10:18:41 <companion_cube> well yes, that's why it's untyped -_-
10:18:59 <jnhnum1> say I use the FFI to pass a haskell function to some C code, and then the haskell portion terminates, and then the C code tries to call that function, what happens?
10:19:11 <Cale> It was originally intended to be a formal logic though, it just wasn't successful at that.
10:19:16 <merijn> jnhnum1: How can the haskell portion terminate?
10:19:25 <Cale> It *was* successful at formalising computation.
10:19:27 <jfischoff> yeah they would be in the same process
10:19:59 <companion_cube> but then there is the simply typed lambda calculus, that is a successful higher order logic
10:20:00 <watermind> Cale: so define a logic in untyped lambda calculus, but then it turns out to be inconsistent (which first order logic isn't) so then how do you translante the negative result regarding effective computation in the calculus to 1st order logic
10:20:17 <watermind> that's the bit I'm missing, because both systems are clearly not equivalent
10:20:30 <Cale> watermind: byorgey nailed it earlier
10:20:43 <jnhnum1> merijn: so main = do $ passSomethingToC
10:21:00 <jnhnum1> and then passSomethingToC returns
10:21:05 <Cale> watermind: You can formalise the normalisation of untyped lambda terms in first order logic.
10:21:09 <jnhnum1> well actually
10:21:09 <geekosaur> it is possible to initiate and terminate the GHC runtime from a C program; I expect that any references held by the C program into the GHC runtime would either prohibit the GHC runtime from exiting (if properly set up) or would dump core
10:21:23 <jnhnum1> the specific example I'm thinking of is inotify
10:21:29 <jnhnum1> which is supposed to notify you when a file is changed
10:21:37 <Cale> watermind: In such a way that determining whether the first order logic statement was true would be to decide whether the program halted.
10:21:49 <watermind> ah ah!
10:21:53 <Cale> watermind: and we know that there can't be a program which decides this
10:21:57 <watermind> Cale: byorgey: thank you got it
10:21:58 <merijn> jnhnum1: I'm not familiar with inotify, but I'm assuming you pass a C callback to the kernel to call for you?
10:21:59 <byorgey> yes, I just skimmed over Church's actual paper
10:22:01 <geekosaur> since C can't really track that a pointer sourced from GHC has been released, I would expect core dumps tbh
10:22:13 <jnhnum1> there is supposed to be this library hinotify http://hackage.haskell.org/package/hinotify which wraps the C library for inotify
10:22:17 <jnhnum1> merijn: yeah something like that
10:22:25 <mcstar> byorgey: can you share or point to it?
10:22:31 <merijn> jnhnum1: In which case the answer would be "the same thing happens as when you hand a C pointer to it and the process with the C pointer exits"
10:22:31 <byorgey> watermind, Cale: in fact it isn't termination that is used, but equivalence of two lambda calculus expressions
10:22:32 <geekosaur> it is in generall better to let haskell provide the main and invoke C from Haskell, in which case the C part will not be running when the Haskell main terminates
10:22:41 <byorgey> though I suppose that's probably equivalent
10:22:45 <Cale> byorgey: ah, okay
10:23:08 <merijn> jnhnum1: C pointer are also no longer valid when their process exits, so...
10:23:10 <Cale> You can do it either way, surely.
10:23:11 <geekosaur> jnhnum1, are you initializing Haskell form a C main()?  if not, the situation yoyu speak of cannot exist
10:23:47 <byorgey> watermind: here's one: phil415.pbworks.com/f/Church.pdf
10:23:49 <jnhnum1> so if you look at hinotify, it's supposed to be some nice haskell wrapper - so I guess it calls C from haskell, and not the other way around.  but basically I don't know how to make it work
10:24:01 <byorgey> Cale: yes, I'm sure you can
10:24:28 <mcstar> thanks
10:25:11 <enolan> why does [1..9] work, but my custom type in Enum give a syntax error for [C2..C6]?
10:25:33 <enolan> Does ghc think C2 is a module name or something?
10:25:37 <EvanR> > [False..True]
10:25:38 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
10:25:43 <EvanR> > [False .. True]
10:25:43 <watermind> byorgey: thanks!
10:25:44 <lambdabot>   [False,True]
10:25:52 <EvanR> [C2 .. C6]
10:25:53 <enolan> it says Failed to load interface for `C2'
10:26:03 <geekosaur> enolan, yes, you need spaces around the ..
10:26:15 <geekosaur> it's a syntactic ambiguity
10:26:17 <enolan> well I figured that out, but why?
10:26:34 <EvanR> C2.Foo is something else, syntactically
10:27:00 <EvanR> > [2..4]
10:27:01 <lambdabot>   [2,3,4]
10:27:03 <EvanR> 2.Foo isnt
10:27:11 <enolan> So C2.Foo is a fully-qualified name, but C2 . foo is composition?
10:27:27 <EvanR> and [C2 .. foo] is enum
10:27:32 <geekosaur> C2.foo is also a qualified name (of a function instead of a constructor)
10:27:51 <geekosaur> and C2.. could be either the start of an enum, or the operator (.) defined in module C2
10:28:32 <enolan> alright, good enough answer. This is a confusing little corner of Haskell.
10:28:33 <geekosaur> er, of a range
10:28:36 <geekosaur> yep
10:28:45 * hackagebot som 1.0 - Self-Organising Maps  http://hackage.haskell.org/package/som-1.0 (AmyDeBuitleir)
10:28:46 <geekosaur> wait until you see how unary - works  :)
10:29:17 <Cale> Well, unary - may be a little non-uniform, but it's non-uniform in exactly the way that you'd expect, I think :)
10:33:35 <mcstar> byorgey: is there a definition of 'effectively calculable'?
10:34:12 <merijn> gah
10:34:22 <merijn> I have a problem with something not being polymorphic enough
10:34:34 <NihilistDandy> Don't we all?
10:34:53 <EvanR> sometimes its too polymorphic
10:35:00 <merijn> Hold on, hpaste inc
10:35:09 <EvanR> and it doesnt matter what types it picks, but you have to pick something
10:35:17 <EvanR> and it wont pick for you
10:37:46 <moqca> Anyone know a good guide to decorators?
10:38:40 <moqca> Oops, wrong channel
10:38:41 <mcstar> erm, thats for python
10:38:52 <moqca> yeah, wrong tab open, haha
10:38:58 <Ornedan> Is it possible to only alter the contents of a particular element of a repa array?
10:39:23 <hpaste> merijn pasted “Not polymorphic enough!” at http://hpaste.org/74921
10:39:45 <merijn> EvanR: Not the case here
10:40:30 <geekosaur> Ornedan, if asking here gets you no answers, try the haskell-cafe list
10:40:54 <Ornedan> All can sort of hack it with traverse and a set of the elements I want to alter, but the Set.members add a fair bit of running time
10:42:48 <mcstar> Ornedan: writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
10:43:24 <Ornedan> mcstar: I don't think that works on repa arrays
10:43:56 <mcstar> erm, sorry, misread the module name
10:45:28 <Ornedan> The underlying problem is that I need an image manipulation library that can handle TGA. Codec-Image-DevIL and repa-devil seem the only choices for what I want to do. The former makes the image data into an UArray, the latter into a repa Array
10:45:40 <t7> is there a reason people would need first class polymorphism when they allready have let abstraction?
10:46:02 <Ornedan> Problem is Codec-Image-DevIL image loading is crazy inefficient
10:46:42 <Ornedan> On the order of several minutes for a 4000x3000 image
10:47:08 <Ralith> o.O
10:48:03 <obiwahn> > fix (\x->"slap obi"++x)
10:48:05 <lambdabot>   "slap obislap obislap obislap obislap obislap obislap obislap obislap obisl...
10:48:34 <obiwahn> > fix (\x->x++"slap obi")
10:48:37 <lambdabot>   mueval-core: Time limit exceeded
10:48:52 <obiwahn> my bot fails with mueval-core: Time limit exceeded on the fist
10:49:16 <jfischoff> Ordenan: I have used repa-devil of images around 1000 x 600 which loads in ~ a second. Is the code compiled or run ghci?
10:50:31 <rwbarton> 500x500-ish jpg loading in 0.2 seconds with repa-devil here
10:51:04 <mcstar> Ornedan: i see, that you can make repa arrays from Data.Vector, maybe you can use a mutable vector and turn that into a repa array?
10:51:55 <jfischoff> the repa-devil is loading into a foreign array is similar
10:52:23 <jfischoff> its an unboxed c array I think
10:52:41 <Fuuzetsu> @src ($!!)
10:52:41 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:52:53 <mcstar> 1000x600 in a second? that sounds really slow
10:53:36 <jfischoff> mcstar: I don't know the exact time
10:54:07 <jfischoff> mcstar: I'm profiling it with my internal clock from memory which is not that precise
10:54:27 <mcstar> it just seems slow to me, imho
10:54:41 <mcstar> is tga compressed at all?
10:55:04 <mcstar> anyway, that image is just a couple megabytes
10:59:07 <Ornedan> mcstar: That might work if I can also do the reverse. I want to change a subset of the pixels in an image
10:59:56 <mcstar> my only source is the docs, i never used repa before, so, sorry
11:16:54 <downloader> I have improperly encoded data (bencode) that fails to parse but I don't know where. What is the easiest way to find out how the data is broken?
11:17:05 <jnhnum1> what's the best way to make a haskell process wait forever / until it receives a SIGTERM
11:17:24 <downloader> (Not a haskell specific question, just thought people here would be best to ask)
11:17:43 <ClaudiusMaximus> main = forkIO realstuff >> forever (threadDelay maxBound)   perhaps
11:19:09 <jnhnum1> hmm ok
11:19:22 <Cale> jnhnum1: Are you sure that's really what you want to do?
11:19:50 <jnhnum1> well not entirely
11:20:08 <Cale> Most of the obvious ways of waiting forever will be detected by the runtime and the RTS will kill the thread :)
11:20:09 <jnhnum1> I have a process that should basically only be acting on inotify callbacks when some file in the file system has changed
11:20:50 <shachaf> The inotify interface involves SIGTERM?
11:22:34 <shachaf> jnhnum1: It looks to me like th einotify interface returns a file descriptor that you read() on.
11:23:39 <jfischoff> never seen this error before: lookupSymbol failed in relocateSection (relocate external)
11:24:05 <jfischoff> any ideas?
11:24:34 <shachaf> @google "lookupSymbol failed in relocateSection (relocate external)"
11:24:36 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/5748
11:24:37 <lambdabot> Title: #5748 (ghci segfault on OS X after dlsym failed lookup) – GHC
11:24:43 <shachaf> I suspect without more context, people won't be able to help you more than that. :-)
11:25:02 <jfischoff> probably...
11:26:55 <geekosaur> jfischoff, you might tke a look at some of the diagnostic envars in dyld(1) to help debug it from the OS X end
11:27:21 <jfischoff> I think I found the issue. I think it is other-modules problem...
11:33:37 <byorgey> mcstar: Church defined 'effectively calculable' using the lambda calculus
11:33:58 <byorgey> mcstar: then Turing proved it was equivalent to saying it could be computed using a Turing machine
11:34:31 <byorgey> mcstar: and every other 'reasonable' computational system anyone has invented since has turned out to be equivalent as well.
11:38:44 <mcstar> byorgey: im reading that article intermittently, it seems it will be one of Church's point to describe this term exactly
11:39:41 <mcstar> quantum computation is a different kind of computation, isnt it? it can change the algorithmic complexity of stuff
11:40:19 <geekosaur> it's a different approach to computing.  whether it actually changes anything is still an open question, believe it or not
11:41:38 <geekosaur> I recall seeing a paper go by recently on sciencedaily suggesting that some things that were thought to be only tractable via quantum computing might actually be representable via traditional computing, but we just haven't figured out the necessary algorithms yet.
11:41:44 <mcstar> as i understand, it is logically equivalent to classical machines, but it changes what can be considered effective and what not
11:41:45 <mcstar> afaik
11:42:41 <mcstar> (by 'logically equivalent' i meant, what was undecidable does not suddenly become deciadble...)
11:42:45 <downloader> geekosaur: It's analogous to P vs NP
11:43:00 <geekosaur> ... I guess what I said was not clear
11:43:15 <geekosaur> there is a common belief that quantum computing can do some things faster than traditional.
11:43:22 <geekosaur> this belief may in fact be entirely false
11:43:26 <mcstar> i get it
11:43:40 <mcstar> you think a different algorithm would do it with the same complexity on classical computers
11:43:46 <mcstar> at least, it is not ruled out
11:43:53 <geekosaur> I said I saw a paper go by on SD that claimed so
11:43:58 <geekosaur> I can try to dig it out
11:44:23 <downloader> geekosaur: No need. It is not know whether P is strictly contained in BQP
11:44:28 <Jafet> There is a common belief that the riemann hypothesis is true
11:44:45 <Jafet> This belief may in fact be entirely false
11:45:07 <Jafet> Let's publish a pop science article on the philosophical implications
11:45:26 <mcstar> if it would be false in all generality, still it would be true for most of the known examples
11:46:48 <mcstar> (^^ as a comment on your 'entirely')
11:47:15 <downloader> Known examples of what?
11:48:20 <mcstar> well, so far noone has found a counterexample
11:48:41 <mcstar> finding a non trivial root with im part /= 1/2?
11:48:50 * hackagebot snap-core 0.9.2 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.2 (GregoryCollins)
11:48:52 * hackagebot snap-server 0.9.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.2 (GregoryCollins)
11:48:54 * hackagebot snap 0.9.2 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.9.2 (GregoryCollins)
11:48:56 * hackagebot fountain 0.0.2 - A fountain codec.  http://hackage.haskell.org/package/fountain-0.0.2 (TomHawkins)
11:49:48 <downloader> mcstar: What is the set of "known examples"? Are you talking about a family of Riemann Hypotheseses?
11:50:00 <downloader> hypotheses?
11:50:09 <Jafet> hypothesii
11:50:16 <uniquenick> is there a simple way to turn off warnings for just one file, but leave them on for the rest of the project?
11:50:22 <mcstar> it would be the set of roots checked already
11:51:21 <Botje> uniquenick: don't use -w, use warnings per file.
11:51:24 <Botje> hh
11:51:30 <Botje> oops. wrong programmign language :)
11:51:46 <Jafet> use strictmeharder
11:51:54 <mcstar> if you had some stuff, that would depend on the riemann hypothesis being true, but in practice wouldnt approach the limit of checked roots, then you could build on that, even if the hypothesis would turn out to be false
11:54:05 <Jafet> uniquenick: OPTIONS pragma
11:55:08 <downloader> mcstar: I have a hard time believing that in general. Take for example limiting arguments.
11:56:54 <edwardk> preflex: xseen jfischoff
11:56:59 <jfischoff> yo
11:57:05 <edwardk> preflex dead and gone?
11:57:12 <Botje> along with mauke
11:57:13 <jfischoff> are you out in sf tomorrow?
11:57:14 <edwardk> that worked better than expected =)
11:57:28 <edwardk> next month
11:57:29 <Eduard_Munteanu> Maybe there's a preflew around.
11:57:32 <jfischoff> ah cool
11:57:41 <edwardk> oct 19-22 or so
11:57:52 <jfischoff> sweet I'll be there
11:58:05 <akamaus> do anybody have an experience using X11 package?
11:58:18 <edwardk> re jberryman's inquery: listToMaybe.holesOf, should do it
11:58:25 <edwardk> er inquiry
11:58:35 <jfischoff> for the sum type?
11:59:00 <edwardk> for how to extract the moral equivalent of a -> Maybe (b, b -> a) from a Traversal
11:59:17 <edwardk> that gives you a -> Maybe (Context b b a)
11:59:28 <edwardk> where Context c d a = Context (d -> a) b
11:59:39 <jfischoff> ah
11:59:42 <jfischoff> I see
11:59:47 * Eduard_Munteanu . o O (moral equality, now!)
11:59:48 <akamaus> I'm looking for a way to send events using sendEvent function and can't decipher types involved.
12:00:47 <Eduard_Munteanu> BTW, where do I read stuff about ITT/ETT/OTT? I'm looking for the basics plus some comparison.
12:01:33 <Eduard_Munteanu> I figure that's probably a good idea before jumping into HTT.
12:02:17 <Eduard_Munteanu> Should I ask for a book on MLTT instead?
12:02:43 <edwardk> jfischoff: without the listToMaybe it'll give you all of the editable contexts
12:02:52 <edwardk> a -> [Context b b a]
12:03:23 <edwardk> Eduard_Munteanu: its a highly extensional form of equality and it is related to homotopy type theory.
12:03:37 * jfischoff wishes he had time to update his depends to work with Control.Lens
12:04:11 <Eduard_Munteanu> edwardk: what exactly? :)
12:04:23 <edwardk> moral equivalence
12:04:36 <Eduard_Munteanu> Ah. So that's an actual concept :)
12:04:49 <edwardk> no, just a bad joke about extensionality
12:05:03 <Eduard_Munteanu> Heh.
12:05:10 <Jafet> They've just managed to formalise moral equivalence there
12:05:15 <hpaste> number9 pasted “xmonad.hs” at http://hpaste.org/74925
12:05:19 <Eduard_Munteanu> Moral Type Theory!
12:05:37 <edwardk> i want it. just so i can say my type systems are amoral
12:09:32 <watermind> isn't there a theorem called bhom's theorem?
12:09:38 <watermind> I'm googling it and can't find it
12:09:42 <watermind> for lambda calculus
12:10:31 <downloader> bohm or boehm
12:10:36 <downloader> maybe
12:10:42 <watermind> hmm
12:11:05 <watermind> yes bohm!
12:11:07 <watermind> thanks downloader
12:11:10 <downloader> k
12:11:25 <hiptobecubic> Is logic equivalence of A and B the same as A entailing B and B entailing A ?
12:11:28 <hiptobecubic> It should be, right?
12:11:49 <n-dolio> That is the usual definition of logical equivalence.
12:12:18 <hpaste> number9 pasted “strace.log” at http://hpaste.org/74926
12:13:03 <hiptobecubic> n-dolio, ok thanks
12:14:37 <n-dolio> hiptobecubic: It's interesting to note what is left out of that.
12:15:13 <n-dolio> Equivalence of sets (isomorphism) A B is two functions f : A -> B and g : B -> A that are inverse.
12:15:42 <n-dolio> But you don't need the inverse requirement for propositions, because it's trivial.
12:16:16 <hiptobecubic> what do you mean
12:16:21 <n-dolio> And for categories you have two functors f : A -> B, g : B -> A that are inverse up to isomorphism.
12:17:26 <hiptobecubic> n-dolio, inverse "up to isomorphism" ?
12:17:28 <n-dolio> I mean that the definition of A and B being propositions in some circles is that A -> B has at most one element.
12:17:43 <jkff> Hey. Do comonads have useful duals of stuff from Control.Monad - like mapM, sequence, filterM etc?
12:18:08 <Eduard_Munteanu> hiptobecubic: g . f isn't the identity functor, but there's a natural isomorphism between that and the identity functor
12:18:15 <n-dolio> So if you have proofs of A -> B and B -> A, then they are inverses automatically because the only proofs of A -> A and B -> B are the identity.
12:18:31 <Eduard_Munteanu> Same for f . g.
12:18:55 <Eduard_Munteanu> Isn't necessarily, I mean.
12:19:25 <edwardk> jkff: not as much. there are lot of them that have a 'Distributive' instance, that lets you use them as sort of a dual to 'Traversable'.
12:19:34 <hpaste> number9 pasted “strace” at http://hpaste.org/74927
12:19:44 <Eduard_Munteanu> jkff: actually, only sequence is special in that sense
12:19:57 <jkff> edwardk: Hm, thanks. Is there a fundamental reason why these useful duals don't exist?
12:20:00 <Eduard_Munteanu> @src mapM
12:20:00 <lambdabot> mapM f as = sequence (map f as)
12:20:19 <n-dolio> hiptobecubic: You don't really need to worry about what I'm saying. It just occurred to me.
12:20:26 <edwardk> the dual of sequence is distribute.
12:20:44 <edwardk> so they do exist
12:20:54 <edwardk> but the analogues aren't useful for the kinds of things you'd expect
12:21:00 <jkff> Ok, I see it...
12:21:35 <jkff> Wow, they make sense. It just remains to find a use for them :)
12:21:59 <Eduard_Munteanu> edwardk: isn't there something like a strong comonad? I mean, isn't Distributive the same thing as Traversable in that sense?
12:22:24 <jkff> Suppose we're talking about the "pointed array" comonad. Let's think what cotraverse could do to it.
12:22:39 <edwardk> brb
12:23:40 <jkff> So we have a double filter over, say, double-valued pixels (w a -> b), and we somehow apply it to a pointed array of Complex Double (g a). And we get a Complex Double as a result.
12:23:47 <jkff> All this if we have a Distributive instance for Complex.
12:23:54 <jkff> Types check, but WTF does this mean? :)
12:23:58 <nikooo> ciao
12:24:07 <jkff> :t cotraverse
12:24:08 <lambdabot> Not in scope: `cotraverse'
12:24:16 <jkff> cotraverse :: Comonad w => (w a -> b) -> w (g a) -> g b
12:24:20 <nikooo> !list
12:25:02 <jkff> Or suppose g is [], the well-known type of 3-item lists. So we have a filter on black-and-white pixels and we apply it uniformly to a filter of RGB pixels.
12:25:10 <jkff> *to an array
12:25:31 <jkff> Still doesn't seem very useful, actually...
12:26:10 <Eduard_Munteanu> :t Data.Traversable.sequence
12:26:11 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
12:26:18 <asdgasdf> @pl \fs xs -> (filter (and . flip map fs . flip ($)) xs)
12:26:19 <lambdabot> filter . (and .) . (. flip id) . flip map
12:26:33 <Eduard_Munteanu> jkff: consider a cosequence, analogue to the above.
12:26:51 <jkff> Yup. In my example, it would "split the channels" in an array of 3-colorer pixels
12:28:13 <jkff> This would probably be more interesting with fancier comonads, but I haven't yet seen very fancy ones - so far I saw only the different variations on pointed arrays
12:28:23 * mcstar wonders wheres the line dividing useful and not-so-much-useful-but-just-rather-complicates-things abstractions
12:29:05 <edwardk> mcstar: the problem is without knowing the abstractions first, its hard to judge what abstractions are too abstract to be useful ;)
12:29:20 <jkff> mcstar: how would you split the channels in an image without a comonad and a distributive functor? I challenge you!
12:29:23 <edwardk> mcstar: there is a strong dunning-kruger effect at work =)
12:29:33 <mcstar> just dont forget to factor in your time studying abstractions :)
12:29:34 <edwardk> jkff: =)
12:29:59 <edwardk> mcstar: *shrug* i value my time surprisingly little, and i like learning stuff
12:30:26 <mcstar> theres a whole lot, that i will never know :(
12:30:27 <jkff> The most interesting comonad I learnt so far is the comonad (Monoid w) => w -> a. However, its only application I'm aware of is a variation on a pointed array, where w is a Num.
12:30:33 <Eduard_Munteanu> mcstar: mm, all this stuff can serve as a source of inspiration for various programming devices, IMO
12:30:36 <edwardk> the benefit is that i'm usually the guy in the room who has _an_ answer, even if its not the one the folks around me want to hear ;)
12:31:03 <Eduard_Munteanu> Of course, that doesn't mean you can't come up with nice abstractions outside math.
12:31:30 <edwardk> jkff: someone in here the other day was playing with that comonad for composing image space transformations, as a better version of the Pointed array comonad that doesn't bother to track its ambient position.
12:31:39 <edwardk> jkff: blanking for a sec on who it was.
12:31:43 <mcstar> jkff: that problem might be surprisingly easy to solve in c XD
12:31:56 <edwardk> mcstar: he was being sarcastic =P
12:32:01 <mcstar> i am too
12:32:06 <jkff> mcstar: That's probably because there's a comonad crawling in C somewhere
12:32:11 <mcstar> haha
12:32:17 <mcstar> ritchie, the bastard
12:32:27 <EvanR> the C comonad
12:32:28 <rwbarton> what do you think C stands for
12:32:54 <mcstar> now, this would be worth to @remember
12:32:56 <timemage> rwbarton, it doesn't really.
12:33:47 <n-dolio> Did B stand for Bimonad?
12:34:00 <n-dolio> Which are trivial, if I recall correctly?
12:34:10 <timemage> heh
12:35:06 <EvanR> i want a language called A, it will be a reboot of the C family
12:35:27 <EvanR> a reimagining of C
12:38:02 <mcstar> i read some blog post, that Prolog is dying, and the poster though, it wuold be wise to steal many of the good points of haskell
12:38:22 <mcstar> mainly, creating a similar live community around Prolog
12:38:32 <EvanR> haskell: the good parts
12:38:33 <tromp_> there's single assignment C (SAC)
12:38:52 <mcstar> i wonder, if there are efforts, to turn haskell into a logic programming language, or sort of, to beat Prolog from its position
12:38:52 * hackagebot simple-log 0.1.1 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.1.1 (AlexandrRuchkin)
12:39:01 <hiptobecubic> tromp_, wow. Someone not from UvA that knows about SAC?
12:39:12 <tromp_> i am from UvA  :)
12:39:22 <hiptobecubic> Should have known ;)
12:39:26 <tromp_> wait, which UvA are you talking about?
12:39:39 <mcstar> thought*
12:40:09 <jfischoff> mcstar: haskell is a logic programming language, just at the type level ;)
12:40:51 <mcstar> jfischoff: we would want more users than just oleg, wouldnt we?
12:41:05 <hiptobecubic> tromp_, the UvA that's working on SAC?
12:41:13 <hiptobecubic> Not U.Va
12:41:25 <mcstar> and there are stuff that arent built into the language semantics unlike in Prolog
12:41:43 <tromp_> i thought you meant Univ of Amsterdam :)
12:41:45 <mcstar> (though i have absolutely no idea about prolog, just find the idea fascinating...)
12:42:18 <tromp_> i didnt know about SAC when i was at UvA though
12:42:37 <Saizan> mcstar: Curry is a Haskell bent on logic programming, iirc
12:42:43 <hiptobecubic> tromp_, I did mean Amsterdam. And where did you hear about SAC if not here?
12:43:29 <tromp_> online many years ago
12:43:30 <Saizan> mcstar: and there are some libs for constraint programming in haskell, which might be the real meat one can get from Prolog
12:44:09 <Saizan> mcstar: Mercury is also in this area, coming from Prolog though
12:44:40 <mcstar> hm, great, problem solved then
12:45:09 <mcstar> is Curry a haskell implementation with logic programming, or some layer on top of ghc?
12:46:27 <mcstar> what id want/propose is something in haskell, that would work with the current language specification
12:46:41 <mcstar> just to fit the logic programming as seamlessly as possible
12:46:50 <mcstar> fit in*
12:47:22 <Saizan> Curry is its own language, supposedly close to being a superset of Haskell though (i'm just channeling the wikipedia page at this point)
12:47:33 <mcstar> im reading its home page
12:47:50 <mcstar> i think it is a totally separate implementation
12:48:20 <mcstar> ah i found it, there are a dozen implementations of Curry
12:48:37 <Eduard_Munteanu> I'm not exactly sure where logic departs from functional programming.
12:49:13 <Eduard_Munteanu> Is it that logic programming purports to hide algorithmic details, and the programmer is supposed to describe what he wants rather than how things compute?
12:49:44 <jkff> Eduard_Munteanu: I'd say logic programming blurs the distinction between argument and result
12:49:46 <maukd> I think logic/declarative programming is directionless
12:49:48 * Eduard_Munteanu remembers asking this in here before, but for some reason he doesn't find things clear
12:49:50 <jkff> Exactly
12:49:50 <mcstar> there is a built-in constraint solver i guess
12:49:56 <mcstar> and theres something called unification
12:50:17 <rwbarton> relation-based rather than function-based
12:50:52 <Saizan> you are often quite aware of what is supposed to be the argument though, if only to get termination
12:50:57 <Eduard_Munteanu> So it's results-oriented rather than method-oriented, like I hinted above, implementation details aside?
12:51:12 <mcstar> more declarative yes
12:51:21 <Saizan> but it's nice when you get to define a predicate that works in all directions
12:52:08 <mcstar> but that blog also said, that Prolog lacks support for other kind of programmig paradigms, which can be bad, and has all sorts of weird mutable constructs
12:52:49 <mcstar> the 'general programming' in haskell is solved, it is working, but probably hard core logic programmers wont choose haskell
12:54:05 <mcstar> would the type system pose a great challenge? iirc Prolog is untyped
12:55:04 <Saizan> you can do typed logic programming quite fine
12:55:15 <Saizan> e.g. Mercury
12:56:17 <Saizan> in fact if i were to write much Prolog i'd run a typechecker on it
12:57:06 <mcstar> i wonder this 'Curry' why isnt hackage-dowloadable
12:57:13 <raek_> Does anyone know how to compile this example? http://www.haskell.org/haskellwiki/GLFW
12:57:29 <raek_> (I'm new to the Haskell build tools)
12:57:48 <mcstar> i mean, why didnt they make it as a simple lib, what were the factors, that weighed against that decision
12:58:09 <raek_> "cabal install GLFW && ghc Main.hs" results in hundreds of "undefined reference" errors...
12:58:13 <EvanR> it should be as simple as possible, but no simpler
12:58:27 <mcstar> cliche
12:59:15 <mcstar> undefined reference to what?
13:00:44 <raek_> adding "-lGL -lglfw" does not seem to help...
13:00:53 <mcstar> grandfather g c = g =:= father (father c)
13:00:55 <mcstar> grandfather g c = g =:= father (mother c)
13:01:06 <mcstar> hm, interesting Curry top level definition
13:02:27 <mcstar> raek_: paste the full output to somewhere, to got help
13:02:39 <sfogarty> Hi. I found an interesting error on 7.4.2. Is there anyone that can test it for me on a more recent version, before I submit a report?
13:02:59 <raek_> seems like "-package GLFW" was the secret trick
13:03:28 <mcstar> ocamlfind ocamlopt -package GLFW ?
13:04:47 <sfogarty> Anyone with 7.6.2 that can check if they get a crash? I don't want to submit an already-fixed bug :)
13:07:34 <geekosaur> raek_, that sounds like you have an older ghc
13:07:50 <geekosaur> --make is default these days, if you have an old ghc then you'll want to specify it
13:08:25 <raek_> ok
13:58:30 <Ralith> carter_: ping
14:00:19 <jfischoff> has anyone messed around yoko? http://hackage.haskell.org/package/yoko-0.3.2.2
14:07:12 <gwern> @quote
14:07:12 <lambdabot> Speck says: "That's like cheating. It isn't even programming. You just tell it what to do and it does it." -- My friend upon seeing some Haskell code
14:11:37 <centrinia> @quote cheating
14:11:37 <lambdabot> quicksilver says: well if you can get proggit to help with your interview, then perhaps you can get proggit to help with the job when you get it. So it's not cheating, it's just an indication of one
14:11:37 <lambdabot> of your skill sets.
14:11:57 <centrinia> Cheating is certainly a skill.
14:18:58 * hackagebot ekg 0.3.1.2 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.1.2 (JohanTibell)
14:31:41 <Phil__> @pl \k -> (!! (k - 1))
14:31:41 <lambdabot> flip (!!) . subtract 1
14:31:42 <dunric> flip (!!) . subtract 1
14:32:25 <Eduard_Munteanu> @bot
14:32:25 <dunric> :)
14:32:25 <lambdabot> :)
14:32:31 <Eduard_Munteanu> Oh, come on.
14:32:48 <ahobo|work> lol
14:32:50 <ahobo|work> @bot
14:32:50 <lambdabot> :)
14:32:51 <dunric> :)
14:33:00 <parcs`> why
14:33:32 <Eduard_Munteanu> I remember this happening earlier as well.
14:33:44 <Eduard_Munteanu> @where ops
14:33:44 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
14:33:45 <dunric> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
14:33:53 <Eduard_Munteanu> Bah.
14:34:01 <marienz> hmm?
14:34:33 <Eduard_Munteanu> marienz: oh, it's not quite a staff-related issue, but someone should kick the extraneous bot
14:34:37 <Saizan> we got two lambda bots?
14:34:52 <marienz> I'll leave figuring out which one's the real deal and which one's the imposter to an actual chanop, then
14:34:53 --- mode: ChanServ set +o maukd
14:34:53 --- mode: maukd set +b dunric*!*@*
14:35:18 <marienz> also, perhaps someone should increment maukd
14:35:30 <Eduard_Munteanu> Yeah, I remember Cale kicking him earlier or something.
14:35:34 --- mode: maukd set -o maukd
14:35:39 --- mode: ChanServ set +o maukd
14:35:39 --- mode: maukd set +b *!*@213.151.77.75
14:36:10 <Eduard_Munteanu> maukd++
14:36:13 <Eduard_Munteanu> ... in that case :)
14:36:24 --- mode: maukd set -o maukd
14:36:32 <madjestic_> is there a definite answer on whether everything in haskell is a function?  I see some contradictory opinions on that.
14:36:44 <tel> Is there a way to "join" functors like Parser (Maybe a) -> Parser a?
14:36:53 <maukd> madjestic_: the answer is no
14:36:55 <Eduard_Munteanu> madjestic_: not everything is a function
14:36:58 <hiptobecubic> :t (=<<)
14:36:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:37:08 <hiptobecubic> :t (=<<) ($) (+)
14:37:09 <lambdabot> forall a. (Num a) => a -> a
14:37:09 <Eduard_Munteanu> Everything is a value, though.
14:37:11 <zig> hi guys
14:37:15 <maukd> Eduard_Munteanu: even types?
14:37:16 <hiptobecubic> :t (=<<) ($)
14:37:17 <lambdabot> forall a b. (a -> a -> b) -> a -> b
14:37:17 <nand`> madjestic_: for example, ‘False’ is not a function
14:37:30 <hiptobecubic> I always have trouble seeing functions as monads
14:37:38 <Eduard_Munteanu> Fair... every term, be it an ordinary value like in other languages or a function.
14:37:42 <maukd> functions aren't monads
14:37:47 <maukd> ((->) e) is a monad
14:37:59 <Cale> @bot
14:37:59 <lambdabot> :)
14:38:26 <Eduard_Munteanu> I guess that's why Cale had that '@' by his name all day.
14:38:39 <hiptobecubic> maukd, functions to 'e' are a monad then?
14:38:52 <maukd> hiptobecubic: from e
14:38:52 <Cale> Functions *from* e are a monad
14:38:56 <hiptobecubic> oh
14:39:08 <hiptobecubic> OH, it's (->), no (-> e)
14:39:20 <hiptobecubic> not*    ok that's more reasonable maybe
14:39:22 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
14:39:23 <lambdabot>   ("hello","olleh","HELLO")
14:39:59 <gwern> @quote f
14:39:59 <lambdabot> beelsebob says: > filter isJuggler #haskell
14:40:06 <hiptobecubic> Cale, that is just crazy.
14:40:08 <Eduard_Munteanu> hiptobecubic: in particular, that's just the Reader monad
14:40:22 <Eduard_Munteanu> A naked Reader monad, but still.
14:40:28 <hiptobecubic> yes i suppose that makes sense
14:40:35 <hiptobecubic> so in (=<<)
14:40:38 <maukd> ... did I invent the name "naked reader"?
14:40:38 <watermind> so in the typed lambda calculus, False would just be Void, and  NOT A  would be A -> Void... but how about the untyped lambda calculus
14:40:43 <hiptobecubic> :t (=<<)
14:40:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:40:57 <hiptobecubic> ah, m has to be of kind * -> *
14:40:59 <Cale> (f =<< x) e = f (x e) e
14:41:06 <watermind> if there are no types, how did Church intend to define False and negation in the calculus
14:41:08 <Eduard_Munteanu> maukd: all we know is you *could* have invented it ;)
14:41:49 <Cale> watermind: You can encode structures of any algebraic datatype by lambdas having the constructors of that datatype as parameters.
14:41:55 <hiptobecubic> Cale, yes, i understand what it does, i'm trying to understand how that fits the type
14:42:03 <maukd> return = const, ask = id, and =<< is the opposite of ap
14:42:25 <Cale> watermind: for example, booleans become (\false true -> false) and (\false true -> true)
14:43:16 <watermind> Cale: I know that construction but I didn't think it would be it...
14:43:21 <Cale> Suppose we let  False = (\false true -> false) and  True = (\false true -> true)
14:43:42 <Cale> then we can define  Not = \b -> b True False
14:44:08 <Cale> watermind: or do you mean something else?
14:44:09 <watermind> Cale: because & is defined via pairing, and it didn't seem to me like  A & false would be false
14:44:13 <Cale> oh
14:44:16 <Cale> Yes you do :)
14:44:30 <Cale> You mean in the logical interpretation
14:44:33 <Eduard_Munteanu> hiptobecubic: see what '(->) r' maps objects and arrows to, first.
14:44:36 <watermind> Cale: yes
14:45:49 <watermind> Cale: so in the logical interpretation I get the implication rules, and how to construct conjunction
14:46:05 <watermind> Cale: but I don't know how to get negation
14:46:35 <watermind> Cale: because in the typed lambda calculus that would be  A->Void, and Void is just an empty type, and we don't have types
14:46:37 <hiptobecubic> Eduard_Munteanu, what do you mean? '(->) r' are the functions from type r to *something*, right?
14:48:07 <Eduard_Munteanu> hiptobecubic: '(->) r' is a functor too.
14:49:03 <Eduard_Munteanu> fmap :: (a -> b) -> (r -> a) -> (r -> b)
14:49:06 <Ornedan> mcstar: Trying it with vectors was also slow. On the order of 40 secs to convert the big image to vector or back.
14:50:21 <Ornedan> On the other hand, the arrays from repa-devil just wrap a foreign pointer and let one access that pointer. Modifying the pixels via that goes fast enough to round to 0 in the profiling log
14:50:28 <madjestic_> is Sublime Text 2 popular among haskellers?
14:51:34 <Ornedan> mcstar: So thanks for the hint, it got me going in the right direction
14:51:46 <watermind> Cale: also I've seen in quite a few places that Church's paradox is defined by Y(neg) = neg (Y(neg)), but then no one defines neg
14:52:06 <maukd> lol wut
14:52:06 <mcstar> Ornedan: good to hear that, but what takes approximately 0 time?
14:52:13 <maukd> watermind: neg is a function parameter there
14:55:59 <Ornedan> mcstar: The whole get pointer, modify pixels via it thing
14:56:27 <mcstar> so i take it, you only access a few pixels?
14:56:35 <mcstar> not a whole-image transformation
14:56:36 <Ornedan> A few hundred
14:57:15 <mcstar> cause first i thought, you might be modifying the pixels in C, and thats why it wouldnt show up in a profiling
14:57:32 <watermind> maukd: ?
14:58:41 <watermind> maukd: that's not a haskell function definition, that's just a term in lambda calculus representing some proposition
14:58:52 <Cale> watermind: That is actually a good question. I guess you could explicitly put it in.
14:58:58 <Cale> But I wonder if that's actually what he did.
14:59:26 * mcstar checks wiki for that paradox
14:59:33 <Cale> http://profs.info.uaic.ro/~fltiplea/CDC/Chur1932.pdf -- let's look
15:00:02 <mcstar> Did you mean: church parade
15:00:14 <mcstar> -_- i didnt
15:02:01 <Cale> watermind: aha, he just put that stuff in :)
15:03:08 <simon__w> Hi, I'm using handleSourceError to catch type errors and am wondering if there's some way to get some context with the errors? I'm hoping to get the location of the constraint(s) that the failed type didn't unify with.
15:04:44 <mcstar> watermind: what is paradoxical about that?
15:06:19 <zzing_> I have a function:   getAdminNewsListR :: Handler RepJson; getAdminNewsListR = jsonToRepJson $ array [ ]  that gives me a type constraint: (ToJSON a0) arising from a use of `array'   but how do I do this for an empty list?
15:06:23 <Cale> mcstar: The fixed point of logical negation :)
15:06:44 <mcstar> i see that it is like a fixed point
15:06:56 <mcstar> it just doesnt strike me as paradoxical
15:07:28 <mcstar> was it paradoxical, because it cant be 'typed' in simply typed lambda calculus?
15:10:19 <pr> ok, suppose i would implement elem like this: elem a as = foldr (\x acc -> if x == a then True else acc) False as. i can do something like: elem 5 [1..], and it returns True. so how das that actually work? i think foldr f z [1..] looks something like: f 1 (f 2 (f 3 (f 4 (f 5 ... so let f = \x acc -> if x == a then True else False, how is this evaluated in the context of f 1 (f 2 (...
15:10:25 <pr> is it like:
15:11:13 <pr> "heres a function with two parameters, we need the first parameter x for the (if x == a) part, so lets evaluate that. hmm, 1 /= 5, so lets evaluate the then part. oh, there's an acc, so lets now evaluate acc. acc = (f 2 (... and so on?
15:11:25 <mcstar> Not = \b -> b True False; i see, so if 'b', was a proposition, that gives its truth value, by calling it on False True, now it will give its negation, since you call it on True False, the opposite order in which you defined the arguments of True/False
15:11:57 <mcstar> so, everything in this propositional calculus is a 2 argument function
15:12:07 <pr> it's kind of difficult for me to wrap my head around the fact that foldr works on infinite lists, so i guess i want to know if my reasoning/intuition is right
15:12:37 <pr> (thinking of folds in terms of replacing the : in lists with some binary op doesn't really make it any easier, feels kinda like an incomplete description)
15:13:23 <maukd> ok, how about *lazily* replacing the : in lists?
15:13:41 <geekosaur> it's a complete description, actually.  one issue you seem to be having is laziness, yeh; "evaluation" does not go all the way immediately
15:14:23 <maukd> @src foldr
15:14:23 <lambdabot> foldr f z []     = z
15:14:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:14:51 <Cale> mcstar: The paradoxical thing is that that isn't even the negation we're talking about :)
15:15:10 <Cale> mcstar: But maybe we could take it to be that too
15:15:17 <Cale> hmm...
15:15:19 <maukd> foldr (\x acc -> if x == 5 then True else acc) False [1 ..]
15:15:27 <mcstar> Cale: i think i understand your negation
15:15:29 <pr> right, it's about laziness i guess, but what if we think about foldr in in terms of function application, like i mentioned earlier
15:15:41 <Cale> mcstar: In Church's original paper, which I linked, he didn't just set up the lambda calculus as we know it today.
15:15:48 <maukd> (\x acc -> if x == 5 then True else acc) 1 (foldr (...) False [2 ..])
15:15:55 <pr> it lazily evaluates the function (the if then else) every time, that's why it works, isn't it?
15:16:06 <Cale> mcstar: He added a bunch of logical operations to it, in addition to the usual variables, lambdas and application
15:16:06 <mcstar> Cale: i saw, he had a substitution operator
15:16:07 <maukd> if 1 == 5 then True else foldr (...) False [2 ..]
15:16:14 <pr> it has to, otherwise acc would blow up in your face
15:16:25 <Cale> mcstar: Including a logical negation operator.
15:16:34 <maukd> foldr (\x acc -> if x == 5 then True else acc) False [2 ..]
15:16:37 <pr> maukd: aah ok
15:17:28 <Cale> (with axiomatic properties)
15:17:36 <geekosaur> > foldr (\x acc -> if x == 5 then True else acc) False [1 ..] :: [Expr] -- does this work?
15:17:37 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
15:17:37 <lambdabot>         against inferre...
15:17:39 <geekosaur> nope
15:17:40 <pr> yeah, i totally forgot to just apply the definition of foldr a couple of times
15:17:47 <pr> now it's crystal clear. thanks :)
15:17:48 <mcstar> Cale: The simply typed lambda calculus was originally introduced by Alonzo Church in 1940 as an attempt to avoid paradoxical uses of the untyped lambda calculus,
15:17:50 <Cale> (lol, 37 axioms!)
15:18:06 <Cale> Right, we're talking about the original untyped one :)
15:18:21 <Cale> How it was intended to be used as a logic
15:18:28 <mcstar> Cale: thats why i asked, if that above Y combinator didnt typecheck in simply typed lambda calculus, thereby eliminating the 'paradox'
15:18:30 <Cale> (when there are no types)
15:18:36 <Cale> oh, right
15:18:47 <Cale> yes, the simply typed lambda calculus has no fixpoint operator
15:19:45 <dmwit> (unless you add one primitively, at which point you're back to being an unsound logic)
15:19:56 <mcstar> dmwit: hey!
15:20:03 <dmwit> mcstar: ho!
15:20:21 <MostAwesomeDude> Thundercats!
15:20:29 <MostAwesomeDude> No wait, I've got it backwards.
15:29:44 <pr> > foldl f z [a,b,c,d,e]
15:29:45 <lambdabot>   f (f (f (f (f z a) b) c) d) e
15:32:35 <yyyymmdd> hi. i wanna module's path (not getCurrentDirectory). is there the function in haskell?
15:32:49 <hpc> no
15:33:06 <hpc> it breaks referential transparency
15:33:24 <dmwit> I'm not even sure I understand the question yet.
15:33:42 <dmwit> What is a module's path?
15:33:46 <yyyymmdd> hpc : thanks.
15:33:50 <ocharles> yyyymmdd: is this for paths to shared files?
15:33:55 <ocharles> because cabal can generate those paths
15:34:25 <yyyymmdd> i wanna GetMoudlePathName in win32
15:35:25 <dmwit> If that's a Windows native system call, and you don't see it in the Win32 package, it probably doesn't exist.
15:35:28 <dmwit> ?hackage Win32
15:35:28 <lambdabot> http://hackage.haskell.org/package/Win32
15:36:36 <hpc> hoogle and hayoo say it doesn't exist
15:36:43 <hpc> so it probably doesn't
15:36:51 <dmwit> I'm not convinced Hoogle indexes Win32.
15:37:04 <hpc> hoogle doesn't index a lot of things, but hayoo is complete
15:37:05 <yyyymmdd> my mistake. not GetMoudlePathName, GetModuleFileName.
15:37:07 <yyyymmdd> dmwit : thanks a lot
15:37:54 <dmwit> Win32 has System.Win32.DLL.getModuleFileName
15:50:09 <yyyymmdd> hm..
15:50:24 <yyyymmdd>           moduleName <- getModuleFileName nullPtr
15:51:12 <yyyymmdd> not in Scope : 'nullPtr'
15:51:16 <yyyymmdd> what's wrong?
15:52:14 <shachaf> nullPtr isn't in scope, I assume.
15:54:03 <yyyymmdd> shachaf : i know that  . i don't know what is right for nullPtr.
15:54:13 <shachaf> @hoogle nullPtr
15:54:13 <lambdabot> Foreign.Ptr nullPtr :: Ptr a
15:54:25 <shachaf> @google haskell nullptr
15:54:26 <lambdabot> http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Foreign-Ptr.html
15:54:26 <lambdabot> Title: Foreign.Ptr
15:55:18 <yyyymmdd> shachaf : thanks a ton :-)
15:56:38 <arch_is_awesome> Hello, i was wondering if it was possible to create a Haskell type (Such as an Integer that can only go from 0 to 9)
15:56:48 <arch_is_awesome> To clarify my question: Not a type class
15:57:05 <sipa> data Int10 = I0
15:57:34 <sipa> data Int10 = Int0 | Int1 | Int2 | Int3 | Int4 | Int5 | Int6 | Int7 | Int8 | Int9
15:57:40 <shachaf> arch_is_awesome: Sort of in various workarounds, but not really.
15:57:56 <arch_is_awesome> Oh, I see.
15:58:00 <arch_is_awesome> Thanks anyways.
15:58:06 <dibblego> http://hackage.haskell.org/packages/archive/Digit/0.0.3/doc/html/Data-Digit.html
15:58:14 <sipa> what you probably want however, is a newtype wrapped Int, with smart constructors that prevent assigning outside the given range
15:59:02 <arch_is_awesome> Ah, thanks
15:59:53 <arch_is_awesome> Also, do you have any idea how much memory an Integer takes?
16:00:03 <arch_is_awesome> Er... Int not Integer
16:01:26 <geekosaur> lazy or strict?  32 or 64 bit?
16:01:33 <arch_is_awesome> lazy 64
16:02:17 <arch_is_awesome> ...bit
16:02:29 <Dodek> could anyone quickly explain the point of newtype to me?
16:02:29 <shachaf> geekosaur: What's a strict Int?
16:02:40 <shachaf> Unless you mean an unpacked field inside a bigger thing, that is.
16:03:36 <sipa> Dodek: for example when you want to use the same representation as some other type, but assign new properties to it (new class instances)
16:03:38 <EvanR> Dodek: its data lite
16:03:53 <geekosaur> I do, among other things (I'm thinking of avoiding allocations but strictness is not the best proxy for that)
16:04:22 <shachaf> Most people give purely operational explanations for why newtype exists. :-(
16:04:38 <arch_is_awesome> It seems to be explained here: http://www.haskell.org/haskellwiki/Newtype#The_short_version
16:05:12 <Dodek> sipa: why not just use data, then?
16:05:16 <EvanR> newtype is the same as data with one constructor with one parameter except for bottom behavior
16:05:24 <EvanR> right
16:05:40 <arch_is_awesome> geekosaur: In C/C++ it seems to be 4.
16:06:06 <shachaf> C/C++ isn't a language. :-(
16:06:13 <arch_is_awesome> C or C++
16:06:15 <shachaf> And the size of its "int" isn't specified.
16:06:16 <t7> in set theory, how are pairs forced to only have 2 elements?
16:06:17 <geekosaur> arch_is_awesome, how much space is used generally has more to do with whether your algorithm can be done efficiently without extra allocations.
16:06:35 <sipa> Dodek: less overhead is the reason in practice, but there is some semantic difference as well
16:06:46 <arch_is_awesome> geekosaur: Oh, I see. So it changes.
16:06:54 <Eduard_Munteanu> t7: um, by definition? I don't really understand your question.
16:07:03 <Dodek> sipa: what semantic difference?
16:07:09 <shachaf> @google newtype vs data
16:07:10 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
16:07:10 <lambdabot> Title: Newtype - HaskellWiki
16:07:33 <sipa> Dodek: data Bla = Foo Int vs newtype Bla = Foo Int
16:07:39 <geekosaur> for a bog-standard Int value, figure 1 platform-word-size for the value plus 1 for the constructor tag (which is present even if you can;t see it) plus one more because of the way normal lazy values are represented
16:07:54 <sipa> Dodek: the newtype one can't be undefined (though it can be Foo undefined)
16:08:05 <sipa> eh wait
16:08:34 <jnhnum1> how can I use the FFI to call functions which are just in an object file?  (I'm trying to, just for fun, see if I can call mix assembly and haskell)
16:09:00 <sipa> jnhnum1: if they behave like C functions, you can
16:09:01 <geekosaur> so on average an Int on a 64bit platform should cost you 3*8=24 bytes.  some of this you may not care about as it may behave as part of something else; it depends on what you're doing
16:09:09 <Dodek> ah i see it
16:09:28 <geekosaur> jnhnum1, FFI /per se/ cannot; see the plugins package
16:09:31 <arch_is_awesome> geekosaur: Thanks
16:09:31 <jnhnum1> sipa: my problem is that I call ghc main.hs asm_fun.o, and then ghc complains that my function is not in scope
16:09:55 <geekosaur> oh, statically linked in.  yes, that's FFI
16:10:11 <geekosaur> you need to use foreign import to tell Haskell about the function in the object file
16:10:45 <jnhnum1> here I will put some stuff in hpaste to show you what I'm doing
16:11:05 <sipa> Dodek: representationally, values of a newtype-wrapped Int are at runtime just an Int
16:11:18 <sipa> Dodek: while data wrapped ones have a tag
16:11:24 <shachaf> sipa: data Blah = Foo !Int is also different from newtype.
16:12:26 <sipa> shachaf: that's still tagged, no?
16:12:56 <arch_is_awesome> Has anyone ever successfully written a package manager in Haskell for non-haskell things such as dolphin (besides Cabal)
16:13:29 <Eduard_Munteanu> What's Nix written in?
16:13:37 <Dodek> sipa: ah ok, makes sense. thanks!
16:13:38 <shachaf> C++, isn't it?
16:13:51 <geekosaur> http://en.wikipedia.org/wiki/Nix_package_manager
16:13:57 <shachaf> sipa: Are you still talking about denotational semantics? :-)
16:13:58 <geekosaur> hm, is it?
16:14:21 <jnhnum1> so I have asm.S: http://hpaste.org/74930 and add.h: http://hpaste.org/74931 and ffi.hs: http://hpaste.org/74932 - I don't know how to compile these together
16:14:25 <Eduard_Munteanu> Ah, so it's some non-Haskell, but functional DSL
16:14:51 <shachaf> http://hydra.nixos.org/build/2860022/contents/4
16:15:09 <jnhnum1> oh sorry
16:15:10 <jnhnum1> maybe I was being dumb
16:15:16 <jnhnum1> I think I need to use c_add, and not add2
16:15:41 <jnhnum1> yeah that was it sorry
16:16:06 <jnhnum1> still it's really cool that I can mix haskell, which is super high level, with assembly, which is really low level
16:16:40 * Eduard_Munteanu thinks about inline asm in Haskell
16:16:42 <shachaf> Twist: GHC turns Haskell *into* assembly!
16:16:50 <ocharles> -S
16:16:53 <ocharles> or -s
16:16:56 <ocharles> i forget which :)
16:17:04 <jnhnum1> that reminds me
16:17:12 <jnhnum1> does anybody know a good resource for learning core?
16:17:29 <shachaf> jnhnum1: Reading the STG paper would probably help, if you haven't. :-)
16:17:36 <Eduard_Munteanu> You're all for the asm-y stuff, aren't you? :)
16:17:38 <shachaf> It's not really Core but it has some similarities.
16:18:34 <Eduard_Munteanu> In any case, it might be a better idea to have a look at primops first.
16:18:46 <Eduard_Munteanu> GHC.Prim, that is.
16:19:01 <jnhnum1> oh I wasn't thinking about writing core directly
16:19:10 <jnhnum1> I just kind of wanted to see what ghc compiles down to
16:19:17 <jnhnum1> before assembly
16:19:25 <Eduard_Munteanu> Oh, then the STG paper is a good starting point.
16:19:26 <jnhnum1> it's like "how ghc thinks"
16:19:33 <Eduard_Munteanu> @where sth
16:19:33 <lambdabot> I know nothing about sth.
16:19:34 <Eduard_Munteanu> @where stg
16:19:34 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
16:20:19 <jnhnum1> thanks :)
16:24:29 <shachaf> I don't think GHC even has a parser for Core, does it?
16:25:59 <t7> @hoogle intersperse
16:25:59 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
16:25:59 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
16:25:59 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
16:28:27 <hpaste> Rung pasted “Can you make this generic?” at http://hpaste.org/74933
16:35:02 <hpaste> CoverSlide annotated “Can you make this generic?” with “Can you make this generic? (annotation)” at http://hpaste.org/74933#a74934
16:39:43 <Mortchek> CoverSlide, why not leave off the type annotation and ask ghci what type it thinks it is?
16:42:39 <CoverSlide> yeah it fails with the type annotation
16:42:59 <Mortchek> Oh woops, I just realized you are not the original asker
16:43:49 <mapf> @help
16:43:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:43:54 <Mortchek> :t \xs -> sum xs / fromIntegral (length xs)
16:43:55 <lambdabot> forall a. (Fractional a) => [a] -> a
16:45:57 <mapf> :t print
16:45:58 <lambdabot> forall a. (Show a) => a -> IO ()
16:46:19 <mapf> > Nothing
16:46:20 <lambdabot>   Nothing
16:46:31 <mapf> :i IO
16:46:53 <Eduard_Munteanu> @index IO
16:46:53 <lambdabot> System.IO, Prelude
16:47:36 <mapf> @index ReaderT
16:47:37 <lambdabot> Control.Monad.Reader, Control.Monad.RWS, Control.Monad.Reader, Control.Monad.RWS
16:49:29 <mapf> @index (.)
16:49:29 <lambdabot> Prelude
16:49:44 <mapf> @index clCreateKernel
16:49:45 <lambdabot> bzzt
16:50:04 <mapf> ha!
16:51:24 <mapf> @pl \x -> map succ x
16:51:24 <lambdabot> map succ
16:51:41 <mapf> @unpl (map succ)
16:51:41 <lambdabot> (map succ)
16:53:01 <mapf> > let a = a in a
16:53:05 <lambdabot>   mueval-core: Time limit exceeded
16:53:42 <Mortchek> > take 10 a where a = 0:b; b = 1:a
16:53:43 <lambdabot>   <no location info>: parse error on input `where'
16:53:47 <mapf> > mapM_ print [1..4]
16:53:48 <lambdabot>   <IO ()>
16:53:57 <Mortchek> > let a = 0:b; b = 1:a in take 10 a
16:53:58 <lambdabot>   [0,1,0,1,0,1,0,1,0,1]
16:54:08 <mapf> > [1..100]
16:54:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:55:12 <mapf> @index (>>>)
16:55:12 <lambdabot> Control.Arrow
16:55:36 <Eduard_Munteanu> lambdabot also answers private messages, btw.
16:55:51 <mapf> How?
16:56:05 <parcs`> /query lambdabot
16:56:58 <Eduard_Munteanu> (mind :t doesn't work there, you need to use @type)
17:00:50 <canta> In real world haskell, in the chapter about parallelism, force is used, but I am unable to find out in what module that might rest.
17:02:16 <shachaf> force :: forall a. NFData a => a -> a -- Defined in `Control.DeepSeq'
17:02:18 <mapf> Control.Parallel.Strategies maybe?
17:02:30 <shachaf> I don't know if that's the one, but it's a one.
17:02:52 <tel> Does anyone know a general name for [Either a a] -> Either [a] [a] which acts like sequence if all the input values are Right but it "finishes early" if any of them are Left?
17:03:20 <shachaf> tel: "finishes early" with what?
17:03:35 <shachaf> If it was [Either e a] -> Either a [a], that'd just be sequence.
17:03:53 <tel> shachaf: like this [Right 1, Left 2, Right 3] -> Left [1, 2]
17:04:02 <shachaf> Oh.
17:04:08 <cmccann> :t partitionEithers
17:04:09 <lambdabot> forall a b. [Either a b] -> ([a], [b])
17:04:13 <shachaf> That seems sort of specialized -- I doubt it's in the standard library.
17:04:20 <shachaf> cmccann: That won't help with what tel wants.
17:04:28 <cmccann> why not?
17:04:51 <canta> the deepseq force does not seem to work with the example code, will try to find some hint in earlier chapter
17:04:54 <shachaf> cmccann: How would it?
17:05:21 <cmccann> just check to see if the left half is []
17:05:39 <cmccann> oh, wait, apparently I misread
17:05:42 <cmccann> yeah, nevermind
17:05:50 <mapf> canta, it's because api changes possible
17:06:12 <tel> cmccann: More fully, the whole type needs to be like [IO (Either a a)] -> IO (Either [a] [a])
17:06:27 <tel> i.e. try some actions until one fails, collect all the results up until that failure
17:06:32 <shachaf> @let isRight (Right _) = True; isRight (Left _) = False
17:06:33 <lambdabot>  Defined.
17:07:17 <shachaf> > let foo xs = let (a,b) = span isRight xs in map (either id id) (a ++ take 1 b) in foo [Right 1, Left 2, Right 3]
17:07:19 <lambdabot>   [1,2]
17:07:28 <cmccann> yeah, I agree that it sounds too specialized to be in the standard libraries, but it's obviously easy to implement
17:08:09 <canta> mapf: ah, okay the book is from 2008, that could be it then
17:08:19 <shachaf> > let foo (span isRight -> (yes,take 1 -> no)) = map (either id id) (yes ++ no) in foo [Right 1, Left 2, Right 3]
17:08:21 <lambdabot>   [1,2]
17:08:30 <tel> cmccann: yeah, it's not too hard. I've got an implementation; I was just hoping to cut down on custom control structures
17:09:41 <cmccann> I doubt there's any way to do it with standard pieces that wouldn't be at least as much code (and more opaque) than what you have already, then
17:09:43 <Eduard_Munteanu> Maybe you want something like EitherT over WriterT over ... ? That is, a computation which can fail, and which logs stuff as it goes.
17:10:18 <cmccann> throwing WriterT in there being such an example ;]
17:11:07 <tel> Eduard: oh! yeah— that's about right
17:11:25 <tel> hah, we'll see if it's any more clear than what I have now
17:11:32 <mapf> canta: can your give a link to exsample? I have read that chapter recently but I could not remember code broken.
17:13:50 <canta> http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html about in the middle of the page, a search for "force lesser" should get you right to it.
17:14:48 <shachaf> canta: force is defined on that page.
17:15:02 <mapf> yeah
17:15:33 <canta> oh :/ sorry
17:15:59 <mapf> http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html#Sorting.hs:force
17:16:38 <mapf> actually I have been confused too and search about half of hour about force )
17:17:07 <monochrom> "search for the force, luke"?
17:18:51 <canta> so not really try as you read along code, when something is 2 pages further down that the current example uses :)
17:26:48 <davorb> can someone tell me why i'm getting "parse error on input =" with this code? http://pastebin.com/Ab0ZVDNQ
17:26:50 <maukd> The paste Ab0ZVDNQ has been copied to http://hpaste.org/74936
17:26:53 <davorb> should be fairly easy
17:27:26 <cmccann> looks like your indentation has gone weird somehow
17:27:38 <davorb> nm found it
17:27:43 <cmccann> try not mixing tabs and spaces
17:27:51 <cmccann> that only ends in tears
17:28:04 <davorb> yeah, that was it cmccann. i saw it now that i pasted it in. i deleted my old sublime-settings, so that's why it started inserting those
17:28:33 <shachaf> Hah, nubBy ((/=) `on` isRight) ... will take either all the Lefts or all the Rights from a list, depending on what comes first.
17:28:36 <davorb> yeah, i usually always use spaces. tabs are annoying if you're working on multiple platforms
17:29:28 <cmccann> tabs are fine if you use them correctly, are using an editor that isn't stupid, and only care about block indent level
17:30:12 <cmccann> but the off-side rule in Haskell explicitly cares about column position, not simply depth of leading whitespace
17:30:28 <cmccann> so tabs are just a horrible idea all around in Haskell code
17:33:30 <cmccann> basically the off-side rule isn't really about whitespace so much as it's about making ASCII art with your code
17:36:05 <hiptobecubic> "A entails B iff A can only be true when B is true." Right?
17:37:18 <Cale> uhhh
17:37:31 <hiptobecubic> Cale, right.
17:37:44 <Cale> A entails B if there is a sequence of logical rules which constructs B starting from A.
17:38:03 <cmccann> are we talking about entailment or material implication here?
17:38:04 <hiptobecubic> that's a much better definition
17:38:08 <hiptobecubic> entailment
17:38:24 <cmccann> because your first definition sounded more like the latter. :P
17:38:31 <Cale> There is usually a theorem which says that the empty context entails A implies B if and only if A entails B
17:38:45 <shachaf> A entails B if B is a donkey and A is playing Pin the Tail on the Donkey.
17:39:02 <Cale> And "A implies B" is usually equivalent to "B or not A"
17:39:24 <hiptobecubic> but if A implies B is a tautology, then A entails B, right?
17:39:39 <Cale> right
17:40:26 <Cale> usually
17:40:32 <Cale> unless your logic sucks
17:40:34 <hiptobecubic> So then either A is false or A and B are both true.
17:40:41 * cmccann doesn't think that's allowed in all logical systems
17:41:09 <cmccann> just the usual ones that behave the way you'd expect logic to behave. :P
17:41:33 <mebaran151> is there a good full text search library for haskell: thinking of playing with Yesod for a webapp I'm starting but will need a search engine built in
17:41:48 <mebaran151> something like Lucene etc, though given the external database, I can't use sphinx
17:42:07 <monochrom> I'm pretty sure what "entail" means is determined by what the author of what you're reading wants it to mean
17:42:22 <shachaf> monochrom: What if I'm reading #haskell?
17:43:09 <monochrom> then you ask the weekly @official command :)
17:43:33 <monochrom> anyway, different authors have subtle variations
17:43:56 <noobster> hi
17:46:59 <lightquake> doing a little digging, it seems like people keep reimplementing the idea of an API for querying information about a haskell program
17:47:00 <cmccann> monochrom, well there's glory for you!
17:50:36 <Cale> lightquake: examples?
17:50:45 <lightquake> there's scion, ghc-mod, buildwrapper
17:51:13 <Cale> Maybe the reason is the same as the reason why I have not heard of any of those things :)
17:51:22 <lightquake> which is?
17:51:40 <Cale> That I don't know :)
17:51:51 <lightquake> ha
17:52:50 <lightquake> my new silly yak-shaving idea is to have a daemon that just wraps buildwrapperd, and then a simple frontend command-line utility
17:52:52 <benmachine> in Haskell it's easier to write a program than to do any research :P
17:53:30 <Darkflux> Possibly just more fun
17:53:49 <shachaf> lightquake: Why "daemon" rather than "program that reads stdin and writes to stdout"?
17:54:06 <lightquake> no particular reason
17:54:11 <shachaf> Like ghci. Which I think is used in that way by some editors.
17:54:22 <lightquake> yeah, I know haskell-mode does that
17:54:22 <shachaf> Doesn't agda-mode do something like that with agda, too?
17:54:37 <lightquake> when you want to look at the type of something it just sends ":t thing" to ghci
17:54:41 <shachaf> agda-mode is probably the thing to take inspiration from, not haskell-mode.
17:54:53 <lightquake> i've never used agda-mode
17:55:23 <shachaf> lightquake: agda-mode is "a pretty cool guy", as they say.
17:55:25 <shachaf> Have you used Agda?
17:55:55 <marcot> Hi.  I have (f :: Maybe Int) and (g :: Int -> IO (Maybe String)).  Is there a way to sequence then cleanly, and get something like (g ??? f :: IO (Maybe String))?
17:55:59 <marcot> them
17:56:08 <lightquake> no, I haven't
17:56:38 <startling> marcot: MaybeT might be useful
17:56:44 <shachaf> startling: Probably overkill.
17:56:45 <lightquake> i don't think you need MaybeT for this
17:56:53 <shachaf> MaybeT is always overkill, even in cases where it's valid.
17:56:54 <mapf> @type maybe
17:56:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:57:05 <startling> marcot: but IO (Maybe String) is different from Maybe (IO String)
17:57:11 <marcot> startling: I thought about it, but it seemed that I would need to change the type of the functions.
17:57:16 <parcs`> marcot: fmap join (dist (fmap g f))
17:57:28 <startling> marcot: yeah, MaybeT is probably too much
17:57:40 <shachaf> fromMaybe (return Nothing) (g <$> f)
17:58:01 <lightquake> i wish you could djinn this
17:58:20 <liyang> join <$> traverse g f
17:58:40 <shachaf> Hah, liyang++
17:58:51 <shachaf> I'm not sure it makes it clearer, though.
17:59:25 <lightquake> @type fromMaybe (return Nothing)
17:59:26 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe (m (Maybe a)) -> m (Maybe a)
17:59:41 <sipa> :t fromMaybe
17:59:42 <lambdabot> forall a. a -> Maybe a -> a
17:59:45 <shachaf> lightquake: fromMaybe is like fromJust with a default.
17:59:51 <lightquake> ah
18:00:24 <lightquake> i'd use the fromMaybe solution
18:01:00 <liyang> "maybe x id" is shorter than "fromMaybe x"
18:01:13 <shachaf> lightquake: Not in tokens!
18:01:17 <marcot> Thanks for the numerous solutions.  I'm quite impressed about how fast you are with these things.
18:01:20 <shachaf> s/ghtquake/yang/
18:02:36 <marcot> parcs`: Where is dist from?
18:02:47 <liyang> I think "join <$> for f g" is perfectly clear, if you consider the more general case where g :: Maybe Int and f :: Int -> IO something
18:03:37 <zzing> Is there any way of getting some arbitrary time in a UTCTime datatype? I need to get a time to compare something against. I am not seeing how to construct an arbitrary one.
18:04:16 <liyang> "for f g" would be "IO (Maybe something)" ; except that "something" here is "Maybe String", so an fmapped join sorts that out.
18:04:21 <shachaf> "arbitrary" meaning that you choose it or I choose it?
18:06:14 <zzing> shachaf, something like that.   I basically am doing something like this:     newscount <- runDB $ count [ NewsItemDate !=. "" ]    where "" will be a time now.  It needs a field to know what table, but I need to filter it so I filter it against something it can't be
18:10:05 <amosr> oy vey. can't you add a type annotation or something instead?
18:10:42 <jasonkuhrt> I'm not sure if the community already knows but if people want a haskell-ish experience in the browser  this might be worth considering... http://gkz.github.com/LiveScript
18:12:01 <mapf> Has haskell-mode some command which "align" code? For exsample, some advanced replacement for basic emacs "align-regexp" comman with parameter "="
18:12:15 <liyang> We used CoffeeScript. Decided in-browser programming wasn't fun or worth the trouble in the end and are switching to a GTK app instead.
18:12:40 <shachaf> lightquake: GTK isn't fun either. :-(
18:13:06 <zzing> How is coffeescript?
18:13:10 <zzing> I use javascript right now :P
18:13:14 <jasonkuhrt> liyang: coffee-script doesn't do much if your coming from haskell IMO, it seems more targeted to folks work in python/ruby,
18:13:27 <jasonkuhrt> zzing: it's ok, but there's a lot of other interesting options
18:13:43 <jasonkuhrt> zzing: what's nice about coffee is you can reasonable expect other devs to know it or pick it up
18:13:48 <zzing> I am likely to be adopting Dojo soon
18:13:50 <mapf> so I could select a function and align all "=" in it
18:13:54 <liyang> shachaf: Not terribly. But less hassle than dealing with CoffeeScript and a Haskell server.
18:13:58 <jasonkuhrt> whereas other projects like roy or livescript... less so
18:14:07 <jasonkuhrt> but those seem a lot nicer for haskellers
18:14:29 <jasonkuhrt> even contracts coffee is better for haskellers
18:14:37 <jasonkuhrt> http://disnetdev.com/contracts.coffee/
18:14:42 <jasonkuhrt> haskell-like type safety
18:14:49 <zzing> hmm, looks like livescript goes with jquery, which I am moving away from
18:15:10 <jasonkuhrt> zzing: doesn't have to? that's just a blog post
18:15:12 <jasonkuhrt> demo whatever
18:15:20 <liyang> I guess if you must do browser-side programming, Coffee/LiveScript is much better than plain JS.
18:15:27 <zzing> Its in some examples that it shows that
18:15:41 <jasonkuhrt> zzing: just becasue its popular i guess
18:15:47 <jasonkuhrt> zzing: but not a requirement
18:15:51 <zzing> fair enough
18:15:59 <lightquake> shachaf: ?
18:16:10 <shachaf> lightquake: ?
18:16:12 <shachaf> lightquake: Oh.
18:16:17 <shachaf> s/ghtquake/yang/
18:16:24 <zzing> I have to do my server side 'ajax' api and then write my javascript stuff, then I can populate my database from the browser and write the UI later
18:16:40 <shachaf> lightquake: Can you seriously expect me to type *three characters* before pressing tab?
18:20:54 <xXx_lIgHtQuAkE42> ugh, nick length limits
18:21:05 <xXxlIgHtQuAkExXx> shachaf: happy?
18:21:18 <shachaf> xXxlIgHtQuAkExXx: Better.
18:22:23 * benmachine wonders if there are any initial characters still unallocated
18:22:37 <shachaf> benmachine: Yes.
18:22:40 <]benmachine> wooo
18:22:46 <shachaf> Well, not anymore.
18:23:13 <shachaf> }lightquake: IRC specifies that ] = } in case-insensitive comparison.
18:23:25 <shachaf> Due to its "Scandinavian origin".
18:23:29 <lightquake> oh, right
18:23:31 <benmachine> hah, weird
18:23:43 <cmccann> I bet it doesn't allow any fun unicode :[
18:23:50 <benmachine> there are only two u's
18:23:57 <shachaf> cmccann: abcdefghijklmnopqrstuvwxyz[]\ are all fun Unicode!
18:24:41 <shachaf> Not to mention `
18:24:42 <cmccann> but they're just not as fun as ☃.
18:24:57 <shachaf> ꙮ
18:25:16 <benmachine> λ
18:25:19 <Nereid> ☂
18:25:36 <shachaf> > let ꙮ = 5 in ꙮ
18:25:37 <lambdabot>   5
18:25:37 * cmccann debates digging up his "convert text to unicode fraktur letters" program
18:25:48 <shachaf> @where zalgo
18:25:48 <lambdabot> import Random;main=mapM_((>>(י=<<randomRIO('̀','ͯ'))).י)=<<getContents;י=putChar
18:26:07 <Nereid> shachaf: hahaha
18:27:50 <liyang> U̺̭̹̯̝͙̺̱̳̼͙̼͗̈́̆ͬ͗̆̓ͮ͌͆̏ͧ̈͆ͭͥ̅̓̀n̷̵̨̛̲̤̠̼̤̜̯̞̜̣̙̫̮͆͗ͯ̅ͯ̔̑ͨ͋͠ḯ̢̹̪̯͈̖̱̤̲̫̗̝̤̺̗ͩ͊ͩ͊͗̓̒̔̄̋ͫͩ͑̀ͅĉ̴̛̮̰̮̯̒͋ͩ͂ͩ́ͭö̸̬̤̙̝͙͓̱̖̰̞̙́ͮ̋͑̒͊͌͌̿ͬ̑ͩ͑͒̒͋͑͗́͠d̸̵̴̡͙̖̺̠̭̖̠̫͖̹̯̣̮̼̪̟ͬ͗ͫͯ̎͗̀̉ͫ̐̏̆͑ͨͪͭ̐̈́̚͘ͅͅḙ̡̣͓͇̤̗͓̤̀ͭ̆ͫͦ̿̋͛̀̊̑́̀͟͡ ͐́͐͂́̊̅͊ͮ̂̃̚
18:28:44 <benmachine> oh dear, you guys have confused my irssi with your unicode
18:29:22 <mapf> What @where do?
18:32:36 <startling> @where foldM
18:32:36 <lambdabot> I know nothing about foldm.
18:32:47 <shachaf> @src foldM
18:32:47 <lambdabot> foldM _ a []     = return a
18:32:48 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
18:32:54 <startling> @where liftM
18:32:54 <lambdabot> I know nothing about liftm.
18:32:57 <startling> huh.
18:33:44 <bobajett> LYAH says: "One big difference between the two types of folds is that right folds work on infinite lists, whereas left ones don't!" but I don't understand the difference, it doesn't explain it.
18:33:48 <geekosaur> @index liftM
18:33:49 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:33:59 <geekosaur>  @where is for web resources, mostly
18:34:10 <shachaf> bobajett: Try expanding foldr and foldl on an infinite list by hand.
18:34:38 <bobajett> shachaf: so like try expanding foldl (+) [1..] vs foldr (+) [1..] ?
18:34:53 <startling> geekosaur: oh! I thought it would tell me what module a thing comes from
18:35:01 <geekosaur> that's @index
18:35:02 <shachaf> bobajett: (+) is a bad example, because it's usually strict (so that won't terminate on infinite lists either way.).
18:35:05 <shachaf> s/\.//
18:35:31 <geekosaur> which uses a database generated by hoogle, I think?.  @where is more general, @where+ creates entries in its database
18:35:36 <bobajett> shachaf: yeah that's why I think Im getting confused, what other example should I try expanding with the two folds?
18:36:01 <shachaf> bobajett: (:) and [] is good.
18:36:04 <shachaf> Or any lazy function.
18:36:10 <shachaf> Even (const foo)
18:36:13 <bobajett> shachaf: ah ok. thanks, I'll try that.
18:36:51 <mapf> @src Maybe
18:36:51 <lambdabot> data Maybe a = Nothing | Just a
18:39:24 <dan`> quit
18:39:28 <dan`> exit
18:40:21 <shachaf> cmccann: Hah, I like `Meaning`
18:41:02 <cmccann> abusing backticks is fun.
18:41:11 <shachaf> Well, you could do it prefix too.
18:41:20 <shachaf> Meaning weight Int -> Meaning height Int -> Int
18:41:26 <cmccann> yes. but it would be less amusing.
18:41:32 <shachaf> I'm surprised no one there mentioned dependent types!
18:41:35 <shachaf> This is so simple in Agda.
18:41:44 <shachaf> foo : (height:Int) -> (weight:Int) -> Int
18:41:47 <cmccann> haha
18:53:07 <parcs`> even better (height weight : Int) -> Int
18:54:52 <parcs`> type a ? (b :: Symbol) = a; foo :: Int ? "height" -> Int ? "weight" -> Int
18:55:19 <shachaf> whoa, dude, GHC has type-level stringythings now.
18:55:30 <MostAwesomeDude> Really?
18:55:51 <parcs`> ya
18:56:09 <shachaf> I wonder whethr there's a clever way to get extra information using Haddock.
18:58:44 <parcs`> type level strings can be used in place empty data types used as phantom types. so instead of 'data Foo; data Bar a where Bar :: Bar Foo' you can do 'data Bar (a :: Symbol) where Bar :: Bar "Foo"'
18:58:55 <parcs`> which doesn't buy you anything but it makes your code prettier
18:59:30 <shachaf> Well, sort of prettier...
18:59:46 <shachaf> Closed sum kinds are much nicer when you can use that.
19:00:58 <carter> theres some cool stuff you can do with type level strings!
19:01:08 <carter> :)
19:01:15 <carter> plus the singleton stuff
19:01:21 <carter> I think
19:07:57 <zzing> type level strings?
19:07:59 <carter> yes
19:08:14 <carter> you can try to do a row type system / record lookup thing
19:08:16 <carter> using them
19:08:21 <carter> (still need to try it out)
19:08:22 <carter> :)
19:10:32 <carter> i think theres some code examples linked from r/haskell at some point
19:10:36 <carter> that should work with 7.6
19:14:15 * hackagebot dtd 0.6.1.1 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-0.6.1.1 (MichaelSnoyman)
19:14:17 * hackagebot http-conduit 1.6.0.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.6.0.4 (MichaelSnoyman)
19:14:19 * hackagebot uri-conduit 0.5.0.2 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-0.5.0.2 (MichaelSnoyman)
19:19:24 <eyu> > 1 + 1
19:19:25 <lambdabot>   2
19:19:56 <simon__w> Hi, I'm using handleSourceError to catch type errors and am wondering if there's some way to get some context with the errors? I'm hoping to get the location of the constraint(s) that the failed type didn't unify with. Alternatively, if there's a way to get the TcLclEnv for a given SrcSpan
19:31:35 <nu11ptr> I have a quick question on monads and the state monad in general
19:31:43 <nu11ptr> http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Introducing_State
19:32:13 <nu11ptr> first line of 'roll die' has a 'get' function call… how does the state get into the function in the first place. It isn't passed in.
19:33:57 <Ferdirand> it is when you call evalState
19:34:16 <geekosaur> nu11ptr, typically you use runState to evaluate State code; (or evalState or execState) --- initial state is specified in that call
19:35:00 <nu11ptr> Ibut how does the state get inside the roll die function call? The function takes no input that I see.
19:36:29 <Ferdirand> and yet it does
19:36:34 <nu11ptr> exactly :-)
19:36:51 <Ferdirand> rollDie is a GeneratorState Int
19:36:56 <nu11ptr> I've tested it - I don't doubt it works… trying to figure out if some monads are passed in with an invisible param?
19:37:01 <otters> no
19:37:09 <otters> the State monad is sugar for a bunch of functions that are composed
19:37:26 <otters> so anything that is type State foo bar baz is a computation into which a value is inserted
19:37:48 <nu11ptr> I understand that, but it has no binding at top level… how does get find the function to execute to get the state and value out?
19:38:03 <otters> Look at the source of get.
19:38:05 <Ferdirand> the magic is not in get
19:38:09 <Ferdirand> it's in the do notation
19:38:17 <nu11ptr> I did… it didn't help
19:38:21 <Ferdirand> and the definition of the monad
19:38:50 <Ferdirand> do you know how do notation is desugared to >>= ?
19:38:56 <nu11ptr> so 'do' notation in addition to doing 'bind' and 'then' also support cross-function visibility to some level?
19:39:00 <nu11ptr> yes
19:39:02 <Ferdirand> no no
19:39:07 <Ferdirand> all the magic is in the bind
19:39:54 <nu11ptr> but bind takes two params… trying to figure out where the very first left param comes from… :-)
19:40:32 <Ferdirand> bind just stitches two functions together to produce another
19:41:29 <Ferdirand> you always end up with a complex function that takes an initial state, and produces a result and a final state
19:41:30 <tikhonjelvis> I think it makes more sense to think of bind (m >>= f) as applying f to m.
19:41:49 <nu11ptr> so forget about monads for a second… in haskell as in most languages you can get something if either a) it is passed in or b) if it is a global binding…. in this case, the state monad in the example is neither
19:41:56 <tikhonjelvis> or are you talking about the State monad in particular?
19:41:57 <otters> no, it's passed in
19:41:58 <nu11ptr> in my own tests, it is neither..and yet it works
19:42:08 <otters> hmm..
19:42:11 <nu11ptr> otters: how? invisible param?
19:42:13 <otters> I'll make a snippet on hpaste
19:42:15 <Ferdirand> yes it is
19:42:18 <Ferdirand> it is passed in
19:42:19 <cmccann> something of type "State s a" is actually a function that takes a parameter of type s
19:42:20 <otters> You could call it invisible
19:43:12 <Ferdirand> look at the bind definition
19:43:29 <cmccann> there's nothing special going on, just a data type holding a value that happens to be a function
19:43:35 <Ferdirand> at the top you have a lambda that takes the initial state
19:43:35 <nu11ptr> otters: if invisible, how does it know which one to pass in?
19:44:03 <otters> it's whatever was passed to runState
19:44:20 <Ferdirand> passes it to the first part of the operation, gets back a value and an intermediate state
19:44:54 <Ferdirand> passes the value to the function to get "something" that consumes the intermediate state
19:45:08 <nu11ptr> Ferdinrand: followed your first part…lambda state the state… not following how it gets into the function w/o a top level binding
19:45:24 <cmccann> it's an argument to the function, just like any other
19:45:28 <Ferdirand> but that is the point of the lambda
19:45:38 <nu11ptr> cmccann: and yet…it is not :-)
19:45:51 <cmccann> yes, it is
19:45:56 <cmccann> there's nothing magic going on here
19:46:17 <nu11ptr> cmccann: which function? the one instate the state monad or 'rolldie ' in the example url?
19:46:27 <nu11ptr> err.. "in the"
19:46:29 <mm_freak_> nu11ptr: newtype State s a = State (s -> (a, s))
19:46:41 <mm_freak_> it's just a function with an additional parameter and result of type 's'
19:46:50 <mm_freak_> now look at the type of runState
19:46:59 <mm_freak_> runState :: State s a -> s -> (a, s)
19:47:09 <mm_freak_> that's where the initial "state" comes from
19:47:16 <nu11ptr> ok, so I call that function with the state, I get back a function that takes no params and returns (a, s)
19:47:28 <mm_freak_> there is no function that doesn't take arguments
19:47:38 <Cale> you just get a pair
19:47:39 <cmccann> a value of type (a, s) is not a function, it's just a value...
19:47:46 <nu11ptr> but how does "roll die" know to run the function in that particular state monad? and how does it find that particular state monad when it wasn't passed to the function
19:47:55 <mm_freak_> nu11ptr: read again, i just gave you the full (!) definition of State…  it's so simple that you could define it yourself
19:48:13 <nu11ptr> cmccann: sorry, I mean in the generic sense.. I think of all values as functions of zero args
19:48:24 <cmccann> well, that's a misleading way to look at it
19:48:31 <mm_freak_> nu11ptr: that definition of "function" will bite you in haskell
19:48:46 <mm_freak_> nu11ptr: every function is a value, but not every value is a function
19:48:56 <mm_freak_> if there is no "->" in the type, it's no function
19:49:16 <Ferdirand> roll die by itself doesn't know it, it is just a fuction waiting for a state to be applied to it
19:49:22 <nu11ptr> mm_freak: I understand the function inside the state monad takes a param. trying to figure out how "roll die" gets the state monad itself
19:49:36 <cmccann> what's the type of "roll die"?
19:49:40 <mm_freak_> nu11ptr: "the state monad" is a type, not a value
19:50:12 <mm_freak_> the type State StdGen might be your state monad
19:50:14 <nu11ptr> cmccann: http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Introducing_State
19:50:22 <nu11ptr> GenerateState Int
19:50:28 <nu11ptr> as return value
19:50:31 <nu11ptr> no params
19:50:54 <latro`a> it has params if you expand the type
19:50:57 <cmccann> right, so it's actually (StdGen -> (Int, StdGen))
19:51:14 <latro`a> GeneratorState Int = State StdGen ~= StdGen -> (Int,StdGen)
19:51:18 <Ferdirand> it is the other way around; "roll die" doesn't get the state from the outside, it is the binds implicit in the do block who stitch the functions together by passing the state from computation to computation
19:51:21 <nu11ptr> ahhh
19:51:22 <latro`a> where ~= is "they're the same up to the constructor"
19:51:30 <latro`a> err
19:51:31 <latro`a> sorry
19:51:34 <nu11ptr> now that would make sense to me :-)
19:51:34 <latro`a> = State StdGen Int
19:51:54 <nu11ptr> I guess I didn't dig into GenerateState enough
19:51:59 <bobajett> > stupid question: isn't foldr (:) [] [1..3]  in it first evaluation equal to:  (:) 1 [] = [1], and then in its second evaluation (:) 2 [1] = [2,1] ?
19:52:00 <lambdabot>   <no location info>: parse error on input `in'
19:52:03 <cmccann> and what (>>=) does is stitch together the inputs and outputs of other "GeneratorState foo" values so that each gets the output StdGen from the previous step
19:52:11 <mm_freak_> nu11ptr: if you really want to understand this, implement Reader monads yourself…  start with this definition:  newtype Reader e a = Reader (e -> a)
19:52:26 <mm_freak_> implementing those monads makes it click for most people
19:52:56 <nu11ptr> mm_freak: and I guess that is where I was going…. can 'State' be implemented myself w/o internal hacking of GHC
19:53:02 <latro`a> yes
19:53:03 <nu11ptr> answer seems to be: yes
19:53:04 <cmccann> yes, easily
19:53:17 <cmccann> it's what, a dozen lines of code?
19:53:28 <latro`a> there is a rather small subset of haskell that can't really be implemented without internal hackery
19:53:31 <nu11ptr> yep, just missed the part of how it got passed in
19:53:33 <latro`a> the IO monad is most of it
19:53:41 <Ferdirand> it is actually fully implemented in the link you gave
19:53:42 <mm_freak_> nu11ptr: that's where your misconception comes from…  State is not magic, it's a simple Haskell98 type and can be implemented in just a few lines
19:53:48 <mm_freak_> nu11ptr: but anyway, start with Reader
19:53:55 <mm_freak_> after understanding how Reader works you will also understand State
19:54:00 <Ferdirand> cessorGenerator x) st'
19:54:10 <mm_freak_> they are very similar in structure and implementation
19:54:16 <Ferdirand> oops
19:54:44 <nu11ptr> yep, the only thing here that had me goofed up, was what "appeared" to be a return type. I see my error - I forgot that type could be expanded and that it may very well expand into a function that took a param. It clicked now. thanks everyone!
19:55:09 <nu11ptr> mm_freak: Ok, I'll read into that one then
19:55:16 <mm_freak_> nu11ptr: yeah, you really just need the definition of runState
19:55:24 <mm_freak_> runState :: State s a -> s -> (a, s)
19:55:24 * edwardk waves hello.
19:55:31 <mm_freak_> runState (State f) s0 = f s0
19:55:32 <mm_freak_> done
19:55:57 <mm_freak_> in fact you would usually define it as a field of State:  newtype State s a = State { runState :: s -> (a, s) }
19:56:05 <mm_freak_> sei gegrüßt, edwardk =)
19:56:59 <edwardk> sitting here debating about incorporating something like zippo directly into lens.
19:57:22 <edwardk> i ported it earlier, and tweaked it to be able to walk left and right through a Traversal
19:58:08 <edwardk> the main issue i have is where to put it. if i export it from Control.Lens.Zipper it would be odd not to re-export it from Control.Lens
19:58:26 <edwardk> but if i do, it takes a lot of common names, which i'd deliberately avoided taking
19:58:40 <edwardk> (up, down, left, right, etc)
19:59:22 <pharaun> provide your own shortcut/interface to zippo?
20:02:33 <edwardk> pharaun: well, its a bit different api wise already, the trick is finding names that are obvious enough to folks who know zippers, without taking all the good names, or just accept that i'll tromple a few more names
20:03:36 <cmccann> pick names that involve horrible puns that everyone else would be too embarrassed to use
20:03:41 <cmccann> that's my favorite strategy
20:03:42 <pharaun> edwardk: aha i see, makes me think of the "there is 2 hard thing in cs...." :)
20:03:51 <edwardk> pharaun: heh
20:04:08 <edwardk> cmccann: excellent advice
20:04:31 <pharaun> edwardk: anything in particular wrong with providing the same zippo interface but just in its own module so if people want to drag it in they can?
20:04:42 <pharaun> then i guess that becomes a collection of library
20:04:45 <rwbarton> isn't that conor mcbride's strategy too
20:04:53 <rwbarton> watch out for him :)
20:05:39 <edwardk> pharaun: i may just export it as Control.Lens.Zipper and require you to explicitly import it, because unlike Control.Lens.Plated the combinators and types in there aren't useful unless you are working with zippers.
20:06:00 <edwardk> e.g. the stuff in Plated was actually really important to making the port of zippo
20:06:30 <edwardk> i'm trying to work out how to get saving and restoring of paths to work though.
20:06:45 <pharaun> ah i see :)
20:06:55 <edwardk> pharaun: i may change the api quite a bit more to be more consistent with the surrounding package though
20:07:24 <cmccann> rwbarton, yes, conor mcbride strikes me as an excellent role model for how to choose appropriate names
20:07:36 <cmccann> and I can't imagine why anybody would think otherwise
20:08:16 <edwardk> cmccann: speaking of which there should be an avant garde poetry reading of his code probably set to a saxophone here in boston in 2-3 weeks. dolio has promised to video tape it ;)
20:08:28 <cmccann> hahahahaha, awesome
20:08:28 <latro`a> ...
20:08:30 <pharaun> edwardk: in that case i suppose to make it familiar with zipper users could just document like x is equivalent to y or something
20:08:31 <latro`a> poetry reading of code
20:08:36 <latro`a> that is the nerdiest thing I have ever heard
20:09:17 <edwardk> latro`a, cmccann : i had a couple of slides of conor code embedded in my talk on bound and it apparently resonated with a guy who was in the audience who is into that scene ;)
20:09:33 <cmccann> hahaha
20:09:46 <dolio> Keep it on the DL.
20:09:55 <edwardk> oh?
20:10:06 <dolio> It should be a surprise, no?
20:10:11 <pharaun> hah
20:10:12 <edwardk> oh yeah
20:10:12 <dolio> For Conor.
20:10:14 <edwardk> shh
20:11:24 <cmccann> fortunately he probably has better things to do than look through IRC logs
20:11:45 <pharaun> quick, bury the logs
20:11:55 <edwardk> yeah, had this been #agda, he'd find out too easily
20:12:12 <carter> good thing no one's on both channels :)
20:12:29 <edwardk> yeah, those agda guys are freaks
20:12:58 <ddarius> edwardk: I know.  Emacs of all things!
20:13:17 <dolio> Hey, man. Not by choice.
20:13:32 <carter> i use cosmic radiation to fip the bits when i edit, tis how I code so slow :)
20:13:49 <carter> dolio you were at hackphi right?
20:14:02 <dolio> If anyone wants to write the 3 million lines of vimscript to do equivalent stuff, I fully support them.
20:14:04 * cmccann persists in being too lazy to learn how to use a proper editor.
20:14:04 <dolio> Yeah.
20:14:40 <edwardk> dolio: that reminds me i need to talk to that guy from boston haskell about banging out the vim support for trifecta grammars
20:14:47 <dolio> Yeah.
20:14:56 <dolio> See if he'll clone agda-mode, too.
20:15:17 <ddarius> The weirdo guy who likes vimscript?
20:15:25 <edwardk> ddarius: yep
20:15:35 <dolio> Shh. He's not weird.
20:15:40 <dolio> He's charming and handsome.
20:16:01 <carter> the one time i tried to file a bug report on a vim script package, the maintainer wasn't nice
20:16:21 <tikhonjelvis> I imagine maintaining vimscript would do that to you :)
20:16:38 <carter> whereas every time i file a bug or patch with stuff on hackage
20:16:40 <ddarius> Who files bug reports for vim script packages?  I just fix it and submit a patch.
20:16:42 <carter> its like "yay!"
20:17:25 <carter> ddarius: i had noooo idea how to even solve the issue, it was a funny interaction between the latex-suite and one of the parens packages
20:17:27 <shachaf> cmccann: You're saved the trouble by the fact that a proper editor has yet to be written, ever.
20:17:35 <cmccann> heh
20:17:44 <carter> i just use sublime text 2 by default :)
20:17:48 <tikhonjelvis> no love for Yi?
20:17:56 <Cale> Someone should make an editor that's scripted using unix dc, just to make vimscript look really good by comparison.
20:18:09 <ddarius> tikhonjelvis: It was interesting when dons was working on it.
20:18:23 <shachaf> tikhonjelvis: Why would I have love for Yi?
20:18:30 <cmccann> write an editor in haskell, use agda as the scripting language
20:18:32 <ddarius> Emacs Lisp isn't all that much better than vimscript.
20:18:37 <shachaf> There are far more important things about a piece of software than the language it's written in.
20:18:39 <tikhonjelvis> shachaf: I don't know. I couldn't even get it to build.
20:18:49 <tikhonjelvis> ddarius: Emacs Lisp is actually pretty good
20:18:54 <carter> they recently added lexical scoping!
20:18:55 <tikhonjelvis> I'd choose it over most other dynamically typed languages
20:19:05 <ddarius> carter: By default?
20:19:06 <carter> that puts it ahead of coffee script now I think
20:19:13 <carter> ddarius: that would break things :)
20:19:15 <ivanm> shachaf: so if there aren't any proper editors, which one comes closest for you?
20:19:19 * hackagebot yjftp-libs 0.0.1 - CUI FTP client like 'ftp', 'ncftp'  http://hackage.haskell.org/package/yjftp-libs-0.0.1 (YoshikuniJujo)
20:19:19 <ddarius> carter: Yeah, that's what I thought.
20:19:21 <ivanm> carter: heh
20:19:47 <startling> carter: did you hear that java is getting closures?
20:20:02 <carter> startling: unless it gets tail calls added to the jvm, who cares? :)
20:20:10 <dolio> Java's had closures.
20:20:11 <shachaf> ivanm: I use Vim because I'm used to it.
20:20:13 <startling> carter, c++ too iirc !
20:20:21 <dolio> They're called anonymous inner classes.
20:20:39 <mapreduce> It will gain a lambda expression syntax.
20:20:45 <Cale> I wish I'd kept my little library of dc tricks. I implemented various higher order functions to act on a stack in dc.
20:20:53 <mapreduce> f -> stuff with f
20:20:53 <dolio> Actually, maybe even regular inner classes can close over the environment.
20:20:54 <ddarius> dolio: The anonymous part is irrelevant.
20:20:54 <cmccann> distinguished from closures in other languages by being needlessly verbose, right?
20:21:07 <mapreduce> dolio: They can.
20:21:31 <ddarius> mapreduce: And multiple arguments?
20:22:06 <mapreduce> Multiple arguments to a lambda work, and so does the x -> y -> x + y form
20:22:16 <mapreduce> I've been playing with an alpha today.
20:22:19 <ddarius> mapreduce: I was asking about the syntax.
20:22:26 <ddarius> It would be insane if the latter didn't work.
20:22:44 <mapreduce> Then I don't know what the question is.  I might benefit from a verb or two.
20:22:48 <cmccann> and java would never make insane language decisions
20:23:02 <ddarius> mapreduce: What does the syntax look like for a multiple argument lambda?
20:23:15 <mapreduce> fairly sure x, y -> x + y
20:23:25 <ddarius> And with types?
20:23:41 <cmccann> does it have lambdas with "zero" arguments?
20:23:49 <mapreduce> They are inferred only.
20:23:58 <mapreduce> () -> for lambdas with zero arguments
20:23:59 <ddarius> Damn cmccann for being right.
20:24:09 <cmccann> heh.
20:24:37 <ddarius> Wtf Java.  All you have to do is exactly what C# did a few years ago.
20:24:46 <shachaf> What did C# do?
20:25:03 <dibblego> C# 5.0 changed with respect to its closures over variables
20:25:11 <mapreduce> A lambda is converted to an instance of an interface inferred by the context.  You can add a cast if you want.
20:25:11 <cmccann> well, it's hard to keep up. I mean, Java was originally a cheap knock-off of C#, right? that's the only way it would possibly make sense.
20:25:18 <mapreduce> to control which type it targets.
20:25:19 <ddarius> x => y is a lambda, (x, y) => z is a multi-argument lambda, and (int x, String y) => z would be one with types.
20:25:59 <mapreduce> ddarius: The syntax has still to be finished debating afaik so they might do that later.
20:26:14 <ddarius> mapreduce: Well this is a bit deeper than a syntactical thing.
20:26:29 <ddarius> It is not always possible to infer the types of the argument to a lambda in a language like Java.
20:26:35 <ddarius> (Let alone always desirable.)
20:26:59 <mapreduce> It is, because a lambda is always 'converted' to a target type.
20:27:17 * cmccann has a lot of respect for the C# team and their ability to improve the language in useful, sensible ways, without generally making things any stupider than necessary given what they're starting from
20:27:35 <ddarius> I've generally been really happy with C#'s progress.
20:27:41 * carter thinks that it helps that they have access to lot of smart PL folks :)
20:27:44 <mapreduce> Any ambiguous cases you have to make unambiguous through providing a context of some sort (assignment to a variable, cast, etc.)
20:27:56 <ddarius> *sigh*
20:27:58 <carter> C# that is
20:28:18 * cmccann particularly enjoys Eric Lippert's blog
20:28:22 <mapreduce> Even C# does something similar in converting lambdas to delegate types.
20:28:49 <ddarius> carter: Sun had access to a lot of smart PL folks.  They made Self.  They used the technology from Self to make the JVM...
20:28:52 <mapreduce> so I don't think C# lets you do (int x => x * 2)(3) because there's no delegate type to target.
20:28:58 <ddarius> (Well, later JVMs.)
20:29:05 <carter> ddarius: that was also nearly 20 years ago!
20:30:03 <ddarius> Well, I don't think that's quite legal syntax, but I don't think there's any problem with it.  I will try tomorrow.
20:30:50 * ddarius likes the equirecursion in delegate types though.
20:33:02 <startling> ddarius, are you a horse breeder?
20:33:36 <mapreduce> ddarius: http://ideone.com/sGwaL
20:34:41 <mapreduce> ddarius: If I add a cast to Func<int, int> as in http://ideone.com/Hs23C it works.
20:34:54 <crdueck> :src Foldable
20:34:59 <crdueck> @src Foldable
20:34:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:35:12 <djahandarie> ddarius, how far have you gotten into that Quantum Field Theory pdf that was posted on ncafe awhile back? (If you tried reading it at all.)
20:35:41 <startling> crdueck, try :info Foldable in ghci
20:37:05 <ddarius> I don't follow n-cafe.
20:37:28 <djahandarie> Hmmm, I definitely recall talking to you about this specific PDF.
20:37:30 <carter> edwardk: does something like http://michaeldadams.org/papers/layout_parsing/layout-parsing.pdf make sense in the context of trifecta?
20:37:33 <ddarius> I have several QFT notes/books, though I haven't read most of them.
20:37:36 <ddarius> djahandarie: It's possible.
20:37:41 <carter> djahandarie: the blog n-cafe?
20:38:10 <djahandarie> ddarius, http://people.math.jussieu.fr/~fpaugam/documents/enseignement/master-mathematical-physics.pdf
20:38:12 <ddarius> If it's the Baez notes, then that isn't too specific to QFT.
20:38:41 <edwardk> carter: haven't seen that one before
20:38:54 <carter> slides are also on the hiw
20:38:55 <edwardk> carter: i'll dig through it after my lens talk thursday
20:39:00 <carter> cool
20:39:05 <ddarius> I definitely haven't looked at n-cafe in the last several months, let alone the last several days.
20:39:06 <carter> wish I could pop by and attend
20:39:11 <carter> too busy though!
20:39:25 <edwardk> the noises in the abstract are similar to my usual offside rule complaints
20:39:31 <djahandarie> ddarius, it was posted in June 2011, it has just been updated since then.
20:39:41 <carter> what are those complaints pray tell?
20:39:43 <djahandarie> Here's the post: http://golem.ph.utexas.edu/category/2011/06/towards_the_mathematics_of_qua.html
20:39:52 <Guest20060> can anyone explain why this doesnt work?   sequenceA [(>4),(<10),odd] 7
20:40:08 <Guest20060> I got that snippet from a book
20:40:12 <edwardk> carter: well, recovery from layout errors is very much entangled with lexing in haskell
20:40:19 <carter> ahhh
20:40:20 <carter> yess
20:40:24 <ddarius> djahandarie: It doesn't look familiar.
20:40:35 <carter> which is why its as helpful as parens mismatch errors in scheme?!
20:40:41 <djahandarie> ddarius, I'm like 99% sure you linked me that PDF on the day it was posted. *head scratch*
20:40:43 <edwardk> in ermine we do things a little bit differently, which means we can't parse some of the stranger corner cases like an empty do, etc. that arent really sensible anyways
20:40:53 <djahandarie> Oh well, I've been trying to make my way through this, been having a hell of a time.
20:41:03 <edwardk> also we deal with things like closing )'s at the same level as the containing block correctly
20:41:12 <ddarius> djahandarie: That would be an odd thing for me to do as I don't much care for QFT (hence not reading the various notes/books/etc.)
20:41:16 <carter> ermine = the in house haskell?
20:41:16 <dolio> > do
20:41:17 <lambdabot>   <no location info>: Empty 'do' construct
20:41:20 <edwardk> carter: yeah
20:41:25 <carter> whats an example of the closing ) sitch
20:41:30 <applicative> Guest,  import Data.Traversable
20:41:30 <lambdabot> applicative: You have 1 new message. '/msg lambdabot @messages' to read it.
20:41:48 <edwardk> carter: how many times in c do you end a { on the first character of a line? almost always
20:41:49 <djahandarie> Yeah, I do know you're not a fan of QFT. Weird.
20:41:53 <edwardk> how often do you do it in haskell?
20:42:04 <carter> true
20:42:08 <edwardk> you always float your )'s and }'s inward to avoid layout complaints
20:42:08 <jasonkuhrt> I was told by someone in node js irc to send this to you guys
20:42:08 <jasonkuhrt> https://github.com/substack/stream-handbook
20:42:14 <carter> oh
20:42:22 <carter> i just thought it was a style ting
20:42:23 <carter> thing
20:42:36 <edwardk> no, its (annoyingly) a syntactic requirement
20:42:46 * ddarius is not sure he's ever written } in Haskell in real code, and he ends his parens at the end of the line not on a line of their own.
20:43:01 <edwardk> ddarius: data Foo = Foo { runFoo :: Int }
20:43:10 <edwardk> no love for records?
20:43:27 <carter> edwardk: so whats an example of the bad paren syntax woes?
20:43:29 <ddarius> edwardk: Nope, but I do use that for newtype, but then I write what you have there, so still no problems.
20:43:46 <ddarius> But, that is an example where I do use {}.
20:43:47 <hpaste> pharaun pasted “ixSet - Maybe I'm missing something?” at http://hpaste.org/74939
20:43:56 <pharaun> seems like i need to add a deriving Data ?
20:44:12 <edwardk> carter: same gist do x <- ( …. \n   )  ending the ) at the position of x'
20:46:00 <pharaun> i'm looking at Data.Data and i'm still bit unclear what it is for
20:47:27 <byorgey> pharaun: yes, looks like you need to add 'deriving Data'
20:47:40 <carter> edwardk: which gist?
20:47:57 <byorgey> pharaun: Data.Data is for doing generic programming
20:48:05 <edwardk> gist as in meaning, not github =)
20:48:20 <byorgey> i.e. writing functions which work over any type, based on the structure of the type
20:48:36 <cmccann> what module is for doing specific programming? do we have one of those yet?
20:48:46 <carter> a "do <- (blahhh \newline )" breaks?
20:49:00 <edwardk> carter: yeah
20:49:06 <carter> gotcha
20:49:06 <byorgey> cmccann: System.IO
20:49:11 <carter> tired parsing
20:49:23 <carter> i escape alll the escapes
20:49:27 <carter> so
20:49:28 <cmccann> byorgey, pf, doesn't sound very useful to me
20:49:32 <carter> \n didnt parse
20:49:51 <byorgey> cmccann: it isn't.  everything should be generic.
20:50:03 <cmccann> yes
20:50:35 <byorgey> currently, people are looking into how to generically write programs for generating programs that work over the structure of types, based on the structure of kinds.
20:50:51 <byorgey> ...actually that is probably less of a joke than I meant it to be.
20:50:57 <cmccann> hahahahaha
20:51:22 <ddarius> franka's work is almost like that but it doesn't use the structure of kinds.
20:51:23 <cmccann> that's the hard part, coming up with something implausibly generic
20:52:20 <byorgey> "implausibly generic programming" sounds like a good paper title
20:52:38 <cmccann> or a library that edwardk would write
20:52:46 <edwardk> cmccann: =P
20:52:50 <cmccann> :D
20:52:54 <edwardk> cmccann: i already wrote my generic programming lib
20:52:57 <edwardk> Data.Data.Lens
20:53:11 <byorgey> implausible-generics
20:53:13 <edwardk> import that and Control.Lens. done ;)
20:54:26 <pharaun> :\ i just want silly ixset
20:55:06 <pharaun> hmm any good way for me to do an data instance?
20:55:35 <pharaun> or am i going to have to wrap up each of the FileID, DeviceID, FileOffset in a newtype and autodefine it via DeriveDataTypeable
20:55:58 * cmccann decides that messing with template haskell at this hour of the evening is not very appealing
20:56:27 <pharaun> this seems like a pain just to get indexing on a collection of data
21:04:00 <hpaste> applicative annotated “ixSet - Maybe I'm missing something?” with “ixSet - ” at http://hpaste.org/74939#a74940
21:05:04 <applicative> pharaun: the trouble is there aren't Data instances for some of the posix curiosa imported here, CDev CIno
21:05:24 <pharaun> :\
21:05:58 <pharaun> am i going to have to somehow extract something useful out of these newtype and create my own newtype
21:06:08 <applicative> pharaun: hey, it compiles.
21:06:21 <applicative> it must be safe ...
21:06:34 <pharaun> its all word64, word32
21:06:48 <pharaun> hidden behind newtypes, which as far as i can tell already has data/typeable
21:07:03 <pharaun> applicative: alright thanks i'll use this :)
21:08:25 <bio44> I'm curious about how people manage hackage packages. I'm constantly running into problems with conflicting dependencies and force reinstalling and hand tweaking cabal files and not being able to delete packages...
21:08:48 <applicative> You mean you would make your own newtypes for Word32 and functions to and from CDev.  I guess that's the right path.
21:09:36 <pharaun> applicative: i could, for now i want to get this to work as a proof of concept then i can make this much better
21:09:55 <applicative> bio44: funny, this is  the first time I've  heard anything like that
21:10:29 <applicative> you dont delete packages with cabal bio44, unless there are new features
21:12:04 <bio44> applicative: Cabal can't have two versions of a package?
21:12:10 <bio44> I
21:12:10 <pharaun> applicative: <3 thanks that got the thing to compile i'll get to work soon on fixing up the types better
21:12:31 <applicative> it's usually better not to have two versions
21:12:41 <bio44> I'm just frustrated to see "Warning: The following packages are likely to be broken by the reinstalls:
21:12:41 <bio44> " as its answer to "Resolving dependencies.."
21:13:03 <applicative> bio44: how long have you had your current ghc?
21:13:18 <bio44> not long enough to know how to answer that question
21:13:38 <shachaf> Wouldn't that more likely be "too long to know how to answer that question"?
21:14:02 <applicative> what version of ghc do you have?
21:15:06 <bio44> 7.4.1
21:15:44 <applicative> hm, the important things should be up to date with that.
21:15:47 <bio44> shachaf: probably "i have no idea what that mans" is a safer reponse, heh
21:16:37 <applicative> bio44: there are a million reasons for this sort of thing, but one is to do 'cabal install x' after repeated uses of 'cabal update' over a period of some time
21:16:37 <bio44> right, but then I want to build some third party project and it complains about mismatching versions of array or containers or whatnot
21:18:27 <applicative> bio44: array and containers come with the ghc; you wouldn't usually want to install new versions of them.
21:18:51 <pharaun> well yesod for a while was a major pain with cabal updates/new installs
21:18:57 <pharaun> its quite a bit better i think
21:19:08 <pharaun> or at least i have not ran into issues for a while
21:19:20 <applicative> yes, but it is an unusually volatile project even by  haskell standards....
21:20:26 <applicative> bio44: is the cabal file for the third party project old, so that it specifies upper bounds for array and containers that predate your own?
21:21:02 <applicative> bio44: what operating system are you using?
21:21:05 <bio44> bio44: I've seen that, and tried to remove the upperbounds from the cabal file. Sometimes it works, sometimes I'm left confused..
21:21:20 <bio44> and just right now I wanted to install something that
21:21:22 <bio44> regex-base-0.93.2 (reinstall) changes: containers-0.4.2.1 -> 0.5.0.0
21:21:32 <bio44> OSX 10.7
21:21:37 <applicative> hm
21:22:24 <bio44> and that thing just now was uploaded last year
21:22:51 <applicative> it bugs me that you have two versions of containers.  does ' ghc-pkg check ' show anything horrible.  if you do 'ghc-pkg list' which version of  containers is in the 'global' haskell patform part
21:22:53 <bio44> yet it needs to reinstall a regex library that requires a new containers than the one in my gch/platform install?
21:23:29 <bio44> that arrow means I have two? i thought it meant change version to version...
21:23:39 <applicative> Hm, is regex-base in the Platform?
21:24:10 <applicative> bio44: no,  it doesn't mean that.
21:25:10 <applicative> you shouldn't need to reinstall regex-base, I'd think  I'm just trying to reason to the source of the trouble
21:26:29 <applicative> regex-base-0.93.2 is the one in the haskell platform you presumably have
21:26:29 <bio44> hmm i have the older containers in my /Library, but newer in home/.ghc ...
21:26:58 <bio44> I
21:28:35 <bio44> I'll try nuking and reinstalling. I probably messed some things up a while back when I was installing/uninstall haskell through different means
21:29:04 <bio44> (packagemanager then OS installer from the website)
21:29:27 <applicative> you can do ghc-pkg unregister foo-a.b.c with the locally installed stuff catalogued in ~/.ghc
21:30:38 <applicative> I don't think the homebrew route is too dependable. There is a script somewhere in there to root out all your other haskell stuff
21:31:47 <applicative> http://www.vex.net/~trebla/haskell/sicp.xhtml is aimed at linux users, but it has some helpful material about conflicts
21:33:08 <monochrom> if you have two versions of anything that should just come with GHC, you can bet real money that you will have problems, and the bet will win in the long run
21:39:09 <bio44> I'll mess around with it then and see what happens
21:44:10 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/99463/ is how one package author's misconception can screw over a lot of users
21:44:19 <pharaun> applicative: haha yeah its remarkably volatile >_<
21:44:31 <NemesisD> any of you guys use hspec?
21:53:03 <applicative> bio44: if you clear everything out, I think one sensible policy is to install the  main things you need with one command 'cabal install georgia california lemon-tree', then cabal can reason  without antecedent constraints how  to put it all together
21:54:04 <applicative> NemesisD: No.  I was just looking at an hspec file, though it seems kind of cool.
21:54:47 <Jurily> my 'safe cabal' process involves nuking everything, installing the executables in one go, nuking everything but the executables, and installing everything in another big build
21:55:04 <latro`a> georgia california lemon-tree, lol
21:57:18 <bio44> applicative: thanks
21:58:41 <applicative> bio44: anyway people here can help with particular difficulties.  I don't know what the best general philosophy is.  The existing technology still presupposes a smaller stabler hackage
22:00:35 <ddarius> There was never a stabler hackage...
22:01:38 <applicative> ddarius: yes, that does't speak against what I said
22:01:43 <latro`a> isn't that kinda why it's named hackage?
22:03:31 <ivanm> ddarius: it was just more stable when no-one was using it? :p
22:03:47 <ivanm> (and thus unable to tell when it stopped working)
22:03:56 <ddarius> There was no period when it existed and no one was using it.
22:04:35 * ddarius can assure you though, that without Hackage we wouldn't have all these problems.
22:04:44 <ddarius> Of course, we'd have like 20 libraries.
22:05:18 <ddarius> You also wouldn't know how to build half of them.
22:05:40 <ivanm> ddarius: sure you would: unpack them all onto the GHC source tarball before building! :p
22:06:06 <ddarius> YHC used Scons.
22:06:49 <ddarius> That said, I think the early versions of YHC were implemented in Common Lisp.
22:08:13 <Jurily> is there a Haskell parser library in C or C++?
22:08:49 <startling> Jurily: you mean a library written in C or C++ for parsing haskell?
22:08:54 <Jurily> yes
22:08:55 <ddarius> Jurily: You can expose haskell-src-exts as a C library if you wanted to.
22:09:19 <ddarius> Presumably there's one in Hugs.
22:09:57 <Jurily> I've checked Hugs, I'm not sure it's reentrant
22:10:32 <applicative> Jurily: maybe you can bring it back
22:11:02 * applicative calls to fellow members of the Committee to Save Hugs
22:11:23 <Jurily> hmm
22:11:33 <ddarius> Hugs sucks.
22:12:19 <applicative> Hugs rules.
22:13:28 * startling hugs ddarius 
22:13:45 <startling> Jurily, why do you want it?
22:14:32 <zzing> I am having an issue No instance for (ToWidget App App (t0 -> a0))  arising from a use of `toWidget' and I cannot for the life of me figure out why. I don't have this issue on a development compile (yesod), just when I go for the real compile.    The possible fix I don't see how to add  the instance declaration because I don't use 'App' explicitly in what it says. Any thoughts? http://hpaste.org/74942
22:14:36 <Jurily> I'd like a Haskell plugin for KDevelop that doesn't involve ghci
22:14:46 <startling> ah
22:14:56 <Jurily> or any IDE, for that matter
22:15:25 <startling> Jurily, you can probably write the plugin in haskell, compile, and run it alone
22:15:49 <applicative> the hugs error for 'main = 2http://ideone.com/8kP5o
22:16:13 <applicative> the hugs error for 'main = 2' http://ideone.com/8kP5o is a miracle of lucidity compare to http://codepad.org/pRSKykAp
22:16:52 <NemesisD> i'm trying to test a pure function with hspec that in some cases calls error. they have an expectation combinator that looks for exceptions  of ErrorCall
22:17:36 <ddarius> applicative: Are you kidding me?  It refers to code that doesn't even exist.
22:17:39 <NemesisD> so its something like it "throws an error" $ (return pureFunctionThatErrors) `shouldThrow` anyErrorCall but that doesn't match
22:17:46 <applicative> ach, maybe the hugs errors arent so great
22:18:04 <applicative> ddarius: yes, it emerges that hugs puts >> return () after your main
22:18:28 <NemesisD> Control.Exception.Base has an ErrorCall exception that says its thrown when the user calls error. do i have to do something special to get this to work?
22:18:53 <ddarius> My experience with dealing with people using Hugs and using Hugs occasionally myself back when people actually used Hugs was that the error messages are generally much worse and only less intimidating at best.
22:19:51 <Jurily> I've gotten a 240 kilobyte error message from Boost once
22:19:53 <applicative> ddarius: maybe, I think lately the ghc is pretty user indifferent,  not that I blame it.
22:20:01 <Jurily> so I guess GHC is still good :)
22:20:43 <ddarius> applicative: People, even relative beginners, are using features that are fairly new.  The error reporting has not kept up.
22:20:55 <applicative> ddarius: yes
22:21:04 <ddarius> I don't remember what TREX errors were like though.
22:21:21 <ddarius> Restricted type synonyms, though, is pretty nice.
22:22:52 <applicative> I am principally fond of it because it was so easy to install. When I first tried to install the ghc I basically had to undertake the study of operating systems, or so it seemed to me at the time
22:23:37 * ddarius hopes applicative has actually studied operating systems since then.
22:24:30 * ddarius remembers back when TH didn't support records.
22:25:45 * ddarius wonders what Igloo and Heffalump are up to.
22:26:00 <ddarius> Well I guess I have a (very vague) idea of what Igloo is up to.
22:26:26 <dolio> I don't really understand why people think GHC's error messages are so bad.
22:26:32 <dolio> But then, I don't write 'main = 2' often.
22:27:18 <ion> instance Num (IO a)
22:27:26 <applicative> dolio: no, wasnt a good example.  I don't find them so bad either, but I've been reading them for some time ...
22:27:54 <dolio> I can remember when they actually were bad.
22:27:58 <ddarius> dolio: Perhaps GHC's lack of keeping up with newer features in terms of error reporting is due to the grief over this despite the rather large effort that the GHC team has put in to produce good error messages.
22:28:05 <ddarius> dolio: Really?
22:28:15 <dolio> Compared to what they are today.
22:28:22 <ddarius> I know the higher rank stuff had some fairly cryptic error messages for a while.
22:28:23 <applicative> No instance for (Num (Char -> b0)) arising from a use of `it'     Possible fix: add an instance declaration for (Num (Char -> b0))
22:28:42 <applicative> for ' map 1 "hi" '
22:29:01 <ddarius> dolio: They've definitely made improvements.  GHC HQ is fairly responsive to these sorts of issues.
22:29:12 <applicative> why not just say: "Bullshit, are you saying 1 is a function on Chars?
22:29:21 <ddarius> > 1 'a'
22:29:22 <lambdabot>   1
22:29:25 <ddarius> Problem fixed.
22:29:28 <applicative> Im sure that would be childs play to implement
22:29:28 <dolio> I should also mention that I don't care in the slightest what the error messages in ghci are.
22:29:45 <ddarius> dolio: They're the same error messages.
22:30:21 <dolio> You'll never get error messages about a non-existent "it" from a .hs file.
22:30:35 <Jurily> can Haskell even have "good" error messages?
22:30:40 <ddarius> dolio: Yes, but 'it' is reasonable as that is a public part of how GHCi works.
22:30:57 <applicative> the error is the same words if I compile main = print $  map 1 "hi"
22:31:00 <NemesisD> hmm i should rephrase, anyone have a clue why: error "oh crap" `shouldThrow` anyErrorCall passes but (return $ error "oh crap") `shouldThrow` anyErrorCall does not?
22:31:18 <Jurily> NemesisD: laziness
22:31:19 <NemesisD> the second one being that the error call is pure? not sure if my terms are correct
22:31:19 <shachaf> NemesisD: Because it just forces it to WHNF?
22:31:30 <shachaf> "return" has nothing to do with "purity".
22:31:42 <shachaf> (Despite the name of the method in Applicative.)
22:31:50 <NemesisD> so should i bang pattern it?
22:31:59 <applicative> @type error
22:32:00 <lambdabot> forall a. [Char] -> a
22:32:03 <ddarius> There's no binding what are you going to use a bang pattern on?
22:32:36 <applicative> @type return (error "ick")
22:32:37 <lambdabot> forall a (m :: * -> *). (Monad m) => m a
22:32:42 <NemesisD> hmm
22:32:47 <shachaf> Bang! Pattern.
22:32:49 <ddarius> shachaf: From the perspective of monads as notions of computation, pure embeds a pure language into an "impure" one, and arguably is a normal form for any term that is actually pure.
22:33:42 <applicative> class Applicative f where normal :: a -> f a
22:34:06 <shachaf> ddarius: Hmm. I suppose.
22:34:21 <NemesisD> how do i force the evaluation then?
22:34:56 <shachaf> (return undefined) just doesn't throw an error.
22:35:12 <shachaf> Depending on the monad, there might be no way to get an error out of it.
22:35:41 <shachaf> (In particular for data Null a = Null, but also for IO and Reader Void and other things.)
22:35:42 <applicative> > return undefined :: [Int]
22:35:43 <lambdabot>   [*Exception: Prelude.undefined
22:35:45 <NemesisD> shachaf: shouldThrow requires the first argument be IO a, the function i'm calling is not in the IO monad
22:36:05 <ddarius> > (return undefined :: Identity ()) `seq` ()
22:36:05 <NemesisD> so i'm trying to lift it into IO, force the error and asser that its thrown
22:36:05 <lambdabot>   *Exception: Prelude.undefined
22:36:13 <shachaf> NemesisD: Oh. Have you tried using "evaluate" instead of "return", maybe?
22:36:36 <ddarius> What's the type of shouldThrow
22:36:37 <applicative> ah clever
22:37:37 <NemesisD> shouldThrow :: Exception e => IO a -> Selector e -> Expectation
22:37:45 <ddarius> Okay, then evaluate is what you want.
22:37:52 <NemesisD> woo! thanks!
22:37:59 <johnw> i'm liking .: and .^ from Data.Function.Pointless
22:38:17 <shachaf> Uh-oh.
22:38:28 * shachaf has never heard of Data.Function.Pointless but it sounds like a bad idea.
22:38:33 <johnw> haha
22:38:36 <johnw> http://hackage.haskell.org/packages/archive/pointless-fun/latest/doc/html/Data-Function-Pointless.html
22:38:37 <shachaf> johnw will probably say that this is a common theme in what I say here.
22:38:45 <johnw> how did you know what I was thiking?
22:39:19 <johnw> the strict composition (.!) is handy too
22:39:33 <shachaf> I'm not sure why the documentation says "(f .: g) x y = f (g x y)" but the implementation says "(.:) = (.) . (.)"
22:39:49 <shachaf> Are they trying to make it obscure on purpose?
22:40:05 <ddarius> Well they are certainly sending conflicting messages somewhere.
22:40:51 <pharaun> someone likes pointless programming a little much? :)
22:40:53 <shachaf> Oh, come on. The documentation says "(f .^ g) x y = f x (g y)" and the implementation says "flip .: (.) . flip"?
22:41:15 <ddarius> Yeah, that's retarded.
22:41:24 <ddarius> @pl \f g x y -> f x (g y)
22:41:24 <lambdabot> flip . ((.) .)
22:41:42 <johnw> pharaun: there are times when I prefer passing in a composition than a lambda, but I can't abide (. f) . g.  f .^ g is at least a bit clearer
22:41:50 <unlink> .: is a great combinator, it should be shipped with the platform
22:42:07 <shachaf> @ty \f g x y -> f x (g y)
22:42:07 <johnw> .:, .^ and .! should be in base
22:42:08 <lambdabot> forall t t1 t2 t3. (t -> t2 -> t3) -> (t1 -> t2) -> t -> t1 -> t3
22:42:15 <johnw> but the other stuff in Pointless doesn't make much sense to me yet
22:42:20 <ddarius> Not to mention, .:., .::, .::., .:::, usw.
22:42:32 <pharaun> johnw: hehe :p
22:42:43 <johnw> ddarius: what would be the difference between .:. and .::?
22:42:51 <shachaf> ddarius: I think Unicode already has code points for Braille.
22:42:52 <johnw> I could see .:: meaning f (g x y z)
22:42:58 <MostAwesomeDude> Wait, is .: just supposed to be . on two-argument functions?
22:43:16 <shachaf> MostAwesomeDude: No, just the last function gets two arguments.
22:43:35 <ddarius> Really, J does this stuff much better.
22:43:59 <MostAwesomeDude> shachaf: I could have used this combinator at least ... three times, maybe, in my last coding session.
22:44:08 <MostAwesomeDude> My mind is blown.
22:44:14 <ddarius> :t (.:)
22:44:15 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
22:44:28 <shachaf> MostAwesomeDude: It's probably not a good idea to.
22:44:31 <latro`a> :t fmap fmap fmap
22:44:32 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:44:41 <shachaf> Point-free Haskell code beyond a certain complexity tends to be write-only.
22:44:43 <latro`a> they're the same, right?
22:44:47 <shachaf> Yes.
22:45:05 <NemesisD> how can i find out the upper limit of an int on my system in haskell
22:45:06 <pharaun> i don't mind some .'s here and there but once you start getting into 20 .'s it gets a little dense for me
22:45:08 <latro`a> :t fmap fmap fmap fmap
22:45:09 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
22:45:12 <shachaf> NemesisD: maxBound
22:45:14 <ddarius> > maxBound :: Int
22:45:15 <lambdabot>   9223372036854775807
22:45:27 <randomclown> > maxBound :: Integer
22:45:28 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
22:45:28 <lambdabot>    arising from...
22:45:34 <latro`a> :t fmap fmap fmap fmap fmap
22:45:35 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
22:45:41 <applicative> > maxBound :: Char
22:45:42 <lambdabot>   '\1114111'
22:45:44 <latro`a> that's interesting, the parity matters
22:46:05 <NemesisD> ok thats pretty big
22:46:19 <NemesisD> was wondering if i should switch to the integer version of threaddelay
22:46:32 <shachaf> Parity of essence.
22:46:43 <latro`a> wot
22:46:57 <shachaf> Our precious bodily fluids!
22:47:03 <latro`a> ...wot
22:47:05 <shachaf> http://slbkbs.org/fluids.jpg
22:47:23 <latro`a> *sigh*
22:47:48 <Ralith> wot
22:47:59 <c_wraith> know what else was used by nazis?  Oxygen!
22:48:09 <shachaf> c_wraith: zomg
22:48:25 <latro`a> also water
22:48:30 <latro`a> also nitrogen
22:48:31 <latro`a> also ...
22:48:34 <ivanm> did you know that dihydrogen monoxide - which kills thousands of people every year! - can be found throughout our homes?
22:48:54 <shachaf> ivanm: latro`a beat you to it.
22:49:03 <centrinia> Dihydrogen Monoxide (DHMO) can cause death if inhaled.
22:49:05 <ivanm> dammit!
22:49:06 <latro`a> kinda ruined the joke, sorry
22:49:12 <centrinia> DHMO is a powerful solvent.
22:49:33 <Ralith> ivanm: it's INSIDE YOUR BODY!
22:49:33 <latro`a> in some contexts it'd be nice if it were better, however -_-
22:49:35 <centrinia> DHMO is present in all cancer cells.
22:49:36 * ddarius doesn't recall being warned that about the solvency of solvents.
22:49:40 <ivanm> Ralith: ZOMG!!!
22:49:40 <ddarius> latro`a: Yep.
22:50:09 <latro`a> I should totally buy a whole bunch of DMSO and use that for my cleaning instead
22:50:15 <latro`a> I totally wouldn't get cancer doing that
22:50:18 <centrinia> DMSO :-S
22:50:19 <latro`a> definitely wouldn't
22:50:38 <centrinia> Have you ever touched DMSO with your skin? :-S
22:50:43 <latro`a> fortunately no
22:50:45 <centrinia> Good.
22:50:50 <latro`a> have worked with it, though
22:50:54 <centrinia> me too.
22:51:04 <latro`a> DMSO-d6 in particualr
22:51:06 <latro`a> *particular
22:51:11 <latro`a> not that that makes much difference wrt safety
22:51:18 <centrinia> What is the d6?
22:51:22 <latro`a> deuterated
22:51:32 <latro`a> a slightly uncommon NMR solvent
22:51:40 <shachaf> latro`a: Is it bad to touch it?
22:51:44 <latro`a> DMSO? quite
22:52:06 <latro`a> most polar aprotic solvents are quite nasty to the body
22:52:08 <centrinia> shachaf, it can enable the absorption of all kinds of shit into your body.
22:52:29 <latro`a> I was thinking of directly, but centrinia's point is also valid
22:53:04 <shachaf> centrinia: Well, you should be careful, of course.
22:53:12 <shachaf> But I heard it tastes like garlic!
22:53:16 <latro`a> anyway yeah DMSO-d6 isn't that uncommon, it's a pretty good choice when you have something too polar to dissolve in CDCl3
22:53:21 <ddarius> They douse brains in it.
22:53:21 <centrinia> I wouldn't know by experience. :)
22:53:53 <centrinia> Also, it tastes like garlic when you touch it.
22:54:22 <ivanm> centrinia: without even getting it near your mouth?
22:54:23 <ivanm> :p
22:54:28 <centrinia> Yes.
22:54:32 <latro`a> ...what
22:54:37 <latro`a> how does that, what
22:54:48 <unlink> Is it idiomatic to use head with infinite lists?
22:54:55 <lightquake> sure
22:55:00 <shachaf> unlink: Reasonably.
22:55:02 <ddarius> It's idiomatic to use pattern matching.
22:55:15 <shachaf> That too.
22:55:18 <lightquake> latro`a: apparently it's super permeable
22:55:18 <ddarius> However, if you know your list is infinite possibly using a Stream type is recommended to make that explicit.
22:55:20 <lightquake> to skin
22:55:27 <shachaf> A Stream type would be nice but that's usually inconvenient.
22:55:29 <latro`a> well yeah
22:55:30 <latro`a> but
22:55:36 <latro`a> how does that trigger a taste on the skin
22:55:58 <shachaf> latro`a: It gets to your tongue.
22:56:05 <latro`a> through the skin?
22:56:05 <latro`a> O.o
22:56:13 <latro`a> and it does this how fast?
22:56:39 * ddarius is not healing like he used to.
22:57:14 <shachaf> "A garlic-like flavor might be tasted in the mouth anywhere from 15 seconds to a few minutes after application."
22:57:25 <latro`a> weird
22:57:52 <shachaf> That's enough offtopicity for here. #haskell-blah
22:59:31 <mcstar> so this is what is going on #haskell while i sleep...
23:06:34 * nobot tired
23:06:53 <nobot> @run 2+1
23:06:54 <lambdabot>   3
23:07:05 <c_wraith> the @run command is the same as >
23:07:17 <centrinia> @run putStrLn "pwnt"
23:07:18 <lambdabot>   <IO ()>
23:07:30 <shachaf> @run putStrLn " <IO ()>"
23:07:31 <lambdabot>   <IO ()>
23:07:34 <nobot> >take 100 $ map (^2) [1..]
23:07:49 <c_wraith> > text "the space is important"
23:07:50 <lambdabot>   the space is important
23:08:00 <nobot> > take 100 $ map (^2) [1..]
23:08:01 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
23:08:07 <nobot> @botsnap
23:08:07 <lambdabot> :)
23:08:26 <mcstar> :t text
23:08:27 <lambdabot> String -> Doc
23:08:33 <mcstar> whats Doc?
23:09:06 <nobot> @help
23:09:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:09:06 <shachaf> @hoogle Doc
23:09:07 <lambdabot> Text.PrettyPrint.HughesPJ data Doc
23:09:07 <lambdabot> Text.PrettyPrint data Doc
23:09:07 <lambdabot> Language.Haskell.TH.PprLib type Doc = PprM Doc
23:09:29 * hackagebot yesod-form 1.1.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.1.2 (MichaelSnoyman)
23:09:31 * hackagebot yesod-test 0.3.0.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.3.0.1 (MichaelSnoyman)
23:09:33 * hackagebot network-conduit 0.5.0.2 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.5.0.2 (MichaelSnoyman)
23:09:35 * hackagebot keter 0.2.0.2 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.2.0.2 (MichaelSnoyman)
23:09:59 <nobot> @pl \g s m t -> g s : m t
23:09:59 <lambdabot> (((.) . (:)) .)
23:10:09 <mcstar> i see, Doc in the signatures, but that doesnt explain what it is
23:10:17 <ksf> mcstar, something that you can format in different ways into concrete strings
23:10:28 <mcstar> thx
23:10:35 <ksf> ...and compose with other documents into, well, a document.
23:10:51 <ksf> think linebreaking control, indenting, parenthesis, etc.
23:11:58 <ksf> @msg lambdabot :t hang
23:11:58 <lambdabot> Not enough privileges
23:12:03 <ksf> darn.
23:12:44 <ksf> @bot
23:12:44 <lambdabot> :)
23:12:47 <ksf> grrr
23:12:57 <ksf> why isn't lambdabot reacting to /msg?
23:13:13 <avpx> It's working for me
23:15:41 <Axioplase> Hi. Has anyone used Luke Palmer's DrawingCombinators library?  When I call the RENDER function on an image, well, "nothing happens"…
23:16:27 <NemesisD> what are you supposed to use for locale if you don't use haskell98
23:16:30 <Axioplase> I'm willing to plot straight lines (basically, time series), and thought his library would be a good choice…
23:16:31 <ksf> it's not reacting to :t, but to >
23:17:03 <shachaf> ksf: :t only works in the channel.
23:17:03 <Enigmagic> NemesisD: old-locale
23:17:22 <NemesisD> Enigmagic: but..but its old
23:17:33 <Enigmagic> NemesisD: there isn't a new one
23:18:02 <NemesisD> seems like an oversight in naming it old-time
23:18:36 <Cale> Axioplase: hmm...
23:18:49 <mcstar> Axioplase: maybe you could use gnuplot?
23:19:16 <Cale> Axioplase: Could you put your code on hpaste?
23:19:29 * hackagebot wai 1.3.0.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.3.0.1 (MichaelSnoyman)
23:19:31 * hackagebot wai-app-static 1.3.0.2 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.0.2 (MichaelSnoyman)
23:19:33 * hackagebot wai-extra 1.3.0.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.0.2 (MichaelSnoyman)
23:19:34 <Axioplase> Cale: Sure.
23:19:35 * hackagebot wai-handler-launch 1.3.1 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.3.1 (MichaelSnoyman)
23:19:37 * hackagebot wai-websockets 1.3.0.1 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.3.0.1 (MichaelSnoyman)
23:19:55 <Axioplase> mcstar: well, I'd like to draw interactively from my code, if I can get it to work.
23:20:12 <mcstar> plot as the data comes in real time?
23:22:16 <hpaste> Axioplase pasted “DrawingCombinators” at http://hpaste.org/74943
23:22:38 <ksf> Axioplase, I think you need a gl context for that.
23:22:40 <Cale> oh!
23:22:52 <Cale> yeah, it doesn't set up GL for you
23:23:03 <Axioplase> Aha!
23:23:07 <NemesisD> anyone have any ideas for testing IO, such as something that does printing with printf?
23:23:16 <hpaste> mcstar pasted “direct gnuplot” at http://hpaste.org/74944
23:23:41 <Cale> Axioplase: You may like to try Gloss
23:24:02 <mcstar> Axioplase: see my paste, maybe it is useful
23:24:12 <Cale> Axioplase: which is a little more batteries-included as far as that sort of library goes, though it doesn't have the super-clever monoidal feedback thing
23:24:28 <mcstar> why is ?? around paste titles?
23:24:39 * hackagebot warp 1.3.1.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.1.1 (MichaelSnoyman)
23:24:41 * hackagebot warp-tls 1.3.0.2 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.3.0.2 (MichaelSnoyman)
23:24:51 <ksf> the package depends on ftgl or glut, though.
23:24:51 <Mon_Ouie> mcstar: Because you didn't set your encoding right, those are quotes
23:25:01 <Cale> mcstar: You mean from the bot? That'd be your IRC client
23:25:24 <mcstar> oh
23:25:28 <mcstar> fail
23:25:35 <ksf> freenode uses latin/unicode hybrid
23:25:43 <shachaf> ksf: Freenode doesn't use nothin'
23:25:45 <mcstar> it was working ok, weeks ago
23:25:47 <shachaf> IRC sends bytes.
23:25:55 <ksf> well, it's standard, here.
23:26:14 <shachaf> Cale had a great UTF-8/ISO-8859-1 issue with lambdabot once.
23:26:23 <Axioplase> Cale: gloss may be the simple enough solution I need.
23:27:12 <donri> edwardk: where did focus go?
23:27:21 <edwardk> zoom
23:27:46 <donri> oh!
23:27:50 <edwardk> zoom started as a more specific type that was limited to a subset of the traversals, but could deal with nested state in deeper monad transformer stacks
23:27:58 <edwardk> but then i generalized it to where it subsumed focus
23:28:03 <edwardk> so i killed focus
23:28:08 <edwardk> because zoom is _way_ more powerful
23:30:56 <donri> edwardk: bit confusing to have both magnify and zoom. maybe rename zoom back to focus?
23:30:56 <Cale> edwardk: So that's why all your photos are blurry and way too close to their subjects!
23:31:29 <edwardk> well, i was just about to use focus in the zipper code that is going in. ;)
23:31:44 <edwardk> Magnify is used to read stufff, Zoom looks across states ;)
23:32:07 <edwardk> Magnify is Local on steroids
23:32:09 <edwardk> er local
23:32:25 <edwardk> since its local that can change the environment type
23:32:44 <edwardk> As for why its Zoom, when I port Lensed back from snap, you'll have pan and zoom =P
23:34:31 * hackagebot redis 0.13 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.13 (AlexanderBogdanov)
23:34:49 <donri> pan?
23:36:37 <edwardk> donri: Lensed is sort of like State with two levels, so you have a top level state and a lens (or at this rate probably a full zipper path) down into part of it, and you can come back up and pan relative to the root
23:37:27 <edwardk> unlike a naive ReaderT (Simple Lens b v) (StateT v m) a  its actually more efficient.
23:37:50 <edwardk> because it doesn't 'unfocus' until you go to zoom in or out
23:38:32 <donri> aha
23:38:59 <donri> is lensed new in git?
23:39:06 <edwardk> its not in yet
23:39:25 <edwardk> i've been debating about the best way to port it, and i want to get the zipper model in first
23:39:33 <edwardk> because it'd be nicer to have it have access to a path
23:40:35 <hpaste> Cale pasted “For Axioplase” at http://hpaste.org/74946
23:41:16 <Cale> Axioplase: note that you can use the mouse wheel to zoom and can drag the image around
23:43:52 <edwardk> @hpaste
23:43:53 <lambdabot> Haskell pastebin: http://hpaste.org/
23:44:23 <hpaste> edwardk pasted “nicer lens-based zippers” at http://hpaste.org/74947
23:44:37 <edwardk> i still need to add the indexed lens to access the current focus, etc.
23:45:18 <edwardk> This way the zippers themselves look like navigational breadcrumbs even more than in zippo, etc.
23:45:27 <edwardk> Top :> a -- is a top level zipper.
23:46:01 <edwardk> Top :> Tree a :> Tree a :> a -- starts at a Tree, has another tree bookmarked and goes to an a.
23:46:26 <edwardk> up :: (a :> b :> c) -> (a :> b)
23:49:17 <startling> edwardk: so is it possible for me to have a leaf :: Ord k => k -> Simple Lens (Trie k a) (Maybe a) into those Tries we talked about last night?
23:49:32 * hackagebot QuickAnnotate 0.6 - Annotation Framework  http://hackage.haskell.org/package/QuickAnnotate-0.6 (ShayanNajd)
23:49:36 <edwardk> yes
23:49:44 <Cale> edwardk: There's got to be some sort of joke where you can define something called horror and then recoil in it.
23:49:50 <edwardk> cale: =)
23:50:12 <edwardk> Coil comes from the fact that most zippers are coil zippers these days. cheaper to manufacture.
23:50:57 <edwardk> next comes saving and restoring
23:51:44 <startling> edwardk, thought so, but I thought I might be missing something. thanks!
23:52:30 <startling> is there a short way for me to compose a Simple Lens x (Maybe a) with a Simple Lens a b ?
23:52:38 <Axioplase> Cale: yeah, I have a few problems with Gloss though: 1) fullscreen does not release the focus of the mouse, and 2) I have to give the window dimensions, while I wish that resizing the window would deform the graphics in it.
23:52:58 <edwardk> startling: you can do so to get a traversal, by interposing 'traverse'
23:53:03 <edwardk> foo.traverse.bar
23:53:22 <edwardk> that gives you a Simple Traversal x b
23:53:57 <startling> edwardk: hmm, that could be useful still
23:54:30 <edwardk> startling: this is why i have traverseAt inside IndexedTraversal. even though its basically at k.traverse
23:54:32 * hackagebot parsergen 0.2.0.4 - TH parser generator for splitting bytestring into fixed-width fields  http://hackage.haskell.org/package/parsergen-0.2.0.4 (JasperVanDerJeugt)
23:54:45 <edwardk> (its a little more complicated because its an indexed traversal using the key)
23:54:50 <Axioplase> Cale: I'm now thinking that I could maybe draw to SVG or postscript, and use a viewer that refreshes upon file modifications
23:54:57 <edwardk> so its at k <. traverse  IIRC =)
23:55:16 <Jafet> You might as well use cairo then.
23:56:36 <startling> edwardk, can I combine a Traversal with a Getter somehow to get a Lens?
23:56:43 <Axioplase> Jafet: yeah, I'll have a look at 'diagrams' first.
23:56:44 <edwardk> no
23:56:59 <startling> edwardk: k.
23:57:10 <startling> oh, am I misunderstanding that diagram?
23:57:34 <edwardk> a lens provides you with all the functionality of both a getter and a traversal
23:57:40 <startling> right, okay
23:57:49 <edwardk> when you use (.) you go _up_ to the least upper bound of the two
23:57:58 <edwardk> so combining say, a Getter and a Traversal gives you a Fold.
23:58:15 <startling> makes sense
23:58:40 <startling> maybe one day I'll understand this magic
23:58:42 <edwardk> basically the chart is all about what you can do with a Foo once you have it
23:58:57 <startling> edwardk: yeah, understood
