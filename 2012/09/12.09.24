00:05:46 <dmos> I'm trying to get feldspar-compiler to compile under ghc 7.4.2, but I'm stumped by this error:
00:05:53 <dmos> Feldspar/Compiler/Imperative/Representation.hs:90:48:
00:06:00 <dmos>     Expecting one more argument to `StructMember'
00:06:12 <dmos>     In the type `Label t StructMember'
00:06:23 <dmos>     In the definition of data constructor `StructMember'
00:06:36 <dmos>     In the data type declaration for `StructMember'
00:09:00 <ceii_> dmos: paste the source somewhere?
00:09:49 <dmos> ceii_: 1sec
00:10:02 <unbliw> djfoiad
00:11:53 <hpaste> dmos pasted “Feldspar.Compiler.Imperative.Representation” at http://hpaste.org/75221
00:12:05 <dmos> ceii_: ^^
00:14:00 <ceii_> Label seems to be defaulted to the wrong kind
00:14:02 <dmos> the package seems to have last compiled around ghc v7.0 (guessing from docs and base constraints (< 4.4))
00:14:09 <ceii_> actually I've no idea how this used to compile before
00:14:22 <dmos> ceii_: so a kind annotation should do the trick?
00:14:39 <dmos> ceii_: i had the same reaction when seeing the code.
00:14:57 <ceii_> yep, I'm just trying to figure out the kind of the t parameter
00:15:16 <ceii_> oh, it's a *
00:16:09 <ceii_> so Label has kind * -> (* -> *) -> *
00:16:20 <ceii_> not sure about the syntax of annottions for things like that though
00:16:24 <ivanm> I wonder why that fails but not earlier usage of Label
00:16:26 * hackagebot bmp 1.2.2.1 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.2.1 (BenLippmeier)
00:16:49 <ceii_> right
00:16:57 <ivanm> where is Label defined?
00:17:10 <ceii_> in the Annotation class at the top
00:17:18 <ivanm> ahhh, right
00:17:31 <unbliw> kjanskja
00:17:46 <dmos> so where would I have to insert the kind annotation?
00:18:00 <ivanm> ugh, the EqLabel definition is fugly
00:18:16 <ivanm> dmos: I suggest in the definition of Label
00:19:09 <ivanm> feldspar looks like one of those academic projects where are soon forgotten :s
00:19:14 <ivanm> well, maybe not _soon_
00:19:52 <dmos> ivanm: they are apparently still tinkering around with it and trying to get an LLVM backend in, but currently it's in a pretty sad state.
00:20:01 <ivanm> hmmmm
00:20:26 <dmos> at least that's what I've gathered from google and various slides online.
00:25:06 <hiptobecubic> considering everyone agrees it's ugly and bad style, maybe the docs for ($) shouldn't have an example of using it multiple times in a row? Or a note about using (.) instead.
00:25:31 <ddarius> Not everyone agrees to that.
00:25:55 <hiptobecubic> ddarius, well of course someone disagrees.
00:26:02 <dmos> ivanm, ceii_ : Ok, KindSignatures with changing Label to 'type Label t (s :: * -> *)' worked. Thanks a lot!
00:26:03 <ddarius> And those docs were probably written long before the other style became popular.
00:26:05 <Nafai> so is it really preferred to use parens over $?
00:26:15 <ceii_> dmos: you're welcome
00:26:29 <ceii_> Nafai: no, not parens
00:26:31 <ivanm> Nafai: not for me it isn't
00:26:35 <hiptobecubic> ddarius, but i had the  impression that . . . . $  was pretty generally accepted as a nicer way
00:26:58 <ivanm> the only times I use parens over $ is in cases where it causes fixity problems, namely (f x) `foo` (g y)
00:27:01 <ceii_> Nafai: but it's generally better to use f . g . h $ x than f $ g $ h $x
00:27:04 <ddarius> hiptobecubic: That's a fairly recent thing and even then, as I said, not everyone agrees with it.
00:27:12 <Nafai> ceii_: ah
00:27:24 <Nafai> why is this preferred style?
00:27:28 <hiptobecubic> Nafai, no. Use parens when it's easier to read. The point is that f $ g $ x $ h $ arg  is ugly
00:27:32 <hiptobecubic> Nafai, apparently it isn't.
00:27:39 <ceii_> it's easier to refacter into point-free
00:27:49 <ceii_> also, $ looks like line noise to some people
00:28:09 <hiptobecubic> ddarius, i'm fairly recent myself. I just always hear people complaining about newbies abusing ($), but the usage that they complain about is right in the docs
00:28:12 <ion> (f . g . h) x
00:28:27 <hiptobecubic> f . g . h $ x
00:29:24 <ddarius> hiptobecubic: I think there are two groups.  People who think this is "way better" and people who don't care.
00:30:13 <hiptobecubic> fair enough
00:30:36 <hiptobecubic> That would explain the lack of opposition to the ($) complainers
00:36:19 <hiptobecubic> I still haven't made anything interesting with fix :(
00:37:02 <ddarius> Is that surprising?  It's extremely rare to use fix.
00:37:16 <shachaf> ddarius: I use fix reasonably often.
00:37:22 <cmccann> > fix error
00:37:23 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
00:37:26 <cmccann> that's the primary use for fix
00:37:38 <hiptobecubic> ddarius, i mean i haven't successfully constructed any example that does anything other than _|_
00:37:39 <shachaf> fix $ \loop -> do { ...; when foo loop }
00:37:53 <ddarius> hiptobecubic: Oh, that is more of an issue.
00:38:10 <ddarius> shachaf: I usually name the loop, but occasionally I use fix like that.
00:38:23 <shachaf> Sometimes naming the loop is awkward.
00:38:43 <shachaf> (Well, other than in the argument, that is.)
00:38:47 <ddarius> Oftentimes I want to pattern match.
00:38:52 <ceii_> the trick using fix for aspect-oriented-ish programming is pretty
00:39:06 <ceii_> though I've never seen it used for anything other than the Fibonacci function
00:48:09 <mm_freak_> is there a way to convert a darcs repository to a git repository
00:48:11 <mm_freak_> ?
00:48:21 <ivanm> quite a few
00:48:55 <mm_freak_> any tutorial links?
00:49:16 <ivanm> most use the fastconvert stuff
00:49:23 <ivanm> @google ghc darcs git fastconvert
00:49:25 <lambdabot> http://www.serpentine.com/blog/2010/10/21/how-to-migrate-from-darcs-to-mercurial-or-git/
00:49:25 <lambdabot> Title: How to migrate from darcs to Mercurial or git | teideal glic deisbhéalach
00:49:51 <ceii_> here's how real men do it:
00:49:57 <ski> cmccann : "which are the same thing in linear logic" -- if you use multiplicative disjunction for PO / PEM / LEM, yes
00:50:02 <ski> cmccann : hm, so you're saying that you CPS-translate the code, yes ?
00:50:04 <ceii_> 1) print out the whole darcs commit history
00:50:06 <ski> cmccann : sure, i'd be interested in looking if you pasted
00:50:10 <ceii_> 2) initialize empty git repo
00:50:14 <ski> Nafai : i (usually) prefer `foo x (bar y z)' to `foo x $ bar y x' (if the `foo x'-prefix tends to be repeated "noise" like `return' or `print', i'm more lenient) -- also some times i do `(f . g . h) x' instead of `f . g . h $ x'
00:50:18 <ceii_> 3) redo every commit by hand
00:50:19 <ski> ceii_ : hm, which trick specifically ?
00:50:50 <ceii_> ski: the one where you define a recursive function with an explicit recursive argument
00:50:59 <ivanm> ceii_: so real men == masochists ?
00:51:00 <ivanm> ;)
00:51:01 <ceii_> then instead of tying the knot immediately
00:51:18 <ceii_> you pass it a few other functions that handle specific cases
00:51:29 <ceii_> like return immediately on a known input, etc
00:51:46 <ceii_> when you finally tie the knot you have an optimized and nicely decomposed function
00:51:49 <cmccann> ski: ok, here you go
00:51:57 <hpaste> “C. McCann” pasted “linear logic” at http://hpaste.org/75222
00:52:17 <mm_freak_> ivanm: thanks
00:52:18 <cmccann> not exactly polished or anything
00:52:26 <ivanm> mm_freak_: np
00:52:42 <mm_freak_> i somehow feel bad about converting to git, but people seem to prefer github these days =/
00:52:44 <cmccann> ski, anyway I'm probably heading out for the night in a few minutes
00:53:46 <ivanm> mm_freak_: stuff people!
00:53:55 <ski> ceii_ : ok, i was thinking you had some more substantive "aspective / weaving" example in mind
00:54:08 <ivanm> mm_freak_: unless you think there's a good chance that productivity will increase solely by it being on github, use what _you_ prefer
00:54:19 <ski> (ceii_ : my <http://hpaste.org/10060> is somewhat non-trivial, at least)
00:55:12 <ski> cmccann : ok. ty
00:55:55 <mm_freak_> ivanm: i want to enable people to provide patches easily
00:56:44 <ceii_> ski: nice, thanks for the example
00:58:05 <ivanm> mm_freak_: hub.darcs.net ?
01:00:07 <mm_freak_> ivanm: is that one reliable?
01:00:29 <hiptobecubic> fix doesn't actually determine if the function has reached a fixed point does it? It just applies the function to itself forever until laziness in the argument lets it 'finish' ? Am I understanding it right?
01:00:49 <ivanm> mm_freak_: that's the plan for it; it's new
01:01:08 <mm_freak_> what about darcsden?
01:01:18 <ivanm> this is the new darcsden
01:01:21 <hiptobecubic> I'd expect something like   fix (\f n -> f (sqrt n)) 1e-15    to stop pretty quickly once machine precision is reached
01:01:25 <shachaf> hiptobecubic: fix f is a fixed point of f.
01:01:28 <ivanm> using the darcsden software
01:01:29 <mm_freak_> i see
01:01:51 <ivanm> the announcements for hub.darcs.net talked about that briefly; I think the darcsden maintainer doesn't have much time to hack on the software much any more
01:01:55 <ivanm> so the darcs team is taking over
01:01:57 <mm_freak_> hiptobecubic: that code does not stop
01:01:58 <shachaf> hiptobecubic: sqrt has more than one fixed point.
01:02:12 <shachaf> For example, sqrt 1 = 1, and sqrt 0 = 0
01:02:17 <shachaf> Also, sqrt undefined = undefined
01:02:18 <ski> hiptobecubic : `fix f' only calls `f' once (given laziness)
01:02:42 <ski> hiptobecubic : for something like you're thinking about re numbers, you'd need a lazy number implementation
01:02:42 <mm_freak_> > fix (\r x -> x : r (sqrt x)) 1e-15
01:02:43 <lambdabot>   [1.0e-15,3.162277660168379e-8,1.7782794100389227e-4,1.333521432163324e-2,0....
01:02:49 <mm_freak_> but that's really just
01:02:54 <mm_freak_> > iterate sqrt 1e-15
01:02:55 <lambdabot>   [1.0e-15,3.162277660168379e-8,1.7782794100389227e-4,1.333521432163324e-2,0....
01:04:00 <ski> hiptobecubic : e.g. an improving intervals implementation might work ..
01:04:05 <mm_freak_> a lazy number representation could work, if you only ever ask for a finite portion of the number and limit yourself to operations like sqrt
01:04:40 <hiptobecubic> I was expecting someting like  "stop when f x = x" behavior
01:05:13 <hiptobecubic> so sqrt (1+1e-15)  will stop quite quickly if you iterate sqrt on it
01:05:17 <mm_freak_> > fix (\r x' -> let x = sqrt x' in if x == x' then x else r x) 1e-15
01:05:18 <lambdabot>   0.9999999999999999
01:06:09 <mm_freak_> hiptobecubic: fix (\r x -> r …) always diverges
01:06:41 <mm_freak_> fix only converges, when you have a base case or when you apply a nonstrict function/constructor
01:06:53 <mm_freak_> (:) is nonstrict, so fix (\r x -> x : …) converges
01:06:56 <hiptobecubic> yes, that was what i was wondering
01:07:28 <hiptobecubic> so it it's a fixed point of f, but only if f has a way to break the recursion, otherwise it's just _|_
01:07:42 <shachaf> hiptobecubic: No.
01:07:49 <hiptobecubic> shachaf, no?
01:08:06 <mm_freak_> hiptobecubic: it's always a fixed point
01:08:19 <mm_freak_> hiptobecubic: but you're looking for a different fixed point
01:08:21 <shachaf> Well, maybe if you define "f has a way to break the recursion" as "f is non-strict"
01:08:22 <hiptobecubic> how is fix (\self n -> self $ sqrt n) 2  any different from (last [1..]) ?
01:08:41 <shachaf> hiptobecubic: What? That's yet another different function.
01:08:55 <shachaf> @pl \self n -> self (sqrt n)
01:08:55 <lambdabot> (. sqrt)
01:08:55 <hiptobecubic> sure, but neither will terminate, ever
01:09:03 <mm_freak_> hiptobecubic: fix finds the /least-defined/ fixed-point
01:09:07 <ski> mm_freak_ : an operation like `limit :: Rational -> Rational -> I -> I', where the intended semantics is that `limit lo hi x = max (realToFrac lo) (min x (realToFrac hi))' can be useful to implement interval-halving (without a (visible) base case)
01:09:10 <mm_freak_> for your function the least-defined fixed point is bottom
01:09:11 * shachaf isn't sure what hiptobecubic is getting at.
01:09:41 <mm_freak_> shachaf: he's probably looking for the arithmetical fixed point
01:09:45 <hiptobecubic> shachaf, the function HAS a fixed point, but fix diverges
01:09:56 <shachaf> hiptobecubic: sqrt has three fixed points.
01:09:57 <mm_freak_> hiptobecubic: bottom is also a fixed point
01:10:01 <shachaf> 0, 1, and _|_
01:10:04 <ski> hiptobecubic : `_|_' is the *least* fixpoint
01:10:04 <shachaf> fix finds one of them.
01:10:16 <hiptobecubic> oh
01:10:33 <hiptobecubic> _|_ is a fixed point? Maybe my definition of fixed point is wrong
01:10:54 <hiptobecubic> well.. no i suppose f _|_ = _|_ for all f?
01:10:55 <shachaf> mm_freak_: I think your "if x == x'" thing was only confusing things, because now we have to different things called "fixed points" involved.
01:11:15 <hiptobecubic> unless it's lazy
01:11:19 <shachaf> And fix *is* finding a fixed point in that example, but it's not related to the one that the whole expression is looking for.
01:11:19 <ski> hiptobecubic : that `f' is strict means `f _|_ = _|_' -- then surely `_|_' is a fixed point of `f' ?
01:11:26 <shachaf> hiptobecubic: Non-strict, but yes.
01:11:29 <mm_freak_> hiptobecubic: if your function is strict, then bottom is the least fixed point
01:11:34 <shachaf> fix f where f is strict is _|_
01:11:35 <mm_freak_> hiptobecubic: always
01:11:47 <hiptobecubic> ok, good to remember
01:12:12 <mm_freak_> hiptobecubic: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
01:13:10 <ski> ("stop when f x = x" is fix-point iteration -- which is not what `fix' does)
01:14:18 <hiptobecubic> reading...
01:14:22 <mm_freak_> hiptobecubic: f ⊥ = ⊥ is the definition of a strict function, and from that follows naturally that every strict function has a fixed point in ⊥
01:14:23 <ski> (`fix f' only calls `f' once (assuming laziness), while fix-point iteration would call it `n' times, for some natural number `n')
01:14:50 <mm_freak_> hiptobecubic: in particular fix f is ⊥ when the function f is strict in its first argument
01:15:36 <mm_freak_> > fix (\r x -> x : r (x + 1))
01:15:37 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
01:15:37 <lambdabot>    arising from a use of...
01:15:43 <mm_freak_> > fix (\r x -> x : r (x + 1)) 0
01:15:44 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:16:09 <mm_freak_> that one is not ⊥, because (:) is nonstrict in its second argument, hence \r x -> x : r (x + 1) is nonstrict in its first argument
01:17:11 <ion> Has anyone experimented with extending the type system to specify e.g. which parameters a function will evaluate?
01:18:03 <hiptobecubic> mm_freak_, yes i think i get how it works now
01:18:20 <ski>   (\r x -> x : r (x + 1)) (\_ -> _|_)  =  \x -> x : _|_
01:18:27 <ski>   (\r x -> x : r (x + 1)) (\x -> x : _|_)  =  \x -> x : x + 1 : _|_
01:18:28 <ski>   (\r x -> x : r (x + 1)) (\x -> x : x + 1 : _|_)  =  \x -> x : x + 1 : x + 2 : _|_
01:18:32 <ski>   ...
01:18:47 <ski> (`\_ -> _|_' is `_|_', ignoring `seq')
01:20:03 <mm_freak_> ion: how would that look like?
01:20:03 <ski> when you pass `\_ -> _|_' (the zeroeth approximation of `fix (\r x -> x : r (x + 1))') to `\r x -> x : r (x + 1)', it returns `\x -> x : _|_', which is not the same as `\_ -> _|_' (it's more defined than it)
01:20:17 <ski> and so `\_ -> _|_' is not the fixed point
01:20:43 <mm_freak_> hiptobecubic: anyway, read that page…  it really explains how strictness and fix work
01:20:54 <mm_freak_> and how you can make use of it
01:21:04 <ion> mm_freak: I have no idea. I haven’t experimented with that. :-)
01:21:14 <ski> so `\_ -> _|_' "gets refined" (by laziness magic) to `\x -> x : _|_' (in the *same* call to `\r x -> x : r (x + 1)', not a new call), and we get yet another (better) approximation of the (least) fixed point
01:22:01 <hiptobecubic> ski, that last one was totally unclear. let me read this wikipage first
01:22:02 <mm_freak_> ion: i don't think there is any sensible way to do it
01:22:17 <hiptobecubic> then i'll ask how our function is being refined without making any additional calls
01:23:21 <t7> ion: yeah just pass it in a monad
01:23:31 <mm_freak_> ion: strictness is really a property of functions, so it would be a new function arrow
01:23:39 <t7> wait, not a monad
01:23:45 <mm_freak_> ion: so then you would need kind polymorphism
01:23:51 <t7> make a 'Thunk' type
01:23:58 <mm_freak_> even for something as simple as function application
01:24:20 <mm_freak_> ion: i don't think it's really useful to have that
01:24:35 <t7> mm_freak_: i want termination checking
01:24:49 <mm_freak_> t7: i want that, too
01:24:53 <ion> mm_freak: Yeah, probably.
01:24:58 <mm_freak_> but i don't see it happen in haskell =)
01:25:08 <ski> hiptobecubic : the "refinement" i was talking about above was mostly just a conceptual thing
01:25:27 <ski> (not necessarily related to any operational/procedural semantics)
01:25:33 <mm_freak_> hiptobecubic: what ski calls refinement is explained in that wikipage, too =)
01:25:34 <bartavelle> anybody ever used the frege language ?
01:25:59 <hiptobecubic> i found a book on denotational semantics, but (as with most things) i haven't gotten to it yet
01:26:13 <ski> ion : iirc, one can do strictness annotations in the type signatures, in Clean
01:26:26 <ion> ski: Oh, interesting.
01:26:33 <mm_freak_> t7: i don't think you can add termination checking to haskell sensibly without introducing guarded corecursion and making the whole language termination-checked
01:26:42 <mm_freak_> but then it stops being haskell for the most part
01:27:11 <ski> t7 : seen Charity yet ?
01:27:22 <mm_freak_> ski: one can use uniqueness typing in clean, which enables a set of static checks and optimizations
01:28:29 <mm_freak_> GHC internally performs strictness analysis, which finds strict functions most of the time
01:28:31 <ski> mm_freak_ : yes. but i seem to vaguely recall some notation for strictness annotation as well
01:28:42 <Man> hi
01:29:01 <ski> (perhaps i'm hallucinating, based on some internal things a paper did, i'm not sure)
01:29:25 <ski> lo
01:29:30 <Man> how  u ski?
01:29:53 <mm_freak_> ski: not sure, i have never used Clean, but i have implemented a dependent type system with some of clean's features =)
01:29:57 <mm_freak_> but it's still far from ready
01:30:31 <ski> Man : i'm fine, ty
01:30:45 <ski> Man : do you have any question about Haskell yet ?
01:31:25 <newbie_> hello good people
01:31:47 <newbie_> permit me as a naive curious student who wants to allay his fear of functional programming.
01:32:17 <ski> hi newbie_
01:32:18 <newbie_> What exactly does Haskell solve today? Or what "common problems" can Haskell be used to solve today?
01:32:27 <ion> any of them
01:32:32 <ski> general programming problems
01:32:46 <sheriff> newbie_: What's your language of choice, and how would you answer that question for it?
01:33:12 <newbie_> i just read this, http://www.haskell.org/haskellwiki/Introduction . The quick sort solution in haskell is "intimidating" and I am a graduate of Comp Science with also an experience developing apps in Java
01:33:20 <ion> Haskell is especially suited for producing the first few numbers of the Fibonacci sequence on IRC.
01:33:38 <newbie_> ion: jokes?
01:33:58 <ion> Yes, that was a joke. Although…
01:34:10 <ion> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
01:34:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:34:13 <shachaf> @quote _pizza_
01:34:14 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
01:34:19 <shachaf> > fix$(1:).scanl(+)1
01:34:21 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
01:34:26 <newbie_> ion: was that ran real time?
01:34:43 <ion> It was evaluated by lambdabot, yes.
01:35:04 <newbie_> cool… parsing the syntax though
01:35:20 <ski> @help run
01:35:20 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
01:35:54 <ion> shachaf: Heretic! Everyone agrees the sequence begins with -55, 34.
01:36:00 <t7> newbie_: its a great language to learn if you want to feel superior to stupid dynamically-typed-language-using idiots
01:36:08 <hiptobecubic> newbie_, you'll find that your experience with  languages like java turns out to be a real problem when trying to write haskell code that doesn't suck :(
01:36:09 <sheriff> newbie_: All programming is essentially about learning certain sets of design patterns; Haskell will teach you a whole bunch of new ones
01:36:11 <mm_freak_> newbie_: haskell is useful for anything you might use one of the more common high level languages for, and does most of it much better than the other languages, but it has two known weak spots, too
01:36:13 <ion> t7: Now, now.
01:36:26 <mm_freak_> 1. random program behavior (aka bugs), 2. embedded software
01:36:33 <Ornedan> I've got a bit of a problem getting repa-devil to work on Windows. I can get it to compile by adjusting the .cabal file to point at the headers directory from DevIL's SDK package, but I don't think I've gotten it to link properly
01:36:51 <newbie_> Web apps that flush data into dbs? Desktop Apps?
01:36:59 <shachaf> ion: dude, you think it starts with two integers? What kind of crazy are you?
01:37:18 <newbie_> ion: can you help me understand that fibonacci program please?
01:37:21 <mm_freak_> newbie_: yes
01:37:34 <sheriff> newbie_: Buy and read "The Little Schemer"
01:37:35 <mm_freak_> @ web apps
01:37:50 <hiptobecubic> newbie_, google for  Snap or Yesod or Happstack
01:38:13 <hiptobecubic> newbie_, a recent game that was made in haskell is "nikki and the robots" i think as well
01:38:46 <mm_freak_> newbie_: the fibonacci sequence program utilizies laziness and really just finds that the fibonacci sequence starts with 0, 1 and the rest is repeated addition of adjacent elements
01:38:57 <mm_freak_> newbie_: understanding it more technically requires learning haskell
01:39:03 <newbie_> i can follow this http://www.haskell.org/haskellwiki/Mac_OS_X to setup my mac i hope for haskell
01:39:14 <sheriff> newbie_: How well do you understand recursion, in general?
01:39:16 <mm_freak_> newbie_: normally you would install the haskell platform
01:39:17 <Ornedan> In that when I try to load the module in GHCi and then do "runIL (return ())", it goes "Loading repa-devil-0.3.2 ... linking ... .o-file-path-here: unknown symbol `_ilInit'"
01:39:36 <mm_freak_> newbie_: http://hackage.haskell.org/platform/
01:39:36 <ion> > zipWith (+) [0,1,1,2,3,5] [1,1,2,3,5,8]
01:39:37 <lambdabot>   [1,2,3,5,8,13]
01:39:44 <newbie_> sheriff: i understand recursion quite well. i can produce a recursive fibonacci program in all languages i have mastered
01:39:56 <sheriff> newbie_: But you're having trouble with the Haskell one?
01:40:13 <mm_freak_> sheriff: yes, because that one needs understanding laziness as well
01:40:19 <bartavelle> sheriff, the trouble is most likely to be the syntax
01:40:21 <Ornedan> Where should I put the .dll and .lib files and what should I tell GHC / cabal to get them to linked in properly?
01:40:25 <bartavelle> like ":"
01:40:31 <sheriff> newbie_: In answer to the problem Haskell solves, it solves the problem of every computer science lab in the world writing their own functional toy language
01:40:39 <newbie_> sheriff: i don't know haskell syntax. and have just spent 15mins max reading btw wikipedia and official wiki
01:40:42 <sheriff> newbie_: And also that Miranda wasn't open saws
01:40:44 <ion> newbie: fibs is defined to be a list that begins with 0, 1, followed by zipWith (+) [0,1,…] [1,…] where [0,1,…] is the list itself and [1,…] is the list itself without the first element.
01:41:27 <mm_freak_> > let xs = 0 : map succ xs in xs
01:41:28 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:41:29 <ski> sheriff : except Nijmegen
01:41:36 <sheriff> newbie_: Plus someone needed to come up with an actual use for Category theory
01:41:42 <ski> (and Utrect, i think)
01:41:47 <sheriff> Also have you seen the amount of cool names they can come up with?
01:42:03 <sheriff> Look Ma, Some Nodes, Some Edges, I've gotta Quiver!
01:42:09 <newbie_> fibs (tail fibs) in fibs
01:42:21 <newbie_> this part...
01:42:26 <hiptobecubic> you're missing some key things
01:42:37 <mm_freak_> newbie_: the part is "zipWith (+) xs ys"
01:42:40 <ski> > tail [2,8,5,7,1,4]
01:42:41 <lambdabot>   [8,5,7,1,4]
01:42:43 <EvanR2> why is it that in ghci "import Foo" does not work, where Foo is a module in the current dir
01:42:46 <mm_freak_> > zipWith (+) [1,2,3] [10, 20, 30]
01:42:47 <lambdabot>   [11,22,33]
01:42:47 <hiptobecubic> newbie_, "let x = 1 in x"  is a whole expression
01:42:55 <sheriff> and then there were all those funny Unicode chars missing out left over from Z Notation...
01:42:58 <hiptobecubic> it means what it looks like it should mean
01:42:58 <EvanR2> where does not work means nothing happens and i get no feedback
01:42:59 <ski> `tail' is a function that given a list, gives a list containing all elements but the first element
01:43:10 <mm_freak_> newbie_: zipWith (+) takes two lists and zips them together with the function (+)
01:43:20 <mm_freak_> newbie_: see the example i just wrote
01:43:23 <newbie_> mm_freak_: to produce a new list
01:43:27 <mm_freak_> yes
01:43:33 <Nereid> > zipWith (+) [10,20,30] [5,6,8]
01:43:34 <lambdabot>   [15,26,38]
01:43:38 <mm_freak_> > zipWith (+) [1..] [10, 20..]
01:43:39 <lambdabot>   [11,22,33,44,55,66,77,88,99,110,121,132,143,154,165,176,187,198,209,220,231...
01:43:40 <newbie_> mm_freak_: nice
01:44:20 <mm_freak_> > zipWith (*) [2, 3, 5] [7, 11, 13]
01:44:21 <lambdabot>   [14,33,65]
01:44:26 <newbie_> >[1,3,5,...]
01:44:31 <hiptobecubic> needs a space
01:44:35 <hiptobecubic> > [1..]
01:44:36 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:44:39 <newbie_> doesn't print odd numbesrs?
01:44:46 <Nereid> > [1,3..]
01:44:47 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
01:44:57 <newbie_> > [1,3,5,...]
01:44:58 <lambdabot>   <no location info>: parse error on input `]'
01:45:08 <hiptobecubic> newbie_, you need a space after >  and no , before the ....
01:45:08 <Nereid> two dots, and you can only specify the first two elements of the list.
01:45:15 <Entroacceptor> > [1,1,2,3,5,8,...]
01:45:16 <lambdabot>   <no location info>: parse error on input `]'
01:45:21 <Nereid> (and the last)
01:45:22 <newbie_> Nereid: it should require at least 3 elements to guess the increment
01:45:26 <Nereid> no
01:45:27 <Entroacceptor> > [1,1,2,3,5,8...]
01:45:29 <lambdabot>   A section must be enclosed in parentheses thus: (8 ...)Not in scope: `...'
01:45:29 <Nereid> just two
01:45:43 <Nereid> > [2,6..]
01:45:44 <bartavelle> obviously just two ?
01:45:45 <lambdabot>   [2,6,10,14,18,22,26,30,34,38,42,46,50,54,58,62,66,70,74,78,82,86,90,94,98,1...
01:45:51 <Nereid> > [2,6..30]
01:45:52 <lambdabot>   [2,6,10,14,18,22,26,30]
01:45:54 <Entroacceptor> > [1,1,2,3,5,8..]
01:45:55 <lambdabot>   <no location info>: parse error on input `..'
01:46:03 <Nereid> Entroacceptor: try using a comma
01:46:07 <newbie_> so the fib in haskell takes advantage of this
01:46:25 <mm_freak_> newbie_: it takes advantage of laziness
01:46:29 <mm_freak_> like this one:
01:46:32 <Entroacceptor> > [1,1,2,3,5,8,..]
01:46:33 <lambdabot>   <no location info>: parse error on input `..'
01:46:39 <mm_freak_> > let xs = 0 : map (+ 1) xs in xs
01:46:40 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:46:46 <mm_freak_> xs = [0, …
01:46:54 <Nereid> > map (+1) [3,5,1]
01:46:55 <lambdabot>   [4,6,2]
01:46:56 <ion> newbie: What languages are you familiar with?
01:47:09 <mm_freak_> and the rest is xs with each element incremented by 1
01:47:16 <mm_freak_> so it's [0, 1, …
01:47:24 <newbie_> ion: java
01:47:27 <mm_freak_> and the rest is xs with each element incremented by 2, etc.
01:47:32 <mm_freak_> and the result is [1..]
01:47:42 <ion> > let fibs = a : b : zipWith (+) fibs (tail fibs) in fibs
01:47:43 <lambdabot>   [a,b,a + b,b + (a + b),a + b + (b + (a + b)),b + (a + b) + (a + b + (b + (a...
01:47:46 <Nereid> java :---)
01:48:20 <newbie_> mm_freak_: maybe i should message you. just want to get the fibonacci part and be done with. a good starting point. hard to follow the conversation here (even though i appreciate everyone's enthusiasm to help)
01:48:24 <ion> > let fibs = a : b : zipWith (f :: Expr -> Expr -> Expr) fibs (tail fibs) in fibs
01:48:25 <lambdabot>   [a,b,f a b,f b (f a b),f (f a b) (f b (f a b)),f (f b (f a b)) (f (f a b) (...
01:48:34 <hiptobecubic> newbie_, if you try to evaluate the expression yourself on paper, you'll end up doing it how haskell does it because humans are also lazy.
01:48:59 <mm_freak_> newbie_: i'd essentially repeat what a common haskell tutorial already teaches you, so perhaps you should just go ahead and start reading LYAH…  you can read it online =)
01:49:04 <mm_freak_> @where lyah
01:49:05 <lambdabot> http://www.learnyouahaskell.com/
01:49:20 <newbie_> mm_freak_: oh okay then
01:49:48 <newbie_> finally, do you guys use haskell at work? outside academics? can you point to an app built with haskell.
01:49:53 <ion> newbie: Yeah, LYAH is much recommended. But feel free to ask if anything about it that’s unclear.
01:50:02 <mm_freak_> newbie_: i use it at work for networking applications
01:50:40 <mm_freak_> newbie_: in fact i don't even have an academic degree =)
01:51:15 <mm_freak_> and i can only second ion's remark…  unlike most other language communities, haskell people are happy to help even with the simplest of problems =)
01:51:28 * hackagebot pqc 0.7.0.1 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.7.0.1 (KidoTakahiro)
01:51:44 <mm_freak_> community is one of the major strengths of haskell that is often understated
01:51:47 <newbie_> thanks all. i'll try and setup my mac and see if i can functional language into my skull in the following weeks. (we have to admit fn seems scary at first)
01:52:00 <imeredith_> newbie_: some of the stuff you learn can also be applied to scala, which is sometimes an easier pill for a java-based shop to swallow
01:52:07 <ion> newbie: You might find these pages interesting. http://www.haskell.org/haskellwiki/Haskell_in_industry http://www.haskell.org/haskellwiki/FAQ
01:52:12 <imeredith_> newbie_: although scala isn't very nice compared to haskell for some stuff
01:52:16 <mm_freak_> newbie_: it's not FP that's scary, but haskell can be a bit scary, because it's very different, even from other functional languages
01:52:38 <mm_freak_> newbie_: to get started just install the haskell platform for mac
01:52:45 <mm_freak_> @where hp
01:52:45 <lambdabot> http://hackage.haskell.org/platform/
01:53:08 <newbie_> imeredith_: yeah i noticed. if i was too chose a jvm functional language it'll be Clojure over Scala. I looking at Haskell cos someone @wfaler once called it a perfect language
01:53:39 <mm_freak_> i never liked scala…  they still have the ugly java-ish syntax and most of the beauty of FP/haskell is lost to the java runtime and libraries
01:54:21 <ion> It’s not perfect, but in my completely biased, subjective opinion it sucks less than the other languages i’ve learned so far.
01:54:24 <imeredith_> newbie_: well, scala is probably closer to haskell than clojure is, but yeah, just learn haskell
01:54:36 <Nereid> well neither scala nor clojure are purely functional languages with a nice type system
01:54:38 <Nereid> so
01:54:46 <imeredith_> yeah
01:54:50 <Nereid> quite different
01:54:51 <mm_freak_> isn't clojure non-statically typed even?
01:54:56 <imeredith_> yes
01:55:05 <mm_freak_> ok, then it's not the language for me
01:55:14 <mm_freak_> i can't stand non-static languages
01:55:19 <t7> im working on my own language like haskell, but with a minimal syntax and (hopefully) agda style infix definitions and any case for types/bindings
01:55:28 <Nereid> clojure is pretty lisp-like
01:55:33 <imeredith_> with scala you can do typeclasses and stuff - but you have to fight the typesystem
01:55:52 <imeredith_> well, you can emulate typeclasses anyway
01:56:00 <mm_freak_> t7: have you kept the dependent types?
01:56:10 <t7> no
01:56:19 <Nereid> scala doesn't even look that different from java ???
01:56:21 <newbie_> t7: yet another language?
01:56:24 <t7> i dont think joe average is ready for dependent types
01:56:30 * hackagebot containers-unicode-symbols 0.3.1 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.3.1 (RoelVanDijk)
01:56:55 <imeredith_> Nereid: err, visually or ?
01:57:14 <Nereid> I'm not talking about the syntax.
01:57:15 <merijn> t7: Instead of wasting your time on your own language, implement mixfix for GHC! :p
01:57:34 <t7> and anycase types
01:57:41 <merijn> FWIW, I'll love you forever :p
01:58:06 <imeredith_> Nereid: it has a much more complex type system than java, almost everything is an expression, ADT's can be experessed a lot easier
01:58:31 <Nereid> fair enough
01:58:35 <t7> merijn: i might submit a patch later, if i get bored after lunch or something. It cant take more than an hour todo both
01:58:58 <Nereid> ADTs are something that every language should have.
01:59:07 <imeredith_> Nereid: but it sucks at laziness, has no TCO apart from one case, List.foldRight breaks if the list is to big, thats in the stdlib lol
01:59:23 <merijn> t7: I think the only reason GHC doesn't support mixfix is that no one could be arsed to implement a parser for it...
01:59:32 <Nereid> well I wouldn't expect something running on the JVM to be great at laziness.
01:59:52 <imeredith_> it has something similar to haskells do notation
02:00:02 <Nereid> monads?
02:00:03 <t7> needs some crazy look ahead stuff i guess
02:00:30 <imeredith_> yeah, scala.Option is Maybe
02:00:33 <Nereid> I have to admit, everything I know about scala comes from what I read on wikipedia in the last 2 minutes.
02:01:11 <imeredith_> Nereid: https://github.com/scalaz/scalaz/tree/scalaz-seven read the readme
02:01:39 <Nereid> heh.
02:02:23 <imeredith_> Nereid: the stdlib is broken, you can do List(1,2,3).flatMap(Option(2)) - (flatmap being >>=), scalaz fixes that though List(1,2,3) >>= (Option(2)) wont compile
02:02:36 <ski> > (zipWith (\m n -> reduce (fromIntegral n * a + fromIntegral m * b)) `ap` tail) (let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs)  -- *cough*
02:02:37 <lambdabot>   [1 * a + 0 * b,1 * a + 1 * b,2 * a + 1 * b,3 * a + 2 * b,5 * a + 3 * b,8 * ...
02:03:47 <imeredith_> but the type system sucks, Monad[({type λ[+α]=RWST[F, R, W, S, α]})#λ] -s what you need to use to get the Monad instance for ReaderWriteStateT
02:03:48 <imeredith_> heh
02:05:17 <imeredith_> Nereid: anyway enoguh scala, i am slowly learning haskell, but came into this stuff via java -> scala -> haskell - and at work they let me use scala so i'll continue with it
02:05:23 <mm_freak_> Nereid: don't worry, scala doesn't get nicer than that ;)
02:05:38 <Nereid> mm_freak_: I had little intention of trying scala anyway ;)
02:05:58 <dobblego> scala is a lot better than java, but that's not saying much — stick to haskell if you can
02:05:58 <bitonic> imeredith_: and the people on #scala insisted that implicits are just fine :)
02:05:58 <EvanR2> ill try scala
02:06:13 <mm_freak_> scala is java on steroids
02:06:18 <merijn> imeredith_: Well, some scala experience will probably ease your way into Haskell a bit more than a direct java -> haskell transition would've been :p
02:06:20 <imeredith_> bitonic: implicits are fine, implicit conversion sucks
02:06:30 <mm_freak_> or (very) poor man's haskell
02:06:40 <bitonic> imeredith_: well.  implicit conversion are part of the system, no?
02:06:41 <imeredith_> merijn: well, i dont think i ever would have tried haskell, i was about to learn clojure heh
02:06:42 <Nereid> if only haskell had dependent types :V
02:06:50 <ski> imeredith_ : possibly `Option' is a subtype of `List' ?
02:06:53 <imeredith_> bitonic: im sure you can do bad things in haskell too
02:07:08 <merijn> imeredith_: To be fair Clojure (or any Lisp really) is pretty interesting too
02:07:13 <mm_freak_> Nereid: i doubt that haskell will ever have dependent types
02:07:16 <imeredith_> ski: no, it is an Iterable though - or maybe its the implicit conversion happening
02:07:16 <zomg> imeredith_: easy, just use unsafePerformIO and call IO from 'pure' code ;)
02:07:19 <Nereid> mm_freak_: me too.
02:07:26 <bitonic> imeredith_: but haskell has much stronger guarantees on instances (save evil extensions...)
02:07:51 <dobblego> imeredith_: no, it's because the type signature of List#flatMap is broken for "flexibility" purposes
02:07:57 <imeredith_> oh yeah
02:08:00 <merijn> imeredith_: Personally I'd go with Racket, but if you have some prior investment into Java (at work for example) Clojure would be my goto Lisp to learn :) (after Haskell, obviously ;)
02:08:02 <dobblego> er
02:08:03 <imeredith_> thats right
02:08:04 <dobblego> ski: no, it's because the type signature of List#flatMap is broken for "flexibility" purposes
02:08:27 <bitonic> the language to learn right now is Erlang imo
02:08:37 <EvanR2> merijn: haskell is your 'goto lisp' ? lol
02:08:54 <ski> dobblego : ok
02:08:56 <astry_> bitonic: why?
02:08:59 <mm_freak_> Nereid: also without termination checking dependent types are like masturbating without the payoff
02:09:14 <merijn> EvanR2: Eh, no? That's not what I said at all...
02:09:17 <Nereid> eh.
02:09:17 <EvanR2> oh
02:09:22 <ski> dobblego : ooc, how is the signature declared (in Haskellish syntax, if you prefer) ?
02:09:24 <astry_> mm_freak_: still feels good while you're doing it
02:09:33 <mm_freak_> lol
02:09:36 <EvanR2> yall are gross
02:09:38 <Nereid> I do expect that laziness + dependent types is a difficult combination though, yes.
02:09:40 <merijn> EvanR2: I meant that learning Lisp should wait until after Haskell :)
02:09:54 <mm_freak_> Nereid: laziness is fine
02:09:56 <bitonic> astry_: because it open your eyes for what concerns concurrency.  it's not a nice language, but it's truly different, as much as Haskell
02:09:57 <astry_> i tried learning some clojure
02:09:58 <astry_> it's ok
02:10:04 <mm_freak_> Nereid: they are completely disconnected
02:10:07 <astry_> but the eager evaluation is annoying
02:10:08 <dobblego> data Iterable a = Iterable { {- may throw error -} next :: IO a; hasNext :: IO Bool }; flatMap :: [a] -> (a -> Iterable b) -> Iterable b
02:10:22 <astry_> bitonic: is it different from haskell
02:10:27 <bitonic> astry_: yes, very
02:10:42 <astry_> is it as different from haskell as clojure is?
02:10:51 <bitonic> that's a silly comparison
02:11:10 <mm_freak_> Nereid: only the termination checker needs to be aware of the laziness, or you introduce guarded corecursion (which you really want to introduce anyway)
02:11:14 <bitonic> but it teaches you more than Clojure, imo
02:11:21 <merijn> bitonic: Really?
02:11:28 <Nereid> mm_freak_: well whatever, I need sleep.
02:11:43 <merijn> bitonic: I haven't really programmed Lisp, but when I finally got it, it was pretty enlightening to me
02:11:44 <ski> dobblego : ok
02:11:48 <bitonic> yeah, Clojure is a rehash of very established concepts
02:12:13 <bitonic> merijn: well sure, but those concepts are very "out there" in CS, and have been there for ages
02:12:27 <neothemachine> Hi guys, I have a (probably simple) problem using QuickCheck, I need to produce two numbers with a condition between them (x <= y), any idea? I made a paste for it
02:12:28 <hpaste> neothemachine pasted “Lower bound for QuickCheck arbitrary” at http://hpaste.org/75224
02:12:32 <merijn> bitonic: Oh sure, it's not very new (although the focus on immutability is nice). But there's plenty of people who haven't tried Lisp for which it's still an eye opener
02:12:49 <merijn> bitonic: I suspect you are overestimating the quality of CS education the past two decades...
02:13:16 <bitonic> merijn: I'm not a lisp fan and I think that Erlang is much more relevant to CS now, so I'm going to suggest erlang :)
02:13:25 <imeredith_> we use erlang at work :)
02:13:39 <astry_> i use haskell at work every now and then
02:13:43 <astry_> even though i don't really know it
02:13:47 <astry_> it's still very useful
02:14:06 <astry_> last time i wrote a tool for helping disk recovery when a disk crashed
02:14:34 <astry_> it was fun to make
02:14:43 <astry_> although a little bit excruciating
02:17:18 <ski> dobblego : i've actually pondered type classes `Thin' and `Thick' which would allow you to "mix" two monads when binding ..
02:18:47 <dobblego> ski, (.=<<.) :: (Applicative q, Monad m, Traversable m) => (a -> q (m b)) -> m a -> q (m b) ?
02:19:07 <ski> no, not really
02:19:18 <ski>   class (Monad m,Monad n) => Thin m n where thin :: m a -> n a; joinThin :: m (n a) -> n a; (>>=|) :: m a -> (a -> n b) -> n b; joinThin mna = mna >>=| id; ma >>=| anb = joinThin (anb `liftM` ma)
02:19:23 <ski>   class Thin m n => Thick m n where thick :: n a -> m a; joinThick :: n (m a) -> m a; (|>>=) :: n a -> (a -> m b) -> m b; joinThick nma = nma |>>= id; na |>>= amb = joinThick (amb `liftM` na)
02:19:37 <ski> with three example instances being
02:19:43 <ski>   instance MonadPlus n => Thin [] m; instance MonadPlus n => Thick [] m
02:19:44 <ski>   instance Thin (State sr) (Reader sr); instance Thick (State sr) (Reader sr)
02:19:49 <ski>   instance Num n => Thin [] (Const n)
02:20:45 <ski> (i also wrote down a couple of laws for the operations (apart from the default implementations), which corresponds to the monad laws)
02:22:14 <ski> (one of those laws is `thin . thick = id' -- but no `thick . thin = id' law here)
02:22:18 <dobblego> that looks handy
02:22:32 <dobblego> related, I had to write MonadHoist today
02:22:55 <ski> the `Thin [] (Const n)' could be used for nondeterminsm, where, in the end, you're really just after counting the number of solutions
02:24:23 <mm_freak_> is there a library for secure memory, where i can store secrets (passwords, keys, etc.)?
02:24:33 <latro`a> uh
02:24:43 <latro`a> oh, I'm silly, was way up in the scrollback
02:24:48 <ski> (your `(.=<<.)' one looks like `m' being a monad in the kleisli kategory of `q')
02:24:56 <EvanR2> mm_freak_: is there a library for that in not haskell?
02:24:59 <latro`a> was just gonna say, ski was saying that \_ -> _|_ is _|_ up to seq, but doesn't it not have anywhere near every type?
02:25:08 <latro`a> for example it doesn't have type Int
02:25:29 <latro`a> (eh, my 5-am polymorphism phrasing is poor, forgive me)
02:25:42 <ski> latro`a : `it' being ?
02:25:58 <latro`a> (\_ -> undefined) :: Int
02:26:01 <latro`a> ^type error
02:26:03 <latro`a> undefined :: Int
02:26:04 <ski> yes
02:26:05 <latro`a> ^no type error
02:26:16 <mm_freak_> EvanR2: in not-haskell it's probably easy to implement
02:26:26 <mm_freak_> ok, i'll implement my own library then
02:26:36 <merijn> mm_freak_: Define secure?
02:26:36 <ski> of course, when comparing `\_ -> _|_' and `_|_', i was assuming some single given type which both these shared
02:26:43 <latro`a> ah
02:26:45 <latro`a> carry on then
02:26:46 <ski> e.g. `Int -> Bool'
02:26:47 <merijn> mm_freak_: Seems impossible to implement
02:26:54 <EvanR2> where is secure memory?
02:26:59 <mm_freak_> merijn: guaranteed not to be implicitly duplicated and wiped at the end
02:27:00 <EvanR2> is that a new feature in linux
02:27:10 <ski> (where `a -> b', with `a' and `b' parametric, is the most general choice)
02:27:23 <mm_freak_> merijn: so that swap is my only enemy
02:27:28 <merijn> mm_freak_: You can't guarantee wiping at the end, because what if your program gets killed nastily
02:27:46 <EvanR2> process finalizer ;)
02:27:50 <mm_freak_> merijn: guaranteed for grateful shutdowns
02:27:56 <mm_freak_> grateful?
02:27:59 <mm_freak_> graceful
02:28:00 * ski tries to recall the most common specific type used for `(.=<<.)'
02:28:02 <merijn> mm_freak_: The OS should take care of wiping any page before it gets handed to any process anyway
02:28:15 <merijn> mm_freak_: That's why your swap should be on an encrypted disk :)
02:28:38 <mm_freak_> merijn: i know, but still i'd like to provide as much memory security as i can for this application
02:29:07 <merijn> mm_freak_: But no, I don't think such a thing exists yet
02:29:11 <mm_freak_> root should have to watch while the application is running to get the in-memory key
02:29:30 <merijn> mm_freak_: I'm curious what you're doing that needs this? :)
02:29:42 <mm_freak_> merijn: in-memory encryption keys
02:30:17 <merijn> mm_freak_: Yeah, that I suspected. But I meant higher level, what application are you writing that has you doing your own crypto :)
02:30:45 <mm_freak_> merijn: it's an application for a customer, but you may take a simple password manager as a good example =)
02:30:54 <bartavelle> I am doubtful of such a scheme, it is easy for root to retrieve your keys in any case if it wants to
02:31:10 <mm_freak_> bartavelle: of course
02:31:31 <bartavelle> you should make sure you don't core dump and don't swap first
02:31:46 <mm_freak_> i can't, because i'm not root
02:31:50 <bartavelle> exactly
02:32:13 <bartavelle> so you can't protect against root in any case, and can't protect against physical attacks because you are not root
02:32:45 <dmos> stream-fusion pkg on hackage uses the ghc flag -fno-method-sharing which has been removed in 7.2. What is the alternative, or what are the consequences of not specifying it?
02:32:47 <EvanR2> security is impossible in general lets all go home
02:32:48 <bartavelle> well you can check what the limit for coredump is and not run if it is not what you expect
02:33:01 <bartavelle> perhaps the same for the swap ?
02:33:23 <mm_freak_> i just don't want to excuse myself as easy as that and do nothing…  that's not my style =)
02:33:27 <mm_freak_> i want to do what is possible
02:33:50 <bartavelle> what do you want to protect against ? if it is physical attacks this is doable
02:33:53 <EvanR2> do nothing <- just rebrand that as 'taking the path of peace'
02:33:55 <bartavelle> if it is evil root it is not
02:34:14 <bartavelle> (by physical I mean examination of the disk)
02:34:17 <EvanR2> its not possible to protect against physical attack
02:34:42 <bartavelle> depends on the kind
02:34:44 <ski> hm .. `concatMapA', i think
02:34:59 <bartavelle> if your computer is compromised before you run the things you want to hide, this is obvious
02:35:09 <mm_freak_> bartavelle: well, there is another scenario
02:35:25 <mm_freak_> the key is used for a short period of time and network attacks happen later
02:35:38 <mm_freak_> so when an attack is successful, the key should not be in memory anymore
02:36:01 <bartavelle> not sure how you can do this with a GC runtime
02:36:10 <mm_freak_> bartavelle: by using Ptr
02:36:16 <bartavelle> ah true
02:36:34 <mm_freak_> StablePtr in fact
02:38:52 <mm_freak_> anyway, i guess i'll do it without this memory security first, but provide the abstraction needed
02:39:02 <mm_freak_> then i can change the abstration to actually do memory security transparently
02:39:17 <mm_freak_> all hail RankNTypes
02:39:46 <maukd> FrankNTypes
02:39:56 <EvanR2> lol
02:41:04 * killy9999 tries to understand ST monad
02:41:06 <mm_freak_> My name is Types, Rank N. Types.
02:41:16 <killy9999> I think that I understand how to use it
02:41:19 <maukd> killy9999: ST provides mutable variables
02:41:29 * hackagebot regex-compat-tdfa 0.95.1.2 - Unicode Support version of Text.Regex, using regex-tdfa  http://hackage.haskell.org/package/regex-compat-tdfa-0.95.1.2 (KidoTakahiro)
02:41:47 <mm_freak_> killy9999: that's sufficient to use it
02:41:53 <killy9999> Haddock for ST says: "This library provides support for strict state threads"
02:41:59 <maukd> heh, yeah
02:42:08 <killy9999> I have problems with meansing of last three words
02:42:15 <maukd> it's using "thread" in a way no one else does
02:42:22 <killy9999> I mean I know what each of them means separately :D
02:42:32 <maukd> so ... ignore "threads" :-)
02:42:37 <killy9999> OK
02:42:39 <killy9999> let me guess
02:42:59 <killy9999> this "thread" has some black-magic background in category theory?
02:43:12 <b__> if I were to use a certain record subtype name (say "name :: Name") repeated in multiple data declarations, could I use the out-of-the-box getter "name" on all those different data types?
02:43:17 <maukd> I doubt it
02:43:40 <maukd> b__: no, you'd get "duplicate definition" errors
02:43:47 <killy9999> ok, but the thread doesn't mean any sort of concurency or parallelism, right?
02:43:49 <b__> that's a shame
02:43:52 <maukd> killy9999: correct
02:43:53 <b__> but I can see why
02:44:00 <maukd> :t runST
02:44:01 <lambdabot> forall a. (forall s. ST s a) -> a
02:44:07 <int-e> I disagree with mauke ... its computational model is a bona fide, but isolated, thread of execution with local memory.
02:44:12 <maukd> killy9999: the "thread" is the s parameter
02:44:16 <maukd> more or less
02:44:30 <killy9999> Well, that s parameter is confusing
02:44:37 <killy9999> just what exactly is this?
02:44:38 <maukd> it ties the whole thing together
02:44:42 <killy9999> I mean what type does it have?
02:44:49 <maukd> none
02:44:59 <killy9999> :/
02:45:05 <maukd> I think of it like this ...
02:45:10 <maukd> :t newSTRef
02:45:11 <lambdabot> forall a s. a -> ST s (STRef s a)
02:45:20 <maukd> all operations in ST have an s parameter
02:45:28 <maukd> this is like a hole
02:45:57 <maukd> combining multiple ST actions (e.g. with a 'do' block) makes the holes line up
02:46:02 * killy9999 looks at the source of ST
02:46:09 <maukd> and runST pulls a thread through the hole
02:46:20 <maukd> (that's a literal thread)
02:46:29 <maukd> this makes sure no ST action can escape
02:46:29 <killy9999> does the strictness come from the usage of (# ... #) ?
02:46:49 <maukd> I don't even know which strictness it's referring to
02:46:49 <killy9999> escape?
02:46:51 <b__> it would be great though to be able to use the same "getter" for different kind of data types
02:46:52 <ski> killy9999 : "state thread" means basically the same as "state transformer" (*not* "state monad transformer", note)
02:46:53 <EvanR2> lets say i have a type containing two different values of type X, how can i easily 'wrap' X somehow to make sure i dont use the worng X in the wrong places?
02:47:14 <maukd> EvanR2: newtype?
02:47:20 <killy9999> return x = ST (\ s -> (# s, x #))
02:47:34 <maukd> killy9999: the source doesn't help me
02:47:40 <killy9999> OK
02:47:46 <killy9999> doesn't help me either...
02:48:01 <EvanR2> maukd: ... and to avoid duplicating stuff unwrap it later?
02:48:02 <ski> killy9999 : a function of type `MyState -> MyState' is a state transformer (a function that transforms an input state to an output state) -- a function of type `MyState -> (MyState,MyResult)' is a state transformer with an auxilary result
02:48:22 <maukd> killy9999: the main difference between ST and something like IO that also provides mutable variables is the existence of runST
02:48:45 <maukd> runST lets you give computations that use mutable variables internally a pure interface
02:48:53 <killy9999> ski: thanks, that helps
02:48:57 <ski> killy9999 : "thread" is here used in the sense of "a thread/sequence of state values, all coming strictly (totally) ordered wrt each other"
02:49:21 <maukd> but to do that it has to make sure that callers can't know that you're using side effects internally
02:49:36 <maukd> otherwise fun stuff can happen
02:50:03 <maukd> for example, if you could return an STRef from one runST, you could then use it in another
02:50:16 <ski> killy9999 : if you have two different `runST (...)' computations in your program, then inside each of those, the state operations will be fully sequences, but when you compare one state thread with the other, there'll be no ordering imposed (apart from ones induced by data dependencies/flow)
02:50:27 <int-e> ski: and that's what a thread of execution is. it's just that a lot of other stuff usually associated with threads - most notably, communication with other threads - is not there, and can't be there, because the core idea is that runST has to be pure.
02:51:03 <maukd> :t runST (newSTRef 'x')
02:51:04 <lambdabot>     Inferred type is less polymorphic than expected
02:51:04 <lambdabot>       Quantified type variable `s' escapes
02:51:04 <lambdabot>     In the first argument of `runST', namely `(newSTRef 'x')'
02:51:21 <killy9999> OK, I guess I'm content with that level of understanding
02:51:27 <ski> killy9999 : there is actually a way to split a State Thread (a value of type `ST s A', for some type `A') into several independent pieces, but it's unsafe (by using it, you're promising the language processor that you *know* they are independent)
02:51:29 <maukd> :t runST (newSTRef 'x' >>= readSTRef)
02:51:30 <lambdabot> Char
02:51:56 <maukd> (I can get the Char out, but not the STRef)
02:52:05 <killy9999> maukd: thanks
02:52:21 <int-e> :t runST (newSTRef ())
02:52:22 <lambdabot>     Inferred type is less polymorphic than expected
02:52:22 <lambdabot>       Quantified type variable `s' escapes
02:52:22 <lambdabot>     In the first argument of `runST', namely `(newSTRef ())'
02:52:25 <killy9999> One day I'll make an attempto to understand >>= implementation for ST
02:52:25 <int-e> :)
02:52:31 <maukd> I wonder
02:52:34 <int-e> (sorry for the repeat)
02:52:36 <maukd> does s count as a phantom type?
02:52:41 <int-e> yes
02:53:14 * ski . o O ( `runST_hmm :: (forall s. Typeable s => ST s a) -> a' )
02:53:17 <maukd> it exists merely to tag values that belong to the same "thread"/computation
02:56:36 <ski> maukd,killy9999 : "lazy ST example" by monochrom in 2012-02-18 (and two annotations in 2012-05-26) at <http://hpaste.org/63925> is an example of what you can do with lazy `ST', but which has different behaviour in strict `ST'
02:57:55 <maukd> oh, safeInterleaveST
03:02:52 <ski> killy9999 : you could check out "Lazy Functional State Threads" by Simon L. Peyton Jones,John Launchbury in 1994-06 under <http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html#monads>
03:05:05 <killy9999> ski: thanks, I'll add it to my list of papers to read (which unfortunatelly is very long)
03:05:07 <ski> (the "State in Haskell" paper there might also be interesting)
03:05:32 <ski> maukd :)
03:06:30 * hackagebot pqc 0.7.1 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.7.1 (KidoTakahiro)
03:06:31 <neothemachine> hmmm, strange, when I run a quickcheck with -xc, I always get "*** Exception (reporting due to +RTS -xc): (THUNK_STATIC), stack trace: Main.main" at the end, although all tests pass
03:06:31 <ski> int-e : *nod*
03:07:03 <neothemachine> and if I don't have -xc, there's no error
03:11:30 * hackagebot cabal-rpm 0.6.3 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.6.3 (JensPetersen)
03:20:02 <mm_freak_> hmm, i'm encoutering a serious problem with secure memory in haskell
03:20:21 <mm_freak_> although it's possible to /keep/ it secure using StablePtr, it's hard to construct it in the first place
03:20:41 <mm_freak_> i guess it only works for certain types like byte arrays
03:20:56 <nevrenato> Helloo, I have a problem with instances constrains, can somebody help me ?
03:21:12 <ivanm> nevrenato: our ability to help you depends on the actual problem :)
03:21:17 <mm_freak_> nevrenato: sure, just ask your question
03:21:26 <mm_freak_> and what ivanm said =)
03:24:46 <nevrenato> wow thx :)….the problem is that a have some class X a b c, and a class Y a b c, when generating a instance from Y I need that one of the type variables belongs to the class X…Something like this…. instance (X a b c) => Y a' b c'…Hope I'm clear enough :)
03:25:05 <hiptobecubic> b__, you can make a typeclass  (sorry if someone has answered you already, i'm just scrolling through)
03:25:46 <ivanm> nevrenato: can you give a more concrete example?
03:26:22 <ivanm> but in general having "all instances of Foo are instances of Bar" can be problematic
03:26:29 <ivanm> *are automatically instances of Bar
03:26:32 <hiptobecubic> b__, it's not perfect because in the records themselves you need unique names. fooGetter, barGetter, whatever. But then make a typeclass HasGetter and an instance for each
03:27:34 <EvanR2> mm_freak_: maybe you need to write some C code
03:28:45 <hiptobecubic> ivanm, i thought with instances it wasn't so bad. you just don't want to make the class definition include that restraint because of overlapping instances
03:29:03 <hiptobecubic> *automatically* overlapping instances anyway
03:29:19 <ivanm> hiptobecubic: well, having something like "instance (Show a) => Printable a where printIt = show" means you can't override it, etc.
03:30:21 <hiptobecubic> ivanm, but you can never 'override' it after the instance is already declared. You can't define a new instance of Ord Int for example.
03:30:26 <hiptobecubic> that's normal
03:30:49 <ceii_> hiptobecubic, but in that case you can't define *any* other instance of Printable
03:30:55 <merijn> Where do I submit suggestions for new Prelude/stdlib functions?
03:30:56 <ceii_> at least not without OverlappingInstances
03:31:13 <ceii_> merijn: reddit
03:31:31 <ivanm> merijn: libraries@
03:31:42 * merijn wants "maxBy :: Ord o => (a -> o) -> a -> a -> a"
03:32:19 <hiptobecubic> ceii_, you can if 'a' is not an instance of Show, no?
03:32:34 <ivanm> hiptobecubic: no, you can't
03:32:34 <ceii_> hiptobecubic: no, that's not how the instance resolution works
03:32:52 <hiptobecubic> Then what does "instance (Show a)" do at all?
03:32:57 <ivanm> I think default instances/templates will let you have something like this _and_ be overridable when you need them to
03:32:58 <ceii_> it's purely guided by the structure of the instance, so in this case "Printable a" matches everything
03:33:11 <ceii_> afterwards, if a isn't an isntance of Show, you get an error
03:33:14 <ivanm> hiptobecubic: the "Show a" bit is discarded at run-time
03:33:22 <hiptobecubic> ohhhhhhhhh yes i have this backwards don't i
03:33:31 <hiptobecubic> you *do* want to do it class based, not instance based
03:33:42 <ivanm> merijn: I think having it generalised somehow so that you could apply it to other functions like minBy as well
03:33:44 <nevrenato> ivanm , hiptobecubic , ceii_  :  I'm confused :)
03:33:49 <hiptobecubic> nevrenato, hold on
03:33:58 <ivanm> nevrenato: tell us exactly what you want to do, not some abstract version
03:34:04 <merijn> ivanm: I guess it's a variation of "on"?
03:34:05 <merijn> :t on
03:34:06 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:34:07 <ivanm> merijn: yeah
03:34:28 <byorgey> merijn: to libraries@haskell.org
03:34:36 <ceii_> :t max `on` snd
03:34:37 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> b
03:34:48 <merijn> ceii_: No, because on returns the result of snd
03:34:51 <ivanm> ceii_: yes, but that doesn't get you the `a'
03:34:57 <byorgey> yeah, at first I thought it was just  \f -> max `on` f, but it isn't
03:34:58 <ceii_> yes, just noticed that
03:35:01 <merijn> Whereas I want "max `on` fst" but with the original value
03:35:03 <nevrenato> ivanm:  I want that one of the type variables of a specific instance, belongs to a specific class
03:35:05 <maukd> :t maximumBy
03:35:06 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:35:19 <ivanm> nevrenato: can you be more specific?
03:35:20 <nevrenato> ivanm:  Like instance (Show a) => Printable a
03:35:23 <ivanm> as an actual use case?
03:35:28 <ivanm> nevrenato: yeah, that's bad
03:35:30 <merijn> maukd: Yeah, but that means first converting to lists. I sorta expected something like maxBy to exist
03:35:32 <nevrenato> ivanm:  But imagine that
03:35:46 <nevrenato> ivanm:  show has two types (Show a b)
03:35:47 <ivanm> nevrenato: is that for _all_ instances or a specific instance?
03:35:53 <hiptobecubic> nevrenato, you want to put the restraint on the class declaration, not the instance i think
03:36:02 <ivanm> e.g. class (Show a) => Printable a where printIt :: a -> String; printIt = show
03:36:06 <hiptobecubic> class (Show a) => Printable a
03:36:11 <ivanm> ^^ only Show-able values allowed, but you can override
03:36:15 <hiptobecubic> right
03:36:45 <hiptobecubic> So the class declaration says "All things of class printable are also of class show and here is a possible way to show them"
03:37:03 <hiptobecubic> Your instance declaration says "HERE IS HOW ALL PRINTABLES WILL BE SHOWN. THE END."
03:37:10 <merijn> I guess a generalisation would be "foo :: (a -> a -> a) -> (b -> a) -> b -> b -> b" so you can do "max `foo` fst" and "min `foo` fst", etc
03:37:15 <merijn> :t by
03:37:15 <lambdabot> Not in scope: `by'
03:37:36 <merijn> I'm hereby claiming the name "by" for the operator "max `by` fst" :)
03:37:54 <ceii_> I'm feeling something very wrong about this operator
03:37:56 <ivanm> merijn: yes, now work out how to define it so that max `foo` by works
03:37:56 <hiptobecubic> don't we have `on` for this?
03:38:03 <ivanm> hiptobecubic: compare the types
03:38:09 <merijn> hiptobecubic: Nope
03:38:17 <ivanm> @type on
03:38:18 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:38:28 <hiptobecubic> ah
03:38:36 <ivanm> well, it's a generalisation I suppose...
03:38:42 <hiptobecubic> so it's on, but specific
03:38:47 <ivanm> merijn: I can't see how max `by` snd would work though
03:38:52 <ivanm> unless you required Eq
03:38:57 <merijn> ivanm: Me neither :\
03:38:58 <nevrenato> I'm trying to make on paper a more specific example to give to you :)
03:39:06 <merijn> ivanm: One problem at a time ;)
03:39:10 <ivanm> merijn: let's blame the definition of max and min :p
03:39:22 <hiptobecubic> max by snd doesn't make sense
03:39:30 <maukd> :t ?maxBy (comparing snd)
03:39:31 <lambdabot> forall t a b. (?maxBy::((a, b) -> (a, b) -> Ordering) -> t, Ord b) => t
03:39:41 <merijn> hiptobecubic: It makes sense, it's just not implementable without Eq
03:39:52 <maukd> :t ?maxBy (comparing ?snd)
03:39:53 <lambdabot> forall t b a. (?maxBy::(b -> b -> Ordering) -> t, ?snd::b -> a, Ord a) => t
03:39:58 <merijn> :t comparing
03:39:59 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
03:40:32 <hiptobecubic> merijn, you mean Ord?
03:40:34 <merijn> I guess what I want is a generalisation of comparing?
03:40:42 <ivanm> merijn: you could do it max/min if you created an auxiliary type with a custom Ord instance
03:40:48 <ivanm> but it then means it doesn't work for general functions
03:41:20 <merijn> :t max
03:41:22 <lambdabot> forall a. (Ord a) => a -> a -> a
03:41:37 <maukd> :t let maxBy cmp a b = case cmp a b of LT -> b; _ -> a in maxBy
03:41:38 <lambdabot> forall t. (t -> t -> Ordering) -> t -> t -> t
03:42:10 <maukd> > let maxBy cmp a b = case cmp a b of LT -> b; _ -> a in maxBy (comparing snd) (1, 2) (3, 1)
03:42:11 <lambdabot>   (1,2)
03:42:14 <hiptobecubic> ;t maximum . map snd
03:42:17 <hiptobecubic> :t maximum . map snd
03:42:18 <lambdabot> forall a b. (Ord b) => [(a, b)] -> b
03:42:26 <hiptobecubic> hmm i see
03:42:42 <merijn> I guess "with :: Ord a => (a -> a -> a) -> (b -> a) -> b -> b -> b" could work?
03:43:05 <frerich> merijn: I think the last 'b' should be an 'a', no?
03:43:11 <nevrenato> ivanm, hiptobecubic, merijn : I will restart with a smaller question :  class (X a b c) => Y d b e .  Is this haskell valid or good programming ? By this i mean having type variables not used after, the constraint ?
03:43:20 <merijn> frerich: No, then I'd just have "on"
03:43:23 <hiptobecubic> frerich, no
03:43:27 <ivanm> nevrenato: it depends on what you want
03:43:37 <hiptobecubic> look at the thing i made, you want the whole tuple back at the end right?
03:43:40 <merijn> frerich: (Well, a limited version of on)
03:43:45 <ceii_> nevrenato, no, it's not valid syntax
03:43:53 <ceii_> you can't put a constraint on unused variables
03:43:55 <ivanm> generally when you have MPTCs though, you want either FD's or TF's
03:44:06 <quicksilver> nevrenato: what would it mean?
03:44:17 <quicksilver> how can you constrain unmentioned variables?
03:44:30 <hiptobecubic> they automatically pass :)
03:44:31 <frerich> merijn: but as it is, couldn't the function only return either of the two 'b's it's given?
03:44:36 <EvanR2> FD? TF?
03:44:39 <quicksilver> the only think I could imagine it meaning is that there is an instance X a b c for all a,b,c
03:44:42 <merijn> frerich: Yes
03:44:54 <nevrenato> I'm constraining b to the class X.. but the class X has 3 type variables not just one
03:45:01 <frerich> merijn: Ok then I will crawl back into my hole because I must be missing the point :-]
03:45:18 <hiptobecubic> nevrenato, i see what you want to do..
03:45:21 <merijn> frerich: The discussion started with me wanting/needing "maxBy" and then someone suggested generalising so you could get minBy, etc. too
03:45:26 <nevrenato> good :D
03:45:55 <ivanm> nevrenato: do you have an actual use case for this?
03:45:56 <hiptobecubic> ceii_, can't a and c just take whatever possible types that make it work in this case?
03:45:58 <ivanm> or just theorising?
03:45:58 <merijn> frerich: I have two tuples which are only comparable in the first element and I want the max of them, i.e. "maxBy fst x y"
03:46:26 <hiptobecubic> but the whole tuple
03:46:28 <merijn> frerich: Which is kinda like on, but on throws away the second element (which happens to be the one I care about)
03:47:05 <nevrenato> ivanm:  at this moment i'm more theorising :), and trying to learn about this to check for solutions for a particular problem that i ahve
03:47:10 <hiptobecubic> :t sortBy
03:47:11 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:47:26 <ivanm> merijn: generalisation: the function needs to return a data WhichValue = FirstValue | SecondValue
03:48:01 <ivanm> you could then use compare with an Ordering -> WhichValue function
03:48:17 <maukd> :t let foo sel cmp a b = sel (cmp a b) a b in foo
03:48:18 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> (t1 -> t2 -> t) -> t1 -> t2 -> t3
03:48:20 <ivanm> nevrenato: well, if you have an actual problem we might be able to suggest a better way of doing it
03:48:41 <merijn> ivanm: Yeah, but then I'd end up having more boilerplate than just implementing things myself (my current solution), I just figured I couldn't be the only one ever wanting/needing maxBy/minBy
03:48:49 <nevrenato> ivanm : ok i will try to expose it next :)
03:48:50 <typoclass> > head $ sortBy (comparing fst) [(3,"lol"), (7,"cat")] -- not sure what's being talked about, but maybe this has to do with it
03:48:50 <lambdabot>   (3,"lol")
03:49:04 <merijn> Although I don't even know if generalising beyond maxBy/minBy gets you anything useful
03:49:10 <maukd> :t let foo sel cmp a b = sel (cmp a b) a b in foo (\p a b -> case p of LT -> b; _ -> a)
03:49:11 <lambdabot> forall t. (t -> t -> Ordering) -> t -> t -> t
03:49:14 <ivanm> merijn: I figure a generalised solution - if it's easy to use - would be more useful and more likely to be used
03:50:07 <maukd> :t let foo sel cmp a b = sel (cmp a b) a b; maxBy = foo (\p a b -> case p of LT -> b; _ -> a) in maxBy (comparing snd) ("x", 1) ("a", 2)
03:50:08 <lambdabot> forall b. (Ord b, Num b) => ([Char], b)
03:50:13 <maukd> > let foo sel cmp a b = sel (cmp a b) a b; maxBy = foo (\p a b -> case p of LT -> b; _ -> a) in maxBy (comparing snd) ("x", 1) ("a", 2)
03:50:14 <lambdabot>   ("a",2)
03:50:16 <typoclass> uhm, or s/head $ sortBy/maximumBy
03:50:49 <maukd> @pl \sel cmp a b -> sel (cmp a b) a b
03:50:49 <lambdabot> flip flip id . ((flip . (ap .)) .) . flip flip id . (liftM2 flip .) . (.) . (.)
03:51:11 <ivanm> actually, are there any cases you would want some generalised version that takes a function that isn't based on Ord?
03:51:38 <ivanm> merijn: I suppose if you just have maxBy, then there's the Down type (whatever it ended up being called) that flips the Ord instance...
03:51:39 <merijn> ivanm: Well, Eq's might be one? But I think Ord is the only sensible constraint
03:51:45 <ivanm> yeah
03:52:13 <merijn> ivanm: And I doubt there's many more Ord uses beyond maxBy/minBy
03:52:45 <ivanm> yeah
04:03:12 <fmap> Are there any papers/articles/blogposts/talks about how to design DSL terms the right way™? I'm specifically interested in free-monad-based DSLs.
04:03:28 <edwardk> Woot. http://imgur.com/bCvTL
04:04:11 <edwardk> I now have a couple hundred of those stickers.
04:04:18 <merijn> Hmm, sometimes GADTs make me sad :(
04:04:52 <merijn> Having a top level function compiles, moving it to a where clause suddenly causes the typechecker to complain :(
04:05:31 <EvanR2> type sig?
04:13:28 <killy9999> I;m doing some tests using QuickCheck and they fail because of numeric precission, eg. I get 3.14158 instead of 3.14159
04:13:40 <killy9999> is there any built in functon to deal with this?
04:13:46 <killy9999> or should I just make my own?
04:14:17 <EvanR2> floating point strikes again
04:14:23 <killy9999> yup
04:14:23 <maukd> "deal with this" how?
04:14:35 <EvanR2> seems like your test is failing
04:14:39 <killy9999> maukd: by allowing my to provide a tolerance value
04:14:42 <EvanR2> fix the code heh
04:15:00 <quicksilver> instead of testing for a == b
04:15:09 <quicksilver> test for abs (a - b) < epsilon
04:15:15 <killy9999> EvanR2: I want to get 13.692025614413383, but I get 13.692025614413382
04:15:22 <killy9999> I wouldn't call that a failure
04:15:28 <quicksilver> where epsilon is something you have to work out.
04:15:41 <killy9999> quicksilver: yeah, I know how to do this
04:15:57 <killy9999> my question is, is there already such a function built into QC?
04:15:57 <quicksilver> 10^-12 should be comfortable for Doubles in that general range
04:16:10 <killy9999> I don't want to reinvent the wheel
04:16:13 <quicksilver> not that I know of.
04:16:16 <killy9999> OK
04:16:18 <quicksilver> == isn't built into QC either
04:16:25 <quicksilver> you're just using a standard ==
04:16:38 <quicksilver> (and many people would argue that == should not be defined for floating point types)
04:16:44 <killy9999> I already reinvented Data Providers, why not reinvent this one
04:17:02 <quicksilver> always reinvent your own wheel and paint it red.
04:17:05 <quicksilver> it will go faster.
04:17:32 <certainty> i see a red wheel, and i want to paint it black
04:17:32 <int-e> quicksilver: there's too much fuzz about NaN :)
04:17:52 <quicksilver> :)
04:18:52 <EvanR2> i could not forsee this thing happening to you
04:19:40 <certainty> exactly :)
04:20:45 <EvanR2> i just got pissed pasting yet another template haskell to derive safecopy... and i put SafeCopy in the deriving clause on a newtype
04:20:54 <EvanR2> it told me ERROR use GeneralizedNewtypeDeriving
04:20:57 <EvanR2> i did, it worked
04:20:58 <EvanR2> wtf
04:21:14 <killy9999> cd /dane/uczelnia/projekty/wavelet-hs
04:21:14 <killy9999> irssi
04:21:55 <killy9999> sorry, having some screen errors :/
04:23:40 <merijn_> edwardk: There's no Map lenses in lens?
04:25:02 <edwardk> merijn: 'at'
04:25:15 <edwardk> merijn: its exported by Control.Lens
04:26:06 <edwardk> there is also traverseAt, traverseMin and traverseMax, along with itraversed
04:26:10 <edwardk> all of those work on maps
04:26:13 <edwardk> (or intmaps)
04:26:34 <edwardk> and at, traverseAt, and itraverse all work on HashMap too
04:26:35 <merijn> edwardk: ok (I'm mostly working by your operator cheat sheet)
04:26:48 <edwardk> the operator cheat sheet just has the infix operators
04:27:01 <edwardk> it doesn't have the huge pile of stock lenses, etc.
04:28:56 <t7> grrr
04:28:59 <edwardk> i should probably put up a list of 'provided lenses/traversals/folds' as well
04:30:00 <merijn> edwardk: So far I just get by by asking random people and you :p
04:32:46 <killy9999> why can't I provide specialized type signature when creating instance of a typeclass?
04:32:58 <killy9999> I know that new GHC provides some new extension that allows that
04:33:15 <killy9999> but what is the rationale behind disallowing this?
04:33:40 <edwardk> i have this vision of merijn stopping random homeless people on the street to ask them lens questions
04:34:15 <ivanm> killy9999: because there was no need
04:34:18 <Botje> I got stopped on the street once, by a guy who asked me 'where does energy come from'
04:34:19 <ivanm> you can't change the type
04:34:28 <killy9999> ivanm: but I can specialize it
04:34:29 <ivanm> Botje: and did you answer him?
04:34:34 <ivanm> killy9999: no you can't
04:34:51 <Botje> ivanm: I didn't have an answer ready, sadly
04:34:51 <killy9999> ivanm: but isn't it logical to do it?
04:34:52 <ivanm> you can specify the type that the method for the instance _should_ have
04:34:53 <merijn> edwardk: Doesn't work out as well as you'd expect...
04:35:01 <ivanm> but you can't make up your own type
04:35:02 <merijn> edwardk: Surprisingly few homeless people know haskell...
04:35:24 <edwardk> merijn: you never know. you might trip over luke palmer on a busking binge and get the answer first try ;)
04:35:32 <ivanm> killy9999: so, unless you want to remind yourself what the type should be as you define it, there's not really much point
04:36:17 <Jetbeard> Hi all - is it possible to define a type synonym with a typeclass constraint?
04:36:21 <maukd> Jetbeard: no
04:36:23 <Jetbeard> I want to be able to write "type Quaternion a = RealFloat a => (a, a, a, a)"
04:36:23 <edwardk> Jetbeard: no
04:36:32 <Jetbeard> :(
04:36:41 <edwardk> data Quaternion a = Q a a a a
04:37:04 <hpaste> killy9999 pasted “Type annotation in instance declaration” at http://hpaste.org/75229
04:37:12 <edwardk> Jetbeard: or just use http://hackage.haskell.org/packages/archive/linear/0.2/doc/html/Linear-Quaternion.html
04:37:22 <killy9999> ivanm: I would like to write a code like the one pasted
04:37:26 <killy9999> but I get an error
04:37:43 <killy9999> to me it would be logical to provide a specialized type signature
04:37:48 <killy9999> as a sort of reminder
04:38:01 <fmap> there is -XInstanceSigs
04:38:06 <ivanm> Jetbeard: class constraints in type definitions usually leads to problems down the track
04:38:14 <ivanm> killy9999: sure, and that's really the only reason to do so
04:38:23 <ivanm> note that your ":: Double" for 1.0e-10 is redundant
04:38:50 <Jetbeard> edwardk, cool, I'll look into that - I was just trying to fix up some code in the 'frag' package
04:38:57 <killy9999> ivanm: without it I get a warning when I enable -Wall
04:39:07 <Jetbeard> (It seems to rely on the fact that 'GLfloat' is a type synonym for 'Float', which is no longer true
04:39:08 <ivanm> oh, right, literal
04:39:39 <edwardk> yes the GLfloat vs Float debacle makes me sad
04:43:51 <hiptobecubic> Do you need a class for this?
04:43:55 <maukd> asyncToSync :: ((a -> IO ()) -> IO ()) -> IO a; asyncToSync f = do { v <- newEmptyMVar; f (putMVar v); takeMVar v }
04:44:20 <hiptobecubic> isn't  (~=~) :: Num a => a -> a -> Bool  enough?
04:44:48 <maukd> syncToAsync :: IO a -> (a -> IO ()) -> IO (); syncToAsync m f = forkIO (m >>= f)
04:47:51 <kaos`> Hi, I have concurrent program that in it's main function basically forks a couple of threads and then calls "delayThread" with a delay of a couple of a very long time... Is there a 'nicer' way to do this without pausing the main thread? (i.e., a bettey way to formulate "forkIO f >> forkIO g >> threadDelay 10^14", "forkIO f >> g" doesn't seem to do what I want))
04:50:17 <ClaudiusMaximus> kaos`: forever (threadDelay maxBound) is what I use in main for that kind of stuff...
04:50:25 <Botje> kaos`: you could takeMVar <=< newEmptyMVar
04:50:41 <ClaudiusMaximus> kaos`: or that MVar based solution suggested in the documentation too
04:50:42 <Botje> oh, without pausing the main thread. nevermind.
04:51:32 <ClaudiusMaximus> kaos`: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#g:13
04:51:52 <kaos`> Botje: cool apprach :) it (imo) better than having a thread dealy.. But it would be cool if the 'main' thread could still be utilized no?
04:51:56 <merijn> edwardk: btw, in the graph/diagram in your documentation, what do the arrows represent? I'm unsure which side is more general, top or bottom
04:52:09 <EvanR2> you want to make the main thread wait, but you dont want to pause the main thread
04:52:21 <Botje> kaos`: why? takeMVar blocks.
04:52:31 <Botje> kaos`: and remember that threads are cheap in haskell
04:52:36 <edwardk> the top of the diagram are 'superclasses' basically.
04:52:47 <Botje> (hell, sleeping threads are cheap in *any* system)
04:52:55 <Botje> kaos`: you could always do some useful work before the takeMVar.
04:52:56 <EvanR2> i only use the main thread to spawn the other threads and to end the entire program
04:53:02 <edwardk> so every lens is a traversal, which is a fold. but every lens is also a getter, which is an action
04:53:28 <kaos`> Botje: aight, it's cool :) Just wanted to check in so that there wasn't an obviously better solution
04:53:28 <edwardk> toward the top you can do less, but there are more of them
04:53:41 <edwardk> composition with (.) moves to the lowest upper bound of the two arguments
04:53:44 <kaos`> whatever 'better' means I guess :P
04:53:54 <EvanR2> threadDelay maxBound sleeps for 40 minutes on my system :(
04:54:22 <Botje> EvanR2: so it does infinite loops in about an hour, then?
04:54:36 <EvanR2> lol?
04:54:42 <hiptobecubic> That's the halting problem no? Don't you get a prize for that?
04:54:51 <hiptobecubic> I wouldn't share your secret until you publish
04:55:27 <Botje> EvanR2: (I'm referring to a joke by Linus torvalds, who said Linux does infinite loops in about three seconds)
04:55:38 <EvanR2> oh
04:55:50 <EvanR2> havent paid attention to linux development in years
04:56:19 <merijn> edwardk: The biggest recurring problem I keep running into is that I'm essentially trying various combinator permutations until one typechecks, because I can't seem to figure out the correct combinations myself. For example, I have a lens to an IntMap in State and want to do a monadic action for each element in it. I can see I need some combination of mapMOf, traverse (or is it itraverseOf) and the lens to the map. But finding the correct incantation 
04:56:21 <Botje> that's a pretty ancient quote, I think
04:56:38 <EvanR2> if it compiles its good, if it boots up its perfect
04:56:53 <EvanR2> he should have used haskell for the kernel, so if it compiles its perfect ;
04:56:56 <hiptobecubic> merijn, stochastic programming :)
04:56:57 <EvanR2> ;)
04:57:45 <edwardk> this one is interesting.
04:58:16 <Botje> EvanR2: well, there's HalVM
04:58:30 <edwardk> the problem you have is the monadic effect can't live in your state monad. what would happen if it replaced the intmap as it was running?
04:58:38 <edwardk> so you have a couple of options
04:58:49 <edwardk> you can 'zoom' using the traversal into the elements of the intmap
04:59:01 <edwardk> zoom (yourIntMapLens.traverse)
04:59:12 <edwardk> which will give you a smaller state monad, where you can only see the element of the traversal
04:59:20 <edwardk> or you can pull out a copy of the intmap at the start
04:59:59 <edwardk> m <- use yourIntMap; mapMOf traverse (whatever you want to do) m
05:00:03 <edwardk> which can be simplified
05:00:16 <edwardk> m <- use yourIntMap; mapM whatever m
05:00:27 <edwardk> or even use yourIntMap >>= mapM whatever
05:01:42 <merijn> Which is pretty much what I already had before I started, I guess xD
05:01:58 <edwardk> heh
05:02:28 <merijn> get >>= mapM foo . view myIntMap
05:02:37 <edwardk> *nods*
05:02:38 <merijn> Well, slightly shorter, I guess :p
05:02:42 <carpi> how is it possible for haskell to be as fast as it is inspite of the high level at which code is written?
05:03:23 <edwardk> carpi: by pushing side-effects off to one side the compiler is free to make a whole lot of optimizations that aren't possible in normal imperative programming languages.
05:04:14 <EvanR2> immutable data helps
05:04:16 <edwardk> carpi: e.g. ghc routinely changes the entire implementation of your function out from under you to one that is equivalent but much faster by unboxing, doing worker-wrapper transforms, etc.
05:05:28 <carpi> is it possible that it might one day overtake much faster languages?
05:06:17 <EvanR2> languages dont have speed!
05:06:33 <carpi> algorithms do - )
05:06:52 <hiptobecubic> they have complexity
05:06:52 <carpi> you were about to say that..
05:07:08 <hiptobecubic> speed is about flipping bits
05:07:33 <EvanR2> language implementations have a speed given a bunch of other operating criteria
05:08:19 <EvanR2> including how much love they get from developers, so if the C people stopped paying so much attention to C compilers we will eventually see 'C' get slower
05:10:19 <carpi> all said.. the brain of someone of who writes compilers for haskell scares me nuts. I wouldn't want them concentrating on me, lest I catch fire. And here I am, writing baby haskell code .. and finding it enormously difficult.
05:10:47 <edwardk> carpi: the difficulty curve levels off after a bit ;)
05:10:51 <Botje> carpi: once you're confident with haskell, you should check out 'the implementation of functional programming languages' book
05:11:36 <Botje> It's a very nice read where they gradually transform miranda (a precursor to haskell) to simpler and simpler terms.
05:11:39 <merijn> edwardk: Is that before or after {-# LANGUAGE RankNTypes, FryYourBrainWithTypeExtensions, NotSureWhatYourCodeActuallyDoes #-}?
05:11:54 <Botje> it's a free book, too
05:11:55 <Botje> @where ifpl
05:11:55 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
05:11:59 <edwardk> merijn: well it does spike up a bit again later ;)
05:12:05 <typoclass> @remember carpi all said ... the brain of someone of who writes compilers for haskell scares me nuts. I wouldn't want them concentrating on me, lest I catch fire.
05:12:05 <lambdabot> Done.
05:12:15 <mm_freak_> carpi: writing a haskell compiler isn't actually that difficult…  but it's expensive
05:12:37 <mm_freak_> carpi: if you closely follow the STG paper, the main difficulty is in writing the type-checker and the parser
05:15:09 <mm_freak_> carpi: or you can make it even easier and not use an STG machine
05:15:43 <mm_freak_> compile to an extended SK calculus and write a graph reducer for that one…  that way you can have a compiler for your core language in a few hundreds of lines of code =)
05:16:00 <mm_freak_> then you just compile haskell to that core language
05:16:16 <EvanR2> in attoparsec, how do i write a parser Parser [ByteString] where i have one or more 'any content' separated by commas
05:16:28 <EvanR2> i dont see one for 'any content'
05:16:42 <EvanR2> sepBy1 ? (char ',')
05:16:58 <mm_freak_> EvanR2: there is one for "any content", but you can't use that for a comma-separated list
05:17:18 <ivanm> EvanR2: not that familiar with attoparsec, but you want one that takes anything except commas
05:17:19 <EvanR2> do i have to use 'anything but comma'
05:17:23 <ivanm> unless commas are escaped
05:17:34 <carpi> edwardk: liar. haskell is more difficult now than when i started. I must be passing the state of 'difficulty' recursively to my brain.
05:17:39 <EvanR2> commas are not allowed
05:17:48 <ivanm> then "anything but commas" will do it
05:17:52 <carpi> mm_freak_: expensive? how so?
05:17:53 <EvanR2> i figured sepBy would know that
05:17:58 <ivanm> I doubt it
05:18:08 <ivanm> EvanR2: because how does it know whether commas are allowed or not?
05:18:26 <mm_freak_> EvanR2: yes, the parser must not consume all commas…  you can write one that supports escaped commas, if you want to
05:18:32 <ivanm> you could always write a new combinator that takes a separator char, and then calls sepBy1 that assumes that all fields are "anything but that char"
05:18:43 <mm_freak_> carpi: writing a haskell compiler is a lot of work
05:18:55 <EvanR2> ok
05:19:08 <mm_freak_> carpi: most of the thinking required has been done by others, so you can simply follow a set of papers and just turn them into code
05:19:34 <EvanR2> so in general, the content parser must exclude the thing beginning the separator parser
05:19:37 <mm_freak_> carpi: just make your own toy language, it's really not that difficult…  read SPJ's book from 1987 for that
05:19:40 <ivanm> there's also already a parser and the start of a type-checker...
05:19:57 <ivanm> EvanR2: yes
05:19:58 <mm_freak_> carpi: it doesn't cover the STG machine, but it does introduce you to G machines and also the simpler SK-based compilation i mentioned above
05:20:12 <ivanm> or have some way of telling whether it's a separator or not (e.g. allow escaping)
05:20:15 <mm_freak_> carpi: after that you will also be able to actually write unlambda/lazy k code =)
05:20:59 <EvanR2> for the sake of completeness, which one is the parser for 'anything' i was asking about originally
05:21:23 <ivanm> EvanR2: I don't know about attoparsec, but in polyparse it'd be "many1 next" (if you want non-empty)
05:21:35 <ivanm> i.e. get the next character many times
05:21:36 <typoclass> EvanR2: perhaps noneOf ","
05:24:34 <EvanR2> takeTill (/= ',')
05:24:37 <Jetbeard> http://hpaste.org/75230 Is there any reason why the ability to do something like this could not be added as a small extension to Haskell?
05:24:48 <EvanR2> er
05:24:54 <EvanR2> takeTill (== ',')
05:25:53 <nand`> Jetbeard: there's no reason it can't be done; indeed you can write TH to do it for you, but can lead to bad design practices
05:26:04 <nand`> it's not a thing you'd want to encourage with language sugar
05:26:28 <Jetbeard> What bad design practices could this lead to?
05:26:36 <fmap> Doesn't makeClassy in lens do that?
05:26:45 <fmap> (haven't actually tried yet)
05:26:57 <mm_freak_> Jetbeard: type classes shouldn't be abused to get nicer record syntax
05:26:58 <nand`> something like that yes
05:27:22 <mm_freak_> Jetbeard: there is an extension for record puns, which you can use
05:28:31 <nand`> Jetbeard: basically; instead of writing code like HasName a => a -> Foo; you'd tend to just write Name -> Foo; also ‘overloading’ with typeclasses like that can lead to situations where you need existentials and other type trickery to do things that would otherwise be dead simple
05:29:08 <typoclass> mm_freak_: why shouldn't they be used?
05:30:59 <hiptobecubic> isn't this exactly what they are for? overloading functions?
05:31:04 <hiptobecubic> they don't even do anything else
05:31:18 <merijn> hiptobecubic: Not entirely true :p
05:31:33 <merijn> hiptobecubic: You can use them to hack compile time constraints into your code :)
05:32:03 <nand`> oh hey, it's the yoneda lemma. (forall a. HasName a => a -> Name, a) and Name are isomorphic
05:32:36 <nand`> and the first is just the ‘name’ typeclass function
05:33:30 <nand`> actually, I'm not sure if that's the yoneda lemma
05:33:40 <nand`> it probably isn't
05:33:42 <nand`> never mind
05:34:08 <EvanR2> haha
05:34:39 <EvanR2> is sepBy1 guaranteed to return a non empty list?
05:34:54 <ivanm> yes
05:34:58 <ivanm> or fail the parse
05:35:02 <EvanR2> so i can do e:es <- sepBy1
05:35:06 <EvanR2> sweet
05:35:43 * ivanm wonders whether the pattern match fail or the empty list parse fail would happen in that case
05:36:00 <EvanR2> one way to find out..
05:42:24 <b__> In my Chess Engine in progress I am updating GameState, which includes a Board and some state like number of moves and castling rights. Board -> [Board] generation is no problem, but I have to update half-moves and castling rights also, _depending_ on certain specific events such as piece capture. I'm having trouble separating these things, and am finding myself wanting some sort of mutable state. Is there an idiom for this kind of problem?
05:43:42 <b__> I could have a big-ass function which allows access to the entire GameState, but I don't like it
05:43:55 <b__> I could also pass the GameState around, but I don't like that either
05:44:23 <EvanR2> castling is a function of the history of the game
05:44:43 <b__> yeah
05:44:45 <EvanR2> since you arent using the whole history youre already doing mutable state ;)
05:45:16 <alpounet> b__, lenses maybe
05:45:22 <EvanR2> State Chess
05:45:24 <alpounet> this doesn't provide mutable state
05:45:28 <b__> yeah lenses does make it prettier
05:45:35 <alpounet> but it will help writing prettier code
05:45:36 <b__> well I'm not sure I need mutable state
05:48:17 <b__> but I haven't yet found a way to put the obvious into code
05:48:51 <b__> when I am thinking about chess, move-generation (and the whole search tree) is separate from the history (castling, en passant etc) of the game
05:48:54 <b__> so it
05:49:03 <b__> so it's like 2 separate processes
05:49:21 <b__> I only consult the "history process" when the game asks me to
05:49:45 <Cale> Well, the fact that castling/en passant/etc. are only valid under certain circumstances seems to make them not independent of move generation
05:50:22 <b__> true they are not independent
05:50:33 <b__> but they run in different threads in my head, sort of
05:50:42 <Cale> The complete game tree has to contain moves where castling happens, and can't contain moves where it happens illegally
05:50:49 <b__> yeah
05:51:15 <Cale> You could generate a larger game tree, for a game like chess but where castling was always allowed, and then prune it
05:52:47 <b__> yeah or prune it once per move
05:53:02 <b__> which is probably what you mean
05:53:18 <Cale> Well, I mean prune it all at once :)
05:53:26 <Cale> The whole infinite tree :)
05:53:39 <EvanR2> you can compute any answer to a question about chess rules given the history so far
05:53:40 <Cale> (but lazily)
05:53:57 <EvanR2> so just use the history instead of a snapshot
05:54:07 <b__> but that history differs for each node
05:54:23 <EvanR2> ah, chess ai
05:54:39 <b__> yes
05:54:42 <EvanR2> then its a tree, but any path back to the root is a valid history
05:54:47 <Cale> wait, what?
05:54:55 <EvanR2> so use a tree
05:55:15 <Cale> I mean, the history does differ for each node, but that's obvious
05:55:27 <Cale> The histories are nested
05:55:27 <NadiaYvette> Chess problem solvers are another issue where one knows the outcome and in how many moves but must exhibit the path taken to it.
05:56:10 <EvanR2> in bytestring, is there a more obvious way to 'strip space from both sides' besides dropWhile . reverse . dropWhile . reverse ?
05:56:51 <Cale> EvanR2: Use span and spanEnd?
05:57:23 <EvanR2> ah
05:57:36 <EvanR2> in bytestring, 'span' is like 'break'
05:57:40 <EvanR2> not like list span
05:57:52 <Cale> No, it is like span...
05:57:53 <Jetbeard> EvanR, Bytestring also has a 'break' function
05:58:05 <Jetbeard> the docs say: "break p is equivalent to span (not . p)."
05:58:08 <EvanR2> oh im getting span confused with scan
05:58:10 <EvanR2> blah
05:58:14 <Cale> > span (< 10) [1..20]
05:58:15 <lambdabot>   ([1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19,20])
05:58:22 <Cale> > break (> 10) [1..20]
05:58:23 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
05:58:58 <EvanR2> :t spanEnd
05:58:59 <lambdabot> Not in scope: `spanEnd'
05:59:03 <EvanR2> blorg
05:59:09 <EvanR2> back to the interpreter
06:00:01 <Jetbeard> :t Data.ByteString.spanEnd
06:00:02 <lambdabot> (Word8 -> Bool) -> BSC.ByteString -> (BSC.ByteString, BSC.ByteString)
06:00:22 <EvanR2> :t Data.ByteString.Char8.spanEnd
06:00:24 <lambdabot> (Char -> Bool) -> BSC.ByteString -> (BSC.ByteString, BSC.ByteString)
06:01:56 <akamaus> Did anyone try to build gtk2hs with ghc-7.6.1?
06:02:18 <EvanR2> > Data.ByteString.Char8.break (== ' ') . Data.ByteString.Char8.breakEnd (== ' ') $ Data.ByteString.UT8.fromString "  barf   bloog   "
06:02:19 <lambdabot>   Not in scope: `Data.ByteString.Char8.break'Not in scope: `Data.ByteString.C...
06:02:41 <akamaus> dcoutts, ^^
06:04:38 <EvanR2> slapping some snd and fst on there, its not more obvious than dropWhile . reverse
06:04:52 <EvanR2> \o/
06:04:54 <EvanR2> :t strip
06:04:55 <lambdabot> Not in scope: `strip'
06:05:14 <EvanR2> @hoogle ByteString -> ByteString
06:05:15 <lambdabot> Codec.Compression.Zlib.Raw compress :: ByteString -> ByteString
06:05:15 <lambdabot> Codec.Compression.GZip compress :: ByteString -> ByteString
06:05:15 <lambdabot> Codec.Compression.Zlib compress :: ByteString -> ByteString
06:09:33 <matthiasgorgens> is there a haskell library to check whether a given symlink is broken or not?
06:10:33 <matthiasgorgens> (on linux.)
06:11:35 <hiptobecubic> matthiasgorgens, maybe an abspath + exists?
06:11:35 * hackagebot deepseq-generics 0.1.0.0 - GHC.Generics-based Control.DeepSeq.rnf implementation  http://hackage.haskell.org/package/deepseq-generics-0.1.0.0 (HerbertValerioRiedel)
06:11:51 <hiptobecubic> matthiasgorgens, i assume those functions exist?
06:12:14 <Botje> matthiasgorgens: there is a readSymbolicLink in System.Posix.Files
06:12:15 <matthiasgorgens> hiptobecubic: thanks!
06:12:23 <matthiasgorgens> Botje: thanks to you to.
06:13:41 <Botje> brokenSymlink = not `fmap` fileExist <=< readSymbolicLink
06:13:45 <Botje> or something like that..
06:13:47 <fmap> well, readSymbolicLink just returns destination path, you need to manually check its existance
06:13:49 <matthiasgorgens> yeah.
06:14:15 <fmap> or existence rather
06:14:17 <Botje> doesn't typecheck, but you get the gist.
06:14:44 <matthiasgorgens> thanks.
06:14:56 <matthiasgorgens> would typecheck with the right parens, I believe.
06:15:50 <Botje> nah, fmap is in the wrong monad there
06:16:51 <donri> fmap ain't no monad?
06:17:08 <matthiasgorgens> fmap.fmap.
06:17:31 <matthiasgorgens> or so.
06:17:41 <matthiasgorgens> where the second fmap is just .
06:17:53 <matthiasgorgens> liftM not . fileExists <=< readSymbolicLink
06:17:54 <matthiasgorgens> (or so.
06:17:55 <matthiasgorgens> )
06:18:17 <donri> oh yea fmap is a monad by merit of function being a monad
06:18:33 <matthiasgorgens> fmap isn't a monad.
06:18:38 <matthiasgorgens> that statement doesn't typecheck.
06:18:44 <matthiasgorgens> but every monad defines liftM.
06:19:02 <matthiasgorgens> and the only reason liftM isn't exactly the same thing as fmap is history.
06:19:12 <matthiasgorgens> (i.e. Monads in Haskell aren't Functors, but they should be.)
06:19:55 <matthiasgorgens> and for the (->) r monad, fmap == liftM == (.)
06:19:57 <donri> well ok fmap is a monadic action ;)
06:20:34 <matthiasgorgens> hmm, I guess strictly speaking that's also not true.  but I guess you mean well. :o)
06:20:49 <roelvandijk> Small question: I have a fresh GHC-7.6.1 install. "cabal update" informs me there is a newer version of cabal-install available. "cabal install cabal-install" gives the following error:
06:20:49 <roelvandijk> cabal: Couldn't read cabal file "bytestring/0.10.0.0/bytestring.cabal"
06:21:06 <matthiasgorgens> fmap f x might is a monadic action, for suitable f and x.
06:21:26 <matthiasgorgens> how did you install ghc-7.6.1?
06:21:29 <Botje> return . not <=< fileExist <=< readSymbolicLink -- is the closest I can get, but it's monday. surely there's a better way
06:21:35 * hackagebot Eq 1.1.1 - Render math formula in ASCII, and perform some simplifications  http://hackage.haskell.org/package/Eq-1.1.1 (VincentBerthoux)
06:21:51 <Jetbeard> roelvandijk, is it possible to update Bytestring first?
06:21:55 <matthiasgorgens> (return . f =<<) is the same as liftM f .
06:21:56 <roelvandijk> matthiasgorgens: From the binary package for linux
06:22:05 <matthiasgorgens> hmm, ok.
06:22:14 <Botje> matthiasgorgens: note that i'm using <=<, not =<<
06:22:33 <matthiasgorgens> Botje: then make it liftM f $
06:22:41 <matthiasgorgens> where f = not.
06:22:51 <Botje> ooh, evil. nice :)
06:22:57 <roelvandijk> Jetbeard: It would have to be installed in the package database for GHC-7.6.1
06:23:08 <matthiasgorgens> or, not <$>
06:23:19 <matthiasgorgens> (because (<$>) = fmap.)
06:24:21 <roelvandijk> I'll try reinstalling GHC-7.6.1
06:24:56 <matthiasgorgens> Botje: on the converse, you can express =<< with fmap and join.
06:25:01 <matthiasgorgens> (or liftM and join.)
06:25:41 <nominolo> what was the solution again to this error?  cabal: Couldn't read cabal file "bytestring/0.10.0.0/bytestring.cabal"
06:25:45 <applicative> roelvandijk: what version of cabal install are you using though. Also, isn't bytestring included
06:26:15 <roelvandijk> applicative: cabal-install version 0.10.2 using version 1.10.1.0 of the Cabal library
06:26:35 * hackagebot attoparsec-conduit 0.5.0.2 - Consume attoparsec parsers via conduit.  http://hackage.haskell.org/package/attoparsec-conduit-0.5.0.2 (MichaelSnoyman)
06:26:40 <roelvandijk> I just did a reinstall. Now cabal installing something gives the error: cabal: Couldn't read cabal file "binary/0.6.1.0/binary.cabal"
06:26:50 <applicative> roelvandijk: I  think bytestring-01.10 came with the compiler
06:26:55 <roelvandijk> So the problem does not seem to be with a specific package.
06:27:00 <nominolo> roelvandijk: yes, same here. I think it's a corrupt .cabal file
06:27:05 <nominolo> i forgot the fix, though
06:27:08 <applicative> as ghc-pkg list will show you
06:27:39 <applicative> what version of cabal-install is it trying to install?
06:28:02 <roelvandijk> applicative: I'll try to find out
06:29:15 <hpaste> me pasted “hello” at http://hpaste.org/75234
06:29:16 <Saizan> "cabal update" might help
06:29:29 <hpaste> me pasted “hello” at http://hpaste.org/75235
06:29:30 <roelvandijk> applicative: Hmm, cabal info cabal-install says "Unknown" for the versions installed
06:29:50 <mysticc> Is there any substitute to cabal-dev
06:29:51 <roelvandijk> applicative: I assume it tries to install the newest version "0.14.0"
06:30:23 <applicative> roelvandijk: it must be since there isn't one in between.  Until recently it was hiding that version, you had to demand it explicitly
06:30:42 <applicative> what happens with cabal install cabal-0.14.0
06:31:04 <robstewartuk> Looks like I'm having the same issue this guy person: http://hpaste.org/74839
06:31:05 <applicative> (which is what you needed to do at least until recently)
06:31:13 * dcoutts can hack the .cabal files on the server
06:31:30 <byorgey> mysticc: there is https://github.com/Paczesiowa/hsenv , which has similar-ish goals (sandboxed Haskell builds) but a different approach
06:31:31 <robstewartuk> Some libraries do not compile with ghc 7.6, due to catch being removed from Prelude. Anyone know how to resolve ?
06:31:53 <nominolo> dcoutts: do you know what exactly is causing the problems?
06:32:00 <mysticc> byorgey: hackage ?
06:32:05 <applicative> robstewartuk: yes, you adopted ghc-7.6 too early
06:32:11 <nominolo> dcoutts: I can read the file locallly
06:32:26 <robstewartuk> applicative: oh. Is there.. no way to fix this?
06:32:26 <dcoutts> nominolo: older cabal versions cannot parse the file
06:32:35 <byorgey> mysticc: well, hsenv used to be http://hackage.haskell.org/package/virthualenv
06:32:54 <byorgey> mysticc: but it seems hsenv has had further development, I am not sure why it is not released on Hackage
06:33:26 <roelvandijk> applicative: Every attempt at installing either cabal or cabal-install results in the error message with the unparsable bytestring.cabal file
06:33:37 <nominolo> dcoutts: i thought Cabal was designed to be future proof.  Basically, my cabal-install is broken now
06:34:03 <applicative> roelvandijk: dcoutts seems to understand
06:34:19 <roelvandijk> applicative: Yes, it is somewhat what I expected
06:34:22 <mysticc> byorgey: I dont want to make it manually .. Both package are under the same person then why two separate packages
06:34:27 <roelvandijk> applicative: Bit of a chicken and egg problem
06:34:30 <nominolo> dcoutts: and I can't upgrade cabal-install itself
06:34:39 <dcoutts> nominolo: I know
06:34:58 <byorgey> mysticc: virthualenv came first.  Then people complained about the name so it was changed to hsenv.  But hsenv has not been released on Hackage.  I do not know why.
06:35:18 <byorgey> mysticc: if you just want to install from Hackage I'm sure virthualenv works fine.
06:35:41 <roelvandijk> For me this isn't a huge issue. I can happily use GHC-7.4.2. But I wan't to upgrade my packages to support GHc-7.6.1
06:35:51 <applicative> robstewartuk: the simple minded thing is to cabal unpack gtk-buildtools, and delete the words "hiding (catch)" from the import of the Prelude. (I'm inferring this since its everytwhere)
06:36:04 <mysticc> byorgey: Ok .. I will see .. Installing cabal-dev was a nightmare without any success ..
06:36:36 <byorgey> applicative: no, that does not work.  The problem is that the hiding (catch) is in the Paths_* modules autogenerated by cabal
06:36:52 <applicative> byorgey: oh, damn, did not reason about that
06:37:10 <byorgey> mysticc: I'm sorry to hear that
06:37:11 * Cale chooses to interpret "wan't" as "want not"
06:37:27 <b__> I like how reading Data.Lens docs and source make me feel like a total idiot
06:37:28 <dmos> nominolo: it's possible to upgrade cabal-install itself without too much of a hassle if you're on a POSIX system. It's how I have multiple GHC with their own cabal-install and cabal-dev running under the same user.
06:37:32 <applicative> robstewartuk: forget that I did not reeason it was a Paths_gtk2hs_ module
06:37:37 <Cale> b__: :)
06:37:59 <byorgey> cabal-dev seems not to be maintained anymore.  It's sad. =(
06:38:02 <applicative> b__ its surprisingly easy to use though.
06:38:02 <Cale> b__: Once you understand a few basic things, it's not so bad
06:38:10 <robstewartuk> right ok. Fine. I'll build 7.4 and compile with that.
06:38:25 <b__> I'm able to use the basics, but now I see a big wall
06:38:28 <Cale> (but there is a lot of it to look through)
06:38:28 <merijn> robstewartuk: The best fix is to submit patches to the relevant maintainers :)
06:38:35 <dmos> applicative: the version on github works with 7.4.1/2 and HP 2012.2
06:38:40 <b__> there's so much there yeah
06:38:42 <merijn> b__: Sounds about right, I have the same :p
06:38:47 <b__> and all so damn interesting
06:39:20 <applicative> merijn: I thought byorgey was saying the mistake is generated by cabal
06:39:31 <mysticc> byorgey: Too many dependencies for it.. and satisfying its dependencies will break my rest of the system
06:39:44 <mysticc> So I am going with virthualenv
06:39:55 <byorgey> mysticc: uh, it only depends on base and Cabal
06:40:00 <b__> but some of those code samples look like a whole new language
06:40:12 <b__> I can see that it's not, obviously, but wow
06:40:26 <Cale> heh, well, in a sense it is
06:40:28 <byorgey> b__: well, in some sense, it IS a whole new language
06:40:40 <byorgey> it just happens to be embedded in Haskell.
06:41:09 <mysticc> byorgey: I dont know it gave so many errors..  http://hpaste.org/75237
06:41:13 <byorgey> mysticc: oh, sorry, I was deceived by Hackage again
06:41:35 <byorgey> Hackage doesn't know how to deal with conditional dependencies, so it just doesn't show them at all
06:41:58 <merijn> applicative: Well, I've found and fixed several packages still relying on Prelude.catch/System.IO.catch that I ran into using 7.6
06:42:01 <mysticc> ohh..
06:42:06 <mysticc> thanks anyways
06:42:17 <byorgey> mysticc: yeah, this is caused by cabal-dev not allowing the latest version of mtl
06:42:27 <applicative> roelvandijk: can you get around all this by building the newer cabal with make or whatever from inside the source directory
06:42:31 <byorgey> mysticc: which is one of the reasons I said it seems like it is not maintained anymore
06:43:25 <applicative> merijn: yeah, me too, thats why I was telling him the same as you a little earlier, somewhat mechanically, but the paths_blah modules are cabal -generated
06:43:28 <b__> really seems like I should dive into monads now
06:43:31 <roelvandijk> applicative: I'll try. I just tried the latest stable build of GHC to no avail. Currently trying the latest unstable build.
06:43:48 <b__> only way to slay this wall (and others)
06:43:51 <Cale> ala :: Simple Iso a b -> ((a -> b) -> c -> b) -> c -> a
06:43:55 <Cale> auf :: Simple Iso a b -> ((d -> b) -> c -> b) -> (d -> a) -> c -> a
06:43:56 <Cale> lol
06:44:23 <merijn> b__: Oh, you haven't gotten around to monads yet? Then I can see how Control.Lens would be even more confusing :p
06:44:34 <b__> I have, to some degree
06:44:46 <applicative> roelvandijk: one thing I don't get is why it installing these things anyway, you already have bytestring-0.10 and binary etc; it just cant find them somehow
06:44:48 <b__> but diving in like Chuck Norris? not yet
06:45:02 <alpounet> byorgey, 'cabal sandbox install' is on its way fortunately heh
06:45:10 <benmachine> Chuck Norris is super lame, fact
06:45:15 <merijn> b__: Have you played with StateT yet?
06:45:19 <b__> no
06:45:38 <roelvandijk> applicative: Perhaps it is simply part of the dependency analysis. Parsing the .cabal files of already installed packages.
06:45:43 <byorgey> alpounet: yay!
06:45:51 <Cale> -- Mnemonically, the German /auf/ plays a similar role to /à la/, and the combinator is 'ala' with an extra function argument.
06:45:57 <merijn> b__: Oh, that might be a good place to start, then. StateT isn't particularly hard and very neat
06:46:05 <byorgey> Cale: hahaha
06:46:08 <b__> ok thanks for the suggestion
06:46:12 <merijn> I end up using it quite often, at least :)
06:46:58 <merijn> b__: It's used to have pure state without needing to explicitly pass that state as a function argument all the time
06:47:30 <Cale> If you want to understand StateT, first understand the monad instance for  newtype Parser a = P { runParser :: String -> [(String,a)] }
06:47:32 <b__> ah cool
06:47:57 <applicative> ... because after all, it's a slightly more complicated type ....
06:48:19 <nominolo> dmos: yeah, I'll have to do that
06:48:45 <Cale> (StateT is a straightforward generalisation -- you can even write the instance of Monad for Parser in such a way that the code doesn't have to change to get the StateT instance :)
06:48:46 <applicative> b__: the Pong.hs module in the source uses StateT + the fancy lenses
06:49:08 <kstt> hi. Almost any real world application I have to do will have a lot of code running in the reader monad (configuration, logging handle, synchronisation MVars ...). That works well, however I am often facing the need to subtype the environment, because some of the environment is shared amongst all computations, and some it absolutly not. That's a bit painful.
06:49:09 <Cale> and if you want Parser to make sense, understanding the monad instance for  newtype State s a = S { runState :: s -> (s, a) }  is a good plan
06:49:10 <b__> ohs, I'll go have a look then
06:49:30 <dcoutts> roelvandijk: yes it's part of the dep analysis, it looks at the .cabal file because it's a potential dependency.
06:49:40 <dcoutts> that makes it hard to avoid the error
06:50:08 <Cale> kstt: Are lenses the answer you're looking for?
06:50:29 <Cale> kstt: Or is it just getting a bit more used to explicit parameter passing? :)
06:50:41 <dmos> nominolo: For me it works if I have the /bin of a downloaded GHC in front of the system wide installation, and then using that GHC to build a source checkout of cabal-install, and then that cabal-install to build a source checkout of cabal-dev and put the binaries also in said /bin
06:51:15 <dmos> nominolo: 'in front of the system wide installation' ... err, earlier in PATH I mean
06:51:16 <applicative> dcoutts roelvandijk at  last I get it, yes
06:52:17 * dcoutts grabs an older cabal-install and tries to reproduce the problem
06:52:33 <dmos> nominolo: and then I just have a shell hack where I open a new shell inside the default shell and do some PATH manipulation in file I always source from project dirs. primitive, but does the trick.
06:53:13 <merijn> kstt: Parameterise your Reader over the extra environment?
06:53:46 <merijn> kstt: "AppEnv a = Reader (GlobalStuff, a)" (or whatever)
06:53:53 <kstt> cale : lenses may be asolution, but how ? ATM, The options I foresee are : 1/ use the union of all environment as THE environment, and let irrelevant fields undefined in some codepath (ugly, but simple).  2/ use separate environment for separate codepath, and define tons of dummy instances (HasThing1, HasThing2 ...).  3/ Be more explit, have separate types for separate environments, use contructors and extractor to build up and
06:53:54 <kstt> deconstruct each time some computation from some environment must run in base environment.
06:54:02 <nominolo> dmos: great, cabal-install-0.14 doesn't even build using the bootstrap script
06:54:21 <dmos> nominolo: under 7.6?
06:54:26 <nominolo> dmos: yep
06:54:29 <Cale> kstt: Well, that last one would be the way I was thinking.
06:54:40 <dcoutts> nominolo: can you tell me your cabal --version
06:54:51 <Cale> kstt: Though I don't actually know what you're doing with these environments. I don't tend to use Reader a whole lot myself.
06:54:58 <harrison> codePATH or codePENDENT?
06:55:01 * dcoutts cannot immediately reproduce it with 0.10.2
06:55:21 <Cale> kstt: (I'll tend to just bundle parameters to functions into appropriate record types and pass them explicitly more often than not)
06:55:29 <nominolo> dcoutts: $ cabal --version
06:55:29 <nominolo> cabal-install version 0.10.2
06:55:29 <nominolo> using version 1.10.1.0 of the Cabal library
06:55:52 <kstt> Cale: yeah, that's fine from typesafety point of view, and resonably noisy
06:55:53 <dmos> nominolo: 1 sec, trying it out myself from scratch
06:56:02 <dcoutts> nominolo: ah ok thanks, I'm using 1.10.2.0 of the cabal lib, will try the older one
06:56:07 <nominolo> dcoutts: the bootstrap script also tries to use Cabal-1.14 (instead of 1.16 from GHC 7.6)
06:56:49 <nominolo> dcoutts: could be the "test-suite" or "benchmark" sections
06:57:20 <nominolo> dcoutts: the easiest test case is to then try to do cabal install cabal-install
06:57:52 <dcoutts> nominolo: yep, I was trying cabal install bytestring, but I was using a slightly later Cabal lib which presumably had the fix
06:57:55 <Cale> kstt: It can be a bit noisy, but you can always cut the noise down by using data types to keep related things together. If the other option was a bare ReaderT, then you'll likely end up making up the cost in all the lifts you don't have to write.
06:58:06 <kstt> Cale: with deep codepaths (A (B (C (D ... (Z) )))), when Z needs some data that only A can construct, it really becomes painful to carry that explicitly throught B..Y while these functions don't even need the data
06:58:17 <dcoutts> nominolo: yes I think it is something in the testsuite or benchmark section (not the whole section)
06:58:29 <Cale> kstt: But they *do* need the data, because Z needs it, and apparently they need Z.
06:58:54 <Cale> kstt: So if you were testing them, you'd have to pass them that data too.
06:59:22 <Cale> It's really good for your sanity while testing things if everything is explicit about what things it depends on.
06:59:36 <Cale> (at least I've found this)
06:59:52 <kstt> sure they need to carry the payload, but they don't need to look at it, and that's what I like in the reader pattern. It avoid to bring into lexical scope tons of data that don't have to be read.
07:02:05 <mysticc> @hoogle liftIOResult
07:02:06 <lambdabot> No results found
07:02:57 <mysticc> Which QuickCheck provided liftIOResult ?
07:03:31 <Cale> mysticc: Are you sure that any did?
07:04:12 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.2/doc/html/Test-QuickCheck-Property.html#v:liftIOResult
07:04:15 <mysticc> Cale: I am trying to install an old package from haskell and error says  Module `Test.QuickCheck.Property' does not export `liftIOResult'
07:04:18 <Cale> aha, 2.2 at least did
07:04:32 <mysticc> Cale: What to do ?
07:04:34 <applicative> kstt: what about ReaderT Local (ReaderT Global (...) or is that insane
07:05:19 <manelvf> hi
07:05:25 <applicative> hi manelvf
07:05:29 <manelvf> having a problem with cabal-install
07:05:39 <applicative> manelvf: seems everyone is today
07:05:54 <manelvf> odec.Compression.Zlib: premature end of compressed stream
07:06:00 <manelvf> Codec*
07:06:04 <mysticc> Cale: http://hackage.haskell.org/packages/archive/chp-plus/1.3.1/doc/html/src/Control-Concurrent-CHP-Test.html#qcCHP see qcResult
07:06:14 <manelvf> trying to install yesod
07:06:18 <kstt> applicative : thanks, that's an other option indeed
07:06:50 <Cale> mysticc: liftIOResult :: IO Result -> Property. In new QuickCheck, anything with an instance of Testable can be made into a Property. Result has an instance of Testable, and there is a function:  morallyDubiousIOProperty :: Testable prop => IO prop -> Property
07:07:41 <Cale> mysticc: So you could perhaps replace the call to liftIOResult with a call to morallyDubiousIOProperty :)
07:07:50 <applicative> manelvf: this is happening while cabal-install is running?  hmm
07:08:18 <Cale> manelvf: Maybe the download failed?
07:08:21 <manelvf> sorry, was doing cabal-dev install
07:08:30 <mysticc> Cale: Nice name by the way morallyDubiousIOProperty :P
07:08:37 <manelvf> applicative: cabal-dev not cabal
07:08:55 <applicative> manelvf:I was wondering what Cale is wondering, the error suggests that
07:08:57 <ciaranm> the last time i heard "morally dubious" was in a category theory lecture
07:09:33 <Cale> It's being used in a similar sense here.
07:09:51 <manelvf> doing a cabal-dev install -v3 shows a problem with package crypto-conduit-0.4.0.1.tar.gz
07:10:02 <quuuux> that's a fascinating choice of words. It's presumably meant to contrast with 'unsafe' and 'safe' in other names
07:10:10 <ciaranm> i think it was about defining an isomorphism as being a bijective hom
07:10:17 <Cale> The reason properties constructed this way are morally dubious is that they can result in unrepeatable testcases.
07:10:34 <Cale> ciaranm: oh, yes, that's a common form of evil.
07:10:44 <quuuux> which suggests that there's a latent association between 'unsafe' and immorality, and 'safe' and morality within the Haskell culture
07:10:53 <quuuux> who knew, we're all actually puritans
07:11:29 <Cale> quuuux: Our sense of morality is that programs should run the same way every time as much as possible
07:11:37 <Cale> "ought to"
07:11:51 <ciaranm> awww. that makes the stuff i'm doing immoral :(
07:12:47 <merijn> @pl \l a -> use l >>= a
07:12:47 <lambdabot> (>>=) . use
07:12:58 <applicative> manelvf: it isn't happening to me with just cabal install crypto-conduit  does cabal-dev keep a copy of the source somewhere?  maybe it is reverting to ill-downloaded source
07:13:48 <Cale> ciaranm: Well, perhaps, perhaps not :)
07:14:25 <ciaranm> i always get the same "size" of answer. but thanks to threads being nondeterministic, it can find different proofs...
07:14:30 <Cale> ciaranm: It's okay for programs to run differently when we mean them to, it's not okay for them to behave differently on different occasions when they don't need to do that.
07:14:38 <Cale> ah
07:14:56 <manelvf> applicative: unable to do cabal install crypto-conduit
07:15:06 <manelvf> gaves me the same error
07:15:49 <Cale> Concurrency is of course a bit evil, but it can be controlled :)
07:15:51 <applicative> manelvf: maybe delete ~/.cabal/repo-cache/hackage.haskell.org/crypto-conduit/0.4.0.1/crypto-conduit-0.4.0.1.tar.gz ?
07:15:53 <siml1> i am trying to install haddock using cabal, but i am getting this error http://hpaste.org/75239. anyone an idea?
07:16:22 <dmos> applicative: if you want to be very sure that it really uses the code you want it to use: cabal unpack <pkg-name>; cd <pkg-name>*; cabal-dev install (or just build)
07:16:36 * hackagebot hamlet 1.1.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.1 (MichaelSnoyman)
07:16:38 * hackagebot yesod 1.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.1 (MichaelSnoyman)
07:16:40 * hackagebot yesod-core 1.1.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.2 (MichaelSnoyman)
07:16:59 <dino-> Does anyone here use gitit? I just did an upgrade from 0.8.x to 0.10.x, carefully made sure the conf was the same, and it's behaving like it's a fresh, new install. No got any of my pages. But the /var/gitit/wikidata dir is present and darcs can see all of the commits from before.
07:17:00 <Cale> siml1: Which GHC version?
07:17:01 <manelvf> applicative: thx, i'll do it
07:17:04 <dmos> manelvf: ^^ (I think that was your question)
07:17:16 <applicative> dmos: yes, but somethign else is puzzling.
07:17:18 <siml1> Cale, 7.4.1
07:17:19 <dino-> So the data isn't gone or destroyed, it's just that new gitit 0.10 isn't looking there like the old one used to.
07:17:20 <Cale> siml1: It's probably better to just use whichever haddock comes with your GHC
07:17:31 <applicative> manelvf: but yes, as dmos says try building from inside the source
07:17:44 <Cale> (or wait, haddock does come with GHC, right?)
07:17:58 <Cale> yeah
07:18:26 <Cale> If you installed ghc into /usr/local/ you should have a /usr/local/bin/haddock
07:18:27 <siml1> Cale, do you mean installing it over the linux-distri repo?
07:18:48 <dmos> is hackage skittish only on my end of the internet (some packages just don't download, ie. connection timeout)
07:19:14 <Cale> Oh, if you got GHC with your distribution, they (Debian and friends especially) have this terrible habit of shattering it into a million small packages.
07:19:31 <Cale> which you have to go hunting for to get a complete installation
07:19:55 <Cale> But there ought to be a haddock package
07:20:09 <siml1> Cale, http://hpaste.org/75240
07:20:26 <Cale> lovely
07:20:42 <manelvf> applicative: removed crypto-packages, reinstalled and restarted installation
07:21:09 <dmos> nominolo: looks like I won't be able to help you because my internet is giving out. Here's what I tried to do: download/install GHC 7.6 into some prefix, put that prefix in front of PATH, checkout cabal from github repo, and run bootstrap.sh directly.
07:21:10 <Cale> What I'd usually recommend unless you're really attached to using your distribution's package is just to get the binary package for 7.4.1 or 7.4.2 from the GHC website.
07:21:42 * hackagebot yesod-form 1.1.3 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.1.3 (MichaelSnoyman)
07:21:42 <dmos> nominolo: It should work, I can't guarantee it until I get decent internet. :|
07:21:56 <Cale> and then grab the tarball for cabal-install from hackage, and it has a bootstrap.sh script in it which will get itself set up, and then you can install other packages as user
07:22:07 <Cale> and that tends to work really well
07:22:26 <siml1> k thx
07:26:36 * hackagebot snaplet-postgresql-simple 0.2.1 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.2.1 (DougBeardsley)
07:28:01 <nand`> I wonder if gloss and gloss-raster can be used to draw nice visualizations of color spaces (think CIE Yxy)
07:28:12 <nand`> gloss for the curve, and gloss-raster for the gradients inside it
07:28:39 <dcoutts> nominolo, roelvandijk, applicative: can you cabal update and try now?
07:28:49 <nand`> is it possible to do stuff like intersecting or masking with gloss? Like, draw one shape only within the confines of another
07:29:52 <dino-> Aha, figured it out. Old gitit used to assume /var/gitit/ for wikidata path, now needs abs path.
07:30:21 <roelvandijk> dcoutts: Currently updating...
07:31:06 <roelvandijk> dcoutts: The error with bytestrings cabal file is gone!
07:31:23 <dcoutts> roelvandijk: someone also mentioned binary, were there any others?
07:31:24 <roelvandijk> dcoutts: Now it complains about the directory-1.1.0.2 dependency which can not be satisfied.
07:32:23 <byorgey> nand`: gloss can't draw arbitrary curves, only arcs
07:33:00 <roelvandijk> dcoutts: I got that error trying to install a package of mine. That error is also gone after cabal update
07:33:30 <nand`> byorgey: hrm, I wonder how well this curve can be drawn: https://upload.wikimedia.org/wikipedia/commons/b/b0/CIExy1931.png
07:33:42 <roelvandijk> dcoutts: Oh, and I now owe you a beer!
07:33:48 * nand` should work out the calculation from wavelength to x/y
07:33:57 <dcoutts> roelvandijk: heh :-)
07:34:39 <byorgey> nand`: if you can generate sample points along the curve, diagrams can create a cubic spline through them
07:34:48 <nand`> byorgey: yes that should be fine
07:34:58 <byorgey> nand`: but diagrams doesn't really do bitmaps like gloss can
07:35:17 <alpounet> we need a @faq with diagrams
07:35:20 <nand`> oh, you made it sound like diagrams interoperates with gloss
07:35:30 <byorgey> nand`: it doesn't, but perhaps it should!
07:35:45 <byorgey> I was just comparing/contrasting
07:36:07 <nand`> I'm sure if I could manage to draw the curve then I could simply make the gloss-raster calculation a bit more complicated and manually check whether each pixel is in the area or not before showing it
07:37:08 <nand`> the intent is to provide me with a canvas on which to draw other stuff like triangles (with a healthy amount of precision); but worst comes to worst I could either just import that or a similar image as-is or just hand-draw the triangles
07:39:15 <applicative> dino-: ah I see in https://github.com/jgm/gitit/blob/master/CHANGES "Wikidata paths are translated to absolute ones, so pandoc/pdflatex can find them (Juraj Hercek)."
07:40:03 <dino-> applicative: I didn't find that info, unfortunately. Had to puzzle it out by hand.
07:40:52 <dino-> And what it did with no abs path in conf was to use ~ for a prefix if you're non-root and /etc/ for a prefix if you are root.
07:41:44 <dino-> s/if you're/if started by/
07:43:10 <dino-> applicative: Ah, I see it now in /usr/local/share/gitit-0.10.0.1/CHANGES
07:43:17 <saml> hey, is FP Days a good conference to go?
07:44:08 <applicative> dino-: I looked at the changes file when you first asked, but didn't spot it.  I was just affirming that it was there, not that it was any use to you by then ...
07:47:09 <dino-> applicative: thank you for assisting
07:50:28 <t7> i want to carry proofs around in my C types
07:51:38 <Cale> t7: lol
07:54:57 <Jello_Raptor> i'm not sure what this error means :/ http://hpaste.org/75242
07:55:49 <atriq> Array a e is a type, not a class
07:56:02 <koeien> types and type classes are different
07:56:11 <atriq> (!?) :: Ix i => Array i e -> i -> Maybe e is what you want
07:56:21 <Jello_Raptor> ahh, okay :)
07:56:40 <koeien> the array stuff is kinda confusing, yeah
07:58:15 <benmachine> you could probably submit that as a GHC regression in helpfulness of error messages, though
07:58:36 <koeien> it's not wrong but very unhelpful indeed
07:59:50 <Jello_Raptor> benmachine: how would I do that
08:00:20 <benmachine> Jello_Raptor: http://hackage.haskell.org/trac/ghc/
08:00:47 <benmachine> Jello_Raptor: I already have an account so I'll do it for you if you want, but after lunch :P
08:01:26 <Jello_Raptor> benmachine: thanks :) that'd benice
08:03:38 <fmap> why is it not helpful?
08:03:50 <koeien> it should mention "Array a e" if possible.
08:03:52 <koeien> imho
08:04:27 <benmachine> fmap: it's not helpful to people who don't know about ConstraintKinds
08:04:30 <benmachine> or indeed kinds in general
08:04:59 <benmachine> fmap: it's not so much that it's unhelpful, but the error message that used to come up in that case is much more helpful
08:05:04 <benmachine> it mentions things like types and type classes
08:05:20 <jdnavarro> is there any way of having Rank2Type constructors automatically derived to Eq and Show?
08:05:35 <merijn> hmm, (!) with a non-existent key prints an error, but doesn't crash my program? :\
08:06:05 <merijn> I was kinda assuming that'd terminate everything :\
08:06:07 <benmachine> merijn: it should throw an exception
08:06:16 <benmachine> that won't crash your program if it happens in a thread
08:07:01 <mm_freak_>       Possible fix: use a standalone deriving declaration instead
08:07:03 <mm_freak_> what's that?
08:07:42 <scooty-puff> it looks like haddock (or ghc - i'm not sure where the information comes from) is having trouble simplifying constraints in the presence of the ConstraintKinds
08:08:01 <scooty-puff> but only in how its displayed in the documentation - not in any use
08:08:38 <quuuux> mm_freak_: you mean, what's standalone deriving? Look for StandaloneDeriving in the GHC manual. It does about what you'd think from the name
08:08:47 <mm_freak_> interesting
08:10:31 <quuuux> random off-topic question: how can I get a result set with no columns in SQL? "SELECT FROM table WHERE blah" doesn't seem to work.
08:10:49 <sithisbitch> I don't think it's possible
08:11:02 <dmwit> select count(*) from table where blah
08:11:17 <dmwit> I think it's so odd that everybody capitalizes all SQL all the time.
08:11:23 <dmwit> The spec specifically says it's case insensitive.
08:11:31 <sithisbitch> yes, but it's old
08:11:36 <quuuux> hmm, I was afraid that was going to be the answer
08:11:40 <sithisbitch> and in the old time uppercase was the norm
08:11:44 <dmwit> afraid?
08:11:46 <mm_freak_> Select count(*) From table Where blah
08:11:48 <dmwit> What's bad about it?
08:11:53 <sithisbitch> (and there is still uppercase faggot, like me)
08:11:57 <dmwit> Oh, I guess what's bad about it is that it's irregular.
08:12:03 <dmwit> So, yeah, you need a special case, sorry.
08:12:11 <mm_freak_> capitalized code is unreadable…  just try to read old BASIC code
08:12:14 <quuuux> dmwit: it means I'll have to patch that into my SQL library
08:12:20 <dmwit> right
08:12:27 <sithisbitch> mm_freak_, i learn with uppercase code' (basic) and it's readable
08:12:37 <sithisbitch> the letter are bigger than with lowercase
08:12:39 <merijn> benmachine: How do I ensure it kills my program if it happens in a thread other than main?
08:12:44 <sithisbitch> you're not used with uppercase
08:13:08 <merijn> benmachine: Wrap all my threads with a catch that quits?
08:13:10 <dmwit> Yes, upper-case things read slower (for most people) because (most) people aren't used to them.
08:13:24 <sithisbitch> dmwit, young people
08:13:31 <sithisbitch> old developper are used with uppercase
08:13:38 <dmwit> I don't think I need to restrict that sentence to young people.
08:13:53 <quuuux> right, I'm used to the upper case. My rationalisation is that it makes it easy to tell what's a variable and what's syntax
08:13:54 <sithisbitch> I read faster with uppercase because i learn with that
08:14:04 <dmwit> That's nice.
08:14:05 <mm_freak_> sithisbitch: your brain deals best with lower case or mixed case
08:14:13 <sithisbitch> i hate mixed case
08:14:17 <mapreduce> "When text is set in all capital letters, reading speed is slowed about 13 to 20 percent. Reading speed is optimal when  uppercase and lowercase letters are used. When extra emphasis is needed, bold has been found to be a better cue than uppercase."
08:14:20 <sithisbitch> upper > lower > mixed
08:14:28 <sithisbitch> esay to difficult
08:14:28 <mm_freak_> sithisbitch: your brain doesn't read the actual letters, but shapes
08:14:40 <dmwit> mm_freak_: Again, I think his point is that's only true because we are so much more used to lowercase than upper. Which seems quite plausible to me.
08:14:45 <mm_freak_> that's why properly typeset books are much easier to read than office documents
08:14:47 <sithisbitch> your brain doesn't read the actual letters, but shapes >> reading shapes... oh it's what we call read :D
08:14:57 <mm_freak_> dmwit: i don't agree about that
08:14:59 <benmachine> merijn: essentially, yes. I wonder if one of the various concurrency libraries will do this for you
08:15:20 <benmachine> merijn: it's a fairly common problem (alongside, if your main thread quits, then everything else *does* die)
08:15:40 <mm_freak_> BRIAN vs BRAIN is harder to differentiate than brian vs. brain
08:15:51 <dmwit> ...for you
08:15:52 <benmachine> merijn: I wouldn't have a catch that quits, just one that threw the exception upstream
08:16:00 <mm_freak_> dmwit: for everyone
08:16:00 <merijn> benmachine: Ah, bugger
08:16:11 <benmachine> for the main thread or whoever to deal with
08:16:14 <atriq> mm_freak_, I find the former easier than the latter
08:16:18 <dmwit> Do you have data to back up this claim?
08:16:18 <sithisbitch> mm_freak_, for you, not for me
08:16:46 <merijn> benmachine: In my case it's non-sensical, it can only happen if the compiler generating my code has failed and produced incorrect code due to which some invariants don't hold
08:16:56 <merijn> benmachine: Meaning any attempt to try and continue is pointless
08:17:03 <benmachine> merijn: ah, fair enough
08:17:05 <mm_freak_> dmwit: any good introduction to typography references enough material to back this up
08:17:13 * dmwit wonders: what data would I consider acceptable for the claim "everybody does X"?
08:17:29 <benmachine> merijn: http://hackage.haskell.org/package/async looks like it might make exception handling with threads nicer
08:17:35 <quuuux> iirc, British road engineers did some testing on all uppercase vs title case on motorway signs in the 60s
08:17:35 <dmwit> mm_freak_: Any good introduction to typography is aimed at people producing material for other people who read lower-case letters all day.
08:17:43 <quuuux> title case won handily, again iirc
08:19:23 <mm_freak_> ok, let me adjust my claim:  it's easier to learn reading lower case than upper case
08:19:33 <dmwit> I don't believe you have data about that, either.
08:19:33 <sithisbitch> mm_freak_, false
08:19:47 <dmwit> I believe you have data saying it's easiest to read what you read most often.
08:19:49 <dmwit> That's what I believe.
08:19:54 <sithisbitch> uppoercase letter are more distinct than lower case
08:19:56 <mm_freak_> sithisbitch: true, and this is easy to see:  there are fewer graphic differences between upper case letters
08:19:57 <sithisbitch> aeo AEO
08:19:58 <merijn> Let me adjust the claim: This conversation is pointless and off-topic
08:20:12 <mm_freak_> sithisbitch: to see that just convert your nickname to upper case
08:20:20 * dmwit shuts up because merijn is very right
08:20:23 <sithisbitch> for me it's the inverse there are fewer grpahic diff between lower case letter
08:20:40 <sithisbitch> merijn, of course
08:20:49 * mm_freak_ shuts up, because merijn is very right and i feel like i'm feeding a troll here
08:21:38 * hackagebot clocked 0.4.1.2 - timer functionality to clock IO commands  http://hackage.haskell.org/package/clocked-0.4.1.2 (SoenkeHahn)
08:21:40 * hackagebot SNet 0.1.0 - Declarative cordination language for streaming networks.  http://hackage.haskell.org/package/SNet-0.1.0 (MerijnVerstraaten)
08:21:40 <merijn> Using an unallocated top level name produces a warning on Hackage? No wonder we have this pointless hierarchy >.>
08:22:29 <mm_freak_> merijn: also you have a typo in the package description of SNet =P
08:22:43 <mm_freak_> a subtle one =)
08:23:03 <merijn> mm_freak_: If you're gonna say coördination I'm gonna slap you
08:23:03 <Polarina> I noticed that as well.
08:23:14 <merijn> If it's good enough for NYT it's good enough for me
08:23:30 <quuuux> let's just all move over to Shavian
08:23:50 <quuuux> boom, phonetic writing system!
08:23:57 <mm_freak_> merijn: my cultural background is probably not enough to understand that
08:24:08 <merijn> The fact that Americans can't spell properly because typing diaeresis is to hard is none of my concern :p
08:24:30 <benmachine> merijn: if it helps, I ignore the warning
08:25:52 <benmachine> cömpöse key <3
08:25:57 <merijn> mm_freak_: coördination is the "true and proper" spelling, but due to US cultural influence most people have start following the American way of dropping punctuation from the word, which means it has by now become uncommon
08:26:07 <merijn> Same for coöperate, etc.
08:26:13 * quuuux thinks we should steal PyPI's classifier list
08:27:14 <merijn> Because otherwise how could you tell whether to pronounce it "co op"/"co ord" instead of coop/coord (not that English pronounciation is in anyway tied to spelling anyway...)
08:27:21 <Polarina> merijn, with that argument alone, we can probably get ourselves all they way back to Old English, if not even further.
08:27:48 <ParahSa1lin> only the new yorker puts the diaresis in there, to look pretentious
08:28:14 <ciaranm> merijn: aww, that's cute. you think english words tell you how to pronounce them. YOU SOUND FRENCH.
08:28:25 <atriq> I generally use a hyphen
08:28:28 <atriq> co-operate
08:28:29 <merijn> ciaranm: Hardly, French isn't much better :p
08:28:47 <ciaranm> french is at least one language
08:28:51 <ParahSa1lin> french pronunciation is regular
08:29:04 <merijn> ParahSa1lin: I've been pretentious ever since I found out the difference between m-dash and n-dash xD
08:29:04 <mm_freak_> blame ASCII
08:29:15 <ParahSa1lin> it's got more vowels and diphthongs than any other language, but its regular
08:29:34 <n-dolio> It certainly seems to be the "lets you act like a jackass" spelling. Like most spellings other than the American one, apparently.
08:29:39 <frerich> merijn: Any sources to back up the claim that "coördination" is the "true and proper" spelling?
08:29:48 <ciaranm> "courriel". enough said.
08:29:55 <ParahSa1lin> the new yorker
08:30:13 <ParahSa1lin> i dont think people in oxford even put the diaresis in there
08:30:36 <benmachine> frerich: philosophically speaking I'd say there's a little doubt as to whether there is such a thing as "true and proper" spelling :P
08:31:42 <quicksilver> I occasionally see diereses on "naive" and "chloe" but I've never seen one on cooperate.
08:32:15 <sithisbitch> ParahSa1lin, it's maybe the only language in the world with a regular prononciation
08:32:41 <ciaranm> japanese is pretty regular
08:33:02 <quuuux> there are many, many languages with entirely predictable pronunciation from the spelling
08:33:11 <sithisbitch> maybe, but syllabe didn't sound equally in time
08:33:14 <ParahSa1lin> i think all the european romance languages have regular pronunciation
08:33:24 <sithisbitch> french is metronome
08:33:29 <ParahSa1lin> spanish is certainly the simplest, most regular
08:33:31 <merijn> ParahSa1lin: Dutch and German are pretty regular too
08:33:32 <sithisbitch> otherwise it's a mistake
08:33:37 <frerich> As far as I can tell, the diaresis is merely an indicator of how to pronounce subsequent vowels, but it's not - at least in english - a separate character (unlike, say, a vs. ä in german).
08:33:42 <sithisbitch> spanish is totally no regular
08:33:49 <wilfredh> what's the easiest way to get the parent directory of a given FilePath ?
08:33:57 <ParahSa1lin> yeah, most languages that have a homogeneous origin are regular
08:33:57 <Clint> spanish is about the only european language that's close to regular
08:34:06 <byorgey> frerich: ä in German is not a dieresis.  It's an umlaut.
08:34:06 <sithisbitch> after french
08:34:22 <carpi> can someone please tell me what "Could not deduce (a ~ Double) means?
08:34:29 <frerich> byorgey: The whole character is, but the two dots above are not I think?
08:34:30 <geekosaur> quicksilver, go back far enough and you'll see it on that and other words
08:34:34 <Clint> the two dots are a trema
08:34:43 <byorgey> carpi: ~ means equality of types.
08:34:43 <Polarina> wilfredh, I would say to append "/../" if you're looking for a quick hax.
08:34:45 <ParahSa1lin> i think even irish is regular, though the pronunciation of the letters does not correspond with any other language that uses roman characters
08:35:06 <quuuux> ParahSa1lin: it does to Scottish Gaelic, boom
08:35:09 <byorgey> carpi: so that error means that for some reason the type checker thinks that a ought to be equal to Double, but it could not prove it
08:35:11 <quuuux> and Manx!
08:35:20 <geekosaur> (I *have* seen it on coöperate and zoölogy and other words, but ypu have to go back to at least the 1910s to see it at all regularly)
08:35:47 <carpi> byorgey: how may i help the type checker ?
08:35:56 <ParahSa1lin> i bet french still uses diaeresis marks, because french is actually regular
08:35:57 <wilfredh> Polarina: if that's the best I can do, will do. Thanks :)
08:36:39 <Polarina> wilfredh, it's far from the best, I can tell you that. Just something I thought up. I'll see if I can find something better.
08:36:51 <merijn> geekosaur: It's rare in English yeah, but I'm used to it from Dutch so it happens out of reflex and then I just post-hoc justify it ;)
08:36:59 <byorgey> frerich: hmm, sorry, I was wrong
08:37:23 <fmap> @type System.FilePath.takeBaseName . System.FilePath.takeDirectory
08:37:24 <lambdabot> FilePath -> String
08:37:26 <byorgey> carpi: that depends entirely on the situation.  If you paste your code I could have a look.
08:37:34 <frerich> byorger: Really? I'm german, and I would've called ä an umlaut :-)
08:37:43 <geekosaur> French uses them but needs them less (at least in the subset I'm familiar with)
08:37:54 <Clint> mostly just with oë
08:37:58 <quicksilver> probably time to move the orthography and pronunciation chatter to another forum ( #haskell-blah ? ) and let people trying to ask about haskell get heard.
08:38:27 <byorgey> frerich: I mean I was wrong about umlaut and dieresis really being two separate things.
08:38:29 <sithisbitch> umlaut and tream are not the same thing
08:38:34 <sithisbitch> (trema)
08:38:40 <Clint> nor is diaresis
08:38:41 <hpaste> carpi pasted “a ~ Double” at http://hpaste.org/75246
08:38:51 <Clint> e
08:38:58 <byorgey> anywan.  back to Haskell? =)
08:39:01 <byorgey> *anyway
08:39:12 <fmap> wilfredh: what should result be for "/a/b/c.d" ?
08:39:17 <carpi> can you please take a look ? i can't pinpoint the location of the problem
08:39:18 <byorgey> carpi: please paste the entire error message as well
08:39:24 <wilfredh> fmap: "/a/b"
08:39:46 <carpi> byorgey: one moment
08:39:57 <fmap> then System.FilePath.takeDirectory
08:40:07 <quicksilver> carpi: I suspect the root of your problem is that (/) is not defined on all Num types
08:40:25 <fmap> wilfredh: or `^. directory' if you are familiar with lenses
08:40:25 <quicksilver> carpi: the *symptom* of your problem is the fact that haskell wants to give ops a monomorphic type
08:40:28 <hpaste> carpi pasted “a ~ Double” at http://hpaste.org/75247
08:40:36 <quicksilver> which will be [(Char,Double -> Double -> Double)]
08:40:38 <Polarina> wilfredh, maybe this is something you want: http://hackage.haskell.org/packages/archive/filepath/1.3.0.1/doc/html/System-FilePath-Posix.html#v:takeDirectory
08:40:57 <byorgey> quicksilver strikes again!
08:41:02 <quicksilver> carpi: so, simp can't compile because 'simp' wants operators which work on all Nums
08:41:02 <wilfredh> takeDirectory is perfect, thanks
08:41:09 <quicksilver> but 'ops' contains operators which only work on Doubles.
08:41:32 <wilfredh> lenses are probably are bit too much cognitive load at this point, I will investigate later :)
08:41:38 * hackagebot network-metrics 0.2.4 - Send metrics to Ganglia, Graphite, and statsd.  http://hackage.haskell.org/package/network-metrics-0.2.4 (BrendanHay)
08:41:51 <byorgey> this is a poster example of why one should give type signatures for all top-level declarations
08:42:32 <byorgey> in trying to give a signature to ops, one would probably figure out the problem.  With no type signature for ops, one gets a cryptic error message in some other part of the code.
08:42:58 <quicksilver> it is perhaps an example of problems with the monomorphism restriction too
08:43:09 <quicksilver> although all that's done is change the error message.
08:43:11 <byorgey> quicksilver: also a good point.
08:43:27 <quicksilver> (without it, you'd have got an error like 'can't infer Num a => from Fractional a => )
08:43:38 <quuuux> byorgey: I broke a program yesterday by adding GHC's inferred type to a top-level definition
08:43:43 <byorgey> though that would probably be a better error message
08:43:54 <byorgey> i.e. it would give a better hint as to the real problem.
08:44:03 <carpi> would this work on ops ? oops :: Num a => [(Char, (a -> a -> a))]?
08:44:20 <byorgey> quuuux: yes, there are some weird corner cases where that can happen.
08:44:27 <quicksilver> that's a good type, carpi
08:44:34 <quicksilver> but you will find (/) won't fit in.
08:44:54 <quicksilver> you get the error in a more natural place with that type specified at least.
08:45:06 <fmap> wilfredh: lenses are very useful if you want to change parts of path later, otherwise takeDirectory is good enough
08:45:21 <byorgey> quuuux: but if you just paste in GHC's inferred type you aren't really getting any of the benefits of adding type signatures.
08:46:07 <byorgey> quuuux: if you have something whose type is really so complicated that you can't figure it out, then it's probably best just to leave it unannotated.
08:46:11 <carpi> quicksilver: you mean (/) doesn't work on types that are instances of Num?
08:46:28 <byorgey> in general the idea is to first write down what you *think* the type ought to be, and then let GHC check that you are correct.
08:46:36 <quuuux> byorgey: oh, no, it wasn't even complicated, and GHC inferred exactly what I got by hand
08:46:52 <quuuux> byorgey: it was a fun interaction with Rank2Types
08:46:54 <byorgey> quuuux: oh, I see
08:47:04 <byorgey> hehe
08:47:18 <byorgey> yes, Rank2Types cause interesting shenanigans with type inference
08:47:30 <quuuux> it confused me greatly because I added the type signature to try and debug something else
08:49:24 <thirsteh> the performance faq says that you should use strict monadic returns (return $! ...) whenever possible, then goes on to warn that using seq can have an adverse effect given compiler optimizations. Are there any cases where I don't want to write "return $!". I'm thinking that it's only when I'm not actually using the result (which is extremely rare), but maybe I'm missing something
08:49:24 <frerich> I often start adding type signatures even for non-toplevel functions when getting odd errors to trace down the place where my assumption diverges from what ghc actually deduces. Now that I think about it, it would be neat if an editor would show 'tooltips' or the like next to function definitions, showing me what it would deduce. Maybe I could spot the odd one earlier that way.
08:49:34 * frerich expects somebody to reply "emacs/vim can do that"
08:50:25 <thirsteh> or, I guess, when the monad is strict
08:51:24 <fmap> frerich: ghc-mod can do that actually
08:51:37 <fmap> or well, perhaps not
08:51:50 <fmap> it requires compilation
08:52:33 <carpi> quicksilver: by removing the entry for (/) from ops and by adding the prior mentioned type signature for ops .. the code compiles and works..
08:54:12 <quicksilver> carpi: yup.
08:54:19 <quicksilver> carpi: as you say, (/) doesn't work for Nums
08:55:01 <carpi> I don't understand why adding (/) to ops makes it not work? cos (/) works on types which are instances of Fractional, but aren't all types that are instances of Fractional also instances of Num?
08:55:07 <quicksilver> no.
08:55:13 <quicksilver> one example is Int
08:55:19 <quicksilver> > (3 :: Int) / 4
08:55:20 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
08:55:20 <lambdabot>    arising from a use o...
08:55:41 <nand`> what carpi asked is actually true
08:55:43 <nand`> but he mistated it
08:56:00 <nand`> all instances of fractional are also instances of num, but that doesn't help here
08:56:04 <nand`> because the reverse is not true
08:56:51 <carpi> so  i should be adding Num and Fractional to the type signatures of ops, evall and simp.. i think
08:57:35 <bitonic> I forget, how do I get a type that appears in the type signature of a class method in the body of a method instance?
08:57:39 <Palmik> Hmm, is it ever possible to mix type-families without undecidable instances?
08:57:57 <bitonic> Palmik: what do you mean with mix type-families?
08:58:23 <frerich> carpi: As you say, all types instantiating Fractional also instantiate Num - so you could just replace 'Num' with 'Fractional'.
08:58:29 <Palmik> So that the result of one type expression is used on rhs one another for different type family.
08:58:34 <Palmik> bitonic ^
08:59:40 <bitonic> you mean recursively defined type families?
09:00:10 <bitonic> that'd send the compiler into a loop, so I get an UndecidableInstances vibe :P
09:00:50 <Palmik> Not recursively. I have F1 defined "on its own" and F2 defined in terms of F1.
09:02:50 <Philippa> it is a sad day: the internet is refusing to give me coq. Coq is down.
09:03:05 <Philippa> so, anyone know where I can find a coq mirror?
09:03:42 <bitonic> Palmik: uhm, right.
09:04:48 <bitonic> Palmik: I don't see why that would be a problem
09:04:52 <ClaudiusMaximus> Philippa: tried archive.org wayback machine?  might be 6mo out of date...
09:05:01 <bitonic> Palmik: I just wrote one
09:05:23 <ClaudiusMaximus> Philippa: otherwise google cache / bing cache might have some docs
09:05:29 <Palmik> OK, so it's probably not a problem every time... that basically what I was asking.
09:05:48 <hpaste> bitonic pasted “Palmik” at http://hpaste.org/75250
09:05:51 <Philippa> unfortunately I'm mostly looking for binaries. Oh well, guess I wait a few days
09:06:02 <Philippa> I just realised I'm talking too much metatheory lately to risk talking utter shite :-)
09:06:18 <mcstar> you can switch to HOL
09:07:17 <quuuux> how recent do you need the binaries to be? You could see if any distros have a suitable version packaged
09:07:27 <bitonic> yeah, debian definitely does
09:16:49 <atriq> I've just realised my entire understanding of the lens package
09:16:59 <atriq> Is based on an analogy with a Gary Larson cartoon
09:17:18 <mysticc> @hoogle liftIO
09:17:19 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
09:17:19 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
09:17:19 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
09:18:53 <byorgey> atriq: please share!
09:19:13 <atriq> I'll see if I can find it
09:20:18 <carpi> isn't Fractional the more specific type compared to Num
09:20:33 <atriq> ...yes
09:20:38 <atriq> byorgey, the one with the dogs
09:20:50 <atriq> So, most of them
09:20:56 <byorgey> um, aren't there like six million... right.
09:21:09 <bitonic> damint.  how do I refer to something in the type sig of an instance method?
09:21:09 * sithisbitch never understood why mathematics classes were not used to design haskell.
09:21:21 <bitonic> mathimatics classes?
09:21:27 <sithisbitch> group, ring, field etc
09:21:37 <sithisbitch> we got that shitty num fractional etc instead
09:22:11 <byorgey> sithisbitch: uh, because the designers of Haskell aren't perfect, and did what they could with limited time and resources?
09:22:17 <byorgey> it's not like it's some conspiracy
09:22:39 <carpi> i think i finally understand this fractional, num mystery
09:22:46 <atriq> byorgey, something to do with waltzing also
09:22:53 <sithisbitch> byorgey, yes but, each time I want to implements N um i can't
09:23:05 <Cale> sithisbitch: Many of the instances which we want for those classes *aren't* instances of the mathematical concepts.
09:23:10 <sithisbitch> I cajnt' implement additive law
09:23:27 <Cale> In particular, anything built on top of Float or Double is not likely to be a ring.
09:23:50 <sithisbitch> i can't explain to haskell that (-> NUm) is Num
09:24:05 <Cale> what?
09:24:11 <atriq> Because you can't do type sections?
09:24:15 <Cale> > (sin^2 + cos^2) 6
09:24:16 <lambdabot>   0.9999999999999999
09:24:30 <sithisbitch> in mathematics I can add functions
09:24:34 <sithisbitch> but in haskell i can't
09:24:44 <Cale> > ((+5) + (*4)) 7
09:24:44 <sithisbitch> because it want things to implements Show or Eq
09:24:45 <lambdabot>   40
09:24:51 <nand`> > sin + cos $ 5
09:24:51 <koeien> sithisbitch: not anymore in GHC.
09:24:52 <lambdabot>   -0.6752620891999122
09:25:00 <sithisbitch> koeien, ha... interresting
09:25:01 <nand`> of course you can add functions
09:25:07 <sithisbitch> but I'm wtih haskell platform
09:25:09 <Cale> Also, you can just put in stupid instances of Show and Eq
09:25:11 <carpi> quicksilver: thanks for the hints along the way
09:25:11 <sithisbitch> maybe it's late
09:25:23 <sithisbitch> Cale, that's exactlty what I don't want to do
09:25:35 <Cale> Well, it's not that bad.
09:25:45 <sithisbitch> and what for abs and signum ?
09:25:49 <atriq> byorgey, it's gonna be hard to find it online
09:25:52 <koeien> I'd rather not have an accidentally wrong instance of Eq in scope.
09:25:58 <atriq> And I can only half remember it
09:26:06 <Cale> sithisbitch: Pointwise abs and signum, of course.
09:26:07 <bitonic> is there really no way I can refer to a type parameter in instance methods?  do I have to define an helper function?
09:26:16 <atriq> A couple of dogs literally waltz in, take something and waltz out again
09:26:23 <byorgey> atriq: "as witnesses later recalled, the two dogs just waltzed in, grabbed the cat, and waltzed right out"?
09:26:27 <atriq> That's the one
09:26:40 <sithisbitch> Mathematicvs goit an history of 3000 years, but computer scientists think that they can junk iot like that
09:26:43 <byorgey> I found a tiny picture of it which is part of a larger picture
09:26:47 <atriq> Yeah
09:26:53 <Cale> sithisbitch: Huh?
09:27:04 <Polarina> nand`, how does that work? Adding sin and cos together?
09:27:07 <atriq> But anyway, I picture lenses as working as you fmap in, take the cat, and fmap out
09:27:16 <byorgey> atriq: hehehe
09:27:18 <sithisbitch> mathematics is experienced with 3000 years, computer science is really young and forget all what the mathematicians did
09:27:21 <Cale> Polarina: an instance of Num for functions whose codomain is an instance of Num
09:27:26 <nand`> Polarina: sin + cos = \x -> sin x + cos x
09:27:30 <byorgey> atriq: I like it =)
09:27:31 <quicksilver> sithisbitch: rubbish.
09:27:32 <koeien> Polarina: (f + g) = \x -> f x + g x
09:27:39 <Cale> sithisbitch: How can you honestly say that in this channel? :)
09:27:44 <quicksilver> sithisbitch: the haskell designers were/are good mathematicians.
09:27:44 * Polarina seems to love that new instance now.
09:27:57 <sithisbitch> NO they are not
09:27:58 <quicksilver> sithisbitch: they made choices for various reasons including the ones Cale mentioned.
09:28:05 <sithisbitch> otherwise they will have designe mathematical classes
09:28:09 <sithisbitch> and not that shitty thing
09:28:10 <Cale> sithisbitch: Haskell users are actively stealing concepts from category theory in order to structure the design of libraries.
09:28:12 <koeien> sithisbitch: the haskell designers knew what groups and rings were
09:28:26 <sithisbitch> they don't have to think, they have to applied 3000 years experience
09:28:26 <koeien> sithisbitch: they just made a (wrong, imho) tradeoff
09:28:42 <Cale> sithisbitch: Also, groups and rings are not 3000 years old
09:28:44 <sithisbitch> they did a lot of things wrong
09:28:55 <nand`> sithisbitch: have you seen the various numerical libraries that take more mathematical approaches to the whole hierarchy?
09:29:02 <nand`> I find them near impossible to work with, personally
09:29:20 <Cale> They're like, 19th century ideas.
09:29:21 <sithisbitch> I just say that if they were the mathematical category,  we could do what we want
09:29:30 <byorgey> sithisbitch: Please stop whining.  Either suck it up, make your own numerics library, use an existing one (e.g. http://www.haskell.org/haskellwiki/Numeric_Prelude), or use a different language.
09:29:36 <quicksilver> sithisbitch: most people who try to do difficult things which have not been done before get some things wrong.
09:29:37 <sithisbitch> today, it's impossible because they thought that waht mathetician take 3000 years to invent is shit
09:29:40 <mcstar> well, at least C got the numerical tower right
09:29:43 <mcstar> (sic)
09:29:46 <thirsteh> the performance faq says that you should use strict monadic returns (return $! f x) whenever possible, then goes on to warn that using seq can have an adverse effect given compiler optimizations. Are there any cases where I don't want to write "return $! f x". I'm thinking that it's only when I'm not actually using the result (which is extremely rare), but maybe I'm missing something.. when the monad is strict?
09:29:47 <quicksilver> sithisbitch: that doesn't mean they aren't good mathematicians.
09:29:55 <byorgey> sithisbitch: also, unfounded and untrue accusations don't help either.
09:30:14 <sithisbitch> quicksilver, i said, that they are typical computer scientist, they thought that mathematics (and 3000 years experience) is useless
09:30:20 <quicksilver> sithisbitch: then you are wrong.
09:30:22 <mcstar> stop this 3k years bs
09:30:29 <sithisbitch> but in decades, Haskell will have the correct mathematic class
09:30:47 <sithisbitch> quicksilver, you think that you can throw to garbage 3000 years of intelligence ?
09:31:05 <quicksilver> sithisbitch: the haskell designers were excellent mathematicians, many of them leaders in their fields.
09:31:14 <Philippa> I think I can thow you to garbage, sithisbitch
09:31:15 <quicksilver> sithisbitch: you simply don't know what you're talking about.
09:31:20 <Philippa> *throw
09:31:22 <benmachine> sithisbitch: in fairness, a lot of the last 3000 years of mathematics was crap
09:31:25 <Cale> sithisbitch: Dude, literally everyone is well aware of the tradeoffs which were made in the numeric hierarchy in Haskell, and there are many ideas for how to improve it. Merely replacing it with Group/Ring/etc. would be horribly insufficient to deal with most real-world uses. Still there are things which could be done to make the hierarchy better, and everyone knows what they are.
09:31:28 <sithisbitch> yes, but they thought that mathematics was useless for computer science
09:31:28 <thirsteh> sithisbitch: you think you should squander 13.7 billion years of cosmic evolution on trolling?
09:31:34 <benmachine> "oh negative numbers, they can't possibly exist, whoever thinks otherwise is being ridiculous"
09:31:35 <quicksilver> sithisbitch: on the contrary.
09:31:47 <quicksilver> sithisbitch: they *specifically* chose to design a language with a sound mathematical foundation.
09:31:59 <Philippa> 3000 years of mathematicians didn't have to deal with all the issues involved in programming language design. You think you can walk into a new domain and know it all? Guess again
09:32:01 <bitonic> the haskell designers are all still alive eh :)
09:32:01 <quicksilver> sithisbitch: which is a choice different from almost all other programming languages.
09:32:06 <sithisbitch> today, numeric i can't produce clean code with num class, because of show, eq, abs etc...
09:32:19 <quicksilver> sithisbitch: that's quite different from "thinking mathematics is useless"
09:32:23 <Philippa> sithisbitch: so use another class already
09:32:29 <n-dolio> If you think it's easy to design a "mathematically correct" class hierarchy, you clearly haven't tried.
09:32:29 <sithisbitch> I have to hack, to inject my instances uin Num
09:32:39 <Philippa> you don't even have to have Num's stuff in scope
09:32:42 <nand`> am I the only one thinking that sithisbitch sure knows how to troll #haskell, a rare occurrence?
09:32:44 <sithisbitch> n-dolio, every algebra book explain it
09:32:49 <benmachine> anyway there are like 30 libraries that try to do maths in Haskell "properly"
09:32:50 <bitonic> sithisbitch's question is legitimate, but he's just trolling now
09:32:51 <byorgey> nand`: hehe, indeed
09:32:55 <benmachine> all of them are unsatisfactory in some way
09:33:04 <Philippa> sithisbitch: no, it doesn't. They don't deal with the constraints of being typeclasses
09:33:06 <Polarina> Allright everyone, enough of the flamewars!
09:33:08 <n-dolio> sithisbitch: Nope.
09:33:15 <Cale> sithisbitch: Please come back when you've rewritten the Prelude with better classes and can show us exactly what it is that you'd prefer to have :)
09:33:25 <sithisbitch> i just in war against computer scientists which did that kind of things. But in decades error will be corrected and I'll see my ring, field, group calsses
09:33:29 <Philippa> after all, if it's just copying out the textbook it shouldn't take too long, right?
09:33:35 <bitonic> Saizan, quicksilver: so you're telling me there is no way to refer to type variable in instance methods :(
09:34:14 <koeien> not sure what you mean exactly, but enabled ScopedTypeVariables might help
09:34:26 <Cale> I think very few of the people here have *not* at least put some thought into how to improve the numeric hierarchy. My background is in mathematics, and after a fair amount of consideration, I think that what was done, while it has a few problems, is much less bad than you're suggesting.
09:34:31 <bitonic> koeien: well but I don't have a type signature
09:34:38 <bitonic> since it's a class instance
09:34:47 <sithisbitch> computer scientists are just dumbass which forget mathematic history and repoduce exactly the same errors... and the history will repeat
09:35:05 <Cale> sithisbitch: What you are saying is blatantly untrue.
09:35:27 <benmachine> @quote Cale.*trolls
09:35:27 <lambdabot> No quotes match. I've seen penguins that can type better than that.
09:35:30 <benmachine> oh
09:35:32 <benmachine> never mind
09:35:43 <Cale> sithisbitch: Consider the operations in RealFloat
09:35:48 * sithisbitch shuts up.
09:35:54 <mcstar> haskell is way closer to actual mathematics than any other language that has a chance to be used by the masses
09:35:58 <Cale> sithisbitch: There is nothing in standard mathematics to formalise those operations.
09:36:21 <mcstar> sithisbitch: go, and use Axiom please, if you are not satisfied
09:36:30 <Cale> Even Floating, which consists entirely of standard mathematical operations, isn't provided for by any standard abstraction.
09:36:46 <Philippa> Cale: oxymoron :p
09:37:03 <Philippa> (FP stuff is fucking weird, but we have to pretend it adds and multiplies...)
09:37:22 <Cale> Well, right.
09:37:32 <Cale> It would be an abuse to call Double a ring.
09:37:47 <Cale> But calling it a sort of number? I'm fine with that.
09:37:57 <quicksilver> it's kinds-of an abuse to suggest it implements Eq
09:38:03 <quicksilver> but it's quite hard to get these abstractions right.
09:38:11 <quicksilver> it's trade-offs everywhere you look
09:38:23 <benmachine> it would be nice if Double supported Ord and Eq in a non-standard way
09:38:33 <benmachine> that agreed with the standard way except on the awkward bits that screw it up
09:38:50 <benmachine> and then the standard way can be in a module somewhere
09:38:50 <Cale> heh, where does NaN fit into the total ordering?
09:38:56 <Cale> before -Infinity?
09:38:59 <quicksilver> do you want to sopport pattern matching on doubles? ( f 0 = 0; f x = 1/x )
09:39:02 <benmachine> sure, why not
09:39:28 <benmachine> actually, no, all NaNs are scattered on the interval [7,8]
09:39:37 <quicksilver> Cale: if all you want to do is permit Double keys in Data.Maps (something you might well want) then it doesn't matter where NaN ends up.
09:39:38 <Cale> lol
09:39:40 <quicksilver> for example.
09:39:48 <Cale> quicksilver: this is true
09:40:03 <Cale> lol, put NaN between positive and negative 0
09:40:09 <benmachine> haha
09:40:10 <benmachine> <3
09:40:28 <carpi> has the Random library been taken out from the standard packages?
09:40:38 <quicksilver> NaN is the flicker on the corner of your shadow when you glance quickly into a mirror.
09:40:47 <benmachine> carpi: it doesn't come with GHC any more
09:40:55 <benmachine> carpi: it's probably still in the platform?
09:41:11 <carpi> i tried import Random. doesn't work
09:41:19 <carpi> though its still mentioned in the docs on the website
09:41:25 <rwbarton> well it's definitely not called that any more
09:41:30 <rwbarton> @hoogle random
09:41:31 <lambdabot> System.Random class Random a
09:41:31 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
09:41:31 <lambdabot> package random
09:41:37 <benmachine> carpi: oh, Random is in the haskell98 module
09:41:45 <benmachine> carpi: using the haskell98 package is a bit awkward
09:41:49 <benmachine> and probably not a good idea
09:41:54 <benmachine> just switch to System.Random instead
09:42:33 <Cale> Something 1000x more productive than working on the numeric hierarchy would be studying pseudorandom number generators having a split operation having (at least relatively) strong statistical guarantees.
09:42:54 <carpi> benmachine: i don't think i have System.Random im using 7.4.1
09:43:04 <benmachine> carpi: do you have cabal-install?
09:43:28 <Cale> I'm really unhappy about how none of the people who know a lot about PRNGs seem to have completely ignored such an operation.
09:43:35 <Cale> er, how all*
09:43:41 <carpi> don't think i do. but ill install.
09:44:03 <mcstar> Cale: how about a new generator with a different seed? should be totally independet for good algs. ?
09:44:04 <benmachine> carpi: did you get the haskell platform?
09:44:08 <benmachine> carpi: how did you get GHC?
09:44:20 <benmachine> mcstar: yes but where do you get the seed from?
09:44:33 <carpi> benmachine: using ubuntu .. so i got it using ubuntu's package manager ... synaptic
09:44:35 <atriq> 17
09:44:39 <mcstar> just make sure, you dont start 2 generators with the same seeds
09:44:41 <atriq> That's the new seed
09:44:46 <mcstar> benmachine: /dev/random
09:44:47 <Cale> mcstar: Well, okay, so suppose I take the seed for my generator g, and I use it to generate two new seeds in sequence, right?
09:44:48 <benmachine> atriq: pretty random
09:44:54 <benmachine> mcstar: that uses IO
09:45:00 <mcstar> yeah
09:45:04 <atriq> unsafePerformIO
09:45:07 <benmachine> mcstar: we'd like to be able to split an RNG purely
09:45:11 <atriq> The wrong answer to every question
09:45:14 <mcstar> i se
09:45:16 <mcstar> e
09:45:16 <benmachine> atriq: that's terrible and you should feel bad about yourself
09:45:37 <Cale> mcstar: Now, are the sequences of numbers generated by g' and g'', these two new seeds correlated with each other? Are the correlated with g?
09:45:47 <benmachine> carpi: there might be a synaptic package for haskell-platform, I froget
09:45:50 <benmachine> forget
09:45:51 <Cale> or, I mean, the sequence of numbers produced by g
09:47:03 <Cale> If I take triples (x,y,z) of corresponding numbers from the sequences generated by g, g', and g'', do I end up with a proper uniform scattering of points, or do I get some bunch of planes, or other surfaces showing up?
09:47:22 <mcstar> for LCG you probably will
09:47:38 <mcstar> but noone uses those
09:47:40 <Cale> Yeah, and in other cases, I have no idea.
09:48:02 <Cale> Nobody seems to have actually written down any results about whether or not this is safe to do.
09:49:22 <Cale> Because everyone studies these generators under the assumption that they'll be threaded linearly through a computation, and not split down two parallel branches.
09:49:36 <jj> hi
09:49:43 <Cale> hello!
09:49:54 <Polarina> Welcome.
09:51:33 <mcstar> i wonder what is the critical number of persons responding to a 'hi', that leads to an avalanche of responses
09:53:12 <Sculptor> ! usually helps. hi!
09:53:31 <Cale> In fact, I think splitting should be *the* fundamental operation on a PRNG, and people shouldn't be studying just the sequence of results produced, but the binary/k-ary/etc. tree. The reason that the current PRNGs are annoying is the same reason that writing natural numbers in unary is annoying. :)
09:54:21 <benmachine> Sculptor: hi!!
09:54:33 <Sculptor> hi!
09:54:39 <atriq> Hi!
09:54:56 <mcstar> hi!
09:55:16 <Polarina> Hi!
09:55:59 <benmachine> I feel like we've started some sort of strange dance
09:56:40 * hackagebot split 0.2.1.0 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.2.1.0 (BrentYorgey)
09:57:07 <Cale> ^^ teehee
09:59:10 <byorgey> Cale: I was talking with someone at ICFP who has actually been doing work on theoretical basis for splitting PRNGs
09:59:15 <Cale> Nice!
09:59:29 <byorgey> Cale: and if I understood correctly, they actually have a specific PRNG which supposedly has good splitting properties
09:59:44 <Cale> Ah, that makes me much happier
10:00:14 <byorgey> Cale: actually, he gave a talk about it at the Haskell Implementor's Workshop, though I must confess I didn't get much out of the talk
10:00:45 <byorgey> Michał Pałka
10:00:48 <Cale> oh, there are videos of that usually -- I wonder if they're online
10:01:18 <byorgey> yes, they are
10:01:23 <Cale> http://www.youtube.com/watch?v=ZU4qWn9QfEM
10:01:25 <byorgey> I am trying to find you a link
10:01:26 <nand`> mcstar: at least there'd be a hard upper cap on the number of greetings, if you assume each person sends each other person at most one greeting per session
10:01:41 * hackagebot split 0.2.1.1 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.2.1.1 (BrentYorgey)
10:02:31 <mcstar> i didnt think in termns of 'addresed welcomes', just say hi in the wild
10:02:40 <mcstar> wilde
10:02:59 <byorgey> Cale: yes, that's the one
10:04:17 <mcstar> im the 26th viewer!
10:06:33 <kirindave> Man, quasi-quotes are cool.
10:06:38 <kirindave> Sorta evil and terrifying
10:06:41 <kirindave> but really cool all the same.
10:06:44 <carpi> benmachine: i thought installing ghc will give me everything. now i see i have to install the haskell-platform as well
10:07:01 <benmachine> carpi: of course installing GHC won't give you everything
10:07:04 <benmachine> there's a lot of everything :)
10:08:03 <byorgey> Cale: Michał said they are in the process of writing it all up so I hope we can expect a nice paper about it soon.
10:08:20 <carpi> benmachine: installing haskell-platform and trying out leksah
10:09:01 <mcstar> " It???s quite simple: the C programming language and others of its time provided an insufficient kind of Kleisli arrow! "
10:09:18 <Cale> byorgey: yeah, the details in that talk were kinda hard to see, but I'm glad to hear that this exists. Hopefully it'll actually replace StdGen.
10:10:21 <Cale> People already complain about the size of GHC, imagine how they'd complain if it came with a complete copy of Hackage :)
10:10:28 <ClaudiusMaximus> best random number generator http://www.cim.mcgill.ca/sresvn/audioscape/audioscape_resources/PDa/src/x_misc.c
10:10:35 <ClaudiusMaximus> (sorry for ot)
10:15:08 <Cale> Philippa: It seems that Coq is back up.
10:15:39 <nand`> mcstar: does C actually have the identity for that?
10:15:42 <nand`> like a no-op instruction
10:16:21 <mcstar> idk
10:16:31 <otters> ;
10:16:41 <Philippa> Cale: thanks
10:16:41 <Philippa> Cale: still having problems here, meh
10:16:59 <nand`> I think if I asked ##c whether it has an identity for its implicit kleisli composition I'd be labelled as a troll
10:17:12 <mcstar> nand`: that quote was addressed at the inability for c functions to hande errors
10:17:12 <Cale> http://coq.inria.fr/download
10:17:15 <Cale> works for me
10:17:17 <otters> I think if you asked that you would be a troll
10:17:27 <nand`> mcstar: makes sense
10:17:28 <Cale> coq.inria.fr is an alias for www.lix.polytechnique.fr.
10:17:28 <Cale> www.lix.polytechnique.fr is an alias for oumix.lix.polytechnique.fr.
10:17:28 <Cale> oumix.lix.polytechnique.fr has address 193.55.176.29
10:19:54 <mcstar> nand`: on the language level, you can certainly write a kleisli identity, like, putting the argument of the call into a struct, and returning that
10:20:26 <mcstar> so that struct would be like a Maybe
10:20:46 <mcstar> the problem is, you cant compose those functions any longer
10:21:06 <mcstar> i think, but im just reading about this stuff
10:21:14 <mcstar> http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/
10:21:17 <mcstar> not bad ^
10:21:26 <nand`> I guess trying to reason about C as if it were based on kleisli arrows when it actually isn't based on kleisli arrows isn't exactly trivial
10:21:57 <nand`> ‘abstraction distraction’ that's a cute wordplay
10:22:00 <mcstar> you could do it with some global variables i think
10:22:22 <mcstar> and a convention, that all the functions you write, have to check if the global var signals error or not
10:28:35 <nand`> “If you open Wikipedia, or most category theory textbooks, and look up monads, they won’t look very much like what we just did. You’ll see something about an endofunctor, and two natural transformation, and properties about commuting triangles and squares.”
10:28:38 <nand`> hehe
10:31:41 * hackagebot spatial-math 0.1.6 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.1.6 (GregHorn)
10:34:46 <nand`> “applicative functors are weaker than monads, but more widely applicable”
10:34:47 <nand`> oh no you didn't
10:36:32 <teneen> What's the most idiomatic way to deal with the case when you want a where clause to be visible to all cases of a certain function?
10:36:41 * hackagebot not-gloss 0.4.3 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.4.3 (GregHorn)
10:37:28 <mcstar> what a stupid name
10:39:13 <kyagrd> mcstar: rarely stupid names like GNU gets its fame
10:39:47 <mcstar> but it is 3d, while gloss is 2d, so not easy to confuse them
10:40:06 <mcstar> anyway, maybe it is a great lib, idk, why not spend a little time on naming it?
10:41:38 <clahey> Has anyone tried doing mobile development in haskell?
10:41:46 <hiptobecubic> clahey, yes.
10:42:02 <mroman> How can I define a Show instance for newtype Foo a m = F (forall a. Num a => (a -> a -> m a))
10:42:28 <teneen> I want to make a where clause visible to all cases of a function, is it possible?
10:42:52 <Palmik> mroman, depends on what you want it to show.
10:42:59 <Jetbeard> mroman, however you want
10:43:19 <Jetbeard> teneen, it is if you use a case expression, as far as I'm aware
10:43:28 <jamiltron> teneen: What do you mean? Isn't that how where works?
10:43:31 <mroman> Can I declare an Instance (Show (Foo t Maybe))?
10:44:10 <teneen> Jetbeard: is a case expression the most idiomatic way? I feel it has some repitition
10:44:12 <kyagrd> mroman: you _can_ declare it but the problem is _how_
10:44:22 <mroman> Probably with FlexibleInstances...
10:44:22 <mroman> hm..
10:44:37 <mroman> Yes, that works.
10:45:33 <kyagrd> if you arnt' goning to show the content of the function it should be simple
10:49:27 <clahey> hiptobecubic: Were they successful?  Is there a framework?
10:49:41 <clahey> hiptobecubic: If so, what is it called?
10:50:21 <hiptobecubic> clahey, moderately i think? let me look
10:51:16 <mroman> hm.
10:51:20 <hiptobecubic> clahey, hmmm there was this http://stackoverflow.com/questions/5151858/running-a-haskell-program-on-the-android-os
10:51:26 <mroman>  Kind mis-match
10:51:26 <mroman>     The first argument of `Functor' should have kind `* -> *',
10:51:26 <mroman>     but `Foo Int Maybe' has kind `*'
10:52:01 <hiptobecubic> there is also some effort for ghc on arm
10:52:55 <centrinia> I have used ghc on the Raspberry Pi.
10:52:59 <centrinia> It isn't fun. :(
10:53:35 <Botje> did it give you a type error?
10:53:37 <solrize> so i want to use hexpat (a sax parser) to build a dom-like structure, i.e. there's a tree of stuff seen so far, and a currently active leaf node that i want to stuck new stuff underneath, and also to delete some subtrees once they're built and processed.  does that sound like it calls for a zipper?
10:53:46 <hiptobecubic> clahey, it seems like the best bet is to use a jvm language that gets as close as possible to being 'not bad'
10:55:05 <clahey> centrinia: What went wrong?
10:55:13 <centrinia> It is just slow.
10:55:18 <centrinia> Also, ghci isn't supported.
10:55:31 <clahey> centrinia: Slow to compile or slow to run the apps?
10:55:52 <centrinia> Slow to compile.
10:56:08 <centrinia> So I have to wait a good part of a minute upon each modification. :p
10:56:25 <centrinia> I shouldn't do the development cycle on the Pi itself. :p
10:57:46 <teneen> Can a LamdaCase take multiple arguments?
10:58:07 <Cale> teneen: It can match on a pair
10:58:13 <Cale> But otherwise no
10:58:24 <Cale> Well, you can nest them
10:58:45 <Cale> I think the use of lambda in the syntax was a bit odd. Case sections are a better way to think about what that is.
10:59:17 <Cale> It's like you've left the scrutinee out of a case expression and it's become a lambda, in a similar way that operator sections work.
11:00:45 <teneen> Cale: I want to use something like a multi-argument LambdaCase, so that a where clause can be visible from all clauses
11:02:20 <fmap> there is never enough syntactic sugar
11:02:53 <teneen> Cale: How can you nest LambdaCases?
11:04:59 <mcstar> ive given up on refined sugar
11:05:31 <Cale> teneen: by putting one as the result of another?
11:05:51 <teneen> Cale: How will you name the variables?
11:06:03 <Cale> huh?
11:07:37 <Cale> \case { Nothing -> \case { [] -> 0; (y:ys) -> 1 }; Just x -> \case { [] -> x; (y:ys) -> x + y } }
11:08:19 <teneen> Cale: Ohh I see what you mean
11:08:39 <rwbarton> yeah but that is awful if you want f (Just x) (y:ys) = x + y; f _ _ = 0
11:08:43 <shachaf> (\x y -> case (x,y) of { ... })
11:09:03 * shachaf isn't really a fan of the \case syntax.
11:09:20 <rwbarton> @type curry
11:09:21 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:09:37 <rwbarton> curry $ {- whatever the lambda case syntax is -}
11:09:44 <Cale> I was all geared up to be a fan of it until it got transformed into something ugly
11:10:12 <kirindave> Cale: What were you hoping it'd be?
11:10:23 <Cale> Just allow case expressions to have a blank scrutinee, and turn that into a function
11:10:33 <kirindave> Ah.
11:10:50 <kirindave> Like keying off an underscore?
11:11:13 <teneen> rwbarton: I'm not really comfortable matching on tuples. Plus I think it's extra unneeded indirections and boxing
11:11:14 <Cale> like   case of { ... }  --->  \fresh -> case fresh of { ... }
11:11:25 <rwbarton> it is
11:11:34 <rwbarton> one traditional way is f = f' where ...
11:11:44 <shachaf> Doesn't GHC optimize the tuples away?
11:14:03 <shachaf> It looks like it does.
11:14:21 <teneen> It would be nice to have a case-like expression which allows you to match on multiple arguments without resorting to tuples
11:14:41 <teneen> shachaf: Did you try it out?
11:15:16 <clahey> centrinia: Except that the point of the rasppi is as a learning tool, so it needs to be able to do development.
11:15:21 <shachaf> teneen: I tried out foo x y = case (x,y) of ... -> ... vs. foo ... = ...
11:15:26 <shachaf> Compiles to the same Core in this case.
11:15:53 <teneen> shachaf: Without optimizations?
11:16:01 <shachaf> With optimizations.
11:16:04 <clahey> centrinia: But it would be a good way to test compiling for arm.
11:16:18 <shachaf> Why would I check for an optimization GHC does while compiling without optimizations?
11:16:43 <Cale> lol, we could just merge it all into lambda
11:17:19 <centrinia> clahey, yeah. It would. But only when I don't expect to make a lot of modifications to the code. :p
11:17:19 <Cale> make \ be a layout keyword, and allow multiple sequences of patterns followed by -> and an expression
11:17:38 <shachaf> Cale: There was some issue with doing that. I don't remember what it was, though.
11:17:45 <shachaf> dmwit might, since he's always been a fan of it.
11:17:52 <Cale> Well, the issue with it is that it breaks existing code
11:18:15 <Cale> like if you wrote:
11:18:23 <Cale> forM $ \x ->
11:18:26 <Cale>   ...
11:18:36 <n-dolio> Which people do a lot.
11:18:44 <Cale> the layout block would start at the column that the x is in
11:18:57 <Cale> which would mean that your code needs to be in that far to be inside the lambda
11:19:40 <Cale> (obviously there should be a list parameter there, but you get what I mean)
11:19:50 <int-e> is that true? I mean it works for do blocks ...  forM [...] $ \x -> do
11:20:09 <Cale> int-e: The layout starts at the first non-whitespace character after do
11:20:13 <shachaf> Oh, that's not reasonable to break.
11:20:20 <int-e> Cale: ah.
11:20:59 <shachaf> I'd prefer slightly modified lambda syntax for casey lambdas, though.
11:21:13 <int-e> aha, x -> is the start of the first pattern (first line of the block), right.
11:21:22 <Cale> But we *could* do something like that with case of
11:21:33 <clahey> centrinia: Well, if you could get it to cross compile, that would be optimal.
11:21:41 <clahey> centrinia: For android devel, anyway.
11:21:51 <Cale> (generalise to sequences of patterns, even though that doesn't really fit the mould of "sections" anymore)
11:22:26 <statusfailed> Is there a way to constrain a type variable to "Double" easily without changing all the times I wrote it out?
11:22:46 <statusfailed> I thoguht it was ~, but it doesn't seem to work
11:22:54 <shachaf> statusfailed: You can put (a ~ Double) => at the beginning.
11:22:57 <Cale> statusfailed: (t ~ Double) =>
11:22:59 <Cale> yeah
11:23:11 <statusfailed> oh, I must have done something wrong elsewhere then
11:23:12 <statusfailed> cheers, heh
11:23:22 <Cale> Well, this isn't *quite* the same thing...
11:23:37 <statusfailed> oh... what's ~ then?
11:23:51 <Cale> Well, it's type equality
11:24:48 <statusfailed> ok, well that suits my purposes heh
11:25:02 <bitonic> what's the performance of the unordered-container HashTable with very few elements?  if I have say 10 elements, is it faster than a simple [(k, v)]?
11:25:11 <Cale> but you're still introducing this type variable, and then assuming that there's a witness for its equality with Double, which your definition is parametrised over
11:25:55 <Cale> So in the core, I believe there will be a secret extra function parameter to your definition which is going to take this type equality witness.
11:26:35 <statusfailed> Cale: assuming there's a witness??
11:26:42 <statusfailed> Sorry, you totally lost me there :)
11:27:27 <Cale> statusfailed: Well, okay, let's just think about the implementation of type classes for a moment
11:27:28 <rwbarton> I think ghc just rewrites f :: (t ~ A) => T[t] to T[A]
11:27:54 <Cale> rwbarton: I've seen it behave differently in those two cases
11:27:59 <Cale> Which may just be a bug
11:28:02 <Cale> but still...
11:28:17 <rwbarton> Prelude> :t undefined :: (t ~ Double) => t -> t
11:28:18 <rwbarton> undefined :: (t ~ Double) => t -> t :: Double -> Double
11:28:51 <Cale> yeah, for the most part, it'll tell you the same things that you'd expect it to
11:29:39 <shachaf> It might not reduce as early as you'd hope, though.
11:29:44 <shachaf> data Foo = Foo { x :: forall t. (t ~ Double) => t }
11:29:53 <shachaf> Foo :: (forall t. t ~ Double => t) -> Foo
11:31:33 <hiptobecubic> If we want to represent a disjunction as a list of Bool, does the empty list have any meaningful interpretation? in Haskell it defaults to False just because of the definition of `or`
11:31:37 <hiptobecubic> @src or
11:31:37 <lambdabot> or    =  foldr (||) False
11:31:57 <Cale> hiptobecubic: Yes, the empty disjunction is false.
11:32:02 <rwbarton> right, that one is not on the outside and for some reason ghc does not reduce it
11:32:14 <hiptobecubic> Cale, why?
11:32:21 <rwbarton> data Bar a where Bar :: forall t. (t ~ Double) => Bar t -- Bar :: Bar Double
11:32:41 <clahey> Are there any yesod hosting services?
11:32:48 <nschoe> Hello fellow haskellers.
11:32:59 <shachaf> hiptobecubic: Because False is the identity of ||
11:33:04 <shachaf> It would be useless otherwise.
11:33:04 <Cale> hiptobecubic: Well... there's a few answers to that. One is just that you want  or (xs ++ ys) = or xs || or ys
11:33:29 <byorgey> clahey: I haven't heard of any dedicated yesod hosting services
11:33:34 <byorgey> hi nschoe
11:33:48 <Cale> and given that axiom, you have   or ys = or ([] ++ ys) = or [] || or ys
11:33:54 <clahey> byorgey: Doesn't have to be dedicated.
11:33:54 <hiptobecubic> right
11:34:01 <Cale> and the only way for that to be the case is if or [] is False
11:34:07 <clahey> byorgey: I know I can make a VM and host it somewhere, but I was curious if there was some other way.
11:34:15 <Cale> the other reason is categorical/logical
11:34:24 <hiptobecubic> Cale, that's the one i'd like to know
11:34:28 <Cale> If you think about the introduction and elimination rules for or
11:34:41 <hiptobecubic> Cale, because to me, the empty disjunction just doesn't make sense
11:35:08 <byorgey> clahey: not that I know of, but you should try asking in #yesod
11:35:18 <Cale> hiptobecubic: Suppose we have basically any logic whatsoever, where we can derive some statements from others by some rules
11:35:23 <shachaf> hiptobecubic: It makes as much sense as the empty sum or empty product, and for the same reasons.
11:35:41 <Cale> hiptobecubic: (and we can derive any statement from itself by the "empty proof")
11:36:03 <shachaf> My GHC patch LGTM(arlow)!
11:36:14 <Cale> hiptobecubic: We can form a category from our logic where there is an arrow P -> Q in the category whenever P entails Q logically.
11:36:34 <hiptobecubic> Cale, ok
11:36:39 <byorgey> shachaf: yay!  what patch is this?
11:36:49 <Cale> hiptobecubic: Now think about what the coproduct of a bunch of objects in this category is going to be
11:37:16 <shachaf> byorgey: Lets you write integer literals like 1.2e6.
11:37:28 <byorgey> shachaf: oh, nice, I've wanted that =)
11:37:28 <shachaf> (With an extension.)
11:37:39 <hiptobecubic> shachaf, byorgey, me too.
11:37:42 <Cale> Well, say we have some X_1,...,X_n, then the coproduct D is a statement such that we have arrows i_1: X_1 -> D, ..., i_n: X_n -> D, that is
11:37:46 <byorgey> shachaf++
11:37:50 <hiptobecubic> Cale, i don't know what a coproduct is yet
11:38:14 <clahey> byorgey: Duh.  My bad.
11:38:17 <Cale> Oh, in that case, let's start with just a coproduct of two things
11:38:21 <Cale> in an arbitrary category?
11:38:28 <Cale> (do you know what a category is?)
11:38:36 <hiptobecubic> Cale, yes
11:38:39 <Cale> okay
11:39:08 <sopvop> How to convert bytesting of utf8 into [Char] without going through Text?
11:39:26 <Cale> So if X and Y are objects of our category, then their coproduct, if it exists is some object U with arrows i_X: X -> U and i_Y: Y -> U
11:39:36 <ben> sopvop: there's a package like utf8 or somethin that might do that
11:39:45 <ben> or maybe it's the encoding package
11:40:01 <byorgey> clahey: no worries =)
11:40:07 <hiptobecubic> Cale, let me think about it
11:40:27 <Cale> such that if V is any object, and f: X -> V and g: Y -> V are arrows, then there is a unique arrow [f,g]: U -> V such that
11:40:50 <Cale> [f,g] . i_X = f
11:40:59 <Cale> and [f,g] . i_Y = g
11:41:15 <Cale> Okay, so it'll help a good deal to see an example of this right away
11:41:47 <Cale> In the category of sets, the coproduct of two sets X and Y is the disjoint union of those sets, with i_X and i_Y being the inclusions
11:42:07 <Cale> In Haskell, we have the type Either which does this job, pretty much
11:42:56 <Cale> Either a b is the coproduct of a and b (possibly ignoring some fiddly details about bottom I can never quite remember when I need to)
11:43:41 <Cale> If we have any functions f: a -> c, and g: b -> c
11:43:49 <Cale> then there is a function  Either a b -> c
11:44:25 <Cale> say, either f g
11:44:32 <Cale> :t either
11:44:34 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:44:39 <Cale> right :)
11:44:40 <hiptobecubic> ok
11:44:48 <Cale> such that either f g . Left = f
11:44:55 <Cale> and either f g . Right = g
11:44:57 <c_wraith> sopvop: there are ways, but why?  Text is probably the best of them.
11:45:08 <hiptobecubic> Cale, hmm
11:45:11 <Cale> hiptobecubic: Okay, so back to logic...
11:45:36 <Cale> If I have two statements X and Y, I want the coproduct to be a statement which is derivable from X or from Y
11:45:44 <sopvop> c_wraith: In the end I need [Char], but data comes in as ByteString. So, you think it's ok to bytestring->text->String?
11:45:53 <Cale> and which if X and Y both imply something, then the coproduct also implies that thing
11:46:08 <Cale> and this is precisely the definition of a disjunction
11:46:25 <Cale> i.e. that is the introduction and elimination rule for a disjunction in most logics
11:46:51 <c_wraith> sopvop: yeah. It's going to be well-behaved. (at least as long as your choice of Text matches the incoming ByteString in terms of strict/lazy)
11:46:53 <Cale> yeah?
11:47:17 <hiptobecubic> Cale, i'm putting it all together, hold on :)
11:47:31 <Cale> (I really should have said 'entail' rather than 'imply', but whatever)
11:47:46 <sopvop> c_wraith: Both a lazy, so It's good. Also, do I need to deepseq the String after all to release the bytestring and text?
11:47:49 <sopvop> damn
11:48:10 * Cale sighs about freenode's lack of stability
11:48:23 <Cale> anyone on wallops and knows what's happening?
11:48:31 <sopvop> c_wraith: Both a lazy, so It's good. Also, do I need to deepseq the String after all to release the bytestring and text? (repeating just in case)
11:48:53 <djahanda1ie> Cale, my understanding is that its been DDoS attacks.
11:49:01 <c_wraith> sopvop: maybe, if you got the ByteString from readFile or something.  The garbage collector will get it eventually
11:49:48 <sopvop> c_wraith: Guess it's profile and see :) Thanks for help.
11:50:06 <shachaf> Someone's going to wallop you if you don't stop complaining!
11:50:27 <c_wraith> sopvop: but if you're worried about freeing the handle quickly, deepseq would do that.  Possibly in exchange for using more memory
11:51:57 <aleksandar> anyone knows about the state of gobject in haskell?
11:52:23 <ParahSa1lin> in ghci how do i set stuff like -XRecordWildCards when :l source.hs files
11:52:40 <shachaf> The same way you do it in GHC.
11:52:50 <shachaf> (ghci also supports :set but that's not relevant there.)
11:53:07 <ParahSa1lin> ah :set
11:53:25 <conal> in Data.Map.Strict, do insert, insertWith, union, and unionWith yield fully evaluated map representations (the tree part, not necessarily the keys or values) if they're given fully evaluated map representations?
11:53:27 <Nereid> ParahSa1lin: or use a LANGUAGE pragma
11:54:10 <shachaf> conal: I don't think that's what the .Strict is about.
11:54:25 <shachaf> Isn't about about value strictness?
11:54:32 <Cale> hiptobecubic: okay, so does that make sense?
11:54:33 <conal> shachaf: that's what i'm wondering.
11:54:50 <rwbarton> even the regular Data.Map is strict in the tree part, I thought
11:54:55 <shachaf> conal: That's what the documentation says.
11:55:00 <hpaste> ps pasted “ugly?” at http://hpaste.org/75256
11:55:02 <conal> shachaf: thx.
11:55:02 <shachaf> Yep.
11:55:10 <shachaf> Data.Map is always spine-strict and key-strict.
11:55:25 <ParahSa1lin> is http://hpaste.org/75256 idiomatic?
11:56:16 <conal> someone at work is building up some very large maps incrementally and battling a space leak. he defeated the leak by forcing the entire map to full normal form after each addition, and i'm concerned that doing so changes an n log n algorithm into a quadratic one.
11:56:48 <conal> so i wonder whether there's a way to *incrementally* normalize a map as it evolves.
11:56:50 <Cale> hiptobecubic: More generally, the coproduct of an indexed family {X_j: j in J} of objects is an object U together with arrows i_j: X_j -> U such that for any object V and family of arrows f_j: X_j -> V, there is a unique arrow u: U -> V such that u . i_j = f_j for all j.
11:57:20 <Cale> well, this is pretty annoying.
11:57:25 <nschoe> indeed^^
11:58:12 <ParahSa1lin> is http://hpaste.org/75256 idiomatic?
11:58:57 <Cale> ParahSa1lin: Apart from the fact that you are using hashtables, yes.
11:59:19 <Cale> actually
11:59:24 <Cale> vl <- return $ ...
11:59:30 <djahandarie> Cale, I know for a fact that some IRC servers can recieve over 20GBit/s of DDoS sometimes. Depending on who is angry right now, it could be costing Freenode's sponsors thousands of dollars.
11:59:31 <Cale> should be replaced by   let vl = ...
12:00:18 <ParahSa1lin> hashtable is more performant than hashmap?
12:00:35 <Cale> ParahSa1lin: Did you actually check?
12:00:39 <n-dolio> I think the adjunction-ish version is nicer.
12:00:51 <Clint> case l' of Just/Nothing can be replaced by fromMaybe
12:00:58 <Cale> n-dolio: of what?
12:01:07 <Cale> n-dolio: coproducts?
12:01:10 <n-dolio> There is a correspondence between {f_i : X_i -> Z} and Coprod X_i -> Z.
12:01:26 <n-dolio> So for the 0 case, there is a correspondence between {} and False -> Z.
12:01:53 <Cale> well, yes
12:01:54 <ParahSa1lin> didn't actually check, what
12:02:05 <ParahSa1lin> what is the typical performance?
12:02:23 <Cale> ParahSa1lin: That the hashtable implementation you're using was faster than any other way of doing things.
12:02:41 <LadyAurora> Hashtables in Haskell suck, therefore Haskell sucks.
12:02:48 <Cale> Because if it's the usual Data.HashTable, that thing tends to have pretty bad performance -- it's worse than Data.Map in most cases.
12:02:57 <ParahSa1lin> ah...
12:02:59 <solrize> conal, i thought maps were spine-strict so maybe it's enough to rnf the individual elements before adding them
12:03:01 <Cale> There are decent implementations of hashtables out there
12:03:13 <LadyAurora> Whose words are these?
12:03:21 <djahandarie> Data.HashMap from unordered-containers is pretty good.
12:03:28 <solrize> is somebody talking about jon harrop again?
12:03:35 <conal> solrize: perhaps so, in order to balance. i wonder how to know.
12:03:40 <Cale> But you don't really want hashtables
12:03:58 <LadyAurora> solrize: so that's the guy
12:03:59 <Cale> Just use Data.Map until you can prove that it's not good enough through profiling.
12:04:04 <benmachine> ParahSa1lin: it's not /bad/ but it might be possibly to improve it
12:04:05 <quuuux> ParahSa1lin: lines 9-11 could be done with fromMaybe
12:04:05 <benmachine> yeah I was just about to say that :P
12:04:05 <benmachine> and in fact you don't need vl <- return $
12:04:05 <benmachine> you can use let vl =
12:04:05 <benmachine> anyway I'm going to dinner, I'm sure others can help you
12:04:05 <quuuux> it might be cleaner to define the big branch in the middle as a function, and then use maybe
12:04:14 <hiptobecubic> Cale, ok
12:04:54 <ParahSa1lin> ah, fromMaybe
12:05:10 <conal> googling "data.map spine-strict" (without the quotes) turns up useful info
12:05:13 <solrize> conal you can probably tell with some debug.trace, or something like vacuum that i haven't tried
12:05:14 <hpaste> quuuux annotated “ugly?” with “ugly? (annotation)” at http://hpaste.org/75256#a75257
12:05:28 <conal> solrize: sure. thx.
12:05:45 <shachaf> Reading the code also turns up useful info. :-)
12:06:19 <quuuux> naming things often helps, I find
12:06:38 <shachaf> data Map k a = Bin !Size !k a !(Map k a) !(Map k a) | Tip
12:06:44 * hackagebot hackport 0.2.19 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.19 (SergeiTrofimovich)
12:06:52 <rwbarton> that's the normal Data.Map Map right
12:06:59 <solrize> rnf'ing is smelly though, i think; might be better to figure out why there's a thunk buildup in the values, and add strictness in the construction
12:07:24 <conal> shachaf: oh! it's right there.
12:08:12 <shachaf> rwbarton: There's only one Data.Map
12:08:23 <shachaf> Data.Map.{Strict,Lazy} are different functions on the same type.
12:09:02 <shachaf> Confusingly, "Data.Map" exports most functions from Lazy and some functions from Strict, or something like that.
12:09:51 <rwbarton> oh
12:17:31 <Cale> hiptobecubic: still here?
12:18:09 <shapr> It's so quiet!
12:18:20 <Cale> shapr: because it's so noisy
12:18:22 <shapr> oh
12:18:40 <Cale> shapr: the join/part spam is killing usability
12:18:49 <shapr> How to turn that off?
12:18:59 <Cale> depends on IRC client
12:19:35 <hiptobecubic> @src either
12:19:36 <lambdabot> either f _ (Left x)     =  f x
12:19:36 <lambdabot> either _ g (Right y)    =  g y
12:20:30 <hiptobecubic> Cale, yes.
12:20:52 <Cale> hiptobecubic: So in the empty case, our coproduct of no objects is going to be an object U (with no required incoming arrows), such that for any object V, there is a unique arrow U -> V
12:21:03 <Cale> hiptobecubic: That is, it's going to be a statement which entails any other.
12:21:29 <Cale> hiptobecubic: and in most logics, that's what False is :)
12:21:39 <Cale> (a statement which implies anything)
12:22:14 <hiptobecubic> Cale, ok i think i see
12:22:23 <hiptobecubic> Cale, weakly, but there's something there.
12:22:28 <Cale> Or in the case of sets, it's a set U such that for any set V, there is a unique function U -> V
12:22:38 <Cale> and that's satisfied by the empty set
12:23:05 <Cale> If we turn all the arrows in the description around, we get the description of a product
12:24:55 <Cale> The product of two objects X and Y is an object U together with arrows p_X: U -> X, and p_Y: U -> Y, such that if V is any object, and f: V -> X, and g: V -> Y are any two arrows, then there is a unique arrow (f,g): V -> U
12:25:11 <crdueck> i want to create a Vectorspace class, which defines operations of vector addition and scalar multiplication. I thought this would work, but it doesnt compile:  http://sprunge.us/YZbW what am i doing wrong?
12:25:57 <Cale> and of course, in the category of sets, U is the Cartesian product of the sets X and Y, and p_X and p_Y are the projections onto the first and second component of each pair: p_X(x,y) = x, and p_Y(x,y) = y
12:27:25 <Cale> and if we have any couple functions f: V -> X and g: V -> Y, then we get a function (f,g) v = (f v, g v), from V -> X x Y
12:28:09 <Cale> which is the unique function satisfying p_X . (f,g) = f and p_Y . (f,g) = g
12:30:04 <kirindave> besides template haskell, are there other extensions for syntactic transformations on haskell files?
12:30:08 <Cale> crdueck: It doesn't know which type s0 to use to satisfy the Vectorspace Vector s0 constraint
12:30:13 <kirindave> Or is that solely the province of compiler extensions.
12:30:34 <Cale> crdueck: You probably want there to be at most one instance of Vectorspace for any given type v
12:31:03 <crdueck> Cale: dont i only have one instance of Vectorspace?
12:31:43 <Cale> crdueck: That doesn't matter, you *could* have many instances of Vectorspace.
12:31:44 * hackagebot git-annex 3.20120924 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120924 (JoeyHess)
12:31:53 <Cale> crdueck: You can express the constraint that v uniquely determines s using the functional dependency:   class Num s => Vectorspace v s | v -> s where ...
12:32:12 <Cale> Or you can use the TypeFamilies extension:
12:32:22 <Cale> class Num (Scalar v) => Vectorspace v where
12:32:27 <Cale>   type Scalar v
12:32:35 <Cale>   (.+) :: v -> v -> v
12:32:44 <Cale>   (.*) :: Scalar v -> v -> v
12:33:36 <crdueck> i've seen functional dependencies before, but not typefamilies. adding the functional dependency works, but I'll check out typefamilies
12:33:44 <crdueck> thanks
12:33:53 <Cale> crdueck: The compiler follows a strict rule that it is never allowed to assume that an instance of a typeclass *doesn't* exist
12:34:14 <Cale> crdueck: because you can always add more instances in future modules
12:34:36 <Cale> (and while compiling this one, it doesn't know what you're going to link it against)
12:35:04 <Cale> It just happens that in this case, this is also your main module, so the rule seems a little weird here.
12:36:20 <Cale> crdueck: Because you *could* in the future, add an instance Vectorspace Vector Float, it can't rely on the presence of the instance for Double to determine which scalar type to use.
12:37:10 <Cale> I suppose this design constraint is also good in that adding instances never affects which instance is selected in an existing program.
12:37:53 <Cale> (It only allows new programs to make use of the new instance, it doesn't change the behaviour of existing ones)
12:39:28 <Palmik_> Hmm, what's wrong with this http://hpaste.org/75262 ?
12:41:02 <Cale> Palmik_: I don't think you can lift GADTs to the type level.
12:41:43 <Cale> (Or GADT type constructors to the kind level)
12:42:21 <mebaran151> hey #haskell, I have a series of functions that all take two inputs, a webservice token and http client; what is the most elegant way to structure such an api
12:42:42 <mebaran151> it seems like an ideal job for something like a Reader monad, but I don't quite know how to build it yet (I'm pretty new to Haskell)
12:44:42 <Cale> Well, you might use something like (preferably a newtype of)  Reader (WebServiceToken, HTTPClient)
12:45:16 <hpaste> weon pasted “wea” at http://hpaste.org/75264
12:46:01 <mebaran151> hey Cale, thanks: is there a good concrete example I can crib from?
12:46:11 <Cale> I'll write you one quickly :)
12:47:02 <mebaran151> I'm thinking my login method would return the monad object and then the rest would expect to work with that
12:50:30 <Palmik_> Cale, OK, thanks. :)
12:51:24 <hpaste> weon annotated “wea” with “wea (annotation)” at http://hpaste.org/75264#a75265
12:51:45 * hackagebot hermit 0.1.2.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.1.2.0 (AndrewFarmer)
12:52:23 <hpaste> Cale pasted “Web monad” at http://hpaste.org/75266
12:52:36 <Cale> mebaran151: So you could do something like that
12:53:35 <Cale> mebaran151: (You may or may not want to provide direct access to the client/token like that)
12:54:16 <Cale> mebaran151: You may or may not also want to make runWeb into something which actually constructs the value of type WebContext rather than taking it as a parameter
12:54:23 <mebaran151> Cale: what do the actual functions look like?  how do they know that they can ask for something?
12:54:35 <Cale> mebaran151: Those are the actual functions :)
12:54:37 <Cale> :t asks
12:54:38 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
12:55:00 <mebaran151> so any function taht includes asks would know that it is implicitly inside a Reader?
12:55:07 <Cale> yes
12:55:24 <Cale> and in this case, we're applying asks to wcClient, say
12:55:33 <Cale> and wcClient :: WebContext -> HTTPClient
12:55:57 <Cale> and so it infers a constraint  (MonadReader WebContext m)
12:56:22 <mebaran151> I'll try it with a quick refactoring
12:56:33 <Cale> and we get  asks wcClient :: (MonadReader WebContext m) => m HTTPClient
12:56:40 <Cale> but I just specialised that to Web
12:57:34 <Cale> mebaran151: There's honestly nothing wrong with just having things that take a parameter of type WebContext though
12:58:23 <mebaran151> I wanted to make it a little nicer
12:58:25 <Cale> mebaran151: It's mainly a good idea to do something like this if you have a fairly rich language of computations of type Web t for various t
12:58:39 <mebaran151> I've gotten sick of passing manager to everything, plus they should all run with the same token and httpclient
12:58:52 <Quantumplation> So, i'm modelling an economy in a game world.  stars have an element of type ResourceStockpile = Data.Map Resource Quantity
12:58:53 <mebaran151> passing in different tokens would be an error, so the forced bundling of a Reader monad is actually a plus
12:58:55 <Cale> In that case, give it a try :)
12:59:11 <Quantumplation> and I want to know what the best idiom for subtracting costs from this is
12:59:35 <Cale> Quantumplation: Probably lenses :)
12:59:43 <Quantumplation> i.e. taking a difference of the elements, checking if it has enough in it, etc.
12:59:54 <mebaran151> Cale, what's the reason behind the newtype there
13:00:16 <Cale> mebaran151: Potentially to provide some abstraction.
13:00:42 <Cale> mebaran151: You could hide the constructor, which I called W, behind a module boundary
13:01:05 <mebaran151> ah
13:01:07 <Cale> mebaran151: and then other things wouldn't necessarily be able to tell that this was implemented as a Reader monad
13:01:22 <Cale> and so if you wanted to add things to the implementation later, that would be useful
13:03:41 <Cale> Quantumplation: okay, so Data.Map actually has a lot of useful things for updating entries and so on
13:04:04 <Quantumplation> right, i was looking through those
13:04:45 <Quantumplation> I was using diferenceWith, but the problem is it doesn't expose if B has a key that A doesn't.
13:06:36 <Cale> Right... so you're doing a whole collection of these at once?
13:08:33 <Quantumplation> hrm.  Maybe i'll explain the requirements of my data model, because maybe i'm using the wrong tool for the job.
13:08:34 <Cale> Quantumplation: I guess at the very least you can use foldrWithKey
13:09:01 <lightquake> edwardk: if I have some lens between String and Text, is there any way to use that to convert a (a -> String) -> (String -> b) -> String to (a -> Text) -> (Text -> b) -> Text ?
13:09:06 <Quantumplation> The player owns a number of stars, and each star has a number of resources which is fairly dynamic
13:09:32 <Cale> Quantumplation: where the 'b' type is your star's resource map, and the map you're folding over is the costs.
13:09:55 <Quantumplation> each star then has some number of buildings.  Every tick, a building converts some set of resources into some other set of resources to be added.
13:10:06 <edwardk> probably some combination of on, view, from and packed
13:10:49 <kirindave> Son of a...
13:10:56 <kirindave> Every year. Every year apple breaks binaries.
13:11:18 <LadyAurora> Son of a... pple?
13:11:49 <kirindave> Compiled on GHC 7.5.1 for OSX 10.8, run on OSX 10.7.4
13:12:00 <mapreduce> As long as they don't sue programmers for use of the world apply.
13:12:06 <kirindave> Illegal Instruction: 4
13:13:03 <geekosaur> that doesn't sound like something apple would have changed, sounds more like a cpu difference
13:13:21 <geekosaur> like something used sse3 instruction on a cpu that's sse2 only
13:13:40 <Quantumplation> so i'd like to be able to do things like contains :: Stockpile -> Stockpile -> Bool, as well as 2 variations on remove: remove only if you can remove it all, and remove as much as you can (probably returning what you removed in a tuple)
13:14:13 <attoboy>  Please pardon my interruption, but does anyone out there know the latest/greatest GHC for PowerPC on MacOS (10.5.8)?  MacPorts currently won't install it, and I haven't gotten a sense yet from any discussions which version/build is the best way to go now.
13:15:00 <kirindave> attoboy: Man, that's getting long int he tooth.
13:15:07 <kirindave> Does 7.4.* even support darwin-ppc?
13:15:57 <m3ga> kirindave: it should do. i know it works on linux-ppc
13:16:05 <attoboy> I think the site talked about it for some releases not too long ago, but let me double-check.
13:16:13 <kirindave> attoboy: Time to build!
13:16:35 <geekosaur> http://www.haskell.org/ghc/download_ghc_6_10_4 is the last version there are packages for
13:16:36 <attoboy> Build and fly into what?
13:17:00 <attoboy> I found a 7.0.4 of GHC via the site, but ...
13:17:20 <kirindave> 7.0 had that terrible concurrency bug. I shudder to even hear its name mentioned.
13:17:37 <shachaf> What bug?
13:17:58 <geekosaur> macports only just updated its ghc, and I am fairly sure no attention was paid to ppc as support has long since rolled off and most of the mp folks no longer have ppc hardware
13:18:06 <geekosaur> (they'll probably accept patches but can
13:18:08 <geekosaur> 't test)
13:18:10 <attoboy> Thanks, those are the kinds of heads up (release notes?) I'm wondering about.
13:18:24 <kirindave> Um, wasn't 7.0.4 the one with that nasty problemw ith unsafePerformIO?
13:18:33 <attoboy> x86_64 only!
13:18:53 <shachaf> The CAF thing?
13:18:58 <kirindave> Yeah.
13:19:10 <shachaf> Was that just introduced in 7.0?
13:19:29 <kirindave> I remember there was some reason why 7.0 was hit particularly bad with it
13:19:35 <kirindave> but it wasn't limited to 7, no.
13:21:22 <kirindave> I just remember for some reason in 7 my concurrent code exploding nonstop, and in 6 it went much longer without exploding.
13:21:52 <shachaf> You actually ran into that bug?
13:22:08 <shachaf> I don't think your concurrent code should be "exploding nonstop" no matter what.
13:22:37 <kirindave> shachaf: A lot of people did.
13:22:53 <kirindave> shachaf: It came up for me in using iteratees and tchans.
13:23:13 <shachaf> Were you doing the unsafePerformIO thing?
13:23:17 <kirindave> No.
13:23:23 <kirindave> You could exacerbate it without unsafePerformIO.
13:23:39 <attoboy> I was trying to install Pandoc - first time I've looked at Haskell.  I love Python's list comprehensions, and so am curious, without wanting to waste time flagellating an expired equine trying to get something recent going on my G5 DP or PS3.
13:26:26 <watermind> the more I think about exceptions and state in Haskell, the less I understand the design decision
13:26:58 <attoboy> 7.0.4 is the last to release with "community support" for MacOS/PowerPC: http://www.haskell.org/ghc/download_ghc_7_0_4#macosxppc
13:27:35 <attoboy> But from what I'm hearing, there might be a reason that was the last ?-)
13:27:35 <watermind> first... why are exceptions caught in IO and not some more restricted Exception monad
13:28:02 <watermind> a monad you can't run and escape from, just like IO
13:28:24 <watermind> and maybe a monad that can be coerced into IO
13:28:32 <shachaf> "a monad you can't run and escape from" :-(
13:28:51 <mroman> Isn't there a Monad Exception?
13:28:55 <watermind> well I get we need that to stay pure (kinda, I'll get there)
13:29:00 <watermind> mroman: yes but that's different
13:29:02 <shachaf> The way Exception works in Haskell is annoying, I'll agree to that.
13:29:13 * nejucomo is also curious about the distinction between Control.Monad.Error, IOExceptions and "asynchronous exceptions".
13:29:35 <shachaf> Lots of things can be thought of as "exceptions".
13:29:39 <shachaf> Including Maybe and Either.
13:29:40 <Quantumplation> shachaf: COMING TO A THEATER NEAR YOU THIS SUMMER... YOU CAN'T RUN... YOU CAN'T ESCAPE... THE EXCEPTION MONAD."
13:30:16 <nejucomo> I could imagine a scheme where every exceptional / asynchronous / non-pure exception in an IO operation is translated to an ErrorT / IO combo.
13:30:46 <mroman> The unsafePhantom can escape every monad.
13:30:54 <nejucomo> I mean, the API for all IO becomes an instance of ErrorT.  Not sure if that'd be better or worse.
13:31:26 <watermind> the second thing I don't fully understand is, why don't we have the same with state, i.e. why can't we write state in pure functions and just access it in IO?  (I'm guessing it is a compiler issue...)...
13:31:52 <quuuux> that'd mess with equational reasoning
13:31:56 <Polarina> watermind, because then the function wouldn't be pure.
13:32:21 <nejucomo> watermind: We can have state in pure functions with StateT or ST, right?
13:32:28 <watermind> quuuux: Polarina: access it in IO! same with exceptions they mess equational reasoning
13:32:45 <watermind> quuuux: Polarina: yet we can throw exceptions and access them *in IO*
13:33:01 <mroman> In IO you can theoretically hack your pure functions.
13:33:05 <mroman> If that's what you want?
13:34:24 <watermind> then the 3rd thing I don't understand is, why don't exceptions follow the same schema as ST, just like with state, if you make exceptions local you could technically run the monad and stay pure
13:35:05 <davean> watermind: and you can have exceptions like that. There are plenty of exception monads.
13:35:25 <watermind> davean: no you don't it's rather different
13:36:08 <watermind> davean: just like a normal state monad is different from ST
13:36:15 <mcstar> by using Maybe or Either you can make your 'local' exceptions
13:36:20 <rwbarton> the exception you can observe in IO is nondeterministic
13:36:29 <watermind> excatly
13:36:43 <rwbarton> so that's why what you're saying won't work...
13:36:45 * hackagebot haslo 0.1.1 - Loan calculator engine.  http://hackage.haskell.org/package/haslo-0.1.1 (BartoszWojcik)
13:37:03 <rwbarton> ST is deterministic which is why we can run it
13:37:15 <watermind> hmm let me think
13:37:39 <geekosaur> the thing about GHC's Exception is that it models exceptions that are *not* deterministic
13:37:49 <geekosaur> think POSIX signals, not program errors
13:38:07 <geekosaur> which is why they're in IO
13:38:30 <watermind> yes but what makes them non-deterministic? appart from the fact that you can raise them in IO?
13:38:39 <rwbarton> if you want to get deterministic exceptions you need to impose a fixed evaluation order
13:38:48 <maukd> watermind: throwTo and lazy evaluation
13:38:55 <rwbarton> error "foo" + error "bar"
13:39:17 <shachaf> Can we have first-class continuations while we're at it?
13:39:32 <geekosaur> watermine, what is deterministic about someone sending a signal to your program?
13:39:40 <nejucomo> What if there were a type FooIO t = IO (Either FooIOException t)
13:40:13 <nejucomo> -and then we made FooIO the "standard IO" and IO into an internal type.  Would that make anything more consistent?
13:40:15 <geekosaur> There are some things that are handled as exceptions that probably should not be (like floating pont errors) except that almost nobody is willing to pay the price to do it right
13:40:25 <watermind> rwbarton: right so the semantics don't establish sequentiality
13:40:31 <nejucomo> I mean, would that make the standard library interfaces any more consistent?
13:40:35 <watermind> rwbarton: I actually thought they did
13:41:20 <watermind> that does destroy my argument
13:41:32 <geekosaur> to that extent, yes, Exception is a mistake, but it's not the fault of Exception /per se/, it's a design decision following the majority of users instead of correctness.  I think there are people better suited to complain about that one :)
13:41:46 * hackagebot pqc 0.7.1.1 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.7.1.1 (KidoTakahiro)
13:43:51 <watermind> I understand being lazy we don't have an _evaluation order_  but every function we write does establish sequential dependencies in the data that is consumed
13:44:28 <mcstar> evaluation order has to do with pureness, not lazyness afaik
13:44:51 <mcstar> i mean, you can evaluate in any order as long as you dont have side effects
13:45:03 <mcstar> ofc, some things depend on others
13:45:38 <watermind> sequentiality is independent of purity
13:45:48 <mcstar> no
13:45:55 <watermind> well... yes :P
13:46:04 <mcstar> if you have effects, then it will matter in what order you evaluate stuff
13:46:16 <watermind> sequentiallity doesn't imply effects
13:46:22 <Cale> actually, lazy evaluation *is* an evaluation order, together with one other thing
13:46:48 <mcstar> call by need, you call it that right?
13:47:11 <Cale> Lazy evaluation is outermost-first evaluation, plus sharing (i.e. parameters to a function which occur more than once in the body are computed at most once, and the result shared between the copies)
13:47:37 <Cale> I can never remember what the call-by-X names for evaluation strategies mean, they're highly unintuitive to me
13:47:52 <Cale> Functions aren't called, they're applied anyway :)
13:48:00 <matthiasgorgens> cale, for call-by-name you can pretend it's call-by-textual-copy.
13:48:18 <Cale> Isn't that how all functions are always called? :)
13:48:20 <watermind> Cale: yes, so the crux of the matter to me appears to be that if I understand correctly, the specification of the 'primitive' functions doesn't say anything about sequentiality, e.g. it doesn't say whether + evaluates it's first or second arguments first  (but why that decision? does it help that much with optimisations?)
13:48:36 <Cale> watermind: yes, it does help
13:48:50 <matthiasgorgens> cale, no, if you don't have referential transparency, it makes a difference when you evaluate.
13:48:51 <Cale> Moreover, the spec doesn't say that Haskell is lazily evaluated
13:48:54 <rwbarton> well, it means for example the compiler can turn foldl (+) 0 into foldl' (+) 0 on a list of Ints (or other known specific types where (+) is strict)
13:49:15 <Cale> matthiasgorgens: What? No referential transparency? What is this?
13:49:18 <Cale> :)
13:49:32 <watermind> Cale: yes but specifying sequential dependencies doesn't mean defining an evaluation method
13:49:41 <LadyAurora> Cale: IO
13:49:44 <n-dolio> Even with, it clearly can make a difference in the amount of work you do.
13:49:51 <watermind> Cale: not fully anyway
13:50:05 <n-dolio> And when you do it.
13:50:40 <watermind> Cale: an easy way to specify sequentiallity is simply to define the beahviour of functions in the presence of two different exceptions
13:51:11 <watermind> Cale: so if you define   e1 + e2 = e1   you defined that the first element is evaluated first
13:51:14 <mcstar> watermind: an easy way to specify sequentiallity  is simply to pass a dummy argument around in the background
13:51:39 <watermind> Cale: or even simpler, you can use one exception and undefined
13:51:49 <Cale> watermind: All exceptions are treated as having a single value, which is also identified with nontermination.
15:50:46 --- topic: '["GHC 7.6.1 http://v.gd/CEBRVo ","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]'
15:50:46 --- topic: set by monochrom on [Fri Sep 14 12:57:21 2012]
15:57:09 <ion> 19
16:20:16 <lispy> shachaf: it's win 2 here as well. odd.
16:20:59 <aristid> lispy: not here. it's _buffer_ 2 here.
16:21:11 <lispy> aristid: erc?
16:21:18 <shachaf> lispy: I was trying to type /win 27.
16:21:20 <aristid> lispy: weechat.
16:21:38 <lispy> aristid: ah. Of course. Who would use emacs for irc. That would be odd ;)
16:21:50 * lispy certainly didn't do that for years...
16:22:02 <lispy> So, anyway, how about those monads?
16:22:27 <lispy> That whole, monoids in the category of endofunctors thing and all.
16:23:23 <shachaf> lispy: I heard Codensity was "a pretty cool monad".
16:23:30 <shachaf> That's what they called it.
16:23:31 <ew0> yo
16:23:40 <ew0> I just wrote an identation plugin for haskell
16:23:41 <ew0> for vim
16:23:47 <ew0> anyone interested?
16:23:58 <shachaf> IRC isn't the place.
16:24:16 <Quantumplation> Trying to write a function with type:  split :: M.Map a Int -> M.Map a Int -> (M.Map a Int, M.Map a Int) such that it subtracts the second list from the first (using subtraction on the values, and if it hits zero it removes it from the map), and returns the pair of the first list after the subtraction, and the total quantities subtracted (if that makes sense)
16:24:26 <aristid> shachaf: what?!
16:24:34 <aristid> shachaf: IRC is THE place!
16:24:40 <ew0> U_U'
16:24:41 <ew0> sorry
16:25:52 <shachaf> I mean that for that sort of question, you're only going to get responses from people who happen to be here.
16:26:04 <shachaf> Quantumplation: Lists?
16:26:11 <beanmachine> ew0: sounds cool
16:26:29 <shachaf> It sounds like you're talking about bags implemented as Maps to Ints.
16:26:48 <beanmachine> ew0: you can put it on haskellwiki, that's where good ideas go to die :P
16:26:49 * hackagebot binary-literal-qq 1.0 - Extends Haskell with binary literals.  http://hackage.haskell.org/package/binary-literal-qq-1.0 (MathieuBoespflug)
16:26:51 <Quantumplation> schachaf: ... you mean there's a thing already for what i'm trying to do? XD
16:27:05 <ew0> lol
16:27:22 <beanmachine> ew0: more seriously, there's already *some* stuff http://www.haskell.org/haskellwiki/Vim
16:27:30 <beanmachine> maybe you could add it there
16:27:42 <ew0> yeah, I'm using it, but it lacks identation
16:27:48 <ew0> indentation
16:27:51 <beanmachine> fair enough
16:27:56 * beanmachine just uses tab
16:30:10 <Guest20276> Does there exist a function like this already:
16:30:12 <Guest20276>  doubleZipWith :: (a -> b -> a -> b -> c) -> [a] -> [b] -> [c]
16:30:16 <Guest20276> doubleZipWith f (x:x':xs) (y:y':ys) = f x y x' y' : doubleZipWith f (x':xs) (y':ys)
16:30:57 <aristid> Guest20276: doubleZipWith f = zipWith (\x y -> f x y x y)
16:31:12 <Guest20276> makes sense
16:31:31 <ew0> benmachine: I've not yet used it, but all it does it align "in" with "let"
16:31:48 <Guest20276> the x and x' are distinct though
16:31:50 <ew0> and words after "case", "do" and "="
16:31:56 <ew0> erm, lines
16:32:08 <ezyang> Cale: If I do a deep transformation, I don't have to commit to execution order.
16:32:20 <ew0> and if you leave a line in blank it will indent it to the left
16:32:41 <ew0> else, it copies the previous line indentation
16:33:30 <rwbarton> Guest20276: can't you make it out of zipWith4 and tail (or drop 1)
16:34:05 <rwbarton> zipWith4 f xs ys (tail xs) (tail ys)
16:34:37 <Guest20276> rwbarton: Yeah I guess thats probably the way to go
16:35:39 <Guest20276> rwbarton: thanks
16:36:16 <aristid> rwbarton: i think drop 1 would be better, due to not being partial
16:37:17 <ivanm> byorgey: did you directly try to avoid the mailing list wrapper and email the underlying list that your xmonad email got sent out twice? :p
16:38:00 <benmachine> aristid: no that's not right
16:38:08 <benmachine> ah I was scroleld up
16:38:10 <benmachine> aristid: ignore me
16:38:11 <rwbarton> the one you want is the one that's better :P
16:38:16 <byorgey> ivanm: eh? what got sent out twice?
16:38:23 <aristid> benmachine: oh yeah that was wrong
16:39:09 <aristid> rwbarton: oh, your version is safe because f won't be evaluated when xs/ys is empty, nevermind me.
16:39:23 <rwbarton> oh that also happens to be true yes
16:39:25 <ivanm> byorgey: the message about firefox not warning you
16:39:32 <rwbarton> only because the arguments are in this order though :)
16:39:47 <aristid> rwbarton: yes... it's a bit scary code ;)
16:39:50 <byorgey> ivanm: firefox not warning you about what?
16:40:03 * byorgey doesn't remember sending any emails about xmonad + firefox recently
16:40:20 <ivanm> byorgey: the thread in the xmonad list about someone directly trying to run the ~/.xmonad/xmonad-<blah> executable
16:40:51 <ivanm> byorgey: sorry, my mistake *facepalm*
16:41:05 <ivanm> it was Brandon Allbery
16:41:11 <byorgey> hehe
16:41:12 <ivanm> not sure how I got Brent Yorgey out of that :s
16:41:23 * ivanm blames only recently getting up
16:41:35 <byorgey> a convenient excuse
16:41:44 <ivanm> *whistles*
16:48:07 <YayMe> is windows emacs written in lisp? or only original console emacs?
16:50:13 <YayMe> (is emacs not written in lisp and that was a stupid assumption?)
16:50:24 <geekosaur> the core of emacs is written in C
16:50:56 <geekosaur> the earliest emacs was written in teco
16:51:01 <dada_cetacean> *wilhelm scream*
16:51:03 <hotaru2k3> the original emacs was written in teco
16:51:16 <hotaru2k3> and then they switched to lisp, because teco was too easy to read
16:51:44 * YayMe imagines a language named teco.. in his head it has semantics he never saw before, half assembler, half pseudo code, and lego analogies are used in the manuals a lot
16:51:46 <Jetbeard> the world needs a text editor written in haskell
16:52:11 <hotaru2k3> yi is written in haskell
16:52:25 <lispy> Jetbeard: isn't that leksah?
16:52:27 <YayMe> Jetbeard: I was thinking about writing one lately.. but I don't know why I would other than I've been trying to find projects to practice haskell.
16:52:35 <lispy> oh and yi of course
16:52:43 <byorgey> leksah isn't really a text editor.
16:52:55 <lispy> YayMe: implement a mini-parsec?
16:53:03 <lispy> YayMe: make a term rewriting system?
16:53:14 <lispy> YayMe: implement the dependently typed lambda calculus?
16:53:39 <Jetbeard> YayMe, here's a fun project: modify the cairo bindings so it can use cairo's OpenGL backend
16:53:53 <Jetbeard> (okay, not so much 'fun' as 'beneficial to me')
16:54:12 <lispy> YayMe: http://www.cs.ru.nl/~wouters/Publications/Tutorial.pdf
16:54:50 <lispy> Jetbeard: I looked at making the charts package use opengl as a backend, but I didn't realize there was an OpenGL backend for cairo.
16:55:04 <lispy> Jetbeard: wait, no I was going to write directly to a buffer not use opengl
16:55:14 <lispy> But opengl would still be nicer than gtk
16:55:37 <byorgey> lispy: make charts use diagrams as a backend.
16:55:45 <byorgey> then you get lots of backends for free.
16:55:55 <luite> yes! do that, i want!
16:56:05 <lispy> In my case, I wanted something isomorphic to matlab's ploting
16:56:14 <lispy> I'll have to peek at diagrams
16:56:32 <YayMe> Jetbeard: I know neither what cairo is, what 'bindings' you mean (C FFI?) nor have I ever written anything in Open GL. I guess what I'm saying is, challenge accepted! What do you actually want changed about cairo's bindings now? :D
16:56:51 <Jetbeard> well, the cairo library has a whole bunch of backends
16:56:59 <lispy> byorgey: looks interesting.
16:56:59 <Jetbeard> it's a library for rendering vector graphics
16:57:29 <Jetbeard> it can render to an image, a pdf, an svg, etc. etc., as well as to an OpenGL surface
16:57:30 <lispy> I agree with byorgey's suggestion.
16:58:01 <Jetbeard> however, the cairo library for haskell doesn't include support for the openGL backend
16:58:03 <lispy> Then when someone else makes an OpenGL backend for diagrams (or does it exist?) you're done.
16:58:44 <byorgey> lispy: right.  There is no OpenGL backend right now, though someone was talking about making one.  But there is a cairo backend as well as native Haskell postscript and SVG backends, as well as an HTML5 canvas backend
16:58:45 <lispy> YayMe: another challenge. Rewrite Hackage using the yesod framework :)
16:59:05 <byorgey> oh, and a TikZ backend
16:59:23 <byorgey> and probably other things I forgot in varying states of completeness
16:59:43 <Jetbeard> Add an OpenGL backend for cairo => get OpenGL backend for diagrams for free
16:59:49 <Jetbeard> ;)
16:59:55 <lispy> architect it so that it uses (dumb) content distribution networks for the packages and their direct metadata and uses plugins/webservices for all other add-on features. Make the login capabilities separate from the core "serving content" features.
17:00:30 <byorgey> Jetbeard: =)
17:00:52 <lispy> Jetbeard: but then I still have to install gtkhs :(
17:01:05 <lispy> (I'm trying to avoid that beast whenever possible)
17:01:48 <Jetbeard> Is it bad because of GTK or is it just a badly-implemented library?
17:01:53 <lispy> byorgey: did you ever figure out fonts for diagrams?
17:02:07 <lispy> byorgey:  that's why you were mildly interested in my freetype bindings, right?
17:02:15 <lispy> Jetbeard: Both?
17:02:27 <byorgey> lispy: right
17:02:34 <lispy> Jetbeard: I'm allergic to things that are hard to build. Also, lgpl is not my friend.
17:02:34 <byorgey> lispy: no, haven't really done anything with it since
17:02:54 <byorgey> Jetbeard: it's just big and can be hard to install
17:03:11 <lispy> byorgey: likewise. I made the lowlevel binding (just the ffi imports/types) and then tested it but never used it from, say, opengl or anything.
17:03:40 <AxiomOfChoice> @pointfree map ( uncurry (/) . swap ) . zip ( map fromIntegral [1..] ) . scanl1 (+)
17:03:58 <lispy> byorgey: I always meant to make a "printf" that is usable on a canvas
17:04:04 <lispy> byorgey: an opengl canvas specifically
17:04:20 <fryguybob> Jetbeard: It also has strange platform dependent bugs.
17:04:26 <lispy> AxiomOfChoice: I'm not sure where lambdabot went
17:04:27 <byorgey> lispy: sounds cool
17:04:43 <AxiomOfChoice> lispy: Noooooooo.
17:05:12 <lispy> She's probably out seeing the sights. I'm sure she'll be back later.
17:05:55 <benmachine> AxiomOfChoice: that *is* pointfree, anyway
17:09:33 <theplanet> why is libgmp3-dev a dependency to ghc6 or ghc6-doc?
17:09:55 <lispy> theplanet: ghc links your programs with libgmp and uses it
17:10:09 <lispy> so libgmp3 isn't enough, I think
17:10:25 <theplanet> libgmp3 isn't an mp3 lib?
17:10:50 <lispy> nope, it's the gnu math lib for infinite precision numbers
17:11:01 <lispy> http://gmplib.org/
17:11:16 <lispy> eg., Integer
17:13:26 <geekosaur> GNU Multiple Precision Library
17:13:32 <geekosaur> version 3
17:18:03 * Polarina has too many IORefs.
17:19:13 * fryguybob hands Polarina an MVar
17:19:30 * Polarina would then have too many MVars.
17:21:50 * hackagebot json 0.6 - Support for serialising Haskell to and from JSON  http://hackage.haskell.org/package/json-0.6 (IavorDiatchki)
17:22:08 <shachaf> lispy: libgmp3-dev has nothing but documentation here...
17:22:33 <shachaf> Aren't -dev headers only needed for C headers and static linking?
17:28:23 <john_r_watson> @pl (\n i -> n / (fromIntegral i))
17:28:44 <john_r_watson> pl (\n i -> n / (fromIntegral i))
17:28:59 <kallisti> :t (//)
17:29:04 <benmachine> john_r_watson: lambdabot's missing
17:29:13 <john_r_watson> benmachine: what happened?
17:29:27 <copumpkin> somebody set up us the bomb!
17:29:39 <mapreduce> type error
17:30:49 <john_r_watson> time to install pointfree... http://hackage.haskell.org/package/pointfree
17:31:28 <lispy> shachaf: that's my understanding, yeah
17:31:45 <shachaf> lispy: Would be nice if we could statically link with gmp...
17:31:50 * hackagebot force-layout 0.1.0.2 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.1.0.2 (BrentYorgey)
17:32:08 <lispy> shachaf: Maybe it's a forwards compatible thing. If they include libgmp3-dev now then if the libgmp3 packager ever puts anything actually needed for linking into the -dev package nothing breaks?
17:32:22 <lispy> shachaf: we could except lgpl.
17:32:31 <shachaf> The GMP-debian thing is a mess anyway.
17:32:31 <lispy> shachaf: it's not a technical limitation
17:32:35 <shachaf> lispy: Right.
17:32:39 <shachaf> I didn't say it was. :-)
17:32:41 <hotaru2k3> i have pointfree installed... but for some reason most of the time it just hangs
17:32:43 <Polarina> Should I be using Data.ByteString.Builder in blaze-builder or bytestring?
17:32:49 <lispy> shachaf: cool. Just wanted to make sure :)
17:33:47 <lispy> I thought, 'I think my problem is caused by numerical (in)accuracy of Double. I'll use Rational.' This reasoning falls down in the face of square roots.
17:34:19 <shachaf> lispy: CReal!
17:34:27 <mapreduce> You could make a smarter version of Rational that knows about square roots
17:34:31 <shachaf> maximum accuracy
17:34:43 <mapreduce> RationalOrPower :)
17:35:10 <hotaru2k3> if i do 'pointfree "(\a b -> a + b)"' it immediately outputs '(+)' and exits, but if i do 'pointfree "(\a b -> a + abs b)"', it hangs forever
17:35:13 <lispy> mapreduce: what would my implementation for sqrt (2 :: Rational), be?
17:35:19 <shachaf> @pl \a b -> a + abs b
17:35:30 <shachaf> @pl \a b -> abs a + b
17:35:35 <shachaf> @pl \a b -> a + blah b
17:35:44 <lispy> mapreduce: would it just be a symbol for square root of 2?
17:35:46 <mapreduce> lispy: Power 2 0.5
17:35:47 <mapreduce> yep
17:36:03 <mapreduce> Power 0.5 2 would probably be better for partial application.
17:36:11 <lispy> mapreduce: I'd more or less be okay with that in this case.
17:36:15 * shachaf wonders how terrible CReal's performance is.
17:36:27 <shachaf> Wait, lambdabot isn't even in here.
17:36:33 <lispy> I'm happy to convert final answer to Double. I just want to rule out numerical problems in the middle...
17:36:41 <shachaf> Should I run a lambdabot instance until the real one is back?
17:36:50 <shachaf> Cale:
17:36:56 <lispy> shachaf: sure if you like. I pinged Cale but no reply yet.
17:37:10 <Cale> oh, I can bring it up again
17:37:20 <Cale> I was waiting until the spam died down
17:37:24 <lispy> shachaf: CReal is also missing a lot of things. I told a friend to try it and he had nothing but problems.
17:37:30 <shachaf> @pl \a b -> a + abs b
17:37:31 <kappabot> (. abs) . (+)
17:37:32 <lispy> Cale: someone was spamming her?
17:37:42 <Cale> no, someone was spamming freenode
17:37:46 <shachaf> @admin + Cale
17:37:46 <lispy> ah
17:37:51 <Cale> and there were netsplits and bad connectivity all day
17:37:54 <shachaf> Just @quote kappabot when you bring lambdabot back.
17:38:18 <shachaf> s/ote/it/
17:38:32 <shachaf> kappabot: @quit bye
17:38:39 <hotaru2k3> huh, i just tested on my server and pointfree works fine there
17:39:14 <shachaf> lambdabot: Am I @admined?
17:39:17 <shachaf> @flush
17:39:24 <lambdabot> Not enough privileges
17:53:37 <jmcarthur> lispy: anything besides the comparison operations?
17:59:23 <YayMe> I'm a visual thinker, when I think of lift I immediately picture in my head an elevator which a complex type walks into, and the elevator lifts to the next level where a primitive walks out. Am I remembering lift correctly that a monad/applicative walks in and primitive walks out?
17:59:38 <YayMe> Or is a primitive type walk in and get lifted up to the complex type level?
18:00:00 <YayMe> Or is my mental picture for lift completely inaccurate?
18:01:19 <Polarina> YayMe, lift :: (Monad m, MonadTrans t) => m a -> t m a
18:01:41 <Polarina> YayMe, a simpler type walks in and a complex one goes out.
18:02:23 <Polarina> YayMe, technically speaking. It'd depends on how you look at it.
18:04:17 <Cale> @bot
18:04:18 <lambdabot> :)
18:06:10 <Nereid> @top
18:06:10 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell do map thx todo type yow
18:06:26 <Cale> @yow
18:06:27 <lambdabot> Couldn't find fortune file
18:06:28 <Cale> :(
18:06:34 <shachaf> @brain
18:06:34 <lambdabot> I think so, Commander Brain from Outer Space! But do we have time to grease the rockets?
18:06:35 <Nereid> :(
18:07:18 * Polarina gives lambdabot a cookie
18:09:44 <Cale> The error message for @yow should at least say something like  I already FOUND my FORTUNE, but I can't get a FILE!
18:10:21 <shachaf> Cale: Feel free to fix it and, uh, submit a patch?
18:10:44 <shachaf> To the person who runs lambdabot.
18:10:59 <hiptobecubic> who runs lambdabot?
18:11:07 <hiptobecubic> lambdabot, WHO DO YOU WORK FOR!?
18:11:53 <gtmanfred> lambdabot: who is your daddy and what does he do
18:12:33 <lambdabot> hiptobecubic: i ain't workin' for no one, kid
18:12:54 * hiptobecubic slaps lambdabot
18:13:05 <hiptobecubic> lambdabot, WHO... DO... YOU... WORK FOR!?
18:13:59 <shachaf> @slap hiptobecubic
18:13:59 * lambdabot moulds hiptobecubic into a delicous cookie, and places it in her oven
18:14:02 <Cale> hiptobecubic: I run that lambdabot instance
18:14:09 <Cale> on lispy's machine
18:14:24 <Cale> but nobody maintains lambdabot anymoe
18:14:27 <Cale> anymore*
18:14:49 <Cale> But someone (I forgot who!) is writing a new IRC bot in Haskell to replace it.
18:15:13 <shachaf> Cale: You "forget" who, eh?
18:15:14 <kallisti> Cale: I am working on an IRC bot in Haskell that would have similar functions.
18:15:27 <benmachine> aren't we all, deep down inside
18:15:33 <Polarina> Hehe. :P
18:15:42 <shachaf> elliott started writing a lambdabot replacement once, I think, but stopped pretty soon.
18:15:49 <shachaf> So did I, actually!
18:15:49 <Cale> Oh
18:16:00 <Cale> That's the right name
18:16:07 <shachaf> elliott?
18:16:12 <kallisti> yes
18:16:13 <shachaf> He writes C++ these days.
18:16:14 <Cale> I heard from just the other day that elliott was working on one
18:16:19 <benmachine> shachaf: whaaaat
18:16:21 <Cale> pff
18:16:27 <benmachine> who even does that
18:17:40 <hiptobecubic> ok #haskell. We need to talk.
18:18:01 <hiptobecubic> I don't know how to say this, but i'm leaving you
18:18:07 <hiptobecubic> it's not me, it's you.
18:18:07 <benmachine> oh, cool
18:18:10 <shachaf> Adieu.
18:19:11 <kallisti> I've written an IRC parser that uses ByteString, attoparsec, and condui  to parse IRC messages
18:19:16 <kallisti> *conduit
18:19:32 <benmachine> kallisti: it's not a competition to involve the most libraries :P
18:19:36 <benmachine> but that sounds good
18:19:44 <kallisti> that's not my goal.
18:19:56 <Ralith> of course not
18:20:00 <Ralith> otherwise you'd've done it on the type level!
18:20:43 <benmachine> heh
18:38:39 <mlh> 11:15 < shachaf> He writes C++ these days.
18:39:11 <mlh> I rofld.  Reminded me of http://www.bitmover.com/lm/bugs.html  "Now he can only drink herb tea."
18:39:40 <startling> hmm, it would be cool if the value () was mempty
18:39:49 <startling> for all monoids
18:40:07 <shachaf> Huh?
18:40:43 <rwbarton> like OverloadedUnit?
18:41:00 <ivanm> methinks that would be too confusing
18:41:09 <shachaf> Oh, syntactically.
18:41:21 <shachaf> meagrees ivanm
18:41:33 <ivanm> @wn meagrees
18:41:34 <lambdabot> No match for "meagrees".
18:41:34 <ivanm> :p
18:41:53 <rwbarton> how often do you actually write mempty though
18:41:55 <ivanm> {-# LANGUAGE OverloadedAllTheThings #-}
18:42:20 <ivanm> rwbarton: I have code that is designed for () but decided to generalise to all Monoids and have mempty there
18:42:26 <ivanm> but yes, it's still rather minimal
18:43:25 <shachaf> /dev/mempty
18:44:27 <startling> heh, just a thought
18:44:56 <startling> <> is much cleaner syntactically than mappend; I think () would go well with it
18:44:57 * Cale imagines a world where the filesystem is not only typed, it's homotopy typed :)
18:45:03 <shachaf> ++ is even cleaner.
18:45:14 <ivanm> Cale: homotopy typed? what does that mean?
18:45:14 <shachaf> Cale: What would that mean?
18:45:21 <Polarina> () <> ()
18:45:22 <startling> shachaf: yes but
18:45:29 <startling> > () <> ()
18:45:30 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
18:45:30 <lambdabot>         agains...
18:45:39 <startling> > mappend () ()
18:45:40 <lambdabot>   ()
18:45:42 <ivanm> is that a landspeeder? :p
18:45:45 <shachaf> > () ++ ()
18:45:47 <Cale> shachaf: I don't even fully know yet. (in particular)
18:45:48 <lambdabot>   ()
18:45:59 <startling> shachaf: that's Caleskell, though, isn't it
18:46:02 <ivanm> Cale: what does it mean even without the context of file systems?
18:46:05 <ivanm> startling: yup
18:46:25 <startling> a typed filesystem *would* be pretty cool
18:46:28 <ivanm> actually, wasn't someone saying that it's more accurate for it to be called skiskell nowadays?
18:46:35 <Cale> Homotopy type theory is this new foundations for mathematics which is built on Martin-Löf type theory, and which people are exploring in Coq and Agda.
18:46:58 <ivanm> in a typed file system, would ls then work on a class? ;)
18:47:02 <Cale> Logical statements have both geometric and (very often) computational content
18:47:04 <benmachine> ivanm: http://www.haskell.org/pipermail/haskell-cafe/2012-April/100527.html I feel this explains it well
18:47:24 <startling> ivanm, yes, Typeable
18:47:37 <benmachine> (actually it doesn't, you just reminded me of it somehow)
18:47:37 <Cale> Martin-Löf type theory is a lambda calculus whose types can be interpreted as (homotopy types of) topological spaces
18:47:41 <ivanm> startling: why Typeable?
18:47:42 <ivanm> :/
18:47:49 <Cale> as well as being interpreted as datatypes in the usual way
18:48:00 <Cale> as well as being interpreted as logical statements
18:48:16 <ivanm> the type of mv would be complicated methinks
18:48:17 <startling> ivanm, because you can see a representation of the type
18:48:21 <startling> or am i thinking of something else
18:48:22 <shachaf> roconnor: So how 'bout them slides?
18:48:32 <Cale> ivanm: :D
18:48:54 <ivanm> startling: a type system for the file system; you would presumably have some kind of class-like abstraction over all file system elements
18:49:35 <startling> ivanm, but all ls needs to tell you is the name and the type
18:49:44 <ivanm> startling: and metadata
18:49:48 <startling> I guess I assumed names would be outside the type system
18:49:58 <ivanm> but I meant that it would be polymorphic on the type of all file system elements
18:49:59 <startling> metadata too
18:50:08 <Cale> OR: The entire typesystem is a Haskell value of some fairly general type, and filenames are lenses.
18:50:23 <ivanm> even something as simple as the difference between "mv <dir1> <dir2>" and "mv <dir1> <dir2>/" (i.e. rename vs move inside a directory)
18:50:32 <startling> Cale, Map FilePath
18:50:43 <ivanm> startling: we're not talking about a Haskell representation
18:51:06 <startling> except you can't have lenses into nested maps. :/
18:51:12 <startling> ivanm: yeah, understood
18:51:15 <ivanm> we're talking about a FS implementation which has an inbuilt type system to distinguish explicitly between files, directories, links, etc.
18:51:23 <ivanm> didn't Plan9 have something like that?
18:51:24 <startling> yeah
18:54:52 <Cale> ivanm: not to mention different types of files :)
18:55:08 <ivanm> well, depends on how file-grained you want to make it
18:55:15 <ivanm> do you distinguish by mime-type?
18:55:22 <startling> you'd get free serializing for (almost?) any data type in a language supporting it, wouldn't you?
18:55:25 <Cale> Something vaguely like that :)
18:55:31 <ivanm> is executable status a separate type or metadata?
18:55:37 <startling> except pointers I guess.
18:55:58 <Cale> I don't know how the details work, or how you "prove" to the system that some data has some appropriate type
18:56:11 <startling> ivanm: perhaps a metadatum attached to ELF/object files
18:56:47 <Cale> Like, hah, if you have a file of type PNG, then it's *really* an honest well-formed PNG.
18:57:11 <ivanm> Cale: so what happens to those "this PNG is also an executable or an HTML file" hacks?
18:57:13 <benmachine> Cale: well, if you have an Integer, how can you be sure it's a genuine integer?
18:57:27 <rwbarton> intersection types? :)
18:57:27 <ivanm> or files which act as scripts in multiple languages?
18:57:46 <startling> ivanm, coercion!
18:57:46 <benmachine> text/x-confusing
18:57:48 <ivanm> or that technique where you hide data inside an image
18:57:50 <ivanm> startling: heh
18:57:54 <ivanm> benmachine: lol
18:58:46 <startling> ivanm: executable *x = (void *) png;
18:59:11 * ivanm 's C-fu is very weak
19:00:06 <Cale> Maybe you have some programs which you bless with a responsibility for parsing raw bytes into structures something more like Haskell datatypes. Once a parse succeeds, producing such a structure for the first time, the filesystem remembers this and marks the data as good for that type.
19:00:47 <startling> a syscall/os function would work, too
19:01:32 <benmachine> Cale: well, in some cases you'd be able to prove a file was a certain type
19:01:45 <benmachine> e.g. by exhibiting the relevant magic whatevers
19:05:01 <ivanm> Cale: wouldn't you need to re-parse every time the file is edited?
19:05:26 <startling> it depends how editing works, I guess.
19:05:28 <ivanm> and even then, you'd need parsers for every possible type, unless you trust file extensions
19:06:52 * hackagebot catch-fd 0.1.0.1 - MonadThrow and MonadCatch, using functional dependencies  http://hackage.haskell.org/package/catch-fd-0.1.0.1 (AndySonnenburg)
19:08:19 <startling> I can take a value of a type that has Typeable and find the name of the type, right?
19:08:22 <startling> or am I way off
19:09:02 <shachaf> Sure (though not a fully qualified name).
19:09:22 <startling> right. how do I do that? `show` on a TypeRep?
19:09:30 <shachaf> Try it!
19:09:43 <startling> fair enough
19:11:10 <startling> yep.
19:15:40 <ivanm> so I'm finally watching some of the ICFP videos
19:15:56 <ivanm> but the ones on youtube don't seem to be good enough quality to actually read the code in the demos that SPJ, etc. have :(
19:19:24 <Jesin> well yeah, okay.
19:22:03 <ivanm> Jesin: huh?
19:22:37 <Jesin> err
19:22:39 <Jesin> sorry
19:22:41 <Jesin> wrong tab
19:26:36 <Jesin> hmm...  I seem to recall something about some standard-ish parser monads not following the monad laws?
19:27:53 <lispy> can anyone confirm what ghc uses under the hood for sqrt on Double?
19:28:11 <lispy> I did some digging through the source, but I got sort of lost on the genprimopscode tool
19:28:26 <lispy> I assume they marshal to C and use sqrt?
19:29:51 <Jesin> lispy: looks like it...
19:30:26 <lispy> Jesin: thanks, BTW, how did you check?
19:30:39 <lispy> I have the ghc source in front of me and I'd like to learn
19:30:54 <Jesin> http://www.haskell.org/ghc/docs/latest/html/libraries/
19:31:50 <jmcarthur> Jesin: i can't think of what monad laws wouldn't be followed. doesn't mean that's wrong, though.
19:32:47 <latro`a> the associativity of bind is the usual thing to break down
19:32:54 <latro`a> as it is the subtlest
19:33:05 <latro`a> the others break and everything falls apart
19:33:40 <lispy> Jesin: Hmm...I guess I don't know where to look at on that page. I traced it to sqrtDouble# but that was defined as sqrtDouble# = let x = x in x; so I started looking at the genprimops tool.
19:33:47 <jmcarthur> i don't think it's that subtle
19:34:03 <latro`a> it's not particularly subtle, but it's the hardest one to check
19:34:20 <latro`a> one example that looks like it should work is a monad where join = map head
19:34:24 <latro`a> *"monad"
19:34:31 <latro`a> fmap is the usual, return is the usual
19:34:56 <jmcarthur> i just mean that it's easy to bump into cases where broken associativity breaks your code
19:35:02 <latro`a> sure
19:35:15 <latro`a> idk, I haven't done enough with the parser monads to know what Jesin menas
19:35:16 <latro`a> *means
19:35:22 <jmcarthur> since it's necessary for abstracting many subexpressions
19:35:37 <latro`a> right, it's just less likely
19:35:49 <latro`a> since the return laws are necessary to put separate pieces together, basically
19:35:50 <Jesin> I traced it to sqrtDouble# but that was defined as sqrtDouble# = let x = x in x; so I started looking at the genprimops tool.
19:36:18 <Jesin> lispy: when something shows up as "defined" as "let x = x in x",
19:36:18 <shachaf> lispy: What are you looking for?
19:36:43 <Jesin> lispy: that means it's actually a primitive.  (Ofc they don't actually use that definition at all.)
19:37:08 <rwbarton> well yes but the question is how is that primitive implemented
19:37:09 <lispy> Jesin: yes. I know that. That's why I started looking at the tool that generates the prim op.
19:37:11 <Jesin> lispy: this especially applies when the name ends with a '#', which is typically used for GHC primitives.
19:37:15 <Jesin> ah, k
19:37:28 <shachaf> It's implemented in the compiler -- it turns into an sqrt instruction, presumably.
19:37:30 <lispy> shachaf: what is the underlying implementation of sqrt for Doubles
19:38:03 <lispy> Let's simplify then, I'm on 64bit osx
19:38:03 <shachaf> lispy: Look in codeGen/ for DoubleSqrtOp, I think?
19:38:44 <lispy> shachaf: ah, okay then that does get turned into sqrt from math.h
19:38:51 <lispy> or whenever C defines it
19:38:53 <shachaf> It does?
19:39:27 <lispy> hmm...I thought so
19:39:32 <shachaf> I think nativeGen/X86/CodeGen.hs turns it into an sqrt instruction, at least.
19:39:34 <jmcarthur> i wouldn't expect C to play into this at all, i think
19:39:35 <lispy> compiler/nativeGen/X86/CodeGen.hs
19:39:38 <lispy> 1656:              MO_F64_Sqrt -> actuallyInlineFloatOp GSQRT FF64 args
19:39:57 <lispy> So let's find out what actuallyInlineFloatOp does
19:40:46 <lispy> I was assuming that generated a function call, but it may do something else
19:40:53 <shachaf> Nope.
19:40:59 <shachaf> Just look at the code it compiles into. :-)
19:41:10 <shachaf> Oh, no, it does.
19:41:24 <Jesin> How do I get cabal to produce a list of installed packages?
19:41:50 <Jesin> oh, wait, there it is
19:41:52 <Jesin> found it  ^^;
19:42:14 <lispy> shachaf: hah, yeah I didn't even think to check the binay. Oop.s
19:44:27 <jmcarthur> so it calls sqrt. that's disappointing
19:44:36 <lispy> for some reason I don't have binutils...
19:44:49 <shachaf> lispy: You don't need to objdump the binary...
19:45:04 <shachaf> Just use ghc -S
19:45:07 <shachaf> Alternatively, ghc-core. :-)
19:45:10 <jmcarthur> you can get ghc to do it, or use ghc-core
19:45:11 <jmcarthur> bah!
19:45:28 <shachaf> GHC's generated assembly will have more information than the disassembled binary.
19:45:42 <jmcarthur> <3 ghc-core
19:46:09 <shachaf> jmcarthur: I wish it compiled under 7.6. :-(
19:46:23 <jmcarthur> shachaf: you can use an old binary with ghc 7.6
19:46:31 <shachaf> jmcarthur: That's what I do.
19:48:35 <jmcarthur> this disassembly has so many wasted instructions :(
19:48:51 <jmcarthur> all it did was compile   test = sqrt . sqrt . sqrt
19:49:25 <shachaf> Did you -O2?
19:49:37 <jmcarthur> yes
19:49:52 <shachaf> Oh, wow, it does.
19:49:55 <shachaf>         addq $8,%rsp
19:49:55 <shachaf>         subq $8,%rsp
19:49:58 <jmcarthur> yeah
19:50:14 <shachaf> Try -fllvm
19:50:16 <jmcarthur> interestingly, the llvm backend actually generates sqrtsd instructions!
19:50:22 <jmcarthur> one step ahead of you :P
19:50:34 * shachaf had already tried -fllvm before saying that. :-)
19:50:34 <jmcarthur> well, not that interestingly i guess
19:50:41 <jmcarthur> it's a bit harder to read
19:50:52 <lispy> mine seems to call _sqrt$stub if I'm reading this correctly
19:51:21 <shachaf> It kind of seems like the x86 native code backend should be generating sqrt instructions too.
19:51:45 <shachaf> lispy: I assume that's an OS X linker thing.
19:51:49 <lispy> Turns out I'm used to reading elf files. OSX doesn't use them?
19:51:53 * hackagebot cabal-rpm 0.6.4 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.6.4 (JensPetersen)
19:51:59 <jmcarthur> shachaf: i'm guessing you see basically identical code to me. what is the difference between .LBB0_1: and .LBB1_5:?
19:52:00 * lispy just assumed osx used elf
19:52:05 <shachaf> lispy: Nope. Mach-O.
19:52:26 <lispy> What's wrong OSX, too good for elf??
19:52:29 <shachaf> jmcarthur: I don't have either of those names.
19:52:44 <jmcarthur> ah
19:53:10 <shachaf> Oh, but I see two code sections too.
19:53:24 <jmcarthur> there are small differences
19:53:34 <jmcarthur> but i don't know the purpose
19:53:58 <shachaf> Hmm, maybe this is a bug in ghc-core's pretty-printing...
19:54:24 <jmcarthur> it looks like. i see duplicated core, too
19:54:45 <YayMe> > :t liftA
19:54:46 <lambdabot>   <no location info>: parse error on input `:'
19:54:48 <dibblego> is there a library to search the PATH for an executable?
19:54:48 <shachaf> Maybe one of them is for inlining?
19:54:49 <jmcarthur> and no divider between the core and the assembler
19:54:57 <lispy> :t liftA
19:54:58 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
19:55:05 <lispy> YayMe: no "> " prefix for :t
19:55:11 <shachaf> No.
19:55:22 <YayMe> Gotcha, thanks
19:55:35 * lispy tries a division free determinant calculation to see if that helps numerical stability
19:55:36 <shachaf> Well, it does generate different code with a NOINLINE annotation...
19:55:52 <lispy> http://hackage.haskell.org/packages/archive/numeric-quest/0.2/doc/html/src/Orthogonals.html#determinantClow
19:55:58 <YayMe> :t liftM
19:55:59 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:56:03 <YayMe> :t liftA2
19:56:04 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
19:56:10 <YayMe> :t liftM2
19:56:11 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:56:23 <jmcarthur> shachaf: i still see the duplication though, at least in the assembly
19:56:30 <shachaf> jmcarthur: Right, but not in the Core.
19:56:48 <jmcarthur> yeah
19:56:53 * hackagebot sparsecheck 0.1.0.3 - A Logic Programming Library for Test-Data Generation  http://hackage.haskell.org/package/sparsecheck-0.1.0.3 (KidoTakahiro)
19:57:06 <shachaf> Are you seeing # BB#1:                                 # %nhD
19:57:11 <shachaf> instead of LBB0_1?
19:57:19 <dibblego> :t let lift0=pure,lift1=liftA,lift2=liftA2 in (lift0, lift1, lift2)
19:57:20 <lambdabot> parse error on input `,'
19:57:28 <dibblego> :t let lift0=pure;lift1=liftA;lift2=liftA2 in (lift0, lift1, lift2)
19:57:29 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *) a2 b1 c (f2 :: * -> *). (Applicative f, Applicative f1, Applicative f2) => (a -> f a, (a1 -> b) -> f1 a1 -> f1 b, (a2 -> b1 -> c) -> f2 a2 -> f2 b1 -> f2 c)
19:57:44 <YayMe> Is this accurate: lift takes a function that acts on simple types and makes the function act on complex types?
19:57:59 <jmcarthur> shachaf: BB#0: BB#3: .LBB1_1: BB#4: etc.
19:58:00 <YayMe> (and the _ variants do so but throw out the return)
19:58:10 <shachaf> Hm.
19:58:11 <lispy> YayMe: simple/complex sounds a bit hand wavey
19:58:15 * shachaf switched to ghc -S
19:58:18 <YayMe> lispy: I know
19:58:23 <dibblego> YayMe: "complex type" is not common nomenclature, but it appears somewhat accurate
19:58:59 <jmcarthur> shachaf:  -S appears to match, at first glance at least
19:59:03 <shachaf> Yep.
19:59:05 <YayMe> dibblego: I don't know the correct nomenclature to generalize the data types or type classes or whatever in haskell, I know "complex type" from C#
19:59:19 <dibblego> lift0 :: a -> f a (aka, return/pure)
19:59:20 <lispy> YayMe: there is a good (meaning not too difficult to grok) paper about Applicative
19:59:24 <shachaf> jmcarthur: Do you know what this "movq    $ghczmprim_GHCziTypes_Dzh_con_info, 8(%rax); leaq    -7(%r12), %rbx" thing is?
19:59:36 <dibblego> lift1 :: (a -> b -> (f a -> f b) (aka, fmap/liftA/liftA)
19:59:43 <shachaf> (And why it's coming in between "sqrtsd"s?)
19:59:45 <dibblego> lift2 :: (a -> b -> c) -> (f a -> f b -> f c)
19:59:52 <dibblego> lift3 :: (a -> b -> c -> d) -> (f a -> f b -> f c -> f d)
19:59:58 <rwbarton> shachaf: maybe building a boxed Double?
20:00:00 <jmcarthur> shachaf: it looks a lot like a mangled C++ name. probably due to llvm
20:00:06 <dibblego> YayMe: LINQ is related to this concept
20:00:07 <shachaf> jmcarthur: No, that's Z-encoding.
20:00:14 <shachaf> It's GHC's encoding scheme.
20:00:17 <rwbarton> @src Double
20:00:17 <lambdabot> data Double = D# Double#
20:00:20 <jmcarthur> oh my ignorance is showing, sorry
20:00:22 <shachaf> We used to have a bot in here that did Z-decoding.
20:00:24 <rwbarton> zh = # right
20:00:26 <shachaf> But no more. :-(
20:00:36 <shachaf> Yep.
20:00:40 <jmcarthur> then i obviously have no idea
20:00:49 <YayMe> dibblego: How so? I'm very comfortable with linq, but I tend to recognize linq in many of the simple common functions, I don't see how applicative is particular to it
20:00:52 <lispy> it would be easy to make a lambdabot plugin for that: http://hackage.haskell.org/package/zenc
20:01:01 <shachaf> rwbarton: I'm seeing "sqrtsd %xmm0, %xmm0; <that thing>; sqrtsd %xmm0, %xmm0; sqrtsd %xmm0, %xmm0"
20:01:07 <lispy> just hook that package up as a plugin
20:01:16 <rwbarton> odd
20:01:24 <shachaf> I expect unboxing but I don't expect it to happen *after* an sqrt instruction.
20:01:28 <dibblego> YayMe: what is the type of this expression: (f, a, b) => from ff in f; from aa in a; from bb in b; select ff(aa, bb);
20:01:29 <rwbarton> how many square roots are you trying to take
20:01:33 <shachaf> Three.
20:01:37 <rwbarton> oh
20:01:43 <shachaf> test :: Double -> Double; test = sqrt . sqrt . sqrt
20:01:46 <YayMe> dibblego: for instance, select = map, aggregate = foldl, selectmany = >>=, where = filter, first = filter . head
20:01:48 * shachaf is just using jmcarthur's code here.
20:01:54 <rwbarton> i think it is boxing, not unboxing
20:01:56 <YayMe> err head . filter rather
20:02:02 <dibblego> YayMe: approximately, yes
20:02:11 <rwbarton> and it is just reordered to improve pipelining
20:02:18 <shachaf> Oh, that makes sense, I guess.
20:02:18 <rwbarton> those are my uninformed guesses
20:02:37 <YayMe> dibblego: So applicative doesn't need to enter into the transliteration from linq to functional concepts that I see?
20:02:47 <dibblego> YayMe: what is the type of this expression: (f, a, b) => from ff in f; from aa in a; from bb in b; select ff(aa, bb);
20:03:29 <YayMe> you want a signature?
20:03:34 <dibblego> yes
20:03:35 <YayMe> or a c# version?
20:03:37 <dibblego> C#
20:03:52 <shachaf> Anyway the code generated by non-LLVM really annoys me.
20:04:15 <shachaf> But I guess that's why LLVM exists.
20:04:22 <jmcarthur> still...
20:04:47 <shachaf> The rsp business probably some sort of constant FFI header.
20:05:42 <shachaf> OK, it looks like it's indeed boxing.
20:05:43 <YayMe> public IEnumerable<TVal> ApplyIndexRelated<T,U,V>(IEnumerable<Func<U,V,TVal>> f, IEnumerable<U> a, IEnumerable<V> b)
20:05:53 <YayMe> dibblego: No?
20:06:09 <dibblego> YayMe: IEnumerable here really stands for "anything with Select and SelectMany" right?
20:06:24 <YayMe> IEnumerably is just []
20:06:29 <dibblego> no, it's different to []
20:06:39 <YayMe> How?
20:06:40 <dibblego> but that expression runs on anything with Select and SelectMany, not just I
20:06:44 <dibblego> not just IEnumerable
20:06:55 <Jesin> Have haskell's version-dependency issues improved at all?
20:07:29 <dibblego> YayMe: [] is isomorphic to its reduction (foldr) — foldr is not even possible on IEnumerable
20:07:32 <jmcarthur> shachaf: why doesn't the non-llvm output have that?
20:07:50 <dibblego> YayMe: but that is not the point — the point is that expression is unrelated to IEnumerable — that's just one possibility
20:07:51 <shachaf> jmcarthur: Have what?
20:08:01 <jmcarthur> $ghczmprim_GHCziTypes_Dzh_con_info
20:08:07 <shachaf> It does.
20:08:21 <shachaf> It happens after all the sqrts.
20:08:30 <YayMe> public IEnumerable<TVal> EnumerateAndApply(IEnumerable<Func<U,V,TVal>> f, IEnumerable<U> a, IEnumerable<V> b) { return f.Select(ff => a.Select(aa => b.Select(bb => ff(aa, bb)))); }
20:08:32 <shachaf> So I believe rwbarton's theory.
20:08:39 <shachaf> Probably some clever LLVM thing.
20:08:41 <jmcarthur> is it encoded differently or something? i don't see it
20:08:42 <dibblego> YayMe: that won't type-check
20:08:54 <dibblego> you want 2xSelectMany with Select at the end
20:09:02 <dibblego> let's convert that type to Haskell anyway
20:09:12 <dibblego> I am going to replace IEnumerable with F
20:09:21 <shachaf> jmcarthur: I do.
20:09:23 <YayMe> dibblego: Wait, why won't it type check?
20:09:34 <dibblego> YayMe: many reasons, try it if you like
20:09:59 <dibblego> F (U -> V -> TVal) -> F U -> F V -> F TVal
20:10:07 <YayMe> I don't have visual studio installed on this machine, but I don't see why my C# wouldn't type check?
20:10:07 <dibblego> YayMe: did I just writ ethe same thing with a different notation?
20:10:10 <Jesin> So, I'm trying to "cabal install directory"
20:10:28 <dibblego> return f.SelectMany(ff => a.SelectMany(aa => b.Select(bb => ff(aa, bb)))); // this will type-check
20:10:48 <dibblego> YayMe: did I just write the same thing with a different notation?
20:10:52 <jmcarthur> shachaf: http://hpaste.org/75281
20:10:56 <Jesin> and I'm getting these errors: http://ix.io/32Y
20:11:03 <YayMe> dibblego: yes you did, as long as you're calling F = IEnumerable?
20:11:14 <shachaf> jmcarthur: It's the         movq $D#_con_info,-8(%r12)
20:11:26 <shachaf> I don't know why it's not Z-encoded in your version... It is here.
20:11:29 <jmcarthur> oh!
20:11:30 <dibblego> YayMe: No I am definitely not, because I said earlier, C# has no such requirement
20:11:33 <clahey> Hi all.
20:11:36 <shachaf> What version of GHC etc.?
20:11:42 <jmcarthur> 7.6.1
20:11:47 <clahey> Is it possible to create a type which can later be extended by other modules?
20:11:49 <dibblego> YayMe: the expression I gave has nothing to do with IEnumerable — you just chose to specialise it that way
20:11:50 * shachaf is using 7.6.1 too...
20:11:53 <Jesin> I'm on 7.4.2
20:11:54 <jmcarthur> x86_64 linux
20:12:02 <shachaf> Also.
20:12:05 <YayMe> dibblego: ahh I see it now
20:12:09 <clahey> For example, can I create a Figure type and define a bunch of instances of it, and then later have someone else be able to do the same?
20:12:10 <jmcarthur> curious
20:12:25 <clahey> I know I can do this with a Typeclass like Ord, but I can't then make an [Ord]
20:12:28 <dibblego> YayMe: k, now what haskell function has the type we just wrote?
20:12:30 <shachaf> clahey: Are you sure that's what you want?
20:12:32 <clahey> Is there any way to do something like this?
20:12:40 <shachaf> clahey: It's possible that what you want is just values, not types.
20:12:42 <clahey> shachaf, Not entirely sure.
20:12:46 <shachaf> clahey: See the FAQ about this:
20:12:47 <shachaf> @where faq
20:12:47 <clahey> Hmm.
20:12:47 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
20:13:01 <dibblego> let me put it in lower-case characters for clarity
20:13:03 <dibblego> F (U -> V -> TVal) -> F U -> F V -> F TVal
20:13:09 <shachaf> 5.4, I think.
20:13:17 <dibblego> f (u -> v -> tval) -> f u -> f v -> f tval
20:13:46 <YayMe> dibblego: b >>= (\bb -> a >>= (\aa -> map (\ff -> ff aa bb) f))
20:14:05 <dibblego> @type liftA2
20:14:06 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
20:14:10 <dibblego> that innit?
20:14:18 <YayMe> dibblego: is that reasonable definition of applyMuch f a b
20:14:42 <dibblego> YayMe: almost, you've reordered the effects
20:14:48 <jmcarthur> shachaf: ah, it's ghc-core doing that. ghc -S gives the Z-encoded version
20:14:54 <dibblego> @type \f a b -> f <$> a <*> b
20:14:55 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
20:15:05 <shachaf> Oh, that's nice of ghc-core to do.
20:15:10 <jmcarthur> but ghc-core apparently fails to do the same for the llvm backend
20:15:26 <dibblego> YayMe: "Applicative =>" here stands for "anything with Select and SelectMany" — but this is not entirely accurate and requires further discussion
20:15:30 <dibblego> so
20:15:37 <dibblego> Applicative f => f (u -> v -> tval) -> f u -> f v -> f tval
20:15:46 <dibblego> that is the type of the expression I have in C#
20:16:05 <YayMe> right
20:16:06 <YayMe> ok
20:16:12 <YayMe> so Applicative is like IEnumerable?
20:16:16 <dibblego> No.
20:16:19 <YayMe> balls.
20:16:24 <mebaran151> so I have a quick question; not sure how to structure it; I have a rest api that returns a url to get more results
20:16:32 <dibblego> IEnumerable is one instance of "something with Select and SelectMany"
20:16:37 <mebaran151> what's the best way to collect them all in one list
20:17:04 <dibblego> and since we are calling "things with Select and SelectMany" as "Applicative" (much to my distaste — it is inaccurate), then you can say
20:17:09 <dibblego> IEnumerable is one instance of Applicative
20:17:33 <Cale> Isn't SelectMany essentially bind?
20:17:38 <dibblego> Yes, sorry!
20:17:45 <YayMe> dibblego: In the sig you just wrote though, where you're constraining that f is an applicative and then making an f with a function, you're saying that function is effectively iteratable?
20:17:50 * lispy notes that the division free determinant calculation returns very, very different answers...
20:17:59 <otters> :t liftA3
20:18:00 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
20:18:09 <dibblego> YayMe: No, I am saying it is Applicative, not all applicatives are "things that are iterable"
20:18:15 <otters> :hoogle f (a -> b -> c) -> f a -> f b -> f c
20:18:24 <dibblego> YayMe: in fact, I have an example of running LINQ on Func (another Applicative)
20:18:26 <otters> oh yeah
20:18:57 <dibblego> http://code.google.com/p/kinet/ The Func monad using LINQ
20:19:06 <YayMe> dibblego: Applicative means anything with select and selectmany only in that particular expression you made earlier, but it doesn't always mean that?
20:19:31 <dibblego> YayMe: ok, let's stop saying Applicative is Select and SelectMany, because it is not accurate
20:19:32 <YayMe> dibblego: And that's only because of the foreall with the kind constraint of (* -> *) no?
20:19:48 <dibblego> YayMe: we will now call things with Select and SelectMany as "Semi-monads"
20:19:57 <dibblego> Applicative is very closely related, but not quite the same
20:20:12 <YayMe> Cale: yes, selectmany is >>=
20:20:19 <dibblego> so now, SemiMonad always means "something with Select and SelectMany"
20:20:26 <YayMe> okey
20:20:30 <dibblego> and LINQ will run on any SemiMonad
20:20:37 <dibblego> IEnumerable is one such SemiMonad
20:20:41 <dibblego> IQueryable is another
20:20:47 <dibblego> and Func<T, _> is yet anothre
20:20:57 <YayMe> wait
20:21:10 <otters> :t liftM3 id
20:21:11 <lambdabot> forall a2 a3 r (m :: * -> *). (Monad m) => m (a2 -> a3 -> r) -> m a2 -> m a3 -> m r
20:21:23 <dibblego> except Select/SelectMany are missing in the BCEL, so I wrote it as extension methods
20:21:26 <YayMe> how is Fun<T, _> one? you can't execute select on that in C#? You can apply it, effectively "select" ing it as the single element to be mapped
20:21:29 <YayMe> is that what you mean?
20:21:41 <dibblego> YayMe: what is the type signature of Select?
20:22:02 <clahey> shachaf, It's nice that forall lets me do it if I want to, but I will think more about making the base class store a bunch of functions.
20:22:19 <shachaf> clahey: forall? What?
20:22:21 <clahey> Will it really not slow things down that the functions store closures for the data?
20:22:49 <shachaf> Oh, you mean an existential type with a class constraint?
20:22:57 <YayMe> IEnumerable<TResult> Select(this IEnumerable<T> target, Func<T,Result> funcToApply) { foreach(T item in target) { yield return funcToApply(item); } }
20:22:58 <clahey> shachaf, 5.3 explains a way to use existential types to do it,  but advocates against it.
20:22:58 <shachaf> clahey: You shouldn't use words like "base class".
20:23:10 <dibblego> YayMe: not necessarily IEnumerable though right?
20:23:16 <clahey> shachaf, I meant "What I would have used as a base class before"
20:23:24 <YayMe> dibblego: IQueryable implements IEnumerable, so yes
20:23:37 <dibblego> YayMe: no, "anything with Select" — absolutely *anything*
20:23:45 <shachaf> clahey: A record of functions pretty similar to what you would get with virtual methods in an OO language, isn't it?
20:23:45 <dibblego> YayMe: this is a really important point
20:23:47 <YayMe> dibblego: System.Array implemented IEnumerable, this is how the extension method gets tacked on their as well
20:23:48 <shachaf> (I assume that's the sort of thing you're trying to do here.)
20:23:59 <shachaf> Note that thinking in terms of OO like that won't help you. :-)
20:24:01 <YayMe> dibblego: so all the subtypes
20:24:03 <dibblego> YayMe: I can write Swizzle#Select write now and use LINQ right?
20:24:10 <dibblego> YayMe: also, all the not subtypes
20:24:21 <shachaf> Anyway, the existential type approach will probably compile to pretty much the same thing.
20:24:22 <YayMe> dibblego: Swizzle? I forget exactly what that means
20:24:27 <clahey> shachaf, It's similar, except that the data is also stored in the functions.
20:24:28 <dibblego> YayMe: I just made it up — this is the point
20:24:38 <clahey> shachaf, So in OO, you have data separate from functions.
20:24:41 <shachaf> Since a type class is just a record of functions/values.
20:24:50 <dibblego> YayMe: *anything* anything absolutely anything with Select, not IEnumerable, not just its subtypes, not anything related to it in fact
20:25:03 <shachaf> clahey: Why do you expect it to slow things down?
20:25:12 <YayMe> dibblego: Uhm, what has select that is not inherit IEnumerable?
20:25:16 <clahey> shachaf, Here, each object has a different function, each of which encodes the data.
20:25:32 <dibblego> YayMe: An enormous number of things — please trust me on this for at least a brief moment
20:25:41 <clahey> Because at construction time for each object, you're effectively creating a new virtual method table, no?
20:25:44 <shachaf> clahey: Well, GHC isn't actually generating new machine code at runtime, of course.
20:26:11 <shachaf> Oh, well, I guess I see what you mean.
20:26:16 <YayMe> dibblego: I can see in my head a set of "All types which you may execute select against", but using C# as the allegory it doesn't stretch very far, though I'll imagine you don't mean the set of things which can fit that precise sig I defined
20:26:23 * shachaf would suggest not worrying about it right now. :-)
20:26:43 <clahey> I'll do it the more haskelly way for now.  :)
20:26:49 <YayMe> dibblego: I trust that you can execute select on other things, but I don't know what they are?
20:26:51 <dibblego> YayMe: let's just say for now, "SemiMonad (anything with Select)" and that the only thing you can think of right now is IEnumerable — let's change that
20:26:56 <dibblego> YayMe: with me?
20:27:02 <YayMe> Okey
20:27:06 <dibblego> SemiMonad<TResult> Select(this SemiMonad<T> target, Func<T,Result> funcToApply)
20:27:12 <dibblego> this is the type signature of Select right?
20:27:27 <YayMe> yes
20:27:36 <YayMe> but now you're capturing it into a different generic type
20:27:36 <dibblego> I am going to give you a new SemiMonad, here I go
20:27:52 <dibblego> Func<X, TResult> Select(this Func<X, T> target, Func<T,Result> funcToApply)
20:28:02 <dibblego> I just replaced SemiMonad with Func<X, _> right?
20:28:13 <YayMe> Yes..
20:28:23 <YayMe> oh
20:28:24 <dibblego> looking only at the signature, what do you think this might do?
20:28:31 <YayMe> Ok, I see now
20:29:01 <YayMe> It will execute the funcToApply and hand it the func you're extension method is executed on as a param, and return the result
20:29:07 <clahey> So I have data Figure = Figure { showFigure :: DisplayMethod -> String, count :: Context -> Integer }
20:29:15 <clahey> Then I define, for example:
20:29:46 <dibblego> YayMe: this particular function is so common that it has a name, "Function composition"
20:29:54 <YayMe> right
20:29:57 <dibblego> YayMe: it takes two functions and composes them into one
20:30:00 <YayMe> I was going to say.. it looks like composition
20:30:09 <YayMe> ohh right yes
20:30:13 <dibblego> YayMe: so, function composition is one example of a SemiMonad that is unlike IEnumerable right?
20:30:16 <clahey> mkDSD direction distance = Figure { showFigure displayMethod = showDSD displayMethod direction distance, count _ = countDSD distance }
20:30:28 <clahey> shachaf, Something like that?
20:30:45 <clahey> shachaf, And then perhaps also parseDSD xmlTree = ...
20:30:52 <YayMe> dibblego: I just feel like using the term "select" to refer to what's happening there is a stretch. I grant the signature is similar, but when I imagine select/map I presume an iteration is occurring
20:31:21 <clahey> Oh, it'd be parseDSD :: Context -> XML -> Figure
20:31:24 <dibblego> YayMe: I am asking you to stop thinking this, because it is limiting you — trust me, all of this falls back to a formalism
20:31:26 <shachaf> clahey: I think that's a syntax error, but you can try something like that.
20:31:52 <YayMe> dibblego: Ok, so select/map does not always imply and iteration. got it
20:31:54 <clahey> shachaf, Can you not define functions inside a record like that?
20:31:55 <dibblego> YayMe: there are some additional constraints on implementations Select — they are called laws
20:31:57 <YayMe> s/and/an/g
20:32:04 <clahey> shachaf, I can figure out the syntax.  Just curious about the concept.
20:32:12 <dibblego> YayMe: do you think you could so same for SelectMany with Func<X, _> ?
20:32:14 <shachaf> clahey: You can use lambda syntax.
20:33:01 <clahey> shachaf, I can even make a map from Text to Context -> XML -> Figure.
20:33:21 <clahey> Fill it up and then my parse loop will be very tight.
20:33:33 <clahey> shachaf, I'm convinced.
20:33:33 <YayMe> dibblego: selectMany f a b = f >>= (\ff -> a >>= (\aa -> b >>= (\bb -> ff aa bb)))
20:33:49 <clahey> shachaf: I think it's time to head to bed soon, but thank you very much for the advice.
20:33:53 <dibblego> YayMe: how does the type of SelectMany look when the SemiMonad is Func<X, _> ?
20:34:22 <mapreduce> YayMe: There are quite a number of linq backends besides System.Linq
20:35:40 <shachaf> clahey: Good luck!
20:36:18 <dibblego> YayMe: every implementation of Select must satisfy these two things: 1) x.Select(z => z) == z 2) x.Select(g).Select(f) == x.Select(q => f(g(q)) — other than this, there are no other rules on Select (no iteration, nothing) — function composition satisfies these rules
20:36:23 <dibblego> oops
20:36:27 <dibblego> YayMe: every implementation of Select must satisfy these two things: 1) x.Select(z => z) == x 2) x.Select(g).Select(f) == x.Select(q => f(g(q)) — other than this, there are no other rules on Select (no iteration, nothing) — function composition satisfies these rules
20:36:28 <YayMe> Func<X, _> SelectMany(this Func<T, _> target, Func<Func<T, _>, Func<X, _>> apply)
20:36:43 * shachaf wonders why people are using this horribly verbose syntax in #haskell.
20:36:47 <shachaf> What is this, Scala?
20:36:49 <clahey> shachaf, showFigure = flip (flip showDSD direction) distance
20:36:53 <dibblego> YayMe: Func<X, TResult> Select(this Func<X, T> target, Func<T,Func<X, Result>> funcToApply)
20:36:57 <shachaf> clahey: :-(
20:37:00 <mapreduce> shachaf: C#
20:37:02 <clahey> shachaf, No?
20:37:02 <shachaf> clahey: Writing out the names isn't bad.
20:37:22 <shachaf> @unpl flip (flip showDSD direction) distance
20:37:22 <lambdabot> (\ c -> showDSD c direction distance)
20:37:24 <clahey> shachaf, I generally prefer function modification to lambda syntax.
20:37:35 <shachaf> clahey: That flip thing is unreadable.
20:37:37 <mapreduce> Scala isn't quite as bad as that.
20:37:45 <clahey> shachaf, Hence my use of the word generally.
20:38:06 <shachaf> I "generally" prefer whatever makes the code clearest. :-)
20:38:15 <clahey> shachaf, I concur it's much less readable, but I wanted to show off my cleverness like the show off I obviously am.  :)
20:38:31 <shachaf> clahey: lambdabot can autogenerate this sort of code for you. No cleverness needed.
20:38:35 <shachaf> @pl (\ c -> showDSD c direction distance)
20:38:35 <lambdabot> flip (flip showDSD direction) distance
20:38:50 <clahey> Fair enough.
20:38:50 <YayMe> dibblego: Ok, I understand those rules. Is there a term or name for those rules I can remember/communicate them as?
20:39:12 <dibblego> YayMe: yes, things with Select are called "Functors" and things with SelectMany, plus a couple more constraints are called "Monads"
20:39:22 <clahey> /method = showDSD method distance direction
20:39:27 <clahey> \method = showDSD method distance direction
20:39:29 <clahey> Like that?
20:39:35 <dibblego> YayMe: C# cannot represent the abstraction in its type system (haskell can)
20:39:46 <clahey> Night all.
20:39:51 <YayMe> dibblego: So those 2 rules are functors, there's different rules for selectmany? a superset of those rules?
20:40:02 <dibblego> interface Functor<F<_>> { F<B> Select<A, B>(F<A> a, Func<A, B> f); } // pretend C# that can do it
20:40:22 <dibblego> YayMe: those two rules are the functor laws, monads have three laws
20:40:47 <dibblego> YayMe: the one rule for SelectMany is that it must be associative — additional rules apply when you give the full monad definition
20:41:36 <dibblego> x.SelectMany(f).SelectMany(g) == x.SelectMany(q => f(q).SelectMany(g)) // associative law
20:42:12 <YayMe> dibblego: Why can't C# do that interface you defined? The _ ?
20:42:30 <dibblego> YayMe: the type system cannot do it — I just invented a notation as if it could
20:43:16 <YayMe> If you change the _ to T that should be a valid interface, but would it then not meet the critera you refer to?
20:43:21 <shachaf> This seeems like a #haskell-overflow topic.
20:43:26 <dibblego> YayMe: try it
20:43:44 <shachaf> It's been going on for the past hour. :-)
20:44:06 <YayMe> shachaf: Sorry about this
20:44:39 <YayMe> Stupid haskell always does this, time goes by so fast when I'm trying to unravel it..
20:44:51 * shachaf doesn't mind, but that channel is better for this sort of discussion. :-)
20:54:15 <clahey> shachaf, So, I realized that it was more important that DisplayMethod be extensible than the rest.
20:54:34 <clahey> shachaf, But I came up with a compromise that allows everything I'm thinking of.
20:55:52 <clahey> FigureType = DSD { direction :: LR, distance :: Int } | Hey { crossings :: [Crossing] } | BalSw { target :: [Target] } | ...
20:56:12 <clahey> FigureSemantics = FigureSemantics FigureType OtherInfo
20:56:30 <clahey> Figure = Figure { functionA = blah, functionB = blah, semantics :: FigureSemantics }
20:56:52 <clahey> Oh, and FigureType would include = Unknown { encoding :: Text }
20:57:34 <clahey> shachaf, Is there anything like that in the haskell world?
20:58:34 <clahey> My thinking is that the DisplayMethod would be a function which would look at the figure semantics and do its work.
20:59:04 <clahey> Since Figure has the built in methods, it can basically have a default display method in case DisplayMethod returns an error (however I represent that.)
20:59:40 <clahey> If display figure returns Nothing, then the figure uses its default implementation.  That way new figures will have their own rendering.
20:59:52 <clahey> But display methods can handle any figures they want to change the behavior of.
21:00:21 <YayMe> If I have 3 .hs files in a folder and execute cabal build will it just try and build an exe from them automatically?
21:00:32 <clahey> shachaf, Did that all make any sense?
21:01:34 <clahey> Oh, time for bed.  tt y'all later!
21:07:22 <YayMe> Anyone got an idea of something for me to work on that would actually be helpful/useful? Plenty of useless challenges but those are far less motivating
21:07:58 * YayMe wishes windows git wasn't such a huge pain in the ass to use
21:10:26 <mapreduce> I find msysgit (git bash) ok.
21:11:08 <YayMe> looking for something open source to poke and prod, would I be better off looking at hackage packages, darcs, or github?
21:14:14 <KirinDave> So...
21:14:15 <KirinDave> Is this style of code normal?
21:14:16 <KirinDave> https://github.com/yaccz/jsmin-hs/blob/master/jsmin.hs
21:15:01 <m3ga> KirinDave: nothing too strange there
21:15:03 <m3ga> why?
21:15:27 <KirinDave> It just looks machine generated to me.
21:15:40 <m3ga> if it was me, the pattern guards would not be indented that far.
21:15:50 <m3ga> probably not.
21:15:50 <KirinDave> I mean, implementing it that way
21:16:06 <KirinDave> I guess it's 2 years old.
21:16:21 <KirinDave> That's before Text and Attoparsec were well-established.
21:16:33 <KirinDave> You wouldn't write this package this way today, i suspect.
21:22:13 <m3ga> KirinDave: here's a JS render (from an AST) written using Builder : https://github.com/erikd/language-javascript/blob/new-ast/src/Language/JavaScript/Pretty/Printer.hs
21:22:17 <m3ga> it may also look machine generated. i guarantee you, it wasn't :-)
21:22:46 <KirinDave> m3ga: Haha. What is this?
21:23:12 <m3ga> my new-ast branch of the language-javascript package.
21:23:44 <m3ga> lang-js is used in hsmin, another haskell JS minifier
21:24:05 <KirinDave> To be honest, I understand this code much more readily.
21:24:12 <KirinDave> Once I figured out what pacc meant.
21:24:21 <m3ga> thanks, it was written to be readable :-)
21:24:41 <KirinDave> HOW it works, I'll have to consider more.
21:25:10 <KirinDave> m3ga: This builds code, right?
21:25:19 <KirinDave> It's not a parser.
21:25:28 <m3ga> KirinDave: yes, generates JS from an AST
21:25:43 <KirinDave> Cool.
21:25:51 <m3ga> lang-js also includes a parser and AST definition.
21:26:44 <m3ga> the pretty printer uses blaze-builder which is good for building output from lots of small string chunks (used in things like yesod as well).
21:27:09 <KirinDave> yeah, blaze is a great package.
21:28:06 <m3ga> i really need to talk to the upstream about getting that branch merged up into master.
21:28:30 <KirinDave> I need to find a way to general-ify and open source all this hakyll work I am doing
21:28:35 <KirinDave> The more I do with this the more rad it gets.
21:29:00 <KirinDave> I'm working on a branch to move away from using strings internally.
21:29:48 <m3ga> what does hakyll do again?
21:30:07 <KirinDave> Static site compiler.
21:30:31 <m3ga> cool. much easier to google it when i spell it correctly
21:31:41 <ion> kirindave: I’ve been meaning to start using Hakyll. I’m looking forward to your Hakyll work. :-)
21:32:06 <KirinDave> ion: I'll give it all to you if you want. Nothing sensitive here. It's just not genericzed and some bits are ugly.
21:32:25 <KirinDave> If I had to do it all again I'd not use sass, i'd use lucious or some other template thing I could make pure
21:32:37 <KirinDave> If I get some free time I'll switch from using jsmin to hsmin.
21:33:06 <KirinDave> Would be nice to get a pure Compiler for that operation.
21:39:53 <YayMe> Anyone have any tips on where to create a blog to post my software rants? I read plenty of others on weblogs.com blogger and yadda yadda, anyone have experience with one that can suggest?
21:40:13 <ion> kirindave: Thanks, but i’m probably not getting around to the Hakyll stuff very soon. I’ll see what’s available when i finally get to that.
21:40:47 <KirinDave> ion: I am just glad it gave me a better intuition about arrows.
21:44:14 <NemesisD> anyone know about Network.Socket? i'm trying to rig up some IPC with unix domain sockets
21:46:55 * hackagebot buildbox 2.1.2.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.2.1 (BenLippmeier)
22:15:09 <startling> is there a type like a -> Writer e b ?
22:15:23 <startling> can you do this some clever way with WriterT?
22:17:45 <shachaf> @unmtl ReaderT a (Writer e) b
22:17:45 <lambdabot> a -> (b, e)
22:18:09 <startling> woah, interesting
22:21:17 <startling> @mtl a -> (b, e)
22:21:17 <lambdabot> Maybe you meant: ft map msg pl unmtl url
22:21:22 <startling> ah well
22:27:34 <dmwit> ?unmtl WriterT e m a
22:27:34 <lambdabot> m (a, e)
22:27:49 <dmwit> ?unmtl WriterT e (Reader a) b
22:27:49 <lambdabot> a -> (b, e)
22:30:50 <mysticc> How to define reverse list using .. notation. like [1..n] is list from 1 to n . Can I have something like [n..1] ?
22:31:46 <dibblego> [n,n-1..1]
22:35:05 <latro`a> .. seems a bit more impressive than it is
22:35:13 <latro`a> once you understand how it desugars
22:41:11 <orzo> anybody know if Data.HList has anything like !! for list?
22:47:03 <YayMe> If any of the language brain-heads in here want to point out where my understanding of OOP dangers are incorrect please do, just wrote an article with my understanding at http://codewonderings.blogspot.com/2012/09/what-about-inheritance.html
22:47:16 <YayMe> And with that, it is so time for me to meet sleep. Night all.
22:59:27 <newbie_> hello good people
22:59:41 <mzero> hello newbie_
23:00:31 <newbie_> okay, i was here yesterday started learning haskell from learnhaskell online tutorial. currently in list comprehension. my question is when i write a program in haskell, how can i distribute it in such a way that my user doesn't have to bother about the language i write it in
23:00:52 <mzero> you compile it and ship an executable
23:01:08 <mzero> just like you would if you wrote it in C or C++
23:01:18 <newbie_> so i just give them an executable to run. they don't have to install any haskell dependencies such as ghci, etc
23:01:25 <mzero> correct
23:01:30 <frio> ghc -o YourNewProgram.exe YourProgram.hs
23:01:33 <newbie_> mzero: oh cool. so i don't need to tell them program is in haskell :)
23:01:37 <newbie_> thanks.
23:01:42 <mzero> right
23:01:44 <frio> (i think?)
23:01:59 <pnielsen> You may want to statically link it -- same options as GCC
23:02:11 <newbie_> i want to invoke haskell bot to run something for me :D
23:02:29 <mzero> on Mac it will statically link all the haskell bits, and dynamically link all the system bits - which is what you want
23:02:39 <mzero> not sure about the default on other OSes
23:02:57 <pnielsen> ghc -c Foo.hs -o foo
23:02:59 <newbie_> [x*2 | x <- [1..10]]
23:03:12 <newbie_> how to invoke the haskell channel bot?
23:03:12 <mzero> > [x*2 | x <- [1..10]]
23:03:13 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
23:03:24 <shachaf> Hmm, "By default, GHC under Windows will link in a static copy of the GMP library.".
23:03:25 <mzero> the key is the leading >
23:03:32 <pnielsen> ghc Foo.o libfoo.a -o prog
23:03:35 <newbie_> > take 10 [2,4..]
23:03:36 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
23:03:38 <newbie_> :D
23:03:45 <mzero> shachaf: that sounds like a good idea - as that lib isn't generically available
23:03:56 <mapreduce> > [2,4..20]
23:03:57 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
23:04:02 <newbie_> thanks guys. still strange. but started with haskell in my free time already.
23:04:04 <pnielsen> or ghc --make Main.hs -optl-static -optl-pthread
23:04:39 <newbie_> still not gotten to the part where i comprehend that fibonacci magic equation of yesterday.
23:05:00 <newbie_> also, part where i start doing thing of minimal interest to mathematicians :D
23:05:47 <certainty> moin haskellers
23:05:53 <newbie_> > reverse [20,18..]
23:05:57 <lambdabot>   mueval-core: Time limit exceeded
23:06:15 <mzero> reversing an infinite list take infinite time
23:06:22 <mzero> :-)
23:06:26 <newbie_> take 20 (reverse [20,18..])
23:06:43 <newbie_> that above should work?
23:06:46 <mzero> > reverse (take 20 [20,18,...])
23:06:49 <lambdabot>   <no location info>: parse error on input `]'
23:06:57 <mzero> > reverse (take 20 [20,18,..])
23:06:58 <lambdabot>   <no location info>: parse error on input `..'
23:07:08 <mzero> > reverse (take 20 [20,18..])
23:07:09 <lambdabot>   [-18,-16,-14,-12,-10,-8,-6,-4,-2,0,2,4,6,8,10,12,14,16,18,20]
23:07:19 <pnielsen> no, it's trying to take the first 20 items from the end of the list, but the list has no end
23:07:28 <mzero> your version still reverses an infinite list, then takes 20 of it
23:07:31 <newbie_> pnielsen: gotcha! X_x
23:08:16 <mzero> take 20 [ 2,4.. ]   works because you can get the first 20 elements of the list without computing the whole (inifinte) list first
23:08:39 <mzero> > take 20 ( map (*100) [ 2,4.. ] )
23:08:40 <lambdabot>   [200,400,600,800,1000,1200,1400,1600,1800,2000,2200,2400,2600,2800,3000,320...
23:09:12 <mzero> that works too, because we still don't need to multiple all the elements of the (infininte) list by 100 before getting the first 20 elements
23:09:13 <pnielsen> > take 20 (reverse [20,18..(-100)])
23:09:14 <lambdabot>   [-100,-98,-96,-94,-92,-90,-88,-86,-84,-82,-80,-78,-76,-74,-72,-70,-68,-66,-...
23:09:37 <pnielsen> should be clearer now?
23:11:13 <pnielsen> or
23:11:17 <pnielsen> > take 5 (reverse [20,18..(-100)])
23:11:19 <lambdabot>   [-100,-98,-96,-94,-92]
23:12:30 <ew0_> hey, is there a way to do this shorter? "numSetBits c =  (getSize c, getBlockSize c, getAssoc c)"
23:14:36 <dibblego> numSetBits = liftA3 (,,) getSize getBlockSize getAssoc
23:15:13 <pnielsen> not worth it imo
23:18:06 <newbie_> yeah it is
23:19:01 <ew0_> uhm
23:19:06 <ew0_> looks a lot like liftM3
23:19:11 <ew0_> xD
23:19:17 <ew0_> hey more question
23:19:24 <ew0_> where is the log2 function?
23:19:25 <dibblego> liftA3 is just a better liftM3
23:19:27 <mzero> :t liftM3
23:19:29 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
23:19:32 <mzero> :t liftA3
23:19:33 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
23:19:38 <dibblego> I suspect edwardk has an even better one
23:19:59 <ew0_> :t log
23:20:00 <lambdabot> forall a. (Floating a) => a -> a
23:20:37 <mzero> > let log2 = logBase 2 in log2 64
23:20:39 <lambdabot>   6.0
23:20:51 <mzero> there it is!
23:21:55 <pnielsen> log2 = logBase 2
23:21:57 <pnielsen> that's nice
23:22:17 <mzero> you may want to apply ceiling to that if your aim to get the number of bits it takes
23:22:33 <ew0_> yes
23:22:39 <ew0_> logBase 2 32
23:22:41 <mzero> > let log2 = ceiling . logBase 2 in log2 67
23:22:45 <lambdabot>   mueval-core: Time limit exceeded
23:22:57 <mzero> ?
23:23:42 <mzero> > ceiling $ logBase 2 67
23:23:44 <lambdabot>   7
23:24:07 <pnielsen> > let log2 = ceiling . logBase 2 in log2 67
23:24:09 <lambdabot>   7
23:24:20 <pnielsen> :)
23:24:34 <mzero> did I not type with enough conviction?
23:24:56 <pnielsen> your type-foo is not strong enough
23:26:18 <hpaste> ew pasted “error1” at http://hpaste.org/75286
23:26:36 <ew0_> still having problems with log
23:26:57 <mzero> are you applying this to an integer?
23:27:19 <ew0_> yes
23:27:23 <mzero> > let log2 = ceiling . logBase 2 . fromIntegral in log2 (67 :: Int)
23:27:25 <lambdabot>   7
23:27:52 <mzero> I bet getBlockSize return Int or Integer
23:28:12 <ew0_> Int
23:28:20 <ew0_> should it not?
23:28:33 <Enigmagic> i have complex blocks.
23:28:38 <mzero> no, it can
23:28:51 <ew0_> it is not really a computation heavy type
23:28:52 <mzero> but you'll need to convert  fromIntegral   to get it to something logBase can take
23:29:07 <ew0_> fromIntegral is safe?
23:29:13 <mzero> quite
23:29:18 <ew0_> ok
23:29:44 <mzero> (it isn't like casting if that is what you're worried about)
23:29:59 <mzero> (all *those* functions have 'unsafe' in their name)
23:30:16 <ew0_> well
23:30:24 <ew0_> fromJust is not really safe isit?
23:30:45 <mzero> true dat - but in a different way than casting
23:30:50 <dibblego> I think you mean unsafeFromJust
23:31:05 <ew0_> there is a fromJust in the Data.Maybe
23:31:10 <mzero> saddly
23:31:11 <nicoo> ew0_: Technically, you can have rounding errors with fromIntegral, which will prevent you from getting the weight of the heaviest bit set to one in your integer (I assume that is what you want)
23:31:12 <ew0_> I used that for a while until it blew in my face
23:31:23 <ew0_> yeah
23:31:29 <dibblego> after it blows in your face, you should try head
23:31:45 <pnielsen> but that's the point of fromJust..
23:31:57 <ew0_> xD
23:31:59 <pnielsen> you only use it if whatever you're fromJusting won't be Nothing
23:32:04 <liyang> fromIntegral is safe in that:
23:32:07 <liyang> > fromIntegral (2^63 :: Int) :: Integer
23:32:08 <lambdabot>   -9223372036854775808
23:32:20 * Bynbo7 thought fromJustjad no pint, it's point free =)
23:32:33 <mzero> > fromIntegral (2^63 :: Int) :: Double
23:32:34 <lambdabot>   -9.223372036854776e18
23:33:08 <ew0_> theoreticaly I'll just be inputting numbers from 2^n | n <- [1..11]
23:33:10 <nicoo> ew0_: http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog
23:33:24 <ew0_> theoreticaly I'll just be inputting numbers from 2^n | n <- [1..6]
23:33:27 <ew0_> actualy not
23:33:38 <ew0_> only for [1..6]
23:34:01 <nicoo> Ok; this is perfectly safe then
23:34:05 <nicoo> Aah, damn
23:34:10 * nicoo got distracted
23:34:31 <Bynbo7> huh, I have no idea where Axman6 is connected from this should be the only machine it connects from...
23:35:11 <liyang> Bynbo7: from dang andar mate!
23:35:21 <Bynbo7> woah, I've got irssi running. ok then
23:35:35 <Bynbo7> dang andar? also, how goes it =)
23:36:16 <liyang> Bynbo7: oh, I see. You're map succ Axman6.
23:36:29 <Bynbo7> down under? surely it'd be dowwwn unda
23:36:40 <liyang> I can't do your funny accents.
23:36:49 <Bynbo7> > map succ "liyang"
23:36:50 <lambdabot>   "mjzboh"
23:37:21 <Bynbo7> ok, switching to using irssi
23:37:32 <liyang> Did I accidentally do a Kiwi accent?
23:37:52 <ew0_> I'm surprised by the beauty of my rushed haskell code
23:38:02 <ew0_> is it possible to make ugly code in haskell?
23:38:14 <pnielsen> hehe, yes
23:38:15 <liyang> ew0_: oh yes.
23:38:19 <Axman6> liyang: nah that'd be dun unduh bro
23:38:22 <ew0_> xD
23:38:23 <dibblego> yes, your code in 3 weeks
23:38:27 <pnielsen> but if you think about it a little then the solutions are often very elegant
23:38:40 <pnielsen> and yeah, don't overthink it
23:38:42 <liyang> dibblego++
23:38:44 <ew0_> I'm rewriting some very ugly python code
23:38:50 <ew0_> that I'm familiar
23:38:55 <ew0_> with
23:39:42 <ew0_> btw, my vim indentation script is working really fine
23:39:43 <mzero> "Haskell... It's a Python code prettifier, basically..."
23:39:51 <ew0_> xD
23:40:16 <ew0_> you know a place to put it it someones get interested on it?
23:40:16 <Axman6> also, see Burp, python written in haskell
23:41:44 <ew0_> o-O
23:42:54 <mzero> gist.github
23:46:56 <mzero> http://www.quickmeme.com/meme/3r27aq/
23:47:31 <certainty> :D
23:56:44 <ew0_> is there a quick way to change just one field of a record?
23:57:10 <ew0_> data A = { a :: Int, b :: Int, c:: Int }
23:57:34 <ew0_> let a1 = A 1 2 3
23:57:40 <dibblego> ew0: see the lens package on hackage
23:57:44 <ew0_> o
23:57:45 <ew0_> ok
23:58:03 <solarus> ew0_: a1 { a = 3 } should work also
23:58:14 <solarus> I believe
23:58:20 <ew0_> uhm
23:58:25 <dibblego> record selectors do not exist in my reality
23:59:50 <solarus> :)
