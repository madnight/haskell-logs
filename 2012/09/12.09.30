00:00:03 <McChousuke> In postfox notation it is always at the end, in praefix always at the front, immediately clear
00:00:13 <McChousuke> ddarius, that is what we are discusing yes
00:00:24 <Cale> McChousuke: Mathematical notation is essentially never apart from text in some human language, unless you're reading something which was intended to be consumed by a theorem prover or other mechanical thing.
00:00:28 <johnw> there's also Liskell :)
00:00:29 <McChousuke> I assert that mathematical textbook notation is bad for what it suppoed to do and therefore it might have been a mistake propagatig it in haskell.
00:00:40 <McChousuke> johnw, yeah, I know.
00:00:42 <Cale> The text tends to make all the ambiguity vanish.
00:00:51 <McChousuke> THe point is, Lisp's syntax does not make a lot of sense in the context of only 1 ary functions.
00:00:56 * ddarius recommends continuing the conversation elsewhere.
00:01:01 <Cale> The things which are left out are things which in context, do not matter.
00:01:08 <Cale> and would only provide a distraction
00:01:10 <McChousuke> It is specifically designed for n-ary functions and as such does not make a lot of sense for Haskell
00:01:41 <Cale> I have a feeling that you've had fairly bad examples of mathematical notation given to you somehow.
00:01:55 <McChousuke> Cale, and yet it creates ambiguities in communication, I've had students see asking lectures many times when notation is ambiguous which of the two was meant.
00:02:01 <pnielsen> a -> b -> c does seem pretty ambiguous
00:02:06 <McChousuke> Cale, like I said, I consider a + b + c bad
00:02:06 <Cale> These cases do exist, but most pure mathematicians at least do a very good job of inventing clear notation.
00:02:12 <McChousuke> Which is very common
00:02:22 <Cale> McChousuke: I don't consider it bad. I consider it extremely good.
00:02:38 <pnielsen> McChousuke: why + and *?
00:02:50 <McChousuke> infix notation made sense when it was first used because basically every function was binary then, then people decided 'Hey, you can have functions of more than 2 arguments' and they mixed that freely with + and -, then they said 'hey, + and - are actually just functions' and stuck with it.
00:02:57 <Cale> The only way we could somehow do better than a + b + c is to have a notation in which the terms had no visual ordering, but that's obviously not possible
00:03:22 <Cale> This notation obliterates the parentheses in order to account for associativity
00:03:25 <osfameron> McChousuke: are you arguing that Lisp's (+ 1 2 3) notation would be better?
00:03:34 <Cale> So it makes applying the associative rule a non-issue.
00:03:55 <McChousuke> Cale, okay, so you compute 3 * 6 - 3 / 6 * 2 / 4 + - 7 - - - 4 / 3 * 2 for me.
00:03:55 <Cale> The only thing it could do to be an even better notation would be to absorb commutativity into that :)
00:04:09 <McChousuke> And yes, that is ambiguous, it depends on how I decided my operator praecidence is
00:04:19 <McChousuke> REad my appendix to find out which of the many, many standards I use.
00:04:25 <pnielsen> McChousuke: so you prefer PN?
00:04:31 <Cale> Find me a published paper in which that expression occurs.
00:04:33 <osfameron> there is something attractive about Lisp's absolutely unambiguous syntax
00:04:44 <Cale> or anything remotely similar to that
00:04:45 <McChousuke> pnielsen, I would definitely say that infix notation is always a bad idea, not sure if lisp's notation is the best, but it's better.
00:04:49 <ddarius> This conversation continues to be completely unrelated to Haskell.
00:04:52 <Cale> with inline / and multiple negations
00:05:00 <McChousuke> Cale, where do you draw the lie?
00:05:04 <Cale> ddarius: Nobody's talking about Haskell atm.
00:05:06 * hackagebot gitlib 0.3.0 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.3.0 (JohnWiegley)
00:05:12 <ddarius> Cale: I agree completely.
00:05:19 <McChousuke> line*
00:05:20 <pnielsen> ddarius: which would be bad if somebody was being drowned out by the discussion
00:05:25 <Cale> ddarius: (Which makes it somewhat okay)
00:05:31 <pnielsen> it's related to notation in Haskell :)
00:05:52 <McChousuke> Cale, in some cases, ambiguities can't even be avoided, what is (a, b), is that an open intervalor an ordered pair?
00:05:59 <Cale> McChousuke: I draw the line where the notation stops being clear and unambiguous.
00:06:06 <McChousuke> Cale, that is a subjective difference.
00:06:24 <McChousuke> And then I draw the line where it starts, every single pieceof infix notation is less clear than the same thing in praefix.
00:06:34 <Cale> McChousuke: Indeed, and mathematical papers are intended to be read by other mathematicians, and are designed with a specific target audience in mind.
00:06:36 <McChousuke> + 1 2 is marginally clearer than 1 + 2
00:06:46 <Cale> disagree
00:06:49 <McChousuke> It requires my eyes to move a milimetre less to find the operation
00:07:03 <Cale> Consider something like:
00:07:09 <McChousuke> Cale, I hypothesize that the only reason you consider ithat so is because you aren't used to it.
00:07:14 <Cale> exp(x) = 1 + x + x^2/2! + x^3/3! + ...
00:07:17 <McChousuke> And if you were taught praefix from the start infix would be clearer
00:07:29 <Cale> Please put that into prefix notation for me :)
00:08:30 <McChousuke> (= (exp x) (+ 1 x (^ x (/ 2 (! 2))) (^ x (/ 3 (fact 3))) ...)
00:08:35 <pnielsen> Cale, McChousuke: http://hpaste.org/75528
00:08:47 <McChousuke> I find my version a lot easier to read than yours by the way.
00:09:17 <Cale> ah, so you're suggesting that addition become variadic?
00:09:18 <ion> I don’t.
00:09:25 <McChousuke> pnielsen, yeah, I think standard polish notation also isn'tperect, but better than infix still
00:09:48 <Cale> your version has a ton of parentheses in it which I have to visually match in order to comprehend what's being written
00:09:57 <McChousuke> Cale, why not? If you're going to improve mathematical notation
00:10:10 <johnw> + 1 2 is not clearer to me than 1 + 2
00:10:11 <McChousuke> Cale, your version has my mind first insert parethenses before it can do that.
00:10:18 <johnw> and I'm a Lisp head
00:10:21 <Polarina> I believe we can all agree that <insert notation here> is better than textbook notation.
00:10:28 <johnw> I even use RPN on my calculator
00:10:42 <johnw> 1 + 2 is just too hardwired
00:10:58 <Cale> Polarina: For many textbook notations and most choices of <insert notation here>, I am going to disagree.
00:11:01 <shachaf> "even"? Isn't that the classic place to use them?
00:11:07 <shachaf> s/them/it/
00:11:13 <McChousuke> the differene between + 1 2 and 1 + 2 is extremely marginal though, but if you get (+ 1 2 2 (- 3 4) 2 4) it becomes a lot clearer than 1 + 2 + 3 + (3 - 4) + 3 + 4
00:11:16 <ddarius> Cale: So let me expand.  Not only is this completely unrelated to Haskell, it is also completely unconstructive.  No one involved is going to change their minds about anything.
00:11:23 <johnw> shachaf: isn't Forth RPN?
00:11:30 <Polarina> Cale, textbook notation is also better than textbook notation.
00:11:33 <johnw> plus, stack-based interpreters are usually RPN
00:11:43 <johnw> (and I deal with them more than I'd like to admit)
00:11:47 <Cale> ddarius: Well, maybe
00:11:53 <McChousuke> Cale, I am pretty sure honestly that this is just habit and if you had been taught another notation from a young age you would've defended that one
00:12:05 <McChousuke> note how Americans also have troubles with the metric system simply because they aren't used to it.
00:12:05 <Cale> Perhaps I should write off McChousuke as a troll, but I tend not to want to do that :)
00:12:19 <johnw> just don't write him off in infix, please
00:12:19 <McChousuke> Cale, dude, I'm master league random.
00:12:20 <Cale> McChousuke: Perhaps, but there's value in consensus
00:12:22 <ddarius> Cale: I didn't say do that.  I suggested moving to a different channel.
00:12:39 <pnielsen> ddarius: it is related to Haskell's notation
00:12:40 <McChousuke> Cale, that doesn't derive from my point that it's an objectively bad system that only gets used a lot because people are used to it.
00:12:43 <McChousuke> Like the impierial system.
00:13:01 <McChousuke> In any case, Haskell's syntax is the biggest turnoff it ever had for me.
00:13:27 <McChousuke> Infix notatin simply makes complicated expressions hard to read, which is why people are adviced to not make them in Hakell and break them up
00:13:32 <McChousuke> in a superior notation that would not be necessary
00:13:36 <Cale> McChousuke: I'm going to disagree with the notion that any notation is objectively better or worse than any other.
00:13:47 <McChousuke> Well, that might be an off phrasing
00:13:50 <Cale> This *is* a subjective matter.
00:13:52 <pnielsen> I don't see what the problem is. The channel would be dead anyway
00:14:01 <Nisstyre-laptop> I love the error message I get when I try to match against an existential data constructor
00:14:05 <ddarius> pnielsen: It mostly isn't.  To the extent that it is, it's equally related to Java.
00:14:13 <osfameron> > (+) 1 2
00:14:14 <lambdabot>   3
00:14:28 <McChousuke> let me put it like this, if children were taught to use a constructed system that is specifically designed to be easy and unambiguous for mathematics from a young age, in the end we would save time, money, errors, and space shuttles exploding
00:15:08 <McChousuke> Just as I believed that if the US switched to Metric today, after the transition was done they would be saving time and money.
00:15:15 <Nisstyre-laptop> McChousuke: I agree
00:15:16 <astertronistic> space shuttles will always explode
00:15:20 <Cale> McChousuke: That's also very different from what we were originally talking about, which is the notation used my mathematicians.
00:15:23 <johnw> you know they started to switch in the 70s, yeah?
00:15:24 <astertronistic> people always make mistakes
00:15:32 <Cale> by*
00:15:33 <johnw> In Tucson, Arizona, the interstate street signs are both metric and standard
00:15:46 <Nisstyre-laptop> astertronistic: Challenger would never have exploded had Richard Feynman been in charge
00:15:47 <McChousuke> Cale, no, I said mathematical textbook notation is bad, and one of the reasons is it takes long to read by a human
00:15:49 <johnw> it was a test city
00:15:59 <McChousuke> other issues are that it is ambiguous and therefore cannot be directly fed to a computer
00:16:08 <Cale> There are about 100 other things which ought to be done to the mathematical education which is given to children which are far more imporatant than any choice of notation.
00:16:12 <McChousuke> if a notation existed which humans could read and write easilya s well as computers, would be better.
00:16:42 <McChousuke> Cale, of course, but that doesn't mean that it might have been a mistake for haskell to model itself after mathematical textbook notation
00:17:01 <McChousuke> And they couldn  even go all the way because mathematical textbook notation is bad
00:17:23 <McChousuke> THey couldn't really use a == b == c in that way because that would require a big overcoplication of the language
00:17:29 <McChousuke> To be able to define operators that work like that.
00:17:50 <Nisstyre-laptop> McChousuke: Scheme notation is clearly the best >.>
00:17:58 * pnielsen joins #haskell-blah :)
00:18:02 <Nisstyre-laptop> McChousuke: actually that reminds me, there is a Gerry Sussman talk where he basically agrees with you
00:18:04 <Cale> The notations which are good for human use and the notations which are good for expressing things to computers are not the same.
00:18:10 <Nisstyre-laptop> McChousuke: you should watch it
00:18:15 <McChousuke> Nisstyre-laptop, it's good if your language has n-ary functions as a focal point.
00:18:35 <McChousuke> Nisstyre-laptop, well, I do tend to agree with Sussman about a lot of things, got a link?
00:18:45 <Cale> Yeah, Sussman is a bit of a troll when it comes to this as well. :)
00:18:54 <McChousuke> Cale, the notations which are good at expressing mathematical ideas to humans are though
00:19:00 <astertronistic> that's actually possible, although it would be hard to keep it straight in all possible parsings...
00:19:06 <Nisstyre-laptop> McChousuke: http://youtu.be/fAY0_pesZ6s
00:19:12 <astertronistic> but a == b == c could be translated to (== a b c)
00:19:17 <McChousuke> I mean, logicians seldom use thigs like a = b = c in their formal proofs, they use a = b /\ b = c for the most part
00:19:20 <Nisstyre-laptop> McChousuke: it's quite long and gets into lagrangian mechanics
00:19:29 <Nisstyre-laptop> but he basically argues that math notation is bad
00:19:36 <McChousuke> Nisstyre-laptop, you got the timestamp for the math notation part
00:19:41 <astertronistic> There is an issue with a == b && c == d
00:19:41 <Nisstyre-laptop> McChousuke: about halfway through
00:19:48 <McChousuke> Why no Fez Sussman?
00:19:53 <Cale> McChousuke: Only if they are reasoning about the structure of the proof itself, is it better to choose a small set of primitives.
00:19:55 <pnielsen> there is a blurb in SICP about the superiority of PN as well, IIRC
00:19:57 <Nisstyre-laptop> McChousuke: and then the rest of the video he talks about it
00:20:07 <astertronistic> is it (& (== a b) (== c d)) or (== a (&& b c) d)
00:20:08 <McChousuke> astertronistic, well yeah, HAskell's type system is hard to unify with N-ary functions
00:20:08 <johnw> pnielsen: really?
00:20:27 <johnw> we should argue about algebraic versus classical chess notation next
00:20:30 <Cale> McChousuke: and you see, it's up to them which notation they choose, and they naturally make the right choices when it makes a difference
00:20:36 <johnw> the latter always sounds better in movies
00:20:51 <pnielsen> johnw: It's been a while. My memory might be off
00:20:57 <McChousuke> Cale, did they? I know a lot of people who were initially very hesitant about HAskell due to the notation
00:21:00 <Nisstyre-laptop> McChousuke: at 30 minutes he starts talking about it
00:21:04 <SLi> Making operations variardic loses the single benefit of infix and prefix, namely getting rid of parens.
00:21:20 <McChousuke> If I'm going to be honet, originally I couldn't take Haskell seriously onnly because of the notation, and I know many more people who had similar praejudices
00:21:27 <McChousuke> "catering to noobs, python, etc"
00:21:31 <Cale> McChousuke: hah
00:21:33 <Cale> Well, that's okay
00:21:39 <McChousuke> Nisstyre-laptop, thanks
00:21:41 <Cale> avoid success at all costs and all that :)
00:21:57 <Cale> Haskell wasn't designed to be popular
00:22:07 <pnielsen> I'm actually quite happy Haskell isn't more popular
00:22:08 <McChousuke> Nisstyre-laptop, I agree directly
00:22:17 <pnielsen> it's very hard to have a conversation like this in more mainstream languages' channels
00:22:33 <McChousuke> the df/dx notation is abuse of notation and indeed, I have also seen proves where they use / as division there to make an argument from notation
00:22:36 <McChousuke> proofs*
00:22:37 <pnielsen> (including when it's related to haskell)
00:22:48 <McChousuke> Basically, physicists giving analysis lectures don't like formality.
00:22:54 <Cale> McChousuke: I totally agree that Leibniz notation for derivatives is shit.
00:23:08 <Cale> McChousuke: which is exactly why most mathematicians don't use it today
00:23:09 <McChousuke> Should just be derive(f)
00:23:11 <McChousuke> tadaa
00:23:14 <Cale> Df
00:23:16 <Nisstyre-laptop> Cale: thank you! I thought I was the only one
00:23:22 <Nisstyre-laptop> I prefer the newtonian notation
00:23:28 <Cale> Or f'
00:23:28 <McChousuke> So D is a function exept you need no parentheseses here?
00:23:35 <Cale> You never need parenthesis
00:23:42 <McChousuke> You do in analysis
00:23:42 <Cale> parentheses*
00:23:54 <Cale> No, never. You never *need* parentheses.
00:23:56 <pnielsen> McChousuke, cale, johnw: "The convention of placing the operator to the left of the operands is known as prefix notation, and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention. Prefix notation has several advantages, however. One of them is that it can accommodate procedures that may take an arbitrary number of arguments"
00:24:01 <pnielsen> http://mitpress.mit.edu/sicp/full-text/sicp/book/node6.html
00:24:12 <McChousuke> Cale, I'm pretty sure that if I answered my calculus exames without them my mark would not exceed a 1.
00:24:15 <pnielsen> "D'uh"
00:24:21 <pnielsen> I just knew I remembered something from SICP
00:24:21 <johnw> ah, when you said pn, I read "Polish Notation" :)
00:24:27 <pnielsen> yeah, I was thinking of Polish Notation
00:24:28 <Cale> The thing is, humans are not like simple theorem checking machines.
00:24:29 <pnielsen> It was prefix.
00:24:37 <Cale> We can invent any notation we want at any time
00:24:44 <McChousuke> pnielsen, same thing really.
00:24:46 <Cale> and proceed to use it as it suits us
00:24:48 <pnielsen> similar, at least
00:25:06 * hackagebot ungadtagger 1.0.0 - Abstract GADTs from typelevel tags  http://hackage.haskell.org/package/ungadtagger-1.0.0 (AndriyPolishchuk)
00:25:25 <ion> I for one love Haskell’s syntax. I liked it already before starting to study Haskell at all.
00:25:30 <johnw> also English is generally infix, while so many other languages are postfix
00:25:41 <Cale> If you want to use parens only for grouping and juxtaposition for application, there are very few mathematicians today who will be confused by this choice.
00:25:59 <Nisstyre-laptop> johnw: can you give an example of an infix in English?
00:26:04 <McChousuke> johnw, yeah, I heard that argument before 'languages use infix notation', nope, English does, my nati ve language is SOV
00:26:05 <johnw> Subject Verb Object
00:26:17 <Nisstyre-laptop> johnw: oh I thought you mean for affixes
00:26:24 <Nisstyre-laptop> *meant
00:26:25 <McChousuke> Even though it tends to break part of the verb, like tense markers off, and places them after the subject.
00:26:33 <pnielsen> I'm accustomed to infix. Prefix feels awkward to me, but I'm inclined to agree it's like imperial vs. metric. Redefinitions of infix operator precedence would be a nightmare, but in practice I find it's usually easy to skim in moderate expressions, without mentally adding parens
00:26:53 <Nisstyre-laptop> johnw: Japanese for example has infix affixes, wheras English only has prefixes and suffixes
00:26:54 <McChousuke> So let's make a + b + c be soemthing like a +{ b c } henceon
00:26:56 <johnw> lots of language use infix too, spanish, arabic, I just wonder if it influenced computer languages
00:26:59 <Nisstyre-laptop> in terms of single words
00:27:04 <johnw> Nisstyre-laptop: oh yeah?  cool
00:27:06 <geisthaus> prefix is just way easier to parse for a computer
00:27:21 <Nisstyre-laptop> johnw: yeah, it was in one of my linguistics textbooks
00:27:31 <McChousuke> Nisstyre-laptop, Japanese is absolutely right branching, is it not?
00:27:39 <Nisstyre-laptop> McChousuke: uh, not sure about that
00:27:39 <McChousuke> As far as I know, Japanese has only affixes.
00:27:41 <Cale> Here's the secret about precedence: every ring is a monoid ring.
00:27:42 <johnw> FWIW, I don't not find Lisp hard to write or read at all, and it's entirely prefix
00:27:47 <johnw> don't find
00:28:01 <McChousuke> Well, the one argument was that honorrifics are behind rather than in front as a left branching charactaristic
00:28:03 <astertronistic> johnw the syntax for method calls in object oriented languages like java seem similar
00:28:04 <Nisstyre-laptop> I don't know a whole lot about Japanese :P
00:28:10 <johnw> One Unit Ring to Rule Them All
00:28:13 <McChousuke> But the honorrific is actually the noun, grammatically
00:28:27 <astertronistic> noun.verb(subject1, subject2, ...)
00:28:27 <Nisstyre-laptop> McChousuke: I'm talking about single words
00:28:32 <McChousuke> If you say like Nisstyre-laptop kun, then 'kun' is the noun and Nisstyre-laptop is more like an adjective.
00:28:35 <johnw> And In the Darkness Mappend Them
00:28:39 <nenz> hi
00:28:42 <pnielsen> hi nenz
00:28:48 <nenz> im new here
00:28:58 <johnw> hi!
00:29:05 <Cale> nenz: Welcome! If you have any questions about Haskell, don't hesitate to ask.
00:29:09 <nenz> hey johnw
00:29:09 <McChousuke> Nisstyre-laptop, well anyway, the point is, mathematical textbook notation is awful, and cale is a silly person who needs to get into master league with random
00:29:21 <nenz> what is it bout
00:29:23 <osfameron> with random?
00:29:27 <SLi> Having used all fixities a fair amount, I really think infix is easily the most readable of the three. If you make prefix operators variardic, you need to have a mental stack of operators and count parens to be able to tell *anything* of the structure, which is a mental burden. If you don't make them variardic, you'll avoid parens, but you need a mental stack of values, which is even worse by an order of magnitude. In infix the ...
00:29:33 <SLi> ... repetition of the operator actually helps humans a lot.
00:29:33 <pnielsen> nenz: Haskell is a programming language. www.haskell.org
00:29:59 <Nisstyre-laptop> SLi: as someone who has used an HP RPN calculator for a while, I can tell you it's faster for me than infix calculators
00:30:05 <Nisstyre-laptop> and more convenient
00:30:12 <johnw> Nisstyre-laptop: muchagreed
00:30:16 <Cale> McChousuke: If you're talking specifically about textbooks aimed at freshman non-pure-mathematics students, I'd be more inclined to agree with you.
00:30:17 <johnw> I can't use infix calculators anymore
00:30:20 <copumpkin> edwardk: do you have a zipper over bazaar? :P
00:30:22 <McChousuke> osfameron, sure, and tell your race at the start.
00:30:29 <copumpkin> edwardk: seems rather difficult to zipperify
00:30:32 <pnielsen> Nisstyre-laptop, johnw: I can see why it's much easier to think about the operators after entering the numbers
00:30:33 <McChousuke> Cale, no, I'm talking about the stuff haskell uses, infix notation itself removes clarity.
00:30:37 <nenz> ohk
00:30:48 <Cale> McChousuke: then I just disagree :)
00:31:00 <McChousuke> I mean the amount of arbitrary praecedence rules Haskell has to define to make ti work...
00:31:03 <Nisstyre-laptop> pnielsen: yes, you can just take down all of the information and push it onto the stack
00:31:06 <johnw> pnielsen: if you code in assembly language, you think in suffix notation, not prefix or infix
00:31:07 <nenz> i do mostly in PHP
00:31:07 <osfameron> McChousuke: I don't understand what you're saying.  (Perhaps you should try restating it in PN? ;-)
00:31:08 <Nisstyre-laptop> and swap things as needed
00:31:14 <edwardk> copumpkin: hrmm. i don't, but it should be doable at least where c = d
00:31:14 <Cale> McChousuke: I think there are a lot of occasions in which infix notations are helpful and improve clarity of how things are being composed.
00:31:14 <johnw> "setup registers, apply operation"
00:31:42 <McChousuke> Cale, my hypothesis is that that is solely because people are used to it.
00:31:43 <pnielsen> johnw, Nisstyre-laptop: Yeah, definitely prefer suffix, although infix seems like the "right" one
00:31:59 <SLi> Nisstyre-laptop, yes, I've used it too and find it faster, but IMHO it's not because the postfix operator model would be easier to understand in general.
00:32:01 <Cale> McChousuke: It's largely that.
00:32:07 <ion> RPN is great for an interactive UI (which hopefully renders any entered symbolic equations in standard notation), not so much for printed math notation.
00:32:12 <Cale> McChousuke: (But I disagree the other way is *better*)
00:32:16 <copumpkin> edwardk: really? it seems hard to do on a non-regular data structure like that, unless you invent a new custom structure that can be zipped up into one
00:32:18 <pnielsen> nenz: there are a bunch of guides and introductions to Haskell on the website. We'd be happy to help if you have any questions about the language
00:32:21 <johnw> pnielsen: yeah, a < b is always easier for me to read than (< a b) or (a b <)
00:32:22 <Nisstyre-laptop> SLi: I agree, my RPL programs look like a giant mess of variables and operators
00:32:28 <Nisstyre-laptop> with no parentheses
00:32:39 <Cale> McChousuke: To a fair extent, the way we currently do things is good *simply because* it's how we currently do things.
00:32:41 <nenz> thanx pnielsen
00:32:43 <McChousuke> Cale, 'better' is an abstract term, I do believe that it would save time, errors, and monies.
00:32:52 <nenz> it looks interisting
00:32:53 <johnw> Cale: that is so true about so many things
00:33:25 <McChousuke> Cale, well, it took me about 2 days before S-expressions became clearer to me than stanards maths and every note to myself is written in soemthing that looks like S-expressions
00:33:26 <Nisstyre-laptop> also things like minus and divide are somewhat harder to remember the order of argument at first
00:33:31 <nenz> im trying to split very large merged XML file n PHP can handle it so im luking for alternative
00:33:35 <edwardk> copumpkin: well, remember, i actually go through the bazaar to get the representation i use in Control.Lens.Zipper.
00:33:36 <pnielsen> johnw, Nisstyre-laptop: sorry, prefix seems like the "right" one (PN), and infix is what I'm used to (the "right" one, subjectively)
00:33:39 <nenz> cant
00:33:40 <McChousuke> though it's not suitable for Haskell, it's only suitable for variadic functions
00:33:55 <edwardk> it uses the bazaar to capture the initial list, and then flattens it back out from that as well
00:33:56 <pnielsen> nenz: Haskell can do that pretty easily :)
00:34:05 <Cale> McChousuke: But also, there are a lot of cases in which you want to imagine a pair of things being glued together end-to-end, where the notation which puts that operation in between them is very much more natural.
00:34:06 <edwardk> its kind of cheating, but it works ;)
00:34:08 <McChousuke> ((+ ((+ 1) 2)) 3) becomes extremely convoluted
00:34:12 <osfameron> nenz: to be fair I don't see why PHP couldn't handle it either?
00:34:12 <nenz> i thought so
00:34:19 <Nisstyre-laptop> (6 2 /) isn't extremely obvious for someone imo
00:34:21 <copumpkin> edwardk: yeah, sure, but I mean capturing the structure of the bazaar itself (in the recursive data form)
00:34:28 <edwardk> oh
00:34:35 <edwardk> good luck =P
00:34:37 <copumpkin> the irregularity seems hard to deal with
00:34:39 <McChousuke> Cale, I beg to differ, in frot with (+ 1 2 3 4 5 6 7) is far more natural to me, not to mention shoter
00:34:40 <pnielsen> johnw: I would hate to have to use anything other than infix, but I'm willing to submit that that's just me being difficult
00:34:46 <nenz> i dont know it jus hangs its bout 250mb
00:34:49 <edwardk> thats probably pretty painful, yes
00:34:56 <nenz> n bout 2million such files
00:34:59 <Nisstyre-laptop> pnielsen: you need to spend some time with Forth or on an HP calculator
00:35:05 <McChousuke> I can perhaps see that 1 + 2 + 3 + 4 + 5 + 6 + 7 migt be easier if  you 'think in English', beause it's an English sentence almost
00:35:31 <pnielsen> Nisstyre-laptop: C and TI have ruined me
00:35:34 <osfameron> > sum [1,2,3,4,5,6,7]
00:35:35 <lambdabot>   28
00:35:50 <McChousuke> But English is not my native language, and I find thinking in human language about abstract mathematics in general is error prone, neither Dutch nor English can comfortably express the fine nuances of abstract maths.
00:35:50 <osfameron> Nisstyre-laptop: what's an HP calculator?
00:35:55 <johnw> there are several objective criteria that indicate prefix is better in many ways, but there are compelling aesthetic criteria that ensure infix will always have a place
00:36:09 <Nisstyre-laptop> osfameron: HP are known for making calculators that use Postfix notation
00:36:24 <McChousuke> johnw, I would assert that the only reason they are more aesthetic is because people are used to them.
00:36:34 <Nisstyre-laptop> well, actually you push stuff onto a stack and then use operators on the data
00:36:37 <osfameron> ah
00:36:40 <Cale> McChousuke: You should also be aware that you're arguing at the same time that addition be defined as an operation: union over k >= 0 of A^k -> A
00:36:47 <osfameron> presumably you have to press "Enter" between each number?
00:36:49 <paolino> reverse polish
00:36:55 <Nisstyre-laptop> osfameron: yes, or you can do it all on one line
00:36:55 <Cale> McChousuke: Which is *okay*
00:36:59 <Nisstyre-laptop> at least on the new models
00:37:08 <johnw> McChousuke: that's the thing about aesthetics, they are nearly inarguable
00:37:14 <Cale> McChousuke: But it makes the axioms of a ring or field perhaps a bit weirder to write down the first time.
00:37:15 <johnw> wait long enough, and maybe everyone will agree with you
00:37:38 <McChousuke> johnw, well, you can empirically demontrate what happens if you teach children a different notation from an early age
00:37:43 <SLi> Even the more advanced HP RPN calculators show things in infix, and that's for a very good reason.
00:37:53 <McChousuke> You could actually test this out and see which one kids like more if you teach them both from an early age
00:38:02 <johnw> McChousuke: this is starting to feel like the dvorak vs. qwerty debate
00:38:03 <Cale> McChousuke: If you really want to be a proponent of that notation, you need to do things like write down the ring axioms in it :)
00:38:04 <Nisstyre-laptop> SLi: it's recommended to turn off infix mode
00:38:12 <Nisstyre-laptop> SLi: however the formula writer is infix yes
00:38:23 <McChousuke> johnw, while Dvorak is pseudoscience, qwerty of course isn't well designed either.
00:38:37 <Cale> McChousuke: and note that you need to now define how associativity works for all possible combinations of variadic parameters
00:38:41 <McChousuke> Also, the 'rows' of a keyboard, that they are semi-diagonal isn't helpful
00:39:28 <McChousuke> Assuming they are, as I said, s-exprssions are only useful insofar you're working with mostly variadic functions
00:39:35 <Nisstyre-laptop> McChousuke: colemak seems pretty scientific to me
00:39:37 <Cale> This is possible to do, and indeed, does happen in things like the definition of an operad or looking at the theory of rings as a monadic theory on Set.
00:39:39 <johnw> McChousuke: although this is a bit OT, I've got 25 years of both qwerty and dvorak behind me now.  The difference comes down to this: when coding in bouts of 10+ hours or more continuously, qwerty makes the bone under my left pinky hurt.  There's, that's about all I've noticed.
00:39:40 <McChousuke> they're meant to make variadic functions easier to write, for Haskell it would be extremely unstuitable.
00:40:16 <Nisstyre-laptop> I think we can agree that variadic functions are difficult in Haskell for reasons other than infix notation
00:40:16 <McChousuke> johnw, hmm, it could be, from what I've read there is no real scientific backing for dvorak.
00:40:20 <Cale> McChousuke: But please actually try writing down the ring axioms for variadic addition and multiplication in a non-handwavy way.
00:40:38 <McChousuke> However, I never get any stress from coding on my fingers, because 1: Das Keyboard. 2: Coding involves very little typing (come at me)
00:40:57 <johnw> haha, not the way I code
00:40:59 <pnielsen> McChousuke: +1 for Das Keyboard, weighted positional keys is golden
00:41:08 <pnielsen> that the little-finger keys don't weigh as much is great
00:41:09 <McChousuke> Cale, if + was onsidered variadic from the start 'ring' would be a different concept honestly.
00:41:10 <johnw> I'm like a genetic algorithm
00:41:10 <Nisstyre-laptop> McChousuke: it usually involves me pressing the parentheses keys quite a bit
00:41:13 <McChousuke> notation does shape thought in a way
00:41:27 <Cale> McChousuke: Oh, now this is getting interesting :D
00:41:41 <Cale> What would you replace the entire theory of rings with? :)
00:41:48 <McChousuke> Well, basically, if + was variadic from the start it gave you associativity for free of course
00:41:51 <pnielsen> any programmer worth his salt should have an IBM M or Das Keyboard (ultimate) IMO :)
00:42:07 <McChousuke> Cale, I'm not sure what would come out of it, but I'm pretty sure that it woul be sligtly different if + was cosidered variadic for the last 400 years.
00:42:07 <Cale> McChousuke: Not all variadic functions are associative.
00:42:09 <johnw> i used to use IBM keyboards.  too loud
00:42:17 <Nisstyre-laptop> McChousuke: it is true that you would have an easier time explaining the multiplication and addition operators to children
00:42:20 <rking> pnielsen: Strong recommendation. I still don't get the appeal.
00:42:22 <Nisstyre-laptop> and I've said this before
00:42:24 <pnielsen> johnw: there is a silent version of the Das Keyboard, although silent is very much in quotes
00:42:30 <johnw> ooh
00:42:30 <McChousuke> Cale, indeed, but they aren't extended that way in scheme unless they are.
00:42:37 <pnielsen> johnw: it's more of a thud instead of a pling, really
00:42:50 <pnielsen> johnw: it's less sharp
00:42:51 <Cale> McChousuke: You still have to express somewhere what it means for a variadic function to be associative in the first place.
00:42:52 <Nisstyre-laptop> pnielsen: can't afford a 150 dollar keyboard
00:42:55 <johnw> I may actually get that, thanks
00:43:08 <McChousuke> Nisstyre-laptop, yeah, I don't think S-expressions are the complete answer, they are better than mathematical textbook notation though.
00:43:18 <pnielsen> got the silent at work, macho version at home
00:43:28 <johnw> I use Apple chiclet keyboards, and I rather like them.  What I disliked about my Happy Hacker was too much key resistance, and too much key travel
00:43:38 <pnielsen> it's an investment, but it lasts for many years (5+), and I could never live without it now
00:43:39 <johnw> pnielsen: which do you prefer?
00:43:43 <Nisstyre-laptop> McChousuke: well that's what Sussman thinks, and apparently it has worked for his course on classical mechanics
00:43:50 <Nisstyre-laptop> people get the concepts better with the Scheme notation
00:43:58 <johnw> i usually break keys on my keyboard after a few years; and it's usually the period key (v on dvorak)
00:44:05 <McChousuke> Cale, that's quite easy? You can generalize that (f x y z ...) is always the same as (if (f x y) z ...) and as (if x (f y z ...))
00:44:16 <McChousuke> Nisstyre-laptop, he used it?
00:44:18 <McChousuke> Wow
00:44:20 <Nisstyre-laptop> McChousuke: yes
00:44:20 <McChousuke> REbell with a cause
00:44:22 <McChousuke> I like him
00:44:24 <Nisstyre-laptop> he taught a course at MIT on this
00:44:25 <pnielsen> johnw: people bicker about the silent keys being less responsive, but I haven't really felt it. No preference. If I had coworkers or was forced to listen to it, I would get the silent version (wearing headphones usually otherwise)
00:44:28 <McChousuke> Nisstyre-laptop, got a link to that?
00:44:30 <Cale> McChousuke: The primary reason that S-expressions are bad is that they *require* parens at every level, which means you spend a lot of time figuring out whether parens are balanced and when you find a close paren, which opening paren it matches.
00:44:31 <Nisstyre-laptop> I think he still teaches it
00:44:40 <McChousuke> Excellent
00:44:50 <pnielsen> johnw: the non-silent version is as loud as the IBM M though -- it's still audible through headphones, which I've found is good--it leads to far fewer typos
00:44:53 <Nisstyre-laptop> McChousuke: http://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Classical_Mechanics
00:44:58 <McChousuke> Cale, I seldom match them wrongly actually.
00:45:02 <McChousuke> Oh yeah, that boo
00:45:03 <McChousuke> k
00:45:04 <McChousuke> I know it
00:45:07 <Ralith> Cale: that's trivially false; you haven't ever used s-expressions seriously.
00:45:09 <Nisstyre-laptop> "The book (ISBN 0-262-19455-4) is used at Massachusetts Institute of Technology (MIT) to teach a class in advanced classical mechanics"
00:45:25 <Cale> Ralith: You haven't ever used them seriously on a blackboard.
00:45:41 <Cale> (and yes, I've spent a fair amount of time programming in Scheme and Common Lisp)
00:45:47 <johnw> I was also looking at http://matias.ca/quietpro/pc/
00:45:50 <Ralith> Cale: I rate my programming tools by how convenient they are to program in, not write on a blackboard.
00:45:53 <Ralith> :P
00:45:56 <SLi> McChousuke, johnw, I've also used dvorak for a number of years now and also consider it a bit funny when people call dvorak "pseudoscience" because of a small study that found no significant typing speed differences. I can tell you this: I haven't measured my typing speed with dvorak, but for me qwerty makes my wrists hurt so much more that I'm actually considering moving to a custom layout that seems to promise another major ...
00:45:57 <Nisstyre-laptop> even in the SICP lectures from the 80s they had a scheme interpreter in front of the class that showed if they were balanced
00:45:59 <Cale> Ralith: But that's not what McChousuke is talking about
00:46:01 <McChousuke> Cale, nope, this is actually not true I feel. It took me about 2 days to get very comfortable with S epxesions
00:46:03 <SLi> ... improvement from dvorak according to an ad-hoc heuristic.
00:46:11 <Ralith> McChousuke: were you talking about how easy it is to write sexps on a blackboard?
00:46:13 <Cale> Ralith: He's talking about using S-expressions for all pure mathematics.
00:46:16 <Nisstyre-laptop> also, I've gotten pretty good at counting parens >.>
00:46:17 <Ralith> oh, my apologies
00:46:22 <Ralith> McChousuke: that's a very silly idea.
00:46:28 <johnw> SLi: agreed, I like dvorak for the comfort, not the speed.  I'm equally as fast on both
00:46:36 <pnielsen> johnw: I'm not familiar with that one, but the weighted keys are a big deal for me. It's definitely noticeable now (on my Lenovo rubber membrane laptop)
00:46:48 <McChousuke> Ralith, well, I don't write on blackboards, but notes to myself are almot always in some S-exprsson like thing
00:46:48 <Nisstyre-laptop> obviously there are tradeoffs with whatever notation you choose
00:46:55 <pnielsen> typos left and right, and a slight finger ache
00:46:56 <McChousuke> I find it easier to read back later and I write it more quickly.
00:46:56 <johnw> pnielsen: ah, I need to try this keyboard
00:47:07 <johnw> weighted keys sounds intriguing
00:47:07 <McChousuke> When I'm thinking of mathematical logic, I'm first thinking of the operatio and then of the operants, of course.
00:47:15 <Cale> btw, I also love my Das Ultimate :)
00:47:21 <johnw> lol
00:47:23 <McChousuke> Ultimate for life
00:47:26 <McChousuke> professional is for noobs
00:47:43 <pnielsen> johnw: Expensive, but no regrets whatsoever. Would purchase again, but I won't need to for a long time.
00:47:47 <Nisstyre-laptop> McChousuke: llike (~ (or (~a) (~ b))) ?
00:47:50 <johnw> huh, the soft das keyboard is actually the chaeper one on Amazon
00:47:50 <pnielsen> McChousuke: Agree.
00:48:13 <Cale> You definitely want the blue switches, people.
00:48:16 <johnw> yeah, I haven't been able to look at my keycaps for a long, long time
00:48:21 <McChousuke> Nisstyre-laptop, well, yeah, but I employ a lot of shorthands
00:48:35 <pnielsen> McChousuke, johnw: The best part of ultimate to me (I never look at the keyboard anyway) is when coworkers come over and get the idea of using my keyboard
00:48:36 <johnw> Cale: the loud one?
00:48:39 * pnielsen wide smirk
00:48:42 <Cale> johnw: Yeah :)
00:48:47 <McChousuke> I use a weird symbol in writing which I type as ; for instance a lot (x y z ; a b ; d) is (((x y z) a b) d)
00:48:52 <Cale> johnw: It's not *that* loud though.
00:49:00 <SLi> I don't care about what the key hats say. No, actually strike that. I prefer them to show qwerty. I find it easier for the occasional need to use shortcuts when working in qwerty after getting used to dvorak shortcuts.
00:49:08 <ion> mccousuke: That’s infix. :-(
00:49:14 <Cale> johnw: I suppose it might potentially bother someone if you had no closed door between you.
00:49:18 <pnielsen> johnw, Cale: It's annoying in an office environment, but it wouldn't bother me personally
00:49:26 <pnielsen>  / it doesn't
00:49:46 <johnw> well, my wife is a doctor and is almost always sleeping, so a quiet environment (I work at home) is critical
00:49:49 * Ralith uses a model m and doesn't get why people complain about noise
00:49:51 <pnielsen> john, Cale: silent one is the brown switch, loud is blue IIRC
00:49:58 <johnw> pnielsen: correct
00:49:59 <Nisstyre-laptop> McChousuke: FWIW, I feel like It's much easier to just sit down and start coding in Racket moreso than any other language I've used
00:50:10 <pnielsen> johnw, Cale: which is what I was referring to when I said "bickering". I can't really feel the difference, but perhaps I'm not enough of a keyophile
00:50:22 <Nisstyre-laptop> feels more like composing English sentences
00:50:41 <SLi> I would show you the heuristically generated layouts, the scoring function and the code, but that would be doubly off-topic because I wrote them years ago in C and Pythin :p
00:50:44 <Nisstyre-laptop> despite the utter lack of similarity in syntax
00:51:25 * Ralith still wants a nice statically typed lisp
00:51:35 <Ralith> Haskell syntax is so awkward to transform :/
00:51:42 <Nisstyre-laptop> Ralith: it exists
00:51:46 <Nisstyre-laptop> Ralith: Typed Racket
00:51:54 <pnielsen> johnw, Cale: almost all forum/Internet people agree though: blue is superior
00:52:04 <pnielsen> that's why I bought the loud one to begin with; feedback was pretty unanimous
00:52:13 <Ralith> Nisstyre-laptop: if I wanted something like that I'd use Qi.
00:52:38 <Cale> pnielsen: I think to some extent it's just nice to have that positive bit of feedback from the clickiness of the keys.
00:52:39 <osfameron> the only thing that puts me off the Das is not having a builtin trackpad...
00:52:57 <pnielsen> Cale: yeah, definitely agree about that. I don't think about it, but I've definitely noticed less/no typos
00:53:05 <johnw> das keyboard ultimate quiet ordered, thanks people
00:53:09 <SLi> That's the noisy one? It felt good at a shop. Didn't even realize there's such a large difference in keyboards. Still not convinced it's worth the money :p
00:53:09 <Cale> pnielsen: But also, it may have something to do with the amount of force the key applies to helping you get your finger back up off of it.
00:53:10 <johnw> the loud one is just not an option
00:53:19 <SLi> The blue switches one.
00:53:22 <pnielsen> ^5 johnw
00:53:38 <pnielsen> SLi: it totally is. Remember it'll last for 3-5 years or more
00:53:45 <pnielsen> NO regrets, and I'm pretty greedy
00:53:54 <johnw> well, this keyboard was only 2* (or should I so, *2) what my current keyboard is
00:53:59 <pnielsen> Cale: yeah, the weight/two-stage come into play too
00:53:59 <johnw> but it improves comfort, it's well worht it
00:54:02 <ion> What keyboard doesn’t last more than five years? I have never had one like that.
00:54:03 <Ralith> SLi: well, one of the big things I've noticed is all my friends who don't buy nice keyboards have to replace them regularly.
00:54:04 <johnw> i type most of my waking life
00:54:07 <pnielsen> all I know is I'm sold
00:54:14 <pnielsen> johnw: exactly
00:54:23 <pnielsen> really a no-brainer for programmers IMO
00:54:29 <pnielsen> that's easy to say after you've bought it
00:54:36 <johnw> and not having keycaps to rub off is a plus :)
00:54:54 <johnw> pnielsen: hey, never underestimate the power of cognitive dissonance
00:55:01 <SLi> ion, they tend to degrade graduakky in my experience.
00:55:09 * pnielsen encourages anyone to come write hello world on mine if you come by Stockholm
00:55:22 <SLi> gradually
00:55:23 <pnielsen> ion: almost all rubber membrane keyboards
00:55:55 <pnielsen> ion, SLi: they might last, but the keys become heavier and heavier (and not with a uniform distribution) over time
00:56:03 <pnielsen> you don't notice it until you use a sane keyboard
00:56:17 <johnw> night all
00:59:14 <osfameron> !pl (\f (a,b) -> (f a,f b))
00:59:32 <osfameron> @pl (\f (a,b) -> (f a,f b))
00:59:33 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
00:59:58 <osfameron> hmmm, there is a nicer way to apply a function to both parts of a pair tuple isn't there?
01:00:18 <osfameron> fmap f (a,b) -> (a, f b)    -- I want (f a, f b)
01:00:41 <geisthaus> make a swap tuple function
01:00:44 <Cale> By the way, this is again tangential to the discussion that just happened, but everyone should know about associahedra, which are n-dimensional polytopes whose vertices correspond to the binary trees with (n+2) leaves, and where there is an edge between x and y when a single application of the associative law will take you from one tree to the other.
01:00:54 <geisthaus> \(a,b) -> (b,a)
01:00:56 <geisthaus> and compose off of it
01:01:02 <pnielsen> mapTuple = join (***)
01:01:26 <osfameron> pnielsen: that's what I was thinking of
01:01:32 <pnielsen> or just mapTuple f (a1, a2) = (f a1, f a2)
01:01:35 <pnielsen> no need to go crazy
01:01:45 <osfameron> geisthaus: hah, fmap, swap, fmap, swap... cute
01:02:22 <pnielsen> Cale: yes, some of those words
01:03:07 <geisthaus> my main personall issue with haskell, is its layout rules, I mean they force beauty but feel unnatural to me
01:03:11 <Cale> http://faculty.tnstate.edu/sforcey/tamari_sm.gif
01:03:38 <Cale> geisthaus: The golden rule of layout: align siblings vertically, children start in a deeper column.
01:04:30 <geisthaus> I still get it quite wrong from time to time and it off's my flow/zone
01:04:32 <Cale> That picture isn't very symmetrically drawn, but that thing has two mirror sets of 3 pentagons meeting at a common vertex, and then 3 squares
01:05:44 <osfameron> geisthaus: luckily haskell has { ; } layout too, if you want it
01:06:02 <geisthaus> ive been using them both lately together
01:06:05 <Cale> geisthaus: There's one thing which I'd really love, which would be if any edit which caused the position of the first non-whitespace character following a layout keyword to move would cause the entire layout block to move.
01:06:21 <Cale> (in the same fashion)
01:06:26 <geisthaus> I find it easier to read at a glance
01:06:30 <geisthaus> a layout keyword?
01:06:42 <Cale> let, of, where, do
01:06:57 <Cale> and \case if you have that extension on.
01:07:07 <geisthaus> is that encodeable? your rule?
01:07:13 <Cale> yes
01:07:23 <geisthaus> has it been done yet?
01:07:25 <Cale> no
01:07:29 <Cale> (for some reason)
01:07:44 <geisthaus> ...what editor(s) would you want it for?
01:07:49 <Cale> vim especially
01:07:50 <nand`> yi, clearly :P
01:07:59 <Cale> but it's shameful that yi doesn't do it
01:08:11 <nand`> yi doesn't seem to be in a very usable state at the moment, at least from my experience
01:08:13 <Cale> and of course, if it existed for emacs, I would have a bigger reason to use emacs
01:08:40 <geisthaus> glanced at yi a few years ago, it seemed quite incomphrensible back then
01:08:46 <nand`> though personally I tend to avoid ‘smart’ editors that do things like indenting and layout for me
01:08:51 <pnielsen> Cale: Sublime Text supports that (language-agnostically) (horizontal selection/duplication)
01:09:00 <pnielsen> Cale: hopefully there'll be Haskell support in Light Table sometime
01:09:13 <Cale> I have not heard of either of those things
01:09:19 <pnielsen> they're both quite hipster
01:09:24 <nand`> sublime text is proprietary
01:09:42 <pnielsen> Light Table is the more interesting one, built for Lisp, which shows you the flow of your program while you are developing--it's quite interesting
01:09:45 <pnielsen> it's not finished yet, though
01:09:59 <pnielsen> Sublime Text is just a regular editor with some nice selection features, and addons
01:10:01 <nand`> flow?
01:10:06 <pnielsen> I'll link a video, sec
01:10:26 <geisthaus> sublime is quite (sp)genteel(sp) on the eyes
01:10:42 <pnielsen> nand`, Cale, geisthaus: I think this is the video: http://vimeo.com/40281991
01:10:47 <pnielsen> I can't check since my connection is bad
01:11:38 <osfameron> how's this as a tr/// in haskell?  https://gist.github.com/3806229
01:12:03 <osfameron> faking mixfix by using (,) is rather meh
01:12:55 <pnielsen> nand`, Cale, geisthaus: 01:15 onward
01:13:22 <pnielsen> Very cool IMO. Would be nice for Haskell
01:13:34 <Cale> I have one criticism already, which is that the contrast in this colour scheme needs to be better :)
01:13:42 <pnielsen> yeah
01:14:10 <geisthaus> my other problem with haskell is coneptual, with oo it can easily be taught a general way to break up things into objects, for haskell I haven't really moved much past an old school procedural/even imperative style most of the time
01:14:17 <geisthaus> conceptual even
01:14:47 <Cale> geisthaus: Objects are easy in Haskell :)
01:15:02 <geisthaus> how? ;) and will it tick people off
01:15:03 <pnielsen> geisthaus: a lot of people have the opposite opinion, actually: that there is no natural analogy for OOP
01:15:04 <Cale> geisthaus: You're allowed to have data types which contain functions.
01:15:15 <geisthaus> its the state though
01:15:19 * Ralith finds that effective use of OO is very hard to teach (or do) indeed.
01:15:26 <pnielsen> Ralith: agree
01:15:36 <geisthaus> im mostly on the small atm
01:15:43 <geisthaus> maybe its easier at that level
01:15:51 <Cale> geisthaus: Objects which would otherwise mutate a state can either: a) produce another object of the same type as (part of) their result
01:16:07 <pnielsen> nand`, Cale, geisthaus: 04:00 = awesome
01:16:12 <Cale> Sorry, that should be "methods"
01:16:19 <Cale> or b) have IO actions as their result
01:16:23 <pnielsen> At least it looks awesome.
01:16:39 <geisthaus> is it for the/a sublime framework?
01:16:54 <pnielsen> geisthaus: Light Table is a new IDE, unrelated
01:17:15 <Cale> yeah, it does look like a nice idea
01:17:16 <pnielsen> geisthaus: under development for Lisp and Python
01:17:36 <pnielsen> I'm not sure, but I think he said it was going to be open source
01:17:54 <Cale> Though there's some part of me which is skeptical about this way of approaching things.
01:18:00 <Cale> (Light Table)
01:18:04 <nand`> pnielsen: looks interesting, but does it run in a terminal? :)
01:18:09 <geisthaus> Cale, so what is the best way to plumb together all the oldObject to newObject functions?
01:18:15 <pnielsen> nand`, Cale, geisthaus: ooh: http://app.kodowa.com/playground
01:18:51 <pnielsen> nand`: HTML5 I think :/  time to spring clean links/lynx?
01:19:02 <nand`> ew
01:19:07 <nand`> I'll wait for the terminal frontend
01:19:29 <Cale> geisthaus: Let's say for example, that you are modelling objects which are being animated, as a simple case. There are (at least) two ways we can approach the decomposition of this problem:
01:19:45 <nand`> this whole concept of moving everything presentation-related to the browser is annoying as long as we don't have a *single* good browser
01:19:50 <pnielsen> if Light Table is as awesome as it looks, it might finally be what drags me away from a terminal+emacs
01:20:02 <pnielsen> nand`: that's Chrome
01:20:15 <pnielsen> nand`: Actually, I believe the application is a webkit shell
01:20:18 <Cale> geisthaus: We can have a datatype like  data Object = Ball { centre :: Point, velocity :: Vector, radius :: Double } | Box { ...} | ...
01:20:28 <pnielsen> nand`: so it's really just webkit as a GUI toolkit, not a website
01:20:31 <Cale> geisthaus: with separate cases explaining which data are needed for each case
01:20:42 <Cale> and then we'd have operations on those data:
01:20:44 <nand`> geisthaus: “it can easily be taught a general way to break up things into objects” <- well, in Haskell, you break up things into functions
01:20:54 <Cale> draw :: Object -> Drawing
01:21:03 <pnielsen> to be fair, webkit+HTML5/JS is a pretty reasonable way to make a consistent cross-platform GUI
01:21:07 <Cale> step :: DeltaTime -> Object -> Object
01:21:22 <pnielsen> anyway, gotta go
01:21:29 <geisthaus> so the general concepts don't really change in practice
01:21:32 <Cale> geisthaus: But in a case where we want to be able to extend the system with new objects easily, this is a bad choice
01:21:40 <geisthaus> just the semantics and implemenations
01:22:11 <geisthaus> ??
01:22:28 <Cale> Because everything which ends up depending on the number and variety of constructors in our type will have to be modified when we add a new one
01:22:39 <Cale> But we can also turn this around
01:22:39 <geisthaus> i've ran into that before
01:22:59 <Cale> and choose some set of operations which every Object ought to have
01:23:11 <Cale> (you can call these methods, or messages, if you prefer)
01:23:29 <Cale> and define the object to just be something which can appropriately respond to those messages
01:23:32 <Cale> i.e.
01:23:52 <Cale> data Object = O { draw :: Drawing, step :: DeltaTime -> Object, ... }
01:23:57 <geisthaus> so thats still a best practice/top tier paradigm for a certain subset of problems in hasekll/funPro?
01:24:15 <nand`> Haskell doesn't have implicit subtyping, but there's nothing stopping you from writing the projection functions yourself
01:24:20 <Cale> (note that we've removed a parameter of type Object from the methods, but it's still there, because they are field extractors)
01:24:21 <nand`> Box -> Object, Circle -> Object
01:24:34 <Cale> Now we just need a way to define circle and so on
01:25:00 <Cale> So those become functions for producing objects. What happened to the radius, centre, velocity fields?
01:25:04 <Cale> They become function parameters:
01:25:10 <nand`> one thing to note is that you don't have the inverse either, (ie. casting); but I'm personally of the opinion that casting something to a less general type is a design error
01:25:22 <nand`> so if you have an Object, you should never get a Box from it again
01:25:22 <Cale> circle centre velocity radius = O {..}
01:25:31 <smartviking> Can someone give me an example of using foldr using an infinite list which returns something? I want to write down the execution so I understand why it's possible
01:25:44 <Cale>   where draw = drawCircle centre radius
01:26:04 <geisthaus> > foldr (+) 0 . take 10 $ [1..]
01:26:07 <geisthaus> like that?
01:26:07 <lambdabot>   55
01:26:12 <geisthaus> or you meant something else?
01:26:16 <nand`> > sum [1..10]
01:26:17 <lambdabot>   55
01:26:30 <nand`> oh
01:26:30 <Cale>         step t = circle (centre ^+^ (t *^ velocity)) velocity radius
01:26:34 <nand`> didn't see smartviking's question
01:26:50 <Cale> probably more like
01:26:58 <latermuse> what do you guys consider to be the current biggest deficiency of haskell?
01:27:04 <Cale> > foldr (\x xs -> (2*x) : xs) [] [1..]
01:27:05 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
01:27:09 <nand`> > foldr const 0 [1..]
01:27:10 <lambdabot>   1
01:27:28 <geisthaus> nice one nand
01:27:29 <Cale> latermuse: It's not dependently typed.
01:27:30 <geisthaus> nand++
01:27:33 <geisthaus> :-/
01:27:39 <nand`> Cale's is better :)
01:27:44 <nand`> Cale: haha
01:28:24 <nand`> latermuse: I have a set of gripes with Haskell, but I can't put a strict ordering on them
01:28:26 <smartviking> Great, I'll look at your examples
01:28:51 <nand`> so I can't say what the ‘biggest’ deficiency is
01:28:56 <geisthaus> my gripe is its way too easy for myself to get lost in super algebra land and get zero results
01:29:19 <nand`> my gripe is that GHC isn't smart enough to super-optimize all of my algorithms to run in perfect time
01:29:32 <nand`> but that's not an issue with Haskell :)
01:29:37 <Cale> latermuse: It might seem like an easy fix: there are lots of dependently typed language implementations. But we also want to preserve a lot of the convenience of type inference, and the approach of SPJ and others has been to gradually step toward more expressiveness at the type level without losing the property that type inference is able to infer the types of most "ordinary" things.
01:30:17 <nand`> the newer versions of GHC do seem to be adding more and more to support crazy type-level stuff
01:30:26 <Nisstyre-laptop> nand`: I think there's something called the full employment theorem that prevents that
01:30:36 <Nisstyre-laptop> the super optimization thing
01:30:49 <Cale> The second thing which I could call a deficiency, I would say, is that our module system is not as expressive as that of SML or OCaml.
01:31:01 <nand`> Nisstyre-laptop: yeah. Perhaps not ‘perfect time’, but certainly ‘better than I could have written it’
01:31:02 <Cale> It would frequently be nice to have module-level functions.
01:31:45 <nand`> one ‘necessary’ thing that has the potential to be annoying is instance sharing / phantom instances
01:31:50 <nand`> orphan*
01:31:55 <Cale> (specifically when it comes to all the libraries which presently have somewhere between two and five versions for Strict and Lazy ByteString/Text and plain String
01:31:57 <Cale> )
01:32:40 <Ralith> Cale: the dependently typed langs I've toyed with don't seem to require anything more than what's already good style in haskell as far as type decls
01:33:28 <Cale> Ralith: well... if you're going to require all top-level declarations to have types, say, even that kind of hurts for programming in the small
01:34:40 <Ralith> Cale: does it? Even when programming in the small, I usually find it helpful to work out the type of what I'm writing before writing it.
01:34:44 <Cale> It might be good style to include certain type signatures, but it's really nice if the compiler can still always infer them all as long as we're not specifically using fancy features of the type system.
01:35:41 <Saizan> Ralith: having to write the type of every helper function that pattern matches is quite annoying, also it's easier to abstract away subexpressions with inference
01:35:48 <Cale> I've often had times where it would take me longer to write down the type signature of something, and a lot more thinking, than it would take me to write the definition.
01:36:05 <Cale> So it's nice in cases like that to just be able to define the thing as well.
01:36:22 * Ralith understands the rationale but hasn't had those experiences himself
01:36:40 <Saizan> sometimes you use type inference just to figure out how general your code could be :)
01:37:36 <Ralith> though dependent type inference is generally undecidable, I wonder how far some fuzziness would get you for that kind of case
01:37:42 <Ralith> attack the problem from the other direction
01:39:29 <geisthaus> opinions and opines on http://hpaste.org/75531
01:39:48 <Cale> I'm pretty sure that there has to be some lovely dependently-typed language which will admit all programs which would be well-typed in H-M without any annotations, and which keeps required type signatures to a minimum once you do start using fancier things (ideally you only have to explicitly write the types on the definitions which have non-HM types, and then only elsewhere if there's genuine potential for ambiguity)
01:39:53 <Saizan> i'm not sure what one should do, GHC is showing worrying signs that higher-rank polymorphism doesn't really fit in the HM-inspised inference they are doing
01:40:16 <atriq> geisthaus, if you change the forM to a forM_, you can omit the return ()
01:40:31 <Ralith> Cale: well, there's general potential for ambiguity everywhere, as I understand it--but defaulting to the HM interpretation where one exists sounds sane.
01:40:35 <Saizan> Cale: you're quite an optimist :)
01:40:41 <geisthaus> ty atriq
01:40:46 <Cale> geisthaus: Configure whichever text editor you're using to convert tabs to spaces.
01:40:49 <scshunt> Cale: A nonconstructive proof is not useful
01:40:50 <Ralith> Cale: patch it into idris!
01:41:11 <atriq> geisthaus, also, toFilePath is utterly pointless
01:41:16 <Ralith> geisthaus: hpaste has given you some opinions all on its own already!
01:41:18 <shachaf> Tabs should be a valid character in an identifier.
01:41:25 <augur> does anyone know of anything i can read that discusses the notion of "structure" abstractly?
01:41:32 <Cale> shachaf: LOL
01:41:46 <atriq> geisthaus, you can completely remove it and it won't change the program at all
01:41:52 <geisthaus> augur: something on zippers for starters?
01:41:57 <geisthaus> the return ? yes I know
01:42:07 <Cale> scshunt: hm?
01:42:17 <geisthaus> I like it though as a mental reminder, iirc ghc strips it out pretty much anyways doesnt do anything to begin with etc.
01:42:22 <Cale> scshunt: I don't claim to have proof that such a language exists.
01:42:48 <geisthaus> so it very well be non-computable D:
01:43:42 <Cale> geisthaus: Which editor are you using?
01:44:33 <geisthaus> vim mostly, gedit for pasting
01:44:45 <geisthaus> is 2 space indent sufficient for haskelling?
01:44:46 <augur> geisthaus: the sort of structure im thinking of is the difference between context free languages and regular languages, for instance, or between slightly-richer-than-regular languages which let you make reference to things like "the nth X after this"
01:45:09 <nicoo> Cale: I'm not so sure; even GADTs don't play so nice with H-M
01:45:23 <Cale> geisthaus: basically, just make things line up and nobody will care how many spaces you use. 1 is a bit obnoxious though.
01:45:23 <nicoo> But it would be nice indeed
01:45:25 <geisthaus> augur: that is way (overmyHead (TM))
01:45:37 <augur> fair enough :)
01:45:41 <nicoo> @type overMyHead
01:45:42 <lambdabot> Not in scope: `overMyHead'
01:45:58 <Cale> nicoo: I'm considering the current treatment of GADTs as sufficiently nice
01:45:59 <augur> @hoogle overMyHead
01:45:59 <lambdabot> No results found
01:46:06 <geisthaus> I understand the basics, well not really, but I have alot of other things I need to sort out in my head space before I tackle that honestly
01:46:27 <atriq> @hoogle m [a] -> (a -> m b) -> m [b]
01:46:27 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
01:46:27 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:46:27 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:46:48 <atriq> Okay, that doesn't exist
01:46:51 <nicoo> augur: I don't think adding constant look-ahead to regular languages make them more powerful
01:47:11 <nicoo> atriq: What doesn't ?
01:47:19 <atriq> I had imagined a function
01:48:12 <nand`> :t \m -> (m >>=) . mapM
01:48:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m [a] -> (a -> m b) -> m [b]
01:48:33 <augur> nicoo: probably not. im not sure im concerned with generative power tho, but rather with just the underlying mathematical notion of structure that distinguishes between these sort of "unstructured" relationships that obtain between a thing and another thing some fixed distance away, on the one hand, and "structured" relationships that obtain between two things of unrestricted but distance
01:49:04 <augur> or any other kind of structure that we might imagine existing above and beyond just linear adjacency properties
01:49:13 <hpaste> Cale annotated “multicopy” with “multicopy (annotation)” at http://hpaste.org/75531#a75532
01:49:25 <Cale> geisthaus: ^^ is how I'd lay it out
01:49:40 <Cale> geisthaus: Some people prefer to put the newline after the do
01:49:45 <Cale> (and that's fine too)
01:50:09 * hackagebot hsshellscript 3.3.1 - Haskell for Unix shell scripting tasks  http://hackage.haskell.org/package/hsshellscript-3.3.1 (VolkerWysk)
01:50:14 <nicoo> augur: Well, I just gave you an argument for constant look-ahead (and the construction using FSA is easy enough)
01:50:41 <Cale> geisthaus: if you're using fmap with a complicated lambda, you can always consider moving the work that the function does out into a separate let afterward
01:51:24 <hpaste> nand` annotated “multicopy” with “multicopy (annotation) (annotation)” at http://hpaste.org/75531#a75533
01:51:25 <geisthaus> so it was decent overall? ;D
01:51:27 <nand`> indenting alone, this is how I would do it
01:51:36 <nand`> though the actual code I'd write would probably look nothing like that
01:51:37 <Cale> geisthaus: sure :)
01:52:09 <Cale> yeah, nand` has also fixed up the spacing around that second lambda a bit
01:52:16 <geisthaus> is there a *nix function that does what my proggie does out of the box?
01:52:25 <nand`> just for an example, line 7 I would write as lines <$> readFile sourceFileList
01:52:35 <geisthaus> I messed with some shell looping and depending on the shell it seemed to get some of the filenames completely wrong
01:52:54 <Cale> geisthaus: In cases like that, I tend to use bash as a pipeline target
01:53:01 <nand`> in general, f . g $ x  when x is a single name is much cleaner as f $ g x or even f (g x)
01:53:04 <geisthaus> ?
01:53:05 <Cale> and construct a shell script using sed, etc.
01:53:23 <Cale> because then you can make sure that the code you construct is sane before piping it to bash :)
01:53:46 <geisthaus> all the convolutions just made me want to code it up in haskell
01:53:49 <Cale> yes
01:53:55 <geisthaus> though the toFilePath thing seemed hackish to me
01:53:59 <Cale> Haskell makes a pretty decent shell scripting language
01:54:06 <Cale> toFilePath is entirely unnecessary
01:54:15 <Cale> FilePath is a type synonym for string
01:54:20 <nand`> `combine` = </> -- ?
01:54:21 <Cale> String rather
01:54:25 <geisthaus> I started playing with ksh and friends the other day, seems haskell do syntax is almost modleed on it
01:54:43 <Cale> geisthaus: for example, you should just be able to write...
01:55:11 <geisthaus> it was choking out GHC.IO.String is not String or some other nonsense for a bit
01:55:13 <hpaste> Cale annotated “multicopy” with “multicopy (annotation) (annotation) (annotation)” at http://hpaste.org/75531#a75534
01:55:22 <Cale> ^^ look there
01:55:27 <nand`> if you want I can paste what the program would look like if I had written it entirely
01:55:54 <geisthaus> if you would like
01:56:01 <geisthaus> I will stick mostly to my own thing for now :D
01:56:03 <Cale> geisthaus: It should be a big hint that your toFilePath function has the same implementation as the identity function :)
01:56:13 <Cale> @src id
01:56:14 <lambdabot> id x = x
01:56:18 <geisthaus> but I am somewhat interested in what you would consider a nice solution
01:56:22 <geisthaus> I know that
01:56:29 <geisthaus> I just enjoy being overly verbose at times
01:57:07 <Cale> There would be some advantages to honestly making FilePath and String separate types
01:57:19 <geisthaus> also I despise the monomorphism restriciton in general and I prefer to avoid the mere hint of it
01:57:30 <geisthaus> they almost are
01:57:47 <Cale> geisthaus: well, they're not. FilePath and String will unify
01:57:58 <geisthaus> try killing out toFilePath and striking it from the code
01:58:02 <geisthaus> it might work now
01:58:05 <Cale> geisthaus: You should be able to.
01:58:11 <geisthaus> probably not was getting strange complaints
01:58:15 <Cale> (and that's what my latest paste did)
01:58:19 <geisthaus> heck i'll do it an see if it does
01:59:20 <Cale> If f x = x, then you can replace any occurrence of f x with x and you should have the same result.
01:59:58 <Cale> If that's not true, then what the hell are we even programming in Haskell for? :)
02:00:16 <atriq> Cale, to confuse all the C people
02:00:27 <atriq> Why else?
02:01:05 <geisthaus> wow they did unify
02:01:20 <Cale> geisthaus: FilePath is just a type synonym
02:01:26 <Cale> type FilePath = String
02:01:33 <Cale> it's not a newtype or anything
02:02:03 <Cale> It's intended to help mark which parameters to functions are intended as file paths, without actually making the typechecker do anything to get in your way.
02:02:19 <Cale> But I agree it's sort of confusing.
02:02:53 <Cale> (most type synonyms at least somewhat introduce a bit of potential for confusion)
02:03:45 <Cale> But for example, String = [Char] as well
02:04:55 <Cale> and even though it's not any shorter, there's something nice about that very thin veil of abstraction letting you read "String" and not "List of characters"
02:05:03 <geisthaus> perhaps it was because I was importing things strangely from Prelude for a bit
02:05:31 <Cale> ah, maybe you actually weren't importing the type synonym!
02:05:40 <Cale> Is that actually possible?
02:06:04 <geisthaus> I think so...believe I have done it before
02:06:15 <Cale> yeah, it is possible
02:06:16 <Cale> haha
02:06:58 <atriq> preflex: quote Taneb
02:06:58 <preflex>  no quotes found for Taneb
02:07:03 <Cale> oh, no wait
02:07:13 <Cale> 5.5.3 of the Haskell Report
02:07:37 <Cale> The type of an exported entity is unaffected by non-exported type synonyms.
02:08:01 <Cale> (and they are interchangeable even when the synonym isn't in scope)
02:08:14 <atriq> How mysterious
02:08:44 <Cale> "The only reason to export T is to allow other modules to refer it by name; the type checker finds the definition of T if needed whether or not it is exported."
02:09:24 <Cale> *However*
02:09:41 <Cale> if you explicitly tried to use FilePath in a type signature without importing it
02:09:49 <Cale> then the type synonym would not be in scope
02:11:53 <Cale> It would be kind of interesting to make it so that type synonyms which were not exported from a module wouldn't unify with the original type outside of the module.
02:12:02 <Cale> I wonder if there's some kind of brokenness to that idea.
02:12:49 <Cale> I can imagine it being more convenient than using newtype for abstraction sometimes.
02:14:09 <ClaudiusMaximus> with 7.4.2, Prelude> import Prelude hiding (FilePath)
02:14:10 <ClaudiusMaximus> Prelude> :t readFile
02:14:10 <ClaudiusMaximus> readFile :: GHC.IO.FilePath -> IO String
02:14:43 <ClaudiusMaximus> so imo t leaks obscure details that probably might better be hidden
02:14:48 <ClaudiusMaximus> *it
02:14:59 <hpaste> nand` annotated “multicopy” with “multicopy (my version)” at http://hpaste.org/75531#a75536
02:15:14 <Cale> haha
02:15:15 <nand`> geisthaus: http://hpaste.org/75536 <- this is what I could have written
02:15:20 <Cale> nand`!
02:15:21 <ClaudiusMaximus> or resolved to a type that is in scope
02:15:27 <atriq> Either EclipseFP has gone insane or I've forgotten how to define record-y data things
02:15:56 <Cale> that is a really funny implementation
02:16:00 <nand`> you think?
02:16:01 <atriq> Oh, it's the former
02:16:40 <Cale> nand`: It seems just a little baroque to me to use lenses and traverse here :)
02:16:57 <latermuse> why does it feel that the more I learn about haskell, the less I am confident in my ability to actually use haskell?
02:17:02 <atriq> It's annoying that EclipseFP sucks so much and it's what I'm used to
02:17:05 <nand`> I think it's much cleaner forM loops and whatnot
02:17:06 <atriq> I really need to change IDE
02:17:08 <nand`> than*
02:17:19 <atriq> latermuse, because Haskell is an insanely rich language
02:17:35 <nand`> except it actually isn't
02:17:41 <nand`> there's just a rich amount of libraries :)
02:18:03 <atriq> A language is the sum of its definition and its speakers
02:18:03 <Cale> It's a language which allows insanely rich libraries to be written
02:18:08 <Cale> let's put it that way :)
02:18:11 <atriq> Yeah
02:18:11 <nand`> atriq: fair point
02:18:16 <smartviking> Thanks for the help ddarius, latro`a, shachaf, Cale, nand` and geisthaus, I'm starting to understand why foldr works on infinite lists. But it was incredible hard for me to accept. I guess I'll get used to these problems after a while, I just have to change my mindset, think more effectively. Right know I don't know what to look for so all the information is overwhelming.
02:18:35 <Cale> smartviking: Okay, let's look at the definition:
02:18:38 <Cale> @src foldr
02:18:38 <lambdabot> foldr f z []     = z
02:18:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:18:47 <geisthaus> smartviking: haskell is very very lazy
02:18:55 <geisthaus> that is how it can handle infinite lists, or tree's or what have you
02:18:56 <atriq> It can start f'ing before it's finished foldr'ing
02:18:59 <Cale> In an operational sense, the first thing foldr f z does on a nonempty list
02:19:04 <Cale> is to pass control to f
02:19:11 <nand`> smartviking: the thing you have to understand is that Haskell is (usually) evaluated in terms of lazy graph reduction, an ‘infinite’ value is simply a cyclic link in the graph. There's no ‘sequential computation’ or anything
02:19:13 <Cale> you can see it right there in the definition: f is first
02:19:26 <Cale> So f is passed the parameters x and (foldr f z xs)
02:19:37 <Cale> and only if it actually evaluates foldr f z xs will the fold proceed.
02:19:52 <Cale> Let's contrast this with foldl:
02:19:54 <Cale> @src foldl
02:19:54 <lambdabot> foldl f z []     = z
02:19:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:20:32 <Cale> The foldl f z on a nonempty list just applies *itself* to some parameters
02:21:00 <Cale> until it hits an empty list, and then it produces some, possibly giant, expression which will have accumulated
02:21:27 <Cale> The (f z x) will generally *not* be evaluated before the application of foldl
02:21:48 <nand`> since foldl forces the list constructor (by pattern matching on it), and when it does so immediately recurses into itself doing the exact same thing on the tail, it will never terminate if passed an infinite list, no matter the combination of f and z
02:21:55 <Cale> Lazy evaluation, assuming it is followed to the letter (which in reality is not really what GHC does), is outermost-first
02:22:33 <Cale> right, it'll just keep applying itself to new arguments, the last of which will never be an empty list if the list is infinite.
02:22:48 <Cale> But foldr on the other hand, in some sense terminates immediately.
02:22:54 <Cale> and gives f the option of restarting
02:23:09 <Cale> smartviking: does that make more sense now?
02:23:24 <smartviking> Cale: Yes, much more sense! Thanks for the help
02:23:41 <Cale> smartviking: So it's only if f (or something that f uses) wants to pattern match on the second parameter that it'll cause the rest of the foldr to continue
02:25:25 <Cale> smartviking: In some sense, pattern matching is the fundamental thing which drives all evaluation forward. At some primitive level (after removal of syntax sugar) things are only evaluated because they are the scrutinee of some case expression.
02:25:55 <Cale> (which is trying to discover which constructor of a datatype matches the expression)
02:26:23 <Cale> and the evaluation will proceed up until that constructor is discovered, and then no further unless required
02:26:59 <Cale> (i.e. until the variables in the pattern can be bound to parts of the expression, after a bunch of steps of evaluation)
02:31:06 <geisthaus> nand: im confused by this file ^! act readFile.to lines.traverse.act copy
02:34:32 <nand`> ‘act readFile’ is an IO-effectful Action from FilePath to String; ‘to lines’ is a read-only lens from String to [String], traverse is a traversal from [String] to String, and ‘act copy’ is an IO-effectful Action from FilePath to (); you compose them all in that order to get an IO-effective traversal from FilePath to (); which is then performed via ^! on the input ‘file’
02:34:35 <nand`> not sure if that helps
02:34:47 <nand`> it's stuff from Control.Lens
02:37:47 <smartviking> I guess it's like learning to ride a bicycle, once you can do it you wonder why it was so hard. When our brain has similar problems several times, it will create mental shortcuts, our intuition. It makes us look at the useful stuff and forget about the countless details. I think this will sink in and that I'll be able to think about it easily after some time. When I think about it now, I kinda understand it but it's mindblowing at the same
02:39:49 <zhulikas> why is there such a big interest in lenses?
02:40:56 <zomg> zhulikas: I was wondering the same
02:41:23 <zomg> Are lenses something that was added relatively recently? Since I don't recall seeing talk about them for a very long time yet
02:41:56 <Ralith> "added"?
02:41:59 <Ralith> it's just a library.
02:45:57 <Cale> People have been working on lens libraries for a long time, but only fairly recently was a discovery made of the definition   type Lens a b c d = forall f. Functor f => (c -> f d) -> (a -> f b)
02:46:14 <Cale> and that led to a lot of interesting structure
02:46:57 <zomg> Ralith: well is it a new library I mean
02:47:00 <Cale> and of course, Edward Kmett's lens library is pushing that forward a lot.
02:47:11 <zomg> well, new'ish
02:47:39 <zhulikas> can anyone point me to a resource about lenses which is not connected to haskell?
02:47:48 <Ralith> zomg: well, the release history's on hackage.
02:47:51 <Cale> zhulikas: There's a talk explaining them in Scala
02:47:58 <Cale> Would that do?
02:48:01 <zhulikas> sure
02:48:34 <Cale> tbh, I think it's easier just to understand them in Haskell and then translate :P
02:48:38 <Cale> http://www.youtube.com/watch?v=efv0SQNde5Q
02:49:13 <Cale> zhulikas: The basic idea started out as this:
02:49:13 <zhulikas> thanks
02:49:38 <Cale> data Lens a b = L { view :: a -> b, set :: b -> a -> a }
02:50:24 <Cale> zhulikas: So a lens from a to b consists of both a way to extract a value of type b from a value of type a, and a way to replace that value of type b inside the structure of type a, and get another structure of type a.
02:50:40 <shachaf> type Lens record field = record -> (field, field -> record)
02:51:23 * shachaf wonders if something terrible happens now that he used type variables more than one character long.
02:51:29 <Cale> and in addition, we want the following three laws to be imposed for something to really be considered a lens
02:51:41 <Cale> view l (set l b a) = b -- you get back what you put in
02:52:01 <Cale> set l (view l a) a = a -- putting back what you got is the identity
02:52:14 <Cale> set l c (set l b a) = set l c a -- setting twice is the same as setting once
02:52:18 <shachaf> @quote Cale.it
02:52:18 <lambdabot> ddarius says: Now I can just point people at a readable and relevant paper instead of having to Cale it.
02:53:05 <Cale> zhulikas: Now, this initial definition of lens is nice, and we can define operations to compose lenses together:
02:53:15 <Cale> i.e. we have the identity lens:
02:53:21 <Cale> id :: Lens a a
02:53:32 <Cale> and there is a composition:
02:53:43 <Cale> (.) :: Lens b c -> Lens a b -> Lens a c
02:53:53 <Cale> making these into a Category
02:54:30 <dmwit> > f $ x $ y :: Expr
02:54:31 <lambdabot>   Couldn't match expected type `a -> b'
02:54:32 <lambdabot>         against inferred type `Simple...
02:55:26 <ion> > let ($) = (Prelude.$); infixl 0 $ in f $ x $ y :: Expr
02:55:27 <lambdabot>   f x y
02:55:41 <zhulikas> where is lens especially useful?
02:55:45 <Cale> zhulikas: but there are various things which can be done to generalise this, and make it apply in more cases: for example, we'd really like to be able to define a lens into the first component of a pair which can replace that component with a value of a different type
02:56:23 <Cale> zhulikas: Well, have you ever done "updates" on immutable structures which were nested?
02:56:41 <zhulikas> not really...
02:56:52 <Cale> zhulikas: So let's say you have something like:
02:57:17 <Cale> data Employee = Emp { name :: String, dept :: Department }
02:57:57 <Cale> data Department = Dept { depName :: String, .. I dunno, other junk ... }
02:58:21 <Cale> (this isn't meant to be 100% realistic, I just need some datatypes)
02:58:49 <Cale> Okay, and now let's say we want to update the name of the dept field of an Employee
02:59:02 <Cale> let's reverse it :)
02:59:53 <Cale> revDepartment emp = emp { dept = (dept emp) { depName = reverse (depName (dept emp)) } }
03:00:04 <Cale> you end up with some bunch of junk like that
03:00:35 <Cale> where you have to pick out the structure you want to adjust, and even with the record syntax helping you construct a new value with the same fields as the old apart from the changed one
03:00:37 <Cale> it's awkward
03:01:20 <Cale> Without the record syntax, this is perhaps even worse, because we have to name all the fields then, and make sure they end up in the new structure.
03:01:42 <Cale> So lenses help with this -- they're like composable field names.
03:02:49 <zhulikas> and how such scenario would look like using lens?
03:03:14 <Cale> and if I had appropriate lenses set up, I could write   revDepartment = depName . dept %~ reverse
03:03:46 <Cale> (and there's template haskell magic for making lenses automatically from a data declaration)
03:04:28 <Cale> dept :: Lens Employee Department
03:04:37 <shachaf> "lens" has (.) order reversed. :-)
03:04:44 <Cale> oh, right
03:05:17 <Cale> and yeah, in that library, I'd want
03:05:26 <zhulikas> why did you reverse?
03:05:26 <Cale> Simple Lens Employee Department
03:05:35 <zhulikas> revDepartment
03:05:35 <Cale> zhulikas: It's just a stupid example :)
03:05:38 <zhulikas> ok
03:05:41 <zhulikas> so
03:06:11 <Cale> zhulikas: i.e. I just needed an operation to perform on some subfield of one of the fields of this thing
03:06:11 <zhulikas> let's say we have this
03:06:15 <zhulikas> <Cale> data Employee = Emp { name :: String, dept :: Department }
03:06:15 <zhulikas> <Cale> data Department = Dept { depName :: String, .. I dunno, other junk ... }
03:06:32 <zhulikas> lens for this would be Lens Employee Department
03:06:50 <Cale> Yeah, assuming the simple definition I gave you
03:06:54 <zhulikas> <Cale> zhulikas: So a lens from a to b consists of both a way to extract a value of type b from a value of type a, and a way to replace that value of type b inside the structure of type a, and get another structure of type a.
03:07:10 <Cale> right
03:07:13 <Cale> So we'd have
03:07:15 <zhulikas> wait
03:07:20 <zhulikas> I want to try to explain how I understand
03:07:25 <zhulikas> and you can correct me
03:07:25 <zhulikas> :)
03:07:28 <Cale> okay
03:07:54 <zhulikas> so lens let me do updates on Department and return Employee which contains updated Department?
03:09:36 <zhulikas> ok, type definition suggests that :)
03:09:52 <zhulikas> data Lens a b = L { view :: a -> b, set :: b -> a -> a }
03:10:19 <zhulikas> is there a way to get 'a' from lens?
03:10:28 <Cale> nope!
03:10:32 <shachaf> zhulikas: Think of a lens as a special kind of function.
03:10:38 <Cale> Not without having an 'a' already
03:10:44 <shachaf> (Lens a b) is like (a -> b) with extras.
03:11:29 <zhulikas> (a -> b) is dept emp in above example
03:11:33 <imeredith> how do i make cabal put things it installs on my $PATH ?
03:11:57 <shachaf> What?
03:12:02 <imeredith> nvm
03:12:03 <imeredith> ~/Library/Haskell/bin/
03:12:08 <imeredith> just found the location
03:13:07 <Cale> zhulikas: You want  Lens Employee Department
03:13:43 <Cale> So, say, deptL = L { view = ... , set = ... }
03:15:10 * hackagebot wxdirect 0.13.1.3 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.13.1.3 (KidoTakahiro)
03:15:12 * hackagebot wxcore 0.13.2.3 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.13.2.3 (KidoTakahiro)
03:15:14 * hackagebot wx 0.13.2.3 - wxHaskell  http://hackage.haskell.org/package/wx-0.13.2.3 (KidoTakahiro)
03:15:19 <dcoutts> imeredith: you can also change the location specified in the ~/.cabal/config file
03:16:40 <imeredith> dcoutts: bah, i just installed fay from cabal  - but it was an old version, now my symlinks are pointing to the old version
03:19:36 <imeredith> ah deleted said symlinks and reinstalled
03:19:40 <imeredith> and now its good :)
03:19:48 <mysticc> I have a list which is appended by "0"s.. so something like ["0","0","0","12","12","45","0","56","0","0"] .,. I wanted to remove starting and ending "0"'s I removed starting ones by dropWhile, How to do that for the trailing ones ?
03:20:02 <mysticc> middle "0" should not be removed
03:21:30 <hiptobecubic> mysticc, is the list finite?
03:22:22 <mysticc> hiptobecubic: yes
03:22:27 <imeredith> reverse it and dropWhile ?
03:22:52 <hiptobecubic> >  let clean = dropWhile (== "0") in reverse . clean . reverse . clean $  ["0","0","0","12","12","45","0","56","0","0"]
03:22:55 <lambdabot>   ["12","12","45","0","56"]
03:23:01 <Nimatek> > reverse . dropWhile (=="0") . reverse . dropWhile (=="0") $ ["0","0","0","12","12","45","0","56","0","0"]
03:23:03 <lambdabot>   ["12","12","45","0","56"]
03:29:17 <solirc> The implementation of readFile from "strict" looks broken: http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/src/System-IO-Strict.html#readFile
03:30:29 <Igloo> solirc: In what way?
03:31:36 <solirc> Igloo: Or wait, I guess hGetContents guarantees to close the handle immediately, after all input has been consumed?
03:32:06 <Igloo> Yeah
03:32:07 <dmwit> No, it doesn't guarantee that.
03:32:17 <dmwit> It closes the handle on the next GC.
03:32:23 <solirc> Igloo: ?
03:32:37 <solirc> If it is really like that, then it's broken.
03:32:47 <dmwit> Why?
03:32:49 <solirc> Because it leaks handles.
03:32:53 <dmwit> Yes.
03:33:04 <solirc> And there is really no need to leak handles here.
03:33:06 <dmwit> Though not nearly as bad as the lazy readFile. =)
03:33:14 <solirc> yes, but still
03:33:32 <solirc> if your do a readFile and then a writeFile it may fail
03:34:23 <dmwit> yup
03:34:24 <solirc> I think this would be a correct implementation: http://hpaste.org/75537
03:34:45 <dmwit> No, that wouldn't help.
03:34:50 <solirc> why
03:34:55 <dmwit> Closing a semiclosed handle doesn't do anything.
03:35:04 <solirc> ouch
03:35:11 * hackagebot cmaes 0.2.0 - CMA-ES wrapper in Haskell  http://hackage.haskell.org/package/cmaes-0.2.0 (TakayukiMuranushi)
03:35:12 <mroman> readFile "foo">>=writeFile "foo" will fail badly :)
03:35:38 <dmwit> Doesn't, and can't.
03:38:56 <solirc> dmwit: The documentation of hGetContents says that a semi-closed handle becomes closed on hClose
03:40:06 <dmwit> Huh, so it does. But it also says that once the entire contents are read it's closed anyway.
03:40:12 <dmwit> So perhaps I was wrong through and through.
03:40:25 <dmwit> It really does make the guarantee Igloo said it did.
03:40:47 <solirc> dmwit: oh, you were just guessing?
03:40:54 <solirc> nvm :D
03:40:56 <dmwit> No, but my memory was off.
03:41:00 <dmwit> As it sometimes is.
03:41:24 <solirc> Igloo: thx ;)
03:42:13 <dmwit> (I do try to carefully mark any statements I make that are guesses or speculation. What I said was neither: it was just wrong.)
03:47:23 <Twey> I was under that impression too; was it perhaps the case in an earlier version?
03:48:10 <shachaf> dmwit: Do you really try to carefully mark guesses and speculation? Or is that just a guess/speculation?
03:53:52 <dmwit> Twey: Well, the oldest version of base on Hackage is 3.0.3.1 and it has an identical description to modern hGetContents.
03:55:58 <dmwit> I do find this "This operation may fail with isEOFError" a bit mysterious.
03:57:50 <dmwit> I can't figure out how to trigger it.
04:12:03 <dmwit> "The flagship Haskell application is Zetabot, a 200 line Zeta calculus interpreter that sits in #haskell, much to the entertainment of several hundred dead-ended college students."
04:12:07 <dmwit> 98% accurate
04:13:07 <Cale> lol
04:15:57 <ion> I love the Haskell game box.
04:18:20 <nexx> do you mean this? http://images.wikia.com/uncyclopedia/images/f/fb/Halflife-Haskell.jpg
04:18:45 <ion> yeah
04:24:13 <hpaste> shmoo_ pasted “gloss default viewport controls” at http://hpaste.org/75542
04:26:59 <shmoo_> not sure if anyone here has any gloss specific experience, but this seems like a bug.
04:33:00 <Twey> dmwit: Oh, I guess we were just misinformed.  ☺
04:37:30 <alpounet> dmwit, meh, where's that from?
04:38:36 <alpounet> oh, the uncyclopedia
04:40:33 <absence> i read in the ghc docs about HsStart and HsEnd when producing a dll in windows. the docs don't say anything about loading multiple dlls though. will each HsStart/HsEnd "chain" so everything works out without problems, or will things blow up if dll_1 is unloaded (and HsEnd called) and dll_2's haskell code is called afterwards?
04:42:29 <McChousuke> Twey, sweetie, do you not hate mathematical textbook notation?
04:50:45 <hpaste> trotro pasted “lazy hack” at http://hpaste.org/75543
04:51:02 <trotro> wouah it's magic :)
04:51:47 <trotro> hi guys, in http://hpaste.org/75543 i put a print in function withLight, otherwise my program failed saying a resource is busy
04:52:05 <trotro> i think I know what happen, but is there another way to fix it without a print ?
04:52:56 <Cale> trotro: Write to another file, move that file over the file you're modifying
04:53:26 <trotro> Cale, it's the only solution ? can i force the read of file, and the write after ?
04:53:30 <Cale> Yes, you can
04:53:40 <trotro> how ?
04:53:57 <Cale> length l `seq` writeList nl  will work
04:54:04 <Cale> though that's a bit ugly
04:54:22 <Cale> A more systematic way to do it is to use either Strict ByteString or Strict Text for IO
04:54:37 <Cale> their readFile will make sure the file is completely read before giving you anything
04:55:42 <Cale> But it's generally considered good form for programs not to write directly to files that they are reading
04:56:34 <trotro> I don't write to a file I read, i read i, close it, and reopen it for writing
04:57:20 <Cale> trotro: Right, but that's not what's going on here :)
04:57:29 <Cale> trotro: because readFile is a bit magic
04:57:37 <trotro> I know, I though IO for the sequence of IO operation
04:57:44 <trotro> s/for/force/
04:58:17 <Cale> Yeah, readFile breaks the usual convention that all the I/O which an IO action does happens by the time the next one begins
04:58:43 <Cale> Instead, it hands you a magical String which reads from the file as you observe its characters.
04:59:27 <Cale> This can be handy in some cases, but in cases like the one you have will get in your way.
04:59:42 <trotro> is there function that don't break the usual convetion ?
04:59:46 <Cale> yes
05:00:35 <trotro> thank you ;)
05:00:50 <Cale> That's the ByteString/Text API that I was talking about
05:01:06 <trotro> ha OK
05:01:16 <Cale> Though there really ought to be one for String, I think
05:01:38 <Cale> But it's easy enough to make one for String out of the one for Text
05:01:53 <Cale> (or just use Text directly, since that's a rather nice library)
05:02:46 <trotro> you'rs sepaking of http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t:Text ?
05:11:46 <trotro> Cale, thx for the information i'll have a look to it
05:13:20 <Cale> trotro: yes
07:06:59 <Rc43> Hi, guys.
07:07:15 <Rc43> How to derive Read correctly? I don't know what to do with precedence.
07:07:26 <Rc43> I want just be able to parse single value.
07:07:43 <monochrom> then you can ignore the precedence parameter
07:10:11 <typoclass> Rc43: yes, i think everyone just takes "_" for the precedence argument
07:10:17 * hackagebot OTP 0.0.0.1 - HMAC-Based and Time-Based One-Time Passwords  http://hackage.haskell.org/package/OTP-0.0.0.1 (ArtemLeshchev)
07:10:57 <Rc43> typoclass, how was supposed to use it? Is it overdesign?
07:11:45 <Rc43> typoclass, I just don't understand precedence of what it is; we haven't any operations, erguments, etc.
07:12:03 <monochrom> only when you expect infix grammar and so there is such a thing as operator precedence and parenthesizing
07:12:34 <typoclass> Rc43: not sure, i couldn't figure out the documentation. i _think_ the precedence argument has something to do with "what if the string to parse contains multiple levels of parentheses"
07:12:56 <osa1> when does Foreign.Storable.peek return null pointer ?
07:14:48 <Rc43> Can I look instance for class in GHCi?
07:14:55 <Rc43> I mean implementation.
07:15:25 <igli> is it true that haskell doesn't have macros?
07:16:12 <hiptobecubic> it has template haskell
07:16:26 <monochrom> for example you have "data X = U | Plus X X | Mult X X" and you want the string form to be "U + U * U"
07:16:30 <igli> ah ok
07:17:20 <igli> i take it "template haskell" is an add-on, not a core thing?
07:17:39 <igli> nm i'll google, sry
07:18:00 * hiptobecubic likes igli
07:18:15 <ion> It’s a GHC extension.
07:18:59 <Rc43> monochrom, and argument is precedence of _what_?
07:19:24 <ion> EPARSE
07:20:37 <cark> is there some way to declare a record with GADT notation ?
07:20:40 <rwbarton> the precedence of the surrounding context
07:21:18 <cark> nvm i found it =/
07:21:28 <rwbarton> e.g. if I have read "U * " and now I am trying to read the remainder of the string the precedence for that call will be higher than if I have so far read "U + "
07:21:42 <igli> interesting, thanks for pointer, hiptobecubic
07:22:05 <osa1> does anyone here know why and when does Foreign.Storable.peek return a null pointer ?
07:22:22 <rwbarton> @type Foreign.Storable.peek
07:22:23 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
07:22:27 <rwbarton> what do you mean
07:22:43 <rwbarton> it returns a null pointer when you read a Ptr (Ptr a) that points to a null pointer.....
07:23:01 <monochrom> of the context. consider recursive calls of readsPrec. the caller has seen "U*", and uses a recursive call for the rest. the caller passes 7
07:23:03 <rwbarton> like asking "when is *x a null pointer in C"
07:23:15 <osa1> rwbarton: I'm not reading a null pointer but it returns a pointer 0x0000000000000000
07:23:37 <hiptobecubic> osa1, then your pointer, which is not null itself, points to another pointer which IS null.
07:23:49 <osa1> hmm
07:24:24 <monochrom> actually "U+" is probably a better example
07:25:18 <Rc43> rwbarton, monochrom, understood, thanks
07:32:17 <xrchz> does it make sense to have a different instance for a superclass? how should I structure this...?
07:32:34 <xrchz> I have a datatype with a few variants
07:32:42 <xrchz> they all share some core fields
07:32:49 <xrchz> then the variants have some extra fields
07:32:57 <xrchz> I was doing it as just a single record type with Maybe components
07:33:08 <xrchz> but I want to do it better, so I was thinking I could use type classes
07:33:28 <xrchz> so I have a class Core a where coreField1 :: a -> Foo etc.
07:34:00 <xrchz> then class Core a => Extended a where extraField :: a -> Bar
07:34:33 <monochrom> now you have to write actual instances
07:34:33 <xrchz> now if I want slightly different instances of Show for extended things, but possibly reusing the Show instance for the core part, can I do it?
07:34:49 <xrchz> yes, I will write instances with data
07:35:10 <xrchz> (hopefully there won't be too much name conflicts... probably there will though... if I want to use the class method names for the record field names?)
07:36:18 <monochrom> you will have type A, it's instance of Core but not of Extended
07:36:44 <xrchz> is there a more idiomatic way to describe this situation of a record type with a few variations, where variation basically means extra fields
07:37:38 <monochrom> then you will have type B, it has nothing to do with type A, but somehow its Show instance can magically call A's show method
07:37:40 <xrchz> and variation also means I might want custom instances of other classes (like Show)
07:38:14 <xrchz> monochrom: only if B is an Extended
07:38:24 <xrchz> monochrom: right... is that where you're going?
07:38:59 <xrchz> or maybe I should have one big record type with Maybe fields that is the union of all the variations
07:39:04 <monochrom> I'm saying it is absurd
07:39:05 <xrchz> and carve out the variations with newtypes of that?
07:39:17 <typoclass> xrchz: be aware that haskell's typeclasses are not an equivalent of classes in other languages. i'm not sure you're on the right track
07:39:27 <typoclass> xrchz: how many variants and how many Maybe fields do you have in your record?
07:39:38 <xrchz> typoclass: I'm even less experienced with OO than with FP :P
07:40:10 <xrchz> typoclass: there are 3 variants so far, each with only one extra field, so it's pretty small. I'd just like to do it elegantly.
07:40:27 <monochrom> data All = A { x :: Int } | B { x :: Int, y :: Bool }  is perfectly suitable
07:40:42 <xrchz> monochrom: ahh.... that's a nice trick: reusing the field name
07:41:15 <rwbarton> data All = A { x :: Int, y :: Bool } | B { x :: Int, y :: Char } you can replace by data All t = R { x :: Int, y :: a }
07:41:34 <xrchz> ok I will try monochrom's suggestion now and come back if it starts to feel ugly or doesn't work...
07:41:41 <rwbarton> and use All Bool or All Char or All (Either Bool Char)
07:41:42 <xrchz> rwbarton: what is that t doing?
07:41:47 <rwbarton> um
07:41:50 <xrchz> rwbarton: I guess you mean t = a?
07:41:50 <rwbarton> supposed to be same as 'a', sorry
07:41:51 <monochrom> t=a
07:42:20 <xrchz> yeah that might work too... but the name of y won't make sense in my case, unless I just call it "other" or "extra" which isn't very mnemonic
07:42:51 <rwbarton> then you can create specialized aliases of "extra"
07:42:59 <rwbarton> to All Bool / All Char
07:43:21 <rwbarton> or use a newtype around Bool/Char and compose the record selector of the newtype with extra
07:43:55 <rwbarton> this is more useful if you want to be able to talk about things like [All Bool]
07:44:00 <typoclass> xrchz: right, what monochrom and rwbarton said. if you have (say) 17 fields that all variants share, you could group them neatly in a record with something like "data Base = B { ... 17 fields ... } ; data VariantWithAnExtraString = V1 Base String ; data VariantWithAnExtraBoolAndInt = V2 Base Bool Int"
07:44:24 <xrchz> typoclass: indeed, yes that is looking better
07:46:44 <xrchz> but then it's not all nicely in one record, but I guess I can deal with that...
07:46:58 <xrchz> there's no way to merge two records?
07:49:41 <rwbarton> well what is so special about a record
07:50:02 <rwbarton> like what specifically do you want that "merging two records" would give you
07:50:05 <xrchz> record update syntax
07:50:17 <xrchz> I can emulate field selection with a function obviously
07:50:23 <rwbarton> if you use lenses (recommended anyways) you can compose lenses for that
07:50:33 <xrchz> ... hmm what are lenses?
07:50:40 <rwbarton> yes, just like you compose field selectors
07:51:25 <rwbarton> a concept defined by about a dozen different libraries that abstracts the notion of record field selection/record update
07:52:00 <xrchz> it might not be worthwhile to me yet (to import those libraries and learn their APIs and concepts) - I'll see if the record update syntax is really important to me first
07:52:05 <rwbarton> sounds good
07:52:37 <rwbarton> if you are interested in lenses you can read here http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
07:53:31 <xrchz> can you change the type of a record by updating it?
07:53:46 <rwbarton> with record update syntax yes
07:53:51 <typoclass> xrchz: i think it's quite okay so far. think of it this way: suppose you have one variant with 19 fields (in 1 record as you wanted) and another variant with 21 fields. let's say 17 of them are shared, but you can't see that directly from the api. a user would have to read both data's and conclude that if both records have a field with the same name, it *probably* means the same thing
07:53:55 <xrchz> rwbarton: awesome :)
07:54:07 <rwbarton> with lenses, depends on the lens library I think but often no
07:54:35 <typoclass> that would actually be an advantage for having another Base record, which both variants have. you'd see immediately that each variant contains exactly the same thing
07:54:39 <xrchz> I have this now: Class IsFoo t where underlying :: t -> Foo () ; underlying t = t { extra = () }
07:54:56 <xrchz> which lets me pull out the underlying fields when I want to use instances on them in defining instances on the extended ones
07:55:48 <xrchz> and I'm just using newtype to get my extended guys. newtype Ext1 = Foo Int, newtype Ext2 = Foo Bool, etc.
07:56:32 <xrchz> presumably just doing instance IsFoo Ext1 ( without any clauses ) is enough to get the desired behavior?
07:57:07 <monochrom> (we have grown from 17 fields to 19 fields!)
07:57:22 <monochrom> @quote monochrom 17
07:57:22 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
07:57:57 <zomg> @quote zomg
07:57:57 <lambdabot> No quotes match. I feel much better now.
07:58:00 <zomg> Aww
07:58:59 <typoclass> xrchz: that seems weird to me, though i don't entirely understand it. i don't think you're on the right track with those ()'s in there
07:59:39 <xrchz> typoclass: the () is for the extra field in the case when I don't need an extra field (one of the variants is just the base)
08:00:17 <xrchz> is there a standard class with a ReadP field that I should be using? (before I go and define my own...)
08:00:18 * hackagebot siphash 1.0.2 - siphash: a fast short input PRF  http://hackage.haskell.org/package/siphash-1.0.2 (VincentHanquez)
08:00:48 <xrchz> s/field/method
08:01:01 <Jeanne-Kamikaze> I'm writing a binding for a C function that takes a pointer; haskell puts the pointer at ebp+3 and the C code expects it at ebp+4; am I missing anything ?
08:01:20 <Jeanne-Kamikaze> perhaps some magical ghc flag to control the calling convention ?
08:03:36 <Jeanne-Kamikaze> not sure I used ; in that sentence
08:03:38 <monochrom> I would rather guess the haskell-side foreign declaration is wrong
08:03:52 <Jeanne-Kamikaze> that's what I'm wondering, how can it be wrong ?
08:03:57 <ClaudiusMaximus> Jeanne-Kamikaze: stdcall vs ccall vs something else in foreign declaration?
08:04:08 <monochrom> default is ccall already
08:04:09 <Jeanne-Kamikaze> where can I see my options ?
08:04:13 <typoclass> Jeanne-Kamikaze: 32 vs 64 bits? little vs. big endian? i have no idea
08:05:20 <sixohsix> I have a program that consumes ~25% CPU while idling when compiled, but ~4% when interpreted via ghc. Any idea what might cause that?
08:05:24 <Jeanne-Kamikaze> well I'm interfacing C code, that should be ccall I suppose
08:06:15 <ClaudiusMaximus> sixohsix: use the +RTS option that sounds the bell on major garbage collections, maybe it's idle-gc-crazy or something like that
08:07:26 <Jeanne-Kamikaze> actually, the library I'm interfacing is C++ with no mangling
08:07:47 <merijn> Doesn't C++ have an entirely different calling convention?
08:07:47 <Jeanne-Kamikaze> so it might have as well used cplusplus calling convention, which my ghc doesn't seem to support
08:08:07 <Jeanne-Kamikaze> according to the man page in haskell.org yes
08:08:25 <merijn> Jeanne-Kamikaze: There is no support for C++ calling convention in any haskell compiler I'm aware off. You'd have to write C wrappers for the C++ code and call those
08:08:31 <Philonous> Jeanne-Kamikaze:  AFAIK no haskell compiler implements cplusplus
08:08:33 <monochrom> I actually can't see GHC putting pointers or anything at ebp+3. GHC knows too well about alignment
08:08:41 <Jeanne-Kamikaze> merijn, I'm writing bindings for those C wrappers
08:08:52 <Jeanne-Kamikaze> some of the functions work
08:08:57 <Jeanne-Kamikaze> this one in particular doesn't
08:12:11 <sixohsix> ClaudiusMaximus: oh wow, yes, it's gc-crazy.
08:12:43 <sixohsix> so that's something like a space leak, right?
08:12:47 <ClaudiusMaximus> sixohsix: there should be some +RTS -? documentation on whether you can turn off idle gc or tune it
08:13:11 <ClaudiusMaximus> or use profiling to detect space leaks etc
08:13:25 <sixohsix> tuning shouldn't be necessary for this simple code. i'm certain it's programmer error. i'll try some profiling. thanks!
08:14:56 <merijn> sixohsix: I don't think you belong on the internet. Your first reaction to something going wrong is to assume you screwed up rather than blaming the tools. That doesn't seem right...
08:15:38 <Philonous> merijn:  Did you just call the haskell community "tools"?
08:15:51 <shapr> Or maybe that means we need to permanently induct sixohsix into the Haskell world right away?
08:15:59 <sixohsix> you're right, merijn. i'm going to rewrite this program in node.js so it scales. clearly ghc sucks. (just jokes just jokes)
08:16:15 * shapr laughs
08:16:24 <merijn> Philonous: Yes, everyone knows node.js is the superior approach!
08:19:29 <dolio> Apparently node.js was almost written in Haskell.
08:19:36 <dolio> But the GHC source code was too off putting.
08:20:19 * hackagebot nextstep-plist 0.0.1 - NextStep style plist parser and printer  http://hackage.haskell.org/package/nextstep-plist-0.0.1 (JanChristiansen)
08:22:26 <shapr> dolio: Aw, that's too bad.
08:24:15 <Cale> dolio: lol, what?
08:25:23 <merijn> Cale: I think he might be joking :p
08:25:30 <dolio> Nope, not joking.
08:25:50 <dolio> I don't know if I'll be able to find the reference, though.
08:26:50 <zomg> dolio: it is now your task in life to find it
08:26:56 <zomg> because it would be very interesting
08:26:59 <zomg> =)
08:27:09 <dolio> http://www.reddit.com/r/haskell/comments/zpff3/larry_wall_you_should_probably_know_about_it/c66nrzf
08:27:11 <dolio> Ah hah.
08:30:19 <nils1> hi
08:32:51 <dolio> It's anyone's guess as to why node.js would require hacking directly on GHC>
08:33:21 <xrchz> is there a point-free way to write foo (Bar x) = baz x, especially when Bar has only one constructor?
08:33:36 <xrchz> and/or just a shorter way
08:34:52 <maukd> not really, but you can get an extractor for free with record syntax
08:35:47 <xrchz> hmm yeah but I am already a newtype above a record
08:37:51 <merijn> dolio: Because GHC can't do async IO, duh!
08:37:51 <Eduard_Munteanu> newtype Bar a = Bar { unBar :: a }
08:37:51 <dolio> Oh, of course.
08:37:52 <xrchz> Eduard_Munteanu: thank you, I'll see if I can make that work for me
08:37:52 <LordDrako> hi.. are there any "new" tutorials/guides for gtk2hs? all I find google-ing are samples using deprecated functionality like "onClicked"
08:37:58 <Eduard_Munteanu> xrchz: then   foo = baz . unBar
08:37:58 <xrchz> in my case I have data Foo a = {x::Int,y::a}, then newtype Bar = Bar(Foo Bool)
08:38:08 <xrchz> Eduard_Munteanu: can I use your trick to get x and y extractors for Bars?
08:38:38 <Eduard_Munteanu> xrchz: yeah
08:38:50 <xrchz> similarly with newtype Bar2 = Bar2(Foo Char), can I reuse the same extractor for x?
08:38:58 <Eduard_Munteanu> Not directly, but you already have extracors for x and y from Foo.
08:39:09 <xrchz> so I need to do the unBar somehow
08:39:10 <Eduard_Munteanu> No.
08:39:11 <xrchz> and compose it
08:39:28 <xrchz> newtype Bar = Bar { unbar :: Foo Bool} ?
08:39:35 <Eduard_Munteanu> Yeah.
08:39:40 <xrchz> ok I will try that
08:40:04 <xrchz> pity field names can't be overloaded (or can they?)
08:41:42 <sixohsix> hmm… let's say i'm space-padding a string at the end. is this a horrible space leak? ( take n (str ++ (repeat ' ')) )
08:43:12 <maukd> sixohsix: I don't think so
08:45:53 <nils1> exit
09:40:07 --- topic: '["GHC 7.6.1 http://v.gd/CEBRVo ","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]'
09:40:07 --- topic: set by monochrom on [Fri Sep 14 12:57:21 2012]
09:45:54 <XexonixXexillion> You guys are good at selling Haskell right? I have to implement a restaurant point of sale system. My two choices are either Haskell or (Pharo) Smalltalk. Why should I use Haskell?
09:48:04 <Nimatek> Doesn't matter what trivial software is written in, it'll work either way. So use whatever you like more.
09:48:42 <jmcarthur> you should use haskell because you will be more likely to maintain it (assuming you like haskell)
09:50:27 <XexonixXexillion> I like Smalltalk, Haskell and Ada equally (although Ada is not suited to this); that's the problem. Why does Haskell make me more likely to maintain it?
09:50:54 <monochrom> I am not good at selling haskell. I am good at selling "go with your heart".
09:51:42 <monochrom> but I wonder if there are more haskell programmers than smalltalk programmers
09:52:34 <burbul> What's the command that takes a monad stack and returns the type signature of the corresponding 'run' function, please?
09:52:50 <jmcarthur> for lambdabot? unmtl
09:52:55 <burbul> thanks
09:53:06 <XexonixXexillion> There are a lot more open source Haskell programmers, but I'm fairly sure there are more Smalltalk jobs
09:53:27 <hiptobecubic> I haven't seen very few actual haskell jobs, and no smalltalk jobs.
09:53:30 <jmcarthur> i've never seen a smalltalk job
09:53:32 <hiptobecubic> granted i haven't been looking for the latter
09:53:37 <jmcarthur> nor have i
09:53:37 <tgeeky> double negative?
09:53:42 <tgeeky> not really, but almost
09:53:47 <hiptobecubic> jmcarthur, what does that even mean? the question you answered
09:53:54 <burbul> @unmtl ReaderT a ListT Identity
09:53:55 <lambdabot> Plugin `unmtl' failed with: `ListT Identity' is not applied to enough arguments, giving `/\A. [A]'
09:53:55 <monochrom> then use this restaurant system to create one more haskell job and one fewer smalltalk job :)
09:54:06 <burbul> @unmtl ReaderT a ListT Identity b
09:54:06 <lambdabot> Plugin `unmtl' failed with: `ListT Identity' is not applied to enough arguments, giving `/\A. [A]'
09:54:18 <jmcarthur> @unmtl ReaderT r (StateT s (WriterT o)) a
09:54:19 <lambdabot> Plugin `unmtl' failed with: `WriterT o (a, s)' is not applied to enough arguments.
09:54:19 <monochrom> but anyway I was counting programmers, not jobs
09:54:34 <burbul> @unmtl ReaderT r a
09:54:35 <lambdabot> Plugin `unmtl' failed with: `ReaderT r a' is not applied to enough arguments, giving `/\A. r -> a A'
09:54:41 <jmcarthur> wha
09:54:43 <burbul> @unmtl Reader r a
09:54:44 <lambdabot> r -> a
09:54:45 <jmcarthur> oh duh
09:54:47 <jmcarthur> @unmtl ReaderT r (StateT s (WriterT o)) m a
09:54:48 <lambdabot> Plugin `unmtl' failed with: `WriterT o (m, s)' is not applied to enough arguments.
09:54:49 <maukd> stop failing
09:54:50 <burbul> @unmtl ReaderT r Identity a
09:54:51 <lambdabot> r -> a
09:55:00 <jmcarthur> @unmtl ReaderT r (StateT s (WriterT o)) Identity a
09:55:00 <lambdabot> Plugin `unmtl' failed with: `WriterT o (Identity, s)' is not applied to enough arguments.
09:55:15 <jmcarthur> do i suck this much?
09:55:20 <burbul> @unmtl ListT Identity a
09:55:20 <lambdabot> [a]
09:55:24 <hiptobecubic> this is a pretty cool command so far
09:55:29 <jmcarthur> lol
09:55:48 <burbul> @unmtl ReaderT a (ListT Identity) b
09:55:49 <lambdabot> a -> [b]
09:55:50 <jmcarthur> @unmtl ReaderT r (State s m) a
09:55:51 <lambdabot> Plugin `unmtl' failed with: `s -> (m, s)' is not a type function.
09:55:52 <maukd> spoilers: yes
09:55:58 <jmcarthur> @unmtl ReaderT r (State s) a
09:55:58 <lambdabot> r -> s -> (a, s)
09:56:00 <jmcarthur> yay
09:56:07 <burbul> @unmtl ListT (ReaderT a Identity) b
09:56:07 <lambdabot> a -> [b]
09:56:08 <jmcarthur> @unmtl ReaderT r (StateT s (Writer o)) a
09:56:08 <lambdabot> r -> s -> (a, s, o)
09:56:13 <jmcarthur> that was really awful on my part
09:56:16 <burbul> Yes, that's what's confusing me...
09:56:29 <burbul> ReaderT a (ListT Identity) b and ListT (ReaderT a Identity) b  give the same type signature
09:56:35 <burbul> Both give   a -> [b]
09:56:40 <jmcarthur> ListT is not a nice monad
09:56:43 <burbul> I would have expected one of them to be  [a -> b]
09:56:45 <XexonixXexillion> The advantage of Haskell is that it's easier to verify; and when you're actually dealing with people's money, that's pretty important
09:56:52 <jmcarthur> transformers don't always work that way
09:57:03 <burbul> It just feels very counterintuitive
09:57:08 <burbul> I don't understand why this is happening
09:57:11 <XexonixXexillion> The advantage of SmallTalk is that it is much more portable, and I can write it slightly faster
09:57:22 <maukd> :t runListT
09:57:23 <lambdabot> Not in scope: `runListT'
09:57:25 <jmcarthur> burbul: they don't nest necessarily in the order you write them once expanded. it's just the way it works
09:57:34 <burbul> gah!
09:57:49 <burbul> That sounds painful
09:57:55 <jmcarthur> nah
09:58:00 <burbul> Is there any way to predict how they're going to nest, then?
09:58:18 <jmcarthur> i never came up with anything more intuitive than "whichever way ultimately makes a real monad"
09:58:26 <Polarina> XexonixXexillion, porting an unregistered GHC shouldn't be all that difficult (disclaimer: I haven't ported GHC before).
09:58:38 <burbul> ok -- thanks
09:59:12 <XexonixXexillion> Polarina: I can't run Haskell on an Android tablet, and I doubt I can port it very easily
09:59:15 <jmcarthur> burbul: for example,   Monoid o => (o, IO a)   is not a real monad, but   Monoid o => IO (o, a)   is
09:59:29 <jmcarthur> burbul: so WriterT o IO a must be the latter
10:00:16 <jmcarthur> burbul: ListT "done right" doesn't even reuse []
10:00:24 <burbul> yes, but in that case, there isn't a IO_T
10:00:31 <burbul> So I can't come up with the 'other alternative'
10:00:36 <jmcarthur> burbul: http://www.haskell.org/haskellwiki/ListT_done_right
10:00:38 <burbul> Doesn't reuse []?  , that sounds interesting...
10:00:39 <burbul> thanks
10:01:25 <jmcarthur> burbul: to be more specific, [] could be expressed in terms of ListT, but ListT can't be expressed in terms of []
10:01:33 <burbul> thanks
10:04:26 <XexonixXexillion> Perhaps here's a simpler question. Imagine you're a waiter at a restaurant. You have an android tablet with you. Would you rather be running a Smalltalk program on the device, of vnc-ing to a haskell program running on a computer somewhere else. Would you even care?
10:05:10 <Nimatek> As a waiter I don't know what those words mean. I want to push button and get tips.
10:05:58 <XexonixXexillion> Would you rather a delay in responding to button presses, or a delay in doing things after you've pressed the button?
10:06:09 <maukd> both of course
10:06:11 <maukd> waiters gonna wait
10:06:15 <Nimatek> lol.
10:07:11 <XexonixXexillion> I have a solution! Write both and sell them to different restaurants
10:08:01 <monochrom> I actually don't see why it is vnc-to-elsewhere for the haskell case
10:08:16 <XexonixXexillion> Can you run haskell on android?
10:08:57 <monochrom> I can't, but I am an irrelevant data point
10:09:36 <XexonixXexillion> Well, I'd ask "can one run haskell on android?", but in modern english that sounds pretentious
10:09:59 <jfischoff> I don't know of anyone how has
10:10:12 <jfischoff> but I'm sure it can be done
10:10:29 <jfischoff> with a patch to GHC ;)
10:10:40 <jfischoff> if you are cross compiling
10:10:53 <mcstar> compile ghc with an older ghc that had the C backend, and voila
10:11:17 <XexonixXexillion> also, the current system we sell is just uses vnc to connect to a C# program, so it has proven itself a viable method
10:11:41 <monochrom> how many restaurants make waiters carry tablets?
10:12:07 <Nimatek> How many beers can you carry on an android tablet?
10:12:29 <XexonixXexillion> A few, not many; but we're trying to change that (to the how many restaurants)
10:12:36 <mcstar> wait, you use a tablet to carry bear?
10:12:43 <mcstar> or beer
10:12:54 <XexonixXexillion> Nimatek: You can carry about two pints on a nexus 7, but i'd recommend against it
10:13:11 <Nimatek> mcstar: Being classy.
10:13:30 * maukd cracks open a bear
10:13:35 <edwardk> i've actually been known to move drinks from room to room on my ipad, sad as that is
10:14:01 <edwardk> fortunately, its yet to cause an applecare-voiding incident ;)
10:14:07 <monochrom> I think I did put my tea cup on my closed laptop once
10:14:19 <hiptobecubic> why did the c backend get dropped?
10:14:26 <hiptobecubic> seems like a valuable thing to keep around just-in-case
10:14:47 <mcstar> i think it is generally inferior
10:14:50 <edwardk> hiptobecubic: bitrot is a powerful force =P
10:14:52 <hiptobecubic> for portability, i mean
10:14:59 <hpaste> Jeanne-Kamikaze pasted “gcc argument placement” at http://hpaste.org/75548
10:15:24 * hackagebot ad 3.1.3 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.1.3 (EdwardKmett)
10:15:37 <edwardk> Now with conjugateGradient methods
10:16:05 <edwardk> Next up BFGS, etc.
10:16:06 <hiptobecubic> edwardk, i can't help but notice that you produce lots of code
10:16:21 <edwardk> i've been told that before ;)
10:16:27 <mcstar> he just rewrites solid c++ codebases
10:16:39 <hiptobecubic> good enough
10:16:48 <copumpkin> mcstar: not sure I'd agree with that :P
10:16:51 <edwardk> i only have one lib that is more or less a straight c++ port
10:17:10 <mapreduce> boost::haskell
10:17:51 <cmccann> mapreduce, not sure if that's complicated and confusing enough to be in boost
10:18:38 <edwardk> i don't think i produce that much, its more that i produce a lot of different types of code =P
10:18:55 <cmccann> and upload to hackage frequently
10:19:03 <edwardk> that too
10:19:10 <edwardk> though i've been slowing down lately
10:19:23 * cmccann notes again how many versions there are of a package whose sole purpose is to provide a type with no values
10:19:33 <edwardk> hey!
10:19:37 <cmccann> ;]
10:19:42 <ion> edwardk: Cool, i might find conjugateGradientDescent useful at some point.
10:19:58 <cmccann> and yes I know there were perfectly good reasons for that, it's just funny
10:20:38 <edwardk> ion: Takayuki Muranushi wrote the initial version of it. I just cleaned it up and made it idiomatic AD code
10:21:21 <copumpkin> edwardk: next we need AD-friendly interpolation code to take discrete sampled data and produce derivatives of it :)
10:21:48 <edwardk> copumpkin: the irony is i really do need that for my colorimetry package
10:21:55 <copumpkin> there you go!
10:22:03 <maukd> Jeanne-Kamikaze: can you paste SFML/System/Clock.cpp ?
10:22:08 <copumpkin> I can definitely see many uses for that :)
10:22:21 <Jeanne-Kamikaze> maukd, https://github.com/jeannekamikaze/SFML
10:22:25 <Jeanne-Kamikaze> oh
10:22:26 <Jeanne-Kamikaze> cpp
10:22:54 <hpaste> Jeanne-Kamikaze pasted “Clock.cpp” at http://hpaste.org/75549
10:23:14 <copumpkin> edwardk: how does colorimetry use it?
10:23:23 <XexonixXexillion> From what I can tell there are more people working jobs in smalltalk. There are far more new haskell jobs than smalltalk jobs
10:23:42 <XexonixXexillion> So if I want job security, I should write my code in smalltalk (that's how one should decide things, right?)
10:23:53 <Jeanne-Kamikaze> maukd, for some reason this is the only function that is not working; all of the others work fine
10:23:53 <copumpkin> lol
10:23:57 <copumpkin> XexonixXexillion: you got it
10:24:21 <edwardk> copumpkin: i have the stimulus, cone response, photopic and scoptopic response curves for each wavelength, and i need derivatives with regards to wavelength if i want to do hamiltonian raytracing with wavelength based refraction, etc.
10:24:25 <XexonixXexillion> By that logic I should write it in Agda
10:24:31 <copumpkin> edwardk: aha!
10:24:53 <copumpkin> edwardk: have you published any "sampling" packages in haskell yet, btw?
10:25:08 <edwardk> so basically i need to spline interpolate and give access to AD
10:25:12 <edwardk> ot yet
10:25:14 <edwardk> er not yet
10:25:20 <copumpkin> ah
10:25:25 <edwardk> i was waiting to see if i was actually selling this stuff
10:25:55 <maukd> Jeanne-Kamikaze: huh. I don't understand why it's reading from 12(%ebp)
10:25:55 <edwardk> i have some gists for different api sketches for it, but no hackage package
10:25:58 * copumpkin has been surreptitiously sabotaging your efforts, for the benefit of the community
10:26:01 <Jeanne-Kamikaze> me neither
10:26:08 <edwardk> that explains everything
10:26:24 <edwardk> in retaliation i've been sitting on your neighbors roof starting a chain saw over and over
10:26:31 <copumpkin> fuck
10:26:31 <maukd> Jeanne-Kamikaze: can you 'disasm sfClock_getElapsedTime' and post the results?
10:26:35 <Jeanne-Kamikaze> maukd, it's been known to work on 64-bit arch linux
10:26:36 <Jeanne-Kamikaze> yes
10:26:37 <maukd> er, 'disassemble'
10:26:41 <edwardk> joshcough and i have been taking turns
10:26:45 <copumpkin> I knew it
10:27:06 <copumpkin> oh well, that'll teach me :(
10:27:34 <edwardk> we figure the best revenge is economic revenge, so we'll just keep this up until you fail your CFA exam
10:27:48 <hpaste> Jeanne-Kamikaze pasted “sfClock_getElapsedTime” at http://hpaste.org/75551
10:27:52 <edwardk> or go mad from lack of sleep
10:28:39 <copumpkin> edwardk: lol, good plan
10:28:59 <Jeanne-Kamikaze> maukd, if I make C code that uses the library it works fine
10:29:17 <edwardk> alas, i need to balance this desire with the desire for a working version of rounded, so I don't want you to go mad too quickly
10:29:59 <Jeanne-Kamikaze> maukd, I noticed it pushes ebx, which is why it then reads from ebp+12 instead of ebp+8
10:30:11 <monochrom> @where oleg
10:30:12 <lambdabot> http://okmij.org/ftp/
10:30:18 * copumpkin grins
10:30:28 <Jeanne-Kamikaze> ok nevermind, that's after it sets ebp
10:30:40 <Jeanne-Kamikaze> so yeah, something's weird in there
10:31:31 <blkt> good evening everyone
10:32:00 <monochrom> hi
10:32:42 <blkt> :D
10:33:00 <maukd> Jeanne-Kamikaze: what is sfTime?
10:33:10 * Polarina wonders how this channel turned into #assembly.
10:33:23 <Jeanne-Kamikaze> typedef struct { int64 val; } sfTime;
10:33:40 <maukd> ah, there we go
10:33:51 <maukd> it's a struct
10:33:58 <Jeanne-Kamikaze> code here: https://github.com/LaurentGomila/CSFML
10:34:07 <maukd> that means your 'foreign import' declaration is invalid
10:34:15 <Jeanne-Kamikaze> why ? it's just a 64-bit int
10:34:19 <maukd> no, it's a struct
10:34:24 <Jeanne-Kamikaze> oh ?
10:34:30 <maukd> yes
10:34:38 <maukd> that is why there is a 'struct' in its definition
10:34:42 * applicative wonders if anyone has figured out the new oleg/simonpj/et al. paper
10:34:49 <Jeanne-Kamikaze> yes, but it's a int64 in memory
10:34:52 <maukd> no
10:34:54 <Jeanne-Kamikaze> or am I missing something ?
10:35:12 <geekosaur> in C it might be.  in C++ it probably isn't
10:35:14 <maukd> structs are returned by passing a pointer as a hidden parameter
10:35:36 <geekosaur> hm, there is that, yes.
10:35:44 <Jeanne-Kamikaze> ohhh
10:35:58 <Jeanne-Kamikaze> let me throw myself out of the window
10:36:02 <maukd> 0(%ebp) is the previous %ebp; 4(%ebp) is the return address; 8(%ebp) is the output parameter telling it where to store the result; 12(%ebp) is the actual argument
10:36:37 <maukd> you can see where it copies 0x8(%ebp) into %ecx, then %ecx into (%esp), passing it on to sfMicroseconds
10:36:45 <Jeanne-Kamikaze> ok so I'll make a helper function that takes a sfTime*
10:36:48 <maukd> (because sfMicroseconds has the same call signature)
10:37:36 * applicative sees Polarina's point in calling this #assembly
10:37:52 <Jeanne-Kamikaze> damn, I would have never figured that out myself man
10:37:56 <Jeanne-Kamikaze> thanks a lot
10:39:20 <robstewartuk> hm hackage tries to build packages with ghc 7.6, which means me libraries don't get compiled due to some deps not being ghc 7.6 ready. If I set `build-tools' to ghc < 7.6, will that force hackage to use ghc 7.4 (which my libraries do compile with) ?
10:39:39 <aristid> maukd: who uses 32-bit these days? :P
10:40:02 <aristid> robstewartuk: interesting question. try it out and tell us:)
10:40:27 <monochrom> I use 32-bit these days
10:40:43 <aristid> monochrom: why?
10:40:50 <Jeanne-Kamikaze> right, that's why it was working on 64-bit
10:41:00 <Jeanne-Kamikaze> maukd, I suppose on 64-bit it returns sfTime in rax ?
10:41:09 <maukd> Jeanne-Kamikaze: I don't know anything about 64-bit
10:41:12 <maukd> aristid: me
10:41:26 <aristid> Jeanne-Kamikaze: x86-64 uses registers for most parameters and return values, yes
10:41:30 <Jeanne-Kamikaze> rax is the 64-bit version of eax, so sfTime fits in a register
10:41:45 <Jeanne-Kamikaze> cool
10:41:50 <Jeanne-Kamikaze> how stupid of me
10:42:10 <Jeanne-Kamikaze> assembly forgets me
10:42:21 <maukd> well, that was fun
10:42:54 <maukd> at first I thought there might have been a hidden 'this' parameter, but the call to sfMicrotime convinced me it was a struct output pointer
10:43:30 <aristid> Jeanne-Kamikaze: i think the standard x86-64 ABI is a big improvement over the standard x86 ABI
10:43:42 <burbul> I should know the answer to this... but what's the difference being control.monad.reader and control.monad.trans.reader ?
10:43:51 <Jeanne-Kamikaze> how so ?
10:44:31 <burbul> Both of them seem to define ReaderT
10:44:38 <burbul> Is one outdated?
10:44:52 <aristid> Jeanne-Kamikaze: well, mostly due to passing arguments in registers instead of the stack:)
10:45:00 <monochrom> Control.Monad.Reader adds the type class MonadReader
10:45:12 <Guest95169> Hi! How can I make quickCheck use a certain range of numbers for testing a property? I've been using the "==>" operator to filter for in-range numbers but it always ends with something like "Gave up! Passed only 9 tests.".. So i'm looking in to creating extra generators but is that really the way to go? Any ideas would be very apreciated! :)
10:45:18 <burbul> thanks
10:45:31 <applicative> burbul: they export it.  Control.Monad.Reader is in mtl no?
10:45:43 <aristid> monochrom: did this split exist in the mtl 1 days?
10:45:53 <monochrom> no
10:45:59 <applicative> mtl adds the classes like MonadWriter and so on, for example
10:47:10 <aristid> isn't the split mostly due to monads-fd vs monads-tf?
10:47:27 <aristid> (before monads-fd became mtl 2)
10:47:37 <burbul> Is there a simple rule governing which one I should import in any given situation?
10:47:51 <jmcarthur> Guest95169: there are many ways. the first that comes to mind is that if they are integers you could just `mod` them into the appropriate range
10:47:52 <Sculptor> dexter - soon
10:48:15 * applicative remembers this struggle when he was first learning haskell
10:49:23 <applicative> burbul: some people oppose mtl.  if you just want the transformers themselves like StateT and lift and so on, you dont need MonadReader and thus not mtl
10:49:30 <mcstar> Sculptor: i can hardly wait!!
10:49:57 <burbul> Is it safe to mix some monads from mtl and some from transformers?
10:49:59 <Guest95169> jmcarthur: Ah, of course! Thanks.
10:50:20 <lpvb> my network-2.3.1.0 keeps breaking all my cabal installs
10:50:33 <lpvb> don't really know what to do
10:50:42 <aristid> burbul: mtl 2 uses the transformers monads. so yes
10:50:52 <burbul> thanks
10:51:09 <applicative> burbul: like aristid says, the types are the same
10:51:30 <hpaste> lpvb pasted “Cabal Install Error” at http://hpaste.org/75553
10:51:39 <aristid> applicative: why do people oppose mtl?
10:51:41 <applicative> mtl imports transformers, ie the Control.Monad.Trans... modules
10:52:27 <applicative> aristid: typical type class nightmares, I think.  I never have a sufficiently complicated use to have trouble.
10:53:11 <aristid> applicative: ok me neither
10:53:12 <dcoutts> lpvb: can you select another version, e.g. --constraint='network >= x.y'
10:53:28 * applicative dimly remembers a typically lucid formulation by tekmo
10:53:40 <lpvb> I get that when I try to install cabal-dev
10:53:42 <Sculptor> mcstar, ditto. hopefully ep1 won't be season 6 highlights
10:53:47 <lpvb> cabal install cabal-dev
10:54:30 <mcstar> Sculptor: i hope not, and i refrained from reading the spoliers
10:54:44 <dcoutts> lpvb: try using the version of network you've already got, --constraint='network== ...'
10:56:24 <applicative> aristid, all the .Class modules say: "All of these instances need UndecidableInstances, because they do not satisfy the coverage condition."
10:57:06 <lpvb> dcoutts: thanks
10:58:31 <trebla> !list
10:58:31 <monochrom> http://okmij.org/ftp
10:58:45 <monochrom> \∩/
10:59:26 <merijn> FFI question time: Can a forkIO task executing an FFI call be migrated to another OS thread mid call?
10:59:34 <aristid> applicative: hmm
11:00:06 <monochrom> not sure what "mid call" means, i.e., mid haskell execution? mid C execution?
11:00:14 <merijn> monochrom: mid C execution
11:00:27 <monochrom> then no
11:00:30 <bos> merijn: no, of course not
11:00:42 <Jeanne-Kamikaze> working flawlessly now, thanks for the help \o/
11:00:42 <monochrom> this is a property of C execution
11:01:18 <merijn> Related question: I guess it's safe to assume that moving a forkIO task from one OS thread to another involves a full memory barrier?
11:02:38 <applicative>  aristid WriterT o  (StateT s' m) a is a 'MonadState' ; its clear enough what 'get' does;  but so is StateT s (WriterT o (StateT s' m) a ...
11:03:04 <aristid> applicative: yes, i believe only the outermost StateT is accessible this way?
11:03:14 <aristid> applicative: or is that an error?
11:06:10 <applicative> yes I think that's right, it just suggests how opaque it all is.
11:07:41 <trebla> one final test:
11:07:44 <trebla> !list
11:07:44 <monochrom> http://okmij.org/ftp
11:08:59 <monochrom> hrm, interesting, efnet #haskell has been revived by another group of people!
11:09:16 <djahandarie> lol
11:09:25 <djahandarie> Why wouldn't they just come here?
11:12:10 <pnielsen> having set operators is probably too radical
11:23:04 <applicative> aristid: ah here is what I remembered it was reddit nonsense of course http://www.reddit.com/r/haskell/comments/sarkz/four_tips_for_new_haskell_programmers/c4cltmy
11:24:40 <aristid> applicative: the "there must be laws" school of thought, hah
11:25:13 <applicative> well, thats maybe a little tiresome here.  somehow i know the laws for get and put.
11:26:15 <aristid> applicative: isn't the general idea that "an instance of MonadState is either StateT (or something very very similar) or a transformer on something that is MonadState, in which case all the functions must do nothing but lift"?
11:26:17 <applicative> they are the same as the laws that make it responsible to call the defined terms in Control.Monad.Trans.StateT by those names.
11:26:53 <aristid> the relation between StateT and RWST is also pretty well-defined i'd think
11:49:59 <Ralith> what's the ABI defined when you declare something returning Bool in the FFI?
11:51:03 <monochrom> the C side is HsBool, which is one of the number types
11:51:50 <monochrom> in fact, int
11:52:23 <monochrom> Haskell 2010 Section 8.7
11:57:52 <lpvb> is there a permissive software license that doesn't require a copyright notice?
11:58:17 <opqdonut> copyright licenses are not required as such
11:58:25 <opqdonut> in most jurisdictions
11:58:49 <certainty> put it into public domain :)
11:59:25 <mapreduce> Many do not have the right to put their own work into the public domain.
11:59:27 <opqdonut> gah
11:59:34 <opqdonut> I meant _copyright notices_
11:59:38 <opqdonut> obviously :)
12:00:16 <Ralith> monochrom: thanks, poking around
12:00:35 <lpvb> the MIT and BSD licenses require to put a copyright notice at the top
12:00:38 <lpvb> I don't want one
12:00:47 <opqdonut> well just don't
12:00:59 <lpvb> maybe something like "All copyright rights waived, no rights reserved. WARRANTY DISCLAIMER"?
12:01:27 <lpvb> If I don't, the license doesn't make sense
12:01:42 <Polarina> lpvb, I'd recommend you consult a lawyer rathen than asking in here for legal advices.
12:01:47 <merijn> lpvb: at the top of what?
12:01:49 <Polarina> rather*
12:02:08 <monochrom> I agree about asking a lawyer for real
12:02:19 <lpvb> bah
12:02:32 * merijn disagrees about the lawyer thing
12:02:43 <t7> copyright licenses are a joke anyway
12:02:50 <opqdonut> btw. waiving rights seems to be hard, see http://en.wikipedia.org/wiki/CC0#Public_domain_tools
12:02:55 <zomg> America, the land of lawyers
12:03:01 <t7> has anyone ever been sued ? only to release the source i think
12:03:10 <merijn> lpvb: I don't really see the problem with MIT/BSD?
12:03:23 <ParahSailin_> go to ##copyfree
12:03:34 <zomg> or #piratebay !
12:03:36 <merijn> t7: If it's your code to begin with they can't really sue you for unclear licensing
12:03:46 <merijn> t7: THat's for your user's lawyers to worry about
12:04:10 <int-e> lpvb: I don't think you have to include a copyright notice in every file. But if you do, you'll help the people who want to use your software, because it makes clearer who the author of a file is and what license it is governed by.
12:04:44 <opqdonut> https://en.wikipedia.org/wiki/Copyright_notice is pretty informative
12:04:46 <int-e> lpvb: if they're unsure they have to assume that they have no right to use the code.
12:04:47 <certainty> unlicense.org :)
12:04:56 <pnielsen> "Copyright (c) 2012 The <Foo> Authors. See AUTHORS", then listing the copyright holders in AUTHORS, is fine
12:05:23 <pnielsen> it should be fine even without the notice if the judge is sane
12:06:26 <pnielsen> lpvb: you can just omit the "must reproduce this notice" portion of either license
12:06:39 <merijn> pnielsen: Judge sanity doesn't really matter. How would he get dragged into court over missing/unclear copyright attribution?
12:06:42 <Philonous> lpvb:  Not all jurisdictions even allow you to waive copyright. (It's not allowed in Germany, for example)
12:06:46 <pnielsen> lpvb: there is no reason you have to include the license verbatim
12:06:46 <lpvb> I really just want to define the pemissive permissions in which the code can be used without expressing who the copyright belongs to
12:07:36 <lpvb> pnielsen: maybe that would work, but I was thinking about including a link to the license instead of putting a huge thing on the top of every file
12:07:47 <pnielsen> merijn: http://en.wikipedia.org/wiki/Contributor_License_Agreement
12:08:01 <pnielsen> lpvb: it's fine if you just refer to it
12:08:43 <pnielsen> most corporations with a legal team can't use software that doesn't have a proper CLA/lists all the copyright holders
12:08:57 <pnielsen> IANAL, though
12:09:16 <merijn> lpvb: Use WTFPL?
12:09:33 <merijn> lpvb: THe "Do What The Fuck You Want To Public License"
12:09:33 <pnielsen> examples of CLAs: http://code.google.com/legal/individual-cla-v1.0.html / http://code.google.com/legal/corporate-cla-v1.0.html
12:10:10 <pnielsen> merijn: WTFPL is silly, and it has no warranty disclaimer
12:10:33 <pnielsen> (the license is fine, the name is silly IMO)
12:10:44 <pnielsen> warranty disclaimers are important, especially if your software is going to be used by Americans :)
12:10:52 <merijn> pnielsen: What
12:11:03 <merijn> pnielsen: It says "no warranty whatsoever" on the first line
12:11:37 <pnielsen> merijn: http://sam.zoy.org/wtfpl/COPYING
12:11:44 <typoclass> pnielsen: has anyone ever been sued for not putting in the incantations? ("warranty disclaimers"). have they been sued and then lost?
12:11:49 <merijn> pnielsen: No, only if your software is going to be used by Americans *and* you have a business pressence in the US
12:12:09 <merijn> If you don't have a US business they can't sue you anyway
12:12:09 <pnielsen> typoclass: don't know. But it happens in every other discipline
12:12:32 <typoclass> what i'm saying is, it sounds like FUD to me
12:12:36 <merijn> And then you get to post their legal threats to the web like the piratebay does
12:13:56 <pnielsen> merijn: sure, but even if you do business in the U.S., which almost all companies that use any cloud provider do, your assets can be seized
12:14:09 <pnielsen> typoclass: every large company disagrees with you
12:14:14 <pnielsen> again, IANAL, but I trust they have a good reason
12:15:01 <Caravaggio> Test
12:15:07 <certainty> passed
12:15:17 <int-e> how generous
12:15:19 <pnielsen> merijn: "used by Americans" was just a joke anyway, since Americans are extremely litiguous
12:16:11 <pnielsen> (sorry to any Americans here who aren't :))
12:16:15 <merijn> pnielsen: I'll just include a clause that disallows Americans from using my software then. If they try to sue me I get to sue them for breaking the license :)
12:16:23 <pnielsen> merijn: good idea
12:16:25 <latro`a> lol
12:16:31 <latro`a> surely that won't *itself* get you sued
12:16:31 <lpvb> seems like CC0 is FSF acceptable
12:16:34 <lpvb> I'll use that
12:17:00 <lpvb> thanks @ opqdonut
12:17:05 <merijn> pnielsen: Also, that seems fairly dubious
12:17:27 <Caravaggio> How do I use this infamous lamdabot thing?
12:17:31 <pnielsen> Caravaggio: >
12:17:35 <merijn> pnielsen: If you're only asset is software they can't really seize them
12:17:37 <merijn> > 2+2
12:17:38 <lambdabot>   4
12:17:43 <mapreduce> merijn: money
12:18:15 <mapreduce> You'll probably have some money at least temporarily in the US if you're doing business with Americans.
12:18:18 <pnielsen> merijn: e.g. the hardware/service it runs on
12:18:21 <merijn> mapreduce: No, because why would a non-US company have their money in the US?
12:18:24 <pnielsen> merijn: if you're just distributing software you're probably fine
12:19:49 <Caravaggio> insertSglton :: String -> KEY -> TPSQ -> TMap -> IO ()
12:20:17 <Caravaggio> > insertSglton :: String -> KEY -> TPSQ -> TMap -> IO ()
12:20:18 <lambdabot>   Not in scope: type constructor or class `KEY'Not in scope: type constructor...
12:20:19 <pnielsen> merijn: I kind of jumped to services
12:21:02 <Caravaggio> > type KEY = (IPv4, Integer)
12:21:02 <lambdabot>   <no location info>: parse error on input `type'
12:21:08 <mapreduce> Caravaggio: > is for running stuff.
12:21:14 <mapreduce> no definitions (afaik)
12:21:31 <Caravaggio> the stuff I cash run seems to be more limited than I expected :D
12:21:37 <typoclass> Caravaggio: lambdabot is also available in private chat windows. also, folks could help you if you told us what you're trying to do
12:22:49 <Caravaggio> I try to find out what this can do and what not. Some people say it is so great but I have the impression that it is fairly limited.
12:24:47 <typoclass> Caravaggio: lambdabot's ">" is mostly for trying out one-liners. for longer code use runhaskell, or ":l" in ghci, or codepad lets you execute things online (i believe)
12:25:37 <Caravaggio> Have u ever heard about Safe Haskell?
12:25:42 <merijn> Hmm, if I have code expecting "a -> IO b" am I screwd if I have "MonadIO m => a -> m b"?
12:25:50 <Caravaggio> Apparently that was taken from the lambdabot?
12:26:57 <typoclass> @instances MonadIO
12:26:58 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
12:27:13 <typoclass> merijn: i think no. there's an IO instance for MonadIO
12:27:43 <merijn> typoclass: No, that'd mean if I had code expecting "MonadIO m => a -> m b" and had a "a -> IO b" I'd be fine
12:27:48 <merijn> typoclass: I'm asking the reverse
12:28:41 <typoclass> merijn: right, i see. i'd guess that you are screwed then, in your words
12:28:48 <merijn> Crap :\
12:30:05 <monochrom> lambdabot is both great and limited
12:33:34 <Caravaggio> typoclass: where can I find more about "runahskell"
12:34:35 <typoclass> Caravaggio: oh, it's just a small command that comes with your haskell compiler (ghc). "runhaskell something.hs" runs that file, without compilation (i.e. slower), but it's okay for quickly trying something
12:35:29 <Caravaggio> typoclass: I am looking for a way that is reasonably secure to run larger applications of potentially untrusted Haskell code
12:35:54 <mcstar> what do people do to draw fancy stuff with opengl?(2d)
12:36:27 <mcstar> do they draw into a buffer with cairo or other vector graphics, and display it as a texture?
12:36:53 <typoclass> Caravaggio: i think lambdabot uses something called mueval. check the lambdabot source code, and maybe check how tryhaskell.org does it (i bet it's open source as well)
12:37:49 <t7> mct
12:38:05 <t7> mcstar: why not just draw your vector art in opengl?
12:38:25 <hpaste> edwardk annotated “Lensed MonadCatchIO” with “Lensed (annotation)” at http://hpaste.org/75560#a75564
12:38:42 <mcstar> t7: im not sure how
12:39:10 <zomg> Caravaggio: if you want to try your hand at making something yourself rather than using mueval, you can use the GHC compiler APIs
12:39:11 <mcstar> t7: cant you just set up polygons and texture them?
12:39:20 <t7> yes
12:39:28 <t7> check the haskell GLUT tutorials
12:39:35 <Caravaggio> Thanks
12:39:49 <zomg> Caravaggio: I wrote about it here a bit (bear in mind I'm not really pro haskeller so it may not be perfectly awesome =) ) http://codeutopia.net/blog/2011/08/20/adventures-in-haskell-dynamic-loading-and-compiling-of-modules/
12:40:07 <mcstar> t7: i want stuff like, smooth lines, with effects, like glow, or filling polygons with gradients,...
12:40:33 <jfischoff> mcstar: smooth lines are not opengl speciality
12:40:46 <mcstar> yeah, i thought so
12:40:49 <mcstar> thats why im asking
12:41:00 <waseem_> I just started learning Haskell. I'm trying to work through "Learn You a Haskell". I copied an example from the book at http://learnyouahaskell.com/starting-out. But I get a parse error. https://gist.github.com/3808246
12:41:01 <t7> open GL has AA
12:41:10 <mcstar> maybe opengl is an overkill
12:41:19 <mcstar> i should just use a gtk canvas or something
12:41:28 <jfischoff> mcstar: probably
12:41:41 <jfischoff> mcstar: maybe diagrams?
12:41:45 <gfredericks> waseem_: what did you copy exactly?
12:41:46 <mapreduce> We'll all have retina displays in a couple of years and AA will be pointless.. right? :)
12:41:47 <ClaudiusMaximus> mcstar: i've done cairo->texture successfully in the past
12:41:48 <mcstar> ill check
12:42:12 <waseem_> gfredericks: Yes I did.
12:42:21 <gfredericks> waseem_: no what was it that you copied?
12:42:29 <mcstar> ClaudiusMaximus: 2 or 3d?
12:43:03 <merijn> waseem_: ghci doesn't accept assignment like that
12:43:03 <waseem_> gfredericks: Please see the gist I posted. You can find first few words in your browser. It is the 'boomBangs' function.
12:43:04 <ClaudiusMaximus> mcstar: using cairo to generate multiple mipmap levels with constant apparent line width for a sprite
12:43:16 <ckirkendall> can someone explain why I get an error with something like this "instance Monoid [Char] where"
12:43:30 <gfredericks> waseem_: oh sorry I missed the gist
12:43:34 <merijn> waseem_: Basically, you can't define functions in ghci
12:43:41 <waseem_> merijn: Ohh. Okay. What can I do to make it work.
12:43:42 <gfredericks> waseem_: like merijn said, in ghci you have to `let foo = bar`
12:44:02 <t7> mapreduce: i can just about play new games at 768p :(
12:44:08 <merijn> waseem_: The easiest solution is to put that in a .hs file and load it ghci by doing "ghci foo.hs" or (inside ghci) ":load foo.hs"
12:44:11 <waseem_> merijn: Okay got it. I will try to define it this way in a script and try to load it.
12:44:15 <ckirkendall> the error I recieve is: Illegal instance declaration for `Monoid [Char]'
12:44:15 <ckirkendall>       (All instance types must be of the form (T a1 ... an)
12:44:19 <ClaudiusMaximus> mcstar: but i used C because at that time gtk2hs/cairo had a severe performance issue http://claudiusmaximus.goto10.org/v/incidents/nightboat-v3.ogv is noisy but shows the idea - the waves are each just a quad with a fragment shader (but this is a bit ot)
12:44:29 <typoclass> waseem_: sorry, this is a little weird, but you can't have "something = something" in ghci. you have to do "let something = something in ..."
12:44:30 <waseem_> merijn: Thanks! I will do that. :)
12:44:39 <typoclass> > let boomBangs xs = [if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] in boomBangs [1,2,3] -- waseem_, see this
12:44:40 <lambdabot>   ["BOOM!","BOOM!"]
12:45:01 <waseem_> typoclass: Got it sire. Thanks for your help.
12:45:02 <merijn> waseem_: gfredericks' let example should also work, but having a text file open and loading it is good practice anyway since that way you can also play around with data types later (you can't define data types in the ghci prompt)
12:45:23 <gfredericks> merijn: I was told yesterday that newer ghci lets you define data types
12:45:27 * hackagebot hashtables 1.0.1.8 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.1.8 (GregoryCollins)
12:45:32 <merijn> gfredericks: Heresy!
12:45:41 <shachaf> merijn: It does.
12:45:44 * merijn is extremely sad
12:45:47 <shachaf> >=7.2, I think.
12:45:50 <shachaf> It's wonderful.
12:45:54 <merijn> shachaf: Not about that
12:45:56 <ClaudiusMaximus> mcstar: for fast smooth anti-aliased curves i use fragment shaders with liberal amounts of early "discard"
12:46:29 <typoclass> gfredericks: yup, but i don't think "x = y" works in any ghci (old or new)
12:46:31 <merijn> I have a "MonadIO m => a -> m b" but I can't use bracket with it since bracket demands "a -> IO b" :(
12:47:06 <ClaudiusMaximus> mcstar: and maths to make them "constant width" instead of "constant y height"... http://identi.ca/notice/80346472
12:47:46 <mcstar> ClaudiusMaximus: impressive
12:47:56 <mcstar> (from a total opengl noob's perspective)
12:48:07 <merijn> :t liftIO (bracket undefined undefined)
12:48:08 <lambdabot> Not in scope: `bracket'
12:48:17 <merijn> :t liftIO (Control.Exception.bracket undefined undefined)
12:48:18 <hpaste> Jeanne-Kamikaze pasted “Unpure FFI Thing” at http://hpaste.org/75567
12:48:18 <lambdabot>     Couldn't match expected type `IO a'
12:48:19 <lambdabot>            against inferred type `(a1 -> IO c) -> IO c'
12:48:19 <lambdabot>     In the first argument of `liftIO', namely
12:48:29 <Jeanne-Kamikaze> maukd, still around ?
12:48:33 <ClaudiusMaximus> mcstar: i should really push that repo before i lose it, if you wait 30mins it should be online...
12:48:53 <mcstar> ClaudiusMaximus: great, i might lear something from it
12:48:56 <mcstar> n
12:49:11 <ckirkendall> I am very new to Haskell and trying to experiment with some stuff.  Can someone help me figure out why I am getting an error on the following code: https://gist.github.com/3808269
12:50:43 <merijn> ckirkendall: The standard "demands" that you'd write "Monoid ([] Char)" even though this is perfectly sensible. The easiest solutions is to enable FlexibleInstances (like GHC says)
12:51:05 <ckirkendall> merijn: thanks!
12:51:19 <hpaste> Jeanne-Kamikaze annotated “Unpure FFI Thing” with “Unpure FFI Thing (annotation)” at http://hpaste.org/75567#a75568
12:51:29 <merijn> ckirkendall: Which you can do by putting the following pragma at the top of your file "{-# LANGUAGE FlexibleInstances #-}"
12:52:20 <monochrom> no, the standard forbids "Monoid [Char]" and "Monoid ([] Char)" (same difference). it allows only "Monoid [ variable_here ]"
12:52:35 <merijn> ah
12:52:39 <ckirkendall> merijn: it seem even ([] Char) still cused the same issue.  I will enable flexibleInstances
12:52:41 <monochrom> but the error message says exactly that
12:53:18 <merijn> monochrom: Yeah, I usually just skipped the message and enabled flexibleinstances directly >.>
12:53:28 <ckirkendall> monochrom: then how do you define a monoid over a string?
12:53:57 <merijn> ckirkendall: Well monoid for [a] includes the one for [Char]
12:54:18 <monochrom> Monoid [variable_here] is more general
12:54:23 <ckirkendall> merijn: good point
12:54:55 <ckirkendall> but my monoid identity would be wrong
12:55:14 <monochrom> you can use [] for empty string, too
12:55:35 <ckirkendall> monochrom: thanks
12:58:27 <lispy> changing from Num a to Double made this numeric code go from taking microseconds to nanoseconds to execute.
12:58:50 <lispy> Is there a way to get ghc to notice that specialization automatically so my type can still be general?
12:58:58 <jmcarthur> lispy: SPECIALIZE pragma?
12:59:17 <jmcarthur> s/?//
12:59:29 <lispy> looking
12:59:31 <dmwit> Suppose I have a term of type () that I happen to know is an infinite loop. If I treat it as a black box, can I produce a value of type forall a. a without additional recursion? Or do I need to open up the box?
12:59:35 <merijn> argh, I need to redesign all my code because it's impossible to "unlift" stuff :(
12:59:41 <jmcarthur> lispy: or if it's small you could make sure it's INLINABLE or even just force it to be INLINE
12:59:58 <Swizec> hello #haskell
13:00:00 <jmcarthur> since that could enable some call-site specialization
13:00:15 <ClaudiusMaximus> mcstar: https://gitorious.org/maximus/incidents very messy collection of bits and pieces
13:00:29 <lispy> jmcarthur: yes, this looks promising. I'll go benchmark it and report
13:00:35 <jmcarthur> lispy: SPECIALIZE basically makes a version of the function fixed to that type and a rewrite rule to replace uses of it with the specialized version
13:00:39 <mcstar> ClaudiusMaximus: thanks
13:01:04 <ClaudiusMaximus> mcstar: https://gitorious.org/maximus/incidents/blobs/master/code/wave.frag is probably what you want to look at first
13:01:47 <mcstar> i think i just better clone it
13:01:54 <mcstar> i cant use gitorous
13:02:48 <ClaudiusMaximus> mcstar: then code/boat.c is the part that uses cairo to generate multiple mipmap levels for the boat
13:03:16 <ClaudiusMaximus> (sorry everyone for off-topic, there is some haskell in the repo too, if you look hard enough)
13:03:20 <lispy> jmcarthur: right. And that should be just the right magic. Bummer than I even need to request it though.
13:03:29 <mcstar> ClaudiusMaximus: fatal: https://gitorious.org/maximus/incidents.git/info/refs not found:
13:04:08 <jmcarthur> lispy: i think it's the default just to avoid inflating the executable even more, although i personally wouldn't mind making that tradeoff most of the time
13:04:16 <jmcarthur> *much of the time
13:04:16 <lispy> awesome, now my hand coded matrix operations are actually faster than hmatrix (I have the advantage of only needing 3x3 and 4x4 matrices though)
13:04:22 <jmcarthur> nice!
13:04:31 <mcstar> ClaudiusMaximus: ok, https worked
13:04:52 <lispy> I wonder if hmatrix could benefit from specialize...
13:05:38 <lispy> Just glancing at the source code, I think the answer is yes
13:05:50 * lispy plans to find out
13:09:10 <jmcarthur> lispy: i've specialized some pretty weird things with great results. mtl instances for transformer stacks, for example
13:13:19 <edlinde_> I have been asked to convert a procedural code to "declarative style" for a paper
13:13:34 <edlinde_> wondering if functional programming is declarative style?
13:13:56 <gfredericks> probably not
13:13:58 <edlinde_> so basically I have to describe the "what" but not the "how"
13:14:20 <lispy> jmcarthur: my code is still faster (specialize didn't seem to help hmatrix), which is good considering the algorithm is less general.
13:15:13 <jmcarthur> edlinde_: i would describe ideal functional code as declarative, but the label "functional" is often applied to things i wouldn't call declarative
13:15:17 <lispy> edlinde_: a declarative language would be something like pure SQL
13:15:20 <Polarina> lispy, I could use some good, simple matrix operations. :)
13:15:40 <jmcarthur> haskell is pretty declarative
13:15:41 <lispy> edlinde_: possibly prolog too
13:15:42 <jmcarthur> usually
13:15:49 <applicative> edlinde_: the standard Haskell style is 'declarative', certainly.  I think the term originally applied to prolog
13:15:54 <edlinde_> lispy :  never done any prolog
13:16:12 <edlinde_> I have done some SML.. wondering if that style would work?
13:16:14 <lispy> Polarina: Good to know. I'm hoping to turn this into a library at some point.
13:16:20 <Ralith> Is there any way to get some sort of backtrace when foreign code triggers an abort? Even just of the foreign stack?
13:16:36 <lispy> edlinde_: SML is probably more functional and less declarative than haskell
13:16:42 <applicative> edlinde_: but what is this procedural code?  sml would presumably count.
13:16:45 <edlinde_> Just not sure how I can turn this procedural loops etc. to declarative. Guess I got to think recursive
13:16:57 <applicative> edlinde_: yes...
13:17:07 <lispy> Ralith: that's a case where gdb could be used
13:17:09 <Polarina> lispy, let me know when you decide to release it. :)
13:17:15 <Ralith> lispy: yes, it gives me nonsense.
13:17:20 <lispy> Ralith: unless you meant the Haskell "backtrace"
13:17:28 <Ralith> I'd settle for the foreign one.
13:17:43 <edlinde_> applicative: its basically operations carried out on vertices of a graph, so while looping through the vertices, if a certain condition is met, I have to remove the vertex
13:17:44 <Cale> There is a gradient -- functional programming is more declarative in general than imperative programming, but it still retains some operational character.
13:17:46 <lispy> Polarina: it's already on github (not as a library) but it's also not nice to use yet.
13:18:11 <Polarina> lispy, do you have a link?
13:18:11 <edlinde_> maybe I should type up the loop in a paste bin somewhere? would that help get a better opinion?
13:18:17 <Ralith> lispy: the foreign code in question is statically linked into the haskell binary; the earliest coherent stack frame gdb lists is from libc.
13:18:20 <lispy> Ralith: did you combile the foreign code with -ggdb3 or -g?
13:18:28 <Ralith> lispy: -g
13:18:34 <applicative> edlinde_: we use hpaste.org for what it's worth
13:18:39 <edlinde_> ok
13:18:58 <lispy> Polarina: https://github.com/dagit/haray/blob/master/src/Data/VectorSpace.hs
13:19:11 <lispy> Polarina: I will warn you, work in progress so don't assume my calculations are correctly implemented )
13:19:29 <Polarina> lispy, disclaimer noted. :)
13:19:34 <Polarina> Thanks.
13:19:46 <lispy> Ralith: in that case, gdb should be able to show you a reasonable foreign stack trace
13:19:50 <lispy> Polarina: yw!
13:19:50 <Cale> edlinde_: What is being asked for in your case is probably a specification for what the algorithm is computing which completely determines its result (but perhaps not how it obtains the result)
13:20:17 <Ralith> lispy: and yet it's all stuff like 0x0000000000946d76 in ?? () until it hits libc.
13:20:45 <merijn> :t bracket
13:20:47 <lambdabot> Not in scope: `bracket'
13:20:49 <jmcarthur> lispy: oh no! that module name overlaps with conal's vector-space package!
13:21:00 <merijn> :t Control.Exception.bracket
13:21:01 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:21:41 <lispy> jmcarthur: :)
13:22:04 <lispy> jmcarthur: I will probably change it to something different soon. I started by mimicing his vs library
13:22:08 <merijn> Is there any way to turn that into "MonadIO m => m a -> (a -> m b) -> (a -> m c) -> m c"? I would even settle for "MonadIO m => IO a -> (a -> IO b) -> (a -> m c) -> m c"
13:22:08 <jmcarthur> lispy: speaking of which, if you were to use NumInstances you could shorten your code a lot
13:22:09 <applicative> so it does.  Data.Vector.Space seems wrong for another.
13:22:17 <lispy> Ralith: Does gdb say anything about not finding symbols?
13:22:19 <applicative> ++ reason.
13:22:28 <merijn> I've been trying for a while now, but I can't think of any sensible approach...
13:22:37 <Ralith> lispy: yes; perhaps cabal is stripping them?
13:22:54 <edlinde_> Cale: yep thats the idea, but just wondering how I should go about it :)
13:22:56 <lispy> Ralith: oh, cabal builds in a sandbox so they are probably getting deleted
13:23:05 <Cale> edlinde_: Well, what is this graph algorithm?
13:23:08 <edlinde_> Cale: just looked at some Prolog code and it does look like SML
13:23:22 <Ralith> lispy: this is linux, aren't the symbols part of the binary?
13:23:30 <edlinde_> Cale: its a custome one, gimme a few minutes .. will type it up
13:23:35 <lispy> Ralith: but I don't think it strips...(I could be wrong, use file on the binaries will tell you if it's stripped)
13:23:42 <lispy> jmcarthur: NumInstances?
13:23:43 <edlinde_> Cale: maybe will take a first stab at the ML equivalent and you can help
13:24:02 <Ralith> lispy: says it's stripped.
13:24:12 <lispy> Ralith: ah, well there we go :)
13:24:44 <jmcarthur> lispy: http://hackage.haskell.org/package/NumInstances
13:24:58 <lispy> jmcarthur: ah. Hmm... I wonder what that would do for performance...
13:25:01 <jmcarthur> lispy: the instances that allow things like this:
13:25:18 <jmcarthur> > let average = sum / genericLength in  average [1..100]
13:25:19 <lambdabot>   50.5
13:25:30 <lispy> right
13:25:31 <jmcarthur> lispy: probably no difference
13:25:35 <Cale> edlinde_: The difference between Prolog code and SML is that Prolog as part of its fundamental mechanism implicitly does searches for values which satisfy n-ary predicates where possibly some of the parameters are known. There are not *functions* so much as relations which happen to have the condition that a function is meant to satisfy :)
13:25:53 <edlinde_> ok
13:25:59 <Ralith> lispy: how can I prevent that from occurring, or work around it?
13:26:22 <Cale> edlinde_: and many/most relations can be used in both directions: a program to concatenate two strings can also be used to split one up in all possible ways
13:27:02 <Ralith> lispy: nvm, got it
13:27:05 <Ralith> --disable-executable-stripping
13:27:34 <mcstar> --disable-executable-lapdancing
13:27:52 <Cale> It'll consist of something like a predicate Concat(X,Y,Z) which will be satisfied when Z is the concatenation of X and Y, say
13:28:15 <Ralith> lispy: works perfect now, thanks :D
13:28:39 <lispy> Ralith: awesome
13:32:25 <Egbert9e9> http://stackoverflow.com/questions/6320775/essentially-sequential-array-transformations-in-in-repa how (not) efficient is the first solution?
13:33:32 <hpaste> edlinde pasted “Procedural Code” at http://hpaste.org/75576
13:33:46 <lispy> Egbert9e9: one way to find out: http://hackage.haskell.org/package/criterion
13:34:12 <edlinde_> Cale: so that is my procedural code
13:34:15 <edlinde_> :)
13:34:31 <jmcarthur> Egbert9e9: looks like n^2 to me
13:35:01 <shachaf> hi Egbert9e9
13:35:31 <Egbert9e9> hihi and thanks jmcarthur and lispy
13:35:34 <jmcarthur> Egbert9e9: the second solution looks faster to me
13:35:39 <jmcarthur> unless the list is short
13:35:51 <jmcarthur> in which case i don't know
13:35:54 <Egbert9e9> couldn't make the second one work
13:36:24 <jmcarthur> i think n^2 was a bad way for me to describe the performance of the first one
13:36:25 <edlinde_> Cale: the paste was cooked up really fast, so there could be typos .. but that is the general idea
13:36:45 <edlinde_> Cale: how should I for example think about initialise?
13:37:02 <jmcarthur> m + n^2, for m = size of array and n = length of list
13:37:31 <jmcarthur> it also occurs to me that that implementation doesn't have the same behavior as the corresponding function from Data.Array
13:37:37 <jmcarthur> when there are duplicate indices
13:40:23 <KitB_> Can I define a point free function that will return true if two functions return the same output on the same input?
13:40:29 * hackagebot ad 3.1.4 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.1.4 (EdwardKmett)
13:41:08 <KitB_> (I'm a bit rusty)
13:41:58 <fmap> liftA2 (==), if you mean \f g x -> f x == g x
13:44:14 <KitB_> Quite
13:44:14 <applicative> @pl kitb f g x = f x == g x
13:44:15 <lambdabot> kitb = liftM2 (==)
13:44:31 <edlinde_> ok so I pasted the code and no responses? :)
13:46:07 <applicative> I can't tell what vertices its removing somehow, edlinde_ . Too darn imperative!
13:46:53 <edlinde_> hm
13:47:30 <edlinde_> its removing v'
13:48:13 <edlinde_> this is to be passed in.. like the list of vertices we want to remove.. that may or may not be removed
13:48:28 <edlinde_> sorry its removed always (my bad)
13:49:57 <applicative> Calculate \delta of v' (w.r.t v) is a little obscure
13:50:56 <edlinde_> yeah lets assume that its an operation known to us
13:51:00 <applicative> somehow we have a representation of a graph with a bunch of vertices and I guess ordered pairs connecting them; then we want to remove vertices, clearing out all the edges mentioning them
13:52:35 <edlinde_> applicative: yeah close :)
13:53:10 <edlinde_> calculation of delta is a blackbox and depending on what value we get .. we either update the delta value or not
13:54:11 <applicative> we speak of the 'delta of ' each vertex or maybe the delta of one w.r.t. another
13:54:37 <edlinde_> yes its the delta between two vertices
13:56:32 <zzing> if I have  fmap A (fmap B x)  is that the same as A <$> B <$> x
13:56:48 <applicative> yes
13:57:03 <zzing> applicative, very appropriate nick for your answer
13:57:28 <zzing> :t intercalate
13:57:31 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:58:13 <shachaf> Hah, if you double-CPS (.) composition goes back to the normal order.
13:58:25 <shachaf> (Which is sensible, of course.)
13:58:38 <jmcarthur> :t (.)
13:58:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:58:59 <shachaf> @let cps f g = \x -> g (f x)
13:59:01 <lambdabot>  Defined.
13:59:01 * jmcarthur shakes his head at Caleskell
13:59:19 <shachaf> > ((*2) . (+1)) 5
13:59:21 <lambdabot>   12
13:59:31 <shachaf> @let uncps f = f id
13:59:31 <opticdelusion> how many people are acually using template haskell? i've read some papers about that topic and tried some examples myself - seems to be a really handy tool, but i can't imagine any real use cases
13:59:32 <lambdabot>  Defined.
13:59:35 <shachaf> > uncps (cps (*2) . cps (+1)) 5
13:59:37 <lambdabot>   11
13:59:48 <shachaf> > uncps (uncps (cps (cps (*2)) . cps (cps (+1)))) 5
13:59:50 <lambdabot>   12
13:59:55 <merijn> opticdelusion: Well, for use cases look at (for example) the varying lens libraries
14:00:10 <merijn> opticdelusion: Which use Template Haskell to autogenerate lenses for datastructures
14:00:46 <edwardk> I use template haskell to do a ton of code generation in 'ad' and 'type-int' as well
14:01:13 <jmcarthur> the acid-state package makes pretty good use of template haskell, as well
14:01:22 <alpounet> persistent does too iirc
14:01:34 <jmcarthur> yesod generally uses a lot of TH
14:04:53 <opticdelusion> The lenses librariy looks interesting. Thanks for the direction.
14:05:49 <edwardk> lens, not lenses
14:06:12 <edwardk> lenses is an old library sitting in a useful point in the namespace
14:06:46 <carter> edwardk: put out a solicitation to kill lenses / take its space! :)
14:06:52 <carter> or just fiat coopt it :)
14:07:03 <edwardk> carter: =P
14:07:27 <edwardk> i was originally going to release data-lens as lenses, then i realized that package was there
14:13:46 <burbul> Which end of a list does a writer monad tell at?
14:14:14 <shachaf> The end end.
14:14:58 <Nereid> hey
14:15:02 <burbul> thanks
14:15:13 <Nereid> isn't appending to the end of a long list kinda expensive?
14:15:19 <shachaf> Yep.
14:15:22 <Nereid> yeah.
14:15:29 <shachaf> Depending on how you use Writer, that might not matter, though.
14:15:36 <Nereid> how so?
14:15:45 <burbul> Is there an off-the-shelf variant that writes to the beginning of the list (for efficiency reasons)?
14:16:00 <Nereid> burbul: use the dual monoid for []
14:16:32 <lispy> jmcarthur: I can't seem to get this numinstances thing to pay off
14:16:59 <jmcarthur> oh?
14:17:01 <Nereid> burbul: Dual a <> Dual b = Dual (b <> a)
14:17:18 <burbul> thank you.
14:17:23 <shachaf> It's possible that trying to add to the beginning is misguided.
14:17:23 <lispy> jmcarthur: yeah, at least the stuff that was obvious to try to me does not type check :)
14:17:28 <Nereid> possible.
14:17:30 <applicative> for efficience, burbul there is the obvious expedient of Endo [a] , 'diff lists' etc
14:17:34 <jmcarthur> lispy: link to your github page again?
14:17:38 <applicative> efficiency
14:17:41 <Nereid> yes.
14:17:46 <carter> any one have good opinions on crypto packages on hackage? :)
14:17:57 <Nereid> burbul: you might want to look at DList or similar.
14:18:00 <shachaf> carter: Most of them worry me.
14:18:00 <lispy> jmcarthur: the code I'm trying is not up there at the moment
14:18:03 <jmcarthur> ah
14:18:11 <carter> shachaf: how so/ in which ways?
14:18:26 <Nereid> which has O(1) append
14:18:26 <mcstar> i somehow i miss functions for IO code
14:18:39 <Puffton> How come I can't use the pipe char to match different conditions of a function, with "where" in multiple conditions?
14:18:40 <jmcarthur> lispy: well i just meant the old stuff. i was certain i saw a few big opportunities
14:18:44 <mcstar> like versions of when/unless that take an IO action or an IORef as predicates
14:18:52 <carter> i'm mostly wanting to update some of the IMap haskell code so i can write an email client for gmail :0
14:18:55 <lispy> jmcarthur: https://github.com/dagit/haray/blob/master/src/Data/VectorSpace.hs imagine that I'm rewriting determinant so that it looks more like, m00 * det3 m11 m12 ...
14:19:09 <jmcarthur> yeah
14:19:39 <lispy> ghc says Could not deduce (a ~ (Mat44 a0 -> a0)) from the context (Num a)
14:19:54 <jmcarthur> lispy: hpaste?
14:20:05 <Cale> Nereid: Writer appends elements with the same associativity as the binds
14:20:17 <Nereid> sure
14:20:18 <Cale> Nereid: So unless you have a lot of left recursion (++) isn't a problem
14:20:25 <Nereid> mhm.
14:20:26 * shachaf notes that >> is infixl
14:20:29 <shachaf> For some reason.
14:20:35 <Philonous> > flip appEndo [] . snd . runWriter $ do {tell $ Endo (1:); tell $ Endo (2:)}
14:20:37 <lambdabot>   [1,2]
14:20:41 <Cale> shachaf: oh, weird!
14:20:46 <carter> shachaf: ...
14:20:55 <Cale> At least (.) is correctly infixr
14:21:01 <shachaf> Is "do" infixl?
14:21:14 <Cale> burbul: By the way, the trick behind DList is useful to understand, and often just as easily applied as DList itself.
14:21:14 <shachaf> carter: I haven't looked at them in enough detail to give a good answer.
14:21:18 <Nereid> shachaf: I think not
14:21:18 <carter> fair
14:21:19 <lispy> jmcarthur: http://hpaste.org/75577
14:21:23 <rwbarton> I think the scoping rules force do to be infixr
14:21:41 <jmcarthur> lispy: you need to drop the m argument now
14:21:51 <Cale> burbul: The trick is basically to replace the use of lists [a] with functions [a] -> [a] which add elements to the beginning of a given list.
14:21:54 <lispy> ah, right
14:22:00 <Cale> burbul: Then [] becomes id
14:22:07 <Cale> burbul: and [x] becomes (x:)
14:22:14 <Cale> burbul: and (++) becomes (.)
14:22:16 <Puffton> http://hpaste.org/75578
14:22:20 <Puffton> like this, what's wrong with doing this?
14:22:46 <Nereid> Puffton: what's m?
14:22:50 <Puffton> sorry, I meant s there
14:22:52 <Philonous> Cale:  So basically the trick is to store the values as closures and let the compiler figure it out?
14:22:57 <Cale> And since f . g always evaluates in one step, while xs ++ ys takes O(length xs) steps to evaluate, this improves performance.
14:22:59 <Puffton> just trying to illustrate the where-issue I'm having
14:22:59 <Nereid> so why would you do that?
14:23:04 <Puffton> I would like to use where in both clauses
14:23:15 <Nereid> you probably have to indent lines 3,5 more
14:23:22 <lispy> jmcarthur: neat, no slow down so far. I'll continue to push this refactor around.
14:23:32 <Nereid> or move where down and left
14:23:41 <rwbarton> where scopes over an entire set of guards so you can't write it like this
14:23:53 <Nereid> eh
14:24:06 <Cale> Philonous: Well, you're forcing a right associative construction of the list, in a funny way.
14:24:07 <rwbarton> where doesn't attach to expressions the way you are trying to use it
14:24:11 <shachaf> rwbarton: Makes sense.
14:24:11 <Cale> Philonous: but yeah, kinda
14:24:14 <Nereid> hm.
14:24:17 <Puffton> Nereid, tried it, didn't work
14:24:22 <Puffton> errors on the pipe char
14:24:26 <applicative> mcstar: people often define things like whenM ... this one is seeming kind of ugly  http://hackage.haskell.org/packages/archive/cond/0.4.0.1/doc/html/src/Control-Conditional.html
14:24:27 * shachaf tests using an evil non-associative Monoid instance.
14:24:52 <Cale> Philonous: I find it easiest to understand just by measuring the total possible cost of each operation involved and seeing that you're replacing something which is O(n) with O(1)
14:25:01 <rwbarton> shachaf: Same way as if you write m1 >>= \_ -> m2 >>= \_ -> m3 that is automatically "infixr" because of where the lambdas are
14:25:03 <zzing> I love when contrived lines like             liftIO $ putStrLn $ Prelude.unlines $ show <$> documentSlug <$> entityVal <$> pagesInEntity    just compile and work first time
14:25:18 <shachaf> rwbarton: Right.
14:25:28 <shachaf> It's kind of strange that a >> b >> c /= do { a; b; c }
14:25:32 <mcstar> applicative: oh, thanks, ill get rid of mine then
14:25:39 <mm_freak_> zzing: contrived and very ugly
14:25:42 <hpaste> Nereid annotated “Puffton” with “Puffton (annotation)” at http://hpaste.org/75578#a75579
14:25:43 <rwbarton> I actually didn't believe >> was infixl until I learned so recently because of that
14:25:51 <zzing> mm_freak_, does the job although I take suggestions
14:25:53 <shachaf> I also thought >> was infixr
14:25:59 <Puffton> yes but that is pointless
14:26:08 <Puffton> it doesn't address the issue of using where in both cases
14:26:11 <Puffton> it's just an example
14:26:32 <Eduard_Munteanu> Eww.
14:26:41 <Eduard_Munteanu> Why is it infixl?
14:26:43 <rwbarton> Puffton: you have to use "let ... in ..." or reorganize the code in some other way
14:26:51 <Nereid> hmm
14:27:02 <Cale> zzing: You can replace all those $ with . I think
14:27:38 <rwbarton> infixl is better for some monads I suppose, not that that is much of an answer
14:28:02 <Nereid> zzing: and with (.) = fmap you can replace <$> with . too!
14:28:12 <zzing> heh
14:28:13 <shachaf> But you shouldn't.
14:28:16 <Nereid> :D
14:28:47 <Eduard_Munteanu> And infixr is better for others :(
14:28:47 <mm_freak_> zzing: liftIO . putStrLn . Prelude.unlines . fmap (show <$> documentSlug <$> entityVal) $ pagesInEntity
14:28:55 <rwbarton> indeed
14:28:58 <Nereid> haha I just realized I messed up that paste.
14:29:03 <Puffton> hm ok :(
14:29:20 <Polarina> It seems that I forgot to use 'withSocketsDo' in the network library on Windows. And networking still worked without problems. Am I missing something? The haddock documentation says it is absolutely required.
14:29:22 <rwbarton> but you can write the ones that want infixr with do notation! (shudder)
14:29:32 <Nereid> Polarina: strange things may happen.
14:29:39 <Nereid> unpredictably.
14:29:49 * Polarina is scared.
14:30:09 <mm_freak_> Polarina: it's windows…  the underlying core language is java2k
14:30:09 <Philonous> Cale:  Yes, but part of "getting" it for me was to understand that you can actually use closures in that way, that is as temporary variables to hold on to data until the final value is constructed
14:30:27 <Nereid> Polarina: wait uh. looking at the source, withSocketsDo x = x
14:30:28 <Nereid> lol
14:30:41 <Cale> Philonous: I tend to avoid saying the word closure at all unless I'm thinking about the implementation of the language.
14:30:43 <mm_freak_> Nereid: under windows?
14:30:49 <Nereid> I don't see any conditionals in the source.
14:31:04 <rwbarton> maybe that is for if you are running on windows 95 with winsock
14:31:07 <mm_freak_> Nereid: not even CPP?
14:31:21 <Polarina> Nereid, it's generated from a .hsc file. It may be different there.
14:31:26 <Nereid> maybe.
14:31:27 <YayMe> I can't believe I thought emacs was stupid for so many years.. question, is it easy to port something written in parsec to attoparsec?
14:31:50 <Cale> Philonous: Mainly because the functions which Haskell gives you don't give you any way to separate the code and data making up the closure, so they don't really support the required interface to "be" closures, even where they get implemented as such.
14:31:51 <Puffton> will the where clause always share its bindings between all clauses?
14:31:52 <mm_freak_> the time library switches between entire modules depending on the OS, so you might be looking at the wrong module
14:32:08 <typoclass> rwbarton: well most linux fanboys mentally are stuck in 1995, so that fits :)
14:32:16 <Cale> Philonous: So usually I'll just say "functions" :)
14:32:18 <Nereid> aha yes.
14:32:20 <Nereid> there's the hsc
14:32:24 <Polarina> The connect function seems to call withSocketsDo for me when it fails. :/
14:32:53 <Cale> withSocketsDo seems like a terrible hack which shouldn't be required in the first place.
14:32:55 <mm_freak_> windows is weird anyway…  i don't know why you have to initialize sockets there
14:32:59 <zzing> mm_freak_, nice.
14:33:10 <mm_freak_> zzing: much more readable =)
14:33:12 <Cale> If extra initialisation is required on Windows, the RTS should just do it for you.
14:33:47 <Nereid> I don't like it when magic happens
14:33:52 <mm_freak_> Cale: not necessarily…  windows' sockets API does some weird stuff to your program, in particular i think it even starts a hidden thread behind the scenes
14:34:11 <mm_freak_> so you probably don't wnat that for a simple command line program
14:34:27 <Cale> mm_freak_: well, it could always be done upon the first use of any sockets
14:34:32 <Cale> no?
14:34:35 <mm_freak_> that's true
14:34:48 <Cale> (maybe that's what it *is* doing?)
14:34:57 <Nereid> lol
14:35:01 <rwbarton> but if so then why export withSocketsDo
14:35:08 <rwbarton> maybe for historical reasons I guess
14:35:12 <Cale> rwbarton: because backwards compatibility, yeah
14:35:13 <YayMe> Are there any plugin like frameworks for haskell?
14:35:18 <mm_freak_> Cale: but note that there are potentially many entry points into the sockets API even for the same operation
14:35:18 <rwbarton> if ghc 6.4 or whatever didn't automatically do that
14:35:27 <mm_freak_> Cale: just like under linux you have send, write, sendfile, etc.
14:35:30 <Cale> YayMe: hint
14:35:33 <YayMe> something that makes late binding simple like DI
14:35:34 <zzing> mm_freak_, to me it does look about the same
14:35:44 <YayMe> Cale: thanks, I'll have a look
14:35:54 <mm_freak_> zzing: because you wrote it…  revisit your code a month later =)
14:36:04 <Cale> YayMe: hint is basically a little wrapper around the GHC API
14:36:07 <rwbarton> the latest documentation for withSocketsDo still claims that it is necessary though
14:36:25 <Cale> YayMe: which lets you load Haskell code at runtime and evaluate expressions in terms of the loaded code
14:36:41 <mm_freak_> YayMe: plugins as in an embedded haskell interpreter or dynamic loading?
14:36:47 <Puffton> rwbarton, let ? in seems to suffer from the same limitations as where in this case thought?
14:36:49 <Puffton> though*
14:36:50 <WhoNeedszzz> Hey guys
14:37:01 <mm_freak_> hi there WhoNeedszzz
14:37:14 <YayMe> mm_freak_: Configurable late binding is all I need
14:37:19 <Cale> Note that this secretly supports compiled code, in that if you have .hi and .o files present, then just like ghci, it'll load the compiled object code.
14:37:20 <WhoNeedszzz> So i'm trying to compute the sum of cubes 1..n. The best method is to use a list comprehension IMO, but i'm supposed to come up with 2 methods of doing it. What's another way?
14:37:20 <hpaste> rwbarton annotated “Puffton” with “Puffton (annotation)” at http://hpaste.org/75578#a75580
14:37:25 <rwbarton> Puffton, try that
14:37:42 <mm_freak_> YayMe: then there are at least to plugin libraries on hackage…  their usage is really ugly
14:37:51 <milaz> WhoNeedszzz: folds, maybe?
14:37:53 <YayMe> Cale: Cool, so it'll do what I want, but also a lot more
14:37:56 <Puffton> ah nevermind, I had a paranthesis error
14:37:59 <WhoNeedszzz> milaz, come again?
14:38:00 <Puffton> thanks rwbarton!
14:38:04 <Nereid> WhoNeedszzz: compute sum [1..n] and square it :O
14:38:04 <Cale> WhoNeedszzz:  n^2 * (1 + n)^2 `div` 4
14:38:08 <mm_freak_> YayMe: hint is much nicer interfacewise, but is not a dynamic loader
14:38:21 <rwbarton> you could write a manually fused cubing/addition loop
14:38:38 <rwbarton> aka recursion on n
14:38:46 <Cale> sum over k = 1 to n of k^3 = (n^2 (1+n)^2)/4
14:38:46 <WhoNeedszzz> cubes...not squares
14:38:52 <Nereid> WhoNeedszzz: I know!
14:38:57 <YayMe> mm_freak_: Not a dynamic loader? You mean it won't load DLL's, only code or objs/libs?
14:39:03 <Nereid> WhoNeedszzz: sum of the cubes is square of the sum.
14:39:08 <lispy> jmcarthur: I'm having some trouble figuring out how to write inverse too
14:39:09 <Philonous> connect actually handles WSANOTINITIALISED and calls withSocketsDo for you
14:39:18 <Cale> = (n (1+n)/2)^2
14:39:22 <mm_freak_> WhoNeedszzz: a map on the list [1..n] and a coroutine/thread taking (Double, MVar Double) pairs and reports back the result
14:39:27 <milaz> WhoNeedszzz: map (^3) over the list [1..n], and then foldl it with 1 and (+)
14:39:38 <YayMe> mm_freak_: granted .lib is the more or less equivalent to dll in linux
14:39:43 <WhoNeedszzz> Ok that's above my knowledge of haskell
14:39:49 <mm_freak_> YayMe: hint is an interpreter
14:40:04 <Cale> mm_freak_: It's not *just* an interpreter
14:40:09 <Cale> mm_freak_: It can also load compiled code
14:40:11 <Nereid> milaz: I don't think you want to fold it with 1
14:40:24 <mm_freak_> Cale: really?  that's nice
14:40:35 <Cale> mm_freak_: It's just like ghci
14:40:43 <lispy> jmcarthur: I ended up with Mat44 (Mat44 a -> a) instead of Mat44 a -> Mat44 a
14:40:46 <rwbarton> you could write out i^3 'a's to a file for i=1..n and then use System.Posix.Files.fileSize
14:40:49 <Cale> (it's calling the same GHC APIs as GHCi does)
14:40:58 <milaz> Nereid: right, I'd better fold it with 0
14:41:08 * YayMe wonders if he should write a mimic of one of the well regarded DI or plugin frameworks from C# that uses hint
14:41:14 <lispy> jmcarthur: and I guess I need a zip of some sort to fix that
14:41:58 <YayMe> considering you're saying the interfaces for the plugin frameworks stink and hint sounds like an interface built for a different purpose
14:42:02 <mcstar> @pl \x y z -> x * y * z
14:42:02 <lambdabot> ((*) .) . (*)
14:42:04 <Cale> @check \n -> sum [1..n]^2 == sum [k^3 | k <- [1..n]]
14:42:05 <lambdabot>   "OK, passed 500 tests."
14:42:30 <Nereid> who needs to prove things when you have quickcheck!
14:42:33 <mm_freak_> Cale: would you recommend using hint directly, though?
14:42:33 <WhoNeedszzz> Nereid, huh you're right. I guess that's the simplest answer
14:42:34 <mm_freak_> i see
14:42:35 <YayMe> Is there anything at all similar to or resembling C#'s attributes in Haskell?
14:42:42 <mcstar> @pl \(x,y,z) -> x * y * z
14:42:43 <lambdabot> (line 1, column 6):
14:42:43 <lambdabot> unexpected ","
14:42:43 <lambdabot> expecting letter or digit, operator or ")"
14:42:43 <lambdabot> ambiguous use of a non associative operator
14:42:49 <Cale> @check \n -> ((n*(n+1))`div`2)^2 == sum [k^3 | k <- [1..n]]
14:42:50 <lambdabot>   "Falsifiable, after 4 tests:\n-3\n"
14:42:53 <Cale> lol
14:43:01 <jfischoff> what are c#'s attributes?
14:43:01 <Nereid> lol
14:43:07 <Cale> @check \(Nonnegative n) -> ((n*(n+1))`div`2)^2 == sum [k^3 | k <- [1..n]]
14:43:08 <lambdabot>   Not in scope: data constructor `Nonnegative'
14:43:13 <Cale> @check \(Positive n) -> ((n*(n+1))`div`2)^2 == sum [k^3 | k <- [1..n]]
14:43:14 <lambdabot>   Not in scope: data constructor `Positive'
14:43:16 <Cale> oh
14:43:20 <Cale> old quickcheck
14:43:32 <Nereid> @check (\n -> ((n*(n+1))`div`2)^2 == sum [k^3 | k <- [1..n]]) . abs
14:43:33 <YayMe> jfischoff: it's a way of annotating part of your code for inspection at runtime
14:43:34 <lambdabot>   "OK, passed 500 tests."
14:43:59 <Cale> That works :)
14:44:11 <Cale> At some point I'm going to need to find a way to update the GHC on lambdabot's machine
14:44:20 <Cale> I think I might be in sudoers there
14:44:23 <mcstar> seems to me, attrivutes are for things that the language developers didnt anticipate
14:44:25 <Nereid> what version is it at now?
14:44:32 <jfischoff> YayMe: any code or just type declarations?
14:44:33 <mcstar> and they just throw in a new attribute
14:44:43 <Philonous> Cale:  What GHC is it running?
14:44:45 <Cale> 6.12.3
14:44:50 <Nereid> ancient
14:45:06 <Cale> Hey, it's not like it's 5.x :)
14:45:15 <Cale> I should switch it to 5.02
14:45:19 <YayMe> jfischoff: signature or type declarations, you can't put them in the middle of a method, btu you can put them over a class or anything encapsulated therein
14:45:50 <Nereid> I never even touched haskell until like
14:45:51 <Nereid> 6.8?
14:45:55 <Cale> http://www.haskell.org/ghc/docs/5.02.3/set/book-hslibs.html :D
14:46:24 <mcstar> YayMe: what does [< >] called then?
14:46:31 <Cale> Fuck the hierarchy
14:46:31 <WhoNeedszzz> Do you guys know about perfect integers?
14:46:33 <Cale> :D
14:46:34 <mcstar> does->is
14:46:55 <mcstar> @wiki perfect integer
14:46:56 <lambdabot> http://www.haskell.org/haskellwiki/perfect_integer
14:46:57 <jmcarthur> lispy: that's odd
14:46:59 <YayMe> mcstar: well, one thing I've used attributes for which was pleasant was the [Import(typeof(IWhatever))] attribute over a property, then at runtime there's a plugin framework where you can just kick it and it will inspect your class to find those imports and actually fill the properties with instances which implement the specified type
14:47:04 <Cale> WhoNeedszzz: As in integers which are equal to the sum of their divisors?
14:47:08 <WhoNeedszzz> yeah
14:47:14 <WhoNeedszzz> So how is 6 perfect?
14:47:22 <jfischoff> YayMe: Tagging functions  is trickier, but for types you could just use type classes
14:47:26 <dmwit> 1 + 2 + 3 = 6
14:47:27 <hiptobecubic> WhoNeedszzz, 3 2 1?
14:47:30 <Cale> Sum of their *proper* divisors :)
14:47:30 <Nereid> proper divisors
14:47:40 <Nereid> else no number would be perfect.
14:47:43 <Nereid> except 1.
14:47:43 <WhoNeedszzz> Ah i see
14:47:54 <Nereid> also
14:47:56 <Nereid> positive divisors
14:48:02 <WhoNeedszzz> Now to figure out how to write the function for that
14:48:08 <Cale> yeah, otherwise in Z you'll get lots of cancellation :)
14:48:11 <YayMe> mcstar: another common use is range checkers, you put [Range(1,3)] over a property in a class and similar validation rules over other properties in that class, then you just hand instances of that class to a validator method which will ensure the instances meet the valid criteria as defined by the attributes
14:48:33 <jmcarthur> lispy: oh i see how that comes up. it's due to reusing det
14:48:40 <jmcarthur> hmm
14:49:08 <jfischoff> YayMe: you achieve something similar with type classes
14:49:10 <WhoNeedszzz> What's the most efficient way of getting the divisors?
14:49:40 <mcstar> @wiki "most efficient way of getting the divisors"
14:49:41 <lambdabot> http://www.haskell.org/haskellwiki/"most_efficient_way_of_getting_the_divisors"
14:49:43 <YayMe> jfischoff: similar yes, here's what I don't know how to do in haskell though: find all types that implement a type class
14:49:43 <zzing> What is the simplest way to parse command line options? (Stuff like   -b "…" -s "…"
14:49:45 <merijn> WolframAlpha :p
14:49:46 <lispy> jmcarthur: I did something like Mat44 ((... / d) m)
14:49:56 <lispy> jmcarthur: and then the performance was terrible
14:50:03 <merijn> YayMe: You can't
14:50:07 <YayMe> jfischoff: That's the useful part about C# being reflexive, you can just search for all types with given attributes (or other criteria)
14:50:13 <jmcarthur> lispy: did you check the core?
14:50:16 <lispy> jmcarthur: So I think NumInstances is cool, but I don't know how to use it without sacrificing performance
14:50:18 <jmcarthur> i'm curious about that
14:50:26 <WhoNeedszzz> mcstar, that didn't return anything
14:50:30 <merijn> YayMe: Why would you need to find that out, though?
14:50:33 <rwbarton> you can sort of maybe do that with Template Haskell
14:50:49 <YayMe> merijn: Plugin architectures are often based on that concept
14:50:58 <jfischoff> YayMe: you can do that with template haskell
14:51:05 <jmcarthur> lispy: how was d defined in that?
14:51:08 <Cale> WhoNeedszzz: The most efficient way that you're likely to understand without a bunch of number theory is probably just to factor the number into primes by testing divisibility, and actually dividing off each prime as you find it, then forming all combinations of the primes that you found.
14:51:32 <jmcarthur> lispy: const $ determinant m  ?
14:51:35 <lispy> jmcarthur: it was just a binding to determinant
14:51:44 <jmcarthur> ah! that's the problem
14:51:46 <YayMe> merijn: drop an assembly in a folder, and your program just finds every class in that folder which implements IWhatever or has X attribute etc, you can work around not having reflexivity but it is kind of nice for some cases
14:51:49 <jmcarthur> you were repeating the work
14:51:54 <Cale> There are better ways to factor a number into primes than just trying each prime, but they tend to be quite involved.
14:52:20 <merijn> YayMe: Sounds rather brittle
14:52:21 <jfischoff> and you could shove the results into a dictionary keyed by the Typeable rep or name (I don't know) and have the same results
14:52:51 <jmcarthur> lispy: you want it to be something like   const (determinant m)   so that it doesn't have to reevaluate (determinant m) each time
14:52:54 <YayMe> merijn: It's not something you use often don't get me wrong
14:53:02 <rwbarton> the Haskell equivalent would be having a bunch of compiled modules and checking which ones contain a symbol of a certain name
14:53:11 <rwbarton> or type, possibly
14:53:23 <YayMe> rwbarton: yeah, exactly, can that be done? Haskell doesn't compile to IL does it?
14:53:30 <rwbarton> uh
14:53:33 <rwbarton> you mean the .net thing? no
14:53:36 <jfischoff> Haskell has less of need to be reflex of runtime, because of what it can achieve at compile time (it can still be useful or course).
14:53:37 <YayMe> no
14:53:37 <rwbarton> or something more general
14:53:43 <YayMe> IL = intermediate language
14:53:44 <mm_freak_> Cale: the code for pollard p-1 is not much longer than the one for trial division, but MUCH faster
14:53:46 <YayMe> just mean byte code
14:53:49 <YayMe> non-native
14:53:52 <lispy> jmcarthur: gotcha. Yeah, that fixes the performance bug. I didn't even think about that :)
14:53:54 <rwbarton> why is that relevant
14:53:55 <lispy> jmcarthur: thanks
14:53:56 <jfischoff> s /reflex/reflective/
14:54:14 <rwbarton> it can compile to native code but still have info about the names and types of things
14:54:17 <YayMe> rwbarton: Perhaps I'm wrong, but I presume in general a byte code will be more verbose and thus mroe parseable than a direct native machine code
14:54:18 <rwbarton> as well
14:54:48 <rwbarton> name/type information is a different kind of information than the actual executable code of a function
14:55:32 <lispy> jmcarthur: now if I write something Matrix (Matrix a -> a) -> Matrix a -> a, I can simplify this even more
14:55:49 <YayMe> rwbarton: Right, I guess I don't know enough about how native code is laid out in a binary assembly to know what kind of metadata can be stored in it for things like reflection purposes
14:55:52 <lispy> :t ap
14:55:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:56:33 * nand` has yet to find a compelling distinction between ‘native code’ and ‘bytecode’
14:56:44 <YayMe> rwbarton: In a normally GHC compiled assembly, is name/type information stored in it in a parseable format?
14:56:49 <rwbarton> YayMe, well obviously there must be information about the names of symbols for the linker :P
14:57:01 <nand`> how does lambdabot handle its plugins?
14:57:07 <thoughtpolice> YayMe: GHC emits interface files that describe a lot of the important information inside a compiled module. they are the .hi files that sit next to .o files
14:57:08 <lispy> nand`: the instruction sets are often very different
14:57:46 <YayMe> nand`: bytecode is just what we enterprisey devs often refer to our intermediate language as, I realize machine code is also a code made of bytes..
14:57:49 <thoughtpolice> the linker and associated stuff like 'plugins' works on using the interface file for bits of important information
14:58:07 <YayMe> nand`: We enterprisey devs say lots of dumb things like that though
14:58:20 <thoughtpolice> nand`: dons has some papers on it, that should give you a rough idea. i reimplemented an irc bot with dynamic plugins myself based on it
14:59:03 <thoughtpolice> it's quite doable, but historically stuff like 'plugins' has been brittle and the approach has some other drawbacks
14:59:05 <YayMe> thoughtpolice: so GHC can spit out .hi files which behave like the metadata I'm used to reflecting in C#
14:59:20 <rwbarton> you can hardly get it not to spit out .hi files
14:59:26 <thoughtpolice> GHC always spits out .hi files. they're an important part of it's design
14:59:32 <YayMe> ok
14:59:44 <rwbarton> really annoying when you want to tab complete things :)
14:59:57 <WhoNeedszzz> Is this a good solution to my perfect int problem? http://ideone.com/Q24j9
15:00:07 <WhoNeedszzz> It seems to work
15:00:10 <thoughtpolice> yeah, although if i'm not using cabal i find it worth it to use -hidir and -odir to specify output
15:00:16 <nand`> one method I can see working is something like what xmonad/dyre does, where you recompile the ‘worker’ binary whenever you load or unload a plugin
15:00:25 <YayMe> What type of information do they have? data type names and signatures? type class names/signatures? functino signatures?
15:00:46 * YayMe always gets to the n key before the o key when typing function.. dunno why
15:01:10 <rwbarton> any information about a module that you would need to typecheck or build a program that uses that module
15:01:22 <nand`> YayMe: if ‘bytecode’ == ‘intermediate language’, then GHC has quite a few of them; arguably including Haskell itself
15:01:22 <rwbarton> I believe
15:01:32 <thoughtpolice> YayMe: all the above, they can even contain function definitions themselves
15:01:40 <rwbarton> when you import Data.List GHC doesn't read List.hs
15:01:46 <thoughtpolice> (which is how GHC does cross-package/cross-module inlining)
15:02:04 <milaz> WhoNeedszzz: on line two, 1..(n-1)
15:02:05 <thoughtpolice> realistically you can pretty much cram an entire module into a .hi file
15:02:06 <YayMe> rwbarton: so in that way typeclasses could be used as a basic one to one with C# attributes so long as the .hi files are available
15:02:24 <WhoNeedszzz> milaz, ...?
15:02:25 <milaz> WhoNeedszzz: maybe 1..(floor $ sqrt n) would be better?
15:02:55 <thoughtpolice> nand`: that seems to be the popular approach, and it works pretty well. this is totally doable for an IRC bot, since you can exec() and keep file descriptors open
15:03:00 <WhoNeedszzz> That would be two extra function calls...
15:03:02 <Mon_Ouie> Just make sure to handle perfect squares properly
15:03:05 <WhoNeedszzz> That's not efficient
15:03:09 <milaz> ha-ha
15:03:13 <thoughtpolice> it's also a lot more simpler conceptually and less brittle than dyanmically loading object files
15:03:16 <thoughtpolice> IMO, anyway
15:03:17 <Mon_Ouie> WhoNeedszzz: That's O(sqrt(n)) vs O(n)
15:03:55 <YayMe> thoughtpolice: Doing what? recompiling your worker process with each new plugin?
15:04:02 <WhoNeedszzz> Mon_Ouie, How do you figure
15:04:10 <rwbarton> at the other extreme you can also just fork processes and use normal IPC mechanisms
15:04:17 <nand`> Can I inspect GHC parameters with TH?
15:04:39 <jfischoff> hand`: command line parameters?
15:04:55 <Mon_Ouie> You only need to iterate for positive integers up to the sqrt of n (i.e. sqrt(n) steps), not all of them
15:04:56 <jfischoff> :p
15:05:03 <nand`> yeah; for example if I want to pass a list of modules to ‘include’ at the GHC command line and embed them using TH
15:05:07 <milaz> WhoNeedszzz: for n = 10, 10 iterations vs 3; for n = 100, 100 iterations vs 10
15:05:19 <WhoNeedszzz> Hmm
15:05:21 <rwbarton> you can do whatever IO actions you want so I guess that includes getArgs
15:05:22 <WhoNeedszzz> what does $ mean?
15:05:23 <Mon_Ouie> Because if a is a divisor b, then so is (a / b) — and one of those has to be less than sqrt(a)
15:05:23 <YayMe> rwbarton: That's a very good point... I actually started looking at haskell after falling in love with IPC and how difficult it makes state mutation taught me state mutation is the Fountain of Evil
15:05:31 <nand`> WhoNeedszzz: ($) = id
15:05:36 <Mon_Ouie> (or equal to it)
15:05:37 <WhoNeedszzz> meaning?
15:05:38 <WhoNeedszzz> ha
15:06:04 <jfischoff> nand`: I don't think you can
15:06:40 <WhoNeedszzz> And then given that wouldn't divisors 6 be wrong then? sqrt(6) < 3
15:06:46 <WhoNeedszzz> That would remove 3 as a divisor
15:06:54 <YayMe> rwbarton: What's commonly used for IPC in haskell? shared memory mapping?
15:07:07 <thoughtpolice> YayMe: dynamic loading in GHC is fragile in a few ways. it totally works, but just executing a new process with a persistent state, and inheriting things like file descriptors is a lot better way to go IMO
15:07:43 <YayMe> thoughtpolice: Yeah I don't know why I didn't think about doing it that way. IPC is my friend
15:07:45 <Mon_Ouie> No, because you'd detect 2 as a divisor, and at the same time, you'd know (6 / 2) (i.e. 3) is a divisor too
15:07:46 <jfischoff> what is IPC?
15:07:55 <thoughtpolice> inter-process communication
15:08:09 <jfischoff> ah
15:09:15 <jfischoff> YayMe: I've used sockets, perhaps there are other options.
15:09:43 <hpaste> rwbarton pasted “get ghc command line args from TH” at http://hpaste.org/75582
15:09:48 <rwbarton> nand`: ^ this works
15:09:49 <thoughtpolice> i loves me some unix pipes
15:10:25 <jfischoff> rwbarton: that's cool
15:11:13 <rwbarton> apparently my ghci runs with -fobject-code and -O2, good to know :)
15:11:18 <YayMe> thoughtpolice: Unix pipes are shared memory no? In windows we call them "memory mapped files" I think it's the same thing because sometimes they're referred to as pipes in windows too
15:11:47 <jfischoff> rwbarton: -O2 :o
15:12:02 <nand`> rwbarton: interesting
15:12:39 <thoughtpolice> YayMe: yeah, you share pipes between child/parent
15:12:44 <thoughtpolice> typically anyway
15:12:50 <WhoNeedszzz> milaz, No instance for (RealFrac Int)
15:12:50 <WhoNeedszzz>       arising from a use of `floor'
15:12:52 <MHD> YayMe: Pipes are pipes
15:13:08 <MHD> YayMe: They are lazy/buffered
15:13:16 <rwbarton> shared memory and memory mapped files are the same and pipes are something different
15:13:26 <YayMe> thoughtpolice: Can haskell easily do pipes with processes that aren't child/parent ?
15:13:36 <WhoNeedszzz> YayMe, pipes direct output of something to something else...
15:13:48 <geekosaur> unix can't do pipes created with pipe() but can use fifos between arbitrary processes
15:13:56 <MHD> YayMe: pipe() in Unix gives you file handles which are integers
15:14:16 <rwbarton> modern linux actually implements the POSIX shared memory interface via mmapped files in /dev/shm/ which is a tmpfs filesystem
15:15:03 <YayMe> rwbarton: AH, so if I wanted to do IPC with memory mapped files I would just use haskell's standard file IO facilities to write to and read from an arbitrary file in there?
15:15:09 <hpaste> “Ertugrul Söylemez” pasted “Pollard p-1 in Haskell” at http://hpaste.org/75583
15:15:20 <mm_freak_> see paste, if you need somewhat fast factoring in haskell =)
15:15:28 <mm_freak_> % time ./pollard 281037462074870949421753555350522821
15:15:29 <mm_freak_> 281037462074870949421753555350522821: 487524142893449159 ** timings:  real 0.050  user 0.047  krnl 0.000  cpu% 93%
15:15:37 <rwbarton> yes, but... shared memory is pretty much the "state mutation" approach to IPC
15:16:04 <MHD> Is there some easy way of implementing a trie parsing combinator in Parsec?
15:16:23 <YayMe> rwbarton: Right, in windows we aren't given a lot of options so I'm not super familiar with my choices here heh. Never been a *nix developer despite how much I wanted to years ago
15:16:38 <rwbarton> doesn't windows have pipes like unix?
15:17:01 <mm_freak_> rwbarton: windows can redirect std*, but it doesn't have fifos as filesystem nodes
15:17:07 <YayMe> Perhaps? I'm not familiar with using them. Memory mappings tend to be the common IPC approach outside of RPC
15:17:13 <MHD> no, windows doesn't implement the blocking buffer pipes
15:17:20 <rwbarton> wow
15:17:20 <pnielsen> there's always the POSIX subsystem for Windows..
15:17:21 <mm_freak_> rwbarton: it has named pipes, but you need to use a different API for them
15:17:38 <rwbarton> I see
15:17:41 <YayMe> mm_freak_: named pipes in windows are just memory mappings
15:17:41 <MHD> windows has intermediate files
15:17:45 <rwbarton> can't you pipe between processes at the shell?
15:17:52 <rwbarton> fsvo shell
15:17:56 <WhoNeedszzz> milaz, No instance for (RealFrac Int)
15:17:58 <mm_freak_> rwbarton: as said, it can redirect std*, so yes, you can
15:18:00 <YayMe> rwbarton: yes, you have your stdin/stdout/stderr and such
15:18:07 <milaz> WhoNeedszzz: floor $ sqrt $ fromIntegral n
15:18:10 <geekosaur> rwbarton, even old MS-DOS had that... simulated via temporary files
15:18:21 <rwbarton> if I have prog1 | prog2 does it use a temp file?
15:18:35 <YayMe> rwbarton: No
15:18:57 <mm_freak_> it's funny that in haskell the code for modular exponentiation is longer than the code for pollard's p-1 factoring algorithm =)
15:19:01 <jmcarthur> lispy: that's an interesting type...
15:19:12 <YayMe> rwbarton: But unless I'm terribly mistaken I don't know that stdin for a process is generally published in the system as an accessible stream from another process
15:19:51 <rwbarton> well the really relevant question is can a windows process launch a subprocess and write to its stdin/read from its stoud
15:19:54 <rwbarton> stdout
15:19:55 <rwbarton> I assume so
15:20:04 <YayMe> rwbarton: named pipes are registered with the OS as memory allocations for memory mapping
15:20:08 <YayMe> rwbarton: Yes.
15:20:24 <mm_freak_> rwbarton: it uses CreateProcess(Ex), where you can specify the standard handles…  start prog2 first, get its standard input, then start prog1
15:20:27 <YayMe> rwbarton: But I don't know that you can do that same with an arbitrary non-child process
15:20:33 <rwbarton> oh, sure
15:20:38 <MHD> The really interesting question is if you can pipe stdout into stdin.
15:20:54 <rwbarton> hehe
15:20:55 <mm_freak_> doubt it
15:20:56 <rwbarton> where's my mfix
15:20:59 <mm_freak_> lol
15:21:12 <MHD> I think you can in unix
15:21:19 <MHD> with a hax
15:21:30 <MHD> almost everything is possible
15:21:35 <mm_freak_> MHD: you don't need a hack…  just use a fifo
15:21:47 <MHD> Thus the whole "C - You shoot yourself in the foot" tjomg
15:22:00 <lispy> jmcarthur: it arises naturally from the way I implemented inverse
15:22:01 <MHD> mm_freak_: Neat
15:22:20 <mm_freak_> MHD: man pipe
15:22:29 <mm_freak_> gives you an unnamed pipe
15:23:56 <YayMe> MHD: on the command it's got 0 1 and 2 for stdin/out/err and you can do things like someCmd 1>stdout.txt 2>stderr.txt etc, as well as someCmd < file.txt to push file.txt into your stdin
15:24:20 <rwbarton> none of that requires pipes though
15:24:21 <YayMe> MHD: You can likely combine those command facilities in a way to send stdout to stdin
15:24:34 <MHD> YayMe: I know that
15:24:44 <YayMe> rwbarton: No, you have standard | behavior though in windows command prompt
15:24:45 <MHD> Wait
15:25:08 <MHD> cmd </dev/stdout >/dev/stdin
15:25:30 <YayMe> right, something like that
15:25:40 <mapreduce> wouldn't that have to be cmd <1 >0 (never tried that)?
15:26:55 <MHD> mapreduct: no, the numbers go before the angle
15:27:26 <YayMe> no it would actually be  someCmd 0<&1
15:28:22 <tgeeky> 2>&1 is the weird one I need to remember
15:28:27 <geekosaur> http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/redirection.mspx?mfr=true
15:28:40 <geekosaur> looks  like a subset of bourne shell redirection syntax
15:29:36 <rwbarton> haha, it worked
15:30:54 <hpaste> rwbarton pasted “fixIO” at http://hpaste.org/75584
15:31:38 <alpounet> hahaha
15:31:48 <alpounet> fun
15:31:49 <YayMe> windows command prompt is not altogether horrible, granted it's no *nix shell in capabilities but largely it's abilities are unknown because majority of windows users never give a thought to the command prompt and people who do think about it don't waste their time in windows
15:31:57 <rwbarton> don't know how to write it in bash though
15:32:18 <rwbarton> none of the suggestions here worked
15:34:24 <rwbarton> tried with mkfifo also but I think it blocks because it opens the fifo for reading before opening it for writing
15:36:09 <typoclass> rwbarton: mkfifo makes things that are a bit special, afaik you can't just cat them or tail -f them, for example. what are you trying to do again?
15:36:24 <rwbarton> feed a unix process its own output as its input
15:36:44 <rwbarton> in bash
15:37:03 <Nereid> how perverse
15:37:43 <mcstar> lol
15:37:49 <mcstar> reminds me of a movie title
15:37:50 <mm_freak_> rwbarton: you can do that in zsh
15:38:02 <rwbarton> oh?
15:38:10 <rwbarton> the killer feature I've been waiting for
15:38:22 <Nereid> zsh is pretty awesome
15:38:24 <typoclass> rwbarton: uhm ... :) well i guess it wouldn't be very interesting anyway. bash for instance woult print the prompt to stdout, which it would read from its stdin, and then nothing *shrug*
15:38:36 <mm_freak_> however, writing a small program is probably better…  you might call it mfix =)
15:38:42 <rwbarton> http://hpaste.org/75584
15:38:46 <geekosaur> typoclass, the magic about fifos is the first open needs to be O_RDWR, which proper shells can do with <> redirections
15:38:52 <rwbarton> using your suggestion
15:40:58 <typoclass> geekosaur: hm ... all i know is occasionally i wanted to "just use tail -f" on a fifo that a process was using to talk to another process
15:41:17 <mm_freak_> typoclass: for a fifo you would just use cat
15:41:22 <mm_freak_> or tail without -f
15:42:08 <Nereid> is it bad that I've put stuff like ... | ([ -z $x ] && cat || grep $x) | ... in a pipeline?
15:42:38 <mm_freak_> why would it?  that's categorical programming =)
15:42:41 <Nereid> :)
15:45:04 <cads> hey guys, how happy is the haskell platform situation in centos?
15:45:29 <Cale> Nereid: Ever used bash at the end of or in the middle of a pipeline, with like, a sed before it to construct a script to run?
15:45:35 <jaxtr> it runs well on centos
15:45:45 <Nereid> Cale: haha.
15:45:48 <Nereid> no
15:45:59 <Cale> bash is the ultimate xargs
15:46:08 <mm_freak_> require (const (null pat)) <|> grep pat
15:46:09 <Nereid> what about zsh
15:46:15 <cads> jaxtr, have you worked with stuff that depends on gtk/cairo, etc?
15:46:23 <Cale> or, any shell in general is the ultimate xargs :P
15:46:32 <cads> like byorgey's diagram?
15:46:36 <cads> diagrams*
15:47:46 <cads> (the dependencies for the newest versions of those can be a bit painful in debian)
15:48:17 <Cale> I used to use zsh, but then bash pretty much caught up in terms of completion features, and I had less of a reason to switch to it.
15:48:41 <Cale> (on a fresh install)
15:48:51 <mm_freak_> it's not just completion features
15:48:56 <Cale> I know
15:49:00 <jaxtr> cads: it seems to work ok, but honestly i prefer to build from source....
15:49:13 <Cale> But for me, it was mostly the completion features which were the reason I was using it.
15:49:31 <mm_freak_> i find myself using find + xargs too much in bash
15:49:52 <mm_freak_> with zsh i think i haven't used find for years and xargs even longer
15:50:30 <cads> thanks for the vote of confidence, jaxtr
15:51:14 <Cale> I actually prefer to use a shell to xargs, because it means I can look at the script on the terminal easily before I commit to actually running it.
15:52:10 <mm_freak_> i prefer to write:  grep "blah" **/*(.)
15:52:11 <mm_freak_> =)
15:52:13 <dmwit> for i in **/*; echo complicated expression involving $i
15:52:15 <dmwit> ^echo
15:52:16 <rwbarton> you can replace the command to be run by echo
15:52:37 <dmwit> can't count how many times I have used those two lines (or very similar)
15:52:40 <rwbarton> or add echo depending on the situation, yeah
15:53:25 <mm_freak_> does bash support recursive searching by now?
15:53:39 <dmwit> Who cares?
15:54:21 <dmwit> Anyway, it doesn't seem to here.
15:54:30 <dmwit> ls **/* and ls */* do the same thing as far as I can tel.
15:55:34 <mm_freak_> to this day it seems like bash doesn't support the most basic stuff, although it might be related to the fact that it's really difficult to implement in C
15:56:02 <YayMe> Can someone give me some tips for just general haskell work organization; namely I'm starting a new little haskell project which will have parsec as a dependency, do you guys usually write a cabal file before or after writing some code?
15:56:17 <mm_freak_> YayMe: before
15:56:24 <mm_freak_> YayMe: cp -av skel my-project
15:56:29 <mm_freak_> cd my-project
15:56:38 <mm_freak_> mv skeleton.cabal my-project.cabal
15:56:39 <mm_freak_> make init
15:56:39 <mcstar> after
15:56:44 <mcstar> long after :)
15:56:45 <YayMe> mm_freak_: I really do need to install *nix onto that extra partition I have don't I?
15:57:19 <mm_freak_> YayMe: if you prefer windows, get MSYS from the mingw site
15:57:24 <dmwit> YayMe: Write a bit of code, then run "cabal init".
15:58:16 <YayMe> dmwit: can I import parsec/attoparsec and c-X c-L without writing a cabal file to identify that dependency first?
15:58:32 <rwbarton> sure
15:58:34 <dmwit> I don't know what c-X c-L do, but yes.
15:59:06 <YayMe> dmwit: reloads my file into the GHCI window in emacs
15:59:20 <dmwit> ghci doesn't touch cabal
15:59:36 <YayMe> dmwit: will ghci resolve my imports for me?
16:00:08 <jmcarthur> yes
16:00:17 <mm_freak_> FWIW there is the PackageImports extension, but when using cabal you shouldn't use it
16:00:26 <jmcarthur> but wont set up your cabal project
16:00:27 <mm_freak_> import "mtl >= 2.0" Control.Monad.Trans
16:00:32 <dmwit> What does "resolve my imports" mean?
16:01:04 <jmcarthur> i interpret that to mean "doesnt need an explicit package list"
16:01:05 <geekosaur> typoclass, that would not work as you would hope anyway; just like any other filehandle, if you have multiple processes reading from it at the same time each process gets some subset of the data
16:01:27 <Cale> YayMe: I would generally write a cabal file shortly before releasing code, but another good point to consider it is when your project starts getting more complicated to build than ghc --make
16:01:37 <geekosaur> the system doesn't automatically spawn a tee or wye command for you
16:03:01 <YayMe> Cale: I have no expectation of writing something in Haskell that is ever "released", I'm not that good heh, but you're advocating creating the cabal file after I write most of the code?
16:04:01 <Cale> YayMe: Well, yeah, there's not a whole lot of point in having a cabal file unless you're using cabal to build the project, which isn't generally necessary until it's fairly large. Most things can be compiled just by running ghc on the main .hs file.
16:04:29 <typoclass> geekosaur: oh, hm ... yeah, i guess there's a fundamental difference between a pipe, which is just something volatile by nature, and an actual file (e.g. there's no problem with multiple people doing tail -f on /var/log/something)
16:04:37 <geekosaur> right
16:04:37 <Polarina> I mainly use a cabal file in my small projects so that I don't have to repeat the language extensions in every file.
16:05:06 <typoclass> geekosaur: ... whether the pipe is some descriptors you created with pipe(), or something that has a name in the file system through mkfifo
16:05:13 <mm_freak_> Polarina: -XMyExtension
16:05:18 <geekosaur> a file's data is fairly fixed in place and differnet processes have their own pointers to locations within it; a pipe you're all working on the same small buffer
16:05:34 <geekosaur> (fifo is just that buffer with a filesystem node pointing at it)
16:05:34 <YayMe> Haskell feels like development in reverse to me, I often read/write haskell code lines right to left, when trying to write something I start with the tiny detail functions before growing up to the overarching design..
16:05:45 <Polarina> mm_freak_, very painful when cmd doesn't have command history, or you got 9 extensions you use.
16:05:49 <Cale> I prefer putting the LANGUAGE pragmas into the files
16:06:07 <mm_freak_> Polarina: write a Makefile
16:06:37 <mm_freak_> make ghci, make test, …
16:06:46 <YayMe> Given that I suppose it makes sense to write the code before the packaging files. In OOP all of those things are done in the opposite order
16:06:49 <geekosaur> some versions of linux may allow you to snoop on /proc/whatever/fds/N btw
16:06:56 <Polarina> mm_freak_, that'll work as well, and cabal works too, and isn't any more complex either. :)
16:07:06 <Cale> YayMe: You can of course start with the overarching design too, but as Philippa once suggested, a more reasonable approach is to build a sort of "path" from the large scale down to the small, and then sort of expand outward around that.
16:07:14 <Cale> (often)
16:07:22 <mm_freak_> Polarina: i usually use cabal together with a Makefile =)
16:07:33 <geekosaur> but even there you must be careful as the buffer's contents depend on real writer and reader and your snoop might miss stuff --- because again, the system doesnt clone anything for the convenience of snoops
16:07:35 <Polarina> mm_freak_, I noticed that. :)
16:07:56 <Cale> YayMe: But generally functional programming is often going to be about designing miniature languages in which the solution to the problem you're trying to solve is more easily expressed.
16:07:57 <dmwit> #include ALL_EXTENSIONS_LOL.H
16:08:02 <mm_freak_> Polarina: if even for being able to just use my editor's default keystroke for building ;)
16:08:11 <YayMe> Cale: Is it just my inexperience that has me starting at the small scale in haskell than building out do you think? In OOP I feel like you can't start at the small scale or else you will overrun your boundaries really fast
16:08:15 <Cale> YayMe: and those are going to consist of small pieces and combining operations
16:08:17 <dmwit> mm_freak_: :set makeprg
16:08:25 <Polarina> mm_freak_, Haha! Fair enough.
16:08:34 <mm_freak_> dmwit: how does that help emacs?
16:08:48 <dmwit> It causes you to rethink your poor life decisions.
16:08:51 <dmwit> ;-)
16:08:59 <mm_freak_> i don't follow
16:09:34 <Cale> YayMe: Well, I don't know. I think it's much more fun to write programs whose behaviour you can examine right away, and then piece those together into larger things.
16:09:43 <mm_freak_> if this is about inferior-haskell, i'm not using it, because i find it easier to have a separate shell
16:10:11 <Cale> YayMe: But that also doesn't mean that you have to have no idea what the large scale picture is going to look like when you're done. :)
16:10:38 <jmcarthur> YayMe: "I often read/write haskell code lines right to left"  <-- notably, evaluation still occurs left to right!
16:10:44 <Cale> YayMe: It can also be helpful to start out at the large scale and just start writing stuff in terms of imaginary definitions -- how would you like the code to look in an ideal world?
16:10:55 <YayMe> Cale: Yeah, it makes sense and is why I've been sticking with haskell after it clicked. In OOP you start by defining your boundaries, then as you fill in the functionality inside those boundaries you find out after a while where you effed up laying out the boundaries. But if you start at the small scale then try to see where your boundaries end up you'll be even worse because you'll find out you have no boundaries
16:12:02 <shachaf> nary a boundary
16:12:31 <jmcarthur> i think there are reasonable arguments for both bottom-up and top-down design. i usually do some sort of weird mix, starting somewhere in between
16:12:39 <milaz> I remember reading a paper comparing the style of beginning and experienced Haskell programmers
16:12:41 <Cale> YayMe: I think that after programming in Haskell for a while, you'll find that it is actually possible to write fairly reasonable OO code, but almost nobody does it, because the only way to write reasonable OO code is to impose restrictions on yourself that OO languages don't impose on you. :)
16:12:54 <milaz> it was regarding Aegis system
16:12:56 <jmcarthur> typically by designing a module top-down
16:13:42 <milaz> what was apparent, the inexperienced programmer started with lots of definitions and so on, while experienced one got right to the business
16:14:53 <jmcarthur> milaz: that makes me feel inexperienced
16:15:52 <milaz> jmcarthur: maybe that was just my impression, but also when I start with unfamilliar language/environment, I always take overlong time caring about these things
16:17:27 <YayMe> Nobody answered me earlier about ease of porting parsec code to attoparsec?
16:17:40 <jmcarthur> well, i think my approach depends on how familiar i am with the kind of task i'm doing, too, i guess
16:17:44 <YayMe> is it pretty straight forward or are there some significant differences in how you use the two packages?
16:17:45 <Cale> YayMe: How hard it would be would depend on the parser in question
16:17:56 <jmcarthur> but notably, not just on my familiarity with the language
16:18:03 <Cale> But the two packages are fairly similar in terms of how they name things...
16:18:44 <YayMe> The interfaces are fairly similar? I know underneath there's a significant conceptual difference in the way they approach the computation which made me wonder if the interfaces would be easily interchangeable
16:18:54 <jmcarthur> YayMe: approaches differ mainly in that with attoparsec you are typically thinking about performance a bit more, so you might favor a different set of combinators than you would in parsec
16:19:05 <Cale> Yeah, the interfaces are pretty similar
16:19:32 <jmcarthur> s/typically/probably/
16:19:35 <YayMe> Ok good enough. I ask because finding attoparsec tutorials and explanations has been a pain in the ass for me, but I've found countless parsec ones
16:19:47 <Cale> I haven't actually checked what stuff Attoparsec lacks relative to Parsec, but at the very least, being used as a monad transformer, and any type of stream other than strict bytestrings.
16:19:57 <Polarina> Is there a specific reason you really need the performance?
16:20:02 <YayMe> I figure if I start with parsec and the interfaces are similar enough I could always move it to attoparsec after I get comfortable with parsec
16:20:04 <jmcarthur> attoparsec supports Text
16:20:04 <Cale> YayMe: Parsing libraries are all designed very similarly
16:20:27 <Cale> (for the most part)
16:20:48 <Cale> YayMe: at least, the monadic ones :)
16:21:09 <YayMe> Polarina: I'm going to try writing something that parses an entire source code base, it can be a pretty significant amount of data to tear through so I don't need the performance but it may be noticable
16:22:10 <pnielsen> YayMe: what language?
16:22:13 <Cale> Oh, there is an Attoparsec for lazy bytestrings
16:22:25 <Cale> (and Text)
16:22:38 <pnielsen> I've been looking for Haskell parse tree/static analysis packages for various languages
16:23:46 <Polarina> YayMe, I've found that parsec is reasonably fast enough for most tasks, unless you depend on those special things in attoparsec that actually make it that much faster (take, drop, etc.). I haven't used attoparsec for anything significant myself though, so assume my opinion biased. :)
16:24:35 <Cale> The other thing you'd want Attoparsec for is if you needed resumable parsing
16:24:44 <Polarina> And that.
16:24:48 <Cale> like, if you may or may not have the entire stream
16:25:10 <Cale> and you want to be able to parse what you have, and if you find out it's not everything, being able to continue where you left off when you get more
16:26:57 <hpaste> newbiie pasted “list function” at http://hpaste.org/75588
16:27:53 <milaz> jmcarthur, YayMe: finally, i found that paper: http://www.cs.yale.edu/publications/techreports/tr1031.pdf
16:29:51 <Polarina> newbiie, you need { getFirst [] = "" } before { getFirst (h:t) = ... }.
16:30:08 <Polarina> newbiie, (h:t) doesn't pattern match on an empty list.
16:30:49 <milaz> newbiie: why won't you use patterns instead all of these if/else constructs?
16:31:50 <newbiie> polarina ok that solve the error problem but still couldn't get it to show as one string instead of list
16:32:02 <newbiie> milaz how to?
16:32:06 <YayMe> pnielsen: Starting with C# because I know it inside-out, but I've for years wanted to put together something that allows we enterprisey folks to restructure our entire code bases/output product by object representation rather than file representation. Though that's a pipe dream I'll never achieve, ever since learning Haskell it seems like something worth poking towards. Starting by creating a C# parser of sorts
16:32:46 <milaz> newbiie: you can match against constants, not only variables
16:33:21 <hpaste> Polarina pasted “getFirsts” at http://hpaste.org/75589
16:33:26 <pnielsen> YayMe: sounds very similar to what I've been thinking of
16:33:34 <pnielsen> YayMe: hope you open source it :)
16:34:05 <YayMe> pnielsen: If I ever productize anything it'll be under the "Free for personal use but expensive for corporate use" style
16:34:18 <pnielsen> cool
16:34:40 <Polarina> newbiie, that's how you can use only pattern matching.
16:35:41 <milaz> > concat $ map (take 1) ["How", "Are", "You","?"]
16:35:42 <lambdabot>   "HAY?"
16:35:48 <milaz> or this way ;)
16:35:55 <YayMe> pnielsen: I've finished very few things I've started. So don't hold you're breath ;)
16:36:11 <pnielsen> heh, ditto
16:36:24 <Polarina> milaz, :)
16:36:55 <milaz> I adore higher-order functions
16:37:13 <hpaste> MHD pasted “getFirsts” at http://hpaste.org/75590
16:39:29 <milaz> What's beautiful, such short soultion handles empty list, and empty strings in it correctly
16:40:16 <newbiie> milaz thanks, it works beautifully.
16:40:17 * Polarina finds Haskell to be too powerful at times.
16:40:23 <newbiie> lol
16:40:28 <copumpkin> this much power cannot be wielded by mere mortals
16:40:32 <newbiie> key words "at times"
16:41:43 <YayMe> can anybody direct me to the best parsec learning sources they've used?
16:41:58 <hpc> YayMe: honestly, the docs on hackage are very good
16:42:13 <hpc> there's also the RWH chapter
16:42:15 <YayMe> hpc: Ok, I'll start there :) Hackage really is amazing so I'm not surprised
16:42:26 <hpc> but that's going to be slightly outdated
16:42:27 <YayMe> oo good to know, I still haven't read RWH (shame on me..)
16:42:57 <hpc> RWH isn't something you read, per se; when you need something, you read one of the later chapters to learn that specific thing
16:43:10 <hpc> i haven't read RWH either :P
16:43:12 <newbiie> hey milaz how do you declare the type of a function that takes two functions and return a function
16:43:13 <newbiie> ?
16:43:45 <milaz> YayMe: this was most helpful when I learned Parsec: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
16:44:32 <Polarina> newbiie, what do you want to achieve? It depends on what you want it to do.
16:45:04 <Polarina> newbiie, one example is :: (a -> b) -> (b -> c) -> (a -> c)
16:45:20 <milaz> newbiie: for example, (b -> c) -> (a -> b) -> a -> c
16:45:39 <hpc> ?type \f g x -> f (g x)
16:45:40 <lambdabot> forall t t1 t2. (t1 -> t2) -> (t -> t1) -> t -> t2
16:45:43 <newbiie> for example if the function is a maxfunction that take two other functions and return the max function of the two
16:45:46 <YayMe> milaz: Thanks! There's so many bad explanations of things on the internet, it's always good to get a suggested resource :)
16:46:03 <YayMe> newbiie: How do you compare 2 functions?
16:46:04 <milaz> YayMe: you are welcome
16:46:10 <avpx> YayMe: I think he means pointwise
16:46:43 <newbiie> ex. (maxFunc sqrt succ) 4 would return succ since succ 4 is bigger
16:46:53 <milaz> YayMe: but as I remember, I have to make some adjustments to this tutorial so it match the current version of Parsec
16:46:53 <YayMe> ah
16:47:32 <Polarina> newbiie, :: (a -> b) -> (a -> b) -> a -> b
16:47:39 <XexonixXexillion> a type something like (Ord b) => (a -> b) -> (a -> b) -> a -> (a -> b)
16:47:41 <shachaf> Hah, cps f = (. f)
16:47:41 <avpx> newbiie: I'm guessing that'd look something like Ord a => (b -> a) -> (b -> a) -> b -> a
16:47:46 <shachaf> Whereas theotherthing f = (f .)
16:47:51 <shachaf> @pl ((. f) . (. g) . (. h)) id
16:47:52 <lambdabot> h . g . f
16:48:03 <monochrom> theotherthing?
16:48:03 <YayMe> f g h x = max (g x) (h x)
16:48:35 * YayMe smells the s combinator in his implementation, but still stinks at using combinators
16:48:46 <Nereid> @type liftA2 max
16:48:47 <lambdabot> forall a (f :: * -> *). (Ord a, Applicative f) => f a -> f a -> f a
16:48:58 <Nereid> (specialize to f = (t ->)
16:49:12 <newbiie> great thanks all
16:49:27 <hpc> YayMe: there's also `on`
16:49:41 <hpc> which instead of (g x) vs (h x) would be (g x) vs (g y)
16:50:37 <Nereid> @type on max
16:50:38 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> b
16:51:00 <avpx> @pl \g h x -> max (g x) (h x)
16:51:01 <lambdabot> liftM2 max
16:51:06 <YayMe> ahh
16:51:10 <avpx> That makes sense.
16:51:14 <Nereid> I did say liftA2 max earlier.
16:51:20 <avpx> I was thinking there was a way to use the ((->) e) monad
16:51:37 <avpx> Nereid: Ah, I missed that, sorry
16:51:46 <YayMe> hpc: that is not what he was asking for though now that I see tha type and understand the purpose (i think?)
16:52:05 <YayMe> @type on
16:52:06 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:52:39 <YayMe> nevermind, I don't understand on
16:52:51 <hpc> @src on
16:52:51 <lambdabot> (*) `on` f = \x y -> f x * f y
16:52:59 <Nereid> somethign you often do is
16:53:02 <Nereid> @type (compare `on`)
16:53:03 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
16:53:10 <Nereid> or so
16:53:24 <c_wraith> :t comparing
16:53:26 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:53:28 <hpc> @type compare `on` abs
16:53:29 <lambdabot> forall a. (Ord a, Num a) => a -> a -> Ordering
16:53:44 <Nereid> @type compare `on` fst
16:53:45 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
16:53:48 <Nereid> but yes, comparing is the same.
16:54:15 <hpc> > let comp = compare `on` abs in sortBy comp [1, 2, 3, -1, -2, -3]
16:54:17 <lambdabot>   [1,-1,2,-2,3,-3]
16:54:46 <latro`a> sortBy is stable?
16:54:53 <hpc> dunno
16:54:58 <hpc> probably coincidence
16:55:14 <latro`a> > let comp = compare `on` abs in sortBy comp [-1,1,2,3,-2,-1,-3,3]
16:55:17 <lambdabot>   [-1,1,-1,2,-2,3,-3,3]
16:55:31 <hpc> looks like yes
16:55:33 <latro`a> seems stable yeah
16:55:49 <monochrom> IIRC it's required to be stable
16:56:16 <Nereid> > sortBy (const EQ) [1..10]
16:56:16 <lambdabot>   Couldn't match expected type `a -> GHC.Ordering.Ordering'
16:56:17 <lambdabot>         against i...
16:56:19 <Nereid> oops.
16:56:29 <Nereid> > sortBy (const (const EQ)) [1..10]
16:56:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:56:30 <WhoNeedszzz> Hey again
16:56:45 <monochrom> yeah, Haskell 2010 section 20.9.3 "The sort function implements a stable sorting algorithm."
16:56:48 <WhoNeedszzz> How would you split a string into two lists, one with the numbers in the list and everything else in the other list?
16:56:55 <gtmanfred> vodik: \o/
16:57:01 * monochrom loves quoting Haskell 2010 on all of you!
16:57:05 <Nereid> WhoNeedszzz: partition
16:57:22 <Nereid> @type partition
16:57:23 <newbiie> hmmm...
16:57:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:57:30 <newbiie> maxFunc :: Ord b => (a -> b) -> (a -> b) -> a -> b
16:57:41 <Nereid> @partition (< 5) [1,5,87,9,3,2,6,3]
16:57:41 <lambdabot> Unknown command, try @list
16:57:45 <Nereid> > partition (< 5) [1,5,87,9,3,2,6,3]
16:57:46 <lambdabot>   ([1,3,2,3],[5,87,9,6])
16:58:17 <latro`a> that's anti-stable iirc
16:58:21 <WhoNeedszzz> so how would you say about numbers in general?
16:58:24 <latro`a> since it puts the front toward the end of the list
16:58:42 <Nereid> WhoNeedszzz: ??
16:58:51 <newbiie> when I make the call (maxFunc sqrt succ) 4, it gave me the value 5 instead of the function succ
16:58:59 <WhoNeedszzz> How would you split a string into two lists, one with the numbers in the list and everything else in the other list?
16:59:05 <newbiie> how do i get it to return the function instead of just the value
16:59:06 <newbiie> ?
16:59:07 <monochrom> every item in the same list has the same type
16:59:12 <latro`a> idr if there is a maxBy
16:59:15 <latro`a> :t maxBy
16:59:15 <Nereid> @type partition isDigit
16:59:17 <lambdabot> [Char] -> ([Char], [Char])
16:59:17 <lambdabot> Not in scope: `maxBy'
16:59:21 <latro`a> but it'd be something like maxBy
16:59:25 <Nereid> WhoNeedszzz: like that?
16:59:35 <monochrom> if the list has at least one number, every other item is also a number
16:59:51 <monochrom> so, to literally answer your question, split xs = (xs, [])
17:00:04 <mm_freak_> newbiie: the function you're looking for probably has a different type
17:00:10 <milaz> :t Data.List.maximumBy
17:00:11 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:00:18 <mm_freak_> newbiie: (Ord b) => (a -> b) -> (a -> b) -> a -> a -> b
17:00:29 <YayMe> what makes a parser "combinator" ? just that it's chainable in a "fluent" style?
17:00:29 <Nereid> funny there's no maxBy.
17:01:01 <milaz> let maximumFunc = maximumBy (compare `on` ($4)) [(+1), (+2), (*10)]
17:01:02 <Nereid> maxBy x y = case cmp x y of {GT -> x; _ -> y}
17:01:10 <Nereid> er
17:01:14 <Nereid> maxBy cmp x y = ...
17:01:28 <Nereid> @let maxBy c x y = case c x y of {GT -> x; _ -> y}
17:01:30 <lambdabot>  Defined.
17:01:34 <hpc> YayMe: it's a function that takes a parser or whatever as a parameter
17:01:38 <Nereid> @type maxBy
17:01:39 <lambdabot> forall t. (t -> t -> Ordering) -> t -> t -> t
17:01:52 <hpc> :t many -- YayMe
17:01:53 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
17:02:26 <WhoNeedszzz> It says partition is out of scope
17:02:40 <newbiie> freak got an error what i try to declare that "unification would give infinite type"
17:02:45 <hpc> well, for parsers, (many parseElem) = (parse parseElem a bunch of times until you fail, returning the list of results)
17:02:56 <Nereid> WhoNeedszzz: Data.List
17:03:05 <mm_freak_> newbiie: a function with the type you gave does not return a function, but a value
17:03:13 <mm_freak_> newbiie: the function you want has a different definition
17:03:52 <mm_freak_> maxFunc f g x = if f x > g x then f else g
17:04:03 <mm_freak_> :t \f g x = if f x > g x then f else g
17:04:04 <lambdabot> parse error on input `='
17:04:08 <mm_freak_> :t \f g x -> if f x > g x then f else g
17:04:09 <lambdabot> forall t a. (Ord a) => (t -> a) -> (t -> a) -> t -> t -> a
17:05:07 <YayMe> as someone who stinks at this haskell thing still I find trying to define my sigs ahead of time I usually get them wrong where the languages inference knows what I want better than me..
17:05:36 <YayMe> Does that tend to change at some point?
17:05:38 <Nereid> @let maxFunc f g x = if f x > g x then f else g
17:05:40 <lambdabot>  Defined.
17:05:57 <Nereid> > maxFunc sqrt succ 5 2
17:05:59 <lambdabot>   3.0
17:06:07 <YayMe> Nereid: Why not just use max (f x) (g x) ?
17:06:09 <milaz> by the way, how long do lambdabot definitions live?
17:06:11 <Cale> YayMe: mostly
17:06:16 <Nereid> YayMe: because we want the function, not the value
17:06:24 <Nereid> milaz: until someone writes @undefine
17:06:50 <Cale> YayMe: There are still things with sufficiently fancy types where the compiler is better than me at discovering the type, but generally I know what the types of things are when I write them.
17:07:05 <newbiie> nereid using maxFunc f g x = if f x > g x then f else g still got the value not the function
17:07:11 <YayMe> Nereid: oh oops then snd $ max (f x, f) (g x, g)
17:07:15 <Nereid> newinot true
17:07:18 <Nereid> newbiie: not true
17:07:23 <Nereid> YayMe: heh.
17:07:30 <YayMe> No?
17:07:32 <monochrom> "then f else g" how is f or g not a function?
17:07:33 <Nereid> sure.
17:08:03 <Nereid> > maxFunc (2*) (1+) 0 100
17:08:05 <lambdabot>   101
17:08:06 <Nereid> > maxFunc (2*) (1+) 10 100
17:08:08 <mm_freak_> perhaps newbiie has enabled the OverloadedFunctionApplication extension =)
17:08:08 <lambdabot>   200
17:08:12 <Polarina> :t \f g x -> if f x > g x then f else g
17:08:13 <lambdabot> forall t a. (Ord a) => (t -> a) -> (t -> a) -> t -> t -> a
17:08:22 <hpc> mm_freak_: oh god, if that exists...
17:08:37 <luksow> is there anything wrong with handling Data.Either using Data.Either.Unwrap and its functions isLeft/isRight formLeft/fromRight?
17:09:02 <latro`a> > (\f g x -> if f x > g x then f else g) (+1) (-1) 2
17:09:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:09:04 <lambdabot>    arising from a use of `...
17:09:07 <mm_freak_> luksow: 'either' is usually a better choice
17:09:12 <latro`a> err...oh
17:09:15 <latro`a> > (\f g x -> if f x > g x then f else g) (+1) (-1) 2 1
17:09:16 <lambdabot>   2
17:09:23 <YayMe> Cale: But it's safe to say over my lifetime as a haskeller I can only hope to know *as* well as the compiler what my sigs should look like?
17:09:25 <Polarina> mm_freak_, these overloading extensions are about to go too far... :/
17:09:28 <Nereid> > (\f g x -> if f x > g x then f else g) (+1) (subtract 1) 2 1
17:09:29 <lambdabot>   2
17:09:37 <Nereid> latro`a: you got saved by caleskell
17:09:43 <Nereid> where (-1) = const (-1)
17:09:44 <latro`a> so I did
17:09:57 <mm_freak_> Polarina: we have only two of them, what's the matter?
17:10:04 <Cale> YayMe: Pretty much.
17:10:10 <mm_freak_> and in fact i'd love to see OverloadedLists at some point
17:10:15 <monochrom> isLeft/isRight formLeft/fromRight have very little value in a language supporting pattern matching (haskell, sml). they belong to lisp
17:10:19 <Cale> YayMe: I suppose there are some cases where you'll know better than the compiler too :)
17:10:21 <Polarina> mm_freak_, it's fine now -- people seem to be going on a spree to "invent" thousands more soon.
17:10:32 <Cale> YayMe: but only once you get past HM types
17:10:35 <newbiie> ERROR - Cannot find "show" function for: //  *** Expression : maxFunc sqrt succ 4 //*** Of type    : Double -> Double
17:10:45 <mm_freak_> Polarina: just because snoyman proposed OverloadedLists recently =)
17:10:51 <Nereid> newbiie: well duh, you can't show a function
17:10:55 <YayMe> Cale: You mean like when dealing with FFI?
17:11:04 <WhoNeedszzz> How would you find common chars of two strings and output a string containing the common chars?
17:11:08 * pnielsen wonders if anybody in the security/fuzzing industry has heard about QuickCheck
17:11:12 <milaz> newbiie: you can bind it to a name and call
17:11:13 <Cale> YayMe: I mean when dealing with things like GADTs and higher rank types
17:11:20 <luksow> monochrom, but creating many simple one-line functions just to use pattern matching generates code-noise :)
17:11:37 <monochrom> Double->Double functions cannot be printed, that's right. don't ask to print them.
17:12:01 <Nereid> @let sample f = map .
17:12:01 <lambdabot>   Parse error in expression: map .
17:12:07 <Nereid> eh
17:12:08 <shachaf> monochrom: Sure they can, given enough paper.
17:12:09 <mm_freak_> luksow: i don't get it…  pattern matching saves code
17:12:17 <monochrom> the "case" expression saves you one-line functions.
17:12:17 <mm_freak_> luksow: and if you don't like pattern matching, then fold
17:12:21 <Nereid> @let sample f = map (f $)
17:12:22 <lambdabot>  Defined.
17:12:25 <mm_freak_> 'either' is a fold on Either
17:12:26 <Nereid> @sample id [1..3]
17:12:26 <lambdabot> Unknown command, try @list
17:12:29 <Nereid> > sample id [1..3]
17:12:31 <lambdabot>   [1,2,3]
17:12:32 <YayMe> Cale: ok so GHC knows everything about HM types, but that's because they are determinable where haskell has other forms of types which are not?
17:12:35 <newbiie> hmmm...
17:12:36 <Cale> YayMe: There's a type system which Haskell's type system is built off of, called the Hindley-Milner type system. Every program which is allowed in that type system can have a unique most general type inferred, called its principal type.
17:12:43 <Cale> YayMe: yeah
17:12:43 <shachaf> newbiie: (f $), eh?
17:12:45 <mm_freak_> > either (const True) (const False) (Left 3)
17:12:45 <Nereid> > sample (maxFunc (+1) (*2) 4) [1..3]
17:12:46 <lambdabot>   True
17:12:47 <lambdabot>   can't find file: L.hs
17:12:55 <Nereid> > sample (maxFunc (+1) (*2) 0) [1..3]
17:12:58 <lambdabot>   [2,3,4]
17:12:59 <Nereid> > sample (maxFunc (+1) (*2) 4) [1..3]
17:13:01 <lambdabot>   [2,4,6]
17:13:07 <Cale> The extensions to that type system don't have complete type inference, and so you end up needing to know better than the compiler what you mean.
17:13:08 <shachaf> @let sample' = map
17:13:09 <YayMe> Cale: Yeah, I read a little about HM types when realizing that was a term for the type system it's mostly based off of
17:13:10 <lambdabot>  Defined.
17:13:18 <Cale> This is also true of typeclasses, actually
17:13:21 <Nereid> shachaf: haha.
17:13:26 <Nereid> I'm dumb.
17:13:43 <Cale> You can create ambiguously typed expressions using, say, read and show :)
17:13:50 <hpc> on the bright side, the compiler still knows when to ask you for help
17:14:14 <Nereid> @type read . show
17:14:15 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
17:14:37 <Nereid> @type show . read
17:14:39 <lambdabot> String -> String
17:14:47 <Nereid> > show . read $ "10"
17:14:49 <lambdabot>   "*Exception: Prelude.read: no parse
17:15:02 <YayMe> Cale: Read yes, I have to tell it what I want so I understand there, but show I don't see that as one where I would ever know better than GHC?
17:15:12 <Nereid> > (show :: Int -> String) . read $ "10"
17:15:12 <milaz> show . read $ "\"10\""
17:15:14 <lambdabot>   "10"
17:15:20 <milaz> > show . read $ "\"10\""
17:15:21 * Polarina would rather use quasiquotes than Overloaded* extensions.
17:15:23 <lambdabot>   "*Exception: Prelude.read: no parse
17:15:25 <hpaste> Polarina pasted “Multi-line strings” at http://hpaste.org/75592
17:15:33 <newbiie> the return function should be of the maximally general type.  So, there's no way you can bind the function to a name and show which function it is that is max of the two?
17:15:58 <hpc> Polarina: i try to just use short names for the conversion functions
17:16:01 <mm_freak_> newbiie: you can't show functions in general
17:16:10 <shachaf> newbiie: I think you should go back a few chapters in whatever introduction to Haskell you're using and read it again before you get to using "return".
17:16:24 <Cale> YayMe: I mean, you can compose those two together :)
17:16:37 <Nereid> > return 1 2
17:16:38 <lambdabot>   1
17:16:41 <shachaf> "return" is pretty complicated compared to other functions. :-) It returns a polymorphic value and all that.
17:16:46 <mm_freak_> newbiie: i guess you want to show the name of the function, which is impossible as a pure function
17:16:51 <monochrom> "maximally general type" and "print the function" are unrelated
17:17:16 <luksow> mm_freak_, but suppose I have a function fff that calls another function ggg and gets Either [X] Y, and it have to return true if some elem is in [X] and false if not (or Left is returned previously)... creating another function hhh just to do pattern matching on the result from ggg is bad idea in my opinion
17:17:22 <mm_freak_> so you probably want:  unsafeGetFunctionName :: (a -> b) -> IO String
17:17:26 <luksow> but I agree either would work great in this case
17:17:42 <monochrom> I already said, "case" expression for that
17:17:57 <Nereid> or type NamedFunction a b = (String, a -> b)
17:18:03 <mm_freak_> luksow: use Right for results and Left for exceptions
17:18:13 <milaz> > return 1 :: [Int]
17:18:14 <lambdabot>   [1]
17:18:16 <mm_freak_> luksow: notice that 'Either e' is a monad with exception type e
17:18:20 <luksow> yes, of course, just an example
17:18:26 <monochrom> > case Right 4 of { Left x -> "left"; Right y -> show (y + 1) }
17:18:27 <lambdabot>   "5"
17:18:32 <monochrom> no hhh here
17:18:37 <Cale> YayMe: Consider something like: show . read :: (Show a) => String -> String, where the type variable no longer appears in the type, and so it's inherently ambiguous (unless you have GHCi's extra strong defaulting! ;)
17:18:40 <YayMe> Damn I wish I had a white board at home.. a big one..
17:18:54 <luksow> monochrom, nice!
17:19:01 <BMeph_> YayMe: You and Munroe... ;)
17:19:04 <YayMe> Cale: Yeah, I get that, but that's an affect of read not particularly show
17:19:12 <mm_freak_> luksow: pattern matching is the lowest level…  it's often appropriate directly, but in some cases you want something higher level like a fold or some other kind of combinator
17:19:44 <mm_freak_> in any case, unsafe stuff (impartial pattern matches) is always a bad choice
17:19:49 <mm_freak_> Bool is most often a bad choice
17:19:59 <mm_freak_> and you're using both, when you use isRight/fromRight =)
17:20:19 <hpc> Cale: does the rewrite engine kick in before typechecking? you could do some really evil stuff there
17:20:22 <YayMe> Cale: I defined AtoP in something I did was (*) . (read :: Int) and it's due to read not (*)
17:21:09 <luksow> thanks, useful remarks
17:22:00 <milaz> newbiie: not all functions have names
17:22:08 <milaz> in fact, function do not have names
17:22:22 <milaz> thay are just bound to some... um... variables
17:22:42 <monochrom> some of them are never bound to variables/names
17:22:51 <newbiie> i see
17:22:53 <hpc> take something like
17:23:12 <mm_freak_> newbiie: functions may not even exist in memory
17:23:16 <hpc> let max x y = (the usual definition) in max 5 4
17:23:22 <hpc> there's the function max
17:23:26 <shachaf> @let sam = min
17:23:27 <lambdabot>  Defined.
17:23:29 <monochrom> if you go "(\x -> x + 1) 5", that function is like plastic fork, you use it and throw it away, no name
17:23:46 <hpc> but there's also the fact that max is curried, so it's really defined something like
17:23:55 <hpc> max = \x -> \y -> ...
17:23:56 <newbiie> \x here is anonymous function
17:24:00 <mm_freak_> the misconception is that functions in haskell work like functions in C =)
17:24:04 <hpc> so \y -> ... is a function
17:24:20 <mm_freak_> i.e. separate units of code, which can be CALLed
17:24:27 <hpc> and (max 5) is a function
17:24:37 <mm_freak_> that's not how functions work in haskell (with GHC at least)
17:24:47 <YayMe> newbiie: think of it like this: In haskell, every function is anonymous. You just have assigned some of them to variables.
17:24:53 <hpc> so in that example, not even half of functions have names :P
17:25:21 <WhoNeedszzz> How would you check if the characters in str1 appear in the same order as str2?
17:25:25 <mm_freak_> hpc: notice that techically it's a single function, if you write it like "max x y ="
17:25:27 <newbiie> so if the question is given two function say sqrt and succ and applied those to a value, which function provide the bigger value?  How would you write that in Haskell?
17:25:31 <pnielsen> I liked this bit on currying: http://osdir.com/ml/beginners@haskell.org/2012-09/msg00208.html
17:25:39 <mm_freak_> hpc: at least with GHC
17:25:58 <hpc> mm_freak_: pfffsh, operational details
17:26:06 <YayMe> newbiie: max = \x -> \y -> | y > x = y | otherwise = x -- anonymous function as you said, but you have a variable to reference it by.
17:26:13 <mm_freak_> newbiie: maxFunc f g x = if f x > g x then f else g
17:26:42 <mm_freak_> hpc: which are relevant to newbiie's question
17:26:49 <mm_freak_> getFunctionName :: (a -> b) -> IO String
17:26:53 <mm_freak_> sorry
17:26:56 <mm_freak_> unsafeGetFunctionName :: (a -> b) -> IO String
17:27:46 <newbiie> but if you call it like maxFunc sqrt succ 4 for example the system return an error for "not able to show function"
17:27:56 <mm_freak_> newbiie: because you can't show functions
17:28:04 <mm_freak_> for the reasons we just explained =)
17:28:04 <YayMe> newbiie: No, GHCI returns that error because functions cannot be shown
17:28:15 <mzero> newbiie: what are you trying to do with the function, once you pick the one that generates the larger result?
17:28:22 <milaz> newbiie: you still can bind it to a variable and call it
17:28:26 <WhoNeedszzz> How would you check if the characters in str1 appear in the same order as str2?
17:28:26 <mzero> do you really want to print out the functions' name?
17:28:28 <mm_freak_> newbiie: try:  let f = maxFunc sqrt succ 4 in f 3
17:28:32 <newbiie> return to let user know which one is more?
17:28:35 <mzero> or do you then want to apply it to some other value>?
17:28:41 <newbiie> display it
17:28:43 <YayMe> newbiie: you can definitely get that function, it just doesn't implement a .ToString() or .to_s or whatever language you're used to type of showing function
17:28:48 <hpc> WhoNeedszzz: you mean check if the strings are equal?
17:28:50 <mm_freak_> newbiie: but that's the same as: maxFunc sqrt succ 4 3
17:28:52 <mm_freak_> because of currying
17:28:53 <WhoNeedszzz> hpc, no
17:28:55 <mzero> well, you can't - you have to give it a name, so consider this
17:29:29 <WhoNeedszzz> hpc, use str1's characters and check if str2 has those characters in that order, but can have other characters in between
17:29:44 <WhoNeedszzz> For instance "hello" and "hdsessllo" would return true
17:29:47 <YayMe> newbiie: You want this: f (g,gn) (h,hn) x = snd $ max (g x, gn) (h x, hn)
17:29:59 <mm_freak_> newbiie: you could do something like:  data NamedFunc name a b = NamedFunc name (a -> b)
17:30:00 <mzero> > let maxFunc (f, fn) (g, gn) x = if (f x > g x) then fn else gn in maxFunc ((*2), "double") ((+10), "plus ten") 8
17:30:01 <lambdabot>   "plus ten"
17:30:12 <mzero> > let maxFunc (f, fn) (g, gn) x = if (f x > g x) then fn else gn in maxFunc ((*2), "double") ((+10), "plus ten") 12
17:30:13 <lambdabot>   "double"
17:30:34 <Polarina> instance Show (a -> b) where { show = const "a function"; }
17:30:49 <mzero> or YayMe's version - which is who I'd write it
17:30:54 <hpc> WhoNeedszzz: oooh
17:31:18 <newbiie> mzero in this case, you actually have to give it a name manually
17:31:24 <mzero> exactly
17:31:25 <monochrom> I am not sure why you insist on displaying a function. not to say it can't be done in theory, but no haskell interpreter/compiler does it so far. this probably reflects how much value it has in most haskellers' minds
17:31:31 <newbiie> what if the user just enter two function that you don't know
17:31:40 <Nereid> newbiie: then you can't
17:31:42 <newbiie> the function is supposed to take in two functions
17:31:46 <Nereid> mm_freak_: funny, that's exactly what I'm looking at now. writing various instances and whatnot.
17:31:50 <newbiie> as parameters
17:31:56 <mzero> the same is true in many other languages - the name you use to reference a function isn't actually a property of the function itself
17:31:58 <newbiie> ok
17:32:03 <newbiie> i understand the concept
17:32:05 <newbiie> lol
17:32:10 <mm_freak_> Nereid: it's a Category, if 'name' is a monoid =)
17:32:13 <milaz> newbiie: how do user enter two functions?
17:32:28 <hpc> WhoNeedszzz: what you do is, you get "hello" and "hdsessllo", so you start with 'h', see it at the start of "hdsessllo", and step forward
17:32:30 <Nereid> mm_freak_: yeah
17:32:31 <mm_freak_> id = NamedFunc mempty id
17:32:33 <Nereid> I'm just looking at name = String.
17:32:40 <monochrom> it seems to me that the sole operation most people just want for a function is: call it with a parameter
17:32:42 <Nereid> so we can have meaningful names.
17:32:51 <hpc> you see the 'e' in "ello" is a ways forward in "dsessllo"
17:32:58 <newbiie> at main> the user type in "(maxFunc sqrt exp) 4"
17:33:02 <mm_freak_> NamedFunc n2 f . NamedFunc f1 g = NamedFunc (n1 <> n2) (f . g)
17:33:04 <WhoNeedszzz> hpc, code?
17:33:13 <Nereid> mm_freak_: yeah.
17:33:14 <WhoNeedszzz> hpc, I don't know how to traverse in haskell
17:33:25 <monochrom> anyway, I think the usual python interpreter doesn't display functions either
17:33:30 <newbiie> the function then take sqrt and exp and bind it to the two parameters for functions
17:33:40 <mm_freak_> monochrom: it doesn't, but it does display an address
17:34:01 <milaz> newbiie: let's imagine that one step earlier, user entered "let s = sqrt"
17:34:17 <milaz> newbiie: and then (maxFunc s exp) 4
17:34:31 <hpc> :t let sameish [] _ = True; (c:cs) [] = False; (c:cs) (t:ts) | c == t = sameish cs ts | otherwise = sameish (c:cs) ts in sameish
17:34:32 <lambdabot> Parse error in pattern
17:34:38 <hpc> :t let sameish [] _ = True; (c:cs) [] = False; (c:cs) (t:ts) | c == t = sameish cs ts; | otherwise = sameish (c:cs) ts in sameish
17:34:39 <lambdabot> Parse error in pattern
17:34:43 <hpc> dammit
17:34:50 <Nereid> mm_freak_: for user-defined functions, yes. it shows something else for built-ins or lambdas
17:34:57 <hpc> :t let sameish [] _ = True; (c:cs) [] = False; sameish (c:cs) (t:ts) | c == t = sameish cs ts; | otherwise = sameish (c:cs) ts in sameish
17:34:58 <lambdabot> Parse error in pattern
17:35:03 <Nereid> wait.
17:35:13 <mm_freak_> indeed
17:35:18 <mm_freak_> >>> print
17:35:18 <mm_freak_> <built-in function print>
17:35:19 <Nereid> yeah, for user-defined functions it shows a name and address
17:35:21 <milaz> newbiie: sorry, "(maxFunc s (-100)) 4" better. So, what should the function return then: "s" or "sqrt"?
17:35:23 <Nereid> for lambdas the name is just <lambda>
17:35:43 <milaz> newbiie: Javascript in this case prints the source code for the function, by the way
17:35:50 <milaz> if it can
17:36:38 <milaz> because otherwise you are willing to print the name of the variable passed into maxFunc
17:36:39 * BMeph_ asks javascript: But what about encapsulation? Reply: lol wut
17:36:43 <newbiie> well s is a pointer to sqrt right?
17:36:58 <mm_freak_> newbiie: no, it /is/ sqrt
17:37:09 <mm_freak_> newbiie: in haskell x = y is an equation
17:37:16 <milaz> newbiie: sqrt is a pointer to a real function
17:37:25 <mm_freak_> no, it's not
17:37:29 <mm_freak_> forget the word "pointer", please
17:37:32 <milaz> newbiie: and s is a pointer to the same function
17:37:36 <mm_freak_> sqrt is a function, period
17:37:48 <newbiie> which you cannot display the name of
17:37:49 <milaz> how would we decide if one name is better than another?
17:38:07 <newbiie> since sqrt is not of type show
17:38:08 <mm_freak_> otherwise newbiie will ask why you can't display the pointer, at which point we will have to start all over again =)
17:38:16 <mm_freak_> show is not a type
17:38:36 <newbiie> o...k.....
17:38:58 <mm_freak_> newbiie: to see the problem try to write your own function 'getFunctionName'
17:38:59 <avpx> Show a is a class constraint.
17:39:48 <Nereid> unsafeCoerce :: a -> Ptr b  -- there's your pointer!
17:40:10 <EvanR2> show . unsafeCoerce
17:40:12 <EvanR2> lol
17:40:14 <milaz> Nereid: one step further, and we can show hardware address for it
17:40:27 <milaz> victory! :)
17:41:26 <WhoNeedszzz> hpc, i'm dumb. I can use the function i just made to do it really easy: http://ideone.com/UC9op
17:41:51 <hpc> oh, that works
17:42:27 <WhoNeedszzz> yeah i'm silly sometimes
17:42:35 * BMeph_ tries: (show . unsafeCoerce) highSchoolGirl...
17:43:28 <mzero> WhoNeedszzz: that doesn't look like it will do what you asked about earlier
17:43:43 <mm_freak_> unwantedChildren = unsafePerformIO sex
17:43:45 <WhoNeedszzz> mzero, It does
17:43:47 <mzero> consider   "abc" and "dcba"
17:43:56 <mzero> should that be true?
17:44:11 <hpc> mm_freak_: unsafePerformIO, if you know what i mean?
17:44:19 <mm_freak_> ;)
17:44:24 <WhoNeedszzz> mzero, oh dang you're right
17:44:50 <mzero> think of it this way: Your predicate relies on ordering ... hence a relation on sets (intersect) can't possible be right
17:45:07 <WhoNeedszzz> So then how to do it?
17:45:17 <mzero> (assuming this is an assignment, and hence I'm resisting not writing it for you)
17:45:21 <hpc> no, it still works i think
17:45:28 <hpc> > intersection "abc" "dcba"
17:45:28 <Nereid> WhoNeedszzz: what's the goal?
17:45:29 <lambdabot>   Not in scope: `intersection'
17:45:33 <mm_freak_> WhoNeedszzz: explicit traversal of the lists
17:45:35 <hpc> > intersect "abc" "dcba"
17:45:36 <lambdabot>   "abc"
17:45:39 <hpc> damn
17:45:43 <EvanR2> hpc: rofl
17:45:57 <aristid> hpc: that's the expected answer, no?
17:46:03 <mzero> WhoNeedszzz: start with the null case.... what should the answer be if the first list is empty?
17:46:07 <mzero> write out that clause
17:46:09 <aristid> @src intersect
17:46:09 <lambdabot> intersect = intersectBy (==)
17:46:10 <hpc> > flip intersect "abc" "dcba"
17:46:12 <lambdabot>   "cba"
17:46:15 <hpc> ha!
17:46:18 <aristid> @src intersectBy
17:46:18 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
17:46:24 <hpc> hooray for operational details
17:46:25 <milaz> WhoNeedszzz: what about these statements:
17:46:38 <milaz> commonChar "" any = True
17:46:39 <aristid> :t intersect `on` sort
17:46:41 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
17:46:44 <milaz> that will be base
17:47:04 <mzero> now, if the first string isn't empty - what should you do with the first letter of it?
17:47:36 <Nereid> and commonChar (c:cs) s should be False if s doesn't contain c, and otherwise it'll be commonChar cs (the stuff in s after the first c)
17:47:37 <Nereid> so
17:47:40 <Nereid> is that right?
17:48:05 <milaz> commonChar (a:as) (a:bs) = commonChar as bs
17:48:20 <Nereid> milaz: you can't do that.
17:48:23 * mzero wonders how many people are working on this assignment?  :-)
17:48:41 <milaz> Nereid: whoops
17:48:43 <milaz> really?
17:48:47 * BMeph_ believes the answer is: >1
17:48:59 <milaz> arrrgh, I started learning FP from Refal
17:49:15 <Nereid> but yeah, commonChar (a:as) (b:bs) | a == b = commonChar as bs ...
17:50:22 <mzero> also, consider what should the answer be if the first string isn't empty, but the second one is.
17:50:25 <mzero> write out that clause
17:50:35 <Nereid> yeah, I just wrote it out, it's 4 easy lines.
17:50:54 <mzero> (the order of the clauses makes a difference,... see if you rationalize the order)
17:51:40 <mzero> Yes, I'll give you that I think the clearest solution is 4 lines, too
17:51:46 <hpaste> Nereid pasted “commonChar (spoilers)” at http://hpaste.org/75593
17:51:46 <mzero> well, 4 clauses
17:52:22 <mzero> that looks nice - but yeah, it's a spoiler
17:52:30 <milaz> yay!
17:53:49 <mzero> for those doing this as an exercise - make sure you understand why the order of the first two clauses (whether you look at Nereid's solution, or wait to write your own) are in the order they are
17:54:11 <Nereid> and obviously there's nothing that says these have to be strings.
17:54:31 <mzero> sure, load your function into ghci, then :t commonChar
17:54:42 <mzero> and realize that the function name is, well, restrictive
17:54:48 <Nereid> :V
17:54:58 <Nereid> and common is also probably a bad name.
17:55:09 <Nereid> since that makes it sound symmetric.
17:55:10 <mzero> appearsInOrder
17:55:14 <Nereid> subsequenceOf might be better.
17:55:34 <milaz> subsequenceInOrder :)
17:55:39 <mzero> so     then you can write       "abc" `appearsInOrder` "xaxbxcx"
17:55:39 <Nereid> sequences are ordered.
17:56:11 <Nereid> contiguous subsequences might be more interesting.
17:56:27 <mzero> maybe   appearsInOrderOf   to match prefixOf   infixOf   suffixOf
17:56:41 <Nereid> subsequenceOf.
17:57:09 <mzero> subsequence would generally be synonomous with infixOf ---- at least for people coming from other languages
17:57:22 <milaz> exactly
17:57:29 <Nereid> oh right. I'm thinking of what mathematicians mean by subsequence.
17:57:30 <mzero> though, yes, that sounds like a technically better name
17:57:40 <milaz> i perceive subsequence as something contiguous
17:57:59 <mzero> embeddedSequenceOf
17:58:09 <mzero> or
17:58:10 <mzero> embedOf
17:58:17 <Nereid> or <=
17:58:29 <mzero> no no, that already has meaning
17:58:31 <Nereid> :V
17:58:35 <mzero> >   "abc" <=
17:58:36 <Nereid> but it's a nice partial order!
17:58:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:58:45 <mzero> >   "abc" <= "xaxbxcx"
17:58:46 <lambdabot>   True
17:58:54 <mzero> >   "abc" <= "xx"
17:58:55 <lambdabot>   True
17:58:59 <mm_freak_> > "abc" `elem` subsequences "daxbcss"
17:59:00 <milaz> for that point, i preferred giving taskN names for my exercises when i was a student
17:59:00 <lambdabot>   True
17:59:26 <milaz> that way, i got a lot of time to work on the next task
17:59:37 <mzero> wonders how efficient mm_freak's version is....
17:59:43 <mm_freak_> it's very inefficient
17:59:49 <mzero> might not be, really
18:00:00 <mm_freak_> but it is (in general)
18:00:00 <WhoNeedszzz> mzero, I get Nereid's solution
18:00:05 <WhoNeedszzz> I understand why the order is important
18:00:19 <WhoNeedszzz> Well actually no i don't
18:00:26 <WhoNeedszzz> I get why the clauses are necessary
18:00:35 <Nereid> WhoNeedszzz: consider commonChar [] []
18:00:36 <WhoNeedszzz> but not why the order is important
18:00:47 <WhoNeedszzz> []
18:01:05 <Nereid> I thought we were returning a Bool.
18:01:19 <WhoNeedszzz> Ah see i have a function called commonChars
18:01:28 <WhoNeedszzz> So it's confusing me
18:01:28 <Nereid> commonChar is a bad name.
18:01:30 <mzero> right, so commonChar "" ""   should return what?
18:01:42 <WhoNeedszzz> so you mean subsequenceOf "" ""
18:01:46 <Nereid> yeah
18:01:49 <Nereid> > subsequenceOf [] []
18:01:51 <lambdabot>   True
18:02:13 <Nereid> > subsequenceOf "abc" "abc" -- reduces to the above
18:02:13 <milaz> lambdabot gets the prize for the right answer
18:02:15 <lambdabot>   True
18:02:22 <Nereid> milaz: well, I did just @let that.
18:02:29 <WhoNeedszzz> Right but why does the order matter?
18:02:41 <Nereid> WhoNeedszzz: what is commonChar "" "" when you switch the order?
18:02:53 <mzero> WhoNeedszzz: yes, so if    subsequencesOf [] []   should be True, then consider if that will be the case if you reverse the order of the first two clauses
18:03:09 <WhoNeedszzz> i see
18:03:23 <Nereid> and it's not just that
18:03:53 <WhoNeedszzz> I just need to get used to (a:as) and (b:bs)
18:04:02 <Nereid> when the two strings are identical (for example), the recursion reduces to comparing empty strings
18:04:09 <WhoNeedszzz> I get that it means the first character plus the reset
18:04:11 <WhoNeedszzz> rest*
18:04:18 <WhoNeedszzz> But i get confused on how to use them
18:04:23 <monochrom> suppose you have this sequence [a,b,c,d,e]. it's pretty standard to say a subsequence is [a,c,e]
18:05:12 <Nereid> ok, here's what you get if you switch the first two lines
18:05:14 <WhoNeedszzz> Now the bigger question (which is out of scope I know) is how to do that in C
18:05:19 <Nereid> > wrongSubsequenceOf "" ""
18:05:21 <lambdabot>   False
18:05:23 <Nereid> > wrongSubsequenceOf "abc" "abc"
18:05:26 <lambdabot>   False
18:05:31 <Nereid> > wrongSubsequenceOf "abc" "fabc"
18:05:34 <lambdabot>   False
18:05:40 <Nereid> > wrongSubsequenceOf "abc" "abcd"
18:05:42 <lambdabot>   True
18:06:22 <Nereid> WhoNeedszzz: with C strings, I'd just hold a pointer into each string and increment them until one of them reaches the end of the string.
18:06:44 <WhoNeedszzz> or a for loop?
18:06:48 <Nereid> in a for loop, yes.
18:07:01 <Nereid> well, while might be cleaner.
18:07:08 <WhoNeedszzz> true
18:07:09 <EvanR2> haha cleaner C code
18:07:12 <WhoNeedszzz> ha
18:07:17 <WhoNeedszzz> I hate C
18:07:24 <EvanR2> also haha 'cleaner'
18:07:31 <WhoNeedszzz> But i have to compare the code for the functions in Haskell and C
18:07:34 <milaz> I'd do this in a for with no body :)
18:07:34 <EvanR2> sorry my code is dity
18:07:46 <mzero> WhoNeedszzz: now that you've written it in Haskell, you should be able to translate it to C to code that work out-of-the-box
18:07:56 <WhoNeedszzz> True i guess
18:08:16 <WhoNeedszzz> But like what would the C equivalent be for intersect?
18:08:23 <mzero> without the Haskell version, the subtlty if which null to check for first is easy to get wrong in the C version
18:08:34 <Nereid> WhoNeedszzz: I dunno, I'd probably sort the strings first.
18:09:00 <mzero> Nereid: I think sorting the strings changes the predicate
18:09:13 <WhoNeedszzz> not for the common chars function
18:09:17 <WhoNeedszzz> that's what i'm referring to
18:09:18 <mzero> I don't think we want    "abc" `subsequenceOf` "cba"
18:09:21 <Nereid> oh.
18:09:30 <Nereid> I say "oh" but for a different reason.
18:09:42 <Nereid> you want intersect to be symmetric.
18:09:50 <mzero> ah--- commmonChars just sees if all the first lists elements are in the second?
18:09:55 <Nereid> yes
18:09:58 <WhoNeedszzz> no
18:10:03 <dmwit> ?karma ah-
18:10:03 <lambdabot> ah- has a karma of -1
18:10:07 <dmwit> ah-++
18:10:27 <WhoNeedszzz> My commonChars method just finds common chars
18:10:32 <kallisti> ?karma --
18:10:32 <lambdabot> -- has a karma of -64
18:10:35 <hpaste> Nereid pasted “commonChar in C” at http://hpaste.org/75596
18:10:37 <kallisti> --++
18:10:37 <KirinDave> Is there a fast versoin of show for Data.Text values?
18:10:39 <Nereid> something like that
18:10:53 <dmwit>  ?karma ""
18:10:56 <KirinDave> I have this cute test program and I wanted to show how data.Text is way nicer than Strings
18:11:04 <KirinDave> But it turns out the String version is faster
18:11:07 <kallisti> KirinDave: you mean Show a => a -> Text?
18:12:03 <KirinDave> Yeah
18:12:08 <KirinDave> Hoogling did not help me.
18:12:29 <Nereid> I doubt there's much you can do besides fromString . show?
18:12:31 <hpaste> WhoNeedszzz pasted “commonChars and subsequenceOf” at http://hpaste.org/75597
18:12:51 <dmwit> show isn't magic
18:12:53 <KirinDave> So then for small operations
18:12:54 <dmwit> Just write your own class.
18:12:54 <mzero> WhoNeedszzz: if you need to compare to C versions for both functions - it would be amusing to write the C version as you would in C ... then write it in C a second time, mirroring the Haskell version - and then compare the two versions of the C code as well
18:13:04 <KirinDave> Data.Text is slower here.
18:13:05 <Nereid> haha
18:13:18 <WhoNeedszzz> ha yeah
18:13:25 <WhoNeedszzz> Nereid, That's the functions i'm referring ot
18:13:31 <kallisti> KirinDave: yes, converting to Text will be slower than doing the same thing without converting to Text
18:13:33 <WhoNeedszzz> to*
18:13:44 <KirinDave> kallisti: I thought maybe the cost of joining would be lower.
18:13:48 <KirinDave> kallisti: But I guess not in this case.
18:21:38 <WhoNeedszzz> Well thanks all who have helped me
18:33:39 <lpvb> how do I get putStr to work correctly again?
18:33:46 <lpvb> it doesn't print until I Ctrl-C
18:33:55 <lpvb> something about flushing I think
18:34:57 <EvanR2> set buffering differently or put a newline
18:35:07 <EvanR2> hSetBuffering
18:35:32 <lispy> i was going to put my matrix/vector code on hackage, but it seems there are tons of libraries already doing that
18:35:48 <lpvb> I don't have a handle
18:35:58 <EvanR2> :t stdout
18:35:59 <lambdabot> Not in scope: `stdout'
18:36:12 <lpvb> thanks
18:37:14 <EvanR2> :t System.IO.stdout
18:37:15 <lambdabot> GHC.IO.Handle.Types.Handle
18:37:20 <EvanR2> chaching
18:40:04 <dmwit> I read that incorrectly and got confused. Output has nothing to do with caching!
18:40:36 * hackagebot gloss 1.7.6.2 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.6.2 (BenLippmeier)
18:44:34 <YayMe> :t SourcePos
18:44:35 <lambdabot> Not in scope: data constructor `SourcePos'
18:44:42 <InternetFriends> now you're going to die...
18:44:44 <YayMe> balls. I'm confused by this
18:45:02 <YayMe> Hrmm, this appears helpful..
18:45:05 <InternetFriends> ie
18:45:05 <InternetFriends> di
18:45:06 <dmwit> ?where ops
18:45:06 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
18:45:06 <InternetFriends> e
18:45:06 <InternetFriends> die
18:45:07 <InternetFriends> die
18:45:07 <InternetFriends> die
18:45:08 <InternetFriends> die
18:45:10 <InternetFriends> die
18:45:10 <InternetFriends> die
18:45:11 <InternetFriends> die
18:45:11 <InternetFriends> die
18:45:12 <InternetFriends> die
18:45:12 <InternetFriends> die
18:45:12 --- mode: ChanServ set +o Cale
18:45:13 --- mode: ChanServ set +o copumpkin
18:45:13 <InternetFriends> die
18:45:14 <InternetFriends> die
18:45:14 <InternetFriends> die
18:45:14 --- mode: copumpkin set +m
18:45:17 --- mode: Cale set +b *!*@24.69.197.34
18:45:17 --- kick: InternetFriends was kicked by Cale (InternetFriends)
18:45:22 --- mode: copumpkin set -m
18:45:25 <c_wraith> alternate strategies
18:45:36 * hackagebot gloss-raster 1.7.6.2 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.6.2 (BenLippmeier)
18:45:38 * hackagebot gloss-examples 1.7.6.2 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.6.2 (BenLippmeier)
18:45:40 <dmwit> thanks
18:46:10 * copumpkin high-fives Cale 
18:46:13 --- mode: copumpkin set -o copumpkin
18:46:22 --- mode: Cale set -o Cale
18:47:07 <lpvb> I'm making a small library, and I have an library section in .cabal and an executable demo for the library. How do I use cabal-dev ghci to execute main from the executable?
18:49:47 <YayMe> in ghci :type works for functions but what do I do for data types?
18:50:02 <rwbarton> what?
18:50:07 <scshunt> YayMe: :kind
18:50:16 <jfischoff> or :info
18:50:57 <YayMe> ah that's the one jfischoff thanks
18:51:04 <YayMe> couldn't remember, haven't used it in a while
18:51:07 <rwbarton> you can use :type on values that aren't functions too
18:53:55 <kallisti> lpvb: just run the executable?
18:53:57 <kallisti> you don't need ghci
18:54:08 <kallisti> cabal-dev install; my_executable
18:55:08 <YayMe> does yesod support WebSockets?
18:55:11 <lpvb> that's what I'm doing
18:59:35 <YayMe> how do I unload something in GHCI?
18:59:59 <jfischoff> load something else?
19:00:46 <YayMe> Err?
19:01:59 <kallisti> YayMe: :m will clear all imports
19:02:11 <YayMe> perfect thanks!
19:05:37 * hackagebot buildbox 2.1.2.2 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.2.2 (BenLippmeier)
19:05:39 * hackagebot gluturtle 0.0.7 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.7 (YoshikuniJujo)
19:17:18 <Hail_Spacecake> I'm trying to read a value from a string, and use a defualt value if that fails with with a Prelude.read no parse
19:17:27 <Hail_Spacecake> and based on my understanding of haskell exceptions I think I want something like
19:17:38 <EvanR2> dont use exceptions for that
19:17:42 <Hail_Spacecake> so what should I use?
19:17:43 <lispy> Hail_Spacecake: reads
19:17:46 <EvanR2> reads
19:18:12 <YayMe> How do I get a "Stream" type for Parsec?
19:18:44 <Hail_Spacecake> just out of curiosity, how would you do that with read and an exception
19:18:44 <Hail_Spacecake> becuase I would think that catch (read "myvalue" :: Int) (\x -> 10)
19:18:44 <Hail_Spacecake> where my default is 10
19:18:44 <Hail_Spacecake> would work
19:19:04 <EvanR2> meh
19:19:13 <BMeph_> :t catch
19:19:15 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
19:19:37 <EvanR2> :t Control.Exception.catch
19:19:38 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
19:19:38 <BMeph_> Hail_Spacecake: ^^ Check the types, Luke!
19:19:57 <mzero> YayMe: what type are you trying to parse? String?
19:20:01 <YayMe> :type reads
19:20:13 <EvanR2> :t reads
19:20:14 <lambdabot> forall a. (Read a) => String -> [(a, String)]
19:20:26 <YayMe> mzero: For starters yes, a file eventually but I'll abstract that section I assume after playing with strings
19:20:41 <mzero> Then String is already a Stream
19:21:27 <luksow> any users of ghc-mod here?
19:21:38 <mzero> er, or rather, you don't need to construct a Stream type
19:21:44 <mzero> it's got one for you
19:21:47 <Puffton> What do you guys think about my code so far?
19:21:48 <Puffton> http://hpaste.org/75599
19:22:31 <mzero> just use Text.Parsec.String
19:22:58 <Puffton> Sorry, xchat crashed for me
19:23:15 <mzero> all the combintors and Char utilities will work with auto-type-inferringly
19:23:16 <newsham> has anyone made a Maybe version of all the partial functions in the prelude?
19:23:20 <YayMe> :type Text.Parsec.String
19:23:21 <newsham> that would be a nice lib
19:23:25 <mzero> maybe....
19:23:29 * mzero (couldn't resist)
19:23:30 <YayMe> :t Text.Parsec.String
19:23:32 <lambdabot> Couldn't find qualified module.
19:23:42 <newsham> like a maybe-read
19:23:44 <mzero> that's a module, not a type
19:23:46 <EvanR2> import Prelude hiding *
19:23:50 <EvanR2> import SafePrelude
19:23:52 <EvanR2> haha
19:24:12 <newsham> ?type read
19:24:14 <lambdabot> forall a. (Read a) => String -> a
19:24:19 <newsham> ?hoogle (Read a) -> String -> Maybe a
19:24:19 <lambdabot> Warning: Unknown type Read
19:24:19 <lambdabot> Debug.Trace trace :: String -> a -> a
19:24:19 <lambdabot> Text.Parsec.Pos updatePosString :: SourcePos -> String -> SourcePos
19:24:27 <newsham> ?hoogle (Read a) => String -> Maybe a
19:24:27 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
19:24:28 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
19:24:28 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
19:25:41 <mzero> exit
19:25:42 <syntaxfree> sometimes I understand what's going on in this place -- and this scares me,
19:25:57 <newsham> if mzero is quit, what is mappend?
19:26:08 <EvanR2> mempty?
19:26:16 <EvanR2> mplus
19:27:49 <YayMe> I am failing miserably at making this Parsec thingy do anything, anyone know where I can find a simple example?
19:28:42 <newsham> i've got a baby parsec-like tutorial thingy if you're interested.
19:29:03 <YayMe> please
19:29:17 <jfischoff> also feel free to hpaste your code
19:29:20 <newsham> there's also the scheme48 tutorial
19:29:47 <newsham> http://www.thenewsh.com/~newsham/formal/parse/parser.lhs
19:30:40 <newsham> RWH has a chapter http://book.realworldhaskell.org/read/using-parsec.html
19:31:06 <newsham> the hask wiki has a page with links to examples http://www.haskell.org/haskellwiki/Parsec
19:31:13 <lpvb> What's wrong with TryHaskell?
19:31:34 <lpvb> it can't even evaluate arithmetic today
19:32:34 <newsham> but did it *try*?
19:32:42 <lpvb> haha
19:32:56 <YayMe> lpvb: It's just hungover
19:40:09 <Hail_Spacecake> actually, hm, I think I might want to use read and catch an exception after all
19:40:18 <Hail_Spacecake> what I'm actually doing is I'm reading the 2nd element of a list
19:40:21 <Hail_Spacecake> and parsing it as an int
19:40:30 <Hail_Spacecake> that element might not exist, and if it does, it might not be parseable as an int
19:40:37 <Hail_Spacecake> in either case i want to return a defualt value
19:40:45 <Hail_Spacecake> only if it exists and is parseable do I return that value
19:41:20 <Hail_Spacecake> but yeah catch seems to only work with IO exceptions
19:41:32 <Hail_Spacecake> and this isn't an IO exception, other than that the list I have is ultimately from user input
19:45:38 * hackagebot lin-alg 0.1.0.0 - Low-dimensional matrices and vectors for graphics and physics  http://hackage.haskell.org/package/lin-alg-0.1.0.0 (JasonDagit)
19:46:32 <newsham> you could use parsec to read the integer with error handling
19:46:40 <EvanR2> Hail_Spacecake: you can catch non io exceptions with Control.Exception
19:46:47 <EvanR2> Hail_Spacecake: you should just wrap reads
19:47:23 <YayMe> shouldn't you just use reads for read checking?
19:48:10 <EvanR2> fromMaybe default . (\x -> if null x then (Just . fst . head) x else Nothing) . reads
19:48:36 <EvanR2> blaw
19:48:49 * YayMe doesn't understand the head referene
19:48:58 <YayMe> s/referene/reference
19:48:58 <EvanR2> (\x -> if null x then default else (fst . head) x) . reads
19:49:54 <Hail_Spacecake> I'm not sure what fromMaybe does
19:49:54 <Hail_Spacecake> :t fromMaybe
19:49:55 <lambdabot> forall a. a -> Maybe a -> a
19:50:17 <EvanR2> > fromMaybe 8 Nothing
19:50:18 <lambdabot>   8
19:50:33 <YayMe> what does fromMaybe do in the case of a nothing?
19:50:34 <Hail_Spacecake> oh
19:50:35 <Hail_Spacecake> ah
19:50:37 <Hail_Spacecake> makes sense
19:50:41 <Hail_Spacecake> yeah that's what I want
19:50:44 <EvanR2> the only thing that makes sense
19:51:04 <YayMe> EvanR2: Throw? Or return a default-like value?
19:51:30 <YayMe> ohh I see
19:51:39 <YayMe> it allows you to specify the default value
19:51:44 <EvanR2> purity plus immutability plus algebraic types equals often times the type sig is all the documentation you need
19:52:39 <YayMe> which is pretty awesome to be sure. Where outside of Haskell has anyone seen that?
19:53:08 <EvanR2> haskells the only remotely mainstream system with those three things
19:53:14 <EvanR2> not to mention lazy semantics
19:53:27 <YayMe> EvanR2: remotely mainstream? That's a stretch heh
19:53:45 <pnielsen> more like remotely niche ;)
19:53:49 <EvanR2> hah
19:53:58 <monochrom> tutorial on reads: http://www.vex.net/~trebla/haskell/reads.xhtml
19:54:27 <YayMe> EvanR2: It wouldn't be as amazing if it were remotely mainstream, but it's amazing that it has such characteristics yet 98% of devs will never know such things are even possible
19:54:50 <pnielsen> YayMe: agree
19:54:56 <EvanR2> 98% of devs are made up
19:55:12 <pnielsen> so are 58% of all statistics
19:55:16 <YayMe> You're made up!
19:55:24 <EvanR2> im a 2%er
19:55:26 <jmcarthur> EvanR2: are you sure?
19:55:39 <pnielsen> Dunning-Kruger up inhere
19:55:50 <monochrom> 98% of devs can't convey ideas, either
19:56:09 <pnielsen> 90% of those 98% don't _like_ programming
19:56:15 <pnielsen> I know very few haskellers who don't enjoy programming
19:56:22 <pnielsen> actually, I know none
19:56:23 <YayMe> very true
19:56:34 <EvanR2> i enjoy programming a lot less in not haskell now
19:56:51 <pnielsen> it used to be the case for Python--Paul Graham's essay on that was quite nice--but not anymore
19:56:59 <startling> EvanR2: yeah, I've had that too
19:57:03 <pnielsen> http://www.paulgraham.com/pypar.html
19:57:14 <startling> somehow coffeescript is nice, though?? I wasn't expecting to like it this much
19:57:25 <lpvb> is haskell supposed to make you feel like every other language does everything wrong?
19:57:25 <monochrom> you can make a lot of true statements of the form "98% of people lack what the other 2% of people have"
19:57:26 <EvanR2> meh
19:57:28 <pnielsen> startling: did you try Fay?
19:57:35 <pnielsen> startling: http://fay-lang.org/
19:57:35 <startling> pnielsen, not yet
19:57:37 <jmcarthur> lpvb: by design, yes
19:57:43 <YayMe> drives me nuts in enterpriseyland trying to figure out how to do things right while everyone I work with just doesn't actually _like_ programming to begin with, more less being interested in doing it well
19:57:45 <startling> pnielsen: but it's on my list. :)
19:57:53 <monochrom> in particular "98% of people lack the property that they're members of the other 2%"
19:57:54 <pnielsen> lpvb: it's an unintentional side effect, at least. I thought Haskell didn't have those. He he.
19:58:07 <lpvb> lol
19:58:15 <EvanR2> rofl.
19:58:29 <jmcarthur> @remember monochrom 98% of people lack the property that they're members of the other 2%
19:58:30 <lambdabot> I will never forget.
19:58:32 <monochrom> you can partition people into any 98%, 2% partition and have that statement being true
19:59:20 <EvanR2> 98% of people live in montana
19:59:23 <Puffton> monochrom, and almost everyone belonging to the 98% would think they belonged to the 2%
20:00:07 <pnielsen> Puffton, monochrom: http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect
20:00:07 <monochrom> they are right to thing that. since you are free to do the partition any way you want, you can certainly put yourself outside the 98% part
20:00:17 <monochrom> s/thing/think/
20:00:26 <XexonixXexillion> Haskell has never made me feel like every other language does everything wrong. Things like C and Java explain why they are wrong by themselves
20:00:38 <EvanR2> ll
20:02:15 <XexonixXexillion> I mean as much as I like Haskell, the prelude has too many unsafe functions, and the module system for Haskell is painful
20:02:44 <mm_freak_> comparing to C and java doesn't exactly support your point =)
20:02:44 <YayMe> monochrom: Yes, you can make those statements with ease, but the meaning of them is still valid, it goes something like this: In this partition, things would be better if the segmentation weren't so lopsided
20:03:16 <Puffton> monochrom, of course if they partition it as they please, they can always be part of the 2%.. what I meant was just the Dunning-Kruger effect (didn't know it had a name) that pnielsen mentioned
20:03:40 <XexonixXexillion> mm_freak_: it makes my point perfectly. Haskell only seems like it's doing everything right to people who've never seen something else do it right
20:03:46 <YayMe> monochrom: It's just an expression.. call me wrong but I still think, "In the partition of people who know the benefits of haskell vs people who don't, things would be better if the segmentation weren't so lopsided"
20:03:47 <EvanR2> C and java dont have module systems xD
20:04:07 <newsham> ?type fromMaybe
20:04:08 <lambdabot> forall a. a -> Maybe a -> a
20:04:21 <newsham> ?src fromMaybe
20:04:21 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
20:04:36 <pnielsen> XexonixXexillion: ML, then? >:)
20:04:44 <mm_freak_> XexonixXexillion: haskell doesn't do everything right, so what?
20:04:50 <newsham> ?src maybe
20:04:50 <lambdabot> maybe n _ Nothing  = n
20:04:51 <lambdabot> maybe _ f (Just x) = f x
20:04:51 <mm_freak_> i mean, your premise is broken to begin with
20:05:00 <pnielsen> XexonixXexillion: Robert Harper, is that you?
20:05:15 <pnielsen> (jk)
20:05:17 <Polarina> I haven't seen anything that does everything "right".
20:05:32 <YayMe> Polarina: Look at me!
20:05:38 <pnielsen> YayMe: Yay you!
20:05:40 <YayMe> :D
20:05:46 <mm_freak_> Polarina: have you checked out netwire 4? ;)
20:05:49 <newsham> ?type \d -> maybe d id
20:05:50 <lambdabot> forall a. a -> Maybe a -> a
20:06:07 <Polarina> mm_freak_, it's still not finished yet. :)
20:06:09 <XexonixXexillion> Which is my point. This was in reference to the statement that Haskell seemed to do everything right compared to other languages
20:06:22 <mm_freak_> Polarina: but it does everything right =P
20:06:38 <YayMe> dunning-kruger effect, never heard that term but I've heard of studies that prove it
20:06:45 <Polarina> mm_freak_, sure it does. :)
20:07:06 <jfischoff> YayMe: how's parsec treating you?
20:07:58 <YayMe> I found something on haskell wiki that actually reads fairly well of it
20:08:09 <pnielsen> YayMe: link?
20:08:21 <YayMe> http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
20:08:28 <pnielsen> thanks
20:09:33 <jfischoff> buildExpressionParser is nice when it works for your purposes
20:10:57 <newsham> you guys and your large component frameworks
20:11:02 <newsham> for expressin parsing
20:11:38 <EvanR2> i write all my parsers by hand, uphill both ways
20:11:56 <YayMe> jfischoff: It just seems like a good example of how to use parsec
20:12:09 <startling> in my day, you needed to tokenize!
20:12:48 <YayMe> newsham: I've spent the last hand full of years working places where when something needed parsing it meant write a mega state machine! woo! It'll be full of errors but you already know that going in and accept that as a fact! Woo!
20:13:05 <jfischoff> YayMe: yeah, its to bad there isn't an updated version of the old tutorial linked from newsham tutorial.
20:13:07 <YayMe> newsham: So the concept of a combinatory parser kind of rocks my socks
20:16:47 <YayMe> I'm at least glad I never wrote one of those state machine parsers, though I'm ashamed that I thought for a long time I just needed to factor them correctly to make them good..
20:17:10 <monochrom> I wrote http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements . thank you for choosing monochrom!
20:17:56 <jfischoff> monochrom: :D
20:17:59 <YayMe> monochrom: Well thank you very much!
20:18:08 <lpvb> in Data.Binary.Get, can I jump to an offset?
20:18:19 <copumpkin> no
20:19:24 <YayMe> I wrote this http://codewonderings.blogspot.com/2012/09/closures-or-software-bags.html please let me know if my explanation or understanding is shit, anonymous commenters are allowed
20:19:33 <EvanR2> class Seekable
20:24:49 <eyebloom> I think I might be in kind hell. But it could be type hell. It's hard to tell. :)
20:24:50 <YayMe> according to wikipedia Dunning-Kruger effect was put forward in 1999, that sounds like when I recall reading an article dictating the same thing. I wonder if what I read back then was the original publishing of Dunning-Kruger
20:25:22 <EvanR2> hard to tell hell
20:27:06 <hpaste> eyebloom pasted “Kind Hell?” at http://hpaste.org/75600
20:27:47 <eyebloom> Trying to get an interpreter to compile and or work properly at runtime.
20:29:02 <lispy> I want to do something with ST s foo as the type as part of an IO computation. What bit of lifting magic do I need?
20:29:16 * lispy seems to be having a brain fart
20:29:30 <bos> runST?
20:29:31 <monochrom> nice, God heard my prayer, "module Main(main,) where" is correct syntax!
20:30:01 * Clint squints.
20:30:15 <bos> you can't convert between IO and ST without visiting the sin bin
20:30:45 <monochrom> there is stToIO
20:30:46 <shachaf> I thought IO was the sin bin.
20:31:34 <lispy> bos: oh, I thought you could bring ST stuff into IO
20:32:03 <monochrom> @hoogle stToIO
20:32:04 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
20:32:04 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
20:32:04 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
20:32:12 <bos> stToIO is almost impossible to use, since you have to have a RealWorld
20:32:26 <bos> which you can't get by legal means
20:32:43 <lispy> basically I have, mkImage :: Int -> Int -> ST s (MutableImage s PixelRGB8), and writePixel :: MutableImage s a -> Int -> Int -> a -> ST s (), but I'm using them from IO instead of ST
20:33:18 <bos> lispy: you can use unsafeSTToIO, and it will work, but you're in the sin bin
20:33:53 <lispy> bos: refactoring would incur less sin
20:33:59 <lispy> so I may go that route
20:34:03 <bos> good plan
20:34:18 <monochrom> if you have "s :: ST s Int", then "stToIO s" type-checks
20:34:26 <bos> basically, if the type system is giving you a wedgie, it is good to reestablish happy buttocks before continuing
20:34:32 <monochrom> sorry for using s twice
20:34:40 <EvanR2> lol
20:35:11 <monochrom> if you have "s :: ST is_this_realworld_or_does_it_matter Int", then "stToIO s" type-checks
20:36:23 <lispy> is stToIO otherwise safe? I know nothing about this magic function
20:36:34 <monochrom> stToIO is safe
20:36:38 <bos> yes, it's safe
20:37:00 <monochrom> the argument about "but you don't have the RealWorld type" is irrelevant
20:37:46 <Ralith> why not use tuse runST?
20:38:18 <YayMe> Is it particularly helpful in understanding haskell/monads to really grasp and understand the kleisli triple?
20:39:26 <lispy> Ralith: at the moment I print out a progress meter in the middle of the loop where i write pixels.
20:39:50 <lispy> I have to do a lot of refactoring to avoid that if I want to use runST
20:40:35 <Ralith> ah, I see
20:40:56 <lispy> Granted, JuicyPixel seems to be missing a function that can take a mutable bitmap and write it as a png
20:41:02 <EvanR2> lispy: ah youre trying to do IO in the middle of an ST
20:41:05 <lispy> So maybe this is all for naught
20:41:19 <EvanR2> the large-computation progress report is something i was looking for earlier
20:41:42 <EvanR2> maybe you could use a writer
20:42:20 <lispy> EvanR2: wouldn't that just accumulate the progress updates instead of showing them?
20:42:37 <EvanR2> lazy writer?
20:43:13 <lispy> I guess the author expects me to extract the STVector and freeze it and then generate an image from that?
20:43:20 <EvanR2> WriterT [Progress] (ST something) FinalAnswer
20:43:56 <EvanR2> i guess just do the whole thing in IO!
20:45:40 <lispy> Yes, I would prefer that, but the only mutable interface they provide is ST
20:45:52 <monochrom> main = do { v <- stToIO (newSTRef 'x'); y <- stToIO (readSTRef v); print y }
20:46:07 <monochrom> this code type-checks and works. this may surprise many people
20:47:11 <Cale> monochrom: Why would that be surprising? Isn't that the point of stToIO?
20:47:48 <monochrom> it does not surprise me, and I see that it is the point of "ST RealWorld" rather than the smug "ST s"
20:48:00 <monochrom> but see scrollback for who would be surprised
20:48:16 <YayMe> :t parse
20:48:17 <lambdabot> Not in scope: `parse'
20:48:59 <lpvb> can I implicitly cast Word16 to Word32?
20:49:51 <copumpkin> no
20:50:24 <copumpkin> haskell doesn't do implicit casts
20:51:00 <EvanR2> > fromIntegral (39 :: Word16) :: Word32
20:51:01 <lambdabot>   39
20:51:31 <EvanR2> however it can infer what you want to convert from/to
20:51:39 <EvanR2> sometimes
20:52:55 <EvanR2> copumpkin: it can implicitly cast from int to float watch
20:53:01 <EvanR2> > 3*1.0
20:53:02 <lambdabot>   3.0
20:53:05 <EvanR2> \o/
20:53:06 <copumpkin> that's not an implicit cast
20:53:09 <EvanR2> lol
20:53:19 <copumpkin> it's just polymorphic literals :)
20:53:42 <EvanR2> > 6.0 `div` 3.0
20:53:43 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:53:43 <lambdabot>    `GHC.Real.Integral a'
20:53:43 <lambdabot>   ...
20:53:48 <EvanR2> >_>
20:53:57 <EvanR2> > 6.0 `div` 3.0 :: Int
20:53:58 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
20:53:59 <lambdabot>    arising from the lit...
20:54:06 <Jafet> The cast is done in
20:54:07 <EvanR2> > (6.0 `div` 3.0) :: Int
20:54:08 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
20:54:08 <lambdabot>    arising from the lit...
20:54:09 <Jafet> THE TYPE SYSTEM
20:54:23 <EvanR2> cast as a jargon implies ignoring type systems
20:54:31 <lpvb> any way to break a Word32 into Word8's or turn a 4 bytes of a ByteString into a Word32?
20:54:32 <EvanR2> which we never want to do
20:54:53 <EvanR2> use Data.Bits arithmetic
20:54:57 <copumpkin> lpvb: Data.Binary.Get
20:55:07 <copumpkin> lpvb: you need to decide on your endianness though
20:55:08 <EvanR2> theres different ways to convert from bytes to Word32
20:55:30 <EvanR2> the choice is YOURS
20:55:34 <lpvb> Binary.Get looks like a hassle
20:55:47 <copumpkin> it isn't
20:56:26 <startling> it's not too bad
20:56:30 <lpvb> I'm already using it to read the Word32, but I need its representation as a ByteString and Word32
20:57:08 <startling> lpvb, can't Data.Binary backtrack/lookahead?
20:57:27 <copumpkin> lpvb: this might be relevant: http://stackoverflow.com/questions/11424961/having-my-cereal-and-parsing-it-too
20:58:40 <Clint> lpvb: you could do something like integerToBEBS = B.pack . reverse . unfoldr (\x -> if x == 0 then Nothing else Just ((fromIntegral x :: Word8) .&. 0xff, x `shiftR` 8
20:58:43 <Clint> ))
20:58:51 <Clint> only less ugly
21:00:17 <startling> lpvb: asBS <- lookahead (getBytes 4); as32 <- getWord32
21:00:33 <ivanm> is there a nice way of defining a function :: (Ord a) => [a] -> [a] -> Ordering such that longer lists are GT, but if they're the same length then it compares the elements the "normal" one?
21:00:47 <copumpkin> ivanm: yes!
21:00:51 <shachaf> comparing length ++ compare
21:00:58 <shachaf> Where ++ is mappend
21:01:23 <shachaf> (Of course, "comparing length" is suboptimal, but you can write a better comparison function.)
21:01:29 <copumpkin> :t comparing length ++ compare
21:01:31 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
21:01:42 <ivanm> @src Ordering mappend
21:01:42 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:01:43 <copumpkin> that's kind of obscure :)
21:01:48 <monochrom> @type (++)
21:01:48 <ivanm> @src Ordering Monoid
21:01:49 <lambdabot> forall m. (Monoid m) => m -> m -> m
21:01:49 <lambdabot> Source not found.
21:01:52 <ivanm> bah
21:01:53 <monochrom> amazing
21:01:53 <copumpkin> it's using the function instance too
21:02:00 <startling> haha
21:02:11 <ivanm> I'm guessing mappend EQ x = x ?
21:02:15 <copumpkin> yeah
21:02:42 <startling> > LT ++ GT
21:02:44 <lambdabot>   LT
21:02:50 <startling> > GT ++ LT
21:02:52 <lambdabot>   GT
21:02:59 <startling> I don't get it.
21:03:06 <ivanm> > EQ ++ GT
21:03:08 <lambdabot>   GT
21:03:10 <shachaf> EQ ++ x = x
21:03:14 <shachaf> x ++ _ = x
21:03:19 <startling> oh. meh.
21:03:24 <shachaf> It's lexicographical.
21:03:25 <copumpkin> startling: it gives you lexicographic behavior
21:03:43 <startling> oh, I see
21:04:01 <shachaf> Is there a package like dlist generalized to any Monoid?
21:04:16 <ivanm> shachaf: how would that work?
21:04:31 <startling> you'd need pure/return, wouldn't you?
21:04:41 <ivanm> or some kind of singleton
21:05:33 <shachaf> You need fromList, which is just (++)
21:05:51 <ivanm> shachaf: mappend is fromList? :/
21:06:05 <shachaf> No, fromList = mappend
21:06:16 * shachaf 's connection is getting cut off -- on a ferry.
21:06:35 <ivanm> shachaf: oh, fromList converting to a DList ?
21:06:40 <shachaf> Yes.
21:06:52 <shachaf> Really it's just Endo, I guess...
21:06:59 <shachaf> Except restricted.
21:07:09 <shachaf> I wonder whether there's a nice way of expressing that restriction in the type.
21:07:12 <ivanm> hmmm.... rather than using comparing length, I could add the length to it with a tuple and use the tuple's Ord instance, couldn't I?
21:07:28 <shachaf> ivanm: Yep.
21:07:29 <ivanm> > compare (3, "abc") (3, "abd")
21:07:30 <lambdabot>   LT
21:07:40 <shachaf> Hmm, you could even add map (const ()) to it.
21:07:44 <shachaf> That way it'll do lazy-natural comparison.
21:07:57 <ivanm> shachaf: rather than length?
21:07:58 <shachaf> @ty \l -> (map (const ()) l, l)
21:07:59 <lambdabot> forall a. [a] -> ([()], [a])
21:08:07 <shachaf> That way it'd be properly lazy.
21:08:15 <Polarina> mm_freak_, do you have any examples on when one would use ArrowLoop (rec in do notation) with wires?
21:08:20 <ivanm> this will still require traversing the list twice, but my case isn't computationally expensive
21:08:38 <ivanm> just brute-forcing some stuff so I can try and find a pattern and thus generate values
21:24:37 <zuserm> Good evening.
21:25:22 <shachaf> ivanm: The alternative is doing a lot of possible unnecessary comparisons.
21:25:35 <ivanm> true
21:25:40 <shachaf> It would be nice if ()'s Ord instance pretended it was unlifted.
21:25:52 <shachaf> I.e. compare undefined undefined = EQ
21:25:56 <shachaf> Is there a type like that?
21:26:17 <ivanm> Void with compare _ _ = EQ ?
21:26:31 <shachaf> Well, yes, but that's ugly.
21:26:33 <monochrom> I think people expect comparisons to be pretty strict
21:26:59 <shachaf> ...Void has a cmopare instance which doesn't terminate.
21:27:28 <ivanm> newtype it? ;-)
21:27:29 <shachaf> I mean that compare undefined undefined = _|_, but not undefined-_|_
21:27:48 <monochrom> your computer time goes into a void... :)
21:28:26 <shachaf> GHC derives that instance, I guess.
21:28:50 <shachaf> Silly GHC.
21:29:17 <ivanm> monochrom: *groan*
21:29:52 <shachaf> Oh, that's because edwardk defined data Void = Void !Void
21:31:10 <shachaf> @tell edwardk (undefined::Void) == undefined is non-terminating; is that on purpose?
21:31:10 <lambdabot> Consider it noted.
21:35:03 <applicative> zuserm: good evening
21:35:46 * hackagebot lin-alg 0.1.0.1 - Low-dimensional matrices and vectors for graphics and physics  http://hackage.haskell.org/package/lin-alg-0.1.0.1 (JasonDagit)
21:39:48 <lispy> I wonder if I should upload my ray tracer too
21:40:02 <zuserm> I have a program I refactored and now it's not being optimized as well. I'm trying to figure out where the problem is coming from, but the the difference mostly goes away with profiling on.
21:40:06 <lispy> I only uploaded my linear algebra library (tiny at the moment) because I split it out from the ray tracer
21:40:25 <lispy> zuserm: inlining?
21:40:46 * hackagebot snap-loader-dynamic 0.9.0.1 - Snap: A Haskell Web Framework: dynamic loader  http://hackage.haskell.org/package/snap-loader-dynamic-0.9.0.1 (DougBeardsley)
21:40:47 <lispy> zuserm: odd that it goes away with profiling. I've heard it can interfer but never experienced it
21:42:04 * lispy wonders if writing a physics engine in pure haskell would be worthwhile given all the viable alternatives already out there in other languages.
21:42:24 <zuserm> The difference doesn't completely go away, but it goes down from about 50% to about 5% and the profiles don't look much different.
21:42:41 <lispy> I guess the thing that would be "easy" to do is write a reference physics engine that doesn't allow pentration
21:43:29 <lispy> zuserm: hmm...Need more info to help
21:43:38 <ivanm> @pl \ es -> (map (const ()) es, es)
21:43:38 <lambdabot> (,) =<< map (const ())
21:43:59 <applicative> zuserm is it complicated or can you paste it?
21:44:35 <ivanm> OK, for some reason  - either the version of pointfree, the interaction with ghci or the emacs/ghci interface - the "()" bit gets dropped when I try and do that here :s
21:44:53 <ivanm> seems to be pointfree
21:45:31 <zuserm> I can paste what I think is the relevant piece of it. One sec.
21:49:49 <hpaste> zuserm pasted “optimization fail” at http://hpaste.org/75602
21:51:33 <zuserm> I also split out the definition of the game that's being played into a separate module. Could that be it maybe?
21:52:30 <ivanm> zuserm: how are you compiling it?
21:52:40 <ivanm> are you comparing profiled versions?
21:52:41 <zuserm> -O2 -fllvm
21:53:36 <ivanm> you said you tried profiling it before; was that with -prof ?
21:53:46 <ivanm> if so, did you make sure to clean before re-compiling _without_ profiling?
21:54:06 <zuserm> for profiling I had: -O2 -llvm  -rtsopts -prof -auto-all -caf-all
21:56:17 <bos> using -prof -auto-all -caf-all has a number of problems
21:56:41 <bos> it introduces a ton of profiling points, and it also inhibits optimisation
21:57:08 <bos> ideally, you'll annotate specific parts of the code instead
21:57:14 <ivanm> which is why I was asking if zuserm did a clean
21:57:23 <ivanm> and tried without profiling to compare them
21:57:58 <zuserm> ivanm: yeah
21:59:48 <zuserm> bos: this is my first attempt at profiling, I don't really know much about it
22:01:19 <ivanm> bos: so -prof -auto-all -caf-all can disable the optimisations that you're actually trying to profile? :/
22:02:33 <bos> ivanm: it can do that, or the profiling overhead can overwhelm the effect you're trying to measure
22:03:05 <ivanm> *nod*
22:03:24 <ivanm> so what do you suggest, adding explicit SCC points or something and just using -prof ?
22:03:31 <bos> yep
22:04:58 <zuserm> mm
22:05:47 <ivanm> bos: in case I haven't said so earlier, I do find the SCC adding/removing snippets for emacs you had on your blog handy
22:06:21 <bos> glad to hea
22:06:22 <bos> r
22:12:44 * ivanm facepalms
22:13:18 * copumpkin palmfaces
22:13:26 <ivanm> turns out the [a] -> [a] -> Ordering function isn't what I want, since I'm trying to sort binary trees and of course each node in the tree has at most 3 neighbours
22:13:29 <ivanm> @slap copumpkin
22:13:30 * lambdabot pokes copumpkin in the eye
22:14:37 <mosno> is it just me, or is tryhaskell.org not working right now? -- http://ompldr.org/vZnBobA
22:14:39 <ivanm> what I really want is "order by size of the sub-tree" :s
22:15:06 <ivanm> mosno: looks like it
22:15:19 <ivanm> email Chris Done and ask him wtf is going on
22:15:31 <Cale> lol, filesystem failure
22:15:43 <ivanm> it looks like temp files aren't being deleted
22:15:48 <mosno> okay, i will email him now
22:15:55 <ivanm> maybe too many people have open tryhaskell.org tabs open? :p
22:16:10 <ivanm> s/have open/have/
22:17:08 <zuserm> I merged the modules back together and I get most of my performance back.
22:18:02 <Ralith> inlining, perhaps?
22:18:19 <ivanm> Ralith: yeah, seems likely
22:18:26 <ivanm> GHC doesn't really do cross-module optimisations IIRC
22:19:00 <Ralith> I wonder if you can get ghc to spit out the LLVM bitcode for each module and then do the rest yourself
22:19:32 <zuserm> eww
22:20:38 <liyang> ivanm: It doesn't? I thought the RHS of INLINEABLE functions were included in .hi files, and those will get inlined if deemed profitable.
22:20:51 <Ralith> liyang: INLINEABLE?
22:21:04 <ivanm> liyang: if you specify the pragma, yes
22:21:14 <liyang> Unless you meant something else entirely by ‘cross-module optimisations’.
22:21:45 <liyang> And cheap-enough functions always get their RHS included in the .hi.
22:22:31 <ivanm> I'm trying to vaguely remember other conversatiosn on the topic
22:23:00 <liyang> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#inline-noinline-pragma
22:23:04 <ivanm> but there used to be some hack tool that merged a whole bunch of source files into one before passing it into GHC as it would give better performance, if there wasn't any namespace clashes
22:24:24 <solrize> can anyone advise me about building a tree from the top down (e.g. parsing an XML stream into a DOM)?  is a zipper the right way to do it?
22:24:36 <ivanm> is there any particular reason Data.Tree.Tree doesn't have an Ord instance? is it mainly a matter of "which ordering to use?" ?
22:26:01 <Cale> I think it's at least partly a matter of "everyone writes their own tree type because it's easy"
22:27:56 <ivanm> heh
22:28:11 <ivanm> I was originally just using Data.Tree for the pretty-printing functions
22:28:33 <ivanm> but I figured that if the Ord instance does what I want, it might work for that as well
22:29:33 <chumma> hello all
22:29:52 <chumma> how can i get started with haskell on ubuntu 11.10
22:33:21 <ivanm> chumma: is the haskell-platform available?
22:33:31 * ivanm doesn't use ubuntu and thus doesn't know
22:33:50 <pnielsen> yes
22:33:51 <MostAwesomeDude> There's a platform available but it's not the latest.
22:33:57 <MostAwesomeDude> Should be fine, though.
22:34:05 <pnielsen> the package is called haskell-platform
22:34:15 <pnielsen> not sure if it existed in 11.10
22:34:55 <pnielsen> ivanm: oops, missed your line :)
22:37:30 <chumma> which is latest platform version?
22:37:46 <chumma> synaptic shows 2011.2.0.1.2
22:39:55 <chumma> and what's difference b/w ghc and ghc6?
22:40:42 <lispy> chumma: ghc6 would be old these days
22:41:49 <chumma> so can i get started with installing haskell-platform 2011.2.0.1.2?
22:42:15 <lispy> chumma: yes, that should work
22:42:48 <lispy> chumma: the idea behind the haskell platform is that it should have everything you need to get started with basic usage
22:43:01 <zomg> chumma: you can just install haskell-platform from apt and that'll get you started nicely. If you want a newer version, you can manually install one from the haskell platform website
22:43:23 <zomg> (or update to 12.xx ubuntu which has a more recent one)
22:44:09 <chumma> thank you i'l take a look
22:44:23 <zomg> You'll also want cabal-install, I forgot if it comes with haskell-platform
22:45:05 <pnielsen> it does
22:45:33 <zomg> Yeah I'd imagine it would :)
22:46:18 <chumma> ok
22:49:37 <chumma> by the way where does these words come from like cabal yesod? Python is my primary language so a little curious.
22:51:06 <ivanm> chumma: CABAL == Common Architecture for Building Applications and Libraries
22:51:17 <ivanm> Yesod is a Hebrew word meaning something-or-rather that Snoyman picked
22:57:23 * solirc is puzzled if there is a way to check whether some code is running within GHCi
22:57:48 <liyang> Yesod means ‘foundation’ I believe.
22:58:03 * liyang has never used it.
23:02:48 * cmccann considers making some sort of pun about installing yesod with "kabbalah" instead of "cabal" but decides that would be a bit too ridiculous.
23:03:11 <liyang> oyy vey.
23:03:35 * liyang knows Yiddish… ¬_¬
23:04:51 <luite> cmccann: and michael already did http://www.yesodweb.com/blog/2012/04/replacing-cabal
23:05:24 <cmccann> hahahaha I hadn't seen that
23:05:28 <ivanm> solirc: see if ghci is currently accepting input? ;-)
23:05:36 <ivanm> (doesn't work if you forkIO'd something in ghci though)
23:06:34 <cmccann> though given there's a package named "keter" I figured someone was already aware of the kabbalah thing
23:07:17 <zomg> cmccann: keter is also from msnoyman
23:07:24 <zomg> He seems to like those type of words
23:07:25 <zomg> lol
23:07:37 <cmccann> ok well there's eight more to go
23:07:45 <raouk> why
23:07:48 <zomg> Only thing I see them doing is making it harder to google for it
23:07:49 <zomg> :P
23:08:21 <ivanm> cmccann: eight more to go of what?
23:08:55 <cmccann> cf. http://en.wikipedia.org/wiki/Sephirot
23:09:52 <raouk> cmccann: what are you doing with kabbala?
23:10:28 <cmccann> eh I just have lots of trivia in my brain
23:10:45 <sheriff_> Ah, the Kabbala, the ancient source of Madonna's wisdom
23:11:52 <cmccann> raouk, but the topic came up because of yesod, if that isn't obvious
23:12:03 <raouk> i just came in
23:14:54 * osfameron waves at sheriff_ 
23:16:58 <marzipanmartian> why doesn't this example work? https://gist.github.com/3809779
23:17:23 <sheriff_> hi osnr
23:17:27 <sheriff_> osfameron, even
23:21:28 <ivanm> marzipanmartian: which imports are you using?
23:21:32 <ivanm> @hoogle string
23:21:33 <lambdabot> Prelude type String = [Char]
23:21:33 <lambdabot> Data.String type String = [Char]
23:21:33 <lambdabot> Data.String module Data.String
23:21:54 <Enigmagic> @hoogle string +parsec
23:21:55 <lambdabot> Text.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
23:21:55 <lambdabot> Text.ParserCombinators.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
23:21:55 <lambdabot> Text.Parsec.Token stringLiteral :: GenTokenParser s u m -> ParsecT s u m String
23:22:04 <ivanm> Enigmagic: ahhh, that's how you do it!
23:23:08 <fmap> marzipanmartian: add type signature
23:23:54 <fmap> (or disable monomorphism restriction)
23:24:13 <Enigmagic> ivanm: yeah, didn't know if it would work in here... but that's how i use it on the command line :_)
23:24:34 <marzipanmartian> I'm importing Text.Parsec.Char
23:24:57 <marzipanmartian> it's the example for string (http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Char.html) so I just wanted to play with it
23:25:23 <Enigmagic> marzipanmartian: add this to the top of your file: {-# LANGUAGE NoMonomorphismRestriction #-}
23:26:26 <marzipanmartian> Enigmagic: that fixed it! I'll have to do some reading into how that extension works :P
23:47:06 <isomorphic> Enigmagic:  Can you explain in simple terms what the NoMonoMorphismRestriction pragma does?
23:49:27 <mracrrot> When I am trying to test through ghci parts of lambdabot, I get this message when I try to load:
23:49:48 <mracrrot>     Could not find module `Paths_lambdabot'
23:49:58 <mracrrot> Why is this coming?
23:51:12 <mracrrot> Btw, if somebody here is maintaining lambdabot, it appears to be a bug there in the Url-plugin (disabled by default). It will not fetch the title for all urls.
23:51:50 <mracrrot> http://en.wikipedia.org/wiki/Haskell_(programming_language)  (will not work)
23:52:09 <mracrrot> http://en.wikipedia.org/wiki/Main_Page (will work)
23:53:45 <ivanm> mracrrot: do a "cabal configure; cabal build" and then launch ghci with the -idist
23:54:26 <Cale> Good way to end a talk: "So... there's time for negative two questions." :)
23:54:40 <ivanm> heh
23:54:41 <ivanm> which talk?
23:54:51 <ivanm> @google monomorphism restriction
23:54:52 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
23:54:52 <lambdabot> Title: Monomorphism restriction - HaskellWiki
23:54:55 <ivanm> ^^ isomorphic
23:55:30 <isomorphic> ivanm:  Thanks :)
23:55:40 <Cale> It was a talk by Thurston (the guy whose geometrisation conjecture Perelman proved and which implied the Poincaré conjecture.)
23:57:01 <mracrrot> ivanm: Thanks!
23:57:11 <ivanm> np
23:57:35 <Nereid> Cale: haha.
23:58:27 <mracrrot> ivanm: I am still getting the same message.
23:59:46 <ivanm> mceier: sorry, -idist/build/autogen
