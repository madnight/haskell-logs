00:00:06 <johnw> ddarius: and I think that's awesome
00:00:16 <johnw> i've been living with a 7-bit ASCII mentality for way too long
00:03:35 <johnw> well, this does work:
00:03:36 <johnw> ^. at "foo" ^% fromJust ^. at "hello"
00:03:42 <johnw> but that's not what I want
00:03:49 <johnw> I want the lens equivalent of <$>
00:15:49 <johnw> ah, got it
00:15:59 <johnw> shachaf: ^. at "foo" . folded ^. at "hello"
00:16:18 <johnw> returns Nothing if foo or hello doesn't exist, else the value at foo/hello
00:16:38 <shachaf> johnw: Any reason for the second ^. ?
00:16:45 <johnw> it doesn't type check with .
00:16:57 <johnw> oh, that might be my problem
00:17:00 <johnw> oh, that might be my problem
00:17:26 <johnw> yeah, not necessary
00:17:38 <Cale> .oO(The realisation that something might be his problem might be his problem.)
00:17:43 * hackagebot lojbanParser 0.1.1 - lojban parser  http://hackage.haskell.org/package/lojbanParser-0.1.1 (YoshikuniJujo)
00:17:54 <johnw>  ^. at "foo" . folded . at "hello"
00:17:55 <johnw> nice
00:18:05 <johnw> now I can write a simple pathToLens function
00:23:07 <dmwit> lojban: the programming language designed with verbal pronunciation in mind
00:25:52 <johnw> what is the identity lens?
00:26:26 <dmwit> It does nothing, like all identities.
00:26:33 <johnw> i mean, what is the name
00:26:44 <dmwit> aha
00:26:52 <shachaf> id
00:27:01 <johnw> hrmph
00:27:18 <shachaf> Assuming this is Control.Lens, that is.
00:27:29 <johnw> so what's wrong with: buildLens []     = id; buildLens (x:xs) = at x . folded . buildLens xs
00:27:31 <shachaf> Whether it's Control.Lens or not, Control.Category.id will probably work.
00:27:37 <johnw> doesn't even come close to type checking ;)
00:27:54 <johnw> well, pretty close actually
00:27:58 <johnw> i'll keep chewing on it
00:40:37 <john_r_watson> @pl (\a x -> a * 10 + x)
00:40:37 <lambdabot> (+) . (10 *)
00:41:35 <shachaf> @pl \a x -> x + a * 10
00:41:35 <lambdabot> (+) . (10 *)
00:48:53 <merijn> Good morning, my lambda loving friends.
00:49:29 <jamy23> merijn: Good morning dood!
00:51:42 <jamy23> dude
01:02:53 <merijn> "cabal: The following packages are likely to be broken by the reinstalls: ghc-7.6.1" :<
01:03:02 <johnw> so, I can' use ^. at a . folded . at b
01:03:13 <johnw> but I can't build a lens = at a . folded . at b
01:03:21 <johnw> I can use the ^. case
01:03:40 <johnw> I can't get the composition to type check in the absence of ^.
01:04:57 <jfischoff> is there way to perform efficient scans with Repa?
01:05:08 <merijn> Oh, it was just an out of date container constraint, apparently
01:07:11 <merijn> Does cabal have a field to restrict compiler versions?
01:11:21 <amosr> jfischoff: doesn't look like there are any scan functions
01:12:34 <amosr> foldP and construct a list or vector? :(
01:18:43 <amosr> er foldS
01:29:28 <merijn> Does 7.6 have built in comparison for Nat? I thought so, but I can't seem to find any documentation to prove it
01:31:36 <c_wraith> I don't think so.
01:31:46 <c_wraith> I think that stuff is all still in the experimental branch
01:35:17 <randomclown> @pl \_ -> True
01:35:17 <lambdabot> const True
01:36:07 <merijn> c_wraith: I don't see why? DataKinds and TypeLevel Nat is in 7.6
01:36:50 <c_wraith> merijn: but all the logic for treating type-level Nats as numbers didn't make it in, as far as I know.
01:36:54 <merijn> Nat without comparison is a bit useless, because then I'd still need to use "data Nat = Zero | Succ Nat" to do type level comparison
01:43:08 <jamy23> @pl \_ -> True
01:43:08 <lambdabot> const True
01:43:11 <hpaste> johnw pasted “pathToLens” at http://hpaste.org/74843
01:43:42 <johnw> can anyone tell me if this is even possible?
01:43:55 <johnw> I have a feeling it's attempting to violate the type systems
01:44:03 <jamy23> :t @
01:44:04 <lambdabot> parse error on input `@'
01:44:12 <johnw> it feels like a deadend I've faced before
01:44:15 <jamy23> :t @pl
01:44:15 <lambdabot> parse error on input `@'
01:44:33 <jamy23> :t @pl \_
01:44:34 <lambdabot> parse error on input `@'
01:44:42 <jamy23> :t pl
01:44:43 <lambdabot> Not in scope: `pl'
01:45:06 <johnw> what are you trying to do, jamy23?
01:45:32 <jamy23> what is this ---- @pl \_ -> True  ?
01:45:58 <jamy23> i dont understand @pl construction
01:46:47 <jamy23> @ -- is the marker for lambdabot?
01:47:52 <merijn> jamy23: @ is for lambdabot commands
01:48:13 <merijn> jamy23: pl is the "pointless" plugin which tries to eliminate names from haskell expressions
01:49:09 <merijn> jamy23: So @pl is just a command to lambdabot to eliminate names from the following haskell expression
01:49:32 <merijn> @pl \x y -> x * y + (x - y)
01:49:32 <lambdabot> ap (ap . ((+) .) . (*)) (-)
01:49:39 <jamy23> eliminate names? Like Y-combinator?
01:49:50 <merijn> It's not usually an improvement, though :p
01:49:55 <merijn> jamy23: Variable names
01:50:06 <merijn> jamy23: Do you know what point-free style means?
01:50:14 <jamy23> shure
01:50:58 <merijn> jamy23: It's basically a converter that turns haskell expressions into point-free haskell expressions
01:52:49 <jamy23> How i can eliminate names in pure ghci?
01:54:07 <osfameron> EXTERMINATE NAMES, WE ARE THE DALEKS, ER, EEEEK!
01:54:13 <jamy23> i mean convert to point-free expression
01:54:34 <merijn> jamy23: ghci can't do that
01:54:54 <merijn> jamy23: I believe there was a "ghci with lambdabot extensions" project, but I don't remember what it's called
01:55:15 <ivanm> ghci-on-acid
01:55:32 <ivanm> but if memory serves, every time you did a :load or :reload, goa died :s
01:57:33 <dbushenko> hi all!
01:57:44 <dbushenko> can anyone help me with that snippet: https://gist.github.com/3736283
01:57:59 <dbushenko> I can't get calculated my function when the argument is 3
01:59:36 <ivanm> dbushenko: what's the error?
01:59:44 <ivanm> oh, wait, I know
01:59:49 <ivanm> dbushenko: what happens when n == 2 ?
01:59:51 <dbushenko> it skips the guard n>2
01:59:56 <ivanm> no it doesn't
02:00:14 <ivanm> fseq 3 = 3 * fseq 2 = 3 * error "Unknown Argument"
02:00:17 <ivanm> ^^
02:00:18 <dbushenko> fseq 2 throws error
02:00:22 <ivanm> exactly
02:00:25 <dbushenko> why?
02:00:26 <ivanm> is 2 > 2 ?
02:00:27 <ivanm> > 2 > 2
02:00:29 <lambdabot>   False
02:00:31 <ivanm> :)
02:00:58 <dbushenko> f*ck! I wrote that code yesterday night and was totally sleepy...
02:00:59 <dbushenko> thanks!
02:01:05 <ivanm> np :)
02:01:24 <merijn> dbushenko: Happens to the best of us ;)
02:01:31 <dbushenko> :-)
02:02:26 <johnw> is there a cheap way to tell in haskell that x = f x, without using ==?
02:02:45 <johnw> in C, I'd use a pointer comparison
02:03:07 <ivanm> except for Oleg
02:03:07 <ivanm> :p
02:03:11 <merijn> Naming convention question: should functions be verbs? i.e. createBaseHandle vs baseHandle?
02:03:18 <jamy23> "@pl" /= "fmap" ???
02:04:06 <ivanm> johnw: what are you planning on doing with it?
02:04:07 <merijn> jamy23: fmap is a function that applies another function inside a Functor, @pl is a lambdabot plugin that tries to rewrite haskell expressions
02:04:14 <merijn> > fmap (+1) (Just 2)
02:04:15 <lambdabot>   Just 3
02:04:44 <johnw> ivanm: decide in a recursive function whether the result of a recursive call actually yielded a new value
02:04:54 <johnw> I want myFunction id x to return x
02:04:58 <ivanm> ahhh
02:05:02 <ivanm> I've used == for that
02:05:15 <dmwit> johnw: IORef's have an Eq instance.
02:05:16 <johnw> yeah, I actually think that could work here
02:05:41 <ivanm> unless you can make f smarter to also return a Bool to indicate whether or not the value has changed >_>
02:06:00 <dmwit> If you want a function that discriminates between returning changed and unchanged values, return a Maybe a or Either a a as appropriate.
02:06:06 <johnw> yes, that's very true!
02:06:08 <jamy23> I think haskell can has solution to convert lambda expression to point-free function
02:06:11 <johnw> but I can't, alas
02:06:16 <johnw> it's a user-supplied function
02:06:18 <dmwit> http://stackoverflow.com/q/1976247/791604
02:06:22 <dmwit> johnw: See that.
02:06:31 <johnw> thanks
02:07:14 <jamy23> *point-free curried function
02:07:17 <dmwit> jamy23: ?pl can do that
02:07:23 <dmwit> ?pl \x y z -> 3 + y
02:07:23 <lambdabot> const (const . (3 +))
02:08:20 <jamy23> that the a troble whate pl is the only a lambdabot plugin
02:08:31 <dmwit> johnw: also http://stackoverflow.com/q/5701893/791604
02:08:33 <ivanm> jamy23: no it isn't
02:08:48 <ivanm> jamy23: you can get the pointless package from hackage, and then bind it to say :pl in ghci
02:08:54 <antalsz> jamy23: What are you trying to do, at a higher level?  Inside a running Haskell program, converting to point-free style doesn't make sense.
02:11:16 <jamy23> i am confused
02:11:16 <sgk284> hey all, quick question. I've got a data type with two constructors, and two different functions to handle each constructor. I don't care about the values in the constructors, so I'm matching with: fn bar@(Bar _ _ _) = ...
02:11:23 <sgk284> and fn baz@(Baz _ _) = ...
02:11:28 <sgk284> is there a better way to do this?
02:12:01 <dmwit> fn bar@(Bar {}) = ...
02:12:11 <sgk284> thank you!
02:13:48 <jamy23> ivanm: So we there have a package with methods for do point-free convertion?
02:13:55 <ivanm> no
02:14:01 <ivanm> just a utility that does the same as @pl
02:14:41 <ivanm> jamy23: unless you want to do some kind of AST transformation, why do you want a function to do point-free conversions?
02:14:46 <jamy23> they convert only text presentation of expression?
02:15:09 <ivanm> yes
02:15:21 <jamy23> Oh! I see...
02:15:27 <antalsz> jamy23: What else would they do?  Inside a running Haskell program, `\_ -> True` and `const True` are the same thing.
02:21:53 <jamy23> I dont want a function to do pointfree conversion. Its begining when i saw unknown construction on this chatroom
02:24:47 <jamy23> `\_ -> True` its only anonymous function which alltime return true than they equal to const true.
02:42:15 <jamy23> And what is "$$" mean?
02:42:31 <quicksilver> nothing standard
02:42:43 <quicksilver> it must be an operator defined by the code you're looking at or one of its libraries
02:43:12 <jamy23> its free name?
02:43:39 <dmwit> ?hoogle $$
02:43:39 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
02:43:39 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
02:43:39 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
02:44:15 <jamy23> ?hoogle <$>
02:44:16 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
02:44:16 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
02:45:15 <quicksilver> jamy23: not sure what you mean by 'free name'. Haskell has very few names in the language.
02:45:31 <quicksilver> it's mostly just the standard library, for various meanings of 'standard'
02:45:35 <quicksilver> and you don't have to use it all
02:45:41 <oish> I've got a type synonym, is it possible for me to implement Show for it in the same way I can with an algebraic data type.
02:45:56 <oish> I just want to get one of the fields out and print it.
02:46:14 <jamy23> I know. haskell its only a power lambda calculator
02:46:14 <ivanm> oish: you can, but you shouldn't
02:46:17 <Nereid> oish: -XTypeSynonymInstances exists, but you shouldn't
02:46:19 <quicksilver> oish: type synonyms are not really different types.
02:46:35 <ivanm> oish: unless you're not exporting the constructors, Show/Read should only be derived
02:46:38 <quicksilver> so you can't implement a different Show instance fro the underlying type.
02:46:42 <ivanm> and they should return/parse valid Haskell values
02:46:58 <Nereid> that and you shouldn't use TypeSynonymInstances in general.
02:47:00 <ivanm> don't use Show for pretty-printing
02:47:03 <oish> ok cool, thanks :-)
02:47:21 <dmwit> Everybody's got a different angle on how to answer this. Love it.
02:47:27 <quicksilver> Nereid: nothing wrong with typesynonyminstances.
02:47:38 <quicksilver> it's not a very interesting extension but it's not a problematic one.
02:47:59 <mysticc> I have a type family defined as Dual a .. and instances as say Dual A = B , Dual B = A etc.. I have a function which reads value of type A and it applies a function on value of type (Dual A) ..The conversion from A to Dual A takes place using unsafeCoerce .. so f a = somefn ((unsafeCoerce a) :: Dual (?) ..The problem is f is polymorphic in its argument..
02:48:05 <quicksilver> Why force to me to write an instance for Map [Char] when Map String feels more natural?
02:48:06 <Nereid> quicksilver: but it leads to confusion.
02:48:28 <mysticc> so what to give in place of ?
02:48:38 <dmwit> mysticc: 1. Don't do that. 2. ScopedTypeVariables
02:49:23 <dmwit> Nereid: Really? What confusion?
02:49:24 <ivanm> dmwit: I've been bitten _hugely_ when I first inherited Graphviz and it was using Show; I kept trying to keep using it until I gave in and wrote a proper pretty-printer
02:49:33 <mysticc> dmwit: Thanks
02:49:42 <dmwit> FlexibleInstances causes confusion sometimes, but I've rarely had TypeSynonymInstances cause confusion.
02:50:52 <dmwit> ivanm: I'm not really sure why that was aimed at me, but... I'm glad you got that all sorted out.
02:51:37 <ivanm> <dmwit> Everybody's got a different angle on how to answer this. Love it. <-- that's why :)
02:51:45 <ivanm> explaining the reasoning behind my angle :)
02:51:52 <lightquake> i wish there was a way to use a 'fake' show instance for ghci
02:52:18 <quicksilver> yes, it would be useful for ghci to have a more 'debug-type' structural pretty printer
02:52:20 <hpaste> dreugeworst pasted “parallel fannkuch” at http://hpaste.org/74844
02:52:37 <quicksilver> it is after all a language runtime - it ought to be able to introspect values without relying on user-provided code.
02:52:45 <lightquake> yeah
02:52:55 <quicksilver> still I don't find it bites me very often.
02:53:01 <lightquake> imo there needs to be some work done on ghci improvements
02:53:11 <quicksilver> occassionally when working with fiddly types it's useful to have some 'ghci helpers' to work with them.
02:53:15 <lightquake> yeah
02:53:18 <ivanm> there have been various attempts at pretty-printing Show output in ghci
02:53:29 <quicksilver> don't think that's what he means, ivanm
02:53:34 <ivanm> ahhhh
02:53:40 <dreugeworst> Hi, I was looking at the programming language shootout challenge fannkuch redux, and was wondering why the following parallel implementation gets slower as you add more threads
02:53:43 <dreugeworst> http://hpaste.org/74844
02:53:44 <quicksilver> he means ignoring show instances and just giving a structural representation of the data
02:53:54 <lightquake> yeah
02:53:55 <ivanm> example?
02:54:05 <dmwit> dreugeworst: (Your paste was already announced, by the way.)
02:54:27 <dreugeworst> dmwit: woops, yeah I see now
02:54:45 <lightquake> well, one idea would be to just use the Show derivation, and show fields such as a -> b that don't have showable representations as just "unrepresentable" or as their type
02:54:54 <lightquake> better than nothign
02:54:56 <lightquake> *nothing
02:56:06 <dmwit> dreugeworst: How are you compiling and running?
02:56:25 <dmwit> oh wait
02:56:40 <dmwit> This is a solution you cooked up, or is this the code from the shootout?
02:56:49 <dmwit> Oh, I'm looking at fannkuch-redux not fannkuch
02:56:50 <dreugeworst> I cooked it up yes
02:57:28 <dreugeworst> I just noticed the multicore shootout solution didnt use all cores a lot, so I was curious why
02:57:49 <dmwit> looks like it uses them to me...
02:57:55 <dmwit> CPU Load 99% 99% 96% 100%
02:58:52 <randomclown> is there a msum that doesn't stop at the first success?
02:59:00 <dmwit> :t msum
02:59:01 <dreugeworst> dmwit: http://shootout.alioth.debian.org/u64q/performance.php?test=fannkuchredux
02:59:01 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
02:59:13 <dmwit> :t sequence -- ?
02:59:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:59:17 <dreugeworst> the first haskell solution: 40% 37% 42% 35%
02:59:26 <randomclown> it seems that once one fails all of it fail
02:59:39 <randomclown> with sequence
02:59:41 <dreugeworst> so I tried changing it to use all cores more, but it gets slower instead
02:59:56 <newmind> dreugeworst: tried looking at it with threadscope?
03:00:34 <dreugeworst> newmind: not sure what threadscope is
03:00:58 <dmwit> dreugeworst: Have you tried just stealing the code from the other shootout?
03:00:58 <newmind> http://www.haskell.org/haskellwiki/ThreadScope
03:01:07 <dmwit> http://shootout.alioth.debian.org/u32q/benchmark.php?test=fannkuchredux&lang=ghc <- much better CPU load
03:01:20 <dreugeworst> newmind thanks
03:01:49 <fmap> randomclown: "stop at the first success"?
03:02:01 <fmap> ah, i guess you mean msum for Maybe
03:02:23 <dmwit> If you mean for Maybe, then you want catMaybes.
03:02:41 <dreugeworst> dmwit: huh, that's interesting. Not sure why it hasn't been used for x64 then =)
03:02:42 <liyang> catDefinitely!
03:03:00 <randomclown> is there a monad that supports this?
03:03:13 <jamy23> > map (+1) [1..10]
03:03:13 <randomclown> it's the ServerPart monad
03:03:14 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
03:03:24 <randomclown> on happstack
03:05:07 <newmind> i don't see what you want to do there.. either you return a response, or you don't and let the next serverpart try it
03:05:39 <randomclown> I'm looking for input for a list of checkboxes
03:05:49 <newmind> i can't exactly think of an obvious way to combine multiple responses
03:06:01 <randomclown> with "look"
03:06:08 <randomclown> and if one isn't there it just mzeros
03:06:12 <randomclown> the whole thing
03:08:01 <newmind> yes... and?
03:08:19 <randomclown> well browsers only sends the checkboxes that are checked
03:09:31 <newmind> ah, i see
03:10:17 <jamy23> I dont understand why this not spawn error: "> [1,2,3..10]", and this not: "> [1..10]"
03:10:32 <randomclown> so msum only gets me the first checked on, sequence fails if any of them are not checked
03:10:37 <randomclown> one*
03:10:40 <jamy23> Sorry!  I dont understand why this spawn error: "> [1,2,3..10]", and this not: "> [1..10]"
03:11:12 <paolino> > [1,2..10]
03:11:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
03:11:17 <quicksilver> jamy23: .. is special syntax
03:11:19 <int-e> jamy23: the first syntax is not defined.
03:11:39 <paolino> > [1,3..10]
03:11:39 <int-e> > 1 : 2 : [3,5..10]
03:11:40 <lambdabot>   [1,3,5,7,9]
03:11:40 <lambdabot>   can't find file: L.hs
03:11:57 <int-e> > 1 : 2 : [3,5..10]
03:11:58 <lambdabot>   [1,2,3,5,7,9]
03:12:04 <int-e> funny
03:12:21 <int-e> is lambdabot processing these queries concurrently?
03:12:45 <shachaf> More or less.
03:13:29 <jamy23> :t ..
03:13:30 <lambdabot> parse error on input `..'
03:13:43 <dmwit> .. is not an operator, it is a special syntactic form.
03:13:43 <int-e> it's syntax, not an infix operator
03:13:45 <newmind> randomclown: my haskell-foo isn't too strong, but shouldn't somethink like `myvalue <- msum [ look "mycheckbox", alternative_value ]` work?
03:13:53 <paolino> > enumFromTo 1 10
03:13:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
03:14:13 <paolino> @src Enum
03:14:13 <lambdabot> class  Enum a   where
03:14:13 <lambdabot>     succ                     :: a -> a
03:14:13 <lambdabot>     pred                     :: a -> a
03:14:13 <lambdabot>     toEnum                   :: Int -> a
03:14:13 <lambdabot>     fromEnum                 :: a -> Int
03:14:15 <lambdabot> [3 @more lines]
03:14:19 <jamy23> suggar :)
03:14:19 <paolino> @more
03:14:19 <lambdabot>     enumFrom                 :: a -> [a]
03:14:19 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
03:14:21 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
03:14:22 <int-e> > enumFromThenTo 1 3 10
03:14:23 <lambdabot>   [1,3,5,7,9]
03:14:33 <randomclown> > msum [ Nothing, Just 1, Just 2, Just 3, Nothing, Just 4 ]
03:14:34 <lambdabot>   Just 1
03:14:35 <dmwit> There are several related forms, actually: "[ e1 .. e2 ]" and "[ e1 , e2 .. e3 ]" and "[ e1 .. ]" and "[ e1 , e2 .. ]".
03:14:38 <dmwit> I think that's all of them.
03:14:43 <randomclown> newmind: see only the first one get returned
03:14:59 <randomclown> with msum
03:15:10 <paolino> > catMaybes [ Nothing, Just 1, Just 2, Just 3, Nothing, Just 4 ]
03:15:11 <lambdabot>   [1,2,3,4]
03:15:16 <newmind> yeah, but in your case look would return mzero, so it returns the next value
03:15:25 <int-e> dmwit: hehe. how about [..] = enumFromTo minBound maxBound :-))
03:15:41 <randomclown> need a more general form of catMaybes
03:16:00 <newmind> either way, something ends up in myvalue
03:16:05 <newmind> which you can use
03:16:07 <jamy23> enumFromTo "a" "z"
03:16:08 <randomclown> well I need 1,2,3,4
03:16:11 <randomclown> not just 1
03:16:20 <jamy23> > enumFromTo "a" "z"
03:16:21 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
03:16:22 <lambdabot>    arising from a use of `...
03:16:26 <int-e> > ['a'..'z']
03:16:27 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
03:16:30 <dmwit> > enumFromTo 'a' 'z'
03:16:31 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
03:16:47 <dmwit> > enumFromTo 1 5
03:16:48 <lambdabot>   [1,2,3,4,5]
03:16:51 <dmwit> > enumFromTo [1] [5]
03:16:52 <lambdabot>   No instance for (GHC.Enum.Enum [t])
03:16:52 <lambdabot>    arising from a use of `e_115' at <in...
03:17:26 <paolino> e_115 ?
03:17:43 <jamy23> @let alphabet = ['A'..'Z']
03:17:44 <lambdabot>  Defined.
03:17:45 <newmind> randomclown: you can use lookPairs to just get a list of parameters and their value
03:18:06 <jamy23> > alphabet
03:18:08 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
03:18:14 <merijn> How costly is it to wrap a haskell function into a FunPtr? (using foreign import ccall "wrapper")
03:18:14 <merijn> If that has any cost at all..
03:19:52 <jamy23> @let alphabet from to = [from..to]
03:19:52 <lambdabot>  <local>:9:0:
03:19:52 <lambdabot>      Multiple declarations of `L.alphabet'
03:19:52 <lambdabot>      Declared at: <l...
03:19:58 <randomclown> newmind: ah right, somehow missed it
03:20:23 <newmind> i still think there is a prettier way though
03:20:42 <jamy23> Where is my polymorphism? :)
03:20:50 <newmind> but some of the haskell-gods in here would have to help you out there :P
03:21:43 <jamy23> @let specialAlphabet from to = [from..to]
03:21:44 <lambdabot>  Defined.
03:21:48 <randomclown> cabal install haskell-gods
03:22:42 <jamy23> > specialAlphabet 'i' 'r'
03:22:43 <lambdabot>   "ijklmnopqr"
03:23:07 <int-e> merijn: it has a cost - it allocates a small "adjustor thunk" on the heap, a sort of trampoline for jumping into Haskell code from C
03:23:39 <int-e> merijn: that's the C heap, apparently. (reading rts/Adjustor.c in the ghc sources)
03:24:39 <merijn> int-e: I'm mostly interested in computational cost, space is not really something I'm worried about for any reasonable space usage
03:24:58 <jamy23> Anybody know good implementation SECDmachine on haskell?
03:27:13 <jamy23> desirable for ghc
03:27:36 <newmind> randomclown: bla <- msum[ look "bla", return "" ]
03:28:05 <newmind> this would bind bla to either the content of the parameter "bla" or to ""
03:28:11 <newmind> (adjust as needed)
03:29:54 <merijn> int-e: My problem is this: I have a loop that calls out to C, passing C a handle struct. C later calls back into haskell using said handle, to do this callback the struct stores a FunPtr to the haskell callback. So my choice is to partially apply the callback on each iteration and then convert it to FunPtr, or to store the extra argument in the struct and pass that argument to the haskell function when I actually do the callback
03:30:44 <jamy23> int-e: C has heap?
03:31:01 <merijn> If the wrapper only allocates a small amount of space it's probably more convenient to curry first, then convert to FunPtr, especially since I need to update the handle either way (change the FunPtr vs change the additional callback argument)
03:31:02 <int-e> jamy23: sure, for malloc and friends.
03:31:33 <randomclown> newmind: I suppose I could then just sequence those
03:31:48 <jamy23> Maybe its heap of os (process heap)?
03:31:51 <randomclown> sequence [ msum [look, default] , ... ]
03:32:59 <randomclown> > sequenceM [ msum [ Just 1, Just 0 ], msum [ Nothing, Just 0 ] ]
03:32:59 <lambdabot>   Not in scope: `sequenceM'
03:33:01 <jamy23> int-e: Maybe its heap of os (process heap)?
03:33:09 <randomclown> > sequence [ msum [ Just 1, Just 0 ], msum [ Nothing, Just 0 ] ]
03:33:10 <lambdabot>   Just [1,0]
03:36:17 <int-e> merijn: I can't answer your question without measuring (which I haven't done). But it's not just allocating some memory, it also has to create the trampoline code depending on the function signature.
03:36:36 <shachaf> foreign wrapper has to allocate special pages outside of the regular heap.
03:36:41 <shachaf> (Because they have to be executable.)
03:39:05 <merijn> shachaf: hmm, ok so I should probably avoid doing it more than once in that scenario
03:39:28 <shachaf> Why?
03:39:33 * shachaf has no idea what the scenario is.
03:39:45 <int-e> shachaf: right, it's using libffi for that actually.
03:40:28 <shachaf> Yes.
03:40:35 <shachaf> You also have to free allocated FunPtrs explicitly.
03:41:53 <jamy23> int-e: "...and friends" What friends?
03:42:06 <int-e> calloc, free
03:42:19 <jamy23> Oh! right!
03:42:48 <jamy23> But its only a systemcall, not part of the C
03:43:07 <merijn> shachaf: That's my point, it's probably more efficient to add an extra argument to my function type than it is to do a new conversion/free on every call
03:43:21 <int-e> it's part of C, and usually they are not system calls. system calls involved are brk(), traditionally, more likely mmap today - not sure what they use on windows.
03:43:33 <shachaf> merijn: Oh, you mean once per call? Yes, probably.
03:44:16 <jamy23> int-e: :-O crazy???
03:44:50 <astry> how can i compile haskell programs so that i can distribute only the binaries?
03:44:55 <shachaf> Windows doesn't really have "system calls" in the UNIX sense.
03:45:20 <astry> i'm only distributing to fairly similar systems, but not exactly same ones
03:45:20 <jamy23> int-e: if you wrote kernel module than you right
03:45:33 <int-e> jamy23: doing a system call (involving a context switch) for every allocation - that would be crazy.
03:46:23 <int-e> jamy23: you either don't know what a system call (as opposed to using a library function) is, or you don't know what you're talking about.
03:47:27 <Jafet> astry: ghc compiles to binaries.
03:48:43 <merijn> Hmm, if I have a value Foo with a CInt in it, is there a function "Ptr Foo -> CInt -> IO (Ptr Foo)" to change it? Or should I write it myself doing using peek to go Ptr Foo -> Foo, then update foo and then use poke to convert back Foo -> Ptr Foo?
03:49:26 <quicksilver> merijn: "a value Foo with a CInt in it" doesn't actually mean anything.
03:49:26 <merijn> (Actually, I guess "Ptr Foo -> CInt -> IO ()" would be a better signature for that)
03:49:33 <shachaf> merijn: ?
03:49:42 <quicksilver> but the various C haskell bridge things may have conveniences
03:49:51 <quicksilver> at least one of them have conveniences for C structs
03:49:55 <quicksilver> (and field setters)
03:49:57 <shachaf> What function are you asking for?
03:51:32 <jamy23> int-e: "The specific algorithm used to organize the memory area and allocate and deallocate chunks is interlinked with the kernel" (C) http://en.wikipedia.org/wiki/Memory_management#Dynamic_memory_allocation  section "Implementation"
03:52:37 <merijn> shachaf: I want to update a field inside a struct for which I have a Storable instance
03:52:47 <shachaf> What's Foo?
03:53:24 <merijn> shachaf: The Haskell datatype (with a Storable instance) for said struct
03:53:34 <int-e> jamy23: of course the memory ultimately is allocated by the kernel. but the idea is to satisfy as many allocation and deallocation requests as possible without involving the kernel. doing otherwise would be very inefficient.
03:54:28 * jamy23 face-hand
03:54:36 <merijn> brb, need to switch to a less sucky network
03:54:39 <int-e> jamy23: so the library function will allocate a rather big chunk of memory and return small chunks to the user code.
03:55:27 * jamy23 facepalm
03:56:03 <shachaf> merijn: How's the data type and Storable instance defined?
03:56:20 <merijn> shachaf: hsc file using bindings-DSL
03:57:07 <shachaf> I guess it depends on what code is being generated.
03:58:04 <merijn> Storable defines peek/poke, which read in and write out the entire data structure, which I can live with if necessary. But I was hoping there was a neater way
04:02:19 <killy9999> How do I eta0reduce such expression: (\e -> (d ++ " " ++ eName e)) ?
04:02:44 <DT`> @pl \e -> (d ++ " " ++ eName e)
04:02:44 <lambdabot> (d ++) . (' ' :) . eName
04:03:40 <jamy23> int-e: Sorry! Maybe i so long study Minix...
04:03:54 <DT`> killy9999, that, and also ((d ++ " ") ++) . eName
04:04:02 <killy9999> thanks
04:04:25 <shachaf> Don't do that!
04:04:37 <shachaf> ((d++).(" ")++) . eName
04:04:41 <shachaf> Er.
04:04:43 <rfw> hey #haskell, just a kind of weird question - were the ideas of structures and unions in C codified in parallel to the concept of ADTs?
04:04:46 <shachaf> ((d++).(" "++)) . eName
04:04:57 <int-e> killy9999: You can't eta-reduce it directly, since it's not of the form \e -> (...) e. You may transform it into seomthing equivaent as @pl does.
04:05:01 <shachaf> rfw: C unions aren't really like sum types at all.
04:05:07 <rfw> as in, the functional camp and the procedural camp came up with the ideas of structs/unions and product/sum types independently
04:05:14 <rfw> shachaf: i know :)
04:05:27 <rfw> i was just wondering if there was some kind of theoretical foundation for C structs/unions
04:07:03 <DT`> C unions kind of resemble actual union types.
04:07:13 <int-e> jamy23: Oh well. I got carried away a bit, too.
04:07:14 <typoclass> killy9999: i think points-free doesn't make sense in your case. you're not saving anything and it just gets harder to read. the lambda you mentioned is perfectly fine, imho
04:07:43 <shachaf> rfw: I suspect unions came about independently of sum types.
04:07:54 <rfw> shachaf: i do too
04:08:07 <rfw> just seeing if i can get away with claiming that in a blog post
04:08:18 <shachaf> More as a more convenient thing than casting the same memory address to different types than as something nice like sum types.
04:08:23 <shachaf> But I don't have a source. :-)
04:08:40 <rfw> i would think that finding a source on that would be painfully hard and not worth the effort
04:18:02 <hpc> did sigfpe's blog vanish?
04:20:08 <shachaf> Uh-oh.
04:22:17 <Botje> it's just in an infinite-dimensional space
04:22:21 <Botje> give it time, it'll be back
04:29:10 <merijn> @hoogle Ord a => [a] -> a
04:29:11 <lambdabot> Prelude maximum :: Ord a => [a] -> a
04:29:11 <lambdabot> Data.List maximum :: Ord a => [a] -> a
04:29:11 <lambdabot> Prelude minimum :: Ord a => [a] -> a
04:31:36 <LambdaDusk> hi, is it possible to do something like geo-indexing in haskell
04:32:48 * hackagebot hedn 0.1.6.0 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.6.0 (AlexanderBondarenko)
04:36:05 <typoclass> LambdaDusk: i bet it is, haskell is a general-purpose programming language
04:37:52 <t7> concatMap ftv $ catMaybes $ map (\tv -> Map.lookup tv s) ms   -- can i make this prettier ?
04:38:06 <hiptobecubic> @faq Can haskell do geo-indexing?
04:38:06 <lambdabot> The answer is: Yes! Haskell can do that.
04:39:15 <LambdaDusk> typoclass: I mean is there a sort of lib or an article or anything to make it easier for an idiot like me?
04:39:39 <shachaf> t7: Something like concat [ftv x | Just x <- map (`Map.lookup` s) ms]?
04:39:50 <shachaf> Probably that doesn't type-check but something vaguely alone such lines.
04:41:35 <t7> my first things was wrong, its:    concatMap (ftv . (\tv -> fromMaybe (TVar tv) (Map.lookup tv s))) ms
04:41:56 <stepcut> randomclown: you need to use the applicative instances for look
04:44:23 <stepcut> randomclown: with the RqData Applicative, you can try to look up all the parameters and then either get back a success value, or a list of all the failures
04:45:25 <merijn> ls
04:45:34 <merijn> hmm, cursed terminal >.>
04:45:54 <LambdaDusk> @jaq Can Haskell sort my life out and make me a better human?
04:45:54 <lambdabot> The answer is: Yes! Haskell can do that.
04:46:03 <LambdaDusk> great
04:46:31 <merijn> The first step is to officially join the Church of Church
04:46:57 <LambdaDusk> no the first step is to eat the Curry I just cooked
04:49:20 <typoclass> LambdaDusk: i don't know much about geo information. if i were you, i'd think about what problem you're attacking, then read around on wikipedia until you find an algorithm that looks relevant. folks in here can then help you implement or adapt that for haskell
04:53:49 <Cale> http://video.ias.edu/univalent/awodey -- nice talk about homotopy type theory
04:58:30 <LambdaDusk> @faq Can Haskell land me awesome jobs and lift me out of the misery?
04:58:31 <lambdabot> The answer is: Yes! Haskell can do that.
04:59:49 <merijn> Using DataKinds how can I convice GHC that a constructor is, in fact, not already declared, since the other declaration is promoted to the type level?
05:00:20 <shachaf> merijn: You should probably accompoany a question like that with code that doesn't work.
05:00:27 <amosr> will it make me a sandwich when I'm feeling down, perhaps go to the bottle shop for a sixpack of beer
05:01:13 <merijn> shachaf: The question is "data Foo = Bar | Baz -- promoted to type level using DataKinds; data SomethingElse = Bar | Baz -- value level constructors"
05:01:30 <shachaf> merijn: Oh. No, I don't think you can do that.
05:01:45 <shachaf> If something is promoted to type/kind it still exists as value/type.
05:02:43 <shachaf> I might be wrong so don't listen to me.
05:03:33 <typoclass> DataKinds is the thing that was very buggy, but is fixed in 7.6, right?
05:03:46 <shachaf> Was it?
05:04:46 <merijn> shachaf: No, it doesn't still exist as a value/type
05:04:48 <typoclass> or was it the type naturals thing ...
05:04:59 <merijn> shachaf: Because using it as such is an error
05:05:19 <merijn> typoclass: DataKinds is buggy (but also not officially supported) in 7.4
05:05:43 <merijn> It's supported in 7.6 (including type naturals, but no type level natural comparison yet, so it's a bit useless :p)
05:05:46 <typoclass> merijn: right, thanks. maybe i didn't misremember :)
05:07:22 <applicative> merijn, no you cant do that.  data Foo = Bar | Baz  thing; why do you want to?
05:08:44 <applicative> I think it would have been clearer in some ways if they had just let us declare kind Foo = Bar | Baz
05:10:59 <quicksilver> this way let them cheat a whole buch of things
05:11:07 <quicksilver> including module/identifier import/export
05:16:08 <shachaf> merijn: ?
05:16:39 <merijn> applicative: I want that because I need to write a GADT as existential wrapper for those two types (i.e. I have "data RecType = Control | Data" and "Record (t :: RecType)", but when I want to send both types over the same Chan I need a GADT to wrap them in and I figured the easiest/most readable thing would be to use GADT constructors named Control/Record
05:16:45 <shachaf> data Foo = Bar | Baz defines both the type Foo :: * and the kind Foo
05:17:08 <merijn> shachaf: No, because using Foo :: * in a file where you use kind Foo is a compile error
05:17:08 <shachaf> Which aren't really related to each other.
05:17:44 * shachaf must not be understanding the question.
05:18:51 <shachaf> Anyway, /me >>= sleep
05:19:05 <applicative> like so?  data RecType = Control | Data ; data Record :: RecType -> * where Control :: String -> RecordControl; Data :: Int -> RecType Data ?
05:19:10 <hiptobecubic> shachaf, what part of the world are you in?
05:19:27 <shachaf> @localtime
05:19:31 <lambdabot> Local time for shachaf is Mon Sep 17 05:19:07 2012
05:19:38 <amosr> @localtime
05:19:41 <lambdabot> Local time for amosr is Mon Sep 17 22:19:21 2012
05:19:45 <hiptobecubic> interesting
05:19:46 <amosr> magic!
05:20:05 <applicative> merijn, messed up the gadt
05:20:12 <applicative> merijn:  Record :: RecType -> * where Control :: String -> Record Control; Data :: Int -> Record Data ?
05:21:36 <applicative> That would just be two types with the same constructors, of course, one of them also being used as promoted
05:22:21 <applicative> if you declared RecType directly as a kind, maybe there woulldn't have been a name space clash
05:22:31 <merijn> applicative: No, the Record has like 5 constructors which all return "Record Control" or "Record Data" as result
05:22:35 <applicative> I mean, if they had mad it so
05:22:42 <applicative> made
05:23:00 <applicative> oh so where is your confllict, that is a legitimate position for Control and Data
05:23:15 <merijn> applicative: It's just that you can't have a Chan that accepts both "Record Data" and "Record Control" values so I have a "WrappedRecord" type which wraps the Record value while it is in the channel
05:23:41 <applicative> right, an existential; that is one of the typical devices
05:23:49 <merijn> data WrappenRecord where Control :: Record Control -> WrappedRecord; Data :: Record Data -> WrappedRecord
05:24:17 <merijn> But I guess I'll have to use Control' and Data' as WrappedRecord constructors
05:24:42 <Botje> WrappenRecord, Blinkenlight, what's next
05:25:09 <applicative> data W where W :: forall a . Record a -> W
05:25:28 <gabrielprioli> Hi everybody! This is my first time here. I'm having trouble with something. Should I just send my question right here?
05:25:39 <applicative> gabrielprioli: yes
05:25:45 <applicative> but paste code
05:25:50 <gabrielprioli> Thanks!
05:25:50 <applicative> @where hpaste
05:25:50 <lambdabot> http://hpaste.org/
05:25:51 <Botje> gabrielprioli: you can put big chunks of code/errors on hpaste.org
05:25:54 <merijn> applicative: If I do that I cannot unwrap the Record and get the appropriate type back
05:25:58 <gabrielprioli> It's more a genereal of a question
05:26:10 <gabrielprioli> sorry, general*
05:26:25 <applicative> merijn, some suitable song and dance is needed, yes
05:27:14 <gabrielprioli> I forked a package and made some changes to it but I don't understand how can I run my version of the package. Should I reinstall it with my modifications?
05:28:01 <typoclass> @remember applicative <merijn> If I do that I cannot unwrap the Record and get the appropriate type back <applicative> merijn, some suitable song and dance is needed, yes
05:28:01 <lambdabot> It is forever etched in my memory.
05:28:03 <applicative> but you should be able to pattern match if the result type is okay, f (W (Contr s)) -> Just s ; f (W(Dat n)) -> Nothing
05:28:40 <ivanm> @type \ f pa pb -> pure f <$> pa <*> pb
05:28:41 <lambdabot> forall a b a1 (f :: * -> *). (Applicative f) => (a -> b) -> f a1 -> f a -> f b
05:28:49 <ivanm> dammit
05:29:08 <merijn> applicative: I already know how to do what I want, I was just asking whether I'd be able to use value constructors with the same name as an existing type constructor (using DataKinds), to which the answer is apparently no
05:29:16 <ivanm> I'm trying to switch to applicative; what symbols do I need if I want to have it be of type "(a -> b -> c) -> f a -> f b -> f c" ?
05:29:37 <applicative> liftA2
05:30:05 <applicative> or \op x y ->  op <$> x <*> y
05:30:29 <applicative>  @type \ f pa pb ->  f <$> pa <*> pb
05:30:32 <typoclass> gabrielprioli: you can run 'cabal install' with no argument in the directory of your modified package. i think it's clearest if you give it a new version number (i once had a normal xmonad-0.9 and another xmonad-0.9 where i had been messing around, and it was confusing)
05:30:38 <ivanm> oh, I thought the op needed to be applicative as well *facepalms*
05:30:41 <applicative> @type \ f pa pb ->  f <$> pa <*> pb
05:30:43 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
05:31:26 <applicative> ivanm: if its an A (a->b) like a list of functions then you would do op <*> x <*> y
05:31:26 <gabrielprioli> thanks typoclass. But this is for everytime I want to run my files?
05:31:36 <ivanm> applicative: *nod*
05:31:37 <applicative> ivanm: since all three things are in applicative-land
05:31:40 <ivanm> that makes more sense now :)
05:34:30 <typoclass> gabrielprioli: if your package builds an executable, you can just do 'cabal build'. it will put the executable somewhere in the sub-directory dist/
05:35:10 <typoclass> gabrielprioli: the regular stuff like 'ghci SomeFileYouAreWorkingOn.hs' is of course also possible, cabal doesn't prevent that
05:36:05 <gabrielprioli> typoclass: That's what I wanted; just save the file and run without having to install it everytime. But it tries to access the module from the package that is installed
05:37:09 <ique> how do you install GHC 7.6.1 on Ubuntu? I can't find a distribution package for it and downloading the binary gives me a bunch of stuff where if I run ./configure it fails, is there an actual compiled binary anywhere?
05:37:23 <ivanm> ique: how does configure fail? :/
05:37:34 <ivanm> maybe you need to install some -dev packages first (like for gmp)
05:37:45 <ique> "error while loading shared libraries: libgmp.so.3"
05:37:54 <ique> right, so that's it then
05:38:34 <typoclass> gabrielprioli: hm, good question. maybe you could use 'ghc-pkg hide' on the package that's interfering
05:38:53 <ique> is there a list of the dependencies somewhere so I can install them?
05:40:44 <typoclass> ique: are you sure that ghc 7.6 is nowhere to be found? it must be in one of those small repositories that ubuntu has ("ppa" or what they're called)
05:41:10 <ivanm> typoclass: IIUC, only if someone has bothered to build it
05:41:17 <ivanm> since the PPA's are done by individuals and are unofficial
05:41:19 <ique> typoclass: I honestly don't know how I would go about searching for it
05:45:31 <ique> seemed to work to configure after doing apt-get'ing libgmp3c2
05:46:24 <typoclass> ique: good question. https://launchpad.net/ubuntu/+source/ghc has a link at the bottom ("untrusted archives"), but they don't seem to feature 7.6
05:47:04 <gabrielprioli> typoclass: I was trying what you said and it either doesn't work or I'm missing something that is obvious
05:47:53 <gabrielprioli> typoclass: what I'm doing is: editing the source code of the package and then I installed a new version, hid the other installed version and did "ghci MyFile.hs"
05:48:40 <gabrielprioli> typoclass: but it ghci says it cannot find the module because  it is a hidden member of the package
05:49:18 <typoclass> gabrielprioli: that probably means you accidentally hid the modified package, not the original one ...?
05:50:06 <gabrielprioli> typoclass: no, that part I got right =)
05:50:55 <hpaste> stepcut pasted “text depends cycle” at http://hpaste.org/74849
05:51:00 <t7> does mapM not work with StateT ?
05:51:09 <Baughn> mapM works with every monad.
05:51:29 <stepcut> anyway know how to make cabal happy here? this happens on a system where I just installed haskell platform
05:53:15 <typoclass> gabrielprioli: sorry i got to go now, but try running "ghc-pkg list" and put its output on hpaste. also the command that you tried and the error message you got. folks can help you better then
05:53:33 <gabrielprioli> typoclass: all right, man, thanks a lot!
05:54:06 <typoclass> @where hpaste
05:54:07 <lambdabot> http://hpaste.org/
05:54:16 <typoclass> gabrielprioli: didn't seem to solve very much so far, but you're welcome :-) see you
05:56:05 <rfw> @pf \f x = x >>= return . f
05:56:05 <lambdabot> Maybe you meant: bf pl
05:56:09 <rfw> @pl \f x = x >>= return . f
05:56:09 <lambdabot> (line 1, column 6):
05:56:09 <lambdabot> unexpected "="
05:56:09 <lambdabot> expecting pattern or "->"
05:56:14 <rfw> @pl \f x -> x >>= return . f
05:56:14 <lambdabot> fmap
06:01:22 <applicative> ique  http://www.vex.net/~trebla/haskell/haskell-platform.xhtml explains how to install all the platform things. you need the llc binary from llvm for compiling with -fllvm
06:02:19 <applicative> stepcut is there an -fno-tests or whatever for text
06:03:05 <stepcut> I tried --disable-tests, but it didn't change anything
06:03:21 <stepcut> there is no 'tests' flag explicitly listed in the text.cabal
06:03:32 <stepcut> it uses the normal cabal test stuff
06:05:31 <applicative> strange though, its insisting on getting the stuff needed for the tests. or is that normal behavior
06:05:48 <stepcut> i am now hoping that if I manual install all the things in the cycle that cabal install will be satisfied
06:05:59 <stepcut> as it stands now, I can't seem to cabal install anything that depends on text
06:06:16 <stepcut> even though I already have text installed via the platform
06:11:18 <stepcut> nope
06:11:25 <stepcut> still stoopid
06:14:41 <applicative> I take it the platform includes an older text, which cant be used
06:15:24 <stepcut> perhaps,but I already upgraded text
06:15:39 <stepcut> I actually have all the packages which the same versions in the errors messages installed now
06:15:46 <stepcut> but it is still pissed about the cycle
06:16:43 <applicative> hm xml is the one that needs text
06:18:21 <stepcut> yes
06:21:09 <stepcut> I have cabal-install 0.9.5 installed. I tried upgrading to 0.10.2.. but somehow that requires older versions of unix and other packages than what comes with the platform
06:21:45 <jamy23> Ansver to self: @hoogle secd
06:24:14 <Saizan> stepcut: go to 0.14.0
06:24:38 <stepcut> Saizan: which is not on hackage yet ?
06:24:56 <Saizan> it is, but not preferred
06:26:19 <applicative> can he build it with his ghc?
06:26:37 <applicative> oh I'm using 0.14
06:27:53 <stepcut> Saizan: oh, you mean Cabal not cabal-install
06:28:08 <stepcut> I already have Cabal-0.14.0 installed -- comes with platform
06:28:34 <Saizan> stepcut: http://hackage.haskell.org/package/cabal-install-0.14.0
06:28:37 <jamy23> http://hackage.haskell.org/package/ghc-heap-view
06:28:39 <applicative> Saizan meant cabal-install I think but I suppose you cant separate them
06:30:05 <applicative> you can get it from hackage by specifying the version , somehow otherwise they hid it
06:30:22 <stepcut> oh, I see
06:30:47 <stepcut> cabal unpack cabal-install does 0.10.2, I had to do, cabal unpack cabal-install-0.14.0
06:32:13 <applicative> right, i think in the past the tendency to go for the most recent with cabal-install produced chaos for older ghcs installing Cabal and base or whatever
06:33:03 <stepcut> ok, upgrading to cabal-install-0.14.0 makes everything happy!
06:33:04 <stepcut> thanks
06:51:05 <Blkt> good day everyone
06:53:45 <vikt0r0> @undo pop ; pop ; pop
06:53:46 <lambdabot>  Parse error at ";" (column 5)
06:54:05 <vikt0r0> @undo do pop ; pop ; pop
06:54:05 <lambdabot> pop >> pop >> pop
06:54:29 <dimka> What is the best way to match String with perl/posix regular expression? String → Expr → Bool
06:54:38 <dimka> Best and easiest
06:54:44 <vikt0r0> @undo do pop ; x <- pop; pop
06:54:44 <lambdabot> pop >> pop >>= \ x -> pop
06:54:46 <Botje> did you look at Text.Regexp?
06:58:42 <killy9999> I'm writing a list comprehension that uses a predicate that returns Maybe
06:59:08 <killy9999> how do I continue computation when I get Just sth?
06:59:29 <bartavelle> why do I get 404 when doing cabal upload ? grrr
06:59:29 <killy9999> I mean I want to act Nothing as if preficate returned False
06:59:49 <bartavelle> ok got it
07:00:43 <Botje> killy9999: you could use isJust (computation)
07:00:53 <hiptobecubic> @src isJust
07:00:54 <lambdabot> isJust Nothing = False
07:00:54 <lambdabot> isJust _       = True
07:00:55 <Botje> or the maybe function
07:00:59 <hiptobecubic> Ah.
07:01:00 <Botje> :t maybe
07:01:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:01:15 <Botje> maybe False (const True) (computation)
07:01:17 <killy9999> hm...
07:01:39 <killy9999> I have to think about ir for a moment
07:03:25 <killy9999> OK, a hypothetical non-working example: [ y | y <- provideData, z <- lookup (unitPrice y) index ]
07:03:47 <killy9999> [ y | y <- provideData, z <- lookup (unitPrice y) index, z == 2 ]
07:04:01 <Botje> oh.
07:04:09 <killy9999> like this - if I get the value of z I want to use it in further part of comprehension
07:04:11 <Botje> Just z <- lookup ...
07:04:25 <killy9999> briliant
07:04:42 <killy9999> wow, I even understand why this works
07:04:45 <Botje> if lookup returns Nothing the comprehension continues with the next element of provideData
07:05:02 <hiptobecubic> Botje, i didn't realize that
07:05:09 <killy9999> pattern matching fails within a monad - I was thinking how could I cause that
07:05:19 <Botje> @src catMaybes
07:05:19 <hiptobecubic> All the terms after  | are predicates then? Just some also bind on success?
07:05:19 <lambdabot> catMaybes ls = [x | Just x <- ls]
07:05:29 <Botje> ^^ another example
07:05:48 <Sculptor> hi
07:05:54 <Botje> hiptobecubic: all the terms after | are either generators (x <- xs), predicates (foo), or let bindings.
07:06:14 <Botje> it can happen that a generator fails to pattern match, in which case the fail of the [] monad is invoked
07:06:42 <killy9999> :r
07:06:45 <killy9999> sorry
07:07:00 <hiptobecubic> Botje, why does it bother with fail if the comprehension syntax is only for lists?
07:07:27 <killy9999> hm...
07:07:36 <Botje> hiptobecubic: that's how *I* rationalize it ;)
07:07:41 <hiptobecubic> oh
07:07:45 <hiptobecubic> @src [] fail
07:07:45 <lambdabot> fail _      = []
07:07:46 <killy9999> [ y | y <- provideData, Just z <- lookup (unitPrice y) index ]
07:07:51 * hackagebot language-puppet 0.1.7.2 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.1.7.2 (SimonMarechal)
07:07:53 <killy9999> what am I doing wring?
07:08:15 <killy9999> Couldn't match expected type `[t0]' with actual type `Maybe b0'
07:08:27 <killy9999> looks like I can't pattern match like this
07:08:28 <hiptobecubic> @src IO fail
07:08:28 <lambdabot> fail s  = failIO s
07:08:35 <hiptobecubic> @src failIO
07:08:35 <lambdabot> failIO s = ioError (userError s)
07:08:41 <Botje> killy9999: sure you can, catMaybes also works like that.
07:08:56 <t7> bit of a longshot but; has anyone read "generalizing hindley milner type inference algorithms" ?
07:09:03 <Botje> killy9999: oh, duh. lookup returns Maybe, not a list.
07:09:14 <Botje> killy9999: Just z <- [lookup ...]
07:10:23 <killy9999> well, it returns Maybe - that's why I'm matching against Just, right?
07:11:04 <Botje> yes
07:11:14 <Botje> but the <- generator requires the right-hand side to be a list
07:11:22 <Botje> so make it Just z <- [ lookup ... ]
07:11:55 <killy9999> ok
07:13:12 <vikt0r0> Can anyone explain to doing 'do c1 ; c2' will result in a stateful computation that yields the same result as runState c2 (runState c1 s) when used on s? When i make the computation on pen and paper it seems that c2 is applied to s first :-S
07:13:45 <vikt0r0> Wow, a lot of grammatical errors, sorry for that.
07:14:03 <Botje> vikt0r0: I think your pen & paper thing was wrong then.
07:14:24 <vikt0r0> Okay.
07:15:09 <vikt0r0> Thanks, I'll try again then.
07:15:22 <Saizan> runState c2 (runState c1 s) is not quite type-correct
07:16:06 <quicksilver> execState, presumably
07:16:07 <killy9999> can I fuse (filter p) . (filter q) into one filter?
07:16:18 <killy9999> filter (\x -> p x && q x)
07:16:25 <killy9999> is there a more elegant way?
07:16:29 <eyebloom> Does anyone have a moment to discuss a difficult type matching question involving DSLs?
07:16:34 <vikt0r0> No, i just wrote it on top of my head, did not actually do 'runState ...'
07:16:53 <hiptobecubic> killy9999, filter is lazy. It acts fused.
07:16:59 <vikt0r0> But i guess that would be the semantics… Kind of… That c1 should be applied, then c2
07:17:34 <hiptobecubic> @pl filter p . filter q
07:17:34 <lambdabot> filter p . filter q
07:17:50 <killy9999> so there will be no difference in performance?
07:18:02 <Botje> killy9999: none whatsoever.
07:18:06 <hiptobecubic> well you can test it easily, but it shouldn't make any intermediate lists or anything.
07:18:24 <Botje> (although filter p . filter q is filter (\x -> q x && p x) instead of p x && q x)
07:18:45 <killy9999> Botje: right
07:18:55 <Botje> (also, you could write it as liftA2 (&&) q p)
07:19:06 <hiptobecubic> Botje, liftA2... that's what i wanted
07:19:15 <hiptobecubic> I was trying to figure out what it would
07:19:21 <hiptobecubic> be, using ap
07:19:56 <hiptobecubic> @src (-> r) liftA2
07:19:56 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:20:01 <hiptobecubic> :(
07:20:10 <hiptobecubic> Lambdabot is so rude.
07:20:20 <hiptobecubic> @src liftA2
07:20:20 <lambdabot> liftA2 f a b = f <$> a <*> b
07:20:32 <hiptobecubic> @src ap
07:20:32 <lambdabot> ap = liftM2 id
07:20:45 <hiptobecubic> @src liftM2
07:20:45 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:22:23 <vikt0r0> @src (State) (>>=)
07:22:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:22:50 <Botje> hiptobecubic: (&&) `ap` q `ap` p also works.
07:22:56 <Botje> uh
07:22:59 <Botje> return (&&) `ap` ...
07:23:10 <merijn> Is there something like "assert True" or should I just use error for those scenario's?
07:23:25 <hiptobecubic> merijn, what would "assert True" accomplish?
07:24:11 <merijn> hiptobecubic: assert :: Bool -> a -> a exits with a line number if Bool is false
07:24:57 <merijn> hiptobecubic: I basically want to have a function that is missing some patterns, but it shouldn't warn about incomplete patterns. I just want it to print an "some invariant was horribly invalidated" error
07:25:52 <applicative> vikt0r0: m >>= k  = StateT $ \s -> do {(a, s') <- runStateT m s; unStateT (k a) s'}
07:26:31 <applicative> missed an r there ...
07:26:51 <hiptobecubic> merijn, so the last pattern is   foo _ = error "DISASTER"
07:27:51 <vikt0r0> applicative: I am reading the LYAH chapter about state monads. The implementation he presents looks different, but I'll try and compare it with this one.
07:28:24 <applicative> vikt0r0: does he use on without StateT?
07:28:55 <vikt0r0> applicative: The one he uses is just called State.
07:29:17 <merijn> hiptobecubic: Yeah, I was just hoping to get assertion's automatic line number listing
07:29:19 <vikt0r0> applicative: But it seems what you are doing is equivalent.
07:29:34 <applicative> hm, what is the link?
07:29:41 <applicative> chapter or whatever
07:29:42 <hiptobecubic> merijn, then you want (assert False) undefined  no?
07:29:51 <merijn> hiptobecubic: assert is turned of by -O
07:29:52 <vikt0r0> applicative: http://learnyouahaskell.com/for-a-few-monads-more
07:30:02 <hiptobecubic> merijn, hmmm
07:30:08 <vikt0r0> applicative: under 'Tasteful stateful computations' :-)
07:30:14 <merijn> hiptobecubic: I'll just use error
07:30:21 <applicative> vikt0r0: oh, I see, yeah.  To follow that, you should just use the State type he gives you
07:30:27 <hiptobecubic> there must be something that gives you current source line?   haskel-src-exts or something?
07:30:51 <applicative> vikt0r0: the more recent versions of the main libraries use a more complicated type
07:31:32 <merijn> vikt0r0: StateT is slightly different from State, it's a monad transformer that wraps around an existing monad and adds State capabilities to it. For learning and just startin State should be simpler and sufficient
07:31:45 <applicative> vikt0r0: I was thinking of making a package 'monad-sensible' with the older version of State, Writer and Reader, which are all now more complicated.\
07:31:55 <merijn> applicative: State still exists
07:32:08 <applicative> yes as a synonym
07:32:25 <applicative> merijn: Its just that a lot of tutorials and stuff presuppose the other types.
07:32:35 <hiptobecubic> merijn, Debug.Trace.Location?
07:32:47 <hiptobecubic> or does Debug also get pruned with -O
07:32:50 <merijn> applicative: I guess
07:33:03 <eyebloom> From which version of GHC are polymorphic kinds supported?
07:33:05 <applicative> even LYAH
07:33:17 <merijn> eyebloom: 7.4 at least, because I used them with 7.4 :p
07:33:19 <applicative> eyebloom: 7.4 sort of; 7.6
07:33:20 <robstewartuk> eyebloom: 7.6
07:33:37 <applicative> robstewartuk s answer is correct, thats when they are "supported"
07:34:09 <applicative>  but you can do a lot of things with 7.4
07:34:36 <merijn> vikt0r0: Actually, if you see a type ending in a capital T you can pretty much assume it is similarly a monad transformer to add certain capabilities to an existing monad. (And then immediately forget about that detail for now :p)
07:34:42 <eyebloom> Does anyone know of actual working example code that uses them?
07:35:18 <peopleHands> Real world haskell has an example of directory traversing if you're talking about transformers (:
07:35:31 <peopleHands> (which is what I just joined to talk about)
07:35:32 <applicative> eyebloom: you mean 'working' in the sense of doing something sensible?
07:35:41 <merijn> eyebloom: According to the guide you don't need to do anything
07:35:41 <applicative> i mean practical?
07:35:41 <robstewartuk> Support in ghc 7.6: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/kind-polymorphism.html
07:35:55 <applicative> oh the red black trees were an excellent demo
07:35:56 <merijn> eyebloom: It says un annotated kinds are polymorphic by default
07:35:58 <vikt0r0> applicative: I see it now. I must've gotten it wrong somehow, but an expression like c1 >> c2 evaluates to c1 >>= (\_ -> c2) which in turn is (\s -> runState g newState) where (a, newStathe) = runState c1 and (State g) = f a. Makes sense.
07:36:09 <robstewartuk> I'm hoping this resolves my stack overflow question I asked a few months back ;-) http://stackoverflow.com/questions/11488379/haskell-error-cannot-derive-well-kinded-instance-kind-mismatch
07:36:50 <vikt0r0> applicative: Actually, I am ashamed to say that I have no idea of what a monad transformer is.
07:36:58 <eyebloom> I see I've just been reading "Haskell get's a promotion" and the example code uses a lot of symbols that it would be great to see in straight ASCII
07:37:37 <applicative> eyebloom: this is rampions code, i put datakinds on it https://gist.github.com/2660297
07:37:46 <merijn> applicative: As I just said, they're used to transform an existing into one that has extra capabilities. i.e. transforming the Maybe monad into "Maybe monad with state"
07:37:49 <merijn> eh
07:37:53 <merijn> s/applicative/vikt0r0
07:38:10 <vikt0r0> merijn: aha
07:38:38 <vikt0r0> merijn: Makes sense, at least i can see how it's useful.
07:38:49 <merijn> eyebloom: Is that about DataKinds and promoted literals? Because I've been working on code that uses that to show you how you could use it
07:39:08 <applicative> eyebloom: oh the original has nice back and forth with simon pj https://gist.github.com/2659812
07:39:19 <peopleHands> What does ask do in the reader monad?
07:39:28 <vikt0r0> merijn: Oops, didn't see your first message there :)
07:39:34 <merijn> vikt0r0: np :)
07:40:09 <hpaste> eyebloom pasted “Polymorphic” at http://hpaste.org/74851
07:40:21 <merijn> vikt0r0: Like I said, it's useful to know what it approximately does, but not worth worrying about when just starting. Just remember it so that in the future when you think "I wish maybe had state" you know where to start looking ;)
07:40:32 <eyebloom> Well for example this piece of code above gives me a parse error.
07:40:44 <eyebloom> Granted I have no idea what I'm doing.
07:40:48 <applicative> ask gets the environment, peopleHands
07:41:13 <peopleHands> ...I see further reading is required (: Thanks for the help
07:41:32 <eyebloom> I'm just experimenting with ways to make a type that could maybe deconstruct a base type depending on if it contains an arrow.
07:43:08 <merijn> @hoogle m Bool -> m ()
07:43:08 <lambdabot> GHC.Conc.Sync always :: STM Bool -> STM ()
07:43:08 <lambdabot> GHC.Conc always :: STM Bool -> STM ()
07:43:08 <lambdabot> Control.Monad.STM always :: STM Bool -> STM ()
07:43:22 <vikt0r0> merijn: I actually have to write an interpreter for a homework assignment, and i think that it might be relevant in that context. I haven't even wrapped my head around the State monad yet, so I can not be sure :-)
07:43:48 <sithisbitch> You read real haskell world ?
07:43:53 <applicative> peopleHands: so in ReaderT config IO x, something like :  config <- ask; dependOn config; dependOn2 config would typical;
07:45:24 <peopleHands> applicative: I see what you mean, I'm reading RWH and trying to find a use for it. I'm a bit new to all of this
07:46:02 <hpaste> merijn pasted “Can this repetition be simplified without record syntax?” at http://hpaste.org/74852
07:47:00 <Eduard_Munteanu> peopleHands: don't forget 'asks' if you're using a record as your config.
07:47:04 <Eduard_Munteanu> :t asks
07:47:05 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
07:47:23 <fmap> merijn: lens? :)
07:47:27 <Eduard_Munteanu> You can say foo <- asks fooField
07:48:00 <applicative> it could be simplified with lenses for the field
07:48:10 <merijn> fmap: Good point
07:48:11 <applicative> oh as fmap is saying.  fields
07:53:41 <applicative> vikt0r0: yeah, I see for Reader and Writer LYAH also gives the 'old' definitions.  You should just use his type and his monad instance and scrap the import Control.Monad.X
07:55:48 <vikt0r0> applicative: Okay. Also wondering: I am unable to use State as a value constructor. In LYAH he uses it, but i have to make the s lowercase.
07:56:30 <vikt0r0> applicative: Thought it was kind of odd, but could it be because the 'old' definitions were changed?
07:56:35 <applicative> victor, yes, state x is like State x, but it puts the trivial Identity wrapper on
07:56:47 <quicksilver> vikt0r0: you are mistaken about something at least - constructors can never be lowercase.
07:57:03 <quicksilver> oh, I see now what you meant
07:57:04 <Eduard_Munteanu> You don't really need to mess with the constructor.
07:57:05 <quicksilver> sorry :)
07:57:19 <vikt0r0> quicksilver: But that
07:57:25 <quicksilver> State is no longer a constructor at all in the new StateT Identity implementation
07:57:26 <Eduard_Munteanu> Just use runState and friends.
07:57:29 <vikt0r0> 's what i didn't understand.*
07:57:35 <quicksilver> but 'state' is a function (not a constructor)
07:57:39 <applicative> it's just that Control.Monad.State uses a fancier type, StateT , State is not a constructor, but a type synonym State s a = StateT s Identity a
07:57:44 <quicksilver> which can be used to construct State objects
07:58:06 <vikt0r0> But how come i can write: push :: Int -> State Stack () push a = state $ \xs -> ((),a:xs)
07:58:42 <applicative> because state is a function from a -> (a,b) to a -> Identity (a,b)
07:58:47 <vikt0r0> state just wraps it in a state context?
07:58:50 <vikt0r0> Aha
07:59:32 <quicksilver> applicative: ?
07:59:34 <vikt0r0> I am not sure i get it though :-/
07:59:39 <Eduard_Munteanu> You might as well use 'modify'.
08:00:07 <quicksilver> applicative: surely state is a function from (a -> (a,b)) to State a b ?
08:00:19 <Eduard_Munteanu> push a = modify (a:)
08:00:37 <applicative> quicksilver: yes, sorry, I was focussing on the other wrapping that is happening nin this case
08:00:41 <vikt0r0> And definitely not sure why the LYAH author uses State, verbatim: "push a = State $ \xs -> ((),a:xs)"
08:00:50 <applicative> quicksilver: not he is using the synonym State in the signature.
08:01:08 <Eduard_Munteanu> Probably so you understand how State itself works.
08:01:15 <applicative> vikt0r0: this will all be much simpler if you scrap import Control.Monad.State
08:01:40 <vikt0r0> applicative: What does that imply? Can I still use the State monad?
08:01:41 <applicative> vikt0r0: just replace it with his definitions.  he isn't using the new Control.Monad.State
08:01:53 <quicksilver> vikt0r0: because in the old version of the library, "State" was a constructor.
08:01:54 <vikt0r0> Yes he is: import Control.Monad.State
08:01:58 <applicative> vikt0r0: you can define the state monad, he does it right there
08:02:03 <quicksilver> and you could construct objects directly.
08:02:09 <applicative> vikt0r0: the problem is that it's out of date
08:02:25 <quicksilver> vikt0r0: both the old and new states used the module name 'Control.Monad.State'
08:02:30 <applicative> State isn't defined as he defined it
08:02:32 <vikt0r0> Aha
08:02:38 <vikt0r0> I get it
08:03:05 <applicative> this was after a fairly gruesome crisis with the more advanced but more useful StateT and company
08:03:56 <applicative> if you just use the combinators get put and so on, I think old code will compile, but not e.g. State as a constructor
08:03:59 <quicksilver> there is a tension between the sensible inclination of libraries to provide abstract interfaces
08:04:15 <quicksilver> and the sensible inclination of *teachers* to teach to the concrete implementation
08:04:20 <quicksilver> because tehre is more to learn that way
08:04:23 <quicksilver> and it seems less magic.
08:04:31 <applicative> someone should write Control.Monad.Tutorial.State Control.Monad.Tutorial.Reader etc
08:05:01 <applicative> similarly actually for Parsec, just the really simple type String -> [(String, a)] and so on
08:05:41 <applicative> or maybe a package old-tutorial ...
08:05:47 <merijn> vikt0r0: Basically "Identity" is the trivial monad that does nothing. And as I explained StateT is just a transformer that adds State capabilities to an existing monad. "State s a" is now defined as being "StateT s Identity a". The wrapper around Identity functions identical to what LYAH explains, but does result in State no longer being a valid constructor
08:05:58 <atriq> I really don't want to be the person who writes Control.Monad.Tutorial.Cont
08:06:06 <merijn> vikt0r0: The "state" function was added to mimic the behaviour of the old State constructor
08:06:10 <atriq> Or Control.Monad.Tutorial.List, either
08:07:15 <atriq> @djinn (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> (b -> r) -> r
08:07:15 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e d)))
08:07:22 <applicative> vikt0r0: you might take a look at the famous tutorial of sigfpe at this point
08:07:26 <applicative> @google you could have invented monads
08:07:27 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
08:08:56 <vikt0r0> Okay, but i should probably go with the state function and the Control.Monad.State module for future projects, right?
08:09:13 <applicative> he is using the types LYAH defines for you not the moderne StateT WriterT
08:09:27 <atriq> @pl \a b c -> b (\d -> a (\e -> c (e d)))
08:09:27 <lambdabot> flip (.) . (. ((. flip id) . (.))) . (.)
08:09:30 <atriq> ...
08:09:31 <applicative> vikt0r0: yes, it's just another little turn of the conceptual crank
08:09:54 <Eduard_Munteanu> vikt0r0: if you even need the 'state' function to begin with
08:10:07 <applicative> vikt0r0: they are much more useful anyway
08:10:30 <vikt0r0> applicative: Aha
08:13:08 <applicative> vikt0r0: so for example for a game state, you might use StateT Game IO a as the main business then you keep getting and putting to the Game state according to IO stuff
08:14:26 <applicative> vikt0r0: whereas with State as defined in LYAH you can only put to change state with a pure function that depends on what you get
08:15:25 <vikt0r0> applicative: Might be a stupid question, but what is a 'pure' function in this context?
08:15:45 <applicative> just no IO is all I was meaning
08:15:50 <vikt0r0> applicative: Sorry, maybe all of this will be clearer by the time i finish the chapter :-)
08:15:54 <vikt0r0> Aha
08:15:58 <bartavelle> funny how applicative tells it
08:16:09 <bartavelle> (pure and applicative functors, joke)
08:16:49 <applicative> his tick >> tick >> tick is a pure computation, runState $ tick >> tick >> tick extracts a function that you can supply the initial state with. So it adds one to the starting point three times
08:16:55 <vikt0r0> bartavelle: Dadum-tschhh.
08:17:23 <applicative> @type runStateT
08:17:24 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
08:17:35 <applicative> @type execStateT
08:17:36 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
08:17:56 <vikt0r0> *hides*
08:18:15 <bartavelle> :)
08:18:53 <vikt0r0> applicative: I am not familiar with that notation… But i get the semantics of the runState...
08:19:02 <vikt0r0> Where do you see the tick >> tick >> tick?
08:19:13 <applicative> oh, he's using push and pop, not the other standard tutorial example
08:19:21 <vikt0r0> Oh yes.
08:19:39 <vikt0r0> Yes. I get that.
08:20:52 <vikt0r0> My problem was that I somehow thought that c1 >> c2 = c2 >>= (\_ -> c1) and not the other way around
08:21:04 <vikt0r0> So the functions got applied in reverse order.
08:21:10 <vikt0r0> When i did the pen and paper
08:22:39 <vikt0r0> Or computations, i guess would be the correct term.
08:24:03 <merijn> @tell edwardk Probably to late to change, but the argument order of over seems reversed. With "flip over" you could write "myComputation `over` myLens", I find "myLens `over` myComputation" looks odd
08:24:03 <lambdabot> Consider it noted.
08:25:25 <hpaste> applicative pasted “tick tick tick ” at http://hpaste.org/74853
08:25:50 <applicative> vikt0r0: here's the tick example, it's in the comments for Control.Monad.State or somewhere
08:26:00 <Saizan> merijn: maybe there's an infix operator that does the same as over already?
08:26:31 <fmap> %~
08:27:53 * hackagebot MFlow 0.1.5.0 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.1.5.0 (AlbertoCorona)
08:28:04 <hpaste> applicative annotated “tick tick tick ” with “tick tick tick  (annotation)” at http://hpaste.org/74853#a74854
08:28:23 <applicative> vikt0r0: ^^^ has a right type signature for something
08:30:39 <merijn> Saizan: Maybe, but the haddock documentation is a bit cryptic for mere mortals :p
08:31:02 <merijn> fmap++
08:31:11 <ahobo|work> lol
08:31:19 <fmap> merijn: there is https://github.com/ekmett/lens/wiki/Operators
08:31:35 <merijn> Althought I suspect people unfamiliar with Control.Lens would think `over` is more readable
08:33:53 <merijn> The lenses help make the replication less verbose, but I'm still offended by some of the repetition I have in my code. Although I suspect the type system won't let me merge said repetition
08:34:07 * killy9999 i simpressed after reading first chapter of Bird's "Pearls of Functional Algorithm Design"
08:34:17 <hpaste> merijn annotated “Can this repetition be simplified without record syntax?” with “Can this repetition be simplified without record syntax? (annotation)” at http://hpaste.org/74852#a74855
08:34:22 <sithisbitch> Maybe it's your type definition which force you to repeta code
08:34:49 <merijn> sithisbitch: It is, I already know that. But that still annoys me :)
08:35:24 <sithisbitch> Factor your type definition and you'll can factor your code.
08:36:19 <hpaste> applicative annotated “tick tick tick ” with “tick tick tick  (annotation)” at http://hpaste.org/74853#a74856
08:36:19 <merijn> No, because changing the type definition will remove the safety I introduced with it
08:36:24 <applicative> vikt0r0: here's one with trivial IO thrown in so you can see the purpose of the 'transformer' version, StateT  ^^^
08:36:34 <vikt0r0> applicative: That makes sense. The sigfpe article looks pretty good too.
08:37:40 <sithisbitch> merijn, In my country there is an expression "You can't have the butter and the money of the butter" :)
08:38:10 <hpaste> fmap annotated “Can this repetition be simplified without record syntax?” with “Can this repetition be simplified without record syntax? (annotation) (annotation)” at http://hpaste.org/74852#a74857
08:38:20 <fmap> merijn: can't you do something like that?
08:38:32 <vikt0r0> applicative: What does 'get' do?
08:38:53 <applicative> in us we say, 'you can't have your cake and eat it' sithisbitch
08:38:59 <vikt0r0> applicative: and 'put'
08:39:10 <sithisbitch> Ok, i'll try to remember it
08:39:17 <applicative> vikt0r0: it recovers the state, whatever it is, at that point. put x makes the new state be x
08:40:09 <fmap> that probably just moves duplication to lens code though
08:41:02 <applicative> vikt0r0: so when i ask ghci to do execStateT three 3 I give initial state 3. the first tik updates to four, and prints "Tick" , the next tick updates to 5 and prints "Tick" etc
08:41:58 <merijn> fmap: I can't do that because the constructors are GADTs, the different constructors actually produce different output types
08:43:32 <vikt0r0> applicative: What about it's type: StateT Int IO (). It means that it takes Int as a state, IO as a monad and () as the result of the computation? If one can say it that way?
08:44:21 <applicative> vikt0r0: yes, in this case nothing is returned, it just updates the state and does a little IO
08:44:22 <Eduard_Munteanu> vikt0r0: yes
08:44:55 <merijn> vikt0r0: Yes. "StateT Int IO" adds an int state to the IO monad, so "StateT Int IO ()" is a stateful IO computation, using an Int state and returning () as result of the computation
08:45:31 <vikt0r0> Ah!
08:45:51 <Cale> btw, using StateT to transform IO is frequently a silly thing to do, because IO already has a *ton* of facilities for statefulness.
08:47:09 * merijn hides his 5 "StateT a IO" definitions
08:47:14 <Cale> and the extra syntactic overhead of using StateT is usually equally bad if not worse compared to passing an extra IORef around (say)
08:47:22 <vikt0r0> applicative: I am still not sure about what it means for 'get' to recover the state, but maybe it is not necessary to know at this point.
08:47:29 <Cale> There are some arguments which can be made in its favour :)
08:47:39 <merijn> vikt0r0: Well, you added state to the computation, right?
08:47:49 <merijn> vikt0r0: Presumably at some point you want to inspect, that state
08:47:49 <Cale> but it has been a little overused
08:47:52 <merijn> :t get
08:47:53 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
08:47:53 <dunric> forall s (m :: * -> *). MonadState s m => m s
08:48:03 <merijn> Oh, unlucky definition
08:48:13 <vikt0r0> Yes, i checked that too
08:48:21 <vikt0r0> But I am not sure what to make of it.
08:48:23 <merijn> vikt0r0: Mentally replace the type of get with "StateT Int IO Int"
08:48:26 <Ferdirand> what if you want to write polymorphic code that usually runs under IO, but sometimes you want to clone or destroy the state ?
08:48:46 <quicksilver> it's very useful for polymorphism
08:48:53 <quicksilver> however the liftIOs can be infuriating
08:48:56 <merijn> or "StateT s m s", that is, for a stateful computation in the m monad, return a value of the same type as the state
08:49:09 <quicksilver> how annoying it is is directly proportional to the number of lifts you end up doing
08:49:17 <merijn> quicksilver: I just have a handful of pre-lifted IO operations
08:49:41 <merijn> vikt0r0: Basically, get returns the current value of the state
08:49:53 <anakreon> Does anyone have problems installing with cabal semigroups-0.8.4
08:49:53 <Cale> I've come to the conclusion that the right times to use StateT are almost exactly the times when you know you can hide its use from the rest of the world, either behind a module boundary, or within a single definition.
08:50:15 <anakreon> I get compilation errors
08:50:18 <merijn> Cale: Good, I fit both use cases :p
08:50:20 <quicksilver> merijn: yes, if you have a small set of operations it's fine.
08:50:23 <Cale> (and same goes for other monad transformers)
08:50:29 <quicksilver> especially if they're custom operations.
08:50:38 <quicksilver> possibly polymorphic themselves
08:50:44 <quicksilver> (i.e. it might not always be IO underneath)
08:51:34 <merijn> > runStateT 1 $ do { x <- get; put (x+1); return (2*x) } --vikt0r0: An example
08:51:35 <lambdabot>   No instance for (GHC.Show.Show (m (a, m1 s)))
08:51:35 <dunric>  Terminated
08:51:35 <lambdabot>    arising from a use of `M23...
08:51:40 <merijn> aww
08:51:49 <merijn> Did I make a type? :(
08:52:00 <merijn> oh, of course
08:52:06 <merijn> > runState 1 $ do { x <- get; put (x+1); return (2*x) } --vikt0r0: An example
08:52:06 <dunric>  Terminated
08:52:07 <lambdabot>   No instance for (GHC.Num.Num
08:52:07 <lambdabot>                     (Control.Monad.Trans.State...
08:52:11 <merijn> hmm
08:52:44 <maukd> :t runState
08:52:45 <lambdabot> forall s a. State s a -> s -> (a, s)
08:52:45 <dunric> forall s a. State s a -> s -> (a, s)
08:53:10 <fmap> > flip runState 1 (do { x <- get; put (x+1); return (2*x) })
08:53:11 <dunric>  Terminated
08:53:12 <lambdabot>   (2,2)
08:53:14 <merijn> oh...
08:53:15 <merijn>  duh
08:53:17 <Ornedan> Looks like I need to manually install Haskell, since F17 has an old platform. Looking at http://www.haskell.org/platform/linux.html it says I should install GHC 7.4.1 first. But GHC's page says to just install the platform
08:53:20 --- mode: ChanServ set +o maukd
08:53:20 --- kick: dunric was kicked by maukd (dunric)
08:53:31 <Ornedan> Which one is correct?
08:53:33 <merijn> > runState (do { x <- get; put (x+1); return (2*x) }) 5 --vikt0r0: An example
08:53:34 <lambdabot>   (10,6)
08:53:40 <hpaste> applicative annotated “tick tick tick ” with “tick tick tick  XXII” at http://hpaste.org/74853#a74858
08:53:54 <applicative> vikt0r0: this one has a better tik , it prints the current state, so you can see the role of get better, maybe
08:54:00 --- mode: maukd set -o maukd
08:54:04 <monochrom> install GHC 7.4.1 first
08:54:18 <vikt0r0> merijn: Okay, one sec.
08:54:18 <merijn> vikt0r0: As you can see, my example "runState" starts the stateful computation with a state of 5. The get retrieves the state, the put then puts "x +1" back as the new state
08:54:27 <killy9999> Ornedan: first GHC, then platform
08:54:28 <monochrom> (proof: the other route is an infinite loop. clearly.)
08:54:29 <merijn> vikt0r0: And then 2*x is returned as the return value of said computation
08:54:45 <killy9999> download binary distribution of GHC and install it and the install the platform
08:55:02 <hiptobecubic> F17 has an old platform?
08:55:02 <Ornedan> Ok
08:55:07 <monochrom> the other route is not an infinite loop for windows and mac
08:55:07 <hiptobecubic> That's not like them at all
08:55:50 <Ornedan> Yeah. F17 has 2011.4
08:56:42 <Ornedan> F18 is going to have 2012.2, though
08:57:44 <vikt0r0> merijn: So when I do execStateT three 3, for instance, 'get' wraps the 3 in in a StateT context and then used in the first 'tik' or what?
08:59:54 <merijn> vikt0r0: No, remember how State was defined as "\s -> (a, s)"?
09:00:04 <vikt0r0> merijn: Yes.
09:00:11 <merijn> vikt0r0: 3 is passed as the initial s argument
09:00:41 <vikt0r0> merijn: So it evaluates to ((),3)?
09:00:45 <merijn> So, get is just "\s -> (s,s)"
09:02:03 <merijn> And put is "\x s -> ((), x)" (i.e. "put 3 == \s -> ((), 3)" and discards old state s)
09:02:16 <applicative> !pizza
09:02:17 <pizzabot> Order acknowledged
09:02:34 <vikt0r0> merijn: That makes sense.
09:02:39 <merijn> vikt0r0: Consider working out the put/get substitutions by hand on paper and you can see better what happens
09:03:03 <vikt0r0> @src get
09:03:03 <lambdabot> Source not found. Maybe you made a typo?
09:04:58 <vikt0r0> Oops, DC'ed.
09:05:43 <vikt0r0> merijn: Is there a lambdabot FAQ/Tutorial? I would like to look up the implementation of get and put.
09:06:12 <edwardk> @tell merijn i don't use over infix. if you want it inix, use %~ =)
09:06:12 <lambdabot> Consider it noted.
09:06:17 <edwardk> er infix
09:06:43 <aleksandar> :t get
09:06:45 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
09:06:54 <aleksandar> :t put
09:06:55 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
09:09:47 <Eduard_Munteanu> @src get
09:09:47 <lambdabot> Source not found. Are you on drugs?
09:10:28 <Eduard_Munteanu> Ah, you had already tried it.
09:10:35 <vikt0r0> Yes :-)
09:12:17 <Eduard_Munteanu> vikt0r0: google/hoogle that, and follow the source links in Haddock
09:16:38 <vikt0r0> Oh no he dc'ed :-(
09:16:56 <vikt0r0> Thanks Eduard
09:18:39 <vikt0r0> Eduard_Munteanu: Very stupid question, how do I follow the files in Haddock/Access haddock at all.
09:18:56 <vikt0r0> Eduard_Munteanu: I hav Haskellmode installed for VIM
09:21:14 <Eduard_Munteanu> vikt0r0: I just mean look at the instances here http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-State-Lazy.html#State
09:22:12 <Eduard_Munteanu> And yeah, there are no source links for the individual instances in Haddock.
09:22:21 <vikt0r0> Ah
09:26:21 <glguy> Anyone know if a .pkg installs is in the works for OS X for GHC 7.6.1?
09:26:26 <glguy> installer*
09:26:34 <Cale> glguy: Doesn't that exist?
09:26:50 <Cale> oh
09:26:55 <Cale> I see, no it doesn't
09:27:04 <glguy> Way to get my hopes up ;)
09:27:57 <edwardk> glguy: i'm hoping it'll come out with or before the platform
09:27:58 <Cale> (I thought it did because I was looking at the .pkg version of GHC the other day while helping someone else, but that must have been 7.4.2)
09:31:52 <Cale> btw, since there are likely somewhat different people around now, http://video.ias.edu/univalent/awodey was a really good talk, which for some inexplicable reason I only found out about last night?
09:32:47 <Cale> (I have no idea why, it's right at the top of the list of talks on homotopytypetheory.org and is a couple years old)
09:32:55 <Eduard_Munteanu> Neat. I hope that's good as an introductive talk to HTT too.
09:33:02 <Botje> I think I understand the verbs in that sentence :/
09:33:30 * Eduard_Munteanu kinda wants to learn stuff about HTT, but doesn't know where to start
09:34:26 <Cale> It's a kinda okay intro -- he doesn't really seem to introduce all the details of what the type theory is carefully, but it's good as a rough overview. It will help to know some homotopy theory later on.
09:36:33 <Eduard_Munteanu> Cale: I know almost nothing about topology or homotopy, where do I start? :)
09:37:39 <Cale> I would point you at a book, except that the course where I learned algebraic topology didn't have one, and I haven't really looked into finding one whose explanation of things I really liked. There's Hatcher's book, but its treatment of homotopy is awkward imo.
09:38:06 <Cale> (http://www.math.cornell.edu/~hatcher/AT/ATpage.html)
09:38:25 <Eduard_Munteanu> I'll have a look, thanks.
09:38:51 <fmap> How can I add haddock documentation to a lens generated with TH?
09:39:34 <byorgey> fmap: sorry, you can't.
09:39:48 <Eduard_Munteanu> I wonder, is there any theorem prover / actual type system based on HTT?
09:39:48 <Cale> Eduard_Munteanu: Introducing just a little tiny bit more category theory to the description of things than he does makes everything a whole lot nicer.
09:40:01 <Cale> Eduard_Munteanu: yes, there are implementations of it in Coq and Agda
09:40:14 <byorgey> fmap: I suppose you could use -ddump-splices the first time you compile, then take the output, clean it up, and paste it directly into the file (and add Haddocks).
09:40:24 <Botje> Eduard_Munteanu: I first read that as HTTP...
09:40:35 <Eduard_Munteanu> Hm, I should look for the Agda one.
09:40:38 <Cale> Eduard_Munteanu: and people are starting to prove real classical topological results in them, albeit simple ones.
09:40:39 <glguy> ddump-splices doesn't always produce valid Haskell
09:40:41 <byorgey> but it's a bit unfortunate there's no way to add comments to declarations output by TH.
09:40:54 <byorgey> glguy: I know, that's why I said "clean it up" =(
09:41:26 <Eduard_Munteanu> Botje: the wget theorem prover maybe? :P
09:42:08 <fmap> byorgey: well, there is a way if lens package wouldn't generate a type signature too :(
09:42:12 <Eduard_Munteanu> To be fair, I probably need to read more on ITT/ETT/OTT as well.
09:42:32 <Cale> Eduard_Munteanu: Okay, so the traditional almost-first thing you study in homotopy theory is something called the fundamental group of a (pointed/connected) space.
09:42:49 <fmap> probably I can add wrappers around every generated lens with type signature and attach haddocks to them
09:43:27 <Eduard_Munteanu> Cale: is that a group as in group theory?
09:43:30 <Cale> yes
09:43:56 <Cale> Eduard_Munteanu: So suppose you have some topological space X, and you pick a point in it, say *
09:44:35 <Cale> You can consider the set of all paths in the space (i.e. continuous functions from the unit interval to X), which start and end at *
09:45:37 <applicative> Eduard_Munteanu: fwiw I found this extremely helpful.  http://www.cse.chalmers.se/~coquand/equality.pdf together with some random abcs about homotopy
09:45:57 <fmap> it's probably easier to write a lens by hand though
09:46:13 <Cale> and then you can form an equivalence relation on paths, where (slightly more generally) two paths f,g: [0,1] -> X are equivalent if there is some continuous function which describes a deformation from one into the other while keeping the endpoints fixed
09:46:40 <applicative> Cale, I think it's easier with some pictures...
09:46:55 <Eduard_Munteanu> Hm, that deformation thingy sounds a bit familiar, I think I read something on wikipedia about it.
09:47:45 <Cale> i.e. a continuous function F: [0,1] x [0,1] -> X such that F(0,s) = f(s), F(1,s) = g(s), F(t,0) = f(0) = g(0), and F(t,1) = f(1) = g(1), where we think of t as "time" and s as "position along the curve"
09:47:53 <applicative> Eduard_Munteanu: oh the other thing that was a massive help was the old essay on 'the groupoid interpretation of type theory' which is awesome anyway
09:48:34 <Eduard_Munteanu> applicative: is that something like a category-theoretic semantics for type theory?
09:49:23 <Cale> Eduard_Munteanu: It really helps to have a picture of this, perhaps, so draw two points, and a couple of somewhat wiggly paths f and g in between them, and then imagine F as describing a whole family of paths (like a sheet) connecting those two, while keeping the endpoints the same the whole time
09:50:14 <Cale> Eduard_Munteanu: Now, if we return to our pointed space (X,*), we can talk about the set of equivalence classes of paths in X which start and end at *
09:50:44 <Cale> and because any two of these paths start and end at the same point, we can concatenate any two of them to get another path
09:50:44 <applicative> Eduard_Munteanu: sort of.  But it explains the conundra with the identity type
09:50:54 <rwbarton> http://www.math.cornell.edu/~hatcher/AT/ATch1.pdf page 25
09:51:07 <rwbarton> for homotopy
09:51:17 <rwbarton> the picture I mean :)
09:51:19 <Cale> rwbarton: thanks, that's the picture I want :)
09:51:32 * Eduard_Munteanu looks
09:51:47 <applicative> right, I used that textbook ...
09:52:21 <Cale> Eduard_Munteanu: and basically, it's possible to show that this makes the set of equivalence classes of loops beginning and ending at * into a group with the operation of concatenation
09:53:16 <Cale> called the fundamental group of the (pointed) space X
09:53:21 <john_r_watson> @pl (\s -> (d s) - (d a))
09:53:21 <lambdabot> subtract (d a) . d
09:53:21 <dunric> subtract (d a) . d
09:53:26 <Eduard_Munteanu> Hm, so what is this concatenation exactly?
09:53:34 <Cale> Well, good question
09:54:43 <applicative> Eduard_Munteanu: its easy with the agda interpretation path_concat : A : Set -> a b c : A -> Eq a b -> Eq b c -> Eq a c
09:54:44 <Eduard_Munteanu> And presumably the group contains equivalence classes for *each* point in the X space.
09:55:08 <Eduard_Munteanu> Ah.
09:55:12 <Cale> It takes two paths f, g: [0,1] -> X which start and end at the same point, and gives h: [0,1] -> X where h(t) = f(2t) for t from 0 to 1/2, and then h(t) = g(2t - 1) for t from 1/2 to 1
09:55:32 <Cale> (in traditional terms)
09:55:41 <alpounet> Eduard_Munteanu, it contains equivalence classes of PATHS, not points
09:55:50 <Cale> So it's the path which traces along each of the two paths, twice as fast
09:56:17 <Cale> and you can show that this is continuous, and it extends to a well defined operation on equivalence classes of paths as well
09:57:45 <applicative> the textbooks all begin with maps from [0,1] which is somehow extremely distracting, given the actual abstractness of the material
09:57:46 <Cale> and moreover, the operation which sends a path f: [0,1] -> X to the path g: [0,1] -> X where g(t) = f(1-t) will be an inverse with respect to concatenation -- obviously not on paths, but on equivalence classes of them
09:58:20 <Cale> applicative: maybe, but there's something to it, really :)
09:59:22 <Dodek> applicative: it depends on textbook.
09:59:27 <Cale> Like, you can reinterpret this definition where you replace your topological spaces by categories and your continuous maps by functors, and you replace the unit interval [0,1] with the category 0 -> 1 (with two objects and exactly one nonidentity arrow going between them)
09:59:31 <applicative> of course it makes perfect sense, but they are using the familiar facts about [0,1] to express something that in the end hardly needs that case
09:59:41 <Cale> and the definition of a natural transformation falls out
10:00:02 <Dodek> applicative: some of them, instead of lookin at [0, 1] and concatenating, use the cogroup structure on the circle.
10:00:08 <Eduard_Munteanu> Cale: oh, cool
10:00:30 <Dodek> applicative: if S is a cogroup object, then for any object X, Hom(S, X) has group structure
10:01:07 <applicative> Dodek I see, that sounds more like what they end up wanting, but now that you mention what is actually wanted , it seems like maybe they do the right thing :)
10:01:25 <Dodek> applicative: and the circle S^1 has a cogroup structure in a catgory of pointed topological spaces with homotopy classes of continuous functions as morphisms
10:02:02 <Dodek> applicative: well yeah.
10:02:45 <Cale> applicative: The nice thing about the way they start out is that it is immediately amenable to geometric intuition
10:02:51 <Dodek> it's the same as with expressing seifert-van kampen theorem in terms of "group product with amalgamation"
10:03:00 <applicative> i was just thinking, it is always extremely tiresome to do this real number math -- as with Cales mention of the proof that the concatenation of paths is a path, by speeding up each, so to say
10:03:02 <Dodek> when in fact this is just categorical colimit
10:03:12 <Cale> all the more abstract things which start arising from here just get harder and harder to picture :)
10:03:38 <applicative> Cale, my objection was the use of real number arithmetic,not geometric intuition
10:03:41 <rwbarton> it is a mystery that you can approach this funny alien branch of algebra called homotopy theory with real numbers and open sets and all that stuff
10:03:45 <Cale> heh, we had a lemma at the start of my course
10:03:47 <applicative> Cale: not that it's an objection
10:03:55 <Cale> which the prof called the stickingfunctionstogetherlemma
10:04:26 <Dodek> applicative: well do you know what (topological/differentiable) manifolds are?
10:04:44 <applicative> manifolds yipe
10:04:53 <Cale> basically that if you had two continuous maps which agreed on the intersection of their domains, then you could get a continuous map on the union
10:05:06 <applicative> i see
10:05:20 <Dodek> so aren't manifolds geometric objects expressed in terms of real numbers?
10:05:58 <Dodek> applicative: the point is that real numbers _are_ geometric. real numbers are terribly uninteresting from algebraic point of view.
10:06:03 <applicative> yes, I see the wikipedia definition does allude to E^n
10:06:44 <applicative> Dodek: ok, I see.  From your point of view I was being distracted by a dim apprehension of the real numbers
10:06:49 <Cale> I'm not sure I'd say *terribly* uninteresting, but I mostly agree :)
10:06:52 <Infectas> www.infect-mu.lt VISIT! :)
10:07:23 <diablosbestfrien> How much would I learn about TCP/IP by implementing the irc-protocol?
10:07:25 <Cale> Infectas: That seems like a good way to get people not to visit your link.
10:07:34 <benmachine> the unique complete archimedean totally ordered field isn't interesting?
10:07:49 <Dodek> benmachine: from algebraic point of view? hardly
10:07:55 <Dodek> who cares about completenes? :)
10:08:04 <benmachine> diablosbestfrien: you can implement IRC without knowing anything about how TCP works
10:08:37 <benmachine> diablosbestfrien: you'll make use of its properties, but you needn't know anything about how it gets those
10:08:52 <applicative> diablosbestfrien: what do you want to do?
10:09:00 <mroman> Can one restrict the argument in (\x -> x x) so it is valid?
10:09:05 <Cale> diablosbestfrien: You generally don't have to know anything about TCP/IP in order to implement network applications, because it's a pretty good abstraction layer.
10:09:34 <Cale> Well, that's a bit glib, but pretty much.
10:10:04 <applicative> diablosbestfrien: certainly you can make a bot without knowing anything; even I can do it :)
10:10:16 <benmachine> mroman: yes, but probably you can't also do it so it's useful
10:10:24 <mroman> Something like f :: (a -> a) -> (a -> a); f x = x x
10:10:25 <benmachine> mroman: and you can't do it in Haskell98
10:10:47 <rwbarton> @type f :: (forall a. a -> a) -> b -> b; f x = x x in f
10:10:48 <lambdabot> parse error on input `;'
10:10:48 <dunric> parse error on input `;'
10:10:54 <rwbarton> @type let f :: (forall a. a -> a) -> b -> b; f x = x x in f
10:10:55 <lambdabot> forall b. (forall a. a -> a) -> b -> b
10:10:55 <dunric> forall b. (forall a. a -> a) -> b -> b
10:10:57 <mroman> (\x -> x x) id ~=> id id ~=> id
10:10:59 <mroman> ^- like that
10:11:02 <diablosbestfrien> applicative: what id really like to do is do some project that teaches me about tcp/ip. just reading tanenbaum isnt for me. i learn best by doing.
10:11:03 <benmachine> @type who is this dunric guy
10:11:04 <lambdabot> Not in scope: `who'
10:11:04 <dunric> Not in scope: `who'
10:11:04 <lambdabot> Not in scope: `is'
10:11:04 <lambdabot> Not in scope: `this'
10:11:04 <dunric>     Not in scope: `is'
10:11:05 <dunric>     Perhaps you meant one of these:
10:11:07 <rwbarton> @botsnack
10:11:08 <lambdabot> :)
10:11:08 <dunric> :)
10:11:19 <Dodek> diablosbestfrien: why do you want to learn TCP/IP?
10:12:29 <Cale> mroman: you can do a trick like defining   newtype Rec a = InR { outR :: Rec a -> a }
10:12:56 <Cale> mroman: and then you can write things like:
10:13:16 <benmachine> @type let fn x = x x; fn :: (forall a. a) -> b in ()
10:13:17 <lambdabot> ()
10:13:17 <dunric> ()
10:13:32 <benmachine> @nixon
10:13:32 <lambdabot> Scrubbing floors and emptying bedpans has as much dignity as the Presidency.
10:13:33 <dunric> A public man must never forget that he loses his usefulness when he as an individual, rather than his policy, becomes the issue.
10:13:41 <benmachine> okay can we seriously not have two lambdabots please
10:14:08 --- mode: ChanServ set +o Cale
10:14:15 --- kick: dunric was kicked by Cale (dunric)
10:15:23 <edwardk> fmap: the 'lens' package actually generates the signatures for the lenses it makes
10:15:36 <fmap> edwardk: yes
10:15:39 <edwardk> fmap: but there is no way for me to generate haddock comments for them too
10:16:09 <fmap> edwardk: does it make sense to generate lenses without type signatures?
10:16:32 <edwardk> fmap: thats what data-lens-template and most of the others do
10:16:44 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
10:16:45 <edwardk> fmap: the problem with that approach is that you get warnings out of -Wall
10:16:46 <lambdabot>   3628800
10:17:05 <Cale> mroman: So that lets things of that sort typecheck, just by wrapping and unwrapping appropriately
10:17:07 <edwardk> fmap: which is what drove me to do the unification correctly to figure out the type signature for the lens
10:17:19 <fmap> edwardk: well, the point is I can then add type signatures and haddocks
10:17:46 <edwardk> fmap, hrmm, can you actually define part of a method like that?
10:17:53 <Cale> InR and outR are both isomorphisms, and operationally they're implemented by the identity function (after forgetting the types)
10:18:04 <edwardk> e.g. put the signature in explicitly and let TH splice in the body?
10:18:12 <edwardk> if so, then i can add a flag to lens
10:18:45 <fmap> edwardk: I could do this with 7.4 at least
10:19:03 <edwardk> fmap: ok. i'll put an issue on lens to add a flag and try to get to it this week
10:19:21 <fmap> edwardk: thanks :)
10:19:24 <edwardk> (i have a talk on lenses on thursday and haven't even written my slides yet, so a lot of stuff is getting pushed down the stack)
10:19:41 <merijn> edwardk: oh, I don't suppose it'll be filmed?
10:19:41 <lambdabot> merijn: You have 1 new message. '/msg lambdabot @messages' to read it.
10:20:11 <edwardk> merijn: it'll probably be filmed. if not this one then definitely the version of the talk i plan to do at the bay area haskell user group will be filmed
10:20:23 <merijn> Good :)
10:20:27 <edwardk> merijn: i have a couple of videos of haskell talks i need to figure out how to get off of various devices
10:20:36 <mroman> Cale: I see.
10:21:02 <edwardk> when i moved i lost the cord to my camera, and the last one i recorded was on my ipad, but its been hell getting imovie to sync an hour and a half video
10:22:00 <dunric1> test
10:22:14 <benmachine> @botsnack
10:22:14 <lambdabot> :)
10:22:15 <Cale> @bot
10:22:15 <lambdabot> :)
10:24:04 <ipuustin> hi guys! A quick newbie question: what is the recommended way of reading input from two IO sources at once? I would like to wait on both user input (getLine) and timer (threadDelay).
10:24:21 <merijn> edwardk: While you're here anyway, I'm trying to figure out how to write something like "views", but with the value being accessed on the left (like ^.), I can't seem to manage to write a simple version of that...
10:24:24 <ipuustin> something like select/poll in other words.
10:25:10 <edwardk> merijn you want something like foo ^#!@(# _2 $ somefunction ?
10:25:11 <merijn> ipuustin: I guess either something using asynchronous exceptions (having the timer throw one that wakes up the getLine thread) or something STM based?
10:26:09 <edwardk> merijn: remember you can always use foo^._1.to bar    instead of views _1 bar foo
10:26:40 <merijn> edwardk: Well, right now I have "myLens `views` someFun $ rec" and I wanted to get rid of the "$ rec" part and having something more akin to "rec ^. foo" where foo is a combination of myLens/someFun
10:26:43 <vikt0r0> merijn: Hi again. My laptop ran out of power before, sorry for that.
10:26:48 <merijn> Hmm, I guess to is what I'm looking for
10:26:57 <merijn> vikt0r0: It's ok, I had to go home anyway :p
10:27:07 <maukd> :t fmap fix return
10:27:08 <lambdabot> forall a. a -> a
10:27:08 <dunric> forall b. b -> b
10:27:09 <edwardk> merijn: there is also ^%
10:27:13 --- mode: ChanServ set +o maukd
10:27:13 --- mode: maukd set +b *!*dunric@213.151.77.*
10:27:17 <vikt0r0> :merijn :D
10:27:23 <edwardk> foo^._1^%bar
10:27:26 <diablosbestfrien> Dodek: why not? I think I should know it if I shopuld program webapps etc.
10:27:43 <applicative> someone needs to make a lensbot so edwardk can explain this stuff better
10:27:48 <edwardk> that doesn't work so well when you go to mix it with use/uses though
10:27:53 --- mode: maukd set -o maukd
10:27:54 <merijn> edwardk: Ah, yeah. the ".to" seems to be the missing link
10:28:01 <ipuustin> merijn: thanks. I guess I'll look further to STM...
10:28:06 <edwardk> ^% is basically ^.to
10:28:29 <edwardk> merijn: the ubiquity of 'to' is why i gave it such a short name =)
10:28:56 --- mode: ChanServ set +o maukd
10:29:13 <edwardk> merijn: for what its worth the % and ^% operators exist because then %~ is the application of % to the target of the lens ;)
10:29:19 <applicative> its a huge namespace grab this Control.Lens I keep finding
10:29:21 <edwardk> post hoc justification of the choice of symbol
10:29:37 --- mode: maukd set -o maukd
10:29:39 <merijn> edwardk: Yeah, ^% is much better than what I had before
10:29:41 <edwardk> applicative: i admit, i was a bit greedy
10:30:14 <edwardk> i tried pushing stuff out into modules, but they keep finding its way back in, generalized via classes into Control.Lens ;)
10:30:25 <edwardk> er they keep finding their way
10:30:26 <applicative> it seems okay, you just hide whatever seems greedy, but maybe it will be a  problem with things one wants both to export and have used with Control.Lens
10:31:18 <merijn> I just feel a bit bad about the parenthesis having a semantic effect (that is not completely obvious immediately) in "rec ^. recTags   ^% (IntMap.! i)", although that's not a lens problem :p
10:31:20 <Dodek> diablosbestfrien: you don't need to know about 95% stuff that's involved in tcp/ip if you want to create webapps
10:31:23 <edwardk> applicative: well, for the most part the operators are chosen not to conflict with operators in third party libraries. the names are also chosen not to collide with stuff in the platform as well
10:32:57 * hackagebot pwstore-fast 2.3 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-2.3 (PeterScott)
10:34:18 <merijn> edwardk: One more before I get back to coding, right now I have this (plus lenses for all three fields), I don't suppose there some existing weird voodo to make it look nicer? "merge (Rec t1 b1 f1) (Rec t2 b2 f2) = Rec (union t1 t2) (union b1 b2) (union f1 f2)"
10:34:46 <edwardk> merijn: nada
10:35:14 <merijn> ok, I'll just mess with the whitespace until I like xD
10:36:20 <vikt0r0> merijn: Let me know if you don't have time talking to me now, but here goes: Say i want to 'glue' together an arbitrary amount of tick-state computations. I guess I could declare is as multiTick n = tick >> multiTick (n-1) with a boundary condition multiTick 1 = tick. But is there a way I could declare it as multiTick 0 = 'insert some computation that returns state and the last computed result'?
10:37:14 <vikt0r0> merijn: Such that e.g. runState . multiTick 0 $ 40 => 40
10:37:36 <vikt0r0> Or ((),40) I guess?
10:38:19 <merijn> vikt0r0: I don't think I understand the question?
10:38:23 <edwardk> gah. apparently the video for bound is ~16gb. need to grab an external drive and shuffle things around =/
10:40:07 <merijn> vikt0r0: Do you want to know how to have a runtime specified number of repetitions?
10:40:12 <vikt0r0> merijn: Oh, maybe it was applicative who gave me the 'tick' example.
10:40:13 <vikt0r0> Yes!
10:40:18 <vikt0r0> I can do it that way
10:41:08 <vikt0r0> merijn: But if the number of repetitions is 0, it shouldn't do anything. I do not know how to express that...
10:41:46 <vikt0r0> merijn: Besides having my function recurse indefinitely :-)
10:43:38 <merijn> vikt0r0: Well your first example was fairly sensible: multiTick :: Int -> StateT Int IO (); multiTick 1 = tick; multiTick n = tick >> multiTick (n-1)
10:44:06 <merijn> vikt0r0: Alternatively, you'd probably use replicateM and replicateM_ from Control.Monad
10:44:06 <appamatto> Cale or ski around today?
10:44:22 <appamatto> I come bringing relevant research :p
10:44:45 <merijn> > let tick = do { i <- get; put (i+1) } in replicateM_ 40 tick
10:44:46 <lambdabot>   No instance for (GHC.Show.Show (m ()))
10:44:47 <lambdabot>    arising from a use of `M774344586...
10:44:48 <vikt0r0> appamatto: Cale was here like 2 hours ago.
10:45:08 <merijn> > let tick = do { i <- get; put (i+1) } in runState (replicateM_ 40 tick) 0
10:45:09 <lambdabot>   ((),40)
10:45:33 <vikt0r0> Cool.
10:45:41 <appamatto> vikt0r0: thanks
10:46:18 <Cale> appamatto: hi
10:46:25 <merijn> vikt0r0: "replicateM :: Int -> m a -> m [a]" and "replicateM_ :: Int -> m a -> m ()", i.e. replicateM_ is replicateM but throwing away the result
10:46:33 <Cale> I'm sorta here, trying to work :)
10:46:41 <hpaste> applicative pasted “tick tick tick  (annotation)” at http://hpaste.org/74864
10:46:52 <merijn> vikt0r0: Those (like everything in Control.Monad) work on any monad, including State
10:47:09 <applicative> vikt0r0: this sort of thing?  it would be briefer with replicateM_ or something
10:47:46 <appamatto> Hey Cale. I found a paper by DeLesley Hutchins called Pure Subtype Systems which is almost exactly what I was talking about the other day, unifying lambda and pi
10:48:04 <appamatto> http://redwood.mza.com/~dhutchins/papers/popl10-hutchins.pdf
10:48:07 <ciaranm> mmmmpi
10:48:29 <vikt0r0> merijn: Yes, just like that.
10:48:45 <Cale> okay, I don't know if I was really part of a discussion where you were talking about unifying lambda and pi calculus
10:48:47 <vikt0r0> merijn: How do people find these hpaste examples?
10:49:30 <vikt0r0> merijn: Yea, you're right, but I had no idea that there was such a thing like replicateM
10:49:46 <merijn> vikt0r0: Mostly people code them on the spot
10:49:57 <merijn> vikt0r0: Ah, but that's what Hoogle is for :p
10:50:03 <merijn> @hoogle Int -> m a -> m ()
10:50:04 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
10:50:04 <lambdabot> Test.QuickCheck.Gen resize :: Int -> Gen a -> Gen a
10:50:04 <lambdabot> Test.QuickCheck resize :: Int -> Gen a -> Gen a
10:50:09 <appamatto> Cale, I was asking why lambda couldn't be used instead of pi
10:50:22 <vikt0r0> merijn: Yea, i was pretty impressed by hoogle :D
10:50:30 <vikt0r0> merijn: Has been a lifesaver
10:50:42 <Cale> Okay, I don't remember that. Maybe I was there for some subdiscussion.
10:50:56 <merijn> vikt0r0: Control.Monad and Control.Monad.Loops (the latter is form the monad-loops) package are pretty good places to look when you're writing monad code
10:51:12 <merijn> vikt0r0: Lots of generic combinators there that you can use for everything
10:51:27 <appamatto> Oh. Hmm, you don't remember how I was saying that the type of id should be id, etc.?
10:52:12 <appamatto> And you were saying that the tye of id had to involve -> because id is a function
10:53:59 <hpaste> applicative annotated “tick tick tick  (annotation)” with “tick tick tick  XXIII” at http://hpaste.org/74864#a74865
10:54:10 <applicative> vikt0r0: here's the same using replicateM ^^^
10:56:53 <vikt0r0> merijn: Oh that's cool.
10:57:07 <vikt0r0> merijn: I have a bunch of functions i can rewrite using that.
10:57:27 <merijn> vikt0r0: You should, it's good practice to see how well you understand things :)
10:57:36 <vikt0r0> merijn: Do you know what would I do, in general, if I want to see the implementation of it?
10:57:45 <vikt0r0> merijn: Of something*
10:58:04 <vikt0r0> merijn: Or instance i guess I should be saying.
10:59:21 <merijn> vikt0r0: In the Haddock documentation (the stuff you find on Hoogle and installed locally) there's a "source" link on the right of all functions
11:00:14 <vikt0r0> merijn: How could I not have seen that.
11:00:23 <vikt0r0> merijn: All this time :)
11:02:50 <merijn> Anyhoo, I need to go. Good luck.
11:03:51 <hpaste> applicative annotated “tick tick tick  (annotation)” with “tick tick tick  XXIV with adding machine” at http://hpaste.org/74864#a74867
11:04:07 <applicative> vikt0r0: now with addingMachine ^^^ !
11:05:25 <vikt0r0> What does lift do?
11:05:39 <Cale> vikt0r0: the one for monad transformers?
11:05:57 <applicative> it takes any action in IO , like putstrLn "Hi" and makes it appropriate to the transformed State x IO y
11:06:02 <Cale> vikt0r0: It takes an action in your original monad, and adds whatever structure is required to make it an action of the newly transformed monad
11:06:33 <ben> like liftM?
11:06:35 <vikt0r0> merijn: Sorry, but I have only been learning Haskell for a little over a week. So a lot of maybe triviial questions on my side :D
11:06:39 <ciaranm> is a monad action an action?
11:06:56 <Clint> what
11:07:27 <vikt0r0> :t lift
11:07:28 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
11:07:31 <applicative> vikt0r0: if `add` were an IO () , then input <- getLine would be the way to write it; but I am keeping state with StateT Int IO () , so I have to do lift to raise the IO thing to a StateT Int IO thing
11:07:48 <applicative> then I can use get and put on my underlying state
11:08:19 <vikt0r0> :t StateT
11:08:20 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
11:08:46 <applicative> ie. basically  (s -> m (a, s))  but wrapped so you can write all the monad definitions
11:08:52 <Cale> ciaranm: "action" can be used as a generic term for "value of type m a where m is a monad"
11:09:01 <Ferdirand> @type join
11:09:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:09:38 <ciaranm> Cale: yeah. i'm just wondering whether that use of action coincides with the usual action / representation definition.
11:10:09 <vikt0r0> applicative: Okay, I am officially confused now, but I'm just gonna keep on reading ahead, it'll probably all make sense at some point.
11:13:28 <vikt0r0> @help
11:13:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:13:32 <vikt0r0> @help tell
11:13:32 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
11:14:08 <vikt0r0> @tell applicative Thanks for the help, lifting makes sense, conceptually at least.
11:14:08 <lambdabot> Consider it noted.
11:19:35 <XexonixXexillion> I've had a look on hackage and can't find any RTree implementations in Haskell. Are there any?
11:24:34 <kosmikus> XexonixXexillion: http://stackoverflow.com/questions/7270796/implementations-of-spatial-indexes-in-haskell
11:24:56 <bos> i had my students implement a Hilbert R-tree last year
11:26:41 <copumpkin> yay R-trees
11:29:16 <XexonixXexillion> I guess I'll just write my own, it shouldn't take too long
11:30:36 <DrTeggy> Well, an R-tree is a data structure that has been devised/tuned for block-based storage.
11:32:07 <DrTeggy> (read: storage on disk)
11:32:58 * hackagebot shake 0.3.3 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.3 (NeilMitchell)
11:34:25 <XexonixXexillion> I have a set of spatial relations I need to infer. It'll be a lot faster if I can trivially exclude objects that are too distant to have any effect on each other
11:35:12 <XexonixXexillion> can anyone think of a better idea than storing my objects in an R-Tree?
11:35:40 <bos> a quadtree would also work, and is much easier to implement
11:36:27 <vikt0r0> merijn: Hey! Thanks a ton for the help, meant a lot. I'm off for today!
11:40:09 <XexonixXexillion> How do I deal with overlap in a quadtree?
11:43:18 <XexonixXexillion> Whilst none of my objects truly overlap, I only get bounding boxes, and the bounding boxes overlap
11:56:36 <hiptobecubic> alelos, absorbing?
11:56:58 <alelos> hiptobecubic: damn no :P
12:07:59 * hackagebot tagsoup 0.12.8 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.12.8 (NeilMitchell)
12:14:28 <plat0> I have an orphan Arbitrary instance for use in QuickCheck, so -Wall -Werror fails.  What's the usual way around this?
12:14:47 <Heffalump> {-# OPTIONS_GHC -fno-warn-orphans #-} in the file
12:14:53 <Heffalump> I also include a comment saying why
12:15:11 <plat0> Is it generally accepted that Arbitrary instances will be orphans?
12:15:18 <plat0> Seems like there's no other sensible way.
12:15:35 <hiptobecubic> plat0, http://stackoverflow.com/questions/3079537/orphaned-instances-in-haskell
12:16:00 <hiptobecubic> some interesting points in here, although maybe not super relevant for quickcheck?
12:16:01 <plat0> Also, can I somehow tell ghc to ignore the particular orphan instance, but not all of them in the file?
12:20:22 <enolan> conal: You around? I want to talk about the license on your reactive library.
12:20:48 <plat0> thanks hiptobecubic, that was useful
12:21:46 <uniquenick> if I have a type like "data Foo = Foo (Maybe Int) (Maybe Int)", is there a simple way to isJust both parts?
12:22:48 <MostAwesomeDude> uniquenick: What did you want as your return type?
12:22:59 * hackagebot shake 0.3.4 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.4 (NeilMitchell)
12:23:01 <MostAwesomeDude> Did you want Foo -> Bool or Foo -> (Bool, Bool)
12:23:30 <uniquenick> one Bool, like if Both isJusts return true then true, if either returns false then false
12:23:51 <ncs> what is considered a higher-kinded datatype? is * -> * higher-kinded, or should it be something like (* -> *) ->  * ?
12:24:02 <appamatto> Is there a path through academia that involves writing papers indiendently before being accepted to a PhD program?
12:24:06 <MostAwesomeDude> So you wanted isFooJust (Foo a b) = isJust a && isJust b
12:25:57 <uniquenick> is there an applicative way to do it so that it is a little neater as the number of elements in my data types grows?
12:26:54 <geekosaur> :k StateT
12:26:55 <lambdabot> * -> (* -> *) -> * -> *
12:27:09 <rwbarton> not really... unless you can factor it as data Foo a = Foo a a and then use Foo (Maybe Int)
12:27:12 --- mode: ChanServ set +o maukd
12:27:12 --- mode: maukd set -b *!*dunric@213.151.77.*
12:27:20 <rwbarton> then write a Foldable or Traversable instance for Foo
12:27:33 <rwbarton> which you can derive with TH (and maybe other ways too)
12:27:52 --- mode: maukd set -o maukd
12:31:32 <sfogarty> Is there a good way to deal with the case of 'a value might be a float or an int' in an interpreter when doing arithmetic over them? I want to introduce the concept of a disjoint type of values early, but redefining mult, plus, div, - for all of them is cumbersome. I'm sure there's a pretty haskell way to handle this
12:32:20 <latro`a> use a typeclass?
12:32:29 <latro`a> sounds like that's what you're doing anyway, though, so I'm not sure what the problem is
12:32:47 <bitonic> sfogarty: can't you put a constraint on your type class parameter?
12:32:54 <bitonic> `Num a => Foo a' or whatever.
12:32:57 <sfogarty> I wasn't using a typeclass (yet), I just had 'data Value = InvVal int | RealVal real'. Perhaps I should be using a type class
12:33:12 <sfogarty> (real = Float)
12:33:19 <bitonic> sfogarty: are you aware of the available numeric typeclass?  maybe you don't need one.
12:33:45 <bitonic> *typeclasses
12:33:54 <rwbarton> sfogarty: Your approach is the normal way to implement an interpreter for an untyped language
12:33:55 <sfogarty> I think Fractional would handle it, but I kind of want them to deal with the eventuality (in the next assignment) of having different types of values that can't always combine
12:34:02 <rwbarton> (or "dynamically typed")
12:34:05 <sfogarty> right.
12:35:06 <sfogarty> it just means that plus and minus become four-line functions
12:35:14 <Twey> sfogarty: Better to use GADTs like ‘data Value a where IntVal ∷ Integer → Value Integer; RealVal ∷ Float → Value Float’
12:35:23 <rwbarton> you can factor out a lot of the redundancy in defining plus, mult etc. with normal functional programming techniques
12:35:28 <Twey> sfogarty: Then you can derive an instance Num a => Num (Value a)
12:36:40 <sfogarty> rwbarton: HOF for times, plus, mult, that kind of thing?
12:36:47 <sfogarty> Twey: I think that is /way/ overkill for a class project
12:36:49 <rwbarton> plus = op (+) (+) where op int_op real_op (IntVal v1) (IntVal v2) = IntVal (v1 `int_op` v2) ; op int_op real_op v1 v2 = let { r1 = valToReal v1; r2 = valToReal v2 } in RealVal (r1 `real_op` r2)
12:37:44 <sfogarty> I suppose that'll have to do. Get them more practice using hofs.
12:37:53 <rwbarton> assuming you want that kind of automatic promotion semantics
12:37:53 <Twey> sfogarty: It's easy if you understand GADTs, & results in less duplication of code
12:38:04 <Twey> Plus you should get better marks ;)
12:38:17 <sfogarty> Er, no, I'm /designing/ a class project :)
12:38:18 <rwbarton> his students will get worse marks
12:38:24 <Twey> Oh!
12:38:27 <Twey> I beg your pardon
12:38:31 <sfogarty> No worries :)
12:38:45 <Twey> Are you making a model answer or something, or just playing around with it to see what you should set?
12:38:52 <shapr> @quote
12:38:52 <lambdabot> <companion_cube> says: edwardk, you mean it's 2 phD/nick in average ? :) <edwardk> clearly this is why SPJ stays away, he doesn't want to dilute that metric.
12:39:09 <Twey> Haha
12:39:12 <sfogarty> well, I want to make sure I assign something implemenmtable
12:39:46 <ParahSai1in> what is the default buffering mode ghc uses
12:40:20 <Heffalump> if you were starting out teaching Haskell datatypes and didn't care about the theoretical foundation of sums and products, arguably GADT notation would be a natural way to do it
12:40:29 <Twey> sfogarty: It's definitely implementable.  The naïve way is just to redefine; the slightly less naïve way is to use typeclasses; and the reasonably smart way is to use GADTs.
12:40:55 <sfogarty> implementable by my students who have had three weeks of introduction to Haskell :)
12:41:00 <edwardk> ParahSai1in: same as every other process. stdin buffered stderr unbuffered, if stout is a terminal then buffering is line buffered, else block buffered
12:41:10 <Twey> For bonus points, fix the compiler to extend GeneralizedNewtypeDeriving for GADTs ;)
12:41:12 <edwardk> ParahSai1in: nothing alltogether haskell specific about that though
12:41:18 <Twey> It practically marks itself!
12:41:31 <rwbarton> it's not clear that you want the GADT solution for a dynamically typed language anyways
12:41:48 <Twey> That's true
12:42:26 <Twey> Heffalump: +1
12:42:26 <ParahSai1in> on linux, is the buffering mode on a handle opened by openFile determined by OS?
12:42:38 <rwbarton> I like the idea of introducing data declarations with GADT syntax though, but it may be too inconvenient
12:42:55 <Twey> I tend to use GADT notation even when I don't have to, now, because I find it much more intuitive & descriptive (if somewhat more verbose)
12:43:27 <Heffalump> ParahSai1in: I think it's determined by GHC and is documented in System.IO
12:44:04 <Heffalump> ah, that's says implementation-dependent but normally block-buffered for physical files
12:44:09 <Heffalump> http://www.haskell.org/ghc/docs/7.4.1/html/libraries/base/System-IO.html#g:12
12:44:16 <enolan> the actual read()/write() syscalls exist below the buffering layer
12:44:36 <sfogarty> and thanks, rwbarton, I would have gotten hung on the int_op real_op type kerfufle.
12:44:37 <enolan> since the point of buffering is to minimize the number of syscalls
12:47:56 <rwbarton> sfogarty, it can also provide an interesting example for discussion later of why do we need to pass (+) twice
12:48:04 <rwbarton> if you plan to get into the typechecking algorithm
12:48:38 <sfogarty> not for a bit, but yeah
12:48:51 <sfogarty> although I probably won't go into typeclass-based typechecking
12:51:49 <hiptobecubic> night
12:51:58 <hiptobecubic> wrong window :D, but goodnight everyone!
12:52:33 <Jello_Raptor> hmm, why does haskellnot like this type synonym?
12:52:37 <Jello_Raptor> type tableEntry = (Score,Gaps,(Code,Code),[Dir])
12:53:04 <Jello_Raptor> it's meant to be a tuple, but i get a syntax error on the first paren
12:54:16 <latro`a> is it possible you have something unclosed on the previous line or similar?
12:54:28 <latro`a> because that should work fine I think (though I'd encourage having a constructor anyway)
12:54:37 <tommo_> @hoogle (<+>)
12:54:37 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
12:54:37 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
12:54:37 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
12:54:39 <maukd> Jello_Raptor: TableEntry
12:54:39 <latro`a> oh wait
12:54:41 <latro`a> I see
12:54:41 <latro`a> yeah
12:54:44 <latro`a> TableEntry
12:54:55 <Jello_Raptor> ahh
12:54:55 <Jello_Raptor> thanks
12:57:08 <sfogarty> wooo. I have an interpreter that I think my students can duplicate. Once I teach them happy.
13:00:40 <ncs> how can i check 2 variables at once in a case statement? i.e., i have a function  :   f a b  and i want to check combinations of a and b at the same time
13:01:08 <Mon_Ouie> case (a, b) of … ?
13:01:44 <latro`a> in that simple case you can just match on the left side
13:01:47 <latro`a> or use case on a tuple
13:02:27 <ncs> the tuple solution works for me! thanks!
13:05:27 <startling> it's really neat how I can work on Data.Map.Map and hardly use any of the functions from Data.Map
13:05:37 <mog_> I kinda don't get how to use the modifiers in Quickcheck (such as Positive for example). Is there any good doc out there that covers Quickcheck basics such as that? Tutorials I found were too simple and the doc doesn't explain anything
13:06:49 <startling> mog_, yeah, I haven't found any good tutorials. I've only had success by reading the haddocks
13:07:20 <certainty> so if i use an as-pattern i can share structure? That is, when i cons a value onto a list bound by an as pattern, the value will be reused in the result?
13:07:59 <mog_> startling: ok ok I'll start there. Thanks for sharing your experience :)
13:08:17 <startling> mog_: and yeah, no idea how Positive et al are supposed to work. :/
13:18:00 * hackagebot hashed-storage 0.5.10 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.10 (PetrRockai)
13:19:44 <cark> what library should i use to get to play with the either monad ? there seems to be a few of these...
13:19:54 <parcs`> 971 people, nice
13:20:56 <startling> cark, `base` has most of it
13:22:02 <cark> i see there is an Either type there, but nothing related to monads
13:22:16 <nejucomo> cark: Perhaps you want Control.Monad.Error ?
13:22:49 <nejucomo> I'm not sure what you mean by the "Either monad", but assume you mean something akin to C.M.Error.
13:22:53 <cark> ah i think that is it
13:23:43 <cark> thanks !
13:24:45 <Clint> instance [safe] Monad (Either e) -- Defined in `Control.Monad.Instances'
13:26:01 <cark> Clint: ah that answer my question, but now i'm wondering which one i should use =)
13:26:30 <Clint> which what?
13:26:54 <cark> Control.Monad.Error or the Either monad
13:27:16 <Clint> depends what you want to do, presumably
13:27:38 <cark> My concern is more about using the most idiomatic one
13:27:55 <cark> and since i'm a newbie, i have no idea =)
13:37:47 <Kuraitou> What does 'Num (a -> a)' mean in a type constraint?
13:38:01 * hackagebot serialport 0.4.5 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.4.5 (JorisPutcuyps)
13:38:14 <fmapE> Kuraitou is this in an error message?
13:38:18 <Kuraitou> Nope
13:38:27 <fmapE> Where is it?
13:38:37 <Kuraitou> I'm playing around with function composition and came up with this and I'm trying to figure out what it means
13:38:39 <Ralith> Kuraitou: it means someone is doing something very strange.
13:38:40 <Kuraitou> ((2+) . (*)) :: (Num a, Num (a -> a)) => a -> a -> a
13:39:02 <lpsmith> Ok,  this is a really stupid question,  but I'm having a really stupid argument with a firewall guy.
13:39:09 <Ralith> Kuraitou: in this case, it means you are trying to multiply functions together.
13:39:19 <maukd> adding*
13:39:23 <rwbarton> that means ((2+) . (*)) can be given type a -> a -> a if a is a type for which a is an instance of Num and also (a -> a) is an instance of Num
13:39:27 <Ralith> maukd: no, multiply.
13:39:51 <maukd> I don't see it
13:39:57 <Kuraitou> So it's not really a valid operation?
13:40:18 <rwbarton> you should try applying it to a few variable arguments and expanding
13:40:20 <lpsmith> When I initiate a plain, vanilla TCP connection to another computer,   is there any way to specify the client-side source port that will be used for the connection?    Can it be done via the network package?   Can it be done using linux system calls?    Or is that totally outside my control?
13:40:24 <Ralith> (2+) . (*) == (\x -> (2+) * x) right?
13:40:47 <maukd> (2+) . (*) == \x -> (2+) ((*) x)
13:40:57 <maukd> == 2 + (x *)
13:41:14 <Ralith> @pl (\x -> (2+) * x)
13:41:14 <lambdabot> ((2 +) *)
13:41:14 <Azel> Kuraitou: Unless you have a instance of Num for functions, and there are none in standard Haskell, that's indeed invalid.
13:41:17 <Ralith> oh.
13:41:20 <Ralith> kay
13:41:34 <Ralith> right
13:41:39 <Kuraitou> I see, thanks guys.
13:41:47 <Ralith> Azel: not 'invalid' so much as 'useless'
13:42:03 <Ralith> it's valid code, you just won't be able to apply it.
13:42:45 <maukd> > ((2+) . (*)) 2 3
13:42:47 <lambdabot>   8
13:42:57 <Azel> Ralith: True, the user of your code could conceivably have created an instance of Num for functions
13:43:05 <latro`a> which lambdabot has
13:43:07 <latro`a> as you can see
13:43:08 * nejucomo starts imagining what a Num (a -> a) instance would mean...
13:43:09 <lpsmith> The problem is that the firewall (which I know very little about) is allowing connections,  but not allowing traffic back from the service I'm connecting to.    I'm trying to point out that the client side port on my end is dynamic and not chosen by me,  and for some reason we are talking past each other and a lot of accusations are starting to fly.
13:43:20 <latro`a> nejucomo--apply the operations to the output
13:43:25 <shachaf> > ((2+) * 5) 3
13:43:27 <lambdabot>   25
13:43:28 <Ralith> Azel: I mean, the definition in and of itself is legal regardless, right?
13:43:34 <latro`a> i.e. you can do a Num b => Num (a->b)
13:43:40 <startling> nejucomo, "12" is "const 12"
13:43:45 <maukd> nejucomo: you can define a Num instance for all Applicatives
13:43:47 <lpsmith> Namely, for not being able to answer his questions about what ports I need the other side to have access to.
13:43:55 <lpsmith> And not understanding how my application is written.
13:43:59 <XexonixXexillion> > (succ + pred) 5
13:44:00 <lambdabot>   10
13:44:14 <Ralith> whee
13:44:14 <nejucomo> Wait...  ((2+) * 5) doesn't type check in my simplistic mental model.  The left and right of '*' are different types.
13:44:28 <maukd> nejucomo: your type checker is broken :-)
13:44:30 <lpsmith> So I would like to know,  is it even possible to choose the client ports,  in principle,  using a vanilla TCP stack,  and using a vanilla network package.
13:44:34 <Azel> Yes, it's legal, so you're right, my usage of "invalid" was unjustified.
13:44:45 * Ralith rewards himself with lunch.
13:44:49 <latro`a> nejucomo--treat 5 as const 5
13:44:52 <latro`a> and you're good
13:44:55 <rwbarton> lpsmith, I think so but I'm not sure
13:45:12 <startling> > succ (const 5) 2
13:45:13 <lambdabot>   No instance for (GHC.Enum.Enum (b -> a))
13:45:13 <lambdabot>    arising from a use of `e_152' a...
13:45:26 <rwbarton> but normally firewalls are configured to allow return traffic of connections that originated from within the firewall, of course
13:45:36 <Ralith> :t (fromInteger 5) :: (a -> a)
13:45:37 <lambdabot>     Could not deduce (Num a) from the context ()
13:45:37 <lambdabot>       arising from a use of `fromInteger' at <interactive>:1:1-13
13:45:37 <lambdabot>     Possible fix:
13:45:48 <Ralith> or something like that.
13:45:52 <lpsmith> rwbarton, right, I don't understand why this is proving to be so difficult.
13:46:06 <XexonixXexillion> lpsmith: Which vanilla network package?
13:46:10 <lpsmith> as it's a plain old TCP connection of the variety that everybody else uses.
13:46:21 <lpsmith> XexonixXexillion, http://hackage.haskell.org/package/network
13:46:45 <nejucomo> This reminds me of a general issue I've had with typeclasses...  I kind of want the ability to have modular/safe orphan instances, where at the usage site I am explicit about which instances I want...
13:47:03 <nejucomo> -but I can't figure out how to make that sane and usable.
13:47:23 <nejucomo> The reason is that there is no single instance of a typeclass for a given type, logically.
13:47:53 <nejucomo> Take the idea of "the Either monad".  I can think of several, and perhaps different code would want to use different instances.
13:48:37 <Ferdirand> nejucomo: then you can use newtypes, no ?
13:49:12 <c_wraith> there are several different Either monads?  Isn't that statement equivalent to "there are several different Maybe" monads?
13:49:20 <c_wraith> quote placement fail
13:49:22 <c_wraith> anyway
13:49:27 <c_wraith> What other options are there?
13:49:28 <nejucomo> Ferdirand: I have several practical use cases where that falls down (requires a lot of boilerplate), so I wonder if there's a better way.
13:49:41 <nejucomo> c_wraith: Sure.
13:49:55 <Twey> c_wraith: For a start you can stop execution on Left or on Right
13:50:09 <nejucomo> Well, you could take the Error monad and imagine the Either analog.  Now flip Left and Right.  That's one example.
13:50:23 <Twey> There was an instance somewhere that required Exception on its Left argument, for some unknown reason
13:50:23 <c_wraith> oh.
13:50:27 <c_wraith> I meant something more specific
13:50:34 <nejucomo> The quick description of the newtype problem (and I could easily be missing an existing better way):
13:50:47 <c_wraith> For the exact type Either a, what other monad definitions are possible?
13:50:48 <nejucomo> Let's say I have a structure composed of many types.
13:51:09 <nejucomo> Now I am using two different JSON apis, and they encode some of the leaf-node types differently.
13:51:14 <c_wraith> It seems exactly isomorphic to Maybe
13:51:25 <nejucomo> -so I need a newtype for the leaf nodes if I'm using a json parsing typeclass.
13:51:37 <nejucomo> -but since they are leaf nodes, I must make newtypes for all the other types in the data structure.
13:51:44 <c_wraith> I guess you could encode the trivial monad in Maybe
13:51:52 <nejucomo> Pretty soon I have two giant piles of boilerplate which are almost identical.
13:51:56 <c_wraith> return _ = Nothing
13:52:06 <c_wraith> ok, there are two possible monads.
13:52:30 <nejucomo> c_wraith: I think there are more than two.  I think there are infinite, but I may be wrong.
13:52:34 <nejucomo> -for Either.
13:52:55 <c_wraith> I don't see how Either a allows any other instances.  In fact, it seems like it has *less* instances.
13:53:02 <c_wraith> Since you can't encode the trivial monad
13:53:07 <Twey> I don't think there are infinite instances that obey the monad laws
13:53:16 <nejucomo> Maybe for some wacky reason I want a Left result to be processed by an implicit function at each step.
13:53:27 <c_wraith> nejucomo: I'm pretty sure that breaks monad laws
13:53:32 <Ferdirand> nejucomo: but then it would violate the monad laws
13:53:39 <nejucomo> c_wraith: Doesn't it depend on the function?
13:53:51 <Twey> Sure; if it's ‘id’ you're fine ;)
13:53:54 <Ferdirand> not if the function is id
13:53:58 <Ferdirand> gah !
13:54:11 <Twey> You need ‘return x >>= f = f x’
13:54:14 <nejucomo> Oh, yes, I see that now.
13:54:42 <c_wraith> I'm pretty sure there's only one instance of Monad for Either.  Amusing, because Maybe does have two possible instances. (though only one is useful)
13:55:00 <nejucomo> Anyway, the other issue of the two piles of identical boilerplate...  I'd love a concise solution in haskell, but barring that, I'm interested if it's possible to have a language with "orphan instances that are sane/modular/composable/safe."
13:55:01 <Twey> c_wraith: Not including flipping Left/Right?
13:55:13 <Twey> That's a fairly significant difference, I think
13:55:30 <c_wraith> Twey: you can't do that without changing the definition of the type, as far as I can tell.
13:55:31 <nejucomo> Gotta run, but I'll be scanning the scrollback to see where this goes.
13:55:48 <rwbarton> you can try adding a phantom type parameter
13:55:51 <Ralith> c_wraith: that's just an artifact of syntax, though, isn't it?
13:56:04 <Twey> c_wraith: Just use Left x >>= f = f x; Right x >>= _ = Right x
13:56:17 <Twey> Oh, wait
13:56:19 <c_wraith> Twey: what's return?
13:56:22 <maukd> Twey: that looks like a type error
13:56:24 <Twey> return = Right
13:56:26 <Twey> But yeah
13:56:36 <Twey> Er, I mean, return = Left
13:56:49 <Ralith> Twey: hard to specify the instance, though.
13:56:56 <Ralith> I guess you can use a type synonym
13:57:01 <rwbarton> you can't
13:57:09 <c_wraith> Ralith: no, it's actually an artifact of type class resolution needing to be unambiguous
13:57:17 <c_wraith> Ralith: not syntax
13:57:28 <rwbarton> imagine I had return 3 :: Either Int Int
13:58:21 <Ralith> I mean the bit where you can easily specify (Either a) but not the type-level equivalent of ((flip Either) a)
13:58:44 <c_wraith> Ralith: And I'm saying that if you could specify it, you would make type class resolution basically impossible
13:59:00 <Ralith> c_wraith: why?
13:59:14 <c_wraith> Someone wrote a nice long post with examples.  I wonder if I can find it
13:59:28 <Ralith> unfortunately I need to head offline
13:59:38 <Ralith> would like to see that, though
14:00:19 <c_wraith> if I find it, I'll leave a note with lambdabot
14:00:23 <Ralith> thanks!
14:03:41 <astry_> Twey: you can pattern match using >>=? i didn't know that
14:03:56 <astry_> i thought you could only match using constructors?
14:04:45 <startling> astry_: Right is a constructor
14:04:49 <Ferdirand> astry_: but it is not matching here, it is defining (>>=)
14:04:55 <astry_> oh
14:04:56 <astry_> ok
14:05:06 <astry_> it looked like a pattern
14:05:11 <astry_> that would be cool..
14:05:40 <Ferdirand> "x >>= f = ..."  is like "(>>=) x f = ..."
14:08:19 <astry_> Ferdirand: i realize
14:09:32 <XexonixXexillion> lpsmith: Using Network.Socket you can just make a new socket, bind it to the address you want, and just send messages from there
14:10:01 <lpsmith> XexonixXexillion, don't I need a connect in there as well?
14:10:22 <lpsmith> (I'm reading the connectTo source right now to try to figure out who picks the source port under normal circumstances.)
14:10:39 <maukd> the OS
14:12:34 <XexonixXexillion> lpsmith: connect <yoursocket> <targetaddress> should be in there
14:14:08 <lpsmith> XexonixXexillion, right,  ok I understand this I think well enough to defend myself.  But geez, this firewall guy and I find it difficult to work together.
14:14:25 <benmachine> lpsmith: if you don't bind your client socket, I think it gets a randomly-chosen port
14:14:29 <benmachine> if you do it doesn't :P
14:15:00 <lpsmith> right, and in my case it's a randomly chose port in the /proc/sys/net/ipv4/ip_local_port_range
14:15:00 <benmachine> well, not randomly-chosen
14:15:04 <benmachine> but not-you-chosen
14:15:06 <lpsmith> well, not quite randomly chosen
14:15:06 <lpsmith> right
14:19:47 <hpaste> “Ludvik Galois” pasted “Connecting from a port of your choosing” at http://hpaste.org/74874
14:22:41 <kanedank> hey,, how do I enable something like M-. for haskell files? The command I'm using to generate TAG files are causing emacs to freeze when I try and load them
14:24:04 <shachaf> It might be easier for people to answer that question if you mention what M-. is. :-)
14:25:17 <SideEffffECt> hello, could please somebody explain to me why doesn't this pattern matching work out?
14:25:19 <SideEffffECt> http://pastebin.com/7JKsxYDG
14:25:21 <SideEffffECt> prfx0 doesn't work at all (returns just []), although it's 99% identical to prfx1
14:25:22 <maukd> The paste 7JKsxYDG has been copied to http://hpaste.org/74875
14:25:48 <shachaf> SideEffffECt: Because "e" matches any pattern.
14:25:53 <maukd> SideEffffECt: -Wall
14:25:56 <shachaf> Patterns are matched in the order that you give them.
14:25:59 <shachaf> Also what maukd said.
14:26:00 <geekosaur> shachaf, kanedank is looking for a tags table generator (like etags), apparently whatever they are using is hanging emacs on find-tag
14:26:18 <shachaf> s/pattern/value/
14:26:22 <geekosaur> kanedank, what are you using currently to create tags tables?
14:26:28 <shachaf> geekosaur: Ah, M-. is go-to-tag?
14:26:51 <shachaf> I've used hasktags to create tags file in the past. Worked fine with vim.
14:27:02 <SideEffffECt> hmm... how come, that e (which is set to be an alisas for [], that is a term of the type Str) matches everything?
14:27:07 <geekosaur> find-tag, in the versions of emacs I've used
14:27:07 <shachaf> If Emacs is freezing on a file, valid or invalid, I'd be inclined to blame Emacs. :-)
14:27:17 <shachaf> SideEffffECt: Because patterns don't work that way.
14:27:35 <Eduard_Munteanu> SideEffffECt: how could it know you want it to match []?
14:27:39 <shachaf> > case "hello" of { e -> e }
14:27:40 <lambdabot>   "hello"
14:27:56 <shachaf> SideEffffECt: Did you do what maukd said?
14:27:57 <geekosaur> but essentially yes.  and I too would suspect a bug in emacs, but I also would not be greatly surprised if nobody has checked the behavior of emacs in the presence of corrupt / incorrect tags tables
14:28:18 <XexonixXexillion> SideEffffECt: it makes a new 'e' with a more local scope, overwriting your definition of e
14:28:37 <Eduard_Munteanu> Oh, I missed that 'e'. Yeah, it doesn't work that way.
14:28:39 <SideEffffECt> Eduard_Munteanu: because I explicitly say, that e = [] :: Str, which is e = [] :: [Char]
14:28:49 <geekosaur> but that does not work
14:28:59 <geekosaur> as everyone has just told you, pattern matching creates a *new* e.
14:29:06 <shachaf> SideEffffECt: Did you compile your program with -Wall? :-)
14:29:09 <geekosaur> it does not care if an 'e' already exists or what type or value it has
14:29:44 <geekosaur> if you want to compare to an existing value you cannot use a pattern to do so (except maybe to pull out a value to compare), you must use a guard
14:29:47 <SideEffffECt> oh, that just makes me a sad panda... :(
14:29:54 <SideEffffECt> but thanks anyway for the answers
14:30:09 <geekosaur> pattern matches are structural, they do not compare anything
14:30:35 <benmachine> geekosaur: except for when they do :P
14:30:50 <benmachine> (numeric and character/string patterns)
14:31:37 <geekosaur> yeh, numbers are an ugly special case though (string/character patterns are just funnly looking constructor matches, unless you turn on the string version of numeric evil)
14:32:03 <shachaf> geekosaur: Whereas character literals are sort of in between.
14:33:00 <benmachine> SideEffffECt: the important thing to understand is that patterns are a different sort of thing from expressions
14:33:22 <benmachine> SideEffffECt: so 'e = []' kind of means "e is equal to [] in expressions" but not patterns
14:33:35 <benmachine> SideEffffECt: constructors can appear in both expressions and patterns, because they're special
14:34:24 <benmachine> SideEffffECt: there has in the past been proposals for "pattern synonyms" which would allow you to say "e is [] in patterns" or something to that effect, but they've not been implemented in GHC
14:35:14 <shachaf> It's not obvious how to make them work, or that they should work at all.
14:36:03 <SideEffffECt> benmachine: i see, interresting, thanks for the deeper info
14:36:39 <astry_> why is e not equal to [] in patterns?
14:36:55 <shachaf> SideEffffECt: By the way, GHC -Wall would've told you what was going on.
14:37:01 <benmachine> astry_: because patterns create new bindings, they don't use existing ones
14:37:02 <hpc> astry_: patterns aren't expressions, they're how you give things names
14:37:03 <SideEffffECt> well, it's speen a splendid patters session, but I'm on my way to bed, c u round :0
14:37:07 <SideEffffECt> :)
14:37:16 <astry_> so what happens if you use e in a pattern?
14:37:32 <maukd> it matches
14:37:34 <hpc> astry_: you name one of the parameters e
14:37:42 <benmachine> astry_: the same thing as happens if you use any other variable in a pattern
14:37:45 <hpc> > let id e = e in id 17
14:37:46 <lambdabot>   17
14:38:05 <astry_> oh
14:38:11 <hpc> astry_: it's very roughly analogous to trying to do an assignment backwards in any other language
14:38:18 <hpc> foo() {
14:38:21 <hpc>   7 = x;
14:38:25 <hpc>  ...
14:38:25 <hpc> }
14:38:31 <astry_> getting that right would require something similar conceptually to lifting / unboxing / whatever
14:41:54 * nej|meeting chats a bit before a meeting...
14:42:39 <nej|meeting> The bit about Monad was sort of a red herring.  I meant generally, for all type classes, for each type, there may be many consistent possible instances...
14:43:13 <nej|meeting> For example a mathematical group typeclass (would this be Monoid?) could apply to Integer with (+) and 0 or (*) and 1.
14:43:25 <nej|meeting> -so the type Integer doesn't imply a specific Group instance.
14:44:02 <shachaf> Monoids are like groups without inverses.
14:44:08 <shachaf> Well, without the requirement of inverses.
14:44:16 <shachaf> I don't think integers are a group with (*) and 1. :-)
14:44:18 <nej|meeting> The haskell way seems to be to pick one instance as blessed, whose definition lives with a type (or typeclass) definition.
14:44:38 <shachaf> nej|meeting: That's correct. One way around is is newtype wrappers.
14:44:46 <nej|meeting> Maybe I have my group definition wrong.  I think you can see what I mean.  (Maybe I mean rings?)
14:44:55 <shachaf> > getProduct (Product 2 `mappend` Product 3)
14:44:56 <lambdabot>   6
14:45:03 <shachaf> > getSum (Sum 2 `mappend` Sum 3)
14:45:04 <rwbarton> nej|meeting, you mean monoid :)
14:45:04 <lambdabot>   5
14:45:14 <monochrom> you can safely say "integer, 1, * is a monoid"
14:45:19 <nej|meeting> shachaf: Right, which brings me back to my other issue.  Sometimes the newtype approach is burdensome, and I wonder if there could be a language change to allow multiple instances sanely.
14:45:33 <shachaf> nej|meeting: It's trickier than you might think.
14:45:40 <nej|meeting> shachaf: I realize.
14:45:56 <nej|meeting> -well, I realize enough to know "it's tricky", but not enough to understand the compiler details.
14:46:08 <nej|meeting> Ok, now the meeting is becoming reality...
14:46:15 <shachaf> I don't mean compiler details, I mean semantics. :-)
14:46:18 <hpc> the simplest way is to just (Reader MonoidDict)
14:46:30 <nej|meeting> biab.
14:46:36 <monochrom> right, screw compiler details. get the semantics right first
14:46:39 <hpc> foo = do {dict <- ask; (mappend dict) 5 6}
14:46:51 <shachaf> nej|meeting: The classic example, as someone brought up yesterday, is that you might have a (Set Foo) with invariants that depends on the Ord instance for Foo.
14:47:32 <shachaf> hpc: I'm not sure why introduce Reader into this rather than just take an argument...
14:47:34 <monochrom> the #1 reason why so many languages are designed wrong: the designers think compiler details first. "oh I know how to do that in the compiler" then it's a go. but broken semantics
14:47:47 <hpc> shachaf: just to guarantee coherent instances
14:47:55 <shachaf> ?
14:48:11 <lpsmith> hahaha,  I think the firewall guy didn't quite understand how his firewall worked.
14:48:28 <monochrom> every ambiguity has a high chance of semantic insanity. you can bet money on that and win in the long run.
14:48:28 <XexonixXexillion> lpsmith: That's surprising? :p
14:48:33 <hpc> append3 dict x y z = append dict x (append differentDict y z)
14:49:15 <benmachine> hpc: well, sure, but, the Reader monad doesn't change that
14:49:23 <shachaf> hpc: Nothing stops you from doing that with Reader.
14:49:34 <hpc> it makes it significantly more annoying
14:49:40 <benmachine> especially ReaderT MonoidDict (Reader MonoidDict) a :P
14:49:48 <lpsmith> XexonixXexillion, well I think he thought that the emphemeral port range on the TCP specification meant that the traffic could be sent back to me at any time,  instead of requiring an outbound connection first.
14:49:52 <hpc> same way you can "always unsafePerformIO"
14:50:07 <lpsmith> Now, I don't do firewalls that much,  but I'm pretty sure that's wrong.
14:50:15 <benmachine> hpc: nah. Reader doesn't give you any assurances
14:50:32 <hpc> benmachine: it's exactly as much assurance as the IO monad :P
14:50:45 <shachaf> hpc: Wherever differentDict is coming from, it could come from the same place in the other case.
14:50:58 <benmachine> ^
14:50:59 <lpsmith> I could be wrong,  but I would think that the reverse port range only allows traffic back to me only when I've initiated a connection to the other guy.
14:51:03 <hpc> ... i know
14:51:18 <hpc> the point isn't "this is impossible", the point is "the wrong thing is much noisier to do"
14:51:54 <hpc> which to make an analogy, is the point of IO, since we always have the unsafePerformIO escape valve
14:51:56 <lpsmith> so anyway he restricted the reverse range down to a single port, the one I wanted to connect to,  so of course traffic wasn't getting back to me
14:52:20 <lpsmith> Oh well,  at least I learned a little bit about the sockets API today.
14:52:39 <lpsmith> And linux kernel IP4 settings.
14:52:56 <XexonixXexillion> lpsmith: So what you do, is you set up a vpn, get that working, and then stop caring about the firewall :p
14:53:30 <Baughn> @find (<|>)
14:53:31 <lambdabot> Not in scope: type variable `<|>'
14:53:45 <geekosaur> @index (<|>)
14:53:46 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
14:54:00 <geekosaur> hm, out of date I think.  Alternative?
14:54:21 <geekosaur> yep
14:54:28 <Baughn> Right, that's where it was.
14:54:35 <geekosaur> Control.Applicative
14:54:50 <geekosaur> (and Parsec 3 lives in a different namespace too...)
14:55:15 <lpsmith> XexonixXexillion, =)
14:55:48 <johnw> edwardk: do I use "at" to access the member of a list?
14:55:57 * Baughn is doing some bizarre firewall-rules-in-haskell thing
14:58:03 * hackagebot MFlow 0.1.5.1 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.1.5.1 (AlbertoCorona)
15:16:46 <mouna> could anyone helps me to understand this function ?
15:16:52 <hpaste> mouna pasted “problem to understand a function” at http://hpaste.org/74877
15:17:47 <ocharles> mouna: how far have you got?
15:18:27 <ocharles> mouna: my recommendation is to write this with explicit arguments, and then gradually evaluate it from right to left
15:18:42 <shachaf> > ((++"\n") . reverse . dropWhile (=='\n') . reverse) "blah blah
15:18:43 <lambdabot>   <no location info>:
15:18:43 <lambdabot>      lexical error in string/character literal at end o...
15:18:50 <shachaf> Oh, *understand*.
15:18:59 <maukd> did you mean: reverse . ('\n' :)
15:19:12 <shachaf> maukd: Given that this isn't code this person wrote, probably not.
15:19:15 * benmachine feels comforted by the :) at the end of maukd's version
15:19:18 <shachaf> But that would be a better way to do it.
15:19:26 <mouna> they are saying in the documentation of this function : Replace a string's 0 or more terminating newlines with exactly one.
15:19:38 <ocharles> mouna: yep, that looks like what it does
15:19:42 <mouna> but still didn't get what it does
15:19:46 <ocharles> it removes all trailing new lines, then adds exactly one
15:19:55 <maukd> mouna: where are you stuck?
15:19:58 <geekosaur> mouna, how much haskell do you understand?
15:19:59 <maukd> do you know any haskell?
15:20:07 <ocharles> the reverse . doSomething . reverse idiom is a common way of efficiently operating on the end of something
15:20:07 <mouna> yes
15:20:14 <shachaf> "efficiently"
15:20:22 <mouna> and tried to understand it but can't
15:20:34 <ocharles> shachaf: i don't think poking holes in this could will help the beginner
15:20:39 <geekosaur> what are you having trouble with?
15:20:40 <ocharles> code*
15:20:41 <maukd> mouna: where are you stuck?
15:21:10 <mouna> I mean I didn't get the point from the combination of all the functions
15:21:19 <maukd> mouna: why not?
15:21:26 <mouna> tried to execute one by one but still not getting the meaning
15:21:28 <geekosaur> do you understand what the individual functions do?
15:21:36 <mouna> yes of course
15:21:48 <maukd> mouna: where are you stuck?
15:22:03 <geekosaur> ... "of course" is not that clear, since given the meaning of the individual functions, the meaning of the combination is not difficult to derive
15:22:25 <mouna> I mean I tried it for an example but
15:22:34 <mouna> can't get the point
15:22:46 <maukd> wtf
15:23:12 <geekosaur> the point is building up a complex operation from individual operations.
15:23:41 <geekosaur> 'tried to execute one by one' did you try feeding the output from each stage to the next, to watch it be transformed as it works through the chain?
15:23:47 <merijn> I can only re-export imported values using an explicit export list, right?
15:26:26 <syntaxfree> it just dawned on me that coroutines aren't the dual of routines.
15:27:05 <KirinDave> syntaxfree: I was told the "co-" in that context was more a contraction of "cooperative."
15:27:13 <KirinDave> Like "coworkers"
15:27:21 <Baughn> It occurs to met that the monad I'm currently writing never, ever has a value other than ().
15:27:25 <syntaxfree> it's "co" as in parallel. "parallel" as in "in the same level", not "parallel execution".
15:27:31 <Baughn> In other words, I'm doing it just to get sequencing. Hm.
15:27:35 <mouna> ok I am trying executing it but don't know if I'm right or not
15:27:41 <hpaste> mouna annotated “problem to understand a function” with “problem to understand a function (annotation)” at http://hpaste.org/74877#a74879
15:27:53 <syntaxfree> jesus, I thought coroutines were this really hairy idea.
15:27:57 <syntaxfree> like corecursion.
15:28:18 <shachaf> syntaxfree: It's not parallel, it's concurrent. :-)
15:28:18 <maukd> mouna: look at what dropWhile does
15:28:26 <rwbarton> coordinates are not dual to ordinates
15:28:32 <mouna> ok
15:28:35 <maukd> cojoined twins
15:28:44 <syntaxfree> corecursion is hairy as shit in the general case, no matter how many simple para/ana examples you give me.
15:28:59 <syntaxfree> COSTUFF SHOULD BE DUAL TO STUFF. :'(
15:29:21 <rwbarton> hmm, there must be some better examples than that
15:29:22 <Lutin`> No stuff called 'dual *' should be dual
15:29:36 <dolio> The 'co-' prefix was around before category theory.
15:29:43 <maukd> colin ear
15:29:48 <Lutin`> co-operative
15:29:52 <Lutin`> co-operation
15:29:58 <merijn> syntaxfree: I mentally replace "co-" with "mathematician bizzaro world-"
15:30:09 <shachaf> coöperative
15:30:14 <rwbarton> "co-operation" is actually used in coalgebra
15:30:15 <merijn> shachaf++
15:30:31 <syntaxfree> my ears just went to my biliar gland and my spleen to my nose when I considered "dual core processor" as in categorically dual.
15:30:31 <maukd> coal
15:30:41 <rwbarton> e.g. "cohomology operation" -> "homology cooperation"
15:30:49 <merijn> shachaf: My supervisor corrected the spelling of coöperation in my paper because "that wasn't the proper spelling" :(
15:30:54 <syntaxfree> my internal organs are still finding their way into homeostasis.
15:31:06 <shachaf> merijn: Tell them that's how the New Yorker does it.
15:31:14 <maukd> syntaxfree: dual core processor == re processor
15:31:30 <merijn> shachaf: I did, I even pulled out the dictionary, but to no avail
15:31:39 <syntaxfree> I wish I understood cohomologies. I have a fairly intuitive understanding of homologies, but but but.
15:31:56 <merijn> Anyway, back to my earlier question: Re-exports only work with explicit export lists, right?
15:32:15 <dolio> maukd: I think you mean duel core.
15:32:26 <rwbarton> core wars?
15:32:34 <Lutin`> mexican stand off core
15:32:38 <monochrom> haha
15:33:27 <syntaxfree> you really only get gilles deleuze when you figure out about a third of what he's doing is inventing an ad hoc homology theory.
15:33:28 <monochrom> mexican comonad burrito
15:33:38 <hpaste> mouna annotated “problem to understand a function” with “problem to understand a function (annotation) (annotation)” at http://hpaste.org/74877#a74880
15:34:12 <maukd> mouna: I don't understand what that's supposed to mean
15:34:21 <maukd> e.g. what do the numbers refer to?
15:34:27 <syntaxfree> the other third is better explained in delanda (2000), where he explicitly takes deleuze's timid references to differential geometry (which he did not understand beyond a general concept) and makes it rigorous.
15:34:43 <syntaxfree> anyway, if you don't stop me from talking about deleuze I'll be awake all night.
15:34:53 <syntaxfree> and it's still 19:30.
15:34:56 <avpx> mouna: I also don't understand why you don't just prepend the \n while it's reversed
15:35:09 <shachaf> maukd: Is preflex ever coming back?
15:35:16 <maukd> shachaf: unknown
15:35:32 <syntaxfree> are monad comprehensions ever coming back?
15:36:16 <shachaf> They're already in GHC>
15:36:16 <mouna> could anyone help me by a step by step execution of an example ?
15:36:16 <monochrom> monad comprehension is already in GHC. in fact, you also get "group by", "sort by", the whole SQL shebang
15:36:29 <dolio> They fight each other.
15:36:29 <dolio> And give you more efficient results because of the competition.
15:36:30 <monochrom> (well, ok, I don't recall seeing natural join or division!)
15:37:40 <maukd> > "foo\n\n"
15:37:41 <lambdabot>   "foo\n\n"
15:37:46 <maukd> > reverse "foo\n\n"
15:37:47 <lambdabot>   "\n\noof"
15:37:50 <Lutin`> I don't even understand the point of that function
15:37:57 <maukd> > dropWhile (=='\n') (reverse "foo\n\n")
15:37:58 <lambdabot>   "oof"
15:38:04 <maukd> > reverse (dropWhile (=='\n') (reverse "foo\n\n"))
15:38:05 <syntaxfree> MONAD COMPREHENSIONS ARE BACK? WOO HOO!
15:38:05 <lambdabot>   "foo"
15:38:07 <Lutin`> Why not just takeWhile
15:38:16 <maukd> > (++"\n") (reverse (dropWhile (=='\n') (reverse "foo\n\n")))
15:38:18 <lambdabot>   "foo\n"
15:38:22 <MostAwesomeDude> Lutin`: Does something different.
15:38:38 <Lutin`> Not if you switch the predicate
15:38:47 <maukd> Lutin`: crash and burn
15:38:52 <monochrom> consider "x\ny\n"
15:38:58 <Lutin`> Yes
15:38:59 <MostAwesomeDude> > takeWhile (\='\n') "hurp\nderp\n"
15:38:59 <lambdabot>   Not in scope: `\='
15:39:04 <MostAwesomeDude> > takeWhile (/='\n') "hurp\nderp\n"
15:39:05 <lambdabot>   "hurp"
15:39:16 <Lutin`> Isn't that what you would want
15:39:33 <maukd> Lutin`: no
15:39:33 <Lutin`> Oh wait
15:39:42 <MostAwesomeDude> I have a feeling that this particular function was written by somebody who didn't know about unlines and lines.
15:40:03 <monochrom> see the power of counterexamples!
15:40:07 <Lutin`> I was looking at it as wanting to terminate at first newline
15:41:03 <Lutin`> not remove all newlines at the end then add another
15:43:37 <Lutin`> > let foo = reverse . (:) '\n' . dropWhile (=='\n') . reverse in foo "a\nb\n\n\n"
15:43:38 <lambdabot>   "a\nb\n"
15:43:58 <Lutin`> Yeah
15:44:31 <Lutin`> > let foo = unlines . lines in foo "a\nb\n\n\n"
15:44:33 <lambdabot>   "a\nb\n\n\n"
15:44:46 <mouna> maukd : I understood the example but still can't find what 's the cases when using this function ?
15:45:21 <maukd> mouna: what?
15:45:27 <Lutin`> > let foo = lines in foo "a\nb\n\n\n"
15:45:29 <lambdabot>   ["a","b","",""]
15:45:35 <Lutin`> Ahh
15:46:39 <shachaf> unlines . lines /= id
15:47:01 <maukd> @check \x -> unlines (lines x) == x
15:47:02 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\779011\"\n"
15:47:23 <mouna> maukd : for example the functions I encountred before are useful but this function doesn't to be useful or I am wrong ?
15:47:24 <johnw> argh, why doesn't PrintfArg export its class functions?
15:47:36 <nejucomo> Woah, how did lambdabot perform check?
15:47:57 <shachaf> @check \x -> x < 50000000000
15:47:58 <lambdabot>   "OK, passed 500 tests."
15:48:15 <Lutin`> wot
15:48:35 <ben> @check \x > x < maxBound
15:48:35 <lambdabot>   Parse error at ">" (column 4)
15:48:39 <ben> @check \x -> x < maxBound
15:48:40 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
15:48:45 <ben> :(
15:48:48 <zygoloid_> @check \xs -> length xs /= 12345
15:48:49 <lambdabot>   "OK, passed 500 tests."
15:49:33 <Cale> nejucomo: Using QuickCheck
15:50:32 <benmachine> @check \x -> x < 500
15:50:33 <lambdabot>   "OK, passed 500 tests."
15:50:50 <benmachine> guys, all numbers are less than 500
15:50:51 * monochrom is tempted to repeat his favourite test :)
15:51:04 * benmachine tempts monochrom 
15:51:16 <ocharles> benmachine: https://www.youtube.com/watch?v=f3ek85X2uOE
15:51:31 <Cale> @check \x -> x < 50
15:51:32 <lambdabot>   "Falsifiable, after 144 tests:\n65\n"
15:51:41 <Cale> hah, old quickcheck
15:52:30 <Cale> New QuickCheck will always produce 50 when it discovers a counterexample for that.
15:54:12 <shachaf> Cale: Yes, the version of GHC and libraries being run by lambdabot *is* rather old, isn't it...
15:54:49 <Cale> Yeah, it would be nice if that machine had a newer GHC
15:55:10 <Cale> I wonder if I can sudo on it.
15:55:29 <Cale> Well, maybe I could even install GHC as user.
15:55:47 <rwbarton> @check \x y -> x * y == 57
15:55:48 <lambdabot>   "Falsifiable, after 0 tests:\n0\n0\n"
15:56:02 <rwbarton> @check \x y -> not (x * y == 57 && x > 1 && y > 1)
15:56:03 <lambdabot>   "OK, passed 500 tests."
15:56:30 <Lutin`> Oh my. So what are the downsides to http://hackage.haskell.org/package/dlist
15:57:02 <benmachine> Lutin`: it's a pretty good thing, but you can't really inspect the list while building it
15:57:11 <Cale> Lutin`: The downside is that dlist just codifies a little trick which is lightweight and easy to apply by hand
15:57:18 <Lutin`> Ah
15:57:27 <Lutin`> Guess I should look at the source
15:57:35 <Cale> Lutin`: It's basically this...
15:58:03 <Cale> Suppose you have an algorithm which builds a list using [], [x] and (++)
15:58:29 <Cale> It might be slow due to recursive uses of (++) because (xs ++ ys) takes O(length xs) steps to reduce
15:58:46 <Cale> So it's easy to make something quadratic complexity if you have a growing left list
15:59:09 <Cale> So the trick is, instead of making a list, make a function which will add elements to the beginning of a list
15:59:14 <Cale> replace [] with id
15:59:19 <Cale> replace [x] with (x:)
15:59:25 <Cale> and replace (++) with (.)
16:00:01 <Cale> Since (.) always takes exactly one step to reduce, the complexity of your algorithm becomes better
16:00:18 <Cale> and then you can apply the function you get to an empty list at the end to get a normal list back
16:00:19 <Lutin`> So [1,2,3] becomes (1:2:3:)?
16:00:27 <Cale> ([1,2,3]++)
16:00:28 <hpc> yes
16:00:35 <Cale> or (1:) . (2:) . (3:)
16:00:55 <Lutin`> Ah
16:01:12 <Cale> (It's okay to use (++) with short left lists, it only becomes a problem when the left argument can grow)
16:01:18 <Lutin`> So it's almost like a functor from lists to functions
16:01:34 <Cale> Or a natural transformation
16:01:56 <Lutin`> Yeah
16:02:11 <Cale> So for example, suppose you have
16:02:12 <shachaf> > foldr (+) z [a,b,c,d]
16:02:13 <lambdabot>   a + (b + (c + (d + z)))
16:02:14 <shachaf> > foldl (+) z [a,b,c,d]
16:02:15 <lambdabot>   z + a + b + c + d
16:02:20 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
16:02:23 <Cale> and
16:02:29 <Cale> inorder Tip = []
16:02:36 <shachaf> > ($ z) . foldl (.) id . map (+) $ [a,b,c,d]
16:02:39 <lambdabot>   a + (b + (c + (d + z)))
16:02:39 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
16:03:03 <Cale> Then this performs poorly on leftward leaning trees
16:03:12 <Cale> But you can rewrite it as
16:03:16 <Cale> inorder' Tip = id
16:03:29 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
16:03:31 <Cale> and then
16:03:37 <Cale> inorder t = inorder' t []
16:03:50 <Cale> and magically you go from quadratic worst case to linear
16:05:28 <Lutin`> I lke it
16:07:06 <Cale> I've used an analogous trick with a program which constructed a lot of ByteString chunks which needed to be put into a different order than they'd initially be constructed in and concatenated into a final file. Simply replacing ByteStrings with functions ByteString -> ByteString made the program go from taking hours and hundreds of megabytes to a minute or two and maybe 20 megs.
16:07:59 <Cale> (I'm less certain about why that is, but I didn't really think about whether or why the transformation would buy me anything, I just applied it mindlessly and the program went faster and I was done :)
16:08:28 <cmccann> zen optimization
16:08:40 <shachaf> Wouldn't one of the Builder things be what you want for ByteStrings?
16:08:50 <cmccann> empty your mind, transform the code, accept the resulting improvements
16:08:59 <Eduard_Munteanu> I thought normal lists were ok for logging with the Writer monad.
16:09:07 <Cale> Eduard_Munteanu: they are
16:09:12 <Eduard_Munteanu> "This is particularly useful for efficient logging and pretty printing, (e.g. with the Writer monad),"
16:09:22 <Cale> yeah, that's nonsense
16:09:42 <Cale> The Writer monad associates things to the right anyway
16:09:49 <Cale> Well...
16:09:50 <Eduard_Munteanu> Yeah.
16:09:54 <Cale> Under normal use
16:10:32 <rwbarton> you can translate your inorder function naively to Tree a -> Writer [a] () and won't it have the same problem
16:10:53 <Eduard_Munteanu> Indeed.
16:11:11 <Eduard_Munteanu> I wonder if there's a name for that trick Cale mentioned, though.
16:11:21 <Cale> Worker-Wrapper transformation
16:11:24 <ocharles> Oh, I was just wondering about replacing a Writer [a] with this dlist stuff, but if I'm using Writer I don't need to worry as much?
16:11:34 <Eduard_Munteanu> Nice, thanks.
16:11:36 <ocharles> specifically, I build up an XML document for my web service with Writer [Node]
16:11:41 <ocharles> (XML.Types.Node)
16:12:10 <rwbarton> it depends on what kind of recursion you do, basically
16:12:23 <Lutin`> You should be able to abstract it to easily switch between the two
16:12:34 <ocharles> i don't do anything with it afterwards, i just hand it to xml-conduit to render
16:12:40 <agocorona>  /join #haskell-indeep
16:12:41 <shachaf> Eduard_Munteanu: Which trick? Composing (x++) functions?
16:12:45 <ocharles> profiling earlier did show it responsible for 30% of allocations
16:13:06 <Eduard_Munteanu> shachaf: that transformation Cale mentioned above, replacing concatenation with composition etc.
16:13:40 <shachaf> Eduard_Munteanu: "difference lists" refers to this particular example.
16:13:41 <shachaf> @hackage dlist
16:13:42 <lambdabot> http://hackage.haskell.org/package/dlist
16:13:59 <Eduard_Munteanu> ocharles: if you're producing a list as a result, (++) is no less efficient as long as you associate the right way.
16:14:03 <syntaxfree> wait, the new monad comprehensions are list comprehension-style, or SQL-style only?
16:14:10 <Cale> ah, yeah, I guess you may still want to use Endo [a]
16:14:14 <Cale> Or DList a
16:14:16 <Cale> which is the same
16:14:34 <ocharles> Cale: was that to me?
16:14:36 <cmccann> y'know, optimizing Haskell code used to be so much easier before -fvia-stack-overflow was deprecated because dons got a new job
16:14:37 <JoeyA> > [] <> []
16:14:37 <Cale> (I prefer not to pull in an extra package dependency for something that lightweight)
16:14:38 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
16:14:38 <lambdabot>         agains...
16:14:50 <shachaf> Cale: DList a is hardly the same.
16:15:12 <shachaf> There are many values of type ([a] -> [a]) that aren't of the form (x++)
16:15:22 <Eduard_Munteanu> shachaf: ah, you mean http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html
16:15:23 <Cale> ocharles: Yeah, and rwbarton, who correctly points out that Writer with the list monoid can suffer from left recursion issues.
16:15:31 <Cale> shachaf: Well, yes :)
16:16:01 <Cale> shachaf: I suppose DList *does* protect you from using functions that aren't ones that add elements to the beginning of a list
16:16:01 <ocharles> i think this warrants a bit more investigation then with larger xml responses
16:16:50 <shachaf> Cale: It's not just about protecting you, it's about making the meaning clear and the functions convenient.
16:17:06 <Cale> It is already convenient to work with functions
16:17:16 <Nereid> DList concatenation is just like a cps'd (++) right
16:17:30 <Cale> Nereid: it is like composition of functions
16:17:38 <Cale> (I just explained the trick that it uses above)
16:17:42 <hpc> there's a more general pattern, the (Endo a) monoid
16:17:42 <Nereid> well yes, cps'd anything is composition of functions.
16:17:50 <hpc> where mempty = id, mappend = (.)
16:18:07 <Nereid> or
16:18:09 <shachaf> http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/ is a nice sort-of-generalization of that.
16:18:13 <shachaf> Well, the paper that it links to.
16:18:30 <Eduard_Munteanu> Oh, that's the same thing?
16:18:33 <Lutin`> Yeah I mean if you look at http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/src/Data-DList.html#DList it's really simple
16:18:35 <JoeyA> It'd be nice if there were a helper package for DList (or even just Endo [a]) to make working with Writer a tad easier.
16:18:39 <hpc> codensity does that transformation for (>>=) instead of (++)
16:18:42 <hpc> or something like that
16:18:42 <JoeyA> execWriterDL :: Monad m => WriterT (DList item) m a -> m [item]; tellItem :: Monad m => a -> WriterT (DList a) m ()
16:19:16 <JoeyA> These are really easy to write, but I just don't like writing tell . DL.singleton all over the place.
16:19:38 <ocharles> tell . return -- is a bit more general
16:19:41 <Eduard_Munteanu> Is that the same as the Yoneda trick too?
16:19:51 <Cale> Has anyone here used groundhog?
16:20:11 <Cale> http://hackage.haskell.org/package/groundhog -- this looks nice
16:20:12 * Eduard_Munteanu vaguely recalls edwardk blogging about it
16:20:41 <Nereid> I read through edwardk's free monads for less articles and most of it made sense but I couldn't quite figure out where the monad operations came from.
16:20:46 <Nereid> I'll have to think about it again.
16:21:03 <JoeyA> What's the main difference between groundhog and persistent?
16:21:24 <benmachine> Cale: that package description isn't
16:21:28 <jfischoff> Cale: I here bos's sql mapping approach is also pretty effective
16:21:43 <benmachine> (a package description)
16:21:44 <Lutin`> Couldn't you write tell . (:) all over the place
16:21:45 <Cale> jfischoff: What is that?
16:21:56 <hpc> Lutin`: that'd be painful
16:22:09 <Lutin`> Instead of tell . DL.singleton not as bad
16:22:14 <jfischoff> Cale: I can't remember the name, stepcut would know. It has sql in it
16:22:44 <rwbarton> not if you're using DList because there is a newtype constructor too
16:22:53 <rwbarton> tell . DL . (:)
16:23:13 <Lutin`> Shouldn't we be able to abstract this out
16:23:27 <Lutin`> So it looks the same for [a] and DList a
16:23:54 <Cale> benmachine: It's a database persistence thing
16:24:16 <Lutin`> Oh
16:24:21 <Lutin`> tell . return
16:24:44 <benmachine> Lutin`: write a wrapper for tell
16:29:47 <Lutin`> Oh
16:29:53 <Lutin`> Just write a MonadWriter instance
16:30:37 <Cale> JoeyA: http://www.haskell.org/pipermail/haskell/2011-June/022851.html appears to discuss it though apparently after Groundhog was released, there were changes made to Persistent inspired by Groundhog, so I'm not totally sure now :)
16:34:31 <int80_h> anyone here using nixOS?
16:39:53 <Lutin`> Yeah
16:40:28 <Lutin`> I have it on a VM
16:42:16 <Eduard_Munteanu> int80_h: quite a few people in here, AFAIK, why?
16:42:28 <edwardk> @tell john element
16:42:28 <lambdabot> Consider it noted.
16:42:36 <edwardk> @tell johnw element
16:42:36 <lambdabot> Consider it noted.
16:43:01 <edwardk> some guy named john will be rather surprised when he finds this channel
16:43:06 <john> hello
16:43:07 <lambdabot> john: You have 1 new message. '/msg lambdabot @messages' to read it.
16:43:12 <Eduard_Munteanu> :)
16:43:24 <edwardk> fixed
16:43:45 <monochrom> hehe
16:43:56 <JoeyA> tell john We've been expecting you...
16:45:17 <rwbarton> !tell mauke welcome back!
16:45:29 <rwbarton> @tell mauke welcome back!
16:45:29 <lambdabot> Consider it noted.
16:45:35 <monochrom> clever!
16:46:05 <monochrom> also, what is the name of a recurring troll who will come back next? :)
16:46:11 <JoeyA> @tell lambdabot Oh hi there!
16:46:12 <lambdabot> Nice try ;)
16:46:19 <monochrom> haha
16:46:28 <MostAwesomeDude> She's pretty clever.
16:46:46 <JoeyA> Now that's what I call "self-aware"
16:46:48 <johnw> edwardk: hi!
16:46:48 <lambdabot> johnw: You have 1 new message. '/msg lambdabot @messages' to read it.
16:46:54 <Lutin`> @tell ChanServ Hey sexy
16:46:54 <lambdabot> Consider it noted.
16:47:02 <JoeyA> lol
16:47:47 <edwardk> @tell lambdabot @tell lambdabot @tell lambdabot @tell lambdabot hello
16:47:47 <lambdabot> Nice try ;)
16:47:57 <edwardk> would work better if there were two of them
16:48:42 <edwardk> then i wonder if you could mix @tell with something else with @. to get a fixed point
16:48:57 <rwbarton> there were two of them earlier today
16:49:10 <ddarius> @google concat, map, filter vanish
16:49:13 <lambdabot> http://lambda.csail.mit.edu/~chet/papers/others/p/partial-eval/voigtlander02icfp.pdf
16:49:13 <lambdabot> Title: Concatenate, Reverse and Map Vanish For Free
16:52:23 <JoeyA> {-# RULES "why" forall a. a = error "What's the point of all this needless complexity, anyway?" #-}
16:53:26 <JoeyA> A rewrite rule that asks the developer to look at the big picture.
16:53:52 <JoeyA> Though I hear GHC 7.8 will be able to do some of that automatically.
16:54:46 <Dodek> i heard GHC 8.0 will be able to iteratively improve itself until it becomes self-aware.
16:55:42 <dented42> :D
16:56:37 <Lutin`> At that point it will realize the futility of all of it's needless complexity
16:57:15 <benmachine> and of everything else too
16:57:20 <benmachine> and set about bringing it all to an end
16:57:33 <Lutin`> Through untyped lambda calculus
16:59:29 <Lutin`> Actually by that point it will have transcended lambda calculus
16:59:40 <Lutin`> MOst likely
17:03:55 <Cale> If you want needless complexity, today I replaced the use of a plugin for grails called "searchable", which is an interface to a library called Compass, which itself is "a simple API for working with Lucene", which itself is an indexing and search library built on top of relational database backends. Skedge.me would occasionally fail when this "magnificent" stack of software would somehow get jammed and stop searching.
17:03:56 <Cale>  So I replaced it with a SQL query.
17:05:04 <benmachine> :D
17:05:07 <benmachine> good work
17:05:56 <hpaste> ezyang pasted “Inflated code” at http://hpaste.org/74881
17:08:12 <cmccann> Cale, industry loves simple practical solutions like that software stack for Getting Things Done (tm). academic languages like Haskell just can't match that kind of pragmatic architecture.
17:08:47 <purefn> to be fair, lucene has nothing to do with relational dbs
17:09:30 <Cale> purefn: In that case, I have no idea what the thing was doing -- in our case, it was searching through a bunch of records which were already in a relational database.
17:09:54 <cmccann> of course not, nobody uses an relation DB without at least two intermediate layers of abstraction
17:10:04 <cmccann> ...an relation?
17:10:16 <purefn> that's fair. but the idea of lucene is to be able to do fast, full text searches. i'm not saying it was misused, just that it has nothing to do with relational dbs
17:10:19 * cmccann needs to stop trying to type words.
17:10:38 <purefn> er wasn't misused
17:11:12 <Cale> purefn: Ah, okay, so it was probably that somewhere higher up this stack of software, Lucene was being abused to do text searches on database records.
17:11:33 <Cale> (Text searches which could just as well be accomplished in SQL with LIKE)
17:11:55 <purefn> right. if it wasn't for searching based on user input ala google, then there isn't much point
17:12:26 <purefn> LIKE in sql is extremely basic compared to the type of text searching lucene provides
17:12:51 <Cale> Yeah, but we didn't even need a LIKE in which there was more than one % at the end of the query here.
17:13:19 <purefn> heh lucene was definitely overkill then :)
17:15:01 <Cale> https://svn.codehaus.org/grails-plugins/grails-searchable/trunk/src/java/org/codehaus/groovy/grails/plugins/searchable/compass/config/ -- I think this directory of filenames says about everything that needs to be said about this style of architecture.
17:16:09 <Cale> https://svn.codehaus.org/grails-plugins/grails-searchable/trunk/src/java/org/codehaus/groovy/grails/plugins/searchable/compass/config/mapping/ might even be better
17:16:42 <newmind> ahh, beautyful! self-documenting file placement
17:16:55 <Cale> SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator.java
17:17:09 <newmind> <3 java and its calssnames
17:17:16 <cark> Cale: you missed a factory in there
17:17:25 <newmind> (god, what is wrong with my typing today?)
17:17:30 <maukd> FactoryFactory
17:17:35 <Cale> cark: That's an actual class.
17:17:51 <cark> !
17:17:52 <Cale> cark: But since you asked: SearchableGrailsDomainClassMappingConfiguratorFactory.java
17:18:23 <Cale> (it's in that directory I linked)
17:18:36 <newmind> as expected....
17:18:52 <Cale> CompositeSearchableGrailsDomainClassCompassClassMapper classMapper = SearchableGrailsDomainClassCompassClassMapperFactory.getDefaultSearchableGrailsDomainClassCompassClassMapper(defaultExcludedProperties, defaultFormats);
17:19:05 <Lutin`> What
17:19:25 <newmind> i think i'll take that line, and use it from now on as an example why i don't like java <.<
17:19:53 <Cale> THIS CODE IS EXCELLENT CODE, I AM AN EXCELLENT ENTERPRISE PROGRAMMER ACCOMPLISHING REAL WORLD TASKS USING PATTERNS LIKE I READ ABOUT IN ALL THE JAVA BLOGS
17:20:55 <newmind> it probably is pretty decent java code, thats the sadest thing about it >.<
17:21:04 <Cale> How does someone write this and not take a step back and wonder what the fuck they're doing?
17:21:08 <newmind> that something like this is a prime example of "quality code"
17:24:39 <hpaste> hoyor pasted “neg” at http://hpaste.org/74882
17:28:29 <monochrom> language limits thought
17:29:04 <ahkurtz> there can be no thought without constraint
17:31:06 <newmind> well. java has its advantages....
17:31:32 <newmind> i wouldn't call it an elegant or beautiful language though
17:33:00 <cmccann> yes, java has advantages, such as providing a platform where anyone halfway sane can use clojure or scala instead
17:33:42 <newmind> also: you can hire (and replace) java "programmers" by the truckload
17:34:04 <shachaf> Is it make-fun-of-java-o'clock already?
17:34:10 <newmind> yeah
17:34:28 <avpx> shachaf: It's actually just past make-fun-of-Java-thirty
17:36:27 <monochrom> people enjoy puzzles. a language that forces you to encode a straightforward idea into an elaborate edifice is a great puzzle.
17:36:57 <Lutin`> This is true
17:37:12 <Lutin`> Sometimes I'm disappointed at how easy something is in haskell haha
17:37:19 <glguy> monochrom: are we talking about Agda now?
17:38:03 <cmccann> if something seems too easy in haskell, you can always start adding extra type-level hoops to jump through to ensure minor bits of correctness!
17:38:03 <monochrom> how does someone write this and not take a step back and wonder "this proves my worth"? :)
17:38:28 <Lutin`> cmccann: I'll start making everything free monads
17:38:33 <cmccann> it's at least sort of technically useful, and you can add nearly unbounded amounts of complexity with type hackery.
17:38:43 <monochrom> glguy, search scrollback for "<Cale> https://svn.codehaus.org/grails-plugins" for context
17:38:45 <cmccann> no, free monads are too simple, that doesn't help
17:39:03 <Lutin`> I'll do everything on the type level?
17:39:21 <glguy> monochrom: I knew what you meant :-p
17:39:27 <aristid> Lutin`: no, that's hard but a lame way to create complexity
17:39:30 <monochrom> oh haha ok!
17:39:41 <tsou> (btw curious..  on what do we base that this code is considered decent java code?)
17:39:54 <cmccann> yes, making types say complicated things about what's going on with the values is the right way to create complexity
17:39:56 <glguy> Haskell is the language of over abstraction
17:40:05 <glguy> we have to be careful making fun of Factories
17:40:21 <newmind> haskell is on the other extreme end of java
17:40:23 <aristid> glguy: factories are not a very meaningful abstraction
17:40:38 <Lutin`> We're not making fun of factories necessarily
17:40:42 <newmind> while java makes you code trivial things explicitly
17:40:48 <monochrom> perhaps "factory" is shorter than "smart constructors"
17:40:52 <newmind> in haskell you can do pretty complex stuff implicitly
17:40:52 <Lutin`> Just the god awful 30 charater names
17:40:55 <Lutin`> imo
17:41:10 <maukd> in perl, all constructors are smart
17:41:12 <mapreduce> Java code is tending more toward referential transparency over the years.
17:41:14 <aristid> monochrom: in other words, a hack around the lack of functions? ;)
17:41:53 <monochrom> however, I disdain the Command pattern "class CallMe { void callme(); }"
17:42:36 <rwbarton> yes, particularly if you cannot abstract over the identifier callme
17:43:07 <aristid> isn't there some kind of interface for things that can be called/run? Runnable or so?
17:43:17 <newmind> there is
17:43:32 <newmind> its just one method you know that you can call
17:43:33 <dibblego> Callable too
17:43:41 <dibblego> Java is hilarious
17:43:49 <monochrom> oh sure, "interface CallMe { void callme(); }" is such a vast improvement over "class CallMe { void callme(); }"
17:43:56 <dibblego> http://functionaljava.org/ I take that hilarity seriously, so I did this
17:45:00 <newmind> thats... actually pretty awesome
17:45:12 <aristid> dibblego: using anonymous classes to simulate lambdas?
17:45:25 <dibblego> of course, do I have a choice?
17:45:29 <ivan> IDEA collapses Command patterns into things that look closer to lambdas
17:45:30 <ivan> also Java 8
17:45:34 <Boney> Try compiling a higher order language into Java.  All the subclasses!!
17:45:50 <benmachine> @remember Cale THIS CODE IS EXCELLENT CODE, I AM AN EXCELLENT ENTERPRISE PROGRAMMER ACCOMPLISHING REAL WORLD TASKS USING PATTERNS LIKE I READ ABOUT IN ALL  THE JAVA BLOGS
17:45:50 <lambdabot> I will remember.
17:45:59 <aristid> dibblego: so you chose to have your functions uncurried and created F, F2, F3...?
17:46:22 <dibblego> aristid: yes, the JVM penalises you for calling methods y'know
17:46:53 <monochrom> do you have F17? :)
17:47:11 <aristid> monochrom: F8 is max
17:47:30 <latro`a> wasn't reading
17:47:31 <latro`a> scrolled up
17:47:33 <latro`a> saw java
17:47:35 <latro`a> head exploded
17:48:04 <Lutin`> So uh
17:48:08 <avpx> Meh, I don't really mind the Java anonymous-functions-through-anonymous-instances pattern.
17:48:18 <Lutin`> We might actually be able to have faster than light travel :O
17:48:20 <Lutin`> woo
17:48:26 <aristid> dibblego: i suspect the JVM isn't really the best platform for really functional programming.
17:48:31 <avpx> I think it makes sense within the object-oriented paradigm, and means fewer features for the Java language. And I prefer more minimal language features.
17:49:01 <maukd> I prefer maximal language features
17:49:02 <Lutin`> Also just to throw this into the mix, Scala is JVM
17:49:09 <dibblego> aristid: it can be done, with difficulty and a suitable language — I just wanted to show Java at its shiniest to the Java guys
17:49:15 <avpx> maukd: I think maximal *library* features is better
17:49:26 <avpx> Haskell strikes a nice balance, I think.
17:49:26 <rwbarton> I found Android UI code even in Scala to be ridiculously verbose "levelRG.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener { def onCheckedChanged(group: RadioGroup, checkedid: Int) = updateTVs })"
17:49:28 <maukd> just fewer of them
17:50:08 <Lutin`> Yeah I mean
17:50:39 <latro`a> Lutin`, wat
17:50:41 <latro`a> @ FTL
17:50:54 <Lutin`> http://news.yahoo.com/warp-drive-may-more-feasible-thought-scientists-161301109.html
17:51:08 <avpx> Probably better for #haskell-blah?
17:51:20 <dibblego> avpx: yeah good idea, thanks
17:51:35 <Lutin`> Yeah I was just throwing it out there
17:51:54 <monochrom> Cale will explain to you how records and lambda suffices to give you the maximum flexibility of choosing to be functional, OO, or somewhere between. unless you prefer inheritance.
17:52:16 <latro`a> I feel like actually using a warp drive would probably be disastrous in some way
17:52:18 <latro`a> >.>
17:52:27 <latro`a> eh, should stop if I'm not gonna go to haskell-blah
17:52:53 <aristid> monochrom: i wonder whether SomeException is more of an example on how to make subtypes in haskell, or a cautionary tale
17:53:35 <shachaf> SomeException is the devil. :-(
17:53:40 <Lutin`> Is there a way to type latex in haskell/agda?
17:54:00 <rwbarton> Lutin`, can you be more specific?
17:54:01 <Lutin`> instead of going through unicode tables
17:54:16 <Lutin`> Like using latex syntax for special characters
17:54:24 <maukd> editor question?
17:54:31 <Lutin`> Ah, true
17:54:34 <rwbarton> M-x set-input-method TeX
17:55:24 <rwbarton> assuming if you are using agda you must be using emacs :)
17:55:48 <Lutin`> vim actually..
17:55:57 <monochrom> instead of just looking at number of features and minimizing it, you should be looking at the feature : choice ratio and minimizing it. fewer features, but more choices
17:56:36 <dmwit> I dunno.
17:56:50 <monochrom> but of course, despotic communities want to limit choice. GvR is out to eliminate all alternative programming styles.
17:56:52 <dmwit> I have a clothes washer with one button on it that I like pretty well.
17:57:37 <geekosaur> ...but does it also have only one indicator?
17:58:10 <geekosaur> (from GvR to S. R. Bourne in one leap...)
17:58:28 <monochrom> one button sufficies if the machine takes morse code for input
17:59:06 <geekosaur> and now I;m thinking SxS
17:59:13 <geekosaur> (stop me, I'm thinking again)
17:59:29 <dmwit> GEEKO, STAHP
18:10:01 <Lutin`> GEEKO, WAT R U DOIN
18:21:11 <Jafet> > let x | x == 0 = 0 | otherwise = 1 in x
18:21:15 <lambdabot>   mueval-core: Time limit exceeded
18:23:07 * hackagebot lojysamban 0.0.2 - Prolog with lojban  http://hackage.haskell.org/package/lojysamban-0.0.2 (YoshikuniJujo)
18:23:28 <rwbarton> @pl \x -> if x then 1 else 0
18:23:28 <lambdabot> flip (flip if' 1) 0
18:23:38 <rwbarton> is there a good point-free way to write this?
18:23:54 <rwbarton> fromEnum I guess
18:23:57 <rwbarton> > fromEnum True
18:23:58 <lambdabot>   1
18:24:04 <shachaf> bool 0 1 :-)
18:24:11 <cmccann> there would be if "bool" existed
18:24:24 <rwbarton> that would be nicer actually because I need a Word32
18:24:32 <cmccann> pf, and shachaf beat me to it anyway
18:24:51 <rwbarton> no actually I just need an Int, great
18:25:02 <rwbarton> I feel fromEnum is a bit obscure though
18:25:49 <geekosaur> doesn't seem obscure to me
18:26:09 <benmachine> I think fromEnum is silly
18:26:17 <benmachine> although it's common enough that it's not too bad
18:26:43 <rwbarton> obscure isn't quite the word I want
18:26:44 <liyang> It depends on the constructor ordering of data Bool… I wouldn't use it like that.
18:26:59 <rwbarton> it's just that it's not terribly obvious in the context what type it is being used at
18:27:00 <shachaf> liyang: I think False < True is pretty universally accepted.
18:27:15 <shachaf> rwbarton: Writing a special-purpose function for it isn't so bad.
18:27:28 <shachaf> If you really want to be clear.
18:27:31 <Jafet> But succ False = True isn't
18:27:53 <liyang> shachaf: doesn't preclude its Enum instance from doing the wrong thing though.
18:27:59 <shachaf> True. But with "deriving" and the two possible definitions of Bool, one implies the other. :-)
18:28:02 <shachaf> (Doesn't it?)
18:28:13 <rwbarton> Yeah, I was just hoping for something off-the-shelf.
18:28:15 <shachaf> Anyway writing out the "if" long-hand is always an option.
18:28:42 <benmachine> shachaf: yes, I think so
18:29:06 <benmachine> also, I think one might reasonably expect fromEnum to be an order-preserving map
18:29:19 <benmachine> in which case the existing definition is fairly inevitable
18:29:45 <applicative_> I wonder if the source for http://ghc.io/ is available somewhere
18:31:01 <shachaf> applicative_: I found it in about a minute of looking things up. :-)
18:31:13 <shachaf> Admittedly I took a roundabout path.
18:31:16 <applicative_> hm, really.
18:31:20 <shachaf> https://github.com/dterei/GhciOnline
18:31:30 <applicative_> hah
18:31:36 <applicative_> thanks
18:31:48 <Jafet> github.com/*/*ghcio*
18:32:24 <shachaf> Jafet: whois ghc.io --> nic.io -> David Terei --> google.com/search?q=david+terei+github
18:32:28 <shachaf> So almost that.
18:33:11 <Jafet> You should advise him not to leave his name in WHOIS records.
18:33:25 <rwbarton> I wonder what packages are installed here
18:33:53 <shachaf> Pft, it won't even let you import System.IO.Unsafe.
18:34:24 <rwbarton> I know right!
18:34:31 <rwbarton> or ByteString
18:34:54 <Jafet> http://codepad.org
18:34:57 <rwbarton> can't I write unsafeCoerce anyways
18:34:59 <shachaf> ByteString.Internal has all sorts of unsafe functions.
18:35:10 <shachaf> rwbarton: Depends on what extensions are enabled, I think?
18:35:17 <shachaf> Can you write unsafeCoerce using plain Haskell 2010?
18:35:31 <rwbarton> I was going to try the GeneralizedNewtypeDeriving thing
18:35:36 <Jafet> I hope not
18:35:45 <shachaf> Hmm, it won't let you hand-write Typeable instances.
18:35:50 <rwbarton> but I guess that is an understood issue and probably one of the extensions I need to do it is not Safe Haskell-compatible
18:36:03 <benmachine> shachaf: I think so, via unsafePerformIO
18:36:10 <benmachine> well.
18:36:15 <shachaf> benmachine: Doesn't count. :-)
18:36:16 <benmachine> it won't be standards-compliant, I guess
18:36:35 <benmachine> there's an unsafeLocalState in H2010 but I think it disallows that sort of thing in its docs
18:36:55 <rwbarton> I like the "help"
18:37:04 <rwbarton> Prelude> :?
18:37:04 <rwbarton> GHCi Online...
18:37:42 <parcs`> rwbarton: there's fromBool
18:37:57 <shachaf> Hah, there is.
18:37:58 <rwbarton> huh!
18:38:04 <shachaf> Foreign.Marshal.Utils
18:38:23 <benmachine> rwbarton: GNTD is disabled by Safe Haskell
18:38:24 <benmachine> iirc
18:38:26 <rwbarton> I would use exactly that if it weren't in such a scary sounding package
18:38:35 <rwbarton> er, module
18:38:41 <parcs`> you can just import Foreign
18:38:47 <shachaf> rwbarton: Don't be xenophobic.
18:38:54 <Jafet> @quote fromJust
18:38:55 <lambdabot> SamB says: [on the subject of fromJust] SamB_XP thinks that unJust would be a more fun name for that
18:39:02 <Jafet> @quote fromJust
18:39:02 <lambdabot> SamB says: [on the subject of fromJust] SamB_XP thinks that unJust would be a more fun name for that
18:39:10 <Jafet> @quote ddarius fromJust
18:39:11 <lambdabot> No quotes match. Just what do you think you're doing Dave?
18:39:25 <rwbarton> I guess with a bounded import it's acceptable
18:39:28 <shachaf> @quote ddarius unsafeCoerce
18:39:28 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
18:40:21 <shachaf> rwbarton: But thing of all those spoooky Foreign instances you're importing!
18:43:27 <rwbarton> with DataKinds, if I have a class Foo (X :: Bool), say, and both instance Foo False and instance Foo True, can I discharge a (Foo x) constraint automatically?
18:43:35 <rwbarton> I will guess no
18:44:06 * shachaf would guess the same thing.
18:45:20 <pikanso> hi
18:45:42 <benmachine> rwbarton: do it and find out?
18:46:08 <rwbarton> oh right I can actually test DataKinds now because I installed 7.4
18:46:26 <shachaf> You should install 7.6!
18:46:31 <shachaf> Then you can test DataKinds-working-properly.
18:46:48 * shachaf doesn't know if there's anything wrong with DataKinds in 7.4, but there were rumors.
18:46:52 <rwbarton> I hear it's a mess at the moment
18:46:58 <rwbarton> in terms of the cabal/hackage landscape
18:47:02 <shachaf> Yes. :-(
18:47:08 <shachaf> What do we do about fixing that?
18:47:20 <benmachine> I'm glad that I still have 7.4 even though I've installed 7.6
18:47:21 <shachaf> I mean, there are a bunch of packages that have easy fixes, but their maintainers aren't around or something.
18:47:31 <shachaf> dmwit: You probably know.
18:47:35 <benmachine> shachaf: I think in many cases the answer is just "wait"
18:48:31 <shachaf> benmachine: :-(
18:49:08 <shachaf> CosmicRa`: For example, MissingH is broken on 7.6.
18:49:17 <benmachine> yes but that's a silly package anyway >_>
18:49:37 <shachaf> Someone told me they couldn't switch to 7.6 because of it and a few others.
18:50:30 <shachaf> Looks like Bits had a Num superclass in 7.4 and not in 7.6.
18:51:18 <benmachine> that's true
18:51:22 <benmachine> that's sensible though, imo
18:51:50 <shachaf> Yes, but it breaks things. :-)
18:51:54 <shachaf> Also the whole exception mess.
18:52:05 <BMeph> benmachine: Having it before, or losing it now? ;)
18:52:22 <benmachine> BMeph: losing it
19:07:19 <john_r_watson> Can anyone explain the following:
19:07:19 <john_r_watson> *Main> (readFile "words.txt") >>= (print . length)
19:07:19 <john_r_watson> 16345
19:07:19 <john_r_watson> *Main> (withFile "./words.txt" ReadMode hGetContents) >>= (print . length)
19:07:22 <john_r_watson> 0
19:07:38 <scshunt> :t withFile
19:07:39 <lambdabot> Not in scope: `withFile'
19:07:39 <startling> john_r_watson: explain what?
19:07:50 <rwbarton> yes, withFile closes the file before hGetContents has read any of it
19:07:56 <john_r_watson> startling: why my withFile fails
19:08:08 * hackagebot lojysamban 0.0.3 - Prolog with lojban  http://hackage.haskell.org/package/lojysamban-0.0.3 (YoshikuniJujo)
19:08:17 <shachaf> john_r_watson: hGetContents shouldn't be used with withFile.
19:08:28 <john_r_watson> rwbarton: I see
19:08:35 <john_r_watson> shachaf:
19:08:36 <shachaf> It closes the handle automatically when it's done, but until it's done it relies on the handle staying open (or "semi-open").
19:08:57 <john_r_watson> shachaf: what is one supposed to use w/ withFile in this case?
19:09:10 <shachaf> Other things that don't do lazy I/O.
19:09:48 <shachaf> (Alternatively, you can force the length.)
19:09:53 <Jafet> hGetContents' h = do x <- hGetContents h; evaluate (length x); return x
19:10:36 <shachaf> that's such a roundabout way of doing it. :-(
19:10:36 <benmachine> john_r_watson: this is basically lazy IO being confusing
19:10:49 <benmachine> you could use hGetLine, that is less confusing
19:10:59 <john_r_watson> benmachine: sounds like it - would that drop the last line/
19:11:20 <benmachine> john_r_watson: it gets one line at a time
19:11:30 <Jafet> hGetContents' = liftM Text.unpack . Text.hGetContents
19:11:57 <napping> uh, what about readFile if you just want to read the whole thing?
19:12:26 <Jafet> readFile f = hGetContents <$> openFile f
19:12:45 <Jafet>  ReadMode
19:12:55 <john_r_watson> Jafet: Doesn't it automagically close ?
19:13:11 <applicative_> john_r_watson: hGetContents is kind of like 'listen'
19:13:13 <monochrom> hGetContents does the auto closing. readFile too.
19:13:27 <Jafet> It does
19:14:04 <benmachine> Jafet: I think you want =<< not <$>
19:14:06 <applicative_> hGeth
19:14:54 <applicative_> hGetContents is kind of like, 'exposeToPossibleCalculation'
19:15:09 <napping> why are you looking at withFile?
19:15:09 <Jafet> Geth? Where!
19:16:01 <applicative_> hGetContents is awesome, excepting of course for its name
19:16:06 <napping> like, do you have some handle-based thing in mind?
19:16:54 <applicative_> how shall I compare lazy io to a summer's day?  it is more lovely and more temperate.
19:20:58 <applicative_> john_r_watson: try withFile "./words.txt" ReadMode (hGetContents  >=> print . length) or equivalent
19:21:51 <applicative_> instead of  (withFile "./words.txt" ReadMode hGetContents)  >>= print . length
19:31:46 <john_r_watson> applicative_: nice
19:31:58 <guymann> aw yea
19:34:22 <napping> that's a kind of strange way to do it, though
19:35:00 <napping> if you're doing lazy IO with readFile or something and don't force it promptly the worst case is you leak fds and eventually crash with an error about not being able to open more files
19:35:33 <rwbarton> which is a problem you have anyways if you are wrapping your whole program in a withFile
19:35:34 <john_r_watson> napping: fds = file descriptors / handles?
19:35:39 <napping> while if you try to use hGetContents inside of withFile and don't force enough (or don't always force enough, if there's some concurrency or something), the worst case is silently truncating input
19:36:44 <napping> yeah, file descriptors. I think every Handle wraps one, certainly at least the ones you get from opening files
19:38:08 * hackagebot lojysamban 0.0.4 - Prolog with lojban  http://hackage.haskell.org/package/lojysamban-0.0.4 (YoshikuniJujo)
19:42:37 <slack1256> When should i use lazy-bytestrings instead of strict-bytestrings with conduit?
19:42:44 <slack1256> is there is some case I am missing?
19:43:22 <johnw> is there a strict version of >>?
19:43:29 <startling> slack1256, when the bytestring is expected to be too big for your memory
19:43:58 <johnw> slack1256: also, when you want resident memory size to remain relatively cosntant
19:44:37 <napping> I think conduit is supposed to give all that too
19:45:01 <slack1256> napping: That what i thought.
19:47:02 <napping> I haven't learned how to use it, it looks more complicated to use, but I haven't heard that anything is wrong with it
19:47:24 <slack1256> the thing with streaming lazy-bytestring would be doing IO with it for the closing handlers problems.
19:48:24 <Cale> I would tend to use all those pipe/conduit/iteratee things only in anger, once I'd decided that I had no other reasonable option to obtain the performance I wanted.
19:50:31 <jkff_> Hi folks. It occured to me that there's a definition of >>= for Cont that typechecks, but is much simpler than the usual one. Is it correct? http://hpaste.org/74885
19:50:47 <jkff_> Probably not, because everyone would be using it then, but I do not see what exactly is wrong with it
19:51:03 <shachaf> jkff_: That's not Cont, is it?
19:51:14 <shachaf> Cont is parameterized on r.
19:51:21 <jkff_> shachaf: Well, it is a polymorphic Cont
19:51:26 <copumpkin> it's the double-negation monad!
19:51:41 <copumpkin> sort of, anyway
19:51:49 <rwbarton> it's the whatever-it's-called-these-days version of Identity
19:52:34 <jkff_> Hm, allright, is the second definition of >>= equivalent to the first?
19:52:55 <jkff_> I suspect they may have different strictness or something...
19:53:18 <rwbarton> they must be pretty close if they're both monad structures on Identity :)
19:53:55 <jkff_> rwbarton: Do you mean that this thing is not actually a useful Cont, but is simply isomorphic to Id?
19:54:04 <rwbarton> it is Identity yes
19:54:29 <jkff_> Ok :) But how is it conceptually different from the usual parameterized Cont monad?
19:54:39 <rwbarton> if I have f :: forall b. (a -> b) -> b, I can set b = a and apply f to id to get a value of type a
19:54:41 <shachaf> Your (>>=) is (forall r. (a -> r) -> r) -> (forall r. a -> (b -> r) -> r) -> (forall r. (b -> r) -> r)
19:54:59 <shachaf> So everything has to be completely polymorphic on the r.
19:55:42 <jkff_> That's interesting.
19:55:49 <monochrom> what does your callCC look like?
19:55:51 <jkff_> Indeed the code doesn't typecheck with Cont r
19:56:03 <jkff_> monochrom: it doesn't look like anything, so far I only wrote what I showed :)
19:56:35 <monochrom> sure, but without callCC, you don't see what breaks or what works
19:56:45 <jkff_> So, being overly polymorphic takes away its power.
19:56:52 <shachaf> jkff_: See Codensity m a = Codensity (forall r. (a -> m r) -> m r), though.
19:56:52 <rwbarton> and yeah there is some kind of operational difference between your Cont and newtype Identity a = Identity a
19:57:04 <jkff_> Ok, I'll try writing callcc.
19:57:15 <jkff_> shachaf: So this one is not equivalent to anything simpler?
19:57:18 <applicative_> it is akin to codensity, as shachaf says, but without an underlying monad to mess with
19:57:33 <shachaf> applicative_: Well, the underlying monad makes all the difference.
19:57:38 <applicative_> it's Codensity Identity
19:57:42 <shachaf> applicative_: Er, it's not necessarily a monad.
19:57:53 <shachaf> For example Codensity Const = Cont, more or less.
19:57:53 <rwbarton> if I let v = return x and runCont v id several times, x will be recomputed
19:58:09 * hackagebot fmark 0.1.0 - A Friendly Markup language without syntax.  http://hackage.haskell.org/package/fmark-0.1.0 (JoseLopes)
19:58:12 <jkff_> :t callCC
19:58:13 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
19:58:28 <applicative_> Codensity Endo
19:58:39 <shachaf> The thing about (forall r. (a -> r) -> r) is that if you have one, you can get the "a" trivially, just by passing "id".
19:58:51 <shachaf> Whereas if the "r" is fixed by someone else, you can only do limited things with it.
19:58:53 <monochrom> one way to see whether it is no more than Identity: Identity can't have callCC. so, if your thing has a working callCC, you know it's way more than Identity. if your thing doesn't have a working callCC, you know you haven't escaped Identity
19:58:54 <shachaf> (Or nothing, if r = ())
19:59:14 <jkff_> shachaf: Yes, that's why it seemed deceptively simple to write a comonad instance for it, at least the extract :)
19:59:15 <shachaf> So YourCont a ~ a
19:59:16 <rwbarton> as opposed to if I let v = return x in and runIdentity v several times, x will be shared
19:59:30 <applicative_> Codensity doesn't have callcc and it isnt trivial
19:59:45 <shachaf> jkff_: Right. But a (Cont r a) for some specific r is more restricted than an a. :-)
20:00:05 <jkff_> Yes, I see. Ok, I have to digest this and code something.
20:00:19 <monochrom> Codensity has something else to stand apart from Identity
20:04:12 <mdmkolbe> I'm getting an error similar to http://hpaste.org/69953 how do I fix it?
20:04:45 <shachaf> jkff_: A nice specific example is that you can write lem :: Cont r (Either (a -> Cont r Void) a)
20:04:52 <benmachine> oh geez, fmark is another friggin' markdown
20:04:57 <shachaf> Well, or callCC, which is equivalent.
20:05:03 <benmachine> because we didn't have enough lightweight pseudomarkup languages
20:05:04 * shachaf likes lem, though.
20:05:08 <jkff_> shachaf: What's lem?
20:05:12 <shachaf> Law of excluded middle.
20:05:18 <shachaf> (For r = Void)
20:05:21 <applicative_> mdmkolbe: is it trying to install the ghc package?
20:05:52 <jkff_> Oh
20:05:55 <mdmkolbe> applicative_: No I'm just trying to install hermit. I.e., "cabal install hermet" emits this error
20:05:56 <shachaf> jkff_: If you had first-class callcc :: ((a -> b) -> a) -> a, you could use it to write lem :: forall a. Either (a -> Void) a
20:06:00 <johnw> is there a way to get shelly to print lines "as they come in"?
20:06:21 <applicative_> mdmkolbe: what does e.g. ghc-pkg.exe check say? is anything broken?
20:06:47 <shachaf> Hmm, can you make Cont r (Either (a -> Void) a)?
20:06:50 <monochrom> if ghc-pkg does not report anything wrong, next look at "ghc -v"
20:07:01 <kallisti> johnw: getContents basically gives you an indefinite-length string containing all of the stdin
20:07:10 <johnw> that's not my question
20:07:25 <shachaf> Or Cont Void (Either (a -> Void) a), I guess.
20:07:29 <kallisti> johnw: lines <$> getContents   -- ????
20:07:34 <shachaf> @djinn Cont Void (Either (a -> Void) a)
20:07:34 <lambdabot> Error: Undefined type Cont
20:07:37 <monochrom> I expect ghc-pkg to detect nothing, and ghc -v to tell you the truth: a lot of "unusable" and "shadowed"
20:07:37 <johnw> my question relates to shelly
20:07:47 <shachaf> @djinn-let newtype Cont r a = Cont ((a -> r) -> r)
20:07:47 <lambdabot> Maybe you meant: djinn-del djinn-ver
20:07:52 <shachaf> @djinn-add newtype Cont r a = Cont ((a -> r) -> r)
20:07:52 <lambdabot> Cannot parse command
20:07:57 <shachaf> @djinn-add data Cont r a = Cont ((a -> r) -> r)
20:08:01 <shachaf> @djinn Cont Void (Either (a -> Void) a)
20:08:01 <lambdabot> f = Cont (\ a -> void (a (Left (\ b -> a (Right b)))))
20:08:09 <shachaf> @djinn Cont r (Either (a -> Void) a)
20:08:09 <lambdabot> -- f cannot be realized.
20:08:11 <shachaf> djinn++
20:08:45 <mdmkolbe> hmm, this might take a while.  (You guys have given me an idea.)
20:08:47 <shachaf> (Oops, did I just give away the exercise?)
20:08:49 <applicative_> mdmkolbe: what version of the ghc package does ghc-pkg list say you have?  what version of the ghc do you have, by the way?
20:08:58 * jkff_ copies the log to a text file for later digestion
20:09:33 <clahey_> Hi.
20:09:39 <applicative_> hi clahey_
20:09:46 <clahey_> Can you all help me with using IO in interesting ways?
20:10:11 <otters> maybe
20:10:12 <clahey_> I've written the script I want, but it does lots of things by hand that I think should be done with some sort of pattern.
20:10:14 <applicative_> 'it's all we ever do,' as James Dean says in the movie
20:10:16 <otters> depends on the interest level
20:10:24 <clahey_> Okay.  First question.
20:10:44 <johnw> ah, I had a misplaced "silently"
20:10:47 <jkff_> Note to self for later: explore comonadic control structures like the stuff from Control.Monad - liftM, sequence etc
20:10:51 <kallisti> johnw: well, you could do something like echo Data.Text.IO.getContents
20:11:05 <clahey_> I think I'll just ask using type signatures of the functions I want?
20:11:27 <kallisti> johnw: well, you could do something like echo . words =<< liftIO Data.Text.IO.getContents
20:11:46 <kallisti> that would be using shelly, technically
20:11:52 <clahey_> (a -> IO b) -> [a] -> IO b
20:11:57 <johnw> kallisti: I just needed to not use silently
20:11:57 <monochrom> applicative_: http://www.vex.net/~trebla/haskell/sicp.xhtml and search for "ghc-6.12.3 requires array ==0.3.0.2 however" for fun!
20:12:04 <kallisti> :t mapM
20:12:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:12:05 <johnw> shelly echoes to stdout as lines appear by default
20:12:10 <kallisti> clahey_: ^
20:12:13 <kallisti> well, no
20:12:14 <clahey_> I know  (a -> IO b) -> [a] -> [IO b] is just map
20:12:15 <kallisti> nevermind
20:12:17 <otters> :t sequence
20:12:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:12:29 <kallisti> I can't get you m b as the output
20:12:32 <kallisti> instead of m [b]
20:12:39 <applicative_> monochrom: ah yes the same error-type
20:12:46 <otters> :t foldl (>>)
20:12:47 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [m b] -> m b
20:12:51 <clahey_> kallisti Which is probably what I wanted anyway.
20:13:11 <clahey_> mapM.  Thank you.
20:13:19 <otters> figured
20:13:22 <shachaf> jkff_: Control.Comonad has a standard library like Control.Monad but I'm not sure whether the things in it correspond to control structures in the same way that the monad functions do.
20:13:23 <kallisti> clahey_: mapM f ls = sequence $ map f ls
20:13:31 <applicative_> monochrom: the next bit about missing or recursive dependencies is what his error made me afraid of
20:13:50 <shachaf> Since comonads don't really represent effects like monads do.
20:13:56 <monochrom> now see the text before it for how to cause it
20:14:13 <shachaf> On the other hand you can consider quite a lot of things in Haskell to be "control structures", including lists. :-)
20:14:29 <otters> :t mapM_
20:14:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:14:32 <shachaf> On the other other hand you shouldn't listen to me because I don't have a proper intuition for this.
20:14:40 <mdmkolbe> Ok, I just rebuilt my installed packages and now the problem seems to have gone away
20:15:28 <clahey_> :t mapM
20:15:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:17:15 <applicative_> mdmkolbe: monochrom's essay is worth a look in cases like this http://www.vex.net/~trebla/haskell/sicp.xhtml
20:18:44 <mdmkolbe> cool, I'll be sure to read it so I can avoid the same troubles next time
20:20:10 <clahey_> Thanks very much.
20:20:23 <kallisti> clahey_: no problem. also see forM.  forM = flip mapM
20:21:12 <clahey_> How about (a -> IO Maybe b) - > [a] -> Maybe b
20:21:20 <clahey_> Giving me the first non Nothing value?
20:21:33 <kallisti> that doesn't exist, however there is a MaybeT monad transformer, but it's usually not needede
20:22:01 <shachaf> clahey_: Do you mean (a -> IO (Maybe b)) -> [a] -> IO (Maybe b)?
20:22:11 <clahey_> Yes.
20:22:35 <shachaf> foo f xs = catMaybes <$> mapM f xs
20:22:39 <clahey_> Forgot the parentheses and forgot that it needed to return a Monad.
20:23:08 <clahey_> And that will stop running the IOs once it finds one?
20:23:18 <shachaf> Oh, wait.
20:23:29 <shachaf> Never mind, I wrote out the type but didn't read it. :-)
20:23:39 <shachaf> You won't be able to use mapM for that.
20:23:40 <rwbarton> you need to write your own custom loop for that
20:24:38 <clahey_> I actually did it with error.
20:24:53 <shachaf> foo f [] = return Nothing; foo f (x:xs) = do { v <- f x; case v of { Nothing -> foo xs; Just v' -> return v' } }
20:24:56 <shachaf> Something like that.
20:24:59 <shachaf> foo f xs
20:26:08 <Ralith> someone in here linked me an article on why the design of Go is dissapointing, but I've lost it
20:26:11 <Ralith> ring any bells?
20:27:01 <clahey_> Ah, I see how I actually did it.
20:27:52 <A1kmm> Is it a Parsec bug if code like "(many $ (try expr) <?> "some message not found anywhere else" )" fails expecting that string?
20:27:56 <clahey_> What I actually wanted was (a -> IO Bool) -> [a] -> IO a
20:28:10 * hackagebot fmark 0.1.1 - A Friendly Markup language without syntax.  http://hackage.haskell.org/package/fmark-0.1.1 (JoseLopes)
20:28:20 <shachaf> You mean (a -> IO Bool) -> [a] -> IO (Maybe a)?
20:28:54 <clahey_> That would have worked, but I implemented it as IO a which returns an error if it's not found.
20:29:02 <shachaf> You could do something evil with unsafeInterleaveIO and mapM to make it more compositional-ish.
20:29:06 <shachaf> But that's probably a bad idea.
20:29:10 <clahey_> And instead of making it take a list, I just had it iterate over all values from 0 to 256.
20:29:13 <A1kmm> Or rather: (many ((try expr) <?> "some message not found anywhere else" ))
20:30:39 <clahey_> I was sad that I had to implement myXor a b = B.pack (zipWith DB.xor (B.unpack a) (B.unpack b))
20:31:03 <rwbarton> there isn't a bytestring zipWith?
20:31:11 <clahey_> Probably.
20:31:31 <rwbarton> that will be some ridiculous factor faster
20:31:46 <ivanm> @hoogle (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString
20:31:46 <lambdabot> No results found
20:31:52 <shachaf> rwbarton: That still probably ends up being less efficient than an "unsafe" version.
20:32:00 <rwbarton> oh it doesn't produce a ByteString
20:32:01 <rwbarton> how odd
20:32:05 <shachaf> rwbarton: Oh, ByteString.zipWith returns [a]
20:32:08 <rwbarton> @hoogle (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
20:32:08 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
20:32:08 <lambdabot> Data.ByteString.Lazy zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
20:32:08 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
20:32:14 * shachaf can't keep up with anything these days.
20:32:20 <ivanm> because the function is generalised
20:32:43 <rwbarton> oh
20:32:49 <rwbarton> I think there is a rule if you pack the result of that
20:33:02 <shachaf> Aha.
20:33:24 <rwbarton> "ByteString specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q . zipWith f p q = unpack (zipWith' f p q)
20:33:55 <shachaf> Oh, there's a zipWith'
20:33:57 <shachaf> It's just not exported.
20:34:13 <clahey_> Which means that pack (zipWith...) will be fast.
20:34:16 <shachaf> RULEs make me vaguely nervous.
20:34:18 <clahey_> I like this language more and more.
20:34:21 <ivanm> shachaf: agreed
20:34:25 <ivanm> explicit > implicit
20:34:36 <rwbarton> i feel like i only know this rule exists because it wasn't working for someone here once
20:34:52 <shachaf> clahey_: Probably not as fast as a special-cased xor operation would be. :-(
20:35:12 * shachaf wonders how much B.pack (B.zipWith xor b1 b2) gets optimized.
20:38:07 <rwbarton> well when I compile with ghc -O2 I see some assembly that does two loads, an xor, a store, an increment, a test and a conditional jump
20:38:10 <rwbarton> that's not very impressive
20:38:43 <clahey_> Is it doing byte loads or word loads?
20:38:59 <rwbarton> byte
20:39:21 <rwbarton> with -fllvm it combined the second load with the xor which probably doesn't make any difference at all
20:40:00 <applicative_> clahey_: you could convert the bytestrings to unboxed vectors, let vecpack = V.unfoldr B.uncons , then use the zipWith of Data.Vector.Unboxed
20:40:16 <rwbarton> but at least the RULE apparently fired correctly
20:40:26 <clahey_> rwbarton, True.
20:40:45 <shachaf> rwbarton: It could be much worse. :-)
20:41:09 <clahey_> Next puzzle.
20:41:50 <rwbarton> I really wish the symbol names in the assembly bore some relation to the names of functions in the Haskell source
20:42:08 <shachaf> GHC-generated assembly is so weird.
20:42:18 <shachaf> When you're used to reading GCC-generated assembly, anyway.
20:43:02 <clahey_> (ByteString -> Maybe Word8) -> ByteString -> ByteString
20:43:11 <clahey_> That's not quite right.
20:43:22 <clahey_> (ByteString -> IO (Maybe Word8)) -> ByteString -> IO ByteString
20:43:25 <clahey_> That's what I actually need.
20:43:42 <shachaf> Sounds specialized enough that you'd need to write the loop yourself.
20:43:46 <clahey_> I figured.
20:43:49 <rwbarton> how is it a loop?
20:43:54 <shachaf> Maybe you can use a "builder" thing to make it nice.
20:44:06 <shachaf> rwbarton: I assume that's a mapMaybe-style thing.
20:44:09 <rwbarton> you have a ByteString and a function that takes a ByteString
20:44:11 <shachaf> Er, wait, that's not Word8 ->
20:44:26 * shachaf isn't reading types very well.
20:44:30 <clahey_> findBlock' target blockNum suffix | B.length suffix == blockSize = return suffix | otherwise = do byte <- findByte target blockNum suffix; findBlock' target blockNum (B.cons (fromIntegral byte) suffix)
20:44:40 <latro`a> wait, what exactly do you apply the ByteString function to?
20:44:46 <latro`a> not just the second argument, presumably
20:45:04 <clahey_> The idea is for it to prepend the Word8 to the ByteString and call the function again.
20:45:12 <shachaf> Oh, that's more specialized than I misread it as.
20:45:19 <latro`a> and then return it if you get Nothing?
20:45:24 <clahey_> Yep.
20:45:28 <latro`a> that seems simple then?
20:45:46 <clahey_> I posted my solution, but my goal is to learn to make things more haskelly.
20:46:27 <rwbarton> that seems to not really do exactly what you said
20:46:30 <clahey_> findBlock target blockNum = findBlock' target blockNum suffix
20:46:46 <rwbarton> oh I get it
20:47:41 <rwbarton> I wouldn't bother trying to improve on that
20:47:59 <clahey_> I am happy that I got findString target = mapM (findBlock target) [0..(B.length crypto) `div` 32 - 2]
20:48:45 <clahey_> Is there no takeM?
20:49:27 <rwbarton> oh wait
20:49:29 <clahey_> (I hope this is interesting to y'all.)
20:49:38 <rwbarton> are you doing the findByte action a known number of times?
20:49:39 <latro`a> where is your solution, clahey_ ?
20:49:55 <clahey_> latro`a, It's a homework, so I'd rather not post the whole thing.
20:49:59 <rwbarton> @type replicateM
20:50:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
20:50:02 <clahey_> I meant I posted my solution to that particular little bit.
20:50:09 <latro`a> yeah
20:50:13 <latro`a> but I haven't been following
20:50:18 <latro`a> so I didn't see it
20:50:20 <latro`a> can you paste it again?
20:50:29 <clahey_> findBlock' target blockNum suffix | B.length suffix == blockSize = return suffix | otherwise = do byte <- findByte target blockNum suffix; findBlock' target blockNum (B.cons (fromIntegral byte) suffix)
20:50:47 <clahey_> I figure the chance of anyone doing this homework in haskell is close to NULL.
20:51:01 <latro`a> that seems like a different type than you stated before
20:51:09 <clahey_> latro`a, It is a little different.
20:51:30 <clahey_> I tried to extract the end concept when describing the type.
20:51:44 <latro`a> k
20:52:04 <latro`a> wait, so that do block is in the IO monad?
20:52:10 <latro`a> if so, how does Maybe come into the picture
20:52:30 <clahey_> I suppose the actual type is (ByteString -> IO Word8) -> count -> ByteString -> ByteString
20:52:41 <latro`a> uh
20:52:42 <latro`a> what
20:52:43 <latro`a> that
20:52:43 <latro`a> what
20:52:52 <rwbarton> yes that is replicateM-like
20:52:59 <latro`a> even without any context that looks fishy
20:53:23 <latro`a> if you're doing IO in the middle and aren't doing unsafePerformIO, you get IO at the end
20:53:32 <clahey_> I suppose the actual type is (ByteString -> IO Word8) -> count -> ByteString -> IO ByteString
20:53:34 <clahey_> Thank you.
20:53:37 <clahey_> I keep forgetting that.
20:53:41 <clahey_> I'm new to haskell.
20:54:11 <clahey_> Although, the more you talk about it, unsafePerformIO might be the way to go.
20:54:30 <latro`a> I don't suggest it if you're new
20:54:34 <clahey_> The IO is querying a web server which gives the same response every time.
20:54:38 <latro`a> if only because its semantics are somewhat subtle
20:55:43 <clahey_> It seems like this is the exact situation in which it would be warranted, no?
20:56:13 <latro`a> a situation where you get the same response every time would be a situation for it, true
20:56:17 <rwbarton> if you are willing to assume that the server really gives the same response every time and the server never fails and your network never fails then possibly
20:56:21 <latro`a> but it shouldn't require it
20:56:22 <latro`a> and yeah
20:56:23 <latro`a> that
20:57:33 <latro`a> also, do you only sometimes get a Word8 or not
20:57:54 <latro`a> if you always do then this is indeed rather replicateM/mapM-y
20:57:58 <rwbarton> the Maybe is so that in the B.length suffix == blockSize case it can return Nothing, I think
20:58:06 <clahey_> rwbarton, Exactly.
20:58:25 <clahey_> That seemed like the way to do it, but I can see how mapping would work.
20:58:26 <latro`a> but it doesn't, it returns suffix
20:59:04 <shachaf> Hah, waitForJust :: forall a. STM (Maybe a) -> STM a
20:59:13 <latro`a> lol
21:00:54 <clahey_> latro`a, No, the idea was the called function could return Nothing so that the Unfolding function could know to return the ByteString at that point.
21:01:01 <clahey_> shachaf, Oh man, if that works.  :)
21:01:05 <latro`a> but where does it return Nothing
21:01:09 <latro`a> I don't see any use of Maybe in there
21:01:29 <shachaf> clahey_: This isn't relevant to your situation at all.
21:01:31 <clahey_> latro`a, Instead of using Maybe, the code I actually wrote just checked the length of the current ByteString.
21:01:34 <shachaf> I just saw it and liked it.
21:01:40 <latro`a> ah
21:02:07 <latro`a> well wait, so it fails only in the case when it isn't long enough?
21:02:09 <latro`a> or can the find operation fail?
21:02:18 <clahey_> latro`a, It fails when it is long enough.
21:02:28 <clahey_> So it starts with pack ""
21:02:30 <latro`a> ah, k, well same idea
21:02:47 <clahey_> I think I'll try writing it the way I was thinking of.
21:11:29 <clahey_> I haven't tested it yet, but here's what I came up with:   myIOUnfoldl f bs = do  r <- f bs;  case r of;    Nothing -> return bs;    Just x -> unfoldl f (B.cons fromIntegral (r) bs)
21:17:59 <clahey_> It should have been fromIntegral (x), but that worked.
21:18:37 <shachaf> It should probably be "fromIntegral x" instead.
21:18:46 <clahey_> (fromIntegral x)
21:18:55 <clahey_> Right.
21:19:19 <monochrom> save the parentheses for fromIntegral (g x) or fromIntegral (x+1) :)
21:19:43 <clahey_> monochrom,  B.cons (fromIntegral r) bs
21:20:03 <clahey_> It's really hard to get out of the habit of f(x) apparently.
21:24:53 <osa1> can anyone recommend me introductory resources on fixed-points, fixed-points of functors, least fixed points etc.
21:26:57 <clahey_> How much does writing things with tail recursion matter in haskell?
21:27:06 <clahey_> Does the compiler tend to find such possibilities anyway?
21:27:35 <dibblego> No.
21:27:37 <clahey_> Not that anything I'm doing is IO free...
21:27:49 <clahey_> I guess tail recursion would still matter though.
21:27:54 <shachaf> clahey_: The compiler won't do any optimizations like that, but tail calls matter in a very different way in lazy languages.
21:28:04 <clahey_> shachaf, Ah, right.
21:28:05 <shachaf> Often you specifically don't want things to be tail-recursive.
21:28:42 <clahey_> I think considering everything I'm doing here is IO, it acts more like a non lazy language.
21:29:11 <shachaf> If everything you're doing is IO, it's possible that you should reconsider what you're doing. :-)
21:29:43 <clahey_> I'm running an algorithm that queries a web server at its inner most loop.
21:30:11 <clahey_> It's for a crypto class.  The assignment is to break a piece of cryptography by using an intentional flaw in the web server.
21:30:46 <clahey_> I think unsafePerformIO at the core is probably actually the right way to go.
21:30:47 <shachaf> clahey_: You might want to turn your code inside out or something to make more of it pure.
21:31:00 <shachaf> unsafePerformIO for querying a web server doesn't sound right to me at all.
21:31:20 <clahey_> Unfortunately, the value of each query is dependent on the results of the previous one.
21:31:28 <otters> :t (>>=)
21:31:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:31:34 <otters> ^
21:32:01 <shachaf> clahey_: This is why function arguments were invented!
21:32:17 <clahey_> shachaf, How would I go about inverting it?
21:32:32 <shachaf> I don't know. Depends on your code.
21:32:49 <clahey_> Perhaps have a state variable and have the IO function return an updated state variable.
21:32:51 <dibblego> blimey mate
21:33:28 <clahey_> I hope I'm not being daft.
21:33:54 <dibblego> clahey_: the idea is to minimise the use of IO and certainly, you shouldn't be using unsafeAnything
21:34:05 <otters> it's unsafe
21:34:15 <jfischoff> shachaf: Two questions. In lazy languages it is guarded recursion that matters? If so, what is guarded recursion, and why does it matter?
21:34:17 <clahey_> dibblego, I agree.  And I'm trying to figure out how to do that.
21:34:27 <clahey_> But I think I'm starting to get it.
21:34:34 <shachaf> jfischoff: I was going to ask you your second question when I saw the first.
21:35:39 <jfischoff> oh wait I looked it an know I remember
21:36:14 <jfischoff> shachaf: from the haskell wiki "The important concept to know in Haskell is guarded recursion (see tail recursion modulo cons), where any recursive calls occur within a data constructor"
21:37:08 <jfischoff> I know tail recursion modulo cons is I think I just don't understand the lazy optimization that occurs
21:37:14 <shachaf> jfischoff: OK.
21:37:18 <shachaf> jfischoff: It's not really an optimization.
21:37:23 <jfischoff> go on
21:37:31 <shachaf> jfischoff: Let's take map as an example.
21:37:38 <jfischoff> awesome
21:37:48 <shachaf> In a strict language, when you evaluate "map f [1,2,3]", you get something like
21:38:02 <shachaf> map f (1:(2:(3:[])))
21:38:14 <jfischoff> yeah
21:38:15 <shachaf> f 1 : map f (2:(3:[]))
21:38:17 <shachaf> And so on.
21:38:29 <shachaf> Let's think of this strictly from the perspective of avoiding stack overflows.
21:38:44 <shachaf> If the list has a million elements, you're going to get a million stack frames from a million recursive calls to map. Right?
21:39:15 <jfischoff> yeah
21:39:29 <shachaf> On the other hand, in a lazy language, we make that one reduction, and then we stop.
21:39:41 <shachaf> We have thunk1 : thunk2, where thunk1 = f 1 and thunk2 = map f [2,3]
21:39:47 <shachaf> (Sorry, monochrom!)
21:40:08 <clahey_> findResult :: State -> ioresult -> (State, Maybe answer)       Then do     getResult' state = do ioresult <- doIO state; (state', result) <- findResult state ioresult; (case result of Nothing -> getResult' state'; Just finalResult -> return finalResult)
21:40:13 <shachaf> Now the person who's consuming this list can do other things, like evaluate thunk1 and print it, and then recurse.
21:40:35 <shachaf> At each level of the list, we only need to do a little bit of work and then we return immediately, so we never overflow the stack.
21:40:51 <clahey_> Then I have very little IO.  It's all in the top level function and in doIO.
21:41:01 <clahey_> Most of the processing is in findResult.
21:41:13 <shachaf> clahey_: That's the general idea, yep.
21:41:16 <shachaf> See? No IO needed. :-)
21:41:44 <shachaf> jfischoff: On the other hand, laziness gets you a different kind of stack overflow, if you're not careful.
21:42:14 <jfischoff> huh, that's interesting. I wasn't thinking that way.
21:42:38 <clahey_> Well, I've got my answer submitted for the homework.
21:42:46 <clahey_> Hopefully I'll rework it to not have an IO tomorrow.
21:43:09 <shachaf> jfischoff: If you think in terms of simple substitution -- not even laziness -- you see that "tail-call optimization" isn't really an "optimization" at all, just a thing that happens by default when you substitute.
21:43:20 <shachaf> f x = g x; g x = x + 5
21:43:37 <shachaf> f 8  ===>  g 8  ==>  8 + 5
21:43:44 <shachaf> (That's kind of a tangent.)
21:44:06 <shachaf> But it's just what happens naturally. You don't get a "call stack" in the C sense.
21:45:03 <jfischoff> I can be an optimization when you can take advantage of an associative property I think.
21:45:30 <jfischoff> that's what most of the fib examples are doing, (or is it communicative …)
21:45:37 <shachaf> ?
21:45:58 <clahey_> I love that you get automatic storage of old values in computing fib.
21:46:00 <clahey_> Is that true?
21:46:31 <otters> > let fibs@(t:fibs') = 1:t:zipWith (+) fibs fibs' in take 20 fibs
21:46:32 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
21:46:37 <otters> If you do it right
21:46:58 <shachaf> jfischoff: Oh, you're talking about that?
21:47:15 <clahey_> I think I'll change it to have three functions.  :t getNextIO == State -> IOInput       :t doIO == IOInput -> IO IOOutput       :t processOutput == State -> IOOutput -> (State, Maybe Result)
21:47:18 <jfischoff> so typical tail call means the last statement is returned. So you pass around the accumulator as an argument. However you add things in a different order with the tail call version.
21:47:33 <shachaf> jfischoff: Oh, we're talking about two different things.
21:47:46 <jfischoff> were we?
21:47:56 <shachaf> Well, I was. :-)
21:48:09 <shachaf> Yes, in the case that you're generating a small strict value, like an integer, you usually want tail recursion.
21:48:15 <jfischoff> haha, still I like thinking harder about lazy evaluation
21:48:29 <shachaf> Like fact 0 = 1; fact n = n * fact (n-1)
21:48:29 <jfischoff> right, but that is actually a pretty limited situation
21:49:01 <jfischoff> I don't think you can have the * there
21:49:04 <shachaf> That's better rewritten as fact n = fact' n 1; fact' 0 a = a; fact' n a = fact' (n-1) (a*n), or something
21:49:09 <jfischoff> yeah
21:49:21 <shachaf> Except that's still bad in Haskell.
21:49:41 <clahey_> fact n = product (1..n)
21:49:50 <clahey_> fact n = product [1..n]
21:49:52 <clahey_> I mean.
21:50:06 <jfischoff> shachaf: go on
21:50:26 <shachaf> @google foldr foldl foldl'
21:50:27 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
21:50:27 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
21:50:31 <shachaf> I think that page explains it.
21:50:36 <jfischoff> aye
21:50:54 <shachaf> It's possible that the strictness analyzer will make the fact I gave good, though.
21:51:01 <shachaf> You never know with bees.
21:51:05 <clahey_> Then process state = do let input = getNextIO state; output <- doIO input; state', (case realOutput of Nothing -> process state'; Just x -> return x; where (realOutput, state') = processOutput)
21:51:08 <clahey_> I love it.
21:51:56 <jfischoff> ha, yeah I don't know. My vote is that it would work if everything was unboxed, which is doable i think. Not sure about other cases
21:52:13 <jfischoff> I think GHC can unbox all of that
21:52:29 <shachaf> I suspect it'd figure that out. But who knows.
21:53:21 <jfischoff> yeah sounds like a job for HERMIT
21:53:40 <jfischoff> http://hackage.haskell.org/package/hermit
21:53:54 * shachaf isn't familiar.
21:54:06 <jfischoff> well anyway off to bed, see this week right?
21:54:19 <shachaf> Ah, on Wednesday. Yep.
21:54:28 <jfischoff> awesome ttyl
21:55:35 <johnw> has anyone else been successful using pipes in Shelly?
21:55:47 <johnw> I'm using -|-, but I keep getting "Broken pipe" from zfs send
21:55:48 <kallisti> I haven't, no.
21:55:58 <kallisti> (nor have I tried)
21:56:17 <shachaf> johnw: "has anyone else been successful" seems to imply that you've been successful. :-)
21:56:25 <johnw> oh, haha
21:56:31 <johnw> so you're editing my grammar now too, fantastic
21:56:40 <shachaf> Sorry. :-(
21:56:55 <johnw> sorry, was just joking that time
21:57:04 <clahey_> So, how do I update my state variable?  Specifically:
21:57:24 <clahey_> Say I have data State = State {a :: Int, b :: ByteString}
21:57:36 <clahey_> And I have a state {5, "a"}
21:57:44 <clahey_> I would like a state { 5 + 1, "" }
21:58:12 <ivanm> clahey_: is this in a State monad?
21:58:21 <johnw> (-|-) works just fine in simple examples, so I wonder what I'm doing wrong...
21:58:26 <clahey_> ivanm, I don't know.  I could make it be so.
21:58:39 <ivanm> clahey_: oh, you just wnat to know how to update record data structures?
21:58:52 <clahey_> ivanm, I'll look up State monads and let you know if I need anything else.
21:58:53 <clahey_> Yes.
21:59:07 <ivanm> updateState st = st { a = succ $ st a; b = "" }
21:59:19 <ivanm> though in this case since you're re-defining all fields you can use the constructor rather than st
21:59:25 <ivanm> lenses may also make this nicer for you
22:00:45 <johnw> shachaf: have you ever used Shelly?
22:01:10 <clahey_> ivanm, Except in actual fact, I'm not updating all of them.
22:01:26 <ivanm> clahey_: so you probably don't want to use the constructor then :)
22:03:15 <lightquake> does anybody else here use sublime text with haskell?
22:04:15 <NihilistDandy> lightquake: Been trying. SublimeREPL's a bit weak, though
22:04:22 <NihilistDandy> Or I can't figure out how to configure it to work nicely
22:04:55 <osa1> is there a way do download the source from hackage with cabal ? I want to look at harpy's source but seems like it's webpage is down
22:05:14 <NihilistDandy> I float between ST, macvim, and Emacs. I think I prefer the Emacs haskell-mode, generally speaking
22:05:27 <lightquake> yeah, haskell-mode is pretty nice. but i'm getting fed up with emacs in general
22:05:58 <NihilistDandy> Install Evil :D
22:06:27 <ivanm> osa1: cabal unpack
22:06:33 <lightquake> it's more the 'i have to use a very crufty lisp API to script it' thing
22:06:43 <ivanm> there's probably also "cabal fetch" or something as well...
22:07:40 <NihilistDandy> lightquake: Just use Emacs Prelude
22:07:49 <NihilistDandy> Lots of really nice defaults
22:08:20 <lightquake> well, like... if i want to customize stuff like syntax highlighting
22:08:25 <lightquake> i have to learn lisp. and i don't know lisp.
22:08:27 <lightquake> i know python!
22:08:41 <eyu> > 1 + 1
22:08:42 <lambdabot>   2
22:09:09 <NihilistDandy> Oh, then I suppose ST is right up your street. Though I've found scripting it to be more of a pain than Emacs
22:09:10 <Dodek> lightquake: lisp is like python, you just surround stuff with parentheses
22:09:20 <eyu> > fix (\x -> (1, x))
22:09:21 <lambdabot>   Occurs check: cannot construct the infinite type: a = (t, a)
22:09:46 <eyu> > fix (\(_, x) -> (1, x))
22:09:50 <lambdabot>   mueval-core: Time limit exceeded
22:16:35 <ion> dodek: And you have macros and lambdas
22:17:51 <tmiw> > map (\x -> x + 1) [1,2,3,4]
22:17:52 <lambdabot>   [2,3,4,5]
22:18:05 <Dodek> ion: yeah whatever -- people don't use macros that much in emacs lisp, and older emacs lisps had dynamic scoping, which rendered lambdas almost useless.
22:18:12 * hackagebot sizes 1.2.0 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-1.2.0 (JohnWiegley)
22:19:48 <tmiw> > map (\x -> Data.Char.chr $ (Data.Char.ord x + 13)) "hello world"
22:19:49 <lambdabot>   "uryy|-\132|\DELyq"
22:19:55 <tmiw> woot, rot13.
22:19:57 <tmiw> kinda
22:22:16 <mm_freak_> i can't compile lens 1.4.1
22:22:22 <mm_freak_> Could not find module `Control.Applicative.Backwards'
22:22:32 <ivanm> did edwardk forget a dep?
22:22:37 <ivanm> or a lower bound not tight enough?
22:22:37 <mm_freak_> apparently
22:22:54 <mm_freak_> well, you can't really forget a dependency, but you can get the version number wrong
22:23:03 <mm_freak_> s/number/range/
22:23:13 <ivanm> it's in transformers and in applicative-extras
22:23:18 <ivanm> so... go figure which one is wrong :p
22:24:42 <djahandarie> ddarius, how far have you gotten into that quantum field theory book pdf by Paugam which was posted on ncafe some time ago?
22:24:55 <ivanm> mm_freak_: if it's transformers, it needs >= 0.3
22:25:20 <ivanm> wait, applicative-extras isn't one of edwardk's! :o
22:56:09 <lightquake> so here's a really silly idea
22:56:23 <lightquake> take ghc-mod and make it into a daemon so that it doesn't have to reparse the source tree every time
22:56:36 <shachaf> johnw: Nope.
22:56:41 <lightquake> and come up with some protocol, so that ghc-mod listens on port whatever
22:56:49 <lightquake> and responds to requests
22:57:57 <shachaf> lightquake: I think emacs can do something similar with ghci for top-level :t requests and such.
22:59:03 <lightquake> it can, yes, but the point of this is to be editor-agnostic
22:59:30 <lightquake> alternately, make ghc-mod-daemon and have ghc-mod be a simple CLI that talks to the daemon
23:02:48 <enolan> is "reactive" - ie Conal's push-pull FRP library - still actively maintained?
23:03:18 <enolan> It won't build on my system. Appears category-extras has been split into a bunch of smaller packages...
23:04:57 <kallisti> lightquake: that's possible with ghc api
23:05:07 <kallisti> for interpreting
23:05:10 <kallisti> I believe
23:05:13 <lightquake> right
23:05:38 <lightquake> basically i want to split ghc-mod into a frontend and a backend
23:05:47 <kallisti> right
23:10:38 <pharaun> ipc?
23:13:09 <syntaxfree> I had a couple of flame wars re: oo x fp, and went to bed, but got a kind of epiphany.
23:13:46 <syntaxfree> the type constructor syntax that allows for inline destructors. you know what I'm talking about.
23:14:24 <syntaxfree> you can have functions as a parameter to a long type. this is effectively OO, except for inheritance.
23:16:06 <pythonguy> hello
23:16:26 <pythonguy> anybody home?
23:16:50 <m3ga> pythonguy: what's up?
23:17:26 <pythonguy> I wanted to ask somebody if Haskell would be a decent language for simulating human cognition
23:17:50 <pythonguy> could you shed any light on that?
23:18:11 <m3ga> how are you planning on modelling human congnition?\
23:18:27 <cark> that language has not been invented yet =)
23:18:54 <pythonguy> @ cark - yes I'm aware that it's not FULLY there yet
23:19:00 <syntaxfree> you're probably better off with a multi-agent approach.
23:19:18 <syntaxfree> literally. lots of embedded devices interacting with a physical environment and fine-tuned neural networks.
23:19:27 <pythonguy> I've read through Artificial Intelligence: A Modern Approach but I find it seriously lacking
23:19:53 <pythonguy> have you considered GPGPU for that type of thing?
23:20:17 <pythonguy> fine-tuned neural networks taking lots of different inputs
23:20:27 <merijn> pythonguy: "not FULLY there yet" might be the understatement of the century, if not all of human existence...
23:20:29 <m3ga> pythonguy: i think thats a sign that "it's not FULLY there yet" should be "its nowhere near there yet"
23:21:20 <merijn> Just simulating a neural network on GPGPU is not going to get you anywhere close
23:22:05 <pythonguy> right. not looking to use human brain models per se, just looking to characterize the situational awareness of a person
23:22:31 <syntaxfree> it's well possible that the first general-purpose AI will be a distributed spambot.
23:22:40 <syntaxfree> deus ex internet.
23:22:48 <merijn> pythonguy: Then you probably want to look into autonomous robot stuff
23:23:10 <merijn> pythonguy: Lots of research into situational awareness in that area
23:23:18 <syntaxfree> you may want to look at the stuff about coherent volitional frameworks.
23:23:32 <syntaxfree> yudkowsky and pals'  research.
23:23:52 <syntaxfree> don't skip the "friendly AI" stuff, it's more important than it sounds.
23:23:57 <pythonguy> at the singularity institute
23:24:00 <pythonguy> ?
23:24:19 <syntaxfree> i.e. it's not Terminator paranoia, it's an integral part of how you understand what a general AI looks like.
23:24:23 <syntaxfree> yep.
23:24:41 * syntaxfree is a regular donor to SIAI and Humanity+ (formerly WTA)
23:24:47 <pythonguy> thanks, I'll look into it. but my original question - would haskell be a decent language to learn in this vein
23:24:51 <NemesisD> any of you guys use hspec?
23:25:18 <syntaxfree> it's way more likely than not that you don't really-really know what you want to do.
23:25:51 <pythonguy> I don't think consciousness "really-really" knows what it wants to do.
23:26:04 <m3ga> pythonguy: haskell is an exception language for tackling difficult problems as long as you are doing device drivers or other low level speed critical stuff.
23:26:15 <m3ga> s/exception/exceptional/
23:27:07 <cark> m3ga: didn't you forget a "not" too ?
23:27:25 <pythonguy> I am part of a university, with an advanced machine vision/robotics lab, and I've heard all of the blithe criticisms against general AI
23:27:36 <m3ga> yes. i'm jet lagged :-(.
23:27:37 <pythonguy> but if somebody isn't working on it, it'll never happen and the criticisms will continue to be valid
23:28:20 <cark> pythonguy: i think we need way more parallelism, and maybe a different architecture to tackle such problems
23:28:49 <clahey_> Should  a (b c d) = (a . b) c d
23:28:52 <clahey_> And if not, why not?
23:28:58 <cark> the brain is a massivelly parallel computer, with very dumb processors, and data on each processor rather than appart
23:28:58 <syntaxfree> erlang does almost transparent concurrency.
23:29:05 <centrinia> :t a (b c d)
23:29:06 <lambdabot>     Couldn't match expected type `Expr -> Expr -> t'
23:29:06 <lambdabot>            against inferred type `Expr'
23:29:06 <lambdabot>     In the first argument of `a', namely `(b c d)'
23:29:16 <syntaxfree> but i really think you want multiple physical lightweight microprocessors.
23:29:27 <centrinia> :t \a b c d -> (a (b c d), (a.b) c d)
23:29:28 <lambdabot>     Occurs check: cannot construct the infinite type: a = t -> a
23:29:29 <lambdabot>     Probable cause: `b' is applied to too few arguments
23:29:29 <lambdabot>     In the second argument of `(.)', namely `b'
23:29:32 <centrinia> :t \a b c d -> (a (b c d), (a . b) c d)
23:29:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = t -> a
23:29:33 <lambdabot>     Probable cause: `b' is applied to too few arguments
23:29:33 <lambdabot>     In the second argument of `(.)', namely `b'
23:29:36 <cark> syntaxfree: it does, but the underlying architecture is still a few processors connected to memory via a single, slow bus
23:29:37 <syntaxfree> i.e. dozens of arduinos interacting with a physical environment and cross-calibrating neural nets.
23:29:51 <merijn> > a (b c d) :: Expr
23:29:52 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
23:29:52 <lambdabot>                           ...
23:29:56 <merijn> hmm
23:30:04 <syntaxfree> of course, that will mean C++, but each processor's task would be simple.
23:30:25 <clahey_> centrinia, Yeah, I keep getting a result like that, but I don't understand why.
23:30:52 <clahey_> Oh, now I do.  Just thought about it right.
23:30:57 <merijn> clahey_: No, they're not the same. The first brackets "a ((b c) d)", whereas the second becomes "(a (b c)) d"
23:31:20 <clahey_> merijn, Right.
23:31:25 <shachaf> a (b c d) = a ((b c) d) = (a . (b c)) d = (a . b c) d
23:31:26 <clahey_> I could do a . b c $ d
23:31:40 <centrinia> clahey_, it means that the types are not the same.
23:31:42 <clahey_> But that's not what I want.
23:31:55 <pythonguy> syntaxfree: it's an interesting idea to use many small processors, but scaling that up to the level of a brain would be insane. I read an article recently of a group at Stanford that simulated a single celled organism, and it took 20 computers 10 hours to do a single cell division
23:31:55 <shachaf> @pl \b c d -> a (b c d)
23:31:55 <lambdabot> ((a .) .)
23:31:59 <centrinia> If they are the same then you will not have a type error.
23:32:00 <shachaf> @pl \c d -> a (b c d)
23:32:00 <lambdabot> (a .) . b
23:32:05 <clahey_> centrinia, Yes, but I know that the types weren't the same, but that wasn't the question.
23:32:18 <clahey_> centrinia, I didn't understand why the types weren't the same, but now I do.
23:32:20 <syntaxfree> you are not going to scale to the level of a brain. you're going to emulate lizard intelligence, maybe mouse.
23:32:48 <syntaxfree> and you're not going to simulate biology. you're going to use machine learning stuff.
23:33:10 <clahey_> @pl \d -> a (b c d)
23:33:10 <lambdabot> a . b c
23:33:14 <pythonguy> okay. it seems like a lot of the metaphors we use to talk about this stuff get misinterpretted. i see what you mean
23:33:19 <clahey_> @pl \c d -> a (b c d)
23:33:19 <lambdabot> (a .) . b
23:33:22 <cark> syntaxfree: right, gotta make do with what hardware we got
23:33:26 <clahey_> So I want (a .) . b
23:33:34 <clahey_> If it takes two parameters.
23:33:36 <syntaxfree> arduinos are dirt cheap.
23:33:44 <clahey_> @pl \c d e -> a (b c d e)
23:33:44 <lambdabot> ((a .) .) . b
23:34:49 <clahey_> Yeah, that's less readable I think.
23:39:21 <meiji11> if I've defined an instance of Foldable local to the file I'm working in, how do I hide the Prelude foldr to prevent a conflict? I want the locally defined fold to occur in the call.
23:39:57 <kallisti> meiji11: you could explicitly qualify it with your module name, or you could add import Prelude hiding (foldr)
23:40:35 <kallisti> an explicit import of Prelude overrides the implicit one.
23:40:53 <meiji11> heh, foldr is used normally in a few other places, though. incidentally, can you wrap only part of a file in a module, and import that in the rest of the file as you normally would? I'm guessing not.
23:44:06 <kallisti> meiji11: yeah sometimes it's good to have a common import for everything in the library.
23:44:17 <kallisti> to control names
23:44:54 <kallisti> for example Yesod comes with an Import module that makes (<>) work on several versions of GHC.
23:45:30 <meiji11> right. I'm hesitant to split the file, but only to avoid another problem that comes up. a type constructor refuses to export.
23:45:45 <meiji11> this is a lousy way around the problem, obviously..
23:45:56 <kallisti> do you have an explicit export list?
23:46:04 <kallisti> did you export the type constructor?
23:46:20 <meiji11> it does. it's actually the source for data.priorityqueues.fingertree on hackage.
23:46:36 <meiji11> it exports PQueue, but it's a no show when I import that module.
23:46:43 <kallisti> oh, awesome module.
23:46:46 <meiji11> the module does export PQueue.
23:46:52 <kallisti> I'll have to remember that one.
23:47:04 <kallisti> which type constructor?
23:47:06 <meiji11> and I have installed with cabal, heh.
23:47:08 <meiji11> PQueue.
23:47:14 <meiji11> installed it *
23:48:06 <kallisti> looks like that's exported in the latest version?
23:48:13 <kallisti> the type constructor is exported, but not the data constructor.
23:48:33 <kallisti> module Data.PriorityQueue.FingerTree ( PQueue,
23:48:47 <kallisti> as opposed to PQueue(..)
23:50:14 <meiji11> erm, what's the difference, if you don't mind my asking?
23:51:57 <meiji11> oh, I think I see..
23:52:02 <meiji11> yes, that seems obvious now.
23:52:07 <meiji11> the type constructor constructs a type variable..
23:52:11 <meiji11> the data constructor, data. duh.
23:52:51 <kallisti> meiji11: yep, and now there are kind constructors with the DataKinds type extension.
23:53:14 * hackagebot lojysamban 0.0.5 - Prolog with lojban  http://hackage.haskell.org/package/lojysamban-0.0.5 (YoshikuniJujo)
23:53:17 <kallisti> string literals, numbers.
23:53:23 <meiji11> since "PQueue" denotes both the type and data constructor, how does ghc decide which gets exported?
23:53:43 <kallisti> the syntax is always TypeConstructor(Data1, Data2, Data3)
23:53:52 <kallisti> or TypeConstructor(..)
23:53:57 <meiji11> kallisti: heh, nuts.
23:53:58 <kallisti> which exports all constructors
23:54:16 <kallisti> hidden constuctors are pretty useful
23:54:56 <meiji11> well, crap. that deflates what I was trying to do.
23:55:13 <meiji11> I wanted to pattern match on PQueue.
23:55:21 <kallisti> btw you could easily do OO programming with hidden method constructors
23:55:39 <meiji11> instances of typeclasses are analogous to objects?
23:56:01 <kallisti> meiji11: interfaces, or type relationships in the case of multiple parameters
23:56:09 <shachaf> meiji11: Not really.
23:56:21 <shachaf> You'd be best off not trying to make analogies between type classes and OO.
23:56:25 <shachaf> They're different things.
23:56:34 <meiji11> that's what I thought.
23:56:49 <meiji11> I'm not seeing the OO connection, I guess.
23:56:50 <kallisti> > read "2" :: Word16
23:56:51 <lambdabot>   2
23:57:05 <shachaf> Wait, kallisti is the one who brought up OO? :-(
23:57:10 <kallisti> yes.
23:57:15 <kallisti> I apologize for the foul language.
23:57:25 <meiji11> haha..
23:57:52 <shachaf> I don't mind OO, but when someone is learning Haskell it probably doesn't help to talk about it. :-)
23:58:43 <kallisti> you can do several different kinds of inheritance-like structures with type constructors, phantom types, and GADTs
23:58:51 <mm_freak_> i'd like to interject, i do mind OO =)
23:59:19 <mm_freak_> in any case, a 'data' is more like a class in C++/java-style OO
23:59:42 <kallisti> that is fairly accurate.
