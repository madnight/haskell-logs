00:00:02 <cmccann> Cale, the other thing is that pipes uses a sum type at each layer, which abandons the linear behavior you get from e.g. an automaton arrow, but makes writing nonlinear stream processors much nicer
00:00:07 <ew0> that's what's happening
00:00:12 <ew0> my python code was taking 2 days
00:00:15 <ew0> to run
00:00:19 <pharaun> >_<
00:00:24 <mm_freak_> Polarina: you can also switch to netwire 4, which is a lot nicer interface-wise:  hold (periodically 1 . avgFps 10)
00:00:24 <Cale> ram_: It also makes programs hard to understand. You can no longer run any part of the program in isolation, because there are mutable things which it depends on. Testing becomes hard.
00:00:30 <ew0> the haskell version is taking 9 minutes
00:00:42 <pharaun> ew0: sweet :)
00:00:48 <ew0> xD
00:01:16 <pharaun> ew0: i've had to do that before with python but it was python -> multi-processing -> cython -> C & OpenMP
00:01:24 <Cale> ram_: Testing turns into doing a bunch of operations to set up the state of the world just so, possibly caching some of their values in order to compare afterward, then executing the thing you mean to test, and then looking around at what has changed.
00:01:49 <Cale> ram_: and even then, your procedure may have changed things which it wasn't meant to touch and your test might miss this
00:02:09 <Cale> ram_: It makes programming hard, and it makes debugging hard.
00:02:25 <Cale> ram_: So we're collectively looking for better ways to do things in Haskell land.
00:02:48 <Lemon> you know
00:03:03 <Cale> ram_: The first of which is just to do as much as possible independently of state.
00:03:04 <Lemon> we really ought to avoid triggering the courtier's reply
00:03:22 <ew0> ehe, if it were no for haskell I would have written it in C++, boost is not all bad, it is just that I really love functional programming
00:03:22 <Cale> Lemon: ?
00:03:25 <Lemon> it makes us sound more like cultists than enlightened ones
00:03:38 <ew0> my python code is more or less functional
00:03:43 <Cale> Lemon: I don't understand what you mean.
00:03:46 <pharaun> ew0: i have hard time sometime with that in python
00:04:03 <Lemon> Cale, as in "you'll love Haskell if you just learn it first"
00:04:05 <pharaun> ew0: i'm trying to make my python code more functional over time but the pre-existing code is *so* state-bound that its sad :\
00:04:16 <Cale> Lemon: Oh, that wasn't my response.
00:04:27 <ew0> yeah, I have a ton of preexisting code too
00:04:35 <Lemon> Cale, it wasn't directed specifically at you
00:04:44 <cmccann> that wasn't my response, either. I said that if you learn Haskell, you'll hate every other language.
00:04:46 <Cale> ram_: are you still here?
00:04:50 <Lemon> it was just a general thing I've noticed in the Haskell community
00:04:53 <cmccann> loving Haskell is another matter entirely.
00:05:01 <Lemon> and the Go community, too
00:05:03 <pharaun> hehe
00:05:27 <ew0> cmccann: lol
00:05:43 <Lemon> "our language doesn't suck! You just have to learn it before you can say it sucks!"
00:06:11 * cmccann does not love any languages. there are languages he considers utter garbage, and languages that are still on probation.
00:06:47 <ew0> ehe, hey, at least haskell's comunity is larger than <+->.,[]
00:06:54 <ew0> if you know what I mean
00:07:06 * cmccann should learn APL one of these days
00:07:13 <Lemon> I don't know what you mean
00:07:36 <otters> brainfuck
00:07:37 <Cale> Well, at least in Haskell's case, there are a litany of cool features and things from research which have gone into Haskell which can be used to defend the idea that it's something interesting to look into. In Go's case, you have an incredibly boring language with essentially nothing really new in it. Shouldn't be hard to pick up, but it also probably won't teach you much (unless you programmed only in C your whole lif
00:07:38 <Cale> e and had never done anything with concurrency)
00:07:43 <ew0> yeah
00:07:44 <ew0> xD
00:08:27 <Lemon> in either case, the answer to "why language X" shouldn't be "just learn it", but rather "because reasons A, B, and C"
00:08:34 <Cale> I agree.
00:08:38 * cmccann still thinks that with STM concurrency is essentially a solved problem for most everyday sort of problems
00:08:49 <ew0> I tried to learn haskell once ~3 years ago
00:08:51 * pharaun agrees with cmccann for most part
00:08:57 <ew0> my C++ programming skills skyrocketed
00:09:00 <pharaun> its pretty sweet :)
00:09:04 <Cale> The reason I responded the way I did was because I thought there was a better answer than cmccann gave in that case.
00:09:15 <dolio> I like the Go vs. Algol 68 comparison.
00:09:32 * cmccann is not as patient as Cale
00:09:40 <ddarius> cmccann: APL is utter garbage.  Fun garbage, but not something you'd want to write applications in.
00:09:44 <ew0> hey, wich package I must install to get Text.Regex working?
00:09:58 <cmccann> ddarius, people write applications in it?
00:10:02 * cmccann had no idea
00:10:05 <pharaun> yup
00:10:06 <ddarius> cmccann: I don't think so.
00:10:10 <cmccann> heh
00:10:21 <pharaun> ddarius: one way applications you mean? :)
00:10:24 <ddarius> cmccann: Most presumably use J, but I think it's pretty rare to write whole applications is J either.
00:10:34 <cmccann> I will admit that my primary motivation for learning APL would be to be able to say I know APL
00:10:43 <cmccann> and see the expression on people's faces when I show them APL code
00:10:50 <Lemon> I see there was a split
00:11:02 <pharaun> does anyone have any good example of quickcheck testing suite?
00:11:03 <Cale> ew0: minimally regex-base, and one other thing to provide a backend, like regex-pcre or regex-posix
00:11:17 <pharaun> i'm trying to learn quickcheck and some of the stuff is proving to be a little tricky
00:11:22 <Cale> http://hackage.haskell.org/package/regex-pderiv-0.1.2 -- omg, someone implemented this?
00:12:02 <Cale> lol, I've read Antimirov's papers, because there was this guy who used to bother me constantly to help him understand them
00:16:16 <ew0> ow yeah, you need regex-compat
00:16:20 <ew0> for regexes to work
00:16:54 <Cale> oh!
00:17:00 <Cale> oh sorry, right
00:17:09 <Cale> I never actually use those packages
00:17:17 <Cale> They're kinda crazy :P
00:18:00 <Cale> and everything that regexes do would be better served by a parser combinator library, unless the entire goal is to let users put in their own regular expressions.
00:18:05 <ddarius> s/crazy/retarded/
00:19:29 <Cale> Someone should write a decent regex library which we could also proceed to never use, just to save all the beginners from dealing with that one, except then some of them might actually use regexes for things.
00:19:44 <cmccann> heh
00:21:21 <Jafet> They can always use C++, where there is a parser combinator library using regular expressions
00:21:57 <pharaun> heh
00:22:17 <pharaun> i've found that since i've discovered a parsing combinator library my needs for regex has dropped to basically nil
00:29:22 <ew0> sanitize s = subRegex (mkRegex "\\W") s "_"
00:29:28 <ew0> this was my use for the regex
00:29:57 <ew0> can it be done with less work?
00:30:30 <Cale> Is that just  intercalate "_" . words?
00:32:06 <ew0> no
00:32:15 <ew0> it replaces anything that is not a word with a _
00:32:20 <ram_> Cale: Yes, I do not see the problem with local mutation
00:32:56 <pharaun> ram_: have you ever had to debug multi-threaded program with wanton mutation of state?
00:33:14 * cmccann thinks anyone who sees no problem with local mutation has never actually done any programming
00:33:17 <Cale> ram_: The more you can localise it, the less bad it is, I'll agree.
00:33:57 <Cale> But it's still making life hard in the local context where it exists.
00:34:23 <ew0> ok, I managed to get my graphs, now I need a bigass screen
00:34:32 <cmccann> then again agreeing that global mutation is bad doesn't seem to stop people from writing programs that way, so who knows
00:34:34 <ew0> xD
00:37:01 <Cale> ew0: ah, right, in that case, I would have done something like  map (\x -> if isAlpha x || isDigit x then x else '_')
00:37:24 <ram_> Cale: so? it still doesn't seem right to be using Haskell to work around that, making unreadable code instead. imo
00:37:42 <Cale> ram_: Sorry, what code is unreadable?
00:38:03 <Cale> ram_: Haskell code is obviously unreadable if you don't know Haskell.
00:38:17 <Cale> But then, I wouldn't expect to be able to read Korean without learning it.
00:38:49 <ram_> Cale: poor workarounds like State s a or IORef
00:39:16 <Cale> ram_: Well, okay, what is it that you're trying to do?
00:39:37 <Cale> (apart from "use local state to do something")
00:40:31 <Cale> On the light end of the scale, there are lots of ways to make uses of state monads and IORefs a lot more pleasant.
00:40:59 <ion> “State s a” isn’t a workaround for mutable state, it’s what you use to make the pure state value implicit when you’ve already decided you want pure state.
00:41:08 <Cale> yes
00:41:24 <Cale> You should definitely understand how to write imperative algorithms with plain functions.
00:41:39 <Cale> Using function parameters in place of mutable variables.
00:41:44 <pharaun> and it helps people who are new to your code understand that XYZ is stateful while abc isn't, etc...
00:42:05 <slack1256> when something is throw out from the ghc-tree (extensible-exceptions in 7.6) that means that now lives just in hackage right?
00:42:15 <Cale> slack1256: yes
00:42:21 <pharaun> anyone in here familiar with quickcheck? I'm trying to "Gen Int64" that are strictly positive, any suggestion?
00:42:30 <Cale> slack1256: and presumably the Haskell Platform
00:42:32 <ram_> Cale: I want to have state that can change.
00:42:33 <ivanm> pharaun: there's a Positive newtype wrapper I think
00:42:35 <ion> pharaun: Doesn’t QuickCheck come with a “Positive”?
00:42:40 <lightquake> wait, extensible-exceptions got thrown out?
00:42:43 <ivanm> @hoogle Positive
00:42:43 <lambdabot> Test.QuickCheck.Modifiers Positive :: a -> Positive a
00:42:43 <lambdabot> Test.QuickCheck Positive :: a -> Positive a
00:42:43 <lambdabot> Test.QuickCheck.Modifiers newtype Positive a
00:42:46 <Cale> ram_: to accomplish what task though?
00:42:47 <pharaun> yeah i've been working with Positive, but it keeps on failing with type
00:42:52 <ivanm> lightquake: it was just re-exporting Control.Exception
00:42:58 <lightquake> oh, the extensible-exceptions package. ok.
00:42:59 <ivanm> pharaun: you need "Positive Int64"
00:43:24 <ion> λ> quickCheck (\(Positive n) -> (n :: Int64) > 0)
00:43:26 <ion> +++ OK, passed 100 tests.
00:43:27 <slack1256> lightquake: sorry for not expressing me correctly.
00:43:34 <pharaun> ion: so -         fileSize <- Positive arbitrary :: Gen Int64 would not work?
00:43:41 <pharaun> i need it to construct a type
00:43:49 <Cale> Positive fileSize <- arbitrary
00:44:14 <Cale> ram_: and that's your only goal?
00:44:31 <pharaun> doh
00:44:38 <pharaun> Cale: thanks :)
00:44:44 * hackagebot dates 0.2.0.1 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.2.0.1 (IlyaPortnov)
00:44:44 <pharaun> ivanm: ion thanks too :)
00:44:49 <Cale> ram_: If you have some imperative algorithm, I can help you translate it into a pure one.
00:44:52 <ivanm> np
00:45:01 <Cale> (so long as it's not too big, I eventually have to sleep)
00:45:10 <ram_> Cale: I do. State s a is slightly prettier than f :: s -> (a, s) but still.
00:45:14 <cmccann> Cale sleeps? :O
00:45:30 <Cale> ram_: What makes it un-pretty?
00:45:32 <ivanm> cmccann: now we know!
00:45:39 <ram_>  Truthfully I do not really understand this monadic stuff well enough to understand it effectively, nor do I think you should have to in order to use it.
00:45:39 * cmccann boggles
00:45:41 <Cale> ram_: Are you explicitly using get and put everywhere?
00:45:44 <ion> How to get #haskell to do free work for you: claim Haskell sucks because it can’t do what you want it to do.
00:45:53 <ram_> It is not the most straightforward thing.
00:46:07 <ram_> Cale:  runState, get, put
00:46:09 <Cale> ram_: If you wrap up your uses of get and put by operations which act more meaningfully on your state, it will look more pleasant.
00:46:15 * cmccann thinks ram_ probably hasn't actually tried to understand anything
00:46:35 <ivanm> I usually use modify a lot more than put
00:46:49 <ivanm> and get when I'm being lazy and not using ReaderT over StateT
00:46:50 <ram_> Cale: could I get an example?
00:46:57 <ram_> cmccann: What's with the personal attacks?
00:47:18 <Cale> Sure, I'll give the really tiny example that I give everyone after explaining the implementation of the state monad.
00:47:22 <dbushenko> hi all!
00:47:31 <fmap> I used to use modify but then I discovered lenses
00:47:32 * ivanm waves idly in dbushenko's general direction
00:47:36 <Cale> actually, come to #haskell-overflow, because I want to write code
00:47:42 <Cale> and it's a bit noisy for that
00:47:58 <ivanm> SSSSHHHHHH EVERYONE! Cale wants to write code and we're disturbing him!
00:47:58 <ivanm> :p
00:48:13 <Cale> Well, I also don't want to get in everyone else's way :)
00:48:28 <Cale> fmap: also a very good point
00:48:33 <shachaf> ivanm: Cale is going to write code regardless of what we do.
00:48:41 <shachaf> ivanm: It's for our own sake.
00:48:45 <ivanm> shachaf: heh
00:48:53 <shachaf> You really think a little conversation would get in Cale's way?
00:48:56 <dbushenko> I have a function  f n, and want in one definition use a guard and function body definition. Is that possible?
00:49:16 <ion> dbushenko: yes
00:49:28 <dbushenko> ion: can you give a short example?
00:49:35 <cmccann> ram_, why do you THINK? seriously, I don't buy for a second that you're asking questions in good faith here.
00:49:37 <cmccann> but whatever.
00:49:41 <dbushenko> or am I supposed to use "otherwise" ?
00:49:49 <ew0> I'm so proud of myself
00:49:53 <ion> dbushenko: It’s difficult to say more without more information about your “f”.
00:49:57 <ew0> check my piece of code: 60      do foldM_ doBackEdge g (backEdges g) 61         putStrLn $ show u
00:50:11 <ew0> 60 and 61 are the line numbers, lol
00:50:11 <ion> putStrLn (show u)
00:50:12 <dbushenko> ion: nothing special. like f n = 10/n
00:50:19 <dbushenko> and I want a guard that n > 0
00:50:19 <ivanm> ew0: I hate to tell you this, but unless you're abusing Num I don't think those line numbers are meant to be there :p
00:50:23 <ivanm> dammit, you already said that
00:50:28 <ion> f n | n > 0 = 10/n
00:50:45 <ew0> xD
00:50:48 <dbushenko> :-D
00:51:04 <dbushenko> ion: thanks :-D
00:51:09 * killy9999 reads release notes for GHC 7.6
00:51:20 <killy9999> What does it means: "The following libraries have been removed from the GHC tree: mtl"
00:51:27 <ew0> I actually looked for a function that would work as a fold in a monad =D
00:51:28 <killy9999> mtl has been droped?
00:51:33 <ivanm> killy9999: it no longer ships with GHC
00:51:36 <ew0> erm, fold of monadic operations
00:51:37 <ion> dbushenko: Remember to compile with -Wall (and preferably -Werror as well) so you won’t forget to handle the remaining cases.
00:51:37 <killy9999> ok
00:51:40 <fmap> @pl \g -> foldM_ doBackEdge g (backEdges g)
00:51:40 <lambdabot> ap (foldM_ doBackEdge) backEdges
00:51:41 <ivanm> which means it's a lot easier to get it yourself from Hackage
00:51:46 <ivanm> as you're not tied to any one version
00:51:56 <killy9999> great
00:52:11 <dbushenko> ion: I'm using the ghci. Is there any option to make it loading files with that options?
00:52:24 <ivanm> dbushenko: :set -Wall
00:52:29 <ivanm> you can also add that to ~/.ghci
00:52:31 <dbushenko> thanks!
00:52:36 <ivanm> or per-project .ghci files
00:52:42 <ew0> ok, 5 am
00:52:44 <ew0> time to sleep
00:52:45 <ew0> gn
00:56:21 <atriq> Is it possible to search for instances using Hayoo?
00:57:19 <ivanm> atriq: unless the instances are orphans, search for the class or the type you're interested in
00:57:22 <ivanm> I think that's about it
00:57:41 <atriq> I'm just curious how many instances of Category there are
00:57:45 <ddarius> @instances Category
00:57:45 <lambdabot> Couldn't find class `Category'. Try @instances-importing
00:58:33 <atriq> I can think of five
00:58:36 <ivanm> @instances-importing Control.Category
00:58:36 <lambdabot> Couldn't find class `Control.Category'. Try @instances-importing
00:58:42 <ivanm> @instances-importing Control.Category Category
00:58:42 <lambdabot> (->), Kleisli m
00:58:49 <atriq> Two from base, one from comonad, two from data-lens
00:58:50 <ivanm> then you add all the pipe ones
00:59:42 <edwardk> atriq: check 'categories' also there are a bunch in my semigroupoids packages
01:02:08 <atriq> Hmm
01:02:27 <atriq> Semi seems interesting-ish, and now I've got Gangnam Style stuck in my head
01:06:32 <killy9999> I just noticed that GHC that I installed from my distribution repositories has "haskell2010" and "haskell98" libraries hidden
01:06:35 <killy9999> any ide why?
01:06:40 <killy9999> s/ide/idea
01:06:51 <atriq> Because it uses base and array instead
01:06:59 <atriq> Which is a good thing
01:07:03 <atriq> (tm)
01:07:08 <ivanm> by default, yes
01:07:21 <ivanm> the haskell* libraries are there for when you require standardisation
01:07:28 <killy9999> so there's no reason why it should be exposed?
01:07:38 <ivanm> not unless you need them, no
01:09:26 <killy9999> and what is the relation between these libs and "default-language: Haskell2010" entry in .cabal files?
01:09:38 <killy9999> I mean do I need to expose these libs to be able to use it?
01:10:12 <dcoutts> killy9999: no, that's the language you're using (distinct from libs)
01:10:54 <killy9999> dcoutts: yeah, I know that I define libs in different sections of .cabal file
01:11:07 <killy9999> but it seemed to me that these two are connected
01:11:32 <killy9999> I mean it would be logical (?) to require haskell2010 lib in order to use Haskell2010 as default haskell version
01:12:49 <dcoutts> killy9999: yep you can see why people might guess that, but it's not the case
01:44:27 <AndChat720225> Moin
02:09:48 <Hail_Spacecake> how do I write a function that will fire off a few IO actions with an interval of 1 second between them
02:09:52 <Hail_Spacecake> without blocking?
02:10:29 <Hail_Spacecake> like, I basically want to call a function that will, without blocking, write "hello" over a socket, pause for a second, write "world", pause for a second, etc.
02:11:00 <ivanm> Hail_Spacecake: there's sleep/delay functions...
02:11:16 <notdan> If I want to generate sequences of random numbers and then use them somehow in parallel, should I use Concurreny or Parallel?
02:11:19 <shachaf> Hail_Spacecake: What's with the not-blocking thing?
02:11:28 <shachaf> "pause for a second" seems like very blocking behavior to me.
02:11:40 <Hail_Spacecake> well I don't want the whole program to be doing absolutely nothing during that second
02:11:48 <notdan> I want to implement a simple monte carlo algorithm, but I am not sure whether I need to use forkIO (since I use getStdGen et al) or just par would be sufficient
02:11:50 <shachaf> Well, no, it'd just block the thread.
02:12:02 <Hail_Spacecake> so maybe I'm misunderstanding how haskell threads work
02:12:17 <shachaf> Probably.
02:12:31 <Hail_Spacecake> I'm not explicitly using any kind of threading-related code in my program
02:12:36 <Hail_Spacecake> so I would asume it runs as a single thread
02:12:37 <ivanm> notdan: concurrency == "do lots of independent things at the same time"; parallelism == "split the job up into sub-components that all run at the same time"
02:12:49 <shachaf> Hail_Spacecake: Well, you'd fork off a thread for this. :-)
02:12:54 <srhb> Hail_Spacecake: You would probably want to forkIO for those things. :)
02:13:03 <shachaf> forkIO (do { write handle "hello"; threadDelay 1000000; write handle "world" threadDelay 1000000; ... })
02:13:36 <Hail_Spacecake> ah
02:14:55 <shachaf> With an extra ;
02:16:32 <shachaf> See also the FAQ.
02:16:33 <shachaf> @where faq
02:16:34 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
02:20:41 <neothemachine> Hi guys, I just started doing some stuff in quickcheck and wonder if I can express a generator more shortly for a specific case, please see my paste
02:20:44 <hpaste> neothemachine pasted “QuickCheck and modifiers (NonNegative)” at http://hpaste.org/75166
02:21:27 <ddarius> Hail_Spacecake: A threaded API uses blocking and forking.  Non-blocking operations are accomplished by executing blocking operations in separate threads.  Event-based APIs use non-blocking calls and callbacks/event handlers.  Blocking calls are accomplished through CPS-like transformation.
02:21:59 <Sculptor> good morning. today i will continue with my haskell quest
02:22:17 <ivanm> neothemachine: liftM getNonNegative arbitrary
02:22:22 <ivanm> I think that will do it
02:22:38 <ivanm> good luck Sculptor!
02:22:49 <Sculptor> hvala
02:23:10 <ivanm> @type getNonNegative <$> arbitrary
02:23:11 <lambdabot> forall a. (Num a, Ord a, Arbitrary a) => Gen a
02:23:17 <ivanm> neothemachine: ^^
02:23:34 <neothemachine> ivanm: hmm what do I have to import for those to functions?
02:23:37 <ivanm> @type getNonNegative <$> (arbitrary :: Gen (Maybe Int)
02:23:38 <lambdabot> parse error (possibly incorrect indentation)
02:23:55 <ivanm> neothemachine: getNonNegative is defined as part of NonNegative
02:24:09 <ivanm> liftM is the same as fmap
02:24:20 <ivanm> (but you need to import it from Control.Monad)
02:28:19 <neothemachine> hm it seems I don't have quickcheck 2.5, at least in quickcheck 2.4 there's no accessor for NonNegative
02:28:31 <neothemachine> eh.... how do I check which version I got? ^^
02:28:46 <ivanm> ghc-pkg list QuickCheck
02:28:52 <ivanm> and yeah, it seems to be new :/
02:29:07 <neothemachine> indeed, 2.4.2
02:29:14 <neothemachine> time to update
02:29:19 <ivanm> you could always define it yourself if you're stuck with 2.4 (call it something different though so it will still work with 2.5)
02:29:54 <neothemachine> what is the liftM magic doing by the way?
02:30:09 <ivanm> ooohhh, the liftM stuff is wrong anyway: you'll need two levels
02:30:22 <ivanm> so, arbitrary (in this case) is :: Gen (NonNegative Int)
02:30:36 <shachaf> ddarius: It's funny that all IO code in Haskell uses a CPS-like transformation, but the threading implementationd is in the RTS anyway.
02:30:41 <ivanm> sorry, :: Gen (Maybe (NonNegative Int))
02:30:46 <ivanm> we use liftM/fmap once to lift the function inside the Gen Monad
02:30:57 <ivanm> then we want another liftM/fmap to get it inside the Maybe
02:31:03 <ivanm> @type fmap (fmap getNonNegative)
02:31:05 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (f (NonNegative a)) -> f1 (f a)
02:31:10 <dmwit> I think you're confused.
02:31:12 <ivanm> @type fmap (fmap getNonNegative) arbitrary
02:31:13 <lambdabot> forall a (f :: * -> *). (Functor f, Arbitrary (f (NonNegative a))) => Gen (f a)
02:31:28 <dmwit> You want liftM (Just . getNonNegative) arbitrary, or perhaps liftM (return . getNonNegative) arbitrary
02:31:48 <ivanm> dmwit: why?
02:32:01 <dmwit> Because you don't want to give arbitrary the option of generating Nothing.
02:32:09 <ivanm> oh, because of Maybe having different probabilities by default?
02:32:32 <dmwit> Just stare at the "Arbitrary (f (NonNegative a))" constraint in that type lambdabot just gave you and I'm sure the light bulb will go off. =)
02:32:35 <ivanm> dmwit: one of his options _is_ to return Nothing
02:32:53 <dmwit> Oh, you want to replace the whole shebang?
02:32:53 <dmwit> okay
02:32:58 <ivanm> @type fmap (fmap getNonNegative) (arbitrary :: Gen (Maybe (NonNegative Int))
02:32:59 <lambdabot> parse error (possibly incorrect indentation)
02:33:06 <ivanm> @type fmap (fmap getNonNegative) (arbitrary :: Gen (Maybe (NonNegative Int)))
02:33:07 <lambdabot> Gen (Maybe Int)
02:33:08 <dmwit> In that case I retract my complaint.
02:33:14 <ivanm> oh good :)
02:34:02 <dmwit> :t traverse
02:34:03 <lambdabot> Not in scope: `traverse'
02:34:09 <dmwit> :t Data.Foldable.traverse
02:34:10 <lambdabot> Not in scope: `Data.Foldable.traverse'
02:34:14 <ivanm> @hoogle traverse
02:34:14 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:34:14 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
02:34:14 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
02:34:16 <isomorphic> @type fmap
02:34:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:34:31 <notdan> @hoolge a -> Float
02:34:32 <lambdabot> Prelude id :: a -> a
02:34:32 <lambdabot> Data.Function id :: a -> a
02:34:32 <lambdabot> GHC.Exts breakpoint :: a -> a
02:34:35 <notdan> hm
02:34:52 <notdan> I am sorry for a noob question, but is it possible to convert int to a float?
02:34:59 <ivanm> notdan: fromIntegral
02:34:59 <dmwit> :t fromIntegral
02:35:00 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:35:03 <notdan> Thanks
02:35:08 <dmwit> ?hoogle Int -> Float
02:35:09 <lambdabot> Prelude (!!) :: [a] -> Int -> a
02:35:09 <lambdabot> Data.List (!!) :: [a] -> Int -> a
02:35:09 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
02:35:12 <ivanm> RWH has a table of how to convert from one type to another
02:35:17 <dmwit> Those results aren't helpful, either. =P
02:35:17 <ivanm> dmwit: heh, nice hoogle results :p
02:35:55 <dmwit> The online Hoogle gives toEnum as a third result, which would probably work okay in this case.
02:36:20 <dmwit> Though it still doesn't give any useful results for notdan's first query. =P
02:37:32 <ivanm> weird
02:39:17 <neothemachine> well thanks ivanm, seems to work!
02:39:25 <ivanm> np
02:42:02 <Hail_Spacecake> so, forkIo returns an IO threadId
02:42:18 <Hail_Spacecake> and I'm not sure how to use this in a function that expects an IO () argument
02:42:31 <ivanm> fmap (const ())
02:42:32 <shachaf> Argument?
02:42:34 <Palmik> Hi guys. I'm looking a for nice way to define a key for multidimensional map (map where element can be stored under multiple keys of different types) -- an example of such maps are IxSet and HiggsSet currently on Hackage. This a more detailed description of the problem: http://hpaste.org/75165, this one proposed (but flawed) solution: http://hpaste.org/75144 (these are the more obvious flaws: http://hpaste.org/75164)
02:42:37 <ivanm> @hoogle void
02:42:37 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
02:42:37 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
02:42:37 <lambdabot> package void
02:42:42 <shachaf> Why are you trying to pass (forkIO foo) as an argument?
02:43:18 <Hail_Spacecake> shachaf I have a dispatcher that uses separately-defined functions that return IO ()
02:43:56 <dmwit> Hail_Spacecake: The thread ID that forkIO returns is for sending killer messages to the thread you kicked off.
02:44:17 <dmwit> If you want to communicate in more... benign... ways, you need to set up the communication channels yourself.
02:44:28 <dmwit> Using, e.g., MVar's or Chan's or whatever you want.
02:44:39 <Hail_Spacecake> do I need to communicate iwth the thread?
02:44:49 <Hail_Spacecake> all it's doing is writing to a socket and pausing between writes
02:44:51 <ivanm> but if your threads auto-kill themselves, then you don't really need the ThreadID
02:44:52 <dmwit> Probably. But only you can really answer that question.
02:44:59 <shachaf> dmwit++ # answering a question right before it's asked
02:45:45 <shachaf> Hail_Spacecake: You might look into Control.Concurrent.Spawn or Control.Concurrent.Async
02:45:59 <Hail_Spacecake> well I just got it to compile
02:46:02 <shachaf> Well, that's not so much for communicating *with* the thread.
02:46:06 <dmwit> I mean, the name "dispatcher" definitely suggests communication to me.
02:47:02 <Hail_Spacecake> http://codepad.org/WKdmLmny <- this is my code, the function I was trying to write is synchro down at the bottom
02:47:09 <Hail_Spacecake> so that is a solution that compiles but it does look ugly
02:48:04 <dmwit> Line 58 looks a bit weird.
02:48:11 <dmwit> Why bother delaying a thread right before it dies?
02:48:28 <Hail_Spacecake> ah I guess there's no reason to do that
02:48:41 <Hail_Spacecake> the actual use case I'm writing this for needs like 3 or 4 more delays and writes
02:48:43 <dmwit> :t 1e6
02:48:44 <lambdabot> forall t. (Fractional t) => t
02:48:49 <dmwit> > 1e6 :: Int
02:48:50 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
02:48:50 <lambdabot>    arising from the lit...
02:48:52 <dmwit> bummer
02:50:15 <ivanm> > 10^6 :: Int
02:50:16 <lambdabot>   1000000
02:50:19 <ivanm> :)
02:50:57 <dmwit> > 1.2*10^6 :: Int -- :(
02:50:58 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
02:50:59 <lambdabot>    arising from the lit...
02:51:39 <shachaf> > 1.2e6 :: Int -- :—(
02:51:40 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
02:51:40 <lambdabot>    arising from the lit...
02:51:50 <dmwit> I'd be pretty psyched if GHC's rules were relaxed a bit so that any literal that happened to have a denominator of 1 was still Integral-polymorphic.
02:52:10 <shachaf> dmwit: That wouldn't work with 1.2*10^6
02:52:12 <dmwit> errr, Num-polymorphic, I guess
02:52:14 <dmwit> shachaf: Sure it would.
02:52:21 <dmwit> shachaf: Oh.
02:52:23 <shachaf> 1.2's denominator isn't 1?
02:52:28 <dmwit> But it would work with 1.2e6, is the point.
02:52:31 <shachaf> Sure.
02:52:38 <dmwit> Which is what I wanted in the first place.
02:53:27 <shachaf> I wish there was a one-page HTML version of the report.
02:53:31 <notdan> Can you guys help me with my small piece of code: http://bpaste.net/show/SNh9MnA9rHJ5TjUkNyQ9/ I don't understand why it's so slow :S
02:54:44 <hiptobecubic> notdan, System.Random is pretty slow. There are other generators which are more performant like mwc
02:55:10 <dmwit> notdan: ...you're not doing anything in parallel.
02:55:12 <shachaf> dmwit: That should be a GHC extension that extends to arbitrary expressions which can be verified to reduce to an integral value at compile time.
02:55:16 <dmwit> Well, you're not doing anything worthwhile in parallel.
02:55:25 <ivanm> notdan: you shouldn't call getStdGen more than once
02:55:30 * hiptobecubic wonders why mwc is not the default backend
02:55:38 <ivanm> hiptobecubic: it's newer?
02:55:40 <shachaf> Then you could do (symbolicIntegrate 0 1 foo) and it would have type Integral a => a
02:55:46 <shachaf> You could call it -XIntegralIntegrals
02:55:49 <ivanm> also, does it have a good Random instance? IIRC it isn't splittable
02:55:59 <hiptobecubic> ah it's not?
02:56:02 <hiptobecubic> then forget it
02:56:27 <dmwit> notdan: There's actually quite a lot of gotchas evident in this code. =)
02:57:35 <ivanm> I'm not really liking that take followed by splitAt; better IMHO to call splitAt twice on the infinite stream
02:57:41 <dmwit> repeatedly calling getStdGen, using sum, evaluating IO actions in parallel, using Float instead of Double, and arguably using StdGen at all (though I'm not as convinced about this one)
02:58:14 <ivanm> dmwit: what's wrong with sum? just that there are better ways to calculate an average?
02:58:20 <k0ral> Hello
02:58:27 <ivanm> I don't think it's StdGen per-se (though mwc would be faster, not sure how much)
02:58:29 <dmwit> ivanm: sum uses foldl instead of foldl' =)
02:58:33 <ivanm> ahhhh
02:58:48 <ivanm> oh, it's not an average, you know what you're dividing by
02:58:50 <hiptobecubic> ivanm, it's *significantly* faster
02:59:23 <k0ral> is it normal/known that glib doesn't compile with GHC 7.6 ?
02:59:45 <ivanm> k0ral: the gtk2hs libs usually need a new release for new ghc releases
03:00:10 <k0ral> ivanm: ok
03:00:26 <dmwit> It is known.
03:00:26 <ivanm> what was the error message though? it might be something easily fixed
03:00:46 <dmwit> It is not easily fixed, as far as I can tell (though I've only spent about 15-20 minutes on it so far.)
03:01:01 <notdan> dmwit: why am I not doing anything in parallel? I use parMap?
03:01:10 <notdan> (sorry for late reply, had a minor power outage)
03:01:11 <k0ral> System/Glib/GObject.chs:130:1: Unacceptable result type in foreign declaration: IO (FunPtr (Ptr () -> IO ()))
03:01:23 <dmwit> The error is misleading, anyway.
03:01:45 <dmwit> That's an acceptable result type, but GHC is giving the wrong error message for what the problem actually is.
03:02:15 <k0ral> there's also xdg-basedir which is broken since ghc 7.6
03:11:33 <notdan> dmwit: what can I use instead of sum? foldl?
03:12:59 <Cale> http://www.msr-inria.inria.fr/events-news/feit-thompson-proved-in-coq -- wow :)
03:13:37 <dmwit> ?src sum
03:13:37 <lambdabot> sum = foldl (+) 0
03:13:45 <dmwit> notdan: use sum' = foldl' (+) 0
03:14:01 <notdan> ?src sum'
03:14:01 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:14:13 <Maxdamantus> > sum [1..]
03:14:14 <lambdabot>  Terminated
03:14:15 <Cale> notdan: he just defined it :)
03:14:20 <notdan> Ok, but it doesn't actually make things faster, does it/
03:14:27 <Cale> notdan: Maybe a little
03:14:30 <dmwit> Cale: Wow, 170,000 lines of Coq is no small undertaking.
03:14:31 <notdan> Cale: yeah I was just checking whether it is predefined
03:14:40 <Maxdamantus> > sum [1..] where sum = foldl' (+) 0
03:14:41 <lambdabot>   <no location info>: parse error on input `where'
03:15:06 <dmwit> Maxdamantus: That's an infinite loop no matter which fold you use. =)
03:15:36 <Cale> notdan: You appear to be computing which action calculatePi 50000 is a bunch of times in parallel, and then running them all sequentially
03:15:41 <shachaf> dmwit: Not for lazy nats!
03:15:49 <Maxdamantus> Doesn't one of them .. yeah.
03:15:50 <shachaf> (And foldr.)
03:16:05 <dmwit> shachaf: Still an infinite list, because we're implicitly calling show. =)
03:16:12 <dmwit> err... infinite loop, I mean
03:16:16 <notdan> Cale: yeah I've already updated my code
03:16:26 <shachaf> dmwit: data Nat = Z | S Nat deriving Show
03:16:33 <dmwit> Oh, fine.
03:16:35 <notdan> http://bpaste.net/show/ULRlfpEQPwLPqwBsDnPV/
03:16:41 <shachaf> Pedantry saves the day!
03:17:12 <shachaf> I like the solution to http://hackage.haskell.org/trac/ghc/ticket/2245
03:17:28 <Maxdamantus> Meh .. doesn't one of them potentially use unnecessary amounts of memory?
03:17:40 <Maxdamantus> (with Integers)
03:17:45 <Cale> notdan: is there a reason you're doing the exact same computation 10 times in parallel?
03:17:47 <shachaf> There was an issue where Fractional literals were being pretty-printed as Doubles, so they made a special case *just* for Fractional literals to save the original String.
03:18:02 <shachaf> Note that "0100" isn't a Fractional literal, so it'll be pretty-printed as "100".
03:18:12 * shachaf :-(
03:18:17 <notdan> Cale: I am doing it with different random numbers tho?
03:18:32 <Cale> notdan: nope, you're passing in the same generator state
03:18:41 <Cale> notdan: so it'll compute the exact same results
03:18:58 <Maxdamantus> Prelude> sum [1..]
03:18:59 <Maxdamantus> ^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^CKilled
03:19:03 <notdan> Hm, ok, that's stupid. I'll have to use split?
03:19:04 <Maxdamantus> :\
03:19:53 <Cale> notdan: yeah, or you could just map mkStdGen over a list of random integers
03:19:58 <Cale> :t mkStdGen
03:19:59 <lambdabot> Int -> StdGen
03:20:03 <Maxdamantus> I think the definition of sum was changed in GHC 7.3 or something to fix that.
03:20:22 * Maxdamantus should update.
03:20:23 * shachaf gets the feeling, reading GHC code, that it was written before "deriving" was invented.
03:20:29 <ivanm> Maxdamantus: there's generalisedSum or something that works for any Num
03:20:33 <ivanm> and it's a foldr if memory serves
03:20:41 <dmwit> Maxdamantus: Not according to http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sum
03:20:47 <ivanm> so you can use it with lazy natural numbers to check if it's > x or something
03:20:48 <dmwit> no strictness annotations there at all
03:21:12 <ivanm> dmwit: strictness annotations wouldn't help with sum [1..] anyway...
03:21:15 <Cale> notdan: I'm not sure whether that's statistically a good thing to do, but it's probably about as safe as splitting a bunch. Apparently nobody really understands anything about split-like operations on pseudorandom generators.
03:21:24 <shachaf> You can't change sum's strictness in general without changing semantics.
03:21:37 <shachaf> But GHC's strictness analyzer detects some specific cases.
03:22:16 <Maxdamantus> Mm .. maybe not.
03:23:04 <ivanm> is foldl' part of the standard?
03:23:21 <notdan> ivanm: I changed splitAt n $ take .. to splitAt n $ fst $splitAt (2*n) (infnumbers) and it doesn't seem to work :|
03:23:27 <notdan> runs out of stack space
03:23:35 <shachaf> ivanm: Yes.
03:23:56 <shachaf> (2010, anyway.)
03:23:59 <dmwit> notdan: Why not just splitAt n (infnumbers)?
03:24:17 <ivanm> notdan: (f,rs') = splitAt n rs; s = take n rs'
03:24:23 <dmwit> no
03:24:26 <dmwit> let zip take care of that
03:24:31 <ivanm> dmwit: oh, right
03:24:33 <ivanm> duh
03:25:10 <notdan> dmwit: ah, you are right!
03:26:06 <notdan> Hm, altho it still runs out of stack space
03:27:30 <carpi> can someone please tell me how to call Data.ByteString.singleton? i tried singleton 'a' .. no luck
03:28:10 <carpi> my bad... seems like it needs a number
03:28:18 <notdan> Cale: hm, I've read a couple of mailing list postings and it seems that I have to sacrifice something at some point.
03:28:27 <Cale> randomPairs n gen = take n . map (\(x:y:xs) -> (x,y)) . iterate (drop 2) . randomRs (0,1) $ gen
03:28:41 <notdan> In an imperative language I'd just use a shared state where I'd put a random number generator
03:31:25 <Cale> oh, why are you using ** rather than ^?
03:31:59 <notdan> No idea
03:32:07 <notdan> because I am a newbie :S
03:32:09 <notdan> thanks Cale
03:33:40 <fmap> carpi: that's because bytestring shouldn't be used as a list of characters
03:33:46 <notdan> Actually, it works faster with **, Cale
03:34:06 <Cale> what...
03:34:11 <Cale> That is crazy
03:34:20 <Cale> ** is taking a logarithm
03:34:25 <Cale> ^ is doing a multiplication
03:34:47 * hackagebot VKHS 0.2.0 - Provides access to Vkontakte social network  http://hackage.haskell.org/package/VKHS-0.2.0 (SergeyMironov)
03:34:49 * hackagebot RefSerialize 0.3.0.1 - Write to and read from ByteStrings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.3.0.1 (AlbertoCorona)
03:34:53 <Cale> (a logarithm and an exponential)
03:35:15 <Cale> notdan: btw, you are compiling with -O2?
03:35:16 <Saizan> a
03:35:37 <notdan> Cale: no, I am compiling with -threaded --make
03:35:42 <Cale> Add -O2
03:35:52 <carpi> fmap: yes. I realized it takes numbers from 0..255
03:36:44 <notdan> Cale: woah, the ** version is 2x faster with -O2, the ^ version... not so fast
03:37:00 <Cale> I am really surprised by that
03:37:10 <Cale> what if you put x*x + y*y
03:37:10 <notdan> ~ 1.9s for the ^ version with -N2 and 0.5 s for the ** version
03:37:27 <luite> ** uses exp and log, not recursion
03:37:51 <notdan> a little bit faster than **, Cale
03:37:58 <notdan> practically the same
03:39:17 <notdan> Actually, my bad, I was running it on 4 cores, on 2 cores it's even faster
03:39:21 <notdan> around 0.3s
03:39:25 <luite> hm where is the code?
03:39:32 <notdan> still 0.1s slower than the python version
03:39:34 <notdan> luite: 1sec
03:39:53 <notdan> http://bpaste.net/show/qZ1iNThvYVXCbJJg22KP/
03:40:05 <notdan> And I haven't encorporated the splitting yet :|
03:42:45 <notdan> https://gist.github.com/raw/3769228/ede15efe9c15c83da136b40d16291b2dc7001128/pi.py the python version is faster (and in fact, correct)
03:43:38 <Cale> There's also the problem that StdGen is a fairly slow PRNG implementation if you're really getting picky about things.
03:48:07 <carpi> why do we have a 2 different versions of Data.ByteString? one lazy and the other non-lazy?
03:48:57 <JuanDaugherty> because lazy is sometimes TeH phail?
03:49:24 <JuanDaugherty> and locking into it a larger scale failure
03:49:42 <carpi> TeH phail?
03:50:10 <Cale> carpi: Lazy ByteStrings are built up as chunks of strict ones.
03:50:57 <Cale> carpi: Strict bytestrings lack some of the overhead of lazy bytestrings, but have worse asymptotic complexity for some operations.
03:52:15 <carpi> you mean like evaluating or allocating space for lazy bytestrings are defered until absolutely necessary?
03:52:19 <luite> notdan: hm, i still don't know why ^ is slower, but i'm guessing it's because it's not inlined becasue it's recursive, but i do know that reading the -O2 optimized stg and cmm code for that snipped gave me a headache :p
03:52:20 <dcoutts> Cale: btw, it's only 1 word overhead (in the best case)
03:52:39 <luite> snippet
03:52:47 <Cale> dcoutts: that's pretty good in terms of memory :)
03:53:07 <Cale> dcoutts: But there's also an extra indirection of course
03:53:11 <dcoutts> oh, sorry, it's actually 2 words
03:53:22 <dcoutts> 1 is what it would be if I change the rep
03:53:38 <shachaf> There's the extra indirection and other extra code.
03:53:42 <luite> 1 word? it must be more, since the ForeignPtr itself is malloc allocated, isn't it? so there's some malloc bookkeeping as well
03:53:53 <dcoutts> Cale: that's not intrinsic either, with constructor specialisation
03:53:57 <luite> or doesn't it use ForeignPtr?
03:54:09 <dcoutts> luite: I'm comparing strict and lazy bytestring
03:54:48 * hackagebot TCache 0.10.0.4 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.4 (AlbertoCorona)
03:54:51 <luite> oh, a 1-chunk string, right
03:55:09 <dcoutts> Cale: with algorithms on a strict bytestring you can often get down to a single indirection because the bytestring is unpacked into individual args
03:55:26 <dcoutts> Cale: and the same is true with a lazy bytestring, with constructor specialisation
03:55:35 <dcoutts> so no extra indirection
03:56:11 <dcoutts> if we don't get constructor specialisation then yes there's an extra indirection
03:56:36 * dcoutts is planning on changing lazy bytestring to use a single constructor rather than two to avoid this problem
03:58:33 <hpaste> Athas pasted “Type-level literals versus self-defined natural numbers” at http://hpaste.org/75170
03:58:59 <Athas> Oops, apparently it contains my entire ghci session.  Ignore everything but the last error.
03:59:26 <Cale> notdan: did you try my randomPairs?
04:02:27 <notdan> Cale: yes, I am using your version, in fact
04:02:37 <Cale> okay good
04:02:57 <notdan> Right now I am looking into mwc-random, but I don't see a way to use a generator in order to purely get random values
04:03:14 <Cale> http://hackage.haskell.org/packages/archive/mersenne-random-pure64/0.2.0.3/doc/html/System-Random-Mersenne-Pure64.html#t:PureMT
04:03:17 <Cale> is easier to use
04:03:35 <Cale> but doesn't seem to affect performance *that* much here
04:04:20 <Cale> You just use newPureMT instead of getStdGen/newStdGen and import import System.Random.Mersenne.Pure64
04:04:27 <astry> wow, this is excruciating
04:04:39 <astry> why is it so difficult to zoom into images with gtk?
04:04:41 <notdan> Cale: but how do you split?
04:04:51 <notdan> Because right now I am using mkStdGen as you've suggested
04:05:01 <notdan>   let r' = parMap rpar (uncurry calculatePi) $
04:05:01 <notdan>            zip (map mkStdGen (randoms gen)) (take 10 (repeat it))
04:05:02 <Cale> right, so that becomes pureMT
04:05:05 <astry> i've been trying to figure out how to zoom properly for two days now.. and it just doesn't want to work right
04:05:15 <Cale> why zip instead of just map?
04:05:30 <Cale> if you flip the parameters to calculatePi
04:05:40 <Cale> then you can write  map (calculatePi it) gens
04:06:05 <Cale> also, I believe you want  parMap rseq
04:06:50 <Cale> (i.e. evaluate them in parallel, don't spark them as available for parallel computation in parallel)
04:07:38 <astry_> dcoutts: hey, you have worked on gtk2hs, right?
04:07:44 <dcoutts> @arr!
04:07:44 <lambdabot> Smartly me lass
04:08:11 <astry_> dcoutts: can you give me any tips how to zoom images?
04:08:34 <dcoutts> astry: what are you using, cairo, pixbuf?
04:08:44 <astry_> i am using pixbuf
04:09:02 <astry_> i have a pixbuf i load from file and then do pixbufScale
04:09:14 <notdan> Cale: still, ~1.2s :(
04:09:32 <astry_> when i press the i button, i zoom in by 10%, however the position doesn't seem to hold
04:09:43 <astry_> either it sort of drifts around if i do nothing
04:09:50 <notdan> I don't understand, how the python version can be so much faster, it uses shared state for PRNG
04:10:08 <astry_> or, if i try to zoom to the center (so that the center pixel stays in the same place in the window) then it totally fluctuates in weird ways
04:10:16 <dcoutts> astry_: you're displaying it inside an image widget?
04:10:34 <hpaste> astry pasted “zoom fluctuates (press i / o)” at http://hpaste.org/75171
04:10:40 <astry_> dcoutts: yes
04:12:30 <ClaudiusMaximus> astry_: here's a little function i use to zoom about the mouse click location (using opengl within gtk2hs, with procedural images - mandelbrot set) https://gitorious.org/ruff/gruff/blobs/master/src/Interact.hs#line44
04:14:28 <ClaudiusMaximus> astry_: 400+lines of paste with many IORef is a bit too much for me to take in right now, have to go out in about 20mins too....
04:14:54 <dcoutts> astry_: ah so you're keeping the target pixbuf the same size all the time, so you don't need to adjust the image widget
04:15:09 <astry_> ClaudiusMaximus: look inside handleZoom
04:15:29 <ClaudiusMaximus> astry_: http://hpaste.org/75171#line156 right
04:16:04 <astry_> yeah, it's all in the let block
04:16:09 <dcoutts> astry_: the other option is to use cairo rather than pixbuf zoom
04:16:22 <astry_> dcoutts: do you think pixbuf zoom might be broken?
04:16:37 <dcoutts> astry_: I'd be surprised if it is
04:16:52 <astry_> thanks ClaudiusMaximus
04:17:25 <astry_> dcoutts: at the bottom of the let block (line 192) add newL = oldL, newT = oldT
04:17:33 <astry_> this means the top-left corner should stay the same
04:17:40 <astry_> however, if you zoom in, you notice it doesn't
04:17:51 <ClaudiusMaximus> i'm guessing pixbuf zoom would recalculate image pixels in an imperative/mutable fashion?  while cairo and opengl zoom would implicitly recalculate pixels on display
04:18:23 <astry_> hm, no, it does
04:18:40 <astry_> ClaudiusMaximus: every time i load a new zoomed image anew
04:18:47 <astry_> a new zoomed pixbuf that is
04:18:56 <astry_> i don't re-scale an old pixbuf
04:19:09 <ClaudiusMaximus> zooming maths is a bit tricky (for me at least), i suggest drawing diagrams on paper to figure out exactly what you think should happen instead of my traditional manual "genetic programming" techniques with aimless fiddling
04:19:25 <ClaudiusMaximus> astry_: ok, but i have to prepare some other things - g'luck
04:19:29 <astry_> thanks
04:19:39 <astry_> i did try the paper method, and figured it out, and what i figured out doesn't work
04:19:41 <Cale> notdan: lol, apparently it spends 96% of the time in randomPairs
04:19:51 <dcoutts> astry_: sorry, I also don't have time to check all your calculations, but yes the two good choices are pixbuf zoom and cairo, latter being more flexible
04:19:51 <Cale> notdan: So obviously that's what we need to attack
04:20:17 <astry_> in fact it doesn't even nearly work because as you zoom in it'll sometimes drift up and left, and sometimes bottom and right, and it makes no sense to me
04:20:19 <notdan> Cale: sorry, but how did you mange to find that out?
04:20:26 <notdan> I have yet to use a profiler with GHC
04:20:27 <astry_> dcoutts: ok, no problem
04:20:35 <Cale> notdan: compile with -prof -auto-all, run with +RTS -p
04:20:43 <Cale> and then look at the .prof file which is created
04:20:56 <astry_> dcoutts: btw, one more question - once my image widget is big, i can't make the window smaller.. what's the right way to do this?
04:21:19 <dcoutts> astry_: put it inside a scroll window
04:21:46 <astry_> oh ok
04:21:52 <dcoutts> astry_: that or don't make the image widget big
04:22:35 <astry_> well what i really wanted is to be able to make the window smaller, and when i'm done resizing i would change the size of the image window to a new smaller size
04:22:55 <dcoutts> astry_: the latter may make more sense since you're not really showing an image but a zoomed view into another image
04:22:56 <notdan> sweet, thanks Cale
04:22:56 <astry_> because all my scrolling is via the keyboard anyways
04:23:07 <astry_> i didn't understand the latter
04:23:18 <astry_> how do you mean "don't let it get big"?
04:23:52 <astry_> i thought you were joking
04:24:47 <dcoutts> astry_: so here's how I'd make a viewer into a scrollable/zoomable image: use a draw area, the size of the draw area is just your viewport into the bigger virtual image. Then paint that draw area on demand.
04:24:57 <Cale> notdan: I wrote an explicitly recursive randomPairs and it really looks like it's the calls to randomR which are taking the time
04:25:16 <Cale> notdan: which would seem to indicate it's just the RNG which is taking all the time and not this program
04:28:16 <astry_> dcoutts: how is a draw area different from a pixbuf?
04:28:36 <astry_> i think i am using the exact approach you are suggesting
04:29:51 <notdan> Cale: I see. Well, what can I do then
04:30:19 * hackagebot data-nat 0.1.1 - data Nat = Zero | Succ Nat  http://hackage.haskell.org/package/data-nat-0.1.1 (GaborLehel)
04:30:24 * hackagebot Workflow 0.7.0.6 - Monad transformer for thread state persistence and workflow patterns  http://hackage.haskell.org/package/Workflow-0.7.0.6 (AlbertoCorona)
04:30:26 * hackagebot data-nat 0.1.2 - data Nat = Zero | Succ Nat  http://hackage.haskell.org/package/data-nat-0.1.2 (GaborLehel)
04:30:28 * hackagebot groundhog 0.1.0.2 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-0.1.0.2 (BorisLykah)
04:30:30 * hackagebot groundhog-sqlite 0.1.0.2 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.1.0.2 (BorisLykah)
04:31:42 <Cale> notdan: I guess we can try some other libraries. Most of the random generators provide somewhat annoying APIs, the MT one is the most drop-in-replacement-y
04:32:14 <astry_> dcoutts: oh, i see what you mean. I do the zooming when i do viewporting, you suggest an intermediate step.
04:32:17 <astry_> let me try that.
04:33:30 <dcoutts> astry_: sorry, disappeared for a mo
04:34:01 <astry_> np :) cooking myself
04:34:15 <dcoutts> astry_: right, the point is you decide what size your viewport is. The image widget will always be exactly the size of the pixbuf you stick into it.
04:34:20 <notdan> Cale: I tried to rewrite the randomPairs function like that, but now it is extremely slow and requires a lot of memory: http://bpaste.net/show/hyS83r724rCLjkFXRX0o/
04:34:44 <Cale> notdan: don't use an accumulator
04:35:15 <Cale> notdan: just  (r1,r2) : randomPairs' (n-1) g
04:35:32 * hackagebot groundhog-postgresql 0.1.0.2 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.1.0.2 (BorisLykah)
04:35:34 * hackagebot groundhog-th 0.1.0.3 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.1.0.3 (BorisLykah)
04:35:36 * hackagebot rss 3000.2.0.2 - A library for generating RSS 2.0 feeds.  http://hackage.haskell.org/package/rss-3000.2.0.2 (BasVanDijk)
04:36:51 <Cale> notdan: It didn't change the performance much at all when I did that.
04:37:00 <Cale> (from the original version I wrote)
04:38:28 <Cale> notdan: The reason it's better this way is that it in some sense finishes immediately, with a list containing a pair and whose tail will continue the process when/if it's evaluated, so things can get to work immediately.
04:39:13 <astry_> dcoutts: but if the image widget takes up the whole window, then i can't drag-resize the window to a smaller size.. therefore i can't make the pixbuf smaller, and therefore can't make the image smaller
04:40:20 <Cale> notdan: If you use an accumulating parameter like that, it does nothing but call itself and build up expressions in the accumulator until you hit 0 and it finally begins to evaluate which list that is. The whole time, it won't have computed any of the generator states or values, and then you'll immediately demand the last ones.
04:40:51 <dcoutts> astry_: I'm reasonably sure that if you put a smaller pixbuf into the image widget then it's min size reduces, so the window can be shrunk. It doesn't just get bigger and bigger.
04:41:00 <Cale> notdan: and that's what'll give you a stack overflow, possibly, as each randomR is almost certainly going to pattern match its parameter
04:41:37 <Cale> or at the very least, it uses lots of memory hanging on to this huge expression with all the calls to randomR in it :)
04:42:10 <Cale> (and the list is in memory all at once too, whereas it can be generated one cell at a time the other way)
04:42:39 <astry_> dcoutts: i understand that, but i can't know when to make the pixbuf smaller because i can't detect the condition when the window gets dragged smaller
04:42:47 <astry_> dcoutts: because the window is blocked from getting smaller
04:43:23 <dcoutts> astry_: ok this is why I suggest the draw window approach, it has no intrinsic size
04:43:29 <notdan> Ok, I give up! I spent the first half of my day tackling this problem and I am still far from getting to the python performance
04:43:42 <notdan> Which makes me mad, because I don't like python
04:45:21 <astry_> dcoutts: but the draw window is an image widget, right? and that draw window takes up the whole size of my application window.
04:47:37 <dcoutts> astry_: no, a DrawWidget (iirc that's what it's called) not an image widget
04:47:45 <astry_> ahhhh
04:47:47 <astry_> ok
04:47:54 <astry_> i will try that, thanks a lot
04:49:21 <hpaste> Cale pasted “Another attempt” at http://hpaste.org/75172
04:49:29 <Cale> notdan: there's another try
04:49:37 <Cale> showing how you might use MWC
04:49:43 <Cale> but it's not really any faster for me
04:50:13 <Cale> notdan: where was your python code again?
04:50:19 <HankMoody> So how would Haskell perform for some embedded networking?
04:50:51 <astry_> you can make a dsl which generates assembler
04:50:52 <ivanm> Cale: I'm unfamiliar with MWC, but in line 16 wouldn't that just create the same list of values 10 times as you're sharing the seed?
04:51:07 <ivanm> Cale: also, you have a variable for 50000 but you're not using it in that same line :p
04:51:09 <astry_> then you can assemble that in your target's toolchain
04:51:15 <ivanm> astry_: there already is one if memory serves
04:51:31 <astry_> i'm sure there is
04:51:48 <Cale> ivanm: yeah, I should be using that, and no, that's a reference to the generator, not something which needs splitting
04:52:01 <Cale> (it only works in IO/ST)
04:52:04 <ivanm> ahhhhh
04:52:43 <Cale> but hey
04:53:14 <Cale> when I run the python version with 10 workers and 50000 iterations, it takes the same time as the Haskell for me
04:53:19 <Cale> so how are you running it?
04:53:38 <astry_> dcoutts: have you meant DrawingArea? http://hackage.haskell.org/packages/archive/gtk/0.12.3.1/doc/html/Graphics-UI-Gtk-Misc-DrawingArea.html#t:DrawingArea
04:54:12 <dcoutts> astry_: ah yes
04:54:28 <astry_> dcoutts: thanks, i'll try that
04:54:44 <Cale> notdan: also, decreasing the number of parallel computations does wonders
04:54:55 <Cale> notdan: in both the Python and Haskell equally
04:55:04 <Cale> (10 is more than the number of CPUs in my system)
04:55:25 * hackagebot MFlow 0.1.5.5 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.1.5.5 (AlbertoCorona)
04:55:30 <Cale> yeah, the performance is almost identical
04:55:45 <Cale> notdan: so what the heck, man? :)
04:56:01 <Cale> notdan: how are you getting the python to run faster?
04:56:09 <astry_> Cale: pypy? ;)
04:56:21 <ivanm> Cale: magic! :p
04:56:36 <astry_> notdan: where's your code?
04:56:44 <Cale> https://raw.github.com/gist/3769228/ede15efe9c15c83da136b40d16291b2dc7001128/pi.py
04:56:53 <astry_> and the hs?
04:56:57 <ivanm> did he say how he was compiling/running the haskell version?
04:56:59 <Cale> astry_: that'd be a pypy pi.py
04:57:06 <Cale> ivanm: yeah
04:57:17 <Cale> -O2 -threaded / +RTS -N4
04:57:27 <ivanm> OK, so it wasn't as simple as forgetting to use -O2 :)
04:57:33 <ivanm> (that's happened before...)
04:57:41 <Cale> yes, I always check as well
04:58:54 <Cale> I was all like, ready to be blown away by how much faster this naive looking python code looks, and I run it and it takes... exactly the same amount of time as the Haskell program we've been trying to optimise.
04:59:10 <Cale> s/looks/runs/
04:59:19 <astry_> where's the haskell?
04:59:52 <Cale> There's a bunch of versions all over the place...
04:59:57 <astry_> ok
05:00:01 <astry_> :)
05:00:17 <Cale> let me repaste my latest
05:00:41 <hpaste> Cale pasted “random pi” at http://hpaste.org/75173
05:00:58 <Cale> there was a prettier one earlier which ran in the same amount of time
05:01:08 <Cale> though tbh this is shorter anyway
05:01:17 <Cale> (just more in IO)
05:01:21 <hpaste> “Alfredo Di Napoli” pasted “Orc Battle in Haskell” at http://hpaste.org/75174
05:01:49 <Cale> ^^ that is super-cute
05:02:19 <Cale> data Slime = Slime { sHealth :: Int,
05:02:19 <Cale>                      sSliminess :: Int}
05:03:32 <ivanm> I wonder whether they're the same speed because of the IO-bound nature
05:03:44 <Cale> I'm not sure I like this use of typeclasses
05:03:58 <Cale> ivanm: It's the speed of computing pseudorandom numbers
05:04:05 <ivanm> Cale: *nod*
05:04:11 <Cale> It spends like 96% of its time in the PRNG
05:04:12 <ivanm> ugh, abusing Show for pretty-printing
05:04:16 <ivanm> people really should stop doing that
05:04:27 <Cale> why?
05:05:04 <Cale> you mean as opposed to using a prettyprinter combinator?
05:05:09 <Cale> library
05:05:16 <Cale> It is 8am :D
05:05:40 <nand`> I don't really the use of typeclasses in that either; MonsterInstance could be replaced by data Monster = Monster { health :: Int, description :: String, hit :: HitPoint -> Monster, ... }
05:06:11 <ivanm> Cale: yeah
05:06:15 <astry_> yay, i won
05:06:39 <Cale> nand`: yes, and then the instances could take their data as function parameters constructing Monsters
05:06:48 <nand`> that being said, it gives me the idea of using edwardk's classy lenses to have something like class HasHealth, class HasDescription, etc.; then using something like type Monster a = (HasHealth a, HasDescription a, ...)
05:06:52 <Cale> (though I suppose you could keep the datatypes)
05:07:10 <NadiaYvette> What is Show for if not pretty printing?
05:07:23 <Cale> NadiaYvette: indeed
05:07:39 <Cale> NadiaYvette: well, it is more intended as a way to display values for debugging
05:07:42 <ivanm> NadiaYvette: for debugging?
05:07:45 <donri> i prefer derived show instances for types that expose their constructors
05:07:45 <hpc> it's ordinary printing
05:07:50 <nand`> I wonder whether it would just collapse into a pile of boilerplate machinery or whether it would work out nicely
05:07:50 <hpc> "ugly printing", if you will
05:07:58 <ivanm> it makes it a hell of a lot harder to debug code if Show does pretty-printing
05:08:00 <ivanm> hpc: heh
05:08:03 <astry_> wouldn't you want your ordinary printing to be pretty
05:08:19 <ivanm> especially if you can't parse in your pretty-printed Show output
05:08:24 <donri> ivanm: incidentally i think the pretty printing show instance for Doc in wl-pprint-text is a good thing
05:08:40 <donri> because Doc doesn't expose constructors you can pattern match on anyway
05:08:43 <ivanm> or - better still! - you're trying to _debug_ your parser :s
05:08:53 <nand`> show (Player h a s) = "You are a valiant knight with a health of " ... -- I think this is just plain wrong
05:08:57 <ivanm> donri: *nod*
05:08:59 * dcoutts would like a Term class for converting to and from untyped terms
05:09:06 <dcoutts> replacing most uses of Read and Show
05:09:06 <nand`> It's not even pretty printing, it's mixing in content
05:09:24 <notdan> Cale, astry_ : https://gist.github.com/raw/3769228/ede15efe9c15c83da136b40d16291b2dc7001128/pi.py - python; http://bpaste.net/show/v3LtLoT2Hybvr3bQvJ5S/ - haskell
05:09:31 <NadiaYvette> That's a different notion of pretty printing.
05:09:49 <notdan> sorry, went to grab some food
05:10:01 <Cale> notdan: So, I ran your python code and it takes the exact same amount of time as the Haskell code
05:10:39 <Cale> notdan: You should also note that the number 10 of workers is a bad choice
05:11:00 <Cale> and 4 works better for me (# of CPUs)
05:11:06 <ivanm> notdan: why do you have "let ... hits = ... in hits "?
05:11:15 <ivanm> kind of defeats the purpose of defining the variable doesn't it?
05:11:26 <Cale> ivanm: probably because that had other definitions before
05:11:30 <ivanm> ahhh
05:11:31 <ivanm> Cale: does parMap use threads or processes?
05:11:42 <Cale> parMap makes sparks
05:11:48 <Cale> one per list element
05:12:29 <Cale> also, rdeepseq is silly there
05:12:31 <ivanm> I would have thought you could have had more than one spark per CPU...
05:12:32 <ski> > listArray (0,3) "abcd"  -- donri, how about this approach ?
05:12:33 <lambdabot>   array (0,3) [(0,'a'),(1,'b'),(2,'c'),(3,'d')]
05:12:41 <ivanm> yeah, it's a bit useless
05:12:42 <Cale> rseq will fully evaluate a Double
05:12:43 <ivanm> seq would do
05:12:52 <donri> ski: was that meant for me?
05:12:56 <ski> yes
05:13:02 <donri> why?
05:13:59 <ski> donri : "incidentally i think the pretty printing show instance for Doc in wl-pprint-text is a good thing" -- that array example is an example of neither exposing the constructors, nor outputting a non-haskell-code string
05:14:24 <nand`> > Map.fromList [(0, "foo"), (1, "bar")]
05:14:25 <lambdabot>   Not in scope: `Map.fromList'
05:14:32 <notdan> Cale: I use 4 workers now and -N4. rseq instead of rdeepseq. Python code runs under 0.2 seconds, haskell code takes more than 0.5 seconds
05:14:40 <ski> > M.fromList [(0, "foo"), (1, "bar")]
05:14:42 <lambdabot>   fromList [(0,"foo"),(1,"bar")]
05:14:51 <Cale> notdan: increase the number of iterations would you?
05:14:56 <notdan> maybe GHC for mac os is just not as good as python interpreter
05:15:00 <notdan> Cale: yeah, doing that atm
05:15:08 <nand`> the only problem I have with that is that the name should be qualified
05:15:18 <donri> ski: yea, that's a sensible show instance for Map methinks
05:15:20 <ivanm> ski: though the convention for pretty-printing libraries is that show prints the pretty-printed value
05:15:21 <ski> yes
05:15:21 <notdan> btw, I wanted to say thank for you help, Cale, today I learned *a lot* about parallelism in Haskell
05:15:22 <nand`> because eg. Seq's show instance works the same way
05:15:25 <ivanm> rather than text "..."
05:15:41 <ivanm> nand`: yeah, but there's no sane way to do consistent qualification
05:15:45 <Cale> user	0m1.368s -- python version, 500k iterations, 4 workers
05:15:52 <ivanm> if it was forced that Data.Map was always qualified as Map, it would work
05:15:54 <nand`> Data.Map.fromList -- it's defined in Data.Map, no?
05:15:56 <ivanm> unless you _fully_ qualified it
05:15:58 <Cale> 1.357125s elapsed. -- haskell version, 500k iterations, 4 workers
05:16:05 <nand`> but that might get a tad verbose
05:16:07 <ivanm> nand`: yeah, just realised that as I was writing earlier :)
05:16:09 <ivanm> yup
05:16:25 <ivanm> the worst cases happen when you have multiple fromLists, etc. in the same Show output :s
05:16:50 <notdan> hm, my haskell version takes 5.8 secs and python - 0.6
05:16:54 * ivanm spent quite a few hours adding in qualifications to the Show output from a QC run of graphviz that failed
05:16:56 <nand`> yeah, like when showing large records with autoderived instances
05:17:00 <donri> ivanm: not a problem for read'ing, but for mere humans yea
05:17:06 <nand`> lack of newlines makes those nearly impossible to read
05:17:07 <solirc> Is there a way to set the package name for code loaded into GHCi?
05:17:08 <notdan> plus I had to use -K100M
05:17:09 <ski> nand` : i think a proper solution would be to be able to get a value representing a Haskell expression, and then being able to, given a list of what modules has been openend, convert that to a string (with explicit qualification for those identifiers which need it)
05:17:11 <ivanm> notdan: I really suspect you're doing something wrong then...
05:17:24 <Cale> notdan: wait, what's -K?
05:17:26 <nand`> I think it would actually be better for Show to place newlines between record fields
05:17:34 <notdan> Cale: stack space
05:17:38 <ski> ivanm : "the convention for pretty-printing libraries is that show prints the pretty-printed value" -- yes, but i'm not sure i like it
05:17:43 <Cale> oh, hah, don't change that
05:17:46 <nand`> it's not like you're going to use auto-derived record Show instances for anything other than debugging
05:17:47 <Cale> fix the problem
05:17:47 <donri> nand`: groom?
05:17:52 <ivanm> nand`: no, it was that I had two different types of named colours, mixing and matching different graph representations, sequences, etc. all needing qualification
05:17:56 <ivanm> and the Show output was _long_
05:18:01 <Cale> If you run out of stack space, it's a bug
05:18:04 <Cale> (almost always)
05:18:06 <ivanm> ski: *nod*
05:18:07 <nand`> ivanm: ah
05:18:15 <ivanm> ski: it's arguable either way I think
05:18:27 <Cale> Is that last paste you linked the exact code you're using?
05:18:32 <ivanm> since it's usually easy to get it back into the code form
05:18:54 <ivanm> nand`: I use non-derived Show instances a fair amount...
05:18:55 <ski> nand` : i wouldn't have anything against putting newlines into the output, e.g. putting too long arguments on lines of their own (preferably aligned)
05:18:58 <notdan> Cale: well,t he bug was that I was suing sum instead of foldl'
05:19:00 <notdan> using*
05:19:03 <ivanm> nand`: sorry, misread what you wrote
05:19:17 <notdan> but it's still really slow, 4.5secs
05:19:35 <Cale> cale@ender:~$ ./notdanpi +RTS -N4
05:19:35 <Cale> 3.141352
05:19:35 <Cale> 1.244448s elapsed.
05:19:46 <ski> ivanm : just showing a `Doc' as its rendering isn't so bad, but showing a value which contains `Doc's at various places is bad -- iow the mixing
05:19:49 <Cale> oh, derp
05:19:50 <donri> i wish the types in GHC.Generics had [derived] Show isntances
05:19:55 <ivanm> ski: ahhh, yes
05:19:57 <notdan> what the hell :(
05:20:02 <Cale> yeah, that's way slower
05:20:15 <notdan> Cale, do you use Linux?
05:20:16 <ski> ivanm : if it outputted some kind of quasiquoter stuff for `Doc' there, that would be ok
05:20:18 <Cale> (forgot to edit the iteration count for your program)
05:20:20 <Cale> yeah
05:20:45 <ivanm> ski: for planar-graph, I deliberately have the Show instance for Node, Edge and Face be invalid code as you're not meant to create them directly; it does mean structures containing them can't be Read in again straight away
05:20:54 <ivanm> (without adding explicit Read clauses)
05:21:14 <Cale> notdan: hang on a sec, let me mess with this for a bit. I made some changes to mine, and I think I missed what actually counted.
05:21:56 <dreixel> donri: why?
05:22:12 <donri> dreixel: would make it easier to learn by exploration
05:22:32 <ski> ivanm : ok (and adding such explicit `Read' instances would probably by hairy, in case you want to read stuff like `[Node]',&c., i assume)
05:22:32 <dreixel> well, you can use standalone deriving
05:22:42 <dreixel> but I guess I could add those instances
05:22:59 <ivanm> ski: yeah; (Node 1) gets printed as Node_1
05:23:04 <donri> cool
05:23:05 <dreixel> can you create a feature request?
05:23:23 <ski> ivanm : anyway, i think there's several distinct uses hiding in here, and it would be good if we could separate these uses into different classes
05:23:48 <sheriff> Given an arg of type Bla that may have been created from a number of different data constructors, can I programatically get at the Data Constructor other than by type matching?
05:24:02 <donri> dreixel: OperationalError: database is locked
05:24:05 <donri> when logging into trac
05:24:25 <ivanm> sheriff: I don't think so
05:24:52 <ski> one of these uses is similar to `lift' in MetaML : converting a value to a code representation that, if evaluated (in some kind of standard environment) will yield an equal value
05:25:14 <Cale> notdan: hmm... I guess it does make a difference to use MWC
05:25:41 <ski> then that could be combined with a way to serialize such code representation, e.g. into a string (possibly with pretty-printing in the sense of using newlines and aligning stuff) and back
05:25:44 <Cale> notdan: did you try this one? http://hpaste.org/75173
05:26:49 <ski> in the `Doc' case, we want some custom string representation (which presumably can't be read back in ?), which seems to be a different use case
05:27:39 <ivanm> well, in my last case, I have it print _something_ (which is exposing some internals) just so you _can_ debug code
05:27:50 <Cale> oh, oops
05:27:51 <Cale> hmm
05:28:18 <dreixel> donri: try again. happens every now and then.
05:28:19 <ski> but maybe in some cases we could see this kind of thing as outputting code in a language with different concrete syntax (so one could use a quasiquoter to embed such in Haskell source) : i'm thinking of various textual representations of config files, graphs, simple tables, &c.
05:29:15 <ski> sheriff : i'm not sure what you mean by "type matching" ..
05:29:18 <Cale> oh, derp
05:29:24 <Cale> there was another 10 which needed to be 4
05:29:33 <Cale> let's restructure this so the program is sane
05:29:42 <ivanm> Cale: magic numbers causing problems again? :p
05:31:12 <donri> dreixel: http://hackage.haskell.org/trac/ghc/ticket/7263
05:31:51 <ski> sheriff : in any case, to be able to match and unpack the value of type `Bla' wrt a data constructor of that type, you must have that data constructor in scope (either by defining it in the same module, or by importing it from a module which exports it)
05:32:57 <sheriff> I am trying to debug a non-exhaustive pattern match error
05:33:18 <sheriff> And I have a gazillion data type constructors, so I don't wanna do that
05:33:23 <ski> (maybe one could do some kind of trick with something like the `Data' type class, but i'm not sure -- and probably this is not what you want/need)
05:33:39 <sheriff> I also can't do a 'show' on it, because the piece of data in this case is defined recursively
05:33:50 <ski> sheriff : paste the code ?
05:33:58 <ski> @paste
05:33:58 <lambdabot> Haskell pastebin: http://hpaste.org/
05:34:00 <sheriff> Which piece? I'm not sure how that would help
05:34:14 <sheriff> I want: foo x = show (typeOf x)
05:34:18 <sheriff> where typeOf is a real thing
05:34:30 <sheriff> but refers to the data constructor, rather than the type class
05:35:02 <ski> have you defined `typeOf' yourself, or is this the standard one ?
05:35:07 <ski> @index typeOf
05:35:07 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
05:35:33 <sheriff> I am looking for some kind of typeOf function that will tell me the data constructor used in the construction of whatever I gie it
05:35:47 <notdan> Cale: oh, I see it too
05:35:56 <notdan> well, it shouldn't affect the performance, should it?
05:36:07 <ski> sheriff : you could try pasting the definition of the data type (with all data constructors), together with the definition which generates the "non-exhaustive pattern match error"
05:36:20 <Cale> notdan: right, it doesn't
05:36:31 <Cale> notdan: I just suddenly realised the result was way off :)
05:36:42 <sheriff> ski: If I was trying to solve this specific bug as a priority, rather than trying to answer my question, that would be a sensible thing to do, yes
05:37:24 <sheriff> ivanm: Thanks
05:37:30 <ski> > toConstr (Just 28)  -- maybe what you're lookig for is `toConstr' (but i'm still not sure whether it's what you need)
05:37:31 <lambdabot>   Just
05:37:44 * sheriff looks
05:38:01 <donri> > tyConString . typeRepTyCon . typeOf $ Just 0
05:38:05 <lambdabot>   "Maybe"
05:38:11 <donri> bah
05:38:14 <dreixel> donri: saw it, thanks
05:39:13 <sheriff> Given: singleItemList = DList (DInteger 1) DListCollapse
05:39:33 <sheriff> I would like: (foo singItemList) to return "DList"
05:40:08 <donri> > showConstr . toConstr $ Just 0
05:40:09 <lambdabot>   "Just"
05:40:25 <ski> sheriff : i think that if you add `deriving Data' on the datatype definition, `toConstr' will basically do that
05:40:43 <Cale> Doing 5 million iterations creates a stack overflow inside of MWC, lol. They weren't careful to force the generator state when updating it.
05:41:13 <Cale> (So creating lots of random values without actually evaluating them causes an overflow)
05:41:30 <sheriff> Ah crap, this is where I get bitten for using my own 'Data' type
05:41:37 <ski> sheriff : .. however, i'm still not sure why (you think) you want to do this
05:41:42 <ski> sheriff : ?
05:41:58 * Cale wonders where bos is
05:42:04 <ski> using your own datatype should be fine here
05:42:19 <sheriff> ski: 50% curiosity, 50% trying to work out what's wrong with my program
05:42:20 <ski> the `Data' in `deriving Data' i mentioned is a type class, not a datatype
05:42:25 <Cale> oh well, this is easy to work around :P
05:42:34 <sheriff> Where my program is homework, so I don't feel right posting the actual code here
05:43:01 <ski> sheriff : well, that( the 50% thing)'s an acceptable answer :)
05:43:11 <ski> ok
05:43:21 <Cale> hmm, maybe not so easy
05:43:24 <sheriff> I think I am going to focus instead on just fixing the program
05:43:35 <sheriff> thanks sincerely for your help
05:43:36 <ski> sheriff : about how many (data) constructors do you have in this data type ?
05:44:42 <sheriff> ski: Not enough to justify the fuss I'm making. /me gets busy with copy and paste
05:45:04 <mux> damn, Network.Socket.ByteString lacks a sendTo function
05:45:41 <mux> despite the documentation giving example import statements hiding sendTo from Network.Socket
05:45:43 <ski> anyway, "nonexhaustive" means you're not handling some cases
05:45:53 <ski> sheriff : are you using any guards in that definition ?
05:47:31 <notdan> Eh, Cali, I think I'll give up, it just doesn't worth it and I've spent a lot of time on this already. Thasnk you very much for your assistance, I really appreciate it
05:48:58 <mux> actually, Network.Socket.ByteString has sendTo, but Network.Socket.ByteString.Lazy does not
05:50:31 <mouna> could anyone helps me with that : I would like to extract the tdescription of the Transaction http://hackage.haskell.org/packages/archive/hledger-lib/latest/doc/html/Hledger-Data-Types.html#t:Transaction
05:51:52 <Cale> notdan: The MWC one doesn't run faster for you?
05:52:14 <Cale> notdan: you might also try replacing MWC with http://hackage.haskell.org/package/mersenne-random-1.0.0.1
05:52:29 <Cale> notdan: which gets it down under a second for 500000 iterations
05:52:31 <Cale> for me
05:52:49 <notdan> I haven't tried the MWC yet
05:52:56 <Cale> notdan: oh
05:52:59 <Cale> notdan: why not?
05:53:24 <Cale> That's the one which was running fast for me
05:54:01 <HankMoody> I have 3.675 GPA, sounds to ghigh
05:54:18 <notdan> Idk, can you paste me the MWC version?
05:55:02 <Cale> http://hpaste.org/75173 -- replace that 10 with a 4, or better yet make a variable :P
06:01:31 <Cale> notdan: unfortunately, these versions with impure generators don't really benefit much like this from the parallelisation we're using -- most of the time is spent generating random numbers up front. With forkIO, you could use them concurrently.
06:02:54 <Cale> (using different generator references for each thread)
06:04:29 <dcoutts> Cale: for parallel sims a typical approach is to create multiple rng streams up front, and then use one in each chunk
06:04:40 <Cale> yeah
06:04:52 <dcoutts> there are rngs designed for this use case
06:05:17 <dcoutts> splitable up front, not general binary splitting at any point
06:05:20 <Cale> dcoutts: Well, you need to parallelise the generation of random numbers here, because it's like 96% of the work :)
06:05:28 <dcoutts> yes exactly
06:05:36 <dcoutts> you init N streams
06:05:58 <dcoutts> so there's no sharing when you evaluate them in parallel
06:06:17 <Cale> btw, I just noticed that the Feit-Thompson theorem is the ultimate justification for even/odd having special names and divisibility by other numbers not.
06:07:26 <dcoutts> Cale: we've been doing this for a high energy particle sim that runs in parallel, the perf and quality of the rng is critical
06:07:49 <Cale> dcoutts: Which implementation do you use?
06:07:59 * dcoutts is just finding it
06:09:44 <dcoutts> Cale: https://github.com/bjpop/lfg  and previously https://github.com/bjpop/haskell-sprng
06:10:02 <dcoutts> SPRNG is a Fortran/C prng lib, which we bound and also ported
06:11:16 <dcoutts> Cale: the key feature of SPRNG is that you can make a number of independent streams (and it has good statistical properties for these)
06:11:29 <ciao> ciao
06:11:37 <ciao> list!
06:12:40 <Cale> It's interesting that it's usually even-sized things which are misbehaved in various ways in mathematics.
06:16:32 <rwbarton> well in general I think the fewer small prime factors the "better"
06:17:09 <Cale> Well, characteristic two is frequently a special case
06:17:19 <rwbarton> a group whose order has NO proper factors is a lot "better" than just "not simple" :)
06:20:28 * hackagebot GLFW-b 0.1.0.3 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.1.0.3 (BrianLewis)
06:25:30 * hackagebot nanospec 0.1.0 - A lightweight implementation of a subset of Hspec's API  http://hackage.haskell.org/package/nanospec-0.1.0 (SimonHengel)
06:35:23 <zomg> Any advice on figuring out why cabal install gives random segfaults?
06:35:43 <zomg> I wonder if the build system is somehow fucked since this seems pretty weird
06:35:52 <zomg> but no idea how to go about debugging/fixing it
06:35:57 <dcoutts> zomg: check if it's the cabal binary that's segfaulting or some other program that cabal calls
06:36:17 <dcoutts> e.g. ld
06:36:17 <zomg> How can I do that? It's very random, as in sometimes it's package a, other times package a installs fine
06:36:55 <dcoutts> when running it from the shell it should be clear from the output
06:37:19 <zomg> Hmm, I ran it with -v and I think it's ghc
06:37:57 <zomg> I see the ghc command line, then the ghc "compiling ..." output, then exitfailure 11
06:38:23 <zomg> The thing is, I've tried ghc 7.4.1 and ghc 7.4.2 and no matter which one it is I keep getting this
06:38:43 <dcoutts> zomg: are you running on a box with very little memory?
06:39:06 <zomg> 512mb ram, but I've added additional disk swap worth 1 gb
06:39:10 <dcoutts> zomg: other suggestion is to check for bad ram with a memory checker
06:39:42 <dcoutts> zomg: ok, 512 is quite low, to the point where the linker can often get killed by the linux OOM killer
06:39:54 <dcoutts> zomg: does it happen when it's linking?
06:40:00 <zomg> Yeah I was getting 'Killed' when compiling ghc earlier but boosting it with the swapfile fixed it
06:40:01 <dcoutts> often/typically
06:40:16 <zomg> hamlet-1.1.0.2 failed during the building phase. The exception was:
06:40:22 <zomg> I'm assuming this means it was not linking :)
06:40:30 <dcoutts> no, need to see where it really diea
06:40:32 <dcoutts> died
06:40:54 <zomg> Okay let me paste the output before that
06:40:55 <rwbarton> you can check in dmesg whether the OOM killer killed it, if you can match up the times
06:40:56 <dcoutts> from the output from ghc, does it look like it had started linking?
06:41:47 <zomg> rwbarton: dmesg just has 'ghc segfault' messages
06:41:53 <hpaste> fffff pasted “cabal fail” at http://hpaste.org/75176
06:42:04 <zomg> That's the output from cabal
06:44:25 <zomg> I am getting this with the default ubuntu ghc package too btw
06:44:31 <zomg> which is 7.4.1
06:44:47 <zomg> however I also tried compiling 7.4.1 from source, and  currently have 7.4.2 from source installed
06:49:32 <zomg> I've spent the last two days trying to figure this out so any ideas would be nice :P If you have any ideas on how to debug this further would be also welcome since I don't really know much about that, so I may be missing some sort of obvious thing to look at
07:00:16 <Ghal> Hey, does anyone have time to help out a haskell noob with a small problem?
07:02:23 <mcstar> just post the code with problem description, whoever can help will do
07:02:59 <liyang> Ghal: C'est notre raison d'être!
07:05:06 <mcstar> well, not mine, but the channel's
07:05:58 <liyang> I was speaking collectively.
07:06:17 <mcstar> i get it
07:06:30 <mcstar> my google translator is working just fine :)
07:06:48 <Ghal> Well the problem is that I can't figure out how to write the code...Let me explain, I'm making a blackjack game for an assignment, and I have come to the part where I suffle the deck...The problem is that I need to create a random number generator using StdGen, and well it doesn't really become random since the same value create the same generated value every time , and I'm out of Ideas how to use this to get a new value every time
07:07:04 <ivanm> @type random
07:07:05 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
07:07:15 <ivanm> ^^ you give it a seed, you get back a value and a new seed
07:07:16 <jesyspa> When I compile and run this (GHC 7.4.2), I must enter a char before anything is printed.  Why is this?  http://ideone.com/EfBqt
07:07:23 <ivanm> use the new seed when you next want to get a random value
07:07:54 <mcstar> Ghal: you either request an infinite list of random numbers, or pass the seed value back after pulling out a random number, or hide this away, by using IO
07:08:59 <ivanm> jesyspa: interesting... I think it's because the putStr is waiting for the rest of the line
07:09:11 <ivanm> using putStrLn definitely doesn't have that problem
07:09:13 <Ghal> mcstar: I earlier had the idea to send back the new seed value to the generator but I'm not sure how to do it
07:09:28 <ivanm> Ghal: you get the new seed, and pass it back to your calling function
07:09:39 <jesyspa> ivanm: Any way I could flush the buffer manually?
07:09:54 <byorgey> Ghal: you don't need to do that.  The functions which give you a random value also give you a *new generator*
07:09:58 <ivanm> e,g, getting _two_ random numbers: get2Rand g = let (n1,g') = random g; (n2,g'') = random g' in ((n1,n2),g'')
07:10:18 <ivanm> jesyspa: probably; have a look through System.IO
07:10:26 * ivanm needs sleep
07:10:27 <ivanm> @time
07:10:28 <lambdabot> Local time for ivanm is Mon Sep 24 00:10:07
07:10:36 <jesyspa> Thanks, will do.
07:10:59 <byorgey> jesyspa: hFlush stdout
07:11:08 <jesyspa> byorgey: Ah, thanks.
07:11:09 <Eduard_Munteanu> jesyspa: or you could disable line buffering
07:11:17 <byorgey> jesyspa: the other option is to turn off output buffering, with  hSetBuffering stdout NoBuffering
07:11:26 <Eduard_Munteanu> @hoogle hSetBuffering
07:11:27 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
07:11:27 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
07:11:43 <jesyspa> Thanks, I'll read up on those.
07:14:34 <mcstar> i used seed and generator synonimously
07:15:24 <jesyspa> Thanks, that works great! :D
07:15:30 * hackagebot esqueleto 0.2.8 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2.8 (FelipeLessa)
07:19:02 <byorgey> using 'seed' and 'generator' synonymously is probably confusing for beginners
07:19:29 <byorgey> A seed can be used to create an initial generator.  A generator can be used to generate pseudorandom numbers.
07:20:47 <mm_freak_> StdGen is a bit unfortunately named
07:21:04 <mm_freak_> the generator doesn't manifest in a type, but in a RandomGen instance
07:21:40 <mcstar> byorgey: agreed, but from the types, it was clear what i meant.... since it takes and gives a RandomGen g
07:22:13 <byorgey> mcstar: it is clear to *me* what you meant.  But not to a beginner who is confused about the types anyway.
07:22:24 <mcstar> and i agree
07:29:58 <Ghal> okay I got it working now, Thanks! :D
07:41:06 <tsou> anyone knows how the online LYAH and the printed LYAH compare in terms of date?
07:55:46 <dncr> what is a "coparser"?  http://hackage.haskell.org/packages/archive/fixhs/0.1.3/doc/html/Data-Coparser.html
07:58:28 <merijn> jesyspa: That's actually default (i.e. posix/C, which is alos copied by python and pretty much every language I know) behaviour for reading from stdin/writing to stdout is to buffer everything until a newline appears (i.e. reading/writing in lines at a time)
07:58:58 <merijn> tsou: AFAIK not enough difference to worry about
07:59:12 <jesyspa> merijn: I'm used to C++, where stdin and stdout are bound together, so any output will cause a flush of the input.
07:59:40 <jesyspa> And in Python I've only used input(), which flushes seeing as it's meant to be used as a dialogue.
08:00:08 <jesyspa> Haskell seems to be more fully-featured in terms of what I can do with the terminal using the stdlib, though.
08:00:11 <merijn> jesyspa: Ah, I'm not familiar with the C++ behaviour. The more you know... :)
08:02:19 <wunki> I have an "examples" directory for my library. Is there a possibility to add a flag to cabal which also builds executables from the examples?
08:02:57 <dcoutts> yes
08:03:33 <dcoutts> declare a flag, and make buildable: False, conditional on that flag
08:04:27 <wunki> I currently have the following: https://gist.github.com/fa8fa30b584a6f3798c0
08:05:23 <mcstar> jesyspa: could  you explain what does c++ differently?, or what did you mean
08:06:01 <wunki> dcoutts: like this: https://gist.github.com/616ac908bdd26180cc71
08:06:58 <dcoutts> wunki: yes, though you can simplify it since True is the default, so you don't need both branches of the if
08:07:05 <jesyspa> mcstar: std::cout << "Input: "; std::cin >> i; // C++ guarantees that Input: will be displayed in a timely manner (i.e. on the call to operator>>, if I'm not mistaken).
08:07:23 <wunki> dcoutts: thank you
08:07:34 <jesyspa> Let me look up the exact phrasing.
08:08:48 <dcoutts> jesyspa: Haskell doesn't tie stdin and stdout, you can flush explicitly if you need to.
08:09:10 <jesyspa> mcstar: According to cppreference.com: "[Most] versions operator behave as formatted input functions. That is, they construct a sentry object at the beginning that flushes the tie()'d buffers if needed...".
08:09:22 <jesyspa> Yep, seems like that's the main difference between the two; good to know. :)
08:09:49 <jesyspa> (I was primarily confused due to the difference with ghci, where both seem to be unbuffered.)
08:09:50 <mcstar> jesyspa: what about c?
08:10:53 <mcstar> so basically with cout/cin it is guaranteed that before any read form stdin, stdout is flushed?
08:10:56 <jesyspa> mcstar: I don't know, I haven't coded in C in ages.
08:11:03 <jesyspa> Any formatted read.
08:11:14 <Polarina> mm_freak_, is netwire 4 already stable? I mean, I don't want to write my code when it could break every hour or two (every week's fine).
08:11:51 <jesyspa> I think there's a way to untie them, but I'm not sure.
08:11:52 <mm_freak_> Polarina: it's stable, i'm just finishing the tutorial
08:12:16 <Polarina> mm_freak_, shiny. :) -- I'll take a look into it then.
08:12:39 <mm_freak_> darcs get http://darcs.ertes.de/netwire/
08:12:41 <mm_freak_> go ahead =)
08:13:20 <dons> morning, folks.
08:13:35 <dcoutts> hia dons
08:13:48 <mm_freak_> hi there dons
08:14:44 * dcoutts is hacking on the hackage server, reducing memory consumption
08:14:47 <Polarina> mm_freak_, I like how Time is back, like in netwire 1, instead of the clumsy MonadClock typeclass. It'd make things simpler for me.
08:15:12 <mm_freak_> Polarina: yeah, i never really liked MonadClock
08:15:20 <mm_freak_> or even the worse ArrowClock
08:15:32 * hackagebot vector-space-points 0.1.2.0 - A type for points, as distinct from vectors.  http://hackage.haskell.org/package/vector-space-points-0.1.2.0 (BrentYorgey)
08:16:24 <Polarina> mm_freak_, the only reason I can think of it being beneficial if I would want to work with Rational rather than floating-points. Never had to do that though.
08:16:57 <hazkell> whom to ask to get unbanned ?
08:17:16 <lpvb> is there an easy function to update one character in a string?
08:17:38 <lpvb> by its index
08:17:50 <mm_freak_> Polarina: i could have made the time type polymorphic, but it didn't really seem necessary
08:17:57 <wunki> when I add a flag in .cabal, e.g. `flag examples`, how do I call it from cabal? `--examples` doesn't seem to do it.
08:18:04 <mm_freak_> Polarina: Wire has enough type arguments as it is =)
08:18:16 <rwbarton> hazkell: are you the one who was running a duplicate lambdabot?
08:18:33 <Polarina> mm_freak_, what do you mean? We all want more type arguments. </sarcasm>
08:19:18 <Polarina> lpvb, take a look at some of the functions here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
08:19:21 <monochrom> ah, yes, I remember now, the duplicate lambdabot that always replies informationlessly
08:19:31 <hazkell> rwbarton: probably yes, just tried the connect.rc from the installation
08:19:41 <Polarina> lpvb, there's no single function to do what you want, as far as I am aware. What is it you're trying to achieve?
08:19:52 <rwbarton> hazkell: well it was banned because a duplicate lambdabot is really annoying :P and it kept coming back
08:20:09 <monochrom> and it was loud and informationless
08:20:23 <monochrom> "mu-eval timeout" even with "> 0"
08:20:33 <mcstar> jesyspa: thanks
08:20:47 <monochrom> (I was certainly not impressed)
08:20:56 <hazkell> rwbarton: understand, it was my ignorance
08:21:25 --- mode: ChanServ set +o monochrom
08:21:36 --- mode: monochrom set -b dunric*!*@*
08:21:41 --- mode: monochrom set -o monochrom
08:21:45 <rwbarton> sure, so make sure you have your lambdabot configured not to join #haskell
08:22:13 <mm_freak_> Polarina: you probably would have liked how i defined Wire in the first attempt to create netwire 4 =)
08:22:24 <dcoutts> wunki: cabal configure --help will tell you
08:22:28 <hazkell> monochrom: thanks (btw. good memory)
08:22:42 <mm_freak_> Polarina: newtype Wire e s cat a b
08:22:49 <Polarina> :D
08:22:58 <mcstar> ~dunric@101.16 .....
08:23:01 <mm_freak_> where s is a functor
08:23:31 <hazkell> rwbarton: sure it won't happen again
08:25:42 <wunki> dcoutts: ah, --flags="" :)
08:27:39 <jmcarthur> it's a dons!
08:38:31 <carpi> are where clauses available between different function patterns?
08:39:14 <rwbarton> only different guards on the same pattern
08:39:27 <rwbarton> since different patterns could bring different variables into scope in the where clause
08:39:52 <mcstar> if the where is at the same level as the pattern defined function, yes
08:40:06 <rwbarton> ... though now I wonder how that works with pattern guards
08:40:57 <mcstar> well,i should have said, if the where bound thing is defined in the same where, as the pattern defined function...
08:41:22 <rwbarton> I assume your question was about something like
08:41:25 <rwbarton> f 1 = x
08:41:27 <rwbarton> f 2 = x + 1
08:41:29 <rwbarton>   where x = ...
08:41:46 <carpi> yes
08:42:14 <Polarina> carpi, one common solution is to use case:  f x = case x of { 1 -> f' x; _ -> 0 } where f' x = x + 1
08:42:48 <noviceprogrammer> hello
08:42:56 <carpi> hmm.. case of works here yes
08:43:18 <jmcarthur> local modules would also be a solution :\
08:43:23 <jmcarthur> err
08:43:27 <noviceprogrammer> does haskell have a Decimal or Real type?
08:43:30 <jmcarthur> multiple modules per file at least
08:43:45 <Polarina> noviceprogrammer, there's Rational for rational numbers.
08:44:05 <noviceprogrammer> right
08:44:08 <MostAwesomeDude> noviceprogrammer: There's a typeclass for fractional numbers and another for real numbers.
08:44:09 <jmcarthur> noviceprogrammer: there's Float and Double (just use Double). there's also Rational. a library provides CReal, but i doubt anybody really uses it for practical stuff
08:44:19 <noviceprogrammer> ah
08:44:32 <MostAwesomeDude> ...Wait, is there a full typeclass around CReal or just CReal itself?
08:44:33 <jmcarthur> Fixed, as well
08:44:37 * MostAwesomeDude should wake up before saying things
08:44:40 <jmcarthur> MostAwesomeDude: just CReal itself
08:44:43 <nand`> there's Floating
08:44:52 <MostAwesomeDude> nand`: Ah, that'd be it.
08:45:00 <noviceprogrammer> I have lots to learn about Haskell (and FP in general) ^^
08:45:05 <nand`> yeah, it's meant for stuff that can't really be represented exactly
08:45:07 <jmcarthur> i thought noviceprogrammer was asking about types, not type classes
08:45:25 <Polarina> > (5%3) * (2%8)
08:45:26 <lambdabot>   5 % 12
08:45:32 * hackagebot pathtype 0.5.3 - Type-safe replacement for System.FilePath etc  http://hackage.haskell.org/package/pathtype-0.5.3 (BenMoseley)
08:46:19 <nand`> there are a few libraries around providing arbitrary fixed length decimal numbers
08:46:20 <jmcarthur> noviceprogrammer: Rational is a numerator and denominator, both Integers. Float and Double are the usual machine floats. Fixed is an integer with a decimal point in some fixed location (depends on type parameter).
08:46:33 <jmcarthur> Fixed is in the standard libs, though
08:47:31 <ClaudiusMaximus> @hackage variable-precision
08:47:31 <lambdabot> http://hackage.haskell.org/package/variable-precision
08:47:34 <ClaudiusMaximus> one i wrote
08:47:42 <ClaudiusMaximus> may have bitrotted and be slow
08:47:52 <noviceprogrammer> right
08:48:14 <jmcarthur> i guess since we're plugging packages, here's a binary fixed point library i wrote http://hackage.haskell.org/package/fixed-point
08:48:23 <jmcarthur> but it has some problems, like a broke Show instance
08:48:37 <ClaudiusMaximus> feel free to file bug reports, but i won't have time to work on them until late october...
08:48:55 <jmcarthur> also requires some extra flags to ghc to prevent ghc from overflowing some stack
08:49:02 <jmcarthur> at least for some uses
08:49:52 <merijn> Speaking of CReal, I always get really confused by it's name and how it matches Foreign.C.Types >.>
08:50:04 <nand`> yeah
08:50:32 * hackagebot explicit-iomodes 0.6.0.5 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.6.0.5 (BasVanDijk)
08:53:51 <ParahSailin> state monad is not part of prelude? it's mtl package?
08:55:07 <t7> > 17 / 12
08:55:08 <lambdabot>   1.4166666666666667
08:55:34 * hackagebot explicit-iomodes-bytestring 0.2.0.2 - Extends explicit-iomodes with ByteString operations  http://hackage.haskell.org/package/explicit-iomodes-bytestring-0.2.0.2 (BasVanDijk)
08:55:36 * hackagebot explicit-iomodes-text 0.1.0.8 - Extends explicit-iomodes with Text operations  http://hackage.haskell.org/package/explicit-iomodes-text-0.1.0.8 (BasVanDijk)
08:56:28 <mcstar> > 22 / 7
08:56:29 <lambdabot>   3.142857142857143
08:56:44 <byorgey> ParahSailin: correct
08:57:26 <mm_freak_> carpi:  i usually write a local function definition:  f x = f' x where …
09:00:33 * hackagebot string-combinators 0.6.0.4 - Polymorphic functions to build and combine stringlike values  http://hackage.haskell.org/package/string-combinators-0.6.0.4 (BasVanDijk)
09:00:35 * hackagebot dstring 0.4.0.4 - Difference strings  http://hackage.haskell.org/package/dstring-0.4.0.4 (BasVanDijk)
09:05:33 * hackagebot repr 0.4.1.3 - Render overloaded expressions to their textual representation.  http://hackage.haskell.org/package/repr-0.4.1.3 (BasVanDijk)
09:10:53 <ParahSailin> what is ST monad
09:21:22 <Philonous> Why does pokeSockAddr leave the port in host byte order?
09:25:33 * hackagebot catch-fd 0.1.0.0 - MonadThrow and MonadCatch, using functional dependencies  http://hackage.haskell.org/package/catch-fd-0.1.0.0 (AndySonnenburg)
09:29:05 <akamaus> does anybody know of r-tree implementation in Haskell?
09:36:37 <carpi> is there a way to make a fold to stop processing the input list based on a condition?
09:38:16 <copumpkin> carpi: with a foldr, you sort of have control over that yourself
09:38:19 <copumpkin> but it's subtle
09:38:41 <copumpkin> > foldr (&&) True [True,False..]
09:38:42 <lambdabot>   <no location info>: parse error on input `]'
09:38:50 <copumpkin> > foldr (&&) True (cycle [True,False])
09:38:51 <lambdabot>   False
09:39:46 <obk> What is the status of the class alias proposal (http://repetae.net/recent/out/classalias.html and/or http://www.haskell.org/haskellwiki/Superclass_defaults)?
09:40:29 <obk> I have a pretty large code base and this would have significantly cut down on my boilerplate...
09:41:55 <obk> Is there a way to approximate it using the new constraints?
09:43:17 <Kori> hi everybody!
09:43:58 <parcs`> obk: with ConstraintKinds you can do 'type FooBar a = (Foo a, Bar a)' where Foo and Bar are type classes
09:44:29 <obk> parcs`: Does that also allow me to say "instance FooBar a where ..." ?
09:44:56 <parcs`> nope
09:45:02 <obk> :-(
09:45:12 <neothemachine> hm.... in quickcheck, when I have something like "sample = map (\i -> choose (0,len-i)) [1..len-1]", this is [Gen Int], how do I transform it to [Int]? probably a really stupid question...
09:45:14 <obk> Well, half a solution is better than none...
09:45:21 <obk> Thanks!
09:45:59 <parcs`> obk: what would that buy you anyway? a couple of lines at most?
09:46:47 <mcstar> > foldr (\n acc -> if n < 50 then n + acc else acc) 0 [1..100]
09:46:48 <lambdabot>   1225
09:47:02 <mcstar> > foldr (\n l -> if n < 10 then n : l else []) [] [1..]
09:47:03 <lambdabot>   [1,2,3,4,5,6,7,8,9]
09:47:19 <mm_freak_> obk: is that about your own type classes?
09:47:21 <obk> parcs`: In my case, quite more than that. My code si structured similarly to http://repetae.net/recent/out/classalias.html - that is, I have several small classes with reasonable defaults, and that forces me to have ~4-5 lines of "instance Feature1 A, instance Feature2 A, ..."
09:47:39 <obk> mm_freak_: yes, my own.
09:47:42 <mcstar> foldr plus + doesnt woth with infinite lists, since + is strinct afaik
09:47:53 <mcstar> work*
09:47:55 <mm_freak_> obk: then it's questionable whether you really want type classes at all
09:48:10 <obk> mm_freak_: I'm game, what else is there?
09:48:17 <parcs`> obk: ah, i see. that would be useful.
09:48:30 <mm_freak_> obk: data
09:48:34 * obk tried building "vtable record" instead but that ended up having evem more boilerplate.
09:48:54 <obk> mm_freak_: That didn't end up well...
09:49:16 <obk> It was like writing an interpreter for what is essentially compiled code.
09:49:41 <mm_freak_> obk: perhaps you're misunderstanding…  i'm talking about manual dictionary passing
09:51:03 <obk> mm_freak_: Yes, that's what I did. But since each dictionary entry is a method with a different signature, you need to use a record. And records aren't easily composable, either.
09:52:11 <mm_freak_> obk: consider this:  there are three different ways to implement foldr
09:52:22 <obk> So instead of saying "type Foo a = (Bar a, Baz a)" you need to define "data FooDictionary a = { _fooBar :: BarDictionary a, _fooBaz :: BazDictionary a }". And then initualize the horrible mess.
09:52:36 <mm_freak_> foldr :: (Foldable b a) => [a] -> b
09:52:41 * obk nods
09:52:46 <mm_freak_> foldr :: Fold a b -> [a] -> b
09:52:57 <mm_freak_> foldr :: (a -> b -> b) -> b -> [a] -> b
09:53:03 <obk> Right.
09:53:10 <mm_freak_> right now you're doing the first one
09:53:18 <mm_freak_> i'm suggesting one of the two others
09:53:19 <obk> Pretty much.
09:53:51 <mm_freak_> but anyway, i guess constraint aliases would remove much of the boilerplate with the current version
09:54:23 <obk> Sure. The problem is that if "FeatureA" has, say, 3-4 functions, and FeatureB has another 3-4 functions... and I have ~10 features, and I combine 3-4 of them, the other 2 methods get messy _fast_.
09:54:53 <obk> Well, the 1st one gets semi-messy; with constraints I can avoid half the mess, with proper class aliases I could avoid all of it.
09:55:21 <obk> It is all equivalent as far as expressive power goes, I'm trying to cut down on the boilerplate of the code.
09:55:33 <mm_freak_> i doubt it…  with class aliases you're introducing alternative hierarchies, which then get messy
09:55:55 <mm_freak_> in fact i think that constraint aliases are the proper way to go
09:56:09 <mm_freak_> just that it can be difficult to give them sensible names
09:56:39 <obk> I missed out on the reason class aliases are "bad". Given ConstraintKinds do half of them, I guess that half is OK :-)
09:57:20 <obk> The half that is missing is saying that "instance FooBar a where ..." is the same as "instance Foo a where ..." magically combined with "instance Bar a where ..."
09:57:24 <mm_freak_> if it sounded like that, i'm not saying they are bad…  i'm saying they don't solve your problem ;)
09:57:41 <rwbarton> i don't think they are "bad", just not implemented in ghc :)
09:58:07 <obk> Well, I saw a statement saying that the proposal as it stands has "problems".
09:58:21 <obk> I'm not certain what they are...
09:59:22 <mm_freak_> most class-related proposals have subtle problems, because either they introduce technical difficulties or diverge from their fundamental idea
09:59:50 <obk> http://www.haskell.org/haskellwiki/Superclass_defaults suggested breaking "class aliases" to two parts. One part is implemented by ConstraintKinds, so whatever the problems there, they were handled :-)
10:00:03 <obk> The other part - is there a description of the subtle problems?
10:00:25 <obk> Well, at any rate, since it isn't implemented, I'll have to live with it.
10:00:33 <obk> At least I have half the solution :-)
10:02:11 <ParahSailin> if you mapM to a state monad, what state does the function act on?
10:02:14 <nand`> that article on the yoneda lemma is neat
10:02:41 <nand`> now I'm a step closer to the codensity transformation :)
10:03:29 <nand`> (oh, wrong channel; seems it came from -blah)
10:03:31 <mm_freak_> ParahSailin: the current one?
10:04:01 <Philonous> Somebody should add a warning to Network.Socket that you are not supposed to use the PortNumber constructor but the Num instance
10:04:18 <nand`> if you're not supposed to use it, why is it exported?
10:04:32 <benmachine> nand`: for silly reasons
10:04:48 <benmachine> Network.Socket is a little bit crufty in some ways
10:04:51 <benmachine> it's getting better
10:05:01 <benmachine> I believe it's exported so that Network.BSD can use it
10:05:03 <benmachine> not for clients
10:05:09 <Philonous> nand`:  To make idiots like me waste hours wondering why my ports are not in network byte order
10:05:22 <mm_freak_> ParahSailin: the argument function of mapM can modify the state, so for the next list item it can be different
10:06:11 <ParahSailin> ah, how is that implemented
10:06:13 <nand`> benmachine: that sounds ridiculous; if they wanted to export it so Network.BSD could use it they should have exported a function with a name clearly indicative of its nature in regards to network byte order or w/e
10:06:37 <benmachine> nand`: not saying it isn't ridiculous :)
10:06:55 <mm_freak_> ParahSailin: implement mapM yourself…  that should answer your question
10:07:15 <ParahSailin> sequence . map
10:07:21 <nand`> .:
10:07:22 <benmachine> almost
10:07:22 <nand`> but yeah
10:07:28 <benmachine> mapM f = sequence . map f
10:07:41 <mm_freak_> ParahSailin: no, implement it without the help of monadic combinators
10:07:50 <nand`> or implement sequence
10:07:59 <mm_freak_> mapM f [] = …;  mapM f (x:xs) = …
10:09:26 <ParahSailin> ah ok, so the implementation of sequence is equivalent to the playGame function in http://www.haskell.org/haskellwiki/State_Monad
10:09:28 <benmachine> nand`: from the source:
10:09:29 <benmachine>     -- PortNumber is used non-abstractly in Network.BSD.  ToDo: remove
10:09:29 <benmachine>     -- this use and make the type abstract.
10:09:51 <rwbarton> probably written in 2007
10:09:54 <benmachine> in fairness there's also intToPortNumber and portNumberToInt
10:10:14 <mm_freak_> ParahSailin: don't guess, just do it
10:10:23 <mm_freak_> implement mapM without the help of sequence, or implement sequence
10:10:55 <benmachine> ParahSailin: kind of, yeah
10:11:23 <benmachine> the state is threaded left-to-right through the list
10:13:30 <Philonous> @type foldr (liftM2 (:)) (return [])
10:13:31 <lambdabot> forall a1 (m :: * -> *). (Monad m) => [m a1] -> m [a1]
10:19:39 <tsou> merijn: feels like looking at "1st edition" on the web and "2nd edition" printed, but I'm wondering if it could be the other way around..
10:54:15 <hpaste> quuuux pasted “mysterious behaviour with Rank2Types and type signatures” at http://hpaste.org/75186
10:57:33 <Polarina> quuuux, what do you mean with "doesn't work"?
11:03:13 <Polarina> mm_freak_, what happened to the constant wire?
11:06:08 * hackagebot happstack-yui 7371.5.0 - Utilities for using YUI3 with Happstack.  http://hackage.haskell.org/package/happstack-yui-7371.5.0 (DagOdenhall)
11:10:38 <Philonous> Is there some guidance on when (if at all) to use ioError and when to throw an extensible exception?
11:15:08 <ajax__> ыч
11:15:11 <hpc> Philonous: never and never, respectively
11:15:23 <hpc> you probably want ErrorT
11:16:26 <ajax__> людиииии
11:18:52 <quuuux> sorry, lost connection just as I asked a question. http://hpaste.org/75186 -- what's up with uncommenting the type signature breaking it?
11:21:55 <benmachine> quuuux: what's the error message?
11:22:10 <benmachine> hpc: I think that's silly
11:22:20 <benmachine> ioError is there so you might as well use it
11:22:50 <noviceprogrammer> hello
11:22:52 <noviceprogrammer> if a function is inpure, does that mean it is non-reentrant?
11:22:56 <hpaste> quuuux annotated “mysterious behaviour with Rank2Types and type signatures” with “mysterious behaviour with Rank2Types and type signatures (annotation)” at http://hpaste.org/75186#a75187
11:23:06 <quuuux> benmachine: ^
11:23:37 <benmachine> quuuux: iiinteresting
11:24:00 <benmachine> noviceprogrammer: not necessarily, but a non-reentrant function is impure, I think
11:24:06 <mcstar> not necessarily
11:24:06 <noviceprogrammer> right
11:25:00 <benmachine> quuuux: it's odd that it works without hte type annotation
11:25:25 <quuuux> benmachine: that's what's really confusing me. I could write it off as extension weirdness if it didn't work without
11:25:35 <benmachine> quuuux: did you mean that if you do it without the annotation and then use -fwarn-missing-signatures or :t
11:25:41 <benmachine> that's what you can?
11:25:58 <quuuux> benmachine: :t at the prompt. Let me check with the warning
11:26:22 <quuuux> benmachine: yes, same inferred type
11:26:27 <benmachine> ho hum.
11:26:32 <benmachine> what GHC version?
11:26:38 <quuuux> 7.4.1
11:28:25 <benmachine> quuuux: I see the same behaviour with 7.6.1
11:28:53 <benmachine> I don't know enough about RankNTypes to tell you exactly what is going on
11:28:53 <quuuux> how odd
11:29:12 <benmachine> oh hey wait
11:29:18 <benmachine> I'm getting
11:29:24 <benmachine>     Couldn't match expected type `forall r. RealFrac r => r -> String'
11:29:25 <benmachine>                 with actual type `Double -> String'
11:29:33 <quuuux> try with -fwarn-defaults?
11:29:58 <dolio> I have an idea of what's going on.
11:30:00 <benmachine> unrecognised flag
11:30:28 <quuuux> benmachine: oops, -fwarn-type-defaults
11:30:34 <quuuux> I can never remember those warning flag names
11:31:04 <benmachine> quuuux: in that case I get a defaulting warning but only if the typesig is there
11:31:23 <dolio> Without the signature, val has type alpha, 'Just val' has type 'Maybe alpha', and then when you map Foo on it, you get alpha ~ (forall r. (RealFrac r) => r -> String).
11:31:52 <dolio> With the signature, val has type (forall r. (RealFrac r) => r -> String).
11:32:25 <dolio> Then 'Just val' has a type like (RealFrac beta) => Maybe (beta -> String)
11:33:01 <dolio> Then you try to map, and it tries to unify (beta -> String) with (forall r. (RealFrac r) => r -> String).
11:33:20 <dolio> And that fails. There's nothing you can unify with beta to make that match.
11:34:45 <jesyspa> I'd like to test a function where there is no easy inverse relationship between input and output (an interpreter).  Is QuickCheck still suitable for this, or should I try HUnit?
11:34:50 <benmachine> dolio: it's still a bug, though, right?
11:35:19 <benmachine> jesyspa: what do you mean, inverse relationship?
11:35:32 <dolio> benmachine: Probably more like a flaw in the inference/checking algorithm.
11:35:44 <benmachine> dolio: surely a flaw is a bug :P
11:35:45 <quuuux> might not strictly be a bug, just a really unhelpful error message
11:35:49 <dolio> In which case it wouldn't be fixed.
11:35:59 <dolio> No, I mean, fundamental to the approach.
11:36:04 <benmachine> dolio: I mean, it should not be the case that adding a correct type signature to a program causes it to fail to compile
11:36:39 <astry_> hi
11:36:44 <astry_> i have a fairly serious question
11:36:56 <ddarius> benmachine: That's trivial to do.
11:37:00 <jesyspa> benmachine: As far as I can tell, QuickCheck works by you specifying that for every given input, you expect certain properties about the output.  My function doesn't seem to have all that many such properties beyond what is already coded in the main program.
11:37:07 <dolio> benmachine: I'm not saying don't report it. I'm just saying, don't be surprised if nothing can be done.
11:37:08 <jesyspa> Hm, it's a direct relationship, not an inverse one.
11:37:23 <benmachine> ddarius: go on
11:37:31 <ddarius> (id :: Int -> Int) True
11:37:33 <jesyspa> benmachine: I'd rather be able to write some specific examples and then check them for correctness compared to what I get by executing them by hand.
11:37:42 <benmachine> ddarius: that isn't correct
11:38:02 <benmachine> jesyspa: I've never used HUnit, but it sounds reasonable
11:38:06 <ddarius> Though, more interestingly with polymorphic recursion you get more subtlety.
11:38:34 <astry_> i have a program written in python which i use for managing linux servers. i would like to start selling server instances to other people, who would have root access to servers it's installed on. i have considered using haskell, because it's a compiled language, and converting the program to haskell. this is so that other people don't get the source code. is this a feasible way to go? i don't care about people making copies (can't be prevented) b
11:38:37 <jesyspa> benmachine: Does what I described sound like a reasonable assessment of QuickCheck?  I want to make sure I'm not skipping it over due to some misunderstanding.
11:38:48 <benmachine> jesyspa: yes, it sounds reasonable to me
11:38:56 <Botje> astry_: the correct way of hiding source code from people is lawyers.
11:39:00 <jesyspa> Alright, thanks. :)
11:39:11 <nand`> the correct way of hiding source code from people is not at all
11:39:24 <astry_> Botje: i think you're answering a question i haven't asked
11:39:36 <benmachine> astry_: the end of your message got cut off, (can't be prevented) b
11:39:39 <Botje> astry_: well, you got cut off after 'can't be prevented'
11:39:51 <nand`> Botje: if the intent is security through obscurity, lawyers won't help for that
11:40:00 <astry_> benmachine: but i want people not to be able to modify the programs, make upgrades, etc
11:40:00 <quuuux> astry_: decompilation is always possible
11:40:00 <Ralith> also, it's stupid.
11:40:21 <astry_> guys
11:40:36 <astry_> it's fairly important that i get informed answers
11:40:50 <astry_> so can we please skip all the "security through obscurity" etc bullshit
11:40:56 <Ralith> it's unfortunate that you won't accept them
11:41:02 <mcstar> it is possible to rewrite the python code in haskell, yes
11:41:10 <benmachine> okay, there's no need for you guys to start an argument about this >_>
11:41:22 <benmachine> astry_: it's never been a design goal of Haskell to be difficult to reverse-enginner
11:41:25 <benmachine> *engineer
11:41:26 <astry_> mcstar: is it possible to redistribute versions of the program that are compiled or partway compiled?
11:41:39 <benmachine> astry_: you may find that e.g. interface files contain your code, for inlining purposes
11:41:42 <astry_> benmachine: i realize, but i don't think there are that many people who would know how to do that.
11:41:50 <nand`> astry_: trivially true; you can distribute a version that is compiled into Haskell
11:41:53 <mcstar> types can leak info
11:42:08 <benmachine> nand`: don't be silly :P
11:42:11 <mcstar> but ofc you can distribute binaries
11:42:14 <quuuux> dolio: I think your theory is correct
11:42:34 <benmachine> astry_: Haskell relies more on cross-module inlining than many languages, so it's more common for binaries to contain code, I think
11:42:37 <hpaste> quuuux annotated “mysterious behaviour with Rank2Types and type signatures” with “mysterious behaviour with Rank2Types and type signatures (annotation) (annotation)” at http://hpaste.org/75186#a75188
11:42:48 <quuuux> dolio: see mkFoo3 ^
11:42:53 <benmachine> astry_: I would at least see what ghc --show-iface has to say about oyour .hi files
11:43:00 <nand`> benmachine: but does that count for (statically linked) executable binaries? I mean, it's not like you're going to be compiling anything else against them
11:43:05 <astry_> benmachine: but if this binary is not a library itself, just an executable?
11:43:06 <nand`> so there's no point for them to store code anymore
11:43:09 <benmachine> oh
11:43:10 <benmachine> shrug
11:43:11 <dolio> quuuux: Yep.
11:43:12 <quuuux> oh, whoops, that also requires ImpredicativeTypes
11:43:14 <benmachine> I don't know
11:43:16 <nand`> Haskell code, that is
11:43:17 <quuuux> anyway, same difference
11:43:18 <astry_> benmachine: i'll check that out
11:43:35 * quuuux is an incompetent paste editor
11:43:35 <mcstar> i think you should use an authentication server with the product
11:43:44 <astry_> how can i build a binary on one linux machine so that it runs on another?
11:43:49 <mcstar> like, direct connection is required to run it
11:44:06 <astry_> is there anything special required for me to do this?
11:44:19 <quuuux> I wonder if it's possible to give useful warnings about things like mkFoo2
11:44:24 <benmachine> astry_: I've had problems in the past with different versions of libgmp
11:44:54 <astry_> benmachine: oh, so it's basically matching the same linux lib package versions?
11:44:55 <benmachine> quuuux: my hypothesis is that mkFoo2 is not supposed to compile, because Just val has an impredicative type
11:44:55 <quuuux> anyway, I'll file a bug against GHC and see if anything can't be done
11:45:01 <benmachine> but I won't pretend to be an expert
11:45:27 <benmachine> astry_: I've never had any other problems, but I don't promise there aren't any others :)
11:46:28 <astry_> well, to think of it the only external stuff this program would be using is rabbitmq, sqlite, and some shell execution / subprocess wrappers
11:46:57 <benmachine> astry_: Haskell executables are usually pretty distributable because they're not dynamically linked by default
11:47:08 <benmachine> (you can make them so, but I generally don't bother)
11:47:21 <benmachine> 'cept when I'm pressed for disk space
11:47:36 <astry_> right, i was fairly certain that ghc links statically
11:47:52 <geekosaur> astry_, .hi files often have source code embedded in them (cross-module inlining).  Haskell is not intended to try to solve a legal problem with technical nonsolutions so there is no reliable way to turn the feature off (disabling optimization *might* work
11:48:30 <astry_> geekosaur: why do i need .hi files?
11:48:34 <benmachine> geekosaur: I already mentioned that, keep up :P
11:48:40 <geekosaur> they are part of library linkage
11:48:43 <mcstar> it wont be a lib afaik
11:48:52 <astry_> geekosaur: but once i've got the final compiled binary i'm ok, right?
11:49:03 <astry_> as in, there are no .hi files required
11:49:19 <mcstar> no you dont
11:49:21 <geekosaur> a .o file is not sufficient, unless you only write C or something that constrains itself to C's limited linkage (such as C++ which uses symbol mangling to pretend it has real types)
11:49:33 <geekosaur> compiled binary might be okay, nobody promises
11:49:39 <geekosaur> and nobody is going to promise
11:49:58 <astry_> geekosaur: yeah, i didn't expect promises, i just wanted to know if it's relatively simple to reverse-engineer it all
11:50:15 <geekosaur> you've already been answered there
11:50:19 <astry_> yeah
11:50:30 <astry_> as long as there are no glaring obvious ways to do it i think i'll be good to go
11:50:36 <geekosaur> ...
11:50:46 <geekosaur> whatever.  go pretend you're safe
11:50:51 <nand`> I wonder how easy it is to systematically go from GHC's x86_64 output to cmm to STG
11:50:54 <mcstar> sell it cheap it enough, to discourage reverse engineers
11:51:03 <astry_> mcstar: that's exactly the point..
11:51:26 <astry_> finding a specialist to reverse-engineer the software would cost orders of magnitude more than just buying it
11:51:58 <astry_> if you blow things out of proportion there's no security in anything at all
11:52:14 <mcstar> do you really think you can leverage some algorithm, or whatever that nobody has thought of?
11:53:16 <astry_> but relatively it doesn't matter if someone can spend 20 years flipping stones to reverse-engineer whatever i'm making.. i just don't want it to happen in less than 5 days
11:53:28 <astry_> mcstar: are you asking if what i'm making is innovative?
11:53:30 <astry_> hell no
11:53:42 <mcstar> then i dont understand
11:53:47 <astry_> it's there and it does something that fulfills someone's need and he's willing to pay for it
11:54:09 <geekosaur> astry-, people here have experience, if you insist you don't want to hear the truth then people will just tell you the lie that's all you want to hear because it's not worth the effort
11:54:18 <mcstar> if your only advantage came from a single innovation that nobody else had in the market, id understand that you would feel uncomfortable aobu tdistributing it
11:54:22 <mcstar> bot otherwise...
11:54:25 <mcstar> but
11:54:32 <astry_> geekosaur: if you want to spend 20 years reverse-engineering my computer program you are welcome to do it
11:54:35 <astry_> in fact
11:54:36 <astry_> i'd be honored
11:54:50 <geekosaur> (point goes flying overhead...)
11:55:01 <geekosaur> never mind, you proved my point admirably
11:55:15 <astry_> geekosaur: i'm glad i've given you the chance to feel superior
11:55:28 <astry_> geekosaur: i hope the rest of your day is likewise entertaining
11:56:07 <mcstar> reverse enginnering that stuff might be harder than just sitting down and solving the problem from scratch
11:56:19 <nand`> and then open sourcing the solution
11:56:25 <mcstar> nobody would bother with that, even if you had sold you program at a high price
11:56:30 <astry_> who said i won't open-source the solution?
11:56:42 <astry_> i just don't want the people i send it to to have a way of getting it without paying
11:57:09 <mcstar> you said, they will be able to freely copy it
11:57:14 <mcstar> since you cant do anything against that..
11:57:17 <mcstar> so what now?
11:57:27 <benmachine> guys, I don't think we're talking about Haskell at this point
11:57:27 <nand`> the solution was given
11:57:29 <nand`> lawyers
11:57:46 <benmachine> if astry_ is using unwise business practices or whatever, that's frankly their problem
11:57:48 <mcstar> blah?
11:58:02 <nand`> mcstar: not worth taking it there, better to just cut it off at this line
11:58:25 <astry_> "i don't like a conversation therefore i want others to not like it either"
11:58:53 <astry_> nand`: ever heard of... "live and let live"?
11:59:05 <astry_> might help you down the road :)
11:59:23 <nand`> mcstar: did you do anything interesting with the samples I sent you the other day?
11:59:45 <YayMe> I really did not expect emacs choords to leak into my muscle memory this quickly, I find myself wanting to hit C-x before C-anything at work now.
12:00:26 <YayMe> chords? I think I just bastardized chords and coord(inate)s
12:00:51 <quuuux> YayMe: that's an excellent neologism. Be proud of yourself!
12:01:06 <astry_> either way, there's nothing stopping me from opensourcing this stuff, since i can't possibly imagine pointy haired web developers figuring out there's something called "hackage"
12:01:20 <mcstar> nand`: as i understand, compressed sensing needs data sampled at a very uncorrelated manner wrt the features in the data being sampled, that mask might be too regular, idk
12:01:40 <nand`> mcstar: oh, hrm
12:01:41 <benmachine> astry_: remember that thing about live and let live? maybe start with not justifying yourself to us
12:01:47 <benmachine> astry_: we don't need it and you don't need it
12:01:56 <nand`> mcstar: do you think it would be interesting to semi-randomly generate a whole-image mask?
12:02:16 <mcstar> nand`: i tried some sample code from a blog, that meant to really surprise the reader with the result, but turned out, it doesnt work as it was advertised to do, im a bit disapointed
12:02:18 <nand`> it just needs to, on average, cover about 30% of the pixels; and obscure the rest
12:02:40 <astry_> benmachine: i'm not sure what to make of your comment. why do you think i'm justifying myself to anyone? and, why do you think that's bad?
12:02:49 <mcstar> yeah, random sampling would be preferable
12:03:16 <mcstar> nand`: i plan to look into this further, but i have other more important activities
12:03:18 <nand`> random sampling would get rid of any mosaicing artifacts arising from interference with other patterns as well
12:03:26 <mcstar> when i have some result ill let you know :)
12:03:32 <nand`> sure, no problem
12:03:59 <benmachine> astry_: I think you talking to us about whether or not you are going to opensourceyour whatever is not productive that's all
12:04:18 <benmachine> astry_: but arguing with you about it is even less productive, so feel free to ignore me :P
12:04:29 <astry_> since when is #haskell trying to be productive?
12:05:05 <astry_> in the years i've been here that's never been listed as a virtue, that's a first :)
12:06:01 <nand`> mcstar: I'm thinking this may be interesting for camera CCDs, which use filter patterns like the one I showed to distinguish between red, green and blue pixels - it could be interesting to put a semi-random (but known) filter over the whole 10+ megapixel CCD and then use compressed sensing to reconstruct the individual color images
12:06:09 * hackagebot hedis-tags 0.2.3 - Tags for hedis  http://hackage.haskell.org/package/hedis-tags-0.2.3 (AlexanderDorofeev)
12:06:24 <mcstar> nand`: that has already been done
12:06:35 <nand`> mcstar: ooh, link?
12:06:36 <mcstar> nand`: they even made 1-pixel cameras
12:06:45 <mcstar> lets go over to blah
12:11:09 * hackagebot hedis-pile 0.6.3 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.6.3 (AlexanderDorofeev)
12:13:21 <ddarius> mcstar, nand`: What are you guys talking about?  A brief sentence or a link/keywords would be preferable.
12:15:38 <mcstar> ddarius: http://en.wikipedia.org/wiki/Compressed_sensing
12:15:49 <ddarius> Thanks.
12:15:53 <mcstar> pls google a more colorful article to appreciate it :)
12:17:12 <theorbtwo> ?seen inigo_
12:17:12 <lambdabot> Unknown command, try @list
12:18:04 <ddarius> mcstar: I did go to the single-pixel camera link in the article.  It reminds me vaguely, of the femto second camera.
12:18:50 <theorbtwo> Hmmpf.  @list links to http://code.haskell.org/lambdabot/COMMANDS which suggests seen exists, but neither seen inigo_, ?seen inigo_, or @seen inigo_ work.
12:19:08 <shachaf> Yes, it's gone.
12:19:12 <ddarius> mcstar: But this sounds interesting even from the Wikipedia article, and I'm on a DSP kick right now, and this may actually be directly "useful" to me.
12:19:31 <mcstar> ddarius: great, dsp away!
12:19:49 <theorbtwo> shachaf: Whee, always love it when documentation doesn't match reality.
12:20:03 <Dirrk> Is there a library to access i386 I/O ports (or iomem, if you want) for Haskell on Linux?
12:20:15 <ddarius> theorbtwo: Documentation never matches reality.
12:20:44 <ddarius> Dirrk: In the worst-case, you can just FFI bind to the relevant system calls.
12:21:09 * hackagebot wai-middleware-route 0.7.3 - Wai dispatch middleware  http://hackage.haskell.org/package/wai-middleware-route-0.7.3 (AlexanderDorofeev)
12:21:33 <astry_> nand`: the filters and optical sensors in cameras are very uneven, better cameras auto-calibrate each photo by taking another photo in succession with the shutter closed
12:21:52 <astry_> nand`: that might be enough to create a pattern like what you're looking for
12:26:11 * hackagebot wai-middleware-catch 0.3.5 - Wai error catching middleware  http://hackage.haskell.org/package/wai-middleware-catch-0.3.5 (AlexanderDorofeev)
12:27:47 <YayMe> Monad m => [a] -> (a -> m b) -> m ()
12:27:54 <YayMe> I can read that fine until I get to the last bit
12:28:07 <YayMe> what is () in a type sig?
12:28:12 <mcstar> unit
12:28:12 <YayMe> like unit in ml?
12:28:16 <Polarina> YayMe, an empty tuple.
12:28:27 <YayMe> I didn't know that was a thing in haskell
12:28:31 <zomg> Hm didn't someone here say they had Ubuntu 12.04?
12:28:40 <ddarius> @src ()
12:28:40 <lambdabot> data () = ()
12:28:42 <YayMe> I guess that's why it's forM_, the _ means throw away result eh?
12:28:45 <ddarius> :t ()
12:28:46 <lambdabot> ()
12:28:52 <mcstar> YayMe: yes
12:28:56 <ddarius> YayMe: Often that suffix has that meaning.
12:29:02 <YayMe> makes sense
12:29:09 <YayMe> thanks, carry on
12:29:16 * mcstar would like unit to be 1 character
12:29:30 <ddarius> data U = U
12:29:31 <mcstar> like _
12:29:34 <nand`> 1
12:29:38 <nand`> oh wait, that's taken :(
12:29:41 <ddarius> :k 1
12:29:42 <lambdabot> *
12:29:42 <mcstar> haha
12:29:51 <nand`> (on both the type and the value level, now)
12:29:53 <quuuux> there's probably a unicode character for that
12:30:03 <nand`> ⊤
12:30:06 <nand`> oh no
12:30:07 <quuuux> widely used in Japanese SMSes but completely unknown in the west
12:30:10 <mcstar> that doesnt help with typing it
12:30:26 <YayMe> it does in japan heh
12:30:28 <ddarius> 1 has been taken at the type level, given certain extensions, for quite a while.
12:30:37 <astry_> zomg: i didn't say that, but i have it
12:30:42 <astry_> zomg: need any help?
12:30:47 <Dirrk> ddarius: Yes, but I thought I could save myself some work.
12:31:05 <ddarius> @google site:hackage.haskell.org iomem
12:31:06 <lambdabot> No Result Found.
12:31:10 * hackagebot wai-middleware-cache-redis 0.4.3 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.4.3 (AlexanderDorofeev)
12:31:35 <zomg> astry_: I'm encountering an odd segfault on my vps with Ubuntu 12.04 and am pretty much out of ideas. I have a short application which causes it on mine, would you mind checking if it does the same on yours?
12:31:55 <ddarius> Dirrk: I suspect the procedures you'd need to bind are few and relatively simple, so it shouldn't be too bad.
12:31:55 <astry_> zomg: ok
12:32:06 <zomg> I'll pm your a link to the sources
12:32:48 <Dirrk> ddarius: Yeah, but I need to work through the FFI stuff first. Any good example files somewhere I could copy and modify?
12:33:03 <quuuux> oh, that's handy. I thought the thing with Rank2Types I was talking about earlier was completely irrelevant to the bug I was trying to solve (hurrah for yak shaving), but exactly the same solution applies
12:33:09 <mcstar> i got stuck at the 'reentrant' wiki page
12:33:12 <astry_> zomg: ok
12:33:15 <mcstar> when i read about FFI from RWH
12:33:24 <ddarius> Dirrk: I'd recommend just reading the FFI spec.  It's quite readable and quite usable directly.
12:33:33 <Dirrk> Right, I'll do that. Thx.
12:34:29 <knrafto> is there a concise way to write a function (a -> IO (Maybe b)) -> Maybe a -> IO (Maybe b) ?
12:35:06 <mcstar> reading RWH on the subject felt like, when your dad is handling you a rifle, and saying "son, try not to shoot yourself in the leg"
12:36:14 <ddarius> mcstar: If that entertains you, you may find this entire chapter from the Scala book entertaining: http://www.artima.com/pins1ed/object-equality.html
12:36:22 <quuuux> :t maybe . return
12:36:22 <Botje> knrafto: sounds like you just want the 'maybe' function?
12:36:23 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => a1 -> (a -> m a1) -> Maybe a -> m a1
12:36:27 <quuuux> knrafto: ^
12:36:51 <ddarius> quuuux: Not right.
12:36:59 <ddarius> Er, maybe I misread.
12:37:08 <quuuux> well, no, but my function isn't partial
12:37:26 <quuuux> wait, no, I am wrong anyway
12:38:04 <knrafto> :t maybe
12:38:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:38:28 <ddarius> I think it's traverse though.
12:38:28 <knrafto> :t maybe (return Nothing)
12:38:29 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (Maybe a)) -> Maybe a1 -> m (Maybe a)
12:38:29 <ddarius> :t traverse
12:38:30 <lambdabot> Not in scope: `traverse'
12:38:36 <knrafto> there we go
12:38:40 <ddarius> :t Data.Traversable.traverse
12:38:41 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:38:56 <ddarius> Almost.
12:39:35 <ddarius> I suspect it can be done with some function in Data.Traversable or very easily in terms on one of those functions.
12:40:08 <knrafto> i think i'll go with maybe (return Nothing). it's concise enough and readable
12:40:32 <drunK> :t maybe (return Nothing)
12:40:34 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (Maybe a)) -> Maybe a1 -> m (Maybe a)
12:40:53 <knrafto> thanks everybody
12:41:32 <inigo_> theorbtwo: but I exist!
12:42:15 <theorbtwo> inigo_: See #sl4a, please?
12:43:45 <inigo_> theorbtwo: ok
12:46:10 * hackagebot alsa-seq 0.6.0.2 - Binding to the ALSA Library API (MIDI sequencer).  http://hackage.haskell.org/package/alsa-seq-0.6.0.2 (HenningThielemann)
12:47:39 --- mode: ChanServ set +o copumpkin
12:48:08 --- mode: copumpkin set -b *!*@213.151.77.75
12:48:10 --- mode: copumpkin set -o copumpkin
12:49:24 <teneen> Why does this expression "let (x,y,1) = f x y where f x y = (y,1,x)" not bind x and y to 1?
12:52:02 <ddarius> > let (x,y,1) = f x y where f x y = (y,1,x) in (x,y)
12:52:06 <lambdabot>   mueval-core: Time limit exceeded
12:52:23 <ddarius> > let (x,y,1) = f x y where f x y = (y,1,x) in y
12:52:26 <lambdabot>   mueval-core: Time limit exceeded
12:52:57 <rwbarton> it needs to know the third component of f x y is 1 "before" it can bind x and y to y and 1 respectively
12:53:02 <rwbarton> informally speaking
12:53:11 <rwbarton> > let (x,y,~1) = f x y where f x y = (y,1,x) in (x,y)
12:53:12 <lambdabot>   (1,1)
12:54:12 <rwbarton> > let (x,y,_) = f x y where f x y = (y,1,x) in (x,y)
12:54:13 <lambdabot>   (1,1)
12:54:46 <teneen> rwbarton: Amazing! thanks
12:55:45 <rwbarton> > fix $ \z -> case z of ~(x,y,1) -> (y,1,x)
12:55:48 <lambdabot>   mueval-core: Time limit exceeded
12:57:17 <teneen> > fix $ \z -> case z of ~(x,y,~1) -> (y,1,x)
12:57:18 <lambdabot>   (1,1,1)
12:57:55 <ddarius> The outer irrefutable pattern is unnecessary.
12:58:26 <teneen> > fix $ \z -> case z of (x,y,~1) -> (y,1,x)
12:58:30 <lambdabot>   mueval-core: Time limit exceeded
12:58:33 <teneen> it is
12:58:43 <ddarius> Yep.  I was thinking of something else.
12:59:03 <rwbarton> in the let it isn't necessary
12:59:25 <rwbarton> perhaps let-bound patterns could be "recursively lazy"... but they're apparently not
12:59:49 <rwbarton> note that
12:59:55 <rwbarton> > let (x,y,~2) = f x y where f x y = (y,1,x) in (x,y)
12:59:56 <lambdabot>   (1,1)
13:00:06 <rwbarton> the 1 would then be useless (same as _)
13:00:45 <teneen> interesting
13:00:55 <teneen> I think it shouldn't work this way
13:01:07 <ddarius> Yes, let bound patterns are irrefutable, but this doesn't (and shouldn't) propagate into the pattern.
13:01:10 * hackagebot fb 0.12.4.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12.4.1 (FelipeLessa)
13:01:27 <quuuux> rwbarton: it'd be funny if that rebound 2. Like that old story about some scientist who redefined '4' in FORTRAN and wondered why his results were strange
13:03:12 <ddarius> You can say True = False, or 1 = 2 at the top level of a Haskell file.
13:03:52 <Palmik> Hi guys, is playing around with this heterogenous list structure and was wondering whether it's possible to implement the function "dimension" in its current state http://hpaste.org/75193
13:04:00 <cmccann> > let 1 + 1 = 3 in 1 + 1
13:04:01 <lambdabot>   3
13:05:03 <cmccann> Palmik, you probably need a type class for that
13:05:34 <Palmik> Aaah, that might work, thanks! :)
13:05:38 <ddarius> Palmik: Also, I doubt that that list type does what you think it does.
13:06:27 <Palmik> ddarius, ok?
13:07:33 <ddarius> You will not be able to recover information about b at the value level.
13:09:42 <cmccann> why's that? looked equivalent to nested tuples to me
13:09:46 <cmccann> but I only glanced at it
13:10:15 <Palmik> yes, it's implicitly foralled but not discarded :)
13:10:25 <Palmik> thisng like this work http://hpaste.org/75194
13:11:10 * hackagebot couchdb-conduit 0.10.4 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.10.4 (AlexanderDorofeev)
13:20:20 <shapr`> SHAZAM!
13:20:58 <Polarina> Wha?
13:22:08 <shapr`> @quote cultofdone
13:22:08 <lambdabot> cultofdone says: 10. Failure counts as done. So do mistakes.
13:22:11 <shapr`> @quote cultofdone
13:22:11 <lambdabot> cultofdone says: 8. Laught at perfection. It's boring and keeps you from being done.
13:22:13 <shapr`> @quote cultofdone
13:22:13 <lambdabot> cultofdone says: 6. The point of being done is not to finish but to get other things done.
13:22:18 <shapr`> ok, back to Prolog...
13:27:06 <deech> Are there any tutorial on calling Agda from Haskell and vice versa?
13:30:12 <ocharles> shachaf: got my flights to ca!
13:30:17 <ocharles> don't be changing the ba haskell date, yo
14:01:18 <madjestic__> hey guys, I was pondering about something that may seem like a no-brainer, but I realized that I can't find a clear answer on this subject
14:01:19 <tdammers> anyone know how I can do a parametric IN (?) with hdbc? Can I even?
14:04:39 <madjestic__> the question is:  how do you use help?  Way, you are importing a module, e.g. Graphics.Gloss.  Naturally you want some information on that.  What would be the next natural step for that?  Hoogle?  Browsing the module in leksah browser?  Browsing through ghci :browse?
14:06:15 <tdammers> madjestic__: the package's haddock, maybe? Most packages have decent documentation on hackage...
14:06:58 <rwbarton> i usually use hoogle (via browser search keyword) to look up the module name and it gives a link to the documentation on hackage
14:07:25 <benmachine> yeah, I use hackage
14:07:27 <tdammers> I do the same, but with hayoo
14:07:40 <benmachine> I tend to find out which package by more boring means, like ghc-pkg find-modules
14:07:46 <benmachine> er, find-module
14:07:49 <benmachine> or just, knowing :p
14:10:49 <madjestic__> benmachine, thanks for sharing
14:11:39 <benmachine> ghc-pkg find-module Graphics.Gloss gives you a package name, and then you go open hackage.haskell.org/package/name in firefox
14:12:41 <Puffton> is the terminal command "ghc -o t4 t4.hs" the same as "ghc --make t4"?
14:13:14 <geekosaur> iwith modern ghc, yes.  with older, --make is not the default and you would have to list packages explicitly (or use --make)
14:15:20 <Puffton> ok, cool
14:21:10 <madjestic__> benmachine, does not haskell come with a pre-installed documentation?  How do you use it, if it does?
14:21:42 <madjestic__> say, something analogous to hackage, but local copy of it
14:26:37 <benmachine> madjestic__: you can configure cabal to build docs for your libraries, I forget if it does that by default
14:27:01 <benmachine> madjestic__: but for tedious reasons they don't compile with --hyperlink-source, so I go ahead and use hackage anyway
14:27:45 <madjestic__> right
14:28:56 <madjestic__> I just wanted to make sure that I am not missing something obvious (like local help files), by going straight to on-line sources
14:33:24 <benmachine> madjestic__: I have docs in ~/.cabal/share/doc/html
14:33:41 <benmachine> but the hackage docs are just a bit bietter
14:33:42 <benmachine> they're certainly more complete :)
14:36:12 * hackagebot repa-devil 0.3.2.1 - Support for image reading and writing of Repa arrays using in-place FFI calls  http://hackage.haskell.org/package/repa-devil-0.3.2.1 (RaphaelJavaux)
14:39:41 <ew0> yo, the task of today is doing a ondisk cache of a function
14:40:14 <ew0> I'll sha256 the parameters and i'll have a map in the disk with the return value
14:46:45 <ew0> http://www.yesodweb.com/book/persistent looks great
14:51:30 <hpaste> keep_learning pasted “defining function in main” at http://hpaste.org/75202
14:51:51 <keep_learning> Hello All.
14:52:02 <Puffton> Hello dear sir
14:52:08 <maukd> greetings, fleshy one
14:52:44 <keep_learning> I am curious about this behaviour.
14:53:43 <maukd> > foo + (let foo = 2 in 3)
14:53:44 <lambdabot>   Overlapping instances for GHC.Show.Show
14:53:44 <lambdabot>                              ((a ->...
14:53:45 <keep_learning> Why putting loop on top of definition giving compiler error. Is GHC is not able to see the function definition below.
14:53:59 <mcstar> keep_learning: let /= where
14:54:01 <maukd> > foo
14:54:02 <lambdabot>   Overlapping instances for GHC.Show.Show
14:54:02 <lambdabot>                              ((a ->...
14:54:06 <maukd> @undefine
14:54:12 <hiptobecubic> does anyone have an interesting example using fix?
14:54:17 <maukd> > foo + (let foo = 2 in 3)
14:54:18 <lambdabot>   Not in scope: `foo'
14:54:22 <maukd> there we go
14:54:54 <maukd> > (let foo = 2 in foo) + 3
14:54:55 <lambdabot>   5
14:54:59 <keep_learning> mcstar, Thank you!
14:55:33 <mcstar> keep_learning: let makes the binding you introduced applicable, in the body of the let, i.e. what follows after 'in', in a 'do' block, the binding is visible after 'let' simply
14:55:36 <maukd> > fix ((1 :) . (2 *))
14:55:37 <lambdabot>   No instance for (GHC.Num.Num [t])
14:55:37 <lambdabot>    arising from a use of `e_112' at <inte...
14:55:42 <maukd> > fix ((1 :) . map (2 *))
14:55:44 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
14:56:10 <latro`a> I've always found that one easier to think about from the fixed point perspective rather than the operational perspective
14:56:31 <keep_learning> mcstar, I was somehow assuming let and where same.
14:56:32 <latro`a> "what list is such that if you double all its elements and put 1 in front, you get the same list"
14:56:34 <hiptobecubic> maukd, interesting. I was trying to come up with anything that worked and had nothing
14:56:40 <maukd> > fix (\self n -> if n < 2 then 1 else n * self (n - 1)) 5
14:56:41 <lambdabot>   120
14:57:04 <hiptobecubic> crazy talk
14:57:10 <yitz> > let f g 1 = 1; f g n = n * g (n - 1); fact = fix f in map fact [1..] -- hiptobecubic
14:57:11 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
14:57:17 <hiptobecubic> @src fix
14:57:17 <lambdabot> fix f = let x = f x in x
14:57:19 <maukd> > fix error
14:57:20 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:57:24 <latro`a> lool
14:57:37 <maukd> best use of fix
14:57:40 <hiptobecubic> yes
14:57:57 <yitz> > fix show -- maukd, much better use
14:57:58 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:58:07 <latro`a> oh dear
14:58:28 <Iceland_jack> Oh great, another fix playground
14:58:42 <hiptobecubic> i'm still having trouble with how it works
14:58:46 <hiptobecubic> i see what it *does*
14:58:53 <hiptobecubic> let x = f x in x ?
14:58:55 <yitz> hiptobecubic: my fact example above is the "real" way to use it.
14:59:08 <maukd> @yhjulwwiefzojcbxybbruweejw
14:59:09 <lambdabot> Exception: <<loop>>
14:59:15 <maukd> @yhjulwwiefzojcbxybbruweejw
14:59:15 <lambdabot> "\""
14:59:18 <Iceland_jack> hiptobecubic: have you searched for "haskell fix"?
14:59:29 <maukd> yitz: what about my fact example?
14:59:31 <sipa> hiptobecubic: fix f is really just f (f (f (...)))
14:59:38 <lispy> I started putting Data.StateVar back into the OpenGL namespace, but that's so yucky. OpenAL uses it too.  So Graphics.Rendering.OpenGL.StateVar is all kinds of terrible.
14:59:40 <maukd> sipa: not really
14:59:47 <maukd> it's cyclic, not infinite
14:59:48 <hiptobecubic> maukd, no?
14:59:57 <hiptobecubic> maukd, can you elaborate?
15:00:00 <yitz> maukd: ?
15:00:14 <lispy> Khronos.IntResource.StateVar would be more fitting.
15:00:17 <hiptobecubic> i was under the impression that it was just f(f(f(f(f...
15:00:18 <mcstar> defined with a 'let' and that makes a difference
15:00:22 <mcstar> apparently
15:00:24 <maukd> fix (1 :) is finite in memory
15:00:29 <maukd> it points back to itself
15:00:45 <sipa> of course
15:01:05 <sipa> but semantically the two expressions are identical
15:02:23 <sipa> well, not really as infinitely-sized expressions don't exist and thus don't have semantics
15:02:31 <sipa> but you get the point
15:03:17 <hiptobecubic> maukd, in your fact example why is self the first arg?
15:03:27 <hiptobecubic> and how did the 5 get 'in'
15:03:40 <maukd> every function takes exactly one argument
15:03:56 <maukd> fix takes a function and calls it with its own result
15:04:02 <maukd> (a minor case of time travel)
15:04:19 <maukd> fix (\self -> (\n -> ...))
15:04:35 <maukd> the result of \self -> (\n -> ...) is another function (of n)
15:04:46 <maukd> which is what fix passes in, binding it to self
15:05:04 <maukd> the (\n -> ...) thing is applied to 5
15:05:04 <hiptobecubic> i see it now
15:05:29 * mcstar wonders who will mop up the place from all the exploded brain matter
15:05:30 <hiptobecubic> well i see the currying anyway
15:06:01 <hiptobecubic> i don't see how substituting this function in again for self gets us any closer to 120
15:07:03 <yitz> hiptobecubic: it's just ordinary recursion in disguise, really. if the edge condition is met, return the result. otherwise, apply the function again.
15:07:10 <maukd> the (\n -> ...) thing is applied to 5
15:07:23 <maukd> if 5 < 2 then 1 else 5 * self (5 - 1)
15:07:34 <maukd> 5 * self (5 - 1)
15:07:49 <hiptobecubic> aha
15:08:02 <maukd> 5 * (\n -> if n < 2 then 1 else n * self (n - 1)) (5 - 1)
15:08:15 <maukd> 5 * (if 4 < 2 then 1 else 4 * self (4 - 1))
15:08:25 <hiptobecubic> so we are counting down from 5, using a particular case to stop us when we're ready?
15:09:09 <maukd> 5 * (4 * (3 * (2 * (if 1 < 2 then 1 else 1 * self (1 - 1)))))
15:09:15 <ew0> hey, is there a quick way to check which packages are installed by cabal?
15:09:17 <maukd> 5 * (4 * (3 * (2 * 1)))
15:09:29 <yitz> ew0: ghc-pkg
15:09:30 <mcstar> ghc-pkg list
15:09:43 <ew0> thakns
15:09:56 <yitz> ew0 --global or --local are useful
15:10:20 <ew0> thanks, it worked fine
15:10:32 <hiptobecubic> maukd, of
15:10:34 <hiptobecubic> oh*
15:10:44 <hiptobecubic> Well that's clear enough, i wasn't really looking at it that way
15:10:58 <hiptobecubic> maukd, but you said it doesn't blow the stack? How is that possible
15:11:03 <maukd> fix is the essence of recursion
15:11:22 <maukd> every recursive definition can be rewritten in terms of fix
15:11:35 <maukd> wait, what stack?
15:12:51 <hiptobecubic> the call stack?
15:12:55 <ew0> is there a better solution in haskell instead of a makefile with a lot of cabal install X ?
15:13:01 <ew0> to install deps?
15:13:10 <hiptobecubic> am I in outer space? Does this make any sense?
15:13:32 <dcoutts> ew0: you mean like installing a bunch of local packages in one go?
15:13:45 <ew0> yeah
15:13:47 <ew0> for deploying
15:14:00 <ew0> someting like a Gemfile for ruby
15:14:05 <hiptobecubic> if the deps are listed in the cabal file it should be able to get them itself no?
15:14:06 <yitz> hiptobecubic: there is no call stack. in haskell, we mean something else when we say "stack".
15:14:08 <maukd> hiptobecubic: there is no call stack, though
15:14:23 <hiptobecubic> oh
15:14:31 <maukd> that's not really important, though
15:14:35 <hiptobecubic> So what is a haskellian stack overflow? foldl style?
15:14:36 <maukd> I could do this in e.g. perl
15:15:19 <hiptobecubic> It's an interesting function
15:15:26 <maukd> hiptobecubic: that's when you're trying to force a thunk that contains a subthunk that contains ...
15:15:33 <hiptobecubic> Ok i'm off. thanks maukd yitz
15:15:42 <hiptobecubic> maukd, how is that different?
15:15:56 <maukd> it's not related to function calls
15:17:02 <dcoutts> ew0: to prepare an exe for deployment, you'd need two steps: one to install all the lib deps, then a second step to make an install image for the exe
15:17:06 <mcstar> the definition of 'fix' can only work in a lazy language
15:17:10 <mcstar> right?
15:17:27 <mcstar> it seems to me, it just there, to typecheck
15:17:47 <hiptobecubic> Ok, sleep
15:18:21 <dcoutts> ew0: installing deps is easy: cabal install ./foo/ ./bar/   or whatever. Then for preparing the exe, cabal configure --prefix=${as you choose} ; cabal build; cabal copy --destdir=${imagedir}
15:18:27 <mcstar> obviously, you cant call a function with its own return value...
15:18:32 <maukd> mcstar: yes, but you can use other definitions in strict languages
15:18:58 <mcstar> thats basically a Y combinator?
15:19:06 <maukd> fun fix($f) { fun (@args) { $f->(fix($f), @args) } }
15:19:18 <maukd> (I hope I got that right)
15:19:23 <mcstar> whats that?
15:19:27 <maukd> perl
15:19:31 <mcstar> uh
15:20:33 <maukd> function fix(f) { return function () { return f.apply(this, [fix(f)].concat(arguments)); }; }  // javascript version, not sure about the .concat though
15:22:05 <ew0> ok, I have a bunch of functions I can run in parallel
15:22:15 <ew0> with no dependency whatsoever inbetween
15:22:23 <gwern> @quote
15:22:24 <lambdabot> jack-nicholson says: You only lie to two people in your life, Linux fanboys and the police. Neither can handle the truth.
15:22:34 <mcstar> maukd: can you produce an ocaml version? :)
15:23:00 <ew0> is there a way do something like xargs on the shell?
15:23:47 <geekosaur> pseq?
15:23:55 <maukd> let rec fix f x = f (fix f) x;; but is that valid ocaml?
15:24:00 * Eduard_Munteanu can't tell how xargs is related
15:24:05 <ew0> aw, forget about, I'm using 7gb of memory already
15:24:20 <geekosaur> http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel.html
15:24:22 <Entroacceptor> troll?
15:25:01 <ew0> ls *.c | xargs -i --max-procs=4 bash -c "do_all_program {}"
15:25:07 <geekosaur> I think the gnu version of xargs can do some simple mapreduce stuff, assuming the collected commands don't intefere with each other
15:25:12 <ew0> you can do this king of stuff with xargs
15:25:22 <ew0> kind*
15:25:48 <ew0> simple stuff
15:26:21 <mcstar> maukd: problem with that, i cant even use const as a test function
15:27:16 <maukd> let me install ocaml (and tcl for some reason)
15:27:35 <maukd> but!
15:27:37 <maukd> > fix const
15:27:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
15:27:39 <geekosaur> ew0: Control.Parallel.Strategies (parallel package as I linked earlier) has some stuff to let you do things like that, I think more advanced stuff is also available
15:28:14 <mcstar> > fix (const 12)
15:28:15 <lambdabot>   12
15:28:47 <ew0> geekosaur: I'm just checking out pseq
15:28:52 <geekosaur> parListChunk is perhaps the most direct analog to GNUish --max-procs
15:29:05 <ew0> is there a simple foldM_ or mapM_ that is parallel?
15:29:06 <geekosaur> ew0, pseq is more fundamental
15:29:07 <maukd> mcstar: that's true, it only works for functions
15:29:23 <mcstar> maukd: what?
15:29:28 <geekosaur> ew0, I'll just wait for you to catch up in about 5 minutes (judging by recent responses)
15:29:38 <ew0> ok
15:29:40 <mcstar> const 12 is a function, and gives 12, since the recursion is terminated
15:29:53 <mcstar> maukd: problem is, it doesnt terminate for ocaml
15:29:53 <ew0> yeah, I'm kinda new to this stuff
15:29:58 <ew0> I'm used to CSP
15:30:14 <ew0> I was searching for something CSP likey in haskell
15:30:34 <maukd> mcstar: 12 is not a function
15:31:05 <maukd> val fix : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun>
15:31:14 <LadyAurora> > 12 5
15:31:15 <lambdabot>   12
15:31:23 <geekosaur> or I can repeat what I said earlier since you're stuck somewhere or other.
15:31:29 <geekosaur> ew0: Control.Parallel.Strategies (parallel package as I linked earlier) has some stuff to let you do things like that, I think more advanced stuff is also available
15:31:33 <geekosaur> parListChunk is perhaps the most direct analog to GNUish --max-procs
15:31:33 <LadyAurora> > fix 12
15:31:34 <lambdabot>   12
15:31:50 <geekosaur> there's also the Traversable stuff etc. in there
15:32:05 <maukd> mcstar: fix (fun self n -> if n < 2 then 1 else n * self (n - 1)) 5;;
15:32:09 <maukd> 120
15:32:33 <mcstar> i didnt say 12 is a function
15:32:38 <mcstar> i said const 12 is a function
15:33:10 <LadyAurora> In Caleskell 12 is a function.
15:33:23 <maukd> mcstar: irrelevant
15:33:48 <mcstar> maukd: "mcstar: that's true, it only works for functions"
15:33:54 <maukd> haskell's fix is :: (a -> a) -> a
15:33:54 <ew0> uhm
15:34:04 <ew0> I've done nothing, but my program is already running in 2 threads
15:34:12 <maukd> this works because of lazy evaluation (any value of type 'a' can be a thunk)
15:34:19 <ew0> how's that
15:34:21 <ew0> ?
15:34:30 <maukd> ocaml's fix is :: (('a -> 'b) -> ('a -> 'b)) -> ('a -> 'b)
15:34:43 <Polarina> ew0, what is it that you're doing?
15:34:56 <ew0> unrolling loops
15:34:56 <maukd> i.e. the type variable 'a' has been specialized to functions only
15:35:06 <ew0> and doing static analisys of properties of graphs
15:35:11 <maukd> this works because even in a strict language a lambda delays evaluation
15:35:33 <maukd> ew0: IO manager thread maybe?
15:35:34 <Polarina> ew0, are you using forkIO, forkOS, par or pseq?
15:35:38 <mcstar> maukd: i defined it as fix f = f (fix f), i.e left the x argument out
15:35:41 <ew0> no, I'm using nothing
15:35:48 <ew0> but I have 2 cpus in 100%
15:35:53 <maukd> mcstar: infinite loop
15:36:09 <ew0> actualy 3, but one is probably starving at ~2%
15:36:55 <t7> literate binary file... that would be awesome
15:37:02 <t7> im using nasm like that at the moment
15:38:45 <Puffton> What's the easiest way to output a list to console?
15:38:52 <maukd> print
15:39:04 <Puffton> but my function returns IO, then I don't think I can use print?
15:39:19 <maukd> huh?
15:39:32 <aristid> Puffton: your function returns a list of IO foo, or an IO of [foo]?
15:39:51 <aristid> or to use proper syntax, is it [IO foo] or IO [foo]?
15:39:55 <Puffton> right now, it just returns a list that I want to write to console in another function
15:40:08 <Puffton> but I also considered "IO [(String,String,Float)]"
15:40:13 <Puffton> as return type
15:40:20 <Puffton> it's a list of tripples
15:40:44 <aristid> sure you can use print
15:40:45 <mcstar> maukd: i still dont understand, if my function in ocaml is parameteric (a->a)->a why cant a = c->d ?
15:41:02 <maukd> mcstar: it can
15:41:15 * hackagebot aws 0.7.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.1 (AristidBreitkreuz)
15:41:20 <mcstar> ok, but why doesnt it do what i expect?
15:41:28 <maukd> mcstar: because it's an infinite loop
15:41:43 <maukd> you have: fix f = f (fix f)
15:41:52 <maukd> i.e. fix always calls itself first
15:41:56 <maukd> bang dead
15:42:18 <Dodek> hey, is there any tutorial on how to use data-lens package?
15:42:34 <mcstar> fix f x = f (fix f) x, isnt the same true here?
15:42:38 <maukd> no
15:42:49 <maukd> here fix also calls itself, but it stops there
15:42:56 <edwardk> no. there is a tutorial for 'lens' though
15:42:56 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
15:43:09 <mcstar> maukd: i see, i just partially apply fix
15:43:11 <Dodek> edwardk: where can i find one?
15:43:13 <maukd> mcstar: maybe this form is clearer: fix f = fun x -> f (fix f) x
15:43:22 <maukd> i.e. the result of fix f is a lambda
15:43:24 <mcstar> maukd: no, i get it
15:43:50 <maukd> lambda delays evaluation! cookies for everyone!
15:43:57 <edwardk> https://github.com/ekmett/lens#examples gives a walk through of how to do some easy stuff. there is more on the wiki there
15:44:22 <edwardk> mind you this is for a different package. i wrote data-lens, then decided i liked a different design and wrote lens
15:45:06 <Dodek> edwardk: ah, ok. thanks.
15:46:36 <mcstar> maukd: are there more complicated but still useful/practical recursion patterns like fix?
15:47:00 <cmccann> next edwardk will write lens-data, data-lens-lens, lens-data-lens-lens, lens-lens-ham-baked-beans-and-lens...
15:47:09 <maukd> mcstar: yes, map
15:47:33 <mcstar> map, but not the map i know?
15:47:38 <Puffton> http://hpaste.org/75204
15:47:40 <edwardk> cmccann: i was originally going to call what became lens, lens-family, but roconnor beat me to the punch
15:47:46 <maukd> mcstar: no, just the map you know
15:47:56 <Puffton> I can't seem to get print to work
15:48:18 <Puffton> I'm having a type mismatch, but I'm not sure I can do what I'm doing with the recursion in computeResultWriteConsole
15:48:20 <cmccann> you should have challenged him to a duel for the right to use that name
15:49:41 <ew0> uhm
15:49:47 <ew0> it is not 2 threads
15:49:54 <ew0> it is this weird htop
15:50:00 <ew0> from the server I'm running
15:54:35 <benmachine> edwardk: "Conversely view, can be used as an infix alias for (^.)."
15:54:40 <benmachine> edwardk: itym prefix?
15:54:49 <edwardk> benmachine: yes
15:56:15 * hackagebot liblastfm 0.0.3.6 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.3.6 (MatveyAksenov)
16:01:14 <Puffton> Ah nvm
16:01:17 <Puffton> Was some sloppy code
16:01:55 <Puffton> Disconnected.. Sorry about that pastebin, was some sloppy mistakes in it
16:01:56 <Puffton> now it works
16:08:18 <derrida> Hello, I'm trying to install idiii via `cabal install idiii`, after the deps have succesfully built the build fails saying that: "Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.1". I did some googling and the two workarounds I found suggested don't seem to help (ghc-pkg --hide haskell98 || removing haskell98 from the idiii.cabal file). I'm more/less haskell newb so
16:08:20 <derrida> I'm at a bit of impasse here, any assistance would be appreciated! :D
16:11:29 <derrida> hm, if i remove haskell98 from build-deps, the line "import Bits" is what makes it complain, i'll do more research, sorry.
16:11:43 <rwbarton> you are probably better off removing base
16:12:22 <rwbarton> or you can track down every import using haskell98 module names and change them to use the new modules names (Bits -> Data.Bits etc.)
16:13:39 <derrida> rwbarton: after fixing Bits I see there are quite a few more changes that would be necessary. I'll try removing base :)
16:13:53 <quuuux> rwbarton: straight up removing base doesn't work either, it uses some hierarchical module names
16:13:59 <quuuux> what an awful failure mode :/
16:15:37 <Dodek> hey,i tried to use Control.Lens.TH.makeClassy on a data type with no arguments, and got the following error:
16:15:39 <hpaste> dodek pasted “th lens” at http://hpaste.org/75205
16:16:01 <Dodek> i just copy-pasted the example from documentation
16:16:01 <edwardk> Dodek: what does the data type look like?
16:16:20 <Dodek> data Foo = Foo { _fooX, _fooY :: Int }
16:16:30 <edwardk> interesting
16:16:35 <edwardk> what ghc version?
16:16:46 <Dodek> 7.4.1
16:17:08 <quuuux> derrida: I think that removing base will easier. It apparently relies on other Haskell-98 behaviour
16:17:10 <mgsloan> Dodek: Yikes!!  perhaps ForallTs need to have something in them
16:17:22 <edwardk> that foo :: line looks odd to me
16:17:35 <edwardk> actually all the missing type variables there look odd
16:17:35 <Dodek> adding a dummy type argument and using makeLenses works
16:18:09 <edwardk> hrmm, makeClassy should work. i'll dig in deeper
16:18:57 <mgsloan> works for me under 7.6.1
16:18:59 <edwardk> i'm going to throw an issue on the tracker in case i fall asleep. out of it sick at the moment
16:20:18 <Puffton> is getContents ever used to read multiple lines in the console? does it expect an EOF to stop expecting input?
16:20:40 <Puffton> I would like to input a bunch of lines and then stop expect input at first empty line
16:21:12 <edwardk> Dodek: https://github.com/ekmett/lens/issues/60
16:21:44 <edwardk> Dodek: i'll update that with whats going on/my findings, etc.
16:22:28 <Dodek> edwardk: that's great, thanks!
16:22:47 <derrida> quuuux: Excuse my crudeness, i was able to remove base and then change a few Data.Foo to Foo. Got past several errors but with Data.Either it doesn't work, I guess Either is not provided?
16:23:52 <quuuux> derrida: yes, sorry, I just ran into that too. That's not in Haskell-98, annoyingly.
16:24:14 <derrida> hehe, np
16:25:08 <quuuux> derrida: I have something of a solution, I think. Let me just make sure it actually, y'know, works
16:25:12 <edwardk> Dodek: i'm thinking it may be that there is a bug in ghc 7.4.1 not liking the use of 'newName'd type variables. which would suck
16:25:17 <derrida> sure!
16:25:50 <Dodek> edwardk: you're suggesting to update ghc, then?
16:26:04 <edwardk> Dodek: not sure what i'm suggesting yet. =)
16:26:12 <mgsloan> edwardk: that would suck, but non-newnamed type variables wouldn't be bad
16:26:20 <mgsloan> because they're so locally scoped
16:26:34 <mgsloan> infact it might make ddump-splices more readable
16:26:48 <edwardk> Dodek: it is known to work on ghc 7.6.1, but it _should_ work with 7.4 or even 7.2, and has historically until i made the change for https://github.com/ekmett/lens/issues/35
16:27:13 <edwardk> but i find it odd that travis doesn't complain about the similar test cases it has
16:27:20 <edwardk> that is running 7.4.1
16:27:50 <tux_override> :exit
16:27:53 <tux_override> aah
16:27:57 <Dodek> edwardk: now i'm trying to reproduce it on different machine
16:27:59 <edwardk> mgsloan: the danger is shadowing
16:28:40 <edwardk> mgsloan: i'd love to have a smarter 'newName' that kept an ambient context of already used names, like the 'secrets of the ghc inliner's "rapier" for barendregt-style renaming
16:28:50 <edwardk> that way it could take the nice names where possible
16:28:55 <Puffton> Is it possible to read using getContents "until the last read line is an empty string"?
16:29:07 <Puffton> I found "until" but not sure I can use it like this
16:29:08 <mgsloan> edwardk: yeah, that'd be really nice.  Or just have a smarter prettyprinter
16:29:49 <mgsloan> a better newName would be better
16:31:16 * hackagebot cabal-file-th 0.2.3 - Template Haskell expressions for reading fields from a project's cabal file.  http://hackage.haskell.org/package/cabal-file-th-0.2.3 (NickPartridge)
16:31:18 * hackagebot Workflow 0.7.0.7 - Monad transformer for thread state persistence and workflow patterns  http://hackage.haskell.org/package/Workflow-0.7.0.7 (AlbertoCorona)
16:32:11 <quuuux> derrida: okay, that's not *so* bad. You'll have to manually touch a few modules. 1) Delete the dependency on haskell98 in the .cabal file. 2) Change the bad import of 'Bits' to 'Data.Bits'. 3) In src/ID3/Parser/General.hs, change 'Num n' to 'Eq n, Num n' (lines 180, 188, 197)
16:32:37 <quuuux> derrida: then write the maintainer an email and ask them to put a tighter version bound on base :)
16:35:00 <quuuux> also, man, removing the Eq superclass from Num must've broken -so- much old code :/
16:36:09 <derrida> quuuux: whew! thew worked! :) tyvm. I'll write the maintainer and let them know.
16:36:16 <zomg> Is there some trick to exposing a hidden module? I tried ghc -package http-conduit myfile.hs but it still complains
16:36:20 <derrida> s/thew/that/
16:36:24 <Dodek> edwardk: i have the same thing on 7.4.1 on different machine
16:36:53 <mgsloan> quuuux: yeah, we need something like superclass default instances / class aliases so that things like that don't break everything
16:36:58 <edwardk> Dodek: K. then i probably borked makeClassy. hrmm. one sec while i look for a flag for you to try
16:38:09 <edwardk> hrmm i apparently didn't make an option for whether or not you want the methods in the class or on their own
16:38:19 <hpaste> dodek pasted “test case” at http://hpaste.org/75206
16:39:59 <edwardk> Dodek: can you install lens 2.8 and see if it works for you?
16:41:09 <Dodek> edwardk: how do i do that?
16:41:16 <Dodek> i've been using cabal install all the time
16:42:25 <edwardk> yes, but it got you 2.9 i bet. i want you to try with an older version, before i updated the makeClassy behavior
16:42:49 <Dodek> so can i install older version using cabal install?
16:43:15 <edwardk> cabal install lens --constraint 'lens < 2.9'
16:45:44 <Dodek> edwardk: it still fails, but with different error message
16:46:00 <edwardk> Dodek: can you hpaste the error you got there?
16:46:02 <hpaste> dodek pasted “lens error” at http://hpaste.org/75207
16:46:20 <edwardk> that was rather unexpected
16:49:45 <edwardk> interestingly, travis builds that code just fine: http://travis-ci.org/#!/ekmett/lens/builds/2540953/L1265
16:50:26 <edwardk> thats on ghc 7.4.1 http://travis-ci.org/#!/ekmett/lens/builds/2540953/L8
16:53:37 <Dodek> these urls don't work for me
16:56:34 <pr> yeah, they display something completely unrelated to the lens package in the middle column
16:56:50 <edwardk> interesting
16:57:26 <edwardk> does http://travis-ci.org/#!/ekmett/lens/builds/2540953 work?
16:57:32 <pr> they actually display the (name of) the most recent building
16:57:33 <pr> project
16:57:51 <pr> yep, works fine edwardk
16:58:05 <edwardk> then line 1265 and 8 of that respectively ;)
16:58:33 <Dodek> this one works
16:58:39 <pr> 8The Glorious Glasgow Haskell Compilation System, version 7.4.1
16:58:40 <ddarius> shapr: Prolog?
17:02:42 <Puffton> http://hpaste.org/75208
17:03:03 <Puffton> What am I missing here? the use of readLine requires me to use IO () in the signature of the function?
17:03:28 <Puffton> I would like to return "line" with one char dropped, but I keep getting issues with "IO String" not being "String"
17:03:49 <edwardk> Dodek: one last test. can you git clone https://github.com/ekmett/lens, cd into it, cabal install, and try your test again?
17:03:59 <edwardk> i want to make sure this isn't something i just happened to have fixed
17:04:30 <benmachine> Puffton: it looks like you don't understand how to use IO in Haskell
17:04:39 <benmachine> Puffton: uh, not meaning to sound dismissive or anything
17:04:43 <benmachine> have you done much IO before?
17:05:12 <Puffton> no, started learning about IO in Haskell today
17:05:44 <Puffton> but I was under the impression that in the case of the code I supplied, line would be of type "String" and not "IO String"
17:05:46 <benmachine> ok, well, you might be interested in http://www.haskell.org/haskellwiki/Introduction_to_IO
17:05:55 <zomg> Welp, if you run Ubuntu 12.04 and GHC 7.4.1, this will segfault... http://jjh.fi/~jani/segfault2.txt
17:06:02 <parcs`> ;
17:06:02 <benmachine> yes, line is of type String
17:06:06 <zomg> (uses http-conduit)
17:06:12 <benmachine> however, you're stuck in the IO do-block
17:06:23 <benmachine> you can't get line *out* of the do-block without wrapping it in IO
17:06:46 <Puffton> ok, I guess the way I've been getting out of it before is by using an outputting statement
17:06:54 <Puffton> like print
17:07:05 <benmachine> Puffton: right
17:07:31 <benmachine> Puffton: another way is to use 'return'
17:07:41 <Dodek> edwardk: same error as with lens 2.9
17:07:43 <benmachine> which just makes an IO action which gives the string when executed without doing anything else
17:08:31 <edwardk> dodek: hrmmph. i'll need to set up a new machine with 7.4.1 on it to test deeper
17:08:38 <benmachine> zomg: no segfault here
17:08:49 <edwardk> since my usual approach of using travis for backwards compatibility testing isn't getting me anywhere
17:09:07 <benmachine> zomg: how exactly are you running it?
17:10:06 <Puffton> but if I do "return line" it will be stuck as IO String?
17:10:18 <benmachine> Puffton: right. this is kind of the point :)
17:10:25 <benmachine> Puffton: whatever you do in IO, stays in IO
17:10:46 <benmachine> Puffton: however, if you have some function that wants a string, you can turn it into a function that accepts an IO string (and produces an IO result)
17:10:50 <edwardk> We need a Vegas monad.
17:10:51 <benmachine> did you read the haskellwiki page I linked you?
17:10:55 <benmachine> edwardk: :>
17:11:05 <frio> type Vegas = IO?
17:11:08 <edwardk> yep
17:11:56 <edwardk> You could have a MyAss comonad too. You can pull things out of it. Not sure I like the visual of extend though.
17:12:25 <hpc> nnnnyah!!!
17:12:28 <hpc> cannot unsee!
17:12:49 <edwardk> ok, medication has definitely kicked in. going to get some sleep ;)
17:12:55 <Puffton> benmachine, 1 min
17:22:36 <Puffton> benmachine, yeah I have checked it out. my scenario was a bit more tricky than the one I presented though
17:22:51 <Puffton> i.e. it was hard to make it pretty
17:23:05 <Puffton> which was why i started splitting code up, and ended up in this situation
17:23:09 <Puffton> but now I'm onto something :)
17:23:33 <parcs`> :)
17:30:06 <ddarius> Puffton has become a surjective function.
17:30:18 <Puffton> I am now the king of the universe!
17:30:49 <Puffton> http://hpaste.org/75209
17:30:50 <Puffton> Behold!
17:31:17 <Puffton> It finally works, thanks benmachine
17:31:39 <benmachine> Puffton: :)
17:32:28 <Puffton> Speaking of hpaste, do you guys know how long it takes for them to expire? Do they ever?
17:32:36 <benmachine> they... don't, I don't think
17:32:59 <rwbarton> they expire when the admin of hpaste disappears from the internet and a new hpaste site is set up
17:33:01 <benmachine> I guess it can afford not to because it's not spammed very much
17:35:02 <hpaste> benmachine annotated “Puffton” with “cleverer readConsoleUntilEmptyLine” at http://hpaste.org/75209#a75210
17:35:18 <benmachine> Puffton: this isn't related to your problem, but I thought you might like to see it anyway :)
17:36:50 <Jello_Raptor> hmm, what should I name a function '[Maybe a] -> Maybe [a]' that works like catmaybe, except in that if there's a single NOthing in the input, the oput is simply nothing?
17:37:06 <cmccann> the oldest hpastes seem to be from late 2008
17:37:09 <benmachine> Jello_Raptor: you should name it 'sequence'
17:37:13 <benmachine> Jello_Raptor: oh wait!
17:37:15 <benmachine> :t sequence
17:37:16 <benmachine> :)
17:37:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:37:25 <Puffton> oh yeah that's smart.. rewriting it without an accumulator
17:37:28 <Jello_Raptor> benmachine: <_< point
17:37:33 <Jello_Raptor> and thanks :)
17:37:35 <benmachine> Jello_Raptor: :P
17:38:12 <startling> anyone know of low-level language based on a "memory" monad?
17:39:18 <Puffton> cmccann, how do you see the age? at least it seems even the paste with ID 1 is up, so
17:39:23 <Puffton> doesn't seem to be much cleaning going on there :p
17:39:38 <cmccann> from the "browse pastes" page
17:39:48 <benmachine> Puffton: press 'Expand' and it shows you the date
17:40:47 <Puffton> ah yes, it was hidden away
17:40:55 <Puffton> the browse feature
17:41:37 <Puffton> the page is a little tricky to use if you want those features, but it's really cool with the HLint feedback on pastes
17:41:53 <benmachine> mm
17:41:56 <Puffton> must have been one heck of a job implementing that
17:42:01 <Puffton> (HLint=
17:42:19 <benmachine> hlint has been around for a looong time
17:42:22 <benmachine> lot of work has gone into it
17:42:56 <Puffton> who started with these lints? I know JSLint has been around for ages too
17:43:18 <benmachine> oh, C lint predates them all
17:43:24 <benmachine> C lint is probably older than me
17:43:49 <benmachine> oh, by a decade or so :D
17:43:57 <Puffton> http://en.wikipedia.org/wiki/Lint_(software)
17:44:21 <Puffton> yeah 1979 it seems
17:44:53 <ddarius> 77
17:45:05 <startling> author of yacc, wow
17:45:33 <Puffton> ah yes, missed that at the bottom
17:45:36 <Puffton> you born 87?
17:46:51 <quuuux> I can't speak for anyone else, but I don't find hlint to be as useful as lint-a-likes in other languages
17:47:02 <quuuux> probably because the compiler already does so much more in Haskell
17:47:07 <startling> seems like the typechecker catches everything in haskell
17:47:10 <startling> yeah
17:47:14 <benmachine> hlint *is* useful
17:47:18 <benmachine> not *as* useful
17:47:21 <benmachine> but useful nonetheless
17:48:15 <shachaf> ocharles: ?
17:58:32 <startling> where in the module hierarchy should I put machine code generation stuff
17:59:37 <donri> possibly Language or System? or simply a top-level module named as your package?
17:59:39 <edwardk> Language.Assembly.StartlingsAwesomeDSL
18:00:03 <shachaf> Not a fan of 's in filenames, huh?
18:00:09 <benmachine> the module hierarchy is overrated, true fact
18:00:22 <edwardk> wasn't sure if it'd work ;)
18:00:22 <startling> oh, Language seems obvious
18:00:24 <startling> thanks!
18:00:34 <shachaf> "Language.Assembly"
18:01:25 <benmachine> Language.It.Is.Vital.You.Understand.The.Scope.And.Purpose.Of.My.Module.Just.From.Its.Name.Also.I.Work.In.A.Keyboard.Factory.And.Need.To.Drive.Up.Demand.Somehow
18:01:46 <benmachine> that's what it should be called.
18:02:05 <startling> benmachine: compelling
18:04:36 <aristid> benmachine: ah so that's who invented the Control/Data module prefix dichotomy
18:04:43 <Puffton> is "do" a monad or syntactic sugar or..?
18:04:53 <aristid> Puffton: syntactic sugar
18:05:02 * YayMe actually names classes and variables like that at work... it makes me feel funny sometimes, but it beats the arbitrarily inaccurate naming of my colleagues
18:05:28 <donri> > do 1 + do 2
18:05:29 <lambdabot>   3
18:06:44 <centrinia> :t do 1
18:06:45 <lambdabot> forall t. (Num t) => t
18:07:15 <copumpkin> > do (do 5)
18:07:16 <lambdabot>   5
18:07:20 <copumpkin> > do do 5
18:07:21 <lambdabot>   5
18:07:28 <ddarius> Arbitrarily.Inaccurate.addition 3 4 == 12
18:07:33 <copumpkin> > do do do do do do do 5
18:07:34 <lambdabot>   5
18:07:39 <YayMe> can someone explain what forall does in a signature?
18:07:58 <scshunt> ddarius: I want that library
18:08:03 <ddarius> It binds type variables and universally quantifies them.
18:08:36 <YayMe> what is thwe difference between (Num t) => t and the same with forall t.
18:08:52 <shachaf> @google what does forall mean in haskell
18:08:52 <lambdabot> http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
18:08:53 <lambdabot> Title: syntax - What does the `forall` keyword in Haskell/GHC do? - Stack Overflow
18:09:36 <shachaf> Someone ought to write a good explanation of all the different things you do with "forall".
18:09:53 <ddarius> You can universally quantify type variables.
18:09:59 <ddarius> That was easy.
18:10:16 <shachaf> ddarius: People never seem satisfied...
18:10:54 <YayMe> ddarius: I understand what you're saying, but it doesn't seem like something that it would actually do if I understand it from that SO article and from what you're saying
18:11:20 <YayMe> that's why it's not satisfying.. it's like saying "It causes teleportation", the statement makes sense, but you figure you're understanding it wrong because that seems unlikely
18:11:44 <shachaf> Universal quantification is a lot like teleportation.
18:11:59 <YayMe> so if I understand it, it forces the signature to be applied to any variable sharing it's name in the scope of the function?
18:12:20 <YayMe> shachaf: yeah I get that, kind of why it's what came to mind
18:12:25 <shachaf> I don't understand what you said but suspect that you don't understand it.
18:12:48 <YayMe> yes I suspect the same
18:12:59 <oneZeroOne> is there some way to make 'anonymous types' in haskell? something like c# anonymous classes?
18:13:23 <Puffton> but using >> doesn't seem to make it possible to pipeline stuff?
18:13:34 <MostAwesomeDude> oneZeroOne: To what end?
18:13:36 <YayMe> anonymous types in C# are syntactic sugar for tuples
18:13:48 <YayMe> that's why they came into the language at the same time as the Tuple
18:13:58 <YayMe> tuple's are the same thing in haskell
18:14:12 <Puffton> like "let myfunc a = a" then "myfunc 'A' >> toUpper"
18:14:18 <Nisstyre> YayMe: so tuples actually mean TWO elements in C#?
18:14:34 <YayMe> Nisstyre: tuples mean arbitrary numebr of elements
18:14:36 <benmachine> Puffton: >> doesn't do that, no
18:14:41 <YayMe> of arbitrary types
18:14:45 <YayMe> just like in haskell
18:14:46 <Nisstyre> YayMe: I thought that was n-tuples?
18:14:56 <Nisstyre> maybe my terminology is screwed up
18:15:01 <jmcarthur> 2-tuples are just a special case of n-tuples
18:15:06 <YayMe> Nisstyre: I don't know terminology for squat, I'm uneducated
18:15:09 <jmcarthur> they are all tuples
18:15:33 <YayMe> I think of "tuple" as the generic term, "double" and "triple" and etc are usually what I here used to refer to specific numbers of them
18:15:35 <jmcarthur> tuples must have statically known size, if that's what you mean
18:15:40 <YayMe> s/here/hear/g
18:15:49 <Nisstyre> jmcarthur: maybe that's what I'm thinking of
18:15:53 <startling> woah, it's like #python crossover day
18:15:59 <Nisstyre> that goes for almost every language anyway
18:15:59 <YayMe> Eh?
18:16:08 <Nisstyre> even python has immutability for tuples
18:16:53 <oneZeroOne> MostAwesomeDude i want to project a sequence into a new one but adding 'labels' to the values (guess pretty much like linq)
18:17:04 <jmcarthur> immutability doesn't really have anything to do with arity, does it?
18:17:10 <oneZeroOne> much better if the labels are not strings
18:17:36 <Nisstyre> jmcarthur: umm, well the arity of the tuple is always known, but not at compile time
18:17:43 <Nisstyre> (in python)
18:17:47 <YayMe> oneZeroOne: In C# when you say new { Bla = "hoy", Har = 3, Ning = 2.0f }; at compile time it turns it into a System.Tuple<String,Int,Float>
18:18:01 <jmcarthur> Nisstyre: oh, you mean in python you can't dynamically change the arity of a tuple
18:18:07 <Nisstyre> jmcarthur: right
18:18:14 <Nisstyre> you have to create a new one
18:18:19 <jmcarthur> the mere idea of doing that sounds weird to me :P
18:18:24 <YayMe> oneZeroOne: the same thing in haskell would just be (String,Int,Real)
18:18:35 <benmachine> Real isn't a type
18:18:37 <YayMe> err (String,Int,Float)
18:18:44 <jmcarthur> Real could be a type
18:18:48 <YayMe> I'm not that bright, can't remember exactly
18:18:51 <oneZeroOne> YayMe yeah but i could say obj.nome
18:19:23 <YayMe> oneZeroOne: Huh?
18:19:27 <YayMe> Oh
18:19:41 <oneZeroOne> i mean in C# i know the name of each field
18:19:43 <YayMe> oneZeroOne: data types have record accessors automatically if you define them
18:19:50 <jmcarthur> i think it would be nice to have locally defined types, say in a where clause
18:20:11 <YayMe> oneZeroOne: But for the same from a tuple, you just define a function, i.e. name (_,x,_) = x
18:20:20 <jmcarthur> i care less for anonymous records
18:20:22 <YayMe> or just name = snd rather
18:20:23 <Nisstyre> jmcarthur: you think? what use would you have for that?
18:20:30 <Nisstyre> not attacking the idea
18:20:33 <Nisstyre> just curious
18:20:36 <YayMe> but I don't know that a functino of the sort would be particularly useful
18:20:51 <oneZeroOne> yayme but that way there would have to be previoulsy declared ...
18:20:51 <YayMe> instead of using the default or just deconstructing the tuple in a match
18:21:24 <jmcarthur> Nisstyre: an example could be a function in a where clause that returns a sum type, such that the main function body pattern matches on it
18:21:57 <YayMe> You could maybe define that sugar in haskell (in C# when you use the anonymous accessor like obj.Prop, underneat it's obj.Item2 or wherever the prop is)
18:22:04 <Nisstyre> jmcarthur: I think such a thing would be possible to do, and potentially useful
18:22:10 <Nisstyre> I think you can do that in Typed Racket, also
18:22:18 <ddarius> Nisstyre: It's certainly possible.
18:22:22 <Nisstyre> via the struct procedure
18:23:26 <Nisstyre> ddarius: when GHC does type inference, it would just have to keep track of these special "local" types, right?
18:23:34 <jmcarthur> they would just be types
18:23:38 <ddarius> It depends on the choices you make.
18:23:52 <ddarius> The simplest thing would just be to lift them to top-level with suitably mangled names.
18:23:56 <jmcarthur> the kind i'm imagining would be pretty much context free and could be lifted
18:24:00 <oneZeroOne> YayMe yes but how would i associate the names with the positions in the tuple?
18:24:22 <Nisstyre> ddarius: sort of like how hygienic macro systems rename, right?
18:24:53 <YayMe> oneZeroOne: Like I said, you would have to define the sugar, for instance in C# you do it with new { bla = bla, bla = bla };, in haskell you would have to define your version of the "new" part, and etc
18:24:54 <ddarius> I don't think so.
18:25:12 <ddarius> Nisstyre: I believe hygienic macros have a significantly harder problem that this approach.
18:25:28 <Nisstyre> ddarius: I know, just trying to draw an analogy, it helps me understand thing
18:26:12 <jmcarthur> i don't think it would be useful enough to warrant implementing it
18:27:17 <ddarius> Maybe if I ever get around to making a patch for local modules I'll add that too, because why the hell not?
18:27:22 <jmcarthur> local modules!
18:27:27 <shachaf> Local modules!
18:28:05 <oneZeroOne> YayMe template haskell ?
18:28:26 <ddarius> oneZeroOne: This was kind of lost, but with pattern matching this is much less compelling.
18:29:00 <YayMe> oneZeroOne: I haven't touched it so I don't know if it would be helpful, but you could create the functionality yourself without it I would wager
18:29:53 <YayMe> perhaps something like...
18:30:46 <YayMe> myThing = anon ("NameA", valA, "NameB", valB)
18:30:58 <YayMe> then anon returns a type which can be used with:
18:31:18 <YayMe> myThing %^%& "NameA"
18:31:29 <YayMe> replace %^%& with whatever operator you wish
18:31:54 <YayMe> anon returns a function which has all your types in a closure and a mapping to them by string
18:32:11 <YayMe> in C# you have myThing.NameA in haskell it would just be myThing "NameA"
18:32:49 <YayMe> Though for this purpose I'm imagining just using a hashtable would perhaps be fine, which are defined somewhere in Data aren't they?
18:33:08 <oneZeroOne> not quite
18:33:30 <oneZeroOne> still could make a typo with string labels, beats the porpouse
18:33:51 <oneZeroOne> that why i was thinkin in records and template haskell
18:34:39 <Jello_Raptor> can haskell have question marks in function names?
18:34:54 <shachaf> Only operators.
18:35:06 <YayMe> true, there's no way for your local scope to be filled with new types or functions that would be able to compile time check for your instanec because all that stuff being filled into the scope above the anon function would just be wicked side effects
18:35:09 <Jello_Raptor> ahh, thanks
18:35:28 <YayMe> Though I do agree with the others about pattern matching really making something like you're talking about kind of extra cruft
18:36:24 <QUACKALPACATRON> What's the behaviour on getting the lengh of an infinite list? It just doesn't terminate?
18:36:42 <scshunt> yeah, it's bottom
18:37:13 <shachaf> QUACKALPACATRON: Not with the function "length".
18:37:43 <shachaf> With genericLength and a suitable lazy natural type, you can get a non-_|_ "infinity" number.
18:38:00 <shachaf> (Which isn't, in fact, a natural number.)
18:38:13 <ddarius> shachaf: But then neither is _|_.
18:38:16 <YayMe> How could you get that?
18:38:16 <scshunt> shachaf: whoa, really?
18:38:24 <YayMe> Oh I got it
18:38:30 <YayMe> it goes like this:
18:38:47 <ddarius> Nat ~ [()], lazyLength = map (const ())
18:38:55 <jmcarthur> "coinductive naturals"?
18:38:59 <shachaf> Nat ~ [Void], lazyLength = map (const undefined)
18:39:04 <YayMe> infinity = read ('9' : infinity) :: Int
18:39:09 <scshunt> oh, so you can
18:39:10 <YayMe> :D
18:39:11 <Nisstyre> jmcarthur: coinduction means building from a seed
18:39:14 <QUACKALPACATRON> shachaf, but I take it there is no guarantee it will ever terminator?
18:39:17 <latro`a> oh dear that's bad, YayMe
18:39:18 <scshunt> now that I see how genericLength works
18:39:19 <Nisstyre> er, you probably know that
18:39:21 <jmcarthur> Nisstyre: which is not incorrect
18:39:27 <ddarius> shachaf's version is slightly more careful than mine.
18:39:28 <YayMe> latro`a: haha I know, it's fun though
18:39:37 <latro`a> it's also a type error
18:39:44 <YayMe> I'm sure
18:39:46 <ddarius> Nisstyre: Coinduction "means" defined by observations.
18:39:55 <shachaf> QUACKALPACATRON: I prefer my software not to terminator, unless I'm writing SkyNet.
18:39:57 <YayMe> but I stand by my infinity! :D
18:40:03 <Nisstyre> ddarius: I don't understand that definition
18:40:07 <Nisstyre> can you explain more?
18:40:08 <latro`a> infint = let infstr = '9':infstr in read infstr :: Int
18:40:18 <latro`a> > infint = let infstr = '9':infstr in read infstr :: Int
18:40:19 <lambdabot>   <no location info>: parse error on input `='
18:40:23 <latro`a> bah
18:40:43 <latro`a> > infint = let infstr = repeat '9' in read infstr :: Int
18:40:44 <lambdabot>   <no location info>: parse error on input `='
18:40:46 <latro`a> wat
18:40:46 <jmcarthur> data Nat = S Nat | Z
18:41:02 <shachaf> latro`a: You already know it's not going to work. What's the point?
18:41:05 <jmcarthur> lazyLength [] = Z; lazyLength (_:xs) = S (lazyLength xs)
18:41:06 <latro`a> now it should
18:41:14 <latro`a> unless I'm missing brackets
18:41:26 <latro`a> > infint = let {infstr = repeat '9'} in read infstr :: Int
18:41:26 <lambdabot>   <no location info>: parse error on input `='
18:41:30 <shachaf> No, it won't work. It'll just crash.
18:41:31 <jmcarthur> Nisstyre: ^^
18:41:40 <latro`a> ah yes
18:41:44 <latro`a> but it should still compile
18:41:51 <YayMe> there's no way my little sarcastic remark is any form of functional code
18:42:00 <rwbarton> let x = y in z
18:42:03 <jmcarthur> Nisstyre: data Nat = Z | S Nat    is roughly the same in expressive power as   [()]
18:42:09 <YayMe> but more importantly, what was that definition you guys used?
18:42:13 <jmcarthur> (a small lie)
18:42:23 <shachaf> data Nat = S Nat
18:42:30 <YayMe> that ~ is?
18:42:38 <Nisstyre> so which one is inductive and which is co-inductive?
18:42:45 <ddarius> jmcarthur: Ignoring the "small lie" aspect, it's pretty much exactly representationally equivalent, just with different constructor names.
18:42:54 <jmcarthur> ddarius: right
18:43:06 <jmcarthur> as my implementation of lazyLength demonstrates
18:43:07 <shachaf> I guess Mu Identity is almost exactly Nat
18:43:22 <shachaf> Except for fix (In . Identity)
18:43:25 <jmcarthur> shachaf: so... the "always infinity" type?
18:43:33 <shachaf> jmcarthur: No, you can put a _|_ anywhere you want.
18:43:37 <jmcarthur> heh
18:43:41 <shachaf> _|_ = 0, S _|_ = 1, etc.
18:44:04 <Nisstyre> so _|_ is the base case?
18:44:11 <copumpkin> shachaf: not really, because you can't deconstruct it at all. Mu Maybe is closer
18:44:20 <jmcarthur> _|_ isn't much of a base case
18:44:27 <ddarius> Yay, semi-decidable ordering comparisons.
18:44:28 <shachaf> copumpkin: I'm not talking about deconstruction, just the inhabitants you can make. :-)
18:44:30 <jmcarthur> Free Identity
18:44:46 <jmcarthur> err
18:44:47 <jmcarthur> Free Identity ()
18:44:57 <copumpkin> shachaf: if you can't observe them, then there's not much point in calling them distinct
18:45:01 <jmcarthur> (ignoring the lie again)
18:45:07 <shachaf> Says the author of spoon.
18:45:11 <jmcarthur> lol
18:45:13 <copumpkin> :)
18:45:30 <YayMe> Care to explain the ~ in the definition you guys wrote?
18:45:41 <ddarius> In copumpkin's world, spoon always returns Nothing.
18:45:48 <ddarius> Er Just?
18:45:53 <jmcarthur> spoon is the most awful package that i can't live without
18:46:01 <centrinia> @let spoon = const Nothing
18:46:02 <lambdabot>  Defined.
18:46:06 * YayMe wonders what spoon is
18:46:06 <jmcarthur> i've never used it, actually
18:46:26 <copumpkin> me neither :P
18:46:39 <YayMe> oh I see
18:46:43 * Nisstyre is buried under notation that he doesn't understand fully
18:46:48 <jmcarthur> YayMe: imagine a function of type   a -> Maybe a   that gives Nothing if a is "observed" to be _|_
18:46:48 <shachaf> YayMe: Try Hoogle.
18:46:58 <ddarius> Sounds like we can vote spoon the most crucially important package that no one has ever used.
18:47:04 <shachaf> YayMe: (For both questions.)
18:47:26 <YayMe> shachaf: Sorry. Got spoon now, the ~ I guess I'll just have to read on
18:47:29 <jmcarthur> YayMe: once you're done imagining that horrible thing, forget it was ever mentioned, and never look up the spoon package
18:48:12 <YayMe> jmcarthur: Too late, and luckily having "don't swallow exceptions" drilled into my skull from years of C# I twinged when I read the tag line on hackage
18:48:19 <ddarius> YayMe: ~ is just an ASCIIification of ≅ which is the usual symbol for "is isomorphic to".
18:48:32 <jmcarthur> YayMe: it's not quite *swallowing* exceptions
18:48:46 <YayMe> yeah, not *quite*
18:48:47 <jmcarthur> YayMe: it's just making them observable in otherwise pure code
18:48:56 <YayMe> relatively observable
18:49:01 <YayMe> to the extent that you can observe nothing
18:49:06 <ddarius> jmcarthur: Yes, but to make it reasonable, it has to identify all exceptions which is less than desirable.
18:49:30 <ddarius> @hackage spoon
18:49:31 <lambdabot> http://hackage.haskell.org/package/spoon
18:49:32 <jmcarthur> ddarius: if _|_ is among "all exceptions" then it's impossible
18:49:35 * shachaf briefly wonders what YayMe means.
18:49:40 <Cale> a -> Either SomeException a
18:49:44 <YayMe> swallowing catches in C# aren't exactly *swallowing* exceptions either, you can observe the null values that shouldn't be there if the code behaves appropriately, but you still shouldn't do it heh
18:49:46 <jmcarthur> YayMe: Nothing is always observable...
18:49:58 * shachaf totally wrote a GHC extension this morning.
18:50:02 <jmcarthur> YayMe: the difference is that null isn't designated with a special type
18:50:18 <shachaf> It was all of 8 lines!
18:50:22 <YayMe> jmcarthur: Yes, but the error case is no longer observable
18:50:23 <jmcarthur> YayMe: null is kind of like _|_, in that sense
18:50:36 <Tekmo> Except you can't pattern match on _|_
18:50:37 <YayMe> jmcarthur: No, the exception is more like _|_
18:50:43 <shachaf> null is very different from _|_
18:50:50 <YayMe> null is closer to nothing
18:51:06 <ddarius> shachaf: To quote someone from here, I don't know what you're talking about but it sounds like a bad idea.
18:51:08 <jmcarthur> shachaf: only in that you can't observe _|_ (usually)
18:51:13 <Nisstyre> is it correct to view _|_ as a type scheme for something that has no possible instances?
18:51:22 <YayMe> you know there was a _|_ but you have no idea why and therefore no recourse, thus why swallowing exceptions is bad
18:51:31 <ddarius> Nisstyre: _|_ is a value not a type.
18:51:37 <Nisstyre> ddarius: ah okay
18:51:51 <Tekmo> The type equivalent is forall r . r
18:52:00 <shachaf> Tekmo: How is that equivalent?
18:52:01 <jmcarthur> _|_ could also be a type, but it's not what we usually mean in haskell
18:52:15 <jmcarthur> shachaf: it's an initial object
18:52:25 <jmcarthur> so you have   _|_ -> a
18:52:26 <Nisstyre> jmcarthur: I'm just confused because I thought "top" meant a type that covers all possible instances
18:52:33 <shachaf> The only relation seems to be that _|_ happens to be the only inhabitant of forall r. r.
18:52:37 <Tekmo> I meant equivalent as in "What Nisstyre was probably thinking of"
18:52:45 <shachaf> Ah.
18:52:48 <jmcarthur> shachaf: Tekmo was talking about _|_ as a type, not as a value
18:53:08 <shachaf> Yes, but that type isn't really related to the value.
18:53:45 <Tekmo> So I came in to the discussion late, but I'm guessing there was some discussion about catching undefined?
18:53:48 * ddarius thinks he will attempt to watch a movie.
18:54:05 <jmcarthur> Tekmo: some jokes about spoon and then discussion
18:55:12 <jmcarthur> Tekmo: the only interesting quotes:  "<copumpkin> shachaf: if you can't observe them, then there's not much point in calling them distinct <shachaf> Says the author of spoon."
18:55:14 <appamatto> Anyone know about a service that will print academic papers?
18:55:40 <Nisstyre> appamatto: you should ask your school's library
18:55:47 <Nisstyre> they can probably help with bindings, etc...
18:56:00 <Nisstyre> also obviously use TeX to typeset it
18:56:28 <appamatto> Nisstyre: I'm just trying to print some pdfs to read offline instead of at my screen
18:56:39 <ddarius> appamatto: Kinko's etc?
18:56:47 <Nisstyre> appamatto: and you don't have a printer?
18:56:57 <Nisstyre> then just go to a kinkos like ddarius said
18:57:02 <Nisstyre> or whatever you have where you live
18:57:03 <Tekmo> Or the library
18:57:11 <ddarius> (Or buy a printer...)
18:57:13 <jmcarthur> Nisstyre: i am confused by your confusion about top. what do you mean by "I thought 'top' meant a type that covers all possible instances"?
18:57:15 <Tekmo> Printers are cheap
18:57:21 <copumpkin> misleadingly cheap
18:57:23 <appamatto> Yeah, I have a printer, not really looking forward to running hundreds of sheets through it
18:57:30 <jmcarthur> Nisstyre: "top" in haskell is ()
18:57:35 <Nisstyre> jmcarthur: I thought top was the type scheme you get for a function like id a = a
18:57:37 <Tekmo> What's the point of having a printer if you don't want to use it?
18:57:41 <jmcarthur> (which is another small lie)
18:57:45 <ddarius> appamatto: Just start it in the morning with a bunch of paper and finish when you get back from work/school/whatever.
18:57:58 <Nisstyre> jmcarthur: maybe I totally misunderstood something
18:57:59 <appamatto> Okay, you guys have convinced me :p
18:58:01 <Nisstyre> probably I did
18:58:11 <copumpkin> just don't print the papers
18:58:17 <copumpkin> read them on your computer
18:58:18 <Nisstyre> or Haskell uses different terminology than the stuff I've been reading
18:58:36 <Tekmo> Top is usually synonymous with the terminal object
18:58:40 <jmcarthur> Nisstyre: i'm not sure where your idea of top came from, to be honest
18:58:42 <appamatto> copumpkin: can't read what amounts to a book while standing in front of my machine. Plus I want to doodle
18:58:49 <ddarius> Nisstyre: This isn't really Haskell terminology, though the terminology is fairly overloaded.
18:59:06 <ddarius> In general, Top and Bottom refer to the elements of an arbitrary lattice, so you have to know what lattice is relevant.
18:59:07 <Tekmo> A terminal object is an object which every other object has a unique arrow to
18:59:14 <Nisstyre> jmcarthur: I'll see if I can dig up the paper I read it in
18:59:29 <Tekmo> In Haskell, you can always define a function from any type "a" to "()"
18:59:31 <ddarius> E.g. the bottom of the subtyping lattice is rather different than the bottom of the definability lattice.
18:59:39 <Tekmo> so "()" is a terminal object (barring undefined)
18:59:58 <ddarius> appamatto: Why are you standing in front of your computer?
19:00:00 <jmcarthur> gah! describing it in terms of lattices and in terms of categories! confusing. (the lattice explanation is probably more acceptable, i think).
19:00:05 <shachaf> Subtyping is a lattice?
19:00:14 <jmcarthur> i guess top and bottom for lattices and terminal and initial for categories makes the most sense
19:00:16 <shachaf> Isn't it just a semilattice in Haskell?
19:00:34 <Tekmo> What's the definition of semilattice?
19:00:36 <shachaf> I guess exists a. a would be one end.
19:00:40 <Tekmo> Yeah
19:00:42 <byorgey> well, Haskell doesn't have subtyping at all, so ...
19:00:44 <jmcarthur> Tekmo: only join or meet, not both
19:00:44 <Tekmo> I thought that was the initial object
19:00:48 <ddarius> Haskell doesn't have subtyping and lattices don't need bounds.
19:00:55 <ddarius> Subtyping usually permits both meets and joins.
19:00:57 <Tekmo> with absurd being the morphism from it to every other object
19:01:23 <ddarius> jmcarthur: A lattice is a special type of category.
19:01:29 <jmcarthur> yes
19:01:54 <ddarius> But the "bottom", "top" terminology definitely comes from lattice theory.
19:02:13 <shachaf> A well-ordered set is a partially-ordered set S such that for any non-empty subset T, there exists an element e in T such that e <= every element of T.
19:02:24 <shachaf> A semilattice is a partially-ordered set S such that for any non-empty subset T, there exists an element e in S such that e <= every element of T.
19:02:30 <shachaf> (Is that definition wrong? I like it.)
19:02:35 <jmcarthur> i only mean that "top" and "bottom" imply something more specific than "terminal" and "initial"
19:03:11 <ddarius> shachaf: Well, to begin with, being a lattice doesn't require infinite meets and joins.
19:03:28 <shachaf> ddarius: Oh, finite subset.
19:03:33 <shachaf> Fine. :-(
19:04:04 <ddarius> shachaf: That does make a big difference.
19:04:20 <shachaf> Yep.
19:04:27 <jmcarthur> Tekmo: exists a. a  would have to be the terminal object, no? you can create it from any type, but you can't extract anything from it
19:04:53 <ddarius> Modulo bottom, exists a. a ~ ()
19:05:03 <Tekmo> Well, it assumes that you don't use undefined or something similar
19:05:10 <shachaf> ddarius: Why modulo bottom?
19:05:11 <Tekmo> I know that's not rigorous
19:05:14 <jmcarthur> (that's neat that forall a. a is initial and exists a. a is terminal. i didn't realize that before)
19:05:26 <jmcarthur> sure
19:05:30 <ddarius> shachaf: Point, that's true in Haskell, but not for the () Tekmo was talking about.
19:05:31 <Tekmo> Oh wait
19:05:34 <Tekmo> Sorry, I misunderstood you
19:05:37 <Tekmo> I didn't see the exists
19:05:45 <jmcarthur> ah
19:05:51 <Tekmo> I thought it was a forall
19:06:16 <ddarius> jmcarthur: There's a fairly general fact about building colimits from limits over everything else and vice versa for small categories.
19:06:36 <dolio> shachaf: If you're using the existentials in GHC, exists a. a has 3 distinct inhabitants.
19:06:51 <dolio> Because it's required to be lifted.
19:06:52 <shachaf> dolio: GHC doesn't have first-class existentials.
19:06:57 <shachaf> Right.
19:07:16 <jmcarthur> it could be strict though
19:07:17 <ddarius> data E = forall a. E !a ?
19:07:32 <dolio> Yeah, that'd work, I guess.
19:07:43 <Tekmo> Wait
19:07:57 <Tekmo> So I'm still missing the isomorphism that ddarius and jmcarther were talking about
19:07:58 <Nisstyre> jmcarthur: http://en.wikipedia.org/wiki/Top_type
19:08:01 <ddarius> Also, newtype E where E :: a -> E
19:08:03 <Tekmo> I can see the two morphisms
19:08:05 <Nisstyre> this seems to express what I thought "top" means
19:08:12 <Tekmo> But it's hard for me to see how they are isomorphic
19:08:17 <dolio> ddarius: That doesn't work, does it?
19:08:32 <shachaf> Not in GHC.
19:08:36 <ddarius> Nisstyre: That's referring to subtyping.
19:08:42 <ddarius> Again, there are many different lattices.
19:09:08 <shachaf> Hmm, why can't a newtype be existential (if it doesn't have type class constraints)?
19:09:21 <dolio> shachaf: Arbitrary restriction.
19:09:34 <shachaf> dolio: What does this have to do with QuickCheck?
19:09:54 <jmcarthur> Tekmo: is there anything you can do with  exists a. a  that you can't do with  ()  or vice versa?
19:11:06 <aristid> what's the name of that "test" to determine if some generic function is worth writing instead of writing the expanded form every time?
19:11:22 <aristid> it's been mentioned here a couple times
19:11:37 <Nisstyre> aristid: I don't see why you wouldn't want the most generic version all the time
19:11:37 <jmcarthur> aristid: const True?  ;)
19:11:37 <shachaf> Is it the "Are you writing in Haskell?" test?
19:11:48 <Nisstyre> aristid: unless you're getting errors and you want better error messages
19:11:58 <shachaf> Nisstyre: There are lots of reasons not to want the most generic version.
19:12:13 * shachaf was making fun of #haskell a bit, but it looks like it was unnecessary.
19:12:14 <aristid> i think i didn't phrase what i meant properly.
19:13:02 <aristid> i mean if it's worth writing functions like (.:) = (.).(.) which might be useful sometimes instead of writing (f.).g
19:13:43 <Tekmo> The common sense test
19:13:52 <jmcarthur> Tekmo: i apologize for requesting that you attempt to disprove the isomorphism instead of proving it myself, but i don't think i have the ability to prove it
19:13:53 <aristid> Tekmo: that name is too polymorphic!
19:14:03 <Tekmo> No apologies necessary
19:14:06 <Nisstyre> the "a" test
19:14:10 <Tekmo> I was just curious
19:14:23 <ddarius> aristid: Fairbairn.
19:14:29 <Tekmo> I'm not at all a stickler for rigor
19:14:52 <Tekmo> I personally never use (.:)
19:15:02 <Tekmo> I always expand it out
19:15:05 <ddarius> jmcarthur: I'd think you'd be able to prove it yourself.  Simply write the functions.
19:15:06 <aristid> ddarius: thanks
19:15:10 <jmcarthur> i prefer SECs over things like (.:)
19:15:10 <ddarius> Then enumerate the cases.
19:15:23 <jmcarthur> ddarius: heh, point
19:15:29 <Tekmo> The real question you should ask is
19:15:35 <Tekmo> who will be reading your code
19:15:42 <Tekmo> Write to that audience
19:15:54 <jmcarthur> (result . result) f g
19:16:15 <ddarius> If the answer to that is "no one", what is the answer to the original question?
19:16:32 <Tekmo> Then the audience is yourself, a year from now
19:16:43 <ddarius> That would be someone.
19:17:06 <Tekmo> Then write something you'd be able to read clearly after leaving it off for a year or so
19:17:10 <dolio> jmcarthur, Tekmo: The free theorem for 'f :: forall a. a -> (exists a. a)' says that forall x y. f x = f y. So the 'constructor' of exists a. a in GHC takes all inputs to the same element.
19:17:42 <dolio> So there is only one.
19:17:51 <Tekmo> Oh, nice
19:18:02 <ddarius> dolio: I think you meant to say "So there can be only one."
19:18:13 <dolio> Damn. I've been watching Highlander, too.
19:19:10 <dolio> Of course, seq and such make things a little more complicated.
19:19:17 <Tekmo> But regarding (.:), another rule of thumb is
19:19:24 <Tekmo> whether or not it scales
19:19:30 <ddarius> We should eliminate seq.  pseq ho!
19:19:40 <Tekmo> For example, would you be willing to write the equivalent for 3 or 4 arguments?
19:19:48 <Tekmo> It's a brittle abstraction in that respect
19:19:53 <Tekmo> Same thing with 3+-tuples
19:20:08 <Tekmo> Would you be willing to write accessors for all tuples sizes greater than 2?
19:20:17 <jmcarthur> SECs, on the other hand, scale quite nicely
19:20:27 <ku> I am a Haskell newbie and I'm trying to understand why Haskell prefers to embed type info in functions rather than values, TIA
19:20:30 <Tekmo> What is SEC an abbreviation for?
19:20:42 <jmcarthur> semantic editor combinator, iirc
19:20:42 <ku> so FP vs. OOP
19:20:43 <shachaf> Teko: Something Editor Combinators
19:20:47 <Tekmo> Oh yeah
19:20:51 <Tekmo> I agree
19:20:59 <shapr> ddarius: Yah, prolog for my class
19:21:01 <Tekmo> I always just use nested pairs
19:21:08 <ddarius> shapr: Interesting.
19:21:12 <jmcarthur> (result . result . result . result) f g
19:21:13 <ddarius> shapr: What do you think?
19:21:24 <shapr> ku: functions are values?
19:21:27 <jmcarthur> == f ...: g ?
19:21:45 <shapr> ddarius: It's interesting... it feels a bit like Haskell in some ways, but I can't say I understand it well.
19:21:50 <jmcarthur> f .::: g, perhaps
19:21:56 <shapr> ddarius: It feels more like a really crappy theorem prover.
19:21:56 <Tekmo> What is result?
19:22:13 <shapr> ku: I don't really understand your question.
19:22:17 <shachaf> shapr: Is that referring to the theorems or to the prover?
19:22:28 <jmcarthur> Tekmo: just a renaming of (.), meant to be read such that "result f g" means "apply f to the result of g"
19:22:39 <shapr> Prolog feels like a terribly cut down proof assistant.
19:22:47 <ddarius> shapr: ku never asked a question so it's not surprising you don't understand it.
19:22:58 <jmcarthur> Tekmo: so  (result . result . result) f g  means "apply f to the result of the result of the result of g"
19:23:06 <shapr> ddarius: It was an implied question, FP vs OOP
19:23:24 <ku> shapr: why does haskell store per-type operations in functions instead of storing per-method operations in values/objects?
19:23:47 <Tekmo> I think he means
19:23:53 <Tekmo> Why we don't store associated methods like in OOP
19:24:02 <Tekmo> and we separate transformations on the data from the data definition
19:24:12 <shapr> That seems far more sensible to me.
19:24:25 <shapr> But maybe that's because I'm used to typeclasses.
19:24:28 <jmcarthur> ku: your questions seems mislead, somewhat. are you contrasting ADTs to subclasses?
19:25:16 <startling> what's the way to define a type and constructors in a record field? or am I just imagining that that exists?
19:25:23 <ku> jmcarthur: ADTs vs. classes
19:25:43 <YayMe> ku: I'm not near as bright as other's here but I would say when handling functions you're handling the computation that generates values, those values can't be modified by other parts of the system because they don't even exist, just the definition of how to get them exists
19:26:01 <YayMe> or something like that? But I really don't know this stuff
19:26:06 * ddarius returns to attempting to watch a movie.
19:26:15 <shachaf> ddarius: Which movie are you attempting to watch?
19:26:17 <Tekmo> Are you talking about Java-style classes?
19:26:22 <shapr> ku: Typeclasses store per-type functions together. One good example is (+), which is different for Int, Float, and others.
19:26:41 <cmccann> aw, did I miss a conversation about "Bottom = forall a. a" and "Top = exists a. a" as sorta making sense as a subtype hierarchy?
19:27:00 <dolio> It makes lots of sense.
19:27:05 <shachaf> cmccann: Pay closer attention next time.
19:27:06 <dolio> Polymorphism induces subtyping.
19:27:17 <dolio> If you bother to handle it.
19:27:18 * cmccann even made a joke library for that months ago
19:27:38 <ddarius> shachaf: I haven't gotten that far yet.
19:27:43 <dolio> Which GHC doesn't, really.
19:28:06 <Tekmo> startling: I don't think you can define a type in the middle of another type
19:28:15 <jmcarthur> ku: ADTs put all the code for a function in one place. Objects put all the code for a type in one place. there are benefits to both approaches.
19:28:29 <ku> shapr: my question is why haskell stores the per-typeclass procedure in a shared function (simplified) instead of carrying the per-function procedure in a shared object (like Python)
19:28:59 <ku> jmcarthur: that is my question: what is the haskell design rationale for choosing ADTs?
19:29:09 <Tekmo> If you store it in the object, how would you check at compile time if the object supported the call?
19:29:10 <jmcarthur> ku: when all the code for a function is in one place, it makes it easier to know the meaning of an expression because it's easier to find the meaning of its subexpressions
19:29:14 * cmccann considered defining Top and Zero with exists/forall in his toy linear logic, as well
19:29:16 <ddarius> dolio: Indeed.  In HM, an instance of a polymorphic type is a sub-/super-type of the type.
19:29:18 <YayMe> ku: so you're asking, why is it not float.Add
19:29:20 <YayMe> ?
19:29:20 <shachaf> "Haskell" doesn't really do either as such.
19:29:25 <ku> I'm asking this because my favorite langs right now are Python and Haskell
19:29:27 <shapr> ku: Typeclasses are dictionaries that get passed around, so they seem like shared objects to me.
19:29:45 <shachaf> You can do either in Haskell perfectly well.
19:29:48 <startling> I'm half-remembering a syntax like data Prefix = Group1 { as1 :: X | B }.
19:29:52 <jmcarthur> ku: that is, if you have some function "foo" and you don't know what it does, you just look up its definition. if it's a method on some random superclass, you don't know what the code you're about to execute is
19:29:57 <dolio> GHC doesn't really bother to handle it, by the way.
19:30:15 <benmachine> startling: sounds crazy
19:30:19 <jmcarthur> shapr: i'm not sure ku is talking about type classes
19:30:24 <ddarius> startling: The only thing that might vaguely be similar to what you're talking about are TREX in Hugs.
19:30:32 <ddarius> I forget their syntax.
19:30:32 <Nisstyre> ddarius: so I wasn't crazy with my usage of top/bottom as supertypes?
19:30:34 <ku> jmcarthur: but then it's more difficult to have libraries that work with third-party handlers
19:30:37 <startling> yeah, I don't think that's it
19:30:40 <startling> thanks anyway
19:30:44 <ku> like Python does with duck typing
19:30:50 <Nisstyre> er. top as a supertype
19:30:52 <jmcarthur> ku: higher order functions solve this
19:30:53 <Nisstyre> not bottom
19:30:55 <dmwit> startling: There's data Foo = Bar { a, b :: X }
19:31:06 <startling> dmwit, that's different. :)
19:31:10 <ddarius> Nisstyre: No, though id's type is not top by any means, but subtyping (or in fact typing at all) is not what people are talking about when they say "bottom" here typically.
19:31:23 * dmwit nods agreeably
19:31:27 <jmcarthur> ku: as do type classes, as shapr is talking about, which are somewhat the same thing as higher order functions in some sense that probably isn't worth getting into right now
19:31:30 <Nisstyre> ddarius: okay, I'll take a note of that
19:31:42 <QUACKALPACATRON> >> length "stri ̈ng"
19:31:48 <QUACKALPACATRON> Ehh
19:31:48 <ddarius> @google "definability ordering"
19:31:50 <lambdabot> http://www.ccs.neu.edu/home/riccardo/papers/msc-thesis.pdf
19:31:50 <lambdabot> Title: INVESTIGATIONS ON RELATIVE DEFINABILITY IN PCF
19:32:18 <QUACKALPACATRON> > lengh "strïng"
19:32:19 <lambdabot>   Not in scope: `lengh'
19:32:22 <QUACKALPACATRON> > lenght "strïng"
19:32:23 <lambdabot>   Not in scope: `lenght'
19:32:30 <QUACKALPACATRON> Really?
19:32:34 <QUACKALPACATRON> Ohh
19:32:37 <Tekmo> ku: Type classes are about type-based inference, not value-based inference
19:32:39 <shachaf> QUACKALPACATRON: You can /msg lambdabot, you know.
19:32:46 <QUACKALPACATRON> That is true, aprdon
19:32:51 <Tekmo> So when you invoke a method of a type-class, it only checks the value's type, not its value
19:32:54 <Nisstyre> /query lambabot
19:32:59 <Tekmo> This is why we don't associate type-class instances with objects
19:33:05 <Tekmo> we associate them with the types themselves
19:33:08 <ku> that kind of makes sense, thanks
19:33:31 <QUACKALPACATRON> Yeah, so it turns out it's 7. Does anyone know if there's a unicode aware string library for haskell some-where?
19:33:31 <jmcarthur> oh, the question *was* about type classes
19:33:33 <YayMe> Anyone here particularly familiar with C#?
19:33:51 <shachaf> > length "strïng"
19:33:52 <lambdabot>   6
19:33:54 <Tekmo> @hackage test
19:33:54 <lambdabot> http://hackage.haskell.org/package/test
19:33:57 <Tekmo> Oops
19:33:58 <jmcarthur> QUACKALPACATRON: haskell's built in strings handle unicode. there's also the text library
19:33:58 <shapr> YayMe: er, why?
19:34:01 <Tekmo> @hackage text
19:34:01 <lambdabot> http://hackage.haskell.org/package/text
19:34:01 <QUACKALPACATRON> I didn't use that string
19:34:06 <QUACKALPACATRON> I used a combining character
19:34:07 <dmwit> QUACKALPACATRON: It's 6 here.
19:34:11 <shachaf> QUACKALPACATRON: Yes, I know.
19:34:17 <dmwit> QUACKALPACATRON: I would blame IRC sooner than I'd blame GHC on this one.
19:34:17 <QUACKALPACATRON> Not "ï" but i+combining diaereses
19:34:22 <shachaf> dmwit: No, it's a Unicode thing.
19:34:43 <shachaf> But "glyphs" or "characters" or something like that is a hard thing to work with.
19:34:49 <YayMe> shapr: I'm thinking that type classes in haskell are like static extensions in C#, is that a fairly appropriate simile?
19:34:54 <cmccann> unicode is hard to work with
19:35:01 <shachaf> You'll need a specialized library.
19:35:05 <ddarius> YayMe: Not really, no.
19:35:11 <shachaf> I think there are ICU bindings? I don't know if that does it.
19:35:12 <byorgey> Unicode is hard.  Let's go shopping!
19:35:15 <QUACKALPACATRON> Surely someone must have written a library that basically follows the unicode mandates?
19:35:20 <ddarius> YayMe: By "static extensions" you mean "extension methods"?
19:35:22 <dmwit> Hm, seems I should blame whatever is handling copy-and-paste into my terminal.
19:35:36 <dmwit> So, some combination of screen, irssi, and urxvt.
19:35:41 <YayMe> ddarius: same difference, they must be static and in a static class
19:35:54 <jmcarthur> type classes are just functions that are determined based on types
19:35:59 <jmcarthur> err
19:36:03 <jmcarthur> s/functions/values/
19:36:11 <YayMe> ddarius: I think? I generally hear them called static extensions, as in "public bla(this Something target)"
19:36:17 <shachaf> dmwit: Maybe... ï and i + combining ¨ are considered equivalent.
19:36:19 <jmcarthur> wow, i really fudged the terminology there
19:36:22 <ComeBack> Hello
19:36:37 <sentientwaffle> how does `map` (over regular lists) never overflow the stack?
19:36:52 <shapr> ComeBack: Learning Haskell?
19:36:52 <YayMe> jmcarthur: I'm pretty sure I understand type classes, but I think this simile holds true and if anyone here is familiar with C# static extensions I'd be curious to hear how it doesn't hold true
19:36:54 <shachaf> sentientwaffle: Evaluate it non-strictly by hand and you'll see.
19:36:55 <dmwit> shachaf: very likely, yes
19:36:58 <Tekmo> Tail call optimization
19:37:08 <shachaf> Tekmo: Huh?
19:37:11 <jmcarthur> Tekmo: i don't think that's true at all
19:37:16 <cmccann> more like the exact opposite of tail call optimization
19:37:42 <jmcarthur> it's just that map is "productive"
19:37:50 <Tekmo> I thought there must be tail-call optimization since it calls itself
19:37:51 <shachaf> Talking about "tail call optimization" doesn't even really make sense in Haskell, as such.
19:37:57 <sentientwaffle> I dont thinks it can be TCOd
19:38:04 <jmcarthur> @src map
19:38:04 <lambdabot> map _ []     = []
19:38:05 <lambdabot> map f (x:xs) = f x : map f xs
19:38:05 <shachaf> It calls itself but it's not a tail call.
19:38:06 <cmccann> foldl is tail recursive, I think.
19:38:06 <ddarius> YayMe: I've never heard them called "static extensions" and the C# spec calls them "extension methods" which is the only term I've heard used for them
19:38:14 <cmccann> which is why it explodes if you're not strict enough
19:38:15 <YayMe> ddarius: Is there something else in Haskell that is a simile of static extensions which I'm mistaking "type classes" for?
19:38:19 <Nisstyre> @src foldl
19:38:19 <lambdabot> foldl f z []     = z
19:38:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:38:24 <jmcarthur> that isn't even tail recursive (and if it was, *then* it might stack overflow, funny enough)
19:38:34 <ddarius> YayMe: Extension methods are just an extremely minor syntactic sugar.
19:38:35 <jmcarthur> yeah, foldl can actually stack overflow!
19:38:45 <Tekmo> foldl does stack overflow
19:38:52 <jmcarthur> not always
19:38:57 <YayMe> ddarius: I realize that, but the rules they follow seems similar to type classes no?
19:39:02 <ddarius> YayMe: No.
19:39:07 <YayMe> Okey dokey
19:39:16 <jmcarthur> ghc will sometimes notice and make the accumulator strict for you
19:39:22 <jmcarthur> depending on the call site, i think
19:39:27 <benmachine> in fairness, foldl doesn't stack overflow because the recursive calls to foldl build up
19:39:38 <cmccann> it won't stack overflow if the accumulation is strict, which should end up amounting to typical tail recursion
19:39:47 <benmachine> it stack overflows because the accumulator... accumulates
19:39:47 <ddarius> cmccann: It being tail recursive has nothing to do with why it does or does not stack overflow.
19:39:50 <sentientwaffle> so the reason map doesnt overflow is b/c of lazy evaluation?
19:40:03 <ddarius> cmccann: In fact, foldl never stack overflows.  What stack overflows is the reduction of the chain of thunks built up.
19:40:14 <Nisstyre> benmachine: because it's not needed until the function is matched with '[]' correct?
19:40:20 <ddarius> cmccann: foldl is tail recursive.
19:40:25 <Nisstyre> or in other words, until it reaches the base case
19:40:34 <YayMe> cmccann: the other day I was told it was impossible to stack overflow in haskell because it has no stack (except for pattern matches), is that inaccurate? It sounded fishy to me but I wouldn't know
19:40:40 <benmachine> Nisstyre: yeah, something like that
19:40:44 <dmwit> It is inaccurate.
19:40:54 <YayMe> I thought so
19:40:54 <jmcarthur> YayMe: it has a stack, but it's not the same as the C stack
19:40:55 <dmwit> However, it's very uncommon with modern GHCs' dynamic stack.
19:40:56 <ddarius> TCO is as important in Haskell as it is in pretty much every other language.
19:40:56 <cmccann> YayMe, listen to ddarius if you want the precise explanation :P
19:41:00 <benmachine> Haskell doesn't have a stack like other language's stacks
19:41:15 <dmwit> Also, the stack is not used for what you might think of from traditional languages.
19:41:17 <YayMe> it can still stackoverflow if you don't use an accumulator in your recursion though, no?
19:41:22 <dmwit> No.
19:41:29 <dmwit> That is not where a stack overflow will come from in Haskell.
19:41:32 <benmachine> in particular, Haskell doesn't push a stack frame on every function call
19:41:34 <benmachine> that would be silly
19:41:35 <jmcarthur> YayMe: thunks that the runtime enters are pushed on the stack rather than haskell functions that are called
19:41:40 <ddarius> http://www.youtube.com/watch?feature=player_detailpage&v=J0c4L-AURDQ#t=149s
19:41:55 <YayMe> jmcarthur: so the thunk can cause stack overflow?
19:42:00 <jmcarthur> right
19:42:01 <shachaf> ddarius: That's not like dolio's youtube.com links at all!
19:42:11 <YayMe> jmcarthur: but not because of too many thunks, but rather the size of the thunk, no?
19:42:19 <Nisstyre> YayMe: it has to do with the call by need semantics
19:42:24 <ddarius> benmachine: Very few languages, including Haskell, specify whether or not "stack frames" are "pushed" on function calls.
19:42:27 <jmcarthur> normally because of too many thunks
19:42:34 <YayMe> oh
19:42:36 <jmcarthur> a long chain of thunks
19:42:36 <benmachine> ddarius: fair point
19:42:38 <Nisstyre> YayMe: in the example of foldl
19:42:39 <YayMe> so too much !
19:42:47 <ddarius> In fact, Haskell says nothing at all about tail call elimination, so having f x = f x stack overflow would be completely acceptable.
19:42:48 <Nisstyre> the accumulated value is not needed until the function returns at the base case
19:42:55 <Nisstyre> YayMe: so, it doesn't compute it till then
19:43:08 <ddarius> I'm pretty sure R5RS doesn't talk about "stack frames" and "pushing" either.
19:43:08 <Nisstyre> but it can build up a massive number of thunks before that happens
19:43:10 <shachaf> "very few language, including Haskell, do X" means that Haskell *doesn't* do X, by the way.
19:43:13 <startling> is there a clever way of encoding "a list whose length is less than or equal to 4" in the type system?
19:43:16 <YayMe> Nisstyre: Right I know that, but when the thunk happens, does it happen in one stack frame or does the thunk generate a stack frame for each piece of the chain?
19:43:21 <jmcarthur> YayMe: say we have this:   sum [] acc = acc; sum (x:xs) acc = sum xs (x + acc)
19:43:25 <Nisstyre> YayMe: not sure
19:43:33 <ddarius> shachaf: Please retroactively correc.t
19:43:34 <jmcarthur> YayMe: acc is not evaluated during the evaluation of that function
19:43:39 <shachaf> startling: type Foo a = (a, Maybe (a, Maybe (a, Maybe a)))
19:43:50 <shachaf> Er, Maybe of that.
19:43:54 <startling> shachaf: oh, that works. yeah
19:44:05 <jmcarthur> YayMe: so if you apply that to a long list and then evaluate it, you will have to enter a thunk, then another, then another, then another, etc.
19:44:36 <shachaf> R5RS does specify something about tail calls, does it?
19:44:46 <ddarius> shachaf: Yes, but I don't believe it talks about "stacks".
19:44:48 <shachaf> s/s i/sn't i/
19:44:50 <jmcarthur> YayMe: before evaluation, acc just looks like   a + b + c + d + e + ... + z
19:44:58 <jmcarthur> YayMe: each addition is another thunk
19:45:12 <ddarius> The point being that TCE is not about "pushing or not pushing stack frames".
19:45:15 <Tekmo> YayMe: I checked out static extensions and I think they are similar to type classes
19:45:24 <shachaf> You don't really need to talk about thunks to understand this, do you?
19:45:31 * shachaf .monochrom.moed
19:45:37 <YayMe> jmcarthur: So I'm misunderstanding thunks, I was thinking of a thunk as something that occurs once for a chain of calculations, you're saying it happens once for each piece in the chain (though at a delayed time obviously because it's only as needed)
19:45:49 <ddarius> Tekmo: Extension methods just let you write SomeStaticMethod(obj, arg) as obj.SomeStaticMethod(arg).
19:45:57 * Nisstyre likes the gift metaphor
19:45:58 <startling> YayMe, a thunk is just a tree of expressions
19:46:04 <ddarius> Like, literally, the former syntax is still legal for extension methods.
19:46:06 <jmcarthur> YayMe: a thunk is just a delayed computation. forcing it might or might not in turn require forcing other thunks
19:46:06 <Tekmo> Yes, but you can restrict them to a certain type
19:46:11 <Nisstyre> or maybe those eggs with eggs inside of them >.>
19:46:25 <Tekmo> Oh wait, I see what you mean
19:46:36 <Tekmo> You can't program generically over the extension name
19:46:40 <shachaf> «A Scheme implementation is properly tail-recursive if it supports an unbounded number of active tail calls.»
19:46:51 <YayMe> jmcarthur: I was thinking for instance length "abcdefghijklmnopqrstuvwxyz" will have a single thunk at the end or maybe upon need of the actual length or at some generally non-deterministic time (non-deterministic if you don't have a ! somewhere)
19:47:04 <jmcarthur> YayMe: in the case of that sum function, each recursive step builds another thunk on top of acc
19:47:09 <YayMe> jmcarthur: You're saying there will be 26 thunks for that function call
19:47:10 <Nisstyre> YayMe: depends on the implementation of length
19:47:26 <shachaf> @src length
19:47:26 <lambdabot> Source not found. :(
19:47:27 <jmcarthur> YayMe: it will be one thunk that depends on another the depends on another, etc.
19:47:35 <jmcarthur> YayMe: it's still only "one" thunk, though
19:47:42 <jmcarthur> just nested
19:47:51 <ddarius> Actually, that video I referenced (mainly for Simon Marlow saying "TCO is essential") also has a lot of sense in it.  E.g. being able to control how many stack frames we keep for debugging purposes and providing some kind of semantics for stack traces.
19:47:55 <YayMe> jmcarthur: and one stack frame?
19:48:20 <jmcarthur> YayMe: whenever you start evaluating a thunk, you push some data to the stack.
19:48:40 <jmcarthur> YayMe: so if you have to evaluate one inside another inside another inside another, you end up with more on the stack
19:48:57 <YayMe> jmcarthur: more data on the stack or more frames on the stack?
19:49:10 <jmcarthur> YayMe: think of a thunk as just a function along with some arguments to call it with
19:49:34 <jmcarthur> actually, that's basically what a thunk in ghc literally is
19:49:42 <YayMe> jmcarthur: you're "one" thunk idea is really speaking of something definite that is not the same as the "nested thunks" you spoke of
19:50:23 <Tekmo> So, until you call length
19:50:25 <Tekmo> it is a single thunk
19:50:29 <Tekmo> I mean
19:50:32 <Tekmo> until you need its result
19:50:35 <shachaf> You don't need to talk about thunks to understand laziness.
19:50:47 <jmcarthur> you're just holding on to the head of a chain of thunk, but you can't always know that it's a chain of thunks without knowing the thunk's origin
19:50:50 <shachaf> @google trebla lazy
19:50:51 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
19:50:58 <jmcarthur> shachaf: we are talking about stack overflows
19:51:15 <jmcarthur> in ghc
19:51:26 <YayMe> shachaf: I'm not having difficulty with laziness, I'm trying to understand the behavior of stack and stack frames in haskell because I've heard a number of conflicting things said
19:51:46 <YayMe> I *have* read before that if you don't use an accumulator you'll get a stack overflow in haskell
19:52:12 <jmcarthur> it depends
19:52:15 <YayMe> (in recursion scenarios where an accumulator would be obviously necessary)
19:52:20 <ddarius> YayMe: That's a massively simplistic and wrong view of stack behavior in Haskell.
19:52:23 <Nisstyre> YayMe: except the foldl function is tail recursive
19:52:31 <YayMe> ddarius: Which I'm realizing, and why I'm asking the questions
19:52:45 <ddarius> YayMe: So where did you hear that?
19:52:50 <Tekmo> Here's the implementation for length:
19:52:50 <YayMe> Nisstyre: Isn't every functino tail recrusive that can use an accumulator?
19:52:51 <Tekmo> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#length
19:52:57 <Nisstyre> YayMe: not necessarily
19:53:07 <Tekmo> They use a strict accumulator
19:53:46 <YayMe> Here's my understanding: tail optimization is possible as long as a function doesn't need itself evaluated for one of it's parameters
19:54:13 <shachaf> YayMe: "tail optimization" isn't really a thing that exactly makes sense to talk about.
19:54:32 <ddarius> YayMe: Tail call "optimization" is applicable to all tail calls.  Whether a call is a tail call or not is a simple syntactic property.
19:54:33 <Tekmo> I also checked the naive length implementation
19:54:35 <Tekmo> if you just write
19:54:49 <Tekmo> length xs = case xs of [] -> 0; _:ys -> 1 = length ys
19:54:52 <Tekmo> You get a stack overflow
19:54:53 <ddarius> Whether a function will result in stack overflows directly or indirectly depends on several other factors as well.
19:55:12 <ddarius> Tekmo: Not with that definition...
19:55:24 <ddarius> s/1 =/1 +/
19:55:27 <Tekmo> Yeah
19:55:28 <jmcarthur> > let len [] = 0; len (_:xs) = 1 + len xs in len [1..9999999]
19:55:30 <lambdabot>   *Exception: stack overflow
19:55:33 <Tekmo> 1 + length ys
19:56:11 <Nisstyre> YayMe: http://ideone.com/9y4Ve
19:56:11 <Tekmo> So, to explain for YayMe
19:56:18 <Tekmo> When you write the naive version
19:56:20 <Tekmo> and try to evaluate it
19:56:21 <Tekmo> you get
19:56:24 <jmcarthur> > let len xs = let go [] !acc = acc; go (_:xs) !acc = go xs (1+acc) in go xs 0 in len [1..9999999]
19:56:25 <startling> shachaf: any idea how to work nicely on that kind of Maybe chain?
19:56:28 <lambdabot>   mueval-core: Time limit exceeded
19:56:32 <Tekmo> 1 + (1 + (1 + (1 + (1 + (1...
19:56:35 <jmcarthur> beats a stack overflow at least
19:56:36 <Nisstyre> YayMe: hopefully you understand that syntax, anyway
19:56:38 <Tekmo> Each of those parentheses
19:56:41 <shachaf> startling: It wasn't a serious suggestion. :-(
19:56:47 <Nisstyre> that is a non tail-recursive function with an accumulator
19:56:49 <Tekmo> represents a thunk that gets created when you try to demand the value from length
19:56:51 <startling> shachaf: >:(
19:56:56 <Tekmo> which is why the naive version overflows
19:57:00 <shachaf> startling: I thought that was clear, sorry.
19:57:06 <centrinia> > let len [] =  0; len xs = fst $ last $ zip [1..] xs in [1..9999999]
19:57:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:57:15 <jmcarthur> > let len xs = let go [] acc = acc; go (_:xs) acc = go xs (1+acc) in go xs 0 in len [1..9999999]
19:57:19 <lambdabot>   mueval-core: Time limit exceeded
19:57:21 <YayMe> > let lenAcc [] acc = acc; lenAcc (_:xs) acc = len xs (acc+1)
19:57:22 <lambdabot>   not an expression: `let lenAcc [] acc = acc; lenAcc (_:xs) acc = len xs (ac...
19:57:40 <Nisstyre> YayMe: did you see my scheme example?
19:57:44 <centrinia> > let len [] =  0; len xs = fst $ last $ zip [1..] xs in len [1..9999999]
19:57:46 <lambdabot>   9999999
19:57:47 <jmcarthur> interesting that removing the bangs didn't make that overflow. maybe it would have given more time
19:57:57 <centrinia> > let len [] =  0; len xs = fst $ last $ zip [1..] xs in len [1..9999999999]
19:58:01 <lambdabot>   mueval-core: Time limit exceeded
19:58:07 <centrinia> > let len [] =  0; len xs = fst $ last $ zip [1..] xs in len [1..999999999]
19:58:11 <lambdabot>   mueval-core: Time limit exceeded
19:58:11 <ddarius> jmcarthur: Lambdabot compiles with optimizations.
19:58:35 <jmcarthur> ddarius: it also didn't overflow in ghci, but i'm not sure if its execution model is different somehow
19:58:39 <YayMe> Nisstyre: I'm not sure what the purpose of your example is?
19:58:42 <jmcarthur> it did use up a lot of memory
19:58:54 <Nisstyre> YayMe: you asked if all functions with accumulator are tail recursive
19:58:59 <Nisstyre> YayMe: I said no, and that is proof
19:59:02 <ddarius> jmcarthur: Then give it more time.
19:59:25 <shachaf> 999999999 is a big number.
19:59:26 <YayMe> Nisstyre: it didn't stackoverflow so it doesn't prove not to be tail optimized..
19:59:40 <shachaf> Not as big as 1000000000, though.
19:59:45 <Nisstyre> YayMe: Racket (which is what I ran it with) probably optimizes that away
20:00:00 <Nisstyre> YayMe: or it didn't fill up the amount of memory the vm has
20:00:18 <YayMe> Nisstyre: The second is possible, but if the first is the case then you just admitted it is tail optimized
20:00:35 <Nisstyre> YayMe: I never claimed it couldn't be optimized
20:00:39 <Nisstyre> sorry if you got that impression
20:01:01 <YayMe> Nisstyre: Ohh you misunderstood me, I was saying all functions with a cumulator *can* be tail optimized
20:01:10 <YayMe> Nisstyre: (by my understanding of the term "accumulator")
20:01:13 <Nisstyre> YayMe: eh, well
20:01:22 <Nisstyre> that's not necessarily true either, but I don
20:01:30 <Nisstyre> don't know enough about the intricacies of optimization
20:01:47 <jmcarthur> YayMe: tail call optimization only applies to tail calls
20:01:49 <ddarius> YayMe: You are not understanding "tail optimized".
20:02:08 <Hail_Spacecake> I have a list of strings
20:02:34 <jmcarthur> YayMe: there are often ways to write functions that have accumulators using tail recursion, but rewriting them that way isn't not itself tail call optimization. it only *enables* tail call optimization.
20:02:40 <Nisstyre> YayMe: you are confusing "accumulating function" with "tail recursive"
20:02:41 <jmcarthur> *is not itself
20:02:46 <YayMe> ddarius: tco is when a recursive function is executed as a loop in a single stack frame rather than in successive stack frames, this is overly simplistic definition? this is inaccurate?
20:02:57 <ddarius> YayMe: Yes and yes.
20:02:58 <applicative> yes Hail_Spacecake ?
20:03:12 <Hail_Spacecake> and I want to do something based on whether the second element of that list
20:03:15 <Hail_Spacecake> 1) exists and 2) is parseable as an integer
20:03:19 <YayMe> ddarius: Please explain, I really have this stuff understood poorly it sounds like
20:03:27 <Tekmo> So what you do is
20:03:28 <Nisstyre> YayMe: you should really read SICP
20:03:34 <Tekmo> You can split it into two functions
20:03:40 <Tekmo> the first "maybe" gets the second element
20:03:41 <ddarius> YayMe: TCO is, in overly operational terms, simply not pushing a stack frame that will just immediately be removed on return.  This applies to all tail calls and can always be done.  They don't need to be recursive.
20:03:41 <Tekmo> i.e.
20:03:48 <Tekmo> firstFunction :: [a] -> Maybe a
20:03:56 <Tekmo> The second function "maybe" succeeds at parsing it
20:04:03 <Tekmo> secondFunction :: String -> Maybe Int
20:04:08 <Tekmo> Then you just compose them
20:04:11 <Nisstyre> all tail recursive functions can be tail call optimized
20:04:12 <shachaf> Uh-oh, Tekmo is going to >=>
20:04:13 <Tekmo> using Kleisli composition
20:04:16 <Tekmo> :)
20:04:17 <shachaf> DOn't do it, Tekmo!
20:04:19 <shachaf> Too late.
20:04:24 <jmcarthur> ddarius: how is that overly operational? is there a more general way to describe TCO?
20:04:27 <ddarius> Nisstyre: Calls get optimized, not functions.
20:04:29 <Tekmo> firstFunction >=> secondFunction
20:04:34 <Tekmo> Which in do notation is
20:04:36 <Nisstyre> ddarius: fair enough
20:04:39 <YayMe> according to C2 "Tail-call optimization (or tail-call merging or tail-call elimination) is a generalization of TailRecursion: If the last thing a routine does before it returns is call another routine, rather than doing a jump-and-add-stack-frame immediately followed by a pop-stack-frame-and-return-to-caller, it should be safe to simply jump to the start of the second routine, letting it re-use the first routine's stack frame
20:04:39 <YayMe> (environment)."
20:04:40 <jmcarthur> shachaf: lol
20:04:50 <Hail_Spacecake> well, I'm not sure if a maybe pattern is exactly what I need
20:04:54 <Tekmo> do { secondElement <- firstFunction listofStrings; secondFunction secondElement }
20:04:54 <ddarius> jmcarthur: There are some, but this presumes a definition of "stack frame" which is rarely defined and often non-existent.
20:05:02 <Hail_Spacecake> because what I want to do is if it doesn't exist
20:05:03 <YayMe> ddarius: Is that accurate?
20:05:07 <Memee> wee, this is fun!
20:05:17 <shachaf> Tekmo: You forgot the \listofStrings -> at the beginning.
20:05:20 <Tekmo> Yeah
20:05:21 <Hail_Spacecake> is use a defualt value
20:05:23 <ddarius> YayMe: Yes, if overly specific/operational.
20:05:26 <Tekmo> \listOfstrings -> do {... }
20:05:27 <Hail_Spacecake> so I'm always going to have this function return an int
20:05:37 <jmcarthur> @remember shachaf <Tekmo> Then you just compose them <shachaf> Uh-oh, Tekmo is going to >=> <Tekmo> using Kleisli composition
20:05:37 <lambdabot> Done.
20:06:04 <Hail_Spacecake> so, basically I need a test for like
20:06:21 <Hail_Spacecake> if myList !! 1 can be read in as an integer
20:07:02 <Tekmo> You mean you want a default value if it fails?
20:07:28 <ddarius> jmcarthur: It's hard to pin down TCO precisely because there's nothing to "optimize" in archetypical operational semantics of function calls, e.g. (syntactic) beta reduction.  TCO is an "optimization" that fixes broken function call implementations.  It's like making arrays with O(n) lookup, and then having an "array access optimization" that makes them O(1).
20:07:50 <ddarius> Most people would just say you have broken arrays not that there is a wondrous optimization that makes arrays constant time.
20:07:51 <Nisstyre> YayMe: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_1.2
20:08:04 <Hail_Spacecake> yeah
20:08:08 <applicative> > reads "22" ::[(Int,String)]
20:08:09 <lambdabot>   [(22,"")]
20:08:13 <Tekmo> Then do the same Maybe thing
20:08:16 <Tekmo> and then as a final step
20:08:18 <Tekmo> do:
20:08:30 <applicative> > reads "Hail_Spacecake" ::[(Int,String)]
20:08:31 <lambdabot>   []
20:08:31 <jmcarthur> ddarius: right. i've always seen TCO as tied to a particular implementation, which is why i was confused when you called your explanation "overly operational"
20:08:34 <Tekmo> maybe (defaultValue :: Int) id :: Maybe Int -> Int
20:09:12 <shachaf> Tekmo: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Text-Read.html#v:readMaybe
20:09:18 <ddarius> jmcarthur: You -can- make less operational/implementation-specific views, and a few have been done, but they are still uncompelling for the reason I mentioned above.
20:09:34 <Hail_Spacecake> huh I don't understnad what a type signature of [(Int,String)] means, conceptually
20:09:37 <YayMe> ddarius: What do you mean by "operational" ?
20:09:41 <applicative> > fmap fst (listToMaybe (reads  "22") ) :: Maybe Int
20:09:42 <lambdabot>   Just 22
20:09:45 <YayMe> I've never heard the word used in that way
20:09:50 <jmcarthur> that's an acceptable enough explanation to make me uninterested in looking into it further
20:09:51 <Hail_Spacecake> like, that returns a list with one tuple element?
20:09:56 <Tekmo> It's a list, where every element contains an integer and a string
20:09:58 <Hail_Spacecake> or an empty list?
20:10:00 <Nisstyre> ddarius: the SICP explanation seems like one of those more general explanations
20:10:01 <ddarius> Basically, you have to explicitly add in a stack just so you can "optimize" it back out.  This is exactly what Simon Marlow does in that talk.
20:10:12 <Tekmo> You can never tell from a list's type how many elements it has
20:10:21 <applicative> Hail_Spacecake: the signature is for a list of potentially many pairs
20:10:44 <ddarius> Nisstyre: Which?
20:10:49 <copumpkin> moo
20:10:58 <applicative> moo
20:11:00 <Nisstyre> ddarius:  http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_1.2
20:11:01 <jmcarthur> moof
20:11:06 <Nisstyre> that whole chapter basically
20:11:36 <Hail_Spacecake> huh, reads
20:11:37 <Hail_Spacecake> not read
20:11:37 <Hail_Spacecake> what is the difference between those two?
20:11:44 <ivanm> @type reads
20:11:45 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:11:45 <ivanm> @type read
20:11:46 <lambdabot> forall a. (Read a) => String -> a
20:11:55 <applicative> Hail_Spacecake: but I wonder what a good way of checking for the existence of a second element is;  x !! 1 is disreputably unsafe
20:12:01 <ivanm> using reads potentially allows for a backtracking parser
20:12:06 <applicative> > "a" !! 1
20:12:07 <lambdabot>   *Exception: Prelude.(!!): index too large
20:12:08 <Tekmo> reads returns all possible parses along with their corresponding unconsumed strings
20:12:10 <YayMe> ddarius: what I'm hearing you say is that the concept of using a new stack frame for things is merely an implementation decision made by language implementors, and that by and large stack frames is unnecessary in general
20:12:11 <ivanm> though does any instance actually return more than one element?
20:12:13 <ddarius> Nisstyre: No, that illustrates that the syntactic substitution semantics that we typically use -does not- have this "stack growing" defect for tail calls.
20:12:22 <Dodek> edwardk: you still there? it fails even when i try to do makeLenses
20:12:29 <Tekmo> Of course, ivanm
20:12:33 <Tekmo> I could just define one right now!
20:12:34 <startling> Dodek, how does it fail?
20:12:37 * edwardk arches an eyebrow.
20:12:50 <edwardk> Dodek: something is seriously wrong there.
20:12:55 <ivanm> Tekmo: OK, does any existing commonly used Read instance utilise more than one returning value?
20:12:55 <applicative> ivanm: yeah, all the simple examples never give many parses
20:13:06 <Tekmo> This might
20:13:07 <ddarius> YayMe: No, stack frames correspond to things.  You can identify a stack frame with something even in the simple syntactic substitution semantics for beta reduction.  What doesn't correspond to anything is "pushing a stack frame on every call".
20:13:11 <Tekmo> data A | AB deriving (Read)
20:13:51 <YayMe> ddarius: Ok, so the fact that many languages do push a stack frame on every call is simply a decision made by the language implementors
20:14:04 <YayMe> ddarius: even though every language needs stack frames that do correspond to a particular purpose
20:14:09 <edwardk> YayMe: and one that leads to bad consequences for many styles of programming
20:14:21 <hpaste> dodek pasted “makeLenses fail” at http://hpaste.org/75217
20:14:33 <YayMe> edwardk: Yeah, that makes sense considering the pain they cause
20:14:37 <Dodek> startling: edwardk: ^
20:14:44 <ddarius> YayMe: Sort of, there's no need for these "stack frames" to correspond to the hardware stack or even a stack data structure.  Also many are somewhat forced into this position by their underlying implementation languages.
20:14:50 <jmcarthur> YayMe: i think even the notion of a "function call" is a little weird
20:14:52 <edwardk> Dodek: hrmm i wonder if its something else bizarre about your set up.
20:14:59 <edwardk> Dodek: because i can't duplicate it
20:15:09 <ivanm> Tekmo: it would help if that was a valid definition :p
20:15:10 <edwardk> at least it works with travis
20:15:16 <Tekmo> Oh, hehe
20:15:17 <Dodek> edwardk: it is certainly possible, but i didn't do anything weird.
20:15:21 <Tekmo> data A = A | AB
20:15:27 <edwardk> Dodek: but you said you got it to blow up on another machine
20:15:39 <Jello_Raptor> is this a valid generic dynamic programming function http://hpaste.org/75216 , when given a function that is recursive (albeit, looking at the table it's given instead of itself) and won't choke on itself in one of any number of ways? (and the table is finite, infct how could you extend it to infinite tables/
20:15:39 <edwardk> Dodek: its bothering me a great deal =/
20:15:44 <ivanm> Tekmo: and I suppose it'd be too much to hope that the deriving code is smart enough to re-order the read instances :p
20:15:50 <Tekmo> Here
20:15:53 <Tekmo> I will test it out
20:15:54 <Tekmo> one second
20:15:55 <ivanm> (i.e. try to parse AB first)
20:15:57 <ivanm> k
20:16:03 <edwardk> somewhat alarmed that none of the other users have said anything though
20:16:11 <edwardk> especially if its also happening with makeLenses
20:16:23 <ddarius> YayMe: But there's no reason why C implementations need to "push a stack frame" on every call.  C implementations that did TCO for all tail calls are perfectly compliant and straightforward to implement.
20:16:24 <hpaste> dodek pasted “another machine” at http://hpaste.org/75218
20:16:38 <Dodek> edwardk: this is what i get on another machine.
20:16:48 <YayMe> ddarius: Right, it's just become a common misnomer that it is necessary.
20:16:51 <Tekmo> I tested it out and it only returns one read
20:16:54 <Tekmo> i.e.
20:17:02 <Tekmo> reads "AB" :: [(A, String)]
20:17:05 <Tekmo> Only returns the AB parse
20:17:13 <Dodek> edwardk: my local machine is gentoo, and the other one is debian. ghc is instaled from repository. all packages are installed using cabal install
20:17:15 <edwardk> you pulled the git repository earlier, right? if you 'cabal configure --enable-tests --enable-benchmarks && cabal build && cabal test && cabal bench' inside of that folder, can you hpaste what happens?
20:17:54 <ivanm> Tekmo: well, if it returned two options, what could the rest _be_ ?
20:17:57 <ddarius> YayMe: C++ and Java have stronger (but at least in Java's case not undeniable) claims that TCO is hard/impossible to do in those languages.
20:18:06 <Dodek> edwardk: ok, wait a minute
20:18:11 <edwardk> actually
20:18:13 <edwardk> cabal configure --enable-tests --enable-benchmarks -fdump-splices
20:18:16 <Tekmo> I was expecting perhaps [(A, "B"), (AB, "")]
20:18:18 <edwardk> (and the rest)
20:18:28 <ddarius> (Though, I would say if you have features that preclude TCO, they should be thought out more or are bad ideas.)
20:18:30 <YayMe> ddarius: But that's based on the language's spec itself?
20:18:32 <edwardk> i want to see all the splices it generates
20:19:03 <scooty-puff> i'm noticing haddock is showing fulling subsumed constraints in instance declarations - instances: Monad (Either e) => ...
20:19:13 <scooty-puff> is there any technique to eliminate this?
20:19:28 <Tekmo> That's weird
20:19:56 <Tekmo> Maybe the Either Monad instance was no in scope when you generated the haddock
20:20:16 <ddarius> YayMe: The specs don't preclude it, but the features may be unimplementable without storing information per call (including tail calls) which would lead to "stack overflows" even if you eliminated the redundant "stack" information.
20:21:00 <ddarius> Some languages explicitly technically can't do TCO because the stack is a visible part of the language, and thus TCO would change semantics, e.g. Smalltalk.
20:21:11 <YayMe> ddarius: Aye, I just mean, the spec defines things that would make it difficult to implement TCO and complying with the spec, as opposed to you referring to the implementations themselves
20:21:22 <Tekmo> Are you using a really old base library before it had the Either monad?
20:21:43 <scooty-puff> i'm getting it for other instances defined in the module, too -  and some of the contraints or not.. going deeper?  Monad (RWST r w s m) => ... instead of Monad m => ..., the import is as import Control.Monad.Trans.RWS.Lazy
20:22:05 <scooty-puff> it should be from ghc 7.6.1, but i can check that - though this is both locally, and on hackage
20:22:22 <ddarius> YayMe: Another, pretty serious, misunderstanding is that "tail call optimization" is an FP problem, but it's actually even more crucial in OOP.
20:22:35 <scooty-puff> i'm trying to get it closer and closer to how mtl defines various modules - that made provide some more infromation
20:22:44 <Tekmo> Are you defining the instances manually?
20:22:44 <scooty-puff> *made -> may
20:22:47 <Tekmo> Or using deriving?
20:23:07 <Dodek> edwardk: i'm having problems installing dependencies for tests. i get
20:23:08 <Dodek> setup: The program happy version >=1.17 is required but it could not be found.
20:23:11 <scooty-puff> manually for the two classes defined in the module, though one includes use of DefaultSignatures
20:23:14 <Dodek> but i installe happy and it is in PATH
20:23:28 <edwardk> you may have to cabal install happy to satisfy it
20:23:30 <edwardk> not sure
20:24:00 <edwardk> Dodek: i'm reinstalling the old platform now
20:24:02 <Tekmo> You may have to try a test case without extensions to see if the extensions are causing the problem
20:24:11 <scooty-puff> k
20:24:20 <Tekmo> But I find it odd that your instance would type-check, yet generate a completely different context in the documentation
20:24:40 <YayMe> ddarius: How do you figure? I understand people assume it's an FP problem because fp lacks loops often and therefore requires recursion while people presume function calls correspond to stack frames. this makes sense, but recursion is largely ignored in OOP, how is tco a bigger issue there? Are you referring to how terribly sloppy people get with their stacks in OOP? (something I can absolutely atest to)
20:25:01 <scooty-puff> yesh - its kind of throwing me off, too - most of it is available here: http://hackage.haskell.org/packages/archive/catch-fd/0.1.0.0/doc/html/Control-Monad-Catch.html
20:25:31 <edwardk> Dodek: i wonder if its the version of template haskell you have installed or something else odd that was caused by hand installing everything
20:26:00 <scooty-puff> *yesh -> yeah
20:26:49 <ddarius> YayMe: For languages, such as Haskell, without any control structures other than recursion.  TCO is clearly crucial, but it would not be hard to add control structures to Haskell and avoid that.  However, there's a pattern called "open recursion" that is rather important object-oriented programming that will often rely on TCO to work.  Most OOP programmers don't run into it simply because, in these cases, they (are forc
20:26:50 <ddarius> ed to) abandon OOP ideals and write procedural code in an OO language.
20:27:34 <ddarius> (Also, many "OO" programmers are basically writing procedural code in OO languages in the first place, so they also don't run into these issue.)
20:27:49 <YayMe> ah, yeah, got me there. Never heard of "open recursion"
20:28:04 <Tekmo> Something like
20:28:09 <Tekmo> undefined = undefined
20:28:35 <YayMe> ddarius: Yeah, I hear ya. I struggle to convince people I work with all the time of the benefits of OOP principles when we're working in C# where they're all writing procedural code and professing that it's "KISS"
20:28:49 <Tekmo> Speaking of which
20:28:55 <Tekmo> There was that MRI paper on /r/haskell
20:29:08 <Tekmo> By Tom Schrijver(? I think I misspelled his last name)
20:29:27 <Tekmo> The very first definitions seem like they didn't type-check
20:29:33 <Tekmo> I'll link it, hold on
20:30:08 <Tekmo> http://users.ugent.be/~tschrijv/Research/papers/jfp_mri.pdf
20:30:13 <Tekmo> Figure 1 is the weird one
20:32:25 <YayMe> ddarius: So "this" in C# is actually a tricky thing to implement because you could be referring to a type that's not even referenced in the code making the call to "this" ?
20:33:26 <YayMe> ddarius: How does that have to do with recursion? Is it just because it *might* be calling a method that's calling back to that which called it?
20:33:54 <Tekmo> YayMe: Here is my understanding of the relationship between open recursion and OOP
20:34:10 <ddarius> YayMe: Open recursion is not recursion, though, since the knot tying is often not obvious, it looks like recursion.
20:34:12 <Tekmo> You define an object function as something of the type: a -> a
20:34:45 <Tekmo> Then you write a function like this:
20:35:00 <Tekmo> fib :: (Int -> Int) -> (Int -> Int)
20:35:18 <Tekmo> fib this n = case n of 0 -> 0; 1 -> 1; n -> this (n - 1) + this (n - 2)
20:35:22 <YayMe> ddarius: You mean in the implementation underneath it is implemented similarly to recursion? Where in the code utilizing it, it does not look anything like recursion
20:35:53 <Tekmo> You can combine such functions using ordinary composition
20:35:58 <Tekmo> And then you tie the know using fix
20:36:05 <Tekmo> fix fib :: Int -> Int
20:36:07 <Tekmo> *tie the knot
20:36:28 <ddarius> YayMe: No, I mean in the code it looks like recursion, but in the implementation it's just higher order functions and the recursion, if any, happens elsewhere (namely in new typically).
20:36:55 <Tekmo> YayMe: Read the paper I linked
20:36:55 <Tekmo> http://users.ugent.be/~tschrijv/Research/papers/jfp_mri.pdf
20:37:00 <Tekmo> Except Figure 1 is wrong
20:37:19 <Tekmo> the (+) function should be (.), I believe
20:37:20 <YayMe> Tekmo: Oh that was for me? I thought you were talking to someone else. Also your function sig doesn't appear to match your function implementation to me?
20:37:23 <hpaste> dodek pasted “cabal configure” at http://hpaste.org/75219
20:37:41 <Tekmo> In that function
20:37:44 <Tekmo> this :: Int -> Int
20:37:46 <Tekmo> n :: Int
20:37:50 <Tekmo> and the result :: Int
20:38:05 <hpaste> ddarius pasted “C# code wanting TCO” at http://hpaste.org/75220
20:38:06 <Dodek> edwardk: this is what i get when i try to configure
20:38:10 <ski> (Tekmo : .. <http://hpaste.org/10060> is basically an example of this)
20:38:19 <ddarius> YayMe: http://hpaste.org/75220 implement LengthAcc following OO ideals.
20:38:29 <Dodek> edwardk: and when i cabal build, it just dies silently after some linking with error code 11
20:38:51 <Tekmo> ski: That's right
20:39:02 <ddarius> YayMe: Feel free to imagine a int Length() { return LengthAcc(0); } as that would be a more realistic public API.
20:41:09 * ski . o O ( PCLSRing )
20:41:38 <YayMe> Tekmo: I'm sorry, but that really doesn't match your sig for your function.. does it?? Really?
20:41:40 <startling> is `case` O(n) where n is the number of options?
20:41:53 <Tekmo> Let me test it in ghci
20:41:56 <ddarius> startling: Mostly likely not.
20:42:03 <Tekmo> Or lambdabot
20:42:03 <startling> in other words: is there an advantage to using `case` over an association list and `lookup`?
20:42:08 <ddarius> startling: Yes.
20:42:16 <YayMe> Tekmo: your sig shows a single parameter, your matching 2 though..
20:42:16 <startling> ddarius: hm, darn
20:42:28 <applicative> @type let new a = let this = a this in this
20:42:29 <lambdabot> <no location info>:
20:42:29 <lambdabot>     not an expression: `let new a = let this = a this in this'
20:42:32 <ski> YayMe : yes, saying `fib :: (Int -> Int) -> (Int -> Int)' is the same as saying `fib :: (Int -> Int) -> Int -> Int'
20:42:40 <applicative> @type let new a = let this = a this in this in new
20:42:41 <lambdabot> forall t. (t -> t) -> t
20:42:51 <mm_freak_> Polarina: pure
20:43:22 <YayMe> ski: I can see how that would be true, I guess I didn't realize that you would be allowed to match on what is a fill for the partial
20:43:42 <YayMe> ski: Thanks for explaining that for me
20:43:52 <Tekmo> You can
20:43:57 <Tekmo> Otherwise currying would not work!
20:44:01 <YayMe> ski: however, it is *NOT* the same as fib :: Int -> Int -> Int -> Int
20:44:21 <edwardk> Dodek: i'm thinking your problem is that you wound up with an upgraded version of template-haskell installed that is incompatible with your ghc
20:44:29 <Tekmo> YayMe: Consider this function
20:44:35 <YayMe> Tekmo: Sure, it makes sense. I guess I just never really thought about that
20:44:37 <edwardk> Dodek: if you ghc-pkg list | grep template-haskell        what shows up?
20:44:40 <Tekmo> Ok
20:44:45 <ski> YayMe : yes. the `->' operator in types is right-associative, meaning that `A -> B -> C' is a shorthand way of writing `A -> (B -> C)'
20:44:57 <Dodek> edwardk: template-haskell 2.7 and 2.8
20:45:01 <YayMe> ski: right great. thanks!
20:45:08 <YayMe> are signatures a function?
20:45:09 <edwardk> Dodek: thats why everything is going haywire for you
20:45:12 <Tekmo> After a while you get a hang for what parts of the signature you match on
20:45:25 <ski> YayMe : so, `fib :: (Int -> Int) -> Int -> Int' is just a shorthand way of writing `fib :: (Int -> Int) -> (Int -> Int)' -- presumably the parse tree for both is exactly the same
20:45:27 <Dodek> edwardk: damn! how should i fix this, then?
20:45:36 <YayMe> I am constantly surprised to realize what feels like a keyword is actually a function in haskell, but surely signatures aren't functions are they?
20:45:39 <mm_freak_> Polarina: i have removed some redundancy…  you would now use 'pure' instead of 'constant'…  in many cases you can even just use literals (Wire is both a Num and an IsString)
20:45:48 <shachaf> ski: Once there was a bug with that.
20:45:50 <Tekmo> Well
20:45:55 <Tekmo> The (->) in type signatures
20:45:56 <edwardk> good question, pretty much everything that depends on template-haskell 2.8 needs to be unregistered with ghc-pkg
20:45:57 <Tekmo> is a type constructor
20:45:57 <mm_freak_> Polarina: identity is also gone in favor of 'id'
20:46:02 <Tekmo> You can write it prefix style
20:46:02 <Tekmo> i.e.
20:46:06 <Tekmo> id :: (->) a a
20:46:09 <ski> YayMe : "are signatures a function?" -- i don't understand the question
20:46:26 <Dodek> edwardk: how about i delete ~/.ghc and ~/.cabal
20:46:31 <edwardk> the usual rule of thumb i have is to just remove the whole local install folder for ~/.ghc/your-compiler-version
20:46:39 <edwardk> no need to whack ~/.cabal
20:46:41 <edwardk> just the ~/.ghc
20:46:44 <Dodek> okay
20:47:01 <startling> can I annotate type constructors and do stuff with those annotations in template haskell?
20:47:03 <ski> YayMe : signatures are a kind of declaration (other kinds are datatype declarations, class declarations, instance declarations, and defining equations)
20:47:05 <applicative> Dodek just see what happens if you try ghc-pkg unregister template-haskell-2.8
20:47:14 <applicative> it will tell you what the damage will be
20:47:15 <startling> err, data constructors, not type constructors
20:47:25 <YayMe> ski: Thanks, that's a good way of thinking about it I guess
20:47:27 <mm_freak_> i delete ~/.cabal/{bin,lib,share} ~/.ghc
20:47:36 <Dodek> applicative: ah, too late.
20:47:39 <YayMe> ski: I guess one could say functions are a kind of declaration.
20:47:41 <ski> YayMe : so, `::' *syntactically* behaves as an operator, but it's not a function in any sense, it doesn't "exist" at that level
20:47:51 <ski> YayMe : no
20:47:54 <edwardk> Dodek: i mentioned earlier that it might be just a bad template-haskell version, guess i should have pursued that rather than pass out ;)
20:48:26 <Tekmo> I think you could reasonably consider :: to be reserved syntax
20:48:32 <Dodek> edwardk: thanks for help :)
20:48:59 <applicative> Dodek: what version of ghc are you using?
20:48:59 <Tekmo> There's no sensible way to implement your own ::
20:49:03 <ski> YayMe : `\x -> x * x' is a function (more strictly, it's an expression having a function type, evaluating to a function value). while `f x = x * x' is a declaration (a defining equation) which defines `f' to be (in this case) a function
20:49:11 <edwardk> i'm just glaf that it doesn't sound like i have to go off and rewrite huge swathes of code and come up with my own template haskell renamer, etc. ;)
20:49:31 <Tekmo> f x  = x * x is just syntactic sugar for f = \x -> x * x
20:49:34 <ddarius> YayMe: Actually with the API as written in that paste, you have no options, but you can assume an IsEmpty/Head/Tail/Uncons if you want.
20:50:02 <Dodek> applicative: 7.4.1 on one machine and 7.4.2 on the other
20:50:21 <applicative> Dodek: I see, so not out of date
20:51:50 <YayMe> ddarius: Yeah, I understand it. I can definitely see how TCO is important in C# and OOP in general, data structures themselves which are commonly modeled in C# are going to use forms of recursion like you showed there..
20:52:33 <YayMe> ddarius: Would it be fair to categorize what you implemented there as a linked list implementation? It looks like one to me, but I've never seen or thought of one implemented that way outside of fp
20:52:43 <Dodek> edwardk: yay, it works
20:52:50 <edwardk> Dodek: woot =)
20:53:02 <edwardk> i'll close out the issue with the summary of what happened
20:53:13 <edwardk> that way if someone else runs into it they can know what to do
20:53:39 <mm_freak_> YayMe: recursive data structures in strict OO languages can't be optimized, but only operations on them
20:54:12 <mm_freak_> in particular you can't have infinite data structures, at least not dynamic ones
20:54:17 <ddarius> YayMe: What's provided is, but since any one can go and add new implementations of list, such as Append(List<A> prefix, List<A> suffix) or LengthMemoizedList(List<A> l), there's nothing, in what I've outlined that says the actual representation is a linked list.
20:54:18 <ski> YayMe : yes, it's a (singly-)linked list datatype
20:54:58 <startling> so I have a *lot* of types that map to and from Word8s. can I do some template haskell magic to do "data Mything = A : 0xf0 | B : 0xf3" and automatically derive a typeclass?
20:55:41 <mm_freak_> startling: could you rephrase that question without using haskell terms?
20:55:58 <YayMe> Tekmo: Right, \x -> x * x is an expression, I understand that, but the = sign makes functino definition a declaration, so one could say like ski did, signatures are a declaration, functino definition is a declaration, data definitions are declarations, as are most other things. I can see how this is refered to as a "declarative language" in this way I guess
20:56:08 <ddarius> YayMe: In particular, if you define Length using IsEmpty and Tail, for example, you will be failing to use OO ideals 1) since you'll have to do an if on the result of IsEmpty, and 2) more importantly, you'll be deciding on an implementation of Length instead of asking the object to tell you its length allowing it to do smarter things e.g. returning a precalculated length or defining length as prefix.Length() + suffix.Le
20:56:08 <ddarius> ngth() (maybe with parallelism too).
20:56:42 <Tekmo> YayMe: Well, with function definitions using equals
20:56:56 <ddarius> I.e. a IsEmpty/Head/Tail API -exposes- a sequential linked-list view, but doesn't require the implementation to be sequential (v. parallel) or a linked-list.
20:56:57 <Tekmo> You can always take the value on either side of the equals sign
20:57:02 <Tekmo> and replace it with the value on the opposite side
20:57:10 <Tekmo> and referential transparency says that is safe
20:57:13 <startling> mm_freak_, I want to annotate some data constructors with values that I can later retrieve
20:57:14 <Tekmo> But, with a type signature
20:57:17 <ski> YayMe : and `x = "hello"' (not a function definition) is also a declaration -- also note that expressions (as well as patterns) are not declarations
20:57:19 <Tekmo> you can't really treat it like equals
20:57:29 <Tekmo> because I can't replace "f" with its type signature
20:57:38 <mm_freak_> startling: would the Enum class be appropriate?
20:57:56 <mm_freak_> startling: you can even derive that one, but when you do that you can't select the values
20:58:09 <mm_freak_> > fromEnum 65 :: Char
20:58:09 <startling> mm_freak_, no, the values are arbitrary and unordered
20:58:10 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:58:10 <lambdabot>         against inferred type...
20:58:14 <mm_freak_> > toEnum 65 :: Char
20:58:15 <lambdabot>   'A'
20:58:32 <ski> Tekmo : also you can note that often the line between declarations and commands (aka "statements") is often blurred in imperative languages -- however, conceptually they're distinct things
20:58:36 <ski> er
20:58:40 <ski> YayMe ^
20:58:59 <YayMe> ddarius: Right makes sense, I just found your linked list implementation interesting. Like I said, I recognize it from haskell but just interesting to see the same thing implemented in C# really makes it clear how fp gives you the ability to see different ways to do lots of things.
20:59:00 <Tekmo> However, there are some parallels between types and their corresponding values
20:59:04 <Tekmo> at least for non-sum types
20:59:11 <mm_freak_> startling: in that case you will have to write a ToWord8 class
20:59:13 <Tekmo> for example, the type for id is "a -> a"
20:59:17 <ddarius> Declarations are often interpreted as statements that update the environment, e.g. in Javascript.
20:59:18 <Tekmo> and the implementation is "\a -> a"
20:59:28 <startling> mm_freak_: yeah, that's what I have now. it's quite a bit of boilerplate
20:59:34 <Tekmo> and if you have a function of type "(a, (b, c)) -> ((a, b), c)"
20:59:37 <Tekmo> its implementation is
20:59:42 <shachaf> If I have a simple proposed extension to GHC, is the way to propose it to create a new feature request ticket with a patch?
20:59:44 <ski> Tekmo : a declaration is a construct which introduces a new *name*, standing for something -- in some cases a value, in other cases a type; there can be more possibilities too
20:59:45 <Tekmo> "\(a, (b, c)) -> ((a, b), c)"
20:59:51 <mm_freak_> startling: quasiquotes can help you there, but it's going to be difficult to write the quasiquoter
21:00:05 <startling> mm_freak_, what would that look like?
21:00:09 <startling> syntax-wise
21:00:17 <mm_freak_> startling: data X = [myQuoter| … |]
21:00:27 * ski idly wonders why his fingers insists on directing messaged to Tekmo while they were meant (primarily) for YayMe
21:00:28 <startling> oh, interesting
21:00:29 <ddarius> YayMe: This approach works generally for encoding (at least polynomial) algebraic data types.  It's also completely natural from an OO perspective.  If you follow OO ideals, this representation is what you'd arrive for a class representing (but not necessarily represented by) singly linked lists.
21:00:34 <ski> YayMe : see what i said above
21:00:43 <startling> mm_freak_: I'll look into this, thanks
21:00:44 <mm_freak_> startling: but actually i don't think that would work
21:00:51 <mm_freak_> startling: perhaps you actually need TH
21:00:51 <startling> mm_freak_: aw
21:01:16 <ddarius> YayMe: Smalltalk, for example, often uses representations like this, though it is often corrupted by an abundance of mutation that makes things less simple and clear.
21:01:30 <mm_freak_> data MyType = …; deriveToWord8 ''MyType
21:01:39 <mm_freak_> or rather
21:01:44 <YayMe> ddarius: I've only ever seen people implement a linked list in OOP using the classical public class Node { public Node Next { get; set;} } and public class LinkedList { public Node Head { get; set; } }
21:02:13 <mm_freak_> data MyType = A | B | C; deriveToWord8 ''MyType [('A, 1), ('B, 9), ('C, 27)]
21:02:24 <startling> mm_freak_: that would be doable
21:02:30 <ski> Tekmo : i think those parallels are probably related to functoriality, in some way ..
21:02:40 <ddarius> YayMe: Yes, because most people are just "copying" text-book algorithms/representations and those are usually presented in a procedural manner.
21:02:57 <Tekmo> I wish it also worked for sum types
21:03:03 <Tekmo> i.e.
21:03:05 <Tekmo> you gave the type
21:03:13 <mm_freak_> startling: yeah, but it doesn't look like it would use less code than an actual instance definition
21:03:15 <Tekmo> and the corresponding case implementation
21:03:19 <Tekmo> mirrored the sum type
21:03:39 <mm_freak_> startling: toWord8 x = case x of { A -> 1; B -> 9; C -> 27 }
21:03:45 <startling> mm_freak_, well, I'm going Word8 -> Maybe a too
21:03:50 <ddarius> Also, these structures are usually mutable and things start falling apart once you add in mutation, albeit, no more than they fall apart everywhere else in OO programs.
21:04:03 <mm_freak_> startling: i see
21:04:06 <startling> mm_freak_: so it looks like this would be an advantage
21:04:10 <benmachine> mm_freak_: I think a quasiquoter would work fine
21:04:19 <edwardk> now i just need to fix my ghc install again. going to 7.4.1 mucked everything up =)
21:04:20 <ddarius> Ironically, mutation is the bane of inheritance (and thus a large aspect of OO for a traditional definition of "OO").
21:04:23 <mm_freak_> benmachine: how would the quasiquoter write the instance?
21:04:32 <benmachine> mm_freak_: via quoteDec
21:04:56 <mm_freak_> benmachine: a quasiquoter can silently add instances?
21:05:04 <benmachine> mm_freak_: hardly silently!
21:05:05 <mm_freak_> data X = [myQuoter| … |]
21:05:11 <ski> Tekmo : would something like `distr :: (a,Either b c) -> Either (a,b) (a,c); distr (a,Left b | Right c) = Left (a,b) | Right (a,c)' qualify ?
21:05:12 <benmachine> no, cut the data X = but
21:05:14 <benmachine> *bit
21:05:17 <benmachine> it generates that too
21:05:24 <mm_freak_> benmachine: then you could just as well use TH
21:05:28 <benmachine> just [myQuoter| ... |] on the toplevel
21:05:29 <Tekmo> Yeah, that's what I had in mind
21:05:33 <Tekmo> Or, also, something like
21:05:38 <Tekmo> associativity for sums
21:05:41 <benmachine> mm_freak_: well, sure, but this way you get a more natural syntax
21:05:47 <startling> benmachine, huh, interesting
21:05:49 <YayMe> ddarius: Yeah I hear ya, I just wish I knew how to convince people of the dangers of mutation and these things, but alas a bunch of procedural developers convinced they're writing OO code are too confused to begin with to be set straight on things like this in any way I'm aware..
21:05:49 <Tekmo> (a + (b + c)) -> ((a + b) + c)
21:05:51 <edwardk> the usual example i like to point to is the usual square vs. rectangle issue. every square _is_ a rectangle. but if you expand the API to permit editing the x and y coordinates in situ in the object then you can't have that relationship in either direction.
21:05:54 <benmachine> well, I say "get", you have to parse it yourself :P
21:05:55 <mm_freak_> benmachine: and you will have to write a parser
21:06:01 <mm_freak_> exactly =)
21:06:04 <startling> benmachine, oh, so I just get a string?
21:06:05 <benmachine> mm_freak_: everyone loves haskell parsers, though
21:06:09 <benmachine> startling: yes
21:06:16 <ski> Tekmo : well, associativity is harder (and you don't have it for tuples) -- perhaps positional sum types would be enough for you ?
21:06:23 <startling> benmachine, hmm, it's definitely possible
21:06:35 <benmachine> startling: that's how quasiquoters work, you get a string and turn it into some declarations or an expression or something
21:06:53 <benmachine> startling: although, is there actually boilerplate in the straightforward approach?
21:07:05 <benmachine> startling: I mean, surely you've got to encode the mapping somehow, and that's just a lot of information
21:07:12 <benmachine> where's the overhead?
21:07:16 <ski> Tekmo : stuff like `(\b -> ( ~ | b | ~ )) :: b -> (a | b | c)', i mean
21:07:21 <mm_freak_> i think if you really want to reinvent the whole 'data' syntax, at least do it using both a quasiquoter and TH, just like yesod does
21:07:22 <Tekmo> Yeah, I wish I could just write: assoc (Left a | Right (Left b | Right c)) = Left (Left a | Right b) | Right c
21:07:35 <startling> benmachine: in the straightforward approach, I have to do it all twice
21:07:48 <benmachine> startling: you don't really
21:07:49 <mm_freak_> mkToWord8 "MyType" [toWord8| … |]
21:07:54 <Tekmo> It doesn't have to be positional
21:07:59 <Tekmo> I would be satisfied with just Eithers
21:08:04 <benmachine> startling: define a list of pairs, and look up in either the first or second component
21:08:05 <ski> Tekmo : well, that'd work with the idea i already had in mind with `distr' above, i think
21:08:10 <Tekmo> Yeah
21:08:16 <benmachine> startling: might be inefficient, though
21:08:19 <mm_freak_> there the toWord8 quasiquoter is only responsible for parsing
21:08:24 <Tekmo> I think if it worked for just pairs and Either that would still be pretty cool
21:08:27 <YayMe> ddarius: Just the other day someone at work sent me and another fellow an article about "Is traditional inheritance obsolete?" talking about those dangers and asking if that article made sense, I wrote a long detailed explanation with examples of how inheritance exists for mutation and then detailing the difference between and dangers in a mutable implementation and an immutable implementation of something. They basically said I'm not
21:08:28 <YayMe> making much sense and it all sounded too painful and difficult
21:08:30 <mm_freak_> it parses to something that looks like an AST
21:08:42 <startling> benmachine, yeah, but then I might as well do deriveToWord8 like mm_freak_ and I were talking about
21:08:44 <mm_freak_> then the mkToWord8 TH function has an easy time turning that into a bunch of declarations
21:09:05 <benmachine> startling: what do you mean, "might as well"? you might as well add complexity?
21:09:42 <Tekmo> ski: Maybe we just need to write an extension that does that
21:09:43 <ddarius> YayMe: Oleg's BRules article is a reasonably clear exposition of the issues and what you need to do have well-behaved inheritance (short of actually being serious about Liskov substitutability).
21:09:45 <mm_freak_> IMO quasiquotes should always be "pure" in a sense
21:09:47 <Tekmo> except perhaps using + instead of Left and Right
21:09:48 <Tekmo> i.e.
21:09:52 <mm_freak_> in other words, they should only parse
21:09:59 <Tekmo> assoc (a + (b + c)) = (a + b) + c
21:10:02 <Tekmo> Or :+:
21:10:04 <benmachine> mm_freak_: why? that seems unnecessarily limiting
21:10:28 <mm_freak_> benmachine: not limiting…  a quasiquoter can work together with TH as i explained above
21:10:33 <ski> Tekmo : the starting point is : allow disjunctive-/or- patterns (normally the sets of variables bound by `<pat 0>' respectively `<pat 1>' in `<pat 0> | <pat 1>' would have to be identical -- or at least the set of variables bound by the whole disjunctive-pattern is the intersection of those two previous sets)
21:10:34 <cmccann> pf. I thought being serious about Liskov substitutability was the definition of well-behaved inheritance.
21:10:44 <mm_freak_> use the quasiquoter for parsing and for parsing only (that also makes debugging MUCH easier)
21:10:49 <ddarius> (Unfortunately, particularly in the face of mutation, showing that a subclass is Liskov substitutable is extremely difficult and usually turns out to be "no", and even knowing what the conditions are that need to be met is extremely difficult where "extremely difficult" = undecidable.)
21:10:53 <benmachine> mm_freak_: sure, but isn't it more natural to just incorporate the TH in the QQ?
21:10:53 <YayMe> ddarius: I'll have to read through that tomorrow, thanks.
21:11:00 <Tekmo> ski: Here's another brain teaser
21:11:03 <startling> benmachine, because then I'm doing instance ToWord8 x where toWord8 = flip lookup xassox; for lots of things
21:11:08 <mm_freak_> benmachine: no, it's natural to do it the other way around
21:11:09 <ski> Tekmo : but now the idea is : allow these two sets to be different : so the pattern only *sometimes* binds `a' (say)
21:11:16 <Tekmo> ski: What if you wrote a signature like: true, false :: a -> a -> a
21:11:27 <Tekmo> and it automatically deduced the two functions that inhabited that type
21:11:34 <benmachine> startling: ah, so the problem is lots of types, not lots of values in the types
21:11:41 <Tekmo> Hmm, one thing at a time
21:11:47 <Tekmo> anyway, back to disjunctive patterns
21:11:51 <mm_freak_> benmachine, startling:  mkToWord8 "MyType" [toWord8| A 1, B 9, C 27 |]
21:12:06 <ski> Tekmo : the trick is : to make things deterministic, we have to make sure that we know which "branch" in the body of the defining equation we will use, other it's ambiguous (and thus should generate an error report)
21:12:07 <ddarius> cmccann: Yes, it is.  But, LSP is not free at all unless you constrain what you do significantly (starting with getting rid of mutation but not ending there).  Few programmers provide the necessary information for you to even know what you need to do to meet LSP for a particular (super)class.
21:12:13 <mm_freak_> where toWord8 is really just a quasiquoter for parsing that syntax between the pipes
21:13:17 <mm_freak_> or rather
21:13:27 <mm_freak_> mkToWord8 "MyType" [toWord8| MyType: A 1, B 9, C 27 |]
21:13:30 <ski> Tekmo : iow, `foo (Left (a,b) | Right (a,c)) = ((Left a | Right a),(Left b | Right c))' would be disallowed, since we can't determine which branch to choose to evaluate in the expression `Left a | Right a'
21:13:31 <ddarius> My views of OO have evolved over time.  Perhaps surprisingly, I -do- consider object identity and statefulness to be crucial aspects of OO, though I have a very different idea of what OO is compared to many programmers.
21:13:35 <mm_freak_> or even
21:13:36 <Tekmo> Just pasting this for my reference: distr (a * (b + c)) = (a,b) + (a,c)
21:13:42 <mm_freak_> mkToWord8 [toWord8| MyType: A 1, B 9, C 27 |]
21:14:03 <aristid> is it possible that 7.6 is much stricter about what counts as usage of RankNTypes when it's not declared?
21:14:08 <cmccann> ddarius, fortunately, most programmers have a very different idea of what OO is compared to most other programmers.
21:14:09 <YayMe> ddarius: haha, upon cursory glance, this brules stuff is basically saying "To not make inheritance a terror, feel free to use it but write your code in a functionally stateless style" is that right?
21:14:10 <Tekmo> ski: I think I follow so far
21:14:17 <mm_freak_> that way the QQ does not have "side effects" and can be tested easily…  it can also be used for other things
21:14:19 <startling> cmccann: heh
21:14:25 <shachaf> aristid: 7.6 is more strict about other things than 7.4.
21:14:26 <mm_freak_> in other words the QQ/TH stuff gets more composable
21:14:31 <shachaf> So it seems possible.
21:14:34 <startling> mm_freak_, yeah. that's a lot of complexity, though
21:14:40 <ddarius> YayMe: One of the surprising aspects of it is that simply outlawing mutation is -not- enough.
21:15:02 <ddarius> (Though it is basically necessary and a large part of the solution.)
21:15:06 <mm_freak_> startling: you want nice syntax and for writing QQ/TH stuff, believe me, you want easy debugging ;)
21:15:39 <Tekmo> ski: A really easy rule is to simply reduce both sides to their algebraic normal form and check if they are equal
21:15:39 * cmccann personally sticks with the view of OO as being behavior-centric rather than data-centric, and as such regards nominal subtyping as an abomination.
21:15:52 <startling> mm_freak_: this is true
21:15:57 <ski> Tekmo : btw, i think this idea fits nicely in with the idea of "impossible case" in Agda2
21:15:59 <Tekmo> ski: So in the example you gave, it would give an error because "a * (b + c)" /= (a + a) * (b + c)"
21:16:00 <Dodek> edwardk: some libraries i try to install pull template-haskell-2.8, and then shit hits the fan :/
21:16:13 <edwardk> which ones?
21:16:28 <benmachine> Dodek: you can't install new versions of TH, really
21:16:40 <benmachine> well, I say really, I mean at all
21:16:43 <mm_freak_> startling: also this makes your QQ/TH-level stuff very composable…  perhaps you decide later to allow to define the data type and instances in separate modules, then you can just write partial derivers (mkToWord8Type, mkToWord8Instances)
21:16:46 <benmachine> you're stuck with whatever GHC comes with
21:16:57 <edwardk> you can use cabal install foo --constraint 'template-haskell < 2.8'
21:16:58 <YayMe> ddarius: Ah interesting. Well what i said in my e-mail the other day was basically, the only reason to have code in a parent class instead of a separate unrelated but available class is because the parent class gives privileged access to the objects state. Based on that if you're trying to write side effect free code there's no reason to use inheritance at all. Does that not make sense?
21:16:59 <startling> mm_freak_: yeah, that's true
21:17:10 <edwardk> it may complain that you can't install the package at all with that constraint
21:17:10 <ddarius> cmccann: My view is the programming style that naturally arises (both in practice and theoretically) from message passing concurrency is the "true" OO, and it is certainly more inline with the ideas of many early OO thinkers.
21:17:18 <startling> anyway, where do I learn how to write quasiquoters?
21:17:20 <ski> Tekmo : well, `foo' was attempting to define a (one-directed) transformation `a * (b + c)  ->  (a + a) * (b + c)'  (you saying `/=' looks like we tried a bi-directional one)
21:17:21 <edwardk> but then the package doesn't work with 7.4
21:17:26 <ddarius> Basically when OO started getting divorced from concurrency, it started losing its way.
21:17:29 <Tekmo> Not bidirectional
21:17:37 <Tekmo> I mean, just for determining whether to throw an error
21:17:39 <edwardk> ddarius: simula 4 life
21:17:43 <Tekmo> The compiler checks if both sides are algebraically equal
21:17:47 <Tekmo> if not, it's unsolvable
21:17:49 <mm_freak_> startling: http://www.haskell.org/haskellwiki/Quasiquotation
21:17:55 <Tekmo> the unidirectional transformation is unsolvable
21:18:13 <Tekmo> Additionally
21:18:17 <Tekmo> the proof of algebraic equality
21:18:23 <Tekmo> carries with it the implementation
21:18:31 <ddarius> YayMe: I'm not keen on (implementation) inheritance even in my view of OO.  I think there are pretty good arguments for avoiding it without even having to go to ideology.
21:18:46 <ski> Tekmo : but, we don't have a "most canonical" implementation of `forall a b c. a * (b + c) -> (a + a) * (b + c)' -- we have two canonical ones, and that's the problem; we don't know which to choose (and the suggested code above doesn't arbit)
21:18:55 <Dodek> benmachine: it's not like i want new TH
21:19:12 <ddarius> edwardk: Simula did have some (relatively novel for the time) concurrency constructs and of course actors were conceptually closely related to concurrency.
21:19:17 * cmccann thinks implementation inheritance was and is a terrible mistake.
21:19:22 <Tekmo> ski: Right, but what I'm saying is that the compiler would reject that because both sides are not algebraically equal
21:19:45 <edwardk> ddarius: i agree. =)
21:20:07 <ddarius> Out of popular languages, Erlang is the closest to my view of what OO is.
21:20:09 <YayMe> ddarius: Right, I'm not keen on that either, but that was how i tried to explain the position
21:20:16 <Tekmo> ski: In fact, here's how you implement both the check and the implementation
21:20:30 <YayMe> I think it's a rational argument against inheritance
21:20:47 <ski> Tekmo : yeah, though i'm saying that the point isn't that the sides aren't equal -- the point is that there's no canonical (single-directed) transformation
21:20:54 <Tekmo> ski: You use associativity and distributivity for product and sum to reduce each side to its algebraic normal form (a sum of products, with everything right associativie)
21:21:10 <Tekmo> Then the compiler keeps track of which transformations it used to reduce each side to its normal form
21:21:12 * cmccann probably leans more toward Smalltalk as a "definition" of OO
21:21:15 <mm_freak_> i think it's unfair to say that C++/java-style OO "is not OO"
21:21:21 <Tekmo> If both sides evaluate to the same normal form, then it passes the check
21:21:22 * hackagebot fountain 0.0.5 - A fountain codec.  http://hackage.haskell.org/package/fountain-0.0.5 (RubenAstudillo)
21:21:24 * hackagebot repa 3.2.2.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.2.2.1 (BenLippmeier)
21:21:26 * hackagebot repa-algorithms 3.2.2.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.2.2.1 (BenLippmeier)
21:21:28 * hackagebot repa-io 3.2.2.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.2.2.1 (BenLippmeier)
21:21:30 <Tekmo> So let's say the set of transformations for the left side are
21:21:35 <ddarius> cmccann: Its arguably a common "definition" but it misses mine in many ways.
21:21:42 <mm_freak_> it still follows the idea that you have objects and pass messages to them, which then act based on those messages
21:21:53 <Tekmo> Let's use the simple example of associativity of products
21:22:05 <Tekmo> Or even, simpler
21:22:09 <Tekmo> let's say we give the compiler
21:22:11 <Tekmo> a -> a + a
21:22:24 <Tekmo> It will refuse that
21:22:27 <Tekmo> because a /= 2 * a
21:22:37 <Tekmo> so there is no unique implementation
21:22:40 <ski> Tekmo : consider `blah :: ((a0,a1),(Either b0 b1)) -> Either (a0,b0) (a1,b1); blah ((a0,a1),Left b0 | Right b1) = Left (a0,b0) | Right (a1,b1)'  -- here, the sides are "not equal", but this would still work out fine
21:22:44 <mm_freak_> in any case, by the smalltalk definition haskell is also an OO language
21:22:45 <YayMe> ddarius: is "micro architecture" a term? I know of "microkernel architecture" vs "monolothic kernel architecture" but I find the same architectural concepts can be seen in normal software, where I would think the closest modern allegory to "micro architecture" would be like a SOA system, or smoething written in erlang, whereas the garbage I find myself in with large UI\BL\DAL and no vertical segmentation in the system as monolothic
21:23:11 <Tekmo> ski: Then perhaps the criterion is whether the right hand side is "less than" the left hand side
21:23:11 <Dodek> edwardk: it seems that postgresql-simple has template-haskell in the dependencies list, and it ignores th-2.7 i have and tries to install th-2.8
21:23:11 <Tekmo> i.e.
21:23:12 <YayMe> ddarius: unless I am terribly over simplifying the purpose and meaning of those things
21:23:13 <Tekmo> a + a -> a
21:23:14 <Tekmo> would be fine
21:23:17 <Tekmo> since 2 * a > a
21:23:24 <Tekmo> and it has a unique implementation
21:23:24 <cmccann> ddarius, I imagine you've read this paper? http://lambda-the-ultimate.org/node/3668
21:23:38 <edwardk> Dodek: then you need to yell at whoever maintains that thing, and see if it can work with 7.4.1
21:23:43 <ddarius> mm_freak_: I'm saying -my- definition of OO is intimately tied to message passing concurrency, and since method invokation in Java/C++ is not (concurrent) message passing, it fails to meet it.  Also, driven by that, it does many other things which are extraneous or incompatible with my view of OO.
21:24:05 <Tekmo> Let me try the example you gave
21:24:16 <Tekmo> ski: Could you repaste it, because my mouse is broken?
21:24:17 <ski> Tekmo : "You use associativity and distributivity for ... (a sum of products, with everything right associativie)" -- you could possiblt do that, yes; though i think i'd favour a more lazy approach, not converting to a sum-of-products eagerly ..
21:24:31 <ddarius> cmccann: I read it at some point.
21:24:35 <Dodek> edwardk: the thing is that .cabal file does not require has >=2.8 constraint for template-haskell
21:24:38 <edwardk> i've had to jump through some pretty awful hoops to get lens compatibility. i forget what puts the hard floor on it at 7.2
21:24:39 <mm_freak_> ddarius: of course…  my point is that nowadays there are multiple OO paradigms, and just rejecting everything that is not smalltalk-/concurrency-like is unfair
21:24:41 <ddarius> cmccann: I don't really remember it too much.
21:25:08 <Tekmo> ski: So the idea is that if you can prove that the left-hand side is algebraically greater than the right hand side for all non-negative variable choices, then you can derive a unique transformation
21:25:16 <ddarius> mm_freak_: I reject Smalltalk as meeting my definition of OO.  I don't see how this is unfair.  I'm not saying this is what everyone else should mean when they say OO.
21:25:24 <Tekmo> So, for example
21:25:35 <mm_freak_> ddarius: unfair in general
21:25:46 <Tekmo> ski: If I give the compiler: (a, b) -> a
21:26:00 <Tekmo> It would deduce that the left hand side is only greater if b > 0
21:26:06 <Tekmo> which is correct
21:26:06 <cmccann> ddarius, it gives roughly the same definition of "object" that I prefer, where I define OOP informally as programming centered on using objects
21:26:08 <Tekmo> since the case b = 0
21:26:10 <jmcarthur> Tekmo: i haven't read everything above. are you only speaking of products and sums?
21:26:12 <mm_freak_> ddarius: i mean when a beginner asks how he can express his favorite java-OO idea in haskell, one shouldn't answer "this is not OO"
21:26:18 <Tekmo> Yes, only products and sums
21:26:23 <ddarius> mm_freak_: Where have I done that?
21:26:26 <Tekmo> Although conceivably you could do it for functions, too
21:26:29 <ddarius> mm_freak_: Or said that that should be done?
21:26:30 <Tekmo> treating functions as exponentiation
21:26:35 <mm_freak_> ddarius: you haven't…  i wasn't even talking to you =)
21:26:44 <YayMe> ddarius: I appreciate that you didn't give me shit for referring to the C#/java style "OOP" as OOP, I realize there is the older definition of OO but I've been given guff for referring to the C# style OO as such heh
21:26:54 <ski> Tekmo : "less than" analogy fails for `blah :: Either a0 b1 -> Either (Either a0 a1) (Either b0 b1); blah (Left a0 | Right b1) = Left (Left a0) | Right (Right b1)', no ?
21:26:58 <jmcarthur> i haven't thought that through, but my gut says it might not be possible in general, even with your proposed restriction
21:27:27 <ddarius> YayMe: Why would I complain about people using common definitions of technical terms?
21:27:42 <Tekmo> Let me see: a0 + b1 -> (a0 + a1) + (b0 + b1)
21:27:43 <cmccann> oddly enough my first exposure to anything called OOP was essentially a really horrible form of the actor model
21:27:45 <YayMe> ddarius: Many people do because the "common definition" is the "wrong" definition
21:27:56 <YayMe> which is decidedly unhelpful
21:28:03 <mm_freak_> my first exposure to OO was C++
21:28:12 <YayMe> Anyway I gotsa get, later all
21:28:33 <Dodek> how can i stop cabal from installing newest template-haskell?
21:28:35 <cmccann> mm_freak_, you can actually do OO in C++? how fascinating. ;]
21:28:45 <ddarius> It's possible my first-ish experience with OO would be dealing with Windows API at the assembly level, but it's probably C++.
21:28:48 <mm_freak_> cmccann: why not?
21:28:55 <benmachine> Dodek: did you try --constraint?
21:29:09 <cmccann> mm_freak_, because blah blah the well-known Alan Kay quote making fun of C++ &c.
21:29:27 <Dodek> benmachine: how do i use this?
21:29:35 <Jafet> Kay clearly didn't try hard enough.
21:29:46 <mm_freak_> cmccann: i know neither alan kay nor his quote
21:29:49 <Tekmo> ski: Or let's simplify the example
21:29:53 <Tekmo> ski: a -> a + b
21:30:07 <benmachine> Dodek: something like --constraint='template-haskell installed'
21:30:14 <ddarius> Alan Kay is often considered the person who defined "OOP".
21:30:14 <ski> Tekmo : sure, but then the `|'s in patterns and expressions disappear :)
21:30:20 <benmachine> Dodek: I don't promise that will work, but I think it does
21:30:24 <cmccann> mm_freak_, the quote is "I invented the term Object-Oriented and I can tell you I did not have C++ in mind."
21:30:34 <cmccann> he's the main person behind smalltalk IIRC
21:30:42 <mm_freak_> i see
21:30:43 <ski> @where object-oriented
21:30:43 <ddarius> cmccann: One of the main people, yes.
21:30:43 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
21:30:46 <ski> (fwiw)
21:30:51 <Dodek> benmachine: thanks
21:31:00 <edwardk> Dodek: you can always use the --constraint 'template-haskell < 2.8' on every cabal command line
21:31:14 <jmcarthur> Tekmo: the left side of  (a,a) -> a  is algebraically greater than the right, but doesn't have a unique transformation. did i misunderstand something?
21:31:22 <ski> iiuc, Simula was "the other big, early OO language"
21:31:30 <Tekmo> jmcarthur: You're right
21:31:40 <ddarius> ski: Yes.  Simula is commonly considered the "first" "OO" language.
21:31:46 <mm_freak_> well, unfortunately for kay, terms can expand their meaning
21:31:51 <ski> jmcarthur : yea, that's another good example
21:32:23 <ski> ddarius : when (relatively speaking) did actors (and then Scheme, as a spin-off) enter the picture ?
21:32:42 <mm_freak_> even C++ and java follow the idea that you have an "object" and pass messages to it
21:32:42 <ddarius> Scheme and Smalltalk are both languages of the 70s.
21:33:19 * benmachine adds "constraint: template-haskell installed" to his .cabal/config file
21:33:26 <benmachine> that should probably be there by default
21:33:40 <benmachine> we could avoid a lot of problems in life by appropriate installed constraints
21:33:41 <Tekmo> ski: Ok, take 2.  For many expressions you can compute how many type inhabit them
21:33:57 <ski> mm_freak_ : some OO purists seem to frown on using synchronous messages (at least if you use almost only those) -- not doing that means some form of concurrency
21:34:01 <Tekmo> ski: For example, using jmcarthur's example, you can prove that it is inhabited by two implementations
21:34:26 <ski> (iirc, the mantra was "tell, don't ask")
21:34:34 <Tekmo> ski: since (forall a . (a, a) -> a) ~ (forall a . (2 -> a) -> a) ~ 2
21:34:35 <jmcarthur> larger products must be on the right. larger sums must be on the left. not sure about compositions of them. it'
21:34:37 <jmcarthur> oops
21:34:52 <jmcarthur> it's also insufficient. not sure how to explain why   a -> (a,b) is impossible
21:34:55 <Tekmo> So if you prove something is inhabited by more than one implementation, you reject i
21:35:12 <Tekmo> The problem is that I'm not sure how to calculate in the general case how many implementations inhabit a type
21:35:13 <jmcarthur> unless b is 1
21:35:15 <ski> Tekmo : "For many expressions you can compute how many type inhabit them" -- itym to swap "expression" and "type" there
21:35:24 <Tekmo> Right
21:35:25 <Tekmo> :)
21:35:37 <copumpkin> type/term is the usual distinction
21:35:47 <copumpkin> or value
21:35:49 <ddarius> I used to think that object identity and statefulness were irrelevant to "OOP", but as I got more into concurrent calculi (with the deep blue calculus being a good example, though primarily the pi calculus), I came to the conclusion that there was a natural programming style that arose from this, it was very similar to aspects of OOP, it more closely met common ideals of OOP (e.g. objects are autonomous), but had some s
21:35:50 <ddarius> trong opinions about other aspects and was completely orthogonal to others.
21:35:53 <shachaf> type/term are the usual terms
21:36:23 * hackagebot aws 0.7.2 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.2 (AristidBreitkreuz)
21:36:32 <copumpkin> jmcarthur: well, tekmo's conversion of (a, a) to (2 -> a) doesn't quite work for (a, b), at least not directly
21:36:47 <Tekmo> That converts to
21:36:53 <Tekmo> (a -> a, a -> b)
21:37:04 <jmcarthur> right
21:37:21 <Tekmo> This is where I get stuck
21:37:40 <copumpkin> just try to prove the negation ;)
21:37:53 <Tekmo> If I remember correctly
21:37:55 <Tekmo> the negation is
21:38:00 <shachaf> What are people trying to prove here?
21:38:10 <Tekmo> negate b ~ forall a . b -> a
21:38:11 <jmcarthur> shachaf: i don't think we're even sure
21:38:19 <shachaf> Oh.
21:38:22 <shachaf> Then it's probably wrong.
21:38:23 <copumpkin> (forall a b. a -> (a, b)) -> Void
21:38:25 <ski> ddarius : hm, i wonder whether one could say that, out of traditional OO concepts, programming with products respectively concurrency with identity and local state are really distinct ideas, that happened to be bundled together ..
21:38:39 <copumpkin> Tekmo: sure
21:38:45 <Tekmo> So, then
21:39:05 <ski> ddarius : or would you say there's reasons why those two would fit together ?
21:40:09 <ddarius> ski: It comes up that it's nice to prevent a concurrent process as a product of message endpoints, an "active object" like representation.
21:40:45 <ski> (itym s/prevent/present/)
21:40:51 <Tekmo> copumpkin: I still get stuck because I don't know the rules for manipulating forall
21:41:02 <shachaf> Tekmo: What are we trying to prove?
21:41:08 <copumpkin> (forall a b. a -> (a, b)) -> c
21:41:10 <Tekmo> that a -> (a, b) is impossible
21:41:11 <copumpkin> try to prove that in haskell :P
21:41:28 <copumpkin> without looping and stuff like that
21:41:35 <ddarius> ski: I'm not quite sure what you mean by "programming with products" though.
21:41:36 <Tekmo> Oh
21:41:39 <Tekmo> I understand now
21:41:43 <Tekmo> Give me a second
21:41:49 <ski> i suppose concurrent processes commonly has the "server-type" behaviour -- i.e. they run until explicitly terminated, just like coalgebras
21:41:54 <shachaf> Can djinn be tricked into doing these?
21:42:01 <copumpkin> not as far as I know
21:42:03 <Tekmo> proof f = snd (f ())
21:42:04 <jmcarthur> higher rank types? i doubt it
21:42:06 <copumpkin> unless you instantiate it yourself
21:42:13 <shachaf> It's just rank-2.
21:42:15 <copumpkin> Tekmo: look about right
21:42:26 <shachaf> Rank2Types, a magical land where some things are possible.
21:43:22 <jmcarthur> Tekmo: one useful way to think about forall is as a type-level lambda
21:43:25 <ski> ddarius : i'm thinking about constructing non-strict tuples/records, where the code for a field/method is only executed when that field is extracted / you send that message to it -- including defining values as greatest-fixpoints over this
21:43:34 <Tekmo> Yeah, I sort of get that part
21:43:37 <Tekmo> like, I notice that
21:43:44 <Tekmo> whenever I have the implementation : \a -> ...
21:43:47 <Tekmo> the type signature ends up with
21:43:49 <copumpkin> Tekmo: I think you were the one I was answering on that stackoverflow response I wrote :P
21:43:51 <Tekmo> forall a. a -> ...
21:44:00 <A2kmm> I have a data structure that takes a (* -> *) kinded parameter and applies it to get * kinded member types. I want to derive instances (Eq, Ord, Typeable, Data).
21:44:04 <Tekmo> You mean the algebraic representation of forall?
21:44:09 <copumpkin> yup
21:44:11 <ski> ddarius : iow, i'm thinking about the duality between inductive types, and coinductive types
21:44:12 <Tekmo> Yeah
21:44:26 <Tekmo> I was hoping for something more like
21:44:29 <Tekmo> a derivative
21:44:31 <Tekmo> or dividing by 0
21:44:36 <Tekmo> :)
21:44:45 <shachaf> Tekmo: Have you seen the proof of lem given callcc?
21:44:47 <Tekmo> Although I still appreciated the Yoneda lemma answer
21:44:50 <A2kmm> How can I put a constraint on the parameter to say that if the argument supports an instance, the result of the application supports it?
21:44:53 <shachaf> That's the best CH-style proof.
21:44:54 <ddarius> ski: I think those aspects (as you were alluding to) fit in nicely with this view.  In fact, I think many theoretical and practical aspects fit in nicely with this view which is why I take it.
21:44:58 <copumpkin> Tekmo: hrrmpf, fine
21:45:07 <Tekmo> Proof of lem?
21:45:13 <copumpkin> I'm sorry that type theory does not match your hope for a division by 0
21:45:17 <Tekmo> :)
21:45:32 <Tekmo> Well, I just wanted something that was easy to manipulate into a normal form
21:45:39 <Tekmo> the way I can with multiplication or sum
21:45:47 <copumpkin> you can manipulate Pi
21:45:52 <copumpkin> much like you'd do in algebra
21:46:07 <copumpkin> but I'm not sure why you'd expect it to be as easy as manipulating individual terms
21:46:07 <Tekmo> Could you explain?
21:46:08 <A2kmm> "data (forall a . Eq (forward a), forall a . Ord (forward a), forall a . Typeable (forward a), forall a . Data (forward a)) => Model forward = Model {" doesn't work
21:46:21 <shachaf> A2kmm: That looks like a syntax error to me...
21:46:22 <copumpkin> Tekmo: you can distribute things across n-ary sums and products
21:46:39 <copumpkin> or *-ary
21:46:42 <shachaf> You can distribute things across nary a sum or a product.
21:46:44 <Tekmo> Right, but how do I go from that to "forall a . a -> a ~ 1"
21:46:58 <copumpkin> that requires knowledge of parametricity
21:47:01 <A2kmm> shachaf: It compiles with ConstraintKinds, but fails at the typechecker.
21:47:03 <Tekmo> Right
21:47:04 <ddarius> shachaf: *nor
21:47:07 <Tekmo> parametricity is what I care about
21:47:17 <Tekmo> But is there a way to mangle parametricity into a normal form?
21:47:53 <shachaf> Oh, now I see what Tekmo is trying to do.
21:48:09 <copumpkin> Tekmo: not as far as I know, because fundamentally the types don't actually say that
21:48:21 <rwbarton> there's some TWF issue about this, let me find it ...
21:48:33 <shachaf> TWF?
21:48:50 <rwbarton> http://math.ucr.edu/home/baez/week240.html
21:49:12 <benmachine> A2kmm: you might find StandaloneDeriving will help you
21:49:45 <A2kmm> benmachine: Thanks, I'll look into it.
21:49:55 <jmcarthur> saying "A ~ 1" is in some sense the same as saying "A is self-evident"
21:50:15 <shachaf> jmcarthur: What about "A ~ 2"?
21:50:18 <ski> Tekmo : anyway, have you seen stuff like `index : forall n A. Vect A n -> Fin n -> Vect A n -> A; index {Zero} vect (); index {Succ _} (Cons a _ ) (FZero  ) = a; index {Succ _} (Cons _ as) (FSucc i) = index as i', specifically the `()' construction in the pattern there ?
21:50:44 <A2kmm> benmachine: I still get "Could not deduce (forall a. Data (forward a), ...) arising from the 'deriving' clause of a data type declaration When deriving the instance for (Eq (Model forward))"
21:50:53 <ski> ddarius : ok
21:51:16 <benmachine> A2kmm: well, yes, StandaloneDeriving only enables standalone deriving declarations, you have to change your code to actually use them :)
21:51:16 <A2kmm> benmachine: which is weird given I have actually defined that in the instance head.
21:51:41 <benmachine> A2kmm: datatype contexts don't do what you'd hope they did
21:51:47 <ski> A2kmm : unfortunately no higher-rank constraints (or even polymorphic constraints)
21:51:50 <Tekmo> ski: I didn't follow what that is for
21:52:13 <ski> Tekmo : `()' means "impossible case"
21:52:22 <jmcarthur> shachaf: you've managed to convince me in very few words that... i need to go to sleep
21:52:47 <benmachine> A2kmm: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
21:52:56 <ski> Tekmo : compare `f (A a | B b) = foo a | bar b' with `f (A a) = foo a; f (B b) = bar b' -- obviously those are equivalent
21:52:58 <Tekmo> ski: Oh, you mean like pattern matching on "Void", sort of
21:53:04 <ski> Tekmo : now, what is the corresponding nullary case ?
21:53:40 <A2kmm> benmachine: Ah... so I can derive after I completely apply my parameters. That seems like it might work for this case since I only ever apply Model to two parameter choices.
21:53:56 <benmachine> A2kmm: um, now I'm confused
21:54:01 <ski> Tekmo : for the latter form, it would of course be writing no equations at all !
21:54:16 <ski> Tekmo : (and this works, in case there's other (unrelated) equations for the same thing which is being defined -- otherwise you have to use the former form anyway)
21:54:18 <benmachine> A2kmm: the problem is that the context on your datatype does not end up as context on your derived instances
21:54:26 <benmachine> A2kmm: because that's not what datatype contexts do
21:54:43 <benmachine> A2kmm: the idea behind standalone deriving is that you get to write the instance head, so you get to put the context in
21:54:57 <Tekmo> ski: I get it
21:55:07 <Tekmo> ski: So it is like parallel function case matching
21:55:17 <ski> Tekmo : just like `_' acts like an identity element of `@' (assuming we generalize it to allow a (possibly non-trivial) pattern on both sides), we ought to have an identity element for `|' (disjunctive pattern)
21:55:59 <ddarius> Let's use Agda's notation: f ()
21:56:13 <Tekmo> Unfortunately, that would be confusing in Haskell
21:56:18 <ski> Tekmo : consider `data Void where' (no constructors), we'd like to define `void :: Void -> a' -- just writing no definition equations will not work (it will assume we forgot to define `void')
21:56:24 <ddarius> "Confusing" is an understatement.
21:56:35 <dolio> Haskell is already confusing.
21:56:42 <ski> Tekmo : `void v = case v of {}'  could work -- as could Agda2's `f ()'
21:56:43 <Tekmo> How about {}?
21:56:51 <shachaf> f x = case x of {}
21:56:55 <shachaf> That would be reasonable.
21:57:20 <Tekmo> Or, you could even do:
21:57:23 <Tekmo> f {x} = x
21:57:27 <Tekmo> where {x} denotes Void
21:57:29 <ski> Tekmo : let's for argument's sake say that the identity element of `|' is written like `^' -- then we could formulate the Agda2 `f ()' like `f ^ = ^'
21:57:36 <Tekmo> and x denotes any possible value
21:57:38 <shachaf> What?
21:57:42 <Tekmo> So for Void -> A
21:57:46 <Tekmo> You would write
21:57:49 <Tekmo> f {x} = x
21:57:54 <copumpkin> ick
21:58:07 <copumpkin> Void has no values in it
21:58:08 <shachaf> My syntax is the best one.
21:58:08 <Tekmo> Well, you need something for the right hand side
21:58:09 <shachaf> Argument over.
21:58:17 <ddarius> f !{x} = x -- Yay!
21:58:21 <copumpkin> and if it did, they wouldn't be of type A
21:58:34 <Tekmo> Ok, so with shachaf's syntax
21:58:36 <Tekmo> we would write
21:58:37 <shachaf> type A = Void -- what now, copumpkin?
21:58:38 <Tekmo> f {}
21:58:46 <shachaf> Tekmo: That's not my syntax. :-(
21:58:50 <Tekmo> I mean
21:58:50 <ski> Tekmo : `^' on the left-hand side of `=' is the "failing pattern", it always fails -- while on the right-hand side is the "failing expression", which fails to compute a value
21:58:57 <Tekmo> for the function pattern matching sugar
21:59:14 <Tekmo> So
21:59:17 <Tekmo> f ^ = ^?
21:59:27 * cmccann thought an empty case block was really the obvious way to go?
21:59:34 <shachaf> cmccann confirms it.
21:59:40 <ski> Tekmo : yes -- let's consider `foo x = (x,^)'
21:59:43 <Tekmo> cmcann: How do you do the syntactic sugar for pattern matching
21:59:45 <liyang> Tekmo: ¯\(°_0)/¯
21:59:48 <ddarius> cmccann: It's obvious but solves a different problem.
21:59:48 <Tekmo> Would you write: f {}
21:59:54 <shachaf> Tekmo: You don't need it.
21:59:55 <ski> Tekmo : this would be illegal, since the "function" isn't deterministic
22:00:00 <shachaf> Oh, what's the problem being solved?
22:00:04 <Tekmo> I don't mind it at all
22:00:07 <Tekmo> I think it looks nice
22:00:14 <Tekmo> I was just wondering if it would confuse the parser or not
22:00:35 <ski> Tekmo : this is basically the other half of the fact that `bar x = (x + 1) | (x - 1)' is illegal (it isn't deterministic)
22:01:04 <ddarius> shachaf: The goal is to have a -pattern- that always fails, so that it is a unit to a disjunctive pattern.
22:01:19 <shachaf> ddarius: Ah.
22:01:19 <ski> Tekmo : let's for the moment ignore the concrete syntax (apart from having *some* concrete syntax for purposes of discussion), ok ?
22:01:23 * hackagebot word8 0.0.1 - Word8 library  http://hackage.haskell.org/package/word8-0.0.1 (KazuYamamoto)
22:01:25 * hackagebot markdown 0.1.1 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.1 (MichaelSnoyman)
22:01:27 <Tekmo> ski: Yeah
22:01:41 <A2kmm> benmachine: Right, so I have a choice of "deriving instance (forall a . Eq (forward a)) => Eq (Model forward)" with StandaloneDeriving, RankNTypes, ConstraintKinds, UndecidableInstances or "deriving instance Eq (Model OrForward) etc..." w/StandaloneDeriving, FlexibleInstances
22:02:01 <ddarius> Cale: You'll like what this word8 package has just added.
22:02:07 <copumpkin> lol
22:02:11 * copumpkin sulks
22:02:27 <shachaf> Oh boy, Data.Char8?
22:02:32 <ski> Tekmo : the point is that, this `^', the identify of `|' seems to be what `()' in Agda2's `void ()' is really about -- it's just that Agda2 doesn't allow you to provide a right-hand side in this case
22:02:33 <benmachine> A2kmm: I don't think you need RankNTypes or ConstraintKinds
22:02:52 <benmachine> A2kmm: just deriving instance (Eq (forward a)) => Eq (Model forward)
22:03:05 <aristid> shachaf: you should've seen the benchmark fest on web-devel
22:03:15 <Tekmo> ski: Right, I get the purpose of it
22:03:16 <ski> s/ seems/, seems/
22:03:41 <Tekmo> ski: Earlier you mentioned: f a = (a, ^)
22:04:06 <ski> Tekmo : now, i'm not sure yet whether one'd ever use `^' in the definiens other than like `f ... (...^...) ... = ^'
22:04:50 <ski> Tekmo : yes, and that would be illegal since that "function" is really not a function (it's partial, it doesn't always give a value (of fact it always does not give a value))
22:05:06 <Tekmo> ski: What about making this purely syntactic
22:05:11 <Tekmo> ski: In other words, if you write
22:05:27 <Tekmo> ski: f (a * (b + c)) = (a * b) + (a * c)
22:05:35 <ski> Tekmo : compare this with `bar x = (x + 1) | (x - 1)', which would be illegal, since this (also) is not really a function (it has multiple "results")
22:05:35 <Tekmo> ski: The compiler just desugars that to
22:06:00 <Tekmo> ski: f (a * Left b) = Left a * b
22:06:07 <Tekmo> ski: f ( a * RIght b) = Right (a * c)
22:06:11 <Tekmo> and then type-checks it
22:06:13 <Tekmo> to ensure it is valid
22:06:24 * hackagebot gloss 1.7.6.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.6.1 (BenLippmeier)
22:06:26 * hackagebot gloss-raster 1.7.6.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.6.1 (BenLippmeier)
22:06:28 * hackagebot gloss-examples 1.7.6.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.6.1 (BenLippmeier)
22:06:30 <Tekmo> The compiler takes care of reducing it to a sum of products
22:06:39 <Tekmo> and then matches each product on the left hand side
22:06:46 <Tekmo> with a product on the right hand side
22:06:54 <Tekmo> and if there is a mismatch it fails to desugar
22:07:06 <rking> Just curious.  Is this at all possibly valid Haskell?: >=( @ &&      >>=( @ ()
22:07:14 <rking> The misbalanced parens probably screw it, no?
22:07:36 <shachaf> As a full expression, on its own?
22:07:37 <otters> :t (()
22:07:38 <lambdabot> parse error (possibly incorrect indentation)
22:07:53 <Tekmo> ski: So, with your example
22:07:54 <rking> shachaf: Under any possible Haskell context.
22:08:00 <Tekmo> ski: bar x = (x + 1) | (x - 1)
22:08:05 <Tekmo> ski: it fails to desugar
22:08:06 <shachaf> rking: Sure. Between ""s, for example.
22:08:12 <Tekmo> ski: Since there is just one term on the left
22:08:14 <rking> shachaf: I'd even accept the closing )'s on another line.
22:08:15 <Tekmo> ski: but two on the right
22:08:24 <rking> shachaf: Nono, that's too-much-cheating.
22:08:37 <ddarius> shachaf: They always change the goalposts.
22:08:43 <Tekmo> ski: But you could instead right
22:08:50 <Tekmo> ski: bar (x | x) = (x + 1) | (x - 1)
22:08:51 <Tekmo> *write
22:08:58 <ski> when checking an equation involving `|' ior `^', it (roughly speaking) has to be the case that for each branch of a `|' or `^' in the pattern, there has to be a unique branch for each `|' and `^' in the body  (in case no `|' or `^' is used in the pattern, one can treat this as a disjunctive pattern with one case)
22:09:09 <shachaf> rking: Next you'll tell me you don't want a -- at the beginning either.
22:09:14 <rking> Right. =)
22:09:17 <Tekmo> ski: I agree
22:09:21 <shachaf> This problem is too ill-defined.
22:09:25 <Tekmo> ski: I think we are now saying the same thing
22:09:33 <Tekmo> ski: Which is that there should be an equal number of "branches" on both sides
22:09:39 <rking> And no {- or -} in sight.
22:10:45 <Tekmo> ski: So if I write out: f (a | (b | c)) = (a | b) | c
22:10:51 <ski> Tekmo : "`f (a * (b + c)) = (a * b) + (a * c)' ... desugars to `f (a * Left b) = Left a * b', `f ( a * RIght b) = Right (a * c)'" -- how would it know the first branch in the body corresponded to the first branch in the pattern (and similarly for the second branch) ? (instead of e.g. the first branch in the body corresponding to the second branch in the pattern)
22:10:53 <Jafet> Russian Haskell )))
22:11:03 <Tekmo> ski: It uses distributivity
22:11:16 <Tekmo> ski: The compiler uses the distributive law to reduce both sides to a sum of products
22:11:25 <Tekmo> ski: And then checks that the number of products on each side matches
22:12:16 <chumma_> hello all came here from tryhaskell
22:12:54 <Tekmo> ski: So when you write: "f (a * (b + c))", the compiler first reorders that to "f ((a * b) +(b * c))"
22:13:09 <Tekmo> ski: Then does the branch number check
22:13:45 <Tekmo> Well, right now I have to head out
22:13:47 <ski> Tekmo : "it fails to desugar","Since there is just one term on the left","but two on the right" -- note that `foo ((Left a0 | Right a1),(Left b0 | Right b1)) = Left (a0,(Left b1 | Right b0)) | Right (a1,(Left b0 | Right b1))' should work -- here the number of `|'s on the two sides doesn't match
22:14:22 <Tekmo> So that would be
22:14:48 <ski> Tekmo : itym s/distribu/associa/)
22:14:51 <Tekmo> foo ((a0 + a1) * (b0 + b1) = (a0 * (b1 + b0)) + (a1 * (b0 + b1))
22:14:55 <Tekmo> If you distribute both sides
22:14:59 <Tekmo> you get four terms on both sides
22:15:11 <ski> chumma_ : hello there
22:15:28 <Tekmo> However, the trick is defining the ordering
22:15:58 <Tekmo> Anyway, I have to head out
22:16:02 <Tekmo> I'll talk to you later
22:16:19 <ski> Tekmo : yeah -- but i'd also like to be able to say `foo (Left a | Right b) = Left b | Right a'
22:16:24 * hackagebot buildbox 2.1.1.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.1.1 (BenLippmeier)
22:16:37 <ski> iow, order of the branches oughtn't matter
22:17:25 <ski> @tell Tekmo "If you distribute both sides you get four terms on both sides","However, the trick is defining the ordering", yeah -- but i'd also like to be able to say `foo (Left a | Right b) = Left b | Right a' -- iow, order of the branches oughtn't matter
22:17:25 <lambdabot> Consider it noted.
22:18:01 <ski> chumma_ : so, if you have any question about Haskell, feel free to ask :)
22:24:46 <johnw> what's the current state of the Pipes vs. Conduits debate? :)
22:24:58 <shachaf> johnw: #haskell-flamewars, please.
22:25:08 <johnw> I didn't even know there was such a channel
22:25:16 <johnw> I'm more just wanted to know who was winning, not why
22:25:26 <shachaf> johnw: Tekmo just left, sorry.
22:25:46 <johnw> My interest in asking is knowing which to better devote my time to
22:26:00 <shachaf> Neither.
22:26:03 <johnw> I read the tutorial for pipes finally last night, and was getting very excited by the way he's made everything a Category
22:26:07 <mm_freak_> johnw: likely conduit is winning in terms of package names…  the internals are pretty much the same today
22:26:10 <shachaf> Just hide under a table until the mess is over.
22:26:19 <johnw> :)
22:26:20 <mm_freak_> johnw: michael snoyman has adopted the concept of pipes for conduit
22:26:24 * hackagebot path-pieces 0.1.2 - Components of paths.  http://hackage.haskell.org/package/path-pieces-0.1.2 (MichaelSnoyman)
22:26:31 <mm_freak_> johnw: so in a sense both have won =)
22:26:31 <johnw> and I saw there is a pipes-conduit too
22:26:48 <johnw> I can imagine a conduit-pipe would be just as easy
22:27:16 <mm_freak_> johnw: yeah…  if you look into the conduit package, you will find that there is a Pipe type now =)
22:27:25 <johnw> ah, cool
22:27:43 <johnw> how is conduit now with the category laws?
22:27:56 <mm_freak_> dunno, i haven't written conduits for some time
22:29:08 <benmachine> shachaf: I've been hiding since around the time iteratees turned up, it's worked pretty well so far
22:29:35 <shachaf> We con du it!
22:31:24 * hackagebot monad-logger 0.2.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.2.1 (MichaelSnoyman)
22:41:24 * hackagebot hamlet 1.1.0.3 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.0.3 (MichaelSnoyman)
22:41:26 * hackagebot shakespeare 1.0.1.4 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.1.4 (MichaelSnoyman)
22:46:28 * hackagebot shakespeare-css 1.0.1.5 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.1.5 (MichaelSnoyman)
22:46:30 * hackagebot shakespeare-js 1.0.0.6 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.0.0.6 (MichaelSnoyman)
22:46:32 * hackagebot shakespeare-text 1.0.0.5 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.0.5 (MichaelSnoyman)
22:46:34 * hackagebot persistent 1.0.1.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.0.1.2 (MichaelSnoyman)
22:46:36 * hackagebot persistent-template 1.0.0.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.0.0.2 (MichaelSnoyman)
22:47:33 <johnw> wow, he's busy tonight :)
22:51:38 * hackagebot repa-examples 3.2.2.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.2.2.1 (BenLippmeier)
22:52:30 <ski> @tell Tekmo "What if you wrote a signature like: true, false :: a -> a -> a","and it automatically deduced the two functions that inhabited that type" -- how would you know which of `true',`false' selected which argument ?
22:52:30 <lambdabot> Consider it noted.
22:53:08 <shachaf> ski: I'd like to know how to count the number of inhabitant of a polymorphic type like (forall a. a -> a -> a)
22:53:12 <ski> cmccann : "/me thinks implementation inheritance was and is a terrible mistake." -- mayhaps, but i think it's noteworthy that math uses it sometimes
22:53:26 <ski> @tell Tekmo "In fact, here's how you implement both the check and the implementation","You use associativity and distributivity for product and sum to reduce each side to its algebraic normal form" -- hm, i think i see now what you meant -- you'd then match disjuncts from definiendum with ones from definiens based on which free variables (not occuring in every branch) they have, and you require this matching to be unambiguous
22:53:26 <lambdabot> Consider it noted.
22:53:32 <shachaf> For concrete types you can count the number of inhabitants using addition/multiplication/exponentiation/etc.
22:53:36 <ski> cmccann : "/me thought an empty case block was really the obvious way to go?" -- yes, it's one obvious way -- but just as we have a choice between `foo xy = case xy of {A x -> ..x..; B y -> ..y..}' and `foo (A x) = ..x..; foo (B y) = ..y..' (and `foo (A x | B y) = ..x.. | ..y..', for the generalization of disjunctive patterns which i was talking about), it'd be nice to have a similar choice for the nullary case
22:54:07 <ski> shachaf : yeah, i'd like to grok that better as well ;)
22:54:41 <shachaf> edwardk once mentioned a paper that talked about that, I think.
22:54:47 <shachaf> I don't remember exactly, though.
22:54:51 <edwardk> bout what?
22:54:55 * edwardk skims backwards
22:54:59 <cmccann> I wasn't really reading the earlier conversation, so yeah I see why an empty case didn't help
22:55:00 <shachaf> edwardk: Counting the inhabitants of polymorphic types.
22:55:13 <shachaf> E.g. (forall a. a -> a -> a) ~ Bool
22:55:30 <edwardk> shachaf: oh, that was dpiponi who wrote a blog post on it, and i think conal followed up
22:55:49 <edwardk> not sure of any actual bona fide academic papers on the topic
22:55:57 <rwbarton> that link i posted earlier talks about this (or refers to a paper which does)
22:56:10 <shachaf> Oh, *that* TWF.
22:56:12 <ski> edwardk : counting number of inhabitants of closed types involving `->' and `forall' (at least in case they're finite)
22:56:25 * hackagebot lojysamban 0.0.8 - Prolog with lojban  http://hackage.haskell.org/package/lojysamban-0.0.8 (YoshikuniJujo)
22:57:27 <m3ga> messing with Data.Conduit.Attoparsec and i'm getting a DivergentParser error and i can't figure out why. any clues?
22:57:47 <ski> (shachaf : nitpick, s/polymorphic types/universal types/ -- a polymorphic type would be something like `Compose' having kind `forall k0 k1. (k1 -> *) -> (k0 -> k1) -> (k0 -> *)')
22:58:02 <shachaf> ski: (Fair enough.)
22:59:03 <ski> (this is a pet peeve of mine :)
22:59:44 <ski> (.. also when people say "polymorphic type" but really mean "parametric type" (i.e. a type function))
22:59:57 <cmccann> btw, ski. were you one of the people in here interested in linear logic?
23:00:28 <edwardk> ski has many pet peeves. i wonder how he affords to feed them all
23:01:05 <ski> cmccann : yes
23:01:32 <cmccann> finished most of a simple toy linear logic implementation the other day that I think is kinda cute. want to help me figure out how to make the exponentials work? :D
23:02:33 <cmccann> under the constraint that every function argument is used linearly, the rest of it pretty much works automatically
23:03:08 <ski> edwardk : well, i (mostly) only feed them when people trigger them where i see, which is thankfully not too often :)
23:04:36 <ski> cmccann : by "implementation" do you mean something like a theorem prover / proof searcher ? or normalizing proofs ?
23:05:00 <cmccann> no, as in just writing haskell functions
23:05:22 <cmccann> though unwrapping in order to apply the functions is a little awkward for some connectives
23:05:27 <ski> i'll assume you mean "normalizing proofs" by that, then
23:06:05 <cmccann> ski, I mean stuff like "curry = passocr ∘ (dmtensor `par` id) :: (x ⊗ y ⊸ z) ⊢ (x ⊸ y ⊸ z)"
23:07:12 <cmccann> I *think* that assuming the linearity constraint on function arguments, it's impossible to write any function that isn't valid in linear logic
23:07:55 <cmccann> I'm really not sure how to add the exponentials except by fiat. which isn't very satisfying, but maybe that's inherent to what they mean?
23:08:46 <ski> cmccann : hm, with what type for `par' ?
23:09:36 <edwardk> :t par
23:09:37 <lambdabot> forall a b. a -> b -> b
23:09:38 <cmccann> well, par and with are expressed via negations
23:09:44 <edwardk> =)
23:10:32 <dunric> monochrom: Hi, yesterday you've tried to remove my ban on #haskell. Do you remember ?
23:10:38 <cmccann> and plus/tensor are just Either and (,)
23:11:37 <cmccann> what makes it all work is lots of Cont-type junk shoved everywhere
23:12:29 <cmccann> :t \k -> k . Left $ \x -> k . Right $ x
23:12:30 <lambdabot> forall b b1. (Either (b1 -> b) b1 -> b) -> b
23:12:56 <cmccann> ^ that's basically the representation used for the identity function or LEM
23:13:01 <cmccann> which are the same thing in linear logic
23:14:36 <shachaf> I know someone who was teaching a Haskell class which involved a lecture on parallelism. But they were using Hugs, so he made a library with fake implementations of all the functions in Control.Parallel that didn't actually speed things up. I thought that was kind of weird, but he told me it was par for the course.
23:14:48 <cmccann> shachaf, >:[
23:14:50 <dunric> Hi, can anybody also unban my IP address (213.151.77.75) ?
23:15:31 <shachaf> cmccann: You're just a h8r.
23:16:00 <cmccann> ski, anyway, if you're interested I can hpaste the code or something. I kinda lost interest when I couldn't find a way to make the exponentials work nicely.
23:16:12 <otters> :pl \k -> k . Left $ \x -> k . Right $ x
23:16:17 <otters> @pl \k -> k . Left $ \x -> k . Right $ x
23:16:17 <lambdabot> ap (. Left) (. Right)
23:16:23 <dunric> Yesterday I get a confirmation to remove my ban but only name and IP of the hotspot I was connected were cleared.
23:16:39 <shachaf> otters: Maybe you mean (\k -> Left (\x -> k (Right x)))?
23:16:44 <copumpkin> dunric: you kept joining #haskell-ops asking to unban but never stayed for more than a minute so we couldn't talk to you
23:17:01 <otters> shachaf: I'm just using what cmccann wrote
23:17:09 <copumpkin> dunric: all I did was remove the ban I saw for you in the ban list. Is something still there? as far as I remember, you were banned for running a duplicate lambdabot in the channel
23:17:10 <copumpkin> which was annoying
23:17:11 <shachaf> Oh.
23:17:24 <shachaf> Maybe cmccann was talking about something else.
23:18:03 <kirindave> So, it's late and I've ridden a lot on my bike today. I need a sanity check for my haskell newbie brain.
23:18:04 <cmccann> shachaf, it's the law of the excluded middle, being faked via CPS "double negation".
23:18:26 <kirindave> I have an IO action MyType a -> IO String
23:18:27 <shachaf> cmccann: Oh, you can use k on the Left too, I guess.
23:18:34 <shachaf> But it's not really necessary.
23:18:42 <kirindave> I'd like to chain this with some function String -> String
23:18:42 <shachaf> The perils of reusable continuations!
23:18:56 <dunric> copumpkin: I was on #haskell but not connected from my home but hotspot. I talked about my ban (unintentional lambdabot) and `monochrom` cleared my ban but not my original IP address.
23:18:59 <cmccann> i.e., read "(Either (a -> r) a -> r) -> r" as "Either (Not a) a"
23:19:07 <kirindave> So I said myFancyIoAction >>= (liftM mySimpleFunction)
23:19:11 <copumpkin> dunric: I cleared one such ban earlier today
23:19:12 <shachaf> f :: MyType -> IO String; g :: String -> String; x :: MyType; g <$> f x :: IO String
23:19:20 <shachaf> kranius: You probably don't want >>= *and* liftM
23:19:20 <copumpkin> dunric: which IP is that?
23:19:50 <shachaf> s/ranius/irindave/
23:19:50 <dunric> copumpkin: dunric from 213.151.77.75
23:19:57 <copumpkin> that's the one I removed earlier today
23:20:04 <copumpkin> did you try recently?
23:20:05 <kirindave> shachaf: Doesn't liftM make a String -> String a String -> IO String
23:20:41 <copumpkin> it'll make String -> String into IO String -> IO String
23:20:43 <dunric> copumpkin: yesterday evening 23:00 (GMT+1) but refused as still banned
23:20:47 <otters> :t (return .)
23:20:48 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
23:21:01 <copumpkin> dunric: yeah, that might have been before I removed it
23:21:03 <kirindave> Ah I misread the type.
23:21:08 <copumpkin> dunric: anyway, check the ban list. It's not there anymore :)
23:21:12 <shachaf> kirindave: No, (return .)
23:21:13 <kirindave> This is why I should not do this so tired.
23:21:24 <dunric> copumpkin: great, thank you :)
23:21:26 <shachaf> kirindave: foo >>= (return . bar) will do what you want.
23:21:32 <shachaf> kirindave: That happens to be the definition of liftM. :-)
23:23:52 <kirindave> As none of these things work
23:23:56 <kirindave> I should just use do notation
23:24:05 <kirindave> I was just like, "Oh hey point free because it is good for my psyche."
23:24:14 <shachaf> kirindave: fmap g (myIOThing)
23:24:30 <shachaf> fmap :: (a -> b) -> IO a -> IO b
23:25:48 <kirindave> I am too tired to understand why none of these work. :\
23:26:29 <shachaf> Don't write code past 23:00... Unless you have a type system.
23:26:39 <kirindave> Yeah well
23:26:54 <kirindave> I just want to take an Fancy a -> IO String and add an extra String -> String on the end.
23:27:03 <kirindave> In a point free style. :)
23:27:05 <shachaf> kirindave: You have to apply the argument before you can fmap.
23:27:23 <dunric> What's the `proper/efficient way` to fold over a list with a function returning an IO action ?
23:27:26 <shachaf> @pl \fancy -> fmap s2s (fancy2ios fancy)
23:27:26 <lambdabot> fmap s2s . fancy2ios
23:27:34 <dunric> foldl' (\acc e -> fmap (+acc) ioAction e) (return 0) [1..10]
23:27:35 <shachaf> See?
23:27:43 <kirindave> Oh I see.
23:28:19 <shachaf> kirindave: I resisted the urge to correct your terminology before, but I shouldn't've!
23:28:32 <shachaf> "MyType a -> IO String" isn't an IO action. It's a function that returns an IO action.
23:28:36 <kirindave> shachaf: Never resist the curge to correct me.
23:28:39 <Nisstyre> kirindave: what should "fmap (fmap toUpper) getLine" do?
23:29:12 <Nisstyre> feel free to replace fmap with liftM
23:29:15 <kirindave> Nisstyre: Get a line, capitalize each character. The inner fmap is over List.
23:29:20 <Nisstyre> yeah
23:29:21 <shachaf> The *urge* to correct you, kirindave.
23:29:32 <kirindave> shachaf: You pass the test.
23:29:41 * shachaf = sheeple
23:30:28 <kirindave> But there
23:30:39 <kirindave> I replaced my other way of doing Sass compilation in hakyll with conduits.
23:30:53 <dunric> Is there a better way then "foldl' (\acc e -> fmap (+acc) ioAction e) (return 0) [1..10]" ?
23:31:06 <Nisstyre> also, if you want to do folding with IO there is foldM and foldM_
23:31:49 <dunric> Is there a strict version of foldM or am I on my own here ?
23:32:25 <Nisstyre> I'm sure you can use strict IO with it
23:32:34 <Nisstyre> unless you meant something different
23:32:52 <Nisstyre> I don't see why it being strict or not matters
23:33:24 <Nisstyre> oh sorry, I'm tired
23:33:29 <dunric> I'm looking for an equivalent of foldl' updating accumulator with the result of IO action. Performance reasons.
23:33:31 <Nisstyre> I thought you were kirindave :|
23:33:50 <dunric> np :)
23:35:04 <kirindave> https://gist.github.com/3774612
23:35:07 <kirindave> And it works.
23:35:09 <kirindave> Kinda slow tho.
23:35:14 <kirindave> Because ugh, is sass slow.
23:35:26 <kirindave> at least to start up. Such is the price I pay for shelling out to ruby.
23:35:41 <Nisstyre> good god
23:35:46 <Nisstyre> why man?
23:35:52 <kirindave> Nisstyre: Why which?
23:35:52 <zhulikas> @hoogle unsafeCompiler
23:35:53 <lambdabot> No results found
23:35:56 <Nisstyre> kirindave: ruby
23:36:05 <Nisstyre> I mean, just write it all in one language
23:36:07 <kirindave> Nisstyre: Is there a sass implementation in Haskell?
23:36:08 <kirindave> No
23:36:14 <Nisstyre> :(
23:36:25 * hackagebot hakyll 3.4.2.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.4.2.1 (JasperVanDerJeugt)
23:36:38 <kirindave> I've _considered_ asking if we can use a different css compiler.
23:36:45 <kirindave> But the thing is, all the work is done in sass now.
23:36:52 <kirindave> So, it's a bit late for that call.
23:37:05 <Nisstyre> kirindave: in that case, why not write it all in ruby?
23:37:23 <kirindave> Nisstyre: Oh, I had code on hand to do ssg in Haskell.
23:37:39 <Nisstyre> fair enough I suppose
23:37:46 <kirindave> And as much as I am a fan of mojombo's work, I like hakyll a lot more than I like jekyll
23:38:20 <kirindave> I wonder if lucious is almost scss tho.
23:38:36 <kirindave> Cuz it _would_ be slick to just quietly flip that over. We don't use any mixins.
23:38:56 <kirindave> Nisstyre: Web development is pretty much an exercise in cross-environment work anyways. Whatcha gonna do?
23:39:35 <kirindave> Nisstyre: "Do it all in one language" leads you spiraling down a narrowing funnel of madness, orbit tightening until you are actually using node.js like a crazyperson.
23:39:36 <Nisstyre> kirindave: I suppose that's why people want to create various languages that attempt to unify these technologies
23:40:54 <rking> http://cdent.org/examples/hello-world/
23:41:46 <kirindave> Nisstyre: Compare https://gist.github.com/a91a19bbd776a35e297a with your average jekyll project. Much better.
23:44:00 <kirindave> Damn. I _could_ use Lucious for css templating instead of sass. It's actually possible.
23:44:11 <kirindave> As long as we don't use the mixins.
