00:00:04 <ew0_> ow, it works!
00:00:05 <ew0_> thanks
00:00:10 <ew0_> you made my life so much easier
00:01:59 <ew0_> hey. Data.HashMap is deprecated
00:02:04 <ew0_> but isnt Map slow?
00:02:06 <fmap> record syntax exists for the ease of lenses generation i believe
00:03:11 <dibblego> record syntax exists because lenses were an afterthought
00:03:15 <mzero> ew0
00:03:36 <mzero> Map is reasonable, especially if you need to read out the pairs in key order
00:03:49 <mzero> if you want faster performance, tre IntMap
00:03:56 <ew0_> uhm
00:03:58 <ew0_> ok
00:04:08 <mzero> or HashMap
00:04:12 <mzero> from unordered-containers
00:04:42 <mzero> (which uses IntMap internally, but extends to all Hashable key types)
00:06:05 <liyang> I don't think HashMap uses IntMap internally anymore.
00:06:48 <ew0_> HashMap is deprecated
00:06:50 <ew0_> =/
00:06:55 <ew0_> IntMap is fine for me
00:07:06 <ew0_> my key is an Int32
00:07:11 <mzero> ew0 - I don't think you are looking at the right HashMap
00:07:21 <ew0_> Data.HashMap?
00:07:28 <mzero> the one from the unordered-containers is certainly not depricated
00:07:39 <mzero> which package? different packages can export modules under the same names
00:07:49 <liyang> http://hackage.haskell.org/package/unordered-containers
00:08:18 <mzero> yes, that one certainly isn't deprectaed - I'm wondering which one ew0_ is looking at
00:08:30 <ew0_> let me reproduce the error
00:10:40 <danr> I'm also puzzled which HashMap is deprecated...
00:11:38 <NemesisD> hi all. is there any way in a child thread i can execute some cleanup when the main thread is killed/shut down
00:12:11 <ew0_> ok
00:12:14 <ew0_> I was being silly
00:12:23 <ew0_> only the type sinonym is being deprecated
00:12:26 <mzero> NemesisD: OS thread or Haskell thread?
00:12:46 <ew0_> type HashMap k v = Map k vSource  The HashMap is a type synonym for Map for backward compatibility. It is deprecated and will be removed in furture releases.
00:12:48 <NemesisD> mzero: haskell thread started with forkIO
00:13:37 <mzero> ah - that's the hashmap package
00:14:25 <danr> ew0_: ok, but it just means that if you want to use the hashmap package, you're recommended to use the type constructor Map instead of the type synonym HashMap
00:14:27 <mzero> I don't think you want that one, try the unordered-containers package
00:14:34 <ew0_> yeah
00:14:42 <danr> it does not mean that HashMap is deprecated.
00:14:44 <ew0_> I don't know why I freaked out so much
00:14:53 <danr> ok :)
00:14:57 <ew0_> guess I'm getting jump by so many compiler errors
00:15:02 <ew0_> jumpy xD
00:15:14 <mzero> the HashMap in unordered-containers has been heavily optimized by the author, who is an expert in Haskell opt.
00:15:18 <ew0_> python didn't scold me this much xD
00:15:35 <marajjj> hi there
00:15:40 <ew0_> hi
00:16:09 <marajjj> i'm trying to learn haskell language..
00:16:46 <mzero> NemesisD: I don't think there is a way to get notified of a thread death for a thread you didn't start with forkFinally
00:17:05 <mzero> marajjj: then you came to the right channel
00:17:39 <NemesisD> mzero: well i guess it may not necessarily be thread death, i just need my child thread to clean itself up when the program is trying to exit
00:18:12 <NemesisD> i could do forkfinally in a pinch, it just kind of sucks because the thread isn't self-contained
00:18:29 <marajjj> why?
00:18:40 <marajjj> is this a wrong channel?
00:18:52 <ivanm> marajjj: no, this is the right channel
00:18:55 <ivanm> as mzero said
00:19:13 <marajjj> ahh.. i'm sorry
00:19:17 <mzero> NemesisD: hmmm... atexit functionality doesn't appear to exist
00:19:26 <mzero> probably with very good reason!
00:21:27 <maukd> foreign import ccall "stdlib.h atexit" c_atexit :: (FunPtr (IO ())) -> IO CInt
00:22:00 * hackagebot tls 0.9.11 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.9.11 (VincentHanquez)
00:22:12 <dmos> I"m trying to get a cabal-dev version rolling under 7.6 but tar 0.4.0.0 fails because of old-time/time. Has anyone worked on this already?
00:22:32 <startling> hmm, when I have a Writer [String], do I do "tell ["hello"]"?
00:22:44 <maukd> :t tell
00:22:45 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
00:22:50 <startling> or should I have a Writer String and just "tell "hello""?
00:22:59 <maukd> :t runWriter
00:23:00 <lambdabot> forall w a. Writer w a -> (a, w)
00:23:05 <startling> ah
00:23:11 <startling> so tell ["hello"] it is
00:23:16 <maukd> > runWriter (do tell "hello"; tell "world")
00:23:17 <lambdabot>   ((),"helloworld")
00:23:21 <startling> and I guess it's like that so it can mappend.
00:23:27 <maukd> > runWriter (do tell ["hello"]; tell ["world"])
00:23:29 <lambdabot>   ((),["hello","world"])
00:23:38 <startling> yeah, that's ^ what I want
00:23:43 <startling> thanks!
00:23:49 <NemesisD> mzero: hmm my Control.Concurrent doesn't seem to export forkFinally
00:23:50 <maukd> maybe even use DList
00:24:03 <maukd> I can't imagine mappend being all that efficient for []
00:24:20 <augur> maukd: isnt mappend for [] just (++)?
00:24:26 <maukd> yes
00:24:26 <shachaf> Depends on how you're using Writer.
00:24:43 <shachaf> do { tell blah; tell blah; tell blah } should be OK.
00:24:46 <augur> so its not THAt inefficient
00:24:55 <maukd> augur: quadratic if nested to the left
00:24:55 <mzero> NemesisD: ah, fie, ghc 7.6
00:25:11 <augur> maukd: true
00:25:32 <startling> shachaf: woah cool, ReaderT a (Writer e) b  is already a MonadWriter
00:25:40 <NemesisD> mzero: i can try finally i guess
00:25:53 * shachaf isn't sure that ReaderT is worth it.
00:26:17 <startling> shachaf, it works for this application.
00:26:38 <maukd> @unmtl ReaderT a m b
00:26:39 <lambdabot> a -> m b
00:27:14 <NemesisD> forkIO $ doStuff `finally` cleanUp doesn't seem to work
00:29:29 <NemesisD> evidently because its an async exception?
00:32:18 <NemesisD> i'll have to look at this later, too  tired to stay awake. cheers, guys!
00:40:09 <pharaun> I have a general quickcheck question, for ex say i have a "UniqueFile" now i have several variant of UniqueFile, right now i am generating the other variant in the properties itself, but when it fails it only lists the input UniqueFile but not the one generated in properties, i noticed you could do some type stuff to restrict a input to a certain sub type like Positive, is there any way i can somehow do the same with my alte
00:40:53 <pharaun> or is this something that quickcheck is not well equipped to deal with and i should be doing some of *that* types of test in hunit instead?
00:41:15 <ivanm> pharaun: not quite sure I understand what you're saying
00:41:27 <pharaun> maybe easier with source code sample, hold on
00:41:29 <ivanm> are you a) wanting a new type wrapper to limit the types of UniqueFiles you generate?
00:41:43 <ivanm> or are you wanting something more analogous to "this is test on lists, but don't run it on empty lists" ?
00:43:54 <hpaste> pharaun pasted “quickcheck - UniqueFile” at http://hpaste.org/75288
00:44:42 <pharaun> ivanm: i guess the 2nd one, but the issue is some of the children gen depends on what the parent generated IE i want to generate X without the following value then modify it
00:45:25 <ivanm> how do you define UniqueFile ?
00:45:41 <pharaun> data UniqueFile = UniqueFile (Set.Set FilePath) FileID DeviceID FileOffset (Maybe String)
00:46:06 <ivanm> pharaun: oh, you're trying to have intelligent Arbitrary instances?
00:46:08 * ivanm gave up on that
00:46:15 <pharaun> yeah something like that
00:46:19 <pharaun> no way to have that?
00:46:54 <ivanm> pharaun: put it this way: it's an absolute PITA to try and sanely generate graphs with QC
00:46:57 <pharaun> well i guess as a fallback would it be possible to at least print out what i generated for the failing arbitrary input
00:47:00 <pharaun> ah :\
00:47:16 <ivanm> I can't run some tests for my graphviz package because the generated Dot values are quite often stupid
00:47:24 <ivanm> so it might very well be possible
00:47:26 <pordan30> Is there some reason that haskeline-0.7.0.3 fails to install using cabal with "unrecognized option --disable-benchmarks" exceptions? Is this a known problem or anomalous?
00:47:26 <pharaun> this is the first time i got to use quickcheck and i thought this would be perfect for that
00:47:32 <ivanm> but I cbf spending the time doing it :)
00:47:43 <ivanm> pordan30: because the benchmark stuff was only added in cabal-install-0.14
00:48:00 <ivanm> so if you're using an older version, the flag doesn't make sense
00:48:03 <pharaun> ivanm: aha alright thanks, i guess i can keep *some* of the generated stuff and move some/rest of it into hunit or something
00:48:15 <ivanm> pordan30: also, why specify disabling benchmarks?  They shouldn't be getting built by default...
00:48:50 <pordan30> Is the solution to install from source and modify the flag, compile with an older version of GHC, or something else?
00:49:15 <pordan30> I have no idea - I haven't needed it before, but it's a build dependency for the current Agda distribution.
00:49:21 <ivanm> pordan30: ummmm...... what is giving you that error message?
00:49:21 <pharaun> ivanm: i guess one solution is to just accept two unique file then compare and discard this iteration if they won't work for "merging/mangling"
00:49:31 <ivanm> pharaun: yeah
00:50:02 <ivanm> pharaun: or if you know how to generate different types of values, then have helper functions to do that and don't rely on the Arbitrary instance
00:50:56 <pharaun> ivanm: yeah i already do that with some of my "helpers" but then it does not relly output what's wrong when it fails, ie it only prints out the arbitrary instance that it feeded to it
00:51:17 <pharaun> which is the main reason why i was looking into figuring out intelligent arbitrary stuff
00:51:29 <ivanm> huh; I get huge big long (as in 70000+ characters) outputs from QC...
00:51:53 <pharaun> UniqueFile (fromList [FilePath "/tmp/bar.gz"]) 0 0 2 (Just "D051EF9CF18AAAE8FCA76DDEB2BD1E67") <--- is example of one output
00:52:05 <pharaun> that's good, but its missing the 2nd one, which is what i generated in the property
00:52:12 <emias> ,
00:52:14 <pharaun> i need both to be able to debug in that case
00:52:38 <ivanm> pharaun: oh, so maybe your tests need re-doing?
00:53:00 <pharaun> what you mean by redoing?
00:53:16 <ivanm> oh, nvm
00:53:49 <pharaun> i guess for *most* of those cases i can just accept 2 unique file and ignore/abort out of that iteration if they matches too closely and that would be good enough probably
00:54:00 <ivanm> pharaun: maybe have your property take in a tuple of (UniqueFilePath, DiffFilePath) where the latter is a newtype around the first
00:54:10 <ivanm> because generating extra data inside a test is weird
00:54:13 <pharaun> yeah
00:54:20 <ivanm> I never realised that Gen was an instance of Prop :/
00:55:01 <pharaun> >_< alright i'll try the newtype wrapper or something, thanks :)
00:55:33 <ivanm> np
00:55:59 <ivanm> pharaun: maybe even have a newtype for _two_ paths...
00:56:32 <pharaun> yeah that gave me an idea since i am modifying the uniquefile, maybe i could just spin up a few newtypes like you said for the various type of "modification"
00:56:44 <pharaun> then merge and pass it into the code
00:56:59 <pharaun> would do what i want close enough and yield up enough useful data for debugging
01:03:00 <pharaun> ivanm: not perfect but that got me close enough to my goals for now, that works, thanks :)
01:03:10 <ivanm> np
01:07:32 <ew0_> ok, one more night of productive coding
01:07:34 <ew0_> time to sleep
01:07:36 <ew0_> gn
01:28:08 <bitonic> is there an "indexable" type class?  the ones in `keys' sound a bit too generic and are only for functors - I'd want something that work well on the three widely used "strings" (String, Text, and ByteString)
01:29:40 <pordan30> Is the class in Keys the Ix class? If not, then there is Ord a => Ix a available, which maps values onto Ints.
01:30:42 <bitonic> pordan30: I don't want to abstract over the key, but over the container.  the key is always an Int
01:30:52 <bitonic> maybe ListLike?
01:31:48 <bitonic> whoa.  ListLike is a big class.
01:32:13 <bitonic> it has what I want.  coolio
01:32:30 <bitonic> no wait.  why isn't Text an instance :(
01:33:06 <bitonic> well, there is listlike-instances.
01:37:25 <pordan30> i hadn't seen listlike before; it's pretty cool. it looks like the container class also allows that kind of abstraction.
01:38:02 <bitonic> pordan30: which container class?
01:39:58 <pordan30> there is an interface for container types called containers on hackage
01:40:17 <pordan30> with the normal finset operations defined and so forth
01:41:11 <bitonic> pordan30: those are not typeclasses, just data types
01:43:44 <pordan30> no, i was just looking at an obsolete package. my mistake :/
01:43:57 <startling> is there a nice way to have a WriterT whatever that logs to two different places? WriterT (WriterT m)?
01:44:22 <startling> will that even work?
01:44:35 <kallisti> startling: are the two outputs identical?
01:44:39 <startling> kallisti: no
01:44:51 <kallisti> should be possible
01:44:55 <startling> I want two differently-typed logs
01:44:59 <kallisti> you just need to change the interface so that you can choose which output to write to.
01:45:07 <shachaf> You can use a tuple as the output type...
01:45:50 <bitonic> kallisti: just have the datatype to have a nice monoid instances that separates the two streams
01:45:51 <shachaf> There's an instance (Monoid a, Monoid b) => Monoid (a,b)
01:45:51 <kallisti> bitonic: sure that works
01:45:51 <kallisti> you'd still probably benefit from a nice interface. as in tellA/tellB or whatever
01:45:58 <bitonic> or what shachaf said, with some helper functions
01:46:08 <startling> shachaf, oh, yeah! tuples of monoids are monoids, aren't they
01:46:08 <startling> > ([], "hello") ++ ([1, 2], "world!")
01:46:11 <lambdabot>   ([1,2],"helloworld!")
01:46:30 <startling> kallisti: yeah, tellA/tellB is trivial
01:46:35 <sithisbitch> >:t (++)
01:46:40 <startling> (,) mempty and flip (,) mempty
01:46:46 <sithisbitch> fatch, how dos it work ?
01:46:46 <merijn> :t (++)
01:46:48 <lambdabot> forall m. (Monoid m) => m -> m -> m
01:46:50 <startling> sithisbitch: it's mappend
01:46:54 <danr> nice smiley >:t
01:46:55 <sithisbitch> merijn, xie xie
01:46:58 <merijn> Ah, Caleskell
01:47:04 <sithisbitch> i thought (++) was for string only
01:47:09 <merijn> sithisbitch: It is
01:47:11 <startling> sithisbitch: lists only. it is
01:47:28 <startling> sithisbitch: lambdabot uses a nonstandard dialect
01:47:30 <merijn> sithisbitch: Lambdabot uses caleskell which has many prelude functions replaced with more general ones
01:47:37 <merijn> See for example
01:47:37 <sithisbitch> yes sorry, list, but here it looks like it's for all monoides
01:47:39 <merijn> :t (.)
01:47:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:47:43 <sithisbitch> ha ok
01:47:44 <maukd> we have the technology
01:47:45 <merijn> :t (Prelude..)
01:47:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
01:47:50 <bitonic> we have the expertise
01:47:53 <sithisbitch> maukd, I swa that :)
01:48:03 <maukd> :t flip
01:48:04 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:48:14 <startling> whaaaat
01:48:41 <startling> oh I see
01:48:46 <merijn> Caleskell is a good way to confuse newbies ;)
01:48:46 <startling> it's fmap flip
01:48:57 <merijn> :t fmap flip
01:48:58 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f1 (f (a -> b)) -> f1 (a -> f b)
01:49:02 <merijn> Nope
01:49:08 <bitonic> :t fmap (+1) 5
01:49:10 <lambdabot> forall a (f :: * -> *). (Num a, Num (f a), Functor f) => f a
01:49:22 <maukd> :t (sin, 2) + 1
01:49:23 <lambdabot> forall a t. (Floating a, Num t) => (a -> a, t)
01:49:28 <sithisbitch> is hoogle "embeded" in lambdabot ?
01:49:29 <startling> merijn: that already uses the more general flip, though
01:49:37 <bitonic> sithisbitch: @hoogle
01:49:38 <startling> :t fmap (Prelude.flip)
01:49:39 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f (a -> b -> c) -> f (b -> a -> c)
01:49:43 <merijn> sithisbitch: I think it just queries the hoogle site
01:49:46 <sithisbitch> @hoogle a -> a
01:49:47 <lambdabot> Prelude id :: a -> a
01:49:47 <lambdabot> Data.Function id :: a -> a
01:49:47 <lambdabot> GHC.Exts breakpoint :: a -> a
01:49:48 <startling> oh waiiit
01:49:52 <sithisbitch> sweet
01:49:53 <merijn> :t fmap Prelude.flip
01:49:54 <maukd> > first ($ 0.5) ((sin, 2) + 1)
01:49:55 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f (a -> b -> c) -> f (b -> a -> c)
01:49:55 <lambdabot>   (1.479425538604203,3)
01:50:00 <startling> no, it has its own hoogle
01:50:06 <startling> it worked when hoogle was down
01:50:26 <Veinor> > (3, 4) + 1
01:50:27 <lambdabot>   (4,5)
01:50:33 <startling> merijn: okay, I give up. what does it do?
01:50:43 <merijn> startling: I have no clue :p
01:50:46 <startling> oh heh
01:51:03 <merijn> :t fmap
01:51:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:51:10 <maukd> :t \f x -> fmap ($ x) f
01:51:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
01:51:19 <merijn> :t flip
01:51:20 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:51:21 <startling> flip [const, const, const] <*> [1, 2, 3] <*> "abc"
01:51:38 <startling> > flip [const, const, const] <*> [1, 2, 3] <*> "abc"
01:51:39 <lambdabot>   Couldn't match expected type `a1 -> a2 -> a -> b'
01:51:39 <lambdabot>         against inferred ...
01:51:50 <startling> :t flip [id]
01:51:51 <lambdabot> forall a. a -> [a]
01:51:58 <startling> ohhh
01:52:00 <startling> wat
01:52:06 <startling> flip [id, id, id] 3
01:52:13 <startling> > flip [id, id, id] 3
01:52:15 <lambdabot>   [3,3,3]
01:52:27 <startling> waaaat. that's isomorphic to flip?
01:52:29 <startling> crazy
01:52:46 <maukd> replace Functor f by ((->) e)
01:52:53 <startling> yeah
01:53:07 <startling> > flip (Maybe id) 3
01:53:08 <lambdabot>   Not in scope: data constructor `Maybe'
01:53:14 <startling> > flip (Just id) 3
01:53:16 <lambdabot>   Just 3
01:53:26 <maukd> oh wait
01:53:29 <startling> weird man
01:53:34 <maukd> :t flip `asTypeOf` sequence
01:53:35 <lambdabot> forall a b. [a -> b] -> a -> [b]
01:53:39 <maukd> I knew it
01:53:52 <startling> :t asTypeOf
01:53:53 <lambdabot> forall a. a -> a -> a
01:54:00 <startling> what's that?
01:54:06 <maukd> const
01:54:09 <shachaf> @ty flip flip `asTypeOf` (map . flip ($))
01:54:11 <lambdabot> forall a b. a -> [a -> b] -> [b]
01:54:17 <startling> ugh what
01:54:23 <maukd> @src asTypeOf
01:54:23 <lambdabot> asTypeOf = const
01:54:31 <maukd> similarly, ($) is id
01:54:40 <kallisti> startling: asTypeOf is a const where the 2 arguments must be the same type. it forces them to unify.
01:54:47 <startling> oh, I see
01:55:01 <startling> so it's handy in the same way seq is?
01:55:17 <startling> like
01:55:22 <quicksilver> well, seq is operational; asTypeOf is just helping the type checker
01:55:24 <kallisti> depends on what "the same way" is. I think of seq doing something completely different from asTypeOf
01:55:33 <startling> :y asTypeOf (12 :: Integer) 13
01:55:40 <startling> :t asTypeOf (12 :: Integer) 13
01:55:41 <lambdabot> Integer
01:56:03 <hiptobecubic> :t 13
01:56:04 <lambdabot> forall t. (Num t) => t
01:56:06 <quicksilver> asTypeOf can normally be replaced by explicit type signatures but it works in cases where the type signatures are not possible to write (without extentions) or are just very large + cumbersome to write.
01:56:16 <startling> mhm, understood
01:56:25 <startling> :t seq
01:56:26 <lambdabot> forall a t. a -> t -> t
01:56:36 <startling> is mostly the reason I equated it to seq
01:56:46 <maukd> :t asTypeOf `asTypeOf` seq
01:56:48 <lambdabot> forall a. a -> a -> a
01:57:14 <frerich> Hm, any native english speaker around? I'm writing an error message but I just realized that I'm unsure whether it's "X seems to be already installed" or "X seems to be installed already". Does anybody know? :-}
01:57:31 <kallisti> frerich: either
01:57:41 <kallisti> word order doesn't matter in this case.
01:57:42 <startling> frerich, yes, either
01:57:48 <frerich> Ah, interesting - thanks :-)
01:57:51 <donri> "X seems to already be installed" ;)
01:57:59 <startling> "X already seems to be installed"
01:58:09 <kallisti> "already, X seems to be installed"
01:58:12 <startling> frerich: adverbs are pretty flexible this way
01:58:14 <maukd> I heard you can pronounce "either" either way
01:58:20 <hiptobecubic> frerich, If i were speaking, i'd say the latter. But it's not ambiguous either way.
01:58:23 <startling> maukd, Left and Right
01:58:26 <donri> "Installed already, X seems to be" -- yoda
01:58:37 <frerich> Thanks guys, I didn't want to drag the discussion to more off-topic grounds. ;-)
01:58:43 <quicksilver> "X? Installed? Seems to be. Already."
01:59:01 <hiptobecubic> Seems already installed, X does
01:59:17 <startling> maukd: alternatively: bimap, either
01:59:19 <quicksilver> frerich: I suggest you randomise the word order for each event.
01:59:20 <maukd> X is present at present
01:59:27 <maukd> rectify?
01:59:28 <startling> quicksilver: haha
01:59:39 <hiptobecubic> would almost work
01:59:44 <donri> > unwords . sort . words $ "X seems to be already installed"
01:59:47 <lambdabot>   "X already be installed seems to"
01:59:53 <maukd> what is this, latin poetry?
02:00:05 <startling> maukd, hic est.
02:00:16 <hiptobecubic> > unwords . shuffle . words $ "X seems to be already installed"
02:00:17 <lambdabot>   Not in scope: `shuffle'
02:00:24 <hiptobecubic> rats i thought we had shuffle
02:00:35 <donri> need moar IO?
02:00:35 <dmos> cabal file advice requested: if a dependency changes API (directory in GHC 7.6), should you conditionally match on directory itself or on impl GHC?
02:01:03 <hiptobecubic> donri, ah yes.
02:01:13 <akamaus> Hi, I've found a strange inconsistency. A documentation page http://hackage.haskell.org/packages/archive/time/1.4.0.1/doc/html/Data-Time-Clock.html says UTCTime has an Show instance, but :i UTCTime in ghci shows only  Eq and Ord instances. What's the reason?
02:01:27 <maukd> akamaus: import Data.Time and try again
02:01:32 <startling> aesthetic advice: I have ReaderT a (Writer e) b. should I do type Noisy a e b = ReaderT a (Writer e) b or type Noisy e a b = ReaderT a (Writer e) b ?
02:02:06 <hiptobecubic> ugh this again
02:02:49 <startling> hiptobecubic, hm?
02:03:32 <merijn> startling: Which ever reads nicer in your type signatures :)
02:03:44 <bitonic> is there some tutorial on dynamic programming in a purely functional setting?
02:03:52 <merijn> startling: You could also use RWST with () for StateT
02:03:53 <bitonic> I just hate filling in those tables :(
02:04:08 <startling> merijn, oh, true
02:04:32 <bitonic> for example the sudoku "wholemeal programming" style was really inspiring, I'd like more stuff like that
02:04:38 <akamaus> maukd, thanks!
02:04:53 <basdirks_> I have imported Control.Monad.State, and am trying to use State as a constructor, but compiler gives "StackState.hs|12 col 7 error| Not in scope: data constructor `State'", I am using the examples from LYAH. Something I am doing wrong?
02:04:56 <maukd> akamaus: did that change things?
02:05:11 <maukd> basdirks_: no, the library changed
02:05:15 <akamaus> maukd, yes. All the instances are in place now
02:05:17 <maukd> basdirks_: there's now a 'state' function
02:05:29 <basdirks_> okay, thanks
02:05:34 <maukd> akamaus: ok. that's because haddock sometimes shows instances from random other modules without telling you
02:05:59 <akamaus> maukd, by the way, how I was supposed to find the proper module to input myself?
02:06:41 <maukd> akamaus: luck
02:06:49 <startling> heh
02:07:01 <dmos> dcoutts: I have a patched version of tar working on 7.6 (change is fairly trivial). Interested?
02:07:22 <akamaus> dmos, I'm interested, if you're talking about gtk2hs ;)
02:07:42 <dmos> akamaus: different ballgame ;)
02:07:50 <startling> merijn: RWST was good advice; some intermediate steps might need State.
02:07:55 <hiptobecubic> startling, netsplits
02:08:04 <startling> hiptobecubic: oh fun
02:08:23 <donri> does RWST really make much sense in mtl, isn't it mostly useful in transformers?
02:09:25 <startling> what's the way to run a ReaderT?
02:09:39 <donri> runReaderT? :p
02:10:04 <startling> oh right, of course
02:10:07 <akamaus> dmos, :( Desperately want to build that beast
02:11:01 <dmos> akamaus: I built it yesterday on 7.4.2 which was already an story in and of itself. Not sure I really want to go there with 7.6 right now.
02:12:33 <akamaus> dmos,  I  built it on 7.4 with cabal multiple times. Didn't encounter any problems
02:13:14 <dmos> akamaus: me neither, but my machine was wheezing after finishing.
02:14:23 <akamaus> dmos, how is that?
02:15:22 <dmos> akamaus: fairly old hardware. MacBook 2,1, and it was building inside a VirtualBox/Arch install. Not exactly a recipe for speed.
02:16:33 <merijn> donri: Well, the shorter name makes it easier to parse the type IMO
02:16:33 <dmos> Ah, sorry, MacBook 3,1. Not that it makes much of a different in terms of being out of date.
02:17:10 <sithisbitch> how do you know the version of your macbook ?
02:17:52 <akamaus> dmos, well, cpu time is the cheapest thing ;) Just leave it alone
02:18:55 <dmos> sithisbitch: Launch Profile, main page, first line (by hand: apple icon -> about this mac -> more info)
02:19:20 <sithisbitch> dmos, you need MacOS for that ? because i only have 'buntu on my mac
02:20:08 <dmos> akamaus: true, but it also means that I have to actually plan at what opportune moment I'm compiling stuff like gtk2hs.
02:20:17 <osfameron> stick the serial number on https://selfsolve.apple.com/GetWarranty.do
02:20:34 <Ralith> you can also read the ROM from linux with the right tool
02:20:54 <sithisbitch> OK thx
02:20:59 <sithisbitch> i'll see that this evening
02:21:21 <t7> hmm someone should write a dialect of C with parametric poly morphism. You could compile out all the dictionary passing so it would be really easy to integrate with existing c stuff
02:21:31 <t7> polymorphism*
02:21:36 <maukd> t7: templates?
02:21:36 <dmos> sithisbitch: yeah, that was the MacOS version of finding it out, osfameron already pointed to the hardware way of figuring it out.
02:21:50 <maukd> t7: also, what dictionaries?
02:21:51 <startling> can I have a typeclass synonym somehow that says "X has A and B constraints"? I want a reader-writer class.
02:22:13 <t7> maukd: parametric polymorphism,  e.g. type classes
02:23:06 <startling> @hoogle (a, b, c) -> c
02:23:06 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
02:23:06 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
02:23:43 <maukd> t7: type classes aren't parametric polymorphism
02:24:06 <maukd> first you have to get the parametric polymorphism working, then you can worry about adding typeclasses
02:24:23 <t7> i have both owkring
02:24:34 <t7> but thats not the point
02:24:50 <t7> ah crap you are right
02:25:04 <t7> i thought parametric included type classes
02:25:30 <t7> 'Bounded parametric polymorphism'
02:26:35 <dmos> Anyone knows whether cabal-dev is now obsolete with 7.6 (and what version of cabal-install are we talking)?
02:33:47 <startling> Darn, a nested writer with different types doesn't just magically work with "tell"
02:34:14 <startling> stupid type inferer isn't good enough for my special snowflake needs
02:34:40 <shachaf> Don't use nested writers. :-(
02:35:08 <shachaf> @unmtl WriterT a (WriterT b m a)
02:35:08 <lambdabot> Plugin `unmtl' failed with: `WriterT a (m (a, b))' is not applied to enough arguments, giving `/\A. m (a, b) (A, a)'
02:35:22 <startling> @unmtl WriterT e (Writer f)
02:35:22 <lambdabot> Plugin `unmtl' failed with: `WriterT e (Writer f)' is not applied to enough arguments, giving `/\A. (A, e, f)'
02:35:28 <shachaf> @unmtl WriterT a (WriterT b m) a
02:35:28 <lambdabot> m (a, a, b)
02:35:37 <shachaf> Hah, silly lambdabot.
02:36:07 <startling> lift . tell works, though
02:36:08 <startling> hmmm
02:44:12 <kallisti> startling: it's not really the type inference that's preventing tell from working with 2 writers.
02:44:25 <kallisti> there's a functional dependecy that makes the common case inferrable
02:44:52 <startling> kallisti, oh. hm
02:45:03 * startling doesn't know anything about FunDeps
02:45:33 <kallisti> weren't you just going to use a tuple as the writer type?
02:45:41 <startling> yeah, I'm going with that
02:45:49 <startling> just thought this might be an interesting avenue
02:46:21 <kallisti> I believe using tell with multiple writers would be possible with some tweaks to the typeclasses, but you would also have to write more explicit type annotations.
02:46:32 <startling> can I have a shorthand somehow for (MonadReader m, MonadWriter m) => ... ?
02:46:54 <startling> kallisti: sure, makes sense. lift . tell would be fine, too
02:48:29 <kallisti> startling: with ConstraintKinds you can create constraint aliases.
02:48:56 <startling> oh, interesting
02:49:10 <kallisti> type ReaderWriter w r m = (MonadReader r m, MonadWriter w m)
02:49:31 <startling> can I define that in a module with ConstraintKinds on and use it in a module without?
02:49:48 <kallisti> startling: without using ConstraintKinds, you can also create a dummy typeclass with those classes as superclasses, and then define instances for the types you want.
02:49:56 <kallisti> startling: believe so
02:50:30 <startling> very interesting
02:51:27 <kallisti> class (MonadWriter w m, MonadReader r m) => MonadReaderWriter w r m
02:51:43 <kallisti> instance MonadReaderWriter X Y Z
02:52:16 <kallisti> I guess MonadWriterReader would be a better name, given the order of the parameters.
02:52:57 <startling> hehe
02:53:41 <kallisti> the problem with that approach is that MonadReaderWriter requires explicit instance declarations, whereas the type alias + ConstraintKinds is a true alias.
02:53:46 <startling> yeah
02:54:33 <shachaf> Just decide what the monad you actually want is, what operations it actually needs, and write code for that.
02:54:48 <startling> yeah, that's what I'm doing
02:55:36 <shachaf> So don't use the classes MonadReader and MonadWriter.
02:55:44 <shachaf> Those are just implementation details. :-)
02:58:13 <kallisti> I would say they're generalizations more so than implementation details.
03:06:16 <quicksilver> they're a way to get polymorphism
03:06:28 <quicksilver> so you could write code over *any* monad with the right Reader + Writer behaviur
03:06:38 <quicksilver> but there is no point doing that for the sake of it
03:14:23 <statusfa1led> Does Network.URI not have a way of getting the "base" only of a url? e.g. the "google.com" part of "http://google.com/?foo=bar&qux=quz"
03:15:51 <Lemmih_> statusfa1led: fmap uriRegName . uriAuthority
03:16:19 <Lemmih_> Or just 'authority'.
03:19:32 <kstt> hello. Sorry for this uninteresting question, but does anyone know how to catch exception with http-conduit ? They happen in the ResourceT monad transformer, that is run with the runResourceT action. I'd like to catch them (and react to them) from inside this ResourceT block, since catching them from outside the runResourceT would be really too coarse.
03:19:47 <hvr> ...what was the URL for the hackage-2.0 test-install again?
03:20:10 <kstt> btw, this whole ResourceT stuff feels horribly hacky ...
03:20:53 <statusfailed> Lemmih: seems odd that uriAuthority returns a Maybe?
03:21:16 <statusfailed> I'm not sure what Authority is though :D
03:21:28 <newbie_> > 2 +2
03:21:29 <lambdabot>   4
03:21:59 <hvr> kstt: just guessing: maybe that's wat ExceptionT (also defined in resourcet) is for?
03:22:19 <Lemmih> statusfailed: "/path" is a valid URI as well.
03:22:46 <statusfailed> oh, it is? ok :)
03:22:54 <statusfailed> maybe I should just use Network.URL then
03:23:15 <statusfailed> but I guess you can have relative ones...
03:25:57 <hvr> kstt: also, ResourceT is an instance of MonadTransControl whose purpose is afaik to be able to do things like catch exceptions
03:26:21 <kstt> ah, I'll have a look at this typeclass then, thank you hvr
03:26:38 <statusfailed> Lemmih: Cheers for your help btw
03:28:26 <hvr> kstt: http://www.yesodweb.com/book/monad-control seems relevant
03:28:48 <kstt> hvr, this chapter got me lost
03:28:59 <kstt> but I'll give a try again
03:29:10 <kstt> that's just incredibly convoluted
03:29:32 <hvr> kstt: tell snoyberg, he's usually interested in knowing what's not clear in his documentation
03:29:41 <hvr> or in this case, his book
03:30:50 <kstt> well, to be clear, I am far from being a wizard, but I have happily and successfuly done haskell projects for a couple of years now. For my last project, I decided to use conduit, and that has been horribly painful so far ...
03:31:18 <kstt> unfortunalty, there isn't many http client library available
03:31:44 <kstt> so I can't escape this land easily :)
03:32:19 <hvr> do you need specific conduit features from http-conduit?
03:33:31 <kstt> not really, beside catching exceptions
03:33:40 <hvr> in some cases, when I just need a simple http client, I can usually get away with avoiding using the ResourceT monad, and just wrap single calls in runResourceT
03:33:49 <fosskers> hey guys
03:34:33 <hvr> and thus be in the IO monad most of the time, w/o having to infect everything with the ResourceT monad
03:34:35 <kstt> hvr: this isn't a good option here. Reusing connections is important in my pattern (lots of small requests).
03:35:02 <hvr> isn't that essentially handled by the http-conduit Manager?
03:35:11 <kstt> true !
03:35:16 <hvr> i.e. just pass around the Manager, which serves as a connection-pool manager
03:35:16 <fosskers> I have a question that has an answer I know I've seen before.
03:35:28 <kstt> I could probably rework the code so that less code gets infected !
03:35:34 <kstt> I'll give that a try, thanks !
03:35:56 <fosskers> How does one map a value from one list to every value of the other? Is that Monoids?
03:35:57 <hvr> the resource-t monad (as far as I understood it) is interesting, if you have "streaming" invovled
03:36:17 <kstt> and I do, but I can probably isolate it better
03:36:23 <hvr> where the http-transaction last longer
03:37:06 <kstt> fosskers: like [(a,b) | a <- list1, b <- list2] ?
03:37:27 <fosskers> kstt: no, like:
03:37:40 <fosskers> [1,2,3] and [4,5,6]
03:37:54 <hvr> kstt: but better check the API yourself, I haven't investigated too well into the matter yet (I've still got plenty of code still using the http-enumerator package)
03:37:59 <fosskers> I want the list [5,6,7,6,7,8,7,8,9]
03:38:15 <kstt> hvr ok, anyway thank you for your light !
03:38:21 <fosskers> I know there's a very simple way to do this, it just escapes me at the moment.
03:38:36 <fosskers> And not fiddling manually with maps and concats.
03:38:44 <ion> > [0..] >>= \n -> [n..n+2]
03:38:45 <lambdabot>   [0,1,2,1,2,3,2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11...
03:39:08 <kstt> fosskers: like [a + b | a <- list1, b <- list2] ?
03:39:11 <fosskers> Also in the example above, I'd be mapping with (+) obviously
03:39:42 <kstt> > [a + b | a <- [1,2,3], b <- [4,5,6]]
03:39:43 <fosskers> > [a + b | a <- [1,2,3], b <- [4,5,6]
03:39:43 <lambdabot>   [5,6,7,6,7,8,7,8,9]
03:39:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:40:17 <fosskers> I suppose you could do it with list comprehensions then, yeah.
03:40:25 <fosskers> I thought there was a more... sexy way.
03:40:42 <fosskers> I recall <*> and perhaps <?>
03:40:48 <kstt> fosskers: if you don't want, it is also the default "bind" implementation for the list monad
03:41:24 <kstt> and yeah, certainly also the <*>
03:41:25 <frerich> > (+)  [1,2,3] <*> [4,5,6]
03:41:26 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
03:41:32 <frerich> drat this IRC client
03:41:41 <frerich> Why does it keep eating lower-than-dollar-greater-than...
03:41:55 <kstt> frerich: do you feed it enough ?
03:42:04 * hackagebot twentefp 0.4 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-0.4 (ChristiaanBaaij)
03:42:06 * hackagebot wai-handler-launch 1.3.1.1 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.3.1.1 (MichaelSnoyman)
03:42:08 * hackagebot warp 1.3.1.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.1.2 (MichaelSnoyman)
03:42:35 <frerich> > (+) `fmap` [1,2,3] <*> [4,5,6]
03:42:37 <lambdabot>   [5,6,7,6,7,8,7,8,9]
03:42:44 <fosskers> Aha!
03:42:52 <frerich> fosskers: There - except that you can use the '<' '$' '>' operator instead of fmap
03:43:01 <frerich> My IRC client won't let me send it for some obscure reason
03:43:02 <ion> '<' '$' '>'?
03:43:05 <fosskers> Right, that's what I remember
03:43:07 <ion> ಠ_ಠ
03:43:17 <kstt> > (+) <$> [1,2,3] <*> [4,5,6]
03:43:17 <fosskers> ion: he had to do that or IRC would puke
03:43:18 <lambdabot>   [5,6,7,6,7,8,7,8,9]
03:43:22 <fosskers> ...or not
03:43:32 <fosskers> Question: Is this monoids?
03:43:38 <fosskers> or Applicative functors...?
03:43:53 <Botje> <$> and <*> is applicative functors
03:44:00 <Botje> mappend and mempty are monoids
03:44:08 <Botje> (or (++) in Caleskell)
03:44:12 <kstt> however fosskers, if you don't deeply understand <$> <*> or >>=, I'd recommand you to use list comprehensions, which are much more explicit and expressive in this case.
03:44:22 <fosskers> I understand Monads fine
03:44:27 <fosskers> >>= and me are good buddies
03:45:39 <kstt> then you can also use  [1,2,3] >>= \a -> [4,5,6] >>= \b -> return $ a + b
03:45:48 <fosskers> > lines "This is my\nawesome string\nAnd I hope this works" >>= words
03:45:49 <lambdabot>   ["This","is","my","awesome","string","And","I","hope","this","works"]
03:46:34 <fosskers> kstt: Oh, hot damn. You're right
03:47:04 * hackagebot twentefp 0.4.1 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-0.4.1 (ChristiaanBaaij)
03:47:29 <fosskers> Albeit the applicitive functor solution looks better
03:47:49 <kstt> but all these definitions are really arbitraty. Don't get this wrong, they are valid implementations, but other valid implementations exist. In my opinion, reading "(+) <$> [1,2,3] <*> [4,5,6]" and knowing the laws for applicative functors *is not enought* to know the result, because implementation is one of many possible.
03:48:21 <kstt> on the other hand, the list complrehension is fully explicit, you do know the output from just reading the expression
03:49:31 <frerich>  and <a> but not <$ plus >
03:49:39 <frerich> sorry, wrong paste.
03:50:23 <fosskers> Actually that's true... it does seem pretty arbitrary what that does.
03:50:23 <fosskers> In that case, which is the most consistant?
03:50:23 <fosskers> as in "This is clear and does what is predictable."
03:50:39 <astry_> > (+) <$> [1,2,3] <*> [4,5,6]
03:50:40 <lambdabot>   [5,6,7,6,7,8,7,8,9]
03:51:44 <fosskers> I'll try them all out.
03:51:54 <fosskers> Obviously I'm doing this on more than just lists of Ints with (+)
03:52:08 <astry_> > (+) <$> [1,2,3] <*> [4,5,6] <*> [100,10000,1000000]
03:52:09 <lambdabot>   [5,5,5,6,6,6,7,7,7,6,6,6,7,7,7,8,8,8,7,7,7,8,8,8,9,9,9]
03:52:18 <fosskers> ...
03:52:37 <fosskers> ah, because (+) only takes two arguments?
03:52:45 <kstt> fosskers: don't hesitate to use your own ghci for this kind of experimentations :)
03:52:50 <fosskers> i was
03:52:54 <astry_> 10 20
03:52:57 <astry_> > 10 20
03:52:57 <fosskers> and things were exploding, lol
03:52:58 <lambdabot>   10
03:53:08 <fosskers> i live in ghci dude
03:53:19 <fosskers> rather, the ghci inside emacs
03:54:18 <kallisti> sounds like an inhospitable land
03:56:08 <fosskers> No it's quite a nice place to be
04:02:49 <frerich> Hm, why does '10 20' typecheck with lambdabot?
04:03:29 <merijn> frerich: Because Num a is an instance of ((->) a) in lambdabot
04:08:25 <mux> there's a way to have pattern guards in case of constructs, right? I can never seem to remember the syntax
04:09:08 <merijn> mux: I dunno, but I have a cheat sheet for these questions
04:09:14 <merijn> Lemme check if it's online somewhere already
04:09:23 <mux> never mind
04:09:28 <mux> I was using = instead of ->
04:10:12 <das_bomben> haskell!!! oh me oh my it sounds nice
04:10:19 <das_bomben> whats so nice abuot haskell anyhow?
04:11:26 <fosskers> The universe is written in Haskell.
04:11:28 <Botje> why don't you learn it and find out? you can start with learn you a haskell
04:11:31 <merijn> If anyone else wants it: http://fau5tln.home.xs4all.nl/Haskell%20Cheat%20Sheet.pdf
04:11:43 <merijn> (Gratuitously stolen from someone else, but I forgot who)
04:11:49 <sipa> @where lyah
04:11:49 <lambdabot> http://www.learnyouahaskell.com/
04:12:04 <fosskers> Uncertainty principle of particle physics? That shit's lazy evaluation.
04:12:32 <certainty> merijn: nice .. I guess it was Justin Baily (unless that is you)
04:12:51 <merijn> No, that isn't me :p
04:16:38 <fosskers> thanks guys, I got it figured out.
04:17:27 <das_bomben> oow!
04:17:28 <das_bomben> ok
04:20:58 <kuribas> Is it bad to use unsafePerformIO to do memoizing?  (Since it should preserve referential transparency).
04:22:45 <bitonic> kuribas: you can do it.  but you could simply use ST>
04:23:58 <kuribas> ST Monad?
04:24:23 <bitonic> yes
04:24:45 <Saizan> kuribas: http://augustss.blogspot.it/2011/04/ugly-memoization-heres-problem-that-i.html <- you might be interested in this opinion
04:25:08 <Saizan> (start by the Moral at the end maybe)
04:25:15 <clsmith> hmm, is external ghc core fully lambda-lifted / supercombinatory?
04:27:56 <kstt> hvr: thank you again for your simple advice, I isolated runResourceT and life is better now :)
04:28:17 <kstt> I suspect I should have used runResourceT that way from the very begining
04:29:07 <hiptobecubic> Whoever designed ghc's debugger obviously hates humans.
04:34:58 <das_bomben> i thought with types no gub
04:35:01 <das_bomben> er bug
04:35:35 <hpaste> “Stephen Blackheath” pasted “Fails on 7.6.1, works on 7.4.2 - is this a bug?” at http://hpaste.org/75301
04:38:24 <byorgey> it's not a bug, it's a feature
04:38:45 <byorgey> "The behavior of the TypeOperator extension has changed: previously, only type operators starting with ":" were considered type constructors, and other operators were treated as type variables. Now type operators are always constructors. "
04:39:15 <byorgey> blackh: ^^^
04:40:03 <blackh> byorgey: Thanks - now all I have to do is to figure out what that means for me in practice.
04:40:36 <hiptobecubic> if i have a function and list of args, is there a way to apply the function to the args directly or do i need to pattern match myself to extract them
04:41:56 <byorgey> hiptobecubic: you need to pattern match.  A bit of reflection will show that there is no possible type that could be given to an operator that applies a function to a list of arguments (at least not in Haskell's type system).
04:42:05 <blackh> byorgey: I am thoroughly confused. Why can't I name my type (constructor) variable as (~>) ?
04:42:35 <maukd> blackh: because operators aren't variables anymore
04:43:00 <hiptobecubic> byorgey, yeah...  ok
04:43:11 <blackh> maukd: OK. So does that mean I can't have any sort of infix type variable name?
04:43:17 <maukd> blackh: yes
04:43:41 <maukd> hiptobecubic: it's possible if you have the arguments in nested tuples (hi, HList)
04:44:15 <hiptobecubic> maukd, oh.. perhaps. But then it's not worth the extra effort really
04:44:18 <byorgey> blackh: for background, see http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/21350
04:44:28 <byorgey> that thread also contains some interesting workarounds
04:44:32 <byorgey> towards the end
04:45:13 <blackh> byorgey, maukd: Well that will render 850 lines of type signatures even less readable.
04:45:24 <byorgey> blackh: I know =(
04:46:08 <blackh> byorgey, maukd: Thanks for being the bearers of bad news. :)
04:46:47 <byorgey> blackh: see http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22615 for a nice (IMO) workaround
04:47:21 <zomg> I'm trying to find out why this is causing a segfault: https://github.com/snoyberg/http-conduit/blob/master/Network/HTTP/Conduit/Manager.hs#L386
04:47:24 <byorgey> relatively speaking, at least
04:47:52 <zomg> I tried adding a trace call in the go function, however for some reason it's segfaulting even before the trace outputs anything
04:48:14 <zomg> Any advice?
04:50:21 <blackh> byorgey: Thanks! That should help a lot.
04:51:28 <merijn> hiptobecubic: Does it have to be list, or just any data structure you can create yourself?
04:52:30 <blackh> zomg: Assuming this is OpenSSL-based, make sure you call the thing that initializes the library globally, because it definitely crashes if you don't do that.
04:54:31 <hiptobecubic> merijn, i'm just being lazy.
04:55:00 <hiptobecubic> merijn, it could be anything but I'm just working with Debug.Trace and trying to take hideous shortcuts
04:55:54 <merijn> hiptobecubic: I dunno if you checked the link I send you of my code, which does exactly that. Call functions of arbitrary (but known at compile time) argument from a pattern that provides input
04:56:17 <merijn> hiptobecubic: Actually, you could hijack that to work on lists too, but you'd crash if you have insufficient arguments :p
04:56:17 <zomg> blackh: hmm. This worked in 7.0.3 but segfaults on 7.4.1 on Ubuntu 12.04... any ideas?
04:56:47 <zomg> blackh: Not sure if anything between those would've changed enough to cause that
04:57:49 <hiptobecubic> merijn, actually i missed you link. paste it again?
04:57:52 <hiptobecubic> your*
05:00:22 <nand`> acid-state has built in machinery for dealing with versioned data structures and seamless updating
05:00:27 <nand`> are there any similar approaches for versioned protocols?
05:01:09 <merijn> hiptobecubic: https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs
05:01:16 <hpc> other databases?
05:01:21 <merijn> hiptobecubic: Check out the apply function + BoxFun type family
05:01:33 <merijn> hiptobecubic: (And definition of Pattern in Pattern.hs)
05:01:49 <hiptobecubic> sure
05:01:51 <hiptobecubic> thanks
05:04:03 <merijn> Anyone happen to know what diffusion trees are? Saw a mention in a paper and Google lists lots of papers mentioning them, but no description...
05:05:41 <pchiusano> does anyone know if it was Parsec that discovered the approach of having all parsers commit if they consume any characters, and using attempt to allow backtracking?
05:05:52 <pchiusano> or did that idea originate somewhere else?
05:06:19 <pchiusano> i feel like that design was a serious breakthrough in being able to generate good, predictable error messages
05:06:47 <ivanm> merijn: I have an arxiv result which defines Pitman-Yor diffusion trees as my third hit
05:07:42 <ivanm> pchiusano: I don't think that that is specifically why parsec has good error messages
05:07:47 <Jello_Raptor> merijn: no clue but a quick google gives http://arxiv.org/pdf/1106.2494v2.pdf and http://people.ee.duke.edu/~lcarin/Neal2.pdf
05:07:48 <ivanm> I think it's more the extra metadata it keeps around
05:08:05 <ivanm> (in terms of line number, etc.)
05:08:53 <pchiusano> ivanm: I think it is a precondition of good error reporting that there is a very predictable model for when backtracking occurs
05:09:03 <quicksilver> it does help with error messages, ivanm
05:09:09 <pchiusano> of course tracking line numbers, etc is important too, though
05:09:19 <quicksilver> otherwise you get the case where what you really wanted was the 'first choice' but it backtracked
05:09:28 <quicksilver> and you only get the error message with the 'nth' possibility
05:09:39 <quicksilver> (the last one it tried when there was nothing left to do)
05:09:52 <ivanm> hmmmmm
05:09:55 <ivanm> I see your point
05:09:56 <quicksilver> but this is more about grammar design than parser library design
05:10:15 <ivanm> in that there should be only one real option?
05:12:53 <quicksilver> well just that re-using grammer fragments makes it harder to get good errors.
05:13:12 <quicksilver> similarly, re-using grammar fragments makes more 'mistakes' into successful parses
05:13:43 <pchiusano> quicksilver: though with good code factoring, I think even those problems can be ameliorated
05:21:38 <ceasar> Can someone help me out with a newbie question? I am trying to write "cat Nil ys = ys" expecting Nil to be defined (since a List = Nil | Cons a b?) but it doesn't work. When I tested if 'Just' works though it does.
05:22:08 <ceasar> Is the definition of List not imported by default? And if not, how can I import it? (importing Data.List didn't seem to help)
05:23:06 <hiptobecubic> @src []
05:23:06 <lambdabot> data [] a = [] | a : [a]
05:23:15 <hiptobecubic> ceasar, that's how list is actually defined.
05:23:26 <ceasar> Oh-- Cons and Nils are just examples then?
05:23:31 <hiptobecubic> ceasar, if you want to define your own list-like type you can
05:23:41 <Puffton> Sometimes I get the result -0.0 in Haskell, is there any reason for this?
05:23:46 <Puffton> I mean, as opposed to 0.0
05:23:55 <ceasar> @hiptobecubic Got it. Thanks!
05:23:55 <lambdabot> Unknown command, try @list
05:23:59 <ion> You’re using floating point numbers, that’s how they behave.
05:24:11 <Puffton> So it's "zero", but basically a very small negative number?
05:24:29 <hiptobecubic> Data MyList a = Nil | Cons a MyList    i guess?
05:24:32 <ion> > negate 0.0
05:24:33 <lambdabot>   -0.0
05:25:15 <ion> IEEE-something floats have a bit for the sign, a zero can be negative in that representation/
05:25:28 <hiptobecubic> > data MyList a = Nil | Cons a (MyList a)    -- i guess?
05:25:30 <lambdabot>   <no location info>: parse error on input `data'
05:27:07 * hackagebot network-metrics 0.2.5 - Send metrics to Ganglia, Graphite, and statsd.  http://hackage.haskell.org/package/network-metrics-0.2.5 (BrendanHay)
05:28:30 <basdirks_> how do I makeLenses for multiple types at once? (data.lens)
05:28:46 <ion> Do you mean Control.Lens?
05:28:56 <basdirks_> yes sorry
05:29:39 <nomeata> Hi. Just a small survey: How many of you remember having had to use "map X", where X is a newtype constructor, to convert a whole list of the original type to the newtyped (or the other way around)?
05:30:01 <hiptobecubic> nomeata, i did that an hour ago
05:30:11 <nomeata> (Say you have "newtype X = X { unX :: Int}", and use map X or map unX)
05:30:31 <nomeata> hiptobecubic: Nice. How expensive do you think this call is?
05:30:46 <ion> basdirks: Multiple makeLenses lines, i suppose.
05:30:49 <hiptobecubic> free? Doesn't the compiler handle it?
05:31:09 <hiptobecubic> i guess newtype isn't quite free
05:31:11 <hiptobecubic> almost though
05:31:31 <basdirks_> ion yeah thought so
05:31:37 <Botje> nomeata: one popular usecase is mconcat . map First
05:31:42 <ion> A newtype is free, but i suppose map can make a copy of the spine in runtime in the worst case scenario.
05:31:45 <Botje> or any Monoid, really
05:31:49 <basdirks_> but I saw a different approach for fclabels
05:31:53 <nomeata> What do other expect? Please say what you think, not necessariy what you know for sure; I want to find out what peple expect.
05:31:56 <ion> foldMap == mconcat .: map
05:32:10 <basdirks_> where you could do makeLenses [''lulz, ''cake]
05:32:23 <nomeata> Botje: hopefully mconcat is set up for fusion, so that no extra list is created there.
05:32:47 <Botje> @src mconcat
05:32:47 <lambdabot> Source not found. My mind is going. I can feel it.
05:32:50 <Botje> huh
05:33:08 <Botje> mconcat = foldr mappend mempty
05:33:11 <nomeata> file:///usr/share/doc/ghc-doc/html/libraries/base-4.5.0.0/src/Data-Monoid.html. It is defined in terms of foldr, so that is ok.
05:33:12 <Botje> and foldr . map fuses
05:33:15 <nomeata> (assuming it inlines)
05:33:26 <nomeata> but what about a single "map First"?
05:34:38 <nomeata> What is the predominant believe here – zero cost, or the cost of traversing the list and creating new (:) cells?
05:35:11 <Botje> depends how/if GHC can fuse it away, really
05:37:08 <maukd> new spine by default
05:37:21 <maukd> you could supply a rewrite rule, I guess
05:37:26 <maukd> or just unsafeCoerce it
05:38:56 <quicksilver> fusion means no "intermediate" lists, FWIW
05:39:02 <quicksilver> you still have the initial list and the final result
05:39:28 <quicksilver> so xs = blah; ys = map foo xs; is still two lists however clever fusion is.
05:39:45 <quicksilver> (unless 'blah' is a generator expression not a literal list and nothing else in the program uses xs)
05:43:11 <nomeata> Hmm, ok, looks like it is not as bad as I though. For a long time I belived that the compiler would just replace "map X" by “appropriately typed” id. Maybe eventually GHC will be able to do it, but it is not clear how to get there: http://hackage.haskell.org/trac/ghc/ticket/2110
05:44:42 <quicksilver> @remember Igloo The major problem, as far as I can see, is how to construct the mumble'.
05:44:42 <lambdabot> Done.
05:46:59 <whald> I have a rather large data set which I'm trying to sort into a hash table. to handle collisions, I used a list in each hash cell, prepending new elements to the list
05:48:07 <whald> is there a better structure than a list for this kind of thing? I feel like it should be possible to do this with better locality, e.g. using a vector which doubles size whenever it's full
05:48:37 <whald> i've already implemented the latter, but the performance is very very bad compared to lists
05:48:49 <quicksilver> if you're just prepending and linear searching, the lists are precisely right aren't they?
05:49:04 <Botje> whald: have you tried Data.Sequence?
05:49:06 <quicksilver> they are a structure designed for fast append and reasonable linear access.
05:49:16 <quicksilver> data.sequence is slower than list
05:49:23 <quicksilver> (if all you are doing is prepend and linear access)
05:49:30 <quicksilver> if you're doing other things it is, of course, much faster.
05:49:34 <kallisti> whald: are you familiar with quadratic probing?
05:49:41 <quicksilver> also colliion lists are typically short?
05:49:55 <quicksilver> if you average length is (1) and your typical length is never more than 2 or 3
05:50:01 <quicksilver> then lists are, again, the fastest structure.
05:50:05 <whald> quicksilver, the final step is to create a kdtree from the list, and the kdtree construction works inplace on an mutable array
05:50:26 <quicksilver> that doesnt' mean that it's fastest to build up mutable arrays though :)
05:50:43 <whald> and with lists I'll have to convert them to that mutable _vector_ finally, so I thought I can exploit this.
05:51:57 <hiptobecubic> Debug.Trace is my new favorite tow
05:52:00 <hiptobecubic> toy*
05:53:35 <whald> kallisti, i can't exploit quadratic probing, because my (spatial) hash can't separate the elements well enough because of their size / overlap. that's why I'm using the kdtree inside the hash cells
05:54:37 <whald> quicksilver, my collission lists can easily have > 100 elements
05:56:21 <whald> I have hacked my personal "GrowVec" data type, which I've already used for good performance gains in other places, but this time it completely blows up. and I don't really see why. :-( the code is here: https://github.com/waldheinz/bling/blob/master/src/Graphics/Bling/Utils.hs
05:57:34 <t7> map sin [0.0,0.1,1.01]
05:57:38 <t7> > map sin [0.0,0.1,1.01]
05:57:39 <lambdabot>   [0.0,9.983341664682815e-2,0.8468318446180152]
05:57:58 <t7> wut
05:58:09 <whald> and I'm using it in the mkHash function in https://github.com/waldheinz/bling/blob/master/src/Graphics/Bling/Renderer/SPPM.hs
05:58:15 <t7> > map sin [0.0,0.1 .. 1.01]
05:58:16 <lambdabot>   [0.0,9.983341664682815e-2,0.19866933079506122,0.2955202066613396,0.38941834...
05:59:00 <Philonous> How could it come about that a constant in the C-code of a compiled library evaluates to -1 when compiled to native code (as it should) but becomes -907777 when I run the client code in ghci?
05:59:13 <Philonous> when the client program is compiled, that is
05:59:29 <sipa> :t fix error
05:59:30 <lambdabot> [Char]
05:59:38 <sipa> :t error
05:59:39 <lambdabot> forall a. [Char] -> a
06:06:27 <Quantumplation> if I have something that's just empty Datums like data Resource = A | B | C deriving (Ord, Eq), does it provide a default and distinct ordering?
06:06:44 <quicksilver> if you derive (which you did)
06:06:46 <quicksilver> then yes.
06:06:49 <benmachine> A < B < C
06:06:58 <Quantumplation> because when using it in a multiset, i'm getting sometimes inconsistent results
06:07:00 <quicksilver> that's what deriving (Ord) does
06:08:17 <basdirks_> what do others use in vim for coding Haskell? I already have syntastic and HLint integration etc, but are there other interesting plugins to aid development?
06:09:51 <benmachine> I don't use any plugins because I am a troglodyte
06:10:21 <frerich> basdirks_: I once created https://github.com/frerich/unicode-haskell for some Unicode exuberance, but that's just a cosmetic thing. Also, I was once shown a much more elegant way to achieve the same effect (but I forgot how it worked).
06:10:44 <basdirks_> try to remember ;}}}}
06:10:57 <frerich> There was some vim feature I wasn
06:11:12 <frerich> 't aware of which could be used to render certain characters one way but store them on disk in another.
06:12:01 <basdirks_> I've seen and used your plugin before actually
06:12:22 <basdirks_> and iirc extended it a bit, but there was some weirdness going on
06:12:50 <frerich> Sounds like something I wrote, yes.
06:12:54 <benmachine> :)
06:14:27 <basdirks_> no it had to do with some characters taking up 2 spaces etc
06:14:39 <basdirks_> I believe your map was safe
06:16:02 <frerich> Thanks. It's the most complicated vim script I ever wrote, heh.
06:30:09 <carpi> is there a way to check docs for System.Random? because the online docs don't have system.random
06:31:07 <whald> carpi, this one : http://hackage.haskell.org/package/random-1.0.1.1 ?
06:31:26 <carpi> whald: the one that comes with haskell platform
06:32:32 <Quantumplation> oh, derp, i'm a moron.  I was using fromDistinctAscOccurList and not putting them in order, no wonder I was getting inconsistent results XD
06:32:48 <whald> that's the one in the current haskell platform: http://lambda.haskell.org/platform/doc/current/index.html
06:33:10 <dunric> @djinn (a->b)->(b->c)->a->c
06:33:10 <lambdabot> f a b c = b (a c)
06:34:02 <byorgey> Quantumplation: hehe, that would do it =)
06:34:47 <carpi> whald: thanks. but the link on the homepage of the haskell.org site points to a set of docs that doesn't have the updated documentation for the standard libraries
06:36:03 <whald> carpi, I always dig the documentation on hackage.haskell.org, it's usually the latest and greatest anyway
06:36:51 <benmachine> carpi: where's the problematic link you're talking about?
06:37:53 <carpi> benmachine: http://www.haskell.org/ghc/docs/7.4-latest/html/libraries/frames.html
06:39:14 <benmachine> carpi: oh, those are the GHC docs, not the platform docs
06:39:34 <benmachine> carpi: hmm. yeah, I see what you're clicking on
06:39:53 <benmachine> I wonder why that's there
06:40:18 <carpi> benmachine: they're not the same? I mean .. when i download and install haskell don't i get the compiler, interactive repl and all its standard libraries?
06:40:29 <benmachine> (okay, wow, HaskellWiki has a Category:Haskell...)
06:40:50 <benmachine> carpi: GHC is just one component of the Haskell Platform
06:40:56 <benmachine> so if you look at its docs, not everything will be included
06:41:00 <geekosaur> carpi: you can download just ghc, which contains only the base/boot libraries, or you can download the Platform which has everything
06:41:02 <benmachine> the Haskell Platform has its own docs
06:41:10 <benmachine> http://lambda.haskell.org/platform/doc/current/start.html
06:41:25 <geekosaur> and the docs for ghc include only the bootlibs
06:41:36 <benmachine> carpi: the GHC libraries are just the libraries that GHC needs to work
06:41:48 <benmachine> (aiui)
06:42:15 <carpi> oh . . and the haskell platform includes ghc and the other "standard libraries"?
06:42:19 <geekosaur> yes
06:43:10 <geekosaur> ghc is big enought hat everything they can unbundle, they are unbundling to get the size and complexity down; which is why the platform exists
06:44:18 <carpi> so next time i can just install the haskel platform. all this time i was installing ghc and the platform seperately. what a waste (
06:44:43 <benmachine> (personally, I don't use the platform, I just install the stuff I want when I want it)
06:44:47 <benmachine> (but the platform's cool too)
06:45:10 <Quantumplation> newtype A = A b; is there a convenient inline way to extract the b? I keep having to use where-clauses to pattern match and bind it into a different variable
06:45:34 <whald> could someone please have a look at some profiling output I don't understand?
06:45:37 <benmachine> Quantumplation: let and case are both capable of doing that
06:46:04 <benmachine> Quantumplation: but another common option is to define it as newtype A = A { getB :: B } and then getB :: A -> B
06:46:20 <hpaste> whald pasted “Where's the time?” at http://hpaste.org/75304
06:46:53 <Quantumplation> ah didn't know I could do that ^.^
06:46:53 <hpaste> whald pasted “The code for "where's the time?"” at http://hpaste.org/75305
06:48:21 <whald> the profiling says that lots of time is spent in mkTrees, but I think everything expensive inside mkTrees already has it's own SCC, as can be seen on line 29.. of the log, so what's possibly going on there?
06:48:49 <Quantumplation> benmachine: is there any way to "lift" a function of B's onto a function of A's?
06:49:29 <benmachine> Quantumplation: not a fully automated one
06:49:33 <merijn> Quantumplation: f . getB? :p
06:49:34 <benmachine> Quantumplation: it depends a little
06:49:55 <benmachine> Quantumplation: there is a way to automatically lift type class instances that B has so that A has them
06:50:04 <quicksilver> there is "ala"
06:50:18 <quicksilver> http://hackage.haskell.org/packages/archive/newtype/0.1/doc/html/Control-Newtype.html
06:50:23 <benmachine> yes, there's that too
06:50:29 <benmachine> and isomorphism lenses
06:50:31 <quicksilver> however if you find you're doing this loads and loads and loads
06:50:37 <quicksilver> then possibly you may be doing something wrong :)
06:50:50 <scooty-puff> what is the best way to detect if a language extension is available in a module (which is part of a cabal project)?
06:51:08 <benmachine> scooty-puff: huh? who is doing the detecting and for what purpose?
06:51:08 <scooty-puff> i have seen ghc version checking, but was hoping there was a better way
06:51:22 <scooty-puff> i want to check if DefaultSignatures is an available extension
06:51:27 <scooty-puff> (as well as ConstraintKinds)
06:51:50 <byorgey> scooty-puff: I've never heard of any way to check for extensions explicitly.
06:51:54 <benmachine> ghc --supported-languages?
06:52:18 <scooty-puff> ooo
06:52:33 <scooty-puff> that could work
06:55:51 <whald> ghc supports a stunning number of languages, I always thought it was only haskell
06:56:14 <benmachine> :P it is
06:56:32 <benmachine> well, two different versions of Haskell
06:56:38 <carpi> Not in scope: data constructor `IO'. how may I rectify the problem? I tried import System.IO
06:56:47 <k00mi> carpi: use return
06:56:49 <benmachine> (pedantically three, but they're all quite similar)
06:57:00 <benmachine> carpi: IO is a type, not a value
06:57:00 <carpi> although it works in the interactive repl without any specific importing
06:57:18 <benmachine> carpi: what are you typing to cause that problem?
06:57:59 <ski> carpi : you are trying to use `IO' in an expression, so it assumes you are trying to use a *data* constructor named `IO' (there isn't one in the interface of the standard libs)
06:58:06 <hpaste> carpi pasted “IO” at http://hpaste.org/75307
06:58:33 <maukd> carpi: yeah, that code makes no sense
06:58:37 <benmachine> carpi: does that really work in the repl?
06:58:46 <ski> carpi : `IO True' in `tabu (Io Bool) (t,f) = ...' doesn't make sense
06:58:57 <carpi> i mean the line "randomIO :: IO Bool" works
06:59:02 <benmachine> oh
06:59:03 <benmachine> yes
06:59:05 <benmachine> it would
06:59:05 <maukd> that line works here as well
06:59:08 <ski> carpi : you can only pattern-match on *data* constructors -- and there's no data constructor exported for the type `IO Bool'
06:59:24 <edwardk> re makeLenses: mapM makeLenses [''Foo,''Bar,''Baz]
06:59:33 <ski> carpi : maybe you really meant to define `tabu :: IO Bool -> (Int, Int) -> IO (Int, Int)' ?
06:59:35 <quicksilver> carpi: randomIO :: IO Bool is fine
06:59:44 <edwardk> gives you the same effect as the fclabels approach and isn't appreciably noisier
06:59:57 <quicksilver> carpi: it's tabu (IO True) that isn't.
07:00:37 <edwardk> er i guess join <$> mapM makeLenses [''Foo,''Bar,''Baz]
07:00:39 <merijn> edwardk: I have a state lens I keep running into, I'll leave it up to you whether it's sensible (or in fact even a valid lens) to include it (hpaste in a sec)
07:00:42 <ski> carpi : `IO True' is not a valid expression, and it's not valid as a pattern either (simply because there's no data constructor `IO')
07:00:44 <carpi> then how may i extrack the value of the bool alone
07:01:06 <maukd> carpi: you don't
07:01:16 <quicksilver> there isn't a Bool inside "IO Bool"
07:01:16 <maukd> carpi: why do you think there's a bool in there you can extract?
07:01:17 <ski> carpi : more specifically, you can't pattern-match on something of type `IO Foo' with a pattern `IO x', expecting `x' to get the type `Foo'
07:01:32 <hpaste> merijn pasted “Monadic state lens” at http://hpaste.org/75308
07:01:55 <merijn> edwardk: Maybe there already is a better way of doing that, but if so I didn't find it
07:02:07 <Spockz> could someone help me with recursive bindings in Arrow notation? https://gist.github.com/1c2c0f7b08fb54e90879
07:02:14 <ski> carpi : think of a value of type `IO Bool' as a recipe -- now, given a recipe of a cake, you wouldn't find a cake somehow inside it
07:02:23 <carpi> so IO is a type constructor. Not a data constructor. So it has no business being in the section of code that does not deal with type annotation?
07:02:27 <byorgey> edwardk: how easy would it be to use lens to make a zipper on a "view" of an abstract data type?
07:02:34 <merijn> @quote ls.list
07:02:35 <lambdabot> No quotes match. :(
07:02:37 <edwardk> the problem is the intervening can move the target out of the way. so you can have an action that reads, say one element of a list, has the list modified inserting something and writes back to the wrong place
07:02:37 * ski . o O ( The recipe is not the cake )
07:02:43 <maukd> @quote ls.contain
07:02:43 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
07:03:02 <edwardk> byorgey: you can use the zipper code in lens on that very easily, just descend into the isomorphism
07:03:04 <ski> carpi : yes !
07:03:10 <byorgey> edwardk: cool =)
07:03:29 * byorgey is going to make some zipper lenses for editing paths in diagrams
07:03:31 <ski> carpi : also see the lambdabot quote maukd fetched
07:04:07 <ClaudiusMaximus> byorgey: that sounds cool!  like splicing paths together?
07:04:08 <edwardk> zipper (1 :+ 2) % down polarize % down _1 % focus .~ 10 % rezip
07:04:52 <edwardk> 4.472135954999578 :+ 8.94427190999916
07:04:53 <ski> carpi : "then how may i extrack the value of the bool alone" -- as maukd said "you don't" -- what you *can* do, is if you have instead `tabu :: IO Bool -> (Int, Int) -> IO (Int, Int)', then you can write something like
07:05:02 <byorgey> ClaudiusMaximus: I was thinking like generating a path and then applying an operation/transformation to the third vertex, or whatever
07:05:13 <byorgey> ClaudiusMaximus: what do you mean by "splicing paths together"?
07:05:14 <merijn> edwardk: Ok, I'll just stick with my own definition of it then :)
07:05:44 <edwardk> merijn: yeah that one falls into the realm of 'stuff i don't include because it has bad edge cases'
07:05:58 <ClaudiusMaximus> byorgey: like inserting a path between nodes of another path
07:06:07 <byorgey> ClaudiusMaximus: ahhh, I see
07:06:09 <ClaudiusMaximus> byorgey: or turning each path node into a little figure
07:06:20 <merijn> edwardk: Time to introduce Control.Lens.Unsafe :p
07:06:21 <byorgey> ClaudiusMaximus: sure, I think that should be possible!
07:06:31 <ski>   tabu ioBool (t,f) = do bool <- ioBool
07:06:33 <ski>                          if bool
07:06:48 <edwardk> you can simplify it to foo l f = do x <- use l; l <~ f x
07:06:51 <ski>                             then return (t+1,f  )
07:06:55 <byorgey> ClaudiusMaximus: e.g. we could make a view of paths as nested things, where each node can be either a segment OR a nested path
07:06:55 <ski>                             else return (t  ,f+1)
07:06:59 <dmos> What's the next step after 'Typesafe Observable Sharing' by Andy Gill to EDSL Enlightenment?
07:07:21 <byorgey> ClaudiusMaximus: then you make a zipper for that and you can wander around the structure splicing and editing to your heart's content =)
07:07:39 <ski> carpi : so, you can use `<-' in `do'-notation, to "extract" (really not extraction, but execution of the recipe) a `bool' from `ioBool'
07:07:41 <Quantumplation> I have a function, F :: a -> b -> (a, b), and a MultiSet of a's.  I need to fold over the a's (using the snd F as the input to the next one) and collect the fst F's into a list.  I also need access to the very LAST b returned by F.  I'm not sure how to construct this function.  So, [a1, a2, a3, a4] b1 should give F a1 b1 = (c1, d1), then run F a2, d1 = (c2, d2), etc.  I need to collect all the c's, and the last d.
07:07:51 <edwardk> you can also render it safe by zooming, that would empower the operator to work on traversals, at the expense of limiting the portion of the state it can seee
07:07:55 <Quantumplation> (Sorry if that's somewhat unclear ><)
07:08:16 <Botje> Quantumplation: sounds like mapAccumL maybe
07:08:18 <ski> carpi : but for this to work, the return type of `tabu' must be `IO (...)'
07:08:36 <merijn> edwardk: Oh, I think <~ is something I wanted anyway :)
07:08:45 <Quantumplation> Botje: That's what I was thinking, but there's no built in mapAccumL for Data.MultiSet's, so I have to write it myself
07:08:56 <ski> carpi : does this help at all ?
07:08:57 <byorgey> Quantumplation: sounds like you want something like mapAccumR, perhaps?
07:09:03 <byorgey> @type mapAccumR
07:09:04 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:09:09 <edwardk> merijn: =) its named because you can replace x <- foo   with x <~ foo when you want to assign to x a lens
07:10:01 <carpi> ski: thanks for the clarification. trying to edit the code accordingly.
07:10:17 <merijn> edwardk: Hoogle need to index your docs :p
07:10:26 <edwardk> merijn: heh
07:10:31 <edwardk> yell at the hoogle maintainer
07:10:43 <wilfredh> I'm trying to use readProcess but I'm getting a very strange error:
07:10:56 <wilfredh>  readProcess "ls" ["-a" "/"] [] --  The function `"-a"' is applied to one argument
07:11:01 <quicksilver> edwardk: although that's not without its cognitive dissonance cost
07:11:06 <Botje> wilfredh: you missed a comma after "-a"
07:11:07 <wilfredh> but "-a" isn't a function, what's up?
07:11:15 <quicksilver> edwardk: x <- foo is a binder and x <~ foo is not.
07:11:16 <ski> carpi : also, while the code you have for `infibool' is correct Haskell, i doubt that it does what you presumably wanted it to do. i suspect that you wanted to (somehow) get an infinite list of randomly chosen booleans (is that right ?)
07:11:16 <wilfredh> argh. Thanks :)
07:11:17 <edwardk> quicksilver: true, but its still convenient ;)
07:11:18 <ClaudiusMaximus> byorgey: want to do something like that with fractal text with graphics tablet, here's something painstakingly constructed with Gimp http://img213.imageshack.us/img213/8397/thequick.png
07:11:18 <rwbarton> you tried to apply "-a" to one argument ("/")
07:11:35 <carpi> ski: yes. thats what i was trying to do
07:11:36 <edwardk> i keep forgetting to add the <<~ variant that can chain
07:12:15 <maukd> :t randoms
07:12:16 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
07:12:16 <ski> carpi : what you have actually written will define an infinite list of `IO'-actions (all the elements is actually the same action, namely the one that, when executed, will randomly select a boolean)
07:12:34 <ski> carpi : so, what you've written gives `infibools :: [IO Bool]'
07:12:40 <ClaudiusMaximus> byorgey: would probably want to port some potrace-like vectorize simplification algorithms to avoid explosion of points
07:12:58 <ClaudiusMaximus> byorgey: but again, too many projects, not enough time....
07:13:04 <ski> carpi : now, maybe what you tried to get was `infibools :: [Bool]', but that's impossibly if you want randomness here (where does the randomness come from ?)
07:13:50 <carpi> ski: from a source or function that does not give the same output everytime for the same input
07:14:04 <carpi> ski: or rather from a non-pure function?
07:14:12 <ski> carpi : what would be closer to what you presumably intended is to define `infibools :: IO [Bool]' -- i.e. as a recipe that, when executed, will give an infinite list of (independently) randomly chosen booleans
07:14:43 <maukd> :t fmap randoms newStdGen
07:14:44 <lambdabot> forall a. (Random a) => IO [a]
07:15:07 <ski> carpi : there are no non-pure functions in Haskell -- every function gives the same return value, when you pass it equal arguments
07:15:26 <carpi> ski: putStrLn?
07:15:28 <whald> ehm, could it be that it's a problem if you have lots of STVars? say 100000 or more?
07:15:51 <carpi> ski: I mean getLine
07:15:57 <maukd> carpi: getLine is not a function
07:16:04 <maukd> getLine is a constant
07:16:06 <ski> carpi : `putStrLn' is a function that when called on a string will always return the same *recipe*, namely the recipe explaining how to print that string
07:16:34 <ski> carpi : `getLine' is the recipe that tells how to get a line (when executed)
07:16:35 <byorgey> ClaudiusMaximus: heh, tell me about it =)
07:16:54 <ski> carpi : the recipe is different from the result when you folow/execute it
07:17:01 <ski> s/folow/follow/
07:17:28 <Quantumplation> Anyone know why Data.MultiSet isn't a member of the Traversable typeclass?
07:17:51 <ski> carpi : so, `getLine' is pure, it's always the same value (namely a recipe)
07:17:54 <benmachine> Quantumplation: at a guess, because it isn't a Functor
07:18:08 <carpi> or rather the same recipe
07:18:41 <Quantumplation> Why's it not a Functor? :-S
07:18:45 <ski> carpi : now, if you create the larger recipe `do getLine; getLine' then this is of course a different recipe than `getLine', even though both components there are the same
07:19:08 <ski> carpi : this is not that differnent from `[2,2]' being a different list than `[2]'
07:19:57 <ski> carpi : you have to distinguish clearly between (a) *which* recipe you have (what it *is*); and (b) the *result* of executing that recipe (in a certain situation)
07:20:07 <rwbarton> Quantumplation: presumably you need at least an Eq constraint to construct a MultiSet
07:20:09 <Sculptor> hi!
07:20:09 <maukd> > do "[]"; [2]
07:20:10 <lambdabot>   [2,2]
07:20:12 <ski> executing the same recipe in a different situation can yield a different result
07:20:28 <rwbarton> using fmap (or indeed traverse) I could construct a MultiSet whose elements were e.g. functions
07:20:38 <Quantumplation> ah ok
07:21:13 <Quantumplation> that means i'll have to implement the mapAccumL function myself XD
07:21:14 <ski> carpi : that's why `do a <- randomIO :: IO Bool; b <- randomIO :: IO Bool; return a - b' is different from  `do b <- randomIO :: IO Bool; a <- randomIO :: IO Bool; return a - b'
07:21:48 <ski> carpi : "or rather the same recipe", yes, the value of `getLine' is the recipe
07:21:48 <rwbarton> @type mapAccumL
07:21:50 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:21:55 <ski> (it is *not* the string)
07:22:01 <maukd> ski: that's like 3 type errors
07:22:06 <rwbarton> Quantumplation: if you really need to produce a new MultiSet then yes
07:22:10 <ski> maukd : ty
07:22:45 <carpi> what i need is an haskell training center? is there one?
07:22:45 <Quantumplation> I don't lol.  It could end up as a list
07:22:46 <ski> carpi : apparently i managed to confuse that example -- (a) imagine i used `return (a - b)'; (b) imagine i used `IO Int', not `IO Bool'
07:22:51 <maukd> looks like you need Num (IO Bool), Bool ~ IO Bool
07:22:53 <ski> carpi : this channel ?
07:23:11 <ski> maukd :)
07:23:45 <carpi> ski: you can't use irc chatrooms to learn how to make music. Coding in haskell is like making music for the computer : ) Same thing.
07:24:03 <quicksilver> maukd: that's really an interesting direction.
07:24:08 <quicksilver> > do"  [";{-]  -};[  '^','_'  ];--
07:24:09 <lambdabot>   "^_^_^_"
07:24:16 <ski> well, yes, you need to tinker and think for yourself as well
07:24:16 <quicksilver> programming entirely in emoticons.
07:24:32 <quicksilver> > do"  [";{-]  -};[  '^','_'  ];-- >
07:24:33 <lambdabot>   "^_^_^_"
07:26:40 <ski> carpi : anyway, i suggest you attempt writing `infibool :: IO [Bool]'
07:27:02 <ski> you'll probably need `do' and `->' (or `>>=') and also `return'
07:28:35 <ski> carpi : you can try first to do it using `randomIO', but i suspect that you'll find `random' (e.g.) and `newStdGen' easier (to get it to work at all)
07:29:34 <maukd> spoilers: I already posted the solution
07:30:12 <carpi> thanks for the pointer. I shall look into it.. getting some compile errors. but its the type system thats not satisfied. trying to fix that
07:30:55 <merijn> edwardk: I guess with zoom it'd become something like "l <%%= f = zoom l (get >>= f >>= put)", which is at least more readable, I guess
07:31:52 <edwardk> you can probably make use of zoom l (id %~ f) or something like that
07:32:03 <edwardk> er zoom l (id %%~ f)
07:32:37 <edwardk> er maybe not
07:32:38 <Cale> <%%= -- is this a smoke monster, or a jellyfish?
07:32:47 <Clint> squid
07:32:57 <clsmith> i must say, these operators are getting pretty elaborate
07:33:26 <merijn> edwardk: %%~ wouldn't get the state out, would it?
07:33:51 <edwardk> thats why i backtracked and said 'maybe not' ;)
07:34:29 <edwardk> clsmith: <%%= isn't a lens operator =P
07:34:49 <merijn> To be fair <%= and it's based on that :p
07:34:57 <merijn> Cale: Still doesn't beat the sperm operator
07:35:01 <merijn> <>~
07:35:46 <edwardk> <%= is consistent though. % :: a -> (a -> b) -> b    is an infix operator %= is the application of it to the target of a lens. <%= also returns the result for chaining
07:36:30 <byorgey> %<<-~+
07:36:31 <blackh> merijn: I had a sperm and egg operator in an error message once. ghc annotated my ~> infix type constructor with the number 0, giving me ~>0
07:36:36 <merijn> I've seen % used before to indicate fmap in operators (which is maybe not consistent with the further lens naming)
07:37:15 <edwardk> the (%) operator was named retroactively to make that reasoning work out, admittedly ;)
07:37:21 <blackh> Cale: I just learnt all about how you can't have infix type constructors no more. Sob.
07:37:31 <edwardk> before it was just %=   for 'mod-equals'
07:37:48 <edwardk> blackh: did you see the work around i posted?
07:37:56 <edwardk> well, iavor posted and i cleaned up?
07:38:07 <blackh> edwardk: Yes - I did - I think I'm going to use that.
07:38:19 <edwardk> x -:c:> y   is pretty clean
07:39:05 <edwardk> i actually prefer it since i can give fixity to the -: and :> that make the needless parens go away
07:39:23 <Cale> blackh: yeah, it's pretty crazy
07:39:26 <edwardk> i was sad when i realized i couldn't use - as a type operator though
07:39:39 <Cale> blackh: There were some neat tricks to work around the problem
07:39:54 <Cale> blackh: But the amount of code that it breaks is massive
07:40:02 <edwardk> Cale: it makes sense when you think about it. they wanted (+), (*), etc. for type nats
07:40:10 <Cale> edwardk: well, yes
07:40:11 <blackh> Yeah - I saw those. I think that's the right thing to do. Yes - a lot of code, so I think it'd be worth writing a program to convert it
07:40:23 <ski> carpi : "but its the type system thats not satisfied. trying to fix that" -- yes, you will need to massage the code so that it looks somewhat different
07:40:30 <Cale> edwardk: It's just that we have something like 10k lines of code which is using ~> as an infix type variable everywhere
07:40:39 <edwardk> cale: sounds like a long day ;)
07:40:44 <blackh> I counted 850 type signatures
07:40:51 <edwardk> you can always search and replace for it with `k` or something
07:41:11 <edwardk> then replace (`k`) with k
07:41:26 <edwardk> that might automate it for the most part
07:41:37 <Cale> I'm thinking we'll end up doing one of those tricks with the --k--> or something
07:41:37 <blackh> Well, I'm a bit time-zone challenged at the moment, so I'll catch you guys later. Good night!
07:41:38 <byorgey> I think this demonstrates that the current process (proposing changes to the libraries@ list) is not scaling well.
07:41:50 <byorgey> because people who care about such changes aren't finding out about them until it's too late.
07:42:09 * hackagebot network-metrics 0.2.6 - Send metrics to Ganglia, Graphite, and statsd.  http://hackage.haskell.org/package/network-metrics-0.2.6 (BrendanHay)
07:42:14 <blackh> Cale: edwardk suggested -:c:-> which looks fairly nice
07:42:15 <mike-burns> I was just browsing through my Web server and found this: http://mike-burns.com/project/all%20your%20haskell/
07:42:23 <edwardk> well, i for one changed all my code to be compliant 6 months ago ;)
07:42:33 <int-e> byorgey: yeah and the rc period for ghc is a bit too short
07:42:50 <Cale> edwardk: reminds me of the start of Hitchhiker's Guide :D
07:42:56 <edwardk> cale: =)
07:42:57 <byorgey> edwardk: sure, you're active on the libraries@ list.
07:43:01 <int-e> (although that would've been very late to back out of such change ...)
07:43:08 <byorgey> Cale: hehe, indeed =)
07:43:49 <edwardk> i think i only had to change about 4k lines though, so you guys have it rough ;)
07:44:36 <edwardk> i had someone put in a proposal to add infix aliases for simple lenses, simple traversals, etc. Should I add :-> as an alias for Simple Lens?
07:44:48 <edwardk> and i suppose :=> for SImple Traversal?
07:44:51 <int-e> hmm. =-c->
07:45:16 <edwardk> there is also >-c->  or :-c:>
07:45:21 <zomg> I'm assuming this is bad: Stack space overflow: current size 8388608 bytes.
07:45:28 <edwardk> the latter has the benefit of being compatible with code before 7.6
07:45:54 <Cale> zomg: that's generally a bug in your program, yeah
07:46:06 <Cale> zomg: (or occasionally one of the libraries you're using)
07:46:16 <zomg> Yeah looks like it might be a bug in Network.TLS.Extra..
07:47:15 <int-e> we can have fish, too. ><c>>
07:47:41 <Cale> edwardk: The changes to Typeable will also probably break things a bit, but it might also make things easier for us, so I don't know :)
07:48:01 <edwardk> well, the Typeable changes didn't go in in 7.6.1 did they?
07:48:16 <edwardk> they were punted to 7.8
07:48:21 <Cale> Well, we're likely to be on 7.8 by the time we start things up again
07:48:25 <edwardk> ah
07:48:30 <edwardk> yeah.
07:49:06 <Philonous> How is it possible that a constant in C code is garbled when that code is loaded as a library in ghci?
07:49:10 <edwardk> int-e: you can use <c> if you don't care about the visual asymmetry ;)
07:49:24 <zomg> Cale: btw could a stack overflow be causing a segfault?
07:49:30 <Cale> zomg: no
07:49:37 <zomg> Hmm
07:49:40 <Cale> zomg: well, at least, not in any way that I can think of
07:49:44 <edwardk> Philonous: ghci uses a custom linker that loads the .o file by hand and sometimes does derpy things
07:49:52 <zomg> I was looking into a segfault issue and tracked it down to a function in Network.TLS.Extra
07:50:04 <edwardk> Philonous: i've been chasing after a similar bug with copumpkin for a long time
07:50:08 <zomg> However, if I take it out of the main app and into a smaller test case app, it only causes the stack overflow and not a segfault
07:50:12 <copumpkin> BOOYAH
07:51:01 <Cale> zomg: Segfaults usually either happen in C code which is being linked in, or because something is using unsafeCoerce (or rarely, unsafePerformIO in a really unsafe way, given that you can write unsafeCoerce with it)
07:51:13 <Cale> zomg: anything else, and it's a bug in GHC
07:51:31 <Philonous> edwardk:  So there is a chance I'ts actually not me being stupid? Is there a workaround?
07:51:36 <RichyB> or Foreign.Storable, Foreign.Ptr
07:51:42 <Cale> right, right :)
07:51:44 <RichyB> but those are just ways of writing C directly in Haskell.
07:52:12 <RichyB> Cale: https://github.com/RichardBarrell/snippets/blob/master/RC4.hs ← malloc ftw :)
07:52:24 <Cale> I love the Haskell malloc
07:52:27 <edwardk> Philonous: we haven't fixed ours yet. let me know if you fix yours ;)
07:53:01 <Cale> zomg: In order to understand stack overflows, it's important to realise that there is no call stack
07:53:33 <Cale> zomg: The stack which is overflowing is a stack of pattern matches who are waiting for their scrutinee to be sufficiently evaluated to match
07:53:43 <zomg> Cale: yeah I'm just trying to figure out why the damn thing is segfaulting since it pretty much stops me from doing any work :P
07:53:59 <Cale> zomg: This also includes things like (+) which internally pattern matches on the constructor(s) of Integer/Int/Float/etc.
07:54:23 <Cale> Is the code which overflows small?
07:55:04 <Philonous> edwardk:  Is your's on a public tracker so I can compare / see potential updates?
07:55:42 <edwardk> Philonous: https://github.com/ekmett/rounded/issues?state=open is the tracker for rounded, but we didn't put in an issue for it yet
07:55:52 <ion> In order to understand recursion, it’s important to understand recursion.
07:55:58 <Philonous> Thanks
07:56:08 <edwardk> https://github.com/ekmett/rounded/issues?state=open
07:56:13 <edwardk> er
07:56:14 <edwardk> https://github.com/ekmett/rounded/issues/10
07:56:21 <edwardk> i've added an issue now =)
07:56:26 <edwardk> not much to see there yet ;)
07:56:38 <zomg> Cale: yeah it's just a few lines now that I managed to track it down (and a cert file which I dumped off google which is the one causing it)
07:56:55 <Cale> Put it on hpaste or something, and I'll see if I can spot the overflow
07:57:17 <zomg> Well this is the actual function for it https://github.com/vincenthz/hs-tls-extra/blob/master/Network/TLS/Extra/Certificate.hs#L101
07:57:29 <zomg> Didn't yet look into that one
07:57:48 <zomg> However, as far as I can tell, it seems this is the cause for the segfault
07:58:06 <zomg> I replaced the call which calls this one with just a value which it would probably output, and it no longer segfaults
07:58:44 <Cale> huh...
07:59:28 <Philonous> edwardk:  I guess I'll just copy over the values of the constants and hope that's the last of it
08:00:09 <zomg> This one ends up calling certificateVerifyChain, replacing the call to mCheckCerts with CertificateUsageAccept fixes the segfault https://github.com/snoyberg/http-conduit/blob/master/Network/HTTP/Conduit/Manager.hs#L410
08:01:23 <Cale> zomg: ah, and that's a field extractor for Manager
08:01:37 <Cale> zomg: so, you need to know which thing is creating the Manager you're using
08:01:44 <zomg> Yeah defaultCheckCerts is the one
08:01:55 <zomg> https://github.com/snoyberg/http-conduit/blob/master/Network/HTTP/Conduit/Manager.hs#L84
08:02:42 <zomg> http://jjh.fi/~jani/segfault3.txt this is a test app I wrote, which causes the stack overflow from certificateVerifyChain
08:02:50 <zomg> using the same cert as the segfaulting code
08:03:01 <zomg> http://jjh.fi/~jani/cert1 <- this is the cert file needed to run the test application
08:03:07 <Cale> oh, that's higher up
08:05:40 <Cale> zomg: So it's either in certSubjectDN, certIssuerDN, or certificateVerifyChain_ because everything else in certificateVerifyChain looks safe
08:06:00 <Cale> (Those first two look like field extractors, but I don't know
08:06:01 <Cale> )
08:06:03 <zomg> Yeah
08:06:07 <zomg> Looking into it now
08:06:37 <Cale> SysCert.findCertificate -- maybe this?
08:07:03 <zomg> http://jjh.fi/~jani/segfault2.txt <- this one causes the segfault
08:07:15 <zomg> Not sure if it will do that on other platforms than Ubuntu 12.04 however
08:07:23 <Cale> lol, wtf
08:08:42 <Cale> I'll install http-conduit and try it
08:08:47 <zomg> Thanks
08:10:12 <zomg> I had one Ubuntu 12.04 user verify they are getting the segfault as well so it seems it's not an issue with my system at least
08:10:31 <JJme> Hi there
08:11:59 <sopvop> can cabal do such thing: either depend on  base <4.5 and something < 1.2.3, or base <5 and something 2.3.4?
08:12:15 <dcoutts_> yes
08:12:23 <ceii> sopvop: yes, see flags
08:12:36 <Cale> zomg: That doesn't crash for me on Ubuntu 11.04
08:12:45 <zomg> Cale: yeah it was ok for me on 10.04 too
08:12:47 <sopvop> which flags? I can't figure out from docs.
08:13:04 <ceii> sopvop, no, I mean the "flag" directive in cabal files
08:13:06 <zomg> Cale: I tried this with the ghc package on 12.04, source compiled 7.4.1 and source compiled 7.4.2
08:13:09 <Cale> zomg: So my guess is that it's a bug in some system C library.
08:13:46 <zomg> hmm
08:13:54 <zomg> at least we're getting somewhere with this now =)
08:14:24 <Cale> Yeah, I'm on 7.4.1 here
08:14:31 <Cale> (binary from GHC website)
08:14:52 <Cale> also, 32 bit
08:14:53 <sopvop> celi: flags require user input, but can this be done automatically? Like if you can't satisfy this, then try that.
08:14:57 <zomg> Yeah 32 bit for me as well
08:15:00 <ceii> sopvop: see the example here
08:15:07 <ceii> oops, sorry
08:15:10 <ceii> missed your answer
08:15:20 <zomg> Cale: any ideas on finding which library is the cause?
08:15:33 <ceii> cabal-install will try flag combinations until it finds one that works
08:16:06 <ceii> see the part called "Resolution of conditions and flags"
08:16:12 <zomg> I'm guessing ldd would give some indication on what deps it has but I'm not really that familiar with those
08:16:16 <ceii> in the configuration part of the Cabal user's guide
08:16:19 <ceii> http://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
08:16:26 <fmap> zomg: do you have strace log?
08:16:32 <zomg> I can grab one, sec
08:16:51 <sopvop> Oh, thanks celi
08:17:04 <fmap> and ltrace can be useful too
08:17:13 <Cale> zomg: yeah, there's very little which this program actually depends on, but fmap has the right idea, I think.
08:17:20 <zomg> fmap: http://jjh.fi/~jani/segtrace.txt
08:18:20 <zomg> grabbing ltrace...
08:18:41 <zomg> Ltrace: http://jjh.fi/~jani/segltrace.txt
08:19:29 <zomg> last call gmpz_add... would this indicate it's an issue with gmp?
08:19:34 <Cale> ohoho
08:19:42 <Cale> Lots of calls into GMP
08:19:51 <zomg> I'd imagine the cert checking funcs would use those
08:20:19 <rwbarton> are you linking against a library that uses GMP
08:20:26 <rwbarton> I got a segfault recently in that situation
08:20:30 <rwbarton> but not quite like this
08:20:44 <zomg> rwbarton: I'd imagine Network.TLS.Extra or such may use those, and using ldd indicates libgmp.so.10 => /usr/lib/i386-linux-gnu/libgmp.so.10 (0xb76ae000)
08:21:00 <rwbarton> linking against a library that had GMP statically linked in but it was a different version => calamity
08:21:06 <Cale> zomg: I know that in newer Debian-based distributions, they replaced the GMP 3 which GHC expects with something newer.
08:21:21 <Cale> zomg: So maybe there's an incompatibility with the new version of GMP?
08:21:51 <zomg> Hmm
08:21:53 <Clint> triggered only by one cert?
08:22:02 <ceii> I'm pretty sure GHC doesn't expect gmp3 anymore
08:22:03 <zomg> libgmp-dev, Version: 2:5.0.2+dfsg-2ubuntu1, Replaces: libgmp10-dev, libgmp3-dev
08:22:38 <Cale> lol, wtf...
08:22:48 <Clint> does ghc not have a profiling switch to show the stack overflow details?
08:22:50 <tsou> ceii: anymore = ?
08:23:29 <zomg> I think I could try installing libgmp3-dev
08:23:34 <das_bomben> I have a low profile personally.
08:23:51 <das_bomben> When people learn too much about me they get pitch forks and want to start burning me
08:24:02 <zomg> Actually, it seems to say it's already installed although libgmp-dev supposedly replaces it
08:24:04 <monochrom> wrong channel?
08:24:17 <zomg> libgmp3-dev Version: 2:5.0.2+dfsg-2ubuntu1
08:24:18 <Cale> I just had this program segfault inside of ltrace a couple times, but it never seems to crash when run on its own, and will often successfully ltrace all the way through as well.
08:24:25 <rwbarton> zomg: is that "libgmp.so.10 => /usr/lib/i386-linux-gnu/libgmp.so.10" just because all ghc executables use libgmp though?
08:24:43 <zomg> rwbarton: No idea :)
08:25:01 <Cale> rwbarton: well, it would be in any case :)
08:25:06 <Cale> rwbarton: (because they all do)
08:25:10 <rwbarton> Cale: oh I also had that happen once I solved my other gmp problem :) program ran fine without ltrace but segfaulted with ltrace
08:25:41 <rwbarton> (was trying to use ltrace to see how much execution time was happening in the library)
08:26:25 <rwbarton> zomg: can you paste the full ldd output? (or did you already)
08:26:34 <zomg> rwbarton: sure, just a sec
08:26:39 <luite> does anyone here have a working installation of haste?
08:27:04 <zomg> rwbarton: here you go http://jjh.fi/~jani/segldd.txt
08:27:09 <till_t> luite: yes i have
08:27:10 * hackagebot monad-ox 0.1.0 - Monad for observation extraction  http://hackage.haskell.org/package/monad-ox-0.1.0 (JakubWaszczuk)
08:27:25 <rwbarton> that looks very standard and boring
08:28:00 <zomg> luite: btw this is regarding the segfaulting issue I had... I tracked it down to Network.TLS.Extra certificateVerifyChains, which is causing a stack overflow but as far as I can tell, that is the cause for the segfault in the conduit code
08:28:06 <luite> till_t: hm ok, i cannot install it anymore, have rebooted a lot of times, built from source etc, but doesn't work. can you compile something for me and send back the result?
08:29:18 <till_t> what do you mean by 'doesnt work"?
08:29:32 <luite> /Users/luite/.haste/lib/Main.jsmod: openBinaryFile: does not exist (No such file or directory)
08:29:46 <rwbarton> it looks like the segfault isn't actually in gmp, right? or it would say <unfinished>
08:30:06 <rwbarton> zomg: can you run the executable under gdb and get a C stack backtrace?
08:30:13 <luite> till_t: perhaps I just need that file
08:30:33 <zomg> rwbarton: yeah but it's like two lines
08:30:39 <rwbarton> oh
08:30:44 <tommy28> ciiiii
08:30:48 <zomg> #0  0x08518fe0 in s1Jv_info ()  #1  0x00000000 in ?? ()
08:30:48 <tommy28> ao
08:31:01 <rwbarton> lovely
08:31:33 <bartavelle> is there a way to have dynamically loaded stuff in my compiled (with ghc) haskell program ?
08:31:41 <bartavelle> I'd like to add a plugin system
08:32:01 <luite> till_t: oh bah found the problem.... the file i was trying to compile had module name Fibs, if I change that to Main, it works
08:32:02 <zomg> This is my first time trying to figure out a segfault issue so I've mostly just been trying to find out the point in code where it does that, don't really know much else to do =)
08:32:13 <SjorsvdHeijden> So I'm kinda new to haskell, and I've got a (probably) very basic problem
08:32:45 <SjorsvdHeijden> How do I go storing a readFile IO String in an actual String?
08:33:28 <bartavelle> SjorsvdHeijden, something like  'string <- readFile "myfile"' if you are in a "do" block
08:33:33 <byorgey> SjorsvdHeijden: an (IO String) is not a String.  It is an action which, when run, may have some I/O effects and will produce a String.
08:33:53 <byorgey> SjorsvdHeijden: but you can chain it with other I/O actions using the value of the String that is produced.
08:33:56 <monochrom> readFile "myfile" >>= \x -> ... here x "stores" the string. equivalently to what bartavelle says
08:33:57 <SjorsvdHeijden> Oh, right
08:34:04 <byorgey> fundamentally this is done with the (>>=) operator
08:34:06 <SjorsvdHeijden> I think I should use return instead of print ;)
08:34:27 <byorgey> and the do-notation provides syntactic sugar for this, like what bartavelle said above
08:34:37 <till_t> luite: i'm glad u foud the prob
08:34:43 <SjorsvdHeijden> Ah, yes
08:34:44 <SjorsvdHeijden> Thanks :)
08:34:57 <till_t> luite: i had a similiar one in the past
08:35:26 * Clint hmms at http://hackage.haskell.org/trac/ghc/ticket/3693
08:36:08 <luite> till_t: i'm just trying to compile some benchmarks against fay and ghcjs :)
08:36:54 <till_t> sounds interesting
08:37:02 <till_t> will you publish teh results?
08:37:11 * hackagebot lens 3.0 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.0 (EdwardKmett)
08:37:27 <edwardk> now with zippers
08:38:23 <thoughtpolice> edwardk: i was playing with the zipperyiness, it's pretty cool
08:38:39 <edwardk> thoughtpolice: its probably my favorite feature now =)
08:38:41 <bartavelle> loading haskell code at runtime seems horribly complicated
08:38:41 <till_t> luite: if i remember correctly, fay doesnt support typeclasses. is that correct? if yes, then i'm not sure on how useful it is
08:38:51 <edwardk> i need some more complex zipper examples
08:39:30 <SjorsvdHeijden> Heh, obviously I'm doing something wrong
08:39:43 <SjorsvdHeijden> storeString path = do str <- readFile path
08:39:43 <SjorsvdHeijden>                       return str
08:39:58 <maukd> SjorsvdHeijden: storeString = readFile  -- simplified
08:40:28 <edwardk> thoughtpolice: i need to transcode the video from boston haskell to youtube. i have an almost 2 hour lens talk that i gave there recorded
08:40:58 <thoughtpolice> edwardk: nice, i'd like to see some more advanced stuff with them. i have yet to fully jump on the lens train
08:41:07 <SjorsvdHeijden> maukd: what does that do?
08:41:27 <SjorsvdHeijden> Oh nvm, I see
08:41:33 <Eduard_Munteanu> SjorsvdHeijden: same thing your version does :)
08:41:53 <monochrom> your problem is elsewhere
08:42:43 <edwardk> i'm hoping to have support for parameterized 'makeClassy' in 3.1, and it may incorporate a version of mgsloan's lenq dsl.
08:42:55 <SjorsvdHeijden> Basically, what I want is to make a readFile-like function that instead of printing what it reads, returns it as a string
08:43:07 <SjorsvdHeijden> So that my other functions can work with it.
08:43:16 <monochrom> readFile doesn't print
08:43:17 <edwardk> so you can say things like $(composite [e| \(x,y,z) -> (x,y) |])  and it'll build a lens for you
08:43:36 <harrison> can i call a dll compiled in Intercal on windows 95? My boss won't upgrade our development servers.
08:43:37 <maukd> SjorsvdHeijden: that would be readFile
08:44:20 <SjorsvdHeijden> Maybe, but the output is of the type IO String, and not String, which is kind of the essence of my problem :P
08:44:25 <Eduard_Munteanu> Heh, harrison
08:44:45 <maukd> SjorsvdHeijden: that's not a problem
08:45:00 <harrison> Eduard_Munteanu: yes, heh
08:46:18 <monochrom> consider do{ x <- readFile "myfile"; return (length x) }. figure out what it means, what you can change to do your deed, etc
08:46:53 <monochrom> equivalently readFile "myfile" >>= \x -> return (length x)
08:47:29 <SjorsvdHeijden> k, will work on that
08:47:41 <monochrom> other people will tell you a million simplifications of either expression for the sake of information overload
08:48:33 <maukd> but that's the most simple form
08:48:54 <maukd> liftM wraps >>=, not the other way around
08:50:32 <SjorsvdHeijden> Then what will be the difference between a String and an IO String?
08:50:47 <maukd> a String is a string
08:50:48 <edwardk> hrmm, is it not possible to implement lookAhead using the combinators exposed in attoparsec?
08:50:51 <Eduard_Munteanu> x :: String in the above.
08:51:00 <maukd> an IO String is a recipe for generating a string
08:51:02 <djahandarie> A String is an actual string. An IO String is a recipe to get a string.
08:51:09 <djahandarie> lol
08:51:49 <monochrom> @quote ls
08:51:49 <lambdabot> qwe1234 says: 'static' and 'dynamic' are disjoint sets. no matter if you're talking about typing or anything else.
08:52:00 <Cale> @quote list.of.files
08:52:00 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:52:08 <monochrom> yeah, that one
08:52:26 <SjorsvdHeijden> k :)
08:55:51 <SjorsvdHeijden> Well then, one last question.. If IO String contains a string, how can I obtain it for use of other functions? (lines and/or words come to mind)
08:56:32 <monochrom> no, it says IO String does not contain a string. it says so sarcastically. look at "/bin/ls contains a list of files". clearly /bin/ls doesn't
08:57:10 <SjorsvdHeijden> Ah... I find it hard to detect sarcasm when I'm kind of new to the subject
08:57:29 <maukd> ... you've never used ls before?
08:57:55 <SjorsvdHeijden> Not that I know of
08:58:07 <Eduard_Munteanu> SjorsvdHeijden: you use (>>=) to pass the result of that IO action to other IO actions.
08:58:34 <Eduard_Munteanu> readFile "foo" >>= \contents -> putStr contents
08:59:45 <monochrom> I have already suggested my example do{ x <- readFile "myfile"; return (length x) } and if you find out what it does or means, that will be progress
08:59:54 <Eduard_Munteanu> There, readFile "foo" :: IO String, contents :: String
09:00:12 <monochrom> if you feel like it, you can replace "return" by "print", and do the exercise again
09:00:41 <monochrom> if you also feel like it, you can replace "length" by "lines" and do the exercise again. etc etc
09:03:31 <luite> till_t: sorry away, yeah fay does not have typeclasses, they might be added later. it also doesn't do a CPS transformation, so compiled programs might blow the javascript stack (even when they'd run in constant stack space natively)
09:03:57 <luite> till_t: but fay is probably the easiest to use at the moment, and most lightweight
09:04:36 <luite> till_t: anyway ghcjs should win obviously ;p
09:06:31 <luite> till_t: there's a large difference between the javascript engines: simple fib n = fib(n-1) + fib(n-2) benchmark for fib 35: v8: ghcjs 1.2s, haste 11s, fay 5.5s (non-cps), uhc-js: 7 minutes. ionmonkey: ghcjs: 1.0s, haste: 14s, fay: 25s, uhc-js: not tested
09:08:54 <till_t> luite: that's interesting. i should give ghcjs a try then
09:08:56 <luite> till_t: on ionmonkey, ghcjs runs at about 10% of native ghc speed
09:09:24 <luite> till_t: don't yet ;p this is with a new ghcjs code generator that i've been working on. the current one is slower than haste
09:10:39 <till_t> luite: so when is it ready to get tested by the public?
09:10:52 <moobull69> Good day everyone. i am trying to connect to an irc with lambdabot and am getting: Plugin `irc' failed with: user error (Serial.readM: no parse). http://pastie.org/4798177  can anyone offer me some advice on how to resolve this error?
09:11:02 <luite> till_t: i'm not sure how long it will take to implement all the missing functionality, could be a few months before it can replace the old one
09:11:13 <luite> the new one doesn't have threading, exceptions, arrays yet
09:12:10 <Saizan> luite: what maeks uhc-js so bad?
09:12:43 <Cale> moobull69: Well, that means that whatever it applied readM to, it wasn't able to parse it. Do you have the @seen plugin active by any chance?
09:12:57 <luite> Saizan: no strictness analysis. ghc compiles does a worker/wrapper transformation on the fibs thing, where the inner loop works on unboxed ints, using only the stack
09:13:03 <till_t> luite: a rough estimation would be helpful. like 1month 2months 3months?
09:13:32 <Cale> moobull69: Have a look at State/seen and check that it's nonempty.
09:14:39 <Cale> moobull69: Lambdabot seems to have this habit of blanking the file under certain conditions, and it has no idea about how to reinitialise it, so the only thing for it is to copy over a backup. I just ended up disabling the seen plugin altogether.
09:14:40 <till_t> Saizan: uhcjs is also a bit hard to work with because it doesn't come with all the libs from ghc, like Data.{Map,Set}
09:15:02 <Cale> moobull69: That's the only time I've seen parse failures from lambdabot, so if it's not that, I don't know.
09:15:05 <luite> till_t: hard to say, one month definitely not, really depends on how many problems the more tricky bits have
09:15:27 <luite> so far, the new genrator uses its own garbage collector
09:15:47 <till_t> good to know
09:16:10 <luite> but some of the more difficult parts, collecting global thunks, CAFs, have not been implemented yet
09:16:17 <moobull69> I will try that cale, but can you point me to where the plugins are and how to enable or disable them by chance?
09:16:28 <luite> (now none of the other hs->js compilers do that correctly as far as i know)
09:17:08 <Cale> moobull69: Modules.hs -- you can just remove or comment out the import and the entry in the list below.
09:17:22 <Saizan> hah, nested GCs
09:17:42 <nand`> Who collects the garbage collector's garbage?
09:17:48 <moobull69> location of Modules.hs
09:18:04 <nand`> answer: another garbage collector. it's garbage collectors all the way down
09:18:08 <luite> Saizan: yeah i'm still not 100% sure about that... fortunately some bits can be left out, no pinned arrays for example
09:18:09 <moobull69> sweet ill give it a try ty cale :)
09:18:10 <Cale> moobull69: It's in the root of the source code, you should see it
09:18:49 <luite> Saizan: but i still don't know a good other way to collect cafs, and the typical haskell heap has a huge amount of very small objects
09:19:24 <luite> Saizan: if you stored them all in very small javascript arrays, you'd have a memory overhead of ~200% on code that does lots of list processing or similar data structures
09:20:17 <luite> v8 seems to optimize the gc loops nicely, ionmonkey spends a bit more time there
09:21:04 <Saizan> js's arrays are that beefy?
09:21:20 <Saizan> though i guess it doesn't take much to 2x the memory used by a cons cell
09:21:24 <luite> in #v8 some dev told me that it has around 6 word overhead
09:21:31 <luite> 48 bytes on 64 bit systems
09:21:45 <luite> a cons cell itself is 3 words
09:21:54 <Saizan> heh
09:22:00 <luite> (pointer to the cons constructor, head and tail)
09:23:36 <JJme> I'm playing with subLayout but want no to have tabs. I don't success in using subLayout directly, is it, at least, the good way ?
09:25:09 <JJme> I just don't want the addTabs
09:25:26 <luite> Saizan: since information about the cons constructor (size of object, locations of pointers in the object) can be stored in the constructor object, it can actually be stored in 3 words (3 array indices) in javascript
09:27:27 <Saizan> luite: i see, i guess there's not much one can do, unless js implementers decide to provide a more direct access to memory
09:28:22 <moobull69> looks like it worked
09:31:47 <luite> Saizan: also the haskell gc can be a bit more clever, since it knows that most objects never point to newer heap objects. only indirections do (when a thunk has been evaluated it's overwritten by an indirection that points to the value), so doing a generational gc only requires a list of indirections from the old gen to the new gen
09:32:01 <luite> on the other hand it doesn't have access to fast memory copying stuff
09:51:20 <hpaste> mog pasted “explanation on IO monad and Either functor needed” at http://hpaste.org/75313
09:52:13 * hackagebot xdg-userdirs 0.1.0.0 - Basic implementation of XDG user directories specification  http://hackage.haskell.org/package/xdg-userdirs-0.1.0.0 (IlyaPortnov)
09:52:58 <mog_> I've been trying to make a simple map of a function work in the IO monad and the either functor but I can't get it right, help appreciated (link to the paste above)
09:55:11 <bartavelle> anybody knows of a nice scripting language that can be integrated easily with my haskell library (for execution of user scripts included at runtime)
09:56:46 <bartavelle> will see tomorrow
09:56:53 <hpaste> mog annotated “explanation on IO monad and Either functor needed” with “explanation on IO monad and Either functor needed (annotation)” at http://hpaste.org/75313#a75314
09:57:03 <Clint> mog_: what do you want it to do if the parse fails?
09:57:30 <Botje> mog_: after all that, you've created something of type Either ParseError (IO ())
09:57:51 <Botje> mog_: probably easier to just pattern match on f and continue as normal
09:58:42 <mog_> Clint: I don't mind what it does if the parse fails, in my case it shouldn't fail anyway
09:58:52 <mog_> Botje: I'll try the pattern matching then, thanks :)
10:00:09 <Entroacceptor> bartavelle: traditional is Lua, I guess?
10:00:19 <Entroacceptor> http://www.haskell.org/haskellwiki/HsLua
10:02:51 <Polarina> Does calling an unsafe FFI function block the entire Haskell runtime, including other threads when compiled with -threaded?
10:03:46 <mog_> Botje: works like a charm now, thanks again
10:05:06 <moobull69> ./build: 20: cd: can't cd to botpp
10:05:37 <Botje> mog_: yay!
10:06:41 <moobull69> any more suggestions? The botpp folder seems to be missing
10:06:50 <moobull69> when using source
10:07:18 <geekosaur> Polarina, with -threaded at least they're run in a dedicated thread and should allow other stuff to run
10:09:56 <Philonous> Does threadWaitRead not block the haskell threads, even when compiled without -threaded?
10:15:40 <geekosaur> file descriptors are nonblocking, the blocked thread is simply not rescheduled until the fd is marked ready for read by select/poll/epoll
10:16:05 <clahey> Say I want to build a hash table with order 2^20 items each of which I need to calculate.
10:16:45 <clahey> Any idea what would be an efficient way to do that in haskell?
10:17:49 <clahey> Doesn't have to be a hash table.  A map would work okay.
10:18:09 <clahey> By a map, I mean a balanced tree.
10:19:29 <Philonous> geekosaur:  Ah, than I understand the maneuvre of calling accept4()-nonblockingly and instead using threadWaitRead
10:19:57 <Philonous> then*
10:24:15 <clahey> Is there any way to make a type dependent on a value?
10:24:28 <clahey> I know you can have type variables where the type is dependent on another type.
10:24:38 <clahey> Like [Int] is a list dependent on an Int.
10:24:43 <Philonous> clahey:  Haskell is not dependently typed, no.
10:25:06 <zxspectrum> hi. is there a name for a binary tree with the types on the leaves different from the types on the internal nodes?
10:25:08 <Philonous> clahey:  Ask again in a few years, though ;)
10:25:13 <clahey> Specifically, I want modulo arithmetic.
10:25:27 <clahey> But I want to make it so you can't add a Mod 5 and a Mod 7.
10:25:59 <benmachine> clahey: ah, that's different
10:26:04 <Philonous> clahey:  Oh, but that's different. In ghc 7.6.1 you can actually do that
10:26:06 <benmachine> clahey: all you want *there* is type-level numbers
10:26:14 <Polarina> clahey, you can newtype wrap an existing type and not implement Num for it.
10:26:16 <benmachine> 7.6.1 makes it convenient but it was possible before
10:26:43 <benmachine> clahey: sec, I'll paste something I did that uses similar dieas
10:26:46 <benmachine> er ideas
10:27:43 <clahey> Polarina: I want to implement Num for it.
10:27:58 <clahey> Polarina: You should be able to add a Mod 5 to another Mod 5.
10:28:24 <exFalso> you can simulate it
10:28:31 <exFalso> try DataKinds
10:28:41 <exFalso> and lift the Naturals to the type level
10:29:07 <exFalso> so you'll have something like this: data Nat = Zero | Succ Nat
10:29:19 <exFalso> and your Modulo type will be:
10:29:43 <exFalso> data Modulo (n :: Nat) (... your definition here ...)
10:30:00 <hpaste> benmachine pasted “Field.hs” at http://hpaste.org/75315
10:30:09 <moobull69> (lamdbabot) Illegal instance declaration for `Module BaseModule BaseState'
10:30:31 <exFalso> if you don't want to rely on the DataKinds extension you can also do it like this:
10:30:33 <exFalso> data Zero
10:30:40 <exFalso> data Succ a
10:30:43 <benmachine> exFalso: see my paste :)
10:30:53 <benmachine> I actually have a binary encoding which is way less painful
10:31:03 <benmachine> (but you can't really do arithmetic on it so easily)
10:31:03 <clahey> exFalso: Woah.
10:31:21 <exFalso> see benmachine's code for doing it without DataKinds
10:31:23 <Philonous> exFalso:  I thing 7.6 actually has a better representation for type-level ints including literals and a solver for Pressburger arithmetic
10:31:25 <exFalso> and in binary haha
10:31:34 <Philonous> think*
10:31:47 <clahey> Won't that be super slow if your type requires 2^20 other types before it?
10:31:48 <exFalso> Philonous: true dat, most people havent migrated yet though
10:31:57 <benmachine> clahey: the code I pasted implements a type for a + b sqrt n
10:32:28 <clahey> benmachine: Where n is associated with the type, right
10:32:29 <clahey> ?
10:32:31 <benmachine> clahey: one of the key parts of this approach is that although I've included a way to represent any number, I don't need to use it
10:32:34 <benmachine> clahey: yes
10:33:01 <benmachine> clahey: I could just as well use 'data Five'; 'instance Root Five where getRoot _ = 5'
10:33:07 <exFalso> clahey: yes it is slow, if you have ghc 7.6 it has type level naturals using native ints so it should be faster, see Pholonous's post
10:34:02 <benmachine> clahey: I'm assuming that you don't need functions like Mod n -> Mod m -> Mod (n*m), that's a bit harder :)
10:34:33 <clahey> benmachine: Nope.
10:34:40 <clahey> benmachine: Just Mod n -> Mod n -> Mod n.
10:34:49 <benmachine> (I could see it being useful in solving problems with the CRT, but...)
10:34:50 <clahey> Well, I'd like to make them the standard operators.
10:34:56 <benmachine> sure, you can do that
10:35:05 <exFalso> i'm not sure about how powerful the 7.6 type level nat equational reasoning is, in any case you can construct all your proofs if you define the Nats yourself
10:36:15 <clahey> benmachine: Okay, so I see that I can do it, but it's somewhat complicated.
10:36:17 <exFalso> also, if your code is only for maths purposes, check out Agda:)
10:36:26 <clahey> benmachine: Is there a description of the mechanism I'd be using?
10:36:28 <benmachine> clahey: it doesn't need to be that complicated
10:36:34 <rwbarton> getting modular arithmetic should be pretty painless with something like type-level or type-nat or reflection
10:36:39 <Philonous> exFalso:  That quickly get "interesting" If you numbers aren't fairly small
10:36:44 <benmachine> clahey: see also the Data.Fixed module in base
10:36:44 <Philonous> will*
10:37:26 <benmachine> clahey: also, are you okay with users of your library having to define an instance of a typeclass for every n they want modulo for?
10:37:55 <clahey> It'd be nice if they didn't have to, but if it's not possible...
10:38:06 <clahey> Especially since I'm probably going to be the only person that ever uses it.
10:38:17 <benmachine> clahey: it's possible for them to not have to, but it's simpler if you accept that restriction
10:38:24 <benmachine> because you don't need any type-level arithmetic in that case
10:38:53 <clahey> I get it.
10:39:08 <clahey> I define a typeclass and they just have to write an instance which returns the value.
10:39:13 <benmachine> yeah, basically
10:39:41 <clahey> And you won't be able to do ChrisModFive -> BenModFive -> JohnModFive.
10:39:51 <clahey> Because we will each have created a different type.
10:39:53 <benmachine> yeah
10:39:58 <benmachine> unless you share your types somehow
10:40:12 <clahey> I just realized that all this won't allow the base to be determined at run time.
10:40:20 <rwbarton> you can still do that with reflection
10:40:24 <clahey> Just like it wouldn't in the languages I'm used to.
10:40:25 <benmachine> you can't have types determined at runtime
10:40:34 <rwbarton> yes you can :) sort of
10:40:36 <benmachine> unless you're using a dependently-typed language
10:40:43 <n-dolio> You can have dictionaries determined at runtime.
10:40:46 <benmachine> rwbarton: sort of, indeed! :P
10:40:47 <n-dolio> Which is all you need.
10:40:53 <rwbarton> right, with polymorphic recursion
10:41:06 <clahey> I'll just make it a run time error if you mix bases perhaps.
10:41:07 <benmachine> n-dolio: well, but surely the whole point is that the types are distinct, so that you can't use them wrongly
10:41:16 <exFalso> rwbarton: link please
10:41:26 <rwbarton> @hackage reflection
10:41:26 <lambdabot> http://hackage.haskell.org/package/reflection
10:41:34 <rwbarton> @where reflection
10:41:34 <lambdabot> I know nothing about reflection.
10:41:39 <rwbarton> there is an oleg paper about it
10:41:48 <exFalso> even better
10:41:51 <rwbarton> from rather a while ago
10:41:58 <rwbarton> @google oleg implicit configuration
10:42:00 <lambdabot> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
10:42:00 <lambdabot> Title: Functional Pearl: Implicit Configurations
10:42:10 <benmachine> if we want a simple approach, this probably isn't it, though, right?
10:42:48 <rwbarton> well it is simple in that there are already libraries that do the work for you :)
10:44:17 <exFalso> thank you! i love haskell
10:44:30 <mcstar> the module's 'docstring' is longer than the code in that lib
10:44:56 <rwbarton> haha yeah, the new version is a bit cheating :)
10:45:07 <clahey> Maybe I'll just do it with Integers and not worry about making it look cool with neat types.
10:45:21 <rwbarton> http://hackage.haskell.org/packages/archive/reflection/0.9/doc/html/src/Data-Reflection.html is the traditional way
10:45:27 <strager_> How do I coerce a Double into a Word32?  :: Double -> Word32
10:45:29 <benmachine> clahey: but cool neat types are awesome :(
10:45:47 <rwbarton> strager_: define "coerce"
10:45:54 <rwbarton> there are a bunch of functions like that
10:45:56 <clahey> benmachine: I agree.
10:46:17 <clahey> benmachine: But getting my homework done quickly and then moving on to making my web site be in haskell might be cooler.
10:46:25 <benmachine> clahey: ah, fair enough
10:46:37 <benmachine> strager_: do you want rounding or what
10:46:41 <strager_> rwbarton: fromInteger 2 :: Double  -- like that, but from Double to Word32.  It may be lossy; I don't care what happens if the input is out of range.
10:46:56 <strager_> benmachine: The input double should be an integer, but if it isn't, I don't care.
10:47:00 <Cale> strager_: fromIntegral
10:47:05 <rwbarton> ... no
10:47:07 <rwbarton> @type floor
10:47:08 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
10:47:10 <benmachine> strager_: round or floor or ceiling
10:47:14 <rwbarton> > floor 3.7 :: Word32
10:47:15 <lambdabot>   3
10:47:16 <Cale> oh, the other way
10:47:21 <mcstar> rwbarton: somehow code that has lots of repetition like that, looks out of place to me... like some hack
10:47:30 <benmachine> or truncate
10:47:33 <Cale> or round
10:47:35 <benmachine> probably round
10:47:52 <rwbarton> mcstar: it's a kind of unrolled loop for efficiency, but indeed the not-unrolled version is a hack too :)
10:48:03 <clahey> So, what options do I have for a run time error?
10:48:19 <NihilistDandy> GO CAT GO
10:48:23 <strager_> Thanks benmachine
10:48:55 <benmachine> clahey: 'error' is probably the easiest
10:49:03 <benmachine> and is fine if you don't anticipate it coming up very much
10:49:08 <monochrom> the "error" function is for runtime errors
10:49:20 <benmachine> if you have functions that might fail in normal usage, a Maybe type is better
10:49:32 <benmachine> or an Either type if there's more than one failure mode that you might want to know about
10:49:52 <clahey> benmachine: Yeah, I understood those.  I think I'll just go with error.
10:49:57 <clahey> It's a programming error if you mix them.
10:50:01 <benmachine> mm
10:50:23 <clahey> IMO.
10:50:34 <monochrom> that's cool. but if you can help it, should find a way to forbid mixing.
10:50:34 <mcstar> im trying to write a simple asteroids game, but if i keep staring at the irc window ill get nowhere
10:50:37 <benmachine> or you could do something perverse, like giving a result whose modulus is the gcd of the input moduli :P
10:51:02 <clahey> I wanted it to be a compile time error, but that's obviously impossible if the modulus is determined at run time.
10:51:08 <clahey> Unless it could automatically create a new type.
10:51:21 <clahey> Since I'm just a beginning haskeller, I think I'll go with making it a run time error.
10:51:22 <rwbarton> it's not impossible
10:51:26 <rwbarton> let me dig up my old code for this
10:51:47 <benmachine> I think for a beginner, a runtime error is fine
10:56:44 <gwern> @pl f x = take x . filter odd
10:56:44 <lambdabot> f = (. filter odd) . take
10:56:52 <rwbarton> I would put together a modular-arithmetic package for hackage, but with 7.6 out now it seems obsolete...
11:00:10 <clahey> Hmm.
11:01:31 <clahey> I want to implement Bounded and Enum, but my class wouldn't follow the rule they suggest.
11:01:44 <clahey> I guess minBound and maxBound don't really make sense, but they seem like they would be useful.
11:04:36 <clahey> Oh, minBound and maxBound are based on the type and if the modulo is in the data, then they absolutely don't make sense.  Done.
11:05:22 <BernardP> hello
11:05:37 <BernardP> just a total noob climbing mount haskell
11:06:18 <BernardP> reading "real world haskell" atm
11:07:50 <BernardP> does anyone know if there is anything current with FRAN? or anthing similar?
11:09:55 <mizu_no_oto> FRP in general, or FR animation in particular?
11:10:56 <hiptobecubic> > let [x] = [1,2,3] in x
11:10:56 <lambdabot>   *Exception: <interactive>:3:4-16: Irrefutable pattern failed for pattern [x]
11:11:08 <hiptobecubic> Why doesn't it just fail to match up front?
11:12:56 <hiptobecubic> Are let bindings just always irrefutable?
11:13:02 <benmachine> yes
11:13:04 <rwbarton> they are
11:13:09 <rwbarton> however i don't understand what you are asking
11:13:19 <rwbarton> well, maybe i do
11:13:21 <rwbarton> but your example is bad :)
11:13:32 <benmachine> it doesn't fail to match up-front because that would not be non-strict
11:13:36 <benmachine> well
11:13:39 <rwbarton> it can't possibly do anything other than cause a pattern match failure
11:13:49 <benmachine> it'd be possible to have the language like that, but it would be silly
11:13:50 <BernardP> @mizu - in general for starters
11:13:50 <lambdabot> Unknown command, try @list
11:14:32 <Cale> let generally doesn't cause evaluation to occur
11:14:36 <mcstar> any ideas to trick Gloss into not terminating ghci when i close the window?
11:14:38 <hiptobecubic> i guess i need to use case then
11:14:43 <BernardP> i want to understand the advantages (if any) to adapting a functional approach to animation
11:14:48 <benmachine> case is underrated
11:14:52 <benmachine> everyone should use case all the time
11:15:05 <Cale> (with the weird exception of bang patterns in let, which oddly don't have ~'s added to them)
11:15:26 <benmachine> bang patterns in let are just weird
11:15:45 <rwbarton> pretend it's let! x = ...
11:15:46 <Philonous> edwardk:  cc-options: -fPIC made the error go away.
11:15:48 <Cale> bang patterns in let get translated into case expressions
11:15:52 * benmachine wonders if bang patterns would not be better restricted to case-like contexts
11:16:04 <benmachine> (I imagine that's where most people use them anyway)
11:16:10 <Cale> I think it should just go back to the original translation
11:16:12 <Quantumplation> Is there a convenient function to rotate a list? i.e. so that the first element becomes the last (or vice versa)
11:16:16 <edwardk> interesting. i think i'm already feeding cc -fPIC in rounded
11:16:16 <Cale> i.e. the obvious one
11:16:30 <benmachine> Cale: what's the obvious one? :P
11:16:37 <Cale> Quantumplation: no, because that's a bad operation on lists
11:16:48 <edwardk> apparently not!
11:16:50 <benmachine> let !x = y in z → let x = y in x `seq` z?
11:16:51 <edwardk> let me try that
11:17:03 <Cale> benmachine: yes
11:17:27 <benmachine> Cale: makes sense. I suppose you don't worry, either, about which order the seqs go in if there's more than one binding
11:17:37 <Cale> benmachine: just bind a fresh variable if needs be for each banged subpattern, and then seq those on the rhs.
11:17:52 <Cale> The order the seqs go in cannot matter anyway.
11:17:57 <benmachine> semantically at least, x `seq` y `seq` z = y `seq` x `seq` z
11:18:08 <Cale> x `seq` y `seq` z is equal to y `seq` x `seq` z, yes
11:18:11 <Quantumplation> cale: is there some kind of ring structure that behaves similarly to lists but lets me move the "head" in haskell?
11:18:13 <benmachine> (I suspect exceptions may be able to tell the difference, but exceptions are odd anyway)
11:18:21 <rwbarton> what do let bang-patterns do instead then?
11:18:29 <benmachine> rwbarton: turn into a case statement
11:18:37 <Cale> case expression*
11:18:44 <benmachine> :P fair point
11:18:58 <benmachine> Quantumplation: there are structures that at least support fast appending and reading from either end
11:19:02 <benmachine> like Data.Sequence
11:19:10 <rwbarton> surely not like "let !x = y in z" => "case y of x -> z"
11:19:11 <mcstar> can i 'newtype' the element of a sum type?
11:19:17 <Cale> Quantumplation: well, you can write   rotate [] = []; rotate (x:xs) = xs ++ [x]
11:19:20 <benmachine> you *can* define circular linked lists, but they are a bit hairy >_>
11:19:30 <scshunt> mcstar: huh?
11:19:30 <rwbarton> or you mean a core case
11:19:38 <Cale> Quantumplation: but note that xs ++ ys takes O(length xs) time to fully evaluate
11:19:39 <mysticc> I am using parsec. I am writing a parser to parse a line. I parsed the initial part and now I want to parse everything else until the end of line into a string .. How to specify this ?
11:19:45 <Cale> Quantumplation: So that's really expensive on lists
11:20:00 <Cale> Quantumplation: If you use something like Data.Sequence, you might have a better time there.
11:20:03 <mcstar> probably not then
11:20:08 <benmachine> mysticc: something like, many (noneOf "\n")?
11:20:09 <edwardk> hrmm, that wasn't sufficient to fix mine
11:20:17 <edwardk> Philonous: but i'm glad it helped your case =)
11:20:23 <Cale> Or perhaps you want a Queue structure (Data.Sequence makes a fine queue though)
11:20:40 <mysticc> benmachine: Thanks
11:20:53 <benmachine> mysticc: it's been a while since I last used parsec, so no promises :)
11:21:28 <Philonous> edwardk:  I'm still puzzled why that helped. Wouldn't that mean a bug in ghci's relocator?
11:21:34 <Cale> Quantumplation: and rotating in the other direction:  rotate' [] = []; rotate' xs = last xs : init xs  is similarly O(n)
11:22:01 <edwardk> not sure
11:22:18 <edwardk> copumpkin copumpkin copumpkin: i invoke thee
11:22:19 <Cale> Quantumplation: However, you can apply cycle to xs, and then iterate through that
11:22:22 <Cale> (infinitely)
11:22:27 <copumpkin> on conference call :)
11:22:31 <Cale> > cycle [1,2,3,4]
11:22:31 <copumpkin> need to pay attention
11:22:32 <edwardk> =)
11:22:32 <lambdabot>   [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,...
11:22:43 <Cale> Quantumplation: and that's inexpensive :)
11:22:45 <edwardk> when you get a chance read Philonous' comments above
11:23:55 <EvanR> show . show . show . show $ "foo"
11:23:57 <EvanR> >show . show . show . show $ "foo"
11:23:59 <EvanR> > show . show . show . show $ "foo"
11:24:01 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
11:24:03 <zomg> Cale: tracked segfault down to this now https://github.com/vincenthz/hs-certificate/blob/master/System/Certificate/X509/Unix.hs#L63
11:24:11 <Philonous> I need to read a book about linkers. I merely have a hazy idea about what they do. Any suggestions?
11:24:46 <EvanR> Philonous: http://linker.iecc.com/ ?
11:25:17 <Philonous> EvanR:  Thanks
11:26:48 <clahey> benmachine: I am liking the idea of doing something like HasResolution a => Fixed a.
11:27:01 <clahey> benmachine: It makes fromInteger and fromRational possible.
11:27:11 <Industrial> Trying to learn haskell, there's something wrong with my indentation. https://gist.github.com/5b972f98524a820c754c
11:27:19 <benmachine> clahey: but the type is still fixed at compile time
11:27:43 <rwbarton> Industrial: line 7 needs to be more indented
11:27:52 <rwbarton> currently it begins a new command in the do block
11:28:14 <clahey> benmachine: When it says: resolution :: p a -> Integer
11:28:18 <clahey> What are the p and a?
11:28:40 <benmachine> clahey: well, the a is the class parameter
11:28:53 <benmachine> the p can be anything, but will almost always be Fixed
11:29:07 <clahey> So that method takes types as its arguments?
11:29:18 <benmachine> no, it takes a value of type p a
11:29:30 <benmachine> where p is usually Fixed, and a is whatever the instance is being defined for
11:29:48 <clahey> It takes a Fixed E12 and returns 10^12 or whatever.
11:29:52 <benmachine> yes
11:29:56 <clahey> Or 10^-12, whatever.
11:30:03 <benmachine> well, it returns an Integer
11:30:09 <benmachine> might be just 12
11:30:15 <clahey> True.
11:30:44 <benmachine> ghci> resolution (0 :: Fixed E12)
11:30:44 <benmachine> 1000000000000
11:30:51 <benmachine> there you have it
11:31:10 <benmachine> ghci> resolution (0 :: Fixed E9)
11:31:11 <benmachine> 1000000000
11:31:11 <benmachine> etc.
11:31:26 <clahey> And it doesn't matter whether it's 0 or 10000 or -5
11:31:35 <clahey> Or whatever.
11:31:42 <benmachine> indeed
11:31:46 <benmachine> it doesn't look at the actual value
11:31:52 <benmachine> in fact it can't
11:32:10 <benmachine> because resolution :: p a -> Integer has to work regardless of what p is
11:32:20 <benmachine> since you don't know anything about p, you can't inspect it at all
11:32:32 <benmachine> so it must just return a constant integer
11:33:03 <benmachine> (it just so happens you'll normally use it when p = Fixed, but you don't *have* to)
11:33:08 <benmachine> ghci> resolution (Nothing :: Maybe E6)
11:33:08 <benmachine> 1000000
11:33:54 <clahey> Is there a way for me to make Modulo 5 3 ^ 20 do something other than repeated multiplication?
11:34:17 <benmachine> what's wrong with repeated multiplication?
11:34:23 <rwbarton> (^) already doesn't do repeated multiplication
11:34:31 <benmachine> rwbarton: well, it does :P
11:34:36 <rwbarton> well not the dumb way
11:34:39 <benmachine> but x^20 doesn't do 20 multiplications
11:35:05 <EvanR> clahey: a newtype
11:35:05 <rwbarton> > x^20
11:35:06 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
11:35:15 <benmachine> EvanR: no, because ^ is not a class method
11:35:19 <benmachine> you can't redefine it
11:35:22 <EvanR> oh
11:35:28 <EvanR> :t (^)
11:35:29 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
11:35:36 <benmachine> it *uses* class methods
11:35:40 <benmachine> but how it uses them is fixed
11:35:55 <clahey> > x ^ 40
11:35:56 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
11:36:11 <benmachine> clahey: that's not really a great way of showing you how it works
11:36:18 <clahey> > x ^ 10
11:36:19 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x)
11:36:25 <benmachine> clahey: are you familiar with the concept of exponentiation by repeated squaring?
11:36:28 <clahey> Yes.
11:36:30 <rwbarton> lots of stuff there is shared
11:36:31 <benmachine> okay
11:36:31 <benmachine> well
11:36:33 <benmachine> it does that :P
11:36:37 <clahey> And the fact that it's built in is wonderful.
11:36:45 * benmachine secretly put out that he didn't get to explain it
11:36:47 <EvanR> > x ** 10
11:36:48 <lambdabot>   x**10
11:36:54 <clahey> 2 `modulo` 3 ^ (2 ^ 20)
11:37:00 <clahey> Answered immediately.
11:37:07 <benmachine> clahey: :)
11:37:08 <Melvar> The use of x here just reminded me of the time I considered naming an exported constant “x”.
11:37:19 <clahey> It's 1 `modulo` 3, fwiw.
11:37:22 <EvanR> lol
11:37:33 <benmachine> clahey: well, yes, because the exponent is even :P
11:37:41 <clahey> benmachine: True.
11:37:44 <benmachine> (2 = -1 mod 3)
11:37:56 <clahey> benmachine: True.
11:37:58 <benmachine> so indeed you *could* actually implement ^ way faster than even repeated squaring
11:37:59 <EvanR> > -1 `mod` 3
11:38:01 <lambdabot>   -1
11:38:07 <benmachine> but unfortunately the system is not set up to let you
11:38:23 <benmachine> EvanR: that's -(1 `mod` 3)
11:38:31 <EvanR> > (-1) `mod` 3
11:38:32 <lambdabot>   2
11:38:35 <EvanR> \o/
11:38:59 <Melvar> x = Poly [0,1]
11:39:01 <clahey> But benmachine Right, because as soon as I hit 1, I could stop.
11:39:19 <clahey> benmachine: Actually, I could.
11:39:32 <benmachine> clahey: not /exactly/ - it's just that the only thing that matters is the parity of the exponent
11:39:33 <clahey> If I include a special case, I can do it.
11:39:35 <benmachine> odd or even
11:39:49 <clahey> benmachine: No, because it would do repeated squaring.
11:40:01 <benmachine> clahey: ah, I see what you mean
11:40:14 <clahey> After the first squaring, it would see 1 and from then on it would just see the 1 and skip the actual multiplication step.
11:40:22 <benmachine> mm.
11:40:30 <benmachine> I suspect that's not *quite* possible
11:40:40 <clahey> It would know that mult 1 x = 1
11:40:45 <benmachine> yes
11:40:52 <benmachine> but it would still have to reduce a tree of lots of mults
11:40:57 <clahey> Which is faster than actually multiplying.
11:40:58 <rwbarton> it's not like multiplying 1 by itself a bunch of times is significantly more expensive than determining than the exponent actually is a power of 2
11:40:59 <benmachine> even if it doesn't have to do much multiplication
11:41:12 <clahey> benmachine: True.
11:41:22 <rwbarton> also mult 1 x isn't 1 :P
11:41:26 <clahey> rwbarton: I know.
11:41:31 <clahey> mult 1 1 = 1
11:41:54 <benmachine> rwbarton: you can determine the exponent is a power of 2 just by looking at the last bit
11:41:54 <clahey> rwbarton: Multiplying 1 by itself is just as expensive as any other multiplication, no?
11:41:57 <benmachine> depending on your representation
11:42:03 <clahey> It really doesn't matter.
11:42:03 <benmachine> clahey: nooo not exactly
11:42:11 <clahey> benmachine: Well, not for Integers.
11:42:13 <clahey> For Ints.
11:42:15 <benmachine> clahey: ah, right
11:42:21 <shachaf> benmachine: What kind of representation is that?
11:42:32 <benmachine> shachaf: apparently, the one we are talking about :P
11:42:34 <rwbarton> data Integer = PowerOfTwo Int | Other Integer
11:42:39 <rwbarton> uh
11:42:42 <rwbarton> except not recursive
11:42:56 <clahey> rwbarton: Really?  That's awesome.
11:43:01 <rwbarton> no of course not :P
11:43:02 <benmachine> that's weird
11:43:07 <benmachine> I think Integer is
11:43:13 <benmachine> well, it's built-in by default
11:43:16 <shachaf> rwbarton: That's OK, it's just a representation of naturals!
11:43:17 <benmachine> but there's integer-simple
11:43:25 <rwbarton> @type (^)
11:43:26 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
11:43:29 <rwbarton> oh
11:43:42 <benmachine> aw, integer-simple's not on Hackage
11:43:46 <benmachine> there's probably good reasons for that
11:43:51 <rwbarton> well a large Integer is of course represented as a bunch of words in whatever power of 2 is convenient for gmp
11:43:58 <rwbarton> *in base
11:44:39 <rwbarton> in order to know that you only ever multiply 1 by 1 you need to know the input is a power of 2
11:44:43 <benmachine> hah, there's a module called GHC.Magic
11:44:46 <rwbarton> and in order to know that you have to check all the bits
11:44:46 <benmachine> it's not as exciting as it sounds
11:45:02 <benmachine> rwbarton: no
11:45:03 <Quantumplation> Cale: sorry, i'm at work so I saw your response but was busy.  I'm writing a simulator for a producer/consumer economy, and the problem is if the consumers all stay in the same order, the first one tends to hog the resources from each successive tick, so I want to make sure each one gets a "chance" to run first.
11:45:11 <benmachine> rwbarton: well, whatever :P
11:45:15 <rwbarton> no what
11:45:18 <Quantumplation> But they're executed on a tick-bases, not just sequencing infinitely through the list as with cycle
11:45:29 <benmachine> rwbarton: I mean, essentially you are calculating (-1)^n
11:45:44 <benmachine> rwbarton: it gets calculated as ((-1)^2)^(n/2)
11:45:51 <rwbarton> if you want to say "n is even so at the end I square something => I get 1" that's different
11:46:06 <benmachine> rwbarton: n is even so at the *beginning* I square something :)
11:46:20 <rwbarton> that's not actually how it works is it
11:46:24 <benmachine> isn't it?
11:46:30 <benmachine> I don't see why not
11:46:36 <Cale> Quantumplation: sounds like a job for priority queues or just regular queues
11:46:43 <rwbarton> isn't it like pow x n | even n = let y = pow x (n `div` 2) in y * Y
11:46:58 <rwbarton> i guess you can do it either way
11:47:02 <benmachine> indeed
11:47:03 <uniquenick> what is the right way to go from a lazy bytestring to a notlazy text?
11:47:20 <shachaf> uniquenick: There are lots of ways to do that.
11:47:23 <benmachine> uniquenick: depends on the encoding
11:47:34 <ParahSa1lin> does the GHC runtime do fancy-cool stuff to avoid blocking in io, when you do a forkIO lightweight thread?
11:47:43 <shachaf> ParahSa1lin: Yes.
11:47:57 <shachaf> Your ByteString is probably UTF-8, so you can use Data.Text.Encoding.decodeUTF8
11:47:57 <Cale> ParahSa1lin: all IO is implemented with nonblocking primitives, pretty much
11:47:57 <benmachine> the GHC runtime does all the fancy-cool stuff
11:48:01 <uniquenick> its utf8, do I need to go lazybs -> bs -> encodeUtf8?
11:48:01 <shachaf> (But maybe it's not.)
11:48:04 <rwbarton> benmachine: oh yeah, I see (^) is actually implemented the other way
11:48:07 <ParahSa1lin> where might i read about the fancy-cool stff it does
11:48:21 <benmachine> uniquenick: either that or lazybs -> lazytext -> text
11:48:22 <Cale> ParahSa1lin: The source code for the runtime system?
11:48:28 <rwbarton> more tail-recursive I guess
11:48:39 <benmachine> rwbarton: I don't know why it's that way, it might be something like that
11:49:01 <Cale> ParahSa1lin: Or just the source code for System.IO has lots of hints
11:49:05 <benmachine> Cale: but some of it is *gasp* C
11:49:08 <Quantumplation> Thanks Cale :)
11:49:10 * benmachine faints in horror
11:49:35 <shachaf> And C--!
11:49:52 <benmachine> shachaf: is that worse or better
11:49:59 <shachaf> Depends.
11:50:09 <benmachine> I have a feeling it ought to be better because it was invented by the GHC people
11:50:10 <shachaf> It's closer to assembly than C.
11:51:03 <Cale> Quantumplation: If you wanted to implement your own queue, a very straightforward way is just a pair of lists, one in reverse order. You add elements to one of the lists, and take them from the other, and when you try to take and there's nothing there, you reverse the other and swap that in.
11:51:25 <uniquenick> is there some nicer way to use aeson that I am missing?  seems a bit nuts to have to encode -> lazybs -> bs -> text instead of just getting a text in the first place
11:51:42 <ParahSa1lin> seems the runtime uses select() syscall?
11:51:56 <Cale> ParahSa1lin: It uses epoll/kqueue where available
11:51:56 <shachaf> A zipper is also a pair of lists, one in reverse order. I wonder if there's any relation.
11:52:10 <shachaf> Probably not, since they're used very differently.
11:52:13 <benmachine> uniquenick: hmm, I think there is a nicer way
11:52:28 <benmachine> uniquenick: or wait, you're going JSON -> Text?
11:52:39 <jfischoff> uniquenick: what are you trying to do exactly?
11:52:48 <shachaf> Well, maybe moving the cursor all the way to the left is like a queue operation.
11:53:10 <uniquenick> take a Foo and turn it into a Text that contains the utf8 string of its json representation
11:53:23 <benmachine> uniquenick: what do you do with that text?
11:53:27 <rwbarton> s/utf8//
11:53:41 <Melvar> Are there guidelines on the hierarchical module structure within a single lib?
11:53:45 <rwbarton> (or s/utf8/unicode/)
11:54:07 <uniquenick> send it to a function that wants a Text
11:54:17 <Cale> Melvar: Just do whatever seems reasonable.
11:54:34 <Melvar> Cale: Dang, I suspected that.
11:54:57 <Cale> Melvar: Is that a disappointment? :)
11:55:23 <benmachine> uniquenick: yeeees... I was just wondering if it was a function that had a bytestring companion :P
11:55:56 <uniquenick> no such luck in this case, that's why I was ok before, because everywhere else I used encode I could use the LBS directly
11:56:02 <rwbarton> how about http://hackage.haskell.org/packages/archive/aeson/0.6.0.2/doc/html/Data-Aeson-Encode.html#v:fromValue
11:56:09 <jfischoff> uniquenick: ^
11:56:13 <Cale> Melvar: Obviously it's best if people don't trample over each other, but there are ways to select the package to import individual modules from anyway -- though I've basically never seen that come up.
11:56:32 <Melvar> Cale: It is, because I’m having a hard time thinking up how to restructure a tiny lib I wrote, since I think the current structure is rather bad.
11:56:48 <ParahSa1lin> hm i dont see any reference to kqueue or epoll in the source im looking at
11:57:05 <shachaf> dmwit: How do you catch uniquenick?
11:57:09 <Quantumplation> Cale: any particular Queue library you reccomend? I.E. are there ones more efficient than the prelude Data.Queue?
11:57:15 * hackagebot haslo 0.1.2 - Loan calculator engine.  http://hackage.haskell.org/package/haslo-0.1.2 (BartoszWojcik)
11:57:25 <clahey> So, I can't seem to do:
11:57:32 <clahey> instance Num Modulo where
11:57:49 <clahey>   Modulo a bas + Modulo b bas = ...
11:57:56 <clahey> Conflicting definitions for bas.
11:58:04 <clahey> But the whole point is that I want them to be equal.
11:58:08 <clahey> Not allowed?
11:58:11 <rwbarton> not allowed
11:58:15 <rwbarton> you can use a guard
11:58:25 <rwbarton> (and two separate variables)
11:58:30 <Cale> Quantumplation: oh, there's a Data.Queue?
11:58:40 <Cale> Quantumplation: that's from the queuelike package isn't it?
11:58:53 <rwbarton> or I guess ViewPatterns if you want to get overly fancy
11:59:23 <bgamari> If I have a SCC declaration: ({-# SCC hello #-} sampleProb theta t)
11:59:42 <bgamari> how is it possible that hello has lots of allocations against it, yet hello.sampleProb doesn't
11:59:50 <Cale> Quantumplation: a really easy way is just to use Data.Sequence as a queue
11:59:58 <Cale> Quantumplation: it has O(1) access to both ends
12:00:59 <saml> given f, how can I get inverse of f?
12:01:11 <clahey> rwbarton: I just did a + b | base a == base b = ...
12:01:16 <dmwit> shachaf: =)
12:01:17 <saml> f is  Int -> Int
12:01:38 <ParahSa1lin> ah GHC.Event
12:01:42 <Cale> saml: The inverse function to f is the function g such that g . f = id and f . g = id
12:02:07 <Cale> saml: i.e. g (f x) = x, and f (g x) = x
12:02:16 <saml> Cale, but is there such known inverse such that    inverse f   = g ?
12:02:27 <Cale> saml: It's uncomputable in general.
12:02:32 <saml> thanks
12:02:39 <benmachine> it doesn't necessarily exist, surely
12:02:53 <benmachine> cf. f = const 7
12:03:08 <rwbarton> inverse f y = head [ x | x <- concat (transpose [[0..], [-1,-2..]]), f x == y ]
12:03:15 <saml> ah true
12:03:29 <saml> map [1..10] (const 7)
12:03:39 <benmachine> rwbarton: awesome.
12:03:40 <saml> and you can't get the original list back
12:03:58 <benmachine> rwbarton: given that it's Int -> Int though, you could use [minBound..maxBound]
12:04:05 <rwbarton> oh true
12:04:06 <Cale> Oh, for Int of course, if you can assume that the function is total, then you can just do exhaustive searches :)
12:04:20 <clahey> benmachine: So, I'm trying to figure out how / is defined in terms of recip, but I don't know where to find that.
12:04:38 <benmachine> clahey: surely x / y = x * recip y, no?
12:04:45 <clahey> That was my expectation.
12:04:45 <benmachine> clahey: if I wanted to look something up, I'd use hackage
12:05:03 <topriddy> quick one. please if haskell is compiled, but then i can do stuff in ghci interactive. how does that work?
12:05:21 <clahey> benmachine: Oh.
12:05:26 <topriddy> also i can do :r fileName.hs to load a file. almost like an interpreted language
12:05:29 <benmachine> clahey: sec
12:05:31 <clahey> No, I thought I had an idea, but no.
12:05:49 <topriddy> > zip [1..] ['A'..'Z']
12:05:49 <benmachine> clahey: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Prelude.html#t:Fractional
12:05:50 <lambdabot>   [(1,'A'),(2,'B'),(3,'C'),(4,'D'),(5,'E'),(6,'F'),(7,'G'),(8,'H'),(9,'I'),(1...
12:06:08 <Cale> topriddy: ghci has both a bytecode interpreter in it, and a compiled object loader. In the case of compiled .o files, you have a corresponding .hi file which contains information about the stuff that the .o exports.
12:06:18 <bgamari> Is there any way to get the space profiler to give you a breakdown by both cost center and type?
12:06:20 <benmachine> clahey: that tells you that at least / *does* have a definition in terms of recip
12:06:45 <topriddy> Cale: okay.
12:06:48 <Cale> topriddy: In interpreted mode, well, there's nothing too special, it has the definitions of everything from the source
12:07:01 <benmachine> clahey: and then I can click the Source link and see what it actually is
12:07:09 <clahey> benmachine: I tried that.
12:07:16 * hackagebot enummapset 0.2.0 - IntMap and IntSet with Enum keys/elements.  http://hackage.haskell.org/package/enummapset-0.2.0 (MichalTerepeta)
12:07:20 <rwbarton> (/) is a class method isn't it
12:07:32 <topriddy> why does lambdabot stop midway? confirmed it works right in my ghci :D
12:07:32 <geekosaur> last I checked
12:07:34 <rwbarton> so it may have a default definition in terms of recip
12:07:57 <clahey> rwbarton: Right.  The question is what's the definition.
12:08:04 <benmachine> clahey: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/src/GHC-Real.html#Fractional
12:08:04 <clahey> Cause it's giving a Reciprocal error for me.
12:08:06 <rwbarton> but for e.g. Double i'm sure it's not used
12:08:22 <benmachine> clahey: are you dividing by zero or something
12:08:36 <benmachine> clahey: also, what is a Reciprocal error
12:08:52 <clahey> benmachine: Sorry, modulo mismatch error.
12:09:02 <clahey> (2 `modulo` 5) / (3 `modulo` 5)
12:09:03 <clahey> *** Exception: Modulo Mismatch
12:09:07 <clahey> (2 `modulo` 5) * recip (3 `modulo` 5)
12:09:07 <clahey> 4 `modulo` 5
12:09:15 <benmachine> that is odd.
12:09:33 <Cale> clahey: note that you can just implement / yourself
12:09:44 <Cale> When you write your instance of Fractional
12:09:53 <clahey> Cale: I know, but half the point is to learn haskell so I want to know why it's not working.
12:10:01 <benmachine> clahey: I can't explain that without being able to see your code
12:10:11 <rwbarton> did you write recip?
12:10:13 <clahey> Okay.
12:10:15 <clahey> Ignore me.
12:10:21 <clahey> I had a line that shouldn't have been there.
12:10:24 <benmachine> awesome
12:10:31 <Ralith> topriddy: also, sufficiently advanced compilers can compile things interactively, giving you an interface like ghci without any perf cost to the code.
12:10:40 <clahey> It turns out _ / _ = error "Modulo Mismatch" will make that happen.
12:10:42 <Melvar> On the note of inverting, I once thought of instance (Enum a, Bounded a, Eq b) => Eq (a -> b) where f == g = let everything = [minBound..maxBound] in map f everything == map g everything
12:10:45 <rwbarton> how are you dealing with fromInteger btw
12:11:00 <benmachine> clahey: haha, yeah :P
12:11:02 <clahey> rwbarton: I'm ignoring it for now.
12:11:25 <clahey> rwbarton: I'm considering having the modulus be a Maybe.
12:11:45 <benmachine> or you could go with my crazy idea from earlier :>
12:11:51 <clahey> And if you combine a `modulus` Nothing with b `modulus` base, you get a result modulus base.
12:12:07 <topriddy> Ralith: the rightTriangles' example on learnyouhaskell today blazingly fast. I don't even want to start thinking solution in my "former language"
12:12:10 <rwbarton> that can work yeah
12:12:16 * hackagebot dataenc 0.14.0.4 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.14.0.4 (MagnusTherning)
12:12:26 <benmachine> (namely, when you combine two things, the modulus of the results is the gcd of the modulus of the arguments; then fromInteger can use modulus 0)
12:12:40 <zomg> Anyone happen to know if there's any applications to verify the validity of a PEM file on *nix?
12:12:44 <nand`> a sufficiently primitive GHCi could just dump everything to a file and compile it with GHC+optimizations :P
12:12:50 <zomg> I figured out what's causing the segfault... decoding a PEM file.
12:12:52 <Cale> clahey: You should have operations on elements with two different moduli (apart from that Nothing case) produce a result in the lcm of the moduli :)
12:13:05 <Ralith> nand`: that works too, bar global state
12:13:07 <benmachine> Cale: that was my idea!
12:13:10 <clahey> benmachine, Cale: I really think that I want it to be an error.
12:13:11 <benmachine> Cale: except I said gcd
12:13:16 <zomg> There appears to be several pem files there which cause the segfault
12:13:21 <Ralith> topriddy: ghci doesn't actually do this, but e.g. most common lisp impls do
12:13:21 <benmachine> clahey: possibly reasonable
12:13:28 <zomg> but from an inspection using vim, I can't really tell if there's something wrong with them
12:13:48 <benmachine> Cale: I'd think gcd because, say you have 2 module 5 and 3 modulo 10, you can only guarantee your result modulo 5, not 10
12:13:55 <topriddy> Ralith: what does ghci do then?
12:14:05 <benmachine> anyway
12:14:09 * benmachine leaves on state business
12:14:15 <Ralith> topriddy: what was explained to you above.
12:14:23 <topriddy> okay :)
12:14:48 <zomg> Hmm well as far as openssl seems to be caring the pem file is valid...
12:14:57 <Cale> oh, right, I guess you'd need to have whole sets of values
12:16:17 <Cale> Everything works out nicely for the lcm when they're coprime (so that the lcm is just the product)
12:18:00 <bgamari> Any suggestions for tracking down high garbage collection rates?
12:18:01 <nand`> does the interpreter in GHCi use the source directly (or an AST representation of it) or does it translate down to a template microcode or something first?
12:18:12 <bgamari> Looking at the profile it doesn't seem like there's a ton of allocation happening
12:18:37 <bgamari> yet when run with more than 4 threads GC time grows to >80%
12:20:39 <c_wraith> bgamari: I'd suggest looking at it with threadscope.  You'll probably find that you're blocking on stop-the-world GC a bunch
12:21:26 <Ralith> nand`: 12:06:15 < Cale> topriddy: ghci has both a bytecode interpreter in it
12:21:31 <bgamari> c_wraith, Yeah, I first have to compile it which appears to be quite a feat on 7.6
12:21:37 <bgamari> This effort has already resulted in several patches
12:21:38 <Ralith> nand`: so, probably not raw AST.
12:21:55 <gfredericks> I have just started learning haskell and have been wondering about the (lack of?) difference between global constants ande 0-arg functions; especially as it relates to the memory perf of infinite sequences
12:22:00 <bgamari> How does one avoid stop-the-world?
12:22:11 <Cale> gfredericks: There's no such thing as a 0-arg function
12:22:44 <rwbarton> there is no difference
12:22:49 <ion> gfredericks: A function is anything with “->” in its type.
12:22:56 <nand`> functions are just special names for certain kinds of values
12:22:57 <gfredericks> Cale: okay, so if I want to define `primes = ...`, and it is an infinite list, the head of the list will always have a reference to it?
12:23:07 <gfredericks> such that the more of the list I realize the more memory it takes up?
12:23:24 <nand`> implementation specific
12:23:30 <rwbarton> yes
12:23:31 <Cale> gfredericks: Well, so long as it doesn't become garbage
12:23:37 <rwbarton> unless primes goes out of scope, yeah
12:23:45 <gfredericks> but it's sort of global isn't it?
12:24:06 <gfredericks> if I "assign" it at the top level?
12:24:07 <c_wraith> bgamari: you don't avoid it with the current ghc.  You can mitigate it by making the world stop much more promptly, though.
12:24:22 <rwbarton> if at some point the remainer of your program doesn't refer to it, it can be freed
12:24:25 <rwbarton> afaik
12:24:38 <rwbarton> "out of scope" was a poor choice of words on my part
12:24:44 <nand`> being defined at the top level isn't sufficient for being non-garbage, no?
12:24:45 <bgamari> c_wraith, What is puzzling me is that the profile claims I'm only allocating a few megabytes yet GC time doesn't change when I force -A/-H to 256m
12:24:59 <nand`> it depends on what thunks ‘main’ keeps alive
12:25:01 <gfredericks> okay; so if the only thing I do with it is print out the millionth element then it may not hold on to the whole thing
12:25:10 <Cale> gfredericks: right
12:25:21 <nand`> yeah such operations are usually optimized
12:25:22 <rwbarton> if you print out the millionth element twice then it probably will though
12:25:26 <gfredericks> okay that's not so bad
12:25:31 <c_wraith> bgamari: Is there a flag to set the size of the nursery generation?  That's the one that needs to be huge to prevent GC runs
12:25:41 <Cale> gfredericks: Though in the case of something like primes, it can be quite effective to hold on to the start of the list until you get there
12:25:54 <Cale> (because it's useful to use the list of primes in defining the list of primes)
12:25:59 <gfredericks> Cale: eh?
12:26:05 <gfredericks> oh but you don't need the whole thing
12:26:09 <Cale> Something like:
12:26:11 <gfredericks> so you can do much better if you avoid that tactic
12:26:11 <ion> destroyUniverse = IO (const (# undefined, undefined #))
12:26:39 <Cale> primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)
12:26:44 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
12:26:45 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:27:07 <bgamari> c_wraith, I believe that's -A
12:27:10 <gfredericks> Cale: so you can go much farther if you don't keep the whole thing in memory
12:27:27 <ion> p^2 expands to p*p, and the expansion probably gets inlined by the optimizer.
12:27:41 <Cale> gfredericks: right -- you'll need some other primality test then of course
12:27:54 <gfredericks> Cale: or a sieve
12:27:55 <bgamari> c_wraith, which is set to a few orders of magnitude higher than the supposed memory usage of the application
12:27:58 <topriddy> i can't seem to do this from ghci
12:28:06 <topriddy> > let pie :: Double
12:28:07 <lambdabot>   not an expression: `let pie :: Double'
12:28:20 <gfredericks> Cale: which is what I'm working on
12:28:27 <ion> topriddy: Indeed.
12:28:30 <topriddy> here i am trying to specify the return type for pie in preparation for doing this later on.
12:28:39 <topriddy> > pie = 22 /7
12:28:40 <lambdabot>   <no location info>: parse error on input `='
12:28:41 <rwbarton> topriddy: you can't use let like that here with lambdabot anyways but in ghci try > let pie :: Double; pie = ...
12:28:44 <rwbarton> all on one line
12:28:53 <topriddy> > let pie = 22 / 7
12:28:54 <lambdabot>   not an expression: `let pie = 22 / 7'
12:29:11 <Cale> gfredericks: Be careful, the naive sort of "Sieve of Eratosthenes" which you might write isn't really what it looks like :)
12:29:26 <topriddy> i'm sure that second line works on my ghci in any case
12:29:39 <rwbarton> yes. lambdabot is not ghci
12:30:12 <topriddy> rwbarton: but i can do the declaration on one line in a text file right
12:30:32 <Cale> > let sieve (x:xs) = x : sieve (filter (\y -> y `mod` x /= 0) xs) in sieve [2..]
12:30:33 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:31:01 <gfredericks> Cale: it's a sieve without division
12:31:04 <rwbarton> yes (but you're also not using 'let' then)
12:31:10 <gfredericks> which I think is what the idea of 'sieve' is supposed to evoke
12:31:15 <Cale> yeah
12:31:20 <NemesisD> anyone have any suggestions for a thread to figure out when the program is ending and clean up? or as a second choice, the point where the thread was spawned doing so?
12:31:46 <NemesisD> example: forkIO $ doStuff `finally` cleanUp, cleanUp does not get run when the program is hit with an interrupt, for example
12:31:56 <Cale> gfredericks: you might find this interesting: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
12:31:58 <gfredericks> Cale: it takes maybe ~20 LOC; it's kind of complicated but it's cool because it ends up working well with iterate
12:33:49 <gfredericks> Cale: I'm suspecting this paper is exactly what I came up with for Clojure
12:34:29 <dmwit> NemesisD: You must program the communication yourself (though you can of course write some functions that ease the programming).
12:35:40 <gfredericks> yep this is what I'm trying to do
12:35:41 <NemesisD> dmwit: i was planning to have to do some programming here, but i don't know how to hook into the program exit like that
12:35:49 <gfredericks> I'm curious about the perf diff between clojure and haskell
12:37:01 <gfredericks> apparently I should write academic papers instead of blogs :D
12:37:06 <gfredericks> Cale: thanks for the pointer
12:37:18 <Cale> no problem
12:37:32 <NemesisD> dmwit: im thinking it might involve Contro.Exception.mask but I'm not sure how i'd use it here
12:38:46 <dmwit> NemesisD: I think you basically don't hook into program exit. You just replace any calls that might exit to something that does some communication and then exits.
12:39:58 <NemesisD> dmwit: i don't think that works very well because a program can exit in many ways, including the user sending a sigint/hitting ctrl-c
12:41:14 <statusfailed> I'm trying to get Aeson to automatically get ToJSON and FromJSON instances for my ADT so it matches a schema, but the only problem is that the schema has one field called "data"
12:41:15 <clahey> Will Set.fromList(take (2^20) ([1..]))
12:41:19 <clahey> be fast at all?
12:41:24 <statusfailed> is there an easy way to work around it? (obviously I can't name the record thing 'data')
12:41:38 <clahey> Instantaneous.
12:41:49 <clahey> So the fact that it's slow is because of the calculations I'm doing.
12:42:13 <clahey> Oh, it's not instantaneous.  I forgot the fromList.
12:42:29 <clahey> But not terribly long.
12:42:34 <clahey> I love haskell.
12:42:50 <NemesisD> i guess i can just use System.Posix.Signals
12:42:55 <Botje> clahey: there's a fromAscList, fwiw
12:43:42 <lambdalover> hello
12:43:51 <Cale> hello!
12:44:04 <clahey> Botje: Which isn't true of my original list, but if I make it tuples with the index!
12:44:30 <Botje> fair enough, thought you didn't know :)
12:44:47 <lambdalover> http://ideone.com/Ok1f7 I have written two functions to compute the area and the perimeter of a rectangle according to supplied dimensions. How should I handle negative arguments?
12:45:12 <clahey> Botje: I didn't know about fromAscList.  That was super helpful.
12:45:50 <rwbarton> if you are making a set of zip [0..] xs maybe you should be using an array
12:47:09 <lambdalover> for most things, haskell seems much more concise than C++ :)
12:47:19 <Cale> lambdalover: I'd be tempted to just do the calculation regardless. You could also produce a Maybe result, or do what you've been doing which is throw an exception.
12:48:42 <topriddy> please in this statement: "The read function takes a string and returns a type which is a member of Read"
12:48:53 <Cale> :t read
12:48:53 <topriddy> how does it choose betwee
12:48:54 <lambdabot> forall a. (Read a) => String -> a
12:48:57 <raek_> I'm making a processor simulator for fun. The instruction decoding involves lots of bit masking. Anyone have any pointers to useful "bit libraries" that could make this easier? (I have used Data.Bits a little.)
12:49:04 <Cale> topriddy: By what type you demand
12:49:09 <Cale> > read "56" :: Integer
12:49:10 <lambdabot>   56
12:49:13 <Cale> > read "56" :: Double
12:49:14 <lambdabot>   56.0
12:49:19 <rwbarton> based on the context
12:49:25 <Cale> > read "[56,2,10]" :: [Double]
12:49:26 <lambdabot>   [56.0,2.0,10.0]
12:49:29 <topriddy> how does it choose between returning a [Char] and Int for something like read "78"
12:49:35 <topriddy> > read "78"
12:49:36 <lambdabot>   *Exception: Prelude.read: no parse
12:49:43 <rwbarton> if you try to use the result of read "78" as a [Char] then it will try to return a [Char]
12:49:45 * topriddy bleeh
12:49:47 <Cale> > read "78" :: String
12:49:48 <lambdabot>   "*Exception: Prelude.read: no parse
12:49:52 <Cale> > read "\"78\"" :: String
12:49:53 <lambdabot>   "78"
12:50:10 <topriddy> the example i saw tried to use it for arithmetic
12:50:15 <rwbarton> there are special rules for picking a type when it's not determined from the context
12:50:18 <topriddy> > read "78" + 8
12:50:18 <rwbarton> sure
12:50:19 <lambdabot>   86
12:50:23 <rwbarton> yes
12:50:29 <statusfailed> raek_: Somebody's done a DCPU-16 simulator, maybe that has useful bits?
12:50:31 <statusfailed> raek_: https://github.com/jaspervdj/dcpu16-hs
12:50:31 <Cale> topriddy: That gets handled by numeric defaulting in that case.
12:50:46 <raek_> statusfailed: Thanks! I'll take a look at it.
12:50:52 <statusfailed> raek_: np :)
12:51:05 <topriddy> oh okay. just trying to confirm a pattern
12:51:21 <Cale> (It tries Integer and Double in cases where it knows it needs an instance of Num, and the context only involves Prelude typeclasses)
12:56:59 <hpaste> hiptobecubic pasted “WHY? Is there any reason to match like this?” at http://hpaste.org/75323
12:57:03 <NemesisD> anyone familiar with installHandler from posix signals? im not sure how to handle the old handler when you install a new one
12:57:25 <clahey> So, I think I've coded my problem.
12:57:30 <dmwit> NemesisD: Sorry, I stepped away. Yeah, it kind of sucks.
12:57:36 <hiptobecubic> Am I crazy? That paste seems like a really terrible way to do things.
12:57:38 <Cale> hiptobecubic: no, there's no good reason to do that last match
12:57:42 <clahey> But since I did it all functionally, I can't put in printfs to check that it's working.  :)
12:57:49 <dmwit> You pretty much can't guarantee that something will run before you exit ever, but you can at least catch sigint and ^c.
12:57:50 <Cale> hiptobecubic: all you're doing is making the error less precise
12:58:16 <NemesisD> dmwit: i've got that working but i don't know how to responsibly call the old handler
12:58:17 <scooty-puff> is it possible to write a (Monad m, Monad n, MonadTrans t, MonadHoist t) => t m a -> (e -> t n a) -> t n a, with MonadHoist t where (Monad m, Monad n) => (forall a . m a -> n a) -> t m a -> t n a?
12:58:21 <hiptobecubic> Cale, right. But strings even? Is there any reason to use strings? I feel like this is just throwing the type checker in the garbage
12:58:37 <Cale> hiptobecubic: Well, that depends
12:58:42 <scooty-puff> is MonadTrans comparable to return, MonadHoist comparable to fmap? (meaning a join operation is required as well)
12:58:52 <NemesisD> dmwit: so i register a CatchOnce, and installHandler returns IO Handler, where Handler is the old handler, but i want to cascade the handlers
12:59:07 <Cale> hiptobecubic: There might be a good reason for those to be strings, but it's quite possible that a proper type would be better too.
12:59:09 <NemesisD> dmwit: the result from not doing that means that ctrl c will clean up and then not exit the first time
12:59:09 <dmwit> NemesisD: If it's your program, you probably already know what the old handler is, no?
12:59:19 <dmwit> Like if it's the default one you can just throw it away and never call it if you want.
12:59:42 <hiptobecubic> Cale, why would you want strings there? Given that they are all hardcoded in and this is the entire definition of fint?
12:59:52 <lambdalover> http://ideone.com/rCqpL I seem to be getting a runtime error. What's going on?
13:00:08 <NemesisD> dmwit: it seems a better choice that this isolated thread not know or care whether or not there's already a handler, it just wants to add a handler on top
13:00:17 <dmwit> sure
13:00:18 <Cale> hiptobecubic: Are they being matched against String user input somewhere?
13:00:25 <dmwit> If you want to cascade them, by all means do.
13:00:26 <mysticc> I have a datatype as data X = A something | B something | C [a] b ... I dont care about rest but when I sort like [C [7] x,C [4,1] y] it should sort on length of the list which is second argument of the constructor.. I dont want to define Ord instance for rest of the constructor as I am using deriving Ord //
13:00:34 <NemesisD> dmwit: i do but i don't know how, lol
13:00:43 <dmwit> Allocate an MVar and stick it in.
13:01:04 <dmwit> do { m <- newEmptyMVar; h <- installHandler (myNewHandler m); putMVar m h }
13:01:12 <dmwit> ...for example
13:01:20 <dmwit> It's possible that mfix will Just Work, too.
13:01:22 <dmwit> :t mfix
13:01:23 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
13:01:33 <fmap> lambdalover: function clauses match from top to bottom, so `area _ _ ' for example matches all calls to area
13:01:40 <dmwit> :t mfix (\oldhandler -> installHandler (myNewHandler oldhandler)}
13:01:41 <lambdabot> parse error on input `}'
13:01:45 <dmwit> :t mfix (\oldhandler -> installHandler (myNewHandler oldhandler))
13:01:46 <lambdabot> Not in scope: `installHandler'
13:01:46 <lambdabot> Not in scope: `myNewHandler'
13:01:52 <dmwit> of course =P
13:01:58 <lambdalover> fmap: good catch
13:02:05 <NemesisD> dmwit: could I do something like: do oldHandler <- installHandler sigINT newHandler; installHandler sigINT oldHandler
13:02:14 <Cale> mysticc: Use sortBy, possibly along with comparing
13:02:22 <dmwit> NemesisD: That surely wouldn't work.
13:02:24 <lambdalover> http://ideone.com/FJiPO hmm :( still the same error
13:02:37 <Cale> > sortBy (comparing length) (words "here is a bunch of words to sort only by length")
13:02:38 <lambdabot>   ["a","is","of","to","by","here","sort","only","bunch","words","length"]
13:02:58 <Cale> > sortBy (comparing length `mappend` compare) (words "here is a bunch of words to sort by length and then alphabetically")
13:02:59 <lambdabot>   ["a","by","is","of","to","and","here","sort","then","bunch","words","length...
13:03:09 <mysticc> Cale: Oh I totally forgot sortBy ..thanks.
13:03:34 <hiptobecubic> Cale, both. it's interactive
13:04:13 <Cale> hiptobecubic: So that's perhaps why? I suppose you could always have a better separation of the parser -> abstract syntax -> interpretation
13:04:26 <dmwit> NemesisD: mfix (\h -> installHandler sigINT (Catch (myHandler h)) Nothing) -- and then write myHandler to have an argument h that is the old handler
13:06:20 <clahey> I hated doing instance Ord Modulo, since they aren't really comparable, but it's necessary for maps and sets.
13:06:37 <NemesisD> dmwit: so i should case off of the old Handler? data Handler = Default | Ignore | Catch (IO ()) | CatchOnce (IO ()), so what do i do in the case of default?
13:07:02 <NemesisD> dmwit: it seems almost like the Posix.Signals module needs a function that calls a handler
13:07:20 * hackagebot simple-log 0.1.2 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.1.2 (AlexandrRuchkin)
13:07:22 * hackagebot Octree 0.2.3 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.2.3 (MichalGajda)
13:07:53 <clahey> powers a = 1 : (map (* a) (powers a))
13:07:55 <clahey> What a language.
13:08:10 <mightybyte> Is there anything like a "thunk explorer" that can traverse any given data structure and figure out what if any parts exist as unevaluated thunks?  It seems like this kind of capability would be a huge help debugging space and performance issues in complex codebases.
13:08:24 <Cale> powers a = iterate (*a) 1
13:08:34 <dmwit> NemesisD: Personally, I would just say "throw it away" if it's Default or Ignore.
13:08:57 <rwbarton> mightybyte: yes, e.g. vacuum, vacuum-cairo
13:08:58 <lambdalover> does Haskell have optional curly braces?
13:09:01 <NemesisD> dmwit: should that exit the program?
13:09:10 <Nereid> > iterate (*2) 1
13:09:10 <dmwit> NemesisD: What is "that"?
13:09:11 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
13:09:18 <NemesisD> dmwit: sorry, throwing it away
13:09:26 <Cale> mightybyte: there's http://hackage.haskell.org/package/vacuum
13:09:29 <mightybyte> rwbarton: Awesome.  Headed there next
13:09:31 <clahey> iterate.  Cool.
13:09:32 <dmwit> NemesisD: No.
13:09:42 <NemesisD> myHandler Default = return () or myHandler Default = exit 1
13:09:53 <rwbarton> I think I saw something about a newer similar tool but I don't remember any details
13:10:03 <dmwit> myHandler Default = {- do your communication, then exit -}
13:10:14 <dmwit> myHandler (Catch f) = {- do your communication, then f, then exit -}
13:10:26 <dmwit> or whatever you want
13:10:29 <dmwit> You're in charge.
13:10:46 <thoughtpolice> vacuum is a bit better for showing you the indirections and sharing properties, although it could pretty easily do things like colourize nodes or make it easier to count the amount of machine words backing a data structure
13:11:04 <thoughtpolice> (i'm the current maintainer but haven't had as much time to give it love as i'd like. i'd really just eventually like it to become one with GHC)
13:11:17 <thoughtpolice> er, colourize/indicate which nodes are thunks, etc
13:11:26 <dmwit> NemesisD: Okay, I've got to run now. Good luck.
13:11:37 <NemesisD> dmwit: thanks!
13:11:54 <thoughtpolice> joachim has ghc-heap-view, which is a similar package and a bit lower level. it may be more appropriate for this kind of thing
13:23:14 <NemesisD> anyone know why exitSuccess and exitFailure  in another thread would dump "exitFailure 1" to the console? i'd like to suppress that
13:24:09 <Botje> I'd think exit() is per-process :)
13:26:22 <merijn> If I want to read from multiple MVars/Chan's and return the first succesfull read I guess I should be using STM?
13:26:36 <benmachine> NemesisD: that's the default exception handler, I believe those functions work by throwing an exception
13:27:07 <benmachine> NemesisD: catch the exception yourself and throw it to the main thread or something similar
13:27:16 <Cale> merijn: That'll probably make life a whole bunch easire for you
13:27:18 <Cale> easier*
13:27:51 <benmachine> NemesisD: http://hackage.haskell.org/package/async this package can make that stuff easier
13:27:52 <clahey> I could totally have done that homework in like 10 minutes if I hadn't bothered to make a special class.
13:27:55 <merijn> Cale: How much overhead should I expect from using STM? Not much?
13:27:58 <clahey> But oh what I wouldn't have learned.  :)
13:28:09 <Cale> merijn: Well, a little
13:30:30 <benmachine> merijn: I think it depends on things like, how many writers there are, how many readers there are
13:30:34 <benmachine> what sorts of conflicts are likely
13:31:20 <merijn> benmachine: In this case multiple writer, single reader
13:31:45 <benmachine> merijn: I don't actually know the details
13:31:50 <merijn> Or rather, single writer per stream, multiple streams being written by the same reader
13:31:53 <benmachine> just that the answer isn't super simple
13:31:57 <merijn> s/written/read
13:32:01 <NemesisD> anyone know of a good way to figure out what sort of exception is being thrown so i can write a handler for it?
13:32:06 <NemesisD> its just rendering a string to the console
13:32:21 <benmachine> NemesisD: a SomeException handler will catch anything
13:32:46 <NemesisD> benmachine: i'm trying to catch a specific exception but i don't know what to match against just for that case
13:32:54 <NemesisD> its the case where a file doesn't exists when opening a unix domain socket
13:33:13 <benmachine> NemesisD: hmm. I think there's a way to use a SomeException handler to find out
13:33:14 <merijn> benmachine: Well, I'd like to avoid the overhead of STM, but since there's no "poll :: [Chan a] -> IO a" I have no clue how I'd build my own poll...
13:33:17 * benmachine investigates
13:33:34 <benmachine> merijn: are you really worried about overhead?
13:33:34 <merijn> (except through STM)
13:33:38 <Cale> merijn: Fork a thread for each Chan
13:34:00 <benmachine> merijn: if you don't know what the overhead is, my advice is don't worry about it :P
13:34:27 <Cale> merijn: Then have the threads all try to read from their respective Chan and write to a shared MVar
13:34:28 <merijn> Cale: That doesn't solve the problem at all. I need to merge multiple Chan's, so adding an extra thread per chan changes nothing
13:34:54 <benmachine> merijn: sure it does
13:34:59 <benmachine> merijn: you have an "output chan"
13:35:11 * merijn thinks STM would probably be less overhead than having everything contend for the same MVar :p
13:35:11 <benmachine> every thread reads from a different input chan and writes to the output chan
13:35:13 <Cale> (or, yeah, that's better -- write to a Chan)
13:35:30 <benmachine> but yeah, I'd say use STM
13:35:37 <merijn> benmachine: That's my current implementation, but that doesn't allow you to selectively stop listening to one of the channels
13:36:17 <merijn> benmachine: Because once everything is in a shared channel you have no clue about origin unless you tag it explicitly (and even then you can't throttle the origin, which would happen with a BoundedChan implementation)
13:36:25 <merijn> But yeah, STM it is then :p
13:51:15 <nicoo> merijn: Wouldn't CAS be enough ?
14:00:28 <Ruun> Hio, does anyone know some interesting webblogs about haskell?
14:01:03 <atriq> Comonad.reader
14:01:10 <hiptobecubic> Ruun, neighborhood of infinity is also nice
14:02:45 <Ruun> looks interesting :-)
14:04:17 <hpc> http://blog.ezyang.com/
14:04:18 <blackh> Ruun, if you go onto Haskell Reddit you'll find links to lots of them. http://www.reddit.com/r/haskell
14:08:49 <Ruun> wuhu ... thx
14:15:03 <merijn> nicoo: CAS?
14:20:03 <o-O-o> why does haskell exist?
14:20:12 <atriq> ...
14:20:16 <atriq> That's an odd question
14:20:25 <atriq> Why does any programming language exist?
14:20:28 <simon_> because someone created it? :)
14:20:31 <atriq> Because somebody thought it would be a good idea
14:20:33 <o-O-o> how can I get a job coding in haskell?
14:20:40 <ahkurtz> haha
14:20:40 <simon_> apply for one? :)
14:20:41 <atriq> First, by learning Haskell.
14:20:48 <atriq> Then, by finding a job.
14:20:48 <o-O-o> yeah! but where are these jobs?
14:20:59 <atriq> haskellers.org, I think
14:21:01 <simon_> atriq, strictly speaking, I think it might be possible to get a Haskell job without knowing Haskell.
14:21:16 <ahkurtz> if you are in grad school?
14:21:17 <atriq> simon_, yeah, but that's not very nice, and you may not keep it for long
14:21:22 <MostAwesomeDude> I like how o-O-o follows the Adams rules for learning.
14:21:23 <companion_cube> o-O-o: Galois Inc. :p
14:21:24 <o-O-o> can I get a job at Microsoft, Facebook or Amazon?
14:21:32 <companion_cube> microsoft research, yes
14:21:33 <simon_> atriq, I got a C# job once without knowing C#, but I suppose that is quite different. ;-)
14:21:44 <companion_cube> (fyi o-O-o is a troll for ##c++)
14:21:45 <MostAwesomeDude> "What is haskell?" "Why does Haskell exist?" "Where can I get paid to use Haskell?"
14:22:05 <atriq> simon_, well, I'm still in high school. I want your luck for the future.
14:22:13 <atriq> Or skill.
14:22:15 <ownchood1> Anyone else having trouble installing cabal-install?
14:22:15 <atriq> Or charisma.
14:22:28 <atriq> ownchood1, you should have got it with the Haskell Platform?
14:22:48 <ownchood1> atriq: yes, but I should be able to 'cabal install cabal-install', and I can't.
14:23:05 <benmachine> ownchood1: what goes wrong?
14:23:10 <ownchood1> atriq: the install fails during subinstall of Distribution/Client/BuildReports/Upload.hs
14:23:16 <o-O-o> is haskell only for nerds?
14:23:17 <ownchood1> benmachine: ^^
14:23:26 <benmachine> ownchood1: please quote the exact message
14:23:41 <ownchood1> benmachine: It's a type error (just a sec...)
14:23:58 <ownchood1>  Couldn't match expected type `Maybe b' against inferred type `URI'
14:23:58 <ownchood1>     In the expression: relativeTo rel uri
14:23:58 <ownchood1>     In the expression:
14:23:58 <ownchood1>         do { rel <- parseRelativeReference location;
14:24:00 <ownchood1>              relativeTo rel uri }
14:24:03 <benmachine> o-O-o: I heard you can catch nerd from public bathrooms
14:24:04 <ownchood1> (sorry for pasting...)
14:24:11 <benmachine> ownchood1: hpaste.org :)
14:24:22 <benmachine> ownchood1: that's interesting. sounds like a bad dependency
14:24:29 <Clint> api change?
14:24:34 <benmachine> ownchood1: try with --constraint 'network < 2.4'
14:24:44 <ownchood1> benmachine: yes, and I saw the same problem when I tried to install another package (snap, maybe?)
14:24:52 <benmachine> yep
14:24:54 <blackh> o-O-o: You're from #c++ and you're asking if Haskell is for nerds?
14:24:59 <benmachine> people not putting proper upper bounds on their deps :)
14:25:03 <gabor> any suggestions for a "software-backplane", i.e. a bus for interprocess communication with structured data between named endpoints (looking for a haskell-friendly technology)
14:25:11 <benmachine> blackh: Haskell is way nerdier than C++
14:25:15 <o-O-o> blackh: C++ is for nerds that want to get a good salary
14:25:16 <benmachine> blackh: it's one of its better features :)
14:25:40 <blackh> o-O-o: Spoken like a true slave. :)
14:25:52 <o-O-o> money slave? yes! I am
14:26:06 <Quantumplation> using Data.Sequence, how would I split the first element off of the sequence? :< operator gives me a ViewL and i'm not sure what to do with it
14:26:17 <o-O-o> other options are robbing or living in the woods... so I prefer being a money slave
14:26:53 <benmachine> Quantumplation: viewl
14:27:08 <benmachine> Quantumplation: pattern match on the result of "viewl seq"
14:27:13 <blackh> o-O-o: Haven't you got money to go and earn?
14:27:19 <benmachine> o-O-o: have you considered robbing in the woods?
14:27:22 <Quantumplation> oo, k
14:27:50 <o-O-o> benmachine: yup. but the hillibillies are mean and dangerous
14:27:56 <ownchood1> So, benmachine, how did you know to impose that constraint (network < 2.4)?
14:28:34 <blackh> o-O-o: C++ is turning into a sort of bloated form of Haskell.
14:28:49 * blackh will stop now and do some work
14:28:52 <benmachine> ownchood1: honestly, luck; I happen to follow the development of the network package
14:29:04 <benmachine> ownchood1: there'd be ways I could work it out if I didn't, but this one was easy
14:29:19 <Quantumplation> benmachine: ((viewl h) :< rest) = sequence?
14:29:34 <benmachine> Quantumplation: h :< rest = viewl sequence
14:29:45 <ownchood1> benmachine: this is yet another way in which Haskell is off-putting to newcomers (and I'm not exactly a newcomer).
14:29:52 <benmachine> Quantumplation: except, you shoudl really do a case statement, to handle the empty case
14:30:02 <benmachine> ownchood1: I know, we have dependency problems
14:30:17 <benmachine> ownchood1: we tried putting strict upper bounds on everything for a while but then things just break in a different way
14:30:37 <benmachine> ownchood1: it's a byproduct of the development of Haskell progressing rapidly and mostly unregulatedly
14:30:49 <benmachine> ownchood1: coupled with the fact that Haskell libraries have very low interface stability
14:31:02 <ownchood1> benmachine: this is really embarrassing to the community.  Yes, perhaps what's needed is less bazaar and more cathedral.
14:31:15 <benmachine> ownchood1: we don't really have the staff for a cathedral, unfortunately
14:31:22 <ownchood1> benmachine: I've had to stop using cabal and now typicaly use cabal-dev instead.
14:31:27 <benmachine> it's hard to know what that would even mean
14:31:40 <Quantumplation> so if i'm in a where clause, rotate (EmptyL :< null) = null; rotate (h :< rest) = rest |> h
14:31:43 <Quantumplation> that would work?
14:31:44 <rwbarton> isn't the haskell platform a sort of cathedral
14:32:06 <benmachine> Quantumplation: no, that argument is of type ViewL, right?
14:32:16 <benmachine> Quantumplation: so, EmptyL :< null -- what is this supposed to mean?
14:32:25 <benmachine> rwbarton: yeah, the HP is a step in the right direction
14:32:34 <benmachine> rwbarton: unfortunately people keep innovating all over the place >:[
14:32:42 <benmachine> it's really quite untidy
14:32:42 <Quantumplation> ah, i could just do rotate null, couldn't I?
14:33:07 <rwbarton> does the HP not include cabal-install?
14:33:11 <benmachine> Quantumplation: ...I'm not sure how your thoughts are going here, exactly
14:33:19 <Quantumplation> er. the empty sequence is empty, not null >_>
14:33:21 <Quantumplation> woops
14:33:28 <benmachine> rwbarton: it does, but maybe you want to update it
14:33:35 <rwbarton> oh i see
14:33:37 <benmachine> Quantumplation: "empty" is not a pattern, though
14:33:50 <int-e> benmachine: it can be generalized - one idea would be a sub-hackage: a subset of selected versions of related hackage packages that are known to work together.
14:34:12 <benmachine> int-e: yeah. we're struggling to get Hackage 2.0 off the ground at the moment, though :)
14:34:17 <rwbarton> well basically HP is like debian stable and hackage is like ... I dunno, gentoo
14:34:20 <rwbarton> pick your poison :)
14:34:30 <Quantumplation> return {empty sequence} = {empty sequence}; return {pattern match to split the head off} = {attach head to the end}
14:34:40 <Quantumplation> so return :: Seq a -> Seq a
14:34:50 <benmachine> Quantumplation: the thing is you can't pattern match on sequences directly
14:34:52 <int-e> benmachine: I know. I'm just throwing an idea here, right now the situation is not painful enough to me personally to do anything about it.
14:35:07 <benmachine> Quantumplation: you use the 'viewl' function and it turns it into a different type, which you *can* pattern match on
14:35:18 <Quantumplation> ahh
14:35:26 <Quantumplation> sorry that took me so long to get
14:35:26 <benmachine> Quantumplation: I'd start with rotate seq = case viewl seq of ...
14:35:42 <benmachine> Quantumplation: you need a case for EmptyL and for h :< seq
14:35:43 <latro`a> cept not seq
14:35:47 <latro`a> because that name's taken
14:35:47 <latro`a> :p
14:35:57 <benmachine> latro`a: true. I can shadow it harmlessly
14:36:05 <benmachine> but you're right that that's confusing
14:36:44 <benmachine> rotate sq = case viewl sq of EmptyL -> empty; h :< t -> t |> h
14:36:48 <Quantumplation> yay, thanks :)
14:36:50 <benmachine> tada.
14:38:40 <o-O-o> this is crap
14:41:54 <mcstar> crap indeed
14:42:19 <mcstar> i cant draw anything on the screen with sdl + drawingcombinators
14:42:24 <applicative> unusually sublime crap, I'd think
14:44:21 <EvanR> is there a formatter for nominal diff times?
14:44:29 <EvanR> the show instances just reports number of seconds
14:44:32 <EvanR> with an s
14:48:42 <benmachine> EvanR: toRational and then do whatever you want with it?
14:49:15 <EvanR> of course
14:49:44 <EvanR> you can do that without converting to rational
14:50:03 <EvanR> but was wondering if there was a formatter like the one for universal time
14:51:58 <applicative> mcstar does graphics drawingcombinators use sdl?
14:52:21 <mcstar> not excusively
14:52:23 <mcstar> it can
14:52:33 <benmachine> EvanR: doesn't seem to be an instance of FormatTime, so I think you're on your own
14:52:34 <mcstar> as well as plain opengl, or glfw
14:53:27 <applicative> I see it used to require sdl
14:54:16 <ParahSa1lin> whats ProtocolNumber in Network.Socket
14:54:52 <applicative> type ProtocolNumber = Foreign.C.Types.CInt
14:55:00 <benmachine> ParahSa1lin: umm, usually you fill it in with defaultProtocol I think
14:55:26 <applicative> i.e.  0
14:55:57 <larskinn1> hi, does anybody know if unordered-containers has profiling libraries, and if so, where to get them for Windows?
14:56:52 <applicative> larskinn: you mean you want to build it with profiling libraries, or something else
14:56:53 <ivanm> @remember edwardk i want to be able to know if the compiler is being stupid or if its just me, and without any sort of model to reason about it with, i always have to assume it could be the compiler; i already have to deal with that problem, its called 'scala'
14:56:53 <lambdabot> It is forever etched in my memory.
14:57:38 <jfischoff> I'm finding that vim with haskellmode and mod-ghc to be very unstable. Is that normal?
14:58:02 <larskinn> applicative: I'm trying to build a program that uses unordered-containers, to try and find out why I'm running out of stack space
14:58:38 <larskinn> applicative: insert "with profiling" before comma :)
14:59:04 <applicative> you need to install unordered containers with profiling
14:59:04 <benmachine> larskinn: did you get it with cabal-install?
14:59:17 <larskinn> benmachine: yes
14:59:20 <applicative> larskinn: to do this you will need to uninstall a couple fo things
14:59:25 <benmachine> larskinn: just reinstall with -p, then
14:59:35 <benmachine> cabal install --reinstall -p unordered-containers
14:59:39 <larskinn> benmachine: aha! the more you know.
14:59:40 <applicative> benmachine: it will fail because of hashable
14:59:46 <benmachine> applicative: hmm
14:59:51 <ivanm> and set it in ~/.cabal/config to default to profiling libraries
15:00:08 <ivanm> cabal install --reinstall world ?
15:00:12 <benmachine> ivanm: you know, I've been wondering lately how much mileage I really get out of my tripled install times
15:00:15 <applicative> larskinn: like ivanm says
15:00:21 <ivanm> benmachine: LLVM as well?
15:00:25 <benmachine> ivanm: no, dynamic
15:00:29 <ivanm> ahhh
15:00:31 <benmachine> ivanm: I can do llvm? :O
15:00:35 <ivanm> I don't bother with that
15:00:47 <benmachine> I think
15:00:51 <applicative> larskinn: you cant profile unless all the libs before are installedd with -p
15:00:55 <benmachine> I will leave it on so I remember to test it for my own libraries
15:01:04 <benmachine> I've had a library fail only the dynamic compile before
15:01:26 <ivanm> oh? which one?
15:01:37 <larskinn> applicative, ivanm: okay, I'll try that
15:01:50 <benmachine> ivanm: it was some Template Haskell magic, I think
15:01:57 <benmachine> it was only with 6.12.3
15:02:00 <ivanm> *nod*
15:02:06 <applicative> base and deepseq will have come with the Haskell Platform, with profiliing libs, so it looks like you should ghc-pkg unregister hashable then reinstall all with -p or the like
15:02:39 <benmachine> applicative: why unregister hashable?
15:02:46 <applicative> it
15:02:54 <applicative> is installed without -p
15:02:58 <benmachine> applicative: so?
15:03:13 <benmachine> you install profiling libraries in addition to non-profiling ones
15:03:17 <ivanm> benmachine: that would force re-compilation
15:03:21 <applicative> its a dependency of  unordered containers
15:03:22 <ivanm> rather than doing it explicitly
15:03:36 <applicative> there will just be chaos
15:03:45 <benmachine> applicative: man, you're pessimistic :P
15:03:46 <benmachine> but ok
15:04:10 <applicative> wait, of course you install both if you cabal install with -p
15:04:50 <applicative> but cabal install b -p will complain if the dependency a was installed with out profiling
15:05:08 <applicative> or am I generalizing from some few caseas
15:05:12 <benmachine> applicative: I don't remember
15:05:21 <benmachine> I turned on profiling in my cabal config several major versions ago
15:05:25 <benmachine> it's a long time since I've worried about this :P
15:05:45 <applicative> same here. it's a bit of a pain....
15:05:56 <applicative> given I only use it for a few things
15:05:57 <larskinn> hehe, it's actually the first time I've tried compiling Haskell
15:06:21 <applicative> oh good work larskin
15:06:44 <applicative> does ghc A.hs now have a sensible default for optimization?
15:07:02 <benmachine> applicative: depends what you think is sensible :)
15:07:13 <benmachine> -O isn't default
15:07:30 <applicative> its O1 or something
15:07:44 <benmachine> by default I believe optimisation is disabled
15:07:50 <benmachine> in my .cabal/config it's enabled
15:07:52 <applicative> I was just going to tell larskinn to remember an optimization flag
15:08:08 <applicative> larskinn: my fingers always type ghc --make -O2 A.hs
15:08:19 <applicative> but I don't  think its all necessary now
15:08:52 <benmachine> --make is default these days
15:08:54 <applicative> whenever you compile without optimizations someone in ghc hq sheds a tear.
15:09:01 <benmachine> that's not true :P
15:09:15 <benmachine> there's nothing wrong with not optimising except when you need it
15:09:58 <larskinn> already using -O2, so no tears need shedding :)
15:10:01 <applicative> benmachine: I knew about --make but there was a fight about optimization, I thought it was decided to use cabal's default, but I cant remember
15:10:16 <hpc> cabal doesn't decide either
15:10:19 <applicative> larskinn: ah good.
15:10:25 <hpc> you give it a ghc-options: -O2 line
15:10:36 <applicative> hpc?  I thought it used 01 by default.
15:10:39 <benmachine> hpc: there's an optimization: True setting
15:10:39 <applicative> or something
15:10:50 <benmachine> I think that gives you -O
15:10:57 <benmachine> and yes, I believe it is default
15:11:36 <applicative> oh how bad is -O
15:11:40 <applicative> or how good?
15:11:41 <hpc> benmachine: neat; i couldn't find a good list of cabal's options and so i just wing it based on what other packages do
15:11:56 <larskinn> ah, curse you Windows and your Application Data folder
15:11:58 <jaj> hpc: just fuzz it ;)
15:12:04 <benmachine> applicative: well, if you use ghc-options: -O2, then cabal check whines at you
15:12:22 <applicative> hm
15:12:37 <benmachine> "* 'ghc-options: -O2' is rarely needed. Check that it is giving a real benefit
15:12:37 <benmachine> and not just imposing longer compile times on your users.
15:12:49 <benmachine> "
15:12:52 <applicative> you can specify in the .cabal file of course.
15:12:55 <benmachine> yes
15:13:21 <applicative> yes they're agaisnt -O2
15:13:38 <larskinn> okay, I don't seem to have a .cabal/config file
15:13:55 <applicative> larskinn: you have a .cabal directory though
15:14:20 <applicative> oh wait, it doesn't have a dot in windows, is that it?
15:14:30 <larskinn> applicative: no ~/.cabal/ and no ~/Application Data/cabal/
15:14:34 <benmachine> larskinn: cabal --help will tell you where your config file is
15:14:53 <applicative> ah yes
15:15:15 <larskinn> benmachine: thanks! was ~/AppData/Roaming/Cabal/config
15:15:22 <benmachine> :)
15:16:07 <acowley> I get a GHC panic if I try to compile, "data Foo = Foo (!Int,!Int)"
15:16:12 <acowley> can anyone confirm that?
15:16:44 <benmachine> acowley: confirmed, 7.6.1
15:16:52 <bgamari> What are the reasons a thread would yield (short of an explicit yield call, of course)?
15:16:53 <acowley> okay, I'll file a report
15:16:57 <acowley> benmachine: thanks
15:17:03 <benmachine> acowley: interestingly, no panic on 7.4.2
15:17:25 <geekosaur> 7.4.1 gives me an error but no panic ("unexpected strictness annotation")
15:17:36 <maukd> bgamari: doing I/O, allocating memory
15:17:45 <Polarina> What version of cabal does ghc-7.6 have?
15:17:46 <larskinn> do I need both "library-profiling" and "executable-profiling"?
15:18:05 <benmachine> Polarina: Cabal-1.16.0
15:18:09 <benmachine> Polarina: by default
15:18:21 <benmachine> Polarina: I... think. I remember there being some faff about the precise version
15:18:26 <benmachine> but don't recall what exactly
15:18:31 <Polarina> benmachine, thanks. I'm trying to find a cabal-install binary for ghc-7.6 on windows.
15:19:29 <applicative> larskinn  I only use library profiling. If you build something and executable yourself you can build it with -p but maybe I'm missing somethign
15:19:42 <applicative> if you build an executable yourself
15:20:11 <bgamari> maukd, I seem to be seeing lots of yields in fairly pure code (every 150us?)
15:20:38 <Polarina> benmachine, http://hackage.haskell.org/package/cabal-install only has 1.14.. :/
15:20:41 <applicative> Polarina doesnt ghc come with binary?
15:20:53 <thoughtpolice> bgamari: all allocations are yield points, technically speaking
15:20:55 <benmachine> Polarina: wait, did you mean cabal-install?
15:20:58 <Polarina> applicative, apparently not.
15:21:12 <bgamari> thoughtpolice, Alright, that's good to know
15:21:12 <Polarina> benmachine, yes, I need cabal to install packages.
15:21:20 <benmachine> Polarina: atm I'm using version 0.14 of cabal-install, compiled with version 1.14.0
15:21:23 <thoughtpolice> bgamari: so the fact you see them isn't surprising, but i'd be surprised if they were taking up a big part of the runtime
15:21:32 <benmachine> Polarina: if you say cabal I assume you mean Cabal-the-library :)
15:21:33 <Polarina> benmachine, with 7.6?
15:21:39 <applicative> Polarina do you still have your old cabal?
15:21:45 <thoughtpolice> (i mean i'm only postulating if you have a problem :) maybe you were just curious)
15:21:48 <benmachine> Polarina: I probably didn't compile it with 7.6
15:21:52 <applicative> Polarina: you can use the old executable cabal-install
15:22:04 <Polarina> applicative, I don't. It's 32-bit and I installed 64-bit ghc.
15:22:39 <bgamari> thoughtpolice, The thread only stays inactive for a few us
15:22:41 <applicative> Polarina: you mean the one from ghc hq
15:22:44 <benmachine> Polarina: ok but you may be able to use old cabal to compile with new GHC
15:22:55 <Polarina> applicative, yes.
15:22:59 <benmachine> Polarina: as in, you don't need the GHC you compiled cabal with to match the one it uses necessarily
15:22:59 <bgamari> I also seem to see a lot of thread stops due to stack overflow
15:23:12 <bgamari> I'm assuming this is when the RTS is allocating more memory for the stack?
15:23:16 <larskinn> applicative: you were right, had to unregister hashable then reinstall
15:23:18 <applicative> I am using an old cabal built with 64 bit to compile 32 bit ghc-7.6 and 64bit ghc7.4
15:23:47 * Polarina finds this confusing.
15:24:12 <thoughtpolice> bgamari: yea, i imagine it wouldn't be frozen long. the reason allocations are safe points BTW is because you generally are allocating all the time, so it's a good tradeoff in terms of speed/binary size impact (you could really place safepoints everywhere, but that would have negative effects.) RE stack growing, yes. the RTS basically allocates a threads' stack in a chunk, and it doubles it's size whenever the chunk needs to enlarge
15:24:14 <applicative> Polarina is cabal.exe still there?
15:24:18 <thoughtpolice> IIRC
15:24:25 <Polarina> applicative, it is not.
15:24:30 <bgamari> thoughtpolice, Alright
15:24:33 <applicative> damn
15:25:29 <applicative> Polarina: its insane but I wonder if you should reinstall the Platform to get it, then delete it somehow preserving cabal ? THis does seem odd...
15:25:43 <applicative> maybe theres a dev version of cabal-install?
15:25:57 <Polarina> I seem I need a cabal-install that goes with Cabal-1.16, cabal-install-1.14 (the latest version) needs <1.15.
15:26:17 <thoughtpolice> bgamari: what are you looking at if i may ask? i remember you asking stuff earlier but was at work so couldn't answer. JaffaCake may be the person to talk to really based on what you said earlier
15:26:32 <thoughtpolice> (something like GC spikes to > 80% runtime with 4 threads?)
15:26:38 <dysoco> Hey, I'm just learning haskell and I'm learning about Guards, can anyone tell me why this would be bad ? http://pastebin.com/7u6aaT8S
15:26:40 <maukd> The paste 7u6aaT8S has been copied to http://hpaste.org/75325
15:26:44 <bgamari> thoughtpolice, I'm looking at Gibbs sampling framework
15:26:49 <bgamari> thoughtpolice, Yes, exactly
15:27:06 <applicative> Polarina: hah, the dev version requires Cabal -17 ...
15:27:20 <latro`a> dysoco--it's expecting young and old to be Bools, but they are lists
15:27:21 <bgamari> thoughtpolice, Most of this program used to be in IO
15:27:26 <applicative> https://github.com/haskell/cabal/blob/master/cabal-install/cabal-install.cabal
15:27:30 <latro`a> you probably want young = age `elem` [1..18]
15:27:31 <Polarina> applicative, that's odd, I see that the one in darcs requires Cabal    >= 1.15.0   && < 1.16,
15:27:38 <latro`a> old = age `elem` [60..120]
15:27:47 <bgamari> thoughtpolice, Since I need to share state between multiple sampler threads, I put nearly everything in IORefs
15:27:53 <bgamari> thoughtpolice, It was awful
15:27:58 <applicative> seems ghc-7.6 is ruled out one way or another...
15:28:09 <latro`a> or better, young = age <= 18, old = age >= 60
15:28:13 <EvanR> dont share IORefs among thread
15:28:14 <EvanR> s
15:28:23 <bgamari> EvanR, It was a bad idea
15:28:30 <benmachine> EvanR: you /can/ do
15:28:32 <bgamari> it wasn't even that fast, but it did scale nicely
15:28:32 <larskinn> so, in the profiler output most of the heap is filled with "[]". does that actually mean the empty list, or just a list type?
15:28:36 <benmachine> atomicModifyIORef, and all that
15:28:39 <dysoco> latro`a, I tried something like that but didn't worked, I see why now, thanks!
15:28:50 <applicative> Polarina: if you reinstall the Platform, your old cabal-install will be fine, it's ridiculously indirect to then uninstall all but it...
15:28:54 <thoughtpolice> well, you can share IORefs, but there are some catches. you should always use atomicModifyIO ref to touch it, and also you want to make sure the main thread isn't the one talking
15:29:00 <bgamari> thoughtpolice, Anyways, now I have a pure-r implementation, but it effectively doesn't scale at all
15:29:09 <thoughtpolice> there are a lot of performance implications when you talk back to the main thread
15:29:17 <bgamari> thoughtpolice, I'm sharing state through MVar
15:29:23 <bgamari> thoughtpolice, There is not talk-back
15:29:45 <benmachine> Polarina: are you aware that cabal-install is no longer held in darcs?
15:29:49 <thoughtpolice> bgamari: is this 7.6.1 btw? JaffaCake fixed a massive regression that appeared there this weekend that was causing a lot of fragmentation and performance problems
15:29:49 <benmachine> Polarina: it moved to github
15:29:50 <bgamari> thoughtpolice, The threads are all doing computation; when one finishes, it takes the state from the MVar, updates it, and puts it back
15:29:56 <Polarina> benmachine, I was not aware of that.
15:29:59 <thoughtpolice> bgamari: ah yeah, that should be fine
15:30:05 <dysoco> old = age >= 60 throws an error: "parse error on input `='"
15:30:10 <benmachine> Polarina: https://github.com/haskell/cabal
15:30:18 <bgamari> thoughtpolice, The computation is long-lived enough that there shouldn't be much contention for the MVar
15:30:24 <bgamari> thoughtpolice, Yes actually
15:30:31 <bgamari> thoughtpolice, I guess master is the solution to this?
15:30:46 <latro`a> uh
15:30:49 <thoughtpolice> bgamari: ok, I would suggest trying HEAD if possible them. i couldn't tell you if it is your exact problem, but i just remember it because it was so recent :)
15:31:05 <benmachine> I really wish more people would be explicit about what they try to support
15:31:09 <thoughtpolice> bgamari: if you look at the glasgow-haskell-users archive from last week, you can see a post by John Lato describing the problem, and Simon's response
15:31:19 <benmachine> cabal-install.cabal has code in it to support base-2.0 and ghc 6.8
15:31:26 <benmachine> I wonder if they actually test that stuff
15:31:26 <bgamari> I have an event log if anyone might find that interesting
15:31:35 <bgamari> I frankly don't know what it's trying to tell me
15:31:41 <bgamari> I also have code
15:31:45 <hpaste> latro`a pasted “dysoco” at http://hpaste.org/75326
15:32:29 <hpaste> latro`a annotated “dysoco” with “dysoco (annotation)” at http://hpaste.org/75326#a75327
15:32:52 <thoughtpolice> bgamari: IIRC, the problem was basically that the GC was allocating and pinning a lot of memory (e.g. ByteStrings are pinned memory underneath) and then when it needed to traverse the nurseries for all the pointers, it traversed too eagerly basically, and caused lots of thrashing/negative performance impact. it's a place where a few extra cycles can add up quickly, of course :)
15:32:54 <Polarina> benmachine, would compiling this work?: https://github.com/haskell/cabal/tree/cabal-1.16
15:33:06 <benmachine> Polarina: I dunno
15:33:11 <benmachine> maybe?
15:33:12 <bgamari> thoughtpolice, Yeah, I don''t believe I'm using any pinned memory
15:33:36 <Polarina> benmachine, I'll try it then. Thanks.
15:34:00 <thoughtpolice> bgamari: hm, may be worth checking HEAD anyway. if not i'd suggest talking to JaffaCake in #ghc and/or filing a bug. simons are always overhauling stuff so regressions happen :)
15:34:06 <bgamari> thoughtpolice, Definitely
15:34:26 <bgamari> thoughtpolice, I'll see if Jaffa can help
15:37:17 <thoughtpolice> bgamari: he's in cambridge btw. i don't know what your timezone is, but for me he shows up in the wee early hours of the morning. just leaving a @tell or something works fine, fwiw
15:37:28 <thoughtpolice> or posting to the mailing list
15:39:55 <bgamari> thoughtpolice, Thanks!
15:40:52 * benmachine is going to be in Cambridge as of this weekend
15:46:54 --- mode: sturgeon.freenode.net set +o ChanServ
15:59:35 <Polarina> benmachine, I compiled cabal-install and all its dependencies manually (with Setup.hs) and now all I get is "cabal: Command.optionToFieldDescr: feature not implemented" when I do cabal anything.
15:59:57 <benmachine> Polarina: :(
16:04:17 <Polarina> benmachine, it fixes if I remove cabal's config file. Cabal then makes a new one and subsequent commands cease to function.
16:04:48 <benmachine> Polarina: hmm. try blanking the file instead of deleting it
16:05:26 <Polarina> "Warning: No remote package servers have been specified. Usually you would have one specified in the config file."
16:06:36 <arthulia> Can someone help me understand this type: func1 :: (Float -> Float) -> Float
16:06:43 <Cale> arthulia: sure
16:06:45 <arthulia> I'm completely new to Haskell
16:06:53 <arthulia> trying to figure out how to write a function that uses that type
16:07:01 <ivanm> arthulia: where did you get that type from?
16:07:14 <arthulia> First homework assignment
16:07:15 <Cale> arthulia: That says that func1 is a function whose first parameter is a function which takes a Float and produces a Float
16:07:16 <applicative> ivanm sounds suspicious
16:07:22 <Cale> and it returns a Float
16:07:38 <Cale> For example...
16:07:43 * ivanm guesses then that it's from a partially applied function or is somehow supplied another Float
16:07:55 <benmachine> ivanm: you can just make them up!
16:08:08 <ivanm> benmachine: sensible ones?
16:08:13 <Polarina> benmachine, seems that the field "jobs: 8" was causing it. Commenting it and it seems to work now. Let's try compiling something now. :)
16:08:17 <Cale> > let func1 :: (Float -> Float) -> Float; func1 f = f 0 + f 1 + f 2 in func1 (\x -> x^2)
16:08:18 <lambdabot>   5.0
16:08:19 <applicative> @type \x -> x +  (1::Float)
16:08:20 <lambdabot> Float -> Float
16:08:27 <ivanm> @type flip ($) (3 :: Float)
16:08:27 <benmachine> ivanm: a sensible Float? no, you've lost me there
16:08:28 <lambdabot> forall b. (Float -> b) -> b
16:08:37 <ivanm> benmachine: a sensible function I mean
16:08:45 <benmachine> oh right
16:08:46 <benmachine> sure
16:08:52 <benmachine> depending on what you mean by sensible
16:09:15 <arthulia> whoa
16:09:20 <ivanm> unless you're doing something like what Cale did with explicit values, that type looks rather useless
16:09:44 <arthulia> We're just supposed to be learning types
16:09:48 <benmachine> ivanm: and why shouldn't you do what Cale did?
16:09:50 <applicative> arthulia: so your definition will look like this  ::  func1 f = ... f ...
16:09:54 <Cale> > let epsilon = 10**(-9); func1 f = (f epsilon - f 0) / epsilon in [func1 sin, func1 cos, func1 tan]
16:09:55 <lambdabot>   [1.0,0.0,1.0]
16:09:57 <benmachine> the world would be a better place if we were all more like Cale.
16:10:04 <Cale> ^^ computing derivatives at 0 :)
16:10:10 <Cale> (approximately)
16:10:14 <ivanm> benmachine: because when I first saw that type I was trying to work out "how the hell do you use that?!?" :)
16:10:17 <applicative> arthulia, anything you can think of doing with a Float -> Float function will likely do...:)
16:10:51 <arthulia> applicative: ghci gives me errors if I just try something like func1 x = x + 2.0
16:11:06 <Cale> arthulia: put 'let' before it
16:11:08 <applicative> arthulia: yes, with that signature?
16:11:21 <Cale> arthulia: or better yet, put it into a file and load that into ghci
16:11:29 <arthulia> Cale: that's what I've been doing
16:11:33 <applicative> > let func1 x = x + 2.0 in func1 1
16:11:33 <Cale> (and then use :r to reload when you update the file)
16:11:34 <lambdabot>   3.0
16:11:43 <arthulia> yup, I've been doing just that
16:11:49 <arthulia> ghci test.hs
16:11:53 <arthulia> or :l test.hs
16:11:56 <Cale> arthulia: If you gave the signature  func1 :: (Float -> Float) -> Float
16:12:02 <applicative> arthulia: the problem there is that the argument of func1 is a Float not a function
16:12:07 <Cale> arthulia: then ghc will check that the code you wrote matches that type
16:12:19 <Cale> x is a function
16:12:29 <Cale> but you're adding that function to 2.0 in your code
16:12:34 <applicative> it should be
16:13:17 <applicative> arthulia: don't add the function and the float 2.0
16:13:25 <applicative> that doesn't make sense
16:13:26 <Cale> and the result is supposed to be type Float according to the signature, but it has to be Float -> Float according to the code, because the arguments to (+) must have the same type
16:13:35 <applicative> but what can you do with the function and the float?
16:13:45 <arthulia> I'm pretty lost, my book doesn't arrive until tomorrow xD
16:13:49 <applicative> the float 2.0
16:14:06 <arthulia> I've been looking through some good web tuts like Learn You A Haskell but I still don't understand how this works
16:14:07 <Cale> arthulia: Do you know about derivatives (from Calculus)
16:14:11 <arthulia> no :(
16:14:15 <Cale> oh, okay
16:14:20 <Cale> in that case...
16:14:37 <Cale> Suppose we have any function (Float -> Float) at all
16:14:50 <Cale> say that function is called f
16:15:00 <Cale> then we could decide to compute f 1 - f 0, say
16:15:04 <Cale> right?
16:15:13 <Cale> and that would be a Float
16:15:23 <Cale> f 1 is a Float, and f 0 is a Float
16:15:32 <Cale> and then their difference is a Float too
16:15:32 <larskinn> *rant* argh, my A* search is running out of memory... need a better heuristic
16:15:35 <applicative> and 0 and 1 here are floats
16:15:42 <Cale> larskinn: are you using my package?
16:16:40 <larskinn> Cale: which package is that?
16:16:41 <Cale> larskinn: I haven't tested that implementation of A* extensively, but I understand it has a few happy users.
16:16:43 <Cale> astar
16:17:06 <applicative> arthulia: the problem of writing a (Float->Float) -> Float function is very simple, but it does involve a tiny conceptual step
16:17:14 <Cale> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html
16:17:42 <arthulia> I never had time to fit calc into my schedule
16:17:58 <choi> are there any people here who came to haskell from ruby?
16:18:09 <Cale> arthulia: I only asked because I could give a cooler example if you did know some Calculus, it's no big deal
16:18:09 <arthulia> I'm afraid I'm still lost :( Sorry if I seem dense, I'm not used to haskell syntax and my math is somewhat rusty
16:18:12 <applicative> arthulia: you want to begin on the left hand side   func1 f =
16:18:20 <larskinn> Cale: it's actually a homework assignment, so I had to implement it myself.
16:18:22 <applicative> where f is some Float to Float thing like (+1)
16:19:01 <applicative> arthulia: then we get to use f on the  right hand side. But we must use it in such a way as to get a float out of it.
16:19:03 <Cale> arthulia: So the way to write a function A -> B, in general, is to imagine that you have some value of type A, and (possibly) using that, construct a value of type B somehow.
16:19:24 <applicative> arthulia: but how could I  get a float with the help of a Float-> Float function?
16:19:56 <Cale> arthulia: So in order to write a function (Float -> Float) -> Float, we imagine that we have a function f :: Float -> Float, and from that, we somehow want to make a Float.
16:20:39 <larskinn> Cale: I should probably look through your implementation when I have the time, though :)
16:20:40 <Cale> and of course, we have values of type Float like 0 and 5 and pi
16:20:45 <Cale> larskinn: :)
16:21:24 <Cale> larskinn: I opened up wikipedia and translated the imperative code on the A* page directly
16:21:30 <applicative> arthulia: we want a float, and we have a function (f) that will give us a float if we give it a float
16:21:59 <Cale> (lol, though I don't know if it counts as "directly" once you use foldl')
16:22:28 <larskinn> Cale: hehe, did something similar... also looked at the description in Russel/Norvig
16:23:30 <applicative> arthulia: so whats the natural thing to do with our function f, whatever it is?
16:24:28 <Rotaerk> is "function" an inuendo
16:24:55 <larskinn> Cale: mine uses foldr though. currently trying to solve a linear checker-move problem.
16:25:33 <arthulia> applicative: I dunno what you mean by natural
16:25:38 <arthulia> return the same number? :P
16:25:56 <Cale> arthulia: well, if we have a function, almost the only thing we can do is apply it to things
16:26:10 <arthulia> right
16:26:10 <EvanR> nah you can compose it!
16:26:22 <Cale> Well, yes
16:26:34 <applicative> arthulia: and what can we apply a Float -> Float function to?
16:26:42 <EvanR> > typeOf 'a'
16:26:43 <lambdabot>   Char
16:26:48 <EvanR> > typeOf id
16:26:49 <arthulia> a float?
16:26:49 <lambdabot>   Ambiguous type variable `a' in the constraint:
16:26:50 <lambdabot>    `Data.Typeable.Typeable a...
16:26:53 <applicative> and what do we get when we do?
16:26:54 <Cale> arthulia: sure
16:26:57 <arthulia> another float
16:27:12 <EvanR> > typeOf sum
16:27:13 <applicative> yes, so how do we complete  func1 f = f ...
16:27:13 <lambdabot>   [Integer] -> Integer
16:27:27 <arthulia> I understand func :: Float -> Float, even Float -> Float -> Float, I think
16:27:30 <EvanR> heh, you can take the typeOf a function
16:27:30 <applicative> where f is some random Float to Float thing
16:27:32 <arthulia> I just don't understand what the ()s do
16:27:40 <Cale> arthulia: they're grouping
16:27:58 <Cale> arthulia: A function of type A -> B takes a parameter of type A, and produces a result of type B
16:27:59 <applicative> it means the argument isnt a float but a float to float function
16:28:06 <applicative> have you seen the map function arthulia
16:28:07 <Cale> in (Float -> Float) -> Float
16:28:14 <Cale> we have A = Float -> Float
16:28:17 <Cale> and B = Float
16:28:29 <applicative> > map  (+1) [1..10]
16:28:30 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:29:02 <lpvb> > (+1) <$> [1..10]
16:29:03 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:29:22 <lpvb> applicative: applicative
16:29:29 <Polarina> > [2..11]
16:29:30 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:29:34 <applicative> map can take a Float -> Float function and a list of Floats and give us a new list of floats
16:30:13 <Cale> .oO(fix)
16:30:15 <arthulia> okay so a function Float -> Float will work as an arg for (Float -> Float) -> Float
16:30:18 <arthulia> which then returns a float
16:30:25 <Cale> yes!
16:30:30 <applicative> yes
16:30:31 <arthulia> gotcha
16:31:14 <Cale> arthulia: And when you have  Float -> Float -> Float, the -> associates to the right, so what that means is Float -> (Float -> Float)
16:31:45 <Cale> arthulia: You're literally writing a function which takes a Float, and produces as its result another function which takes a second Float, and finally produces a Float
16:31:47 <applicative> arthulia: so that's easier to grasp, it takes two floats and gives you a third, like +
16:32:01 <DrSyzygy> :t ($2)
16:32:02 <lambdabot> forall a b. (Num a) => (a -> b) -> b
16:32:28 <Cale> @let add x y = x + y
16:32:29 <lambdabot>  Defined.
16:32:35 <DrSyzygy> :t ($ (2::Float))
16:32:36 <lambdabot> forall b. (Float -> b) -> b
16:32:37 <Cale> :t add
16:32:38 <lambdabot> forall a. (Num a) => a -> a -> a
16:32:44 <Cale> oh, actually, hrm
16:32:45 <johnw``> heya DrSyzygy
16:32:47 <Cale> @undefine
16:32:50 <DrSyzygy> hey
16:32:53 <lpvb> forall a. (Num a) => Dollar a
16:32:57 <Cale> @let add :: Float -> Float -> Float; add x y = x + y
16:32:57 <johnw``> I was reading your chat log explaining category theory in Haskell
16:32:58 <lambdabot>  Defined.
16:33:00 <johnw``> very good stuff
16:33:01 <Cale> :t add
16:33:02 <lambdabot> Float -> Float -> Float
16:33:09 <johnw``> so thank you for taking the time with that
16:33:12 <Cale> :t add 5
16:33:13 <lambdabot> Float -> Float
16:33:14 <DrSyzygy> johnw``: *snrk*
16:33:20 <DrSyzygy> johnw``: That thing is getting feet, is it?
16:33:24 <Cale> :t add 5 10
16:33:25 <lambdabot> Float
16:33:26 <Shou> :t fix
16:33:27 <lambdabot> forall a. (a -> a) -> a
16:33:34 <DrSyzygy> johnw: You know I have an entire sequence of lecture notes up on the Haskell wiki, right?
16:33:36 <johnw> yeah, well, it's rare to see mathematicians bring it down to a lower level like that
16:33:42 <johnw> no!
16:33:45 <johnw> where at?
16:34:06 <DrSyzygy> http://www.haskell.org/haskellwiki/User:Michiexile/MATH198
16:34:18 <Cale> arthulia: So you can see I defined that function add :: Float -> Float -> Float
16:34:19 <DrSyzygy> One of these years, I should really link this to the haskellwiki category theory page
16:34:38 <Cale> arthulia: and then  add 5 :: Float -> Float  is the function which adds 5 to whatever its argument is
16:34:56 <Cale> arthulia: and then  add 5 10 :: Float  is just the number 5 + 10 = 15
16:35:07 <johnw> that whole thing about functors being the morphisms of the category of categories was really helpful
16:35:15 <DrSyzygy> :-)
16:35:38 <johnw> today I finally understood how zippers can be comands, which helped me understand comands a ton better
16:35:42 <johnw> comonad
16:35:48 <DrSyzygy> awesome
16:35:53 <DrSyzygy> let's see...
16:36:02 <DrSyzygy> comonads let you get current element, and let you move your context.
16:36:12 <edwardk> note: the zippers in lens don't form a comonad, though the Level comonad is used for each level
16:36:13 <Eduard_Munteanu> johnw: there's ##categorytheory too, mind :)
16:36:14 <DrSyzygy> so yeah, it's obvious (once you see it) that zippers are comonads.
16:36:24 <johnw> because these past few weeks I'd been implementing 1/2 of a zipper, so once I learned what a zipper was I kind of hit myself on the head, then when I saw the connection to a comonad, I was like, so *that's* it....
16:36:25 <DrSyzygy> Eduard_Munteanu: ORLY? /joins
16:36:48 <Eduard_Munteanu> DrSyzygy: yep, and founded by #haskell-ers too :)
16:36:55 <johnw> Eduard_Munteanu: I wonder what the morphisms of that group are..
16:36:57 <DrSyzygy> Eduard_Munteanu: of course it was. :-P
16:37:05 <DrSyzygy> ... now it's REALLY sleepytime over here though
16:37:11 <DrSyzygy> johnw: I'm glad you liked it!
16:37:18 <edwardk> >>> zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
16:37:19 <edwardk> ("Jelly","world")
16:37:20 <johnw> edwardk: I was just going to ask you about zippers in Control.Lens...
16:37:23 <DrSyzygy> johnw: Now if you can just encourage some university to give me a lectureship. :-P
16:37:27 <Eduard_Munteanu> johnw: what group?
16:37:36 <johnw> Eduard_Munteanu: ##categorytheory :)
16:37:40 <Eduard_Munteanu> Heh :)
16:37:55 <edwardk> the zipper type there can;t be a comonad, because you can't just give me a new type for the current hole and have me accept it, when i roll it back up into its parent
16:38:08 <shachaf> edwardk: What's (%)?
16:38:08 <edwardk> but
16:38:13 * shachaf assumes that's not from Data.Ratio.
16:38:14 <edwardk> (%) = flip ($)
16:38:19 <shachaf> Oh.
16:38:27 <DrSyzygy> neat
16:38:30 <johnw> like what LYAH calls -:
16:38:41 <edwardk> its the operator such that %= is the infix application of it on a lens into the current state ;)
16:39:04 <shachaf> |> is a popular name for it.
16:39:05 <johnw> edwardk: I don't get the "fromWithin traverse" part
16:39:27 <edwardk> you can name a traversal when you go down with the zippers in lens. then left and right move with in that entire traversal
16:39:51 <Cale> (focus .~ 'y') . rightmost . (focus .~ 'J') . fromWithin traverse . down _1 . zipper $ ("hello","world")
16:40:06 <johnw> i mean, why do you need fromWithin traverse at all?
16:40:14 <edwardk> >>> rezip . (focus .~ 'y') . rightmost . (focus .~ 'J') . fromWithin traverse . down _1 . zipper $ ("hello","world")
16:40:14 <edwardk> ("Jelly","world")
16:40:18 <johnw> once you go "down _1", isn't your focus at the head of "hello"?
16:40:25 <Cale> oh, right :)
16:40:26 <edwardk> your focus is on the string 'hello'
16:40:28 <edwardk> you can reverse it
16:40:33 <johnw> oh, I see
16:40:34 <johnw> of course
16:40:38 <edwardk> etc
16:40:39 <johnw> it's a data structure within a data structure
16:40:46 <johnw> i'm too used to not thinking of strings as lists
16:41:03 <edwardk> yeah the type starts at Top :> (String,String), when you go down _1 it becomes Top :> (String,String) :> String
16:41:03 <johnw> i'm using lens more and more
16:41:15 <johnw> my latest utility uses more lens stuff than I ever have before
16:41:22 <shachaf> That's just how I'd write it! Much more intuitive than s[0][0] = 'J'; s[0][-1] = 'y'
16:41:32 <johnw> :)
16:41:40 <edwardk> when you go 'fromWithin traverse' it becomes Top :> (String,String) :> String :> Char
16:41:46 <edwardk> and you can move left and right within the traversal
16:41:52 <edwardk> fromWithin is the unsafe form of within
16:42:01 <johnw> edwardk: what do I have to implement to make my own types "zipper"-able?
16:42:08 <edwardk> nothing
16:42:13 <edwardk> just add lenses and traversals
16:42:20 <johnw> can you zipper Data.Maps?
16:42:26 <edwardk> yep
16:42:31 <johnw> ok, then I'm good
16:42:33 <edwardk> and syntax trees, etc
16:42:44 <edwardk> all the uniplate combinators in lens combine with the zipper combinators
16:43:01 <johnw> i have a Git.Tree which is a recursive map of maps, and I wanted to use zippers to focus and transform (which is the function I'd been hand-writing)
16:43:07 <johnw> sweet
16:43:12 <edwardk> so you can just go down in a syntax tree to sub-expressions with 'within plate' or 'within uniplate' depending on if you want a hand optimized walk or one built on Data.Data
16:43:31 <edwardk> >>> zipper ("hello",["world","!!!"],(),True) % fromWithin biplate % focus .~ 'J' % rightmost % focus .~ '?' % rezip
16:43:32 <edwardk> ("Jello",["world","!!?"],(),True)
16:43:39 <johnw> when I get to Lensify that data structure, I'll be sure to come to you :)
16:43:46 <edwardk> biplate there is magically finding all the Chars inside of that structure wherever they lie
16:44:01 <johnw> interesting
16:44:07 <johnw> that is really powerful stuff
16:44:37 <startling> can I have a Writer that runs some other Writer and then filters that written state?
16:44:41 <johnw> I feel like my Haskell "toolbox" is already so much bigger than anything I've known in other languages..
16:45:11 <edwardk> it is also doing it in a super-efficient form where it memoizes the parts of the structure that can't contain something and avoids retraversing that type looking for the types that can't be found there
16:45:14 <johnw> startling: you wouldn't need a StateT a Writer b?
16:45:28 <startling> johnw, I don't think so.
16:45:34 <edwardk> that part i stole from the original uniplate
16:45:40 <johnw> edwardk: brilliant
16:45:58 <johnw> what language is Kmett from?
16:46:00 <edwardk> that was ndm's magic in the original uniplate. it just got faster when it was boiled down to a traversal
16:46:00 <startling> oh, mapwriter is pretty cool
16:46:21 <startling> johnw: Haskell. ;)
16:46:22 <edwardk> bulgarian or slovenian by way of sweden ;)
16:46:34 <johnw> ah!
16:46:35 <Cale> edwardk: presumably this also works?  zipper ("hello",["world","!!!"],(),True) % fromWithin biplate % focus .~ "ehhhh" % rightmost % focus .~ "???" % rezip
16:46:41 <edwardk> depending on who you ask it means 'mayor' or 'slave' ;)
16:46:51 <Eduard_Munteanu> Hah.
16:46:54 <edwardk> >>> zipper ("hello",["world","!!!"],(),True) % fromWithin biplate % focus .~ "ehhhh" % rightmost % focus .~ "???" % rezip
16:46:54 <edwardk> ("ehhhh",["world","???"],(),True)
16:47:05 <edwardk> yeah there is nothing magic about Char
16:47:08 <Cale> right
16:47:34 <edwardk> and you can modify as well as set, etc.
16:47:35 <edwardk> >>> zipper ("hello",["world","!!!"],(),True) % fromWithin biplate % focus %~ reverse % rightmost % focus .~ "???" % rezip
16:47:36 <edwardk> ("olleh",["world","???"],(),True)
16:48:27 <shachaf> Oh, lens is at 3.0.
16:48:43 <edwardk> i'm actually fiddling with a 'ZippedT' monad that lets you walk left, right, up, down, etc. as monadic actions. the up/down require nested scopes, but everything else works fine monadically
16:48:51 <edwardk> yeah. zippers were the big 3.0 feature
16:49:00 <shachaf> They'll be covered in your talk, right?
16:49:14 <edwardk> yeah, assuming i get as far as i did in the talk i gave at boston haskell
16:49:31 <edwardk> that talk ran about two hours long though and was a bit dense
16:50:15 <shachaf> bahaskell generally has just one talk per meeting, for what it's worth.
16:50:23 <shachaf> roconnor was the exception. :-)
16:50:32 <edwardk> as long as you guys don't mind me rambling on for hours, i'm happy to talk ;)
16:50:40 <edwardk> eventually i tend to take pity on my audience and stop ;)
16:51:17 <edwardk> the way i did it at boston haskell worked pretty well though. it was about 50% interactively done at the repl
16:51:32 <Cale> edwardk: In your blue diagram, you have au and auf, where I think au should be ala
16:51:41 <edwardk> i usually hate repl based talks, but i think it helps with lenses because the theory of them is so abstract
16:51:52 <edwardk> Cale: yeah. i was waiting for someone to call me on that ;)
16:52:55 <edwardk> let me go find the version in which it changed and update the wiki links
16:54:08 <edwardk> it was around 2.7 iirc
16:54:30 <edwardk> hah thats what a CHANGELOG is for i guess
16:54:30 <edwardk> was right
16:57:22 <johnw> edwardk: would it be possible to have a kind of "zipper" that could also be a Comonad?
16:57:34 <dibblego> johnw: yes
16:57:41 <edwardk> johnw: the Level comonad in lens is a zipper for a list that is comonadic
16:57:42 <johnw> I'd like to extend over my data structure and have each application receive a zipper
16:57:55 <edwardk> i also have a zipper for traversable containers that is comonadic in comonad-extras iirc
16:58:05 <edwardk> the zipper in lens is sort of a generalization of these
16:58:12 <johnw> edwardk: can I apply Level to my own types?
16:58:26 <edwardk> johnw: Level is basically a Zipper into a NonEmpty list
16:58:27 <johnw> i see, comand-extras is not obsolete?
16:58:46 <dibblego> data ListZipper a = ListZipper { lefts :: [a], focus :: a, rights :: [a] }; extend :: (ListZipper a -> b) -> ListZipper a -> ListZipper b -- johnw, I often give this as a beginner exercise to introduce comonad
16:58:56 <dibblego> oh I am missing context, sorry
16:58:56 <johnw> you have so many libraries, and I understand some of them are merely historical at this point...
16:59:14 <johnw> dibblego: yeah, I'm specifically referring to "zipper" in lens-3.0
16:59:19 <edwardk> comonad-extras contains comonads that need extra extensions over and above the laundry list usually used for mtl
16:59:24 <johnw> but I appreciate the explanation nonetheless
16:59:41 <shachaf> I think that's more of a NonEmptyListZipper.
17:01:41 <edwardk> cale: images in the wiki for versions after 2.6 should be fixed,
17:03:33 <dibblego> edwardk: do you think it is worth putting together a (small) monadhoist package — one H98 and the other not (perhaps distinguished by a version number)?
17:04:41 <edwardk> dibblego: i think the idea of distinguishing them by version number is terrible, but i don't object to having a package or two with the hoist class in it
17:04:41 <edwardk> i'd probably just as soon have it be the actual transformation-based one
17:05:00 <dibblego> edwardk: how would you distinguish? you think the H98 is not too useful?
17:05:07 <edwardk> the problem with the version number thing is it means that you split an already small user-base into two incompatible ghettos
17:05:12 <dibblego> right
17:05:58 <identity> Any of you guys seen the "haskell book" thread in /r/programming recently?
17:05:59 <dibblego> I currently have it now in my nothing-to-do-with-monadhoist package and I only needed t Identity a -> t f a
17:06:00 <edwardk> i'd just as soon build the monad homomorphism version, if someone needs it, i don't think they are going to object to a rank2 type
17:06:04 <identity> (and /r/haskell)
17:06:11 <dibblego> edwardk: ok cool
17:07:00 <edwardk> maybe it shouldn't be called hoist
17:07:07 <johnw> pitard
17:07:08 <edwardk> i don't even remember why i threw that name out originally ;)
17:07:25 <edwardk> MonadPetard looks silly ;)
17:07:25 <johnw> identity: to what do you refer?
17:07:34 <edwardk> identity: yes
17:07:41 <dibblego> MonadTransform?
17:07:53 <johnw> MonadTutorial
17:07:58 <edwardk> class MonadHom where liftHom :: … ?
17:08:08 <johnw> ooh.. Hom
17:08:24 <johnw> because things didn't make enough sense yet!
17:08:44 <identity> johnw: The guy writing the haskell book
17:08:45 <dibblego> hrm I hate coming up with names — I freeze
17:08:47 <edwardk> i guess MonadTransformer wouldn't be bad either
17:09:00 <edwardk> at least MonadHom and liftHom have names that sound related
17:09:02 <identity> At any rate -- I don't find the book interesting as such, but rather what everyone is saying about Haskell
17:09:05 <identity> a lot of it makes sense.
17:09:13 <dibblego> class MonadTransformer where transform ::
17:09:14 <edwardk> and it doesn't collide with the use of cohoist in comonad-transformers
17:09:21 <edwardk> dibblego: sounds good
17:09:25 <edwardk> make it so
17:09:33 <dibblego> It Is That
17:09:35 <johnw> edwardk: can you understand this article: dewaca
17:09:38 <johnw> http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/
17:09:46 <edwardk> johnw: yes
17:09:49 <johnw> this is the kind of stuff that scared me away from Haskell back in the day
17:09:56 <identity> Particularly the general consensus that people have the hardest time understanding how to write practical code
17:09:57 <johnw> now it simply mystifies, but doesn't scare
17:10:05 <identity> Not just small functions for doing things in a nifty manner
17:10:06 <identity> etc
17:10:10 <edwardk> johnw: admittedly the stuff that gets blogged on comonad.com is sort of deliberately not dumbed down. ;)
17:10:38 <startling> meh, why can't data X a b c = X [a] [b] [c] derive monoid?
17:10:50 <edwardk> i started the blog there to post about things _i_ wanted to know more about =)
17:11:00 <edwardk> the audience was a secondary concern ;)
17:11:09 <johnw> ah, fair enough
17:11:09 <jfischoff> edwardk: was the article inspired by the lens work?
17:11:52 <edwardk> jfischoff: it was written by dolio. there was a paper by ralf hinze recently, where he did a bunch of stuff using kan-extensions and codensity that nodded toward the usecases on my blog
17:12:08 <jfischoff> ah
17:12:09 <edwardk> along the way he made a claim in there that Codensity m is isomorphic to m
17:12:13 <edwardk> which is subtly wrong
17:12:23 <dolio> I don't know if he actually did.
17:12:38 <edwardk> i need to reread the paper
17:12:41 <dolio> Do you know which paper it is?
17:12:44 <edwardk> in the context of dolio's result
17:12:50 <edwardk> art and dan explain
17:13:03 <edwardk> http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf
17:14:41 <dibblego> s/MonadTransformer/MonadTransform
17:15:27 <edwardk> anyways there was a claim in there that was really really surprising to me, and when dan and i worked through it on the whiteboard it used the yoneda lemma on the kleisli category of m, but it turned out the quantification we usually rely on for naturality was the wrong thing
17:15:57 <edwardk> (i really sat around and cheerleaded, dan did all the work)
17:16:02 <edwardk> cheerled?
17:17:11 <johnw> i guess it would be cheerled.. :)
17:17:13 <dolio> I think we just read the paper wrong at the time.
17:17:50 <startling> man, Writer is really cool
17:18:22 <edwardk> could be
17:18:32 <dolio> The paper seems to note that the 'every monad is isomorphic to a codensity monad' is not Codensity m = m.
17:18:39 <edwardk> i'm skimming it for the statement that we ran off and tried to disprove
17:18:41 <startling> edwardk, do you have lenses for working with Writer?
17:18:58 <edwardk> startling: i had _one_, but it was silly and i removed it
17:19:02 <startling> or functions for telling with lenses
17:19:17 <edwardk> i used to have 'whisper' which let you tell part of a monoidal result
17:19:28 <ivanm> IIUC what lenses are, why do you need one for writer?  Why not just use tell & co. ?
17:19:30 <dolio> Of course, if you want it to work for the Codensity you can write in Haskell, it's probably questionable, too.
17:19:45 <startling> ivanm, telling to a certain field of the writer state
17:20:01 <startling> edwardk: yeah. tell (files .~ x $ mempty) isn't too bad, though
17:20:09 <ivanm> ahhhh
17:20:10 <ivanm> duh
17:20:22 <edwardk> yeah that was 'whisper files x'
17:20:26 <ivanm> I've only ever really seen/used Writer in a "log something to the end" use case
17:20:26 <startling> right.
17:20:37 <edwardk> but too many people gave me crap about the name ;)
17:20:41 <startling> haha
17:20:52 <dolio> I doubt there's an F such that M = Codensity F for every monad M in Haskell.
17:21:42 <Cale> edwardk: what's wrong with that name?
17:21:48 <Cale> (why'd they complain?)
17:21:49 <edwardk> anyways i'm much much happier with dolio's final result than our patchwork understanding when we thought we understood it
17:21:55 <edwardk> Cale: mostly coz it sounded silly ;)
17:22:24 <startling> edwardk: "give" leads to some nice dsl-ish expressions, though. "give files [a, b, c]"
17:22:24 <edwardk> i'm willing to put it back in I suppose if people want it
17:22:40 <startling> edwardk: it's pretty trivial to write regardless
17:22:44 <edwardk> startling: yeah but its a pretty valuable name to take for such an uncommon operation
17:22:45 <Cale> Tell those people to see 'auf'
17:22:51 <startling> edwardk, true
17:22:58 <startling> I'm gonna use it anyway. :)
17:22:58 <edwardk> Cale: i really liked auf.
17:23:02 <edwardk> it was better when ala was au
17:23:05 <edwardk> but its still pretty good
17:23:16 <Cale> Yeah, it's like au with an f
17:23:19 <edwardk> auf was au with a function =)
17:23:27 <edwardk> and linguistically played the same role
17:25:40 <Cale> "I hope to see string diagrams more widely used for program calculation in the future" -- Go weak 2-categories!
17:26:20 <edwardk> i really like string diagrams
17:26:29 <Cale> me too
17:26:42 <startling> it's too bad types don't curry like functions do.
17:26:44 <edwardk> dolio and copumpkin gave me grief when i spent like 2-3 sessions on them in the weekly category theory classes we used to run
17:26:58 <Cale> startling: Oh?
17:27:05 <Cale> :kind Either
17:27:06 <startling> type Whatever m = X Y m is silly. it should just be type Whatever = X Y
17:27:12 <edwardk> but they make so many proofs obvious
17:27:16 <Cale> startling: and that doesn't work?
17:27:27 <hpc> startling: sure, if you want arbitrary type-level lambdas
17:27:34 <edwardk> startling: that works
17:27:50 <edwardk> you can have type aliases for kinds other than *
17:28:03 <hpc> startling: you can do that, but you can't partially apply something like "type Flip x y = (y, x)"
17:28:23 <hpc> "Flip x y" is all or nothing, and you can't define Flip in a pointfree fashion
17:28:26 <startling> I have "type Handler a = Noisy Results [File] a". if I do "type Handler = Noisy Results [File]", I get "Type synonym `Noisy' should have 3 arguments, but has been given 2"
17:28:35 <startling> is it because Noisy is a synonym?
17:28:43 <copumpkin> edwardk: not me!
17:28:50 <hpc> startling: yes
17:28:52 <Cale> startling: yes, it's because Noisy is a synonym, and synonyms must always be fully applied
17:28:53 <copumpkin> edwardk: also, I just advertised you ;)
17:28:54 <edwardk> hpc: modulo a few opportunities where you can get away with it using LiberalTypeSynonyms
17:29:01 <edwardk> uhoh, where?
17:29:03 <hpc> startling: "type Noisy a b c = ...", i assume?
17:29:04 <startling> Cale, hpc: ah. weird
17:29:16 <copumpkin> edwardk: twatt0r
17:29:19 <startling> hpc: type Noisy e a b = RWS a e () b, yes
17:29:35 <hpc> startling: you can curry synonyms only as far back as they are made pointfree in the type alias
17:29:38 <Cale> startling: change that to  type Noisy e a = RWS a e ()
17:29:45 * ddarius prefers string diagrams to the normal diagrams and likes the mnemonic value they provide, but generally doesn't like categorical diagrams.
17:29:51 <startling> yeah. weird, but it makes sense. thanks!
17:29:56 <hpc> what Cale said will fix your specific issue
17:30:06 <hpc> but you probably don't want to be hacking that hard with type aliases
17:30:32 <startling> hpc, why not?
17:31:10 <edwardk> startling: the approach taken by lens using lots of crazy type aliases is generally not considered good form ;)
17:31:12 <Cale> startling: Because they generally just start to make things confusing, by making it harder to tell when you can use things together.
17:31:28 <startling> edwardk: hehe
17:31:42 <hpc> startling: if you could, type aliases would be type-level functions
17:31:47 <edwardk> startling: and in almost any other scenario i would agree about that
17:32:03 <hpc> which means undecidable type checking if you aren't veeeeeery careful
17:32:13 <hpc> for an example of such extreme carefulness, see agda
17:32:22 <hpc> (but don't, because your head will probably break)
17:32:23 <startling> Cale, that's true. I'm not using Noisy at all explicitly, though, it's just my implementation of a monad that's both a MonadWriter and a MonadReader.
17:32:55 <jmcarthur> Cale: "I hope to see string diagrams more widely used for program calculation in the future"  <-- where was that?
17:33:09 <edwardk> jmcarthur: Art and Dan explain an old trick
17:33:15 <Cale> http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf
17:33:17 <jmcarthur> thanks
17:35:34 <edwardk>  i use them a lot with adjunctions, monads and kan-extensions
17:35:34 <Cale> If anyone doesn't believe in the power of string diagrams, tell them to suppose that F is left adjoint to G, and ask them to find a natural transformation from FFGGFGFGG to GGFGFFGGF
17:35:44 <copumpkin> lol
17:36:04 <Cale> and then show them this: http://cale.yi.org/share/adjunction-nat-trans.png
17:36:05 <copumpkin> how about to FFFFFFFFUUUUUUU?
17:38:38 <SLi> What would be the easiest/cleanest/most compact way to produce all possible length n lists of booleans (or other bounded enumerables)?
17:38:46 <SLi> Some weird trick using the list monad?-)
17:38:58 <Cale> > replicateM 3 [True, False]
17:38:59 <lambdabot>   [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[F...
17:38:59 <jmcarthur> replicateM
17:39:15 <SLi> Hmm. Interesting. Thanks :)
17:39:18 <Cale> > replicateM 3 "01"
17:39:19 <lambdabot>   ["000","001","010","011","100","101","110","111"]
17:39:50 <jmcarthur> oh i like how that is in numerical order. didn't think of that before
17:40:04 <jmcarthur> > replicateM 2 ['0'
17:40:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:40:07 <jmcarthur> grr
17:40:12 <jmcarthur> > replicateM 2 ['0'..'9']
17:40:13 <lambdabot>   ["00","01","02","03","04","05","06","07","08","09","10","11","12","13","14"...
17:40:31 <ddarius> Why are there so many Gs on that blue line?
17:40:38 <YayMe> > replicate 3 "01"
17:40:39 <lambdabot>   ["01","01","01"]
17:40:47 <YayMe> >replicateM 3 "01"
17:40:47 <Cale> ddarius: To better read off the composite
17:40:57 <YayMe> > replicateM 3 "01"
17:40:58 <lambdabot>   ["000","001","010","011","100","101","110","111"]
17:41:09 <Cale> ddarius: (in horizontal rows)
17:41:10 <YayMe> wow.. what?
17:41:22 <jmcarthur> YayMe: that's exactly what Cale just did a second ago...
17:41:31 <YayMe> jmcarthur: I know, I saw it...
17:41:36 <jmcarthur> @src replicateM
17:41:36 <lambdabot> replicateM n x = sequence (replicate n x)
17:41:46 <YayMe> @src replicate
17:41:46 <lambdabot> replicate n x = take n (repeat x)
17:41:46 <jmcarthur> @src sequence
17:41:47 <lambdabot> sequence []     = return []
17:41:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:41:47 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
17:42:29 <frio> hah at the smiley face in (liftM2 (:)) (return [])
17:42:29 <Cale> YayMe: sequence in the list monad is a Cartesian product -- "running" a list means picking an element from it in all possible ways, and so if you run all the lists and return a list of the results, you're picking one element from each in all possible ways
17:43:06 <arthulia> sorry for disappearing, I had to run and catch a bus.
17:43:07 <YayMe> Cale: interesting, so then...
17:43:17 <YayMe> > replicateM 2 "01"
17:43:18 <lambdabot>   ["00","01","10","11"]
17:43:26 <YayMe> ok
17:43:26 <Cale> > filterM (const [False, True]) "abcd"
17:43:27 <lambdabot>   ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","...
17:43:43 <arthulia> Cale: you gave me the function earlier for the type i was showing you: f = f 0 + f 1, what do the numbers 0 and 1 mean?
17:43:44 <ddarius> @let amb = id
17:43:45 <lambdabot>  Defined.
17:43:53 <Cale> arthulia: Just arbitrary Floats
17:44:08 <benmachine> frio: the function for making a list from a single element is sometimes called the robot monkey operator
17:44:13 <benmachine> frio: (:[])
17:44:15 <Cale> arthulia: We could have just done  func1 f = f 0
17:44:30 <arthulia> and that just returns the Float from the first function and adds 0?
17:44:31 <Cale> arthulia: Or even  func1 f = 0  (but that's boring)
17:44:44 <Cale> arthulia: It applies the function f to 0
17:44:49 <frio> hahahah benmachine
17:44:50 <frio> awesome
17:44:53 <Cale> arthulia: if it helps, f 0 means f(0)
17:44:55 <SLi> I already thought I understood something about the list monad, but now I realize I don't. I'm baffled by the mere notion of lists being "monadic actions" (though I realize a "monadic action" is just anything wrapped in a monad... right?)
17:45:15 <Cale> SLi: anything of type m t where m is a monad
17:45:39 <arthulia> ok cool
17:46:18 <Cale> arthulia: for example, we could then apply func1 to the function (\x -> (x + 2)^2)
17:46:25 <arthulia> now I understand :)
17:46:33 <Cale> arthulia: and that would apply this function to 0, so we'd get (0 + 2)^2 which is 4
17:46:38 <arthulia> right
17:47:32 <blackh> SLi: You can think of it as being nondeterministic, i.e. it "runs" multiple times. Sort of like spawning parallel universes.
17:47:35 * hackagebot ghc-vis 0.4 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.4 (DennisFelsing)
17:47:56 <Cale> Or like list comprehensions
17:48:07 <Cale> If you can understand list comprehensions, the list monad is just a generalisation of that
17:48:24 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
17:48:25 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
17:48:34 <jmcarthur> and then we can introduce you to monad comprehensions...
17:48:40 <arthulia> no, but that's neat :P
17:48:42 <Cale> > [(x,y,z) | x <- [1,2,3], y <- [4,5], z <- [6,7,8]]
17:48:43 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
17:48:59 <Cale> arthulia: that was more aimed at SLi  :)
17:49:08 <arthulia> aha
17:49:58 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; guard (x + y + z < 15); return (x,y,z)
17:49:59 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
17:50:20 <Cale> lol, of course
17:50:29 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; guard (x + y + z < 13); return (x,y,z)
17:50:31 <lambdabot>   [(1,4,6),(1,4,7),(1,5,6),(2,4,6)]
17:50:46 <Cale> > [(x,y,z) | x <- [1,2,3], y <- [4,5], z <- [6,7,8], x + y + z < 13]
17:50:47 <lambdabot>   [(1,4,6),(1,4,7),(1,5,6),(2,4,6)]
17:51:11 <Cale> So there's this direct correspondence between do-notation with calls to this 'guard' function and the list comprehension syntax
17:51:36 <Cale> But of course, the advantage here is that you get all the stuff in Control.Monad working on lists for free :)
17:53:18 <c_wraith> I recently used guard in a non-list context
17:53:20 <c_wraith> I was amazed
17:54:13 <jmcarthur> there are a lot of MonadPluses out there ;)
17:54:38 <benmachine> I use guard all the time for Maybe
17:54:59 <bitonic> oh damn.  I've just installed debian testing and I can't install the ghc binaries - wrong version of gmp
17:55:42 <Cale> bitonic: and there might be problems with just compiling GHC against the new one too.
17:55:59 <bitonic> Cale: so... what do I do?  newer version of gmp?
17:56:14 <Cale> older, I think
17:56:23 <ddarius> "I use guard all the time for lists of length at most 1."
17:56:39 <thoughtpolice> bitonic: yeah, that's what's been biting me on fedora. i can't use a more modern ghc binary dist because of a different gmp version, so i can't have 7.4.x, so i can't have 7.6.x, so i can't use head :/ you just have to do the boostrapping manually yourself
17:57:20 <Cale> (A guy was in here earlier with a problem with segfaults happening suspiciously around a place where ltrace showed a bunch of GMP calls, and his problem didn't happen on my system which has the older GMP)
17:57:39 <bitonic> damnit.  if I knew I might have stayed with ubuntu.
17:57:52 <bitonic> I suppose there is no easy way to have an older version?
17:57:59 <ddarius> Now you are irrevocably lost.
17:58:12 <Cale> You can probably just grab an older libgmp.so
17:58:16 <ivanm> bitonic: get the .so file from somewhere and shove it in the library path
17:58:27 <Cale> and stick it in /usr/local/lib and run ldconfig
17:58:40 <bitonic> uhm.  OK.
17:58:40 <ivanm> I've done that to be able to darcs over ssh when the server doesn't have gmp installed
18:00:55 <blackh> Cale: I'm new to haskell-src-exts. Is there some generic way to traverse the whole structure looking for, say, type signatures, without writing lots of boilerplate for constructor?
18:01:02 <YayMe> In my definition of a cartesian product, you take 2 sets, and give all combinations of those two for instance:
18:01:08 <YayMe> > [ (x,y) | x <- [1..4], y <- [5..7] ]
18:01:10 <lambdabot>   [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7),(4,5),(4,6),(4,7)]
18:01:20 <YayMe> Is that inaccurate?
18:01:32 <ivanm> blackh: maybe see how ndm does it in hlint?
18:01:33 <YayMe> Someone told me that was a cartesian product once. the combining of 2 sets
18:01:39 <Cale> YayMe: That is a Cartesian product, but it can be naturally extended to products of more sets.
18:02:03 <YayMe> Cale: that is "a" cartesian product, but not the definition of "Cartesian Product" ?
18:02:14 * ddarius would not refer to "Categories for the Working Mathematician" as a "masterpiece".
18:02:26 <Cale> You can take it as the definition of the Cartesian product of two sets.
18:02:40 <Cale> blackh: hmm
18:03:13 <Cale> blackh: I think that's what the uniplate/biplate/etc. stuff is all about.
18:03:19 <YayMe> then would it follow that [ (x,y,z) | x <- [2,3], y <- [5,6], z <- [9,0] ]
18:03:21 <Cale> blackh: Or of course, other generics libraries
18:03:26 <YayMe> is the cartesian product of 3 sets?
18:03:34 <Cale> blackh: I've really only used it to generate code
18:03:42 <Cale> YayMe: yeah
18:03:46 <blackh> Cale: I thought that might be the answer. Well, I still think the naive way will be shortest overall.
18:04:33 <YayMe> > replicateM 2 "01"
18:04:35 <lambdabot>   ["00","01","10","11"]
18:05:10 <Cale> YayMe: Do you know what a category is?
18:05:11 <YayMe> > [ x:y | x<-[0,1],y<-[0,1]]
18:05:12 <lambdabot>   No instance for (GHC.Num.Num [t])
18:05:12 <lambdabot>    arising from a use of `e_10101' at <in...
18:05:25 <ddarius> @hackage haskell-src-exts
18:05:26 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
18:05:55 <YayMe> Cale: Nope. Everyone does hand wavey stuff when they mention them in tutorial type stuff and outside of those I only see them referred to in stuff far too dense for me
18:06:02 <luite> blackh: isTypeDecl (TypeDecl{}) = True, isTypeDecl _ = False; allTypeDecls ast = listify isTypeDecl ast
18:06:10 <YayMe> s/dense/over my head
18:06:23 <luite> blackh: no extra instance deriving needed, syb uses Data ;p
18:06:37 <ddarius> blackh: All the types are instance of Data and Typeable so you can use syb.
18:06:45 <ddarius> At which point the solution is probably one or two lines.
18:06:53 <YayMe> > [(x,y)|x<-[0,1],y<-[0,1]]
18:06:53 <blackh> OK, then I am going to give it a go!!
18:06:54 <lambdabot>   [(0,0),(0,1),(1,0),(1,1)]
18:06:59 <Cale> YayMe: Okay, well, if you want, I could explain that, and give you a definition of "product" which works in any category, or I could just tell you what it is for sets...
18:07:02 <YayMe> > replicateM 3 "01"
18:07:03 <lambdabot>   ["000","001","010","011","100","101","110","111"]
18:07:14 <YayMe> > replicateM 2 "01"
18:07:15 <lambdabot>   ["00","01","10","11"]
18:07:35 <jmcarthur> just do sets. that's the only intuition that most beginners of category theory have for categories at first anyway
18:08:12 <YayMe> I think I get sets
18:08:18 * YayMe definitely doesn't get sets
18:08:22 <Cale> :D
18:08:34 <johnw> haha
18:08:36 <YayMe> so far my intuition has been that I think I understand things, only to find out I absolutely do not
18:08:49 <jmcarthur> that will never change
18:08:50 <johnw> "thinking you get something" is an interesting proposition
18:09:10 <YayMe> johnw: I have an understanding which I *think* is right (though shallow)
18:09:23 <YayMe> johnw: I don't *believe* it's right however
18:09:27 <YayMe> :)
18:10:06 <johnw> I think I'm certain that that might be true
18:10:24 * ddarius would recommend actually presenting category theory in terms of lattice theory for someone without a heavy math background.
18:10:39 <Cale> YayMe: Wait until you see just about any modern paper on set theory and you see them talking about iterable pre-mice and zero hand-grenade and stuff and you're like "wat".
18:10:48 <johnw> maybe it should be presented in terms of space stations and astronauts
18:10:58 <shachaf> ddarius: Hmm, where can I read about that?
18:11:04 <jmcarthur> ddarius: that's interesting
18:11:18 <benmachine> ddarius: someone tried to explain lattice theory to me
18:11:28 <benmachine> it went roughly along the lines of "it's, uh, you know, there are lattices"
18:11:51 <ddarius> benmachine: Lattices and partially ordered sets are more or less the same thing.
18:11:55 <YayMe> Cale: Eh, I don't suspect I'll ever get anywhere near an understanding of any of the crazy theory stuff, I wish I had gone to college because then perhaps I would have, but that was not my path.
18:12:01 <jmcarthur> i pretty much know the most basic algebraic presentation of lattices
18:12:10 <ddarius> It's pretty easy to provide comprehensible examples of ordered sets and the operations are natural and intuitive as well.
18:12:13 <benmachine> ddarius: oh right. from the explanation I received, I assumed that there was more than one thing called a lattice
18:12:14 <YayMe> I'd like to try, but I know the papers about the theoretical stuff will just fly right over my head
18:12:19 <benmachine> I know about poset-lattices
18:13:04 <benmachine> are they categories in the poset sense, i.e. at most one arrow between two objects?
18:13:43 <ddarius> shachaf: Well, if you want a technical paper that goes over this but assumes fairly involved understanding of lattice theory, there's "Category Theory as Coherently, Constructive, Lattice Theory"
18:13:59 <ddarius> benmachine: Lattices are (give rise to) posets.
18:14:41 <startling> @hoogle [a] -> [a] -> Bool
18:14:41 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
18:14:42 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:14:42 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
18:14:51 <Cale> YayMe: Well, it's just a matter of building up from some point where you do get things, and picking up definitions one at a time :)
18:15:16 <ddarius> Anyway, the benefit of using a lattice theoretic approach is that it encourages less preconceptions, lattices are fairly simple, and many lattice theoretic results directly and usefully generalize to category theoretic results.
18:15:35 <ddarius> Cale: No, it's more a matter of checking yourself in objective manners.
18:15:50 <ddarius> Well, for YayMe's earlier problem.
18:16:25 <ddarius> Anyway, reading a research paper is easy.  Start reading it.  If it is too difficult, recurse upon the references.
18:16:52 <startling> is there a function somewhere that tells me whether one list starts with another list?
18:16:59 <dolio> Well, that might not work.
18:17:00 <Cale> isPrefixOf
18:17:00 <ddarius> isPrefixOf
18:17:00 <copumpkin> :t isPrefixOf
18:17:01 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:17:27 <ddarius> dolio: Well you do have to remember which papers you read or you may end up in a citation loop.
18:17:27 <Cale> @hoogle [a] -> [a] -> Bool
18:17:28 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
18:17:28 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:17:28 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
18:17:28 <shachaf> Every non-empty list starts with another list.
18:17:42 <ddarius> Alternatively, you can do it breadth first, which is somewhat closer to how you are likely to do it.
18:17:43 <startling> shachaf: another *given* list
18:18:04 <startling> isPrefixOf is nice, weird that I missed it.
18:18:05 <startling> thanks!
18:18:13 <ddarius> > [] `isPrefixOf` []
18:18:14 <lambdabot>   True
18:18:26 <dolio> No, I mean there might not be citations you actually understand. Recursively.
18:19:40 <dolio> Because if you're a real beginner, beginner books don't get cited in research papers, often.
18:19:44 <ddarius> dolio: For some areas, and particularly newer, specialized areas, you may bottom out in something not understandable, but I think many do reach relatively expository/clear papers too long.
18:19:56 <YayMe> A fellow at my last job who had a math degree took a couple hours one day when I was first learning haskell to try and explain some theory stuff to me from his math understanding. Neither he nor I knew where it fit into haskell but it sounded like it was related. Here's what I took away: If you have a set F and an operation i which has to be a member of that set, that maps elements in that set to elements of set G that is a
18:19:56 <YayMe> (endo?)functor and the relationship between F and G is (iso?homo?mono?)morphic. If you have in the set G an operation j that maps elements from G to F then the relationship is something-else-morphic and if i(j(Gsub1)) == Gsub1 that meant the relationship is something-else-morphic
18:20:09 <bitonic> ivanm, Cale: well, that worked, thanks.
18:20:20 <ddarius> dolio: A lot of early work is remarkly clear and readable (though admittedly, a lot is remarkably confused and unclear.)
18:20:59 * ddarius is losing syllables.
18:21:18 * ddarius imagines a room of Babel where all the missing syllables and words go.
18:21:45 <YayMe> he also said I think it's some property of a set when not all elements of G can be represented by i(F) or all elements of F be represented by j(G)
18:22:08 <startling> @hoogle (Eq a, Foldable f) => f a -> f a -> Bool
18:22:09 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
18:22:09 <lambdabot> Data.Foldable notElem :: (Foldable t, Eq a) => a -> t a -> Bool
18:22:09 <lambdabot> Data.IntMap isProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
18:22:09 <johnw> is there a uniq in Haskell, (Eq a) => [a] -> [a] -> [a]?
18:22:17 <Cale> YayMe: huh, I'm not sure
18:22:19 <shachaf> @hoogle (Eq a) => [a] -> [a] -> [a
18:22:19 <lambdabot> Parse error:
18:22:20 <lambdabot>   (Eq a) => [a] -> [a] -> [a
18:22:20 <lambdabot>                           ^
18:22:23 <shachaf> @hoogle (Eq a) => [a] -> [a] -> [a]
18:22:23 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
18:22:23 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
18:22:24 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
18:22:24 <ddarius> nub
18:22:34 <shachaf> Wait, why does that get two arguments?
18:22:34 <johnw> ah, nub
18:22:36 <Cale> johnw: what's the other list for?
18:22:37 <ddarius> Though nub doesn't assume sortedness and thus is quadratic.
18:22:39 <johnw> oh, haha
18:22:48 <johnw> @hoogle (Eq a) => [a] -> [a]
18:22:48 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
18:22:48 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
18:22:48 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
18:22:50 <YayMe> Cale: did I understand anything that fellow told me accurately?
18:22:52 <shachaf> Hoogle would've found it if you'd given the right type. :-)
18:22:52 <johnw> would explain why I didn't find it
18:22:59 <YayMe> Cale: Did I communicate anything that even remotely makes sense?
18:23:14 <Cale> YayMe: Well, I don't know what he was telling you. There are words in there which are real words :)
18:23:19 <benmachine> haha
18:23:20 <benmachine> that's a start
18:23:21 <YayMe> haha
18:23:45 <ddarius> It sounds like he was getting at monomorphisms (injections) and epimorphisms (surjections), and probably also isomorphisms (bijections).
18:23:56 <Cale> yeah
18:25:20 <startling> can I write an isPrefixOf for Foldables without using toList?
18:25:38 <startling> oh, I suppose it doesn't really mean "isPrefixOf", then
18:25:43 <YayMe> he said something like this, given set F whose members are (*,1,2,3) and a set G (+,1,2,3), for G "+" is a functor and for F "*" is a functor, where in the F set 1*1 = in the G set 1 and this is a something-morphic relationship
18:26:02 <Cale> YayMe: are you sure it was functor?
18:26:12 <Cale> Or just a (binary) operator?
18:27:12 <Cale> I think I know maybe what he was talking about, though your descriptions are somewhat jumbled
18:28:08 <YayMe> Cale he used the word functor but he also said he hadn't really studied category theory and was interested in other parts of maths none of which he had touched in years
18:28:12 <YayMe> heh
18:29:21 <startling> maybe he meant it in the C++ sense
18:29:49 * ddarius contemplates 0-dimensional notation.
18:29:51 <Cale> Perhaps he was talking about how with sets, surjections and epimorphisms are the same thing, but in other categories, this isn't always the case, and introduced a pair of monoids to show that an epimorphism might not be surjective.
18:30:14 <YayMe> yeah he used the word epimorphism
18:30:21 <YayMe> and I think that other one you said which I don't know heh
18:30:35 <startling> surjection?
18:30:50 <YayMe> I can't even spell words like that
18:31:02 <startling> wikipedia's diagram is pretty good: http://en.wikipedia.org/wiki/Surjection
18:31:27 <startling> it's means the image of f : A -> B is all of B
18:32:23 <YayMe> that diagram looks like what I took away from him except he said it's not always the case because the relationship may be superset/subset, the relationship may be offset, and  the relationship may go both ways though not always equivalently
18:33:07 <startling> sounds right
18:33:35 <YayMe> set 1 in set A may become 2 in set B, but 2 in set B may become 3 in set A (or there may be equivalence but it all depends on the sets and their relationships)
18:33:42 <YayMe> s/set//f
18:34:29 <YayMe> Cale: So do I get at least a C for knowing what a set is, or do I not know what a set is?
18:34:47 <Cale> YayMe: You probably know what a set is well enough :)
18:34:56 <YayMe> Neat
18:35:01 <YayMe> So then what's a category? :)
18:35:06 <Cale> There are some subtleties to what sets are which most people can't be expected to know
18:35:19 <startling> YayMe: well, do you know what a Group is?
18:35:27 <startling> Cale: something about barbers
18:35:38 <YayMe> startling: Cale says I know what Sets are, does that count? :D
18:35:52 <startling> hehe
18:35:53 <Cale> YayMe: nope :)
18:36:27 <Cale> A group is a set G together with a binary operation, usually called multiplication, *: G x G -> G
18:36:36 <Cale> (where G x G is the Cartesian product)
18:36:55 <Cale> Such that the following rules are satisfied:
18:37:09 <startling> it's associative, has an identity element, each G has an inverse wrt *, and G * G is always a member of G
18:37:21 <Cale> 1) For any a, b, c in G, we have a * (b * c) = (a * b) * c   (it's associative)
18:37:23 <ddarius> People rarely define "set" and even when defined such definitions are rarely given more than lip service.
18:37:51 <Cale> 2) There is an element 1 in G such that for any a in G, we have 1 * a = a * 1 = a  (there is an identity element)
18:38:09 <Cale> 3) For any a in G, there is some b in G such that a * b = b * a = 1
18:38:22 <Cale> (there are inverses)
18:38:37 <YayMe> so in a group any element in the set combined with the binary operator and any other member of the set will return a member of the set?
18:38:39 <Cale> Something like this but where only 1 and 2 are satisfied is called a monoid.
18:38:49 <Cale> yes
18:39:08 <TaylorBaby1985> www.quickcollegehookups.com is accepting 45 more free accounts!
18:39:13 <dolio> A set is a type in Martin-Löf type theory.
18:39:14 <YayMe> Cale: and it's a special case when that rule is not met, but groups like that do exist?
18:39:15 <ddarius> YayMe: Yes, this is usually meant by the phrase "a closed operation", though is more clearly articulated by giving the operator a type.
18:39:24 <YayMe> that's an open group, no?
18:39:32 <YayMe> or open set or something
18:39:35 <Cale> dolio: A set is a type with hlevel 2
18:40:22 <Cale> YayMe: Sometimes people say that the operation is "closed"
18:40:32 <startling> I've never heard "open group"
18:40:47 <Cale> but really, any function G x G -> G has to be defined for every pair in G x G, and has to produce something in G
18:40:59 <dolio> http://www.opengroup.org/
18:41:19 <startling> dolio: heh
18:41:23 <YayMe> ok Cale, this is sounding very much like what that math fella I knew was explaining
18:42:18 <YayMe> he said there was a set combined with an operator or something and I remember him referring to it being closed when the operator can only produce elements inside of that set
18:42:30 <YayMe> (that is when applied to members of that set)
18:42:37 <Cale> YayMe: Okay, so imagine a cardboard square
18:42:44 <startling> heh
18:42:48 <YayMe> I prefer posterboard, got it
18:42:58 * YayMe wishes he chose corkboard
18:43:10 <Cale> YayMe: and the set of ways that you can pick up that square and move it so that when you're done, the corners are in the same place
18:44:01 <YayMe> uh, only one?
18:44:14 <Cale> Well, the corners are allowed to change places with each other
18:44:27 <Cale> So you can turn it 90 degrees
18:44:29 <Cale> or 180
18:44:31 <YayMe> ah ok
18:44:36 <YayMe> or 270
18:44:38 <Cale> right
18:44:43 <Cale> or you can flip it over
18:44:59 <Cale> In total, there will be 8 moves
18:45:08 <Cale> (one of which is to do nothing at all)
18:45:26 <ddarius> When did Hinze start being prolific again?
18:45:32 <Cale> We can put a multiplication on them which is to do one move, and then another
18:45:51 <YayMe> so flip it over then rotate it
18:45:54 <Cale> yeah
18:46:14 <ddarius> "Reason Isomorphically" may be useful to refer people to to explain my recommended approach.
18:46:16 <Cale> and that one will be equivalent to some other flip
18:46:59 <Cale> Moreover, (doing X then doing Y) then doing Z
18:47:09 <Cale> is the same thing as doing X then (doing Y then doing Z)
18:47:16 <Cale> so this operation is associative
18:47:17 <YayMe> so G * G -> G
18:47:27 <Cale> then: G x G -> G
18:47:37 * hackagebot monadtransform 0.0.1 - A type-class for transforming monads (homomorphism) in a transformer  http://hackage.haskell.org/package/monadtransform-0.0.1 (TonyMorris)
18:47:44 <Cale> (I mean, my operation is called "then")
18:47:52 <YayMe> there are 4 corner placements
18:49:48 <Cale> There are 4 just-rotations, and then 4 more moves where it's flipped over (and possibly rotated)
18:50:26 <YayMe> right
18:50:52 <Cale> So next, note that if we do nothing (or a rotation by 360 degrees, or two of the same flip), and then do any other move, it's the same as if we'd just done the second move
18:51:00 <YayMe> so the flipping is the operator
18:51:08 <YayMe> the result will always be a member of those 4 corner placements
18:51:11 <Cale> "then" is the operator
18:51:16 <YayMe> oh
18:51:25 <Cale> and the set is the set of ways of moving the square
18:51:34 <Cale> The set of *symmetries* of the square if you will :)
18:53:21 <ddarius> That wording/emphasis seems backwards.
18:53:38 <ddarius> @google "Homotopy theory in general categories"
18:53:40 <lambdabot> http://www.springerlink.com/index/X631213068255812.pdf
18:53:41 <lambdabot> Title: Mathematische Annalen, Volume 144, Number 5 - SpringerLink
18:54:25 <Cale> If you wanted to get formal, you'd say that we're talking about the set of all isometries (distance-preserving functions) of the plane R^2 which send the square, (say [0,1] x [0,1]) to itself.
18:54:31 <bgamari> Does anyone have any idea where Id in the GHC source is defined?
18:55:00 <Cale> YayMe: and the operation is then function composition
18:55:07 <shachaf> bgamari: compiler/typecheck/TcTyClsDecls.lhs
18:55:07 <shachaf> 86:  type Id a = a
18:55:11 <shachaf> That?
18:55:16 <bgamari> that's the one
18:55:19 <shachaf> Oh, there's more than one thing called Id.
18:55:35 <shachaf> compiler/basicTypes/Var.lhs 104:type Id    = Var       -- A term-level identifier
18:55:36 <bgamari> I guess
18:55:45 <bgamari> ahh, yes, that's the one
18:55:48 <shachaf> As well as several others.
18:55:56 <Cale> lel
18:56:03 <YayMe> Cale: Ok, that helps, your "function" had interesting behaviors I wasn't quite divining.. I would say composition is a little more than a simple function heh
18:56:10 <YayMe> err your operation
18:56:14 <bgamari> I'm looking for the non-parametric one (Var.lhz)
18:56:27 <Cale> YayMe: Well, it's a function which takes two functions and produces another
18:56:41 <Cale> YayMe: and in this case, it will take two isometries and produce another isometry
18:56:42 <YayMe> Cale: yes, but I wasn't realizing the set members were functions
18:57:01 <Cale> Right, I was saying "ways of moving the square" which was perhaps a bit hazy :)
18:57:07 <YayMe> Cale: Makes sense now though :)
18:57:19 <Cale> okay
18:57:41 <Cale> So, this operation is associative (because function composition is) and has an identity (the identity function)
18:57:48 <Cale> and moreover, there are inverses
18:57:58 <Cale> Any move that I can do to that square, I can undo it.
18:58:27 <Cale> So this is a group, the symmetry group of the square
18:59:23 <Cale> YayMe: You can imagine we can generalise this to any shape at all
18:59:31 <YayMe> Yep
18:59:39 <Cale> YayMe: after all, it's nothing special about the square which is making this a group
18:59:46 <YayMe> if you don't care where the corners lie it becomes an infinite set
18:59:51 <Cale> right
19:00:02 <Cale> the set of all isometries of the plane forms a group
19:00:28 <YayMe> I don't know this word isometries
19:00:37 * ddarius expects Cale to not stop until he's outlined the Klein program.
19:00:39 <Cale> Ah, if d(x,y) is the distance between x and y
19:00:43 <Cale> :D
19:00:47 <ddarius> YayMe: Learn Greek.
19:00:49 <ddarius> It's useful.
19:00:49 <Cale> I"M GETTING THERE
19:00:53 <Cale> lol
19:01:07 <avpx> First we're covering subgroups of S_n
19:01:19 <Polarina> mm_freak_, is there another way to "branch" wires, that is, to have the same wire evolve individually, other than by using Control.Wire.Trans.Combine? I hope I phrased that correctly. I'm making a game client where players can join and leave at will. I don't want to keep around the payer's wire when he leaves. And I want to make a new one when someone joins.
19:01:22 <Cale> An isometry is a function f such that for any x and y, d(x,y) = d(f(x),f(y))
19:01:50 <Cale> that is, the distances between any two points are preserved
19:01:58 * ddarius thinks Cale should explain some conformal groups.
19:02:39 <ddarius> Who doesn't like the word "loxodrome".
19:02:42 <Cale> Yeah, you can also talk about functions which preserve angles, but then you kinda have to really get into what angles are
19:03:06 <Cale> and YayMe hasn't had Calculus
19:03:23 <YayMe> ddarius: Sounds like the cab of an expensive BMW
19:03:26 <Cale> So I can't easily talk about the angles between curves
19:04:00 <YayMe> Cale: that reads to me like f is an identity function
19:04:05 <Polarina> mm_freak_, player's wire* -- I was looking at 'multicast' in that module. At first it seems like that's what I want, but I can't seem to be able "evolve" what's in the Traversable (1st argument) over time (player joins or leaves) as it's not an arrow input, I think...
19:04:05 <Cale> It's this really great salmon restaurant
19:04:06 <YayMe> in your example
19:04:07 <ddarius> What?!  They teach angles to children.  Clearly it must be a trivial concept.
19:04:30 <Cale> YayMe: Well, think about your moves on the square
19:04:47 <ddarius> d is a pretty arbitrary function.
19:04:49 <Cale> YayMe: any of them preserved the distances between any pair of points on the square
19:05:01 <YayMe> Oh
19:05:07 <Polarina> mm_freak_, sorry for bothering you with all these questions. I'm still new to this.. :(
19:05:22 <Cale> YayMe: Similar moves will preserve the distances between any two points in the whole Euclidean plane
19:05:47 <Cale> YayMe: Rotations, and reflections, and that's actually it (but that's a little tricky to prove :)
19:05:57 <YayMe> Right I understand that
19:06:14 <YayMe> I'm still trying to understand what f is then... a group is the set of all possible f's ?
19:06:24 <Cale> yeah
19:06:40 <Cale> So if f is say, a rotation by 30 degrees
19:06:48 <ddarius> Cale: Your inching up on the Klein program.
19:06:53 <Cale> ddarius: I know :)
19:06:58 <YayMe> right, so a group is a set of functions or only in this case?
19:07:03 <Cale> then the distance between any two points x and y will be the same as the distance between f(x) and f(y)
19:07:17 <YayMe> and an isometry is an f that meets the laws you specified
19:07:20 <Cale> YayMe: Well, only in this case, but we can represent any group as a group of functions
19:08:04 <Cale> That is, we can take the elements of the group, and find a set of functions which when composed with each other behave like our elements under multiplication.
19:08:25 <Cale> YayMe: Here's another group: the set of all nonzero real numbers, under usual multiplication
19:08:47 <Cale> Is a real number a function? Well...
19:08:52 <avpx> Or, hey, all nonzero rational numbers under multiplication
19:09:00 <Cale> sure :)
19:09:11 <avpx> Just an aside, go ahead :)
19:10:25 <Cale> You can actually kind of replace any given nonzero real number x by a function which multiplies nonzero real numbers by x
19:10:29 <ddarius> Or the set of notes under shifting pitch up or down by one step...
19:10:45 <YayMe> Cale: That's how the math fella I knew defined a group, numbers combined with an operator
19:11:03 <avpx> ddarius: Or like, anything you do that you can also undo
19:11:06 <YayMe> Cale: But I see as you said your group is a set of functions with a binary operator beign "then"
19:11:09 <Cale> YayMe: well, that works, so long as you're prepared to think of the symmetries of a square as "numbers"
19:11:17 <avpx> ddarius: Only sort of
19:12:03 <Cale> YayMe: The definition I gave initially is the real one -- just a set of things, and a way of combining any two of those things to get another, which satisfies the rules I mentioned.
19:12:09 <ddarius> Cale: They are d-numbers.
19:12:33 <avpx> Oh boy, do we get to talk about Cayley's theorem now?
19:12:58 <ddarius> Who needs Cayley when you have Yoneda?
19:13:16 <Cale> Well, I already almost did Cayley's theorem, but it went by really quickly.
19:13:34 * ddarius thinks Yoneda is actually more intuitive to most programmers.
19:13:42 <avpx> ddarius: The few among us who are not category theorists (yet)
19:14:33 <Cale> YayMe: But yeah, if you want to think of the elements of a group as functions under composition, you won't be harmed in any way by that assumption.
19:16:53 <Cale> absolutely every group G has a representation as a group of functions G -> G, by taking for each element a in G the function f_a: G -> G to be the function which just multiplies on the left by a, that is, f_a(b) = a*b.
19:17:57 <Cale> and then if we compose those functions: (f_a . f_b)(x) = f_a(f_b(x)) = f_a(b * x) = a * (b * x)
19:18:12 <Cale> but then by associativity, we have a * (b * x) = (a * b) * x
19:18:24 <Cale> and that's the same as f_(a*b)(x)
19:19:00 <ddarius> (Which is to say, (*) is a group homomorphism.)
19:19:26 <raymank26> hi all. I am trying to install CV library but I have got an error. How to fix? http://hpaste.org/75330
19:19:28 <Cale> So, just as functions, f_a . f_b = f_(a * b)
19:19:41 <Cale> (since that happens for any x)
19:20:32 <YayMe> "absolutely every group G" are you referring to multiple groups now?
19:20:58 <Cale> well, yeah, or I'm referring to any one of your choosing
19:22:12 <ddarius> Perhaps Cale is referring to the group of all groups.
19:22:34 <Cale> I just mean that even if you are antagonistic and try to pick a group for which it will be hard for me to represent as a bunch of functions, I will still be able to do so.
19:22:41 <YayMe> Ok I understand your compositino there, I did soemthing like that in haskell the other day
19:24:16 <mm_freak_> Polarina: see the context* stuff
19:24:45 <mm_freak_> Polarina: you can combine that with the wires from Control.Wire.Prefab.Move
19:25:29 <mm_freak_> Polarina: in particular see the contextLimit combinator
19:25:56 <YayMe> Cale: Ok, so your point is every group whose set may not be functions can be represented as a group whose set is functions ?
19:25:57 <mm_freak_> although it's probably not powerful enough for your application
19:26:06 <Cale> YayMe: yes
19:26:58 * ddarius could hug Ralf Hinze.
19:27:00 <mm_freak_> Polarina: i'm going to reintroduce the manager wire, which allows you to manage a dynamic set of wires
19:27:01 <Cale> YayMe: So if it helps you to think of the elements of a group as functions and the group multiplication as composition of functions, then you can go right ahead :)
19:27:19 <YayMe> Cale: SK calculus being a group whose operator is application(?) and is minimally complete to represent all groups who are defined as functions? Or did I make a terribly inaccurate logical leap?
19:27:39 <mm_freak_> Polarina: check out the haddocks in Contro.Wire…  i have greatly extended the quickstart tutorial
19:27:48 <Cale> Unfortunately not all the SK combinators have inverses
19:28:07 <Cale> and application isn't associative
19:28:16 <mm_freak_> just a few minutes ago actually =)
19:28:23 <Cale> *However*
19:28:26 <ddarius> Cale: Nor does it have a right unit.
19:28:35 <Cale> that too :)
19:29:20 <YayMe> Cale: So what I said made sense but are you saying SK is not complete?
19:29:37 <Cale> I'm saying it's not a group in the way you wanted
19:29:42 <YayMe> Ok
19:30:52 <Cale> However, composition: C f g x = f (g x) (which I could turn into a bunch of S's and K's if I wasn't lazy), will be associative
19:30:55 <ddarius> YayMe: What he and I said, is that application satisfies one (or maybe two) out of four (or five) laws that are required to hold for something to be (the operator of) a group.
19:31:13 <YayMe> ah
19:31:32 <Cale> and we can pick the SK terms which have inverses under composition, and those will be a group
19:32:01 <ddarius> We could use the BCI calculus instead ...
19:32:05 <Cale> :)
19:32:44 <YayMe> so to be a member of the set in a group you need to have an inverse?
19:33:01 <Cale> yes, that was rule number 3
19:33:17 <avpx> YayMe: Otherwise you have a monoid
19:33:22 <Cale> I'll repeat the definition now that you have more context:
19:33:33 <YayMe> oh an explanation for monoid, nice.
19:33:43 <YayMe> Cale: please do, I'm losing track heh
19:33:45 <Cale> A group is a set G together with a binary operation called multiplication *: G x G -> G such that
19:34:05 <Cale> 1) For any a, b, c in G, we have a * (b * c) = (a * b) * c -- associativity
19:34:33 <Cale> 2) There is an element 1 in G such that for any a in G, we have a * 1 = 1 * a = a  -- existence of an identity element
19:34:56 <Cale> 3) For any element a in G, there is some element b in G such that a * b = b * a = 1  -- existence of inverses
19:35:14 <YayMe> the binary operation is referred to as multiplication though that's just a common term for it?
19:35:17 <dolio> f (g x) = K f x (g x) = S (K f) g x ==> C f = S (K f) = K S f (K f) = S (K S) K f ==> C = S(KS)K?
19:35:20 <Cale> yeah
19:35:25 <topriddy> help please. I am trying to pull off a cast.
19:35:25 <Cale> It can be addition :)
19:35:44 <avpx> YayMe: Yeah. Sometimes it's called addition, but by convention that's when the operation is commutative
19:35:59 <Cale> topriddy: By 'cast' you mean like 'reinterpret_cast' in C++? Or you just mean you want a function between two types?
19:36:01 <ivanm> topriddy: shouldn't ou go to the hospital for that? :p
19:36:06 <rwbarton> topriddy: please forget you ever heard the term "cast" or "coerce" and explain what you want to do
19:36:06 <ivanm> *you
19:36:42 <avpx> YayMe: You can prove some stuff right off the bat with those laws, like the fact that there can only be one identity.
19:36:57 <YayMe> Cale: Your inverse defintion isn't clear, associativity says a * b = b * a (no?)
19:37:04 <Cale> no
19:37:12 <avpx> YayMe: That's commutativity
19:37:16 <Cale> In fact, for many of the groups we mentioned that's not true
19:37:19 <topriddy> in my case I have a factorial' which i wrote as such: factorial' :: (Integral a) => a -> a; factorial' 0 = 1; factorial' x = x * factorial' (x - 1);
19:37:22 <avpx> YayMe: Associativity is that (a * b) * c = a * (b * c)
19:37:54 <topriddy> so now I want to do factorial' (Integer :: 67); //such that I have unbounded Integer result
19:37:55 <YayMe> avpx: in the presence of commutativity you have guaranteed associativity?
19:37:59 <Cale> YayMe: Do you have a book handy? Any book will do.
19:38:02 <avpx> YayMe: Not that either
19:38:09 <ddarius> dolio: Is there a Klein program "library" in Agda?
19:38:11 <rwbarton> (67 :: Integer)
19:38:15 <ivanm> topriddy: OK, that seems OK
19:38:16 <topriddy> hopefully someone gets my question. i get parser error on last error
19:38:23 <ivanm> apart from what rwbarton pointed out
19:38:28 <ivanm> it's <value> :: <type>
19:38:30 <topriddy> isn't that a "cast" in any language?
19:38:35 <ivanm> nope
19:38:39 <dolio> ddarius: Not that I know of.
19:39:03 <ivanm> topriddy: in Java, etc. you can do (int) 67; is that what you're referring to?
19:39:26 <rwbarton> it is sort of more like writing 67LL to get a long long literal
19:39:26 * ivanm has admittedly thankfully not used Java for 3 years
19:39:39 <rwbarton> but really just don't use the word "cast" when talking about Haskell and you'll be fine :)
19:39:48 <ivanm> rwbarton: how long is long long? ;)
19:39:54 <rwbarton> rather
19:40:04 <ivanm> almost sounds like pidgin counting: one, two, many, many lots...
19:40:06 <avpx> YayMe: For an example of a group that's not commutative (we call it "nonabelian"), see S_3, the permutations on 3 elements
19:40:07 <topriddy> ivanm: somehow have been thinking in the box of the "haskell tutorial", so i intended my argument "a" to be of type Integer such that result is type "Integer"
19:40:27 <topriddy> ivanm: how have you been able to get any work done (without java). *sarcastic*
19:40:34 <rwbarton> topriddy: another thing you could do is write: x :: Integer; x = 67
19:40:38 <ivanm> quite well actually! :)
19:40:39 <rwbarton> say, at the top level
19:40:41 <rwbarton> and then use x
19:41:04 <topriddy> rwbarton: thanks for that. :)
19:41:06 <ddarius> "The long long (or Alexandroff long)"
19:41:10 <ivanm> topriddy: you can also do factorial' 67 :: Integer -- this makes the result of the function call an Integer, and thus the input must be Integer
19:41:29 * ddarius calls it "noncommutative".
19:41:54 <ivanm> yeah, I've never heard of nonabelian before
19:41:57 <topriddy> ddarius: :: is "noncommutative"
19:42:14 <avpx> ddarius: I've heard commutative/noncommutative used with ring operations and abelian/nonabelian with groups. But I guess "commutative" would be unambiguous anyway
19:42:16 <ivanm> topriddy: ddarius is referring to YayMe
19:42:19 <ivanm> not to you :)
19:42:44 <ddarius> ivanm: I've heard of it, I just think it is bad terminology offering no value of equally well-established terminology.
19:42:54 <ivanm> *nod*
19:42:56 * ddarius is responding to avpx.
19:43:11 <ivanm> ddarius: well, I meant to YayMe's question
19:43:14 <topriddy> anyway can't wait to get to other non-mathematical parts of haskell. have survived more hours learning than i did with clojure. (funnily i feel courageous to look at Clojure again)
19:43:27 <ivanm> topriddy: there are non-mathematical parts of Haskell? :o
19:43:29 <ivanm> (I kid)
19:43:47 <ddarius> There are non-mathematical parts of writing code?
19:44:00 <avpx> ddarius: See: Ruby, Python, ...
19:44:01 <topriddy> ivanm: well all the examples have done aren't something i would do in my daily real life work
19:44:14 <ddarius> avpx: Those look like formal languages to me.
19:44:26 <ivanm> topriddy: well, would the examples in learning Java, etc. be used in daily work life?
19:44:41 <ivanm> and I use factorial in my code...
19:44:42 <ivanm> ;)
19:44:59 * ddarius hopes ivanm doesn't use factorial.
19:45:43 <topriddy> ivanm: yeah. check out Java How To Program, Deitel (though I admit i had to get to like say chapter 12+ to see jdbc, swing, file, interesting stuffs)
19:45:45 <ivanm> no, I lie, I'm not using factorial in this; I thought some of the polynomials I had to solve had polynomial terms but it appears I was mis-remembering
19:46:15 <ivanm> topriddy: is that aimed at people who've never programmed before? and how realistic are the examples to real life programming?
19:46:25 <ddarius> Even if they did (and I assume you mean factorial coefficients(?)), you typically don't want to use factorial.
19:46:37 <ivanm> no, I thought i had a custom function
19:46:44 <ivanm> @src factorial
19:46:45 <lambdabot> Source not found. Just try something else.
19:46:50 <ivanm> @src product
19:46:50 <lambdabot> product = foldl (*) 1
19:47:00 <ivanm> yeah, I can see why using factorial would be bad
19:47:15 <ivanm> I _am_ using sum though
19:47:16 * ddarius always implements financial software with class Bank { double amount; public void deposit(double amt); public void withdraw(double amt); public double getBalance(); }
19:47:27 <topriddy> ivanm: i'm following my haskell tutorial very well at the moment. :)
19:47:28 <ivanm> but in this case I think the lack of the ' in the fold is manageable
19:47:39 <ivanm> ddarius: heh
19:47:45 <ddarius> ivanm: Even with a good implementation of factorial, you usually don't want to generate such large intermediate terms and, usually, can do a lot of cancellation.
19:47:50 <ivanm> yeah
19:47:54 <isomorphic> ddarius: not int?
19:48:44 <ivanm> isomorphic: nah, ddarius skipped the first lecture
19:48:48 <ddarius> isomorphic: Clearly I need to represent cents and surely no one will have more than a 2^53 cents...
19:49:04 <ivanm> ddarius: and surely no-one will have something like 10 c to worry about
19:49:16 <ivanm> only those that can be cleanly expressed in binary
19:49:27 <isomorphic> ddarius:  * 100?, and ivanm: Yes, exactly.
19:50:00 <ivanm> isomorphic: wow, what an optimisation! :o
19:52:09 * ddarius may have gotten a bit excessive with providing a computational interpretation.
19:52:16 <ddarius> Er, Ralf, not me.
19:52:59 <Grant> hi
19:53:53 <ddarius> "Like functors, adjunctions can be composed. [..] C(L2(L1(-), =) ~ D(L1(-),R2(-)) ~ E(-,R1(R2(=)).  If we view the nested functors L2(L1(-)) as a list, then the proof corresponds to the efficient version of list reversal."
19:54:49 <topriddy> a little tricky differentiating a function body declaration from pattern matching (if one is thinking with a oop brain)
19:56:10 <jmcarthur> topriddy: i don't understand what you mean
19:56:19 * ddarius joins jmcarthur in confusion.
19:56:45 <topriddy> this looks cool though. addVector :: (Num a) => ( a , a) -> (a, a) -> (a, a); addVector (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
19:57:27 <shachaf> topriddy: When you see "foo = bar", that means that anywhere you see "foo", you can replace it with "bar".
19:57:43 <shachaf> Oh, I see what topriddy means.
19:57:54 <YayMe> > 3.1 + (2.1 + 4.2)
19:57:55 <lambdabot>   9.4
19:57:56 <shachaf> That's not actually how it works when you have "(x1,x2) = (3,5)"
19:57:57 <jmcarthur> i think i do too, now
19:57:57 <YayMe> > (3.1 + 2.1) + 4.2
19:57:58 <lambdabot>   9.4
19:58:42 <jmcarthur> still not sure how to help clear it up, or what oop has to do with it
19:59:30 <topriddy> nothing actually. i'll just keep my head in the haskell box. easier that way :)
19:59:49 <topriddy> hopefully, i'm not over-trolling by discussing newbie experience here
19:59:59 <jmcarthur> not at all, as long as it doesn't get too verbose
20:00:12 <jmcarthur> it's best if there are questions behind what you're saying
20:00:31 <jmcarthur> so that you're actually interacting with us instead of using #haskell like a twitter feed
20:00:44 <jmcarthur> but you're not being annoying
20:01:51 <topriddy> oh okay. :)
20:02:21 <topriddy> well i haven't experienced this form of pattern matching before.
20:04:41 <ddarius> Fraktur Greek letters are confusing.
20:05:41 <ddarius> What?!  We're not allowed to use #haskell as a twitter feed?!  What am I going to do?!
20:06:16 <shachaf> #ohno
20:06:59 <shachaf> bgamari: I see why you were asking about Id now. :-(
20:07:40 * hackagebot network-socket-options 0.2.0.1 - Type-safe, portable alternative to getSocketOption/setSocketOption  http://hackage.haskell.org/package/network-socket-options-0.2.0.1 (JoeyAdams)
20:09:08 * ddarius needs to hug Ralf.
20:09:25 * ddarius wonders if he can dispatch shapr to hug Ralf.
20:09:47 <shachaf> @where Ralf
20:09:47 <lambdabot> I know nothing about ralf.
20:10:16 <bgamari> shachaf, This was my "fix" http://hpaste.org/75331
20:10:27 <bgamari> shachaf, Although it introduces a redundant import warning
20:10:37 <latro`a> aww, I was hoping for a fix pun
20:10:38 <latro`a> :(
20:10:52 <shachaf> fix fox = fox (fix fox)
20:11:18 <jmcarthur> bgamari: you can normally get rid of such warning by more explicitly controlling what to import from each module
20:11:21 <jmcarthur> *warnings
20:11:41 <bgamari> jmcarthur, very true
20:12:11 <bgamari> but I was assuming it was just my tree that was screwed up, so I was happy enough to find that the thing built
20:12:24 <bgamari> Tonight I'm a compiler user, not a compiler developer
20:12:33 <ddarius> shachaf: Read "Reason Isomorphically"
20:12:41 <hyperFRITZ> I read some-where you can make a fixpoint operator in Haskell's type system without ythe use of a letrec, how?
20:13:15 <shachaf> ddarius: Any context, or should I just read it in general?
20:13:16 <ddarius> hyperFRITZ: There are plenty of places providing recursion in Haskell.
20:13:22 <jmcarthur> hyperFRITZ: you can do it using recursive types, but that's its own form of fix
20:13:37 <shachaf> Hmm, looks relevant.
20:13:43 <ddarius> shachaf: Well, it's directly relevant to what we were talking about before, but you, and probably everyone else in this channel (and then some) should just read it in general.
20:13:57 <hyperFRITZ> ddarius, it is, but it's purely a theoretical enquiry.
20:13:58 <dolio> What about reasoning homotopically?
20:14:10 <hyperFRITZ> jmcarthur, yeah, I should've left those out too I guess
20:14:36 <ddarius> dolio: We don't want our code to get too flabby.
20:15:01 <hyperFRITZ> Let's put it like 'making an anonymous fixedpoint using only bound variables'
20:15:16 <jmcarthur> ddarius: this looks great already
20:15:50 <jmcarthur> i need to show one of my coworkers this. he was asking me about what it means for two types to be isomorphic recently
20:16:24 <ddarius> jmcarthur: The first two or three paragraphs sum up my view completely and the paper covers my usual examples of this.  Now I can just point people at a readable and relevant paper instead of having to Cale it.
20:17:22 <shachaf> @remember ddarius Now I can just point people at a readable and relevant paper instead of having to Cale it.
20:17:23 <lambdabot> Good to know.
20:17:31 <jmcarthur> i was about to do that, shachaf!
20:19:02 <dolio> They got the definition of "representable" backwards.
20:19:11 <bgamari> thoughtpolice, Would you expect productivity to increase (now 97%) but runtime to increase as well as a result of the pinning fix?
20:19:20 <dolio> Like everyone else in Haskell.
20:19:49 * ddarius actively uses "representable" ambiguously.
20:20:00 <ddarius> I don't use the term "corepresentable".
20:20:19 <dolio> I'm not saying I mind.
20:20:49 <dolio> I don't really like how category theorists name everything to coincide with presheaves.
20:21:20 <ddarius> dolio: Why?  Consistency with presheaves seems pretty compelling.
20:21:41 <ddarius> (Well, to a categorist.)
20:21:51 <dolio> I'm not a categorist.
20:22:02 <lpvb> I'm getting another network:URI old version expected but network recieved error and forgot how to fix that
20:22:05 <ddarius> Also, I think these have historically been more interesting to the kinds of things categorists were originally doing.
20:22:06 <lpvb> should I just use cabal-dev
20:22:44 * ddarius isn't sure how they decided which way "lax" should go.
20:22:56 <rwbarton> not very consistently :/
20:22:59 <shachaf> Oh, there's a video.
20:23:08 <shachaf> Should I watch the video or just read the paper?
20:23:14 <ddarius> shachaf: For "Reason isomorphically"?
20:23:21 <dolio> Yes.
20:23:36 <ddarius> You should read the paper.  You should probably also watch the video, but you should definitely read the paper.
20:24:40 * ddarius should give an SPJ-style talk about this.
20:24:48 <shachaf> What's an SPJ-style talk?
20:25:19 <jmcarthur> drink caffeine
20:25:22 <mapreduce> Imagine a human frog.
20:25:25 <jmcarthur> use comic sans
20:25:39 <jmcarthur> smile a lot
20:25:48 <jmcarthur> be super smart
20:25:58 <shachaf> Sounds good.
20:26:05 <mapreduce> say 'terribly exciting' every so often
20:26:25 <jmcarthur> talk with your hands
20:29:45 <isomorphic> Apologies for asking a monad question - can anybody give me an example of why one might use sequence_ instead of sequence?
20:30:34 <dibblego> isomorphic: e.g. when you are sequencing effects that produce a () result
20:30:37 <shachaf> When you don't need the result.
20:31:10 <isomorphic> Ok.  So why do you want the computation to happen at all?
20:31:23 <jmcarthur> isomorphic: for the effects
20:31:35 <dibblego> @type sequence_ [print 7, writeFile "file" "x"]
20:31:36 <lambdabot> IO ()
20:31:38 <isomorphic> jmcarthur:  Example, say for Maybe?
20:31:48 <jmcarthur> :t sequence_ [putStrLn "foo"; putStrLn "bar"]
20:31:49 <lambdabot> parse error on input `;'
20:31:53 <jmcarthur> :t sequence_ [putStrLn "foo", putStrLn "bar"]
20:31:55 <lambdabot> IO ()
20:31:57 <jmcarthur> too much ocaml
20:31:57 <isomorphic> Ah - makes sense for IO
20:32:00 <benmachine> isomorphic: then sequence_ behaves a bit like any isJust
20:32:14 <benmachine> (except returning Maybe () instead of Bool)
20:32:35 <jmcarthur> those are isomorphic!
20:32:50 <shachaf> Not in Haskell. :-(
20:32:53 <benmachine> jmcarthur: Maybe () has an extra bottom, no?
20:32:53 <jmcarthur> do i really have to say "ignoring _|_" every time?
20:33:01 <ddarius> Yes.
20:33:06 <ddarius> (ignoring bottom)
20:33:08 * jmcarthur sighs
20:33:12 <shachaf> jmcarthur: Just like you have to say "up to isomorphism" every time!
20:33:19 <shachaf> Those are isomorphic (up to isomorphism)!
20:33:20 * jmcarthur double sighs
20:33:21 <benmachine> jmcarthur: no, you just have to allow me my opportunity to prove I am paying attention :p
20:33:24 <rwbarton> or you can go to #agda
20:33:36 <jmcarthur> i am in #agda :P
20:33:42 <rwbarton> well, talk in #agda :)
20:34:03 * shachaf notes that rwbarton is not in #agda.
20:34:09 <isomorphic> Actually - while you're all here - all this talk of _|_ and sometimes which types are inhabited - what book would you recommend?
20:34:26 <rwbarton> it's true
20:34:41 <benmachine> I'm not in #agda
20:34:43 <benmachine> I was for a while
20:34:59 <solrize> isomorphic, http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
20:35:01 <benmachine> but I got mostly hopelessly lost
20:35:13 <shachaf> I'm in #agda but all I ever do there is pretend that Agda is Haskell and confuse people (often myself).
20:35:26 <benmachine> I think I gave up on agda while trying to prove that Bijection (suc n) (suc m) → Bijection n m
20:35:33 <EvanR2_> is [1..] the same as _|_ ?
20:35:37 <benmachine> EvanR2_: no
20:35:53 <jmcarthur> benmachine: what was that unicode symbol. implies?
20:35:55 <isomorphic> solrize:  Perfect, thanks.  I think I have a book that includes stuff about denotational semantics, somewhere :/
20:36:01 <benmachine> jmcarthur: it was just rightarrow, actually
20:36:06 <EvanR2_> because theres a weak head normal form?
20:36:17 <jmcarthur> benmachine: same difference
20:36:24 <dmwit> is last [1..] the same as _|_?
20:36:25 <benmachine> jmcarthur: no, implies is Rightarrow :P
20:36:28 <dolio> ddarius: Man, that paper really has all your favorite stuff in it.
20:36:43 <benmachine> EvanR2_: there is, and much else besides
20:36:49 <jmcarthur> benmachine: rightarrow has an interpretation as implies, too
20:37:03 <dmwit> > BS.pack [32]
20:37:04 <lambdabot>   " "
20:37:12 <benmachine> jmcarthur: oh, sure, but when someone says "implies" to me I think "\implies"
20:37:18 <dmwit> > BS.pack [last [1..]]
20:37:19 <lambdabot>   "\255"
20:37:27 <benmachine> which is a double-line thingy
20:37:34 <benmachine> that apparently my compose key won't produce :(
20:38:17 <EvanR2_> is last [1..] the same as _|_?
20:38:28 <dmwit> EvanR2_: no, because
20:38:29 <dmwit> > BS.pack [last [1..]]
20:38:30 <lambdabot>   "\255"
20:38:32 <dmwit> =)
20:38:43 <EvanR2_> lol
20:38:45 <barrucadu> Sorcery!
20:39:12 <EvanR2_> [1..] :: [Word32]
20:39:15 <EvanR2_> > [1..] :: [Word32]
20:39:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:39:23 <EvanR2_> > last [1..] :: Word32
20:39:27 <lambdabot>   mueval-core: Time limit exceeded
20:39:32 <EvanR2_> > last [1..] :: Word8
20:39:33 <lambdabot>   255
20:39:45 <EvanR2_> frak all yall
20:39:45 <rwbarton> is there an agda-like language with extensional equality for functions that actually exists?
20:39:48 <Jesin> last [6..] :: Integer
20:39:50 <Jesin> > last [6..] :: Integer
20:39:54 <lambdabot>   mueval-core: Time limit exceeded
20:39:54 <jmcarthur> last [1..] :: Word32  actually happens pretty quickly
20:40:03 <dolio> What qualifies as agda-like?
20:40:09 <Jesin> extensional equality...?
20:40:15 <Jesin> that sounds difficult
20:40:17 <rwbarton> "I can try to prove stuff in it"
20:40:21 <rwbarton> and it's not Coq
20:40:25 <dolio> NuPRL.
20:40:32 <ddarius> Yay NuPRL.
20:40:32 <dmwit> jmcarthur: It's still running here, and I started it when EvanR2_ said it in-channel.
20:40:40 <dmwit> oop, just finished
20:41:16 <EvanR2_> hmm @ last [1..] :: Integer
20:41:17 <lispy> rwbarton: I don't know if idris qualifies wrt extensional equality, but it's between haskell and agda
20:41:28 <startling> what should I name a function that lifts a function into a Writer that fits my api?
20:41:38 <shachaf> lispy: I really doubt it qualifies.
20:41:43 <EvanR2_> > [False..]
20:41:43 <rwbarton> yeah I played around with idris a little bit, but not for proving things in
20:41:44 <lambdabot>   <no location info>: parse error on input `]'
20:41:50 <EvanR2_> > [False ..]
20:41:51 <lambdabot>   [False,True]
20:42:06 <shachaf> Extensional equality for functions would be farther in the direction of Agda than Agda, presumably.
20:42:09 <dibblego> startling: depends on its type
20:42:17 <ddarius> *further
20:42:22 <jmcarthur> EvanR2_: technically there is a limit to the gmp implementation of Integer, but i think it's large enough that no conventional computer can represent it anyway
20:42:23 <lispy> You can fake extensional equality in agda though
20:42:48 <shachaf> @wn farther
20:42:49 <lambdabot> *** "farther" wn "WordNet (r) 3.0 (2006)"
20:42:49 <lambdabot> farther
20:42:49 <lambdabot>     adv 1: to or at a greater extent or degree or a more advanced
20:42:49 <lambdabot>            stage (`further' is used more often than `farther' in
20:42:49 <lambdabot>            this abstract sense); "further complicated by uncertainty
20:42:50 <rwbarton> yes but I find it such a pain
20:42:51 <lambdabot> [18 @more lines]
20:42:52 <dolio> Yeah, but NuPRL is just extensional type theory.
20:42:54 <shachaf> @wn further
20:42:54 <lambdabot> *** "further" wn "WordNet (r) 3.0 (2006)"
20:42:55 <lambdabot> further
20:42:57 <lambdabot>     adv 1: to or at a greater extent or degree or a more advanced
20:42:57 <dolio> So you don't have to fake it.
20:42:59 <lambdabot>            stage (`further' is used more often than `farther' in
20:43:01 <lambdabot>            this abstract sense); "further complicated by uncertainty
20:43:03 <lambdabot> [24 @more lines]
20:43:13 <shachaf> Hm.
20:43:27 <ddarius> "Farther" is typically constrained to referring to physical distance.
20:43:29 <EvanR2_> jmcarthur: hmm
20:43:43 <rwbarton> what if it's a metaphorical physical distance?
20:43:46 <ddarius> The theory of NuPRL is certainly worth looking at.
20:43:57 <liyang> rwbarton: that's okay too.
20:45:12 <startling> dibblego: (File -> File) -> RWS [File] Result (), where Result has a "files" field
20:46:27 <thoughtpolice> bgamari: hm, no. runtime increase could be because of the new code generator though. simon enabled it in HEAD after ghc 7.6.1 was released. sometimes it's better, sometimes it's slower
20:46:34 <thoughtpolice> bgamari: but now that means it should mostly get better :)
20:49:27 <bgamari> thoughtpolice, Any way to disable it?
20:50:00 <dmwit> ?unmtl RWS [File] Result ()
20:50:00 <lambdabot> Plugin `unmtl' failed with: `RWS [File] Result ()' is not applied to enough arguments, giving `/\A. [File] -> () -> (A, (), Result)'
20:50:08 <dmwit> startling: kind error
20:50:18 <thoughtpolice> bgamari: i don't think so, you'd have to check the git logs. it was pretty recent, but i don't think simon put any sort of backwards-compat flag in
20:50:57 <dmwit> But, just looking at the type of the argument, perhaps something like "modifyFile"?
20:51:23 <dmwit> or "mapFiles" or something like that if it is applied to more than one file?
20:51:24 <startling> @unmtl RWS [File] Result () ()
20:51:25 <lambdabot> [File] -> () -> ((), (), Result)
20:52:19 <startling> dmwit, yeah, mapFiles sounds good
20:53:01 <startling> I think I'm actually going to turn a File -> File into a RWS File Result and thence to a RWS [File] Result
20:55:15 <copumpkin> > let f x = sqrt(pi)*(x/exp 1)**x*(((8*x + 4)*x + 1)*x + 1/30)**(1/6) in f 5
20:55:16 <lambdabot>   120.00014706585664
20:55:19 <copumpkin> > let f x = sqrt(pi)*(x/exp 1)**x*(((8*x + 4)*x + 1)*x + 1/30)**(1/6) in f 6
20:55:20 <lambdabot>   720.0004424025802
20:55:29 <copumpkin> > let f x = sqrt(pi)*(x/exp 1)**x*(((8*x + 4)*x + 1)*x + 1/30)**(1/6) in f 10
20:55:30 <lambdabot>   3628800.3116126074
20:56:07 <copumpkin> > let f x = sqrt(pi)*(x/exp 1)**x*(((8*x + 4)*x + 1)*x + 1/30)**(1/6) in f 20
20:56:09 <lambdabot>   2.43290202196162e18
20:56:09 * ddarius wonders if he can make a nice thing with that using a Mellin transform.
20:56:16 <copumpkin> > product [1..20]
20:56:17 <lambdabot>   2432902008176640000
21:04:54 <Cale> mmmm... melon transform
21:05:15 <larskinn> merlin transform? *zap*
21:07:38 <DSade> No one uses Haskell they told me
21:07:39 <ddarius> Dammit, I need to finish that paper on the zeta function.
21:07:43 <DSade> 895 nicks...
21:07:53 <ddarius> Don't worry, 894 are bots.
21:08:10 <DSade> Than...what am I?
21:08:11 <DSade> and you
21:08:13 <DSade> my God
21:09:12 <zerowaitstate> it's full of stars
21:12:10 <ddarius> Oo.  I like (right) Kan extensions as weakest post-specifications.
21:13:30 <startling> how do I map a reader over the current reader state?
21:16:19 <startling> well, a MonadReader.
21:16:31 <startling> can I, even?
21:17:32 <startling> I want to turn a MonadReader e x into a MonadReader [e] [x]
21:18:28 <EvanR2_> map + uncurry + runReader
21:19:11 <sclv> Reader r a is an alias for r -> a, so turning r -> a to [r] -> [a] is straightforward, and that gives your solution
21:19:26 <sclv> a wrapping of, not an alias for
21:19:27 <latro`a> Reader and MonadReader aren't the same thing
21:20:25 <startling> sclv, EvanR2_: I want this to work on any MonadReader
21:21:09 <rwbarton> well "a MonadReader" is not even general in the type r
21:21:49 <sclv> yeah you really can't do that
21:22:45 <rwbarton> I can give you a type MyMonad and an instance MonadReader (String,Bool) MyMonad and you have no way of constructing a "corresponding" type which is an instance of MonadReader [(String,Bool)]
21:23:04 <sclv> you can write it for any given instance of MonadReader (or rather any instance built with ReaderT) but not in general general.
21:25:08 <startling> darn. alright. :/
21:25:24 * ddarius recommends the terms "abstract general" and "concrete general" to sclv.
21:26:32 <sclv> nice terms
21:26:48 <sclv> yours?
21:27:30 <ddarius> Lawvere's.
21:28:42 <sclv> he always has a knack for terms
21:30:28 * ddarius should make a follow-on paper to "Reason Isomorphically" called "Reasoning Continuously".
21:32:40 <pnielsen> http://pdos.csail.mit.edu/scigen/
21:32:59 <pnielsen> for inspiration :)
21:37:03 <osa1> is LLVM haskell bindings complete enough to port kaleidoscope tutorial to haskell ?
21:40:20 <Ralith> osa1: no.
21:40:32 <Ralith> osa1: my branch will get you very close, though.
21:41:18 <Ralith> see https://github.com/bos/llvm/pull/39
21:42:04 <randomclown> How to encode "epsilon" in Happy?
21:42:59 <randomclown> oh found it
21:43:49 <osa1> Ralith: thanks. it says it depends on llvm-base >= 3.0.0.1, how are you handling API changes between 3.0 and 3.1 ? I'm asking this because I'm now reading the tutorial for 3.1 and it doesn't work on 3.0 because of API changes
21:45:15 <Ralith> osa1: the LLVM C API is less subject to upheaval than the C++ API.
21:45:19 <Ralith> the bindings are against the C API.
21:46:08 <Ralith> osa1: also, if you want to port the tutorial, I'd be very happy to accept patches that add in the missing pieces--they should be few and far between.
21:46:56 <osa1> Ralith: sure.
21:48:03 <Ralith> to be clear, there's a fairly complete FFI binding, but not all (merely most) of it has been wrapped in a convenient-to-use-in-Haskell way.
21:48:35 <Ralith> (C strings and arrays and so on are awfully awkward to work with directly)
21:49:32 <osa1> hmm, I'm not experienced in working with FFI, I only worked a little with SDL bindings. but let's see ..
21:52:16 <Ralith> there are plenty of examples, and the raw bindings themselves are, again, already there.
21:52:43 * hackagebot type-spine 0.2.20120924 - A spine-view on types  http://hackage.haskell.org/package/type-spine-0.2.20120924 (NicolasFrisby)
21:52:45 * hackagebot yoko 2.0 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-2.0 (NicolasFrisby)
22:04:07 <Hugglesworth> having weird (at least I think they're weird) stack space overflow issues
22:04:15 * Hugglesworth finds hpaste
22:08:09 <hpaste> huggles pasted “dna” at http://hpaste.org/75332
22:09:14 <Hugglesworth> I've looked at the articles about similar issues
22:09:43 <Hugglesworth> I think it's tail recursive
22:09:44 <Hugglesworth> and I think it's strict
22:09:44 <Hugglesworth> but I guess it's still building up thunks?
22:10:12 <Hugglesworth> file being run on is 213M of ascii
22:11:59 <Hugglesworth> clearly non-optimal code BTW
22:12:08 <Hugglesworth> pretty hacked together
22:14:55 <latro`a> fmap f . fmap (map g) . fmap h = fmap (f . map g . h), for one thing :/
22:17:08 <Hugglesworth> yup
22:17:29 <Hugglesworth> I've been copying and pasting and moving all about
22:17:36 * Hugglesworth is a messy coder
22:17:43 * hackagebot Boolean 0.1.0 - Generalized booleans  http://hackage.haskell.org/package/Boolean-0.1.0 (ConalElliott)
22:18:22 <latro`a> uh
22:18:28 <latro`a> in combine you only seq the left
22:18:46 <latro`a> that's probably the problem?
22:18:55 <latro`a> I'm also not sure why you're using tuples at all btw
22:19:19 <ddarius> BangPatterns for two thing
22:19:27 <ddarius> :t foldl'
22:19:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:19:36 <latro`a> as they are not really desirable unless you have heterogeneity, which you don't
22:19:36 <latro`a> and yeah bang patterns will save you some pain
22:19:44 <ddarius> s/some/quite a bit/
22:19:47 <ddarius> +of
22:20:40 <ddarius> The seqs are in the tuple, so they aren't quite as useful as you would want...
22:20:52 <ddarius> latro`a: The left side is the side that matters.
22:21:09 <latro`a> oh, you're right
22:21:30 <ddarius> combine is strict in both arguments, but not in the components of the first argument.
22:22:28 <ddarius> Also, from a performance and a not-having-to-use-the-relatively-new-BangPatterns-extension, making an explicit strict unpacked type will probably solve all these problems and allow some optimizations.
22:22:45 * hackagebot vector-space 0.8.3 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.8.3 (ConalElliott)
22:23:06 <ddarius> Of course, this may also be overkill (albeit it doesn't really add much code, more will be removed).
22:24:04 <ddarius> In that vein, the numeric components are likely defaulting to Integer which probably is overkill unless you are expecting to run this on a 32-bit architecture with billions of base-pairs as input.
22:25:56 <ddarius> Admittedly, you'll probably be IO-bound pretty quickly even with a pretty crappy representation.
22:26:15 <ddarius> (Which readFile will definitely give you.)
22:26:19 <latro`a> IO-bound?
22:28:22 <ddarius> The code will be limited by how quickly the OS can fill buffers from disk.
22:28:57 <latro`a> ah
22:29:03 <isomorphic> latro`a:  I was thrown by the reference to representation too
22:30:07 <ddarius> :t readFile
22:30:08 <lambdabot> FilePath -> IO String
22:30:34 <Hugglesworth> thanks, I'll try that out tomorrow
22:30:36 <ddarius> String is about 12/24 bytes per, likely, byte of input.
22:33:27 <isomorphic> ddarius:  Is there a way of figuring that figure of 12/ 24 bytes in ghci?
22:38:58 <ddarius> You can (reasonably) determine whether you are on a 32 or 64 bit system (and have a corresponding build of GHC) pretty easily, but you probably don't need to run a program to know this.
22:39:21 <ddarius> To know how big String actually is, though, is not exposed and not something you could guaranteedly determine.
22:47:01 <seth_s> Hi all, I am new, and wondering if there is any good way to compose functions without abusing parenthesis
22:47:23 <seth_s> specifically functions that take more than one argument like map or filter
22:48:32 <latro`a> . and $ are your friends, basically
22:48:48 <seth_s> I'll read up on them.  Thank you!
22:48:54 <latro`a> np
22:49:14 <seth_s> Do they work well with bringing arguments across multiple lines?
22:49:29 <latro`a> assuming I know what you mean, yes
22:49:33 <seth_s> I'm a lisp programmer and like to split things in a way that seems un-haskel like
22:49:46 <latro`a> foo = somefun $ do <whole do block on subsequent lines>
22:49:47 <seth_s> something like (map
22:49:49 <latro`a> is not at all uncommon
22:50:11 <seth_s> lets see if my irc client will let me do this
22:50:13 <seth_s> (map
22:50:18 <seth_s>     (some expression)
22:50:24 <seth_s>     (some list))
22:50:37 <seth_s> can I break things up like that in haskell?
22:50:37 <latro`a> I would discourage that a fair portion of the time
22:50:43 <latro`a> but yes, you can
22:50:49 <latro`a> I just wouldn't do it as often as you might in lisp
22:50:56 <MostAwesomeDude> > map (+1) [1..5]
22:50:57 <lambdabot>   [2,3,4,5,6]
22:51:42 <seth_s> Yeah, that seems like it would work for small problems
22:51:54 <latro`a> the thing is that you tend to make everything small
22:51:58 <latro`a> and then put them together
22:51:59 <seth_s> when either expression grows large, do you usually define the functions outside of that?
22:52:00 <MostAwesomeDude> Well, if your problem isn't small enough, just refactor.
23:04:37 <hpaste> mgsloan annotated “Code style for seth_s” with “Code style for seth_s” at http://hpaste.org/75335#a75336
23:05:37 <dmwit> seth_s: If the expressions grow large:
23:05:48 <dmwit> map wellNamedFunction wellNamedList where
23:05:51 <dmwit>   wellNamedFunction = ...
23:05:55 <dmwit>   wellNamedList = ...
23:06:48 <mgsloan> dmwit: sure sure, but sometimes there's not a good name ;)
23:07:00 <mgsloan> maybe only when you're name-challenged
23:07:43 <mgsloan> seth_s: http://hpaste.org/75335#a75336
23:08:18 <dmwit> Well, in dire need, map f xs where { f = ...; xs = ... }
23:08:22 <ddarius> @name
23:08:23 <lambdabot> Local time for ddarius is Wed Sep 26 02:08:01
23:08:29 <ddarius> Er, not what I wanted.
23:08:42 <ddarius> Ah, yes.
23:08:44 * ddarius remembers.
23:08:45 <ddarius> @fresh
23:08:45 <lambdabot> Hahq
23:08:52 <hpaste> mgsloan annotated “Code style for seth_s” with “Code style for seth_s (annotation)” at http://hpaste.org/75335#a75337
23:09:00 <mgsloan>  @fresh
23:09:31 <dmwit> ?botsnack
23:09:31 <lambdabot> :)
23:09:33 <dmwit> hm
23:09:38 <dmwit> she doesn't like you =)
23:31:05 <stragerTelnet> Hello, world!
23:33:55 <ddarius> Why am I not sleeping?
23:56:57 <ddarius> @tell shachaf Exercise: Any category that is small and complete is also cocomplete.  Hint: This is a direct generalization of the lattice theoretic result, e.g. the supremum of the empty set is the infimum of the whole lattice.  Extra credit: What is the dark secret of this exercise?
23:56:57 <lambdabot> Consider it noted.
