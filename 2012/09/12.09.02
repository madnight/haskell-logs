00:01:18 <sheldonh> LYH is working so much better for me than RWH was! wow
00:01:43 <sheldonh> sadly, comparisons like this are always fraught, because you take what you learned from the first book into your experience of the second :)
00:01:53 <thirsteh> LYAH is more approachable
00:02:02 <thirsteh> and a little more coherent, IMO
00:02:12 <thirsteh> but both are great
00:02:48 <thirsteh> RWH has more practical/real-world examples, surprisingly
00:03:00 <sheldonh> it's like puppet and chef (two configuration management systems). i've interviewed a lot of people who've used both, and all of them settled on the second one they tried :)
00:05:43 <adnauseam> it is all a journey
00:05:51 <isBEKaml> hi, did System.Posix.Internals disappear from base at some point of time?
00:05:58 <sheldonh> adnauseam: until the end :)
00:06:26 <isBEKaml> (since I see it in base-3.0.3.2, but not in 4.5.1.0)
00:06:31 <adnauseam> indeed!
00:06:40 <amiller> ddarius, is there a more precise word than 'regular datatype' to use there? algebraic datatype?
00:07:59 <amiller> there's a "regular" package so maybe that is precise
00:08:04 <ddarius> Regular data type is a technical term, that I didn't define.
00:09:13 <ddarius> sheldonh: The fact that you were exploring another option already suggests discontent with the first, for whatever reason.
00:09:46 <adnauseam> that makes good marital advice, too
00:09:49 <ddarius> Though, most "regular" data types are regular.  Generally polynomial (sum of products) types are regular.
00:11:54 <sheldonh> ddarius: yup. i'm hinting at a pattern of inappropriate evaluation of worth, when a common source of discontent is a poor initial understanding of the problem space
00:12:26 <sheldonh> ddarius: they *all* insist that the one they tried second is "just easier to understand" :)
00:13:51 <sheldonh> ddarius: hmmmm.... i'm assuming. maybe there are just three kinds of people in this world. people who prefer chef, people who prefer puppet, and people who haven't used either one :)
00:14:06 <ddarius> sheldonh: I'm mostly agreeing but also pointing out a selection bias, namely that, presumably, people who were happy with whatever they used first never tried the other.
00:14:09 <ddarius> sheldonh: Yes.
00:14:15 <sheldonh> :)
00:18:11 <sheldonh> oh. the field of music production with haskell has already been pioneered. i'm going to have so much fun :)
00:18:25 * ddarius needs to figure out how to write the composition of a sequence of overlapping Givens rotations as a single, efficient, monolithic, purely functional operation.
00:19:10 <ddarius> If you don't care too much about real-time performance, you can have a lot of fun doing sound synthesis with just lazy lists.
00:20:35 <sheldonh> ddarius: nice pun :)
00:22:20 <ivanm> since when has "cabal test" redirected stdout?
00:22:30 <ivanm> I was getting a tad worried when my test suite wasn't printing anything...
00:22:38 <ivanm> (and thought there might have been some kind of loop)
00:22:51 <thirsteh> is there a nice way to "generate" random numbers for STM transactions? I have a variety of things that could need random numbers depending on what happens inside a transaction. Right now I'm thinking I'll have some threads replenishing a bunch of random pools and retrying on them
00:23:43 <thirsteh> sorry, I realize it's a ridiculously broad question
00:24:35 <ivanm> thirsteh: keep a seed in a TVar?
00:24:55 <thirsteh> oh, doh. Of course
00:25:31 <thirsteh> perfect, cheers
00:29:38 * ddarius hopes hmatrix has a dynamic programming-like matrix creating function.
00:29:55 <ddarius> I guess I could make one if need be...
00:32:32 <sheldonh> LYH says members of Ord must be members of Eq. that seems weird to me, because you can implement == in terms of <=>, but not vice versa
00:33:02 <sheldonh> ugh, that's just more OO brain damage on my part :(
00:33:16 <sheldonh> types are not about implementation :)
00:34:16 <ddarius> Even in OOP, you'd typically have an Ord interface extend an Eq one.  You certainly wouldn't do it the other way.
00:34:38 <covi> Hi everyone. What can I do to retrieve an optional argument?
00:34:58 <ddarius> What optional arguments?
00:35:00 <thirsteh> besides, == is more efficient unless <=> is optimized
00:35:15 <covi> ddarius: like the opens we can with <- getArgs
00:35:33 <sheldonh> thirsteh: implementation detail :)
00:35:41 <ddarius> covi: getArgs just gives you a list of strings.  You can handle them however you want.
00:36:01 <thirsteh> sheldonh: exactly, instances of Eq and Ord can be quite different
00:36:36 <covi> ddarius: I mean, what should I write on the left side of <-, in order to prevent failure if the optional argument is not supplied by users?
00:37:37 <thirsteh> covi: xs <- getArgs
00:37:57 * pp
00:38:06 <thirsteh> rather than (a,b,c) <- getArgs
00:38:21 <thirsteh> [a,b,c] *
00:38:27 <sheldonh> i've forgotten how to inspect the precedence of an operator in ghci
00:38:46 <sheldonh> ha! :info :) :) :)
00:38:50 <pp> :i (+)
00:38:51 <covi> thirsteh: then, I check the occurance of optional arguments by what?
00:39:23 <covi> If there's only one such optional argument I can check the length of args to know.
00:39:25 <hpaste> rosie pasted “do block nested in an if-then-else” at http://hpaste.org/74097
00:39:36 <sheldonh> ah, but :: isn't a function. how tightly do type notations bind?
00:40:01 <dmwit> sheldonh: x == y = compare x y == EQ -- is a perfectly good implementation of (==)
00:40:19 <startling> sheldonh: very loosely, iirc
00:40:49 <rosie> Anyone know why my do block nested in an if statement gives a syntax error? (the indentation of the else is only off in hpaste)
00:41:10 <startling> rosie: where?
00:41:13 <thirsteh> covi: you can check the length of the list no matter what
00:41:19 <dmwit> rosie: You must align "div" with "h4".
00:41:28 <dmwit> rosie: All lines in a do block must align.
00:41:35 <thirsteh> covi: I would use a guard to check the length or something, but if there many options, I would look at something similar to getopt/something that returns an association list instead
00:41:37 <rosie> http://hpaste.org/74097
00:41:43 <ddarius> rosie: Also stop using tabs...
00:41:49 <rosie> dmwit: That's hpaste throwing off the indentation
00:41:51 <rosie> ah sorry
00:41:56 <thirsteh> covi: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
00:42:17 <jtza8> Is there a functional equivalent to the OOP MVC pattern?
00:42:32 <dmwit> rosie: Well, paste the actual code, then.
00:42:34 <ddarius> rosie: Unless you have your tabs set to 8 characters, what the compiler sees and what you see are different.
00:42:38 <covi> thirsteh: thx
00:42:47 <dmwit> We certainly can't guess what's wrong if you paste something different than what you have.
00:43:33 <ddarius> dmwit: As history has proved time and again, people here can certainly guess.  Occasionally accurately too.
00:43:35 <dmwit> Oh, now I understand what you're saying, I think. And you're wrong, it's your editor whose alignment is off. =)
00:44:04 <dmwit> (But the alignment of the "else" wasn't in question anyway in my suggested fix.)
00:44:19 <sheldonh> jtza8: check this out: http://www.yesodweb.com/
00:44:36 <jtza8> sheldonh: Thanks.
00:44:38 <ddarius> Until the mucked things up recently, there were no rules about else and layout.
00:44:57 <dmwit> um
00:44:59 <Saizan> $ after then is an error too
00:45:28 <dmwit> I mean, that is sort of true, but there was always an interaction between the layout rules and the syntax rules for if-then-else.
00:45:43 <ddarius> Not any more than between the syntax of everything else.
00:45:52 <dmwit> I agree with that.
00:46:30 <sheldonh> jtza8: i made the terrible assumption of assuming you meant type 2 MVC for web applications :)
00:48:14 <thirsteh> jtza8: and http://snapframework.com/, and http://happstack.com/
00:49:18 <covi> There's a function inside a let which in turn is inside a do block. How do I write that function (where seems not working)
00:49:41 <dmwit> you just... write it?
00:50:08 <dmwit> do { let { foo x = x }; bar }
00:50:20 <thirsteh> covi: try to write it, then paste if it doesn't work
00:50:46 <covi> dmwit: the function is like  foo x = x   foo y = y  and several other cases
00:51:06 <dmwit> do { let { foo x = x; foo y = y; and several other cases }; bar }
00:51:45 <covi> I wrote that, didn't work. I'm pasting my code now
00:52:13 <covi> http://hpaste.org/74098  Please take a look, thx
00:52:42 <covi> Darn
00:52:42 <dmwit> line 36 is indendent incorrectly
00:52:44 <covi> My bad..
00:53:23 <mikeplus64> covi: your editor is mixing tabs and spaces, which can be problematic
00:53:34 <ddarius> You also can't spread function definitions over different parts of the program if that's what you are trying to do with parse.
00:53:54 <covi> mikeplus64: Should I always use spaces?
00:53:56 <ddarius> Also, avoid length and (!!).
00:53:58 <ddarius> covi: Yes.
00:54:07 <dmwit> covi: No, but you do need to be consistent and know the rules.
00:54:10 <covi> ddarius: why avoid those two
00:54:44 <pp> performance reason?
00:54:54 <ddarius> covi: Because they perform poorly, are partial, are rarely necessary or desirable, and lead to writing code in an unidiomatic manner.
00:55:53 <mikeplus64> if you're using a lot of length and !! then maybe what you want is an array (or vector)
00:56:00 <dmwit> case rawArgs of { (_:fileListPath:destDir:_) -> ...; _ -> ... }
00:56:08 <covi> ddarius: Then how should I approach this (getting the optional argument) without messing with getopt?
00:56:19 <dmwit> covi: pattern match, using my hint
00:56:29 <covi> dmwit: ah I see
00:56:32 <covi> dmwit: thx
00:56:56 <pp> anyone has good examples using parsec? :) already read the chap in rwh, but some details are still confusing..
00:57:18 <dmwit> Define "good".
00:57:59 <ddarius> dmwit: Well clearly pp doesn't want -evil- examples.
00:58:10 <pp> hmm.. basically, i can't find any examples except for rwh... :P
00:58:11 <dmwit> http://hackage.haskell.org/packages/archive/xmonad-extras/0.10.1/doc/html/src/XMonad-Actions-Volume.html#amixerGetParser is an example
00:58:11 <startling> what about chaotic neutral?
00:58:43 <dmwit> Type "amixer get" in a terminal to see the format it's parsing.
00:58:54 <amiller> okay so neither a :< (Trunk :. m) nor a :< (m :. Trunk) seem to work quite right, maybe I can put the monad inside the algebra for a, instead of next to trunk
00:59:18 <pp> dmwit: thx :)
01:01:44 <dmwit> http://hackage.haskell.org/packages/archive/sgf/0.1.1/doc/html/Data-SGF.html has a slightly more involved example
01:03:05 <pp> i've been learning haskell for a while, but still have much difficultiy in writing any useful code...
01:04:06 <covi> dmwit: http://hpaste.org/74098 check the annotation pls? I wrote let's after ->, but there was parse error on line 38
01:04:43 <dmwit> Outside of do blocks, "let"s must have an "in".
01:04:58 <covi> Right
01:05:04 <Z`> hey people. why this: sqr x = x*x    sumOfSquares xs = sum . (map(\x -> sqr x) xs) doesn't work ? (although it does if I replace . with $ or if I write sum(map(...)))
01:05:20 <covi> But then if I can't use let, what should I do to 'assign' the values
01:05:30 <dmwit> Z`: (.) is function composition; map (\x -> sqr x) xs is not a function.
01:05:42 <Z`> ooops, thanks dmwit !
01:05:47 <dmwit> covi: You don't assign them, you just use them.
01:06:46 <covi> dmwit: But that means I have to write the following actions after each ->, right?
01:07:08 <covi> The problem is, actions in these two cases are similar, so it would be verbose
01:08:19 <dmwit> Write a function.
01:08:43 <startling> covi: use a where
01:08:44 <Jafet> @pl \x -> sqr x
01:08:44 <lambdabot> sqr
01:08:49 <simplicio> use a let
01:09:20 <hpaste> dmwit annotated “....” with “.... (annotation) (annotation)” at http://hpaste.org/74098#a74100
01:09:35 <dmwit> covi: By the way, why are you throwing away the first argument?
01:09:57 <sheldonh> dmwit: i think that's called a straw man ;)
01:10:16 <dmwit> That's a wonderful pun, thank you sheldonh.
01:10:25 <sheldonh> *baddadush*
01:12:25 <covi> dmwit: I see ur annotation
01:12:40 <covi> Is using a helper function common in such case?
01:12:51 <ddarius> It's what functions are for.
01:15:46 <sheldonh> so far it looks like this to me: if you can't understand the body without x, put x in a let. if x is an implementation detail, put it in a where. if x is useful outside just this body, pull it up.
01:17:23 <shachaf> That heuristic doesn't sound right.
01:17:29 <Jafet> Wait, people decide to use let and where on other grounds than saving indentation?
01:18:52 <Reactionary> Jafet: let and where do not mean the same thing.
01:19:09 <Reactionary> Jafet: let bounds a nested definition to an expression, where bounds At this point in the tutorial, you should have a strong enough grasp of the arrow machinery that we can start to meaningfully tackle the question of what arrows are good for.
01:19:10 <Reactionary> [edit]Stream processing
01:19:11 <Reactionary> [edit]Avoiding leaksit to a value.
01:19:14 <Reactionary> damn
01:19:15 <Reactionary> sorry
01:19:18 <Reactionary> Accidental paste.
01:19:30 <Reactionary> let bounds the nested definition to an expression
01:19:32 <shachaf> I suspect Jafet knows the difference between let and where.
01:19:38 <Reactionary> Well...
01:19:54 <Reactionary> shachaf: Then why would he ask that? :-S
01:20:00 <Jafet> They do mean the same thing in the situations where you can reasonably expect to have to choose between them.
01:21:13 <Jafet> lololol "avoiding leaks"
01:21:44 <Reactionary> Jafet: It was text I selected from another site.
01:22:02 <Jafet> Isn't that just referring to arrow FRP?
01:22:23 <Reactionary> urxvt uses the mouse to copy/paste text, and the part of my hand that is under my thumb keeps accidentally touching my touchpad
01:22:57 <Jafet> Where naïve FRP leaks all over
01:23:25 <Reactionary> lol
01:26:20 <covi> Is using a helper function common in such case?
01:26:26 <covi> Wrong msg.  Sorry.
01:27:03 <ddarius> :t signum
01:27:04 <lambdabot> forall a. (Num a) => a -> a
01:27:06 <amiller> ddarius, there's an option "-XDerivingFunctor" that works for Trunk, and automatically fills in the functor, when there's exactly one available
01:27:10 <ddarius> > signum 3
01:27:11 <lambdabot>   1
01:36:57 <sheldonh> shachaf: about that heuristic... can you gimme some criticism or refinement?
01:37:34 <dmwit> "always use where"
01:37:51 <dmwit> There's also the popular "go with your heart".
01:40:49 <sheldonh> dmwit: well, not everything is less than 3
01:41:33 <dmwit> Yeah, there's 0, 1, and infinity.
01:44:24 <ddarius> > sqrt 0.1
01:44:25 <lambdabot>   0.31622776601683794
01:45:49 * ddarius will now see how disastrous his code is.
01:47:08 <shachaf> dmwit: "always use let" is much better than "always use where"
01:47:16 <shachaf> At least that one is possible.
01:47:34 <zhulikas> what about "never use let nor where"
01:47:47 <ddarius> shachaf: Until you need to scope over multiple guards and use parameters.
01:47:59 <merijn> zhulikas: That's a laughable heuristic
01:48:00 <shachaf> ddarius: You can do that with multiple lets.
01:48:15 <shachaf> (You might need to add a case into the mix.)
01:48:39 <ddarius> shachaf: If you allow case, then I can do everything with let with where.
01:48:54 <shachaf> True.
01:51:44 * hackagebot monarch 0.3.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.3.0.0 (NoriyukiOhkawa)
01:56:07 <ddarius> My code may be freakishly working.
01:56:42 <shachaf> What code?
01:57:08 <ddarius> My unscented Kalman filter.
01:57:20 <Ralith> oo
02:05:43 <dmwit> nothing worse than a smelly Kalman filter
02:21:40 <thirsteh> noob question about typeclasses: is there an easy way to make a wrapper like this? http://hpaste.org/74101
02:22:20 <thirsteh> "No instance for (R.Random a) arising from the use of `R.RandomR`"
02:23:03 <ddarius> This is actually pretty fucking amazing.
02:24:11 <thirsteh> thanks, I try
02:24:18 <Ralith> ddarius: is it open source?
02:24:23 <thirsteh> :D
02:25:09 <ddarius> Ralith: I'm intending on packaging up the code.  It uses hmatrix which uses GSL so the first version will probably be GPL.
02:25:10 <Saizan> thirsteh: you need the "R.Random a => .."  contexts in the sigs of randomR and random
02:25:31 <ddarius> At this point, I need to actually implement Cholesky update rather than just using the specification.
02:25:46 <ddarius> I'll probably want to make a stand alone unscented transform function.
02:26:23 <thirsteh> Saizan: ah, thanks!
03:02:29 <sheldonh> you know what's !$^&# awesome about pure functions? you can write them out over and over again, substituting in the values of expressions, and get a trace of what they'll given you. is this what they mean when they say "easier to reason about"?
03:03:28 <sheldonh> hmmm... is there tooling to do this for you? like the comments under fibonacci at https://github.com/sheldonh/learning-haskell/blob/master/fib/Fibonacci.hs
03:05:23 <ddarius> sheldonh: There was Buddha back in the day.
03:08:40 <Saizan> @where stepeval
03:08:41 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
03:09:28 <yitz> sheldonh: another thing. !$^&# is a valid operator name in haskell.
03:10:11 <sheldonh> yitz: sorry :)
03:14:39 <sheldonh> Saizan: thanks :)
03:37:52 <timthelion> Is there a | more for the output of a value to ghci?
03:38:35 <adnam> timthelion: i don't understand your question
03:39:23 <sheldonh> timthelion: like, you want in-ghci pagination?
03:39:23 <Ke> I think he means pager
03:39:40 <shachaf> ghc -e 'foo' | more
03:40:19 <timthelion> shachaf: is that the only way :/
03:40:26 <timthelion> I guess it works for me now...
03:40:51 <timthelion> I have a value that "Show"s to about 100k lines...  And I want to view it.
03:42:15 <shachaf> No, it's not the only way.
03:42:27 <shachaf> You could use an external pager program, for example.
03:43:14 <byorgey> timthelion: is there some reason you need to do it in ghci, as opposed to writing a little program to print out the output of show, write it to a file, and then use whatever tools you want for viewing the file contents?
03:43:46 <timthelion> byorgey: convenience?  I'm just debugging for goshes sakes!
03:43:47 <simplicio> implying I have to write a program
03:43:55 <simplicio> writeFile "tmp.txt" (show foo)
03:43:59 <dmwit> writeFile "... yes that
03:44:05 <timthelion> I guess
03:44:09 <byorgey> oh, good point
03:44:34 <randomclown> I was readin stackoverflow and this came up, http://stackoverflow.com/questions/12231495/haskell-solution-for-interviewstreet-string-similarity-challenge, I wrote an attempt with bytestrings and it's still not fast enough
03:44:38 <hpaste> randomclown pasted “sample code” at http://hpaste.org/74103
03:45:03 <grust> timthelion, why not just use "script <your-log-file>" before you invoke ghci?
03:45:10 <timthelion> ghc -e outputs nothing for:
03:45:11 <timthelion> ghc -e 'import Language.Haskell.Her.HaLay;readFile "stm3.haskarrow" >>= (\code->return $ ready "" code)>>=print' | more
03:45:19 <shachaf> byorgey: Yes, there are reasons.
03:45:28 <shachaf> For example, you want to search the output of one command.
03:45:31 <yitz> timthelion: you can capture the output of show in a variable using let, then use haskell functions within ghci to explore it
03:45:42 <timthelion> yitz: ;)
03:45:44 * shachaf still relies on ":m + Foo<tab><tab>" to look for modules.
03:45:46 <grust> timthelion, this will capture you session the given log file for later inspection.
03:45:50 <randomclown> the code is so simple so it's hard to any more ways to optimise further?
03:45:54 <grust> s/the/in the/
03:45:55 <byorgey> shachaf: fair enough
03:46:31 <timthelion> I think that the writeFile idea will work
03:47:25 <shachaf> DrTeggy: Why not just go back in time and buy a hammer when you want to put a screw in something?
03:47:59 <dmwit> ...what?
03:48:09 <DrTeggy> shachaf, no need to get ironic here.  If it's a one-shot thing, script is perfectly OK
03:48:22 <shachaf> `script ghci` solves a completely different problem at a completely different time.
03:48:45 <dmwit> randomclown: I'd think you'd want to mimic Data.Text's commonPrefix function, including its efficient implementation using internals of the data structure.
03:48:49 <dmwit> uncons is not going to cut it
03:49:14 <dmwit> randomclown: Anyway, I think I agree with dafis that getting very much faster will require a better algorithm (though I'm not sure you can do much better than quadratic).
03:49:38 <byorgey> randomclown: also, you should just call uncons on each argument once and reuse the results, rather than throwing them away and then calling head and tail again
03:49:39 <dmwit> I've thought briefly about what such an algorithm would look like, but I couldn't come up with anything that seemed like it ought to be a significant win over the naive solution.
03:50:33 <randomclown> byorgey: well at this point the code is going to look like crap anyway haha
03:50:43 <dmwit> This being an interview problem, though, it's likely there is something clever that I simply didn't manage to invent. =)
03:51:09 <randomclown> I wrote pretty much the same thing in c and it's about 4 times faster.
03:52:04 <dmwit> I feel confident that you can double the speed of realSim just by not calling uncons (and therefore removing allocation from your inner loop).
03:54:58 <shachaf> Is this the sort of website where micro-optimizations like that matter?
03:55:30 <shachaf> By "micro" I mean "non-asymptotic"
03:55:32 <lpvb> THIS. IS. IRC.
03:56:22 <lpvb> unless you're talking about website coding then ignore me
03:56:38 <shachaf> I'm talking about the website that someone posted here.
03:56:43 <dmwit> It doesn't accept the solution he put on hpaste because it's too slow. He wrote a C version that uses the same (quadratic) algorithm and is faster. Presumably (though he didn't actually say it) the C version is fast enough to be accepted.
03:57:01 <shachaf> Ah.
03:57:07 <hpaste> randomclown annotated “sample code” with “sample code (annotation)” at http://hpaste.org/74103#a74104
03:57:24 <randomclown> dmwit: same speed.
03:57:32 <dmwit> Calling head and tail isn't exactly an improvement over calling uncons...
03:57:40 <dmwit> tail is still going to allocate.
03:58:14 <shachaf> The implementation of commonPrefixes for Text looks like it also would.
03:58:20 <dmwit> You need to use the internal details of the ByteString data structure to avoid allocating in this loop.
03:58:33 <shachaf> Unless I'm missing some clever thing, which is possible.
03:58:36 <dmwit> shachaf: It allocates once for the whole loop, not once per recursive call.
03:58:44 <dmwit> You are missing something, yes.
03:59:15 <randomclown> dmwit: I'm missing something as well then, could you annote with what you mean?
03:59:30 <dmwit> randomclown: Did you take a look at the implementation of commonPrefixes in Text?
04:00:59 <dmwit> http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/src/Data-Text.html#commonPrefixes
04:01:16 <shachaf> dmwit: Oh, you mean allocates new ByteString/Text objects.
04:01:20 <dmwit> yes
04:01:28 <shachaf> OK, yes.
04:02:43 <shachaf> I'd try it out but I don't really have a way of measuring my results, and I don't want to make an account on that site. :-)
04:03:02 <randomclown> you can bench aganist my crappy c code if you want
04:03:07 <adinapoli> hi guys, I've written a small Vim bundle for vim->ghci communication through Tmux, check it out: http://adinapoli.github.com/cumino/
04:03:36 <dmwit> ...through tmux?
04:03:42 <yitz> randomclown: if you really need that much speed, and you don't need all the machinery of bytestrings/text, just a simple comparison and count, then maybe you're better off with a vector of bytes.
04:04:20 <shachaf> Alternatively you can probably loop through the ByteString and index into it.
04:04:24 <adinapoli> dmwit, yes, it's well explained in the main page
04:04:49 <adinapoli> it's handy, you can load the current opened buffer inside a ghci repl from Vim.
04:04:52 <shachaf> (You couldn't do that with Text, though. At least not UTF-16 Text's current interface, not safely.)
04:05:49 <hpaste> randomclown annotated “sample code” with “sample code (annotation) (annotation) (c)” at http://hpaste.org/74103#a74105
04:06:29 <dmwit> I understand why you need a term. What does tmux do for you?
04:07:00 <adinapoli> dmwit, Tmux acts like an intermediary, it forward commands (like :load) from Vim to ghci
04:07:38 <rking> dmwit: tmux makes for pretty handy IPC
04:07:40 <adinapoli> dmwit, so you don't have to change focus from Vim to ghci, press :r or :load, then try or test the code, then switch back to Vim etc
04:08:11 <adinapoli> dmwit, I'm planning to put online a screencast also, as soon as I have time
04:08:29 <dmwit> Oh, I understand now.
04:08:50 <dmwit> The point is that tmux runs a server that both xterm and gvim connect to.
04:09:04 <dmwit> (right?)
04:09:08 <yitz> vim users: i see that vim support for haskell is improving these days. is it approaching or passing emacs?
04:09:14 <rking> Wait, gvim?  xterm?  I don't imagine so.
04:09:31 <rking> dmwit: tmux splits your current terminal into panes, and then lets one of the processes pipe to the other.
04:09:51 <adinapoli> dmwit, to be precise, the dark magic is provided by a tmux command that allows pasting of a buffer inside a tmux running session
04:10:12 <yitz> i'm more interested in just the basics, not bells and whistles so much. e.g., how is indentation?
04:10:37 <adinapoli> dmwit, the plugin simply tell tmux "hey, I'm putting this command (e.g. :load bla bla) inside this file, can you paste its content inside session named K?
04:10:37 <rking> adinapoli: I definitely would like to see the screencast.
04:10:59 <dmwit> adinapoli: right
04:10:59 <gertc> class Eq a where... i understand but class Monad m => MonadState s m | m -> s where... is confusing first what does the | do ?
04:11:16 <adinapoli> rking, there is a screenshot and a wiki with basic command in the link I gave you
04:11:25 <adinapoli> rking, there it is for completeness: http://adinapoli.github.com/cumino/
04:11:34 <byorgey> gertc: the  | m -> s  part is called a "functional dependency"
04:11:35 <dmwit> yitz: Somebody posted https://github.com/jejansse/haskim yesterday, which seems to collect the most popular vim plugins for Haskell editing in one place.
04:11:41 <yitz> are there any vim users around? if everyone is using emacs, i guess that kind of answers my question too.
04:11:44 <rking> adinapoli: Yeah, I just want to see your workflow.
04:11:47 * hackagebot fay 0.9.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.9.1.0 (ChrisDone)
04:12:08 <rking> adinapoli: I'm pretty into Ruby+pry, and I might steal your whole thing. =)
04:12:10 <adinapoli> yitz, I saw it, maybe cumino can be included in Haskim if it deserves it :)
04:12:11 <byorgey> gertc: it specifies that for any given MonadState instance, m determines s, that is, there cannot be two different instances with the same m but different s
04:12:25 <rking> adinapoli: Actually there's no reason for this to be Haskell-specific. It could just be some config vars, no?
04:12:44 <adinapoli> rking, well, the workflow can be easily adapted to any language, yes :) I wrote a similar plugin for OCaml
04:12:45 <yitz> dmwit: i saw that. that's why i'm asking. it's tons of stuff. i started plowing through it. most of it was either bells and whistles, or tiny unimportant tweaks to syntax highlighting, etc.
04:13:24 <rking> adinapoli: Also, I'm not seeing any hard need for the +python. Am I wrong?
04:13:27 <yitz> what about just the basics?
04:13:44 <hpaste> timthelion pasted “line40 and onwards seen as one block.” at http://hpaste.org/74106
04:14:01 <timthelion> I'm sorry to paste something so long. But this has cost me over an hour now :/
04:14:06 <timthelion> I don't have a clue...
04:14:18 <adinapoli> rking, the python supports is necessary, because I use in my plugin functions written in it :)
04:14:23 <cmears> Is there any way to remove packages from the local cabal documentation index (at ~/.cabal/share/doc/index.html) ?
04:14:25 <gertc> byorgey, ok thx
04:14:28 <adinapoli> rking, but in theory you can make it python free
04:14:33 <rking> adinapoli: Yeah but I mean you could do those in VimL, I think.
04:14:35 <timthelion> Oh, and line 40 is now line 51 after having added commentary.
04:14:44 <adinapoli> I'm going to have lunch, see you later guys :)
04:14:51 <rking> adinapoli: Though I think everyone should run +python just to get :Gundo
04:15:00 <rking> adinapoli: I'll keep in touch. This interests me.
04:15:07 <adinapoli> rking, Yup, see ya!
04:15:07 <rking> Good work.
04:15:51 <yitz> timthelion: line 104 looks suspicious. "<<" ?
04:16:03 <dmwit> I was just about to say the same thing.
04:16:10 <dmwit> Maybe that ought to be an "="...?
04:16:23 <timthelion> :/ :/
04:16:33 <Saizan> cmears: you can ghc-pkg hide them and then trigger a reindexing
04:16:54 <cmears> Saizan: that sounds great -- how do you trigger the reindexing?
04:16:59 <timthelion> I know... The thing is, that my code generator ALSO fails to parse that, for the same reason as stated above, that her-lexer sees everything from line 51 onwards as one block...
04:17:13 <Saizan> cmears: installing a package, iirc
04:17:24 <Saizan> with docs
04:17:32 <timthelion> but thanks for pointing that out.  I'll try to "help the conversion along" and see if the error changes.
04:17:35 <dmwit> timthelion: I don't understand. Why are you expecting any of your tools to parse invalid Haskell correctly?
04:17:41 <timthelion> perhaps McBride's lexer is at fault?
04:18:22 <cmears> Saizan: thanks, I'll try that
04:18:37 <timthelion> dmwit: I have a langauge very similar to haskell that I am converting to haskell.  So far the lexer from she has done a great job of doing so.
04:18:54 <timthelion> dmwit: of lexing my "invalid" haskell
04:19:36 * dmwit feels like channeling Babbage
04:20:11 <timthelion> dmwit: but given that it's a single pass lexer...  What happens later on in the file shouldn't be affecting things...
04:20:44 <dmwit> To be honest, I'm a little lost about what the question actually is.
04:21:28 <cmears> Saizan: thanks again, that works
04:21:46 <timthelion> dmwit: well I had parsable code, up untill I changed something on line 51(of the paste) and now it no longer parses/lexes
04:21:52 <Saizan> cmears: cheers
04:22:26 <hpaste> timthelion annotated “line40 and onwards seen as one block.” with “line40 and onwards seen as one block. (annotation)” at http://hpaste.org/74106#a74107
04:22:36 <timthelion> dmwit: and changing the << to an = doesn't help
04:22:46 <timthelion> stm3.hs:110:15: parse error on input `='
04:22:59 <timthelion> but the error is on line 40...
04:23:09 <timthelion> I just don't have a clue what's wrong with line 40...
04:23:28 <timthelion> line 40 being that "atomically (do..." stuff.
04:26:41 <randomclown> shachaf: are you still trying that string thing?
04:27:41 * shachaf is too sleepy to get much done on it.
04:27:50 <shachaf> I improved things a bit.
04:27:57 <shachaf> Unsafe indexing makes a difference.
04:28:08 <shachaf> Hmm, well, I also rewrote the rest of the code before I tried that. :-)
04:28:18 <shachaf> So I can't tell you whether it actually does.
04:29:51 <shachaf> (Well, I can.)
04:31:14 <timthelion> aha! there IS a bug in McBrides lexer... :)
04:31:26 <gertc> instance Eq TrafficLight where... instance MonadState s m => MonadState s (MaybeT m) where... why is there `MonadState s m =>` in the second instance?
04:31:47 <timthelion> > ready "" "(do{})\n hi"
04:31:48 <timthelion> [[B Rnd [L "do" [[B Crl []]]],NL ("",1),Spc " ",Lid "hi"]]
04:31:49 <lambdabot>   Not in scope: `ready'
04:31:59 <timthelion> Can anyone see the bug :)
04:33:28 <randomclown> data.vector is worse than bytestrings
04:33:41 <randomclown> probably because I used it wrong
04:34:26 <dmwit> gertc: Because to write get and put for (MaybeT m), you need get and put for m.
04:34:43 <byorgey> timthelion: did it drop the closing curly brace?  it's really difficult to tell what all those constructors mean
04:35:42 <dmwit> I'm not really sure I expect good things to happen to "do{}" anyway.
04:36:10 <dmwit> > let in 3
04:36:11 <lambdabot>   3
04:36:15 <byorgey> > do{} >> [1,2,3]
04:36:16 <lambdabot>   <no location info>: Empty 'do' construct
04:36:50 <shachaf> What do you expect do{} to mean?
04:37:27 <byorgey> dmwit: timthelion's real code didn't have empty do blocks though, I presume the point is that the lexer messes up non-empty do blocks with explicit curly braces as well
04:37:28 <timthelion> byorgey: If I pass it ( do { } ) something it acts as if the round brackets never got closed
04:39:11 <byorgey> timthelion: wait, it doesn't look that way to me in the above output
04:39:41 <byorgey> timthelion: it had   [[B Rnd ..., NL ("",1),Spc ... ]]
04:39:46 <gertc> dmwit, so MonadState s m refers to only the m in (MaybeT m)?
04:40:09 <byorgey> timthelion: I am guessing that  B Rnd foo   means 'foo' enclosed in parens?
04:40:22 <timthelion> byorgey: I guess you're correct, hmm
04:40:55 <timthelion> back to the drawing board
04:40:57 <dmwit> gertc: I'm having a little trouble figuring out what you question means, but I *think* the answer is yes.
04:41:37 <dmwit> That instance declaration says "I can make MaybeT m into a stateful thing (with state s) if you tell me how m is a stateful thing (with state s)".
04:41:47 <timthelion> byorgey: Even years of lisp don't save me when it comes to square brakets :/
04:43:54 <byorgey> man, reading through the source of her-lexer is a trip
04:44:04 <byorgey> layDKillaz :: [(String, String)]
04:44:09 <timthelion> byorgey: I know :D
04:44:11 <byorgey> splendid :: [Tok] -> [[Tok]]
04:44:34 <atriq> Easier or harder to read than http://hpaste.org/raw/71201 ?
04:45:05 <byorgey> uh, much easier.
04:45:07 <timthelion> byorgey: when I emailed Conor asking if I could scoop that code, he said he was very good at reading code and could only appologize to others :)
04:45:20 <byorgey> hehe
04:45:32 <atriq> byorgey, that's just a factorial program written with SKI calculus
04:45:47 <atriq> And subsequently minified
04:45:52 <dmwit> -- sod FP now
04:46:00 <gertc> how does the collering works?
04:46:11 <byorgey> atriq: I figured it was something like that
04:46:19 <gertc> i want to coller text in MonadState s m => MonadState s (MaybeT m)
04:46:28 <atriq> Don't try it with a number more than ~11, though
04:46:33 <atriq> Anything more than 8 takes a while
04:47:43 <byorgey> gertc: 'coller' is not an English word, I am not sure what you mean
04:48:17 <byorgey> gertc: do you mean 'color'/'colour'?
04:48:23 <gertc> i want to put MonadState s m => MonadState s (MaybeT  m)
04:48:50 <taylorgb> I think it's french for 'to bind'
04:48:51 <atriq> You want to make an instance MonadState s m => MonadState s (MaybeT m)?
04:48:52 <gertc> `MonadState s m` in red and also the m
04:49:23 <byorgey> oh, you really do mean color.
04:49:36 <gertc> yes :)
04:50:12 <byorgey> gertc: there is a program called  hscolour  for highlighting Haskell source, perhaps that's what you want?
04:50:27 <gertc> ok just sec
04:50:39 <byorgey> http://hackage.haskell.org/package/hscolour
04:51:16 <atriq> On a similar subject, has anyone else tried to put Haskell code on Tumblr with syntax highlighting?
04:51:55 <gertc> can you color text in this channel? for example display `this` in red
04:52:15 <atriq> Depends on the IRC client everyone is using.
04:52:24 <gertc> irssi
04:52:28 <atriq> Coloured text is not part of the IRC standard, but many clients support it.
04:52:38 <taylorgb> coloured text is evil
04:52:42 <gertc> a ok
04:53:01 <taylorgb> Mainly because you have no way of knowing what kind of colour scheme people are using
04:53:24 <gertc> ok i wil try to ask it in non color
04:53:28 <Jafet> Mainly because it makes you sound like a teenager
04:56:14 <gertc> instance 0->MonadState s m<-0 => MonadState s (MaybeT 0->m<-0) where... so MonadState s m => is a reference to only the m?
04:58:06 <Jafet> It also refers to s.
05:05:47 <gertc> ok back to instance Eq TrafficLight where ... instance Eq TrafficLight => Eq TrafficLight where ... would the second instance be possible to make?
05:07:05 <dmwit> Try it. =)
05:07:50 <gertc> ok just a sec
05:16:48 * hackagebot snaplet-fay 0.2.0.0 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.2.0.0 (AdamBergmark)
05:20:10 <Yiq> what would be the channel to talk about CAN and CANopen? there is no #datacommunication . #engineering maybe?
05:22:51 <gertc> so the trafic did not work because it was not a class but still its really confusing to have a instance of class that is a instance of itself
05:25:32 <Yiq> gertc:
05:25:34 <Yiq> @hpaste
05:25:35 <lambdabot> Haskell pastebin: http://hpaste.org/
05:26:32 <timthelion> Yiq: CAN stands for Child Abuse and Neglect?
05:26:52 <Yiq> tim: yes
05:26:54 <gertc> ?
05:27:07 <Yiq> so CANopen would the mean?
05:28:01 <timthelion> Yiq: open source knockoff of parental alchololism.
05:28:43 <Yiq> ok ill put that in my report
05:29:01 <timthelion> :D
05:29:20 * timthelion is a pedagogy major.
05:32:53 <Yiq> i would have guessed u are
05:41:52 <hpaste> gertc pasted “example” at http://hpaste.org/74110
05:43:15 <gertc> can you make a traficlighte that uses =>
05:45:54 <gertc> of it self
05:48:57 <hbIppo> i'm having a little problem understanding this simple piece of code
05:49:09 <hbIppo> foldr1 (>>) $ replicate 100000 Nothing
05:49:17 <hbIppo> this is istantaneous
05:49:29 <hbIppo> however, with foldl1 it is not
05:49:38 <hbIppo> but I don't understand why
05:50:26 <Yuu-chan> @source foldr1
05:50:26 <lambdabot> foldr1 not available
05:50:28 <simplicio> because foldl has to traverse the whole list
05:50:33 <Jafet> > Nothing >> undefined
05:50:34 <lambdabot>   Nothing
05:50:51 <Jafet> > undefined >> Nothing
05:50:52 <lambdabot>   *Exception: Prelude.undefined
05:51:12 <hbIppo> and why doesn't foldr1 traverse it all?
05:51:18 <simplicio> @src foldr
05:51:18 <lambdabot> foldr f z []     = z
05:51:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:51:25 <simplicio> because it calls f first
05:51:47 <hbIppo> @src foldl
05:51:47 <lambdabot> foldl f z []     = z
05:51:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:52:09 <Yuu-chan> So it becomes Nothing >> (thunk) and the rest isn't evaluated?
05:52:11 <hbIppo> mmm... so since (>>) discards the left argument
05:52:19 <hbIppo> foldr immediately discards the rest
05:52:24 <hbIppo> and returns the last Nothing in the list
05:52:26 <hbIppo> right?
05:52:47 <simplicio> >> does not discard the left argument
05:52:53 <simplicio> and it returns the first Nothing
05:53:03 <hbIppo> @src (>>)
05:53:04 <lambdabot> m >> k      = m >>= \_ -> k
05:53:28 <simplicio> @src Maybe (>>=)
05:53:28 <lambdabot> (Just x) >>= k      = k x
05:53:28 <lambdabot> Nothing  >>= _      = Nothing
05:53:51 <hbIppo> @src Maybe (>>)
05:53:52 <lambdabot> (Just _) >>  k      = k
05:53:52 <lambdabot> Nothing  >>  _      = Nothing
05:53:56 <hbIppo> mmm
05:53:57 <hbIppo> you are right
05:53:58 <KBme> hi
05:54:05 <hbIppo> it discards the right
05:54:16 <hbIppo> so in this case, it just returns the head of the list
05:54:17 <KBme> I just installed xmobar and xmonad from cabal, but xmobar doesn't seem to work
05:54:21 <hbIppo> discarding the tail
05:54:21 <hbIppo> right?
05:54:29 <simplicio> yes
05:54:32 <KBme> even with the default config, it just won't appear on the screen
05:54:33 <KBme> no error
05:54:40 <hbIppo> thank you very much, simplicio :)
05:56:12 <saep> KBme, press Alt+Shift+Enter! If a terminal starts then xmonad is running. (Alt may also be the Super key)
05:56:49 <KBme> no, xmonad works, xmobar doesn't
05:57:12 <parcs`> #xmonad may be of more help
05:57:18 <KBme> ok, thanks
06:14:41 <aleksandar> hello
06:14:46 <atriq> Hey
06:15:29 <hpaste> “Aleksandar Jovanov” pasted “Excpetion error” at http://hpaste.org/74111
06:16:25 <aleksandar> 	ln <- try $ hGetLine handle
06:16:37 <aleksandar> the line that I think causes the trouble
06:16:42 <aleksandar> I tried
06:16:55 <aleksandar> 	ln <- (try $ hGetLine handle) :: Exception
06:17:01 <aleksandar> but that did not help either
06:18:57 <Yiq> gertc
06:19:14 <Yiq> you know you can just derive Eq and Show?
06:19:38 <Yiq> data TrafficLight = Red | Yellow | Green deriving(Eq, Ord, Show) ?
06:21:19 <merijn> :t try
06:21:20 <lambdabot> Not in scope: `try'
06:23:00 <simplicio> aleksandar: replace 'try' by 'tryIOError'
06:23:52 <aleksandar> what module is that
06:24:10 <simplicio> System.IO.Error
06:24:41 <Yiq> gertc quit?
06:24:59 <Yiq> can you see if a user is logged onto irc-.freenode?
06:25:21 <aleksandar> @simplicio I will try that now
06:25:22 <lambdabot> Unknown command, try @list
06:25:32 <aleksandar> I will try that
06:25:46 <aleksandar> ok compiled
06:25:50 <aleksandar> :)
06:25:54 <aleksandar> thanks
06:26:10 <merijn> Yiq: "/whois user"
06:28:43 <raboof> in X11, is it possible to find the current size of a window? Dont see anything in http://hackage.haskell.org/packages/archive/X11/1.6.0/doc/html/src/Graphics-X11-Xlib-Window.html
06:31:33 <aleksandar> http://www.sbin.org/doc/Xlib/chapt_03.html
06:31:45 <aleksandar> XGetGeometry
06:32:24 <aleksandar> If there is no info in haskell docs
06:32:31 <aleksandar> it might be needed to use FFI
06:32:56 <Clint> raboof: there seems to be a getWindowAttributes in Graphics.X11.Xlib.Extras
06:34:57 <hbIppo> @src (>>)
06:34:58 <lambdabot> m >> k      = m >>= \_ -> k
06:36:55 <raboof> cool
06:38:37 <Tinned_Tuna> @src (>>=)
06:38:37 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
06:39:44 <hbIppo> ... how is that?
06:39:52 <hbIppo> there is the source for (>>) but not (>>=)
06:39:57 <simplicio> >>= is a method
06:40:04 <simplicio> it depends on the type you're using it with
06:40:09 <atriq> @src Maybe (>>=)
06:40:09 <lambdabot> (Just x) >>= k      = k x
06:40:09 <lambdabot> Nothing  >>= _      = Nothing
06:40:15 <atriq> @src [] (>>=)
06:40:15 <lambdabot> xs >>= f     = concatMap f xs
06:40:37 <hbIppo> you know, maybe I should just stick with using monads and give up understanding them
06:40:38 <atriq> @src ((->) r) (>>=)
06:40:39 <lambdabot> Source not found. I am sorry.
06:40:40 <hbIppo> I suck at this
06:40:45 <hbIppo> :P
06:41:04 <atriq> I think it's not Monads you're not understanding
06:41:12 <atriq> But rather, polymorphic functions
06:41:19 <atriq> Or something
06:41:23 <hpc> type classes
06:41:27 <simplicio> hbIppo: do you understand Functor?
06:41:29 <applicative> @src (+)
06:41:30 <lambdabot> Source not found. My brain just exploded
06:41:38 <hpc> hbIppo: imagine the Num typeclass
06:41:40 <hpc> @src Num
06:41:40 <lambdabot> class  (Eq a, Show a) => Num a  where
06:41:41 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:41:41 <lambdabot>     negate, abs, signum     :: a -> a
06:41:41 <lambdabot>     fromInteger             :: Integer -> a
06:41:59 <hpc> hbIppo: there's many numeric types, including Integer, Double, Rational, etc
06:42:00 <hbIppo> simplicio: not really, just like Monads
06:42:18 <nand`> you should understand Functor before trying to understand Monad
06:42:19 <hpc> hbIppo: addition is defined separately for each type, and then you can use the same symbol for any type of addition
06:42:23 <hpc> @src (+)
06:42:24 <lambdabot> Source not found. Are you on drugs?
06:42:26 <hbIppo> hpc: I'm ok with common classes, I just stop functioning when you start saying Monad I guess
06:42:48 <hpc> hbIppo: (>>=) is like (+) in that respect; you have to define it yourself for each monad you define
06:43:15 <hpc> there's no single definition
06:43:17 <hbIppo> hpc: right, I hadn't thought of that, but it makes sense, obviously
06:43:28 <hbIppo> just like (+) for Num
06:43:29 <hpc> (>>) is defined in terms of (>>=)
06:43:33 <simplicio> hbIppo: I'd start with simple stuff like Show, Num, Read; then intermediate stuff like Functor, Applicative; then Monad
06:43:37 <hpc> like "increment = (1 +)"
06:43:46 <hpc> hence being able to see source for it
06:43:46 <atriq> @src (^)
06:43:47 <lambdabot> x ^ 0            =  1
06:43:47 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
06:43:47 <lambdabot>   where f _ 0 y = y
06:43:47 <lambdabot>         f x n y = g x n
06:43:47 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
06:43:49 <lambdabot>                       | otherwise = f x (n-1) (x*y)
06:43:51 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
06:43:54 <hpc> oh god what
06:44:01 <hbIppo> simplicio: I waahahah
06:44:05 <atriq> :t (^)
06:44:06 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
06:44:09 <hbIppo> sorry cut off mid sentence
06:44:12 <merijn> If I have a transformer stack that includes some read only info and some mutable info should I have a separate ReaderT and StateT or just have both in the StateT?
06:44:26 <hbIppo> simplicio: I am following Real World Haskell
06:44:31 <hbIppo> maybe not the best choice?
06:44:48 <hpc> merijn: is there an RS in the same vein as RWS?
06:44:49 <atriq> merijn, I'd use RWST, something like RWS Foo () Bar
06:44:59 <hpc> oh, or use () in the type lol
06:45:03 <hpc> yeah, what atriq said
06:45:12 <hpc> > () ++ ()
06:45:14 <lambdabot>   ()
06:45:20 <hpc> forgot about that instance
06:45:25 <merijn> I'm not familiar with RWS/RWST?
06:45:35 <hpc> merijn: RWS is Reader/Writer/State
06:45:40 <atriq> merijn, it's a big throw-y together of Reader Writer and State
06:45:44 <hpc> RWST is a transformer composition of the three
06:45:48 <merijn> hpc: I'll take a look
06:45:48 <hpc> in no particular order
06:45:54 <applicative> @unmtl RWS Foo () Bar
06:45:54 <lambdabot> Plugin `unmtl' failed with: `RWS Foo () Bar' is not applied to enough arguments, giving `/\A. Foo -> Bar -> (A, Bar, ())'
06:45:58 <atriq> "Reader Writer State Transformer" has a pretty cool rhythm
06:46:01 <applicative> haha
06:46:10 <atriq> @unmtl RWS Foo () Bar ()
06:46:10 <lambdabot> Foo -> Bar -> ((), Bar, ())
06:46:12 <applicative> @unmtl RWS Foo () Bar Int
06:46:13 <lambdabot> Foo -> Bar -> (Int, Bar, ())
06:46:15 <nand`> atriq: more opportunities for Haskell poetry
06:46:24 <merijn> hbIppo: Personally I thought RWH glossed over some important details. Have you tried Learn You a Haskell?
06:46:35 <hpc> @where lyah
06:46:35 <lambdabot> http://www.learnyouahaskell.com/
06:46:48 <nand`> is there any meaningful difference between RWST r w s m and ReaderT r (WriterT w (StateT s m))  other than perhaps efficiency?
06:46:55 <hbIppo> merijin: yes, but it's not as complete as RWH
06:47:02 <hbIppo> also, it's pretty short
06:47:04 <merijn> hbIppo: In what sense?
06:47:05 <hpc> nand`: possibly a different number of bottoms?
06:47:20 <merijn> I think LYAH is almost longer than RWH? Or maybe it just seemed that way
06:47:28 <hpc> nand`: also, it explicitly hides the order of the stack from you
06:47:39 <Yuu-chan> merijn: what's wrong with RWH?
06:47:53 <hbIppo> merijin: sorry, I said short but actually meant "concise"
06:47:56 <nand`> ah yeah you can't get a partially ‘applied’ result from it
06:48:01 <atriq> I didn't find RWH very readable
06:48:03 <merijn> Yuu-chan: It glosses over some important details of Functor/Applicative/Monad
06:48:04 <hbIppo> it shoots stuff pretty quick
06:48:16 <nand`> from what I read of RWH I think its code examples are ugly
06:48:21 <nand`> and bad examples of what beautiful code looks like
06:48:27 <hbIppo> yes, RWH is pretty ugly
06:48:28 <Yuu-chan> :t ()
06:48:29 <lambdabot> ()
06:48:29 <hbIppo> especially the code
06:48:36 <merijn> hbIppo: Really? RWH goes *much* faster after the first few chapters, whereas LYAH covers everything in depth
06:48:44 <squidz> no alternatives yet though
06:48:58 <hbIppo> merijin: dunno, that was my impression. I'll give it another go
06:49:11 <hpc> RWH is very good in the later chapters where it turns into "intro to every library you will ever want"
06:49:21 <hbIppo> hpc: lol
06:49:23 <hpc> until then, LYAH is the superior book
06:49:31 <Yuu-chan> Interesting.
06:49:36 <hbIppo> ok then, I'll move back to that for a while
06:49:41 <hbIppo> thanks for the advice
06:49:47 <nand`> iunno, I tend to look at some examples of library usage in RWH, decide it's not what I'm looking for and read specialized posts/papers/whatever instead
06:50:19 <raboof> can i convert a Foreign.C.Types.CInt to a Position, where 'type Position = Int32' ?
06:50:22 <hpc> nand`: the example code is way out of date for most of the stuff it covers
06:50:29 <nand`> yeah pretty much
06:50:29 <hpc> namely parsec
06:50:31 <squidz> nand`: that's pretty much my usage too
06:50:59 <atriq> I pretty much learnt parsec, I think the day before yesterday, mainly from RWH but with a lot of guessing and being lucky
06:51:01 <squidz> nand`: or i take a look at one of the usages and realize that I do not want to do it that way and use a different library
06:51:04 <hpc> raboof: convert (CInt n) = n
06:51:07 <atriq> And I still don't no any of it, pretty much
06:51:10 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CInt
06:51:32 <hpc> raboof: there's also fromIntegral
06:52:02 <nand`> I've been deferring learning parsec to until I know what the differences and various strengths of parsec, attoparsec, trifecta, etc. are
06:52:18 <hpc> attoparsec is stricter than parsec
06:52:24 <hpc> parsec is very well tested
06:52:33 <hpc> trifecta is apparently awesome, but has no docs
06:52:57 <hpc> i generally start with attoparsec
06:52:57 <nand`> other than two posts on edwardk's blog that nobody understands?
06:53:00 <squidz> ive used parsec for the first time yesterday, and seem pretty happy with it. If I know parsec well, i shouldnt have to learn much new for attoparsec right
06:53:05 <hpc> then if i find it performs poorly, i rejigger it in parsec
06:53:06 <nand`> yeah I did use attoparsec not too long ago for a three-liner
06:53:11 <hpc> squidz: yeah
06:53:15 <hpc> squidz: almost nothing
06:53:35 <squidz> and parsec can pretty much handle situations where I would normall use regex=?
06:53:40 <hpc> yes
06:53:43 <nand`> parsec provides a monad, right? or just an applicative?
06:53:47 <hpc> monad
06:53:50 <squidz> is it faster than normal regex seraching though?
06:53:57 <mietek> What's a good way to do database access from Haskell today?
06:54:02 <mietek> Still HDBC?
06:54:12 <nand`> I often hear about the differences between monadic parsers and ‘applicative parsers’, though I don't know what the latter can offer by limiting itself to applicatives
06:54:17 <hpc> mietek: HDBC is still good, and there's other options for specific databases
06:54:20 <simplicio> squidz: what do you mean by "normal regex searching"?
06:54:21 <squidz> mietek: I tried hdbc, but got frustrated with it and am going with a DB specific binding
06:54:23 <hpc> postgres-simple or something like that
06:54:27 <hpc> mysql-simple
06:54:27 <nand`> and by ‘I hear about the differences’ I mean ‘I have no clue what the differences are’
06:54:37 <hpc> and there's different database models, like acid-state
06:54:48 <squidz> simplicio: for extracting substrings from text using regext
06:54:59 <nand`> mietek: depends on whether or not you just need a database, or whether you need to interact with some existing database like MySQL
06:55:02 <merijn> hpc: Not sure I'd call acid-state a database...
06:55:16 <hpc> ix-set then
06:55:16 <squidz> mietek: so i am using postresql-simple
06:55:28 <mietek> Aha, bos
06:55:31 <mietek> Thanks
06:55:32 <simplicio> squidz: what do you mean by "using regex"?
06:55:39 <aleksandar> what's the link of this channel ?
06:55:51 <nand`> irc://irc.freenode.net/haskell
06:56:18 <squidz> simplicio: normally, when I am looking for a specific sub string I use regex to find a pattern and then extract that string
06:56:29 <squidz> simplicio: keep in mind that is of course using another language, like ruby or java
06:56:33 <simplicio> squidz: what do you mean by "use regex"?
06:56:36 <aleksandar> thanks
06:57:11 <nand`> simplicio: do you know what a ‘regex’ is?
06:57:21 <simplicio> nand`: yes
06:57:30 <nand`> then I don't understand your confusion
06:57:30 <squidz> simplicio: you can use patterns like \d\d\d\d for four digits
06:57:33 <squidz> like 1999
06:57:40 <Sculptor> > reverse "asas jom e"
06:57:44 <lambdabot>   "e moj sasa"
06:57:45 <simplicio> squidz: I am no longer interested in talking to you
06:57:52 <squidz> ???
06:58:05 <hpc> squidz: in parsec, applicative style roughly corresponds to context-free grammars (or contextful, if you are sneaky)
06:58:17 <hpc> squidz: and regular expressions are a subset of CFGs
06:58:27 <hpc> squidz: so... yes :D
06:58:59 <squidz> nice
06:59:04 <simplicio> hpc: regexes are not limited to CFGs
06:59:11 <hpc> (and monadic style lets you write turing-complete parsers)
06:59:25 <hpc> simplicio: are you talking perl regexes, or regular expressions?
06:59:27 <simplicio> I'm pretty sure you can't do \b in parsec, for example
06:59:41 <simplicio> hpc: regexes as in common use, not regular expressions
06:59:54 <hpc> simplicio: you can match in parsec without consuming input
06:59:57 <simplicio> if you allow perl regexes, we're turing complete
07:00:01 <hpc> it's how eof works
07:00:11 <simplicio> eof corresponds to \z, not \b
07:00:31 <tdammers> eh... eof is eof, it doesn't correspond to any byte value at all
07:00:33 <hpc> that... wasn't my point
07:00:44 <simplicio> tdammers: ... byte value?
07:00:50 <tdammers> yeah.
07:00:54 <hpc> simplicio: eof is not a primitive in parsec, as it is in regexes
07:01:04 <tdammers> you can either read a byte from a file, or you can't because you've reached eof
07:01:11 <tdammers> but eof itself is not a value.
07:01:12 <hpc> it's defined in terms of things that don't consume stuff
07:01:24 <nand`> nonsense, eof is -1 /me runs
07:01:25 <simplicio> hpc: implementation accident. you can easily replace \z by (?!.)
07:01:31 <simplicio> that's notFollowedBy anyChar
07:01:56 <tdammers> simplicio: exactly. If eof were a value, anyChar would consume it
07:02:10 <simplicio> tdammers: I have no idea what you're talking about
07:02:41 <tdammers> if eof were a value equal to \z, then anyChar would match it, and notFollowedBy anyChar wouldn't work
07:02:53 <simplicio> what does "equal to \z" even mean?
07:03:05 <tdammers> oh forget everything I said
07:03:19 <tdammers> I thought you were talking about string escapes, but it's actually regex typeclasses
07:03:22 <tdammers> nm
07:03:24 <squidz> eof is often just a -1
07:03:25 <tdammers> carry on
07:03:42 <squidz> where the OS recognizes it as exactly that
07:03:43 <squidz> eof
07:03:48 <simplicio> except they're not typeclasses, they're lookaround assertions
07:03:59 <tdammers> squidz: fgetc() returns -1 when eof is reached, but there is no -1 in the file at that point
07:04:07 <simplicio> and \b in particular uses look-behind
07:04:37 <tdammers> you need speculative parsing anyway if you're processing regexes
07:05:03 <tdammers> so /foobar\b/ would translate to something like try (string "foobar" >> wordBoundary)
07:05:17 <simplicio> you can't write wordBoundary
07:05:23 <tdammers> why not?
07:05:32 <simplicio> because I don't see how
07:05:35 <tdammers> ah, yeah...
07:05:43 <simplicio> I'd like to be convinced otherwise, though
07:05:54 <tdammers> but you could write something like
07:06:10 <tdammers> try (string "fooba" >> followedByWordBoundary 'r')
07:06:23 <simplicio> ew
07:06:26 <tdammers> yeah
07:06:42 <tdammers> I'm sure it can be sugared into something more digestible
07:06:53 <hpc> notFollowedBy never consumes input...
07:07:14 <simplicio> try doing \b(\w+)\s+\1\b in parsec
07:07:27 <hpc> diet = notFollowedBy . notFollowedBy
07:07:36 <hpc> diet parser = parser, but it doesn't consume input
07:07:39 <hpc> now you can write \b
07:07:52 <simplicio> hpc: how?
07:08:04 <hpc> simplicio: write a parser that matches a word boundary
07:08:07 <simplicio> hpc: how?
07:08:10 <hpc> er
07:08:51 <tdammers> you *could* use a stateful parser, and track the last consumed input character through everything
07:09:11 <tdammers> then the word boundary parser could look at that and decide whether it had to match a word or non-word character
07:09:44 <hpc> yes, that
07:10:31 <simplicio> \b(\w+)\s+\1\b is too easy, actually
07:10:47 <simplicio> how about \b(.+?)\s*\1\b
07:19:17 <ivanm> what's fun? spending time tracking down an "error" which is actually from malformed input
07:19:18 <ivanm> *sigh*
07:20:03 <lpvb> malformed input is an exception
07:20:03 <Martty> it's our fun cycle isnt it
07:20:12 <Martty> 1. get stuck with bug
07:20:17 <Martty> 2. swear and get depressed
07:20:22 <Martty> 3. finally fix it and be happy
07:20:25 <Martty> 4. wait for next bug
07:20:38 <squidz> it'S the circle of life
07:20:55 <Martty> yes, life is like coding too
07:21:02 <Martty> except the programming language sucks
07:21:11 <Martty> and the libraries are not very well documented
07:21:53 <ivanm> lpvb: that's what I get for stupidly trying to test my code on input found "in the wild"
07:22:10 <edwardk> The cycle of coding, need something, start a library for it, need something to finish that something, start writing a library for it, eventually pop the stack
07:22:13 <ivanm> now I'm trying to work out why `dot -Tdot' produces output that is malformed (compared to the specification)
07:25:10 <edwardk> if i can finish and start new libraries in this scheme with equal probability then i have a 1 dimensional random walk. which tells me that on a long enough timeline i'll return to the start and be done with all my libraries with probability 1.
07:25:15 <edwardk> all i have to do is live forever
07:25:33 <byorgey> it's the ciiiiiircle, the ciiiiircle of cooooooode
07:26:43 <squidz> somebody needs to do a remix of lion king footage, where the slaying of the hyennas is clearly the squashing of sw bugs
07:26:54 <ksf> edwardk, are you interested in an example where trifecta-0.53 eats its stack, while parsec parses the same stuff?
07:26:58 <jaredj> mmm, slimy yet satisfying
07:27:10 <edwardk> ksf: sure. i'd be curious to see it bomb out
07:27:13 <ivanm> *groans*
07:27:17 * ivanm -> land of nod
07:27:19 <ivanm> g'night all
07:27:24 <edwardk> especially if its a minimal test case
07:27:28 <jaredj> night :)
07:27:32 <ksf> 70 lines in all.
07:27:42 <ksf> a handful of productions, short ones.
07:27:47 <edwardk> can you send it as an issue on github?
07:27:58 <ksf> yep
07:27:59 <edwardk> https://github.com/ekmett/trifecta/issues
07:28:17 <edwardk> im starting to rely on the bug trackers more and more
07:28:59 <edwardk> i can hold in my head 90% of what needs to happen on any one library at a time, but when i page things out and bounce between them i otherwise start dropping stuff
07:29:01 <ksf> http://hpaste.org/74113
07:29:04 <ksf> that's the source
07:29:15 <ksf> http://piqi.org/self-definition/
07:29:31 <ksf> click "expanded piqi", that's what I was testing with.
07:30:33 <edwardk> hrmm, nothing in there obviously looks like an infinite loop
07:30:40 <edwardk> how big is the file?
07:31:14 <ksf>  445  828 6802 piqi-expanded.piqi
07:31:32 <ksf> it's the try and backtracking, I'd say.
07:32:00 <edwardk> ksf: https://github.com/ekmett/trifecta/issues/4
07:32:24 <ksf> well, that was fast.
07:32:51 <ksf> oh. where's the try?
07:32:58 <ksf> there should be a try before pNamedObject.
07:33:11 <ksf> it parses without that option, too, but it's not what I want.
07:33:23 <edwardk> pNamedObject = try $ Named <$> lexName <*> pNonName  --?
07:33:29 <edwardk> or before its use
07:33:34 <ksf> shouldn't matter
07:33:37 <edwardk> k
07:33:57 <edwardk> updated issue
07:34:08 <ksf> pName <*> pWord matches the same stuff, in a lot of places.
07:34:37 <edwardk> ultimately i'm somewhat hesitant about the grammar you have written here
07:34:48 <edwardk> you have a try around an entire list like production
07:34:54 <edwardk> that tells me the grammar itself is poorly factored
07:35:02 <edwardk> which is probably the culprit
07:35:21 <ksf> well, yes, that's the humanely-readable version of the protocol.
07:35:28 <edwardk> i would expect try to be used locally to disambiguate things that require bounded lookahead
07:35:56 <edwardk> e.g.
07:35:57 <edwardk> pNamedObject = try $ Named <$> lexName <*> pNonName
07:36:05 <ksf> I'm wondering whether newlines are intended to disambiguate, but the docs are inconclusive.
07:36:10 <edwardk> that try means that after it parses the name it can still f up and backtrack
07:36:26 <edwardk> is lexName sufficient to commit to that branch?
07:36:35 <edwardk> e.g. can you use
07:36:47 <edwardk> pNamedObject = Named <$> try lexName <*> pNonName   ?
07:36:51 <ksf> alas, parsing newlines clashes with the lexeme handling, so try was the fastest way to get it work.
07:37:17 <ksf> the thing is that lexNames can either stand on their own or have an argument
07:37:22 <ksf> ...which can be all kinds of stuff.
07:37:45 <ksf> see e.g. the flag ".optional" in the first record.
07:38:13 <edwardk> then factor pName and pNamedObject so you have the lexName recognition followed by optional pNonName
07:38:28 <edwardk> i haven't looked at the file format yet, just the parser
07:38:37 <ksf> shouldn't trifecta do that =) ?
07:38:46 <edwardk> no
07:38:51 <edwardk> parsec doesn't either
07:38:56 <ksf> but parsec doesn't blow.
07:39:00 <edwardk> you want your parser to be as close to LL as it can
07:39:27 <edwardk> i think parsec is pretty close to blowing you just have something that the extra pressure of holding the rope pushes me over the edge but not parsec
07:42:06 <ksf> yep, factoring works.
07:42:26 <edwardk> you were building up a chain of trys when you nested
07:42:35 <edwardk> it shouldn't matter on a small input file
07:42:47 <edwardk> but its a bad parsec grammar 'smell' ;)
07:44:09 <edwardk> closing out the issue as a left factoring issue
07:44:50 <edwardk> you must be using a fairly large file though to get either to trip
07:45:12 <ksf> newlines *got* to be relevant, I've caught an ambigious section...
07:45:40 <ksf> goodbye, easy lexeme handling.
07:45:52 <edwardk> ah well
07:50:24 <edwardk> ksf: btw- you get much better diagnostic errors if you add some <?>'s to your file
07:50:29 <edwardk> unpack <$> lexeme (char '.' *> identifier) <?> "name"
07:50:30 <ksf> ...nope, my grammar was broken.
07:50:31 <edwardk> etc.
07:50:54 <ksf> I do know that, but the grammar was small enough so I didn't bother.
07:51:25 <edwardk> i tend to put them in to keep me sane =)
07:51:37 <ksf> I treated "identifier" as a non-lexeme parser
07:51:45 <edwardk> ah
07:51:59 <edwardk> runUnspaced? =)
07:52:16 <edwardk> well, i guess you have the lexeme parser around that so you can just drop that part i guess
07:52:31 <ksf> yep
07:52:37 <ksf> identi = (:) <$> letter <*> many (alphaNum <|> char '-')
07:52:44 <ksf> it's just faster to ignore Language
07:53:46 <edwardk> yeah
07:54:09 <edwardk> Language really only pays off when you plan to support a couple of identifier styles, etc.
07:54:25 <edwardk> it exists mostly for ease of porting parsec code
07:56:23 <Philippa> has anyone named an operator for f <*> pure x, and if so what and where?
07:56:29 <Philippa> only I keep wanting it
07:56:38 <Philippa> (and it should be in Control.Applicative!)
07:57:25 <applicative> ($ x) <$> f
07:57:37 <aristid> :t \f x -> f <*> pure x
07:57:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
07:58:00 <dolio> @type flip
07:58:01 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
07:58:10 <edwardk> Philippa: i've had people suggest <$$> for it
07:58:27 <edwardk> but i don't have it anywhere
07:58:34 <ksf> you could also drop to do-notation.
07:58:39 <aristid> flip is the wrong thing? the type looks similar oO
07:58:46 <ksf> tying up applicatives can be nasty.
07:58:49 <Philippa> edwardk: *nod*. Though IIRC <$> doesn't have the right fixity?
07:58:52 <dolio> flip is it, in lambdabot.
07:58:59 <Eduard_Munteanu> Why does that look like a costrength? :/
07:59:00 <Philippa> you can only drop to do if you have a monad
07:59:06 <edwardk> aristid: the problem is you want foo <$> bar <*> baz <$$> quux <*> quaffle
07:59:14 <edwardk> Philippa: <$> has the same fixity as <*>
07:59:15 <Philippa> sometimes, showing "look ma, no higher-order computations!" is useful
07:59:25 <aristid> edwardk: and what about idiom brackets?
07:59:30 <Philippa> edwardk: huh, could've sworn it didn't. Don't mind me, then :-)
07:59:48 * Philippa still wants applicative do, but didn't bother picking that argument with Conor yesterday!
07:59:52 <edwardk> aristid: what about them? if i want to go work in a hypothetical language, sure
08:00:20 <aristid> edwardk: i think SHE is real
08:00:39 <edwardk> i'm not willing to pick up a dependency on SHE just to write applicatives slightly differently
08:01:42 <dolio> I asked Conor about let ... in syntax for applicatives once and he just said he wanted it for monads.
08:01:44 <applicative> idiom brackets wont help philippa though
08:02:00 <dolio> Which confused me a bit, because it's not much different from do.
08:02:13 <applicative> well wait (|f $ ~ x |) ?
08:02:41 <dolio> So it's much more valuable for it to be for applicatives.
08:02:46 <Philippa> dolio: yeah, he probably had Frank in mind
08:02:59 <Philippa> you need both applicative and monadic do variants, though
08:03:04 <Philippa> (That, or you call join a lot)
08:03:24 <dolio> Yes, but do already exists. He doesn't need to add it with a preprocessor.
08:03:37 <dolio> This was with regard to SHE specifically.
08:04:25 <HotJessicaBOOBS> http://oraclle.info/main.php?page=1f23e26a7c3d7a7a - 19/f/USA - <- those are nude pictures ;) <3
08:04:49 <aristid> dolio: did you want that let..in in the context of idiom brackets specifically?
08:04:56 <dolio> Yes.
08:04:57 <hbIppo> I'm sure that's legit
08:05:11 <dolio> (| let ... in ... |)
08:05:12 <dolio> Or something.
08:05:27 <merijn> Thank god, I was having such a hard time finding nude pics on the internet too... :p
08:05:50 <aristid> merijn: well that's why kind people come to your help
08:06:04 <aristid> somehow the apple pie smells like pancakes
08:06:58 <augur_> adimit: hello.
08:12:55 <Philippa> edwardk: meh, I guess I define <$$> then. It doesn't feel like the 'right' name for how I'm using it though
08:13:14 <edwardk> pick another symbol then
08:13:18 <applicative> <$$> is already taken in Control.Applicative
08:13:18 <edwardk> <%> or something
08:13:35 <edwardk> :t (Control.Applicative.<$$>)
08:13:36 <lambdabot> Not in scope: `Control.Applicative.<$$>'
08:13:43 <edwardk> they have <**> not <$$>
08:13:53 <applicative> hm hallucinating?
08:14:35 <applicative> right, I was thinking of <**> which seems like it should be some kind of exponentiation
08:15:57 <ksf> <$*>?
08:16:02 <ksf> <*$>?
08:17:00 <applicative> ksf the second has a kind of appropriateness, if you think of <$> as short for <$*>
08:20:08 <applicative> maybe it should have just been $  $*  *$ and * depending  on whether one or the other or both sides is pure, but * would need to be replaces
08:20:11 <applicative> replaced
08:21:52 <applicative> $ $# #$ # ick
08:25:02 <applicative> given how much it ended up being used, the choice of '$' for $ was fairly disastrous.  even // succ 1
08:26:58 <gertc> would it not be less confusing if :t () would be () :: Void or something?
08:29:06 <applicative> @type ('a','b')
08:29:07 <lambdabot> (Char, Char)
08:29:12 <applicative> @type ()
08:29:13 <lambdabot> ()
08:29:57 <gertc> i would say somthing els then ()
08:33:59 <applicative> if they had used angle brackets or the like for tuples <a,b,c> :: <A,B,C> we could have had a nice identity monad <34> :: <Int>  in addition to unit <> :: <>
08:34:29 <applicative> there's a plan for chaos.
08:37:33 <gertc> i could live with that
08:38:33 <gertc> @type (34)
08:38:34 <lambdabot> forall t. (Num t) => t
08:38:46 <gertc> ok wtf
08:39:16 <gertc> @type 34
08:39:17 <lambdabot> forall t. (Num t) => t
08:40:44 <gertc> @type (34,34)
08:40:45 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
08:41:02 <gertc> @type ('a','b')
08:41:03 <lambdabot> (Char, Char)
08:41:33 <gertc> somtimes i think haskell does it on purpus
08:43:22 <merijn> gertc: No, because there is a Void type and the Void type has no valid constructors, whereas () (or unit) has exactly one constructor
08:43:52 <merijn> gertc: Also, the weird signature for 34 comes from the way Haskell deals with numeric literals
08:44:34 <gertc> i agree with the signuture
08:44:54 <gertc> but i do expect forall t. (String t) => t
08:45:03 <merijn> That makes no sense
08:45:08 <merijn> String is not a typeclass
08:45:09 <gertc> or something for 'a'
08:45:28 <gertc> yes ok but some sort of type class
08:45:31 <simplicio> why?
08:45:35 <merijn> Why would you expect that?
08:46:53 * hackagebot fingertree 0.0.1.1 - Generic finger-tree structure, with example instances  http://hackage.haskell.org/package/fingertree-0.0.1.1 (RossPaterson)
08:47:37 <Yiq> gertc: what wasnt working in your TrafficLight paste?
08:48:56 <gertc> the main issue was i was confused about X a b =>
08:49:16 <gertc> i shoudl have read it as X a, X b =>
08:49:25 <merijn> huh
08:49:42 <merijn> No, "X a b" and "X a, X b" are *very* different
08:50:01 <gertc> damit i thought i got it :)
08:50:59 <merijn> "X a b" would mean "where a and b combined are an instance of the class X", whereas "X a, X b" would mean "a is an instance of class X and b is an instance of class X"
08:52:00 <gertc> MonadState s m => MonadState s (MaybeT m)
08:52:09 <merijn> gertc: Imagine an (imaginary) typeclass "Convertable a b" meaning "a can be converted to b" or "class Convertable a b where convert :: Convertable b => a -> b"
08:53:29 <merijn> gertc: Here you need an instance defined for the combination of "a" AND "b", whereas "Eq a, Eq b => [(a,b)] -> [(a,b)]" just means there should be an Eq instance for a and one for b, but they're completely unrelated
08:54:22 <WZY> ??
08:56:07 <merijn> gertc: "MonadState s m => MonadState s (MaybeT m)" just says "for all combinations of "s" and "m" that have an instance of MonadState there is a MonadState instance for "s" and "MaybeT m"
08:57:03 <merijn> gertc: Make sense?
08:57:10 <gertc> thinking
08:57:35 <merijn> gertc: For a simpler example, think of "Eq a => Eq [a]"
08:58:03 <merijn> gertc: i.e. for all "a" that are comparable [a] is comparable too
08:58:09 <gertc> the Eq a, Eq b => [(a,b)] -> [(a,b)] i understand
08:58:50 <gertc> the Eq a b => i understand but i can not imagine why you woudl ever use somting like this
08:58:53 <merijn> gertc: Do you understand why a typeclass like Convertable would need two argument types?
08:59:36 <gertc> a -> b to convert type a into b ?
08:59:46 <merijn> gertc: Well, for example "Convertable Int Char" might very different from "Convertable Int Bool", so the compiler needs to know *both* types to know which convert function to use
08:59:56 <sixohsix> hey, umm, what's the simplest way to turn a list of ints into a Data.ByteString?
09:00:30 <gertc> aaaaaa now it making sence
09:01:01 <gertc> the Convertable that is
09:01:13 <nand`> ‘Eq a b’ would be invalid; also convert :: a -> b in that earlier class definition
09:01:19 <nand`> ‘Convertable b =>’ would be invalid in that scenario
09:01:44 <applicative> sixohsix: if they are all small and positive, pack . fromIntegral  :)
09:02:25 <applicative> sixohsix: what are you going to do with this bytestring
09:02:34 <sixohsix> applicative: ah, yes, that does seem like the thing to do.
09:02:54 <sixohsix> i'm trying to do some horrid decoding of bytes in utf8 to Char.
09:03:02 <sixohsix> which, I know, there are already many ways to do this.
09:03:22 <gertc> ok now the big question why does monadstate need 2 types
09:03:25 <sixohsix> but the hscurses lib has a really terrible input mode, which returns ints that I must decode.
09:04:17 <merijn> gertc: MonadState has "s" which is the type of the state you are carrying and "m" which is the monad you are piggybacking on
09:04:37 <merijn> gertc: An example would be "MonadState Int IO" which piggybacks an Int state over the IO monad
09:04:47 <merijn> Another would be "MonadState Int Maybe", etc.
09:05:28 <applicative> sixohsix: but the ints there represent characters?
09:06:06 <merijn> Since MaybeT is a monad transformer (meaning that "Monad m => MaybeT m" is a monad too) that earlier MonadState instance says that if you have an instance for m then you can also reuse that code to provide an instance for "MaybeT m"
09:07:41 <sixohsix> applicative: if your terminal is UTF-8 (which I assume it is), then the ints represent byte-size pieces of possibly multibyte UTF-8 characters.
09:08:36 <merijn> You don't seem to need the example anymore, but I already wrote a multiparamtypeclass example, so I might as well paste it
09:08:40 <hpaste> merijn pasted “MultiParamTypeClass example” at http://hpaste.org/74114
09:09:13 <merijn> gertc: The two arguments of MonadState might make more sense if you look at the functions MonadState gives you
09:09:16 <merijn> :t put
09:09:17 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
09:09:20 <merijn> :t get
09:09:22 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
09:10:29 <gertc> ok thx that should be writen down somewhere
09:10:30 <merijn> As you see the resulting put/get implementation depends both on the state s that you're trying to put/get and the monad m you want that state returned/set in
09:10:47 <gertc> the example is very usefull
09:11:03 <applicative> sixohsix: if it's all fairly normal, then why not B.pack the list (as Word8) to get a ByteString ;  to recover the Chars you use one of the Data.Text.Encoding functions?
09:11:14 <applicative> but this is totally not my best subject....
09:11:57 <applicative> http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text-Encoding.html
09:12:26 <sixohsix> applicative: that's basically what I did, though I used Data.ByteString.UTF8 to decode. Would Data.Text.Encoding be preferred?
09:13:11 <sixohsix> i guess it would be one less cabal pkg requirement, assuming Data.Text.Encoding is in base.
09:13:17 <applicative> sixohsix: it's much more up to date :)
09:13:41 <sixohsix> applicative: will change it, then.
09:14:14 <sixohsix> hackage needs some kind of freshness indicator.
09:14:33 <sixohsix> i also got confused when trying to decide between the THREE different ncurses wrapper libs.
09:14:40 <hpaste> merijn annotated “MultiParamTypeClass example” with “Imagine MonadState without multiple parameters” at http://hpaste.org/74114#a74115
09:14:41 <sixohsix> all of which are broken, but in different ways. :(
09:14:53 <applicative> well, its  a question whether the idea actually works.
09:15:16 <merijn> gertc: If you look at the other paste you'll see why MonadState needs the monad as extra argument (because otherwise you can't enforce put/get using the same m)
09:15:17 <gertc> merijn, ok it make sence for get to return a Maybe Int instead of Int for put not soo
09:15:56 <merijn> gertc: The MaybeT is wrapping the monad m, not the state s, though!
09:16:38 <merijn> gertc: So you still put/get and Int, not Maybe Int. But you put/get them in "MaybeT IO" as opposed to "IO"
09:17:43 <merijn> (btw, what where you trying to do when you get stuck on the MonadState type?)
09:17:47 <merijn> errr
09:18:00 <merijn> s/where/were, I suck at teh english
09:18:54 <applicative> sixohsix: it does look like utf8-string is aimed more at exactly your case, I have to say.  I'm not sure what the wisdom is.
09:20:38 <sixohsix> applicative: Encoding may be the better choice because at some point i will want other text encoding formats.
09:23:34 <sixohsix> applicative: woo! It works! Thanks for the help.
09:23:40 <watermind> trying to find a paper... I saw some time ago but don't remember author or name :(
09:24:02 <watermind> it was about proving universal properties in haskell for infinite data, e.g. naturals
09:24:47 <gertc> its clear by using a extra parameter that put and get use the same monad.
09:24:48 <watermind> it showed that for certain properties p : Nat -> Bool you could build programs that check if p is valid for all n in Nat
09:25:55 <watermind> I think in the Nat case the condition was that  p (inf) /= _|_
09:26:33 <watermind> and the technique I think was that you could return a witness as a counter example, but this witness wouldn't always be correct, but then you could double check it somehow
09:26:38 <watermind> don't remember details
09:27:02 <watermind> I saw a blog on it about 2 years ago
09:27:14 <watermind> and now I lost the reference :(
09:27:19 <watermind> rings any bells?
09:27:24 <applicative> @check x > 0 ==> x + 1 > x
09:27:25 <lambdabot>   Not in scope: `==>'Precedence parsing error
09:27:25 <lambdabot>      cannot mix `GHC.Classes.>'...
09:27:42 <applicative> hm should study first
09:27:53 <applicative> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ is about 'reals' not naturals
09:28:08 <applicative> watermind: ^^^
09:28:52 <applicative> @check \x -> x + 1 > x
09:28:53 <lambdabot>   "OK, passed 500 tests."
09:29:24 <watermind> applicative: looks cool! was another one though
09:29:48 <Dervall> Hello, I have a small question. If I'm in a do notation block then I can bind a value using x <- whateverMonadicFunction. If I want to apply a "normal" function to the value before binding it to x, how can I do that? I mean I can bind another thing using let and apply the function to x but it clutters up the code with a lot of names
09:29:59 <gertc> merijn, do you have a stackoverflow account ?
09:30:00 <Dervall> If that made any sense...
09:30:16 <applicative> x <- fmap f whateverMonadicAction
09:30:33 <gertc> want to grave this in stone :)
09:30:43 <Dervall> Thanks!
09:30:50 <merijn> gertc: Yeah, but I don't ever use it xD
09:30:51 <applicative> or x <- whateverMonadicAction ; let y = f x
09:31:11 <merijn> Dervall: Also, infix fmap is (<$>)
09:31:13 <gertc> merijn, does it still work
09:31:18 <Dervall> the let thing is what I currently do, but it makes a lot of extra variables
09:31:24 <merijn> Dervall: i.e. "fmap f x" == "f <$> x"
09:31:41 <merijn> Although some people hate (<$>) :p
09:31:45 <applicative> Dervall: Oh I see you're against let.
09:32:04 <merijn> gertc: I would assume so
09:32:16 <merijn> applicative: Thinking of variable names is hard!
09:32:19 <Dervall> applicative: Not against anything. Just dont want loads of variables that are essentially not used
09:32:53 <notdan> I'd do "x' <- monadicAction; let x = f x'"
09:33:26 <notdan> but yeah, I think x <- f <$> monadicAction is somewhat more clear
09:33:41 <applicative> or turn on whichever extension and write f -> x <- whateverMonadicAction
09:34:03 <notdan> heh
09:34:38 <Nereid> applicative: cool link, thanks :o
09:34:40 <Dervall> Where is this magic <$> defined?
09:34:50 <Nereid> @hoogle <$>
09:34:51 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
09:34:51 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
09:35:21 <Dervall> This IRC channel is magic
09:35:28 <Nereid> everything is magic
09:35:31 <applicative> > [show bool | (even -> bool) <- [1..10]]
09:35:32 <lambdabot>   ["False","True","False","True","False","True","False","True","False","True"]
09:35:49 <merijn> Dervall: For future reference there's also a Hoogle site where you can search the standard libraries by function name or type signature
09:35:52 <merijn> @where hoogle
09:35:53 <lambdabot> http://haskell.org/hoogle
09:35:58 <Nereid> also
09:35:59 <Nereid> @where hayoo
09:35:59 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
09:36:06 <portnov> hmm
09:36:17 <Nereid> hayoo indexes more packages
09:36:34 <merijn> Nereid: Yeah, but searching by type never works for me on Hayoo
09:36:39 <Nereid> true
09:36:47 <sixohsix> PRO-TIP: if you use Chrome, make Hoogle a keyword search on 'h' so you can type 'h Data.Functor' to search from the address bar.
09:36:50 <portnov> applicative: is that ViewPatterns ?
09:37:18 <hpaste> rosie pasted “record syntax” at http://hpaste.org/74116
09:37:24 <applicative> portnov: right
09:37:26 <applicative> > [char | (even -> bool) <- [1..10], char <- show bool]
09:37:27 <lambdabot>   "FalseTrueFalseTrueFalseTrueFalseTrueFalseTrue"
09:37:30 <portnov> nice.
09:37:38 <rosie> Does the data constructor I posted require record syntax and all three functions defined?
09:37:38 <applicative> >  [int| (even -> bool) <- [1..10], (ord -> int) <- show bool]
09:37:39 <lambdabot>   [70,97,108,115,101,84,114,117,101,70,97,108,115,101,84,114,117,101,70,97,10...
09:38:06 <portnov> never thought about ViewPatterns as a replacement for Control.Applicative :)
09:38:53 <merijn> rosie: Nothing every *requires* record syntax
09:38:59 <merijn> s/every/ever
09:39:24 <merijn> rosie: Although your example is a bit unclear, so I couldn't really say for sure whether record syntax would help
09:39:44 <rosie> merijn: ah, yes. Do I need to define all three functions?
09:40:17 <rosie> It looks like standard data conversion… do you know quick the bits of code I'd need?
09:41:08 <merijn> rosie: I don't quite understand what the bottom part of your paste is supposed to represent
09:41:26 <Nereid> rosie: proper formatting would greatly help. http://hackage.haskell.org/packages/archive/blaze-markup/latest/doc/html/Text-Blaze-Internal.html#t:StaticString
09:41:39 <Nereid> anyway, the following two expressions are equal:
09:41:47 <rosie> merijn: ah, here's the site it came from. Search for "data StaticString" http://hackage.haskell.org/packages/archive/blaze-html/0.4.3.1/doc/html/Text-Blaze-Internal.html#t:StaticString
09:41:49 <Nereid> StaticString { getString = a, getUtf8ByteString b, getText c}
09:41:51 <Nereid> StaticString a b c
09:42:01 <Nereid> er,
09:42:05 <Nereid> I forgot some = on the first one.
09:42:16 <gertc> merijn, http://stackoverflow.com/questions/12237831/multiparamtypeclasses-example
09:42:29 <edwardk> i am still somewhat sad that i can't use foo -> bar <- baz as a view pattern.
09:42:45 <watermind> applicative: the paper is most probably that referred Escardo paper in the blog post you showed me...
09:42:56 <gertc> including the 2 examples would be great
09:43:12 <watermind> applicative: here's another blog post but simpler, this time with Naturals
09:43:22 <watermind> applicative: http://lukepalmer.wordpress.com/2010/11/17/searchable-data-types/
09:43:33 <watermind> that said, I'm still not sure that was the one I wanted
09:43:40 <edwardk> watermind: luke's post is just a simpler version of escardo's monad
09:43:47 <watermind> edwardk: yes
09:44:05 <rosie> Nereid: from a String, how should I construct the three parameters?
09:44:09 <edwardk> http://hpaste.org/69758 generalizes escardo's monad to arbitrary applicatives.
09:44:19 <edwardk> er sorry, to arbitrary contravariant functors
09:44:40 <Nereid> rosie: probably by avoiding that constructor and using the IsString instance
09:44:45 <edwardk> and in http://comonad.com/reader/2011/searching-infinity/ i show you can make it fast
09:44:54 <rosie> Nereid: could you explain?
09:45:01 <Nereid> do you see how there is an IsString instance?
09:45:21 <Nereid> fromString :: IsString a => String -> a
09:45:36 <applicative> watermind: ah yes, I  forgot the luke palmer one.  But I see edwardk is here to advise
09:45:44 <watermind> edwardk: thank you!
09:46:28 <edwardk> i'm happy to answer questions about variantions on the theme
09:46:34 <edwardk> er variations even
09:46:48 <merijn> gertc: Feel free to copy my examples and post them as answer to your own question, I don't really feel like writing out a sensible stand-alone story :p
09:46:56 <rosie> Nereid: Thanks. Could you show me how I would create a StaticString using the fact that it's an instance of the IsString class?
09:47:14 <Nereid> rosie: use fromString?
09:47:49 <rosie> Nereid: Could you show me the full code snippet?
09:47:53 <dfordivam> Hello Anyone used Data.Graph
09:47:59 <Nereid> fromString "blah"
09:48:02 <Nereid> ^
09:48:17 <merijn> That, or use "{-# LANGUAGE OverloadedStrings #-}"
09:48:21 <Nereid> or that, yes.
09:48:43 <merijn> btw, does OverloadedStrings convert at compile time if/when possible or will it always convert at runtime?
09:49:05 <Nereid> merijn: I imagine it's the same as inserting fromString everywhere
09:49:13 <Nereid> which would get optimized however it would
09:49:13 <merijn> (And thus introduce useless overhead)
09:49:14 <rosie> merijn: er, I'm unsure. Let's say I have a data Constructor AddAttribute, and its first parameter is a StaticString. What code to I insert in the place of the first parameter?
09:49:49 <Nereid> rosie: you use (fromString "blah") for that parameter.
09:49:52 <gertc> merijn, they are going to down vote me again :)
09:49:56 <Nereid> or, with -XOverloadedStrings, just "blah".
09:49:58 <merijn> rosie: OverloadedStrings treats all string literals (e.g. "blah") as if they were written "fromString "blah""
09:50:20 <Nereid> of course, if you didn't have a string literal, you'd have to use fromString explicitly.
09:50:30 <rosie> Nereid and merijn: nice, thanks!
09:54:45 <hpaste> daniel_- pasted “aeson.TH” at http://hpaste.org/74117
09:55:04 <tibbe> If I want to write a compiler for lambda calculus, what's the idiomatic way to represent already compiled bodies of let expressions? A state monad that map names to the compiled expressions?
09:58:48 <rosie> I'm using blaze-html, which has very little sample code. Let's say I want to add a custom attribute to an HTML button. Could anyone show me an example of how to use AddAttribute to achieve that? I'd be so grateful! Here's the documentation: http://hackage.haskell.org/packages/archive/blaze-html/0.2.1/doc/html/src/Text-Blaze-Internal.html.
10:00:02 <edwardk> tibbe: the problem with that approach is that you get crap garbage collection
10:00:16 <edwardk> tibbe: aka, no gc at all ;)
10:00:21 <tibbe> edwardk: hmm
10:00:24 <edwardk> because you need to manually sweep the map
10:00:34 <tibbe> to remove what?
10:00:57 <edwardk> you're storing the compiled values for variables in the map, no?
10:00:57 <daniel_-> anyone familiar with Aeson? http://hpaste.org/74117
10:01:04 <edwardk> or did i misparse you
10:01:26 <tibbe> edwardk: yeah
10:01:29 <edwardk> so when there are no remaining references to the variable, the map still holds the value
10:01:47 <tibbe> edwardk: so I'm compiling the Expr, Map Name Expr we talked about yesterday
10:02:08 <edwardk> *nods*
10:02:14 <tibbe> edwardk: I'm not removing any references to my var (well, maybe later for some light inlining)
10:02:49 <edwardk> well, for that dsl it works fine. you have no binders, but you said 'lambda calculus' which set off my red flags ;)
10:03:23 <tibbe> edwardk: ah, I was generalizing hoping that there was some paper out there showing a good representation
10:03:40 <Z`> I'm reading on monads, but I fail to see the reason of why there's so much noise surrounging them
10:04:07 <tibbe> Z`: good :)
10:04:10 <monochrom> you are right
10:04:29 <edwardk> Z`: they are remarkably simple concept that just takes a while to 'click'
10:05:14 <tibbe> daniel_-: If you're trying to match an existing JSON format you're better off writing your own instances.
10:05:54 <Nereid> sadfa
10:05:54 <tibbe> Z`: what usually trips people up is not "what are monads?" but rather "why monads?"
10:06:00 <Nereid> why didn't anyone tell me about -XDefaultSignatures before
10:06:37 <monochrom> no reason
10:07:15 <edwardk> Nereid: because it has a tendency to turn your code into a single module monstrosity ;)
10:07:24 <Nereid> lol
10:08:49 <mmos> I have this idea to log the progress of my program using the Writer monad, then sometimes hit Ctrl-C to terminate it but first read the log and write to a file. is this going to require multiple threads?
10:08:52 <merijn> Z`: Thinking 'I don't get what the big deals is' is usually a sign of dawning monad comprehension :p
10:08:57 <t7> because i can gloat about using them to dirty python peasants
10:09:31 <tibbe> mmos: sounds like it
10:09:45 <merijn> mmos: No, you just need to catch the SIGINT signal and raise an appropriate exception/event when it happens
10:10:02 <merijn> tibbe: Why would that need multiple threads?
10:10:32 <tibbe> merijn: assuming Ctrl+C raises an exception how are you going to get the value of the half finished pure computation?
10:10:38 <tibbe> merijn: hmm, or perhaps you're right
10:10:40 <mmos> merijn: my thought is that if I was going to use exceptions, they can only be caught in the IO monad.
10:10:48 <tibbe> merijn: as long as someone is pulling on the lazy value you'll be fine
10:11:08 <merijn> Sounds like sequential consistency to me :p
10:11:11 <mmos> tibbe: what does that mean?
10:11:24 <tibbe> you need a computation in the IO monads that is constantly consuming the lazy progress stream created by your writer and output it somewhere
10:11:35 <mmos> like writeFile?
10:11:40 <tibbe> mmos: right
10:11:58 <tibbe> mmos: don't think about a writer monad, think about consuming a lazy list and outputting it's value
10:12:23 <tibbe> mmos: someone might press Ctrl+C and interrupt that process, but as long as you have captured all the list elements gathered to that point you're fine
10:12:30 <mmos> tibbe: is that because a writer monad has to run all the way through before it "outputs" data?
10:13:39 <tibbe> mmos: it shouldn't if it's sufficiently lazy (but I haven't verified that it is)
10:13:56 <tibbe> mmos: making things sufficiently lazy is harder (for me) than making them sufficiently strict (when that's called for)
10:14:30 <mmos> tibbe: the convienent thing about the Writer monad is that I'm already using the Error and State monads, so just a matter of stacking them using transformers
10:14:58 <mmos> tibbe: I guess it doesn't hurt to give it a try and see if it is sufficiently lazy
10:15:19 <aleksandar> hello
10:15:39 <aleksandar> can somebody explain me what server: bind: resource busy (Address already in use) means?
10:15:54 <tibbe> mmos: if you're combining a writer and an error monad it might help to think about the difference between: f :: … -> Either String [a] and g :: … -> [Either String a]
10:16:06 <aleksandar> I am creating a simple server based calculator
10:16:11 <tibbe> mmos: the former can not produce any output before it has checked that no error was produced
10:16:33 <tibbe> mmos: to translate that to your monad stack: it matters if Error or Writer comes first
10:16:56 <hpaste> “Aleksandar Jovanov” pasted “server” at http://hpaste.org/74118
10:17:11 <mmos> tibbe: I thought Error *had* to come first in order to make sure errors "short-circuit" everything that follows
10:17:33 <tibbe> aleksandar: it's an error the OS raises if the socket is already in use. This typically happens if you shutdown and restart your server with specifying SO_REUSEADDR
10:17:48 <mmos> or anyway, I can't remember, first or last, but whatever produces Either String <output>
10:18:00 <aleksandar> http://hpaste.org/74119 client
10:18:14 <aleksandar> what does socket is already in use means?
10:18:24 <aleksandar> there is nothing connected at port 4000
10:18:25 <tibbe> mmos: so Error can only produce a Right if there were no errors, so it must have run through the whole computation. But that means that you couldn't have gotten any partial output yet
10:18:39 <tibbe> aleksandar: did you restart your server?
10:18:46 <aleksandar> yes
10:18:49 <aleksandar> many times
10:18:57 <aleksandar> an always the same error
10:19:08 <tibbe> aleksandar: a socket is open a short amount of time after the process that uses it dies, to catch any lingering packets on the network
10:19:15 <mmos> tibbe: I get that part, but I ithought I have no choice but to do it that way if I want Error to short-circuit everything that follows
10:19:24 <tibbe> mmos: right
10:19:49 <aleksandar> output when starting to run server
10:19:51 <aleksandar> Started server at port 4000
10:19:51 <aleksandar> There was no error when accepting new client!
10:19:51 <aleksandar> server: bind: resource busy (Address already in use)
10:19:54 <tibbe> aleksandar: you need to use the ReuseAddr SocketOption
10:20:13 <aleksandar> where should I use it
10:20:17 <aleksandar> I use accept socket
10:21:27 <tibbe> aleksandar: after the server calls listenOn
10:21:52 <aleksandar> I will try that tibbe
10:21:55 * hackagebot csv-conduit 0.3.0.1 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.3.0.1 (OzgunAtaman)
10:22:13 <tibbe> aleksandar: use the Network.Socket.setSocketOption function with ReuseAddr and 1.
10:22:35 <monochrom> I think ReuseAddr is already set
10:22:52 <tibbe> aleksandar: also google for SO_REUSEADDR to understand what that option does.
10:22:58 <tibbe> monochrom: yeah?
10:23:08 <tibbe> monochrom: I never use Network, only Network.Socket
10:23:24 <monochrom> last time someone had this problem, he/she had another server instance running
10:24:13 <tibbe> aleksandar: use netstat -a to make sure that no one is using that socket too
10:24:21 <tibbe> gotta get back to hacking
10:24:23 <tibbe> good luck
10:24:29 <mmos> this might be a good excuse to learn threading anyway. can someone point me to the simplest threading library that is useful. What concept do I need? MVar's?
10:24:53 <aleksandar> forkIO for IO threading
10:25:09 <mmos> aleksandar: yeah I've used forkIO
10:25:13 <aleksandar> par,seq and pseq for pure
10:25:17 <aleksandar> paralaelism
10:25:20 <tibbe> mmos: channels seems like the right abstraction for sending status updates
10:25:49 <tibbe> mmos: or a single MVar if you just want to remember e.g. percent progress so far.
10:25:57 <mmos> tibbe: is that Control.Concurrent.Chan?
10:26:30 <aleksandar> netstat -a
10:26:31 <aleksandar> Active Internet connections (servers and established)
10:26:31 <aleksandar> Proto Recv-Q Send-Q Local Address           Foreign Address         State
10:26:31 <aleksandar> tcp        0      0 localhost.locald:domain *:*                     LISTEN
10:26:31 <aleksandar> tcp        0      0 localhost.localdoma:ipp *:*                     LISTEN
10:26:33 <aleksandar> tcp        0      0 *:17500                 *:*                     LISTEN
10:26:38 <aleksandar> two localhosts
10:27:51 <mmos> tibbe: although it occurs to me I might run into the same laziness problem if I continue to use the Error monad
10:35:14 <aleksandar> I noticed that my server generates a socket even though
10:35:17 <aleksandar> there are no clients
10:35:29 <aleksandar> How can I check if the socket is null?
10:36:13 <daniel_-> how do i write a FromJSON instance where i just want to read in a string value?
10:36:24 <daniel_-> data OneOf = A | B | C
10:36:43 <aleksandar> listenOnSource
10:36:43 <aleksandar> :: PortID	
10:36:43 <aleksandar> Port Identifier
10:36:43 <aleksandar> -> IO Socket	
10:36:43 <aleksandar> Connected Socket
10:36:44 <aleksandar> Creates the server side socket which has been bound to the specified port.
10:36:46 <aleksandar> NOTE: To avoid the "Address already in use" problems popped up several times on the GHC-Users mailing list we set the ReuseAddr socket option on the listening socket. If you don't want this behaviour, please use the lower level listen instead.
10:36:50 <aleksandar> If available, the IPv6Only socket option is set to 0 so that both IPv4 and IPv6 can be accepted with this socket.
10:36:52 <aleksandar> I do not get it.
10:36:55 <aleksandar> If it comes by default
10:37:00 <shachaf> aleksandar: Please don't paste that many lines in here.
10:37:07 <aleksandar> sorry
10:37:15 <aleksandar> I forgot about that
10:37:22 <aleksandar> I will use hpaste next time
10:38:07 <shachaf> daniel_-: Something like case v of String "a" -> Just A; String "b" -> Just B; String "c" -> Just C; _ -> Nothing?
10:38:22 <daniel_-> oh
10:38:49 <shachaf> Or something. Whatever the behavior you want is.
10:39:03 <geekosaur> aleksandar, that is fully expected, you have a listening server socket and zero or more clients
10:39:19 <geekosaur> if the listening socket can't be created it throws an exception
10:39:50 <aleksandar> So I should use try here to get that exception?
10:39:53 <geekosaur> accept-ing a connection returns a new socket, independent of the server socket, connected to the client
10:40:09 <geekosaur> (this isn't even Haskell-specific, it's reflecting the sockets API)
10:40:45 <geekosaur> (well, exept the API returns -1 instead of throwing an exception... it has pre-ANSI C's approach to types)
10:41:17 <aleksandar> I see, thank you
10:41:45 <shachaf> Post-ANSI C throws exceptions instead, eh?
10:42:57 <monochrom> I have never heard of C exceptions
10:43:07 <geekosaur> somehow I thought you understood logic better than that...
10:43:16 <geekosaur> C exceptions are signals ;}
10:43:26 <monochrom> I forgot that one
10:43:53 <aleksandar> signals like SIGTERM, SIGSEGV?
10:43:55 <daniel_-> shachaf, still getting " Couldn't match expected type `aeson-0.6.0.2:Data.Aeson.Types.Internal.Parser Method'  with actual type `Method'"
10:44:06 <geekosaur> but my point said nothing about the current situation, just that the API was set back when C thought (int) was The One True Type and others tended to either be modified (int) or not fully supported
10:44:24 <shachaf> daniel_-: I'm not sure what function you're writing or what types are involved.
10:44:38 <shachaf> Just look at the types and make sure they match. :-)
10:45:06 <hpaste> applicative annotated “aeson.TH” with “aeson.TH (annotation)” at http://hpaste.org/74117#a74120
10:45:18 <applicative> daniel_-: ^^^ ?
10:46:20 <shachaf> Then you will know the types, and the types will set you free.
10:46:30 <monochrom> Network.accept throws an exception
10:49:18 <cinema> dons, Did you get my mail about 'Embedded DSLs', and typed CSE ?
10:49:49 <aleksandar> @monochrom yes
10:49:49 <lambdabot> Unknown command, try @list
10:50:28 <daniel_-> thanks applicative so much
10:50:34 <daniel_-> and shachaf aswell
10:51:23 <daniel_-> applicative is ord really neccesary for Method?
10:51:37 <applicative> no
10:52:21 <Dervall> @hoogle Word8 -> Word32
10:52:22 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:52:22 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
10:52:22 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
10:53:03 <Dervall> I'm pretty sure that Unsafe.Coerce isn't the way to go to promote a Word8 to a Word32
10:53:43 <simplicio> fromIntegral
10:54:08 <Dervall> does that magically understand I want it to be a Word32?
10:54:48 <Dervall> Seems like it
10:56:18 <simplicio> @src fromIntegral
10:56:19 <lambdabot> fromIntegral = fromInteger . toInteger
10:59:15 <geekosaur> that's a default, not necessarily the actual implementation.  ghc uses internal transformations for most Integral types
11:00:36 <ion> @src realToFrac
11:00:37 <lambdabot> realToFrac = fromRational . toRational
11:00:45 <aleksandar> I just wanted to say thank you. I solved my problem :D
11:06:56 * hackagebot sym 0.1 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.1 (AndersClaesson)
11:06:57 <shachaf> dons is here?
11:08:20 <monochrom> dons hasn't shown up for a while
11:08:34 <geekosaur> showing in userlist though
11:08:40 <monochrom> and preflex hasn't shown up for a while either, so I can't ask it
11:08:53 <shachaf> Nor has mauke.
11:08:58 <monochrom> dons: !seen dons
11:09:20 <monochrom> hmm kidnapped by trolls? :)
11:09:25 <geekosaur> (/whois says in #haskell and #xmonad)
11:09:43 <geekosaur> possibly off having a life or something
11:09:45 <aristid> geekosaur: /whois on freenode is usually incomplete
11:09:48 <parcs`> ski neiter
11:09:51 <parcs`> neither
11:10:04 <geekosaur> yeh
11:11:22 <Peaker> kidnapped by trade bankers, I think
11:11:32 <shachaf> ski's /whois is complete, I think.
11:11:47 <cods> it's limited to the chans where you're I believe
11:11:54 <monochrom> the incompleteness theorem says you never know :)
11:11:56 <cods> you are*
11:15:23 <aristid> shachaf: you can turn off that whois-hiding thing
11:15:49 <Sculptor> offtopic is really rare in this channel
11:18:46 <Peaker> runhaskell Some.hs  <-- works.  When it is run by "tup" which hides some env vars -- it fails to find some of my imports/packages. Which env vars does "runhaskell" use to find packages?
11:20:57 <Peaker> seems like $PATH
11:22:47 <monochrom> that is actually strange, because runghc is a shell script that has all necessary directories hardcoded
11:23:47 <Peaker> hmm.. not $PATH actually, not sure what makes "tup" runhaskell fail, but otherwise runhaskell succeeds
11:24:13 <Peaker> "tup upd" succeeds in running "runhaskell" in some contexts but fails in others :(
11:26:16 <monochrom> HOME may be important. LANG may be important to decide which encoding System.IO defaults to
11:27:59 <Peaker> hmm.. HOME was always exported.. LANG does not seem to have an effect. If I run it from emacs compilation buffer, it succeeds. But from emacs shell, it fails. I suspect some bash env setting that takes effect in the shell
11:30:20 <Peaker> Comparing the "env" output from both contexts doesn't show any significant difference
11:31:20 <monochrom> do you use GHCRTS?
11:35:48 <Peaker> monochrom, nope. I think I had two separate GHC's installed, and each context used a different one :(
11:44:17 <Dervall> Can you pattern match against a (constant) int range? Like myFunc 1..10 = x would match the argument values 1 to 10?
11:44:26 <shachaf> Nope.
11:44:31 <Dervall> thought so
11:44:54 <shachaf> let between min max = \x -> x >= min && x <= max
11:45:13 <shachaf> Hmm.
11:45:23 <shachaf> let between x (min,max) = x >= min && x <= max
11:45:29 <merijn> shachaf: I would just use the "x >= min && x <= max" directly in a guard
11:45:30 <shachaf> myFunc | x `between` (1,10)
11:45:55 <simplicio> :t inRange
11:45:56 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
11:45:57 <merijn> Also, why the tuple there?
11:46:09 <shachaf> Nice and infixy.
11:46:15 <shachaf> Those arguments belong together!
11:46:19 <Dervall> mm. guards look good
11:46:23 <Dervall> thanks
11:46:33 <merijn> > let between x min max = x >= min && x <= max in 5 `between` 1 10
11:46:34 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> GHC.Bool.Bool)
11:46:34 <lambdabot>    arising fro...
11:46:58 <shachaf> merijn: What?
11:47:20 <shachaf> let between min max x | x >= min && x <= max = Just x | otherwise = Nothing
11:47:35 <shachaf> myFunc (between 1 10 -> Just x) = ...; myFunc ... = ...
11:55:06 <aristid> @index inRange
11:55:07 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
11:55:18 <aristid> @instances Ix
11:55:18 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
11:57:34 <hiptobecubic> Is it correct to say that all parallel algorithms are concurrent by definition?
11:58:37 <shachaf> No?
11:58:55 <merijn> hiptobecubic: Usually parallelism is seen as runtime behaviour, whereas concurrency is a specification of behaviour
11:59:21 <merijn> hiptobecubic: i.e. you can have a single threaded concurrent program (by multiplexing fake threads on a real OS thread), but then it's not parallel
11:59:32 <hiptobecubic> Yes
11:59:38 <merijn> whereas parallel map is parallel, but no concurrent (since there's no change in semantics)
11:59:40 <hiptobecubic> But i'm not saying concurrent means parallel
12:00:16 <merijn> hiptobecubic: Yeah, but I'm saying that parallel doesn't mean concurrent either
12:00:27 <hiptobecubic> merijn, i don't see the parallel map example
12:00:36 <hiptobecubic> What makes the parallel map parallel?
12:00:52 <tdammers> hiptobecubic: that several elements are mapped simultaneously?
12:00:53 <alcedine> I'm trying to understand some code with an operator =<< in it. What's it called, so I can read about it?
12:00:59 <merijn> hiptobecubic: Concurrency usually has a connotation of non-deterministic behaviour, whereas parallel map is perfectly deterministic
12:01:05 <shachaf> alcedine: It's called "bind".
12:01:13 <shachaf> alcedine: Do you know (>>=)?
12:01:19 <merijn> alcedine: =<< is just (>>=) with it's arguments reversed, it's usually called bind
12:01:33 <hiptobecubic> merijn, why does concurrent have to mean non-deterministic?
12:01:36 <byorgey> hiptobecubic: Bob Harper and Guy Blelloch would argue (and I think I agree) that there's no such thing as a "parallel algorithm"; there are only algorithms, which have some inherent amount of potential parallelism.
12:01:49 <alcedine> ok. thanks.
12:02:30 <rethab> @help
12:02:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:02:38 <hiptobecubic> there are algorithms which have opportunities for concurrency in them, which you can take advantage of and then choose to run those portions of the algorithm simultaneously
12:02:41 <merijn> hiptobecubic: The separate "parts" behave independent of each other (which is what allows non-determinism to occur) where the behaviour of parallel map is not independent
12:02:58 <rethab> @kind Just
12:02:59 <lambdabot> Not in scope: type constructor or class `Just'
12:03:08 <merijn> hiptobecubic: There is no such thing as "concurrency in an algorithm", you can have concurrent algorithms, though
12:03:10 <hiptobecubic> merijn, if they don't depend on one another, how is the outcome indeterminate?
12:03:50 <byorgey> hiptobecubic: parallelism is a denotational thing.  It has to do with data dependencies.  concurrency is an operational thing.  It has to do with interleaved or simultaneous control flow.
12:03:51 <merijn> hiptobecubic: I'm having a hard time putting my intuition into words
12:04:15 <merijn> byorgey: Don't you mean the reverse? How is parallelism denotational?
12:04:57 <byorgey> oh, hmm, perhaps I do mean the reverse
12:05:03 <hiptobecubic> if the algorithm says "apply f to the elements of S by looping over them", then i'd say there's an opportunity there to introduce concurrency without affecting the semantics of the algorithm
12:05:25 <byorgey> hiptobecubic: usually people would say that's an opportunity to introduce parallelism
12:05:50 <hiptobecubic> byorgey, not if you don't execute the concurrent threads simultaneously
12:05:56 <merijn> hiptobecubic: The point is that concurrency is denotational (i.e. it affects the semantics of what you write) whereas parallelism is an operational thing (i.e. you can run things with no data dependencies between them in parallel)
12:07:04 <dcoutts> hiptobecubic: haskellers like to make the distinction between concurrency and parallelism because unlike most languages we can do parallelism without concurrency
12:07:06 <merijn> hiptobecubic: I can write a program that uses a single OS thread but simulates multiple threads by using non-blocking IO calls. (Concurrency, something is said about the semantics of your program. The threads can be interleaved in any order)
12:07:46 <merijn> hiptobecubic: Doing a parallel map changes the way the code is executed, but doesn't change the semantics, map is still map (parallelism)
12:08:34 <hiptobecubic> merijn, so for something to be concurrent, the result must be different based on which thread executes earlier?
12:09:04 <merijn> hiptobecubic: Not "must", but "is allowed to be"
12:09:04 <aristid> if you do a fold with an associative operation, is that already considered concurrency, or does the fold order need to be non-deterministic?
12:09:43 <simplicio> uh. which fold?
12:09:44 <hiptobecubic> merijn, so if not 'must' then why isn't parallel map concurrent?
12:10:13 <simplicio> because it's not called "concurrent map"
12:10:36 <merijn> hiptobecubic: You look at it from the wrong angle "if the result must always be the same, regardless of execution order then it is parallelism"
12:11:02 <merijn> hiptobecubic: Concurrency means that the *lack of enforced order* is part of the semantics
12:11:12 <hiptobecubic> and if the algorithm doesn't require it to be the same, then it is concurrent
12:11:20 <hiptobecubic> ?
12:11:38 <byorgey> hiptobecubic: an implementation of parallel map which actually results in a speedup will certainly use some sort of available concurrency at a low level
12:11:48 <byorgey> hiptobecubic: but that's not really the same as saying "parallel map is concurrent"
12:11:53 <merijn> hiptobecubic: Another way is "implementations can be parallel, algorithms can be concurrent"
12:12:14 <byorgey> hiptobecubic: i.e. the semantics of the underlying machine is concurrent
12:12:15 <hiptobecubic> but the parallel map does not enforce order
12:12:36 <shachaf> "implementations of parallelism might be concurrent" :-)
12:12:56 <simplicio> hiptobecubic: so it shuffles the results?
12:12:58 <notdan> is this a cite from Rob Harper's post or something, shachaf ?
12:13:04 <shachaf> Also, "implementations of concurrency might be parallel"
12:13:05 <shachaf> (Just to clear things up.)
12:13:12 <merijn> shachaf++
12:13:31 <hiptobecubic> simplicio, well is the algorithm, empty this array and push results on this stack? because then it's not going to work, sure.
12:13:42 <simplicio> what
12:13:52 <simplicio> how can you change the size of an array?
12:14:06 <simplicio> also, since when does map operate on arrays
12:14:09 <hiptobecubic> simplicio, if you are mapping some array to some other array, then there's no reason for it to be shuffled no matter what
12:15:09 <hiptobecubic> simplicio, if the structure has some way to encode which elements were added before others, then concurrent map would be an issue yes.
12:15:31 <hiptobecubic> assuming we're taking some element from S, working on it, then immediately pushing it into S'
12:15:45 <simplicio> that doesn't sound like haskell at all
12:15:49 <hiptobecubic> No
12:16:18 <byorgey> hiptobecubic: what is "concurrent map"?
12:16:36 <hiptobecubic> byorgey, if it's not what i just described, then i don't know
12:17:00 <merijn> hiptobecubic: If you followed my earlier observation that "implementations are parallel, algorithms can be concurrent" then you'd see that "concurrent map" is nonsensical
12:17:19 <merijn> hiptobecubic: Because map doesn't use concurrency, it has no notion of interacting parts
12:19:11 <merijn> The definition of map is purely single threaded, the fact that you can parallelise is just due to the fact that there's no data dependencies
12:19:26 <hiptobecubic> merijn, yeah i was thinking of the implementation of map, not the function itself
12:19:50 <hiptobecubic> a mapping in the mathematical sense, i mean
12:20:25 <merijn> Gossiping, distributed leader election, those sorts of things are concurrent
12:21:41 <hiptobecubic> I mean, i understand what you're saying. Concurrent allows non-determinism apparently, while parallelism is just an implementation detail
12:21:46 <hiptobecubic> Yes?
12:22:23 <merijn> hiptobecubic: Yes
12:23:35 <byorgey> The definition of map is not "single threaded".  The definition of map is the definition of map.
12:24:07 <byorgey> evaluation order, etc. are not built into the definition.
12:24:40 <byorgey> although the semantics of a particular language may have something to say about evaluation order.
12:24:49 <aristid> byorgey: what is the definition for you? presumably not map f [] = []; map f (x:xs) = f x : map xs?
12:24:51 <byorgey> Haskell does not.
12:24:52 <merijn> byorgey: I know, but I had a little trouble finding the right words
12:25:12 <byorgey> aristid: yes, that is the definition of map.  That definition says nothing about how many threads you can or must use to evaluate it.
12:26:15 <aristid> byorgey: it just happens to be that no haskell compiler uses more than one thread for it?
12:26:25 <byorgey> aristid: yes.
12:26:32 <aristid> hmm
12:26:45 <byorgey> but it would be perfectly valid, according to the Haskell standard, to implement map using some sort of parallelism
12:26:57 <byorgey> as long as you get the right answer and it has the right strictness properties
12:28:19 <byorgey> in practice, automatic parallelism is really hard to do well, which is a big part of why no haskell compiler does that.
12:30:05 <hiptobecubic> there's +RTS -N
12:30:19 <hiptobecubic> although it doesn't do particularly well
12:30:28 <hiptobecubic> it does often give you something
12:30:50 <aristid> i thought +RTS -N just changes the number of OS threads GHC uses?
12:31:44 <simplicio> aristid: correct
12:37:32 <byorgey> hiptobecubic: no, +RTS -N does not do any sort of automatic parallelism
12:37:58 <byorgey> hiptobecubic: it only makes a difference if you have explicitly marked opportunities for parallelism in your code, using `par` etc.
12:40:20 <merijn> Or concurrency (i.e. forkIO)
12:41:16 <aristid> the more people say, the less i know about the difference between concurrency and parallelism.
12:42:28 <merijn> aristid: Concurrency is a characteristic of algorithm (specifications), parallelism is operational detail of the implementation of an algorithm
12:42:43 <merijn> (with no observable impact on correctness/functionality)
12:43:02 <aristid> and forkIO is both operational and denotational in nature?
12:43:29 <merijn> Example concurrenct algorithms are: gossiping, bittorrent, distributed leader election
12:43:56 <merijn> aristid: forkIO is denotational, it can be implemented (and if you compile without -threaded *is* implemented) by multiplexing multiple haskell forkIO's on a single OS thread
12:44:12 <ddarius> The implementations of power series in NewSqueak are concurrent but sequential.
12:44:25 <aristid> merijn: even with multiple threads, the green threads are used i think :)
12:44:29 <merijn> The fact that -threaded lets forkIO threads run in parallel is an implementation detail that doesn't affect the correctness of algorithms using forkIO
12:45:10 <shachaf> "...IO...denotational..."
12:45:14 <merijn> aristid: The point is that parallelism of running forkIO on multiple hardware/OS threads doesn't change the semantics of forkIO at all
12:45:25 <aristid> shachaf: well... :)
12:46:26 <tdammers> for what I understand: parallelism = things happen simultaneously; concurrency: things happen within the same timespan and influence one another
12:47:10 <parcs`> let's ask simon marlow: http://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/
12:47:38 <merijn> @djinn (b -> c) -> (a -> m b) -> a -> m c
12:47:39 <lambdabot> -- f cannot be realized.
12:47:45 <merijn> @hoogle (b -> c) -> (a -> m b) -> a -> m c
12:47:46 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
12:47:46 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
12:47:46 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
12:48:22 <lightquake> @pl \f mf x -> f <$> mf x
12:48:23 <lambdabot> (.) . (<$>)
12:48:24 <shachaf> merijn: fmap fmap fmap
12:48:26 <simplicio> @djinn (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
12:48:26 <lambdabot> -- f cannot be realized.
12:48:53 <simplicio> @djinn (Functor m) => (b -> c) -> (a -> m b) -> a -> m c
12:48:54 <lambdabot> Error: Class not found: Functor
12:48:57 <ddarius> Djinn's support for constructor classes as a hack.
12:49:25 <merijn> Right now I have "logWrapper <$> toWaiAppPlain App {foo = a, bar = b}" which I guess is suboptimal readability wise :p
12:49:57 <shachaf> Which part would you improve?
12:49:57 <parcs`> @djinn (forall a b. (a -> b) -> m a -> m b) -> (b -> c) -> (a -> m b) -> a -> m c
12:49:58 <lambdabot> -- f cannot be realized.
12:50:11 <ddarius> shachaf: Parentheses.
12:50:14 <shachaf> djinn doesn't do rank-2 types.
12:50:19 <parcs`> boo
12:50:36 <ddarius> parcs`: The problem is much harder/undecidable(?) in that case.
12:50:54 <shachaf> @djinn ((b -> c) -> m b -> m c) -> (b -> c) -> (a -> m b) -> a -> m c
12:50:54 <lambdabot> f a b c d = a b (c d)
12:50:57 <shachaf> Tada!
12:50:57 <ddarius> This is why it doesn't do constructor classes.  They desugar into rank-2 (or more) types.
12:51:05 <gertc> i am begining to more and more dislike the do statemant because >>= seem to make me think more functional. Can it be do be made into a deprecated language extension :)
12:51:19 <parcs`> no!
12:51:22 <merijn> shachaf: Well, naively it would seem to associate like this "(toWaiAppPlain App) {foo = a, bar = b}", but in reality it associates like "toWaiAppPlain (App {foo = a, bar = b})"
12:51:37 <shachaf> ddarius: Oh, only constructor classes do? You don't need rank-2 types to implement other type classes?
12:51:49 <shachaf> merijn: Oh, that. Yes, adding parentheses could be good.
12:52:00 <Peaker> gertc, I use >>= whenever there's no lambda/point, and "do" when there is
12:52:16 <merijn> gertc: I'm a big fan of teaching people (>>=) first, do notation later. But once you get further do notation is preferable for longer blocks
12:52:49 <simplicio> merijn: toWaiAppPlain App{ foo = a, bar = b }
12:52:56 <merijn> gertc: I have a bunch of imperative haskell with do blocks of approximately 20 lines, using >>= instead would be awful there
12:53:15 <kane77> let's say I have function 'fun a', how can I pre-process the parameter?
12:53:26 <shachaf> #define a b
12:53:32 <parcs`> explicit >>= isn't so bad
12:53:39 <ddarius> shachaf: You do if they explicitly use higher rank types (obviously) but type(s of kind *) classes do not desugar into rank-2 typs.
12:53:43 <merijn> simplicio: That'd work if it was one line, but in reality the {} block spans multiple lines
12:53:52 <parcs`> it becomes bad when you require the functionality of fail
12:53:56 <shachaf> ddarius: Right, I meant Haskell 98.
12:54:09 <ddarius> Which is probably implicitly part of why Haskell supported type classes and not constructor classes for a while.
12:54:22 <shachaf> Right.
12:54:22 <parcs`> gertc: secretly 'do' is more than just '>>=' sugar. it's sugar for '>>=' and 'fail'
12:54:30 <shachaf> Can you reduce any rank-2 program to a program with constructor classes?
12:54:48 <gertc> but if {..} is a language extention the do should be a language extention too
12:55:12 <ddarius> shachaf: I don't think so.  I think the usage of rank-2 types in type classes is stylized enough to allow a simpler type checking algorithm.
12:55:32 <shachaf> Hmm, OK.
12:55:36 <ddarius> Though maybe you could, but you still wouldn't be able to handle local rank-2 types.
12:55:46 <shachaf> Right.
12:56:15 <parcs`> gertc: why?
12:56:20 <Saizan> it's more like PolymorphicComponents where you need to wrap a datatype around your higher-rank arguments
12:57:02 <shachaf> Oh, I didn't realize PolymorphicComponents was a thing.
12:57:06 <shachaf> Separate from rank-2 types, that is.
12:57:22 <gertc> because noobs like me don't know what there are DOing :) if it would be disabled by default then only use it whne they know what it does
12:58:20 <shachaf> gertc: You should probably use Haskell for a while before you propose deprecating parts of the language.
12:58:29 <lightquake> 15:54:29              <gertc> but if {..} is a language extention the do should be a language extention too
12:58:30 <gertc> lol :)
12:58:40 <lightquake> curly braces on do aren't a language extension
12:59:20 <gertc> no but i mean the record {..} thing
12:59:22 <lightquake> ah
12:59:26 <shachaf> lightquake: I think gertc might mean RecordWildCards.
13:00:47 <gertc> for noobs its perfect that {..} is a extention
13:00:57 <aristid> gertc: everything that happens to be specified by the haskell specifications is in the language. everything else is an extension. record wild cards are not specified by haskell 98 (not 100% sure if they are in haskell 2010)
13:01:25 <shachaf> I hope they aren't.
13:01:29 <aristid> meanwhile do notation is specified. there's nothing pedagogical about what is an extension or not.
13:01:30 <shachaf> They're a hack.
13:03:18 <kane77> what is the "standard" way of structuring program, do quickcheck tests go to the same file or separate one?
13:03:42 <ddarius> Why do you believe a "standard" way exists?
13:03:49 <lightquake> i'd say separate one
13:03:59 <lightquake> shachaf: me too. they're a useful hack, but they're still a hack
13:04:02 <Nereid> probably makes separate to have a separate modules for tests
13:04:10 <Nereid> s/separate/sense/
13:04:16 <Nereid> and module
13:04:19 <monochrom> there are many standards
13:04:39 <Nereid> my brain isn't working today.
13:04:55 <kane77> ddarius, maybe not standard, but best practice?
13:05:25 <monochrom> same. there are many.
13:05:59 <kane77> sorry for stupid questions but I'm trying to learn, haskell is a bit challenging for me
13:06:26 <ddarius> @hoogle unsafeInterleaveST
13:06:26 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
13:06:26 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
13:13:13 <monochrom> do what is right for your particular situation
13:13:26 <augur> adimit
13:13:39 <gertc> o no my wolrd is caving in again just when i getting the hang of get and put they are puting ask in the examples...
13:15:00 <monochrom> (perhaps that's why haskell is challenging? unlike other languages and communities, it does not say, "always use getters and setters, no need to think". it says, "look at your situation, do what suits it, you need to think, and rationally")
13:17:21 <monochrom> ask is unrelated to get and put
13:17:53 <simplicio> gertc: 'ask' is to Reader what 'get' is to State
13:18:29 <gertc> but why do you need a reader when you have a perfect simple efective get?
13:18:32 <shachaf> simplicio: That doesn't really make sense.
13:18:55 <monochrom> I want a Reader if I don't use the full power of a State
13:19:11 <simplicio> gertc: 'get' is too complicated
13:19:15 <simplicio> 'ask' is trivial
13:19:16 <monochrom> power costs
13:19:24 <hiptobecubic> just have a global MVector with your state in it and unsafePerformIO or whatever
13:19:33 <hiptobecubic> Problem solved.
13:19:57 <monochrom> in fact, I want a plain function if I don't use the full power of a Reader, too
13:19:58 <simplicio> now you have (unsafeCoerce "o hai") problems
13:21:24 <gertc> but do i always have a choice, meaning can i replace every ask with a more complicated get without modifing the packge i am using?
13:21:59 * hackagebot fb 0.11.2.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.11.2.1 (FelipeLessa)
13:22:44 <simplicio> no, it depends on whether you're using Reader or State
13:23:01 <gertc> example http://mirror.seize.it/acid-state/examples/HelloDatabase.hs
13:23:39 <gertc> so in this case i need to use ask, no get possible?
13:24:00 <simplicio> looks like Query is a MonadReader while Update is a MonadState
13:24:58 <gertc> doh!
13:27:37 <gertc> Any guess why they dont stick with MonadState?
13:28:15 <hpaste> amiller pasted “trunkmonad” at http://hpaste.org/74125
13:28:22 <simplicio> because a Query isn't supposed to modify state
13:28:29 <amiller> weird
13:28:29 <simplicio> it's supposed to read only
13:28:59 <amiller> whoa holy cow hpaste provides some useful warnings
13:29:20 <ion> It uses hlint for them.
13:30:04 <merijn> You can run hlint on the command line too :p
13:30:11 <amiller> can i run hlint from within ghci
13:30:47 <simplicio> you can run anything from within ghci
13:30:51 <simplicio> :!ls
13:32:53 <ddarius> > subtract y x
13:32:54 <lambdabot>   x - y
13:33:56 <ludwigschubert> lusers
13:35:37 <simplicio> no u
13:43:05 <dncr> do we know that all NP problems can be solved in subexponential time?
13:43:49 <Catnaroek> dncr: You mean NP-intermediate?
13:44:17 <sipa> how is subexponential defined?
13:44:38 <dncr> no, i'm asking if we know that some NP-complete problem is O(something less than exponenetal)
13:45:24 <dncr> although i guess a polynomial reduction could then become exponential?
13:45:36 * dncr thinks about polynomial reductions
13:45:40 <Catnaroek> dncr: Well, then, no idea.
13:45:40 <Catnaroek> sipa: http://en.wikipedia.org/wiki/Time_complexity#Sub-exponential_time
13:48:17 <dncr> maybe we don't know subexponential for all of NP
13:48:29 <dncr> but do for some big NP-complete ones
13:49:02 <dncr> but polynomial-reduction doesn't presetve this property
13:50:04 <sheldonh> is this a succinct way to filter for non-empty lists in a list of lists? filter (not . null) xs
13:50:31 <shachaf> That depends.
13:50:39 <shachaf> Do you think it's succinct?
13:50:52 <ddarius> > 0.64^2
13:50:53 <lambdabot>   0.4096
13:51:04 <ddarius> > 21*0.4
13:51:05 <lambdabot>   8.4
13:52:58 <parcs`> dncr: yes
13:53:26 <parcs`> oops sheldonh^
13:53:32 <sheldonh> shachaf: well i can't think of a better way. i'm just nervous that i don't understand composition as well as i thought i did :)
13:54:14 <shachaf> It's a pretty standard idiom.
13:54:31 <ddarius> [x | x@(_:_) <- xs]
13:54:49 <startling> heh
13:56:39 <kane77> I'm trying to use QuickCheck, I defined instance for my data type A, however I test function that takse [A] as input and that has to be exactly of size 5, how do I tell it to quick check?
13:56:42 <parcs`> x@((:){})
13:56:59 * hackagebot aws 0.7.0 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.0 (AristidBreitkreuz)
13:57:57 <parcs`> > let x@(:){} = [1,2] in x
13:57:58 <lambdabot>   [1,2]
13:58:01 <parcs`> nice
13:58:44 <sheldonh> shachaf: yay. then i've implemented transpose from Data.List. a week ago, it was tying my head in knots. so there's nope :)
13:58:48 <sheldonh> *hope
13:59:19 <Jesin> I would like to read binary input from a file
14:00:04 <monochrom> openBinary, then use bytestring I/O routines
14:00:16 <sheldonh> Jesin: like reading haskell isn't challenging enough!
14:00:28 <habstinat> I know nothing about Haskell, but I'm trying to compile haskell-uniplate. Towards the end I get this error: <http://sprunge.us/SIhO> What can I do about this?
14:00:38 <Jesin> monochrom: where can I find the bytestring I/O routines?
14:01:09 <monochrom> in package "bytestring". comes with GHC
14:01:45 <avpx> Data.ByteString
14:01:51 <simplicio> habstinat: what is clippy?
14:02:17 <monochrom> haha
14:02:40 <ddarius> Problem found.
14:04:04 <Jesin> monochrom: thanks
14:04:47 <monochrom> you need "hashable" and "unordered-containers" before you can build "uniplate"
14:18:01 <sheldonh> is it reasonable to assume that haskell will optimize my heads and tails functions to operate on a value of nonEmpty that's only calculated once per iteration? http://fpaste.org/QM8z/
14:18:47 <hpc> yes
14:18:55 <Yiq> Anyone have a good link to what makles something a REST API?
14:19:01 <hpc> it's not even an optimization; it's a consequence of the fact that nonEmpty has a name
14:19:17 <Yiq> And to use twitters REST api with haskell, what lib would you use?
14:20:06 <sheldonh> hpc: thanks :)
14:20:22 <monochrom> you should s/haskell/GHC/ (or choose your compiler)
14:21:34 <monochrom> I would try wikipedia first for what REST means
14:21:46 <Sculptor> funny anagram: ask hell
14:21:56 <sheldonh> monochrom: ah, fair enough. as a nublet, yum install haskell-platform gives you ghc, and it's not obvious that there are other implementations :)
14:22:01 <monochrom> anagrams are stupid IMO
14:22:54 <hpc> sheldonh: there aren't any other implementations that matter, at the moment ;)
14:23:01 <monochrom> yes, Haskell Platform goes with GHC by definition, too, it is not just yum or fedora or redhat's decision
14:23:03 <hpc> there used to be
14:23:12 <sheldonh> hpc: so monochrom's just being pedantic or old or both? ;)
14:23:18 <hpc> yes
14:23:20 <Yiq> what haskell li would you use to get and POST to an API? like twitters
14:23:23 * sheldonh ducks.
14:23:30 <Yiq> s li/lib
14:23:46 <monochrom> other compilers are hugs, jhc, and some more rare ones
14:24:00 <sheldonh> Yiq: io would google for: haskell twitter api
14:24:00 <hpc> yhc was a research compiler at some point
14:24:33 <geekosaur> yhc, uhc, jhc, hugs
14:25:17 <sheldonh> hpc: about "as a consequence of it having a name" -- this is an advantage of purity, right? if a function always gives y for x, then there's no need to call it twice with the same x, ever. right ballpark?
14:25:19 <monochrom> there is some request for a GHC pragma that says "please re-compute nonEmpty several times". trades speed for memory
14:26:33 <hpc> sheldonh: more or less; worded a bit more straightforwardly, your program will mean the same thing if you write "... (expr) ... (expr) ..."
14:26:45 <hpc> or if you write "let foo = expr in ... foo ... foo ..."
14:27:01 <hpc> at the end result, anyway
14:27:15 <merijn> The latter guarantees expr is only computed once, though
14:27:24 <hpc> the side-effect of factoring out to a name is purely performance
14:27:30 <hpc> (harr harr, "purely")
14:27:38 <sheldonh> *baddadush*
14:28:09 <sheldonh> okay. so it took me 2 weeks, but i buy that functional thinking is useful :)
14:28:29 <Sculptor> two weeks to do what
14:28:30 <parcs`> hpc: and comprehension, usually
14:28:48 <hpc> that too
14:29:19 <sheldonh> Sculptor: mostly to understand what "easier to reason about", "purity has some remarkable benefits" and "values are awesome" meant :)
14:29:40 <Sculptor> great. i'll cross that bridge when i come to it
14:30:10 <hpc> sheldonh: nah, types are awesome, and some of that rubs off onto the values
14:30:11 <hpc> :P
14:30:25 <sheldonh> Sculptor: if you're struggling, check out the SICP videos. they helped me bigtime. http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
14:30:48 <monochrom> "types" and "functional" are orthogonal. haskell does well in both
14:31:02 <Sculptor> will bookmark that
14:31:08 <sheldonh> hpc: the effectiveness of haskell's type inference still blows my mind a bit
14:31:12 <monochrom> indeed for example scheme just does well in "functional"
14:31:48 <avpx> sheldonh: Anymore, I explain the type inference to non-believers as "literally a deductive system which goes over your code and proves its type"
14:32:02 <monochrom> SML and Haskell are on par in type inference. of course, type inference is just part of "types".
14:32:09 <sheldonh> hpc: but what i'm loving is that if i have a bug, i can do apply/eval with pencil and paper for a while and tada!
14:33:00 <sheldonh> avpx: i'm not saying it's magic. it's just freakin' awesome, and i can't think about how it works for more than a few minutes :)
14:33:16 <avpx> Hah.
14:33:36 <monochrom> what you're seeing is that locality helps compositional reason, and compositional reasoning is easy reasoning
14:33:41 <avpx> It is awesome, this is what I have trouble convincing people of. Because to them it's like, "so I have to help this thing write a proof for my code or it errors out?"
14:33:46 <ddarius> > let x = 0.897739638808 in x/2 + 25*x/(1+x*x) + 8
14:33:47 <lambdabot>   20.87648921723428
14:34:30 <monochrom> I used to pencil-paper my BASIC code, too. it was easy because I had very few variables, or I disciplined myself to be modular about using variables.
14:34:59 <avpx> I think I would find it difficult to practically pencil-paper my Haskell code
14:35:11 <sheldonh> monochrom: i can't pencil-paper most of my ruby code (not saying anything bad about ruby)
14:35:46 <monochrom> I TAed a java course. we could even pencil-paper java code.
14:35:51 <sheldonh> avpx: fair enough. i'm still doing simple, academic exercises, so it doesn't take more than 10 or so lines on a notepad :)
14:36:04 <hpc> i hated writing java on paper
14:36:14 <hpc> it was sooooo much writing for so little doing things
14:36:23 <avpx> "public static void main, oh yeah, we're really cruising now"
14:36:47 <monochrom> oh, computer-print your java code on paper, no reason to handwrite it. but, execute it by hand. it's do-able. you just have to know the right method
14:37:57 * ddarius needs to stop counting down from 0.
14:38:00 <monochrom> and easy vs hard is completely determined by less interference vs more interference. so, it's your own programming discipline, nothing to do with the language
14:39:30 <Sculptor> yes, but for java you need tons of paper
14:40:03 <simplicio> om nom nom feed me paper
14:40:21 <monochrom> the size is determined by program complexity only
14:40:29 <timthelion> Executing java by hand is easy, start from the main statement and follow the links.
14:40:56 * timthelion realises, that he's not actually sure now if Java uses "main" as it's initial function.
14:41:54 <startling> executing java by hand is easy, just compile it to jvm bytecode and walk through it
14:42:05 <merijn> timthelion: It does, but it's a method on a class (which can be named anything)
14:42:05 <parcs`> java looks for for the first static function called main and runs that, or something
14:42:19 <monochrom> write a java program to build a 10-million-node tree. write a haskell program to build a 10-million-node tree. both need the same amount of paper to hand-execute. the amount to fit 10 million nodes.
14:42:35 <timthelion> startling: Executing java by hand is easy, just scan over till you find the first unhandled exception and crash :D
14:42:53 <Peaker> I'm thinking of switching from "tup" to "shake", but worried that "shake" does not use "strace" to verify I didn't forget to specify dependencies
14:42:56 <startling> timthelion: heh
14:45:24 <simplicio> did someone say ArrayStoreException?
14:45:44 <monochrom> not yet
14:53:39 <watermind> this is confusing me...   reverse . reverse = id
14:54:00 <aib> @pl (\x y z -> x * y * z)
14:54:00 <lambdabot> ((*) .) . (*)
14:54:01 <watermind> the assertion does hold for   _|_   so why is this not a valid property
14:54:31 <watermind> that was not very well phrased
14:54:51 <watermind> reverse (reverse xs) = xs      seems to hold for  _|_
14:55:05 <watermind> and it obviously holds for finite xs
14:55:26 <Peaker> > reverse . reverse $ cycle [1,2]
14:55:29 <watermind> so that 'should' mean it holds for infinite lists
14:55:30 <lambdabot>   mueval-core: Time limit exceeded
14:55:34 <watermind> which is obviously not true
14:56:01 <Peaker> > reverse . reverse $ 1 : 2 : error "booya"
14:56:03 <lambdabot>   *Exception: booya
14:56:05 <watermind> but I'm even checking gibbons and huddak paper on corecursion
14:56:19 <Peaker> > 1 : 2 : error "booya"
14:56:20 <lambdabot>   [1,2*Exception: booya
14:56:22 <watermind> and I don't see any extra requirements for fixed point induction
14:58:30 <ddarius> watermind: Using induction says only that it should hold for list of any finite size.  You should use coinduction/bisimulation.
15:00:15 <watermind> ddarius: that's why I just downloaded this paper on proof methods for corecursive structures
15:00:31 <watermind> ddarius: but richard bird does prove properties of infinite lists like this
15:01:03 <watermind> ddarius: in fact this is a question in his book... why does, despite holding also for _|_ it doesn't mean it holds for infinite lists
15:01:47 <hpaste> gertc pasted “HelloDatabase.hs” at http://hpaste.org/74130
15:03:14 <gertc> litle help with >>= pleas
15:03:30 <gertc> the do works
15:04:05 <Peaker> do { x <- act ; <more> } -   becomes:       act >>= \x -> do { <more> }
15:04:07 <gertc> my >>= does not extract the messages
15:04:16 <Peaker> gertc, paste?
15:04:28 <Automorphism> gertc: ask >>= (return . take limit)
15:04:58 <ddarius> I would say the issue is that the recursion in reverse is not guarded.
15:04:59 <gertc> really thats it?
15:05:09 <Automorphism> :t (.)
15:05:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:05:22 <Peaker> Automorphism, if you hlint it - it will say, why not:  take limit <$> ask
15:05:50 <Automorphism> :t (Prelude.t)
15:05:50 <Peaker> gertc, there's also "asks":   asks (take limit)
15:05:51 <lambdabot> Not in scope: `Prelude.t'
15:05:58 <Automorphism> Dang.
15:06:23 <Automorphism> How do I refer to the (.) that is defined in the Prelude?
15:06:40 <gertc> testing
15:07:04 <aristid> Automorphism: "compose"?
15:07:15 <ddarius> Prelude..
15:07:18 <Cale> :t (Prelude..)
15:07:19 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:07:28 <Automorphism> aristid: Ah!
15:08:04 <aristid> Automorphism: oh you didn't mean how to pronounce it?
15:08:21 <Automorphism> Cale: Yeah, that was what I meant.
15:08:22 <aristid> Automorphism: you can most easily refer to the prelude's (.) by not using lambdabot
15:08:30 <Cale> :)
15:08:40 <Cale> I like lambdabot'
15:08:51 <aristid> Cale: you would like it!
15:09:00 <gertc> ask >>= (return . take limit) is the same error
15:09:01 <Cale> sorry, I like the way that lambdabot teaches everyone that little truth about (.)
15:09:07 <Automorphism> I thought the only other (.) was the one defined for the Category type class.
15:09:10 <Cale> (pressed enter while trying to edit)
15:09:21 <gertc> Couldn't match type `Database' with `[[Char]]'
15:09:34 <Cale> Automorphism: In lambdabot, I have (.) = fmap
15:09:41 <Peaker> No chance for lambdabot running Haskell rather than Caleskell?
15:09:50 <Cale> It's still Haskell :P
15:09:55 <gertc> so how do i extract messges from x ?
15:10:02 <Automorphism> aristid, Cale: Ah!
15:10:23 <Peaker> Cale, the main purpose of pedagogy is harmed.. trying to show newbies stuff and tripping over these diffs
15:11:01 <Automorphism> gertc: Oh, I assumed the type was correct, and your only problem was the ugliness of using an explicit lambda. My apologies.
15:11:10 <Cale> But I also get to introduce all the newbies to the idea that composition is an instance of functor application. :)
15:11:11 <Peaker> (.) = fmap   bites the newbie explanation all the time.. trying to use @type when explaining to newbies is hopeless
15:11:24 <ddarius> watermind: I suspect that all examples that worked on infinite lists either are guarded, e.g. map, or are actually doing induction on something else, e.g. take.
15:11:33 <Peaker> Cale, you can show that via:   let (.) = fmap in ...
15:12:03 <adnauseam> could just introduce an alternate @
15:12:08 <aristid> and i think some people have argued that they prefer Category's (.) over fmap as (.)
15:12:12 <Automorphism> gertc: If you have a type error, you are better off giving us more context.
15:12:14 <gertc> Peaker, http://hpaste.org/74130
15:12:17 <adnauseam> @newbie fmap or @newbie (.) :p
15:12:17 <lambdabot> Unknown command, try @list
15:12:23 <Cale> Yeah, I could also import Control.Category for a while, I suppose :D
15:12:29 * ddarius can't tell if his code is suffering from numerical instability or is just incorrect.
15:12:42 <Cale> ddarius: Will it work using CReal?
15:12:54 <ddarius> Cale: CReal is not Storable.
15:12:57 <Cale> ah
15:13:06 <Peaker> gertc, there's a pattern-match in your "do" but not in your lambda
15:13:13 <adnauseam> is cale the guy who writes lambda bot ? :o
15:13:18 <ddarius> adnauseam: No.
15:13:22 <Cale> No, I'm just the guy who keeps it running
15:13:27 <Cale> at the moment
15:13:37 <adnauseam> close enough ! is there going to be lambda bot 2 ? :o
15:13:45 <Cale> Not written by me
15:13:55 <adnauseam> the current lambda is very difficult to get set up
15:14:00 <ddarius> adnauseam: That's like asking a web admin if there is going to be a new release of Apache.
15:14:05 <Cale> adnauseam: yeah, it is annoying
15:14:09 <aristid> Cale: to make it really entertaining, how about randomly deciding on every lambdabot invocation whether to use fmap or Category? :)
15:14:19 <Cale> aristid: lel
15:14:20 <hpaste> Peaker annotated “HelloDatabase.hs” with “HelloDatabase.hs (annotation)” at http://hpaste.org/74130#a74131
15:14:46 <Cale> aristid: I could probably do that with TH
15:14:49 <Sculptor> are channel logs available online
15:14:59 <Cale> Sculptor: yes, see the topic
15:15:05 <adnauseam> are there any people working on lambdabot2 ? ? :o
15:15:06 <Sculptor> first class, thanks
15:15:13 <gertc> Peaker, aaaaa yes :) thx
15:15:18 <Cale> adnauseam: Lambdabot has no maintainer at present
15:15:19 <Sculptor> i never read topic :/
15:15:23 <adnauseam> :[
15:15:46 <adnauseam> wish i could maintain it. i'm still a noob though. maybe someday
15:15:48 <watermind> ddarius: he proves associativity of  ++   like this for instance: (xs++ys)++zs = xs++(ys++zs)   by induction on xs, and it is valid for xs infinite since he also considers the case xs = _|_
15:16:22 <Peaker> gertc, if you define:  newtype Database = Database { dbMessages :: [..] }  you can use the field accessor rather than pattern-matching
15:16:40 <Cale> watermind: Yeah, that's coinduction.
15:17:24 <Cale> I believe you can prove that coinduction works using transfinite induction.
15:17:37 <gertc> Peaker, ok wait trying somthing
15:18:08 <Cale> and you probably don't even need uncountable ordinals
15:18:18 <Cale> Well, certainly not :)
15:18:24 <watermind> Cale: so why does this approach fails on   reverse (reverse xs) = xs    in the sense that it is obviously false for infinite lists, but you do have reverse (reverse _|_ ) = _|_
15:18:56 <Cale> Well, reverse (reverse (1 : _|_)) is not 1 : _|_
15:19:58 <Cale> So that should hint at where the argument breaks down :)
15:20:15 <watermind> Cale: yes I see!
15:20:16 <Cale> (need a specific implementation of reverse to proceed)
15:21:33 <Anoop> hi there
15:21:49 <Cale> hello...
15:21:53 <Cale> :S
15:24:10 <watermind> Cale: thanks that was really confusing me... I hadn't noticed that the induction step does require the list to be finite
15:24:51 <ezyang> I'm porting some cmdargs code to the latest version; did anyone ever write an upgrade tutorial?
15:28:58 <watermind> Cale: do you know of any source explaining / proving why transfinite induction works and relating it to coinduction?
15:29:21 <watermind> Cale: because my understanding is that with coinduction you're trying to prove that the output generated is bisimilar
15:30:13 <Cale> Well, okay, do you know what a well-ordering is?
15:30:40 <watermind> yeap
15:32:24 <Cale> So suppose that (S,<=) is a well ordered set, and suppose additionally that A is a subset of S such that for any x in S, we have that if every y < x is in A, then x is in A.
15:32:31 <Cale> We're going to show that A = S
15:33:34 <Cale> Suppose not, so that S \ A = { x in S : x not in A } is nonempty.
15:33:50 <Cale> Being a nonempty subset of S which is well-ordered, this S \ A must have a least element.
15:34:04 <Cale> say, u
15:34:46 <watermind> yes...
15:34:48 <Cale> But then for all x in S with x < u, we have that x is in A, otherwise u would not be the least element of S \ A.
15:35:00 <watermind> yeap
15:35:12 <Cale> and so u must be in A by our original assumption
15:35:16 <Cale> which is a contradiction
15:35:39 <Cale> So, that's transfinite induction :)
15:35:56 <Cale> We can use this on well-ordered sets which are even larger than the naturals.
15:36:05 <rosie> What's a good tutorial for learning about ST and IORef?
15:36:06 <Cale> (or, have a larger order type)
15:36:35 <watermind> Cale: this sounds like the approximation lemma though...
15:36:58 <Cale> rosie: IORef is pretty easy if you already know how to use the IO monad, you should be able to understand it just by looking at the documentation.
15:37:03 <Cale> rosie: ST... hmm
15:37:22 <shachaf> rosie: For learning about how ST works or for using it? :-)
15:37:29 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/Data-IORef.html -- here's the documentation for IORef
15:38:22 <watermind> Cale: i.e. in the sense that it does seem to show that you can take an _Output_  x and prove your property for every y < x
15:38:31 <ezyang> rosie: There's the original paper for ST
15:38:57 <Cale> I hate google's mangling!
15:39:03 <Cale> http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&ved=0CB8QFjAA&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.144.2237%26rep%3Drep1%26type%3Dpdf&ei=wd9DUIXMBoGiywGXjIGoCw&usg=AFQjCNHb9Jopm0lvj2HuQ9gJvscOjr2csw
15:39:09 <Cale> there you go, whatever
15:39:09 <watermind> Cale: never mind
15:39:15 <watermind> Cale: I got it
15:39:20 <Cale> watermind: okay, great
15:39:56 <Cale> watermind: So then in order to prove that coinduction works, we basically just need to topologically sort the dcpo for our datatype, I think :)
15:40:09 <Cale> Maybe it's not quite that straightforward...
15:40:14 <watermind> Cale: actually not quite, I mean I see the intuition... I expect it to be true, but it doesn't seem to follow directly from what you are saying
15:40:25 <Cale> Oh, what doesn't?
15:40:38 <watermind> Cale: well in terms of coinduction yes it makes perfect sense
15:41:15 <watermind> Cale: we do have a domain so we can prove a property for approximations of our result
15:41:25 <watermind> Cale: that is clear to me
15:41:56 <watermind> Cale: but here we are working with the input
15:42:02 <Cale> watermind: Maybe we need a slight generalisation of this for it to work really smoothly.
15:42:55 <rosie> Cale: looks good, thanks!
15:43:08 <Cale> After all, the only property of the ordering we used was that every nonempty subset has a minimal element, not even that said element is a minimum.
15:43:28 <shachaf> google-- # mangling
15:43:31 <Cale> and so there's a direct generalisation to any ordering having that property
15:43:45 <Cale> (well-founded sets)
15:43:52 <ddarius> watermind: (++) uses guarded recursion.
15:44:45 <watermind> ddarius: yes you're right, I already understood why that property failed
15:45:38 <watermind> ops got to go
15:46:41 <watermind> ops no I don't
15:46:52 <Cale> I wonder what was done to the paper I just linked to, in order that it looks so bad.
15:47:03 <Cale> It looks like it was printed out and scanned back in or something.
15:47:34 <Cale> yeah, that's probably what happened
15:49:31 <ddarius> Cut-elimination is basically the hydra problem.
15:50:47 <Cale> So yeah, it just comes down to putting a well-founded ordering on your datatype and then proving the general induction step for that ordering.
15:51:06 <Cale> (but you want to treat all the elements, even the ones with bottom in them)
15:51:29 <hpaste> gertc annotated “HelloDatabase.hs” with “HelloDatabase.hs (annotation)” at http://hpaste.org/74130#a74132
15:52:30 <watermind> Cale: if you show that a property P is valid for all   data y < x  then it follows that it is valid for x    (that's ok)
15:53:01 <gertc> Peaker, somthing like this you mean? http://hpaste.org/74130
15:53:20 <Cale> We're assuming that this holds when proving induction works, and it's one of the things we're required to prove of our data in order to make use of induction.
15:53:38 <watermind> Cale: but here we are proving that   P (f y) is valid for all y < x  and concluding that P (f x) follows
15:53:52 <ddarius> Let P = x < 10, P holds for all y < 10.
15:55:08 <watermind> Cale: now maybe we can easily turn that into a property P' = {z | P(f z)}
15:55:19 <Cale> sure
15:55:27 <Peaker> gertc, addMessage msg = modify (msg:)
15:55:44 <Cale> Remember I was just talking about sets -- you can define A in any way that you can construct a set.
15:55:49 <Peaker> gertc, viewMessages is shadowing the "messages" field
15:56:08 <Cale> (but it's up to you to prove that the induction step holds)
15:56:18 <watermind> Cale: yes you're right...
15:56:20 <Peaker> gertc, you need: viewMessages limit = ask >>= \db -> return $ take limit (messages db)
15:56:43 <watermind> Cale: yeap all makes sense
15:56:55 <Peaker> gertc, or: viewMessages = ask >>= return . take limit . messages
15:57:12 <Peaker> gertc, or: viewMessages = take limit . messages <$> ask
15:57:21 <Peaker> gertc, or: viewMessages = asks $ take limit . messages
15:57:54 <Peaker> gertc, [ "  " ++ message | message <- messages ]   ==>    map ("  "++) messages
16:05:14 * ddarius imagines numerical imprecision would be a form of correlated noise.
16:12:59 <gertc> Peaker, I am testing... allot :)
16:21:47 <hpaste> gertc annotated “HelloDatabase.hs” with “HelloDatabase.hs (annotation)” at http://hpaste.org/74130#a74133
16:23:34 <gertc> Peaker, http://hpaste.org/74130
16:23:57 <gertc> can not be used as an UpdateEvent because it contains the type variables: messages_0 ?
16:24:44 <notNicolas> I just met Hideo Kojima and he signed my LYAH book. This book is a good luck charm. http://i.imgur.com/SZUNZ.jpg
16:24:52 <gertc> which do not appear in the state type: Main.Database
16:35:09 <SHACHAF> ARISTID: Can you believe that guy?
16:35:14 <SHACHAF> This is oppression!
16:39:30 <aristid> SHACHAF: truly.
16:39:38 <SHACHAF> aristid: :-(
16:40:15 <SHACHAF> <Guildenstern> So, you gave up.
16:40:21 <SHACHAF> <Rosencrantz> So, you gave in.
16:40:38 <dolio> I just met Bryan Adams and he signed my copy of New Super Mario Bros.
16:41:21 * Clint squints.
16:42:30 <Cale> I have no idea what is being discussed here
16:44:16 <parcs`> Cale: http://i.imgur.com/SZUNZ.jpg
16:45:00 <dolio> Someone mentioned that they got their copy of LYAH signed by Hideo Kojima, which is an odd combo.
16:45:04 <nkpart> Hey, given this: data Resource = Resource { uri :: Text, handle :: Snap () }
16:45:05 <nkpart> resourceToSnap (Resource ...) = (encodeUtf8 uri, handle)
16:45:18 <nkpart> what's the proper syntax for the record splat thing I'm trying to do on the second line?
16:45:29 <Jesin> hmm
16:45:31 <parcs`> it's an awesome combo
16:45:40 <dolio> But I guess people don't typically carry copies of Snatcher with them, and such.
16:45:46 <Jesin> I want to read Ints from a binary file, is there a good way to do this?
16:46:00 <nand`> perhaps Get
16:46:11 <parcs`> there's an awesome way to do that
16:46:15 <parcs`> check out the cereal package
16:46:19 <Jesin> Alternately, what's the best way to get Ints from a ByteString?
16:46:25 <parcs`> bytestring-lexing
16:46:56 <parcs`> do you mean binary ints or ascii ints?
16:48:45 <Jesin> I've got a binary-mode file handle.  If an Int is 32 bits long, I want the first 32 bits of the file as an Int.
16:48:55 <parcs`> cereal
16:49:10 <Jesin> !hoogle cereal
16:49:22 <Jesin> ...eh, it's been a while, I forgot lambdabot's syntax
16:49:25 <Jesin> @hoogle cereal
16:49:25 <lambdabot> package cereal
16:49:25 <lambdabot> package cereal-enumerator
16:49:26 <lambdabot> package cereal-ieee754
16:49:30 <nand`> @hackage cereal
16:49:30 <lambdabot> http://hackage.haskell.org/package/cereal
16:51:44 <dncr> what's the easiest way to parse haskell keeping whitespace information
16:51:52 <dncr> lossless parsing+unparsing
16:52:09 <dncr> ideally parsing everything that GHC can
16:53:05 <Saizan> haskell-src-exts should allow that with the Annotated modules
16:53:12 <dncr> sweet
16:55:13 <Jesin> parcs`: "decodeLazy :: Serialize a => ByteString -> Either String a" - do I have to worry about this failing?
16:56:12 <Jesin> ...I guess it could fail on an EOF?
16:56:28 <Jesin> I don't think the file I'm reading from gives those, though.
16:57:03 <parcs`> what do you mean by failing?
16:57:08 <Jesin> erm
16:57:12 <Jesin> producing a Left String
16:57:29 <dncr> what's the state of the art for theorem proving and/or dependent types?  i should just look at coq and agda2?
16:58:48 <thoughtpolice> Jesin: it'll possibly fail, but maybe not because of EOF. it might fail because the data is corrupt (so something to messed up.) if the ByteString you feed it is lazily read from a file and you close the file handle, then it could also error because of EOF. but you'll have to handle the error case no matter what
17:00:05 <Jesin> eh, I'll just do something like thefunction (Left foo) = error foo
17:00:10 <hpaste> ezyang pasted “Symbol zoo” at http://hpaste.org/74134
17:00:48 <dncr> like what is the most expressive theorem prover
17:02:59 <ddarius> The unscented Kalman filter doesn't handle jump constant inputs very well.
17:03:47 <nand`> ezyang: so is that an Agda program to compute pi or what?
17:04:04 <ion> ddarius: Is your code available somewhere already?
17:04:15 <SHACHAF> That's Agda?
17:04:20 <SHACHAF> It doesn't have enough Unicode to be Agda.
17:04:23 <ezyang> Ha ha ha.
17:05:26 <ezyang> It's a list of all publically exported symbols on Hackage :)
17:05:31 <startling> SHACHAF: it's all unicode !
17:05:33 <ddarius> ion: Not yet.
17:06:03 <SHACHAF> startling: True.
17:06:07 <ion> What are jump constant inputs?
17:06:24 <SHACHAF> ezyang: Oh, that's short.
17:06:47 <ddarius> I'm making up the term, but inputs (by which I mean observations) that are constant except for discontinuously jumping to other constants.
17:06:50 <parcs`> i imagine half of those are from the base-unicode-symbols package
17:07:19 <ion> ddarius: ok
17:08:22 <startling> @hoogle ~~~>
17:08:22 <lambdabot> No results found
17:08:35 <startling> @hoogle (~~~>)
17:08:35 <lambdabot> No results found
17:08:42 <ddarius> ion: If you are at a point where you could use this code, I could provide the current version.  Hell if I know that it is right though.
17:08:44 <ezyang> Well, a symbol gets no points if it's not exported.
17:08:54 <ezyang> We also miss some due to infelicities in the code.
17:09:22 <ddarius> The more serious concern is that, no doubt, some symbols are being reused.
17:11:27 <ddarius> Who's defining **/***?
17:11:38 <Cale> I wonder how long it would take everything to go to hell if shares were allowed to be traded at arbitrary computable real prices.
17:11:42 <ddarius> @hoogle **/***
17:11:42 <lambdabot> No results found
17:12:05 <ezyang> I can check up on it...
17:12:10 <SHACHAF> Cale: As opposed to arbitrarily small time intervals?
17:12:28 <Cale> SHACHAF: heh
17:13:12 <geekosaur> I think that one is defined in XMonad.Layout.LayoutCombinators...
17:13:29 <ezyang> lol.
17:14:11 <Cale> The fun part is that computing enough of the real to decide whether or not you want to accept an offer can take an arbitrarily long period of time. You might even allow people to place bids at nonterminating prices :)
17:15:37 <Jesin> hmm
17:15:54 <SHACHAF> Cale: Oh, now I see what you mean.
17:15:59 <Jesin> is it possible for a module to export a function that returns a value of type T, without exporting any constructors for T?
17:16:37 <ezyang> Jesin: I think so, but it is a bit awkward.
17:16:43 <Jesin> (In particular, people are not supposed to be able to pattern match for this.)
17:16:55 <Jesin> Actually, perhaps I should ask if this has been done before
17:17:01 <ezyang> Oh, well, you can totally export a type T without exporting any of his constructors
17:17:03 <Cale> Jesin: absolutely
17:17:11 <geekosaur> you can export T without anyt constructors; just name it.  (exporting T exports only the type, T(..) exports all constrctors, T(A,B) exports constructors A and B)
17:17:11 <avpx> Jesin: Yes, I have seen it done before
17:17:13 <Jesin> I want to make a nice RNG interface that just reads from /dev/random
17:17:14 <Cale> Data.Set does this
17:17:17 <startling> Jesin: yes, of course
17:17:30 <startling> IO does this
17:17:32 <avpx> Jesin: It's quite a good option if you want to abstract away the details of your type while still giving functions that deal with it
17:17:34 <startling> (kind of)
17:17:45 <Jesin> yaaaay
17:17:57 <avpx> startling: IIRC, that's ST RealWorld?
17:18:25 <geekosaur> @src IO
17:18:25 <lambdabot> Source not found. I am sorry.
17:18:26 <Jesin> so, um...  does anyone know if there's a nice Haskell interface for /dev/random ?
17:18:29 <geekosaur> ah well
17:18:38 <avpx> Jesin: Why /dev/random?
17:18:49 * ddarius does not find the explicit naming of data constructors for export useful.
17:18:51 <startling> Jesin: there's nicer interfaces for getting random stuff
17:18:59 <Jesin> avpx: because http://www.issihosts.com/haveged/
17:19:16 <avpx> Jesin: I see
17:19:18 <Jesin> is cryptographically much more secure than the builtin System.Random
17:19:38 <startling> Jesin, you can get your seeds from anywhere
17:19:39 <Jesin> and when invoked with the right options is also very fast.
17:19:51 <avpx> Jesin: I don't know of any, but it doesn't seem too hard to just read in /dev/random as a ByteString and go to work
17:20:30 <Jesin> avpx: there's already a RandomGen class, I'm just trying to write a type that wraps /dev/random with that interface
17:21:09 <avpx> I can't tell if that's a good idea; shouldn't RandomGen be pure?
17:21:11 <SHACHAF> Jesin: Are you sure you don't want /dev/urandom?
17:21:24 <avpx> SHACHAF: I think he's quite sure
17:21:27 <Jesin> SHACHAF: I am sure.
17:21:36 <Jesin> http://www.issihosts.com/haveged/ gives... let's see
17:21:51 <SHACHAF> Jesin: /dev/random isn't a very nice interface because it can block.
17:22:21 <MostAwesomeDude> SHACHAF: You look taller today. :3
17:22:32 <Jesin> SHACHAF: if you're running haveged in the background, you get performance like....  *testing*
17:22:39 <SHACHAF> /dev/urandom is good enough for almost everything, including cryptography.
17:22:53 <SHACHAF> (So I understand.)
17:22:59 <SHACHAF> (IANAC.)
17:23:21 <avpx> Jesin: I might advise against using RandomGen because it is based around a function g -> (Int, g)
17:23:22 <Jesin> [jesin@jesin-pc00 ~]$ time cat /dev/random > foo
17:23:24 <Jesin> ^C
17:23:25 <Jesin> real	0m21.993s
17:23:27 <Jesin> user	0m0.060s
17:23:28 <Jesin> sys	0m20.819s
17:23:29 <avpx> And that doesn't really fit into the model of /dev/random
17:23:30 <Jesin> [jesin@jesin-pc00 ~]$ wc -c foo
17:23:31 <Jesin> 68036655 foo
17:23:41 <MostAwesomeDude> (If you're implementing your own cryptography, you probably are skilled enough to know which randomness sources are good for you.)
17:23:47 <Jesin> avpx: if you keep a lazy ByteString in your g, sure it does
17:23:51 <MostAwesomeDude> (Or you should not be implementing crypto at all!)
17:24:00 <avpx> Jesin: Aha, okay
17:24:19 <avpx> That's actually quite nice
17:24:23 <SHACHAF> MostAwesomeDude: (If you're *qualified to* implement your own cryptography.)
17:24:47 <Jesin> MostAwesomeDude: I am not implementing cryptography, I am simply implementing a RandomGen interface for /dev/random
17:25:29 <Jesin> RandomGen is a typeclass for random number generators; /dev/random is provided as a particularly secure random number generator
17:25:39 <Jesin> :P
17:26:04 <avpx> Jesin: It seems like it will actually be quite easy to add a RandomGen instance.
17:26:15 <Jesin> avpx: I know right  :D
17:26:26 <avpx> If I am reading this correctly, you can just specify the range of the ints (that is, the Word8s from the bytestring)
17:26:29 <parcs`> getRandomNumber :: IO Int; getRandomNumber = return 4
17:26:37 <avpx> Splitting is a bit less trivial...
17:26:37 <Jesin> lol
17:26:58 <Jesin> parcs`: that would fail statistical randomness tests so hard all the time
17:27:07 <ddarius> RandomGen is a class for -pseudo- random number generators.
17:27:22 <Jesin> ddarius: where's that specified?  :P
17:27:27 <ddarius> Jesin: The type.
17:27:44 <Jesin> Meh.
17:28:21 <Jesin> ddarius: umm... does the interface require that you be able to set the seed manually?
17:28:52 <Jesin> if not, I don't see why newtype RandByteString = RandByteString { getRandByteString :: ByteString }
17:29:20 <amiller> I don't think I ended up any closer to my goal :/ I'm trying to find a way of taking operations on a regular datatype (e.g., insertion in a binary Tree) to derived operations that record a stream of every node that's visited
17:29:43 <amiller> so far i have basically tried just injecting Monad m everywhere, such as a :< (Trunk :. m),   a :< (m :. Trunk),  (m a) :< (m :. Trunk)
17:29:49 <Jesin> isn't a perfectly acceptable instance
17:29:50 <Jesin> :p
17:30:13 <Jesin> Even the "split" is easy
17:30:31 <amiller> None of those behave how i expect (in particular they don't result in 'incremental' computations but instead recompute the whole tree) so I'm still misunderstanding something
17:30:32 <ddarius> Jesin: The only way to implement it, unless I'm misunderstanding what you want to do, is with unsafeInterleaveIO.
17:30:43 <Jesin> ddarius: umm... no?
17:30:46 <Jesin> I don't think so.
17:31:22 <Jesin> I think http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.9.2.1/Data-ByteString-Lazy.html#readFile will be perfectly fine.
17:31:54 <ddarius> Which uses unsafeInterleaveIO
17:32:15 <startling> hehe
17:32:25 <Jesin> ...
17:32:34 <SHACHAF> ddarius: In particular, uses it in a way that exposes the unsafeinterleaving effects.
17:32:42 <Jesin> okay?  I'm not the one using it, I'm just using a library that happens to include that in its implementation
17:32:44 <SHACHAF> Most of ByteString is implemented using unsafePerformIO but that's not observable.
17:33:33 <ddarius> Jesin: The point is, the only way to implement what you want with the RandomGen interface requires at least bending purity.  This strongly suggests that this interface wasn't meant for that.  At any rate, the RandomGen interface more or less sucks.
17:33:46 <Jesin> lol
17:34:01 <Jesin> The implementation kinda does, I agree
17:34:05 <Jesin> it's usable though
17:34:13 <Jesin> What would you recommend?
17:34:30 <Jesin> I was looking at http://hackage.haskell.org/package/MonadRandom myself
17:35:35 <ddarius> Simply implement an IO action that reads a Word32 (or Word64 or Double or whatever you want) from /dev/random.
17:35:44 <Jesin> If you look at the source of that, though, http://hackage.haskell.org/packages/archive/MonadRandom/0.1.8/doc/html/src/Control-Monad-Random.html#RandT
17:35:55 <ddarius> If someone really wants a lazy infinite list of them, they can do the unsafeInterleaveIO.
17:35:56 <Jesin> it appears to expect a RandomGen instance.
17:36:19 <Jesin> ...Yeah
17:36:23 <Jesin> that's probably nicer
17:36:37 <ddarius> @hackage mwc-random
17:36:37 <lambdabot> http://hackage.haskell.org/package/mwc-random
17:36:56 <SHACHAF> Pure computations that block on I/O aren't that nice.
17:37:01 <ion> ddarius: I’m not. I’ll be getting some sensors this week.
17:37:14 <Jesin> except then you don't get all the http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:Random instances
17:37:32 <Jesin> SHACHAF: I suppose you have a point
17:39:01 <Jesin> frig
17:39:20 <ddarius> You could also do this in ML where such concerns aren't an issue.
17:39:31 <Jesin> nah, ddarius I'd rather not
17:40:17 <Jesin> Anyway, it's now looking like the best option is probably to write an instance of http://hackage.haskell.org/packages/archive/MonadRandom/latest/doc/html/Control-Monad-Random-Class.html#t:MonadRandom myself
17:40:32 <Jesin> still
17:41:01 <Jesin> err... wait no that was my intention from the beginning
17:41:33 <Jesin> it just looks difficult to write stuff like getRandom :: Random a => m a
17:41:40 <Jesin> without writing a System.Random.RandomGen instance
17:42:54 <Jesin> why does http://hackage.haskell.org/package/MonadRandom even exist?
17:43:17 <scri> i'm using the elpa package for emacs haskell-mode
17:43:22 <SHACHAF> Convenience?
17:43:26 <scri> the version string is $Name:   $
17:43:39 <ddarius> It's like MonadState.
17:43:39 <scri> anyone know whats up with that?
17:44:00 <dncr> it seems sad that haskell-src-ext doesn't have an intermediary lexing phase.  like lex :: String -> [Token] and parse :: [Token] -> AbstractSyntaxTree.  because a lot of simple transformations can be more naturally conducted on [Token].
17:44:09 <dncr> Saizan: is there a lexer?
17:45:26 <dncr> the package description for haskell-src-exts includes "lexer" but then i don't see one in the docs..
17:46:29 <Jesin> ddarius: it's insufficiently general for taking that name
17:46:37 <Jesin> it should be Control.Monad.Pseudorandom
17:47:23 <Saizan> dncr: don't know actually
17:47:46 <dncr> Jesin: isn't it ok to fudge names a bit based on commonness-of-use-in-practice?
17:47:52 <dncr> Saizan: mm
17:48:45 <Jesin> dncr: it should really be more mathematically general if it's going to take that name imo.  =/
17:48:51 <hnoob> I've been trying to wrestle the following out of a do block for an hour now.  Can't seem to get it done cleanly.  It seems like such a simple function.
17:48:53 <hnoob> messageIsomorphisms :: [String] -> [String] -> [[String]]
17:48:57 <hnoob> messageIsomorphisms xs ys = do; x <- xs; return (filter (isIsomorphic x) ys)
17:49:05 <ddarius> Jesin: That's true for pretty much all the classes.  Pseudo random number generators and "true" random number generators have fairly radically different interfaces.
17:49:08 <hnoob> Any suggestions?
17:49:27 <Jesin> ...
17:49:30 <SHACHAF> hnoob: Why are you trying to use a do block?
17:49:35 <Jesin> Fine I'll write Control.Monad.TrueRandom then
17:49:36 <Jesin> :p
17:49:41 <ddarius> Jesin: I recommend it.
17:49:43 <hnoob> I'm trying not to.
17:49:46 <SHACHAF> curl http://random.org/
17:50:06 <hnoob> It worked in a do block.  Trying to wrestle it into combinators
17:50:26 <byorgey> dncr: haskell-src seems to include a lexer.  Though of course that doesn't handle extensions.
17:50:30 <SHACHAF> hnoob: The function you want is probably "map".
17:50:37 <ddarius> For example, anything returning an infinite stream from a true random number generator will require unsafeInterleaveIO or worse, while getRandom :: Random a => IO a from a pseudo-random number generator requires global variables which means the unsafePerformIO hack for a "pure" Haskell implementation.
17:50:37 <dncr> Language.Haskell.Exts.Lexer is not exposed i guess
17:50:51 <dncr> byorgey: maybe i just need to expose that..
17:50:53 <hnoob> Map what?
17:51:15 <byorgey> dncr: ah, indeed
17:51:22 <dncr> winning
17:51:23 <SHACHAF> hnoob: map some function over xs.
17:51:27 <Jesin> ddarius: ...hm...  I'm still not entirely comfortable naming it this, as the interface should be usable for PRNGs as well
17:51:37 <SHACHAF> hnoob: I think this might be easier to write if you make it more abstract. :-)
17:52:09 <hnoob> The only thing to abstract out is isIsomorphic
17:52:09 <SHACHAF> messageIsomorphisms :: (a -> b -> Bool) -> [a] -> [b] -> [[b]]?
17:52:17 <hnoob> And that doesn't make it any more apparent
17:52:30 <SHACHAF> If you do that, the types can help you.
17:52:39 <SHACHAF> Did I give the correct type?
17:52:55 <ddarius> Jesin: If you make it narrow enough, e.g. only monadic actions, no infinite streams, and provide an "initialize" method, similar to how mwc-random works, you could make an interface that incorporates both.
17:53:32 <hnoob> Think so.  But it's still no more pparant how to put that together
17:53:37 <Jesin> wait what?
17:53:37 <hnoob> *apparent
17:53:48 <Jesin> ddarius: what would preclude infinite streams?
17:54:04 <SHACHAF> hnoob: Well, given a particular x from xs, and ys, can you generate the appropriate list for the result?
17:54:15 <SHACHAF> (\x -> ...ys...)
17:54:17 <Jesin> also why would "initialize" be necessary for the typeclass?
17:54:28 <ddarius> Jesin: The fact that reading from a file is IO.  And you can't read an infinite bytestring into memory, so that would require unsafeInterleaveIO to implement.
17:54:29 <Jesin> It might be suitable for a subclass, I suppose...
17:54:30 <SHACHAF> Hint: You should be able to get this from your previous code. :-)
17:54:53 <Jesin> ddarius: is there a problem with unsafeInterleaveIO?
17:55:02 <ddarius> It's unsafe.
17:55:06 <Jesin> as used in Data.ByteString.Lazy, though.
17:55:09 <Jesin> Is *that* unsafe?
17:55:11 <ddarius> Yes.
17:55:19 <Jesin> Then why isn't it labeled as such?
17:55:27 <hnoob> Yeah, \ xs ys = xs >>= \x -> return (filter (isIsomorphic x) ys).  That's just desugaring the do.  I am trying for combinators with no free variables.
17:55:33 <Jesin> Also: how is it unsafe?
17:55:46 <SHACHAF> hnoob: \xs ys? I said "given a single xs"?
17:55:48 <SHACHAF> Er.
17:55:51 <SHACHAF> hnoob: \xs ys? I said "given a single x".
17:56:05 <Jesin> I suppose it could potentially lead to lockup, if it's impossible for two threads to read from /dev/random at the same time.
17:56:13 <hnoob> \x -> return (filter (isIsomorphic x) ys)
17:56:19 <Jesin> I don't know how else it could be unsafe, though.
17:56:50 <SHACHAF> hnoob: I don't think you want that "return".
17:56:54 <SHACHAF> What's the type of that function?
17:57:00 <hnoob> return just wraps it in a list
17:57:15 <SHACHAF> Yes.
17:57:16 <Jesin> ddarius: I don't intend to touch unsafeInterleaveIO myself, I just plan to use the functions provided in Data.ByteString.Lazy
17:57:22 <SHACHAF> OK, list >>= f = concat (map f list)
17:57:43 <Jesin> ddarius: Is that really unsafe?  If so, I'd appreciate it if you could explain how...
17:57:46 <SHACHAF> xs >>= (\x -> return ...) === concat (map (\x -> return ...)) xs
17:58:11 <dncr> i guess Language.Haskell.Exts is using Happy and i just need to figure out how to pull a stand-alone lexing function out of a happy parser..
17:58:14 <ddarius> Jesin: In general, it causes execution of IO to depend on evaluation order.  So, for example, if you close the file, how many results you have depend on how much of the string was evaluated which isn't controllable.  Arbitrary IO also can happen where you didn't expect it, e.g. in other threads like you alluded to.
17:59:01 <SHACHAF> I suspect infinite streams of random numbers generated by reading /dev/urandom are among the less morally reprehensible uses of readFile...
17:59:17 <ddarius> For this -particular- case, you probably don't have to worry about closed files and the order of operations matters less.
17:59:51 <ddarius> SHACHAF: Until, as you've pointed out multiple times, code ends up blocking somewhere unexpectedly.
18:00:10 <SHACHAF> ddarius: I specified "urandom". :-)
18:00:36 <SHACHAF> I thought Jesin had switched to talking about urandom too, but maybe I misunderstood.
18:00:38 <Jesin> if haveged is working correctly, it will fill up the /dev/random entropy pool very fast
18:01:55 <Jesin> SHACHAF: I am talking about /dev/random with haveged running.  To give an idea for what that does for a system: http://ix.io/2Vv
18:02:14 <ddarius> Jesin: If this is going to be a general class for random number generators, you can't assume that unsafeInterleaveIO based implementations are safe or that they will fill up the entropy pool in a timely manner.
18:02:19 <startling> so uh, what does an OS need to run ghc binaries?
18:02:58 <hnoob> @pl \xs ys = map (\x -> (filter (p x) ys)) xs
18:02:59 <lambdabot> (line 1, column 8):
18:02:59 <lambdabot> unexpected "="
18:02:59 <lambdabot> expecting pattern or "->"
18:03:11 <hnoob> @pl \xs ys -> map (\x -> (filter (p x) ys)) xs
18:03:11 <lambdabot> flip (map . flip (filter . p))
18:04:13 <Jesin> ddarius: I generated 68 MB of random data in 22 seconds
18:04:19 <hnoob> @pl \ys xs -> map (\x -> (filter (p x) ys)) xs
18:04:19 <lambdabot> map . flip (filter . p)
18:04:23 <SHACHAF> Jesin: 3MB/s?
18:04:31 <ddarius> Jesin: I can burn through that no problem.
18:05:15 <Jesin> ddarius, SHACHAF: okay, is there a problem with a bit of a slowdown?
18:06:01 <Jesin> ...look, if people want faster, they can use /dev/urandom if they want
18:06:10 <Jesin> I'm going to include an object for that
18:06:30 <Jesin> If people want more secure, I think that should be an option too.
18:06:50 <ddarius> Jesin: The problem is it happening in unexpected places.  At any rate, I don't see why you feel this needs to be in the general interface.  There's no problem having a subclass for generators that support providing an infinite stream of numbers, though that isn't really all that useful.
18:07:20 <Jesin> ...Ah
18:07:35 <Jesin> I'm sorry, I didn't realize what exactly we were arguing about  6_9
18:07:37 <Jesin> umm
18:08:34 <Jesin> ....yeah, if people want an infinite stream they can probably just sequence...
18:10:41 <ddarius> I'd say only pseudo-random number generators can support that.  I'd say that if users -want- to turn an IO-based random number generator into something that produces a lazy IO stream, they should explicitly do the unsafeInterleaveIO so they are aware of the consequences, rather than hiding such things behind a "nice" interface like readFile.
18:11:18 <Jesin> ddarius: why is there a lazy readFile, then, that isn't called unsafeReadFile?  =/
18:11:28 <Jesin> or perhaps you disagree with that decision?
18:11:46 <ddarius> I do.  It's mostly history and the fact that this is a fairly controversial area.
18:12:08 <ddarius> At this point though, I think most people who care use things like pipes/conduits.
18:12:10 <startling> what are the consequences of unsafeInterleaveIO?
18:12:27 <Jesin> pipes/conduits  ??
18:12:34 <ddarius> @hackage conduits
18:12:35 <lambdabot> http://hackage.haskell.org/package/conduits
18:12:38 <ddarius> @hackage pipes-core
18:12:38 <lambdabot> http://hackage.haskell.org/package/pipes-core
18:12:53 <Jesin> "404 Not Found
18:12:53 <Jesin> The requested resource was not found: no such package 'conduits'"
18:16:06 <ddarius> @hackage conduit
18:16:07 <lambdabot> http://hackage.haskell.org/package/conduit
18:17:44 <aristid> @hackage pipes
18:17:44 <lambdabot> http://hackage.haskell.org/package/pipes
18:28:18 <k0k01> hello
18:29:00 <TheMarkup> Hello
18:29:09 <avpx> Hi.
18:29:18 <k0k01> > # 3+3
18:29:19 <lambdabot>   *Exception: No match in record selector srcSpanFile
18:29:25 <k0k01> > 3+3
18:29:26 <lambdabot>   6
18:29:37 <k0k01> > I love lambdabot
18:29:38 <lambdabot>   Not in scope: data constructor `I'Not in scope: `love'Not in scope: `lambda...
18:29:41 <Guy123> Sup guys.
18:29:44 <TheMarkup> Hello
18:29:47 <TheMarkup> How are you?
18:29:48 <avpx> k0k01: Okay, please don't abuse the bot
18:29:50 <Guy123> Very good.
18:30:02 <k0k01> I was just checking
18:30:04 <k0k01> sorry
18:30:51 <JohnnyBoy> We here to flood
18:30:54 <Guy123> Flood
18:30:56 <JohnnyBoy> Flood
18:30:58 <Guy123> Flood
18:31:03 <avpx> *sigh*
18:31:07 <Guy123> So what?
18:31:09 <JohnnyBoy> What?
18:31:11 <Guy123> What?
18:31:13 <JohnnyBoy> What?
18:31:22 <JohnnyBoy> We are flooders.
18:31:25 <Guy123> Flooders.
18:31:28 <JohnnyBoy> Flooders.
18:31:31 <Guy123> No Flooders.
18:31:31 <SHACHAF> @where ops
18:31:31 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
18:31:34 <JohnnyBoy> Yes Flooders
18:31:36 --- mode: ChanServ set +o Saizan
18:31:38 <Guy123> Here floods.
18:31:44 --- mode: ChanServ set +o Cale
18:31:57 <nand`> same ip
18:32:10 <SHACHAF> Saizan++ # menacing
18:32:17 <Cale> They weren't very effective flooders
18:33:05 <avpx> Cale: Indeed.
18:35:21 <byorgey> SHACHAF, feeling loud today?  or perhaps tall?
18:35:23 <lpvb> They didn't even leverage lambdabot to flood
18:36:06 <SHACHAF> byorgey: I'M FEELING CAPITAL, THANK YOU!
18:36:12 <SHACHAF> LIFE IS GOOD.
18:36:17 <lpvb> LG
18:39:24 <byorgey> excellent, excellent
18:40:39 <k0k01> > [1..10]
18:40:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:41:06 <newsham> ?karma SHACHAF
18:41:07 <lambdabot> SHACHAF has a karma of 24
18:41:15 <k0k01> what is karma?
18:41:43 <SHACHAF> @karma newsham
18:41:43 <lambdabot> newsham has a karma of 1
18:41:53 <SHACHAF> Hmm. preflex's count is probably more accurate.
18:41:56 <newsham> one is the loneliest number
18:42:00 <SHACHAF> I wonder where mauke's gone off to.
18:42:12 <newsham> prob working on perl7
18:44:23 <newsham> (not that there's anything wrong with that)</seinfeld)
18:45:01 <matthavener> i have a pure function, like findThings :: [String] -> String -> [String] , and i want to call it with the first argument coming from an MVar, is that possible without adding the IO monad into it?
18:46:05 <newsham> not without unsafe*
18:46:25 <SHACHAF> matthavener: No.
18:46:27 <Cale> matthavener: You don't have to touch *that function*
18:46:38 <matthavener> Cale: what do you mean?
18:46:41 <SHACHAF> Ah, but what Cale said, if that wasn't clear.
18:46:41 <Cale> matthavener: But in order to access the MVar, you'll need to write an IO aciton
18:46:43 <Cale> action*
18:47:03 <SHACHAF> foo mvar = do { val <- readMVar mvar; let result = findThings val "blah"; doSomethingWith result }
18:47:08 <Cale> You can leave the function that you already wrote alone, and simply use it from an IO action which accesses the MVar
18:47:20 <matthavener> ah ok, perfect, that's what I was wondering
18:47:44 <matthavener> I see now the usefulness of do, let me try something similar to what you wrote SHACHAF
18:48:32 <Cale> SHACHAF: why are you all-caps?
18:48:42 <newsham> cale: someone hit commodore-shift
18:49:22 <SHACHAF> Cale: WHY NOT?
18:51:13 --- mode: Saizan set -o Saizan
18:51:28 <matthavener> thanks Cale SHACHAF that worked
18:52:01 <matthavener> so is "do" mostly used to "lift" monads across pure functions (correct me if i'm using the wrong terminology)
18:52:05 * hackagebot date-cache 0.3.0 - Date cacher  http://hackage.haskell.org/package/date-cache-0.3.0 (KazuYamamoto)
18:52:07 * hackagebot fast-logger 0.3.0 - A fast logging system  http://hackage.haskell.org/package/fast-logger-0.3.0 (KazuYamamoto)
18:52:09 * hackagebot wai-logger 0.3.0 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.3.0 (KazuYamamoto)
18:52:11 * hackagebot wai-logger-prefork 0.3.0 - A logging system for preforked WAI apps  http://hackage.haskell.org/package/wai-logger-prefork-0.3.0 (KazuYamamoto)
18:52:13 * hackagebot wai-app-file-cgi 0.8.0 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.8.0 (KazuYamamoto)
18:53:15 <newsham> in do-land you can use both pure functions and impure "functions" (ie. procedures)
18:53:32 <newsham> (of course you can write the code without do-notation too)
18:53:56 <startling> matthavener: mostly `do` is used to store intermediate values ime
18:54:33 <SHACHAF> In do-IO land, specifically.
18:54:37 <SHACHAF> dolIO land.
18:55:00 <startling> oh, that's a good point
18:55:19 <matthavener> SHACHAF: so to write what you wrote without do, it'd require a bunch of chained lambdas?
18:55:32 <SHACHAF> matthavener: It'd depend on what you were doing.
18:55:40 <avpx> matthavener: You should actually avoid using "do" until you understand >>= and return, IMO (some might disagree)
18:55:54 <matthavener> i'm basically doing exactly what you showed
18:55:57 <SHACHAF> It might look like foo mvar = readMVar mv >>= (\val -> let result = findThigns val "blah" in doSomethingWith result)
18:56:22 <SHACHAF> Some people will tell you to avoid "do" until you understand >>= and return, but that's kind of silly.
18:56:31 <avpx> Meh, it's how I learned :-\
18:56:39 <SHACHAF> Most of Haskell has nothing to do with "do", but you need a little bit of "do" sugar to make any program.
18:56:51 <SHACHAF> You can pretend it's just an imperative-programming DSL inside Haskell (because that's what it is).
18:57:00 <newsham> <- in the "use-do-first" camp.
18:57:11 <avpx> newsham: I see what you did there.
18:57:34 <newsham> avpx thinks i'm more clever than I am, cause I didnt see it :)
18:58:21 <matthavener> i made the mistake of reading "learn you a haskell" at work, never writing anything, then coming back 1 month later and trying to write something substantial
18:58:31 <avpx> Even better. In any case, "do" notation is a simple translation.
18:59:02 <ddarius> Shouldn't you have been working at work?
18:59:12 <avpx> ddarius: So old-fashioned
18:59:51 <newsham> do { ioaction1; ioaction2 }  does ioaction1 first then ioaction2.   do { x <- ioaction1; ioaction2 x }    does ioaction1 first, gets its result into x and passes it as an argument to something that results in another io action,
19:00:28 <avpx> Yeah, and the "getting its result into x" is the interesting part.
19:00:37 <newsham> ?type do { x <- readFile "/etc/passwd"; writeFile "/tmp/out" x }
19:00:39 <lambdabot> IO ()
19:01:01 <newsham> the whole do basically jsut glues togethe the things inside the do into one big IO action
19:01:03 <avpx> Basically, for some Monad m => m a, that binding "unwraps" the monad
19:01:35 <newsham> a big IO-program-construction-kit if you will
19:01:38 <avpx> IO is one of these monads, so you get a way to turn IO a into a
19:01:54 <SHACHAF> avpx: It's not really "turning" "IO a" to "a".
19:02:01 <avpx> SHACHAF: I'm speaking very loosely here
19:02:05 * hackagebot mighttpd2 2.8.0 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.0 (KazuYamamoto)
19:02:06 <SHACHAF> "IO a" is like a program that will get you an "a" when you run it.
19:02:14 <SHACHAF> Did you read what FAQ?
19:02:16 <SHACHAF> @where faq
19:02:16 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:02:20 <SHACHAF> @quote /bin/ls
19:02:20 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
19:02:39 <avpx> Heh.
19:02:43 <newsham> shachaf has a getline burrito
19:03:02 <avpx> SHACHAF: Look, I get what IO does :p
19:03:21 <newsham> ?guote burrito
19:03:21 <lambdabot> kmc says: an arrow is like *two* burritos
19:03:56 <SHACHAF> avpx: Oh, you're not matthavener.
19:04:00 * SHACHAF can never tell people apart.
19:04:07 <avpx> Perhaps I could try being taller?
19:04:15 <SHACHAF> matthavener: What I said was intended for you.
19:04:15 <otters> I have a disorder where I can't tell usernames apart.
19:04:18 <otters> Please be understanding.
19:04:19 <koninkje> does anyone know how to adjust the default interword spacing in lhs2tex?
19:04:20 <ddarius> It's hard to make out all those tiny letters.
19:04:35 <SHACHAF> avpx: I don't see a point in mentioning the word "monad" when talking about IO to people, anyway.
19:04:38 <SHACHAF> It's barely a monad.
19:05:23 <avpx> "Barely?"
19:05:24 <koninkje> is it a monad at all?
19:05:30 <otters> it fulfills the monad laws
19:05:31 <otters> and is a datatype
19:05:35 <otters> Soooo...
19:05:49 <koninkje> otters: um, real IO doesn't obey the monad laws though
19:05:57 <avpx> Does associativity break or something?
19:06:03 <koninkje> only the nice and easy subset of IO does that
19:06:03 <otters> I would think so
19:06:18 <otters> but you can't really make IO completely typesafe :/
19:06:45 <avpx> The reason I mention Monad at all is because that instance is really how you do anything nontrivial with IO in Haskell.
19:06:56 <avpx> You compose monadic functionality together. Thus, bind.
19:07:21 <SHACHAF> You can pretend (>>=) and return are monomorphic.
19:07:32 <avpx> Fair enough.
19:07:56 <koninkje> otters: I think the bigger problem is we can't get IO to respect the semantics of the rest of the language; semantics-preserving transformations (e.g., optimization) can be witnessed by IO
19:08:30 <newsham> whats a good example of an optimization that obeys the monad laws but changes the IO smenatics?
19:08:40 <Dodek> :D
19:09:22 <ddarius> The behavior of IO actions is already non-deterministic, so in most cases any "difference" in an IO action's result, would still be a correct solution.
19:10:01 <koninkje> let f be a function, let f' be an optimized version of f which preserves all the semantic properties of f. The fact that f' requires different time/space can be observed by IO, therefore IO breaks the semantic equivalence of f and f'
19:11:04 <ddarius> koninkje: The time and space measurements are already undefined/non-deterministic so those don't lead to observable differences.  The different results are valid results in either case.
19:12:05 <koninkje> ddarius: they surely are observable from IO. I don't care about determinism here. I'm just saying that the semantic equivalence used by the rest of the language is not "valid" from IO
19:12:13 <koninkje> because IO does not respect that equivalence
19:13:11 <SHACHAF> newsham: Easy: IO doesn't have semantics.
19:13:17 * SHACHAF .conal.moed
19:13:22 <koninkje> :)
19:14:26 <parcs`> > Dual 3 < Dual 5
19:14:27 <lambdabot>   True
19:14:30 <parcs`> is this correct?
19:14:50 <dolio> Where is Dual from?
19:14:56 <parcs`> Data.Monoid
19:14:56 <SHACHAF> Data.Monoid.
19:15:01 <SHACHAF> I think it inverts mappend?
19:15:06 <SHACHAF> Flips, I mean.
19:15:13 <ddarius> koninkje: I'm saying there is no guarantee that the results for the -same- function are the same even within a run.  I run a timer with function f.   It takes 10 seconds.  I run again with f optimized by the compiler to f'.  It takes 1 second.  I run again, still with f', but my computer is thrashing for completely unrelated reasons.  It takes 10 seconds.  How am I able to tell the difference between f and f' again?
19:15:17 <parcs`> yeah
19:15:23 <Cale> so yes, that's correct
19:15:40 <parcs`> is there somethingc like Dual for Ord?
19:15:45 <SHACHAF> Yes.
19:15:47 <nand`> yes
19:15:49 <nand`> Dual
19:15:50 <SHACHAF> GHC.Exts.Down
19:16:00 <nand`> there's an instance Ord a => Ord (Dual a)
19:16:07 <otters> > Dual "hi" `mappend` Dual "bye"
19:16:08 <lambdabot>   Dual {getDual = "byehi"}
19:16:10 <otters> o
19:16:22 <SHACHAF> nand`: Yes, and compare (Dual x) (Dual y) === compare x y
19:16:38 <otters> yeah, because that isn't part of the definition of Monoid
19:16:58 <newsham> ?google beauty in the beast wouter
19:16:59 <lambdabot> http://lambda-the-ultimate.org/node/1984
19:17:00 <lambdabot> Title: Beauty in the Beast | Lambda the Ultimate
19:17:01 <SHACHAF> Right, Dual is only about the monoid operations. It has nothing to do with Ord.
19:17:23 <parcs`> @hoogle Down
19:17:24 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Down :: KeyState
19:17:24 <lambdabot> GHC.Exts Down :: a -> Down a
19:17:24 <lambdabot> GHC.Exts newtype Down a
19:17:27 <otters> I would think the Ord instance would just be treating Dual like a wrapper
19:17:32 <parcs`> bah GHC.Exts
19:17:45 <SHACHAF> parcs`: It's used for ComprehensiveComprehsions.
19:18:14 <parcs`> i guess i can use flip compare `on` instead of comparing
19:18:42 <SHACHAF> compare EQ . comparing foo
19:18:55 <SHACHAF> (May not actually be a good idea.)
19:25:23 <Clint> if i'm doing foo <- state (\s -> (bar, s)), how might i be confused?
19:26:51 <dibblego> Clint: let foo = bar
19:27:06 * hackagebot iteratee 0.8.4.2 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.4.2 (JohnLato)
19:27:16 <SHACHAF> return x = state (\s -> (bar, s))
19:27:21 <SHACHAF> foo <- return bar
19:27:24 <SHACHAF> let foo = bar
19:27:34 <dibblego> * return x = state (\s -> (x, s))
19:27:43 <SHACHAF> Yes, that.
19:27:49 <SHACHAF> #define bar x
19:28:13 * Clint grumbles.
19:30:15 <newsham> > runState (do { return 5; }) 100
19:30:16 <lambdabot>   (5,100)
19:30:36 <newsham> > runState (do { x <- get; put (x+5); return (x-5) }) 100
19:30:38 <lambdabot>   (95,105)
19:31:10 <SHACHAF> > (do { runState; }) (do { (do { return; }) (do { 5; }); }) (do { 100; })
19:31:11 <lambdabot>   (5,100)
19:31:45 <newsham> clarity
19:32:20 <newsham> runstate (do { modify (+1) })
19:32:24 <newsham> > runstate (do { modify (+1) }) 100
19:32:25 <lambdabot>   Not in scope: `runstate'
19:32:30 <newsham> > runState (do { modify (+1) }) 100
19:32:31 <lambdabot>   ((),101)
19:33:10 <newsham> > runState (liftM (+1)) 100
19:33:11 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.State
19:33:11 <lambdabot>         ...
19:33:26 <ddarius> newsham: It's like INTERCAL, we must make sure to ask the implementation to do what we want.
19:33:36 <newsham> > runState (fmap (+1)) 100
19:33:37 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.State
19:33:37 <lambdabot>         ...
19:33:43 <SHACHAF> What are you fmapping?
19:37:19 <nand`> > (do 1; 2) 3
19:37:20 <lambdabot>   2
19:37:31 <newsham> > 2 3
19:37:32 <lambdabot>   2
19:37:47 <ddarius> > 1 2 3 4 5 6
19:37:48 <lambdabot>   1
19:37:51 <newsham> > 3 1 4 1 5 9 2 7
19:37:52 <lambdabot>   3
19:38:24 <avpx> Well, there you have it, folks
19:38:28 <avpx> pi is exactly equal to three.
19:38:44 <SHACHAF> pi is as equal to 3 as it is to 3.1415927
19:39:07 <nand`> > (pi :: Uni) == 3
19:39:08 <lambdabot>   No instance for (GHC.Float.Floating Data.Fixed.Uni)
19:39:08 <lambdabot>    arising from a use o...
19:39:12 <avpx> In the sense that it's "not," I presume?
19:39:19 <SHACHAF> When you can compile and run a Haskell program made up of all the digits of pi in order, you can say that pi = 3
19:39:27 <SHACHAF> (If it prints 3.)
19:39:41 <newsham> except not in real haskell
19:39:50 <ddarius> Why would you make the program out of the digits of pi?
19:40:01 <nand`> easy, use TH to generate it
19:40:21 <newsham> how many infinite programs are legal haskell?
19:40:37 <ddarius> That said, the UTF8 encoding of any Haskell program occurs in the bytes of pi somewhere.
19:40:39 <SHACHAF> None of them.
19:40:41 <nand`> I'm not sure. I think I'll have to look up the report about that one
19:40:54 <SHACHAF> Alternatively: All of them. But there are no infinite programs.
19:41:05 <newsham> ddarius: bytes of pi = base-256?
19:41:10 <ddarius> Yes.
19:42:03 * ddarius moves on to hidden Markov models (though he'll probably combine [simple] Kalman filtering with them.)
19:42:06 * hackagebot iteratee 0.8.9.3 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.9.3 (JohnLato)
19:44:40 <otters> what would you folks recommend for a map of String => [String]
19:45:02 <ddarius> Map String [String]
19:45:10 <otters> figured
19:45:48 <ddarius> I might recommend something different if I knew what you were using it for and what was important to you.
19:45:52 <startling> otters: repeat
19:46:03 <startling> ;)
19:46:26 <startling> `return` works too I guess
19:46:31 <ddarius> class String;  f :: String => [String]
19:46:43 <avpx> startling: I don't think he meant in the functor sense
19:46:48 <avpx> Err
19:47:11 <SHACHAF> otters: I recommend (String -> [String])
19:47:14 <avpx> Well, in any case I think we were talking about the Map data structure
19:47:28 <startling> hehe
19:47:40 * ddarius endeavors to read 3-5 hundred pages of technical material as quickly as possible.
19:53:27 <otters> @pl \x -> (last x, head x)
19:53:27 <lambdabot> liftM2 (,) last head
19:54:00 <SHACHAF> @ty last &&& head
19:54:01 <lambdabot> forall c. [c] -> (c, c)
19:54:06 <SHACHAF> (But it's an evil function, of course.)
19:54:37 <otters> @pl \w -> zip w (tail w) ++ [liftM2 (,) last head $ w]
19:54:37 <lambdabot> ap ((++) . ap zip tail) (return . liftM2 (,) last head)
19:54:59 <aristid> SHACHAF: it's evil insofar it uses last, i guess?
19:55:08 <SHACHAF> aristid: Yes, and head to a lesser degree.
19:55:20 <aristid> SHACHAF: ok right, that's partial
19:55:42 <SHACHAF> aristid: You seem gloomy.
19:55:50 <SHACHAF> Not cheerful and uplifty like before.
19:55:51 <aristid> i'm not :)
19:55:55 <aristid> oh
19:55:57 <aristid> haha
19:56:04 <aristid> because i'm lowercase now?
19:57:58 <erlnoob> quick question, I have ghc installed with the haskell platform, but not sure if it's 32bit or 64bit version, how do I find out which?
19:59:00 <SHACHAF> ghc +RTS --info
19:59:51 <erlnoob> SHACHAF: thanks :)
20:01:45 <Saizan> SHACHAF: you look SQLy to me
20:02:16 <otters> @pl (\a (x,y) -> M.insertWith' (++) x [y] a)
20:02:16 <lambdabot> (`ap` snd) . (. fst) . flip (flip . (. return) . M.insertWith' (++))
20:02:20 <otters> great!
20:02:59 <erlnoob> is it ok if I just install the latest haskell platform on top of the old one or do I need to uninstall first?
20:03:23 <SHACHAF> You haven't yet mentioned what operating system you're using (usually a good question when you're asking these types of questions).
20:03:34 <SHACHAF> In general installing multiple versions of GHC at once is fine.
20:03:46 <erlnoob> SHACHAF: I'm on osx
20:07:01 <Saizan> osx tends to be touchy, but otherwise the old one might not be completely functional (i.e. tools like haddock) but it shouldn't be a problem for the new one, though if you are not going to use the old one it might be better to remove preemptively
20:07:36 <Saizan> judging from linux experience though
20:08:45 <tibbe> I have an AST for a DSL I just created. Are there any libs that makes creating a pretty printer for that easy. I want to pretty-print the DSL back as the Haskell syntax that it represents (i.e. function applications like f (g "foo")
20:10:06 <SHACHAF> Show has some mechanisms for it...
20:10:19 <SHACHAF> Probably not to the point of being "easy", though.
20:10:20 <geekosaur> tibbe:  the only AST prettyprinter I'm aware of is in haskell-src-exts
20:10:35 <SHACHAF> Ah, there's an actual Haskell code pretty-printer, yes.
20:10:43 <tibbe> geekosaur: I could convert my AST to a Haskell AST but it'll be a bit of a PITA
20:10:46 <SHACHAF> groom uses it to pretty-print arbitrary expressions.
20:11:01 <tibbe> shachaf: will give it a try
20:12:12 <dmwit> oh my
20:12:31 <SHACHAF> hi dmwit
20:13:06 <dmwit> must have been a different channel
20:13:25 <dmwit> Ah, I see it was #-blah.
20:13:38 <SHACHAF> What was?
20:13:51 <dmwit> or... no
20:13:58 <dmwit> I'm trying to find what triggered your name change. =P
20:14:14 <SHACHAF> Oh, it was in #cslounge-trains
20:14:34 <dmwit> amazing
20:14:49 <SHACHAF> dmwit: YOU SHOULD TRY IT!
20:14:55 <SHACHAF> IT'S VERY UPLIFTING
20:15:03 <DMWIT> hm
20:15:08 <SHACHAF> DMWIT: WELCOME TO "THE CLUB"!
20:15:18 <SHACHAF> You don't have to shout when you're in THE CLUB.
20:15:29 <aristid> i was in the club just briefly :(
20:15:31 * SHACHAF suspects #-blah is a better channel for shouting.
20:15:33 <DMWIT> Does being uplifted count as a minor problem for the purposes of prayer?
20:15:57 <SHACHAF> DMWIT: That depends on whether an eel has swung itself around you recently.
20:16:17 * SHACHAF quaffs cursed potion of uplifting.
20:16:17 --- mode: Cale set -o Cale
20:16:38 <DMWIT> I feel like I'm shouting even when I type in lower case letters.
20:17:00 <SHACHAF> DMWIT: The best part is when you forget about it, and then someone else tab-completes your name.
20:17:07 <SHACHAF> And you're uplifted all over again.
20:20:45 <nanotech> is there a way for the f in `\x -> let f = … in (f $ x+1, f $ show x)` to become a parameter that accepts all the same functions it does in the let position? as in `\f x -> (f $ x+1, f $ show x)`.
20:22:01 <ion> It’s almost two months until the CAPS LOCK DAY.
20:22:22 <Cale> nanotech: You can turn on Rank2Types or RankNTypes and give an explicit polymorphic type signature to the function parameter
20:23:02 <nanotech> I tried that, but couldn't get it to generalize for functions that returned different types
20:23:13 <nanotech> say, id and Just
20:23:43 <nanotech> (forall a. a -> a) -> Int -> (Int, String) works for id, but only id
20:24:11 <DMWIT> You have to give it the type it would have had in the let position.
20:24:43 <Saizan> (forall a. a -> a) is that type for id :)
20:25:01 <Saizan> if you want both id and Just you've to find a type that generalize both
20:25:34 <Saizan> (forall a. a -> f a) is close, if you allow for Identity rather than id
20:26:18 <ddarius> Saizan: The issue is, unless f was id, it needed more information anyway.
20:27:08 <nanotech> is the issue that i'm just getting the type wrong, or that there is no way to generalize to all functions that can operate on the two tuple component types?
20:27:26 <ddarius> nanotech: For now, it's the former.
20:27:59 <nanotech> what about if I wanted to use typeclass functions too, say show and serialize
20:28:11 <ddarius> nanotech: Then just use the appropriate type.
20:31:39 <Cale> What are you actually trying to do?
20:33:30 <startling> what does it take to port ghc to a new platform? a libc? what else?
20:34:26 <nanotech> I got on this trail from trying to generalize a free monad transformer, but I found it kind of interesting that this was the first instance I found where you couldn't directly lift some code out of a function and have it maintain the same generality
20:34:33 <geekosaur> gmp is useful although there's a pure haskell alternative.. which would still be difficult as I don't think youc an bootsrrap it with an unregisterised build
20:34:39 <nanotech> or at least the first that I noticed
20:34:50 <startling> geekosaur: oh hmm
20:34:54 <DMWIT> What code are you trying to lift out?
20:35:58 <nanotech> I'll pull out the original code.
20:36:01 <geekosaur> I don't think you need a lot else beyond that though, ghc is reasonably self-contained
20:36:29 <startling> yeah. cool, good to know !
20:37:28 <hpaste> nanotech pasted “Transform.hs” at http://hpaste.org/74142
20:38:20 <nanotech> it's an attempt at something like monad-par, but for monadic (esp. IO) code too
20:39:03 <geekosaur> startling, you might want to ask in #ghc (dunno if anyone is around right now though), I may well be wrong about integer-simple or etc
20:40:03 <nanotech> the issue I was having is that all the in and output types in a run are constrained to be the same
20:41:02 <nanotech> because the monad transformer gets passed the processing functions
20:41:04 <startling> geekosaur: I'm just idly wondering, anyway
20:42:29 <DMWIT> Well, the current maintainer hasn't gotten back to me about patches to make it build on GHC7. It's been five months.
20:42:46 <DMWIT> Is it okay to exploit Hackage1's security policy and upload a new version yet?
20:44:11 <DMWIT> nanotech: There's a lot of code there. What, specifically, are you trying to lift?
20:44:20 <ddarius> dmwit: If you are going to take over maintainership, you should announce it on the libraries list.
20:44:51 <DMWIT> ddarius: Ah; before taking over, or after?
20:45:43 <nanotech> DMWIT: yeah, sorry. in the `ideal` function, i'd like to be able to uncomment that `showT input` line and have it work
20:46:09 <nanotech> DMWIT: the only way I can see to do that is to remove the conduit type from the transformer
20:46:10 <ddarius> DMWIT: Before, though in this case it can be a pretty brief period unless someone objects.
20:46:38 <DMWIT> Okay, thanks for the advice.
20:46:48 <ddarius> DMWIT: Basically, announce that you intend to take over maintainership and why, and if the current maintainer or someone else doesn't say something/object, act on it.
20:47:05 <DMWIT> Will do.
20:47:19 * DMWIT wonders what the Hackage2 story for this kind of thing is
20:47:58 <DMWIT> nanotech: :t showT
20:48:26 <ddarius> Probably harass the Ross-alike until some kind of semi-automatic reputation scheme is made.
20:48:43 <nanotech> DMWIT: showT :: (Monad m, Monad m1, Show a1) => i -> TransformT [Char] (Pipe l a1 String r m1 r) i a m a
20:50:31 <DMWIT> Why are you expecting a free monad with Pipe bits in to be compatible with a free monad with Conduit bits in?
20:51:13 <nanotech> Conduit is a specialized type synonym for Pipe
20:52:42 * ddarius finds the aspects of Haskell's community fascinating.
20:53:46 <DMWIT> Okay, let me try again. Why are you expecting a free monad with Pipe bits in that outputs Strings to be compatible with a free monad with Pipe bits in that outputs Ints?
20:54:01 <DMWIT> (This time I feel more confident that Int and String can't unify.)
20:54:08 <nanotech> I'm not, that's what i'm trying to find a way around
20:54:18 <nanotech> I got my first lambda question by simplifying the transformer out of this code so that mk*Transform function was passed directly into ideal
20:55:03 <nanotech> that didn't work, but removing the parameter and pasting mkListTransform into each call did. thus the let f = thing from before
20:55:29 <DMWIT> Did you try
20:56:09 <DMWIT> ideal :: (Monad m, Monad n) => (forall m n c i a. Monad m => n -> c -> i -> TransformT n c i a m a) -> {- rest of ideal's type here -}
20:56:12 <DMWIT> ?
20:56:25 <DMWIT> This is the rank-2 version of passing in the fully-polymorphic mkTransform.
20:57:20 <nanotech> no, I'll try that
21:02:06 <nanotech> ah, perfect!
21:02:24 <nanotech> thanks, DMWIT
21:02:37 <DMWIT> haha
21:02:48 <DMWIT> SHACHAF was really right about the "right after you forget" thing
21:03:14 <Nereid> haha, what's with the all caps names.
21:03:27 <DMWIT> It's a virus.
21:03:38 <DMWIT> Don't chat with me, you might catch it.
21:04:11 <nanotech> so would it be correct to interpret adding forall to all the type variables as delaying the type instantiation?
21:04:47 <DMWIT> That is exactly what it is, yes.
21:06:25 <ddarius> nanotech: The value level realization of a forall would be a type lambda, i.e. the type would be passed as a parameter.  One of the consequences of this, is that it changes who provides the type.
21:07:03 <nanotech> ddarius: ah, I see. makes sense.
21:07:37 <ddarius> nanotech: E.g. forall a. (a -> a) -> X, means, you'll pass in the type to bind to a and that's what I must use when implementing the function, but (forall a. a -> a) -> X, means you are passing in a function of a type that I can provide.
21:07:54 <ddarius> Type lambdas and type application (instantiation) are implicit in Haskell.
21:11:46 <dfordivam> hello
21:13:50 <avpx> ddarius: Is the latter the same as exists a. (a -> a) -> X? This is where I get tripped up because I know there are ways to move quantifiers around but I don't know the rules
21:14:23 <ddarius> avpx: That's not a valid equivalence in intuitionistic logic.
21:14:29 <DMWIT> (And the fact that it's implicit can be darn difficult to deal with sometimes.)
21:14:36 <avpx> ddarius: Is it valid in any logic?
21:14:58 <ddarius> avpx: It's valid in classical logic because all the operators/quantifiers are dual.
21:15:05 <avpx> Okay
21:15:10 <DMWIT> ddarius: Really?
21:15:22 <DMWIT> Can't the implementation use the argument at two different types, so to speak?
21:15:56 <tibbe> edwardk: I found Sjoerd's solution really nice: http://stackoverflow.com/questions/12230088/how-can-i-recover-sharing-in-a-gadt
21:15:57 <DMWIT> (I admit that I am not calculating, but rather reading as English, the types.)
21:16:51 <tibbe> edwardk: in the end it doesn't buy us much as most of the expressions are in the environment, which isn't statically typed
21:17:02 <edwardk> hrmmm
21:17:10 <zzo38> Is thre any ephemeris to use with Haskell and use enough features?
21:18:09 <zzo38> I want to make a program for astronomy and astrology and want to learn the geometry and so on usable with Haskell. And then, there is text mode, and some things can use graphical mode.
21:18:20 <zzo38> Do you know these things?
21:18:34 <DMWIT> If you looked on Hackage and didn't see one, there probably isn't one.
21:18:44 <DMWIT> If you didn't look on Hackage, do so now.
21:18:55 <zzo38> I already did look on Hackage.
21:19:04 <DMWIT> I exclude the possibility that you looked on Hackage and saw one on the grounds that you shouldn't ask the question in that case.
21:19:44 <zzo38> I also looked on Wikipedia, Haskell Wiki, Google, Veronica, and Usenet.
21:20:07 <zzo38> I did not find any.
21:20:08 <ddarius> As Leibniz would say, "Let us calculate."  Simplifying we have, (forall a. a) -> X <=> not ((forall a. a) and (not X)) <=> not (forall a. a) or X <=> (exists a. not a) or X <=> exists a. not a or X <=> exists a. not (a and not X) <=> exists a. a -> X.
21:20:12 <SHACHAF> zzo38: Did you check any Gopher servers?
21:20:18 <zzo38> However some other people seem to want some too.
21:20:22 <SHACHAF> Oh, that's Veronica.
21:20:22 <zzo38> SHACHAF: Yes, Veronica.
21:22:24 <zzo38> I have found *no* other program with what I need. The closest I have found is Astrolog, which is very fast, and contains only two features I found useless (biorhythms and interpretations), but is not allowed for commercial use (so it is not compatible with FOSS).
21:22:41 <zzo38> Even that lacks various things.
21:22:47 <DMWIT> ddarius: Very helpful, thanks.
21:22:47 * ddarius remembers that (A -> B) <=> not (A and not B) by using the classical BHK interpretation and interpreting not A as an A accepting continuation.
21:23:07 <avpx> ddarius: I see, but it really is by taking the law of excluded middle that you arrived at that?
21:23:09 <ddarius> Then not (A and not B) means a continuation that takes A and a return address.
21:23:33 <ddarius> avpx: Yes, by using double negation elimination (and equivalent things) at various points.
21:23:47 <avpx> Okay, thanks.
21:24:25 <ddarius> The connection between classical second order propositional logic and assembly programming should be clear.
21:24:26 <zzo38> I have found Swiss Ephemeris which is a software library with many features but is for C rather than Haskell, and even that lacks some things.
21:24:56 <zzo38> I also managed to find Dutch Ephemeris, which has the same problems (although also the same benefits).
21:25:20 <DMWIT> I see, the "not (forall a. a) <=> exists a. not a" duality is exactly expressing the (to me, surprising) fact that if you can produce something by calling the first thing at several types, then you can produce that thing by calling it at one specific type.
21:25:48 <zzo38> Do you know about these kind of calculation with Haskell?
21:25:55 <DMWIT> In retrospect, this should not be surprising.
21:26:38 <ddarius> You'll find that you can't implement both directions of the equivalence in Haskell.
21:27:08 <avpx> exists a. not a => not (forall a. a), correct?
21:27:10 <dolio> If that's your interpretation, then it is surprising.
21:27:23 <ddarius> As a result, runST's type is logically more powerful than the classically equivalent: runST :: exists s. ST s a -> a.
21:28:27 <DMWIT> dolio: Well, the point of rank-2 types is so that you can call the argument you're supplying at several different types, no?
21:28:44 <DMWIT> And not (forall a. a) <=> (forall a. a) -> False looks a bit like a rank-2 type to me. =)
21:28:57 <dolio> DMWIT: Yes.
21:29:28 <DMWIT> Perhaps you weren't objecting to my interpretation, and I needn't defend myself.
21:30:42 <ddarius> x :: not (forall a. a) would say x is a continuation that will accept something that it can instantiate at any type.  x :: exists a. not a says x is a package of a type and a continuation that can be applied at that type.
21:30:55 <dolio> You should be surprised at, "if you can implement it by calling at multiple types, you can implement by calling at one type." Because that's not true without classical logic, and the interpretation there is from the typically non-classical school.
21:32:16 <dolio> Unless you're talking continuations, I guess, which it looks like you are.
21:32:44 <ddarius> avpx: In classical logic, they are equivalent.
21:33:11 <avpx> Right, I was referring to intuitionist logic
21:33:36 <ddarius> avpx: In intuitionistic logic, I think it's the other direction that's doable, but you can verify this by attempting to write the appropriate programs.  Or you can have Djinn do it.
21:33:59 <dolio> Except you can't have djinn do it. :)
21:34:25 <DMWIT> data Funny = forall a. Funny (a -> Void)
21:35:25 <DMWIT> f :: Funny -> ((forall a. a) -> Void); f (Funny g) bottom = g bottom
21:36:14 <dolio> Although, if you write (forall a. a) = Void, then one side is Void -> Void, and it's clear that exists a. a -> Void with a = Void. :)
21:36:39 <ddarius> Yeah, this particular example might be a bit degenerate.
21:36:45 <dolio> Yeah.
21:37:24 <DMWIT> f :: ((forall a. a) -> Void) -> Funny; f g = Funny g -- so... Haskell is not intuitionistic...?
21:37:34 <DMWIT> One of these must not typecheck. Let me pull out my GHC.
21:37:42 <ddarius> DMWIT: See dolio's recent comment.
21:38:09 <ddarius> But yes, make sure you check with GHC too
21:38:11 <dolio> If you want to make it more interesting, you need to put some arbitrary predicate in there.
21:38:35 <dolio> not (forall a. P a) vs. exists a. not (P a)
21:38:59 <ddarius> "Let B(R^n) be the space of bounded, Borel measurable functions on R^n."
21:39:36 <DMWIT> GHC says these typecheck.
21:40:02 <DMWIT> So "not (forall a. a) <=> exists a. not a" seems to be an okay equivalence in Haskell.
21:40:51 <parcs`> is why there no Functor instance for (,,) etc?
21:40:57 <DMWIT> Oh, I guess I didn't check that they composed to the identity.
21:41:01 <parcs`> why is*
21:41:06 <parcs`> jesus christ i suck at typing
21:41:31 <dolio> DMWIT: You can just prove 'not (forall a. a)' and 'exists a. not a' by themselves.
21:41:54 <Cale> ddarius: What prompted that quote?
21:42:35 <dolio> They're both the unit type, but you'll probably need parametricity to prove that.
21:43:04 <ddarius> The left side follows immediately from continuity and the fact that forall a. a ~ Void.
21:43:12 <DMWIT> dolio: ...oh
21:43:56 <ddarius> Cale: It was just a discontinuous change in the diction and feel of the article I'm reading.
21:45:12 <Cale> Functional analysis?
21:45:32 <ddarius> Cale: No, signal filtering.
21:46:04 <ddarius> Admittedly, signal filtering is not at all far removed from functional analysis.
21:48:03 <ddarius> avpx: Anyway, if you view exists as a generalization of sums and forall as a generalization of products.  All the intuitionistically valid equivalences are the "high school algebra" ones, e.g. A^(B+C) ~ A^B * A^C, so A^(exists a. P a) ~ forall a. A^(P a)
21:49:41 <avpx> Holy crap.
21:51:33 <otters> The only thing worse than a strictness/laziness specific problem is when you're not sure which is which
21:51:51 <avpx> ddarius: That's really interesting. Any particular literature on this you'd recommend?
21:52:18 * ddarius needs a nice proof that Lim Id ~ 0 and Colim Id ~ 1 using only continuity of adjoints/hom functors arguments.
21:54:00 <ddarius> avpx: Probably start by looking at the BHK interpretation.  I believe the online lecture notes "Lectures on the Curry-Howard Isomorphism" goes over those.
21:55:32 <ddarius> avpx: Also, these ideas become much clearer categorically.  All the "high school algebra" isomorphisms follow from continuity of the adjoints that define symmetric monoidally closed categories, and thus apply to anything that can be viewed as an instance of one of those.
21:55:58 <avpx> ddarius: Cool, I've been reading a bit through Mac Lane, though I'm not terribly far in.
21:56:25 <ddarius> @google Barr Wells ESSLLI
21:56:27 <lambdabot> http://www.ling.ohio-state.edu/~plummer/courses/winter09/ling681/barrwells.pdf
21:56:53 <ddarius> I recommend those notes and Awodey's book for category theory stuff (though not specific to this.)
21:58:33 <avpx> Neat, thanks.
22:00:52 <hpaste> otters pasted “Markov chain generator that doesn't work” at http://hpaste.org/74148
22:00:58 <otters> help!
22:01:09 <otters> it works when I unsafePerformIO newStdGen
22:01:12 <otters> but not otherwise
22:01:45 <DMWIT> um
22:01:48 <DMWIT> You don't want newStdGen.
22:01:53 <otters> Oh boy
22:01:58 <otters> I don't?
22:02:02 <DMWIT> Almost certainly not.
22:02:07 <DMWIT> Just getStdGen.
22:02:18 <DMWIT> There may be other problems.
22:02:24 <otters> I would think there were
22:02:33 <DMWIT> Or even better, just use randomRIO
22:02:34 <otters> chain' uses chain'' to get the next word in the list and maps it onto its own result
22:02:39 <otters> yeah, I should probably do that
22:02:45 <DMWIT> which calls putStdGen correctly for you.
22:02:49 <DMWIT> (setStdGen?)
22:03:06 <otters> chain' current morewords = let new = chain'' current morewords in new:chain' new morewords
22:03:07 <otters> basically
22:03:12 <DMWIT> I can never keep the get/read/take/set/put/write things right.
22:03:20 <DMWIT> s/right/straight/
22:03:23 <otters> And that works if I unsafely perform the random number generation part.
22:03:27 <otters> but not if I don't.
22:03:31 <otters> so it's some kind of I/O related problem.
22:03:40 <SHACHAF> DMWIT: I can never get get/write right.
22:03:42 <otters> If I don't use unsafePerformIO the program hangs and apparently infinite loops.
22:05:09 <DMWIT> Oh, you're trying to return a lazy infinite list from your IO action?
22:05:17 <otters> Exactly.
22:05:20 <DMWIT> Yeah, don't do that (or learn about unsafeInterleaveIO).
22:05:42 <DMWIT> The simplest thing is probably to just use randomRs and make a pure lazy infinite list instead.
22:06:11 <DMWIT> :t randomRs
22:06:12 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
22:06:25 <otters> And then get the generator in main and pass it to the pure function.
22:06:27 <DMWIT> :t \r -> randomRs r <$> getStdGen
22:06:29 <lambdabot> forall a. (Random a) => (a, a) -> IO [a]
22:06:32 <DMWIT> yes
22:06:47 <otters> Well, I need to generate each number in a specific range, as you can see
22:06:56 <otters> maybe I can state monad
22:07:00 <DMWIT> Ah, okay.
22:07:22 <DMWIT> In that case, you'll probably want to use randomRs (0,1) and then scale to the actual range you want.
22:07:25 <otters> Time for a rewrite.
22:07:38 <otters> What about prime numbers?
22:07:45 <DMWIT> What about them?
22:07:55 <otters> I guess I don't understand what you mean by that.
22:08:06 <DMWIT> :t mkStdGen
22:08:07 <lambdabot> Int -> StdGen
22:08:19 <DMWIT> > randomRs (0,1) (mkStdGen 0) :: [Double]
22:08:20 <lambdabot>   [0.9872770354820595,9.953806877591176e-4,0.9737700946800807,0.1302804380260...
22:08:21 <otters> oh
22:08:23 <otters> okay
22:09:28 <DMWIT> > let source = randomRs (0,1) (mkStdGen 0); funnyRange (lo,hi) v = (hi-lo) * v + lo in zipWith funnyRange [(5,10), (100,1000), (100,1000), (5,10)] (randomRs (0,1) (mkStdGen 0)) :: [Double]
22:09:29 <lambdabot>   [9.936385177410298,100.89584261898321,976.3930852120726,5.651402190130065]
22:09:43 <DMWIT> otters: Now are we on the same page? =)
22:10:24 <DMWIT> oh, I defined source to be nice to myself and then didn't even use it =/
22:10:28 <Axman6> y u no use source?
22:10:35 <Axman6> heh
22:12:23 <dolio> ddarius: Is Id terminal in [C^op, C^op]?
22:13:22 <DMWIT> I would think Id was initial in [D, D] for any D, including C^op.
22:13:49 <dolio> I don't think either is true, off hand.
22:14:14 <DMWIT> Oh, huh.
22:14:20 <dolio> That's every endofunctor is (co)pointed.
22:14:21 <DMWIT> Right, I agree.
22:15:12 <DMWIT> Right, you need an arrow from X -> F X for every X for Id to be initial, which seems easy to cook up a counterexample.
22:15:25 <DMWIT> Take a discrete category and any non-Id functor, for example.
22:17:06 <Nereid> C is an arbitrary category?
22:17:20 <dolio> Yes.
22:17:22 <Nereid> identity functor is in general not universal in either way
22:18:10 <Nereid> consider C = Sets, and note that the empty set exists.
22:18:10 <DMWIT> I think we've made it that far, yep.
22:18:21 <DMWIT> You don't like my counterexample? =)
22:18:32 <Nereid> or that.
22:18:51 <otters> Man haskell is fast.
22:18:52 <dolio> If you want lim Id ~ 0 due to continuity, then lim is a left adjoint, so it preserves limits, so you want Id to be terminal in C^op.
22:19:16 <dolio> Unless I'm mistaken.
22:19:29 <Nereid> lim Id is the terminal object
22:19:53 <Nereid> er
22:19:55 <ddarius> Lim is a right adjoint when the general functor exists.
22:20:08 <dolio> That's what I meant.
22:20:13 <Nereid> no, initial.
22:20:19 <Nereid> if it exists.
22:20:20 <dolio> Right adjoints preserve limits.
22:20:35 <Nereid> either that or my brain isn't working.
22:21:07 <dolio> Anyhow, doesn't matter, because even if it preserved colimits, you'd want Id to be initial in C or something, which it isn't, either.
22:21:38 <ddarius> Nereid: Yes, Lim Id is initial if it exists, and it's pretty easy to prove, but I don't like the proofs I know.  I want one in a different style.
22:22:33 <yitz> DMWIT: are you feeling ok today?
22:22:37 <Reko_> I have a function at the top of my file referencing a function at the bottom of my Haskell source file, and it's giving me a not-in-scope error. ???
22:22:47 <ddarius> Reko_: You have some other problem.
22:22:56 <Reko_> Ah, okay.
22:23:13 <Nereid> how'd this discussion arise, anyway?
22:24:42 <ddarius> dolio: I wasn't saying that I wanted to say Lim Id ~ 0 because Lim is continuous or something, just that the proof used primarily continuity arguments (and less clearly other arguments like the definition of things in terms of representability and the naturality formula for example, though that was not clear.)
22:25:10 <dolio> Ah.
22:25:24 <Nereid> this is what I get for jumping into the middle of a conversation.
22:27:15 <ddarius> I.e. I want a proof like Hom(-,1) ~(by definition of terminality) ~ 1 ~ magic ~ Hom(Colim Id, Colim Id) ~ Nat(Id, K(Colim Id)) ~ magic ~ Hom(-, Colim Id)
22:27:37 <ddarius> And then you implicitly apply Yoneda as usual.
22:27:38 <Nereid> ~magic~
22:28:14 <ddarius> What I -don't- want is to break open Nat(Id, K(Colim Id)) as a cone and point out that those are the components are exactly the arrows we need etc.
22:29:18 <Nereid> what's K
22:29:29 <dolio> Constant.
22:29:33 <Nereid> oh right that.
22:30:05 <ddarius> So things like the naturality formula, End x. Hom(F(x-), G(x+)) ~ Nat(F,G), or F fully faithful, Hom(A,B) ~ Hom(FA,FB), are fine as well.
22:30:39 <DMWIT> yitz: I feel GREAT!
22:30:42 <ddarius> Incidentally, when C has a terminal object it's representability formula is a special case of the preservation of limits by Hom functors.
22:30:49 <ddarius> I.e. Hom(-,1) ~ 1
22:31:02 <Nereid> indeed.
22:31:49 <ddarius> In fact, this is the case for all limits and colimits.  Representability just interprets them as limits of hom-sets in Set.
22:34:49 <ddarius> Hmm, maybe I should (doubly) exploit the full faithfulness of Yoneda.
22:35:08 <artelius> Hello, I'm wondering if there is an easy to way to do something like: data Foo = X | Y | Z deriving (Enum, Bounded) ; data Bar = A Foo | B Foo deriving (Enum, Bounded)  (actually I only care about the Enum but there would be no way to "derive" it without the bounds)
22:35:37 <Nereid> artelius: what's wrong with what you just wrote?
22:35:46 <DMWIT> What's wrong is it doesn't work. =)
22:35:50 <Nereid> oh
22:35:54 <Nereid> I didn't know that.
22:35:56 <DMWIT> GHC refuses to do Enum on non-single-arity-constructor types.
22:35:58 <artelius> Bar has has "non-nullary constructors"
22:36:06 <DMWIT> err, zero-arity, yes
22:36:21 <DMWIT> I've been annoyed by this before.
22:36:57 <DMWIT> I think what I usually end up doing is defining a class Universe a where universe :: [a] and default implementations for the Enum functions that are Universe-polymorphic.
22:37:10 * hackagebot xournal-builder 0.1.1.1 - text builder for xournal file format  http://hackage.haskell.org/package/xournal-builder-0.1.1.1 (IanWooKim)
22:37:14 <DMWIT> Maybe Universe is a bad name.
22:37:22 <DMWIT> class Finite a where universe :: [a] might be better.
22:38:06 <ddarius> dolio: You guys may be vaguely interested in the article I'm reading.
22:38:47 <ddarius> dolio: "The Unscented Particle Filter".  One of the examples is a finance problem.
22:39:40 <ddarius> Now to switch to HMM.
22:40:11 <ddarius> dolio: It is generally right up Ed's alley, though he may find some things interesting.
22:40:53 <dolio> I'll check it out.
22:41:32 <dolio> Merwe, Doucet, Freitas and Wan?
22:42:12 <artelius> DMWIT: I think I understand
22:42:18 <artelius> Thanks
22:43:51 <artelius> but my intuition tells me it won't perform well on large enums?
22:43:53 <ddarius> dolio: Yes.
22:44:15 <ddarius> Man, IEEE has all the control theory/signal processing/data fusion papers.
22:47:03 <pharaun> paywall?
22:47:35 <dolio> Man, now I'm conflicted. I looked up The Groupoid Interpretation of Type Theory earlier, and they actually talk about 'extensional identity sets' in the way that I'd only heard category theorists talk about them.
22:49:21 <ddarius> pharaun: Yes.
22:49:27 <pharaun> ddarius: :\
22:49:32 <ddarius> dolio: Why does this conflict you?
22:50:11 * ddarius has been finding particularly very lately that he is very particular about people citing specific people.
22:51:09 <dolio> I'd written a note on ncatlab's article about extensional type theory that it's got a lot of incorrect information, but now I'm not sure how much is incorrect and how much is due to my not reading the right people on type theory.
22:51:18 <dolio> Since at least some of what I thought was wrong was common usage.
22:51:30 <dolio> Some of it is still wrong though, I think.
22:52:11 <ddarius> dolio: Your thinking there may be terminological confusion?  Otherwise, it either is or is not correct.
22:52:26 <ddarius> (or generally different contexts)
22:52:55 <dolio> Well, their definition of extensional type theory is any type theory with unique identity proofs, which is wrong.
22:53:25 <dolio> But I also kind of took issue with 'extensional identity types' being ones that have unique proofs, since I'd never heard that before, but I guess it has precedent.
22:54:09 <djahandarie> How do you define extensional type theory? Just any TT that has the extensionality 'axiom'?
22:54:32 <dolio> They also have a lot of examples of 'equivalent formulations' of extensional type theory that are only equivalent if you look at the models they support, and not at other aspects.
22:55:27 <dolio> No. Extensional type theory is traditionally one where there's an inference rule from propositional equality to judgmental equality.
22:55:49 <dolio> Which means that if two terms are provably equal, they are convertible.
22:56:09 <dolio> That implies unique identity proofs/K, but not the other way around.
22:56:30 <dolio> But their page just lumps them all together.
22:56:32 <djahandarie> I think that's the axiom I'm talking about.
22:56:46 <dolio> Oh, then yes.
22:56:53 <djahandarie> f,g \in A -> B      p \in \Pi a \in A . f a = g a
22:56:53 <ddarius> djahandarie: Wouldn't K normally be the axiom?
22:56:56 <djahandarie> -----------------------------
22:57:01 <djahandarie> ext p \in f = g
22:57:12 <ddarius> djahandarie: Nevermind.
22:57:23 <dolio> K is a different eliminator for the propositional equality type.
22:58:01 <dolio> djahandarie: No, not that.
23:00:03 <dolio> djahandarie: In Martin-Loef type theory, there are equality judgments.
23:00:15 <dolio> x = y : A
23:00:21 <poisonarms> Are there any screencasts for learning Haskell?
23:00:39 <dolio> In ITT, you get x = y : A when x and y are convertible by the reduction rules, more or less.
23:00:40 <djahandarie> Right.
23:01:08 <ddarius> poisonarms: Someone is making some right now.
23:01:24 <dibblego> poisonarms: http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
23:01:33 <typoclass> poisonarms: how about http://haskelllive.com/
23:01:38 <dolio> And if x = y : A, you can also prove refl : Id A x y.
23:02:08 <poisonarms> Thanks guys. I'll check them both out.
23:02:18 <dolio> djahandarie: But extensional type theory has a rule with a premise of 'p : Id A x y' and a conclusion of 'x = y : A'.
23:02:59 <dolio> Which obviates the need for J and K, I believe.
23:04:01 * ddarius is reminded of focusing a la Paul Taylor's abstract stone duality.
23:04:18 <dolio> But then syntax directed type checking becomes undecidable.
23:04:44 <dolio> Because the identities you've substituted by aren't represented in the syntax.
23:04:56 <djahandarie> This is what OTT solves, right?
23:05:30 <dolio> Yeah, OTT is still intensional in this sense.
23:05:57 <dolio> Which is why it has decidable type checking.
23:06:28 <dolio> Of course, the page on ncatlab mentions that ETT has undecidable type checking, but most of their examples of ETT probably aren't undecidable.
23:06:34 <dolio> Which is another problem.
23:07:36 <hpaste> rosie pasted “monads” at http://hpaste.org/74150
23:08:16 <rosie> Could I have a hand with a couple lines of code? I'd love some help with the monads!
23:09:03 <hpaste> rosie annotated “monads” with “monads (annotation)” at http://hpaste.org/74150#a74151
23:09:28 <hpaste> rosie annotated “monads” with “monads (annotation)” at http://hpaste.org/74150#a74152
23:09:30 <Saizan> rosie: i suspect you should stop using tabs
23:09:30 <edwardk> preflex: xseen jberryman
23:09:49 <ddarius> edwardk: Familiar with the unscented transform?
23:09:55 <edwardk> lolwut
23:10:07 <ddarius> edwardk: You should give it a look then.  You'll like it.
23:10:09 <edwardk> like kalman filters?
23:10:10 <Saizan> rosie: return on line 5 needs to align with students on line 4
23:10:26 <ddarius> edwardk: Yes, the unscented Kalman filter is probably the most common application.
23:10:30 <edwardk> k
23:10:33 <rosie> Saizan: yep, I tried delete ding the spaces and inserting the correct number of spaces straight in hpaste, but it didn't work
23:10:53 <edwardk> i know the kalman filter part, but i've paged out the rest ;)
23:13:02 <ddarius> This short little Chinese paper I'm reading may turn out to be more useful than I thought.
23:13:20 <djahandarie> You can read Chinese?
23:13:36 <Saizan> rosie: you need to correct them in your file anyway
23:14:03 <edwardk> ddarius can do anything
23:14:04 <ddarius> djahandarie: No.
23:14:09 <Saizan> rosie: if your editor can you should make it expand tabs to spaces
23:14:42 <edwardk> ddarius: Ray, when someone asks you if you're a god, you say "YES"!
23:14:43 <rosie> hmm I'm using haskell-mode in emacs. That should cover it, right?
23:14:53 <rosie> Saizan: CC ^^
23:16:08 <SHACHAF> Saizan: What tabs?
23:18:03 <Saizan> SHACHAF: i was assuming
23:18:17 <ddarius> Yay files with backslashes in the name.
23:18:29 <Saizan> rosie: i think so, then just fix the alignment
23:18:51 <rosie> Saizan: thanks. Any ideas on the content?
23:20:19 <djahandarie> dolio, what about 'p : Id A x y' concluding 'p = r(a)'? I think that follows from the earlier rule (using Id-elim), right?
23:20:41 <djahandarie> And that's why we get unique identity proofs / K
23:21:16 <Saizan> rosie: i'm not familiar with the functions you are using
23:23:28 <dolio> djahandarie: It's unclear whether that rule makes sense without the x = y rule as a prerequisite.
23:26:35 <dolio> Since p : Id A x y and r(x) : Id A x x.
23:29:32 <djahandarie> Right. But you don't need to explicitly state it as part of what's needed for ETT because you get it automatically from the x = y rule.
23:30:23 <djahandarie> Is there a nice rule that gives you J but doesn't give you K/UIP?
23:30:39 <dolio> Oh, you mean, once you have the x = y rule, you get UIP from equality elim? Yes.
23:30:46 <djahandarie> Yeah.
23:32:40 <djahandarie> If there is a nice rule, I imagine it's fairly relavent for the HTT stuff, since that's kind of what you want there. But I still don't really understand HTT in its entirety.
23:33:17 <ddarius> djahandarie: I don't think anyone understands HTT in its entirety.
23:33:47 <djahandarie> Maybe, but I definitely understand it less than a lot of other people.
23:37:17 <yitz> DMWIT: GLAD TO HEAR!
23:37:28 <SHACHAF> HI YITZ
23:37:31 <SHACHAF> JOIN THE CLUB
23:37:38 <Saizan> a nicer rule than giving a computational content to J?
23:37:42 <yitz> oh noes it's contagious
23:37:46 <SHACHAF> /nick YITZ
23:37:50 <yitz> better get out of here
23:37:54 <yitz> (bbl)
23:38:04 <Nevin> Hello
23:38:32 <dolio> djahandarie: One of the problems with ETT is that that rule is wrong for HTT.
23:38:42 <dolio> So if you want to support higher dimensions correctly, you need more rules.
23:38:42 <Nevin> May I ask if you know acid-state being used for large data set?
23:38:42 <djahandarie> Right.
23:39:15 <djahandarie> Saizan, I guess so.
23:40:15 <dolio> And if you want to do HTT, you need infinitely many rules.
23:40:17 <dolio> I believe.
23:40:33 <djahandarie> Infinitely many rules?
23:40:48 <dolio> Yes. One for each dimension.
23:42:02 <dolio> Whereas ITT just works, except they don't know how their extra homotopy rule should compute.
23:43:53 <yubiwasabi2> hi
23:45:17 <Saizan> how would the infinitely many rules version of HTT look like?
23:45:48 <pharaun> can i implement my own "records" or is this something done at a lower layer IE. i need to reach down to template haskell?
23:48:21 <ddarius> pharaun: Template Haskell is not a lower level.
23:48:43 <ddarius> pharaun: Haskell's record types are built in, but they are just mild sugar for functions and normal data types.
23:48:53 <ddarius> There are many "record systems" built in Haskell.
23:49:13 <pharaun> ddarius: ahh k alright thanks
23:50:08 * ddarius recommends "Lectures on n-Categories and Cohomology" "by" Baez and Shulman to djahandarie if he hasn't read through it already.
23:50:23 <djahandarie> dolio, I think the 'definition' of HTT I've seen is dependent sums, inductive families, a universe, univalance, and possibly higher inductive types.
23:50:43 <djahandarie> I haven't, and that definitely sounds like it's going to be an amazing read considering the authors.
23:51:33 <sheldonh> if i have a single .hs file with main that prints the result of a single function in that file, how can i profile it? the stuff at http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program is a bit heavyweight
23:51:52 <dolio> Saizan: If you look at Licata and Harper's 2DTT, it has rules that correspond to various stuff in 2 categories. They have to distinguish between functors, transformations, etc. So it'd be something like that, but without the directedness but with higher dimensional rules.
23:53:12 <ddarius> djahandarie: It's mostly incoherent but it has some very interesting ideas.
23:53:30 * ddarius hasn't made a water steak in a while.
23:53:55 * ddarius -still- hasn't read the directed type theory paper.
23:54:03 <ddarius> dolio: I'm assuming by now you have.  Was it any good?
23:54:36 <dolio> Harper seems to view the 2DTT stuff as an extension of ETT to the case where you want some non-sets, and he likes ETT. But it isn't going to work for full HTT.
23:54:41 <dolio> Have what?
23:55:05 <djahandarie> Either made a water steak or read the directed type theory paper.
23:55:21 <djahandarie> I'm assuming the latter.
23:56:36 <ddarius> dolio: Read the thesis on directed type theory.
23:57:37 <sheldonh> i've got a .prof file, but it seems to only profile IOs? how do i profile my own pure function? :)
23:57:56 <djahandarie> Gah, Freenode is lagging real bad for me right now.
23:58:50 <djahandarie> I guess that's a sign I should sleep and then finish all the homework I put off tomorrow. Night.
23:58:53 <dolio> Oh. Yes. It's good. There's still stuff in there I don't understand.
23:59:13 <johnw> is there any utility to auto-create an .hsc file from a C header?
23:59:39 <djahandarie> Did you read the 200+ page dissertation one or the shorter one?
23:59:58 <dolio> I've definitely read the shorter one. I've read parts of the dissertation.
