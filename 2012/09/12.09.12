00:03:05 <pikitgb> lambdabot Thanks :)
00:19:42 <proony_boon> Hello
00:19:58 <proony_boon> is there a built in method to shuffle a list of items?
00:20:44 <proony_boon> shuffle :: [a] -> [a]
00:20:47 <proony_boon> something like that?
00:21:02 <Jafet> That's not very useful, as it shuffles the input the same way every time.
00:21:49 <lightquake> there's System.Random.Shuffle
00:22:12 <lightquake> @hoogle shuffle
00:22:12 <lambdabot> package random-shuffle
00:23:38 <proony_boon> many thanks!
00:23:51 <shachaf> There's a binding to strfry.
00:24:01 <shachaf> @hackage acme-strfry
00:24:02 <lambdabot> http://hackage.haskell.org/package/acme-strfry
00:24:11 <shachaf> Not portable, though, and only works for ASCII strings.
00:25:13 <lightquake> haha
01:12:34 * hackagebot ClassLaws 0.3.0.2 - Stating and checking laws for type class methods  http://hackage.haskell.org/package/ClassLaws-0.3.0.2 (PatrikJansson)
01:28:09 <kanedank`> hey, I'm having a lot of trouble teaching myself haskell. I really haven't made a sincere effort to code something, primarily because I feel like I'm running into walls all the time with the sheer amount I don't know how to do. Should I persist in trying to program? Or just keep reading?
01:28:48 <osfameron> kanedank`: both?  start simple, with exercises from Learn You A Haskell ?
01:29:45 <Cale> kanedank`: also feel free to ask questions
01:29:59 <shachaf> kanedank`: Haskell might take more up-front learning than languages you're used to, particularly depending on the sort of thing you're trying to do.
01:31:50 <kanedank`> well I guess I'm trying to say, I know how to hit my code with a hammer until it compiles, but I don't really feel like I'm learning anything. It's not exactly becoming intuitive, or at least it doesn't feel like it.
01:32:09 <merijn> If I define a kind + some types (using DataKinds) how do I define values of those types?
01:32:29 <merijn> kanedank`: What are you reading and how far have you gotten reading it?
01:32:34 <Cale> kanedank`: How long have you been studying it? It was something like 2 months before I felt like I could start to really get things done in Haskell, and maybe about a year before I felt really comfortable. Mind you, that was back in 2001 or so, and I had a full course load.
01:32:38 <kanedank`> lyah + rwh
01:32:46 <Jafet> Sometimes academics do that
01:32:55 <Jafet> "We follow the types..."
01:32:58 <shachaf> merijn: The normal way?
01:33:06 <kanedank`> for rwh I'm reading the monads, using monads, and monad transformers chapters at least once per day for the last week
01:33:39 <kanedank`> only since the beginning of August
01:33:43 <merijn> shachaf: So "data Foo = Bar | Baz; data Bar = Xyzzy" will give "Xyzzy :: Bar" and "Bar :: Foo"?
01:33:56 <cbm80> um, is something borken with profiling in 7.6.1? +RTS -p doesn't seem to work anymore
01:34:41 <shachaf> merijn: data Bar = Xyzzy will give you "Xyzzy :: Bar" -- i.e., the value Xyzzy is of type Bar -- and "Xyzzy :: Bar" -- i.e., the type Xyzzy is of kind Bar.
01:34:49 <shachaf> You can see that using :t and :k in ghci.
01:34:57 <shachaf> It's a little confusing, perhaps. :-)
01:35:07 <merijn> shachaf: No, I got that
01:35:16 <shachaf> Oh.
01:35:22 <shachaf> So what's the question?
01:35:30 <merijn> But given a new Kind declaration plus its types, how do i create values of those types?
01:35:38 <kanedank`> I only really learned Java and Python in school, and neither very well. I really want to become a good programmer, and people seem to say that Haskell really helps.
01:35:45 <shachaf> merijn: Values have types of kind *
01:36:20 <merijn> shachaf: So the answer is you can't define values for your own type+kind combinations
01:36:31 <arbn> kanedank`: You might start by reading SICP, in my opinion. That will change your thinking more than just learning Haskell.
01:36:38 <shachaf> merijn: Well, I'm not sure what it would mean to do that.
01:37:03 <Cale> kanedank`: For what it's worth, I think monad transformers are somewhat overrated. They're really nice sometimes when you can spot a case where they'll help you write the sort of library you're after, but otherwise it's better not to even necessarily set out to write a monad in the first place. Design your library how you want it to be, and if there's a sensible definition for return and (>>=) then great, and if not, t
01:37:03 <Cale> hen at least you have the API which you really wanted :)
01:37:21 <kanedank`> arbn: well I know a bit of lisp. I have a copy of practical common lisp that's pretty dog eared now, although I'm prett sure I've forgotten most of it.
01:37:27 <merijn> shachaf: Well, in my earlier example I'd have create the value constructor Xyzzy, whose type is Bar, whose kind is Foo
01:37:50 <Cale> kanedank`: But that said, if there's something I can help explain, ask away :)
01:37:52 <shachaf> merijn: What would that mean?
01:38:26 <merijn> shachaf: I don't know :p
01:38:51 <kanedank`> Cale: thanks, I've found the people on this channel to be especially helpful
01:39:02 <shachaf> merijn: DataKinds aren't really meant to be used that way.
01:39:10 <merijn> shachaf: :(
01:39:14 <shachaf> They're meant to restrict places where you'd otherwise be using * for no good reason.
01:39:59 <shachaf> For example, in the good old days you might write "data Z; data S n" and then, in places that use type-level naturals, just use those two types.
01:40:12 <shachaf> (With kind *, which can also hold anything else.)
01:40:19 <shachaf> But now you can say data Nat = Z | S Nat, and then use the kind Nat.
01:40:33 <shachaf> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/promotion.html has an example.
01:40:38 <merijn> shachaf: Yeah, that much I got. I was just curious how far I could push that :p
01:40:40 <shachaf> In fact, exactly this example. :-)
01:40:53 <shachaf> merijn: Keep in mind that (->) :: * -> * -> *, for example.
01:40:58 <merijn> The answer is clearly, "not very far"
01:42:29 <merijn> kanedank`: tbh, if you find yourself continously rereading the monad and transformer chapter you might be better of playing with some simple toy examples of your own until it makes sense. There is only so much you can learn from reading about them without using/implementing them
01:43:05 <merijn> kanedank`: Defining your own list with associated monad instance (or your own monad instance for Maybe/Either) can be very educational
01:43:27 <shachaf> kanedank`: There's no need to hurry and read about monads, and especially not monad transformers.
01:43:38 <Hail_Spacecake> how do I perform the same IO action for a finite specificed number of times?
01:43:45 <shachaf> @ty replicateM_
01:43:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
01:44:27 <Cale> Or just replicateM if you want the results
01:44:32 <Cale> :t replicateM
01:44:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
01:44:44 <shachaf> Or replicate if you don't even want to run it
01:44:45 <merijn> Hail_Spacecake: See also Hoogle :)
01:44:47 <shachaf> @ty replicate
01:44:47 <lambdabot> forall a. Int -> a -> [a]
01:45:27 <randomclown> @pl \x -> zip (inits x) (tails x)
01:45:27 <lambdabot> liftM2 zip inits tails
01:45:29 <merijn> Hail_Spacecake: If you know the type of function you want it's quite easy to find usually
01:45:40 <Hail_Spacecake> actually, hm, it's not quite the same IO action I want to replicate
01:45:49 <Hail_Spacecake> I want to hGetLine, bind that to a variable
01:45:57 <Hail_Spacecake> and then putStrLn that variable
01:45:58 <merijn> Hail_Spacecake: And then...
01:46:00 <Hail_Spacecake> a finite number of times
01:46:06 <merijn> Hail_Spacecake: Easy
01:46:26 <shachaf> replicateM sounds like what you want.
01:46:28 <Hail_Spacecake> so, I think I want to chain IO actions?
01:46:29 <merijn> Hail_Spacecake: "replicateM 5 (hGetLine hnd >>= putStrLn)"
01:46:35 <Hail_Spacecake> ah, yeah, >>=
01:46:37 <shachaf> replicateM 5 (getLine >>+ putStrLn)
01:46:38 <Hail_Spacecake> which I don't entirely understand
01:46:53 <Hail_Spacecake> or rather I don't understand how >>= relates to the do-block syntax x <- hGetLine handle
01:46:53 <randomclown> >>+
01:47:00 <Hail_Spacecake> >>= or >>+ ?
01:47:04 <randomclown> haha
01:47:07 <randomclown> >>= of course
01:47:11 <merijn> Hail_Spacecake: Or even "replicateM 5 (do { line <- hGetLine hnd; putStrLn line })"
01:47:20 <Hail_Spacecake> ah
01:47:38 <merijn> @undo do { line <- hGetLine hnd; putStrLn line }
01:47:39 <lambdabot> hGetLine hnd >>= \ line -> putStrLn line
01:47:54 <merijn> Hail_Spacecake: undo is exactly what happens inside the compiler
01:48:22 <merijn> @undo do { getLine; getLine }
01:48:23 <lambdabot> getLine >> getLine
01:48:29 <shachaf> @yarr
01:48:29 <lambdabot> Get out o' me way, yeh landlubber
01:49:21 <Hail_Spacecake> ah, okay
01:49:22 <Hail_Spacecake> thanks
01:49:40 <merijn> @undo do { line <- hGetLine hnd; putStrLn line; putStrLn line; line <- getLine; print line } --or a more elaborate example
01:49:40 <lambdabot> hGetLine hnd >>= \ line -> putStrLn line >> putStrLn line >> getLine >>= \ line -> print line
01:50:17 <merijn> Which should also explain how do notation allows you to "overwrite" a "variable" even though everything is immutable
01:50:46 <shachaf> It doesn't. :-(
01:50:56 <shachaf> But this has nothing to do with do-notation. You can do it with "let" just as much.
01:51:28 <merijn> shachaf: Sure it does, the explanation is the scoping of the lambda's names...
01:51:55 <shachaf> > let x = 5 in let x = 6 in x
01:51:55 <lambdabot>   6
01:52:11 <merijn> shachaf: That isn't overwriting, that's just lexical scoping
01:52:29 <shachaf> "do" isn't overwriting either.
01:52:36 <merijn> Which exists in every sane language on earth
01:52:42 <merijn> shachaf: That was my point...
01:52:59 <johnw> touche!
01:53:00 <merijn> Hence why overwriting and variable were in quotes :p
01:53:20 <shachaf> Why bring up a misconception that someone doesn't even have just to point out that it's wrong?
01:53:39 <shachaf> do { x <- blah; replicateM_ 5 (do { x <- blahum; ... }); ... }
01:53:45 <Hail_Spacecake> okay so the thing I was trying to do works
01:53:59 <Hail_Spacecake> I guess now my question is whether or not it's a good idea
01:54:01 <Hail_Spacecake> I suspect not
01:54:07 <Hail_Spacecake> I'm still following http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
01:54:18 <Hail_Spacecake> and on one irc server that I happen to frequent, the code as given doesn't work
01:54:44 <merijn> IRC is (afaik) a notoriously underspecified and ad hoc protocol :p
01:54:48 <Hail_Spacecake> becuase it writes the USER NICK and JOIN lines before listening
01:55:12 <Hail_Spacecake> so I basically just had the program sit there and listen for like 10 lines
01:55:16 <Hail_Spacecake> and *then* send those messages
01:55:19 <Hail_Spacecake> and then the listen-loop
01:55:22 <Hail_Spacecake> and that seemed to work
01:55:25 <Hail_Spacecake> but it seems hackish
01:57:12 <Cale> Hail_Spacecake: might be interesting to try to see what the smallest number of lines which works is
01:57:17 <merijn> I suspect that might be more of a quirk of the server than of the bot code?
01:57:33 <Hail_Spacecake> yeah, it is
01:57:37 <Hail_Spacecake> works fine as given on freenode
02:00:36 <merijn> shachaf: hmm, I guess I could just write type funs to convert from my DataKinds types to types of kind *...
02:01:21 <shachaf> merijn: Oh, you're actually trying to do something in particular?
02:01:26 <shachaf> You should probably mention that thing. :-)
02:02:20 <merijn> shachaf: I will, as soon as I figure out what it is :p
02:03:08 <merijn> shachaf: I have a terribly horrible typeclass based type recursion that I'm trying to replace with a nicer TypeFamilies version and maybe some extra voodoo :p
02:04:11 <merijn> shachaf: But, you know: http://quicklol.com/wp-content/uploads/2012/03/dog-on-computer-no-idea.jpg
02:04:36 <merijn> It works, but don't ask how :p
02:05:40 <timthelion> merijn: like me when end up returning a tuple onion :D
02:08:05 <merijn> Can I have class contraints on type family instances?
02:08:58 <merijn> "type family Foo :: * -> *; type instance Bar a => Foo a = Something"
02:11:32 <merijn> I guess I need to define it as a classbound type family in that scenario...
02:12:36 * hackagebot explicit-exception 0.1.7.1 - Exceptions which are explicit in the type signature.  http://hackage.haskell.org/package/explicit-exception-0.1.7.1 (HenningThielemann)
02:24:08 <johnw> On http://www.haskell.org/haskellwiki/Exception it says "Haskell solves the problem a diplomatic way: Functions return error codes, but the handling of error codes does not uglify the calling code.".  I feel as though the author didn't read the code on that webpage
02:25:36 <timthelion> > case error "foo" of _ -> "bar" -- So errors CAN be caught in pure code. It's just exceptions that can't...
02:25:37 <lambdabot>   "bar"
02:26:12 <adnam> :O did not know that
02:26:26 <shachaf> timthelion: What?
02:27:07 <shachaf> johnw: Which code are you talking about?
02:27:07 <timthelion> johnw: which code is ugly to your tastes?
02:27:19 <adnam> oh wait error is never forced there timthelion?
02:27:27 <shachaf> johnw: I think the Haskell solution to this problem is really nifty and something that no other language has tried to do.
02:27:37 <shachaf> Admittedly it doesn't work quite as nicely as you'd hope, in practice.
02:27:40 <johnw> i have to change my code to either use case everywhere, or change everything to use the applicative to propagate the exception
02:27:48 <johnw> how that doesn't count as uglification, I'm not sure
02:27:57 <shachaf> johnw: Yes, or Monad.
02:28:00 <johnw> yeah
02:28:11 <johnw> that's not really acceptable in my opinion
02:28:19 <shachaf> The point is that you can have code that looks like do { x <- blah; y <- blam; ... }
02:28:26 <johnw> monadifying everything just to allow exceptions to occur
02:28:33 <shachaf> blah and blam return error codes, but they *also* throw exceptions, within that block.
02:28:45 <johnw> my complaint is his statement "without uglifying the calling code", when that's exactly what happens
02:28:46 <shachaf> That's exactly what monads are for!
02:28:49 <shachaf> Modeling effects.
02:28:53 <johnw> yeah
02:29:02 <johnw> that is a point
02:29:04 <shachaf> Eh. They could've been more precise than "uglifying".
02:29:23 <shachaf> The point is that you have both error codes *and* exceptions, in the same function, in a naturalish way.
02:29:38 <shachaf> Alternatively, something that automatically propagates error codes exception-style.
02:30:36 <shachaf> You can call it uglifying in sense.
02:30:46 <johnw> it's also not something you can do easily after the fact
02:30:52 <shachaf> This is the sense that you can't say f(g(h(x)), where h() can throw an exception.
02:31:01 <johnw> if you've already written 20 functions and then realize you want an exceptions to be able to propagate up from some bottom layer
02:31:14 <johnw> case in point, the fact that c2hsc is entirely in a monad, and how ugly that made a lot of the code
02:31:22 <shachaf> Indeed.
02:31:29 <shachaf> Well, I have other complaints about c2hsc code. :-)
02:31:42 <johnw> omg, was that a smiley?
02:31:47 <johnw> mixed with a complaint?
02:31:47 <shachaf> The code path is very convoluted and a lot of things are monadic that don't really need to be.
02:31:51 <johnw> shachaf, careful
02:32:06 <shachaf> ?
02:32:26 <merijn> I can't enforce that the t is a Pattern in the Cons constructor of "data Pattern h t where Nil :: Pattern () (); Cons :: h -> t -> Pattern h t" without a class somewhere, right?
02:32:26 <shachaf> We were just talking about this yesterday in a bit more depth.
02:32:36 <merijn> (or maybe a data family)
02:32:49 <johnw> i mean, be careful, you're using a smiley where ordinarily there'd be a frown
02:32:59 <shachaf> That's definitely not a frown.
02:33:01 <johnw> c2hsc will win no prizes
02:33:23 <shachaf> The smiley means "I'm saying this in a cheerful, friendly, light-hearted way; don't take it as an insult, because it's not".
02:33:34 <johnw> I know
02:33:38 * merijn doesn't care, c2hsc is working just fine for my trivial usecase now :)
02:33:57 <johnw> I just don't usually experience you being cheerful, friendly and lighthearted when I grope to understand Haskell
02:34:06 <shachaf> Huh?
02:34:13 * shachaf is cheerful, friendly and lighthearted most of the time.
02:34:21 <johnw> you may not realize that many of your comments have been demoralizing
02:34:30 <shachaf> Except when I'm in #haskell, I guess.
02:34:31 <merijn> shachaf: You wanted a concrete example, right? There you go, but without any DataKinds or TypeFamilies remaining in it :p
02:34:37 <johnw> I'm happy to hear if that is not intended
02:35:24 <shachaf> merijn: Nil's t is certainly not a Pattern. :-)
02:35:48 <merijn> johnw: Realise that most people in here aren't trying to be mean spirited when they mention about 20 things you could improve. It's just hard to get people from "just grasping haskell" to "writing idiomatic haskell" without doing that
02:35:51 <shachaf> Anyway I'm not sure what that's trying to accomplish, so I don't know.
02:36:38 <shachaf> johnw: I wouldn't even say things like "I have other complaints about [your] code" if it wasn't a thing that we already talked about yesterday (and which you agreed with, more or less).
02:37:06 <johnw> merijn: I meant more how when I say something stupid or not quite correct, I'll often get a frowny face without any explanation of what I said wrong, as if I should just know this stuff intuitively and I'm being slow
02:37:12 <johnw> there, that's off my chest
02:37:14 <shachaf> Anyway arguing with you about how I come across to you is silly.
02:37:21 <johnw> shachaf: I actually welcome your critique of my code
02:37:27 <shachaf> It''s true that I do that sometimes.
02:38:01 <merijn> shachaf: Well, I had this, but I wanted to do it more prettily, but I guess I failed: "data Nil = Nil; data Cons h t = Cons h t; class Pattern a; instance Pattern Nil; instance Pattern t => Pattern (Cons h t)"
02:38:04 <shachaf> It's probably more "I've said this thing in #haskell many times and it's tiring to say it again".
02:38:11 <johnw> your comments on c2hsc are helping me both improve and learn.  A criticism that say, "You could have done THIS" is infinitely better than just, "You shouldn't have done THAT"
02:38:30 <shachaf> merijn: Ah, something HListy?
02:38:46 <shachaf> johnw: Those comments are often hard to give without context.
02:39:02 <johnw> true
02:39:09 <johnw> anyone, thanks for talking with me about it
02:39:15 <shachaf> It's easy to say "you shouldn't use length/fromJust/whatever" when I see someone asking a question that uses those; it's harder to say what they should be doing instead.
02:39:15 <johnw> it was bothering me a little
02:39:17 <merijn> shachaf: Actually, I guess it was "instance (Foo h, Pattern t) => Pattern (Cons h t)", but due to the open world the compiler can't infer the "Foo h" constraint when using Pattern somewhere
02:39:29 <shachaf> Often the answer is "approach the problem in a completely different way". :-)
02:40:22 <merijn> shachaf: I was hoping the Constraint on Cons would let me infer it (which it will) I just can't enforce the constraint on t anymore, now xD
02:40:38 <johnw> merijn: do you know how to deal with functions taking varargs in Bindings-DSL?
02:40:51 <merijn> johnw: FFI doesn't support vararg functions
02:40:56 <shachaf> Blugh, binding to varargs.
02:40:58 <johnw> ah, that's good to know
02:40:59 <merijn> johnw: So the answer is "you don't"
02:41:04 <shachaf> Yes, it's a mess.
02:41:14 <johnw> c2hsc should then not generates #ccalls for those at all
02:41:38 <shachaf> johnw: Sometimes the way to deal with varargs is a C wrapper that turns them into something else.
02:41:48 <johnw> that's a good approach
02:41:50 <shachaf> But I suspect that can't be autogenerated in general.
02:41:58 <shachaf> merijn: It sounds like you're doing something vaguely like HList, but I'm not really sure.
02:42:01 <johnw> accept a list in the place  of the varargs position
02:42:11 <johnw> I could auto-generate an inline...
02:42:13 <shachaf> johnw: Yes, except types.
02:42:21 <johnw> oh, that's a good point
02:42:34 <merijn> shachaf: Yeah, a little
02:43:14 <merijn> Why can't I have class constraints on type instances/data families? :(
02:43:14 <shachaf> johnw: Types are what makes FFIing to varargs so hard.
02:43:24 <shachaf> I mean, have you *seen* the amd64 C varargs ABI?
02:43:46 <shachaf> @google nelhage va_arg
02:43:46 <lambdabot> http://blog.nelhage.com/2010/10/amd64-and-va_arg/
02:43:46 <lambdabot> Title: Made of Bugs » amd64 and va_arg
02:44:29 <johnw> lol
02:44:43 <johnw> tomorrow I'll be looking at varargs in LLVM
02:44:44 <shachaf> merijn: Did you see the HList example in the GHC manual?
02:44:46 <johnw> expecting loads o' fun
02:44:54 <shachaf> data HList :: [*] -> * where { HNil :: HList '[]; HCons :: a -> HList t -> HList (a ': t ) }
02:45:29 <shachaf> HCons 'a' (HCons True (HCons "hello" HNil)) :: HList [Char,Bool,String]
02:45:45 <shachaf> Isn't that nice? Just syntactically, I mean. :-)
02:45:46 <merijn> shachaf: I don't think so?
02:46:08 <merijn> shachaf: Does that work in 7.4?
02:46:11 <shachaf> Yes.
02:46:22 <shachaf> That's straight from the 7.4 manual: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/kind-polymorphism-and-promotion.html
02:46:40 <johnw> merijn: found another c2hsc bug
02:46:46 <merijn> johnw: Oh?
02:46:52 <johnw> unnamed enums emit a "#integral_t" with no type name
02:47:25 <merijn> shachaf: I'll look into that
02:47:37 <johnw> and bit fields don't work
02:47:45 <benmachine> shachaf: I find it weird that the 'name stuff is used in this, isn't it also used in template haskell?
02:47:52 <shachaf> merijn: I don't know what Foo is in your example.
02:48:01 <shachaf> benmachine: Yes.
02:48:07 <shachaf> But that's on a different level, I think?
02:48:17 <benmachine> I'd... imagine so
02:48:19 <shachaf> '[] is a value; '[] is a type.
02:48:21 <merijn> shachaf: Is there a quick ref/link site for GHC extensions? Right now I keep Googling "haskell DataKinds", "haskell GADTs", etc.
02:48:29 <shachaf> merijn: That's how I do it...
02:48:32 <johnw> merijn: can bit fields even be represented?
02:48:40 <johnw> I'm getting: error: cannot take address of bit-field ‘local’
02:48:45 <johnw> from: #field local , CInt
02:48:50 <johnw> where: int local:1;
02:48:51 <benmachine> merijn: the GHC user's guide is usually the first place I look
02:48:52 <merijn> johnw: I don't think so?
02:48:58 <ocharles> shachaf: shame you can't actually use that HList to do much without OverlappingInstances
02:49:00 <shachaf> merijn: Sometimes I change the URL to "latest", or look at the release notes, or something.
02:49:03 <johnw> i mean, that's a typical C "bool"
02:49:04 <merijn> benmachine: Yeah, but I do that via Google :p
02:49:14 <ocharles> ( http://stackoverflow.com/questions/12124584/is-it-possible-to-remove-overlappinginstances-for-this-datakinds-backed-heteroge )
02:49:18 <shachaf> Oh, it's ocharles.
02:49:24 <ocharles> a wild ocharles appears
02:49:26 <shachaf> Which SoC are you doing?
02:49:35 <ocharles> Which org?
02:49:37 <shachaf> Yes.
02:49:41 <ocharles> MusicBrainz
02:49:46 <ocharles> (metabrainz foundation)
02:49:46 <shachaf> Aha.
02:49:56 <shachaf> Well, see you in October, I guess. :-)
02:50:01 <ocharles> yep!
02:50:08 <ocharles> have you been before?
02:50:17 <shachaf> I'm not a mentor there or anything.
02:50:23 <shachaf> I've been at bahaskell before, though.
02:50:23 <ocharles> ah
02:50:34 <ocharles> gotcha
02:50:34 <shachaf> I've also been at the mentor night-before thing, but that was just meeting edwardk.
02:51:10 <merijn> ocharles: Why do you need overlappinginstances to do anything useful with that HList?
02:51:34 <ocharles> merijn: see the 'HasField' class in that stack overflow post
02:52:00 <ocharles> (x ': xs) and (a ': xs) overlap, when you're trying to recurse on the hlist
02:52:49 <shachaf> Is this relevant to what merijn is trying to do with the list?
02:52:56 <ocharles> no idea, I only just joined
02:52:57 * shachaf doesn't actually know what merijn is trying to do.
02:53:02 <shachaf> So I have no idea either. :-)
02:53:27 <ocharles> just saying that I was bitten by how promising data kinds HLists looked, and then realised I'd still have to use OverlappingInstances to do what I want with it (type indexed records)
02:57:37 * hackagebot hscurses 1.4.1.2 - NCurses bindings for Haskell  http://hackage.haskell.org/package/hscurses-1.4.1.2 (StefanWehr)
02:57:39 * hackagebot hlibgit2 0.4.0 - Low-level bindings to libgit2.  http://hackage.haskell.org/package/hlibgit2-0.4.0 (JohnWiegley)
03:07:29 <solomatov> Hi! I want to use some GUI library for haskell on OSX. Unfortunately, I use 10.8 which works bad with gtkhs and wx doesn't work because of quicktime dependency. Can anyone help?
03:10:21 <Guest15954> I'm learning haskell as my first language so I apologize if my question is outragously simple, but I'm trying to do project euler problem 1, list all natural numbers that are multiples of 3 and 5, under 1000.  my solution was: sum [3,6..999] + sum [5,10..999] however that doesn't return the right answer, but to me it looks like it should do exactly what the problem asks, can anyone explain what goes wrong when trying to solve the p
03:11:06 <bartavelle> 15 will be in both lists
03:11:19 <Guest15954> aha! thanks!
03:11:38 <astry> why would you use "sum"?
03:11:47 <benmachine> Guest15954: that question is so simple it makes me FURIOUS
03:11:48 <benmachine> (not rly)
03:11:58 <Guest15954> haha :D
03:12:04 <bartavelle> astry: the answer is often the sum of what you need to find in euler
03:12:22 <astry> it says "list all natural numbers"
03:12:22 <shachaf> Guest15954: Project Euler is probably not that great a way to learn Haskell and maybe a good way of learning some mathematics.
03:12:30 <bartavelle> bad specs
03:12:36 <benmachine> shachaf: I don't think it's bad
03:12:52 <astry> well let's help him list all natural numbers that divide by 3 and 5
03:12:58 <astry> because that's the actuall issue
03:13:04 <astry> how would you do that Guest15954 ?
03:13:20 <benmachine> astry's got a point, if you just did that and then summed those it would work better
03:13:23 <Guest15954> hmm I'm thinking :)
03:14:06 <bartavelle> when you need only certain values from a list, you often want to use "filter" or guards in a list comprehension
03:14:15 <johnw> night all
03:14:16 <bartavelle> filter is probably easier to understand
03:14:41 <benmachine> bartavelle: I'm not sure which is easier to understand
03:14:53 <bartavelle> filter was to me
03:15:17 <bartavelle> the fact list comprehensions were just sugar for the list monad was understood far later to me
03:15:51 <shachaf> @quote monochrom euler
03:15:51 <lambdabot> No quotes match. Where did you learn to type?
03:16:15 <Guest15954> Can you filter a list, with another list?
03:17:12 <astry> no
03:17:18 <bartavelle> don't you mean you want to intersect sets then ?
03:17:21 <astry> you filter by predicates
03:17:31 <astry> @type filter
03:17:32 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
03:17:33 <bartavelle> because filtering a list with another list doesn't make much sense
03:17:46 <astry> you take a predicate, and a list to filter by that predicate, and get another list
03:17:59 <astry> a predicate is a function that takes an element of a list, and returns a boolean value
03:18:18 <astry> the boolean value is either True or False, and says if the list element should be included in the output list or not
03:18:24 <randomclown> Can we use >>= to compose functions instead of .?
03:18:34 <Guest15954> ah yes, I hadn't thought to use elem and boolean
03:18:44 <bartavelle> randomclown : >>= is monad binding
03:18:51 <randomclown> monad of (->)
03:18:58 <astry> randomclown: >>= can be seen as a kind of function composition, but it's not the same as ..
03:19:01 <shachaf> randomclown: Look at the type and figure it out for yourself!
03:19:10 <shachaf> (>>=) :: m a -> (a -> m b) -> m b
03:19:18 <shachaf> (>>=) :: (r -> a) -> (a -> r -> b) -> r -> b
03:19:26 <shachaf> ...I guess I just stopped you from figuring it out for yourself. :-(
03:19:27 <shachaf> Sorry.
03:20:12 <randomclown> I'll take that as a yes
03:20:54 <shachaf> It's definitely not a yes.
03:20:59 <shachaf> It's not a no either.
03:21:14 <randomclown> depends on what functions
03:23:36 <merijn> btw, is there a list of unsafe/bad extensions somewhere?
03:23:43 <qnikst> hello, it's possible to add a build-depends that depends on package version i.e. smth like (foo>=1.3 && bar) || (foo < 1.3 && baz)?
03:24:02 <qnikst> i.e. is I have foo>=1.3 I should depend on bar otherwise on baz
03:24:47 <astry> Guest15954: what have you got?
03:25:28 <Guest15954> a head full of thoughts!
03:25:47 <astry> write down some code and put it into ghci
03:31:20 <fmap> merijn: did you check http://stackoverflow.com/questions/10830757/is-there-a-list-of-ghc-extensions-that-are-considered-safe and http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid ?
03:33:19 <merijn> fmap: Thanks!
03:33:46 <merijn> hmm
03:33:52 <merijn> This doesn't parse right "type family BoxFun :: [*] -> *
03:34:06 <merijn> It complains BoxFun expects 0 argument when I try to declare an instance for it
03:39:39 <merijn> No suggestions?
03:40:08 <Ferdirand> @. hoogle type head
03:40:09 <lambdabot> Parse error:
03:40:09 <lambdabot>   forall a. [a] -> a
03:40:09 <lambdabot>  
03:40:10 <Saizan> type family BoxFun (x :: [*]) :: *
03:40:14 <Saizan> merijn: ^^^
03:40:22 <Ferdirand> that is somewhat disappointing
03:41:09 <merijn> Saizan: \o/
03:41:33 <merijn> Saizan: Any reason why "type family BoxFun :: * -> * -> *" parses right but this doesn't?
03:42:16 <Saizan> merijn: afaiu that one should have 0 indexes too
03:42:38 * hackagebot xmlgen 0.4.0.3 - Fast XML generation library  http://hackage.haskell.org/package/xmlgen-0.4.0.3 (StefanWehr)
03:43:21 <randomclown> @pl \x y -> f1 x $ f2 x $ f3 x y
03:43:21 <lambdabot> liftM2 (.) f1 (liftM2 (.) f2 f3)
03:43:54 <merijn> Saizan: Oh, you're right. I misunderstood the docs
03:47:21 <merijn> ok, I have concluded that TypeFamilies are awesome
03:50:16 <XexonixXexillion> How expensive are comparisons on Text compared to String?
03:54:18 <RichyB> XexonixXexillion: you should expect Text comparisons to be a faster than String comparisons by a large constant factor unless you were making *really* clever use of String's laziness; String is a singly-linked list of Char values, whereas Text is implemented with dense arrays of UTF-16 characters.
03:56:50 <XexonixXexillion> RichyB: Let's assume I had a Map String a and a Map Text a. Would it make a noticable difference to lookup times if the map had ~500 items and the keys were ~8 characters each?
03:57:54 <RichyB> Probably. Whether it's noticable or not depends on how often you make those lookups, but it should very likely be measurable.
03:58:22 <RichyB> Also on how long the common prefixes of different strings in the Map are.
03:58:59 <XexonixXexillion> Actually, perhaps prefix trees would be better for this
03:59:18 <RichyB> e.g. (cmp "aaaaaaaaaaaaaaaaaaaaaaaaa" "bbbbbbbbbbbbbbbbbbbbbbbb") won't take very long to return regardless of whether you use Text or Char.
03:59:42 <merijn> Saizan: Is it by any change possible to put constraints on type families/instances for type families?
03:59:43 <kallisti> XexonixXexillion: comparisons of Texts will be faster than Strings. Texts are contiguous arrays (or ropes, for the lazy variant) whereas Strings are linked lists.
03:59:47 <merijn> s/change/chance
03:59:56 <RichyB> The longer the common prefixes are, the more you're going to gain by using a packed data type that makes comparing individual characters in them cache-friendly.
04:00:05 <XexonixXexillion> I'm writing an interpreter for a smalltalk-like language, and working out how best for an object to lookup how to respond to a message
04:00:36 <kallisti> XexonixXexillion: assuming your language uses Unicode, then Text is likely a good choice.
04:00:48 <kallisti> if you don't wish to make any assumptions about encoding, you could use ByteString.
04:01:51 <kallisti> (but you probably want to make assumptions about encoding)
04:02:00 <kallisti> (or maybe not)
04:05:31 <XexonixXexillion> If 95% of characters are in ascii, and 90% of time is going to be spent looking these things up, should I be using UTF-8 as opposed to UTF-16?
04:06:39 <Jafet> Pft, just use ascii then.
04:07:39 <merijn> ...
04:07:42 <kallisti> XexonixXexillion: this channel has a tendency to erupt into discussions of character encodings at a rapid pace. You have been warned.
04:07:46 <merijn> ghci just reported the following error:
04:07:49 <merijn> "My brain just exploded"
04:08:21 <kallisti> merijn: Could not reproduce. Can I borrow a shotgun?
04:08:26 <RichyB> XexonixXexillion: I would be willing to bet that ByteStrings containing UTF-8 encoded text would be fine/sensible.
04:09:12 <RichyB> Wasn't someone talking about reimplementing Data.Text with UTF-8 as the encoding in the bytearrays instead of UTF-16, at some arbitrary point in the past?
04:09:23 <kallisti> XexonixXexillion: you'll likely get some meager efficiency out of using ByteString over Text. It also allows you to essentially be indifferent to character sets to some degree, if that's what you want.
04:10:18 <kallisti> RichyB: sounds familiar.
04:10:24 <merijn> kallisti: GHCI gets confused when you try to pattern match constructors from a file with GADTs when you start it without -XGADTs apparently :p
04:10:45 <Jafet> What does Text use?
04:10:59 <merijn> Also, I'm starting to feel like edwardk... {-# LANGUAGE GADTs, DataKinds, TypeOperators, TypeFamilies #-}
04:11:16 <merijn> I guess I should be glad there's no OverlappingInstances/UndecidableInstances yet xD
04:11:58 <kallisti> merijn: you can't join the Church unless your instances are undecidable.
04:12:04 <kallisti> sorry.
04:12:41 <Jafet> You can still join the Church of Church
04:14:57 <hpaste> merijn pasted “Constraints for type families?” at http://hpaste.org/74621
04:15:37 <merijn> Right now I have the double type list in Pattern because I can't enforce the RecEntry constraint in the BoxFun typeclass, is there a way to avoid this?
04:16:13 <kallisti> where's a good summary of changes in 7.6?
04:16:43 <mikeplus64> Jafet: i think that text uses utf-16 internally
04:19:34 <Jafet> Yeah, that's pretty dumb
04:21:53 <XexonixXexillion> I just found Data.Trie, that looks like it's sufficient for my purposes, and saves me writing a lot of code
04:22:13 <kallisti> hurray
04:23:52 <Botje> every time you use a trie, $deity spawns a kitten
04:30:59 <merijn> Is there a typeclass that provides a "toInt" function? (Specifically I have a bunch of Int newtypes that I want to convert back)
04:31:38 <Jafet> fromEnum
04:31:58 <merijn> Jafet: Thanks
04:32:39 <Jafet> In which case you can derive Enum, and throw away a little type checking
04:33:48 <merijn> Actually...
04:34:14 <merijn> I just realised I can maybe avoid the entire issue by using a GADT instead of multiple newtypes...
04:34:40 <merijn> Which is probably nicer anyway
04:35:50 <benmachine> yay GADTs
04:36:11 <benmachine> have you considered just making your types integers instead? :P
04:36:59 <merijn> benmachine: I have three different types of entries in a record, all indexed by Int's, but giving different return values
04:37:52 <merijn> So I used a typeclass + associated type family and then created instances for each type of entry by creating a newtype around Int
04:38:24 <merijn> But I just realised that "data Entry a where Tag :: Int -> Entry Foo; Field :: Int -> Entry Bar" would let me do it all in one go :)
04:38:43 <merijn> Because I can define "getEntry :: Entry a -> Record -> a" :)
04:38:52 <merijn> No typeclasses or newtype necessary
05:02:38 <frerich> Two questions to get my nomenclature straight: in layman's terms, an algebraic data type (in Haskell) is something like "data T = ...", and a generalized algebraic data type would be "data T a = ..." - or another way to put it - a generalized algebraic data type has a type constructor with a kind unlike "*" but something which involves "->". Does that sound correct? The second question: would (in Haskell) any
05:02:38 <frerich>  ADT be a GADT or is it the other way round - or are the two sets disjoint?
05:03:08 <frerich> I don't want to start a fruitless discussion, but I always got confused that sometimes people use ADT and sometimes GADT...
05:04:57 <benmachine> frerich: that is not correct
05:05:08 <benmachine> both of what you describe are ADTs
05:05:27 <frerich> Ok so every GADT is an ADT - but not the other way round?
05:05:33 <benmachine> no
05:05:41 <benmachine> G means "Generalised"
05:06:00 <bitonic> every ADT is a GADT, but not the other way around :P
05:06:22 <benmachine> basically, a GADT is allowed to have more exotic type signatures for its constructors
05:06:37 <arbn> frerich: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
05:06:57 <benmachine> an ADT like data T a = ... can have 'a' being anything, but a GADT can restrict what things a can be
05:07:09 <frerich> Aaaah, interesting!
05:07:22 <frerich> So it doesn't have anything to do with the 'a' parameter per se but rather about being able to restrict what 'a' is.
05:07:42 <benmachine> frerich: well, not just a
05:07:52 <benmachine> frerich: read the user's guide page, it's more informed than me :P
05:08:08 <frerich> Yeah I'm currently doing that
05:08:35 <benmachine> you can usually recognise GADTs because they give those explicit constructor signatures
05:08:42 <frerich> Actually, the very first example in that page already raised my eyebrows, it didn't occur to me that you could have constructors defined like 'data T where...'. I thought it's always "data T = ...'
05:08:50 <frerich> but maybe that's a distinguishing feature.
05:08:58 <benmachine> frerich: yeah, that syntax was invented for GADTs
05:09:07 <frerich> Ahaaa...
05:09:15 <frerich> Ok *that* helps alot already!
05:09:22 <frerich> Thanks for clearing this up for me :-)
05:09:27 <benmachine> yeah, sorry, should've mentioned that earlier :P
05:09:49 <benmachine> you *can* define normal ADTs with that syntax if you enable the GADTSyntax (or GADTs) extension
05:09:58 <benmachine> but it almost always means "here comes a GADT"
05:10:49 <frerich> Actually, I think it's really pretty. I think I should reconsider some code I wrote, I believe the fact that it allows you to have more "powerful" pattern matching would simplify some stuff I did.
05:11:24 * benmachine lunchtime
05:13:00 <merijn> frerich: GADT in practical terms means you can put (restricting) type signatures on your constructors
05:14:39 <hpaste> merijn pasted “GADT example” at http://hpaste.org/74628
05:15:17 <merijn> frerich: See the example I just posted, it shows a normal ADT, the equivalent in GADT notation and then the GADT I based it on
05:16:15 <merijn> frerich: In that example I use the GADT to smuggle in a phantom type that I need later
05:17:08 <frerich> merijn: Yeah, it appears to me that the fact that the return type is not always "RecEntry a" is the key feature - and you can exploit this when pattern matching, so you can have 'f (Tag x) = <x is an Int here>', right?
05:17:20 <merijn> frerich: Yes
05:17:35 <frerich> merijn: The 'phantom type' would be "CInt" or "Ref" in your example?
05:17:41 <merijn> frerich: Yes
05:18:02 <merijn> Phantom type is the usual name for a type that appears in a type but has no actual value associated with it
05:18:12 <merijn> In this case, there is no actual CInt or Ref inside my RecEntry
05:18:46 <frerich> Hm, I see. And you didn't want to use "RecEntry Int" in all three cases because that means "Field" and the other two constructors would yield values of the same type, which you don't want for later pattern matching?
05:19:07 <merijn> frerich: It is just that I can now write "lookup :: Record -> RecEntry a -> Maybe a" and have "lookup _ (Tag i)" return CInt, while "lookup _ (Field i)" returns Ref
05:19:20 <merijn> frerich: Without the phantom type you couldn't write that function
05:19:59 <frerich> aaah
05:20:00 <frerich> I see
05:20:05 <merijn> Because "lookup :: Record -> RecEntry -> Maybe ??"
05:20:36 <merijn> And of course "data RecEntry a = Tag a | BTag a | Field a" doesn't let me restrict the type correctly either
05:20:36 <fmap> merijn: but you need to convert i from Int to CInt or Ref inside lookup, right?
05:20:47 <frerich> but, maybe I'm being stupid here - couldn't you avoid the phantom type but rather have "lookup :: Record -> RecEntry a -> Maybe b"?
05:21:14 <merijn> fmap: Yes, in my case Record has 3 IntMap's inside, IntMap CInt, IntMap CInt and IntMap Ref
05:21:23 <frerich> Or does it need to be the same "b" for all constructors then?
05:21:33 <merijn> fmap: Which IntMap I look up from I determine on the constructor
05:21:45 <merijn> frerich: In that signature my function would need to be able to return *any* b
05:22:05 <merijn> frerich: Because "Maybe b" unifies with "Maybe Char"
05:22:09 <merijn> (for example)
05:22:19 <frerich> Ah, that's the implicit "forall b." part, I guess...
05:22:29 <ski> yes
05:22:32 <merijn> frerich: Yes, you can only return undefined or similar there
05:23:03 <merijn> frerich: Whereas the GADT guarantees to the typechecker that the "RecEntry a" will always be Ref for the constructor Field
05:23:15 <XexonixXexillion> :t (fromJust . cast)
05:23:16 <lambdabot> forall a a1. (Typeable a1, Typeable a) => a1 -> a
05:23:17 <frerich> Hm, and because you used "RecEntry a -> Maybe a" you only need to be able to work with all 'a's supported by RecEntry, which is just CInt and Ref...
05:23:20 <merijn> frerich: Which means my lookup will typecheck when returning different results for different constructors
05:23:50 <merijn> frerich: Even more restricted, it only needs to support Ref for the Field constructor :)
05:23:53 <frerich> I think I slowly understand the trick here...
05:24:14 <frerich> I'll probably have forgotten about it by tomorrow, but it's good to have it understood just once, will make learning it a second time easier :)
05:24:20 <frerich> merijn: Thanks for your very nice explanations!
05:24:23 <merijn> frerich: Because the typechecker can verify the there are no other constructors that can return "RecEntry Ref"
05:24:56 <merijn> frerich: The wikibook has nice elaborate example of this
05:25:13 <merijn> frerich: https://en.wikibooks.org/wiki/Haskell/GADT
05:25:24 <merijn> frerich: They construct a typed AST and interpreter
05:25:33 <merijn> Might be simpler to follow
05:25:53 <frerich> Funky! I'll give that a try later today (when the kids are in bed, ahem), thanks for pointing it out!
05:28:15 <lpvb> is there a shortcut function to do (\_ -> value)?
05:28:31 <mikeplus64> lpvb: const
05:29:00 <lpvb> thanks
05:29:07 <lpvb> @src const
05:29:08 <lambdabot> const x _ = x
05:29:12 <Jafet> > (length "(\\_->x)", length "const x")
05:29:13 <lambdabot>   (7,7)
05:30:07 <merijn> I think const can be nicer to read sometimes, though
05:34:22 <Jafet> Being a value helps.
05:34:37 <Ferdirand> const is return, right ?
05:34:54 <sipa> :t const
05:34:55 <lambdabot> forall a b. a -> b -> a
05:35:05 <sipa> :t return
05:35:07 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:35:45 <fmap> @check \x y -> const x y == return x y
05:35:46 <lambdabot>   "OK, passed 500 tests."
05:36:39 <Ferdirand> now if only there was sugar for monad comprehensions with no generators...
05:41:55 <Saizan> > [ () | True ]
05:42:07 <lambdabot>   [()]
05:42:21 <merijn> What is cleaner? "foo [] x = x" or "foo [] = id"?
05:43:27 <thirsteh> merijn: imo the first is easier to read
05:44:27 <bitonic> definitely.  I'd consider the second one obfuscation :P
05:48:35 <Axman6> @oesis 2 6 184
05:48:37 <lambdabot>  Sequence not found.
05:48:40 <Axman6> :(
05:49:56 <ketil> bitonic: that depends on the other equations for foo, IMO.
05:50:29 <Hadaka> hey, is there a function that does this in the libraries somewhere: \act init -> act init >>= act
05:50:30 <bitonic> ketil: well, the others are more likely to need that third argument, if anything.
05:50:37 <Hadaka> whoops
05:50:45 <bitonic> and anyway, they all have to have the same number of args.  so you'll have no choice
05:50:46 <Hadaka> nevermind for a moment
05:51:26 <Hadaka> okay, this is more like it: loopaction act init = act init >>= loopaction act
05:51:42 <ketil> Well, to me it's conceptual: does foo take a list and return a function, or does it take a list and a something and compute a result from them.
05:52:29 <ketil> It is also obfuscation to name things that don't need to be named.
05:52:32 <Hadaka> so, basically forever, except that the result of the monad is always fed as input to the next call
05:53:04 <bitonic> ketil: yes, if the intention is returning a function, `id' is clearer.  that will be a case less often.
05:53:38 <ketil> Yes, I agree with that. :-)
05:56:30 <fmap> @type \act -> fix (\f x -> act x >>= f)
05:56:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m a) -> a -> m b
05:56:35 <merijn> Hadaka: Did you check out the package monad-loops?
05:56:36 <merijn> Hadaka: http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html
05:57:00 <merijn> Hadaka: Looks like "iterateM_" in monad-loops
05:57:29 <Hadaka> merijn: quite right! thanks!
05:57:56 <merijn> Hadaka: Rule #1 of writing monad code, if it looks vaguely like a loop, check monad-loops first :p
05:58:44 <fmap> ew, iterateM_ is written without fix :(
05:59:10 <bitonic> fmap: why would you?
05:59:41 <Hadaka> fmap: can you suggest a better iterateM_ implementation?
05:59:42 <bitonic> again, that looks like obfuscation to me
06:00:04 <fmap> bitonic: one line less!
06:00:17 <Hadaka> merijn: yeah, thanks!
06:00:23 <bitonic> fmap: `loopaction act init = act init >>= loopaction' is one line
06:01:43 <fmap> bitonic: I guess you need "where" for perfomance reasons?
06:02:09 <bitonic> fmap: I haven't read `iterateM_', but the answer is probably "no"
06:04:15 <dmwit> Somebody put "haskell@haskell.org" as their email address on LinkedIn. ^_^
06:05:54 <Hadaka> so, "iterateM_ f = g where g x = f x >>= g" is the best implementation?
06:06:11 * jfischoff wonders what job offers Haskell is getting
06:08:27 <bitonic> Hadaka: your implementation is perfectly fine
06:09:04 <Hadaka> bitonic: thanks
06:10:03 <ski> `subst :: Monad m => (a -> m a) -> (m a -> m b)' can also be useful
06:12:41 * hackagebot regular 0.3.4.2 - Generic programming library for regular datatypes.  http://hackage.haskell.org/package/regular-0.3.4.2 (JosePedroMagalhaes)
06:22:41 * hackagebot instant-generics 0.3.6 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.3.6 (JosePedroMagalhaes)
06:26:42 <MagneticDuck> I'm trying to install gtk2hs on my ubuntu linux machine using http://www.haskell.org/haskellwiki/Gtk2Hs/Linux
06:26:58 <MagneticDuck> I install gtk2hs-buildtools fine...
06:27:23 <MagneticDuck> but when I try to install the gtk package..
06:27:36 <MagneticDuck> it says it can't find any binaries from gtk2hs-buildtools
06:27:38 <Jafet> The build tools are binaries, and hence they should be in your PATH.
06:27:53 <MagneticDuck> okay, let me try that
06:27:54 <MagneticDuck> x)
06:27:57 <MagneticDuck> I'm a linux newbie
06:27:57 <Jafet> PATH=$PATH:~/.cabal/bin
06:28:01 <Jafet> Or something
06:29:04 <MagneticDuck> okey
06:29:44 <MagneticDuck> err, same error
06:29:51 <MagneticDuck> Cannot find gtk2hsTypeGen
06:29:51 <MagneticDuck> Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin).
06:29:51 <MagneticDuck> cabal: Error: some packages failed to install:
06:29:51 <MagneticDuck> gtk-0.12.3.1 failed during the configure step. The exception was:
06:29:51 <MagneticDuck> ExitFailure 1
06:30:19 <MagneticDuck> I reinstalled gtk2hs-buildtools with the modified PATH
06:30:44 <dmwit> You only need to change the PATH when installing gtk.
06:30:47 <Jafet> They should already be in that directory. You just add the directory to your PATH.
06:31:06 <MagneticDuck> PATH=$PATH":~/.cabal/bin"
06:31:10 <MagneticDuck> then I installed both packages
06:31:16 <MagneticDuck> gtk2hs-buildtools and gtk
06:31:19 <dmwit> Did you export PATH?
06:31:25 <MagneticDuck> no..
06:31:26 <Jafet> "~" expands to "~".
06:31:31 <MagneticDuck> ah
06:31:35 <dmwit> Jafet: Even in double quotes?
06:31:38 <MagneticDuck> I have to use $HOME
06:31:42 <MagneticDuck> ?
06:31:51 <dmwit> Ah, yes, even in double quotes.
06:31:54 <dmwit> So yes, use $HOME.
06:31:57 <MagneticDuck> okay
06:32:01 <MagneticDuck> that will fix it hopefully
06:32:13 <Jafet> Who has control characters in $HOME, anyway?
06:32:16 <MagneticDuck> btw, how do I permantly add ~/.cabal/bin to PATH?
06:32:26 <MagneticDuck> nobody
06:32:27 <MagneticDuck> :P
06:32:30 <MagneticDuck> I just like double quotes
06:32:33 <dmwit> Change your .bashrc (or .zshrc or whatever).
06:32:47 <dmwit> Well, probably your .zshenv if you're a zsh guy.
06:32:49 <MagneticDuck> yeah, using back
06:32:55 <MagneticDuck> *bash
06:33:15 <MagneticDuck> okay, then I have to export PATH too?
06:33:28 <MagneticDuck> I'm only running one console session..
06:33:53 <MagneticDuck> well, I guess I would have to
06:34:08 <Jafet> If it's in your bashrc, it gets exported into bash.
06:34:25 <MagneticDuck> okay
06:34:57 <MagneticDuck> I might as well change the .bashrc
06:35:20 <ketil> Any idea if pandoc can generate postscript directly?  I'd like to be able to pipe it to the printer.
06:35:27 <MagneticDuck> gaah.. same error!!
06:35:32 * ketil is sorry if this is off topic.
06:35:48 <MagneticDuck> nothing's off topic here@!
06:35:50 <MagneticDuck> *!
06:35:52 <dmwit> ...did you export PATH this time? =)
06:35:56 <MagneticDuck> yes
06:36:00 <MagneticDuck> ._.
06:36:03 <dmwit> strange
06:36:03 <MagneticDuck> but it still no workies
06:36:08 <MagneticDuck> I'll paste it
06:36:08 <dmwit> what does "which gtk2hsC2hs" say?
06:36:19 <EvanR> writeChan haskellChan (Just GoodMorning)
06:36:26 <MagneticDuck> one sec
06:36:39 <MagneticDuck> lol, is that simpleIRC or something?
06:36:55 <dmwit> ketil: Dunno, but I guess there's pdf2ps and similar tools.
06:37:09 <dmwit> And I think at least lp can handle more than just postscript.
06:37:12 <MagneticDuck> dmwit: it doesn't return anything
06:37:16 <EvanR> evanr Speaks = Only Haskell
06:37:17 <ketil> Funny: pandoc file -o file.ps works great, but there is no -t ps option.
06:37:31 <dmwit> MagneticDuck: Try ls $HOME/.cabal/bin, then?
06:37:48 <MagneticDuck> I see gtk2hsC2hs
06:37:52 <MagneticDuck> and gtk2hsTypeGen
06:38:08 <dmwit> echo $PATH ?
06:38:26 <MagneticDuck> it has a ~/.cabal/bin
06:38:32 <MagneticDuck> and also /home/magneticduck/.cabal
06:38:36 <MagneticDuck> for some reason
06:38:42 <dmwit> Okay, both of those are wrong.
06:38:46 <MagneticDuck> oh.
06:38:47 <Jafet> [GoodMorning, GoodMorning, GoodMorning, GoodMorning, GoodMorning]!!
06:38:52 <dmwit> The first because it has a ~, and the second because it doesn't have /bin at the end.
06:39:04 <MagneticDuck> ..
06:39:04 <MagneticDuck> yes
06:39:06 <MagneticDuck> I see it now
06:39:08 <MagneticDuck> :D
06:39:11 <MagneticDuck> ima go and change it
06:39:27 <lpvb> > replicate 5 "GoodMorning"
06:39:28 <lambdabot>   ["GoodMorning","GoodMorning","GoodMorning","GoodMorning","GoodMorning"]
06:39:36 <MagneticDuck> I was about to do that
06:39:36 <MagneticDuck> xD
06:40:06 <MagneticDuck> IT STILL NO WORKIES!
06:40:39 <MagneticDuck> I added "/home/magneticduck/.cabal/bin"
06:40:46 <MagneticDuck> same error
06:41:16 <dmwit> Does "which gtk2hsC2hs" work now?
06:41:31 <MagneticDuck> oh
06:41:34 <MagneticDuck> I forgot to export the new path
06:41:35 <MagneticDuck> lo
06:41:37 <MagneticDuck> lol
06:41:40 <MagneticDuck> this is a learning experience
06:41:57 <int-e> welcom to (s)hell
06:42:06 <MagneticDuck> UM*G DEH SAME ERROR
06:42:18 <MagneticDuck> I'm going to go insane. x)
06:42:26 <MagneticDuck> I had this same problem installing yi
06:42:29 <MagneticDuck> I never managed to do it
06:42:42 <MagneticDuck> dmwit: let me see.
06:42:54 <MagneticDuck> dmwit: now it has one entry
06:43:04 <MagneticDuck> all looking good
06:43:20 <MagneticDuck> oh wait
06:43:21 <MagneticDuck> omg
06:43:22 <MagneticDuck> yes!
06:43:26 <MagneticDuck> praise the bash gods!
06:43:29 <MagneticDuck> it worked!
06:43:39 <MagneticDuck> I stopped using sudo
06:43:40 <MagneticDuck> O.o
06:43:44 <MagneticDuck> and now it worked
06:43:53 <MagneticDuck> or wait now it's freezing up at preprocessing
06:44:00 <MagneticDuck> ~_~
06:44:24 <MagneticDuck> how long does it take to preprocess a big library?
06:44:42 <MagneticDuck> lol int-e
06:45:21 <dfordivam> ok
06:46:29 <MagneticDuck> I see everyone's given up on me
06:46:30 <MagneticDuck> :D
06:47:01 <Jafet> We're waiting for you to give up on the computer.
06:47:07 <MagneticDuck> ..or that
06:47:26 * Quadrescence is contemplating writing a FORTRAN 77 DSL in Haskell so Fortran programmers can leverage their code in Haskell.
06:47:42 * hackagebot groundhog 0.1.0 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-0.1.0 (BorisLykah)
06:47:45 * hackagebot groundhog-th 0.1.0 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.1.0 (BorisLykah)
06:48:49 * MagneticDuck continues battling in unknown regions of the bash shell
06:49:35 <dmwit> MagneticDuck: preprocessing takes a long time
06:49:40 <dmwit> So just wait.
06:49:48 <MagneticDuck> okay
06:49:49 <dmwit> I didn't give up on you, but I'm not 100% in the channel.
06:49:51 <hpaste> MagneticDuck pasted “(s)hell” at http://hpaste.org/74629
06:49:59 <MagneticDuck> however, this is the problem I had
06:50:14 <MagneticDuck> I fixed it by taking "sudo" off the install for gtk
06:50:17 <ski> Quadrescence : <http://augustss.blogspot.se/2009/02/is-haskell-fast-lets-do-simple.html> and related posts might perhaps be of some inspiration
06:50:18 <MagneticDuck> I wonder why
06:50:19 <MagneticDuck> ~_~
06:51:03 <MagneticDuck> lol
06:51:04 <dmwit> Well, because sudo uses a different environment (root's).
06:51:06 <MagneticDuck> I forgot to export
06:51:07 <MagneticDuck> again
06:51:08 <typoclass> MagneticDuck: you need to do "export PATH"
06:51:09 <MagneticDuck> ah
06:51:11 <MagneticDuck> yes
06:51:13 <MagneticDuck> lol
06:51:17 <MagneticDuck> I hope I learn THIS time
06:51:34 <dmwit> And also cabal installs to different local repositories when run as different users.
06:51:52 <MagneticDuck> hm
06:51:57 <MagneticDuck> I see
06:52:00 <Jafet> @where sicp
06:52:00 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | "Structure and Interpretation of Computer Programs"
06:52:04 <Jafet> @where xsicp
06:52:05 <lambdabot> I know nothing about xsicp.
06:52:05 <MagneticDuck> but magneticduck is root!
06:52:15 <Jafet> http://www.vex.net/~trebla/haskell/sicp.xhtml
06:52:23 <MagneticDuck> yes I must read that some day
06:52:29 <MagneticDuck> how is it to the functional programmer?
06:52:35 <MagneticDuck> I see a lambda
06:52:35 <MagneticDuck> :D
06:52:37 <dmwit> I would be pretty surprised if magneticduck was the root user.
06:52:46 <dmwit> If your uid is not 0, you are not root.
06:52:47 * hackagebot groundhog-sqlite 0.1.0 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.1.0 (BorisLykah)
06:52:48 * hackagebot groundhog-postgresql 0.1.0 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.1.0 (BorisLykah)
06:52:51 <MagneticDuck> well, I'm running ubuntu
06:52:55 <dmwit> irrelevant
06:53:11 <MagneticDuck> in ubuntu, root privilege is handled differently
06:53:13 <MagneticDuck> but yes
06:53:20 <dmwit> I know how root privilege is handled in ubuntu.
06:53:29 <MagneticDuck> I guess sudo cabal install would install to the root directory..
06:53:42 <MagneticDuck> and it installs to magneticduck!
06:53:50 <MagneticDuck> well, I don't know much
06:53:53 <MagneticDuck> I'm probably missing something
06:54:15 <MagneticDuck> well yay!
06:54:16 <MagneticDuck> it installed
06:54:21 <MagneticDuck> :'D
06:54:28 <MagneticDuck> now I can make a hello world applicatoin
06:54:32 <MagneticDuck> application
06:54:32 <dmwit> sudo copies $HOME from your user's environment to root's environment, so possibly my complaint about sudo installing the wrong place was wrong
06:54:40 <MagneticDuck> using a tiny fraction of what was installed
06:54:47 <fmap> that depends on sudo settings?
06:55:02 <dmwit> I'm assuming default Ubuntu settings, since MagneticDuck claims to be a newbie.
06:55:02 <MagneticDuck> hm
06:55:07 <MagneticDuck> yes
06:55:13 <MagneticDuck> I didn't change anything at all
06:55:37 <MagneticDuck> so what did sudo do?
06:55:46 <MagneticDuck> or, sudid what?
06:55:52 <dmwit> =)
06:55:56 <MagneticDuck> ah great I'm going on a punny tangent
06:56:00 <Jafet> It would also probably have the nice effect of placing root-owned files into ~/.cabal.
06:57:14 <MagneticDuck> yeah, sudo didn't do anything actually
06:57:18 <MagneticDuck> I just forgot to export I guess
06:57:31 <typoclass> MagneticDuck: most people use their own user (joe_shmoe) for almost everything, and log in as root only rarely and only when necessary
06:57:36 <merijn> How costly the haskell function to FunPtr conversion in the FFI? (i.e.: foreign import ccall "wrapper" mkOutFun :: OutFun -> IO (FunPtr OutFun))
06:58:24 <typoclass> MagneticDuck: in other words, don't use "sudo cabal ..." unless you have a good reason. sudo will make that command run with root priviledges
06:58:27 <MagneticDuck> typoclass: yeah, I have the only account on the computer, which in other distros would be root.. however on ubuntu I can't do anything with super privileges without logging in as su, usually just for one command
06:58:31 <MagneticDuck> okay
06:58:41 <MagneticDuck> true
06:59:27 <MagneticDuck> now how do you install a cabal package so all users can get it?
06:59:36 <typoclass> MagneticDuck: i don't know ubuntu, but i bet they have a regular root user. they only hide his icon in the login chooser
07:00:01 <MagneticDuck> I don't see any other user directories..
07:00:02 <MagneticDuck> just me
07:00:12 <dmwit> MagneticDuck: Set user-install: False in ~/.cabal/config; then you *will* have to run "cabal install" as root.
07:00:21 <typoclass> MagneticDuck: root's home directory is typically /root, not /home/something
07:00:25 <MagneticDuck> so where does it install?
07:00:26 <typoclass> root is very special
07:00:28 <dmwit> typoclass: They do more: they disable the root user (give it no password).
07:00:32 <MagneticDuck> yeah
07:00:54 <dmwit> MagneticDuck: It installs where you tell it to in the "install-dirs global" stanza.
07:00:56 <MagneticDuck> but I can get its privileges if I really need to
07:01:00 <typoclass> MagneticDuck: at any rate, i suggest you don't use sudo unless there's reason to
07:01:02 <MagneticDuck> ah
07:01:04 <MagneticDuck> where is that usually?
07:01:16 <MagneticDuck> ah
07:01:17 <dmwit> MagneticDuck: Open up the file. =)
07:01:24 <MagneticDuck> /root/.cabal/bin I imagine
07:01:31 <dmwit> no
07:01:35 <dmwit> open the file
07:01:35 <MagneticDuck> oh
07:01:38 <MagneticDuck> okay then
07:01:40 <MagneticDuck> suspense
07:01:40 <MagneticDuck> :D
07:02:10 <MagneticDuck> ah
07:02:13 <MagneticDuck> /usr/local
07:02:46 <MagneticDuck> jdsalkfjdsa
07:03:05 <MagneticDuck> gar
07:03:09 <Botje> hahaa!
07:03:10 <MagneticDuck> I can't put a / in the front of a message
07:03:10 <MagneticDuck> xD
07:03:15 <MagneticDuck> wait..
07:03:17 <MagneticDuck> dafuq?
07:03:22 <MagneticDuck> /usr/local
07:03:25 <MagneticDuck> ~_~
07:03:26 <dmwit> Try /msg #haskell /foo
07:03:33 <MagneticDuck> /bin or /lib
07:03:36 <MagneticDuck> YAY
07:03:47 <int-e> a common workaround is to put a space in front of the /
07:03:52 <MagneticDuck> or that
07:03:53 <dmwit> ...and then read the documentation for your IRC client. ;-)
07:04:00 <MagneticDuck> /or do this
07:04:05 <MagneticDuck> /string escapes ftw//
07:04:36 <MagneticDuck> whaatsa CTCP VERSION?
07:04:37 <int-e> xchat uses double /
07:04:45 <MagneticDuck> yes I'm new to IRC too
07:04:46 <MagneticDuck> x)
07:04:59 <MagneticDuck> I used to be a silly little pascal programmer for windows
07:05:00 <typoclass> MagneticDuck: just a friendly heads-up, be aware that some 900 people are in this channel. please send only messages that are worth their time
07:05:16 <MagneticDuck> sorry
07:05:21 <int-e> MagneticDuck: sorry, it asks your client for its version. I was curious.
07:05:23 <typoclass> MagneticDuck: no worries
07:05:41 <MagneticDuck> I'd give anyone with a real question yeild :P
07:06:58 <MagneticDuck> now, less spam and more work
07:07:00 <RawProduce> caffeine intoxication... it's real
07:07:11 <MagneticDuck> x)
07:07:14 <MagneticDuck> COFFEEEE
07:07:43 * hackagebot shake 0.3.2 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.2 (NeilMitchell)
07:07:45 * hackagebot TCache 0.10.0.1 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.1 (AlbertoCorona)
07:07:53 <RawProduce> :)
07:08:11 * Cale has his daily cappuccino made with ~4 shots of espresso with like 1600mg of caffeine or whatever.
07:08:54 <MagneticDuck> :D
07:09:03 <MagneticDuck> so you're saying it's just daily eh?
07:09:23 <MagneticDuck> :P
07:10:17 <Cale> If I have another one, I don't sleep.
07:11:06 <MagneticDuck> aahh
07:11:31 <Botje> espresso is only like 50 mg of caffeine i think
07:11:44 <Botje> if you count the one in your cappucino you have ~ 2 cups of regular drip coffee
07:12:29 <randomclown> @pl \x -> f (p x) a
07:12:29 <lambdabot> flip f a . p
07:12:44 <MagneticDuck> everyone loves @pl!
07:17:43 <SLi> Argh, so many reactive programming frameworks. Any suggestions on which, if any, I should use for code that controls, say, a robot with sensors that periodically report something over a network socket?
07:18:31 <dmwit> reactive-banana seems the most actively developed at the moment.
07:18:53 <SLi> I read some tutorials on Reactive and reactive-banana.
07:18:57 <timthelion> but you have to write your own bindings for reactive-banana and there are no docs on that :/
07:19:46 * timthelion rather strongly does not recomend reactive, given the latest blog posts by the author.  Seems *very* accademic and not at all practical :(
07:20:11 <SLi> Ok.
07:20:33 <SLi> Perhaps I'll look more closely on reactive-banana. Thanks.
07:21:49 <aristid> hey mm_freak you still haven't release netwire 4
07:22:57 <timthelion> SLi: take a look at the package, netwire, which aristid just refered to.  At least the author claims that netwire has been succesfully used in a project.
07:23:22 <SLi> Hmm, ok.
07:23:27 <aristid> timthelion: yeah but netwire 4 is supposed to change everything but it's not released
07:23:57 <timthelion> aristid: still better than a package, which cannot even be used by the author...
07:25:10 <aristid> timthelion: ?
07:25:42 <timthelion> aristid: he wrote 3 or 4 small example programs, and gave up on the last, saying that he needed to revise his thinking.
07:25:50 <dfordivam> hello
07:25:52 <aristid> timthelion: who?
07:26:14 <ski> hello dfordivam
07:26:33 <dfordivam> I heard in some recent talk, " you learn programming language by doing something non-trivial"
07:26:56 <dfordivam> any suggestions for doing some non-trivial stuff in haskell
07:27:01 <MagneticDuck> I'd agree with that
07:27:12 <timthelion> aristid: moment
07:27:18 <dfordivam> or anyone doing some open source / collaborative project
07:28:38 <timthelion> aristid: I'm reffering mainly to this: http://apfelmus.nfshost.com/blog/2012/03/29-frp-three-principles-bidirectional-gui.html
07:29:09 <aristid> timthelion: so this is about reactive-banana.
07:29:16 <timthelion> aristid: yes.
07:30:44 <tdammers> if you want to do the whole web app in Haskell, try one of the frameworks - snap, yesod, happstack; they're all good
07:30:46 * timthelion has really mixed feelings about this :/  On the one hand he thinks it's great that people are excited about theory and FRP. and on the other hand, he feels that haskell is discredited by the sugestion that FRP can turn water into wine when the commonly recomended library makes really impractical code and has never been used for a large project.
07:30:57 <tdammers> nm
07:30:59 <tdammers> scrolled
07:31:13 <timthelion> dfordivam: what kind of project?
07:31:54 <dfordivam> <timthelion> : Well what kind of projects have you worked on?
07:32:09 <timthelion> The thing about FRP, is of course I don't want to insult the authors.  And of course many of their ideas are great, but they aren't "there" yet.
07:32:10 <geekosaur> timthelion, I would claim FRP is still in its infancy, it has lots of potential but is not really at the stage where production systems are viable
07:32:39 <timthelion> dfordivam: I am working on this: https://github.com/timthelion/gridhaskell-haskarrow
07:32:39 <geekosaur> the FRP folks want to encourage experimenttion, for good reason, but you should use your judgment
07:32:51 <timthelion> dfordivam: http://imageshack.us/photo/my-images/94/gridediteditcell.jpg/
07:32:56 <dfordivam> <timthelion> : projects which take use of existing smaller projects to create something big would be great,
07:34:03 <timthelion> dfordivam: I am working on the compeditor to FRP, which is the toolkit I'm using to make that application.
07:34:16 <t7> im not sure i like they way Constructors have to start with uppercase and functions with lowercase
07:34:50 <timthelion> t7: yes, it's a bit awkward.  since constructors a la GADTs are quite a bit more functiony than datay.
07:34:59 <dfordivam> <timthelion> : yup trying to understand from the links
07:35:11 <ski> timthelion ?
07:35:48 <timthelion> ski: data Foo = Bar Int.  Bar is a function that takes an Int and returns a Foo.  It's not a type.  So why is it capitalized, like a type, and not lowercase like a function?
07:35:57 <timthelion> ski: doesn't really matter that much though.
07:36:15 <timthelion> dfordivam: never mind the long political rant in the README :)
07:36:24 <timthelion> dfordivam: the idea is a visual programming language.
07:36:40 <dfordivam> <timthelion> : Oh man its really long
07:36:58 <timthelion> dfordivam: I know... Sorry. :(  I should delete it...
07:37:08 <geekosaur> timthelion, the distinction is that in a pattern match, something starting with lowercase is a new binding, so something is needed to distinguish the data constructors that you pattern match on
07:37:16 <geekosaur> so those start with uppercase
07:38:00 <timthelion> geekosaur: good point.  I was just agreeing with t7's general sentiment.  I don't have a feeling about it myself.  I have no trouble reading haskell's basic syntax as it is.
07:38:00 <dfordivam> <timthelion>: its more like a blog post
07:38:13 <timthelion> dfordivam: you don't have to read it :D
07:38:27 <ski> timthelion : in SML, where type constructors, data constructors and variables can start with both upper as well as lower case, it sometimes happens that, in pattern-matching, a data constructor is misspelled, and thus becomes a variable, matching anything
07:38:37 <t7> lets all start a petition and send it to SPJ ?
07:38:38 <dfordivam> <timthelion>: anyways that's too much above my head, do u know ppl who are working on using haskell in EDA
07:38:44 <lpvb> @src unsafePerformIO
07:38:44 <lambdabot> Source not found. stty: unknown mode: doofus
07:38:47 <dfordivam> Electronics Design Automation
07:38:53 <lpvb> @src System.IO.Unsafe.unsafePerformIO
07:38:54 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:39:10 <timthelion> dfordivam: no :(  Though I know that EDA does a lot of visual programming :)
07:39:29 <timthelion> t7: not worth it. there are worse things in haskell.
07:39:41 <t7> like?
07:39:59 <timthelion> t7: Like if I had an idea of how to fix exceptions. I would petition my head off.  But I don't have a "better" solution to the one that we have now...
07:40:14 <aristid> t7: the fact that constructors are upper case makes sense, this way you can visually vistinguish them.
07:40:27 <t7> but i wanna use silly unicode characters for stuff!
07:40:39 <aristid> t7: you can.
07:40:44 <t7> aristid: it could just be a convention
07:40:56 <aristid> t7: starting in ghc 7.6, the uppercase requirement is no longer there for type operators.
07:41:20 <aristid> all type operators are assumed to be constructors if i understand it correctly
07:41:30 <ski> lpvb : please cover your eyes : <http://darcs.haskell.org/packages/base/GHC/IO.hs>
07:41:44 <xz> is there no inverse to Data.List.intersperse in Haskell Platform? (I know there is Data.List.Split.wordsBy, but that requires a separate download)
07:41:45 <dfordivam>  <timthelion>: Are you in research lab or industry??
07:41:49 <t7> aristid: what about if i wanna use ¬ for prefix not?
07:42:00 <aristid> t7: then you should use agda.
07:42:55 <ski> aristid : hm, so no more `Category (~>) => (a ~> b) -> (a ~> (a,b))' ? :(
07:42:56 <aristid> > generalCategory '¬'
07:42:57 <lpvb> ski: thanks
07:42:57 <lambdabot>   MathSymbol
07:43:03 <aristid> ski: seems like it
07:43:20 <aristid> ski: but maybe there is a workaround, i don't know the details
07:44:13 <t7> haskell 2013 should use agda infix notation
07:44:13 <timthelion> t7: just prefix everthing with C for constructor... Then you can have C¬Bar and CBar
07:44:14 <aristid> t7: so the reason why you can't use the negation symbol as a prefix operator or function isn't even the uppercase/lowercase requirement. it's a symbol, and as such reserved for (binary) infix operators.
07:44:30 <Cale> ski: yeah, I'm totally annoyed about that
07:44:55 <aristid> Cale: why didn't you petition for an exception for ~ if it bothers you? :P
07:44:59 <Cale> ski: I'm almost certain they're going to have to do something about it. It's going to kill 90% of all arrow libraries.
07:45:02 <timthelion> dfordivam: I am an undergrad pedagogy student. :P
07:45:30 <Cale> aristid: Other people had already mentioned the issue.
07:46:49 <Cale> tbh, I would expect it should be obvious to everyone involved what the problem with this change is. How are people not aware of this?
07:46:53 <aristid> Cale: i was kind of surprised that ghc 7.6 was released so soon after 7.4
07:47:39 <timthelion> Cale: can you explain to me what changed, and how it's a problem?
07:47:52 <Cale> timthelion: Infix type variables are no longer possible.
07:48:06 <aristid> other than with ``
07:48:19 <typoclass> Cale: did that happen already, or will it happen?
07:48:22 <Cale> timthelion: So things like (Arrow (~>)) => ... are screwed
07:48:26 <aristid> typoclass: in 7.6
07:48:27 <Cale> Already happened
07:48:35 <typoclass> urgh
07:49:00 <timthelion> Cale: I see it now.  I didn't realise that ski was describing a type :D  Now it's clear.  That's a pitty.  Why the change?
07:49:25 <Cale> Yeah, you could use backticks, but that would be silly.
07:49:46 <Cale> (it's less readable than just switching to prefix notation, and just as much work to edit the code)
07:50:07 * typoclass hates the weird "a b c" syntax in Control.Arrow. i think the little synactic change to "b ~> c" would have caused it to be twice as popular.
07:50:16 <typoclass> @type (&&&)
07:50:17 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:50:17 <Cale> timthelion: Because they wanted to steal arithmetic operators to be type constructors now that there are numeric literals at the type level.
07:50:20 <aristid> so i guess the data :+: faction won over the arrow faction :P
07:50:35 <Cale> timthelion: and so rather than being cautious, they just stole all the infix operators for type constructors
07:50:52 <Cale> rather than only the ones they needed
07:52:32 <ski> typoclass : i prefer `ar a b' to `a b c'
07:52:43 <timthelion> Cale: and couldn't they have doen the obvious of contextual classification of infix?  So that a + b would be an infix type variable if a and b are type variabels, and a + b, + would be an operator if a and b were numeric literals? and in the case of a mismatch an error?
07:53:01 <aristid> timthelion: what?
07:53:14 <Cale> That wouldn't make sense
07:53:18 <aristid> timthelion: it needs to be a typoe CONSTRUCTOR for a + b to work.
07:53:25 <aristid> -typoe+type
07:53:26 <bartavelle> it is incredible that I have absolutely no clue what you are talking about
07:53:37 <bartavelle> I thought the next big step would be working properly with arrows
07:53:44 <Cale> You're frequently going to want to add numbers at the type level which are variables.
07:53:47 <aristid> bartavelle: don't worry, what timthelion just said didn't make sense. :P
07:54:06 <bartavelle> what Cale just said didn't to me :)
07:54:10 <typoclass> so, a solution could be to say if it starts with ":", it's a constructor, else it's a type variable? (i mean we already have that sort of thing, "if it starts with an uppercase letter ...")
07:54:11 <timthelion> Cale: but can't you determine if those variables are numbers or not?
07:54:12 <aristid> Cale: oh, so that's what he meant.
07:54:12 <bartavelle> add number at the type level ?
07:54:21 <aristid> timthelion: you mean their kind?
07:54:42 <Cale> bartavelle: There are type level numbers in GHC 7.6
07:55:02 <bartavelle> I don't even understand what that might even mean, but don't worry, I probably have a lot to learn before that
07:55:02 <ski> typoclass : that's how it was previously
07:55:25 <Cale> bartavelle: It's useful to be able to index types by things like the size of the structures they contain
07:55:29 <timthelion> Cale: and what I'm saying, is it would make sense to make a way to distinguish between type level numbers and the normal, non numeric type variables.
07:55:33 <typoclass> ski: oh! interesting. but then why the change?
07:55:48 <Cale> bartavelle: So that you can tell at compile time how large structures are by looking at their types
07:55:52 <bartavelle> Cale, like char[10] in C ?
07:55:56 <Cale> bartavelle: yes
07:56:00 <bartavelle> oh this is nice
07:56:01 <ski> bartavelle : presumably something like `data Vector :: Nat -> * -> * where Nil :: Vector 0 a; Cons :: a -> Vector n a -> Vector (n+1) a'
07:56:34 <Cale> append :: Vector n a -> Vector m a -> Vector (n+m) a
07:57:08 <Cale> timthelion: But this is a syntactic thing, while the kind is semantic information.
07:57:31 <aristid> Cale: i wonder how useful functions like append are without the solver. i _think_ i read they didn't include it now
07:57:41 <Cale> timthelion: If you need interaction between the kind checker and the parser in order to be able to parse types, it gets hairy.
07:57:44 * hackagebot type-spine 0.2 - A spine-view on types  http://hackage.haskell.org/package/type-spine-0.2 (NicolasFrisby)
07:57:46 <timthelion> Cale: yes, that's obvious.  What I said DID make sense.  Here we know that the kind of n and m is Nat where as the kind of a is *.  So if we have * infix * then that infix is another * and if we have Nat infix Nat then the infix is an operator.
07:58:10 <Cale> timthelion: You can say that, but implementing it is another thing entirely :)
07:58:16 <timthelion> Cale: I can see how it can get hairy. But that's a case of "letting your implementation show" so to speak.
07:58:24 <Cale> timthelion: because it means you need to re-parse things when kind checking fails
07:58:42 * timthelion admits that it might be quite difficult, yes.
07:58:55 <RichyB> Cale: the [10] in char[10] in C isn't just syntactic. It's actually part of the type. e.g. char a[10]; printf("%d\n", sizeof(a)); // will print 10.
07:58:56 <Cale> Also difficult for programmers to read, in general
07:59:20 <Cale> RichyB: What prompted that statement?
07:59:33 <timthelion> Cale: that still doesn't mean that what I said was meaningless ^_^
07:59:41 <RichyB> Cale: oh, I misread something you wrote.
07:59:48 <Cale> timthelion: I never said it was
07:59:58 <timthelion> Cale: thanks :)
08:00:09 <RichyB> Cale: <Cale> timthelion: But this is a syntactic thing, while the kind is semantic information. -- I thoughts you were talking about type-level numbers there.
08:00:19 <RichyB> Never mind, sorry to bother you.
08:00:20 <Cale> timthelion: Just that I don't think it's a likely solution to this problem.
08:01:10 <Cale> RichyB: yeah, I was talking about the Haskell side of things here where we'd be deciding whether + is a type constructor or type variable based on the kinds of the things it's applied to.
08:02:01 <aristid> timthelion, Cale: also, being able to do syntax highlighting on haskell without parsing the whole damn language is nice.
08:02:46 * hackagebot type-digits 0.2 - Arbitrary-base type-level digits  http://hackage.haskell.org/package/type-digits-0.2 (NicolasFrisby)
08:02:48 * hackagebot type-cereal 0.2 - Type-level serialization of type constructors  http://hackage.haskell.org/package/type-cereal-0.2 (NicolasFrisby)
08:02:50 * hackagebot type-ord 0.2 - Type-level comparison operator  http://hackage.haskell.org/package/type-ord-0.2 (NicolasFrisby)
08:02:52 * hackagebot type-ord-spine-cereal 0.2 - Generic type-level comparison of types  http://hackage.haskell.org/package/type-ord-spine-cereal-0.2 (NicolasFrisby)
08:02:57 <timthelion> aristid: heh, haskell-mode in emacs currently does a terrible job of that :|
08:03:10 <Cale> aristid: Well, that's the point, you don't just need a parser then
08:03:16 <Cale> You need a kind checker to be able to parse
08:03:23 <Cale> which makes it pretty rough going
08:04:31 <timthelion> Cale: actually it's quite common in other languages.  In Perl I believe that there are operators that change their number of arguments depending on the types of the proceding arguments
08:04:45 <aristid> Cale: would you have been fine with ~ being reserved for type operator variables?
08:05:09 <dmwit> No, way, ~ is for making negative numbers!
08:05:29 <Cale> timthelion: Perl is the only other example I know of
08:05:34 <bartavelle> dmwit :)
08:05:48 <Cale> aristid: That would have been somewhat okay.
08:06:25 <ski> (dmwit : .. thinking about SML ?)
08:06:32 <edwardk> i can write all sorts of functions in haskell where the number of arguments depends on the types of preceeding arguments
08:06:51 <edwardk> :t id
08:06:52 <lambdabot> forall a. a -> a
08:06:53 <edwardk> :t id id
08:06:54 <lambdabot> forall a. a -> a
08:06:55 <dmwit> ski: That's the joke, yeah. =)
08:06:57 <edwardk> its magic =)
08:07:26 <timthelion> edwardk: Yes, but do those cases end up making the langauge unparsable before type resolution?
08:07:44 * hackagebot yoko 0.9 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.9 (NicolasFrisby)
08:07:54 <edwardk> not those cases, but you can make plenty of ones that do. e.g. vgrad in my ad library
08:08:06 <edwardk> vgrad (+) takes as many arguments as (+) did.
08:08:19 * ski would have to ask dmwit to dissect the joke
08:08:43 <dmwit> Eh, you probably got it. It just wasn't a very good joke.
08:10:16 <Cale> timthelion: The number of arguments to a function isn't a syntax issue, at least in Haskell
08:10:30 <Cale> timthelion: because it's really always 1
08:11:11 <Cale> timthelion: and there's also no syntactic distinction between functions and non-function values
08:11:42 <Cale> (you can apply any expression to any other, and that might be a type error, but not a syntax error)
08:11:50 <timthelion> Cale: OK, but in languages with contexts, such as Perl, and now PHP comes to mind as well. The parser actually does rely on type information...  I see your point though, about how it might be hard to read given that there is no good way to see without double checking, the kind of a type variable.
08:12:03 <Cale> > ("herp", 5) "derp"
08:12:04 <lambdabot>   Couldn't match expected type `t1 -> t'
08:12:04 <lambdabot>         against inferred type `([GHC...
08:13:22 <timthelion> Cale: I always wanted that to resolve to some value: a <- b that could then be applied to an a -> b -> c to get c :P
08:13:57 <timthelion> like let f = 1 2 in (+) f
08:14:19 * timthelion realises that such a sugestion is insane...
08:15:14 <Cale> It would make a certain amount of sense for (f,g) to be synonymous with \x -> (f x, g x), but that brings a whole lot of insanity with it.
08:15:33 <dford> Anyone here used Lava hdl?
08:16:02 <mysticc> :i guard
08:16:08 <ski> > let f = ($ 1) >>> ($ 2) in (+) >$ f
08:16:10 <lambdabot>   3
08:16:14 <mysticc> > :i guard
08:16:15 <lambdabot>   <no location info>: parse error on input `:'
08:16:21 <mysticc> @where guard
08:16:21 <lambdabot> I know nothing about guard.
08:16:28 <ski> @index guard
08:16:28 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:16:43 <timthelion> ski: wow :D My dream come true...
08:16:49 * timthelion will never use such code...
08:17:42 <dmwit> > let f = \g -> g 1 2 in (+) >$ f
08:17:44 <lambdabot>   3
08:18:00 <dmwit> (>$) = flip ($) -- or some such thing
08:18:10 <dmwit> > let f = \g -> g 1 2 in f (+)
08:18:11 <lambdabot>   3
08:18:52 <dmwit> type a <- b = (a -> b -> c) -> c -- lololol
08:20:45 <Jesin> ...
08:21:20 <Cale> dford: I haven't used Lava, but I've played around with it slightly.
08:21:39 <Cale> dford: Do you have a question about it?
08:21:54 <dford> Cale: I am playing around with it right now
08:22:16 <dford> Cale: u know any useful material which helped you use it
08:22:38 <Cale> dford: Just the original paper describing it.
08:23:15 <Cale> dford: You might also look at the implementation of the Reduceron, since it's a working CPU written in Lava (albeit one with a very non-traditional architecture)
08:24:54 <dford> Cale: ok that's cool! Do you have any idea, if there is any haskell tool which does simulation/verification of traditional languages like verilog and vhdl
08:30:00 <Cale> dford: I don't know. I know there are companies like Bluespec and Galois who do hardware verification stuff in Haskell, but I don't know if they do it in that direction. (There are tools for generating VHDL from Haskell domain specific languages, but I haven't heard of any openly available VHDL parser)
08:30:52 <dford> Cale: Thanks for the reply
08:31:05 <Cale> there is this: http://hackage.haskell.org/package/verilog
08:32:43 <dford> Cale: yup I tried that, the parsing part is ok, What I am concerned is how will I represent the design for doing efficient static verification
08:34:03 <Cale> You might try to somehow compile the verilog code back into lava :)
08:34:43 <dford> Cale: I need a sort of graph structure for connectivity part, then the various blocks (buffers/flops) need some other efficient representation
08:35:48 <dford> Lettme see whether Lava' design part can do what I need
08:39:41 <tdammers> is there an easy way to get ghc 7 running on debian stable
08:41:26 <tdammers> (other than building from source)?
08:41:52 <bitonic> tdammers: use the binaries
08:42:50 <bitonic> tdammers: <http://www.haskell.org/ghc/download_ghc_7_6_1#x86linux>
08:42:56 <tdammers> ah, ok
08:43:04 <tdammers> those will "just work"?
08:43:17 <bitonic> tdammers: well, unless you have glibc/gmp issues
08:43:25 <tdammers> no idea...
08:43:30 <bitonic> how about trying :)
08:43:34 <tdammers> fairly clean debian squeeze system
08:43:36 <tdammers> yeah
08:44:35 <tdammers> I guess I should remove the debian-provided one first then, huh?
08:45:05 <bitonic> tdammers: well you don't *need* to, especially to try it out.
08:45:14 <tdammers> it's a vm anyway
08:45:15 <scri> how do you convert a church booleans to a boolean?
08:45:24 <scri> i have lambda datatypes
08:45:27 <tdammers> I'm using it to build for my x86 server
08:45:30 <bitonic> scri: is this homework?
08:45:38 <bitonic> it sounds a lot like homework
08:45:44 <tdammers> the main dev machine is x86_64
08:45:52 <tdammers> (with debian testing)
08:45:53 <scri> it's already late
08:45:59 <scri> i mean, no credit at this point
08:46:08 <scri> i just need to finish it for myself
08:46:16 <scri> it's a project
08:46:23 <bitonic> scri: well, I won't give you the solution anyway :).  I suppose that with church booleans you mean things of type `a -> a -> a', right?
08:46:37 <t7> @pl Map.filterWithKey (\k _ -> Set.member k s) m
08:46:38 <lambdabot> Map.filterWithKey (const . flip Set.member s) m
08:46:42 <scri> well, no they're untyped
08:47:25 <bitonic> scri: OK, but you've got `\a b -> a' as true and `\a b -> b' as false
08:47:31 <scri> > data Expr = Var String | Lam (String, Expr) | App (Expr, Expr)
08:47:32 <lambdabot>   <no location info>: parse error on input `data'
08:47:53 <scri> yes
08:48:20 <scri> but applying that to a "t" and "f"
08:48:26 <bitonic> scri: OK.  so you need to provide some values for `a' and `b' such that when you have false, you get back `false', when you have true, you get back `true'
08:48:37 <scri> doesn't always result in a Var, though
08:49:37 <bitonic> what do you mean?
08:49:50 <bitonic> actually I really should work now, someone else will help - hopefully :P
08:50:00 <scri> sigh ok well
08:50:18 <mysticc> bitonic: Whats your thesis finally ?
08:50:36 <bitonic> mysticc: ...I'm not sure, did we talk about my thesis :D?
08:51:14 <bitonic> with "work" I meant paid work, today
08:51:47 * mysticc had a dream about bitonic's Noble Thesis
08:52:21 <bitonic> lol
08:53:13 <mysticc> so what did you decide on ?
08:53:56 <bitonic> I told you, I don't know yet.  I should decide soon...
08:57:42 <mysticc> ohh .. Let us know when you stumble upon the next big thing :D
08:57:44 <timthelion> Why must types be of kind * -> * to be monads?  I want to make a monad(simply for abuse of the do notation mind you) that is of kind * :/
08:57:54 <timthelion> I cannot figure out how.
08:57:56 <bitonic> mysticc: I'm not sure what you're talking about, but OK :P
08:58:28 <Clint> timthelion: how do you want it to work?
08:59:33 <Botje> timthelion: just make a newtype alias of the right kind.
08:59:37 <timthelion> Clint: I currently have a function: doModifications :: [Modification] -> IO () and I would like to write doModifications $ do {foo;bar} rather than doModifications foo:bar:[]
09:00:03 <timthelion> Clint: so I want to make a Modifications monad.
09:00:14 <ski> timthelion : how else could you express `join :: M (M a) -> M a' and `return :: a -> M a' (working for *any* choice of `a'), for your monad `M' ?
09:00:40 <timthelion> http://hpaste.org/74630
09:01:33 <ski> or, if you prefer `(>>=)' to `join', then in `(>>=) :: M a -> (a -> M b) -> M b', the point is to be able to "replace" the `a' (any `a') here by *any* `b' (through the `a -> M b' argument function)
09:01:41 <mysticc> bitonic: If you were sure then you would already have the topic :P ..
09:02:09 <bitonic> mysticc: I was talking about the "next big thing".  I have never done big things ehe
09:02:28 <timthelion> ski: so basically, despite the fact that do notation would look pretty here, I don't actually want a monad...
09:02:41 <ski> maybe not
09:02:44 * ski isn't sure
09:03:00 <Clint> it sounds like you just want [foo,bar]
09:03:12 <Botje> timthelion: how about the write monad?
09:03:19 <Botje> tell foo >> tell bar
09:03:26 <ski> you should probably try to figure out what you want, and then (optionally) checking if what you want actually is a monad
09:03:30 <Botje> and then make your LoudSourceModification a Monoid
09:03:46 <hpaste> timthelion annotated “modification monad” with “modification monad (annotation)” at http://hpaste.org/74630#a74631
09:04:11 <timthelion> ski: well I already have working code.  See the paste.  It's just ugly working code.
09:05:27 <timthelion> Clint: So I should go with the list. Like I have already...  It's just, this syntax is so different than the syntax I'm modeling it off of(STM) that it seems I should try to make it look more "typical"
09:05:28 <ski> timthelion : source (or at least types) of `doLoudSourceModification',`modifyLoudSource' ?
09:06:01 <timthelion> ski: moment
09:06:24 <benmachine> timthelion: if you're just trying to abuse notation, you're not the first
09:06:34 <benmachine> timthelion: it's not that hard to introduce a dummy parameter
09:06:51 <benmachine> (but IMO just using lists isn't that bad)
09:08:26 <scri> >data Expr = Var String | Lam (String, Expr) | App (Expr, Expr)
09:08:34 <hpaste> benmachine annotated “modification monad” with “modification monad (annotation) (annotation)” at http://hpaste.org/74630#a74632
09:08:44 <benmachine> timthelion: see that annotation
09:08:44 <scri> > data Expr = Var String | Lam (String, Expr) | App (Expr, Expr)
09:08:45 <lambdabot>   <no location info>: parse error on input `data'
09:08:47 <timthelion> ski: https://github.com/timthelion/haskarrow/blob/master/Control/Concurrent/STM/LoudObject.lhs#L95
09:09:23 <timthelion> benmachine: yes, I could do that too.
09:09:28 <ski> scri : lambdabot's `>' only accepts expressions to evaluate
09:10:24 <benmachine> timthelion: alternatively, maybe you're interested in the RebindableSyntax extension
09:10:42 <timthelion> benmachine: I'll look at it.
09:13:26 <timthelion> benmachine: though the more I think about it, the more I realise that do notation might be a bit misleading here.  Because it really is a declarative thing.  I'm not telling it to do something, but rather giving it a list of things to do.  It's just that the sytax is very different than other cases of the same behavior...
09:13:53 <ski> timthelion : instead of `unsafeUnsortedDoLoudSourceModification pairs = let (ids,updates)=unzip pairs in ...' you can say `unsafeUnsortedDoLoudSourceModification (ids,updates) = ...'
09:14:04 <ski> er, no
09:14:28 <ski>   unsafeUnsortedDoLoudSourceModification (unzip -> (ids,updates)) = ...  -- rather, using `ViewPatterns'
09:14:46 <timthelion> yes I could.  I just read about ViewPatterns today.
09:15:23 <ski>   unsafeUnsortedDoLoudSourceModification pairs = uncurry unsafeUnsortedDoLoudSourceModificationInternal (unzip pairs)
09:15:26 <ski> or
09:15:30 <ski>   unsafeUnsortedDoLoudSourceModification = uncurry unsafeUnsortedDoLoudSourceModificationInternal . unzip
09:15:33 <ski> might be nicer
09:15:48 <ski> though, frankly, i'd probably skip `unsafeUnsortedDoLoudSourceModificationInternal' altogether
09:16:12 * ski ponders
09:16:58 <timthelion> ski: I think there are cases where an inner loop might want access to it...
09:17:36 <linusoleander> Does the datatype Nil exists in haskell?
09:18:07 <lightquake> linusoleander: what do you mean?
09:18:16 <linusoleander> I've seen it in some examples, but I can't use it in ghci
09:18:19 <ski> if you define `getSourceID :: SourceID -> Int', you could replace  (\(SourceID id) (SourceID id1)-> id `compare` id1)  by  (comparing getSourceID)
09:18:20 <timthelion> :t ()
09:18:21 <lambdabot> ()
09:18:40 <ski> linusoleander : probably those examples defined it themselves
09:18:45 <timthelion> ski: thanks.
09:19:15 <ski> (i.e. `newtype SourceID = SourceID {getSourceID :: Int}', with record syntax)
09:19:39 <linusoleander> ski: Like this http://i.imgur.com/Y4KX1.png
09:20:04 <linusoleander> Nil nor Cons exists by default in ghci
09:20:06 <timthelion> linusoleander: that's not a type, but a constructor. and yes it exists.
09:20:39 <linusoleander> timthelion: Can i replace Nil with [] and Cons p ps with p:ps?
09:20:49 <linusoleander> Is that the same thing?
09:20:53 <ski> linusoleander : that looks like it's assuming a definition `data List a = Nil | Cons a (List a) deriving (Show,Eq)'
09:21:06 <ski> linusoleander : yes, it's basically the same idea
09:21:09 <timthelion> > Nil == []
09:21:11 <lambdabot>   Not in scope: data constructor `Nil'
09:21:13 <ski> @src []
09:21:14 <lambdabot> data [] a = [] | a : [a]
09:21:32 <dented42> Is there something like threadscope that uses wxhaskell instead of gtk2hs?
09:21:34 <linusoleander> ski: Good, then I get the examples
09:21:44 <linusoleander> thanks
09:22:10 <ski> linusoleander : in the type signature, you'd also need to replace `List Bool' with `[] Bool', alternatively `[Bool]' (which is the usual way to write it)
09:22:42 <linusoleander> ski: Okay, good to know
09:23:02 <ski> (`[Foo]' in types is syntactic sugar for `[] Foo')
09:23:54 <linusoleander> Hehe, I was just about to ask that
09:25:20 <ski> timthelion : does the order in `updates' matter ?
09:26:04 <timthelion> ski: no.
09:27:48 <timthelion> ski: I have a bunch of listeners(threads) and a bunch of sources(values which upon getting set will cause the listeners to do something)  and I just want the listeners to do only one "update" per modification rather than multiple. So I send the listeners a list of which sources have changed, so they know to wait rather than doing wastefull updates.
09:29:03 <timthelion> ski: thus the list of updates is without order, while the list of ids has an order(because the listeners pattern match against a sorted list ^_^ :O)
09:30:38 <ski> thirsteh : instead of `(ids,updates) = unzip pairs; sortedIDs = sortBy (comparing getSourceID) ids' you could then say `(sortedIDs,updates) = unzip (sortBy (comparing (getSourceID . fst)) pairs)' -- only the order of `updates' would be different
09:31:10 * ski wonders whether this improves the situation
09:31:38 <timthelion> It doesn't really matter. because it's not the library code that I care about being pretty, it's the caller code.
09:31:58 <timthelion> https://github.com/timthelion/haskarrow/blob/master/Examples/stm3.haskarrow#L381
09:32:12 <timthelion> note that haskarrow is pretty much the same as haskell.
09:37:25 <ski> btw  ('1':'2':_)  could be written as  '1':'2':_
09:38:11 <timthelion> true.  I tend to err on the side of parentheses, coming from an old elisp addiciton.
09:39:09 <ski> timthelion : anyway, i think your `LoudSourceModification' could be an output monad :
09:39:30 <ski>   data LoudSourceModification a = LoudSourceModification [(SourceID, [SourceID] ->IO ())] a
09:39:37 <ski>   instance Monad LoudSourceModification
09:39:42 <ski>     where
09:39:49 <ski>     return a = LoudSourceModification [] a
09:40:41 <ski>     LoudSourceModification ps0 a >>= k = LoudSourceModification (ps0 ++ ps1) b
09:40:46 <ski>       where
09:40:54 <ski>       LoudSourceModification ps1 b = k a
09:41:14 <timthelion> ski: OK, I'll try it :)
09:41:39 <ski>   doLoudSourceModification :: LoudSourceModification a -> IO a
09:42:07 <timthelion> OK, coool
09:42:08 <ski> will do basically the same as before, except unwrapping the `LoudSourceModification', and also finally returning the `a' which it contains
09:42:13 <ski> then you should be able to say
09:42:24 <ski>   doLoudSourceModification $ do
09:42:41 <timthelion> great !
09:42:46 <ski>     modifyLoudSource source1 (+ 1)
09:42:48 <ski>     modifyLoudSource source2 (+ 1)
09:44:08 <ski> timthelion : note that a shorter way of getting basically the same thing is to say `newtype LoudSourceModification a = LoudSourceModification (Writer [(SourceID, [SourceID] ->IO ())] a) deriving Monad' (using '{-# LANGUAGE GeneralizedNewtypeDeriving #-}')
09:44:33 <ski> that way, you don't have to do the `Monad' instance manually
09:44:50 <timthelion> interesting.  And it's really the same?
09:45:33 <ski> hm, you'd also need to expand `modifyLoudSource' slightly
09:46:06 <timthelion> To make it return a LoudSourceModification?
09:46:14 <ski>   modifyLoudSource :: LoudSource a -> (a -> a) -> LoudSourceModification ()
09:46:16 <ski> yes
09:46:26 <timthelion> Of course :)
09:46:28 <ski> alternatively, if you use the `Writer', you could instead say
09:46:36 <ski>     tell [modifyLoudSource source1 (+ 1)]
09:46:58 <timthelion> aw, that's ugly...
09:47:02 <ski> hm, well i suppose `deriving Monad' should be `deriving (Monad,MonadWriter ([(SourceID, [SourceID] ->IO ())]))'
09:47:44 <ski> timthelion : yes, so it might be nicer to hide that inside `modifyLoudSource' and `modifyLoudSourceIO' :)
09:48:54 <timthelion> ski: you have helped me crack a golden egg :)
09:50:43 <timthelion> ski: You see, I've figured out that STM allows us to do a new kind of data flow programming language(which is what haskarrow is), that is many times more preformant...  And yet I struggle with silly things like the sytax.  I want it to be perfect when it's done.
09:53:18 <ski> timthelion : happy to help :)
10:00:33 <johnw> hmm.. I don't know how, but somehow my ~/.cabal got completely borked.  ghc-pkg won't stop complaining about broken dependencies, no matter how much rebuilding I do.  Looks like I'm going to have to start over. :(
10:01:25 <timthelion> johnw: it doesn't take that long to start over. Sometimes I start over twice a day :( :P :O
10:01:32 <timthelion> :D
10:04:37 <Z`> mm, people. I'm stuck on a silly problem. I have a function f :: [Int] [Int] -> ... I'd like to use map f [Int] so that it operates on all elements of a list. ALso I'd like to pass the other array (which is constant). I'm not sure how to do it
10:05:30 <timthelion> Z`: are you sure that's not f :: [Int] -> [Int] -> ...?
10:05:33 <Z`> er sorry, f is :: Int [Int] -> ...
10:05:56 * timthelion is even more confused by that one and thus will leave it to the "experts"
10:06:12 <Z`> I'm probably wrong at writing the type signature. hold on pls
10:06:39 <raek> Z`: you put "->"s between the argument types
10:06:42 <Z`> getSecondaries :: Int -> [Int] -> ...
10:06:55 <Z`> yeh, sorry. The way I wrote it appeared as a monad ?
10:07:13 <ski> Z` : perhaps you want `zipWith' ?
10:07:28 <geekosaur> well, as a type constructor of some variety
10:07:33 <ski> > zipWith (+) [0,1,2] [100,200,400]
10:07:34 <lambdabot>   [100,201,402]
10:07:41 <geekosaur> not a meaningful one since Int was also being used as a kind-* type
10:07:49 <Z`> let me read on zipWith ski . thanks
10:07:57 <timthelion> Z`: No. it appeared as if a container type named Int a was taking [Int] as an argument.  A monad is just a specific variety of such a container type.
10:08:17 <Z`> a ha. ok, thanks people :) +  sorry for confusion
10:08:32 <ski> Z` : `zipWith' takes a function and two lists, and calls the functions on corresponding elements drawn from the two lists, putting the function results into a new list
10:08:43 <ski> > zipWith (+) [0,1,2] [100,200,400] :: [Expr]
10:08:44 <lambdabot>   [0 + 100,1 + 200,2 + 400]
10:08:49 <ski> > zipWith f [0,1,2] [100,200,400] :: [Expr]
10:08:50 <lambdabot>   [f 0 100,f 1 200,f 2 400]
10:09:07 <ski> Z` : no need to be sorry :)
10:09:14 <Z`> so I should have N copies of the second list, since I want it to pass it to every f call
10:09:33 <Z`> because I want: f 0 list, f 1 list, f 2 list, ... (where list is constant)
10:09:39 <ski> oh
10:10:14 <ski> > map (\x -> f x [2,3,5,7]) [0,1,2,3] :: [Expr]  -- like this ?
10:10:16 <lambdabot>   [f 0 [2,3,5,7],f 1 [2,3,5,7],f 2 [2,3,5,7],f 3 [2,3,5,7]]
10:10:19 <raek> Z`: how many "f n list" elements do you want to have? do you want them collected in a list?
10:10:33 <Z`> yeh, I'd like the result to end up in a list
10:10:38 <Z`> ski: mm, something like that, yeh
10:10:43 <Z`> let me try it (thanks)
10:10:53 <ski> (the `:: [Expr]' is just to tell lambdabot to print it nicely, you wouldn't have that in your code)
10:11:57 <raek> > [ f x [2,3,5,7] | x <- [0,1,2,3] ]
10:11:58 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:11:58 <lambdabot>    `SimpleReflect.FromExpr ...
10:12:12 <ski> > [ f x [2,3,5,7] | x <- [0,1,2,3] ] :: [Expr]
10:12:14 <lambdabot>   [f 0 [2,3,5,7],f 1 [2,3,5,7],f 2 [2,3,5,7],f 3 [2,3,5,7]]
10:12:23 <raek> ehr. yeah. :)
10:12:25 <ski> Z` : yes, a list comprehension as raek suggested above is an alternative
10:12:35 <Z`> cool,. I like alternatives.thanks.
10:13:12 <lpvb> aww, now Expr in ghc
10:13:16 <lpvb> no*
10:14:14 * ski . o O ( /etc/alternatives/Z` )
10:15:15 <mysticc> @hoogle uncons
10:15:16 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
10:15:16 <lambdabot> Data.ByteString.Lazy.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
10:15:16 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
10:16:00 <johnw> ski: :)
10:17:08 <mysticc> @hoogle countIf
10:17:08 <lambdabot> No results found
10:20:57 <ski> `countIf' ?
10:25:57 <mysticc> @hoogle toLower
10:25:57 <lambdabot> Data.Char toLower :: Char -> Char
10:25:57 <lambdabot> Data.Text toLower :: Text -> Text
10:25:57 <lambdabot> Data.Text.Lazy toLower :: Text -> Text
10:25:58 <merijn> I don't suppose there's a (convenient) way to write values with a type of kind Nat?
10:26:04 <mysticc> ski: Nothing
10:27:33 <merijn> I have a function that uses type level naturals and I have some typeclasses/functions whose type depends on values of those type level naturals
10:28:05 <c_wraith> merijn: values have types with kind *.  that hasn't changed, as far as I know
10:28:06 <merijn> So I want to be able to write "foo someConstant" where the type of foo depends on the type of someConstant
10:28:29 <merijn> c_wraith: I use my own types atm, not promoted literals (I'm using 7.4)
10:28:52 <merijn> So I'd have to write "foo (undefined :: S (S (S Z)))" to get what I want
10:29:16 <c_wraith> well, you could use a proxy type - but that doesn't change much except getting rid of undefined
10:29:17 <merijn> I was hoping for a slightly nicer way, since I can't write "Int -> (* :: Nat)" without dependent types :p
10:30:41 <merijn> It seems it should be possible to have something like "'4 :: 4" using promoted literals
10:32:57 <Ralith> merijn: you can't write Set : Nat with dependent types, either.
10:32:59 <Ralith> :P
10:33:41 <Ralith> perhaps you're thinking of (n : Nat) -> (Fin n)?
10:33:44 <shachaf> merijn: Still on this, are you?
10:34:09 <shachaf> You still haven't told me what it would mean to have a value whose type has a kind other than *!
10:34:55 <merijn> shachaf: Actually, no. I solved the problems I had this morning quite elegantly using GADTs and TypeFamilies :)
10:35:24 <merijn> shachaf: This is just something I want to use with that :p
10:35:33 <mysticc> @hoogle isUpper
10:35:34 <lambdabot> Data.Char isUpper :: Char -> Bool
10:36:16 <ski> merijn : maybe you could use `Proxy'
10:37:37 <merijn> shachaf: elegant being that I replaced about 120 lines of MultiParamTypeClass with associated type families and really ugly instances with about 40 lines consisting of zero typeclasses 2 GADTs and 1 type family while being more type correct and easier to program xD
10:37:58 <copumpkin> > let ಠ_ಠ = 5 in ಠ_ಠ
10:37:59 <lambdabot>   5
10:38:42 <merijn> copumpkin: ?
10:39:52 <merijn> ski: What do you mean by Proxy? "haskell proxy" is not very useful as a google term...
10:43:58 <sully> @pl \x y -> f (g x y)
10:43:58 <lambdabot> (f .) . g
10:46:32 <ski> @hackage tagged
10:46:33 <lambdabot> http://hackage.haskell.org/package/tagged
10:46:40 <ski> merijn : i was thinking about the one in that
10:46:49 <ski> sully : aka `f .: g'
10:47:48 <mysticc> @hoogle Word8 -> ByteString
10:47:49 <lambdabot> Data.ByteString.Lazy repeat :: Word8 -> ByteString
10:47:49 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
10:47:49 <lambdabot> Data.ByteString.Lazy singleton :: Word8 -> ByteString
10:48:17 <merijn> ski: I'll take a look, that looks close to what I'm doing anyway (statically checking the correct number of arguments to pass to a function of arbitrary arity)
10:48:39 <nejucomo> @pl \x y z -> f (g x y z)
10:48:39 <lambdabot> ((f .) .) . g
10:48:57 <nejucomo> :t .:
10:48:59 <lambdabot> parse error on input `.:'
10:49:01 <nejucomo> :t (.:)
10:49:03 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
10:49:24 <merijn> What I wanted to implement is a tuple/list of function representations and then looks up in there (where the type obviously depends on the index you're retrieving, which is not a problem for statically known lists and indexes)
10:49:33 <ski> @type let (.) = (Prelude..); (.:) = (.) . (.) in (.:)
10:49:34 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:49:47 <ski> @type let (.) = (Prelude..); (f .: g) x y = f (g x y) in (.:)
10:49:49 <merijn> But writing indexes of the form "undefined :: S (S (S Z))" is just so cumbersome
10:49:49 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3 -> t) -> t2 -> t3 -> t1
10:50:10 <shachaf> merijn: GHC 7.6 has type-level Nat literals!
10:50:26 <ski> nejucomo : `\x y z -> f (g x y z)' would be `(.::)', &.
10:50:49 <ski>   (.::) = (.) . (.) . (.)
10:51:03 <merijn> shachaf: I know, but I don't have 7.6 and that just changes it from "undefined :: S (S (S Z))" to "undefined :: 3", I'd prefer something like "'3", although I fear I don't get much influence there :p
10:51:08 <nejucomo> shachaf: Yes, it has user-defined kinds of some sort.
10:51:09 <ski> (which should hopefully explain the name choice)
10:51:20 <fmap> Is it possible to generate lenses for GADTs?
10:51:23 <nejucomo> (I don't mean "sort" in a technical term there...  ;-)
10:51:26 <donri> edwardk: why isn't there a <+= stateful increment with pass-through? :(
10:51:32 <edwardk> fmap: by hand
10:51:40 <edwardk> donri: what do you mean?
10:51:47 <fmap> edwardk: okay, thanks
10:52:12 <edwardk> <+= increments state, what do you also want it to do?
10:52:23 <edwardk> it tells you what it changed it to
10:52:27 <donri> edwardk: like += but like <.=
10:52:34 <edwardk> there is <+=
10:52:39 <donri> i don't see a <+= operator in .Setter, hm
10:52:52 <merijn> edwardk: Speaking of type wizardry, maybe you can give me an idea on how to best do what I want? :p
10:52:52 <edwardk> its not a setter operation, its necessarily a Lens operation
10:52:57 <mysticc> Is there a isUpper,isLower,toUpper etc for Word8 ?
10:53:01 <shachaf> donri: Just import Control.Lens
10:53:06 <edwardk> <.= is able to work with a setter because it knows what the new value is ;)
10:53:13 <donri> shachaf: yea was reading haddocks
10:53:22 <edwardk> <+= needs to work with a Lens because it needs to see the old value in a way it can tell you about it
10:53:25 <shachaf> donri: :i <+= in ghci. :-)
10:53:27 <edwardk> a Setter might be modifying an infinite number of things
10:53:44 <glguy> mysticc: There shouldn't be. What are you trying to do?
10:53:51 <edwardk> (technically (<+=) works with a Traversal, but probably not in the way you'd expect
10:55:13 <merijn> edwardk: I'm doing indexing in a heterogenous list (on the type level via "undefined :: S (S Z)", so the types can be determined statically), but writing the indexes is cumbersome. Do you have any clue how I could have "nicer" ways of producing indexing values?
10:55:37 <edwardk> merijn: 7.6.1 type lits?
10:56:29 <merijn> ok, I guess the unanimous solution is to install 7.6 and use undefined then >.>
10:57:49 <merijn> When is 7.6 appearing in HP? :p
10:58:17 <edwardk> merijn: couple of months from now
10:58:29 <donri> edwardk: alright thanks
10:59:03 <edwardk> donri: one of the examples in the readme is fresh = id <+= 1
10:59:05 <edwardk> =)
10:59:38 <donri> aha
11:00:30 <Z`> people, is [Char] equivalent to String ?
11:00:53 <merijn> Z`: Yes
11:01:14 <Z`> so in a type signature I could replace for example [Char] with String ?
11:01:16 <tromp_> it *is* String
11:01:41 <tromp_> yes, no wau to distinguish one from other
11:01:43 <Ralith> they are freely interchangable in all contexts save the definition of String itself.
11:01:50 <Z`> thank you
11:02:21 <edwardk> hrmm. if i added  Projection f g . Projection h i = Projection (unsafeCoerce f . unsafeCoerce h) (unsafeCoerce (unsafeCoerce i Prelude.. unsafeCoerce g))  do you think that would improve peoples confidence in my lens library?
11:07:19 <lpvb> @src String
11:07:19 <lambdabot> type String = [Char]
11:17:14 <yitz> edwardk: sure, just mark it Trustworthy in Safe Haskell.
11:17:33 <edwardk> yitz: i already did ;)
11:17:49 <yitz> good work! ;)
11:18:13 <edwardk> (it actually is safe, ghc is just being paranoid)
11:18:33 <yitz> it's not safe, but it's trustworthy.
11:19:02 <edwardk> well, what i mean is the unsafeCoerce's hould be necessary, but i can't convince ghc of that fact
11:20:43 <copumpkin> {-# LANGUAGE WrittenByEdKmett #-}
11:20:54 <edwardk> copumpkin: and copumpkin
11:21:19 <edwardk> (as he sits here denying his involvement)
11:22:21 <shachaf> He never kmett an extension he didn't like.
11:22:57 <edwardk> i've kmett plenty of extensions i don't like. remember, i spent most of the last couple of years trying to keep everything haskell 98 ;)
11:23:01 <hpaste> copumpkin pasted “whee” at http://hpaste.org/74636
11:23:10 <edwardk> copumpkin++
11:23:30 <edwardk> we just need to add the instances for typenats
11:23:39 <edwardk>  Rounded TowardZero (Bits 512)
11:23:53 <shachaf> copumpkin: Hah.
11:23:54 <thoughtpolice> i'll be happy when the constraint solver goes in
11:24:06 <edwardk> thoughtpolice: yeah
11:24:33 <thoughtpolice> also edwardk, thanks for that post on free monads for less. i ended up doing ezyang's exercises on the codensity transformation and reading through your posts some yesterday, it was a lot of fun.
11:24:43 <edwardk> thoughtpolice: =)
11:24:55 <shachaf> What exercises?
11:24:57 <edwardk> np
11:25:25 <Cale> Haha, I just saw edwardk's line before shachaf's and I thought "Did edwardk just use his own last name as a verb?"
11:25:25 <thoughtpolice> shachaf: http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
11:25:51 <edwardk> i'm sorry, have we kmett before?
11:26:28 <c_wraith> ...  is that a terrible pun?
11:26:34 <c_wraith> or just a horrible pun?
11:26:45 <shachaf> c_wraith: What's the difference, eh?
11:26:53 <shachaf> The beauty of the pun is in the Oy of the beholder.
11:27:18 <shachaf> @brain
11:27:18 <lambdabot> I think so, Brain, but there's still a bug stuck in here from last time.
11:27:41 <thoughtpolice> edwardk: i haven't read through the one on yoneda yet, i'm still working through just doing some of the reasoning on the definitions i wrote for codensity (i did get them all except for the 'MonadFree f (Codensity m)' instance which i cheated on.) they all typecheck and thus work :P (i'd speculate the implementations i wrote may be the only term that satisfies that type, but i can't prove that, only intuit it.)
11:28:24 <t7> whats goin on at icfp?
11:28:28 <edwardk> thoughtpolice: the nice thing is the reasoning is exactly the same for Cont
11:31:03 <Z`> mm, I'm sure it's something obvious, but.. this line works:  let foo = do { allLines <- readFile "myfile"; let x = getSecondaries "0x12" allLines in return x; } but if I put between those 2 this: let lines = map processLine allLines; then it fails with parse error on input `;'
11:31:34 <thoughtpolice> edwardk: yeah that's what i picked up on, Codensity is basically cont as you can tell from the underlying type signature (modulo the fact 'r' is quantified over in the constructor so you can't callCC it.) i guess i just never use Cont, it's a very big hammer i've never needed :)
11:31:58 <thoughtpolice> which was probably why it was so tricky. most of the definitions fell out once i started writing down all the types in scope and just trying to unify manually
11:32:18 <edwardk> thoughtpolice: yeah its _so_ much easier to work in CPS in agda than it is in haskell
11:32:31 <edwardk> thoughtpolice: because of the holes. hopefully ghc will catch up a bit soon
11:32:33 <Botje> Z`: that should just work. did you write your program like that, all on one line?
11:32:42 <Botje> Z`: otherwise tabs/spaces are the usual suspect.
11:32:44 <dmwit> ugh, what idiot decided to install 7.6 on my machine
11:32:53 <Z`> yes, all on one line. ah mm, ok, I'll check again. Thank you Botje for caring
11:33:10 <thoughtpolice> edwardk: i know enough agda to use holes, and yes, i really, really wanted that extension when i was writing code yesterday.
11:33:18 <thoughtpolice> i actually thought that exact thing :)
11:33:34 <edwardk> i got a lot better at writing haskell by writing so much code cps'd
11:33:42 <thoughtpolice> there's a way you can trick GHC into giving you the expected type as an error using implicit parameters i think
11:33:46 <thoughtpolice> but i can't remember what it is
11:33:47 <copumpkin> > pi ^ 500 :: CReal
11:33:51 <lambdabot>   mueval-core: Time limit exceeded
11:33:51 <shachaf> thoughtpolice: I sometimes make pseudo-holes by doing "...blah..." and then top-level "blah = ?foo"
11:33:53 <copumpkin> > pi ^ 500 :: CReal
11:33:57 <lambdabot>   mueval-core: Time limit exceeded
11:34:02 <shachaf> Then GHC gives me a type error that says ?foo is unbound, and what type it should have.
11:34:02 <copumpkin> well I guess that's a point in favor of MPFR
11:34:03 <thoughtpolice> edwardk: yes, it flexed my reasoning muscles quite a bit, holes would help take away a lot of the tedium i encountered
11:34:03 <edwardk> yeah you can use ?foo x y z   and the error about foo gives you the signature
11:34:26 <shachaf> (Hmm, maybe it doesn't need to be top-level...)
11:35:48 <thoughtpolice> edwardk: maybe that extension will make it in by ghc 7.8 :) i could also wish for a lot of other things, too (possibly including ponies)
11:36:24 <ski> @type all ?f "abcd"
11:36:25 <lambdabot> (?f::Char -> Bool) => Bool
11:36:26 <edwardk> there is a repo out there where some folks are slowly building them up
11:36:46 <thoughtpolice> yeah, i saw some stuff fly by on cvs-ghc about it recently
11:36:59 <Philippa> I'm not sure ponies belong in GHC. The Platform, however...
11:41:24 <Saizan> and they better not be unicorns
11:48:35 <Cale> thoughtpolice: It would be so funny to package the pony program from Hackage with GHC.
11:48:36 <Z`> one more question please. I usually write:   filter (\x -> ...) $ map f list , but this is backwards logic in my mind, because first I map f into the list, then filter the results. Can I rewrite it as a composigion ?
11:48:40 <Z`> composition*
11:49:05 <Z`> (or somehow else)
11:49:09 <shachaf> What does a composition have to do with it?
11:49:10 <Cale> Z`: how is it backwards?
11:49:12 <Cale> What?
11:49:16 <shachaf> Do you mean that you want it from left to right?
11:49:30 <Cale> [f x | x <- list, ...]
11:49:33 <Clint> he wants to filter the results before he has them
11:49:34 <startling> Z`: you could do it with composition, yeah: "filter myfn . map f $ list", but that's not what you want
11:49:37 <Cale> is that what you want?
11:49:37 <Z`> I'd like to write something like: map f list <some magic here> filter (\x -> ...)
11:49:52 <Botje> Z`: map f >>> filter (...) $ list
11:49:54 <shachaf> Z`: Yes, you can do that, but it's somewhat unidiomatic.
11:49:54 <Eduard_Munteanu> :t (>>>)
11:49:56 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
11:50:00 <Cale> uhh...
11:50:06 <shachaf> list |> map f >>> filter ...
11:50:06 <Botje> Z`: note that people will hate you for it :)
11:50:16 <Cale> map f (filter (\x -> ... f x ...) list)  ?
11:50:25 <startling> Z`, a map and a filter can be done in one pass with a fold
11:50:26 <Cale> is that what you want?
11:50:26 <startling> fyi
11:50:31 <Z`> wow, really ? but I read from left to right. so it is more reasonable (for me) to have map firsr then filter
11:50:47 <Cale> Z`: If it helps, the code evaluates left to right
11:50:49 <Botje> Z`: blame whoever invented function composition :)
11:50:55 <shachaf> Cale: Well, Haskell function application isn't really left-to-right.
11:50:57 <shachaf> s/Cale/Z`/
11:51:04 <Z`> I don't want you to hate me. So I'll comply.
11:51:05 <Cale> If you have  f (g x)  then f is evaluated first
11:51:11 <shachaf> You say "map f x" instead of "x f map"
11:51:14 <Botje> If you read '.' as 'after' it's not so bad
11:51:20 <Cale> and the expression g x is supplied as a parameter
11:51:21 <shachaf> x is to the right of "map f". :-)
11:51:29 <Botje> map f AFTER filter ...
11:51:30 <appamatto> ST monad is blowing my mind
11:51:33 <Botje> works for me
11:51:53 <Cale> Z`: Did you ever encounter functions in school?
11:52:06 <Z`> Cale: yes
11:52:09 <Cale> The notation is in the same order as functions in school :)
11:52:10 <Botje> appamatto: did you receive your complementary package of duct tape and painkillers?
11:52:32 <shachaf> Cale: It might be more sensible if application was written "f x"!
11:52:35 <shachaf> Er.
11:52:37 <shachaf> Cale: It might be more sensible if application was written "x f"!
11:52:49 <Z`> Cale: in school also struck me as awkward. because you read f(g(x)) as "f applied to the result of g to x"
11:53:15 <Cale> Z`: Or just f of g of x
11:53:23 <appamatto> Botje, haha. Learning about ST is not instilling a desire to learn it, but rather just amazed at how mutability is given a pure interface in Haskell
11:53:32 <appamatto> desire to use it rather
11:53:33 <thoughtpolice> Cale: that would actually be great :)
11:53:39 <Eduard_Munteanu> Chasing arrow diagrams is a bit strange using the standard composition / notation.
11:53:40 <Z`> so you read from outside to inside, but "actions" happens towards the opposite direction (from inside to outside)
11:54:09 <Eduard_Munteanu> Or commutative diagrams, whatever.
11:54:19 <Cale> Z`: actually, they happen from the outside to the inside as well, in Haskell
11:54:26 <shachaf> Z`: Read it however you like.
11:54:30 <Cale> Or at least, usually
11:54:42 <Cale> (Haskell doesn't actually specify the evaluation order)
11:54:45 <hiptobecubic> Botje, can i ask you a dutch question? It's from my stats book and I don't follow the grammar. pm?
11:54:57 <Cale> But under lazy evaluation, which is common, it's outermost-first
11:55:10 <shachaf> Z`: But it's worthwhile getting used to the standard way it's written, if you're hoping to be able to read anyone else's code. :-)
11:55:40 <Botje> hiptobecubic: i can give it a shot, but stats is now five years ago :)
11:55:41 <shachaf> Cale: What you're saying is true but I suspect it's not very helpful for Z`'s complaint...
11:55:48 <Cale> So you should see something like  filter p (map f xs)  as first starting to filter a list, which it's going to determine one element at a time by mapping the function f over the list xs
11:55:54 <Z`> It' like unix pipes: doSomething | thenAnotherThing | thenTheLastThing, or F#'s |> operator
11:56:15 <Z`> I'm not complaining. I can comply with standard notation. Just wondering.
11:56:17 <matthavener> what's the idiomatic way to read two TVars in a transaction?
11:56:26 <Cale> Z`: When you run the unix pipe  p | q | r  which program runs first?
11:56:34 <Cale> Do you know? :)
11:56:41 <Z`> Cale: p ?
11:56:41 <lpvb> I'm more comfortable with f then g then x, I don't know why you aren't
11:56:45 <Cale> nope!
11:56:48 <lpvb> f of g of x
11:56:54 <shachaf> matthavener: Two uses of readTVar?
11:57:02 <lpvb> f applied to g applied ot x
11:57:26 <Z`> Cale: which one ?
11:57:28 <dmwit> Huh, where are you supposed to get "try" from these days?
11:57:45 <shachaf> Control.Exception?
11:57:46 <matthavener> shachaf: yeah
11:57:48 <roconnor> matthavener: atomically ((,) <$> readTVar x <*> readTVar y) ?
11:58:23 <shachaf> You can do what roconnor said if you want.
11:58:32 <dmwit> urgh
11:58:34 * roconnor wonders if there is a zipA to do this?
11:58:45 <Cale> Z`: I am reasonably certain that it runs r first :)
11:58:48 <dmwit> It's expecting the one from Control.OldException, I think, but Control.OE doesn't exist any more.
11:58:57 <dmwit> I'll just wait until happy is upgraded.
11:59:07 <shachaf> dmwit: That's what I'm doing.
11:59:08 <Cale> Z`: The data flows from p to q to r, sure
11:59:09 <matthavener> roconnor: thank you, now gotta figure out what that means :)
11:59:21 <shachaf> dmwit: A bunch of things are broken. :-(
11:59:33 <roconnor> matthavener: It is a bit more obsurce than I'd like
11:59:53 <shachaf> matthavener: atomically $ do { xv <- readTVar x; yv <- readTVar y; return (xv,yv) }
12:01:02 <appamatto> What language are the .lhs files of ghc in?
12:01:10 <Cale> Z`: though really it doesn't usually matter what order the programs are started in
12:01:15 <roconnor> appamatto: literate haskell
12:01:18 <hiptobecubic> appamatto, literate haskell
12:01:21 <hiptobecubic> damn
12:01:42 <matthavener> shachaf: and you can embed a do statement in another do statement?
12:01:45 <Botje> 'swahili' was not the right answer, apparently.
12:01:50 <matthavener> phrased that question weirdly
12:01:55 <shachaf> matthavener: do isn't a statement.
12:02:00 <appamatto> Oh nice.
12:02:02 <startling> matthavener: but yes
12:02:10 <matthavener> do is an expression?
12:02:12 <shachaf> matthavener: But anyway, do is a very mechanical transformation.
12:02:19 <matthavener> still learning the nomenclature
12:02:23 <shachaf> @undo do { xv <- readTVar x; yv <- readTVar y; return (xv,yv) }
12:02:23 <lambdabot> readTVar x >>= \ xv -> readTVar y >>= \ yv -> return (xv, yv)
12:02:30 <shachaf> What I wrote just turns into that.
12:02:40 <shachaf> Then it's type-checked.
12:02:40 <appamatto> Is llvm a decent backend for ghc?
12:03:05 <shachaf> matthavener: If you want to use STM, nesting "do" will probably be very helpful. :-)
12:03:38 <Ralith> appamatto: yes.
12:03:54 <boegel> test?
12:03:56 <boegel> hmm
12:05:00 <Cale> Z`: actually, it's totally nondeterministic in my current bash :)
12:05:27 <Z`> Cale: cool. nice to know. Still I miss F#'s |>
12:05:28 <Cale> Z`: (I recall a time where it was consistently in reverse order, but that no longer seems true -- it's completely concurrent)
12:05:40 <hpaste> staticshock pasted “Ambiguous type variable” at http://hpaste.org/74639
12:05:44 <Cale> and this reflects the fact that it actually doesn't matter which runs first
12:05:46 <Z`> heh, perhaps it's one is given each own thread ?
12:05:48 <Z`> its*
12:05:50 <Cale> yes
12:05:53 <staticshock> can someone help me figure out where my type problem is?
12:05:55 <Cale> well, they're separate processes
12:06:21 <shachaf> staticshock: Not if you don't say what it is.
12:06:27 <Botje> staticshock: fromIntegral n / 12
12:06:33 <Botje> uh..
12:06:33 <staticshock> Botje: thanks, trying
12:06:39 <Botje> fromIntegral n / primeFactor
12:06:43 <Botje> on line 5
12:06:44 <Cale> The shell starts all the processes almost at once, and whichever order the kernel schedules things in determines who gets to run first
12:06:45 <staticshock> right
12:07:16 <Eduard_Munteanu> shachaf: I was about to make a similar comment, but noticed his paste :)
12:07:17 <staticshock> Botje: so / takes two floats?
12:07:36 <staticshock> Botje: or can the denominator be an int?
12:07:41 <Botje> staticshock: / takes two numbers that belong to Fractional
12:07:51 <Cale> Z`: But there are two orders which are really important for understanding how Haskell code works: one is left to right, and the other, less important one, is right to left :)
12:08:00 <Botje> staticshock: and the Fractional and Integral type classes are (conceptually, at least) mutually exclusive.
12:08:14 <Cale> In F#, when you write x |> f, it's really going to evaluate x first, and then apply f to it
12:08:23 <Cale> or whatever it is
12:08:28 <staticshock> so it should really be fromIntegral n / (fromIntegral primeFactor)
12:08:52 <hiptobecubic> What is the difference between implication and logical entailment? I don't see how they are different at all.
12:08:57 <Cale> Z`: in Haskell, functions evaluate usually before their arguments
12:08:57 <Heffalump> not only that, but it might use the type of x to help it infer which f you mean
12:09:08 <staticshock> Botje: i'm really just trying to do truncating integer division, is there a quicker way?
12:09:27 <Botje> staticshock: n `div` primeFactor
12:09:29 <Cale> hiptobecubic: "A implies B" refers to a statement inside the logic (a string or expression tree or whatever)
12:09:33 <staticshock> thanks!
12:09:43 <shachaf> staticshock: Oh, sorry!
12:09:47 <Cale> hiptobecubic: "A" entails "B" is a statement *about* the logic
12:09:48 <Z`> Cale: because f g h x is in haskell ((f g) h) x ?
12:09:53 <appamatto> I heard that ghc 7 (?) has some non-blocking IO enhancements
12:10:03 <hiptobecubic> It loosely relates. I'm trying to implement propositional logic
12:10:05 <appamatto> Are these exposed to the programmer, or just transparently applied?
12:10:07 <Heffalump> z`: it's the same bracketing in F#
12:10:22 <dmwit> appamatto: If you mean the new IO manager, it's all transparent.
12:10:39 <Cale> Z`: bracketing and evaluation order are separate
12:10:42 <hiptobecubic> Cale, so how does A entails B mean something other than A -> B?
12:10:48 <Cale> Z`: suppose we have this program:  double x = x + x
12:10:54 <Heffalump> the difference is that F# defines that function arguments are evaluated before the function is called
12:11:19 <Heffalump> whereas Haskell doesn't
12:11:22 <tdammers> hmm... haskell-platform failed to build
12:11:35 <shachaf> @yarr http://ww.reddit.com/r/haskell/comments/ywula/yet_another_reason_not_to_be_lazy_or_imperative/c5znykk
12:11:35 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
12:11:38 <tdammers> "Building the OpenGL-2.2.3.1 package failed"
12:11:59 <Cale> hiptobecubic: Imagine a string rewriting system. "A implies B" is one of the strings which we're manipulating, and "A" entails "B" means that we can rewrite the string "A" according to the rules of our system to obtain the string "B"
12:12:07 <tdammers> (GHC 7.6, debian 'squeeze')
12:12:08 <appamatto> dmwit, are the IO manager changes explained anywhere online?
12:12:11 <tdammers> any ideas?
12:12:20 <dmwit> I'm sure there's a paper about it.
12:12:28 <dmwit> tdammers: Scroll up for the exact error.
12:12:42 <tdammers> Graphics/Rendering/OpenGL/GL/VertexArrays.hs:575:1:
12:12:42 <tdammers>     Unacceptable argument type in foreign declaration: AttribLocation
12:12:42 <tdammers>     When checking declaration:
12:12:42 <tdammers>       foreign import ccall unsafe "dynamic" dyn_glEnableVertexAttribArrayARB
12:12:42 <tdammers>         :: Invoker (AttribLocation -> IO ())
12:12:47 <Cale> hiptobecubic: It's *usually* a theorem that the empty set of assumptions entails "A -> B" if and only if "A" entails "B"
12:12:56 <tdammers> And about 12 more like it
12:13:04 <Heffalump> where can I find functions for encoding and decoding strings to bytestrings using the current locale?
12:13:04 <dmwit> tdammers: Probably AttribLocation doesn't export its constructor.
12:13:07 <dmwit> err
12:13:23 <dmwit> My language was a bit imprecise.
12:13:35 <Cale> Z`: sorry... okay, so double x = x + x, and suppose we evaluate  double (double 5)
12:13:53 <dmwit> Probably AttribLocation's constructor isn't in scope (either because the module that defined it doesn't export it or the module with the error doesn't import it).
12:13:58 <Cale> Z`: Under strict evaluation, we would go like this:
12:14:00 <Cale> double (double 5)
12:14:04 <Cale> -> double (5 + 5)
12:14:06 <Cale> -> double 10
12:14:10 <Cale> -> 10 + 10
12:14:11 <Cale> -> 20
12:14:16 <tdammers> it's the official haskell-platform distribution, so I suppose it would build cleanly given the right environment
12:14:31 <tdammers> maybe I should try ghc 7.4 instead...
12:14:38 <Cale> Z`: Strict evaluation is innermost-first: we evaluate the arguments to a function before evaluating the function application
12:14:48 <Cale> Z`: but we can also evaluate this thing outermost-first
12:14:51 <merijn> tdammers: haskell platform still uses 7.4
12:14:54 <Cale> double (double 5)
12:14:54 <shachaf> Cale: You've relapsed. :-(
12:14:59 <Cale> -> (double 5) + (double 5)
12:15:08 <Cale> -> (5 + 5) + (double 5)
12:15:09 <merijn> tdammers: It will move to 7.6 on the next release, most likely
12:15:13 <Cale> -> 10 + (double 5)
12:15:16 <Cale> -> 10 + (5 + 5)
12:15:20 <Cale> -> 10 + 10
12:15:22 <Cale> -> 20
12:15:25 <tdammers> merijn: I figured, but I had already downloaded & instaled 7.6, and I was hoping I could avoid the extra download
12:15:28 <Cale> shachaf: ?
12:15:47 <hiptobecubic> Cale, so if A->B is a tautology, then A entails B?
12:15:54 <tdammers> I'm building a dedicated build server, so it doesn't matter *that* much, really, just annoying that I have to go through all the steps again
12:16:02 <Cale> Z`: this obviously has wasted work, in that we evaluated the expression double 5 twice, because x occurred twice in the body of double
12:16:06 <shachaf> Cale: It's been quite a while since I've seen a double-double-5.
12:16:15 <Cale> hiptobecubic: *usually*
12:16:22 <hiptobecubic> Cale, when no?
12:16:24 <hiptobecubic> not*
12:16:49 <Cale> hiptobecubic: when the rules for implication in our logic are weird
12:17:22 <Cale> hiptobecubic: |- A -> B means that starting from nothing, we can prove the statement that A implies B
12:17:41 <Cale> hiptobecubic: A |- B means that starting from A, we can prove B
12:17:51 <hiptobecubic> aha
12:17:54 <dmwit> hiptobecubic: When your logic sucks.
12:17:57 <hiptobecubic> That makes more sense
12:18:14 <hiptobecubic> Cale, thanks. Very helpful.
12:18:16 <dmwit> (or when it's just a weird logic)
12:18:22 <hiptobecubic> dmwit, less so ;)
12:25:25 <bartavelle> I have a design problem. I would like to "fmap read (readFile filename)", but depending on a command line argument the data will be of a different type
12:25:40 <bartavelle> then it is fed to polymorphic functions so that it works for all cases
12:25:52 <bartavelle> except it seems I'll have to write code for each version
12:25:59 <bartavelle> is there a trick to this ?
12:26:23 <hiptobecubic> bartavelle, what is the problem?
12:26:25 <dmwit> No trick. You have to write code for each version.
12:26:35 <bartavelle> ah this will look ugly
12:26:43 <hiptobecubic> dmwit, won't read read the appropriate type?
12:26:50 <Ralith> Haskell does not include a magically-guess-the-type-encoded-in-some-string feature.
12:26:51 <Cale> Z`: anyway, what I was going to say before is that lazy evaluation is outermost-first evaluation, except that we share the result of evaluating the argument to a function between all the occurrences of the parameter in the body of the function
12:26:59 <Cale> Z`: so it looks like:
12:27:00 <dmwit> hiptobecubic: It should, yup.
12:27:01 <bartavelle> Ralith, not my point, I do know the type
12:27:03 <Cale> double (double 5)
12:27:03 <hiptobecubic> Ralith, no, but based on the type of the function that's using it
12:27:16 <Cale> -> let x = double 5 in x + x -- note that this is still outermost-first
12:27:19 <Ralith> bartavelle: if you do know the type, then why is it polymorphic?
12:27:24 <Cale> -> let x = 5 + 5 in x + x
12:27:27 <Cale> -> let x = 10 in x + x
12:27:29 <Ralith> hiptobecubic: correct
12:27:29 <bartavelle> because I know the types actually :)
12:27:31 <dmwit> The continuation is polymorphic, not the value.
12:27:40 <bartavelle> it is "Record a"
12:27:41 <Cale> -> 10 + 10 -- may or may not be a real step
12:27:45 <Ralith> bartavelle: you have to tell Haskell what you know.
12:27:46 <merijn> Ralith: It can, if you don't mind being stoned by other programmers :p
12:27:47 <Cale> -> 20
12:27:54 <Ralith> merijn: haha, true
12:27:55 * hackagebot VKHS 0.1.1 - Provides access to Vkontakte social network, popular in Russia  http://hackage.haskell.org/package/VKHS-0.1.1 (SergeyMironov)
12:28:02 <merijn> Ralith: i.e. you can use OverloadedStrings + an IsString instance to do that
12:28:23 <Ralith> merijn: or a variety of other horrifying hacks.
12:28:27 <Cale> Z`: do you get what I'm saying? The actual order in which things occur is really the order in which they appear on the page :)
12:29:06 <Cale> (at least approximately)
12:29:08 <Z`> Cale: not quite, but I will study the log again . Thanks
12:29:15 <dmwit> bartavelle: Usually it's as easy as writing a polymorphic producer and a polymorphic consumer, then writing a quick case statement with the same code in each branch but appropriate type annotations attached.
12:29:27 <dmwit> bartavelle: If you can shoehorn all the data into the same type, everything gets easier, of course.
12:29:35 <dmwit> Either and friends can be helpful here.
12:31:10 <merijn> bartavelle: Maybe you could manage to do it with a phantom type based on the commandline argument
12:31:20 <bartavelle> I heard of phantom types
12:31:29 <bartavelle> not sure what they are
12:31:37 <bartavelle> except painful
12:31:46 <merijn> bartavelle: They're a type with no associated value (i.e. incorporeal :p)
12:31:56 <bartavelle> can it be used to "pass a type as an argument", then cast my read with that type ?
12:32:10 <merijn> bartavelle: An example would be "data Expr a = I Int | B Bool | Add (Expr a) (Expr a)"
12:32:33 <merijn> bartavelle: "toInt :: Int -> Expr Int; toInt = I"
12:32:58 <merijn> bartavelle: Here the a is unrelated to the values in the Constructors, but you can still use it in type signatures
12:33:32 <bartavelle> ah yes
12:33:43 <bartavelle> but can I use a type signature for my function inside it ?
12:33:44 <merijn> bartavelle: For example "readVal :: String -> Expr a -> a; readVal str _ = read str"
12:34:08 <bartavelle> ahhh
12:34:22 <bartavelle> Ok will try that
12:34:52 <merijn> bartavelle: It becomes a bit more useful with GADTs, but those make more sense after you've tried this way and become stuck (because then it is easier to see the problem GADTs solve)
12:35:17 <dmwit> It's not clear to me that phantom types help at all here.
12:35:18 <shachaf> @wiki Phantom type
12:35:18 <lambdabot> http://www.haskell.org/haskellwiki/Phantom_type
12:35:54 <lpvb> why would one use a mutable array over an immutable one?
12:36:23 <dmwit> Now that's an unusual question.
12:36:25 <merijn> dmwit: Well, if you can have "data Select a" and create a "Select a" with the appropriate type based on the commandline args, then you can use a similar read trick to solve the issue
12:36:28 <dmwit> For efficiency of writes.
12:36:36 <merijn> dmwit: Whether that's worth it...it would depend
12:36:48 <dmwit> merijn: You can't return a "Select a" with a monomorphic (but runtime-chosen) type.
12:36:51 <lpvb> dmwit: just making a new array isn't as efficient?
12:36:56 <dmwit> lpvb: Correct.
12:37:08 <lpvb> why is that?
12:37:22 <dmwit> Because copying an array takes longer than not copying an array.
12:37:34 <lpvb> but they aren't really copied in the background are they?
12:37:39 <lpvb> not most of the time?
12:37:42 <dmwit> Yes. How else would you do it?
12:38:21 <lpvb> I read that it optimizes copying into updating the data structure
12:38:40 <dmwit> What is "it"?
12:38:52 <lpvb> GHC
12:39:47 <bartavelle> dmwit, actually it can help, I can return the result of my read in a tuple with my original result
12:39:50 <dmwit> I'm sort of skeptical of this, except in some special cases.
12:39:54 <bartavelle> it is not a phantom type at all
12:40:04 <Z`> http://paste.lisp.org/display/131797 quick question on cosmetic stuff
12:40:06 <bartavelle> just I didn't figure this out
12:40:50 <dmwit> Z`: I like the former better than the latter; I like a single let better than the former; and I like where better than let.
12:41:25 <Z`> How could you rewrite it with a single let ? (also how would you rewrite it with where?)
12:41:41 <dmwit> ...and I like "allLeafs = nubBy (==) . map last . breakConditionals" best of all.
12:42:10 <Z`> thanks
12:43:20 <dmwit> Z`: how to use a single let or where: http://paste.lisp.org/display/131797#1
12:43:56 <Z`> thank you dmwit for taking time to write that
12:44:27 <dmwit> (By the way, I think the plural of leaf is leaves.)
12:44:34 <Z`> yes, correct
12:44:56 <Z`> hm, is allLeafs allLines = nubBy (==) . map last . breakConditionals allLines supposed to compile or was it schematic ?
12:45:13 <dmwit> I didn't write "allLines" anywhere. ;-)
12:45:27 <dmwit> It was not schematic: it was exact. You just didn't copy it correctly. =)
12:45:30 <Z`> wow.
12:45:35 <Heffalump> dmwit: did you consider monomorphism?
12:45:39 <dmwit> I did not.
12:45:41 <Z`> I don't understand how that can work
12:45:57 <Z`> let me :t that
12:46:07 <Z`> allLeafs :: [String] -> [String]
12:46:09 <Heffalump> z`: . is function composition, like << in F#
12:46:25 <Z`> a ha.
12:48:28 <Z`> so, f . g is like \x -> f (g x) ?
12:49:07 <Z`> seems so. neat.
12:49:15 <Ralith> @pl \f x -> f (g x)
12:49:15 <lambdabot> (. g)
12:49:23 <Ralith> er
12:49:26 <Ralith> @pl \f gx -> f (g x)
12:49:26 <lambdabot> const . ($ g x)
12:49:28 <Z`> what does @pl do ?
12:49:31 <Ralith> @pl \f g x -> f (g x)
12:49:32 <lambdabot> (.)
12:49:34 <Ralith> there we go
12:49:46 <Z`> it searches an operator that does what you write ?
12:49:50 <Z`> for*
12:50:02 <Ralith> Z`: converts an expression to "point-free" form
12:50:09 <kosmikus> no lambdas, essentially
12:50:14 <dmwit> ?src (.)
12:50:14 <lambdabot> (f . g) x = f (g x)
12:50:14 <lambdabot> NB: In lambdabot,  (.) = fmap
12:50:16 <geekosaur> not exactly, Z` although the optimization step can have that effect
12:50:37 <Z`> @pl \f g x -> (f g) x
12:50:37 <lambdabot> id
12:50:41 <Z`> :D
12:50:58 <dmwit> f . g is not just *like* \x -> f (g x), it *is* \x -> f (g x).
12:50:58 <geekosaur> @pl \(a,b) f -> (f a,f b)
12:50:59 <lambdabot> uncurry ((. flip id) . ap . ((,) .) . flip id)
12:51:18 <Ralith> as you can see, it often gets a bit silly.
12:51:23 <geekosaur> @pl \f (a,b) -> (f a,f b)
12:51:24 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
12:51:31 <Z`> yeh, alright
12:51:32 <dmwit> (up to some fiddly typing stuff that doesn't really happen unless you have some extensions on)
12:51:33 <geekosaur> ...isn't there an arrow for that?
12:51:43 <dmwit> Yes, but ?pl doesn't know about arrows.
12:51:56 <Ralith> someone should teach it!
12:51:57 <dmwit> :t (&&&)
12:51:57 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:52:08 <dmwit> ...not that one
12:52:14 <dmwit> :t join (***)
12:52:14 <Z`> I have mixed feelings on dmwit use of composition. It made my source much more elegant. No question about that. But also it reduced it significantly in size! It looks as if I didn't put much effort on it! :P
12:52:15 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
12:52:16 <hpaste> latro`a pasted “poly” at http://hpaste.org/74641
12:52:24 <latro`a_> ^anyone know how I might memoize that?
12:52:27 <dmwit> Z`: haha
12:52:35 <latro`a_> eh, not so much memoize as introduce sharing
12:52:36 <latro`a_> but yeah
12:52:42 <Z`> dmwit: please stop deleting my project's code :D
12:53:57 <zzzzzbogus> @
12:54:08 <Botje> Z`: it's not over until you've reduced your program to a foldM in a very nasty monad.
12:54:19 <lpvb> lolol
12:54:22 <zzzzzbogus> @pointfree \f1 f2 f3 t -> (,,) (f1 t) (f2 t) (f3 t)
12:54:23 <lambdabot> Unknown command, try @list
12:54:28 <zzzzzbogus> @list
12:54:28 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:54:34 <latro`a_> example usage by the way: "poly [2,-1] [1,2] 2 2" is the second coefficient of the second chebyshev polynomial
12:54:36 <latro`a_> err
12:54:38 <latro`a_> quadratic coefficient
12:54:56 <zzzzzbogus> @pl \f1 f2 f3 t -> (,,) (f1 t) (f2 t) (f3 t)
12:54:56 <lambdabot> (ap .) . liftM2 (,,)
12:55:07 <geekosaur> @listmodules
12:55:08 <lambdabot> activity babel base bf check compose dice dict djinn dummy elite eval fact free fresh ft haddock help hoogle instances irc karma localtime more oeis offlinerc pl pointful poll pretty quote search
12:55:08 <lambdabot> slap source spell state system tell ticker todo topic type undo unlambda unmtl version where
12:55:14 <geekosaur> @list pl
12:55:15 <lambdabot> pl provides: pointless pl-resume pl
12:55:15 <hpaste> dmwit annotated “poly” with “poly (annotation)” at http://hpaste.org/74641#a74642
12:55:21 <dmwit> Lots of other possible changes, too.
12:55:29 <dmwit> e.g. arithmetic ones
12:55:32 <latro`a_> fair enough, dmwit
12:55:41 <latro`a_> cleaner than the repeated patterns that I had before the guards
12:55:44 <dmwit> or ones where you do a case on n first, then k
12:55:52 <latro`a_> unimportant here, though
12:55:59 <dmwit> There's also more mechanical changes if *all* you want is sharing.
12:56:18 <latro`a_> I pretty much want calls like
12:56:21 <dmwit> e.g. poly as ds n k | n0 && k0 = 1 | ... where n0 = n == 0; k0 = k == 0
12:56:25 <latro`a_> poly [2,-1] [1,2] 100 100
12:56:28 <latro`a_> to be acceptable
12:56:41 <latro`a_> performance-wise
12:57:20 <dmwit> Oh, is the current code not acceptable performance-wise because of this?
12:57:23 <latro`a_> eh, rather, I want to be able to get map (\k -> poly [2,-1] [1,2] 100 k) [0..] in reasonable time
12:57:25 <dmwit> I'd be quite surprised.
12:57:34 <latro`a_> it wouldn't be, no; it has the same issues as the naive fibonacci recursion
12:57:52 <latro`a_> in fact it more or less is the naive fibonacci recursion
12:57:52 <dmwit> Now I'm not sure what you want.
12:57:54 <latro`a_> in that case
12:57:59 <latro`a_> err, in the case when ds = [1,2]
12:58:11 <latro`a_> it's not much different from the fibonacci recurrence
12:58:13 <dmwit> You want "poly" to do some precomputation given only as, ds, and n?
12:58:18 <latro`a_> just different coefficients
12:58:46 <latro`a_> basically I'd want to refactor it so I can get use poly as ds n k for smaller n,k to generate the same for larger n,k
12:59:02 <latro`a_> so the whole structure will change, with poly becoming a !! operation
12:59:05 <latro`a_> on a list polys
12:59:10 <dmwit> Man, I'm not doing anything that requires me to actually read the code! =P
12:59:31 <latro`a_> essentially I want to get something like the zipWith definition of fibs
12:59:50 <latro`a_> but this is a 2D situation, and the sharing isn't always between adjacent nodes
12:59:54 <latro`a_> so it's more subtle
13:00:11 <latro`a_> also I should probably make as and ds a list of pairs, since they always have the same length
13:00:17 <keep_learning> join #CCI
13:01:53 <hpaste> latro`a annotated “poly” with “poly (annotation) (annotation)” at http://hpaste.org/74641#a74643
13:05:03 <hashem> Hey all, is there a way to iterate through all elements of a tuple, say, if I want to sum them?
13:05:10 <latro`a_> no
13:05:21 <latro`a_> because the elements of a tuple make no promises about being the same type
13:05:30 <hashem> assuming they were though
13:05:42 <latro`a_> even then you'd have to match each element of the tuple
13:05:43 <timthelion> hashem: why are you using a tuple?
13:05:47 <latro`a_> indeed
13:06:06 <latro`a_> an ordered collection of elements on the same type is more naturally a list than a tuple
13:06:24 <zzzzzbogus> or an array/vector
13:06:29 <latro`a_> or that
13:06:38 <timthelion> zzzzzbogus: I was typing just that when your message appeared ;)
13:06:41 <hashem> I have a record type, and given two instances of this record I want to compare their fields
13:07:07 <latro`a_> why are tuples relevant then?
13:07:12 <timthelion> hashem: as in Greater than, less than, or eq?
13:07:14 <hashem> records are tuples, no?
13:07:21 <latro`a_> other way around
13:07:54 <latro`a_> data (,,) a b c = (a,b,c) --pseudocode
13:07:56 * hackagebot TCache 0.10.0.2 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.2 (AlbertoCorona)
13:08:25 <zzzzzbogus> @hashem: Can't you just use the derived instances of Eq and Ord to compare?
13:08:25 <lambdabot> Unknown command, try @list
13:08:34 <zzzzzbogus> hashem: Can't you just use the derived instances of Eq and Ord to compare?
13:08:45 <latro`a_> deriving is probably not desired here, if he wants to compare specific fields
13:08:54 <latro`a_> but like
13:09:05 <latro`a_> compare rec1 rec2 = compare (somefield rec1) (somefield rec2)
13:09:07 <latro`a_> works fine
13:09:18 <hashem> actually, I want to subtract them ... sorry for being unclear... basically:  (10, 9, 8, a) and (3, 2 ,1, b) I want to get [7, 7, 7].
13:09:38 <zzzzzbogus> Then use vectors of size 4
13:09:46 <timthelion> wait,
13:09:47 <hashem> so I'm stuck trying to figure out how to iterate through the spots in the record.... I'm new to haskell :)
13:09:54 <timthelion> hashem: you said iterate, that's not what you want.
13:10:05 <Cale> hashem: f (x,y,z,w) (x',y',z',w') = [x-x', y-y', z-z'] ?
13:10:18 <latro`a_> ^something like this
13:10:24 <timthelion> you can use a Num instance if all of them are Nums and you wish to subtract all of them.  Or you can even MAKE a num instance for your type.
13:10:31 <latro`a_> not sure why you want tuples, however
13:10:55 <timthelion> latro`a_: if he's doing a side by side action, it actually can make sense.  For example, if it's a point.
13:11:05 <latro`a_> sure
13:11:09 <latro`a_> but context
13:11:13 <timthelion> it's just iterating though elements it makes no sense.
13:11:17 <hashem> a record allows me to name the fields, and I expect an exact number of fields
13:11:32 <latro`a_> OK, then you want to access them the way I showed
13:11:37 <latro`a_> compare rec1 rec2 = compare (somefield rec1) (somefield rec2)
13:11:39 <latro`a_> or similar
13:11:46 <hashem> Cale, yes that would work, thank you. I was wondering perhaps if there was a way to do it without writing it out explicitly.
13:11:49 <latro`a_> when you name the fields of a record you automatically get accessor functions
13:12:25 <latro`a_> not really; the only way to access things from a record is via pattern matching or a field accessor function (which compiles to pattern matching anyway)
13:12:25 <frerich_> latro`a: For the record, that can be written as "comparing somefield"
13:12:33 <latro`a_> frerich_, I know, but he's new
13:12:54 <latro`a_> and comparing is written like that anyways
13:12:59 <timthelion> hashem: you CAN do it without writting it out explicitly, if you write it out in a Num instance!
13:13:37 <latro`a_> indeed; you have to write it once, but not necessarily more than once
13:13:52 <latro`a_> you could also just have a "subtractMyRecord" function or similar
13:16:29 * timthelion wonders what happens, if module A defines it's own Num instance for the three tuple, and module B imports NumInstances.  Which instance is used when passing a 3 tuple from module A to module B...
13:18:13 <latro`a_> I suspect you'd just get instance collision
13:18:29 <startling> yeah, pretty sure it's an error
13:19:59 <Heffalump> instances are global and a clash is an error
13:20:39 <startling> would be cool if you choose whether or not to import instances
13:21:15 <Heffalump> lots of people want it
13:21:37 <Heffalump> but it has lots of problems, e.g. what happens if you make a Set with one Ord instance and then pass it to a module using another Ord instance?
13:23:03 <startling> an error, duh
13:23:08 <Twisol> Sounds a bit like the problems with Ruby's refinements feature.
13:23:09 <startling> is there an `on` for Lenses?
13:23:22 * startling lights up the edwardk signal
13:23:30 <edwardk> startling: signature?
13:23:36 <Twisol> (i.e. scoped monkey patches)
13:25:34 <tdammers> *sigh* now alex fails to build...
13:25:46 <tdammers> "Illegal bang-pattern"
13:25:55 <johnw> :)
13:26:01 <startling> edwardk: Simple Lens a b -> (b -> b -> c) -> a -> a -> c
13:26:04 <startling> I think
13:26:16 <johnw> edwardk is an experiment in operant conditioning
13:26:23 <edwardk> johnw: =)
13:26:45 <edwardk> startling: you could that what with a getter.
13:26:48 <johnw> does your IRC client ring a bell whenever we say "lens"?
13:26:49 <edwardk> er could do
13:26:52 <edwardk> maybe =)
13:27:13 <startling> edwardk, do you get a treat every time?
13:27:14 <Botje> > cycle "lens! "
13:27:15 <lambdabot>   "lens! lens! lens! lens! lens! lens! lens! lens! lens! lens! lens! lens! le...
13:27:32 <startling> edwardk, yeah, I figured, but I thought there might be something already
13:28:38 <staticshock> if i :load script.hs in ghci it looks like it works if it hasn't been compiled, but stops working if i have the compiled output side by side with it
13:28:43 <staticshock> why is that?
13:28:54 <edwardk> ghci> on (+) (^._2) (1,2) (3,4)    ==> 6
13:29:09 <geekosaur> define "it works"
13:29:12 <edwardk> Botje: i turn it off when it gets spammy ;)
13:29:25 <johnw> mmmm spam as a treat
13:29:28 <Reko_> How can I obtain a datum by mutating a single element of an existing datum?
13:29:28 <startling> edwardk: oh, didn't realize it would be that simple
13:29:32 <startling> edwardk: excellent, thanks
13:29:46 <startling> now I just need `(some expression)` syntax. :(
13:29:53 <Botje> Reko_: what does this 'datum' look like?
13:30:03 <edwardk> ghci> ((+) `on` view _2) (1,2) (3,4)
13:30:03 <edwardk> 6
13:30:06 <edwardk> works better for the infix case
13:30:09 <geekosaur> it is expected that a compiled version will be loaded in favor of reinterpreting it in modern ghci, unless you force it; this will make things like single stepping not work, IIRC, but most things should work
13:30:12 <Botje> if it's a record type, you can do something like new = orig{foo="bar"}
13:30:19 <edwardk> startling: you can write that with two combinators
13:30:21 <Reko_> Ah, excellent.
13:30:37 <johnw> :t on
13:30:38 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:30:40 <geekosaur> ":l *Foo.hs" shuld force interpreted load
13:30:50 <hashem> timthelion, I went to look up Num and instance, and if I'm correct in what you meant before, I would do: instance Num myRecord where (a, b, c) - (x, y z) = [a-x,b-y,c-z] (and then also implement +, *, negate, abs, signum, fromInteger). While this would technically work, this would be infeasible if myRecord, for example, contained 500 elements. Is this a job for metaprogramming (aka editor macro) or does the language support something
13:30:50 <hashem> else? Or am I a fool? ;)
13:31:03 <edwardk> a -: some expression :- b     or a -| some expression |- b can be done, but you want different fixities for each
13:32:10 <startling> edwardk: ooh
13:32:20 <startling> ``, though, is just syntactic sugar, right?
13:32:35 <edwardk> > let infixl 9 -|, |-; a -| f = f a; (|-) = id in 1 -| (+) |- 2
13:32:36 <lambdabot>   3
13:32:45 <merijn> > let '2 = 5 in '2
13:32:46 <lambdabot>   <no location info>:
13:32:46 <lambdabot>      lexical error in string/character literal at chara...
13:32:51 <edwardk> > let infixl 9 -|, |-; a -| f = f a; (|-) = id in [1,2,3] -| zipWith (+) |- [4,5,6]
13:32:52 <lambdabot>   [5,7,9]
13:33:02 <startling> edwardk: very clever
13:33:12 <startling> thought I'm not sure I should use it in real code
13:33:19 <edwardk> i think chung-chieh shan came up with the trick
13:33:29 <staticshock> can anyone give me a ghci insight?
13:33:50 <hashem> staticshock, just ask
13:33:52 <startling> staticshock: what do you mean "if i have the compiled output side by side with it"?
13:33:57 <startling> hashem, he already did
13:34:10 <hashem> ah sorry
13:34:15 <staticshock> startling: i mean the exe output of ghc <my script>
13:34:27 <geekosaur> staticshock, everything I said in the past couple minutes was amimed at you
13:34:46 <geekosaur> starting with `define "it works"'
13:35:02 <staticshock> geekosaur: ah, sorry! it was part of the noise for me.
13:35:08 <startling> Reko_, lenses are a generalized solution for this problem
13:35:58 <staticshock> geekosaur: ok, to define "it works", i have a top-level function that i can call if the script is interpreted, and i get errors calling that function if the script is compiled
13:36:10 <staticshock> geekosaur:
13:36:13 <staticshock> geekosaur: "not in scope"
13:36:53 <geekosaur> oh.  I wonder if it needs to be exported or something.  although it should still be in scope, if you used :l to load it
13:37:09 <geekosaur> anyway you can use the leading * to force interpretation as I noted earlier
13:37:23 <startling> when things are inlined, is the inlined function still in the executable?
13:37:37 <edwardk> startling: usually
13:37:39 <simon> startling, do you mean if the inlined function isn't used?
13:37:50 <startling> simon, if it's only ever inlined
13:37:57 <geekosaur> otherwise, might send email to the ghc users list http://www.haskell.org/mailman/listinfo/glasgow-haskell-users or maybe try in #ghc
13:38:09 <edwardk> ghc isn't terribly aggressive at removing dead code
13:38:29 <johnw> it would be useless in a zombie apocalypse
13:38:47 <staticshock> geekosaur: ah, i didn't realize they had their own channel
13:39:01 <startling> poor ghc has too much compassion. it can't deal with harsh realities
13:40:09 <staticshock> geekosaur: so you think the problem might be me not exporting it?
13:41:58 <geekosaur> I don't know, just the first thing that occurs to me off the top of my headis it may be trusting the export list of a compiled module a bit too much when it's *current* module and not imported
13:42:04 <startling> so I've got a data structure like (UTCTime, a). I can't defined Ord (Mything a) and also Ord a => Ord (Mything a)?
13:42:07 <startling> *define
13:42:26 <staticshock> geekosaur: alright, thanks
13:42:41 <startling> I'd like to order by the UTCTime no matter what and then order by the a (if possible).
13:43:06 <staticshock> geekosaur: is there a way to inspect what's in scope in ghci?
13:43:15 <geekosaur> ":browse"
13:43:25 <rwbarton> generally "if possible" is not an option
13:43:32 <staticshock> ok
13:43:36 <shachaf> geekosaur: That's not "what's in scope"
13:43:40 <geekosaur> startling, Ord doesnt work that way in any case
13:43:50 <shachaf> That's "what's in the last module you imported"
13:43:55 <startling> geekosaur, how so?
13:43:55 <rwbarton> if your data structure is a Functor you can define the Ord a => Ord (Mything a) instance and use fmap (const ()) myThing to compare ignoring a
13:43:57 <thirsteh> is there a seamless way to memoize pure functions?
13:44:11 <thirsteh> found http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.3/doc/html/Data-MemoCombinators.html but it seems pretty involved
13:44:46 <simon> I'm doing 'if Map.lookup x m == Just True then Just Foo else Nothing' but figure I can shorten this using some operators. I thought about 'Map.lookup x m >> Just Foo', but this does not regard Just True, only Nothing.
13:44:49 <geekosaur> startling, suppose it depend son hoew you intended that but it looks to me almost like you'retryingt o define a sort and a subsort.  or did you actually want an overlap there?  which can sort of be done but is strange
13:44:50 <startling> rwbarton, that doesn't get me anything better than instance Ord (Mything a) comparing by the utctime
13:45:08 <rwbarton> what?
13:45:14 <thirsteh> and http://mikeburrell.wordpress.com/2007/04/04/memoizing-haskell/
13:45:32 <geekosaur> shachaf, the context is a module loaded, are you saying :browse is undefined because I didn't import?
13:45:35 <rwbarton> have the Ord (Mything a) instance compare by both, so if you want that just don't use fmap (const ())
13:45:50 <staticshock> geekosaur: thanks for the help
13:46:03 <startling> geekosaur, I want all Mything to be orderable but I don't want to clobber the contained data type's Ord if it's there, especially for (==) (which isn't Ord I know)
13:46:06 <thirsteh> ah, nevermind. Looks like there's a relatively new memoization module at http://hackage.haskell.org/package/memoize-0.3
13:46:46 <shachaf> geekosaur: I thought the goal was to list everything in scope.
13:46:53 <shachaf> (Maybe I misread, though.)
13:47:18 <geekosaur> shachaf, we're trying to determine in particular if :l-ing a binary module brings all the names in scope or just its export list
13:48:59 <hiptobecubic>  can't you just test this immediately?
13:52:21 <shachaf> geekosaur: Ah.
13:52:44 <geekosaur> hiptobecubic, if that was aimed at me, I cannot at present, no
13:53:42 <latro`a_> simon, you can do "join $ Map.lookup x m >>= \b -> if b then Just True else Nothing", though that's not exactly cleaner
13:53:47 <latro`a_> er
13:53:49 <latro`a_> *Just Foo
13:54:28 <simon> latro`a_, I think I'll explore mfilter. :)
13:54:37 <latro`a_> mfilter is also relevant
13:54:52 <latro`a_> erm
13:54:53 <latro`a_> filterM
13:56:44 <latro`a_> you can also avoid == by just matching on Just True
13:56:45 <merijn> startling: What you really need is the ability to invert type constraints, but I'm not sure whether that's even possible...
13:56:50 <Clint> how on earth do i get the actual node from a gtk TreeSelection?
13:57:31 <merijn> startling: Well, that or OverlappingInstances, but that's Bad.
13:58:29 <Clint> dcoutts: am i missing some easy way to get the actual node from a gtk TreeSelection?
13:58:47 <Jeanne-Kamikaze> easy and gui ? and gtk ?
13:58:49 <merijn> Maybe an Olegian type hack will manage it, but I wouldn't hold my breath
13:58:56 <startling> meh, guess I can just Ord and Eq by the time then
13:59:30 <dcoutts> Clint: the tree selection will give you a tree path (iirc), you can then use that with the underlying model to lookup the value at that location
13:59:59 <Clint> dcoutts: oh, duh. thanks!
14:00:50 <dcoutts> Clint: e.g. http://hackage.haskell.org/packages/archive/gtk/0.12.3.1/doc/html/Graphics-UI-Gtk-ModelView-TreeStore.html#v:treeStoreGetValue
14:01:06 <Clint> right
14:01:28 <dcoutts> Clint: the confusing thing is you need to keep hold of the TreeStore, you can't get it back from the TreeView widget
14:01:46 <dcoutts> because the store is typed while the view widget is not
14:02:03 <dcoutts> that is, TreeStore a  vs  TreeView
14:02:19 <dcoutts> store is parametrised by the content type
14:02:39 <edwardk> startling: was it you who was asking about how to use lens with aeson?
14:02:57 * hackagebot singletons 0.8.2 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.8.2 (RichardEisenberg)
14:03:34 <startling> edwardk: nope
14:05:32 <Clint> dcoutts: that's not a problem in this case.. this seems to work for me: treeSelectionGetSelectedRows treeselect >>= (treeStoreGetValue treestore . head)
14:06:30 <dcoutts> Clint: if you're just expecting one to be selected, use treeSelectionGetSelected
14:06:31 <rwbarton> edwardk: it was me
14:06:39 <rwbarton> perhaps
14:06:59 <edwardk> rwbarton: ah. i've just added projections to 2.9
14:07:04 <edwardk> so you can use a projection for aeson
14:07:23 <edwardk> that will let you use all the combinators to work on values contained in json data
14:07:41 <rwbarton> cool. I'll check it out later
14:08:08 <edwardk> k. i'll probably push it out to hackage tonight, in the meantime its on github
14:09:03 <Clint> dcoutts: yeah, it's a SelectionSingle
14:10:00 <dcoutts> Clint: right, so you still have to consider the case of none being selected, so I'd avoid using 'head' here
14:14:41 <edwardk> json = projection encode decode' :: (FromJSON c, ToJSON d) => Projection ByteString ByteString c d
14:15:13 <edwardk> then you can convert something to json with foo^.by json    and can traverse parts of the structure by composing the json traversal into the chain
14:15:47 <Z`> Is there a way to tell ghci that what I'm writing isn't complete yet ? so that I can break my code into multiple lines ?
14:16:03 <Z`> Because curretnyl I write 1 very long line and I don't like it
14:16:03 <monochrom> yes, but I forgot how
14:16:07 <Z`> like clisps' repl
14:16:14 <geekosaur> :{
14:16:25 <monochrom> but you can race me in looking it up in the user manual
14:16:36 <Z`> ah so it';s documented. cool! thanks
14:16:47 <geekosaur> that is, type ":{" to open a multiline block
14:16:56 <geekosaur> and ":}" on a line by itself terminates it
14:16:56 <Z`> ah lol I thought it was an emoticon
14:16:57 <Clint> dcoutts: ok, redone with treeSelectionGetSelected
14:17:00 <monochrom> oh! you are not frowning! :)
14:17:04 <geekosaur> yeh, I realized that and expanded
14:17:12 <Botje> :{ I MUSTACHE YOU A QUESTION :}
14:17:17 <Z`> haha
14:19:29 <monochrom> you may like to know that XQuery comments are like (: don't you love smileys :)
14:20:18 <geekosaur> I know (* foo *) from Pascal... big-nose smileys?
14:20:46 <startling> How about /* these guys */ ?
14:20:48 <rwbarton> cyclops smileys
14:21:09 <startling> reminds me of vonnegut
14:21:21 <FireFly> ·)
14:21:34 <monochrom> well, there was no smiley idea when Pascal was designed, it is excused
14:21:47 <Botje> what's that gemstone doing next to an arrow?
14:21:56 <monochrom> but by the time of XQuery, people knew better!
14:22:12 <monochrom> anyway, SML went with (* *) too
14:22:16 <startling> Botje, it's a wand
14:22:19 <startling> obv.
14:22:48 <startling> or a fountain and a gecko
14:22:57 <startling> (for :{)
14:24:04 <Botje> startling: could've been a newt.
14:24:10 <Botje> hard to tell in ascii ;)
14:24:23 <startling> Botje: unfortunately we have no colors here
14:24:42 <johnw> I have colors here
14:24:45 <johnw> they're just all black
14:25:00 <johnw> but chromatically it's a union
14:25:24 <startling> it's a monoid
14:25:29 <startling> black <> black = black
14:25:32 <monochrom> you need at least two colours to IRC. information theory.
14:25:37 <startling> id = black, obviously
14:25:44 <johnw> i have color and not-color
14:26:03 <johnw> startling: the Null monoid? :)
14:26:06 <monochrom> that's good enough for two colours
14:26:39 <johnw> hmm... it appears I cannot use gtk2hs-buildtools from a cabal-dev installation
14:26:53 <johnw> even setting my PATH doesn't stop it from complaining that it can't find a binary which is manifestly present
14:27:03 <monochrom> yikes
14:27:18 <monochrom> did you use cabal-dev to install gtk2hs-buildtools?
14:27:29 <johnw> yes
14:27:52 <johnw> i'm trying to cabal-dev install threadscope
14:27:57 <startling> what parsing libraries don't try to enforce their own notions of error handling?
14:28:31 <johnw> but even though this is now on my PATH (confirmed with 'which'), I still get: Cannot find gtk2hsC2hs
14:28:52 <startling> better yet: is there a nice thing that'll parse a ByteString like "a: b\nc: d" and give me a Map?
14:29:51 <Clint> wrap it in a json blanket and use aeson?
14:31:43 <startling> I prefer yaml, actually
14:31:53 <startling> is there a nice yaml thing that lets me define my own types?
14:32:01 <rwbarton> well that is valid yaml already
14:32:06 <Clint> i've not been thrilled by the haskell yaml libraries
14:32:23 <startling> Clint: yeah, they seem to be all pretty meh
14:32:58 * hackagebot groundhog 0.1.0.1 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-0.1.0.1 (BorisLykah)
14:33:00 * hackagebot groundhog-th 0.1.0.1 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.1.0.1 (BorisLykah)
14:42:58 * hackagebot groundhog-sqlite 0.1.0.1 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.1.0.1 (BorisLykah)
14:43:00 * hackagebot groundhog-postgresql 0.1.0.1 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.1.0.1 (BorisLykah)
14:44:26 <startling> why doesn't Data.ByteString.Lazy have breakSubstring?
14:49:49 <monochrom> perhaps "stringsearch" or "attosplit" may help you
14:54:58 <edwardk> rwbarton: i added a tiny aeson example to the examples folder https://github.com/ekmett/lens/blob/master/examples/Aeson.hs
14:58:25 * Cale is dealing with a beautiful clusterfuck of an example why it's a bad idea to approximate sum types with product types.
14:59:11 <monochrom> where?
14:59:39 <monochrom> also, http://www.vex.net/~trebla/humour/Nightmare.java
15:00:09 <Botje> isn't that functional Java?
15:01:23 <edwardk> Botje: thats nothing compared to some of the craziness nand` has been building ;)
15:01:42 <Cale> In this server backend for skedge.me, where we have events that have both a recurrenceBaseId (indicating that the event is an exception to a recurrence) and a recurrenceRule (describing how recurring events occur), and only one of those is ever supposed to be set, but somehow 218 of our events have both, and in 206 of those, the recurrence rule on the child doesn't match the parent.
15:02:13 <Cale> and now I have to figure out what the heck that's supposed to mean :)
15:02:27 <monochrom> I see
15:03:37 <monochrom> people are so limited by their education. they have only been taught product types (records, structs), therefore every sum type looks like a product type
15:04:03 <monochrom> it calls for the question "is that education or is that brainwashing? how do you tell the difference?"
15:04:44 <Cale> As opposed to colimited
15:06:22 <Cale> (come on, it's the one time that joke actually makes total sense in context!)
15:06:33 <monochrom> har har har
15:06:38 <monochrom> (hehehe!)
15:07:03 <typoclass> monochrom: education or no, at the moment where he's using X to solve Y, he still has to ask himself if that's the right tool for the job
15:09:22 <monochrom> taking liberty to continue this while #haskell-blah is busy with the Dutch election... :)
15:09:32 <simon> @pl swap (fmap (+1) (swap (1,1)))
15:09:32 <lambdabot> swap (fmap (1 +) (swap (1, 1)))
15:10:10 <monochrom> in my early days I lamented a stark contrast between computer science education and conventional arts/humanity education
15:10:25 <Cale> @pl point point point
15:10:26 <lambdabot> point point point
15:10:41 <simon> is there a neater way to fmap something to the first argument of a 2-tuple.
15:10:52 <startling> simon, first from Control.Arrow
15:10:52 <glguy> first (+1)
15:11:06 <startling> > first (+ 1) (1, "hello")
15:11:07 <lambdabot>   (2,"hello")
15:11:22 <monochrom> in arts/humanity classes, the typical activity is "let's go critical. what's wrong with this famous author's ideas? what do you disagree with?"
15:12:24 <Cale> @pl \(x,y) -> (f x, y)
15:12:25 <lambdabot> first f
15:12:35 <monochrom> in computer science class, let's say just programming classes and programming language classes for now, the typical activity is nothing like that. it's just "this OO thing is great! you must believe in this. in the exam, there are questions on why you must believe in this"
15:12:59 * hackagebot zlib 0.5.4.0 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.5.4.0 (DuncanCoutts)
15:13:42 <monochrom> (of course, same goes for the FP class)
15:14:15 <simon> monochrom, except in FP class it'd be true.
15:16:51 <Cale> While in mathematics classes, things are rarely discussed as good or bad, while some of that might actually be a good idea.
15:18:14 <monochrom> yes, I exempt proof classes from this.
15:22:07 <Z`> wow. guys and girls, with your help I finished a "real" haskell project! it accepts as input a file containg lines of the for "addr opcode args" and generates graphviz code on who calls who, who jumps towards whom, who RETurns, etc
15:22:11 <monochrom> in China, there are classes to teach "the Party is great! its ideology is great! here are what's great about it: 1... 2... 3... 4... 5... in the exam, you will be asked to answer those"
15:22:25 <Cale> Z`: nice!
15:22:36 <Z`> <3 thank you so much.
15:22:47 <monochrom> as far as teaching approach is concerned, I see no difference between the two
15:23:08 <startling> monochrom, sounds like religion class at my catholic high school !
15:23:53 <monochrom> now here is the sad part. as far as student response is concerned, there is a marked difference. the Chinese students are cynical, their thought is "yeah yeah whatever I'll write what you want in the exam, but this is BS"
15:23:55 <startling> "the united states right now has a culture of death" and on the exam "the united states right now has a culture of a) life b) death c) money d) none of the above"
15:24:09 <monochrom> the programming students actually believe everything told
15:24:15 <startling> monochrom: heh
15:24:37 <monochrom> Chinese student : programming student :: car salesperson : computer salesperson
15:26:44 <johnw> is there a way to force a library which uses forkIO to use forkOS instead?
15:27:11 <Dodek> monochrom: i have a counter data point: i had a c++ class on my cs course, and there was very little propaganda: nobody was saying that c++ is either good, bad, or ok
15:27:23 <Cale> johnw: No, but there shouldn't be a reason to, as far as I can tell
15:27:32 <johnw> hmm.. I think you're right
15:27:35 <hpc> johnw: you could do something really freaky and change the forkIO definition to call forkOS
15:27:36 <Dodek> nevertheless, the course seemed to be designed to make students realize that c++ sucks really fucking hard.
15:27:40 <hpc> but... don't
15:28:08 <typoclass> monochrom: i do agree that CS is weirdly superstitious. i wonder why. engineering-ish fields seem more critical. "if this system fails, then we have this backup system", and so on. it seems to encourage some mistrust of the things you designed/your tools/your judgement. i wonder why that's missing from CS
15:28:21 <startling> Dodek, I think that's a property of c++ itself tbh
15:28:39 <Dodek> startling: sure, but you can design a course to not give students that impression
15:29:02 <lpvb> I'd like to see how one can achieve that
15:29:12 <Cale> You start by making sure the students are not exposed to any other programming languages.
15:29:21 <Dodek> when you're chest deep in static initialization order fiasco, safe bool idiom and similar stuff, it's hard to accept c++ propaganda anymore.
15:29:56 <lpvb> Teach students both languages with the best pedagogy and then ask which one they prefer
15:30:01 <Dodek> and well there's lots and lots of propaganda in c++'s favour, even more than for java
15:30:22 <benmachine> pretty much 90% of my contact with C++ is actually via anti-propaganda :P
15:30:29 <benmachine> or those might just be called "facts" I dunno
15:30:51 <Dodek> when i was starting to learn programming, i recall i somehow got an impression that c++ is new, sexy, bleeding edge and nobody uses anything else.
15:30:59 <Cale> Facts have an inherently anti-C++ bias
15:31:19 <meiji11> Dodek, that was the generally vibe I had when I first learnt it too.
15:31:26 <meiji11> ah, the late '90s..
15:31:37 <meiji11> general vibe *
15:33:24 <c_wraith> Cale: we need not let the reality-based community dictate our opinions on programming languages
15:34:10 <qwr> but C++ is for some reason still nicer to write than Java ;)
15:34:16 <Jurily> reality is overrated
15:34:34 <monochrom> I liked c++, too. but then, it was c++ 1.1 or something
15:34:45 <startling> can I make an n-ary Either with some extension?
15:35:30 <monochrom> you can make your own "data Mine a b c d = A a | B b | C c | D d", does that count?
15:35:39 <startling> 'course not
15:35:40 <Cale> You can also compose binary Eithers.
15:36:03 <startling> hmm, I suppose there might be a template haskell way to do that automatically
15:36:08 * qwr thinks that the reason might be that C++ isn't so extremely verbose
15:36:17 <nand`> typoclass: I think that the farther you abstract yourself out into a virtual world, the more you tend to rely on errors not happening - it may be a mistake of CS practitioners to neglect real world errors during the execution of their, virtually proved correct, programs
15:36:48 <Cale> startling: Now, with extensions, you can essentially do the "composing binary eithers" in a fancier way, with lists at the type level.
15:37:10 <startling> oh, that's true, hmm
15:39:26 <rwbarton> with DataKinds I guess you can write a Sum type constructor of kind [*] -> *? (not sure of the syntax)
15:40:53 <Twisol> How useful/appropriate is it to work with >=> primarily instead of >>= on Monads?
15:41:15 <johnw> startling: what is a binary Either?
15:41:16 <typoclass> nand`: actually what i had in mind was the open-source fiddlers who'd chase some ridiculous 0.3 seconds speedup rather than writing test code or checking errors, but yeah
15:41:19 <johnw> Twisol: all depends on the code
15:41:32 <latro`a_> @twisol: depends highly on the code, but the way monads tend to get used makes it somewhat awkward
15:41:33 <lambdabot> Unknown command, try @list
15:41:43 <rwbarton> I imagine Either is a binary Either
15:41:47 <johnw> :t (>=>)
15:41:48 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:41:50 <johnw> :t (>>=)
15:41:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:42:24 <johnw> a x >>= b >>= c === a >=> b >=> c $ x
15:42:36 <Twisol> yeah, it's composition vs. application
15:42:40 <johnw> exactly
15:42:50 <nand`> I wonder what it would look like if we had syntax sugar for n-eithers, as comparable to syntax sugar for n-tuples
15:42:52 <latro`a_> indeed; the problem is mainly dealing with the lambdas
15:42:56 <latro`a_> in the composition model
15:43:18 <latro`a_> m1 >>= \x1 -> m2 >>= \x2 -> ... etc. is complicated in >=>
15:43:44 <Twisol> Hm, yeah.
15:43:46 <latro`a_> and is the most common use case
15:44:01 <Cale> data OneOf :: [*] -> * where Er :: a -> OneOf (a:ts); Um :: OneOf ts -> OneOf (a:ts)
15:44:15 <rwbarton> yeah
15:44:26 <rwbarton> mine were going to be called ThisOne and SomethingElse
15:44:28 <rwbarton> :)
15:44:28 <latro`a_> in a way the lambdas are a "pipeline", but in another way you have a sort of "convergence in", if that makes sense, from several nodes
15:44:39 <johnw> startling: I meant, what is an n-ary Either?
15:44:43 <johnw> isn't that just an ADT?
15:44:51 <Twisol> latro`a_: in other words, the later lambdas are already partially applied over the earlier ones?
15:44:57 <Twisol> *arguments of the earlier ones
15:45:04 <latro`a_> not really applied, it's a scope thing
15:45:04 <rwbarton> OneOf '[Int,String,Bool] is pretty light syntactically
15:45:23 <latro`a_> but, well, try and write liftMn using >=>
15:45:28 <johnw> like a c++ union?
15:45:46 <latro`a_> even just liftM2
15:45:50 <startling> johnw: NaryEither Integer Bool, or NaryEither String ByteString Text, or NaryEither Int8 Int16 Int32 Int64 is what I was thinking of
15:45:51 <Twisol> latro`a_: isn't "scope" just partially applying a lambda over the contents of the outer scope?
15:46:03 <startling> johnw: is that an ADT? no idea
15:46:14 <latro`a_> umm...I'm not sure about that, twisol
15:46:15 <johnw> startling: how do you know which one it is?  what does the pattern match look like?
15:46:34 <startling> johnw, I suppose you'd need type signatures
15:46:43 <latro`a_> I'm not sure how I'd turn scope into an idea about function application
15:47:00 <Twisol> latro`a_: well, if you were to excise a section out of a monad that uses earlier results
15:47:00 <startling> latro`a_, he's talking about lambda lifting
15:47:04 <johnw> an ADT is: data MultiChoice = MC1 Int | MC2 String | MC3 Text
15:47:09 <rwbarton> Either is not a union though, you can have Either Int Int
15:47:09 <startling> Twisol, that's called lambda lifting
15:47:11 <Twisol> latro`a_: wouldn't you need to explicitly state those items in its arguments list, and pass those in?
15:47:15 <Twisol> startling: coolness
15:48:14 <startling> johnw: yeah, that's the kind of boilerplate I was hoping to cut down on
15:48:20 <startling> especially the abundance of constructors
15:48:22 <rwbarton> so you can't identify which constructor it is by type, only by index
15:48:24 <johnw> oh, I see
15:48:32 <johnw> you just want to automate the creation of an nAry
15:48:39 <latro`a_> ah I see
15:48:40 <johnw> TH :)
15:49:56 <johnw> but your calling code is still going to be very boilerplatey
15:50:28 <johnw> maybe you want a typeclass?
15:50:38 <johnw> + existential types
15:50:55 <johnw> then you can create your own interface over common traits for String, Text, ByteString
15:51:04 <johnw> or Int8/16/32/64
15:51:08 <Twisol> I've also noticed this: const f >=> g === const (f >>= g)
15:51:11 <Twisol> which is rather neat
15:58:55 <latro`a_> yup
15:59:21 <latro`a_> also m >>= f = (const m >=> f) ()
15:59:45 <latro`a_> (a modification of what you just wrote)
16:00:38 <Twisol> *nod*
16:00:55 <Twisol> I'm playing with $, ., >>=, and >=> in another window right now. ;D
16:05:06 <Jetbeard> Can somebody just slap me? I tried to write a function of no argmuents with lambda syntax
16:05:37 <Jetbeard> maybe it's a bit too late to be thinking like a Haskell programmer (both time of day, and time of life)
16:05:56 * Twisol slaps Jetbeard around a bit with a large trout
16:06:08 <Jetbeard> thankyou
16:06:10 <Twisol> ^_^
16:06:36 <Twisol> I wouldn't give up too easily.
16:07:11 <Twisol> but yes, sleep helps
16:07:23 <Jetbeard> It's only midnight here
16:07:26 <Jetbeard> I should be fine
16:07:41 <startling> Jetbeard: peak programming time, in fact
16:07:57 <Twisol> I don't know about you, but it's surprisingly easy for me to misjudge my own level of exhaustion.
16:08:35 <startling> Twisol: nah, it's easy. just try to write a type signature
16:09:33 <Jurily> what guarantees does bracket give about the "release resource" argument? Apparently it doesn't run when the program hits an undefined
16:12:47 <johnw> if getChanContents returns IO [a], doesn't that mean it will block until all a are ready?
16:13:15 <johnw> well, no that's not right
16:13:23 <johnw> because than getContents do the same
16:14:25 <typoclass> Jurily: good question. hitting an undefined is an exception, right? i thought 'bracket' is able to deal with exceptions
16:14:36 <typoclass> uh, he's gone
16:15:11 <davesq> hi all, i'm looking at "newtype State { runState :: s -> (a,s) }" and finding the terms a bit confusing. 's' represents the state right? So would "newtype StateCalculation" be slightly more accurate? (not saying it's desirable, just clarifying terms)
16:15:18 <Twisol> my guess as a novice is that bracket only guarantees to release the resource before bracket returns - and if undefined is bottom, it never returns anything
16:15:44 <startling> > x = do { Just 12; undefined; }
16:15:45 <lambdabot>   <no location info>: parse error on input `='
16:15:53 <startling> > do { Just 12; undefined; }
16:15:55 <lambdabot>   *Exception: Prelude.undefined
16:16:19 <jedai> davesq: ComputationWithState would be the more precise name for the datatype though a bit verbose ;)
16:17:47 <davesq> jedai: right, thanks. :) i'm just writing out some examples for myself and keep finding myself tripping over state 's' and 'State'
16:17:51 <typoclass> davesq: as far as i can tell, you can read runState's signature as: you give it an initial state, it does things, and gives you back a result value and a final state
16:19:01 <davesq> typoclass: yes, so "newtype State" represents a way to get from one state to the next (plus the result of that transition)
16:20:05 <typoclass> i guess it's a little like running binaries in linux. there's an environment (a number of variables like PATH=...). the binary runs and can read from those, which may influence its behavior. the binary might also change some of them. finally, it gives you an exit status (which in linux can only be an int, but in haskell could be anything)
16:20:20 <Cale> davesq: If you want, I can quickly go over the definition of the state monad in #haskell-overflow and explain the thought process behind the basic combinators
16:20:24 <typoclass> davesq: i guess you could look at it like that
16:21:40 <davesq> typoclass: i'm happy to look at it another way :)
16:22:29 <startling> davesq, Reader might be easier to understand at first
16:23:49 <davesq> startling: i think i've got a decent idea of how it works (for a n00b anyway), it's the terminology i wanted to clarify
16:24:00 <Twisol> If `const` provides a morphism (function) that always returns the same value, is there an analogous function that takes a value and provides a Category instance that always returns the same value?
16:24:29 <startling> Twisol: I was wondering about that a week or so ago. I think the answer was no
16:24:32 <nand`> no, but there is for Arrows
16:24:51 <Twisol> nand`: I figured arrows played into it somehow. Still digging around there
16:24:56 <nand`> :t arr . const
16:24:58 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => c -> a b c
16:25:13 <Twisol> hmm, makes sense
16:25:34 <Twisol> I'm trying to come up with ways of generalizing $ to any category.
16:25:43 <startling> Twisol, it's just id
16:25:52 <startling> Twisol, with a specific fixity
16:25:59 <Twisol> for functions
16:26:08 <Twisol> with monads you have to use >>=
16:26:15 <Twisol> but it's still application
16:26:25 <nand`> perhaps you're thinking of
16:26:28 <nand`> :t app
16:26:29 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
16:27:11 <startling> > app ((+ 1), 2)
16:27:12 <lambdabot>   3
16:27:23 <startling> neat
16:27:28 <Twisol> Guess I am!
16:28:45 <Twisol> It would be nice if I could use the same function regardless of whether I'm applying functions or monads
16:29:06 <nand`> by ‘applying monads’ do you mean ‘ap’?
16:29:26 <startling> > let (.:) = (.).(.) in app .: (,)
16:29:27 <Twisol> well, =<<
16:29:27 <lambdabot>   Overlapping instances for GHC.Show.Show ((b -> b1) -> b -> b1)
16:29:27 <lambdabot>    arising f...
16:29:31 <startling> :t let (.:) = (.).(.) in app .: (,)
16:29:32 <lambdabot> forall b b1. (b -> b1) -> b -> b1
16:30:12 <nand`> > let ($) = (=<<) in Identity . (+1) $ return 3
16:30:13 <lambdabot>   Precedence parsing error
16:30:13 <lambdabot>      cannot mix `L..' [infixr 9] and `$' [infixl 9...
16:30:20 <nand`> > let ($) = (=<<) in (Identity . (+1)) $ return 3
16:30:21 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity a))
16:30:21 <lambdabot>    arisi...
16:30:28 <nand`> no instance on that? odd
16:31:32 <latro`a_> twisol: note that every ArrowApply induces a Monad
16:31:49 <latro`a_> so not every category actually has an analogue of $
16:31:57 <latro`a_> (as they shouldn't!)
16:32:00 <Twisol> nand`: These type signature similarities make me feel like there should be a way to define one in terms of the other.
16:32:01 <Twisol> http://hpaste.org/74650
16:33:04 <nand`> Twisol: as I showed, (=<<) and (<=<) are generalizations of ($) and (.) since you can replace in Identity for every ‘m’
16:33:21 <Twisol> Aaah.
16:33:24 <Twisol> I see.
16:33:57 <nand`> unfortunately, the Identity cruft is a bit verbose. I've often dreamed about a less verbose way to lift/unlift newtypes
16:34:24 <Twisol> I prefer working with the most generalized form where possible (like fmap instead of map), so… yeah.
16:35:16 <lpvb> what are the operator naming rules in haskell?
16:36:07 <monochrom> punctuations, roughly. the colon : is like uppercase letters --- for the beginning of a constructor
16:36:46 <monochrom> the Haskell 2010 Report has the exact rules
16:37:13 <monochrom> example: #$%^& is a valid operator name. so you can swear by operators
16:37:40 <monochrom> > let a #$%^& b = a*2+b in 2 #$%^& 1
16:37:41 <lambdabot>   5
16:38:37 <monochrom> a constructor will be like :#$%^&, i.e., begins with ":". some people add a colon at the end for aesthetics, e.g., :+:
16:38:41 * nand` wonders what the world would look like if newtype isomorphisms are automatically witnessed (as long as you have the constructor/field name in scope)
16:39:00 * nand` .oO( constructor/destructor )
16:39:09 <rwbarton> there is usually no "most generalized form", e.g. (.) generalizing to fmap or Control.Category's (.)
16:40:11 <Twisol> rwbarton: well, if I'm doing things in multiple places that's fundamentally composition, but over different types, it would be nice to use a common operator
16:40:36 <Twisol> …unfortunately it sounds like I'd have to use lots of newtype wrapping/unwrapping to achieve that
16:40:39 <Twisol> so yuck
16:40:39 <monochrom> use a generalization that fits exactly your task
16:40:51 <rwbarton> better to use the least generalized version IMO
16:41:15 <Twisol> rwbarton: Why's that?
16:41:19 <startling> nand`, any data constructor is an isomorphism, no?
16:41:36 <rwbarton> it's helpful to the reader (this includes you and the compiler)
16:42:09 <nand`> startling: only if it's the only one and has only one field (the two restrictions newtypes have)
16:42:13 <rwbarton> if you make a mistake, you are more likely to get a type error than something that typechecks by accident, or the error is more likely to be close to the location of the mistake
16:42:33 <nand`> well, actually; you can make more isomorphisms than that
16:42:35 <Twisol> rwbarton: That's a fair point.
16:42:44 <startling> nand`: right, you can do any that only have one field
16:42:44 <nand`> eg. Foo a b ⇔ (a, b)
16:43:29 <startling> e.g, Left would have an unLeft and Right could have an unRight
16:43:32 <nand`> but for any ‘automatic conversion’ I'd only be happy with newtypes, since they're there for ‘representing the exact same thing under a different name’
16:43:49 <startling> oh, that's not really an isomorphism wrt haskell's type system though
16:43:54 <edwardk> woot.
16:43:59 <monochrom> "mappend 5 6" is ambiguous as to whether you mean the "mappend (Sum 5) (Sum 6)" or "mappend (Product 5) (Product 6)" if newtype isomorphisms are automatically witnessed
16:44:21 <edwardk> whoever it was who wanted it to be easier to export the generated lenses, i just managed to get that to work. so now makeClassy will put all the lenses in the class it generates
16:44:46 <nand`> monochrom: yeah, that's what I thought - something like today's “ambiguous class” errors; ie. you'd disambiguate by writing getSum (mappend 5 6)
16:44:55 <nand`> or simply specifying it in the type signature
16:45:29 <Twisol> (mappend 5 6 :: Sum Int)?
16:45:37 <monochrom> "mappend 5 6" is also ambiguous as to whether you mean "mappend 5 6", "getSum (mappend 5 6)", or "getProduct (mappend 5 6)"
16:45:58 <monochrom> in fact...
16:46:03 <rwbarton> another thing you can write is 5 + 6 ;)
16:46:05 <monochrom> "mappend 5 6 :: Int" is also ambiguous as to whether you mean "mappend 5 6", "getSum (mappend 5 6)", or "getProduct (mappend 5 6)"
16:47:13 <monochrom> how about this? have two kinds of newtype. call them newtype1 and newtype2
16:47:17 <ion> Make the compiler choose by random.
16:47:50 <monochrom> newtype1 disallows multiple choices. once you have "newtype1 X = X Int" you are not allowed "newtype2 Y = Y Int"
16:48:00 <monochrom> err typo
16:48:04 <monochrom> newtype1 disallows multiple choices. once you have "newtype1 X = X Int" you are not allowed "newtype1 Y = Y Int"
16:48:12 <monochrom> newtype2 allows multiple choices
16:48:38 <monochrom> automatic newtype1 isomorphism witnessing has less ambiguity
16:48:40 <nand`> hmm
16:49:01 <nand`> I'm not sure how well that would work, especially with stuff like newtype Sum a = Sum a
16:49:37 <nand`> alternatively what I could see working is explicitly annotating when to move in/out of the newtype
16:49:52 <nand`> but in a less verbose way; arguably that can be done right now
16:49:57 <monochrom> that would be newtype2
16:50:06 <nand`> class Newtype o i where out :: i -> o; in' :: o -> i
16:50:32 <monochrom> newtype2 does not enjoy automatic isomorphism witnessing. newtype2 is deliberately ambiguous because some people want it
16:53:38 <Twisol> monochrom: It would seem reasonable to define all of your options as newtype2, then define a newtype1 in terms of a newtype2
16:54:12 <Twisol> the newtype1 could be done near the usage site rather than the point of definition
16:54:22 <nand`> in other names, keeping newtypes intact but having an extra construct for ‘automatic isomorphisms’?
16:55:12 <nand`> (add a fundep | i -> o in my example just now, fwiw)
16:56:09 <johnw> is there is a function that given a [Maybe a], maps a -> b over the Just values and stops at Nothing?
16:56:20 <johnw> so, [Just 1, Just 2, Nothing] => [1,2]
16:56:29 <hpaste> staticshock pasted “Indentation error?” at http://hpaste.org/74651
16:56:30 <lep-delete> :t catMaybes
16:56:31 <johnw> (and anything after Nothing is ignored, unlike catMaybes)
16:56:31 <lambdabot> forall a. [Maybe a] -> [a]
16:56:36 <nand`> I would first write a function [Maybe a] -> [a] that stops at Nothing
16:56:48 <lep-delete> :<
16:56:49 <staticshock> can someone help me understand where the indentation error is coming from?
16:56:50 <nand`> the mapping seems distinct
16:57:14 <rwbarton> staticshock: "in"?
16:57:28 <rwbarton> oh
16:57:29 <rwbarton> you hid it
16:57:39 <Twisol> johnw: (takeWhile isJust) . catMaybes ?
16:57:47 <staticshock> rwbarton: does it not belong there?
16:57:53 <staticshock> rwbarton: do people generally put in on its own line?
16:57:57 <typoclass> staticshock: try to put the 'in' on the new line, so that it's aligned with the 'let'
16:57:58 <rwbarton> well I usually put it on the beginning of the next line
16:58:00 <nand`> Twisol: other way around but yeah
16:58:02 <hpaste> BleuM937 pasted “Pair class constraints” at http://hpaste.org/74652
16:58:03 <nand`> that would do it
16:58:05 <staticshock> typoclass: aite, trying
16:58:09 <typoclass> ("in memoFix fibInternal")
16:58:16 <Twisol> ah, right
16:58:35 <BleuM937> Hi, fiddling around with typeclasses, trying to add a constraint to an instance but not sure how to do it
16:58:42 <staticshock> typoclass: doesn't help
16:58:42 <johnw> hey, just ran into my first caes of really needing >=>
16:58:48 <rwbarton> I would think this also "works" though yeah
16:59:16 <Twisol> johnw: Cool!
16:59:18 <rwbarton> ... I don't get a parse error here so the error is somewhere else
16:59:33 <johnw> paralell $ map (a >=> b) xs
16:59:45 <johnw> since parallel wants [IO a]
16:59:56 <BleuM937> Can somebody point me to some docs for these sorts of constraints? Is this a case for MultiParamTypeClasses?
17:00:12 <staticshock> typoclass, rwbarton: i had fibInternal defined at the top level before, and fib had a one line definition, and that was working.
17:00:15 <rwbarton> staticshock: paste the whole file or at least the first 15 lines
17:00:20 <staticshock> rwbarton: ok
17:00:29 <typoclass> staticshock: sorry, i was actually wrong. the code you pasted works for me (except that memoFix is not found, i had to define that as "= undefined")
17:00:35 <monochrom> yeah, cannot reproduce error
17:00:45 <staticshock> typoclass: ah, yeah, i cabal-installed memoize
17:01:05 <rwbarton> if you get a "not in scope" error it means there wasn't a parse error anyways
17:01:08 <typoclass> staticshock: so that you put the 'in' on the new line was good normal style, but not syntactically necessary :-)
17:01:15 <rwbarton> so no need to replace it
17:01:18 <staticshock> ok
17:01:22 <hpaste> staticshock pasted “Indentation error? PART DEUX” at http://hpaste.org/74653
17:01:26 <staticshock> that's the whole file
17:01:35 <typoclass> rwbarton: ok, i just wanted to be absolutely sure
17:01:41 <staticshock> i'm loading it into ghci via :load fib.hs
17:01:47 <rwbarton> right like the error said, the error is on line 15
17:02:02 <staticshock> oh, damn it. did i miss that?
17:02:02 <monochrom> oh? inside a do-block, you don't need "in" there
17:02:07 <rwbarton> or arguably on line 14
17:02:16 <rwbarton> "fib.hs:15:5:"
17:02:25 <nand`> note that you can include an ‘in’ and remove the do block instead
17:02:49 <staticshock> nand`: really?
17:02:56 <monochrom> yes
17:03:01 <nand`> staticshock: the do block is unnecessary for only one statement
17:03:05 <monochrom> kill exactly one of them
17:03:08 <nand`> (do a) desugars to a
17:03:10 <typoclass> it's actually kinda silly that removing the 'in' would work, removing the 'do' also (i think), but not keeping both
17:03:22 <c_wraith> > do False
17:03:24 <lambdabot>   False
17:03:25 <rwbarton> you wrote "main = do { let x = e; in y }"
17:03:43 <rwbarton> should be "main = do { let x = e in y }" or "main = let x = e in y" or "main = do { let x = e; y }"
17:03:47 <staticshock> i see. i was under the impression that wrapping things in a do expression was done for IO's sake
17:03:50 <nand`> typoclass: you can actually include both too
17:03:56 <nand`> typoclass: I think you'd just need to indent line 15
17:04:05 <nand`> then it'd be do { let x = e in y; }
17:04:13 <rwbarton> also I left out some braces that are necessary
17:04:14 <nand`> but in this case the do { } is unnecessary
17:04:54 <typoclass> nand`: yeah, but that's the weird thing, outside a do block it works. (see lines 7-10 in his old paste)
17:05:34 <monochrom> rwbarton explains it. layout rules and adding back {;}
17:05:34 <pnielsen> typoclass, nand`: http://www.haskell.org/haskellwiki/Keywords#let.2C_in
17:05:41 <rwbarton> "let x = e in y" is an expression
17:05:49 <rwbarton> "let x = e" is a thing you can put in a do-block
17:05:57 <rwbarton> "let x = e in" isn't anything :)
17:06:08 <rwbarton> each thing in a do-block starts in the same column
17:06:11 <nand`> typoclass: yeah but do blocks not only have their own version of ‘let’ but also different indenting rules (splitting something up without indenting it counts as multiple expressions in the do block)
17:06:17 <rwbarton> so if you put a new line starting in the same column it is a new thing
17:06:19 <rwbarton> does that make sense?
17:06:34 <nand`> rwbarton: I think what he actually wrote was do { let x = e in; y }, not do { let x = e; in y } -- regardless, both invalid
17:06:43 <rwbarton> oh oops, yes
17:08:23 <typoclass> all true, but it still seems a little icky to have something that works in pure code, but not in a do block
17:08:28 <typoclass> (just a little)
17:08:56 <nand`> do's layout rules have bitten me before on occasions
17:09:46 <ddarius> do doesn't have layout rules.  do is just one of the several keywords that starts layout.
17:09:54 <nand`> (including one situation in which I think the parsing behavior should be changed - specifically when defining a do block inside a let-statement inside a do block)
17:10:37 <nand`> but I think what I'm envisioning introduces other ambiguities in that scenario
17:16:05 <Cale> ddarius: then again, there's that funny DoAndIfThenElse thing
17:16:40 <ddarius> Which was a complete mistake in my opinion.
17:16:45 <Cale> mine as well
17:17:28 <Cale> MY CODE DOSN"T WORK WHEN I INDENT BADLY HALP
17:17:44 <Cale> Haskell' Committee:  (.__. ) okay
17:18:50 <ivanm> heh
17:18:52 <ivanm> agreed
17:19:00 <ivanm> never got the point of DoAndIfThenElse
17:19:09 <dolio> If I were fixing that, I'd make indenting then the same amount as if a syntax error.
17:19:11 <dolio> Always.
17:19:16 <Cale> There are all these things which they *could* have fixed or changed about the language spec, and instead, they do this.
17:19:41 * BMeph thinks that if-then-else should have never been put in the language. The same with "return"; it's like an inside joke that's genuinely funny...for the first week. Afterwards,... :/
17:20:10 <monochrom> return (if b then e0 else e1)
17:20:13 <Cale> return is good
17:20:37 <nand`> if b then return e0 else return e1
17:20:40 <Cale> There's nothing wrong with calling the computation which returns v *cough* return v
17:21:02 <Cale> seems straightforward and sensible :)
17:21:17 <Cale> all the other names are kinda odd or meaningless
17:21:27 <Cale> you could name it eta
17:21:43 <Cale> but that's not going to be helpful to anyone but the people who don't need help
17:21:47 * ddarius is also fine with 'return'.
17:21:52 <BMeph> Cale: There's nothing inherently bad about 'return,' I just don't like how it plays into people's pre-(Haskell-)formed notions.
17:22:25 * ddarius is mostly against not doing things because Haskell might somehow be mistaken for some other language.
17:22:42 <nand`> if anything, I think it emphasizes the need to learn from scratch, instead of trying to pick it up by looking at some code examples and guessing together intuition
17:22:46 <ddarius> E.g. I have no problem with type classes being 'class'.
17:22:48 <nand`> like you can if you're familiar with very similar languages
17:22:59 <latro`a_> return isn't THAT far off from imperative langs in IO, as long as it's never in the middle of a block
17:23:00 <Cale> return even *mostly* plays the role that it plays in other languages -- it just doesn't have the control effects that it does
17:23:14 <Cale> which is something that most people seem to get over pretty quickly
17:23:28 <Cale> yeah
17:23:31 <ddarius> latro`a_: Yes, I'm pretty sure it was intentionally chosen to mimick the look of common imperative code, which it does rather well and reads rather well.
17:24:07 <mm_freak> another sensible name for "return" is "returning"
17:24:19 <mm_freak> "returning ()" is an action that produces a ()
17:24:37 <latro`a_> eh, verb/noun distinction
17:24:42 <nand`> I think any name is “appropriate” in some situations but not all
17:24:42 <latro`a_> is always hard in programming
17:24:43 <BMeph> I think I would have chosen "cast" instead. Now, imagine the chaos THAT might cause! >;)
17:24:49 <latro`a_> oh dear
17:24:58 <monochrom> I am thinking "ate"
17:25:05 <latro`a_> also, just for fun
17:25:09 <latro`a_> import Prelude hiding id
17:25:11 <mm_freak> latro`a_: it's not a noun actually
17:25:13 <latro`a_> import Unsafe.Coerce
17:25:18 <latro`a_> id = unsafeCoerce
17:25:20 <latro`a_> *boom*
17:25:41 <benmachine> @quote unsafeCoerce
17:25:42 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
17:25:45 <benmachine> haha
17:25:48 <johnw> now that I've found parallel-io, I'm retrofitting concurrency into a lot of my utility scripts :)
17:25:51 <benmachine> that's not what I meant but that's also cool
17:26:01 <latro`a_> eh, I read "returning ()" as an adjective, which makes it a noun with an implicit article, basically
17:26:03 <mm_freak> interestingly that wouldn't break correct code, except perhaps for ambiguous type errors
17:26:04 * ddarius agrees that that was a good quote.
17:26:10 <johnw> git-all's status scan of 1:05 is now 0:41, essentially for free
17:26:15 * BMeph does, too.
17:26:23 <latro`a_> also yeah that's pretty funny
17:26:38 * ddarius also feels that Haskell should provide special syntax for unsafeCoerce as it's certainly a feature that should be built-in to the language and also facilitated to ease it's use.
17:27:01 <latro`a_> ...special syntax for unsafeCoerce
17:27:01 <dolio> Our language at work has unsafeCoerce in the prelude.
17:27:04 <latro`a_> *head explode*
17:27:22 <BMeph> Of course, every time I see "unsafeCoerse," I always follow it with "(high school girls)" in my head. I think, it's just to emphasize to myself just how creepy it is.
17:27:34 <mm_freak> a very common language has implicit unsafeCoerce
17:27:44 <mm_freak> sadly that language is often used to implement security-related software
17:27:49 <jkff> I suggest some really special syntax, e.g. no syntax at all - an implicit unsafeCoerce around everything.
17:27:56 <latro`a_> mm_freak, C?
17:28:00 <mm_freak> latro`a_: yeah
17:28:25 * BMeph feels with his fingers! ;þ
17:28:30 <latro`a_> unsafeCoerce = unsafeCoerce unsafeCoerce
17:28:40 <mm_freak> fix unsafeCoerce
17:28:57 * BMeph echoes: "(high school girls...)"
17:29:02 <jkff> > fix unsafeCoerce
17:29:03 <lambdabot>   Not in scope: `unsafeCoerce'
17:29:06 <jkff> :(
17:29:25 <MostAwesomeDude> Now I'm reading "fix" as "neuter". :T
17:29:33 <latro`a_> aww, lame
17:29:36 <latro`a_> fix unsafeCoerce is _|_
17:29:44 <monochrom> I know a better way (to cause chaos). use parentheses to stand for unsafeCoerce. sometimes. examples: (x) is an unsafeCoerce, (x+y)*z doesn't have an unsafeCoerce, but ((x+y))*z does
17:30:02 <mm_freak> fix (. unsafeCoerce)
17:30:26 <latro`a_> nope
17:30:30 <latro`a_> stilll _|_
17:30:31 <nand`> ((*))(((+))(x)(y))(z)
17:30:32 <latro`a_> *still
17:30:35 <mm_freak> latro`a_: of course
17:30:37 <nand`> unsafeCoerce, unsafeCoerce everywhere!
17:30:51 <nand`> oh, I forgot one set of ()s
17:31:03 <mm_freak> let andrea = unsafeCoerce andrew
17:31:03 <nand`> two if you include one around everything
17:31:34 <dolio> monochrom: That'll work out nice in Scala. There you need to distinguish between f(x,y) (call f with two arguments) and f((x,y)) (call f with a tuple of x and y), so you can also have f(((x,y))) (call f with a coerced tuple of x and y).
17:31:53 <ddarius> dolio: What?
17:32:01 <dolio> Which part?
17:32:04 <ddarius> The last.
17:32:47 <dolio> (x,y) is a tuple, so ((x,y)) is a coerced tuple in monochrom's format.
17:33:00 <dolio> And you're calling f with it. f(((x,y)))
17:33:02 * hackagebot git-all 1.2.0 - Determine which Git repositories need actions to be taken  http://hackage.haskell.org/package/git-all-1.2.0 (JohnWiegley)
17:33:07 <ddarius> dolio: Oh, I thought you were talking about something Scala actually had.
17:33:12 <dolio> No.
17:33:13 <mm_freak> i never liked scala
17:33:21 <dolio> It does have the f(x, y) vs. f((x,y)), though.
17:33:21 <ddarius> Scala isn't very likable.
17:33:26 <ddarius> dolio: Yeah, I know.
17:33:41 <nand`> I have enough of edwardk's ramblings concerning scala to last a lifetime, I don't need my own
17:33:43 <dolio> Because, you know, the ML people didn't solve that decades ago.
17:33:49 <edwardk> hahaha
17:34:05 <mm_freak> yeah, when i tried to learn scala i expected an actual improvement over java…  it's just java with a more powerful type system
17:34:29 <jkff> mm_freak: what other kind of improvement did you expect?
17:34:36 <mm_freak> jkff: a functional language
17:34:40 <ddarius> Scala's definitely a better Java in most regards.  Unfortunately, Java drags it down from being a reasonably nice language.
17:34:42 <nand`> I expected actual improvements over C# in F# as well. All they added was sum types, really
17:34:56 <benmachine> mm_freak: that *is* an improvement, though, right?
17:35:02 <nand`> (also type inference)
17:35:03 * ddarius didn't expect actual improvements in F# and hasn't yet been suprised.
17:35:03 <jkff> mm_freak: hm. Do you mean it's inconvenient to use the higher-order facilities in Scala, or that the language doesn't promote immutability etc?
17:35:18 <mm_freak> nand`: F# has a much nicer syntax than C# at least, and it actually allows you to program functionally without forcing you to lots of syntax noise
17:35:30 <mm_freak> jkff: both
17:35:37 <mm_freak> benmachine: yes, but not a major one
17:35:45 <nand`> mm_freak: yeah, it's a bit more compact - but I meant as a language; oh, F# also doesn't have ‘null’ for its own types
17:35:49 <jkff> Regarding F#, I once tried to rewrite a C# project in it, but decided not to, because I figured the difference would be merely syntactical… C# is good enough already :)
17:35:53 <ddarius> Though Visual Studio does let you execute arbitrary F# which it doesn't for C# and that can be very convenient.
17:36:07 * ddarius agrees with jkff overall.
17:36:13 <Z`> I thought c# has unsafe keyword ?
17:36:32 <dolio> ddarius: I think we've begun to suspect at work that Scala's problem isn't actually Java (well, not all of them, at least).
17:36:44 <nand`> Z`: you mean for pointer arithmetic and stuff?
17:36:44 <mm_freak> one nice thing about F# is the TCO and the optional monadic syntax
17:36:55 <Z`> nand`: yeh
17:37:01 <ddarius> dolio: Certainly not all of them, but many problems are caused by trying to be true to Java.
17:37:01 <mm_freak> although the syntax is really ugly in F#
17:37:03 <nand`> F# also lets you shadow names, something that C# apparently still hasn't figured out
17:37:12 <ddarius> dolio: Reading the section on .equals in Odersky's book is laughable.
17:38:22 <frio> eurgh
17:38:24 <dolio> I don't know that I've seen that.
17:38:26 <frio> scala upsets me
17:38:41 <jkff> mm_freak: TCO, hm - is proper TCO really implemented in .NET runtime?
17:38:49 <frio> from a pure SE standpoint, it reminds me too much of perl and ruby: one man's scala can be radically different from the next's
17:38:50 <nand`> jkff: yeah
17:38:59 <mm_freak> clojure started out as a more promising project, but while providing a nicer syntax and better supporting FP they have removed the static type system, which destroys everything again
17:39:11 <jkff> band`: Whoa. I remember they tried to, but I didn't know they got all the way. So - no corner cases, real TCO like in Scheme?
17:39:12 <nand`> jkff: you can actually open up the .exe obtained from compiling C# code and change the regular calls to tail calls if you want
17:39:16 <mm_freak> apparently only haskell and ocaml programmers are skilled at making programming languages
17:39:25 <frio> there's a typed clojure extension on the way mm_freak (fwiw, anyway)
17:39:33 <mm_freak> jkff: dunno, but F# performs it
17:39:57 <nand`> jkff: I can't be fully sure, I'm not that intimate with the .NET, but I know the CLR has a ‘tail’ instruction which makes the next call an actual tail call
17:40:03 <Associat0r> yes .NET has proper TCO
17:40:09 <mm_freak> jkff: a long time ago i've written monadic parser combinators based on CPS in F#…  that depends on TCO a lot
17:40:14 <Associat0r> http://blogs.msdn.com/b/fsharpteam/archive/2011/07/08/tail-calls-in-fsharp.aspx
17:40:19 <jkff> Cool, thx!
17:40:44 <mm_freak> frio: yeah, but i'm having doubts that clojure is really worth looking at, even with types
17:40:59 <nand`> anybody have experience with Frege?
17:41:05 <dolio> ddarius: Anyhow, we had a week recently where we were trying to port something Ed designed in Haskell over, and it was just one nightmare after the next, purely with all the slightly-more-advanced-than-Java type system features.
17:41:13 <mm_freak> as a haskell programmer i'm very difficult to impress
17:41:22 <mm_freak> (when it comes to programming languages)
17:41:28 <dolio> So we ended up just casting some things through Any, because nothing else actually worked.
17:41:47 <SLi> If I have Timed t = Timed { time :: Float, value :: t }, and the corresponding Functor instance for it, is there some clean way (using fmap etc.) to implement the equivalent of mapMaybe for a list of these, if I want to have a mapping function mapMaybeTimed :: (a -> Maybe b) -> [Timed a] -> [Timed b]?
17:41:49 <mm_freak> that's why i also turned off the Go presentation in the middle…  it's not a language worth looking at from my viewpoint
17:42:07 <SLi> Perhaps somehow using the Maybe monad?
17:42:09 <nand`> mm_freak: It's hard to get impressed when you're looking at the wrong languages
17:42:10 <mm_freak> they added concurrency and basically got everything else wrong
17:42:11 <frio> really mm_freak? i've found clojure to be quite brilliant; and rich hickey's talks on the language make me a lot happier about it. the only thing i dislike about it is (again) the JVM, which leads to painfully long compile/start times
17:42:14 <Nafai> mm_freak: I have a hard time looking at any braces and semicolon language any more
17:42:28 <jkff> mm_freak: Go has a couple of interesting features IMO. I like the way it handles resource cleanup.
17:42:41 <nand`> SLi: catMaybes . map sequenceA or something is what I would be thinking
17:42:55 <mm_freak> jkff: more interesting than haskell's?
17:43:11 <nand`> ie. Timed (Maybe b) -> Maybe (Timed b) followed by [Maybe x] -> [x]
17:43:23 <jkff> mm_freak: Just different. I never programmed in Go, so I don't know what it's really worth
17:43:23 <nand`> jkff: thing is, they're improvements over something like C
17:43:35 <nand`> not something like Haskell
17:43:37 <jkff> mm_freak: Other than that, probably not that interesting from a PLT perspective, but if it's actually fast as C and more convenient/safe, I'd give it a shot
17:43:44 <nand`> which doesn't *need* built-in resource management stuff, since you can define your own
17:43:45 <SLi> nand`, thanks, that looks interesting. sequenceA is somewhat new to me, I'll have to study applicative functors :)
17:44:33 <mm_freak> jkff: it's not…  it's C with hundreds of syntactic constructs, slower and with about the same type system
17:44:35 <nand`> SLi: if you want to avoid the overhead for now you can easily write Timed (Maybe a) -> Maybe (Timed a) yourself: Timed t m = fmap (Timed t) m
17:44:41 <nand`> f (Timed t m) *
17:44:49 <mm_freak> don't waste your time on Go…  if you want to do systems programming, use haskell or erlang
17:44:59 <mm_freak> Go is just a poor man's erlang
17:45:09 <nand`> Go seems to fill no niche
17:45:23 <adnauseam> is there a better way to find an element's position in a list without checking if it's in a list
17:45:39 <adnauseam> or must i always check if it's in the list?
17:45:48 <ivanm> @type index
17:45:49 <SLi> nand`, that looks like what I tried to do but failed :) But I guess I'll want to look into sequenceA too. Thank you!
17:45:49 <jkff> mm_freak: I mean the defer statement.
17:45:49 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
17:45:52 <mm_freak> adnauseam: finding out the position is an implicit membership test
17:45:57 <ivanm> @hoogle a -> [a] -> Int
17:45:57 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
17:45:57 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
17:45:58 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
17:46:07 <adnauseam> oo index
17:46:11 <frio> go's not that bad
17:46:14 <Associat0r> mm_freak: last time I checked, Rust was a proper systems language
17:46:31 <ivanm> adnauseam: you don't want the Ix-based index function, that won't do what you want
17:46:32 <mm_freak> jkff: could you explain that statement briefly?
17:46:38 <ivanm> but there's indexOf or something IIRC
17:46:43 <frio> I'm currently looking at it strongly for running a few tiny web services on a raspberry pi
17:46:46 <ivanm> and the safe elemIndex in Data.List
17:46:51 <jkff> mm_freak: defer f(x,y,z) means evaluate f(x,y,z) after the current function returns
17:47:08 <mm_freak> Associat0r: probably nicer than Go, but it's an OO language IIRC
17:47:10 <jkff> mm_freak: http://blog.golang.org/2010/08/defer-panic-and-recover.html
17:47:10 <adnauseam> mm_freak: yeah i was thinking about it. if i implement it witout the True/False of a membership function i would have still needed to return then a number, which would have been a bit strange :/
17:47:19 <Associat0r> mm_freak: you need easy representation and mem alloc control to be considered a systems lang in my eyes
17:47:35 <Associat0r> mm_freak: it's multiparadigm
17:47:42 <mm_freak> Associat0r: Go is sold as a language for server implementations and similar things
17:47:51 <jkff> mm_freak: E.g. you can, in a loop, open a few files and defer closing them
17:48:03 <mm_freak> jkff: that's what ResourceT does
17:48:05 <mm_freak> in haskell
17:48:19 <mm_freak> open a scope, defer actions, leave the scope
17:48:33 <mm_freak> conduit is built on that monad transformer
17:48:49 <jkff> mm_freak: Oh, cool, I didn't look into that
17:48:51 <mm_freak> there is also RegionT, but it's less powerful
17:48:52 <hpaste> staticshock pasted “can this be improved?” at http://hpaste.org/74656
17:49:05 <mm_freak> jkff: you could write such a monad yourself easily
17:49:24 <jkff> mm_freak: Sure; it's still an interesting construction for someone grown on try/finally :)
17:49:49 <mm_freak> staticshock: liftA2 (*)
17:49:57 <mm_freak> > liftA2 (*) [1..3] [10,20,30]
17:49:59 <lambdabot>   [10,20,30,20,40,60,30,60,90]
17:50:19 * staticshock looks it up
17:50:26 <mm_freak> staticshock: Control.Applicative
17:51:13 <mm_freak> jkff: of course, but that's the great thing about haskell…  everything you have to expensively implement as language features/macros you get as first class stuff in haskell
17:51:38 <nand`> jkff: like I said, haskell doesn't need these things built in because you can easily define them yourself
17:52:05 <nand`> mixture of lazy semantics and a powerful type system that lets it do that
17:52:07 <mm_freak> as such haskell encourages you to use more domain-specific stuff instead of dangerous generic for-loops
17:52:21 <jkff> Agreed. I'm all for Haskell, though I enjoy the imperative style sometimes too.
17:52:37 <mm_freak> jkff: you have the imperative style in haskell…  if you insist, you can even implement goto
17:52:54 <jkff> mm_freak: I know that too ;) It still feels different though
17:53:03 <nand`> https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs <- look, you have an imperative language
17:53:13 <mm_freak> jkff: yes, because the for-loop is not predefined =)
17:53:17 <nand`> oh, and it has go-style ‘defer’ too
17:53:22 <nand`> what's so special about go now?
17:53:31 <staticshock> so, the description of lifta2 in the docs is "lift a binary function to actions"
17:53:40 <staticshock> and i'm not sure what the "to actions" part means
17:53:41 <mm_freak> nand`: it's from google, so it creates a lot of marketing hype
17:53:42 <jkff> band`: Don't know, I'd have to actually program in Go to answer :)
17:54:03 <mm_freak> staticshock: think of a list as an action with a non-deterministic result
17:54:04 <c_wraith> @src liftA2
17:54:05 <lambdabot> liftA2 f a b = f <$> a <*> b
17:54:08 <Associat0r> mm_freak: http://corp.galois.com/blog/2010/8/11/tech-talk-video-developing-good-habits-for-bare-metal-progra.html  |   http://www.haskell.org/haskellwiki/DDC you might want to check out these for haskell-like systems programming
17:54:28 <mm_freak> Associat0r: i know those
17:54:28 * nand` thinks ‘bare metal programming’ and ‘systems programming’ are orthogonal
17:54:28 <c_wraith> liftA2 is just a convenience function, if you know what Applicative is for in general
17:54:40 <hpc> @src liftA2
17:54:40 <lambdabot> liftA2 f a b = f <$> a <*> b
17:54:41 <nand`> bare metal is something the runtime and compiler are concerned with
17:54:52 <nand`> the system shouldn't even care. In fact, it's better if it doesn't - more portability, more safity
17:54:55 <nand`> safety*
17:55:13 <nand`> so any language targeted at ‘bare metal programming’ is inherently nothing better than a compilation target
17:56:00 <mapreduce> Arguably Forth is a reasonable language aimed at that.
17:56:21 <jkff> nand`: true until you run into things current compilers can't compile well (e.g. I doubt we'll soon be writing a videocodec in haskell)
17:56:46 <jkff> Though I admit that the area is pretty narrow
17:56:52 <Associat0r> nand`: that's all nice in theory if you don't have resource constraints or hard real-time guarantees to worry about
17:57:39 <nand`> Associat0r: I don't know what you mean by ‘resource constraints’ in this context
17:58:57 <ddarius> dolio: I know from my impression talking and occasionally working with Ed that Scala's type system promises far more than, at least, the implementation delivers.
17:59:28 <mm_freak> jkff: fast video codecs can be written in haskell actually using the Store or Traced comonads
17:59:37 <jkff> nand`: E.g. memory consumption is often hard to control
17:59:39 <dolio> Yeah.
17:59:58 <jkff> mm_freak: Can you tell more?
18:00:08 <mm_freak> jkff: if you ask a question, yes =)
18:00:32 <jkff> mm_freak: Heh. What do these comonads do?
18:00:53 <jkff> mm_freak: I mean, do they magically make use of the hardcore CPU instructions?
18:01:12 <mm_freak> jkff: first some theory:  an array is basically just a mapping from an index to a value
18:01:28 <johnw> I'm thinking of using the Store Comonad to model a Git repository
18:01:54 <johnw> then I can have an "extend" that walks a branch
18:01:58 <mm_freak> jkff: so you can represent an array as a function p -> a, where p is the index type
18:02:26 <mm_freak> jkff: if you couple such a function with an index, you get the Store comonad:  data Store p a = Store (p -> a) p
18:02:40 <mm_freak> the really interesting thing about this comonad is the 'extend' combinator
18:02:51 <mm_freak> extend :: Store p a -> (Store p a -> b) -> Store p b
18:03:22 <mm_freak> suppose you want to implement a blurring filter
18:03:35 <mm_freak> now all you need to implement is a function that calculates the color value for a single pixel
18:03:41 <mm_freak> then use 'extend' with that function
18:03:59 <mm_freak> oh, the type signature is wrong
18:04:05 <jkff> mm_freak: Ok, this sounds pretty interesting so far and might enlighten my understanding of comonads. Please go on :)
18:04:10 <mm_freak> extend :: (Store p a -> b) -> Store p a -> Store p b
18:04:18 <mm_freak> extend (average . neighbourhood) myVideo
18:04:39 <johnw> jkff: the extended function can see the surrounding pixels
18:04:46 <mm_freak> just compare 'extend' to (>>=)
18:04:48 <johnw> jkff: and returns the new value for the blurred pixel
18:04:56 <mm_freak> (>>=) :: m a -> (a -> m b) -> m b
18:05:00 <nand`> since you have p -> a and you know p for each pixel ?
18:05:04 <johnw> it's an inverted >>=
18:05:09 <mm_freak> (>>=) allows you to construct a monadic value by looking at a point
18:05:24 <mm_freak> extend allows you to construct a point by looking at the whole comonadic value at that point
18:05:26 <johnw> nand`: since you have Store p a for each pixel!
18:05:28 <jkff> Yup, I know what a comonad is, but I haven't seen a compelling example yet. Seems like now I'm in the middle of seeing one.
18:05:46 <johnw> nand`: and the Store will have been indexed to the pixel you're intended to blur
18:06:02 <nand`> johnw: well, the function is always the same, right?
18:06:05 <jkff> mm_freak: Ok, why will this blur function be fast?
18:06:13 <mm_freak> jkff: the argument received by the argument function is a store located at the target point, so all you need to do is to look at the surroundings locally
18:06:25 <johnw> nand`: yes, but the "value" of the Store is seen to be different each time
18:06:44 <nand`> yeah, so like I said; you have p -> a and you know p for each pixel
18:06:49 <nand`> read as (you have p -> a and you know p) for each pixel
18:06:51 <mm_freak> jkff: it will be the same function you would have written tediously using explicit iteration, but now the comonad can parallelize the iteration under the hood
18:07:19 <johnw> nand`: are conflating p with Store p a?
18:07:25 <jkff> mm_freak: Does there exist some example code that actually does something like this and is fast?
18:07:34 <johnw> nand`: it's not just that you have p, but you can peek at the pixels near to p as well
18:07:35 <nand`> mm_freak: I think he's more concerned about whether or not that will boil down to stuff like MMX primitives
18:07:40 <nand`> in the implementation
18:07:41 <johnw> nand`: using relative offsets (provided by Store)
18:07:57 <jkff> nand`: Right. Maybe mm_freak will tell me that it will :)
18:08:07 <mm_freak> jkff: edwardk uses comonads extensively in his projects…  for example the now obsolete data-lens library uses Store
18:08:11 <edwardk> nand`: was it you who wanted the table of operators from lens? https://github.com/ekmett/lens/wiki/Operators
18:08:18 <nand`> edwardk: it wasn't
18:08:20 <nand`> but that's nice
18:08:28 <johnw> edwardk: it was I
18:08:31 <edwardk> nand`: its slow going but its fleshing out =)
18:08:35 <johnw> yay!!
18:08:36 <mm_freak> jkff: no, it won't use MMX, until GHC supports compiling to MMX =)
18:08:39 <johnw> you are my hero
18:08:49 <johnw> mounting on wall...
18:08:56 <edwardk> johnw: about 1/3rd of the way through. don't mount it yet ;)
18:09:10 <nand`> johnw: I'm not sure what's unclear about what I said; since Store p a ≅ (p -> a, p); extend ≅ ((p -> a, p) -> b) -> Store p a -> Store p b
18:09:12 <johnw> what's the difference between .~ and <.~?
18:09:19 <edwardk> click on them ;)
18:09:23 <jkff> mm_freak: That's kinda my point :) It still seems interesting though. Do you mean edwardk has projects which use Store for high-performance computing?
18:09:34 <nand`> thus in your ‘iteration function’ you know ‘p -> a’ and ‘p’, for each pixel
18:09:36 * Philippa grins
18:09:37 <jkff> mm_freak: Also, what is Traced? The definition in docs didn't give me the slightest hint :(
18:09:43 <mm_freak> jkff: to have MMX code right now you would need restricted comonads (basically the dual of RMonad)
18:09:50 <johnw> nand`: ok, I see what you mean now, sorry
18:09:52 <Philippa> jkff, meet edwardk. He does things you wouldn't think were possible :-)
18:10:02 <mm_freak> jkff: Traced is Store, where the current position is always mzero =)
18:10:02 * edwardk takes a bow.
18:10:26 <mm_freak> jkff: it's a Store, where you don't move the cursor, but you move the store around the origin…  that's a way to look at it
18:11:01 <johnw> mm_freak: interesting
18:11:24 <mm_freak> jkff: notice the Monoid constraint on the Comonad instance…  i already suggested to edwardk to use a VectorSpace constraint instead, but he refuses (for engineering reasons)
18:12:08 <mm_freak> the nice thing about Traced is that your position is always zero, so some arithmetic things get easier
18:12:58 <jkff> mm_freak: I still don't get it, let me try formulating a question
18:13:11 <mm_freak> i'll be right back, but just ask, i'll answer later
18:13:18 <Cale> mm_freak: Every vector space is a monoid anyway -- can you make good use of the scalar multiplication in the instance?
18:14:13 <jkff> mm_freak: I'm afraid I just don't understand it at all. Why is it called Traced? Can you give a good example of its type arguments?
18:15:22 <H4rx0rBG00> !help
18:16:09 <Philippa> H4rx0rBG00: what makes you say that?
18:19:07 <ivanm> H4rx0rBG00: randomly trying to determine which bots are in the channel?
18:20:48 <ivanm> OK, that response was meant to be at Philippa not h4*
18:23:06 <pdxleif> Digestive functors are the new Formlets?
18:26:07 <hashem> I'm doing foo^0.5, but it says ambiguous variable in constraints... Fractional from the "0.5" and Integral from the "^". I tried changing it to foo^(0.5::Integral) but then it complains "Expecting one more argument to 'Integral'"
18:26:33 <Cale> hashem: Use ** for fractional exponents
18:26:39 <rwbarton> or in this case, sqrt
18:27:05 <hashem> ah, thanks guys
18:28:02 <Cale> hashem: There are three exponentiation functions in the Prelude, (^) needs a nonnegative integer exponent, but can take any kind of number as the base. (^^) can have a possibly negative integer exponent, but is restricted to base types which allow fractions, while (**) can have floating point exponents and requires a floating point base.
18:28:35 <Z`> when I run a compiled program, does it take a lot of time for the runtime to be initialized? (I run an app 1000 times, and I'd like to know how much time roughly is spent in initialization)
18:28:55 <jkff> Z`: Why don't you "time" an empty program?
18:29:04 <Z`> nice idea jkff -- thanks
18:29:20 <hashem> Thanks Cale, that's a very clear explanation
18:30:01 <startling> Z`, might also be worth timing within haskell itself
18:30:16 <Z`> I see that ghc has dtrace probes
18:30:19 <Z`> very nice
18:31:33 <adnauseam> is it good practice to count indices starting at 0, or at 1 ?
18:31:43 <Cale> adnauseam: yes
18:32:03 <adnauseam> at 0 it is then!
18:32:07 <adnauseam> thanks man
18:32:33 <Cale> I have actually run into a case where 1 is really more natural, but usually it's 0
18:33:01 <Cale> (i.e. more natural for the purpose of an algorithm, rather than for some human reason)
18:33:02 <Mortchek> Cale, I thought 0 was more Natural
18:33:06 <Mortchek> :P
18:33:15 <startling> Mortchek, talk to Peano
18:33:15 * ddarius likes to say (^) for Monoid, (^^) for Group, and (**) for Floating(?)
18:33:57 <adnauseam> it's somewhat non intuitive to think of the place holder for nothing to siginify an element, but from a concrete point of a view, it is actually the first member of a set
18:34:03 <adnauseam> in terms of ordering
18:34:13 <startling> (for some reason I seem to remember reading that Peano started with 1, not 0. Am I mistaken?)
18:34:25 <adnauseam> i've heard that too
18:34:41 <startling> oh, from wikipedia: "Peano's original formulation of the axioms used 1 instead of 0 as the "first" natural number."
18:34:57 <ddarius> I could easily believe it as 0 is often awkward for number theory.
18:34:59 <adnauseam> my math professor was soemwhat threatening when we suggested that we should consider N* and not N
18:35:08 <ddarius> Though, 0 is the top of the divisibility lattice...
18:35:09 <scshunt> 0 is useful for set theory
18:35:41 <scshunt> and I prefer 0 at the very least because N and N^+ are then easy to notate
18:35:43 <adnauseam> is it not as  useful in category theory ?
18:35:56 <Mortchek> Don't all the same axioms/theorems apply whether you start at 0 or 1 anyway?
18:35:56 <adnauseam> scshunt: what's N^+ ? :o
18:36:07 <startling> Mortchek, well, there's no additive identity. :)
18:36:12 <Mortchek> Oh, true.
18:36:15 <adnauseam> Mortchek: it breaks the identity for addition
18:36:24 <ddarius> N tends to be more natural in category theory, though there's nothing keeping you from nicely formalizing N^+.
18:36:30 <startling> otherwise I think it's roughly the same
18:36:35 <pdxleif> Z`: From tests I did before, Hello World in Haskell started faster than interpreted langs like Ruby, Python, etc, but not as fast as C.
18:36:43 <adnauseam> damnit what's N^+ :[[
18:36:52 <startling> yeah, I'm wondering too
18:36:53 <Mortchek> adnauseam, positive integers I think.
18:36:57 <ddarius> adnauseam: Positive naturals.
18:37:06 <adnauseam> pdxleif: aye haskell is written in C
18:37:18 <Z`> pdxleif: 1000 empty haskell programs take up 12 seconds in my machine
18:37:19 <pdxleif> The runtime, anyways.
18:37:27 <adnauseam> pdxleif: though i believe one can write C as part of a haskell program
18:37:46 <startling> adnauseam, but then you'd need both their runtimes
18:37:55 <startling> adnauseam, not likely to improve speed for "hello world"
18:37:55 <adnauseam> pdxleif: the trick is try running 1000 concurrent hello world programs, and see which finishes first
18:37:58 <ivanm> where's preflex?
18:38:02 <pdxleif> Wonder if there's an option for pre-loading / leaving the runtime running between invocations?
18:38:02 <ivanm> @seen preflex
18:38:03 <lambdabot> Unknown command, try @list
18:38:10 <adnauseam> which is where haskell strength lies
18:38:14 <ivanm> wait, lambdabot doesn't even pass @seen onto preflex any more?
18:38:21 <startling> ivanm: preflex is dead
18:38:25 <ivanm> :(
18:38:28 <ivanm> who killed it?
18:38:30 <pdxleif> Z`: For that case it sounds like you'd want a server process to leave running?
18:38:30 <startling> or so I hear
18:38:46 <adnauseam> Z` that was toally asynchrnous btw, we came up with the 1000 example independently :o
18:38:51 <Cale> When you're memoising the computation of the Levenshtein distance of two strings, and you use an array to hang on to the results for various positions through the string, it's more natural to use 1-based indices for that array, and 0-based indices for the string, oddly enough.
18:38:51 <Z`> Ah no, I don't start + stop so many times
18:38:55 <pdxleif> Are you planning on these running serially or concurrently?
18:38:57 <ddarius> If mauke were here, he'd be the one to ask, but maybe mauke not being here is why preflex isn't here.
18:39:06 <ivanm> hmmmm
18:39:12 <Z`> I just don't have a bigger input file, so I instead run my app again and again (minus the intitialization time)
18:39:22 * ivanm was about to do "preflex: seen mauke" and then realised that that wouldn't work...
18:39:45 <adnauseam> Mortchek: ddarius: where can i get an intro into being able to read that notation of N^+ ?
18:39:51 <adnauseam> not sure what it's called
18:40:03 <Mortchek> It's actually N then a superscript +.
18:40:15 <Mortchek> But we use ^ in mediums where superscript is inconvenient.
18:40:16 <ddarius> It's TeX notation (though commonly used other places as well.)
18:40:20 <adnauseam> oh so it's Latex
18:40:24 <startling> ohhhh
18:40:29 <startling> hah, didn't even get that
18:40:47 <startling> I've written that before, too. :(
18:41:05 * adnauseam feels enlightened
18:41:08 <Mortchek> As for an intro on that notation, I have no idea. I think the first I saw it was in intro to number theory and it just made sense enough I didn't question it. :P
18:41:29 <Mortchek> Well, we talk about Z^+ there.
18:41:32 <ddarius> Mortchek: The notation isn't standardized though there are some rather commonly used notations.
18:41:57 * adnauseam shudders at the thought of non standardized math notation
18:41:59 <adnauseam> :[
18:42:12 <adnauseam> might as well shoot puppies in the face
18:42:14 <startling> adnauseam, do you shudder all the time?
18:42:22 <Cale> What
18:42:22 <ddarius> There doesn't exist any standardized mathematical notation, so I'm assuming you shudder at all mathematical notation.
18:42:23 <adnauseam> startling: it's been getting better lately =/
18:42:23 <Mortchek> Z^+ and N^+ are equal, aren't they?
18:42:40 <ddarius> Mortchek: It depends on how rigorous you're being.
18:42:56 <Mortchek> I was technically incorrect earlier when I said N^+ was the positive integers.
18:43:06 <Mortchek> But as far as I know they are the same set.
18:43:06 <scshunt> Mortchek: yes, they are the same
18:43:08 <ddarius> And also just what you define them to be.
18:43:11 <scshunt> so N^+ is the positive integers
18:43:12 <Cale> ddarius: There's no standard, but if you write anything nonstandard, the council of math gnomes, (who also decide what the axioms are) will haunt you in your dreams.
18:43:29 <Mortchek> Well, let's say I took an extra step beyond what was absolutely necessary.
18:43:32 <scshunt> Cale: tell them to put in a good word for the continuum axiom
18:43:48 * ddarius writes N^+ for the set of all natural numbers with 0 because it's N (the set of natural numbers without 0) plus something or augmented.
18:43:53 <Cale> scshunt: You like CH? :)
18:44:45 <startling> adnauseam, look at all the glorious overlap! http://en.wikipedia.org/wiki/List_of_mathematical_symbols
18:44:46 <Mortchek> ddarius, that is pretty much the opposite of what I'm used to in this case. + means "limit to positive".
18:45:03 <adnauseam> we need to do a Oppa Haskell Style video
18:45:14 <adnauseam> startling: fuck me.
18:45:32 <adnauseam> right. i think i will just stick to therse 4 books i have here. nothing else exists outside of them. NOTHING.
18:45:42 <monochrom> we need an official authority </sarcasm>
18:45:56 <startling> I like this guy: <:
18:46:00 <startling> he's pretty cute
18:46:07 <adnauseam> :[
18:46:19 <ddarius> @official definition of N
18:46:19 <lambdabot> Unknown command, try @list
18:46:41 <ddarius> monochrom: We can also redefine N weekly.
18:46:48 <monochrom> oh!
18:47:14 <pdxleif> Math notation is standardized way better than language.
18:47:32 <staticshock> is there a way to update the module search path dynamically?
18:47:37 <monochrom> we need a weekly official authority
18:47:49 <pdxleif> Someone can come up to me from most any country, and I can read their math homework a lot better than the prose.
18:47:52 <ddarius> pdxleif: Unfortunately, math notation requires much more precision and less ambiguity than language.
18:48:06 <staticshock> i have two scripts in sibling directories and i was hoping to import one into the other
18:48:10 <Mortchek> Out of curiosity, is general mathy stuff generally on-topic here?
18:48:16 <ddarius> Mortchek: No.
18:48:17 <Cale> Math language is standardised way better than notation :)
18:48:18 <monochrom> no
18:48:40 <Mortchek> But talking about, say, category theory as it relates to Haskell might be?
18:48:52 <pdxleif> Just memorize all the different ways of writing things like "OR" and "SUBSET", "PRODUCT", etc
18:48:59 <ddarius> Talking about X as it relates to Haskell is generally on topic for all X that actually have some relation to Haskell.
18:49:07 <Mortchek> Sounds good.
18:49:17 <Cale> But we have hour long discussions about set theory anyway
18:49:24 <Cale> so don't sweat it
18:49:44 <Mortchek> Yeah, understood. I just don't want to blatantly start a discussion that's completely off-topic.
18:49:56 <ddarius> Much like the principle of revealed preference, what's on-topic is what actually happens and what you get away with.  The real rules are arbitrary and whimsical.
18:50:19 <staticshock> anyone? can i import some functions from a different file in a sibling directory?
18:50:29 <monochrom> the GHC user guide has how to set the module search path. I don't know whether it is good enough for you, and I am too lazy to find out
18:50:51 <Cale> staticshock: hmm, if you run the compiler from the shared root of the two modules
18:51:09 <Cale> staticshock: and you name the modules according to where they occur
18:51:16 <adnauseam> i wonder if peyton jones lurks on #haskell
18:51:28 <ddarius> adnauseam: He's here very occasionally.
18:51:33 <adnauseam> :o
18:51:36 <ddarius> Much less so lately (i.e. in the last several years).
18:51:44 <ddarius> He's on #ghc more as you might imagine.
18:51:45 <Cale> ddarius: Oh really?
18:51:52 <Cale> What's his nick?
18:51:55 <ddarius> simonpj
18:52:02 <Cale> oh, interesting
18:52:07 <Cale> I never see him talk
18:52:10 <ddarius> Simon Marlow is here fairly often but rarely talks.
18:52:33 <Cale> yeah, he's JaffaCake
18:59:55 <staticshock> ok. i guess i'm looking for more of a scripting language feature.
19:02:26 <scri> in pure untyped lambda calculus, would this be a normal form? > f.x.(f) (((f.y.y) (f)) (x))
19:03:04 * hackagebot ghc-vis 0.3.1 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.3.1 (DennisFelsing)
19:03:21 <ReinH> *click*
19:03:45 <scri> i'm wondering about the (f.y.y) (f)
19:04:01 <ddarius> If you have a redex, it's not normal form.
19:04:44 <scri> see, that makes sense but for a project spec it says, a beta reduction on a lambda does nothing
19:04:48 <ReinH> uh. ghc-vis is fucking wizard shit. o_O
19:04:52 <ReinH> that's really awesome
19:05:17 <ReinH> sorry for my profanity, I'm just really impressed
19:05:31 <monochrom> it's ok, we're not PG-14 or something
19:05:40 <ReinH> fuck yeah we're not
19:05:54 <ReinH> but seriously that's really cool
19:06:05 <ReinH> so guess what's happening this weekend
19:06:15 <ReinH> episode 3!
19:06:22 <ReinH> I think it'll be titled "It's About Fucking Time"
19:06:23 <startling> ReinH: are you going to vis the hell out of ghc?
19:06:25 <startling> oh
19:06:40 <ReinH> startling: I'm hoping I can use this to demonstrate lazy evaluation though
19:06:43 <ddarius> scri: Yes, if the top level operator is lambda, then beta reduction doesn't apply.
19:06:46 <ReinH> because thunks are hard
19:06:50 <scri> ah nvm, it's using call by name
19:07:10 <ReinH> although I read a very cool explanation that involved presents and ghosts recently
19:07:13 <ReinH> that was nice
19:07:21 <ddarius> scri: If you make application explicit, beta reduction says (\x -> E[x]) @ y ~> E[y]
19:07:25 <AfC> "thunks are hard" heh. "but sparks are shiny!" :)
19:07:30 <monochrom> oh yikes, you're the video lecture guy!
19:07:36 <ReinH> AfC: ooh shiney
19:07:41 <ReinH> monochrom: ?
19:08:02 <monochrom> the video lecture guy likes to swear! this is a disaster :)
19:08:08 <ReinH> I don't understand :)
19:08:20 <monochrom> but I hate "thunk"
19:08:31 <ReinH> monochrom: are you calling my videos lectures? :p
19:08:33 <Philippa> eh, thunk that
19:08:33 <ReinH> that's rude
19:08:39 <anotherone> lol
19:08:53 <ReinH> they have 8bit funk music ffs
19:08:56 <scri> ddarius: when would application not be explicit?
19:09:14 <Philippa> we use implicit type applications all the damn time
19:09:15 <scri> or, when would that not be the reduction for an application
19:09:21 <ddarius> Application is usually represented by juxtaposition.
19:09:36 <scri> oh, yeah ok
19:09:37 <ReinH> how many lectures are prefixed and postfixed by 8bit funk music?
19:09:44 <ReinH> answer: zero. zero lectures.
19:09:46 <randomclown> why isnt mlt bundled by defalt?
19:09:50 <randomclown> default*
19:09:50 <ddarius> I'm saying the definition of beta reduction is that it only applies when the top level operator is application (denoted by @ in my example).
19:09:52 <scri> so you just mean notation?
19:10:04 <scri> right, thanks
19:10:13 <monochrom> because the aim of GHC is to bundle less by default
19:10:37 <monochrom> go for Haskell Platform if you want "common" instead of "minimal"
19:13:24 <ReinH> platform is where it's at :)
19:13:53 <ReinH> so what's the current state of cabal dependency resolution?
19:14:07 <ReinH> As someone who has written his fair share of topsorts, I am interested in this problem
19:14:23 <ReinH> does cabal use topsort of some kind of search algo?
19:14:28 <ReinH> *or
19:15:14 <randomclown> one can just use Either without anything from control.monad.exception right
19:15:28 <mm_freak> Cale: there are vector spaces that aren't monoids
19:15:32 <ReinH> randomclown: yes
19:15:38 <mm_freak> Cale: in haskell that is
19:16:04 <mm_freak> Cale: i suppose you could nowadays just use Num instead of Monoid or VectorSpace
19:16:05 <scri> n00b q: i tried installing ghc-vis, it tells me glib and cairo failed to install, ExitFailure 1
19:16:15 <randomclown> what extra does control.monad.exception provide to using either
19:16:19 <scri> where do i go from here
19:16:21 <ReinH> randomclown: Either is available in the prelude http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Either
19:16:26 <Jafet> You'll have to ask dcoutts, but topsort might not be enough for cabal.
19:16:30 <ReinH> how do I hoogle search with the bot?
19:16:58 <monochrom> for glib and cairo, you first need gtk2hs-buildtools
19:16:59 <Clint> with @hoogle
19:17:03 <ReinH> I need to learn the ways of LambdaBot
19:17:11 <ReinH> is there a cheat sheet or a manpage or do I just read the docs?
19:17:16 * Clint eyes cabal-sort
19:17:23 <ReinH> I figure I'm in here enough now, I should know how to use the tools ;)
19:17:24 <Cale> mm_freak: Or write a lifting instance?
19:17:25 <scri> monochrom: that fails too
19:17:40 <Cale> (for a newtype)
19:17:40 <ReinH> Clint: so http://hackage.haskell.org/package/cabal-sort
19:17:41 <ReinH> thanks
19:17:43 <ReinH> I'll check that out
19:18:22 <ReinH> so the first paragraph indicates " topologically sorted"
19:18:26 <edwardk> johnw`: ok, i think the operator list is at a relatively stable point
19:18:29 <ReinH> I wonder if anyone has approached it as a search problem
19:18:34 <ReinH> edwardk: hai :)
19:18:49 <edwardk> heya
19:18:53 <johnw`> edwardk: thanks!
19:19:07 <scri> says they fail during the configure step. does ExitFailure 1 have any significance?
19:19:14 <td123> can anyone tell me where I can find documentation about this line? {#pointer GDestroyNotify as DestroyNotify#}
19:19:15 <edwardk> johnw`: i may add sections to that page enumerating combinators as well as operators
19:19:26 <johnw`> yes please
19:19:36 <monochrom> ExitFailure 1 has almost no significance
19:19:56 <staticshock> what's a simpler way to write: map (\i -> (\j -> i `mod` j == 0)) [2..20]
19:19:56 <johnw`> i think it indicates failure :)
19:19:59 <td123> I'm trying to understand what it does and what other options I can specify, and I know it's used to rename the pointer, but I'm not sure what to google
19:20:08 <johnw`> @pl map (\i -> (\j -> i `mod` j == 0)) [2..20]
19:20:08 <lambdabot> map (flip flip 0 . ((==) .) . mod) [2..20]
19:20:29 <johnw`> not an improvement
19:20:35 <staticshock> hm. what's @pl?
19:20:35 <monochrom> @src divides
19:20:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:20:49 <johnw`> recasts an expression in point-free notation
19:20:56 <johnw`> the opposite of @unpl
19:20:56 <Jafet> > map ((==0) .: mod) [2..20]
19:20:57 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
19:20:58 <lambdabot>    arising fro...
19:21:11 <Jafet> > map ((==0) .: mod) [2..20] [2..20]
19:21:13 <lambdabot>   Couldn't match expected type `[t1] -> t'
19:21:13 <lambdabot>         against inferred type `[a ...
19:21:14 <monochrom> (\i j -> i `mod` j == 0)
19:21:16 <Mortchek> @unpl foldl (+)
19:21:16 <lambdabot> foldl (+)
19:21:17 <Jafet> Oh wait
19:21:30 <Jafet> > map ((==0) .: mod) [2..20] <*> [2..20]
19:21:32 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
19:21:34 <johnw`> :t (.:)
19:21:35 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:21:36 <Cale> [\j -> i `mod` j == 0 | i <- [2..20]] -- if it can be considered any simpler, I don't know.
19:21:57 <johnw`> i forget what .: is useful for again
19:22:04 <johnw`> @unpl f .: g
19:22:04 <lambdabot> (f .: g)
19:22:15 <Twisol> (.).(.)
19:22:18 <Twisol> I think
19:22:34 <johnw`> @src (.:)
19:22:34 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:22:41 <johnw`> what is f .: g equivalent to?
19:22:44 <johnw`> and don't say fmap fmap fmap
19:22:49 <Jafet> (f .: g) x y = f (g x y)
19:22:56 <johnw`> ah that's it
19:22:58 <mm_freak> Cale: i'd like to keep it convenient =)
19:23:33 <Twisol> (.:) :: (a -> b -> c) -> (c -> d) -> (a -> b -> d)
19:23:35 <Mortchek> @unpl join (++)
19:23:36 <lambdabot> ((++) >>= \ a -> a)
19:24:02 <Twisol> except I probably have the first two in the wrong order ;P
19:24:07 <Nafai> johnw`: Hey, shapr is struggling with some C++ stuff in #haskell-blah, perhaps you have a moment to help our good friend? :)
19:24:15 <ddarius> johnw`: Of course it isn't fmap fmap fmap.  It's fmap fmap fmap f g.
19:24:22 <johnw`> what is #haskell-blah?
19:24:28 <monochrom> a channel
19:24:29 <shapr> johnw`: off-topic #haskell discussion
19:24:37 <staticshock> hm, i guess i just got more confused
19:24:50 <johnw`> isn't off-topic #haskell == every other channel? :)
19:25:04 <johnw`> shapr: can you summarize the question briefly?
19:25:07 <staticshock> where can i look up .: ?
19:25:07 <Twisol> every other channel doesn't have the same community/culture as #haskell
19:25:21 <thirsteh> johnw`: the topic was poultry before. Not sure there's a channel on Freenode for that
19:25:27 <shapr> johnw`: I don't understand how to declare and implement friend function operator<< overloading for a templated class.
19:25:27 <johnw`> #poultry
19:25:33 <johnw`> just no one is in it :)
19:25:35 <thirsteh> johnw`: It'd be ##poultry
19:25:42 <johnw`> sorry, have to go
19:25:44 <johnw`> i'll be back later shapr
19:25:46 <thirsteh> :D
19:25:51 <shapr> ok, bye!
19:26:00 <Twisol> what about &poultry?
19:26:47 <thirsteh> #haskell-blah is a channel for talking about things not related to Haskell with the same people
19:27:00 <shapr> thirsteh: Yah, that's accurate.
19:27:11 <thirsteh> including poultry
19:29:34 <staticshock> where can i look up .: ?
19:30:06 <appamatto> Is the haskell type checker basically a "logic programming" program?
19:31:01 <Jafet> appamatto: if you're close enough to glasgow
19:31:42 <Mortchek> ddarius, I think my brain exploded trying to comprehend the structure of a thing you'd need fmap fmap fmap to operate on.
19:31:51 <appamatto> Jafet, in physical proximity? :p
19:32:20 <Jafet> I've never tried that, but it may help.
19:32:35 <Jafet> If you can't afford to, turn on some ghc extensions
19:33:22 <appamatto> Is there much logic programming going on in Haskell?
19:35:51 <hashem> Why, in ghci, if I do :load main.hs, and I have a main.hs with a main function defined (and other stuff), only the main function is loaded?
19:36:11 <hashem> If I rename main.hs to temp.hs, everything :loads properly
19:36:33 <Mortchek> Ooh, it applies to something inside a functor within a functor, I think.
19:36:51 <Mortchek> s/inside/within/
19:36:55 <Jafet> hashem: see whether it is interpreting main.hs or temp.hs.
19:38:32 <Cale> hashem: check if there are .o/.hi files around
19:38:59 <Cale> hashem: if they're present, ghci will load them, and only the things exported from the module will be available (but it'll be compiled code, so it'll run fast)
19:40:19 <staticshock> how can i apply multiple filters to the same infinite list?
19:40:44 <Jafet> filter p . filter q ...
19:41:00 <Clint> filter (p && q) ?
19:42:01 <lightquake> @type (&&)
19:42:03 <lambdabot> Bool -> Bool -> Bool
19:42:11 <lightquake> @pl \x -> p x && q x
19:42:11 <lambdabot> liftM2 (&&) p q
19:42:15 <hashem> Cale, There are .o/.hi files around, but they're from the most recent compile of main.hs. It seems like ghci is getting confused with a main function being inside a main.hs file. Is that possible?
19:42:42 <monochrom> no
19:42:46 <appamatto> Are haskell programs automatically parallelized where possible?
19:42:52 <monochrom> no
19:42:56 <lightquake> 22:42:21          <monochrom> no
19:42:58 <lightquake> 22:42:25          <appamatto> Are haskell programs automatically parallelized where possible?
19:43:08 <lightquake> concurrency error!
19:43:14 <appamatto> haha
19:43:14 <monochrom> no
19:43:20 <Jafet> hashem: your module doesn't export anything, so when ghci loads its compiled version, it imports nothing except main
19:43:43 <thirsteh> sometimes when you have a problem, you'll go, "I know, I'll use threads!" Now you havtwo rpboelms.
19:43:57 <lpvb> no
19:43:59 <hashem> Jafet, how do you explicitly export something? I have several functions defined at the top level. main is just one of these functions.
19:44:04 <Twisol> thirsteh: I see what you did there
19:44:05 <thirsteh> STM to the rescue
19:44:36 <monochrom> you don't need to export things for this. just delete the .hi and .o files
19:44:50 <Jafet> module Foo where -- exports everything
19:45:04 <monochrom> this is so XY Problem now
19:45:05 <thirsteh> hashem: module Main where or module Main (a,b,c) where
19:45:26 <thirsteh> where a may be main
19:45:27 <thoughtpolice> @seen edwardk
19:45:27 <lambdabot> Unknown command, try @list
19:45:45 <hashem> ah thanks all, both suggestions worked :)
19:46:08 <appamatto> Ah I see, you use par and seq
19:46:18 <edwardk> heya
19:46:32 <thirsteh> appamatto: or forkIO. GHC will multiplex those lightweight threads automatically
19:46:37 <thirsteh> IIUC
19:46:45 <appamatto> Does Snap use explicit threads?
19:46:53 <Jafet> par and pseq are very primitive operators
19:46:58 <Jafet> seq is not a parallelism operator
19:47:04 <thirsteh> provided you compile with -threaded and run with e.g. foo +RTS -N
19:47:16 <Cale> hashem: Even if you specify the main.hs file, when there are .o files present it will load in compiled mode rather than interpreted.
19:47:21 <thoughtpolice> edwardk: ohai. in your series when you're talking about yoneda and mention the Yoneda Endo instance, what do you mean when you say 'positive and negative position' for the type in the definition of Endo? i've vaguely heard of this before but i was wondering :)
19:47:53 <hashem> Cale, right, that makes sense. However, I had *just* compiled the source, before running the interpreter anyway.
19:47:58 <Cale> hashem: I seem to recall some flag you could pass to avoid that, but I usually just delete the .o and reload
19:48:18 <Cale> If your module doesn't export anything other than main, then that's all you'll see
19:48:22 <monochrom> you can say :load *main.hs
19:48:23 <thirsteh> appamatto: Snap uses a lightweight thread per request AFAIK
19:48:28 <Cale> ah, cool
19:48:41 <edwardk> every time you wind up on the left hand side of a  ->   in the _ -> _ sense, you 'flip' sign. starting from positive.    a -> r   has a in negative position. (a -> r) -> r  has it back in positive position
19:48:46 <thirsteh> appamatto: that is to say it does forkIO app
19:49:30 <edwardk> if a only occurs in positive position you can work with it like a Functor, a function from (a -> b) could be used to replace all the 'a's with 'b's.
19:49:39 <thirsteh> appamatto: are you familiar with nginx? It's quite similar. The IO is transparently asynchronous, and the coroutines are multiplexed onto "worker OS threads" automatically
19:49:53 <edwardk> if a occurs only in negative position you can work with it like a Contravariant, a function from b -> a could replace all the 'a's with 'b's
19:50:18 <edwardk> if it occurs in both, you can only map it with isomorphisms or specific knowledge of the type and other invariants (like those that hold for difference lists.)
19:50:34 <thirsteh> appamatto: tl;dr; don't worry about it. Just run your binary with +RTS -N to make it leverage all your CPU cores
19:50:48 <appamatto> thirsteh, hmm, I was wondering how it compares with node.js
19:50:59 <thirsteh> appamatto: so long as you don't do anything that requires synchronization it'll scale "automatically"
19:51:07 <thirsteh> appamatto: there is no comparison
19:51:28 <edwardk> thoughtpolice: folks also distinguish between 'strictly positive' and 'positive', strictly positive means you didn't double negate. so you are on the right hand of all ->'s
19:52:03 <thirsteh> appamatto: node.js is one thread that does a lot of really small computations that are all blocking, but which are (usually) so small that you don't feel the blocking. Snap, for example, is e.g. 4 threads (for 4 cores) that each do the context switching automatically
19:52:05 <edwardk> the reason for distinguishing is that you positivity is an important property for proving termination in languages like coq or agda that care about totality
19:52:28 <edwardk> it avoids certain paradoxes that can lead to non-termination
19:52:32 <thirsteh> appamatto: that means you don't have to worry about blocking in your code. The scheduler will automatically switch back and forth between the lightweight threads
19:52:53 <jmcarthur> wait, why does that mean we like to distinguish between positive and strictly positive?
19:53:00 <appamatto> thirsteh: if that can be done automatically then I'm not sure why people are using node.js
19:53:08 <thirsteh> appamatto: me neither :)
19:53:34 <thirsteh> appamatto: well, I have an idea: It's JavaScript, and that's all a large group of frontend devs know, and now they have a way into the backend
19:53:49 <jmcarthur> is this positivity the same thing as or related to covariance?
19:53:52 <thirsteh> appamatto: if you're looking for performance, Haskell won't disappoint you. AFAIK all Haskell web frameworks outperform node.js and other async frameworks
19:54:13 <staticshock> is  map ($ 0) xs the same thing as map (\x -> x 0) xs?
19:54:25 <lightquake> staticshock: yes
19:54:36 <dolio> jmcarthur: Yes. Positive is covariant position and negative is contravariant.
19:54:40 <thoughtpolice> edwardk: ok, that makes sense equationally. :) when you say positive as in Functor, you mean in 'Functor a' the type variable is positive and we replace 'a's with 'b's. i'm not familiar with Contravariant - a would occur in negative position in its definition?
19:54:57 <thoughtpolice> well, that second sentence was a question, but i imagine you get what i mean
19:55:35 <dolio> jmcarthur: Also you distinguish between strictly positive and positive because the latter is odd to mathematicians.
19:55:58 <jmcarthur> dolio: huh. interesting...
19:56:02 <appamatto> thirsteh: thanks for the analysis :p
19:56:03 <dolio> Like, T ~ (T -> Bool) -> Bool.
19:56:04 <thirsteh> appamatto: the two really important differences are 1. cooperative (node.js, bad) vs. preemptive multitasking (haskell, good) and 2. that node.js isn't parallel whatsoever. If you want to leverage more than one processor, you need to spawn a separate process
19:56:16 <edwardk> @hackage contravariant
19:56:16 <lambdabot> http://hackage.haskell.org/package/contravariant
19:56:24 <monochrom> appamatto: you may like http://www.iij.ad.jp/en/company/development/tech/mighttpd/
19:56:32 <lightquake> 22:55:41              <dolio> Like, T ~ (T -> Bool) -> Bool.
19:56:35 <lightquake> what do you mean?
19:56:57 <dolio> T being isomorphic to its own double power set, effectively.
19:57:08 <monochrom> creepy, you're in the same timezone as mine
19:57:09 <lightquake> how does that make sense?
19:57:25 <rwbarton> oh, you mean this as a definition of T
19:57:29 <dolio> It makes sense when T -> Bool is not really a powerset.
19:57:47 <edwardk> lightquake: how often have you ever used "not (not a) entails a" in logic?
19:57:55 <lightquake> decently
19:57:56 <dolio> But if you want to say that types are sets, and functions are functions on sets, that's what it ends up being.
19:57:56 <edwardk> lightquake: that comes up a lot in classical logic =)
19:58:12 <monochrom> I use classical logic all the time
19:58:20 <copumpkin> I prefer baroque logic
19:58:26 <lightquake> but i thought not a was a -> Void, not a -> Bool
19:58:30 <edwardk> lightquake: you lose that when you move to constructive logic you lose that axiom
19:58:40 <dolio> Who said anything about not?
19:59:10 <dolio> data T = In ((T -> Bool) -> Bool) is a positive type.
19:59:24 <thirsteh> appamatto: I should say that I'm not a Haskell zealot. In fact I'm quite new to it. I would submit identical arguments for node.js vs. e.g. Go.
19:59:25 <jmcarthur> lightquake: a hand-wavy computational intuition that might make some sense is that  forall A. (T -> A) -> A  probably has to have a T in its closure in order to produce an A like it claims to be able to do (unless T is a terminal object or something i guess...)
19:59:26 <dolio> But it's not strictly positive.
19:59:37 <edwardk> yes
19:59:42 <appamatto> monochrom: nice link
19:59:45 <lightquake> @type ($ 3)
19:59:47 <lambdabot> forall a b. (Num a) => (a -> b) -> b
19:59:59 <lightquake> ah, now it makes sense
20:00:33 <staticshock> do i need to import something to use .: ?
20:01:38 <startling> staticshock, (.:) = (.).(.)
20:01:49 <startling> staticshock: dunno if it's defined in any common module
20:01:53 <thoughtpolice> edwardk: oh, i get it. it comes from the definition of contramap/fmap, 'a' is positive in fmap but negative in contramap
20:02:04 <thoughtpolice> i'd never seen contravariant before i suppose
20:02:10 <edwardk> thoughtpolice: yes
20:02:14 <staticshock> oh, ok
20:02:25 <appamatto> monochrom: is that bit about system calls still true (at the end of the mighttpd article?)
20:03:00 <jmcarthur> since picking up ocaml i've taken a liking to using variance annotations even when they aren't necessary for the documentation
20:03:01 <thirsteh> appamatto: that's true for any language
20:03:44 <thirsteh> appamatto: node.js blocks completely AFAIK
20:04:24 <copumpkin> mauke got maukd!
20:04:30 <Ralith> :O
20:04:33 <thirsteh> it's usually pretty easy to avoid making a lot of syscalls though
20:04:43 <Nafai> jmcarthur: what do you mean by variance annotations?
20:05:04 <jmcarthur> Nafai: type (-'a, +'b) t = 'a -> 'b
20:05:14 <jmcarthur> Nafai: the - and +, specifically
20:05:18 <appamatto> thirsteh: thanks, hitting the sack now
20:06:47 <jmcarthur> Nafai: here's a helpful lie.  '-' can be roughly interpreted as "expects/lacks" and '+' can be roughly interpreted as "provides/has"
20:06:59 <monochrom> appamatto: I don't know
20:08:01 <monochrom> I suppose yes
20:10:34 <thoughtpolice> edwardk: heh, and it's appropriate something like (T -> X) -> X was brought up, since that's basically codensity it seems. :)
20:11:02 <edwardk> thoughtpolice: yep
20:20:07 <copumpkin> Contdensity
20:26:30 <maukd> Condensity
20:26:35 <copumpkin> edwardk: nice wiki
20:26:45 <edwardk> which one?
20:26:55 <copumpkin> the lens stuff
20:27:00 <edwardk> ah, slowly fleshing it out
20:27:59 <prototrout> Never seen GHC give that message before... "Exciting arity" followed by 44000+ lines of some intermediate representation of a function.
20:28:18 <edwardk> i need a few more tables explaining the relationships between the different types, etc.
20:28:24 <copumpkin> prototrout: must have been awfully exciting
20:29:08 <prototrout> copumpkin: It's an arity to be sure.
20:30:13 <otters> 44,000 lines isn't nearly enough
20:31:23 <lightquake> exciting arity!
20:31:36 <prototrout> The total stderr line count is 375,770. Surely that's enough?
20:32:00 <monochrom> that is very strange
20:32:18 <copumpkin> prototrout: I'd join #ghc and paste all those lines into the channel
20:32:25 <monochrom> hahahahaha
20:32:25 <maukd> that's C++ level
20:33:06 * hackagebot xdot 0.2.1 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.1 (DennisFelsing)
20:33:12 <prototrout> copumpkin: I think I'd get banned halfway through.
20:33:17 <thoughtpolice> edwardk: so, also, is 'lens' now basically the ultimate edwardk lens library? you seem to have written a few of them :)
20:33:23 <copumpkin> I'd hope it'd be closer to 0.01% of the way :)
20:33:25 <prototrout> (45 megabytes!)
20:33:32 <edwardk> thoughtpolice: yes, lens pretty much subsumes them all
20:33:44 <thirsteh> prototrout has quit (Excess flood)
20:33:46 <thirsteh> :)
20:33:53 <startling> edwardk: were you saving that name for last or what?
20:34:18 <edwardk> startling: heh, well i was going to take lens-family, but roconnor beat me to it ;)
20:34:34 <thoughtpolice> edwardk: as i figured, i need to jump on the lens train someday soon too
20:34:41 <edwardk> it does have the benefit of being memorable ;)
20:34:47 <monochrom> yikes, "one lens to rule them all"?
20:35:00 <edwardk> monochrom: pretty much =)
20:35:04 <monochrom> maybe you should call it "ring"
20:35:07 <copumpkin> I shall use edwardk's lens in my monocle
20:35:10 * copumpkin adjusts his top hat
20:35:35 <startling> @hackage algebra
20:35:36 <lambdabot> http://hackage.haskell.org/package/algebra
20:35:40 <startling> monochrom: he already wrote that one ^
20:35:52 <monochrom> yikes
20:38:07 <Ralith> @hackage monocle
20:38:07 <lambdabot> http://hackage.haskell.org/package/monocle
20:38:12 <Ralith> aw
20:39:01 <startling> Ralith: @hackage is just a dumb prefixer
20:39:07 <startling> Ralith: doesn't mean the package exists
20:39:24 <startling> (it doesn't)
20:40:17 <Ralith> startling: yes, I picked up on that :P
20:40:24 <Ralith> it was a joke.
20:41:34 <thoughtpolice> copumpkin: do you have a watch on a chain, too?
20:41:52 <edwardk> oooh
20:41:58 <edwardk> i should rename Classy to Monocle
20:42:00 <edwardk> makeMonocle
20:42:11 <copumpkin> thoughtpolice: indeed I do, my good chap
20:42:18 <copumpkin> gold, of course
20:45:10 * ddarius used to have a pocket watch.
20:46:19 <startling> edwardk: do you have a mappend-on lens?
20:46:27 <edwardk> <>~
20:46:32 <startling> thanks
20:46:33 <edwardk> Data.Monoid.Lens
20:46:38 <startling> is that the fish?
20:46:46 <edwardk> =)
20:46:55 <edwardk> <<>~ looks more like a rat from overhead
20:46:58 <startling> oh ugh, I'm looking at old docs. stupid google
20:47:19 <edwardk> ekmett.github.com/lens/frames.html
20:47:45 <edwardk> will keep you up to date, since i try to keep the docs there current as i develop
20:48:34 <startling> edwardk: cool, thanks
20:48:36 <ddarius> @hackage package
20:48:36 <lambdabot> http://hackage.haskell.org/package/package
20:48:54 * ddarius awaits edwardk's foray into that region.
20:49:09 <edwardk> ddarius: =)
20:49:14 <liyang> @hackage schmackage
20:49:15 <lambdabot> http://hackage.haskell.org/package/schmackage
20:49:33 <startling> edwardk: can I mappend two structures given lenses into the structure and get another such structure?
20:49:43 <startling> these type signatures are pretty esoteric
20:50:10 <edwardk> startling: how would that work?
20:50:12 <startling> I want to do whatever first ("h", 2) ("i", 3) and get ("hi", 3")
20:50:23 <startling> er, not `first`. _2
20:50:26 <startling> err, _1
20:50:58 <edwardk> just use the lens to read the contents of one, then use %~ on the other
20:51:14 <startling> yeah, will do. thought that might exist though
20:51:28 <edwardk> _1 <>~ foo^._1 $ bar   -- is pretty specific =)
20:51:52 <edwardk> but also its simple enough not to cross the fairbairn threshold
20:52:42 <startling> edwardk, googled fairbairn threshold, found a mailing list post asking you what it means
20:52:52 <monochrom> haha
20:52:59 <edwardk> when in doubt assume that combinators for lenses will only work with one 'container', when wondering if i've implemented something like that ;)
20:53:01 <edwardk> hahaha
20:53:31 <startling> edwardk: you apparently haven't answered. :/
20:53:35 <edwardk> startling: i did
20:53:48 <startling> then I'm just bad at browsing this thing
20:54:17 <edwardk> startling: http://www.digipedia.pl/usenet/thread/14405/6430/
20:54:27 <edwardk> see my reply along with Nils'
20:54:29 <sordina> Hey Haskellers. Is there a specific versions of cabal I should use with ghc 7.6.1?
20:55:17 <startling> ah, thanks
20:55:30 <sordina> I'm trying to build from master on github and get some issues with "Module `Distribution.Simple.Setup' does not export `buildOptions'"
20:55:57 <sordina> I've tried to track down buildOptions, but can't find anything useful.
20:56:08 <td123> sordina: cabal-install doesn't build with ghc 7.6.1
20:56:34 <sordina> td123: Ah, are people just using a version compiled with a previous ghc or something?
20:56:50 <td123> sordina: ya, unfortunately
20:56:56 <Axman6> @oesis 2 12 185 8512
20:56:56 <lambdabot>  Sequence not found.
20:57:01 <Axman6> http://oeis.org/A007764 :(
20:57:15 <johnw`> sordina: but come to think of it, we use a previously built ghc to build ghc too, so there's precedent :)
20:57:21 <sordina> td123: Thanks! Is there anything I can do to help get it building with 7.6.1?
20:57:31 <sordina> johnw`: haha
20:57:38 <phaikawl>  /msg NickServ VERIFY REGISTER phaikawl jzaupyopwnjv
20:58:32 <startling> edwardk, can I flip a lens somehow?
20:58:46 <edwardk> startling: like 'from'?
20:59:09 <startling> edwardk, I want a <>~ that appends the second to the first
20:59:10 <edwardk> startling: that works with an Iso
20:59:15 <Axman6> phaikawl: you probably want to change that password now
20:59:37 <edwardk> startling: just use %~ mappend foo
20:59:46 <startling> yeah.
20:59:57 <ddarius> %~(<>)foo
20:59:59 <phaikawl> @Axman6: what? why?
21:00:00 <lambdabot> Unknown command, try @list
21:00:07 <johnw`> what is the typical module to use for getting the current time?
21:00:11 * ddarius awaits the recreation of J inside of Haskell.
21:00:18 <johnw`> I would expect a System.Time or something
21:00:22 <edwardk> ddarius: =)
21:00:22 <Axman6> phaikawl: oh, that's not your password?
21:00:25 <ddarius> johnw`: I usually look at my phone.
21:00:35 <Clint> @hoogle getCurrentTime
21:00:36 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
21:00:36 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
21:00:40 <phaikawl> @phaikawl test
21:00:41 <lambdabot> Unknown command, try @list
21:00:49 <edwardk> @hoogle time
21:00:49 <lambdabot> System.Timeout module System.Timeout
21:00:49 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
21:00:49 <lambdabot> System.Event type TimeoutCallback = IO ()
21:00:57 <edwardk> er
21:01:00 <johnw`> @index Date.Time
21:01:00 <lambdabot> bzzt
21:01:00 <edwardk> @hackage time
21:01:00 <lambdabot> http://hackage.haskell.org/package/time
21:01:09 <johnw`> ah, thank you
21:01:11 <johnw`> Date.Time
21:01:13 <edwardk> its Data.Time ;)
21:01:15 <phaikawl> how to mention another?
21:01:31 <ddarius> Axman6: Presumably you can ghost him and you'll know and maybe he'll pick up the hint.
21:01:54 <scri> phaikawl: twitter is that way -->
21:01:59 * Axman6 is too lazy
21:02:30 <phaikawl> -->scri: this way, right?
21:02:57 <monochrom> yes
21:03:04 <Axman6> phaikawl: do you have any questions about haskell?
21:03:07 * hackagebot git-all 1.3.0 - Determine which Git repositories need actions to be taken  http://hackage.haskell.org/package/git-all-1.3.0 (JohnWiegley)
21:04:48 <phaikawl> -->phaikawl
21:05:22 <phaikawl> -->Axman6: I'm just starting and, umm, no question yet
21:05:34 <scri> :t (-->)
21:05:35 <lambdabot> parse error (possibly incorrect indentation)
21:05:38 <Axman6> what are you doing >_<
21:05:48 <ddarius>  :t misparses --
21:05:53 <ddarius> > (-->)
21:05:54 <lambdabot>   Not in scope: `-->'
21:06:07 <Axman6> it should't, or it used not to anyway
21:06:09 <startling> Axman6, could be trolling
21:06:14 <Axman6> --! was a valid operator
21:06:17 <scri> shucks
21:06:23 <scri> @hoogle (-->)
21:06:23 <lambdabot> No results found
21:06:23 <ddarius> GHC doesn't, I'm pretty sure, just lambdabot's :t.
21:06:28 <ddarius> @type (-->)
21:06:29 <lambdabot> parse error (possibly incorrect indentation)
21:06:43 <scri> must be a twitter thing after all
21:07:36 <Clint> > reverse "vjnwpoypuazj"
21:07:37 <lambdabot>   "jzaupyopwnjv"
21:10:28 <ddarius> Waste Dearth
21:13:56 <startling> why can't I derive Monoid with data Foo a b = Foo a b ? :(
21:14:17 <dmwit> Because you can't derive Monoid at all.
21:15:01 <startling> dmwit, precisely!
21:15:19 <maukd> newtype Foo a b = Foo (a, b) deriving (Monoid)
21:15:30 <startling> maukd: heh
21:15:56 <scshunt> unless you have derivednewtypes on
21:16:03 <scshunt> or whatever that extension is called
21:16:15 <latro`a> GeneralizedNewtypeDeriving
21:16:21 <latro`a> but you don't have a constraint or anything
21:17:07 <dmwit> you get one for free
21:17:09 <maukd> I told u I was hardcore
21:17:34 <latro`a> uh
21:17:38 <latro`a> you shouldn't be able to get one for free
21:17:47 <latro`a> because mempty is a value, and (Void,Void) isn't inhabited
21:18:07 * hackagebot lens 2.9 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-2.9 (EdwardKmett)
21:18:11 <maukd> buy none, get one free
21:18:21 <maukd> void where prohitibed
21:18:35 <latro`a> lol
21:18:56 <latro`a> data Void where prohibited :: Void
21:19:26 <monochrom> hahaha
21:19:52 <dmwit> latro`a: mempty is a value, but Foo Void Void isn't an instance of Monoid
21:20:00 <latro`a> but he just had a b
21:20:03 <latro`a> completely arbitrary
21:20:04 <dmwit> Like I said: you get a constraint for free.
21:20:09 <latro`a> from the deriving?
21:20:16 <dmwit> instance (Monoid a, Monoid b) => Monoid (Foo a b)
21:20:17 <dmwit> yes
21:20:29 <latro`a> ....deriving can magically add instances on the input types
21:20:35 <dmwit> It's not magic.
21:20:37 <latro`a> I guess that makes sense, but is nonetheless TIL
21:20:43 <dmwit> It comes from instance (Monoid a, Monoid b) => Monoid (a, b)
21:20:48 <latro`a> I know
21:21:00 <edwardk> pwd
21:21:02 <edwardk> heh
21:21:03 <latro`a> oh oh
21:21:04 <dmwit> In reality, it's instance Monoid (a, b) => Monoid (Foo a b)
21:21:15 <dmwit> It's a really, really braindead mechanism.
21:21:26 <latro`a> that's kinda convoluted actually
21:21:27 <latro`a> >.>
21:21:32 <maukd> newtype Void where Prohitibed :: Void -> Void
21:21:53 <latro`a> ah sorry
21:21:56 <latro`a> needed Prohibited
21:21:57 <latro`a> up there
21:21:59 <latro`a> which would've been funnier
21:22:00 <latro`a> -_-
21:22:17 <maukd> I don't know if mine is valid syntax but it's a real Void type
21:22:32 <latro`a> data Void where Prohibited :: Void is valid I think
21:22:37 <latro`a> wait
21:22:38 <latro`a> no
21:22:39 <latro`a> nvm
21:22:40 <dmwit> It's not a very good Void type.
21:22:41 <latro`a> you're right
21:22:48 <dmwit> It has lots of non-bottom values.
21:23:03 <latro`a> was ultimately just a joke, though -_-
21:23:11 <Twisol> XD
21:23:23 <dmwit> How do you strict GADTs?
21:23:25 <Jafet> newtype Void = Void Void
21:23:31 <edwardk> newtype Void where Prohibited :: Void -> Void -- is perfectly legal syntax.
21:23:36 <Jafet> Bangpatterns?
21:23:40 <dmwit> edwardk: awesome
21:23:58 * maukd files a patent
21:24:01 <edwardk> it needs GADTs or i'd use it in Void ;)
21:24:09 <latro`a> lol
21:24:27 <dmwit> oh
21:24:30 <dmwit> oh my goodness
21:24:39 <dmwit> I completely misread maukd's post and now I feel like an idiot
21:24:45 <dmwit> maukd++ dmwit--
21:24:57 <maukd> I didn't even do anything!
21:25:10 <monochrom> what is the correct reading?
21:25:17 <Twisol> Did you just use mutable variables in #haskell? -_-
21:25:33 <dmwit> You switched data to newtype, which eliminated my complaint about having lots of non-bottom values, before I even made the complaint.
21:25:34 <latro`a> it's ok, it's in a lens
21:25:37 <dmwit> So yeah, you did something.
21:26:01 <Jafet> > let maukd = []; dmwit = [] in maukd++ dmwit--
21:26:02 <latro`a> (seriously guys, lens code starts looking even more like imperative than IO does, some of the time)
21:26:03 <lambdabot>   []
21:26:16 <edwardk> heh
21:26:33 <dmwit> ?karma test
21:26:33 <lambdabot> test has a karma of -1
21:26:39 <edwardk> depends on how you use it. if you switch to using more traverseOf and plated stuff it stays pretty nifty and functional ;)
21:26:44 <dmwit> > let test = [] in test++ []
21:26:46 <lambdabot>   []
21:26:48 <dmwit> ?karma test
21:26:48 <lambdabot> test has a karma of 0
21:27:00 <latro`a> sure @ edwardk
21:27:02 <ddarius> maukd: preflex?
21:27:03 <dmwit> test--
21:27:08 <latro`a> but like that Pong example looks quite imperativeish
21:27:14 <maukd> ddarius: still asleep
21:27:17 <latro`a> in parts
21:27:47 <edwardk> latro`a: that code was contributed by nand`. i'm not sure how much haskell code he'd actually written by that point.
21:27:48 <ddarius> maukd: Related to "maukd" v. "mauke"?
21:27:51 <maukd> dmwit: well, IIRC I invented 'newtype Void = V Void'. all I did here was convert it to GADT syntax
21:27:56 <maukd> ddarius: yes
21:28:24 <dmwit> maukd: ...which made it awesome and worth some totally worthless karma.
21:28:27 <edwardk> but yeah, the mutable +=, etc. operators definitely lend themselves to a very imperative coding style
21:28:28 <dmwit> Congratulations. Stop complaining.
21:32:01 <ddarius> How many characters does IRC (typically) allow per line?
21:32:25 <maukd> there's a hard limit of 512 bytes per message
21:32:31 <maukd> minus protocol overhead
21:32:54 <maukd> ~400
21:38:08 * hackagebot void 0.5.8 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.8 (EdwardKmett)
21:38:43 <edwardk> (noticed the way it detected if DeriveDataTypeable was present was slightly wrong)
21:38:54 <dmwit> Oh, not just a documentation update? =)
21:39:40 <johnw`> edwardk: what is a Semigroup?
21:39:56 <edwardk> a semigroup is a binary associative operation on a set.
21:40:04 <johnw`> binary?
21:40:11 <johnw`> oh, on a set
21:40:13 <edwardk> class Semigroup a where (<>) :: a -> a -> a
21:40:18 <johnw`> like monoid is on values?
21:40:20 <dmwit> It's a monoid that doesn't necessarily have a unit.
21:40:21 <edwardk> mappend without mempty
21:40:26 <johnw`> oh, I see
21:40:28 <johnw`> got it
21:40:33 <edwardk> consider min, or max
21:40:39 <ddarius> @official pooba on lesser known algebraic structures
21:40:40 <lambdabot> Unknown command, try @list
21:40:46 <edwardk> without a corresponding maximum element, min isn't a monoid
21:41:15 <ddarius> @official lambdabot
21:41:15 <lambdabot> Unknown command, try @list
21:43:14 <maukd> class Magma a where (<>) :: a -> a -> a
21:43:41 <ddarius> class Magmoid a b c where (<>) :: a -> b -> c
21:44:37 <dmwit> If there's no laws, why even bother?
21:45:13 <ddarius> CS people love lawless structures.
21:45:23 * ddarius <3 pointed free magmas.
21:45:26 <edwardk> class Magmoid k where (.) :: k b c -> k a b -> k a c
21:46:03 <edwardk> is probably more faithful to the notion
21:46:47 <Twisol> looks an awful lot like a category?
21:46:58 <edwardk> Twisol: sans id and the associativity law, it is ;)
21:46:59 <ddarius> Definitely not a category.
21:47:08 <Twisol> edwardk: Ahhhh, I see.
21:47:14 <djahandarie> class Magma a = > Semigroup a where assoc :: (x :: a) -> (y :: a) -> (z :: a) -> (x <> y) <> z == x <> (y <> z)
21:47:20 <djahandarie> Duh
21:47:51 <ddarius> Don't you need Eq a?
21:47:53 <maukd> syntax error near = >
21:48:04 <ddarius> And of course, Eq would need the superclass EquivalenceRelation.
21:48:08 * hackagebot ghc-vis 0.3.1.1 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.3.1.1 (DennisFelsing)
21:48:49 <djahandarie> maukd, oh right. If you fix that, it works. Trust me.
21:49:09 <djahandarie> trustMe
21:50:11 <ddarius> @hoogle trustMe
21:50:11 <lambdabot> No results found
21:50:27 <djahandarie> @aoogle trustMe
21:50:28 <lambdabot> Maybe you meant: google hoogle
21:58:07 <adnauseam> can't i map over a list such as 1:2:3:4:[] ?
21:58:30 <ddarius> Can't you?
21:58:34 <adnauseam> i'm getting the error No instance for (Num [a0]) arising from the literal `1'
21:58:40 <BMeph> adnauseam: Nope, you have to map under it... ;þ
21:58:49 <adnauseam> with map (+) 1:2:3:4:[]
21:58:50 <adnauseam> :[
21:58:57 <adnauseam> > map (+) 1:2:3:4:[]
21:58:59 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Num.Num [a -> a])
21:58:59 <lambdabot>    arising from a ...
21:59:02 <ddarius> adnauseam: What do you think that means?
21:59:02 <adnauseam> FU
21:59:09 <Twisol> Since I'm struggling a bit to do a project in Haskell, would it be a good idea to implement it in a language I'm more familiar with, using functional ideas/techniques, then port it later?
21:59:19 <adnauseam> well i would have liked an alternative :p
21:59:39 <ddarius> Twisol: If your goal is to implement it, sure.  If your goal is to learn Haskell, that doesn't seem very productive.
21:59:48 <adnauseam> i'd rather cons my input into a list and map over it before passing it to another function
21:59:51 <adnauseam> though, hmm
21:59:59 <Jafet> ((((((map (+)) 1):2):3):4):[])
22:00:24 * BMeph gives Jafet a thumbs-up...
22:00:25 <adnauseam> hmm, i assume that would work, but
22:00:32 <adnauseam> i suppose it's careful what youw ish for
22:00:39 <ddarius> Except (:) is still right associative.
22:01:20 <Twisol> adnauseam: use map (+) (1:2:3:4:[])
22:01:28 <Twisol> you're falling prey to precedence rules
22:01:41 <ddarius> Twisol: That still is very unlikely what adnauseam wants.
22:02:40 <adnauseam> i think
22:02:45 <adnauseam> given
22:03:14 <adnauseam> i'll paste the code, uno momento
22:03:27 <adnauseam> though i /think/ i got it now
22:03:35 <lcc> wait, so with ghc I can compile haskell into C?
22:03:44 <adnauseam> i'll just take a b and c and put them in []
22:03:45 <Twisol> ddarius: Well, I'm not sure how to proceed right now. I'm learning mostly through osmosis on this channel; I'm having a tough time actually writing what I want.
22:03:56 <ddarius> lcc: Not really, particularly with newer GHCs.
22:04:05 <BMeph> lcc: Yes. I think it's a bit round-about at this time, though.
22:04:07 <ddarius> Twisol: Why not read one of the several books available for free online?
22:04:34 <BMeph> ddarius: LLVM -> C? ;)
22:04:49 <ddarius> BMeph: That's not GHC compiling Haskell to C.
22:04:49 <lcc> so I could in theory, design an operating system kernel in haskell and convert it to C one day?
22:05:04 * adnauseam noticed that the paid for version of LYEAH is much better than the one available online
22:05:23 * ivanm wonders what the "E" in "LYEAH" stands for
22:05:32 <ivanm> Learn You Everything About Haskell? :p
22:05:39 <adnauseam> ivanm: a typo ;p
22:05:43 <BMeph> ddarius: I've never taken "with" to mean "exclusively"...unless it's about my wife, but that's another topic altogether.
22:06:00 <adnauseam> lol
22:06:10 <Jafet> lcc: why would you convert it to C?
22:06:21 <ddarius> BMeph: You can compile Haskell to C with GHC (by which I mean using JHC).
22:06:28 <lcc> would I not need to?
22:06:33 <ddarius> No.
22:06:49 <lcc> haskell will compile to a native architecture?
22:06:59 <ddarius> That's how it typically works.
22:07:03 <Jafet> Neither C nor Haskell is a language of any hardware architecture
22:07:07 <ddarius> What do you think is happening now?
22:07:10 <Jafet> So it makes no difference
22:07:16 <lcc> wow.
22:07:17 <BMeph> lcc: Not only will, but does, and has many times in the past! ;)
22:07:35 <ddarius> There were never Haskell interpreters without Haskell compilers.
22:08:06 <adnauseam> lcc: you're thinking about cpu architechture mnemonics perhaps
22:08:23 <Twisol> ddarius: I've read the entirety of LYAH, and I have Real World Haskell on my Kindle
22:08:31 <lcc> is it possible to write a uKernel/server based os with haskell? what would the benifits of doing so be, and what would the negative aspects be?
22:08:43 <lcc> I am interested in OS design, and minix in particular.
22:10:05 <Twisol> ddarius: I'm trying to write an implementation of Telnet that supports certain bothersome extensions. It's relatively easy in a side-effected language, but I'm constantly running up against a wall in Haskell.
22:11:08 <Jafet> There are many positive aspects. The main negative aspect is that no one has bothered to do it.
22:11:28 <ddarius> Microkernels are a waste of time anyway.
22:11:31 <Jafet> Conceptually, it is the same as implementing a kernel in C.
22:11:50 <lcc> ddarius: why so?
22:12:19 <lcc> not to start a uKernel vs monolithic kernel debate here, but I'm curious.
22:12:33 <lcc> I want to find a project to start working on. minix caught my eye.
22:12:48 <ddarius> lcc: False dichotomy, though a monolithic kernel is usually better, but there are other options as well.
22:13:15 <ddarius> Microkernels typically impose significant overheads without much actual benefit over monolithic kernels other than a more maintainable design.
22:14:56 <lcc> ddarius: well, minix seems to be fast.
22:15:19 <lcc> I just want to start kernel hacking in some way.
22:15:34 <lcc> maybe create my own toy OS that runs in a vm.
22:15:41 <ddarius> lcc: Then just start.
22:16:08 <lcc> ddarius: ok, but would you recommend that I not start with minix?
22:16:39 <ddarius> lcc: You can start with whatever you want.  If you are making toys, most practical concerns are irrelevant to you.
22:19:01 <frio> lcc: someone linked me to http://www.cl.cam.ac.uk/freshers/raspberrypi/tutorials/os/ the other day
22:19:18 <frio> might not be overly relevant if you're wanting to do it in haskell, but it seemed relatively straightforward and fun
22:20:44 <lcc> frio: thanks
22:20:58 <ddarius> frio: Not to be too harsh, but that series is ridiculous, at least for what it is claiming to be.
22:23:53 <frio> fair enough ddarius. like i said, it was linked to me so i havent really had a chance to look at it yet :)
22:24:17 <frio> im sure there's better (im currently on a binge of collecting material for things to do with my raspbis)
22:25:17 <johnw`> edwardk: if I'm making my records all lensy with _accessor and makeClassy, how do people pattern match on my record fields?
22:25:44 <edwardk> pattern match with the constructor typically
22:25:55 <johnw`> and not use the field names?
22:26:06 <edwardk> i usually don't find myself using foo { bar = 12 } in a pattern
22:26:18 <johnw`> so really the answer is: you don't
22:26:23 <edwardk> more or less
22:26:27 <johnw`> hmm
22:26:54 <edwardk> not much different to just get 'foo m = …. m^.someField'
22:27:04 <tam1138> hiya
22:27:17 <johnw`> but i can't Foo { field = Just x } =
22:27:19 <edwardk> or use foo m | b <- m^.bar, c <- m^.baz = ...
22:27:32 <johnw`> not so pretteh
22:27:35 <liyang> You can probably use ViewPatterns.
22:27:57 <edwardk> foo m@Foo{} | Just x <- m^.bar = …
22:28:10 * hackagebot heaps 0.2.2 - Asymptotically optimal Brodal/Okasaki heaps.  http://hackage.haskell.org/package/heaps-0.2.2 (EdwardKmett)
22:28:19 <tam1138> at some point, i became under the impression that i should be using Text instead of String, but working with Text seems to be a big of a pain in the ass.  a) should i indeed be preferring Text?  b) is there a guide beyond haddock for making effective use of it?
22:28:19 <liyang> foo ((^.bar) &&& (^.baz) -> (b, c)) = …
22:28:54 <tam1138> (yes, i'm fairly newbish)
22:29:32 <edwardk> tam1138: Text is occasionally useful for interop, and is faster if you are munging a ton of character data, but if you aren't under a lot of pressure to make things faster or take less memory, strings are a hell of a lot more convenient
22:29:48 <johnw`> edwardk: you realize that looks a ton worse, yeah?
22:29:59 <johnw`> like, wtf?
22:30:00 <edwardk> johnw`: sure.
22:30:04 <johnw`> kk
22:30:11 <edwardk> johnw`: i woudn't use it, but you explicitly _asked_ for how ;)
22:30:33 <edwardk> johnw`: in practice i contort my code so i never have to say anything that hideous ;)
22:30:40 <johnw`> ah
22:31:20 <tam1138> hmm.  thanks edwardk.
22:33:11 <tam1138> was i wrong in assuming that Text is the future and that playing around with, eg, BasicPrelude, would be a good way to prepare myself?
22:33:50 <johnw`> I need to pass a lazy bytestring to a C function expecting a Void * as the beginning of a memory buffer.  What's the most efficient way to pass my Text as a Ptr ()?
22:34:07 <startling> tam1138, OverloadedStrings may make Text easier to deal with
22:34:26 <tam1138> startling: i'm using that =)
22:34:31 <startling> ah okay
22:35:13 <tam1138> currently, the BasicPrelude lines is not playing nice with the BasicPrelude getContents, which seems rather... wrong to me
22:35:27 <startling> what is BasicPrelude?
22:35:47 <tam1138> http://hackage.haskell.org/package/basic-prelude-0.3.0.0
22:35:56 <startling> tam1138: and what do you mean "not playing nice with"? what are the type singatures and how are you trying to get them to play together?
22:36:39 <Twisol> How are you using getContents and lines?
22:36:57 <tam1138> input <- getContents ; let paths = lines input
22:36:59 <tam1138> nothing fancy
22:37:17 <startling> do you get an error?
22:37:20 <tam1138> apparently, lines expects a Text, but getContents produces a Data.Text.Lazy.Internal.Text
22:37:47 <Twisol> copy the full error to hpaste.org?
22:37:47 <Twisol> (with code preferrably)
22:37:54 <tam1138> sure, one sec
22:38:36 <ddarius> copumpkin: Want to go on a road trip to Rhode Island on Saturday or maybe Sunday, but probably Saturday?
22:39:55 <hpaste> tam1138 pasted “BasicPrelude, lines vs getContents: FIGHT!” at http://hpaste.org/74660
22:41:11 <Twisol> tam1138: yep, that does seem rather wrong. :/
22:41:23 <startling> tam1138, someone screwed up somewhere
22:41:25 <tam1138> heh
22:41:37 <johnw`> ah, Data.Text.Foreign
22:41:50 <startling> tam1138: try import Data.Text at the beginning there
22:42:01 <tam1138> is it possible that i screwed things up when i converted cabalized packages to arch PKGBUILDs?
22:42:21 <tam1138> same error with Data.Text
22:42:50 <startling> tam1138, possibly, but I don't think this badly
22:43:25 <ddarius> Importing another module isn't going to change the meanings of other functions.
22:43:29 <hpaste> pharaun pasted “Need help with strictness....” at http://hpaste.org/74661
22:43:46 <startling> tam1138: one is using Data.Text.Lazy.Text, the other is using Data.Text
22:43:47 <pharaun> hello, i've been struggling to figure out/apply seq/strictness to this function above
22:43:51 <pharaun> I could use some advice
22:44:08 <pharaun> i want to strictly evalulate MD4.update to force it to consume the whole ByteString
22:44:16 <tam1138> startling: yeah, and looking at BasicPrelude.hs, this is intentional
22:44:21 <startling> tam1138: ugh
22:44:27 <pharaun> I've played around with seq and a few other but i can't seem to make it work
22:44:31 <tam1138> it specifically re-exports Text.lines and LText.getContents
22:44:58 <startling> tam1138: I would stay away from this BasicPrelude thing
22:45:03 <tam1138> heh
22:45:04 <tam1138> fair enough
22:45:43 <johnw`> pharaun: a `seq` MD4.update (fst $ L.last xs) a, didn't work?
22:46:08 <tam1138> thanks all =)
22:46:14 <pharaun> nope, ram usage is ramping up to 13gb :)
22:46:34 <johnw`> oh, you need the return value from newHash to be strict
22:46:41 <ddarius> copumpkin: Answer, if you care, by text or something.
22:46:48 <johnw`> call newHash as: newHash $! a1 xs
22:46:56 <pharaun> hm k
22:47:09 <johnw`> but you have another problem
22:47:18 <johnw`> you have deep structures here
22:47:28 <pharaun> i'm not sure how else i'm supposed to do this
22:47:30 <johnw`> a list of pairs
22:47:34 <johnw`> do you know about deepseq?
22:47:45 <pharaun> won't that re-evalulate the list over and over
22:47:50 <johnw`> now
22:47:55 <pharaun> which is why i've been avoiding deepseq
22:48:04 <johnw`> the thing is, you need the return value from your inner updateHash function to be fully "collapsed"
22:48:23 <johnw`> but since it returns a nested structure, you need to use seq at every level
22:48:29 <pharaun> ugh
22:48:31 <johnw`> the alternative is to use deepseq
22:48:38 <johnw`> which recursively seq's all the elements within the structure
22:48:52 <pharaun> seems silly hard to get strict eval
22:49:04 <johnw`> then you can do this:
22:49:30 <pharaun> it seems like just getting the newHash to be strict
22:49:32 <pharaun> would solve it?
22:49:42 <johnw`> let x = updateHash xs; y = split xs a in x `deepseq` y `deepseq` uncurry x y
22:49:54 <johnw`> if you just use seq it won't work
22:49:57 <johnw`> because x and y have depth
22:50:14 <johnw`> (it won't work the way you want, that is)
22:50:32 <johnw`> i solved a very similar problem to this just 2 days ago
22:51:10 <pharaun> let me try that
22:52:16 <johnw`> something else to remember when use seq is that it only applies when the expression is evaluated
22:52:24 <johnw`> so you can very easily builds thunks containing seq :)
22:52:34 <pharaun> no way to just tell ghc to suush and just eval X
22:52:42 <johnw`> yes, it's called seq :)
22:52:47 <pharaun> ugh
22:53:18 <startling> pharaun, have you tried -XBangPatterns?
22:53:47 <pharaun> i'm starting to lean toward just doing that
22:53:55 <pharaun> johnw`: ok so i did let x and y
22:54:10 <pharaun> so how exactly do i then... replace the uncurry (updateHash xs) (split xs a) ?
22:54:55 <ivanm> johnw`: are you the same johnw from #org-mode?
22:55:08 <johnw`> yes
22:55:39 <johnw> pharaun: use the let form I typed above
22:55:44 <pharaun> startling: won't the problem then be that the damn md4 function never get consumed?
22:55:51 <ivanm> johnw: since I've spent the past few hours bashing my head about this and #org-mode seems dead: do you know anything about the new experimental export backend in 7.9.1?
22:55:59 <startling> pharaun, no idea, didn't look at your code
22:56:14 <johnw> no, I don't do any exporting from Org
22:56:19 <ivanm> oh
22:56:20 <ivanm> dammit
22:56:31 <johnw> pharaun: "consuming"?
22:56:34 <johnw> "consumed"?
22:56:41 <ivanm> I fiddled around with the new build system just so I could get the booktabs support in the new exporter... only to find it doesn't seem to work with orgtbl :s
22:57:08 <pharaun> i'm just rather frustrated about the whole thing
22:57:15 <pharaun> so i'm probably not getting something here
22:57:42 <ivanm> so I guess I just wasted most of today :s
22:58:02 <pharaun> it just seems to me that all i need to do is to make the md4 hasher consume all input then it'll be in NHF which i can then store in my tuple in the list
22:58:05 <johnw> pharaun: did you put in my let?
22:58:25 <ivanm> thanks anyway though johnw
22:58:29 <pharaun> johnw: i'm still not clear *where* like what does it replace? or do i just stick it in the base and that's it?
22:58:35 <johnw> pharaun: you need to make sure that subexpressions get evaluated
22:58:51 <johnw> but if you do it too deep, you'll just build a bunch of thunks containing calls to seq
22:59:03 <johnw> replace the top call
22:59:12 <johnw>  | len xs < blockSize    = uncurry (updateHash xs) (split xs a)
22:59:23 <johnw> replace the text after the = with what I typed
22:59:55 <johnw> that will cause your recursion to collapse the chunks as it processes
23:00:15 <johnw> otherwise, your function isn't doing any work at all
23:00:21 <pharaun> oh
23:00:25 <pharaun> trying
23:00:27 <johnw> it's just building a huge data structure with unevaluated calls to MD4.update
23:00:45 <pharaun> yeah i figured that just been stuck on getting the silly update to just consume
23:01:15 <pharaun> hmm
23:01:22 <johnw> seq didn't work for you because of the depth of the structures
23:01:22 <pharaun>     | len xs < blockSize    = let x = updateHash xs; y = split xs a in x `deepseq` y `deepseq` uncurry x y
23:01:38 <pharaun> its now tossing a type error at me
23:01:55 <johnw> you imported Control.DeepSeq?
23:02:04 <Twisol> Can someone recommend a good, high-quality library I can read the source of to learn more about solving a problem in Haskell?
23:02:05 <pharaun> yeah lemme pastie it, its NFDAta
23:02:12 <johnw> you'll need to make an NFData instance
23:02:31 <pharaun> hm k
23:02:42 <johnw> instance NFData Ctx where
23:02:43 <johnw>   rnf a = a `seq` ()
23:03:31 <pharaun> oh wow didn't have one for bytestring
23:03:42 <pharaun> defined one its running, hmm still exploding in memory usage to ~13gb
23:04:21 <johnw> repaste your code please
23:04:28 <johnw> with the changes
23:04:33 <pharaun> sure
23:05:39 <pordan30> is there a de facto standard prelude with well-organized type classes?
23:05:46 <hpaste> pharaun pasted “deepseq'd the function.” at http://hpaste.org/74662
23:06:32 <ivanm> pordan30: no
23:06:35 <johnw> this will be clearer btw:
23:06:37 <johnw> uncurry $!! (updateHash xs) (split xs a)
23:06:41 <johnw> it means the same thing
23:06:47 * ivanm hugs his Prelude from base
23:06:53 <johnw> so, we still aren't seq'ing high enough
23:06:56 <johnw> let me read
23:07:39 <pharaun> johnw: when i try the "uncurry $!! (updateHash xs) (split xs a)" i end up with another type error
23:07:53 <johnw> oh sorry
23:07:59 <johnw> uncurry (updateHash xs) $!! (split xs a)
23:08:02 <pharaun> doh
23:08:15 <johnw> but that still isn't right
23:08:23 <johnw> that deepseqs the argument, we need the return value
23:08:26 <pordan30> is there any reason to not use the numeric prelude, then?
23:08:28 <pharaun> yeah
23:08:38 <johnw> in all your calls to updateEd2k
23:08:42 <johnw> make them updateEd2k $!!
23:08:45 <pharaun> k
23:08:52 <johnw> then we *have* to be evaluated the substages
23:08:55 <johnw> ed/ing
23:09:54 <johnw> you've got some other problems with this function
23:09:56 <pharaun> done, still expanding nicely
23:10:00 <pharaun> *sigh*
23:10:00 <johnw> it's basically a foldl
23:10:08 <johnw> you need it to be a foldr
23:10:12 <pharaun> i'm not sure how else to express the function
23:10:18 <johnw> your appeands are killing you
23:10:20 <johnw> appends
23:10:32 <johnw> one sec and I'll rewrite it
23:10:39 <pharaun> i need to basically eval "up to 9.5mb of data" in each md4 hash, then repeat
23:11:10 <pharaun> and one of my issue was trying to get the function to be able to eval less or more than the block size so it would be robust to varying data chunks being tossed at it
23:11:15 <johnw> is the ByteString lazy?
23:11:25 <pharaun> import qualified Data.ByteString as B
23:11:38 <pharaun> so its strict
23:12:10 <pharaun> from my understanding of strictness so far, in general i want the strict bytestring if i have known data limitation, i am reading it in from disk in "chunks"
23:12:17 <pharaun> strictly
23:12:34 <johnw> that's how lazy bytestring works
23:12:42 <johnw> it's a series of strict chunks
23:12:56 <pharaun> well i was trying to avoid the whole lazy IO issue
23:13:08 <pharaun> with open/close and all of this because i'll eventually be doing hashes over multiple files
23:13:23 <johnw> what does (Ctx (xs ++ [(MD4.init, 0)])) mean?
23:13:41 <johnw> pharaun: you could use conduit
23:13:54 <johnw> it will manage the open/close stuff for you
23:13:59 <pharaun> johnw: i was, but i was geting abyssal performance, like 72 seconds to hash 200mb file
23:14:05 <johnw> ah
23:14:10 <pharaun> with this version i'm getting 27s for 11gb file
23:14:31 <johnw> what does (Ctx (xs ++ [(MD4.init, 0)])) mean?
23:14:36 <johnw> i can't figure that out
23:14:50 <pharaun> oh basically - data Ctx = Ctx ![(MD4.Ctx, Int)]
23:15:10 <pharaun> Ctx holds a list of tuples (md4 hash, length of data digested by that hash)
23:15:19 <johnw> oh, I see
23:15:24 <johnw> so maybe the appends aren't so bad then
23:15:38 <pharaun> i did this so that i can digest any amount of data up to the block size (9500*1024 bytes)
23:15:53 <pharaun> then when i hit that, i generate a new md4 hash for the next block
23:16:13 <pharaun> yeah the lists is alright, i'm thinking of looking at the vector data so i can get o(1) for access to the last element in the list
23:16:36 <johnw> so, does "split xs a" happen recursively?
23:16:43 <pharaun> or something because all i really ever do is grab the last element and update/replace it or append a new one
23:16:46 <johnw> i'm really having a hard time reading this
23:17:07 <johnw> so, you want to MD4 blocks of text, right?
23:17:10 <pharaun> oh split xs basically split a incoming strict binary string
23:17:20 <johnw> and then use that MD4 to seed the MD4 of the next block?
23:17:34 <pharaun> in a chunk of 0-(9500*1024) length and (rest)
23:17:50 <pharaun> then i re-call update ed2k with the rest and repeat till i have consumed the whole thing
23:17:58 <johnw> what is the type of MD4.update?
23:18:33 <pharaun> yeah basically i want to do md4 chunk of each ~9.27MiB block of data, and for each 9.27MiB it gets its own md4 block
23:18:38 <pharaun> a sec
23:19:03 <pharaun> curious why this code is hard to read, is it my style or just?
23:19:12 <johnw> i maybe just don't understand problem
23:19:17 <pharaun> lemme paste a summary
23:19:47 <johnw> what about: B.map (\x -> (MD4.update ? x, length x)) (B.splitAt blockSize)
23:19:56 <hpaste> pharaun pasted “whole file - plus summary” at http://hpaste.org/74663
23:20:08 <pharaun> i have comments above the function explaining what its doing
23:20:16 <pharaun> see steps - 1, 2, 3
23:20:39 <johnw> yeah
23:20:52 <pharaun> johnw: how would that then address the issue of the update function needing to be able to be updated with "any" sized chunk of data
23:20:58 <pharaun> i modeled this after the Crypto-api
23:20:59 <johnw> oh, I get it
23:21:10 <simon> @pl \x y -> (x, f y)
23:21:10 <lambdabot> (. f) . (,)
23:21:37 <pharaun> http://hackage.haskell.org/packages/archive/cryptohash/0.7.5/doc/html/Crypto-Hash-MD4.html
23:21:39 <johnw> what is the list held by Ctx?
23:21:41 <pharaun> johnw: ^ this is the Md4
23:21:57 <pharaun> data Ctx = Ctx ![(MD4.Ctx, Int)]
23:22:22 <johnw> so, there's a pair for every chunk?
23:22:34 <pharaun> this^ ? basically it holds a list of (md4 hash, length), where length is how much data that the md4 hash has consumed till it hit 9.27MiB
23:22:37 <pharaun> yes
23:22:46 <johnw> I don't understand why the "len xs < blockSize"
23:22:51 <johnw> xs isn't your input bytestring
23:22:59 <johnw> but blockSize relates to the chunk size?
23:23:18 <pharaun> yeah block size is the "max" size of a chunk
23:23:30 <johnw> BUt xs should just be a list of hash-created-so-far
23:23:36 <johnw> so it's going to be very small
23:24:24 <pharaun> i could have thousands (1,215 for a 11gb file) but in grand scheme of things yes it would be very small
23:24:35 <johnw> certainly always < 9500 * 1024
23:24:42 <johnw> so I don't see how the "otherwise" every runs
23:24:46 <johnw> ever
23:24:59 <pharaun> hold on let me think
23:25:26 <pharaun> this code as it is works i have a test suite that i use and it passes @_@
23:25:31 <johnw> lol
23:25:38 <pharaun> based off the reference impl of ed2k
23:25:59 <johnw> len xs = number of hashes computed so far
23:26:02 <pharaun> oh i think the len xs was probably supposed to be len a
23:26:05 <johnw> ah
23:26:15 <pharaun> wait
23:26:16 <pharaun> oh
23:26:17 <pharaun> ohh
23:26:20 <johnw> and (split xs a) is a problem too
23:26:36 <pharaun> basically - len xs - it extracts the last element out of the list of hash + consumed int
23:26:47 <pharaun> remember the Ctx is [(hash, length)]
23:27:08 <johnw> if Ctx [(,)], then len xs is always small
23:27:17 <johnw> i think you want len a
23:27:23 <pharaun> len xs, gets the last (hash, length) out of the list, and return that length, if that length is less than (9500*1024) that means the md4 hash in that is not yet filled to capacity, so it needs to be filled up
23:27:42 <pharaun> i cannot start a new md4 till the previous md4 has been filled up with exactly 9.27MiB of data
23:28:00 <johnw> um, I can't see how len xs is anything other than the length of the list held by Ctx
23:28:09 <johnw> it doesn't "extract" the length from the last pair in the list
23:28:12 <pharaun> len xs = snd $ L.last xs
23:28:17 <pharaun> defined in where
23:28:24 <johnw> oh
23:28:29 <johnw> damn, I got fooled by Python's len
23:28:37 <pharaun> haha yes me too for a few minute
23:28:39 <pharaun> was all confused
23:28:42 <johnw> i'd call it lengthFrom
23:28:43 <pharaun> haskell's is Length
23:28:46 <pharaun> k
23:28:48 <pharaun> renaming
23:29:08 <johnw> ok, so that really changes thing
23:29:09 <johnw> s
23:29:12 <johnw> reading again
23:29:20 <pharaun> sorry, still learning things, i was trying to follow the style i guess
23:29:29 <pharaun> lots of code i see tends to favor short func/args
23:29:46 <johnw> yeah
23:29:51 <johnw> lenFrom then :)
23:30:19 <pharaun> lengthFrom is fine for now :) beside lenFrom makes me think of lens now heh
23:30:24 <pharaun> >_> at a certain someone
23:30:46 <johnw> oh, and you have  Ctx (L.init xs ++ [(newHash a1 xs, newLength a1 xs)]) twice
23:30:51 <johnw> you can factor that
23:31:01 <pharaun> yeah i should
23:31:06 <pharaun> factoring it out
23:31:25 <coldpizza72i> Is there a way to see if a number n is prime by using a fold function involving &&n `mod` != 0 on the list [2,..,sort(n)] ?
23:32:05 <johnw> how much memory did you say this is using?
23:32:13 <pharaun> ~13gb for a 11gb file
23:32:16 <pharaun> not sustainable :)
23:32:32 <johnw> but it's a strict bytestring
23:32:38 <coldpizza72i> so like n mod 2 !=0 && n mod 3 != 0 && … && n mod sqrt(n) != 0… can you do this using folds?
23:32:38 <johnw> so 11gb is your minimum, isn't it?
23:32:46 <pharaun> nah
23:33:02 <johnw> oh
23:33:07 <hpaste> pharaun pasted “reading in the chunks” at http://hpaste.org/74664
23:33:08 <pordan30> you can check for factors using mod on the list of naturals up to the predecessor of the absolute value of the test number
23:33:10 <johnw> you only ever pass 10 mb chunks to updateEd2k
23:33:15 <pharaun> yeah for now
23:33:26 <pharaun> i'm hoping to migrate back to conduit once i have figured out what the problem is with conduit
23:33:45 <coldpizza72i> pordan30: that doesn't use folds does it?
23:33:45 <pharaun> so i tried to model my foreach function after the idea of conduit passing "x" chunks of data to the sink
23:34:07 <pordan30> yeah, fold with conjunction testing each number in the list
23:34:23 <pharaun> johnw: as you can see if i print or eval it there it stays at low memory usage so it indicates a space leak then i profiled it and it pointed to my updatehash/etc in the ed2k module
23:34:30 <coldpizza72i> pordan30: what would that look like
23:34:36 <johnw> can I see the code that calls this code, in full?
23:34:42 <pharaun> sure, a second
23:35:11 <MostAwesomeDude> @djinn (a -> f a) -> (f a -> g a) -> (a, b) -> (g a, b)
23:35:12 <lambdabot> f a b (c, d) = (b (a c), d)
23:35:57 <pordan30> you want a function of the form foldr (\x xs -> P x && xs) True or foldr (\x xs -> P x || xs) False, where P is the appropriate test
23:36:51 <hpaste> pharaun pasted “calling code” at http://hpaste.org/74665
23:37:24 <pharaun> johnw: i can probably make the calling code strict but that's kind of sidestepping making the ed2k hasher strict as it should be *imho*
23:37:45 <pharaun> and this is purely test code just to test the ed2k stuff
23:37:45 <johnw> ok, this needs to be strict too
23:38:01 <johnw> foreach $!! ...
23:38:09 <pharaun> how so? i'm hoping to put it back into a conduit/itertree
23:38:12 <pharaun> k
23:38:16 <johnw> or maybe not
23:38:25 <johnw> but it can't hurt
23:38:31 <johnw> if you get a type error, don't bother
23:38:37 <Nereid> aaaaa.
23:38:49 <Nereid> I'm trying to wrap my head around the Constraint kind.
23:39:21 <johnw> since this is IO, this shouldn't be too "deeP"
23:39:42 <johnw> but putting the $!! there should at least get your memory use < 20 mb
23:39:45 <pharaun> johnw: yeah got type error, cos of no NFData Ctx, defined one
23:39:51 <pharaun> running now
23:40:29 <pharaun> hmm i put $!! on both of my foreach, its still expanding to 13gb :)
23:40:31 <coldpizza72i> could it be on one line like … foldr (\x xs -> \y -> n `mod` x == 0 && xs) ?
23:40:35 <johnw> huh
23:40:49 <pharaun> johnw: no worries the computer has 24gb of ram so 13 isn't hurting me but it *should* get fixed
23:41:11 <pharaun> if i uncomment - evaluate (finalizeEd2k ctx)
23:41:20 <pharaun> which forces the whole thing to evalulate, it stays at ~
23:41:35 <mysticc> If I state function dependency say class Foo a c| a -> c in a class definition .. Does it means given type of a type of c is uniquely determined .. ?
23:41:49 <lightquake> yep
23:42:00 <lightquake> it means that you can't write instance Foo Int Bool and instance Foo Int ()
23:42:18 <pharaun> johnw: ~165-231mb and performs about the same as the ballooning one
23:42:27 <johnw> i want to understand this
23:42:33 <johnw> can I run your code here?
23:42:54 <pharaun> let me check what i all need, hmm yeah you just need the ed2k module, and then that driving IO loop i gave you
23:43:02 <coldpizza72i> pordan30: you still there?
23:43:15 <pharaun> you would need - crypto.hash.md4
23:43:26 <mysticc> Will it also ensure when a belongs to say Real a and I have a instance for instance (Real a , integral d) => Foo a d .. then I can determine Integral d from this ?
23:43:30 <johnw> is it under version control anywhere?
23:43:33 <pharaun> johnw: but yeah go for it
23:43:35 <johnw> or should I just copy the files down?
23:43:40 <pordan30> yeah
23:43:43 <pharaun> johnw: locally i have not put it up on github yet :)
23:43:51 <johnw> can you e-mail me a tarball?
23:43:54 <pharaun> the parent project isn't done just yet, and i wanted to finish it before i pushed it out to github
23:43:59 <johnw> /msg pharaun johnw@newartisans.com
23:43:59 <johnw>  
23:44:01 <lightquake> mysticc: not sure
23:44:02 <pharaun> johnw: just the relevant files? k sure
23:44:05 <johnw> yeah
23:44:11 <johnw> i want to run this under the heap profiler here
23:44:36 <pharaun> sure, i've done the same here i'm still not experienced enough to quite 100% understand it but it seems to all point to the ed2k stuff
23:44:56 <johnw> i also want to see how changing the code changes the numbers
23:44:59 <johnw> i've got 24g RAM too
23:45:03 <pharaun> haha
23:45:05 <pharaun> alright
23:45:16 <pharaun> i hope you don't want me to send you a 11gb file also ;)
23:45:19 <johnw> no
23:45:21 <johnw> i have one
23:45:25 <coldpizza72i> how can i determine if every element in a list e is not a divisor of some constant?
23:45:28 <johnw> after we fix this, we'll parallelize your hashing function too
23:45:33 <pharaun> sweet!
23:45:34 <johnw> that should really help your performance
23:45:38 <pharaun> i was going to try that next too
23:45:42 <opqdonut> coldpizza72i: the constant is not fixed?
23:45:51 <johnw> i'm on a parallelization/concurrency kick lately :)
23:45:54 <coldpizza72i> its fixed
23:45:56 <johnw> been retrofitting all my code
23:46:19 <pharaun> johnw: i love me some parallelization, i've done bunch of OpenMP + low level SIMD, just haven't gotten to the point yet where i am comfortable doing it in haskell
23:46:21 <coldpizza72i> opqdonut: ^
23:46:22 <opqdonut> > all (\x -> mod x 12 == 0) [1,2,3,4] -- coldpizza72i
23:46:23 <lambdabot>   False
23:46:29 <opqdonut> > all (\x -> mod x 12 == 0) [1,2,3,4,5] -- coldpizza72i
23:46:31 <lambdabot>   False
23:46:40 <opqdonut> gah, sorry
23:46:41 <johnw> it is so easy in Haskell
23:46:46 <johnw> that's why I have fun doing it
23:46:49 <coldpizza72i> hmm
23:46:50 <opqdonut> > all (\x -> mod 12 x == 0) [1,2,3,4,5] -- coldpizza72i
23:46:52 <lambdabot>   False
23:46:54 <opqdonut> > all (\x -> mod 12 x == 0) [1,2,3,4] -- coldpizza72i
23:46:55 <lambdabot>   True
23:46:57 <opqdonut> there
23:47:27 <opqdonut> I often define a function "divides k n = mod n k == 0"
23:47:38 <coldpizza72i> opqdonut: would it be very similar with folds instead of all?
23:47:44 <mikeplus64> coldpizza72i: yes
23:47:49 <mikeplus64> @src all
23:47:50 <lambdabot> all p =  and . map p
23:47:56 <mikeplus64> @src and
23:47:57 <lambdabot> and   =  foldr (&&) True
23:48:04 <pordan30> all is a fold, coldpizza
23:48:06 <coldpizza72i> what does that mean
23:48:11 <pordan30> or all is defined in terms of a fold
23:48:24 <coldpizza72i> pordan30: how so?
23:48:58 <mikeplus64> coldpizza72i: all f xs = foldr (&&) True (map f xs)
23:49:19 <coldpizza72i> cool
23:49:22 <mikeplus64> > foldr (&&) True [True, True, False]
23:49:23 <lambdabot>   False
23:49:26 <mikeplus64> > foldr (&&) True [True, True]
23:49:27 <lambdabot>   True
23:50:01 <pharaun> johnw: sending
23:50:05 <mysticc> How to restrict instances of a class ... as in say Class Foo a b .. using FD a -> b ,, I can restrict no two instances like Foo Int Int , Foo Int Float exist .. But I want to restrict instances like instance (Integral a) => Foo a Int .. Now no more instances with integral in first argument can be defined ..
23:50:15 <coldpizza72i> Im so excited to learn haskell this semester.. Its mad hipster
23:52:32 <startling> how evil is empty = Result { errors=(repeat undefined), result=mempty } where (<|>) finds the one with the shortest `errors`?
23:54:21 <johnw> got it!
23:54:58 <startling> also, wtf, is nickserve down?
23:55:21 <pordan30> a right fold over a list [x1,...,xn] looks like f x1 ( ... (f xn v) ... ) for some f and v. you want to test each element of the list, then if it divides a number n, know that n isn't prime. so your f should say: if x divides n or something in the rest of the list divides n, then n isn't prime. so an appropriate f might be: f x xs = x ∣ n \/ xs.
23:55:31 <coldpizza72i>  Im getting parse error on \ "foldr (&&) True (map (\x -> mod 16 x == 0))[1,2,3,4]"
23:55:43 <pharaun> johnw: sweet
23:56:01 <johnw> just ghc --make simple.hs?
23:56:10 <pharaun> pretty much
23:56:26 <pharaun> you'll need to update the let file = "x" in the sample.hs
23:56:33 <johnw> k
23:56:39 <pharaun> to point to your file (i know i should have a arg, but never got around to it)
23:56:57 <pharaun> but yeah other than that i tested it and it should work out of the box, it does need crypto.hash.md4
23:57:08 <coldpizza72i> do you guys know why I'm getting the parse error
23:57:35 <johnw> running
23:57:59 <pharaun> coldpizza72i: do you mean - type error ?
23:58:06 <johnw> heh, my test file happens to be 11g too
23:58:16 <pharaun> i put that expression in ghci and i get a type error
23:58:21 <pharaun> johnw: heh :D
23:58:36 <coldpizza72i> pharaun: i had bad parens.. fixed it
23:58:47 <pharaun> coldpizza72i: oh ok :)
23:59:21 <pharaun> johnw: btw thanks a bunch for being so helpful so far :)
