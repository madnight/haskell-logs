00:00:29 <johnw> ddarius: what is the dark secret?
00:02:43 <maukd> do you have stairs in your house?
00:04:37 <hpaste> osa1 pasted “llvm compile error” at http://hpaste.org/75339
00:05:06 <osa1> Ralith: I'm getting this error while compiling your LLVM package, do you know why? http://hpaste.org/75339
00:06:28 <johnw> what version of LLVM do you have?
00:06:48 <osa1> johnw: 3.0
00:06:59 <johnw> that may be a bit old, I'm not sure
00:07:15 <osa1> yea, most recent is 3.1
00:07:25 <johnw> and has been for a while
00:08:24 <osa1> ok, it's compiling now.
00:08:37 <osa1> I had already have a llvm package installed, I had to remove it
00:08:50 <osa1> ops, nope. got the same error after a while
00:09:37 <Ralith> osa1: that error is the result of installing my llvm-wrapper package on top of the vanilla llvm-base package.
00:09:55 <Ralith> osa1: unregister llvm-base and install the version from my fork.
00:10:34 <Ralith> osa1: no, wait, that's the result of installing my just straight 'llvm' package on top of the vanilla llvm-base package.
00:10:53 <Ralith> osa1: you probably don't want the actual 'llvm' package at all, it's for DSLs more than compiler backends.
00:11:13 <osa1> Ralith: which package should I install ?
00:11:39 <Ralith> remove all llvm* stuff you have from hackage
00:11:46 <Ralith> install llvm-base and llvm-wrapper from my fork
00:11:53 <Ralith> use LLVM.Wrapper.* modules
00:12:13 <osa1> Ralith: you don't have llvm-base fork ?
00:13:02 <Ralith> osa1: install {llvm-base and llvm-wrapper} from my fork
00:13:30 <Ralith> osa1: they're in the base/ and wrapper/ subdirs, while the DSL bindings that you probably don't want are in the root dir.
00:14:35 <osa1> Ralith: http://hpaste.org/75340
00:15:18 <Ralith> osa1: as described in the documentation, you need to run 'autoreconf' before building llvm-base.
00:17:58 <osa1> I think this one is a version mismatch: http://hpaste.org/75341
00:19:27 <Ralith> osa1: ah, yes, that changed in LLVM 3.1
00:19:32 <Ralith> osa1: lemme ifdef that, hold on...
00:21:36 <Ralith> osa1: okay, pull and it should Just Work.
00:21:51 <osa1> thanks very much
00:22:10 <Ralith> np, should've conditionalized that from the start.
00:22:18 <Ralith> thanks for highlighting it
00:23:05 <osa1> nice, that worked. now moving to llvm-wrapper package
00:51:47 <zomg> Anyone around? Can you see if this segfaults for you: http://jjh.fi/~jani/pemtest.txt (cert file: http://jjh.fi/~jani/7d0b38bd.0 )
00:53:01 <maukd> what package is `Data.Certificate.X509 in?
00:55:47 <zomg> maukd: certificate
00:58:46 <freels> So, say I want to redefine Prelude implicitly in my project...
00:59:03 <freels> are there any consequences to doing this: https://gist.github.com/3786684 ?
00:59:46 <ivanm> freels: use the NoImplicitPrelude pragma
00:59:56 <ivanm> and call your prelude something else
01:00:04 <freels> I am aware that it exists, but then I have to import it in all my source files.
01:00:40 <ivanm> yes, but then it's more obvious you're using a non-custom prelude in case anyone wants to hack on your code
01:00:43 <ivanm> explicit > implicit
01:01:17 <freels> sure, that's an option, but I'm more interested if there are any unintended consequences with the approach in my gist.
01:01:39 <ivanm> PackageImports is flaky last I heard
01:01:46 <ivanm> and highly non-recommende
01:01:50 <ivanm> *non-recommended
01:02:02 <freels> well, ignore that. pretend I imported BasicPrelude instead
01:02:19 <ivanm> using a custom Prelude is fine
01:02:24 <ivanm> there are a few of them on Hackage already
01:02:31 <ivanm> AwesomePrelude, ClassyPrelude, YAP, etc.
01:10:44 <topriddy> hiya good people. browsing the internet today and found a blog where the author expresses fear of how pure functional lang including haskell handle states
01:11:26 <m3ga> topriddy: only one blog expressing that fear?
01:11:40 <topriddy> i was wondering if the points he raised here: http://kawagner.blogspot.com/2006/12/my-haskell-experience.html are still relevant, and if one should NOT need state, or haskell can be made to handle it cleanly
01:12:32 <topriddy> m3ga: not one. i havent gotten to Monads yet in haskell, but there's no harm having some foresight or reading about how state can be done without harm or its alternative
01:15:13 <topriddy> meanwhile , is this line correct: giveElements :: (a -> Bool) -> [[a]] -> [[a]]
01:15:47 <topriddy> i am more familiar with ths: giveElements :: (Bool -> a) => [[a]] -> [[a]]
01:16:01 <topriddy> where Bool is called typeclass
01:16:36 <johnw> I don't use State as often as I thought I would
01:16:58 <johnw> most of the places where I'd reach for state, all I really need is a fold
01:17:06 <fmap> > In Ocaml you can simply declare global, mutable variables and so the problem is a non issue.
01:17:07 <lambdabot>   <no location info>: parse error on input `,'
01:17:12 <fmap> I like that line
01:17:25 <zomg> I'm not sure if that guy who wrote it is a very experienced haskell programmer
01:17:29 <johnw> yeah, *that* problem becomes a non-issue :)
01:17:39 <johnw> a non-issue chock full o' issues
01:17:42 <topriddy> global vars are problems, agreed
01:17:44 <zomg> I'm not really that great myself, but I can sort of see issues in how he approaches the problems he is having
01:17:57 <zomg> Also, if you want to output debug messages, you can just use Debug.Trace.trace from even pure code
01:18:00 <topriddy> johnw: objects would always have state. say student with attributes name, age, sex, etc
01:18:32 * topriddy hasnt read haskell up to the fold level yet X_x
01:18:42 <johnw> you're talking about mutable state, I presume
01:18:46 <johnw> not state as in, just values
01:19:19 <topriddy> johnw: well from oop world. its mutable alright. a class Student has properties. comes up a lot
01:19:31 <topriddy> anyone know if the code line i pasted is just another style? see below:
01:19:36 <johnw> also, it's not uncommon for the "spine" of my program to be in some monad (IO or a transformer), in which I can put the state that needs to "reach out" to my child, pure functions
01:19:48 <topriddy> meanwhile , is this line correct: giveElements :: (a -> Bool) -> [[a]] -> [[a]]
01:19:53 <topriddy> meanwhile , is this line correct: giveElements :: (a -> Bool) -> [[a]] -> [[a]]
01:19:58 <topriddy> are they same please?
01:20:00 <zomg> if you have data Student = Student String Int, you usually just generate a new Student value based on the old one if you change it =)
01:20:19 <mysticc> Suppose I have a typeclass and instance for say Int, Integer, Double etc .. f is a function of this typeclass .. Now when I apply f on say 1 then I will need to provide explicit type to 1 .. How can I make sure if no type is provided then default it to say Integer ..
01:20:29 <zomg> topriddy: yes, (a -> Bool) vs (Bool -> a) just means the parameters are the other way around
01:20:55 <zomg> eg. if it was (a -> Bool), the first param would be a function which takes some type and returns a bool
01:21:09 <zomg> if it was (Bool -> a), it would take a func which takes a Bool and returns some type
01:21:56 <topriddy> infact scratch that, this is what i understand giveElements :: (Bool a) => [[a]] -> [[a]]
01:22:03 <topriddy> typeclass constraint
01:22:39 <zomg> Okay so? =)
01:22:50 * hackagebot ghc-events 0.4.0.1 - Library and tool for parsing .eventlog files from GHC  http://hackage.haskell.org/package/ghc-events-0.4.0.1 (SimonMarlow)
01:26:39 <topriddy> zomg: are they equivalent?
01:27:12 <myme> topriddy: Bool is a type, not a typeclass, so you cannot make a constraint on (Bool a). That would be invalid afaik.
01:27:12 <zomg> No
01:27:39 <zomg> and yeah like myme said, it's not a typeclass so it wouldn't work
01:27:42 <myme> topriddy: What you're then "trying" to say there, is: giveElements :: [[Bool]] -> [[Bool]]
01:27:47 <myme> Basically.
01:29:21 <topriddy> okay. so they just represented Bool as a then
01:29:50 <topriddy> giveElements :: (a -> Bool) -> [[a]] -> [[a]]
01:30:45 <zomg> Yeah when the parameter is enclosed in brackets like that it just means the parameter is supposed to be a function with that signature
01:31:54 <myme> topriddy: It's just to differentiate between a function which takes three arguments, vs. a function which takes two arguments whose first argument is a function.
01:32:50 * hackagebot monad-ox 0.1.1 - Monad for observation extraction  http://hackage.haskell.org/package/monad-ox-0.1.1 (JakubWaszczuk)
01:34:04 <Lutin`> Uh
01:34:44 <Lutin`> giveElements :: [[Bool]] -> [[Bool]] is not the same as giveElements :: (a -> Bool) -> [[a]] -> [[a]]
01:35:01 <myme> Lutin`: Nope, that was not what I was trying to say.
01:35:21 <Lutin`> Oh nevermind I see what you mean
01:35:22 <myme> Regarding if Bool was in fact a typeclass and all.
01:35:25 <Lutin`> Yeah
01:35:27 <myme> Not important.
01:36:22 <bjornars> move 0
01:36:36 <myme> lol
01:36:39 <Lutin`> Where do I move it
01:36:41 <bjornars> nevermind that
01:36:49 <myme> bjornars: /clear
01:36:52 <myme> That might work :p
01:37:06 <myme> "If *I* can'
01:37:08 <myme> Gah!
01:37:38 * frerich wasn't aware of '/join 0'
01:37:55 <myme> bjornars and I are in fact in the same office. And we just got ourselves some new keyboards.
01:38:04 <myme> And we're both n00bing. So sorry for that.
01:40:15 <ClaudiusMaximus> http://archive.org/details/ClaudiusMaximus_-_Glitchy_Video_Feedback_4585 some glitchy video feedback (using a haskell program in the loop to flip and overlay rgb histogram - http://hpaste.org/75110#a75111 )  first 1m10s are especially glitchy due to broken camera, then it clears up; usual strobe warnings apply...
01:46:54 <zomg> maukd: did you have time to try the application?
01:49:08 <zomg> Anyone on Ubuntu 12.04 around?
01:49:31 <lightquake> ClaudiusMaximus: ha, that's neat
01:57:00 <ClaudiusMaximus> lightquake: ty
02:07:51 * hackagebot hxt 9.3.0.1 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.0.1 (UweSchmidt)
02:16:48 <logicalguy> hello, can anybody help me?  I've got a gentoo system and I'm trying an emerge world update and it won't update darcs.  the problem is with mtl package.  darcs wants version 2.1.1, but haskeline and regex-base want version 1.1.1.1
02:18:49 <Saizan> logicalguy: seems to me it's trying to use old versions of haskeline and regex-base
02:19:07 <mm_freak_> logicalguy: the usual solution is not to install haskell packages through portage
02:19:27 <logicalguy> mm_freak_, how does one install haskell packages then?
02:19:29 <mm_freak_> logicalguy: install only haskell infrastructure (ghc, cabal-install, darcs, etc.) and install the rest through cabal
02:21:14 <logicalguy> well, ive got very few haskell packages installed.  only ghc, cabal, the major ones you're talking about
02:22:27 <mm_freak_> haskeline suggests that you have more than that =)
02:22:50 <logicalguy> only darcs depends on haskeline
02:22:53 <logicalguy> mm_freak_,
02:23:21 <logicalguy> mm_freak_, and layman wants darcs
02:24:18 <mm_freak_> darcs depends on haskeline?
02:24:44 <mm_freak_> wow, indeed
02:24:56 <logicalguy> don't ask me why :P
02:25:00 <carpi> top down and bottom up approach?
02:25:14 <carpi> top down "or" bottom up approach?
02:25:34 <mm_freak_> logicalguy: you may want to install darcs via cabal-install, too
02:26:05 <logicalguy> mm_freak_, is darcs a haskell package?
02:27:52 * hackagebot safecopy 0.6.3 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.6.3 (DavidHimmelstrup)
02:29:07 <m3ga> logicalguy: yes, darcs is written in haskell and can be installed using cabal-install
02:56:12 <zomg> Is there some way I can *force* a specific package version for ALL deps for a build?
02:56:42 <Saizan> --constraint=
02:56:47 <zomg> I need to see if a problem persists with certificate-1.2.8 as opposed to 1.2.6, but several libs the project uses require 1.2.6
02:56:53 <Saizan> --constraint="pkg == ver"
02:57:18 <zomg> How do I put that in a cabal file? into ghc-options?
02:57:29 <Saizan> you don't
02:57:38 <Igloo> You can't tell cabal to ignore package dependencies, if that's what you mean
02:57:39 <zomg> Oh just as cabal arg?
02:57:41 <Saizan> and it doesn't override other constraints it just adds one
02:57:48 <Igloo> You can only further constrain them
02:57:51 <int-e> zomg: I think you're out of luck - you have to relax the constraints in all cabal files. (or cheat and install certificate-1.2.8 modifying the version to 1.2.6)
02:58:05 <maukd> zomg: pemtest works here
02:58:25 <zomg> maukd: yeah I'm seeing it pass with certificate-1.2.8 as well now... might be an issue with 1.2.6 which is why I'm trying this now
02:58:28 <maukd> also, 'cabal install cabal-install' fails
02:58:52 <zomg> int-e: that's what I figured
02:59:03 <zomg> thanks, guess I'll just need to set it up with all the sources changed
02:59:11 <maukd> Distribution/Client/BuildReports/Upload.hs:54:37:  Couldn't match expected type `Maybe b' against inferred type `URI'
02:59:14 <maukd> fucking cabal
03:01:33 <maukd> zomg: segfaults with 1.2.6
03:02:54 <logicalguy> thanks m3ga
03:03:32 <dcoutts_> maukd: is that a released version of cabal that fails to build with that type error?
03:04:08 <maukd> not sure, I just ran 'cabal install cabal-install'
03:04:49 <dcoutts_> maukd: what version of network are you using?
03:05:02 <int-e> maukd: not Cabal - network-2.4 changed the type of 'relativeTo' from Maybe to a definite result.
03:05:30 <dcoutts_> ah, I see we've got it fixed in the github version
03:05:52 <dcoutts_> maukd: so to build the released one use --constraint='network < 2.4'
03:06:35 <maukd> ah, I see
03:06:35 <zomg> maukd: thanks for checking
03:06:51 <maukd> network-2.4.0.1
03:08:13 <int-e> maukd: Of course, Cabal's fault is that it doesn't specify an upper bound on its network dependency.
03:08:26 <GnomeStoleMyBike> Hi!
03:09:19 <maukd> network-2.3 built fine so far, let's see how this goes
03:11:12 <maukd> dcoutts_, int-e: worked, thanks a lot
03:11:35 <dcoutts_> int-e: ironically
03:11:47 * dcoutts_ noticed that too
03:13:10 * hackagebot hxt 9.3.1.0 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.0 (UweSchmidt)
03:13:12 * hackagebot sgd 0.2.0 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.2.0 (JakubWaszczuk)
03:37:09 <merijn> hmm, I <3 Haskell
03:38:45 <merijn> With STM implementing polling from a group of Chan's just becomes "foldr1 orElse . map readTChan" xD
03:39:03 <merijn> Actually, slightly more I guess
03:39:58 <merijn> I guess it needs a "case tryRead of Nothing -> retry; Just s -> s"
03:40:07 <maukd> :t msum
03:40:08 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
03:40:58 <hyperFRITZ> merijn, me rijn is bet dan je rijn.
03:41:02 <hyperFRITZ> beter*
03:41:36 <merijn> @src STM msum
03:41:36 <lambdabot> Source not found. You untyped fool!
03:42:17 <maukd> @src msum
03:42:17 <lambdabot> msum =  foldr mplus mzero
03:43:18 <hvr> @src seq
03:43:19 <lambdabot> Source not found. Are you on drugs?
03:43:51 <hvr> lambdabot: sadly, no
03:44:02 <merijn> oh, readTChan already retries, it's just the docs that don't mention it
03:44:17 <merijn> So "msum . map readTChan" is sufficient
03:44:49 <merijn> hvr: I belief seq is built-in and so has no source?
03:44:52 <merijn> :t seq
03:44:53 <lambdabot> forall a t. a -> t -> t
03:44:58 <hvr> merijn: exactly :-)
03:45:09 <hvr> merijn: I was just wondering, whether lambdabot would show me GHC source
03:45:28 <hvr> (I /was/ being silly)
03:46:35 <maukd> :t foldr (orElse . readTChan) retry
03:46:36 <lambdabot> Not in scope: `readTChan'
03:46:36 <lambdabot> Not in scope: `retry'
03:49:45 <merijn> maukd: Doesn't seem much clearer
03:51:02 <merijn> The difference between a TVar and TMVar is that the latter can be empty, right?
03:51:39 <maukd> yes
03:52:21 <matthiasgorgens> also TVars allow more complicated transactions.
03:52:29 <matthiasgorgens> in a composable fashion.
03:52:30 <quicksilver> and reading from an empty TMVar is a retry, I presume?
03:52:34 <maukd> yes
03:52:35 <quicksilver> (rather than a block)
03:52:40 <maukd> and so is writing to a full TMVar
03:52:49 <quicksilver> matthiasgorgens: TMVars allow for composable transactions too
03:52:54 <matthiasgorgens> oh, ok.
03:53:00 <matthiasgorgens> Yeah, I was mixing it was MVars.  sorry.
03:53:06 * quicksilver nods
03:53:12 <matthiasgorgens> was -> with.
03:53:13 <quicksilver> well the naming scheme isn't a coincidence :)
03:53:21 <merijn> hmm, I don't suppose there's a "liftIO . atomically" by default?
03:53:24 <matthiasgorgens> what does the V stand for? ;o)
03:53:54 <hpc> @hoogle atomically
03:53:54 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
03:53:54 <lambdabot> GHC.Conc atomically :: STM a -> IO a
03:53:54 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
03:54:00 <matthiasgorgens> merijn: the same tricks as lifted-base does might be workable for monads build on TVar or TMVar, too.
03:54:32 <matthiasgorgens> though you have to watch out because MonadBaseControl is not "sound".
03:54:37 <merijn> @hoogle MonadIO m => STM a -> m a
03:54:38 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
03:54:38 <lambdabot> GHC.Conc atomically :: STM a -> IO a
03:54:38 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
03:54:42 <matthiasgorgens> (in a technical definition of the word.
03:55:07 <matthiasgorgens> see http://hackage.haskell.org/package/lifted-base
03:55:22 <quicksilver> merijn: it's not very hard to write "atomically = liftIO . STM.atomically" in one of your modules
03:55:25 <quicksilver> and then you have it :)
03:56:13 <merijn> quicksilver: Yeah, I just figured someone had probably already done that :p
03:56:13 <matthiasgorgens> lifted-base tries to do more than plain liftIO.  it tries to handle callbacks.
04:09:42 <merijn> If I have a set of things that aren't Ord instances, what's the best data structure to keep them in? (Since Set is obviously out)
04:19:44 <int-e> merijn: That's fairly vague. With just Eq, a list is about the best you can hope for. If you can extract some information (like a hash value), a map using that as keys, mapping to lists, may be better than a plain list.
04:22:10 <merijn> int-e: I basically have sets of TChan's, didn't want to traverse/rebuild entire lists when adding/removing elements.
04:23:14 * hackagebot sgd 0.2.1 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.2.1 (JakubWaszczuk)
04:23:28 <merijn> I guess one ugly hack would be a top level TVar holding the current channel count and defining "type Stream a = (Int, TChan a)", then I could provide an Ord instance for the Int and use the global counter to make sure they're unique
04:38:15 * hackagebot monadtransform 0.0.2 - A type-class for transforming monads (homomorphism) in a transformer  http://hackage.haskell.org/package/monadtransform-0.0.2 (TonyMorris)
04:38:52 <ckirkendall> quick question from a newbie
04:39:54 <m3ga> ckirkendall: don't ask to ask, just ask
04:41:03 <ckirkendall> I was trying to experiment with type classes and created this gist https://gist.github.com/3787511  but I am getting the following error: Not in scope: type constructor or class `Tip'
04:42:28 <int-e> ckirkendall: Node Tip (3::Int) Tip -- as you wrote it, Int Tip  would be interpreted as a type
04:42:30 <Botje> ckirkendall: I think you want (3 :: Int)
04:42:32 <carpi> in the Numeric library why does every function return a type 'ShowS' ?
04:43:30 <hpc> @src ShowS
04:43:30 <lambdabot> type ShowS = String -> String
04:43:53 <hpc> carpi: they apply the difference list optimization
04:43:55 <merijn> carpi: ShowS is used to build strings more efficiently
04:43:56 <int-e> carpi: because ShowS allows for more efficient concatenation that strings
04:44:08 <ckirkendall> int-e , Botje: Thank you very much that was it
04:44:28 <int-e> carpi: just provide an extra "" argument to get a string
04:44:55 <carpi> but it doesn't seem like it serves any purpose?
04:45:06 <hpc> carpi: basically, instead of returning a string like "abc", it returns a function like ('a':'b':'c':)
04:45:12 <hpc> pretend that was a valid section
04:45:37 <merijn> carpi: The purpose it serves is efficiency/optimisation
04:45:49 <hpc> carpi: instead of having to do a scan over "abc" to convert it to a form that can concat with another string, that form is returned directly
04:46:01 <hpc> @src (++)
04:46:02 <lambdabot> []     ++ ys = ys
04:46:02 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:46:02 <lambdabot> -- OR
04:46:02 <lambdabot> xs ++ ys = foldr (:) ys xs
04:46:48 <hpc> carpi: in other words, ("abc" ++ foo) normally computes to
04:46:56 <hpc> 'a' : 'b' : 'c' : foo
04:47:01 <carpi> a:b:c:foo
04:47:11 <hpc> yeah, so we just chop off foo and call it a function
04:47:19 <hpc> voila, efficient concatenation
04:47:41 <carpi> is it possible to see how ShowS is implemented?
04:48:35 <merijn> carpi: ShowS is just a type synonym for "String -> String"
04:48:44 <maukd> carpi: ... we just did
04:48:50 <merijn> Similar to how "String" is a synonym for "[Char]"
04:49:10 <hpc> 07:43 < lambdabot> type ShowS = String -> String
04:49:52 <hpc> carpi: incidentally, that line of optimization is how you get to the endofunctor monoid, and codensity
04:50:16 <hpc> if you want to see a more theoretical side to it
04:50:16 <merijn> hpc: I'm sure that helped :p
04:50:37 <hpc> :P
04:50:39 <carpi> shame on your for assuming i would know what an "endofunctor" , "monoid" and "codensity" means.. !
04:50:54 <carpi> kiding
04:51:18 <maukd> @src Monoid
04:51:18 <lambdabot> class Monoid a where
04:51:18 <lambdabot>     mempty  :: a
04:51:18 <lambdabot>     mappend :: a -> a -> a
04:51:18 <lambdabot>     mconcat :: [a] -> a
04:51:25 <maukd> (because monoids are pretty great)
04:51:56 <hpc> monoids are like differently-kinded categories
04:52:00 <hpc> or something
04:52:02 <carpi> endo... whatever sounds like the ents from LOTR
04:52:21 <maukd> carpi: do you understand Monoid above?
04:52:26 <hpc> "endo" basically means "into itself"
04:52:40 <hpc> "endofunctor" essentially means the type (a -> a)
04:52:46 <hpc> ie, functions that go from a type to itself
04:52:50 <maukd> @src Endo
04:52:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:52:56 <maukd> :-(
04:53:06 <hpc> newtype Endo a = Endo {appEndo :: a -> a}
04:53:12 <hpc> @quote appEndo
04:53:13 <lambdabot> hpc says: appEndo sounds like a harry potter spell
04:54:02 <Saizan> hpc: an endofunctor is one that goes from and to the same category
04:54:33 <Saizan> you were right about the prefix endo though
04:54:34 <carpi> maukd: all i see is that the word 'monoid' refers to a typeclass. im still at the starting rungs of haskell enlightenment. been there for a few months now
04:54:52 <maukd> carpi: do you know basic math?
04:55:08 <carpi> you + - * /? that i do
04:55:13 <maukd> like, various types of numbers, and sets
04:55:21 <hpc> Saizan: i was explaining it in haskell terms :P
04:55:31 <hpc> i still don't know all the CT terminology
04:55:44 <carpi> maukd: yea some of it. no expert by all means
04:55:48 <maukd> carpi: a monoid is a set with a special "neutral" element and an operation that combines two elements into a third
04:56:06 <maukd> e.g. natural numbers are a monoid with 0 and +
04:56:13 <Saizan> hpc: you were explaining it wrong :)
04:56:36 <maukd> oh yeah, the operation has to be associative: (a + b) + c = a + (b + c)
04:56:43 <maukd> and x + 0 = 0 + x = x
04:57:12 <maukd> if you use * as the operation, you get another monoid (with neutral element 1)
04:57:23 <palien> @seen humasect
04:57:23 <lambdabot> Unknown command, try @list
04:57:27 <palien> @list
04:57:27 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:57:41 <palien> !seen humasect
04:57:43 <maukd> strings are also a monoid: (++) combines two of them, and "" is neutral
04:57:53 <palien> sry for the noise ^_^;
04:58:26 <merijn> @src mappend Maybe
04:58:27 <lambdabot> Source not found. It can only be attributed to human error.
04:58:35 <maukd> carpi: ok so far?
04:58:40 <merijn> > mappend (Just 1) (Just 2)
04:58:41 <lambdabot>   Ambiguous type variable `t' in the constraints:
04:58:41 <lambdabot>    `Data.Monoid.Monoid t'
04:58:41 <lambdabot>  ...
04:58:54 <maukd> merijn: Maybe is lifted
04:59:13 <merijn> Oh, duh
04:59:33 <merijn> > mappend (Just [1]) (Just [])
04:59:34 <lambdabot>   Just [1]
04:59:56 <hpc> > mappend Nothing (Just [1])
04:59:57 <lambdabot>   Just [1]
05:00:12 <hpc> (that part is important, because otherwise mappend = liftM2 mappend)
05:00:37 <hpc> ((which is also a valid monoid))
05:00:55 <maukd> is it?
05:01:00 <maukd> what's mempty then?
05:01:06 <hpc> uh
05:01:20 <hpc> mempty = (return mempty)
05:01:29 <hpc> iirc
05:02:13 <maukd> oh, that makes sense actually
05:02:17 <maukd> it's like (*)
05:02:20 <hpc> you can consider that the "1" to Nothing's "0" and mappend's "*"
05:02:23 <hpc> yeah
05:03:35 <danr> is there an equivalent to map in perl?
05:03:43 <danr> ah. map.
05:03:46 <hpc> ;)
05:03:50 <hpc> and grep is filter
05:04:05 <carpi> how did some of you learn haskell? honest answers will help )
05:04:16 <nand`> initially, be reading LYAH
05:04:18 <nand`> by*
05:04:20 <danr> hpc: oh. thanks!
05:04:22 <hpc> carpi: LYAH and loads of work
05:04:23 <nand`> from then on, by writing Haskell
05:04:30 <maukd> (perl's map is actually concatMap)
05:04:36 <hpc> danr: incidentally, (grep == filter) is a nice way to remember which way the predicate goes
05:04:57 <Eduard_Munteanu> Googling around various topics, insisting on doing homework in Haskell instead of C or other stuff... :)
05:05:06 <hpc> maukd: totally forgot about that feature!
05:05:07 <danr> hpc: what do you mean?
05:05:31 <hpc> danr: the spoken english implication of "filter p list" is "remove elements that match p"
05:05:33 <tdammers> capri: not being able to make any sense of xmonad's "configuration file", then reading Real World Haskell, and from there, writing actual code and running into the typical situations
05:05:38 <hpc> instead of "keep the elements that match p"
05:05:45 <hpc> that trips up a bunch of people
05:06:08 <maukd> exercise: implement grep in terms of map
05:06:26 <frerich> > filter (> 5) [1..10]
05:06:26 <merijn> carpi: I had ocaml in university, was completely lost for a couple of weeks and didn't understand anything (and hated the syntax), kept programming python. Eventually 90% of my python code consisted of generators/list comprehensions/functional style, decided to try a functional language again and decided on haskell because of pretty syntax
05:06:27 <lambdabot>   [6,7,8,9,10]
05:06:44 <merijn> carpi: (And then it took 5 attempts of starting to learn haskell before I finally grokked it)
05:06:48 <frerich> hpc: huh, you're right - I am one of that bunch of people who get tripped up :)
05:07:20 <carpi> you didn't give up after 4 attempts. thax good
05:07:20 <danr> hpc: aha :) I always found the variance of the predicate to filter to be intuitive so it hasn't struck me that you could confuse it :)
05:08:24 <merijn> carpi: The first four attempts were mostly playing around in ghci with one liners for code golfing things, didn't attempt to write "real" applications
05:08:49 <nand`> hpc: I always saw the operation as ‘separate the list based on p’, the only confusion being which of the two resulting lists you end up keeping
05:09:25 <nand`> if you think of filter like a literal filter, you're keeping what you filter out and throwing away what goes through
05:10:10 <merijn> carpi: I think compiler/AST stuff helps to really understand the entire functional programming thing a lot. Recursion is just so obvious when working with trees
05:10:31 <danr> nand`: do you mean like in a sieve?
05:10:44 <nand`> danr: yes
05:11:53 <topriddy> hello
05:12:48 <luv> hello
05:12:51 <topriddy> trying to practice what have learnt so far, program to find product of two matrix giving parser error. my codes here: pastebin.com/bdhqZm4q
05:13:10 <luv> http://hpaste.org/75353 <- im trying to get lines 59 and 60 into one
05:13:28 <topriddy>  2 X 2 matrix
05:13:45 <nand`> [(a,a), (a,a)] is not a valid type
05:13:56 <luv> im trying to get rid of sym_lines'  as it seems redundant and only purpose of it is "to get rid of IO" in next step
05:13:57 <topriddy> nand`: Why?
05:13:57 <luv> so
05:14:02 <nand`> perhaps you meant ((a,a), (a,a))
05:14:05 <merijn> topriddy: Also, in the future please paste the error message as well
05:14:24 <topriddy> merijn: noted
05:14:33 <merijn> luv: fmap / <$>
05:14:41 <merijn> luv: IO is a Functor :)
05:14:43 <merijn> :t fmap
05:14:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:14:54 <merijn> :t (<$>)
05:14:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:15:19 <luv> merijn: yeah I have seen http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html and there is an instance of fmap for IO
05:15:27 <luv> merijn: though im not sure how to apply it :-S
05:15:29 <merijn> luv: Also, FYI. mapIO already exists :)
05:15:48 <luv> umm isnt mapIO what fmap would do for IO as a Functor?
05:16:08 <carpi> topriddy: i think changing the type annotation for the function will help
05:16:10 <merijn> :t mapM
05:16:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:16:20 <merijn> :t fmap
05:16:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:16:32 <merijn> luv: See the difference in the type?
05:16:41 <merijn> (Replace m/f with IO)
05:16:57 <luv> umm
05:17:00 <luv> im very new to haskell
05:17:28 <magnus___> How can I do this transformation? [[1,2],[3,4],[5]] => [[1,3,5],[1,4,5],[2,3,5],[2,4,5]]
05:17:42 <luv> mapM seems to take a function that returns an IO and a list a applies the function to the list
05:17:46 <merijn> luv: In that case I can highly recommend doing substitutions of type signatures by hand on paper. In the case of fmap you get "fmap :: (a -> b) -> IO a -> IO b"
05:17:50 <luv> yeah
05:17:55 <luv> mapM is my mapIO :-)
05:18:01 <nand`> > sequence [[1,2],[3,4],[5]]
05:18:02 <lambdabot>   [[1,3,5],[1,4,5],[2,3,5],[2,4,5]]
05:18:31 <merijn> luv: You can simplify the entire thing to "sym_lines <- concat `fmap` mapM getLines symFiles"
05:18:34 <luv> now lets see whats the difference between mapM and mapIO
05:18:39 <luv> merijn: i get that
05:18:49 <luv> merijn: but id like to understand why
05:18:51 <luv> thanks
05:19:26 <magnus___> @nand` thanks
05:19:26 <lambdabot> Unknown command, try @list
05:19:27 <luv> mapM getLines symFiles will give me IO [String] right
05:19:33 <merijn> luv: (or, if you prefer <$> is a combinator that does the same as fmap so that you get "concat <$> mapM getLines symFiles")
05:19:36 <merijn> luv: Correct
05:19:55 <luv> oh
05:20:04 <luv> fmap doesnt take a list but a "wrapped" list
05:20:19 <maukd> fmap takes a wrapped something
05:20:24 <maukd> list is a kind of wrapper
05:20:25 <merijn> luv: fmap takes a Functor f, and does something inside that f
05:20:37 <luv> so fmap <foo> (IO [String]) will unwrap, apply foo on String and wrap again?
05:20:37 <merijn> luv: fmap = map for lists, but you can also do other things
05:20:46 <merijn> > fmap (+1) (Just 1)
05:20:47 <lambdabot>   Just 2
05:20:51 <merijn> > fmap (+1) Nothing
05:20:52 <lambdabot>   Nothing
05:20:53 <luv> ok
05:21:07 <luv> fmap (+1) (IO [1,2,3])
05:21:17 <luv> would return IO [2,3,4] ?
05:21:32 <luv> > fmap (+1) (IO [1,2,3])
05:21:33 <lambdabot>   Not in scope: data constructor `IO'
05:21:37 <merijn> IO is not an exxisting structure. But if it did it would be a type error
05:22:17 <maukd> luv: fmap (+1) (IO [1,2,3]) would be IO ([1,2,3] + 1)
05:22:23 <merijn> fmap has type "Functor f => (a -> b) -> f a -> f b" and (+1) has type "Int -> Int" (well really "Num a => a -> a", but let's ignore for now)
05:22:39 <merijn> so "fmap (+1)" becomes "Functor f => f Int -> f Int"
05:23:03 <luv> looks ok
05:23:20 <merijn> If you combine it with an "IO Int" it'd become "fmap (+1) :: IO Int -> IO Int"
05:23:30 <luv> still looks godo to me :-)
05:23:35 <merijn> But "[1,2,3] :: IO [Int]"
05:23:50 <merijn> So GHC will complain that "[Int]" is not "Int"
05:24:14 <luv> well
05:24:20 <merijn> Which is why "fmap (+1) foo" fails if "foo :: IO [Int]"
05:24:38 <topriddy> nano': poor network got disconnected. i didt see tour response
05:24:43 <luv> i have a similiar case her --- I use fmap <string_function> (IO [String]) ... and it's supposed to work fine
05:24:53 <merijn> luv: Ah, but what is the type of concat?
05:24:55 <merijn> :t concat
05:24:56 <lambdabot> forall a. [[a]] -> [a]
05:25:03 <maukd> concat is not a string function
05:25:24 <topriddy> > :t [(a,a), (a,a]
05:25:25 <lambdabot>   <no location info>: parse error on input `:'
05:25:31 <topriddy> > :t [(a,a), (a,a)]
05:25:32 <lambdabot>   <no location info>: parse error on input `:'
05:25:45 <topriddy> > :t ((a,a), (a,a))
05:25:46 <lambdabot>   <no location info>: parse error on input `:'
05:25:53 * topriddy oh well
05:26:05 <luv> so fmap func (IO a) ... unwraps IO, applies func, wraps IO
05:26:17 <merijn> "fmap :: Functor f => (a -> b) -> f a -> f b" and "concat :: [[a]] -> [a]", if we combine the "(a -> b)" in fmap get's replaced with "[[a]] -> [a]" and we get: "fmap concat :: Functor f => f [[a]] -> f [a]"
05:27:00 <merijn> Now, String is just a different name for [Char], so [String] is really [[Char]]
05:27:29 <nand`> one does not ‘unwrap’ IO
05:27:29 <luv> alright - i think i understand a bit more why I can simplify to sym_lines <- fmap (concat) (mapM getLines symFiles)
05:27:31 <topriddy> help
05:27:37 <merijn> And "IO [[Char]]" clearly matches "fmap concat :: Functor f => f [[a]] -> f [a]"
05:27:39 <luv> nand`: one does here :-)
05:28:01 <luv> nand`: i have to think about that in those lines for now
05:28:06 <merijn> luv: Well, it helps to think of it as inserting concat into IO, rather than unwrapping/wrapping :)
05:28:12 <nand`> what does ‘unwrap IO’ mean for “getLine” ?
05:28:25 <luv> merijn: that will do :-)
05:28:37 <maukd> luv: fmap doesn't really weaken the iron skin of IO to let you peek inside. instead it strengthens the function
05:28:41 <bartavelle> ok is that me or isn't there any code anywhere that explains how you use lua tables with hslua ?
05:28:53 <luv> nand`: let x <- getLin
05:29:29 <luv> but yeah thinking about it as insterting concat into IO is fine
05:29:35 <luv> cheers :-)
05:29:52 <merijn> luv: Anyway, in the future it really helps understanding to just do these types of substitutions by hand on paper (and maybe check using ghci/lambdabot whether you were correct)
05:42:45 <Polarina> mm_freak_, having the manager wire back would be very nice. And the documentation you have is excellent, by the way. I love it in every way. Thank you. :)
05:57:48 <hiptobecubic> There's something about watching a computer scientist type with two fingers that just unsettles me.
05:58:31 <hiptobecubic> It's like studying music theory and not learning to play an instrument.
06:00:36 <madjestic> hiptobecubic: I find brain interfaces far superior to keyboards
06:00:41 <Jafet> Computer scientists that use blackboards.
06:01:11 <EvanR2_> qwerty sucks
06:01:51 <hiptobecubic> madjestic, I have yet to see a brain interface that wasn't completely terrible.
06:02:02 <topriddy> i blogged on haskell here: http://topriddy.wordpress.com/2012/09/26/functioning-in-a-functional-language/
06:03:23 <hiptobecubic> topriddy, a fine start :)
06:03:43 <EvanR2_> topriddy: done to death i know, but im interested in knowing more about this 'brain wired to think in OOP' thing
06:04:39 <EvanR2_> something in generation X mothers diets?
06:05:00 <topriddy> heh
06:05:11 <Jafet> The modern trend of objectification
06:05:30 <Jafet> Not to be confused with 70's era objectivism
06:05:33 <EvanR2_> objectivism
06:05:37 <EvanR2_> dang
06:06:02 <Jafet> I still want existentialist types
06:13:22 * hackagebot monad-codec 0.1.0 - Monadic conversion between complex data structures and unique integers  http://hackage.haskell.org/package/monad-codec-0.1.0 (JakubWaszczuk)
06:15:16 <Polarina> EvanR2_, you should look at the alternatives then.
06:15:30 <EvanR2_> of course
06:16:45 <canta> blist
06:16:51 <canta> sry, wrong window
06:17:29 <hiptobecubic> is there a changelog from 7.4 to 7.6? Did the -fno-code flag disappear?
06:17:34 <hpaste> scooty-puff pasted “cabal LANGUAGE detection” at http://hpaste.org/75355
06:18:10 <scooty-puff> in the paste, could i assume if a language extension is in an even tenth (7.2., 7.4, etc.), its in the next lower odd (7.1, 7.3, etc.)?
06:19:02 <dcoutts_> scooty-puff: I'm not sure why you'd bother to assume anything about the devel versions
06:19:12 <rwbarton> you can reasonably assume the odd versions don't exist
06:19:41 <scooty-puff> k
06:20:15 <dcoutts_> scooty-puff: and if you think about it, you can answer your question: some 7.1 versions will have the extension, some not, depending on when the extension was added. So you decide what you want.
06:21:06 <ceii> hiptobecubic, it's still in 7.6 according to the user's guide
06:21:28 <hiptobecubic> ceii, I didn't see it. Are you looking at it right now? Can you link?
06:21:35 <hiptobecubic> maybe i'm on the wrong page
06:22:02 <ceii> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/flag-reference.html#id549663
06:22:24 <hiptobecubic> aha, there's a flag-reference... that's nice. I was just digging through individual pages about flags here and there
06:22:53 <hiptobecubic> what does "omit-code generation" really do? Isn't code what we want?
06:23:15 <EvanR2_> haha
06:23:57 <hiptobecubic> sorry, omit code-generation :)
06:24:08 <ceii> good question, I suppose it just doesn't output anything
06:24:17 <ceii> unless you use -ddump-core or similar
06:24:42 <hiptobecubic> then what's the point?
06:24:50 <ceii> no idea
06:25:41 <whald> ehm, what might be cause a profiling build being much faster than a regular build?
06:25:59 <whald> I don't mean the compile time, but the execution time
06:26:27 <hiptobecubic> I'm looking at ghcmod and ghcmod-vim, and -fno-code *really* improves responsiveness, but then there are some cases where it's unable to function properly. Presumably because it hasn't generated some appropriate code to use to report a type or something.
06:26:31 <whald> and my .cabal file has no ghc-prof-options, so the options for regular builds should be inherited, right?
06:27:06 <hiptobecubic> For example it doesn't work with template haskell, and apparently using -fno-code also doesn't work with unexported functions
06:27:16 <hiptobecubic> So i'm trying to figure out what -fno-code actually does
06:27:57 <merijn> hiptobecubic: typecheck, presumably?
06:27:58 <hiptobecubic> oh.. also ghci i guess.
06:28:22 <hiptobecubic> ghci -fno-code MyFile.hs    and then :i foo   where foo is unexported just prints a blank line
06:29:07 <tromp> > 1440*9/7
06:29:08 <lambdabot>   1851.4285714285713
06:37:24 <osa1> strange, I'm getting this error while trying to run a code that uses LLVM bindings with ghci: http://hpaste.org/75359 but it works fine when I compile it with ghc --make. any ideas why ?
06:38:16 <yezariaely> Can I create documentation for a package with cabal though it is an executable? I always get "No documentation was generated as this package does not contain a library."
06:38:30 <yezariaely> (cabal-dev … haddock)
06:39:52 <ceii> yezariaely, tried using the --executables option?
06:40:02 <ceii> it's in the regular cabal command at least
06:40:56 <Spockz> Is there a way to clean up my cabal library? I'm getting all sorts of errors installing packages and I would like to start over with the packages
06:41:31 <whald> Spockz, clean out your ~/.cabal and ~.ghc/
06:42:20 <whald> Spockz, that will let you start over with only what's system wide installed for you, which shold be ok in most cases
06:42:42 <Spockz> whald: does a cabal install default to --user nowadays?
06:42:50 <Spockz> (on OS X)
06:43:21 <quicksilver> wait, whut? "type TId a = a" "type PersonRow = Person TId"
06:43:37 <ceii> Spockz, you can see what's installed system-wide and for your user using ghc-pkg list
06:43:38 <quicksilver> you can pass partially applied type synonyms as parameters to other type synonyms?
06:43:41 * quicksilver never knew that.
06:44:06 * ceii neither
06:44:10 <Jafet> They're types
06:44:20 <whald> Spockz, oh, on OS X I don't know the paths, but I think cabal install  defaults to user installs
06:44:29 <rwbarton> what is 'Person' in this example?
06:44:31 <Jafet> I think the only problem is using them as instance heads
06:44:34 <rwbarton> also a type synonym?
06:44:51 <quicksilver> Jafet: type synonyms are types, sure.
06:44:57 <Spockz> whald: there were a lot of packages in ~/.ghc so I think I hit the target ;)
06:44:57 <quicksilver> Jafet: but *partially-applied* ones are not.
06:45:12 <quicksilver> partially-applied type synonyms are nothing
06:45:20 <quicksilver> (context : http://chrisdone.com/posts/2010-10-07-haskelldb-and-typeoperator-madness.html )
06:45:44 <whald> seriously, then an executable built with "--enable-executable-profiling" is almost 2x faster than on built without, what's that? I'm clueless
06:45:49 <whald> s/then/when
06:45:54 <Spockz> whald: strictness
06:46:13 <rwbarton> I think GHC expands type synonyms outside-in
06:46:39 <rwbarton> so you can pass a partially applied type synonym as an argument to another type synonym if in the expansion of the latter it becomes fully applied
06:46:51 <rwbarton> also I think this is controlled by a language extension
06:47:03 <rwbarton> not Haskell 98/2010
06:47:05 <whald> Spockz, which one would be "stricter"?
06:47:17 <Spockz> whald: the one with profiling
06:47:33 <quicksilver> rwbarton: it does make sense in the "type synonyms are only macros" sense
06:47:40 <Polarina> whald, can you share some code that exercises this behaviour?
06:47:44 <quicksilver> as long as what you end up with is fully applied.
06:47:50 <quicksilver> I'd just never seen it/thought of it before.
06:48:02 <quicksilver> it makes type synonyms slightly more useful than I'd given them credit for.
06:48:32 <Philippa> what does? (Hi, I'm lazy and cba to check the logs in a minute or two)
06:48:39 <hpaste> “http://www.0daymusic.eu/” pasted “http://www.0daymusic.eu/” at http://hpaste.org/75361
06:48:49 <Philippa> I've found myself wanting local (to a datatype declaration) synonyms today
06:49:14 <Philippa> bonus points for being able to declare a datatype in terms of a synonym of appropriate form
06:49:16 <whald> Polarina, yes the code is here: https://github.com/waldheinz/bling
06:49:52 <whald> Polarina, just "cabal build" and then "./dist/build/bling/bling examples/cornell-box.bling"
06:50:08 <Polarina> whald, I'll take a look. :)
06:50:38 <rwbarton> Philippa, the fact that you can pass a partially applied type synonym as an argument to another type synonym provided the expansion of the latter causes the former to become fully applied
06:50:42 <quicksilver> Philippa: "type TId a = a" "type PersonRow = Person TId"
06:51:12 <quicksilver> Philippa: if you cba to check the logs then instead you have to be smart enough to reconstruct a useful context from that snippet :)
06:51:19 <quicksilver> Philippa: (context - http://chrisdone.com/posts/2010-10-07-haskelldb-and-typeoperator-madness.html )
06:51:47 <whald> Polarina, the program is affected by http://hackage.haskell.org/trac/ghc/ticket/7185 -- which was fixed in 7.6.1 recently.
06:52:06 <whald> Polarina, so if it segfaults, it might be just that
06:52:29 <Philippa> ooh. Yes, fixity for type synonym operators is nice
06:53:11 <benmachine> quicksilver: there's an extension that I think is supposed to make the rules about type sysnonyms a bit less strict
06:53:18 <merijn> Spockz: Some stuff is also installed in ~/Library/Haskell/
06:53:21 <benmachine> I forget what it's called
06:53:26 <Spockz> merijn: yes binaries I saw there
06:53:31 <merijn> Spockz: (Specifically in bin, lib, doc and ghcversion)
06:53:34 <yezariaely> ceii: thanks for the hint with the executable.
06:53:38 <benmachine> LiberalTypeSynonyms
06:53:57 <Philippa> I might actually sit down and bash out something suitable for the AST manipulation that's pissing me off as I functorialise the hell out of everything
06:54:11 <Philippa> though that's an extra kind of hard because you'd get polykinded synonyms
06:54:17 <benmachine> I feel I ought to make a political joke but
06:54:20 <Philippa> (I think that's pronounced "oh fuck")
06:54:22 <benmachine> perhaps I'll pass :P
06:54:45 <benmachine> Philippa: nothing wrong with PolyKinds
06:55:00 <Spockz> is anyone using Hermit here? Does it work from GHCI as well?
06:55:27 <Philippa> benmachine: nope, but it's putting me into "I actually have to think and might run into something counterintuitive" territory
06:55:35 <benmachine> :P
06:55:44 <benmachine> it's good when you can avoid thinking
06:56:12 <Philippa> I think all the FieldTag instances or their equivalent still count as pissing me off too much, anyway
06:57:25 <merijn> So far my main frustration with DataKinds has to be that (lacking "proper" type level compose) it is impossible to do have GADTs "Foo (x :: Maybe a)" and make a Functor instance for "Foo (Just v)" :\
06:57:32 <bartavelle> god I finished writing "instance (Lua.StackValue a, Lua.StackValue b, Ord a) => Lua.StackValue (Map.Map a b)"
06:57:34 <bartavelle> this was horrible
06:58:10 <bartavelle> not sure why this wasn't done already as it is obviously quite useful
06:58:23 * hackagebot language-objc 0.4.2.4 - Analysis and generation of Objective C code  http://hackage.haskell.org/package/language-objc-0.4.2.4 (JohnLato)
07:13:24 * hackagebot yesod-fb 0.1.3 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.1.3 (FelipeLessa)
07:14:05 <Polarina> whald, does the package require llvm?
07:14:56 <whald> Polarina, not really, but it's a tad faster with. but it runs just fine without. the profiling problem is also there without llvm
07:18:01 <Polarina> whald, the first thing I get is "Prelude.head: empty list" when I run that.
07:20:27 <whald> that's strange, what's you command line?
07:21:51 <Polarina> whald, dist\build\bling\bling.exe
07:22:18 <whald> you need to specify the scene to render, try adding "examples/cornell-box.bling"
07:22:31 <whald> the command line parsing is mostly absent. :-)
07:24:50 <Polarina> whald: now I get "<stderr>: hPutChar: invalid argument (Bad file descriptor)"
07:27:42 <whald> stderr being an invalid FD is a bit strange, do you get any output before that?
07:28:50 <Polarina> whald, none.
07:30:33 <whald> i have never run it on window, but the only place I can imagine where this might come from is the src/Graphics/Bling/Main/Main.hs -- I have never seen this before on OSX and Linux
07:37:49 <Polarina> whald, I have no idea then.
07:38:31 <whald> Polarina, ok, thanks anyway. I'll have a look what's the problem on windows when I'm at home where I have a windows VM
07:42:32 <Jello_Raptor> hmm, what are those named data typess called which look like "data this = {that::Int,everythingElse::Int}" called?  I can't find documentation.
07:42:43 <otters> record syntax
07:44:00 <otters> Jello_Raptor: the constructor is the same type as a regular datatype's constructor would be, but you can initialize and update fields using record syntax, which is nice
07:44:31 <otters> data Foo = Foo { bar :: Int, baz :: Int }; f = Foo { bar = 3, baz = 4 }; print $ f { bar = 5 }
07:44:38 <otters> "Foo { bar = 5, baz = 4 }"
07:46:56 <t7> are Data.Set's lazy?
07:47:40 <t7> well it doesnt matter
07:48:36 <merijn> otters: Better yet, just use lenses :p
07:48:55 <otters> yeah, lenses are way easier than record syntax
07:49:06 <otters> all you need is to install a package, make an import, and use Template Haskell
07:49:16 <t7> lel
07:49:40 <Jello_Raptor> otters: thanks, I was looking for a more exact syntax definition, and without the name of the structure, I didn't know where to find it, ... also yup, i found lenses too and an reading up on them :)
07:49:44 <merijn> Data.Lens is pretty easy. Control.Lens is nice, but not sure yet whether I'd recommend it :p
07:49:51 <byorgey> t7: they are lazy in the values, and strict in the keys
07:49:54 <edwardk> merijn: =P
07:50:10 <otters> merijn: we're running out of Lens module name prefixes
07:50:12 <byorgey> t7: oh, you said Set
07:50:32 <merijn> Or, rather. I'd recommend Control.Lens after Data.Lens has convinced you that they're a smart idea :p
07:50:41 <otters> dibs on Language.Lens
07:50:46 <byorgey> t7: no, Sets aren't lazy, since the values stored have to be evaluated enough to compare them with other values, to decide where to store them in the tree
07:50:47 <otters> and Network.Lens
07:51:04 <edwardk> otters: I already have Language.Haskell.TH.Lens ;)
07:51:28 <merijn> otters: To be fair none of those actions are particularly hard :p
07:51:29 <otters> Jesus
07:51:29 <byorgey> Optics.Lens
07:51:47 <edwardk> and Data.Data.Lens
07:51:58 <otters> Control.Data.TH.Lens
07:52:00 <HugoDaniel_II> <3
07:52:53 <otters> I'm admiring the diagram on Control.Lens' hackage page
07:53:18 <merijn> If I ever need a better Haskell programmer I'll say "Lens, lens, lens" while looking in a mirror. Pretty sure that summons edwardk :p
07:54:10 <Philippa> not "zygohistomorphicprepromorphism"*5?
07:54:13 <edwardk> Heh. I figured there was a certain irony to using UML to model lenses. It has a very 'yo dawg' feel to it. I mean we're so imperative even our accessors have diagrams showing what accessors they have.
07:55:05 <merijn> Well, this is sad...
07:55:21 <merijn> Chrome's PDF rendering is snappier and more responsive than OSX's Preview >.>
07:55:38 <Cale> What could be more imperative than forall f. Functor f => (c -> f d) -> a -> f b?
07:55:47 <Botje> merijn: you say that like it's a bad thing :)
07:56:15 <merijn> Botje: It is, it means I have to continuosly open PDFs from Chrome rather than opening them from the file browser...
07:56:33 <frerich> edwardk: Is http://www.youtube.com/watch?v=efv0SQNde5Q still useful for learning about how the stuff at https://github.com/ekmett/lens works, or is the video outdated? I lost track of what's the lens du jour, but people seem to agree that your version is actually kinda neat :-)
07:57:46 <frerich> The video is "only" about a year old, but in Haskell terms that means there may have been half a dozen lens implementations created and discarded since then :-}
07:57:58 <Cale> frerich: that seems to use an old definition of lenses
07:58:16 <merijn> Deprecate early, deprecate often xD
07:58:18 <Cale> also, it's in scala, which is a bit of a handicap
07:59:18 <Botje> merijn: make it the default app for pdfs then?
08:00:01 <t7> I need some kinda hyper extensible tree structure
08:00:04 <Cale> frerich: The old definition of a lens was simply something like  data Lens a b = L { get :: a -> b, set :: b -> a -> a }
08:00:11 <t7> i think dynamic types might be right for this
08:00:26 <t7> or just JSON style
08:00:46 <edwardk> frerich: the stuff i cover in that video is still useful for understanding why lenses are neat
08:00:51 <Cale> frerich: which is nice enough, in that you can compose them end to end, and such
08:01:11 <Cale> http://twanvl.nl/blog/haskell/overloading-functional-references
08:01:14 <edwardk> frerich: i'll probably post my 2-hour long 'lens' crash course from boston haskell talk to that channel soon
08:01:26 <edwardk> i just need to figure out how to get it to successfully transfer off the phone ;)
08:01:47 <Cale> A blog post explaining the old lenses, ironically(?) from the blog of the guy the new lenses are named after :)
08:02:17 <luv> let area = ( (read base) * (read height) ) / 2 ::Float
08:02:22 <Lutin`> edwardk: Do you put them up on youtube? If so what's your account?
08:02:34 <edwardk> http://www.youtube.com/user/edwardkmett?feature=watch
08:03:02 <SLi> I wonder if it would be possible to get from ghc/cabal the "[N of M] Compiling ModuleName (...)" lines without a thousand "Loading package..." lines when using template haskell. If I say "ghc-options: -v0", I get nothing, if I say "ghc-options: -v1", I get both.
08:03:12 <Cale> http://www.twanvl.nl/blog/haskell/cps-functional-references
08:03:26 <luv> base and height are strings
08:03:27 * hackagebot cognimeta-utils 0.1.2 - Utilities for Cognimeta products (such as perdure). API may change often.  http://hackage.haskell.org/package/cognimeta-utils-0.1.2 (PatrickPremont)
08:03:29 <edwardk> i have video from my talk on bound that needs to get cut up and posted, and the lens talk i also need to post
08:03:29 * hackagebot monad-codec 0.1.1 - Monadic conversion between complex data structures and unique integers  http://hackage.haskell.org/package/monad-codec-0.1.1 (JakubWaszczuk)
08:03:34 <quicksilver> it was twanvl's original blog post which meade me 'get' it originally
08:03:41 <luv> so i suppose read should convert them to Num in that expression
08:03:45 <luv> but it wont compile ?!
08:03:57 <Cale> frerich: that second blog post is about the newer lenses
08:04:12 <Cale> frerich: but still not quite as general as they are in the lens package
08:04:40 <hdev> is there a function, that takes two records of same type a and a third parameter [(a -> *)], that will merge on those functions defined in the third parameter? is this even possible?
08:04:44 <merijn> luv: What's the error?
08:04:47 <edwardk> in theory i have video on an old camera of mine of my talk on improving the known asymptotics of online lowest common ancestor search too
08:04:47 <edwardk> the lens package generaralizes lenses to allow for lenses with multiple targets, things that can be used for only getting, only setting, isomorphisms, indexed structures, etc.
08:04:49 <byorgey> luv: that code looks fine to me.  Can you paste your entire code along with the exact error message on hpaste.org?
08:05:01 <edwardk> er generalizes even
08:05:05 <luv> sure
08:05:41 <edwardk> and then packages them up with a version of uniplate that is compatible with its notion of a traversal and a form of zippers based on traversals
08:05:53 <luv> http://hpaste.org/75376
08:06:00 <edwardk> along with other goodies, like representable functors with lenses as the representation, which makes things like linear algebra nice to work with
08:06:07 <Cale> frerich: and then there's http://r6.ca/blog/20120623T104901Z.html which explains how to do polymorphic updates in the context of the new style lenses by generalising them slightly.
08:06:22 <luv> oh
08:06:23 <luv> :-)
08:06:24 <luv> i see now
08:06:29 <Cale> http://comonad.com/reader/2012/mirrored-lenses/ also talks about them
08:06:41 <luv> on the last line I should convert area to a string
08:06:52 <quicksilver> Cale: is there an affiliate link to purchase new wallpaper after that series of blog posts makes your head explode?
08:07:00 <merijn> luv: You're missing "show" on the last line :p
08:07:08 <edwardk> talking to roconnor about the stuff he was going to post in that r6.ca post was basically the thing that got me started on breaking down the concept of lenses into what became the lens package
08:07:21 <merijn> luv: FYI, there's also readLn :: IO String
08:07:25 <merijn> eh
08:07:27 <merijn> IO a
08:07:44 <merijn> luv: It's basically a combination of read + getLine
08:07:44 <alpounet> luv, the compiler (correctly) gives are the Float type, but then you try to append it to a String (which is [Char])
08:07:58 <alpounet> to do Float -> String, you must use 'show', like merijn said
08:08:05 <alpounet> s/are/area
08:08:29 <merijn> luv: So if you use "base <- readLn" you can skip the read conversion in the computation of area
08:08:38 <Puffton> If I have a list of tuples and want to make a map out of the first and second parameters of the tuple
08:08:56 <merijn> :t Map.fromList
08:08:57 <lambdabot> Couldn't find qualified module.
08:08:59 <Puffton> Is there a pretty way of doing it? I can do it with Set.fromList and doing one argument per each map
08:09:04 <merijn> :t Data.Map.fromList
08:09:05 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
08:09:10 <luv> thanks
08:09:28 <merijn> Puffton: Something like that? :p
08:09:34 <Puffton> oh sorry, damn, I meant Set
08:09:41 <Puffton> and I know there is a Set.fromList, too
08:09:49 <Puffton> but I need to break the tuples up
08:09:57 <rwbarton> start over
08:10:01 <rwbarton> what do you have and what do you want
08:10:17 <merijn> He wants "[(a,b)] -> (Set a, Set b)"
08:10:26 <Puffton> [(a,b,c),(d,e,f)] to [a,b,d,e] where first to args are strings in the triple
08:10:41 <merijn> oh, hmm
08:10:45 <Puffton> and [a,b,d,e] is a set, so maybe {a,b,d,e} is proper notation
08:10:46 <merijn> That's different, I guess
08:10:54 <nooodl> unzip3 and union?
08:11:11 <Puffton> ah yes unzip could be cool
08:12:12 <Puffton> but then I would need to use Set.fromList on the union
08:12:31 <Puffton> and filter out every third param or so
08:12:35 <Puffton> since I only want the first two
08:12:51 <rwbarton> @type unzip3
08:12:52 <lambdabot> forall a b c. [(a, b, c)] -> ([a], [b], [c])
08:12:53 <ski> Philippa : "I've found myself wanting local (to a datatype declaration) synonyms today" -- for abbreviation ?
08:12:56 <ski> (quicksilver : "it does make sense in the \"type synonyms are only macros\" sense" -- probably one could make this more exact using ideas from multi-stage computations)
08:13:37 <rwbarton> Puffton: just throw away the third component of the result of unzip3
08:14:42 <Puffton> rwbarton, but won't the solution be kind of ugly then?
08:14:49 <thoughtpolice> edwardk: so, i AM really liking zipper + plate a lot. the horizontal movements confused me at first, but i am really liking it
08:15:04 <Puffton> unzip3 + drop(?) + Set.fromList
08:15:13 <merijn> :t uncurry (union `on` Data.Set.fromList) . \(x, y, z) -> (x, y) . unzip3
08:15:14 <lambdabot>     Couldn't match expected type `[a]' against inferred type `S.Set a1'
08:15:14 <lambdabot>     In the second argument of `on', namely `S.fromList'
08:15:14 <lambdabot>     In the first argument of `uncurry', namely
08:15:23 <edwardk> =)
08:15:23 <edwardk> yeah you pick a traversal to grab a horizontal slice of whatever it is you want and them can move left or right within that slice
08:15:32 <Puffton> well tail works, rather than drop, but still
08:15:38 <rwbarton> what
08:15:40 <Puffton> or hm
08:15:44 <nooodl> why the drop?
08:15:46 <rwbarton> it's a tuple, just use pattern matching
08:15:50 <Puffton> I figured I would reverse+drop or something
08:15:59 <Puffton> oh hm, but won't it make it automatically?
08:16:06 <rwbarton> let (x, y, _) = unzip3 stuff in Set.fromList (x ++ y)
08:16:37 <Puffton> rwbarton, it's [(x,y,z)], a list of triples
08:16:43 <rwbarton> yes
08:16:43 <Puffton> but I could do it recursively I guess like that
08:16:45 <nooodl> rwbarton: wouldn't (Set.fromList x `union` Set.fromList y) be better
08:16:48 <rwbarton> what
08:16:48 <Puffton> although it feels ugly still
08:16:54 <nooodl> Puffton: do you know what unzip3 does
08:16:55 <rwbarton> did you see unzip3?
08:17:04 <Puffton> nooodl, yes
08:17:10 <merijn> :t uncurry (union `on` Data.Set.fromList) . (\(x, y, z) -> (x, y)) . unzip3
08:17:11 <lambdabot>     Couldn't match expected type `[a]' against inferred type `S.Set a1'
08:17:11 <lambdabot>     In the second argument of `on', namely `S.fromList'
08:17:11 <lambdabot>     In the first argument of `uncurry', namely
08:17:15 <merijn> pffft
08:17:17 * hackagebot perdure 0.2.1 - Robust persistence for acyclic immutable data  http://hackage.haskell.org/package/perdure-0.2.1 (PatrickPremont)
08:17:17 <merijn> :t union
08:17:19 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
08:17:22 <merijn> oh, bah
08:17:23 <Puffton> ok nvm
08:17:28 <nooodl> Data.Set.union?
08:17:29 <merijn> :t uncurry (Data.Set.union `on` Data.Set.fromList) . (\(x, y, z) -> (x, y)) . unzip3
08:17:30 <lambdabot> forall b c. (Ord b) => [(b, b, c)] -> S.Set b
08:17:35 <merijn> \o/
08:17:35 <Puffton> I thought it just took a single triple
08:19:01 <nooodl> unzip3 x = [x]? :P
08:20:59 <osa1> how can I create float constants in haskell llvm bindings ?
08:21:01 <rwbarton> nooodl, quite possibly but I wouldn't expect a noticeable difference
08:21:48 <Cale> edwardk: Hey, so, lenses are polymorphic in the choice of a functor. Presumably that corresponds in some way to a naturality condition, but have you thought at all about how to write that naturality condition down? (I figure if anyone has then you would have :)
08:22:21 <edwardk> being polymorphic in the form of the functor really just means you have the same information as an isomorphism lens
08:22:51 <Cale> Well, I'm thinking of lifting this whole idea to an arbitrary category
08:23:04 <Cale> one which maybe doesn't have the same endofunctors as we have here
08:23:08 <Cale> ?
08:24:31 <Cale> So we have some category C, and some chosen objects X, Y, Z, W in C, and a family of mappings L_F sending each arrow X -> FY, to an arrow Z -> FW.
08:24:36 <quicksilver> ski: multi-stage computations at the type level?
08:25:01 <Cale> hmm
08:26:25 <edwardk> i admit i haven't given it much thought in a more general setting
08:26:28 <Cale> maybe the condition relating L_F to L_G has to involve all choices of natural transformation F -> G
08:26:58 <rwbarton> won't it be some kind of awful dinaturality condition, because "sending each arrow X -> FY to an arrow Z -> FW" is not functorial in F
08:27:03 <mm_freak_> Polarina: thanks =)
08:27:58 <edwardk> rwbarton: probably
08:28:14 <ski> quicksilver : yes
08:31:39 <merijn> Where should discussion/suggestion of features in GHC go? Is there a mailing list or should it go to more general haskell lists?
08:32:18 * hackagebot catch-fd 0.1.0.2 - MonadThrow and MonadCatch, using functional dependencies  http://hackage.haskell.org/package/catch-fd-0.1.0.2 (AndySonnenburg)
08:32:19 <Clint> haskell prime somethingorother?
08:33:14 <edwardk> hrmm, so we have a category C, chosen objects a,b,c,d, and have a family of mappings L_F such that for any endofunctor F : C -> C, L_F is a functor from C(c, F d) to C(a, F b) ? or something
08:35:12 <edwardk> er i C(c, F d) is probably just a set of homomorphisms, not a category in its own right
08:35:13 <Cale> Maybe the law is that for any eta: F -> G, and any a: X -> FY, we have that eta_W . L_F a = L_G (eta_Y . a)
08:35:56 <edwardk> that looks plausible
08:36:24 <edwardk> and should follow as a free theorem in haskell
08:37:01 <edwardk> here its the parametricity in f, rather than the parametricity in the arguments giving it to you
08:37:40 <edwardk> well, the free theorem plus the fmap id = id side-condition
08:38:02 <Cale> I forget how to use @free :)
08:38:51 <Cale> well, that's the obvious law anyway, so it's probably the right one :)
08:41:01 <maukd> :t generalCategory
08:41:02 <lambdabot> Char -> GeneralCategory
08:41:05 <maukd> > generalCategory '⁢'
08:41:06 <lambdabot>   <no location info>:
08:41:06 <lambdabot>      lexical error in string/character literal at chara...
08:41:14 <rwbarton> oh, right. it is just a natural transformation between the two functors End(C) to Set: F |-> Hom(X, FY), F |-> Hom(Z, FW)
08:41:22 <maukd> > generalCategory '\x2062'
08:41:23 <lambdabot>   Format
08:41:49 <maukd> > let (⁢) = () in ()
08:41:50 <lambdabot>   <no location info>: lexical error at character '\8290'
08:51:25 <hpaste> “Ben Gamari” pasted “MPTC difficulty” at http://hpaste.org/75377
08:51:52 <lgandras> has someone had to work with thrift lately?
08:51:53 <hpaste> “Ben Gamari” annotated “MPTC difficulty” with “MPTC difficulty (errors)” at http://hpaste.org/75377#a75378
08:52:19 <bgamari> I seem to have some misunderstanding regarding MPTCs
08:52:24 <lgandras> does someone know how to create an IO function in the .thrift file?
08:52:49 <c_wraith> bgamari: what's to not understand?  They're type classes with multiple parameters. :)
08:53:00 <bgamari> c_wraith, See above hpastes
08:53:09 <c_wraith> bgamari: I joined after them
08:53:12 <rwbarton> bgamari, on line 19 looks like modelState should be ms
08:53:13 <bgamari> c_wraith, The errors in the annotation, namely
08:53:43 <bgamari> rwbarton, Doh! Thanks
08:53:44 <lgandras> no one on thrift?
08:53:56 <hirsch_> How can I rewite this as a oneliner with >>= without lambdas? Is there a combinator for this?            zipErrs = do e <- genErrors
08:53:56 <hirsch_>                          return  (zip [0..] e)
08:54:19 <maukd> @undo zipErrs = do e <- genErrors; return (zip [0 ..] e)
08:54:19 <lambdabot> zipErrs = genErrors >>= \ e -> return (zip [0 ..] e)
08:54:25 <maukd> @. pl undo zipErrs = do e <- genErrors; return (zip [0 ..] e)
08:54:25 <lambdabot> zipErrs = zip [0..] `fmap` genErrors
08:54:36 <rwbarton> @botsnack
08:54:36 <lambdabot> :)
08:54:55 <hirsch_> cool
08:54:57 <bgamari> rwbarton, The other question is how do I get WrappedUpdateUnit to be an instance of UpdateUnit?
08:54:59 <maukd> @batsnock
08:54:59 <lambdabot> :)
08:55:16 <tromp> @batshit
08:55:17 <lambdabot> Unknown command, try @list
08:55:18 <bgamari> I need to be able to construct a list of UpdateUnits ms sharing the same ms
08:55:40 <rwbarton> hmm
08:55:50 <bgamari> but seeing as the compiler is warning me about lacking default implementations in my instance on line 17, I'm assuming the current approach isn't going to work
08:55:53 <rwbarton> looks a little tricky
08:56:07 <rwbarton> maybe something like
08:56:38 <rwbarton> oh wait
08:56:52 <rwbarton> ah okay
08:56:59 <rwbarton> forgot how to read non-GADT syntax for a moment there :)
08:57:17 <bgamari> I'm afraid that Setting might give me difficulties
08:57:26 <rwbarton> yes that is what I am trying to work out
08:58:09 <rwbarton> if it didn't have that type parameter uu this might be easier
08:58:33 <Cale> rwbarton: ah, almost missed your comment above, yes!
08:59:07 <bgamari> rwbarton, I've been struggling to figure out how to express the UpdateUnit (uu) notion
08:59:41 <rwbarton> I guess the instance is going to look like "type Setting (WrappedUpdateUnit ms) = ..."
08:59:41 <bgamari> rwbarton, Perhaps the current approach is suboptimal
08:59:44 <rwbarton> right?
08:59:50 <bgamari> yes
09:00:01 <carpi> i finally know what a functor is .. er.. or i think i do. onwards .. _____? can someone fill in the blank for me? P
09:00:19 <maukd> carpi: do you understand monoids?
09:00:20 <bgamari> the problem is I don't know what to put on the right hand side as the underlying type being wrapped is already hidden from me
09:00:28 <rwbarton> data WrappedSetting ms = forall uu. UpdateUnit uu ms => WrappedSetting (Setting uu) -- maybe?
09:01:02 <carpi> maukd: not yet. so onward to monoids..
09:01:10 <maukd> monoids are simpler than functors
09:01:35 <maukd> carpi: I think you disconnected in the middle of my explanation earlier. did you get any of that?
09:01:36 <carpi> can't be. the name 'monoid' sounds scary
09:02:02 <carpi> didn't disconnect.. i got disconnected. patchy internet connection here : (
09:02:11 <maukd> yes, that's what I meant :-)
09:02:45 <bgamari> rwbarton, hmm, I'm beginning to think this just isn't going to work
09:03:45 <maukd> carpi: so ... do you want me to repeat what I said earlier?
09:04:02 <carpi> so functors are a way to abstract the idea of applying a function to every element in a concrete type. and a one line description for monoid would be?
09:04:18 <carpi> oh thanks.. but no need to repeat. just give me a gist of it so i can go on and figure it out myself :)
09:04:24 <rwbarton> bgamari, I am thinking so too especially because ms is not a parameter of Setting
09:04:36 <maukd> gisting is harder
09:04:51 <maukd> carpi: a monoid is a set with a special "neutral" element and an operation that combines two elements into a third
09:04:53 <rwbarton> hmm
09:05:02 <bgamari> rwbarton, An UpdateUnit is a group a random variables, the values of which are of type (Setting uu). The current value of this unit can be retrieved and set in a ModelState
09:05:08 <maukd> carpi: e.g. natural numbers are a monoid with 0 and +
09:05:14 <bgamari> that is the gist of the object
09:05:22 <bgamari> I'm not really sure how to express that, however
09:05:23 <maukd> oh yeah, the operation has to be associative: (a + b) + c = a + (b + c)
09:05:35 <maukd> and x + 0 = 0 + x = x
09:05:35 <carpi> monoid rule eh
09:05:52 <maukd> if you use * as the operation, you get another monoid (with neutral element 1)
09:06:05 <maukd> strings are also a monoid: (++) combines two of them, and "" is neutral
09:06:06 <bgamari> rwbarton, I could have multiple update units which inhabit the same model (e.g. have the same ModelState), yet different Settings
09:06:12 <bgamari> I want to construct lists of these
09:06:36 <maukd> and that's pretty much all there is to monoids
09:07:03 <carpi> so its  a way of abstracting the idea of combining an element and an operation to get another element?
09:07:21 <nand`> sets are also monoids; ∪ and ∅
09:07:43 <maukd> I don't know if it's abstracting anything
09:08:23 <carpi> isn't that what all typeclasses do ... abstracting a notion of 'something' ? )
09:08:27 <maukd> monoids are pretty dumb. they have an associative operation and a neutral element, and that's it
09:08:36 <maukd> there's not much meat here
09:08:44 <hiptobecubic> Is there a monoid typeclass that isn't based on monads? Or is that a nonsensical question
09:08:49 <maukd> that's why there are so many different monoids
09:08:49 <nand`> sure monoids are abstracting something
09:08:52 <Cale> Yeah, monoids are an abstraction
09:09:26 <nand`> they're abstracting the property of ‘having an associative operation with an identity’
09:09:47 <maukd> that's pretty abstract itself
09:09:55 <Cale> carpi: "The idea of combining two elements to get another element, in such a way that there is an identity, and the combining operation is associative"
09:09:56 <hiptobecubic> i always thought of them as 'mergables'
09:10:06 <hiptobecubic> mergeables ?
09:10:18 <centrinia> Semigroups with identity.
09:10:27 <Cale> I talk about a really nice example in this reddit post...
09:10:32 <Cale> Let me find it :)
09:10:32 <edwardk> Functional programming wins, flawless victory: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3449.pdf
09:10:33 <nand`> I personally think it saner to explain semigroups first
09:10:55 <maukd> nand`: why not magmas?
09:11:01 <nand`> maukd: that's where I was getting
09:11:08 <nand`> I meant ‘before monoids’
09:11:16 <nand`> not ‘first of all’
09:11:26 <Cale> http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx
09:12:34 <quicksilver> edwardk: fatality?
09:12:48 <bgamari> rwbarton, Ideas?
09:13:25 <nand`> edwardk: I don't get it. It's just a C++ thing?
09:13:26 <edwardk> just never thought i'd see the day where bjarne stroustrup would be shilling for pattern matching ;)
09:13:39 <rwbarton> bgamari: I am trying something and am confused why it doesn't compile
09:13:44 <Cale> It's so cute that they consider case expressions to be a polytypic operation
09:13:51 <edwardk> cale: =)
09:13:54 <bgamari> rwbarton, Ahh, thank you very much
09:14:51 <Cale> edwardk: OO programmers are so limited when it comes to colimits
09:15:30 <hpaste> rwbarton annotated “MPTC difficulty” with “MPTC difficulty (errors) (annotation)” at http://hpaste.org/75377#a75379
09:17:06 <rwbarton> why doesn't that work?
09:17:17 <maukd> carpi: but if you want to take the next step past Functor, that would be Applicative
09:18:11 <carpi> going thru Cale's reddit post
09:19:35 <edwardk> i really want to see the haskell benchmarks they used, since i'd be curious to see if they were appropriately strictness annotated
09:19:44 <rwbarton> I mean, where is the type variable "uu0" even coming from
09:20:12 <bgamari> Yeah, I actually don't know
09:20:25 <rwbarton> ohh
09:20:25 <maukd> rwbarton: that part is clear
09:20:34 <maukd> but I don't understand the bigger picture
09:20:34 <rwbarton> i see
09:20:34 <bgamari> I do wish GHC would be a bit more expressive about wheretype variables were introduced
09:20:45 <edwardk> instance UpdateUnit (WrappedUpdateUnit ms) ms where  -- already sets off red flags for me
09:20:58 <rwbarton> it doesn't know it's supposed to pack a dictionary for uu rather than some other uu0 with Setting uu0 = Setting uu
09:20:59 <edwardk> because you have an MPTC without a fundep but you only refined one side
09:21:21 <edwardk> so there can now never be any other instances that don't overlap that refine the right hand side
09:21:43 <edwardk> this is usually a sign that you should have at least one fundep in there from the first arg to the second
09:21:51 <rwbarton> they just have to be instances for a different constructor on the left
09:21:54 <edwardk> class UpdateUnit uu ms | uu -> ms where
09:22:07 <rwbarton> but yes, possibly a fundep is wanted. this isn't mine originally
09:22:09 <bgamari> that is true, uu should determine ms
09:23:12 <Cale> Possibly another associated type would work better too
09:23:27 <bgamari> I originally started with ModelState being an associated type
09:23:32 <nevrenato> Hi all. can someone explain me why this code (http://piratepad.net/sdHCwwIqW8) gives me error ?
09:24:03 <bgamari> but I moved it to a type parameter so I could construct WrappedUpdateUnit
09:24:21 <hpaste> rwbarton annotated “MPTC difficulty” with “"fixed"” at http://hpaste.org/75377#a75380
09:24:22 <hpaste> Cale pasted “nevrenato's paste” at http://hpaste.org/75381
09:24:49 <Cale> nevrenato: Sorry, I didn't want to read that in a non-fixed-width typeface in which l and | were similar :)
09:24:56 <nevrenato> np :)
09:25:07 <bgamari> Would it be more natural to phrase ModelState as an associated type?
09:25:07 <rwbarton> you could write data WrappedUpdateUnit ms = forall uu. (UpdateUnit uu, ModelState uu ~ ms) => ...
09:25:08 <nevrenato> in fact i prefer this way
09:25:27 <maukd> I don't see how the instance in line 11 is even valid
09:25:30 <bgamari> Ahh, I forgot about type-level equality
09:27:22 <rwbarton> updateSetting looks like trouble though, if I do this existential wrapping how will I know that the types of those first three parameters match up
09:27:24 <Cale> nevrenato: I'm genuinely surprised it accepts the instance (Show b) => Logic Hybrid [b]
09:27:53 <nevrenato> Cale: Why shouldn't ?
09:27:57 <Cale> nevrenato: since that kinda blatantly contradicts the functional dependency for the typeclass
09:28:12 <Cale> nevrenato: You said that l -> b
09:28:27 <bgamari> rwbarton, hmm, yeah, that could be problematic
09:28:32 <Cale> which means that for any given type l, there should be at most one type b such that Logic l b holds
09:28:50 <n-dolio> Cale: That's pretty well known nonsense.
09:28:55 <bgamari> and here I was thinking the case of heterogeneous update units would be easy
09:28:56 <nevrenato> Cale: yeah, I thought that way too, but undecidable instances bypassed that
09:28:58 <n-dolio> Someone was even arguing a while back that it's sensible behavior.
09:28:59 <quicksilver> Cale: perhaps forall b . [b] counts as "one type" ?
09:29:00 <rwbarton> Cale: I remember a thread on some Haskell mailing list that was divided between people who thought an instance like that was "obviously okay" and people who thought it was "obviously nonsense"
09:29:17 <Cale> rwbarton: I think it's BS, and the compiler should not accept it
09:29:33 <quicksilver> if only functional dependencies were actually specified somewhere we might know :)
09:29:36 <Cale> even in the face of UndecidableInstances, that contradicts the fundep
09:29:57 <rwbarton> Cale: That's what I thought too of course but the other side was equally convinced that they were obviously right.
09:30:28 <Cale> The other side in this case obviously doesn't understand what functional dependencies are?
09:30:29 <rwbarton> It might just have been one guy
09:30:40 <rwbarton> well, he had the weight of GHC on his side :)
09:30:49 <n-dolio> rwbarton: It's an okay instance in that it doesn't cause any problems the way fundeps are implemented. Except they shouldn't be called functional dependencies in that case.
09:31:26 <n-dolio> Also it completely breaks if you implement fundeps more like type families.
09:31:28 <nevrenato> Cale : I'm a noob in this…but since i don't have another instance violating that fundep, it should pass ?
09:31:49 <Cale> nevrenato: That's probably why GHC accepts it, but it's really broken.
09:32:20 <rwbarton> nevrenato: already you have instances Logic Hybrid [Bool] and Logic Hybrid [Int] (among many others)
09:32:21 <maukd> nevrenato: what do you mean, you don't have another instance? you don't have even one instance
09:32:22 <Cale> nevrenato: The whole point of the functional dependency l -> b is that if you know exactly what the type l is, then you should know exactly what the type b is.
09:32:24 <maukd> which is the whole problem
09:33:38 <Cale> nevrenato: You defined a polymorphic instance which implicitly constructs infinitely many instances of which rwbarton listed two
09:34:12 <nevrenato> Cale : yes i agree with you…But i think we are thinking in a wrong way ? …since it valid code
09:34:21 <rwbarton> n-dolio: so what would be a more accurate formulation, "the types b for which Logic l b holds are all specializations of some single type expression with free variables"?
09:34:37 <Cale> nevrenato: It ought not to be valid to write that instance in the presence of the functional dependency l -> b.
09:34:41 <rwbarton> accurate meaning what GHC implements
09:34:54 <Cale> nevrenato: I'm going to consider it a bug in GHC that the compiler accepts that instance in the first place.
09:35:01 <quicksilver> well I'm sure you can construct some formulation "There is one *natural* family of types b and parametricity guarantees the implementation of the instance is natural"
09:35:04 <n-dolio> rwbarton: The guy who was arguing for it said that 'a -> b' means there is only ever one instance declaration for any particular 'a'.
09:35:05 <rwbarton> (by "are all specializations" I mean "are exactly all the specializations")
09:35:09 <quicksilver> ...for a specific l.
09:35:32 <nevrenato> and if we consider [a] as a type ?
09:35:38 <quicksilver> the important questions are (1) is that what fundeps are really intended to be and (2) even if not, is it in some way useful?
09:35:47 <n-dolio> Which is an interpretation of what is actually implemented, but that's not really a functional dependency.
09:36:03 <rwbarton> doesn't that get tricky also given that an instance head might have free variables in 'a'?
09:36:05 <quicksilver> I'm not immediately seeing how it's useful :)
09:36:09 <Cale> nevrenato: but [a] isn't a type on its own, because it has a free type variable in it.  forall a. [a] is a type, but it's not a terribly useful one
09:36:42 <rwbarton> e.g. class X a b | a -> b; instance X a a; instance X [a] a  isn't okay
09:36:46 <Cale> nevrenato: usually when you write a type signature with variables in it, all the variables are implicitly forall'ed at the start of the type signature
09:37:04 <Puffton> what is the difference between [Char] and String in Haskell?
09:37:13 <bgamari> Puffton, There is none
09:37:16 <Puffton> if I return "hello" it says [Char] although I would like it to be string
09:37:26 <Cale> Puffton: type String = [Char]
09:37:30 <bgamari> Puffton, they are synonyms
09:37:44 <n-dolio> rwbarton: That's probably accepted as long as you have overlapping instances.
09:37:46 <rwbarton> you can pretend it says String
09:38:09 <Cale> nevrenato: but okay, it *does* accept this instance
09:38:11 <bgamari> rwbarton, Any advice for dealing with this heterogeneous update unit issue?
09:38:15 <n-dolio> rwbarton: The key is that GHC doesn't really let you reason from (X a b, X a c) to b ~ c.
09:38:22 <n-dolio> So it works out okay.
09:38:25 <Cale> nevrenato: and then you immediately run into a problem because the functional dependency is violated
09:38:31 <bgamari> ScopedTypedVariables seems to raise alarm with me for some reason
09:38:43 <bgamari> ScopedTypeVariables*
09:38:43 <n-dolio> Except that's just a quirk.
09:38:53 <nevrenato> if i remove the Show constraint in line 11 compiler passes
09:38:59 <bgamari> It seems like there really should be a nice way to do this
09:39:10 <Cale> nevrenato: it's saying "Oops! I don't know what type b is in this Show b constraint which was generated when I applied the instance (Show b) => Logic Hybrid [b]!"
09:39:27 <Cale> nevrenato: and so it can't decide if that Show constraint holds or not
09:39:40 <bgamari> rwbarton, Strictly speaking I could eliminate the first ModelState argument from update
09:39:43 <Cale> nevrenato: and it *must* hold in order for the list to be well-typed
09:39:43 <nevrenato> Cale : ooh ok thx :)
09:39:51 <bgamari> rwbarton, I just throw it out anyways
09:40:03 <bgamari> but it still bothers me that I need ScopedTypeVariables
09:40:16 <bgamari> but maybe it shouldn't
09:40:24 <rwbarton> you can usually (always?) work around ScopedTypeVariables, I was just too lazy to do so
09:40:27 <Cale> nevrenato: If the functional dependency hadn't been violated, then instead of b, some specific, known type would be there
09:40:36 <Cale> nevrenato: and there would be no problem like that
09:40:43 <rwbarton> for example instead of Proxy uu you can add a field of type uu and store (undefined `asTypeOf` uu)
09:40:55 <rwbarton> or you could store uu if you like even
09:40:58 <Cale> (it would be able to look and see if it finds a Show instance, and either complain or accept it)
09:40:58 <rwbarton> I guess
09:42:32 <Cale> A word of warning about ScopedTypeVariables is that ScopedTypeVariables + PolyKinds = Death in 7.4.1 -- I don't know about newer GHCs
09:42:57 <nevrenato> Cale : wow, Ghc is seeming to me a little bugged
09:43:26 <rwbarton> n-dolio: I see, it just lets me reason from (X a b) and {- the unique instance in scope for X a e -} to {- unify b with e -}?
09:43:26 <Cale> nevrenato: Once you get into the subtle interactions between some of these type system extensions, there can be some funny behaviours.
09:43:29 <rwbarton> more or less
09:44:03 <Cale> Ah, the ScopedTypeVariables/PolyKinds bug I mentioned was fixed in 7.6.1
09:44:06 <nevrenato> Cale : yeah UndecidableInstances is what does the trick for passing the "violated" fundep
09:44:21 <Guest4912> hi
09:45:01 <nevrenato> Cale : Im trying to think of a way why this happens…My only idea is that ghc is considering [b] a concrete type
09:45:21 <Cale> nevrenato: I guess UndecidableInstances is an extension that they figure if you turn it on, you're kind of saying "I know what I'm doing"
09:45:34 <Guest4912> hi cale
09:45:36 <Cale> hi
09:45:41 <rwbarton> I think UndecidableInstances is just needed because of that (Show b) constraint, right?
09:45:58 <Guest4912> what time is it there?
09:46:03 <Cale> 12:45
09:46:08 <Guest4912> pm?
09:46:12 <nevrenato> rwbarton: No, it's used to not violate fundep
09:46:18 <rwbarton> that doesn't make any sense
09:46:24 <rwbarton> not saying it is not true :)
09:46:38 <nevrenato> rwbarton: Or at least to compiler says that it doesn't violate
09:46:50 <rwbarton> huh
09:46:52 <Cale> nevrenato: Normally UndecidableInstances isn't intended to let you violate fundeps
09:47:18 <nevrenato> Cale : Yes, i have an idea of undecidableinstances and the no termination problem
09:47:22 <rwbarton> it sure does have that effect though
09:47:44 <nevrenato> But the compiler suggested that  i used the undecidableinstances, for the fundep problem !!
09:47:45 <rwbarton> Illegal instance declaration for `Logic Hybrid [b]' (the Coverage Condition fails for one of the functional dependencies; Use -XUndecidableInstances to permit this)
09:48:18 <nevrenato> wow mine doesn't give error
09:48:20 <rwbarton> that is without (Show b) =>
09:48:24 <nevrenato> are you using ghc or ghci ?
09:48:25 <rwbarton> and without UndecidableInstances
09:48:30 <nevrenato> aah ok
09:48:47 <nevrenato> then all good
09:49:48 <monochrom> there is a reason it is a compiler suggestion, not a compiler automation
09:49:49 <nevrenato> I'm really confused about this
09:49:59 <Cale> http://hackage.haskell.org/trac/ghc/ticket/1241
09:50:50 <jfischoff> If I would like to "return early" from monadic code, without creating a bunch of deeply nested if/case blocks what are my options? In my ideal world I could use something like when' :: Monad m => Bool -> m a -> m a.
09:51:17 <Cale> jfischoff: That's what continuation monads give you
09:51:25 <jfischoff> ah
09:51:32 <Cale> jfischoff: (well, that, plus a bunch of other control stuff)
09:51:52 <jfischoff> Cale: are you aware of good example to start with?
09:52:02 <monochrom> you can define when'
09:52:07 <Cale> But you can imagine that in your favourite standard imperative programming language, every function definition has been secretly wrapped in  callCC $ \ret -> ...
09:52:25 <Cale> and when you use the return keyword, like  return v
09:52:33 <Cale> it does  ret v  instead
09:52:38 <noviceprogrammer> hello
09:52:58 <monochrom> also for-loop and "break"
09:53:03 <Cale> right :)
09:53:11 <monochrom> ironically, "continue" does not continue :)
09:53:20 <jfischoff> okay yeah
09:53:37 <pnielsen> monochrom: continue continues to the next "stage" of the loop
09:53:48 <nevrenato> Cale : awesome, it's seems exactly this case
09:53:48 <pnielsen> monochrom: rather than 'break'ing
09:53:57 <Cale> jfischoff: So you can locally wrap things in ContT to get funny breakout effects like that
09:54:10 <pnielsen> monochrom: oh, sorry, wrong channel. Thought you were talking about C
09:54:24 * monochrom writes all his Cont/ContT use cases as: callCC (\continue -> ...)
09:54:29 <jfischoff> Cale: is it worth it? does it overly complicate things?
09:54:48 * monochrom writes all his monad use cases as "... return x" anyway!
09:54:53 <Cale> jfischoff: But usually I find that branching explicitly is nicer. Something about the property that a chunk of code either doesn't terminate or runs completely is nice.
09:55:39 <Cale> jfischoff: There have been imperative programmers who were vehemently opposed to the ability to stick "return" in the middle of a block of code.
09:55:51 * jfischoff nods
09:56:09 <rwbarton> can't you just use Maybe/Either/etc. for this?
09:56:14 <Cale> (Hoare maybe? I forget who, but some famous ones.)
09:56:33 <monochrom> pnielsen: the dilemma is this. I decide to invoke a continuation given to me. I can say "continue" for that, right? but that continuation takes me out of the loop, not to the next iteration.
09:56:34 <jfischoff> My issue with continuing is I am accumulating warnings
09:56:40 * nand` starts all of his procedures with ‘return’ and a linebreak
09:56:51 <jfischoff> which are duplicates
09:57:21 * hackagebot secure-sockets 1.2.8 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.8 (IavorDiatchki)
09:57:23 * hackagebot fb 0.12.5 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12.5 (FelipeLessa)
09:58:00 <Cale> jfischoff: Maybe there's another way to factor them out?
09:59:07 <Cale> monochrom: What if you put the callCC $ \continue -> ... just on the inside of the loop?
09:59:51 <Cale> callCC $ \break -> forM xs $ \x -> callCC $ \continue -> ...
09:59:56 <pnielsen> monochrom: yeah
10:00:05 <n-dolio> rwbarton: I don't think it even lets you do that, locally.
10:00:17 <jfischoff> Cale: I could definitely .log the warnings at the end of the function, but I think that would require some duplication of code. (some tests for control, the same tests for logging)
10:00:43 <Cale> jfischoff: Paste your code?
10:00:44 <monochrom> then I will write callCC (\return -> forM_ xs (\x -> callCC (\break -> ...))) just to confound you! :)
10:01:08 <bgamari> arg
10:01:34 <applicative> noviceprogrammer: hi
10:01:50 <bgamari> rwbarton, The issue with adding a uu type argument to WrappedSetting is that I don't have anything to seed it with in the definition of the Setting associated type in the UpdateUnit instance
10:02:04 <pnielsen> monochrom, Cale: speaking as somebody who's used C-style languages forever and functional languages only recently, the fact that there's no "imperative continue/break/return" (or at least that it's not common) really helps in quickly understanding what something does, although it does mean you have several more layers of indentation in general. Programming Haskell with 8-space indents would be pretty annoying, I imagine
10:02:13 <monochrom> . o O ( let h be a group, G be a homomorphism h->h, J be an element of G...)
10:02:17 <rwbarton> bgamari: yeah, semantically there shouldn't be one. hence use of undefined or Proxy
10:02:19 <pnielsen> monochrom, Cale: that and type signatures
10:02:22 <Cale> pnielsen: I totally agree :)
10:02:49 <rwbarton> I think because of that last method you just can't make WrappedUpdateUnit be an instance of UpdateUnit though
10:02:53 <Cale> pnielsen: I almost can't tolerate reading imperative code with early returns anymore
10:02:57 <jfischoff> Cale: pasting, but the code doesn't compile, its just a sketch so to speak
10:03:03 <n-dolio> rwbarton: I think all it does is: If type inference yields X T b => ..., and there is an instance X T E in scope, it may discharge the constraint with b := E.
10:03:03 <Cale> jfischoff: okay
10:03:11 <monochrom> well, it's the same reason why Dijkstra disuades you from goto
10:03:50 <Philippa> because tail-calling is much better!...
10:04:05 <pnielsen> Cale: yep. Haskell sucks like that: It'll make you pissed off at the languages you're forced to use professionally
10:04:06 <Philippa> (yes, yes it is, but maybe I'm gettin' cranky in my old age)
10:04:21 <Cale> Philippa: Of course, at least tail calling is still equational :)
10:04:49 <rwbarton> what is so bad about "... if (argc != 2) return 1; f = fopen(argv[1], "r"); if (f == NULL) return 2; ..."
10:04:58 <Philippa> what, you mean the 0-parm case behaves oddly if you expect it to do something useful?...
10:05:00 <rwbarton> add error messages if you like
10:05:17 <hpaste> “Jonathan Fischoff” pasted “Control Flow” at http://hpaste.org/75382
10:05:24 <Cale> pnielsen: I'm presently fixing bugs in a groovy/grails web application backend that we're shortly going to replace completely with Haskell, because it's very nearly unmaintainable.
10:05:24 <jfischoff> Cale: ^
10:05:34 <n-dolio> rwbarton: But it is all about that kind of discharge. Aiding the inference. Not about local refinement based on known information.
10:05:35 <pnielsen> Cale: awesome
10:05:41 <Philippa> rwbarton: lots. But nothing a pile of local functions can't fix
10:05:41 <pnielsen> Cale: well, the latter part
10:05:57 <rwbarton> that will just make your code a lot uglier for no reason
10:06:04 <jfischoff> Cale: ideally I would like to return an empty button after most of the warnings
10:06:57 <Philippa> rwbarton: MMV, I consider the C fugly if I'm trying to get the gist of what happens quickly
10:07:04 <Philippa> sure, I'm out of practice. But needing practice is the point
10:07:17 <monochrom> the general phenomenon seems to be that the denotational semantics way keeps your sanity. by denotational semantics I mean: the mapping from code to your mental model is simply defined by structural recursion over syntax. so, you see why it's pretty modular and helps your sanity
10:07:46 <Cale> jfischoff: You're in IO, right?
10:08:00 <jfischoff> Cale: No
10:08:08 <jfischoff> But I could be
10:08:18 <jfischoff> I haven't implemented the monad I am in yet
10:08:23 <Cale> ah, okay
10:08:24 <n-dolio> rwbarton: For instance, someone asked on haskell-cafe recently... class X a b | a -> b ; instance X Int Float ; f :: X Int a => Int -> a ; f = undefined ; g :: X Int a => Int -> a ; g = f
10:08:37 <n-dolio> rwbarton: f ends up with type Int -> Float. g is a type error.
10:08:38 <pnielsen> monochrom: that's definitely my experience with FP. Tons of headaches at first, lots of making sense vs. imperative languages after that
10:08:45 <Cale> Well, I was thinking, you could throw an exception and just catch it to print the message and return Nothing
10:08:54 <jfischoff> Cale: Yeah I thought about that
10:08:56 <Cale> which is quite similar
10:09:29 <jfischoff> well I can't just print the message. The messages are collected and filtered by a config
10:10:03 <Cale> well, okay, whatever you've got to do with the message :)
10:10:04 <Sculptor> hi!
10:10:08 <jfischoff> but that doesn't change you point :)
10:10:23 <noviceprogrammer> why is the Haskell Int guaranteed about +/- 2^29 rather than +/- 2^31?
10:10:29 <noviceprogrammer> as in C*
10:10:39 <jfischoff> Cale: honestly this is the worse function I will have
10:10:52 <Cale> noviceprogrammer: Because maybe some hypothetical implementation will want to use those two extra bits for something else.
10:11:01 <applicative> > maxBound :: Int
10:11:02 <lambdabot>   9223372036854775807
10:11:09 <noviceprogrammer> right
10:11:12 <monochrom> because C lacks GC and lacks polymorphism. to implement each, you may want to steal a bit for tagging
10:11:14 <applicative> > 2^29 :: Int
10:11:15 <lambdabot>   536870912
10:11:31 <noviceprogrammer> ah interesting ^^
10:11:31 <jfischoff> Cale: I think I'm going to just spew extra warnings…for now
10:11:57 <rwbarton> n-dolio: Bleh. Good example
10:11:58 <Cale> noviceprogrammer: In particular, on many architectures, pointers to values are aligned, and so by sticking a '1' bit in that position, one could tell that this is not a pointer (to code for producing an Int), but an honest Int
10:12:22 * hackagebot HTF 0.8.2.2 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.8.2.2 (DavidLeuschner)
10:12:26 <noviceprogrammer> right
10:12:30 <monochrom> now, GHC gives you full +/- 2^31 for Int, on a 32-bit version. how it is done: use 64 bits for every 32-bit Int
10:12:33 <n-dolio> rwbarton: So, locally we don't know that a ~ Float, but 'globally' we do, somehow.
10:12:34 <Cale> monochrom got it even better :)
10:13:08 <noviceprogrammer> thanks guys
10:13:10 <monochrom> and similarly use 128 bits for every 64-bit Int on a 64-bit version
10:13:41 <noviceprogrammer> wow 128-bit types... C doesn't even have those ^^
10:14:09 <monochrom> one day, it will
10:14:12 <rwbarton> monochrom didn't say anything about 128-bit types
10:14:23 <Cale> C has fixed-size array types, doesn't it?
10:14:32 <noviceprogrammer> right
10:14:33 <monochrom> when I was playing with Turbo C, we barely talked about 16-bit numbers
10:15:24 <Cale> monochrom: and if you were playing with C today, you'd also barely talk about 16 bit numbers :)
10:15:40 <Cale> (I'd guess)
10:16:11 <monochrom> I miss segment prefix registers!
10:17:05 <edwardk> hrmm looks like after my comment Mike Stay decided to take down the latest jquery is a monad shpiel.
10:17:14 <lightquake> jquery is a monad? wat
10:17:42 <Cale> jquery is a monad on what category?
10:17:52 <Cale> lol
10:18:24 <pnielsen> it's simple, it's just a monoid in the category of endofunctors
10:18:34 <pnielsen> what's the problem?
10:18:56 <noviceprogrammer> so Haskell is a great language for general application development?
10:19:19 <pnielsen> noviceprogrammer: yes, but especially great for anything where you're not just concatenating strings, i.e. most web development
10:19:27 <zomg> noviceprogrammer: Haskell is great for everything
10:19:28 <Cale> HAY GUYS I HEARD FROM BRIAN BECKMAN THAT A MONAD IS JUST LIKE CLOCK ARITHMETIC AMIRITE?
10:19:29 <noviceprogrammer> ah
10:19:29 <zomg> =)
10:19:30 <pnielsen> but even that it's pretty good at compared to Python
10:19:58 <noviceprogrammer> Im a little shy to move on from C and C++
10:20:04 <zomg> Cale: btw sorted out the segfault.. certificate-1.2.6 -> 1.2.8 solved it, and there's almost no difference between the versions. Yeah, makes no sense, but...
10:20:14 <Cale> zomg: interesting
10:20:20 <zomg> pnielsen: I use Yesod for web dev, it's rather neat =)
10:20:34 <nand`> there are a number of haskell web frameworks
10:20:51 <Cale> noviceprogrammer: I think it's a hell of a lot better for general application development than C and C++ are, at least. :)
10:22:15 <pnielsen> zomg: yeah, I've used Yesod and Snap. Like both. Definitely not a bad choice for web development, just that the competition doesn't have much on it (and its siblings) when you're actually doing something
10:23:14 <Polarina> noviceprogrammer, you don't have to "move on" from anything. You can continue to use them alongside with Haskell.
10:23:33 <nand`> the question is, will you want to?
10:23:55 <zomg> ^ you will grudginly think "this would be so much simpler in haskell" all the time
10:24:00 <derrida> I don't know many polyglots that miss C++ <shrug>
10:24:31 * Polarina never misses C++.
10:24:37 <derrida> just have to get over that hump of being out of comfort zone, then bliss ensues.
10:24:39 <zomg> derrida: I do php for my day job :P
10:24:43 <derrida> eek
10:24:45 * sopvop can't use c++ anymore. And python is hard.
10:25:04 <zomg> It's not bad when I'm the only programmer on the project, I can somewhat make sure things aren't completely shitting all over the place
10:25:07 <zomg> but it could be better
10:25:07 <zomg> =)
10:25:51 <sopvop> zomg: my sincerest condolences. php should just die in fire.
10:25:52 <nand`> the only language I would begrudgingly accept being forced into for work purposes would have to be C#.NET, simply because I have experience with hacking whatever useful things I need into it
10:25:59 <hpaste> bartavelle pasted “type question” at http://hpaste.org/75383
10:26:01 <zomg> sopvop: lol =)
10:26:08 <nand`> I wonder if zomg should be classifier as an enabler
10:26:08 <bartavelle> I have a type question with that paste
10:26:27 <zomg> when you've been doing it as long as I have you sort of know ways to deal with it so it doesn't get so much on your nerves
10:26:30 <zomg> :p
10:26:32 <Cale> bartavelle: ask away
10:26:41 <bartavelle> as you can see, I would like to be able to resolve the lua types to my own types
10:26:48 <bartavelle> the problem is that sometimes I want to get
10:26:56 <bartavelle> a Map.Map String ResolvedValue
10:26:59 <bartavelle> hummm
10:27:02 <bartavelle> just realized something
10:27:03 <bartavelle> brb
10:27:34 <pnielsen> bartavelle: that's the best kind of question :)
10:27:38 <bartavelle> ;)
10:28:40 <bartavelle> I believe it is a bug with the hslua library, when you expect a string but you were returned a number
10:28:49 <bartavelle> it doesn't automagically convert it
10:28:53 <bartavelle> well probably not a bug
10:29:00 <bartavelle> just something you should know
10:29:05 <bartavelle> results in a nasty panic
10:29:38 <bartavelle> not sure how to handle this :(
10:32:22 * hackagebot hs-bibutils 4.14 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-4.14 (AndreaRossato)
10:32:24 * hackagebot secure-sockets 1.2.9 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.9 (IavorDiatchki)
10:32:26 * hackagebot secure-sockets 1.2.9.1 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.9.1 (IavorDiatchki)
10:34:09 <Polarina> bartavelle, doesn't the binding have facilities to attemt to convert a string to a number?
10:34:14 <Cale> bartavelle: It doesn't tell you the dynamic type of the thing? I don't really know anything about the binding (and am only vaguely familiar with Lua)
10:35:04 <bartavelle> Polarina, doesn't seems so, I am experimenting
10:35:19 <bartavelle> Cale, I am relying on the instance of Lua.StackValue for string
10:35:28 <bartavelle> I suspect it throws the error when it sees a number
10:35:34 <bartavelle> this is not my code
10:35:40 <bartavelle> I could do it manually however
10:36:00 <bartavelle> but as I am more or less bruteforcing the lua stack until it does what I want, I'd rather use somebody else's code
10:36:37 <Cale> huh
10:37:12 <bartavelle> the problem is that I wrote this : instance (Lua.StackValue a, Lua.StackValue b, Ord a) => Lua.StackValue (Map.Map a b)
10:37:19 <bartavelle> I wondered why it wasn't provided
10:37:24 <bartavelle> as in lua lists and maps are the same thing
10:37:30 <bartavelle> and the instance for [] was
10:37:34 <bartavelle> I suspect this is related
10:38:14 <ClaudiusMaximus> bartavelle: here's my hslua work, no time to help and might be too much code to make sense, may also have bitrotted https://gitorious.org/maximus/mandulia/blobs/master/src/Interface.hs
10:38:15 <Cale> bartavelle: I don't see an instance of StackValue for lists here...
10:38:29 <bartavelle> it's in luautils
10:38:40 <bartavelle> thanks claudius, looking at it
10:39:14 <bartavelle> god you are not afraid of that lua interface
10:40:07 <bartavelle> Cale, problem is fixed, instead of asking for a Map.Map String ResolvedValue, I get a Map.Map ResolvedValue ResolvedValue  and convert the keys to strings with my functions
10:40:14 <ClaudiusMaximus> bartavelle: you probably want to look at https://gitorious.org/maximus/mandulia/blobs/master/src/Interface.hs#line171
10:40:21 <ClaudiusMaximus> bartavelle: ah problem fixed, cool
10:40:37 <bartavelle> yes, but not nicely
10:40:47 <bartavelle> I will propose a patch to the hslua module later
10:40:51 <ClaudiusMaximus> plenty of scope for collisions/nondeterminism
10:41:24 <ClaudiusMaximus> dinner time, bbl
10:41:34 <bartavelle> is that possible that the Lua binding can throw exceptions that can't be catched by my program ?
10:41:51 <bartavelle> I suppose it is, as it can just call exit()
10:42:08 <Cale> I'm a little surprised there isn't a LuaValue type which just reflects all Lua datastructures. Lua doesn't even have a very rich typesystem does it?
10:42:27 <bartavelle> Cale, I agree this is extremelly surprising
10:51:08 <mcstar> is StateVar just a convenience over IORef?
10:55:01 <Polarina> mcstar, mostly, yes.
10:55:15 <Cale> mcstar: It's an abstraction of IORef/MVar/etc.
10:55:22 <gfredericks> I see a Bag type metioned here (http://www.haskell.org/ghc/docs/7.6.1/html/libraries/ghc-7.6.1/Bag.html), but I can't figure out the name of the module; or is it not available in 7.0.3?
10:55:56 <Cale> mcstar: It's kind of like an IO lens.
10:56:20 <mcstar> Cale: hehe, that didnt help at all
10:56:35 <Cale> gfredericks: well, you're looking at the documentation for 7.6.1
10:56:53 <mcstar> module Bag (
10:57:01 <Cale> gfredericks: and the package you're looking at is the ghc package, i.e. ghc-as-a-library
10:57:17 <Cale> yes, the module name is Bag
10:57:32 <Cale> 7.0.3 is getting pretty old
10:58:03 <gfredericks> so the fact that `:m + Bag` fail at my ghci means that it's a version issue, right?
10:58:37 <Cale> http://www.haskell.org/ghc/docs/7.0.1/html/libraries/ghc-7.0.1/Bag.html
10:58:38 <Cale> no
10:58:44 <rwbarton> looks like it is in the ghc package which is normally hidden
10:58:47 <Cale> It's that ghc-as-a-library is usually hidden
10:59:05 <gfredericks> how do I use it then?
10:59:07 <Cale> You're not meant to use that stuff for normal programming
10:59:17 <gfredericks> ooh
10:59:28 <gfredericks> so if I want a bag I make my own
11:00:15 <Cale> It would probably be better to make your own or use one from a library on hackage. Depending on the ghc package is kind of bad for compatibility.
11:00:47 <Cale> (Even if you're okay with being GHC-specific, anything in there is allowed to change between versions of GHC)
11:00:57 <gfredericks> I'll go with my own for now; am just learning the language, and am not up to learning the ecosystem yet
11:01:05 <gfredericks> thanks!
11:01:13 <Cale> http://hackage.haskell.org/package/multiset-0.2.1
11:01:38 <Cale> gfredericks: you could  cabal install multiset
11:01:44 <Cale> and then import Data.MultiSet
11:02:17 <Cale> http://hackage.haskell.org/packages/archive/multiset/0.2.1/doc/html/Data-MultiSet.html -- and you get that stuff
11:02:53 <Cale> gfredericks: But implementing your own multiset in terms of Data.Map isn't too hard
11:07:23 * hackagebot Elm 0.4.0.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.4.0.2 (EvanCzaplicki)
11:08:55 <ornicar> hello, newbie speaking. I'm starting my first haskell project. Is there a way to have caball recompile each time I save a .hs file, so I see my mistakes right away?
11:09:12 <hiptobecubic> ornicar, that is an editor feature
11:09:19 <hiptobecubic> ornicar, what editor are you using?
11:09:22 <ornicar> vim
11:09:28 <ornicar> without haskell-mode at the moment
11:09:47 <ornicar> maybe I should go with syntastic then
11:10:11 <hiptobecubic> ornicar, vim2hs is a nice setup
11:10:13 <ornicar> I'm used to scala sbt doing recompile on the fly for me, so I was wondering if cabal had something comparable
11:10:21 <ornicar> I'll look into vim2hs, thx
11:10:32 <dcoutts_> ornicar: not yet, I'm envious though :-)
11:10:33 <hiptobecubic> ornicar, I am also using vim with syntastic, vim2hs, and ghcmod-vim
11:10:47 <ornicar> ah! how good is it?
11:11:02 <dcoutts_> ornicar: the nearer thing for quick recompile will be "cabal ghci", ie load the package in ghci
11:11:19 <hiptobecubic> ornicar, quite? If you know the quirks of working with vim in general then i'd say it's pretty good
11:11:35 <gertc> how do you write "alldo i do not have..."
11:11:49 <ornicar> great. I'd like to spend few time on tooling tho, and more time on learning, at the beginning
11:11:51 <hiptobecubic> I wish ghcmod could identify the type of expression even the there is an error in some unrelated part of the file
11:12:18 <hiptobecubic> ornicar, that's a reasonable goal. I think there's even a premade vim "distribution" on github somewhere.
11:12:20 <rwbarton> you could also rig up something with inotify-tools
11:12:25 * hackagebot yesod-auth-fb 1.2.3 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.2.3 (FelipeLessa)
11:13:03 <byorgey> gertc: I don't understand your question.
11:13:21 <ornicar> I'm going for http://aichallenge.org/ as my first haskell project, lot of fun planned :)
11:13:33 <startling> hmm yeah, auto-reload in emacs with inotify would be excellent
11:13:49 <mcstar> it is preferable to split up a project to many modules, and work in ghci, it picks up compiled modules, and load the changed one either as interpreted or compiled mode, this will be quicker than recompiling and linking on each change
11:13:57 <startling> though I could probably just remap c-x s to c-c c-l. hmmm
11:14:11 <gertc> i writing a comment in inlish and my spell check does not find the right word fro "aldo" :)
11:14:23 <gertc> "alldo"?
11:14:32 <startling> "although"?
11:14:34 <hiptobecubic> ornicar, https://github.com/andrey013/Haskim
11:14:38 <gertc> aaaaa yes :)
11:14:46 <gertc> thx
11:14:57 <mcstar> whats inlish?
11:15:04 <gertc> enlish :)
11:15:08 <gertc> english
11:15:18 <gertc> sorry
11:15:42 <ornicar> hiptobecubic: oh nice. I'll pick what I need from there
11:16:08 <mcstar> ornicar: have fun, it was a great contest
11:16:20 <hiptobecubic> I toyed with the idea of having a second vim install as a playground, never got around to it, of course.
11:16:22 <ornicar> I hate spf13-vim tho :) I think it's not the right way to go with vim
11:16:26 <mcstar> ornicar: before you ask, we dont know yet when the next one will take place
11:16:43 <hiptobecubic> ornicar, never used it
11:17:09 <hiptobecubic> i looked at it briefly and didn't want it, although I don't remember why
11:17:27 * hackagebot yesod-fb 0.2 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.2 (FelipeLessa)
11:17:33 <hiptobecubic> this class alias thing looks great. What happened to it? This is years old... http://repetae.net/recent/out/classalias.html
11:18:40 <startling> hiptobecubic: you can do it kind of with ConstraintKinds
11:19:10 <startling> type Foobar a = (Foo a, Bar a), iirc
11:19:34 <startling> dunno if you can do instance Foobar with that, though
11:19:42 <n-dolio> You can only do, maybe, half of it.
11:19:52 <S11001001> @pl \f g h -> map h . sortBy (comparing g) . map f
11:19:53 <lambdabot> (flip ((.) . map) .) . flip ((.) . sortBy . comparing) . map
11:20:02 <startling> heh
11:22:06 <hiptobecubic> But it looks like such a nice feature to have
11:32:10 <ornicar> weird stuff. cabal install ghc-mod complained about `happy` not being found. `cabal install happy` fixed it. I wonder why it did not figure it by itself.
11:32:50 <geekosaur> normal
11:33:00 <luite> it's a program, not a library, unfortunately cabal-install cannot install those automatically
11:33:02 <geekosaur> cabal manages libraries (that's the L in "cabal")
11:33:10 <ornicar> ah ok.
11:34:08 <geekosaur> it's unfortunate, and comes from cabal-install being used to manage applications when the underlying cabal library is not designed to do so.  google "cabal is not a package manager" for more details.  (someday we need to find a better solutuon...)
11:35:27 <ornicar> I'm sure it makes sense, but it does look weird to the newcomer I am. No big deal tho.
11:47:15 <sully> is there a "ListT done right" in hackage?
11:47:32 <sully> there are wiki pages with code, so I could just paste them into my project...
11:47:57 <startling> is there a problem with mtl's C.M.List?
11:48:02 <fmap> @hackage logict
11:48:02 <lambdabot> http://hackage.haskell.org/package/logict
11:48:46 <sully> it's not a monad transformer
11:49:08 <sully> in the sense that it doesn't always produce something that obeys the monad laws
11:49:11 <startling> because of "Note: this does not yield a monad unless the argument monad is commutative."?
11:49:13 <startling> yeah
11:49:32 <sully> and since I want the inner monad to be IO...
11:49:46 <sm> hi all. How do I get pass a sequence of html elements (eg two table rows) as a single HSP expression ? I read <%>...</%> but it doesn't seem to work here.
11:49:46 <startling> ah
11:49:57 <rwbarton> if you want ListT IO then maybe you should look into things like pipes/conduits
11:50:46 <sully> actually, I mean really want ListT Writer
11:50:57 <sully> the main thing I want is to produce a log of the search I am doing
11:51:10 <rwbarton> aha
11:51:28 <rwbarton> yeah, LogicT is a good bet then
11:52:29 <startling> @hoogle listDir
11:52:29 <lambdabot> No results found
11:52:35 <startling> what's that function, again?
11:52:46 <startling> @hoogle FilePath -> IO [FilePath]
11:52:47 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
11:52:47 <lambdabot> Graphics.UI.GLUT.Initialization initialize :: String -> [String] -> IO [String]
11:52:47 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
11:52:51 <startling> ah
11:56:18 <Cale> edwardk: In the documentation for Control.Lens.Type, you have:
11:56:20 <Cale> -- Every 'Lens' is a valid 'Control.Lens.Setter.Setter', choosing @f@ =
11:56:20 <Cale> -- 'Control.Lens.Getter.Mutator'.
11:56:48 <edwardk> thats a bit wrong now
11:56:48 <Cale> edwardk: That should probably be 'Control.Lens.Setter.Mutator'
11:57:03 <edwardk> that too
11:57:13 <killy9999> this is not a haskell question, but does anyone know where can I find a neatlyformated text file with CC0 license?
11:57:21 <edwardk> nowadays it uses Settable rather than Mutator anyways
11:57:42 <killy9999> I wanted to release a piece of haskell code under CC0, but can't find anything other than HTML to add to my package :/
11:57:52 <clahey> killy9999: Why CC0?  Isn't that old?
11:58:02 <atriq> I have a strange compulsion to install Haskell libraries.
11:58:06 <atriq> Any suggestions?
11:58:09 <Polarina> mm_freak_, For Control.Wire.Prefab.Move.object and object_, can I have the post-update move function run in the wire's monad?
11:58:12 <edwardk> i find it hilarious that the benchmarks used for that c++ pattern matching library that show it beating haskell screwed up the haskell code pretty badly ;)
11:58:15 <killy9999> clahey: what would you propose instead?
11:58:17 <Polarina> atriq, netwire
11:58:19 <startling> atriq: lens
11:58:27 <atriq> startling, already got
11:58:31 <atriq> Polarina, what does it do?
11:58:36 <ornicar> hiptobecubic: can you auto-indent haskell code in vim (using =) without breaking it, because of bad indentation?
11:58:46 <clahey> killy9999: I was wrong about what CC0 is.  Go for it.
11:58:50 <Polarina> atriq, it's a library for functional reactive programming.
11:58:56 <clahey> atriq: I use apt-get install if I can, and cabal if it's not available.
11:59:00 <atriq> Functional...
11:59:05 <atriq> reactive programming?
11:59:14 <Cale> edwardk: Well, what do you expect, it was written by C++ guys who are probably beginners :)
11:59:17 <edwardk> haskell runs ~19% faster if you actually properly force everything, 39% faster if you fit the case analysis in a way that it fits in the pointer tagging bits and even faster if you use a custom strict list and rejigger the test suite to avoid blowing the stack
11:59:26 <hiptobecubic> ornicar, i don't trust it with huge files usually, no. I have my own syntax file that I tweak. It's close enough. Also things like the Tabularize and Align plugins.
11:59:31 <Polarina> atriq, there's a nice introduction here: http://www.haskell.org/haskellwiki/Functional_Reactive_Programming
11:59:42 <ornicar> hiptobecubic: got it.
11:59:45 <edwardk> even that first step is enough to beat all the c++ examples, the second blows the doors of ocaml, the third is just insult to injury
12:01:11 <killy9999> clahey: I considered WTFPL as an alternative :)
12:01:35 <clahey> killy9999: I'm actually good with CC0.
12:01:35 <hiptobecubic> atriq, opengl, then you don't have to do anything else for awhile
12:01:41 <clahey> killy9999: Can you not just strip out all the tags?
12:01:46 <hiptobecubic> assuming you have enough ram
12:01:59 <clahey> edwardk, Cale: I would argue that having to have advanced knowledge of the language to get fast code would be a weakness.
12:02:15 <killy9999> clahey: that's what I'm doing right now
12:02:21 <clahey> killy9999: Automated, I mean.
12:02:26 <hiptobecubic> clahey, you are right. but there are unfortunately very few (read 0) languages where that's not the case
12:02:33 <Cale> clahey: You need advanced knowledge of any language to get fast code.
12:02:45 <edwardk> clahey: the 19% was gained by fixing their benchmarking. they were literally making the haskell code do extra work in the part being benchmarked that they obviously didn't intend it to do
12:02:49 <killy9999> I removed them automatically, now I'm breaking lines manually
12:02:53 <edwardk> they used $! which only forced the head of the list
12:03:01 <killy9999> probably there's some extension to emacs that automates this
12:03:23 <edwardk> they also only compiled with -O.
12:03:28 <hiptobecubic> killy9999, lynx -dump
12:03:30 <edwardk> its just kind of sad over all
12:03:38 <startling> edwardk: where do I see the haskell code?
12:03:48 <edwardk> startling: i linked to it on twitter, one sec
12:03:56 <edwardk> https://t.co/VfwXxGWo
12:03:57 <Cale> edwardk: Is that paper already published, or do they get to revise it?
12:04:03 <edwardk> cale: dunno
12:04:04 <clahey> edwardk: What are they forcing?
12:04:05 <killy9999> hiptobecubic: thanks!
12:04:08 <clahey> killy9999: M-q
12:04:19 <edwardk> clahey: they build up a list that they intend to match on over and over
12:04:28 <hiptobecubic> edwardk, is it not longer the case that -O2 takes much longer and "does practically nothing useful as of now", or whatever that guide says.
12:04:30 <edwardk> the test isn't the profiling of the construction of the list
12:04:43 <clahey> edwardk: Oh, the test is the matching.
12:04:47 <edwardk> yes
12:04:55 <clahey> edwardk: And so it is doing construction during part of the matching step.
12:04:58 <edwardk> yes
12:05:03 <acowley> Is there any Haskell or FP thing happening in Boston in late October?
12:05:15 <startling> edwardk: thanks
12:05:25 <clahey> edwardk: And lazy evaluation is not an advanced feature when it comes to haskell.
12:05:30 <johnw> edwardk: I won't be coming to California after all next month
12:05:43 <johnw> :(:(
12:05:43 <clahey> edwardk: So if you don't realize that it might do that, you shouldn't be using haskell.
12:05:54 <edwardk> acowley: hrmm, i'm in mountain view from the 18th-22nd, then i go down to tampa til the 30th, so i hadn't planned anything for the latter half of the month
12:06:02 <acowley> darnit
12:06:08 <hiptobecubic> good ol' tampa
12:06:10 <clahey> edwardk: Next, what do you mean about fitting the case analysis...
12:06:16 <acowley> I may be in town while you're in tampa
12:06:35 <clahey> killy9999: Does M-q do what you wanted?
12:06:56 <acowley> edwardk: Can I ask what you're doing in Mt. View?
12:06:57 <clahey> killy9999: I kinda like the wtfpl.
12:06:59 <edwardk> clahey: ghc uses 'dynamic pointer tagging' as an optimization. it effectively means that the first 15 constructors are really cheap to pattern match on, avoiding a couple of terrible blind jumps that never branch predict well
12:07:00 <clahey> btw
12:07:21 <edwardk> also the fact that it cycles through cases sequentially is a worst case for ANY branch predictor and is not a good test
12:07:30 <clahey> The first 15 type constructors of a particular type.
12:07:41 <clahey> edwardk: Is that what the C code does?
12:07:45 <edwardk> acowley: gsoc mentor summit and giving a talk at BAHUG
12:08:15 <clahey> edwardk: What's the context, btw?
12:08:20 <edwardk> clahey: yes
12:08:37 <shachaf> edwardk: 15? Wasn't it 7?
12:08:42 <edwardk> clahey: https://twitter.com/kmett/status/250995914821496832
12:08:43 <luite> hm, 15? that sounds like too many, i think it has 3 bits availab,e of with the 000 combination is not a constructor tag, so you have 7 remaining combinations?
12:08:49 <edwardk> shachaf: 64 bits gives you an extra tag bit
12:09:00 <shachaf> You have 4 tag bits?
12:09:09 <luite> oh i thought it was 2 bits on 32 bit, 3 bits on 64
12:09:23 <shachaf> I thought it just kept things 64-bit aligned.
12:09:47 <int-e> luite: yeah, same here.
12:10:17 <clahey> edwardk: So if I have more than 15 constructors, switching based on the constructor is going to be significantly slower?
12:10:27 <shachaf> Of course you have more unused bits on amd64 in practice, but you're not really supposed to use those. :-)
12:10:54 <luite> clahey: if it cannot use the tag bits, it has to lookup the tag from the closure info table, an extra indirection
12:11:29 <int-e> well, if we're talking about ghc, it has 3 bits on platforms with 8 byte pointers, 2 bits for 4 byte pointers.
12:11:49 <luite> right, that's what i thought as well :)
12:11:53 <int-e> (see Cmm.h)
12:11:56 <edwardk> clahey: anything past the 15th constructor will be untagged, and therefore will have to jump into code blindly to do case analysis. this is considerably worse than the switch-like construct the c guys get to use, but somehow we still win
12:11:57 <edwardk> ;)
12:12:18 <clahey> edwardk: But the first 15 will still be fast?
12:12:23 <edwardk> yes
12:12:30 <clahey> So I can just put the most common ones in the first 15 and I'll get a decent result.
12:12:34 <edwardk> yep
12:12:36 <edwardk> and thats the diea
12:12:38 <edwardk> er idea
12:12:43 <startling> interesting
12:12:49 <luite> edwardk: hmm, you sure that it will have to do blind jumps? it could still get a constructor number from the info table, in theory it can generate fast jump code from that
12:12:58 <edwardk> luite: it doesn't
12:13:28 <edwardk> it might be able to but at last check that isn't the way it works. it sit untagged, and then does the blind jump in
12:13:45 <edwardk> one way to make that work might be to repurpose the 15th tag as a 'go look at the infotable' tag
12:14:24 <edwardk> but you'd need to profile a lot of stuff to see if that pays off, and its not going to be easy since it only affects the vanishingly small % of code that already has more than 15 (now 14) constructors
12:14:27 <luite> only for constructors with more than 15 constructors
12:14:40 <crdueck> @src filterM
12:14:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:14:53 <luite> since the code is monomorphic there, you know whether the 15th tag is a 15th constructor or a 15+th constructor :)
12:15:24 <luite> and i still think it's 7 :p
12:15:26 <edwardk> fair nuff
12:15:41 <edwardk> you may be right
12:15:45 <clahey> How do you get a type without a constructor?
12:15:51 <startling> @hoogle [a] -> (a -> m Bool) -> ([a], [a])
12:15:52 <lambdabot> No results found
12:15:53 <edwardk> 3 and 7  sounds correct now that you mention it
12:16:05 <clahey> I.e., what's the 8th tag value for currently?
12:16:25 <luite> clahey: zero means that it's not a constructor (or not known to be), so it might be a thunk
12:16:40 <clahey> luite: Ah, a thunk.  That makes total sense.
12:16:56 <Polarina> Why can't GHC check, e.g. if it has tag 3, it checks the 3rd constructor, then 18th, then 33th, etc? Sounds better than checking everything after the 15th.
12:16:57 <clahey> @hoogle [a] -> (a -> Bool) -> ([a], [a])
12:16:57 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
12:16:57 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
12:16:57 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
12:17:23 <clahey> @hoogle [a] -> (a -> m Bool) -> m ([a], [a])
12:17:24 <lambdabot> No results found
12:17:24 <int-e> clahey: also, some types don't have any values. In Haskell 98, newtype X = X X; with the EmptyDataDecls (sp?) extension in ghc, just  data X  works.
12:17:38 <edwardk> luite: you can always use my tag-bits library to access the tag info from the tag-bits (or info table) ;)
12:18:23 <shachaf> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/960526161_yXhEz#!i=960526396&k=jUHj2&lb=1&s=L
12:18:24 <edwardk> and yes it apears there are 7
12:18:45 <int-e> ghc cat plays tag!
12:18:47 <edwardk> that means that switching to pointer tagging is even more of a win, speeding the code up by almost 45%
12:19:20 <luite> i hope to add pointer tagging to ghcjs later, but i'm sad about the range of integer values i can work with :(
12:20:18 <shachaf> luite: You have 52 bits, right?
12:20:22 <rwbarton> using js integers?
12:20:24 <rwbarton> "integers
12:20:25 <rwbarton> "
12:20:33 <shachaf> That's more than my CPU has. :-)
12:20:37 <int-e> oh, doubles :/
12:20:53 <rwbarton> yeah, since you are nowhere near either 32 or 64 bits I don't see the big deal in using up a few more
12:21:13 <luite> shachaf: not really, javascript engines represent small integers differently, you can have 31 bits usually. large integers and doubles are stored as a boxed value, if you store lots of them in an array you get a lot of allocation and low performance
12:21:13 <int-e> shachaf: you have a CPU without double precision floating point arithmetic? :)
12:21:28 <rwbarton> ah okay, interesting
12:21:30 <shachaf> Ah.
12:21:39 <shachaf> int-e: I'm talking about integers.
12:21:47 <simon> hlint complains if monadic actions inside do-notation discard their value (do foo rather than do _ <- foo). how bad is this?
12:22:00 <luite> shachaf: perhaps v8 on 64 bit has a larger range for small integers, but you really hit a huge speed bump if you accidentally step outside the smi range
12:22:03 <simon> s/value/return value/
12:22:10 <rwbarton> simon: if you intended to use the return value it is bad :)
12:22:35 <dino-> Huh, I just got one of those evacuate(static) strange closure failures just trying to start ghci
12:22:44 <simon> rwbarton, I am thinking in terms of pleasing hlint and being idiomatic. :-P I suppose _ <- foo is rarely done by accident.
12:22:48 <rwbarton> opinions differ. personally I don't mind implicitly throwing results away
12:22:59 <luite> shachaf: 32 bits is probabaly available on 64 bit platforms, since that's the range they're required to support for bitwise operations
12:23:35 <hpaste> hiptobecubic pasted “A use for fix!” at http://hpaste.org/75384
12:23:40 <hiptobecubic> I finally found one! :D
12:23:45 <n-dolio> I think people who want to do the "_ <- m" stuff should be forced to use Scala for a few months.
12:23:47 <hiptobecubic> Granted it's hideous
12:23:49 <n-dolio> That will fix them.
12:23:59 <int-e> shachaf: well, doubles can represent hmm, 53 bit integers exactly.
12:24:26 <shachaf> int-e: See above.
12:24:46 <luite> shachaf: javascriptcore (and i think mozilla now) use a different way, they use part of the NaN range (which actually is not a single value) to store 32 bit ints and pointers, so they usually don't have to box doubles (as long as you can make some assumptions about memory layout for pointers)
12:24:58 <simon> n-dolio, there is talk of using Scala as an introductory programming language at my CS dept.
12:25:08 <n-dolio> Heh.
12:25:10 <simon> currently the first language people see is Standard ML.
12:25:14 <dino-> simon: Well.. better than starting them off with python I suppose
12:25:16 <rwbarton> yeah I read about using NaNs for a sort of pointer tagging, it's clever
12:25:21 <hiptobecubic> simon, where is this?
12:25:25 <simon> hiptobecubic, Copenhagen.
12:25:31 <hiptobecubic> simon, ah.. ok sure.
12:25:34 <n-dolio> I'd say stick with SML.
12:25:39 <n-dolio> But, whatever.
12:25:42 <hiptobecubic> If it had been in the US I'd have been shocked.
12:26:07 <acowley> I don't know Scala, so this is from a position of complete ignorance, but I haven't yet been able to understand why you would use Scala if you have a choice of not being on the JVM.
12:26:31 <dino-> Is it true that they ditched Scheme for Python for this type of course at MIT?
12:26:48 <typoclass> simon: the warning is not really bad. it's just a reminder to take a minute and think if you meant that. i think it's most important for functions like the ones that write into a socket, giving you back the number of bytes they wrote so you can check your entire message went through. you can suppress it with "_ <- foo" or "_numBytesDontCare <- foo" or "void foo"
12:26:55 <hiptobecubic> dino-, yes.
12:26:57 <acowley> That is to say, if nobody's forcing the JVM on you, why Scala? Why not Zoidberg^H Haskell?
12:27:04 <dino-> hiptobecubic: Kind of shocking, eh?
12:27:07 <hiptobecubic> dino-, at least, in the "easy" course i think.
12:27:20 <simon> typoclass, ah... void looks nice.
12:27:52 <hiptobecubic> acowley, in my opinion, the biggest (only?) reason for going with scala IS the jvm. There's a lot of jvm code out there that needs talking to.
12:28:32 <hiptobecubic> And a lot of bosses that think the jvm means that it won't be their fault when the project goes sour.
12:28:35 <acowley> hiptobecubic: Okay, I can accept that. But that doesn't seem like a good reason for making it the intro to typed languages.
12:28:51 <dino-> That's so sad, it's the new "nobody ever got fired for picking Microsoft"
12:29:30 <dino-> I've also heard the joke "Java is the new COBOL" wrt all the J2EE out there that needs maintenance. But I digress now into #haskell-blah territory.
12:29:33 <hiptobecubic> acowley, from a philosophical standpoint, no. If the goal is to produce an army of coders with good looking resumés then it's not a bad choice.
12:29:54 <hiptobecubic> dino-, i think the original was "... for picking IBM."
12:30:09 <geekosaur> "jvm means that it won't be their fault when the project goes sour" soinds like choosing failure from the beginning
12:30:11 <dino-> hiptobecubic: I think I forgot that, heh
12:30:13 <acowley> Those sayings come about due to some truth, though. Next time you're tempted to slam someone for an unwise technology decision, you should consider if what you're saying is the moral equivalent.
12:30:30 <acowley> For instance, I'm always saying, "Why didn't you just use Haskell?"
12:31:20 <hiptobecubic> geekosaur, it's not choosing failure. It's choosing safety. Specifically, safety in numbers.
12:32:02 <acowley> Actually I'm in a terrible advocacy state of mind right now as 7.6 support is so thin on the ground.
12:32:27 <geekosaur> hiptobecubic, I'm commenting on your phrasing, which is not *quite* the same thing as you (and they) intend
12:33:54 <hiptobecubic> geekosaur, I'm not following you.  You mean by choosing the jvm they are acknowledging that the project will go sour? Because no, that's not what I (or they) ever meant.
12:34:28 <acowley> It's not real safety though, it's a safety from blame in numbers
12:34:35 <hiptobecubic> I mean that when the project goes sour because it's inevitable, that's what projects do, people will start pointing fingers.
12:34:48 <geekosaur> your specific phrasing implies that the choice of the JVM is intended specifically to make the JVM the scapegoat.  as I said, that is not quite the right emphasis
12:35:05 <acowley> You could even consciously know that this tech decision will negatively impact the project, but if it's viewed as the safe choice, maybe you go that way because failure is always a possibility and you don't want to be the one left holding the bag
12:35:10 <banana_> is there a function like delete :: Eq a => a -> [a] -> [a] which removes all, not only the first one, occurences?
12:35:26 <hiptobecubic> acowley, sure. But you're missing the point. The point is not to be excellent. The point is not to be the guy who can be blamed for whatever happened.
12:35:26 <MostAwesomeDude> Hm.
12:35:43 <MostAwesomeDude> :t \x -> filter (/= x)
12:35:44 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
12:35:52 <MostAwesomeDude> banana_: ^^ ?
12:35:53 <acowley> No, I get that… I think that is just a different wording of what I just said
12:36:13 <hiptobecubic> acowley, yes, you said that after i had already typed the whole thing :)
12:36:24 <MostAwesomeDude> > (\x -> filter (/= x)) 1 [1,2,3,1,3,2,4,1,5,6,1]
12:36:25 <lambdabot>   [2,3,3,2,4,5,6]
12:36:30 <banana_> MostAwesomeDude: ah... thanks!
12:36:39 <MostAwesomeDude> banana_: Sure. Do you understand how it works?
12:36:49 <acowley> In any case, I am no closer to buying into the choice of Scala to introduce typed programming in school :)
12:37:39 <hiptobecubic> acowley, It could certainly be worse. At least scala is 'cool' right now.
12:38:16 <banana_> MostAwesomeDude: yes :) thanks!
12:38:30 <MostAwesomeDude> banana_: No problem. :3
12:39:34 <hiptobecubic> So this use of `fix` I wrote is essentially just a while loop. Is this the normal way it's used when not doing demonstrations on IRC?
12:39:52 <hiptobecubic> for the recent joiners: http://hpaste.org/75384
12:40:04 <dino-> btw, I'm in the Coursera class Odersky is teaching right now, FP with Scala. 2nd week, it's good so far.
12:40:28 <pnielsen> hiptobecubic: that's how it's used here, anyway: http://www.haskell.org/haskellwiki/Implement_a_chat_server
12:40:47 <hiptobecubic> dino-, yeah? I'm enrolled but have been too busy to actually do any of it :(
12:40:50 <whald> i've already asked about this here some hours ago, so please excuse if i'm repeating myself. but i'm really stuck on this and so i ask again, maybe someone can tell me whats going on: i have a program which runs twice as fast with a profiling build than without. does this sound interesting enough so s.o. here might have a look?
12:41:15 <dino-> hiptobecubic: You still have time to do the 1st week assignments
12:41:26 <hiptobecubic> dino-, when is the deadline?
12:42:08 <dino-> hiptobecubic: Due date Sep 28, hard deadline Oct 2
12:42:23 <hiptobecubic> hmm
12:44:17 <dino-> What I was complaining about earlier, ghci crashed with internal error: evacuate(static)..  I reinstalled the ghc and it went away. :( Wonder if my hd is failing
12:44:55 <dino-> Having a lot of weird problems like this, especially vbox VM image corruption.
12:45:25 <Botje> brrr
12:46:01 <dino-> whald: That doesn't sound right at all.
12:46:31 <whald> dino-, that's what i said. :-)
12:47:18 <dino-> whald: Is this a small program? Can you cut it down to the smallest code that still acts like this?
12:47:26 <Polarina> Is there something like Data.Map.foldrWithKey' but traverses the tree sorted?
12:47:52 <RawProduce> how easy is it to get a job writing Haskell?
12:48:01 <whald> dino-, it's rather big, but it's all on github: https://github.com/waldheinz/bling
12:48:28 <whald> dino-, would you give it a try?
12:48:58 <sully> (I wound up using http://hackage.haskell.org/package/List, by the way)
12:49:09 <typoclass> RawProduce: i think knowledge of haskell makes you a better programmer and more attractive to employers, whether you end up programming haskell or in another language
12:49:38 <copumpkin> RawProduce: no, it isn't
12:49:44 <RawProduce> so quite difficult
12:49:50 <copumpkin> but as typoclass says, lots of jobs like to see people who know it
12:49:56 <copumpkin> even if they don't write it for the position
12:49:58 <johnw> and no matter your job, you can often use Haskell for your own tooling.  That's what I'm doing right now
12:50:24 <pnielsen> it's like having a degree in an unrelated field
12:50:38 <johnw> or, it's like having a degree :)
12:50:44 <copumpkin> or like having
12:50:56 <sully> hm; if I want to put a Writer inside of an RWST stack
12:50:57 <dino-> whald: I got it here but going to have to work on it later. Probably shouldn't install all these deps (like SDL and whatever that Juicy thing is) here at work.
12:51:06 <sully> is there anyway for me to do this without the world ending?
12:51:40 <shachaf> sully: You alredy have a Writer, don't you?
12:51:50 <copumpkin> you need a Ghost Writer
12:51:56 <pnielsen> or, yeah.. :) I meant in terms of what employers think when they see "Haskell"
12:52:02 <shachaf> Anyway you can do it using explicit lifts or something. But it sounds like a pretty weird monad that you're making.
12:52:11 <whald> dino-, yeah, that SDL part is a bit unfortunate, I'll have to clean this up. it can run in a terminal as well.
12:52:26 <shachaf> Note that an alternative to WriterT a . WriterT b is WriterT (a,b)
12:53:08 <whald> dino-, JuicyPixels is the simplest thing to read some common bitmap formats (jpeg, png, ...) i found on hackage. works quite well.
12:53:38 <noviceprogrammer> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ what do you guys think of this tutorial?
12:53:45 <sully> well, I am getting told 'Ambiguous occurrence `tell''
12:53:53 <sully> oh, hm
12:53:59 <sully> I haven't even introduced the second writer though
12:54:03 <sully> I've just imported more things
12:54:56 <whald> dino-, so if you find some time to look at it later, i can provide you with instructions to reproduce
12:54:59 <Cale> edwardk: You copied the documentation for <+= and <-= from the documentation for <*= but you missed changing the word 'multiplication' to 'addition' or 'subtraction' in the second sentence.
12:55:06 <edwardk> derp
12:57:56 <sully> importing Control.Monad.RWS instead of Control.Monad.Trans.RWS fixed that problem...
12:59:06 <sully> schovi: yeah, this is a somewhat weird monad
12:59:09 <sully> er, argh!
12:59:20 <sully> shachaf: this is a somewhat weird monad
12:59:37 <sully> shachaf: there is a ListT in there for backtracking
12:59:47 <sully> and I need a writer on each side of the backtracking
13:01:39 <benmachine> ListT is broken
13:01:47 <sully> yes, I am not using the mtl ListT
13:01:53 <benmachine> oh, cool
13:02:03 <sully> I am using http://hackage.haskell.org/package/List
13:02:10 <sully> which has a monadic list and operations on it
13:02:51 <dmos> Any recommendations on how to structure the build files when using shake for building?
13:03:14 <sully> it is also too clever for its own good and defines all of the list operations in terms of a generic list typeclass with an associated type family
13:08:14 <sully> hm, weird; ghc is telling me that the ListT in that package doesn't have a MonadTrans instance, but the source says it does...
13:08:51 <luite> sully: could be that you have some dependency conflict, multiple versions of transformers for example
13:09:10 <luite> if ListT is built against one, and your own code is using the other
13:09:25 <sully> oh, yeah, that seems possible
13:09:31 <luite> try making a cabal project out of it, and run cabal-dev ghci
13:09:34 <sully> since I upgraded the version of transformers I had
13:10:03 <Daroth> Am I in the right place for "noob" questions ?
13:10:37 <maukd> no, but we can help you with "haskell" questions
13:11:38 <magnus1> anyone know of any fix to "unacceptable result type..." in gtk2hs/glib? (http://hackage.haskell.org/trac/gtk2hs/ticket/1272)
13:11:49 <typoclass> Daroth: sure. welcome to haskell.
13:14:11 <sully> luite: yeah, it was List dependending on a different version of mtl
13:14:20 <sully> or of transformers, rather
13:14:41 <hpaste> Daroth pasted “slice'” at http://hpaste.org/75385
13:14:46 <Daroth> http://hpaste.org/75385
13:15:25 <gabor> edwardk: I am thinking of indexed parsec (with (>>=) :: IParsec (a,b) m -> (m -> IParsec (a,c) n) -> IParsec (a,c) n)
13:15:27 <gabor> edwardk: where the index pair signifies the range of the covered input. But probably IApplicative parsing would give nicer indices
13:15:52 <Daroth> I'm trying to achieve 99 problems number 18 about cutting a range in a array, and I can't get why it does not compile
13:15:54 <edwardk> yeah
13:16:14 <nooodl> "sliceI x:(sliceI xs (c+1) d f)"
13:16:23 <edwardk> its tricky getting indexed parsing to work out nicely though
13:16:25 <gabor> edwardk: of course I would consume a Nat-indexed thrist
13:16:25 <nooodl> this is being parsed as (sliceI x) : (...)
13:17:38 <nooodl> i think you just want to drop the sliceI entirely?
13:17:51 <gabor> edwardk: btw., did you get around reporting the index pair bugs in GHC head?
13:17:56 <Daroth> nooodl: I do
13:18:03 <edwardk> index pair bugs?
13:18:05 <typoclass> Daroth: yes, what nooodl says. the error message is telling you that in line 21. it thinks the first argument is "sliceI x"
13:18:08 <edwardk> trying to remember
13:18:22 <edwardk> oh the ghc head ones that came up on the mailing list?
13:18:32 <gabor> edwardk: your Fst Snd workarounds
13:18:35 <edwardk> i talked further with SPJ on and off the list
13:18:49 <edwardk> they seem to have a plan moving forward but its going to require some heavily lifting and big changes
13:18:57 <edwardk> so its not yet ready for primetime
13:18:59 <gabor> heh
13:19:09 <nooodl> (also, that code isn't very haskell-y!)
13:19:11 <gabor> derp!
13:19:31 <edwardk> herp and derp are perfectly good names for those equality witnesses ;)
13:19:38 <Botje> huh, ubuntu didn't upgrade me to the latest haskell-platform. correcting that now ...
13:19:43 <edwardk> i'd argue they are safer than the (ab)use of Any. anyways ;)
13:20:37 <nooodl> "Start counting the elements with 1." nice coding habit you're teaching there, 99 haskell problems
13:20:55 <dino-> whald: Sorry, I got busy with work. One thing that can help is to try to run smaller sections of your code in isolation. See if you can figure out where the profiling is so weird that's smaller than "the whole damn thing"
13:21:20 <benmachine> nooodl: it's not that bad
13:21:35 <benmachine> things should be indexed from 0 but counted from 1
13:21:40 <Daroth> Is my problem about operators priority ?
13:23:18 <nooodl> Daroth: yeah, function application has the highest priority
13:23:50 <nooodl> so "f x:[y]" is "(f x):[y]", not "f (x:[y])"
13:24:38 <clahey> nooodl: What if I put in two spaces?  :)
13:25:09 <Daroth> And another question lead by my previous one, how can I trace code execution step by step ?
13:26:12 <ew0> I don't think it is possible
13:26:20 <ew0> execution doesn't go step by step, does it?
13:26:53 <Daroth> I mean, theire is probably a way to have more detail about exection internal isn't it ?
13:27:01 <fmap> depends on definition of step
13:27:10 <clahey> Is there a standard way to test yourself on the 99 questions?  It'd be cool if there were some sort of submission framework or something.
13:27:27 <simon> clahey, what 99 questions?
13:27:30 * hackagebot affine-invariant-ensemble-mcmc 0.2.0.0 - General-purpose sampling  http://hackage.haskell.org/package/affine-invariant-ensemble-mcmc-0.2.0.0 (JaredTobin)
13:27:36 <nooodl> clahey: nope, just keep track of which ones you've solved yourself
13:27:37 <c_wraith> > fix $ ((-21):) . scanl (+) 13
13:27:39 <lambdabot>   [-21,13,-8,5,-3,2,-1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,159...
13:27:42 <banana_> I need a function which does the following: ["1a","1b","2a","2b"] (even number of elements) to [("1a","1b"),("2a","2b")]. I wrote a recursive function but I wonder if there is a more elegant way to do this?
13:28:14 <simon> clahey, you can always solve Project Euler if you want a badge with your points on it :P
13:28:15 <ew0> hey, is there a way to make quickcheck used my supplied test vectors instead of random ones?
13:28:43 <nooodl> banana_: what should the function do for lists with an odd length?
13:28:47 <noviceprogrammer> What is the difference between saying Haskell is lazy and Haskell is non-strict?
13:29:04 <banana_> nooodl: you don't need to look at this case :)
13:29:11 <clahey> simon: Touche'.
13:29:21 <clahey> Touché.
13:29:49 <fmap> Daroth: what details do you want?
13:30:20 <simon> banana_, when I search hoogle for [a] -> [(a,a)], the closest I see is zip, which isn't exactly like it.
13:31:42 <Daroth> fmap: mostly pattern recognition details
13:31:47 <nooodl> > unfoldr (\x -> if null x then Nothing else Just (splitAt 2 x)) [0..9]
13:31:48 <lambdabot>   [[0,1],[2,3],[4,5],[6,7],[8,9]]
13:31:55 <nooodl> wait, that's lists
13:32:21 <MostAwesomeDude> > (\l -> zip l (tail l)) [0..9]
13:32:22 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9)]
13:32:40 <MostAwesomeDude> Oh, no, wait, I'm thinking of something different.
13:34:36 <maukd> I need a module for en-/decoding utf-8
13:34:42 <maukd> I can't find a good one
13:34:45 <shachaf> maukd: Data.Text?
13:34:56 <shachaf> (.Encoding)
13:35:04 <benmachine> > unfoldr (\xs -> case xs of y:z:zs -> Just ((y,z),zs); _ -> Nothing) [1 .. 10]
13:35:05 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
13:35:43 <simon> I'd say combine (x:y:xs) = (x,y):combine xs; combine _ = [] is prettier :P
13:35:48 <maukd> shachaf: suboptimal. I need String, not Text
13:36:35 <benmachine> > unfoldr (\xs -> do y:z:zs <- Just xs; Just ((y,z),z)) [1 .. 10]
13:36:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
13:36:43 <shachaf> maukd: And you care about performance, or what?
13:36:43 <benmachine> > unfoldr (\xs -> do y:z:zs <- Just xs; Just ((y,z),zs)) [1 .. 10]
13:36:44 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
13:36:59 <maukd> shachaf: no, I care about existing code
13:37:08 <nooodl> benmachine: clever maybe monad usage there
13:37:26 <benmachine> nooodl: I'm using the do-notation pattern match failure thing
13:37:36 <typoclass> i could have sworn that MissingH has a function for the grouping that simon wanted, but i can't find it
13:37:37 <benmachine> it's a bit... sneaky :P
13:37:39 <benmachine> works though
13:37:45 <nooodl> probably too sneaky
13:37:50 <benmachine> typoclass: but MissingH is silly
13:37:59 <shachaf> Anything wrong with pack/unpack?
13:38:00 <nooodl> i mean, could you guess what that does at first glance
13:38:04 <simon> typoclass, banana_ wanted it.
13:38:14 <typoclass> simon: er right, sorry
13:38:29 <benmachine> shachaf: wrong? well, they're slower than just having the data in the right format in the first place
13:38:29 <noviceprogrammer> 'a' :: Char
13:38:29 <noviceprogrammer> "a" :: [Char]
13:38:30 <noviceprogrammer> ""  ⇔ []
13:38:34 <typoclass> benmachine: how so? it's a bit old-fashioned
13:38:35 <noviceprogrammer> oops sorry
13:38:43 <shachaf> benmachine: So is this about performance?
13:39:00 <benmachine> shachaf: well, could arguably be about clarity as well
13:39:13 <benmachine> if you're doing string IO and then packing it, ur doin it rong :P
13:39:37 <noviceprogrammer> why use Data.Text  over [Char]?
13:39:49 <benmachine> shachaf: ohh wait, I'm being silly
13:39:55 <benmachine> shachaf: I didn't see the rest of your context
13:39:58 <banana_> benmachine:  thanks, I'll think about it =)I
13:40:08 <benmachine> typoclass: it has too much unrelated stuff in it
13:40:26 <benmachine> typoclass: I like things to be separated out, it means version numbers are more informative
13:40:33 <benmachine> and compile times are faster
13:40:49 <benmachine> plus, it's harder to find stuff
13:41:07 <benmachine> if I want to look for an MD5 algorithm, I'm going to search hackage for an MD5 package, or maybe a hashes package, or something
13:41:20 <benmachine> not for a package of "functions that aren't anywhere else in particular"
13:41:20 <shachaf> maukd: Do you also want it to use [Word8]?
13:41:27 <benmachine> I have to read more to see what's included
13:41:44 <benmachine> maukd: what's wrong with utf8-string?
13:42:28 <noviceprogrammer> is there any significance to having ' in a function name?
13:42:54 <maukd> shachaf: no. thanks for the tip, btw. compiles fine
13:43:28 <benmachine> noviceprogrammer: sometimes it means "strict version" sometimes it just means "alternate version"
13:43:29 <typoclass> noviceprogrammer: no, it counts as a regular character in function names. foo' usually means "a variant of foo"
13:43:29 <maukd> benmachine: doesn't seem to have a useful decode function
13:43:59 <benmachine> maukd: what type are you looking for? ByteString -> String?
13:44:16 <noviceprogrammer> ah
13:44:20 <maukd> ByteString -> Maybe String
13:44:44 <benmachine> maukd: what's not useful about the utf8-string decode functions?
13:45:00 <maukd> also, the author of utf8-string doesn't seem to know haskell: "Errors are replaced by character '\0xFFFD'."
13:45:08 <maukd> > '\0xFFFD'
13:45:09 <lambdabot>   <no location info>:
13:45:09 <lambdabot>      lexical error in string/character literal at chara...
13:45:19 <maukd> benmachine: they ignore errors
13:45:54 <benmachine> maukd: well, they replace them with an error character
13:46:05 <maukd> yes
13:46:15 <benmachine> > '\xfffd'
13:46:16 <lambdabot>   '\65533'
13:46:22 <benmachine> could you not just... test for that
13:46:30 <maukd> Codec.Binary.UTF8.String.decode doesn't even bother to document what it does in case of errors
13:46:43 <benmachine> right, but http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.htmldoes
13:46:47 <benmachine> http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.html does
13:46:50 <benmachine> er
13:46:50 <maukd> benmachine: no. what if the text genuinely contains replacement characters?
13:47:03 <maukd> this is why you don't use in-band error reporting
13:47:05 <nooodl> > let f = (concat . zipWith replicate $ cycle [1, 0]) in uncurry zip $ f &&& f . tail $ [0..11]
13:47:06 <lambdabot>   Couldn't match expected type `[[a]]'
13:47:06 <lambdabot>         against inferred type `[b] -> ...
13:47:21 <nooodl> > let f = (concat . zipWith replicate (cycle [1, 0])) in uncurry zip $ f &&& f . tail $ [0..11]
13:47:23 <lambdabot>  Terminated
13:47:33 <nooodl> i'm a terminator
13:47:44 <benmachine> maukd: ok, fair enough, would have been useful if you'd stated your requirements in the first place though >_>
13:47:46 <shachaf> maukd: There's also the UTF-8 code used by GHC for String and such, but it looks like a mess.
13:47:52 <typoclass> benmachine: i agree that a few things could be moved out into their own package (the stuff about email for instance). however, i'm not sure about this trend of making tons of packages that essentially contain 1 module with 1 function (e.g. the split package). i think it leads to clutter and dependency hell
13:47:53 <nooodl> (anyway, that works in pm/locally)
13:47:55 <shachaf> I mean for I/O with String.
13:48:32 <benmachine> typoclass: I think the opposite! it's usually version upgrades that lead to dependency hell, and amalgamated packages mean unnecessary version bumps
13:48:56 <benmachine> typoclass: also, package-level clutter versus module-level clutter, pick your poison
13:49:31 <nooodl> i should look into Control.Arrow once; &&& seems useful
13:50:01 <nooodl> (that's probably the J enthousiast in me speaking)
13:50:03 <t7_> ah i need dependent types
13:50:09 <shachaf> nooodl: You don't need to know anything about arrows to use &&& the way most people do.
13:50:15 <shachaf> @ty (&&&)
13:50:16 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:50:25 <shachaf> It's just a function :: (a -> b) -> (a -> c) -> a -> (b,c)
13:50:36 <nooodl> @ty (***)
13:50:37 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:50:55 <maukd> :t ioError
13:50:56 <lambdabot> forall a. IOError -> IO a
13:51:04 <nooodl> i can mentally replace a with (->)?
13:51:18 <typoclass> benmachine: well modules are grouped hierarchically, so i'd pick that over an unstructured list of packages. i don't think it's particularly cluttered to look at http://hackage.haskell.org/package/MissingH-0.18.6 , or base's list of modules
13:51:30 <shachaf> nooodl: Yes. That's usually the Arrow instance people in here use.
13:51:42 <benmachine> typoclass: I don't think hierarchy always helps
13:51:52 <nooodl> wow. i wonder why i never linked Arrow and... -> arrows
13:52:18 <benmachine> nooodl: arrows in general can be more interesting than just (->), but it's a good example to start with
13:52:45 <shachaf> benmachine: It's probably a terrible example if you want to understand Arrow in general. :-)
13:52:49 <shachaf> Just like Identity for Monad.
13:53:12 <benmachine> shachaf: mm, fair enough
13:53:48 <typoclass> benmachine: about findability, i don't have trouble with that because hayoo seems to always find stuff. about compile times and such, that's true, but i feel it's a smaller issue that doesn't warrant a blanket "MissingH is silly". also, i bet downloading and building 10 different 1-function packages takes longer than doing the same for 1 package that has perhaps 30 modules of which you use 10
13:53:48 <maukd> benmachine: true, but shachaf immediately responded with a suggestion so I went to look at it first :-)
13:54:00 <benmachine> maukd: :)
13:54:31 <benmachine> typoclass: right, but suppose I only use one module from MissingH
13:54:39 <benmachine> typoclass: which honestly I don't think is going to be that unusual
13:54:46 <benmachine> typoclass: anyway, what about the version bump issue
13:55:04 <anakreon> Hello. I need to generate with quickcheck random values of a data type but the values of some fields depend on the values of other fields. Any suggestions how to accomplish this?
13:55:28 <anakreon> The data type is a record
13:55:42 <benmachine> anakreon: do you know how to create random values normally?
13:55:51 <anakreon> yes
13:55:53 <benmachine> anakreon: and what do you mean by "depend" precisely?
13:56:44 <benmachine> anakreon: I imagine you'd just generate the independent fields first, and then choose how to generate the dependent fields based on those values
13:56:45 <anakreon> Sure. One field is a set. The values of an other field must be in this set
13:57:13 <clahey> If I have an answer that's noticeably different from one given, what do I do?  Just edit the wiki?
13:57:54 <typoclass> benmachine: well that's the point of packages like MissingH; you don't usually use only one of its modules (one of its functions), at least in my experience. there is a difference here between specialized packages and general "miscellaneous" packages
13:58:06 <anakreon> The record contains expressions and references to variables must be from a set that contains the names of variables.
13:58:45 <benmachine> clahey: umm, context?
13:59:05 <benmachine> anakreon: ok, so there are two approaches. randomly generate the expression, and then form the set by finding the variables in it
13:59:20 <benmachine> anakreon: or form the set, and write a function that randomly generates an expression using names from this set
13:59:26 <typoclass> anyway, i think there's a continuum between "one package and version number for every function" and "one version number for all haskell code everywhere". i think the optimum is, as always, somewhere in the middle, and i think the pendulum these days has swung too far in the direction of 1-function packages *shrug*
13:59:55 <fengshaun_> hi all, I'm getting started with haskell and I'm wondering where the math library is!  I need to calculate log
13:59:58 <fengshaun_> to the base e
14:00:11 <benmachine> > log 10
14:00:12 <lambdabot>   2.302585092994046
14:00:17 <fengshaun_> oh, built-in
14:00:19 <fengshaun_> interesting
14:00:22 <fengshaun_> thanks
14:00:25 <benmachine> > logBase 10 10
14:00:27 <lambdabot>   1.0
14:00:27 <anakreon> Thanks
14:00:30 <johnw> typoclass: MissingH seems like a "grab bag" to me
14:00:31 <typoclass> fengshaun_: the log function is available from Prelude. in general, use hoogle or hayoo to find things:
14:00:40 <typoclass> @where hayoo
14:00:40 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:00:45 <typoclass> johnw: sure
14:00:48 <fengshaun_> hoogle, got it, thanks!
14:01:13 <jfischoff> johnw: did you form an opinion on shelly hsscript (I think that is what is was called)?
14:01:52 <johnw> i like shelly quite a bit
14:01:59 <johnw> i've used it much more extensively in my latest utility
14:02:10 <jfischoff> any complaints?
14:02:12 <johnw> and now that I know more than I did before (like, what to do, what not to do), it's much easier to get along with
14:02:20 <johnw> my only complaint right now is that it swallows stderr
14:02:26 <johnw> and piping is very awkward
14:02:30 <t7_> :k ReadS
14:02:31 <lambdabot> * -> *
14:02:33 <johnw> so I can run "foo | pv | bar" and see the output from pv
14:02:35 <maukd> preflex: zenc 
14:02:35 <preflex>  z0e9U
14:02:35 <johnw> I can't
14:02:44 <maukd> preflex: zenc €
14:02:44 <preflex>  z20acU
14:02:55 <johnw> and stdout is line-buffered, so you don't see the incremental updates from utility that output \r
14:02:59 <jfischoff> johnw: pv?
14:03:06 <johnw> pv measure data coming through a pipe
14:03:11 <augur> http://www.reddit.com/r/haskell/comments/10heyd/slides_for_a_delimited_continuations_talk_based/c6dni8o
14:03:17 <jfischoff> ah
14:03:18 <johnw> pv -s SIZE will give you time estimates of how long the pipe will take to complete
14:03:19 <augur> am i missing something about ky3's response? :|
14:03:44 <jfischoff> huh cool
14:05:05 <benmachine> augur: the response to it amused me :P
14:05:31 <johnw> just yesterday I did a "zfs send -R ... | pv -s <size of filesystem> | zfs recv -d", and was able to know right away that it would take 13 hours to complete, and about when it would be done
14:06:05 <bgamari> hmm, my code get consistently worse when scaling on over than 8 cores
14:06:08 <bgamari> very strange
14:06:15 <bgamari> even on a 24 core machine
14:06:18 <johnw> bgamari: why is that strange?
14:06:25 <johnw> bgamari: maybe your granularity is too small
14:06:36 <bgamari> johnw: Because it scales quite well right up to 8
14:06:49 <johnw> yeah, but 24 threads have a lot more overhead than 8
14:06:57 <jfischoff> threadscope ftw!
14:06:58 <johnw> so you have to make sure it's not spending all its time in the schedular
14:07:00 <bgamari> we'll see what threadschope has to say
14:07:08 <augur> bens: the response to ky3, you mean?
14:07:12 <augur> er
14:07:16 <augur> benmachine: ^
14:07:32 * hackagebot FixedPoint-simple 0.3 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.3 (ThomasDuBuisson)
14:07:39 <benmachine> augur: yes
14:07:49 <augur> benmachine: well im glad my response amused you :)
14:08:03 <benmachine> oh, that's you? :P
14:08:15 <shachaf> bgamari: Is it a GC thing?
14:08:30 <benmachine> but yeah I don't get what's going on there
14:08:32 <bgamari> shachaf, Nope, I'm running master which fixed the GC issue
14:08:37 <bgamari> productivity is >90%
14:08:40 <augur> benmachine: its even worse, right
14:08:44 <augur> its not merely that its sort of aimless
14:08:44 <shachaf> "the GC issue"?
14:09:29 <bgamari> shachaf, I encountered the GC pinning issue that Simon M. fixed last week earlier this week
14:09:51 <bgamari> I was here asking about it a few days ago
14:10:03 <bgamari> thoughtpolice alerted me to the fix
14:10:11 <shachaf> Which issue is that?
14:10:26 <benmachine> augur: I just see it as inexplicable and then stop worrying
14:10:49 <ew0> hey, is there a haskell functino to eval a haskell list from a string?
14:11:04 <maukd> ew0: what
14:11:30 <ew0> something like a = parseLiteral("[1, 2, 3]")
14:11:43 <maukd> ew0: read
14:11:48 <augur> benmachine: the thing with his response is that its like half a conversation
14:11:55 <ew0> uhm, clever
14:12:21 <bgamari> shachaf, http://www.haskell.org/pipermail/glasgow-haskell-users/2012-September/022907.html
14:12:29 <benmachine> read isn't eval, it can't call functions or look up variables
14:12:37 <benmachine> (this is by and large a good thing)
14:12:45 <maukd> but it can parse literals!
14:13:25 <typoclass> > read "[ 1, 2, 3 ]" :: [Int] -- ewo, you might start with something like this
14:13:26 <lambdabot>   [1,2,3]
14:14:03 <shachaf> bgamari: Hmm. I should probably know more about GHC GC. :-)
14:15:01 <shachaf> bgamari: Anyway, say what it is when you figure it out. :-)
14:17:01 <t7_> is there a way to enumerate through tuple ranges? e.g. [ (x, y) | x <- [0..3], y <- [0..3]]
14:17:41 <benmachine> t7_: uh... like that?
14:17:51 <benmachine> what do you mean
14:17:59 <t7_> [(0, 0) .. (3, 3)]
14:18:03 <noviceprogrammer> > even 2
14:18:04 <lambdabot>   True
14:18:17 <rwbarton> you could use range from Ix
14:18:29 <MostAwesomeDude> > range ((0,0),(3,3))
14:18:30 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
14:18:36 <Nisstyre> > (not . not) $ even 2
14:18:38 <lambdabot>   True
14:19:19 <noviceprogrammer> where did the x and xs naming for head and tail begin?
14:19:23 <typoclass> > [ (x, y) | x <- [0..3], y <- [0..3]] -- t7, your specification works directly, as a list comprehension
14:19:24 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
14:19:25 <noviceprogrammer> is it from ML?
14:19:42 <Nisstyre> noviceprogrammer: not sure of the exact origin, but "x" came from Renes Descartes
14:19:48 <t7> yeah but it seems too big
14:19:49 <Nisstyre> "xs" is pronounced as "exxes"
14:19:52 <Nisstyre> as in pluralized x
14:20:00 <shachaf> @ty range
14:20:02 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
14:20:07 <shachaf> > curry range (0,0) (3,3)
14:20:08 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
14:20:22 <noviceprogrammer> ah
14:20:56 <noviceprogrammer> so haskell has optional curly braces/semicolons?
14:21:15 <maukd> sometimes
14:21:19 <Nisstyre> noviceprogrammer: yes, for some things
14:21:19 <typoclass> noviceprogrammer: if you ask me, x just means "some value". xs is a plural like "cat -> cats", in other words, xs means "some list"
14:21:52 <Nisstyre> yeah xs is just the logical continuation of "x" as a pluralized version
14:22:12 <Nisstyre> s/logical/linguistic/
14:22:41 <Nisstyre> you can add -s to almost anything in English
14:22:46 <noviceprogrammer> right
14:22:52 <Nisstyre> especially if you're from Newfoundland
14:24:12 <noviceprogrammer> why were n+k patterns banned? they seem useful
14:24:23 <noviceprogrammer> handy*
14:24:26 <maukd> [citation needed]
14:24:29 <atriq> instance Num Matrix
14:24:32 <Nisstyre> I forget the exact reason
14:24:33 <atriq> pretty much
14:26:35 <noviceprogrammer> http://www.willamette.edu/~fruehr/haskell/evolution.html
14:26:38 <typoclass> Nisstyre: i don't think it's particularly logical (or linguistic), because it's somewhat uncommon to pluralize letters. also, afaict most people would write "PWR's" and not "PWRs". but whatever, "xs" works pretty well once you got it, and an apostrophe wouldn't improve things
14:27:02 <noviceprogrammer> still too green to get most of the jokes in the page ^^
14:27:02 <MostAwesomeDude> noviceprogrammer: Special-casing (+) as a type constructor.
14:27:08 <noviceprogrammer> ah
14:27:28 <maukd> > let n + 1 = () in "a" + 1
14:27:30 <lambdabot>   ()
14:28:31 <benmachine> noviceprogrammer: they were so rarely used that they were really more confusing than useful
14:28:45 <benmachine> noviceprogrammer: plus, they made parses depend on whether or not you put parentheses in
14:28:53 <benmachine> noviceprogrammer: you can turn them back on if you want :P
14:29:33 <Nisstyre> but nobody will like you if you do >.>
14:30:13 <noviceprogrammer> right ^^
14:31:21 <bgamari> hmm, does it seem counterintuitive that raising the RTS' -H size (suggested heap size) reduces productivity?
14:33:44 <geekosaur> not necessarily; it can mean more work done during GC
14:34:09 <geekosaur> if you're doing lots of tiny allocations (bt in that case I would suspect you're missing some opportunities for fusion)
14:37:05 <noviceprogrammer> how should I decide when to use foldl' over foldl i.e. when would I use strict functions over non-strict ones?
14:37:15 <maukd> always
14:37:37 <n-dolio> You should always use foldl', that is.
14:37:51 <n-dolio> Not necessary always use strict functions.
14:38:11 <johnw> n-dolio: sometimes foldr is much more appropriate
14:38:21 <benmachine> johnw: sure, but between foldl and foldl'
14:38:24 <n-dolio> That was not an option under consideration.
14:38:27 <johnw> oh, yes, certainly
14:38:34 <noviceprogrammer> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ learning from this ^^
14:38:36 <johnw> foldl is just a memory gobbler
14:38:54 <johnw> unless the lazy semantics are just right
14:38:59 <noviceprogrammer> so non-strict functions are like call by name?
14:39:08 <johnw> non-strict functions are call by need
14:39:13 <n-dolio> Sometimes foldl is acceptable. But it's never really better.
14:39:19 <typoclass> noviceprogrammer: the rule of thumb is: use foldr or foldl', don't use foldl. if you're interested, here's some more discussion http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
14:39:21 <noviceprogrammer> ah right
14:39:21 <maukd> @src reverse
14:39:22 <lambdabot> reverse = foldl (flip (:)) []
14:39:29 <noviceprogrammer> thanks guys
14:39:39 <johnw> typoclass: that link is not right
14:39:47 <johnw> oh, my client dropped the '
14:39:48 <benmachine> n-dolio: aren't there cases where the semantics of foldl and foldl' are different?
14:39:48 <johnw> n/m
14:39:58 <noviceprogrammer> so the default higher-order/builtin functions are in Haskell rather than C? ^^
14:40:05 <johnw> foldl' is not right if you specifically don't want strictneees
14:40:07 <n-dolio> benmachine: Yes, but the things you have to write to see the difference are contrived.
14:40:15 <benmachine> n-dolio: fair enough :P
14:40:28 <johnw> I think the "use foldl' unless otherwise instructed" rule of thumb is for before you start thinking consciously about strictness
14:41:09 <maukd> putting the cons into consciously
14:41:09 <johnw> the issue I have with webpages like that haskellwiki page on foldl vs. foldl' is that it only considers cheap operations like +
14:41:19 <MostAwesomeDude> > foldl x [0..5]
14:41:20 <lambdabot>   Couldn't match expected type `a -> b -> a'
14:41:20 <lambdabot>         against inferred type `S...
14:41:23 <johnw> if I am folding over a lazy stream, foldl is much more appropriate
14:41:38 <n-dolio> benmachine: Like, "I want to fold over an entire list using a function that will sometimes discard the accumulator without looking at it, and at some points the accumulator will be bottom, but the result won't."
14:41:51 <benmachine> n-dolio: :P
14:42:25 <johnw> well, maybe
14:42:32 <johnw> as with most things, it all depends
14:43:44 <benmachine> hmm
14:45:14 <ew0> Not in scope: type constructor or class `TestLabel'
14:45:25 <ew0> but I'm pretty sure I imported HUnit
14:45:40 <ew0> when I build the TestCase without the label it is fine
14:50:38 <adanuseam> I don't suppose anyone can point me to an implementation of anti log
14:50:43 <adanuseam> ?
14:51:42 <adanuseam> wait, nvm
14:51:47 <ew0> I'm getting a divide by zero
14:51:56 <ew0> is there a way to know where it is happening?
14:52:07 <typoclass> ewo: folks can help you better if you paste your code, and the error message that you're getting
14:52:10 <typoclass> @where hpaste
14:52:10 <lambdabot> http://hpaste.org/
14:52:15 <bgamari> Man, GC tuning is hard
14:52:41 <ew0> ### Error in:   891:"Testing:((256,32,1),943580918)"
14:52:41 <ew0> divide by zero
14:52:41 <ew0> Cases: 240000  Tried: 892  Errors: 892  Failures: 0943580918
14:53:14 <ew0> is there a compile option to run some kind of debugger to point me the line it is happening?
14:53:35 <ew0> something gdb would do
14:55:38 <typoclass> ewo: well, i bet that 891 is the line. it's also listing the input
14:57:02 <ew0> 891 is the test
14:57:27 <ew0> I don't have a file with more than 200 lines
14:57:29 <ew0> xD
14:57:34 * hackagebot HTF 0.9.0.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.9.0.0 (StefanWehr)
15:02:56 <functor_you> Does something like this exist? (Monad m) => m a -> a
15:03:25 <dmwit> no
15:03:37 <dmwit> That's probably even on the FAQ.
15:03:39 <dmwit> ?where FAQ
15:03:40 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:03:48 <lightquake> functor_you: no, because you can't do IO a -> a
15:03:59 <functor_you> I see.
15:04:36 <dmwit> I guess it's not in the FAQ.
15:04:37 <pnielsen> <- :)
15:04:50 <functor_you> Which is why certain monads provide that functionality specifically? eg fromJust Just 3 -> 3
15:05:09 <lightquake> yeah
15:05:22 <functor_you> Is there a name for demoting a `value` like that?
15:05:28 <dmwit> You should probably just not use fromJust.
15:05:41 <dmwit> Most monads that have a sensible way to extract values name they extraction function "runFoo".
15:05:47 <dmwit> e.g. runState, runReader, etc.
15:05:59 <dmwit> whoa, it got a little ebonics in that sentence
15:06:01 <shachaf> dmwit: None of those are "extraction" functions.
15:06:02 <dmwit> s/they/their/
15:06:04 <rwbarton> most monads are also ordinary data types you can inspect by pattern-matching
15:06:16 <functor_you> rwbarton: True.
15:06:21 <dmwit> shachaf: Yes, let's argue about names, that will be helpful to the new guy.
15:06:22 <shachaf> Not in the sense of IO a -> a, anyway.
15:06:46 <shachaf> It's not names -- runState and runReader do something completely different from m a -> a
15:07:05 <shachaf> Anyway, never mind.
15:07:23 <functor_you> I think I understand dmwit's sentiment all the same.
15:07:26 <Ralith> functor_you: you shouldn't use fromJust either.
15:07:45 <functor_you> Ralith: Understood. I was more interested in the general idea of removing Monadic context.
15:07:58 <functor_you> The IO a -> a example really drove home how nonsensical that was, though.
15:08:29 <dmwit> I'm actually mildly upset that you consider IO a -> a a better example than Maybe a -> a.
15:08:33 <Ralith> functor_you: fromJust is an equally good example of why it's a bad idea.
15:08:36 <Ralith> if not better.
15:08:41 <functor_you> I think the problem is my brain still thinks about Monads as wrappers for values, which they clearly aren't.
15:09:20 <dmwit> A couple experiences with the data Unit a = Unit monad ought to clear that problem right up.
15:09:50 <functor_you> dmwit: Is `fromMaybe` not well liked, either?
15:09:57 <dmwit> fromMaybe is fine.
15:09:57 <c_wraith> fromMaybe is fine
15:10:01 <c_wraith> jinx
15:10:13 <dmwit> fromMaybe could reasonably be called runMaybe if you like that naming scheme from other monads.
15:10:31 * typoclass finds the naming in Data.Maybe not great
15:10:33 <functor_you> dmwit: I'm not sure I understand the runXXX convention.
15:10:48 <Ralith> functor_you: compare what happens when you give fromJust a Nothing to what happens when you give fromMaybe a Nothing.
15:11:11 <functor_you> Ralith: Error vs default value.
15:11:18 <Ralith> yes.
15:11:28 <functor_you> Ralith: Understood.
15:11:45 <functor_you> Finally, why runXXX? What's the significance of that naming convention?
15:11:49 <Ralith> you generally don't want your program to die with an error, and if you really do there are better ways than actually calling "error"
15:12:01 <Ralith> the (Either a) monad for example.
15:12:12 <dmwit> functor_you: There's no significance. It's just a name.
15:12:37 <functor_you> dmwit: A naming /convention/, rather.
15:12:40 <Ralith> functor_you: if you think of monads as a computation, 'runFoo' can be thought of as executing the computation.
15:12:49 <Ralith> but that's just one perspective.
15:13:02 <dmwit> Doesn't matter, there's still no significance. =)
15:13:41 <cmccann> in most cases "runFoo" just unwraps the underlying type, rather than "running" anything.
15:14:00 <typoclass> functor_you: for many monads, there's a function that makes the monad run and do its thing and (usually) produce a value. that's customarily called runState for the State monad, and so on
15:14:08 <cmccann> that naming convention always seemed a bit silly to me, honestly.
15:14:11 <dmwit> Conventions are nice because it means your poor brain that can only hold seven facts in short-term memory and a similarly limited number of facts in long-term memory can have cache-misses that go through to Google less often.
15:14:15 <dmwit> Nothing more.
15:14:54 <functor_you> Thank you, masters. I shall meditate on this. :)
15:14:59 <Ralith> hah
15:15:00 <Ralith> you do that
15:15:14 <dmwit> I think you should skip the meditation and write some code. =)
15:15:25 <functor_you> dmwit: That's mostly what I was getting at. :D
15:15:29 * Ralith found writing code to be the fastest way to grasp monads.
15:15:43 <cmccann> aren't we supposed to hit people with a stick and then they'll be enlightened? that's totally how most koans go, right.
15:15:52 <typoclass> ralith: s/monads/anything :)
15:16:02 <functor_you> +1 typoclass
15:16:02 <dmwit> SEVEN POUNDS OF FLAX!
15:16:17 <Ralith> typoclass: well in that case, I'll change my advice to, 'implementing them'
15:16:46 <dmwit> ln -s /usr/bin/ghc /usr/bin/runIO
15:17:06 <typoclass> cmccann: we prefer condescension, terminological hair-splitting, and baffling them with arcane irrelevant complications
15:17:29 <Ralith> typoclass: nonsense.
15:17:34 <cmccann> dmwit, pf, there's a perfectly good runIO function already
15:17:35 * hackagebot warp 1.3.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.2 (MichaelSnoyman)
15:17:35 <Ralith> typoclass: *all of freenode* prefers those. :D
15:18:16 <dmwit> If I were an op, this is the exact moment I would abuse my powers and mute cmccann. ;-)
15:18:42 <cmccann> dmwit, not a fan of TH, I take it?
15:18:55 <dmwit> There is a runIO, but we don't speak its name in here.
15:19:11 <dmwit> But I'll give you a hint, it starts with V and rhymes with "moldy wart".
15:19:38 <Ralith> vivialdi fort?
15:19:42 <Ralith> vivaldi*
15:20:11 <Ferdirand> unsafePerformIO, unsafePerformIO, unsafePerfo
15:20:14 <cmccann> pf, running arbitrary IO actions in TH splices is awesome and not at all a bad idea.
15:20:17 <Dodek> vUnsafePerformMagicOMort
15:20:18 * Ferdirand disappears in a puff of smoke
15:20:19 <typoclass> cmccann: tread carefully, ceiling cat is watching you
15:20:36 <dmwit> you guys actually crack me up =D
15:20:42 <cmccann> cf. http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH.html#v:runIO
15:20:54 <cmccann> it's even called runIO!
15:20:54 <Jafet> runIOT
15:21:51 <functor_you> Is this a reasonable resource to understand the State monad better? http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
15:21:56 <functor_you> The one on Haskell Wiki is a bit shit.
15:22:24 <dmwit> ?google you could have invented monads and maybe you already have
15:22:25 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:22:28 <cmccann> IOT would be perfectly reasonable if GHC just duplicated and/or destroyed the entire universe depending on what you do with the RealWorld token
15:22:44 <cmccann> why they don't implement that is beyond me
15:23:27 <Jafet> @hackage acme-realworld
15:23:27 <lambdabot> http://hackage.haskell.org/package/acme-realworld
15:23:52 * cmccann wants a quantum bogosort using IOT [], is that so much to ask?
15:24:07 <jathd> I'm trying to use Trifecta to write an REPL, but I'm having trouble understanding how to use stepParser.
15:24:12 <dmwit> There is a quantum monad transformer on Hackage...
15:24:52 <edwardk> jathd: i should probably put together a repl example
15:25:11 <edwardk> in particular i was working on how to get syntax highlighting and tab completion within something like haskelline
15:25:20 <edwardk> i just got distracted by shinier things
15:25:33 <jathd> edwardk: An example would be fantastic. The documentation is a bit, err… let's say spartan.
15:25:48 <edwardk> jathd: yeah, i admit trifecta is less than fully baked ;)
15:26:03 <thoughtpolice> edwardk has been on a lens voyage, away from parser-land
15:26:06 <edwardk> i got it far enough for my own purposes and folks kept clamoring for me to release it ;)
15:27:09 <edwardk> i've been thinking about releasing a nice command line argument parser using a trifecta-ish approach using lenses into a configuration though
15:27:35 * hackagebot http-conduit 1.6.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.6.1 (MichaelSnoyman)
15:28:03 <edwardk> e.g. you specify the configuration type, use a little trick for representability to get monoidal concatenation of configurations from a config file or the command line, and describe options giving the lens to what they change
15:28:23 <jathd> Specifically, stepParser takes a ByteString argument, but if I give it some incomplete input for that argument, it returns a StepFail. So when I try to feed it the rest of the input, it returns a StepFail saying the input was incomplete…
15:28:49 * cmccann hums "write it, use it, fix it, break it, test it, change it, just release it..."
15:29:04 <jathd> I've tried giving it mempty and then feeding it the incomplete input (which works)
15:29:10 <edwardk> jathd: hrmm, i've had a couple of people raise similar issues. can you put an issue on the issue tracker?
15:29:27 <edwardk> with preferably a small example?
15:29:39 <jathd> edwardk: well I don't know, I'm not sure what the expected behaviour is :)
15:30:03 <hvr> edwardk: ...is your current "lens" package in the same performance-ballpark as "data-lens"?
15:30:30 <edwardk> well, you should be able to take an arbitrary input and split it up however you want, step through it in as many small non-empty pieces as you want and get the same answer
15:30:34 <edwardk> if you can't, then thats a bug
15:30:46 <edwardk> hvr: same or better
15:30:50 <acowley> Is there a canonical non-empty list data type somewhere?
15:30:58 <edwardk> acowley: Data.List.NonEmpty in semigroups
15:31:05 <acowley> edwardk: thanks
15:31:27 <jathd> edwardk: well it works if you give no input in the call to stepParser, and the call "feed input" on the result.
15:31:37 <hvr> edwardk: so you'd recommend switching from "data-lens" to "lens" (or at least not advise against it)?
15:31:39 <jathd> edwardk: which is how parseByteString is implemented.
15:31:48 <edwardk> jathd: oh, i think i see your problem
15:31:57 <edwardk> the thing you feed it in step parser is just for setting the initial position
15:32:01 <edwardk> that should be documented
15:32:02 <edwardk> =)
15:32:14 <jathd> edwardk: oooh, ok
15:32:18 <edwardk> its used so you can put an annotation for say a file directive
15:32:18 <cmccann> edwardk, having gone from "data-lens" to "lens", what's next? "lens-codata"?
15:32:28 <snyp> Hi. Can I declare a function inside ghci, not the body, just the signature and then write the body?
15:32:36 <edwardk> cmccann: len
15:32:50 <cmccann> ooh, good idea
15:32:51 <jathd> edwardk: so if you start parsing in the middle of a string, you give it the whole stringa and the position. Is that for error messages to make sense?
15:32:57 <edwardk> Someone was joking on here that he didn't know what a len was but that I must like them a lot
15:33:05 <cmccann> haha
15:33:06 <hvr> what's the minimum package-name length Hackage accepts? =)
15:33:31 <edwardk> jathd: trifecta supports out of band repositioning for things like #line pragmas in c/c++
15:33:44 <edwardk> the ability to put this annotations in relies on passing it a custom delta
15:33:57 <edwardk> er these annotations
15:34:15 <edwardk> the Delta data type basically tracks offsets in position
15:35:01 <edwardk> https://github.com/ekmett/trifecta/blob/master/src/Text/Trifecta/Delta.hs#L45
15:35:32 <edwardk> the position is the starting position, otherwise your error messages just have a column, or line number
15:35:52 <jathd> Talking about delta: I see that "parseByteString p delta" is implemented by calling stepParser with a parser argument of (release delta *> p), and not just p. I've looked at release, but I just don't understand what it does.
15:36:19 <edwardk> thats a bit of a hack i admit =)
15:36:24 <jathd> ^^
15:36:33 <edwardk> mark and release are used to jump to positions in the input rope
15:36:45 <edwardk> so you can mark the current position, parse stuff and release back to the mark
15:37:10 <edwardk> and that puts you back to where the mark occurred
15:37:24 <jathd> so when you start parsing, you always have to release to the start?
15:37:24 <snyp> oh nevermind. I can. :) let { function; }
15:37:25 <edwardk> now with Delta, we're starting with a position that should be just the 0th byte of an empty file
15:37:46 <edwardk> releasing loads the line cache for the current line, otherwise i'd have to duplicate all that logic in parseByteString
15:38:03 <jathd> edwardk: ok, I guess that makes sense.
15:38:16 <edwardk> the stock trifecta parser carries around the current line, column and info about whether that line is fully ascii
15:38:42 <edwardk> it holds this separately from the rope because its much more efficient to cut that up directly for slicing, etc.
15:40:08 <edwardk> btw- if anyone wants to take over active maintainership on trifecta, let me know. i'd be happy to toss code towards it now and again, but i'm a pretty crappy maintainer for it right now
15:40:52 <edwardk> maybe i should ship 0.90 first
15:41:21 <jathd> edwardk: Something that might be a bug, then: If I call stepParser with (release mempty *> p) as the parser and mempty as the input, and then feed it whatever I want, it seems to always return StepCont, never StepFail or StepDone. In particular, when it returns StepCont of Failure, how can I know if it found a mistake in the input or if it's just waiting for more input?
15:42:30 <edwardk> not sure if thats a bug, StepCont is saying it could take more input. when you starve it what does it say?
15:43:08 <edwardk> parsers in trifecta are usually pretty 'hungry'. they'll usually just keep taking additional input you feed them until you cut them off at the trough ;)
15:43:23 <edwardk> e.g. many anyChar
15:43:38 <edwardk> that will keep eating input until you stop feeding it
15:43:51 <edwardk> the fact that its willing to accept more input isn't a sign of a bug per se
15:44:18 <edwardk> so looking at the Step constructors directly is a pretty dangerous way to hint at whether or not its done eating
15:45:01 <edwardk> StepCont should have a couple of arguments, a 'what to do if its fed more input' which may just ignore the input or do something else. and 'what to do if there is no more input and you had to run with what you've been given'
15:45:03 <jathd> edwardk: well if there's a mistake, when I stave it and print the result I get "unexpected x, expected y" at the correct position (so the error message is good); if I just didn't give it enough input, it prints "unexpected EOF, expected ...".
15:45:50 <edwardk> had trouble parsing that, so with starving its doing the right thing?
15:46:29 <edwardk> basicaly you shouldn't have to interpret StepCont, StepDone, StepFail yourself, thats starve's job.
15:46:41 <jathd> edwardk: if there is a mistake in the input, it returns StepCont _ (Failure _) _ and the Failure part contains a correct error message
15:46:59 <edwardk> yep and starve brings that Failure out
15:47:05 <jathd> yes
15:47:31 <jathd> but if I call starve before giving it all the input it needs, it returns a Failure complaining about an unexpected EOF.
15:47:37 <edwardk> sadly there isn't a good way to use the presence of StepCont as 'keep reading lines'
15:47:41 <edwardk> correct
15:47:53 <edwardk> you should only starve after you've fed it the entire input
15:48:16 <edwardk> so take your current repl line, feed it, then starve and look at the result
15:48:17 <jathd> edwardk: ah, I was kind of expecting it to return a StepFail when there's a mistake (so that it cannot parse successfully, whatever input remains)
15:48:37 <edwardk> the problem is what happens when i have something like
15:48:40 <edwardk> anyChar *> anyChar
15:48:43 <edwardk> er
15:48:56 <edwardk> anyChar *> anyChar <|> return '?'
15:49:02 <jathd> edwardk: the problem is that the repl input may span several lines.
15:49:04 <edwardk> that guy will succeed on no input
15:49:12 <edwardk> yep
15:49:27 <jathd> e
15:49:47 <edwardk> we track that specially here in our repl, we have a test to check to see if the command is one we expect to take multiple lines, and if so, we parse until we see a blank line
15:49:53 <edwardk> we do that outside of the parser though
15:50:18 <jathd> so I take a line of input, parse it, starve it, and get back a Failure. How do I know if the user made a mistake, or if I just haven't read all they have typed yet?
15:50:21 <edwardk> er so the  anyChar *> anyChar <|> return '?' example, will fail on one character, but succeed on two.
15:50:22 <jathd> oh, ok
15:51:15 <edwardk> we have something that looks at the command and sees if it looks like a 'data' declaration, or a type signature for an undefined term, etc. and then opens a multiline continuation prompt which keeps eating lines
15:51:52 <edwardk> ghc's solution is even uglier, they just have a :{ command that parses lines as a single command until it sees :}
15:52:53 <jathd> edwardk: Ok. What I had in mind was the way most List/Scheme repls work: if I type "(1 2" on the first line, it waits for more input; if I type "3 4)" on the second, it does its thing because it sees that it got the whole list, and doesn't need to read anything more.
15:52:58 <edwardk> i suppose it might be worth investigating if an alternate model for the parser could be constructed that has a 'this will fail no matter what you feed it' constructor
15:53:06 <jathd> I was hoping to do something like that with Trifecta
15:53:23 <edwardk> yeah, we actualy do that as part of the 'more' parser. we test for balanced ('s and ['s
15:53:27 <jathd> edwardk: that's exactly what I expected StepFail to mean
15:53:28 <acowley> Is the ZipFold package my best bet for composable folds?
15:53:34 <edwardk> but thats not part of the core trifecta'ish parser we use
15:54:09 <edwardk> StepFail does mean that, i just don't think trifecta is smart enough to put a StepFail everywhere that it _could_.
15:54:29 <edwardk> some of those corner cases may be outside of its scope to understand
15:55:07 <edwardk> acowley: composable folds?
15:55:31 <jathd> yeah, I was thinking it was just a matter of sending EOF errors to a StepCont and all other to StepFail, but I suspect there are weird corner cases lurking…
15:55:39 <edwardk> acowley: machines
15:55:51 <edwardk> acowley: you can use a mealy machine for folding just as well, and they compose as machines
15:56:30 <edwardk> jathd: i confess the end user case analyzing the Step constructors was something i explicitly remember _not_ thinking about ;)
15:56:49 <jathd> What bothers me is that what I was talking about is trivial to implement in any imperative language. :)
15:56:50 <edwardk> so there be dragons
15:57:12 <edwardk> its trivial to implement here with the right model. i just didn't factor that into my model
15:58:08 <jathd> Anyway, thanks! At least I'll know how to use stepParser
15:58:49 <Cale> edwardk: I've asked a couple mathematician friends of mine whether they've ever seen anything in the same shape as lenses going on in another category :)
15:59:09 <edwardk> and?
15:59:09 <Cale> (Just sent the email)
15:59:12 <edwardk> ah
15:59:36 <Cale> I think there might be some sort of application to doing surgery on topological spaces
15:59:44 <ew0> ow yeah : Cases: 480000  Tried: 480000  Errors: 0  Failures: 0
15:59:47 <edwardk> jathd: np. beat on it. find corner cases i didn't consider and i can consider them for subsequent versions ;)
16:00:00 <edwardk> cale: hah
16:00:15 <Cale> (maybe in an abstracted setting where the notion of toplogical spaces being considered aren't just sets of points anymore, but defined in a categorical way)
16:00:42 <edwardk> cale: great. the next haskell post on lenses can draw intuitive connections between the lens library and understanding the riemann hypothesis
16:01:20 <c_wraith> will that mean the lens hypothesis has a million-dollar prize for solving?
16:01:45 <edwardk> c_wraith: =)
16:05:35 <Cale> (The guy I mainly aimed my email at studies categorical abstract homotopy theory, but doesn't know much about functional programming yet)
16:07:36 * hackagebot directory-tree 0.11.0 - A simple directory-like tree datatype, with useful IO functions  http://hackage.haskell.org/package/directory-tree-0.11.0 (BrandonSimmons)
16:07:56 <Cale> Actually, hey wait a minute
16:09:22 <Cale> Couldn't we think of, say, the charts on a manifold kind of like Simple Lens (R^n) M, in a category of suitably differentiable maps on manifolds? :)
16:09:32 <Cale> hmmm!
16:12:36 * hackagebot yesod-platform 1.1.3 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.3 (MichaelSnoyman)
16:28:50 <mm_freak_> Polarina: not right now
16:29:22 <mm_freak_> netwire 4 is really mostly made for pure wires (where cat = (->))
16:38:31 <whittle> I just encountered the literal sequence "{..}" for the first time. Is there a name for this, so that I can search for it to find out more?
16:39:03 <edwardk> whittle: RecordWildcards
16:39:11 <whittle> edwardk: Thank you.
16:48:17 <typoclass> whittle: don't worry, it's pretty simple ... "create a record from those local variables, which i cleverly named the same as the record's fields". see also the ghc user guide: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
16:49:17 <monochrom> always read the GHC user guide from beginning to end
16:49:44 <RebelBunny> why do people say learning haskell is a waste of time?
16:50:15 <monochrom> because of the law of large numbers
16:50:35 <typoclass> RebelBunny: hm, haven't heard that. i bet you won't find that opinion in this channel, however :-)
16:50:35 <luite> possibly because they think you can't get a job programming haskell
16:50:41 <RebelBunny> monochrom: "the chances of you running into needing to use it or a place that'll allow you to use it in a production environment are extremely low to none"
16:51:14 <monochrom> if there is a probability of 0.0001% that a person opines X, and there are 4 billion people, you are bound to hear some of them say X
16:51:55 <monochrom> I don't need the exact quote, thank you very much. the law of large numbers suffices to explain why people say all sorts of things.
16:52:38 <typoclass> monochrom: i guess we should end all chat then?
16:53:58 <monochrom> no, there are some other things worth talking about, and they are not explained by the law of large numbers
16:54:13 <liyang> Pepper spray: it's a food product, essentially!
16:54:23 <monochrom> but definitely, "why do some people on the internet says X" should be ended
16:57:09 <benmachine> monochrom: that's not the law of large numbers >_>
16:57:29 <benmachine> the law of large numbers is about the probability of random variables deviating from their mean
16:58:43 <latro`a> that's actually the weak one
16:58:55 <latro`a> the strong one is about convergence of a particular sequence of numbers
17:00:34 <monochrom> a few more steps after using the law of large numbers, then
17:02:05 <Nereid> but
17:02:13 <Nereid> the law of large numbers doesn't tell you anything
17:02:19 <Nereid> in this case.
17:02:31 <Nereid> because your numbers aren't arbitrarily large.
17:03:19 <monochrom> right, the population size or number of experiments is merely 4 billion
17:03:34 <Nereid> I mean why not, while we're being pedantic.
17:05:58 <ahf> hr
17:10:32 <Jafet> If you learn haskell, you can get laid off.
17:11:19 <typoclass> RebelBunny: anyway, if a job applicant can demonstrate some haskell knowledge, that at least shows "i'm willing to explore things off the mainstream", "i enjoy a brain-teaser", "i'm not scared if there's a learning curve"
17:11:33 <typoclass> (no matter if haskell is used directly on that job)
17:12:10 <typoclass> so no, i don't agree with that quote, i think it's shortsighted and narrow-minded *shrug*
17:12:31 <monochrom> depending on the hiring decision maker, that may be a benefit or a curse
17:13:17 <cglazner_> how should i apply map to a newtype wrapping a list?
17:13:31 <cglazner_> do i have to deconstruct it in a pattern match?
17:13:46 <monochrom> I think so
17:13:55 <polrtx> Hi, I'm trying to compare coordinates represented as tuples. compare (3,3) (4,1) outputs LT. How to compare them by digits?
17:14:19 <Jafet> compareByDigits (3,3) (4,1)
17:14:49 <benmachine> polrtx: what's comparing by digits?
17:14:58 <monochrom> Jafet++
17:15:08 <typoclass> Jafet: very helpful answer :-(
17:15:39 <monochrom> it's a good answer. it says that the original question begs the question
17:16:17 <Jafet> cglazner: newtype Foo = Foo { getFoo :: T }
17:18:23 <benmachine> monochrom: begs the question?
17:18:52 <monochrom> yes. it begs your question
17:19:06 <cglazner_> Jafet: so where does the list come in?
17:19:28 <cglazner_> right now i have newtype SpecialList = SpecialList [Int]
17:19:38 <Jafet> I have no idea. That's just the usual way to write a newtype to avoid patterns.
17:19:52 <benmachine> monochrom: http://www.qwantz.com/index.php?comic=693
17:19:55 <cglazner_> ah ok thanks
17:20:00 <Jafet> SpecialList { getList :: [Int] }
17:20:15 <Jafet> map (SpecialList . sum . getList)
17:20:26 <cglazner_> oh ok got it
17:20:37 <monochrom> God, why do those comics contain more text than my thesis
17:20:38 <Jafet> If you do that a lot you probably want to derive Functor.
17:21:50 <typoclass> monochrom: i disagree. if the question is underdefined in your opinion, the adult thing to do is ask for clarification. the above answer is the kind of terse passive-aggressive crap common in many irc channels, and the reason why those are so unpleasant
17:22:00 <monochrom> you know, in those cases, if you delete the dinosaur pictures and just layout the script as "A: ...  B: ...  A: ..." etc, it will be so much more readable
17:22:59 <benmachine> monochrom: readability is not the only value
17:23:58 <Jafet> That transformation applies to most newspaper comics
17:25:00 <typoclass> monochrom: the purpose of answers like that is not to help anyone, but to demonstrate how clever the author is, for some warped definition of clever involving how he's able to construct unhelpful nonsense that still technically fits the a question
17:25:31 <benmachine> typoclass: I don't think it is
17:25:48 <typoclass> benmachine: what else would it be for?
17:25:57 <benmachine> typoclass: it's not about cleverness, it's about exasperation
17:26:02 <Jafet> Indeed. I didn't really help the asker like typoclass did.
17:26:27 <benmachine> typoclass: I'm not saying it's the right response
17:26:29 <Jafet> Grow something.
17:26:55 <typoclass> Jafet: if that's supposed to be sarcastic, benmachine already asked him what he meant by comparing. no need to ask that twice.
17:27:33 <benmachine> typoclass: I just think that calling people out on their bullshit is something you have to do /very/ tactfully if you want them to listen
17:27:45 <benmachine> typoclass: if you don't want them to listen and you're just venting, then fine
17:27:57 <benmachine> typoclass: but then you don't get to claim the moral high ground wrt helpful responses :)
17:28:35 <Quantumplation> Can you extend the [2..] type behavior to your own types?
17:28:42 <RawProduce> if programming languages were to be personified, Haskell would be a hipster. Discuss.
17:28:44 <Jafet> [2..] is fromEnum 2
17:28:45 * RawProduce ducks
17:28:50 <benmachine> Quantumplation: yes, it's governed by the Enum class
17:29:03 <monochrom> @type [2..]
17:29:04 <lambdabot> forall t. (Num t, Enum t) => [t]
17:29:22 <monochrom> you need both Num and Enum, but yes. make your type an instance of both
17:29:43 <monochrom> you need Num for "2" and you need Enum for ".."
17:30:21 <benmachine> you can even derive Enum on data types where all the constructors are nullary
17:30:38 <Quantumplation> right, but if i had like... data AB = A | B deriving Enum; let a = [A..] it would be the infinitely alternating list of A, B, A?
17:30:40 <Jafet> rawproduce: nonsense, most of us don't have unicycles
17:30:50 <benmachine> Quantumplation: no, it would be [A,B]
17:30:53 <RawProduce> Jafet: what about monacles?
17:30:58 <Jafet> > [False..]
17:30:58 <benmachine> > [False ..]
17:30:59 <lambdabot>   <no location info>: parse error on input `]'
17:30:59 <lambdabot>   [False,True]
17:31:04 <Quantumplation> ah ok
17:31:05 <benmachine> I win :P
17:31:16 <Quantumplation> and if I provided my own custom implementation for the enum typeclass, could I make it do that?
17:31:21 <benmachine> yes
17:31:26 <Quantumplation> woo, that's awesome
17:32:02 <Jafet> ಠ.ಠ
17:32:34 <Jafet> > cycle [False ..]
17:32:35 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
17:33:00 <RawProduce> has anyone managed to crash lambdabot so far?
17:33:08 <Jafet> I suppose a hipster would write cycle with fix.
17:33:15 <RawProduce> lazy evaluation probably saves it, I guess
17:33:28 <startling> RawProduce, it's pretty thoroughly sandboxed
17:33:36 <monochrom> > fix ([False .. ] ++ )
17:33:38 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
17:33:42 <startling> RawProduce, why would lazy evaluation save it?
17:33:52 <startling> someone flooded #clojure with a lambdabot once
17:34:03 <RawProduce> you can't blow it up with infinity
17:34:12 <monochrom> hahaha
17:34:16 <startling> heh
17:34:24 <monochrom> I mean, this is so ##math
17:34:31 <liyang> > 1 / 0 :: Integer
17:34:32 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
17:34:32 <lambdabot>    arising f...
17:34:39 <liyang> Oh. Er.
17:34:42 <startling> > sum [1..]
17:34:46 <lambdabot>   mueval-core: Time limit exceeded
17:34:47 <shachaf> preflex: seen ddarius
17:34:47 <preflex>  ddarius was last seen on #haskell 25 days, 15 hours, 31 minutes and 4 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
17:34:58 <Jafet> @quote infinity
17:34:58 <lambdabot> <mc__> says: infinity <lambdabot>   * Exception: stack overflow
17:35:04 <shachaf> Wait, preflex is here? I didn't expect that to work.
17:35:11 <shachaf> ...Well, it only sort of worked.
17:35:13 <Jafet> @quote Infinity
17:35:13 <lambdabot> <mc__> says: infinity <lambdabot>   * Exception: stack overflow
17:35:44 <Quantumplation> what would a situation be that you want to use uncurry?
17:35:49 <RawProduce> hah
17:36:11 <rwbarton> preflex has been here for an hour or so
17:36:18 <startling> Quantumplation, hooking up an a -> b -> c to an x -> (a, b)
17:36:19 <latro`a> > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
17:36:24 <lambdabot>   can't find file: L.hs
17:36:25 <shachaf> Yay, z-encoding.
17:36:32 <shachaf> Someone ought to put a plugin for that in lambdabot.
17:36:32 <latro`a> lolwut
17:36:33 <latro`a> L.hs
17:36:35 <startling> L.hs?
17:36:47 <shachaf> rwbarton: How do you feel about writing Lambdabot 2.0?
17:36:51 <latro`a> > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
17:36:52 <lambdabot>   "hell, wold"
17:37:17 <latro`a> oh, right
17:37:22 <YayMe> is this a reasonable structure for a graph? data Vertice a = Vertice a [Vertice a]
17:37:31 <typoclass> Quantumplation: when you have a 2-tuple, and a function that takes two arguments (instead of one argument that is a 2-tuple)
17:37:32 <Jafet> The singular is "vertex".
17:37:33 <monochrom> if you use Arrow, often you need functions (X,Y) -> Z, so you use uncurry to get one. that's a use of uncurry. I think that's the major use
17:37:35 <typoclass> > uncurry (+) (2,3) -- Quantumplation
17:37:36 <lambdabot>   5
17:37:40 <shachaf> YayMe: That's usually called a "rose tree".
17:37:47 <shachaf> The singular of "vertices" is "vertex".
17:37:52 <YayMe> shachaf: You're a rose tree! I mean, ok
17:37:58 <YayMe> ah didn't know that thanks
17:38:05 <Quantumplation> *nods* i get it
17:38:09 <shachaf> YayMe: Remember that you don't have pointer equality in Haskell.
17:38:14 <shachaf> You have to provide your own identity.
17:38:28 <YayMe> shachaf: yeah I was thinking about that
17:38:34 <Quantumplation> YayMe: no, that's not reasonable, because you spelled Vertex wrong. :|
17:38:39 <startling> YayMe, Data.Tree has an implementation + useful functions
17:38:39 <Quantumplation> (kidding, kidding)
17:38:44 <YayMe> the problem I realize with my 'rose tree' is that as a graph it doesn't work for loops
17:38:45 <rwbarton> shachaf: I already have a pile of my own projects that I never get around to coding up. Sure would be nice to have, though
17:39:07 <startling> YayMe, yeah, you can't detect loops
17:39:10 <Jafet> If you tie the knot, you get an immutable graph
17:39:37 <YayMe> startling: I'm trying to learn data structures and functional programming to look good in interviews, so far so good on the fp part (ish) but the data structures part is murder. possibly because I'm trying to figuer them out using the fp part.
17:40:05 <startling> YayMe, what data structures do you have questions about?
17:40:13 <YayMe> startling: moreover, my data structure can't present loops, I tried reading the tying the knot examples on haskell's wiki and about blew my brains out
17:40:22 <startling> heh
17:40:38 <startling> YayMe, at least haskell is a pretty good language for data structures
17:40:45 <startling> no struct + pointer nonsense
17:40:49 <monochrom> the tying the knot examples there are too hard IMO
17:40:57 <YayMe> startling: I've never studied data structures, so all of them. :) I kind of get most of them, but trying to implement them I figure is the best way to get an intuitive feel for them
17:41:29 <YayMe> monochrom: if they're representative of tying the knot then it as a whole is too hard for my wee brain heh
17:41:41 <monochrom> they are not representative
17:42:21 <YayMe> I understood the idea in the data structure there for the doubly linked list, but then I got lost partially because I've tended to avoid let .. in .. syntax moreover, the let statements don't mentally parse for me
17:42:46 <YayMe> the ones they show have... strange interdependence I don't grok
17:42:53 <monochrom> well, they are representative of how people use knots for real. but not representative of how you should start learning
17:43:31 <monochrom> clearly, for every topic, how people use for real is much more advanced than how people start learning
17:43:56 <YayMe> true enough, at least in haskell heh
17:44:02 <RawProduce> not every topic
17:44:04 <monochrom> if you have written "x = 0 : x", you have already tied a beginner knot
17:44:09 <YayMe> I need to go read and practice a bit of the let stuff
17:44:49 <Nisstyre> YayMe: http://en.wikibooks.org/wiki/Haskell/Zippers
17:45:23 <shachaf> YayMe: Are you reading a standard data structure book and trying to implement it in Haskell, or something like that?
17:45:27 <YayMe> I get that tying the knot is recursion in somehow and it's got to behave like a generator, but then I've failed to implement the Y combinator in any language since I learned of it short of using other peoples obvious snippets, so perhaps I'm not so good at recursion
17:45:41 <shachaf> Doubly linked lists don't make sense in Haskell the same way they do in other languages.
17:45:53 <YayMe> shachaf: No, just reading about different data structures then trying to implement them
17:46:02 <shachaf> YayMe: You can't* implement the Y combinator in Haskell, so don't worry about that. :-)
17:46:22 <YayMe> shachaf: Yeah I know that, but you can in ela and javascript
17:47:07 <c_wraith> The thing that prevents* it in haskell is requiring an infinite type, which the type-checker rejects.
17:47:12 <YayMe> I was able to sort of mentally parse the implementations in those and F# as well, and understood them when I evaluated them on paper but still couldn't without following a recipe figure out how to write it exactly
17:47:22 <monochrom> if you model a two-vertex graph as "a = Vertex 1 [b]; b = Vertex 2 [a]", so a and b points to each other (but you won't detect it at run time), you have tied an intermediate knot
17:47:29 <c_wraith> F# would have the same limitation
17:47:43 <shachaf> monochrom: An intermediate knot? What's an advanced knot like?
17:47:53 <startling> YayMe: let fib@(_:fs) = 0 : 1 : zipWith (+) fib fs
17:48:02 <Jafet> Something involving abstract topolopy, no doubt.
17:48:24 <startling> Jafet: well, they have a whole Theory for knots
17:48:26 <monochrom> advanced knots are in http://www.haskell.org/haskellwiki/MonadFix
17:50:01 <monochrom> also those memoizing combinators
17:50:20 <monochrom> "memofix" etc
17:51:52 <babe1993> hello!!
17:51:56 <babe1993> !list
17:53:19 <RawProduce> hey
17:53:22 <benmachine> babe1993: what exactly are you looking for a list of
17:54:42 <rwbarton> can we make lambdabot respond to !list with a link to oleg's ftp site?
17:54:59 <shachaf> rwbarton: That's part of Lambdabot 2.0!
17:55:07 <shachaf> @where oleg
17:55:07 <lambdabot> http://okmij.org/ftp/
17:55:14 <shachaf> By the way, that isn't actually an FTP site.
17:55:26 <ion> Aww, Vacuum doesn’t handle SimpleReflect values very nicely. I hoped visualizing x^10 in Vacuum would display the sharing nicely.
17:56:28 <RawProduce> what does FTP have to do with that site? it's all HTTP
17:56:45 <benmachine> maybe he ftps things into it
17:56:51 <ion> ftp://okmij.org/
17:56:57 <rwbarton> So it may appear to those uninitiated in the ways of type-level programming
17:57:07 <monochrom> rwbarton++ hehehe!
17:57:41 <Ishpeck> On some platforms, the ftp program can be used like wget so... either http://okmij.org/ftp/ or ftp://okmij.org/ can be used as FTP sites. :P
17:57:52 <monochrom> actually we don't need to modify lambdabot. anyone can add a bot for just that. even simply a script to their current irc software
17:58:00 <RawProduce> this cake is a lie
17:58:06 <shachaf> distribot
18:01:45 <Cale> Obviously babe1993 was in search of 31337 0DAY Ha5K3LL W4R3Z
18:02:33 <Cale> We need to get some XDCCs running serving up copies of the latest GHC and stuff :)
18:03:34 <ddarius> Why get 0 day warez when you can have -150 day warez.
18:04:22 <ion> cale: hah
18:04:46 <rwbarton> put hackage on one, that sounds warez-y enough
18:04:50 <Cale> We could have release groups like PURiTY and HYL0M0RPHiC
18:04:55 <ion> Someone really should do that, that would be pretty funny.
18:04:55 <rwbarton> actually probably a terrible idea
18:04:55 <shachaf> 23:56 <ddarius> @tell shachaf Exercise: Any category that is small and complete is also cocomplete.  Hint: This is a direct generalization of the lattice theoretic result, e.g. the supremum of the empty set is the infimum of the whole lattice.  Extra credit: What is the dark secret of this exercise?
18:05:06 <ion> And have a bot announce any actual downloads to the channel (or #-blah).
18:05:31 <shachaf> ddarius: Now I have to look up what those things are.
18:05:53 <rwbarton> complete = has all limits, cocomplete = has all colimits (indexed by arbitrary diagrams)
18:06:04 <ion> > co "cocomplete"
18:06:06 <lambdabot>   "complete"
18:06:11 <ion> > (co . co) "cocomplete"
18:06:13 <lambdabot>   "mplete"
18:06:18 <Cale> I know the dark secret
18:06:27 <dolio> All small limits.
18:06:28 <shachaf> Don't say the dark secret!
18:07:35 <shachaf> OK, now I need to figure out what limits and colimits are.
18:10:03 <ddarius> If D is a diagram, i.e. a functor, D : I -> C, and K is the constant functor K : C -> C^I, then limits are characterized by Nat(KA,D) ~ Hom(A, Lim D) and colimits by Hom(Colim D, B) ~ Nat(D, KB).
18:10:27 * shachaf suspects there are probably better places to read about this than Wikipedia.
18:11:07 <ddarius> Being complete means having limits for all diagrams where I is a small category.
18:11:12 <monochrom> the definitions of limit and colimit are a bit long. take time, don't rush
18:12:40 * hackagebot exact-combinatorics 0.2.0.4 - Efficient exact computation of combinatoric functions.  http://hackage.haskell.org/package/exact-combinatorics-0.2.0.4 (WrenThornton)
18:18:16 <dgpratt> '']
18:21:24 <YayMe> So back to tying the knot, which my computer crashed before I could read about, any tips on where I might read something that explains it well?
18:23:14 <monochrom> do you understand "a = Vertex 1 [b]; b = Vertex 2 [a]" ?
18:23:15 <ddarius> The Haskell wiki article used to be good.  I have no idea what it says nowadays.
18:24:10 <YayMe> ddarius: Maybe it is good, that's fine, but if it does explain it well I don't think I'm smart enough to do it
18:24:25 <YayMe> monochrom: yes
18:24:43 <shachaf> This picture should help: http://i.imgur.com/Hzqy3.gif
18:24:50 <shachaf> Wait, no, that's Knotting the Tie.
18:25:02 <monochrom> then you already understand a lot of tying knots
18:25:07 <YayMe> haha, appreciated, but as an experienced corporate drone I've got that one down heh
18:25:32 <YayMe> it's the actually useful tying the knot I'm lacking
18:26:35 <YayMe> monochrom: your version is 2 functions which are recursive  (what's that term again for multiple functions creating recursion?)
18:26:51 <monochrom> mutual recursion. but they are not functions
18:27:00 <YayMe> then it's a do statement?
18:27:19 <monochrom> they are values of your tree-like vertex data type
18:28:50 <jmcarthur> knot tying is nothing more than recursion for values instead of functions
18:28:57 <monochrom> you look at the words "tie the knot", you haven't seen it before, so you go "this must be very advanced theory"
18:28:59 <jmcarthur> which is a silly thing to say
18:29:04 <jmcarthur> since functions are values anyway
18:29:14 <shachaf> I'm knot tying anything!
18:29:19 <YayMe> monochrom: No, I looked at the code on the haskell wiki and thought it must be advanced
18:29:25 <monochrom> but if you see "cyclic data", "self reference", "mutual reference", then it's much more boring
18:29:29 <jmcarthur> > let x = 1 : x in x
18:29:30 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:29:40 <jmcarthur> ^^ knot tying!
18:30:00 <jmcarthur> > fix (1:)
18:30:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:30:02 <monochrom> and all the excitement dies away
18:30:02 <jmcarthur> @src fix
18:30:02 <lambdabot> fix f = let x = f x in x
18:30:20 <shachaf> let x f = f 1 x
18:30:24 <shachaf> Is that knot-tying too?
18:30:29 <monochrom> "tying the knot" is just an excited way to say "cyclic data"
18:31:00 <jmcarthur> and "cyclic data" is just an excited way to say "recursion"
18:31:09 <YayMe> shachaf: that looks just like normal recursion to me, no? as long as f calls to x in it's body
18:31:13 <shachaf> And "recursion" is just an excited way to say "recursion"
18:31:15 <YayMe> which I assume it must
18:31:30 <jmcarthur> YayMe: the point is that knot tying *is* normal recursion
18:32:12 <jmcarthur> all you have to unlearn is that recursion isn't limited to functions
18:32:27 <lispy> Recursion: It's not just about functions anymore.
18:32:47 <pnielsen> To understand recursion you must first understand ecursion
18:32:54 <lispy> Okay. Any tips for debugging type class instances that result in <<loop>>?
18:32:57 <rwbarton> you can write mutually recursive values of a sort in C too ("struct list_node y; struct list_node x = {1, &y}; struct list_node y = {2, &x};")
18:33:10 <lispy> Luckly, all the functions have type IO a, so I can use putStrLn
18:33:20 <jmcarthur> rwbarton: right. mutation is the key to "value recursion"
18:33:29 <jmcarthur> the mutation is haskell is just laziness
18:33:32 <jmcarthur> *in haskell
18:33:41 <benmachine> lispy: missing methods that are default-defined in terms of each other?
18:33:46 <shachaf> data Foo a = Foo a (IORef (Foo a))
18:33:52 <lispy> jmcarthur: I guess it depends on how you /thunk/ about it ;)
18:33:57 * cmccann likes corecursion better because the only way to understand it is to figure it out as you go.
18:34:00 <shachaf> This reminds me of ddarius's puzzle about writeIORef semantics.
18:34:05 <jmcarthur> cmccann: lol
18:34:06 <YayMe> jmcarthur: When I read the haskell wiki article it sounded like "tying the knot" is when instead of generating new values each time, you actually manage to fill in the elements of your structure with values that have circular references
18:34:15 <lispy> benmachine: I can double check that
18:34:25 <jmcarthur> YayMe: right. that is the same as what you do with recursive function definitions.
18:34:26 <rwbarton> this example isn't using mutation though
18:34:44 <jmcarthur> YayMe: recursion is just using the thing you are defining in its own definition
18:35:05 <rwbarton> (these were top-level declarations/definitions)
18:35:11 <YayMe> jmcarthur: with recursive functions though I'm generating new values each time rather than reusing previously created values
18:35:27 <jmcarthur> rwbarton: y is initially undefined, then it's defined. is that not mutation?
18:35:33 <rwbarton> in a function I think I need mutation, yes
18:35:34 <jmcarthur> YayMe: you aren'
18:35:34 <whittle> I'm using a libarary (riak) that has many functions that look like `:: Connection -> ... -> IO a` where the ellipsis represents 3 to 6 parameters that vary between functions. I'd like to use those functions within a ReaderT that has a Connection as its environment. Do I need to write a wrapper for each function to get it to work within the ReaderT, or is there a more succinct way?
18:35:36 <jmcarthur> oops
18:35:44 <jmcarthur> YayMe: you aren't generating new functions each time
18:36:08 <rwbarton> jmcarthur: "struct list_node y;" was a declaration of the global variable y and later I provided the initial value
18:36:29 <rwbarton> so here &y and &x are just constants that the linker can fill in
18:36:54 <monochrom> if you define "f x = f (x-1)", and you call "f 10", you can say you're generating a lot of stuff. but one thing you don't re-generate every time: you don't re-generate f, it's reused every time
18:37:01 <rwbarton> anyways this is sort of off-topic
18:37:03 <jmcarthur> rwbarton: ah, i typically (possibly incorrectly) interpret a variable declaration in C-like languages as going ahead and allocating the space and such
18:37:18 <monochrom> note: read it as "f = \x -> f (x-1)"
18:37:32 <jmcarthur> YayMe: what monochrom said!
18:37:41 <shachaf> @quote monochrom
18:37:42 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
18:37:48 <monochrom> so similarly if you write "x = 0 : x", you don't regenerate x
18:38:02 <ddarius> The linker uses mutation.
18:38:09 <hpaste> YayMe pasted “Why is this not tying the knot” at http://hpaste.org/75389
18:38:14 <rwbarton> well, fair enough :)
18:38:34 <shachaf> μtation, eh?
18:38:35 <rwbarton> as does the implementation of laziness
18:38:50 <shachaf> Sounds advanced.
18:38:52 <YayMe> monochrom: how is that snippet not tying the knot?
18:38:54 <ddarius> rwbarton: Indeed.
18:39:43 <shachaf> "Tying the knot" sounds like something out of ring theory.
18:39:56 <jmcarthur> YayMe: if you are trying to define a cyclic data structure, you have failed because you instead defined a cyclic function
18:40:49 <monochrom> yeah, mkDList refers to itself, as opposed to some DList value referring to itself
18:41:18 * lispy instruments all the functions!
18:41:20 <hpaste> jmcarthur annotated “Why is this not tying the knot” with “Why is this not tying the knot (annotation)” at http://hpaste.org/75389#a75390
18:41:23 <shachaf> What does this have to do with DLists?
18:41:38 <shachaf> Oh, DList means "infinite binary tree" now.
18:41:49 <jmcarthur> YayMe: my annotation is intended to demonstrate what you're actually recursing on
18:41:51 * ddarius functions all the instruments.
18:41:54 <rwbarton> whittle: you could probably come up with some type class trickery to reduce the boilerplate
18:42:23 <rwbarton> oh
18:42:48 <YayMe> jmcarthur: Right, makes sense
18:43:06 <rwbarton> whittle: I think I misread at first, the "..." are all function-specific arguments that won't come from the ReaderT?
18:43:14 * YayMe goes back to trying to create a cyclic graph
18:43:16 <whittle> rwbarton: Yes.
18:43:52 <dibblego> is there a known way to get around this "cabal install cabal-install" failure? https://gist.github.com/3791702
18:44:17 <monochrom> consider instead "x = DLNode z 0 y; y = DLNode x 1 z; z = DLNode y 2 x"
18:44:20 <rwbarton> aha, but you want ... -> ReaderT Connection IO a
18:44:47 <whittle> rwbarton: Yes! I think that's what I'm trying for.
18:44:50 <rwbarton> so you still need some magic to move the ReaderT past a variable number of ->s, perhaps
18:46:43 <whittle> Right. I want to transform, let's say `get :: Connection -> a -> b -> c -> IO d` into `:: a -> b -> c -> ReaderT Connection IO d`.
18:46:54 <rwbarton> well, there is a basically mechanical way to produce this sort of type class magic
18:47:11 <shachaf> This sort of type class magic sounds like a bad idea to me.
18:48:02 <rwbarton> class Whittle before after | before -> after where munge :: Connection -> before -> after; instance Whittle IO a (ReaderT Connection IO a) where ...; instance (Whittle b a) => Whittle (e -> b) (e -> a) where ...
18:48:23 <rwbarton> er, first instance should be instance Whittle (IO a) (ReaderT Connection IO a) where
18:48:37 <latro`a> dem flexibleinstances
18:49:02 <rwbarton> I think if you translate to type families (which maybe you should do anyways) the instances aren't even "flexible"
18:49:13 <rwbarton> or rather associated types
18:49:42 <rwbarton> Though, you may need a reverse dependency too depending on how polymorphic the functions you're wrapping are
18:51:03 <rwbarton> you can also just make, for each n, a function to do it for n-arg functions
18:51:48 <rwbarton> ugh, also I meant "munge :: (Connection -> before) -> after"
18:51:58 <monochrom> YayMe: consider "x = 0 : x" vs "f () = 0 : f ()"
18:51:59 <whittle> Okay, that makes sense.
18:53:07 * shachaf should probably study category theory and such properly rather than rely on random snippets that come up in #haskell.
18:54:15 <johnw> shachaf: agreed
18:54:38 <whittle> So munge would just call its first argument, passing in $ ask.
18:55:03 <whittle> Sorry, passing in the result of ask.
18:55:57 <rwbarton> for the "IO a" case, yes
18:56:37 <YayMe> monochrom: I don't understand the difference between those two except there's a match on the second
18:59:17 <whittle> Interesting. Thank you, rwbarton. I have much to think about.
19:01:48 <monochrom> with a sufficiently dumb compiler, the second does not build a cyclic data structure. it generates as many ":" nodes as you demand
19:02:11 <monochrom> the first is a cyclic data structure, constant space, even with a dumb compiler
19:02:53 <monochrom> you may use "f n = 0 : f (n+1)" to make it more obvious
19:03:33 <jmcarthur> "sufficiently dumb compiler"... lovely that we feel the need to say this
19:06:49 <jmcarthur> YayMe: in the first version, x refers to itself in its own definition. in the second version, f refers to itself in its own definition. if you assume that a function body is always duplicated when you apply the function to arguments then the second one will continue to allocate new stuff on the heap as the structure is generated. the first version, however, involves no recursive function applications.
19:09:42 <hpaste> YayMe pasted “cyclical graph” at http://hpaste.org/75391
19:10:09 <monochrom> yes that's a cyclic graph
19:10:24 <YayMe> yes, your explanation about the compiler drove it home
19:11:04 <YayMe> compiler recognizes it as a data structure rather than a function when it meets certain laws and can build the pointers for me which Haskell doesn't let me build
19:12:00 <rwbarton> technically if you turn off the monomorphism restriction it is no longer a cyclic graph :)
19:12:01 <dmwit> uh
19:12:12 <dmwit> no laws involved in distinguishing functions from data structures
19:12:35 <dmwit> Either the top-level type constructor is (->), in which case it's a function, or it's not, in which case it isn't.
19:12:47 <YayMe> then that's the law
19:12:57 <YayMe> heh
19:13:29 <monochrom> compilers go out of their ways to treat (->) special
19:13:33 <shachaf> rwbarton: Are you some kind of operationlist?
19:14:11 <dmwit> Man, what have you got against operational semantics!
19:14:19 <rwbarton> isn't that what we've been discussing?
19:14:41 <monochrom> if you call "(&&) x y", the compiler is not going to "first build the closure for ((&&) x)"
19:14:57 <shachaf> Is it? I haven't been paying attention.
19:17:33 <ddarius> Hagino's compiler doesn't.
19:17:49 <YayMe> is there any reasonable way to make a referential equality check in haskell? Would I have to attach a randomish value to my type?
19:18:18 <Ralith> YayMe: you shouldn't want that.
19:18:34 <YayMe> Ralith: I figured but wasn't certain
19:19:05 <Ralith> YayMe: if you absolutely need values that have no meaning other than so as to be distinct from eachother, use a newtype of Int(eger)
19:19:27 <Ralith> and build them sequentially
19:19:34 <Ralith> what are you actually trying to do?
19:19:54 <monochrom> ghc -O2 does optimize f () = 0 : f () to x = 0 : x
19:20:35 <dmwit> What is a "referential equality check"?
19:21:17 <dmwit> If you want pointer equality, IORef's have an Eq instance (whether they're contained values do or not).
19:21:18 <Ralith> I assumed he meant pointer comparison
19:21:22 <hpaste> YayMe pasted “Can you tell this is circular” at http://hpaste.org/75392
19:21:32 <dmwit> There are also StableNames if you don't mind being GHC-specific.
19:21:51 <YayMe> is it even possible to know that data structure is circular? (granted it's absolutely useless)
19:22:04 <dmwit> Generally speaking, if you want to detect cycles in the heap, you can use one of the many observable sharing libraries from Hackage.
19:22:14 <dmwit> s/can/must/
19:22:18 <shachaf> :-(
19:23:09 <shachaf> YayMe: The usual thing to do is to come up with your own definition of identity.
19:23:21 <dmwit> yes
19:24:36 <YayMe> shachaf: I know, so would the average way in a data structure that allows duplicate values as different elements be to tag on an identity value that exists just to make your "identity" ?
19:24:52 <dmwit> yes
19:25:12 <asd_> fuck this shit !
19:25:19 <YayMe> data Vertex a = Vertex a [Vertex a] Int
19:25:29 <Ralith> YayMe: why do you want that?
19:26:30 <shachaf> type Graph = [(Int,Int)]
19:27:03 <YayMe> Ralith: if I put a rand (or some other unique bit like an incrementor) into the Int I could have multiple Vertexes have the same value while still being able to test for circular
19:27:27 <Ralith> YayMe: as shachaf said, use an observable sharing library for that.
19:27:33 <shachaf> Huh?
19:27:36 <benmachine> I enjoyed asd_'s contribution
19:27:38 <shachaf> I didn't say that and I don't recommend that.
19:27:38 <Ralith> oh, sorry
19:27:40 <Ralith> dmwit
19:27:50 <shachaf> dmwit said that that's the only way to do it given certain constraints.
19:27:58 <Ralith> yes.
19:27:58 <benmachine> observable sharing is scary
19:28:01 <shachaf> I don't think he's recommending those constraints either.
19:28:02 * Ralith recommends not reinventing wheels, especially stochastically.
19:28:13 <dmwit> I am indeed not.
19:28:32 <Ralith> perhaps those constraints weren't clear to me
19:28:44 <shachaf> Ralith: Observable sharing is rarely the solution to your problems.
19:28:50 <dmwit> I think you should rearrange your program so that you don't need to detect cycles in the heap.
19:28:54 <Ralith> shachaf: nor detecting cycles.
19:28:59 <YayMe> benmachine: I don't know how to use ! in haskell but i think _asd's contribution was syntactically incorrect
19:29:01 <shachaf> I suspect it's never the solution to problems you have before you know what observable sharing is.
19:29:01 <Ralith> yes, precisely.
19:29:03 * ddarius comes up with his own definition of reality.
19:29:39 <benmachine> YayMe: enjoyable nonetheless
19:29:41 <shachaf> Ralith: Identity is useful.
19:29:46 <Ralith> shachaf: very!
19:30:08 <YayMe> Ralith: I wouldn't be creating a structure for use, I'm just trying to learn to create them
19:30:22 <Ralith> YayMe: well, now you know!
19:30:38 <jmcarthur> i wish it was more convenient to perform substitutions in graphs in pure code without expanding them to trees, somehow
19:30:58 <YayMe> Ralith: so given my scenario, would someone trying to use the structure do it similar to me, or use some magical referential equality tester?
19:31:35 <Ralith> YayMe: magical referential equality testing isn't even feasible, iirc.
19:31:41 <shachaf> Referential equality?
19:32:13 <startling> YayMe, you could write all the interesting bits in C
19:32:30 <YayMe> Ralith: oh, I thought someone was saying stuff on hackage would do that, but the stuff on hackage just puts an identity field onto the structures instead or something doesn't it?
19:32:46 <Ralith> that was my assumption, at least.
19:32:49 <jmcarthur> e.g....    data F a = Leaf a | Branch [F a]    x = let r = Leaf 1; a = Branch [r,r,r,r,r,r] in x >>= someFunction
19:32:52 <dmwit> shachaf: I think they mean "reference equality".
19:33:07 <shachaf> Oh.
19:33:25 <Ralith> don't look at me, I'm just using YayMe's words here
19:34:02 <Ralith> YayMe: I believe a moving GC would make any attempts to do something like that very fragile.
19:34:05 <Ralith> at best.
19:34:28 <jmcarthur> YayMe: you can get identities with StableName, but it requires IO and doesn't guarantee that you will always get the same name for the same object (in particular, it might have a different identity before evaluation from after evaluation)
19:35:05 <jmcarthur> Ralith: that's why we have StableName
19:35:18 * dmwit notes that he suggested both IORef and StableName fifteen minutes ago when this first started
19:36:03 * Ralith thought YayMe was wondering if an approach without those measures existed.
19:36:16 <Ralith> otherwise, indeed, you answered his question 15 minutes ago.
19:37:42 <YayMe> Ralith: I was wondering if those measures were possible, also I'm wondering if thos measures would be more commonly used than my hand spun identity attribute
19:38:16 <benmachine> STRef has equality too
19:49:07 <dibblego> drdo: are you drdro?
19:50:03 <dibblego> I am having the same problem as http://hpaste.org/70161 but the solution discussed is in Russian — http://chatlogs.jabber.ru/haskell@conference.jabber.ru/2012/06/19.html — I only speak haskell
19:53:48 <ew0> can you use parsec to parse russian?
19:54:18 <dolio> ddarius: Does a complete category have all small ends?
19:54:22 <dibblego> I do not have parsec installed in my brain
19:54:29 <dmwit> dibblego: Delete one or the other instances...?
19:54:36 <dibblego> :(
19:54:42 <dmwit> say, the one in src/Control/Monad/Base.hs
19:54:51 <dibblego> I am doing a fresh install :(
19:55:00 <dolio> Wait, of course it does.
19:55:10 <ddarius> dolio: I would think so.  You can define ends in terms of limits and I don't think the intermediate category you need is large.
19:55:10 <dolio> I'm an idiot.
19:55:19 <dibblego> of course it does?
19:55:48 <dolio> End is a limit of F : C^op x C -> D.
19:55:49 <rwbarton> it's an equalizer of two maps between products indexed on the index category of the end
19:56:01 <dolio> Wait, no.
19:56:34 <shachaf> Cale: Is recent State for lambdabot up anywhere?
19:57:31 <dolio> But, okay, I believe it.
19:58:15 <ddarius> http://ncatlab.org/nlab/show/category+of+elements
19:58:27 <rwbarton> or rather one product is indexed on the objects and the other product on the morphisms of the index category of the end
19:59:38 <maukd> http://translate.google.de/translate?sl=auto&tl=en&js=n&prev=_t&hl=de&ie=UTF-8&layout=2&eotf=1&u=http%3A%2F%2Fchatlogs.jabber.ru%2Fhaskell%40conference.jabber.ru%2F2012%2F06%2F19.html
19:59:58 <dibblego> I just modified the source
19:59:59 <copumpkin> oh man, I might have a misnomer in the categories library
19:59:59 <copumpkin> I called the category of elements the grothendieck construction
20:00:03 <copumpkin> the horror!
20:00:29 <ddarius> I think it's a discrete version of the Grothendieck construction.
20:00:37 <copumpkin> yeah
20:00:42 <copumpkin> but mine isn't general enough to deserve its name!
20:01:10 <ddarius> Yes, usually just "Grothendieck construction" means the general version.
20:02:50 <ddarius> Proposition 1 in X.5 in Mac Lane.
20:02:54 <bgamari> Do the major lens libraries incur any runtime overhead or is this all resolved at compile time?
20:02:56 <ddarius> Er IX.5
20:09:42 <jasonkuhrt> Has anyone seen haskelllive.com?
20:09:54 <jasonkuhrt> seems nice for semi-beginners
20:11:44 <shapr> Does anyone remember if test-framework or HTF support replaying failed QuickCheck properties on the next test run?
20:13:35 <donri> shapr: test-framework has a --test-seed and will print the seed used on QC failure
20:15:31 <ddarius> shapr: Apparently either SSAS or SSRS uses a BGR convention for colors.
20:16:24 <donri> jasonkuhrt: three L's? really?
20:17:13 <shapr> ddarius: That's exciting.
20:17:31 <jasonkuhrt> donri: not ideal
20:17:31 <dmwit> donri: Three L's is weird, but any other number would be weirder.
20:17:43 <donri> dmwit: how about a hyphen? :)
20:17:51 <jasonkuhrt> donri: maybe
20:18:03 <jasonkuhrt> donri: would be better
20:18:06 <ddarius> haske---ive.com would make no sense.
20:18:06 <dmwit> livehaskell.com, maybe
20:18:22 <donri> ^_^
20:18:23 <ddarius> haskelldead.com.  Problem solved.
20:18:25 <jasonkuhrt> haskell-live.com
20:18:40 <copumpkin> haskelllloyd
20:19:00 <YayMe``> That haskelllive seems neat, actually when I first started learning haskell after reading LYAH one thing that helped was digging around on GitHub and finding some other learners attempt at creating a MUD like console game
20:19:18 <copumpkin> say your name is lloyd haskell, and you like having your last name first
20:19:33 * ddarius always learns the best tricks and idioms from beginners' code.
20:19:45 <donri> copumpkin: Lloyd L. Haskell
20:19:50 <copumpkin> oh yes!
20:19:56 <aristid> copumpkin: isn't haskell a valid first name, too?
20:19:58 <ddarius> Lloyd Loftus Haskell
20:20:00 <YayMe``> ddarius: Err? what?
20:20:02 <donri> haskelllololtrololoolol
20:20:04 <copumpkin> aristid: yeah, but I need something starting with it
20:20:21 <aristid> copumpkin: i said valid _first_ name
20:20:34 <copumpkin> aristid: yeah, but find me a last name that starts with ll
20:20:46 <aristid> copumpkin: why not just LLoyd?
20:20:47 * cmccann is pretty sure that Haskell is a valid first name, yes.
20:20:58 <cmccann> what with who the language is named for and all.
20:21:01 * ddarius is pretty every name is a valid first name.
20:21:10 <aristid> ddarius: you're pretty?
20:21:34 <dmwit> To quote Louis: "There are no laws about what you can name your kid. ... there ought to be a COUPLE of laws."
20:22:09 * ddarius plans to name his kids with UUIDs.
20:22:13 <dmwit> http://www.youtube.com/watch?v=4u2ZsoYWwJA
20:22:22 <johnw> ddarius: future-proofing?
20:22:39 <copumpkin> aristid: it just seems more common as a first name :P
20:22:42 <copumpkin> should label your IUDs with UUIDs and avoid kids altogether
20:22:45 <YayMe``> dmwit: I knew someone whose parents last name were Johnson and so they purposely named their son James Richard
20:23:41 <aristid> copumpkin: http://en.wikipedia.org/wiki/Lloyd_(surname)
20:23:47 <copumpkin> fair enough, you win
20:24:10 <aristid> an important fight, won bravely!
20:24:35 <aristid> ddarius: i'd name my kids with SHA-512s
20:24:58 <aristid> if they're twins might happen that they get the same name
20:25:29 <ddarius> Oo, content-based addressing of children by hashing their DNA.
20:26:01 <aristid> that way i can also easily put them under version control
20:26:42 <donri> and revert them when they start to become more annoying than cute
20:26:47 <pnielsen> just read from /dev/random and give your kids cryptographically random names
20:27:32 <mapreduce> You can solve the twin problem with a time-based salt.
20:27:42 <mapreduce> assuming.. er, nevermind
20:28:11 <pnielsen> use a linked list to resolve bucket collisions
20:28:31 <mapreduce> He's ae234238fbc, but we call him 'head' for short.
20:29:16 * YayMe put a gps chip in his kid, his name changes based on location
20:30:24 * ddarius wonders if you can have the legal name for a person be a QR code.
20:30:25 <whittle> mapreduce: Your other kids don't mind being referred to collectively as 'tail'?
20:30:56 <pnielsen> ddarius: just encode it in base64
20:30:58 <mapreduce> Well, there's cadr, caddr and cadddr.  We decided to stop after that.
20:31:10 <mapreduce> (I probably got those wrong)
20:31:12 <ddarius> pnielsen: No. Not an encoding.
20:32:06 <kkwang> hi,guys
20:32:08 <pnielsen> a real name with Reed-Solomon encoding would be pretty funny
20:32:33 <kkwang> ok
20:32:34 <shachaf> @quote monochrom flies
20:32:35 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
20:32:36 <shachaf> @quote monochrom flies
20:32:37 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
20:33:03 * ddarius makes a QR code that encodes an image of a QR code.
20:34:17 <copumpkin> and the internal QR code should encode "yo dawg"
20:34:57 <pnielsen> BBBBBBBriannnnnnnnnnnnnnnnnn
20:36:02 <rwbarton> can you make a QR code that encodes (a PNG file of) itself?
20:37:20 <pnielsen> you'd need extra space for error correction
20:39:05 <pnielsen> you can make QR codes that resemble an image. You could probably make a QR code that resembles itself
20:39:27 * ddarius is pretty sure everything resembles itself.
20:40:46 <mapreduce> pnielsen: Can you make a QR code that does not resemble itself?
20:41:19 <pnielsen> that's the joke
20:42:48 <dmwit> Can you make a QR code that resents itself?
20:42:58 <latro`a> "fruit flies like a banana" <3
20:43:00 <latro`a> totally stealing this
20:43:20 <shachaf> That's a very old one.
20:43:26 <latro`a> I bet
20:43:27 <latro`a> but still
20:43:39 <dmwit> You want to hear some more in that vein?
20:43:42 <ddarius> Proofs done?
20:43:49 <latro`a> sure, why not
20:44:25 <dmwit> http://dmwit.com/geocities/jokes06.htm
20:44:33 <dmwit> From my AIM profile when I was 13. =P
20:46:28 <dibblego> https://gist.github.com/3792032 can this compile/installation error easily be resolved?
20:47:27 <dmwit> I guess you'd need to look at the code and find out which fold it's expecting to use and where that fold has gone.
20:48:05 <dibblego> yeah but it's completely gone!
20:48:26 <dibblego> http://hackage.haskell.org/package/bytestring click on Data.ByteString.Lazy.Internal
20:48:26 <dmwit> What is "it"?
20:48:29 <mapreduce> dmwit: I think you'd have liked Tommy Cooper (assuming you would have understood him)
20:48:54 <dmwit> Data.Bytestring.Lazy has both foldl and foldl'.
20:49:08 <dibblego> neither of those are related to foldlChunks
20:49:11 <dmwit> ...and foldlChunks
20:49:58 <pnielsen> anyway, go for it
20:50:10 <pnielsen> if you can create a QR quine you'll probably have solved some hard comp.sci. problem
20:50:11 <dibblego> I have bytestring-0.9.2.1 installed
20:50:36 <dibblego> something in the dependency graph is requiring it
20:51:04 <dibblego> (and there is no foldlChunks here)
20:51:09 <dmwit> mapreduce: this guy is silly =)
20:51:43 <acyed> putStrLn . fst . head x , where x is of type ([Char], [Char])... am I not understanding this dot notation?
20:52:07 <shachaf> acyed: (putStrLn . fst . head) x
20:52:07 <whittle> rwbarton: Does this look right? instance Whittle (IO a) (ReaderT Connection IO a) where munge f = ask >>= liftIO . f; instance (Whittle b a) => Whittle (e -> b) (e -> a) where munge f = munge . flip f
20:52:22 <acyed> awesome! thanks!
20:53:12 <dmwit> ...not if it has the type he said it has
20:54:31 <dmwit> dibblego: Well, either use toChunks and roll your own foldlChunks or try installing with a "bytestring >= 0.10" constraint and see what fails.
20:54:35 <acyed> sorry, it was of type [([Char, Char])]. Thanks again for the quick help
20:55:07 <acyed> [([Char], [Char])]...
20:55:15 <acyed> i'll get it right eventually
20:55:17 <dibblego> dmwit: I am having to --constraint="network < 2.4" so that cabal-install installs — so I am going to try some other gymnastics first
20:56:18 <rwbarton> whittle: if it compiles, I think it must be right :)
20:57:47 <dibblego> ok I can get hashable installed so long as I don't update cabal-install and vice versa
20:58:22 <osa1> how can I get a infinite list full of some element a, I thought of using [a..], but a is not an instance of Enum
20:58:35 <dibblego> osa1: repeat
20:58:43 <osa1> dibblego: thanks
20:58:47 <dibblego> np
21:03:20 <whittle> Awesome.
21:03:52 <monochrom> [a..] means completely something else
21:03:58 <monochrom> > ['x'..]
21:04:00 <lambdabot>   "xyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\14...
21:04:20 <dmwit> > ['x','x'..] -- not that different if you correct the obvious error
21:04:22 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
21:04:22 <monochrom> totally not full of 'x'
21:04:28 <monochrom> hrm, darn
21:06:09 <aristid> monochrom: the infinith element is totally greater than 'x'
21:06:34 <pharaun> > ['0'..]
21:06:36 <lambdabot>   "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx...
21:07:10 <latro`a> acyed: also common is putStrLn . fst . head $ x
21:07:14 <latro`a> which means the same thing
21:07:34 <johnw> ['ا'..]
21:07:37 <johnw> > ['ا'..]
21:07:39 <lambdabot>   "\1575\1576\1577\1578\1579\1580\1581\1582\1583\1584\1585\1586\1587\1588\158...
21:07:42 <johnw> heh
21:08:04 <latro`a> "putStrLn . fst . head x" doesn't work because function application is tighter than any infix operator, so you get "putStrLn . fst . (head x)" which doesn't typecheck for obvious reasons
21:08:17 <shachaf> @quote mauke What
21:08:18 <lambdabot> mauke says: data What a = No; instance Monad What where { return _ = No; No >>= _ = No }
21:08:28 <latro`a> lol
21:09:21 <latro`a> data Who what = Where; instance When Who where why = how
21:11:07 <acyed> I guess I'm not seeing the head of the obvious reasons. Isn't the head of x a tuple that fst can consume?
21:11:45 <dmwit> The head of x is a tuple that fst can consume, yes.
21:11:53 <dmwit> But the head of x is not a function that (.) cand compose with fst.
21:12:12 <monochrom> "fst . (head x)" says something different
21:12:32 <acyed> ah! that makes sense. (.) has to compose functions, not functions and values. That's where my thinking was wrong
21:13:00 <acyed> (right?....)
21:13:17 <monochrom> right
21:13:54 <monochrom> this is why I never use $ on beginners, and sometimes I use extra parentheses
21:14:09 <acyed> you guys rock. Coming from a C background to Haskell is not easy
21:14:30 <shachaf> (f . g) x = f (g x)
21:15:08 <monochrom> and I always say "calculate, do not think", e.g., calculating using (f . g) x = f (g x)
21:15:26 <maukd> (fst . head x) y = fst ((head x) y)
21:16:04 <latro`a> which, if head x is actually a list of functions with the right type, actually makes sense ;)
21:16:12 <latro`a> err
21:16:18 <latro`a> if x is actually a list of functions with the right type
21:16:19 <acyed> x would have to be a function that... ah, beat me too it
21:16:35 <acyed> to*
21:17:08 <acyed> I think the hardest thing for me so far has been the change from for loops to recursion
21:17:27 <latro`a> you get used to that, and actually more often than not you don't use explicit recursion anyway
21:17:42 <latro`a> most iterative control constructs are already available as operations on lists or as monadic functions
21:19:00 <acyed> that's the other hurdle: getting familiar with the large list of functions available
21:19:15 <latro`a> eh, that happens in most higher level languages
21:19:20 <latro`a> and, frankly, happens in C too
21:19:25 <latro`a> if you go far enough down the rabbit hole
21:19:31 <dmwit> This must be the first time I've heard somebody complaining that Haskell has too large of a library.
21:19:32 <acyed> I'm sure it come's with time... but time is of the essence!
21:19:35 <dmwit> Usually the complaint is the other way.
21:19:39 <latro`a> I don't think it's complaining
21:19:46 <latro`a> it's just....daunting, a bit, at first sight
21:19:53 <latro`a> Data.List is kinda ridiculous
21:20:36 <acyed> I know it's all on line, but I ordered the Haskel 98 revision 2 book today. Hopefully having something in front of me will help
21:21:49 <dmwit> There's a book?
21:22:27 <acyed> yep, http://www.amazon.com/Haskell-98-Language-Libraries-Revised/dp/0521826144
21:23:03 <shachaf> dmwit: You have to make the SML immigrants feel at home.
21:23:28 <acyed> Small Minded Language ?
21:23:42 <shachaf> Standard ML
21:24:08 <shachaf> You know the latest version of Haskell isn't 98 anymore, right? :-)
21:24:33 <aristid> somebody's gotta tell bob harper the new backronym for his favorite language :P
21:24:52 <acyed> yeah, but's it all I could find
21:25:16 <scshunt> latro`a: and yet every time I code in Scheme I miss it
21:25:26 <scshunt> "you mean I have to write intercalate?"
21:26:03 <latro`a> I think people get used to it pretty quick, and it becomes more standard idiom than explicit control
21:29:55 <latro`a> I for one have more trouble with explicit control than with functional list processing now :/
21:37:57 <ddarius> intercalate wasn't in the libraries when I started doing Haskell.
21:38:07 <ddarius> They just quietly added it at one point.
21:38:32 <johnw> i always confuse intersperse with intercalate
21:38:38 <pnielsen> probably after "join" popped up everywhere
21:38:41 <dibblego> yeah I had it written a few times before I noticed
21:54:41 <ddarius> The worst thing was when they changed the Monoid instance for functions.
21:55:15 <dibblego> was it once instance Monoid (a -> a) ?
21:55:20 <ddarius> Yes.
21:55:47 <dibblego> are you now a foldr (.) id kind of guy or Endo/appEndo?
21:56:19 <ddarius> It hasn't come up that much, but probably the former.
21:57:44 * hackagebot random-fu 0.2.3.1 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.3.1 (JamesCook)
21:57:55 <ddarius> But having mconcat suddenly have a rather different meaning in a very common usage confused the fuck out of me for quite a while when I returned to some old code.
22:00:11 <mm_freak_> the Monoid instance seems to be based on Applicative now
22:00:18 <mm_freak_> mempty = pure mempty
22:00:24 <mm_freak_> mappend = liftA2 mappend
22:00:25 <ddarius> I have an odd number of pens.
22:00:40 <lightquake> every time i use cabal-dev i type 'cabal install' and break everything
22:00:49 <mm_freak_> that's also about the most sensible (in terms of usefulness) i can come up with
22:03:16 <johnw> lightquake: alias your cabal so that if a cabal-dev directory exists in the current directory, it uses the cabal-dev exe, otherwise cabal
22:07:33 <lightquake> what exactly is the point of makeClassy in Control.Lens?
22:08:00 <johnw> for a given Foo, it also makes the HasFoo class
22:08:46 <lightquake> right, but why?
22:08:55 <johnw> well, for that answer we need edwardk
22:09:08 <johnw> but one thing I use it for is exports
22:09:09 <johnw> HasFoo(..)
22:09:13 <johnw> will export all the lenses for Foo
22:19:33 <Ralith> is there a good library out there for constructing and then sampling gaussian and/or pearson distributions?
22:20:00 <ddarius> @hackage statistics
22:20:00 <lambdabot> http://hackage.haskell.org/package/statistics
22:22:35 <shapr> ddarius: seen https://github.com/HackerFoo/peg ?
22:23:39 <ivanm> Cale: you around?
22:23:44 <ddarius> shapr: Can I use you as a service to deliver hugs to people?
22:24:02 <shapr> ddarius: Sounds good to me :-)
22:24:09 * shapr hugs ddarius 
22:24:21 <shachaf> What does it take to get a hug from ddarius? Do you have to write a paper?
22:24:23 <ivanm> Ralith: statistics ?
22:24:24 <ddarius> shapr: That looks interesting.
22:25:13 <Ralith> ivanm: that's what ddarius just pointed me at; looks promising, but I don't see pearson, or for that matter a 'sample' function.
22:25:23 <ivanm> oh, missed that
22:25:29 <ivanm> what do you mean by "sample" ?
22:25:44 <ivanm> Hayoo says to look in hstats for pearson
22:25:52 <ivanm> but if memory serves, hstats is bitrotten
22:26:20 <ivanm> Ralith: the documentation for chi2test in statistics says it's a generic form of pearson; same thing as you're after?
22:26:22 <Ralith> well, what I want to do is create various continuous distributions, then obtain a pRNG that emits results according to them.
22:26:42 <ivanm> otherwise bindings-levmar, hmatrix-gsl-stats, statistics-linreg
22:26:45 <ivanm> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=pearson
22:27:13 <Ralith> ivanm: hm, maybe
22:27:29 <Ralith> I'm not looking for a particular distribution so much as the ability to specify certain characteristics
22:27:46 <Ralith> in this case, what I want is a gaussian distribution which I can skew
22:27:56 <ddarius> http://hackage.haskell.org/packages/archive/statistics/0.10.2.0/doc/html/Statistics-Distribution.html#t:ContGen
22:28:12 <Ralith> ah, great
22:33:57 <Ralith> ivanm: doesn't look like chi² is really the right thing; I may have misjudged pearson, even.
22:34:14 <theplanet> m´ttadvoce youu agaiknst it
22:34:27 <ivanm> theplanet: come again?
22:34:40 <johnw> can anyone else git clone http://darcs.haskell.org/ghc.git/?
22:34:47 <Ralith> ..oh, there's actually a 'skew normal distribution'
22:34:53 <theplanet> ivanm, oh sorry.
22:34:58 <johnw> it's just returning to the prompt without doing anything for me
22:35:10 <ivanm> johnw: isn't it on github now?
22:35:18 <johnw> that mirror is now 1 month out of date
22:35:33 <johnw> i wanted to try out holes in 7.7
22:38:40 <johnw> at least the master branch is
22:38:48 <johnw> but maybe that's not entirely relevant?
22:38:56 <johnw> the type-holes-branch is only 10 days old
22:39:28 <ivanm> I thought holes wasn't merged in yet anyway
22:39:31 <ivanm> (from SPJ's talk)
22:39:58 <shachaf> johnw: `git pull` works fine for me.
22:40:46 <ivanm> IIRC, when ghc was still on darcs the recommendation was to download a tarball snapshot and then darcs pull from that
22:40:54 <ivanm> maybe the same thing with it being on git?
22:41:02 <ivanm> (which is why git pull works, but not clone)
22:51:37 <johnw> huh
23:01:38 <lispy> I don't really understand why they didn't want to use github
23:01:41 <lightquake> wait, ghc is getting holes? hot damn
23:02:00 <lispy> I think the attempt to use it was half-assed and repeled people from using it more
23:07:09 <Ralith> blah none of those distributions subsume skew normal
23:14:41 <dolio> ddarius: Ah, finally figured out the nice way of saying it.
23:14:48 <dolio> Colim = Ran K Id
23:17:46 * hackagebot misfortune 0.1.1.1 - fortune-mod clone  http://hackage.haskell.org/package/misfortune-0.1.1.1 (JamesCook)
23:23:26 <ivanm> mokus: does misfortune read data files on the system, or does it need to be compiled in?
23:24:17 <ivanm> oh, right, README says it can index them
23:26:26 <ivanm> though IIUC, fortune itself doesn't require any indexing
23:26:55 <mokus> it can run with or without indexing
23:27:11 <mokus> bsd fortune requires indexing, unless there's a newer version than the one I'm used to
23:28:57 <startling> can I use some template haskell thing to derive a specific lens from a specific field of a data type?
23:29:18 <startling> I want to do "someLens = makeLens '_someLens"
23:29:43 <startling> I guess this is difficult because haskell has no idea whether a function is a field or what
23:38:59 <fmap> startling: you can supply custom mapping with makeLensesFor
23:43:41 <startling> fmap: oh, neat
23:44:13 <startling> I'm experimenting with a typeclass whose methods are some lenses, though. can I use makeLensesFor with an instance declaration?
23:54:15 <mysticc> What do you use for syntax highlighting haskell code in latex ?
23:54:57 <alpounet> pandoc?
23:55:04 <alpounet> :p
