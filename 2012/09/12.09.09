00:00:04 <mikeplus64> on x86_64 too
00:00:11 <Cale> (however, there are many concrete categories which are not small)
00:00:14 <Jafet> In any case, I believe using Double just works by accident
00:00:20 <mikeplus64> alright
00:02:18 <Cale> Sorry, I could have said that more clearly: [X] is the set of all arrows, from any object T in C, to X
00:03:19 <scshunt> Cale: isn't there a notation like Hom(*, X) or something for that?
00:03:33 <Nereid> Cale: I make a distinction between concrete categories and concretizable categories.
00:04:06 <Cale> Well, Hom(-,X) is usually not just a set itself, but a functor. I guess you could take Hom(*,X) to be the whole set all at once.
00:04:23 <Nereid> the former being a category C with a particular choice of faithful functor C -> Set
00:04:25 <Cale> Nereid: and well you should :)
00:04:28 <Nereid> :)
00:05:22 <mikeplus64> in http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-130003.3 , there are a number of calling conventions, which are supported by ghc (and where do i look?)
00:06:17 * scshunt enjoys the concept of concretizable large categories
00:06:18 <shachaf> The GHC manual?
00:06:33 <Nereid> scshunt: what about them in particular?
00:06:40 <scshunt> it just tickles is all
00:06:48 <Nereid> Set is a concretizable large category.
00:07:03 <scshunt> it's concrete though
00:07:18 <scshunt> so it doesn't really count :P
00:07:28 <Nereid> it can be made concrete via the identity functor, clearly.
00:07:57 <Nereid> so, what does count?
00:08:08 <Cale> There are a lot of concrete large categories. I can't think of any off-hand which are concretizable, but not a-priori concrete.
00:08:39 <Nereid> certain quotient categories perhaps?
00:09:15 <Cale> Yeah, something like that perhaps, where we can be forced into using the axiom of choice
00:09:24 <Cale> lol, or global choice?
00:09:27 <Nereid> well not just any quotient
00:09:34 <Nereid> some quotients of concrete categories aren't concretizable.
00:09:39 <Nereid> e.g. the homotopy category
00:10:04 <mikeplus64> shachaf: http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html doesn't say exactly
00:11:27 <Cale> mikeplus64: I guess you just try them? Obviously dotnet is unlikely to work.
00:11:31 <Cale> (or jvm)
00:11:35 <mikeplus64> yeah
00:11:47 <Cale> ccall is the usual one to use, and it works
00:11:55 <Cale> I believe stdcall also works
00:11:58 <scshunt> Take the category of all sets ordered by size.
00:12:05 <scshunt> with the ordering as the arrows
00:12:08 <mikeplus64> i've only seen ccall and stdcall in actual use i think
00:12:38 <Nereid> scshunt: huh?
00:13:07 <Cale> mikeplus64: I'd be somewhat surprised if cplusplus is implemented.
00:13:10 <Nereid> so there is a (unique) arrow A -> B iff |A| <= |B|?
00:13:25 <mikeplus64> Cale: according to http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-130003.3, "Any implementation of the Haskell 98 FFI must at least implement the C calling convention denoted by ccall. All other calling conventions are optional. "
00:13:31 <Cale> mikeplus64: right
00:13:39 <Nereid> sounds silly
00:13:44 <scshunt> Nereid: yeah
00:14:29 <Cale> I don't know if that's even concretisable now
00:14:29 <Nereid> I want to say it's concretizable but I'm worried that the proof I have in mind does something you're not allowed to do.
00:14:42 <Nereid> i.e. well-order every set.
00:14:46 <Cale> It is, clearly, if we allow global well-ordering
00:14:49 <Nereid> yeah.
00:14:54 <scshunt> I think you can do it without
00:15:05 <scshunt> if what you mean is well-order all sets
00:15:19 <scshunt> I accept that each set is well-orderable, since that comes from choice
00:15:22 <Cale> scshunt: well-order all sets in a consistent way from set-to-set
00:15:27 <scshunt> Cale: Yeah
00:15:29 <Cale> i.e. well order Set
00:15:37 <scshunt> Ah, no, I don't think you need that
00:15:46 <Nereid> no no.
00:16:40 <Cale> Actually, I can see how you can do it with global choice
00:16:50 <Cale> which is a little weaker than global well-ordering
00:17:14 <scshunt> Hmm... I think you can do better.
00:17:26 <scshunt> Oh.. wait.
00:17:29 <scshunt> Hrmmmm
00:17:29 <Cale> Pick one element from every nonempty set, and pick the map A -> B to be the constant function into the specially chosen element of B
00:17:42 <Nereid> it looks equivalent to global choice, actually
00:17:51 <Nereid> yeah
00:17:53 <Cale> oh yes
00:17:54 <Cale> it is
00:17:55 <Cale> hah
00:18:05 <scshunt> why does that require global choice?
00:18:07 <Cale> You have an arrow 1 -> A for every A
00:18:10 <Nereid> ^
00:18:33 <Nereid> (except A empty)
00:18:34 <Cale> well, assuming that the concrete representation of 1 is indeed a 1-element set
00:18:34 <Cale> lol
00:18:41 <Nereid> ah, heh.
00:18:42 <Cale> yeah, every nonempty A
00:19:46 <Cale> but so long as the representation of 1 is nonempty, then you can pick an element from it, and then get global choice
00:19:52 <Cale> errrr
00:19:59 <Cale> not really
00:20:15 <scshunt> I still don't understand why global choice is needed
00:20:16 <Cale> You get a weird global choice from among the representations of sets
00:20:43 <Cale> So maybe not something which is really global choice
00:20:47 * hackagebot filemanip 0.3.6.2 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/filemanip-0.3.6.2 (BryanOSullivan)
00:20:48 <Nereid> if C is our weird category, then the existence of a functor C -> Set that is the identity on objects is equivalent to global choice.
00:21:17 <Cale> We should call C = Card
00:21:24 <Nereid> no we shouldn't.
00:21:27 <Cale> It's the preorder category of cardinalities
00:21:42 <Nereid> I wouldn't call them cardinalities.
00:21:43 <Cale> oh, no it isn't
00:21:45 <Cale> lol
00:21:53 <scshunt> Set_Card
00:22:04 <Cale> The skeleton of this category is the category of cardinalities
00:22:11 <Nereid> sure.
00:22:29 <scshunt> Nereid: why is it equivalent?
00:22:31 <Cale> So it's the category of cardinalities, morally
00:22:37 <Cale> lol
00:23:00 <scshunt> I'm just a poor undergrad; throw me a bone :P
00:23:16 <Cale> scshunt: Because if the image of 1 under the functor C -> Set is indeed a one-element set
00:23:17 <Nereid> scshunt: because if F: C -> Set is such a functor, then you pick a 1-element set 1. then for any nonempty set A, you get an element of A given by the image of F(1 -> A)
00:23:58 <scshunt> hmm
00:24:08 <Cale> I kinda like global well-ordering as an axiom anyway.
00:24:18 <Nereid> here's an idea.
00:24:22 <scshunt> still failing to see how that implies global choice
00:24:33 <scshunt> you have gotten an element of A, but isn't that regular choice?
00:24:43 <Nereid> we have gotten an element of A for every nonempty set A.
00:24:47 <Nereid> all at once.
00:25:08 <Cale> (not just a set of nonempty sets, but the proper class of all nonempty sets)
00:25:20 <Nereid> yeah.
00:25:29 <scshunt> ah ok
00:25:42 <scshunt> am confusing weak and strong global choice with regular choice apparently :)
00:26:31 <scshunt> (personally I am a fan of infinitely leveled systems but they are rather mathematically uninteresting)
00:26:59 <Nereid> I don't find too much pleasure in thinking about foundations.
00:27:27 <Cale> I occasionally love foundations, and at other times find it somewhat obnoxious.
00:27:38 <scshunt> I'm taking a (graduate-level) set theory & model theory course next term and looking forward to it
00:27:47 <Nereid> good for you. :P
00:27:56 <Cale> Model theory is cool
00:28:30 <scshunt> Nereid: it's rather common for undergrads to take graduate courses here; the line is somewhat blurred.
00:28:40 <scshunt> at least, in the pure math department
00:28:40 <Cale> But, like, 95% of the proofs are by induction on the structure of statements or proofs, and it becomes a little annoying :)
00:28:50 <Nereid> scshunt: I'm not surprised. I took some graduate courses as an undergrad as well.
00:28:56 <Cale> Oh, you're at the same uni I went to :)
00:29:06 <Ralith> my univ has a lot of crosslisted CS courses, it's pretty awesome
00:29:11 <Cale> (just noticed your host :)
00:29:11 * Nereid <- graduated from Calgary
00:29:16 <Cale> Waterloo
00:29:39 <Nereid> oh.
00:29:41 <Cale> scshunt: Who is your prof for Mathematical Logic?
00:29:51 <Nereid> I've been meaning to ask this, but
00:29:58 <scshunt> Cale: Moosa
00:30:02 <scshunt> only one who teaches the course
00:30:17 <scshunt> Nereid: Calgary's my hometown; have a few friends there.
00:30:23 <Nereid> cool.
00:30:28 <Nereid> anyway.
00:30:35 <scshunt> (honestly, "pure math department" is close to a giveaway as well :P)
00:30:44 <Nereid> oh, lol
00:31:04 <Nereid> how hard would it be to get into, say, a PhD program in CS, given that my education is in math and physics?
00:31:16 <Nereid> (and I took, uh, one CS course as an undergrad.)
00:31:39 <scshunt> Depends on what you're after. If you wanted to do security, probably you'd have trouble. If you were doing theoretical work, probably not a serious issue.
00:31:51 <Cale> Nereid: I have no idea in reality, but I've been told that it's not a problem, and may even be an advantage.
00:31:56 <Nereid> hmm.
00:32:15 <Nereid> scshunt: yeah I was thinking more theoretical work. :P
00:32:20 <scshunt> crypto would be totally doable too
00:32:21 <Jafet> Computational foo
00:32:38 <scshunt> Cale: Where are you now?
00:32:39 <Nereid> scshunt: but I don't know any number theory. :(
00:32:45 <Cale> scshunt: Brantford Ontario
00:32:52 <scshunt> Cale: up to what?
00:33:06 * Nereid <- UBC now
00:33:07 <Cale> scshunt: I work from home and am living with my parents and sister.
00:33:13 <Jafet> A lot of theoretical security these days is about modelling and formal analysis
00:33:20 <tylerkahn> Cale: so if we have a category D where ob(D) = {x, y, z} and we concretize it (call it E), then ob(E) = { [X], [Y], [Z] } and the arrow [X] -> [Y] in hom(E) maps each f: T -> X in [X] to the corresponding f: T -> Y in [Y]. so our objects are sets of functions  and our arrows are functions from these sets to one another.
00:33:35 <Jafet> The number theory stuff is largely done
00:33:38 <scshunt> Cale: eh
00:33:43 <Cale> scshunt: Lately, I've been working on the backend of skedge.me
00:34:24 <scshunt> Nereid: any particular field of interest? Logic? Languages? Computing theory?
00:34:36 <Cale> I could move out now, but I like my family, and they don't mind me being around :)
00:34:39 <scshunt> (formal languages, not programming languages)
00:35:02 <scshunt> Cale: do you know Shai Ben-David
00:35:09 <scshunt> ?
00:35:14 <Cale> no
00:35:28 <scshunt> ah, ok
00:35:47 <Nereid> scshunt: I could say something in FP or so, but lately I've been thinking about some machine learning/computer vision/robotics stuff.
00:35:49 <Cale> tylerkahn: yes
00:36:35 <scshunt> Nereid: yeah you could probably find a home somewhere with a math background
00:36:42 <tylerkahn> Cale: haha cool thank you
00:36:44 <scshunt> based on my understanding
00:36:48 <Nereid> anyway, here's another way to see that any small category is concretizable, in a rather neat way:
00:36:58 * scshunt is not, and has not ever been, a grad student
00:37:06 <Nereid> given C, take the Yoneda embedding C -> Set^(C^op) followed by product Set^(C^op) -> Set
00:37:12 <Cale> scshunt: same here :)
00:37:20 <scshunt> Cale: :)
00:37:33 <Nereid> (the latter exists because C is small)
00:37:34 <scshunt> I may yet metamorphose
00:38:23 <Cale> scshunt: After my BMath, I did sort of take a long time getting a job, and just studied random bits of mathematics, and I did a mildly ridiculous number of 400/600 level courses as an undergrad (bit off more than I could chew starting in 2nd year)
00:38:36 <Nereid> and this is clearly functorial in C and all that nice stuff.
00:38:50 <Nereid> I think.
00:38:55 <Cale> But I haven't actually been a graduate student :)
00:39:14 <scshunt> Cale: yeah so due to stupid (ontario-level) politics pmath now has a bunch of 400/600 level courses only offered as 700 level
00:39:26 <Cale> scshunt: wtf
00:40:00 <Cale> I didn't know provincial politics gave a shit about the courses offered by mathematics faculties
00:40:15 <scshunt> Cale: because the ontario something of graduate schools or whatever it's called doesn't want grad students taking more than a certain number of cross-listed courses. So pmath decided to just stop cross-listing them but continue putting undergrads in them
00:40:27 <Cale> oh, okay
00:40:29 <scshunt> every term they cancel the 400-level ones and move everyone into the 700-level ones and no one complains
00:40:29 <Cale> lol
00:40:45 <Cale> so it's just a technicality, that's cute
00:40:51 <scshunt> yeah
00:40:59 <Cale> I thought they actually had to stop letting undergrads in for some reason
00:41:36 <scshunt> (and this was a problem because the grad students who weren't from waterloo needed a bunch of things like functional analysis and model theory as background for their work)
00:41:46 <Cale> scshunt: I don't suppose you'd have had the chance to take any courses with David Jackson?
00:42:00 <Cale> He's kinda retired, so I don't know...
00:42:05 <scshunt> Cale: No. I've heard poor reviews, but I haven't been avoiding him.
00:42:10 <scshunt> He's still teaching topology afaik
00:42:18 <Cale> oh, what, really?
00:42:29 <scshunt> yeah
00:42:42 <Cale> D. M. Jackson was by far my favourite prof. Mostly taught combinatorics.
00:42:51 <scshunt> hmm, maybe a different jackson
00:42:55 <Cale> But I can see how he might do topology.
00:43:06 <Cale> It would be a very interesting topology course
00:43:10 <Cale> :)
00:43:34 <Cale> He did a lot of work on counting maps in nonorientable surfaces.
00:44:10 <scshunt> no wait
00:44:14 <scshunt> I'm confusing with someone else
00:44:15 <scshunt> nvm
00:44:28 <Cale> http://www.math.uwaterloo.ca/~dmjackso/
00:44:31 <Cale> this guy
00:44:41 <scshunt> yeah, he's still around
00:44:57 <Cale> If you can get into a course with him as the prof, do it.
00:45:28 <scshunt> he hasn't taught a regular undergrad course in over a year; just a readings in winter
00:45:52 <scshunt> hmm... no grad courses either
00:46:02 <Cale> I remember one of the midterms I had with him, he gave us a midterm which basically slaughtered everyone. Nobody got a mark higher than 50%, so he just added 50% to everyone's mark.
00:46:08 <scshunt> haha
00:46:12 <scshunt> oh man
00:46:14 <scshunt> 1 sec
00:46:31 <Cale> and said "We have to keep up appearances when the non-advanced-section students look at the past exams"
00:47:23 <scshunt> hahahaha
00:47:39 <scshunt> kpurbhoo gave the best grading scheme I've ever seen on a final
00:48:05 <Cale> I've heard he had an interesting grading system
00:48:32 <scshunt> it was 20 max_{\sigma \in S_20} \sum_{n=1}^20 i_n/n, where i_n is your score from 0 to 1 on problem n
00:48:40 <scshunt> * multiplier of 30
00:49:03 <scshunt> (that is, the 20 was a typo and I meant 30)
00:49:12 <Cale> yeah, that's a lovely system
00:49:13 <scshunt> also
00:49:18 <scshunt> by /n I mean /sigma(n)
00:49:25 <Cale> right
00:49:40 <Cale> or perhaps i_sigma(n)/n
00:49:54 <scshunt> doesn't matter really
00:50:03 <Cale> yeah
00:50:05 <scshunt> although you may be correct as to how he wrote it
00:54:33 <Saizan> what's S_20 ?
00:54:43 <Cale> Saizan: symmetric group
00:55:21 <scshunt> Cale: also question 20 was "tell me about something else you learned in this course"
00:55:51 <Cale> scshunt: Go down to the graphics shop at some point before you've graduated and get copies of the Math 249, CO 330 and CO 630 course notes, as well as perhaps the Linear Algebra 245 course notes by D. M. Jackson
00:56:08 <Cale> I don't know of any better introduction to combinatorics in existence
00:56:20 <scshunt> Cale: I took 249 from Godsil with Goulden's notes :)
00:56:23 <Cale> which is annoying because I can't easily tell most people to get those
00:56:42 <shachaf> Cale: :-(
00:57:49 <Cale> The approach to generating series taken by the CO 330 course notes in particular is especially nice. It mirrors the theory of combinatorial species, but without needing any category theory.
00:58:26 <Cale> (odd as that may sound :)
00:58:44 <shachaf> So how do I get the notes?
00:58:58 <Cale> shachaf: You can actually phone up the Waterloo graphics department
00:59:06 <Cale> and ask them to send the notes to you
00:59:19 <scshunt> or get a digital copy
00:59:22 <Jafet> By airmail?
00:59:29 <scshunt> I have a digital copy of the 249 notes
00:59:36 <scshunt> Cale: Goulden's now dean btw
00:59:49 <scshunt> hrm
00:59:49 <Cale> I was never able to get a digital copy of any of Jackson's notes from him
00:59:55 <shachaf> Cale: Can I phone you up instead?
01:00:01 <scshunt> I just now discovered the notes were actually written by Godsil
01:00:06 <scshunt> why did I think they were goulden's?
01:00:22 <Cale> shachaf: Well, you could, but it likely won't lead to you getting a copy of the notes.
01:00:47 <Cale> I had Godsil for algebraic graph theory
01:00:48 <scshunt> Cale: which notes are you referring to in particular when you say the 249 notes?
01:01:07 <scshunt> Cale: excellent prof
01:01:09 <Cale> Math 249, Advanced section intro to combinatorics
01:01:15 <shachaf> Cale: Maybe I should try anyway.
01:01:17 <Cale> by D. M. Jackson
01:01:40 <scshunt> Cale: would probably be work to try to get them to dig those up :(
01:01:48 <Cale> C&O 330, Enumerative Combinatorics by D. M. Jackson
01:02:01 <Cale> scshunt: Last I checked, they could still print them
01:02:13 <Cale> scshunt: even after the courses with him were no longer offered
01:02:26 <Cale> (I think they still get requests for them reasonably often)
01:02:53 <Cale> But I should actually call them up and see... I think I'll try to get his Linear Algebra notes, because I never actually got a copy for myself
01:03:08 <shachaf> These are wrong? http://www.math.uwaterloo.ca/~kpurbhoo/winter2012-math249/math249notes-goulden.pdf
01:03:09 <scshunt> Cale: well it's more an issue of them being superseded
01:03:29 <Cale> shachaf: Those are different
01:03:39 <scshunt> very much note-style
01:03:40 <shachaf> > compare 249 249
01:03:41 <lambdabot>   EQ
01:03:50 <Cale> (but not unrelated)
01:03:53 <Cale> different prof
01:03:56 <scshunt> shachaf: different profs' notes from the same course
01:04:04 <scshunt> not that those are bad, goulden is a brilliant man
01:04:31 <Cale> scshunt: If you ask for the ones by Jackson, they will be able to tell you anyway
01:04:37 <scshunt> yeah
01:04:37 <ivanm> wtf? I haven't had any problem before using haskell-mode, but suddenly it's telling me that a function doesn't exist when it does :/
01:05:08 <Cale> scshunt: I actually had a couple of people do this and get the right notes shipped to them, a few years after Jackson had stopped teaching the course (and I'd left the uni)
01:05:22 <scshunt> cool
01:05:56 <scshunt> my favourite prof so far has been ken davidson I think
01:06:36 <Cale> He has an approach to teaching Linear Algebra which is pretty cool too, with a lot of combinatorial applications in it, and which discusses things like the number of subspaces of F_q^n
01:08:09 <Cale> A lot of things which you wouldn't likely normally see in a first or second course on linear algebra anyway :)
01:08:43 <scshunt> well my second course involved a shitton about dual spaces and quotient spaces :)
01:08:45 <scshunt> also jordan forms
01:08:50 <scshunt> this all thanks to krdavids
01:08:56 <Saizan> he should get a minion to put them in digital form
01:09:15 <Cale> I had Ken Davidson for noncommutative algebra
01:09:16 <scshunt> Saizan: clearly a digital copy exists in the bowels of the graphics deparment
01:09:35 <ivanm> nvm, figured it out
01:09:43 <Cale> It was a fairly brutal course
01:10:07 <scshunt> yeah
01:10:08 <scshunt> he does that
01:10:20 <scshunt> but you learn so much
01:10:38 <Cale> Noncommutative algebra is just pretty brutally difficult to begin with though, I don't think it's just him.
01:10:41 <zzing> Isn't something like    fmap Just $ insert $ User (credsIdent creds) Nothing   the same as  Just <$> insert ...
01:11:08 <Cale> <$> is the same as fmap
01:11:42 <Cale> (it's just defined to go along with <*> and such from Applicative
01:11:43 <Cale> )
01:12:28 <zzing> Cale, I am aware of its sameness, I was just looking at how the thing worked on that line
01:12:49 <zzing> I am not even sure exactly what fmap is really doing there tbh
01:14:08 <Cale> Presumably, the result of insert (User (credsIdent creds) Nothing) is some action producing a value, and  fmap Just will apply Just to the result of the insert, so that it'll be a Maybe value
01:14:45 <Cale> (rather, an action producing a Maybe value)
01:14:59 <Cale> what's the type of insert?
01:15:20 <zzing> insert :: PersistEntity val => val -> backend m (Key backend val)
01:16:43 <Cale> okay, so it'll be  backend m (Maybe (Key backend val))
01:18:36 <zzing> Which is curious… insertUnique :: (backend ~ PersistEntityBackend val, PersistEntity val) => val -> backend m (Maybe (Key backend val))   Looks like this should have been used
01:24:14 <zzing> When I get something like (PersistEntity val0) arising from a use of `count'    Probable fix: add a type signature that fixes these type variable(s)    and it is with regards to         num <- count []   What is the best way to solve that?     The function is count :: PersistEntity val => [Filter val] -> backend m Int
01:32:34 <g_> (5) `divMod` (-9223372036854775806::Int64)
01:32:42 <g_> : (5) `divMod` (-9223372036854775806::Int64)
01:32:46 <g_> > (5) `divMod` (-9223372036854775806::Int64)
01:32:47 <lambdabot>   (-1,-9223372036854775801)
01:33:24 <g_> Anybody running linux?
01:34:09 <g_> Anybody running Linux? If you can try  "(5) `divMod` (-9223372036854775806::Int64)" and tell me the result; I'd appreciate
01:34:09 <arbn> g_: Yes.
01:35:08 <Botje> ghc 7.4.1: (1,-9223372036854775801)
01:35:35 <g_> Botje: yep, looks like a bug
01:35:45 <g_> Lambdabot has the right answer
01:36:11 <Botje> ghc 6.12.1 on a 64-bit debian has -1 again
01:36:35 <Botje> ghc 7.0.4 on 64-bit slackware also has -1
01:36:55 <arbn> (-1,-9223372036854775801) here
01:36:58 <arbn> ghc 7.4.2
01:37:29 <Nereid> 7.6.1 on win32 gets 1
01:38:12 <Jafet> > 5 `divMod` -9223372036854775806
01:38:13 <lambdabot>   Precedence parsing error
01:38:13 <lambdabot>      cannot mix `GHC.Real.divMod' [infixl 9] and p...
01:38:17 <Jafet> > 5 `divMod` (-9223372036854775806)
01:38:18 <lambdabot>   (-1,-9223372036854775801)
01:38:46 <Jafet> > 2^63 - 9223372036854775806
01:38:47 <lambdabot>   2
01:40:03 <g_> Jafet: Looks like Int64 division is bogus when the divisor is around minBound
01:40:39 <g_> Jafet: On Linux only by the way; works fine on the Mac for me. And looks like Lambdabot is getting it right as well
01:42:36 <Jafet> It works for me.
01:44:18 <Jafet> But this would be a very amusing regression test
01:44:34 <arbn> g_: I'm getting it right as well, with ghc 7.4.2 on Linux.
01:46:46 <Nereid> g_: but it's wrong on win32
01:47:44 <Nereid> well
01:47:47 <g_> weird
01:47:59 <Nereid> you guys are putting :: Int64 right?
01:48:05 <scshunt> .win 22
01:48:26 <g_> yeah; make sure to put ::Int64
01:48:45 <g_> arbn: do you have ::Int64 when you get that right?
01:48:55 <arbn> g_: Yes.
01:49:11 <Nereid> on x86-64? or what
01:50:13 <arbn> 64-bit installation here.
01:50:49 <g_> arbn: is there a way to find out what-bit installation one has?
01:50:49 * hackagebot doctest 0.8.0.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.8.0.1 (SimonHengel)
01:51:47 <arbn> maxBound::Int will give you a clue, of course.
01:52:26 <arbn> maxBound::Int here gives 9223372036854775807, for instance.
01:52:50 <g_> ah good point; looks like I've got a 32-bit installation
01:53:15 <g_> Botje: can you verify you got 32 bit as well?
01:54:18 <g_> so, it's not a linux/mac thing; but rather the behavior of a 32-bit installation
01:54:53 <Botje> g_: my 7.4.1 report was on 32 bit
01:55:17 <g_> Botje: cool, that confirms what we're seeing
01:55:25 <g_> here's the relevant code by the way: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Int.html#Int64
01:55:55 <g_> must have some sort of a bug when the native word size is 32
01:57:12 <Jafet> That's a pretty obscure bug then
01:58:07 <g_> Jafet: obscure maybe, bug nonetheless
02:06:25 <g_> Jafet: Nereid: arbn: Just filed the ticket: http://hackage.haskell.org/trac/ghc/ticket/7233
02:06:53 <g_> Feel free to add your comments, if you like
02:16:54 <k0ral> if >=> is the functor equivalent for >>=, what would be the functor equivalent for >> ?
02:17:58 <lpvb> @hoogle (>=>)
02:17:58 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
02:18:23 <Cale> k0ral: what?
02:18:36 <lpvb> >=> is for Monads ^^
02:18:49 <Cale> k0ral: (<=<) = flip (>=>) is sort of the monadic version of (.)
02:19:07 <Cale> Every monad is a functor...
02:19:31 <Cale> But (>>) :: Monad m => m a -> m b -> m b   is a monadic thing too.
02:20:00 <k0ral> replace "functor" with whatever suits you, I just meant >=> is acts on functions
02:20:08 <k0ral> I want the >=> of >>
02:20:12 <Cale> Oh, functor and function are quite different things
02:20:25 <Cale> and I don't know what that means
02:20:29 <Cale> what type would it have?
02:21:25 <k0ral> (a -> m b) -> (m c) -> a -> m c
02:21:27 <k0ral> (I think)
02:21:31 <lpvb> I think Monad m => (a -> m b) -> (b -> m c) -> (b -> m c)
02:22:12 <Nereid> @type \x y -> x >=> const y
02:22:13 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> m c -> a -> m c
02:22:20 <k0ral> I want to "compose" 2 monadic functions while discarding the 1st result
02:23:26 <lpvb> the input for that type isn't two monadic functions?
02:24:01 <k0ral> well, the 2nd argument isn't a function
02:24:15 <Cale> k0ral: is what Nereid suggested the right thing?
02:24:36 <k0ral> yes, I had hoped there was an operator for that but that's fine
02:25:06 <k0ral> thank you :)
02:26:14 <Nereid> @type \x y a -> x a >> y
02:26:15 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> m b -> t -> m b
02:33:31 <Twisol> Does attoparsec have a version of takeWhile that stops at chunk boundaries?
02:33:57 <ivanm> don't believe so
02:34:10 <ivanm> doesn't that kind of get rid of the point of the chunking support?
02:34:49 <Twisol> well, what if I'm reading from the network and I want to use whatever I have immediately without waiting for the next packet?
02:35:10 <ivanm> *shrug*
02:35:21 <ivanm> I haven't played that much in depth with attoparsec so I could very well be wrong
02:37:22 <Twisol> writing a Telnet protocol implementation in Haskell is apparently not easy. :|
02:39:24 <MostAwesomeDude> Eh. If only there were some sort of protocol abstraction.
02:40:25 <MostAwesomeDude> Twisol: The correct thing to do is to match zero or more of your desired parser.
02:40:29 <Cale> What is challenging about it?
02:40:31 <MostAwesomeDude> This will give you a list of packets.
02:40:38 <Cale> oh
02:40:41 <MostAwesomeDude> And then you can shove that list into your state machine.
02:41:08 <MostAwesomeDude> As a side benefit, matching zero packets is not an error condition and is handled right next to the one-packet and many-packet cases.
02:41:24 <Twisol> Match zero or more of my parser?
02:41:42 <MostAwesomeDude> Say you've got parseMyObjects :: Parser MyObject.
02:41:52 <MostAwesomeDude> You should match zero or more of it to get a Parser [MyObject].
02:42:01 * MostAwesomeDude tries to remember what attoparsec calls that combinator
02:42:11 <Cale> Probably many
02:42:15 <MostAwesomeDude> I did this before, with a pretty gnarly protocol, so it's totally possible.
02:42:19 <Cale> If it's like Parsec
02:42:25 <Twisol> Cale: plenty. The use case I'm working on does stuff like inserting a compression layer between the socket and the Telnet layer, and signals this by sending a certain Telnet event
02:42:41 <Cale> I mean that 'many' is probably the name of that combinator
02:43:23 <Twisol> I should note I've done this successfully in C, so I do have experience with the domain. Just… not w.r.t. Haskell.
02:43:48 <MostAwesomeDude> Yes, it's called many.
02:44:19 <MostAwesomeDude> Twisol: I've done this in Python and Factor, in addition to Haskell. The pattern I am talking about is pretty universal.
02:44:38 <MostAwesomeDude> I don't have a name for it, but it's the right way to parse structures out of chunked data.
02:45:22 <Twisol> My "MyObject" would probably be a telnet event. Text, command, negotiation, subnegotiation
02:45:28 <MostAwesomeDude> Okay.
02:46:04 <bootcode> Is it possible to put a new monad to the bottom of a transformer stack? If I have MaybeT (ListT X a) a, then I would like to have MaybeT (ListT (XT Y a) a) a
02:46:08 <MostAwesomeDude> Unrelated: I have a small game I'm building in SDL+GL. It refuses to go above roughly 45 FPS. It's not doing much graphical work and shouldn't be bounded that way; does GHC have some kind of overhead I should know about?
02:46:17 <Twisol> One of the problems I have is that I need to be able to bail out in the middle of the parser if the consumer looks at an event and says "no no, they're enabling compression, we need to decompress from here on"
02:46:38 <MostAwesomeDude> Twisol: Is the compression on the stream, or per-packet?
02:46:53 <Twisol> It's on the stream, compresses the Telnet layer
02:46:56 <MostAwesomeDude> (i.e., could you reasonably use a separate data type for that?)
02:46:58 <MostAwesomeDude> Ah, so no.
02:47:06 <Twisol> the notification for this compression comes in on the Telnet layer
02:47:07 <Twisol> :/
02:47:29 <MostAwesomeDude> You could go look at how other networking libraries do it.
02:47:58 <Twisol> The only possibly similar case I can think of is HTTP's upgrade mechanism, since it stops being HTTP - but I'm not sure how much that would apply.
02:47:59 <MostAwesomeDude> Also won't the uncompressed parser stop working once it sees one of these? Won't the parser fail at that point?
02:48:18 <Twisol> No, Telnet is pretty hardy. My C implementation had no case where a parse would fail.
02:48:36 <MostAwesomeDude> No, I mean, won't your parser fail to match compressed packets?
02:48:49 <Twisol> No.
02:48:51 <MostAwesomeDude> If so, you could tack a gatherer for leftovers to the end of your parser.
02:48:57 <MostAwesomeDude> Oh. That's weird but okay.
02:49:10 <MostAwesomeDude> It'd just parse them incorrectly?
02:50:06 <Twisol> Telnet accepts all bytes, from 0x00 to 0xFF. The only special bytes are 0xFF and 0x0D; the latter expects an 0x0A or 0x00 immediately after, but otherwise pretends there was an 0x00 anyways. 0xFF can have anything after it.
02:50:14 <Twisol> In short, yeah. Incorrectly parsed.
02:50:22 <MostAwesomeDude> Annoying.
02:50:47 <Twisol> In C I just had a telnet_halt() function that the event callback could call. It would signify to the parser on the next iteration to bail and return the remainder.
02:51:04 <MostAwesomeDude> I don't remember seeing this kind of thing in Twisted when reading through their telnet; is compression a pretty popular thing?
02:51:10 * MostAwesomeDude really only does SSH and not telnet
02:51:21 <Twisol> It's a mudding thing. (Online multiplayer text adventures)
02:51:34 <Twisol> it's called MCCP and it's a nonstandard subnegotiation protocol
02:51:40 <MostAwesomeDude> Ah.
02:51:56 * MostAwesomeDude did not realize people still MUD'd over telnet
02:52:06 <Twisol> Telnet is all we have ^_^
02:54:34 <Twisol> Right now my approach is to accept a bytestring and an "actor" monad implementing an event handling typeclass, and bind actions to it for every telnet object parsed.
02:54:56 <Twisol> but I don't know how that will adapt to the annoying halt-the-parser, upgrade-the-connection part
02:55:04 <ddarius> hmatrix is an overly incomplete binding...
02:55:22 <Twisol> also whether I can even communicate between the "actor" and the parser sufficiently to determine whether to halt
02:56:05 <Twisol> Should I just write bindings to my C impl? :P
02:57:15 <cmccann> why are you trying to stop parsing with incomplete data? is this a stream format where you want to produce chunks/packets/&c. as they arrive?
02:57:38 * cmccann looks through backscroll
02:57:42 <Twisol> cmccann: Yes
02:57:44 <Twisol> it's Telnet :)
02:58:13 <cmccann> you should find a parsing library that works well for that, and then tell me what it is.
02:58:24 <Twisol> also an annoying MUD extension that inserts a compression layer at unpredictable times, only known immediately before it begins
02:58:32 <cmccann> so I don't have to spend the time to finish the half-baked library along those lines I was working on months back. :T
02:58:38 <Twisol> Heheh.
02:59:15 <cmccann> though I was mostly after cases where chunk size is known in advance, not sure if that's the case in what you're doing
02:59:48 <Twisol> I'm not sure it's a meaningful question - you either have two- or three-byte sequences, or indetermine sequences of actual data
02:59:58 <Saizan> if you write the consumer of the parsing results as an iteratee-like you should be able to write the parser as a function transforming that into an iteratee that consumes the telnet input
02:59:59 <cmccann> where by "in advance" I mean "specified in a chunk header"
03:00:00 <MostAwesomeDude> Twisol: StateT or ReaderT your Parser and have it statefully figure out whether to decompress each chunk before acting on it?
03:00:53 <Twisol> MostAwesomeDude: There's no concept of a "chunk" really, Telnet is built on TCP as a stream protocol. The compression signal can occur anywhere within a "chunk".
03:01:06 <Twisol> only way to do that is to give my parser one byte at a time
03:01:12 <Twisol> which I refuse to do on philosophical grounds ^_^
03:01:37 <MostAwesomeDude> Twisol: Oooh, I thought that you had some sort of chunkifier.
03:02:04 * cmccann was dealing with file formats of the "series of chunks with a tag header including length" variety.
03:02:11 <Twisol> Only in that I read specific chunks at a time from the network. But it's not meaningful to the protocol itself.
03:02:21 <MostAwesomeDude> But yeah, I can't think of anything else useful. I'm thinkin' of my own problems now.
03:02:32 <Twisol> MostAwesomeDude: No worries. Thanks for the feedback
03:02:41 <MostAwesomeDude> Has anybody already invented a monad for doing variable-timestep absolute timers?
03:02:43 <Twisol> cmccann: I wish I had that kind of problem ^_^
03:03:38 <Twisol> Does it make sense for one monad to be contained within another, but not like a transformer?
03:03:40 <cmccann> anyway, I've looked around for stuff to do parsing while producing incremental output before and never found anything
03:03:56 <Twisol> More, say, interleaved with its actions?
03:04:19 <cmccann> interleaving sounds like what a transformer does.
03:04:31 <Twisol> then I don't understand transformers very well! ^_^
03:05:10 <cmccann> otherwise you can have stuff like [IO (Maybe a)] or whatever all you want, they're just values of some type that happens to involve a monad instance
03:05:16 <ddarius> @hackage pipes-attoparsec-streaming
03:05:16 <lambdabot> http://hackage.haskell.org/package/pipes-attoparsec-streaming
03:05:44 <cmccann> Ooh, interesting.
03:06:45 <MostAwesomeDude> @hackage attoparsec-conduit
03:06:45 <lambdabot> http://hackage.haskell.org/package/attoparsec-conduit
03:07:03 <MostAwesomeDude> There are options.
03:07:07 <Twisol> conduit was confusing to me :(
03:07:13 <MostAwesomeDude> Yeah, it's very confusing.
03:07:30 <Twisol> I like pipes' elegance, but I haven't really used either.
03:07:53 <cmccann> heh, looks like those packages are both new since last time I was working on that stuff.
03:08:06 <cmccann> so at least I didn't somehow miss them before
03:09:06 <ddarius> MostAwesomeDude: That does something different.
03:09:31 <ivanm> Cale: with your reply to greenspans on proggit: how do you tell from profiling results whether something is "expensive" just becuase it _is_ expensive/inefficient vs it just gets called a lot?
03:09:38 <ddarius> MostAwesomeDude: Note that there is a pipes-attoparsec package which is also different.
03:10:00 <ddarius> @hackage incremental-parser
03:10:00 <lambdabot> http://hackage.haskell.org/package/incremental-parser
03:11:42 <cmccann> that one I did look at before... don't remember why it didn't work for my purposes, though.
03:12:30 <MostAwesomeDude> ddarius: Yeah. I still don't grok pipes.
03:12:56 <cmccann> pipes are pretty simple as far as the basic concept goes
03:14:19 <ddarius> MostAwesomeDude: attoparsec-conduit and pipes-attoparsec are basically the same thing.  pipes-attoparsec-streaming is different.
03:14:26 <cmccann> making any stream processing library play nicely with all the situations you'd like to use it for can be tricky though
03:18:24 <k0ral> has anyone thought of creating a Concatenable typeclass, with (++) as member function ?
03:18:48 <cmccann> and that differs from Monoid how?
03:19:14 <ivanm> cmccann: Monoid doesn't apply to NonEmptyLists?
03:19:54 <cmccann> ah, right. of course, doesn't assume an identity.
03:21:08 <ddarius> Semigroup already exists.
03:21:17 <bitonic> HTTP does not work with GHC 7.6?
03:22:23 <bitonic> mhm.  it seems to be the test suite target
03:23:00 <bitonic> aaaaand, it's importing the wrong `catch'.
03:23:06 <nus> https://github.com/haskell/HTTP/pull/27
03:24:31 <bitonic> nus: thanks
03:24:55 <nus> np
03:25:24 <cmccann> ugh, this example of possible abuse of exceptions if they could be caught in pure code is probably the worst thing I've ever written. D:
03:26:02 <ddarius> I think I implemented one-shot delimited continuations using threads and exceptions a long, long time ago.
03:26:15 <k0ral> well, Monoid is exactly what I wanted, thank you for pointing it out, seems to be a very famous type and yet I didn't know about it
03:26:23 <k0ral> s/type/typeclass
03:27:29 <cmccann> yeah, I figured not everyone would be convinced about catching exceptions messing up the semantics of the language, so I implemented a "pure" callCC
03:27:38 <cmccann> it's terrible
03:27:49 <bitonic> nus: mhm.  it still does not build.
03:28:07 <ddarius> cmccann: You have a full callCC?
03:28:54 <cmccann> with the caveat that it doesn't work if you're not strict enough in evaluating stuff
03:29:13 <nus> bitonic, log?
03:29:46 <cmccann> and is probably broken in other ways anyhow
03:30:11 <bitonic> nus: I think I've got an outdate cabal for some reason.  the problem is in the generated Paths_HTTP file
03:30:50 <nus> 4000.2.4 says Cabal-Version: >= 1.8
03:31:08 <triyo> I got the GHC 7.6.1 installed. However, I need cabal-install installed so I downloaded it form the cabal page but got an error when try to run bootstrap.sh => etup: At least the following dependencies are missing: base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6
03:31:09 <cmccann> and the need to force everything within the bounds of what catch will see probably means it's not a full callCC, no
03:31:15 <ddarius> cmccann: Does lem = callCC (\k -> k (Right (k . Left))) work?
03:31:15 <ivanm> I don't think the Paths_* module format has changed any time recently
03:31:20 <ivanm> triyo: hasn't been ported yet AFAIK
03:31:29 <ivanm> might be able to see if the git repo has anything newer
03:31:52 <bitonic> nus: no, I mean an outdated cabal for the compiler
03:31:56 <bitonic> it generates invalid files
03:32:06 <triyo> Cool, thanks. Otherwise what's the alliterative for me? Run runhaskell Setup.hs on packages?
03:32:11 <ivanm> triyo: ooohhh, the 1.16 changes were merged in by tibbe 15 hours ago, so try the git repo
03:32:21 <ivanm> https://github.com/haskell/cabal/tree/master/cabal-install
03:32:24 <triyo> Thanks
03:32:34 <triyo> I'll give that a try
03:33:25 <bitonic> yes, I've got an outdated cabal.  for some reason.
03:33:51 <pharaun> any good way to dealing with Left/Right while parsing/processing data from parsec?
03:33:57 <ivanm> bitonic: how is it being outdated causing problems? not parsing the .cabal format properly?
03:33:59 <bitonic> doesn't cabal come shipped with ghc?
03:34:03 <pharaun> i've gotten a bunch of cases all over, i'm wondering if there's a better way
03:34:04 <ivanm> Cabal does
03:34:06 <ivanm> cabal-install doesn't
03:34:13 <bitonic> ivanm: for the third time, it's generating the wrong Paths file :)
03:34:17 <ivanm> pharaun: use the either function ?
03:34:27 <ivanm> bitonic: but AFAIK the Paths_* module hasn't changed
03:34:56 <bitonic> ivanm: well, it surely did from 0.10, which is what I have
03:35:13 <pharaun> ivanm: that could make a couple of this nicer, thanks i'll try that
03:35:17 <ivanm> oh, it uses Catch
03:35:19 <bitonic> since it generates invalid files
03:35:19 <ivanm> I get you now
03:35:20 <ivanm> sorry
03:35:21 <bitonic> yes.
03:35:34 <realrocker> Hey Guys. I am a haskell newbie and was trying to install yesod on my 12.04 32-bit 2gb ram Ubuntu. Error Log: http://pastebin.com/Ap7EzXhD. Googled for it, couldn't get solution so need help.
03:35:38 <ivanm> I thought you meant the exported stuff was wrong
03:36:00 <ivanm> realrocker: what are the errors from building unix-time ?
03:36:00 <bitonic> no
03:36:04 <ivanm> you don't have any errors there...
03:36:41 <bitonic> at the same time, `cabal-install' requires a version of `directory' which requires base < 4.6
03:36:55 <ivanm> bitonic: which version of GHC?
03:37:04 <bitonic> brilliant.  so I need to install that version with an older version of GHC
03:37:14 <Cale> realrocker: is that all the output?
03:37:28 <ivanm> bitonic: as I said to triyo, grab it from github
03:37:34 <ivanm> it's been updated there if you're using 7.6
03:37:38 <realrocker> no..i will put up a more descriptive log
03:37:42 <bitonic> ivanm: I'll just use --with-compiler
03:38:22 <ivanm> bitonic: won't change the version of Cabal it uses
03:38:30 <bitonic> ivanm: ?
03:38:40 <bitonic> I'll just build cabal-install with an older compiler
03:38:44 <triyo> Quick question. If GHC ships with Cabal, where is the binary cli tool `cabal'? I can't find it anywhere.
03:38:49 <ivanm> bitonic: your problem is that the version of Cabal being used is old
03:39:07 <nus> triyo, why aren't you using the platform, anyway?
03:39:07 <ivanm> triyo: install cabal-install
03:39:09 <bitonic> ivanm: I know.  I'm installing a newer version
03:39:10 <ivanm> it doesn't come with GHC
03:39:17 <ivanm> bitonic: you have old GHC's still installed?
03:39:23 <bitonic> ivanm: yes, many
03:39:30 <bitonic> 7.0.4 worked
03:39:31 <triyo> nus: 7.6.1 platform?
03:39:52 <ivanm> triyo: if you want to use 7.6, you have to be aware of breakages with many packages
03:40:00 <nus> http://hackage.haskell.org/platform/
03:40:03 <ivanm> but there won't be a version of the platform available for it until next year probably
03:41:05 <bitonic> I would have waited for this important packages to work before releasing GHC 7.6
03:41:22 <ivanm> bitonic: it needs to be released so that people can use it to update their packages...
03:41:40 <bitonic> ivanm: there was a RC
03:41:41 <ivanm> bitonic: remember, people are meant to use the Platform, not getting GHC directly
03:41:45 <bitonic> and there was GHC HEAD before
03:41:46 <ivanm> bitonic: ... so?
03:41:56 <bitonic> so, they could have waited for those packages to be working
03:41:58 <ivanm> you're expecting every single Haskell developer to install GHC from HEAD?
03:42:09 <bitonic> ivanm: there was a RC as well
03:42:15 <ivanm> so?
03:42:17 <bitonic> which exists exactly for that purpose
03:42:23 <ivanm> what _should_ have happened is that libraries that ship with 7.6 be released (Cabal, etc.)
03:42:24 <bitonic> and not *every single*, just the core packages
03:42:30 <ivanm> bitonic: no, the RC is to test GHC
03:42:34 <ivanm> and cabal-install ins't a core package
03:42:53 <ivanm> also, I don't get why the version of haddock that comes with 7.6 can't be built by 7.6 :/
03:42:57 <bitonic> ivanm: really?  with core I meant "in the platform", more or less
03:43:10 <ivanm> bitonic: but the platform won't be coming out for six months or so
03:43:14 <bitonic> also, the RC is mainly to test that existing packages work, and fix them if they don't
03:43:20 <ivanm> to precisely let everything be updated, settle down, etc.
03:44:09 <bitonic> ivanm: I think waiting for the maintainers of that handful of packages to catch up does no harm
03:44:22 <bitonic> and in fact many were doing it while GHC 7.6.1 was in RC
03:44:35 <ivanm> GHC HQ doesn't control those packages
03:44:39 <ivanm> and it doesn't depend on cabal-install
03:44:44 <ivanm> so I don't see why they should wait
03:44:54 <ivanm> especially since they traditionally release just before or at ICFP
03:44:58 <triyo> ivanm: running multiple version of GHC should be a big deal? I wish to run 7.4.2 as my dev but really wish to test out some 7.6.1 new features...
03:45:21 <ivanm> triyo: some people do
03:45:25 <bitonic> ivanm: the people who maintain the platform and the people who release GHC collaborate already, it wouldn't be an hassle
03:45:26 <ivanm> I've never bothered
03:45:34 <ivanm> bitonic: except they're two entirely different things
03:45:45 <bitonic> triyo: you don't have to do anything if you install the binaries.  they're automatically versioned
03:45:48 <ivanm> the platform deliberately waits to let things settle down, bugs to be ironed out, etc.
03:45:52 * hackagebot cookie 0.4.0.1 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.4.0.1 (MichaelSnoyman)
03:45:53 <bitonic> ivanm: I'm tired of this discussion, whatever
03:45:54 * hackagebot dates 0.1.1.1 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.1.1.1 (IlyaPortnov)
03:47:16 * bitonic goes back to 7.4.1
03:53:16 <arbn> Huh. LtU is spitting out an SQL error about duplicate session IDs when I try to visit the site.
03:54:13 <StrangeLoop> What's the most recommended tutorial for an experienced programmer, yet with little to no experience with functional languages?
03:54:34 <adnauseam> learn you a haskell
03:54:42 <adnauseam> or real world haskell
03:54:52 <adnauseam> well, real world haskell if you're experienced
03:54:55 <arbn> StrangeLoop: LYaH is good if you have no experience with functional programming.
03:55:27 <StrangeLoop> OK, thanks
03:55:37 <arbn> StrangeLoop: If you take the route of learning Scheme or Racket first, I'd suggest trying Real World Haskell to see if that's more your speed.
03:56:24 <StrangeLoop> They say Haskell is more intuitive to people who have done a lot of math
03:56:44 <arbn> StrangeLoop: Math became more intuitive to me after I had done a lot of Haskell.
03:57:01 <StrangeLoop> Cool :)
03:59:45 <arbn> StrangeLoop: One of the advantages of pure functional programming is that you can reason about it equationally, which math people are quite used to.
04:00:02 <cmccann> ddarius, fwiw I can't find any way to write that version of lem
04:00:39 <adnauseam> StrangeLoop: i'm actually using haskell to learn math
04:00:43 <cmccann> types won't match up and I can't force the expression where catch will see it
04:00:51 <adnauseam> my math skills are pitiful
04:00:52 * hackagebot resourcet 0.4.0 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.0 (MichaelSnoyman)
04:00:54 * hackagebot zlib-bindings 0.1.1.1 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.1.1.1 (MichaelSnoyman)
04:00:56 * hackagebot dates 0.1.2.0 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.1.2.0 (IlyaPortnov)
04:01:04 <StrangeLoop> I'm about halfway my masters, actually
04:01:05 <adnauseam> just take it easy and abuse GHCI
04:01:23 <adnauseam> then you're already better positioned, don't worry and just dive in
04:01:34 <hnsz> adnauseam: Begin with prime numbers :)
04:01:44 <adnauseam> hnsz: it's funny you should say that
04:01:55 <hnsz> adnauseam: Prime factors that is.
04:02:12 <adnauseam> i'm trying to understand the proof of why composite numbers can't be prime numbers
04:02:29 <ivanm> adnauseam: by definition?
04:03:04 <arbn> StrangeLoop: Just be warned, that there's a rabbit hole of specialized topics relating to Haskell and category theory, lambda calculi, proofs, type hackery, etc, that will eat all your free time and energy. :P
04:03:12 <adnauseam> http://mathworld.wolfram.com/CompositeNumber.html
04:03:18 <adnauseam> step (6) puzzles me
04:03:44 <adnauseam> but i'm rereading it, i think i've missed something. and yes iknow that by definition it is so, but i'm trying to gain a deeper understanding
04:04:21 <bitonic> what's the easiest way to send an HTTP request and get the result as a ByteString?
04:05:52 * hackagebot todos 0.5.3.1 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.5.3.1 (IlyaPortnov)
04:06:02 <ivanm> bitonic: what's S/
04:06:08 <ivanm> sorry, that was meant to be for adnauseam
04:06:54 <adnauseam> well S seems to be the sum of the factors of the two possible products a composite can have, squared
04:07:42 <adnauseam> not sure what the idea behind that is though
04:08:18 <hnsz> adnauseam: If you wan't to get into math I wouldnt dangle on it foor too long Just understand that an natural number is either a prime or a product of primes and learn greatest common divisor and lowest common denominator.
04:08:58 <adnauseam> hnsz: i got to do a lot of proofs this semester
04:09:05 <adnauseam> doing analysis 1
04:09:08 <ddarius> adnauseam: Step 6 is a definition and the upshot is it's showing that all sums of four squares are composite.
04:09:11 <arbn> bitonic: The HTTP package in the Platform has a ByteString instance for the HandleStream, which is the typeclass used for your requests and responses.
04:09:12 <adnauseam> (calc 1?)
04:09:25 <adnauseam> mhm
04:09:57 <bitonic> arbn: oh, of course.  thanks.
04:09:57 <hnsz> calculus is analysis yes
04:10:40 <adnauseam> i've got 40 days to get ready
04:10:43 <adnauseam> all good. no panic here.
04:10:50 <hnsz> :)
04:11:27 <lpvb> can I use Data.Aeson to find one value from a JSON without making a new type and an instance of that type for FromJSON?
04:11:28 <ddarius> Often first courses in calculus are not proof heavy, though that depends on the school and the instructor.
04:11:32 <hnsz> adnauseam: I can giv eyou a list of things you want to know before you start with calculus
04:12:51 <arbn> lpvb: There is probably a type with a FromJSON instance already that you can pattern-match from, right?
04:15:06 <lpvb> arbn: not all of the values are the same so I can't parse the whole json as one type
04:15:38 <lpvb> values are of the same type*
04:15:40 <hnsz> adnauseam: Partial fractions are another important one
04:15:52 * hackagebot attoparsec-conduit 0.5.0.1 - Consume attoparsec parsers via conduit.  http://hackage.haskell.org/package/attoparsec-conduit-0.5.0.1 (MichaelSnoyman)
04:16:19 <lpvb> the json is an object with several values of different types and I only need one of them which is an Int
04:16:29 <lpvb> without making a whole new data type or instance
04:16:33 <lpvb> seems overkill to me
04:17:08 <adnauseam> hnsz: i'd love that
04:17:18 <hnsz> adnauseam: the list?
04:17:22 <adnauseam> yeah
04:17:24 <Saizan> lpvb: parse as a Value and take it apart
04:17:27 <arbn> lpvb: If you know what type the value you want is, you can deserialize the JSON as some structure of Value types, and then your "parser" is obviously pretty primitive.
04:17:32 <hnsz> adnauseam: i'll msg you
04:17:37 <adnauseam> sweet =]
04:19:14 <ddarius> lpvb: Just decode it to Value and pick out what you want.
04:19:21 <arbn> lpvb: So, yeah, use a type with a FromJSON instance already, use Value, and then pattern-match and convert to the type you want.
04:19:25 <lpvb> ddarius: how do I pick out what I want?
04:19:44 <lpvb> how do I parse a Value type
04:20:32 <ddarius> You don't parse it.  It's a data structure that mimicks the structure of JSON.  Just pick out from it what you want.  For an object, the fields are in a HashMap of Values.
04:20:52 <lpvb> yea
04:20:54 * hackagebot blaze-builder-conduit 0.5.0.1 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.5.0.1 (MichaelSnoyman)
04:20:56 * hackagebot conduit 0.5.2.4 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.2.4 (MichaelSnoyman)
04:20:58 * hackagebot filesystem-conduit 0.5.0.1 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-0.5.0.1 (MichaelSnoyman)
04:21:00 <lpvb> but how do I turn those Values into something I can use?
04:21:00 * hackagebot imagesize-conduit 0.5.0.1 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-0.5.0.1 (MichaelSnoyman)
04:21:02 * hackagebot network-conduit 0.5.0.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.5.0.1 (MichaelSnoyman)
04:21:26 <lpvb> Value -> Int
04:21:30 <ddarius> lpvb: You pattern match.  It's a transparent data structure.
04:21:31 <triyo> Anyone know how to write the new lambda case in a GHCi session? As a one line…. let f = \case Just x -> x; _ -> 0
04:23:21 <ddarius> triyo: That should work.
04:23:22 <lpvb> so I would do pickInt :: Value -> Int; pickInt (Value i) = i?
04:24:07 <ddarius> lpvb: No.  I recommend reading the Data.Aeson docs and an introduction to Haskell.
04:24:24 <triyo> ddarius: thought so too. => parse error on input `case'
04:24:30 <lpvb> umm, pickInt (Number i) = i :: Int?
04:24:36 <ivanm> triyo: try double escapes?
04:24:45 <ivanm> you're sure you're using ghci for 7.6.1?
04:24:46 <lpvb> I read the Data.Aeson docs
04:24:49 <lpvb> and lyah
04:24:50 <triyo> I did add option "LambdaCase"
04:24:59 <triyo> ivanm: 100% sure.
04:26:04 * hackagebot resourcet 0.4.0.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.0.1 (MichaelSnoyman)
04:26:06 * hackagebot zlib-conduit 0.5.0.1 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.5.0.1 (MichaelSnoyman)
04:26:08 * hackagebot VKHS 0.1.0 - Provides access to Vkontakte (popular Russian social network) API  http://hackage.haskell.org/package/VKHS-0.1.0 (SergeyMironov)
04:27:40 <triyo> My bad it does work; LambdaCase lang ext wasn't loaded as I trout it was..
04:31:10 <realrocker> Cale: So I tried installing yesod platform again . Failed. This is my error log: http://pastebin.com/dYV4Jem1       Sorry for the delay, I am in India and we get power cuts all the time :(
04:32:39 <ivanm> realrocker: cabal install unix-time -v3
04:34:31 <edwardk> preflex: xseen obk
04:36:46 <ivanm> hey edwardk
04:36:50 <edwardk> heya
04:37:17 <realrocker> same error: ExitFailure 127
04:37:27 <realrocker> ivanm
04:37:33 <ivanm> no actual output?
04:37:36 <ivanm> which version of GHC?
04:38:25 <ivanm> does "ghc-pkg check" say anything?
04:38:53 <realrocker> ivanm:http://pastebin.com/gUb1pnrY
04:38:55 <bitonic> is there a library somewhere, that given a base uri and a link, gives you an absolute link?  e.g. `foo "www.google.com/bar" "/baz/quux"' would give `www.google.com/baz/quux'
04:39:04 <bitonic> but with relative paths as well, links starting with //, etc.
04:39:08 <realrocker> the output
04:39:45 <ivanm> so it's a _shell_ problem? :/
04:40:11 <ivanm> realrocker: try these commands:
04:40:27 <ivanm> cabal unpack unix-time && cd unix-time-0.1.2 && cabal configure
04:40:33 <bitonic> OK, Network.URI has it
04:44:14 <realrocker> ivanm: that configured unix-time but yestod installation fails with the same error
04:44:29 <ivanm> realrocker: OK, now do "cabal build" in the unix-time directory
04:45:51 <ivanm> if that succeeds, do "cabal install"
04:46:04 <ivanm> if that succeeds, try installing yesod again
04:46:16 <realrocker> did not succeed: http://pastebin.com/jkVjbMPh
04:46:27 <ivanm> aha!
04:46:30 <ivanm> finally we're getting somewhere
04:47:20 <ivanm> realrocker: is there a cbits/conv.c there ?
04:48:06 <realrocker> yes
04:48:27 <ivanm> is there a cbits/config.h ?
04:48:42 <realrocker> yes
04:49:14 <realrocker> oh hold on
04:49:25 <ivanm> realrocker: which version of GHC are you using?
04:49:32 <realrocker> this is here config.h.in
04:49:35 <realrocker> not config.h
04:49:42 <ivanm> OK
04:49:51 <ivanm> IIUC, autoconf should be turning that -into_ config.h
04:50:07 <ivanm> anyone here familiar with autoconf-based builds?
04:50:12 <ivanm> because I'm not...
04:50:30 <realrocker> ghc 7.4.1
04:51:01 <ivanm> realrocker: when I do "cabal configure" here, the last line is "config.status: creating cbits/config.h"
04:51:04 <ivanm> how about for you?
04:51:08 <ivanm> and which OS?
04:51:42 <realrocker> Ubuntu 12.04 32 bit 2gb ram
04:51:49 <ivanm> oh, right, you said that
04:51:55 <realrocker> for cabal configure I get: Please create a package description file <pkgname>.cabal
04:52:07 <ivanm> realrocker: is this in the unix-time-0.1.2 directory?
04:52:15 <realrocker> yes
04:52:23 <ivanm> ummmm.... can you double-check that?
04:52:31 <ivanm> because there should be unix-time.cabal there
04:52:42 <realrocker> sorry again
04:52:52 <realrocker> i was in cbits
04:52:55 <ivanm> heh
04:53:05 <ivanm> OK, what is the output of "cabal clean && cabal configure"
04:53:49 <realrocker> now i get Resolving dependencies.. cleaning...Resolving dependencies...Configuring unix-time-0.1.2...
04:54:02 <ivanm> and that's it?
04:54:07 <realrocker> yep
04:54:10 <ivanm> do you have autoconf installed?
04:54:44 <realrocker> yes
04:55:16 <realrocker> autoconf 2.68
04:55:30 <ivanm> well, something is going wrong there
04:55:38 <ivanm> because you should be getting output from autoconf as well
04:56:10 <realrocker> should i try building from source
04:56:25 <ivanm> that's what I'm trying to get you to do!
04:56:25 <realrocker> i did apt-get install haskell-platform
04:56:36 <realrocker> && cabal update
04:56:37 <ivanm> do you have a configure.ac file ?
04:56:38 <realrocker> i mean
04:56:56 <realrocker> yes
04:57:22 <ivanm> is the contents of your Setup.hs "import DIstribution.Simple" and "main = defaultMainWithHooks autoconfUserHooks" ?
04:57:31 <ivanm> oh, and what is your version of cabal-install? cabal --version
04:58:05 <triyo> How do I add additional language flags to current running GHCi session?
04:58:14 <realrocker> cabal 0.14.0
04:58:42 <ivanm> triyo: :set -XOverloadedStrings
04:58:48 <triyo> Thanks!
04:58:58 <ivanm> realrocker: what about the contents of your Setup.hs ?
04:58:59 <realrocker> Setup.hs bingo
04:59:04 <ivanm> as in the same?
04:59:09 <realrocker> yes
04:59:10 <realrocker> same
04:59:56 * ivanm is out of ideas
05:00:14 <ivanm> realrocker: what happens if you try to run ./configure manually ?
05:00:49 <realrocker> whoa that worked
05:00:53 * hackagebot bindings-levmar 1.1.0.1 - Low level bindings to the C levmar (Levenberg-Marquardt) library  http://hackage.haskell.org/package/bindings-levmar-1.1.0.1 (BasVanDijk)
05:00:54 <realrocker> i have a config.h now
05:00:55 * hackagebot levmar 1.2.1.2 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.2.1.2 (BasVanDijk)
05:01:04 <ivanm> realrocker: OK, do "cabal install"
05:01:08 <ivanm> and let's see if that magically works
05:01:22 <ivanm> realrocker: and report a bug to the Cabal bug tracker on github
05:01:27 <ivanm> not sure how to reproduce this...
05:01:33 <ivanm> but it's definitely weird :s
05:01:37 <realrocker> same  error still
05:01:44 <ivanm> oh :(
05:01:45 <realrocker> on cabal install
05:01:49 <ivanm> dammit
05:02:00 <realrocker> cabal build?
05:02:01 <ivanm> I hoped that the config.h would still have been there
05:02:09 <ivanm> realrocker: that won't help with actually _installing_ it though
05:02:27 <realrocker> hmm
05:02:28 <maukd> but you still have to build before install
05:02:35 <realrocker> did not work anyway
05:02:38 <realrocker> tried it
05:02:43 <ivanm> maukd: yeah, but "cabal install" normally does a re-build
05:02:49 <ivanm> and it looks like it cleans first as well
05:03:53 <realrocker> ok cabal build works for unix-time..so cabal install must be trying to build it again
05:03:59 <ivanm> yup
05:04:08 <realrocker> can't i skip it
05:04:08 <realrocker> ?
05:04:10 <ivanm> I think it even does a clean :(
05:04:13 <ivanm> doesn't look like it
05:05:04 <ivanm> hmmm, it doesn't seem to re-generate the files here
05:05:13 <ivanm> realrocker: does cbits/config.h still exist?
05:05:20 <realrocker> does this mean anything to you :http://stackoverflow.com/questions/10196001/what-does-cabal-exitfailure-127-mean
05:05:26 <realrocker> yes it does
05:06:01 <realrocker> i did cabal install encoding -v....but that failed too
05:07:02 <ivanm> realrocker: does the hint by PaulGraphvo help?
05:07:05 <ivanm> *Graphov
05:07:50 <realrocker> I did not get the hint :(
05:08:08 <realrocker> probably
05:08:20 <realrocker> tried it....but i think i am doing it wrong
05:08:32 <bitonic> what's the thing with the interface closest to attoparsec, but with String?
05:08:36 <bitonic> was it polyparse?
05:08:46 <ivanm> realrocker: do you have a /usr/include/time.h ?
05:09:19 <realrocker> yes
05:09:19 <ivanm> it might be in glibc-dev or something
05:09:22 <ivanm> hmmm
05:12:02 <ivanm> I've got no ideas then, sorry
05:13:07 <realrocker> today is my first day on haskell
05:13:13 <realrocker> not a good day :(
05:13:22 <realrocker> thanks for the help :)
05:13:22 <ivanm> and you're diving straight in to yesod? :o
05:13:36 <realrocker> well i just doing it for funsies
05:13:36 <plat0> Yes, what is the rationale for that?
05:13:45 <plat0> ^^ Err, sorry
05:13:56 <plat0> miskeyed
05:15:26 <ivanm> I would figure learning the language first would be a better way of doing it
05:15:43 <ivanm> especially since yesod isn't exactly standard haskell, what with all the TH and QQ :p
05:16:32 <realrocker> i needed to run an example benchmark to validate something
05:17:05 <realrocker> it's ok though
05:29:02 <statusfailed> Is it possible to turn a Num into a Fractional?
05:31:27 <EarlGray> Hi there
05:31:44 <EarlGray> I just tried to install `encoding` through Cabal
05:31:47 <EarlGray> cabal: dependencies conflict: ghc-7.4.1 requires unix ==2.5.1.0 however
05:31:47 <EarlGray> unix-2.5.1.0 was excluded because ghc-7.4.1 requires unix ==2.5.1.1
05:31:53 <EarlGray> how to handle that?
05:32:30 <lpvb> install an earlier version of encoding
05:32:38 <mapreduce> > sqrt 2
05:32:39 <lambdabot>   1.4142135623730951
05:32:54 <mapreduce> @instances Fractional
05:32:54 <lambdabot> Double, Float
05:33:23 <lpvb> @instances Num
05:33:23 <lambdabot> Double, Float, Int, Integer
05:34:03 <hiptobecubic> Ratio isn't fractional?
05:34:48 <hiptobecubic> oh... well it's definitely in Num, so this is just missing it i guess.
05:36:37 <maukd> @instances-importing Data.Ratio Fractional
05:36:38 <lambdabot> Double, Float, Ratio a
05:40:54 * hackagebot arrows 0.4.4.1 - Arrow classes and transformers  http://hackage.haskell.org/package/arrows-0.4.4.1 (RossPaterson)
05:44:24 <bitonic> Network.URI doesn't seem to parse URIs like `//foo.bar.com'
05:51:37 <mroman> bitonic: //foo does not lok like a genuine uri
05:51:43 <mroman> *look
05:51:52 <ion> mroman: It is.
05:52:10 <bitonic> actually, my fault.
05:52:12 <ion> It’s just relative.
05:52:16 <bitonic> I was using parseURI
05:53:30 <bitonic> mhm.
05:54:27 <bitonic> relativeTo "http://wikipedia.org" "//wikimediafoundation.org/" => http://wikipedia.org
05:54:32 <bitonic> which is wrong
05:54:56 <bitonic> or am I missing something?
05:55:03 <mroman> An URI with / is relative to its domain.
05:55:36 <mroman> if the / is at the beginning.
05:55:47 <bitonic> mroman: not if you have two slashes
05:56:42 <mroman> // is part of hier-part
05:56:59 <ion> bitonic: Try flipping the arguments.
05:57:22 <bitonic> ion: aha, thanks.  sorry.
05:57:55 <mapreduce> It keeps the same protocol.
05:58:14 <mapreduce> //foo if you're in https://bar gives https://foo
05:59:00 <bitonic> yeah, I know, I didn't get why it didn't work.  it turns out that I'm stupid and for some reason I had the arguments wrong :P
06:00:45 <mroman> I forgot about that.
06:02:26 <ion> λ> do base <- parseURI "prot://foo/bar"; rel <- parseURIReference "//baz/quux"; rel `relativeTo` base
06:02:28 <ion> Just prot://baz/quux
06:04:19 <maukd> bitonic: looks like it's meant to be infix
06:04:44 <ion> > succ maukd
06:04:45 <lambdabot>   Not in scope: `maukd'
06:04:46 <ParahSailin_> A programmer goes to the store to get milk. His wife calls and says, "while you're out, get some eggs." He never returns.
06:05:48 <bitonic> ion: apparently
06:05:54 <bitonic> sorry, maukd
06:06:02 <bitonic> is maukd a mistyped mauke?
06:06:26 <Sculptor> bitonic: apparently
06:08:03 <cjay> oh, somebody enabled -fdefer-type-errors ;)
06:10:55 * hackagebot mime-mail 0.4.1.2 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.1.2 (MichaelSnoyman)
06:11:49 <ion> messageC =<< messageB . messageA
06:15:14 <maukd> bitonic: no, decremented
06:16:06 <bitonic> maukd: oh, OK.
06:25:55 * hackagebot crypto-conduit 0.4.0.1 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.4.0.1 (FelipeLessa)
06:27:38 <ocharles> I wonder if it's bad to have OverlappingInstances for Has x (xs :: [*])
06:33:58 <ocharles> argh, type family Index x (xs :: [*]) has conflicting instances for Index x (x ': xs) and Index x (y ': xs)
06:33:59 <ocharles> damnit.
07:25:16 <ignar> Hi all. Could anybody help me with simple function?
07:27:12 <Sweden_jack> ignar: what's the problem?
07:28:24 <ignar> I am only start to lear Haskell. Usualy I use ruby and I couldn't write signature for this: hourAngle h m = 360 * (h `rem` 12) / 12 + 360 * (m / 60) * (1 / 12)
07:28:47 <maukd> ask ghci
07:29:04 <maukd> it can tell you the types of everything
07:29:21 <mapreduce> :t let  hourAngle h m = 360 * (h `rem` 12) / 12 + 360 * (m / 60) * (1 / 12) in hourAngle
07:29:22 <lambdabot> forall a. (Integral a, Fractional a) => a -> a -> a
07:29:58 <mapreduce> You might want to be more specific than that and write (Double a) or something though.
07:30:10 <mm_freak> ignar: if you don't know how type classes work yet, this is a valid type:  hourAngle :: Double -> Double -> Double
07:30:35 <mm_freak> mapreduce: Double :: *
07:30:38 <mapreduce> Ignore my comment.
07:30:51 <mapreduce> mm_freak: Yep, I realised when I saw your signature. :)
07:31:01 <mm_freak> =)
07:31:25 <maukd> how is that valid?
07:31:33 <maukd> Integral + Fractional cannot work
07:31:42 <maukd> the code is broken
07:32:17 <mapreduce> > let  hourAngle h m = 360 * (h `rem` 12) / 12 + 360 * (m / 60) * (1 / 12) in hourAngle 12 30
07:32:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:32:18 <lambdabot>    `GHC.Real.Integral a'
07:32:18 <lambdabot>   ...
07:32:27 <mm_freak> the code isn't broken…  you just won't find a type with those instances
07:32:42 <maukd> that's what I mean by broken
07:32:45 <mm_freak> so applying this function to anything currently available will give a missing instance error
07:32:52 <mapreduce> So presumably he should be using div throughout.
07:33:05 <mm_freak> but yeah, my type is in fact invalid
07:33:10 <ignar> mm_freak: hourAngle :: Double -> Double -> Double - it fail with 'No instance for (Integral Double) arising from a use of `rem''
07:33:15 <maukd> mapreduce: unlikely
07:33:24 <maukd> ignar: what do you want that function to do?
07:33:28 <mm_freak> ignar: yeah, i just realized that it can't work
07:33:37 <mapreduce> > let  hourAngle h m = 360 * (h `rem` 12) `div` 12 + 60 * m div 12 in hourAngle 12 30
07:33:38 <lambdabot>   1800
07:33:53 <mm_freak> ignar: you have (/) and 'rem' there, which are incompatible for all predefined types
07:34:12 <ignar> maukd: it should take two integral arguments and return something of float type
07:34:29 <mm_freak> ignar: (/) requires the type to be a Fractional, while 'rem' requires Integral…  no predefined type has instances of both type classes defined
07:34:36 <maukd> ignar: insert 'fromIntegral' before every argument in the function body
07:34:45 <maukd> well, no
07:34:57 <Sculptor> 2nd div lacks backticks. is that ok
07:34:58 <maukd> ignar: change m to fromIntegral m
07:35:02 <mapreduce> > let  hourAngle h m = 360 * fromIntegral (h `rem` 12) / 12 + 360 * (fromIntegral m / 60) * (1 / 12) in hourAngle 12 30
07:35:03 <lambdabot>   15.0
07:35:18 <maukd> Sculptor: no
07:35:34 <cjay> will there be videos from icfp?
07:35:51 <mm_freak> maukd: that won't do it
07:36:20 <mapreduce> why did my bad div compile?
07:36:28 <maukd> > 1 ()
07:36:29 <lambdabot>   1
07:36:30 <mm_freak> :t \h m -> 360 * fromIntegral (h `rem` 12) / 12 + 360 * (m / 60) * (1 / 12)
07:36:31 <lambdabot> forall a a1. (Fractional a1, Integral a) => a -> a1 -> a1
07:36:37 <ignar> mapreduce: yep, it works, thanks. But how signature should look like?
07:36:41 <mapreduce> Is that a lambdabot thing?
07:36:45 <mapreduce> ignar: do :t on it
07:36:46 <mm_freak> > (\h m -> 360 * fromIntegral (h `rem` 12) / 12 + 360 * (m / 60) * (1 / 12)) 3 4
07:36:47 <lambdabot>   92.0
07:36:49 <maukd> mapreduce: sort of
07:37:16 <maukd> ignar: Integer -> Integer -> Double, if you want something monomorphic
07:37:44 <mm_freak> mapreduce: your 'div' wasn't bad…  you just replaced every (/), which entirely removed the Fractional constraint
07:37:47 <maukd> mapreduce: among the modules loaded by lambdabot is one that defines instance (Num a) => Num (e -> a)
07:38:17 <maukd> (incidentally, you can do this for all Applicatives, not just functions)
07:38:18 <mapreduce> mm_freak: I intended to remove the fractional constraint at that moment.  The div was bad though, because I omitted the backquotes.
07:38:53 <mm_freak> mapreduce: ah, then what maukd said
07:38:55 <ignar> maukd: thank you. It works
07:39:31 <ignar> Complete function look like:
07:39:31 <ignar> hourAngle :: Integer -> Integer -> Double
07:39:32 <ignar> hourAngle h m = 360 * fromIntegral(h `rem` 12) / 12 + 360 * (fromIntegral m / 60) * (1 / 12)
07:39:55 <maukd> * (1 / 12) better written as / 12
07:40:01 <maukd> or is it?
07:40:01 <ignar> Thanks you guys
07:40:12 <mm_freak> or as (* recip 12)
07:40:49 <cardamon> Looking for a compositing alternative to xcompmgr, one that can manage vblank syncing...while still running xmonad.
07:40:53 <mapreduce> 360 * (fromIntegral (h `rem` 12) + m / 60) / 12
07:41:02 <maukd> fold more algebra
07:41:17 <maukd> > 360 / 12
07:41:18 <lambdabot>   30.0
07:41:33 <mapreduce> using 30 might lose some information for the reader.
07:52:53 <linusoleander> I'm trying to use the join function, without success, what I'm I doing wrong?
07:52:54 <linusoleander> https://gist.github.com/9c9140b5d87a97c624eb
07:53:06 <linusoleander> I get "Main.hs:6:26: Not in scope: `join'"
07:53:17 <linusoleander> Using ":load Main" in ghci
07:53:41 <plat0> If anyone would like to comment on my article about Free Applicatives I would appreciate it: http://web.jaguarpaw.co.uk/~tom/blog/2012/09/09/towards-free-applicatives.html
07:53:54 <lpvb> join only takes one argument
07:53:57 <lpvb> :t join
07:53:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:54:12 <maukd> linusoleander: import Control.Monad
07:55:06 * linusoleander maukd: Aha, how do I join a list of items?
07:55:18 <linusoleander> [1,2,3].join("-") => "1-2-3"
07:55:25 <maukd> > join ["a", "b", "c"]
07:55:26 <lambdabot>   "abc"
07:55:32 <maukd> > intercalate "-" ["a", "b", "c"]
07:55:34 <lambdabot>   "a-b-c"
07:55:44 <linusoleander> Perfect, thanks
07:56:12 <lpvb> > join "-" "asdfd"
07:56:13 <lambdabot>   Couldn't match expected type `[a]'
07:56:14 <lambdabot>         against inferred type `GHC.Types...
07:56:45 <lpvb> > join (Just (Just 3))
07:56:46 <lambdabot>   Just 3
07:57:17 <lpvb> is there a way to recurse that until it gets to the last monadic type?
07:57:36 <lpvb> > join . join (Just (Just (Just 3)))
07:57:37 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
07:57:37 <lambdabot>    arising from a use of...
07:58:03 <lpvb> > join (Just (Just (Just 3)))
07:58:04 <lambdabot>   Just (Just 3)
07:58:15 <lpvb> > join .join $ (Just (Just (Just 3)))
07:58:17 <lambdabot>   Just 3
08:00:58 <latro`a_> lpvb: such a function wouldn't be well-typed
08:01:32 <b__> Is there an idiom for pattern matching with elem?
08:01:43 <b__> I often have a couple of cases where I can use a literal
08:01:51 <latro`a_> example?
08:02:07 <b__> followed by a case where I need to test for x `elem` foo
08:02:52 <maukd> like, guards?
08:03:26 <lpvb> what is for?
08:03:32 <latro`a_> I'm not really sure what you're doing, but an example would be helpful
08:03:33 <b__> yeah, like guards
08:03:37 <b__> yeah 1 sec
08:04:48 <hpaste> b__ pasted “this” at http://hpaste.org/74475
08:05:42 <latro`a_> what is z
08:06:11 <b__> wish I could do: f ("foo"|"bar":xs) = ...
08:06:18 <b__> or something similar
08:06:21 <latro`a_> because it looks like what you're doing is basically removing bars and then mapping
08:06:26 <latro`a_> more or less
08:07:02 <latro`a_> erm...sorry, you're splitting at the first member of bars
08:07:24 <latro`a_> ...bah, no you're not, this is a really weird recursion pattern
08:07:39 <latro`a_> but when you hit a member of bars you throw out what you've seen already
08:08:09 <b__> my question is about lines 3, 4, 5. I was wondering if there is a better way to describe the `elem` match
08:08:27 <latro`a_> ...eh, nope, not that either, bah; I feel like this should be doable without explicit recursion
08:09:02 <latro`a_> I mean, there is, you are applying a function to f xs in both cases
08:09:56 <b__> the function isn't from the wild
08:10:05 <latro`a_> sec, writing an annotation
08:10:10 <b__> ok
08:10:49 <hpaste> latro`a annotated “this” with “this (annotation)” at http://hpaste.org/74475#a74476
08:11:31 <latro`a> this is of course longer, but it generalizes a bit, which (depending on what this is for) is usually a good thing
08:12:13 <latro`a> anyway, no, I don't think they're is; you're doing one thing if x is precisely "foo", another if it is in bars, and another thing if it is neither
08:12:24 <latro`a> you could use a pattern guard, which would save a binding
08:12:35 <b__> I've been meaning to read about those
08:13:04 <hpaste> latro`a annotated “this” with “this (annotation) (annotation)” at http://hpaste.org/74475#a74477
08:13:28 <latro`a> you could merge the [] into the guards as well
08:13:40 <b__> are those pattern guards?
08:13:42 <latro`a> of course you could also just use ==
08:13:46 <latro`a> the <- thing is a pattern guard
08:13:50 <b__> cool
08:13:57 <latro`a> in the case of matching on string literals you can just use ==
08:14:20 <latro`a> but you can also do like (Just y) <- x etc.
08:14:33 <b__> ahhh ok
08:14:44 <latro`a> which will actually bind y, letting you use it in the equation for that guard
08:15:38 <b__> using that binding would be right _after_ the binding right?
08:15:50 <Eelis> suppose i have a program that occasionally has to read some data from static files part of the program's installation.
08:15:53 <Eelis> this is file I/O, so normally i have to do it in the IO monad. using unsafePerformIO is evil because in theory, reading from the file isn't pure (because the file may have different contents at different times, or may not even exist!)
08:15:57 <Eelis> however, suppose i'm on btrfs and i take a btrfs read-only private snapshot of the whole filesystem right on program startup.
08:16:00 <Eelis> then later when i need to read my data files, it stands to reason that if i read from the private snapshot, this operation /is/ pure, and unsafePerformIO is justified. on btrfs, would it be evil to use this approach to pull this particular simple file I/O use case out of the nasty IO monad?
08:16:33 <b__> I'll go read some more on pattern guards, thanks latro`a
08:16:37 <latro`a> b__: yeah
08:17:32 <latro`a> maybe def f m | (Just x) <- m = f x; | otherwise = def
08:17:45 <latro`a> ^an example with which you are already familiar, but written as a pattern guard
08:17:47 <maukd> I don't think you need the parens
08:17:51 <latro`a> probably not
08:18:31 <maukd> maybe d _ Nothing = d; maybe _ f (Just (f -> y)) = y
08:18:42 <latro`a> ^the view patterns version
08:18:44 <latro`a> iirc
08:18:56 <latro`a> (haven't really used view patterns)
08:19:05 <benmachine> Eelis: people have different notions of purity. you'd avoid some of the worst pitfalls, but you might find it a headache even then
08:19:24 <Eelis> benmachine: hmm. do you foresee any particular problems?
08:19:42 <benmachine> Eelis: I don't know enough about btrfs to say
08:20:10 <Eelis> it seems natural to me to exploit filesystem features that let us get closer to a pure filesystem interface
08:20:19 <benmachine> sure, it's a good idea
08:20:19 <rwbarton> nothing wrong with unsafePerformIO readFile'ing files you don't expect to change
08:20:32 <rwbarton> as long as you're not in danger of running out of file handles
08:20:33 <Eelis> rwbarton: it feels dirty though :P
08:20:38 <benmachine> it should do
08:20:45 <rwbarton> meh, I do it all the time
08:20:54 <benmachine> well, it feeling dirty doesn't mean you shouldn't do it
08:20:55 <rwbarton> no, it's exactly the sort of thing unsafePerformIO is for
08:21:36 <benmachine> rwbarton: some people argue that if you have v :: String, then there really ought to be a genuine single string that v refers to
08:21:43 <rwbarton> there is, it's the contents of the file
08:21:44 <benmachine> not one that changes per program invocation
08:21:57 <rwbarton> "some data from static files part of the program's installation"
08:22:15 <benmachine> rwbarton: but Eelis referred to taking a snapshot on program startup
08:22:21 <rwbarton> unnecessary
08:22:50 <benmachine> rwbarton: the implication is, to me at least, that it can change between invocations
08:23:01 <benmachine> it's only static per program run
08:23:10 <rwbarton> it sounds like extra CYA, but imo his ass is already covered :P
08:23:31 <benmachine> CYA?
08:23:50 <rwbarton> cover your ass
08:23:54 <benmachine> I see
08:23:56 <rwbarton> i.e. defensive programming
08:23:56 <Eelis> yeah, i guess it depends on how paranoid you want to be
08:24:06 <Eelis> and making a btrfs snapshot for a static data file is pretty paranoid
08:24:20 <rwbarton> I mean even if you read it strictly with regular IO, have you considered that someone might modify the file while you are reading it
08:24:26 <benmachine> Eelis: assuming that you can't have e.g. exceptions thrown by the reading, you're pragmatically fine
08:24:35 <Eelis> yeah
08:24:40 <benmachine> rwbarton: at least the behaviour is defined in that case
08:24:50 <rwbarton> not in any useful way, unless you are using locks
08:24:52 <Eelis> rwbarton: well, that too would be avoided with the private snapshot approach
08:24:56 <rwbarton> you're subject to the whims of the scheduler
08:24:58 <rwbarton> yes, that is true
08:25:07 <rwbarton> if you don't make the snapshot, though
08:25:13 <benmachine> rwbarton: well, sure, but, I mean
08:25:21 <benmachine> the behaviour doesn't violate anything like RT
08:25:27 <benmachine> because it sort of opts-out of RT
08:27:03 <rwbarton> to put it another way, if you are concerned about the file changing between your program startup and the time unsafePerformIO readFile actually reads from the file, you should also be concerned about the file changing while you are in the middle of reading it if not using unsafePerformIO
08:28:39 <benmachine> rwbarton: but I believe that the result of an IO action being unreliable is by far a lesser crime than the value of a notionally pure type being unreliable
08:29:00 <rwbarton> it's not really unreliable though if you are reading "some data from static files part of the program's installation"
08:29:42 <rwbarton> if someone modifies the data file your program will do something different, yes. the data is part of the application. if someone modifies some bits of your executable your program will probably do something different also
08:29:48 <benmachine> rwbarton: okay, fair enough, but still, I think it's legitimate to be more concerned when you use unsafePerformIO
08:30:45 <rwbarton> right, of course you should be concerned and make sure it is a case where unsafePerformIO makes sense to use
08:30:48 <benmachine> rwbarton: when you're in IO, you get nice things like guaranteed ordering of exceptions
08:31:00 <benmachine> rwbarton: so when things go wrong it is easier to deal with
08:31:10 <daniel_-> @pl let logP t = logF t >>= putStrLn
08:31:10 <lambdabot> (line 1, column 33):
08:31:10 <lambdabot> unexpected end of input
08:31:10 <lambdabot> expecting letter or digit, variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<", ";" or "in"
08:31:17 <daniel_-> @pl logP t = logF t >>= putStrLn
08:31:17 <lambdabot> logP = (putStrLn =<<) . logF
08:31:43 <benmachine> @src (<=<)
08:31:43 <lambdabot> Source not found. Just try something else.
08:31:47 <benmachine> hmph
08:32:04 <benmachine> daniel_-: you might be interested in (<=<) from Control.Monad
08:32:07 <benmachine> or (>=>)
08:32:12 <daniel_-> oki
08:32:12 <aristid> :t ?logF >=> putStrLn
08:32:14 <lambdabot> forall a. (?logF::a -> IO String) => a -> IO ()
08:32:39 <benmachine> rwbarton: anyway, I initially missed that bit about it being considered part of the program
08:32:53 <benmachine> rwbarton: I guess in that case your stance is legitimate
08:33:51 <ben> What's a monotype?
08:34:00 <ben> Type without forall in it?
08:34:16 <benmachine> ben: where did you come across the word?
08:34:36 <benmachine> (I assume it's a type without type variables, but I can't say that with any authority)
08:34:42 <benmachine> (that would just be my guess)
08:34:52 <ben> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt "The result type of each constructor must begin with the type constructor being defined, but for a GADT the arguments to the type constructor can be arbitrary monotypes. "
08:35:18 <rwbarton> yeah, it can't be of the form "forall x. ..."
08:35:58 * hackagebot esqueleto 0.2.5 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2.5 (FelipeLessa)
08:36:00 * hackagebot compdata 0.6.1 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.6.1 (PatrickBahr)
08:36:57 <rwbarton> maybe it can't have a forall in a nested position even?
08:37:56 <benmachine> nested foralls are scary anyways
08:38:09 <benmachine> ben: ok, that doesn't sound like I was right, in which case shrug
08:38:20 <ben> All right
08:38:31 <ben> if it's not a really common term I'm fine not knowing it anyway
08:38:49 <benmachine> maybe it's a common term that I don't know :P
08:38:51 <bitonic> benmachine: really?  a GADT case can't be parametrised by some type with a type var. in it?
08:39:02 <benmachine> bitonic: like I said, it doesn't sound like I was right
08:39:11 <bitonic> ah, ok
08:39:14 <rwbarton> you can't write "data X a where X :: X (forall a. a)"
08:39:23 <benmachine> rwbarton: that's an impredicative type
08:39:35 <benmachine> so maybe with impredicative types enabled?
08:39:36 <rwbarton> you can't write it even with impredicative types
08:39:38 <benmachine> oh
08:39:39 <benmachine> ok
08:39:52 <benmachine> fair enough
08:39:59 <rwbarton> nor data X a where X :: X (Maybe (forall a. a))
08:40:17 <bitonic> well but you can write `data X a where X :: X [a]'
08:40:22 <benmachine> yes
08:40:45 <maukd> I can?
08:40:56 <rwbarton> I was confused at first because you could write newtype M = M (Maybe (forall a. a)) with impredicative types, then data X a where X :: X M
08:40:57 <bitonic> why not
08:41:01 <maukd> infinite type
08:41:17 <maukd> hmm, no
08:41:22 <maukd> I'm wrong about the scoping
08:41:28 <bitonic> what do you mean?
08:41:31 <bitonic> ah
08:41:35 <bitonic> there isn't a forall there
08:41:44 <rwbarton> but the M is just a label, not a field
08:42:25 <rwbarton> as far as the GADT is concerned there is no real relation between M and Maybe (forall a. a)
08:42:46 <benmachine> bitonic: I think it's more that the a in "data X a" isn't necessarily anything to do with the one in "X :: X [a]"
08:42:58 <benmachine> bitonic: you could have just written data X :: * -> * instead, after all
08:43:03 <bitonic> yes
08:43:04 <benmachine> (I think)
08:43:08 <bitonic> well
08:43:29 <Eelis> benmachine, rwbarton: thanks for your thoughts on using btrfs snapshotting for purity! :)
08:43:29 <rwbarton> might need some extra extension, but yes
08:43:36 <bitonic> benmachine: yeah
08:43:46 <benmachine> Eelis: I was going to refer you to a blog post about purity but the blog seems to have died
08:44:07 <benmachine> Eelis: http://conal.net/blog/posts/notions-of-purity-in-haskell it might only be temporary
08:44:17 <bitonic> I think it means that all the foralls need to be to the left of the
08:44:20 <Eelis> benmachine: thanks
08:44:30 <bitonic> type constructor, in the return type
08:44:43 <rwbarton> Eelis: this reminds me of something I was wondering about actually, is there a reason I can't mmap a file and set it up so that my version of the file is unshared when others write to the file
08:45:01 <bitonic> in other words, a type with no quantification
08:45:36 <benmachine> data X a where X :: (forall a. a) -> X Char -- is fine, though
08:45:40 <bitonic> e.g. `data X :: * -> * where X :: forall a. X [a]' works
08:45:41 <benmachine> if you have RankNTypes on\
08:45:55 <bitonic> well that would certainly work
08:45:59 <rwbarton> basically a snapshot that is copy-on-write in both directions... after all isn't that the behavior of fork()
08:46:23 <benmachine> Eelis: isn't that how linux does it anyway?
08:46:26 <benmachine> or no wait
08:46:44 <benmachine> Eelis: that was addressed at the wrong person anyawy
08:46:51 <Eelis> np :)
08:47:11 <benmachine> rwbarton: I have a feeling that if you used MAP_PRIVATE it would be copy-on-other-people-writing
08:47:21 <benmachine> if that makes sense
08:49:13 <rwbarton> that's what I'm going for yeah
08:49:53 <benmachine> rwbarton: I mean, it would be sensible if that were the case, right?
08:51:24 <rwbarton> the man page for mmap says "Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file.  It is unspecified whether changes made to the file after the mmap() call are visible in the mapped region."
08:51:43 <Lutin_> mmmap
08:51:44 <rwbarton> so copy on write when I write, but not necessarily copy on write when someone else writes
08:51:55 <tgeeky> write
08:52:20 <benmachine> rwbarton: ah, good old unspecified
08:52:56 <rwbarton> :)
08:53:12 <tgeeky> i guess they expect you to flush and re mmap() when you write the file?
08:53:22 <geekosaur> if you MAP_PRIVATEd it, it s up to the underlying memory manager hether it's COW or separate copies from the start
08:53:28 <rwbarton> it does seem a little tricky because someone might be modifying the file directly via seek()/write() rather than mmap()
08:53:29 <benmachine> tgeeky: possibly, but you might not want to write the file at all
08:54:17 <benmachine> rwbarton: yeah, I guess you have a situation where you writing something to a file could cause a whole bunch of other processes who had it mmapped to say "no I want to copy it before you do that"
08:54:28 <rwbarton> yes
08:54:59 <tgeeky> benmathat's no big deal, since they will just update the pages which ... have updated
08:55:05 <tgeeky> oops prefix
08:55:19 <tgeeky> I remember learning about this stuff (specifically) in school
08:55:25 <benmachine> tgeeky: the whole point is they don't *want* the pages updated
08:55:30 <benmachine> they want a static snapshot
08:55:31 <rwbarton> is that a problem though? it still seems better than each of those processes eagerly reading the whole file
08:55:34 <benmachine> or at least, rwbarton does
08:55:37 <rwbarton> right
08:55:42 <rwbarton> well, and Eelis originally
08:55:47 <benmachine> yeah
08:55:53 <rwbarton> I was wondering at some point whether Haskell could do this for readFile in general
08:56:09 <benmachine> mm
08:56:12 <benmachine> it would be nice
08:56:18 <rwbarton> I guess maybe not on POSIX, but I don't see why the OS couldn't support this in principle
08:56:22 <tgeeky> i'm fuzzy -- isn't this the technique that "forest" took?
08:56:23 <benmachine> yes
08:56:34 <rwbarton> but, I could be missing something
08:58:04 <tgeeky> http://www.cs.cornell.edu/~jnfoster/papers/forest-icfp.pdf <--
08:58:17 <rwbarton> well, this shouldn't replace readFile but rather a strict readFile
09:02:06 <sheldonh> how can i indicate a function as a data type constructor parameter? e.g. data CalculatorOperation = CalculatorInt Int | CalculatorOp ?
09:03:00 <rwbarton> put a function type like (String -> Bool) there
09:03:21 <sheldonh> oh cool, simple as that! thanks :)
09:03:28 <latro`a> functions are just data
09:03:41 <latro`a> :)
09:09:38 <daniel_-> why cant i match my exception class with (SomeException e)
09:09:52 <daniel_-> exception type*
09:10:21 <daniel_-> if every exception is encapsulated in SomeException?
09:10:58 * hackagebot roots 0.1.1.2 - Root-finding algorithms (1-dimensional)  http://hackage.haskell.org/package/roots-0.1.1.2 (JamesCook)
09:11:31 <rwbarton> are you using Prelude.catch or Control.Exception.catch, and are you using throw or throwIO (or what)
09:11:51 <daniel_-> Control.Exception.Catch and throw
09:11:58 <benmachine> daniel_-: every exception type is convertible to SomeException via toException
09:12:05 <benmachine> daniel_-: but they are not actually the same type
09:13:06 <rwbarton> maybe your throw isn't getting evaluated inside the execution of the action you pass to catch
09:13:19 <rwbarton> s/inside/during/ would be clearer i guess
09:13:34 <monochrom> guess the cause in 20 questions
09:13:49 <daniel_-> Could not deduce (e ~ ServiceException)
09:13:49 <daniel_->     from the context (Exception e)
09:13:54 <otters> the SomeException typeclass hierarchy is one of the few things that still confuses me
09:14:11 <daniel_-> that is what confuses me
09:14:26 <daniel_-> since SomeException encapsulates all Exceptions
09:14:32 <rwbarton> well surely those two lines in isolation are not confusing
09:15:49 <monochrom> @type undefined :: ArithException
09:15:50 <lambdabot>     Not in scope: type constructor or class `ArithException'
09:16:06 <daniel_-> i just want to log all my own made exceptions and clean up after them, and then catch all others and log which exception it was and do some clean up
09:16:19 <daniel_-> pattern match
09:20:36 <monochrom> f :: (Exception e) => e -> Bool; f Overflow = True; f _ = False;  {- Overflow has type ArithException -}
09:20:44 <monochrom> this is a type error
09:21:37 <monochrom> the type sig says: user chooses e. the implementation says: implementer chooses e, and implementer wants e to be ArithException
09:22:04 <latro`a> you're trying to both type-match, basically, right?
09:22:06 <latro`a> er
09:22:09 <latro`a> -both
09:22:11 <monochrom> clearly, you can't give the same freedom to both user and implementer. they will choose conflicting things
09:22:47 <latro`a> like, if an exception is an ArithException and specifically matches Overflow, return True, otherwise False
09:23:01 <latro`a> but you can't type-match
09:23:05 <monochrom> I am trying to cause a type error
09:23:32 <latro`a> right; "type-matching" is a type error
09:24:31 <monochrom> I don't know whether I'm type-matching or not. perhaps you know my brain? as far as I know, I am trying to cause a type error by acting misguided
09:24:40 <latro`a> example, you can't do this
09:25:01 <latro`a> class FooOrBar a where baz :: a
09:25:09 <xz> is there a list of internationalised haskell learning resources?
09:25:10 <latro`a> instance FooOrBar Foo where baz = foo
09:25:15 <xz> e.g. in other languages
09:25:19 <latro`a> instance FooOrBar Bar where baz = bar
09:25:23 <daniel_-> so you cant match for two different Exception types?
09:25:50 <latro`a> bem :: FooOrBar a => a -> Bool
09:25:58 <latro`a> now bem can't tell whether its input is a Foo or a Bar
09:26:32 <nand`> Data.Fixed doesn't have any shenanigans like NaN, Infinity or -0, right?
09:26:38 <hpaste> timthelion pasted “WTF” at http://hpaste.org/74478
09:27:07 <timthelion> Anyone come across that error before? It's the seccond time I've gotten it.  But last time, deletling all the .o files fixed it.  This time, it won't go away!
09:27:45 <monochrom> I'm pretty sure you're thinking like "g :: (Monad m) => m a -> (); g [] = (); g Nothing = (); ..."
09:28:02 <latro`a> same idea, yes
09:28:29 <latro`a> a function with that type can't do anything that isn't eventually defined in terms of just return and >>=
09:28:43 <latro`a> (and function application)
09:29:12 <monochrom> python and php allow you to do that. kind of. lack pattern-matching
09:29:24 <latro`a> in fact since it knows nothing about a, there is very little it can do to it, either
09:31:47 <benmachine> nand`: no, pretty sure it doesn't, internally it's just an Integer
09:33:16 <hpaste> daniel_- pasted “exception handling” at http://hpaste.org/74479
09:35:49 <daniel_-> ^ using Control.Exception.Catch and not Prelude.Catch
09:35:59 <daniel_-> catch*
09:42:25 <latro`a> yeah I'm fairly sure you can't actually do that
09:42:38 <daniel_-> okey
09:42:53 <latro`a> I haven't really studied how Control.Exception works, but just from the type system perspective I'm pretty sure you can't
09:43:27 <daniel_-> but if i would only match my ServiceException's and just leave a "_ -> do exitFailure" would this catch all other exceptions still?
09:43:41 <nand`> latro`a: iirc it uses Typeable for safe casting
09:43:46 <latro`a> matching your ServiceExceptions fixes the type
09:43:57 <latro`a> ...unless it actually does internal casts, in which case maybe not
09:44:20 <nand`> fromException :: SomeException -> Maybe ArithException
09:45:44 <nand`> so if you pass in a handler that only accepts ArithException, and the an arbitrary exception gets thrown, the handler would try to cast it to ArithException and if that succeeds, pass it to your handler, otherwise continue throwing it
09:46:10 <benmachine> daniel_-: if you want to catch all exceptions, you're doing the right thing with matching on SomeException, but as others have said you then need to use fromException
09:46:26 <latro`a> he wants to catch two different types, so it's gonna require two calls to fromException
09:47:12 <startling> so is there a Ring typeclass somewhere or not?
09:47:28 <daniel_-> ye im trying to make it work with fromException
09:47:39 <nand`> um
09:47:53 <nand`> wouldn't you use ‘catches’ with two different handlers?
09:47:59 <nand`> let the function take care of casting etc. for you
09:48:11 <latro`a> probably better yeah
09:48:23 <maukd> @hoogle catches
09:48:23 <lambdabot> Control.Exception catches :: IO a -> [Handler a] -> IO a
09:48:24 <startling> @hoogle Ring
09:48:25 <lambdabot> Graphics.UI.GLUT.Objects type Rings = GLint
09:48:25 <lambdabot> Prelude data Ordering :: *
09:48:25 <lambdabot> Data.Ord data Ordering :: *
09:48:34 <nand`> in fact, catching two different types of exception is exactly the example used to outline ‘catches’
09:48:42 <daniel_-> oh
09:49:01 <daniel_-> didnt know that existed
09:49:01 <daniel_-> thanks
09:49:03 <nand`> expr `catches` [Handler (\ (ex :: ArithException) -> handlerArith ex), Handler (\ (ex :: IOException) -> handlerIO ex)]
09:49:35 <maukd> did you mean: [Handler handlerArith, Handler handlerIO]
09:49:55 <nand`> I just copied the example from ‘catches’' documentation
09:50:17 <nand`> I guess they wanted to emphasize that the two have different types
09:50:59 * hackagebot flexible-defaults 0.0.1.0 - Generate default function implementations for complex type classes.  http://hackage.haskell.org/package/flexible-defaults-0.0.1.0 (JamesCook)
09:51:44 <latro`a> that foldr under the hood is pretty clever
09:58:47 <ion> Under the hood of what?
10:05:02 <lpvb> @hoogle (Monad m) => IO (a -> b) -> m a -> m b
10:05:02 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
10:05:03 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
10:05:03 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:05:12 <lpvb> can I use ap for that?
10:06:15 <linusoleander> I'm trying to iterate over a list and for each value apply a function, but I can't get it to work
10:06:15 <linusoleander> https://gist.github.com/15fe7b499bac339d902f
10:06:27 <linusoleander> Anyone got an idea?
10:07:20 <maukd> define "work"
10:07:22 <geekosaur> lpvb, I don't understand what you want there.  but you can't "escape" IO, so that IO (a -> b) looks dubious at best
10:07:24 <linusoleander> (start..stop).each{|n| myCustomMethod(n, var1, var2)}
10:07:35 <linusoleander> That is how I would do it in Ruby
10:08:06 <nand`> the haskell way would be ‘map’
10:08:23 <maukd> forM_ [start .. stop] $ \n -> myCustomMethod n var1 var2
10:08:30 <linusoleander> Map will put back the value, that i do not want
10:08:51 <Sweden_jack> linusoleander: Look at maukd's forM_
10:08:57 <lpvb> @hoogle (Monad m) => (a -> IO b) -> m a -> m b
10:08:57 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:08:58 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:08:58 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:09:15 <benmachine> lpvb: ap will get you IO (a -> b) -> IO a -> IO b
10:09:20 <ion> linusoleander: map function [start..stop]
10:09:29 <lpvb> I see I need =<<?
10:09:44 <linusoleander> ion: Yes, but I don't need the value calculated by myCustomMethod
10:09:44 <benmachine> lpvb: uh, probably not
10:09:52 <linusoleander> myCustomMethod returns an IO()
10:09:54 <ceii_> ceii
10:09:54 <geekosaur> not what I meant.  what exactly are you trying to acconplish?
10:09:59 <ion> linusoleander: Then see what maukd said.
10:10:04 <ceii_> oops, ignore that
10:10:19 <geekosaur> my point was that you have an IO thing but the result of the entire function is not an IO thing, it's an m thing
10:10:21 <nand`> linusoleander: so you want to compute a bunch of IO ()s, then do nothing with them?
10:10:34 <geekosaur> IO can't be escaped
10:11:13 <lpvb> benmachine: it says it expected a 'a -> m b' but got an 'a -> IO b' instead
10:11:14 <linusoleander> nand`: myCustomMethod prints the calculated value
10:11:46 <benmachine> lpvb: hpaste the context
10:12:07 <linusoleander> ion: Yes, that works. But I don't think that is something I can use in my case. I'm trying to solve a problem in a "introduction to functional programing" course
10:12:10 <nand`> haskell functions don't have side effects
10:12:32 <hpaste> lpvb pasted “lpvb” at http://hpaste.org/74482
10:12:32 <linusoleander> I think I should use some kind of recursion
10:12:37 <maukd> linusoleander: then you won't have a bunch of IO ()'s
10:12:41 <nand`> your myCustomMethod really isn't printing anything, it's returning an IO () action
10:13:07 <maukd> @src forM_
10:13:07 <lambdabot> forM_ = flip mapM_
10:13:10 <maukd> @src mapM_
10:13:10 <lambdabot> mapM_ f as = sequence_ (map f as)
10:13:18 <lpvb> getBangCommandText is an Irc Bytestring
10:13:19 <maukd> @src sequence_
10:13:20 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
10:13:34 <lpvb> write is a Bytestring -> Irc ()
10:13:40 <linusoleander> How would I solve it by using recursion ?
10:13:43 <bitonic> does anybody have experience with {mysql,postgresql}-simple?  I have a question with query formatting: how do I insert multiple rows in a query without having to insert multiple `?'?
10:13:54 <nand`> linusoleander: for starters, I'm not sure what problem you are trying to solve
10:14:25 <linusoleander> nand`: I want to do this, but with recursion: (start..stop).each{|n| myCustomMethod(n, var1, var2)}
10:14:39 <ion> linusoleander: Also, it’s often better to use functions like maps and folds that do the recursion for you instead of doing it manually.
10:14:48 <lpvb> is there a liftIO for an a -> IO a function?
10:14:57 <linusoleander> I*ve a start and stop value, each value in the list should be passed to a function with some other variables
10:15:20 <benmachine> lpvb: you can just liftIO the result...
10:15:20 <ion> lpvb: (liftIO .)
10:16:00 * hackagebot hfsevents 0.1.3 - File/folder watching for OS X  http://hackage.haskell.org/package/hfsevents-0.1.3 (LuiteStegeman)
10:16:30 <ion> linusoleander: How about making the function return a value instead of printing said value and then just using map?
10:17:01 <nand`> linusoleander: I meant the actual problem, not just ‘I want to apply this function a bunch of times’
10:17:08 <linusoleander> ion: Yeah, that might be a better solution
10:17:17 <nand`> because I suspect your solution is fundamentally going down the wrong path
10:23:44 <juliohm> I really want to use Haskell, but afraid if it'll be able to manage huge amounts of data. Since it's pure and there is no move semantics of any kind. Suppose i work with big matrices (~million entries), what do you think of Haskell in this context?
10:24:19 <juliohm> I should keep with C++ and it's terrible template system to achieve generics?
10:24:25 <luite> juliohm: haskell does have mutable arrays if required for some algorithm
10:24:58 <juliohm> luite, mutable in what sense? I can update an data structure with no overhead?
10:25:03 <startling> juliohm, yes
10:25:04 <ion> yes
10:25:04 <hpc> GHC has some absolutely magical optimizations
10:25:05 <Eduard_Munteanu> juliohm: what sort of matrices? If you're doing linear algebra, you'd normally call some external lib like GSL to handle them
10:25:05 <luite> juliohm: yes
10:25:26 <Eduard_Munteanu> E.g. see hmatrix
10:25:34 <Eduard_Munteanu> @hackage hmatrix
10:25:35 <lambdabot> http://hackage.haskell.org/package/hmatrix
10:26:11 <bitonic> is there some some standard QQ that lets you write multi-line strings?
10:26:18 <bitonic> something that just returns the string contained
10:26:22 <benmachine> bitonic: standard, no. there are several packages that do it
10:26:29 <nand`> bitonic: there's a string quoter
10:26:31 <benmachine> or you can define your own easily
10:26:37 <nand`> but it's not standard yeah
10:26:37 <bitonic> benmachine: well, with "standard" I meant something that a lot of people use
10:26:51 <juliohm> Interesting, is it possible to call C/C++ routines from within Haskell?
10:26:55 <luite> yes
10:26:56 <luite> C
10:27:01 <benmachine> C is much easier than C++
10:27:13 <bitonic> whatever, I'll roll my own, it's probably a couple of lines
10:27:22 <juliohm> luite, there is some example so that i can get a feeling on how it's done?
10:27:25 <startling> juliohm: yes, C, but you'll need to either a) know reasonably that it's pure-ish or b) use it in IO
10:27:38 <benmachine> bitonic: I don't know what people use, but this might help you decide http://packdeps.haskellers.com/reverse
10:27:40 <Eduard_Munteanu> juliohm: normally you'd use one of the existing linear algebra libs like the one I mentioned
10:27:50 <luite> juliohm: http://www.haskell.org/haskellwiki/GHC/Using_the_FFI
10:28:39 <luite> juliohm: oh looks like that only has more advanced examples
10:28:40 <juliohm> Eduard_Munteanu, i see, just wondering, because it's a hard decision to take. I just don't want C++ anymore, it's too hack. :(
10:28:40 <Eduard_Munteanu> Which is a good idea even if you're using C, that is, not rolling your own matrix algos.
10:29:05 <luite> juliohm: the introduction is better then: http://www.haskell.org/haskellwiki/FFI_Introduction
10:29:53 <yitz> bitonic: haskell has syntax that allows multi-line strings, without a QQ
10:30:16 <scshunt> yitz: does it?
10:30:35 <luite> juliohm: it's really easy to call a C function, and there are packages that store arrays in a way that C can use them directly (as a pointer), so no conversion is needed at all
10:30:46 <bitonic> yitz: yeah, with slashes
10:30:47 <yitz> end the line with a backslash, indent the next line as much as you'd like, then start again with another backslash
10:30:50 <bitonic> I don't like it
10:31:00 * hackagebot esqueleto 0.2.6 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2.6 (FelipeLessa)
10:31:09 <juliohm> Eduard_Munteanu, luite , what's your experience with Engineering applications in Haskell?
10:31:40 <yitz> bitonic: many people just forget about them, whether or not they like them
10:31:47 <Eduard_Munteanu> juliohm: I'm not sure what you mean by "engineering applications".
10:31:54 <bitonic> yitz: I'm sure I don't like them :P
10:31:59 <juliohm> Lots of parallelism (MPI), numerical algorithms, and so on.
10:33:05 <juliohm> I mean, the focus here is to write programs to do physics, machine learning, ...
10:33:16 <juliohm> massive data and computation
10:33:40 <bitonic> very big numbers
10:33:49 <luite> i've done some non-distributed numerical things with haskell, which worked pretty well, but not quite C-level speed
10:34:20 <bitonic> there's nothing in Haskell that prevents you from handling "huge amounts of data"
10:34:24 <juliohm> luite, did you measured the overhead? How much slow the end program was compared to a C implementation?
10:34:56 <Eduard_Munteanu> juliohm: it's quite fast if you're not implementing the algos themselves in Haskell.
10:34:59 <luite> distributed apps are probably possible with cloud haskell (perhaps there are other alternatives?) not sure how it deals with huge data
10:35:46 <juliohm> bitonic, i had this idea because of the pure concept of the language, by default everything is immutable, and i don't know how much work a programmer would have to make this statement less strong.
10:36:08 <yitz> actually, it's more general than that. in a string literal, two backslashes around any sequence of one or more whitespace characters is a "gap" and is ignored.
10:36:13 <luite> juliohm: uh in my case it was only 25% slower or so, because most of the time was spent in C libraries (linear programming and linear algebra)
10:36:15 <bitonic> juliohm: you can write imperative algorithms easily in Haskell, and you often don't need to anyway.
10:36:51 <juliohm> bitonic, i want functional programs, i really liked the paradigm.
10:37:20 <luite> juliohm: (that's an estimate because i don't have the full algoritms in C, but the amount of time spent in foreign libs gives a nice upper bound. a t least i could keep the haskell part nicely pure and get things like automatic differentiation :) )
10:37:36 <bitonic> juliohm: I'm not sure what your concern is then
10:38:13 <juliohm> I'm just too annoyed with C++, if Haskell is an alternative, it will be my first try.
10:38:26 <juliohm> Python is another strong candidate
10:38:53 <bitonic> juliohm: of course Haskell is an alternative
10:39:08 <bitonic> unless you're strongly coupled with C++ libraries/tools
10:39:12 <badabing> juliohm; what are you doing?
10:39:48 <kanedank> can I use this technique (first answer): http://stackoverflow.com/questions/2349798/in-haskell-how-can-i-use-the-built-in-sortby-function-to-sort-a-list-of-pairst with tuples with a more complicated layout?: http://hpaste.org/74484
10:41:00 <juliohm> badabing, my next project involves Geostatistics (Kriging, Gaussian Simulation, ...), Karhunen-Loeve representations of random fields, convex optimization (probably robust optimization), etc.
10:41:06 <monochrom> ((x1, y1) c1) is a type error
10:43:07 <yitz> > ((1, 3), 4) < ((3, 1), 1) -- kanedank
10:43:08 <lambdabot>   True
10:43:35 <badabing> juliohm: well poython has a lot of libs for that  i think.
10:43:39 <juliohm> we will certainly need some distributed parallelism (embarassedly parallelism), let me see how is the state of that in Haskell...
10:43:45 <badabing> cvxopt for example
10:43:48 <yitz> kanedank: you want to reverse the compare on xs and ignore cs, is that it?
10:43:53 <juliohm> badabing, yes, Python is pretty complete set of libraries
10:44:02 <juliohm> @hackage mpi
10:44:02 <lambdabot> http://hackage.haskell.org/package/mpi
10:44:21 <juliohm> ops, this bot returns invalid URLs?
10:44:37 <maukd> sure
10:44:50 <maukd> '@hackage' is a string operation, not a search engine
10:45:08 <maukd> @hackage foo bar baz
10:45:08 <lambdabot> http://hackage.haskell.org/package/foo bar baz
10:45:46 <applicative> hm, this 'experience report' on using Haskell in computational biology http://www.cs.tufts.edu/~nr/pubs/mrfy.pdf ends with the mysterious line "You can live to surf the Haskell wave, but if you slide off the crest, you drown"
10:46:45 <monochrom> yeah, what a tautology
10:47:47 <yitz> > sortBy (comparing $ first negate . fst) [((x, y), c) | [x,y,c] <- replicateM 3 [1,2,3]] -- kanedank
10:47:49 <lambdabot>   [((3,1),1),((3,1),2),((3,1),3),((3,2),1),((3,2),2),((3,2),3),((3,3),1),((3,...
10:48:36 <applicative> juliohm: what kind of thing is represented by these giant matrices?
10:49:08 <applicative> juliohm: oh i see you mention geostatistics
10:49:53 <juliohm> applicative, you also work with Geostatistics? :)
10:50:34 <applicative> juliohm: no, I was wondering what kind of thing you were worrying about, I think I missed the beginning
10:51:22 <juliohm> I really want a more productive language, C++11 is great, but is still an ugly language.
10:53:32 <applicative> juliohm: take a look at that experience report I mentioned, its quite recent and pretty realistic, I think http://www.cs.tufts.edu/~nr/pubs/mrfy.pdf
10:55:05 <juliohm> applicative, very nice, thanks.
10:57:36 <latro`a> I liked that article, though I twitched at some things that could've been simplified
10:58:08 <latro`a> such as: costedUtility pt cost = utility sg move >>= \u -> return $ CCosted u cost
10:58:30 <applicative_> latro`a: that's part of the realism I was talking about though
10:58:37 <latro`a> true, true
10:59:00 <latro`a> that one in particular isn't bad at all
10:59:02 <latro`a> this is:
10:59:17 <latro`a> search strat test = return . test =<< everyPt strat 0 =<< pt0 strat
11:00:03 <maukd> why bad?
11:00:28 <latro`a> eh, they had to explain the use of =<< (because of the audience), and the return (as in the previous example) is unnecessary
11:00:37 <latro`a> or rather can be avoided with fmap
11:00:45 <applicative_> hm whats best, fmap test $ pt0 strat >>= everyPt strat0
11:01:01 * hackagebot List 0.5.1 - List monad transformer and class  http://hackage.haskell.org/package/List-0.5.1 (YairChuchem)
11:02:08 <latro`a> either that or a single =<<
11:02:21 <latro`a> no need for a whole pipeline that ends in return
11:03:01 <Ralith> :t =<<
11:03:02 <lambdabot> parse error on input `=<<'
11:03:05 <Ralith> :t (=<<)
11:03:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:03:09 <applicative_> @pl liftM test $ pt0 strat >>= everyPt strat0
11:03:09 <lambdabot> fmap test (everyPt strat0 =<< pt0 strat)
11:03:35 <applicative_> @pl \strat test -> liftM test $ pt0 strat >>= everyPt strat 0
11:03:35 <lambdabot> flip fmap . liftM2 (>>=) pt0 (flip everyPt 0)
11:03:49 <applicative_> ah well
11:04:17 <applicative_> @pl \ test  strat  -> liftM test $ pt0 strat >>= everyPt strat 0
11:04:17 <lambdabot> (. liftM2 (>>=) pt0 (flip everyPt 0)) . fmap
11:04:36 <timthelion> When I'm using something like cabal-dev or hellno, how do I actually use a package that is only installed from inside a sandbox?
11:05:22 <applicative_> doesn't cabal-dev have an internal way of calling ghci?
11:05:31 <hpaste> cardamon pasted “card's xmonad mess” at http://hpaste.org/74486
11:06:35 <parcs`> timthelion: ghc -package-conf cabal-dev/lib
11:06:53 <parcs`> i forgot what the actual subdir is called.. i think it's lib
11:06:58 <timthelion> parcs`: thanks :)
11:07:16 <timthelion> parcs`: I'll use tab completion to figure out the subdir, don't worry :)
11:07:36 <timthelion> or ls,  great program ls :D
11:07:49 <parcs`> oh cabal-dev/packages-*.conf
11:08:17 <cardamon> Sorry about that paste guys.  I clicked the wrong thing.
11:08:54 <yitz> timthelion: inside your other sandbox, use cabal-dev add-source path/to/other/sandbox
11:09:41 <timthelion> yitz: that means that I have to have a cabal file associated with every file I compile?
11:09:48 * timthelion does a lot of 30 liners.
11:09:58 <yitz> timthelion: after first running cabal-dev sdist in the "remote" sandbox
11:11:30 <yitz> timthelion: well, no, that's how you let one sandbox use another. truth is, i tend to put my 30-liners inside of some existing cabal project somewhere.
11:13:50 <yitz> timthelion: usually, i just plop my 30-liner into whatever project i'm working on. if later i see i need it other places, then it's worth it to break it out into its own cabal project.
11:14:36 <timthelion> yitz: OK :/
11:21:01 * hackagebot gutenberg-fibonaccis 1.0.5 - The first 1001 Fibonacci numbers, retrieved from the Gutenberg Project.  http://hackage.haskell.org/package/gutenberg-fibonaccis-1.0.5 (JustinHanekom)
11:21:10 <ion> :-D
11:21:22 <ion> I like the fact that the package is even maintained.
11:21:53 <ben> It's not documented though :(
11:22:43 <LambdaDusk> Monad Transformers - The Movie
11:22:45 <ion> lastFib :: Integer
11:22:52 <maukd> http://hackage.haskell.org/packages/archive/gutenberg-fibonaccis/1.0.4/doc/html/Algorithm-Gutenberg-Fibonaccis.html
11:23:00 <ben> huh
11:23:11 <ben> Why isn't that linked from the package page?
11:23:28 <sclv_> maukd: are you mauke?
11:23:29 <ben> Did they not build documentation for 1.0.5?
11:23:36 <ben> yet*, i guess
11:23:40 <sclv_> if so, what happen to preflex?
11:23:43 <rwbarton> not in the past 3 minutes
11:23:45 <maukd> ben: how could they, it was just uploaded
11:23:59 <maukd> sclv_: hardware failure
11:24:04 <maukd> it's sleeping
11:24:08 <sclv_> :-(
11:24:14 <ben> I don't see why it's so unlikely that they build documentation before getting it to a place where the bot can announe it
11:24:27 <rwbarton> resting?
11:24:29 <maukd> ben: because documentation is built in batches
11:24:31 <benmachine> hackagebot only announces every five minutes or so
11:24:38 <linusoleander> Im trying to get this code to work, but I'm stuck
11:24:39 <linusoleander> https://gist.github.com/c60d0d3517716ba817a5
11:25:03 <linusoleander> What I'm I doing wrong?
11:25:06 <maukd> linusoleander: ( )
11:25:08 <ben> Remove the ( ) in line 3
11:25:27 <linusoleander> Hehe
11:25:34 <linusoleander> That worked, thanks
11:25:35 <ben> (x n) is a function call, not a parameter list
11:25:49 <monochrom> sin (cos x) vs (sin cos) x
11:26:07 <maukd> > (sin cos) x
11:26:08 <lambdabot>   sin (cos x)
11:26:15 <benmachine> haha
11:26:19 <maukd> where is your god now?
11:26:19 <monochrom> hahaha
11:26:20 <benmachine> oh lambdabot, you crazy
11:26:37 <maukd> proof: function application is associative
11:26:41 <benmachine> :D
11:26:59 <Sculptor> > sin cos x
11:26:59 <ben> :t sin
11:27:00 <lambdabot>   sin (cos x)
11:27:00 <lambdabot> forall a. (Floating a) => a -> a
11:27:21 <ben> idgi
11:27:33 <maukd> ishiggydiggy
11:27:34 <rwbarton> > log log 1000000
11:27:35 <lambdabot>   2.625791914476011
11:27:39 <rwbarton> useful :)
11:27:49 <Sculptor> > sin $ cos x
11:27:50 <lambdabot>   sin (cos x)
11:27:57 <benmachine> ben: instance Floating b => Floating (a -> b)
11:28:12 <ben> oh. oh dear.
11:28:15 <maukd> > (sin + 1) x
11:28:16 <lambdabot>   sin x + 1
11:28:31 <maukd> > (sin * 2 + cos) x
11:28:33 <lambdabot>   sin x * 2 + cos x
11:28:44 <ben> > (sin^2) x
11:28:45 <lambdabot>   sin x * sin x
11:28:48 <maukd> > deriv (sin * 2 + cos) x
11:28:49 <lambdabot>   1 * cos x * 2 + 1 * negate (sin x)
11:28:51 <hiptobecubic> wow
11:28:56 <ben> :t deriv
11:28:57 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
11:29:06 <Playground> Wait, what?
11:29:06 <Playground> Should that not be "log $ log 1000000"?
11:29:13 <rwbarton> haha
11:29:24 <maukd> > 1 2 3
11:29:25 <lambdabot>   1
11:29:30 <maukd> it's as easy as 1 2 3
11:31:32 <Playground> :i Dif
11:32:05 <ben> :! rm -Rf /
11:33:27 <maukd> @hoogle Dif
11:33:27 <lambdabot> package Diff
11:33:27 <lambdabot> Data.Time.Clock.TAI diffAbsoluteTime :: AbsoluteTime -> AbsoluteTime -> DiffTime
11:33:27 <lambdabot> package diffarray
11:33:33 <maukd> aw
11:34:09 <nand`> is it a lambdabot local library?
11:34:46 <maukd> @hackage numbers
11:34:46 <lambdabot> http://hackage.haskell.org/package/numbers
11:34:55 <nand`> ah
11:35:14 <maukd> http://hackage.haskell.org/packages/archive/numbers/3000.0.0.0/doc/html/Data-Number-Dif.html
11:36:07 <maukd> > 1 :: Dif ()
11:36:08 <lambdabot>   No instance for (GHC.Num.Num ())
11:36:09 <lambdabot>    arising from the literal `1' at <intera...
11:36:11 <maukd> > 1 :: Dif Int
11:36:12 <lambdabot>   1~~
11:36:49 <maukd> > df 2
11:36:50 <lambdabot>   0~~
11:37:17 <nand`> > sin 1 :: Dif Expr
11:37:19 <lambdabot>   sin 1~~
11:37:31 <hpc> > df sin
11:37:32 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a'
11:37:32 <lambdabot>         against inferr...
11:37:35 <hpc> > df sin 1
11:37:36 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a'
11:37:37 <lambdabot>         against inferr...
11:37:38 <hpc> :(
11:37:44 <hpc> :t df
11:37:45 <lambdabot> forall a. (Num a) => Dif a -> Dif a
11:38:01 <hpc> > df sin <*> 1
11:38:02 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif (a -> b)'
11:38:02 <lambdabot>         against...
11:38:22 <maukd> hpc: ?
11:38:52 <hpc> trying to trigger the function Num instance
11:39:29 <maukd> Dif is not a function
11:39:59 <nand`> > val (df sin) 1
11:40:00 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a'
11:40:00 <lambdabot>         against inferr...
11:40:02 <hpc> @ty df
11:40:03 <lambdabot> forall a. (Num a) => Dif a -> Dif a
11:40:13 <hpc> > 1 `asTypeOf` sin
11:40:14 <rwbarton> > df (sin 1)
11:40:14 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:40:14 <lambdabot>    arising from a use of `...
11:40:15 <lambdabot>   can't find file: L.hs
11:40:17 <rwbarton> > df (sin 1)
11:40:18 <lambdabot>   0.0~~
11:40:24 <hpc> @ty 1 `asTypeOf` sin
11:40:25 <lambdabot> forall a. (Floating a) => a -> a
11:40:56 <nand`> oh
11:40:59 <hpc> maukd: there's your Num instance
11:41:01 <nand`> it's Floating a, Eq a => Floating (Dif a)
11:41:08 <hpc> ooooh
11:41:10 <nand`> sin is not Eq
11:41:15 <nand`> so it wouldn't work either way
11:41:27 <nand`> (same for Num (Dif a))
11:41:29 <hpc> well that's annoying
11:41:35 <t7> can I emit ASM from a very basic C AST or do i need to compile down to a stack language or something first?
11:41:48 <rwbarton> > dVar 1
11:41:49 <lambdabot>   1~~
11:41:54 <rwbarton> > sin (dVar 1)
11:41:55 <lambdabot>   0.8414709848078965~~
11:42:03 <rwbarton> > df (sin (dVar 1))
11:42:04 <lambdabot>   0.5403023058681398~~
11:42:08 <rwbarton> > cos 1
11:42:08 <lambdabot>   0.5403023058681398
11:42:45 <nand`> deriv f = val . df . f . dVar
11:42:53 <Ralith> t7: you can emit ASM from whatever you can write an ASM emitter for.
11:43:31 <t7> Ralith: is it practicle to emit from an AST that resembles a C program ?
11:43:37 <t7> practical*
11:43:38 <Ralith> yes.
11:43:51 <Ralith> that was a design goal o fC.
11:44:36 <rwbarton> > df (df (sin (dVar 1)))
11:44:37 <lambdabot>   -0.8414709848078965~~
11:45:28 <Sculptor> loads of parentheses there
11:45:43 <nand`> hmm
11:45:56 <nand`> > (deriv . deriv) sin 1
11:45:58 <lambdabot>   -0.8414709848078965
11:46:32 <monochrom> I like parentheses
11:48:53 <badabing> Did you people think about purity/impurity before programming in Haskell? Maybe it is an obvious thing and Im stupid but it got me thinking in ways I hadn't before and I have taken this to other languages. Roughly, pure == easily testable. I have made my Python programs purer to make them more testable. Unforetuneately Python isn't made for purity but performance is not an issue most of the
11:48:53 <badabing> time anyway in ym programs.
11:50:08 <raek> badabing: I did, but I came from Clojure (another functional programming language)
11:50:19 <latro`a> surprisingly, in my experience good style in high level imperative languages is rather pure
11:50:33 <latro`a> in the sense that much of the use of mutable state is with variables that vanish after a function cal
11:50:34 <latro`a> *call
11:50:42 <latro`a> (i.e. local variables)
11:51:50 <monochrom> completely understood interaction == easily testable. pure is just a special case
11:52:02 <nand`> badabing: I've been thinking about it in C#, where there's a clear distinction between a method that mutates the original, and a method that returns a modified copy
11:52:11 <raek> monochrom: interesting.
11:52:59 <monochrom> so for example some OO programs are easily testable too. for example when different objects interact very little and in a known way
11:54:26 <monochrom> we say "global variables are bad" because you keep forgetting how several subroutines interact through the global variables. if you do not forget, there is nothing bad and the suite is still easily testable
11:56:21 <latro`a> the problem is mainly that that "forgetting" effect is inevitable as a program grows
11:56:28 <latro`a> and it inevitably *does* grow, in practice
11:58:03 <nand`> of course one could always come up with strict guidelines and adhere to these while programming, but imo having to manually ensure invariants is a sign of a bad programming style
11:58:48 <monochrom> as an example of the other side of the equivalence:
11:59:35 <monochrom> they say "laziness makes time and space elusive" because they don't completely understand the interaction between subroutines in terms of lazy time and space
12:00:14 <monochrom> I completely understand (up to constant multiples), and so lazy time and space are easily testable, provable, predictable to me
12:00:40 <nand`> isn't ‘time and space’ implementation specific?
12:01:56 <monochrom> yes. but I say "lazy", which contrains implementation to only within a constant multiple
12:02:18 <maukd> that's what you think
12:02:34 <monochrom> "non-strict" is what you're looking for if you want to say you completely know nothing
12:02:58 <maukd> consider malicious implementations
12:04:36 <nand`> I thought laziness referred to sharing, whereas nonstrictness simply referred to, well, nonstrictness
12:04:57 <monochrom> laziness includes both order and sharing
12:05:45 <monochrom> non-strictness refers to how much information is in the answer
12:06:41 * JuanDaugherty thought laziness referred to time of evaluation/execution.
12:07:05 <raek> is non-strictness completely defined by the "f _|_ == _|_" property?
12:07:08 <nand`> ‘execution’ is best avoided in this context, since it usually refers to execution of IO actions
12:07:16 <maukd> raek: yes
12:07:27 <maukd> no
12:07:41 <nand`> if f is not strict in its argument, that does not hold
12:07:56 <nand`> (not necessarily)
12:08:02 <monochrom> strictness is defined by that equation
12:08:08 <jmcantrell> just getting started with haskell. i installed haskell platform using homebrew on mac. i'm getting "The build-tool has reset ENV. --env=std required" when trying to start ghci. anyone know what might be the problem?
12:08:16 <raek> is strictness a property of functions or programming languages?
12:08:35 <monochrom> both
12:08:38 <applicative_> jmcantrell: thats a new one... hm
12:09:07 <applicative_> jmcantrell: it cant be ghc/ghci thats telling you this can it?
12:09:32 <applicative_> wait maybe
12:09:40 <jmcantrell> applicative_: honestly, i'm not sure. i can pastebin the whole output if you want
12:09:47 <monochrom> denotational semantics maps programs to values and/or functions. whatever property you care about for functions, now you can impose them on programs, too
12:09:50 <raek> I guess that if a certain programming language is strict, then that implies that functions in that language can only be strict?
12:10:32 <hpaste> jmcantrell pasted “ghci error” at http://hpaste.org/74489
12:10:33 <nand`> raek: a language could be strict by default with optional laziness, I guess
12:12:03 <startling> lots are
12:12:08 <startling> e.g. python
12:12:14 <startling> fsv of laziness
12:13:07 <atriq> Isn't it possible to use functions of type () -> a to simulate thunks in strict languages?
12:14:01 <maukd> if you have mutable variables, yes
12:14:27 <juliohm> All those libraries we see in HackageDB, which are official part of the Haskell distribution? I'm only interested in libraries under continuous revision by the Haskell core development team.
12:14:45 <juliohm> It's dangerous to include libraries written by anyone in the world. :(
12:15:07 <maukd> there's a "Haskell core development team"?
12:15:33 <monochrom> there is no "the Haskell distribution"
12:15:42 <atriq> The closest thing to what you're saying is the Haskell platform, plus half the things by edwardk and one of Yesod, Snap or Happstack.
12:15:47 <mgsloan> there's just the glorious one ;)
12:16:39 <juliohm> the Haskell platform includes all "official" libraries?
12:16:44 <atriq> Yes
12:16:44 <edwardk> nand`: in my experience such a language is pretty crippled unless its willing to give up stack traces, etc. scala tries to provide that
12:16:45 <atriq> Ish
12:16:47 <maukd> no
12:16:56 <juliohm> I'm looking for the the Haskell standard library, if i can say that
12:17:00 <maukd> you can't
12:17:10 <edwardk> juliohm: not all official libraries, just a common core that you should be able to rely on being anywhere you can install haskell
12:17:11 <nand`> edwardk: F# appears to as well, from what I've seen
12:17:22 <monochrom> I would not say "official". there is no dictator like GvR in the haskell community
12:17:30 <edwardk> nand`: and f# is rather crippled. i note a correlation ;)
12:17:36 <nand`> there is a Haskell standard library though, the Prelude that's defined in the report
12:17:42 <nand`> edwardk: hehe
12:17:51 <juliohm> maukd, what is the closest i can get for an official, maintained by experts,  Haskell library?
12:17:55 <maukd> juliohm: no
12:17:59 <edwardk> juliohm: the haskell platform is pretty much what you can consider standard
12:18:10 <nand`> it is a de facto standard, though
12:18:23 <juliohm> edwardk, there is a list of all packages included in the platform?
12:18:24 <maukd> juliohm: that is not how it works
12:18:30 <monochrom> "well-maintained" is the only thing you can ask for
12:18:31 <juliohm> !haskell-platform
12:18:36 <nand`> in practice most haskell tends to gravitate towards glasgow haskell and the base it provides
12:18:52 <nand`> @where platform
12:18:53 <lambdabot> http://hackage.haskell.org/platform/
12:19:07 <juliohm> maukd, but you agree we need a solid standard library, right?
12:19:28 <maukd> juliohm: no
12:19:31 <juliohm> No one will get a language without a official library to use. At least me.
12:19:31 <nand`> haskell's standard library is the Prelude
12:19:42 <maukd> juliohm: tell that to every language ever
12:19:52 <monochrom> however, "well-maintained" is satisfied by way more packages than just the haskell platform, so your analogies still break down
12:20:08 <nand`> it defines types like Int, Char, Bool and typeclasses like Num that are in common use and should be shared
12:20:19 <Igloo> Nomenclature aside, I'm pretty sure the Haskell Platform is what you want
12:20:33 <edwardk> juliohm: haskell 98/2010 provides the prelude, which is the most basic library that everyone signs up for. On top of that you have the platform, which is a network of packages that are all maintained with a certain level of consistency and released together in a coherent way
12:20:53 <atriq> edwardk, you're missing out a couple of levels there
12:21:08 <juliohm> edwardk, thanks for the clear explanation. :)
12:21:16 <hpaste> applicative annotated “ghci error” with “ghci error (annotation)” at http://hpaste.org/74489#a74490
12:21:23 <applicative_> jmcantrell: hm the next thing thats supposed to happen is this: ^^^
12:21:48 <juliohm> We can say Haskell Platform is much like the Boost libraries in the C++ community?
12:21:55 <edwardk> juliohm: in between those you have 'base' and a few packages that were split off from 'base' at one point, you can view pretty much any of those levels as our 'standard library'. its a system that works pretty well.
12:22:09 <edwardk> juliohm: the platform is closer to the stl.
12:22:17 <juliohm> ok.
12:22:28 <edwardk> juliohm: there are a lot of well regarded libraries beyond the platform that you could consider more boost-like
12:22:54 <mgsloan> Like Control.Lambda!  Oh wait..
12:22:55 <SLi> And is there a way to separate the well-regarded ones from the less-so ones?
12:22:57 <juliohm> edwardk, such as?
12:23:14 <juliohm> SLi, if there is not, then Haskell has a problem
12:23:15 * mgsloan is joking about boost-lambda
12:23:15 <applicative_> jmcantrell: do you have a copy of the gcc installed?   if you do '/usr/bin/gcc' '-m64' '-fno-stack-protector' '-m64' '-L/Library/Frameworks/GHC.framework/Versions/7.4.1-x86_64/usr/lib/ghc-7.4.1/base-4.5.0.0' '--print-file-name' 'libiconv.dylib'
12:23:50 <Igloo> edwardk: "all maintained with a certain level of consistency" has been explicitly declared to not be a goal of the HP: http://www.haskell.org/pipermail/libraries/2010-November/015044.html
12:23:52 <juliohm> Every language should have a collection of well-designed libraries, maintained by a group of Haskell experts who knows everything about the compiler issues
12:23:53 <wabash> Ok, how common is it to use Haskell for machine learning applications?
12:24:03 <applicative_> jmcantrell: then does anything happen? for me it declares /usr/lib/libiconv.dylib
12:24:08 <SLi> I mean, the pythonic "batteries included" model has clear upsides. If I understand hackage correctly, almost anyone can upload almost anything there, and the individual modules are owned by individual people, so there's essentially little review and nothing ensuring compatibility between versions. But might be that I understand wrong :)
12:24:23 <edwardk> Igloo: fair enough
12:24:28 <mgsloan> juliohm: Yes, every language would be far better off if their core libraries were maintained by a group of Haskell experts ;)
12:24:37 <nand`> haha
12:24:55 <edwardk> Igloo: i meant consistency with regards to release timetable and that you can use them together because there is a consistent version, not API style
12:25:06 <juliohm> There is no peer-review in Haskell? o.O
12:25:23 <edwardk> juliohm: relax, its not as bad as that sounds =P
12:25:34 <SLi> Well, hackage seems a lot like CPAN to me.
12:25:47 <edwardk> juliohm: the stuff in the platform typically falls under the libraries mailing list for discussing changes to it, etc.
12:25:48 <monochrom> you can argue your theory of official libraries all decade long. meanwhile, CPAN defies your theory in the same decade. Hackage is pretty close to CPAN.
12:25:48 <juliohm> On the mailing list, there is no "Release is coming, let's review everything".?
12:25:51 <MostAwesomeDude> juliohm: If you're using GHC, you can't really install things without verifying that all the things below them are type-correct.
12:25:52 <applicative_> who needs peer review when we have a typechecker
12:26:08 <Cale> juliohm: Everyone knows when GHC releases are coming
12:26:09 <SLi> The problem is not so much lack of quality as variance of quality together with it not being easy to tell what is good and what is not.
12:26:17 <nand`> applicative_: if only ..
12:26:31 <edwardk> juliohm: ghc does that, many libraries in the platform do that, many individual authors have some process like that
12:26:34 <juliohm> applicative_, type checking doesn't prevent all kinds of bugs.
12:26:58 <nand`> first and foremost, type checking doesn't help when your types are designed poorly
12:27:09 <Cale> There's this thing called Haskell Platform. GHC gets released, then a whole bunch of the most well-used libraries get updated and packaged together with it a little later, and that's what Haskell Platform is.
12:27:11 <nand`> but I guess applicative_ was joking
12:27:13 <MostAwesomeDude> juliohm: It's not a perfect system. Were you thinking of some other large collection of libraries in some other language that *is* entirely peer-reviewed?
12:27:21 <SLi> Type checking is quite strong. But more often that just means that some package in hackage doesn't compile because of some change in some other package.
12:27:22 <applicative_> how do perl people deal with the infinite mass of things  on cpan?
12:27:24 <applicative_> nand`: yes
12:27:26 <MostAwesomeDude> juliohm: (Your questions about C++ and Python in #python haven't gone unnoticed.)
12:27:30 <edwardk> juliohm: applicative_'s comment is somewhat tongue in cheek but there is a somewhat apocryphal maxim that in haskell if it compiles its probably correct. beyond that the linking between libraries is versioned. so you have people checking for consistency fairly locally
12:28:16 <nand`> I think it strongly depends on the domain
12:28:19 <edwardk> juliohm: there are a lot of eyeballs on the code, especially as it gets closer to the core of the ecosystem
12:28:34 <nand`> for example, there are all sorts of functions :: Int -> Int, but presumably most of them don't denote what you actually wanted
12:28:35 <SLi> But generally hackage packages have worked "fairly well" for me.
12:28:44 <nand`> yet they all type check
12:28:45 <Cale> You can't expect a bunch of people who write this code for free in their spare time to ensure that everything works together 100% all the time. People will fix problems when they spot them, but you're one of those people too. :P
12:28:55 <SLi> And if a package compiles, it generally works very well.
12:28:57 <edwardk> nand`: and the more monomorphic my type signatures get the more i check them for consistency ;)
12:29:05 <maukd> applicative_: a search engine, word of mouth, sometimes cpanratings
12:29:17 <juliohm> MostAwesomeDude, nice you're in #python also. :)
12:29:21 <SLi> Hmm, is there something in place to ensure that all the packages in hackage compile?
12:29:27 <nand`> but if you're dealing with stuff like transformations on abstract tree representations, the type checking tells you more and more
12:29:36 <edwardk> maukd: well now that we're getting hackage 2.0, there is a lot more ability to put in those kinds of rating systems, etc.
12:29:48 <maukd> edwardk: are we getting hackage 2.0?
12:29:51 <nand`> hackage 2.0?
12:29:53 <applicative_> maukd: I see, sort of like hackage; we don't have hackage ratings though.  but i'm not sure i like that idea
12:30:01 <MostAwesomeDude> SLi: Hackage runs builds when you upload things.
12:30:03 <edwardk> SLi: the hackage server itself builds them to get you the haddocks =P
12:30:06 <SLi> And what happens when a library A in hackage depends on a certain version of another library B, but then the maintainer of B upgrades it, possibly breaking compatibility?
12:30:17 <Cale> SLi: For many packages, if the documentation builds, then the package is probably okay, but there are a lot of false negatives in that regard, because the hackage servers don't necessarily have all the external dependencies.
12:30:18 <SLi> edwardk, including all packages that depend on the just uploaded one?
12:30:19 <nand`> (you need to give your real identity when uploading to hackage, don't you?)
12:30:26 <edwardk> maukd: check the mailing list. igloo has done a wonderful job herding us in that direction
12:30:52 <juliohm> I really want Haskell because of it's elegance and state of the art techniques, but is not that simple to start using it, i want to make sure everything is consistent and safe.
12:31:04 <maukd> juliohm: hah
12:31:12 <MostAwesomeDude> juliohm: This is programming. :3
12:31:19 <SLi> juliohm, generally I'd say everything is consistent enough to be more consistent than in many other languages :)
12:31:22 <Cale> juliohm: lol, good luck finding a language where everything is consistent and safe between *all* produced code.
12:31:26 <edwardk> SLi: think of it like a layer-cake. i upload a new version that doesn't mean old packages can't work with my old versions. yes there are updates that should force upgrades because we spotted major bugs in logic, etc. but beyond that, the general model is you put out a new version and then when the dependencies update they'll use it
12:31:31 <juliohm> To have a standard collection of libraries is a primary concern.
12:31:42 <nand`> “think of it like a layer-cake” introduction to edwardk's monad tutorial?
12:31:54 <monochrom> so it's just an XY Problem? "I want to get a well-packaged start, so let me ask about official instead?"
12:32:01 <edwardk> my monad tutorial: here are the monad laws. deal with it ;)
12:32:09 <SLi> And then I think you can have a situation isomorphic to the Windows "DLL hell", where two libraries you'd want to use have conflicting version requirements for a third library.
12:32:18 <nand`> edwardk's monad tutorial “consider a lax 2-functor from a terminal bicategory”
12:32:20 <Cale> juliohm: There is a standard collection of libraries, in fact there are two circles of them. There's the stuff which comes with GHC itself, and then there's the Haskell Platform.
12:32:23 <monochrom> the Haskell Platform is precisely "well-packaged start" and precisely not "official"
12:32:52 <juliohm> Cale, i understood, i'm now investigating what comes with each. :)
12:32:57 <applicative_> is vector in the haskell platform now?
12:33:08 <Cale> As little as possible comes from just installing GHC.
12:33:18 <SLi> edwardk, are all the old versions also available indefinitely? I *think* I've run to a case where there has been a dependency on a library package, probably with a version dependency like (>= something), where there was no version of that library that cabal could find that it would compile with.
12:33:23 <edwardk> juliohm: when we get a new major version of ghc, a few months later folks get together and push out a new version of the platform. in the middle there are a bunch of people working on hundreds or thousands of other packages that rey to differing degrees on each
12:33:27 <Cale> (though I actually feel a bit sad about that, GHC used to come with more)
12:33:36 <monochrom> no, vector is not yet in haskell platform, but there are talks of getting it in
12:33:50 <edwardk> SLi: sure. its not perfect. and many old versions while they exist in hackage indefinitely can't build with newer compilers, etc.
12:33:57 <jmcarthur> it's *basically* agreed upon, but there's some bikeshedding about module heirarchies
12:33:59 <edwardk> there is sort of a rolling wave forced on the community by that
12:34:12 <applicative_> monochrom: ah I see, I was thinking of things someone like juliohm might need
12:34:28 <edwardk> monochrom: vector should be going in in this next platform release, there really is no voice against it
12:34:39 <SLi> edwardk, but I guess that could at least be detected by a system that triggers rebuilds of all reverse dependencies... Of course I realize it's probably a question of whether someone is willing to do it :)
12:34:48 <monochrom> that's what I heard too. all "yes" and no "no"
12:34:57 <edwardk> sli: you are welcome to engineer such a system.
12:35:00 <juliohm> thanks applicative_ :)
12:35:14 <edwardk> sli: that wasn't as snarky a reply as it probably sounded
12:35:23 <edwardk> SLi: i would probably use it ;)
12:35:46 <edwardk> SLi: but as for how you deal with downstream stuff, the package versioning policy addresses that
12:36:03 * hackagebot selinux 0.1.1 - SELinux bindings  http://hackage.haskell.org/package/selinux-0.1.1 (LuiteStegeman)
12:36:06 <Cale> Whether it's in the Haskell Platform or not, vector is a pretty solid package.
12:36:10 <edwardk> SLi: there are procedures you should follow when you release a new version based on whether or not you break compatibility in certain ways.
12:36:57 <edwardk> SLi: the versions are x.y.z.  any change like adding instances requires updating x.y, any change that just adds new methods and which could be prophylactically coded against by using qualified or explicit imports can get by with a bump to 'z'.
12:36:58 <SLi> edwardk, yeah, as I said, of course I realize it depends on whether someone is willing to do it ;) I might take a stab at it, but no promises at this moment. I'm familiar with how Debian does its builds, and it's generally a lot more mess than I find people would assume... And basically it's still the same problem set.
12:37:07 * Cale doesn't believe in package versioning policies
12:37:42 <applicative_> Cale, you curmudgeonly old-timer! You want 'import List; import Monad'
12:37:44 * monochrom believes in formal complete specifications and full verification
12:37:49 <Cale> applicative_: :D
12:37:53 <ben> import *;
12:37:53 <edwardk> SLi: if you do something smaller you can bump a number further down the chain. this results in a crapton of false positives mind you. so downstream developers are constantly bumping up the bounds on their dependencies
12:38:16 <edwardk> sli: but it largely addresses the downstream build issues so long as folks actually comply with the pvp or something like it
12:38:27 <nand`> I actually think import List, import Monad would be better than Data.List, Control.Monad - simply because those categories make little sense in my opinion
12:38:40 <benmachine> nand`: agreed
12:38:51 <edwardk> nand`: hackage 2.0 complains at you if you upload something in a non-standard namespace. =(
12:39:00 <Cale> applicative_: which is better?  import FiniteMap  or  import Data.Map (Map); import qualified Data.Map as Map ?
12:39:17 <edwardk> nand`: i'm rather annoyed about that one actually, because i deliberately break some things off into other spaces
12:39:18 <SLi> edwardk, so if I look at, for example, "cabal show hlint", I see these dependencies: base ==4.*, process -any, filepath -any, directory -any, containers -any, transformers >=0.0 && <0.4, hscolour >=1.17 && <1.21, cpphs >=1.11 && <1.15, haskell-src-exts >=1.11 && <1.14, uniplate >=1.5 && <1.7, base -any
12:39:30 <monochrom> merge the two categories Control and Data. have ControlData.List and ControlData.Monad
12:39:32 <benmachine> edwardk: complain about it
12:39:33 <SLi> Would the upper bounds be a result of the hlint maintainer noticing that a recent version breaks things?
12:39:34 <Igloo> edwardk: Hackage 1 does too
12:39:35 <nand`> there's a lot of overlap and lack of distinction between ‘Data’ and ‘Control’, and personally I think it just gets cumbersome to write them out over and over again; I have a hard time imagining them providing useful information or disambiguating
12:39:37 <Cale> monochrom: lol
12:39:38 <ben> import org.haskell.lang.control.monad;
12:39:39 <benmachine> edwardk: I already did
12:40:15 <ben> I like Data.ByteString and Control.Exception
12:40:22 <benmachine> noo
12:40:22 <monochrom> to some extent, some people may like to call the merger Computation. Computation.List, Computation.Monad, Computation.Applicative
12:40:33 <Cale> I like Control.ByteString and Data.Exception
12:40:35 <edwardk> heh, just realizing i can't point to any of the packages i already pushed to hackage that do that =)
12:40:39 <benmachine> ByteString and Exception are perfectly descriptive
12:40:43 <nand`> hierarchical package names are great for when you have sub-modules within a module, like import Lens.Getter, but in general I think distinct packages would be fine on the top level
12:40:52 <nand`> module names*
12:40:58 <ben> bytestring better be descriptive, it's the package name anyway
12:41:17 <nand`> import Stuff.List; import Stuff.Monad
12:41:21 <monochrom> except the "string" part is misleading
12:41:22 <edwardk> apparently all my non-standard namespacing is in private projects
12:41:31 <nand`> monochrom: only if you have misconceptions about what a string is
12:41:34 <ben> (the fact that package names and module names are completely unrelated is kinad offputting too, anything we can do about that?)
12:41:47 <benmachine> I have the notcpp package under NotCPP.*
12:41:48 <Cale> What if we want other structures made of bytes? Maybe we should put it in Data.Byte.String?
12:41:48 <ben> kinda*
12:41:50 <monochrom> I have misconceptions about what a string is
12:41:51 <edwardk> ben: won't happen. it's a huge part of the culture at this point.
12:42:02 <Cale> trololol
12:42:16 <benmachine> Da.Ta
12:42:20 <nand`> a string is a finite sequence of symbols chosen from a certain alphabet
12:42:21 <maukd> Data.Byte.St.Ring
12:42:26 <maukd> Data.Byte.St.orage
12:42:27 <nand`> maukd: hehe
12:42:29 <edwardk> benmachine: Da.Ta.Da.Ta.Da.Ta
12:42:31 <monochrom> oh, KC on haskell-cafe complained bitterly about package names and module names, too
12:42:34 <ben> Cale: Rather Data.String.Byte and Data.String.Multibyte :V
12:42:35 <benmachine> edwardk: quite
12:42:51 <benmachine> I'm not on haskell-cafe
12:43:01 <benmachine> well, I have mail delivery turned off
12:43:06 <benmachine> because otherwise I'd drown in mail
12:43:12 <monochrom> "the module name is A.B, so why is the cabal command not cabal install A.B?"
12:43:20 <nand`> hmm
12:43:26 <maukd> that's just a cabal bug
12:43:29 <Cale> The funny part is that the hierarchical nature of module names is entirely imaginary, and basically consists of the ability to use '.' as a symbol in the name.
12:43:30 <nand`> looking at that definition, arguably String doesn't represent character strings very well :)
12:43:34 <maukd> cabal install should accept module names
12:43:51 <nand`> Cale: it might as well be import ControlByteString
12:43:57 <ben> monochrom: Also "okay I installed this attoparsec-conduit-whatever package you mentioned, why are the names from the tutorial not in scope :argh:"
12:44:16 <benmachine> Cale: yeah, I thought that too
12:44:24 <badabing> can u see me?
12:44:33 <monochrom> no, I can't see u
12:44:34 <Cale> badabing: nope, you're invisible
12:44:37 <badabing> ok
12:44:41 <nand`> monochrom: do you think a reverse module lookup mechanism would be useful for this purpose?
12:44:47 <badabing> weird my internets doesnt work but irc does
12:44:50 <benmachine> sarcasm is so great you guys
12:44:50 <monochrom> or rather, u can't see you
12:45:07 <benmachine> nand`: I think that would be cool!
12:45:19 <monochrom> I don't know
12:45:26 <timthelion> benmachine: I had that just the other day. restarting the router fixed it
12:45:27 <hiptobecubic> badabing, happens to me as well. router's dns server crashed i think
12:45:58 <monochrom> wait, restarting the router fixes sarcasm?
12:46:03 <nand`> (arguably, hayoo/hoogle provide such a mechanism)
12:46:03 <SLi> But I guess the(?) problem with a system like hackage is that it requires the package maintainers to be active in updating their code to work with latest versions of libraries, because otherwise (as I understand it) it will lead to situations where you cannot use two libraries because they have mutually conflicting requirements on some version of a third library. But that's really something you cannot get around. I think it's the major headache with ...
12:46:09 <timthelion> monochrom: :D
12:46:09 <SLi> ... Debian packaging too. But then Debian has a fallback mechanism, called Non-Maintainer Uploads (NMUs) for severe enough ("Release Critical" in Debian terminology) bugs that, for example, prevent a transition to a newer version of some library.
12:46:36 <benmachine> SLi: we have non-maintainer uploads too, they're just not formalised at all
12:46:39 <SLi> benmachine, ok.
12:46:40 <benmachine> the entire thing is a bit ad-hoc
12:46:43 <nand`> SLi: yeah a problem with unmaintained packages is that they depend on (conflicting) old versions of other libraries you have installed
12:46:49 <benmachine> we don't have the staff, is the problem
12:47:04 <hiptobecubic> How do you fix such a problem though? Without ending up with a cesspool like AUR, for example?
12:47:08 <nand`> I don't think there's really any way around it besides either allowing concurrent installations of the same library (useful in some cases) or keeping everything updated
12:47:22 <benmachine> hiptobecubic: it'd be a lot easier if everyone stopped writing so much code :|
12:48:25 * nand` wonders what a system where imports are package/version-aware and multiple versions of the same library can coexist seamlessly would look like
12:48:34 <nand`> or how well it would work
12:48:46 <SLi> Ah, yes, there's a problem even with only conflicting requirements of two different programs. The case with a program A that depends on libraries B and C, where B depends on D (=1.1) and C depends on D (>=1.2), is even more messy.
12:48:54 <benmachine> nand`: the latter is hard
12:49:00 <benmachine> nand`: how do you specify which one you want?
12:49:20 <nand`> benmachine: import Control.Lens >= 2.7  ?
12:49:40 <benmachine> nand`: but you have two copies of Control.Lens 2.7, one depending on x version y, one depending on x version z
12:49:54 <edwardk> SLi: yes. diamond dependencies are hell.
12:49:56 <nand`> I don't see why you would have two copies of Control.Lens 2.7
12:49:58 <benmachine> nand`: oh wait
12:50:01 <benmachine> sorry
12:50:07 <benmachine> I thought you meant multiple installations of the same version
12:50:11 <nand`> oh, no
12:50:15 <benmachine> we already allow multiple versions of the same library
12:50:20 <benmachine> but you can't use them together
12:50:37 <edwardk> benmachine: at least without package imports ;)
12:50:42 <monochrom> import Prelude "base-3.0" as P; import Prelude "fugue-1.0" as Q; now P.Int and Q.Int may be different and un-interchangeable, but at least you have your hands on P.Int and Q.Int
12:50:47 <benmachine> because bytestring-0.9 ByteString is different from bytestring-0.10 ByteString
12:50:55 <nand`> heh, import qualified Control.Lens >= 2.7 as New; import qualified Control.Lens < 2.7 as Old
12:50:58 <benmachine> monochrom: yeah, fair enough
12:51:10 <ben> How likely is ByteString to actually change anyway
12:51:11 <SLi> What Debian does is that it most often uploads separate versions of API-incompatible libraries (the .soname thing, you may have noticed library names like libfoo.so.1; the 1 is the "soname", and every ABI-breaking version is required to bump the soname). If the update breaks only ABI but not API, all reverse dependencies get rebuilt, and there's still a headache in the transition period.
12:51:18 <ben> maybe we should just version symbols individually rather than whole packages
12:51:23 <edwardk> meh. why would anyone want to use a version of Control.Lens before 2.7? =)
12:51:25 <monochrom> btw fugue is a real package, except I don't know its real version numbers :)
12:51:58 <monochrom> of course, if P.Int and Q.Int are different, the usefulness of importing both is diminished
12:52:09 <SLi> But then Debian supports upgrading packages, and cabal apparently does not properly (at least it always warns that upgrades are dangerous? :)
12:52:17 <nand`> I think at best, allowing multiple package versions would allow older packages that are themselves consistent in their dependencies to coexist
12:52:31 <benmachine> SLi: they are getting less dangerous these days
12:52:35 <nand`> but you'd still not be able to solve diamond dependency problems without ultimately keeping everything updated
12:52:49 <juliohm> do you know any resource with lots of Haskell snippets of code?
12:52:55 <benmachine> nand`: you know you can already have multiple package versions, right?
12:53:01 <benmachine> juliohm: github :D
12:53:04 <monochrom> cabal does not "upgrade". why? because "upgrade" includes erasing old stuff, and cabal doesn't erase old stuff
12:53:19 <benmachine> monochrom: maybe it should though
12:53:28 * nand` erases old stuff all the time
12:53:32 <benmachine> yeah
12:53:34 <SLi> nand`, I actually think that having a system that detects obvious (= does not compile) breakage of all reverse dependencies might be quite a good way forward. Knowing what works and what doesn't would possibly make it much easier to tackle the problem.
12:53:51 <ben> cabal should also rebuild all my local projects and one-off scripts to work with the newly upgraded packages, and abort if the build fails
12:53:51 <monochrom> certain upgrades cannot be done by cabal. for example consider container
12:53:59 <nand`> SLi: here's what works - keeping everything updated to the latest version of everything
12:53:59 <juliohm> benmachine, github is too spread, i'm looking for a simple webpage with lots of examples. I know there are some on the Haskell Wiki, but i'm looking for other resources
12:54:15 <nand`> it just requires a nontrivial amount of effort as the number of packages increases
12:54:23 <monochrom> "ghc" (the GHC API) depends on "container". if you upgrade "container", are you going to rebuild "ghc", too?
12:54:24 <SLi> nand, yes, but that assumes active maintainers of all packages, which seems to be a false proposition to me :-)
12:54:26 <hiptobecubic> nand`, that only works if the maintainers update everything
12:54:48 <monochrom> well, you are, but cabal can't do that one, "ghc" is not on hackage
12:55:07 <juliohm> I think i'll reread the Learn Haskell for a great good...
12:56:06 <benmachine> monochrom: cabal has a builtin rule that base can't be installed, but it would be nice to have a configurable list of un-upgradable packages
12:57:33 <monochrom> here is the real reason why replacing C libs is so much easier and replacing GHC libs is so much harder: GHC does cross-lib inlining and optimizations, gcc doesn't
12:58:11 <SLi> Hmm, how does hackage build the packages when uploaded, by the way? I often run into packages that don't build because I don't have some required C headers installed, and I suspect the hackage buildbots cannot have everything installed either?
12:58:53 <Cale> juliohm: You might find this helpful as a quick refresher on main points of the syntax: http://www.cs.utep.edu/cheon/cs3360/pages/haskell-syntax.html
12:58:54 <SLi> Thinking about writing that system that tries to detect API breakage. Can it be somehow done without requiring all C headers of every library.
12:59:48 <Cale> btw, I will believe in package versioning policy as soon as someone writes a machine to implement it
13:00:01 <monochrom> hackage tries to build packages when uploaded, yes.
13:00:12 <juliohm> Cale, nice, bookmarked here.
13:00:31 <SLi> Cale, well, "API incompatible" is generally turing complete, but the part that could be implemented is "typechecks (and compiles)".
13:00:58 <monochrom> but hackage does not have all the world's C libs, either. some packages fail to build just because hackage doesn't have monochrom's-amazing-C-data-structures-lib
13:01:50 <monochrom> anyway hackage pages tell you build success and failure
13:02:04 <SLi> Cale, actually I think another thing that could be done is run quickcheck tests and report errors.
13:03:28 <SLi> But then versioning policies are just necessary for things to work. Dismissing them as something that cannot be enforced seems to me like saying "I believe in criminalizing murder once you can automatically catch every murderer".
13:05:15 <SLi> Hmm. Perhaps there's a way to typecheck code that depends on C libraries without actually requiring the C libraries (or headers) to be present? I guess that might be what hackage does (if compiling is required for getting the docs; I think I've seen docs on hackage for packages that have dependencies on C headers.)
13:06:21 <Cale> SLi: I'd be okay with "monotone strictly increasing"
13:06:30 <Cale> as a package versioning policy
13:06:40 <Cale> because that can obviously be enforced
13:07:06 <autismkills> linux is for homosexuals and lesbian as its so shit and every prosesser blow up trying to run linux, so fuck off and use window as its so much betterlinux is for homosexuals and lesbian as its so shit and every prosesser blow up trying to run linux, so fuck off and use window as its so much betterlinux is for homosexuals and lesbian as its so shit and every prosesser blow up trying to run linux, so fuck off and use window as its s
13:07:08 <autismkills> linux is for homosexuals and lesbian as its so shit and every prosesser blow up trying to run linux, so fuck off and use window as its so much better
13:07:09 <autismkills> linux is for homosexuals and lesbian as its so shit and every prosesser blow up trying to run linux, so fuck off and use window as its so much better
13:07:10 <autismkills> linux is for homosexuals and lesbian as its so shit and every prosesser blow up trying to run linux, so fuck off and use window as its so much better
13:07:10 <SLi> The problem is that following that will cause breakage that can be avoided with a stricter policy.
13:07:22 <Cale> Why, thankyou ircops
13:08:16 <Cale> Well, if I'm importing some package of yours, I consider it my responsibility to check that things still work when I switch which version of your package my code depends on.
13:08:59 <SLi> Cale, hmm, so you would pin the dependency to the exact version available at that point?
13:09:36 <SLi> Ah, or you are not even talking about maintaining your package?
13:09:50 <juliohm> Ok, Cabal is the build system, how do you do testing in Haskell? What's the alternative for generating documentation from code comments?
13:11:30 <SLi> Cale, then what you do if things do not work after you switch to a later version of my package? If that breakage is in some library you already have installed (whose maintainer is possibly MIA)?
13:11:55 <juliohm> The Darcs control system is intended only for people developing Haskell libraries for the website, or should i use it instead of Mercurial, Git, etc?
13:11:58 <SLi> And when a newer version of some other library you install start depending on that later version of my package?
13:12:07 <t7> is http://hackage.haskell.org/package rendering strangly for anyone else?
13:12:11 <t7> (scroll down)
13:12:34 <juliohm> t7, the link is invalid here
13:12:37 <SLi> juliohm, I think it's a VCS among others, but probably more common with Haskell people because it's written by Haskell people and in haskell.
13:13:04 <juliohm> SLi, how do you install others Haskell libraries? By using Cabal only, right?
13:13:05 <SLi> juliohm, I personally use git, but it's more or less a matter of taste and what works for you.
13:13:08 <pixel4> question: on learnyouahaskell.com, it talks about thinking about Int as .. "data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647" .. but this only seems to be sudo-code .. so how would I do this .. "data MyRange = 1 | 2 | … | 50" ?
13:13:45 <SLi> juliohm, yes. Generally. (It's possible also that your Linux distribution would have packaged some haskell libraries, like Debian does, for example. It may be that these wouldn't mix too well with cabal. I don't know.)
13:14:14 <Cale> SLi: Then I either rework my code to deal with it, or switch back.
13:14:26 <juliohm> SLi, perfect. ;-)
13:14:49 <Cale> SLi: and yeah, if I really cared about having my package build and work, I would pin to exact dependencies
13:15:02 <geekosaur> so I've scrolled it abut halfway dwn and it looks fine to me (assuming corrected path), aside from known issue that we really need to stop putting all packages on a single page :)
13:15:34 <Cale> pixel4: You basically wouldn't. It's suggesting that you can *think* of Int like that.
13:15:49 <juliohm> Why do we need the keyword let on GHCI for definitions and not on a script?
13:15:59 <juliohm> `let'
13:16:24 <Cale> pixel4: Integer literals like 5 get desugared to something like  fromInteger (5 :: Integer)
13:16:25 <geekosaur> ghci is kinda the inside of a "do" block, not really a top level
13:16:29 <pixel4> Cale: yeah I got that, but what if I wanted my own number type with it's own subrange of int
13:16:40 <geekosaur> it's starting tp get some top-level-like stuff added but that is all very recent
13:16:52 <SLi> Cale, well, then I hope it's not a library package that other people would use, because generally any two library packages depending on our packages would be incompatible ;)
13:17:02 <Cale> pixel4: and so by declaring an instance of Num for your datatype and implementing fromInteger, you can have integer literals interpreted as values of your own datatype
13:17:20 <SLi> Cale, and probably mutually uninstallable.
13:17:27 <maukd> pixel4: you don't (and it's "pseudo")
13:17:37 <juliohm> geekosaur, thanks, but i didn't understood how this makes difference, to be inside a "do" construct.
13:18:29 <Cale> SLi: well, they should be mutually installable
13:18:37 <Cale> SLi: but possibly incompatible
13:19:01 <mgccl> What is so hard about implementing data parallel haskell? It seems to me algorithmic wise is a simple thing, transform a tree to a list
13:19:20 <Cale> mgccl: there's a talk about the difficulties
13:19:25 <Cale> mgccl: Let me find the video
13:19:33 <t7> a couple of good ones by SPJ about this
13:20:47 <SLi> Cale, it's not going to be a very good user experience for newcoming haskellers if they cannot use a smtp library and a (say) database library in a single project, because they depend on incompatible versions of other packages...
13:21:01 <Cale> There was a good technical one by Manuel Chakravarty
13:21:10 <daniel_-> if one of my executables in a cabal projects needs to be imported by another executable in the same cabal project how can i still have module ExeName instead of module Main, since i cant do cabal build without module Main and it cant import without module ExeName
13:21:39 <mgccl> Cale: awesome, thanks~ I assume it's this one http://vimeo.com/28477220
13:21:45 <mgccl> Cale: I shall go and watch
13:22:01 <SLi> daniel, no idea about exactly that, but perhaps you could split the code you need to import to another module and make module Main very simple?
13:22:33 <Cale> mgccl: I'm not sure that's the exact one I'm thinking of, but it looks like it has some of the same slides
13:24:10 <Cale> mgccl: Basically the difficulty comes from needing lifted versions of everything, including complex datatypes.
13:24:44 <boboy77b> http://bitchinbeach.com/Forum/index.php?tid=30&title=The_Best_TEEN_Porn_Movie_Collection
13:25:00 <Cale> Wow, the spammers are out in full force today.
13:25:11 <geekosaur> fast service from the spotters too, I see
13:25:50 <Cale> SLi: That's true. It's too bad that it would be super-inconvenient for the package system to be more fine-grained.
13:26:41 <Cale> SLi: If you put things like datatypes into separate packages, their version numbers would likely tick more slowly than the algorithms which depend on them.
13:27:18 <ddarius> There is a main-is field.
13:27:39 <daniel_-> ddarius, still doesnt help if you set module to anything else than Main
13:29:31 <Cale> mgccl: Oh, I'm sorry, I think I'm thinking of the talk by Roman Leshchinskiy
13:30:04 <Cale> http://vimeo.com/6574677
13:30:05 <geekosaur> daniel_-, the problem with what you want to do, as I understand it, is that cross-module inlining and such make it difficult to "share" a module the way you want to
13:30:14 <Sculptor> doesn't someone have a list of urls to all public domain haskell videos
13:30:20 <Sculptor> does*
13:30:26 <geekosaur> which is why the recommendation is to split out the shared part into its own module and import it into your main
13:30:35 <geekosaur> so it can be shared properly
13:30:40 <daniel_-> ye
13:32:00 <Cale> mgccl: yes, that's definitely the talk I'm thinking of now
13:32:01 <Cale> :)
13:32:56 <mgccl> Cale: thanks!
13:34:17 <maukd> re: http://mauke.hopto.org/tmp/brillig.html - is there some trick to proving language classifications equal/unequal?
13:34:37 <maukd> e.g. I have no idea where to even start if I wanted to show that brillig /= regular
13:34:58 <DrTeggy> This channel should be empty these days because everybody is at ICFP.  ;-)
13:35:32 * rtharper is not at ICFP
13:35:53 * DrTeggy is.
13:36:05 <t7> maukd: prove a term in regular is impossible in brillig ?
13:36:08 <zzing> When GHC spits out  login :: forall sub master. GWidget sub master ()    can I just use login :: GWidget sub master ()   in real code?
13:36:23 <geekosaur> yes
13:37:10 <maukd> t7: what's a term?
13:37:24 <t7> no i have no idea, just wanted to sound celver
13:38:06 <Cale> zzing: yes
13:38:10 <timthelion> t7++
13:38:21 <Cale> zzing: If foralls are left out, they're implicitly added right after the ::
13:38:31 <Cale> (i.e. at the top level of the type signature)
13:38:37 <cjay> will there be videos of the icfp talks?
13:39:00 <zzing> Are there any conferences near detroit or windsor on haskell?
13:39:10 <zzing> I would so love to go to one but can't go far :P
13:39:24 <Cale> maukd: why are you interested in brillig languages?
13:39:48 <Eduard_Munteanu> Is that an invented term?
13:39:54 <maukd> Eduard_Munteanu: yes
13:40:08 <Cale> Twas brillig and the slithy toves?
13:40:17 <maukd> Cale: because "brillig" is my attempt to mathematize what you get when you implement regexes without backtracking
13:40:51 <zzing> mathematize? That sounds like WordStar 6, now *componentized*
13:40:56 <Cale> maukd: Yeah, I was about to say this looks a lot like what happens when you have a left-biased disjunction
13:41:06 <Eduard_Munteanu> Formalize, then. :)
13:41:17 <zzing> Now Formalize, I like that word
13:41:31 <maukd> I could formalize it in Perl: just add (?> ... ) around every subterm
13:41:37 <maukd> but that's not useful for proving things
13:43:14 <eyebloom> I have kind of a complex question if anyone is interested in talking about it.
13:44:19 <t7> eyebloom: ask away sir
13:44:20 <Eduard_Munteanu> eyebloom: we're interested in actual questions, rather than hypothetical ones. Just go ahead and ask :)
13:44:27 <maukd> Cale: anyway, this seems like an interesting alternative to regular expressions, but I want to know what exactly I'm going to lose (or win?) by switching
13:44:32 <Cale> maukd: though, just to check, you do know there's a way to implement regular expressions without backtracking ;)
13:44:39 <hnsz> eyebloom: Is it about politics? :p
13:44:45 <maukd> Cale: yes, the smart way :-)
13:44:53 <Cale> okay, good :)
13:45:27 <Cale> maukd: There may indeed be a way to rewrite any regular language into this form...
13:45:45 <hnsz> what is meant by regular languages?
13:45:51 <eyebloom> I'm writing an evaluator for a lambda calculus variant that basically just allows a global structure to pass along the reduction...
13:45:58 <hnsz> natural language?
13:46:04 <maukd> hnsz: I bet that's on wikipedia
13:46:12 <Cale> hnsz: I could give a few definitions. Not natural languages, they're certain sets of strings.
13:46:20 <maukd> Cale: whoa. that would surprise me
13:46:56 <Soultaker> just, any language that can be parsed with a finite state machine, right?
13:47:15 <eyebloom> There are extensions that can access that structure and change it according to rules that make the changes work fine regardless of reduction order.
13:48:11 <eyebloom> This is really useful but I'm thinking the Haskell type system can't handle what I'm trying to do.
13:48:22 <DrTeggy> cjay, yes, I think so.  The core conference only starts tomorrow.  Some workshop talks have been video-taped already.
13:49:19 <Cale> Soultaker: that's one definition, yeah
13:49:29 <Cale> The super-fancy definition: A language L on the alphabet A is regular if there is a finite monoid M, a subset M' of M and a monoid homomorphism f: A* -> M such that L is the preimage of M' under f. i.e. L = { x in A* : f(x) in M' }
13:49:45 <eyebloom> For example the type of the evaluator can be stated like: data Lg x a = x->(x, a)
13:49:51 <cjay> DrTeggy: awesome, any idea where they will be hosted? I could only find some videos of icfp 2009, nothing from 2011.
13:50:22 <Cale> Then there's the definition via regular expressions.
13:50:33 <DrTeggy> cjay, I cannot tell, sorry.
13:50:44 <eyebloom> Where x is the global structure type and a is the lambda expression type.
13:50:57 <cjay> ok
13:50:59 <maukd> if you take my "brillig" definition and use normal set union/concatenation operations instead, you should get regular languages as well
13:51:55 <Cale> eyebloom: So you're basically talking about a restricted state monad, where the operations on the state are limited to ones which would make it a commutative monad?
13:52:39 <eyebloom> But if the type a is in fact a function type like b->c. Then the evaluator type must be x->b->(x, c).
13:53:21 <Expez> I've noticed a few projects put each type into it's own file. Leaving some files with only a few lines. Is this considered good practice?
13:53:54 <eyebloom> There is no way to construct a type that can handle both and also garauntee that x is passed along the whole evaluation.
13:54:57 <eyebloom> Cale: I think its a similar case except that the type of the expression being passed along the monad is changing.
13:55:57 <Cale> eyebloom: okay, so the indexed state monad instead :)
13:56:09 <LadyAurora> > monad
13:56:10 <lambdabot>   Not in scope: `monad'
13:56:19 <LadyAurora> Oh yeah, the only word I understand.
13:57:46 <Cale> eyebloom: however, that does make things a little interesting -- you could only hope to commute operations past one another if the types lined up properlu
13:57:48 <Cale> y*
13:58:58 <eyebloom> I think the issue I'm having is not how to construct it as a monad but how to deal with the fact that the number of arguments changes at different points in the expression.
13:59:09 <ion> “<Cale> http://vimeo.com/6574677” Interesting, downloading the video.
13:59:42 <Cale> i.e. do u <- x; v <- y; return (u,v) and  do v <- y; u <- x; return (u,v)  only both make sense when the state type isn't changed by x or y
14:02:22 <Cale> eyebloom: what exactly do you mean about the number of arguments changing?
14:02:28 <Cale> I'm not 100% clear on that
14:04:20 <eyebloom> some expressions are: x->a->(x,b) and some are x->(x,a)
14:04:53 <eyebloom> depending on the underlying subexpression.
14:04:58 <Cale> hmm
14:05:35 <Cale> Well, that's either  a -> State x b, or  State x a
14:05:53 <eyebloom> Since I don't know if the subexpression contains an extension that modifies the state.
14:06:21 <eyebloom> I have to handle both with the same type.
14:06:58 <Cale> okay, so can the 'a' type in the first case be considered an (optional) part of the state?
14:07:14 <Cale> State (x,Maybe a) b
14:08:11 <eyebloom> I see, I was trying to avoid something like that.
14:08:16 <Cale> eyebloom: Well...
14:08:42 <Cale> Either you want to check things at runtime, or you want to check them at compile time.
14:08:46 <Cale> You can't have it both ways :)
14:09:24 <eyebloom> I agree, but I think compile time is preferable with embedded languages.
14:10:38 <eyebloom> I was hoping I wouldn't run into this but I guess I have a dependent type situation.
14:10:50 <dzhus> Is this correct that if you build a chain of monads using transformers, you can have IO only as the bottom-most monad?
14:11:05 * hackagebot gutenberg-fibonaccis 1.1.0 - The first 1001 Fibonacci numbers, retrieved from the Gutenberg Project.  http://hackage.haskell.org/package/gutenberg-fibonaccis-1.1.0 (JustinHanekom)
14:11:26 <ion> Wow, another update.
14:11:32 <jmcarthur> dzhus: there is no IO transformer that i know of, yes
14:12:06 <ddarius> ion: It's hard to keep up with the changes in mathematical truths.
14:14:40 <dzhus> the joy of posting to hackage.
14:14:46 <dzhus> ah
14:14:56 <kanedank> how do I do something like [] op [1,2] == [[1,2]] and [[1,2]] op [2,3] == [[1,2],[2,3]]?
14:16:06 <Cale> eyebloom: Well, I don't really have enough details about your situation to be able to suggest anything more refined than that.
14:16:57 <maukd> > let op x y = x ++ [y] in [] `op` [1,2]
14:16:58 <lambdabot>   [[1,2]]
14:17:10 <maukd> > let op x y = x ++ [y] in [[1,2]] `op` [2,3]
14:17:12 <lambdabot>   [[1,2],[2,3]]
14:17:49 <Cale> kanedank: Note that adding repeatedly to the end of a list like that is generally a source of quadratic time behaviour, and you may want to avoid it.
14:19:43 <Sculptor> does reversing a list actually reverses its internal structure, or just sets a flag
14:19:46 <Cale> (this is because xs ++ ys takes O(length xs) steps to fully evaluate, and xs will tend to grow)
14:19:53 <Cale> Sculptor: it rebuilds the list
14:20:01 <Sculptor> not efficient
14:20:07 <Cale> Sculptor: and indeed, it may take forever
14:20:14 <Cale> > reverse [1..]
14:20:23 <lambdabot>   mueval: ExitFailure 1
14:20:23 <lambdabot>  mueval: Prelude.undefined
14:20:45 <Nereid> > reverse [1..100000]
14:20:49 <lambdabot>   [100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,9...
14:20:52 <Nereid> > reverse [1..10000000]
14:21:00 <lambdabot>   mueval: ExitFailure 1
14:21:00 <lambdabot>  mueval: Prelude.undefined
14:21:04 <Nereid> > reverse [1..1000000]
14:21:09 <lambdabot>   [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,999...
14:21:30 <Nereid> Sculptor: reverse is still smart enough that it can do it in linear time
14:21:43 <Cale> Sculptor: reverse is as efficient as it possibly can be, given what it does
14:21:55 <Nereid> well,
14:22:05 <centrinia> > reverse . reverse $ [1..2^20]
14:22:09 <lambdabot>   mueval-core: Time limit exceeded
14:22:12 <Sculptor> adding a new head rebuilds a list, but actually uses previous data structure under the hood, amirite
14:22:17 <centrinia> > reverse . reverse $ [1..2^10]
14:22:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:22:30 <Nereid> 2^10 is only 1024
14:22:39 <Cale> Sculptor: It refers to the old list, provided that you name the old list as the tail
14:22:57 <Cale> Sculptor: i.e. if your new list is (x:xs), then that will have a pointer to the list xs in it.
14:23:10 <Sculptor> nice, tx
14:23:18 <centrinia> @let doubleReverse = reverse . reverse
14:23:19 <Nereid> > let slowReverse [] = []; slowReverse (x:xs) = slowReverse xs ++ [x] in slowReverse [1..1000000]
14:23:20 <lambdabot>  Defined.
14:23:22 <lambdabot>   *Exception: stack overflow
14:23:30 <Nereid> heh, not even slow.
14:23:33 <maukd> Sculptor: it doesn't really "rebuild"
14:23:33 <Nereid> just bad.
14:23:43 <Sculptor> k
14:23:48 <maukd> there is no hidden structure
14:23:48 <Nereid> @ let reverse' [] = []; reverse' (x:xs) = reverse' xs ++ [x]
14:23:51 <Nereid> @let reverse' [] = []; reverse' (x:xs) = reverse' xs ++ [x]
14:23:51 <maukd> @src []
14:23:52 <lambdabot>  Defined.
14:23:52 <lambdabot> data [] a = [] | a : [a]
14:23:55 <Sculptor> figured as much
14:23:59 <Nereid> > reverse' [1..10000]
14:23:59 <maukd> ^ this is what "lists" actually are
14:24:01 <lambdabot>   [10000,9999,9998,9997,9996,9995,9994,9993,9992,9991,9990,9989,9988,9987,998...
14:24:04 <Nereid> > reverse' [1..100000]
14:24:07 <lambdabot>   mueval-core: Time limit exceeded
14:24:10 <Nereid> yeah.
14:24:20 <centrinia> > map ($[1..1024]) (iterate (\f -> f . f) doubleReverse)
14:24:26 <lambdabot>   mueval: ExitFailure 1
14:24:26 <lambdabot>  mueval: Prelude.undefined
14:24:40 <mgccl> I was thinking of implementing something like topcoder for Haskell. and I thought about if there is no IO, no matter what code the other person submit should be safe. because one can just type check the function, right?
14:24:45 <Cale> > let reverse xs = rev xs []; rev [] = id; rev (x:xs) = rev xs . (x:) in reverse [1..1000000]
14:24:45 <centrinia> Huh?
14:24:51 <lambdabot>   mueval-core: Time limit exceeded
14:24:54 <Nereid> mgccl: what about unsafePerformIO and friends?
14:24:56 <Cale> > let reverse xs = rev xs []; rev [] = id; rev (x:xs) = rev xs . (x:) in reverse [1..100000]
14:24:58 <lambdabot>   [100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,9...
14:24:59 <parcs`> > let reverse' = reverse in let reverse xs = go xs (reverse xs); go [] _ = []; go (_:xs) ~(y:ys) = y : go xs ys in reverse (reverse [1..2^20])
14:25:04 <lambdabot>   mueval: ExitFailure 1
14:25:04 <lambdabot>  mueval: Prelude.undefined
14:25:05 <centrinia> :t map ($ [1..1024]) (iterate (\f -> f . f) doubleReverse)
14:25:08 <lambdabot> forall t. (Num t, Enum t) => [[t]]
14:25:19 <Nereid> mgccl: lambdabot does a lot of things to make sure people can't do funny things with it.
14:25:21 <maukd> mgccl: Template Haskell
14:25:32 <maukd> mgccl: DoS via type checker
14:26:08 <Cale> mgccl: of course, you don't want to allow them to import unsafePerformIO
14:26:38 <ddarius> Who needs unsafePerformIO when you have unsafeCoerce?
14:26:50 <Cale> indeed, that too :)
14:26:58 <Nereid> hence "and friends"
14:27:07 <kanedank> can someone help me figure out what is wrong with my let statement here?: http://hpaste.org/74493
14:27:13 <int-e> ddarius: Heh. But it's much harder to write unsafe, non-crashing code using unsafeCoerce, in my experience.
14:27:17 <Cale> actually, there's something interesting I've never seen: write unsafePerformIO using unsafeCoerce. Should be doable, I think.
14:27:34 <Nereid> kanedank: you need an "in" somewhere
14:27:41 <Cale> (but would rely on the details of GHC's implementation of IO)
14:28:07 <Nereid> kanedank: let ... = ... in ...
14:28:20 <ddarius> If you have runST, you could just unsafeCoerce to ST.
14:28:37 <Cale> ah, but that's too cheap :)
14:28:39 <kanedank> Nereid: thanks!
14:28:56 <maukd> mgccl: oh, I completely forgot about the FFI
14:28:57 <mgccl> Are they easy ways to make sure the function does only pure thing?
14:29:02 <maukd> if you have that, you can run arbitrary machine code
14:29:14 <ddarius> @hackage harpy
14:29:15 <lambdabot> http://hackage.haskell.org/package/harpy
14:29:19 <maukd> also, http://hackage.haskell.org/packages/archive/reflection/1.1.6/doc/html/Data-Reflection.html is the best module
14:29:22 <Nereid> @hackage mueval
14:29:22 <lambdabot> http://hackage.haskell.org/package/mueval
14:29:26 <Nereid> mgccl: ^
14:30:34 <int-e> Cale: tricky, because of the special handling of IO's state token in ghc - the actual argument is erased at runtime.
14:30:55 <mgccl> Nereid: nice!
14:31:19 <int-e> I phrased that badly. It's erased at compile time and does not exist at runtime.
14:31:28 <int-e> A true phantom value :)
14:32:10 <Cale> ghci> (unsafeCoerce (putStrLn "hello") :: Int -> Int) 0 `seq` ()
14:32:10 <Cale> hello
14:32:10 <Cale> Segmentation fault
14:32:24 <Nereid> lol
14:32:28 <int-e> Cale: yeah, that's as far as I got :)
14:33:46 <Cale> (obviously the `seq` () isn't required, it was left over from a previous attempt)
14:34:45 <kanedank> um, I've been trying to use haskell with emacs and I tried following a tutorial on setting up flymake/hslint, but now my haskell files look weird because there are yellow lines everywhere: http://i.imgur.com/RV9Jz.png
14:35:28 <ion> IO actions are functions after all? ;-)
14:35:41 <Cale> ion: In the implementation, sorta
14:35:56 <maukd> unsafeCoerce 42 :: Int -> Int
14:36:00 <maukd> numbers are functions!
14:36:08 <ddarius> :t 42 :: Int -> Int
14:36:10 <lambdabot> Int -> Int
14:36:18 <Nereid> > 42 "hello"
14:36:19 <lambdabot>   42
14:36:41 <Cale> > 23 "skidoo"
14:36:42 <lambdabot>   23
14:37:07 <ion> λ> (unsafeCoerce 42 :: Int -> Int) 0
14:37:09 <ion> 8646911284551352320
14:37:41 <shachaf> Cale: Don't you think that should be taken out of lambdabot?
14:37:49 <shachaf> It only confuses beginners.
14:37:51 <Cale> shachaf: What should?
14:37:55 <shachaf> Num (b -> a)
14:38:02 <int-e> Prelude GHC.Exts Unsafe.Coerce> case (unsafeCoerce (putStrLn "Hello") :: State# RealWorld -> State# RealWorld) realWorld# of _ -> ()  -- but now unsafeCoerce is relegated to a newtype deconstructor
14:38:03 <Cale> meh, I kinda like it
14:38:14 <parcs`> it only confuses beginners for as long as it takes for somebody to point out the Num (b -> a) instance
14:38:16 <Nereid> it's Caleskell.
14:38:29 <maukd> it's NumInstances
14:38:31 <shachaf> parcs`: If they know what Num (b -> a) means, they're probably not all that beginners.
14:38:32 <Cale> Confusing beginners is good, so long as you do it in a way which leads to their enlightenment :)
14:38:49 <shachaf> You don't think regular Haskell is confusing enough?
14:39:01 <Cale> They have regular Haskell in GHCi :)
14:39:18 <shachaf> lambdabot's main purpose is to help explain things, isn't it?
14:39:39 <Eduard_Munteanu> (.) is needlessly confusing as well.
14:39:39 <Cale> lambdabot is always going to be importing tons of stuff, so it's not likely to be quite like a fresh ghci session
14:39:44 <Eduard_Munteanu> :t (.)
14:39:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:39:52 <shachaf> Yes, it is.
14:40:03 <Nereid> :t (.) . (.)
14:40:03 <Cale> If you're explaining something, you can always sidestep the generalised things in lambdabot :)
14:40:04 <shachaf> (.) = fmap does no one any good in lambdabot.
14:40:04 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:40:11 <shachaf> Cale: No you can't.
14:40:13 <Nereid> :t flip
14:40:14 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:40:18 <sipa> > (+5) . [1,2,3]
14:40:20 <lambdabot>   [6,7,8]
14:40:24 <Playground> wat
14:40:31 <shachaf> Cale: Even if you don't do it, some other person in #haskell will.
14:40:37 <sipa> > (+5) . 5
14:40:38 <lambdabot>   No instance for (GHC.Num.Num (f a))
14:40:38 <lambdabot>    arising from a use of `e_155' at <in...
14:40:42 <Cale> shachaf: hm?
14:40:44 <parcs`> back when i was a beginner i found the generalized (.) and Num (b -> a) instance and all the other stuff to be somewhat confusing but mostly interesting and neat
14:40:45 <int-e> Cale: Ah, this seems to do the trick: (unsafeCoerce (putStrLn "Hello, world!" >> unsafeCoerce (const ())) :: () -> ()) ()
14:40:50 <maukd> > ((+5) . 5) 2
14:40:52 <lambdabot>   10
14:40:55 <Yuu-chan> @unpl (flip (>>=) .) . ((filter .) . (flip . (((==) .) . flip mod)))
14:40:56 <lambdabot> (\ o aa c -> c >>= filter (\ h -> (mod h o) == aa))
14:41:03 <Cale> int-e: lovely!
14:41:31 <Eduard_Munteanu> Although one can often do stuff like...
14:41:36 <Eduard_Munteanu> :t (Prelude..)
14:41:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:41:44 <Nereid> int-e: now how do we get values out of IO?
14:43:07 <int-e> Nereid: first let me test whether it works when compiled, too
14:43:17 <int-e> which it does :)
14:43:18 <Eduard_Munteanu> @let (.) = (Prelude..)
14:43:18 <lambdabot>  <local>:12:0:
14:43:19 <lambdabot>      Multiple declarations of `L..'
14:43:19 <lambdabot>      Declared at: .L.hs:89...
14:43:22 <Eduard_Munteanu> Dang.
14:44:11 <Cale> (unsafeCoerce (getLine >>= \v -> unsafeCoerce (const v)) :: () -> String) ()
14:44:33 <Nereid> nice.
14:45:15 <ion> cale: Segfault
14:45:21 <Cale> not for me!
14:45:24 <Nereid> lol
14:45:25 <ParahSailin_> :t unsafeCoerce
14:45:26 <lambdabot> Not in scope: `unsafeCoerce'
14:45:31 <Nereid> unsafeCoerce :: a -> b
14:45:35 <ion> λ> (unsafeCoerce (do a <- getLine; unsafeCoerce (const a)) :: () -> String) ()
14:45:37 <ion> "[1]    32106 segmentation fault (core dumped)  ghci
14:45:43 <Cale> ion: Which version of GHC?
14:46:01 <ion> 7.4.1 (oh, it seems i forgot to upgrade to 7.4.2.)
14:46:11 <Nereid> yes, 7.4.1 crashes, works in 7.6.1
14:46:13 <Cale> I'm on 7.4.1 as well
14:46:17 <Nereid> win32 here
14:46:18 <Cale> and it works
14:46:23 <Cale> (on Linux)
14:46:31 <Cale> (32 bit)
14:46:36 <ion> 64
14:46:52 <Sweden_jack> is there a way of interleaving two strings? interleave [1,3..] [2,4..] ⇒ [1..]?
14:46:56 <Sweden_jack> *two lists
14:47:08 <ion> concat .: zipWith (\a b -> [a,b])
14:47:09 <Nereid> waiting for my laptop SSD to arrive so I can stick linux on it. :P
14:47:20 <int-e> Yeah, ended up with the same ...  unsafePerformIO a = unsafeCoerce (a >>= unsafeCoerce . const) ()
14:47:44 <ziman> will that work for unequally sized lists?
14:48:01 <Nereid> ziman: it'll just stop after the end of one of the lists.
14:48:03 <hiptobecubic> Nereid, best decision ever. No regrets here.
14:48:03 <ion> Depends on how you define “work”.
14:48:12 <Cale> Sweden_jack: It's not in the library, but I've often ended up defining  [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs)
14:48:15 <ziman> true.
14:48:31 <Nereid> > (concat .: zipWith (\a b -> [a,b])) [1,3,5] [2,4,6,8,10]
14:48:32 <lambdabot>   [1,2,3,4,5,6]
14:48:38 <latro`a> isn't that unsafePerformIO actually even less safe?
14:48:41 <latro`a> because it's m a -> t
14:48:47 <latro`a> when I :t
14:49:05 <int-e> but it fails on i386 :)
14:49:10 <parcs`> > concat (transpose [[1,3..],[2,4..]])
14:49:11 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:49:12 <Cale> > (\xs ys -> transpose [xs,ys]) [1,3,5] [2,4,6,8,10]
14:49:13 <lambdabot>   [[1,2],[3,4],[5,6],[8],[10]]
14:49:22 <hiptobecubic> :t (.:)
14:49:23 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
14:49:24 <Cale> > (\xs ys -> concat (transpose [xs,ys])) [1,3,5] [2,4,6,8,10]
14:49:26 <lambdabot>   [1,2,3,4,5,6,8,10]
14:49:30 <Nereid> is there any sort of syntax where we can write, say, [_,_] to mean \a b -> [a,b]?
14:49:38 <Sweden_jack> Cale: I might use that, I'd rather not use (.:)
14:49:41 <t7> is there a static analysis tool for C that checks pre/post conditions for functions?
14:50:13 <Nereid> because that would be awesome.
14:50:24 <hiptobecubic> @src (.:)
14:50:24 <lambdabot> Source not found. Maybe you made a typo?
14:50:34 <Nereid> @type (.:)
14:50:35 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
14:50:38 <Nereid> heh.
14:50:46 <t7> @pl \x y -> x : y : []
14:50:46 <lambdabot> (. return) . (:)
14:50:47 <Cale> Nereid: that's been suggested many times, but figuring out what it means in general is really hard, and makes you realise why we have lambda
14:50:48 <Nereid> (.:) = (.) . (.)
14:51:00 <Cale> (the _ parameters thing)
14:51:10 <Nereid> Cale: what's hard about it? you have one argument for each _, and they are inserted in order.
14:51:30 <Nereid> it's obviously less general than lambda, but still.
14:51:42 <maukd> Nereid: where does the expression end?
14:51:55 <Nereid> good questionl
14:51:57 <t7> where the fat lady sings
14:51:57 <Nereid> .
14:52:07 <hiptobecubic> compose two compositions?
14:52:24 <ion> nereid: What does (_, \x -> (x, _)) do?
14:52:36 <Nereid> indeed.
14:53:04 <benmachine> why doesn't [_,_] mean [\a -> a, \b -> b]
14:53:34 <t7> \a -> a   ===  a
14:53:37 <t7> in type language
14:53:40 <Eduard_Munteanu> t7: I think I've seen something like that, but I don't quite remember where
14:53:42 <t7> err the other way round
14:53:44 <ion> I suppose you’d need some kind of brackets to explicitly say where the lambda goes.
14:53:50 <benmachine> t7: wat
14:53:53 <Nereid> ion: yeah, I was thinking that.
14:54:06 <Nereid> but then it's not as tidy.
14:54:13 <t7> :t f x = x :: forall a. a
14:54:14 <Nereid> but what can you do.
14:54:14 <ion> ◀ [_,_] ▶ 5 6
14:54:14 <lambdabot> parse error on input `='
14:54:15 <benmachine> ion: hey, maybe you could use the \ symbol to denote the beginning
14:54:20 <t7> :t \x = x :: forall a. a
14:54:21 <lambdabot> parse error on input `='
14:54:23 <Nereid> haha, what are those
14:54:28 <t7> :t \x -> x :: forall a. a
14:54:29 <lambdabot>     Inferred type is less polymorphic than expected
14:54:29 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
14:54:29 <lambdabot>         x :: a (bound at <interactive>:1:1)
14:54:43 <Nereid> t7: \x -> x = id
14:54:43 <t7> erm the other way?
14:55:18 <mgccl> This might not be a Haskell question, but doesn't the OS stop programs from doing things it doesn't have permission to do? so maybe things can be made safe in the OS level.
14:55:20 <t7> :t let x = x in x :: forall a. a -> a -- does this work?
14:55:21 <lambdabot> forall a. a -> a
14:55:41 <Nereid> mgccl: os permissions are rather coarse.
14:55:58 <Nereid> t7: also, forall a. a
14:56:14 <ion> nereid: Depends on the OS and the security module kind of stuff running in the OS.
14:56:15 <Nereid> :t let x = x in x
14:56:16 <lambdabot> forall t. t
14:56:39 <Nereid> ion: the OS can't make a program not crash, for instance.
14:56:40 <t7> benmachine: my point is: it does
14:57:13 <Nereid> although if it could, that would be very cool.
14:57:20 <Nereid> but then what would happen
14:57:58 <ion> A debug interface where you can roll the universe back into an earlier state, upgrade the code and resume.
14:58:39 <t7> Eduard_Munteanu: any hints on what i should google for?
14:59:15 <Eduard_Munteanu> LOL
14:59:25 <zzing> Is there a simpler way of specifying this?    login :: (master ~ App, YesodAuth App) => Maybe (AuthId App) -> GWidget sub master ()
14:59:40 <Eduard_Munteanu> I wanted to search for "bitc hoare logic", but Google corrected it to "bitch hoare logic".
15:00:04 <Ke> I would have expected bitcoin
15:00:04 <zzing> Eduard_Munteanu, I am surprised it isn't correct hoare too
15:00:26 <zzing> oh, and congrats that might be in your search history now :P
15:02:10 <ddarius> zzing: Just apply the equality constraint by substituting App for master.
15:04:57 <zzing> ddarius, would that mean that I would still need YesodAuth ...?
15:07:17 <Eduard_Munteanu> t7: hrm, it was related to either bitc or proof-carrying code, you might want to search for those terms
15:07:24 * Eduard_Munteanu can't remember right now
15:07:46 <ddarius> zzing: No, you shouldn't need it.
15:08:10 <zzing> ddarius, where would 'master' come from in this case? (the typeclass?0
15:08:31 <ddarius> zzing: The equality constraint says master is App.  So just replace master with App.
15:08:38 <Eduard_Munteanu> t7: but I'm unsure there's an actual tool you can use with normal C code
15:08:51 <t7> i dont mind annotating :|
15:15:19 <juliohm> I forgot the difference in using guards or case/of, could you please clarify?
15:16:02 <juliohm> f x = | cond1 = res1 | cond2 = res2 | otherwise resn
15:16:21 <juliohm> oh
15:16:26 <juliohm> i now understand
15:16:26 <Twey> s/x =/x/
15:16:37 <Twey> It's mostly a syntactic difference
15:16:43 <MostAwesomeDude> f x | guard = stuff
15:16:54 <juliohm> yes
15:17:03 <Twey> Guards/multiple definitions are compiled down to case
15:17:37 <Twey> In standard Haskell, case can do pattern-matching while guards can't (but there's the PatternGuards extension)
15:17:53 <juliohm> it's because with we should use case when the conditions depend on the variable being passed directly, right?
15:18:19 <Twey> I don't think there are any hard and fast rules as to when you ‘should’ use one over the other
15:18:22 <MostAwesomeDude> Twey: I thought PatternGuards got added to Haskell 2010, didn't it?
15:18:26 <monochrom> I don't understand that
15:18:27 <Twey> Use whatever makes your code nicest
15:18:38 <Twey> Did it?
15:18:40 <juliohm> ops, i missed a word...
15:19:13 <juliohm> I think guards should be used when we have arbitrary conditions, and case/of when we try to pattern match the argument being passed
15:19:17 <Twey> MostAwesomeDude: Ah yeah, looks like.  Great!
15:19:47 <slack1256> MostAwesomeDude. yep, they got added
15:19:51 <juliohm> Yes, understood the application of each
15:20:04 <Twey> juliohm: Pattern guards offer the additional ability to match a sequence of patterns and ensure they all succeed
15:20:20 <Twey> … though I guess you can always case on a tuple
15:20:55 <juliohm> Interesting, i have to play more with Haskell to get all the details.
15:21:05 <slack1256> In Data.Complex why realPart and imagPart have a 'RealFloat a => Complex a -> a' type?
15:21:15 <slack1256> shouldn't it be 'Complex a -> a'
15:21:40 <slack1256> they don't use any function defined in RealFloat.
15:23:03 <monochrom> because of "data RealFloat a => Complex a = ..."
15:25:21 <monochrom> it is a great example of why you should just "data Complex a = ..."
15:25:56 <Twey> The thought of a non-RealFrac Complex is odd, though.
15:26:16 <Nereid> Twey: not really, Complex Integer and Complex Rational make perfect sense.
15:26:35 <slack1256> Nereid: I was bitten exactly by Complex Integer
15:26:53 <monochrom> there is a line between "odd" and "forbidden"
15:27:08 <Nereid> how come the RealFloat constraint is still there?
15:27:18 <slack1256> monochrom: but at least in base 4.5.0.0 Complex is defined 'data Complex a = !a :+ !a'
15:27:29 <Nereid> oh, that's good then
15:27:38 <Twey> Nereid: Ehh.  abs (1 :+ 1) = ?
15:27:49 <Twey> Complex Rational I'll grant you
15:27:57 <Nereid> Twey: maybe abs doesn't belong in Num? ;)
15:28:01 <Twey> … or not, actually
15:28:03 <bitonic> what's the easiest way to serialise a String to a list of Word8?  utf8-string to get a ByteString?
15:28:09 <benmachine> Complex Rational wouldn't do it, no
15:28:16 <Twey> Yeah
15:28:27 <Twey> It pretty much has to be RealFrac
15:28:41 <monochrom> then I don't know
15:28:42 <benmachine> but there's zero sense in the RealFloat constraint being on the constructor
15:28:45 <Twey> Nereid: Wherever abs belongs, I'd say it definitely applies to Complex
15:28:48 <benmachine> it should be on the Num instance
15:28:50 <t7> bitonic: yeah utf8 encode? then unpack
15:28:55 <Nereid> Twey: I agree it applies to Complex Real.
15:29:10 <Nereid> well, whatever Real is.
15:29:15 <bitonic> t7: well but I was wondering if that's the best way
15:29:18 <benmachine> Twey: there are useful applications of Complex Integer and Complex Rational
15:29:22 <benmachine> in principle
15:29:28 <Twey> I can't think of any
15:29:45 <Twey> I'm pretty sure that mathematically complex numbers are defined as a superset of real numbers
15:30:02 <Nereid> Twey: never heard of the gaussian integers
15:30:03 <Nereid> ?
15:30:18 <benmachine> Twey: yeees, but there are other interesting structures of the form a + bi
15:30:24 <Nereid> also, I would like to see something like norm :: Complex a -> a
15:30:38 <Twey> Nereid: But that's not Complex
15:30:46 <Nereid> Twey: it's Complex Integer
15:30:49 <Twey> benmachine: Sure, but not Complex
15:31:01 <benmachine> Twey: why not? the addition and multiplication is identical
15:31:08 <benmachine> it's a subfield of the complex numbers
15:31:12 <Nereid> subring*
15:31:22 <Twey> Because it has different semantics elsewise
15:31:22 <benmachine> Nereid: Complex Rational is a subfield :P
15:31:26 <slack1256> Twey: as a mathematician. yes one interpretation We usually teach complex numbers as a R2 dotted of a structure of field
15:31:30 <Nereid> I thought we were talking about Z[i].
15:31:45 <Nereid> I mean Complex Integer.
15:32:02 <benmachine> Twey: okay so it has the same equality, addition, multiplication, division, along with conjugation operations
15:32:08 <benmachine> but apart from that, it's *totally different*
15:32:28 <Twey> Haha
15:32:55 <benmachine> I'm just sayin', it doesn't make sense to demand reals unless you want reals
15:32:57 <benmachine> reals are icky
15:33:05 <benmachine> you can do a lot better with subsets, cf. http://hackage.haskell.org/packages/archive/cyclotomic/0.3.1/doc/html/Data-Complex-Cyclotomic.html
15:33:10 <geekosaur> I thought there were Gaussian rationals as well...
15:33:17 <benmachine> geekosaur: yep
15:33:21 <benmachine> Q[i] is a field
15:33:36 <Nereid> benmachine: ah, there's a package for that too? cute.
15:33:42 <benmachine> (well, ℚ, but ykwim)
15:33:48 <Twey> I just don't want to call them ‘complex’.  Sure, they're similar, and perhaps the similarities could be abstracted out into a different structure, but complex isn't it.
15:33:56 <tylerkahn> guys what does :HdevtoolsInfo do
15:34:01 <tylerkahn> from vim-hdevtools
15:34:03 <benmachine> Twey: but they are complex numbers!
15:34:12 <benmachine> Twey: they aren't ALL the complex numbers, but then neither is Complex Double :)
15:34:22 <Nereid> Double isn't a field ;)
15:34:26 <benmachine> Nereid: cyclotomic is actually more than just gaussian rationals, it's an even bigger field
15:34:32 <Nereid> benmachine: I know what they are
15:34:32 <tylerkahn> it's not in the readme and I can't read vimscript that well
15:34:36 <Nereid> I'm saying it's cute that the package exists.
15:34:36 <benmachine> fair enough
15:34:40 <benmachine> yeah, I thought so :)
15:34:55 <Twey> benmachine: Ehh, implementation detail
15:34:58 <geekosaur> tylerkahn, looks like a command added to vim, which probably tells you the version of the vim-hdevtools package or similar
15:35:09 <Twey> Complex Double *wants* to be all the complex numbers.  :þ
15:35:28 <benmachine> Twey: to me, the essence of complex numbers is their multiplication rule
15:35:35 <benmachine> well
15:35:41 <Nereid> I don't know why we're arguing.
15:35:47 <benmachine> generally the idea that you have a solution of x^2 + 1 in there
15:35:59 <Nereid> for any ring R, it makes perfect sense to make Complex R
15:36:09 <Nereid> (as R[i]/(i^2 + 1))
15:36:26 <Twey> It makes sense to make it.  I'm not convinced it makes sense to name it so.
15:36:37 <Nereid> what else would you call it?
15:36:46 * Twey shrugs.
15:37:03 <Twey> Gaussian Integer
15:37:04 <tylerkahn> geekosaur: that sounds plausible but i think it has to do with this, https://github.com/bitc/hdevtools/blob/master/src/Info.hs
15:37:10 <Twey> Gaussian Rational
15:37:11 <slack1256> the essence of complex numbers is that every differentiable function on them has a laurent series and is holomorphic, so if it is one time differentiable is infinitely differentiable
15:37:13 <Nereid> Twey: Gaussian Real?
15:37:16 <Twey> :þ
15:37:20 <Twey> Knew that was coming
15:37:23 <slack1256> or something like that
15:37:24 <geekosaur> Twey wants the same distinction as with Integral i => Ratio i   vs.  Rational (which is Ratio Integer) ?
15:37:35 <Nereid> also, exercise: show that Complex (Complex R) is isomorphic to (Complex R, Complex R).
15:37:36 <Nereid> ;>
15:37:42 <ddarius> Ah the subtle power notation.
15:37:50 <Twey> geekosaur: Really, if we're getting into proposals, I'd just argue for not calling Complex ‘Complex’.
15:38:14 <Twey> It's misleading.  Call it something else (Gaussian?) and you can have all the Integers you want.
15:38:32 <Nereid> it's not misleading at all.
15:38:45 <ddarius> Much better.
15:38:47 <benmachine> Twey: ok so you find out that there is a type called Complex Integer. what do you assume it does?
15:39:03 <Twey> benmachine: Breaks :þ
15:39:09 * benmachine rolls eyes
15:39:27 <benmachine> fine, have it your way :P
15:39:47 <ddarius> slack1256: That wouldn't be the essence of complex numbers, it would be the essence of functions of complex reals.
15:39:50 <Twey> Wikipedia: « A complex number is a number that can be put in the form a + bi, where a and b are real numbers and i is called the imaginary unit »
15:40:04 <Twey> Since our ‘Complex’ is not restricted to reals, it shouldn't be called ‘Complex’.
15:40:18 <ddarius> Wikipedia is simply wrong.
15:40:23 <benmachine> Twey: but all gaussian integers *are* complex numbers
15:40:27 <zzing> I get an error    parse error on input `"'    on a line  containing     <$> areq textField "Name" Nothing     this does not make any sense to me, is there a common source of this kind of parse error?
15:40:30 <t7> wtf wikipedia is truth
15:40:31 <benmachine> 'cause integers are real numbers :P
15:40:38 <slack1256> ddarius: the essence of function of complex but yeah. I... I just wanted to say something :P
15:40:43 <tylerkahn> zzing: post your code on hpaste.org
15:40:44 <t7> wikipedia is the definition of truth; see wikipedia
15:40:46 <benmachine> (pedantic mathematical philosophy aside)
15:40:53 <Twey> Heh
15:40:54 <Nereid> zzing: and also post the entire error message
15:41:07 * hackagebot yaop 0.1.2.1 - Yet another option parser  http://hackage.haskell.org/package/yaop-0.1.2.1 (EugeneSmolanka)
15:41:24 <ddarius> t7: I'm pretty sure if you look up Wikipedia on Wikipedia it will also define Wikipedia with various qualifications.
15:41:27 <Twey> benmachine: But the set of Gaussian integers is not the set of complex numbers, and, more importantly, Gaussian integers don't support all the same operations as complex numbers
15:41:30 <hpaste> zzing pasted “Parse Error” at http://hpaste.org/74497
15:42:00 <benmachine> Twey: this is true, but I think the name "complex integer" is a very descriptive one
15:42:08 <benmachine> Twey: or at least, it's easy to guess what it means
15:42:25 <Nereid> benmachine: someone might think it's the ring of integers in C
15:42:41 <Nereid> i.e. the algebraic integers
15:42:47 <Nereid> I dunno.
15:42:49 <Twey> benmachine: Sure, but the existing definition is also perfectly reasonable.
15:43:08 <benmachine> Twey: ok so we have two perfectly reasonable definitions, one of which allows more behaviour
15:43:35 * slack1256 wonders if this is bikeshedding
15:44:06 <benmachine> slack1256: I think of this as more of a philosophical discussion than a design one
15:44:13 <benmachine> I don't have a particular goal in mind
15:44:32 <geekosaur> zzing, I was afraid of that.  there is TH involved so there could well be oddness going on behind the scenes.  (Yesod does a *lot* of TH shenanigans)
15:44:43 <zzing> geekosaur, yes it does
15:44:43 <slack1256> I wanted to know if 'imagPart' could change its signature to 'Complex a -> a'
15:44:55 <dolio> The only solution is to put the RealFloat a constraint back on complex.
15:45:00 <dolio> So that people will stop complaining.
15:45:10 <zzing> geekosaur, altohugh I am not sure if there is an TH in this exact spot
15:45:11 <ddarius> Ugh.
15:45:34 <benmachine> slack1256: I think that's more or less inevitable
15:45:47 <benmachine> it will happen when Haskell2011 is more widely used
15:45:53 <slack1256> dolio: people will complain more.
15:45:58 <ddarius> :t imagPart
15:45:59 <lambdabot> forall a. (RealFloat a) => Complex a -> a
15:46:06 <ddarius> :t (:+)
15:46:07 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
15:46:22 <slack1256> que?
15:46:23 <slack1256> what?
15:46:31 <geekosaur> slack1256, I believe realPart and imagart are fields from the declaration of Complex, so they automatically get and keep that constraint
15:46:36 <geekosaur> as it comes from the record declaration
15:46:39 <geekosaur> @src Complex
15:46:39 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
15:46:47 <geekosaur> hm, I'm wrong I guess
15:46:50 <parcs`> > let foo | let bar = 5 = bar + 1 in foo
15:46:51 <geekosaur> @src realPart
15:46:51 <dolio> What version of GHC is lambdabot running?
15:46:51 <lambdabot> realPart (x :+ _) =  x
15:46:51 <lambdabot>   6
15:47:02 <benmachine> geekosaur: lambdabot's definitions are unreliable
15:47:09 * parcs` never knew you can place let statements inside guards
15:47:14 <geekosaur> ...ok, indirectly from the record (which uses an infix constructor).  same thing
15:47:24 <Nereid> parcs`: of course you can.
15:47:25 <Nereid> :P
15:47:27 <benmachine> parcs`: a consequence of PatternGuards I think
15:47:29 <benmachine> or wait
15:47:41 <benmachine> you can definitely always put let-expressions in there
15:47:42 <dolio> Guards contain arbitrary boolean expressions.
15:47:52 <slack1256> geekosaur: in base 4.5.0.0 that constraint doesn't exist
15:47:52 <Twey> benmachine: ‘Complex Integer’ is *reasonable* but not correct, so I'd prefer a different name.
15:47:52 <benmachine> PatternGuards contain... several things
15:48:07 <geekosaur> benmachine, but I recognized that when it came out
15:48:08 <benmachine> Twey: I would argue it becomes correct by being reasonable :P
15:48:23 <Twey> That way lies madness!
15:48:28 <benmachine> ooh
15:48:31 <benmachine> ghci> :i Complex
15:48:32 <benmachine> data Complex a = !a :+ !a 	-- Defined in `Data.Complex'
15:48:41 <zzing> I think I might avoid the forms yesod provides. There are yet other ways to construct these things. Time to run though. Merci.
15:48:46 <Twey> Madness I tell you.
15:48:58 <benmachine> Twey: isn't it delicious though
15:49:03 <benmachine> Twey: delicious, sweet insanity
15:49:14 <Nereid> more generally, if R already contains a square root of -1, then Complex R ~= (R,R)
15:49:31 <Nereid> I think
15:49:36 <ddarius> My cholUpdate is creating columns.
15:49:43 <benmachine> Nereid: I think Complex (Complex R) =~ Complex R
15:49:51 <benmachine> Nereid: not (Complex R, Complex R)
15:49:53 <Nereid> benmachine: that's clearly false.
15:50:01 <Nereid> look at their dimensions over R.
15:50:20 <benmachine> Nereid: you can have extensions of dimension 1
15:50:21 <Twey> benmachine: Complex R ~= R²
15:50:25 <Twey> No?
15:50:31 <Nereid> benmachine: but Complex isn't one of them.
15:50:32 <benmachine> Twey: depends which ~=
15:50:38 <ddarius> benmachine: They are different i's.
15:50:41 <Twey> Touché
15:50:42 <benmachine> ddarius: ah, okay
15:50:55 * benmachine thinks for a bit
15:51:02 <centrinia> Complex Z_10 ~= (Z_10,Z_10)?
15:51:03 <benmachine> yeah, no, you're right, I was thinking of something else
15:51:08 <benmachine> or well
15:51:11 <Nereid> Complex (Complex R) is like R[x,y]/(x^2 + 1, y^2 + 1)
15:51:14 <ddarius> Geometric (/Clifford) algebras make this clearer.
15:51:16 <benmachine> you're at least not wrong for the reason I thought you were wrong :P
15:51:16 <Nereid> or something.
15:51:34 <Nereid> :P
15:51:35 <ddarius> sigfpe has an article on this.
15:51:40 <benmachine> Nereid: right. I was thinking "take the splitting field of X^2 + 1 twice"
15:51:43 <benmachine> or something
15:51:58 <benmachine> Nereid: your thing isn't a field, right?
15:52:02 <Nereid> well the point is that yeah it's not a field.
15:53:39 <int-e> Nereid: can you try  http://hpaste.org/74498  under Windows?
15:54:41 <Nereid> Precedence parsing error
15:54:42 <Nereid>         cannot mix `>>>=' [infixl 9] and `.' [infixr 9] in the same infix expression
15:54:43 <Nereid> :p
15:55:20 <Nereid> putting some extra parentheses in.
15:55:23 <Nereid> and it works.
15:55:49 <int-e> Nereid: hmpf. I had an infixr 5 >>>=  in there at some point.
15:57:48 <Nereid> int-e: and the >> return 1 seems unnecessary.
15:58:24 <juliohm> It's common practice to use `import qualified' ?
15:58:33 <Cale> juliohm: for some modules
15:58:46 <int-e> Nereid: right. But it doesn't hurt. (I also tried 'print x', and printing () is somewhat pointless)
15:58:51 <juliohm> Cale, what's a good criterion?
15:58:55 <Cale> juliohm: Basically for modules which export a lot of names which are already taken by the Prelude.
15:59:06 <Cale> Things like Data.Map and Data.Set
15:59:07 <juliohm> Ok
15:59:21 <int-e> Nereid: while checking that it actually prints 1 is a good plausibility check
15:59:34 <juliohm> there is some convention for the qualified names?
15:59:40 <Cale> Some people like to aggressively import everything qualified. I think qualified names look kinda ugly myself.
15:59:40 <slack1256> juliohm: also sometimes the documentation suggestion of importing qualified (ej: Data.Text)
15:59:57 <slack1256> *suggest
16:00:03 <Cale> "." was a really bad choice of module path separator.
16:00:22 <dolio> Should have used /
16:00:28 <int-e> hah.
16:00:55 <maukd> \
16:01:07 <Cale> I kinda like the thought of using |
16:01:29 <dolio> Yeah, it should alternate between / and \ depending on whether the file's line endings are \r\n, \n or \r.
16:01:35 <Cale> lol
16:01:56 <maukd> &nbsp;
16:01:58 <int-e> I wouldn't mind ^
16:02:25 <int-e> (I don't need exponentiation all that often)
16:04:31 <slack1256> was "." a bad choice by aesthetics or some errors that happen?
16:05:18 <Eduard_Munteanu> '.' is so C++...
16:05:47 <dolio> > let f x | x == 5 = not True|otherwise = True in (f 5, f 6)
16:05:48 <lambdabot>   (False,True)
16:06:24 <int-e> also Pascal, Modula ...
16:06:33 <int-e> And C++ has :: for namespace access
16:06:48 <slack1256> also Poetic ...
16:08:23 <int-e> Ah, ^ is Pascal's equivalent to C's ->. That's why it looked familiar.
16:08:49 <maukd> Data'List
16:08:54 <int-e> hmm, no, it's *. I should sleep :)
16:09:09 <int-e> maukd: I almost asked whether people use identifiers like that
16:10:19 <Nisstyre-home> FWIW, Racket uses /
16:10:24 <Nisstyre-home> which works well I think
16:11:02 <juliohm> wow, i'm reading the Haskell docs much faster, i'm getting familiar with the language, that's nice.
16:11:05 <int-e> Hmm, I like / for division and /= for disequality.
16:11:38 <juliohm> unequality with /= is cool and strange at the same time
16:11:51 <ddarius> This paper has an odd definition of QR decomposition.
16:11:51 <juliohm> i always remember /= C++ implementation
16:12:22 <int-e> (And in the end this is a bikeshed question. not worth changing Haskell for, I think. Similar to the unary minus issue.)
16:12:34 <imeredith> juliohm: heh, thats a common phenomenon - being unfimilar makes things seem hard
16:13:16 <juliohm> imeredith, i had read the book in other opportunity, just rereading it is making things clear.
16:13:31 <juliohm> I finished to read the chapter about modules and how nice they are
16:13:48 <imeredith> oh yeah, i love re-reading things after actaully getting to understand the concepts
16:13:52 <maukd> be glad you're not using ocaml, they use ! for *
16:14:18 <mizu_no_oto> Why are some of the functions in Data.Set strict?  For example, member is strict in its first argument
16:14:25 <juliohm> maukd, ! is used as a dereference operator in OcamL?
16:14:43 <maukd> yes
16:14:48 <juliohm> wow
16:14:56 * ddarius prefers OCaml's syntax to C's.
16:15:00 <benmachine> mizu_no_oto: how would it not be?
16:15:01 <ddarius> In that regard  I mean.
16:15:13 <juliohm> The indexation in Haskell is also not that great
16:15:14 <juliohm> !!
16:15:42 <benmachine> mizu_no_oto: well, I suppose it's /nearly/ always strict anyway, so it might as well just always be strict for optimisation purposes
16:15:56 <mizu_no_oto> benmachine:  Well, is there any particular reason why it has "STRICT_1_OF_2" in the source code?
16:16:17 <benmachine> mizu_no_oto: I don't know, but I imagine for efficiency
16:16:22 <ddarius> juliohm: Yes, but you aren't supposed to ever use (!!).
16:16:55 <juliohm> ddarius, we can replace it always?
16:17:26 <juliohm> How would you get the n-th element of a list?
16:17:37 <maukd> you don't
16:17:47 <ddarius> If you are using it, you are doing something wrong.  You either want a different data structure or a different algorithm.
16:17:50 <Eduard_Munteanu> juliohm: the problem is lists aren't the proper data structure for that
16:18:31 <juliohm> I can agree at some point, but maybe it's the proper data structure and i just want to access one particular element.
16:18:40 <Nereid> what abotu something like
16:18:54 <Nereid> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
16:18:54 <lambdabot>   354224848179261915075
16:19:21 <ion> lastFib = fibs !! 1000
16:19:45 * ddarius decides it's important to not underestimate the noise level in the UKF.
16:20:01 <juliohm> !ukf
16:20:15 <juliohm> @UKF
16:20:15 <lambdabot> Unknown command, try @list
16:20:19 <juliohm> @list
16:20:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:20:45 <ddarius> Nereid: In many cases, that is non-ideal since none of the prior elements get forced and then they all get forced at once leading to a stack overflow.
16:20:53 <ddarius> (As well as wasted memory.)
16:21:06 <Nereid> > let fibs = 0 : 0 : zipWith (+) fibs (tail fibs) in fibs !! 1000000
16:21:07 <lambdabot>   *Exception: stack overflow
16:21:18 <ion> ddarius: UKF?
16:21:27 <ddarius> Unscented Kalman Filter.
16:21:29 <juliohm> Haskell can be trick and delightful
16:21:32 <ion> ah
16:22:00 <Eduard_Munteanu> ddarius: are you studying that sort of stuff lately?
16:22:05 <geekosaur> juliohm, lists in Haskell are singly linked lists, getting a particular element is quite slow.  in general you want a different type if you want anything other than traversal
16:22:31 <juliohm> great point
16:22:34 <benmachine> !! is sometimes useful for coping with other peoples' bad APIs, though
16:22:56 <juliohm> what is the data structure compared to std::vector<> in Haskell?
16:23:00 <ddarius> Eduard_Munteanu: I'm making things that (maybe) can use it.
16:23:01 <juliohm> with fast indexing
16:23:05 <Nereid> juliohm: Arrays.
16:23:08 <benmachine> juliohm: there are a few
16:23:15 <Nereid> and there are a few Arrays.
16:23:15 <benmachine> Data.Sequence has pretty fast indexing
16:23:17 <ddarius> "Few" is a massive understatement.
16:23:22 <Nereid> and a few others, I suppose.
16:23:32 <ddarius> Luckily, there has been some consolidation and winnowing with time.
16:23:36 <juliohm> the most popular is Array?
16:23:52 <benmachine> juliohm: Array is nice because it comes with the standard distribution
16:24:00 <ddarius> Array sucks.
16:24:00 <juliohm> far enough
16:24:04 <juliohm> ops
16:24:07 <juliohm> fair*
16:24:10 <benmachine> the vector package is also quite popular
16:24:12 <maukd> juliohm: Data.Sequence
16:24:27 <BMeph> juliohm: Data.Vector. ;þ
16:24:32 <benmachine> but yeah, Data.Sequence is my favourite
16:24:46 <benmachine> underrated module IMO
16:24:50 <Nereid> benmachine: but that's not constant-time access :P
16:24:51 <ddarius> I don't think I've ever actually used Data.Sequence.
16:25:02 <Nereid> although logarithmic may as well be constant.
16:25:16 <benmachine> Nereid: pedantically, constant-time access is impossible
16:25:20 <juliohm> This is what i don't like, redundancy: when we have multiple implementations in a language to achieve the same task.
16:25:21 * Eduard_Munteanu used it as a queue for breadth-first search, for example
16:25:35 <ddarius> juliohm: They have dramatically different properties.
16:25:38 <djahandarie> juliohm, they can also solve different tasks.
16:25:52 <maukd> oh man
16:25:55 <ddarius> juliohm: Having everything be a hash-table like javascript is definitely the wrong thing to do.
16:25:55 <benmachine> Nereid: Arrays get away with it because addresses are bounded
16:25:58 <maukd> you're going to hate programming
16:26:07 <ion> juliohm: Yeah, just like C++ has std::vector and std::list. What’s up with that? Redundancy is annoying.
16:26:12 <Nereid> benmachine: but now you're being pedantic :p
16:26:21 <benmachine> Nereid: well, yes and no
16:26:22 <maukd> ion: don't forget std::deque
16:26:30 <maukd> AND arrays!
16:26:37 <maukd> and malloc
16:26:40 <maukd> and new[]
16:26:52 <benmachine> Nereid: the lesson to take away from this is that the asymptotics of array access vs. map access aren't really relevant
16:26:55 <ddarius> At any rate, asymptotics aside, Data.Sequence has a significant overhead compared to something like Data.Vector, but, of course, is much more flexible.
16:26:56 <benmachine> (imo)
16:26:58 <juliohm> ion, std::vector<> is not interchangeable with std::list<>
16:27:01 <Nereid> benmachine: I know.
16:27:05 <ion> juliohm: Bingo.
16:27:28 <benmachine> Nereid: and if you /do/ want to give arrays asymptotics, then constant time is... sketchy
16:27:38 <juliohm> I have to look into all this alternatives to std::vector<>
16:27:49 <juliohm> Data.Sequence, Data.Vector, Array...
16:28:10 <juliohm> how can i load this modules in ghci and look for all definitions?
16:28:17 <juliohm> I tried :l Data.Sequence
16:28:18 <maukd> ... no?
16:28:21 <int-e> Nereid: Ah, I can still break it on i386 ... just put a System.Mem.performGC in the middle of the unsafePerformIO'd action. I'll stop playing here - maybe it just can't be done, and in any case it's an interesting but useless exercise :)
16:28:27 <maukd> juliohm: import Data.Sequence
16:28:30 <Nereid> juliohm: import Data.Sequence, or :m + Data.Sequence, or ...
16:28:41 <Nereid> int-e: now that's getting silly.
16:28:45 <juliohm> oh, :l is just for local files
16:28:49 <benmachine> juliohm: for looking at all definitions, try :browse ModuleName
16:28:52 <Nereid> juliohm: but if you want to look at the definitions, just look at the docs
16:28:56 <Nereid> or browse
16:29:00 <benmachine> but the docs are better :P
16:29:04 <Nereid> well, browse gives you just type signatures.
16:29:11 <Eduard_Munteanu> int-e: what are you trying to do?
16:29:41 <Nereid> Eduard_Munteanu: implement unsafePerformIO using unsafeCoerce
16:29:46 <djahandarie> juliohm, why do you need something equivalent to std::vector? Unless you're trying to implement std::vector, that's a bad goal. You probably have some 'real' goal, and one of those modules that have been mentioned tailors to that goal better than the others.
16:30:21 <int-e> Eduard_Munteanu: http://hpaste.org/74498 (last annotation includes the performGC test)
16:30:25 <djahandarie> The fact is that if those modules were redundant from all perspectives, one or the other would be discontinued.
16:30:34 <Eduard_Munteanu> Mm, that might not be possible, and it depends on the implementation anyway.
16:30:40 <benmachine> Nereid: ah, well, that sounds sensible and legitimate as a goal.
16:30:58 <Nereid> benmachine: what does?
16:31:10 <ion> There should be a generalization of all the unsafe*.
16:31:10 <benmachine> Nereid: implementing unsafePerformIO with unsafeCoerce
16:31:11 <int-e> Eduard_Munteanu: of course. I had already concluded that it can't be done ;-)
16:31:16 <Nereid> ah
16:31:28 <ddarius> Such as uvector being deprecated by vector (as part of that consolidation I mentioned)
16:32:13 <benmachine> ion: unsafeDoWhatIMean
16:32:17 <juliohm> djahandarie, as i said, i have to take a better look before conclude something, but many options for std::vector<> indicates something was not correctly optimized, i think.
16:32:21 <benmachine> :: a, presumably
16:32:40 <juliohm> we do not have many alternatives to std::vector<> on C++
16:32:47 <maukd> juliohm: no, it just means that std::vector is a bad abstraction
16:32:55 <maukd> juliohm: excuse me?!
16:33:09 <juliohm> maukd, bad abstraction in what sense?
16:33:21 <maukd> juliohm: alternatives to std::vector in C++ include: std::list, std::deque, std::stack, arrays, malloc, new[]
16:33:28 <maukd> this is just off the top of my head
16:33:36 <maukd> there are tons more
16:33:56 <juliohm> but these are not to be used in replacement of std::vector<> as far as i know
16:34:03 <maukd> why not?
16:35:03 <geekosaur> 'as far as I know' is a bit of a smell... it implies you do *not* know.  do you?  do you know the srengths and weaknesses of your data structures, and when to use them?
16:35:06 <juliohm> stack, deque have fast push/pop operations, whereas list is for fast traversing of non contiguous data, malloc,new,arrays are not memory safe and avoided in C++
16:35:14 <dncr> if i have a bunch of nested datas myA = A {a1 = B {..}, a2 = C {..}, ..}, has anyone made a thing that I can just derive for A, B, C, .. to print myA as a tree instead of in one long line like (show) does?
16:35:27 <maukd> juliohm: std::vector isn't memory safe either
16:35:45 <maukd> juliohm: std::vector has fast push/pop, and so does list
16:36:01 <juliohm> maukd, at least they're type safe and memory is automatically handled behind the hood.
16:36:16 <juliohm> std::vector has fast push/pop?
16:36:18 <maukd> juliohm: arrays are also type safe
16:36:20 <maukd> juliohm: yes
16:36:24 <dncr> i want an output like: unlines ["A", "- a1 = B", "  - ..", "- a2 = C", ..]
16:36:49 <juliohm> maukd, how do you insert an element in front of a std::vector<>?
16:36:56 <juliohm> you have to shift everything
16:37:06 <maukd> true
16:37:06 <juliohm> it's not designed for that
16:37:21 <juliohm> thus, std::stack is not an alternative for std::vector
16:37:22 <benmachine> juliohm: put it on the other end?
16:37:30 <maukd> juliohm: std::stack can't insert at the front either
16:37:34 <juliohm> benmachine, or use the appropriate data structure
16:37:34 <int-e> juliohm: why would you insert at the front?
16:37:36 <ion> unsafe :: (Functor f, Functor g) => f a -> g b; unsafe = magic; unsafeCoerce :: a -> b; unsafeCoerce = runIdentity . unsafe . Identity; unsafePerformIO :: IO a -> a; unsafePerformIO a = runIdentity (unsafe a)
16:37:56 <Nereid> juliohm: the general point is to use a data structure that suits the application.
16:37:59 <juliohm> int-e, priority queues, don't know, many applications would require insert at front
16:38:19 <benmachine> ion: unsafe :: (Unsafe a) => a
16:38:20 <juliohm> Nereid, exactly, and i'm trying to find THE solution in Haskell to replace std::vector<>
16:38:26 <benmachine> ion: instance Unsafe (a -> b) -- etc.
16:38:28 <juliohm> seems there is no one consolidated solution
16:38:33 <benmachine> wait no that doesn't work
16:38:34 <ion> benmachine: heh
16:38:40 <benmachine> never mind
16:38:40 <int-e> juliohm: for implementing a stack using vector. For a deque you need to manipulate both ends, of course.
16:38:48 <ion> benmachine: It does with {-# LANGUAGE UnsafeInstances #-}
16:39:08 <benmachine> ion: {-# LANGUAGE Masochism #-}
16:39:19 <dolio> That unsafePerformIO is unlikely to do what people expect it to do.
16:39:36 <benmachine> dolio: if in doubt, apply mroe magic
16:39:51 <benmachine> juliohm: what solution you get depends on what question you ask
16:40:06 <benmachine> juliohm: iirc you asked for fast indexing. there are several haskell types, as several C++ types, that support that
16:40:23 <juliohm> My question was: What is the data structure in Haskell i should use to mimic the std::vector<> implementation?
16:40:35 <benmachine> juliohm: it would be more helpful if you specified the characteristics you wanted
16:40:37 <maukd> "thus, std::stack is not an alternative for std::vector" is even funnier if you know what std::stack actually is
16:40:41 <shachaf> The answer is probably "you shouldn't".
16:41:01 <maukd> std::stack is a newtype wrapper around an existing container type. such as std::vector.
16:41:11 <juliohm> maukd, it uses std::vector<> under the hood i know
16:41:18 <maukd> no, it defaults to deque
16:41:20 <int-e> juliohm: none, since in general one tries to avoid mutation. so it really depends on what you're doing to the vector
16:41:27 <Nereid> ^
16:41:38 <benmachine> we have mutable arrays in haskell
16:41:41 <Nereid> for a constant-size array, some Array thing is fine.
16:41:43 <BMeph> juliohm: Better ask, "What behavior do I need," rather than, "What implementation should I reproduce".
16:41:44 <benmachine> we try to avoid them, but they are there if we need them
16:41:53 <benmachine> I agree with BMeph
16:41:55 <Nereid> but
16:42:01 <Nereid> blah
16:42:05 <benmachine> especially if you go into #haskell and expect people to know about C++
16:42:10 <benmachine> I mean, some of us do
16:42:17 <int-e> right. but they are fixed size, so if you want a vector-like dynamic size array, you have some work left to do.
16:43:04 <benmachine> int-e: hmm.
16:43:09 <juliohm> Let me see... if the size of the (immutable) vector is fixed i should use Arrays, if i want dynamic storage and mutability with fast indexing, what is the choice?
16:43:10 <maukd> but wait, one of the advantages of std::vector is that it exposes a raw memory buffer, suitable for passing to C functions
16:43:15 <maukd> you'll have to replicate that!
16:43:34 <BMeph> What's the inverse of "metaprogramming"?
16:43:38 <juliohm> the C++ trick &vec[0]
16:43:44 <int-e> maukd: bytestring
16:43:46 <benmachine> int-e: how often in practice does resizing an array require copying it?
16:44:01 <int-e> benmachine: pretty much all the time
16:44:03 <ion> bmeph: gnimmargorpatem
16:44:16 <benmachine> oh well in that case, dynamic storage is a non-issue
16:44:19 <benmachine> just make a new array :P
16:44:22 <juliohm> BMeph, what?
16:44:48 <benmachine> BMeph: metaprogramming aiui is "programs that write programs"
16:44:52 <int-e> benmachine: but you can make the buffer larger than the array size
16:45:05 <BMeph> juliohm: Don't mind me, I'm starting another conversation. :)
16:45:07 <benmachine> int-e: oh, well, that's true. but you can also just oversize your STArray, right
16:45:20 <benmachine> BMeph: that doesn't feel like a group element so I don't know why it would have an inverse
16:45:32 <dncr> so you just wrap mutable arrays to double in size as needed and throw your new library on hackage
16:45:40 <benmachine> juliohm: anyway, I reckon STArray will do the trick most of the time
16:45:43 <ion> Is the inverse of programmer a program that writes humans?
16:45:48 <benmachine> ion: eep
16:45:49 <int-e> benmachine: yes, as I said, there's some work left to do -- and that's it: keeping track of a current size, the buffer size, and growing the buffer when the former exceeds the latter
16:45:55 <benmachine> ion: that sounds like a dual, instead
16:46:05 <Nereid> int-e: and that's exactly what std::vector does.
16:46:09 <Nereid> to my understanding.
16:46:13 <int-e> Nereid: I know
16:46:17 <Nereid> so.
16:46:25 <benmachine> we probably don't have anything on hackage that does that
16:46:29 <benmachine> except for bytestring which does it for bytes
16:46:34 <benmachine> (maybe? I think?)
16:46:37 <juliohm> Let's be clear here, when you say "arrays" in Haskell, you mean a particular implementation of a data structure, namely `Arrays', right?
16:46:50 <juliohm> like import Data.Array
16:47:01 <benmachine> juliohm: who are you talking about
16:47:16 <benmachine> juliohm: I think so, though
16:47:19 <benmachine> that sounds usual
16:47:23 <juliohm> benmachine, everyone on the channel. :)
16:47:30 <benmachine> juliohm: oh, well, we all do different things
16:47:38 <benmachine> there is no haskell hivemind unfortunately :(
16:47:58 <benmachine> (or maybe there is and I just haven't been invited)
16:48:03 <juliohm> Should we add some facts to the channel bot like in #c++ ?
16:48:11 * dncr has never used a mutable array.  i.e. Data.Array.MArray
16:48:18 <dncr> in haskell.  yet.
16:48:21 <benmachine> dncr: I have! it was kind of... okay
16:48:23 <juliohm> @help array
16:48:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:48:32 <benmachine> juliohm: lambdabot is strange
16:48:38 <juliohm> how do you search for these concepts in the bot?
16:48:42 <benmachine> she's very old and no-one really understands her
16:48:49 <juliohm> lol
16:48:49 <benmachine> replacing her would probably be a good idea
16:49:13 <benmachine> however she does do this
16:49:15 <benmachine> @nixon
16:49:15 <lambdabot> This is a great day for France!
16:49:15 <dncr> i think i have a lot to learn about making haskell fast before i get into mutable arrays
16:49:19 <benmachine> so I guess that's something.
16:49:36 <juliohm> benmachine, what bot is lambdabot ?
16:49:41 <maukd> lambdabot
16:49:43 <benmachine> juliohm: a custom one
16:49:49 <Nereid> @version
16:49:49 <lambdabot> lambdabot 4.2.2.1
16:49:50 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:49:53 <juliohm> Written in Haskell i suppose
16:49:56 <benmachine> yes
16:50:00 <Nereid> no, written in python
16:50:04 <benmachine> no that's silly
16:50:07 <juliohm> Why not just use the one written in Python
16:50:08 <Nereid> :P
16:50:09 <juliohm> ?
16:50:17 <dncr> that's funny cabal is up to 4.2.3.3: http://hackage.haskell.org/package/lambdabot
16:50:18 <juliohm> there is a famous Python bot out there
16:50:21 <Nereid> juliohm: and it sucks
16:50:23 <benmachine> juliohm: just the one?
16:50:26 <Nereid> I've used it for years, it sucks
16:50:37 <benmachine> good grief I think I've personally written at least two IRC bots in python
16:50:37 <monochrom> lambdabot is written in php :)
16:50:49 <juliohm> Nereid, the main point is to add facts to the bot, is lambdabot capable of?
16:51:07 <Nereid> yes
16:51:08 <juliohm> so that we can clarify new comers
16:51:10 <benmachine> juliohm: umm, lambdabot can remember quotes
16:51:14 <benmachine> it's not really used for that though
16:51:17 <maukd> and factoids
16:51:21 <juliohm> how could i add a definition to Arrays in lambdabot ?
16:51:21 <benmachine> we haven't felt the need for that feature, I guess
16:51:27 <monochrom> @where lyah
16:51:27 <lambdabot> http://www.learnyouahaskell.com/
16:51:34 <monochrom> you're talking about that
16:51:40 <int-e> benmachine: Hmm, bytestring does it for hGetContents at least. Otherwise it seems to prefer predicting (or overapproximating) the final size of the Bytestring.
16:51:56 <benmachine> int-e: well sure, that's always to be preferred
16:51:59 <monochrom> but adding a definition to Arrays? what does that mean?
16:52:02 <benmachine> int-e: what about snoc et al?
16:52:12 <benmachine> monochrom: I think he meant "of"
16:52:14 <int-e> benmachine: those create a new bytestring
16:52:25 <benmachine> int-e: oh, I suppose that makes sense
16:52:26 <int-e> benmachine: so there's no choice but to copy the whole thing
16:52:27 <monochrom> sure, change it to "of". what does that mean then?
16:53:09 <juliohm> @array is The term array used in the Haskell community refers to a particular implementation of the data structure that can be found on Data.Array
16:53:10 <lambdabot> Yeh scurvy dog...
16:53:15 <juliohm> @array
16:53:15 <lambdabot> Avast!
16:53:20 <juliohm> lol
16:53:27 <Nereid> @array
16:53:28 <lambdabot> Aye
16:53:29 <juliohm> it doesn't work like that
16:53:45 <monochrom> I object to adding it. it is needless and lame and condescending
16:53:49 <benmachine> juliohm: aside from anything else, there isn't really a consensus as to how we use the term
16:53:54 <Nereid> @arr
16:53:54 <lambdabot> Swab the deck!
16:53:56 <benmachine> plus, what monochrom said
16:53:59 <int-e> benmachine: Ah I found it - unfoldr also uses a buffer doubling stategy.
16:54:03 <juliohm> why not start doing the consensus?
16:54:05 <Nereid> @yarr
16:54:05 <lambdabot> Har de har har!
16:54:05 <benmachine> int-e: oh, cool
16:54:12 <benmachine> juliohm: because no-one listens to anyone else :P
16:54:20 <benmachine> well
16:54:26 <benmachine> or alternatively, everyone listens to everyone
16:54:47 <juliohm> Haskell needs standards, peer-review libraries, officially maintained libraries, formal definitions to make it easy to discuss the language. :(
16:54:55 <maukd> juliohm: no
16:55:08 <benmachine> juliohm: we have formal definitions
16:55:15 <benmachine> or, well, the language has a formal definition
16:55:22 <monochrom> in the python community, or the C community, or the Java community, or... it holds almost universally true that "array" refers to a specific thing found in the infrastructure of that community/language. why do you need haskell to clarify it?
16:55:32 <juliohm> that are not intended for the end user, but for the GHC implementers
16:55:41 <maukd> juliohm: nonsense
16:55:46 <benmachine> juliohm: the formal definition of the language is quite readable
16:55:49 <dncr> the treeifier (-> Tree String) i want for data types must have a lot of overlap w/ what Data.Derive.JSON does
16:55:57 <benmachine> it's free and I refer to it fairly frequently
16:56:06 <benmachine> well, occasionally at least
16:56:09 * hackagebot cuda 0.4.1.1 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.4.1.1 (TrevorMcDonell)
16:57:54 <juliohm> monochrom, because that specific thing you mentioned is not clear in Haskell
16:58:19 <juliohm> In C++ we know an array can be either T array[] or can be boost::array<>
16:58:22 <dncr> oh maybe i can just use Data.Data stuff
16:58:32 <maukd> juliohm: oh, it can be a boost::array now?
16:58:35 <maukd> that's news to me
16:58:56 <juliohm> maukd, even better, it can be std::array<>
16:58:58 <juliohm> C++11 feature
16:59:08 <monochrom> do you go on a crusade in the c++ community to make them clarify, too?
16:59:08 <maukd> yeah, I'm still on C++98
16:59:31 <monochrom> and in the java community? and in the php community? and in the c community?
16:59:40 * ddarius does not use "array" to refer to a particular module or library.
17:00:00 <juliohm> monochrom, the C++ community is aware of the possible misconceptions and they have a bot full of definitions in #c++
17:00:03 <maukd> ddarius: me neither (in the context of haskell)
17:00:16 <maukd> did you mean: ##c++
17:00:16 <monochrom> and the java community?
17:00:23 <juliohm> yep
17:00:25 <juliohm> ##c++
17:00:34 <maukd> ##c++ is not the C++ community
17:00:39 <maukd> the bot is non-normative
17:00:47 <maukd> better submit a defect report
17:00:51 <juliohm> Everytime something is not clear, people put effort to make it clear
17:01:09 <juliohm> i don't understand why you don't like the idea
17:01:20 <dncr> juliohm: http://www.haskell.org/haskellwiki/Arrays
17:01:24 <maukd> because clarity is worthless by itself
17:01:31 <monochrom> oh, bait and switch
17:01:33 <zzo38> Is there something wrong with this?   x@(Surreal l _) <= y@(Surreal _ r) = null (filter (y <=) l) && null (filter (<= x) r);
17:01:48 <maukd> I also want correctness and relevance
17:01:50 <monochrom> I like making it clear. I don't like adding it to a bot
17:01:53 <juliohm> dncr, you answered the question, thanks. ;-)
17:01:59 <dncr> juliohm: no problem :)
17:02:14 <juliohm> but i still insist a bot would be great
17:02:36 <juliohm> Giving a guess, i think 80% of the Haskell community is on Freenode?
17:02:44 <juliohm> maybe 75%?
17:02:59 <zzo38> This look correct to me but maybe I missed something? Can you tell me if there is something wrong with it please?
17:03:08 <ddarius> Defining "array" to mean "Data.Array" in Haskell would decrease clarity as almost no-one uses the term that specifically and often they use it in the context where "array" might mean Data.Vector.
17:03:13 <monochrom> you will still also insist on "official this", "official that" for haskell in the next 20 years, too
17:03:29 <dncr> there are so many things going on w/ arrays in haskell, an explanatory blurb in a bot should probably just refer to haskellwiki
17:03:40 <monochrom> and yes what ddarius says. let every speaker decide what his/her "array" means
17:03:45 <ddarius> dncr: Even that wiki page is misleading.
17:03:59 <dncr> ddarius: edit it?
17:04:13 <monochrom> in fact, precisely what c++ people should do, too, since there are several kinds of arrays there, and every speaker is free to choose which one he/she means
17:04:23 <ddarius> dncr: Unless I edit it to nothing, I'd have to almost completely rewrite it.
17:04:39 <dncr> ha you guys are too serious
17:05:24 <BMeph> dncr: "My momma always told me that 'Serious is as serious does'." ;)
17:05:30 <juliohm> Every people in C++ knows exactly what an array is, at least the ones experienced in programming in that language.
17:05:44 <monochrom> and every time something is unclear, such as the fact that the Haskell community is not very keen on "official", people make an effort to make it clear
17:05:52 <juliohm> as i said, the term could refer to either T array[] or std::array<> nothing else
17:06:04 <juliohm> when we talk about vectors, we talk about std::vectors<>
17:06:10 <juliohm> nothing else
17:06:40 <monochrom> so, I say it again, here we have almost nothing "official", apart from Haskell 2010, but even then we deviate from that almost every other day, and it works great for us, thank you very much
17:06:44 <juliohm> When we want to refer to another implementation, then we do it explicitly like boost::something or foo::bar::baz
17:06:47 * ddarius is pretty sure programmer's in general often refer to arrays generically.
17:07:03 <maukd> juliohm: ok, and what does "list" refer to in C++?
17:07:06 <ddarius> juliohm: And what if you want to talk about random access data structures with constant time lookup and update?
17:07:11 <juliohm> maukd, std::list<>
17:07:23 <maukd> juliohm: haha, no
17:07:31 <zzo38> Can you please tell me if I am wrong? It doesn't seem to work.
17:07:32 <maukd> parameter lists, argument lists
17:07:47 <maukd> singly-linked lists, doubly-linked lists
17:07:58 <juliohm> ddarius, that's when we go to more abstract levels, this encapsulates lots of implementations
17:08:08 <ddarius> juliohm: And what word do you use?
17:08:12 <BMeph> juliohm: I think part of your "problem" with folks here, is that we think a lot more abstractly in Haskell - and thus, in #haskell. Many folks here are very aware of the implementations needed to get the language working on a PC. We prefer to think of the problems to solve with the language in general.
17:08:29 <maukd> in fact, I think it's sort of dual
17:08:46 <ddarius> Or do you always just say "Take this random access data structure with constant time lookup and update and sum it pointwise with this other random access data structure supporting constant time lookup and update"?
17:08:49 <maukd> a haskell "list" usually specifically refers to []
17:08:58 <maukd> while in C++ it could be anything
17:09:23 <juliohm> maukd, if you ask for the term list in ##c++ everyone will think of std::list<>
17:09:25 <dncr> zzo38: it looks like your first "<=" shouldn't be there?  it's hard to tell.  maybe you can put it on hpaste?
17:09:50 <maukd> juliohm: I'm almost certain you're wrong
17:09:58 <juliohm> ddarius, scalar product
17:10:48 <ddarius> juliohm: Scalar product could refer to scalar products of tuples, and if you are explaining a generic implementation of scalar product, you probably won't make many friends by saying "the definition of scalar product is scalar product".
17:11:18 <ddarius> Also, in this context, those tuples (or arrays) would often be referred to as vectors.
17:11:28 <zzo38> dncr: How do you mean, shouldn't be there, in what way? I tried to put in the rule for ordering of surreal numbers from Wikipedia, into Haskell.
17:11:42 <monochrom> hey, before the hierarchical module names, we could have said "the definition of Array is Array"!
17:11:55 <maukd> Array.Array?
17:12:08 <juliohm> ddarius, i don't see any relation with the original question: What the term "array" means in Haskell?
17:12:11 <monochrom> that's even better
17:12:14 <juliohm> dncr, answered that with a link
17:12:25 <juliohm> i'm just purposing to add an entry to the bot
17:12:32 <monochrom> "therefore, the definition of Array.Array is (Array.Array).(Array.Array)"!
17:12:36 <juliohm> @array ---> returns the link dncr gave us
17:12:36 <lambdabot> Avast!
17:12:49 <maukd> juliohm: how would that be useful?
17:12:52 <dncr> zzo38: ah ok
17:13:07 <juliohm> seriously?
17:13:10 <monochrom> I know how useful that it
17:13:22 <juliohm> You don't see any use in having a clear definition at hand?
17:13:27 <maukd> correct
17:13:33 <zzo38> But I think I did something wrong, because it doesn't work.
17:13:35 <ddarius> juliohm: His link provides many, many different "definitions" of "array", none of them matching common usage in the Haskell community which is to refer to generic arrays.  You seem to want to eliminate generic meanings for specific ones, leaving no words left to refer to the generic meaning.
17:13:42 <maukd> because the definition is wrong, and I've never needed it
17:14:19 <monochrom> in my 5 years or more of watching #haskell, this is the first time someone wants an "array" entry in the bot. and I fully expect we won't need it again for another 5 years. that's how useful it is
17:14:48 <startling> is there a typeclass somewhere that gives me two monoids?
17:15:01 * ddarius can verify for 10 years of being in #haskell, that this has not been a problem or a common request.
17:15:01 <juliohm> Anyways, let's continue our mind-dependent conversation on arrays, everyone pick the definition you like more and let's go crazy! \o/
17:15:18 <juliohm> lol
17:15:18 <startling> a ring would be more accurate, actuaully
17:15:40 <hpaste> mizu_no_oto pasted “Problem with lens” at http://hpaste.org/74503
17:15:44 <startling> @hackage ring
17:15:44 <lambdabot> http://hackage.haskell.org/package/ring
17:16:10 <dncr> i think we usually just do a "let me google that for you move"
17:16:11 <ddarius> juliohm: By "array" I, and most programmers (except those crazy Pythonistas), mean a "random access data structure allowing constant time lookup and, if mutable, update".  There are many, many different implementations of the idea, which you use or the specific API is usually not relevant.
17:16:12 <BMeph> startling: Don't look at that! If you see the ring (package), you'll die! ;þ
17:16:18 <dncr> @wiki Arrays
17:16:18 <lambdabot> http://www.haskell.org/haskellwiki/Arrays
17:16:23 <startling> BMeph: heh
17:16:43 <monochrom> startling: the "algebra" package may help
17:16:52 <juliohm> ddarius, your definition has a "if" clause, what branch i should pick?
17:17:01 <dobblego> so will the reducers package
17:17:08 <startling> monochrom: neat, thanks
17:17:33 <juliohm> dncr, again you saving the world. :P
17:17:35 <dncr> zzo38: if you post your whole attempt and not just that line it's easier to say what the problem is
17:17:38 <juliohm> @wiki vector
17:17:38 <lambdabot> http://www.haskell.org/haskellwiki/vector
17:17:49 <juliohm> oh, i forget this is not a search engine
17:17:54 <dncr> but @wiki is just a lame prefixer right now
17:18:05 <ddarius> juliohm: There are a lot more choices than that.  I haven't defined the machine model with respect to which I'm claiming "constant time", but usually you know if you are talking about mutable array/need update or not, if you don't then it probably doesn't matter, so pick whichever you prefer.
17:18:11 <zzo38> dncr:   instance Ord Surreal where { x@(Surreal l _) <= y@(Surreal _ r) = null (filter (y <=) l) && null (filter (<= x) r); };
17:18:17 <zzo38> That is the entirety of it.
17:18:42 <ddarius> dncr: It's not just a prefixer, but it hasn't really been changed in like the last several years, so I doubt much is going to change now.
17:19:10 <dncr> lambdabot is easier to change than ever
17:19:19 <ddarius> dncr: I await your updates.
17:19:20 <dncr> it used to be terrible, let me tell you
17:19:35 <kqr> if i have something along the lines of `do {r <- randomIO; return $ x * r}`
17:19:43 <kqr> how can i write that without do notation?
17:19:51 <kqr> or is it a stupid idea?
17:19:52 <zzo38> kqr:   (x *) <$> randomIO
17:19:54 <ddarius> fmap (X *) randoIO
17:19:55 <dobblego> randomIO >>= \r -> return $ x * r
17:19:55 <ddarius> +m
17:19:57 <mizu_no_oto> does anyone know why a call to Control.Lens's makeLenses would fail with "Parse error: naked expression at top level"?
17:19:57 <startling> (x *) <$> randomIO
17:19:58 <jmcarthur> @undo do {r <- randomIO; return $ x * r}
17:19:58 <lambdabot> randomIO >>= \ r -> return $ x * r
17:19:59 <startling> oops
17:20:16 <startling> mizu_no_oto: forgot {-# Language TemplateHaskell #-}
17:20:20 <jmcarthur> @. @pl @undo do {r <- randomIO; return $ x * r}
17:20:21 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
17:20:25 <kqr> <$> looks clever
17:20:25 <jmcarthur> @. pl undo do {r <- randomIO; return $ x * r}
17:20:25 <lambdabot> (x *) `fmap` randomIO
17:20:33 <ddarius> @src (<$>)
17:20:33 <lambdabot> f <$> a = fmap f a
17:20:34 <startling> kqr: it's just fmap
17:20:37 <kqr> is <$> the same thing as fmap?
17:20:40 <startling> yes
17:20:43 <kqr> yeah looks like it
17:20:43 <monochrom> yeah <$> is very nice
17:20:49 <zzo38> kqr: Yes; it is exported from Control.Applicative
17:21:26 <mizu_no_oto> startling: thanks
17:21:49 <kqr> you all answered so fast so i don't know who to thank
17:21:51 <kqr> but thank you all
17:22:08 <kqr> i really need to look into some of the more advanced monad/applicative/functor/whatever-it-is features soon
17:22:29 <dzhus89> can I instruct cabal to install some non-Haskell files (say, a README) from distribution along with the package?
17:22:48 * BMeph thought <$> was imported from Data.Functor... ;þ
17:23:13 <zzo38> dncr: Can you understand by now, what is wrong with this program? I posted the entire program already.
17:23:13 <jmcarthur> i bet i'm one of the only people that really likes num instances for pretty much everything that has an applicative instance, but if there was a num instance for IO then that code could be written:  pure x * randomIO
17:23:16 <dncr> zzo38: well, you can't compare a Surreal to an Int.
17:23:26 <jmcarthur> and if x was a literal or already in IO then you could just write:  x * randomIO
17:23:27 <dncr> if data Surreal = Surreal [Int] [Int] deriving (Eq)
17:23:27 <monochrom> yes, there is some "other-files" stanza
17:23:30 <zzo38> dncr: I am not trying to compare a Surreal to an Int!
17:23:52 <zzo38> dncr: It isn't written like that! I have:   data Surreal = Surreal [Surreal] [Surreal] deriving (Show)
17:23:56 <dncr> oh
17:24:10 <zzo38> O, and also this:   instance Eq Surreal where { x == y = x <= y && y <= x; };
17:24:12 <dncr> zzo38: did you post that earlier?
17:24:20 <dncr> ok
17:24:33 <zzo38> I forgot, but now I have everything, other than imports.
17:24:56 <zzo38> It does compile; but it doesn't work.
17:25:40 <monochrom> that depends on how you wrote your Ord instance
17:26:03 <zzo38> I already posted the Ord instance
17:26:48 <juliohm> Good night everyone, have to go now...
17:27:00 <dncr> zzo38: why don't you post all the code at once with an example of it not doing what you want it to
17:27:15 <dncr> zzo38: http://hpaste.org/
17:28:51 * BMeph feels sad for juliohm, and hopes he returns, if only for the comedy value of the dialogues....
17:29:20 <zzo38> http://hpaste.org/74504
17:30:15 <ddarius> I don't understand why some need to have an "official" version of everything.
17:30:33 <hnsz> sun java
17:31:19 <monochrom> I think I understand why. but it's irrelevant. some people want official, some people reject official. the two kinds must part their ways.
17:31:26 <jmcarthur> official things seem more important
17:31:38 <ddarius> monochrom: I understand the benefits, what I don't understand is why they can't see the costs.
17:31:41 <Jafet> Oracle Delphi
17:32:25 <ddarius> jmcarthur: Yes, which encourages their use even if they aren't good and discourages looking at other implementations.  It also usually requires making a decision with too little information or without context.
17:32:25 <jmcarthur> they probably just think the costs are insignificant next to the benefits. priorities and all that. maybe they even think the costs are so insignificant that they have forgotten what the costs are
17:32:50 <jmcarthur> i have no intention of defending that point of view
17:34:32 <ddarius> Admittedly, juliohm was even more extreme than that.
17:34:47 <hpaste> dancor annotated “ ” with “  (annotation)” at http://hpaste.org/74504#a74505
17:35:34 <Cale> Standardisation is often the bane of progress
17:37:11 <Cale> You absolutely can recursively define Eq and Ord in terms of each other, or at least, you are allowed to.
17:37:36 <Cale> (in general(
17:37:37 <Cale> )
17:38:02 <Cale> lol semicolons :)
17:38:25 <dncr> Cale: ah i had to guess what problem zzo38 was having since there is no error report in there
17:38:31 <Jafet> Tanenbaum loves standards
17:39:04 <BMeph> Jafet: The Christmas song? Wha...?
17:39:17 <ddarius> I have a solution.  For various areas of libraries, e.g. array libraries, web frameworks, IO streaming libraries, etc.  Let's set up a weekly "rotating" "official" library.  So, say, the "official" web framework for the week will be Happstack, then move on to Yesod, then let's add some variety by including salvia so people know there's in more than the three most popular ones.
17:40:08 <mapreduce> Haskell Platform, Soup of the Day edition
17:40:13 <Cale> zzo38's code is fine, if a little weirdly formatted
17:40:38 <Cale> ddarius: :D
17:41:26 <BMeph> ddarius: I like that. As I recall, this lust for Officiality, is why almost no one develops any other compilers besides GHC, except for research purposes.
17:41:48 <monochrom> I like the rotating answer to "which webapp framework?"
17:41:57 * ddarius wonders if hlint will correct it's suggestion not (any (y <=) xs) to "Use all: not (any (y <=) xs) ~> all (y >) xs"
17:41:58 <jmcarthur> haha
17:42:22 <Cale> Or collect lists of various types of library, and have a listing of the official packages which nondeterministically picks them every time the page is refreshed
17:42:49 <monochrom> now add laziness, i.e., no need to set up the rotating scheme until a question arises
17:42:55 <jmcarthur> i like the idea of it rotating every week. that way if you just hit refresh you see the same things. makes it more "official"
17:43:02 <Jafet> Someone better send dcoutts a memo first
17:43:06 <jmcarthur> or maybe there should be a cookie
17:43:10 <jmcarthur> (if this is a web page)
17:43:16 <Cale> ahaha, a cookie :)
17:43:43 <Cale> So you get people arguing over what the standards are, and pointing each other at the same page
17:43:48 <jmcarthur> ha
17:43:48 <BMeph> I wish we had thought of a rotating "official" compiler, before GHC was picked, in what almost seems a fit of frustrated pique over the outcry for "just ONE, damnit, this 'choice' thing you talk about Scares us!"
17:43:51 <monochrom> an alternative method: use your IP address to decide which official answer you get
17:43:57 <mapreduce> Or like xkcd's special comic, you get a different web framework if your IP address is an odd num.. damn you, monochrom.
17:44:10 <jmcarthur> we all thought of it, i'm sure
17:44:15 * BMeph takes a deep, cleansing breath, and leaps off of the soap box!
17:44:22 <ddarius> monochrom: We want the ability for #haskell to know what the official choice of the day/week is.
17:44:39 <jmcarthur> maybe it should just be a lambdabot thing
17:44:53 <ddarius> Though we could probably adapt to whatever the person said they saw.
17:44:55 <jmcarthur> @official web framework
17:44:55 <lambdabot> Unknown command, try @list
17:46:01 <jmcarthur> it could differ by nick
17:46:46 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/82614/
17:47:44 <Jafet> The official Haskell web framework is HVictory. Please erase all haskell-ml posts that have falsely indicated otherwise.
17:48:07 <dncr> i want SPJ to blog about his faves each week
17:48:17 <ddarius> dncr: Simon doesn't use Haskell.
17:48:29 <dncr> oh right because it's too theoretical
17:48:43 <ddarius> Simon Marlow particularly doesn't use Haskell, SPJ at least writes the compiler in Haskell.
17:48:46 <jmcarthur> haha, made up recommendations sounds nice. we could just say that in the interest of avoiding success at all costs they have no actual presence on the internet.
17:49:22 <dncr> doesn't he (He?) also regret making it lazy
17:49:26 <T_S_> best logging library in hackage is…?
17:49:38 <ddarius> dncr: Not really, no.  In fact, that would have completely defeated the point.
17:49:49 <dncr> it would have at the time yes
17:49:49 <ddarius> Seriously?!
17:50:05 <monochrom> "mtl" is the best logging library of the week
17:50:05 <ddarius> jmcarthur: Where's that lambdabot plugin?
17:50:13 <dncr> but nowadays typeclasses alone are like the coolest thing
17:50:17 <jmcarthur> which one?
17:50:22 <jmcarthur> the official one?
17:50:25 <ddarius> Yes.
17:50:53 <jmcarthur> we need to vote on a leader to design it
17:51:06 <ddarius> @official leader
17:51:06 <lambdabot> Unknown command, try @list
17:51:10 <ddarius> Curses.
17:51:44 <T_S_> mtl? I was expecting hslogger or something I had not heard about yet?
17:51:57 <dncr> if i was better at figuring out libraries it would actually be fun to rank them for the masses
17:52:13 <jmcarthur> T_S_: you are on the butt end of an inside joke
17:52:16 <dncr> dnet.com
17:52:24 <ddarius> dncr: Unfortunately, the problem space is multidimensional.
17:52:34 <T_S_> Ok that's fine.
17:52:39 <dncr> ah but the masses are quite 1D
17:52:50 <jmcarthur> i was thinking of recommending HVictory, but that would have been mean of me
17:52:51 <monochrom> hslogger actually exists
17:53:46 <monochrom> but mtl has Control.Monad.Writer which is a kind of logger, too
17:54:41 <jmcarthur> hslogger is the only one i can name off the top of my head, which might mean something
17:54:50 <T_S_> logging is the prototypical use case for Writer, true.
17:55:24 <dzhus> Writer is more like accident data recorder
17:55:43 <ddarius> hslogger is not in the Logging category on Hackage.
17:55:47 * BMeph notices how monochrom seems to unconsciously embody the principle of "technically, the glass is always full"... ;)
17:55:48 <monochrom> the joke part is not "mtl". the joke part is "of the week"
17:56:23 <T_S_> hslogger might be the winner. The docs say it is based on a python library I used once. points for python nostalgia.
17:57:04 <monochrom> no, the real principle I embody, consciously and unconciously, is liberty in wildly interpreting an open-ended question
17:57:45 <maukd> ah, a professional ambiguator
17:58:04 <monochrom> no, professional disambiguator
17:58:09 <T_S_> monochrome for President then
17:58:29 <ddarius> Who's monochrome?
17:58:47 <maukd> president of the week
17:58:55 <monochrom> haha
17:59:17 <T_S_> apologies bad spelling of monochrom
18:01:10 * hackagebot hbeanstalk 0.2.4 - Client for the beanstalkd workqueue service.  http://hackage.haskell.org/package/hbeanstalk-0.2.4 (GregHeartsfield)
18:01:44 * ddarius considers maybe, possibly actually watching a movie.
18:03:00 <ddarius> Alternatively, I may make my own binding to LAPACK to escape GPL tyranny.
18:03:55 <Cale> Speaking of president of the week, a while back I was thinking about a political system where every proposed piece of legislation is a referendum, but where anyone can defer their votes on things to anyone else, and can change that assignment at any point in time and/or decide not to defer their vote on any given issue.
18:04:30 <dncr> won't it be too poplulist, like California
18:05:02 <Cale> What about California?
18:06:03 <monochrom> we don't know yet. the defer option is interesting. most people may defer to experts or representatives. or maybe not. we don't have data to know which way.
18:06:21 <dncr> a lot of referrenda, ppl pass anything mentioning kittens, state goes bankrupt
18:06:27 <Cale> lol
18:06:38 <ddarius> Just put kittens into all the referenda.
18:06:42 <Cale> KITTENS
18:07:09 <dncr> ppl always choose kittens-now over kittens-later
18:07:30 <Cale> Bill N2128 to Make Nyancat the official flag, on every other Wednesday.
18:07:38 <shachaf> Did someone say kittens?
18:07:41 * shachaf likes kittens.
18:08:16 <Cale> (Upvotes to the left)
18:08:30 <shachaf> Cale++ # kittens
18:08:41 <T_S_> hslogger gets my vote...for now.
18:09:08 <shachaf> That's the best slogger.
18:09:48 <T_S_> thx shachaf. u tried it?
18:09:50 <startling> wait til I come out with islogger
18:10:04 <shachaf> T_S_: I don't know what it is.
18:18:42 <kqr> i'm trying to create an array from a list (i need the O(1) lookup times), so i thought `let xs = [1, 2, 3, 4, 5] :: Int; listArray (1,5) xs` would be good. instead, it just tells me there's no instance for (IArray a Int). am i doing something wrong?
18:19:55 <simon> kqr, [1..5] :: Int is certainly never true.
18:20:01 <kqr> oh, i meant [Int]
18:20:44 <ddarius> kqr: It's probably having trouble picking a specific instance.
18:21:04 <ddarius> It doesn't know what index type you want and can't resolve it and it also doesn't know what actual array type you want.
18:21:46 <kqr> ddarius, i'm confused because the way i'm trying to use the function is how i've seen it used just about everywhere else
18:22:22 <maukd> different function
18:22:46 <dncr> does syb let me go from (Foo {foo1 :: Bar, foo2 :: Baz}) to [("foo1", "Bar"), ("foo2", "Baz")]?
18:23:20 <dncr> i know i can get to "Foo", but not sure about getting a list of the parts..
18:23:30 <ddarius> You could do that.
18:23:49 <ddarius> > toConstr Product
18:23:50 <lambdabot>   No instance for (Data.Data.Data (Data.Monoid.Product a))
18:23:50 <lambdabot>    arising from a ...
18:24:09 <ddarius> :t toConstr
18:24:11 <lambdabot> forall a. (Data a) => a -> Constr
18:25:00 <Nereid> kqr: you need to be specific about the array type
18:26:08 <Nereid> so something like uh
18:26:21 <dncr> ddarius: but show on Constr just says "Foo"
18:26:23 <Nereid> array :: Array Int Int; array = listArray (1,5) xs
18:26:31 <kqr> Nereid, oh, okay
18:26:34 <Nereid> I think.
18:26:56 <kqr> Nereid, yeah you're absolutely right
18:27:11 <kqr> Nereid, i was thinking it could figure that out from the arguments, but how wrong i was
18:27:16 <kqr> Nereid, thanks a bunch anyway
18:27:28 <Nereid> kqr: to be clear, you needed to specify the Array part.
18:27:39 <kqr> yeah, i managed to get it working :)
18:29:55 * ddarius needs a record type that is an instance of Data that is loaded in lambdabot.
18:30:12 <ddarius> > toConstr (ZipList [])
18:30:13 <lambdabot>   No instance for (Data.Data.Data (Control.Applicative.ZipList a))
18:30:13 <lambdabot>    arising...
18:30:29 <dolio> ddarius: Tree?
18:30:39 <maukd> :t Node
18:30:40 <lambdabot> forall a. a -> Forest a -> Tree a
18:30:49 <maukd> > toConstr (Node () [])
18:30:50 <lambdabot>   Node
18:31:05 <ddarius> > constrFields $ toConstr (Node () [])
18:31:07 <lambdabot>   ["rootLabel","subForest"]
18:31:12 <dncr> ooh
18:31:43 <ddarius> > gshow (Node () [])
18:31:44 <lambdabot>   "(Node (()) ([]))"
18:32:07 <ddarius> > constrFields $ toConstr Nothing
18:32:09 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:32:09 <lambdabot>    `Data.Data.Data a'
18:32:09 <lambdabot>      a...
18:32:14 <ddarius> > constrFields $ toConstr (Just ())
18:32:15 <lambdabot>   []
18:34:28 <dncr> so i can get "Foo" and "foo1"/"foo2".  but how do you get "Bar"/"Baz"?
18:35:00 <dncr> it's like i want (everywhere) but to only go one level deep
18:35:39 <dncr> ah gmapT
18:39:06 <dncr> hm i guess i have to fold since i'm changing type
18:39:36 <maukd> > constrType $ toConstr (Node () [])
18:39:37 <lambdabot>   DataType {tycon = "Data.Tree.Tree", datarep = AlgRep [Node]}
18:39:40 <tylerkahn> can anyone who has ghcmod-vim installed help me? I'm getting this error: http://i.imgur.com/1NzCm.png
18:41:26 <gertc> i want to imoprt everything except Value from import Data.Aeson?
18:42:45 <Clint> do you?
18:43:03 <Nereid> import Data.Aeson hiding (Value) ?
18:43:12 <gertc> thx
18:46:14 <maukd> > gmapQ gshow (Node () [])
18:46:15 <lambdabot>   ["(())","([])"]
18:46:32 <maukd> > gmapQ typeOf (Node () [])
18:46:33 <lambdabot>   [(),[Tree ()]]
18:48:02 <maukd> > liftA2 zip (constrFields . toConstr) (gmapQ typeOf) (Node () [])
18:48:04 <lambdabot>   [("rootLabel",()),("subForest",[Tree ()])]
18:48:48 <maukd> > liftA2 zip (constrFields . toConstr) (gmapQ (show . typeOf)) (Node () [])
18:48:49 <lambdabot>   [("rootLabel","()"),("subForest","[Tree ()]")]
19:01:10 <dmwit> Can anybody explain how the behavior in this paste is possible?
19:01:13 <dmwit> http://hpaste.org/74506
19:01:37 <dmwit> (Context: trying to get this machine up to building the Haskell X11 bindings, and tracking down why "./configure" says the C compiler can't produce executables.)
19:01:46 * edwardk waves hello.
19:01:52 * dmwit waves back
19:05:27 <dncr> gmapQ is pretty cool
19:10:44 <rwbarton> relative path in LD_LIBRARY_PATH or something?
19:11:03 <dmwit> echo $LD_LIBRARY_PATH says /opt/LogicBlox-3.9.0.e206164b9085/bin:/home/dmwit/links/lib:/opt/LogicBlox-3.9.0.e206164b9085/bin:/home/dmwit/links/lib:
19:11:37 <rwbarton> there's also a file
19:11:48 <dmwit> ah, where?
19:11:56 <rwbarton> /etc/ld.so.conf
19:12:10 <rwbarton> /etc/ld.so.conf.d if your distro is like mine
19:12:40 <rwbarton> but i am not sure whether this is for ld or for the runtime linker
19:12:45 <rwbarton> the name suggests the latter
19:12:47 <dmwit> Yeah, ld.so.conf includes all the files in ld.so.conf.d, but all of those contain only absolute paths as far as I can tell.
19:13:20 <rwbarton> how about "set | grep lib64"
19:13:24 <rwbarton> s/set/env/
19:13:57 <rwbarton> does ~/inst/lib64/libc.so exist?
19:14:14 <dmwit> http://hpaste.org/74506
19:14:34 <dmwit> ...yes, ~/inst/lib64/libc.so exists.
19:14:37 <dmwit> (what?)
19:14:40 <rwbarton> what about ~/lib64/libc.so
19:14:50 <dmwit> ~/lib64 does not exist.
19:15:17 <dmwit> I agree that having ~/inst/lib64 is weird, and will remove it shortly. But I'm still a bit baffled about how it matters.
19:15:30 <rwbarton> me too
19:16:11 <rwbarton> you could, uh, strace gcc test.c and search for where it accesses the file ./../lib64/libc.so
19:16:20 <rwbarton> and see whether there is anything obvious before that
19:16:34 <rwbarton> like if it is reading "./../lib64" from a file
19:17:14 <rwbarton> hard to guess what here might be hardcoded though
19:17:44 <dmwit> Okay, removing ~/inst/lib64 (there were also lib, etc, var, and usr directories that I got rid of) fixes it.
19:17:50 <dmwit> Let's put a bit of them back and see what strace says.
19:22:43 <dmwit> strange
19:22:52 <dmwit> Well, I don't know why, but it's definitely looking in ./../lib64
19:29:16 <meiji11> is there a good alternative to haskell-mode?
19:31:50 <johnw> is haskell-mode giving you troubles?
19:32:29 <meiji11> yes, the auto-indenting is frustrating.
19:32:41 <johnw> it has 3 different indentation modes within it
19:32:47 <johnw> have you tried the other two?
19:32:50 <meiji11> I didn't know that, how can I toggle between them?
19:32:51 <meiji11> nope.
19:32:58 <johnw> M-x turn-on-haskell-indent
19:32:59 <johnw> M-x turn-on-haskell-indentation
19:33:02 <johnw> M-x turn-on-haskell-simple-indent
19:33:46 <meiji11> thanks, i'll play with those
19:36:13 <structuralist> Is every algebra for a monad a catamorphism?
19:38:47 <Nereid> structuralist: what do you mean by "is"?
19:39:09 <copumpkin> structuralist: initial ones _have_ catamorphisms?
19:39:17 <rwbarton> well an algebra for a monad is an object (plus some extra stuff) while a catamorphism is a morphism
19:40:24 <structuralist> Is a function m a -> a that satisfies all the diagrams equal to a catamorphism… like is it compositional
19:40:28 <Nereid> there will be a (unique) catamorphism for each algebra, so they are in 1-1 correspondence, but
19:40:42 <rwbarton> a catamorphism for what
19:40:54 <rwbarton> Mu m?
19:41:25 <rwbarton> catamorphism is just an algebra morphism out of an initial algebra, where is the initial algebra
19:41:55 <structuralist> m a is a recursive type, so it's the fixed point of some base functor
19:42:05 <dmwit> m a is not necessarily a recursive type.
19:42:12 <structuralist> let's say it is
19:42:16 <structuralist> like [a]
19:42:18 <rwbarton> okay, rereading :P
19:42:59 <dmwit> [a] may be one of the only commonly-used monads that is a recursive type, so you should just keep in mind that your assumption is a strong one.
19:43:34 <Nereid> why a monad? why not any functor?
19:44:42 <structuralist> I'm just wondering about the correspondence between algebraic theories (given by monads) and denotational semantics for embedded languages (given by catamorphisms)
19:45:54 <structuralist> dmwit: sorry I'm speaking loosely since I'm not sure of the exact definition of a recursive type, I'm thinking of ones built out of sums and products; are functions the problem?
19:46:10 <dmwit> sums and products are not recursive
19:46:23 <dmwit> recursion is recursive =)
19:46:42 <rwbarton> well of course X = Mu (Const X)
19:46:44 <dmwit> e.g. data Identity a = Identity a -- is a perfectly good non-recursive monad
19:46:54 <dmwit> Okay, that's true.
19:46:57 <structuralist> sure, but I think of that as trivially recursive
19:47:02 <rwbarton> but that somehow seems not to be in the spirit of the thing
19:47:09 <Nereid> guys.
19:47:35 <Nereid> there's no reason to exclude the non-nonrecursive ones.
19:47:39 <Nereid> er, the nonrecursive ones.
19:48:14 <Nereid> well whateverf.
19:48:15 <dmwit> Right, that's what rwbarton's comment about Const is getting at.
19:48:46 <meiji11> hoogle says only certain types e are supported in the declaration "data STUArray s i e". which ones are they? are they captured in a typeclass or something?
19:49:17 <rwbarton> so what exactly does it mean to say "f : [a] -> a is a catamorphism"
19:49:19 <Nereid> meiji11: the ones that satisfy the MArray instance
19:49:20 <dmwit> They are captured in the MArray typeclass.
19:49:25 <Nereid> er class
19:49:30 <Nereid> have a MArray instance.
19:50:09 <structuralist> I think I have a sketch of a proof that they are but I'm a category theory newbie so I'm not sure how to finish it
19:50:32 <rwbarton> I should first pick a (1 + a x -)-algebra structure on a, i.e. z : a and op : a -> a -> a
19:50:34 <meiji11> that makes the compiler errors I'm getting make a bit more sense.
19:51:26 <structuralist> rwbarton: there exists an algebra phi such that f = cata phi
19:51:36 <copumpkin> I hope f :: [a] -> a isn't a catamorphism
19:51:37 <rwbarton> if a is an algebra for the monad [] then it is a monoid and the structure map is [a] -> a, so that's stronger but in particular the conclusion does hold
19:51:47 <rwbarton> that is your motivating example I guess?
19:51:48 <johnw> I was asking a few days ago if there's a tracking program for Haskell.  Found one: http://www.cs.york.ac.uk/fp/ART/
19:51:54 <johnw> s/tracking/tracing
19:51:58 <structuralist> copumpkin: ?
19:52:12 <Nereid> structuralist: what's f in here?
19:52:13 <copumpkin> that type is inherently a lie!
19:52:25 <rwbarton> I think copumpkin is doing the "haha I'm intentionally misreading your quantifiers" joke
19:52:29 <structuralist> Nereid: "so what exactly does it mean to say "f : [a] -> a is a catamorphism""
19:52:46 <copumpkin> rwbarton: nope, I actually thought that's what people were talking about
19:52:49 <Nereid> catamorphism = morphism from the initial algebra
19:52:53 <Nereid> where is your initial algebra?
19:53:13 <structuralist> rwbarton: yes, thinking of monoids
19:53:15 <Nereid> and what functor are we talking about, anyway?
19:53:22 <rwbarton> [a] is the initial (1 + a x -)-algebra
19:53:41 <rwbarton> or in haskell data ListF a x = Nil | Cons a x
19:53:48 <structuralist> Nereid: what rwbarton said
19:54:12 <Boney> :q
19:54:25 <Nereid> yes, and a is not a (1 + a x -)-algebra
19:54:38 <rwbarton> right, the question only really makes sense once you pick such an algebra structure on a
19:54:45 <structuralist> Nereid: so there are two functors: List _ and ListF a _
19:54:47 <rwbarton> or you can say, does there exist an algebra structure on a such that ...
19:54:57 <Nereid> for arbitrary a, there doesn't.
19:55:35 <Nereid> like when a = Void.
19:55:46 <rwbarton> this is like we are talking about the graph of the function y = x^2 and everyone is like "BUT WHAT IF y IS 5 AND x IS 3"
19:56:19 <startling> rwbarton: hehe
19:56:55 <monochrom> but what if y is negative and x is real
19:57:41 <meiji11> so, in a type signature, how I can I ensure that a type a can occupy type e in "data STUArray a i e"?
19:57:44 <rwbarton> structuralist: anyways, what in general will be the monad structure on m = mu f? doesn't it seem like it would be important?
19:58:08 <Nereid> in general there is no monad structure
19:58:11 <rwbarton> or m a = mu f_a rather
19:58:30 <Nereid> like when f = Const Void
19:58:38 <rwbarton> right
19:58:51 <rwbarton> or there might be several
19:59:01 <dmwit> meiji11: Something like (MArray (STUArray a i) e) =>
19:59:16 <rwbarton> it doesn't seem too likely that your original question could hold for all of them
19:59:33 <dmwit> meiji11: sorry
19:59:56 <dmwit> meiji11: MArray (STUArray s) e (ST s) =>
20:00:28 <meiji11> dmwit: I think I tried that a moment ago, but I'll try again.. mine was a little different.
20:01:09 <meiji11> non type-variable argument .. ?
20:01:12 <structuralist> Nereid, rwbarton: I'll try restating more clearly. Suppose (T, eta, mu) is a monad. Does h : T X -> X being an algebra for (T, eta, mu) imply that there exists an algebra h' : TXF X -> X such that h = cata h', where TXF is the base functor for the type T X ?
20:02:01 <dmwit> meiji11: -XFlexibleContexts, or {-# LANGUAGE FlexibleContexts #-}, just like the error tells you to do
20:02:14 <meiji11> right, yeah. I was just deciphering that, heh.
20:02:17 <Nereid> structuralist: what does "base functor" mean?
20:02:40 <structuralist> Nereid: T X is the (least? I think) fixed point of TXF
20:02:58 <Nereid> that sounds wrong
20:02:58 <monochrom> "STUArray s" and "ST s" are the non-type-variable arguments referred to
20:03:05 <meiji11> is the {-# .. notation the equivalent of a pragma declaration in C or something?
20:03:06 <structuralist> T X is isomorphic to TXF (TXF (TXF (TXF … )))
20:03:13 <rwbarton> can't I still obstinately pick TXF = const (T X)
20:03:17 <Nereid> ^
20:03:18 <rwbarton> oh
20:03:23 <rwbarton> that isn't actually a problem is it
20:03:34 <rwbarton> as then h' = h
20:03:40 <rwbarton> hmm
20:04:01 <Nereid> I should probably pull out some paper so I can get this notation straight.
20:04:25 <rwbarton> the reason it sounds weird to me is I can rephrase it like this
20:06:07 <rwbarton> suppose F_X is a functor depending on X (a bifunctor I suppose) and I write T X = mu F_X
20:06:41 <Nereid> saying h : T X -> X, h = cata h' seems to imply that T X is the initial TXF-algebra. ??
20:06:41 <rwbarton> and now suppose h : T X -> X is a morphism; that's clearly not enough for h to be of the form h = cata h'
20:07:05 <rwbarton> but if h is an algebra for *any* monad structure on T then suddenly, it is?
20:07:21 <rwbarton> Nereid: < structuralist> Nereid: T X is the (least? I think) fixed point of TXF
20:07:38 <Nereid> I saw that.
20:07:45 <monochrom> something else tells you that mu F_X is an initial algebra
20:07:47 <Nereid> but I'm just saying.
20:08:20 <Nereid> if h : A -> X is cata h' for some F-algebra h', then by definition, A is the initial F-algebra.
20:08:34 <structuralist> So the particular h' I have in mind is "h . iso . TXF join". where iso is the isomorphism between TXF (T X) and T X.
20:08:52 <structuralist> join = mu
20:09:01 <Nereid> and T X being a TXF-algebra means we have some TXF (T X) -> T X.
20:09:09 <Nereid> which we do have.
20:09:12 <Nereid> so, ???
20:10:17 <structuralist> sorry, "TXF join" should be "fmap join" in pseudoHaskell
20:10:35 <rwbarton> structuralist: so TXF T T X -> TXF T X -> T X -> X?
20:11:04 <structuralist> agh
20:11:05 <structuralist> no
20:11:07 <rwbarton> unit?
20:11:10 <structuralist> unit yes
20:11:33 <structuralist> h . iso . fmap unit
20:11:52 <edwardk> trying to figure out how to get embedding/projection pairs to work for lens. ideally you could use the embedding directly for ^. to embed, and then turn it around to use it as a traversal when you project
20:12:19 <dmwit> meiji11: Yes, it is a Haskell pragma.
20:12:28 <edwardk> but its not obvious to me how to properly encode it in the lens style
20:14:05 <rwbarton> structuralist: so presumably the only thing about T you are using is the unit X -> T X with X -> T X -> X = id?
20:14:17 <meiji11> dmwit: i see, thanks.
20:14:18 <Nereid> well
20:14:20 <Nereid> what you *need*
20:14:37 <Nereid> is that h . iso = h' . fmap h
20:14:53 <rwbarton> hmm
20:15:12 <structuralist> rwbarton: well I use join in the not-quite-proof
20:15:19 <rwbarton> hmm okay
20:15:29 <structuralist> I'll try to upload a picture of the diagram, 1 min
20:16:39 <Nereid> it's trivially true if TXF = Const (T X), yes
20:16:57 <Nereid> because then h' = h
20:18:28 <Nereid> ok, slightly less trivial example:
20:18:54 <Nereid> X is a monoid, TXF a = 1 + (X,a), so T a = [a].
20:18:55 <structuralist> Nereid: my motivating example was monoids
20:19:03 <Nereid> and h = mconcat :: [X] -> X
20:19:31 <Nereid> then there's an obvious thing 1 + (X,X) = TXF X -> X
20:19:42 <Nereid> given by (mempty,mappend)
20:21:04 <rwbarton> right and h being that catamorphism means h [] = mempty and h (x:xs) = x `mappend` h xs
20:21:19 <Nereid> which is clearly true
20:21:41 <rwbarton> suppose I didn't know mconcat was associative and unital, what exact conditions would I need to get mempty and mappend for which that is true
20:21:48 <rwbarton> well I would set mempty = h []
20:24:21 <rwbarton> h (x:xs) = h (join [return x,xs]) = h (map h [return x, xs]) = h [x, h xs] so set mappend a b = h [a, b]
20:24:28 <rwbarton> so somehow the general proof should look "like that"
20:24:33 <Nereid> oh right we were talking about monads.
20:27:22 <rwbarton> I still don't see how I can generalize that first step to any other m though
20:27:23 <hpaste> rosie pasted “Testing the timing of lazy evaluation” at http://hpaste.org/74508
20:29:04 <rosie> I'm trying to test the runtime of lazy evaluation vs. strict evaluation. Could I have some help interpreting the results? I thought getting the last element in the computed fibonacci array would require that all elements in the array be computed, so it would have the same runtime as printing the whole array.
20:29:09 <johnw> Can anyone help me understand why 'parMap' is not being parallel in this code with -j16?
20:29:14 <hpaste> johnw pasted “Main.hs” at http://hpaste.org/74509
20:30:15 <structuralist> rwbarton: I'm LaTeXing, should take another 5 minutes or so
20:34:58 <rwbarton> id = join . iso . fmap return, is this the question?
20:35:06 <dmwit> rosie: The extra time is almost certainly spent in the additional rendering required to create the String containing the whole list rather than a single number.
20:36:14 <meiji11> still getting weird type errors relating to the MArray (STUArray s) a (ST s) constraint :/
20:36:16 <rwbarton> those being :: T X -> T X
20:36:19 <dmwit> I'm not sure what makes "notLazy" not lazy, though. It looks perfectly lazy to me.
20:36:33 <Nereid> you know
20:36:37 <rwbarton> wait no
20:36:43 <Nereid> yeah, h . iso . fmap return does it
20:37:00 <rwbarton> I need another iso in there somewhere
20:37:06 <Nereid> oops.
20:37:08 <Nereid> wrong way.
20:37:15 <Nereid> it doesn't.
20:37:42 <Nereid> (return is a *right* inverse of h, not left.)
20:37:52 <structuralist> rwbarton, Nereid: http://i.imgur.com/qbxV8.png
20:38:00 <structuralist> Not a proof but that's what I have so far
20:38:27 <dmwit> johnw: Does processHoos do IO?
20:38:30 <structuralist> I need that the left side is an isomorphism, and that the top square commutes
20:38:40 <dmwit> ...yes, I see it does.
20:38:52 <dmwit> johnw: Parallelism does not mean what you think it means.
20:39:01 <dmwit> For what you want, you'll need to use the concurrency primitives.
20:39:22 <johnw> ah, then what am I missing?
20:39:30 <johnw> the original version used MVars and it worked fine
20:39:46 <dmwit> Yes, you're computing the IO actions in parallel, but not executing them in parallel.
20:39:52 <johnw> ahh
20:39:59 <johnw> because sequence calls them in order?
20:40:00 <Cale> johnw: parMap is for parallel *evaluation* not parallel *execution*
20:40:11 <johnw> oh, wait
20:40:13 <johnw> I get it
20:40:25 <Cale> johnw: It'll evaluate *which* IO actions to run in parallel, perhaps
20:40:26 <johnw> I'm building up a sequence of IO actions in parallel that will be executed in series
20:40:28 <structuralist> (top square of the botton diagram)
20:40:31 <Cale> yes
20:40:33 <dmwit> johnw: exactly
20:40:34 <johnw> got it, thanks!
20:41:06 <Cale> johnw: A rule of thumb is that replacing map with parMap will never change the output of your program
20:41:38 <johnw> that really helps me understand the difference between concurrency and parallelism too
20:41:40 <Nereid> structuralist: no, it can't be right.
20:41:41 <dmwit> Why is cabal prompting me for a username? I have username: DanielWagner in ~/.cabal/config.
20:41:44 <Cale> yes :)
20:42:08 <structuralist> Nereid: aha why not?
20:42:18 <Nereid> structuralist: even look at it for the list monad
20:42:23 <dmwit> Oh, I have an old version of cabal-install, it seems.
20:42:25 <edwardk> dmwit: hackage-username:
20:42:35 <mm_freak> johnw: you should understand the difference between evaluation and execution…  parallelism is about evaluation, concurrency is about execution
20:42:44 <johnw> mm_freak: yeah
20:42:47 <johnw> understood
20:42:54 <Cale> Well...
20:43:07 <dmwit> edwardk: Oh, really? When did that change?
20:43:12 <dmwit> (thanks)
20:43:29 <edwardk> dunno. i've always used it that way that i can recall
20:43:38 <mm_freak> it's also noteworthy that evaluation is mostly a no-op for IO actions
20:43:48 <dmwit> I guess password: changed to hackage-password:, too?
20:43:56 <Cale> Parallelism is about doing things at the same time in order to get done faster
20:44:06 <structuralist> Nereid: sorry what part
20:44:26 <edwardk> yeah, i'm not sure what the username and password fields in ~/.cabal/config are for
20:44:38 <Nereid> structuralist: you are saying h' = h . iso . fmap return, right?
20:44:56 <structuralist> right...
20:45:02 <mm_freak> edwardk: they used to be for hackage uploads, but that stopped working long ago…  i remember someone saying that this is a bug, but apparently it never got fixed
20:45:08 <Nereid> so check the square
20:45:11 <structuralist> that's the right side
20:45:11 <Cale> Concurrency is about expressing computations in a way that gives up control over how separate processes interleave
20:45:16 <Nereid> h . iso . fmap return . fmap h = h . iso
20:45:42 <Cale> You can have concurrency without parallelism -- such as by switching between threads on a uniprocessor machine
20:45:45 <Nereid> wait.
20:45:55 <Nereid> let me think about it for a sec.
20:46:03 <mm_freak> even coroutines are a kind of concurrency
20:46:20 <Cale> and you can have parallelism without concurrency -- where the result of the program is deterministic because the order of evaluation didn't matter to begin with
20:46:32 <Cale> and you can have concurrency for the sake of parallelism as well
20:46:42 <johnw> so pure algorithms can be made parallel, but concurrency is itself a kind of side-effect?
20:46:47 <dmwit> ...but no parallelism for the sake of concurrency. =)
20:46:54 <Cale> right
20:47:12 <johnw> parallelism doesn't affect referential transparency
20:47:16 <Cale> johnw: Right, and concurrency introduces a kind of nondeterministic semantics.
20:47:16 <mm_freak> johnw: it's not a side effect by itself…  it becomes a side effect when the different threads start to communicate
20:47:36 <johnw> mm_freak: then concurrency induces side-effects?
20:47:42 <mm_freak> the spawning is a side effect
20:47:43 <Cale> johnw: where you can't be sure of which result your program will have anymore because it depends on the order in which things in separate threads occurs
20:47:47 <Cale> occur*
20:47:53 <Rotaerk> to me it seems that parallelism and concurrency are equivalent terms that have been artificially divorced from one another in order to have labels for distinct concepts
20:48:09 <Rotaerk> "concurrent" literally means "at the same time"
20:48:24 <Cale> Rotaerk: they're technical terms here
20:48:25 <Nereid> ok I guess it works there.
20:48:45 <structuralist> phew
20:48:48 <Nereid> lol
20:48:53 <mm_freak> Rotaerk: that's not true…  parallelism is semantically meaningless, while for concurrency you can even build a whole, semantically significant calculus (for example the π calculus)
20:49:12 <structuralist> how do I make banana brackets btw
20:49:29 <mm_freak> structuralist: you stick banana stickers onto your screen
20:49:39 <dmwit> (| and |)
20:49:44 <dmwit> Oh, you mean in TeX?
20:49:44 <Rotaerk> Cale, this wiki page should provide the technical definition, and it indicates it's "a property of systems in which several computations are executing simultaneously, and potentially interacting with each other" http://en.wikipedia.org/wiki/Concurrency_(computer_science)
20:49:48 <structuralist> dmwit: yeah
20:49:53 <dmwit> http://detexify.kirelabs.org/classify.html
20:50:04 <Cale> Rotaerk: yes, that's a reasonable definition
20:50:16 <rwbarton> I think it's probably \left(\!\left| or so
20:50:18 <meiji11> I can't get runST $ do { arr <- newListArray (beg,end) xs; return []} to compile. shouldn't it be fine with that added type constraint?
20:50:22 <mm_freak> (my daily rubbish, sorry)
20:50:26 <Cale> Rotaerk: Well...
20:50:30 <rwbarton> (\! is the negative space one right?)
20:50:31 <Rotaerk> mm_freak, the term parallelism suggests sequential independence, and that there is *potential* for concurrency
20:50:35 <Cale> Rotaerk: for some values of "at the same time"
20:50:40 <structuralist> nothing
20:50:48 <dmwit> detexify says \llparenthesis for me
20:50:59 <dmwit> Maybe you're bad at drawing. =)
20:50:59 <Nereid> yeah
20:51:03 <Nereid> stmaryrd is nice
20:51:06 <mm_freak> Rotaerk: concurrency has a specific technical meaning in this context, and parallelism does not introduce concurrency in that sense
20:51:08 <Cale> Rotaerk: they needn't literally be occurring at the same time, but the idea is that they will behave at least as if their steps are interleaved in some (nondeterministic) fashion
20:51:14 * hackagebot X11 1.6.0.1 - A binding to the X11 graphics library  http://hackage.haskell.org/package/X11-1.6.0.1 (DanielWagner)
20:51:39 <rwbarton> surely there must be a banana brackets paper somewhere on arxiv with source
20:51:58 <Cale> Introducing concurrency deserves a semantics which is nondeterministic. Introducing parallelism needn't.
20:52:01 <mm_freak> Rotaerk: see how concurrency in haskell is inherently IO-bound
20:52:30 <structuralist> no such thing as \llparenthesis ? the \! trick worked though
20:53:09 <Nereid> structuralist: well yeah, you need the stmaryrd package
20:53:33 <dmwit> \usepackage{stmaryrd}... what Nereid said
20:53:39 <structuralist> ah cool
20:53:40 <rwbarton> "obviously"
20:53:42 <rwbarton> :P
20:54:34 <Cale> This is kind of a poor explanation, but you can sort of imagine the difference by thinking of a fast food restaurant. Parallelism is about putting multiple workers behind the counter so that customers get served faster, even if they'll be served in the same order and way that they would with just one guy behind there. Concurrency is about putting in multiple queues, even if there's one guy dashing back and forth to ser
20:54:34 <Cale> ve the customers in different queues.
20:54:55 <dmwit> \tikz (0,0) -- +(0,1em) to[curve=right] +(0,-1em);
20:54:57 <Nereid> Cale: I like.
20:55:03 <dmwit> uh
20:55:09 <Cale> You can do both concurrency and parallelism, or one without the other.
20:55:15 <dmwit> I probably meant like 1.5ex instead of 1em.
20:55:25 <mm_freak> structuralist: in haskell there is a negative space character typeset by \!
20:55:32 <Nereid> in tex*
20:55:36 <mm_freak> uh
20:55:38 <mm_freak> in latex
20:55:41 <mm_freak> of course
20:55:58 <structuralist> btw, how do haskell papers typeset their code so nicely?
20:56:00 <Cale> The order in which the customers get served in the concurrent case becomes interleaved and might be different on different days.
20:56:06 <Nereid> structuralist: they use latex ;)
20:56:08 <Nereid> oh
20:56:10 <Nereid> the code?
20:56:17 <johnw> ooh, just found parallel-io on Hackage
20:56:22 <mm_freak> you can use that to produce your own ligatures, which has the benefit that when someone copies text from your document the text becomes "(|"
20:56:24 <johnw> although now I know it's poorly named ;)
20:56:32 <mm_freak> for example if you write (\!|
20:56:35 <structuralist> yeah, like proportionally spaced code with bold etc.
20:56:42 <structuralist> equal signs lining up
20:56:45 <structuralist> surely not by hand?
20:56:53 <johnw> it takes an [IO a] and executes the actions concurrently, sequencing the results to return IO [a]
20:56:58 <mm_freak> structuralist: i do it by hand
20:57:03 <structuralist> (I wish my text editor did that)
20:57:09 <Cale> Many web servers are concurrent but perhaps not parallel, in order to try to reduce the amount of time that anyone is left waiting for a connection.
20:57:25 <johnw> this library should be ConcurrentIO, yes?
20:57:28 <rwbarton> structuralist: I got a diagram that looks more or less like yours
20:57:37 <Nereid> structuralist: some sort of align thing would get you the lining up
20:57:51 <structuralist> rwbarton: proved commutative?
20:57:55 <rwbarton> no :)
20:57:59 <structuralist> :(
20:58:12 <structuralist> at least not proved non-commutative
20:58:17 <mm_freak> johnw: that action is easy to construct on your own…  create an MVar, fork n threads, take n times
20:58:39 <mm_freak> i think i have pasted such an implementation on hpaste…  let me look
20:58:45 <johnw> mm_freak: that's what I'm doing now, but I'm getting "thread blocked indefinitely in an MVar operation" and can't see why
20:59:05 <johnw> see https://github.com/jwiegley/rehoo/blob/master/Main.hs#L82
20:59:18 <mm_freak> johnw: http://hpaste.org/70436
20:59:22 <johnw> i'm not taking from any MVar twice...
21:00:13 <johnw> mm_freak: can you check over my code?
21:00:24 <johnw> i thought that what you pasted is basically what I'm doing
21:00:54 <mm_freak> johnw: i'm not familiar with some of the libraries you're using
21:01:18 <johnw> read the shelly $ ... stuff as invoking child processes
21:01:33 <johnw> I'm using MSem is restrict the number of concurrent child processes that can run at any time
21:01:46 <mm_freak> btw, parMapM is badly named…  your might call it parSequence
21:01:52 <johnw> MSem.with decrements the pool resource, runs the call, then puts it back
21:04:38 <johnw> mm_freak: if putMVars are paired with takeMVars, how can I get that error?
21:05:01 <johnw> (and there are no exceptions occurring that I know of; but I'll put in a print to check for that
21:06:14 * hackagebot cabal-rpm 0.6.2 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.6.2 (JensPetersen)
21:06:15 <mm_freak> johnw: can you express your whole interaction using only newMVar, readMVar and writeMVar?
21:06:54 <johnw> why would I need them?
21:07:02 <johnw> I only put each MVar once, and read from it once
21:07:05 <johnw> s/read/take
21:07:30 <mm_freak> oh well, can you express your whole interaction using only newMVar, modifyMVar and modifyMVar_?
21:07:47 <johnw> oh, that's an idea
21:09:00 <mm_freak> i'm asking because i see a newEmptyMVar there
21:09:14 <johnw> what does that make you think?
21:09:18 <johnw> that it's never being set?
21:09:25 <johnw> i'm putting in a catch now
21:09:29 <johnw> just to see if that's the issue
21:10:30 <mm_freak> i haven't read all your code, but notice that a combination of newEmptyMVar and modifyMVar cannot work
21:10:54 <mm_freak> that's why i'm asking whether you can express your entire code using only newMVar and modifyMVar (modifyMVar_ is just a special case)
21:11:20 <mm_freak> if yes, then the MVar is not the source of your problem
21:12:02 <mm_freak> additional note:  you may not nest modifyMVar operations
21:12:47 <johnw> ok
21:12:55 <johnw> none of these MVars should be nseted
21:13:31 <mm_freak> you can nest modifyMVar operations for different MVars
21:15:26 <johnw> oho
21:15:36 <johnw> there are exceptions being caught
21:15:43 <johnw> thanks for the help
21:15:55 <rwbarton> structuralist: oh I proved your diagram commutes
21:16:03 <structuralist> rwbarton: !!!!!
21:16:11 <rwbarton> insert the horizontal arrow F(h,Th)
21:16:14 <structuralist> I hope this irc channel is long enough to contain it
21:16:26 <rwbarton> hehe :)
21:16:56 <rwbarton> the middle square must just commute by definition of T/iso
21:17:20 <rwbarton> in general Tf : TX -> TY corresponding to F(f, Tf) : F(X,TX) -> F(Y,TY)
21:17:21 <rwbarton> right?
21:17:44 <structuralist> I think so
21:17:51 <rwbarton> what else could it be
21:17:53 <rwbarton> okay
21:18:00 <rwbarton> now the top square is all stuff in the image of F
21:18:23 <rwbarton> reading along the left and then bottom, we have (eta, eta) followed by (h, Th)
21:18:50 <rwbarton> reading along the top and then right, we have (id, h) followed by (id, eta)
21:19:09 <rwbarton> so we need h . eta = id, and Th . eta = eta . h
21:19:27 <rwbarton> and these are both true for some reason
21:19:35 <Nereid> h . eta = id by definition of a monad algebra
21:19:38 <rwbarton> right
21:19:56 <rwbarton> second is true by naturality of eta I think
21:20:01 <Nereid> yes
21:20:16 <rwbarton> so, the big rectangle commutes
21:20:18 <structuralist> woot
21:20:35 <rwbarton> *but* I don't know how to show the left-and-then-bottom of the big rectangle is the same as in the original square
21:20:46 <rwbarton> that is where join comes in, and it mystifies me
21:21:12 <structuralist> eta and mu canceling somehow
21:21:14 <structuralist> ...
21:22:20 <rwbarton> yes
21:22:34 <rwbarton> hmm
21:22:37 <Nereid> well
21:22:49 <rwbarton> you do have some etas and a mu
21:23:00 <Nereid> that follows if the isomorphisms T a ~= F(a, Ta) are natural
21:23:03 <Nereid> and
21:23:06 <Nereid> wait.
21:23:32 <rwbarton> it's tricky because mu is not T of anything
21:23:46 <rwbarton> and (eta, eta) is not of the form (f, T f)
21:23:48 <Nereid> I need more paper.
21:25:06 <Nereid> yes, it does work out.
21:25:13 <Nereid> because you look.
21:25:49 <Nereid> on the left
21:25:58 <Nereid> the top two arrows compose to
21:26:18 <Nereid> well that composite is the same as the composite F(X,TX) -~-> TX -(T eta_X)-> TTX
21:26:35 <Nereid> and then mu_X . T eta_X = id
21:26:38 <rwbarton> it's not, though
21:26:42 <Nereid> well
21:26:43 <Nereid> it should be!!
21:26:52 <rwbarton> going back to the list/monoid example
21:26:59 <rwbarton> (x,xs) :: F(X,TX)
21:27:06 <Nereid> I'm assuming the iso T a ~ F(a, Ta) is natural.
21:27:15 <rwbarton> goes to ([x],[xs]) :: F(TX,TTX)
21:27:31 <rwbarton> then [[x],xs] :: TTX
21:27:43 <rwbarton> then *magically* join [[x],xs] = (x:xs) and it all works out
21:27:50 <rwbarton> but why
21:28:10 <rwbarton> Nereid, T a ~ F(a, Ta) is natural means Tf corresponds to F(f, Tf)
21:28:13 <rwbarton> not F(f, f)
21:28:27 <Nereid> shit.
21:28:44 <rwbarton> your composite F(X,TX) -~-> TX -(T eta_X)-> TTX is (x,xs) to (x:xs) -> [x:xs]
21:28:48 <rwbarton> or no
21:28:55 <rwbarton> map return (x:xs)
21:29:03 <rwbarton> well whatever
21:29:06 <rwbarton> not [[x],xs]
21:29:21 <Nereid> well maybe it should be T eta_X, and not eta_TX?
21:29:27 <Nereid> on the top
21:29:46 <rwbarton> I needed (eta,eta) for the other square
21:30:09 <Nereid> remind me why the top square commutes
21:30:19 <rwbarton> plus if you do the h (x:xs) = h (join [return x,xs]) = ... logic that's what you are doing
21:31:06 <rwbarton> well the unshown arrow is F(h, Th) and h . eta = id . id and Th . eta = eta . h
21:31:41 <Nereid> right
21:31:52 <rwbarton> I mean, here is a question
21:31:53 <johnw> mm_freak: i solved it with parallel-io, which really simplified my code
21:32:02 <rwbarton> I tell you there is some monad structure on [] that has return x = [x]
21:32:11 <rwbarton> can you prove join [[x],xs] = x:xs
21:32:17 <johnw> if you have sequence $ traverse f, you can turn it into parallel $ map f
21:32:21 <rwbarton> looks hopeless to me...
21:32:28 <johnw> and that's really all there is to it
21:32:33 <Nereid> sure, it may as well be something else.
21:32:34 <Nereid> like xs ++ [x]
21:32:37 <structuralist> I think it boils down to eta being a unit: mu . eta_T(X) = id
21:32:38 <Nereid> er
21:32:44 <Nereid> no.
21:32:45 <Nereid> lol
21:33:25 <rwbarton> I don't really think there are any other possible monad structures [] with return x = [x] (that would be exciting) but how are you going to prove that just from the laws
21:33:26 <Nereid> structuralist: me too.
21:33:58 <rwbarton> join [] = [] you can prove I guess
21:34:23 <rwbarton> by parametricity?
21:34:53 <Nereid> I never figured out what parametricity can tell me.
21:35:14 <rwbarton> well this might be cheating a little but join [] :: forall a. [a]
21:35:20 <rwbarton> there aren't too many values of that type
21:35:27 <Nereid> that's cheating. :P
21:35:34 <Nereid> or is it
21:35:39 <rwbarton> yeah, but it might turn into some kind of naturality something
21:35:57 <Nereid> sure, it's true when a = Void
21:36:08 <mangoboy8> http://bitchinbeach.com/Forum/index.php?tid=16&title=She_Takes_a_Wild_Double_Anal
21:36:09 <Nereid> and then naturality + the fact that Void is initial ...
21:36:22 <rwbarton> right and for any a, ([] :: [[a]]) = fmap unique ([] :: [[Void]])
21:36:32 <rwbarton> so that one is fine
21:36:37 <structuralist> rwbarton: could you spell out exactly why the middle square commutes? I think it's the same reason the left side works
21:37:10 <Nereid> structuralist: because that isomorphism is natural
21:37:15 <rwbarton> well Nereid said it basically, T a ~ F(a, T a) should be natural, that means for f : X -> Y, Tf corresponds to F(f, Tf)
21:38:13 <mikeplus64> with OpenGL 2.5.0.0, Graphics.Rendering.OpenGL is supposed to export Graphics.Rendering.OpenGL.GL which is supposed to export Graphics.Rendering.OpenGL.Raw.Core31, but it doesn't seem to at all, anyone know what's up?
21:38:29 <rwbarton> so the square TX -> TY / F(X,TX) -> F(Y,TY) commutes if we fill in Tf and F(f,Tf) on top/bottom and the iso on the sides
21:38:31 <mm_freak> why is (>>=) left-associative?  i somehow find that it should be right-associative
21:38:50 <structuralist> okay then I think I know why the left side works
21:38:58 <mm_freak> just like (>=>)
21:38:59 <structuralist> maybe
21:39:02 <structuralist> hold on
21:39:18 <Nereid> mm_freak: well >=> is associative
21:39:19 <Nereid> :p
21:40:01 <Nereid> mikeplus64: ... .GL doesn't import all of ... .Raw.Core31
21:40:11 <mm_freak> Nereid: i'm asking from an operational viewpoint
21:40:12 <mikeplus64> Nereid: ah
21:41:01 <rwbarton> so in this case, join is itself a catamorphism
21:41:08 <rwbarton> perhaps you need this additional condition
21:41:40 <mikeplus64> Nereid: any idea where i'm supposed to import stuff like gl_COLOR_BUFFER_BIT, it seems a bit silly to have OpenGL (the haskell package) rename all these GL functions to then import .GL.Raw.Core31
21:42:24 <johnw> :t (>=>)
21:42:34 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
21:43:29 <Nereid> mikeplus64: because if you're using OpenGL they don't expect you to use the raw interface
21:43:43 <Nereid> mikeplus64: and instead use functions like clear
21:43:57 <mikeplus64> oh, right
21:44:25 <mikeplus64> i don't particularly like OpenGL's everything-is-a-state-var philosophy, i guess i'll just use OpenGLRaw
21:45:18 <Nereid> I'm looking at the definition of clear, and uh
21:45:20 <Nereid> is that a bug I see?
21:45:28 <Nereid> clear = glClear . sum . map marshalClearBuffer
21:45:38 <structuralist> I think it works if unit has an inverse… then F(eta_X, eta_TX) has an inverse F(unit^-1,mu_X)
21:45:54 <Nereid> what is unit?
21:46:01 <structuralist> eta
21:46:05 <Nereid> then say eta :p
21:46:06 <Nereid> well
21:46:07 <structuralist> sorry
21:46:11 <rwbarton> that isn't very likely surely :)
21:46:14 <Nereid> yeah
21:46:15 * hackagebot rehoo 0.2.0 - Rebuild default.hoo from many .hoo files in the current directory  http://hackage.haskell.org/package/rehoo-0.2.0 (JohnWiegley)
21:46:45 <structuralist> realizing now that my intuition for assembling that left side was that I could undo eta
21:46:54 <Nereid> anyway, about that definition of clear, it looks like things would go wrong if you wrote like
21:46:59 <Nereid> clear [ColorBuffer, ColorBuffer]
21:47:06 <mikeplus64> yeah
21:47:16 <Nereid> structuralist: you can undo eta with join ;)
21:47:19 <Nereid> er mu
21:47:21 <johnw> mm_freak: looks like I found a bug in hoogle combine
21:47:51 <structuralist> oh actually, wait
21:49:57 <meiji11> the forall quantifier doesn't mean at all what I thought it did, apparently.
21:49:59 <meiji11> so confusing.
21:51:28 <Cale> meiji11: in which context?
21:52:12 <meiji11> Cale: in a nutshell, I placed "forall a." in front of a type signature of a function. I assumed there was an implicit "forall a." present just by declaring a function over the type variable a.
21:52:41 <Nereid> rwbarton: fwiw, TTX -mu-> TX is always a T-algebra
21:52:50 <meiji11> with or without the quantifier, I would expect ghc to behave in precisely the same way.
21:52:54 <Cale> meiji11: that's basically true
21:53:04 <Cale> meiji11: *except* if you have ScopedTypeVariables
21:53:16 <rwbarton> right, the free T-algebra
21:53:27 <meiji11> which I do, I mindlessly included that because I'm following a blog post on a problem similar to mine, haha..
21:53:40 <Cale> in which case, the forall being explicit is required in order to make the scope of the type variable extend past the one signature
21:53:57 <rwbarton> so we know if this is true, mu is always a catamorphism...
21:54:19 <meiji11> I see, so if I use a type signature in the function body, using a as a type variable, it's expecting a possibly different a.
21:54:23 <meiji11> which is what ghc appears to be telling me.
21:54:35 <meiji11> a possibly different a in the body, I mean.
21:54:43 <meiji11> I happen to be quantifying something else in the body..
21:54:43 <rosie> history
21:54:55 <rwbarton> also makes me think that "mu is a catamorphism => h is a catamorphism" is plausible
21:54:56 <Cale> meiji11: right
21:55:00 <rosie> er, how do I view a recent transcript of this IRC? (the past hour) ?
21:55:08 <rwbarton> since it's vacuous for the free algebra
21:55:17 <Cale> meiji11: You can explicitly quantify that one too, which will make it separate
21:55:24 <Cale> http://bit.ly/5mwtRQ
21:55:49 <meiji11> ok, so my previous assumptions to do with forall are not incorrect, they just changed as a result of using ScopedTypeVariables?
21:55:51 <Cale> rosie: http://tunes.org/~nef/logs/haskell/12.09.09
21:56:03 <Cale> meiji11: right
21:56:12 <rosie> Cale: thanks!
21:56:19 <meiji11> awesome, I'm not a complete idiot after all..
21:57:21 <Nereid> hey, does eta_TX . eta_X = T(eta_X) . eta_X?
21:57:27 <Nereid> because if so, we're done.
21:58:13 <rwbarton> yes (naturality of eta) but how does that help?
21:58:16 <Nereid> oh.
21:58:19 <Nereid> cool, we're done.
21:58:22 <Nereid> because
21:58:28 <Nereid> oh boy.
21:58:41 <Nereid> one sec.
21:58:43 <Nereid> let me check.
22:00:14 <Nereid> shit.
22:00:17 <Nereid> :D
22:00:45 <geisthaus> 7.6.1...what I dont pay attention for one small iota of time and miss almost an entire 0.2.0.... what is this world coming too
22:01:04 <Nereid> one sec, it might still work.
22:01:24 <Cale> geisthaus: it was only released the other day
22:01:35 <johnw> how is cabal-install for 7.6.1 coming?
22:01:57 <rwbarton> hmm some formula I wrote above is nonsense
22:02:34 <Nereid> yeah it does.
22:02:39 <Nereid> oh god how shall I write this.
22:02:48 <Nereid> can't be bothered to tex it so I'll just write it on paper and take a photo :P
22:03:22 <rwbarton> oh wait no, i'm just getting too tired
22:03:25 <johnw> OldTeX
22:03:50 <meiji11> Cale: thanks, btw.
22:03:56 <Cale> no problem
22:05:08 <nand`> where can I read about the GHC versioning systems? I noticed that stable releases have tended to be on even minor versions; whereas the few odd-minor-versioned releases in my tree are all labeled unstable
22:05:13 <nand`> surely this can't be a coincidence
22:05:54 <ddarius> nand`: It isn't.
22:06:15 * hackagebot rehoo 0.2.1 - Rebuild default.hoo from many .hoo files in the current directory  http://hackage.haskell.org/package/rehoo-0.2.1 (JohnWiegley)
22:07:44 <nand`> ah, I found http://cs.simons-rock.edu/cmpt312/users_guide/version-numbering.html
22:07:48 <nand`> I presume that is still accurate
22:07:57 <Nereid> this looks complicated, but at least it looks right.
22:09:14 <ddarius> nand`: Why not start on GHC's page?  Such as this page: http://www.haskell.org/ghc/docs/latest/html/users_guide/version-numbering.html
22:09:39 <Nereid> rwbarton: structuralist:
22:09:40 <Nereid> http://i.imgur.com/Lx25i.jpg
22:09:59 <rwbarton> oh god
22:10:07 <ddarius> Nereid: I'm assuming you're familiar with XYpic
22:10:22 <Nereid> I've probably forgotten how to use it
22:10:26 <ddarius> Me too.
22:10:32 <Nereid> anyway
22:10:32 <ddarius> But it is nice for this kind of thing.
22:10:41 <Nereid> follow stuff from the F(X,TX) on the left.
22:11:44 <Nereid> so the squares on the right commute from what we discussed earlier.
22:12:14 <Nereid> oh, theta is the iso F(-,T-) -> T
22:12:22 <Nereid> obviously
22:12:36 <rosie> What's a good way to time the difference between strict and non-strict function evaluation?
22:13:17 <Nereid> anyway, the squares on the left commute because (top) naturality of eta, and (bottom) naturality of theta
22:13:29 <shachaf> rosie: The answer to any question that starts that way is probably "criterion" (so I hear).
22:13:40 <shachaf> I'm not sure what the last part of the question means.
22:13:56 <Nereid> and the leftmost triangle commutes because h is a T-algebra.
22:14:03 <rwbarton> it only commutes one way around though
22:14:12 <rwbarton> h . eta_X = id but eta_X . h /= id
22:14:15 <shachaf> rosie: By the way: bahaskell has been looking for a new venue. Do you know if Stanford might have something available?
22:14:16 <Nereid> yeah, that's fine.
22:14:16 <rwbarton> is it what you want?
22:14:21 <Nereid> because h . eta_X . h = h
22:14:23 <shachaf> They've been asking around.
22:14:30 <Nereid> so you go left and up around the top
22:14:48 <rosie> shachaf: I'm actually concerned with writing a function that differs only in its method of evaluation, and not, for example, printing to the screen.  A venue? Yeah! For sure! How big?
22:14:56 <rosie> What time of day?
22:15:01 <rwbarton> oh
22:15:03 <rwbarton> hmm
22:15:10 <Nereid> what a mess. :P
22:16:28 <Nereid> structuralist: are you here.
22:16:37 <shachaf> rosie: https://groups.google.com/forum/?fromgroups=#!topic/bahaskell/tp2HCNU2lLc
22:17:01 <structuralist> Nereid: yes… trying to follow
22:17:22 <Nereid> heh.
22:17:22 <rwbarton> it looks like this tells you h . theta_X . F(1,eta_X) . F(1,h) = h' . F(1,h)
22:17:56 <Nereid> rwbarton: uh, that follows from the definition of h'
22:18:01 <rwbarton> sorry
22:18:04 <rwbarton> let me try again :)
22:18:21 <Nereid> I'm saying h' . F(1,h) = h . theta_X
22:18:27 <Nereid> which is what we were trying to prove
22:18:33 <structuralist> I now appreciate the phrase "diagram chasing"
22:18:43 <Nereid> so you start from the leftmost F(X,TX)
22:18:49 <Nereid> going around the top is h' . F(1,h)
22:18:53 <rwbarton> I am worried about this weird triangle though
22:18:53 <Nereid> going down is h . theta_X
22:18:57 <Nereid> which triangle?
22:19:07 <rwbarton> the one in the top left
22:19:09 <shachaf> rosie: Criterion can be pretty good at benchmarking things.
22:19:18 <Nereid> rwbarton: surely that commutes, h . eta_X = 1
22:19:35 <structuralist> because it's going in a circle?
22:19:45 <rwbarton> it commutes if you start at F(X,X)
22:19:48 <shachaf> rosie: You'll probably have to think about your input somewhat carefully, though.
22:19:52 <Nereid> yes
22:19:54 <rwbarton> but you are trying to start at F(X,TX)
22:20:02 <Nereid> I don't see what's wrong?
22:20:03 <rwbarton> right?
22:20:08 <Nereid> every triangle and square commutes
22:20:36 <rosie> shachaf: yep, any advice? I can email the CS Program Administrator asking about a good room reservation. Want me to cc you?
22:20:42 <structuralist> Is this saying that F(1,h) and F(1,eta_X) are inverses?
22:20:44 <rwbarton> if you want to make it look like a normal commutative triangle you have to draw the equality as a leftward arrow
22:20:50 <Nereid> structuralist: not two-sided inverses.
22:20:57 <Nereid> ah
22:20:57 <Nereid> fuck.
22:21:02 <rwbarton> but then you have a leftward arrow in your thing
22:21:09 <shachaf> rosie: Sure.
22:21:17 <Nereid> fuck.
22:21:19 <rosie> shachaf: your email?
22:21:22 <ddarius> It's hard to "correctly" draw diagrams upon occasion, though most people fudge it.
22:21:26 <ddarius> E.g. parallel arrows.
22:21:41 <Nereid> yeah, that top = goes to the left.
22:21:49 <Nereid> wait.
22:21:51 <Nereid> it's still fine.
22:22:03 <Nereid> or is it.
22:22:05 <ddarius> I don't really care for commutative diagrams.  They are far less compact and manipulable than actual equations, and tend to have little value other than mnemonic value.
22:22:17 <rwbarton> right, if I had a diagram with parallel arrows that really commuted I would just draw one arrow :)
22:22:18 <shachaf> rosie: /msg
22:22:24 <rwbarton> ddarius: !!
22:22:27 <ddarius> And that last is rarely the case for a large diagram.
22:22:30 <rwbarton> wait I think we've had this conversation before
22:22:32 <shachaf> (Not that it's particularly secret, or that I don't get any spam...)
22:23:08 * ddarius rarely gets spam.  Google (presumably) usually catches it.
22:23:12 <shachaf> rosie: For your other question, I think you'd need to provide more context on what the function is and how it uses its input.
22:23:26 <ivanm> ddarius: most spam that I get is _conference_ spam
22:23:31 <ivanm> from all the dodgy pseudo-conferences
22:23:40 <ivanm> google isn't that good at catching those :s
22:23:47 <rosie> shachaf: let's say, the fibonacci function. Let's use lazy evaluation to only need to compute the first value rather than the twentieth, say
22:24:06 <Nereid> rwbarton: yeah, argh.
22:24:15 <ddarius> Presumably it will learn if you mark enough of it as spam.  Furthermore, if they are semi-legitimate, you can presumably just block that sender.
22:24:21 <Nereid> I'm tired.
22:24:51 <rwbarton> an easier way to see that something is wrong is to look at the big outline starting at the F(X,X) in the second column (the one with a 1 coming out of it) and ending at the X
22:25:25 <Nereid> I'm looking.
22:25:27 <shachaf> rosie: I need to go to dinner but I'll be back later. Someone else here can probably help you too. :-)
22:25:36 <rwbarton> if you read around the border you get h' = h . theta_X . F(1,eta_X) which was the definition of h'
22:25:43 <rosie> shachaf: yep, thanks! no rush at all. Have a good night (:
22:25:45 <Nereid> hilarious.
22:25:48 <shachaf> rosie: Thanks for sending the email!
22:25:59 <rosie> shachaf: no prob
22:26:03 <rwbarton> that's why when I read off an equation before, you told me it followed directly from the definition of h' :)
22:26:05 <Nereid> after all, all horizontal compositions there are 1.
22:26:29 <structuralist> ddarius: This is the problem if you want to have a look: http://i.imgur.com/IpcAF.png
22:27:29 <rwbarton> anyways my gut feeling is there is no reason that the left edge of structuralist's bottom diagram is the same as the left edge of the top diagram
22:27:41 <rwbarton> but this turned out to be a lot more interesting than I expected
22:29:00 <Nereid> I should have used pencil.
22:32:52 <ddarius> structuralist: Is Ta ~ F(a,Ta) is supposed to be natural in a?
22:33:00 <Nereid> yes
22:33:03 <structuralist> yes
22:35:28 <Nereid> my gut still tells me that that h' is "wrong"
22:36:45 <ddarius> I'm not sure what Ta ~ mu(F(a,-)) is supposed to be saying and it seems inconsistent to what's to the left of it.
22:37:03 <Nereid> you can ignore that.
22:37:14 <Nereid> the mu in that line is "fixed point"
22:37:23 <Nereid> not the monad mu
22:37:34 <ddarius> Oh.
22:38:01 <ddarius> That makes it make a lot more sense.
22:40:31 <rwbarton> the issue is whether the left edge of the bottom rectangle is actually the same as the left edge of the top square
22:40:49 <Nereid> right.
22:41:37 <Nereid> wait a sec.
22:41:42 <Nereid> we don't even need that.
22:41:54 <Nereid> or do we
22:42:13 <Cale> What are you guys diagram chasing?
22:42:22 <structuralist> http://i.imgur.com/IpcAF.png
22:42:29 <Nereid> what if you replace mu_X with Th?
22:44:11 <ddarius> To more precisely state the proposition, you want to know if the isomorphism T ~ F(-, T-) is an initial algebra with h as it's mediating morphism?
22:44:42 <ddarius> An initial F(X, -) algebra, that is.
22:45:06 <Nereid> something like that
22:45:26 <rwbarton> the question is whether you can give X an F(X, -)-algebra structure so that h is an algebra homomorphism
22:46:31 <structuralist> I'm a category theory newbie so not entirely sure of terminology but that sounds right?
22:46:31 <Nereid> which is precisely the "it suffices to show" part
22:48:05 <structuralist> I don't know about a natural transformation being an initial algebra, I thought it had to be a morphism
22:48:46 <ddarius> It does.
22:48:59 <ddarius> It would be the isomorphism instantiated at X.
22:49:03 <structuralist> then yes
22:50:34 <zzing> Does anyone know to install the coffeescript executable? I thought it would install 'coffee' from this: http://www.freshports.org/devel/rubygem-coffee-script-source/   but it doesn't seem to install a 'coffee' executable.
22:51:28 <startling> zzing: might not have your ruby gems bin in your PATH
22:52:14 <Nereid> just a silly thought:
22:52:24 <Nereid> two cases: F(a,b) = a, and F(a,b) = b.
22:52:26 <startling> zzing: don't ask, no one knows how to find it
22:52:31 <Nereid> it's clearly true for those two F.
22:52:52 <Nereid> and more generally, it should also be true if F is algebraic.
22:52:57 <zzing> startling, it is a very evil problem
22:52:58 <Nereid> and by that I mean F(a,b) is some sums of products of a,b
22:53:05 <structuralist> Nereid: why?
22:53:41 <Nereid> ok, let p(F) be the predicate "F satisfies the proposition".
22:53:54 <Nereid> for the two F I gave above, p(F) holds.
22:54:25 <Nereid> er uh
22:54:34 <Nereid> F(a,b) = Ta, and F(a,b) = b.
22:54:37 <Nereid> I dunno.
22:54:39 <Nereid> I'm being silly.
22:54:49 <Nereid> it works for those two, anyway.
22:55:05 <Nereid> I'm going crazy.
22:55:08 <Nereid> this gets us nothing.
22:56:13 <Nereid> but it works in those two simple cases.
22:56:24 <Nereid> where h' = h and h' = 1, respectively.
22:57:37 <rwbarton> here is another monad where it works: data Eventually x = Now x | Later (Eventually x)
23:00:03 <MostAwesomeDude> How do people go about creating monads that fill their requirements?
23:00:14 <MostAwesomeDude> I'm having a hell of a time realizing this thing that I want to build.
23:00:18 <rwbarton> actually I think I can choose a screwy join where it won't work
23:00:28 <Nereid> rwbarton: !
23:00:45 <rwbarton> since Eventually x is isomorphic to (Natural, x)
23:01:06 <rwbarton> I can use a weird monoid instance for Natural
23:01:29 <rwbarton> with the writer monad
23:01:59 <Nereid> like a non-cancellative one
23:02:05 <Nereid> ?
23:02:13 <copumpkin> rwbarton: that's the partiality monad!
23:02:23 <copumpkin> omg
23:02:33 <rwbarton> one where 0 is still the identity, but with 1 (+) x /= 1 + x
23:02:42 <rwbarton> where (+) is my new operation, + is regular addition
23:02:50 <shachaf> What's the partiality monad?
23:02:50 <copumpkin> rwbarton: it's only eventually isomorphic to (Natural, x)
23:02:54 <copumpkin> :P
23:03:02 <Nereid> rwbarton: so something like max
23:03:22 <rwbarton> sure
23:03:25 <copumpkin> shachaf: how we embed partial computation in a total language like agda (with codata)
23:03:35 <structuralist> MostAwesomeDude: aside from monad transformers?
23:03:44 <rwbarton> this is data though
23:03:52 <copumpkin> not in haskell it isn't
23:04:01 <ddarius> It's both.
23:04:15 <copumpkin> you could have an inifinite stream of Laters which would never get you that x
23:04:30 <copumpkin> which is why you wouldn't be able to write a total isomorphism to (Natural, x)
23:04:35 <copumpkin> even if that's a conat
23:04:44 <rwbarton> well I am talking about an initial algebra in some category, and I don't like working with DCPO when I can use Set
23:04:51 <copumpkin> ah
23:05:46 <ddarius> copumpkin: You should listen to Kings of Convenience's "Riot on an Empty Street".
23:06:11 <rwbarton> now someone can double-check but I'm pretty sure the left sides of the two diagrams would be different for this Eventually x with max
23:06:14 <ddarius> copumpkin: We should also go out and do something again some time.
23:06:40 <copumpkin> ddarius: sounds good :) next weekend sometime? (listening to album now)
23:06:55 <rwbarton> T-algebras are just sets acted on by (N, max)
23:08:40 <Cale> MostAwesomeDude: Don't necessarily go looking for a monad, design your library, knowing what you do about monads and other libraries, and if you get a monad instance, then great, but if you don't, no need to awkwardly force it to happen.
23:09:14 <shachaf> Cale: But what if you want do-notation?!
23:09:27 <Cale> Maybe do-notation just really doesn't make sense for you.
23:09:39 <shachaf> Then you can awkwardly turn your monoid into a sort-of monad.
23:09:44 <Cale> lol
23:09:47 <shachaf> Well, I guess that's what writer is.
23:10:30 <Cale> Certainly, if all you have is a monoid instance, that's something you can think about
23:10:54 <rwbarton> f :: (Natural, x) -> x is a catamorphism if it's of the form f (n, x) = g^n(h(x))
23:11:01 * ddarius disapproves of do-notation abuse.
23:11:42 <copumpkin> anyway, bedtime
23:11:45 <copumpkin> night!
23:12:03 <rwbarton> but even max is not of this form
23:12:07 <shachaf> Cale: What if you just have a semigroup?
23:12:16 <shachaf> That still qualifies for do-notation abuse, right?
23:12:19 <Cale> lol
23:12:21 <ddarius> shachaf: Then you make a Semigroupoid.
23:12:40 <Cale> If life gives you semigroups...
23:12:45 <ddarius> Really, do-notation doesn't care about return.
23:12:57 <shachaf> True.
23:13:04 <Nereid> shachaf: but a semigroup is almost a monoid
23:13:07 <Cale> make monoids anyway
23:13:12 <Nereid> just adjoin an identity
23:13:18 <ddarius> We should generalize do-notation to semigroupoids.
23:13:23 <Nereid> ha
23:13:39 <Cale> Wouldn't it be proc/do notation we'd be generalising in that case?
23:14:14 <MostAwesomeDude> Cale: Are you familiar with variable-timestep events? Like in games with variable FPS?
23:14:24 <Cale> sure
23:15:17 <MostAwesomeDude> So I want to have some sort of way to feed in the number of ticks I just had, and then possibly have things happen as a result, and every path I think of involves StateT IO and spaghetti code.
23:15:38 <MostAwesomeDude> I don't know how I'd do this in Haskell and I'm pretty sure it involves a gorgeous monad.
23:16:00 <ddarius> Continuous time FRP would solve it handily, if only there were good implementations.
23:16:20 <AfC> "gorgeous monad" heh
23:16:23 <MostAwesomeDude> Yeah, I can't grok any of the FRP libraries well enough to apply them here.
23:16:39 <AfC> "if only there was a good [library]" heh²
23:17:04 <MostAwesomeDude> Well, if somebody had already written a useful game engine in SDL+GL this wouldn't be a problem, but there aren't any.
23:17:19 <Cale> MostAwesomeDude: Yeah, if this were an easy problem, I would just point you at an already released library -- it's not easy to make really nice, but you can do some simple things with pure functions which might be enough to get you started
23:18:18 <Cale> MostAwesomeDude: So you have some delta in time, and a representation of your game state, and possibly user input, and you want to produce a new game state, and perhaps some form of output, yes?
23:18:21 <AfC> Can variable time intervals be expressed as nt where t is a very very small tick size?
23:18:32 <MostAwesomeDude> I think I might just augment my event loop with a buffer of timers which is tended and adjusted every time through the loop.
23:18:36 <Cale> MostAwesomeDude: That should be a pure function, right?
23:18:53 <MostAwesomeDude> Cale: Largely, yes. Right now it's all in IO, but I can pull out the IO parts.
23:19:10 <Nereid> make it a monad transformer. :v
23:19:12 <MostAwesomeDude> There's IO to check SDL's state, IO to update GL, and I should change the stuff in-between to be purer.
23:19:31 <rwbarton> structuralist: did you see this counterexample? set F(X,Y) = X + Y so TX = N x X, but give T the monad structure coming from the monoid (N,0,max) and take X = N, h = max; I claim h is not a catamorphism
23:20:12 <Cale> MostAwesomeDude: yeah, if your game isn't insanely resource intensive, it's usually pretty easy to pull out everything that goes on as a pure function.
23:20:29 <structuralist> rwbarton: yep, thinking about it
23:21:14 <pharaun> speaking of pulling things out of the IO, is there a good approach to pulling out a parser and other logic stuff out of the IO monad? i got a network library
23:21:46 <Nereid> make it a monad transformer. :v
23:21:48 <pharaun> and i find that overtime things ends up in the IO, so i've been pondering if there was any clever tricks to like pull/extract most of that stuff out, cos lots of the processing is decently pure
23:21:52 <pharaun> Nereid: monad transformer?
23:22:12 <Nereid> like ParsecT
23:22:22 <Nereid> I dunno.
23:22:48 <pharaun> hm k i'll dig at parsecT, i haven't done much monad transformer yet, and i figured that this would be a good subject to try out/figure out how it all works
23:23:30 <Nereid> well,
23:23:43 <Nereid> that's if you want the actual parsing to use IO.
23:23:47 <Nereid> I guess.
23:24:00 <Nereid> instead of parsing something you get from IO.
23:24:05 <pharaun> eh, i just want to try to get as much out of IO and get the parsing stuff out of io if possible
23:24:17 <pharaun> so i can try to figure out how to get quickcheck to hammer my parsing stuff
23:25:32 <structuralist> rwbarton: nicely done
23:25:35 <pharaun> lots of the usage is basically using the io to extract some bytestring out of the socket, then feed it into the parser then deciding what to do with it
23:26:44 <ddarius> pharaun: Things like conduit, pipes, iteratees, etc. handle this to some extent.
23:27:13 <pharaun> ddarius: i've been playing with conduits a bit, and i kind of want to eventually start converting my raw network stack over to using conduits
23:27:33 <Nereid> you know what I should do?
23:27:40 <ddarius> Nereid: Go to sleep?
23:27:41 <Nereid> actually write code, instead of being a theoretical haskeller.
23:27:44 <Nereid> and sleep.
23:27:57 <pharaun> :)
23:28:08 <Nereid> not sleepy yet, though.
23:28:55 <MostAwesomeDude> :t (.~)
23:28:56 <lambdabot> Not in scope: `.~'
23:28:58 <MostAwesomeDude> Aw.
23:29:10 <structuralist> rwbarton: did you say that if mu is a catamorphism then the algebras are? or just that it's plausible?
23:29:10 <ddarius> :t (...---...)
23:29:12 <lambdabot> parse error (possibly incorrect indentation)
23:29:21 <ddarius> ?
23:29:27 <Cale> MostAwesomeDude: haha, I'm pretty sure the GHC which lambdabot is using is too old to run lens
23:29:30 <johnw> :t (Control.Lens..~)
23:29:32 <lambdabot> Couldn't find qualified module.
23:29:43 <MostAwesomeDude> TIL _1 .~ 1 $ _2 .~ 2 $ (0, 0) -- works. Never using State for trivial state manipulation again!
23:29:43 <Cale> It's 6.12.3
23:29:44 <shachaf> > (...---...)
23:29:45 <lambdabot>   Not in scope: `...---...'
23:29:47 <shachaf> I think it's a :t thing.
23:29:48 <edwardk> cale: what version is it on?
23:29:52 <edwardk> ah
23:29:56 <edwardk> yeah 7.2 is the current floor
23:29:56 <rwbarton> structuralist: just that it's plausible
23:30:48 <rwbarton> you need some way to get a handle on expressions like join [[x],xs] or more generally to have some kind of good interaction between join and iso
23:30:53 <edwardk> MostAwesomeDude: (0,0) |> _1 .~ 1 |> _2 .~ 2    will give you something that looks more like a traditional record update in ordering
23:30:55 <Cale> MostAwesomeDude: actually, I wonder if I could recommend sodium -- at least I think it would be worth a shot :)
23:31:08 <Cale> http://hackage.haskell.org/packages/archive/sodium/0.3.0.1/doc/html/FRP-Sodium.html
23:31:10 <johnw> edwardk: What does |> do?
23:31:11 <MostAwesomeDude> edwardk: What.
23:31:11 <shachaf> I do not recommend sodium on its own.
23:31:18 <shachaf> Together with chloride it's OK.
23:31:26 <Cale> Sodium is very reactive
23:31:29 <Cale> ;)
23:31:32 <edwardk> johnw: (|>) :: a -> (a -> b) -> b  is just flipped ($) with slightly tighter precedence
23:31:35 <johnw> not as bad as Francium
23:31:45 <Cale> (functional reactive)
23:31:55 <johnw> ah
23:32:39 <MostAwesomeDude> edwardk: Where's (|>) defined?
23:32:44 <ddarius> edwardk: : Being inspired by F#?
23:33:30 <ion> mostawesomedude: Control.Lens (.Something, imported by the main module)
23:33:32 <edwardk> ddarius: obk wanted something so he could reference the fields in the opposite order, and it cleaned up a lot of code. the fact that f# gave me a nice name for it when we couldn't come up with another that didn't suck is a bonus ;)
23:33:46 <edwardk> MostAwesomeDude: Control.Lens.Combinators its re-exported by Control.Lens
23:34:00 <edwardk> MostAwesomeDude: it should be in the latest version on hackage
23:34:02 <MostAwesomeDude> Ah, I'd need a newer lens. Gotta get off of GHC 7.0.x then.
23:34:17 <Cale> MostAwesomeDude: what kind of game are you writing?
23:34:40 <ddarius> edwardk: You could always use (.)!
23:34:47 <MostAwesomeDude> Cale: Just a small platformer. This is largely a test of whether it's feasible; I'm tired of maintaining the normal game spaghetti in Python.
23:34:58 <edwardk> ddarius: wrong precedence, too tight
23:35:13 <ddarius> If you are redefining it, you can give it whatever precedence you want.
23:36:24 <carpi> is there any way to make a 'fold' return the value of the accumulator when it reaches a certain condition without processing the rest of the input list?
23:37:07 <ddarius> If it's a foldr, then you can just ignore the "accumulator."
23:37:16 <edwardk> $ is the actual alternative here =)
23:37:25 <edwardk> ddarius: well, i'm still using prelude (.) =)
23:37:28 <ion> A friend learning Haskell with a F#, OCaml etc. background would like to use x |> foo |> bar |> baz. I’ve been recommending to at least use function composition like x |> foo >>> bar >>> baz. (I noticed that the precedences of |> and >>> don’t let you do that without additional parens though, darn.)
23:37:29 <ddarius> Another option is to use a monadic fold.
23:37:52 <carpi> ddarius: could you please explain?
23:38:04 <ion> ddarius: Oh, btw, what are you using a Kalman filter for?
23:38:04 <carpi> what do you mean ignore the "accumulator"
23:38:05 <ddarius> edwardk: Don't worry, you could just use o for (Prelude..).
23:38:15 <edwardk> ion: sadly. i can't fix it without ruining the use of |> for my purposes ;)
23:38:25 <ddarius> > foldr (\x acc -> x) undefined [1..]
23:38:26 <lambdabot>   1
23:38:27 <ion> edwardk: aye
23:38:44 <Cale> ion: augh
23:38:50 <Nereid> > foldr (\x acc -> acc) "hi" [1..]
23:38:54 <lambdabot>   mueval-core: Time limit exceeded
23:38:54 <Nereid> oops.
23:39:25 <Nereid> yeah, go with a monadic fold.
23:40:01 <Cale> > foldr (\x xs -> if x > 10 then x else xs) 0 [1..]
23:40:03 <lambdabot>   11
23:40:08 <ion> “augh” says the person after whom the variant of Haskell with instance Num (a -> b) and (.) = fmap is named. ;-)
23:40:19 <ion> (Just kidding.)
23:40:20 <ddarius> ion: Nothing yet, and I'll probably use it only as part of a sequential Monte Carlo system or something closer to a HMM (though non-linear Kalman filtering is technically the same thing as HMM, more of a matter of emphasis).
23:40:35 <Nereid> @type foldr
23:40:36 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:41:04 <ion> ddarius: What data are you using to test it?
23:41:14 <ion> at the moment
23:41:16 <ddarius> ion: The application would be cleaning up, detecting, locking onto, and parameter estimating various radio signals such as extended squitter and GPS.
23:41:32 <ion> ddarius: Ok, neat.
23:41:37 <ddarius> ion: At the moment, artificial data like some non-linear and linear test problems.
23:41:57 <ddarius> All one-dimensional right now, though it's not hard to come up with multidimensional examples.
23:42:06 <ion> ok
23:42:22 <ddarius> The code (assuming it's right) works for arbitrary dimensions.
23:42:51 <ddarius> Unfortunately, my cholUpdate function uses a LAPACK routine that hmatrix doesn't bind, so I now have a custom hmatrix.
23:42:53 <carpi> Cale: why does it not work with foldl?
23:43:13 <Cale> @src foldl
23:43:13 <lambdabot> foldl f z []     = z
23:43:13 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:43:25 <Cale> foldl does nothing but call itself until it gets to the end of the list
23:43:36 <Cale> @src foldr
23:43:36 <lambdabot> foldr f z []     = z
23:43:36 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:43:48 <Cale> foldr f z (x:xs) immediately passes control to f
23:44:08 <Cale> and only if f uses its second parameter will it continue folding
23:45:58 <Twisol> Has anyone played with the new bidirectional support in pipes-2.3?
23:46:04 <ddarius> ion: I also have some online changepoint detection code.  I may make some offline version as well.
23:46:20 <carpi>  .. thanks for the clarity. so its more like ... foldr postpones the evaluation of f's second argument until f needs it
23:46:23 <Cale> carpi: you might like to use scanl to be able to observe the results of folding
23:46:29 <Nereid> > foldr (\x y -> if x <= 10 then x + y else 0) 0 [1..]
23:46:30 <lambdabot>   55
23:46:51 <shachaf> carpi: foldr f z replaces (x:xs) with f x (foldr f z xs)
23:47:02 <Cale> carpi: well, that parameter is passed to f as an expression which f may choose to pattern match on (which will force its evaluation)
23:47:41 <ion> ddarius: Any time you feel like publishing the code, i’d be interested to read it for learning purposes. :-)
23:47:54 <Cale> carpi: Expressions are still around at runtime of course :)
23:48:23 <Cale> (you'll hear people talk about thunks, which are the data structures used to represent expressions at runtime)
23:48:28 <ddarius> Well I'll need to get some changes into hmatrix before it will work with unmodified libraries.
23:48:48 <carpi> yes .. thunks .. yet to be evaluated expressions
23:49:01 <ddarius> But if you are interested I could probably put it somewhere, or at least email the current version of the code.
23:49:50 <Cale> But I tend to prefer not mentioning thunks so much -- it's easier just to think at the level of expressions being rewritten as evaluation proceeds
23:50:15 <ion> ddarius: I don’t even need to run it yet, i’d just like to study it. I don’t even have the sensors for which i’d like to implement sensor fusion yet.
23:50:29 <Cale> (or if you need a little more sophistication, you can think of expression graphs, rather than expression trees)
23:51:18 <ddarius> I thought you were going to get them the past week.  Also, did you check out correlation intersection?  Also, the unscented Kalman filter has a cute solution to multi-level information fusion that may be of use to you.
23:51:34 <ddarius> Let me see if I can find the paper that mentions that.
23:51:58 <Nereid> I'm interested.
23:53:15 <ddarius> ion: Check out the paper "Unscented Filtering and Nonlinear Estimation" by Julier and Uhlmann.
23:53:48 <ddarius> On page 17 or so into it, it has a little diagram and section on using unscented filtering for multi-level of information fusion.
23:54:05 <ion> ddarius: I hoped to get them last week, but didn’t yet. The package should finally arrive today or tomorrow. I saved a paper about correlation intersection but didn’t study it yet.
23:54:10 <ion> ddarius: Thanks, i’ll take a look at that.
23:57:06 <mdxbhmt> Anyone can give me some assistance with gloss? I did a cabal install but I'm having a glut related error
23:57:33 <mdxbhmt> $ gloss-styrene / gloss-styrene.exe: user error (unknown GLUT entry glutIgnoreKeyRepeat)
