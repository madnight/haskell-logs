00:00:08 <companion_cube> evincar: also, you can fix mistakes people do by trying things
00:00:45 <shachaf> evincar: It's encouraged.
00:00:57 <shachaf> Also, what does a web log have to do with answering questions?
00:03:02 <evincar> I mean, I would rather write a blog article exploring a topic than use Q&A format where it may not be appropriate.
00:03:19 <evincar> And I don't think enough people take advantage of the editing features on SE.
00:03:37 <Twisol> I just ported a class assignment to Haskell. I think it's my first "real" Haskell program, so if anyone could supply some feedback I'd appreciate it! http://hpaste.org/74378
00:04:42 * hackagebot testing-feat 0.3.0.1 - Functional Enumeration of Abstract Types  http://hackage.haskell.org/package/testing-feat-0.3.0.1 (JonasDuregard)
00:05:00 <lpvb> johnw: Okay, doing -O on ghc, strip -p --strip-unneeded --remove-section=.comment, and upx brought my 35 MB executable to 2.7MB :D
00:05:36 <shachaf> "upx"? Isn't that going a little far?
00:05:46 <johnw> Twisol: take a olok at readInsnClass
00:06:16 <johnw> oh, never mind
00:06:23 <evincar> johnw: Applicative?
00:06:26 <Twisol> johnw: out of curiosity, what were you going to say?
00:06:57 <evincar> I was reflexively going to suggest InsnClass <$> prompt ... <*> prompt ... but it's not really appropriate.
00:07:02 <johnw> what evincar said.  points
00:07:16 <johnw> but I realized in this case it's just 6 of one, half-dozen of the other
00:07:18 <evincar> Although there is that one use of 'fmap'.
00:07:50 <Twisol> I was pretty happy with that sequence $ fmap readInsnClass thing.
00:08:39 <avpx> Twisol: Yeah, I like how this code reads actually
00:09:01 <johnw> and there's this: (/) `on` f $ (totalCycles classes) frequency
00:09:06 <johnw> but I'm not sure that helps readability either
00:09:07 <evincar> Twisol: Shorter lines would be nice. :P
00:09:23 <Twisol> evincar: It's the darned fromIntegrals :(
00:09:31 <avpx> One stylistic note: I think putStr $  "some" ++ "big" ++ "concatenated" ++ "string" is cleaner than putStr "some" >> putStr "big" ...
00:10:03 <johnw> oh, where f = fromIntegrals
00:10:04 <evincar> avpx: Better, concat ["some", "big", "concatenated", "string"], or unwords.
00:10:10 <avpx> evincar: That too
00:10:22 <Twisol> unlines might be nice
00:10:23 <avpx> Or even mapM_
00:10:36 <evincar> Twisol: In 'mips' I would line break before = and /.
00:10:41 <johnw> i prefer traverse_ to mapM_ these days
00:10:42 <avpx> For outputting lines, mapM_ putStrLn can be handy.
00:11:39 <m3ga> @hoogle traverse_
00:11:40 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
00:12:21 <evincar> The deeper I get into Haskell, the more I want absurdly abstract types.
00:12:36 <johnw> evincar: are you excited by 7.6 then?
00:13:04 <avpx> johnw: Hmm, I'm trying to see how I would use traverse_. I don't mess around with applicative functors much.
00:13:23 <johnw> mapM_ == traverse_
00:13:31 <johnw> for monads that have an Applicative instance
00:13:33 <avpx> I see, but just more general
00:13:37 <johnw> oh, I mean, a Traversable one
00:13:40 <johnw> yes
00:13:48 <johnw> Foldable and Traversable are kind of wonderful
00:13:56 <avpx> Right? Because all monads would be Foldable and Applicative, correct?
00:13:57 <johnw> I wish they were in the Prelude
00:14:17 <evincar> johnw: Sadly I haven't had a chance to look into 7.6 yet, except for some stuff on the mailing list.
00:14:20 <johnw> i'm pro-type classes, over functions specialized for lists
00:14:40 <evincar> I'm slowly becoming anti-typeclasses and pro-intersection types.
00:14:50 <evincar> But that's never gonna happen in Haskell of course.
00:15:02 <startling> so what's Traversable?
00:15:03 <avpx> johnw: I think this is reasonable.
00:15:24 <path[l]> whats an intersection type?
00:15:30 <startling> foldable is pretty great; I've never found a motivation to need/learn Traversable
00:15:32 <johnw> i suppose traverse_ is worse than mapM_ in a really tight loop, according to what I've read
00:15:58 <avpx> path[l]: I guess it's an alternative to quantification?
00:16:03 * avpx has been reading for all of 10 seconds
00:16:37 <evincar> startling: IIRC Traversible is basically a nice alternative to (toList . map f . fromList)
00:16:40 <path[l]> ok, I guess we dont follow what any of this means
00:16:55 <startling> evincar: isn't that just fmap?
00:17:01 <johnw> evincar: but not implemented so crudely
00:17:17 <evincar> path[l]: Universal quantification is basically an infinite intersection, yeah.
00:17:21 <evincar> johnw: Naturally. :P
00:17:34 <nand`> evincar: traversable is more like a mapM really
00:17:37 <startling> how is that different from fmap?
00:17:51 <johnw> nand`: yes, that's right
00:17:57 <johnw> fmap takes an a -> b
00:18:03 <johnw> traverse takes an a -> m b
00:18:05 <johnw> just like mapM
00:18:07 <ion> > traverse (Just . succ) [1,2,3]
00:18:08 <lambdabot>   Not in scope: `traverse'
00:18:13 <ion> > Data.Traversable.traverse (Just . succ) [1,2,3]
00:18:15 <lambdabot>   Just [2,3,4]
00:18:23 <startling> oh
00:18:25 <evincar> Right. I think this is a sign I need to sleep soon. :P
00:18:26 <nand`> traversable is defined by sequence :: Applicative f => t (f a) -> f (t a)
00:18:30 <startling> I still don't see the motication
00:18:31 <Nereid> Traversable gives you sequenceA, which generalizes sequenceM
00:19:01 <Nereid> @type (sequenceA, sequenceM)
00:19:02 <lambdabot> Not in scope: `sequenceA'
00:19:02 <lambdabot> Not in scope: `sequenceM'
00:19:04 <Nereid> aw.
00:19:04 <startling> so has anyone written a lensy prelude yet?
00:19:17 <Nereid> @type (Data.Foldable.sequenceA, Control.Monad.sequenceM)
00:19:18 <lambdabot> Not in scope: `Data.Foldable.sequenceA'
00:19:18 <lambdabot> Not in scope: `Control.Monad.sequenceM'
00:19:20 <Nereid> come on.
00:19:22 <Nereid> :(
00:19:28 <Nereid> er not Foldable anyway.
00:19:33 <ion> @type sequence
00:19:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:19:36 <nand`> @type (Data.Traversable.sequenceA, sequence)
00:19:37 <lambdabot> forall (t :: * -> *) (f :: * -> *) a (m :: * -> *) a1. (Data.Traversable.Traversable t, Applicative f, Monad m) => (t (f a) -> f (t a), [m a1] -> m [a1])
00:19:41 <Nereid> I meant sequence, not sequenceM, duh.
00:19:51 <johnw> :t sequenceM
00:19:51 <lambdabot> Not in scope: `sequenceM'
00:19:57 <johnw> heh
00:20:01 <Nereid> ignore me.
00:20:05 <johnw> i've got the short-term memory of a may fly
00:20:30 <evincar> johnw: It didn't even have a chance to leave the screen.
00:20:43 <johnw> my buffer is only 9 lines tall
00:20:44 <Twisol_> kinda sick of this college wi-fi
00:21:30 <Twisol> You'll love this… and by love I mean dislike
00:21:50 <Twisol> I did: where double x = fromIntegral x :: Double
00:21:55 <Twisol> so I could do: (double)(insnCount classes) / executionTime metrics
00:22:55 <johnw> evil :)
00:23:36 <Twisol> I'm thinking of trying to use the Reader monad to hide the annoying 'metrics' everywhere.
00:26:51 <johnw> Twisol: seems a touch overkill
00:27:02 <Twisol> johnw: Nothing is overkill in the name of learning!
00:27:05 <johnw> although I understand the temptation to golf with your own code
00:27:39 <nand`> what you gain in omitting ‘metrics’ you often lose in complexity involved extracting the result from the reader monad
00:27:53 <Twisol> It's more that I have very little direct experience with monads, so this seems like an opportunity to play with things.
00:27:56 <nand`> note that if metrics is a record and executionTime is a field name, there is a very elegant way to solve this
00:28:07 <startling> yeah, Reader is more useful if you're passing around a boatload of things
00:28:24 <nand`> instead of foo metrics = .... executionTime metrics; use foo Metrics{..} = ... executionTime; where Metrics is the constructor
00:28:46 <nand`> reader is useful for scoping and composing
00:29:32 <Twisol> I suppose I should label the fields, but I'm just given the CPU frequency and a set of instruction types, with cycles-per-instruction and a count of how many instructions of that type there are.
00:29:42 <Twisol> executionTime is computed from that
00:30:48 <Twisol> yeap, I hate my connection right now.
00:33:44 <Twisol> Anyways, thanks for the feedback on my program!
00:34:25 <johnw> Twisol: do you pay for your connection?
00:34:31 <startling> I feel like lenses are fractally cool
00:34:37 <Twisol> It's provided by the university, so… I don't think so?
00:34:38 <johnw> startling: lol
00:34:43 <johnw> Twisol: then hate it less :)
00:34:54 <Twisol> …fair point
00:35:07 <Twisol> …I do pay for housing though.
00:35:12 <startling> johnw: my code is just so nice and clean and I don't have all these dumb utility functions everywhere
00:36:13 <johnw> startling: I'm sure to start using them soon
00:36:21 <johnw> what I'm not as sure about yet is pipes/conduit
00:36:24 <Twisol> You'll probably be pleased to hear that the Haskellified version of this assignment is half the size of the original C version I wrote.
00:36:49 <johnw> Twisol: although to be fair, if you write the C version again, it'd probably be much smaller, right?
00:36:55 <startling> Twisol: and 100% less segfaulty?
00:37:23 <Twisol> startling: haven't had a segfault in the C version. Have had a problem with Ctrl+D causing it to reuse the last character at the menu endlessly.
00:37:29 <startling> haha
00:37:50 <akamaus> what's the best way to read C binary data structures from file?
00:38:01 <johnw> attoparsec?
00:38:05 <Twisol> johnw: Original version: http://hpaste.org/74379
00:38:07 <johnw> FFI?
00:38:07 <startling> akamaus: the packages `cereal` and `binary`
00:38:23 <ivanm> startling: well, depends on the structure
00:38:24 <Twisol> johnw: I dunno. I'm finding it tough to improve the C version.
00:38:33 <startling> ivanm: yeah, s'true
00:38:35 <akamaus> Actually it some kind of linked list
00:38:39 <johnw> Twisol: you've got a point there
00:38:52 <ivanm> startling: I tried parsing something where the first byte told me how many times to repeat another parser; binary and cereal couldn't cope with that
00:38:52 <johnw> startling: which is better, cereal or binary?
00:39:15 <ivanm> so I switched to attoparsec (after trying to get polyparse to match it's performence, which only happened by turning polyparse _into_ attoparsec :s)
00:39:23 <ivanm> johnw: depends on what you want
00:39:29 <startling> ivanm: I did something similar with cereal
00:39:31 <ivanm> binary is more lazy, cereal is more strict
00:39:43 <ivanm> binary either has or is soon going to have a CPS-based implementation
00:39:52 <startling> yeah, cereal only works on strict bytestrings
00:40:07 <startling> ivanm: but yeah, attoparsec is definitely more flexible
00:40:19 <Twisol> lol, it's actually kind of funny how similar the Haskell and C versions are. >_>
00:40:41 <akamaus> guys, I'm under impression all these packages are for  sequential reading. And I need to follow pointers inside a file.
00:41:11 <ivanm> come again?
00:41:34 <ivanm> akamaus: what are you _actually_ trying to do?
00:42:01 <akamaus> to play with a memory of a process in /proc/<pid>/mem ;)
00:42:06 <johnw> akamaus: you mean, like a BTree?
00:42:11 <startling> akamaus: u.u
00:42:32 <johnw> ah
00:42:48 <akamaus> i need to read various C data structures from there.
00:43:02 <startling> akamaus: you can probably still do it with cereal. read your first pair, dispatch on that one's address, and so on
00:43:11 <ivanm> akamaus: so you can't just read it in and be done with it?
00:43:17 <startling> akamaus: but be aware that c can do whatever it wants to structs
00:43:19 <ivanm> it sounds like something you'd have to keep in IO then
00:43:22 <Botje> akamaus: mmap plus foreignptrs.
00:43:24 <johnw> you can use the IO functions just like you would C functions, hSeek, hRead, etc., though I'm not sure that's the best
00:43:30 <johnw> ooh, mmap
00:43:37 <akamaus> ivan, yeah, I've to follow the nodes of a linked list for example
00:44:15 <Botje> akamaus: or you ptrace the process and do it like that.
00:44:28 <ivanm> there's an mmap package on hackage
00:44:30 <ivanm> darcs uses it
00:45:38 <johnw> http://hackage.haskell.org/packages/archive/mmap/0.5.8/doc/html/System-IO-MMap.html
00:45:53 <Ralith> mmapping /prod/.../mem
00:45:54 <Ralith> heh
00:46:09 <akamaus> ivanm, can I mmap a pseudofile like /proc/pid/mem?
00:46:12 <johnw> can you run Attoparsec on the memory block returned my mmap?
00:46:22 <ivanm> no idea, never used it
00:46:27 <Botje> akamaus: we've been through this yesterday already ...
00:46:31 <ivanm> and only have a vague understanding what mmap actually _means_ :p
00:47:06 <ion> johnw: http://hackage.haskell.org/package/bytestring-mmap
00:47:28 <johnw> that is just too cool
00:47:39 <johnw> "Lazy, chunk-wise memory mapping."
00:48:08 <akamaus> ivanm, it maps a file into address space of a process. I'm not sure what does it mean when file is actually another memory space :)
00:48:10 <startling> lazy loading sounds like a bad idea for memory
00:48:23 <ion> johnw: Memory access blocking on disk access can have unintended consequenses with threads, though.
00:48:24 <akamaus> startling, why so?
00:48:40 <akamaus> ion, in my case it's a pseudo file
00:48:40 <Botje> akamaus: it maps a file *handle*.
00:48:44 <startling> akamaus, because it'll probably change between evaluating the thunks
00:49:00 <Botje> if you can read from it, you can mmap it.
00:49:07 <akamaus> startling, surely it will.. It's preemptive multitasking, after all
00:49:09 <johnw> I can mmap a socket?
00:49:13 <Botje> (you need to be able to seek, too)
00:49:25 <Botje> so no
00:49:59 <lpvb> @hoogle [a] -> (a,a)
00:50:00 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
00:50:00 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
00:50:00 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
00:50:18 <startling> lpvb: whatcha looking for?
00:50:35 <shachaf> Y'all should listen to ion.
00:50:45 <lpvb> @hoogle [a] -> [(a,a)]
00:50:46 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
00:50:46 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
00:50:46 <lambdabot> Data.Graph.Inductive.Query.Monad apply :: GT m g a -> m g -> m (a, g)
00:51:15 <lpvb> I want to take one list (a:b:_) and fold it into a tuple list (a,b)
00:51:19 <lpvb> I'll just do it myself
00:51:44 <startling> lpvb: a tuple list?
00:51:50 <startling> lpvb: also, that's an incomplete function
00:52:08 <ion> johnw: mmapping a socket will require some advances in time travel technology.
00:52:15 <pharaun> this type does not work? - GenParser Char st (IntMap.IntMap ParseType)
00:52:18 <lpvb> why's it incomplete?
00:52:30 <startling> lpvb: what if I call your thing with []?
00:52:49 <startling> or [1]
00:53:17 <lpvb> @hoogle [a] -> Maybe [(a,a)]
00:53:18 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
00:53:18 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
00:53:18 <lambdabot> Data.Graph.Inductive.Query.Monad apply :: GT m g a -> m g -> m (a, g)
00:53:35 <shachaf> You probably don't want Maybe [(a,a)]
00:53:42 <akamaus> ion, I've looked at interface of bytestring-mmap, I'm not sure is it appropriate for random access or not.
00:53:43 <startling> lpvb: do you want [(a, a)] or (a, a)?
00:54:28 <lpvb> a list of tuples
00:54:37 <lpvb> so only even lists
00:54:43 <startling> lpvb: that's different
00:55:29 <ivanm> lpvb: what is your expected result of doing it to [a,b,c] ?
00:55:39 <ivanm> [(a,b), (b,c)] ?
00:55:46 <johnw> hpc: ping
00:55:58 <ivanm> if so, good 'ol zip`ap`tail to the rescue!
00:56:42 <startling> > zip `ap` tail [1, 2, 3, 4]
00:56:43 <lambdabot>   Couldn't match expected type `[a] -> [b]'
00:56:43 <lambdabot>         against inferred type `[t]'
00:56:46 <shachaf> ivanm: No.
00:56:47 <Nereid> I think he wants [a,b,c,d] -> Just [(a,b),(c,d)], while odd length lists go to Nothing
00:56:50 <lpvb> ivanm: Left "Uneven list" ?
00:56:55 <startling> > (zip `ap` tail) [1, 2, 3, 4]
00:56:56 <lambdabot>   [(1,2),(2,3),(3,4)]
00:56:57 <pharaun> nvm me - pebkac
00:57:10 <shachaf> I think that ruins laziness, so it's unlikely that it's what lpvb actually wants.
00:57:11 <startling> ivanm: that's different
00:57:24 <lpvb> @hoogle ap
00:57:25 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
00:57:25 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
00:57:25 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
00:57:26 <ivanm> ahhhh
00:57:39 <ivanm> so you'd be wanting to fmap ((a,b):) onto the recursive call
00:57:49 <ivanm> and if you get to a singleton at the end the result is Nothing
00:57:54 <shachaf> ivanm: Why fmap?
00:57:55 <shachaf> Oh.
00:57:56 <ivanm> if you get to the empty list the result is Just []
00:58:03 <shachaf> No, this is the wrong function! You don't want this function.
00:58:06 * shachaf is in the business of telling people what they want.
00:58:10 <lpvb> schlumpi: I'm just trying to pair up command line arguments and convert it to a map
00:58:15 <ivanm> shachaf: how else would you do it without pre-computing the length?
00:58:31 <lpvb> uh that was at scha
00:58:40 <lpvb> at shachaf
00:58:40 <shachaf> It's OK. You don't need to type my name. I saw it.
00:58:45 <lpvb> :(
00:58:52 <ivanm> lpvb: are you trying to develop Yet Another Argument Parser ?
00:58:57 <lpvb> I pronounce a silent c
00:59:11 <lpvb> ivanm: there's a better way?
00:59:23 <ivanm> GetOpt
00:59:24 <ivanm> CmdArgs
00:59:26 <ivanm> ArgParser
00:59:27 <ivanm> etc.
00:59:30 <shachaf> No. All the Haskell argument parsers are bad.
00:59:32 <shachaf> It's sad. :-(
00:59:37 <ivanm> shachaf: how are they all bad?
00:59:42 <ivanm> you've tried every single one?
00:59:43 <shachaf> Each in its own way.
00:59:48 <ivanm> IIRC I saw a new one in the past week
01:00:01 <startling> you know what would rule? if undefined had Eq
01:00:07 <shachaf> No.
01:00:08 <ivanm> startling: *shudders*
01:00:14 <startling> haha
01:01:35 <ion> Someone should implement something like https://github.com/docopt/docopt with Template Haskell.
01:02:00 <lpvb> startling: I don't understand the zip `ap` tail, why is zip of the form a -> b?
01:02:02 <ion> type-safely
01:02:11 <Nereid> @type zip
01:02:12 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
01:02:23 <Nereid> [a] -> ([b] -> [(a,b)])
01:02:36 <lpvb> oh
01:02:40 <shachaf> ap zip tail x = zip x (tail x)
01:02:49 <shachaf> It's Haskell people trying to be cute and too clever for their own good.
01:02:49 <Nereid> ^
01:03:04 <Nereid> @type zip <*> tail
01:03:05 <lambdabot> forall b. [b] -> [(b, b)]
01:03:05 <johnw> ion: huh, that is pretty damn cool
01:03:17 <johnw> ion: I hereby commission you to make it so
01:03:58 <ivanm> ion: so it's a pre-processor?
01:05:09 <johnw> wait, so (f <*> g) x = f x ( g x)?
01:05:15 <Twisol> Seems to generate a schema for command-line arguments based on a formatted string
01:05:24 <Nereid> johnw: <*> = ap
01:05:28 <Nereid> for a monad
01:05:28 <startling> ion: I totally wrote that before that guy did
01:05:35 <startling> ion: except mine was better
01:05:36 <johnw> darn, just when I thought I actually understood <*>
01:06:05 <johnw> oh
01:06:15 <johnw> it's because of the (->) r instance
01:06:17 <johnw> that always throws me
01:06:18 <Nereid> yes
01:06:45 <johnw> f <*> g is the reader monad!
01:07:00 <johnw> is that right?
01:07:24 <Nereid> (->) r is the reader monad
01:07:36 <johnw> i mean, using <*> to compose two pure functions
01:08:38 <johnw> is like (do y <- g ; f y) in the reader monad
01:09:16 <johnw> ?
01:09:21 <johnw> guess i'll try it out
01:09:26 <Nereid> ap k m = do { f <- k; m <- x; return (f m) }
01:09:27 <lpvb> <*> applicative functor?
01:09:29 <johnw> where is evincar for his points
01:09:52 <Nereid> er
01:09:56 <Nereid> I got some variables mixed up.
01:10:13 <Nereid> I should sleep.
01:12:36 <johnw> (do x <- g; f x) b
01:12:44 <johnw> is functionally the same, but I don't think the precedence is right
01:12:53 <johnw> > (f <*> g) b
01:12:55 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:12:55 <lambdabot>    `SimpleReflect.FromExpr ...
01:13:08 <johnw> > ((+) <*> (+a)) b
01:13:09 <lambdabot>   b + (b + a)
01:13:25 <johnw> (do x <- (+a); (+) x) b
01:13:30 <johnw> > (do x <- (+a); (+) x) b
01:13:31 <lambdabot>   b + a + b
01:13:35 <johnw> so I'm still lacking some understanding
01:16:25 <johnw> @src liftM2
01:16:25 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:17:22 <startling> johnw: what don't you get?
01:17:35 <startling> > Just (+ 1) <*> Just 2
01:17:36 <johnw> :t f <*>
01:17:36 <lambdabot>   Just 3
01:17:37 <lambdabot> parse error (possibly incorrect indentation)
01:17:41 <johnw> :t (f <*>)
01:17:42 <lambdabot> forall (f :: * -> *) a b. (SimpleReflect.FromExpr (f (a -> b)), Applicative f) => f a -> f b
01:17:50 <johnw> :t ((\x y -> x + y) <*>)
01:17:50 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
01:17:55 <johnw> @pl ((\x y -> x + y) <*>)
01:17:55 <lambdabot> ((+) <*>)
01:18:27 <johnw> startling: I'm trying to see how (f <*> g) x turns into f x (g x)
01:18:40 <johnw> i can't see yet how the x becomes the first argument to f
01:19:57 <Ferdirand> g :: x -> a
01:20:03 <Ferdirand> f :: x -> a -> b
01:20:14 <johnw> @djinn (b -> b) -> b -> b
01:20:14 <lambdabot> f a = a
01:20:31 <startling> :t (+) <*> (+ 1)
01:20:32 <lambdabot> forall a. (Num a) => a -> a
01:20:46 <startling> > ((+) <*> (+ 1)) 3
01:20:47 <lambdabot>   7
01:21:02 <lpvb> @hoogle Char -> [Char] -> [[Char]]
01:21:02 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
01:21:02 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
01:21:02 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
01:21:17 <lpvb> is there a haskell platform function for that?
01:21:19 <startling> @src on
01:21:19 <lambdabot> (*) `on` f = \x y -> f x * f y
01:21:20 <Ferdirand> but (x -> t) is F t
01:21:24 <frerich> johnw: I guess this is not a satisfactory response, but that's how the Applicative instance for '(->) a' is defined.
01:21:28 <Ferdirand> so g :: F a
01:21:32 <startling> lpvb: Data.List is base
01:21:33 <lpvb> split a string on a character
01:21:36 <Ferdirand> f :: F (a -> b)
01:21:41 <johnw> ($) `on` f?
01:21:46 <johnw> no, taht's not it
01:21:47 <lpvb> it's not in Data.List
01:21:50 <johnw> what does ((\x y -> x + y) <*>) become?
01:21:57 <frerich> johnw: In http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Applicative.html#%3C%2A you can see that (<*>) f g x = f x (g x)
01:22:07 <Ferdirand> and (<*>) :: F (a -> b) -> F a -> F b
01:22:16 <johnw> ok
01:22:20 <Lamen> my 2 cents: f = (->) r, f (a -> b) -> f a -> f b => (r -> (a -> b))->(r -> a) -> (r ->b), as [a]-> [b] -> [(a, b)] -> ([a] ->[b]) ->( [a] -> [(a, b)])
01:22:23 <startling> johnw: (\x f -> x + f x)
01:22:43 <startling> woah, look at this:
01:22:44 <startling> @src on
01:22:44 <lambdabot> (*) `on` f = \x y -> f x * f y
01:22:55 <johnw> so, (<*>) (\x y -> x + y) is (<*>) (\x -> (y -> x + y))
01:23:16 <startling> johnw: do you understand >>= on ((->) a)?
01:23:28 <johnw> startling: no
01:23:36 <startling> johnw: that's the first place, then. :)
01:24:55 <startling> > ((+ 1) >>= (+)) 2 3
01:24:56 <lambdabot>   5
01:24:59 <frerich> johnw: I think what Lamen did (simply expanding the 'f' in '(<*>) :: f (a -> b) -> f a -> f b' with '(->) r') is quite useful (that's how I learned it, IIRC LYAH does the same approach).
01:25:01 <donri> uuh that's a weird @src entry
01:25:18 <startling> didn't realize you could make random argument variables infix
01:25:36 <johnw> ah
01:25:44 <johnw> frerich: let me try that
01:27:58 <johnw> ok, (r -> (a -> b))  -> (r -> a) -> (r -> b)
01:29:52 <Twisol> AFAICT, <*> just curries everything you give it with the one value you pass the thing at the end
01:29:55 <johnw> ok, (r -> a -> b) -> ((r -> a) -> (r -> b))
01:30:33 <Twisol> so that <*> looks a lot like (a -> b) -> a -> b, which is id, because it's just including that parameter on everything
01:30:53 <startling> johnw: I still think the better way to understand this would be via (>>=)
01:31:12 <johnw> startling: no, that just confuses me right now
01:31:16 <johnw> let's leave Monad out of this
01:31:40 <startling> johnw: no, it's the key!
01:31:45 <johnw> I'm trying to figure out what (<*>) (\x (\y -> x + y)) becomes, in terms of the resulting lambda
01:34:03 <frerich> johnw: Yes, the expansion of <*> is  (r -> (a -> b)) -> (r -> a) -> (r -> b) which is the same as  (r -> a -> b) -> (r -> a) -> (r -> b); that's the type of <*>. So in 'f <*> g', you get a function of type 'r -> b' (the first two arguments have been given).
01:34:39 <Twisol> In effect, you applied to the 'a' in the original function.
01:34:46 <Twisol> the second argument rather than the first
01:34:52 <frerich> johnW: So in order to produce a 'b' out of the 'r', the function will need to construct an 'a' out of the 'r' using the second argment ('g' in 'f <*> g')
01:34:53 <startling> johnw: it applies the r to both given functions and applies the result of the second to the first
01:35:10 <frerich> jownh: And then that 'a' as well as the original 'r' is passed to the first argument of <*> ('f') to produce the final 'b'
01:35:22 <johnw> startling: ah, that's what I needed
01:35:26 <johnw> that's it
01:35:49 <startling> so you've got (+) and (+ 1) and you get 1. so you get (1 +) and 2, and then three
01:36:04 <Lamen> johnw: and remember f >>= k = \ r -> k (f r) r, it's "defined" that way :)
01:36:08 <startling> > ((+) <*> (+ 1)) 1
01:36:09 <lambdabot>   3
01:36:16 <johnw> f <*> g $ a applies f a, then applies g a, and then passes the result from g a to the result from f a
01:36:17 <johnw> got it
01:36:19 <johnw> phew
01:36:37 <frerich> johnw: Right, and that's the same as "f a (g a)"
01:36:39 <startling> johnw: anyway, let's talk about (>>=)
01:36:43 <johnw> yeah
01:36:56 <johnw> and now I see again how it's identical to Just (1+) <*> Just 1
01:37:01 <johnw> $ a
01:37:02 <Lamen> and you can think k as a monad maker, which takes the result of (f r) then return a new function and appied to r again
01:37:06 <johnw> no, no $ a
01:37:11 <startling> johnw: you know how monads can let you work on values that don't really exist yet?
01:37:22 <johnw> startling: I don't follow
01:37:25 <startling> johnw: like IO String isn't an actual string, but you can work on it
01:37:41 <startling> it hasn't been run yet, so you don't have a concrete value for the string
01:38:06 <johnw> f <*> g <*> h <*> k $ a would basically pass a to every thing, then apply each to the next in series
01:38:28 <johnw> (although it wouldn't happen in that order)
01:38:39 <Twisol> <*> curries on a future argument :O
01:39:15 <johnw> startling: ok
01:39:17 <startling> johnw: (+ 1) >>= x lets you run x on the result of (+ 1)
01:39:25 <johnw> Twisol: only if the arguments are pure functions
01:39:42 <startling> johnw: even though you need another argument there to actually get the value
01:39:43 <Twisol> johnw: since we're talking about ((->) r) I'm assuming that
01:39:48 <johnw> startling: sure
01:39:52 <johnw> startling: the reader monad
01:40:00 <startling> yep
01:40:17 <johnw> startling: that's really a great way of thinking about it
01:40:27 <johnw> "it lets you work with values that don't exist yet"
01:40:38 <johnw> it's like an intention to work with something that will be a value when the monad is executed
01:41:26 <startling> yeah. fmap is similar
01:42:23 <Ferdirand> @pl \x ->  iterate (sort . zipWith (:) x) ([] <$ x) !! length x
01:42:23 <lambdabot> ap ((!!) . ap (iterate . (sort .) . zipWith (:)) ([] <$)) length
01:42:30 <akamaus> I've tried to install cabal-install using ghc-7.6.1, it failed on unix package, saying "fatal error: Signals.h: No such file or directory". Is it a known issue?
01:43:26 <johnw> akamaus: you'll run into more problems once you get past that one
01:43:47 <Twisol> startling: Is this correct? http://hpaste.org/74382
01:44:01 <akamaus> johnw, what do you mean ;)
01:44:47 <johnw> akamaus: mtl will fail to build
01:44:59 <startling> Twisol: it's too late for high-level thinking I think
01:45:04 <Twisol> startling :(
01:45:10 <startling> ):
01:45:12 <akamaus> johnw, nope, it already built, mtl-2.1.2
01:45:17 <Twisol> It looks like Applicative Reader lets you apply over a future value
01:45:21 <johnw> oh yeah?
01:45:23 <Twisol> a "value that doesn't exist yet"
01:45:44 <Twisol> you're currying something you don't even have, but it lets you compose your functions after the first argument anyways
01:45:47 <akamaus> yep, with cabal-install-1.14 built on ghc-7.4.2
01:46:25 <johnw> oh, how are you building cabal-install with ghc-7.6?
01:46:29 <johnw> i was trying with bootstrap.sh
01:46:36 <johnw> i didn't try cabal install cabal-install
01:47:01 <johnw> not that that should work anyway
01:47:03 <johnw> too late her
01:47:04 <johnw> e
01:47:18 <akamaus> johnw, what puzzles me about unix package, is that it verison 2.6 is already inluded. But cabal-install wants <2.6
01:47:49 <akamaus> johnw, yes, I tried to rebuild it
01:48:03 <akamaus> maybe I should just use my current binary..
01:48:11 <johnw> cabal-install is older than 7.6
01:48:12 <lpvb> I get this huge error when trying to compile statically: http://codepad.org/gtEcS8AY
01:48:15 <johnw> hack the .cabal
01:48:19 <johnw> oh, you probably did
01:49:04 <johnw> lpvb: aren't you missing -lssl?
01:49:05 <akamaus> I guess most packages are older than 7.6. Still it's tempting to try :)
01:49:19 <johnw> yeah, I was tempted too
01:49:34 <johnw> fortunately, <*> is keeping me busy enough as it is
01:49:59 <lpvb> johnw: thanks, that worked perfectly
01:50:17 <akamaus> could you build a significant part of haskell-platform?
01:50:22 <lpvb> oh
01:50:25 <lpvb> no it didnt
01:50:47 <lpvb> Linking Poindexter ...
01:50:49 <lpvb> gcc: error: unrecognized command line option ‘-ssl’
01:50:57 <lpvb> -optl-ssl?
01:51:16 <johnw> sure, give it a try!
01:51:30 <lpvb> I did that, I think it's supposed to be -optl-lssl
01:51:48 <lpvb> same error it looks like
01:51:57 <lpvb> meh, forget it
01:52:02 <lpvb> I'll just install gentoo on the webserver
01:52:09 <lpvb> centos is way too old
01:52:31 <johnw> centos 6 isn't too old
01:52:54 <lpvb> how do I get an up-to-date ghc?
01:53:18 <johnw> well, that I'd like to know too
01:53:28 <johnw> it took me over a week to finally get 7.4.2 going on OpenIndiana
01:53:40 <johnw> lpvb: http://rpmfind.net/linux/rpm2html/search.php?query=ghc
01:53:54 <johnw> there's a 7.0.4 RPM for centos 6
01:54:01 <johnw> that's let you bootstrap a 7.4.2
01:54:34 <lpvb> if I install gentoo everything would be up-to-date?
01:54:42 <johnw> i know 0 about gentoo
01:54:45 * hackagebot haskell-src-exts 1.13.4 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.13.4 (NiklasBroberg)
01:54:58 <lpvb> it's compile the latest source for every program
01:55:36 <startling> maybe
01:56:13 <johnw> is there a nice pretty printer for Haskell already packaged as an executable?
01:56:15 <lpvb> also, now that I know a little haskell, can someone explain the major differences between haskell, ocaml, ML, erlang, F# to me?
01:56:23 <johnw> i.e., just run it on somebody code and it's #haskell approved?
01:56:47 <johnw> lpvb: once I learn all of those, I'll get back to ya
01:57:15 <startling> lpvb: haskell is lazy, ocaml is strict and not-pure, ml is what ocaml was based on, dunno about F#
01:57:35 <bitonic> F# is a dialect of OCaml
01:57:56 <lpvb> does ocaml have a nice type system like haskell?
01:58:06 <lpvb> with type classes and stuff?
01:58:10 <startling> lpvb: no typeclasses
01:58:14 <startling> typeclasses are a haskell thing
01:58:17 <bitonic> no type classes.  but it has a nicer module system
01:58:23 <lpvb> how would you do stuff without typeclasses D:
01:58:53 <bitonic> lpvb: no problems here
01:59:30 <lpvb> bitonic: any advantages to using ocaml?
01:59:42 <bitonic> lpvb: I don't use OCaml
01:59:43 <bartavelle> strict execution model is simpler to reason about
01:59:51 <merijn> lpvb: ocaml is strict and doesn't have typeclasses, also not completely pure
02:00:02 <bartavelle> also it is more french
02:00:27 <merijn> F# is very similar to ocaml (as, I imagine, is SML)
02:00:59 <bitonic> F# is closer to OCaml than SML
02:01:25 <merijn> lpvb: Erlang is the most interesting (as in different from Haskell) of those languages, its syntax is ugly, though :(
02:01:51 <bitonic> merijn: that's not that much of a problem
02:01:56 <merijn> bitonic: Well, technically I said SML is similar to ocaml (which is a total WAG from my side)
02:02:19 <ion> I wish Haskell had Erlang’s bitstring syntax.
02:02:21 <bitonic> what I meant is that F# is more similar than OCaml than SML is
02:02:33 <merijn> lpvb: The interesting thing about Erlang is very nice built in support for the actor model and distribution
02:02:42 <merijn> lpvb: Also, hot code swapping seems pretty neat
02:02:48 <merijn> No static typing, though
02:03:03 <merijn> ion: Word.
02:03:13 <merijn> Erlang's bitstring syntax looks nice
02:03:51 <asda8> I have an issue with exceptions: I have a top-level exception-handler which wraps my whole program and only logs any exceptions
02:04:20 <asda8> now I want to catch an exception locally and handle them differently
02:05:07 <asda8> but if I define another catch inside the action that is already in the first catch "block", neither of the handlers gets called
02:05:50 <mrcarrot> Can anyone provide some help on how to get "gloss" installed on debian?
02:06:17 <mrcarrot> There is no ready package and cabal install gloss gives this error:
02:06:18 <mrcarrot> Graphics/Gloss/Internals/Interface/Backend/GLUT.hs:126:15:
02:06:18 <mrcarrot>     Not in scope: `void'
02:08:02 <merijn> asda8: What type of exception are you trying to catch locally?
02:08:10 <merijn> Is it being thrown by code you wrote?
02:08:27 <vrooom2> You have 2 supposedly unbreakable light bulbs and a 100-floor building. Using fewest possible drops, determine how much of an impact this type of light bulb can withstand. (i.e. it can withstand a drop from 17th floor, but breaks from the 18th).
02:08:28 <vrooom2> Note that the ever-popular binary search will give you a worst case of 50 drops. You should be able to do it with under 20.
02:08:40 <asda8> merijn: no, it's thrown by prelude read
02:08:48 <vrooom2> If I start dropping from the 10th floor this will give a worst case of 19
02:08:50 <merijn> asda8: oh, don't use Prelude.read
02:09:16 <frerich> vrooom2: Sounds like a job interview question, but what does this have to do with Haskell? :-)
02:09:23 <merijn> asda8: Depending on your version of GHC use readMaybe or write/copy your own version using reads
02:09:26 <merijn> :t reads
02:09:28 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:09:43 <merijn> > reads "10" :: [(Int, String)]
02:09:44 <lambdabot>   [(10,"")]
02:09:46 <vrooom2> 5th -> 24
02:09:47 <merijn> > reads "10" :: [(Int, Bool)]
02:09:48 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
02:09:48 <lambdabot>         against inferred type ...
02:09:56 <asda8> merijn: ok, I'll change that
02:09:56 <merijn> > reads "10" :: [(Bool, String)]
02:09:57 <lambdabot>   []
02:09:59 <merijn> eh, typo
02:10:13 <johnw> GHC 7.0.4 is in Fedora EPEL
02:10:14 <asda8> merijn: why doesn't catching the exception from read work?
02:10:23 <merijn> asda8: Then you can use case of to detect an error and use Maybe (or something similar) to find the error
02:10:27 <asda8> merijn: my program keeps running, but the handler isn't called
02:10:29 <vrooom2> so how do i motivate this? (yes it is a job interview questions foudn on the internets i think its from google originally) just wondering hat smart haskell people think. i want to motivate it mathematically
02:10:40 <saep> mrcarrot: It builds fine on my debian system. Which version of ghc do you use and which version of gloss did you try to install?
02:10:49 <merijn> asda8: I don't know why it doesn't work tbh, I just think using read for this is bad program design
02:11:15 <asda8> merijn: ok, I'll change it then
02:11:33 <Botje> vrooom2: you tie the bulbs to a string, that saves you the time of getting them back up to the Nth floor
02:12:03 <vrooom2> Botje: doesnt really help me does it
02:12:14 <johnw> happily installing on CdeEntOS 6 now...
02:12:17 <johnw> CentOS 6
02:15:19 <frerich> vrooom2: I think I would just quit the interview because I don't like jobs which use such brain teasers during an interview (the question is relatively common in tests nfortunately, it's the "egg drop problem"), at least if it's about a software engineering position.
02:16:04 <dobblego> @type \a t -> (\e -> if e then t else a) =<< a
02:16:05 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
02:17:13 <johnw> vrooom2: how would binary search give a worst case of 50?
02:17:45 <johnw> > log 100
02:17:46 <lambdabot>   4.605170185988092
02:17:54 <merijn> johnw: The problem with binary search and only two bulbs would be that if the bulb breaks at 18 you'll lose both bulbs before you find the result
02:18:03 <johnw> ah
02:18:03 <vrooom2> johnw: drop qt 50 then you have to try 49 from 1 to 49 at worst case
02:20:30 <johnw> i still don't get it
02:20:49 <johnw> start at 5 and move up by 5 each time
02:20:51 <johnw> that's 20 drops
02:20:52 <merijn> Am I right that one of the main differences between type families and type classes is that a type family can have (for example) return values/arguments that are determined by the parameterised type, but not explicitly appearing in the families type?
02:21:29 <johnw> i guess worst case is if it breaks at 100, you have to go from 96-99 one at a time
02:21:59 <vrooom2> if it holds at 95 youd do 97 or 98 not 100 i guess
02:22:20 <johnw> or, start at 20.  If it breaks, go from 1-19 one at a time.  If not, then go from 25-100 5 at a times :)
02:22:44 <merijn> i.e. how I can have "GenericMap k v" where "GenericMap Bool" just uses a tuple to store a value while "GenericMap Int" could use a tree (where the tree and tuple never appear in the signature of the class)
02:25:05 <timthelion> johnw: the square root of 100 is 10.  So go by tens from the bottom.  That gets you 10 drops, and you'll then have at most 9 drops once the first one breaks.  So it takes 19 drops.
02:25:34 <cods> Hi. I'm trying some concurrent haskell code, but I'm surprised by the drop of performance starting at -N6 here: http://hpaste.org/74383
02:25:37 <johnw> ah, gotcha
02:25:38 <cods> Is that expected?
02:25:54 <johnw> i'll go by fibonacci
02:26:33 <timthelion> johnw: Good followup question, is, if it takes you a minut per floor to go down and then up again, is this naive, by tens method still the fastest.
02:27:20 <timthelion> johnw: how does fibonacci help?
02:27:39 <johnw> becasue every haskell programmer knows fibonacci ;)
02:27:42 <johnw> i was just being facetious
02:27:46 <Twisol> vroom2: I've seen that problem before, so I know the optimal answer already. D:
02:28:08 <johnw> the answer really is to save the light bulbs and drop the interviewer
02:28:26 <timthelion> johnw: Oh, the other question, is if you can drop both at the same time, but from different floors(aka paralel processing) then can you think of a faster way that would take more drops.
02:28:52 <Twisol> the way I see the problem, it's like a skip list
02:28:53 * timthelion doesn't see why people hate those questions so much.
02:29:42 <timthelion> I mean, they're certainly better than asking if you've memorized the types of prelude or something.
02:30:17 <Twisol> there's some N minimum number of drops necessary, so the goal is to build a choice graph with a maximum depth of N
02:30:51 <timthelion> Twisol: you math people, know how to make the simplest damned things sound complex.
02:31:09 <Twisol> timthelion: it's because the picture in our heads is so beautiful
02:31:11 <johnw> timthelion: omg, yes they do
02:31:37 <merijn> timthelion: As John von Neumann said: If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is.
02:32:33 <timthelion> :D
02:32:44 <Botje> heh heh
02:34:46 <johnw> night
02:36:20 <Twisol> I stayed up too late talking about <*> and $ and skip lists
02:36:29 <Twisol> I missed the deadline for my physics homework >_<
02:37:29 <timthelion> Twisol: ! honestly?
02:37:54 <ion> @ask chrisdone Is your modified version of mueval available somewhere? I didn’t see it on your GitHub page.
02:37:54 <lambdabot> Consider it noted.
02:37:55 <Twisol> Well, yes.
02:38:18 <Twisol> according to the grading policy, however: "Late submissions: reduce the score for any item completed late by 20% for each day late, but never by more than 40%."
02:38:27 <timthelion> Twisol: Just tell your teacher what you're doing, he'll/she'll understand.
02:39:01 * timthelion hates homework.
02:39:02 <Twisol> I should be okay as long as I get this done ASAP
02:39:08 <Twisol> and then do the prelecture due before tomorrow ^_^
02:39:18 <timthelion> work
02:39:18 <merijn> The "Fun with Type Funs" paper is blowing my mind, even though I'm not even entirely sure what the exact differences with type classes are...
02:39:40 <Twisol> timthelion: So far I only appear to be losing 2% per item.
02:40:40 <timthelion> Twisol: work and pray, https://en.wikipedia.org/wiki/Pray_and_work
02:40:51 <timthelion> oh, damn, shouldn't have linked you to wikipedia. Sorry.
02:41:17 <Twisol> It's not TVtropes. I'm okay.
02:46:35 <zomg> I have a list of possible types, let's say Foo, Bar and Baz. I must also be able to get a list of all possible types... Is there some simple trick to get a list of all possible constructors of a custom type?
02:46:47 <Twisol> At runtime?
02:46:58 <zomg> eg. data Types = Foo | Bar | Baz... I was looking at enum but not entirely sure if it's suitable as I didn't get it working
02:47:01 <zomg> Nah compile time is fine
02:47:07 <hsnz> Can I list all functions linked to a type class in ghci?
02:47:36 <bitonic> hsnz: :info
02:47:40 <bitonic> @info Num
02:47:40 <Twisol> hsnz: part of the definition of the class, or just using it?
02:47:40 <lambdabot> Num
02:47:46 <bitonic> ah. no.
02:47:59 <zomg> I would prefer to not have to write a function which just says [Foo .. Baz] since let's say a new type is added after Baz
02:48:02 <Twisol> I usually turn to Hoogle…
02:48:02 <bitonic> hsnz: no no, :info works, but not in lambdabot
02:48:03 <zomg> which would obviously break it
02:48:07 <akamaus> zomg, try deriving Enum
02:48:13 <Twisol> zomg: Bounded?
02:48:18 <mrcarrot> saep: ghc --version: The Glorious Glasgow Haskell Compilation System, version 6.12.1
02:48:36 <mrcarrot> saep: It is what comes as default in Debian.
02:49:05 <bitonic> mrcarrot: ooooold.
02:49:09 <zomg> I tried using minBound Types however it's giving me an error about the constructor not existing since that's the type name and not a constructor
02:49:22 <zomg> I must be just thinking about it wrong..
02:49:22 <zomg> =)
02:49:25 <akamaus> zomg, undefined :: Type
02:49:37 <akamaus> minbound $
02:50:00 <zomg> Sorry? :D
02:50:31 <hsnz> bitonic: Thanks alot. And hoogle looks great, twisol.
02:50:39 <Twisol> :)
02:51:02 <saep> mrcarrot: okay, i'm using ghc from experimental (7.4.2-2)
02:51:10 <shachaf>     Add -XExplicitNamespaces to enable using 'type' in import/exports. This extension is implied by: * TypeOperators: so that we can import/export things like (+) * TypeFamilies: because associated type synonyms use "type T" to name the associated type in a subordinate list.
02:51:22 <zomg> I mean doing [Foo .. Baz] works if it's enum/bounded but it would still break if a new type is added after Baz, like Foo | Bar | Baz | Quux
02:51:30 <zomg> Now [Foo .. Baz] is missing the new type
02:54:42 <zomg> Hm I think listTypes = [asTypeOf minBound Foo .. asTypeOf minBound Foo]  works...
02:54:42 <Twisol> [minBounded..maxBounded] ?
02:54:51 <Twisol> or… whatever that is
02:55:04 <zomg> (err the other one is obviously supposed to say maxBound)
02:55:50 <Twisol> as an aside: would the people stomping on the floor upstairs please stop! :|
02:57:56 <identity> :hoogle Parser a -> Maybe (Parser a)
02:58:06 <identity> ?hoogle a -> a
02:58:07 <lambdabot> Prelude id :: a -> a
02:58:07 <lambdabot> Data.Function id :: a -> a
02:58:07 <lambdabot> GHC.Exts breakpoint :: a -> a
02:58:09 <identity> there we go
02:58:13 <identity> ?hoogle Parser a -> Maybe (Parser a)
02:58:13 <lambdabot> No results found
02:58:16 <identity> meh
02:58:40 <zomg> Oh wait I'm stupid
02:58:52 <zomg> listTypes = [minBound .. maxBound] ...
02:59:04 <zomg> See I knew I was thinking of it completely wrong
02:59:10 <zomg> =)
02:59:46 * hackagebot ChasingBottoms 1.3.0.5 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.5 (NilsAndersDanielsson)
02:59:48 * hackagebot haskell-src-exts 1.13.5 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.13.5 (NiklasBroberg)
02:59:54 <Twisol> zomg: :D
03:00:10 <Twisol> zomg: That's an interesting sort of trick. What are you using it for?
03:00:55 <zomg> Well right now I just needed to get a list of possible types in order to list them in JavaScript code being output by the application
03:01:04 <mamihu> hi, anyone here having experience with building haskell-platform from source on Linux?
03:01:51 <identity> Anyone happen to know if there's a combinator in Parsec which returns Maybe? As in Just value for success, Nothing for failure?
03:02:29 <identity> I'm thinking option, which is: a -> f a -> f a, but then I need to return (Just value) from the parser it's trying
03:02:48 <bitonic> identity: do you want it to be backtracking?
03:03:05 <identity> bitonic: Aye. But afaik, attoparsec always backtracks on failure
03:03:30 <bitonic> identity: oh, attoparsec. `foo x = (Just <$> x) <|> return Nothing'
03:03:43 <identity> bitonic: oh, of course
03:03:48 <identity> that's ingenious
03:03:55 <bitonic> I'm ingenious.
03:04:13 <identity> bitonic: http://farm5.staticflickr.com/4119/4876696414_d3f62d18be_z.jpg
03:04:22 <identity> (sfw, ofc)
03:04:29 <bitonic> ehe :)
03:07:56 <amosr> mamihu: is there any reason you want haskell-platform? isn't it terribly out-of-date?
03:09:21 <amosr> oh, I guess not
03:10:52 <bitonic> amosr: it got out of date yesterday
03:11:33 <mamihu> to be honest, I'm completely new to haskell, my task is to build it from source
03:12:23 <qwr> mamihu: i've always just used debian haskell packages, if those are available
03:13:18 <typoclass> mamihu: i'd go with the binaries, unless there's some specific reason that you must build it from source. it's rarely necessary.
03:14:11 <amosr> what distro are you using?
03:14:24 <mamihu> sle11/64
03:17:43 <mamihu> I try to build using ghc 7,4.1
03:18:17 <merijn> amosr: Haskell Platform terribly out of date? huh?
03:20:42 <knz> :t lookup
03:20:43 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
03:20:44 <amosr> oh, it just feels like it's always a few versions behind on ghc. I might be imagining it
03:21:21 <knz> :t IntMap.lookup
03:21:22 <lambdabot> Couldn't find qualified module.
03:21:31 <lpvb> what's the best way to get GHC?
03:21:52 <hpaste> timthelion pasted “What is the type of b at line 16?” at http://hpaste.org/74387
03:22:07 <timthelion> Can someone tell me what the type of be is, at line 16 of my paste?
03:22:30 <timthelion> s/be/b/
03:22:33 <timthelion> :O
03:22:51 <merijn> lpvb: Install haskell platform
03:23:12 <timthelion> lpvb: depends on your OS
03:23:21 <lpvb> so many language extensions
03:25:45 <timthelion> Now can someone tell me the type of b ? Please?  http://tinyurl.com/cozynte
03:27:17 <typoclass> timthelion: what's the compiler error you're getting?
03:27:41 <timthelion> typoclass: no error.  I just want to know the type of b.
03:27:48 <zomg> timthelion: maybe next time instead of a cat picture, you should actually link the paste :p
03:28:03 <timthelion> zomg: The paste is linked to
03:28:10 <timthelion> http://hpaste.org/74387
03:28:18 <typoclass> zomg: he posted it a few minutes ago
03:28:28 <fmap> ghc-mod says `Foo a'
03:28:30 <zomg> Well it scrolled too far for me by now =)
03:29:12 <timthelion> fmap: That confuses me, how can I have an actuall type of Foo a?
03:29:16 <identity> If it was possible, I would have sexual intercourse with attoparsec/parsec.
03:29:37 <JuanDaugherty> TMI
03:29:40 <timthelion> identity: love breaks all boundaries.  Of course it's possible.
03:29:47 <fmap> timthelion: maybe because AnyFoo is Foo a → AnyFoo?
03:30:23 <typoclass> timthelion: i would compile it and in the error message look carefully at the lines "expected type" vs. "actual type". if it compiles without error, i'd load it in ghci and do ":t". you could insert a function "f (AnyFoo b) = b" and do ":t f x" then
03:30:31 <timthelion> fmap: but what does that even mean?  How can I actually HAVE a foo a.  Like a function can take a Foo a, but a Value must have a non algebraic type!
03:30:59 <timthelion> typoclass: I'll try that.
03:31:35 <fmap> timthelion: what do you expect b to be if you have AnyFoo and unpack it with AnyFoo ∷ Foo a → AnyFoo?
03:32:02 <timthelion> fmap: I expect that to be a compile time error.
03:32:13 <timthelion> but it's not.
03:32:37 <fmap> what error?
03:32:50 <timthelion> fmap: Error, ambiguous type Foo a
03:35:33 <timthelion> fmap: for example. g (AnyFoo b) = b IS an error.
03:38:00 * timthelion thinks this may be a bug :(
03:38:48 <shachaf> You keep saying that things are compiler bugs.
03:39:11 <timthelion> shachaf: when was the last time I said something was a compiler bug?
03:39:21 <shachaf> There was that bug report.
03:39:23 <shachaf> Also other times.
03:40:51 <timthelion> shachaf: Why are you turning a technical discussion into a personal attack?
03:42:03 <timthelion> shachaf: I have reported 5 bugs.  Two were marked by design two where fixed, and the third(which is currently marked as "new" is indisputably a bug http://hackage.haskell.org/trac/ghc/ticket/7190
03:42:51 * shachaf isn't sure what you're talking about.
03:43:46 <shachaf> Both with regard to personal attack and with regard to this code.
03:44:19 <shachaf> Is the bug that that file compiles?
03:44:46 <typoclass> timthelion: i don't think he meant it as a personal attack. i don't think there's anything wrong with reporting compiler bugs.
03:44:47 * hackagebot hxt-cache 9.0.2.1 - Cache for HXT XML Documents and other binary data  http://hackage.haskell.org/package/hxt-cache-9.0.2.1 (UweSchmidt)
03:44:48 <shachaf> You have non-exhaustive patterns, which -Wall would probably tell you about.
03:45:27 <ivanm> timthelion: I see a main in both profiling reports
03:45:30 <timthelion> typoclass: Please.  I think my concern is valid.  A pattern is like a function. It should behave similarly on the type level.
03:45:30 <ivanm> what's the problem?
03:45:48 <ivanm> sorry, I misread
03:45:59 <timthelion> ivanm: look again.
03:45:59 <ivanm> blank lines or separate blocks would help :)
03:46:27 <timthelion> ivanm: I copy pasted directly from the terminal.  Seems that I'm less likely to make a mistake/misrepresent something that way.
03:47:15 <ivanm> timthelion: sure, but split it up into multiple blocks of monospace text
03:47:37 <timthelion> Perhaps I'll do that next time.
03:49:47 <timthelion> The point was though, I'm not just thinking everything is a bug wantonly.  I'm actually FINDING bugs!
03:56:22 <hpaste> gabor pasted “Overlapping -- why??” at http://hpaste.org/74389
03:56:59 <benmachine> timthelion: still, I don't think it's fair to call "you keep saying that things are compiler bugs" a personal attack
03:59:20 <timthelion> benmachine: I find something that is inconsistent,  I say I think it's a bug to see if anyone agrees or dissagrees.
03:59:32 <timthelion> benmachine: so far no one has told me if they agree or dissagree.
03:59:34 <ivanm> well, can't help gabor when he's not here...
03:59:55 <hiptobecubic> Foo
03:59:58 <hpaste> me annotated “Overlapping -- why??” with “Overlapping -- why?? (annotation)” at http://hpaste.org/74389#a74391
04:00:15 <benmachine> timthelion: just have a little patience and... durability, is all I'm asking
04:00:25 <hiptobecubic> Read the paste ivanm
04:00:37 <hiptobecubic> Can't come apparently
04:00:40 <ivanm> hiptobecubic: I did
04:00:46 <ivanm> someone suggesting they join the channel
04:02:32 <hiptobecubic> Well he got his answer at least
04:02:36 <beaky> what does bind mean in FP?
04:03:28 <hpaste> gabor annotated “Overlapping -- why??” with “Overlapping -- why?? (annotation) (annotation)” at http://hpaste.org/74389#a74393
04:03:48 <shachaf> beaky: Same thing it means in Mordor.
04:03:55 <benmachine> timthelion: note that even though none of your constructors build values of type Foo a, the type Foo a is still inhabited
04:03:57 <adnam> beaky: could be (>>=), depends on the context
04:04:09 <benmachine> timthelion: e.g. by bottom
04:04:16 <benmachine> timthelion: so why can't it be inhabited by b?
04:04:23 <typoclass> beaky: probably "assign value to", as in "let x = 4" which binds x to 4. in haskell specifically, bind is also the name of (>>=), which is one of the fundamental operations in one quite often-used typeclass
04:04:30 <shachaf> beaky: Huh?
04:04:41 <shachaf> s/beaky/benmachine/
04:04:42 <beaky> yeah what does >>= do?
04:04:53 <timthelion> benmachine: the thing is, that if the pattern where a function, it's type would be invalid.  You cannot have AnyFoo -> Foo a
04:05:21 <shachaf> Patterns aren't functions.
04:05:33 <shachaf> If things worked the way you suggest there would be no point to GADTs.
04:05:50 <shachaf> Are you compiling your code with -Wall like I said?
04:05:55 <benmachine> timthelion: I think that might be a different issue, though
04:06:03 <benmachine> timthelion: I mean, AnyFoo is an existential type
04:06:21 <benmachine> timthelion: so you can't have AnyFoo -> Foo a because then the caller can pick a, and they might pick the wrong one
04:06:35 <shachaf> AnyFoo -> exists a. Foo a
04:06:39 <benmachine> right
04:06:46 <timthelion> benmachine: the only case where such type ambiguity exists, is like the value 1 :: (Num a) => a... But that's different because 1 gains a concrete type from context.  So in show 1. 1 already has type Int
04:06:57 <shachaf> What?
04:06:58 <typoclass> beaky: long story short, it chains two actions together, passing a value. "readSomething >>= print" would run the action readSomething (think stdin), then the action print, passing the value that was read into print
04:07:01 <timthelion> benmachine: right.
04:07:10 <shachaf> That's a complete non-sequitur. :-(
04:07:17 <benmachine> timthelion: not everything ever gets a concrete type
04:07:27 <typoclass> shachaf: what is?
04:08:03 <timthelion> benmachine: Are you sure there are other instances of post compilation type inconcreteness?
04:08:08 <shachaf> The Num thing.
04:08:22 <benmachine> timthelion: well, let x = const 7 id -- what's the type of id here?
04:08:24 <shachaf> There's absolutely no "type inconcreteness" here.
04:08:31 <beaky> so >>= is basically currying?
04:08:43 <benmachine> I think shachaf may be right that this isn't related to your problem :)
04:08:48 <shachaf> beaky: No.
04:09:06 <typoclass> beaky: not really, no
04:09:22 <shachaf> In "show 1", "1" doesn't have the type Int.
04:09:26 <shachaf> Unless you change the defaulting rules.
04:09:34 <shachaf> (Or the type of show.)
04:09:45 <timthelion> how does GHC figure out what instance of Show to use?
04:09:49 <typoclass> > map pred [2..5] -- beaky, this is a normal application of a 2-argument function called 'map'
04:09:50 <lambdabot>   [1,2,3,4]
04:09:53 <benmachine> shachaf: ...it has type Integer instead
04:10:14 <benmachine> > let x = 1 in (show x, typeOf x)
04:10:15 <lambdabot>   ("1",Integer)
04:10:23 <shachaf> benmachine: Yes.
04:10:33 <beaky> right
04:10:34 <typoclass> > let f = map pred in f [2..5] -- this is applying it to only 1 arg, and then later to 1 more arg
04:10:34 <timthelion> Still a concrete type though.
04:10:35 <lambdabot>   [1,2,3,4]
04:10:56 <beaky> so the second is currying
04:11:00 <benmachine> timthelion: right. any *constrained* type variable has to end up as a concrete type, so you know which instance to use
04:11:08 <benmachine> timthelion: but unconstrained type variables don't
04:11:19 <shachaf> timthelion: This has nothing to do with concrete or asphalt or anything.
04:11:48 <benmachine> (oh, when I say a concrete type, I'm actually lying, I just mean a type with an instance)
04:11:49 * shachaf wonders whether there's a question.
04:12:05 <benmachine> shachaf: the original question was "what is the type of b in http://hpaste.org/74387"
04:12:07 <typoclass> beaky: yup. there's one more tiny technicality, but basically yes.
04:12:39 <typoclass> "map pred" can be called curried, it still expects one more argument, aiui
04:12:50 <benmachine> timthelion: oh, as a slightly less silly example of non-concreteness, tell me the type of x in "let x = [] in length x"
04:12:57 <beaky> I love currying
04:13:09 <shachaf> beaky: It's "Foo x" for some x you don't know.
04:13:33 <hiptobecubic> beaky: yes.  It is great
04:14:30 <timthelion> benmachine: It seems strange to me, that I can have a Foo a with truely ambiguous type(even at runtime) but I cannot have [Foo a] with multiple types for a
04:14:36 <shurikas> @type (show . read)
04:14:37 <lambdabot> String -> String
04:15:07 <hiptobecubic> Why
04:15:27 <benmachine> beaky: for some reason, shachaf thinks you're me
04:15:41 <benmachine> damn initial name segments.
04:15:48 <timthelion> hiptobecubic: that Why was at me?
04:15:53 <ivanm> timthelion: huh? why would you expect to be allowed to have [a :: Foo Int, b :: Foo Double] ?
04:15:57 <hiptobecubic> Different types and unknown single type seem pretty different
04:16:04 <shachaf> benmachine: Hey, I can't be expected to type three characters at 04:15!
04:16:23 <benmachine> shachaf: :P go to bed
04:16:55 <typoclass> solution: address everybody with 'dude'
04:17:02 <hiptobecubic> Bro
04:17:06 <timthelion> ivanm: I wouldn't.  But If I can have the exticential type AnyFoo, which is in every case convertable to Foo a... and have a list [AnyFoo] there is something fishy.
04:17:30 <ivanm> you mean data AnyFoo = AnyFoo {forall a . Foo a} ?
04:17:46 <timthelion> ivanm: did you see my paste?
04:17:49 <ivanm> dude, then you get confused as to which dude you're referring to as dude dude
04:17:56 <ivanm> timthelion: nope
04:17:58 <hiptobecubic> The list limits it to one type, no?
04:18:05 <shachaf> no way, dude. it's totally clear
04:18:12 <merijn> hiptobecubic: Not when using existentials
04:18:13 <hiptobecubic> I dunno dudes
04:18:14 <shachaf> timthelion: It's not convertible to (forall a. Foo a)
04:18:23 <shachaf> It's convertible to (Foo a) for some specific a which you don't know.
04:18:24 <timthelion> http://hpaste.org/74387
04:18:27 <merijn> hiptobecubic: [forall a . a] works just fine
04:18:32 <shachaf> timthelion: Have you compiled that file with -Wall yet?
04:18:56 <timthelion> shachaf: I know it will throw an error saying that there is an incomplete pattern in the case statment :)
04:18:56 <ivanm> oh, you're using GADTs
04:19:01 <ivanm> I haven't spent the time to really grok them yet
04:19:49 <benmachine> ivanm: well, only using them here to get an existential type
04:19:50 <shachaf> ivanm: That's just a regular existential type.
04:19:51 <timthelion> merijn: really, I can have [forall a . a]??? Why the heck am I using these Existencials then???
04:20:12 <shachaf> Because [forall a. a] isn't [exists a. a]
04:20:26 <benmachine> [forall a. a] is an impredicative type, those are scary :P
04:20:27 <hpc> [forall a. a] isn't very useful, either
04:20:35 <shachaf> timthelion: You should read about how existentials and forall work.
04:20:37 <benmachine> yeah , it's also just a list of bottoms
04:20:51 <shachaf> You seem to have several misconceptions about them...
04:21:02 <hpc> benmachine: it's a heterogenous list that you can't do anything with
04:21:24 <shachaf> hpc: You can do everything with!
04:21:28 <benmachine> hpc: are you sure? it seems to me it should be a list of things with type forall a. a, and that type has only one inhabitant
04:21:30 <hpc> !!
04:21:32 <shachaf> You just can't make one.
04:21:49 <merijn> timthelion: "[forall a .a]" doesn't let you do much :p
04:21:57 <merijn> timthelion: Might as well have [()] instead :p
04:22:03 <shachaf> merijn: It lets you do anything except make it!
04:22:09 <timthelion> hpc: Can I not have a [Bar,Baz]::(forall a. a) => [Foo a] and map a function that takes Foo a across it?
04:22:09 <identity> Hmm. When using attoparsec, the combinators it provides in D.A.Combinators are generic. Specifically, many1 is (f a -> f [a]). When using OverloadedStrings, and many1 with a Parser Char, should an implicit conversion not happen here?
04:22:16 <benmachine> shachaf: [] fits the type, no?
04:22:23 <benmachine> shachaf: and [undefined], presumably
04:22:29 <shachaf> timthelion: That's not even wrong.
04:22:29 <identity> from [Char] to Text, that is
04:22:35 <shachaf> benmachine: Well, sure.
04:22:45 <benmachine> timthelion: that type signature doesn't parse
04:22:50 <hpc> benmachine: oh you are right
04:22:59 <shachaf> identity: OverloadedStrings is just about string literals. "things that look like this"
04:23:06 <shachaf> It's not magical conversion between types.
04:23:11 <identity> shachaf: I see
04:23:11 <benmachine> timthelion: if you had a type signature [forall a. Foo a] then you wouldn't be able to put Bars or Bazzes in it
04:23:40 <identity> shachaf: Any suggestion on how to do this, then?
04:23:42 <timthelion> benmachine: Why not?  Bar :: Foo BarT and Baz :: Foo BazT
04:23:44 <merijn> benmachine: Presumably he means something like "[forall a . Foo a => a]" where Bar and Baz are foo instances?
04:23:50 <shachaf> A value of type (forall a. Foo a) has to be completely polymorphic.
04:24:06 <benmachine> merijn: Foo isn't a class
04:24:14 <shachaf> I can type these sentences in here but they've been typed hundreds of times before in various documents that you can look up.
04:24:16 <ivanm> identity: you can always use fromString from the IsString class (that OverloadedStrings uses under the hood)
04:24:20 <shachaf> So there's no point.
04:24:24 * shachaf goes to sleep instead.
04:24:35 <ivanm> oh, wait, you want dual-type parser combinators
04:24:37 <benmachine> timthelion: what you're asking for is [exists a. Foo a], but that's pseudo-syntax inasmuch as GHC doesn't have an exists keyword
04:24:58 <merijn> benmachine: Oh, I didn't actually read the example :p
04:25:09 <identity> ivanm: I thought about that. But that seems "hackish"
04:25:09 <hiptobecubic> Could you have a list of actual different types then?
04:25:18 <Twisol> Physics homework: done! I'm going to bed now.
04:25:30 <benmachine> timthelion: in that case, you could make a list with Bars and Bazzes in, but you'd be limited in what you could do with the stuff you took out
04:25:32 <Cale> All the elements of a list must have the same type.
04:25:35 <timthelion> hiptobecubic: You can, with the AnyFoo described in the paste.
04:25:36 <ivanm> identity: there are typically faster variants of many1 for Text and ByteString that return a Text or ByteString
04:25:42 <ivanm> and they really are much faster
04:25:55 <Cale> However, you can, in various ways, form types which encode what is similar about a bunch of things which you want to put into a list.
04:25:58 <identity> ivanm: I see. Speed is not an issue as such, but I guess I may have overlooked a combinator for this purpose
04:26:01 <shachaf> Yay, Cale
04:26:03 * shachaf sleep
04:26:06 <benmachine> :P
04:26:12 <Cale> You wouldn't be putting them together in a list if they didn't share some common interface.
04:26:23 <Cale> If you can decide what that interface is, your problem is solved.
04:26:38 <Cale> Because you can do one of a few things:
04:27:07 <Cale> 1) Collect all the pieces of the interface (a bunch of functions, usually) together into a record type and put those records in a list instead.
04:27:18 <ivanm> Cale: you know a lot of stuff, maybe you know this: I have a function gen that generates a list of graphs; each graph is O(n) to generate (only considering per-output O(...) ); if I then apply a filter to that list such that I have an O(n) discard rate, what is the resulting O(...) of the results? O(n^2) ?
04:27:44 <Cale> 2) Define a typeclass and make an existential type for things having an instance of that class.
04:27:52 <benmachine> ooh, the computing and technology student society at Cambridge wants speaker suggestions
04:28:07 <benmachine> I think they already had SPJ last year, anyone know any other good locals?
04:28:23 <Cale> ivanm: O(n) discard rate?
04:28:41 <hiptobecubic> Removal?
04:29:04 <Cale> ivanm: Do you mean it takes O(n) time to evaluate the Graph -> Bool function you're filtering with?
04:29:09 <ivanm> Cale: for every value that's kept, some g(n) = O(n) are filtered out
04:29:23 <benmachine> ivanm: wait, that's different
04:29:44 <benmachine> ivanm: would half of your items being discarded fit the description?
04:30:00 <hiptobecubic> I'm confused
04:30:06 <ivanm> as I'm solely concerned with the runtime per generated graph, my logic was that if it's f(n) to generate each one, and I discard them at a rate of g(n), then the total runtime is f(n)*g(n) = O(n) * O(n) = O(n^2)
04:30:19 <ivanm> benmachine: something like that, yes
04:30:35 <ivanm> benmachine: that that "1/2" factor depends on `n' (approximately)
04:30:35 <Cale> What do you mean about "the resulting O(...) of the results"? Are you trying to count how many there are or how long it'll take to compute them?
04:30:45 <benmachine> ivanm: well, that's a no, then :P
04:30:50 <benmachine> on account of how 1/2 does not depend on n
04:31:06 <ivanm> Cale: how long
04:31:14 <benmachine> ivanm: wait wait wait... what is n?
04:31:22 <ivanm> number of nodes in the graph
04:31:27 <benmachine> ok
04:31:36 <benmachine> hmm
04:31:45 <benmachine> fair enough, ignore me
04:32:10 <Cale> ivanm: If it takes O(n) time to generate each graph and you expect to compute O(n) graphs to produce one element of the result, then each result costs expected O(n^2) time to compute
04:32:52 <ivanm> Cale: right, that's what I figured
04:32:59 <benmachine> ivanm: you ought to be clear about whether you're talking average- or worst-case
04:33:04 <ivanm> people in -blah were trying to tell me it was O(O(n)) :/
04:33:12 <hiptobecubic> What
04:33:13 <Cale> wtf is O(O(n))?
04:33:19 <ivanm> Cale: exactly my point!
04:33:52 <benmachine> I think it's O(n), if it's anything
04:33:59 <hiptobecubic> O . O $ n
04:33:59 <adnam> the worst worst case
04:34:05 <sipa> i'd say O() is transitive
04:34:15 <ivanm> now I've got to work out whether my discard rate is really O(n) or not; the "theoretical guesstimate" is O(n), but the numbers in practice don't seem to be :s
04:34:28 <timthelion> hiptobecubic: are you shure that wouldn't be 2O(n)?
04:34:38 <timthelion> That is two O and not twenty
04:35:03 <ivanm> g(5) = 0; g(8) = 0; g(11) = 0.314, g(14) = 0.484; g(17) = 0.588; g(20) = <still calculating>
04:35:27 <hiptobecubic> Maybe it IS 20(n)
04:35:50 <timthelion> hiptobecubic: ;) possible, but unlikely
04:35:54 <hiptobecubic> How is that On
04:36:40 <timthelion> I hope everyone is on the same page that Cale answered the question 5 minutes ago?
04:37:28 <ivanm> heh, I am
04:37:44 <hiptobecubic> I'm on an iPod. The pages are small
04:38:06 <flux> O(Ω(n)), hmm..
04:40:13 <hpc> O() can't be composed
04:40:21 <hpc> it takes an expression and returns a set of expressions
04:40:22 <hiptobecubic> This type level prelude effort is blowing my mind
04:40:51 <hpc> and an algorithm runs in O(expr) time if its actual runtime is an ELEMENT of that set
04:40:53 <hiptobecubic> A set? How so
04:41:22 <typoclass> ivanm: i thought the consensus was that O is a good description on a theoretical processor, but it's more complicated on actual ones. i thought there's usually no direct relation between actual measurements and theoretical O values
04:41:31 <hiptobecubic> You mean the coeff?
04:41:52 <hpc> typoclass: O() deals with asymptotics
04:42:16 <hiptobecubic> The o values are just for theimitung case of huge input
04:42:20 <typoclass> hpc: yeah
04:42:21 <timthelion> typoclass: there isn't.  It turns out to be a pretty BS measurement :(
04:43:12 <ivanm> typoclass: this is an algorithms paper.  As part of it I need to specify a complexity of my algorithm
04:43:14 <timthelion> Especially if each operation allocates memory.  Then you're really screwed in terms of theoretical measurement.
04:43:55 <hiptobecubic> Well sure, you make a lot of assumptions
04:43:55 <ivanm> in practice, laziness + sharing means that my actual code is much less
04:45:23 <typoclass> ivanm: sure, this was just because you noted your measurements didn't fit the O prediction at all. i'm not arguing against O notation.
04:45:42 <ivanm> *nod*
04:46:05 <Cale> O really morally takes a function and produces a set of functions
04:46:28 <Cale> But people who use it are bad at notation
04:46:31 <Cale> usually
04:47:25 <Cale> (or at least, willing to abuse notation a little more than usual to save a few symbols)
04:49:07 <merijn> Would there happen to be an example of a (pseudo)dependently typed list somewhere?
04:49:31 <Cale> merijn: What do you mean by that?
04:49:31 <merijn> I'm trying to match argument types/count with a function signature at compile time
04:49:40 <Cale> ah, you want a counted list?
04:50:09 <Cale> (in the latest GHC, we have type-level lists, so heterogeneous lists are possible, where you specify a list of types)
04:50:15 <merijn> Cale: I guess even heterogenous counted
04:50:35 <merijn> I'm on 7.4, so I'm having to hack my own type level naturals too :\
04:51:14 <benmachine> typoclass: I think it depends on context. the difference between an O(2^n) algorithm and an O(n^2) one is usually unignorable
04:51:24 <merijn> Cale: What I have right now is this: http://hpaste.org/74388
04:51:35 <benmachine> typoclass: unless you can come up with a reasonable explanation for why the worst-case doesn't happen in practice
04:52:44 <merijn> Cale: Where the getEntry calls type is solely determined by the BoxFun function. I have three forms of entries (Tag/Binding Tag/Field), which all have Int keys, but differing result values.
04:53:17 <merijn> Cale: I'd want to check that for every function argument my pattern (i.e. the list) actually has a index for the proper type of value and that the list has the right length
04:53:59 <merijn> By for example newtyping Int to Tag/BTag/Field to enforce the difference in the type system, but then I need a known length list that can take all three types of values
04:54:51 <Cale> merijn: What is the motivation for this?
04:55:13 <Cale> (why are the parameters in a list in the first place?)
04:56:11 <Cale> Don't get me wrong, there are some valid reasons they might be in a list, for example, because they came from user input which is arbitrary-length.
04:56:29 <merijn> Cale: It doesn't have to be a list, that's just the first approximation hack I wrote
04:56:29 <typoclass> benmachine: sure, i'm not saying O is all ignorable, just that it's more complicated in practice. i thought O notation e.g. assumes that accessing any part of memory has a uniform cost, which on any actual computer isn't true by huge factors, due to processor caches, things being swapped to disk, etc.
04:56:35 <Cale> But in most cases, if you have that kind of thing, you expect to have some way in which things will fail.
04:56:44 <Cale> (by design)
04:57:15 <benmachine> typoclass: yeah, I think I read your initial statement as more dismissive than it was, whoops
04:57:24 <Cale> If the parameters are not in a list, then you can ensure there are exactly enough of them just by writing plain Haskell functions, because that's what the typechecker does :)
04:57:51 <benmachine> typoclass: I've heard it said that O notation becomes increasingly irrelevant when you get below O(n)
04:58:03 <typoclass> benmachine: no worries :) we seem to be agreeing vigorously
04:58:18 <benmachine> :P
04:58:20 <Cale> benmachine: People ignore log factors *all the time*
04:58:22 <typoclass> benmachine: hm haven't heard that
04:58:35 <benmachine> typoclass: well, it's not a True Fact as such
04:58:36 <Cale> benmachine: and in some cases, they do it unfairly
04:58:41 <merijn> Cale: The parameters are in the record, I have a pattern (that is statically known at compile time) to get the function parameters out of the record
04:58:52 <Cale> For example, there are lots of people who think looking stuff up in a hashtable is O(1) time
04:59:05 <Cale> while this is theoretically impossible
04:59:05 <benmachine> Cale: well, I think the issue is when they say "addition of integers is O(1)" but "binary tree lookup is O(log n)"
04:59:30 <merijn> Cale: I don't really need or want a list, I'm just a bit stuck on where to look for a different (statically checkable) pattern type
04:59:41 <merijn> Cale: I was hoping someone here had some inspiration for me :p
04:59:44 <Cale> (because any function whose range has n elements takes at least O(log n) time to compute)
05:00:01 <Cale> merijn: okay, so what are you actually trying to do?
05:01:00 <benmachine> Cale: I think the problem that people have is misunderstanding asymptotics – hashtables break down in asymptotic analysis because they can't be arbitrarily large
05:01:19 <hiptobecubic> I think you guys are unfairly leaving out the enormous impact of the leading constant in real word contexts
05:01:20 <benmachine> well, they can, but only by losing the O(1) bits
05:01:22 <Cale> benmachine: If they can't be arbitrarily large, then every operation is O(1)
05:01:23 <Cale> lol
05:01:41 <benmachine> Cale: well, quite
05:02:09 <benmachine> whereas tries *can* be arbitrarily large, so the O(log n) stuff makes sense
05:02:12 <Cale> hiptobecubic: The whole point of big O notation is to remove those constants.
05:02:20 <benmachine> so then people conclude that tries are worse
05:02:22 <merijn> Cale: Writing a runtime for a language and I need to call out to C (variable, but static and known at compile time number of arguments) and I want to write a single function for dealing with the C stuff so I can just generate a foreign import for the relevant C function and let the compiler arrange the proper number of arguments going on (based on the pattern, which is also static at compile time)\
05:02:37 <Cale> hiptobecubic: and yes, they're practically important, but they have nothing to do with the discussion of asymptotics
05:02:51 <hiptobecubic> Yes but then you trying to relate it back to the situations where they are unitnorable and calling foul
05:03:24 <Cale> merijn: Sounds like a job for template haskell?
05:03:24 <benmachine> hiptobecubic: well there are two problems, people ignoring it when they can't, and people not ignoring it when they should :P
05:03:44 <Cale> hiptobecubic: huh?
05:03:47 <merijn> Cale: So that I can write "myRTScode someForeignCFun somePattern" and at compile time verify that the number/argument types of the pattern and C function match
05:04:20 <Cale> merijn: hmm
05:04:25 <merijn> Cale: Yeah, that's another thing I considered, but I have no clue how to do Template Haskell and the last time I got hopelessly lost wasting three days with no progress
05:04:40 <typoclass> @remember benmachine [about O notation] well there are two problems, people ignoring it when they can't, and people not ignoring it when they should
05:04:41 <lambdabot> Done.
05:05:07 <Cale> merijn: If you just want to get stuff done, it's probably best just to have different cases for different numbers of arguments.
05:05:16 <benmachine> I like TH
05:05:25 <Cale> merijn: after all, that's the way things are handled in the standard list library :P
05:06:11 <merijn> Cale: That's not possible, that'd require a ton of code and *still* produce a needlessly restricted interface for the C code
05:06:19 <Cale> hmm
05:06:33 <Cale> The C code is using varargs?
05:06:45 <merijn> Cale: No
05:06:58 <merijn> It's just that I'm calling user provided functions
05:07:25 <merijn> So the arguments and everything is fixed and static, I just don't want to restrict the number of arguments users can provide
05:07:55 <merijn> The alternative was to just use a function pointer and write the argument fetching code in C, but that makes me unhappy and would also complicate the interface quite a bit for me
05:08:42 <merijn> Because then my C argument fetching code would have to continuosly call back into haskell
05:19:42 <benmachine> when you're using CPP and you want to comment your #endifs, which comment style do you use?
05:20:01 <benmachine> (actually, does it matter, or does CPP just ignore the rest of the line)
05:20:27 <hpc> benmachine: doesn't matter if it does or doesn't, it's comments
05:20:32 <mroman> #endif //foo <- should work
05:20:43 <hpc> plus i think CPP understands comments
05:20:59 <hpc> ie, if you did a multi-line #define FOO()
05:21:07 <hpc> // FOO()
05:21:09 <hpc> would not expand
05:21:20 <benmachine> you guys realise I am talking about Haskell with CPP here, right :P
05:21:24 <hpc> oh
05:21:40 <benmachine> hence the problem
05:21:45 <benmachine> not sure whether to use // or --
05:21:52 <hpc> do something like
05:21:58 <hpc> -- end if windows
05:22:01 <hpc> #endif
05:22:09 <Cale> benmachine: Put the comment on the next line, problem solved?
05:22:10 <benmachine> hmmm
05:22:18 <benmachine> Cale: possible but unconventional
05:22:35 <kokoko> Петухи, есть кто?
05:22:46 <benmachine> and man, I could just find out by trying to compile it three times
05:22:51 <benmachine> was just hoping someone would already know :P
05:23:12 <kokoko> Хаскельблядок, выходи!
05:23:37 <timthelion> kokoko: negovorim pa rusky :(
05:23:49 <kokoko> pachimu??
05:24:07 <MHD> What does the Spinelessness of the STG imply?
05:24:27 <timthelion> kokoko: neponimaju :(
05:25:37 <nus> kokoko, trying to insult someone in a language they hardly understand?
05:26:26 <timthelion> nus: why do you think that?
05:26:39 <nus> timthelion, he's a cheap troll
05:26:47 --- mode: ChanServ set +q *!*@gateway/web/freenode/ip.93.175.7.133
05:27:10 <timthelion> nus: has he come here before?
05:28:17 <hpaste> merijn pasted “Type hackery!” at http://hpaste.org/74396
05:28:18 <timthelion> nus: jako kdybych tady začal psát český... Bys myslel, že tě nadavam?
05:28:32 <merijn> Cale: I think I can actually hack something together using that type of list
05:28:34 <nus> timthelion, http://www.russki-mat.net/page.php?l=RuEn&a=блядь
05:29:19 <timthelion> nus: I see.  I don't understand russian. Which is what I wrote in responce :)
05:29:28 <merijn> Cale: It'd give my static checking for the types (and length should be pretty easy to add), just not sure how terrible it'll perform :p
05:37:54 <Cale> MHD: http://cale.yi.org/share/p244-burn.pdf
05:40:42 <merijn> MultiParamTypeClasses, TypeFamilies, TypeSynonymInstances and FlexibleInstances
05:40:51 <merijn> Those are all safe/acceptable extensions, right?
05:41:07 <merijn> (Is there a list of "sane" extensions somewhere?)
05:41:09 <latro`a> isn't flexibleinstances a little nasty?
05:41:17 <latro`a> flexiblecontexts isn't, but iirc flexibleinstances is
05:41:43 <Cale> Nah, it's okay.
05:42:32 <merijn> What's it do?
05:42:34 <merijn> :p
05:42:36 <benmachine> flexibleinstances is fairly necessary to get anything done
05:42:58 <merijn> Oh, right, it lets you write instances without type variables in them, right?
05:43:00 <benmachine> merijn: in modern GHC, FlexibleInstances implies TypeSynonymInstances
05:43:14 <benmachine> merijn: it lets you write instances that aren't of the form C a b c
05:43:16 <benmachine> for some C
05:43:24 <Cale> The -XFlexibleInstances flag allows the head of the instance declaration to mention arbitrary nested types. For example, this becomes a legal instance declaration
05:43:24 <Cale>   instance C (Maybe Int) where ...
05:43:26 <benmachine> e.g. it'll let you make String an instance of something
05:43:46 <latro`a> I thought that was FlexibleContexts
05:43:48 <benmachine> in H98 doing that would require a newtype
05:43:48 <merijn> Right
05:43:59 <benmachine> latro`a: FlexibleContexts controls what can appear to the left of a =>
05:44:06 <latro`a> ah
05:44:14 <merijn> Lemme cleanup the code and show you the Frankensteinian horror I just ended up writing...
05:44:16 <benmachine> latro`a: there's not a great deal of point in using one of the Flexibles without the other :P
05:44:25 <latro`a> gotcha
05:44:38 <latro`a> because then you have instances but can't constrain against them, got it
05:44:40 <benmachine> (well, some point maybe, but it would be fairly unnatural, I think)
05:44:42 <latro`a> or vice versa
05:44:46 <Cale> TypeSynonymInstances is fairly unnecessary
05:44:51 <Cale> But it's okay
05:45:16 <merijn> Cale: Yeah, I just removed it
05:45:26 <benmachine> Cale: it's entirely inoffensive since they fixed the bug where it would allow some flexible instances
05:45:45 <benmachine> but flexible implies it anyway now so whatever :P
05:46:25 <Cale> Nevermind that you can always avoid writing instances for type synonyms by expanding the synonyms by hand
05:49:51 <hpaste> merijn pasted “Type hackery 2.0!” at http://hpaste.org/74398
05:50:02 <merijn> I'm not sure whether to be proud or ashamed for that code...
05:50:27 <merijn> If you see any mistakes/cleanups/suggestions, do tell!
05:54:53 <merijn> hah, it actually seems to work too \o/
05:55:27 <merijn> I feel like this should've involved more goat blood...
05:56:45 <MHD> what's it do?
05:57:59 <Saizan> you could do that without the typeclass, using a type family
05:58:10 <fmap> Are resumable exceptions considered useless in Haskell? The only related package I've found is from 2010.
05:58:14 <merijn> Saizan: How? The RecEntry one you mean?
05:58:33 <merijn> Saizan: Or the List? or both...
05:59:06 <merijn> MHD: That question has a long answer :p
05:59:50 * hackagebot haddock 2.11.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.11.0 (DavidWaern)
06:00:23 <Saizan> List just doesn't do anything, but i meant BoxFun
06:00:34 <Saizan> anyhow it might be nicer this way
06:01:32 <merijn> MHD: For any set of "keys" that can be used to look up a value from a Record (i.e. the RecEntry typeclass) it gives you an "apply" function that takes a "BoxFun" function and a heterogeneous pattern of keys and then calls the BoxFun function with the values looked up from the record using the keys in the pattern
06:02:13 <merijn> MHD: It does this for any function the produces an "IO ()", regardless of the number of input arguments, as long as the input argument all have types that can be looked up from a Record
06:02:59 <MHD> What would you use that for?
06:03:00 <merijn> MHD: It will also (at compile time) check that the number of function arguments exactly matches the number of keys in the pattern and that each key in the pattern produces the correct input value
06:03:56 <MHD> fmap: I think you can implement it in some clever way with Cont
06:04:22 <merijn> MHD: I'm working on a runtime system that calls C functions provided by the user, this lets my code accept any C function of the type I'm expecting without needing me to code a bunch of wrappers
06:04:31 <Jafet> What can't you implement with ContT?
06:04:48 <merijn> MHD: So I can just directly use the C function as provided by the foreign function import
06:04:50 * hackagebot haddock 2.12.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.12.0 (DavidWaern)
06:04:52 <MHD> Jafet: Halting Oracle?
06:05:01 <merijn> MHD: Granted, I mostly wrote this to see if I could :p
06:05:12 <MHD> merjin: make it a package, it sound useful
06:05:39 <merijn> This is a personal record for the Oleg value of my type hacks :p
06:06:24 <MHD> I need to grow some type-hacking muscles so I can implement and release my awesome arrow based parsing library
06:06:54 <merijn> MHD: tbh, I have no clue how well it performs (i.e. how much overhead is introduced) and it's not all that general purpose, tbh
06:07:34 <MHD> What was the name of that proposal/package for polymorphic data streams (i.e. file Handle being a special case)?
06:07:46 <deech> Hi all, what are good use-cases for type/data families other that as associated types in type classes.
06:07:50 <Cale> MHD: did you catch that I linked you a paper regarding the meaning of "spineless"?
06:08:02 <MHD> yes
06:09:30 <timthelion> Cale: So I guess you're right.  Using GADTs + exticentials for EVERYTHING is too much of a PITA for now.  Perhaps when I get better with them/better understand the problem, I will write some TH to generate all the instances.  But for now, I'm reverting to the comit I made 2 days ago and moving on :(
06:11:42 <timthelion> Cale: one thing I wonder, is how much effect on preformace there is between always using a list of [Value](with a few incomplete functions).  Or having [AnyValue] and [AnyValueOfParametricity a] ect... and then having to map anyValueOfParametricityAToAnyValue any time I want to apply a more general function.  How much time does it take to do that map?
06:12:39 <Cale> timthelion: Well, not much per element, but it's O(n) over the whole list
06:13:11 <Cale> timthelion: which means that people end up replacing that sort of thing with unsafeCoerce occasionally.
06:13:33 <timthelion> Cale: That kind of destroys the point of the whole thing, now doesn't it!
06:13:36 <Cale> (it's a reasonably safe usage, if you add an explicit type)
06:14:24 <Cale> map NC where NC is a data constructor for a newtype has the same effect as unsafeCoerce, except that it does more work to accomplish it.
06:14:57 <timthelion> Cale: I guess the bigger problem, is that we end up with numberOfParametersInAlgebraicType^2 number of conversion functions to write by hand!
06:15:32 <Cale> Oh, actually, with existentials, you can't really do that
06:15:40 <Cale> because it's not a newtype
06:16:23 <darthdeus> guys, what's the difference between     zip repeat n,   zip $ repeat n,    zip (repeat n)   ?
06:16:29 <Cale> In either case (wrapping or unwrapping) there's nontrivial work there
06:16:37 <Cale> because you're either adding a dictionary or discarding one
06:16:51 <Cale> darthdeus: the last two are equivalent
06:17:08 <darthdeus> Cale: but how do they differ from the first, in my mind it's all the same
06:17:09 <merijn> darthdeus: The first is a type error, the last are identical
06:17:13 <darthdeus> oh
06:17:16 <Cale> darthdeus: zip repeat n means to zip the two lists named repeat and n
06:17:36 <darthdeus> but what if repeat is a function?
06:17:44 <Cale> then it's a type error
06:17:53 <Cale> because zip doesn't take a function as its first parameter
06:17:57 <darthdeus> doesn't that return a function that takes the second parameter?
06:17:58 <darthdeus> oh
06:17:58 <merijn> darthdeus: function application *always* binds tighter than operators
06:18:13 <darthdeus> so it won't use repeat n as a value?
06:18:26 <Cale> repeat n is not a subexpression of zip repeat n
06:18:32 <Cale> because function application associates to the left
06:18:41 <Cale> zip repeat n parses as (zip repeat) n
06:18:46 <darthdeus> uh so it would be like (zip repeat) n ?
06:18:52 <darthdeus> ah, now i understand
06:18:52 <Cale> yes
06:18:55 <darthdeus> cool thanks
06:19:40 <merijn> darthdeus: I assume you installed GHC?
06:19:46 <darthdeus> merijn: yes
06:20:06 <merijn> darthdeus: Then you can play around in GHCI to see what happens to the types (maybe giving you some extra insight in what happens)
06:20:12 <merijn> :t zip
06:20:13 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
06:20:22 <Cale> :t zip repeat
06:20:24 <lambdabot>     Couldn't match expected type `[a]'
06:20:24 <lambdabot>            against inferred type `a1 -> [a1]'
06:20:24 <lambdabot>     In the first argument of `zip', namely `repeat'
06:20:26 <merijn> :t zip (repeat 'a')
06:20:27 <lambdabot> forall b. [b] -> [(Char, b)]
06:20:40 <darthdeus> hm didn't know i could do that
06:20:46 <darthdeus> that's cool
06:20:50 <merijn> darthdeus: For now you can safely ignore the "forall a" part
06:21:23 <merijn> darthdeus: Yeah, the ":t" command in ghci will print the resulting type for you as well
06:21:24 <Cale> (or just understand that the forall a. is just explicitly saying that it should work for all choices of type a)
06:22:18 <merijn> darthdeus: You can also (what I always do for messing around) load a file in ghci (using :l to load and :r to reload) and use :t to see the type of code you wrote in the file or to run the code in the file
06:22:20 <darthdeus> so  zip $ repeat 'a' returns a function that expects another list, and then zips them together
06:22:24 <MHD> I am thinking strange thoughts. Why does every Lisp insist on being its own programming language? Lisp does a marvolous job at code generation, so why not have a Lisp that generates STG code?
06:22:27 <merijn> darthdeus: Correct
06:23:19 <Cale> MHD: Doesn't that just count as another backend for a lisp compiler? Also, it would be weird for a strict language to use the STG machine.
06:23:20 <ion> There should be a bot here that suggests $-less versions of expressions it sees. :-P
06:23:50 <timthelion> ion: you want haskell to be lisp?
06:24:12 <ion> timthelion: The strawman says yes.
06:24:34 <MHD> Cale: You are misunderstanding me. I mean, a really extensive LLVM library in scheme. You run the Lisp code in an interpreter, it produces a native code file.
06:25:00 <lpvb> maybe they should've picked a less ugly character than $
06:25:09 <MHD> You still have arithmetic and macros and list manipulation, but the end isn't the execution of the Lisp code, but the code it generates
06:25:34 <osfameron> > "ion" `isSuffixOf` "timthelion"
06:25:35 <lambdabot>   True
06:25:38 <timthelion> lpvb: perhaps if you look through eyes like these $_$ you'll see what they where thinking.
06:25:41 <Cale> How is that not a compiler then?
06:25:49 <ion> > tail "ion" `isSuffixOf` "osfameron"
06:25:50 <lambdabot>   True
06:26:00 <osfameron> ;-)
06:26:12 <benmachine> > tail "ion" `isSuffixOf` "ion"
06:26:13 <lambdabot>   True
06:26:20 <Cale> A compiler is just an interpreter that makes code in another language rather than executing it.
06:26:33 <Cale> Pretty much.
06:27:22 <MHD> Cale: Think of a scheme, and what you use it for. Now use it for generating a wholly separate LLVM programme. Now you have two programs, a Scheme program that makes another program, and another program that does something else.
06:27:52 <Cale> wat
06:27:56 <MHD> Yes
06:27:59 <hiptobecubic> Isn't that what Cale said
06:28:09 <MHD> Not as I understand it
06:28:12 <Cale> You appear to be describing a scheme compiler
06:28:16 <MHD> No
06:28:23 <merijn> MHD: Well, yes...
06:28:23 <hiptobecubic> How not?
06:28:33 <MHD> The LLVM is a Scheme library
06:28:38 <Cale> okay
06:28:46 <merijn> So?
06:28:52 <Cale> and you're writing a compiler in scheme for some other language, which compiles via LLVM?
06:28:52 <MHD> And when you run the Scheme programme, it runs like a regular scheme programme.
06:28:58 <MHD> Yeah
06:29:04 <MHD> That is the gist of it.
06:29:05 <Cale> People do that.
06:29:10 <MHD> I know.
06:29:13 <Cale> There's surely an LLVM binding for scheme
06:29:19 <hiptobecubic> When they compile stuff
06:29:31 <MHD> Let me start over for a sec
06:29:47 <Cale> So what you're suggesting is that people write compilers in scheme which use LLVM as a backend.
06:30:01 <benmachine> PVP straw poll: an export is marked "this is for internal use only, do not import" and then removed. major version bump [y/n]?
06:30:03 <MHD> Imagine a Lisp implementation that has a standart library that contains only code generation functions.
06:30:15 <lpvb> let f >. y = f y in (+) 5 >. 2+3
06:30:16 <MHD> benmachine: y
06:30:20 <lpvb> > let f >. y = f y in (+) 5 >. 2+3
06:30:20 <lambdabot>   10
06:30:29 <lpvb> what's a prettier operator?
06:30:36 <benmachine> MHD: to be clear, the removal is the only thing that is happening now, it has been exported but marked do not use for some time
06:30:38 <Cale> benmachine: 無
06:30:43 <benmachine> (do not ask why, because silly)
06:31:05 <MHD> Major version bump whenever you feel like it, yo
06:31:20 <MHD> Do it just for the psychological reasons
06:31:21 <benmachine> I guess I can just leave that up to the maintainer, it's not my code
06:31:21 <hiptobecubic> Practical answer or philosophical answer?
06:31:36 <benmachine> MHD: yeah but the point is no-one should notice
06:31:44 <benmachine> because no-one should have been using it anyway
06:31:52 <MHD> I know
06:31:54 <qwr> MHD: every compiling lisp implementation has it already ;)
06:31:57 <hiptobecubic> That means nothing
06:32:08 <Cale> Version numbers don't matter as much as you're implying?
06:32:28 * benmachine shrug
06:32:30 <qwr> MHD: programming language that has static compilation can be viewed as api for compiler
06:32:41 <benmachine> I like my version numbers to be helpful
06:32:58 <Cale> benmachine: If that's the only difference, I'd say minor version bump, because it's not a very big change?
06:33:14 <Cale> If all you're doing is changing the documentation.
06:33:26 <benmachine> Cale: I suppose my real question is "when the PVP says "exported", does it mean morally or literally?"
06:33:32 <MHD> qwr: I know that. I am thinking of using Lisp ONLY and ONLY for code generation; not actually having it be a productive language. The lisp part does nothing but generate native code; the underlying language (i.e. the executables) run like, say, haskell.
06:33:45 <qwr> MHD: for lisp you could of course create alternative compiler apis as llvm, but llvm is lower level than lisp
06:33:46 * Cale doesn't believe in any PVP
06:34:02 <hiptobecubic> What's pvp
06:34:11 <benmachine> Cale: do you not think it's useful for people to mean the same things when they make the same changes?
06:34:17 <benmachine> hiptobecubic: package versioning policy
06:34:17 <Cale> package versioning policy
06:34:38 <benmachine> as in http://www.haskell.org/haskellwiki/Package_versioning_policy
06:34:47 <qwr> MHD: or you could build full your-own hi-level s-expression based language/code generator api that acts as front-end to llvm
06:35:00 <MHD> qwr: basically
06:35:04 <Cale> benmachine: I don't think it's reasonable to expect version numbers to follow any policy apart from being totally ordered and monotone increasing over time.
06:35:11 <benmachine> Cale: why not?
06:35:11 <hiptobecubic> Oh. Thanks
06:35:33 <merijn> How costly is it to make/free a StablePtr?
06:35:44 <merijn> (or FunPtr)
06:35:45 <qwr> MHD: imho the reason why lisp usually uses lisp as code generator is because it's already there, familiar to lisp programmer and therefore simple to use
06:36:07 <Cale> because it's unenforceable with the machinery that we have, and it's pretty much useless to rely on if anyone breaks the convention
06:36:41 <Philippa> Cale: even monotone increasing over time worries me, but then I sorta accidentally made us all face up to the problems either way there
06:37:05 <MHD> qwr: I am imagining a chain of passes over a Scheme-like that basically consists of: High level s-expr macro-stuff looks like scheme/haskell frankenlang -> STG stuff (s-expr) -> LLVM DSL (s-expr) -> LLVM code -> Native code.
06:37:09 <benmachine> Cale: I wouldn't say it's useless - it holds enough of the time to be helpful IMO
06:38:01 <MHD> qwr: So everything like, say, type checking, algebraic codee reduction and more is Scheme
06:38:38 <Cale> I already assume that upgrading any version of any library I depend on is going to break things.
06:38:38 <qwr> MHD: which is basically just implementing that frankenlang using scheme
06:38:38 <Cale> and that I'm going to have to step in and fix stuff
06:38:58 <benmachine> Cale: but isn't it useful to have a cue as to how much work is likely to be required?
06:39:03 <MHD> qwr: except, the scheme part is only used as a compiler.
06:39:16 <Cale> and then I'm just pleasantly surprised when things still work okay
06:39:38 <benmachine> Cale: (and also, I can only justify specifying loose upper bounds in cabal files on the grounds that people won't do anythign stupid; I think that's very useful)
06:40:35 <Cale> bounded version ranges which extend into versions which don't exist yet are pretty silly
06:40:47 <benmachine> Cale: they're only silly if you don't trust the maintainer of the package!
06:40:48 <Cale> Either leave it unbounded or set a specific version.
06:41:38 <benmachine> if someone says "as an API user, minor version upgrades won't affect you except positively", why shouldn't I believe them and set version ranges that use that fact?
06:42:34 <Cale> Because there's no machine to check this.
06:42:43 <Cale> and people are liars
06:42:50 <benmachine> I'm not a liar :(
06:43:21 <Philippa> people do bullshit, or just plain make mistakes
06:43:52 <benmachine> that's true
06:43:57 <benmachine> but not /most/ of the time
06:44:19 <benmachine> a sufficiently small amount of the time that IME the work generated by my assumptions being wrong is less than the work saved by them being right
06:44:53 <benmachine> (and usually, the work generated by them being wrong is mostly the work that Cale has to do anyway)
06:45:15 <Cale> I wouldn't exactly lie about this, but if I was making releases of a package, I wouldn't usually be bothered to even really check whether my external API changed or not when updating the version number. It's the importer's responsibility to check that.
06:46:25 <qwr> Cale: does hackage allow specifing "known working versions" of library dependency, and having multiple versions installed?
06:46:47 <Sculptor> hi
06:47:09 <benmachine> Cale: well, I /would/ be bothered, and as a consequence my packages are easier to use
06:47:21 <beear> pretty new to haskell. i was wondering, can you mutate things in the IO procedure?
06:47:34 <benmachine> beear: you might have to be a bit more specific
06:48:30 <qwr> Cale: then there could heuristic for version conflict, that takes newer version if your dependencies create a version conflict, hoping that it maybe is backwards compatible enough, and uses known working versions if possible
06:49:33 <benmachine> qwr: supposed you have 20 libraries in conflict, which ones do you try upgrading first?
06:49:49 <beear> benmachine i don't know haskell enough to ask a better question. i was just wondering if you can mutate state at all in haskell
06:50:05 <benmachine> beear: oh. yes, but you usually don't need to
06:50:46 <benmachine> ...but arguably, whether or not any actual mutation goes on is an implementation detail
06:50:48 <snickerz777> hi, can anyone please say, how can i get syntax highliting at ghci?
06:51:13 <benmachine> you can implement things that /look/ like state mutation but don't actually mutate anything
06:51:22 <benmachine> but you can also mutate state if you really want to
06:51:35 <benmachine> (and if the type allows it, i.e. IO or ST)
06:51:53 <beear> ok I see.
06:52:30 <beear> it is possible only in IO procedures?
06:52:35 <beear> not in functions
06:52:46 <azaq23> > let f :: a -> a; f x = y where y :: t; y = x in f 5 -- is there a way to fix this without removing the y type annotation and without making 'x' an explicit argument of y?
06:52:47 <lambdabot>   Couldn't match expected type `t' against inferred type `a'
06:52:48 <lambdabot>    `t' is a rigi...
06:52:50 <qwr> benmachine: you could try finding dependency set where minimal number of libraries is upgraded out of known version ranges, not perfect but it could still be useful
06:53:11 <benmachine> qwr: yes but /how/ do you find that set... it's not a simple problem
06:53:45 <benmachine> beear: there's another type called ST that allows you to write pure functions that internally use mutation
06:53:55 <benmachine> beear: but yeah, you'd need to use one of those two
06:54:29 <qwr> benmachine: it isn't simple, yes. package managers like aptitude deal with similar problem, where they have to suggest you which installed packages to uninstall to resolve the dependencies (for example)
06:55:07 <benmachine> qwr: well, you can say "these packages are the problem" more easily than you can say "here is how you fix the problem"
06:57:01 <qwr> benmachine: not so different - my suggestion was similar to removing, by just some conflicting dependencies on lower version numbers
06:57:15 <qwr> s/by just some/by ignoring just some/
06:57:43 <benmachine> qwr: maybe. it just sounds like the kind of algorithm that might end up exponential
06:58:00 <qwr> benmachine: i'm pretty sure, that it will end up exponential
06:59:20 <beear> can you use pattern matching to fetch first two elements in one variable and rest in other?
06:59:22 <qwr> benmachine: that doesn't mean, that it (or some non-ideal approximation of it) couldn't be implemented
06:59:52 <Cale> It seems like a lot of the problems with cabal would go away if GHC just allowed multiple copies of the same package version to be installed at once.
07:00:03 <Cale> (with different ABI hashes)
07:00:38 <benmachine> Cale: that would be nice
07:00:49 <qwr> Cale: yes, having multiple versions installed was one of my assumptions to start
07:00:52 <benmachine> beear: what do you mean? of a list?
07:00:57 <beear> yes
07:01:15 <Saizan> qwr: multiple versions are already allowed
07:01:19 <dcoutts_> Cale: it's a little harder than that
07:01:22 <darthdeus> anyone of you guys tried http://lisperati.com/haskell/ ? I just feel black magic is happening there :D
07:01:30 <Saizan> qwr: multiple installations of the same version not as much
07:01:45 <Cale> darthdeus: where?
07:01:55 <darthdeus> like this http://lisperati.com/haskell/ht6.html in the slice method
07:02:09 <dcoutts_> Cale: I mean you're right, and that's what we've been thinking about for ages, but lifting the restriction introduces lots of new tricky things to get right.
07:02:18 <Cale> dcoutts_: ah, hmm
07:02:32 <dcoutts_> Cale: we can't just lift the restriction, we also have to do quite a few things with the tools to make the whole thing behave sensibly
07:02:35 <benmachine> beear: no, not exactly - you'd fetch each of the first two in different variables, and the rest in a third - then you can make a list of the first two if you like
07:02:38 <darthdeus> specifically concatMap ((uncurry $ clipTriangle i).(partition g)) t
07:02:42 <merijn> darthdeus: Oh, that intro looks a bit...hard to follow
07:02:48 <Cale> dcoutts_: I guess you're immediately faced with about a million issues of the form "I know a package and version number, which ABI hash do I pick?"
07:02:54 <merijn> darthdeus: Have you tried Learn You a Haskell?
07:03:03 <dcoutts_> Cale: yes, that sort of thing
07:03:23 <darthdeus> merijn: not yet, i thought i'd start with this cuz it was shorter, but i guess that was a poor choice
07:03:34 <dcoutts_> Cale: and it's not quite ABI, it's unique id, you can several versions of a package with the same ABI.
07:03:49 <merijn> darthdeus: I mean, just an FYI, but it takes me a bit of effort to decipher the snippet you just pasted
07:03:58 <Cale> dcoutts_: ah, hmm
07:04:14 <merijn> darthdeus: Not what I'd show newcomers early on :p
07:04:28 <darthdeus> merijn: http://mlkshk.com/r/98DU
07:05:31 <merijn> darthdeus: That's the feeling of learning ;)
07:05:56 <Xaphiosis> quick question, if I define a class Show a => Pretty a where pretty :: a -> String, and then provide a default implementation of pretty = show, how can I make all instances of Show automatically instances of Pretty?
07:06:41 <Xaphiosis> i.e. if I call "pretty blah" and I defined a custom instance for that type, it should pretty print, else use show if it's in Show
07:06:43 <merijn> Xaphiosis: "instance Show a => Pretty a", but then you can't provide new Pretty instances without OverlappingInstances
07:06:50 <merijn> Xaphiosis: And OverlappingInstances is *bad*
07:07:18 <Xaphiosis> yeah, I just got excited by the new ghci feature of providing a custom printing function
07:07:31 <beear> benmachine heh  perhaps you didn't undersand me because I just guessed the syntax.  foo (x:y:xs) = (x, y, xs).   foo "123" => ('1', '2', "34")
07:08:04 <Xaphiosis> and I'd like to use it without having to instantiate all the types to a pretty printer. still, that does answer my question, thanks merijn!
07:08:14 <eikke> please remind me to disable _dyn builds next time I'll compile GHC, kthxbye
07:08:30 <merijn> Xaphiosis: As long as you don't use it outside ghci/in real code I guess OverlappingInstances will be fine
07:08:43 <benmachine> beear: ...do you still have a question? :P
07:09:05 <beear> an unrelated one. can I write a function that accepts a list of char consisting of only 4 elements?
07:09:31 <benmachine> beear: sure. just match against a [a,b,c,d] pattern
07:09:35 <eikke> beear: compile-time checked?
07:09:42 <beear> yes compile-time checked
07:10:00 <beear> well on a second thought I guessed it can't be checked at compile time
07:10:11 <merijn> beear: Sure it can, but it'll be scary code :)
07:10:14 <eikke> not with standard [] list, you can with length-indexed lists
07:10:16 <benmachine> beear: well it can if you just make the function accept 4 character arguments :P
07:10:37 <benmachine> merijn: eikke: you overcomplicate things so
07:10:46 <merijn> beear: In fact I just wrote something similar and pastebinned it, but it's not for the feint of heart :p
07:11:01 <merijn> benmachine: Well, yes, it's what I do :)
07:11:08 <eikke> benmachine: then please tell me how to do it (compile-time checked), without that 'complication'
07:11:26 <benmachine> eikke: don't use a list, just use four arguments
07:11:29 <benmachine> or a tuple if you like
07:11:34 <Xaphiosis> merijn: doesn't work with overlapping instances, "constraint is no smaller than instance head"
07:11:40 <eikke> benmachine: that wasnt his question, obviously
07:11:58 <merijn> Xaphiosis: Then I don't know
07:12:21 <benmachine> eikke: but it achieves exactly the same thing
07:12:33 <Xaphiosis> merijn: oh, got it, it needs UndecidableInstances too
07:12:41 <Xaphiosis> pretty, indeed.
07:12:47 <benmachine> eikke: I think it's reasonable to describe tuples as fixed-length lists (with potentially heterogenous types)
07:13:02 <benmachine> Xaphiosis: overlapping bad, undecidable good
07:13:24 <eikke> benmachine: I used to make that mistake as well
07:13:32 <benmachine> eikke: you could argue that I'm not using the list type, but neither are you
07:15:04 <benmachine> we're both using other types that can serve as sequences of fixed length; mine is just simpler than yours (and is less powerful, but for this case powerful enough)
07:15:58 <Phlogistique>  /g
07:17:30 <eikke> benmachine: yet in my approach I can implement (almost?) every function you can have for normal lists, whilst that's not possible for tuples
07:17:40 <Cale> OverlappingInstances isn't that bad
07:17:55 <benmachine> Cale: opinions differ :P
07:17:58 <benmachine> @quote overlapping
07:17:58 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
07:17:58 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
07:17:59 <Cale> It's IncoherentInstances where things start to get bad
07:19:07 <benmachine> eikke: that's not necessarily relevant, though – your lists will still have to have their types fixed at compile time in most cases
07:20:08 <benmachine> eikke: basically, as far as I'm concerned it comes down to this: before passing the arguments to the function, you will need to prove that there are four of them. by far the easiest way of doing this is to exhibit all four, at which point you have them in variables so you might as well just pass them in individually
07:20:30 <eikke> i guess
07:20:59 <Cale> and when you write a totally polymorphic instance like that, you're probably going to end up wanting to use IncoherentInstances, which is the actual problem :)
07:21:29 <Cale> (well, maybe not...)
07:22:59 <Saizan> OverlappingInstances as used for type-hackery aren't that bad because the class is usually morally closed, when you use them for "default instances" or the like it's more of a problem
07:23:23 <Cale> yeah, I'll agree on that
07:23:41 <Xaphiosis> Saizan: which is exactly what I was trying to do, right? :/
07:23:46 <Cale> yeah
07:23:53 <Xaphiosis> so not my best idea
07:24:09 <Xaphiosis> but the result is cool
07:25:21 <merijn> Well, as I said, using it in GHCI is not such a big problem :p
07:25:29 <merijn> Using it in real code, OTOH
07:26:32 <Xaphiosis> No worries there, I'm an academic :P
07:27:15 <benmachine> Cale: ok I tried to come up with an example of why Overlapping is bad, but then I found out I don't understand Overlapping
07:27:18 <benmachine> and I've no particular desire to :P
07:27:47 <Saizan> "pick the most specific instance in scope, if there's a unique one"
07:27:53 <Cale> There's an example in the GHC user's guide of how OverlappingInstances can lead to incoherence between different modules.
07:28:11 <Cale> (IncoherentInstances will let it happen in the same module)
07:29:02 <hpaste> Cale pasted “Example of incoherence” at http://hpaste.org/74400
07:29:35 <kstt> what package is supposed to replace old-locale please ? It is marked as deprecated, but I can't find the new "locale" package on hackage.
07:29:38 <benmachine> oh, well, I can violate parametricity with IncoherentInstances
07:29:44 <osfameron> only in Haskell does even *incoherence* seem awfully clever...
07:29:49 <Cale> benmachine: oh?
07:30:05 <benmachine> (define notConst :: a -> Bool such that notConst 0 = True, notConst () = False)
07:30:14 <benmachine> oh wait
07:30:15 <benmachine> no
07:30:17 <benmachine> I'm silly
07:30:18 <typoclass> kstt: there is no replacement. sorry. it's a misnomer. old-locale is the only thing there is
07:30:30 <benmachine> it picks the more general instance
07:30:34 <Cale> yeah, I'm not sure how you'd do that :)
07:30:42 <Saizan> kstt: there isn't one
07:31:06 <benmachine> Cale: my idea was to get rid of a class context using a generic instance
07:31:18 <Xaphiosis> I also found this note which seems to pick a type class instance based on context without resorting to overlappinginstances, but I can't pretend I understand it yet: http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
07:31:23 <benmachine> Cale: so that a function that appeared parametric was actually using class methods
07:31:27 <Cale> benmachine: right, but if it selects the instance, it won't later go back on its decision
07:31:46 <benmachine> mm, it chooses the instance when it looks at the function, it seems, instead of when the function is applied
07:31:59 <Cale> The problem is just that it might select that instance too early and a more specific one doesn't have a chance to be used.
07:32:28 <kstt> typoclass: Saizan : ok, thank you. In my opinion, that's really confusing.
07:33:10 <kstt> oh, I refreshed the page and noticed the package has just been updated yesterday to remove the deprecation notice.
07:33:15 <typoclass> kstt: that's true :-( at least the package description should mention that imho
07:33:26 <typoclass> ah :-) oh wow
07:33:35 <identity> Is there a combinator(for parsing) that will let me do something like: (inClass someClass *comb* string "foobar" *comb* inClass otherClass) and returns the whole result?
07:33:39 <identity> eh, that is
07:33:47 <identity> whatever inClass parsed + string + inclass
07:33:57 <kstt> what happened to it ? Was it named "locale", before being renamed "old-locale" ? Or was it born old ?
07:34:13 <keyu> Hi, I'm playing around with a handle from Control.Exception and I am confused as to why this line does not work: " handle (const $ return "hello") getLine "
07:34:45 <Cale> :t handle
07:34:46 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
07:34:51 * benmachine blink
07:34:52 <Cale> :t Control.Exception.handle
07:34:52 <typoclass> kstt: no idea. perhaps there was an effort to make a replacement, which was then abandoned
07:34:53 <lambdabot> forall e a. (GHC.Exception.Exception e) => (e -> IO a) -> IO a -> IO a
07:34:56 <Saizan> identity: comb = liftA2 (,)
07:35:15 <Xaphiosis> ah, never mind, there's no way of avoiding overlapping instances in this case, only making it less insane. I think I shall go rest my brain. thanks again.
07:35:32 <Saizan> identity: with an appropriate infix declaration
07:35:34 <benmachine> kstt: I have this vague idea that it was separated out from base with the intention that it be replaced by some third-party package
07:35:35 <Cale> keyu: you sure that line is the problem?
07:35:41 <benmachine> as old-time was replaced by time
07:35:48 <benmachine> kstt: but no-one ever wrote one
07:35:59 <Cale> keyu: Oh, right, it's ambiguous
07:36:18 <keyu> I tried in ghci, not sure what it means
07:36:32 <benmachine> keyu: what handle does depends on the type of the handling function, but the handling function you've given can have any type
07:36:32 <Cale> keyu: It needs to know which type of exception you're trying to catch
07:36:50 <Cale> keyu: If you want to catch all exceptions, you can pattern match on the SomeException constructor
07:37:14 <Cale> handle (\(SomeException e) -> return "hello") getLine
07:37:59 <keyu> ah ok, thanks
07:38:06 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html explains that a bit more
07:38:46 <identity> Saizan: Hmm. I'm not sure how I would use liftA2 in this case. I basically need to return return the whole result of: (letter <|> digit) >> many (letter <|> digit <|> char '-') >> many (letter <|> digit) .. without having to stitch the result together
07:38:56 <identity> where >> is perhaps some combinator that can do that?
07:39:04 <identity> (just used it as an example)
07:39:22 <Cale> nice, haddock is mangling the ghci examples there
07:39:24 <Cale> ugh
07:39:25 <kstt> benmachine: ok, that was a too optimistic decision
07:39:28 <Saizan> identity: i meant that you can define one to be equal to liftA2 (,)
07:39:44 <benmachine> kstt: seems so! I'm not even sure that's what happened, it was before my time
07:40:20 <identity> Saizan: oh, wait.. I get it now.
07:40:42 <Cale> kstt: Yeah, I think the intention was to replace it along with time (which was replaced)
07:40:50 <benmachine> Cale: I don't see mangling
07:40:55 <Cale> kstt: But locale never actually had a replacement.
07:41:05 <kstt> ok
07:41:09 <Cale> benmachine: *Main> throw MismatchedParentheses catch e -> putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
07:41:16 <Cale> benmachine: it's eating the backticks
07:41:37 <Cale> and the lambda
07:41:43 <Saizan> identity: though one often has a declared type to pack these things, so you use the constructor like so: "Constr <$> ... <*> ... <*> .."
07:42:05 <benmachine> Cale: oh, yeah
07:42:10 <benmachine> didn't notice that, whoops
07:42:11 <Clint> identity: you just want it concatted?
07:42:20 <identity> Clint: aye
07:42:37 <identity> Saizan: I don't have in this case, though this will be a part of a data type
07:42:37 <benmachine> dudes need to do some escapin'
07:43:43 <Saizan> identity: ah, if you want the concatenation of the strings you can define your combinator to be liftA2 (++) instead
07:43:50 <identity> Saizan: oh, of course
07:43:57 <identity> thanks!
07:44:20 <Saizan> np
07:45:36 <merijn> pfft, the FFI doesn't have a default type for uintptr_t? >.>
07:46:27 <merijn> oh, ha
07:46:47 <merijn> IntPtr: "this type is compatible with the C99 type intptr_t"
07:46:52 <merijn> I need to learn to read better...
07:47:33 <Saizan> no u there
07:48:22 <merijn> Saizan: I don't particularly care about signedness here
07:48:32 <merijn> Saizan: And there also seems to be WordPtr which is unsigned
07:52:12 <Saizan> ok then :)
07:53:02 <merijn> edwardk: When I use makeLensesFor to create some lenses I get a warning that the Template Haskell line is shadowing the existing fields?
07:53:51 <edwardk> merijn: can you hpaste the warning?
07:54:00 <edwardk> we can make sure the newNames its generating are distinct
07:54:16 <edwardk> merijn: also what version of ghc are you on?
07:54:35 <hpaste> merijn pasted “lens shadowing” at http://hpaste.org/74401
07:54:45 <merijn> edwardk: 7.4
07:55:29 <notdan> http://www.yesodweb.com/blog/2012/09/small-status-update
07:55:37 <edwardk> merijn: interesting. i think its because we borrowed the name from the field. =)
07:55:39 <Cale> merijn: Aren't you supposed to name the fields starting with _?
07:55:43 <edwardk> i can fix that
07:55:50 <edwardk> Cale: you can use makeLensesFor to make a custom mapping
07:55:56 <Cale> oh, I see
07:56:21 <edwardk> merijn: should be easy enough to fix, there is just a use of mkName that needs to become newName somewhere
07:56:30 <edwardk> i'll add this to the test suite to make sure we don't regress also
07:57:09 <Saizan> newName got less unique at some point
07:58:06 <merijn> edwardk: ok, it's not a big problem (everything seems to compile and work?), I just take offense to warnings during my compilation process :p
07:58:18 <edwardk> merijn: me too
07:58:35 <edwardk> the test suite runs with -Werror, we just didn't test that combination
07:59:00 * merijn compiles with -Wall because he's a masochist
08:00:37 <nand`> WARNING: defaulting Num to Integer. WARNING: defaulting Num to Integer. WARNING: defaulting Num to Integer
08:01:34 <edwardk> i compile with -Wall for all my packages, but i use -Werror for test suites, etc
08:01:58 <edwardk> that way everyone can install it, but i have to fix the test suites, etc. pretty much immediately to keep things from breaking on new releases
08:04:04 <edwardk> merijn: what version of lens do you have installed?
08:04:16 <merijn> 2.5 I think?
08:04:32 <merijn> Yeah, 2.5
08:05:22 <edwardk> merijn: try updating and check again i think its already fixed
08:06:23 <jsimon> :t fmap (+)
08:06:25 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
08:08:50 <merijn> edwardk: How do I update? xD "cabal update lens" or just rerun "cabal install lens"?
08:09:02 <edwardk> cabal update; cabal install lens
08:09:03 <otters> cabal doesn't have an update command
08:09:10 <otters> not for individual packages I mean
08:09:15 * merijn kicks c2hs
08:09:27 <edwardk> you may have to use cabal install lens --reinstall
08:09:38 <merijn> intptr_t is turned into CLong? >.<
08:09:48 <edwardk> i can never remember how it works when you aren't sitting in the directory of the project you are reinstalling
08:09:51 * merijn is sad
08:10:26 <edwardk> merijn: IntPtr should be converted into something long enough to hold a pointer on your platform. what did you want it to be?
08:10:50 <edwardk> CLong holds an int64
08:11:04 <merijn> edwardk: I want IntPtr, but c2hs autogenerates CLong for intptr_t in my C struct, so I get a type error
08:11:19 <merijn> (couldn't match expected type IntPtr with type CLong)
08:11:33 <edwardk> ah
08:11:44 <edwardk> there is CIntPtr too
08:12:01 <edwardk> i would expect that instead
08:12:16 <merijn> Why?
08:12:47 <benmachine> merijn: throw fromIntegral at it?
08:12:48 <edwardk> intptr <-> CIntPtr seems like the least information loss ;)
08:13:07 <merijn> edwardk: I would expect IntPtr == CIntPtr
08:13:30 <benmachine> merijn: you'd expect that, but though they do the same job, they needn't necessarily do it in the same way
08:13:51 <merijn> Expecting CIntPtr for intptr_t seems like expecting "CPtr CInt" for "int *"
08:14:07 <benmachine> I regard IntPtr as being "an int big enough to hold a ptr" and CIntPtr meaning "the C type intptr_t"
08:14:22 <benmachine> merijn: no, that's Ptr CInt
08:14:24 <edwardk> that doesn't work. the problem is that haskell types and c types have difference sizes. its the difference in numeric type sizes. remember that windows and those guys follow an LLP64 model for 64 bit addressing, but haskell's model is closer to ILP64
08:14:31 <merijn> benmachine: The docs explicitly state that the purpose of IntPtr is to be intptr_t compatible
08:14:35 <edwardk> so Int in haskell is 64 bit, so Int <-> CInt already fails
08:14:40 <benmachine> merijn: oh, that's weird
08:14:48 <merijn> IntPtr docs: This type is also compatible with the C99 type intptr_t, and can be marshalled to and from that type safely.
08:15:15 <benmachine> where is IntPtr anyway?
08:15:16 <identity> This question may be a bit strange, but it's because I feel like I'm finding some pattern here that I think may exist in some class somewhere. (++) is to mplus as (:) is to .. ? Anything?
08:15:22 <merijn> benmachine: Foreign.Ptr
08:15:23 <identity> Wondering if I can generalize
08:15:39 <edwardk> merijn: and it can, c2hs just chooses a different target for intptr_t
08:15:56 <nand`> if you want to give it a name, ‘cons’; and arguably it can be generalized since many list-like structures have cons operations
08:15:58 <merijn> edwardk: Yes, hence why I was complaining about c2hs and not the FFI :p
08:16:24 <benmachine> identity: not reeeally. although you can do "return x `mplus` m" or some such
08:16:30 <merijn> Maybe I should switch to hsc2hs after all, but then I need to figure this out all over again :(
08:17:07 <benmachine> identity: (or, of course, pure x <|> m)
08:17:22 <edwardk> identity: i have a cons-like operation in reducers (and before that in monoids) but its not a close analogy to what you want. i use something almost identical to make a usable mplus in scala where you can't make the pure a <|> m  idiom work without using an implicit though
08:18:10 <edwardk> though admittedly there i use it for m <|> pure a
08:18:15 <edwardk> so its more snoc-like
08:18:32 <edwardk> since pure a <|> m is awful, since it means vastly different things depending on the choice of monad/applicative
08:18:53 <identity> I see
08:18:54 <edwardk> there are two semantics for mplus/alternative and they disagree completely on precisely this case
08:18:55 <benmachine> notably, in several it means pure a >_>
08:19:00 <identity> It's still interesting running into this stuff
08:19:05 <identity> Seeing patterns everywhere with parsers etc
08:19:18 <identity> Most fun I've had writing code for a while
08:19:23 <identity> Wow, I need to get out
08:19:27 <edwardk> thats the best part of haskell
08:19:27 <benmachine> :P
08:19:34 <merijn> edwardk: I still get the warnings? How do I make sure it is using the new lens version? I just changed 2.5.* into 2.6.* in my cabal file
08:19:37 <identity> edwardk: I agree whole-heartedly
08:20:07 <merijn> I have lens-2.5 and lens-2.6.1 right now
08:20:09 <edwardk> merijn: that should help, if you ghc-pkg list | grep lens you should see the new version
08:20:13 <jsimon> what do you guys think of my description of the <*> operator: <*> applies partial currrying to functions that were lifted by fmap
08:20:14 <edwardk> hrmm
08:20:22 <edwardk> can you try one more step for me then?
08:20:25 <merijn> Sure
08:20:43 <identity> I probably could have finished this parser a long time ago, but I'm having so much fun generalizing heh
08:20:43 <edwardk> git clone http://github.com/ekmett/lens.git    and go into that directory and cabal install
08:20:47 <identity> with my own combinators and stuff
08:20:49 <edwardk> that will get you a pre-release copy of 2.7
08:21:07 <edwardk> i want to see if the error is gone there, because I'm not getting it on my local copy
08:23:52 <merijn> hmm
08:23:59 <merijn> I suspect something is going wrong
08:24:07 <merijn> I get a directory full of html files >.>
08:25:03 <merijn> I suspect I shouldn't have used the http url
08:26:03 <jsimon> what do you guys think of my description of the <*> operator: <*> applies partial currrying to functions that were lifted by fmap
08:26:13 <dgpratt> so the codensity monad...what the heck is it?
08:26:26 <edwardk> merijn: make sure you switch to the master branch
08:26:35 <merijn> edwardk: Yeah, I just noticed :p
08:26:49 <Cale> dgpratt: http://hackage.haskell.org/packages/archive/kan-extensions/2.7/doc/html/Control-Monad-Codensity.html
08:27:06 <merijn> edwardk: Seems like hg-git default to the wrong "latest" version
08:28:42 <edwardk> dgpratt: giti really should have chosen a different name than Codensity when i started pushing this monad on the haskell community ;)
08:28:53 <edwardk> i realize its the second oldest name this monad has, but still =)
08:29:00 <dgpratt> Cale: what is the use of such a thing? I think it can be use to improve the asymptotic complexity of stuff, but is that the general purpose of it?
08:29:05 <Cale> What's the oldest?
08:29:08 <edwardk> er s/giti/i
08:29:19 <edwardk> Cale: 'the monad generated by a functor'
08:29:42 <Cale> I think there's nothing wrong with the name Codensity
08:30:02 <copumpkin> what's nsity?
08:30:11 <Cale> ?
08:30:22 <dgpratt> edwardk: what's the etymology of that name anyway?
08:30:25 <merijn> edwardk: The error is still there in 2.7
08:30:36 <edwardk> Ross Street referred to it as "the monad generated by a functor" in 1972. Codensity came later in 1974.
08:30:46 <edwardk> merijn: damn. ok. i'll work harder to duplicate it
08:31:16 <Cale> edwardk: Is it still referred to by codensity, or is there a newer term for it?
08:31:21 <merijn> edwardk: I can tar and send you the package I have
08:31:27 <edwardk> Cale: afaik
08:31:29 <merijn> edwardk: Although it might be all sorts of broken
08:31:46 <edwardk> merijn: sure, ekmett@gmail.com
08:32:11 <n-dolio> "Monad generated by a functor" sounds like free.
08:32:33 <edwardk> Cale: http://ncatlab.org/nlab/show/codensity+monad
08:32:46 <n-dolio> Which makes it a pretty poor name for codensity.
08:33:33 <n-dolio> Unless you want your audience to distinguish between 'free monad generated by a functor' and 'monad generated by a functor'.
08:33:52 <Cale> dgpratt: the link that edwardk just gave explains the reason for the name, btw
08:34:53 <dgpratt> Cale, edwardk: a good starting point I think, thanks
08:34:53 * hackagebot flock 0.3.1.3 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.3.1.3 (ErikHesselink)
08:36:14 <Cale> dgpratt: It's probably not extraordinarily useful for understanding the meaning of it in the context of Haskell. You can understand it from a programming perspective just by looking at the code for it probably better than you'll get from reading a bunch of CT stuff (I think).
08:36:41 <merijn> edwardk: Sent
08:36:50 <dgpratt> Cale: you're probably right
08:37:43 <Cale> The notion of Kan extensions has been kinda funnily specialised in this context anyway, because we have no concept of other categories than Hask.
08:37:58 <edwardk> dgpratt: the origin of the name comes from the notion of dense (and codense) sets, which ties back to topology, there is a way to make a comonad that has little to do with computation about of the notion of a dense set
08:38:24 <SLi> Which Haskell GUI library/framework should one choose for new projects? On the non-Haskell side I generally prefer qt and gtk, but obviously with haskell it would depend a lot on the quality and completeness of the bindings.
08:38:47 <edwardk> well, you aren't bound to the same 'hask' as haskell Functors at least using Ran, Codensity, etc. those don't need 'f' to be a functor, merely to have kind k -> * for some k.
08:39:26 <edwardk> e.g. Codensity Endo gives you a way to encode lists
08:39:35 <edwardk> even though Endo is clearly not a Functor with a capital F.
08:40:16 <Cale> edwardk: ah, right, we have other kinds to play with now at least :)
08:40:41 <edwardk> Cale: well, even when you were limited to * -> * it worked on things that weren't proper haskell functors.
08:40:47 <Cale> yes
08:41:18 <Cale> SLi: probably Gtk2Hs
08:42:18 <parcs`> @hoogle assert
08:42:18 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
08:42:19 <lambdabot> Control.Exception assert :: Bool -> a -> a
08:42:19 <lambdabot> Control.OldException assert :: Bool -> a -> a
08:42:43 <SLi> Cale, that's the conclusion I was slowly arriving at, too, but decided to look for other opinions. :) Thanks!
08:44:13 <lpvb> I want to write applications that are portable to windows, is wxHaskell better than gtk2hs in that regard?
08:44:30 <lpvb> & which is easier to work with?
08:45:40 <merijn> There really is no documentation for hsc2hs, is there? Googling for "hsc2hs documentation" shows the GHC user guide which doesn't seem to have any examples and the remaining hits seem to be only bugs/mentions?
08:46:04 <SLi> https://en.wikibooks.org/wiki/Haskell/GUI talks about wxHaskell, but I'm a bit allergic to wxWidgets in general... At least on the C(++) side of things.
08:46:11 <dcoutts_> lpvb: I've developed commercial gui apps on windows using gtk2hs, no complaints from the customers
08:46:29 <hpaste> jello pasted “Codon Table” at http://hpaste.org/74403
08:46:32 <dcoutts_> lpvb: and we developed them on linux and did minimal adjustments for windows, so yes pretty portable
08:46:43 <lpvb> dcoutts_: do you bundle in gtk with the apps?
08:46:55 <dcoutts_> lpvb: yes
08:47:02 <lpvb> how do you do that?
08:47:15 <dcoutts_> lpvb: so install is either trivial or not needed (one ran straight from the cd)
08:47:23 <Cale> SLi: tbh, WxHaskell is pretty okay
08:47:44 <Cale> SLi: My guess is that it's a pretty "thick" binding to WxWidgets
08:48:00 <Cale> (i.e. not much of the original library design shows through)
08:48:30 <dcoutts_> lpvb: take the gtk+ redistributable bundle and stick your exe in the same bin dir (the one with all the dlls)
08:48:36 <lpvb> when compiling on windows, do you get every .dll it references and package that in, or do you make the user install the gtk distributable first?
08:48:55 <Jello_Raptor> That's a table of amino acids to related codons (where the codons are [DNACode] elements) is there a way to generate that (and the reverse lookup table) programmatically http://hpaste.org/74403 ?
08:49:10 <lpvb> dcoutts_: okay, thanks
08:49:17 <SLi> Cale, ok. I guess I'll look at gtk2hs anyway. :) Hmm, leksah uses gtk2hs? If so, I guess it definitely must be good enough for my needs.
08:49:31 <gabor> edwardk: I'd like to hear your opinion on this page (https://code.google.com/p/omega/wiki/ConstructorTheorems) which I scribbled in a sleepless night
08:49:31 <Cale> Jello_Raptor: sure, just simulate lots and lots of chemistry
08:49:47 <geekosaur> heh
08:49:51 <lpvb> SLi: on linux, wx is just a layer over gtk
08:49:52 * Jello_Raptor glares
08:50:05 <Jello_Raptor> I mean some metaprogramming method or something
08:50:06 <dcoutts_> lpvb: single combined install, just have the right dir layout and it all works fine, relocatable so install is easy as copying it all
08:50:08 <lpvb> but on windows, it's a layer over the windows ui stuff
08:50:25 <dcoutts_> lpvb: as I mentioned, we had one just run off the cd with no installation
08:50:32 <SLi> lpvb, I see.
08:50:34 <geekosaur> not sure what you mean by programmatically; while there could probably be some TH, for a large enough list I'd use a small shell/perl/whatever script (or even runhaskell) to generate a source file
08:50:40 <edwardk> looks a bit like something of conor's
08:51:05 <edwardk> oh you mentioned that
08:51:36 <Cale> Jello_Raptor: You could put all those cases into one list and use Data.Map.lookup, which would also possibly be marginally more efficient.
08:51:53 * Jello_Raptor nods
08:52:32 <edwardk> gabor: i'm not quite sure where you're going with it in the end. so far it looks like algebraic ornaments or ornamental algebras (i can never remember which is which)
08:53:06 <edwardk> gabor: or like my 'reflecting on incremental folds'
08:54:45 <gabor> edwardk: it is for all constructors, not only foldable things, but right, I do not yet know how where this piece will enter into the big puzzle
08:55:41 <gabor> edwardk: thanks for giving a look, I assume you did not find something violently silly
08:56:41 <edwardk> not off hand, but without understanding the final application i don't have much to grab onto and shake ;)
08:57:11 <thirsteh> is there a switch to have cabal stuff 'dist' somewhere else, e.g. ~/.cabal?
08:57:44 <edwardk> isn't there a --distdir flag?
08:57:48 <thirsteh> I guess I could symlink it
08:58:07 <thirsteh> ah, great
09:01:06 <merijn> btw
09:01:25 <merijn> whoever decided that ghc-pkg should output "ghc-pkg --help" to stderr needs to be crucified
09:01:40 <lpvb> No one uses qthaskell do they?
09:01:49 <Jeanne-Kamikaze> I never got it to build
09:02:19 <geekosaur> merijn, standard unixy behavior...
09:02:41 <Ralith> ^
09:02:56 <Ralith> help stuff is not the program's normal output stream
09:03:05 <Ralith> why is it a problem for you, anyway?
09:03:07 <merijn> geekosaur: wut
09:03:24 <merijn> Ralith: Because it is 4 screen fulls and "ghc-pkg --help | more" doesn't work
09:03:41 <Ralith> merijn: ghc --help 2>&1
09:03:43 <Ralith> :P
09:03:45 <merijn> Ralith: Every time I need to remember that I need to add 2>&1 to fix it
09:03:51 <thirsteh> merijn: ghc-pkg --help | less :)
09:03:58 <thirsteh> less is more
09:04:00 <thirsteh> ba dum tsch
09:04:01 <merijn> thirsteh: What's your point?
09:04:05 <thirsteh> thanks everyone, I'll show myself out
09:04:07 * Clint squints.
09:04:15 <Ralith> less Just Works, looks like.
09:04:23 <Ralith> doesn't need the redirect
09:04:25 <Clint> that doesn't make any sense
09:04:37 <merijn> Ralith: That is not actually possible
09:04:44 <Ralith> it is entirely possible.
09:04:45 <thirsteh> yet here we are
09:04:47 <merijn> Ralith: Unless your shell hijacks the less command
09:04:51 <Ralith> in fact, it just happened!
09:04:59 <Ralith> merijn: you do know that stderr is just another output stream, right?
09:05:10 <merijn> Ralith: Yes, but | only forwards stdout
09:05:18 * Ralith shrug
09:05:18 <Clint> my ghc-pkg --help outputs to stdout
09:05:18 <merijn> Ralith: Unless you have a non-standard shell
09:05:36 <merijn> And less cannot magically grab stderr from ghc-pkg without the shell intervening
09:06:38 <benmachine> my ghc-pkg --help outputs to stdout too
09:06:52 <merijn> Clint: Actually, you're right. It looks like I ran -h instead of --help initially
09:07:04 <tazjin> Is there an SMTP library that supports basic AUTH commands? (specifically AUTH LOGIN)
09:07:06 <Clint> ah
09:07:26 <thirsteh> merijn: yup, help works, h doesn't. weird
09:07:58 <merijn> anyhoo, screw it
09:08:00 <merijn> Time for weekend
09:08:04 <napping> ah, -h is printing "unrecognized option -h" and then going into the usage text
09:08:05 <benmachine> looks like ghc-pkg asdf prints the help to stderr
09:08:11 <Clint> that's sane behavior
09:08:18 <benmachine> it's... moderately sane
09:08:23 <Clint> standard
09:08:26 <thirsteh> ah, yup, then it's standard unix
09:08:27 <benmachine> I'd say if you're printing a "no, wrong command" message it should be short
09:08:32 <thirsteh> it's an error after all
09:09:02 <napping> well, that part is just one line, it's the usage message that's pretty ridiculously long
09:09:14 <benmachine> napping: right
09:09:24 <thirsteh> yeah, it should say "For information, type ghc-pkg --help or something"
09:09:28 <benmachine> mm
09:09:41 <thirsteh> seems like something that was implemented when usage() was only 10-15 lines long
09:10:04 <benmachine> sounds like something they'd accept a patch for!
09:10:39 <thirsteh> nah, it'll get fixed if we just complain enough
09:11:07 <thirsteh> somebody should write a blog post about it
09:11:16 <benmachine> ah yeah, that'll do it
09:11:24 <thirsteh> straight to Hacker News #1
09:11:36 <benmachine> is there anything blogs can't do?
09:11:44 <benmachine> (rhetorical question)
09:12:45 <thirsteh> all hail the Technorati
09:13:44 <napping> Is UU_Pretty the only library that lets you pretty freely give alternate layouts?
09:15:34 <identity> Can lambdabot load attoparsec?
09:15:58 <identity> > Data.Attoparsec.many
09:15:59 <lambdabot>   Not in scope: `Data.Attoparsec.many'
09:16:05 <identity> > Data.Attoparsec.String.many
09:16:06 <lambdabot>   Not in scope: `Data.Attoparsec.String.many'
09:16:51 <ParahSailin> :t flip
09:16:52 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:17:18 <napping> I'm wondering if it's possible to express paragraph filling with hyphenation in some existing library, relying on lazy evaluation to avoid actually computing hypthenation points in a word unless it's necessary
09:19:34 <ParahSailin> easy way to change parameter order of constructor?
09:19:59 <Cale> ParahSailin: lambda?
09:21:08 <identity> Can anyone explain to me why Data.Attoparsec.Combinator.many returns a Partial result for even something as simple as: parse (many anyChar) "foo" ?
09:24:06 <benmachine> identity: because many anyChar could parse more?
09:24:24 <m3ga> identity: yes, what benmachine said
09:24:27 <nand`> :t flip (,)
09:24:28 <lambdabot> forall a a1. a1 -> a -> (a, a1)
09:24:47 <benmachine> identity: just call the function with an empty string to say "there is no more", I think
09:25:16 <nand`> there's also a version that won't ever return Partial results
09:25:19 <identity> oh, of course.
09:25:21 <nand`> as in, if it hits EOF, it's EOF
09:28:37 <mun> hi
09:28:43 <mun> i have a slightly naive, logic question
09:28:55 <mun> does anyone know why 'F = G --> (EX a b. a ~= b --> F a = G a & F b ~= G b)' is provable? If F and G are equal, then F x = G x for all x. So how come the above it's provable?
09:30:22 <benmachine> thirsteh: http://hackage.haskell.org/trac/ghc/ticket/7228 :)
09:30:53 <Cale> mun: What's the difficulty?
09:31:09 <thirsteh> benmachine: nice!
09:31:26 <Cale> mun: actually, what do you mean by ~= ?
09:31:30 <mun> Cale, that's inequality
09:31:31 <benmachine> thirsteh: the power of complaining :P
09:32:03 <napping> why do you think that's provable?
09:32:42 <Cale> mun: Oh, pick a = b, in which case a /= b is False, and the implication is true
09:33:02 <nand`> mun: EX a b. a ~= b --> ...  should be provable assuming EX a; no? just pick a=b and the left hand side is false, therefore you can have anything on the right hand side
09:33:47 <mun> ooh
09:34:38 <Cale> mun: btw, most people will read ~= as "is isomorphic to"
09:34:46 <mun> oh right
09:35:14 <ion> I take it ~= is an approximation of some symbol? ≈?
09:35:41 <Mortchek> I'm trying to install ghc from source, and I have the LMDE package libgmp3-dev installed, but when I run ./configure, I get: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory. What might be the problem?
09:36:16 <ion> % apt-file search libgmp.so.3
09:36:18 <ion> libgmp3c2: /usr/lib/libgmp.so.3
09:36:40 <Mortchek> I get no output from that.
09:36:41 <ion> (YMMV depending on whether we have the same distro and the same release.)
09:36:48 <typoclass> Mortchek: are you sure you must build from source? (just checking)
09:37:03 <mun> Cale, so could it be generalised that lemmas with existentials in the antecedent are trivially true/
09:37:12 <Mortchek> typoclass, I want to use packages that use features of versions of ghc newer than my distro provides; e.g., lens
09:38:48 <Mortchek> Hmm, it seems libgmp3-dev is just a dummy package for libgmp-dev though.
09:39:41 <ion> mortchek: https://gist.github.com/2815423
09:39:51 <typoclass> Mortchek: i don't know much about debian, but don't they have various repositories of newer stuff? ("testing", "unstable"?) i thought you need only a tiny bit of configuration to get apt to query those. i think it would save you quite some trouble.
09:40:48 <Cale> mun: That existential isn't in the antecedent
09:41:06 <mm_freak> Mortchek: you would want GHC 7.4
09:41:08 <typoclass> (i use arch myself, but ubuntu has those "ppa" thingies. surely debian has an equivalent.)
09:41:39 <Mortchek> ion, thanks, I've got most of that, but the problem is currently at the ./configure step, which fails due to libgmp.so.3 missing.
09:42:04 <Mortchek> typoclass, LMDE is based on Debian Testing. I would have to go Unstable if I wanted the newest, and I'd rather avoid that if possible.
09:42:17 <ion> typoclass: I find it nicer to just install it under ~ from the binary package on haskell.org.
09:42:43 <ion> Well, s/package/build/
09:43:14 <typoclass> ion: *nod*
09:43:20 <Mortchek> Hmm, actually I get "No candidate version found for libgmp3c2"
09:46:53 <Cale> mun: What is true is that  exists x. (P(x) -> Q(x)) = exists x. ((not P(x)) or Q(x)) =  (exists x. not P(x)) or (exists x. Q(x))
09:48:07 <Mortchek> I guess it might be a software source problem of some sort. I'll have to try later when I have some more free time. Thanks for your help, folks.
09:49:48 <Cale> Mortchek: Debian has recently stopped providing version 3 of libgmp for some stupid reason.
09:49:56 <Cale> Mortchek: I don'
09:50:07 <Cale> I don't know what would possess them to do this
09:51:13 <Cale> Mortchek: btw, you can't compile the source of GHC without a working GHC.
09:51:27 <Cale> Mortchek: so it's pretty pointless to compile GHC unless you're hacking on it.
09:52:17 * ParahSailin had to compile GHC because of ancient libc version
09:53:18 <benmachine> Cale: I compile GHC because I cba waiting for the OS package to update
09:53:37 <benmachine> and because my system gmp is something odd
09:54:35 <Cale> benmachine: In that situation I'd rather just get myself the appropriate gmp
09:54:49 * typoclass always thought it's rarely necessary to compile from source, and you always want to try binary first. i guess that's changed these days. everyone and their grandma seems to compile from source?
09:55:03 <benmachine> typoclass: I stick to binaries when I can
09:55:04 <typoclass> (i know my grandma does)
09:55:10 <typoclass> benmachine: right
09:55:21 <benmachine> Cale: the prospect of fiddling with libgmp sounds scarier to me than fiddling with GHC
09:55:24 <benmachine> I know GHC better
09:56:02 <typoclass> benmachine: what distro gave you the oddball gmp?
09:56:19 <benmachine> typoclass: archlinux - it's not oddball as such, just newer
09:56:21 <benmachine> I think
09:56:27 <Cale> Just getting a .so file and sticking it in /usr/local/lib and then running ldconfig seems less trouble than recompiling GHC :P
09:56:30 <benmachine> or it was once and I don't bother checking these days :P
09:56:40 <benmachine> Cale: recompiling GHC is easy, it just takes ages
09:56:42 <monochrom> no, actually, "everyone builds from source" was more popular in the past than now
09:57:06 <benmachine> it wouldn't take quite so many ages if this room was cool enough that it wasn't painful to run my CPU at full speed >_>
09:57:09 <benmachine> damn laptops
09:57:31 <benmachine> actually I think my fan is fluffy
09:57:38 <benmachine> should probably get one of those tiny vacuum things
09:57:38 <monochrom> but you should get a laptop cooling pad anyway
09:57:43 <typoclass> oh, i have arch as well. haven't run into trouble yet, but i update only about 1x per month. i'll look out for that ...
09:58:03 <typoclass> monochrom: it seems that building trouble comes up a lot in here
09:58:03 <Cale> benmachine: I hold you solely responsible for the heat death of the universe.
09:58:07 <benmachine> monochrom: my "spending money on laptop" budget is already exhausted on getting a new friggin' battery
09:58:28 <monochrom> oh, heat kills battery, too
09:58:31 <benmachine> Cale: when it happens, I promise to be very apologetic
09:58:41 <typoclass> Cale: for the heat death of his laptop maybe
09:58:42 <benmachine> monochrom: thing is, this battery actually works fine
09:59:10 <benmachine> it's expanded and popped out of its housing to the point where it occasionally stops touching the contacts
09:59:27 <benmachine> but it still gives like 2 hours runtime if you keep it in there for that time >_>
09:59:38 <benmachine> (which is not bad given that it's about 4 years old now)
09:59:42 <monochrom> that is bizarre :)
09:59:53 <benmachine> :P
10:00:06 <typoclass> uh, your battery seems to be seriously not okay ...
10:00:26 <benmachine> typoclass: >_>
10:00:29 <benmachine> it *works*
10:00:48 <typoclass> in the sense that it has not overtly exploded yet
10:00:52 <benmachine> yes.
10:00:54 <benmachine> in that sense.
10:01:10 * typoclass would get *so* scared if things expanded and popped out of their case ...
10:01:22 <benmachine> typoclass: I just assumed it was a poorly designed case
10:01:42 <benmachine> typoclass: by the time I was told it was a battery fault, it had already not hurt me for a while, so I got complacent
10:14:55 * hackagebot monarch 0.6.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.6.0.0 (NoriyukiOhkawa)
10:31:11 <hpaste> int80_h pasted “readability question” at http://hpaste.org/74406
10:33:23 <mvj4> what is the purpose of the new CTYPE pragma in 7.6.1? any docs available on CTYPE/capi?
10:34:36 <Cale> int80_h: that's fine apart from the fact that it's invalid because some things should be uppercase :)
10:34:54 <Cale> int80_h: If you have good names for the fields though, it can be good documentation to use record syntax
10:37:57 <carpi> is this still lazily evaluated  ... "foldl (\acc v -> acc || v) False [True, False, False]"?
10:38:59 <byorgey> carpi: everything is lazily evaluated.
10:39:46 <byorgey> carpi: however, that expression has to evaluate the spine of the entire list before it can hope to output anything.
10:40:38 <carpi> byorgey: so in the expression mentioned earlier, the entire list is evaluated and evaluation does not stop even if acc is "True" at any point?
10:41:01 <Ferdirand> you probably want foldr
10:41:13 <MostAwesomeDude> :t all
10:41:15 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
10:41:30 <Ferdirand> @src any
10:41:30 <lambdabot> any p =  or . map p
10:41:40 <MostAwesomeDude> > any id [True, False, False]
10:41:41 <lambdabot>   True
10:41:42 <Ferdirand> @src or
10:41:43 <lambdabot> or    =  foldr (||) False
10:42:04 <typoclass> mvj4: seems to have to do with this http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html -- «foreign import capi "header.h f" f :: CInt -> IO CInt -- GHC will generate code to call f using the C API defined in the header header.h. Thus f can be called even if it may be defined as a CPP #define, rather than a proper function.»
10:42:13 <typoclass> (not sure what that means, however :) )
10:42:29 <Ferdirand> > or (True : cycle False)
10:42:30 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
10:42:31 <lambdabot>         against inferred typ...
10:42:52 <Ferdirand> > or (True : repeat False)
10:42:53 <lambdabot>   True
10:43:02 <byorgey> carpi: the *spine* of the entire list must be evaluated.  Evaluation of the list *elements* does stop when acc becomes True.
10:43:19 <byorgey> carpi: the best way to understand it is just to simulate it yourself.
10:43:25 <carpi> byorgey: could you please tell me what you mean by the "spine"?
10:43:45 <MostAwesomeDude> carpi: Do you remember the type of lists?
10:43:53 <carpi> byorgey: you mean non evaluted thunkss?
10:43:54 <MostAwesomeDude> data List = Nil
10:44:00 <MostAwesomeDude> Ergh, keyboard.
10:44:07 <MostAwesomeDude> data List a= Nil | Cons a
10:44:31 <byorgey> carpi: if you have a list it could just be a thunk.  Evaulating the spine means evaluating it to something like  thunk : thunk : thunk : thunk : []
10:44:33 <MostAwesomeDude> You have to go all the way to the end of the list, where the Nil is. But you don't have to actually look at the elements inside.
10:44:43 <MostAwesomeDude> What byorgey said; he's better at this.
10:44:50 <byorgey> carpi: i.e. evaluating it enough to know what all the constructors are, but not actually evaluating the elements themselves
10:44:57 <scshunt> MostAwesomeDude: Nil | Cons a (List a)
10:45:08 <scshunt> otherwise it's more like a Maybe :P
10:45:11 <MostAwesomeDude> scshunt: Yeah, I really should shut up now.
10:45:19 <scshunt> get some sleep
10:45:28 <MostAwesomeDude> I just woke up. :c
10:45:59 <scshunt> get some coffee
10:46:56 <carpi> so basically *thunks* until something evaluates to True in the expression earlier ...
10:59:18 <Cale> people, y u think in terms of thunks?
10:59:36 <Cale> Expressions should be good enough for anyone.
11:09:21 <byorgey> think thank thunk
11:10:59 <monochrom> thunk just means expressions. why a different word? only because it's expression in computer format
11:11:42 <mysticc> How to install just the dependencies without actually installing the package from cabal ?
11:11:57 <monochrom> "just like" you don't need two different words for numbers, be it in computer format or your format.
11:12:30 <dcoutts_> mysticc: --only-dependencies
11:12:35 <kanedank> can someone help me figure out what I'm doing wrong here?: http://hpaste.org/74408
11:12:48 <thirsteh> hmm, I'm noticing a theme here
11:12:48 <dcoutts_> mysticc: see cabal install --help
11:12:52 <thirsteh> there's a command line option for everything, isn't there?
11:13:08 <monochrom> no, there isn't
11:13:26 <kanedank> I'm just trying to create a nice automated way to create instances of my agent record type, but it seems like I'm having a lot of trouble trying to think in haskell
11:13:26 <monochrom> for example, no option for "shave exactly those who don't shave themselves"
11:13:47 <monochrom> haha, does cabal-install install exactly those who don't install themselves?
11:14:00 <byorgey> kanedank: you are having trouble thinking in Haskell because you are not thinking enough about types.
11:14:06 <monochrom> "cabal install --the-installer-of-seville"
11:14:12 <byorgey> kanedank: start by writing down type signatures for those definitions.
11:14:56 * hackagebot gnuplot 0.5.0.1 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5.0.1 (HenningThielemann)
11:15:02 <byorgey> kanedank: if you don't understand the types of what you are trying to write, then you really don't understand what you are trying to write.
11:15:50 <byorgey> monochrom: no, cabal shaves^W installs itself
11:18:06 <byorgey> kanedank: what is the type of createAgent?  let's start there
11:18:49 <kanedank> no, I figured out the types. Am I supposed to write types first in genreal?
11:19:02 <byorgey> kanedank: it is strongly recommended.
11:19:12 <hpaste> Philippa pasted “Am I golfing this typechecker too much?” at http://hpaste.org/74409
11:20:01 <Philippa> so that typechecker will have an accompanying post where I'm going to give a 'name' to <$
11:20:14 <byorgey> kanedank: writing types before implementing is a great way to solidify your ideas.  It also helps the compiler give you better, more localized error messages
11:20:56 <Philippa> because with the way I'm doing constraint stuff there, and especially allocating metavariables, <$ strikes me as a cute way to handle return values
11:21:03 <timthelion> Is there somewhere an applyMultipleTimes :: (a->a)->Int->a->a?
11:21:24 <Philippa> (I can /always/ allocate a variable in the outside, then return it in the next scope before constraining it to be what I mean on the RHS of the <$ )
11:21:38 <timthelion> The closest I found is iterateN but I'm not sure that's what I want.
11:21:43 <byorgey> timthelion: not in the standard libraries, but you can easily do  iterate f x !! n
11:21:59 <timthelion> byorgey: I see :) thanks
11:23:52 <Cale> be careful though
11:24:13 <Cale> if n is large, that can be annoyingly problematic
11:24:38 <byorgey> Cale: what do you mean?
11:24:48 <Philippa> timthelion: you basically want foldNat1, as it were?
11:25:30 <timthelion> Cale: that did occure to me.  But for this case, I'm setting indentation levels.  So it'll never be more than about 5.
11:25:41 <Philippa> Cale, byorgey: did my code commit the mortal sin of showing a newbie code that Does Stuff and didn't have an attached type annotation? :-)
11:26:12 <Cale> byorgey: used to be an almost-guaranteed stack overflow, but I just tried it and it only used up lots of memory.
11:26:17 <sclv> i'm having a brain flake. there's a line of research where you have a program, and you change one input, and it only recomputes what it needs and not the whole thing again. this is similar to FRP but its a different line of research with a different name. i thought the name was incrementalization but that's something else. anybody remember the name/have some cites offhand?
11:26:23 <monochrom> oh! "iterate f x !! 100000" builds a 100000-deep expression first
11:26:39 <monochrom> "while we were talking about thunks" :)
11:27:11 <monochrom> yes recent GHC grows stack on the fly. marvellous achievement
11:27:19 <Cale> hah
11:27:24 <Cale> Well, that's reasonable.
11:27:39 <timthelion> > iterate (:' ') "a" !! 100000000
11:27:40 <lambdabot>   Couldn't match expected type `[a]'
11:27:40 <lambdabot>         against inferred type `GHC.Types...
11:27:46 <timthelion> > iterate (:' ') "a" ! 100000000
11:27:47 <lambdabot>   Couldn't match expected type `[a]'
11:27:47 <lambdabot>         against inferred type `GHC.Types...
11:27:55 <timthelion> > iterate (' ':) "a" ! 100000000
11:27:56 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
11:27:56 <lambdabot>         against inferred t...
11:27:58 <Philippa> sclv: incremental recomputation? Incremental programming?
11:28:08 <byorgey> interesting, I never thought much about the performance of the  iterate/!! thing.  I just figured the list would get fused away or whatever, perhaps that was naïve
11:28:12 <Philippa> Generally I see it as something based around 'incremental', anyway
11:28:19 * timthelion should probably quit being a programmer and go wait tables.
11:28:21 <typoclass> Philippa: i have no clue about implementing typecheckers, but that looks surprisingly clear and readable
11:28:32 <sclv> aha! "incremental computation"
11:28:34 <Philippa> typoclass: yeah, that's what I've been golfing it for :-)
11:28:35 <sclv> I was close
11:28:40 <monochrom> the list gets fused. that part doesn't cause a problem
11:28:42 <timthelion> > iterate (' ':) "a" !! 100000000
11:28:46 <lambdabot>  Terminated
11:28:53 <Cale> > iterate (' ':) "a" !! 100000
11:28:54 <byorgey> Philippa: you are exempted from showing type signatures when your code itself does type inference ;)
11:28:56 <lambdabot>   "                                                                          ...
11:29:06 <monochrom> and that part doesn't eliminate the 10000-deep thunk "f (f (f (f (f ... x]"
11:29:06 <Cale> > iterate (1+) 0 !! 100000
11:29:08 <lambdabot>   100000
11:29:09 <Cale> > iterate (1+) 0 !! 1000000
11:29:11 <lambdabot>   *Exception: stack overflow
11:29:12 <timthelion> @botsnack
11:29:12 <lambdabot> :)
11:29:16 <Cale> ^^ this is old GHC
11:29:18 <kanedank> is it okay that this function is returning an agent within IO?: http://hpaste.org/74410
11:29:20 <byorgey> monochrom: oh, right, now I see.
11:29:29 <Cale> New GHC just uses lots of memory for that and succeeds
11:29:34 <kanedank> I can't tell if that's what I should be doing...
11:29:47 <timthelion> Cale: GHC is getting much better at these things :)
11:29:56 <byorgey> monochrom: but that would be a problem with a naive direct encoding of it as well.  You'd have to add strictness annotations to get around it, right?
11:29:58 <Philippa> typoclass: anyway, thanks! I guess I'm a bit out of touch about which possible idioms are idiomatic these days
11:30:09 <rwbarton> "iterate f x !! 1000000" is bad when f is strict, right? you want to force elements of the list as you throw them away
11:30:18 <monochrom> yes
11:30:23 <timthelion> rwbarton: it's bad regardless.
11:30:36 <rwbarton> but when f is lazy it's okay, iterate f x !! n evaluates after a few steps to f (iterate f x !! (n-1)), no?
11:30:46 <mm_freak> rwbarton: the problem is not f, but (!!)
11:30:50 <monochrom> "mapM_ print (iterate f x)" does not cause any growth. this boggles many minds
11:30:58 <mm_freak> (!!) is performs a nonstrict traversal
11:30:59 <byorgey> kanedank: if you want randomness, sure.
11:31:08 <Cale> @src (!!)
11:31:08 <lambdabot> xs     !! n | n < 0 = undefined
11:31:08 <lambdabot> []     !! _         = undefined
11:31:08 <lambdabot> (x:_)  !! 0         = x
11:31:08 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:31:11 <Nereid> mm_freak: we need a (!!!)? ;)
11:31:12 <timthelion> mm_freak: actually, if you think about that, with lazyness, that's fine...
11:31:13 <rwbarton> maybe you want a nonstrict traversal
11:31:14 <Mortchek> Cale, thanks for the information.
11:31:18 <rwbarton> like i said... when f is lazy
11:31:20 <monochrom> hahaha "!!!"
11:31:20 <byorgey> kanedank: you could also use a special-purpose random monad.
11:31:23 <thirsteh> !!'
11:31:24 <mm_freak> timthelion: it isn't…  same problem as with foldl
11:31:29 <Mortchek> Is it still possible to use lens with ghc 7.0.4?
11:31:32 <byorgey> kanedank: see the MonadRandom package
11:31:37 <mm_freak> when f isn't strict, it might be fine
11:31:38 <Mortchek> -still
11:31:38 <rwbarton> > head (iterate (' ':) "a" !! 100000000)
11:31:46 <rwbarton> oh
11:31:46 <lambdabot>   mueval: ExitFailure 1
11:31:47 <lambdabot>  mueval: Prelude.undefined
11:31:51 <mm_freak> but i can't think of an example where that would be ok
11:31:56 <monochrom> (!x:xs) !!! n = xs !!! (n-1)   so many bangs
11:31:58 <rwbarton> hm
11:32:05 <rwbarton> it doesn't know the list is even infinite
11:32:44 <Nereid> well, you can't know that list is infinite
11:32:47 <Nereid> if you're just given some random list
11:32:51 <rwbarton> well, *I* can know
11:32:55 <Cale> rwbarton: It doesn't know that the nth element of the list is the nth iterate of f until it gets there
11:33:06 <rwbarton> @src iterate
11:33:06 <lambdabot> iterate f x =  x : iterate f (f x)
11:33:09 <timthelion> Cale++
11:33:25 <rwbarton> yeah, I want more like x : map f (iterate f x)
11:33:31 <rwbarton> except that would only work with a stream
11:33:56 <rwbarton> @let iterate' f x = x : map f (iterate' f x)
11:34:00 <lambdabot>  Defined.
11:34:06 <rwbarton> > head (iterate' (' ':) "a" !! 100000000)
11:34:11 <lambdabot>   mueval-core: Time limit exceeded
11:34:21 <Cale> > iterate' (' ':) "a"
11:34:24 <lambdabot>   mueval-core: Time limit exceeded
11:34:31 <rwbarton> did i break it
11:34:37 <rwbarton> > take 5 $ iterate' (' ':) "a"
11:34:40 <lambdabot>   ["a"," a","  a","   a","    a"]
11:34:51 <Nereid> > iterate' (' ':) "a"
11:34:53 <lambdabot>   ["a"," a","  a","   a","    a","     a","      a","       a","        a"," ...
11:34:56 <rwbarton> oh is this an n^2 algorithm
11:35:09 <rwbarton> @let iterate' f x = z where z = x : map f z
11:35:09 <lambdabot>  <local>:4:0:
11:35:10 <lambdabot>      Warning: Pattern match(es) are overlapped
11:35:10 <lambdabot>               In...
11:35:13 <rwbarton> ugh
11:35:15 <Nereid> Cale: how come it does that occasionally?
11:35:20 <Cale> @undefine
11:35:31 <Cale> @let iterate' f x = z where z = x : map f z
11:35:33 <lambdabot>  Defined.
11:35:46 <Nereid> does @undefine clear all @lets?
11:35:49 <Cale> yes
11:35:55 <Nereid> ok
11:35:59 <rwbarton> > iterate' (' ':) "a"
11:36:00 <Cale> (regardless of whether you try to give it a parameter)
11:36:02 <lambdabot>   ["a"," a","  a","   a","    a","     a","      a","       a","        a"," ...
11:36:04 <Nereid> heh
11:36:31 <Nereid> I guess it would be harder to just remove one definition.
11:36:55 <timthelion> Nereid: because things being difficult is always the key reason why haskellers don't do things.
11:37:00 <rwbarton> @let ~(x:xs) !!@ 0 = x; ~(x:xs) !!@ n = xs !!@ (n-1)
11:37:02 <lambdabot>  Defined.
11:37:12 <rwbarton> > head (iterate' (' ':) "a" !!@ 100000000)
11:37:16 <lambdabot>   mueval-core: Time limit exceeded
11:37:34 <rwbarton> I am not having much luck here
11:38:02 <Cale> @src (!!)
11:38:02 <lambdabot> xs     !! n | n < 0 = undefined
11:38:02 <lambdabot> []     !! _         = undefined
11:38:02 <lambdabot> (x:_)  !! 0         = x
11:38:02 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:38:05 <rwbarton> right, it has no way to prove that map f xs !!@ n = f something
11:38:09 <Nereid> well yeah, you're still having to deconstruct that list 100000000 levels deep
11:38:17 <rwbarton> which is what I want it to do
11:39:28 <Cale> That would be a super-cute graph rewrite rule to apply in a language like HOPS
11:39:29 <timthelion> rwbarton: Please do note, that what lambdabot does, and what ghc -O2 does are rather unrelated, and some things may excede time limit with lambdabot that are fine with -O2
11:39:58 <Cale> No, this doesn't have anything to do with ghc -O2 :)
11:40:17 <rwbarton> you could have a rule for this actually
11:40:23 <Cale> yeah...
11:40:30 <Cale> though it wouldn't really save you here
11:40:32 <rwbarton> but it doesn't sound very useful
11:40:47 <Cale> because RULES only expand at compile time
11:40:55 <rwbarton> you would have to guess how many times to expand the RULE
11:41:07 * timthelion spent an entire day trying to figure out why his non naive hashtable based median function was slower than the naive one.  -O2 fixed it :)
11:41:35 <rwbarton> you should never even look at the runtime of a program you didn't build with -O2
11:41:42 <Cale> btw, I believe lambdabot does compile things with -O2 anyway
11:41:54 <timthelion> really?
11:42:02 <rwbarton> if so that's probably part of why it times out so much :P
11:42:15 <Cale> yeah, probably
11:42:37 <Cale> I should probably give it a few more seconds
11:43:55 <Ferdirand> is there a way to give -O2 to ghc by default ? with the environment perhaps ?
11:44:00 <Ferdirand> the manpage doesn't say
11:44:10 <rwbarton> > head $ foldr (.) id (replicate 1000000 (' ':)) "a"
11:44:12 <lambdabot>   ' '
11:44:22 <rwbarton> at least you can use this one for a lazy function
11:44:27 <Nereid> ':))
11:45:18 * timthelion wonders if cabal uses -O2 by default
11:45:20 <Nereid> > head $ foldl' (.) id (replicate 1000000 (' ':)) "a"
11:45:22 <lambdabot>   ' '
11:45:28 <Nereid> > head $ foldl' (.) id (replicate 1000000000 (' ':)) "a"
11:45:33 <lambdabot>   mueval-core: Time limit exceeded
11:45:36 <Nereid> > head $ foldr (.) id (replicate 1000000000 (' ':)) "a"
11:45:38 <lambdabot>   ' '
11:45:42 <Nereid> > head $ foldl (.) id (replicate 1000000000 (' ':)) "a"
11:45:51 <lambdabot>   mueval: ExitFailure 1
11:45:51 <lambdabot>  mueval: Prelude.undefined
11:45:51 <dcoutts_> timthelion: -O by default, because that's ghc's default optimisation level
11:46:01 <Nereid> eh, that's a new error.
11:46:47 <timthelion> dcoutts_: haskellers... spend years studying optimization. write theses(plural) on the subject... do nothing to make sure default options are resonable
11:47:40 <MagneticDuck> hey, I'm trying to install terminfo on my linux machine
11:47:44 <MagneticDuck> and I'm getting and eror
11:47:46 <MagneticDuck> *error
11:47:50 <MagneticDuck> it can't find "curses.h"
11:48:01 <MagneticDuck> what do I have to install to get that?
11:48:11 <Ferdirand> ncurses ?
11:48:12 <timthelion> libncurses maybe?
11:48:19 <dcoutts_> timthelion: hmm? -O is reasonable
11:48:21 <MagneticDuck> ah
11:48:23 <Ferdirand> the -dev package probably
11:48:31 <MagneticDuck> it's weird though
11:48:41 <MagneticDuck> I'm trying to install yi
11:48:42 <timthelion> dcoutts_: Why is it reasonable?  I don't care how long my cabal files take to compile. I wan them to run fast.
11:48:52 <MagneticDuck> it should be a bug that it can't install by itself
11:48:59 <dcoutts_> timthelion: have you checked if it runs faster?
11:49:40 <timthelion> dcoutts_: are there times when -O is faster?
11:50:05 <dcoutts_> timthelion: point is, -O is where ghc devs stick all the optimisations that are reasonable for most software, -O2 isn't always faster for general stuff, it's faster for some, but it can also be slower.
11:50:34 <rwbarton> there is also a third case... -O2 produces the same code as -O but takes longer to compile
11:50:34 <petekaz> newbie question: I'm reading LYAH and trying to follow along with the Writer example, but I can't find the module it's located it. LYAH mentions Control.Monad.Writer, but ghci says it's not in scope after I load that module.
11:50:43 <timthelion> dcoutts_: If it was slower, in any large percentage of cases, that would be a bug...
11:51:00 <rwbarton> optimization is hard
11:51:05 <timthelion> rwbarton: that's fine, if you are installing packages you are going to compile once and run every day.
11:51:22 <dcoutts_> timthelion: can be slower due to more code, lots of reasons
11:51:30 <dcoutts_> timthelion: you are of course free to put -O2 into your ~/.cabal/config
11:51:36 <MagneticDuck> grr, I'm installing c2hs manually now
11:51:37 <MagneticDuck> xD
11:51:43 <MagneticDuck> they should do something about this
11:51:55 <MagneticDuck> terminfo needs ncurses
11:51:59 <MagneticDuck> ncurses needs c2hs
11:52:05 <Cale> petekaz: what is it saying isn't in scope?
11:52:05 <MagneticDuck> and they don't do it automatically?
11:52:09 <rwbarton> hi petekaz, what exactly is ghci saying is not in scope?
11:52:22 <petekaz> Cale: the constructor 'Writer', it's suggesting WriterT instead.
11:52:30 <dcoutts_> timthelion: but what we recommend is that people stick with the default, and package authors only override it if there are measurable improvements
11:52:36 <timthelion> MagneticDuck: I'll love you forever if you fix it :)
11:52:48 <timthelion> dcoutts_: OK.
11:53:04 <MagneticDuck> gaah, ncurses isn't working still
11:53:09 <MagneticDuck> I installed c2hs with no problems
11:53:14 <MagneticDuck> but now it can't find the executable
11:53:20 <rwbarton> timthelion, if they add an optimization that helps 80% of the time, and hurts 20% of the time (let's say by "the same amount"), is that a bug? if so, they could "fix" the bug by removing the optimization, would that be an improvement?
11:53:56 <timthelion> rwbarton: I don't know.
11:54:26 <timthelion> rwbarton: it occurs to me, that the only real way to fix most of those, would be an inline pragma that would say whether the coder thinks a given list will be long or not.  Ect.
11:54:51 <timthelion> rwbarton: and such pragmas DO exist.
11:54:52 <rwbarton> I'm just saying, expecting -O2 to be better than -O 100% of the time will just result in -O2 being slower than it might otherwise be most of the time
11:55:01 <hpaste> petekaz pasted “LYAH Writer Example” at http://hpaste.org/74412
11:55:33 <timthelion> rwbarton: of course. but you expect -O2 to be better than -O most of the time.  You expect to use -O and -O0 just for debuggin when you want fast compile times...
11:55:47 <timthelion> s/debuggin/debugging/
11:56:04 <petekaz> I'm just trying to :l the file that contains the above paste.
11:57:23 <rwbarton> petekaz: oh yeah, the *data* constructor Writer isn't called that any more
11:58:03 <rwbarton> use WriterT instead, but only on line 4
11:58:12 <petekaz> rwbarton: Thanks!
11:59:12 <rwbarton> this bit of the library was reorganized since LYAH was written, but it's usually transparent since using the Writer data constructor directly is rare
12:00:22 <rwbarton> normally you'd write something like  logNumber x = tell ["Got number: " ++ show x] >> return x
12:00:32 <qnikst> hello, how can I use unix socket? (filebased)
12:01:18 <petekaz> rwbarton: got it!
12:01:20 <qnikst> in network.socket I can't see anything related to file, or I should create a fd and then mkSocket from it?
12:01:51 <Clint> qnikst: use Network with a PortID of UnixSocket filepath
12:06:59 <qnikst> Clint: SockAddrUnix String?
12:07:01 <qnikst> thanks
12:08:45 <eikke> if I have a cmm file, is there any way to get a primop defined in it inlined in other code?
12:16:57 <johnw> afternoon
12:17:38 <johnw> wow, lot of updated packages today!
12:17:43 <johnw> even a new lambdabot
12:17:58 <typoclass> yo johnw
12:18:09 <typoclass> new compiler as well :) http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html
12:18:19 <johnw> that I built yesterday :)
12:18:25 <hpaste> “Dark Magus” pasted “Binarize” at http://hpaste.org/74413
12:19:23 <osa1> does anyone here use Language.JavaScript.Pretty.Printer? I'm trying to use it as a javascript code prettifier but it's not actually prettifying anything, it just prints in minified format, am I doing something wrong? here's my code: http://hpaste.org/74414
12:30:27 <nand`> Since Agda programs must terminate, Agda is not turing complete, correct?
12:30:41 <DanBurton> I believe there is an option to disable the termination checker
12:30:51 <nand`> well, assuming that option is not set
12:30:52 <DanBurton> but yes, if you leave it enabled, it is not turing complete
12:31:12 <nand`> what practical implications does this lack of turing completeness have for real world programming (again, assuming you don't disable the termination checker)?
12:31:28 <DanBurton> not sure
12:31:45 <Botje> you can't write servers, for example.
12:31:52 <djahandarie> Agda has coinduction.
12:32:05 <djahandarie> So you can write servers, and other sorts of programs that run forever.
12:32:07 <DanBurton> it's certainly inconvenient to disallow code like forever x = x >> forever x
12:32:19 <djahandarie> (They just need to be 'productive'.)
12:32:30 <int-e> so it's turing complete.
12:32:54 <DanBurton> someone should write a turing machine in agda
12:32:56 <djahandarie> It's not turing complete. There are still classes of programs that can't be written. I'm not exactly sure what that class is, but I've never had to write one.
12:33:39 <rwbarton> presumably "agda compiler" is one?
12:33:48 <int-e> you can write a turing machine emulator producing a stream of intermediate states
12:35:04 <t7> speaking of agda, is there any good docs besides 'foetus' describing termination checking?
12:35:09 <t7> are there*
12:36:32 <aristid> djahandarie: isn't the problem in practice more that some properties are hard to prove rather than they can't be proven? :)
12:37:50 <nand`> that's one thing I was wondering about; say you had a language where functions must terminate, but you had a special ‘main’ function that may receive infinite amounts of input, like a request/response (free monad?) model where each request must terminate to a response (+continuation)
12:38:03 <nand`> ie. the RTS being the only thing that can not terminate
12:38:11 <djahandarie> nand`, look at coinduction.
12:38:17 <nand`> I will
12:39:48 <djahandarie> aristid, I haven't done much serious stuff in Agda, but I've found that: A. you're either trying to prove something that isn't actually true in intuitionistic logic, or B. you're thinking about it wrong, and figuring out how to prove it in Agda actually results in a nicer proof than what you had before
12:40:21 <aristid> djahandarie: yes, but (B) takes time :)
12:44:56 <martinalex> hi, i have a question about how haskell interprets this function doubles = 1: (map (\x-> 2*x) doubles). It should be this zyclic data-structure but i cant imagine why it does the right thing
12:45:04 <allsystemsarego> @src >>
12:45:05 <lambdabot> m >> k      = m >>= \_ -> k
12:46:02 <martinalex> how does map find "the rest" of the list?
12:46:14 <martinalex> shouldnt this be just this "map" statement?
12:46:38 <byorgey> martinalex: well, map begins by asking whether doubles is empty or a cons
12:46:48 <byorgey> martinalex: we already know doubles is   1 : something
12:47:34 <byorgey> so map can apply the function to the first element, that is, 1, and produce a 2 before needing to look at the rest
12:47:50 <byorgey> so now doubles looks like   1 : 2 : (map ... something)
12:48:02 <byorgey> and so on
12:48:38 <martinalex> so it does really double all elements in this list each time it goes throug it?
12:48:59 <byorgey> martinalex: what do you mean "each time"?  map only traverses the list once
12:49:26 <byorgey> > let doubles = 1 : (map (*2) doubles)  in doubles
12:49:27 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
12:49:47 <byorgey> > let doubles = 1 : (map (*2) doubles)  in map (*2) doubles
12:49:48 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
12:49:51 <jfischoff> neat
12:49:53 <byorgey> > let doubles = 1 : (map (*2) doubles)  in  1 : map (*2) doubles
12:49:55 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
12:50:17 <martinalex> hm...
12:50:54 <byorgey> martinalex: do you see that if we already had  doubles = [1,2,4,8,...] defined, that we would have   doubles = 1 : map (*2) doubles  ?
12:50:58 <martinalex> well, i found out that it does the right thing... but then i didnt get how the 2 gets near the end of the list and not at the first position
12:51:23 <Cale> martinalex: The definition of doubles says that 1 is the first element of the list
12:52:49 <martinalex> byorgey: i dont get what you mean
12:53:54 <martinalex> Cale: so it get put there every time we need it? how often will this 1 will be inserted in the list? Once?
12:53:58 <tromp_> here's a fun challenge: from a collection of disjoint sets, compute the collection of sets that have at most one element from each set in the collection
12:54:15 <tromp_> (everything with lists of lists)
12:54:35 <tromp_> then make it work for infinite collections of infinite sets:)
12:54:36 <Cale> martinalex: 1 isn't *inserted into* the list.
12:54:45 <Cale> martinalex: It's the first element of the list.
12:54:53 <vroooom> which would be the channel to discuss websiteideas?
12:55:02 <Cale> martinalex: The list never changes :)
12:55:04 <vroooom> and stuff like DNS etc
12:55:23 <rwbarton> there is no "doing" in this definition, only "being"
12:56:00 <Cale> However, if you'd like to see how the graph reduction looks in memory as this proceeds, I can draw it.
12:56:36 <martinalex> Cale: but in which form does map take the first element and make its computation the secont one?
12:57:10 <martinalex> Cale: i found this webpage: http://www.fh-wedel.de/~si/seminare/ws03/Ausarbeitung/a.unendlicheListen/layout4.htm
12:57:28 <Lutin`> martinalex: flip map
12:57:47 <rwbarton> map doesn't do that. the fact that the first element of the result of map is the second element of doubles is a consequence of the definition of doubles
12:58:25 <rwbarton> specifically, it's what (:) means
12:59:05 <Lutin`> Maybe a definition of map using List a would help
12:59:19 <vroooom> > foldl (:) [] [1..10]
12:59:21 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:59:32 <vroooom> > foldr (:) [] [1..10]
12:59:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:59:38 <Lutin`> Since lists hide behind some syntactic sugar
12:59:49 <vroooom> @src foldr
12:59:49 <lambdabot> foldr f z []     = z
12:59:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:59:57 <martinalex> rwbarton: that seems to be the thing i did not understand
13:00:34 <vroooom> > foldl (-) 0 [1,2,3]
13:00:35 <rwbarton> "x : xs" is the list whose first element is x and whose remaining elements are the list xs
13:00:35 <lambdabot>   -6
13:00:41 <vroooom> > foldr (-) 0 [1,2,3]
13:00:42 <lambdabot>   2
13:00:46 <martinalex> Lutin`: i know of usual lists - but plainly not enough to understand cyclic structures
13:01:03 <Lutin`> (:) :: a -> [a] -> [a]
13:01:21 <Lutin`> :t (:)
13:01:22 <lambdabot> forall a. a -> [a] -> [a]
13:01:34 <Lutin`> forgot about that lol
13:01:45 <martinalex> my problem was mostly the cyclyc aspect of it
13:01:47 <Lutin`> martinalex: Do you know of haskell lists
13:01:53 <vroooom> > (-) 1 ((-) 2 ((-) 3 0) )
13:01:54 <lambdabot>   2
13:02:07 <martinalex> not the list monade, but enough to deal with them
13:02:13 <Lutin`> As a recursive type
13:02:21 <nand`> do you understand how  cat = "meow " ++ cat  works?
13:02:37 <typoclass> awww kitties :-D i like
13:02:53 <nand`> (that was aimed at martinalex, mind)
13:02:59 <vroooom> > let cat = "meow" ++ cat in cat
13:03:03 <lambdabot>   "meowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowme...
13:03:07 <martinalex> :D this is like the usual example ones...
13:03:09 <martinalex> yes
13:03:24 <nand`> so you also understand how foo = 1 : foo  works?
13:03:41 <martinalex> yes
13:04:03 <nand`> then it's only a small step to foo = 1 : map (2*) foo  :P
13:04:05 <Lutin`> let cat = "meow" ++ cat in sequence cat
13:04:14 <martinalex> this should have to do with a pointer back to the beginning
13:04:16 <Lutin`> Whoops
13:04:20 <Lutin`> > Whoops
13:04:22 <lambdabot>   Not in scope: data constructor `Whoops'
13:04:24 <Lutin`> fff
13:04:30 <Lutin`> > let cat = "meow" ++ cat in sequence cat
13:04:31 <lambdabot>   Couldn't match expected type `m a'
13:04:31 <lambdabot>         against inferred type `GHC.Types...
13:04:59 * hackagebot monarch 0.7.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.7.0.0 (NoriyukiOhkawa)
13:05:00 <Lutin`> Oh
13:05:02 <johnw> let cat = "kitteh" ; cat = "meow" ++ cat in sequence cat
13:05:04 <johnw> > let cat = "kitteh" ; cat = "meow" ++ cat in sequence cat
13:05:06 <lambdabot>   Conflicting definitions for `cat'
13:05:06 <lambdabot>  Bound at: <interactive>:1:4-6
13:05:06 <lambdabot>           ...
13:05:08 <Lutin`> I know what I'm doing
13:05:18 <johnw> what?
13:05:23 <Lutin`> > let cat = "meow " ++ cat in ( sequence .words )cat
13:05:26 <lambdabot>   mueval-core: Time limit exceeded
13:05:36 <Lutin`> Whoops
13:05:38 <nand`> Lutin`: what are you trying to accomplish here?
13:06:04 <martinalex> nand`: but there something changes... and it matters which of the elements came first and how often map is started
13:06:17 <rwbarton> too much "doing"
13:06:22 <rwbarton> look at it this way
13:06:33 <Lutin`> > let a = "lol this" in (unwords . sequence . words) a
13:06:35 <lambdabot>   "lt lh li ls ot oh oi os lt lh li ls"
13:06:36 <rwbarton> doubles = 1 : map (2 *) doubles
13:06:43 <Cale> martinalex: so it starts out looking like this: http://cale.yi.org/share/doubles.png
13:06:45 <rwbarton> we know this is a list that starts with 1
13:06:55 <rwbarton> oh pretty
13:07:05 <vroooom> > (:) 1 []
13:07:06 <Lutin`> > let a = "lol this" in (join . sequence . words) a
13:07:06 <lambdabot>   [1]
13:07:07 <lambdabot>   can't find file: L.hs
13:07:10 <shapr> johnw: How many hackages do you maintain now? Does una work on Linux for arc/zip/zoo/lha/tar.bz2/ etc?
13:07:15 <vroooom> @src (:)
13:07:15 <lambdabot> Source not found. Wrong!  You cheating scum!
13:07:25 <vroooom> how is that donr anyway?
13:07:26 <johnw> shapr: I think I have seven; and yes
13:07:50 <Lutin`> > let a = "lol this" in (join . sequence . words) a
13:07:52 <lambdabot>   "ltlhlilsotohoiosltlhlils"
13:08:06 <Lutin`> > let a = "meow meow meow" in (join . sequence . words) a
13:08:08 <lambdabot>   "mmmmmemmommwmemmeemeomewmommoemoomowmwmmwemwomwwemmemeemoemweemeeeeeoeeweo...
13:08:11 <Lutin`> THat
13:08:25 <nand`> ‘moo’
13:08:30 <nand`> talks like a cow, must be a cow
13:08:42 <thirsteh> > scream meow meow meow
13:08:44 <lambdabot>   Not in scope: `scream'Not in scope: `meow'Not in scope: `meow'Not in scope:...
13:08:49 <simon> Lutin`: haha.
13:08:51 <thirsteh> aww, the definitions don't stick
13:09:05 <nand`> scream = map toUpper ?
13:09:07 <Lutin`> I love taking strings and then using hoogle to mess with them
13:09:30 <simon> :t sequence
13:09:30 <thirsteh> it was worse, sec
13:09:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:09:58 <Lutin`> simon: Probleme﻿ mit dem Tachometer 2:40? ... bei 300+ scheint er auch ziemlich flattrig zu werden auf der Borderachse, oder?
13:10:00 <Lutin`> WHoops
13:10:11 <Lutin`> simon: Why does my clipboard hate me
13:10:18 <Lutin`> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html#sequence
13:10:21 <allsystemsarego> Cale, what did you use to generate that"doubles" diagram?
13:11:00 <johnw> shapr: it's also very easy to add new unarchivers
13:11:14 <Cale> allsystemsarego: inkscape
13:11:35 <shapr> johnw: Neat, does it check for the existence of particular binaries to see if it can unarchive things?
13:11:46 <johnw> shapr: further, it's recursive.  If you have a README.txt in a foo.iso.tar.gz, you just need one una invocation
13:11:55 <shapr> For example I think 7zip can create archives that only it can undo, but it can undo almost every other archive flavor.
13:12:04 <shapr> whoa, how?
13:12:05 <johnw> shapr: well, if the executable isn't there I think you'll just get an error
13:12:06 * shapr grabs the code
13:12:10 <allsystemsarego> Cale, oh, ok, I thought it was some magic tool that you give some Haskell code and it draws pretty diagrams
13:12:24 <Cale> For some reason, people always think that
13:12:26 <johnw> shapr: una will invoke 7z
13:12:33 <nand`> martinalex: doubles = 1 : map (*2) doubles = 1 : (1*2) : map (*2) (map (*2) doubles) = 1 : (1*2) : (1*2*2) : map (*2) (map (*2) (map (*2) doubles)) ...
13:12:42 <rwbarton> or
13:12:44 <nand`> > let doubles = 1 : map (*2) doubles in doubles :: [Expr]
13:12:45 <lambdabot>   [1,1 * 2,1 * 2 * 2,1 * 2 * 2 * 2,1 * 2 * 2 * 2 * 2,1 * 2 * 2 * 2 * 2 * 2,1 ...
13:12:45 <johnw> shapr: I don't rely on Haskell libraries for unarchiving; I use the usual executables for each format
13:12:53 <shapr> cool
13:13:10 <shapr> Would be neat to have something like file to figure out formats and do it in Haskell :-)
13:13:31 <rwbarton> doubles = 1 : ... => {- substitute -} doubles = 1 : map (*2) (1 : ...) = 1 : 2 : ... => {- substitute -} doubles = 1 : map (*2) (1 : 2 : ...) = 1 : 2 : 4 : ...
13:13:38 <rwbarton> => ...
13:13:44 <johnw> looks like it handles 38 formats, include .gpg
13:13:59 <johnw> and it's recursive for any format that acts as an "archive"
13:14:03 <Lutin`> martinalex: You're just doubling the entire list and then stick a one on the front over and over
13:14:24 <dgpratt> I remember coming across some diagrams a while back that described (IIRC) certain CT related things, initial and terminal objects, etc.; anyone know of such a thing (Cale?)?
13:14:33 <martinalex> Lutin`: this seems not be what happens inside of haskell
13:14:40 <Lutin`> Well yes
13:14:46 <Lutin`> But that's an implementation detail
13:14:59 <Lutin`> The outcome is the same
13:15:07 <Lutin`> 1 : 2 : 4 : 8 ...
13:15:08 <nand`> actually, it's a semantics detail - that way of wording it makes it sound like it'd never complete
13:15:13 <martinalex> Lutin`: i have tried some versions and the speed differs by a huge factor
13:15:43 <nand`> though now that I think about it, it isn't too strange
13:15:50 <rwbarton> I thought you didn't understand why doubles would be 1 : 2 : 4 : 8 : ....  "How"/"how fast" are another question
13:16:03 <Lutin`> ^
13:16:33 <martinalex> rwbarton: its both of it - i know it is this cyclic data structure and dont know how to evaluate it
13:16:48 <Cale> http://cale.yi.org/share/doubles-2.png
13:16:57 <Lutin`> nand`: It's really not because of rewriting
13:16:58 <rwbarton> well, I think you got many answers to "how can I convince myself that doubles = 1 : 2 : 4 : 8 : ..."
13:17:12 <Cale> dgpratt: Sure... there are diagrams which describe initial and terminal objects...
13:17:18 <Lutin`> It goes down to 1 : (one before this * 2)
13:17:21 <martinalex> rwbarton: yes, thats true
13:17:51 <Cale> dgpratt: An initial object is an object 0 such that for any other object X in C, there is a unique arrow 0 -> X.
13:17:52 <Lutin`> martinalex: You can always compile it in ghc
13:17:56 <rwbarton> Cale is drawing pictures of what actually happens when you try to evaluate it in a Haskell interpreter
13:17:58 <Lutin`> if that's what you care about
13:18:02 <thirsteh> @let scream = concat . sequence . words
13:18:05 <lambdabot>  Defined.
13:18:10 <thirsteh> > scream meow meow meow
13:18:11 <lambdabot>   Not in scope: `meow'Not in scope: `meow'Not in scope: `meow'
13:18:22 <martinalex> rwbarton: but Cale did draw this picture i dont know how to use it
13:18:26 <thirsteh> > scream "meow meow meow"
13:18:29 <lambdabot>   "mmmmmemmommwmemmeemeomewmommoemoomowmwmmwemwomwwemmemeemoemweemeeeeeoeeweo...
13:18:32 <martinalex> and this was exactly what i was looking for
13:18:35 <Cale> dgpratt: A terminal object is an object 1 such that for any other object X in C, there is a unique arrow X -> 1
13:18:48 <nikita-0> Cale: any object at all, not "any other".
13:19:21 <Cale> nikita-0: Oh, indeed, I didn't mean to imply that there was an inequality condition :)
13:19:27 <nikita-0> (same for initial.)
13:19:33 <martinalex> rwbarton: i have seen them in the lecture - but we did move over it quite fast
13:20:19 <martinalex> Cale: thx, nice drawings!
13:20:27 <Cale> martinalex: does that make sense?
13:20:30 <kanedank> when should I stop reading and start coding? when I understand monad transformers?
13:20:44 <martinalex> Cale: it looks familiar...
13:20:47 <Cale> martinalex: lines go from the bottom of functions to the top of their arguments in those graphs
13:20:58 <dgpratt> Cale: most edifying as always, thanks; I am still hoping to find that paper/site/blog post that I recall seeing some time ago
13:21:43 <rwbarton> there are a bunch of papers that explain initial algebras/final coalgebras and their relation to data types
13:22:06 <nand`> another step and you'd have a pretty knot
13:22:14 <Cale> dgpratt: They're the trivial examples of a limit and colimit, whose diagrams are a little more interesting in general
13:22:50 <dgpratt> Cale: yes, you remind me that the thing of which I speak referenced limits/colimits
13:23:00 <martinalex> Cale: so in the next step the *2 would go to the next (which means the second) element of the list?
13:23:18 <Cale> martinalex: yeah, the one which already has (*2) in it
13:23:27 <nand`> martinalex: the (*2) would go to the first element of what the second argument of ‘map’ points to
13:23:31 <nand`> in this case, the upper (*2)
13:23:40 <rwbarton> dgpratt: e.g. sections 2 and 3 of this paper from a week ago https://personal.cis.strath.ac.uk/robert.atkey/interleaving.pdf, but probably there are better ones out there with more diagrams
13:23:42 <martinalex> kk
13:24:14 <dgpratt> rwbarton: thanks, but it looks to be 404?
13:24:26 <Cale> I'm actually slightly regretting not having an explicit representation of application in these graphs now :)
13:24:27 <nand`> remove the ,
13:24:46 <martinalex> ok, i think i got the idea...
13:24:59 * hackagebot DAV 0.0 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.0 (ClintAdams)
13:25:18 <Cale> martinalex: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
13:25:43 <Cale> martinalex: There are some transformation sequences in a language which chooses to represent code graphs more visibly :)
13:25:45 <dgpratt> rwbarton: nvm, trailing comma
13:25:48 <nand`> that's a bit fast for my taste
13:26:37 <martinalex> Cale: looks pretty but it misses the "pause" button...
13:27:11 <Cale> yeah, I really wish that Dr. Kahl would make it available
13:27:18 <nand`> well, the main difference is that the former builds up a huge tree before reducing, while the latter runs in constant space
13:27:27 <Cale> (the actual language implementation)
13:27:46 <Lutin`> Yeah the second one doesn't go slow enough to be easily understood
13:27:48 <nand`> a constant origin would seem like a nice thing to have
13:28:04 <nand`> it jitters around a lot
13:28:22 <Lutin`> Yeah
13:28:31 <Lutin`> Oh wait
13:28:45 <Lutin`> Dammit are they gifs
13:28:55 <Cale> Basically, it's rotating the graph a bit
13:29:10 <napping> if I have some monad transformer T, is there any systematic way to make a T Maybe a -> T Identity a -> T Identity a that falls back to the second if the first fails
13:29:13 <nand`> you could download the .gif and display it in a nonconforming viewer
13:29:16 <nand`> that lets you step through it
13:29:24 <rwbarton> dgpratt: ah, this is one that i was thinking of. http://www.cs.ru.nl/~bart/PAPERS/JR.pdf
13:29:26 <Cale> Turning a * (b * c) into (a * b) * c
13:29:30 <Lutin`> Yeah
13:29:31 <Cale> on each step
13:30:02 <Cale> and yeah, iirc, in the actual running program, it did keep a constant origin
13:30:17 <Cale> but I might be remembering incorrectly
13:30:56 <dgpratt> rwbarton: oh, that looks good! thanks!
13:32:49 <DanBurton> I'm making a racket macro for monad comprehensions. What's a good short name that I can use to trigger the macro?
13:33:02 <DanBurton> right now I'm using "monad-comprehension" but that's a bit long
13:33:19 <Cale> I take it do is taken?
13:33:25 <DanBurton> it is
13:33:41 <rwbarton> m[
13:33:47 <rwbarton> is that a symbol
13:34:00 <DanBurton> I don't think brackets are allowable symbols
13:34:09 <nand`> mdo / mcomp ?
13:34:10 <DanBurton> in any event the lack of a close brace would drive people mad
13:34:23 <nand`> DanBurton: especially lispers?
13:34:25 <rwbarton> I imagine you could get a ] in there
13:34:53 <rwbarton> I guess with the surrounding ()s it would look odd
13:35:32 <DanBurton> I'm liking mcomp
13:35:50 <DanBurton> I just wish there were one of those two-letter things like "do" or "for" that weren't already taken
13:36:01 <Lutin`> mc
13:36:12 <DanBurton> tempting
13:36:19 <Lutin`> yay obscurity
13:36:21 <nand`> mcp ?
13:36:30 <DanBurton> how about "moo"
13:36:32 <Lutin`> mcmp would look like mcompare
13:36:40 <nand`> moo is good
13:36:43 <nand`> has my vote
13:36:51 <Lutin`> mew
13:36:52 <rwbarton> or how about monad
13:37:11 <Lutin`> nads
13:37:14 <DanBurton> "monad" is already going to be used theoretically
13:37:22 <rwbarton> okay
13:37:31 <Lutin`> nad-comp
13:37:50 <nand`> mprehension
13:37:56 <nand`> comonad mprehension
13:37:58 <copumpkin> a monad is just a lax 2-functor from a terminal bicategory, what's the problem?
13:38:20 <Lutin`> What the shit
13:38:24 <Ralith> lol
13:38:28 <Lutin`> I understood most of that o.o
13:38:38 <nand`> ‘lax’ ‘bicategory’ are new to me
13:38:47 <Lutin`> lax is new to me
13:38:55 <benmachine> 2-functor is also new to me
13:39:08 <benmachine> ...i.e. the only word I've heard of is "terminal"
13:39:30 <Lutin`> Well a monad is...
13:39:33 <Lutin`> lol
13:40:30 <benmachine> shh :P
13:40:42 <benmachine> a monoid object in the category of endofunctors
13:40:46 <benmachine> obv
13:40:51 <benmachine> (that one I actually *do* get)
13:41:02 <hpc> a monad is just a monad in the 2-category of categories!
13:41:35 <nand`> http://ncatlab.org/nlab/show/2-functor http://ncatlab.org/nlab/show/2-category http://ncatlab.org/nlab/show/lax+functor
13:42:23 <rwbarton> start with the second one :)
13:44:39 <johnw> Cale: have you use Control.Parallel.Strategies much?
13:47:35 * nand` has a feeling most of what he knows about category theory comes from work spent understanding humorous statements like copumpkin's
13:55:38 <johnw> how long until we have n-categories?
13:56:09 <copumpkin> I prefer m-categories
13:56:31 <johnw> oh, heh
13:56:36 <johnw> n-category is linked from the page
13:56:52 <rwbarton> haha, I am going to have to start saying m-categories now
13:57:20 <typoclass> johnw: it'll naturally fall out of the type-level quantum chromodynamics and string theory that's coming up
13:57:22 <nand`> I don't get it, what's different about m-categories vs n-categories?
13:57:40 <rwbarton> an m-category is just an n-category where n = m
13:57:48 <johnw> rwbarton: m has another hump
13:58:30 <copumpkin> rwbarton: yeah, exactly
13:59:23 <nand`> “A third and somewhat less obvious definition says that a monad in K is a lax 2-functor from the terminal bicategory 1 to K: the unique object * of 1 is sent to the object a, the morphism 1 a becomes t, and η and μ arise from the coherent 2-cells expressing lax functoriality.”
13:59:38 <typoclass> nand`: incorrect statement
13:59:47 <typoclass> it's a completely obvious definition
14:00:45 <byorgey> "somewhat less obvious", hehe
14:01:03 <byorgey> when a category theorist says something is not obvious...
14:01:06 <nand`> “mong higher-category theorists, it’s tempting to suggest that this is the most fundamental definition” <- higher-category theorists, heh
14:01:20 <typoclass> high on what?
14:01:47 <Cale> It's (higher category) theorists, not higher (category theorists)
14:01:57 <nand`> unfortunately
14:02:20 <byorgey> "among high category-theorists, it's tempting to suggest that, oh man, this sh** is f***ing awesome"
14:02:30 <Cale> Though sometimes their diagrams make you wonder whether it isn't an associative definition
14:02:33 <rwbarton> for copumpkin, high on m
14:02:37 <typoclass> Cale: thanks but i prefer the other explanation
14:03:30 <typoclass> "among high category theorists, it's tempting to suggest that, dude, have you ever noticed that toes are like foot fingers ..."
14:04:19 <rwbarton> toes are just fingers in the category of feet
14:04:33 <Cale> http://arxiv.org/pdf/math/0305049v1.pdf -- look at the picture of the morphism in the swiss-cheese multicategory on page 39, or... well, there are lots of amusing diagrams in that book
14:05:09 <Cale> page 194 is nice
14:05:53 <benmachine> oh hey, To Martin Hyland
14:05:55 <benmachine> he lectured me once
14:09:26 <rwbarton> I think it was the definition of tricategories that had truly boggling diagrams
14:09:43 <Cale> Higher category theory proceeds by one mathematician standing up and drawing a doodle on the blackboard, and then everyone else rushing to formalise it somehow
14:10:24 <monochrom> wow, tricategories :)
14:10:29 <nikita-0> Cale and when they get to \omega categories they don't need even a doodle.
14:10:47 <monochrom> oh yikes, omega categories
14:10:52 <nand`> Cale: that doesn't just apply to higher category theory
14:11:16 <monochrom> omega category diagrams are full of "..."s :)
14:11:34 <benmachine> is this omega as in the ordinal
14:11:50 <Cale> yeah
14:11:57 <benmachine> are there ε_0 categories
14:11:57 <monochrom> as for uncountable categories, that's when you just draw clouds and say "we go to the cloud"
14:12:43 <nand`> I like my categories ω₁
14:13:18 <benmachine> ω_ω
14:13:33 <benmachine> except that just looks like I have bizarre eyelids
14:13:48 <nand`> UNICODE SUBSCRIPT LOWERCASE GREEK OMEGA
14:14:10 <benmachine> nand`: is there actually one
14:14:14 <nand`> I have no idea
14:15:01 <benmachine> hmm
14:15:08 <benmachine> not on here http://www.w3.org/TR/MathML2/bycodes.html but a few things aren't there
14:15:25 * typoclass is skeptical about books with lots of cloud diagrams, "...", and no code
14:16:42 <Cale> hah, on page 43 there's an amusing note
14:17:34 <Ferdirand> i wish i had 72-hour long days
14:17:38 <Cale> Many authors use the term ‘coloured operad’ to mean multicategory. The 'colours' are the objects, and the idea is that a multicategory is a more complicated version of an operad. ... the coloured viewpoint has given rise to eyebrow-raising statements such as [. . . ] it serves us well to have a subtle generalization of operad known as a bicolored operad. Still more colorful operads can be deﬁned, but they are cur
14:17:38 <Cale> rently not of great importance
14:17:42 <Ferdirand> so i would have time to understand all this
14:18:15 <Cale> of course, most of the coloured operads that one meets every day (Set, Top, R-Mod, ... ) have not just more than two colours, but a proper class of them. The quotation above is analogous to, and indeed includes, the statement that no important category has more than two objects.
14:18:53 <baldur> Hey, is there a way of getting the minimum element of a list using a key? Example input (path cost): [[10,14], [minimum                 :: (Ord a) => [a] -> a
14:18:53 <baldur> minimum []              =  errorEmptyList "minimum"
14:19:00 <baldur> oh sorry!
14:19:05 <nand`> I was just smirking over the ‘that one meets every day’
14:19:08 * typoclass ran into Top just this morning, and talked to R-Mod a few days ago
14:19:41 <monochrom> I think you have to re-type your example
14:19:45 <baldur> yes
14:19:45 <rwbarton> a friend of mine studies 2-categories with two objects
14:19:54 <baldur> I'll ask the question proper real quick: is there something similar to Python's `key': min([[100,1], [5,5,5], [1,4]], key=sum) → [1,4]
14:19:55 <rwbarton> he calls them "bioidal categories"
14:20:00 * hackagebot swish 0.8.0.2 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.8.0.2 (DouglasBurke)
14:20:02 * hackagebot highlighting-kate 0.5.3 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3 (JohnMacFarlane)
14:20:14 <baldur> I have a list of paths and I want to find the cheapest one
14:20:38 <monochrom> I think I see
14:20:43 <monochrom> @type minimumBy
14:20:44 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
14:20:50 <typoclass> > head . sortBy (comparing sum) [[100,1], [5,5,5], [1,4]]
14:20:51 <monochrom> @type comparing
14:20:52 <lambdabot>   [1,5,100]
14:20:52 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:20:54 <baldur> I'd looked into minimumBy but I couldn't get it to work
14:21:01 <baldur> oh awesome
14:21:05 <typoclass> oh god
14:21:09 <typoclass> > head $ sortBy (comparing sum) [[100,1], [5,5,5], [1,4]]
14:21:10 <lambdabot>   [1,4]
14:21:21 <baldur> cheers typoclass! I think this is what I'm looking for
14:21:29 <monochrom> > minimumBy (comparing sum) [[100,1], [5,5,5], [1,4]]
14:21:31 <lambdabot>   [1,4]
14:21:32 <baldur> it sorts the entire list though?
14:21:39 <typoclass> but ... er yeah, what monochrom said :)
14:21:47 <baldur> ah right, minimumBy it is ;)
14:21:55 <nand`> head . sort can be O(n) for optimistic implementations of sort
14:22:11 <monochrom> by a trick of sortBy laziness, head (sortBy ...) is linear time, too
14:22:26 <baldur> *can* be but I'd rather use minimumBy :)
14:22:41 <baldur> Thanks a bunch though, incredibly helpful channel
14:22:54 <monochrom> yes of course, it depends on the actual sorting algorithm used. but the one that comes with GHC, it satisfies the condition
14:23:14 <gabor> why does hackage reject uploads with the PolyKinds extension? :-(
14:24:04 <gabor> am I the first one to try this?
14:24:52 <benmachine> gabor: what does it say?
14:25:35 <benmachine> gabor: if you're using cabal upload, what does cabal --version say?
14:26:12 <startling> edwardk: do you have Left and Right lenses somewhere?
14:26:19 <johnw> edwardk: welcome back
14:26:22 <edwardk> travereLeft and traverseRight
14:26:25 <edwardk> er traverse
14:26:31 <johnw> edwardk: I had an idea for a Slice type I wanted to ask you about
14:26:36 <edwardk> johnw: ?
14:26:37 <startling> edwardk: thanks
14:27:09 <edwardk> gabor: cabal likes to whine about newer extensions =/
14:27:17 <johnw> edwardk: a Slice would be a lens applied over an mapping.  So, you could "slice" the fibonnaci indices of a list.  The getter would return the sublist, and the setter would take another list and replace that sublist with it.
14:27:46 <edwardk> johnw: see 'unsafePartsOf' ;)
14:27:57 <johnw> this would let me "slice" all *.c files from a file finder, for example
14:28:14 <johnw> and then be able to rename them all with a simple map (f :: IO a)
14:28:17 <dcoutts_> edwardk: it only whines about extensions that nobody has yet registered
14:28:18 <edwardk> build a traversal, unsafePartsOf the traversal, this gives you a traversal of the list.
14:28:20 <johnw> (f :: FilePath -> IO a)
14:28:38 <dcoutts_> edwardk: compiler authors are suppose to register ones they think are ready for public consumption
14:28:38 <edwardk> dcoutts_: what is the registration process?
14:28:55 <gabor> benmachine: cabal-install version 0.14.0
14:28:55 <dcoutts_> edwardk: patch for Language.Haskell.Extensions, that's all.
14:28:59 <johnw> edwardk: do you mean that I could build the Slice abstraction on top of unsafePartsOf?  Or that unsafePartsOf is already sufficient?  I tend to shy away from functions that begin with "unsafe"
14:29:07 <edwardk> dcoutts_: and when they do does that only affect new versions of cabal? or does it fetch a language list from somewhere so its known good retroactively?
14:29:26 <edwardk> johnw: its unsafe because if you take a list, you -have- to give me back a list of the same length
14:29:29 <dcoutts_> edwardk: only affects new versions
14:29:36 <benmachine> gabor: using Cabal 1.14.0?
14:29:36 <edwardk> dcoutts_: =/
14:29:45 <gabor> benmachine: not sure which version runs on hackage...
14:29:52 <gabor> benmachine: yep
14:29:55 <johnw> edwardk: I was thinking it would work like ZipList.  The setter would set as much of the sublist as it could, terminated by whichever is shorter
14:30:06 <edwardk> johnw: thats what partsOf does ;)
14:30:14 <edwardk> johnw: but that means you can't use a type changing lens
14:30:16 <edwardk> =)
14:30:16 <johnw> so, slice fib ~. [1..] $ [0..]
14:30:32 <johnw> sorry, .~
14:30:52 <johnw> that would insert 1's at the fib positions of the all zero list
14:31:14 <benmachine> edwardk: in fairness, Cabal is usually not unpleasant to update
14:31:20 <johnw> and then of course, the goal of Slice is that it would be composable
14:31:34 <gabor> benmachine: looks like hackage.haskell.org needs a newer cabal installation
14:31:47 <johnw> I wonder if I even need a new type, or if this is just a kind of Lens
14:31:50 <startling> edwardk: do you have a lens that runs over Maybe? I've got a Simple Lens (Tree k a) (Maybe (Either a (Tree k a))) and I'd like to compose it with another lens to get a Simple Lens (Tree k a) (Maybe a)
14:31:51 <edwardk> benmachine: well, to be fair, i can't currently update cabal using ghc head ;)
14:32:09 <benmachine> edwardk: go write a friggin' patch then :P
14:32:19 <benmachine> gabor: looks like Cabal actually needs patching :(
14:32:39 <edwardk> benmachine: its http, etc. downstream of cabal thats busted, i have other projects, and i have no idea who even maintains most of that stuff =P
14:33:33 <edwardk> dcoutts_: do you know if there are plans to put in the myriad 7.6.1 extensions in before the platform release?
14:34:02 <gabor> dcoutts: isn't PolyKinds now fully supported with the recentlyreleased 7.6.1?
14:34:03 <edwardk> I'm just saying that right now i find that the current system forces me to lie about other-extensions, which makes me feel really bad
14:34:45 <edwardk> there isn't a 'correct' way for me to say 'i'm using this extension you don't know about, so trust me and let me upload already!' ;)
14:34:58 <dcoutts_> edwardk: two separate issues: updating the list in Cabal so the hackage server will accept them, and getting an updated cabal into the platform
14:35:14 <johnw> edwardk: so is Slice not necessary given the way lens is designed?
14:35:34 <edwardk> johnw: let me back up and try to understand slice
14:35:45 <edwardk> so what does it slice on exactly? the contents? or the positions?
14:35:50 <dcoutts_> edwardk: assuming it's the case the ghc devs forgot to register some new extensions, then yes they will not be listed with the cabal lib that comes with 7.6.1, and if the platform uses that then it inherits the same problem since we would not have a chance to update it before 7.6.2
14:36:00 <edwardk> if you want to slice on positions, its easy, thats what elementsOf is for
14:36:14 <johnw> a slice identifies a series of lenses within structured value
14:36:38 <johnw> it's not just elements of a list
14:36:42 <startling> johnw: oh, interesting
14:36:42 * dcoutts_ did write a test for the ghc testsuite so that new extensions would not be forgotten
14:36:43 <edwardk> can you give me a type signature?
14:36:48 <johnw> but any arbitrary lens
14:37:11 <Sculptor> johnw, here http://oeis.org/A192687
14:38:10 <johnw> edwardk: unfortunately, I can't yet
14:38:16 <edwardk> johnw: well, you may have a problem, just because i have two lenses into something doesn't mean that i can compose them or use them both in a manner that is a valid lens you need lenses into disjoint portions of the structure
14:38:17 <johnw> edwardk: I just don't know lens well enough
14:38:59 <johnw> edwardk: so that means a higher type is needed to serve as a collection of lenses associated by a function?
14:39:07 <edwardk> "johnw: that would insert 1's at the fib positions of the all zero list"  -- you probably can't do that with a lens, i mean it could edit the fib positions of the all zero list, but not insert
14:39:23 <edwardk> i still don't quite understand your usecase
14:39:29 <johnw> yeah, I'm not thinking of insert
14:39:32 <johnw> ok, let me step back
14:39:39 <johnw> imagine you have a Tree that represents the filesystem
14:39:39 <edwardk> the closest analogue i have is partsOf
14:39:49 <johnw> I want a slice of that tree which represents all *.c files in that tree
14:39:57 <johnw> if I "get" the slice, I get a list of the *.c files
14:40:20 <johnw> if I "set" on the slice, I pass a substitution list and all the *.c files get replaced (up to whichever is the shorter list)
14:40:36 <edwardk> the problem is this. that isn't actually a legal lens/traversal.
14:40:43 <johnw> ah
14:40:52 <johnw> so, maybe this is orthogonal to lenses
14:40:53 <edwardk> if i were to get on the new result, and i had changed some files to no longer match *.c i don't see them any more
14:40:59 <edwardk> see the problem?
14:41:06 <edwardk> so the fusion laws fail
14:41:11 <johnw> instead, I should have a traversal that returns a list of lenses?
14:41:14 <edwardk> because i can't fuse two passes into one pass
14:41:18 <edwardk> i have that ;)
14:41:28 <johnw> ok, cool :)
14:41:33 <johnw> thanks for chatting
14:41:49 <edwardk> http://ekmett.github.com/lens/Control-Lens-Plated.html#v:holesOf
14:42:13 <edwardk> holesOf :: LensLike (Bazaar c c) a b c c -> a -> [Context c c b]
14:42:17 <edwardk> you can think of that better as:
14:42:24 <edwardk>  holesOf :: Simple Traversal a b -> a -> [Context b b a]
14:43:03 <edwardk> you can 'extract' from a Context comonad. getting an a, or you can use peek/peeks to generate a new a with the b at that position replaced.
14:43:19 <johnw> so that's a lot like what I'm thinking of, isn't it?
14:43:31 <edwardk> pretty close
14:44:03 <edwardk> just pointing to the things that are already there that are like what you are asking for, so you can see if you can get by with what already exists ;)
14:44:12 <johnw> which I'm fine with
14:44:22 <johnw> it was just an idea that occurred to me
14:44:33 <startling> johnw: you could make it a tuple lens
14:44:36 <edwardk> The other one is: partsOf :: Simple Traversal a b -> a -> Simple Lens a [b]
14:45:08 <johnw> I need an O'Reilly book on Lenses written by Edward Kmett.  Know where I can get that?  :)
14:45:18 <johnw> it can have a cut critter wearing thick glasses
14:45:20 <edwardk> given a traversal that gives you b's you can turn that into a lens that gives you a list of b's, requiring you to give back ideally a list of the same length of new b's
14:45:20 <johnw> cute
14:45:26 <stevej> have any of you used hspec before?
14:45:55 <stevej> https://github.com/hspec/hspec
14:46:14 <johnw> i don't get the whole BDD movement
14:46:21 <johnw> seems like a hell of a lot of typing
14:46:58 <stevej> nested describes are the main benefit, they allow you to combine similar setups for a variety of testing scenarios.
14:47:15 <stevej> when done well, results in less characters per test
14:47:27 <edwardk> johnw: like robdds and bddbddb or something else?
14:47:38 <edwardk> oh
14:47:39 <edwardk> behavior driven development
14:48:46 <edwardk> i'm not a huge bdd fan (for either version!), but i don't mind the notion of lighter weight bdd tools, like, say doctests. doctests have caught dozens of regressions in behavior or documentation bugs for lens.
14:48:50 <stevej> I've been using HUnit and QuickCheck but HUnit's output leaves something to be desired.
14:49:32 <typoclass> doctest++
14:49:36 <stevej> edwardk: thanks, I'll checkout docsets. I haven't written any, just seen them in other people's codebases.
14:50:12 <edwardk> stevej: check out the way i use them in github.com/ekmett/lens  i have a test suite for them that automatically finds all the *.hs files, and runs the doctests in each.
14:50:45 <byorgey> does anyone have experience setting up travis-ci with projects consisting of multiple repos?
14:50:52 <edwardk> https://github.com/ekmett/lens/blob/master/tests/doctests.hs and https://github.com/ekmett/lens/blob/master/src/System/FilePath/Lens.hs#L33
14:51:00 <edwardk> byorgey: yes, its messy
14:51:18 <byorgey> is the right thing to do creating a "meta-repo" with submodules for each of the repos and setting up travis ci for the meta-repo?
14:51:31 <edwardk> byorgey: i used git submodules, retrieved the submodule and a custom before_install to install them in order
14:51:36 <byorgey> (to be concrete, I'm thinking about diagrams here)
14:51:40 <stevej> edwardk: thanks!
14:51:45 <byorgey> edwardk: ok, makes sense
14:51:48 <edwardk> byorgey: it is probably the least painful path
14:52:00 <johnw> I also like doctest a lot
14:52:45 <edwardk> doctest was actually the gateway drug that got me to start adding more test cases to my code in the guise of documentation
14:54:02 <stevej> edwardk: thanks for showing me this, way less boilerplate than HUnit.
14:54:02 <edwardk> sol pushed a patched version of lens with a number of doctests in it, and then i felt guilty when i went to remove them ;)
14:54:10 <hpaste> mmos1127 pasted “random state” at http://hpaste.org/74424
14:54:45 <panman21> \quit
14:54:58 <byorgey> hmm, split already has a bunch of examples, I should just convert them into doctests
14:54:59 <edwardk> stevej: i don't mind hunit, quickcheck, etc. either. i have a bunch of quickchecks but its a lot easier to remember to update these because they are right inline and they serve an auxillary purpose of giving the end user nice examples to look at
14:55:23 <mmos> question at http://hpaste.org/74424
14:55:31 <MostAwesomeDude> I think that I'm enjoying the dependent-type-ade a little too much.
14:56:03 <stevej> this reminds me also of darius bacon's halp system: https://github.com/darius/halp/blob/master/examples/sample.lhs
14:56:16 <byorgey> mmos: there is already a MonadState type class
14:56:22 <startling> MostAwesomeDude: which language are you using?
14:56:44 <MostAwesomeDude> startling: At the moment I'm enjoying reading about Idris.
14:57:06 <Ralith> \o/
14:57:11 <mmos> byorgey: but I need the state to have specific data in it
14:57:18 <byorgey> mmos: rdRandom :: (Random a, MonadState RandData m) => m a
14:57:21 <Ralith> dependent types are best types
14:57:27 <byorgey> mmos: ought to work
14:57:48 <startling> MostAwesomeDude: interesting, I haven't seen Idris
14:58:08 <byorgey> mmos: the MonadState type class actually has two parameters, the first for the type of the state, the second for the monad
14:58:17 <mmos> byorgey: I was hoping that the State was not alway RandData but could be various things, but would always be of a class with "getStdGen" and "putStdGenj"
14:58:25 <Ralith> idris is very exciting
14:58:29 <mmos> byorgey: I think I'm starting to get it:
14:59:23 <mmos> rdRandom :: (Random a, MyRandomClass b, MonadState b m) => m a
14:59:34 <mmos> byorgey: would that work?
14:59:47 <edwardk> mmos: yes thats what i was going to recommend =)
14:59:56 <Excedrin> Ralith: why? (how's it better than ATS or something)
14:59:59 <byorgey> mmos: I think so
15:00:14 <byorgey> I forget whether it's a problem that the b only occurs on the LHS of the => there
15:00:19 <mmos> Okay you gave me the little boot I needed, thanks guys, I'll try it
15:00:42 <Ralith> Excedrin: I'm not deeply familiar with ATS, but I can (and do) get very strongly behind the idea of dependently-typed systems programming.
15:01:02 <vroooom> can one prove commutavitity of addition in haskell?
15:01:36 <byorgey> vroooom: no
15:01:38 <Ralith> vroooom: that question seems underconstrained.
15:01:50 <vroooom> curry - howard
15:01:51 <tromp_> addition on what type?
15:01:58 <vroooom> ints
15:02:10 <Ralith> so you're not even talking about the typeclass?
15:02:17 <vroooom> whats the diff between ints and integers in haskell anyway?
15:02:31 <tromp_> Int (+) shld be provably commutative
15:03:07 <benmachine> Int (+) isn't even defined in haskell
15:03:14 <benmachine> err
15:03:20 <benmachine> it's not defined by haskell code, I mean
15:03:23 <benmachine> it's primitive
15:04:36 <vroooom> coq doesnt do any quickcheck testing thing right?
15:04:54 <vroooom> it is a valid proof bar some 1 in 100 billion hardware error?
15:05:57 <edwardk> vroooom: correct
15:06:08 <edwardk> and assuming you trust the small trusted computing base of it
15:09:18 <vroooom> > let (--) x y = x+y in 10 -- 5
15:09:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:09:31 <vroooom> > let (--) x y = x+y in (--) 10  5
15:09:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:09:39 <vroooom> > let (--) x y = x + y in (--) 10  5
15:09:40 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:09:48 <mm_freak> @src Int (+)
15:09:48 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:09:52 <mm_freak> @src (+) Int
15:09:53 <lambdabot> Source not found. Are you on drugs?
15:09:54 <vroooom> > let add x y = x + y in add 10  5
15:09:55 <lambdabot>   15
15:10:12 <vroooom> > let (#) x y = x + y in (#) 10  5
15:10:13 <lambdabot>   <no location info>: parse error on input `)'
15:10:33 <mm_freak> ok, lambdabot doesn't want to help me, but i'm still sure that (+) is actually defined by haskell code =)
15:10:59 <edwardk> mm_freak: (+) is defined by haskell code, but it calls out to something from GHC.Prim
15:11:11 <mm_freak> of course
15:11:42 <edwardk> http://www.haskell.org/ghc/docs/7.2.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:-43--35-
15:17:55 <vroooom> > flip (:) [] 1
15:17:57 <lambdabot>   [1]
15:18:22 <vroooom> > 1 : (5 : [])
15:18:23 <lambdabot>   [1,5]
15:18:39 <vroooom> > (,) 5 6
15:18:40 <lambdabot>   (5,6)
15:19:06 <vroooom> > zipWith (,) [1,2] [3,4]
15:19:07 <lambdabot>   [(1,3),(2,4)]
15:19:15 <vroooom> > zip [1,2] [3,4]
15:19:16 <lambdabot>   [(1,3),(2,4)]
15:19:21 <vroooom> @src zip
15:19:21 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
15:19:21 <lambdabot> zip _      _      = []
15:19:40 <vroooom> why not zip = zipWith (,) ?
15:19:48 <vroooom> @src zipWith
15:19:48 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:19:48 <lambdabot> zipWith _ _      _      = []
15:19:58 <Ferdirand> because (,) was not yet an operator when zip was defined ?
15:20:28 <vroooom> > zipWith (+) [1..10] [1..10]
15:20:30 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
15:21:04 <gseitz> i decided to spend a bit more time actually writing haskell code (instead of reading only about it) by implementing a messaging server (AMQP to be specific)
15:21:18 <vroooom> paste your codez plz
15:21:20 <gseitz> i've written a barebones implementation in scala using actors, but actors are getting kinda old now
15:22:23 <gseitz> and since message producers and consumers need to access various parts of the server (exchanges, queues, ...), I was wondering what concurrency primitives would be a good fit to use
15:23:06 <vroooom> > ((\(x,y)->x+y) . (,)) [1,2,3] [4,5,6]
15:23:07 <lambdabot>   Couldn't match expected type `(t -> t1, t -> t1)'
15:23:07 <lambdabot>         against inferred ...
15:23:21 <gseitz> (of course, the goal is not production-quality, but just something more interesting than fibonacci)
15:23:38 <nikita-0> > let lr = fix . (++) in take 20 (lr "abcde")
15:23:39 <lambdabot>   "abcdeabcdeabcdeabcde"
15:23:48 <vroooom> > ((\(x,y)->x+y) . (\x y -> (x,y))) [1,2,3] [4,5,6]
15:23:49 <lambdabot>   The lambda expression `\ x y -> ...' has two arguments,
15:23:49 <lambdabot>  but its type `t ->...
15:24:02 <vroooom> > ((\(x,y)->x+y) . (\x y -> (x,y))) $ [1,2,3] [4,5,6]
15:24:03 <lambdabot>   The lambda expression `\ x y -> ...' has two arguments,
15:24:04 <lambdabot>  but its type `a ->...
15:24:27 <vroooom> > map (\x y -> (x,y)) [1,2,3] [4,5,6]
15:24:28 <lambdabot>   Couldn't match expected type `[t1] -> t'
15:24:28 <lambdabot>         against inferred type `[t2...
15:24:38 <vroooom> > map ((\(x,y)->x+y) . (\x y -> (x,y))) $ [1,2,3] [4,5,6]
15:24:39 <lambdabot>   The lambda expression `\ x y -> ...' has two arguments,
15:24:39 <lambdabot>  but its type `a ->...
15:24:42 <monochrom> look under Control.Concurrent and Control.Concurrent.STM for various primitives and data structures you can use
15:25:53 <gseitz> TVars seem great for stuffing messages into a queue
15:26:26 <monochrom> actually Chan and TChan are ready-made queues
15:27:04 <parcs`> and TQueue
15:27:32 <gseitz> great, hoogling them now
15:27:55 <gseitz> conveniently right next to TVar ;)
15:28:19 <scooty-puff> i'm having trouble reading type signatures:
15:28:22 <scooty-puff> :t sing
15:28:23 <lambdabot> Not in scope: `sing'
15:28:28 <scooty-puff> bah
15:28:32 <scooty-puff> > import GHC.TypeLits
15:28:33 <lambdabot>   <no location info>: parse error on input `import'
15:28:40 <scooty-puff> sing :: SingI * a => Sing * a
15:28:42 <scooty-puff> anyways
15:29:33 <scooty-puff> but in the haddock, its Sing a
15:29:44 <scooty-puff> should i read it as (Sing a) :: *?
15:29:54 <gseitz> monochrom: parcs`: these are very useful. thanks for the pointers
15:30:02 * hackagebot notcpp 0.2.0.1 - Avoiding the C preprocessor via cunning use of Template Haskell  http://hackage.haskell.org/package/notcpp-0.2.0.1 (BenMillwood)
15:31:23 <rwbarton> scooty-puff: I think that's GHC's notation for specializing kind-polymorphic types
15:31:47 <rwbarton> it would be like if we wrote fmap Maybe (+1) (Just 3)
15:31:54 <rwbarton> if that makes sense
15:32:12 <rwbarton> well, fmap has several type variables but you get the idea hopefully
15:32:22 <scooty-puff> o, so some of system f leaking through?
15:32:30 <scooty-puff> (maybe?)
15:33:01 <scooty-puff> (does system f have anything about higher kinds that aren't (->)?)
15:33:09 <rwbarton> I don't know
15:33:16 <scooty-puff> ok
15:33:43 <scooty-puff> well, i guess you only see it when in general, and i can't imagine writing some thats kind polymorphic to the type literal (yet anyways)
15:33:57 <scooty-puff> *some -> something
15:37:23 <int80_h> could I get an example of a function parameterized by a monad transformer?
15:38:01 <scooty-puff> f :: MonadState Int m => m Int; f = get
15:38:13 <scooty-puff> not exactly a good example..
15:39:13 <int80_h> hmm, yeah. Could I get a good example?
15:39:47 <c_wraith> you can't do much with an arbitrary transformer
15:40:26 <scooty-puff> i think i probably most commonly use it with MonadReader, MonadError
15:40:49 <scooty-puff> data Config = ...; doSomethingBasedOnConfig :: MonadReader Config m => m (); ...
15:40:57 <c_wraith> :t \f x y -> do { x' <- lift x; y' <- lift y ; f x' y' }
15:40:58 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) b a1. (MonadTrans t, Monad m, Monad (t m)) => (a -> a1 -> t m b) -> m a -> m a1 -> t m b
15:41:09 <int80_h> c_wraith: I was looking up Control.Monad.Trans.Identity, and the use for it was described as "This is useful for functions parameterized by a monad transformer.", and I needed clarification on what that meant.
15:41:18 <c_wraith> That's parameterized over a monad transformer - but basically pointlessly so
15:41:32 <c_wraith> Oh.  Parameterized over a *specific* transformer
15:41:42 <c_wraith> :t runStateT
15:41:43 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:41:51 <c_wraith> that's parameterized over StateT
15:42:04 <c_wraith> it doesn't depend on m
15:42:04 <int80_h> thanks! I can understand that :)
15:42:19 <scooty-puff> i have seen Identity used with Traversable to allow you to write something for many things, and have it still work out (unification-fd i think)
15:43:08 <int80_h> uh except for the forall part. That looks like voodoo.
15:43:18 <Lutin`> Is there a library that offers fairly intuitive graphics manipulation/drawing?
15:43:31 <Lutin`> Or do I need to drop to OpenGL bindings
15:44:27 <c_wraith> int80_h: you can ignore everything before the . in the type signature.  It's fully redundant, in that case
15:45:29 <int80_h> c_wraith: oh good, we're back to me understanding your example then. Thanks :)
15:47:09 <MostAwesomeDude> Lutin`: Some people like Gloss.
15:47:22 <MostAwesomeDude> Lutin`: I have resorted to just building things with straight GL, but I'm weird.
15:47:35 <Lutin`> I'm weird too though :P
15:49:07 <crdueck> Lutin`: is it simple 2d? i just used the haskell-sdl library and it was pretty intuitive
15:49:31 <Lutin`> Well there are a variety of ideas I'd like to poke around with
15:49:44 <Lutin`> Some I want to be able to do pixel by pixel
15:50:08 <crdueck> you'll be able to do that with SDL, by drawing a 1x1 rectangle
15:50:08 <Lutin`> Other's just 2D others 3D
15:50:17 <Lutin`> That seems inefficient
15:50:39 <crdueck> well, i know its possible to draw single pixels in the C SDL library
15:50:57 <Lutin`> I'll check all these libs out though
15:50:59 <crdueck> but i wasnt able to find a haskell equivalent, i never needed to draw pixel by pixel anyways
15:51:22 <Lutin`> Well I want to do some cellular automata
15:51:34 <Lutin`> Or output neural network weights
15:51:37 <crdueck> thats funny, i was using it to implement conway's GOL
15:52:02 <Lutin`> I've also got this idea
15:52:25 <Lutin`> Of using the composability of functions to create random combinations
15:52:50 <Lutin`> And then do a genetic algorithm to evolve certain combinations
15:53:14 <Lutin`> And then messing with the fitness function
15:53:18 <crdueck> what would be the desirable characteristic?
15:53:58 <Lutin`> Either through hand selection after displaying their output as an image or as a distance to an input image
15:54:26 <Lutin`> Or other arbitrary fitness functions which you could just watch evolve
15:56:25 <nejucomo> The python bindings for sdl can expose frame sub-buffers as the "standard" numberic matrix type.  That's handy.  Is there a good numeric matrix library for haskell?
15:58:11 <Lutin`> So what was that Vim addon that let you just type in the github link
15:58:27 <Lutin`> WHoops wrong channel
15:59:04 <crdueck> nejucomo: thats pretty cool, i imagine one would be able to implement a one line GOL using SDL using a similar algorithm as this: https://www.youtube.com/watch?v=a9xAKttWgP4
16:02:21 <Lutin`> It was Vundle, by the way
16:10:03 * hackagebot wai-session 0.1 - Flexible session middleware for WAI  http://hackage.haskell.org/package/wai-session-0.1 (StephenWeber)
16:15:03 * hackagebot wai-session-tokyocabinet 0.1 - Session store based on Tokyo Cabinet  http://hackage.haskell.org/package/wai-session-tokyocabinet-0.1 (StephenWeber)
16:20:05 * hackagebot wai-session-clientsession 0.1 - Session store based on clientsession  http://hackage.haskell.org/package/wai-session-clientsession-0.1 (StephenWeber)
16:38:37 <jmcarthur> i just read the conversation about drawing pixels in sdl. it made me realize (again) how much i miss "the good old days" when the way to do graphics was to draw each pixel one at a time. i'm nearly inspired to make a library that makes that convenient again.
16:39:21 <Ralith> jmcarthur: it's not inconvenient to do, it's just a bit silly.
16:40:01 <Ralith> you can draw pixels if you want to, but you can also do so much more!
16:44:17 <monochrom> you probably miss the good old days when graphics was so slow, too
16:44:41 <monochrom> precisely equivalent to "draw one pixel at a time, CPU-bound"
16:45:04 * hackagebot notcpp 0.2.0.2 - Avoiding the C preprocessor via cunning use of Template Haskell  http://hackage.haskell.org/package/notcpp-0.2.0.2 (BenMillwood)
16:54:24 <jmcarthur> monochrom: that's right. i miss the days when tight control over that stuff was the only way to get it done
16:54:37 <jmcarthur> it was a simpler time, with different problems
16:55:56 <nand`> good old days where you could count on the clock rate steadily increasing to meet your demands?
16:57:26 <monochrom> "Two new versions of Haddock have been uploaded to Hackage: version 2.10.0 which comes with GHC 7.4.2 and 2.11.0 which comes with the new GHC 7.6.1!"
16:57:37 <monochrom> that's normal. but next, the plot thickens:
16:57:48 <monochrom> "Changes in version 2.12.0"
16:58:02 <monochrom> version numbers increase steadily!
16:58:11 <rwbarton> so, three new versions?
16:58:17 <rwbarton> or is 2.12.0 not new
16:58:32 <monochrom> there is a typo, but I don't know which one is the typo
16:58:36 <rwbarton> or, has it not been uploaded to Hackage
17:22:37 <startling> @hoogle (a, Either b c) -> Either (a, b) (a, c)
17:22:37 <lambdabot> No results found
17:23:06 <startling> @hoogle (a, x b c) -> x (a, b) (a, c)
17:23:07 <lambdabot> No results found
17:23:11 <startling> ^ any ideas?
17:23:29 <Ralith> reminds me of an arrow combinator
17:23:38 <startling> @pl \(a, Left b) -> Left (a, b)
17:23:38 <lambdabot> (line 1, column 11):
17:23:38 <lambdabot> unexpected "b"
17:23:38 <lambdabot> expecting operator, "," or ")"
17:23:44 <Ralith> but the semantics are different
17:23:47 <startling> yeah
17:23:55 <startling> oh well, I can just pattern-match
17:24:38 <rwbarton> @hoogle bimap
17:24:38 <lambdabot> package bimap
17:25:09 <rwbarton> (not that one)
17:25:15 <rwbarton> you could write it for a Bifunctor x
17:25:23 <startling> rwbarton: could I?
17:25:45 <latro`a> @pl (\a, (Left b)) -> Left (a,b)
17:25:45 <lambdabot> (line 1, column 12):
17:25:45 <lambdabot> unexpected "b"
17:25:46 <lambdabot> expecting operator or ")"
17:25:54 <latro`a> :|
17:26:09 <rwbarton> \(a,x) -> bimap (a,) (a,) x
17:26:20 <rwbarton> which you could @pl to some awful mess
17:27:01 <fmap> @type \x y -> join (+++) (\a -> (x,a)) y
17:27:02 <lambdabot> forall b t. t -> Either b b -> Either (t, b) (t, b)
17:27:41 <rwbarton> @type (+++)
17:27:42 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
17:27:57 <rwbarton> (+++) for (->) is bimap for Either yeah
17:28:36 <fmap> @type \x y -> (+++) (\a -> (x,a)) (\a -> (x,a)) y
17:28:36 <lambdabot> forall b t b'. t -> Either b b' -> Either (t, b) (t, b')
17:28:52 <fmap> join makes it too monomorphic :(
17:32:27 <nand`> bimap :: (a -> b) -> (c -> d) -> f a c -> f b d -- ?
17:32:48 <rwbarton> yes
17:32:51 <edwardk> nand`: yes, in bifunctors
17:41:24 <nand`> so when will we get House running on the Reduceron?
17:42:53 <MostAwesomeDude> When will we get House, period?
17:46:38 <startling> I've got a Simple Lens (Tree k a) [(k, Either a (Tree k a))] and a Simple Lens [(k, Either a b)] ([(k, a)], [(k, b)]). why can't I compose them to get a Simple Lens (Tree k a) ([(k, a)], [(k, Tree k a)])  ?
17:47:04 <startling> should I be able to?
17:47:09 <edwardk> unpacking that statement =)
17:47:29 <MostAwesomeDude> Yes, I think so?
17:47:32 <nand`> so what happens when you compose them?
17:48:40 <startling> oh ugh, I forgot to put an Ord constraint somewhere. sorry!
17:48:55 <edwardk> from the types you mentioned the composition should be Simple Lens (Tree k a) ([(k,a)],[(k,Tree k a)]), so yes.
17:49:09 <startling> that, combined with the dmr, gave me a flurry of confusing errors
17:49:36 <Lutin`> @pl \x y -> (+++) (\a -> (x,a)) (\a -> (x,a)) y
17:49:36 <lambdabot> liftM2 (+++) (,) (,)
17:49:43 <edwardk> btw- i don't believe that your lens is really a lens ;)
17:49:46 <Lutin`> Well look at that
17:49:48 <edwardk> at least the second one =)
17:49:51 <startling> edwardk: why not?
17:50:05 * hackagebot usb 1.1.0.3 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.1.0.3 (BasVanDijk)
17:50:22 <edwardk> the reassembly has to at least reshuffle things to restore an invariant, so at most its a lens 'up to preserving the invariant'
17:50:24 <Lutin`> startling: So yeah liftM2 (+++) (,) (,) :P
17:50:54 <edwardk> if i put two copies of the same key in the new lists then i can get a different number of elements when i view the list a second time
17:51:22 <edwardk> a more principled version would be to make it an indexed lens or indexed traversal
17:51:27 <startling> edwardk: that's true
17:51:38 <startling> hmmm, guess I should learn about those
17:52:08 <startling> edwardk: that requires At, though, doesn't it?
17:52:19 <edwardk> no, At is just a particular indexed traversal
17:52:23 <startling> oh
17:52:56 <startling> edwardk: how do I make one?
17:52:57 <edwardk> hrmm, not sure how to really encode what you have there
17:53:13 <edwardk> i almost want a 'higher order' indexed traversal type ;)
17:53:19 <copumpkin> zomg
17:53:36 <edwardk> heya copumpkin
17:53:43 <copumpkin> greetings!
17:54:09 <edwardk> startling: i suppose the easiest fix is to just disallow the end user from editing the key
17:55:02 <edwardk> startling: how much do you know about indexed traversals?
17:55:48 <startling> edwardk: almost nothing
17:56:00 <nand`> indexed traversals are like traversals, but indexed
17:56:05 <nand`> I'm not helping am I?
17:56:21 <edwardk> startling: ok, the idea is pretty easy. you want something like Applicative f => (key -> c -> f d) -> a -> f b   instead of Applicative f => (c -> f d) -> a -> f b
17:56:43 <edwardk> the addition of the key is the difference
17:56:48 <nand`> a simple example would be an indexed traversal of a list
17:56:58 <nand`> which works like the regular traversal, but indexed by the position in the list
17:57:05 <nand`> clearly, you can't change the position while traversing
17:57:07 <edwardk> you build an indexed traversal by passing that function to 'index'   and then it can be used as a regular traversal or with any of the indexed combinators
17:57:30 <edwardk> or the indexed traversal of a map, where you visit all the elements of the map, but can view the key while you do so
17:57:49 <startling> edwardk: oh, interesting
17:58:12 <edwardk> Control.Lens.WithIndex provides classes for things that have an 'obvious' traversal with key
17:58:29 <edwardk> [], Map k, IntMap, HashMap, etc.
17:59:23 <edwardk> whenever i write a traversal i ask myself if there is a natural notion of a key i can extend it with ;)
17:59:50 <edwardk> a lot of the pain of your tree type, btw- comes from the fact that you do not allow entries that are prefixes of other keys
18:00:05 * hackagebot highlighting-kate 0.5.3.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3.1 (JohnMacFarlane)
18:00:12 <startling> edwardk: hmmm, how do you mean?
18:00:20 <YayMe> Question on balanced binary search tree implementation
18:00:22 <edwardk> if your tree type was more like
18:00:47 <edwardk> data Tree k a = Tree (Maybe a) (Map k (Tree k a))
18:00:51 <YayMe> Is it better to maintain a child count on nodes, or a height count
18:01:19 <startling> edwardk: but then it won't correspond to a filesystem hierarchy
18:01:21 <edwardk> then you could be an instance of instance Ord k => At [k] (Tree k)
18:01:25 <startling> which is the whole point of the exercise
18:01:39 <edwardk> startling: i had no idea the actual problem domain, just pointing out what is awkward ;)
18:01:47 <startling> edwardk: alright
18:03:00 <Jello_Raptor> "invertMap :: (Eq a,b) => (Map a (Set b)) -> (Map b (Set a))" Is there some other way to say both a and b should have typeclass Eq? I've been having a hell of a type searcing for it
18:03:16 <YayMe> Does anyone here know f#?
18:03:31 <copumpkin> Jello_Raptor: you're gonna need Ord a and b, not Eq, aren't you?
18:03:42 <edwardk> YayMe: unfortunately
18:03:53 <copumpkin> Jello_Raptor: you'd just write (Ord a, Ord b) => Map a (Set b) -> Map b (Set a)
18:03:54 <Jello_Raptor> copumpkin: I do now (thanks)
18:04:05 <JoeyA> Jello_Raptor: btw, "transpose" might be a better name.
18:04:07 <edwardk> YayMe: the child count is a more powerful balancing tool, because you can do things like haskell's Data.Map does
18:04:15 <JoeyA> :t transpose
18:04:16 <lambdabot> forall a. [[a]] -> [[a]]
18:04:50 <hpc> the other day i was trying to come up with a generalization of transpose
18:04:55 <hpc> ended up with sequence, which is clearly wrong
18:04:58 <YayMe> edwardk: Ok. I have child count right now, but looking at avl tree and red black tree it seems both use height more but I'll just have to divine height from child count somehow
18:05:01 <edwardk> hpc: there is one in lens
18:05:02 <JoeyA> I wish there was a Map variant of transpose, namely: transpose :: (Ord k1, Ord k2) => Map k1 (Map k2 v) -> Map k2 (Map k1 v)
18:05:08 <hpc> ooh
18:05:36 <JoeyA> transpose makes more sense for maps than it does for lists, in my opinion.
18:05:38 <edwardk> hpc: http://hackage.haskell.org/packages/archive/lens/2.6.1/doc/html/Control-Lens-Traversal.html#v:transposeOf
18:05:45 <YayMe> what is lens? I heard people talking about that yesterday
18:06:00 <edwardk> YayMe: http://hackage.haskell.org/package/lens
18:06:37 <gwern> @wn nadir
18:06:37 <lambdabot> *** "nadir" wn "WordNet (r) 3.0 (2006)"
18:06:37 <lambdabot> nadir
18:06:38 <lambdabot>     n 1: an extreme state of adversity; the lowest point of anything
18:06:38 <lambdabot>          [syn: {nadir}, {low-water mark}]
18:06:39 <lambdabot>     2: the point below the observer that is directly opposite the
18:06:41 <edwardk> YayMe: if you are implementing a purely functional map then it turns out that weighted trees work better than avl or red-black in practice, because they do less copying.
18:06:43 <lambdabot>        zenith on the imaginary sphere against which celestial bodies
18:06:47 <lambdabot>        appear to be projected [ant: {zenith}]
18:07:26 <edwardk> YayMe: if you want red/black or avl or braun trees or whatever course, use whatever metric or color coding is appropriate ;)
18:07:33 <YayMe> edwardk: It's a purely functional balanced binary search tree, not map
18:07:56 <YayMe> edwardk: huh? You lost me
18:08:14 <edwardk> YayMe: the data.map approach gives you a purely functional balanced binary search tree with better performance than avl or red/black trees, which is why we use it
18:08:23 <YayMe> I'm aware
18:08:29 <YayMe> but I've never written a tree
18:08:41 <YayMe> I'm trying to study up on algorithm design and analysis
18:08:56 <YayMe> One of those things we OO developers manage to avoid touching for years
18:09:55 <edwardk> YayMe: http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html talks about the size-balanced tree model. it is of course worth while to implement that, and the classic avl or red-black trees
18:10:09 <edwardk> http://groups.csail.mit.edu/mac/users/adams/BB/ is the paper on size-balancing
18:10:29 * nand` .oO( https://github.com/ghc/testsuite/blob/master/tests/polykinds/RedBlack.hs )
18:10:39 <YayMe> Tired of working at shitty brain dead OO shops with colleagues who are retarded though, so I'm trying to take a step up, which I figure starts with writing algorithms myself so I can understand more and pass those "how do you find a lost car on an infinite street" type of interview questions
18:10:51 <edwardk> YayMe: *nods*
18:11:01 <edwardk> YayMe: have you seen chris okasaki's book?
18:11:19 <YayMe> Nope
18:11:31 <edwardk> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504 <-- this is a gold mine, for those looking to understand how to implement data structures in a functional setting
18:12:23 <YayMe> I'll start with understanding data structures at all, I have a strong feeling that my functional practice of late will make the route to implementing them a lot easier anyway than someone approaching this stuff with only imperative skills
18:13:04 <edwardk> k, well, it starts with things like stacks and queues
18:13:14 <YayMe> I managed to write this last night, now just to balance it: http://hpaste.org/74375
18:13:28 <nand`> Haskell stacks are fun and easy
18:14:16 <startling> pop (a:b) = (a, b); push = (:); peek = head
18:14:20 <YayMe> I may not know much about data structures formally, but I at least have stacks and queues down heh
18:16:50 <JoeyA> Do you know how to reverse a stack without using *any* data structures?  :-)
18:16:56 <hpaste> edwardk annotated “Attempt at tree insertion” with “A more haskelly way to do this” at http://hpaste.org/74375#a74428
18:17:26 <YayMe> Those I've used plenty of in OO because they have obvious CRUD operations which is what OO is all about, but in all the years I been writing OO code I've never run into an implementation of a complex data algorithm like a tree, graph problem, or path finding working in corporatocracy
18:17:35 <JoeyA> jk, I'm referring to what was once the lowest-voted question on Stackoverflow.
18:17:38 <edwardk> YayMe: take a look at my amended version of your paste
18:18:05 <ion> OO is all about CRUD operations?
18:18:48 <YayMe> by and large
18:19:27 <edwardk> YayMe: well, queues in a functional world are a bit tricky. how do you access the far end of where you are pushing data on in a way that you can take from the queue in O(1) while pushing onto it in O(1)?
18:19:36 <YayMe> you can obviously do anything in OO, but having learned functional it's obvious to me now any data modifications should be done functionally, where modeling and pass through crud should likely stay in OO
18:19:41 <edwardk> YayMe: its possible, its just not immediately obvious
18:20:26 <ion> I thought OO is all about objects which respond to messages.
18:20:36 <YayMe> edwardk: Challenge accepted. also it looks like your way is basically the same as mine except you used pattern matching to deconstruct the type and the smaller names (which was why I didn't use pattern matching, because I didn't think to use smaller names)
18:20:40 <YayMe> also why the strict count though?
18:21:15 <ion> Wouldn’t it be better for HTTP and SQL be object-oriented since OO is all about CRUD?
18:21:20 <YayMe> ion: in OO you take a problem, and you deconstruct it into models, and then interact with the problem through messages
18:21:28 <geekosaur> ion: arguably CRUD is just a summary of the messages
18:22:00 <edwardk> YayMe: the strict count is because otherwise you'll find that you make edits to the count that are almost always of the form (n + 1), (n - 1), (l + r + 1), etc.
18:22:13 <edwardk> YayMe: and so you get a huge chain of thunks in there that leak memory until forced
18:22:14 <imeredith> ion: OO isnt all about crud, people use it for crud, but really no one knows what OO actaully is
18:22:15 <YayMe> ion: if your messages are requesting actions more complex than CRUD, the OO solutions rapidly become a lot messier than the functional ones, but for simple CRUD it is very effective
18:22:31 <YayMe> edwardk: Good call
18:22:36 <edwardk> YayMe: the strict count is an attempt to mitigate the space leaks you'll get otherwise
18:22:51 <edwardk> you'll still get some from the fact that you aren't spine strict, but this is better than the alternative by far ;)
18:23:03 <YayMe> right
18:23:45 <YayMe> I have to think about those chains when writing haskell, I recognize they're building just like I'm familiar with the 'thunk' that happens in my native C# when I chain a bunch of linq expressions and then ask for the evaluation at the end
18:24:26 <YayMe> Which is why in C# I will force intermediate evaluations at times
18:26:03 <edwardk> a good rule of thumb is to be strict in those little fields that just contain some memoized property, then when you compile with -funbox-strict-fields or if you put an {-# UNPACK #-} pragma before it, it makes a dramatic difference in your performance
18:26:07 <YayMe> imeredith: I would argue the many people who've been writing C# or java for 10 years and have studied and implemented countless design patterns at the large and small scale know what it is through osmosis as much as anything. There are obviously no good formal definitions for what it *should* be
18:26:20 <edwardk> but that is kind of overkill for the level this exercise is at so far ;)
18:26:36 <YayMe> Right
18:26:48 <YayMe> especially since I don't know those tricks of haskell yet heh
18:27:03 <YayMe> So you said implementing a stack in haskell is a little tricky eh edwardk?
18:27:08 <imeredith> YayMe: it seems to be that almost everyone has a different definition of OO
18:27:11 <edwardk> stack is easy. queue is harder
18:27:18 <edwardk> at least an optimally efficient one
18:28:00 <YayMe> imeredith: I would say that's true again amongst people looking at formal definitions who haven't been writing C# or java for years
18:28:37 <YayMe> what it formally *should* be is unknown, yes, what it actually becomes, there's enough written code and life experience amongst many people to know what OO actually is in practice
18:28:46 <nand`> but who's to say C# and Java define OOP?
18:28:54 <Ralith> Alan Kay's still alive, isn't he?
18:29:01 <Ralith> he came up with the term, ask him.
18:29:04 <nand`> what about the radically different ‘object oriented’ approaches some other languages use?
18:29:04 <YayMe> nand`: A majority of people, likely.
18:29:13 <Ralith> (spoiler: 'Not C++')
18:29:36 <nand`> YayMe: I guess you could get away with calling it C#-style object orientation
18:29:45 <YayMe> that's fair
18:29:48 <nand`> and that should resolve most ambiguity
18:30:48 <YayMe> I would still wager that in other object oriented languages that implement: encapsulation, inheritance, polymorphism, and abstraction, they probably turn out a great deal of the same designs as C#/java
18:30:52 <YayMe> but that's an unfounded bet
18:31:07 <YayMe> So I'm completely speculating
18:31:47 <YayMe> I still think those 4 tools I listed make for great modelling of data, and moving it around, but processing of it, not so much
18:31:50 <nand`> polymorphism and abstraction are fairly ubiquitous; I don't identify them with object orientation
18:31:55 <imeredith> at best OO seems to be a loose collection of concepts, non of which are individaully vital to the definition
18:32:00 <imeredith> none*
18:32:18 <Ralith> I propose we define it as 'smalltalkish' and move on.
18:32:35 <Ralith> that way we can continue putting down the java family.
18:32:42 <imeredith> haha
18:32:44 <YayMe> haha ok Ralith, I don't know smalltalk but I like the idea that I know something based on it
18:32:56 <hpaste> Jello_Raptor pasted “Traspose Map” at http://hpaste.org/74429
18:33:06 <Jello_Raptor> question is in the post ^
18:33:17 <YayMe> Ralith: is java particularly different than smalltalk? because it's not particularly different than C#
18:34:19 <Ralith> YayMe: see, that's the 'joke'. Smalltalk was built (mostly?) by Alan Kay, and pioneered the concept of object orientation. C++, Java, and so on all gave themselves the same label but have very little in common with it.
18:35:27 <Ralith> they've then proceeded to become much more popular, so the whole thing's hopelessly confused now.
18:35:59 * Jello_Raptor facepalms (i flipped k and a in line 9)
18:41:30 <edwardk> Jello_Raptor: you can probably do that easier by just converting it to a [(a,b)], flipping it back to [(b,a)] and then building up with fromListWith
18:41:54 <Jello_Raptor> edwardk: yes ... yes it would
18:42:40 <mdxbhmt> Hey people, anyone has tips about implementing DSL in haskell (or are the wiki resources already a good start?)
18:43:47 <YayMe> Ralith: So basically objective-C followed smalltalk, while stroustrup went a completely different way, and everyone else followed suit?
18:44:24 <Ralith> YayMe: I can't comment on objective C.
18:45:43 <startling> YayMe: that's my understanding
18:46:15 <YayMe> Ok, well back to what I'm hear for: learning algorithms. How am I supposed to identify the height of a tree whose nodes maintain child counts without walking the entire thing?
18:47:13 <YayMe> if a node says child count of 2, that could still mean it's height is also 2 not just one
18:48:01 <edwardk> YayMe: you can't calculate height from weight
18:48:13 <YayMe> balls, that's what I thought
18:48:18 <YayMe> But you can balance based on weight?
18:48:20 <edwardk> you can only bound it.
18:48:23 <edwardk> yes
18:48:30 <rwbarton> you can if you know BMI
18:48:33 <YayMe> isn't balance refer to height though?
18:48:34 <edwardk> thats what the sized based tree paper and link i gave above does
18:48:43 <YayMe> rwbarton: nyuck nyuck :P
18:48:52 <edwardk> YayMe: you can derive the same asymptotics using weight based bounds
18:49:10 <edwardk> if you want the classic CS result, you'll want the height or delta height in nodes
18:49:58 <YayMe> edwardk: Gotcha. Well I have count so I'll follow this yarn for now, but I'll come back to it and figure out how to maintain a height later and then try for the avl/redblack
18:50:07 * hackagebot highlighting-kate 0.5.3.2 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3.2 (JohnMacFarlane)
18:50:17 <YayMe> then who knows, maybe I start to maintain height and weight and make a mixed tree? Or maybe that's retarded
18:50:21 <edwardk> red black can be quite difficult to delete from
18:50:35 <YayMe> functionally or at all?
18:50:55 <edwardk> especially functionally, but in general, too ;)
18:51:17 <YayMe> Ok
18:51:39 <edwardk> i heartily recommend reading okasaki before tackling red-black
18:51:55 <edwardk> note: most of his book is available as his dissertation online… for free
18:52:05 <startling> how evil is MultiParamTypeClasses?
18:52:29 <djahandarie> Not evil
18:52:36 <startling> k
18:52:38 <YayMe> <edwardk> YayMe: well, queues in a functional world are a bit tricky. how do you access the far end of where you are pushing data on in a way that you can take from the queue in O(1) while pushing onto it in O(1)?
18:52:57 <YayMe> That sounds fun.. I bet I could figure that out within an hour.. maybe
18:54:02 <nand`> hmm
18:54:13 <edwardk> YayMe: the main thrust of okasaki's thesis was how to reason about asymptotics for that kind of data structure
18:54:22 <nand`> oh, Data.Seq's time complexities are amortized
18:54:40 <nand`> (I was wondering since it has O(1) cons and O(1) unconsr)
18:54:41 <YayMe> I'll always remember what the first functional programmer I met told me, he was an old lisper and said everything can be done with another layer of indirection. That off hand remark for some reason stuck and is the only reason I've been able to figure out any of this functional stuff
18:55:02 <YayMe> edwardk: ah, reasoning about these things, yes that does sound valuable
18:55:16 <edwardk> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf is the thesis link
18:55:20 <startling> meh, who needs reasoning
18:56:23 <YayMe> startling: people who don't want to say "it's good enough" and churn out the garbage my colleagues do constantly...
18:57:01 <YayMe> why can't I just be happy clocking my time and collecting a paycheck for writing crap like them.. ah well.
18:57:34 <JoeyA> The first time I implemented AVL, I figured out how to update balance factors by brute force (i.e. changing the numbers in a table until it worked).
18:58:52 <YayMe> JoeyA: Was that functional or imperative?
18:59:08 <JoeyA> Imperative (C)
19:00:29 <YayMe> I should think that updating balance factors ought to be simple if that's what you want to do.. same approach I'm using to maintain weight, I would just maintain height except the condition where I +1 is different..
19:02:34 <JoeyA> Here's what I did: http://hpaste.org/74430
19:04:44 <JoeyA> YayMe: Well, what makes balance factors tricky is all the insert and balance cases: http://en.wikipedia.org/wiki/AVL_tree#Insertion
19:05:23 <YayMe> wow, I do not know what that code is doing whatsoever heh
19:05:23 <BMeph> edwardk: " <edwardk> i heartily recommend reading okasaki ..." -- you could have stopped right there. :)
19:05:52 <edwardk> BMeph: very true =)
19:06:28 <JoeyA> Here's an AVL implementation I did later on: http://git.ozlabs.org/?p=ccan;a=blob;f=ccan/avl/avl.c;h=001ea438eb9f4c15967ce775e9d70711dada66be;hb=HEAD#l273
19:07:04 <JoeyA> It's clearer, which for some reason makes it longer.
19:10:59 <YayMe> JoeyA: As is often the case of self-documenting code unfortunately. But perhaps it's just my unfamiliarity with C++ i'm still not clear on where you're incrementing a maintained height on insertion
19:11:08 <YayMe> I'm guessing you aren't?
19:11:20 <JoeyA> I'm not maintaining heights, I'm just maintaining balance factors.
19:11:33 <YayMe> gotcha
19:11:51 <YayMe> but you must calculate the height on insertion to identify the balance factor, no?
19:12:08 <YayMe> that is: see if you're adding a new level or not
19:12:15 <YayMe> no?
19:12:24 <JoeyA> That's the point.  Given what happens to the height, you can derive what needs to happen to the balance factors.
19:13:23 <YayMe> Right, I just can't see in it where you identify if a new level was added
19:14:30 <YayMe> I just suck at reading C++ heh, whatever
19:14:30 <JoeyA>  /* If tree's balance became -1 or 1, it means the tree's height grew due to insertion. */
19:14:57 <JoeyA> insert's return value indicates if the tree grew.
19:15:46 <YayMe> Oh
19:15:53 <JoeyA> And on insertion of a single item, if the tree goes from balanced to unbalanced, we know the tree's height grew.
19:16:01 <YayMe> Right
19:17:17 <JoeyA> I want to implement AVL in Coq some time, so I can be more clear about invariants.
19:17:34 <YayMe> what's Coq?
19:17:47 <JoeyA> It's a proof assistant.
19:17:59 <arbn> http://coq.inria.fr/
19:18:01 <YayMe> Ah, whoa, interesting
19:18:07 <YayMe> Yeah looking at it
19:20:00 <JoeyA> What got me started with Coq was wanting to test a simple set theory thing.
19:20:39 <JoeyA> Namely: if A and B are disjoint, then A+C and B-C are also disjoint, where + means set union and - means set difference.
19:23:17 <edwardk> JoeyA: there is an implementation in agda iirc. i think nils did one and copumpkin was working on another.
19:23:28 <edwardk> (for avl)
19:23:36 <copumpkin> I was adding to nils's one
19:23:37 <edwardk> (or maybe it was red-black)
19:23:37 <YayMe> I understand your theory from all my sql experience except for one word: disjoint
19:23:40 <copumpkin> I haven't finished it yet
19:23:40 <copumpkin> AVL
19:23:50 <YayMe> JoeyA: what's the definition of disjoint in your term?
19:23:55 <copumpkin> haven't worked on it in months either :)
19:24:29 <YayMe> edwardk: looking at okasaki and I understand his pseudo-code syntax except the |, it looks like a guard but I don't think it is, could you explain?
19:24:32 <JoeyA> YayMe: if A and B are disjoint, then they have no elements in common.  In other words, the intersection of A and B is the empty set.
19:24:54 <YayMe> JoeyA: Ah, yeah I see now. Yes that should be simple to prove
19:25:44 <edwardk> YayMe: his code is written in a dialect of ML, rather than haskell. in the published book he also included a copy of the code in haskell
19:25:56 <JoeyA> It's easy to prove the boolean argument (Coq's "tauto" tactic can do it automatically).
19:26:24 <YayMe> JoeyA: So A+C and B-C are disjoint, however A+C and B+C are not, however if A and C are not identical, C-A and B+C is not disjoint
19:26:33 <edwardk> YayMe: the | he's using there is used to separate multiple pattern matches for a function, or multiple cases in a case statement
19:26:54 <monochrom> | is how SML separates cases. SML: "fun f [] = a | (x:xs) = b" Haskell: "f [] = a; f (x:xs) = b"
19:27:14 <edwardk> fun normalize [ ] = [ ] | normalize (t ::ts) = insTree (t, ts)  -- is saying that he's defining normalize using two cases
19:27:27 <edwardk> haskell is less verbose about it
19:27:36 <monochrom> I guess I miss an "f" there
19:27:39 <JoeyA> YayMe: A+C and B+C could be disjoint, if C is an empty set.
19:27:53 <JoeyA> (We're assuming A and B are disjoint)
19:28:31 <YayMe> edwardk: Oo, so it fun bla = (a :: b :: rest) = ... | bla a = ... would be like in haskell saying bla = (a :: b :: rest) = .. then on a separate line bla a = ...
19:28:45 <YayMe> JoeyA: Good point
19:28:52 <JoeyA> (a : b : rest) in Haskell
19:29:00 <YayMe> right
19:29:06 <JoeyA> Haskell and ML flip-flop : and ::
19:29:18 <edwardk> YayMe: well, fun bla (a :: b :: rest) = … | bla a = … would become bla (a : b : rest) = ..; bla a =
19:29:29 <JoeyA> > 3 :: Int : [5]
19:29:30 <lambdabot>   <no location info>: parse error on input `:'
19:29:51 <edwardk> JoeyA: heh, with data kinds, that can start type checking ;)
19:29:52 <monochrom> need more parentheses
19:30:23 <YayMe> edwardk: Right I understand, thanks, and is he writing in an actual language or is it pseudo as I presume?
19:30:32 <JoeyA> > (3 :: Int : [5] -- that just made it worse!
19:30:33 <edwardk> its a real language
19:30:33 <lambdabot>   <no location info>: parse error on input `:'
19:30:54 <edwardk> well, the lazy extensions he uses later aren't quite real
19:32:18 <YayMe> edwardk: What language out of curiosity?
19:32:25 <edwardk> YayMe: ML
19:32:26 <YayMe> some ml variant?
19:32:32 <edwardk> yes
19:32:35 <YayMe> Ah gotcha
19:32:57 <edwardk> its standard ml with some lazy extension that makes it nicer to write some of the lazy algorithms
19:33:32 <YayMe> glad I've been writing f# at work in my copious spare time, the syntax is surprisingly different from haskell, feels like the differences between C and python in imperative
19:33:46 <krakrjak> > 3 : [5]
19:33:47 <lambdabot>   [3,5]
19:34:16 <YayMe> Is interesting to see in functional paradigm they have those same large syntax differences yet by maintaining the same paradigm have the same ease of transfer just like going between tcl and C isn't hard
19:36:47 <edwardk> YayMe: there is a fair impedence mismatch between strict and non-strict languages in terms of what actually will terminate and how to write efficient code, but overall, yes.
19:37:01 <krakrjak> For me reading Okasaki has been kinda tough.  I'be been using the Haskell code in the back as a good guide and I do all the exercises in Haskell.
19:37:33 <krakrjak> It's taking a while.  It's amazing how deep the type system really is and how it gets out of your way.
19:37:47 <edwardk> krakrjak: definitely
19:39:26 <YayMe> edwardk: Of course, I was just referring to how easy it is to transfer techniques from one to the other even though obviously between TCL and C there is an enormous mismatch in what should and shouldn't be done, but if you know one you can transfer to the other easily
19:40:30 <YayMe> edwardk: The same can't be said of going from C to haskell however, knowing one gives you so little to transfer to the other with
19:41:00 <YayMe> Just commenting on the effects of a languages over all paradigm that is
19:41:42 <krakrjak> YayMe: really?  Especially if you want to call C functions most of your C transfers right into Haskell.  Add in some do notation and it can look a lot like C.
19:41:43 <YayMe> edwardk: Should I learn what these data structures are from other texts before reading okasaki's contributions to the bankers queue etc
19:41:49 <edwardk> *nods* folks coming from c find it to be a more gentle transition to move to ocaml or f# or another ml derivative typically because there is only one major component (mutability) being ripped out of their hands
19:42:21 <edwardk> YayMe: much of the vocabulary there is new, so you won't find things tracked as banker's and physicist queues in other sources for the most part
19:42:34 <edwardk> the vocabulary there is mostly about how to amortize the performance
19:43:00 <krakrjak> YayMe: sounds like your at the same section I am.
19:43:05 <YayMe> krakrjak: Let me put it differently, a C programmer can go read python with no knowledge of the language and automatically detect the syntax constructs, but could not do the same with a functional language written in it's languages normal style
19:43:11 <edwardk> i tend to view okasaki as a great counterpoint to a classic algorithms text, like http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844
19:43:52 <krakrjak> YayMe: I guess that's cause C, pascal, python and perl share a lot of syntatic heritage.
19:44:01 <YayMe> edwardk: I have knuth's fundamental algorithms, should I work through that first? That's what I was kind of starting with
19:44:23 <YayMe> krakrjak: are their any imperative languages that do not share those syntactic cosntructs though?
19:44:37 <edwardk> *shrug* bounce around. skim both, then try to read both in a more detailed fashion, etc.
19:44:42 <YayMe> I mean, TCL has a wildly different syntax I think
19:44:45 <ddarius> YayMe: Most of them.
19:44:52 <edwardk> i'm not a good source for the best order to do anything ;)
19:44:53 <krakrjak> YayMe: x86 assembly
19:44:55 <ddarius> Smalltalk has a wildly different syntax as does CL.
19:45:03 <YayMe> krakrjak: Smart alec. True :)
19:45:16 <krakrjak> YayMe: whitespace
19:45:21 <krakrjak> there's a few out there.
19:45:25 <ddarius> edwardk: That's patently false.
19:45:31 <YayMe> edwardk: Me either, I've got no degree and 10 years in the microsoft stack but still don't know any of this
19:45:36 <edwardk> ddarius: hah
19:45:58 <edwardk> YayMe: what i meant is my career led me to figure it out all rather backwards ;)
19:46:01 <YayMe> edwardk: Do you know if knuth is a worthwhile text even? I've been curious
19:46:10 <edwardk> YayMe: knuth is definitely worth working through
19:46:31 <edwardk> it is easily the most concise and well written and by far the best researched guide to many areas of computer science
19:46:34 <YayMe> Ok, didn't want to put my efforts in, finish it and have someone tell me it's completely out dated and not worth my time or something
19:46:39 * ddarius has never read any of TAOCP.
19:46:55 <krakrjak> YayMe: I'm not so sure.  For the modern practitioner I'm not so sure it's that beneficial to learn Knuth's assembly language.
19:47:18 <krakrjak> There are plenty of algorithms and data structure books out there.
19:47:20 <ddarius> krakrjak: What?!  Knuth is a wonderful source of learning what not to do in language design.
19:47:29 <monochrom> hahaha
19:47:45 <krakrjak> ddarius: yes in language design.  That's not what I do every day (unfortunately?)
19:47:45 <edwardk> it is very dense though, i find knuth to be best read without an eye towards application. sit down with it, and just read through it, you need to get a feel for what algorithms are out there, how they solve their problems, how they were derived and their relative merits
19:48:14 <edwardk> then once you've read through them like a novel, its a lot easier to go back and dive in deeper in the areas you care about
19:48:25 <YayMe> edwardk: No shit it's dense. I'm in chapter one been doing the actual work in the sections when I finish them
19:48:25 <nand`> I thought codensitied free monads were all the rage these days for encoding low level operational semantics, as opposed to assembly languages
19:48:28 <arbn> edwardk: That's true of volume 1. I find the others are better to just pick out a few areas of interest.
19:48:40 <edwardk> arbn: probably true
19:48:46 <krakrjak> I just don't think it's a great starting place for those that come from a practical background.
19:48:47 <YayMe> edwardk: This book makes me feel retarded, I'm glad to hear other people think it's dense as well
19:49:05 <krakrjak> I've already gone through it so maybe I'm biased cause I already absorbed the gems ;)
19:49:15 <monochrom> actually, once you've through them like a novel, heed the Bill Gates invitation on the jacket: "send me your résumé"
19:49:30 <edwardk> nand: free monads are useful for the first cut at a DSL. once i know what the interpreter looks like, its usually better to just take the final encoding of that interpreter as the monad itself
19:49:49 <edwardk> monochrom: =)
19:49:49 <arbn> If you're weak on the relevant math, you should work through Knuth's "Concrete Mathematics" first.
19:50:14 <YayMe> monochrom: That's the reason I'm studying this stuff. There's a google, microsoft, and hand full of other real research software shops near where I live, want to get on with one
19:50:37 <startling> arbn: is that the "continuous + discrete = concrete" book?
19:50:40 <YayMe> arbn: Good tip, I've never so much as taken college algebra so the math stuff is daunting to me
19:50:43 <arbn> startling: Yes.
19:51:06 * ddarius would recommend taking college algebra.
19:51:21 <edwardk> when in doubt learn more mathematics
19:51:28 <monochrom> you may be able to learn college algebra on your own
19:51:29 <startling> arbn: is it any good?
19:51:39 <startling> especially for someone with limited calculus and some algebra
19:51:51 <krakrjak> YayMe: If your goal is research then here's a tip.  Be patient, study hard, have fun and write more Haskell for great good!!!
19:52:29 <YayMe> krakrjak: Aye, my goal is to spend a year studying like this in the evening times my wife and kid allow..
19:52:37 <arbn> startling: It's not for someone who isn't comfortable with undergraduate mathematics, no. But, it's a great and rigorous survey of the math relevant for practical CS.
19:53:16 <krakrjak> YayMe: A year with Haskell is glorious!  Get ready to have some great epiphanies and some elegant code.
19:53:27 <arbn> startling: You should already be familiar with what is covered in Calculus courses, definitely.
19:53:35 <startling> arbn: k, thanks
19:53:40 <YayMe> krakrjak: not necessarily research, so much as a company that does do research. I'd be happy writing their internal garbage because at least the company would treat me right
19:53:52 <krakrjak> YayMe: if you can program iteratively then lean on the do notation until you are more comfortable using the collections in Haskell.
19:54:53 <YayMe> krakrjak: I'm a sink or swim person so I dove in a few months ago and am fine without using do, in fact I've been trying to avoid it altogether maintaining all my state on stack, or as okasaki says; persistently :)
19:55:33 <YayMe> If I wanted to try using state for things these trees would probably get a lot easier (and more performant I would assume)
19:56:11 <slack1256> data Eq a => Set a = NilSet | ConsSet a (Set a)
19:56:22 <slack1256> why are data context considere a bad thing(tm)
19:56:38 <slack1256> *considered
19:57:14 <monochrom> it is misleading and useless
19:57:27 <startling> slack1256: because it doesn't let you stick stuff there, even temporarily
19:58:26 <ddarius> Because they've been removed from the language.
19:58:52 <monochrom> heh
19:59:34 <slack1256> mmm it seems to me what with this you could implement Set as a monad without any extensions (apart from this one)
20:00:17 <ddarius> slack1256: Except that's not how it works.  See "misleading and useless."
20:00:35 <monochrom> have you tried? you will find that it is useless for that purpose
20:00:54 <monochrom> do not think. experiment and observe.
20:00:59 <shachaf> Misleading and useless for that purpose, in fact.
20:01:22 <ddarius> They were great for implementing strict fields back when seq was in a class.
20:01:29 <YayMe> What is "snoc" ?
20:01:31 <shachaf> Set as a monad is problematic even if you make it sort of work.
20:01:35 <shachaf> @ty ap
20:01:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:01:39 <startling> YayMe: flip cons
20:01:47 <YayMe> oh
20:01:49 <YayMe> got it
20:02:01 <shachaf> snoc is flip cons?
20:02:04 <shachaf> I've never seen it be that.
20:02:40 <startling> errr, cons on the other side
20:02:42 <YayMe> is it flip cons or is it append?
20:02:45 <startling> that's not flip cons, sorry
20:03:03 <YayMe> ok, so append
20:03:15 <YayMe> (what is cons short for anyway?)
20:03:25 <startling> YayMe: construct, I think
20:03:33 <startling> or "consecutive"? who knows
20:03:50 <shachaf> It's "construct".
20:03:52 <YayMe> hmm second makes more sense, but to you "who" knows, my money's on someone here heh
20:06:15 <startling> YayMe: anyway, point is that CS folks have bad senses of humor
20:07:01 <YayMe> haha
20:08:03 <edwardk> YayMe: snoc is 'cons onto the end of the list'
20:08:14 <YayMe> I don't understand this implementation of tail: tail (QueuefF =x ::f , R =rg) = QueuefF =f , R =rg(Page 16 okasaki)
20:08:23 <shachaf> Etymologically "snoc" doesn't make much sense.
20:08:30 <shachaf> But it works out anyway.
20:08:44 <nand`> that doesn't seem to parse as valid Haskell in my brain
20:08:54 <YayMe> It probably came from the same era of CS folks who decided ending an if with fi makes sense
20:09:13 <edwardk> YayMe: very much so
20:10:15 <YayMe> Oh nevermind, I get it, I was expecting tail to give me last, but that's different
20:10:39 <YayMe> ...carry on...
20:11:09 <edwardk> YayMe: tail (Q (x::xs) ys) = Q xs ys -- removes one entry from the head of the queue, but leaves the rest.
20:11:41 <edwardk> basically okasaki moves contents from the second list to the first list in various ways through the different queues he builds
20:12:11 <edwardk> er i guess it would be tail (Q (x:xs) ys) = Q xs ys
20:12:19 <YayMe> edwardk: Yeah, I got it, makes perfect sense, I was forgetting that catterpillar image LYAH draws and thinking tail was "last" which it is not
20:12:32 <edwardk> ah
20:14:41 <YayMe> It's funny.. I've implemented this exact same concept in the past, a queue made of 2 structures, one optimized for reads and one optimized for inserts with an infrequent chunk transfer
20:15:48 <YayMe> Always fun to find out things that seem you've done have been formalized before
20:16:04 <YayMe> s/seem//f
20:17:04 <krakrjak> all this haskell talk is making me dust off some code.
20:17:11 <krakrjak> I'm missing out on the fun tonight.
20:24:12 <YayMe> edwardk: Are you familiar with okasaki's queue? He speaks of ensuring head will always take O(1) by never allowing it to empty because then it would cost O(n) to refeed f from r due to the reverse necessary. He automatically feeds it with tail.
20:24:37 <edwardk> i've implemented everything in there at least once
20:24:41 <YayMe> This all makes sense except that, why wouldn't f empty from grabbing a bunch of heads
20:25:09 <YayMe> Do I not understand the consumption behavior of this queue? Will tail always be called after head?
20:25:10 <edwardk> head doesn't remove the contents
20:25:17 <edwardk> it just looks at them
20:25:21 <YayMe> Ahh
20:25:24 <YayMe> head is peak
20:25:28 <YayMe> peek
20:25:33 <edwardk> yes
20:25:34 <YayMe> heh not mountain
20:25:40 <edwardk> > head [1,2,3]
20:25:41 <lambdabot>   1
20:26:02 <edwardk> > tail [1,2,3]
20:26:03 <lambdabot>   [2,3]
20:26:09 <YayMe> So in this queue, your consumer must peak and consume separately
20:26:15 <YayMe> *peek
20:26:42 <edwardk> with those operations. you can of course, define soemthing like uncons that explicitly peeks and grabs the tail all in one go
20:26:44 <YayMe> as opposed to the dequeue method I'm used to which does both
20:26:53 <edwardk> uncons :: Q a -> Maybe (a, Q a)
20:27:14 <edwardk> uncons there is a more conventional dequeue op
20:27:37 <YayMe> I'm used to public interface IQueue<T> { T Dequeue(); void Enqueue(T); }
20:27:51 <edwardk> sure, but there is a problem with that interface.
20:27:57 <edwardk> how can i store nulls in the container? =)
20:28:06 <YayMe> So mentally translating these behaviors isn't immediately visible but I see now
20:28:24 <YayMe> if T is a reference type it's nullable
20:29:00 <edwardk> my point is i want to enqueue 3 nulls. how can you distinguish dequeueing a null from trying to dequeue from an empty container
20:29:12 <edwardk> thats the role of the Maybe in the definition i gave
20:29:35 <YayMe> enqueue = snoc (except of course being pure it returns a new copy rather than mutating the one you give it)
20:29:41 <edwardk> this is a common API deficiency in many java/c#/lisp queue models
20:29:50 <edwardk> yes
20:30:06 <YayMe> edwardk: Right, which is awesome, and way better than how you distinguish dequeing an empty container in imperative vs a null: a null gives a null, an empty container throws an exception
20:31:50 <JoeyA> Having dequeue return a Maybe is even better, since the compiler will force you to handle the empty case.
20:32:01 <YayMe> and dequeue = head queue; tail queue which is kind of funny when you think of it like that
20:32:42 <YayMe> JoeyA: Yeah, way better. I do like the lack of exceptions in haskell (granted they're there, just avoided)
20:33:00 <YayMe> whoa I forgot to eat dinner
20:33:13 <YayMe> *shakes fist at haskell*
20:33:15 <JoeyA> throwTo YayMe HungerException
20:33:28 <gentleben> YayMe: Oh it has then, but they are hardly a first class language feature
20:33:47 <shachaf> "exception" has about four different meanings in Haskell.
20:34:33 <gentleben> I refer specficically to Control.Exception
20:34:40 <YayMe> gentleben: That's what I mean, I know they're A) there, and B) completely constructable in a great deal of forms if you want to on your own
20:35:04 <YayMe> and due to B, there are many different forms of accomplishing similar tasks
20:35:34 <YayMe> either, maybe, control.exception, and probably countless other implementations people have done that serve the purpose
20:35:37 <JoeyA> The core functionality of Control.Exception is built in to the implementation.
20:35:50 <gentleben> ah
20:36:01 <gentleben> either, and maybe i would not think of as exceptions
20:36:12 <JoeyA> In particular, forcing an error value will produce that kind of exception, which can be caught in IO.
20:36:17 <YayMe> gentleben: They serve the identical purpose really
20:36:22 <gentleben> hardly
20:36:40 <ddarius> edwardk: The correct imperative answer to that is exceptions.
20:36:42 <gentleben> The STM does not return an either when its blocked
20:37:04 <gentleben> it throws an exception and tears down the process
20:37:04 <YayMe> gentleben: it throws an error?
20:37:06 <rwbarton> base == 4.5.* <=> ghc version = 7.4.*?
20:37:34 <edwardk> ddarius: except there is a whole subculture there who have been taught never to use exceptions for general control flow, and for whom the very word exception is dangerous because they've had 20 years of broken implementations in languages like c++
20:38:02 <JoeyA> When an STM transaction is invalidated, it doesn't even throw an exception.  It just stops whatever the thread is doing (hopefully only STM stuff) and restarts it.
20:38:07 <JoeyA> (if I'm not mistaken)
20:38:16 <ddarius> edwardk: That doesn't make the correct answer not correct.
20:38:28 <YayMe> f "big city burrito" = "mmm..."; f _ = "i want big city burrito :("
20:38:29 <gentleben> not if it detects it cannot progress
20:38:39 <gentleben> same with MVar
20:38:45 <JoeyA> From my experience, exceptions, especially asynchronous exceptions, are broken in Haskell, too.
20:39:04 <edwardk> it just makes it really difficult, given that you have companies like google who have standardized on just flat out not using exceptions anywhere for any purpose and so all their classes are deliberately not-exception safe, etc.
20:39:06 <JoeyA> For example, you can't interrupt an FFI call (for a good reason, too).
20:39:21 <shachaf> rwbarton: Yes.
20:39:28 <YayMe> edwardk: yes, exceptions OOO bad word! bla, that's the behavior that I'm trying to escape corporotocracy to get away from
20:39:29 <gentleben> and yet dealing with exceptions is often necessary
20:39:29 <shachaf> rwbarton: You should upgrade to 7.6!
20:39:32 <monochrom> f x = unsafePerformIO (putStrLn "I want big city burrito" >> return (f x))
20:39:37 <shachaf> Cale: Can you upgrade lambdabot to 7.6 too?
20:39:57 <gentleben> edwardk: using exceptions for control flow in a lazy language is especially twisted
20:40:07 <edwardk> gentleben: true enough
20:40:22 <gentleben> in java/c# its just bad style
20:40:27 <Cale> lel
20:40:28 <rwbarton> shachaf: Haha, actually I should upgrade to 7.4.
20:40:40 <Cale> lambdabot is still running 6.12.3
20:40:44 <shachaf> rwbarton: Why not skip 7.4 and go to 7.6!
20:40:48 <shachaf> s/.$/?/
20:40:54 <rwbarton> I'm afraid I would run out of disk space in the process thugh
20:41:09 <JoeyA> While you're at it, skip Windows XP and go straight to Vista.
20:41:10 <shachaf> Cale: 7.6 has Text.Read.readMaybe :: Read a => String -> Maybe a
20:41:19 <shachaf> Cale: Think of all the trouble that'll save with IRC!
20:41:31 <Cale> wat
20:41:34 <shachaf> rwbarton: Disk space?
20:41:50 <shachaf> That's a thing that has a limit?
20:42:03 <YayMe> gentleben: blech, I disagree. The fear of exceptions in the java/c# world is bafflingly extremist, many people are to the point that if you can't access a file you should return false instead of throwing an exception. which means the function above has to handle false, as well as that above it and so on, rather than using the naturally bubbling behavior of an exception
20:42:13 <shachaf> I thought they solved that ENOSPC thing ages ago.
20:42:14 <rwbarton> I wonder how old this laptop is
20:43:20 <shachaf> Looks like you can get a 500GB laptop disk for $60.
20:43:27 <shachaf> > 6000/500
20:43:28 <lambdabot>   12.0
20:43:48 <monochrom> what if I don't want to spend $60?
20:43:50 <gentleben> YayMe: its a fear from dealing with people who do things like throw exceptions for what should be normal control flow and take out the process. Some developer throws a MyAppIsInThisStateException and all of a sudden your customers are wondering why things are down
20:44:16 <monochrom> http://www.drmaciver.com/2009/03/exceptions-for-control-flow-considered-perfectly-acceptable-thanks-very-much/
20:44:18 <edwardk> YayMe: that is an actual exception, not using it for control flow. the control flow case is. hey run this loop for 1 million iterations, and throw an exception to bail out when the condition fails to hold. the no-exceptions-for-control-flow crowd find that galling, but may be perfectly okay with exceptions for exceptional situations
20:44:19 <shachaf> monochrom: Standalone GBs might be a bit more.
20:44:44 <YayMe> gentleben: actually I think it's a fear born of all the exceptions they see when they're doing things wrong, and especially the dereferencing exception just scares the daylights out of people
20:45:00 <monochrom> generally, my standard answer to "it's so cheap!" is "if it's so cheap, how about you pay it for me?"
20:45:05 <YayMe> edwardk: I know it is and should be an exception, which is why it drives me nuts how people will avoid using exceptions for that case
20:45:26 * monochrom believes in "put your money where your mouth is"
20:45:55 <monochrom> talking is the only cheap thing
20:45:58 <gentleben> YayMe: exceptions are for things that are exceptional. Like I cannot continue. For instance if a disk disappears while you are writing to it. When you have a large development staff not letting the mere mortals use them can save time and money
20:46:11 <shachaf> monochrom: Talking and hard disk space are the only two cheap things.
20:46:49 <gentleben> my favorite was in .net the web request class threw exceptions for any status code about 400
20:46:53 <YayMe> gentleben: I know, drives me nuts.
20:47:05 <edwardk> YayMe: anyways you can work around this without an exception justby passing in a by reference argument of some sort to say whether or not you successfully dequeued in your earlier example
20:47:22 <gentleben> i had a webcrawler so all status codes were normal and unexceptional
20:47:37 <gentleben> i prematurely closed connection is exceptional
20:48:08 <YayMe> edwardk: True, the standard approach I've seen java/C# folks use is public bool TryDequeue(out T);
20:48:24 <edwardk> yep
20:48:30 <YayMe> if dequeue fails it returns false and the out is default(T)
20:48:44 <monochrom> http://www.vex.net/~trebla/humour/Nightmare.java
20:49:02 <gentleben> yeah, when I first found Maybe in F# I was like where have you been all my life
20:49:20 <shachaf> monochrom++
20:50:02 <shachaf> Finally we have sum types in Java!
20:50:09 * hackagebot th-orphans 0.6 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.6 (MichaelSloan)
20:50:30 <monochrom> and a use case for exceptions
20:54:49 <rwbarton> "catch" is just one letter off from "match" anyways
20:58:51 <YayMe> Would this not maybe make more sense.. data Queue a = q [] [] a; head q [] (z:zs) x = head q (reverse zs) [] x; head q (a:as) zs _ = q as zs a
20:59:09 <YayMe> the last element is current
20:59:21 <YayMe> and then you don't need to call tail to ensure head never dies
20:59:49 <YayMe> okasaki's first implementation has unsafe head calls
21:01:11 <YayMe> oh n/m
21:01:18 <YayMe> I would need a maybe for my current
21:01:34 <YayMe> to ensure head only dequeued if it was nothing
21:02:59 <YayMe> does ML and all it's variants have Maybe?
21:04:22 <ddarius> monochrom: Do you need 500GB of laptop disk?
21:05:37 <ddarius> YayMe: Maybe is easily definable in pretty much any language.
21:07:06 <YayMe> I suppose, with varying levels of complexity in it's implementation.. for instance a language that has neither algebraic data type nor generics would be a pain
21:07:28 <YayMe> but ML having those I guess makes my question stupid
21:08:24 <YayMe> Has anyone here looked at or touched ela?
21:08:52 <krakrjak> not stupid.  When I learned Haskell I was very dismayed that every language doesn't have Maybe
21:09:37 <shachaf> elliott: No.
21:09:44 <elliott> Does anyone know if there's a way to formulate (m != n) as a constraint using GHC.TypeLits.Nat?
21:10:03 <elliott> There's only a (<=) class, which would be kind of inconvenient to express it with, though I guess I could.
21:10:16 <elliott> Wait, why am I even saying that? I mean GHC.TypeLits.Symbol.
21:10:46 <ddarius> s/language/standard library/
21:11:38 <elliott> shachaf: I think you know and are just trying to hide the truth from me. :(
21:12:00 <shachaf> I suspect monqy knows.
21:12:16 <YayMe> When someone says O(log n) could this be said to mean: The number of operations are asymptotically closer to n as n grows
21:12:36 <mdxbhmt> not at all
21:12:41 <rwbarton> what happened to "log"
21:13:00 <rwbarton> but also, not really
21:13:06 <mdxbhmt> http://www.cs.auckland.ac.nz/~jmor159/PLDS210/fig/log_graph.gif
21:13:19 <elliott> I guess I'll just have to use TypeEq or something. Assuming that even works with things of kind Symbol.
21:13:37 <YayMe> what is it asymptotically reaching?
21:13:42 <mdxbhmt> log n
21:13:49 <ivan> anyone have the HBC sources lying around? http://www.haskell.org/hbc/hbc-2004-06-29.src.tar.gz is gone
21:14:22 <YayMe> mdxbhmt: no, it's exactly reaching log n, but log n asymptotically reaches something, no? the square root of n?
21:14:29 <shachaf> It doesn't really mean "closer to n".
21:14:30 <ddarius> Clearly they are interpreting log n as a Cauchy sequence of equivalence classes of rational numbers where they are interpreting the Cauchy sequence as a function from naturals and producing the set of functions that are asymptotically bounded below by that Cauchy sequence.
21:14:31 <mdxbhmt> no
21:14:39 <mdxbhmt> YayMe: log n reaches infinity as n goes larger
21:15:16 <shachaf> Little-known fact: log(log(log(n))) -> 8 as n -> ∞
21:15:21 <mdxbhmt> YayMe: just extremly slow
21:15:31 <rwbarton> O(log n) also doesn't mean it exactly reaches or even asymptotically reaches log n
21:15:32 <edwardk> shachaf: =P
21:15:48 <mdxbhmt> shachaf: that doesnt make sense
21:15:50 <Jafet> If you branch cut log n, both sides asymptotically reach 0.
21:16:05 <shachaf> mdxbhmt: Sorry. :-( I'll try to make sense next time.
21:16:11 <mdxbhmt> shachaf: for me*
21:16:29 <ddarius> shachaf: There was too much coherence in that last remark of yours.
21:16:34 <Clint> next time make the 8 spin faster
21:16:36 <YayMe> mdxbhmt: I know it reaches infinity, but it slows significant at some point..
21:16:47 <shachaf> ddarius: Can't please everyone.
21:16:54 * shachaf would rather err on the side of incoherence.
21:16:55 <mdxbhmt> YayMe: aaaaaaah that's a diferent question
21:17:07 <Jafet> shachaf is in no superposition to argue.
21:17:08 <YayMe> Ah well, I guess I'll just continue to picture in my head that graph when I think of log n as I always do
21:17:28 <mdxbhmt> YayMe: you see, it can't asymptotically reach something since it goes to infinity
21:17:41 <mdxbhmt> YayMe: you could ask where it slows down
21:17:48 <YayMe> sorry, it's acceleration asymptotically reaches something
21:18:04 <YayMe> rather, it's acceleration is asymptotically reaching 0 I guess
21:18:17 <rwbarton> it would be best to look at an actual definition of what O( ) means
21:18:24 <YayMe> I suppose my question is more about the inflexion points perhaps where it crosses n
21:18:38 <ddarius> It has no inflexion points.
21:18:45 <YayMe> rwbarton: it means number of executions of the operation based on n data members, no?
21:18:54 <mdxbhmt> YayMe: But I don't think that really make sense since when you say O(log n) , you don't even really now what base the log is, so the O notation wont give you much info
21:19:37 <YayMe> mdxbhmt: Right, but it's absolutely normal for people to give the generalized O(log n) instead of the precise calculation for things
21:19:38 <shachaf> O(leg n)
21:19:59 <ddarius> shift k. O(leg k)
21:20:03 <YayMe> mdxbhmt: I guess they're just referring to the fact that it is very efficient when they say that
21:20:13 <mdxbhmt> YayMe: exactly
21:20:52 <YayMe> moreover, it's efficiency efficiency increases as the data set grows
21:21:07 <YayMe> each new data member costs less than the previous
21:21:15 <mdxbhmt> I wouldn't say that
21:21:19 <YayMe> after a point
21:21:26 <mdxbhmt> because it can be log n in time, but not in space
21:21:30 <Jafet> @remember ddarius shift k. O(leg k)
21:21:30 <lambdabot> Nice!
21:21:33 <YayMe> right, sorry
21:21:45 <mdxbhmt> efficiency is not the right word here
21:22:25 <mdxbhmt> anyway, anyone can give me tips for dsl? D:
21:22:57 <YayMe> yeah, plug the modem in and call AT&T
21:22:59 <ddarius> I think DSLs get paid quite enough as is.
21:23:01 <YayMe> :D
21:23:08 <mdxbhmt> darn it
21:23:09 <mdxbhmt> ahahaha
21:23:18 <mdxbhmt> Im switching to cable
21:34:09 <YayMe> is ML lazy capable?
21:34:20 <Cale> There is LML
21:34:57 <JoeyA> I hear the GHC was originally implemented in LML.  Then they switched to Haskell for some reason.
21:34:59 <Cale> One of the first Haskell compilers, HBC, was implemented in Lazy ML.
21:35:18 <Jafet> Okasaki thought so
21:35:56 <YayMe> Jafet: That's what made me think about it heh
21:36:59 <Cale> oh, interesting, GHC as well
21:37:04 <JoeyA> From Lazy With Class: "The first version of GHC was written in LML by Kevin Hammond, and was essentially a new front end to the Chalmers LML compiler."
21:37:26 <YayMe> Interesting
21:37:40 <BMeph> JoeyA: They make Haskell compilers in Haskell for the same reason that ugly men date beautiful women: 1) Because it's enjoyable; 2) Because they can. ;)
21:38:10 <Cale> There are also practical benefits to self-hosted compilers.
21:38:32 <Jafet> If you don't like the way your compiler is written, you can just change the compiler.
21:38:50 <YayMe> Are there any online haskell IDEs?
21:38:51 <JoeyA> http://cm.bell-labs.com/who/ken/trust.html
21:38:51 <Cale> Improvements to the compiler's code generation directly benefit the performance of the compiler itself.
21:39:05 <Cale> online?
21:39:07 <YayMe> JoeyA: EXACTLY what came to mind for me lol
21:39:20 <YayMe> Cale: like jsfiddle or shiftedit
21:39:42 <Cale> I have never heard of either of those things
21:40:01 <YayMe> jsfiddle.net
21:40:27 <mikeplus64> YayMe: ghclive?
21:41:33 <Cale> https://github.com/shapr/ghclive
21:42:03 <YayMe> I love the checkin comment "Doesn't compile, but looks like it should!"
21:42:27 <geekosaur> codepad seems to support haskell as well
21:42:27 <YayMe> and that's not hosted online, so technically that's an offline IDE heh
21:43:08 <geekosaur> although I have a vague recollection it uses hugs instead of ghc?  or maybe just an ancient ghc
21:43:44 <Cale> YayMe: It theoretically *could* be hosted online, if someone were willing to let you run code on their machine.
21:44:23 <YayMe> interesting. perhaps I'll install it on my desktop
21:44:35 <Jafet> A Haskell IDE would be nice, I'm tired of typing out fromIntegral all the time
21:44:35 <Cale> YayMe: There are seme projects to compile Haskell code to Javascript (ghcjs and Fay, to name a couple)
21:44:47 <Cale> YayMe: so eventually we might have something more like what you want?
21:44:59 <YayMe> I ask because I fiddle my haskell in leksah on my laptop but am too lazy to jack with leksah's configuration to change where it puts all the code so it goes to a network drive
21:45:27 <Cale> YayMe: It's pretty hard to do a web client-side Haskell IDE for a language that doesn't run in your web browser. :)
21:45:50 <YayMe> I know, but they exist
21:45:52 <Cale> YayMe: Use vim and ssh :)
21:46:51 <YayMe> bla. I've been in visual studio for over a decade now, a notepad like IDE drives me batty now heh
21:47:34 <YayMe> so used to just shift+ctrl+b to build my code or F5 runs it
21:48:27 <Cale> I've been doing my paid work lately in an IDE, and I mainly see its features as making up in some small part for the deficiencies of the shitty programming language that I'm using, rather than as essential.
21:48:42 <Cale> :r to reload in ghci
21:49:05 <Cale> (and then any expression to test things)
21:49:20 <YayMe> but you can't edit the code directly in ghci can you?
21:49:34 <Cale> no, that's why you keep two windows open side-by-side
21:49:35 <YayMe> it's just an expression evaluator
21:49:44 <YayMe> hrmm
21:49:46 <YayMe> curious
21:49:55 <geekosaur> pretty sure there are inferior-ghc modes for both vim and emacs (I know it's there for emacs)
21:50:08 <YayMe> geekosaur: ?
21:50:46 <geekosaur> a ghc running under control of the editor; you can send an entire source file or just an expression to the inferior ghc and see the result
21:51:05 <YayMe> huh.. interesting
21:51:16 <Cale> yeah, that stuff exists, I don't really bother with it
21:51:27 <geekosaur> with the right integration stuff, which I know is there for emacs but not so sure about vim, you get most of wht you would get from a dedicated IDE
21:51:38 <Jafet> http://charlespetzold.com/etc/DoesVisualStudioRotTheMind.html
21:51:41 <Cale> tbh, in Haskell I'll be happy with anything that'll do syntax colouring and will convert tabs to spaces
21:51:59 <YayMe> Maybe it would benefit me to try developing the way all you non-MS folks do, I've never had paid work to do so, so I've never seen how others do it
21:53:09 <mdxbhmt> YayMe: do you mean tryHaskell?
21:53:40 <Cale> mdxbhmt: He wants more than that :)
21:53:53 <Cale> mdxbhmt: (presumably)
21:54:08 <YayMe> Right, an expression evaluator alone isn't really enough to sit there and write a haskell program
21:54:15 <mdxbhmt> Cale:  then it must be something like that gsoc project
21:55:24 <Cale> I've often thought that it would be cool to have a Mathematica-like notebook interface to GHC.
21:55:43 <Cale> With code cells and expression/result cells, as well as text.
21:56:13 <Cale> (and then presumably graphical extensions, like ghclive has)
21:56:26 <Cale> (and then once that's done, FRP interactivity :)
21:57:22 <ddarius> http://www.amazon.com/Charles-Petzold-Does-Charles-Petzold-Rot-The-Mind/dp/157231995X
21:57:40 <Cale> lol
21:59:15 <lpvb> whats so bad about haskell's module system?
21:59:40 <ddarius> lpvb: That it's not great.
21:59:45 <lpvb> coming from C++ it's a breath of fresh air
21:59:50 <lpvb> ddarius: any reasons?
22:00:16 <Cale> lpvb: It attracts comparison with OCaml and SML's module systems
22:00:29 * ddarius thinks Cale understands his response.
22:00:41 <Cale> yes :)
22:01:14 <elliott> Cale: wasn't luite working on such an interface?
22:01:43 <Cale> lpvb: and those module systems have cute things akin to module-level functions -- so you can essentially have modules which take other modules as parameters when imported.
22:02:34 <Cale> lpvb: Which solves issues like we have with every library having 3 separate modules which differ in whether they use Data.ByteString.{Lazy/Strict} or Data.Text, say
22:02:41 <luite> elliott: perhaps ;)
22:03:10 <Cale> lpvb: *Theoretically* typeclasses can do the same job
22:03:29 <elliott> (if we ever get record parameters, please don't use them to pass in either Data.ByteString or Data.Text unless your input is just "any sequence module"! they're different things :( )
22:03:30 <Cale> But in practice, the sets of tasks that each makes easy are different
22:03:56 <Cale> elliott: well, sure :)
22:05:30 <luite> elliott: i haven't made too much progress recently though, too many distractions, and ghcjs
22:05:38 <YayMe> reading that charlespetzold article, funny and scary at the same time
22:06:28 <elliott> luite: mm
22:09:32 <lpvb> Cale: thanks, explanation makes me realize that haskell modules are kinda annoying
22:09:46 <ddarius> Because they aren't great.
22:10:04 <lpvb> any language extension to fix it?
22:10:11 * lpvb crosses fingers
22:10:15 <Cale> not yet?
22:10:33 <ddarius> lpvb: Just preprocess to type classes.
22:11:52 <Cale> It somehow hasn't gotten to the point of being a really big deal, because Haskell modules are pretty decent, but as ddarius says, not to that level of greatness. If the module system were to be extended, it would likely be to do what other languages have already done as well
22:12:47 <Cale> (more papers get written extending the type system)
22:13:27 <Cale> Maybe some thought should be put into whether the module system could be even better than the ones the MLs have :)
22:13:28 <djahandarie> I'd like to see parameterised modules.
22:13:59 <ddarius> djahandarie: Just encode into type classes.
22:14:16 <Cale> ... or records :)
22:14:34 <Cale> (though those don't allow type declarations, and type classes do now)
22:14:43 <ddarius> Exactly.
22:14:56 * ddarius leaves all his rebuttals to Cale up to Cale.
22:15:28 <djahandarie> I don't think that's as nice.
22:16:01 <ddarius> It's slightly less convenient, but it is way more powerful than just parameterized modules.
22:16:07 <lispy> ddarius: http://theproofistrivial.com/
22:17:22 <Cale> Reminds me of this time when I was joking with my friend James in university and he remarked "Cale's self-deprecating humour goes really well with my Cale-deprecating humour"
22:18:12 <lispy> heh
22:18:15 * ddarius appreciates Cale's precise use of the word "with."
22:19:27 <ddarius> djahandarie: It would actually be a relatively easy and fun exercise to make a TH function or quasi-quoter to translate some module description language into Haskell's type class system.
22:20:30 <Jafet> So we could finally have more than one module per file?
22:20:56 <lispy> (my sweetheart just walked into the room and asked if we're figuring things out, or if this is just a 2012 version of #teen-hot-tub for nerds)
22:21:03 <lispy> How do I answer that?
22:21:04 <ddarius> Jafet: That's the implementation's fault.  Haskell says nothing about one module per file.
22:21:33 <Jafet> lispy: come on in, the water's fine
22:21:33 <ddarius> lispy: "We're figuring out that this is a 2012 version of #teen-hot-tub for nerds."
22:22:00 <lispy> good answers :)
22:22:06 <Jafet> ddarius: yes, but the implementation is haskell
22:23:47 <lispy> On a more serious note, what are people up to these days?
22:23:52 <lispy> Any of you going to ICFP this year?
22:24:08 * lispy feels kind of out of touch
22:24:14 <djahandarie> What do people do at ICFP anyways?
22:24:22 <Cale> lispy: We need to get some 0-day GHC w4r3z XDCCs going in here
22:24:39 <YayMe> djahandarie: Wish that anybody cared about functional programming in industry
22:24:46 <YayMe> oh wait, that's just a guess, I've never been heh
22:25:09 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_industry
22:25:11 <lispy> YayMe: I work at an industry place that cares deeply about FP :)
22:25:24 <YayMe> Cale: I know I know, I've seen that before
22:25:31 <YayMe> lispy: Great, are they hiring? :D
22:25:38 <lispy> YayMe: up
22:25:40 <lispy> er yup
22:25:44 <Cale> We're going to rewrite our web application backend in Haskell at the company I'm working for atm.
22:25:57 <lispy> YayMe: http://corp.galois.com/careers/
22:26:16 <arbn> I was recently hired by a place that wants me to write their web application backend in Haskell.
22:26:24 <YayMe> Cale: Oh yeah? Well they're making me maintain C# code that was written in the 80's in pascal and has been ported ever since with strict demands that nothing be changed
22:26:27 <YayMe> Cale: So there!
22:26:32 * YayMe weeps
22:26:46 <YayMe> lispy: Let me try again, are you hiring people who don't know what they're doing?
22:26:59 <lispy> YayMe: heh.
22:27:21 <lispy> YayMe: we do hire interns, if that counts :)
22:27:34 <YayMe> heh, that's only uhm, an enormous pay cut
22:27:38 <arbn> YayMe: I was actually asked about dependent type theory and comonads on the interview, for some reason. So, study up. :P
22:27:55 <Cale> YayMe: I'm maintaining groovy time scheduling code which was in large part written by people who apparently didn't understand OOP or times and dates, and for that reason were fired.
22:28:18 <MostAwesomeDude> Wait, it's written in Groovy?
22:28:47 <YayMe> Cale: my company will hire them, they think the best way to store a timespan is in a string, and they might fire you if you disagree
22:28:53 <Cale> MostAwesomeDude: lol, yeah. It really gives PHP a run for its money.
22:29:21 <lispy> Cale: did you move to a different company?
22:29:52 <Cale> YayMe: Here there's a bunch of code which uses integers like 1540 to represent the time 15:40 in some time zone which travels separately
22:30:05 <Cale> lispy: I'm still working for Ryan
22:30:10 <YayMe> haha I guess that's not much better
22:30:11 <Cale> lispy: at his other job :)
22:30:15 <lispy> Cale: ah!
22:30:37 <lispy> Cale: oy, I've seen some shit code, but that's pretty bad.
22:30:40 <YayMe> It's sad how much money can be made on shitty software
22:30:47 <rwbarton> it only took about 100 tries but I got theproofistrivial.com to output a coherent sentence
22:31:13 <nand`> all I ever heard is knowledgeable developers complaining about maintaining code written by people with no clue; is this just the vocal minority or is there some form of mechanism that asserts a prevalence of such situations?
22:31:44 <nand`> rwbarton: cute
22:31:45 <YayMe> lispy: how's this for a representative line I ran across yesterday at work: private const string EMPTY = ""; (in C# string.Empty has been around since, ever.)
22:31:56 <rwbarton> oh wait, this sentence is not quite coherent
22:31:59 <rwbarton> "Just biject it to a finite group whose elements are twice-differentiable bijections"
22:32:00 <lispy> rwbarton: hehe
22:32:01 <Cale> lispy: iPwn is on some sort of extended hiatus while he gets together some more money -- the game engine is pretty close to being complete, and there's a lot of art and music done, so it'd be a shame not to return to it at some point and make something that could be sold
22:32:04 <nand`> rwbarton: you should include a <noscript> message or something indicating that the site requires javascript to function - or, even better, generate the output server-side
22:32:08 <nand`> I was a bit confused by the blank page
22:32:18 <rwbarton> it's not mine, lispy linked to it a few minutes ago
22:32:28 <nand`> oh, okay
22:32:36 <rwbarton> I have just been hitting reload :)
22:32:47 <lispy> Cale: righto
22:33:00 <Cale> lispy: I also have a bunch of ideas for how to use the game engine we already have to make some simpler-to-implement games
22:33:03 <nand`> “Just view the problem as a structure-preserving metric space whose elements are associative monoids”
22:33:06 <lispy> YayMe: That's unfortunate, but it's not that bad in the grande scheme.
22:33:23 <rwbarton> "Just view the problem as a countable poset whose elements are finite monoids", there's a good one.
22:34:24 <YayMe> lispy: how about the fact that today I was instructed that it's better to use magic numbers over member level consts
22:34:32 <nand`> “The proof is trivial! Just view the problem as a trivial group”
22:34:34 <nand`> yes, thanks
22:34:36 <nand`> that helped
22:35:00 <lispy> YayMe: that's not right.
22:35:24 <YayMe> lispy: or the database table I found today with an nvarchar column named "timespan" with the strings "05:00" in every record
22:36:00 <lispy> YayMe: the last really horrible codebase I refactored used what I call a try-ignore pattern. try { ... } catch(Exception e) { /* TODO: what should we do? */ }
22:36:05 <YayMe> except one record had "Tue 17" which is kinda funny because that's in no way a timespan heh
22:36:07 <nand`> reading this conversation is probably ruining my job chances
22:36:19 <YayMe> lispy: haha yeah that's pretty standard
22:36:27 <nand`> I'll be forever scared of touching code written by people I'm unfamiliar with
22:36:41 <lispy> YayMe: it was giving bogus values in the database, so the developer wrote a sanitizer pass (obivously it gave bogus data because of bad input, right?)
22:36:55 <rwbarton> This definitely makes me want to figure out what a "rational complexity class" or a "context-free manifold" is, though
22:36:57 <YayMe> nand`: Avoid any company who has products which are *not* software
22:37:13 <ddarius> lispy: It's very likely true that it was being fed bad input.
22:37:45 <nand`> YayMe: will do
22:38:11 <luite> rwbarton: exactly one google hit for "rational complexity class"!
22:38:14 <lispy> YayMe: Turns out that there were so many levels of try-ignore that the real errors were being hidden. Problems included: a) doing linear regression on a single point, b) doing string comparison on doubles (by accident) instead of <, <=, etc, c) normal run of the mill bugs.
22:38:20 <nand`> so now I'm looking for a company which produces free software, does not sell anything besides software, and uses Haskell
22:38:21 <YayMe> nand`: When the bottom line comes from the software, the quality of the software becomes relevant to the management, in other companies the software is just a cost center in their business
22:38:59 <YayMe> lispy: Heh, nice..
22:39:12 <lispy> YayMe: the linear regression on a single point was causing divide by zero, then the string comparisons on that value passed, and the resulting NaN was stored in the database and coerced to a 32bit int. So then you get bogus values!
22:39:29 <YayMe> bogus is relative
22:39:33 <YayMe> they were values, and they were integers
22:39:34 <YayMe> :D
22:39:38 <rwbarton> lispy: D'oh! Everyone knows if you want to do a linear regression, you're supposed to collect *two* data points.
22:40:03 <lispy> the database scheme was a train wreck as well. They didn't use foreign keys because the "stupid database engine" wouldn't allow them for columns with different types :)
22:40:27 <YayMe> lispy: Yeah, at my place no foreign keys either, because, why bother?
22:40:37 <lispy> YayMe: they were in the billions; it was calculating statistics from traffic counts. They didn't have a billion drivers :)
22:40:46 <ddarius> Be not swayed by those of heretics of the Church of the Overdetermined Linear System.
22:41:01 <YayMe> lispy: Also, this is the first place I've worked that still writes inline SQL since 2000
22:41:36 <YayMe> lispy: You don't know that, maybe a bunch of extra drivers came out at night while you were sleeping.. :D
22:41:45 <nand`> ‘clopen’ oh man
22:41:56 <ddarius> nand`: What about clopen?
22:42:01 <lispy> nand`: that's a real term, but you probably knew that
22:42:23 <nand`> yeah, as much as I want to believe it's just a running joke
22:42:36 <nand`> ‘Sir, we call sets that are both closed and open clopen’
22:42:59 <ddarius> Much more compact than "closed and open".
22:43:04 <lispy> YayMe: inline sql and non-normalized schemes are things I don't mind. Normalization is usually good, but it can go too far relative to what you need. Inline sql? I don't mind that at all. SQL is often a better DSL for what it does than the host language.
22:43:05 <ddarius> Poor sets that are neither closed nor open.
22:43:24 * ddarius agrees with lispy.
22:43:29 <nand`> indeed; the silly thing here is that ‘closed’ and ‘open’, which we consider to be antonyms, are not exclusive
22:43:36 <amosr> much rather inline SQL than stored procedures with no version control *shudder*
22:43:40 <YayMe> lispy: I'm just used to writing all my SQL in stored procedures
22:43:52 <startling> has anyone written an inspectable parser? would be super cool to be able to automatically generate a Gen and/or a function to construct one
22:43:57 <YayMe> amosr: Egh.. who doesn't use version control for their stored procedures??
22:44:09 <lispy> startling: inspectable?
22:44:20 <lispy> startling: you want the source code or does that mean something else?
22:44:49 <startling> lispy: I want a the parser to be represented as a transparent data structure rather than an opaque function
22:45:01 <lispy> startling: oh, I see.
22:45:03 <nand`> ‘whose elements are structure-preserving integers’ O.o
22:45:07 <amosr> very very cruel people. I think it's more effort to version control SPs
22:45:20 <amosr> so they don't bother. whereas inline sql, it's "free"
22:45:25 <startling> hmmmm, maybe the parser could be a lens
22:45:25 <Jafet> theproofistrivial.com is rather trivial.
22:45:37 <lispy> startling: Could you look at parsers specified with happy?
22:46:35 <ddarius> startling: You can easily make a little AST for describing parsers and then interpret it into any parser library.
22:46:39 <YayMe> amosr: yeah.. I think that's probably why they're doing inline sql here..
22:46:48 <Cale> "closed topological space whose elements are combinatorial integers"
22:46:49 <Cale> lol
22:46:50 <startling> ddarius: yeah, that's what I'm doing at the moment
22:47:01 <startling> ddarius: mostly wondering whether there's already something for that
22:47:53 <lispy> startling: there were some papers about something related at ICFP in the last few years. Unparsers? I forget what they called it. They wanted to generate the parser and pretty printer from one representation.
22:48:41 <startling> lispy: yeah, "unparsers" are a thing. there's been some work on OMeta with this, dunno about anything in the functional world
22:49:03 <ddarius> There are tons of papers about this in all branches of computer science.
22:49:47 <Cale> "Just view the problem as a computable language whose elements are combinatorial groups"
22:49:49 <YayMe> I've heard it said sql is a functional language, is that true?
22:50:01 <ddarius> It's a declarative language.
22:50:11 * hackagebot texmath 0.6.1 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.1 (JohnMacFarlane)
22:50:18 <YayMe> I've been writing SQL for so many years I can't think of it in any way except.. as SQL, so I haven't been able to really think through whether it is or not
22:50:20 <ddarius> And under the veil of logic languages, not functional languages.
22:50:30 <YayMe> ok
22:50:48 <Cale> "Just view the problem as a structure-preserving semigroup whose elements are orientable hypergraphs"
22:50:48 <YayMe> Didn't see how it could be functional..
22:51:06 <ddarius> I should say, SQL queries are.  Updates, inserts, etc. are not.
22:51:49 <YayMe> updates/inserts are just commands?
22:53:16 <startling> Cale: ahhh
22:53:22 <startling> Cale: it all makes sense now
22:54:32 <nand`> SQL is pretty close to the relational algebra, isn't it?
22:54:43 <Cale> I've started to think that SQL might have been a really terrible thing to happen to databases, because as a standard, it seems to have done a lot to stifle innovation in terms of the language we use to express relational queries.
22:55:41 <nand`> I do think SQL, at least the way I had to use it in tests, had an absolutely *horrible* implementation
22:55:48 <arbn> I'm still a bit confused on why people think that JavaScript, as a query language, is a step up from SQL.
22:55:51 <nand`> implementation as in the language semantics themselves
22:55:52 <YayMe> Cale: How do you feel about mongoDB's approach regarding that then?
22:56:12 <nand`> something more principled and good-natured based off the same relational principles might have been a much better alternative
22:56:21 <ddarius> There have been a plethora of worse ideas since SQL.
22:56:23 <YayMe> arbn: haven't you heard? javascript can do everything now! (waves magic hands)
22:56:39 <arbn> YayMe: Sadly, yes. :(
22:56:44 <arbn> It depresses me.
22:56:51 <YayMe> heh aye
22:57:02 <nand`> what's the etymology on JavaScript's name, either way?
22:57:07 <YayMe> sadly, node is eating Warp's lunch
22:57:20 <ddarius> nand`: It was called LiveScript but then they tried to cash on Java's popularity.
22:57:33 <nand`> so that wasn't just a joke from the brief-and-mostly-incorrect history?
22:57:41 <Cale> YayMe: I kinda want something which goes in the opposite direction from that.
22:57:49 <nand`> they actually renamed it JavaScript for Java's sake?
22:57:53 <nand`> well, not sake
22:57:53 <MostAwesomeDude> YayMe: You missed the part where it ate Twisted's breakfast. :3
22:58:20 <YayMe> MostAwesomeDude: let's just agree that it's a jerk
22:58:43 <MostAwesomeDude> YayMe: Okay.
22:58:44 <Cale> YayMe: but at least it's a little easier to coerce realistic datastructures into BSON/JSON
22:59:11 <ddarius> Nothing about SQL restricts you to "primitive" types.
22:59:55 <Cale> ddarius: But who does SQL + GADTs? ;)
23:00:04 <ddarius> Cale: Not Mongo.
23:00:12 <Cale> That's for sure
23:00:52 <YayMe> Cale: what would you like to see then in SQLs place? Haskell? lisp?
23:00:59 <Cale> ddarius: Practically speaking, are there many SQL databases which have anything like an interesting type system?
23:01:09 <ddarius> Haskell and Lisp would both be much worse query languages than SQL.
23:01:25 <ddarius> Cale: Your scale for "interesting" is probably to skewed.
23:01:37 * nand` wonders what a mathematically-oriented relational query language full of unicode symbols would look like
23:01:45 <YayMe> ddarius: I can't objectively think of any better so I'm throwing out random ones, I've written way too much SQL to look at it objectively
23:02:16 <Cale> ddarius: Just ordinary algebraic datatypes would be nice
23:02:25 <ddarius> The reason that SQL is so popular is, despite it's warts, it is actually a pretty good language for its domain.
23:02:28 <startling> @hoogle a -> (a -> a) -> [a]
23:02:29 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
23:02:29 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
23:02:29 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
23:03:23 <startling> @src enumFrom
23:03:23 <lambdabot> Source not found. There are some things that I just don't know.
23:03:26 <YayMe> Cale: For what it's worth, newer versions of MSSQL have a variant type which behaves like a record specific (not table specific) generic. Don't know if any other servers have the same? Probably do
23:03:34 <lpvb> ddarius: prolog as a query language?
23:03:48 <startling> how do I do the opposite of enumFrom?
23:03:57 <ddarius> Cale: The whole "OODB" thing (which is now folded into many major implementations) allows you to have arbitrary abstract types.  There are also systems that allow relations as components.
23:04:08 <nand`> startling: you mean, enuming downwards?
23:04:09 <YayMe> startling: enumTo :D
23:04:12 <Axman6> @src Enum
23:04:12 <lambdabot> class  Enum a   where
23:04:12 <lambdabot>     succ                     :: a -> a
23:04:12 <lambdabot>     pred                     :: a -> a
23:04:12 <lambdabot>     toEnum                   :: Int -> a
23:04:12 <lambdabot>     fromEnum                 :: a -> Int
23:04:13 <startling> nand`: yes
23:04:14 <lambdabot> [3 @more lines]
23:04:18 <Axman6> @more
23:04:19 <lambdabot>     enumFrom                 :: a -> [a]
23:04:19 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
23:04:20 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
23:04:23 <ddarius> lpvb: See Datalog which is, to some extent, what you would get if you did aim Prolog at being a query language.
23:04:26 <Cale> ddarius: hmm
23:04:30 <nand`> enumFromThen a (pred a) might do it
23:04:54 <ddarius> lpvb: Prolog, though, is a pretty horrible language (that you should learn), and, unchanged, would be completely unsuitable for SQL's realm.
23:05:17 <startling> YayMe: ?
23:05:31 <Cale> YayMe: As far as non-sql solutions go, acid-state is my current favourite
23:05:35 <YayMe> startling: sorry, was unhelpful sarcasm
23:05:40 <startling> YayMe: oh.
23:05:52 <startling> Do I need Bounded?
23:06:02 <startling> not sure how enumFrom works without Bounded
23:06:09 <Cale> YayMe: http://hackage.haskell.org/package/acid-state
23:06:49 <ddarius> lambdaProlog would also be unsuitable, though a suitably modified version would be interesting and would be a monster to implement.
23:06:53 <u_> cabal is taking up 100% cpu again
23:07:04 <startling> @src (enumFrom :: Int -> Int)
23:07:04 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:07:07 <u_> can't be killed
23:07:12 <ddarius> u_: Damn, no parallelism.
23:07:12 <startling> @src Int enumFrom
23:07:12 <lambdabot> Source not found. Sorry.
23:07:22 <startling> u_, not even kill -9'ed ?
23:07:27 <u_> yup
23:07:28 <u_> not even that
23:07:33 <startling> huh
23:07:35 <Cale> YayMe: Compared to most production DBs though, it's pretty embryonic, and it doesn't really specify any manner in which to query your data, it just handles storage.
23:07:51 <YayMe> Cale: You can't retrieve the data? heh
23:07:56 <nand`> startling: with Bounded, enumFrom counts up to the maxBound; without Bounded, enumFrom counts up indefinitely
23:07:59 <u_> maybe its a virus \o/
23:08:08 <Cale> YayMe: You can retrieve it, it's just that your database is a Haskell value.
23:08:18 <u_> i didn't even do anything with it
23:08:27 <startling> nand`: ah. so is there an `enumDownFrom`?
23:08:33 <u_> haven't used it in over a day
23:08:39 <startling> @hoogle Enum a => a -> [a]
23:08:40 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
23:08:40 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
23:08:40 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
23:08:43 <nand`> I do like acid-state's approach, since it lets me define the query operations I need and/or want to expose
23:08:58 <nand`> well, apart from the whole pure-Haskell safe-state thing
23:09:09 <YayMe> Cale: Ah.. I saw something on hackage that was like part of a framework I sware called Persistence that had tie-ins for a variety of DB's and allowed full haskell syntax for querying I think..
23:09:22 <Cale> yes, persistent
23:09:33 <YayMe> How is that? I was thinking about playing with it
23:10:08 <nand`> startling: not to my knowledge, but enumFromThen a (pred a) should definitely ‘do the right thing’
23:10:26 <ddarius> For some values of "definitely".
23:10:26 <nand`> actually, let me retract that claim
23:10:31 <Cale> I don't actually know. It's part of the Yesod framework, which in general I find a little scary for all the Template Haskell stuff, but otherwise looks well-maintained and developed.
23:10:38 <arbn> YayMe: It's a peristence layer... not unlike the object-mappers often found in OO web frameworks, really.
23:10:53 <arbn> persistence*
23:11:10 <nand`> enumDownFrom minBound would be [minBound], but enumFromThen minBound (pred minBound) would most likely error
23:11:14 <YayMe> arbn: Right, I was just looking for a subjective opinion from someone who knows more about haskell than I
23:11:25 <startling> meh, Bounded should be defined by isMaxBound :: a -> Bool and isMinBound :: a -> Bool
23:12:10 <Cale> heh, of course, you could also be like Reddit, and store everything in a SQL database with two tables, each of which has two columns
23:12:14 <ddarius> That would be a shitastic interface.
23:13:08 <arbn> YayMe: You should try Yesod. It's really fun.
23:13:39 <nand`> startling: not only can you not *generate* the bounds that way, you're also limited in what you can do with it - in the approach taken by Bounded, you can enrich your types with other constraints eg. (Eq a, Bounded a) would let you write isMaxBound/isMinBound
23:14:02 <Cale> I think the Haskell web framework which most pleases me at the moment is Happstack, just because it appears to have the least magic.
23:14:19 <ddarius> nand`: It also readily allows many wrong implementations.
23:14:25 <nand`> startling: not to mention the fact that something may be Bounded which is not equatable in the first place
23:14:57 <arbn> I will admit that I've had some nasty compile-time code exceptions from TH, which were interesting to debug...
23:15:11 <arbn> while using Yesod.
23:15:46 <startling> nand`: yeah, understood
23:16:00 <startling> so what should I do to get everything greater than a given Enum?
23:16:08 <startling> err, *less than
23:16:19 <Cale> startling: you don't.
23:16:47 <startling> Cale, well
23:17:01 <startling> not even if I have Bounded and Eq , too?
23:17:31 <Cale> startling: Enum is a class which defines the syntax sugars [a..], [a..b], [a,b..], and [a,b..c]
23:17:51 <Cale> It doesn't guarantee anything about whether [a..b] hits all the elements between a and b
23:18:13 <Cale> or really much about what succ and pred do
23:18:39 <startling> Cale: yeah, and there's no guarantees about `fmap id`, either
23:18:49 <Cale> yes there are :)
23:19:06 <Cale> fmap id = id is an actual intended law for that class
23:19:07 <paolino> > maxBound :: Integer
23:19:09 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
23:19:09 <lambdabot>    arising from...
23:19:23 <Cale> Enum doesn't intend to give you a way to exhaustively enumerate values of a type
23:19:34 <Cale> It just says what the list notations mean
23:20:00 <Cale> and I guess a mapping back and forth from Int
23:20:06 <startling> so is there a way to exhaustively enumerate values of a type?
23:20:08 <Cale> which may or may not be injective
23:20:16 <startling> @hoogle a -> (a -> a) -> (a -> Bool) -> [a]
23:20:16 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
23:20:16 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
23:20:16 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
23:20:17 <Cale> Not in the Prelude
23:20:29 <Cale> There's iterate which might be useful
23:20:53 <startling> yeah, I've seen iterate but I don't see an iterate-until
23:21:04 <Cale> use takeWhile?
23:21:11 <startling> oh, that's a good point
23:22:40 <paolino> iterate succ x == [x..] ?
23:22:51 <ddarius> paolino: No.
23:23:15 <startling> :t iterate succ
23:23:16 <lambdabot> forall a. (Enum a) => a -> [a]
23:23:23 <Jafet> > iterate succ (255 :: Word8)
23:23:25 <lambdabot>   [255,*Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
23:23:25 <startling> :t \x -> [x..]
23:23:26 <lambdabot> forall t. (Enum t) => t -> [t]
23:23:33 <startling> Jafet: oh, right
23:23:58 <Cale> That one might morally be a law of Enum, but I'm not sure whether it even holds for all the Report instances :)
23:24:06 <Jafet> > iterate succ maxBound
23:24:07 <lambdabot>   [(),*Exception: Prelude.Enum.().succ: bad argument
23:24:21 <Jafet> That is the best default ever
23:24:24 <Cale> oh, right
23:24:29 <Cale> hah, it doesn't, of course
23:24:38 <Cale> > length ['\0'..]
23:24:39 <lambdabot>   1114112
23:24:54 <AfC> Can someone suggest a criterea for choosing one XML library over another? ie HaXmL vs HXT vs XmlHtml vs ?
23:24:59 <paolino> > [()..]
23:25:00 <lambdabot>   [()]
23:25:12 * hackagebot texmath 0.6.1.1 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.1.1 (JohnMacFarlane)
23:25:29 <m3ga> AfC: o/ what is your use case?
23:25:39 <ddarius> Cale: If isIEEE returns True for a Double or Float value, then the Report doesn't even satisfy reflexivity for Eq.
23:25:51 <lpvb> > [minBound .. maxBound] :: Int
23:25:52 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:25:52 <lambdabot>         against inferred type ...
23:25:58 <lpvb> > [minBound .. maxBound] :: [Int]
23:25:59 <lambdabot>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
23:26:02 <paolino> Jafet, Enum stuff has no exceptions ?
23:26:14 <Cale> ddarius: That I know about :)
23:26:35 <paolino> :i Enum
23:26:43 <paolino> @src Enum
23:26:43 <lambdabot> class  Enum a   where
23:26:43 <lambdabot>     succ                     :: a -> a
23:26:43 <lambdabot>     pred                     :: a -> a
23:26:43 <lambdabot>     toEnum                   :: Int -> a
23:26:43 <lambdabot>     fromEnum                 :: a -> Int
23:26:45 <AfC> m3ga: I'm mulling over attempting to implement my parchment renderer in Haskell (as an exercise, with a view to maybe using it preferentially) and so need to load docs off disk and presumably populate them into an in-memory model of some kind
23:26:45 <lambdabot> [3 @more lines]
23:27:50 <ddarius> We should clearly have a class for PERs.
23:27:56 <paolino> > [(),()..]
23:27:57 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
23:28:12 <m3ga> AfC: ah! probably not a place where xml-conduit is suitable answer.
23:28:17 <Cale> AfC: I've used hexpat-pickle before and been happy with the results.
23:28:24 <m3ga> s/suitable/best/
23:28:35 <paolino> > [()..()]
23:28:36 <lambdabot>   [()]
23:28:37 <m3ga> AfC: i've used hexpat too.
23:28:44 <Cale> But I don't know whether it's completely ideal for your case, seeing as you have data in a pre-existing format.
23:28:57 <Cale> (the pickle part)
23:29:10 <AfC> hexpat. Hm. Have to look at that
23:29:18 <ddarius> Cale is all about serializing Haskell data structures.
23:29:35 <Cale> lol
23:29:39 <AfC> heh
23:29:49 <AfC> yeah, this is existing documents to a defined spec
23:30:07 <AfC> so on the saving side I need a fair bit of control on the renderer.
23:30:39 <AfC> some XML libraries give you lots of knobs for that, others assume all XML was created equal and that "you shouldn't have to worry about that"
23:31:13 <m3ga> well the rendering is easier than parsing. defining your own xml pretty printer should not be too hard.
23:31:23 <AfC> m3ga: agreed
23:31:24 <Cale> ddarius: I've been thinking a fair amount about it lately, since we need to decide on some kind of storage for this backend rewrite.
23:31:26 <startling> so what are the downsides of UndecidableInstances?
23:31:48 <startling> I mean, what does undecidability mean for us?
23:32:09 <Cale> startling: http://lukepalmer.wordpress.com/2008/04/08/stop-using-undecidable-instances/
23:33:02 <Cale> More helpfully...
23:33:17 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances
23:33:51 <startling> this sucks
23:33:57 <startling> I'm gonna go learn idris
23:34:16 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
23:34:39 <Cale> it turns off checking the Paterson Conditions and the Coverage Condition
23:35:32 <Cale> which means that deciding whether an instance exists for a given type is no longer a-priori decidable
23:35:46 <Cale> It might not terminate
23:35:58 <startling> which basically means I can't make a class Exhaustive without hand-defining each numeric type, right?
23:36:18 <Cale> That would be the right way to do it, yeah.
23:36:32 <startling> bleh
23:36:38 <Cale> Something you should realise about instances
23:36:40 <Cale> when you write
23:36:59 <Cale> instance (context) => C x y z
23:37:22 <Cale> The context is ignored for the purposes of deciding which instance matches
23:37:43 <Cale> So this is, for the purposes of deciding which instance to use, the same as
23:37:47 <Cale> instance C x y z
23:38:04 <Cale> It checks that the context holds only after committing to using that instance.
23:38:32 <startling> right, and it doesn't backtrack?
23:38:48 <Cale> (Well, it actually doesn't necessarily check that the context holds at all, it generates a constraint which says it must hold, and that may cause a type error somewhere else)
23:39:04 <Cale> or it may just result in polymorphism
23:39:48 <Cale> and right, it doesn't backtrack
23:40:37 <Cale> The reason it doesn't backtrack is that backtracking would mean that we've discovered that there definitively *isn't* an instance to satisfy some constraint in that context.
23:40:55 <Cale> But future modules can always add new instances of typeclasses.
23:41:07 <Cale> and so it would result in inconsistent behaviour
23:43:05 <Cale> There is a point at which it really does have to say "okay, there really isn't an instance of this, and I need to complain now", when compiling something though. But I seem to recall you'll run into separate compilation problems if you try to make it wait until then to decide.
23:44:41 <Cale> startling: does that make any kind of sense?
23:44:58 <startling> so, 1) Enum is useless, 2) Bounded is useless without Eq, and 3) Haskell's type system means I can't write a useful one of these?
23:45:16 <Cale> You can write a useful one of those.
23:45:22 <Cale> Well, define useful.
23:45:58 <startling> one which I can use to return the list of all a greater than some a
23:47:00 <Cale> Well, there's obviously a way to write that class, and for any given type, you may or may not be able to provide an instance.
23:47:14 <Cale> Which types do you need to support?
23:47:37 <startling> mostly Char and the WordXs
23:48:07 <Cale> Oh, you can assume that the Enum instances for those behave in a way which will get you all the elements :)
23:48:29 <startling> Cale: I can't enumDownFrom, though
23:48:34 <Cale> sure you can
23:48:39 <Cale> > [10,9..]
23:48:40 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,...
23:48:48 <startling> what does that desugar to?
23:48:57 <Cale> > enumFromThen 10 9
23:48:58 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,...
23:49:47 <Jafet> @src Enum
23:49:47 <lambdabot> class  Enum a   where
23:49:47 <lambdabot>     succ                     :: a -> a
23:49:47 <lambdabot>     pred                     :: a -> a
23:49:47 <lambdabot>     toEnum                   :: Int -> a
23:49:47 <lambdabot>     fromEnum                 :: a -> Int
23:49:49 <lambdabot> [3 @more lines]
23:49:54 <Jafet> @more
23:49:54 <lambdabot>     enumFrom                 :: a -> [a]
23:49:54 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
23:49:55 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
23:50:18 <Cale> There are Enum instances for Float and Double and Rational and stuff which don't capture all the elements in any meaningful way.
23:50:46 <paolino> is there ?
23:50:53 <Jafet> Well, you can enumerate Rational.
23:51:02 <paolino> ah
23:51:04 <startling> > pred (0.1 :: Float)
23:51:05 <lambdabot>   -0.9
23:51:13 <Jafet> Just not in order.
23:51:16 <Cale> But when you Enum Rational, you don't enumerate Rational :)
23:51:17 <AfC> Cale: how has hexpat-pickle been in the face of changing schema? ie, I have documents whose schema may [slowly] evolve over time. Do you have any experience of how the parser copes with ie new elements or absent elements?
23:55:04 <Cale> AfC: I didn't really try that, it will probably handle new elements fine, but if you have absent elements, your unpickler is going to produce an error.
23:57:18 <Jafet> > let succ (a,b) = (b, a`div`b*b*2-a+b) in tail $ (\x -> [x,negate`first`x]) =<< iterate succ (0,1)
23:57:19 <lambdabot>   [(0,1),(1,1),(-1,1),(1,2),(-1,2),(2,1),(-2,1),(1,3),(-1,3),(3,2),(-3,2),(2,...
23:58:45 <Cale> AfC: You should be able to try it pretty easily for some small part of your XML tree, by inventing some Haskell type to store the data, and using xpElem and friends to define a pickler or two, and then try it out on that part of the tree.
23:59:26 <Cale> http://hackage.haskell.org/packages/archive/hexpat-pickle/0.6/doc/html/Text-XML-Expat-Pickle.html -- not sure if I linked this before...
