00:00:03 <Enigmagic> Ralith: you mean like this? phi :: IsFirstClass a => [(Value a, BasicBlock)] -> CodeGenFunction r (Value a)
00:00:08 <Enigmagic> :)
00:00:21 <Ralith> johnw: that's not enough information; you need to know a value too.
00:00:25 <Ralith> (for each bb)
00:00:35 <pharaun> johnw: yeah its not working right, it slowed down big time again hmm
00:00:46 <pharaun> hmmm
00:00:49 <johnw> Ralith: the BasicBlock monad is a context for a value
00:00:54 <pharaun> actually it might be!
00:01:16 <johnw> also, the BasicBlock monad short circuits once it encounters a terminator
00:01:38 <Ralith> Enigmagic: rather. I wonder if bos would be open to me simply extending the existing LLVM interface with more codegenny stuff instead of just building another...
00:02:01 <hpaste> pharaun pasted “mmap'd with rdeepseq” at http://hpaste.org/74724
00:02:08 <Ralith> johnw: shortcircuits as in (x >>= f) == x?
00:02:10 <johnw> that way you could compose 4 of them with <*>, for exampel, and it would generate sufficiently many phiNodes to make the final BasicBlock contain the final value
00:02:16 <johnw> Ralith: yes
00:02:29 <pharaun> claiming ~17.6GiB/s
00:02:41 <johnw> is the answer right?
00:02:46 <pharaun> i benchmarked the MD4 to be around 960MiB/s
00:03:09 <Enigmagic> Ralith: i've built weaker typed functions for convienence. i don't know if you need a fully new interface to make it easier to dump out IR. e.g. https://github.com/alphaHeavy/llvm/commit/b7a95a6b83528478e09817bff5dc62965765fef6
00:03:15 <Ralith> johnw: interesting idea
00:03:33 <pharaun> johnw: comparing to a known good hash implementation
00:03:38 <johnw> i mean, SSA should be inherently composable
00:03:56 <pharaun> hmm it hashes differently
00:04:05 <pharaun> time to see why
00:05:05 <Ralith> Enigmagic: it's not the dumping out IR that's currently hard, it's the generating dynamically specified modules.
00:05:27 <Ralith> but in retrospect I suppose that extending the current interface with unsafe options would be a better idea.
00:06:02 * Ralith eyes a three hundred lines of suddenly obsoleted code 
00:06:11 <lightquake> bleh
00:06:29 <Ralith> Enigmagic: do you know if bos is open to patches adding unsafe stuff?
00:06:55 <Enigmagic> Ralith: that's what i mean. the functionality is there already, but it's fairly rigid (in part due to the fundeps) and it's hard to say it's always worthwhile
00:07:30 <Ralith> I'm not sure it counts as "there already" if you have to use crazy type-level tricks to get anywhere near 'hello world' :P
00:07:50 * Ralith recalls you trying and failing to provide an example
00:07:54 <Enigmagic> Ralith: i dunno if bos is, henning wasn't so hot on the idea... i haven't actually submitted a pull request for any unsafe functions.
00:08:31 <Ralith> does the haskell module system make it convenient to have a module exports all the same stuff as another module, plus a few new things?
00:08:39 <johnw> yes
00:08:43 <Ralith> well then
00:08:46 <johnw> import FOo
00:08:47 <johnw> Foo(..)
00:08:58 <Ralith> let's just drop it all in LLVM.Unsafe.*
00:09:02 <Ralith> that way everyone's happy
00:09:30 <Enigmagic> i didn't fail ;) it's basically unusuable due to the way FunctionArgs is specified. it looks like it should be a lot easier with the TypeFamilies patch that Lennart did a while ago
00:09:44 * Ralith doesn't follow you
00:10:07 <Ralith> oh, you mean you were unable to provide an example because it turned out to be basically impossible?
00:10:24 <johnw> can I get ghc-7.6 to use a different ~/.cabal directory?  It already uses it own sub-directory inside .ghc...
00:10:26 <Ralith> johnw: I really like your idea of composable BBs, I'll see about implementing that while I'm at it
00:10:31 <johnw> kk
00:11:04 <Ralith> Enigmagic: do I understand you correctly?
00:11:09 <Enigmagic> Ralith: it's really difficult to use, it's not impossible though. just not practical
00:11:18 * Ralith no
00:11:19 <Ralith> d
00:11:21 <Ralith> that was my impression
00:11:29 <Ralith> Enigmagic: all fixable by carefully selected unsafe additions though, yes?
00:12:04 <Enigmagic> the type family variant is much easier since only one type needs to be built up at runtime, rather than 3 (which need to follow very specific rules)
00:13:03 <Enigmagic> unsafe makes it easy but removes the compile time type checks. i think they're nice to have around... having all the type safety available when you can use it is much better than the c/c++ versions which have very little.
00:13:24 <Ralith> they are nice to have around.
00:13:31 <Ralith> but haskell isn't dependently typed, so sometimes we have to make sacrifices.
00:14:54 <Ralith> Enigmagic: has this typefamilies patch been merged? How do dynamic-arg-count functions work with it?
00:15:27 <Enigmagic> Ralith: no, it's here: http://code.haskell.org/~thielema/llvm-tf/
00:15:56 <av_> hi everyone -- I'm looking for an optical design/simulation module for haskell, is there such a thing?
00:16:09 <Ralith> Enigmagic: has it been rejected, then, or what?
00:16:32 <Enigmagic> Ralith: no, nobody is curating patches.
00:16:49 <Ralith> huh?
00:16:53 * Ralith understood that bos accepted patches.
00:17:08 <johnw> Ralith: I wonder if this is enough:
00:17:09 <johnw> instance Monad BasicBlock where return a = BasicBlock NullValue a; (BasicBlock _ a) >>= f = f a
00:17:11 <Enigmagic> Ralith: providing people prepare them and wait, yes.
00:17:33 <johnw> then: createICmp :: BasicBlock Bool
00:17:43 <johnw> where data BasicBlock a = BasicBlock Value a
00:17:54 <johnw> no, it wouldn't be Bool
00:18:04 <johnw> createICmp :: BasicBlock ()
00:18:17 <johnw> no, then you can <- to get the value
00:18:21 <johnw> can't
00:18:29 <Enigmagic> Ralith: there are quite a few different branches of the llvm package around. they're just not getting integrated back in to the main branch.
00:19:04 <Ralith> despite being submitted? :/
00:19:53 <Enigmagic> Ralith: no, there seems to be very little desire for the branch maintainers to submit pull requests.
00:20:12 * Ralith kind of confused.
00:20:14 <Enigmagic> pull requests used to sit for months (3-6?) at a time
00:20:24 <Ralith> do they no longer?
00:20:34 <Enigmagic> i'm not sure, i haven't bothered in a while
00:20:42 <mmaruseacph2> no haskell weekly news this week?
00:20:53 <Ralith> mh.
00:21:17 <Ralith> that's certainly discouraging.
00:21:58 <Enigmagic> Ralith: ultimately the maintainer needs to be active, at least responding to pull requests. it would be nice if someone was working on testing out larger changes like the TypeFamilies branch and integrating it.
00:23:02 <Enigmagic> i've personally committed to doing the type-nats port, but the necessary compiler work didn't make it into GHC 7.6.1
00:23:25 <Ralith> I thought the data kinds stuff covered that?
00:24:34 <zzzzzbogus> Where is instance Ord Int# defined?
00:24:39 <Enigmagic> nope... the library support for type-nats (type level literals) is basically there now but the type-nats solver (type level addition/multiplication) didn't make it.
00:25:16 <Ralith> oh.
00:26:10 <shachaf> Do we have type-level Ints yet?
00:26:28 <Enigmagic> shachaf: i'm pretty sure they're in 7.6.1
00:26:33 <Enigmagic> i'm still on 7.4.2 though
00:26:33 <Ralith> maybe I'll just stick with my C-in-haskell solution for now.
00:26:43 <Ralith> that one just works.
00:27:13 <shachaf> Enigmagic: Complete with undefined behavior on overflow?
00:27:23 <amosr> zzzzzbogus: isn't "instance Ord Int#" a kind error? I think you need to use '<#' '>#' instead of '<'
00:27:53 <shachaf> What amosr said.
00:27:57 <Enigmagic> shachaf: i don't think any operations that could overflow are supported yet
00:28:27 <amosr> which is GHC.Exts I think
00:29:39 <shachaf> GHC.Exts has all sorts of goodies.
00:30:07 <Enigmagic> Ralith: anyways what i was complaining about was mostly due to this type: https://github.com/bos/llvm/blob/master/LLVM/Core/CodeGen.hs#L253
00:30:32 <Ralith> kay?
00:31:53 <zzzzzbogus> amosr: I just want to find how instance Ord Int is defined. I found that Int is implemented in terms of Int#, but I couldn't see instance Ord Int
00:32:54 <shachaf> zzzzzbogus: Did you look at the implementation of instance Ord Int?
00:32:59 <shachaf> Oh, you couldn't find it.
00:33:09 <ivanm> it's probably magic!
00:33:35 * Ralith thinks about working on his own less-safe but not-horribly-overstressing-the-type-system LLVM interface
00:33:51 <shachaf> instance Ord Int64 where (I64# x#) <  (I64# y#) = x# `ltInt64#` y#
00:34:05 <zzzzzbogus> Yes I found that but it's not Int
00:34:09 <shachaf> Int is basically the same, I assume, except with a different # operator.
00:34:27 <ivanm> zzzzzbogus: IIRC, on 64bit Int = Int64
00:34:36 <johnw> that's correct
00:34:38 <zzzzzbogus> But where is that defined?
00:34:46 <johnw> GHC.Int.Int64?
00:34:50 <ivanm> some deep dark voodoo bit of GHC internals or something
00:34:56 <Enigmagic> Ralith: the type families version is much easier to deal with... rather than having a functional dependency between the edsl and the compiled function (for converting the type "Value Int -> Value Int -> IO Double" to "FunPtr (Int -> Int -> IO Double)" it can be done with a type level function instead.
00:34:58 <johnw> i remember seeing that in  type error
00:35:29 <shachaf> instance Ord Int where { compare = compareInt; (<) = ltInt; (<=) = leInt; (>=) = geInt; (>) = gtInt }
00:35:38 <shachaf> (I# x) `gtInt` (I# y) = x >#  y
00:35:54 <hpaste> killy9999 pasted “Misplaced type signature” at http://hpaste.org/74725
00:35:58 <zzzzzbogus> But where is it in sources?
00:36:12 <killy9999> Why can't I place a type signature like this?
00:36:19 <shachaf> killy9999: You can with a new GHC extension.
00:36:25 <shachaf> But in general you can't because that's not (>>=)'s type.
00:36:30 <shachaf> It's not valid Haskell.
00:36:50 <killy9999> can't I explicitly specialize type of (>>=) for a particular instance?
00:37:05 <ivanm> killy9999: with a new extension you can, as shachaf said
00:37:05 <Ralith> Enigmagic: hard to be motivated to play with that when it could easily bitrot away.
00:37:07 <shachaf> Do you expect it to have an effect or is it just for documentation?
00:37:32 <ivanm> I believe the main point is to help you ensure your new implementation of a class method is indeed valid
00:37:49 <shachaf> The type checker will tell you if it's valid.
00:38:04 <Enigmagic> Ralith: well it's certainly an issue, but we have a large codebase built on it... it's not going away anytime soon
00:38:08 <ivanm> shachaf: well, that's the reasoning I got from the docs of that extension
00:38:32 <Ralith> Enigmagic: want to put it on github and merge pull requests, then?
00:38:32 <killy9999> what's the name of this extension?
00:38:40 <shachaf> killy9999: It's new in GHC 7.6.
00:38:48 <killy9999> ok, nevermind then
00:38:52 <killy9999> I'm on 7.4.1
00:39:03 <johnw> {-# LANGUAGE ItsNewInGHC76 #-} ?
00:39:13 <killy9999> :)
00:39:41 <shachaf> johnw: Come on, ' is very valid in identifiers.
00:39:43 <Enigmagic> Ralith: i'll respond to pull requests here https://github.com/alphaHeavy/llvm
00:40:00 <johnw> I'm going to start putting {-# LANGUAGE C++ #-} at the top of my .cpp files
00:40:10 <Enigmagic> Ralith: our compiler isn't going to be open sourced, it's for a specialized language for trading
00:40:23 <hpaste> killy9999 pasted “Avoid pattern matching” at http://hpaste.org/74726
00:40:52 <Ralith> Enigmagic: I was referring to the llvm bindings--I wouldn't ask people to put their work on github out of the blue like that.
00:40:54 <killy9999> so another question
00:40:54 <zzzzzbogus> schachaf: I found instance Ord Int in http://www.haskell.org/pipermail/cvs-libraries/2011-May/013018.html but it's quite old
00:41:12 <killy9999> Why can't I avoid pattern matching like in my example?
00:41:13 <ivanm> killy9999: because it's gone from "Either String a" to "Either String b"
00:41:23 <ivanm> you need to re-apply the constructor to get the new `b' type
00:41:24 <Ralith> 'specially when you imply it's a business thing like you did :P
00:41:36 <killy9999> hm...
00:41:38 <shachaf> zzzzzbogus: The one I gave you is recent.
00:41:46 <shachaf> ghci's :i will tell you where it's defined.
00:41:48 <killy9999> so this means that I created a function with type
00:42:15 <killy9999> Either [Char] a -> (a -> Either [Char] a) -> Either [Char] a
00:42:15 <killy9999> ?
00:42:23 <ivanm> no
00:42:35 <zzzzzbogus> shachaf: but where is it in sources?
00:42:43 <shachaf> zzzzzbogus: In GHC.Classes
00:42:43 <ivanm> >>= requires "Either String a -> (a -> Either String b) -> Either String b
00:42:48 <killy9999> so what is the type of "err >>= f = err" ?
00:42:52 <killy9999> yes
00:43:04 <ivanm> but your Left case is returning an Either Stringi b
00:43:04 <killy9999> and my declaration has the type that I wrote above?
00:43:06 <ivanm> *String
00:43:11 <shachaf> killy9999: Yes, that's what it means.
00:43:15 <shachaf> killy9999: Well, except not with [Char].
00:43:22 <shachaf> Either e a -> (a -> Either e a) -> Either e a
00:43:24 <zzzzzbogus> shachaf: and how do I get it? I tried to google GHC.Classes but I found only for 6.12
00:43:27 <shachaf> You can find that out by yourself.
00:43:38 <ivanm> shachaf: oh, right, I forgot the the type of the Either monad has been generalised
00:43:52 <shachaf> @ty let foo (Right x) f = f x; foo err f = err in foo
00:43:53 <lambdabot> forall t t1. Either t t1 -> (t1 -> Either t t1) -> Either t t1
00:44:15 <shachaf> zzzzzbogus: In the same place it is in GHC 6.12
00:44:17 <Enigmagic> Ralith: :) i'll probably be doing another round of llvm work in a few months... upgrading to llvm 3.2 and trying to merge some other branches in
00:44:25 <Ralith> \o/
00:45:23 <Ralith> Enigmagic: if I end up working on this you can probably expect basic "don't explode" patches for 3.1 at minimum.
00:45:42 <Enigmagic> there are a handful of 3.1 patches in github already
00:45:55 <johnw> Enigmagic: do you work with liyang?
00:45:56 <zzzzzbogus> shachaf: GHC.Classes for 6.12 doesn't have instance Ord Int, and in the same place of latest documentation on base library there are no GHC.Classes
00:46:11 <Ralith> wonderful
00:46:23 <Ralith> hm
00:46:27 <johnw> pharaun: you ever figure it out?
00:46:35 <shachaf> zzzzzbogus: Ah, yes.
00:46:41 <Ralith> github doesn't seem to like me trying to fork two separate repos with the same ancestor.
00:46:48 <Enigmagic> johnw: no, last i checked liyang worked at tsuru
00:47:08 <johnw> so we have multiple companies here using Haskell for trading?
00:47:28 <Enigmagic> yeah
00:47:42 <shachaf> @google "ghc/classes" "instance ord int"
00:47:42 <ivanm> zzzzzbogus: why do you want to see this definition?
00:47:43 <lambdabot> http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/src/GHC-Classes.html
00:47:43 <lambdabot> Title: GHC/Classes.hs
00:47:45 <shachaf> zzzzzbogus: There you go.
00:47:50 <pharaun> johnw: i figured out why i was getting a different hash value, toChunks breaks a lazy bytestring into 32kb or so strict bytestring chunks, so i've been trying to "encourage" it to break it into 9.27MiB chunks, so far i'm breaking the lazy string into a list of lazy string, then consuming the lazy string in a hash but performance is abyssal
00:47:52 <Ralith> johnw: at least three.
00:47:55 <shachaf> ivanm: I already pasted the definition in the channel.
00:48:07 <pharaun> johnw: i can't figure out any way to *force* lazy bytestring to yield up chunks of 9.27 mib
00:48:12 <ivanm> shachaf: I saw; just wondering why he wants to see it
00:48:13 * ddarius can't trust shachaf.
00:48:19 <Ralith> unless I miscount
00:48:20 <shachaf> zzzzzbogus presumably wants to get better at finding things! Though asking in IRC is a strange way to do that.
00:48:24 <lightquake> hackage :(
00:48:28 <johnw> i thought you were using bytestring-mmap now?
00:48:33 <ivanm> ddarius: but can we trust your mistrust of shachaf?
00:48:40 <ivanm> @where hackage-mirror
00:48:40 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
00:48:41 <zzzzzbogus> schachaf: great! I was going to give up
00:48:43 <ivanm> lightquake: ^^
00:48:51 <johnw> and have you looked at Data.ByteString.Lazy.Internal?
00:48:53 <lightquake> no i know
00:48:54 <pharaun> johnw: my problem is basically - bytestring-mmap gives me a bytestring or a lazy bytestring interface
00:49:09 <johnw> well, use the strict one
00:49:09 <lightquake> ... wow, lens is up to 2.9?
00:49:13 <pharaun> johnw: yeah i've been looking at it looks like only solution i can see is to take the whole bytestring and alter the code and recompile it
00:49:19 <lightquake> what the hell is edwardk doing?
00:49:22 <lightquake> :P
00:49:27 <pharaun> johnw: yeah i'm going to try the strict one now
00:49:44 <osa1> do we have a list of ICFP 2012 videos or do I have to search manually in youtube ?
00:50:12 <shachaf> osa1: haskell.reddit.com has a link.
00:50:41 <johnw> pharaun: I have a parser based on lazy bytestrings that gets 1GB/s
00:50:51 <johnw> that's reading from a RAM disk
00:51:05 <pharaun> johnw: i was able to get 17GiB/s but it was doing the hashes in wrong chunks it was doing the hash in 32kb chunks
00:51:19 <shachaf> ddarius: So when are you coming to the correct coast?
00:51:20 <osa1> shachaf: do you mean on right panel ? I can't find it
00:51:30 <shachaf> osa1: No, on the main page. :-)
00:51:30 <johnw> doctest's cabal configuratino is so broken
00:51:37 <johnw> i wonder how the author is able to install it
00:51:45 <johnw> I can never "cabal install" it
00:51:48 <pharaun> i really don't want to have to hack the source of bytestring
00:52:02 <johnw> try a strict bytestring-mmap
00:52:04 <osa1> shachaf: oh malcolm wallace link, got it. thanks
00:52:11 <pharaun> johnw: just did, performance is still abyssal
00:52:19 <johnw> you mean abysmal?
00:52:22 <pharaun> only way i can get performance to stay high is to use - toChunks
00:52:27 <johnw> abyssal would be very, very deep :)
00:52:30 <pharaun> which then toss it into 32kb strict string chunks
00:52:37 <Ralith> deep performance, hm?
00:52:42 <pharaun> johnw: its where my computer will end up soon? :)
00:52:46 <pharaun> in the abyss
00:52:51 <pharaun> but yeah i mean abysmal
00:53:12 <johnw> fork bytestring :)
00:53:45 <johnw> or, write a recursive function to hRead the file into 9 mb chunks
00:53:53 <johnw> that should work just fine
00:54:09 <pharaun> hRead? hmm
00:54:14 <johnw> FilePath -> [ByteString]
00:54:19 <pharaun> just would like it in a parallel manner
00:54:21 <johnw> then a <- readFileIntoChunks
00:54:22 <pharaun> but yeah looking
00:54:24 <johnw> then parallel map over a
00:54:28 <pharaun> aha!
00:54:53 <johnw> the parMap will consume the chunks as fast as it needs them
00:55:25 <shachaf> Hey, cmccann is alive.
00:55:32 <liyang> For reading I've always had the best performance from bytestring-mmap.
00:55:46 <pharaun> liyang: this is bytestring-mmap
00:55:56 <pharaun> but the 32kb chunks of lazy bytestring is screwing me
00:56:02 <shachaf> liyang: bytestring-mmap is presumably incompatible with the GHC IO manager. :-(
00:56:18 <pharaun> and any attempts to fix/reformat it ends up with the performance being abysmal
00:56:45 <johnw> why can you using strict bytestring-mmap, and recursively splitAt thorugh the file?
00:56:58 <pharaun> johnw: that is what i tried
00:57:01 <johnw> that should be roughly equivalent to a lazy bystrings at "chunk" size
00:57:02 <johnw> oh
00:57:03 <isomorphic> Hey - I have a UTCTime (from getCurrentTime) that I'd like to turn into HTML using blaze, which means getting it to be a string first.   Can anybody suggest a more elegant way than show <$> liftIO getCurrentTime
00:57:09 <pharaun> johnw: both lazy and strict
00:57:15 <pharaun> the strict one is still slow
00:57:19 <johnw> how slow was abysmal?
00:57:25 <johnw> and how does memory consumption look?
00:57:26 <pharaun> minutes on a 6mb file?
00:57:28 <liyang> abysmally.
00:57:34 <johnw> oh wow
00:57:39 <pharaun> i don't know what the deal is
00:57:43 <shachaf> isomorphic: Data.Time.Format?
00:57:52 <johnw> yeah, I'd figure that one out first
00:58:13 <isomorphic> shachaf: Thanks :)
00:58:14 <johnw> minutes on a 6mb file indicates something else is very wrong
00:58:24 <pharaun> johnw: just like conduit :)
00:58:28 <pharaun> minutes on small files
00:59:06 <liyang> I'd suspect the problem is elsewhere…
00:59:07 <killy9999> how do I unload a module in ghci ?
00:59:17 <Cale> killy9999: :m - ModuleName
00:59:48 <killy9999> Cale: doesn't seem to work :/
00:59:58 <killy9999> I need to unload a module that I've written
01:00:03 <killy9999> and loaded using :load
01:00:13 <killy9999> not the modules loaded with :m + ModuleName
01:00:26 <Cale> ah
01:00:54 <sopvop> Is there a tool to find unused exports?
01:01:07 <Nereid> killy9999: just :l
01:01:36 <Cale> I've never had to do that
01:01:37 <killy9999> Nereid: thanks
01:01:41 <fmap> sopvop: unused exports?
01:01:42 <Nereid> but yeah, why
01:01:43 <Nereid> :v
01:01:57 <Cale> If I did, I'd probably just ctrl-C and type ghci again :P
01:02:07 <killy9999> I've declared my own instances of stuff that is already defined in some packages
01:02:10 <killy9999> just for learning
01:02:12 <Cale> er, ctrl-D rather
01:02:24 <killy9999> now I need to unload mine and load the real ones
01:02:39 <killy9999> Cale: that's not the proper way to do it ;)
01:02:51 <Cale> I don't even use :l
01:02:57 <sopvop> Well, unused function exported from some modules. Like here you go my main function, now look through imports which come from this directory and tell me what I can safely delete :)
01:03:00 <Cale> to load the files in the first place :)
01:03:05 <deggis> having qualified in ghci is sometimes great
01:03:25 <killy9999> but not always comfortable
01:03:57 <Cale> I also put all my definitions into a file, and only put expressions into ghci
01:04:14 <Cale> (because that's all that ghci would accept for many years :)
01:05:04 <fmap> sopvop: i don't think this makes sense: anybody can import anything you've exported, that's the purpose of exports
01:05:15 <killy9999> I guess I'm using ghci as a REPL environment
01:05:24 <killy9999> and that requires loading modules ;)
01:05:35 <Cale> Yeah, that's what I use it as: a read *eval* print loop
01:05:51 <Cale> Only evaluation, no definitions :)
01:06:19 <Cale> (Of course, in some languages, this distinction is blurred)
01:06:22 <sopvop> fmap: In my case I just want to kill unused code from my project. So this "anybody" is only me.
01:06:28 <killy9999> hm... when I do ":i Either" I get answers like "instance [safe] Monad (Either e)". What does [safe] mean?
01:06:30 <flux> btw, ocaml REPL supports definitions as well.. ;-)
01:07:10 <Nereid> killy9999: huh? I don't get that.
01:07:21 <killy9999> I do
01:07:27 <Nereid> never seen it.
01:07:47 <merijn> I suspect something related to SafeHaskell?
01:07:52 <hpaste> killy9999 pasted “[safe] in instance declarations?” at http://hpaste.org/74727
01:08:04 <Cale> Nereid: import Control.Monad.Instances
01:08:12 <Cale> (and be on one of the recent GHCs)
01:08:27 <killy9999> Cale: yep, that's my case
01:08:27 <Cale> (7.4.1 seems new enough)
01:08:33 <killy9999> so what does it mean?
01:08:46 <Cale> Yes, I bet it has something to do with safe Haskell.
01:08:46 <Nereid> 7.6.1 here, and I don't see it still
01:08:46 <pharaun>   Alloc rate    18,446,744,068,372,894,726 bytes per MUT second
01:08:55 <pharaun> that does not seem right :)
01:08:56 <johnw> lol
01:09:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html
01:09:06 <sopvop> http://hackage.haskell.org/packages/hackage.html timeouts. Is it dead?
01:09:18 <pharaun> johnw: yeah its in the getChunks function
01:09:19 <johnw> that's 2^64-1
01:09:19 <Cale> pharaun: that's one hell of an alloc rate
01:09:20 <Hadaka> how recent is forkFinally? is it not present in ghc 7.4.1?
01:09:24 <pharaun> Cale: haha yes i know
01:09:38 <johnw> well, close to it
01:09:45 <johnw> > 2^64
01:09:46 <lambdabot>   18446744073709551616
01:09:53 <hpaste> pharaun pasted “getChunks” at http://hpaste.org/74728
01:10:04 <merijn> Hadaka: Doesn't show up on Hoogle, where did you read about it?
01:10:17 <Hadaka> merijn: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
01:10:19 <Cale> > 18446744068372894726 - 2^64
01:10:20 <lambdabot>   -5336656890
01:10:44 <pharaun> so i'm allocing at 18 extabytes a sec?
01:10:44 <zzzzzbogus> hadaka: http://www.haskell.org/pipermail/cvs-libraries/2012-June/015662.html
01:11:10 <merijn> Hadaka: Man...now I really want forkFinally...
01:11:20 <johnw> 64-bit only express 18 exabytes?
01:11:29 <johnw> man, I can see that limit being exceeded pretty soon
01:11:32 <Hadaka> zzzzzbogus: okay, pretty recent :-)
01:11:36 <pharaun> johnw: haha
01:11:41 <johnw> i'm not kidding
01:11:50 <johnw> there are already petabyte data clusters
01:11:54 <pharaun> oh i know
01:12:23 <killy9999> I don't undestand that Safe Haskell
01:12:25 <Hadaka> forkFinally action and_then = mask $ \restore -> forkIO $ try (restore action) >>= and_then
01:12:31 <johnw> every ten years my hard drive is about 1000 times larger
01:12:34 <Cale> Some would say 16 exabytes, but they wouldn't be SI compliant
01:12:58 <pharaun> well we're not going to hit 18exabyte of ram anytime soon
01:13:10 <pharaun> and disk subsystem have LBA's for a while plus block sizes
01:13:22 <Nereid> 32-bit systems didn't have any problem accessing disks larger than 4GB :)
01:13:36 <Cale> heh, there was a kid in #math who was worried we were going to run out of SI prefixes
01:13:45 <johnw> Nereid: that is true
01:13:49 <pharaun> the LBA at some point was 48 bit or so i forgot
01:13:55 <johnw> and my ZFS system is supposed to have a ludicrous upper limit
01:14:08 <pharaun> anyway um i'm kind of trying to figure out how the hell i'm allocating 18exabyte with that getchunks
01:14:12 <pharaun> http://hpaste.org/74728
01:14:16 <pharaun> boggles my mind
01:14:23 <pharaun> so i must be missing something
01:14:26 <merijn> johnw: ZFS uses 128bit address space
01:14:33 <johnw> yeah
01:14:47 <pharaun> not going to run out of 128bits anytime soon :)
01:15:12 <mux> pharaun: it still is
01:15:33 <johnw> ooh, I like Safe Haskell
01:15:39 <johnw> i'm going to start using this
01:15:43 <pharaun> mux: oh it is still 48bit figures :)
01:15:52 <mux> yep
01:16:06 <johnw> pharaun: rseq isn't strict enough
01:16:13 <johnw> pharaun: rdeepseq
01:16:38 <killy9999> johnw: I skimmed the doc and I don't seem to understand what new does Safe Haskell add
01:16:44 <johnw> rseq will force the call to MD4, but I don't think it will force evaluation of its contents
01:16:48 <killy9999> except for blocking unsafePerformIO
01:16:55 <johnw> killy9999: that's what it adds
01:17:02 <pharaun> a moment, put rdeepseq on it, and its still.... uh allocating at 18exabytes speed
01:17:20 <johnw> no "behind the scenes" violations of purity, the way you can do now
01:17:35 <johnw> per second, no less!
01:18:03 <Nereid> can't you still break everything with GeneralizedNewtypeDeriving or so
01:18:30 <hpaste> pharaun pasted “heh check out this horrible profiler run” at http://hpaste.org/74731
01:18:36 <killy9999> johnw: and that's all?
01:18:42 <Cale> Nereid: I think it's not safe
01:18:49 <Cale> killy9999: unsafeCoerce as well
01:18:50 <johnw> killy9999: http://www.slideshare.net/dterei/safe-haskell
01:18:53 <Nereid> what's not safe
01:19:10 <Cale> GNTD
01:19:14 <Nereid> of course it isn't.
01:19:17 <johnw> Nereid: you can't use GNTD
01:19:25 <pharaun> isn't that disallowed... oh ^
01:19:25 <Nereid> oh.
01:19:37 <Nereid> yeah I was looking at the page and I just now saw that.
01:19:43 <pharaun> johnw: i like how i have -25% productivity
01:20:51 <zzzzzbogus> slide 11
01:21:24 <mysticc> @hoogle catchIO
01:21:24 <lambdabot> Network.HTTP.Base catchIO :: IO a -> (IOException -> IO a) -> IO a
01:21:24 <lambdabot> Network.HTTP.Base catchIO_ :: IO a -> IO a -> IO a
01:21:24 <lambdabot> package MonadCatchIO-mtl
01:21:32 <mysticc> @hoogle tryE
01:21:32 <lambdabot> No results found
01:21:50 <pharaun> hackage is up btw i think
01:22:26 <johnw> lambdabot should have an @dfe command, for downforeveryoneorjustme.com
01:23:20 <Twey> Not strictly Haskell, but: could anybody explain to me the concept of a ‘neutral term’ in ‘A tutorial implementation of a dependently typed lambda calculus’?
01:23:30 <pharaun> johnw: i think i'm going to toss this one into the trashbin for now and try out the hRead approach
01:23:36 <johnw> k
01:23:43 <johnw> sorry it didn't work
01:23:54 <johnw> hackage still down fro me
01:24:12 <pharaun> johnw: its np, i mean i probably could have made the lazy bytestring one work if i forked the bytestring source :)
01:24:21 <pharaun> but yeah
01:24:39 <pharaun> :\ hackage stopped working for me again
01:24:44 <Cale> Twey: The paper defines it, I think.
01:25:57 <Cale> Twey: A value is either a lambda or a neutral term, and a neutral term is either a variable, or an application of a neutral term to a value.
01:26:32 * Ralith gives up on git for the night and sleeps
01:27:10 <johnw> what did Git do?
01:29:03 <Twey> Cale: I read the explanation, I just don't understand the perpose of it — don't the Term_↑ constructors for free variables & application already cover that?
01:29:09 <Twey> Oh!
01:29:11 <Twey> I'm an idiot
01:29:28 <Twey> (and not just for writing ‘perpose’)
01:30:27 <Twey> Neutrals are values that will be left ultimately unevaluated in the Value output, right?
01:31:35 <Cale> yeah
01:31:58 <Cale> Well, they're the results of evaluation, along with lambdas
01:32:59 <Ralith> johnw: taught me that I'm not nearly as good at branches as I should be.
01:33:32 <Ralith> I'm trying to shove all my wrapper work in a side branch on a fork of Enigmagic's repo
01:33:42 <Twey> *nod* I get it now.  Thanks.
01:33:55 <Twey> I was mixing up terms & values
01:34:25 <Ralith> I can visualize the resulting graph but I can't get git to accept it
01:34:34 <Ralith> and I need to get up in time for lecture tomorrow anyway
01:35:34 <Ralith> it doesn't help that github isn't letting me fork Enigmagic's repo...
01:37:15 <johnw> :(
01:38:45 * Ralith has a few ideas, but they are better tried when well rested.
01:39:22 <Hadaka> question about synchronous exceptions masked - what all are asynchronous exceptions that I need to care about? I get throwTo, but I don't use that in my code - what uses throwTo internally? does pressing Ctrl-C cause an asynchronous exception? internal errors? etc.
01:41:22 <akamaus> is there a way to set the history size of ghci?
01:43:14 <Twey> Hadaka: I don't think anything in the standard library uses asynchronous exceptions
01:43:24 <jdnavarro> is there any hackage mirror with the documentation?
01:44:15 <Twey> Libraries rarely use threads in the first place; usually you need to know the structure of an application before you can make it concurrent appropriately, so it's left up to the user to communicate exceptions (and other things) between threads
01:44:36 <Twey> There are a couple of exceptions that are more like ‘frameworks’ than libraries, such as Gtk2Hs
01:45:35 <Twey> Unlike Java, Haskell uses only one thread by default; if you want more threads you need to create them
01:47:55 <Hadaka> Twey: thanks!
01:48:21 <Hadaka> Twey: I do have threads in my program, I just don't need throwTo
01:52:39 <Twey> Hadaka: Then don't use it ☺
01:58:08 <Hadaka> Twey: the point of my question was rather that do I need things like forkFinally or can I just ignore them as I probably won't get any asynchronous exceptions - and I'm guessing from your answer that I can just ignore forkFinally and exception masking in general
02:00:02 <Twey> Hadaka: It depends what you're writing.  Are you expecting your code to be run in a thread in someone else's application at some point in the future?  Or, more specifically, are you expecting *someone else's* code to be run in your thread in the future?
02:01:11 <Twey> Ooh, Hackage is down :-\
02:02:31 <Hadaka> Twey: nobody will use my code, but I stuff like http conduit and other complex pieces of machinery
02:03:42 <typoclass> Twey: yes, down for me as well :(
02:05:42 <rfw> @pl \(x, y) -> x + y)
02:05:42 <lambdabot> (line 1, column 17):
02:05:42 <lambdabot> unexpected ")"
02:05:42 <lambdabot> expecting letter or digit, variable, "(", operator, "+", "-" or end of input
02:05:44 <rfw> @pl \(x, y) -> x + y
02:05:44 <lambdabot> uncurry (+)
02:05:57 <Twey> Hadaka: Pretty sure http-conduit doesn't use threads at all.
02:09:14 <Hadaka> Twey: yeah, I know - I also doubt any of the other libraries I use would throw an exception to the calling thread...
02:09:28 <Twey> It's quite unlikely.
02:13:17 <byorgey> @tell MagneticD yes, it's easy to get a diagram in a gtk2hs program using the cairo backend.  The backend returns both an IO action to generate a file *and* an action in the cairo Render monad.  Ignore the IO and send the Render action to a gtk2hs window.
02:13:17 <lambdabot> Consider it noted.
02:13:35 <edwardk> @remember ddarius  edwardk: So your plan for Haskell adoption is to write Haskell in languages that aren't Haskell, say "Man, these languages suck, this would be super easy in Haskell", and then use the Haskell you started with reproducing functionality at an "unbelievable" rate.
02:13:35 <lambdabot> I will remember.
02:14:55 <akamaus> can anyone help with basic Template Haskell? I'm trying to build a value of Exp type which denotes a trivial data type declaration, like data A = A {w :: Word32} . I can't figure out how to specify a "Word32", I tried creating it using newName "Word32", but compiler complains, saying "The exact Name `Word32_a4Ig' is not in scope"
02:15:46 <byorgey> akamaus: try quoting it, like ''Word32
02:15:52 <edwardk> akamaus: use conT ''Word32
02:15:52 <byorgey> I think it's two quotes for type names
02:15:55 <jfischoff_> akamus: and import Data.Word into scope
02:16:13 <edwardk> two quotes is right
02:16:18 * byorgey waves hello from the Haskell Implementor's Workshop!
02:16:31 <edwardk> nice
02:16:41 <edwardk> so is it confirmed there that next year is boston?
02:16:42 <akamaus> can you explain this qouting a bit? It reminds me quotation in Lisp macros
02:16:44 * jfischoff_ waves too
02:16:48 <byorgey> edwardk: yep!
02:16:54 <edwardk> woot. =)
02:17:00 <Twey> akamaus: That's what it is
02:17:01 <byorgey> sometime mid-September, the dates aren't fixed yet
02:17:12 <edwardk> i knew if i waited enough you'd just bring ICFP to me
02:17:19 <byorgey> haha
02:17:37 <Spockz> hmm hack age is down? :(
02:17:43 <byorgey> yes, the organizer actually said "we decided to have ICFP in Boston because edwardk is there"
02:17:46 <byorgey> ;)
02:17:46 <shachaf> ICFP will be in Boston next year?
02:17:50 <byorgey> shachaf: yes
02:17:53 <edwardk> clearly my long string of ICFP-non-attendance was a factor in the location choice.
02:18:06 <edwardk> shachaf: another reason for you to move here =)
02:18:18 <Twey> akamaus: ''Type is just shorthand for a quoted representation of Type
02:18:22 <byorgey> Spockz: yes, it appears so =(
02:18:24 <paolino> is there a way to reinstall all the packages in the right order so that I have local docs interlinked ?
02:18:35 <Spockz> byorgey: that's sad :( :P
02:18:43 <Spockz> now cabal install is stuck
02:18:48 <edwardk> Spockz: you do know the workarounds right?
02:18:52 <Twey> Spockz: Hackage is down
02:18:56 <byorgey> Spockz: there are mirrors
02:19:05 <edwardk> http://comonad.com/reader/2012/hackage-mirror/
02:19:06 <Spockz> edwardk, byorgey : where are the mirrors?
02:19:14 <akamaus> Twey, ok. What's the equivalent of 'Char then?
02:19:31 <shachaf> edwardk: What would I do in Boston?
02:19:36 <shachaf> Other than attend ICFP, I mean.
02:19:45 <shachaf> I'm sure even that gets tiresome after a while.
02:19:53 <akamaus> btw, quotation indeed worked for me :)
02:19:55 <Twey> akamaus: Also a Lisp quotation.  They just produce different types.
02:20:07 <byorgey> shachaf: feed the ducks, perhaps
02:20:13 <Twey> Actually, that's a lie
02:20:14 <byorgey> shachaf: or go on historical tours
02:20:16 <edwardk> shachaf: well, eventually they'd kind of shut down the show so i guess it makes sense to come up with a backup plan.
02:20:17 <typoclass> *feed the duck types
02:20:24 <Twey> They just check different namespaces.  They both produce a Name.
02:20:37 <shachaf> I thought Boston was a place where they run ICFP year-round!
02:20:42 * shachaf is disillusioned.
02:20:49 <edwardk> shachaf: clearly you should take a job with ddarius or me =P
02:21:03 <Twey> akamaus: 'Foo is for quoting the value namespace; ''Foo is for the type namespace
02:21:04 <paolino> (mirrors has no docs online)
02:21:10 <Spockz> shachaf: its in Copenhagen now :)
02:21:24 <edwardk> shachaf: we _do_ at least run boston haskell year round.
02:21:33 <shachaf> edwardk: But ddarius is moving to the west coast (I hear)!
02:21:36 <akamaus> but  why newName "Word32" didn't work but ''Word32 did? What's the difference
02:21:36 <edwardk> so you can just camp out in the MIT CSAIL reading room for the duration.
02:21:37 <akamaus> ?
02:21:39 <Spockz> edwardk: is that something like Boston Legal? :)
02:22:06 <byorgey> akamaus: because internally, names get resolved to something more complicated
02:22:22 <byorgey> akamaus: the real name of Word32, internally, is something like Data.Word.Word32 etc.
02:22:24 <Twey> akamaus: newName *creates* a new name, whereas quoting gets one that already exists.
02:22:29 <Spockz> so this is why I want a 8Ghz octacore machine, recompiling a lot of packages.
02:22:51 <edwardk> Spockz: well, we do hold Boston Haskell a couple of blocks from Boston's Legal Seafood. Does that count?
02:22:52 <Cale> ghci> :t ''Word32
02:22:52 <Cale> ''Word32 :: Language.Haskell.TH.Syntax.Name
02:22:52 <Cale> ghci> :t "Word32"
02:22:52 <Cale> "Word32" :: [Char]
02:23:01 <byorgey> oh, yes, what Twey said is the real reason
02:23:05 <shachaf> edwardk: Since that's the only place I've ever seen y'all, I tend to imagine that that's where you are year-round.
02:23:17 <Cale> oh, I see what you mean
02:23:20 <byorgey> there's also a function like "makeName" or "mkName" or something like that which you could get to work, if you knew the correct full name to use
02:23:23 <Twey> akamaus: They might have the same ‘name’ as something in your program, but they're not actually the same thing
02:23:43 <edwardk> shachaf: well if he's moving to the west coast then, clearly there would be an opening out here ;)
02:24:13 <akamaus> Cale, I tried creating newName "GHC.Word.Word32" at first
02:24:36 <pharaun> silly question, how hard is it to get GTK to compile for haskell
02:24:39 <edwardk> byorgey: the issue with mkName is it relies on the names in scope at the template haskell splice site. so the end user needs to have import Data.Word.Word32
02:24:55 <Cale> akamaus: Right, newName makes a new name that's not already taken by something.
02:24:59 <byorgey> edwardk: ah, interesting
02:25:06 <edwardk> it is invariably safer to use the '' technique to quote a name with known provenance
02:25:11 <byorgey> good to know.
02:25:27 <edwardk> and it results in template haskell that people complain about less
02:25:29 <akamaus> Cale, oh, sure! :)
02:25:39 <edwardk> i learned this the hard way from 'lens'. Peaker showed me the error of my ways
02:26:28 <akamaus> another questing then. I'm building this: data A = A { w :: Word32}. Should I create two different new names for "A" or one would be enough?
02:26:34 <jfischoff_> the Aeson TH code is a good example to learn from I've found.
02:27:03 <jfischoff_> first place I saw the single quote for expression names
02:27:57 <akamaus> jfischoff_, would look at it, thanks :)
02:29:07 <jfischoff_> akamaus: one is enough, but you refer to the type as ''A and the constructor name as 'A
02:29:16 <merijn> edwardk: btw, did you ever manage to find what was causing the name shadowing when using makeLensesFor?
02:29:31 <edwardk> yes
02:29:35 <edwardk> its fixed in 2.9
02:29:59 <edwardk> it was fairly painful to fix too =P
02:33:18 <edwardk> and i don't remember who it was who wanted it to generate the lenses inside of the class, when using makeClassy to make nicer exports but i put that fix in too
02:33:20 <akamaus> jfischoff_, wow, I tried one new name and got ghc.7.6.1 panic :)
02:33:32 <edwardk> not sure if it was it you or latro`a or someone else?
02:34:43 <jfischoff_> akamaus: :o
02:40:00 <merijn> edwardk: \o/ I'll upgrade to 2.9 and test is later this afternoon :)
02:41:21 <edwardk> merijn: please let me know if you still have an issue
02:42:51 <edwardk> can some folks try installing https://github.com/rounded and let me know what happens?
02:42:55 <edwardk> er
02:43:00 <edwardk> https://github.com/ekmett/rounded.git
02:43:43 <edwardk> ideally you should be able to :m + Numeric.Rounded      and then use things like pi :: Rounded TowardZero Double
02:44:07 <edwardk> but i'd really like to know what platforms the build breaks on
02:46:21 <ghorn> well right now cabal's down, want me to install tagged from your github too?
02:46:37 <akamaus> Now I'm trying to splice values into my expression, can't make this to work: http://hpaste.org/74735
02:46:39 <ghorn> i mean hackage is down
02:46:54 <typoclass> where is that mirror again? (could someone put it in the topic?)
02:47:01 <shachaf> @where hackage-mirror
02:47:01 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
02:47:09 <typoclass> oh thanks
02:47:17 <edwardk> ghorn: if you follow the instructions from http:/comonad.com/ they tell you how to flip over to luite's mirror
02:47:57 <ghorn> __thank you__
02:48:23 <byorgey> akamaus: what error do you get?
02:48:51 <akamaus> byorgey, parse error in constructor in data/newtype declaration: $to {field1 :: Word32}
02:48:51 <benmachine> man, I never realised pigworker was Conor McBride
02:48:52 <benmachine> oh well
02:49:25 <byorgey> akamaus: hmm, I think you can't splice in names like that
02:49:54 <akamaus> byorgey, any ideas?
02:50:33 <byorgey> I think you can only splice in expressions, declarations, or patterns
02:50:42 <byorgey> not individual names which aren't actually expressions
02:51:56 <edwardk> ghorn: oh i should have mentioned that will only install with ghc 7.6.1
02:51:57 <akamaus> byorgey,  well.. So I should either build an expression myself or customize one returned by quasy quoter?
02:51:57 <byorgey> akamaus: I don't know, I have run into this in the past too, and I ended up having to create AST nodes manually =(
02:52:07 <byorgey> there ought to be a better way but I don't know what it is
02:52:26 <akamaus> not too good for readability...
02:53:32 <akamaus> byorgey, seems you're right http://stackoverflow.com/questions/7563092/data-constructor-in-template-haskell
02:54:23 <byorgey> akamaus: ah, yep, exactly the same issue
02:54:45 <byorgey> akamaus: I wonder if there's a deep reason for this or if it's just because no one's implemented it
02:54:50 <akamaus> what a nasty limitation :(
02:55:04 <byorgey> maybe I can ask SPJ, he is sitting 10 feet away from me =)
02:55:12 <byorgey> and he was just talking about a planned overhaul of TH
02:55:17 <akamaus> wow! Lucky you
02:55:24 <ghorn> edwardk: i get set_f.c: In function 'mpfr_set_f':
02:55:24 <ghorn> set_f.c:27:1: internal compiler error: Segmentation fault
02:55:34 <jfischoff_> byorgey: ask!
02:55:50 <byorgey> jfischoff_: I should probably wait until dcoutts finishes his talk at least =)
02:55:57 <mercury^> rwbarton: Hey, do you know if the infinity category of G-spectra is equivalent to the infinity category of excisive and reduced functors from the infinity category of finite G-CW-complexes to the infinity category of spaces?
02:56:13 <jfischoff_> byorgey: :)
02:56:17 <byorgey> jfischoff_: are you still around?  or did you leave already?
02:56:25 <akamaus> byorgey, we're waiting with you :)
02:56:36 <jfischoff_> byorgey: I'm like 15 feet behind you
02:56:44 <byorgey> jfischoff_: hehe, ok =)
02:58:23 <ghorn> edwardk: apparently a known bug http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=670164
03:00:40 <jfischoff_> byorgey: Another good questions would be to find out if holes are going to let us query the expected types of splices (Mu Haskell already has this ability so I hear).
03:01:04 <edwardk> ghorn: hrmm
03:01:24 <edwardk> ghorn: i'll work with copumpkin to see if updating to 3.1.1 fixes that
03:01:38 <byorgey> jfischoff_: what's Mu Haskell?
03:02:36 <jfischoff_> byorgey: its a version of Haskell in use at Standard Charter that Lennart Augustsson made.
03:02:45 <byorgey> ah, I see
03:04:52 <ghorn> edwardk: i see a report that says compiling with -O2 instead of -O3 might make it go away as well, though you don't seem to be setting -O3 anywhere
03:05:43 <edwardk> ghorn: i just use     runOrBomb "sh" ["configure", "--prefix=" ++ distDir]
03:05:47 <edwardk> nothing fancy
03:07:43 <watermind> Ok so I understand that if we add coproducts and fixpoints to lambda-calculus then the domain of interpretation becomes inconsistent. Which explains why in languages like Haskell type sums are weak coproducts. But on the other hand we have the curry howard isomorphism...
03:08:20 <watermind> and in intuitionistic logic we have OR... and my understanding is that OR works as a (strong) coproduct
03:09:00 <watermind> but if that were true that means we could just take coproducts in the language to be this OR ...
03:09:15 <watermind> so, there's something wrong in that reasoning
03:09:38 <watermind> is it my assertion that OR corresponds to coproducts ?
03:09:44 <watermind> or something else?
03:14:20 <daniel_-> sigh, hackage :(
03:15:10 <shachaf> @where hackage-mirror
03:15:10 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
03:15:48 <edwardk> daniel_-: read http://comonad.com/
03:16:04 <ghorn> is there something like "instance (Traversable f, Traversable g) => Traversable (Compose f g)" ?
03:16:30 <daniel_-> im not interested in the actual packages, but the actual haddock docs.
03:17:05 <t7> hackage down?
03:17:13 <merijn> t7: Seems so, I can't run cabal update
03:17:38 <t7> i need to donate
03:17:42 <t7> before i moan
03:17:44 <iosonofabio> hello, I am a new haskell user and would have a short question, has anybody a minute?
03:17:53 <daniel_-> ask away
03:18:05 <shachaf> iosonofabio: Only if you ask your question.
03:18:19 <iosonofabio> I am doing scientific programming and need to approximate float numbers to x decimals
03:18:37 <ghorn> daniel_: i'm using my local docs in ~/.cabal/share/doc/index.html but that only works if you install everything with documentation
03:18:51 <iosonofabio> e.g. 2.476 --> 2.5, 2.426 --> 2.4
03:19:17 <iosonofabio> I come to haskell from Python, in which there is the numpy.round function
03:19:29 <iosonofabio> is there anything like that in haskell?
03:20:08 <mikeplus64> > round 4.56 :: Int
03:20:09 <lambdabot>   5
03:20:23 <iosonofabio> that is limiting
03:20:27 <mikeplus64> > (round (4.56*10) :: Int)/10
03:20:28 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
03:20:28 <lambdabot>    arising from a use o...
03:20:38 <mikeplus64> > fromIntegral (round (4.56*10) :: Int)/10
03:20:39 <lambdabot>   4.6
03:20:58 <shachaf> Numeric.showFFloat
03:22:09 <liyang> You can print a floating point number to n decimal places with Text.Printf.printf or Numeric.showFFloat, but if you actually want to round the number itself (assuming this is really what you want to do), you can define a small helper along the lines of what mikeplus64 just said.
03:23:03 <donri> is this relevant? https://github.com/ekmett/rounded
03:23:03 <mikeplus64> > showFFloat (Just 1) 1.10 ""
03:23:04 <lambdabot>   "1.1"
03:23:09 <mikeplus64> > showFFloat (Just 1) 1.105 ""
03:23:10 <lambdabot>   "1.1"
03:23:21 <mikeplus64> > showFFloat (Just 1) 1.19 ""
03:23:22 <lambdabot>   "1.2"
03:23:49 <t7> i thought there was a sigfig (or something) function in the platform
03:24:41 <iosonofabio> ok, showFFloat seems to be working, the other solution being cumbersome but valid
03:25:00 <iosonofabio> thanks... mikeplus64++
03:25:31 <donri> iosonofabio: do you just want to print the number to a string with some precision?
03:26:30 <iosonofabio> donri: yes, that's the idea
03:27:07 <donri> ah, then yes. printf/showFFloat or a package like text-format
03:27:52 <iosonofabio> printf does not round correctly, as far as I know, i.e. 1.6 --> 1
03:28:38 <shachaf> Haskell's printf uses showFFloat.
03:28:46 <shachaf> > printf "%.1f" 1.19 :: String
03:28:48 <lambdabot>   "1.2"
03:28:53 <iosonofabio> indeed
03:29:29 <iosonofabio> I got it to work, after some minutes of panic with ShowS instances... :-) thanks all!
03:32:09 <t7> is there a hackage mirror anywhere?
03:32:35 <paolino> @where mirror
03:32:36 <lambdabot> I know nothing about mirror.
03:32:59 <t7> hackage.haskell.org/package/Top :D
03:33:07 <t7> thanks luite
03:33:16 <t7> http://hdiff.luite.com/packages/archive/ i mean that
03:35:08 <Spockz> luite: can we run your mirror somewhere else as well? (Locally for example)
03:48:42 <merijn> For custom Read instances I usually use Text.ParserCombinators.ReadP but then I have to end up lifting every function from there into ReadPrec
03:48:51 <merijn> Is there a better way of going about this?
03:51:38 <jamy23> Any body want join to developing OS on haskell?
03:52:21 <merijn> jamy23: That will be very complicated
03:52:34 <merijn> jamy23: For many different reasons, including memory management and bootstrapping
03:53:08 <flux> there is hOp and House, it can be done :)
03:53:11 <merijn> jamy23: However, if you are really interested, you might want to look at House, HaLVM and Habit
03:53:59 <merijn> jamy23: House is a bare metal haskell runtime, HaLVM is the Haskell Lightweight Virtual Machine for running haskell applications in Xen virtual machines
03:54:12 <merijn> jamy23: Habit is a dialect of haskell aimed at systems programming
03:55:33 <shachaf> Hah, augustss started the "ban n+k patterns" movement in 1993.
03:57:36 <merijn> I forgot which version of catch I want for IO Error's and with Hackage I can't use Hoogle documentation links
03:58:51 <jamy23> its easy! i see house sources they very descriptive. I never see so clean code, without hooks and hacks
03:59:26 <jamy23> Belive me! I know many os underhood
04:03:12 <jamy23> Are you chickened?
04:04:56 <jamy23> 50% of needed code allready in the hackage
04:06:48 <merijn> hmm, GHC complains I need ScopedTypeVariables for "\(_ :: IOError) -> return ()"?
04:06:54 <siml1> hi. i already found a mirror for cabal. but is there also a mirror for the doc-files?
04:07:14 <merijn> siml1: They should be installed locally for all packages you have installed, by default
04:07:51 <MagneticDuck> I take that the cario binding used in gtk2hs makes the user draw graphics in the imperative style as opposed to the declarative style like in diagrams?
04:07:56 <MagneticDuck> is that correct?
04:09:41 <osfameron> jamy23: if it's your itch, perhaps you should start, and then try to tempt people once you've got some work done
04:09:54 <osfameron> jamy23: or start by contributing patches to House?  if that's still maintained?
04:09:55 <arbn> MagneticDuck: Yes.
04:10:15 <MagneticDuck> if so, how would I make a dynamically rendered image in gtk2hs using the declarative style I love?
04:10:33 <MagneticDuck> using diagrams for instance?
04:10:36 <jamy23> House never contributed. He only research project
04:11:08 <MagneticDuck> and, is diagrams practical to make games?
04:11:22 <MagneticDuck> I'm talking about the "diagrams" package
04:12:36 <arbn> MagneticDuck: http://projects.haskell.org/diagrams/doc/Diagrams-Backend-Cairo-Gtk.html ?
04:12:57 <MagneticDuck> I want to make my graphics with a clean conscience. No C style for me except for the end user interface
04:12:59 <MagneticDuck> ah
04:13:04 <MagneticDuck> that looks good
04:13:17 <arbn> MagneticDuck: Yeah, it does. I'll have to try it out myself sometime. :)
04:13:20 <arbn> Good luck.
04:13:40 <MagneticDuck> now, diagrams says it's for "simple graphics"
04:13:50 <MagneticDuck> that wouldn't be a problem, as I'm making a simple game
04:13:55 <MagneticDuck> but does it render fast enough?
04:14:28 <MagneticDuck> thanks for the link
04:14:52 <jamy23> I allready started him couple years ago and yet not make no one release. Because i am hard workin with JS
04:15:38 <arbn> I wouldn't suggest using vector graphics for a game, personally.
04:15:51 <arbn> I don't know anything about the 'diagram' package, though.
04:16:16 <MagneticDuck> hm
04:17:06 <MagneticDuck> I'll make a ping pong game and see how I like it
04:17:07 <MagneticDuck> :P
04:17:10 <MagneticDuck> thanks arbn
04:23:06 <merijn> @where hackage-mirror
04:23:06 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
04:23:31 <merijn> Is there a Haddock mirror somehwere too?
04:28:15 <jamy23> no one want?
04:37:42 <merijn> hmm
04:38:30 <t7> is galois still hosting hackage?
04:38:42 <merijn> Suppose I have a type "Foo a" is there a way to implement (==) that will let me compare Foo Bar and Foo Baz values with eachother?
04:39:10 <merijn> I don't suppose that'll work without a lot of extra work, right?
04:39:19 <t7> merijn: You need a multi param (==) class
04:39:34 <merijn> t7: Meh, I'll just implement my check directly
04:43:58 <mikeplus64> merijn: an instance for Dynamic ;) (horrible idea i never said that)
04:44:11 <mroman> > ((-)8) 19
04:44:12 <lambdabot>   -11
04:44:18 <mroman> > (8(-)) 19
04:44:19 <lambdabot>   8
04:44:28 <mroman> > (8-) 19
04:44:29 <lambdabot>   -11
04:44:33 <mroman> What is the rule here?
04:45:16 <hpc> 1 and 3 parse as "(-) 8 19", or "8 - 19"
04:45:16 <mikeplus64> :t (8(-))
04:45:18 <lambdabot> forall t a. (Num ((a -> a -> a) -> t), Num a) => t
04:45:44 <merijn> mikeplus64: Got a link for that? (Man, I really miss Hackage...)
04:45:45 <hpc> 2 parses as "8 (-) 19", or "8" applied to some things
04:45:48 <mikeplus64> mroman: i think lambdabot must have an instance for Num (a -> a -> a)
04:46:10 <mikeplus64> merijn: see Data.Dynamic, you probably have local docs for it, it's in base
04:46:20 <merijn> mikeplus64: It might not be as horrible as you think for my use case, the a parameter actually doesn't show up in the actual values
04:47:10 <mikeplus64> Prelude Data.Dynamic> let x = toDyn 2 in fromDynamic x :: Maybe Integer
04:47:13 <mikeplus64> Just 2
04:47:17 <mikeplus64> works like you'd expect i guess
04:47:23 <hpc> which normally doesn't typecheck
04:47:28 <mroman> :t 8-
04:47:29 <lambdabot> parse error (possibly incorrect indentation)
04:47:32 <mroman> :t (8-)
04:47:33 <lambdabot> forall t. (Num t) => t -> t
04:47:37 <merijn> :t fromDynamic
04:47:38 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
04:47:44 <mroman> :t (8- 9)
04:47:45 <lambdabot> forall t. (Num t) => t
04:47:51 <merijn> oh...that might be what I want
04:48:00 <mroman> So it looks ahead to see if a literal or whatever comes.
04:48:12 <mikeplus64> > let x = toDyn 0 in fromDynamic x :: Maybe Char
04:48:13 <lambdabot>   Nothing
04:49:11 <merijn> hmm, maybe it isn't...
04:49:29 <merijn> ok, so here's my problem
04:50:23 <merijn> I have a Record datatype which can be Control records or Data records. I use GADTs to encode that in the type using a phantom type
04:50:34 <merijn> (i.e. Record Control and Record Data)
04:51:10 <merijn> But that makes it impossible to write an Eq instance that works for all Record's
04:51:23 <mikeplus64> instance Num (Either (Record Control) (Record Data))
04:51:28 <mikeplus64> Eq
04:51:30 <mikeplus64> i mean
04:51:40 <merijn> That kinda defeats the purpose
04:51:48 <mikeplus64> or your own equality test :p
04:52:19 <merijn> I guess I want something like "Eq (Record (forall a.a))" if that makes sense :p
04:53:14 <mikeplus64> merijn: then do that?
04:53:23 <mikeplus64> ie just instance Eq (Record a)
04:53:59 <mikeplus64> oh, right
04:54:30 <merijn> No, that's not the same
04:54:35 <mikeplus64> yeah
04:54:54 <mikeplus64> no i don't think there is a nice sane way to define an Eq instance for two values of different types
04:55:07 <t7> multiparameter type class
04:55:12 <mikeplus64> yeah
04:55:13 <t7> Eq2 a b
04:55:24 <t7> a ++? b
04:55:28 <t7> a==? b ***
04:56:38 <merijn> t7: Yeah, but then I might as well just write "compare :: Record a -> Record b -> Bool"
04:58:26 <merijn> Bah, I have the same problem with Show :\
04:58:50 <merijn> Apparently the compiler won't let you use print on "Record a" even though I have a show instance for all possible a's
05:02:47 <fmap> that's strange
05:02:54 <t7> what kind is record?
05:03:28 <t7> merijn: instance Show a => Show (Record a) where
05:04:02 <merijn> t7: Yeah, that's what I was thinking
05:04:32 <merijn> Is this legal? "instance forall (a :: RecType) . Show a"?
05:04:55 <hpc> merijn: it's a kind error, probably
05:07:03 <Expez> http://hpaste.org/74738 <- Could someone take a look at my attempt to implement an instance of arbitrary for use with quickcheck? Think I've misunderstood how to use the arbitrary instances I generate.
05:07:37 <merijn> hpc: You're right, show expects kind *
05:11:31 <merijn> What does ImpredicativeTypes do?
05:11:46 <merijn> GHC helpfully suggested it and now my code compiles, but I dunno what it does :p
05:12:26 <hpc> it does mildly evil things, which i don't remember off the top of my head
05:12:50 <hiptobecubic> isn't that how all extensions work
05:13:36 <fmap> all interesting maybe
05:13:46 <hpc> http://www.haskell.org/haskellwiki/Impredicative_types
05:13:52 <merijn> I though Overlapping/Undecidable where the only really evil ones? :p
05:13:59 <fmap> no
05:14:31 <fmap> Undecidable isn't actually evil
05:15:02 <fmap> Incoherent is
05:15:16 <merijn> Actually, ImpredicativeTypes looks like exactly what I want
05:15:17 <hpc> undecidable leads to nonterminating compilation, sometimes
05:16:22 <merijn> Because I want to define "Chan (forall a. Record a)", which seems to be exactly what ImpredicativeTypes does
05:16:37 <hpc> you should use a different extension to do that
05:16:39 <hpc> uh
05:16:45 <jfischoff> Expez: http://hpaste.org/74738
05:16:48 <merijn> hpc: Which one?
05:17:03 <hpc> PolymorphicComponents
05:17:07 <merijn> Impredicative is what GHC suggested and that wiki page says it does exactly what I want
05:17:12 <hpc> ExistentialQuantification
05:17:30 <hpc> one of those two, and write a Record' :: *
05:17:35 <hpc> which is polymorphic on the inside
05:17:54 <hpc> then you have Chan Record' and you get to stick with well-tested extensions
05:17:57 <merijn> I don't want ExistentialQuantification, because then I lose the info
05:19:04 <merijn> Neither is polymorphic components, afaict
05:19:05 <Expez> jfischoff: Thanks!
05:19:09 <mikeplus64> merijn: not really, if your gadt can only be two types anyway
05:19:12 <merijn> That's for polymorphic constructors, which I don't have
05:19:19 <Expez> ghc: panic! (the 'impossible' happened)
05:19:29 <merijn> Expez: DataKinds and 7.4? :>
05:19:47 <Expez> merijn: I have no idea what I'm doing.
05:20:11 <mikeplus64> Expez: that's the spirit :)
05:20:22 <Expez> Fake it 'til you make it :P
05:20:58 <Expez> merijn: Had to google what a DataKind is, but I have not enabled that extension.
05:21:02 <merijn> hpc: All my functions are capable of dealing with "Record a" regardless of the value of a, my only problem is that I need to send them through Chan's/MVar's which of course aren't (normally) polymorphic enough to be written as "Chan (Record a)"
05:21:15 <merijn> Expez: Do you have any enabled extensions?
05:21:39 <Expez> merijn: flexibleinstances
05:23:18 <hpc> is hackage down?
05:23:25 <kyagrd> yes hackage is down
05:23:53 <kyagrd> hope someone in Portland gets up
05:23:53 <fmap> Expez: deriving (show)?
05:24:02 <Expez> fmap: yes
05:24:11 <jathd> Is there a way to tell cabal to always run with --haddock-hyperlink-source?
05:24:18 <Expez> fmap: KNown bug, don't have to report?
05:24:26 <fmap> yes
05:24:31 <merijn> hpc: Besides, someone needs to test the less well tested extensions :p
05:25:13 <hpc> heh
05:25:38 <hpc> i don't see what you lose by existential quantification though
05:26:03 <hpc> (forall a. Record a) => Record' => (forall a. Record a)
05:26:44 <merijn> hpc: ok, so how would I write that? I don't really understand existential quantification
05:27:10 <paolino> merijn, is there a paste of your code ?
05:27:27 <hpc> data Record' = forall a. Record' (Record a) -- the most naive way of writing it
05:27:41 <hpc> you can even newtype it, then it's just type hackery
05:27:41 <merijn> Actually, I think "Chan (forall a. Record a)" is wrong too
05:28:04 <merijn> Hmm, maybe I want existential quantification after all
05:28:14 <paolino> yes, ghc suggested wrong
05:28:35 <hpc> ghc suggested what was necessary for that particular code to work
05:28:46 <hpc> if he had tried to define Record' up front, it would have suggested the right thing
05:29:13 <hpaste> Expez annotated “quickcheck: Problems with arbitrary instances” with “quickcheck: Problems with arbitrary instances (annotation) (annotation)” at http://hpaste.org/74738#a74740
05:29:16 <hpc> merijn: if you need more information than that, you can also turn on GADTs
05:29:35 <deech> Hi all, can I compile Haskell programs for the Rasberry Pi yet?
05:29:39 <Expez> jfischoff: Could you take a look again? Still not working properly :(
05:29:43 <hpc> then after extracting from Record', you can still get type info from the constructor
05:30:06 <merijn> hpc: I already have a GADT
05:30:10 <hpc> ah, sweet
05:30:14 <hpc> then you should be good
05:30:20 <merijn> Lemme paste the datatype I have
05:31:05 <hpaste> merijn pasted “GADT record” at http://hpaste.org/74741
05:31:06 <jfischoff> Expez: did you mean to have the phantom type data Foo x?
05:31:20 <jfischoff> or was that accidentally?
05:32:16 * jfischoff guesses it was accidently
05:32:23 <jfischoff> err accidental
05:32:29 <merijn> hpc: You can't newtype it, apparently
05:32:34 <Expez> jfischoff: a phantom type is when when I did Foo x instead of just Foo = ?
05:32:38 <merijn> "A newtype constructor cannot have an existential context"
05:32:47 <jfischoff> Expez: yes
05:33:22 <Expez> jfischoff: That seems to fix it. Thank you so much :)
05:33:30 <jfischoff> Expez: np :)
05:33:46 <merijn> hpc: I'm not sure how to unwrap Record' back to Record, though...
05:35:01 <watermind> if we define   type NOT a = a->Void   is   NOT (NOT A) isomorphic to  A?
05:35:12 <watermind> I understand how to define the elements of NOT (NOT A)
05:35:42 <watermind> elem f = f  constantOfA
05:35:55 <watermind> for each constantOfA in A
05:36:33 <paolino> @hoogle CInt
05:36:33 <lambdabot> Foreign.C.Types data CInt
05:36:34 <lambdabot> Foreign.C.Types data CIntMax
05:36:34 <lambdabot> Foreign.C.Types data CIntPtr
05:36:41 <watermind> so it does look like an isomorphism, but on the other hand, aren't all these elements the same?
05:37:07 <luite> Spockz: uh you can wget the whole thing, but i haven't installed anything to make copying the archive faster. any suggestions?
05:37:35 <watermind> i.e. the undefined everywhere function
05:37:48 <watermind> and therefore isormophic to Unit
05:37:54 <watermind> i.e. ()
05:39:38 <paolino> merijn, with pattern matching you open Record'
05:40:57 <merijn> paolino: Yeah, but suppose I have "case rec of Record' r -> r" what's the type of r? Whatever it was when I wrapped it?
05:42:03 <hiptobecubic> why not?
05:42:17 <paolino> what else ?
05:42:54 <paolino> the point is to not let a escape from the scope
05:43:28 <paolino> what is the signature of the function acting on Record a ?
05:44:39 <merijn> paolino: Mostly it's "Record a ->"
05:44:44 <paolino> applyFunc f (Record' r) = f r -- f must *destroy* 'a'
05:45:25 <merijn> That renders the entire thing completely useless
05:45:37 <merijn> Hence, why I figured ExistentialQuantification wouldn't be what I want
05:46:06 <paolino> then you need to add a class to the existential
05:46:26 <merijn> No, because then I still know nothing
05:48:02 <merijn> I want to ship both "Record Control" and "Record Data" through one channel from one forkIO thread to another, without losing phantom type
05:48:24 <paolino> use Either
05:49:05 <merijn> Guess I might as well scratch the entire Record implementation have a Data datatype and Control datatype and use either...
05:49:43 <paolino> Chan (Either (Record Control) (Record Data))
05:50:16 <merijn> paolino: Yes, but why even bother having a single datatype for both if you're gonna do that?
05:51:07 <paolino> to enforce correctness on functions acting on one type but not the other
05:51:10 <merijn> If I need either to encode the difference anyway than the entire Record datatype is useless
05:51:46 <merijn> paolino: That you can just as easily do by having "Either Control Data" everwhere, instead of "Record a"
05:52:16 <paolino> it's different
05:52:26 <merijn> paolino: How so?
05:52:28 <paolino> that is runtime checking
05:56:30 <merijn> paolino: Yes, but if I'm forced to do that due to Chan's than I might as well
05:57:10 <merijn> because I'd have to use either to distinguish at the point where I read from a Chan anyway
05:58:56 <paolino> Record Data and Record Control are different types, that is the power and the problem
05:59:02 <merijn> Man, now I really wish I had dependent types
06:00:04 <hpaste> fmap pasted “untouchable?” at http://hpaste.org/74743
06:00:21 <byorgey> MagneticDuck: I'm quite interested in working on optimizing diagrams
06:00:22 <fmap> what does "`a' is untouchable" mean?
06:00:40 <byorgey> MagneticDuck: so if you find examples where it doesn't render fast enough for a game, I'd love to know
06:00:52 <paolino> fmap, maybe it has to do with lambda
06:00:55 <byorgey> MagneticDuck: also, if you have more questions you should ask in #diagrams too
06:01:11 <paolino> try a function instead
06:01:41 <fmap> paolino: yes, this works with a function. lambdas aren't polymorphic enough?
06:02:06 <jfischoff> could it be because of some ghci defaulting?
06:02:18 <paolino> you must ask higher :-/
06:03:21 <akamaus> byorgey, what's about the question to SPJ?
06:03:40 <rwbarton> fmap: what's the type of chain?
06:03:47 <byorgey> akamaus: I'll tell you in just a minute, paying attention to a talk at the moment
06:05:11 <akamaus> byorgey, ok. Is online translation available btw?
06:06:20 <fmap> rwbarton: chain ∷ (Command l s (Free (Command l s) c) → IO a) → Free (Command l s) c → IO (), and Command is GADT
06:06:35 <fmap> basically `chain' folds free monad with IO actions
06:08:29 <byorgey> akamaus: what do you mean by online translation?
06:08:33 <paolino> fmap, isn't that 'a' a bit alone ?
06:09:47 <byorgey> akamaus: the answer re: splicing names is that (for reasons I don't quite understand) it would make things with scoping and name resolution very weird
06:09:59 <byorgey> akamaus: BUT it will be possible after the planned TH overhaul
06:10:26 <akamaus> byorgey,  I asked if video records of talks you're listening to are available through Internet.
06:10:56 <akamaus> byorgey, got it. Will write that AST by hand :)
06:11:07 <byorgey> akamaus: oh, I see.  Yes, videos will be available
06:11:14 <akamaus> I just wanted to make sure I don't miss something obvious
06:11:23 <byorgey> they are not being streamed but they are usually uploaded a few days after
06:11:32 <rwbarton> fmap: interesting. and source?
06:11:47 <rwbarton> perhaps matching a GADT constructor with a lambda doesn't do type refinement?
06:12:07 <akamaus> byorgey, btw, that event are you participating in?
06:12:38 <byorgey> akamaus: today is the Haskell Implementors' Workshop
06:12:47 <byorgey> there was also the Haskell Symposium yesterday, and ICFP before that
06:12:58 <byorgey> akamaus: search for Malcolm Wallace on youtube
06:15:50 <fmap> rwbarton: http://hpaste.org/74745
06:16:21 <akamaus> byorgey, found his channel. So much interesting stuff. Great!
06:16:32 <fmap> it seems there need to be more type signatures if you want inference to work with GADTs
06:16:34 <rwbarton> ah oops, I meant "what is the type of 'source'" :)
06:16:46 <rwbarton> yes I think that's true
06:18:05 <rwbarton> for example if I have data X a b where { A :: Int -> X Int Int; B :: Bool -> X Bool Bool } and then f (A x) = x; f (B x) = x, there isn't a principal type for f
06:18:21 <rwbarton> it can be given type f :: X a b -> a OR type f :: X a b -> b
06:18:31 <teneen> Why is "reallyUnsafePtrEquality# y (const y 1)" == 0 ?
06:18:37 <rwbarton> but maybe that's not the kind of problem you're running into, I don't know.
06:19:10 <rwbarton> teneen, well you didn't evaluate the thunk (const y 1) so it will live somewhere different than y
06:19:14 <fmap> principal as in most general?
06:19:19 <rwbarton> fmap: yes
06:19:51 <teneen> rwbarton: No I forced it before querying
06:20:05 <rwbarton> teneen, try something like let y' = const y 1 in y' `seq` reallyUnsafePtrEquality# y y'
06:20:09 <kingleoric> monochrom: yesterday when you said 4-8 months did you mean really diving into datacommunication? just learning the basics could be done in a half-semester course right?
06:21:03 <teneen> rwbarton: Ok using seq it worked. But when I forced it by querying the result of y' in ghci it didn't work.
06:21:05 <rwbarton> teneen, personally I have tried using reallyUnsafePtrEquality# though and never got it to return 1 except in really dumb cases :)
06:21:30 <rwbarton> teneen: what did you do exactly?
06:22:34 <teneen> rwbarton: In ghci "let x = const y x" then queried the result of x (which I think should force its evaluation) and then asked for reallyUnsafePtrEquality#
06:23:00 <rwbarton> hmm
06:23:01 <rwbarton> I see
06:24:07 <teneen> rwbarton: I think it should work, because x is a constant value which is computed once (like a CAF)
06:40:43 <kstt`> seriously ... hackage is the most amateurish CPAN hosting I have ever used. Even pet languages have better hosting for the community packages. Sorry to be so rude, but here in europe, it is workhours, and hackage is down again. Frankly, that's really not on par with the language. This is frustrating, and makes us loose time and money.
06:41:36 <luite> there is a mirror, at least for the package archive
06:41:41 <kstt`> Are we waiting this time again for the hackage admin to have his breakfast ?
06:42:53 <kstt`> luite: thank you. Indeed there are some ways to work around the state of the affair
06:43:29 <Spockz> luite: rsync?
06:44:44 <kstt`> but I'm reluctant to build upon an individual, local workaround, and leave the rest of the team and community stuck with a broken tool chain for hours
06:44:53 <luite> Spockz: is that the standard way to do mirrors?
06:45:45 <Spockz> luite: well, I believe it is one of the better ways to mirror data between two locations and it is battle-tested :)
06:45:58 <Jello_Raptor> seriously is haskell the only language sensible enough for the '$' operator?
06:46:00 <Spockz> luite: whether it is also the fastest way, I don't know
06:46:11 <Spockz> Jello_Raptor?
06:46:33 <kstt`> but I have never ever, in my whole life, considered cloning any package repository !
06:46:38 <luite> Spockz: does it also work for a larger number of files? I have the package archive mirrored but not yet the haddocks, going to do that soon
06:46:41 <jix_> kstt`: how much money or time have you spent for the hackage infrastructure?
06:46:59 <Jello_Raptor> the '$' operator is wonderful, and i'm sort of wishing I had it in pretty much every other language I work with.
06:47:21 <luite> Spockz: the archive is only 20000 files or so, but it would probably be millions with the haddocks
06:47:21 <Spockz> kstt`: use luites mirror
06:47:33 <shapr> kstt`: so fix it instead of complaining
06:47:40 <kstt`> jix_: the same amount as for ruby-lang, python things, LaTeX, boost, or any language or community infrastructure we use : zero
06:47:44 <fmap> Jello_Raptor: `$' is just `id'
06:48:21 <Jello_Raptor> fmap: yes, but with a low precedence, so that it basically amounts to "Throw parens around everything to the right of me"
06:48:58 <Jello_Raptor> which is wonderful
06:49:28 <Spockz> luite: and we don't have to copy everything everytime
06:49:44 <jix_> kstt`: yeah, just keep that in mind when complaining :)
06:50:08 <fmap> well, there are languages which allow you to not write parens without operators (perl, ruby, …?)
06:50:14 <kstt`> jix_: but Hackage is the only one in this list that is broken so often. It plainly sucks, and spoting that I don't help does not change this fact.
06:50:29 <Spockz> kstt`: they are working on it
06:50:32 <Jello_Raptor> fmap: what do you mean?
06:51:30 <kstt`> Spockz: thx. On what are they working ? On this Nth failure ? Or on the fact that hackage is down every few days ?
06:51:47 <Spockz> kstt`: on a replacement for hackage
06:52:02 <kstt`> that would be very welcome
06:52:43 <kstt`> I think we would even be glad to contribute a french node in a distributed infrastructure
06:53:40 <kstt`> that would be *very* different from locally cloning a domain to ensure our access to package when this host goes down every few days
06:53:50 <fmap> Jello_Raptor: i mean eliminating parenthesis isn't the most interesting usage of `$'
06:54:38 <killy9999> hah, came here to ask about hackage
06:55:02 <killy9999> but I see that's just a failure
06:55:15 <kstt`> yeah, just a failure
06:55:29 <killy9999> when is hackage 2 supposed to be up?
06:55:30 <kstt`> you are just unable to compile your work this afternoon
06:55:31 <Jello_Raptor> fmap: not the most interesting no, but I think it's easily the most important
06:55:48 <kstt`> and you are just unable to read the docs online as well
06:56:06 <kstt`> in a word, you are just unable to work
06:57:18 <Spockz> kstt`: well, no, the docs of packages you have installed are on your machien
06:58:01 <jix_> kstt`: I just don't see how comments like "Are we waiting this time again for the hackage admin to have his breakfast ?" help. This is insulting to exactly those people who contribute time or money to hackage, without whom it wouldn't even exist, while you are not.
06:58:01 <Spockz>  remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive << add that to your ~/.cabal/config and be happy again :)
07:00:49 <luite> I've added the instructions to http://hdiff.luite.com/
07:00:56 <killy9999> Spockz: where are the docs of installed packages¿
07:00:58 <killy9999> ?
07:01:09 <kstt`> jix_: agreed in some sens, but note that I did *NOT* step on to take the responsability to administrate Hackage.
07:03:31 <merijn> If I have C files that need to be compiled/linked do I just pass them as extra arguments to GHC or does GHC expect object files?
07:03:43 <Spockz> killy9999: file://localhost/Users/*username*/Library/Haskell/doc/index.html on mac
07:03:48 <Spockz> OS X
07:04:11 <kstt`> also, I build everything with cabal-dev (or absolute chaos results within a few days). I don't find docs locally.
07:05:00 <kstt`> Although I should probably set that up for next time
07:05:16 <marcot> Hi.  My program is eating about 80M of memory, mostly on unstream/resize/parseTags (from TagSoup).
07:05:27 <marcot> And, well, unstream/resize are from Data.Text
07:06:43 <marcot> The biggest html it is parsing is about 1MB.  I'm using strict Text.  Is this kind of memory consumption expected?
07:08:11 <ique> how could you do modulo with floating point numbers? like 0.15 % 0.05 should be 0 (or 0 within machine precision)
07:08:19 <rwbarton> mod'
07:08:45 <rwbarton> > 0.15 `mod'` 0.05
07:08:46 <lambdabot>   4.999999999999999e-2
07:08:54 <rwbarton> and of course this can happen too
07:09:18 <rwbarton> hmm
07:09:24 <rwbarton> > (15%100) `mod'` (5%100)
07:09:25 <lambdabot>   0 % 1
07:10:48 <ique> ah, Data.Fixed didn't know that existed
07:10:49 <ique> thanks
07:12:56 <killy9999> ok, I can't seem to find documentation of packages on my linux
07:13:30 <kyagrd> hackage is revived
07:14:43 <kyagrd> no not alive
07:15:08 <kyagrd> :(
07:16:24 <sopvop> What's the problem with hackage? Bugs? Hosting wants too much money?
07:18:19 <parcs`> good question
07:19:28 * sopvop surely don't want new hackagegeddons
07:22:23 <typoclass> it's kind of embarrassing really :-(
07:22:23 <hiptobecubic> how much bandwidth does hackage need?
07:22:41 <Lutin`> Think about how many people use this -one- server
07:22:49 <hiptobecubic> perhaps that's the issue
07:22:57 <hiptobecubic> separate the site from the backend that generates it
07:23:02 <killy9999> success!
07:23:04 <hiptobecubic> then at least the static site can be served
07:23:07 <Lutin`> hackage2!
07:23:09 <sopvop> Yup, haskell failed at avoiding success
07:23:18 <killy9999> docs on linux are in /usr/share/doc/ghc/html/
07:23:20 <Lutin`> sopvop: lol right
07:26:35 <Sculptor> hi
07:28:45 <t7> i need hackage :'(
07:31:43 <adnam> t7: http://hdiff.luite.com/packages/archive
07:32:00 <t7> adnam i dont think its complete
07:32:32 <ocharles> damnit, I haven't generate cabal docs locally
07:32:35 <adnam> no? it seems to update frequently
07:32:40 <typoclass> @where hackage-mirror
07:32:40 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
07:32:46 <juanitotartara> Hi!
07:32:47 <dreugeworst> Hi, I'm trying to paralellize a task, but it's blowing up memory usage enormously, and I don't understand why. The main bit of my program looks like
07:32:48 <dreugeworst> foldl accum (0,0) (map flopper permuts `using` parListChunk 170 rdeepseq)
07:32:49 <typoclass> ^^ this is the complete line you need for .cabal/config
07:33:04 <t7> actually that may be a lie
07:33:18 <parcs`> dreugeworst: what's accum?
07:33:20 <dreugeworst> where flopper is an expensive-ish task, and permuts is a very, very large list of tuples.
07:33:46 <dreugeworst> without the using bit, it uses about <1M of memory, but with it blows up to many GB
07:34:23 <dreugeworst> I tried different strategies, but don't really understand them, and they don't change anything
07:34:40 <sopvop> what about foldr?
07:34:44 <Lutin`> Have you read simon's slide/paper on concurrent and parallel haskell?
07:35:01 <sopvop> Or strict foldl'
07:35:02 <parcs`> dreugeworst: did you try foldl'
07:35:55 <Lutin`> dreugeworst: Just in case you haven't http://goo.gl/jHdeS
07:45:22 <lovro_> nigga
07:45:24 <lovro_> nigag
07:45:25 <lovro_> nigga
07:45:27 <lovro_> nigaa
07:45:30 <typoclass> @where ops
07:45:30 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
07:45:31 <sclv> @ops
07:45:31 <lambdabot> Maybe you meant: docs oeis pl
07:45:56 --- mode: ChanServ set +o Cale
07:46:02 --- mode: ChanServ set +o Igloo
07:46:02 --- mode: Cale set +b *!*@gateway/web/freenode/ip.93.137.58.12
07:46:02 --- kick: lovro_ was kicked by Cale (lovro_)
07:46:10 <osfameron> "docs oeis pl" is probably anincntation in some language
07:46:14 --- mode: Cale set -o Cale
07:46:37 <osfameron> was he trying to find the powerset of ['n','i','g','g','a'] ?
07:48:00 <Lutin`> Couldn't have been a set, there were repeated elements
07:48:24 <hpaste> wm pasted “ch” at http://hpaste.org/74747
07:48:33 <Lutin`> Maybe that was a problem with his algorithm
07:49:23 <Lutin`> Igloo: Come on back down here with the rest of us :D
07:51:46 <osfameron> Lutin`: good point
07:53:59 <kingleoric> Who in here was talking about scapy and wireshark last night? Said you could do some cool stuff with it. Example?
07:54:02 <bartavelle> ok, hackage is down. Which module do I use to perform simple http requests to a REST service ?
07:54:20 <bartavelle> kingleoric, scapy is full of cool stuff
07:54:51 <typoclass> bartavelle: most likely http-conduit
07:54:55 <typoclass> @where hackage-mirror
07:54:55 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
07:54:59 <bartavelle> it is just extremely convenient every time you have to work/interact with a network protocol
07:55:04 <bartavelle> typoclass, thx
08:05:31 <statusfailed> hackage is up
08:05:56 <statusfailed> :D
08:06:14 <kyagrd> finally
08:06:31 <statusfailed> It probably wouldn't be that hard to just mirror all the documentation...
08:06:40 <ParahSai1in> @src liftM
08:06:40 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:06:50 <sopvop> right at the end of my work day. the gods hate me.
08:07:05 <statusfailed> sopvop: you get to do haskell at work?!
08:07:19 <sopvop> yup,
08:08:21 <statusfailed> are you at standard chartered?
08:08:34 <sopvop> I don't know what you mean
08:08:44 <statusfailed> i'm trying to guess what company you work for :P
08:08:44 <sopvop> dont understand even
08:09:15 <typoclass> sopvop: 'standard chartered' is the name of a bank or some such
08:09:36 <statusfailed> I think they do haskell
08:09:40 <sopvop> No,  I work in CG animation studio. Being the only real programmer, I can choose the tools :)
08:09:47 <Lutin`> Nice
08:09:59 <statusfailed> Cool =D
08:10:15 <Lutin`> I was talking to this one woman at an open house for my uni and got onto a tangent about functional programming
08:11:50 <Lutin`> Thought she was just a professor or student but then she gave me her card :X lead software engineer for Sensormatic
08:12:08 <Botje> and the next day you were hired? :P
08:12:11 <statusfailed> Networking like a bause
08:13:20 <rwbarton> has anyone here worked with OpenCV from Haskell?
08:13:26 <rwbarton> (computer vision)
08:13:38 <Lutin`> I got slammed with classes right after though and I haven't emailed her yet :X
08:15:20 <zungaloca> Whats wrong main= do xs= [1..10] xz=[1..10] [x*y|x<-xs,y<-xz]
08:15:30 <rwbarton> a lot
08:15:36 <Lutin`> Yeah..
08:15:49 <Lutin`> But we can fix it!
08:16:25 <zungaloca> Hand
08:16:34 <rwbarton> add let before xs and xz, print before the list comprehension, and some newlines and indentation would be nice too
08:17:11 <Lutin`> http://learnyouahaskell.com/a-fistful-of-monads
08:17:34 <zungaloca> http://ideone.com/wF8re
08:17:53 <Lutin`> Scroll down to do notation and if there's anything you don't understand just read previous material
08:18:28 <statusfailed> Lutin`: Lynn university?
08:18:42 <Lutin`> Florida Atlantic
08:18:50 <statusfailed> damnit!! 50% and I failed ;D
08:18:53 <Lutin`> lol
08:18:58 <Lutin`> My roommate goes to Lynn though@
08:19:15 <Lutin`> I'm CSE and he's business
08:19:40 <statusfailed> is that like CS and EE joint major sort of thing?
08:19:45 <rwbarton> I wonder why this CV package has a constraint "base (≥4 & <6)"
08:19:47 <Lutin`> Yeh
08:19:55 <rwbarton> does the author know something I don't??
08:19:56 <statusfailed> hey cool, I did that :)
08:19:58 <mzero> zungaloca: [x*y|x<-[1..10]; y <- [1..10]]   ----or-----   do { x <- [1..10]; y <- [1..10]; return x*y }
08:20:11 <Lutin`> Nice.
08:20:15 <mzero> but then again, I don't know what you are trying to achive
08:20:23 <Lutin`> I'm learning more towards the CS part though
08:20:33 <Lutin`> Cause I'm actually CSE and Math double major, hopefully
08:21:09 <bartavelle> is there a nice pragma that will let me write "strings" and have GHC pack them into the appropriate type ?
08:21:25 <ParahSai1in> @pl do { x1 <- m1; f x1 }
08:21:26 <lambdabot> (line 1, column 4):
08:21:26 <lambdabot> unexpected "{"
08:21:26 <lambdabot> expecting variable, "(", operator or end of input
08:21:31 <paolino> OverloadedStrings
08:21:40 <bartavelle> ah yes
08:21:41 <bartavelle> thanks
08:22:08 <zungaloca> Ok thnx
08:22:22 <ParahSai1in> @src liftM2
08:22:22 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:23:53 <statusfailed> Lutin`: Yeah, I shied away from the EE a bit.. kinda wish I did CS & maths sometimes :)
08:24:23 <Lutin`> Yeah I was thinking of switching to CS, but starting pay is less and I can just take more CS classes
08:26:24 <Lutin`> Programs are similar though http://www.cse.fau.edu/pdf/bscsflowchart.pdf & http://www.cse.fau.edu/pdf/bsceflowchart.pdf. Alright I'm done with offtopic :P
08:31:17 * hackagebot hedn 0.1.5.0 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.5.0 (AlexanderBondarenko)
08:31:19 * hackagebot Workflow 0.7.0.2 - Monad transformer for thread state persistence and workflow patterns  http://hackage.haskell.org/package/Workflow-0.7.0.2 (AlbertoCorona)
08:31:21 * hackagebot ClassLaws 0.3.1.0 - Stating and checking laws for type class methods  http://hackage.haskell.org/package/ClassLaws-0.3.1.0 (PatrikJansson)
08:31:30 <Lutin`> I guess hackage is up
08:32:08 <typoclass> yes, somebody with permission could fix the topic
08:33:04 <statusfailed> Is there a reason the topic is :: [String] ?
08:33:35 <MostAwesomeDude> Theming, mostly.
08:34:16 <c_wraith> also, lambdabot can manage the topic by adding and removing strings from the list
08:34:57 <rwbarton> should execute actions of type State [String] ()
08:35:10 <Morgawr> hello everyone.. I have a question about recursion/pattern matching for functions in Haskell.. is it possible for me to define the pattern match using n+1 instead of n? for example "recurse (n+1) = 1 + (recurse n)" instead of "recurse n = 1 + (recurse n-1)"?
08:35:38 <Morgawr> I tried doing it but it says there's an error with the pattern matching (ghci, that is)... though I'm almost sure I saw some haskell code like that
08:35:46 <rwbarton> it used to be allowed
08:35:54 <rwbarton> but it was sort of silly and weird
08:36:05 <ericmj> + has to be a constructor for that to work - and it isnt
08:36:13 <Morgawr> so it's not allowed?
08:36:20 <Lutin`> It's just weird
08:36:20 <rwbarton> if you really want it you can run ghci -XNPlusKPatterns
08:36:22 <ericmj> not allowed
08:36:35 <rwbarton> but better not to want it imo
08:36:51 <MostAwesomeDude> Morgawr: If you think about how pattern matches are built, n+k is a *very* special case.
08:37:08 <Lutin`> recurse n = recurse (n+1) - 1
08:37:09 <Morgawr> eh, okay thanks... I was just wondering :) Studying computer science stuff at the moment and most of our theoretical recursive algorithm are written like that... I wanted to test them in Haskell as is, but I'll just re-write them, no big deal
08:37:13 <Lutin`> If you really want n+1
08:37:36 <Lutin`> You can just solve for recurse n
08:37:48 <Morgawr> it's because you can have something like... "myfunction (z-1) (z-2) = ...." with a given z, but it's not a big deal
08:37:59 <Morgawr> (for example, ackermann's function)
08:38:22 <Lutin`> eek
08:38:42 <Morgawr> I know I know, not a big deal :)
08:38:55 <Lutin`> Well it's just more
08:40:44 <hpaste> rwbarton pasted “filepath install error” at http://hpaste.org/74750
08:41:10 <rwbarton> does anyone know what this error means?
08:41:50 <Lutin`> Oh
08:41:53 <rwbarton> possibly "Safe Haskell is broken in ghc 7.2"?
08:41:59 <Lutin`> The package (base) the module resides in isn't trusted.
08:42:03 <Lutin`> Whoops
08:42:10 <Lutin`> 7.2.1 shipped without explicitly trusting the `base' package
08:42:23 <Lutin`> Do $ ghc-pkg-7.2.1 trust base
08:42:25 <rwbarton> can I indicate that I trust base and/or don't care about Safe Haskell somehow
08:42:36 <rwbarton> perfect, thanks!
08:43:18 <Ferdirand> speaking of n+k patterns
08:43:26 <rwbarton> ugh
08:43:40 <rwbarton> now I have this problem http://hackage.haskell.org/packages/archive/directory/1.2.0.0/logs/failure/ghc-7.4
08:44:31 <Ferdirand> is there easy sugar to match the beginning of a string ?
08:44:39 <Lutin`> (x:xs)
08:44:51 <Ferdirand> that is not easy
08:44:58 <Lutin`> What
08:45:00 <rwbarton> shouldn't directory's dependency on base reflect what versions of GHC it builds under?
08:45:01 <Morgawr> how is it not?
08:45:09 <Ferdirand> if you want to match 'f':'o':'o':'b':'a':'r':xs
08:45:21 <aristid> :t isPrefixOf
08:45:23 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
08:45:30 <Lutin`> Well yeah that's not pattern matchings job imo
08:45:31 <Ferdirand> but isPrefixOf is not matching
08:45:38 <aristid> Ferdirand: just use it in a guard.
08:45:42 <typoclass> Ferdirand: i think the easiest is a guard ... «f x | "foobar" `isPrefixOf` x = ...»
08:45:49 <Lutin`> What aristid said
08:45:49 <rwbarton> Ferdirand: I think there is also some TH for this somewhere
08:46:40 <kyagrd> http://stackoverflow.com/questions/1602243/pattern-matching-string-prefixes-in-haskell has exactly this discussion :) going on now
08:46:57 <Ferdirand> aah, interesting
08:47:39 <Ferdirand> i don't especially need it, but mentioning n+k patterns made me wonder about n++k patterns
08:48:31 <kyagrd> Ferdirand: there are some languages that allows that such as http://en.wikipedia.org/wiki/Curry_%28programming_language%29
08:49:00 <ParahSai1in> im a bit stuck on converting Data.ByteString.Lazy.Char8.ByteString to Data.ByteString.ByteString
08:49:36 <rwbarton> .Char8 doesn't affect the type. to convert lazy to strict you want something like concat . toChunks
08:50:14 <ParahSai1in> thanks
08:56:03 <adnauseam> i'm being a bit slow. why does "foldr (div 2) 1 [2,4,8]" fail ?
08:56:09 <adnauseam> > foldr (div 2) 1 [2,4,8]
08:56:10 <lambdabot>   No instance for (GHC.Real.Integral (b -> b))
08:56:10 <lambdabot>    arising from a use of `e_12...
08:56:28 <mininaim> hello guys
08:56:35 <mininaim> a general question please
08:56:43 <mininaim> can I use Haskell for webapps?
08:56:48 <adnauseam> i look at foldr's definition, and this seems to be alright. the error message says something doesn't type check. but
08:56:50 <ParahSai1in> yesod
08:56:53 <rwbarton> @faq can I use Haskell for webapps?
08:56:54 <lambdabot> The answer is: Yes! Haskell can do that.
08:56:55 <adnauseam> mininaim: definitely
08:57:08 <rwbarton> adnauseam: well (div 2) doesn't appear to be a function of two arguments
08:57:19 <typoclass> mininaim: hello. yes you can, a lot of people do. there's 2 or 3 popular libraries for that
08:57:23 <adnauseam> but
08:57:27 <adnauseam> :t div
08:57:27 <lambdabot> forall a. (Integral a) => a -> a -> a
08:57:34 <rwbarton> what is the 2 for
08:57:41 <rwbarton> that's one argument
08:57:45 <adnauseam> oh
08:57:46 <rwbarton> there is only one more argument
08:57:53 <adnauseam> > foldr (div) 1 [2,4,8]
08:57:54 <lambdabot>   *Exception: divide by zero
08:58:00 <mininaim> could you please give me one or two
08:58:05 <mininaim> thank you in advance
08:58:05 <adnauseam> :[
08:58:21 <adnauseam> but there is no zero =[
08:58:21 <otters> > foldr (flip div) 1 [2,4,8]
08:58:23 <lambdabot>   0
08:58:27 <rwbarton> 4 `div` 8 is 0
08:58:35 <rwbarton> so 2 `div` (4 `div` 8) is ...
08:58:35 <otters> > 2 `div` 4
08:58:36 <lambdabot>   0
08:58:39 <otters> is also 0
08:58:44 <adnauseam> mhm
08:58:47 <otters> oh wait, but foldr starts from the back
08:59:07 <adnauseam> foldr starts from the left
08:59:14 <rwbarton> mininaim: yesod was mentioned already
08:59:16 <adnauseam> it's the accomulative one
08:59:19 <otters> right
08:59:38 <dfordivam> hello
08:59:38 <rwbarton> also snap, I guess?
08:59:44 <rwbarton> I have only used yesod myself
09:00:03 <mininaim> thank you I'll read about yesod
09:00:03 <mininaim> :)
09:00:09 <mininaim> have a good weekend!
09:00:11 <mininaim> logout
09:00:12 <rwbarton> @google haskell web frameworks
09:00:13 <lambdabot> http://www.haskell.org/haskellwiki/Web/Frameworks
09:00:13 <lambdabot> Title: Web/Frameworks - HaskellWiki
09:02:56 <ocharles> anyone have a personal favourite library for generating xml?
09:03:06 <ocharles> haxml looks like it's going to be pretty ugly for that :(
09:03:19 <ocharles> blaze-markup doesn't really have any namespace support, from what I can tell, which would be nice
09:04:41 <rwbarton> does hackage store build logs for successful package builds too?
09:04:43 <mm_freak_> ocharles: heist
09:04:51 <Clint> xml-conduit
09:04:56 <Clint> i mean xml-hamlet
09:05:01 <rwbarton> (answer: yes)
09:05:17 <ocharles> mm_freak_: hmm, i'd rather be writing the xml in just haskell
09:05:24 <ocharles> which also sorta negates xml-hamlet
09:05:30 <mm_freak_> ocharles: then either what Clint said or xmlhtml
09:06:09 <mysticc> @topic-tell
09:06:09 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
09:06:11 <mm_freak_> ocharles: are you inventing the schema?
09:06:20 <ocharles> yes
09:06:32 <mysticc> @slap
09:06:32 * lambdabot pushes  from his chair
09:06:35 <mm_freak_> ocharles: does it have to be XML?
09:06:39 <ocharles> yes
09:06:50 <ocharles> (reimplementing an existing web service that's xml, in haskell)
09:06:56 <mm_freak_> i wonder if there is an XML serialization library
09:06:59 <ocharles> boo, luite's mirror doesn't have xmlhtml so I can't get any docs
09:07:07 <mm_freak_> ocharles: then you're not inventing the schema
09:07:22 <ocharles> well i did invent it at one point :)
09:07:25 <frigga> ocharles: hackage is up
09:07:29 <ocharles> oh, cool
09:07:30 <frigga> ...at least for me
09:08:05 <mm_freak_> ocharles: you know, i was referring to present progressive ;)
09:08:19 <ocharles> xmlhtml doesn't seem to have namespaces
09:08:47 <kyagrd> what would be the simple GUI library to just render cairo or svg objects?
09:09:15 <mm_freak_> kyagrd: whatever the diagrams library uses
09:09:32 <kyagrd> mm_freak_: is there a documentation?
09:10:00 <kyagrd> mm_freak_: diagram does have a function called "dc" which can render to gtk widget.
09:10:20 <kyagrd> mm_freak_: but the thing is, creating windows and placing a widget on it ....
09:10:30 <kyagrd> I don't want to use glade or gtk just for that
09:11:08 <monochrom> if you want cairo, you're already in gtk territory
09:11:16 <monochrom> as for svg, I don't know
09:11:55 <kyagrd> monochrom: yes I know, but like OpenGL has GLUT library for very basic stuff
09:12:19 <kyagrd> would be nice if there is some simple minded wrapper to just launch from ghci
09:12:24 <monochrom> gtk is also very basic
09:14:00 <kyagrd> monochrom: yeah, not that on cannot do it by scratch themselves, but its like using raw API. things like make a window with single canvas widget kind of predefined thing
09:14:39 <rwbarton> if you have an svg file I would just launch an external svg viewer
09:15:01 <rwbarton> or use diagrams or gloss or something to do it
09:15:15 <kyagrd> rwbarton, sometimes they are just in the memory cairo objects
09:15:22 <monochrom> my understanding of GLUT is "create window; add children to window; mainLoop". if so, gtk is at that level, too
09:15:37 <rwbarton> I guess I don't know what an "in the memory cairo object" is
09:16:09 <rwbarton> isn't cairo what you use to render to a gtk surface?
09:16:48 <kyagrd> rwbarton: yes
09:17:11 <kyagrd> maybe it's just that I never used gtk lib before
09:18:27 <Shapeshifter> Hello. How can I more easily create data from data of the same type? E.g. this function http://hpaste.org/74751 takes a Game and create a slightly modified Game in return, but for this I use a huge where clause unpacking the values and then calling the constructor in the guards.
09:19:10 <rwbarton> records and/or lenses
09:20:23 <rwbarton> I mean record update syntax, like "game { snake = (n:rest), post = return () }"
09:20:42 <rwbarton> for line 23
09:21:00 <Shapeshifter> rwbarton: I see
09:22:13 <rwbarton> oh you are not even changing snake, even simpler then
09:22:45 <edwardk> transformSnake g (Just 'A') = g % grow +~ 1 % score +~ 10 -- using 'lens'
09:23:01 <edwardk> assuming lenses for grow and score
09:23:20 <rwbarton> I imagine if you switch the order of the arguments of transformSnake you could then make it even a bit more concise
09:23:29 <edwardk> yeah then you get
09:23:48 <edwardk> hrmm, well, that doesn't pipeline so we..
09:23:51 <edwardk> er well
09:23:54 <hpaste> typoclass annotated “snake” with “snake (annotation)” at http://hpaste.org/74751#a74752
09:25:11 <typoclass> Shapeshifter: hi. i've annotated your paste. if you pull out the common code into a function (i called it 'game'), you can simplify most of your 'Game' constructor calls. i've done it for two lines as an example
09:26:15 <Shapeshifter> thanks guys
09:26:28 <typoclass> a few things like '@' will remain special cases, but i think it'll still help. you may want to add another parameter that changes 'gr'.
09:26:45 <bartavelle> hum, how can I get "Exception: Cannot decode byte '\x6c': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream" from a purely ascii source ?
09:27:40 <Morgawr> bartavelle: are you sure it's 100% ascii?
09:28:12 <bartavelle> I'll double check, I am probably wrong
09:28:19 <typoclass> bartavelle: there's some utf-8 sequences that are invalid (check wikipedia). if your 8-bit ascii stream happens to contain those, the decoding will fail. 7-bit ascii should be fine (it's a proper subset of utf-8 afaik)
09:28:42 <bartavelle> it's supposed to be 7 bit ascii
09:28:49 <typoclass> bartavelle: you can pipe stuff into the unix tool 'isutf8' to check if it's valid
09:29:15 <Morgawr> not sure if the "file" command on *nix will also tell you text encoding..
09:29:23 <typoclass> bartavelle: i might be wrong ...
09:29:29 <rwbarton> "file" is approximate
09:29:36 <Lutin`> Any vim users here I can query about their setup?
09:29:38 <bartavelle> actually it isn't proper ascii, I was wrong, as expected
09:29:39 <rwbarton> I think it only looks at the start of the file
09:29:42 <typoclass> Morgawr: usually it does a pretty good job of guessing
09:33:21 <xz> recommended package for generating valid xhtml5? options I've found so far include haxml and blaze
09:35:54 <kyagrd> there should be a gui we can recommend to who want to visualize very simple things
09:36:19 * hackagebot com 1.2.3.1 - Haskell COM support library  http://hackage.haskell.org/package/com-1.2.3.1 (KidoTakahiro)
09:36:19 <kyagrd> all these years of FRP research conceptually there exists it out there but I want to load into my ghci ...
09:36:54 <bartavelle> anybody had the good idea to write something like what's in (Data.Text.Encoding) for latin1 ?
09:37:10 <bartavelle> ok googled
09:39:12 <typoclass> kyagrd: i think ghclive can visualize stuff, but i can't find the example at the moment
09:39:38 <rwbarton> I haven't used it but isn't diagrams good for this?
09:39:44 <rwbarton> or gloss?
09:40:26 <kyagrd> rwbarton: okay I know how to export pdf or ps out of diagrams
09:40:39 <rwbarton> I thought there was a way to show a diagram in a window too but I could be wrong
09:41:15 <kyagrd> rwbarton: you can if you manually code up a widget and use the "dc" function provided by diagrams
09:41:23 <rwbarton> gloss definitely has that :)
09:41:38 <kyagrd> rwbarton: thanks I'll check out gloss
09:41:58 <rwbarton> I don't know how it compares when it comes to composing images though
09:42:03 <rwbarton> I should really play around with those packages some time
09:43:28 <dreugeworst> is there a good way to create a range of Word8?
09:44:00 <dreugeworst> eg range (1,3) => [1,2,3] :: [Word8]
09:44:04 <luite> > [1..8] :: [Word8]
09:44:05 <lambdabot>   [1,2,3,4,5,6,7,8]
09:44:13 <rwbarton> > range (1,3) :: [Word8]
09:44:14 <lambdabot>   [1,2,3]
09:44:20 <dreugeworst> oh -_-
09:44:23 <dreugeworst> haha
09:44:25 <dreugeworst> thanks
09:44:29 <rwbarton> I would normally use [1..3] though yeah
09:45:31 <zungaloca> whats wrong func xs xz = [x*y|x<-xs,y<-xz]
09:46:04 <aristid> :t \xs xz = [x*y|x<-xs,y<-xz]
09:46:05 <lambdabot> parse error on input `='
09:46:10 <aristid> :t \xs xz -> [x*y|x<-xs,y<-xz]
09:46:11 <kyagrd> @let func xs xz = [x*y|x<-xs,y<-xz]
09:46:11 <lambdabot> forall t. (Num t) => [t] -> [t] -> [t]
09:46:12 <rwbarton> zungaloca: nothing wrong
09:46:13 <lambdabot>  Defined.
09:46:15 <kyagrd> nothing woring
09:46:20 <scshunt> @unlet func
09:46:21 <lambdabot>   TemplateHaskell is not enabled
09:46:21 <aristid> zungaloca: looks all right
09:46:26 <scshunt> buh
09:46:39 <kyagrd> @let func = error "sorry"
09:46:39 <lambdabot>  <local>:10:0:
09:46:40 <lambdabot>      Equations for `func' have different numbers of arguments
09:46:40 <lambdabot> ...
09:46:52 <kyagrd> @let func _ _ = error "sorry"
09:46:53 <lambdabot>  <local>:10:0:
09:46:53 <lambdabot>      Warning: Pattern match(es) are overlapped
09:46:53 <lambdabot>               I...
09:47:11 <aristid> kyagrd: perhaps use a query with lambdabot for those experiments?
09:47:14 <kyagrd> what was the command I forgat
09:47:16 <geekosaur> kyagrd, there's no way to get rid of a single definition; don't bother
09:47:20 <geekosaur> hm
09:47:24 <zungaloca> Occurs check: cannot construct the infinite type: t0 = [t0]     In the first argument of `(*)', namely `x'     In the expression: x * y     In the expression: [x * y | x <- xs, y <- xz]
09:47:26 <geekosaur> or maybe there is these days
09:47:47 <geekosaur> zungaloca, there must be more there that you aren't showing us, then
09:47:51 <geekosaur> @list run
09:47:51 <lambdabot> eval provides: run let undefine
09:47:56 <geekosaur> there you go
09:47:59 <geekosaur> @undefine func
09:48:11 <geekosaur> wonder when that was added... or was it?
09:48:12 <geekosaur> @bot
09:48:12 <lambdabot> :)
09:48:16 <geekosaur> just silent
09:48:32 <zungaloca> func34 xs = [if x >10 then "qwer"else "ty"|x<-xs,odd x]  func35 y xs = [x|x<-[1..20],x/=xs,x/=y] func35 xs xz = [x*y|x<-xs,y<-xz]
09:48:55 <rwbarton> does that work?!
09:48:57 <rwbarton> @type func
09:48:58 <lambdabot> Not in scope: `func'
09:49:00 <zungaloca> testing out func after func no pattern matching intended
09:49:07 <rwbarton> @let test = "test"
09:49:08 <kyagrd> oh, I found the package for diagrams
09:49:08 <lambdabot>  Defined.
09:49:13 <rwbarton> @let test2 = "test2"
09:49:14 <lambdabot>  Defined.
09:49:14 <kyagrd> ghci-diagrams
09:49:18 <geekosaur> all on the same line?  I hope not
09:49:21 <rwbarton> @undefined test2
09:49:22 <zungaloca> no
09:49:23 <kyagrd> I only searched with diagrams-* :(
09:49:26 <typoclass> zungaloca: people can help you better if you put your code and the complete error message on hpaste, and if you ask a specific question
09:49:28 <typoclass> @where hpaste
09:49:28 <rwbarton> > test
09:49:28 <lambdabot> http://hpaste.org/
09:49:29 <lambdabot>   Not in scope: `test'
09:49:40 <rwbarton> right it just undefines everything
09:49:49 <typoclass> rwbarton: lambdabot is also available privately
09:50:04 <kyagrd> hopefuly ghci-diagrams compile in ghc 7.4 or higher ...
09:50:05 <rwbarton> I was demonstrating its functionality or lack thereof
09:50:12 <geekosaur> zungaloca, I see it now.  you have two func35 and it's trying to reconcile them
09:50:31 <kyagrd> oh it doesn't :(
09:50:38 <hpaste> zungaloca pasted “test.hs” at http://hpaste.org/74754
09:50:41 <geekosaur> (multiple declarations like that turn into a single definition with a case statement doing pattern matching to distinguish; so they need to be compatible)
09:50:55 <zungaloca> dumb mistake
09:51:15 <geekosaur> make the last one func36 and it should work
09:52:16 <zungaloca> yep THNX
09:54:37 <mkramer> I have a question about Haskell type visualization. I have a file full of a large number of type declarations, and these type declarations refer to each other, in effect creating a type graph
09:54:50 <mkramer> Is there a program I can run to create a visualization of that graph?
09:55:10 <luite> yes, vacuum
09:55:21 <rwbarton> there was a project like this
09:55:38 <rwbarton> for the graph of modules importing other modules I think
09:55:54 <luite> a more recent project is ghc-vis, but i haven't tried that
09:56:19 * hackagebot rdf4h 1.0.0 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.0.0 (RobStewart)
09:56:21 <mkramer> nifty! I love Haskell :) so many of the clever things that could be done have actually be done
09:56:38 <rwbarton> @hackage SourceGraph
09:56:38 <lambdabot> http://hackage.haskell.org/package/SourceGraph
09:57:38 <luite> oh right SourceGraph is probably what you're after, i thought yu wanted a graph of runtime things
09:57:49 <rwbarton> e.g. http://code.haskell.org/~ivanm/Sample_SourceGraph/SourceGraph/graphs/imports.svg
09:57:54 <rwbarton> I don't see anything for types though
09:58:46 <mkramer> Hmm, neither do I
09:58:56 <luite> it does collect data declarations
09:59:03 <rwbarton> but it does similar things, so that should not be too hard to add
09:59:03 <luite> dunno if it can output them to a graph
09:59:16 <zungaloca> "let" several functions same time
09:59:32 <luite> hm, you'd probably need to typecheck everything to do it properly
09:59:38 <luite> which SourceGraph probably doesn't
10:01:40 <zungaloca> ??
10:02:23 <geekosaur> zungaloca, what exactly are you asking?
10:02:53 <zungaloca> let ch = ["ugly","you dawg","funny"], st = ["troll","cooling","pooping"] in [cha++" "++str|cha<-ch,st<-str]
10:02:54 <geekosaur> "zungaloca> "let" several functions same time" I can think of several interpretations of that and am not sure which you mean
10:03:10 <geekosaur> almost right
10:03:16 <geekosaur> you need a semicolon between them
10:03:25 <geekosaur> and if you aren;t using layout you may need braces
10:03:43 <geekosaur> > let ch = ["ugly","you dawg","funny"]; st = ["troll","cooling","pooping"] in [cha++" "++str|cha<-ch,st<-str]
10:03:44 <lambdabot>   Not in scope: `str'Not in scope: `str'
10:03:52 <geekosaur> > let ch = ["ugly","you dawg","funny"]; str = ["troll","cooling","pooping"] in [cha++" "++str|cha<-ch,st<-str]
10:03:53 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:03:53 <lambdabot>         against inferred type...
10:04:10 <geekosaur> oops, not quite
10:04:23 <geekosaur> > let ch = ["ugly","you dawg","funny"]; str = ["troll","cooling","pooping"] in [cha++" "++st|cha<-ch,st<-str]
10:04:25 <lambdabot>   ["ugly troll","ugly cooling","ugly pooping","you dawg troll","you dawg cool...
10:04:41 <watermind> if I map a list containing elements who's representation in shared, will the sharing be preserved? e.g.   map f $ replicate k structure
10:04:46 <geekosaur> getting the right names in the right places also helps...
10:05:04 <watermind> in GHC that is
10:05:22 <zungaloca> lol thnx'
10:06:19 * hackagebot hsparql 0.2.0 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  http://hackage.haskell.org/package/hsparql-0.2.0 (RobStewart)
10:10:34 <ParahSai1in> hm, i have a list of items that need to be separated into N bins, which will eventually be written into N different files. i want to minimize number of IO actions
10:10:52 <ParahSai1in> anyone know of some sort of functionality in a haskell library that might be relevant?
10:11:28 <ParahSai1in> it would be nice if i could turn that one list into N different lists that could be lazily written to disk
10:13:54 <Mortchek> ParahSai1in, too many items to hold them all in memory at once?
10:15:24 <ParahSai1in> Mortchek: probably
10:16:07 <ParahSai1in> :t partition
10:16:08 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:16:18 <ParahSai1in> similar to that, i guess
10:16:49 <Mortchek> ParahSai1in, maybe read them n at a time, sort into bins in memory, write them out, repeat until done. Probably a kind of naïve solution, so I don't know if there are any specific problems with that.
10:17:07 <Mortchek> This is assuming you can simply concat to the files.
10:17:21 <Mortchek> s/concat/append/
10:17:44 <ParahSai1in> :t select
10:17:45 <lambdabot> Not in scope: `select'
10:18:42 <Mortchek> Probably wouldn't be hard to write a generalized n-partition
10:19:51 <paolino> :t foldr partition
10:19:52 <lambdabot>     Couldn't match expected type `[a]'
10:19:52 <lambdabot>            against inferred type `([a], [a])'
10:19:52 <lambdabot>     In the first argument of `foldr', namely `partition'
10:20:09 <kyagrd> rwbarton, goloss is cool! thanks
10:20:19 <ParahSai1in> im gonna need to partition according to a tree structure lookup of some sort
10:20:21 <rwbarton> so I've heard :)
10:21:16 <paolino> :t mapAccumL (flip partition)
10:21:17 <lambdabot> forall a. [a] -> [a -> Bool] -> ([a], [[a]])
10:21:19 * hackagebot generic-deriving 1.2.2 - Generic programming library for generalised deriving.  http://hackage.haskell.org/package/generic-deriving-1.2.2 (JosePedroMagalhaes)
10:21:21 * hackagebot alpha 0.9 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9 (MarcCoiffier)
10:23:45 <ocharles> how do I choose RTS options to run my executable?
10:23:54 <ocharles> so far I just have +RTS -N4, because I have 4 cores
10:24:40 <ocharles> of course, I might not even want -threaded :)
10:25:24 <Shapeshifter> Uhm, how do I pass -10 as a function to be applied to a number? (+10) 20 returns 30 (because execution order doesn't matter), but ((-)10) 20 returns -10, because that's 10 (-) 20. I'd want to pass (-10) in such a way that it's applied to the right side of 20, so I get 20-10.
10:25:27 <rwbarton> maybe you can adapt this: http://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/
10:25:43 <paolino> Shapeshifter, subtract
10:26:02 <Shapeshifter> paolino: ah, thanks
10:26:23 <roconnor> Shapeshifter: negate?
10:26:30 <roconnor> oh wait
10:26:33 <roconnor> subtract
10:26:35 <roconnor> :D
10:28:16 <paolino> > flip (-) 10 20
10:28:18 <lambdabot>   10
10:29:11 <Shapeshifter> cool
10:29:16 <ocharles> is it possible to build an executable with profiling, without rebuilding all its dependencies?
10:29:40 <ocharles> and somewhat related, is there a downside of compiling libraries with profiling?
10:30:09 <rwbarton> the profiling versions will be slower and building both takes twice as long
10:30:18 <ocharles> oh, you can have both installed?
10:30:40 <rwbarton> yes. I have "library-profiling: True" in .cabal/config and that seems to do the trick
10:30:47 <ocharles> yep, i'm going to add that now :)
10:30:58 <ocharles> i thought i'd end up slowing everything down even if I didn't want profiling in the end
10:33:22 <ski> > map (subtract 1) (iterate (2 *) 1)
10:33:23 <lambdabot>   [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,...
10:39:12 <ParahSai1in> @src mapM
10:39:12 <lambdabot> mapM f as = sequence (map f as)
10:42:47 <roconnor> why does transformers require the program ar?
10:43:26 <ParahSai1in> @src partition
10:43:26 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
10:43:26 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
10:43:26 <lambdabot>                               | otherwise = (ts, x:fs)
10:44:37 <roconnor> oh wait it is cabal that appears to require ar
10:50:41 <geekosaur> roconnor, ar is used with static archives; unless you have a version of ghc that defaults to building dynamic libraries for everything (I think this only works on a handful of platforms currently?), you'll need ar
10:51:34 <deech> Hi all, does ghc 7.6.1 support arithmentic operations on the type level number literals?
10:51:57 <geekosaur> ...and I haven't looked to see if the dynamic library stuff doesn't go through a static-like step (like some versions of libtool seem to)
10:52:33 <roconnor> geekosaur: gotcha
10:52:50 <roconnor> geekosaur: is this a cabal thing or a ghc thing?
10:52:55 <geekosaur> ghc
10:54:11 <geekosaur> the default is to build haskell libraries static on most platforms, and ar is required for that.  (quick check:  if your ghc packages have .a files, ar is mandatory)
10:55:06 <geekosaur> if they have .so files, it's not so clear; I haven't tried to do dynamic libs with ghc as yet, but I know various other build systems use static intermediaries to simplify crossplatform stuff
10:55:53 <roconnor> ghc --make works fine
10:56:16 <roconnor> so does cabal build
10:56:24 <geekosaur> program or library?
10:56:36 <roconnor> library
10:57:00 <geekosaur> hm
10:57:22 <roconnor> anyhow I'll let the nix people figure it out
10:57:41 <geekosaur> think you need someone who knows cabal internals then.  possibly you are on a plafform that does dynamic libraries but cabal-install hasn't caught up with that?
10:57:55 <Shapeshifter> When someone says that pattern matching is the "only possible way to deconstruct data", does this mean that for example, there is no way of 'retrieving' the 1 from 'Just 1', other than pattern matching?
10:58:05 <Botje> correct.
10:58:25 <roconnor> geekosaur: I just don't have ar in my path by default
10:58:28 <Shapeshifter> I see.
10:58:38 <geekosaur> (solaris lives?)
10:58:56 <Botje> Shapeshifter: this way you are forced to deal with both cases.
11:04:23 <fmap> not really forced, haskell can have partial function, but compiler can warn you if you didn't deal with both of them
11:05:28 <c_wraith> well.  The type forces you to at least think about the possibility that there are more cases
11:06:44 <twmb> How viable are happstack or yesod for building a website
11:06:45 <twmb> ?
11:07:04 <rudyl313> viable
11:07:08 <c_wraith> Both are good.  So's Snap.  (I have to point it out, since I'm a contributor to is)
11:07:37 <roconnor> grrr
11:07:56 <roconnor> cabal install cabal-dev just builds fake-ghc-cabal-dev
11:07:58 <Shapeshifter> In that case, what's a short way of writing something like this: http://hpaste.org/74761 The first guard is just my attempt, but using '1' instead of what is inside the Just. Basically, if any of "Just ['1'..'4']" applies, I want that value to be used on the right side...
11:08:00 <roconnor> why?
11:08:09 <paolino> Shapeshifter, it took some time to me to understand what are datatypes, if this was the question behind deconstruction
11:09:09 <twmb> rudyl313, c_wraith: so all of these are good alternatives to php/RoR/Go/python/anything?
11:09:19 <rwbarton> transformSnake game (Just c) | c `in` ['1'..'4'] = ...
11:09:22 <rwbarton> er
11:09:23 <roconnor> oh wait
11:09:24 <rwbarton> `elem`
11:09:51 <c_wraith> twmb: If you're familiar with haskell, and comfortable with the state of libraries for working with other things you'll want (like databases, etc), then yes.
11:09:58 <Shapeshifter> Ahh, so *that's* how pattern matching and guards can be combined ^^
11:10:20 <paolino> Shapeshifter, guards are exclusive
11:10:35 <twmb> c_wraith: not yet, but I'd like to be; if it can do what I eventually need, that's more motivation for me to start learning haskell... now.
11:10:40 <rwbarton> one pattern can have many guards
11:10:57 <rwbarton> so the next line may be     | c `in` "XYZ"
11:11:06 <rwbarton> then later  transformSnake game Nothing = ...
11:11:50 <rwbarton> (ugh, where is this `in` nonsense coming from)
11:12:19 <c_wraith> twmb: ah.  Then yes.  They certainly can be used for building web sites.  (in fact, Snap is powering one of our servers at the company I work at.)  But there's a lot to learn.  Have fun with it. :)
11:12:42 <c_wraith> actually, come to think of it, two of our services run on snap, not just one.
11:12:43 <twmb> c_wraith: my plan is learn you a haskell, followed by real world haskell.. and then tbd
11:14:37 <atriq> Okay, I've messed up installing Haskell and don't have the docs for the Haskell Platform locally
11:14:51 <atriq> As in, module docs
11:25:32 <ParahSai1in> what does a tilde mean in this context select p x ~(ts,fs)
11:26:11 <shachaf> @google tilde haskell
11:26:12 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Laziness
11:26:12 <lambdabot> Title: Haskell/Laziness - Wikibooks, open books for an open world
11:26:29 <shachaf> That. :-)
11:26:41 <rwbarton> you can also look it up on hoogle!
11:26:47 <shachaf> You can?
11:26:53 <rwbarton> http://www.haskell.org/hoogle/?hoogle=~
11:27:11 <shachaf> whoa, dude
11:27:13 <shachaf> Fancy.
11:27:23 <c_wraith> wow.  I had no clue hoogle could do that.
11:27:25 <shachaf> Is that recent?
11:27:39 <rwbarton> I think it's been around a while
11:27:50 <c_wraith> that's really handy, though
11:28:16 <c_wraith> It means we can point people at hoogle to look up any symbol, not just operators
11:28:26 <rwbarton> @hoogle ~
11:28:26 <lambdabot> keyword ~
11:28:26 <lambdabot> Test.HUnit.Base (~:) :: Testable t => String -> t -> Test
11:28:26 <lambdabot> Test.HUnit.Base (~=?) :: (Eq a, Show a) => a -> a -> Test
11:28:30 <rwbarton> this isnt very useful though
11:28:33 <c_wraith> no.
11:37:27 <rwbarton> hmm. does Data.Vector.Unboxed take a particular long time/large amount of memory to build compared to other modules in vector?
11:37:46 <c_wraith> yes
11:37:54 <rwbarton> i see
11:37:55 <c_wraith> it has about a billion things inlined
11:37:59 <osa1> so I have a yacc grammar specification with lots of left-recursions and I want to port that code to Parsec, do we have any ways to parse left-recursions in Parsec or do I have to eliminate them manually ?
11:38:08 <c_wraith> it takes GHC quite a while to compile it.
11:38:41 <c_wraith> osa1: clever use of try is your main option without refactoring
11:39:01 <c_wraith> but beware of clever use of try - it's hard
11:39:27 <osa1> c_wraith: hmm, do you have any examples ?
11:39:39 <osa1> c_wraith: actually I worked so hard to eliminate recursions before asking this
11:39:39 <geekosaur> might it be easier to port it to happy instead?
11:39:47 <osa1> geekosaur: yeah I'm also considering that option
11:39:51 <lpsmith> you might also consider happy,  the parser generator for Haskell.  It handles left-recursion
11:40:30 <geekosaur> I kinda suspect any yacc grammar is going to be far easier to port to happy than to parsec; yacc allows too many things that require severe refactoring to work sensibly in parsec
11:40:49 <osa1> does code generated with Happy have any dependencies ?
11:41:08 <t7> a haskell compiler
11:41:19 <osa1> t7: and no libraries ?
11:41:21 <rwbarton> oh hey, it finished building :)
11:41:31 <rwbarton> on my VM with 256 MB of memory
11:41:48 <t7> osa1: well the platform comes with happy and alex so i think all the required libs are in the platform
11:42:29 <lpsmith> rwbarton, what were you building?
11:42:48 <appamatto> Howdy. With Curry-Howard proofs are programs and theorems are types. Does it make sense that people then use the theorems (types) to prove things about the programs?
11:42:52 <rwbarton> Data.Vector.Unboxed
11:42:55 <geekosaur> ...256MB and you're surprised ghc takes a long time?
11:42:55 <appamatto> It seems backwards to me
11:43:28 <Rc43> Hi, guys.
11:43:29 <t7> appamatto: its a <-> process
11:43:36 <shachaf> Why does your VM have 256MB of memory?
11:43:43 <appamatto> t7, how do you mean?
11:43:43 <t7> you cant prove alot about a program without dependent types
11:43:50 <rwbarton> well, it built 60ish other modules without problems before this one
11:44:00 <c_wraith> rwbarton: if you need to compile vector-algorithms, schedule it while you're asleep. :)
11:44:01 <t7> i can prove that my program reterns its second arguement ...
11:44:08 <rwbarton> thanks for the tip :)
11:44:11 <geekosaur> appamatto, the program is a collection of types, so you are generally working up from simple to complex.  but there is some back and forth involved
11:44:32 <geekosaur> (in this view)
11:44:51 <appamatto> Hmm, so dependent types allow you to not only write proofs (programs) but also write proofs _about_ the programs?
11:45:07 <t7> appamatto: the curry howard corispondence means that from types you can infer terms and from terms you can infer types
11:45:19 <t7> appamatto: exactly
11:45:28 <rwbarton> shachaf, it's a rackspace VM that I usually don't use and so keep at a low configuration most of the time. I can give it more RAM
11:45:37 <Rc43> Suppose, I have GADT named X with parameter a.
11:45:38 <Rc43> Is it right that the only function which return value with arbitrary parameter is one of X's constructors?
11:45:50 <Rc43> (Or existentially typed function.)
11:46:06 <Rc43> (like `forall a . Something -> X a`)
11:46:43 <appamatto> t7: infering types from terms is normal type inference, but infering terms from types is automatic theorem proving, no?
11:47:07 <appamatto> or is it logic programming?
11:47:50 <t7> theorem prover. i think you need a SAT solver or something to get the term from a type
11:47:59 <t7> look at 'djinn' source code
11:48:33 <Rc43> Hmm, it seems, that even existentially typed function canot be such.
11:48:57 <Rc43> So only GADT constructor can return value of its type with arbitrary parameter?
11:49:03 <appamatto> So is there something that dependent types correspond to in mathematics?
11:49:31 <Rc43> OR GADT == arbitary type parameter ?
11:49:32 <appamatto> Proof theory or something?
11:51:47 <Saizan> appamatto: when seen as logics they are pretty close to multi-sorted higher order predicate logics
11:52:22 <schovi> Hello. Silly question not exactly haskell one, but.. When i create redis connection it is just prepared for work, or it use some resource to keep connection open?
11:52:27 <Saizan> appamatto: but i do feel like proof theory is a good fit as far as reasoning about them goes
11:53:46 <Saizan> appamatto: my answer to your original question would be that these theorems get to talk about properties of other proofs
11:57:37 <appamatto> Saizan: that makes sense, if the type system is complex enough
11:58:01 <appamatto> It's interesting that even a basic type system guarantees that the program will be well behaved in some basic sense
11:58:20 <appamatto> I guess the "proof" of that is done externally to the type system by the guy who designs the language
12:01:04 <paolino> Rc43, how is X a different from X Int ? Btw only X constructors can build X type values
12:02:33 <Rc43> paoline, I am already understood that I have said silly things :) But I just can't understand how I can (if I can) build parser for this example (http://en.wikibooks.org/wiki/Haskell/GADT)
12:02:47 <Rc43> paoline, because I need function like `String -> Expr a`.
12:03:36 <Rc43> paoline, not with any `a`, but with that `a` which have ben parsed.
12:05:28 <geekosaur> Rc43, you can't really specify that without a forall; "String -> Expr a" means the *caller* sets the type of a
12:07:54 <paolino> geekosaur, is it different from read :: String -> a ?
12:08:20 <Rc43> geekosaur, yes, but it isn't what I want; "user" wants parse string and get unknown early parameter
12:09:05 <Rc43> geekosaur, so not `parse "(1 + 1) * 3" :: Int`, but `print $ parse "(1 + 1) * 3"`.
12:09:13 <geekosaur> paolino, it is different, read uses the caller specified type to select a parser for the String, it does not blindly parse and return the inferred type of the thing parsed
12:09:56 <geekosaur> Rc43, yes, I got that.  my point is you want something that makes no real sense in haskell
12:10:06 <Rc43> geekosaur, it is like dynamic types, so I think existential types can help there
12:10:24 <rwbarton> sure
12:10:29 <rwbarton> you can also do it with the continuation style
12:10:40 <rwbarton> String -> (forall a. Expr a -> r) -> r
12:10:43 <Rc43> rwbarton, ooooh
12:10:46 <Rc43> rwbarton
12:10:51 <Rc43> it is nice ^^
12:10:58 <geekosaur> you can use a forall (String -> (forall a. Expr a)) or maybe dynamics, but this gets ugly quickly.  also leaves the question of whether you're doing what you really want
12:11:01 <rwbarton> I don't know if I'd go that far
12:11:09 <Rc43> Nonono, only continuations :D
12:11:19 <Enigmagic> or "String -> (Expr Int -> r) -> (Expr Double -> r) -> r" if you have a small number of types you're going to support
12:12:00 <Enigmagic> that avoids the need for typeclasses and rank-2 types
12:12:07 <shachaf> Enigmagic: Why that rather than Either (Expr Int) (Expr Double)?
12:12:22 <Enigmagic> shachaf: same idea
12:12:35 <Rc43> geekosaur, "also leaves the question of whether you're doing what you really want" -- I want to implement compiler for simple language; first of all I think interpreter would be nice; but specifying type by user seems strange for me
12:12:43 <Enigmagic> or Expr (Either Int Double) :P
12:13:12 * shachaf wonders what a higher-rank Either would be.
12:13:15 <shachaf> (Either Expr Blah) a
12:13:20 <geekosaur> Rc43, sounds to me like that's one of the justified uses, actually; I worry about the folks trying to write Perl in Haskell
12:14:09 <Rc43> geekosaur, sorry, didn't understand about perl =/
12:14:37 <Rc43> BTW, I have only int type and (suddenly) objects
12:17:37 <Enigmagic> Rc43: you could just write "String -> Expr (Either Int Object)" then, depending on how you represent objects..
12:18:27 <Rc43> Enigmagic, ah, you did mean this... there will be a lot of different types as parameter.
12:18:48 <Philippa> what are the current recommendations for a linux distro to mess around with the Platform and Agda on? My debian-fu appears to be weak
12:18:48 <Rc43> Enigmatic, and it is kind of hardcode, I think.
12:19:17 <Philippa> (by which I mean: I tried installing both squeeze and wheezy on VMs and things broke in different ways I cba to fix)
12:19:42 <paolino> I still cannot understand how it is different from read, to parse something the code must try the type
12:20:23 <Philippa> no, the code has to build something of that type
12:20:46 <Philippa> with read, the caller says what (monomorphic) type that should be
12:21:16 <Philippa> when you parse a typeful AST, you don't fully know what type it'll be - you're going to get /back/ something polymorphic
12:21:28 <geekosaur> ^^
12:21:33 <Philippa> you know that there'll exist some type such that you're holding an AST for that type, effectively
12:22:20 <Rc43> paoline, there is such difference: in `read` case we have a lot of ways to parse string; in `parse` case for any string there is only one value which can be parsed from it (by semantics of my lang), so it is ideologically incorrect to specify type
12:22:34 <Rc43> not sure that I am right, get this thought just now
12:25:01 <Philippa> Rc43: in read's case, by the time you've finished typechecking there's also only one type it's allowed to read at
12:25:14 <Philippa> it might be helpful if we introduce System F here
12:25:48 <Philippa> GHC translates your code into a language based (in part) on it
12:26:08 <Philippa> the main thing about it is the way you write polymorphic values
12:26:37 <Philippa> for example, id = /\t -> \x::t -> x
12:26:44 <Philippa> id :: forall t. t->t
12:26:58 <Philippa> the /\ represents a capital lambda - it's a "type lambda"
12:27:11 <Philippa> now I get to decide which notation I'm using for type application :-)
12:27:25 <Philippa> Okay, so you can't just call that id as, say, id 1
12:27:32 <Philippa> because this is the point of having System F
12:27:42 <Philippa> you have to write, say, id [Int] 1
12:27:53 <Philippa> id [Int] is applying id to the type [Int]
12:27:57 <Philippa> does this make sense?
12:27:58 <_ben> @check \a b -> a / b == a - (a/b)
12:27:59 <lambdabot>   "Falsifiable, after 0 tests:\n-1.0\n-2.0\n"
12:28:12 <Philippa> (can you see why the type is forall t. t -> t?)
12:28:31 <paolino> yes
12:30:17 <Philippa> okay. If we forget about type classes for now, that's /all the polymorphism you're allowed/.
12:30:35 <ParahSai1in> @hoogle nomatch
12:30:35 <lambdabot> No results found
12:30:49 <Philippa> admittedly that's a bit cheaty when it comes to GADTs, but we're not going to match on them, just build them. So that's okay for now.
12:30:57 <paolino> Philippa, why [Int] ?
12:31:22 <Philippa> I'm abusing [] as the brackets to indicate "this is a type application", because it's a moderately common notation for it
12:31:24 <paolino> {Int} ?
12:31:30 * Rc43 explored that GADT cannot "derive"
12:31:30 <paolino> ah
12:31:53 <Philippa> if we were speaking a curly brace language it'd be <>, of course
12:32:25 <Philippa> so read :: forall a. Read a => String -> a
12:32:59 <Philippa> if we ignore the Read a constraint for now, we can look at that type and see that it must have a type lambda at the outside - it wants a type, and then a String, and then it'll read you something of that type
12:33:04 <ben> @check \a -> a > 0 ==> a `div` 2 == a - a `div` 2
12:33:05 <lambdabot>   Not in scope: `==>'Precedence parsing error
12:33:05 <lambdabot>      cannot mix `GHC.Classes.>'...
12:33:09 <rwbarton> if I installed a bunch of packages before haddock is there a way to build the documentation for all of them without actually rebuilding the packages?
12:33:11 <ben> how does this go again
12:33:13 <Philippa> Haskell will fill in the type application for us, but it works equivalently to that still
12:33:27 <paolino> (RC43 you are more lucky with StandaloneDeriving)
12:33:28 <johnw> anyone know how to use makeClassy with a type "Foo a"?
12:33:34 <Cale> @check \a -> (a > 0) ==> (a `div` 2 == a - a `div` 2)
12:33:35 <lambdabot>   Not in scope: `==>'
12:33:42 <Cale> oh
12:33:45 <Cale> hrm
12:33:53 <ben> well
12:34:00 <ben> @check \a -> a > 0 && a `div` 2 == a - a `div` 2
12:34:01 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
12:34:10 <ben> err, the other way around
12:34:16 <ben> @check \a -> a <= 0 || a `div` 2 == a - a `div` 2
12:34:17 <lambdabot>   "Falsifiable, after 1 tests:\n1\n"
12:34:31 <ben> curse integer arithmetic
12:34:37 <Rc43> Philippa, you are talking about that we everytime must specify type, but sometimes it is specified implicitly?
12:35:18 <Rc43> paolino, standalonederiving is applied to constructors, right?
12:35:21 <Philippa> Rc43: more than that. Haskell doesn't have type applications at all! But when GHC compiles, it compiles via a language that does
12:35:23 <Saizan> rwbarton: no easy one
12:35:33 <rwbarton> hmm okay, thanks
12:35:43 <paolino> Philippa, ok
12:36:01 <Rc43> Philippa, isn't language with type application "more powerfull"?
12:36:34 <Philippa> No, you can always infer where the applications would go. GHC allows you to use type annotations to provide the information that would go inside them
12:37:20 <Philippa> it even infers type lambdas that way. Sometimes I'd rather be allowed to write the type lambdas out, but that's life for you
12:37:41 <Philippa> but you can use annotations to build an equivalent of any System F term you like
12:38:11 <paolino> so read [Int] "1" -> 1
12:38:30 <Philippa> I'd use => for "reduces to", but yes. 1 :: Int, even
12:38:58 <armlesshobo> > read "1" :: Int
12:38:59 <lambdabot>   1
12:41:42 <Rc43> paolino, can't make StandaloneDeriving work; it is just ignored bu ghci
12:42:56 <paolino> deriving instance Read (Expr a) ?
12:43:24 <Rc43> paolino `deriving instance Show (Expr a)`
12:44:09 <Rc43> paolino, and it gives error `parse error on input `instance'`
12:46:15 <appamatto> What's the process for unifying forall a. a -> a    and   Int -> Int
12:47:09 <Philippa> appamatto: you don't
12:47:21 <Philippa> what you unify is "a -> a" and "Int -> Int"
12:47:53 <Philippa> when unification happens, you've already "instantiated" forall a. a -> a - you've replaced those as with fresh (meta)variables
12:48:05 <appamatto> Oh I see
12:48:11 <appamatto> sort of like logic variables
12:48:23 <Philippa> in other words, "I've got to put a type application here, now what do I fill it in with?"
12:48:36 <Philippa> and even more like constraint logic variables, yes :-)
12:48:36 <rwbarton> "some type that we are going to (partially) determine", rather than "any type"
12:48:59 <Philippa> you can treat type inference as a constraint logic problem with a great deal of success
12:49:06 <rwbarton> (or better "the type bound by the quantifier")
12:49:26 <Philippa> yeah. There's an implicit meta-level existential quantifier around the new variables
12:49:42 <Philippa> "there exists some type a, which we may or may not figure some stuff out about"
12:50:26 <rwbarton> was that the answer to your question?
12:51:14 <monochrom> I think appamatto knows prolog and unification
12:51:35 <appamatto> Yes, I think that answers my question
12:56:40 <mkramer> I have a really frustrating problem: whenever I try to use cabal to install a hackage package, I get this: "cabal: data is not in tar format"…even if it is
12:57:03 <monochrom> that's strange
12:57:34 --- mode: ChanServ set +o monochrom
12:57:41 <mkramer> if I point to an untarred .cabal file, I get the same message
12:57:43 --- topic: set to '["GHC 7.6.1 http://v.gd/CEBRVo ","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
12:57:52 --- mode: monochrom set -o monochrom
12:58:21 <Rc43> Can I implement something like `instance Show a => TypeClass a where ..... instance NOT Show a => TypeClass a where` ?
12:58:34 <hpaste> mkramer pasted “what's not in tar format?” at http://hpaste.org/74766
12:58:40 <shachaf> Rc43: No.
12:59:07 <rwbarton> i bet something that's supposed to be a tar file is just empty
12:59:20 <monochrom> that looks like wrong use of "cabal install"
12:59:21 <Rc43> shachaf, even with default implementations?
12:59:27 <rwbarton> oh
12:59:42 <Rc43> shachaf, I mean default class implementation
12:59:50 <monochrom> just cd into fgl-5.4.2.4 and type "cabal install". add -v if you like
13:00:08 <shachaf> Rc43: What happens to a program that does that when a new Show instance is defined?
13:00:45 <hpaste> mkramer pasted “Same thing” at http://hpaste.org/74767
13:01:17 <mkramer> And it's the same thing if I type the package and try to have it download as well
13:01:19 <Rc43> shachaf, hmm, just switch to new behaviour, why not?
13:01:25 <mkramer> It doesn't matter what the package is, either
13:02:21 <rwbarton> I imagine some file in your ~/.cabal is corrupted
13:02:27 <mkramer> I was about to say that
13:02:32 <mkramer> should I just blow that away rwbarton?
13:03:00 <rwbarton> i don't know
13:03:12 <MagneticDuck> hi
13:03:13 <dncr> can anyone point me to info as to why GHC.Generics was created when Data.Data already exists?
13:03:16 <mkramer> I moved it out of the way … it's making progress now
13:03:56 <MagneticDuck> sorry for saying hi.. playing with irc commands
13:04:09 <monochrom> we like hi
13:05:11 <dncr> i have to decide if i want to go w/ Generic or Data/Typeable for something..
13:05:32 <rwbarton> they are rather different no?
13:05:56 <Rc43> Hmm, so now I have `parse :: String -> (forall a. a -> r) -> r` and `eval :: Expr a -> a`.
13:06:01 <dncr> rwbarton: well i can find papers on Data/Typeable but nothing on GHC.Generics
13:06:16 <Rc43> Why type of `parse "1" eval` cannot be infered?
13:06:27 * MagneticDuck hi
13:06:30 <dncr> i know it's newer and my first impression is that it's more evil-y ghc-specific?
13:06:59 <rwbarton> I think of GHC.Generics as being more like what you'd get with Template Haskell "deriving".
13:07:05 <rwbarton> Except without all the associated pain
13:07:22 <c_wraith> GHC.Generics depends on one (rather small) extension
13:07:35 <c_wraith> Other than that, it'd work in non-GHC stuff pretty easily
13:07:50 <Rc43> Ohh, i need continuation in `eval`'s type, too...
13:08:02 <dncr> so you would prefer that all other things being equal?
13:08:09 <rwbarton> I haven't used it myself but that's the impression I've gotten from reading about it
13:10:31 <dncr> i.e. is it likely that in time binary-derive (using GHC.Generics) will be preferred to binary-generic (despite name uses Data.Data)
13:10:44 <Philippa> Rc43: monomorphism restriction/not defaulting r?
13:10:58 <Philippa> ...oh, no, that shouldn't matter
13:11:01 <Philippa> not if parse works
13:12:48 <Rc43> Philippa, yes, monomorphism restriction isn't cause
13:13:03 <Philippa> oh
13:13:22 <Philippa> you missed an Expr out in (forall a. a -> r), I suspect
13:13:33 <Rc43> Something wrong with this continuations hack. I still need to specify type, I think.
13:13:51 <rwbarton> well the trick is you can't actually write any function forall a. a -> r
13:14:19 <Rc43> Philippa, no; result is plain `a`.
13:14:32 <rwbarton> so either you can add a class constraint to a or you can follow the suggestion of having a separate continuation for each result type (or just using Either in the first place)
13:15:07 <dreixel> dncr: GHC.Generics is not evil at all! :)
13:15:13 <dreixel> it was even implemented first in UHC
13:15:18 <dreixel> original paper: http://dreixel.net/research/pdf/gdmh.pdf
13:15:50 <Philippa> Rc43: okay, (forall a. a-> r) is not going to unify with forall a. Expr a -> a
13:15:56 <dreixel> a more up-to-date version can be found on chapter 11 of http://dreixel.net/research/pdf/thesis.pdf
13:16:53 <Rc43> Philippa, ?
13:17:19 <Rc43> What is unification? Type inference?
13:17:50 <startling> Rc43, it's when the type inferer takes two type signatures and sees if they fit together
13:18:18 <hpc> and type checker
13:18:46 <startling> same thing !
13:19:15 <Rc43> rwbarton, if I had continuation `i :: Int -> IO () ... i x = print x` then I can use it like `parse "1" $ eval i` ? It doesn't work.
13:19:38 <rwbarton> because you cannot know that you are going to receive an Int
13:19:46 <rwbarton> read what I wrote above
13:19:56 <Rc43> rwbarton, yes; what did you mean by `separate cont` ?
13:19:59 <hiptobecubic> I'm not understanding how the Arbitrary class really works
13:20:09 <hiptobecubic> I understand that it's "for generating arbitrary values"
13:20:15 <rwbarton> parse :: String -> (Expr Int -> r) -> (Expr Bool -> r) -> ... -> r
13:20:37 <startling> hiptobecubic, look more closely at Gen
13:20:49 <Rc43> rwbarton, ooh, I got it
13:21:04 <rwbarton> but note this is just the same as String -> Either (Expr Int) (Expr Bool)
13:21:09 <Rc43> rwbarton, but it isn't pretty =/
13:21:11 <startling> hiptobecubic, Arbitrary is just a typeclass that lets you get a Gen with "arbitrary :: Gen Int" or whatever
13:21:27 <rwbarton> well somehow you have to write a function which is going to accept the result of the parse
13:21:31 <rwbarton> without knowing what the result type is
13:21:35 <rwbarton> how do you imagine that working
13:21:46 <rwbarton> you can do
13:21:49 <Rc43> rwbarton, can I use type call constraint or something?
13:21:56 <Rc43> *type class
13:22:00 <rwbarton> parse :: String -> (forall a. Show a => a -> r) -> r
13:22:02 <rwbarton> yes, I said this before
13:22:12 <rwbarton> < rwbarton> so either you can add a class constraint to a
13:22:47 <Rc43> rwbarton, yes, sorry ; didn't know synax with constraint and forall
13:23:01 <Rc43> rwbarton, now it seems it is what I want
13:23:55 <hiptobecubic> startling, aha. thanks
13:24:35 <Rc43> > "1"
13:24:35 <Rc43> > parse "1" $ show . eval
13:24:36 <lambdabot>   "1"
13:24:36 <lambdabot>   Not in scope: `parse'Not in scope: `eval'
13:24:37 <Rc43> yeaaaah
13:25:20 <Shapeshifter> Does someone know what the UI.HSCurses.Curses.timeout function actually does? http://hackage.haskell.org/packages/archive/hscurses/1.3.0.2/doc/html/src/UI-HSCurses-Curses.html#timeout I don't get it. I need behavior where the program waits for 100 miliseconds for user input and if there's none coming, continues with the do block. Putting something like Curses.timeout 1 just before my c <- Curses.getch seems to work misteriously, ...
13:25:26 <Shapeshifter> ... but it has odd side effects.
13:25:48 <hiptobecubic> So I have a recursive data type that looks like: data Form = Prop Name | Neg  Form | Cnj [Form] | Dsj [Form] | Impl Form Form | Equiv Form Form
13:26:18 <hiptobecubic> And I want to make an instance of Arbitrary for Form
13:26:23 * hackagebot wtk 0.2.1 - Wojcik Tool Kit  http://hackage.haskell.org/package/wtk-0.2.1 (BartoszWojcik)
13:26:25 * hackagebot rmonad 0.8 - Restricted monad library  http://hackage.haskell.org/package/rmonad-0.8 (GaneshSittampalam)
13:26:32 <hiptobecubic> So I can play with propositional logic
13:26:56 <Ralith> Enigmagic: kay, here's what I need to do and do not currently know how to:
13:26:59 <startling> hiptobecubic: look here: http://hackage.haskell.org/packages/archive/QuickCheck/2.5/doc/html/Test-QuickCheck-Gen.html
13:27:11 <hiptobecubic> But to generate a random value, I also need to generate a random Nmae if it happens to be a Prop
13:27:26 <Ralith> Enigmagic: functions of dynamically-determined type, and mutually recursive named structs
13:27:39 <Rc43> Is there any trick for checking string before `read`? I want do something like "if isInt x then read x :: Int else ..."
13:27:49 <startling> hiptobecubic: you probably want oneOf [Prop <$> arbitrary, Neg <$> arbitrary, Cnj <$> listOf arbitrary...]
13:28:00 <shachaf> Rc43: Text.Read.readMaybe will give you a Maybe.
13:28:01 <Shapeshifter> Does someone know what the UI.HSCurses.Curses.timeout function actually does? http://hackage.haskell.org/packages/archive/hscurses/1.3.0.2/doc/html/src/UI-HSCurses-Curses.html#timeout I don't get it. I need behavior where the program waits for 100 miliseconds for user input and if there's none coming, continues with the do block. Putting something like Curses.timeout 1 just before my c <- Curses.getch seems to work misteriously, ...
13:28:07 <Shapeshifter> ... but it has odd side effects.
13:28:07 <Shapeshifter> ah sorry...
13:28:10 <Rc43> It seems to be possible with fake argument like (undefined::Int) which is ignored in test function
13:28:12 <shachaf> Rc43: It's only available in GHC 7.6+, though.
13:28:18 <Shapeshifter> didn't mean to double post. apologies.
13:28:18 <Cale> hiptobecubic: instance Arbitrary Form where arbitrary = oneof [fmap Prop arbitrary, fmap Neg arbitrary, fmap Cnj arbitrary, fmap Dsj arbitrary, liftM2 Impl arbitrary arbitrary, liftM2 Equiv arbitrary arbitrary]
13:28:20 <Rc43> schaf, thanks
13:28:38 <MostAwesomeDude> Shapeshifter: What kind of side effects? Why do you need to wait for more user input?
13:28:40 <shachaf> Rc43: Until then, you can fake it using Text.Read.reads, though there's a bit more of a song and dance involved in that.
13:28:43 <Rc43> schachaf, I want to use it in equation guard
13:29:09 <startling> hiptobecubic: N.B. you may want to not use listOf, the lists it generates can be pretty long
13:29:23 <Rc43> schachaf, most convinient way is to use parsec, I think; but I don't want to get extra dependency
13:29:33 <Shapeshifter> MostAwesomeDude: I'm writing a snake clone in haskell for fun. The main loop will need to allow for user input (to change direction), but in case there's no input, I still need to get the loop to continue.
13:29:46 <hiptobecubic> Cale, startling thanks. I'll have to sit for a minute and figure out what's going on there, but i think i see
13:30:10 <Shapeshifter> MostAwesomeDude: so right know I use this timeout function and it seems like getch is not blocking anymore. I also use a s threadDelay
13:30:22 <startling> oh, oops, missed Cale's suggestion.
13:30:32 <startling> hiptobecubic, applicative style may be useful here
13:30:36 <MostAwesomeDude> Shapeshifter: I'd probably kick curses into non-blocking mode, yeah.
13:31:02 <hiptobecubic> so we fmap the constuctor into the functor arbitrary
13:31:02 <Cale> hiptobecubic: instance CoArbitrary Form where coarbitrary p = case p of Prop n -> variant 0 . coarbitrary n; Neg f -> variant 1 . coarbitrary f; Cnj xs -> variant 2 . coarbitrary xs; Dsj xs -> variant 3 . coarbitrary xs; Impl f f' -> variant 4 . coarbitrary f . coarbitrary f'; Equiv f f' -> variant 5 . coarbitrary f . coarbitrary f'
13:31:07 <Shapeshifter> MostAwesomeDude: Ah, so there's a way to switch modes... I'll look it up
13:31:39 <Cale> hiptobecubic: Basically, we use arbitrary to get each of the arguments to the constructor and then apply the constructor to the result
13:31:42 <Cale> (s)
13:31:59 <hiptobecubic> riht
13:32:03 <mm_freak_> edwardk: i revisited your (b ->) proposal as an alternative to VectorSpace, but found that it's unfortunate
13:32:20 <mm_freak_> edwardk: it's slower for vector arithmetic and also disallows the function space
13:32:21 <Cale> hiptobecubic: and then in the opposite direction with coarbitrary, we can use variant to differentiate each of the constructors, and compose in the coarbitraries of the arguments
13:32:22 <dmwit> hm
13:32:24 <hiptobecubic> and so eventually we get down to an arbitrary Prop at the end of the chain
13:32:32 <dmwit> If the new GHC doesn't build some FFI code, is that a bug in GHC?
13:32:40 <edwardk> mm_freak_: i actually use representable functors rather than use that directly
13:32:45 <dmwit> The release notes mention the addition of a new calling convention, but not the removal of any old features.
13:32:51 <shachaf> dmwit: That depends on the code.
13:32:58 <dmwit> um
13:32:59 <edwardk> then the representability of (->) permits that
13:33:14 <dmwit> shachaf: I should add the assumption that old (7.4) GHC does build the same FFI code.
13:33:26 <mm_freak_> edwardk: does that solve the speed problem, too?
13:33:33 <shachaf> dmwit: Well, the answer is probably "maybe". :-)
13:33:41 <shachaf> Depends on the code and the error.
13:33:43 <dmwit> Should I ask on #ghc?
13:34:09 <hiptobecubic> Cale, the coarbitrary is totally new. No we're generating arbitrary functions instead of values?
13:34:16 <shachaf> You should @paste the code if it's small. :-) But #ghc is probably a good place to ask about GHC bugs.
13:34:37 <Cale> hiptobecubic: Basically that's what it's for.
13:34:46 <dmwit> I've seen it now in X11 and gtk2hs, neither of which is small.
13:34:55 <dmwit> one sec
13:34:57 <Cale> hiptobecubic: You need an instance of Coarbitrary a and Arbitrary b in order to generate random functions a -> b
13:35:11 <edwardk> mm_freak_: yes
13:35:23 <edwardk> mm_freak_: notably it fixes the asymptotics of the solution
13:35:25 <Cale> hiptobecubic: basically what happens is that the argument to the function is modified by the coarbitrary implementation, based on the value that it gets
13:35:30 <shachaf> dmwit: I built X11 with GHC 7.6.
13:35:32 <Cale> er, sorry
13:35:44 <Cale> The *random generator* is modified
13:35:45 <dmwit> shachaf: Did you build since the patch with fixes for 7.6? =)
13:35:50 <mm_freak_> edwardk: interesting…  what library should i look at?  representable-functors?
13:35:56 <shachaf> dmwit: I have 1.6.0.1.
13:36:16 <mm_freak_> edwardk: if it's that great, i'll integrate it into netwire, too =)
13:36:18 <dmwit> 1.6.0.1 was released to fix things in 7.6.
13:36:20 <dmwit> So yes.
13:36:26 <hiptobecubic> Cale, why do we have to modify the generator? Can't we just generate as many arbitrary values?
13:36:29 <edwardk> representable-functors, lens has another form of representability too in Control.Lens.Representable. if you look at linear it uses the lens notion of representability
13:36:31 <dmwit> Try building 1.6 and you'll see the error.
13:36:40 <Cale> hiptobecubic: because we want our random function to be a function
13:36:50 <edwardk> so if you've already introduced lenses then the representable functor code comes for free
13:36:52 <Cale> hiptobecubic: So we need it to behave consistently for the same input
13:36:53 <mm_freak_> edwardk: which one should i prefer for Space comonads?
13:37:08 <mm_freak_> i don't really need lenses there
13:37:10 <Cale> hiptobecubic: and of course, we'd like it to produce different values for different inputs
13:37:10 <edwardk> take a look at the way linear uses lens for representability
13:37:21 <shachaf> dmwit: I love the "is it 1.6 or 1.6.0.0? Oh, it's 1.6.0" guessing game.
13:37:30 <edwardk> instance Representable V3 where rep f = V3 (f _x) (f _y) (f _z)
13:37:37 <dmwit> shachaf: =(
13:37:43 <mm_freak_> edwardk: i don't yet know what representability is, so i'll have a look at representable-functors first =)
13:37:44 <edwardk> then you get the Monad, Applicative, Distributive law, etc. for V3 for free.
13:37:55 <edwardk> (co)representability is pretty boring
13:37:59 <mm_freak_> just to learn the concept
13:38:01 <dmwit> shachaf: (I just played the exact same game.)
13:38:04 <edwardk> its just that the functor is isomorphic to a function
13:38:11 <shachaf> dmwit: I won it with 'X11 < 1.6.0.1'
13:38:13 <mm_freak_> ah
13:38:15 <edwardk> f ~ (->) e
13:38:26 <shachaf> But why can't version numbers be equal with trailing 0s?
13:38:34 <edwardk> so you can tabulate :: (e -> a) -> f a   and index :: f a -> e -> a   to witness the isomorphism
13:38:48 <dmwit> Well, somebody just made a choice one way or the other.
13:38:53 <edwardk> for some type 'e' which i say is the 'representation' of the functor.
13:39:03 <dmwit> Both choices have tradeoffs, as usual, and you only notice the bad tradeoffs.
13:39:25 <edwardk> choosing e to be the type of lenses into f gives you a delightfully circular way to think about them
13:39:31 <shachaf> What's the trade-off?
13:39:44 <dmwit> shachaf: Also relevant: https://github.com/haskell-pkg-janitors/X11/commit/920c098 <- the specific patch that 1.6.0.1 contains
13:39:51 <edwardk> rep :: ((forall x. Simple Lens (f x) x) -> a) -> f a
13:39:58 <edwardk> because then you can use the lens itself for indexing
13:40:01 <shachaf>     Unacceptable argument type in foreign declaration: XEvent
13:40:06 <dmwit> shachaf: yes
13:40:09 <hiptobecubic> Cale, so then we generate random non-random functions and that's the stream coming from the rng?
13:40:18 <mm_freak_> edwardk: ok, i got it
13:40:26 <dmwit> shachaf: This was an acceptable argument type in 7.4 (which was the one that changed what types were acceptable, supposedly).
13:40:27 <shachaf> dmwit: Aha, I see.
13:40:40 <hiptobecubic> and we use those functions, fed with some input, to generate one arbitrary value each?
13:40:48 <shachaf> dmwit: XEvent is a newtype over CInt or Ptr x or something?
13:40:51 <dmwit> yes
13:40:56 <edwardk> mm_freak_: http://ekmett.github.com/lens/Control-Lens-Representable.html gives you a list of things you get for free once you define rep
13:41:05 <mm_freak_> edwardk: there is a lot of stuff predefined in vector-space…  do i get that for free as well?
13:41:13 <edwardk> fmap, pure, ap, bind, distribute, etc.
13:41:40 <shachaf> dmwit: Hmm, what does the Report say about newtypes?
13:41:47 <dmwit> good question
13:41:51 <shachaf> Having to have the newtype's definition be in scope seems reasonable to me.
13:41:52 <edwardk> mm_freak_: i work differently than vector space. http://hackage.haskell.org/packages/archive/linear/0.2/doc/html/Linear-Vector.html
13:41:55 <shachaf> So maybe this is a bug in 7.4.
13:42:03 <Ralith> Enigmagic: can you recommend any way to do these besides extending the interface with unsafe values?
13:42:07 <edwardk> mm_freak_: i just work free vector spaces
13:42:15 <edwardk> then you can define (^+^) once and forall
13:42:26 <Ralith> Enigmagic: (and don't say "bitcast the pointers", llvm actually has mutually recursive structs now and I want to use them :P)
13:42:27 <edwardk> (^+^) = liftA2 (+)
13:42:51 <edwardk> er work with
13:43:02 <mm_freak_> edwardk: i actually meant stuff like magnitudes, scalar products, normals, etc.
13:43:13 <zungaloca> func :: Char -> Char func x = toUpper x
13:43:18 <edwardk> http://hackage.haskell.org/packages/archive/linear/0.2/doc/html/Linear-Metric.html
13:43:19 <edwardk> =)
13:43:25 <mm_freak_> ok, thanks =)
13:43:41 <atriq> What I like about Haskell is how by restricting what you can do it allows you to do so, so much more
13:44:11 <Cale> hiptobecubic: To get a "random function" a -> b we more or less take the current RNG state, say g, and we produce a function which takes coarbitrary a and applies it to arbitrary :: Gen b, before using g to generate a value with that generator.
13:44:13 <edwardk> mm_freak_: i go out of my way to deal with conjugation, etc. more correctly than vector-space as well for quaternions, etc.
13:44:54 <shachaf> dmwit: http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1570008.4.2
13:45:02 <edwardk> mm_freak_: i intend to build a fair bit of stuff on top of linear
13:45:03 <zungaloca> toUpper works?
13:45:11 <appamatto> Does anyone here use Curry?
13:45:16 <edwardk> > Data.Char.toUpper 'c'
13:45:18 <lambdabot>   'C'
13:45:30 <shachaf> dmwit: Looks like a bug in 7.4 to me, though it's not nice that fixing it breaks old programs.
13:45:46 <Cale> hiptobecubic: (Gen is like Reader (Int,StdGen))
13:46:02 <hiptobecubic> yes
13:46:04 <dmwit> shachaf: Yeah, I agree: seems like 7.4 didn't catch all the places it should have.
13:46:15 <dmwit> (Though I do remember fixing many other such places for 7.4, so it caught some.)
13:46:21 <dmwit> Not sure what you mean about breaking old programs.
13:46:34 <shachaf> X11 used to work, and now it doesn't.
13:46:41 <shachaf> I mean breaking compilation, that is.
13:46:44 <dmwit> ah
13:48:06 <Cale> hiptobecubic: and then all that variant :: (Integral n) => Gen a -> Gen a does is some number theoretical junk involving the number it's given to mess with the random generator which the Gen a is going to consume -- all that we care about is that it gives a different RNG state for each integer you use.
13:48:09 <Cale> er
13:48:12 <dmwit> bleh, even so I don't understand this gtk2hs one
13:48:18 <dmwit> which doesn't mention newtypes at all
13:48:18 <Cale> variant :: (Integral n) => n -> Gen a -> Gen a
13:48:38 <hiptobecubic> ok
13:49:05 <dmwit> Neither the old version nor the proposed fix from the mailing list look like they match what the Report has to say. -_-
13:49:19 <dmwit> https://github.com/vodik/gtk2hs-patched-ghc-7.6.1/commit/74ba88a10f578323e861f352cac09e722419be1c
13:49:56 <Cale> hiptobecubic: so by using a bunch of variants based on the input of type a, we can mess around with this RNG which are going to produce our output of type b, in a consistent way
13:50:33 <zungaloca> make own toUpper
13:50:42 <hiptobecubic> I understand what you're saying, but it isn't concrete for me yet.
13:51:24 <Cale> hiptobecubic: thankfully, you usually don't have to care all that much, and can more or less follow the pattern I had for coarbitrary instances
13:51:42 <Cale> (it's very boilerplatey)
13:51:55 <hiptobecubic> sounds good
13:52:34 <hiptobecubic> I'd like to understand it, but I'm in no rush. I just want to test these functions
13:53:16 <hiptobecubic> This seems pretty derivable
13:54:47 <dmwit> shachaf: Anyway, thanks for your help.
13:57:00 <rwbarton> this CV package is simultaneously cool and awful
13:57:29 <byorgey> @tell kyagrd ghci-diagrams is completely unrelated to the diagrams-* packages
13:57:30 <lambdabot> Consider it noted.
13:58:00 <zungaloca> can i make my own implementation of toUpper
13:58:03 <rwbarton> awful in that it has "pure" functions which actually modify their argument in place, and a cloneImage function that, for some reason, is then in IO
13:58:09 <byorgey> @tell kyagrd but yes, if you want a simple way to quickly get some pictures in a window on your screen, you should use gloss
13:58:09 <lambdabot> Consider it noted.
13:58:19 <hiptobecubic> hmm, why doesn't quickcheck use camelCase like everything else?
13:58:22 <hiptobecubic> "oneof" ?
13:58:36 <dmwit> zungaloca: Sure, but don't, unless you're a Unicode expert.
13:58:58 <dmwit> (In fact, don't even use toUpper unless you're a Unicode expert.)
13:58:58 <ion> Also, Data.Char.toUpper shouldn’t be use. Data.Text.toUpper works properly.
13:59:06 <ion> d
13:59:15 <hiptobecubic> oh even worse. "listOf" but "oneof" ?
13:59:37 <dmwit> ion: Even Data.Text.toUpper's type looks a bit suspicious... no argument for locale?
14:00:01 <zungaloca> meh only latin alphabet ANSI values? can?
14:00:20 <ion> Do you mean ASCII?
14:00:40 <rwbarton> by that logic Ord String is suspicious too
14:01:09 <dmwit> Yes, the default Ord instance for String shouldn't be used for human-visible sorting.
14:01:12 <dmwit> I agree.
14:01:13 <zungaloca> yep ASCII
14:01:21 * rwbarton is still bitter about grep '[A-Z]' matching [b-z] as well
14:01:27 <hiptobecubic> ok this is totally out of hand
14:01:41 <rwbarton> locales can burn a fiery death as far as I am concerned
14:01:44 <hiptobecubic> startling, you were right about listOf :D
14:01:50 <Enigmagic> Ralith: did you try making a custom StructFields instance for your types? I don't think you can do mutually recursive types it with the tuple instance
14:02:01 <dmwit> Locales are terrible, long live locales.
14:02:02 <hiptobecubic> I suppose i need to use Args
14:02:04 <rwbarton> at least, LC_COLLATE
14:02:56 <kate_r> hi
14:02:59 <dmwit> (Then again, I'm of the persuasion that a good String sort should pay attention not only to collation order but also to things like putting "a2" before "a10".)
14:03:03 <Ralith> Enigmagic: what types?
14:03:23 <kate_r> can a list with one element be referred to as a 'singleton'? or is a 'singleton' necessarily a set?
14:03:38 <dmwit> kate_r: singleton sounds good t ome
14:03:45 <Enigmagic> Ralith: how do you want to represent the mutually recursive structs in your code?
14:03:53 <kate_r> dmwit, but according to http://en.wikipedia.org/wiki/Singleton_(mathematics) singletons are sets.
14:03:56 <hpaste> gensymv pasted “why ambigous types?” at http://hpaste.org/74769
14:04:02 <hiptobecubic> So I want some kind of   sized arbitrary i think?
14:04:09 <Ralith> Enigmagic: as .. types, I suppose.
14:04:12 <gensymv> in the above code, ghc complains about ambigous types, can someone help me with that
14:04:16 <Ralith> since that's the way this wrapper does things
14:04:22 <startling> hiptobecubic: heh
14:04:24 <zungaloca> a + 32 = A
14:04:33 <startling> hiptobecubic: yeah, that's the problem with recursive Gen
14:04:40 <gensymv> i don't understand, why it thinks it can be ambigous
14:04:49 <hiptobecubic> have to randomly hit Prop for the chain to terminate
14:04:51 <Ralith> Enigmagic: but building these types requires side-effecting module-level operations, and I'm not sure how to perform those safely.
14:04:53 <dncr> kate_r: i think "singleton" is used in a number of haskell libraries for more than just sets..
14:04:57 <dmwit> kate_r: ...neat.
14:05:07 <Ralith> Enigmagic: building LLVM's view of them, tha tis.
14:05:23 <kate_r> right
14:05:27 <dncr> http://www.merriam-webster.com/dictionary/singleton
14:06:00 <dncr> maybe it's like the offspring definition..
14:06:16 <dncr> or the "individual member" one
14:07:38 <appamatto> Typing id as a -> a seems like extensional equality
14:08:07 <dmwit> Giving a term a type doesn't imply any kind of equality to me.
14:08:15 <humongous_mango> on page 115 of RWH, why is it that if I do: ghc -o simple Main.hs SimpleJSON.o I get a buttload of 'multiple definition' errors, but when I use SimpleJSON.hs, everything works fine?
14:08:56 <appamatto> Well, when you unify id's type and Nat -> Nat it seems to involve extensional equality
14:09:00 <dmwit> Wow, how do you run GHC on a page of a book? =O
14:09:04 <Enigmagic> Ralith: how does it work from the C API side? is there a forward declaration somewhere?
14:09:23 <dmwit> (Just kidding. But I have no idea the answer to your question.)
14:09:34 <dmwit> appamatto: I'm not sure I understand that claim. Can you unpack it a bit?
14:09:35 <appamatto> For example, id x = x might be reasonable typed as forall a. a -> a, but id by itself is like a partial application
14:09:51 <appamatto> ack, sorry I have a call now
14:10:21 <Ralith> Enigmagic: forward declaration is more or less precisely it; you allocate ('declare') struct types, and then you set their body (define) them, wherein you may reference currently allocated but bodyless structs.
14:10:32 <dncr> appamatto: just inline it :-)
14:10:49 <hiptobecubic> startling, I tried to limit it with    Foo <$> listOf (resize 3 arbitrary)   but it still generates hopelessly huge things. Is this just hopeless in general?
14:11:02 <parcs`> humongous_mango: i assume it's because calling 'ghc A.hs B.o' is like calling 'ghc A.hs B.hs B.o' which will try to link B.o twice
14:11:19 <anakreon> Hi. I want to make quickcheck generate strings of the form [a-z][_a-z]*.  The example from http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck doesn't compile because Quickcheck allready defines an instance for Char and coarbitrary is not in the Arbitrary class anymore. Any suggestions?
14:11:24 <dmwit> oh, --make became the default since RWH
14:11:27 <Enigmagic> Ralith: ok... do you know if that functionality is exposed in llvm-base?
14:11:32 <hiptobecubic> even just making the lists have length 1 is just going crazy
14:11:36 <dmwit> humongous_mango: Perhaps there is a --no-make or something like that.
14:11:51 <gensymv>  why does ghc is telling me that the types here aren't fixed? http://hpaste.org/74769
14:11:57 <Ralith> Enigmagic: it is in my branch!
14:12:01 <gensymv> *wh is ghc telling me
14:12:20 <startling> hiptobecubic, well, don't try to print them
14:12:25 <gensymv> oh crap.
14:12:26 <gensymv> *why
14:12:30 <startling> hiptobecubic, what are you using it for?
14:12:41 <parcs`> humongous_mango: in other words ghc doesn't assume that an object file passed as via the command line may be an object file for an associated source file
14:12:54 <rwbarton> @type properFraction
14:12:55 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
14:13:05 <rwbarton> @type truncate
14:13:06 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:13:24 <rwbarton> mantissa is already an Integral type, no need to truncate
14:13:40 <Ralith> Enigmagic: https://github.com/Ralith/llvm/commit/19286cb10b0e53adc3f3881bd34446ac50d8ae57
14:13:44 <rwbarton> also why not just modf n m = n `mod'` fromIntegral m
14:13:51 <rwbarton> @type mod'
14:13:52 <lambdabot> forall a. (Real a) => a -> a -> a
14:14:34 <dmwit> This is subtly different from mod' (and therefore probably buggy).
14:14:41 <rwbarton> is it?
14:14:45 <dmwit> Oh, I guess it isn't, because m is Int.
14:14:46 <dmwit> oka
14:14:47 <dmwit> y
14:14:54 <gensymv> rwbarton, i didn't know about mod' thatswhy :)
14:15:24 <hiptobecubic> startling, i wrote some functions to rewrite propositional logic formulas into conjunctive normal form
14:15:26 <rwbarton> gensymv, if you turned on warnings you would get a warning about shadowing the name :)
14:15:45 <startling> hiptobecubic: do you have some that undo them?
14:15:49 <hiptobecubic> startling, and then clean them up a bit, remove redundancy, etc.
14:16:19 <hiptobecubic> startling, not yet, but i can at least check that the result is logically equivalent to the original
14:17:03 <startling> hiptobecubic: then run "quickcheck \x -> isEquivalent x (toConjunctive x)"
14:17:39 <gensymv> rwbarton, weird i am trying to compile with -Wall and have no warning about that
14:17:43 <rwbarton> hmm
14:18:02 <hpaste> gensymv pasted “why ambigous types?” at http://hpaste.org/74770
14:18:03 <rwbarton> ah it's probably not in a module you are likely to import
14:18:08 <hiptobecubic> you can't really undo it because it's not an injective function
14:18:08 <rwbarton> @index mod'
14:18:08 <lambdabot> bzzt
14:18:12 <rwbarton> @hoogle mod'
14:18:12 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
14:18:12 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
14:18:17 <hiptobecubic> startling, yes, that's what i'm trying now
14:18:18 <hpaste> gensymv pasted “why ambigous types, error output.” at http://hpaste.org/74771
14:18:49 <startling> hiptobecubic: oh, got it
14:19:01 <monochrom> @type properFraction
14:19:02 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
14:19:21 <monochrom> @type truncate
14:19:22 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:19:39 <monochrom> you don't need truncate. in fact, it gets into the way
14:20:01 <hiptobecubic> startling, but testing it takes impossibly long
14:20:02 <johnw> edwardk: I have makeClassyFor "HasBase" "base" [ ("_gitId", "gitId") , ("_gitRepo", "gitRepo") ] ''Base
14:20:12 <johnw> but I still have a HasBase
14:20:17 <johnw> don't have
14:20:23 <hiptobecubic> is there a way to limit how 'deep' we go with this arbitrary form generation?
14:20:27 <edwardk> what is the type for Base
14:20:37 <edwardk> makeClassy only works if the type has no args
14:20:45 <edwardk> there is no good way to make the constraint otherwise
14:21:34 <johnw> data Base a = Base { _gitId   :: Ident a, _gitRepo :: Repository }
14:21:42 <johnw> i'm using makeClassyFor
14:21:51 <johnw> what should I be using?
14:22:41 <startling> hiptobecubic: ah
14:24:29 <edwardk> johnw: i can't generate a class for types that take arguments. you can use makeLenses and then manually compose something on them
14:24:52 <johnw> ok
14:24:56 <hiptobecubic> startling, yeah this is hopeless.... it only manages 1 test, which i assume is all empty lists and zeros or something
14:25:34 <startling> hiptobecubic: heh. you could use a couple of intermediary Gen to limit the depth
14:25:45 <johnw> so I'll never have a HasWhatever for this type?
14:25:46 <hiptobecubic> How do you mean?
14:26:26 <dmwit> hiptobecubic: If you don't know what that means, you probably wrote an Arbitrary instance that creates much-too-large terms (and sometimes diverges).
14:26:54 <dmwit> (I did, my first few treks through QuickCheck.)
14:26:59 <hiptobecubic> dmwit, no i'm sure that's that i did.
14:27:01 <hiptobecubic> what*
14:27:24 <hiptobecubic> startling, by 'how do you mean'. I mean actually mean "How would that work?"
14:27:38 <hiptobecubic> I actually mean*
14:27:56 <dmwit> hiptobecubic: So, the Gen monad includes a "size" argument. If you write recursive Arbitrary instances, you're suppose to decrease the "size" argument in the recursive calls.
14:28:19 <hiptobecubic> dmwit, yes, and i've set them all to 1
14:28:19 <dmwit> I got byorgey to write me some code for distributing the size over many calls somewhat fairly... it's lying around here somewhere...
14:28:23 <dmwit> oh
14:28:27 <dmwit> Well, that's one way. =)
14:28:47 <hiptobecubic> dmwit, the problem is that only one value is non recursive, out of six
14:28:53 <hiptobecubic> and two of them are doubly recursive
14:29:35 <dmwit> follow up question: do you ever inspect the size when making a choice?
14:29:42 <hiptobecubic> so there's a 1 in 6 chance we terminate this branch on this step, and a 2/6 chance we branch again
14:29:46 <Enigmagic> Ralith: doesn't look all that bad but the way TypeReps are fetched would need to change
14:30:16 <hiptobecubic> dmwit, no? It's a simple definition so far
14:30:32 <dmwit> If you don't inspect the size, changing what you set it to won't do anything...
14:30:34 <hiptobecubic> and even if i throw a lot of things away, it's still too big.  hold on i'll paste
14:30:44 <startling> dmwit, it'll change the listOf
14:30:48 <hiptobecubic> dmwit, maybe i misunderstood?
14:30:59 <Ralith> Enigmagic: suggestions? I'm eager to code on this, but I'm new to doing so much at the type level, especially outside of a dependently typed env.
14:32:52 <hpaste> hiptobecubic pasted “arbitrary values too large” at http://hpaste.org/74772
14:33:56 <hiptobecubic> so if i comment out most of the arbitrary definition, say only leaving oneof [Prop..., Neg..]   then i get reasonably short arbitrary values
14:34:09 <hiptobecubic> because there's a high chance that it will terminate and no way for the growth to explode
14:34:44 <hiptobecubic> Cnj and Dsj are both limited to list length 1, which logically doesn't even make sense, but shouldn't break anything
14:34:52 <dmwit> When the size is small, decrease the chance of choosing Impl or Equiv.
14:35:18 <hiptobecubic> ahhh right, you can do weighted choice from the list, right?
14:35:53 <hiptobecubic> with "frequency" i guess
14:36:01 <hiptobecubic> just a minute, let's see
14:36:54 <Ralith> Enigmagic: mainly I don't want to spend a week faffing about if you can point me in the right direction.
14:37:27 <hiptobecubic> hah! yes
14:40:22 <Enigmagic> Ralith: hum well the main thing is that typeDesc is a pure function... which is fine for structural types but i think llvm's named structs should be treated differently
14:41:26 <Ralith> Enigmagic: considering that they're named, they *do* substantially modify the module, as it changes the results of lookups for that name (though I think this might not be exposed or of consequence through the top-level interface)
14:41:42 <Enigmagic> Ralith: the typeRep of some named struct should always point to the same LLVMTypeRep right?
14:42:13 <Ralith> Enigmagic: the the TypeDesc should always refer to the same FFI.TypeRep, you mean?
14:42:21 <Ralith> (in a pointer equality sense)
14:42:37 <Enigmagic> yes, they'd need to have pointer equality
14:43:28 <Enigmagic> Ralith: do you know if structCreateNamed looks to see if there is already a value with the same name or does it create a new unique name?
14:43:49 <Ralith> Enigmagic: as per LLVM convention, I believe it creates a new unique name.
14:44:00 <Enigmagic> that's what i would guess too
14:44:27 <Ralith> the names still matter insofar as tht FFI.getTypeByName exists
14:44:31 <Ralith> as that*
14:44:41 <Ralith> but it doesn't seem entirely unreasonable to just ignore that.
14:46:46 <ocharles> https://www.youtube.com/watch?v=a4OkTg9DqHs documentary on Paul Erdos, for those who don't read /r/math
14:46:51 <ocharles> might be of interest here :)
14:47:45 <hiptobecubic> startling, well now that i can generate values, I can confirm that my crappy functions don't work :D
14:47:53 <appamatto> okay, back to id and Int -> Int unification
14:48:05 <startling> hiptobecubic, that's the first step !
14:48:31 <appamatto> I think normally id should be a partial application (or unapplied function) and so it shouldn't be so straightforward to unify it without extensional equality
14:49:12 <appamatto> The fact that id :: forall a. a -> a is sort of a workaround I think
14:49:42 <appamatto> Extensionality is built in to forall in that sense
14:50:10 <hiptobecubic> also i tihnk my functions are probably slow as hell
14:52:18 <byorgey> hiptobecubic: try the testing-feat package
14:53:17 <byorgey> it gives you efficient uniform random generation of explicitly sized values
14:53:23 <byorgey> and integrates nicely with QuickCheck
14:54:08 <byorgey> http://youtu.be/HbX7pxYXsHg
14:54:10 <Enigmagic> Ralith: well it seems like the FFI.TypeRef's should be cached in CodeGenModule and LLVM.Core.Types.typeRef should inspect the cached type reps... then you could add another pass to fill in the struct bodies as late as required
14:54:50 <Cale> appamatto: ?
14:55:34 <Cale> appamatto: I'm not sure whether I see how id :: forall a. a -> a is a workaround in any sense
14:55:41 <hiptobecubic> byorgey, thanks. bookmarked
14:56:03 <Ralith> Enigmagic: I don't follow.
14:56:25 * hackagebot aeson-schema 0.1.0.0 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.1.0.0 (TimBaumann)
14:56:53 <KirinDave> I'm confused
14:57:01 <KirinDave> cabal install yesod fails
14:57:13 <Enigmagic> Ralith: typeRef calls out to the FFI to fetch the FFI.TypeRef for a type. that is done lazily and doesn't share it's results.
14:57:28 <KirinDave> Seems like a dependency breaking problem.
14:58:01 <Enigmagic> Ralith: to define mutually recursive structs you'd want to do it in two passes with a defined order: first create the empty structs, then fill in their fields (after all the empty structs have been created)
14:58:36 <Cale> KirinDave: iirc, yesod has very picky dependencies which can easily fail if you don't have just the right versions of things. There's some custom tool which the yesod guys built to help with that, but I forget what it's called...
14:59:13 <Enigmagic> Ralith: in order to accomplish this, you'll need to store the empty struct TypeRefs somewhere. a dictionary of some sort that is shared in CodeGenModule seems like a reasonable approach
14:59:36 <KirinDave> Hrrm
15:00:24 <KirinDave> Maybe I should just stick to using something like compojure for work.
15:00:36 <KirinDave> Kinda don't wanna muck with deptree hell.
15:00:41 <Ralith> Enigmagic: I follow all of that but the first part. What does typeRef perform its lookup on? Why does it call out to the FFI if the CodeGenModule is keeping track of things? Does unsafe IO get involved somewhere, or shall I go around and IOify every user of typeRef?
15:01:43 <Enigmagic> Ralith: CodeGenModule doesn't pay any attention to it right now, that part seems broken. It's effectively doing unsafePerformIO now because the foreign imports are like "a -> b" instead of "a -> IO b".
15:02:17 <Enigmagic> Ralith: it also seems like if you're going to rototill some of the code you'd probably want to switch over to the "...InContext" versions of the functions.
15:02:39 <Ralith> heh, rototill
15:03:00 <Ralith> Enigmagic: that was something I noticed as well; should CodeGenModule carry a Context around?
15:03:12 <KirinDave> Hmm yesod-platform seems to think it has a way forward.
15:03:19 <Cale> KirinDave: I'm not really a yesod person though. Probably someone who had at least used it once would be better help :)
15:03:27 <Enigmagic> Ralith: i'd start changing "typeRef :: IsType a => a -> FFI.TypeRef" to "typeRef :: IsType a => a -> CodeGenModule FFI.TypeRef" and work back from there
15:03:52 <luite> KirinDave: try installign yesod-platform
15:04:03 <Ralith> Enigmagic: it's worth note that many/most type builders *are* pure operations, again as per LLVM convention.
15:04:10 <luite> it restricts all dependencies to a single version, a combination that worked with the ci tests
15:04:21 <Ralith> I believe bos was correct in the a -> bish imports where they exist.
15:04:41 <Ralith> function, integer, anonymous struct, pointer, and array types all have no side effects.
15:05:36 <luite> KirinDave: make sure you have ghc 7 (7.6 should also work with the latest yesod-platform)
15:05:49 <Enigmagic> Ralith: i don't mean you need to tag them with IO. just that the TypeRefs for named structs (at least) should be cached within the CodeGenModule
15:06:25 * hackagebot hashtables 1.0.1.7 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.1.7 (GregoryCollins)
15:06:37 <KirinDave> luite: I'm using 7.4.1
15:06:38 <Ralith> Enigmagic: I'm not sure what you were referring to in your comment about the foreign imports, then.
15:06:44 <KirinDave> luite: Seems better
15:06:54 <Enigmagic> Ralith: you asked if there was some unsafePerformIO going on, and the answer is yes
15:07:13 <KirinDave> luite: I just want to write some small api responders. I could do it in clojure but it's friday afternoon so I figured since I have all weekend I'll give yesod a try as a API backend tool.
15:07:20 <Ralith> Enigmagic: I meant to ask if you were suggesting its addition, but it's clear now that you are not.
15:07:52 <Ralith> Enigmagic: I'm still not completely clear on this approach, but I've got enough to get started and I think doing so will substantially improve the ordering of my thoughts. Thanks!
15:09:38 <luite> KirinDave: ah json?
15:09:46 <KirinDave> luite: That's the plan.
15:10:05 <KirinDave> luite: Gotta go from an email signup and pingback form to metrics.
15:10:23 <KirinDave> luite: Yesod should be good for that, right?
15:11:12 <luite> KirinDave: ah right, should be easy, if you know aeson then just make a Handler RepJson and jsonToRepJson x to respond with a value x with an (aeson) ToJSON instance
15:11:22 <KirinDave> Yeah.
15:11:44 <KirinDave> luite: I'm curious how "easy" it is compared to compojure and friends.
15:11:54 <KirinDave> luite: Cuz man is that terse for the performance you get.
15:12:27 <Enigmagic> Ralith: np
15:12:48 <roconnor> ugh, specifiying versions in cabal is like pulling teeth
15:13:28 <luite> KirinDave: dunno, terseness is not the ultimate goal, but ~20 lines or so should be doable for starting the web server, routing and a handler
15:14:42 <Ralith> Enigmagic: will I be uniquing struct types based on their TypeReps?
15:14:53 <appamatto> Cale, the a meta variable isn't really part of the language
15:15:01 <Ralith> (as in Typeable)
15:15:08 <Enigmagic> Ralith: you'll have to figure out how you want to represent named structs in haskell
15:15:44 <Ralith> well, in lieu of GHC 7.6 we don't really have type-level strings, do we?
15:15:45 <appamatto> I guess what I mean is that you could imagine a type function which is idType a = a
15:15:52 <Enigmagic> Ralith: otherwise yes
15:16:20 <Ralith> until those are a thing it seems like they'll just have automatically assigned names.
15:16:24 <appamatto> And then id :: idType. Then figuring out that idType can unify with Nat -> Nat is requires eta-expansion of idType
15:17:27 <Enigmagic> Ralith: not really. i sometimes use the type-level package to represent short (ascii encoded) strings
15:18:08 <KirinDave> luite: That's solid enough.
15:18:10 <Cale> appamatto: Which language are we talking about?
15:18:10 <Enigmagic> that's not very practical for regular (not machine generated) code though
15:18:20 <Cale> appamatto: Haskell?
15:18:32 <Ralith> Enigmagic: yeah, I'll wait for data kinds for that feature rather than ask users to decode ASCII in their head :P
15:18:39 <luite> KirinDave: for this you probably don't want to start with the scaffold, that's just too big/confusing
15:18:44 <appamatto> Cale: Haskell with "type functions" I guess
15:19:07 <KirinDave> luite: I'll see if I can deviate from the 101 path that fundamentally.
15:19:16 <startling> can I make Monoid b => a -> b a Monad somehow?
15:19:16 <appamatto> Haskell forall seems to guarantee that types of functions are already eta-expanded
15:19:18 <hpaste> roconnor pasted “undecypherable cabal error” at http://hpaste.org/74774
15:19:22 <Cale> appamatto: Oh, so you're talking about type-polymorphic id as a type function?
15:19:32 <Cale> appamatto: with the polymorphic kind  forall a. a -> a?
15:19:32 <roconnor> can someone decypher that cabal error for me?
15:19:43 <appamatto> Cale: I suppose the kind could also be id
15:19:55 <startling> where (>>=) runs both on the same input and mappends the results
15:19:58 <roconnor> oh wait I see
15:20:02 <Enigmagic> Ralith: :^)
15:20:05 <roconnor> cabal-dev requires mtl < 2.1
15:20:05 <appamatto> Cale: turtles all the way down? :p
15:20:10 <roconnor> god what a nightmare
15:20:37 <Cale> appamatto: I think I missed some important part of this conversation though.
15:20:37 <appamatto> The type of idType would be idKind which is defined as idKind a = a, for example
15:21:14 <appamatto> Oh, I was just claiming that unifying id's type with, say, Nat -> Nat relies on extensional equality
15:21:34 <Cale> appamatto: 'a' is just a bound type/kind/what-have-you variable, bound by the forall quantifier... I don't see why it shouldn't be considered "part of the language"
15:21:39 <appamatto> Since at some point you have to do eta-expansion (in Haskell, using forall)
15:22:46 <Cale> appamatto: If id :: forall a. a -> a, then a ~ Nat unifies it with that type...
15:23:11 <Cale> I'm not sure whether this relies on extensional equality... let me think about that
15:23:23 <appamatto> Cale, I like to think that id has some type even unapplied
15:23:33 <appamatto> As in, even before it's applied to a "hypothetical" a
15:23:47 <Cale> Well, sure, it has the type  forall a. a -> a
15:23:59 <Cale> That type has no free type variables
15:24:04 <appamatto> And that forall is an artifact of trying to define equality for its' type extensionally
15:24:39 <Cale> What would it look like if it were defined intensionally?
15:24:51 <Cale> I don't really understand even what distinction you're trying to make :)
15:26:00 <appamatto> Okay, imagine we could define id's type as idType
15:26:06 <Cale> okay...
15:26:07 <appamatto> where idType a = a
15:26:18 <Cale> Don't you mean  idType a = a -> a ?
15:26:20 <byorgey> what?
15:26:29 <shachaf> cmccann!
15:26:34 <Cale> There's got to be a function type constructor in there somewhere!
15:26:42 <appamatto> I mean idType is a function that when given a type returns the same type
15:26:46 <cmccann> shachaf!
15:26:56 <byorgey> appamatto: that doesn't really make sense to me.
15:27:03 <byorgey> the type of id is not a function
15:27:06 <Cale> appamatto: But that's no good, because that doesn't express the fact that id itself is any kind of function
15:27:16 <byorgey> except in the sense that Cale said
15:27:20 <shachaf> cmccann: Whatcha doin' here?
15:27:36 <appamatto> Cale, is that true?
15:27:42 <cmccann> having internet access and free time again, mostly.
15:27:42 <ski> (nitpick : `forall a. a -> a' is not polymorphic, it's universal. `id' is polymorphic)
15:27:51 <Cale> appamatto: unless you mean to restrict the type system to functions alone, and stop treating other values
15:28:14 <appamatto> Cale, actually I wanted to extend the type system with functions?
15:28:17 <Cale> ski: good nitpick
15:28:29 <ski> (the type/kind/&c. of a polymorphic thing is always a universal thing)
15:28:30 <rwbarton> appamatto: your "idType" is more like "undefinedType" where undefined :: forall a. a
15:28:37 <Cale> appamatto: Okay, but if there's a type function involved here, surely it's  /\a. a -> a
15:28:38 <rwbarton> that is what Cale is saying, I think
15:28:55 <roconnor> is cabal-dev not supported anymore?
15:29:00 <appamatto> Oh I see what you're saying
15:29:17 <byorgey> roconnor: it's still supported as far as I know.  Why do you ask?
15:29:44 <appamatto> Okay, so let's say you apply id to 1, on the type level wouldn't you be applying id's type to Int?
15:29:51 <roconnor> byorgey: because the MTL contraint is something like a year out of date
15:30:26 <rwbarton> you apply id's type to Int to get the type of id-on-Int, which is Int -> Int
15:30:36 <appamatto> If we used your definition we would end up with idType Int returning a function instead of Int which is the proper answer
15:30:46 <byorgey> roconnor: oh, huh, so it is
15:30:50 <byorgey> roconnor: I hadn't noticed that
15:30:52 <rwbarton> then you can apply that function to 1
15:30:56 <Cale> appamatto: If id's type is in any sense a function of the type a, then it should be the function which takes Int, and produces the type Int -> Int
15:30:59 <rwbarton> only then do you get an Int
15:30:59 <byorgey> probably because I haven't compiled it in a long time
15:31:03 <rwbarton> yeah
15:31:28 <Cale> appamatto: Maybe read would be a better example
15:31:40 <Cale> read :: forall a. (Read a) => String -> a
15:31:43 <ski> appamatto : maybe you could consider a different, but still polymorphic, example; namely `Nothing', which has type 'forall a. Maybe a' ?
15:32:04 <appamatto> Hmm, is there a reason why you don't simply map (id 1) to their types (idType Int) and then perform the reduction then?
15:32:22 <Cale> If this type is a function of the type a, then it should be the function, which when, say, given the type Int, produces the type  String -> Int  (perhaps after ensuring that the constraint holds)
15:32:27 * cmccann defines "type Id a = a". there, an identity function for types.
15:32:38 <byorgey> appamatto: note that id really takes two arguments: a type, and a value
15:32:46 <byorgey> appamatto: so it should really be   id Int 1
15:32:48 <byorgey> does that help?
15:32:59 <byorgey> it's just that in Haskell the type application is explicit
15:33:07 <Cale> byorgey: you mean implicit?
15:33:11 <appamatto> I see that way of doing it--I'm not sure though why it's not done the way I'm describing
15:33:13 <byorgey> er, yes, implicit
15:33:16 <cmccann> it's explicitly implicit, clearly.
15:33:20 <byorgey> but if we're going to be talking about explicit forall's, then we should talk about explicit type application too
15:33:29 <rwbarton> appamatto, try Cale's or ski's alternate examples, you will see
15:34:02 <appamatto> It seems redundant to have the implicit type application
15:34:18 <Cale> appamatto: ?
15:34:20 <rwbarton> what you are doing only works because the argument to id happens to be of the type a bound by the forall
15:34:33 <rwbarton> but that needn't be the case, and indeed we need not be talking about a function at all
15:34:33 <Cale> appamatto: It's extremely convenient to not have to explicitly apply types everywhere
15:34:54 <byorgey> roconnor: hmm, and there's been an open pull request against cabal-dev for 3 months
15:35:00 <Cale> appamatto: Try writing any significant program directly in System F and then tell us that implicit type application is redundant ;)
15:35:29 <rwbarton> or Java
15:35:32 <cmccann> hahaha
15:35:44 <appamatto> Okay, what I mean is if the type application is implicit then why does it need to be in the type definition?
15:35:52 <Cale> appamatto: hm?
15:36:07 <Cale> appamatto: You mean why do we explicitly quantify the type variables?
15:36:13 <Cale> appamatto: Note that Haskell 98 doesn't
15:36:36 <appamatto> For example, we don't say forall x. id x = x
15:36:49 <appamatto> So why say forall a. idType a = a?
15:36:52 <hiptobecubic> Ok bed. No longer capable of writing anything sensible.
15:36:55 <byorgey> roconnor: and many open issues with no response for several months
15:37:04 <hiptobecubic> Cale, startling, byorgey, thanks for the quickcheck help
15:37:07 <Cale> appamatto: you mean why say  id :: forall a. a -> a
15:37:16 <Cale> because we *don't* say  forall a. idType a = a
15:37:32 <Cale> (I don't even think there's a way for that to make sense)
15:37:37 <appamatto> Hmm, couldn't we just say idType a =a  in analogy to id x = x?
15:37:47 <byorgey> no.
15:37:50 <Cale> no
15:37:55 <Cale> because id is a *function*
15:38:08 <Cale> so somewhere in id's type, the constructor (->) had better appear
15:38:10 <appamatto> Why isn't idType also a function?
15:38:20 <Cale> (->) :: * -> * -> *
15:38:22 <Cale> takes two types
15:38:26 <appamatto> Ah, I see what you're saying
15:38:31 <Cale> and produces the type of functions from the first type to the second type
15:38:51 <appamatto> So we could write id as forall x . id x = x
15:38:55 <appamatto> Oops sorry
15:39:00 <appamatto> forall x . x -> x
15:39:03 <Cale> I *guess*
15:39:09 <appamatto> That should be equivalent to id
15:39:12 <Cale> yes
15:39:14 <byorgey> that is the type of id.
15:39:18 <Cale> we write forall x. x -> x
15:39:21 <Cale> that is correct
15:39:25 <appamatto> I don't mean it is the type, I mean it *is* id
15:39:33 <Cale> mmmm...
15:39:40 <Cale> there are two values of that type
15:39:43 <rwbarton> a mathematician might write x |-> x
15:39:43 <Cale> id and undefined
15:39:51 <appamatto> If you imagine that $ (-> a b) c | a == c = b
15:39:53 <rwbarton> I don't know if that is what you meant
15:39:58 <shachaf> Cale: And const undefined
15:40:01 <Cale> oh, haha
15:40:03 <Cale> three
15:40:08 <Cale> in the presence of seq
15:40:10 <Cale> of course :)
15:40:12 <appamatto> In other words, -> is a function that matches it's first argument and returns the second
15:40:25 <Cale> appamatto: I disagree
15:40:40 <appamatto> Sorry, $ is a function that matches the first argument of -> and returns the second
15:40:40 <Cale> Well, er...
15:40:52 <byorgey> appamatto: you seem to be very intent on explaining Haskell types by making up other weird syntax.
15:40:54 <Cale> I don't understand what you're writing
15:41:00 <byorgey> I am not sure why.  It doesn't seem to be helping.
15:41:17 <appamatto> I'm trying to use the same language in value level and type level
15:41:30 <byorgey> appamatto: well, they aren't the same.
15:41:34 <appamatto> To clarify that the type of a function needn't always involve ->
15:41:57 <byorgey> appamatto: that is false.  The type of a function always involves -> .
15:42:02 <Cale> appamatto: Okay, if you really want to be committed to using the same language, let's unify the idea of lambda at the value level with forall at the type level
15:42:11 <appamatto> Okay
15:42:44 * byorgey doubts this is going to go well
15:42:49 <appamatto> haha
15:42:52 <Cale> oh god, the arrows
15:42:54 <rwbarton> you should really choose an example other than id
15:42:56 <Cale> lol
15:42:59 <byorgey> exactly
15:43:19 <Cale> no you know what, fuck lambda, we're using forall now
15:43:24 <appamatto> id is the only example I can think of that can obviously serve as its own type
15:43:30 <Cale> So id = forall x. x
15:43:37 <rwbarton> but it doesn't... sigh
15:43:37 <Cale> and  id :: forall a. a -> a
15:43:40 <byorgey> appamatto: but it can't!
15:43:50 <rwbarton> right
15:43:51 <cmccann> hm. if you use the same syntax for the type and value levels, are there any non-trivial functions whose definition can be syntactically identical to their type?
15:43:53 <rwbarton> look, already they are different!
15:44:02 <rwbarton> id :: idType
15:44:06 <rwbarton> so idType = forall a. a -> a
15:44:08 <cmccann> er, non-trivial anything, not just functions.
15:44:10 <appamatto> I don't agree that you need forall there
15:44:12 <rwbarton> not the same as id = forall x. x
15:44:21 <Cale> appamatto: I'm using forall in place of lambda
15:44:30 <Cale> appamatto: so normally we'd write  id = \x -> x
15:44:31 <shachaf> Instead of forall you should write type arguments explicitly as arguments.
15:44:53 <Cale> appamatto: and instead of lambda binding, I'm stealing the syntax of forall from the type level and bringing it to the value level for functions
15:45:07 <appamatto> If we're taking the type level seriously then you should be able to apply F to A to get (f a)'s type if f::F and a::A
15:45:10 <byorgey> yes, if you write explicit type arguments, then the structure of types nicely matches the structure of values, but they are not the same
15:45:16 <rwbarton> appamatto, no!
15:45:29 <Cale> appamatto: absolutely not!
15:45:35 <rwbarton> if f :: F and a :: A and you want the type of f a, then F better be A -> B and the type of f a is B
15:46:02 <appamatto> Okay, define ->
15:46:04 <rwbarton> even forgetting polymorphism completely for the moment
15:46:10 <appamatto> That will clear this up :)
15:46:28 <appamatto> I have a very clear definition for it
15:46:30 <cmccann> (->) is just a constructor.
15:46:47 <rwbarton> a -> b [or (->) a b] is the type of function which take an argument of type a and return a result of type b
15:46:54 <Cale> (->) is a type constructor with introduction and elimination rule
15:46:55 <cmccann> it has nothing to do with functions at the type level.
15:47:04 <monochrom> what Cale says
15:47:31 <appamatto> What is the elimination rule?
15:47:33 <rwbarton> if a is a type (of kind *) and b is a type (of kind *) then a -> b is a new type (of kind *)
15:47:40 <monochrom> the primitives must be given through axioms, not definitions.
15:48:12 <appamatto> I think the rule is $ (-> a b) c | a == c => b
15:48:17 <monochrom> the elimination rule is the function application type-checking rule
15:48:28 <appamatto> Which means when you apply (a -> b) to a you get b
15:48:33 <monochrom> yes
15:48:47 <appamatto> Okay, so we're all agreed about that?
15:48:48 <shachaf> appamatto: I think you're confusing types and values a lot here.
15:48:53 <rwbarton> when you apply A VALUE OF THE TYPE (a ->) to A VALUE OF THE TYPE a you get A VALUE OF THE TYPE b
15:48:54 <byorgey> no, when you apply *something of type* (a -> b)  to  *something of type* a, you get *something of type* b
15:49:00 <byorgey> haha
15:49:27 <monochrom> oh, I allowed for sloppy wording
15:49:29 <Cale> (Gamma, x::T |- y::S) |- (Gamma |- (\x -> y) :: T -> S) -- this is the introduction rule for (->)
15:49:38 <byorgey> monochrom: that is very, very dangerous in the present situation
15:50:04 <appamatto> Hehe. That's the part I don't understand. I can see how in Haskell you can't apply (a -> b ) to a, but it seems like the language *should be* that you can do so
15:50:12 * cmccann notes that, at the type level only, Either is equivalent to (,).
15:50:26 <shachaf> cmccann: Equivalent?
15:50:37 <shachaf> Do you mean something other than "has the same kind"?
15:50:40 <Cale> (Gamma |- f :: T -> S), (Gamma |- x :: T) |- (Gamma |- f x :: S) -- this is the elimination rule for (->)
15:50:52 <cmccann> they're both type constructors of two arguments. :]
15:50:56 <byorgey> appamatto: (a -> b) is not a function that can be applied.  It is just a thing.  That thing happens to categorize other things, which are functions.
15:50:57 <monochrom> ha, random mysterious quote of the day by monochrom: equality depends only on... :)
15:50:59 <appamatto> So i guess what I'm doing is proposing that there be a new language where -> is a proper value constructor and it can be applied in the way above, and that it be the type of functions as well
15:51:03 <rwbarton> you can't apply THE TYPE (a -> b) to THE TYPE a any more than you can apply Int to Bool
15:51:15 <cmccann> Just like any data constructor holding two values of the same type is equivalent to (,) at the value level.
15:51:39 <Cale> appamatto: (->) is a type constructor just like (,) is
15:51:39 <appamatto> Sorry, I mean specifically an application $ here $ (-> a b) c = ....
15:51:47 <appamatto> here = where
15:51:48 <Cale> (or Either)
15:52:13 <Cale> > (5, "Hello") :: (,) Integer String
15:52:13 <lambdabot>   (5,"Hello")
15:52:15 <rwbarton> sure you can define some (partial) binary operation on types that does that
15:52:24 <rwbarton> but it's not application of types
15:52:32 <Cale> :t show :: (->) Integer String
15:52:33 <lambdabot> Integer -> String
15:52:46 <Cale> > (show :: (->) Integer String) 5
15:52:47 <lambdabot>   "5"
15:53:15 <Cale> appamatto: See? (->) is a function at the type level, which takes two types and produces a type for functions
15:53:16 <cmccann> applying the type "A -> B" to the type "A" makes as much sense as asking which type "Either A B" holds. "Either A B" has both types, you can see them right there.
15:53:35 <rwbarton> application of types is: I can apply Maybe to Int to get Maybe Int, or if I have type lambdas I can apply (\a. a -> a) to Int to get Int -> Int
15:53:39 <Cale> appamatto: You can't apply (Int -> String) to any more types, because it's fully applied
15:53:51 <Cale> But you can apply (->) to Int to get a type constructor (->) Int
15:54:05 <Cale> and then apply that to String to get the type  (->) Int String
15:54:16 <appamatto> How about this, -> a b c | a == c => b   ?
15:54:17 <Cale> which is another way to write Int -> String
15:54:44 <rwbarton> this pseudo-Haskell notation isn't helping
15:54:47 <appamatto> Defining it as a function
15:54:57 <rwbarton> you can write
15:55:02 <rwbarton> type family ApplicationResult f a
15:55:10 <rwbarton> type instance ApplicationResult (a -> b) a = b
15:55:13 <rwbarton> or whatever the syntax is
15:55:45 <Cale> appamatto: Application at the value level and type level have got to be different things though.
15:55:53 <Cale> appamatto: For example, let's look at Maybe
15:55:53 <appamatto> Cale, why is that?
15:56:05 <appamatto> Ok
15:56:10 <Cale> (->) is deceiving you
15:56:22 <Cale> :kind Maybe
15:56:27 <Cale> :k Maybe
15:56:28 <lambdabot> * -> *
15:56:37 <Cale> Maybe is a function on types
15:56:50 <Cale> it takes a type (of kind *) and produces a type (of kind *)
15:56:59 <Cale> :t Maybe Int
15:57:00 <lambdabot> Not in scope: data constructor `Maybe'
15:57:00 <lambdabot> Not in scope: data constructor `Int'
15:57:02 <Cale> :k Maybe Int
15:57:03 <lambdabot> *
15:57:18 <Cale> So Maybe Int is a type, with values
15:57:25 <Cale> But Maybe is not a type with values
15:57:50 <appamatto> Maybe x = x ? Nothing (in Curry)
15:58:08 <Cale> data Maybe t = Nothing | Just t
15:58:18 <Cale> This defines constructors:
15:58:26 <Cale> Nothing :: forall a. Maybe a
15:58:29 <appamatto> Not sure if I have the semantics right, but Maybe *could* also be a value-level function, no?
15:58:33 <donri> is Nothing a constructor?
15:58:42 <Cale> Just :: forall a. a -> Maybe a
15:58:50 <Cale> donri: it's a data constructor
15:59:11 <donri> i thought constructors where reserved for those that take arguments
15:59:15 <donri> guess not :)
15:59:17 <Cale> Yeah, I should be clear: Maybe is a type constructor, and Nothing, Just are data constructors
15:59:27 <appamatto> My proposal is that value-level Maybe 5 should non-deterministically produce either a 5 or Nothing
15:59:42 <cmccann> how?
15:59:50 <Cale> appamatto: Inventing semantics like this for every possible datatype is going to get stupid
15:59:51 <cmccann> what does "Maybe 5" even mean?
16:00:01 <rwbarton> non-deterministically either a 5 or Nothing, duh
16:00:01 <roconnor> finally got cabal-dev to build!
16:00:07 <appamatto> Haha
16:00:21 <appamatto> I'm fresh off of reading about Curry and logic programming combined with FP :p
16:01:01 <appamatto> Sorry, Maybe 5 should produce either Just 5 or Nothing, I guess?
16:01:02 <jfischoff> roconnor: now you can experience the joy of cabal-dev .hi bugs!
16:01:09 <roconnor> yay
16:01:20 <Cale> appamatto: Maybe 5, even if it existed, should be a type error.
16:01:32 <Cale> appamatto: At least, unless 5 is a type
16:01:42 <Cale> appamatto: Maybe takes types and produces other types
16:01:42 <appamatto> Hmm, but you just said that Maybe foo is either Just foo or Nothing
16:01:43 <roconnor> er
16:01:48 <roconnor> what did cabal-dev install do?
16:01:59 <roconnor> oh there is a cabal-dev directory
16:02:01 <roconnor> that's good
16:02:07 <rwbarton> where did he say that?
16:02:14 <rwbarton> I don't see
16:02:17 <Cale> appamatto: A value of type Maybe t is either a value Just x for some x of type t, or it is the value Nothing
16:02:35 <ddarius> @google "ontic programming language"
16:02:36 <lambdabot> http://www.worldcat.org/title/ontic-a-knowledge-representation-system-for-mathematics/oclc/227714573?referer=&ht=edition
16:02:37 <lambdabot> Title: ONTIC: A Knowledge Representation System for Mathematics. (Book, 1987) [WorldCat ...
16:02:39 <Cale> appamatto: okay?
16:02:53 <appamatto> I guess I'm living in a world where values and types are the same thing, and asking "what's the problem?"
16:02:59 <Cale> appamatto: Maybe Integer is a *type*,  Just 5 is a *value* whose type is Maybe Integer
16:03:08 <appamatto> I can definitely see why in Haskell these things don't work
16:03:13 <Cale> appamatto: Even *if* we had types as values
16:03:15 <appamatto> I'm wondering if that's a limitation of Haskell or not
16:03:44 <Cale> appamatto: We'd still want Maybe to have a type which indicates that it takes a type of the sort which has values, and produces another type of the sort which has values.
16:03:49 <rwbarton> even if types and values are the same "x" is not the same as "a value of type x"
16:04:33 <Cale> appamatto: We wouldn't want to just be able to apply Maybe to *anything* and get some piece of garbage :)
16:05:03 <Cale> appamatto: We want to apply Maybe to something which is the type of x, and get the type of Just x
16:05:03 <appamatto> Cale, what if maybe a = a "or" Nothing, and therefore maybe 5 :: maybe Int because 5 :: Int
16:05:30 <appamatto> Is there something wrong with that alternate calculus?
16:05:51 <Cale> appamatto: I don't see what the distinction is between what you wrote and an awkward approximation of the real definition.
16:05:57 <pnielsen> I've tried to subscribe to the mailing lists (haskell and haskell-cafe) for about a month, and send an email to admin address listed, with no response whatsoever. Can anyone help?
16:06:04 <pnielsen> s/send/sent*
16:06:12 <appamatto> Cale, I'm using the same "maybe" function on both the value and type levels
16:06:17 <byorgey> pnielsen: what admin address?
16:06:24 <Cale> appamatto: You're using maybe as a synonym of Just
16:06:34 <roconnor> cabal-dev ghci says it cannot find my ghc
16:06:36 <pnielsen> byorgey: "Any problems with haskell or haskell-cafe should be reported to haskell-admin@haskell.org,"
16:06:47 <Cale> appamatto: now let's consider Either
16:06:50 <byorgey> pnielsen: how did you try to subscribe yourself?
16:06:54 <Cale> data Either a b = Left a | Right b
16:06:55 <shachaf> appamatto: What do you say about Maybe (Maybe a)?
16:07:01 <appamatto> Cale, I'm talking about a system where I can literally use maybe 5 or maybe Int because maybe a = a "or" Nothing
16:07:11 <Cale> appamatto: Let's look at Either :)
16:07:12 <pnielsen> byorgey: tried both via the mailman UI, and by sending an email to haskell-join@haskell.org
16:07:17 <Cale> So:
16:07:27 <Cale> Left :: a -> Either a c
16:07:31 <appamatto> Maybe (Maybe a) could reduce to a or Nothing I guess by that definition
16:07:33 <Cale> Right :: b -> Either c b
16:07:35 <byorgey> pnielsen: the mailman UI ought to work.  what happened when you tried?
16:07:38 <pnielsen> byorgey: I'm getting a feeling my domain is on a spam filter for haskell or something
16:07:50 <pnielsen> byorgey: "We have received your request blabla and it will soon be acted upon"
16:07:55 <pnielsen> byorgey: never receive any confirmation or list messages
16:08:01 <shachaf> Twist: pnielsen is protontorpedo.
16:08:13 <byorgey> pnielsen: hmm, yes, it sounds like you are not getting the email for some reason
16:08:17 <pnielsen> I don't understand that, but it sounds funny :)
16:08:34 <byorgey> pnielsen: is the Reply-To: in your email mangled for some reason?
16:08:39 <roconnor> oh .cabal/bin needs to be in the path
16:08:39 <appamatto> Cale, ok
16:08:40 * roconnor sighs
16:08:47 <Cale> appamatto: Neither of these is really a natural choice for the value level Either (though if you were going to do this, you'd certainly pick Right)
16:09:02 <Cale> (but that's for a technical reason I'm not even going to talk about now)
16:09:13 <pnielsen> byorgey: shouldn't be. Either way I never received confirmation from the UI. Let me check
16:09:16 <byorgey> pnielsen: also, do you have any spam filters/
16:09:28 <Cale> appamatto: But I mean look, the value level constructors for Either want only one parameter
16:09:30 <byorgey> pnielsen: of course you should make sure that the confirmation email is not getting filtered as spam
16:09:31 <rwbarton> @protontorpedo
16:09:31 <lambdabot> what does haskell do better than java perl or ruby?
16:09:32 <pnielsen> byorgey: it's Google Apps -- no mailman msg caught in spam
16:09:40 <Cale> appamatto: while the type level constructor wants two type parameters
16:09:48 <byorgey> pnielsen: hmm, then I am out of ideas
16:09:59 <pnielsen> so unless haskell's mailman is sending messages with incorrect signatures, I don't think so
16:10:11 <appamatto> Cale, ooh, nice example!
16:10:15 <Cale> appamatto: So surely it's going to be a problem if we start mindlessly identifying these things with each other, because we'll no longer be able to agree even on how many parameters the thing takes.
16:10:33 <appamatto> Cale, sounds like you need logic variables
16:10:47 <Cale> we need TYPE variables
16:10:50 <appamatto> left a = either a ?b
16:10:56 <appamatto> right a = either ?b a
16:11:06 <pnielsen> byorgey: any chance you could try to subscribe to one of them? It'd be helpful to know if it's a general problem or just me going nuts
16:11:18 <appamatto> Is there a problem with this?
16:11:26 <Cale> appamatto: what does either 5 6 mean?
16:11:41 <appamatto> It's just a constructor, so it means (either 5 6)
16:11:51 <Cale> IT NEEDS TO BE INVALID
16:12:02 <shachaf> Oh, now you got Cale going.
16:12:09 <Cale> The whole point of Either is that we have either one thing, or the other, and *NOT* both
16:12:18 <appamatto> Oh I see, I misunderstood Either
16:12:21 <byorgey> pnielsen: sure, I just tried, and got a confirmation email immediately
16:12:38 <pnielsen> byorgey: okay, thanks
16:13:27 <appamatto> (either 5 6) is frowned upon just like alternatie contsructions of the Either type
16:13:47 <appamatto> Couldn't you make a new constructor on the type level that violates Either as well?
16:14:00 <Cale> There are ridiculous numbers of bugs which are caused by OO programmers making this mistake. I spent several hours yesterday cleaning up a bunch of data where we had 200 or so event records which had both recurrence rules and recurrence base ids (indicating that the event is an exception to another event with a recurrence rule) -- it was never supposed to happen that an event had both, but due to this language's lack o
16:14:00 <Cale> f sum types, it did :)
16:14:19 <byorgey> appamatto: this is not very productive.  It seems like you are just engaging in wild speculation, rather than trying to understand Haskell.
16:14:32 <shachaf> Cale: What language?
16:14:34 <Cale> A + B is not the same as A * B
16:14:44 <Cale> shachaf: LOL groovy
16:14:58 <appamatto> byorgey: I'm trying to figure out how one could unify types and values via a language based on but not exactly Haskell
16:14:59 <shachaf> @where These
16:14:59 <lambdabot> data These a b = This a | That b | These a b
16:15:06 <appamatto> I understand how Haskell works
16:15:08 <shachaf> Cale: Groovy? What are you doing in Groovy?
16:15:09 <Cale> (mind you, this is a codebase inherited from a bunch of people who didn't understand OO in the first place)
16:15:23 <Cale> shachaf: The skedge.me backend is written in it.
16:15:29 <byorgey> appamatto: yes, that's exactly what I meant.  I'm not sure it is on-topic for #haskell.
16:15:42 * shachaf looks up skedge.me.
16:15:43 <Cale> shachaf: We're replacing the whole thing with Haskell shortly, but until then we still have to maintain this pile of junk :)
16:15:57 <appamatto> Cale: isn't defining Left and Right and hoping no one else defines Both the same as defining left and right and hoping no one uses either directly?
16:16:05 <rwbarton> shachaf: look out, don't get skedged
16:16:09 <Cale> I shouldn't badmouth it too much, it even mostly works
16:16:18 <Cale> and makes its customers happy
16:16:25 <Ralith> Enigmagic: blah, on further consideration I think doing this *without* type-level strings is futile.
16:16:27 * hackagebot data-lens-template 2.1.6 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.6 (RussellOConnor)
16:16:29 * hackagebot Workflow 0.7.0.3 - Monad transformer for thread state persistence and workflow patterns  http://hackage.haskell.org/package/Workflow-0.7.0.3 (AlbertoCorona)
16:16:32 <Cale> but there are quite a few bugs which are just about impossible to remove
16:16:40 <Cale> without a complete rewrite
16:16:45 <appamatto> byorgey: hmm, is semi-haskell talk against the rules? :p
16:16:55 <cmccann> ...since when does lambdabot know about These? D:
16:17:08 <shachaf> cmccann: Since about a minute ago.
16:17:17 <Ralith> certainly the unsafe approach is dramatically better behaved.
16:17:20 <Cale> appamatto: If you want to change the definition of Either, you have to edit Prelude.hs in GHC, and recompile *everything*
16:17:20 <Jafet> Once Either is defined, it cannot be changed.
16:17:21 <Ralith> (ironically)
16:17:37 <shachaf> appamatto: I think it's more that people feel like you're putting random words next to each other and then asking "what would it be like if that existed?".
16:17:45 <shachaf> I haven't really been following, though. :-)
16:18:01 <appamatto> Right, so Either is shielded away behind the module system
16:18:05 <Enigmagic> Ralith: why's that?
16:18:06 <Jafet> I do that with pornos
16:18:50 <Ralith> Enigmagic: a characteristic of named structs is being able to uniquely identify structurally identical structs.
16:19:06 <Cale> appamatto: similarly with functions and other values though -- if someone defines something, you can't just redefine it without changing the source code and rebuilding
16:19:33 <Cale> (you can add instances to a typeclass though, which is a sense in which things are extensible)
16:20:04 <appamatto> Cale, right. So I would expect a similar restriction on directly using either
16:20:10 <Enigmagic> Ralith: could you use a Typeable instance instead of a type level string?
16:20:13 <appamatto> (the value-level either)
16:20:46 <Cale> appamatto: The point is, there is no value level either -- what you're trying to do is insufficiently general. A few more examples, and you'll start to see :)
16:21:08 <Cale> I really want to do Cont
16:21:17 <appamatto> I would love more examples!
16:21:19 <Cale> but I don't know if this is going to go over well :)
16:21:35 <Cale> appamatto: Okay, so you have to really try to understand the Haskell syntax for what it is here :)
16:21:47 <Cale> data Cont r a = C ((a -> r) -> r)
16:21:57 <rwbarton> also in the afraid to suggest category here: agda
16:22:09 <shachaf> @arr a = (a -> arr) -> arr
16:22:09 <lambdabot> Drink up, me 'earties
16:22:18 <Cale> Okay, so in particular, think about  Cont Bool Integer
16:22:33 <Ralith> Enigmagic: I don't think so. Perhaps a purpose-specific typeclass... but the number of hoops to jump through is climbing awfully fast here.
16:22:42 <Cale> a value of type Cont Bool Integer is the data constructor C applied to a function of type (Integer -> Bool) -> Bool
16:23:03 <Cale> that is, it essentially consists of a box which takes yes or no questions about integers, and answers them somehow
16:23:22 <appamatto> Oooh
16:23:56 <Cale> In general,  Cont r a   is the type of black boxes which take r-valued questions about values of type a, and answer them (with a value of type r)
16:24:06 <Cale> These boxes may actually lie
16:24:07 <Ralith> Enigmagic: this very quickly turns into a dummy type with a big bag of attributes tied onto it through typeclasses.
16:24:20 <Cale> Or they may really contain somehow a value of type a, which they are applying the question to :)
16:24:30 <Ralith> which is supremely awkward compared to the normal approach.
16:24:50 <appamatto> Cale, okay
16:24:58 <Cale> appamatto: My point is, this type has nothing to do with just a plain Bool and an Integer
16:25:02 <Ralith> (in the C API, or even with anonymous structs in the existing bindings)
16:25:04 <Cale> It's something more structured isn't it?
16:25:14 <cmccann> :t (>>>) <<< (>>>) <<< (>>>) <<< (>>>) -- nested fmap for Cont
16:25:15 <lambdabot> forall c c1 c2 (cat :: * -> * -> *) a b c3. (Control.Category.Category cat) => cat a b -> (((cat a c3 -> c2) -> c1) -> c) -> ((cat b c3 -> c2) -> c1) -> c
16:25:23 <appamatto> Cale, that's because it's on the type level
16:25:24 <ddarius> Thankfully programs are recursively enumerable.
16:25:27 <cmccann> that's still my favorite operator.
16:25:36 <appamatto> I don't see why the same expression couldn't be more "mundane" on the value level
16:25:39 <ski> @type cont (\_ -> True)  -- answer every question with `True'  (`cont' corresponds to Cale's `C' above)
16:25:40 <lambdabot> forall a. Cont Bool a
16:26:24 <ski> @type cont (\q -> q "cat")  -- only answer `True' if the given question answers `True' to `"cat"'
16:26:25 <lambdabot> forall r. Cont r [Char]
16:26:28 <Enigmagic> Ralith: i suppose you want named structs that are defined at runtime... which would be pretty clumsy to do without type level strings
16:27:15 <ddarius> Woo, more money.
16:28:17 <Ralith> Enigmagic: I don't actually need that in this particular immediate case, no, though I may in the future.
16:28:33 <Ralith> I think I'm just having a hard time with the representation problem.
16:28:46 <Enigmagic> Ralith: actually it might not be so bad... you could have a wrapper type that was basically newtype NamedStruct a = NamedStruct (String, a)
16:28:46 <Ralith> possibly due to being tired and unfamiliar with this sort of thing.
16:28:57 <Enigmagic> Ralith: where a was a StructFields instance
16:29:58 * ski still isn't sure what appamatto and Cale are discussing
16:30:45 <appamatto> ski: I'm trying to figure out if you can replace values/types with values only (whose types are other values)
16:31:01 <appamatto> And I think Cale is saying it's not posible
16:31:34 <Ralith> Enigmagic: think you could give an example of defining a C-style linked list struct under that?
16:31:49 <ski> well, in dependently typed programming, types are in some sense values -- but we still can say that one value is the type of another value there
16:32:17 <rwbarton> and if you can't say that one value is the type of another value, you don't have types at all
16:32:33 <appamatto> Cont r a x | x == (a -> r) => r
16:32:59 <ski> appamatto : i'm not sure how to interpret that
16:33:11 <appamatto> Which part?
16:33:24 <appamatto> Is that not the proper guard syntax?
16:33:37 <ski> the `... | ... == ... => ...' part
16:34:01 <ski> @src take
16:34:01 <lambdabot> take n _      | n <= 0 =  []
16:34:01 <lambdabot> take _ []              =  []
16:34:01 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:34:26 <ski> ^ the first definition equation of `take' there uses a guard
16:34:44 <appamatto> Oh sorry, it's cont r a x | x == (a -> r) = r
16:35:33 <ski> appamatto : i still don't see what your `cont' has to do with the usual `Cont'
16:35:55 <appamatto> Well, I think that cont :: Cont
16:35:59 <ski> in your case, `x',`r',`a' appears to all be types
16:36:45 <appamatto> .. and cont :: cont?
16:36:52 <ski> let's temporarily assume that `==' is defined on types, and that Haskell functions could take types as argument (i.e. the type of the (type) argument would be `*')
16:37:02 <ski> then it appears that, for your `cont' :
16:37:08 <ski>   cont :: * -> * -> * -> *
16:37:14 <ski> however
16:37:17 <ski> @kind Cont
16:37:18 <lambdabot> * -> * -> *
16:37:44 <appamatto> Ah, there is a constructor in there
16:37:55 <ski> so, your `cont' seems to be a type function which takes three arguments (being types)
16:37:57 <rwbarton> in appamatto's universe there is no distinction between type application and the type of value application
16:38:04 <ski> while the usual `Cont' only takes two arguments
16:38:09 <rwbarton> this makes it rather treacherous for us Haskellers
16:38:47 <appamatto> rwbarton: well said
16:39:07 <Enigmagic> Ralith: hum well that's not going to work.
16:39:10 <rwbarton> (appamatto's universe also makes no sense)
16:39:15 <ddarius> rwbarton: In a world with contradictions, I can have a flying pony.
16:39:17 * ski isn't sure what "the type of value application" means
16:39:20 <appamatto> And my question is: in Haskell, why is there a difference between type application and the type of value application?
16:39:28 <rwbarton> ski: if you apply the type (a -> b) to the type a you get the type b
16:39:54 <appamatto> Yes
16:40:06 <appamatto> Where -> could be defined as: -> a b c | a == c = b
16:40:12 <Ralith> Enigmagic: cycles do make things hairy.
16:40:35 <appamatto> So (a -> b) is a partial application
16:40:56 <ski> appamatto : maybe one fruitful way to think here is to classify types into "concrete types" and "non-concrete types"
16:41:35 <Enigmagic> Ralith: it's not so much the cycles, they'd be easy to handle with regular data types
16:41:56 <Ralith> regular data types?
16:42:03 <Enigmagic> Ralith: data Foo1 = Foo1 (Value (Ptr Foo2)); data Foo2 = Foo2 (Value (Ptr Foo1))
16:42:05 <ski> appamatto : where by "concrete type" i mean a type for which it is conceivable that there can be a value having that type
16:42:10 <Ralith> oh yes
16:42:20 <ski> appamatto : now, it's probably not quite clear what i mean by this
16:42:30 <Ralith> I don't mean cycles are *inherently* hard to do
16:42:35 <Ralith> I mean they break a lot of the obvious approaches.
16:42:44 <Enigmagic> Ralith: if you want to define the struct types using the tuple thing in the llvm package it becomes impossible
16:42:58 <ski> appamatto : but consider e.g. the type `Bool'. the possible values of this type is `False', and `True', so certainly `Bool' must be a concrete type
16:43:19 <Ralith> Enigmagic: for example, yes.
16:43:23 * ddarius is pretty sure the most fruitful thing is for appamatto to go look at books and research about type theory and/or put together a set of rules, similar to the ones defining the simply typed lambda calculus, that would allow someone to calculate these things and their consequences rather than attempting to produce a bunch of seemingly arbitrary, unmotivated "definitions".
16:43:29 <ski> appamatto : do you follow ? should i continue along this line of explanation ?
16:43:29 <Enigmagic> Ralith: it would be essentially this (which is invalid): type Foo = (Value (Ptr Foo))
16:43:35 * Ralith nod
16:44:00 <Ralith> because type synonyms can't cycle
16:44:13 <appamatto> ski, yes, I follow
16:44:46 <appamatto> It sounds like types whose habitation can be shown statically
16:45:30 <ski> appamatto : now, i hope you will agree that `Int', `[Bool]', `(String,Int)', `Bool -> Bool' are also concrete types
16:45:50 <appamatto> ski, yes
16:46:00 <ski> (i think you can think of at least one example of a value of each of those types)
16:46:00 <Enigmagic> Ralith: lemme try something else
16:47:01 <ski> appamatto : now, let's recall that the notation `[Bool]' is really syntactic sugar for `[] Bool'. similarly, we can think of `Bool -> Bool' as syntactic sugar for `(->) Bool Bool'
16:47:32 <ski> appamatto : now, to emphpasize the regular structure here, i'll write these two types as `List Bool' and `Fun Bool Bool' instead
16:48:11 <ski> similarly, instead of `(String,Int)', which can be seen as syntactic sugar for `(,) String Int', i'll write `Prod String Int'
16:48:22 <appamatto> Yes, although I might disagree that -> should merely be a constructor
16:48:40 <ski> now, there's also types like `Maybe Int' and `Either String Int' in Haskell
16:48:59 <pnielsen> byorgey: Turned out to be a really old filter from last time I was subscribed. I was looking for the messages in spam, but they were elsewhere. Sorry to you and anyone else for the astounding level of stupidity I just exposed you to.
16:49:01 <ski> values of `Maybe Int' e.g. are : `Nothing', as well as `Just x', for every possible value `x' of type `Int'
16:49:46 <appamatto> Yes, I understand that
16:49:52 <ski> similarly, values of type `Either String Int' are : `Left x' for every `x' of type `String', and `Right y' for every `y' of type `Int'
16:50:13 <ski> something similar holds for `List Bool'
16:50:54 <ski> appamatto : now, i'm claiming that `List' itself, is a "non-concrete type"
16:51:04 <ski> another term might be "incomplete type"
16:51:27 <ski> we can't just say that a value has type `List' : list of *what* ?
16:52:07 <ski> we need to specify the element type as well, to get to a concrete type
16:52:08 <appamatto> Okay, that's where I think there might be some work to be done
16:52:18 <ski> (and the element type should be a concrete type)
16:52:30 <appamatto> I mean, that's where I think we could change Haskell to make it more regular
16:52:36 <ski> so, for every concrete type `X', `List X' is also a concrete type
16:53:20 <appamatto> If nothing inhabits List then nothing should inhabit List Int
16:53:21 * ddarius finds this differentiation between Strings and functions confusing.  We should get rid of it.
16:53:39 <shachaf> "\\x -> x" is basically a function.
16:53:47 <ski> appamatto : ok. i'm not quite sure i see where you think there might be some work to be done here
16:54:49 <appamatto> ski, what I mean is that if it's possible to unify values and types then there must be some value whose type is List
16:54:58 <ski> appamatto : by "If nothing inhabits List then nothing should inhabit List Int", are you suggesting that there ought to be something that inhabits (in some sense) `List' ?
16:55:04 <appamatto> Yes
16:55:12 <ski> ok
16:55:27 * monochrom does not help
16:55:41 <ski> should the things that inhabit `List' then be values in the same sense as e.g. the things that inhabit `Bool' and `List Bool' ?
16:55:47 <monochrom> eval eliminates the line between string and program
16:55:55 <appamatto> ski, yes
16:55:55 * cmccann won't accept any value of type "List" other than foldr.
16:56:20 <ddarius> monochrom: No it doesn't.  Or does length eliminate the line between string and number?
16:56:23 <ski> appamatto : ok. i have to say i find the first statement here more believable than the second
16:56:36 <Cale> cmccann: not even map? :D
16:56:58 <cmccann> pf, map is overrated.
16:57:12 <ddarius> cmccann: Yeah, who believes in functors?
16:57:24 <DT``> appamatto, when you have a something that is everything, bad things happen(tm).
16:57:59 * ddarius interprets DT``'s phrase as "God exists therefore bad things happen."
16:58:22 <cmccann> ah, we're into theology now?
16:58:28 * cmccann goes back to playing with linear logic.
16:58:30 <appamatto> Ah, I think I have it
16:58:34 <ddarius> Yay linear logic!
16:58:43 <ski> appamatto : my understanding is that the distinction (which i've been attempting to make) between "concrete types" and "non-concrete/incomplete types" here is a useful distinction -- so it'll be hard to convince me that we should discard this distinction (if that is indeed what you're suggesting)
16:58:50 <ddarius> cmccann: You ever read the Olli thesis and LolliMon paper?
16:58:57 <c_wraith> @quote theomorphism
16:58:57 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
16:58:57 <lambdabot> object in the category of religions and theomorphisms.
16:59:09 <appamatto> list a = [] or a:[]
16:59:30 <cmccann> ...maybe? I've read a bunch of stuff about linear logic but I'd have to look through a huge pile of PDFs to find specific names, heh.
16:59:34 <appamatto> the type of list is List
16:59:43 <ddarius> cmccann: Install Google Desktop.
17:00:11 <ski> appamatto : otoh, that "incomplete types" could (in *some* sense) be said to have values, i would find easier to accept (but in any case, those "values" would have to be of a different "quality" than ordinary values of "concrete types")
17:00:11 <ddarius> cmccann: Are you familiar with CLF (the Concurrent Logical Framework)?
17:00:31 <cmccann> doesn't ring a bell, no.
17:00:55 <monochrom> I don't think length is quite on the same level as eval. when you call length, you get a number, and there is no side effect. when you call eval, it has all kinds of side effects, and it probably doesn't even return
17:01:05 <Cale> Of course, we could just decide to start having values whose types have non-* kinds
17:01:08 <ddarius> > length [0..]
17:01:12 <lambdabot>   mueval-core: Time limit exceeded
17:01:14 <appamatto> ski, does that make sense?
17:01:25 <appamatto> By "or" I'm referring to a non-deterministic choice
17:01:27 <ski> appamatto : not to me, at least
17:01:35 <monochrom> parse :: String -> AbstractSyntaxTree is more on the level of length
17:01:41 <ddarius> Cale: We already do sort of (unless you define a value as something with kind *, then, of course, we don't.)
17:01:54 <appamatto> Because type level programming is closer to logical programming I have to use a logic programming construct in the value level
17:01:57 <ddarius> appamatto: You should look at ontic.
17:02:05 <Cale> ddarius: Well, we have unboxed values :)
17:02:51 <Cale> ddarius: But I mean, we could just decide to populate Either :: * -> * with a bunch of values, and admit that as a complete type signature. It wouldn't make any sense to do it, but we could.
17:03:13 <ski> appamatto : well, but non-deterministic choice is only available for combining propositions in logic programming, not for combining arbitrary expressions
17:03:14 <Cale> er, Either :: * -> * -> *
17:03:27 <ski> (at least in Prolog -- maybe you're thinking about Curry or Escher ?)
17:04:01 <appamatto> ski, in Curry I believe you can combine expressions that way
17:04:07 <ski> Cale : i have some vague idea about how one could make some sense of it, at least in some cases :)
17:04:10 <rwbarton> appamatto: can't you just (nondeterministically if you like) pick one of list a = [] or list a = a:[] once and for all as your example... what can this "nondeterministic choice" gain you
17:04:15 <ski> appamatto : i think so, yes
17:04:40 <ski> appamatto : however, if you define `list' by `list a = [] or a:[]', then how is `[]' and `:' defined ?
17:04:54 <appamatto> Yes, so I think that foo = bar ? baz is the value level equivalent to data Foo = Bar | Baz
17:05:54 <ski> (where `?' is your previous `or' ?)
17:05:58 <appamatto> Yes
17:06:18 <ddarius> List A = { x | x = [] or x = a : as where a in A and as in List A }
17:06:28 * hackagebot process-extras 0.2.0 - Process extras  http://hackage.haskell.org/package/process-extras-0.2.0 (DavidLazar)
17:06:49 <rwbarton> I'm beginning to wonder if this is all the most elaborate troll ever to visit #haskell
17:06:56 <appamatto> Hahaha
17:07:12 <appamatto> I'm not trying to troll, I've been trying to sort this out for a week
17:07:16 <ski>   List A = do {return []} `mplus` do {a <- A; as <- List A;  return (a:as)}  -- ho hum
17:07:21 <ddarius> rwbarton: I'm pretty sure there have been more elaborate trolls.
17:09:08 <otters> how do I find the index of a sublist in a list?
17:09:10 <appamatto> ski, nil and cons would be constructors
17:09:26 <ski> appamatto : i understand (or believe, if you will) that you're not trying to troll. however i highly suspect that you're at least partially confused about these issues (and thus would do well to try to better understand the kind system). however i'm willing to accept that there could be some useful intuition/idea in your trains of thought
17:09:59 <ski> appamatto : constructors of what ? or would constructors (i assume you mean data constructors) be defined independently of types ?
17:11:03 <ddarius> otters: It depends on how fast you want to do it and what you mean by "sublist".
17:12:22 <appamatto> ski, I was thinking you would define say: Z :: Nat  and S :: Nat -> Nat
17:12:52 <appamatto> So yes, they are related to their types
17:13:37 <ski> @type \sublist -> findIndex (sublist `isPrefixOf`) . tails
17:13:38 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe Int
17:13:50 <appamatto> They don't get reduced because they don't have any value level reduction rules associated with them
17:14:25 <ski> appamatto : i thought you'd want to define `Nat' by something like `Nat = Z ? S Nat' ?
17:14:50 <appamatto> Yeah, I'm not sure about '?' yet
17:15:29 <appamatto> But I do think that (S Z) :: (Nat -> Nat) Nat which is to say :: Nat
17:16:53 <ski> i'm not sure why you (apparently) want `(A -> B) A' to evaluate to `B'
17:17:16 <shachaf> Is this thing still going on?
17:17:30 <ski> also, what would `(Bool -> String) Int' evaluate to ?
17:17:37 <ski> shachaf : yeah :)
17:17:39 <Ralith> appamatto: I recommend Pierce's Types and Programming Languages
17:17:54 <ski> appamatto : i second that recommendation
17:17:58 <appamatto> ski, no solutions
17:18:10 <ski> appamatto : ok
17:18:26 <appamatto> -> is defined as -> a b c | a == c = b
17:18:35 <appamatto> So the type checker would crash or fail
17:19:01 <ski> appamatto : how about `(Either Int Int) Int' ?
17:19:49 <shachaf> I,I compose :: (b,c) -> (a,b) -> (a,c)
17:20:15 <appamatto> I don't think there is a reduction rule for either, right?
17:20:33 <ski> not in Haskell, no
17:20:43 <ski> (neither is there one for `(->)' in Haskell)
17:20:58 <appamatto> There is left a = either a ?b and right a = either ?b a
17:21:04 <Ralith> appamatto: go read that book.
17:21:45 <appamatto> I think I've read it before... also read the lambda cube paper and other papers. Of course it doesn't mean that I understood it
17:21:48 <daniel_-> anyone like to answer what their biggest pet peeve with haskell is in general. (just asking because i'm bored, no specific reason)
17:22:12 <shachaf> I suspect people won't like to answer that.
17:22:20 <appamatto> Here's my central intuition: there isn't normal value reduction on the type level because we don't want non-determinism during reduction
17:22:47 <ski> appamatto : well, for type synonyms, there's reduction
17:22:54 <ski> but those can't be recursive
17:23:14 <daniel_-> yeah i dont really mind, just would find it interesting to know since im still quite new to haskell and it's ecosystem.
17:23:15 <appamatto> If you are in a logic/fp system like Curry then (in my intuition) you should be able to use the same system for values and types because non-determinism and search is built into the core language
17:23:15 <ski> (there's also reduction for type families)
17:24:01 <appamatto> Also you don't have to worry about type inference settling on the most general unification because you're used to dealing with multiple unifications
17:24:05 * cmccann has too many pet peeves about Haskell and can't choose just one :[
17:24:37 <cmccann> but having recently been reminded the lack of a Natural type is what comes to mind first. because, really. WHY.
17:24:51 <shachaf> cmccann: Type-level naturals exists in GHC 7.6!
17:24:59 <shachaf> Maybe someday we'll get value-level naturals.
17:25:03 <appamatto> So you could make all of these claims: id :: id, id :: Nat -> Nat, id :: (+ 0), etc.
17:25:09 <cmccann> ARRRRRRRRGH.
17:25:25 <rwbarton> cmccann, presumably because of the lack of a type class with (+) and (*) but not (-)
17:25:32 <Twey> daniel_-: The fact that it keeps flirting with depedent types without actually going there.
17:25:37 <ski> daniel_- : i suppose one is that `Functor' (and `Applicative') are not superclasses of `Monad' (yes this is a library issue) -- however, language-wise it would be nice to have something like the superclass and class alias proposals, only working
17:25:40 <appamatto> ski, does that explain more of where I'm coming from?
17:25:41 <DT``> appamatto, you're dangerously near letting Type :: Type.
17:25:53 <cmccann> rwbarton, and yet: Word exists.
17:25:59 <appamatto> DT``, well I think that :: should be reflexive
17:26:06 <rwbarton> well I can subtract Words, it's modular arithmetic
17:26:29 <shachaf> Is Word subtraction defined in Haskell?
17:26:32 <rwbarton> and I still have a + (b - a) = b
17:26:34 <shachaf> Oh, Words aren't even in the report.
17:26:37 <rwbarton> right
17:27:14 <ski> appamatto : when you say "make all of these claims", do you mean that you should be able to state them (i.e. form them as questions), to do you mean that they (additionally) ought to be true/provable/derivable ?
17:27:15 <DT``> appamatto, when Type :: Type, bad things happen.
17:27:15 <cmccann> anyway, the inanity of Num is another issue. people write lots of sketchy Num instances anyway.
17:27:25 <shachaf> Like Double.
17:27:28 <shachaf> That's a very sketchy instance.
17:27:40 <shachaf> (It's even sketchier as an Eq instance, I guess.)
17:27:41 <appamatto> ski, I think that they are all true/provable/derivable
17:27:44 <DT``> like the type theory equivalent of Russell's paradox.
17:28:17 <appamatto> DT`` can you construct Russell's paradox in constructive math?
17:28:19 <Philippa> Twey: I'd say not actually going there is Haskell's purpose in life these days
17:28:27 <Twey> Pretty much, yes
17:28:29 <cmccann> shachaf, ah yes, the common misconception that floating point values are "numbers" in any common sense. :]
17:28:37 <ski> appamatto : "does that explain more of where I'm coming from?" -- not really; e.g. i don't really see why you'd like `::' to be reflexive
17:28:44 <shachaf> "floating point values". That's a good phrase.
17:28:59 <Twey> Philippa: I suppose it makes sense; better to start afresh, maybe
17:29:01 <appamatto> ski, well my idea is that the most specific type of 1 is 1, for example
17:29:11 <ski> appamatto : perhaps by `A :: B' you would like to mean something like : the solutions of `A' are all included amongst the solutions for `B' ?
17:29:11 <DT``> appamatto, I can't find a source, but yes, if Type :: Type, because then Type is the universal set.
17:29:34 * cmccann at least gives NaN credit for fessing up to the reality of the matter, unlike other floating point values. 
17:29:40 <Twey> appamatto: But it doesn't work for the intermediate values.  1 : Nat, but Nat !: 1.
17:30:02 <appamatto> Twey, yes, there is an ordering in the relationship
17:30:25 <appamatto> It's not commutative
17:30:30 <ddarius> Haskell hasn't even remotely "flirted" with dependent types and "going there" would radically change the language.
17:30:45 <appamatto> ski, I think that's somethnig like what I mean
17:31:15 <appamatto> ski, basically, A :: B means that B has some amount of information about A, possibly all the information, in which case B is A
17:31:28 * hackagebot tagged 0.4.4 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.4.4 (EdwardKmett)
17:31:37 <cmccann> the easiest way to add dependent types to Haskell is to replace your GHC with a symlink to an Agda compiler
17:31:57 <ddarius> cmccann: What's a number?
17:32:04 <appamatto> ski, that's what I think is implied by the ability to say 1 :: 1, 1 :: Nat, and 1 :: * at the same time
17:32:29 <DT``> that's subtyping.
17:32:44 <ski> appamatto : hm -- in the former case `A :: B', if we think of the set of solutions of `A' (let's call it `SA'), and the set of solutions of `B' (`SB'), then what i said would amount to that `SA' is a subset of `SB'
17:32:45 <dolio> No, it's just messy.
17:33:04 <dolio> If you want the smallest set including one, it's {1}, not 1.
17:33:07 <pordan30> it's possible to flirt with dependent types in haskell. connor mcbride showed how to partially simulate dependent types in haskell using multi-parameter type classes and functional dependencies in his paper "simulating dependent types in haskell."
17:33:37 <dolio> If :: were reflexive, you'd have Nat :: Nat. Why would I want Nat to be a natural number?
17:33:40 <appamatto> DT``: I'm not sure that it's subtypes
17:33:44 <ddarius> pordan30: No, that's just type level computation and the normal type driven resolution that type classes are.
17:33:49 <dolio> Why is Word32 a Word32?
17:33:56 <Eduard_Munteanu> I don't think we're too far from introducing limited dependent types in Haskell.
17:33:57 <ski> appamatto : however, your "B has some amount of information about A, possibly all the information" i could alternatively interpret as the set of solutions of `B' being a quotient set of the set of solutions of `A'
17:33:58 <dolio> Why is \x -> x a type at all?
17:34:13 <dolio> Capable of having inhabitants?
17:34:19 <appamatto> dolio: \x -> x is the type of Id
17:34:22 <appamatto> id*
17:34:24 <dolio> No, it is not.
17:34:28 <DT``> appamatto, it is, 1 is the singleton type {1}, and {1} is a subtype of Nat.
17:34:28 <Twey> ddarius: It's trying very hard to get as many of the features of dependent types as possible, but is resolute to not actually get dependent types
17:34:41 <Eduard_Munteanu> For example, length-indexed lists.
17:34:45 <pordan30> ddarius: that's the difference between partially simulating the effects of dependent types and partially introducing dependent types, though.
17:34:46 <ski> appamatto : hm, your assertion of '1 :: *' seems to suggest you think `::' should be transitive as well
17:35:16 <appamatto> ski, I think that might be the case, but at least A :: * for all A
17:35:28 <appamatto> Otherwise how could A exist in the type level?
17:35:35 <ddarius> Twey, pordan30: Type level computation is fairly orthogonal to dependent types.  Indeed, type level lambda and the associated reduction rules are a separate axis in the lambda cube from dependent types.
17:35:50 <ski> dolio : i think in appamatto system, `Nat' would possibly mean, nondeterministically, any specific natural number
17:36:15 <ddarius> We could allow arbitrary computation at the type level (and do) and still not support dependent types at all.
17:36:36 <appamatto> ski, I think that's right (about non-determinism)
17:36:50 <Philippa> butbutbut there's an encoding! It's just like supporting polymorphism in the simply-typed lambda calculus by erasure!...
17:36:59 <Philippa> (how blatantly should I signpost the sarcasm there?)
17:37:08 <appamatto> ski, does this seem tenable at all?
17:37:46 <DT``> use the irony mark, Philippa: http://en.wikipedia.org/wiki/Irony_punctuation#Irony_mark
17:38:09 <ddarius> Eduard_Munteanu: You can't write: do i <- readInteger; replicate i 10 :: List i Int.  Dependent types would allow this.
17:38:41 <ddarius> + return
17:38:51 <appamatto> ski, the idea is that you could execute your entire program on the type level statically, or just as much as is possible
17:39:07 <ski> appamatto : "Otherwise how could A exist in the type level?" -- well, in dependent typing, you have a `::' relation which relates values (well, syntactically expressions) to values (ditto) -- without having `A :: *' for all `A'
17:39:40 <Eduard_Munteanu> ddarius: I'm not sure, don't type-level nats allow you to do that?
17:39:45 <ddarius> Eduard_Munteanu: No.
17:40:06 <dolio> You can do something equivalent to ddarius' example in GHC, but not exactly that.
17:40:20 <Eduard_Munteanu> This is all very natural in Agda. :)
17:40:22 <appamatto> ski, I'm not really sure what the value of * is in my system
17:40:45 <appamatto> ski, it might just be better to have a symbol which represents no knowledge at all
17:40:49 <ddarius> dolio: It wouldn't be equivalent.  To talk about the type of replicate, you'd have to hide the length index, at which point all you've done is make a round-about definition of [].
17:41:36 <ski> appamatto : "does this seem tenable at all?" (assuming you refer to "at least A :: * for all A") -- i'm not sure at all
17:41:59 <dolio> You're going to have to wrap it up in a dependently typed language, too, eventually.
17:42:08 <appamatto> ski, I was refering to the whole program I'm embarking upon :p
17:42:41 <Eduard_Munteanu> Arguably you don't need to end up with a theorem prover, though.
17:42:42 <ski> appamatto : well, it's still unclear to me :) i only have a vague idea about what you're attempting to do
17:42:58 <dolio> Unless you use it up and return something not depending on i by the end of the block.
17:43:45 <ddarius> dolio: Which you could do modularly in a dependently typed language.
17:43:50 <Philippa> appamatto: having been in a position not unlike yours a long time ago, good luck and let us know when you've got things we can play with?
17:43:58 <ski> appamatto : however, i think you should try to understand how the kind system in Haskell works, and possibly also how typing in dependent type systems work (e.g. universe levels) -- also, you should be open to the possibility that some of your intuitions might to work out well
17:44:17 <ddarius> As I've said a few times, Ontic has several aspects of what he is talking about, though not the silly ones.
17:44:38 <dolio> Well, I'm not going to argue that GHC doesn't suck at it. You can't really write a general purpose sigma.
17:44:47 <Philippa> I never did get round to checking out Ontic. I imagine I really should?
17:44:51 <appamatto> ski, yes I've been reading about Omega which has many levels of kinds
17:44:53 <ddarius> Philippa: Not really.
17:45:08 <Philippa> appamatto: have you read through something like TaPL?
17:45:10 <ski> appamatto : s/might to work out/might not work out/
17:45:12 <appamatto> I've read about typing in dependent systems but I've always been bothered by the difference between pi and lambda
17:45:25 <Philippa> ski: as a rule one should be open to both possibilities!
17:45:25 <dolio> Actually, maybe with kind polymorphism you can get closer, but type functions still aren't first class.
17:45:44 <appamatto> Actually I was at a dead end for a long time until I discovered logic programming
17:46:20 <appamatto> I think that's the final piece of the puzzle, because you don't have to run away from non-determinism in type inference and unification
17:46:43 <Philippa> as a rule, non-determinism in type inference is really not your friend
17:46:50 <ddarius> If you thinks that's the "final" piece of the puzzle, then you definitely haven't seen the whole picture.
17:46:53 <ski> appamatto : having said that, i think that trying to specify better what system is about, how the type system (static semantics) works, and how the dynamic semantics (say operational semantics or denotational semantics) of it would look like would be a useful exercise for you (regardless of whether you succeed, or fail, or radically change your basic idea)
17:46:54 <Philippa> union and intersection types exist, sure
17:47:12 <appamatto> I think pi is different from lambda because we expect pi statically computable
17:47:15 <Philippa> (sometimes I think intersection types are for when you don't know how to talk about conjunctions of constraints...)
17:47:33 * ddarius does not describing signals as "Gaussian" or "non-Gaussian".
17:47:52 <dolio> Why do you think sigma is different from lambda?
17:47:54 <DT``> appamatto, what do you mean pi is different from lambda?
17:47:58 <Philippa> ddarius: I've been finding "final" pieces for about a decade now, I reckon. Except what they're pieces of keeps growing, of course
17:48:02 <appamatto> ski, yes, part of this idea is divorcing the need for the type system to be statically computable
17:48:16 <Philippa> appamatto: read up on Pure Type Systems
17:48:24 <DT``> ^
17:48:24 <appamatto> DT``: in the lambda cube pi and lambda are similar but different
17:48:32 <appamatto> I've read the PTS papers...
17:48:38 <Philippa> well yes. Lambda is evidence for pi
17:49:00 <Philippa> cruel fate has allowed : to separate them forever
17:49:08 <appamatto> But I think the motive for making pi different from lambda is to make type level expressions static
17:49:36 <DT`> it's not required.
17:49:38 <appamatto> ski, thank you for the input, I'm trying to write some expressions in the language to see what it would be like
17:49:53 <Philippa> appamatto: have you read up on erasure PTSes as well, and compared the two?
17:49:59 * ski has just been finding "pieces" for a long time :)
17:50:08 <appamatto> Philippa: haven't heard of erasure PTS
17:50:18 <Philippa> ski: there's usually /something/ you can finish with any given piece, but yeah :-)
17:51:12 * ddarius has been finding jigsaws for a long time.
17:51:27 <appamatto> One overall intuition I have is that more powerful things like dependent types bump up against decideability, but that can be mitigated by allowing non-determinism
17:51:51 <appamatto> You can always prove later on that your program works deterministically even if the type-level computation isn't
17:52:03 <ski> appamatto : at one time, i was considering a variant of Prolog, where types were replaced by predicates -- only that some predicates were to be statically checked and others dynamically checked
17:52:19 <DT`> (contracts?)
17:53:34 <appamatto> ski, that sounds like this, since t :: T is a predicate
17:55:51 <ski> appamatto : something like `<sum(A0,B,AB0) :- {nat(A0),nat(B),nat(AB0)},( A0 = zero,AB0 = B ; A0 = succ(A),AB0 = succ(AB),sum(A,B,AB) )>', where the things inside `{...}' (and outside `<...>') were to be computed at compile-time
17:57:07 <ski> appamatto : the idea was that this would execute by some variant of partial evaluation / staged programming (and yes, you should probably look up that if don't know it)
17:57:25 <appamatto> ski, do you know ATS?
17:57:56 <appamatto> I think it has something similar to staged programming
17:57:58 <ski> (here nat/1 was meant to be a static predicate, defined e.g. as `nat(N0) :- ( N0 = zero ; N0 = succ(N),nat(N) )')
17:58:15 <ski> i don't know ATS, i've only heard (very little) about it
17:59:04 <Philippa> appamatto: using non-determinism won't save you from undecidability or semi-decidability
17:59:17 <ddarius> halts(p) = true or false
17:59:31 <appamatto> Philippa: sure, but I don't mind if the type checker doesn't halt
17:59:41 <appamatto> I'll just Ctrl-C and add some more type annotations
17:59:42 <ski> (however, the idea above was that instead of just being able to express static properties ("types") of variables, one would also be able to express static relations between them -- e.g. that some predicate expects two arguments, which happen to be lists, to have the same length)
18:00:17 <Philippa> appamatto: of course not. But then you're just back to doing the same old stuff. You can go fix yourself at the type level as easily as the value level - see Cayenne
18:00:18 <appamatto> ski, I'm thinking something similar--how did that work for you?
18:00:44 <ddarius> ski probably woke and realized Prolog is a horrible language.
18:01:02 <ski> appamatto : heh, i didn't complete it :)
18:02:48 <appamatto> Okay, well you all have given me a lot to think about. Time to start hacking!
18:03:06 <ski> ddarius : (: despite its many flaws, i still find it a nice (and yes, sometimes horrible) language
18:03:23 <ddarius> ski: Use lambdaProlog.
18:05:04 <ski> lambdaProlog still has cut and side-effects
18:06:09 <ddarius> I'm not sure there's a good answer for side-effects in logic languages outside of substructural logics.
18:06:29 * hackagebot fugue 0.1 - A recapitulated prelude with minimal dependencies  and profligate exports.  http://hackage.haskell.org/package/fugue-0.1 (AlecHeller)
18:06:50 <ddarius> Why has this suddenly become popular?
18:06:55 <ski> you can do dialogue-I/O, at least
18:08:46 <ddarius> "A time series is a sequence of observations that are orderly in time (or space)"
18:09:11 <ski> (hm, though i suppose to make sure outputs aren't backtracked one'd need at least a determinism system -- and possibly uniqueness anyway)
18:12:27 <Enigmagic> Ralith: it looks like multirec and syntatic both have encoding mechanisms for mutually recursive types. i haven't used either though, not sure how hard it would be to replicate that functionality.
18:13:25 <ski> Philippa : yeah -- i have some ideas i think would be nice as pieces in a logic programming language. but i'm not yet sure what the missing pieces are (but i know there's holes in my understanding)
18:14:01 <hpaste> ps pasted “stack overflow” at http://hpaste.org/74777
18:14:22 <ParahSailin_> anyone care to look at that on on hpaste?
18:14:23 <YayMe> I'm trying to write an actor model system in Ela (haskell clone on CLR) just as a fun practice and learning exercise. Struggling pretty hard to understand how one would do Actor model without global state
18:15:07 <ParahSailin_> it compiles, but it's too lazy at evaluating thunks and dies from stack overflow
18:15:29 <ParahSailin_> (it functions correctly on small input files)
18:17:04 <YayMe> Is it particularly hard to add an accumulator?
18:17:15 <Ralith> Enigmagic: well, thanks for digging around.
18:17:18 <aluink> has anyone here worked with zoom-cache? i'm having some typing issues with Iteratee/Enumerator
18:17:19 <YayMe> What part is stack overflowing?
18:18:17 <hpaste> aluink pasted “zoom-cache” at http://hpaste.org/74778
18:18:27 <ParahSailin_> "Stack space overflow: current size 8388608 bytes. Use `+RTS -Ksize -RTS' to increase it."
18:18:39 <ParahSailin_> simply gives that runtime error
18:19:22 <avpx> http://book.realworldhaskell.org/read/profiling-and-optimization.html
18:20:23 <avpx> ParahSailin_: You should try to collect some data on the program and nail down where this is happening
18:20:53 <Jafet> Use foldl'.
18:21:05 <Nereid> well let's look
18:21:13 <Nereid> it's probably that foldr there
18:21:15 <avpx> Ah yeah
18:21:22 <Nereid> and foldr is lazy etc.
18:21:52 <adnauseam> is there a version of rem that works with floats ?
18:21:55 <adnauseam> :t rem
18:21:56 <lambdabot> forall a. (Integral a) => a -> a -> a
18:22:40 <Jafet> No, there is no fmod.
18:23:06 <Nereid> you could write one without much trouble though.
18:23:19 <Nereid> using those RealFrac methods.
18:23:32 <rwbarton> mod'
18:23:47 <rwbarton> @hoogle rem'
18:23:47 <lambdabot> No results found
18:23:50 <rwbarton> @hoogle mod'
18:23:50 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
18:23:50 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
18:24:19 <adnauseam> mhm, i'll check out mod' and if need be also see if i should just implement rem' too
18:24:33 <avpx> Hmm, I didn't know about the "Real" typeclass. But now I see that it is poorly named
18:24:37 <ddarius> There's not much of a compelling reason to have a rem' versus a mod'.
18:25:23 <adnauseam> mm, you're actually right ddarius
18:27:26 <Nereid> is there a reasonable way to get some type of "integers mod n" in haskell?
18:27:41 <Jafet> foreign import ccall "math.h fmod" fmod :: CDouble -> CDouble -> CDouble
18:27:57 <geekosaur> sadly, that's pretty much it...
18:28:21 <ddarius> "if the kurtosis is maximized and the energy remains the same, then the equalized signal will be a scaled and rotated version of the transmitted signal"
18:28:49 <ddarius> Nereid: Just newtype wrap Integer.
18:29:03 <rwbarton> you can use reflection for a variable modulus
18:29:04 <ddarius> Optionally, use Data.Reify (?)
18:29:04 <Nereid> ddarius: I'd have to do that for each n
18:29:09 <Nereid> or
18:29:13 <rwbarton> it works really well
18:29:22 <Jafet> oleg has something
18:29:23 <Nereid> rwbarton: what do you mean?
18:29:30 <rwbarton> @hackage reflection
18:29:30 <lambdabot> http://hackage.haskell.org/package/reflection
18:29:45 <ddarius> Jafet: That's what reflection implements.
18:29:50 <Jafet> Sure
18:30:02 <rwbarton> I think there is still no pre-packaged modular arithmetic
18:31:33 <rwbarton> but it would look like newtype Modulo n a = Modulo a; {- or just set a = Int/Integer -} instance Reifies n a => Modulo n a where Modulo x + Modulo y = Modulo ((x + y) `mod` (reflect :: Proxy n)); ...
18:31:51 <rwbarton> er, reflect (Proxy n)
18:31:55 <rwbarton> er...
18:31:58 <Nereid> heh, this paper even uses modular arithmetic as a motivating example.
18:32:02 <rwbarton> reflect (Proxy :: Proxy n)
18:32:04 <rwbarton> let's go with that
18:32:05 <Nereid> ok let's have a look.
18:34:28 <ddarius> edwardk improves on the implementation in that paper significantly, albeit quite evilly in the latest incarnation.  Earlier incarnations were much less evil but still a big improvement and extremely clever.
18:36:30 * hackagebot hedis-tags 0.2.2 - Tags for hedis  http://hackage.haskell.org/package/hedis-tags-0.2.2 (AlexanderDorofeev)
18:41:30 * hackagebot hedis-pile 0.6.2 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.6.2 (AlexanderDorofeev)
18:42:56 <Nereid> how does edwardk do everything
18:43:30 <Jafet> The k stands for bourbaKi
18:46:30 * hackagebot wai-middleware-cache-redis 0.4.2 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.4.2 (AlexanderDorofeev)
18:51:17 * cmccann wonders what he's even going to do with this toy implementation of linear logic anyway. :T
18:54:17 <YayMe> Let's say I had 6 threads, all just, hanging out. Doing stuff, calculating, you know, wondering about numbers. Now they all have a facility for sending messages to any one of eachother by thread ID. Now a 7th one joins in the fun and the facility used by the other 6 to send messages should now allow messages sent to the 7th one. Would it be even remotely possible for this to happen without using shared state for the message routing mech
18:55:06 <YayMe> the threads don't have to be responsive to the messages, they just need be able to check for them.
18:55:11 <Jafet> Message routing mecha, sounds very Patlabor
18:55:21 <YayMe> Patlabor?
18:55:50 <Jafet> You can make a distributed routing protocol, if you really have nothing else to do.
18:56:31 <YayMe> That's what I'm trying to do, but I'm trying to do it without using shared state
18:56:49 <YayMe> and I have plenty else to do, but this seems like a fun practicey learny thing to try at
19:00:05 <Jafet> If you make one that works really well, you can probably ask for a phd from somewhere
19:00:09 <Jafet> Anyway
19:00:41 <ddarius> YayMe: The easy solution is just to make a "well-known" registry actor which knows about everyone.
19:00:46 <YayMe> Jafet: Hah. Only things I've made that worked really well are in the anals of corporate C# enterpriseyness
19:01:20 <YayMe> ddarius: Yeah, I just thought about that.. Also I could have them all born with knowledge of every known actor, and it goes to the well-known registry if the address isn't known..
19:02:01 <ddarius> If you do that, but only allow them to be born with knowledge of "neighboring" actors, you can start to implement IP routing protocols.
19:02:09 <ski> cmccann : combine it with staged programming
19:02:34 <cmccann> ski, that sounds like a lot of work
19:02:50 <YayMe> Jafet: I have no expectation to do anything like this "really well" moreover you need an undegrad degree to go for a phd anyway
19:05:35 <YayMe> What would be a type of problem to solve using the actor model anyway when in a pure environment where clean parallelization is always available?
19:06:07 <shachaf> The actor model isn't about parallelization.
19:06:43 <YayMe> I know
19:08:07 <YayMe> What kind of problem would someone solve with it I guess? I mean I've written SOA systems, but never had need for growable numbers of "actors" except for parallelization of the ones already there
19:08:46 <ddarius> YayMe: See Erlang.
19:08:57 <YayMe> ddarius: Thanks, I know that. That's a language, not a problem
19:09:09 <YayMe> I'm curious what kind of problem the actor model is meant to solve
19:09:21 <ddarius> It's a language that was explicitly designed to solve a problem.
19:09:21 <cmccann> what kind of problems is erlang meant to solve?
19:09:33 <ddarius> The actor model wasn't created to solve a problem.
19:09:51 <YayMe> What was it created for I guess?
19:10:00 <parcs`> :t undefined ?x (const ()) Just
19:10:01 <lambdabot> forall t t1. (?x::t) => t1
19:10:11 <ddarius> To model computation.
19:19:49 <Taslem> Does anyone have any (good) experiences with a particular graphics library in Haskell?
19:20:03 <latro`a> for basics, gloss is apparently excellent
19:24:33 <pharaun> how basics is basics?
19:24:43 <pharaun> regarding gloss, i've seen some samples it looks nice
19:24:54 <latro`a> basically, if you think what you're doing is pretty simple, try gloss, if it isn't rich enough, try other stuff
19:25:00 <rwbarton> how does -fllvm work with the binary download ghc 7.4.2, is llvm statically linked into the ghc executable?
19:25:19 <pharaun> latro`a: k fair enough, thanks
19:25:27 <geekosaur> I believe it requires an external llvm installation
19:25:49 <rwbarton> hmm
19:26:00 <geekosaur> at least, it fails with OS X unless you install full LLVM from macports or homebrew; Apple's (xcode 4.x) is incomplete and you get errors about missing opt etc
19:26:27 <rwbarton> do you know what I can ldd to find out where it is picking up llvm libraries?
19:26:42 <geekosaur> no :(
19:26:42 <rwbarton> it appears to be finding some old version I have installed
19:26:53 <shachaf> rwbarton: GHC doesn't use llvm libraries, does it?
19:27:03 <rwbarton> oh binaries?
19:27:05 <shachaf> It just generates LLVM code, just like it does for x86 and C backends.
19:27:32 <rwbarton> okay, this may be easier to track down
19:29:01 <ddarius> shachaf: GHC still called gcc when it produced C.
19:29:12 <geekosaur> that does make sense to me; "opt" that I mentioned earlier is a program in the llvm toolchain.  afaik it just generates the llvm code and invokes the llvm toolchain to do the rest...
19:29:25 <shachaf> ddarius: Right.
19:29:29 <geekosaur> any llvm libraries would be provided by the toolchain
19:31:44 <rwbarton> ugh, now I have a dumber question, squeeze's llvm-2.7 package provides /usr/bin/opt-2.7 not /usr/bin/opt
19:32:03 <rwbarton> is there a better solution than a lot of ln -s
19:32:31 <rwbarton> the Internet indicates that I need llvm-2.7 for ghc
19:32:51 <rwbarton> I feel like I've solved this problem before
19:32:56 <shachaf> rwbarton: Hah, I looked it up and found http://tunes.org/~nef//logs/haskell/12.01.24
19:33:15 <rwbarton> is this me asking the same question
19:33:19 <shachaf> Yes.
19:33:27 <rwbarton> thanks, past me
19:33:35 <shachaf> Maybe #debian would know.
19:33:42 <shachaf> The ways of the Debian are a bit mysterious.
19:33:46 <rwbarton> well I'll just try to figure out how I solved it on my other system
19:33:56 <shachaf> Though Wheezy is a good deal more mysterious.
19:37:09 <rwbarton> rwbarton@adjunction:~$ ls -l ~/bin/opt
19:37:09 <rwbarton> lrwxrwxrwx 1 rwbarton rwbarton 16 Jan 24  2012 /home/rwbarton/bin/opt -> /usr/bin/opt-2.7
19:37:34 <shachaf> rwbarton: Future rwbarton will thank you for writing the answer in the logs.
19:37:58 <parcs`> rwbarton: does llvm 2.6 not work?
19:38:20 <rwbarton> parcs`: something I came across online suggested 2.7 was the minimum version that would work
19:39:02 <parcs`> ah well the llvm package provides the generic symlinks, and on squeeze that's version 2.6
19:40:37 <Enigmagic> 2.7 is required
19:40:53 <Enigmagic> it has patches specifically for ghc in it
20:05:01 <ddarius> > 1024 ^ 3
20:05:01 <lambdabot>   1073741824
20:06:26 <staticshock> how can i improve on this?
20:06:27 <staticshock> takeWhile (\a -> length a == 5) [take 5 (drop y "some string") | y <- [0..]]
20:06:57 <thirsteh> takeWhile ((5==) . length)
20:07:30 <thirsteh> I don't know if that's actually an improvement, or just "pointless style"
20:07:30 <staticshock> what about the comprehension?
20:07:33 <shachaf> Ew.
20:07:38 <shachaf> Don't use ((==5).length)
20:07:49 <shachaf> ...Unless length is genericLength, and 5 is :: Nat.
20:08:38 <rwbarton> @where sneaky
20:08:39 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
20:08:47 <shachaf> staticshock: You should probably use tails or something.
20:08:51 <shachaf> > tails "some string"
20:08:52 <lambdabot>   ["some string","ome string","me string","e string"," string","string","trin...
20:09:07 <staticshock> hm, ok, checking it out
20:09:27 <rwbarton> > let dropFromEnd n xs = zipWith const xs (drop n xs) in dropFromEnd 5 $ map (take 5) (tails "some string")
20:09:28 <shachaf> Any time you're dealing with lengths or indices more than once, you know you're doing something wrong.
20:09:28 <lambdabot>   ["some ","ome s","me st","e str"," stri","strin","tring"]
20:09:50 <shachaf> rwbarton: That's sneaky.
20:09:53 <shachaf> Did you put that there?
20:09:59 <rwbarton> no, you did :P
20:10:05 <shachaf> Wait, did I?
20:10:15 <shachaf> Hmm, so I did.
20:10:19 <thirsteh> hah
20:10:26 <cmccann> so sneaky you didn't even notice doing it.
20:10:41 <shachaf> 13:52:14 <rwbarton> k0ral: better to use the sneaky trick  dropFromEnd n xs = zipWith const xs (drop n xs)
20:10:47 <shachaf> You named it, at least.
20:10:58 * shachaf is surprised you remember that.
20:10:59 <parcs`> why call it 'sneaky' though
20:11:16 <shachaf> parcs`: Didn't you read? It's the sneaky trick.
20:11:20 <staticshock> what makes that better than my approach? it's certainly longer
20:11:23 <rwbarton> I don't know, but it was memorable!
20:11:38 <rwbarton> staticshock, it's maximally lazy
20:11:50 <rwbarton> though maybe yours is too
20:11:51 <staticshock> ah, okay
20:12:07 <Jafet> > zipWith const <*> drop 10 $ [0..]
20:12:08 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:12:33 <cmccann> dropping items from the end of an infinite list, eh?
20:12:50 <rwbarton> it doesn't have to check each "take 5" list for whether it really has 5 elements, it just knows when it is at the end
20:12:58 <Jafet> > length $ zipWith const <*> drop 10 $ [0::Word8..]
20:12:59 <lambdabot>   <no location info>: parse error on input `Word8..'
20:13:01 <rwbarton> so it's just a constant factor faster I guess, probably about 2
20:13:02 <Jafet> > length $ zipWith const <*> drop 10 $ [0::Word8 ..]
20:13:03 <lambdabot>   246
20:13:16 <rwbarton> maybe not worth the sneakiness
20:13:46 <staticshock> okay, i was looking for something like that, but i have a hard time understanding the actual approach
20:13:52 <Jafet> Checking each tail is very inefficient.
20:13:56 <parcs`> @where+ sneaky2 lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
20:13:56 <lambdabot> I will remember.
20:14:04 <rwbarton> not any more inefficient than generating every tail
20:14:07 <rwbarton> which you are doing anyways
20:14:10 <shachaf> parcs`: Hah, I remember that discussion.
20:14:29 <staticshock> const just takes 2 args and discards the second?
20:14:40 <thirsteh> shachaf: the reason you advised against length == 5 was just that it's done repeatedly, right? Or did I miss something about "genericLength and Nat"?
20:14:41 <rwbarton> you can look at it that way, yes
20:14:42 <rwbarton> @type const
20:14:43 <lambdabot> forall a b. a -> b -> a
20:15:10 <Jafet> rwbarton: inefficient n xs@(_:_) | xs `shorterthan` n = [] | otherwise = xs : inefficient n (tail xs)
20:15:20 <Jafet> > length [0..] == 5
20:15:24 <lambdabot>   mueval-core: Time limit exceeded
20:15:25 <shachaf> thirsteh: length (replicate 100000 'a') == 5
20:15:50 <thirsteh> shachaf: okay, I understand. It'll evaluate the whole list
20:16:01 <thirsteh> I thought it might be something else
20:16:07 <rwbarton> Jafet: but you are traversing a list you just constructed from scratch anyways
20:16:28 <Jafet> That evaluates shorterthan for every tail
20:16:45 <shachaf> thirsteh: Even genericLength+Nat has a disadvantage, though, compared to rwbarton's approach.
20:17:42 <rwbarton> I guess if you are only taking head of head of the result then yes, the sneaky trick is better
20:18:13 <rwbarton> if you are evaluating the entirety of each element of the result, they don't differ asymptotically
20:18:17 <ddarius> A suitably lazy Nat would be isomorphic to HeadStrictList ()
20:18:29 <ddarius> At which point, you basically have rwbarton's code.
20:18:53 <Jafet> What code are we comparing to sneaky?
20:18:55 <rwbarton> right
20:19:43 <rwbarton> I was comparing 'takeWhile (\a -> length a == 5) $ map (take 5) (tails "some string")' to 'dropFromEnd 5 $ map (take 5) (tails "some string")'
20:19:48 <thirsteh> shachaf: Makes sense. I wasn't considering the length (take 5) == 5, just the rewrite of the predicate pointfree, and was wondering if anything made the rewrite worse. I see why the whole thing is inefficient
20:19:59 <Jafet> genericSneaky n xs = genericTake (genericLength xs - fromInteger n :: Nat) xs
20:20:15 <shachaf> thirsteh: Rewriting it point-free makes it less readable, I think.
20:20:20 <shachaf> Maybe not.
20:20:25 <rwbarton> [drop y "some string" | y <- [0..]] is definitely bad
20:20:32 <ddarius> genericTake better known as zipWith const
20:20:35 <thirsteh> shachaf: in this case, I think so too. That's why I added it might be "pointless style" :)
20:21:08 <staticshock> rwbarton: you mean bad because it's inefficient?
20:21:14 <rwbarton> yeah
20:21:28 <rwbarton> for each new value of y, it will have to traverse from the start of "some string" again
20:21:35 <shachaf> Inelegance and inefficience tend to go together.
20:21:37 <rwbarton> so it takes O(n^2) time
20:22:01 <parcs`> iterate (drop n) would be better
20:22:03 <staticshock> ah, i got you
20:22:11 <parcs`> er, drop 1
20:22:28 <staticshock> yes, i was worried about the comprehension
20:22:36 <Ralith> where do bindings of C specify the library to link to?
20:22:39 <rwbarton> right, or tails which is close enough here
20:22:50 <shachaf> @src tails
20:22:51 <lambdabot> tails []         = [[]]
20:22:51 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
20:23:31 * ddarius <3 tails.
20:23:53 <aristid> > tails "ddarius"
20:23:54 <lambdabot>   ["ddarius","darius","arius","rius","ius","us","s",""]
20:24:04 <parcs`> Ralith: when invoking ghc
20:24:11 <thirsteh> there are some really nice tail inhere
20:24:16 <thirsteh> there's*
20:24:18 <Ralith> parcs`: so, in the cabal file?
20:24:22 <Ralith> or what?
20:24:57 <parcs`> yeah, via cabal it's the extra-libraries field
20:25:06 <shachaf> @ty let iter z f Nothing = [z]; iter z f (Just x) = x : iter z f (f x) in iter
20:25:08 <lambdabot> forall t. t -> (t -> Maybe t) -> Maybe t -> [t]
20:25:13 <staticshock> what is this syntax? xxs@(_:xs)
20:25:16 <Jafet> Haskell, helping you find tail.
20:25:43 <rwbarton> http://www.haskell.org/hoogle/?hoogle=%40
20:25:54 <ddarius> Not tail, tails.
20:26:09 <LordBrain> staticshock, the xxs is the name of the whole pattern, the head is uninteresting and so not named, and the tail is given the name xs
20:26:32 <staticshock> thanks
20:26:33 <Ralith> parcs`: the llvm-base doesn't have an extra-libraries field :/
20:26:55 <Ralith> oh
20:26:57 <Ralith> .buildinfo
20:27:34 <shachaf> Hmm, iter isn't the function I want.
20:28:16 <Ralith> ...which forwards it to autoconf
20:28:22 <Ralith> ...which sets it to the empty string
20:28:29 <Ralith> dammit bos why did you make this so complicated
20:28:54 <shachaf> @ty let iter f v = go (Just v) where { go Nothing = []; go (Just x) = x : go (f x) } in iter
20:28:54 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
20:29:05 <shachaf> Does that function exist?
20:29:05 <Nereid> hmm
20:29:07 <shachaf> @hoogle (a -> Maybe a) -> a -> [a]
20:29:07 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
20:29:08 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:29:08 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:29:09 <aristid> :t unfoldr
20:29:10 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:29:15 <shachaf> Well, yes, there's unfoldr.
20:29:17 <parcs`> there's also the pkgconfig-depends field for libraries that pkg-config knows about
20:29:20 <shachaf> But this is simpler.
20:29:27 <Nereid> are there any recommendations on having multiple ghc versions installed?
20:29:41 <geekosaur> staticshock, pattern match a list, discarding the head and binding the tail as xs, and also binding the entire list as xxs
20:29:48 <Ralith> oh hey ./configure --with-llvm-prefix
20:29:49 <Ralith> that works!
20:29:59 <Ralith> almost.
20:31:39 <ddarius> :t unfoldr (fmap (join (&&&)))
20:31:40 <lambdabot>     Couldn't match expected type `(c, c)'
20:31:40 <lambdabot>            against inferred type `Maybe (a, c)'
20:31:40 <lambdabot>     In the first argument of `unfoldr', namely `(fmap (join (&&&)))'
20:32:02 <ddarius> :t unfoldr (Just . join (&&&))
20:32:03 <lambdabot>     No instance for (Arrow (,))
20:32:03 <lambdabot>       arising from a use of `&&&' at <interactive>:1:21-25
20:32:03 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
20:32:19 <aristid> :t \f x -> catMaybes . takeWhile isJust $ iterate (fmap f) (Just x)
20:32:20 <lambdabot> forall a. (a -> a) -> a -> [a]
20:32:25 <aristid> shachaf: :P
20:32:44 <ddarius> unfoldr (Just . (id &&& id))
20:32:46 <ddarius> :t unfoldr (Just . (id &&& id))
20:32:47 <Nereid> I guess it's going to be a while before I can use 7.6 for everything.
20:32:47 <lambdabot> forall b. b -> [b]
20:32:52 * ddarius stops making noise.
20:33:14 * parcs` hides his vuvuzela
20:34:03 <shachaf> aristid: What's that function?
20:34:13 <ddarius> :t \f -> unfoldr (fmap (id &&& id) . f) -- almost
20:34:14 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
20:34:18 <aristid> shachaf: i haven't tried it. it has the right type though no?
20:34:22 <shachaf> aristid: Where do Nothings come from?
20:34:38 <aristid> shachaf: ok true :D
20:34:47 <Jafet> :t unfoldr . (fmap (join (,)) .)
20:34:48 <lambdabot> forall b. (b -> Maybe b) -> b -> [b]
20:34:49 <shachaf> @ty \f x -> catMaybes . takeWhile isJust $ iterate (>>= f) (Just x)
20:34:50 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
20:35:01 <Jafet> id &&& id = join (,)
20:35:21 * ddarius wants the unit of the adjunction defining products to be more handy.
20:35:32 <aristid> :t \f x -> catMaybes . takeWhile isJust $ iterate (>>= f) (Just x)
20:35:33 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
20:35:44 <ddarius> @let dup = join (,)
20:35:46 <lambdabot>  Defined.
20:36:00 <aristid> shachaf: damn you for coming up with the same solution while i'm in the ghci window (because i don't want to pollute the channel too much)
20:36:09 <ddarius> :t unfoldr . (fmap dup .)
20:36:10 <lambdabot> forall b. (b -> Maybe b) -> b -> [b]
20:36:29 <ddarius> aristid: The solution is hideous.
20:36:41 <aristid> :t unfoldr . ((.)(.) dup)
20:36:42 <lambdabot>     Couldn't match expected type `a1 -> (a, Maybe a1)'
20:36:42 <lambdabot>            against inferred type `(a2, a2)'
20:36:42 <lambdabot>     Probable cause: `dup' is applied to too many arguments
20:36:57 <aristid> :t unfoldr . ((.)((.) dup))
20:36:58 <lambdabot> forall b. (b -> Maybe b) -> b -> [b]
20:37:15 <Jafet> We're going dotty.
20:37:24 <shachaf> @ty fmap unfoldr (fmap fmap fmap dup)
20:37:26 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
20:37:44 <aristid> shachaf: obviously the best solution
20:37:45 <shachaf> @ty fmap fmap fmap unfoldr (fmap fmap fmap) dup
20:37:49 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
20:37:59 <aristid> uh.
20:38:27 <ddarius> There's no problem that can't be solved with another layer of fmap.
20:38:53 <shachaf> @ty fmap fmap (fmap fmap fmap fmap (fmap fmap) fmap) unfoldr fmap fmap fmap dup
20:38:53 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
20:39:18 <dolio> @type maybe [] repeat
20:39:19 <lambdabot> forall a. Maybe a -> [a]
20:41:01 <dolio> @type flip $ maybe [] repeat
20:41:02 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
20:41:02 <lambdabot>     In the first argument of `maybe', namely `[]'
20:41:02 <lambdabot>     In the second argument of `($)', namely `maybe [] repeat'
20:41:06 <ddarius> :t unfoldr .: fmap dup
20:41:07 <lambdabot>     Couldn't match expected type `b -> Maybe (a, b)'
20:41:07 <lambdabot>            against inferred type `(a1, a1)'
20:41:07 <lambdabot>     In the first argument of `fmap', namely `dup'
20:41:17 <dolio> @type (maybe [] repeat .)
20:41:18 <lambdabot> forall a (f :: * -> *). (Functor f) => f (Maybe a) -> f [a]
20:41:56 <ddarius> :t flip (maybe [] repeat .)
20:41:57 <lambdabot> forall a a1. a1 -> (a1 -> Maybe a) -> [a]
20:42:18 <aristid> oO
20:42:19 <dolio> > (length "unfoldr.((.)(.)dup)", length "(maybe[]repeat.)")
20:42:20 <lambdabot>   (19,16)
20:42:41 <aristid> dolio: i don't think (maybe[]repeat.) does the same thing
20:43:02 <shachaf> No, it's a different function.
20:43:14 <ddarius> dolio has done so much Agda that he just assumes types uniquely identify functions.
20:43:29 <ddarius> "If it type checks, it's correct"
20:43:55 <aristid> ddarius: well, testing functions is boring anyways
20:44:04 <dolio> ddarius: No, that was the disease of that guy speaking earlier. I just wasn't thinking clearly.
20:44:50 <aristid> dolio: i felt you were just using it as a building block for something... uh... loopy
20:45:09 <ddarius> Maybe -> ZipList
20:45:36 <ddarius> @src Alternative
20:45:36 <lambdabot> class Applicative f => Alternative f where
20:45:36 <lambdabot>     empty :: f a
20:45:36 <lambdabot>     (<|>) :: f a -> f a -> f a
20:45:40 <ddarius> :t maybe empty pure
20:45:41 <lambdabot>     Ambiguous occurrence `empty'
20:45:41 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
20:45:41 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
20:45:48 <ddarius> :t maybe Control.Applicative.empty pure
20:45:49 <lambdabot> forall (f :: * -> *) a. (Alternative f) => Maybe a -> f a
20:46:26 <aristid> why does lambdabot import regexes? nobody ever uses that here :P
20:46:44 <ddarius> Nobody ever uses that.
20:46:59 <Jafet> I would golf with Regex, if it didn't need type signatures everywhere
20:47:13 <ddarius> Golf with Parsec instead.
20:47:38 <Jafet> :t many
20:47:39 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
20:48:05 <dolio> > (unfoldr.((.).join(,))) (Just . (1+)) 0
20:48:06 <lambdabot>   Couldn't match expected type `a1 -> (a, Data.Maybe.Maybe a1)'
20:48:06 <lambdabot>         again...
20:48:20 * ddarius makes an already written paper titled "Alternatives to Regular Expressions"
20:48:42 <Jafet> :t many1
20:48:43 <lambdabot> Not in scope: `many1'
20:49:11 * aristid does his parsing with the lens package
20:49:33 * parcs` likes how many and some are mutually recursive
20:50:14 <ddarius> @src many
20:50:15 <lambdabot> Source not found. You speak an infinite deal of nothing
20:51:13 <aristid> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Applicative.html#Alternative
20:54:21 <parcs`> what's the "alternative" definition of Applicative again?
20:54:34 <aristid> parcs`: ?
20:54:38 <parcs`> pure :: a -> f a and product :: f a -> f b -> f (a,b) ?
20:55:03 <dolio> unit :: f ()
20:55:44 <parcs`> oh, okay
20:55:53 <shachaf> liftA0 :: a -> f a and liftA2 :: (a -> b -> c) -> f a -> f b -> f c
20:56:27 <ddarius> LaxMonoidalFunctor
20:57:32 <parcs`> and the alternative Alternative definition would be empty :: f a and sum :: f a -> f b -> f (Either a b) for a nice symmetry
20:58:07 <dolio> f Void, you mean?
20:58:21 <ddarius> @src Alternative
20:58:21 <lambdabot> class Applicative f => Alternative f where
20:58:21 <lambdabot>     empty :: f a
20:58:21 <lambdabot>     (<|>) :: f a -> f a -> f a
20:59:48 <parcs`> dolio: that sounds better
20:59:58 <dolio> I hadn't thought about that before.
21:00:03 * zenware slaps everyone around a bit with as speech by G.W.Bush
21:00:36 <ddarius> :t \m n -> fmap Left m <|> fmap Right n
21:00:37 <lambdabot> forall a b (f :: * -> *). (Alternative f) => f a -> f b -> f (Either a b)
21:01:00 <dolio> That means that an Alternative is a lax monoidal functor in two ways.
21:01:02 <ddarius> :t \m n -> either id id <$> m <|> n
21:01:03 <lambdabot> forall b (f :: * -> *). (Alternative f) => f (Either b b) -> f b -> f b
21:01:04 <aristid> parcs`: i suppose the actual implementation is better suited for ghc though
21:01:16 <ddarius> :t \m n -> either id id <$> (m <|> n)
21:01:17 <lambdabot> forall b (f :: * -> *). (Alternative f) => f (Either b b) -> f (Either b b) -> f b
21:01:33 * hackagebot pqc 0.7 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.7 (KidoTakahiro)
21:01:37 * ddarius is being stupid.
21:01:52 <ddarius> @let aplus m n = fmap Left m <|> fmap Right n
21:01:53 <lambdabot>  Defined.
21:02:05 <ddarius> :t \m n -> either id id . aplus m n
21:02:06 <lambdabot> forall b (f :: * -> *). (Alternative f) => f b -> f b -> f b
21:02:11 <rwbarton> @type aplus
21:02:12 <lambdabot> forall (f :: * -> *) a b. (Alternative f) => f a -> f b -> f (Either a b)
21:02:27 <rwbarton> oh you did that earlier
21:03:18 <ddarius> dolio: Can we do some Eckmann-Hilton type shit up in here?
21:03:42 <rwbarton> so what, it is lax monoidal from (Hask, +) to (Hask, x) and also from (Hask, x) to (Hask, x)?
21:03:46 <dolio> Not sure.
21:04:10 <dolio> rwbarton: (Hask, x) to (Hask, x) and (Hask, x) to (Hask, +).
21:04:10 <rwbarton> what an odd description
21:04:25 <dolio> Or, wait.
21:04:28 <dolio> You got it right.
21:04:31 <rwbarton> that's what I thought first, too
21:04:42 <rwbarton> hmm
21:05:40 <rwbarton> is there some issue with compatibility of <|> and <*>?
21:05:46 <rwbarton> where it's unclear what the laws should be?
21:05:54 <dolio> Well, they are expected to interact in a certain way.
21:06:59 <rwbarton> my first reaction is always "monoid-valued lax monoidal functor" but the pairing (,) <$> x <*> y isn't usually a monoid homomorphism
21:07:03 <rwbarton> and then I get confused
21:07:12 <dolio> ddarius: What would abide be?
21:08:28 <johnw> what am I doing here: (a^.b) .~ c $ d
21:08:41 <johnw> i want to modify the a^.b lens
21:08:44 <johnw> should it be a.b?
21:08:50 <shachaf> johnw: a^.b isn't a lens.
21:08:50 <rwbarton> for example the cartesian product of two lists [a] -> [b] -> [(a, b)] certainly does not commute with products in each variable simultaneously
21:09:00 <shachaf> a.b is a lens if a and b are appropriate lenses.
21:09:08 <johnw> a.b type checks, but is that the right order?
21:09:25 <shachaf> How should I know which order you want?
21:09:33 <shachaf> johnw: You should read the documentation.
21:09:38 <johnw> a is the outer, b is the innr
21:09:44 <johnw> which docs do you recommend?
21:09:50 <shachaf> @google ekmett lens
21:09:51 <lambdabot> https://github.com/ekmett/lens
21:09:53 <johnw> the haddock docs have proved... difficult
21:09:55 <johnw> ok
21:10:13 <aristid> johnw: the Wiki specifically
21:10:13 <johnw> ah, I see
21:10:17 <johnw> thanks
21:10:44 <hpaste> pharaun pasted “conduit performance difference” at http://hpaste.org/74779
21:11:05 <pharaun> is this kind of performance difference normal for using conduit?
21:11:33 * hackagebot VKHS 0.1.3 - Provides access to Vkontakte social network, popular in Russia  http://hackage.haskell.org/package/VKHS-0.1.3 (SergeyMironov)
21:12:00 <dolio> rwbarton: (a <|> b) <*> c = (a <*> c) <|> (b <*> c) is a typical expectation, I believe.
21:12:27 <pharaun> I am wondering if there is any way i can speed up the conduit approach, it seems like a nicer/cleaner approach
21:12:42 <dolio> Probably also a <*> (b <|> c) = (a <*> b) <|> (a <*> c).
21:12:55 <rwbarton> [] only obeys the first, though
21:13:13 <rwbarton> so the situation is like MonadPlus
21:13:15 <dolio> And zero <*> a = zero. Maybe a <*> zero = zero.
21:13:26 <avpx> What structure is this? Looks like a ring?
21:14:12 <rwbarton> that's sort of the question
21:14:18 <ddarius> pharaun: Is each implementation using a comparable buffer size?
21:14:21 <rwbarton> what laws should Applicative satisfy
21:14:23 <rwbarton> *Alternative
21:14:44 <dolio> rwbarton: The problem is, there are probably instances that satisfy any and all of these various properties.
21:14:46 <dolio> And others.
21:14:53 <ddarius> You are going to have all the same MonadOrElse v. MonadPlus issues.
21:15:54 <avpx> MonadPlus isn't always a monoid, correct?
21:15:57 <dolio> (a <|> b) <*> c = (a <*> c) <|> (b <*> c) won't work for Maybe.
21:16:42 <pharaun> ddarius: looking at the sinkHash in crypto-conduit it does a getBlock of "any multiples" of the md4 hash block size which looks like (64*8) bits
21:16:46 <rwbarton> right
21:17:19 <shachaf> MonadOrElse: Type class or threat?
21:17:36 <ddarius> Threat of a type class.
21:17:49 <pharaun> does not seem like there's a way to increase the size of the block size in sinkHash without altering the source :\
21:17:52 <shachaf> Multithreated class.
21:18:32 <dolio> What did people decide MonadPlus was? Right-semi-near-ring-like?
21:19:01 <dolio> Except not always.
21:19:05 <rwbarton> with the (x `mplus` y) >>= k = x >>= k `mplus` y >>= k law?
21:19:19 <rwbarton> and the mzero >>= k = mzero law
21:19:39 <ddarius> I'm pretty sure left zero is uncontroversial.
21:19:56 <dolio> Yeah.
21:20:03 <dolio> I think that's the only one.
21:20:19 <rwbarton> at one point I 80% convinced myself those laws are equivalent to having choose :: [a] -> m a so that x `mplus` y = join $ choose [x, y]
21:21:39 <rwbarton> and also equivalent to having msum . map join = join . msum
21:22:45 * ddarius tries to finish reading this probably extremely relevant to him paper.
21:24:10 <dolio> People write papers on SharePoint?
21:25:34 <ddarius> dolio: Probably, but SharePoint isn't all that relevant to me.
21:25:45 <dolio> Heh.
21:43:12 <johnw> what is the Filesystem.Path way of testing if a pathname is a directory?
21:43:28 <johnw> i'm looking to avoid using toText every time I want to call doesDirectoryExist
21:45:21 <johnw> ah, system-fileio
21:46:35 <pharaun> ddarius: it ended up being the block size, i'm replacing/tweaking it with my own version going to be tweaking it, thanks for pointing that one out
21:47:13 <shachaf> doesDirectoryExist?
21:47:31 <johnw> @hoogle doesDirectoryExist
21:47:32 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
22:08:26 <pordan30> are there canonical laws that instances of foldable and traversable should satisfy? either the documentation is rather sparse, I haven't found the correct documentation, or there aren't agreed upon laws.
22:10:25 <ddarius> All of Foldable's laws would be of the form (or derivable from) foldableMethod = foldableMethod . toList
22:12:30 <Enigmagic> i like getting overlapping instances errors for one instance.
22:14:23 <ddarius> @src Foldable
22:14:24 <lambdabot> Source not found. My pet ferret can type better than you!
22:15:45 <Jafet> @hoogle Float -> Double
22:15:45 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:15:45 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
22:15:45 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
22:16:02 <Enigmagic> :t realToFrac
22:16:03 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
22:16:07 <ddarius> The generic non-integral conversion is realToFrac.
22:16:15 <ddarius> The generic integral conversion is fromIntegral.
22:16:25 <ddarius> Those are the only numeric conversions you need to remember.
22:17:03 <Jafet> The numeric hierarchy for dummies.
22:17:35 <ddarius> Using anything other than those two functions is typically a mistake.
22:18:28 <ddarius> > fromEnum (2^100)
22:18:29 <lambdabot>   0
22:34:30 <johnw> if I have an FFI value x, how do I get a Ptr x that points to it?
22:34:39 <johnw> i.e., the Haskell version of & :)
22:35:40 <johnw> looks like it's Foreign.Marshal.Utils.with
22:35:43 <johnw> @hoogle with
22:35:43 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
22:35:43 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
22:35:43 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
22:36:44 <johnw> it seems a little inefficient for calling C functions
22:36:59 <johnw> but I guess it needs to be to support concurrency
22:37:33 <johnw> ah, newStablePtr
22:40:47 <Enigmagic> why not Foreign.Marshal.Utils.with?
22:41:05 <Enigmagic> iirc it doesn't use StablePtrs
22:43:23 <johnw> i have a C'git_oid values, it's a struct with an SHA1 in it
22:43:40 <johnw> I need to pass a pointer to it (and I know it's immutable, and won't be GC'd during the call)
22:43:59 <johnw> 'with' will allocate a memory region, memcpy the SHA1, and then pass a pointer to the copied memory region
22:44:18 <johnw> StablePtr will just create a pointer to the memory region for me
22:44:22 <Enigmagic> newStablePtr does a hashtable insert
22:44:31 <johnw> really?
22:44:40 <Enigmagic> gotta store a GC root somewhere
22:44:58 <johnw> but don't I have to call freeStablePtr to get rid of it?
22:45:05 <johnw> if so, then why the GC?
22:45:17 <Enigmagic> it's allocating memory on the managed heap
22:45:24 <Enigmagic> if you want unmanaged memory use malloc
22:45:37 <ddarius> 10**2.7
22:45:40 <ddarius> > 10**2.7
22:45:41 <lambdabot>   501.18723362727246
22:45:41 <ddarius> > 10**2.1
22:45:42 <lambdabot>   125.89254117941675
22:45:50 <Enigmagic> @hoogle malloc
22:45:50 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
22:45:51 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
22:45:51 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
22:46:31 <johnw> there's no cheap way to get the address of a value for the duration of a single IO action?
22:46:46 <johnw> I really have to allocate memory?
22:46:54 <johnw> what if this is happnening in a tight loop?
22:46:59 <Jafet> What is the address of a value?
22:47:01 <rwbarton> values don't have addresses
22:47:12 <ddarius> johnw: Allocate memory outside of the loop and operate on that.
22:47:23 <rwbarton> also with is pretty cheap I think
22:47:30 <johnw> my SHA1 value has to exist somewhere at runtime, doesn't it?
22:47:49 <Jafet> No.
22:47:59 <johnw> how not?
22:48:02 <Jafet> It could exist in multiple places.
22:48:03 <Enigmagic> johnw: iirc 'with' and 'alloca' use the stack, but you'll get a memcpy either way
22:48:03 <rwbarton> you don't know what the format is, the gc might move it
22:48:42 <ddarius> alloca is just a wrapper around malloc.
22:49:32 <Enigmagic> oh right
22:49:38 <Enigmagic> garbage collected stacks :P
22:51:35 <johnw> Jafet: but at the time of my call, one of those places will a place I could use, no?
22:51:55 <Jafet> Your calls happen instantaneously?
22:52:33 <johnw> in a single-threaded program, will other things happen while the C function is being called?
22:52:51 <johnw> looks like I have to use with
22:53:01 <johnw> while I swallow the vomit that just crept up
22:53:03 <Jafet> Why don't you use python then
22:53:12 <Enigmagic> uhm
22:53:12 <Jafet> What a dweeb
22:53:13 <rwbarton> well you could trigger a GC in the middle of marshalling the arguments
22:53:25 <johnw> grow up, Jafet
22:53:28 <rwbarton> since that is Haskell code that does that
22:53:44 <johnw> ah, hmm
22:53:50 <Enigmagic> johnw: if you're mostly using it from C use malloc, if you're mostly using it in Haskell use with
22:54:23 <johnw> hmm.. i'm only holding onto the value to pass it back to the C library I got it from
22:55:13 <johnw> so when I first get it I can malloc it and wrap it with a finalizer
22:55:39 <Enigmagic> johnw: is it originally being allocated on the C side?
22:56:26 <johnw> no, the C code is memcpy into a memory block I'm supposde to alloc
22:56:40 <johnw> oh, hmm
22:56:50 <johnw> I think I was dumb in the way I wrote the creation code
22:56:56 <johnw> the alloc was always needed
22:58:34 <johnw> is there as idiom for malloc'ing memory you want the finalizer to clean up for you?
22:59:08 <johnw> ah, mallocF
22:59:10 <johnw> mallocForeignPtr
22:59:13 <johnw> thanks guys
23:31:19 <johnw> if I have a Ptr (Ptr a), is there a way to "dereference" it?
23:31:45 <Jafet> @hoogle peek
23:31:45 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
23:31:45 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
23:31:45 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
23:31:50 <johnw> ah, of course
23:31:54 <johnw> thank you, Jafet
23:32:04 <ddarius> Why do you have a Ptr (Ptr a) ?
23:32:23 <johnw> i have a method that stores a ptr* for me in a malloc'd ptr**
23:32:35 <johnw> when it gets free, I have to call a method on the ptr* before freeing the ptr**
23:36:28 <randomclown> is there a way to prevent a string from being escaped by "show"
23:37:26 <Jafet> Place your cursor after "show". Press delete.
23:38:38 <randomclown> yeah nah that doesnt work
23:38:48 <johnw> is there a way to compose finalizers?
23:38:55 <randomclown> I'm using print
23:39:23 <Enigmagic> randomclown: use putStrLn instead
23:39:25 <Jafet> print = putStrLn . show
23:39:33 <Jafet> Delete "show".
23:39:42 <randomclown> the thing is it's printing (Show a)
23:40:19 <randomclown> and I need that "show" for other types I'm throwing in it
23:40:35 <Jafet> Then not-escaping inputs sounds like a bad idea.
23:40:54 <Jafet> > show "\ESC[1;31m"
23:40:55 <lambdabot>   "\"\\ESC[1;31m\""
23:41:15 <Jafet> Well, unless you're avoiding that.
23:42:23 <randomclown> so there is no way to print a string raw unless it's with putstrln
23:42:43 <Jafet> If you want to show things as if with Show, except for String, then you can do: {-# LANGUAGE OverlappingInstances #-} class MyShow; instance Show a => MyShow a; instance MyShow [Char].
23:42:44 <johnw> you could write it to stdout
23:43:00 <johnw> but putStr is what you want for unescaped strings
23:43:03 <Jafet> This will steal every Show instance except overriding the one for [Char].
23:43:26 <johnw> (n/m my stdout comment)
23:43:36 <Jafet> In any case, it's still a bad idea
23:44:02 <randomclown> I don't know any other language that have this weird escaping string thing
23:44:38 <randomclown> unescaped should be default
23:44:54 <Jafet> Show is not a class for converting values for printing. It is a class for producing machine-readable descriptions of values.
23:45:21 <jedai> randomclown: Of course you do, nearly every language out there either have no show facility or it does work like that
23:45:24 <Jafet> In particular, read.show = id.
23:45:42 <shachaf> Up to isomorphism.
23:45:56 <randomclown> is there a class for converting values for printing?
23:46:04 <Jafet> MyShow.
23:46:04 <johnw> Jafet: do all finalizers have to be FFI functions?
23:46:13 <randomclown> pffff
23:46:14 <ddarius> No because that would be application specific.
23:46:21 <jedai> randomclown: in a bunch of language you can only print a  string, the conversion are left to you with explicit functions or a printf-like
23:46:33 <Jafet> Indeed, and usually you don't need something that polymorphic anyway.
23:46:36 * hackagebot dates 0.2.0.0 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.2.0.0 (IlyaPortnov)
23:47:35 <Jafet> johnw: I have no idea.
23:48:06 <johnw> ok.  their type is FunPtr (Ptr a -> IO ()), so I'm thinking yes
23:48:46 <johnw> actually, don't need to solve this
23:49:00 <johnw> the Ptr Ptr I have can live in alloca
23:49:11 <ddarius> You can make Haskell functions into FunPtrs
23:49:30 <johnw> oh?  how?
23:49:42 <ddarius> @hoogle FunPtr
23:49:42 <lambdabot> Foreign.Ptr data FunPtr a
23:49:42 <lambdabot> GHC.Exts data FunPtr a
23:49:42 <lambdabot> GHC.Exts FunPtr :: Addr# -> FunPtr a
23:49:48 <ddarius> EOUTOFLINES
23:49:49 <shachaf> @google how do i make a funptr
23:49:50 <lambdabot> http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Foreign-Ptr.html
23:49:50 <lambdabot> Title: Foreign.Ptr
23:50:12 <shachaf> As described there.
23:50:13 <startling> @hoogle a -> FunPtr
23:50:14 <lambdabot> Did you mean: a -> FunPtr a
23:50:14 <lambdabot> Prelude id :: a -> a
23:50:14 <lambdabot> Data.Function id :: a -> a
23:50:14 <johnw> oh, I need a wrapper stub
23:50:17 <johnw> ok, thanks
23:50:42 <ddarius> That said, since such FunPtrs need to be freed, it's probably not the best idea to use them for this.
23:51:10 <johnw> i'll see if I can avoid the need
23:51:53 <ddarius> foreign wrapper is actually a bit insane when you think about what it needs to do to work.
23:52:35 <johnw> hmmm... do I peek at the rabbit hole and just walk by, or do I stop and have some cake?
23:52:50 <hpaste> randomclown pasted “better way to do this” at http://hpaste.org/74780
23:52:55 <shachaf> Does the program need to generate executable code at runtime?
23:53:03 <randomclown> anyways that's thde code Jafet:
23:53:13 <johnw> shachaf: no
23:53:24 <randomclown> and the result is a string sometimes
23:53:32 <shachaf> johnw: I mean when you use foreign wrapper.
23:53:53 <johnw> i'm not sure what you mean by "generate executable code at runtime"?
23:54:38 <Jafet> Well, Foreign is inherently magical.
23:55:24 <paolino> randomclown, you can switch on type with typeOf or something like that
23:56:11 <Jafet> randomclown: you can use MyShow, or use Either String b.
23:56:17 <ddarius> Jafet: Only foreign wrapper is not obvious how to implement.
23:57:08 <Jafet> Since a is treated as an error message, I recommend printing it when it is created.
23:58:00 <Jafet> ddarius: it creates a foreign entry point to a given function?
23:58:24 <Jafet> If I'm understanding correctly what it does
23:58:42 <shachaf> Ah, so foreign import wrapper maps in a new page which is both executable and writable?
23:58:49 <shachaf> strace confirms it.
23:58:54 <ddarius> Jafet: It creates a C function pointer, which is just a pointer in pretty much all relevant systems, for a Haskell function which has an environment (as well as a code pointer.)
23:59:07 <Jafet> Can't ghc make it statically?
23:59:11 <ddarius> No.
23:59:12 <Jafet> Oh, closures.
23:59:32 <Enigmagic> shachaf: yes, it uses libffi to alloc the page and copies some machine code into it
23:59:46 <Enigmagic> adjustor thunks
