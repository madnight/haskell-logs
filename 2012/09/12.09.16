00:08:57 <kallisti> Saizan: yeah, every parser monad Ive ever seen has a failure constructor.
00:11:08 <johnw> sometimes, the Applicative is just amazing
00:22:10 * hackagebot cron 0.1.1 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.1.1 (MichaelXavier)
00:27:10 * hackagebot VKHS 0.1.5 - Provides access to Vkontakte social network, popular in Russia  http://hackage.haskell.org/package/VKHS-0.1.5 (SergeyMironov)
01:03:34 <hinst> I've got Leksah 0.12.1.3. It stops redrawing user interface after I maximize its window
01:04:14 <hamishmack> which OS?
01:05:31 <hinst> Windows #7
01:21:12 <shachaf> It seems like a universal rule that join + fmap are easier to implement than (>>=).
01:21:18 <shachaf> Is there any monad where that's not the case? :-)
01:21:30 <dibblego> you mean in teaching?
01:22:11 * hackagebot gitlib 0.2.0 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.2.0 (JohnWiegley)
01:22:18 <shachaf> In this case I was doing http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
01:26:11 <Saizan> ?djinn Maybe a -> (a -> Maybe b) -> Maybe b
01:26:12 <lambdabot> f a b =
01:26:12 <lambdabot>     case a of
01:26:12 <lambdabot>     Nothing -> Nothing
01:26:12 <lambdabot>     Just c -> b c
01:27:18 <nand`> ?djinn Maybe (Maybe a) -> Maybe a
01:27:18 <lambdabot> f a =
01:27:18 <lambdabot>     case a of
01:27:18 <lambdabot>     Nothing -> Nothing
01:27:18 <lambdabot>     Just b -> b
01:27:47 <hpaste> obk pasted “Control.Lens parameterized makeClassy” at http://hpaste.org/74817
01:28:13 <obk> edwardk: I was hoping you could shed some light on this.
01:28:13 <lambdabot> obk: You have 1 new message. '/msg lambdabot @messages' to read it.
01:28:28 <edwardk> makeClassy only works for non-parameterized types
01:28:42 <edwardk> if you put an argument on it, i'm not sure how i should determine what those arguments would be
01:28:45 <obk> edwardk: I know. I did the equivalent manually to see what's what.
01:29:05 <obk> It almost worked, except for when I had more than one parameter, which seems strange.
01:29:22 <edwardk> well, you can probably get away with using fundeps, etc.
01:29:33 <edwardk> but it'll probably take type-specific knowledge to do it
01:29:42 <obk> It would?
01:30:09 <obk> I'm not certain I see why. But I tend to be overly optimistic about these things :-)
01:30:21 <edwardk> if the arg is phantom i can't put a fundep on it for instance
01:31:02 <edwardk> afk a bit
01:35:54 <hpaste> obk annotated “Control.Lens parameterized makeClassy” with “Control.Lens parameterized makeClassy (annotation)” at http://hpaste.org/74817#a74818
01:41:41 <hiptobecubic> Can anyone comment on this quickCheck test? I am trying to stop my (arbitrary :: Gen Form) from growing exponentially in complexity and causes the test functions to diverge, but when I try to limit it, it is unable to make a single arbitrary value any more. It just hangs forever. http://hpaste.org/74804
01:42:47 <hiptobecubic> I am just trying to make a predicate that limits it such that it can't make test cases too deep or too shallow
01:45:41 <hiptobecubic> The majority of test cases are just a single  Prop Int, which is expected given the frequencies i have listed there, but there are always several which are larger than that in a batch of 100, so when i try to limit it to (complexity > 1), i'd still expect it to work, just more slowly
01:45:49 <mm_freak_> shiftR's arguments are really in the wrong order
01:45:53 <mm_freak_> same for shiftL
01:46:02 <mm_freak_> i have to flip it all the time
01:46:09 <hiptobecubic> If i set it to (c > 0), which is guaranteed for all cases, then it works fine of course.
01:46:20 <nand`> I'd expect :: Bits a => Int -> a -> a; what is the actual order?
01:46:43 <hiptobecubic> a -> Int -> a
01:46:46 <nand`> yuck
01:47:08 <nand`> if anything, that should be for some operator like .<<. or .>>.
01:47:11 * hackagebot certificate 1.2.7 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.2.7 (VincentHanquez)
01:47:25 <hiptobecubic> I think it's usually used as infix
01:47:53 <hiptobecubic> 1 `shiftL` 2 == 4
01:48:23 <nand`> 1 .<<. 2  and  shiftL 2 1  both seem logical to me
01:48:44 <nand`> I'm not a huge fan of ‘wordy operators’ except in a few specific circumstances
01:49:53 <hiptobecubic> nand`, agreed.
01:50:41 <kallisti> so
01:51:11 <kallisti> I'm working on a shebang command line utility. I thought it would be a good idea to have a command in PATH that does cross-platform command invocation
01:51:24 <kallisti> can you think of any features that would be useful?
01:51:32 <kallisti> I was thinking cross-platform installation would be nice.
01:52:23 <kallisti> standalone executable installer
01:52:36 <kallisti> could make that a seperate library even.
01:53:09 <kallisti> here's an idea: do you think there would be a lot of people willing to crowdsource Haskell?
01:53:30 <kallisti> (I belatedly apologize for the use of the term "crowdsource")
01:54:22 <kallisti> by "crowdsource Haskell", I mean pay people to develop Haskell libraries, as strange as it sounds.
01:54:56 <kallisti> probably not?
01:55:13 <Heffalump> is crowdsourcing software development generally effetive?
01:55:49 <kallisti> you know, I think this is a mostly unanswered question. The only example I have is kickstarter.
01:55:59 <kallisti> and it seems to work sometimes
01:57:44 <randomclown> what type is ([_, title, contents]:_) -> ...
01:57:46 <randomclown> matching
01:58:07 <Enigmagic> [[a]] ?
01:58:13 <kallisti> yes
01:58:17 <Heffalump> kallisti: sounds like the starting point is someone with a project to propose
01:58:26 <kallisti> Heffalump: yep
01:58:43 <randomclown> so the first list is broken up into 3 elements
01:58:44 <randomclown> and matched
01:59:05 <kallisti> randomclown: yes and the fire element is ciarded
01:59:09 <kallisti> um, discarded
01:59:34 <kallisti> woah. What just happened. I should probably sleep. s/fire/first/
02:01:22 <randomclown> does [_, ...] syntax not work with lambdas?
02:01:41 <Heffalump> yes, it does
02:01:49 <kallisti> randomclown: it works anywhere that a pattern is accepted
02:01:53 <nand`> > (\[_, b, c] -> (b, c)) [1,2,3]
02:01:54 <lambdabot>   (2,3)
02:01:55 <Heffalump> but you can't provide multiple cases, so you'll always get an incomplete pattern
02:02:03 <kallisti> which includes parameter lists of functions (and lambdas) and case expressions
02:02:09 <kallisti> and do notation
02:02:10 <Heffalump> > (\[_, b, c] -> (b, c)) [1,2,3,4]
02:02:11 <lambdabot>   *Exception: <interactive>:3:1-20: Non-exhaustive patterns in lambda
02:02:31 <kallisti> well, technically, you will end up with an incomplete pattern in the majority of cases
02:02:46 <kallisti> oh, right, but specifically with list literals, yes.
02:03:04 <nand`> Heffalump: you could also use (\case [_, b, c] -> (b, c); _ -> (1, 2))
02:03:22 <dmwit> ...starting in GHC 7.6
02:03:25 <kallisti> nand`: oh, you can? nice
02:03:42 <nand`> kallisti: -XLambdaCase
02:03:49 <kallisti> thats
02:03:51 <kallisti> beautiful ;_;
02:04:04 <nand`> some people hate it :)
02:04:14 <kallisti> ah, well, I am obviously not one of those
02:04:26 <randomclown> ugh I wrote the signature wrong and ghc keep complaining about my lambdas
02:04:45 <kallisti> so I will probably upgrade my GHC
02:04:53 <kallisti> and exploit that to no end.
02:04:57 <dmwit> Eh, I think the people that hate it still love the idea and just hate the syntax.
02:04:57 <nand`> I upgraded to 7.6 a few days ago myself
02:05:01 <nand`> dmwit: yeah
02:05:08 <kallisti> yep, that is the problem
02:05:08 <nand`> but the idea isn't new, really
02:05:11 <nand`> \x -> case x of ...
02:05:13 <nand`> same thing
02:05:42 <kallisti> I know a lot of Haskell programmers that dislike case expression syntax in general
02:05:55 <kallisti> "a lot" relatively speaking
02:06:03 <nand`> that'd be new to me
02:06:17 <nand`> what do they criticize about it?
02:06:35 <kallisti> Im pretty sure it's mostly an aesthetic thing
02:06:39 <kallisti> I'm not really sure why
02:07:30 <nand`> come to think of it, I often use case expressions instead of top-level patterns when I want to avoid rewriting the name of the function, this extension helps for that
02:07:37 <nand`> foobar = \case ...
02:08:48 <kallisti> awesome
02:09:07 <kallisti> this is actually the best syntax change ever
02:09:32 <nand`> there's also -XMultiWayIf:  if | foo -> bar | bat -> baz | otherwise -> blob
02:09:35 <nand`> but I think that one's less useful
02:10:30 <kallisti> woah
02:11:15 <kallisti> yeah, not really sure I understand
02:11:24 <kallisti> I guess if you prefer guards
02:11:40 <kallisti> the fall-through behavior is nice
02:11:48 <nand`> well, it's a generalized construct for nested if/else
02:11:54 <nand`> however useful that may be
02:12:04 <nand`> most of my decision making tends to come down to pattern matching personally
02:12:26 <kallisti> yes that is the primitive for it
02:12:50 <kallisti> I've written quite a bit of imperative monad code
02:12:54 <kallisti> using conditional combinators
02:13:33 <dmwit> No new questions on [haskell]
02:13:37 <dmwit> must be time for bed.
02:42:12 * hackagebot liblastfm 0.0.3.5 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.3.5 (MatveyAksenov)
03:08:32 --- mode: wolfe.freenode.net set +o ChanServ
03:22:58 <killy9999> what is the efficient replacement of lists in Haskell?
03:23:02 <killy9999> Data.Vector ?
03:23:07 <kallisti> what operations would you like to be efficient
03:23:43 <killy9999> lookups
03:23:45 <kallisti> Data.Vector has efficient O(1) lookup.
03:23:47 <Botje> and what modifications will you be performing.
03:23:58 <killy9999> hm...
03:24:06 <kallisti> Vector requires copying the array in order to modify
03:24:07 <killy9999> good question
03:24:23 <killy9999> I want to do something like this:
03:24:33 <kallisti> however, with stream fusion it can roll together composed vector operations into one copy
03:24:38 <killy9999> I have some data structure and I want to create an index for it
03:24:57 <killy9999> and then do lookup in the index
03:25:12 <killy9999> say I have a list of products, each product with a name and price
03:25:28 <killy9999> I want to create a structure that indexes these products by price
03:25:32 <kallisti> ah so you want non-integer keys?
03:25:40 <killy9999> yes
03:25:52 <Botje> then vectors are right out :)
03:25:53 <kallisti> you might be interested in HashMap or Map
03:26:20 <killy9999> I'm worried how to construct them efficiently
03:26:29 <kallisti> it shouldn't matter.
03:26:34 <killy9999> why not?
03:26:35 <kallisti> they have O(log n) lookup
03:26:38 <kallisti> they're binary search trees
03:26:51 <killy9999> yes, I;m not worried about the lookup part...
03:27:07 <Jafet> :t M.fromList
03:27:08 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
03:27:12 <killy9999> the problem is that if theyu are constructed inneficiently there might be no point in constructing them
03:27:48 <kallisti> O(log n) insert
03:28:01 <kallisti> if you need massive mapping you may want to use a hash table
03:28:14 <killy9999> mhm
03:28:23 <killy9999> one more thing - the keys might be identical
03:28:32 <killy9999> in which case I would like an entry to store a list
03:28:42 <kallisti> you could just use lists for all cases
03:29:11 <killy9999> I think I don't undestand
03:29:28 <killy9999> you mean I could use lists as entries in Hashmap?
03:29:29 <kallisti> [] represents empty, singleton is one element, many elements are... many elements
03:29:32 <kallisti> yes
03:29:40 <killy9999> OK
03:29:57 <killy9999> I guess I'll do some more reading and come back with some smarter questions
03:30:05 <killy9999> ZOMG
03:30:08 <killy9999> fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
03:30:22 <kallisti> myLookup key map = fromMaybe [] . lookup key map
03:30:24 <kallisti> um
03:30:25 <kallisti> except
03:30:28 <kallisti> myLookup key map = fromMaybe [] $ lookup key map
03:30:31 <killy9999> why is the result in IO monad?
03:30:36 <kallisti> because it's mutable
03:30:39 <kallisti> well, hashtable is
03:30:43 <kallisti> hashmap is immutable
03:30:53 <killy9999> hm...
03:31:18 <killy9999> does mutability result in better performance?
03:31:34 <kallisti> for massive numbers of inserts, yes.
03:31:47 <killy9999> I'll have about 1M of inserts
03:33:09 <kallisti> also
03:33:10 <kallisti> http://hackage.haskell.org/packages/archive/Holumbus-Distribution/0.0.1.1/doc/html/Holumbus-Data-MultiMap.html#t%3AMultiMap
03:33:12 <killy9999> hm.. HashTable is marked as deprecated
03:33:24 <kallisti> MultiMap provides identical keys
03:36:17 <Botje> killy9999: you could bin several articles according to floor(price)
03:36:37 <Jafet> You could just use Map
03:36:45 <Jafet> Or MultiMap
03:38:35 <killy9999> Botje: that's what I'm trying to do, the question is how to do that efficiently if you have 1M articles?
03:39:01 <kallisti> > log 1000000
03:39:02 <lambdabot>   13.815510557964274
03:39:04 <killy9999> anyway, found some similar questions on StackExchange; reading the answers roight now
03:39:32 <kallisti> killy9999: O(log n) is pretty good
03:41:10 <Botje> killy9999: assuming you build this index once and use it for a long time, i don't see a problem
03:41:12 <Jafet> killy: there is an extremely high probability that your guess at what the most inefficient part of the program will be is wrong
03:41:31 <Jafet> Use Map and profile
03:42:08 <killy9999> OK
03:42:45 <Jafet> > 10 * 8 * 10^6
03:42:46 <lambdabot>   80000000
03:43:04 <ivanm> Jafet: yeah, the actual cause of a programs slow down is quite often not what you think...
03:43:15 <Jafet> (Estimated number of bytes used by a Map)
03:43:17 <ivanm> though profiling alone doesn't always help :/
03:43:38 <Jafet> Well, it helps you guess better.
03:43:50 <ivanm> yeah
03:44:04 <killy9999> one more question
03:44:28 <killy9999> if I have Constant Applicative Form (I think that's what it's called)
03:44:34 <killy9999> is it evaluated lazily?
03:44:49 <shachaf> Everything is lazy.
03:44:58 <ivanm> unless it isn't
03:44:59 <ivanm> :P
03:45:02 <shachaf> Right.
03:45:04 <paolino> even seq
03:45:13 <shachaf> > seq (seq undefined) 5
03:45:13 <lambdabot>   5
03:45:15 <shachaf> Yep. Lazy.
03:45:24 <ivanm> does that work with deepseq?
03:45:28 <kallisti> `seq (`seq` undefined 5) 5
03:45:31 <ivanm> > deepseq (deepseq undefined) 5
03:45:32 <lambdabot>   Not in scope: `deepseq'Not in scope: `deepseq'
03:45:33 <kallisti> `seq (seq undefined 5) 5
03:45:35 <ivanm> thought so
03:45:42 <ivanm> kallisti: ` doesn't do anything...
03:45:42 <Jafet> ivanm: NFData
03:45:43 <kallisti> > seq (seq undefined 5) 5 -- help
03:45:44 <lambdabot>   *Exception: Prelude.undefined
03:45:53 <ivanm> Jafet: yeah, but wasn't sure if lambdabot knew it or not
03:45:59 <shachaf> kallisti: So (seq undefined) is strict.
03:46:08 <kallisti> no
03:46:08 <Jafet> Though you can write NFData (a -> b)...
03:46:27 <kallisti> oh, er, yes.
03:46:29 <Nereid> seq (seq undefined 5) 5 evaluates (seq undefined 5) first, which evaluates to undefined
03:46:34 <ivanm> Jafet: oh, right, that
03:46:39 <Jafet> Its implementation should be interesting, to say the least
03:46:41 <Nereid> pretty simple.
03:46:44 <ivanm> but even still, I wasn't sure whether lambdabot had deepseq in scope
03:47:04 <ski> (.. actually, `seq' doesn't give guarantees about evaluation order)
03:47:18 <ivanm> ski: :o
03:47:25 <shachaf> Nereid: No, it doesn't necessarily (and often doesn't in practice).
03:47:26 <ivanm> I thought that was the whole point...
03:47:28 <shachaf> I think monochrom put it best:
03:47:30 <shachaf> @quote monochrom seq
03:47:30 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
03:47:31 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
03:47:35 <shachaf> @quote monochrom pseq
03:47:35 <lambdabot> monochrom says: seq is a suggestion. pseq is an order.
03:47:39 <ivanm> heh
03:47:49 <ski> `seq a b' evaluates both `a' and `b' (not necessarily in that order) and then returns the value of `b'
03:47:53 <Jafet> Well, it does. Instead of something not ever being evaluated, it gets evaluated eventually.
03:48:35 <ski> (or i suppose the evaluation of `a' might perhaps happen after returning the value of `b' in some cases)
03:48:57 <shachaf> As long as the semantics work out evaluation order doesn't matter.
03:49:10 <shachaf> And the semantics carefully don't specify anything about evaluation order anywhere.
03:49:12 <marcot> Hi.  I have a question about cost-centre names, as shown on .hp files produced by +RTS -hc.  They have the form A/B/C/D/E/F/G/...  Usually, it seems that it means A, called by B, called by C, etc, but that's not the case sometimes.
03:50:29 <marcot> I have a case here (called with -L200): replaceOneOf’/clean/tagsText/anyTag/dropTagClose/parseObservations/specificTagText/tagText/parseOab/dropTagText/dropTill/tag/tagOpen...
03:50:43 <marcot> tagsText calls clean which calls replaceOneOf', but anyTag does not call tagsText.
03:51:19 <marcot> parseObservations calls dropTagClose which calss anyTag, but specificTagText does not call parseObservations.
03:51:40 <marcot> Is this correct?  How should I interpret it?
03:52:34 * ski would assume laziness (or maybe tail calls)
03:53:57 <marcot> They seem to be grouped by three.
03:54:12 <paolino> ski, seq a b  evaluates b ?
03:54:27 <ski> yes
03:54:38 <marcot> ski: Are you answering my question, or is it other conversation?
03:54:55 <ski> marcot : not sure about "answering" -- more like "guessing"
03:54:55 <hiptobecubic>  :t suchThat
03:55:02 <hiptobecubic> :t suchThat
03:55:03 <lambdabot> forall a. Gen a -> (a -> Bool) -> Gen a
03:55:34 <marcot> What do you mean by tail calls?
03:55:41 <Ferdirand> > seq (seq 1 undefined) 2
03:55:42 <lambdabot>   *Exception: Prelude.undefined
03:56:04 <Ferdirand> wait no
03:56:13 <paolino> :t suchThat arbitrary
03:56:14 <lambdabot> forall a. (Arbitrary a) => (a -> Bool) -> Gen a
03:56:51 <paolino> :t arbitrary `suchThat` const
03:56:52 <lambdabot>     Couldn't match expected type `Bool' against inferred type `b -> a'
03:56:53 <lambdabot>     In the second argument of `suchThat', namely `const'
03:56:53 <lambdabot>     In the expression: arbitrary `suchThat` const
03:57:03 <paolino> :t arbitrary `suchThat` id
03:57:04 <lambdabot> Gen Bool
03:57:52 <mm_freak_> @check True
03:57:53 <lambdabot>   "OK, passed 500 tests."
03:58:55 <DrSyzygy> @check False
03:58:56 <lambdabot>   "Falsifiable, after 0 tests:\n"
03:59:12 <paolino> 0 ?
03:59:44 <ski> marcot : well, in languages with strict evaluation, if you have `foo ... = 1 + bar xs start; bar [] acc = frob acc; bar (x:xs) = bar xs (blah acc x)' then consider a case when `foo' calls `bar' : now `bar' will tail-call itself (interspersed with non-tail-calls to `blah') until it reaches the base case, when it calls `frob'
04:00:14 <Jafet> 500 tests, what
04:00:28 <statusfailed> Is there a way to trivially turn a State-monadic function into one inside the ST monad?
04:00:31 <ski> marcot : in terms of stack frames, at this point there would possibly be a stack frame for `frob', with a stack frame for `foo' before that, *without* any intervening stack frames for `bar'
04:01:00 <ski> marcot : so, on inspection on the stack, one might be misled to believe that `foo' called `frob' directly
04:01:28 <marcot> ski: Ok, but in my case no function called by anyTag calls tagsText, for example.
04:01:56 <ski> marcot : yes, so it might be laziness, then
04:02:36 <ski> marcot : `anyTag' perhaps returns a thunk that the caller of `anyTag' later passes to something that calls `tagsText'
04:02:41 <ivanm> statusfailed: depends: does "re-write your code" count as being trivial? :p
04:02:54 <statusfailed> haha
04:02:58 <ski> er, no -- the other way around
04:03:12 <statusfailed> ivanm: to be honest, i've just been reading the ST page and thinking- i'm not sure it even has a point
04:03:51 <ski> marcot : something perhaps creates a thunk containing a call to `tagsText', and then that thunk is passed into something calling `anyTag' (which then forces that thunk)
04:03:59 <statusfailed> my question, that is
04:04:00 <marcot> ski: Yes, that's happen, anyTag output is used as the input of tagsText in a point.
04:04:47 <marcot> ski: Well, what happens is on the other way around.  anyTag is a Monad function which does not have any parameter.
04:06:16 <ski> marcot : the point is : a call to `bar' that is syntactically inside the body of `foo' might not be called before `foo' returns -- it might instead be passed around, e.g. to `baz', which actually forces it -- so (presumably) that could then give a cost centre `.../bar/baz/...'
04:07:20 <ski> anyway, i'm just guessing here -- i don't have much experience with the profiler
04:07:23 <ski> marcot : which monad ?
04:07:39 <marcot> ski: This makes sense.  It's a ParsecT ReaderT StateT IO
04:07:39 <mm_freak_> statusfailed: State s and ST s are related in that they are both monads
04:07:42 <mm_freak_> and that's about it
04:08:26 <ski> marcot : ok, then the thunk is possibly passed inside the hidden state
04:08:51 <mm_freak_> there is a natural transformation from State s' to ST s:  evalState
04:09:01 <mm_freak_> there is none from ST s to State s'
04:09:12 <ski> statusfailed : `State s' keeps track of a single (unnamed) state (of type `s')
04:09:18 <mm_freak_> well, there is:  runST =)
04:09:41 <statusfailed> I've realised how vaguely formed my question is tbh :)
04:09:44 <ski> statusfailed : `ST s' keeps tracks of lots of small pieces of state, and you allocate new ones during the computation
04:09:58 <statusfailed> but mainly I was worried about doing things like destructive array updates inside a state monad
04:10:05 <mm_freak_> i don't think of ST as keeping track of anything
04:10:22 <mm_freak_> i think it's a limited version of the IO monad
04:10:35 <mm_freak_> statusfailed: you can't
04:11:23 <statusfailed> mm_freak_: isn't it possible with monad transformers?
04:11:37 <mm_freak_> what monad do you want to transform to which?
04:11:57 <statusfailed> I was thinking a combination of ST and state
04:11:57 <marcot> ski: Well, this makes sense for anyTag and tagsText, since the output of anyTag is used as the input of tagsText, but I can see no relation between specificTagText and parseObservations.
04:12:33 <marcot> parseObservations is called by the same function that calls parseOab, right in the next 3-group.
04:12:33 <mm_freak_> statusfailed: StateT st (ST s) a = st -> ST s (a, st)
04:13:24 <statusfailed> mm_freak_: is there something wrong with that?
04:14:48 <mm_freak_> statusfailed: you're mixing things up there…  State isn't about mutable variables
04:15:14 <mm_freak_> it's about functions with a "side channel" of a certain type
04:15:19 <mm_freak_> State s a = s -> (a, s)
04:15:19 <marcot> I know it's getting a bit abstract.  But the calls are kind of tree-like, there're not much of recursion.
04:16:05 <marcot> So this parseObservations 3-group and the parseOab 3-group are just two branches from the same node of the three.
04:16:07 <statusfailed> mm_freak_: sure- I mean what's wrong with the type signature above?
04:16:27 <ski> mm_freak_ : that's basically the same thing, seen from different angles :)
04:16:27 <mm_freak_> statusfailed: State and ST have specific purposes and they don't really overlap
04:16:34 <marcot> And the results of both will be used as different parameters of a data constructor.
04:17:14 <mm_freak_> ski: "that"?  the same as?
04:18:45 <mm_freak_> statusfailed: perhaps you should give a more concrete example of what you want =)
04:18:58 <statusfailed> mm_freak_: yes, definitely a vague question :P
04:19:16 <statusfailed> I'm trying to think of a decent simple example...
04:19:22 <mm_freak_> in any case you can't make a State computation switch to a mutable variable
04:19:25 <mm_freak_> that's impossible
04:19:30 <ski> mm_freak_ : "mutable variable(s)" vs. "functions with a \"side channel\""
04:20:22 <statusfailed> ski: I just think he means the distinction between how they actually work
04:26:06 <magnus> How would I write a takeWhile' function with an accumulator? I am thinking something like: takeWhile' :: (a -> b -> b) -> (b -> Bool) -> [a] -> [a]?
04:26:49 <ivanm> need an initial b as well
04:26:54 <magnus> sure
04:26:55 <ivanm> @tyle mapAccumL
04:26:58 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:28:05 <mm_freak_> magnus: takeWhileAcc :: (a -> s -> Maybe s) -> s -> [a] -> [a]
04:28:10 <magnus> ah nice, I will look into mapAccumL
04:28:30 <ski> magnus : it's not quite clear what you want the function to compute
04:29:27 <nand`> you could probably implement something like that as an unfoldr
04:29:34 <magnus> mm_freak_: yes that is a bit clearer
04:30:18 <magnus> ski: takeWhileAcc :: (a -> a -> Maybe s) -> s -> [a] -> [a], I think this is pretty clear
04:31:03 <paolino> ski, if seq evaluates both a and b , why there is no function to evaluate only one argument ?
04:31:49 <nand`> there is, it's called id
04:31:55 <ski> magnus : hm, ok i see : you want the accumulator (consrtucted from starting value and previously seen elements) to decide whether to stop at the current element or not
04:32:22 <ski> paolino : alternatively, you want `const' ?
04:32:33 <magnus> ski: correct
04:32:40 <nand`> perhaps `join seq`
04:33:27 <paolino> I was thinking evaluating one argument was more basic
04:34:52 <ski> paolino : `seq' is basically used to do "when evaluating this thing, please also evaluate that thing"
04:35:47 <ski> so, if you want to evaluate `a' when `b' is evaluated, then instead of writing just `b', you write `seq a b'
04:35:55 <paolino> oh I got it all wrong.
04:36:46 <paolino> if 'b' isn't evaluated neither 'a' is
04:37:04 <paolino> the other way around
04:39:33 <paolino> so, it's non sense x `seq` x
04:39:48 <hiptobecubic>  it's not nonsense, it's just useless
04:40:00 <paolino> ok
04:40:05 <hiptobecubic> when you evaluate x, evaluate x first
04:40:32 <paolino> first ?
04:40:53 <plcplc> After having switched to ghc-7.6.1, I get a lot of "Unacceptable result type in foreign declaration.." when compiling various FFI-dependent libraries, but I can't seem to find any information about it. Does anyone here know anything about this?
04:41:32 <ski> paolino : the "first" is at most a suggestion
04:43:08 <paolino> the semantics of suggestion being ?
04:45:42 <paolino> a suggestion in case of possible parallel evaluation, and an instruction in case of sequential ?
04:55:45 <ski> paolino : suggestion in all cases, i think
04:56:17 <ski> in any case, if `seq a b' is evaluated, `a' will be evaluated, sooner or later
04:56:35 <ski> (so if `a' doesn't terminate, then the whole computation won't terminate either)
04:56:53 <paolino> looks like this indecision could break referential transparency
04:57:07 <ski> i don't see how
04:58:37 <paolino> b is printed before a is bottom is different from a is bottom and b is never printed
05:00:58 <paolino> in case b doesn't need a
05:02:43 <paolino> maybe it's not referential transparency the problem
05:04:35 <benmachine> plcplc: if I had to guess, it might be a change to requiring that newtype constructors be exposed
05:04:52 <benmachine> plcplc: er, by which I mean, in scope
05:05:17 <rwbarton> paolino: well evaluating b doesn't cause anything to be printed of course. do you mean an example like print (a `seq` b) ?
05:06:42 <paolino> print (undefined `seq` ()) -- yes
05:07:00 <benmachine> plcplc: it used to be the case that a foreign declaration could use newtype-wrapped foreign types, even if the context of that foreign declaration couldn't actually construct values of that type
05:07:07 <benmachine> plcplc: I think that's been changed now
05:07:26 <rwbarton> two options for evaluating print (a `seq` b) are:
05:07:42 <rwbarton> * evaluate a, then evaluate b, then print the value of b
05:07:50 <rwbarton> * evaluate b, then evaluate a, then print the value of b
05:08:05 <rwbarton> what is not an option is * evaluate b then print the value of b
05:08:20 <paolino> rwbarton, undefined `seq` print () ?
05:08:41 <rwbarton> paolino, what about it
05:09:19 <plcplc> benmachine: sounds more sound, in a sense.
05:09:55 <paolino> rwbarton , can't it happen print () happens before undefined is evaluated ?
05:10:10 <benmachine> paolino: I don't think so
05:10:26 <benmachine> paolino: remember that evaluation of IO is independent of execution
05:10:40 <benmachine> (well, necessary but not sufficient for execution)
05:11:05 <benmachine> rwbarton: third option: statically prove a is not undefined, and then print b
05:11:15 <rwbarton> yes
05:11:20 <plcplc> benmachine: but it seems that a lot of packages depend on ffi calls that produce IO actions, and these are broken now
05:12:43 <benmachine> plcplc: hmm. no, they are not broken – I've installed the network package fine
05:13:06 <benmachine> plcplc: either it's IO a for some inappropriate type a, or it's a bad error message, I think
05:13:33 <benmachine> plcplc: IO CInt would be disallowed if you had not imported the constructors for CInt
05:15:01 <plcplc> benmachine: Ah. guess that would explain it. but why doesn't it apply to IO?.. that constructor is usually not exposed by design :-)
05:15:23 <benmachine> plcplc: IO is given special dispensation, on account of being primitive, I guess
05:15:43 <benmachine> plcplc: although I should emphasise that this is me half-remembering something I read a while ago
05:16:48 <benmachine> plcplc: looks like this was a warning in 7.4.1
05:17:26 <benmachine> if it's now an error that should probably go in the 7.6.1 release notes, doesn't seem to be there atm
05:18:01 <plcplc> benmachine: Do you remember where you read that?.. I'm having trouble finding any info about this specifically. (though I admit I only string-searched through the FFI-intro and friends)
05:18:15 <benmachine> plcplc: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/release-7-4-1.html
05:18:35 <benmachine> that mentions it (search for FFI)
05:18:45 <plcplc> benmachine: I thought so too, but the release notes seem quiet on the issue
05:19:01 <plcplc> Oh, I looked at the release notes for 7.6.1
05:19:06 <plcplc> I'll have a look :-)
05:20:27 <benmachine> plcplc: if it's now an error (and not just a warning that has been mutated with -Werror) then that is probably an accidental omission that should be fixed
05:21:15 <benmachine> plcplc: see also the section on "marshallable foreign types" of the Haskell 2010 report http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1540008.4
05:21:38 <benmachine> plcplc: (i.e. this is what eventually became the official standard, but after GHC had already implemented it a different way)
05:22:13 <benmachine> plcplc: note that the result type is explicitly allowed to be IO (but argument types are not)
05:23:11 <plcplc> benmachine: yeah, you're right. special disepensation
05:23:56 <rwbarton> talking about foreign import declarations?
05:24:05 <plcplc> jup
05:24:28 <rwbarton> from one point of view you can imagine the whole declaration as introducing a new constructor for IO
05:24:51 <rwbarton> one that the RTS pattern matches and implements via a call to the C function
05:24:58 <rwbarton> or "interprets"
05:25:04 <benmachine> you can do that
05:25:26 <benmachine> but it's not much more enlightening than saying "it's magic!" :P
05:26:34 <plcplc> hehe, yeah. that's a pretty big divergence from the semantics of haskell data types :p
05:28:20 <plcplc> but thanks benmachine for the explanation. I'll see if I can fix the packages I need effectively, or just start managing multiple ghc installations
05:47:20 * nand` likes the implementation model of IO as FFI call wrappers
05:48:22 <raymank26> Hi all. How can I adjust fonts in xmonad?
05:48:36 <nand`> xmonad uses fonts?
05:49:23 <raymank26> why not? KDE has some config as well as gui config.
05:49:48 <nand`> the only thing I can think of in xmonad that displays text is the error window when recompiling xmonad.hs fails
05:49:52 <nand`> are you talking about that?
05:50:37 <raymank26> no. For example I want to change fonts in console. How can I do that?
05:50:55 <raymank26> xterm for example
05:51:15 <nand`> try xterm's configuration
05:51:20 <nand`> it has nothing to do with xmonad
05:51:52 <nand`> I think xterm either has a command line flag or uses .Xdefaults for it; at any rate that's what rxvt does
05:52:04 <raymank26> Oh.. Thank you.
05:52:59 <raymank26> There is a second question. How run an application in background?
05:53:12 <raymank26> without terminal.
05:53:36 <nand`> you can bind certain key combinations to programs in xmonad.hs
05:54:06 <raymank26> hm.. not bad.
05:54:18 <nand`> (you could also auto-start them in .xinitrc or something)
05:55:37 <statusfailed> How do I randomly generate a value from a normal distribution with the statistics package?
05:55:56 <newmind> raymank26: there are application launchers (like dmenu) out there that let you enter the program name and start them in the background, i think xmonad has a default binding on mod+p on dmenu
05:56:39 <ski> nand` : `.Xresources' should be prefered to `.Xdefaults'
05:57:07 <nand`> there's also yeganesh, which is written in Haskell
05:57:14 <nand`> (but it's just a wrapper around dmenu)
06:02:17 * hackagebot esqueleto 0.2.7 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2.7 (FelipeLessa)
06:02:19 * hackagebot fb 0.12.3.4 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12.3.4 (FelipeLessa)
06:07:33 <statusfailed> hmm... looks like statistics lib doesn't have any way of generating values from any distribution
06:48:07 <lpvb> will GHC get official ARM support anytime soon?
06:50:01 <tdammers> can anyone explain to me how I get happstack's ServerPart monad and RWST to work together?
06:50:29 <parcs`> lpvb: doesn't ghc 7.4.2 fully support arm?
06:52:17 <nand`> judging by http://hackage.haskell.org/trac/ghc/wiki/Platforms you'd think not
06:52:21 <nand`> but that might be outdatd
06:55:59 <merijn> I thought there was preliminary ARM support?
06:56:19 <merijn> Unrelatedly: How much work is it to maintain two GHC installations?
06:56:46 <luite> about twice as much as maintaining one
06:57:30 <merijn> I have 7.4 from platform, but would like to use 7.6 for some code I'm writing now. I'm just not sure how to instruct cabal which ghc to pick and whether I need to do something special to keep the installed libraries separate so they don't clobber each other
06:58:03 <luite> they usually don't
06:58:58 <merijn> So aside from downloading + installing 7.6 is there something I would need to do?
06:59:02 <luite> what i do is ~/haskell/ghc-7.6.1 and ~/haskell/ghc-7.4.2 in my home dir, and a symlink ~/haskell/ghc -> ~/haskell/ghc-version for the one i'm using
06:59:11 <luite> with ~/haskell/ghc/bin in my path
06:59:24 <luite> but just modifying your PATH also works
06:59:58 <luite> their packages don't clash, except perhaps for the share directories
07:00:58 <tdammers> oh nm, figured it out mysel
07:00:59 <tdammers> f
07:02:34 <luite> merijn: that said i do install from source, with --prefix, so i'm not sure if binaries have more problems
07:04:04 <mikeplus64> @pl do v <- peek vert; f <- peek frag; potato v f
07:04:04 <lambdabot> (line 1, column 18):
07:04:04 <lambdabot> unexpected ";"
07:04:04 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
07:04:23 <rwbarton> @. pl undo do v <- peek vert; f <- peek frag; potato v f
07:04:23 <lambdabot> (peek frag >>=) . potato =<< peek vert
07:04:29 <rwbarton> how pretty
07:04:37 <mikeplus64> well we tried
07:05:15 <parcs`> :t peek
07:05:16 <lambdabot> Not in scope: `peek'
07:05:25 <mikeplus64> parcs`: peek :: Ptr a -> IO a
07:05:25 <parcs`> @type liftM2 ?potato `on` Foreign.Storable.peek
07:05:26 <lambdabot> forall a2 r. (?potato::a2 -> a2 -> r, Foreign.Storable.Storable a2) => GHC.Ptr.Ptr a2 -> GHC.Ptr.Ptr a2 -> IO r
07:06:06 <rwbarton> that one has a pure potato though
07:06:29 <ski> add a `join'
07:06:55 <parcs`> in any case it's probably not worth making that expression point free
07:07:08 <merijn> luite: On OSX it seems to symlink /usr/bin/ghc to /Library/Frameworks/GHC.framework/Versions/version-here
07:07:17 <merijn> luite: So I can probably just replace the symlink again
07:13:06 <Philonous> What is the easiest way to call C++ from haskell? Do I need to manually write C wrappers?
07:13:39 <hpc> Philonous: honestly, the easiest way would be to compile C++ to an executable and do a system call
07:14:26 <warm> is there a way to see the function definitions in ghci ?
07:15:27 <merijn> ah, bollocks
07:15:32 <parcs`> warm: nope
07:15:35 <merijn> There's no native OSX installer yet for 7.6 :\
07:16:10 <Philonous> hpc:  You mean I should just execv the resulting elf binary? That approach seems rather limiting ;)
07:16:27 <hpc> Philonous: you asked for easy... :P
07:16:51 <Philonous> hpc:  Well, in that sense "easiest" would be "don't bother".
07:17:09 <Philonous> hpc:  Actually, that's not so different from your suggestion
07:17:13 <hpc> haha
07:17:18 * hackagebot network 2.4.0.0 - Low-level networking interface  http://hackage.haskell.org/package/network-2.4.0.0 (JohanTibell)
07:17:37 <hpc> but seriously, you have to deal with the C++ RTS, and there's probably a wiki page covering it
07:17:39 <warm> parcs`, sometimes i want to figure out how the function did that, and there is no man page for the functions?
07:21:47 <merijn> warm: You can search Hoogle which has source links for most functions
07:23:31 <warm> merijn, thanks very much
07:24:42 <merijn> warm: If you installed the Haddock documentation that will also have source links locally for everything you have installed
07:26:22 <warm> merijn, in terminal, with ha typed and a tab comes out haddock-ghc-7.0.3 , is it?
07:27:26 <merijn> I have no clue, on OSX I have /Library/Haskell/doc/index.html which provides access to all the docs, no clue where it is on other platforms. I usually just use Hoogle, though
07:27:28 <rwbarton> the documentation isn't a command line program, it's a bunch of html files that got installed somewhere
07:29:00 <rwbarton> on my linux system they are under ~/.cabal/share/doc/
07:29:47 <warm> ok, i'd rather go to Hoogle, then
07:30:51 <luite> merijn: oh i do use OS X but with custom --prefix
07:32:27 <merijn> luite: I guess you install from bindist, then? I'm used to the native installer
07:32:36 <luite> merijn: no from source
07:32:46 <merijn> Even worse :p
07:33:09 <luite> merijn: meh i need to build the source anyway for ghcjs
07:33:37 <applicative> merijn Its simple.
07:33:57 <applicative> oh, this isn't from source.
07:34:27 <merijn> applicative: It's not, at least not without missing out on all the organisation I'm used too
07:35:27 <applicative> merijn I just put http://www.haskell.org/ghc/dist/7.6.1/ in ~/ghc but yeah, I kept 7.4 with the haskell platform
07:36:22 <applicative> then, to maximize laziness I made aliases khc khci khc-pkg and kabal pointing to them in my .profile
07:37:10 <merijn> applicative: Yeah, but on OSX the installer puts the various bits in the relevant OSX libraries, whereas installing with a prefix would put it there. So now the issue is whether 7.4 broken DataKinds support is sufficiently annoying for me to install 7.6 using bindist in a completely different directory tree :p
07:38:03 <applicative> merijn: it was for me thats why I did it. cabal will install in the usual place.
07:39:08 <applicative> the only real difference is that the platform installer can get some of the gui libraries working. though I have a working gloss with ghc-7.6
07:40:04 <applicative> merijn: this is what I do when I want to compile ghc-head, it's pretty practical really.
07:40:37 <applicative> it takes about 2 minutes
07:45:01 <merijn> oh well, time to suck it up :p
07:47:53 <applicative> merijn: oh, i also had to put something in my editor to call the local ~/ghc/bin/ghci  with the current module rather than /usr/bin/ghci
07:50:36 <reynir> Hi, I'm trying to install ghc on a system where I don't have root privileges
07:51:07 <paolino> merijn, how is DataKinds broken in 7.4 ?
07:51:35 <reynir> I can run the top level, but when I try to run the compiler I get the following error: "/usr/bin/ld: cannot find -lgmp"
07:52:33 <applicative> hm,  maybe libgmp isn't installed?  what os are you using, reynir ?  (not that i'm likely to be able to help)
07:52:44 <reynir> (libgmp is installed in a non-standard location, but it's in the $LD_LIBRARY_PATH
07:53:27 <reynir> applicative: ubuntu 10.04 and 12.04
07:53:41 <reynir> x86_64
07:53:46 <rwbarton> how are you installing ghc?
07:53:52 <applicative> hm, and ld isn't given this variable somehow?
07:54:33 <int-e> reynir: you may have to add something to LDFLAGS: LDFLAGS=-L/path/to/gmp/lib/dir
07:54:37 <reynir> I have downloaded the ghc 7.4.1 binary
07:55:03 <rwbarton> I notice the configure script in the ghc 7.4.2 binary distribution has a --with-gmp-libraries option
07:55:35 <reynir> int-e: Thanks. I have tried that wihtout luck
07:55:36 <applicative> ah so he could scrap gmp anyway.  though that would come at a cost ....
07:56:06 <rwbarton> no, like --with-gmp-libraries=<path to gmp libraries> I presume
07:56:30 <reynir> I couldn't run ghci before I added libgmp to LD_LIBRARY_PATH
07:56:43 <rwbarton> though I don't actually know for sure, but I thought --with-FOO means "FOO is here", --enable-FOO means "include support for FOO"
07:57:04 <applicative> oh, of course.  I was thinking of --enable
07:57:22 <reynir> I can't compile haskell platform without a working ghc
07:57:29 <applicative> I was distracted by the fact that people sometimes want to avoid gmp entirely
07:58:24 <rwbarton> reynir, so you are doing something along the lines of "cd ghc-7.4.1; ./configure --prefix=$HOME; make install; ghc" and it doesn't work?
07:59:34 <reynir> rwbarton: Something like that, yes
07:59:43 <reynir> I can run ghci
08:00:26 <paolino> ghc tries to statically link libgmp ?
08:00:58 <rwbarton> what happens if you try instead  ./configure --prefix=$HOME --with-gmp-libraries=<whatever>
08:01:06 <applicative> is this different from adding to the  LD_LIBRARY_PATH <int-e> reynir: you may have to add something to LDFLAGS: LDFLAGS=-L/path/to/gmp/lib/dir
08:02:24 <reynir> rwbarton: Will try that
08:02:52 <applicative> could it be that ld when called by ghc doesn't look in your local bashrc or whatever
08:03:09 <int-e> applicative: yes, they are different. the former is a search path for the dynamic linker; the latter gives additional options to the ld program that produces libraries and binaries.
08:03:25 <rwbarton> oh
08:03:53 <reynir> rwbarton: Didnt work :/
08:03:58 <rwbarton> I misunderstood the error
08:04:12 <rwbarton> you are saying ghc works, until it tries to produce an output file
08:04:24 <rwbarton> e.g. if your program has a type error, ghc will run fine
08:04:25 <rwbarton> ?
08:04:40 <rwbarton> just when linking the output executable, it cannot find libgmp
08:04:40 <reynir> ghci works fine, ghc works until it tries to output a file
08:04:49 <rwbarton> ok, my bad
08:05:29 <reynir> Yea, it gives a type error
08:06:06 <reynir> Maybe I should try compile 7.4 from source without libgmp?
08:06:34 <rwbarton> isn't there an option you can give ghc to pass options to the linker
08:06:48 <applicative> but if you do what int-e says,  calling ghc explicitly with LDFLAGS=-L/path/to/gmp/lib/dir ghc foo.hs
08:06:59 <applicative> or  whatever the syntax is
08:07:31 <rwbarton> I don't really trust this wiki page but how about   LIBRARY_PATH=/path/to/gmp/lib/dir ghc foo.hs
08:07:49 <int-e> oh, ghc doesn't respect LDFLAGS.  ghc -optl-L/path/to/gmp
08:07:53 <rwbarton> alternatively  ... ^ that
08:08:25 <rwbarton> or http://www.haskell.org/haskellwiki/GHC:FAQ#How_can_I_make_GHC_always_use_some_extra_gcc_or_linker_option.3F
08:08:42 <reynir> applicative: I have tried that, it doesn't work
08:09:22 <rwbarton> the -optl-L/path/to/gmp one should be right
08:11:09 <reynir> rwbarton: whoa that worked
08:11:12 <int-e> there is also a file /path/to/ghc/lib/ghc-7.4.1/settings  that contains 'C compiler flags' used for invoking gcc.
08:13:16 <applicative> ah int-e saves the day
08:13:45 <int-e> rwbarton beat me to it
08:16:40 <applicative> Ah well, good work comrades; I think a few things were clarified for me in any case :)
08:21:06 <reynir> Thanks for the help!
08:22:19 * hackagebot stylish-haskell 0.5.0.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.0.1 (JasperVanDerJeugt)
08:22:24 <rwbarton> this gloss-web thing is pretty awesome
08:26:32 <zuserm> I'm doing a thing with generics and I wonder if anyone can think of a good name for it.
08:26:33 <statusfailed> rwbarton: is that what I think it is?
08:26:46 <ksf> edwardk, ever thought of generalising <?> ?
08:26:52 <rwbarton> say I have already written a gloss "game" and want to give it a web front end, does anyone know the best way to do that? I don't need the code editor/SafeHaskell stuff
08:26:57 <ksf> ...or highlight, doesn't matter.
08:27:13 <hpaste> “Mike Zuser” pasted “Generic Flurg” at http://hpaste.org/74822
08:27:16 <rwbarton> statusfailed: http://dac4.designacourse.com:8000/game but change import Graphics.Gloss.Interface.Game to import Graphics.Gloss.Interface.Pure.Game
08:27:21 <edwardk> ksf: generalizing highlight is probably possible, the trick is doing it in a way that doesnt burden the end user
08:27:26 <ksf> I'd like to annotate the parser with completitinon information
08:27:32 <edwardk> oh that
08:27:39 <edwardk> i've been working on a way to do that thats separate
08:27:43 <edwardk> =)
08:28:02 <ksf> ideally fully monadic, for file completition.
08:28:04 <edwardk> yep
08:28:05 <ksf> *filename
08:28:34 <edwardk> i have a test version of trifecta i built that had some nascent support for completions
08:28:47 <edwardk> but i didn't get everything else working with it before i had to do other things
08:28:52 <statusfailed> rwbarton: woah :D
08:28:58 <edwardk> i should dig it up and commit it as a branch to the trifecta repo
08:29:00 <rwbarton> that was my reaction
08:29:01 <statusfailed> That's pretty funky
08:29:04 <edwardk> its pretty old
08:30:34 <edwardk> rwbarton: nice
08:31:04 <rwbarton> apparently the frame rate is throttled to reduce bandwidth and cpu costs
08:31:17 <ksf> isn't it sufficient to just thread the information through like <?> does, at least if you only want completition if the parser fails (or for the last token in the parse)
08:31:17 <ksf> ?
08:32:33 <allsystemsarego> @src intersectWith
08:32:34 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:33:08 <ksf> hmmm. another option would be to parse to a token list including position information, then I can call the right completion by token type.
08:33:31 <zuserm> edwardk, I feel like you should know if my thing is anything
08:33:40 <edwardk> ?
08:34:19 <rwbarton> fancier game from cdsmith's blog: http://dac4.designacourse.com:8000/gameInBrowser?digest=0mP0MFrBsMqFG5UU1GWZ7A%3d%3d
08:34:31 <edwardk> ksf: its pretty close to that. but its tricky to get some things right when you want to be fully parametric in the choice of completion monad for instance
08:34:32 <zuserm> I pasted some code, that feels like it should be related to something that exists somewhere, but I can't figure out what. http://hpaste.org/74822
08:35:15 <edwardk> using ghc.generics?
08:35:21 <zuserm> yeah
08:35:46 <edwardk> erm, is there much you can actually do with enflurg?
08:36:11 <edwardk> if you had enFlurg :: (forall c. Typeable c => c -> f c) i could see more applications etc.
08:36:34 <zuserm> sure
08:37:25 <edwardk> zuserm: it looks a tiny 'bit like my tinplate combinator, but i don't quite get the 'p' parameter for a and b,
08:37:30 <zuserm> if you have
08:37:30 <zuserm> data No a = NoVal
08:37:30 <zuserm> you can enFlurg (const NoVal)
08:37:30 <zuserm> or (const Nothing)
08:37:30 <zuserm> and then build your data from there
08:38:07 <edwardk> yes, but what can you do that isn't phantom or trivial with the 'c's?
08:38:08 <zuserm> Yeah. I'm not sure what the p is for, but GHC.Generics has it.
08:38:25 <edwardk> oh derp
08:38:37 <edwardk> both a and b are supposed to be Rep's for some type
08:38:40 <edwardk> nm =)
08:38:57 <zuserm> Eventually, I'll probably put typeable or something on the c's, put I haven't gotten there yet
08:40:06 <edwardk> http://hackage.haskell.org/packages/archive/lens/2.9/doc/html/src/GHC-Generics-Lens.html#tinplate is as close as i get to that
08:41:10 <edwardk> tinplate is a crappier version of uniplate/biplate. its crappier because it doesn't maintain all the hitmap stuff to avoid traversing areas of a type that can't contain what you are looking for
08:41:21 <dreixel> zuserm: the 'p' is for the parameter. It only matters when using Generic1, and writing functions like fmap
08:41:31 <edwardk> there are Data.Data equivalents in Data.Data.Lens
08:44:15 <applicative> hm, they seem not to have caught the audio for peyton jones'  'ghc status update 2012'
08:49:28 <statusfailed> is random-fu preferred to Control.Monad.Random? I can't choose, but I think RVar is quite nice
08:49:49 <statusfailed> they also both seem to define different versions of MonadRandom
08:57:14 <zuserm> edwardk, yeah tinplate is suggestive, I'll have to think about it, thanks
08:59:43 <hpc> statusfailed: stick with Control.Monad.Random until you know what specific properties you need
08:59:54 <hpc> then ask what has those properties :P
09:02:18 <statusfailed> hpc: well, I need random numbers drawn from various distributtions
09:02:21 <statusfailed> distributions*
09:02:24 <statusfailed> which only random-fu seems to have
09:07:21 * hackagebot gsl-random 0.4.4 - Bindings the the GSL random number generation facilities.  http://hackage.haskell.org/package/gsl-random-0.4.4 (PatrickPerry)
09:14:12 <solomatov> Hi! does anybody know why haskell 2010 doesn't have multi param type classes in the standard? Do they cause some nasty problems? Or is it possible to emulate them with just one parameter type classes?
09:15:33 <nand`> all I know is they can cause complex type ambiguity errors
09:16:21 <parcs`> they are not that useful without functional dependencies or associated types, both of which are not fully understood
09:16:44 <rwbarton> is FlexibleContexts in haskell 2010?
09:16:47 <geekosaur> (1) the standard tries to be doable by other compilers, most of which do not have ghc's type machinery and can't really do MPTC well (which is why they tend not to be used in practice); (2) MPTC by itself turns out to be painful without some additional way to associate types:  so far, either type families or functional dependencies. Jury is still out on which one is likely to become a standard, as both have issues (of different varieties)
09:17:17 <solomatov> I just thinking is it ok to model the following entity. I want to define a generic model and a generic change to it (event).
09:17:25 <solomatov> I want to define a type class Change m c
09:18:31 <solomatov> i see how can I define it with multi parameter type classes. I also can implement it by passing a struct with two type parameters to emulate type classers
09:18:42 <solomatov> Are there any other options?
09:19:04 <rwbarton> you can probably emulate MPTCs with DataKinds. don't do this
09:19:29 <geekosaur> solomatov, is there some reason you need to stick with H2010?
09:20:07 <solomatov> @geekosaur No. There are no reason. But I think that extensions are experimental and it would be better if I didn't use them.
09:20:08 <lambdabot> Unknown command, try @list
09:20:22 <rwbarton> probably there isn't a way to emulate MPTCs in Haskell 98 or Oleg would have written about it
09:20:23 <solomatov>  No. There are no good reason. But I think that extensions are experimental and it would be better if I didn't use them.
09:20:25 <geekosaur> you think incorrectly
09:20:47 <geekosaur> the standard is highly conservative; MPTCs have been around for a long time and are heavily used
09:21:13 <solomatov> rwbarton: type class is just a implicit record which is passed automatically to functions as extra invisible parameter
09:21:30 <solomatov> geekasaur: thanks. so I will use it :-)
09:21:50 <geekosaur> rwbarton, I have this feeling he has written about it (and yes, IIRC it comes down to explicitly passing the dictionaries around...)
09:21:57 <rwbarton> yes of course you can perform the dictionary translation yourself
09:22:01 <rwbarton> I mean in terms of ordinary type classes
09:22:02 <geekosaur> but MPTCs are more convenient
09:24:57 <nand`> glasgow haskell best haskell
09:28:41 <ddarius> MPTCs have been around since Haskell 1.2 so ~1993 or so.
09:34:39 <nand`> anybody have experience with Frege (the language, not the mathematician)?
09:37:08 <solomatov> nand: I tried it and like very much. JVM has much better integrations with external technologies than Haskell
09:38:53 <nand`> solomatov: I'm mainly interested in it because the CT course at my school is currently going through Java-centric teachings; while I'm not forced to actually use Java for it I'd be left out if I didn't have some way of interacting with it; I was thinking of using Frege instead to give me a reasonable sane language from which I can interact with existing Java libraries
09:39:12 <nand`> if you say you like it then that sounds somewhat reassuring; I was afraid of it being a dead/abandoned/broken project
09:39:43 <c_wraith> interacting with existing java libraries is the most overrated feature ever.  Having used existing java libraries, I'm of the opinion that about 90% of them aren't worth it.
09:40:06 <solomatov> nand': it's actually not dead. There were commit to its repo in aug2012
09:40:18 <nand`> c_wraith: I don't expect an awful lot from them either
09:40:24 <rwbarton> what about spring!
09:40:26 <rwbarton> (ducks)
09:40:42 <solomatov> c_wraith: it depends on what you want. If you want to use it in enterprise settings, it's very very very handy
09:41:45 <nand`> I'm convinced “enterprise” settings are merely the lowest common denominator needed to fit everybody into the same concept
09:41:50 <solomatov> btw what is CT?
09:41:58 <nand`> oh, ‘computer technology’
09:42:07 <solomatov> aaaa
09:42:54 <nand`> it's not really that great of a course (for me, at least), but it's a free 15 points and lets me drop another course in its stead :)
09:51:46 * ddarius agrees with c_wraith.  The Java language is kind of crappy, but really isn't -that- bad, but the Java libraries (standard and most others) fail to use even what Java provides effectively producing an extremely cumbersome experience.
09:56:22 <babalone1> ^
09:59:59 <nand`> hooray, asked my teacher and he told me I was free to use whatever I wanted :)
10:07:23 * hackagebot VKHS 0.1.6 - Provides access to Vkontakte social network, popular in Russia  http://hackage.haskell.org/package/VKHS-0.1.6 (SergeyMironov)
10:08:11 <ixmatus> is the "implicit" passing of state inside of a monad a bit like a closure?
10:08:27 <ixmatus> I'm reading http://ertes.de/articles/monads.html
10:08:43 <ixmatus> and it's an excellent read and on monads in Haskell
10:08:55 <ixmatus> but the only mechanism not being explained, is the implicit passing of state
10:09:37 <hpaste> ixmatus pasted “monads/state” at http://hpaste.org/74824
10:09:50 <ixmatus> in the above, I understand that "runState getRandom 5"
10:10:00 <Saizan> if you think monads in general have an implicit state that gets passed around it's probably not a good read
10:10:21 <nand`> there's no implicit passing of anything in monads
10:10:23 <nand`> they're explicit, if anything
10:10:45 <ixmatus> look at my hpaste
10:10:59 <ixmatus> the getRandom function takes no arguments
10:11:01 <Saizan> implicit passing of state is what the State monad does for you
10:11:12 <ixmatus> okay
10:11:24 <Saizan> and to learn how it's done you can lookup the source of it
10:11:33 <ixmatus> fair enough
10:11:55 <ixmatus> one more question
10:12:27 <ixmatus> I'm having a hard time trying to discern what this type signature is saying: getRandom :: State LCGState Integer
10:12:58 <Saizan> State is a type constructor that takes two argument
10:13:01 <ixmatus> I understand type constraints, argument type signatures and return type signatures - but the above doesn't make sense to me and I am having a hard time finding documentation on it?
10:13:03 <Saizan> *arguments
10:13:08 <ixmatus> okay
10:13:48 <Saizan> and here it's applied to LCGState and Integer
10:13:57 <ixmatus> thanks Saizan - that's enough to get me started in the right direction, appreciated :)
10:15:18 <Saizan> a probably easier to understand definition of State than the actual source is data State s a = StateCon (s -> (a,s)); runState (StateCon f) = f
10:16:42 <Saizan> http://www.haskell.org/haskellwiki/All_About_Monads#Definition_6 <- for (>>=) and return
10:19:38 <osa1> so I'm hearing "free monad" sutff a lot on /r/haskell lately, can anyone give me some introductory resources on it ?
10:22:07 <Zayca> Hello! What do you think abiut my site IMPIRAT.COM:D? By the way, if some one need an web-site for business I could make ^^ (in english too)
10:23:29 <ddarius> osa1: It might be better to do it as an exercise, at least for a start.  Here's the definition of the free monad: data Free f a = Return a | Roll (f (Free f a)).  Provide the Monad instance (given f is a Functor) and prove that it is a monad for any Functor f.  Also show some standard monads as examples of free monads.
10:25:54 <gabor> osa1: try this: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
10:26:02 <osa1> ddarius: that may be a little bit advanced for me, I know what a monad is but I never tried showing a data type has monad properties. also I never wrote a monadic data type before
10:26:08 <osa1> gabor: thanks
10:29:18 <osa1> I noted that exercise to be done after getting a better understanding. thanks.
10:31:18 <bootcode> hi
10:42:18 <bootcode> I have some problem trying the Writer monad
10:43:31 <hiptobecubic> bootcode, go on ?
10:43:45 <bootcode> after import C.M.Writer, ghc(i) tells me Not in scope: data constructor Writer
10:44:49 <rwbarton> use WriterT instead
10:46:12 <startling> that wouldn't cause his error, though, would it?
10:46:41 <startling> bootcode, what's the exact line you use to import Control.Monad.Writer?
10:47:22 <startling> oh, Writer is a type synonym
10:47:23 <rwbarton> oh, I assume he is trying to use the Writer data constructor if ghc is telling him "Not in scope: data constructor Writer" but maybe that is a bad assumption :)
10:47:44 <rwbarton> @type writer
10:47:44 <bootcode> http://hpaste.org/74826
10:47:45 <lambdabot> forall a w. (a, w) -> Writer w a
10:47:47 <geekosaur> yeh, this sounds to me like the new mtl is doing it
10:47:52 <startling> never mind me, I was looking at old docs
10:47:54 <geekosaur> use writer instead of Writer
10:48:02 <rwbarton> heh I have seen this exact code before
10:48:11 <rwbarton> is it an example from LYAH?
10:48:13 <rwbarton> or RWH?
10:48:15 <bootcode> yes, it is from the learn you a haskell book
10:48:50 <startling> hmm, someone should probably let them know
10:48:55 <bootcode> geekosaur: using writer helped
10:49:14 <bootcode> what is the cause of this? The data constructor is lower cased now?
10:49:27 <rwbarton> no
10:49:31 <applicative> no, the constructor is WriterT
10:49:42 <rwbarton> the data constructor is called WriterT because Writer w is WriterT w Identity now
10:50:03 <geekosaur> basically we made standalone Writer go away, folded it into WriterT.  but that means the names changed
10:50:06 <applicative> and 'Writer log a' the type is WriterT log Identity a
10:50:14 <applicative> as rwbarton says
10:50:23 <rwbarton> hmm
10:50:29 <bootcode> and what is the usage for the WriterT data ctor signature?
10:50:36 <bootcode> changing writer to WriterT causes errors
10:50:44 <applicative> bootcode: you can write the simpler olde writer
10:50:44 <rwbarton> yeah I was wrong about that
10:50:52 <hpc> @unmtl Writer w a
10:50:52 <lambdabot> (a, w)
10:50:57 <hpc> @src Writer
10:50:57 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:50:57 <rwbarton> you would need to include an Identity constructor as well (or return)
10:50:58 <applicative> bootcode: yes, writer adds the 'Identity' wrapper
10:51:00 <hpc> blah
10:51:13 <geekosaur> :t WriterT
10:51:14 <lambdabot> forall (m :: * -> *) a w. m (a, w) -> WriterT w m a
10:51:26 <rwbarton> :t WriterT . return
10:51:27 <lambdabot> forall (m :: * -> *) a w. (Monad m) => (a, w) -> WriterT w m a
10:51:35 <rwbarton> :t WriterT . return `asTypeOf` writer
10:51:36 <lambdabot>     Precedence parsing error
10:51:36 <lambdabot>         cannot mix `.' [infixr 9] and `asTypeOf' [infixl 9] in the same infix expression
10:51:38 <rwbarton> bah
10:51:41 <applicative> bootcode: WriterT (Identity x, ["Got :" ++ show x])
10:51:42 <rwbarton> :t (WriterT . return) `asTypeOf` writer
10:51:43 <lambdabot> forall a w. (a, w) -> WriterT w Identity a
10:51:58 <bootcode> applicative: I see
10:52:10 <applicative> bootcode it might be as well to write the old Writer...
10:53:24 <monochrom> please don't "change writer to WriterT". that is confusing values and types.
10:53:45 <rwbarton> WriterT is a value too...
10:53:46 <ddarius> WriterT is a data constructor (as well) and thus a value.
10:53:55 <monochrom> oh, darn, nevermind
10:54:31 <ddarius> Poor Haskell books.  They can never keep up.
10:55:55 <SLi> Is there some way to define syntax (some kind of DSL) in Haskell to type-safely represent graphs (in fact I'm only interested in finite DAGs) that can then be analyzed by Haskell code? Something that lets the programmer to write, say, a number of vertices and a number of edges between those, so that the program would not compile if one tries to define an edge on a vertex that has not been defined (so I guess using integers for ...
10:56:01 <SLi> ... vertices doesn't work)
10:56:02 <monochrom> it is also why I discouraged someone from writing a book for "haskell for enterprise things". it is not that I disdain enterprise things. it is because it will be outdated before the writing is finished
10:56:25 <monochrom> and enterprise things actually move faster than haskell libs
10:57:20 <bootcode> applicative: It seems to be WriterT $ Identity (1, ["a"])
10:57:34 <bootcode> which is reasonable now that I think about it
10:57:39 <applicative> bootcode, sorry of course
10:57:59 <zhulikas> isn't it possible to establish some sort of standards for haskell libs?
10:58:09 <zhulikas> it's scary how fast new versions are released
10:58:11 <applicative> if it had been IO say
10:58:51 <monochrom> there is a standard. but it is allowed to change, too
10:59:40 <ddarius> SLi: You can just allocate vertices and only have the allocation mechanism able to produce them, then you will only be able to make edges between allocated vertices, they simply won't be in scope otherwise.
10:59:45 <monochrom> in this context, by "standard", for haskell libs, I mean the consensus on the libraries@haskell.org mailing list
10:59:59 <SLi> ddarius, hmm, makes sense.
11:00:06 <SLi> ddarius, thanks!
11:01:16 <ddarius> You can have something like: do v <- vertex "loop"; e <- vertex "extra; v <-> v; v <-> e
11:02:24 * hackagebot sousit 0.4 - Source/Sink/Transform: An alternative to lazy IO and iteratees.  http://hackage.haskell.org/package/sousit-0.4 (MarioSiegenthaler)
11:02:41 <ddarius> Another?
11:03:07 <monochrom> Some people, when confronted with the problem of moving targets, say "I know, we need a standard / official / leader". Now they have a bigger problem.
11:03:44 <monochrom> the bigger problem is that the standard / official / leader is the new moving target
11:03:45 <ddarius> monochrom: @official would already solve that problem.  Simply ask "@official @official".
11:03:47 <bootcode> now the question I intended to ask originally - how do you apply logging in practice? eventually the gathered logs have to be written
11:03:55 <monochrom> @official mtl
11:03:56 <lambdabot> Unknown command, try @list
11:04:20 <bootcode> does it make sense to have a writer which as a side-effect instantly sends the logs to some collecting facility, for example?
11:05:06 <monochrom> also, see http://article.gmane.org/gmane.comp.lang.haskell.cafe/82614/
11:11:28 <zhulikas> sousit looks totally like conduit
11:14:55 <hpaste> “Anakreontas Mentis” pasted “Expression enconding” at http://hpaste.org/74827
11:15:58 <hpaste> “Anakreontas Mentis” pasted “Expression enconding” at http://hpaste.org/74828
11:17:25 * hackagebot groundhog-th 0.1.0.2 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.1.0.2 (BorisLykah)
11:17:25 <anakreon> I want to encode expressions in ADT's. An attempt is shown at http://hpaste.org/74828
11:18:37 <anakreon> Any suggestions how to improve it? I'd prefer to have only one data type which permits only valid combinations (e.g. do not allow Plus EInt 2 EFalse)
11:19:07 <ddarius> Look up phantom types.  You may also want to look at GADTs.
11:20:27 <anakreon> I did. I think the idea is to allow invalid combintaions in the data type but construct it with functions that will ensure validity
11:20:42 <anakreon> I'm not sure however if I got the concept correctly
11:21:35 <ddarius> That said, what you are doing is completely reasonable and natural.
11:22:00 <anakreon> Could you suggest any other resources on the topic except those in haskellwiki?
11:24:09 <ddarius> There are quite a few articles about using GADTs to enforce type invariants.  Google should find them.  It's harder to find phantom type stuff, though what's on the wiki may be good.  I don't know what it looks like now.
11:34:00 <nbermudez> good afternoon! got a question: is there bracket action in System.IO module? I know previous IO module has it
11:35:29 <geekosaur> @hoogle bracket
11:35:30 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:35:30 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:35:30 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:39:59 <nbermudez> @lambdabot thanks :)
11:39:59 <lambdabot> Unknown command, try @list
11:40:37 <maukd> @index bracket
11:40:37 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
11:43:39 <hiptobecubic> recursive definitions + quickcheck is tough to wrangle
11:59:20 <byorgey> hiptobecubic: did you try out testing-feat like I suggested?
11:59:39 <byorgey> quickcheck is not designed for dealing with recursive data types.
12:06:33 <hiptobecubic> byorgey, not yet. I watched the video but i'm still trying to understand how it works
12:07:22 <john_r_watson> So I have this monadic helper function:
12:07:23 <john_r_watson> sievify :: (Enum i, Ix i, Num i, MArray a Bool m) => a i Bool -> i -> i -> m ()
12:07:23 <john_r_watson> sievify a size i = do
12:07:23 <john_r_watson>   n <- readArray a i;
12:07:26 <john_r_watson>   -- if n then
12:07:29 <john_r_watson>   forM_ [2*i..(size-1)] (falsify a)
12:07:32 <john_r_watson>  
12:07:48 <byorgey> hiptobecubic: well, I guess the video is not so good for understanding how to use it, it's more explaining how it works
12:07:56 <byorgey> you don't really need to know how it works to use it.
12:08:17 <john_r_watson> yikes - sorry about the spam.  Anyways, the compiler complains when I try to jam that form_ in the then stmt (about indentation)
12:08:45 <byorgey> john_r_watson: every if needs an else
12:09:03 <byorgey> john_r_watson: maybe you want 'when' instead?
12:09:08 <john_r_watson> byorgey: indeed
12:09:09 <byorgey> when n $ forM_ ...
12:09:26 <byorgey> unless you do have an else that you didn't paste
12:09:47 <john_r_watson> byorgey: Nope - man I've lost my Haaskell mojo after not having coded in it for a few months
12:09:51 <john_r_watson> byorgey: thanks!
12:10:29 <dblhelix> anyone tried to build happy (1.18.9) with ghc-7.6.1? it seems broken
12:17:20 <allsystemsarego> does anyone know a good implementation of a tree traversal algorithm in Haskell?
12:17:38 <byorgey> allsystemsarego: what kind of tree traversal algorithm?
12:17:51 <allsystemsarego> byorgey, Euler tour
12:18:13 <rwbarton> of a tree? sounds unlikely
12:18:41 <rwbarton> unless you are doubling the edges, in case there will be many
12:19:08 <mreh> anyone know if conal managed to squash the bugs in reactive yet?
12:19:47 <byorgey> allsystemsarego: an Euler tour is a path that visits each edge exactly once.  The only trees with Euler tours are degenerate ones which are just linear chains.
12:20:12 <allsystemsarego> ok
12:23:45 <allsystemsarego> I think what I actually want is flatten in Data.Tree
12:24:05 <allsystemsarego> @src flatten
12:24:06 <lambdabot> Source not found. stty: unknown mode: doofus
12:28:27 <cmccann> copumpkin, you around?
12:28:37 <copumpkin> more or less :) 'sup?
12:29:36 <cmccann> mind taking a look at the mod queue for /r/haskell? I'm feeling irritable and not really up for making judgment calls.
12:30:22 * shachaf guesses it's that thread.
12:30:36 <Cale> allsystemsarego: Usually you'd just write the pre-order traversal by hand, because it's not such a difficult algorithm. One thing which you should watch out for though is that if you're concatenating lists explicitly, xs ++ ys takes O(length xs) steps to reduce, so left-leaning trees can be a problem.
12:31:05 <cmccann> shachaf, you don't say.
12:31:20 <Cale> allsystemsarego: The way to avoid this is to write a helper function which instead of producing a list of the elements [a], it produces a function [a] -> [a] which adds the elements to the beginning of another list.
12:31:21 <copumpkin> cmccann: you mean the reported comments? I wasn't really sure what to do about them either :/
12:31:26 <cmccann> yeah, the comments.
12:31:40 <cmccann> they're kinda borderline off-topic as well as being trollish.
12:32:00 <Cale> allsystemsarego: [] becomes id   [x] becomes (x:)   and (++) becomes (.)
12:32:03 <copumpkin> yeah, looks like some of them are gone anyway?
12:32:13 <Cale> allsystemsarego: so say we have a tree like:
12:32:24 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
12:32:29 <Cale> preorder Tip = []
12:32:37 <gentleben> we need a /r/haskell-blah
12:32:38 <copumpkin> cmccann: I only see one left, and I think the downvotes are good enough at keeping them invisible
12:32:43 <Cale> preorder (Branch x l r) = preorder l ++ [x] ++ preorder r
12:32:46 <cmccann> huh, I see three?
12:32:52 * cmccann does not understand reddit.
12:32:54 <Cale> you'd replace that by:
12:32:59 <Cale> preorder' Tip = id
12:33:02 <copumpkin> cmccann: oh, the other ones are already buried, I see
12:33:13 <Cale> preorder' (Branch x l r) = preorder' l . (x:) . preorder' r
12:33:17 <Cale> and then write:
12:33:22 <Cale> preorder t = preorder' t []
12:33:31 <cmccann> yeah, they're certainly getting voted appropriately.
12:33:40 <Cale> and that'll be linear in the size of the tree, instead of quadratic worst case
12:34:17 <cmccann> but I'm still tempted to kill them with fire. two are just obnoxious and not contributing anything, and one is (in my opinion) way over the line, but has replies.
12:34:18 <copumpkin> cmccann: I'd draw the line if it looked like the reported comments were starting a whole new line of unpleasant/unproductive discussion/name-calling, but they mostly seem to be getting ignored as they should be
12:34:52 <conal> mreh: just noticed your question about reactive bugs. no. i've not worked on it in quite a while.
12:35:14 <cmccann> I'll leave them for now I guess.
12:35:27 <allsystemsarego> Cale, thanks for helping, I'm going to save this in a file and look at it later, thanks again
12:38:41 <timthelion> I must admit, that even generating haskell code, when it's complex enough, gets tricky.
12:38:54 <timthelion> Especially keeping track of the order of arguments.
12:40:15 <Cale> timthelion: You mean, writing a compiler using Haskell as a target language?
12:40:24 <timthelion> Cale: yes.
12:40:47 <mac10688> first time I've seen such a lively IRC Channel
12:40:48 <mac10688> cool stuff
12:42:27 * hackagebot JuicyPixels 2.0 - Picture loading/serialization (in png, jpeg, bitmap and gif)  http://hackage.haskell.org/package/JuicyPixels-2.0 (VincentBerthoux)
12:42:29 * hackagebot type-eq 0.2 - Type equality evidence you can carry around  http://hackage.haskell.org/package/type-eq-0.2 (GaborLehel)
12:42:32 <timthelion> Cale: I'm generating https://github.com/timthelion/haskarrow/blob/master/Examples/stm3.haskarrow#L48 these functions, which listen to multiple TChans at once.  It's a data flow graph in STM....
12:42:50 <timthelion> Cale: couldn't find a way to implement it without massive amounts of code generation.
12:43:27 <timthelion> And it's turning out to be weeks of work when I thought generating it would take a day or two.
12:45:30 <Cale> What are you using to prettyprint this?
12:45:38 <timthelion> ++
12:45:41 <timthelion> ;)
12:45:48 <Cale> y u no haskell-src-exts?
12:46:50 <timthelion> I don't know how.
12:46:55 <Cale> I'm a little bit confused by the idea that this code *needs* source generation though.
12:46:58 <timthelion> I looked at the haddock and was confused.
12:47:06 <Cale> What is it that makes this code hard to abstract over?
12:47:26 <timthelion> Cale: It is impossible to abstract over. that's what makes it hard to abstract over :D
12:47:39 <Cale> (there's obviously a lot of repetition, but it's not clear why that can't be factored out)
12:48:12 <Cale> I mean, normal programming in IO and STM is in some sense "code generation"
12:48:35 <Cale> You're constantly writing functions a -> IO b which take some value and construct a program from it :)
12:48:44 <shachaf> Cale: In the same sense that programming with higher-order functions is "code generation".
12:48:50 <Cale> shachaf: yes
12:48:56 <Cale> In exactly that sense :)
12:49:27 <shachaf> (BECAUSE IO = STATE REALWORLD, RIGHT???)
12:49:32 <Cale> wat
12:49:48 <hpaste> timthelion pasted “data flow language that compiles to haskell” at http://hpaste.org/74829
12:50:23 <timthelion> Cale: I know that you won't be able to understand that code.  But the entire file that I linked to before, can be reduced down to that with code generation.
12:50:58 <identity> :r
12:51:01 <identity> eh, wrong terminal
12:51:14 <rwbarton> wait, http://hpaste.org/74829 is the input?
12:51:33 <timthelion> rwbarton: yes, and the output is the code I linked to in github.
12:51:50 <rwbarton> oh, are you the one who uses a 20-character wide editor?
12:52:01 <timthelion> yes.
12:52:07 <timthelion> well 60 chars
12:52:23 <rwbarton> what's with lines 63-66
12:52:25 <cmccann> modeling IO as "State RealWorld" would be a great idea if it actually worked. I want to use "IOT []" to implement quantum bogosort. :[
12:52:53 <timthelion> rwbarton: of the paste?
12:53:15 * cmccann files a bug "GHC fails to destroy the universe when RealWorld token is GC'd"
12:53:29 <timthelion> cmccann: :P
12:54:08 <rwbarton> yes
12:54:29 <rwbarton> wait, also I'm confused because https://github.com/timthelion/haskarrow/blob/master/Examples/stm3.haskarrow#L48 is not valid haskell?
12:54:37 <john_r_watson> pl (\x -> (foo x) && (baz x))
12:54:51 <john_r_watson> @pl (\x -> (foo x) && (baz x))
12:54:52 <lambdabot> liftM2 (&&) foo baz
12:55:09 <rwbarton> I guess that is a good reason not to use haskell-src-exts
12:55:10 <timthelion> rwbarton: what is not valid about line 48?
12:55:32 <rwbarton> oh
12:55:35 <rwbarton> I meant the whole file
12:55:46 <rwbarton> I guess the non-toplevel declarations maybe are
12:55:47 <shachaf> cmccann: Joke's on you, RealWorld tokens are zero-sized, so they're never GCed.
12:55:48 <timthelion> rwbarton: that's why I'm parsing it with her-lexer instead...
12:55:48 <Cale> It's annoying to read because of the 1-space indentation and frequent newlines :)
12:55:57 <cmccann> shachaf, :[ :[ :[
12:56:02 <rwbarton> but, for example, line 11 is not
12:56:37 <timthelion> rwbarton: of course.  It's not haskell.  It's something like haskell though.  Everything after the << is valid haskell.  There are <<'s and ='s...
12:56:39 <rwbarton> so what part of the input corresponds to line 48 of the output?
12:57:12 <pr> @pl \x -> x `mod` 7 == 3
12:57:12 <lambdabot> (3 ==) . (`mod` 7)
12:57:31 <rwbarton> line 6 i guess?
12:57:57 <timthelion> yes line 6
12:58:30 <timthelion> think of it like FRP.  When the thread fooReader, changes one of the two sources, the listeners will get re-evalutated.
12:58:58 <rwbarton> Cale: well, at least the output has an excuse for being unreadable :)
12:59:42 <timthelion> rwbarton: so each time the graph of sources is re-evaluated, then the display function gets re-evaluated(because it is also a listener in the graph, and all listeners affected by the change get re-evaluated, when a source they are listening to is changed)
13:00:18 <pr> :t liftM2
13:00:19 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:00:31 <timthelion> rwbarton: unfortunately, building a function that listens to the right sources cannot be done without code generation, because there are literally an infinite number of possible listener functions that would listen to different number of sources and other listeners.
13:01:30 <rwbarton> people solve problems like this all the time with things like Applicative
13:01:53 <timthelion> how does Applicative help?
13:02:27 * hackagebot system-fileio 0.3.10 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.10 (JohnMillikin)
13:02:43 <rwbarton> for example I can write any function and "lift" it to a bunch of monadic arguments
13:02:58 <rwbarton> > let f x y z = x * y + z in f <$> [1,3] <*> [2,4] <*> [5]
13:02:59 <lambdabot>   [7,9,11,17]
13:03:05 <rwbarton> that doesn't seem too different
13:04:25 <timthelion> rwbarton: but what about the case statment.  There are (numberOfSources)^2 cases for each recursion.
13:05:28 * timthelion really shouldn't be asking for help on this though. It's got too many details to explain it in short order.
13:05:46 <rwbarton> I am not saying I can reproduce your complicated code on the spot... just saying it is not right to dismiss the possibility of doing this without code generation out of hand
13:07:03 <timthelion> rwbarton: I didn't though.  I spent about two weeks shortening the code.  It is shorter than when I started. And I got to the point where there wasn't anything left to get rid of, and it was still rather long.
13:07:50 <Cale> timthelion: So what program is it that you're trying to write?
13:07:51 <anakreon> :t >>
13:07:52 <lambdabot> parse error on input `>>'
13:08:06 <Cale> :t (>>)
13:08:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:08:07 * ddarius remembers a time when he used no indentation (in C++ code).
13:08:17 <rwbarton> well... you said < timthelion> Cale: It is impossible to abstract over. that's what makes it hard to abstract over :D < timthelion> rwbarton: unfortunately, building a function that listens to the right sources cannot be done without code generation, because there are literally an infinite number of possible listener functions that would listen to different number of sources and other listeners.
13:09:11 <anakreon> I thought I was in my haskell interpreter buffer :)
13:09:12 <timthelion> Cale: I'm creating a data flow language that can respond to changing values in the graph, not by re-evaluating the whole graph, or by "node frequencies" but by using STM to create a dependency graph which only re-evaluates the affected values after each change.
13:11:00 <Cale> timthelion: I can imagine some difficulty perhaps in representing a typed heterogeneous graph in the first place perhaps...
13:11:04 <timthelion> Cale: so if I have value a and then I have value b = a +1 and then I have value c = 3 and value d = c+2. and I have some other node that wants to listen to the changes to b and draw it's current value to the screen.  When I change a, b and it's drawing function get re-evaluated, but c and d are left untouched(thus it being efficient)
13:11:16 <Cale> right
13:11:29 <Cale> Well, that's sort of what FRP is all about.
13:11:33 <timthelion> Cale: Exactly, the fact that it is heterogenous makes it very difficult to do without code generation.
13:12:27 * hackagebot monads-tf 0.1.0.1 - Monad classes, using type families  http://hackage.haskell.org/package/monads-tf-0.1.0.1 (RossPaterson)
13:12:34 <timthelion> Cale: Well no FRP framework that I have seen so far, has had the ability to mix IO listeners with purely functional listeners.  And this has limited FRP, in that you have to use a limited GUI toolkit that interfaces with the FRP backend.
13:14:12 <timthelion> Cale: the other thing is that FRP does re-evaluate the entire graph each time...
13:14:18 <Cale> I think I've heard about one, though I'm unconvinced that any FRP system needs to have "IO listeners" as such -- you can just have pure behaviour/event outputs, and trigger IO based on those.
13:14:33 <Cale> Not necessarily
13:14:43 <Cale> Our system certainly didn't.
13:14:57 <timthelion> which one did you use?
13:15:11 <Cale> An in-house arrow-based system.
13:15:19 <timthelion> I see
13:15:39 <timthelion> And how did it figure out what to re-evaluate?
13:15:57 <Cale> We actually did do a certain kind of "code-generation" -- a custom preprocessor for the arrow syntax which expanded the proc/do notation in terms of a somewhat wider set of combinators.
13:16:12 <Cale> (but you could just as well write code in terms of those combinators in the first place)
13:17:01 * ddarius thinks most of the putative FRP frameworks in and outside of Haskell have solved the "not reevaluating the whole dependency graph problem".
13:17:17 <blackh> Morning!
13:17:20 <Cale> It built a typed heterogeneous graph
13:17:20 <timthelion> I'm very confused, because so many people have told me that what I'm doing is FRP.  And such. Yet I've yet to see an actual FRP based application(other than the really cool stuff those 3D guys are doing)
13:17:33 <Cale> blackh: hello!
13:17:44 <conal> timthelion: the essence of FRP is denotational -- at least as originally intended (http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631). i don't know how "IO listeners" could be compatible with that essence.
13:18:02 <blackh> Hi Cale! I like talking bout FRP. Have you seen my FRP system, Sodium?
13:18:17 <Cale> blackh: Yeah, I was about to recommend that timthelion check it out :)
13:18:21 <timthelion> conal: I know that IO listeners are quite incompatible with FRP :)
13:18:25 <blackh> It's nothing spectacular, but it is complete and pretty stable.
13:19:41 <blackh> timthelion: FRP is (as Cale and my friend Ryan Trinkle said) "the observer pattern that doesn't suck"
13:20:00 <timthelion> conal: the thing is, that I've figured out a way, to get something quite similar to FRP.  A graph of nodes(threads), which comunicate using STM.  Which does have a valid concept of an IO listener.  And it makes "getting things out of the graph and onto the screen" much easier.
13:20:02 <conal> blackh: :) .
13:20:06 <rwbarton> timthelion, isn't it more like 2^n than n^2, and can't you combine all these cases (except the first one) into one
13:20:11 <blackh> So, Sodium is just the observer pattern underneath
13:20:14 <ddarius> blackh: There are a lot of things that improve on the observer pattern that are still not FRP (though they are more like FRP).
13:20:27 <timthelion> rwbarton: how do I combine the cases?
13:20:31 <rwbarton> they are all the same except something you readTChan $ valuesChan mySource1 and sometimes you return source1Val
13:20:43 <ddarius> @google "Deprecating the Observer Pattern"
13:20:46 <lambdabot> http://lampwww.epfl.ch/~imaier/pub/DeprecatingObserversTR2010.pdf
13:20:46 <lambdabot> Title: Deprecating the Observer Pattern
13:20:58 <timthelion> rwbarton: they are all the same except they are different :(
13:20:58 <rwbarton> wait maybe I don't understand something
13:21:09 <conal> blackh: still -- even making the FRP/observer comparison sounds like a denotation/operation confusion.
13:21:16 <rwbarton> what is line 91 for
13:21:27 <identity> So I'm trying to print out a grid representing a solution for the n-queens problem. SOlutions are lists [1 .. n] where n is the size of the board. So [1,2,3] would mean queens at [(1,1), (2, 2), (3,3)], obviously an invalid solution. Anyway, since I'd rather print these solutions out line by line instead of manually moving the cursor to certain coordinates, I can't really come up with a smart solution
13:21:31 <blackh> So there are two ways to view FRP - either semantically, or in terms of implementation, and owing to my experience I tend to use the latter
13:21:33 <blackh> conal: snap
13:21:35 <identity> Anyone have an idea?
13:21:56 <rwbarton> you include it when there's an updatedSource that isn't the beenReadChan?
13:22:25 <timthelion> rwbarton: yes.
13:22:34 <conal> blackh: or maybe it's saying that we can improve on some operational techniques by eliminating operational thinking.
13:22:36 <solomatov> Hello i am reading docs of haskellmode-vim and there're strange shortcuts with underscore, for example, _ct to load tags. Does anybody know what is meas?
13:22:38 <timthelion> rwbarton: if two sources are updated at once, we don't want to run two updates.
13:22:39 <blackh> conal: Saying that FRP can be implemented in terms of observer is useful for people who already understand the observer. Of course it isn't a complete explanation of what FRP Is.
13:22:56 <blackh> conal: Yes, that's a great way to look at it.
13:23:12 <Cale> identity: Write a function which takes an integer and draws a row of the chessboard with a queen on that position.
13:23:23 <cmccann> "like FRP, this approach is functional and based on a reactive conceptual model. unlike FRP, it's not FRP."
13:23:30 <conal> blackh: yes, indeed. many (most?) programmers are more comfortable with thinking operationally. so maybe they can be reached more easily by starting there and then leading them gently toward denotational perspectives.
13:24:05 <Cale> identity: map said function over the list of numbers, possibly transpose if you really want to, and then unlines.
13:24:15 <identity> hmm..
13:24:18 <solomatov> conal: IMO problem in not thinking operationally but about getting used to concept. for example, many guy systems have data binding which is very similar to FRP
13:24:20 <identity> Thanks, I'll try it out.
13:24:29 * timthelion thinks that one should denote things, and do opperations.  
13:24:41 * timthelion likes that duality.
13:24:46 <conal> solomatov: operationally similar or denotationally similar?
13:25:22 <solomatov> conal: denotationally and operationally I think
13:25:32 <blackh> conal: It is a classic paradigm shift, so it has to be done by small pieces of evidence based on the old paradigm.
13:25:39 <rwbarton> timthelion: I mean, whatever logic you are using to determine what to put into each case can just go into a single case itself
13:26:13 <blackh> The computer industry has a problem (with complexity) but they don't know that it can be fixed.
13:26:19 <timthelion> rwbarton: but a bunch of if statements doesn't help the ordeal one bit. It's still the same level of complexity.
13:26:25 <rwbarton> it's no longer 2^n
13:26:51 <blackh> conal: Here
13:26:56 <rwbarton> so I remain unconvinced that there is an essential need for code generation
13:27:03 <conal> solomatov: (a) do such systems even have a precise & simple denotation? (b) FRP can have *very different* implementation styles (operational techniques), so i have hard time imagining any operational model as being "similar to FRP".
13:27:04 <blackh> 's what's wrong with the current approach (with an example).
13:27:11 <Cale> Even the important FRP example aside, I think there's really something to programming with the notation of (symmetric/braided) monoidal categories.
13:27:18 <ddarius> blackh: They know that it can't be fixed.  There is plenty of accidental complexity that many people don't realize can be fixed, but there is still plenty of essential complexity.
13:27:27 * hackagebot HTTP 4000.2.5 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.5 (GaneshSittampalam)
13:27:41 <Cale> I hope we can fix Arrow :)
13:27:49 <rwbarton> Cale, but not closed monoidal, you mean
13:27:53 <blackh> ddarius: This is true, but IMO opinion certain programming techniques allow complexity to add more than it compounds.
13:28:02 <dmwit> > let pprint = (>>=\x->replicate x' '++"Q\n") in pprint [1,2,3]
13:28:03 <lambdabot>   <no location info>: parse error on input `->'
13:28:21 <dmwit> > let pprint = (>>=(\x->replicate x' '++"Q\n")) in pprint [1,2,3]
13:28:22 <lambdabot>   <no location info>:
13:28:22 <lambdabot>      lexical error in string/character literal at chara...
13:28:25 <blackh> ddarius: Or more precisely, they allow the complexity to increase more linearly with program size.
13:28:26 <Cale> rwbarton: right, just plain monoidal :)
13:28:35 <dmwit> oh
13:28:36 <rwbarton> someone (sigfpe?) had that cute knot DSL in do notation
13:28:48 <dmwit> > let pprint = (>>=\x->replicate x ' '++"Q\n") in pprint [1,2,3]
13:28:49 <lambdabot>   <no location info>: parse error on input `->'
13:28:58 <dmwit> I will now stop spamming.
13:29:24 <shachaf> > let pprint = (>>= \x->replicate x ' '++"Q\n") in pprint [1,2,3]
13:29:26 <lambdabot>   " Q\n  Q\n   Q\n"
13:32:47 <Cale> The arrow class is almost but not quite the data required of a symmetric monoidal category. I'd like to make that closer to the truth, by extending the operations (particularly the operations on pairs, to make arr only required for handling pattern matching/expression forming bits of the proc/do notation to the right of -< and left of <-. I'd also like to extend the laws a bit in a way which wouldn't harm any of the FR
13:32:47 <Cale> P systems and would admit a better translation of the proc/do syntax (but would mean that Kleisli isn't an Arrow)
13:33:28 <Cale> We have an implementation of this in iPwn's code, along with a preprocessor
13:33:38 <rwbarton> man, someone should go through all of sigfpe's and make each one into a package on hackage
13:33:40 * cmccann would like a notion of Arrow that allows linear implication.
13:33:44 <rwbarton> *sigfpe's posts
13:34:27 <Cale> cmccann: Yeah, that would be something that you'd get from our change, I think.
13:35:21 <rwbarton> I would be all for a better Arrow class and could easily be convinced of any competing class's superiority :)
13:35:53 <Cale> I'll hpaste our Arrow.hs, since it's something we plan to popularise eventually anyway
13:35:55 <hpaste> Cale pasted “Arrow redesign” at http://hpaste.org/74830
13:36:18 <timthelion> blackh: well I'll give you this.  Your Sodium library is certainly a hell of a lot better than any of the othe FRP libraries I've looked at :D
13:36:33 <cmccann> the awkward bit with linear implication is that you have four different connectives, and the one most like a tuple is not the product
13:36:37 <Cale> (you can see why the TypeOperators change is a little uncomfortable ;)
13:37:15 <blackh> timthelion: I'll take that as a compliment. :)
13:37:41 <rwbarton> cmccann: also one of them is hard to write
13:37:48 <cmccann> rwbarton, how so?
13:38:07 <rwbarton> ⅋
13:38:33 <cmccann> if you have linear implication as a primitive, you basically have ⅋ already...
13:38:34 <rwbarton> oh, that one is not in your fragment perhaps
13:38:40 <rwbarton> cmccann, I mean on paper :)
13:38:46 <cmccann> oh, haha
13:38:56 <ddarius> rwbarton: Why is that hard to write?
13:38:59 <Cale> btw, Pair (~>) is usually implemented by (,)
13:39:01 <cmccann> pf, who uses paper?
13:39:07 <Cale> and Unit (~>) is usually ()
13:39:23 <Cale> but why not generalise, right? :)
13:39:28 <rwbarton> ddarius: Lack of familiarity
13:40:20 <Cale> It's possible that ArrowUnit should be a subclass of ArrowPair
13:40:29 <conal> Cale: i'm really bummed about that TypeOperators change. it'll break a lot of my code, and fixing it means uglifying.
13:40:43 * ddarius is not sure how how cmccann decides which between additive and multiplicative conjunction is "more like" a tuple.
13:40:47 <Cale> conal: People are complaining now...
13:41:02 <Cale> conal: So perhaps we'll get at least operators starting with ~ back
13:41:10 <Cale> (as type variables)
13:41:19 <conal> Cale: glad to hear. i've been feeling sick about missing my chance to speak up in january. :(
13:41:28 <cmccann> Cale, ArrowPair would make linear implication kind of awkward, because all four connectives work that way. :[
13:42:03 <timthelion> blackh: Really your library and examples are very nice and very clean.  But they also prove my point.  There is one full redraw per "frame". And my STM solution allows for partial redraws.  Of course, you cannot be blamed for this, as that is how GLUT works.  But if you where using GTK2HS, and you changed the text of one text box, and you had 100 text boxes, how would you do this?
13:42:04 <Cale> cmccann: So you'd have to bless one of them, as far as proc/do go.
13:42:23 <conal> Cale: i've been working on circuit synthesis in haskell and am using a *very* similar set of abstractions to the ones you pasted. i'm glad to see the similarity.
13:42:31 <cmccann> ddarius, based on implementing linear logic in Haskell and seeing which connective can be represented as a tuple without complicating matters.
13:42:47 <Cale> conal: Right, the unifying idea is that of a symmetric monoidal category
13:43:01 <rwbarton> ArrowDup is a little weird
13:43:34 <ddarius> Cale: Is factoring out the symmetry too burdensome?
13:43:38 <blackh> timthelion: You can have 100 behaviours and attach a listener to each.
13:43:40 <rwbarton> or at least not part of the structure of a symmetric monoidal category
13:44:03 <blackh> timthelion: Is yours on hackage?
13:44:04 <Cale> ddarius: Well, perhaps not really.
13:44:16 <Cale> ddarius: That's actually a decent idea too.
13:44:21 <timthelion> blackh: Mine is, but it's so far from finished as to be not presentable :(
13:44:24 <Cale> swap belongs in yet another class :)
13:44:47 <Cale> But the proc/do desugarer uses all the stuff which is presently in ArrowPair
13:44:56 <Cale> (and more, in some cases)
13:45:06 <blackh> timthelion: Well, welcome to the world of implementing FRP. It's harder than it looks, but not impossible.
13:45:14 <timthelion> blackh: My seccond question, is how do you display a dialog? One dialog, not 100 new dialogs, but one dialog that is shown, and closes once the user clicks OK.
13:45:52 <blackh> timthelion: Using gtk2hs for example
13:45:55 <blackh> ?
13:46:06 <timthelion> yes, using gtk2hs to draw a dialog
13:46:19 <timthelion> blackh: well I'm not implementing FRP. I'm implementing a dependency resolution evaluation graph.  That's almost the same as FRP, but also almost entirely not the same.
13:46:48 <conal> timthelion: denotationally or operationally almost the same as FRP?
13:47:02 <Cale> ddarius: I haven't really thought of any real-world use cases for monoidal categories that don't happen to be symmetric yet.
13:47:16 <ddarius> Cale: Well the circuit layout one may be an example.
13:47:23 <timthelion> conal: denotationally the same.  You can implement anything that is FRP with such a graph.  But operationally entirely different.
13:47:46 <cmccann> ddarius, more specifically, implementing linear logic in Haskell such that every variable bound in a definition is used exactly once, to make it clear that things behave properly.
13:48:02 <cmccann> using a tuple for additive conjunction doesn't really work in that case.
13:48:13 <blackh> timthelion: Sodium uses Ingo Maier's (author of Deprecating the Observer Pattern) numbering algorithm. I quite like the idea of modelling things like that as Event () -> Reactive (Event Answer). The input event gives the opening of the dialog box and the output event is the closing. This is actually an arrow.
13:48:33 <Cale> cmccann: But yeah, one thing that our Arrow library *does* get you is that dup is off in its own class, so everything is linear by default.
13:48:48 <ddarius> cmccann: Have you looked at Wadler's paper(s) on pattern matching and linear logic?
13:49:05 <Cale> cmccann: and even when dup does come into the picture it's explicit, so you get to implement it in whatever clever way you'd like :)
13:49:15 <cmccann> I think so, but not recently. should probably look at those again now that I've spent more time experimenting with this myself.
13:49:26 <conal> timthelion: sorry. i meant my question as a thought provoker. i was hoping that "operationally almost the same" as a denotational notion like FRP (as opposed to various implementation strategies for FRP) would trigger some cognitive dissonance.
13:49:30 <cmccann> (that was directed at ddarius)
13:50:15 <cmccann> incidentally, the TypeOperators  change made the type signatures for my linear logic stuff look MUCH nicer than they would have before, haha
13:51:24 <timthelion> blackh: but at t0, there is the dialog event, and at t1 there is STILL the dialog event. How do you prevent a seccond dialog from being created?
13:51:26 <conal> i'm thinking that the TypeOperators change makes it easier to name specific type operators but harder to form abstractions on them, and hence harder to construct new type operators.
13:51:58 <Cale> I think our arrow desugarer would be much better off as part of GHC though, than as a separate preprocessor, but we'd need to convince people that (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k) is a law they really want their arrows to satisfy.
13:51:59 <blackh> conal: Once I saw you offend a whole lot of people with a purely technical discussion. I didn't think that was even possible! I was impressed. :)
13:52:11 <cmccann> Cale, also, it looks like your ArrowApply would force the issue of which connective is "blessed" for use with ArrowPair.
13:52:34 <ddarius> blackh: You've apparently not observed humanity much.
13:52:58 <Cale> cmccann: ah, yeah, tbh we haven't given much thought to that ArrowApply
13:53:13 <Cale> cmccann: Because we didn't have any instances of it, apart from (->) :)
13:53:24 <timthelion> blackh: So how to I create a network of nodes such that I have more than one Behavior output.  You haven't shown this in your example... Do you have any other example somewhere else?
13:54:23 <cmccann> Cale, specifically, in the case of linear logic your ArrowApply, ArrowDup, and ArrowChoice are all possible, but force a choice of pair that excludes the others
13:54:31 <Cale> cmccann: But I do think that if you *do* have an ArrowApply for some pairing, you probably want that pairing to be the default one.
13:54:35 <cmccann> oh wait, Choice is separate, never mind
13:54:36 <shachaf> blackh: What discussion was that?
13:55:28 <blackh> shachaf: It was a long time ago on Conal's blog.
13:56:26 <blackh> timthelion: With 'Event () -> Reactive (Event Answer)' the dialog opens when the input event fires, which you'd arrange to have happen only once.
13:56:39 <timthelion> conal: I am creating a dynamically re-evaluating dependency graph.  It is very similar to FRP, any given STATE of such a graph, might look the same as the state of an FRP program. But the fact that it is EVALUATED means that I can produce side effects more easilly.  I can say "every time this node gets re-evaluated(and it only gets re-evaluated when it has to because some other value/node that it depends on has changed) I want to redraw it'
13:56:44 <conal> blackh: maybe http://conal.net/blog/posts/notions-of-purity-in-haskell/ ?
13:57:00 <blackh> timthelion: I don't quite understand the question about multiple behaviours. You can outputs lots of behaviours from something, no problem.
13:57:04 <timthelion> blackh: good :)  That's the same as my solution to the problem
13:57:21 <conal> blackh: or http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm ?
13:57:23 <cmccann> Cale, probably. it only gets awkward if your category has both currying and products, but the two use different notions of a pair.
13:57:24 <timthelion> blackh: Like your Game type.
13:57:38 <timthelion> blackh: how would you output more behaviors from your Game type?
13:58:31 <gspr> Suppose I have an FFI call  foo :: IO (Ptr a)  that I guarantee is safe to wrap in unsafePerformIO. Is there any way I can associate a finalizer to the Ptr a, making it a ForeignPtr a, *without* placing myself in the IO monad again?
13:58:39 <blackh> conal: I can't quite remember, but I'm sure you understand that I believe this is a reflection on the audience, not on you. I am very interested in paradigm shifts in general and how they play out in human psychology.
13:58:47 <cmccann> Cale, personally I'd be inclined to make something like Pair with two parameters, using both the arrow and the pair types
13:58:47 <timthelion> blackh: like with the pudle one, what if I wanted to show a dialog every time someone clicked on something that wasn't a pudle?
13:58:50 <kingleoric> what is a municipal vehicle?
13:59:22 <kingleoric> WOuld I learn much about TCP/IP by implementing the IRC protocol?
13:59:31 <cmccann> Cale, note that everything in ArrowPair works for both (,) and Either, even in rather conventional settings
13:59:41 <gspr> (I'm guessing unsafePerformIO *after* newForeignPtr is unwise)
14:01:13 <gspr> Really, what I'm saying is: Suppose I have a C function that in a contextless manner allocates some data. unsafePerformIO lets me have that data in Haskell outside the IO monad if I swear the C function is side effect-free. Do I also, somehow, get to assign it a finalizer?
14:01:14 <Saizan> gspr: you should look at bytestring's source
14:01:23 <gspr> Saizan: Thanks, I'll have a look
14:01:59 <Cale> cmccann: I worry about over-abstracting that though. It's already a bit baroque as far as type parameters go.
14:02:34 <blackh> timthelion: The game one would be easy. You'd output (Behavior A, Behaviour B) then you'd need two listeners and IORefs and all that nonsense.
14:02:35 <Cale> cmccann: (In fact, we don't even internally use the opportunity to use different Pair types than (,) or unit types than ()
14:02:35 <Cale> )
14:03:19 <cmccann> Cale, is it really over abstracting if even terribly mundane cases have two obvious choices and you have to either hobble one or duplicate a lot of definitions? :T
14:04:25 <blackh> timthelion: With the poodle one, you basically need to duplicate the logic. Fanning an event out into multiple events in this model requires a filter for each, so it doesn't scale that well (as far as performance is concerned).
14:04:36 <gspr> Saizan: At first glance, it seems to be that bytestring indeed does unsafePerformIO *after* newForeignPtr.
14:05:11 <gspr> Seems scary to me... I mean, *I* truly don't know that newForeignPtr is "safe" to wrap in unsafePerformIO
14:05:28 <Cale> cmccann: Well... the point of type classes is to bless one operation on a given type over others. Presumably you'd use newtypes to do instance selection.
14:05:31 <timthelion> blackh: and so then, when I then click where ther isn't a pudle, both the sprites IORef will be written to and the dialog creation code will be run?
14:05:50 <Cale> cmccann: Of course, you could argue that all this stuff should be turned into data declarations.
14:05:53 <cmccann> personally the classes built on top of Pair seem needlessly fragmented between ArrowExtend and ArrowForget, while ArrowChoice seems like an afterthought that doesn't distinguish between having (|||) and (+++)
14:05:54 <blackh> gspr: I believe it is safe to use newForeignPtr in unsafePerformIO because, basically, that's the point of unsafePerformIO to do things like that.
14:05:55 <timthelion> blackh: how are you doing the filter?
14:06:14 <Cale> cmccann: There's a reason that it seems like an afterthought :)
14:06:15 <cmccann> but yes, it's hard to pin down where to draw the line.
14:06:26 <Cale> cmccann: (we didn't have an instance)
14:06:56 <Cale> cmccann: It's not perfectly thought out yet, but a rough example of the direction we'd like to take things.
14:07:07 <blackh> timthelion: Well, eDestructions is a big filterJust. You'd need another expression for eMissedPoodle that was the inverse. So, not as efficient as it could be.
14:07:14 <cmccann> yeah, I know. just complaining because it's there. :]
14:07:17 <Cale> In particular, the extend and forget stuff though actually turns out to be useful.
14:08:21 <cmccann> I figured it was, it just seems weird to me at first.
14:09:14 <hiptobecubic> byorgey, :/    i *kind of* get it.
14:09:21 <cmccann> too used to thinking of products as fundamental, where you only have that indirectly as a consequence of combining two other classes
14:09:33 <timthelion> blackh: and can you fix this somehow?
14:09:55 <Cale> cmccann: Actually, wasn't it one of those classes of exotic logics which forbade "forget"?
14:09:59 <hpaste> hiptobecubic pasted “Test.Feat hangs” at http://hpaste.org/74831
14:10:19 <ddarius> Yes, substructural logics typically don't provide "forget".
14:10:30 <timthelion> blackh: like, if you had to rewrite the code somehow so it would scale well could you?
14:10:48 <hiptobecubic> I guess the recursion is some how ruining it. I tried to model it after the lambdas example, but no luck
14:10:58 <cmccann> yes, so I think your classes can't actually define a product on the category without requiring additional stuff.
14:11:48 <cmccann> so I guess that forces the choice of pair for linear logic anyway.
14:12:36 <blackh> timthelion: I've been working with Cale on IPwn.FRP, and we came up with a new primitive for this, which was a sort of "junction box", for routing events. The thing about FRP is that there is no concept of "pushing" a value, and that's where the difficulty comes in.
14:13:01 <blackh> timthelion: By "pushing" I mean routing an event to a destination chosen by the originator of the event.
14:13:19 <cmccann> (the only reason I keep focusing on linear logic here, other than being interested in it myself, is that it's potentially useful while breaking a lot of assumptions about useful Arrow-like things in programming)
14:13:35 <timthelion> blackh: what if you didn't have to push?  What if you could listen instead?
14:13:45 <ddarius> The monoidal product is not a categorical product.
14:14:11 <timthelion> blackh: can I have multiple listeners to the same behavior?
14:14:57 <cmccann> ddarius, I've been misusing "product" to mean specifically the categorical product, if that's what you're getting at...
14:15:34 <ddarius> cmccann: Yes, but Cale's classes not defining a categorical product is kind of the whole point of them.
14:15:58 <timthelion> blackh: imagine Game = Event MouseClick -> Behavior Double -> Behavior ([Sprite],Maybe DialogMesage) and then two listeners to that same Behavior?
14:16:03 <blackh> timthelion: Yes, you definitely can. The thing with FRP programming is that if you think "now I'll push this value into..." then you have to stop yourself, because that does not fit into the model.
14:16:47 <cmccann> ddarius, yes, but it seems kind of odd that they *can't* define a categorical product and nothing else, rather than merely not requiring something to be a categorical product.
14:17:43 <blackh> timthelion: That would work, but there's no reason you can't use .... Reactive (Behavior [Sprite], Behavior (Maybe DialogMessage)) and have two listeners in IO-land. I would model the Dialog as Event DialogMessage -> Reactive (Event Answer) though.
14:17:43 <cmccann> the additive conjunction in linear logic being such an example of something that's excluded
14:18:28 <cmccann> (even though you'd almost certainly pick the multiplicative conjunction in this case anyway, to get currying and application)
14:20:58 <timthelion> blackh: well thank you for your discussion.  You have given me valulable insites into my own framework.  You seem to have done a very good job on yours.  I have to go to bed now though, as I have important buisness tomorrow.
14:21:21 <ezyang_> Hey Haskell, what are some good statements which are true in propositional intuitionistic logic to assign as exercises?
14:21:59 <cmccann> pf, non-linear logic.
14:22:43 <ddarius> ezyang_: All the "high-school algebra" equivalences, though I'm not sure what they are like as logic exercises.
14:23:29 <copumpkin> ezyang_: 3 of the 4 deMorgan laws
14:23:30 <ezyang_> hm, I feel like I might need predicates for that?
14:23:35 <copumpkin> oh
14:23:36 <blackh> timethelion: No worries. It is about my 5th attempt to write an FRP system. It takes a while to get your head around all the issues.
14:23:37 <kingleoric> WOuld I learn much about TCP/IP by implementing the IRC protocol?
14:23:46 <ezyang_> kingleoric: No.
14:24:06 <dolio> ezyang_: To do which?
14:24:11 <hpc> you would probably learn about TCP/IP by implementing it
14:24:13 <cmccann> ezyang_, adding more starting examples for logitext?
14:24:17 <ezyang_> dolio: high school algebra
14:24:21 <hpc> and you would learn to APPRECIATE it by writing an IRC bot with UDP
14:24:30 <ezyang_> I hacked up propositional intuitionistic logic and I want to give some samples
14:24:30 <hpc> (or something else; probably not an IRC bot)
14:24:33 <ddarius> ezyang_: To prove ((A and B) implies C) is equivalent to ((A implies C) and (B implies C))?
14:24:42 <ddarius> Er A or B
14:24:44 <ezyang_> I am also very close to having linear logic \o/
14:24:44 <dolio> ezyang_: It means (A \/ B) -> C = (A -> C) /\ (B -> C) and such.
14:24:56 <ezyang_> "Oh". OK, that I can do.
14:25:15 <dolio> A -> B /\ C = (A -> B) /\ (A -> C)
14:26:58 <ddarius> ezyang_: There're things like commutativity and associativity, though those tend to be rather boring proofs.
14:27:29 <Saizan> is there an FRP lib with an API to deal with filesystems?
14:27:37 <Znudzon> Hi i need to write office app with some gui and data base support ( postgres ) . Is haskell have some good multiplaftorgm gui libs ?
14:28:07 <ezyang_> hm, I bet call/cc would be fun
14:28:19 <Znudzon> Any one tryed write something bigger in haskell maybe some office software?
14:28:27 <shachaf> ezyang_: The proof of LEM using callcc is nice.
14:29:09 <shachaf> ezyang_: By the way, I think something got messed up in http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/ (search for "Tample").
14:30:40 <ezyang_> shachaf: Hm, is that the only bug?
14:31:18 <shachaf> ezyang_: That I saw so far.
14:31:24 * shachaf implemented all the exercises there but doesn't quite understand them yet.
14:31:30 <blackh> Saizan: My system Sodium would allow for that, but nothing like that is built in.
14:31:31 <shachaf> Programming by type-checker, hooray!
14:32:10 <shachaf> ezyang_: "Implement the monad instance from scratch, without rep/abs." -- do rep/abs help you at all, given that you don't have a "Monad m" constraint?
14:32:29 * hackagebot monte-carlo 0.4.2 - A monad and transformer for Monte Carlo calculations.  http://hackage.haskell.org/package/monte-carlo-0.4.2 (PatrickPerry)
14:33:18 <ezyang_> Hmmm.
14:35:01 <shachaf> It seems easier to implement join and fmap for Free, and then inline the join/fmap definition of (>>=) and apply the monad laws to simplify it, rather than just writing (>>=) straight out.
14:35:31 <shachaf> The Codensity monad instance got much easier when I realized it was the same as Cont. :-)
14:37:31 <ezyang_> Ugh, the call/cc derivation gets long pretty quick
14:37:44 <shachaf> Which derivation?
14:38:24 <ezyang_> As in, proving you can implement call/cc
14:38:32 <ezyang_> "i.e., implementing it"
14:38:53 <shachaf> Well, you can't, in intuitionistic logic. :-)
14:39:33 <shachaf> I mean "((a -> b) -> a) -> a" callcc.
14:39:50 <ezyang_> yeah, this is callcc in the cont monad
14:39:54 <cmccann> you can implement it fine using a CPS transform, which certainly would get lengthy.
14:39:55 <shachaf> Ah, OK.
14:40:05 <shachaf> @ty callCC
14:40:06 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:40:19 <ddarius> ezyang_: You'd want to be able to make lemmas.
14:40:23 <shachaf> callCC :: ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
14:40:26 <shachaf> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
14:40:27 <lambdabot> f a b = a (\ c _ -> b c) b
14:40:32 <shachaf> Not that lengthy.
14:40:53 <ezyang_> yeah, the problem is I'm keeping around things in the context after you use them...
14:41:01 <cmccann> ezyang_, how about LEM under Cont, i.e. \k -> k . Left $ \x -> k . Right $ x
14:41:04 <ezyang_> I should just ask if you want to contract
14:41:11 <shachaf> cmccann: Yep, that one is fun.
14:41:27 <ezyang_> I guess I should provide extraction from proofs to lambda terms... :)
14:42:39 <sixohsix> is there a monad like list that would do this? (do a <- [1,2]; b <- [3,4]; return (a,b) -- producing [(1,3), (2,4)] )
14:42:52 <hpc> no
14:42:53 <shachaf> sixohsix: There's an Applicative, "ZipList".
14:42:57 <rwbarton> yes
14:42:57 <shachaf> It's not a monad.
14:43:10 <cmccann> it's a monad if your lists are all the same length. :]
14:43:15 <shachaf> But you can use liftA2, which behaves like do a <- m; b <- n; return (a,b)
14:43:27 <rwbarton> it is actually a monad
14:43:29 <cmccann> (it's also horribly inefficient as a monad, but that's another matter)
14:43:31 <rwbarton> if you define join right
14:43:39 <shachaf> You can make ZipList a monad?
14:43:42 <rwbarton> yes
14:43:48 <dolio> > [ (a, b) | a <- [1, 2] | b <- [3, 4] ]
14:43:49 <lambdabot>   [(1,3),(2,4)]
14:43:52 <shachaf> rwbarton: I was trying to define join wrong the whole time. I guess that's the bit I was missing.
14:44:00 <hpc> wait, how?
14:44:01 <rwbarton> join is tricky
14:44:12 <dolio> Well, I don't believe rwbarton.
14:44:18 <sixohsix> well i don't care its mathematical basis, i just want it to work. :)
14:44:18 <cmccann> rwbarton, don't lists of different lengths always result in breaking the monad laws in some cases?
14:44:19 <dolio> I've seen it defined multiple ways and they all failed.
14:44:21 <rwbarton> I heard the solution from secondhand
14:44:25 <rwbarton> -from
14:44:37 <rwbarton> join xss = the diagonal of the largest square that fits within xss
14:44:50 <sixohsix> > do a <- [1,2]; b <- [3,4]; return (a,b)
14:44:51 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
14:45:11 * cmccann remains skeptical but would have to work through it more detail to be sure either way.
14:45:12 <rwbarton> i.e. length (join xss) = the largest n such that xss !! i !! j exists for all 0 <= i, j < n
14:45:21 <sixohsix> wait. dolio's example is a list comp, which means there is an equivalent in the list monad, right? what am I missing?
14:45:35 <shachaf> sixohsix: That's not a regular list comprehension.
14:45:35 <dolio> It's not a regular list comprehension.
14:45:43 <sixohsix> oh
14:45:47 <dolio> It's a zip list comprehension.
14:46:01 <startling> can you encode lists' lengths in the type system with data kinds?
14:46:16 <rwbarton> can you mix the two? what is [ f a b c d | a <- as, b <- bs | c <- cs, d <- ds ] ?
14:46:18 <cmccann> you don't even need data kinds, really.
14:46:28 <shachaf> Yes.
14:46:33 <startling> cmccann, oh, you can do Nat in the type system without it, can't you
14:46:42 <sixohsix> > [ a + b | a <- [1,1] | b <- [2,32] ]
14:46:43 <lambdabot>   [3,33]
14:46:51 <rwbarton> I guess I could just test it, huh
14:47:00 <rwbarton> > var "a1"
14:47:01 <lambdabot>   a1
14:47:03 <sixohsix> wtf
14:47:25 <startling> sixohsix, you could do it by encoding lists' lengths in the type system
14:47:32 <rwbarton> > [ f a b c d | a <- map var ["a1", "a2"], b <- map var ["b1", "b2"] | c <- map var ["c1", "c2"], d <- map var ["d1", "d2"] ]
14:47:33 <lambdabot>   Ambiguous type variable `t' in the constraints:
14:47:33 <lambdabot>    `SimpleReflect.FromExpr ...
14:47:40 <Cale> rwbarton: are you sure that's associative?
14:47:48 <rwbarton> > [ f a b c d | a <- map var ["a1", "a2"], b <- map var ["b1", "b2"] | c <- map var ["c1", "c2"], d <- map var ["d1", "d2"] ] :: [Expr]
14:47:49 <lambdabot>   [f a1 b1 c1 d1,f a1 b2 c1 d2,f a2 b1 c2 d1,f a2 b2 c2 d2]
14:47:55 <rwbarton> Cale, I have no idea what it means :)
14:48:01 <rwbarton> that's why I'm evaluating it!
14:48:05 <Cale> I mean the join...
14:48:09 <rwbarton> oh
14:48:13 <rwbarton> pretty sure yes
14:48:19 <rwbarton> not 100% sure
14:48:31 <shachaf> Do you happen to have an implementation of it handy? :-)
14:48:37 <rwbarton> hmm
14:49:00 <sixohsix> so the syntax with multiple |'s in the list comp is a ziplist comp, and it's translatable to a ZipList Applicative thing. is that right?
14:49:07 <parcs`> > transpose [[1,2,3],[4,5],[6],[7,8,9]]
14:49:08 <lambdabot>   [[1,4,6,7],[2,5,8],[3,9]]
14:49:33 <shachaf> sixohsix: Zip comprehensions aren't defined in terms of Applicative or Monad or ZipList.
14:50:08 <copumpkin> ddarius (dolio?): what time you wanna meet?
14:50:13 <sixohsix> fine. i'll just use it. i think it's what i was looking for. thanks.
14:50:13 <dolio> What?
14:50:32 <shachaf> sixohsix: You can also just use the function zip(With), of course...
14:50:47 <rwbarton> > let diag' [] = []; diag' ([] : _) = []; diag' (xs:xss) = head xs : diag' (map (\y -> zipWith const y (tail xs)) xss) in diag' ["ab", "cde", "fghi"]
14:50:48 <lambdabot>   "ac"
14:50:54 <rwbarton> no...
14:51:02 <parcs`> sixohsix: they're called parallel list comprehensions and they're defined in terms of the 'zipN' functions i think
14:51:10 <rwbarton> > let diag' [] = []; diag' ([] : _) = []; diag' (xs:xss) = head xs : diag' (map (\y -> zipWith const (drop 1 y) (tail xs)) xss) in diag' ["ab", "cde", "fghi"]
14:51:11 <lambdabot>   "ad"
14:51:32 <rwbarton> > let diag' [] = []; diag' ([] : _) = []; diag' (xs:xss) = head xs : diag' (map (\y -> zipWith const (drop 1 y) (tail xs)) xss) in diag' ["abx", "cde", "fghi"]
14:51:33 <lambdabot>   "adh"
14:51:34 <shachaf> @@ @let @where sneaky
14:51:36 <lambdabot>  Defined.
14:51:39 <rwbarton> haha nice
14:51:53 <rwbarton> @let diag' [] = []; diag' ([] : _) = []; diag' (xs:xss) = head xs : diag' (map (\y -> zipWith const (drop 1 y) (tail xs)) xss)
14:51:54 <lambdabot>  Defined.
14:51:58 <Eduard_Munteanu> @where sneaky
14:51:58 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
14:52:02 <rwbarton> ugly but I think that's what it is
14:52:04 <sixohsix> ah. zipWith! okay NOW I got it!
14:52:14 <shachaf> Oh, that's not dropFromEnd there.
14:52:25 <rwbarton> no, but it is related
14:52:29 <shachaf> Right.
14:52:34 <rwbarton> I want to cut off the rest of the lists at the length of the first list
14:52:37 <shachaf> I think any use of zipWith const is related. :-)
14:52:41 <rwbarton> Most likely
14:53:11 <shachaf> diag' [] = []; diag' ([] : _) = []; diag' ((x:xs):xss) = x : diag' (map (\y -> zipWith const (drop 1 y) xs) xss)
14:53:52 <rwbarton> there was some reason this seemed like a good idea but yeah
14:54:05 <rwbarton> I think I was going for \y -> drop 1 (zipWith const y xs)
14:54:15 <rwbarton> but then failed to actually write that
14:54:30 <rwbarton> Anyways, yours is still better.
14:54:43 <sheriff> Is it possible to overload && to do something different when given arguments of a different type?
14:54:55 <ddarius> sheriff: Only by hiding and redefining it.
14:55:05 <sheriff> OK, that's about where I'd gotten to
14:55:35 <rwbarton> @check \xss -> diag' (diag' xss) == diag' (fmap diag' xss)
14:55:37 <lambdabot>   "Falsifiable, after 7 tests:\n[[[(),(),(),(),()],[],[(),(),(),()],[(),(),()...
14:55:43 <rwbarton> interesting
14:56:05 <Eduard_Munteanu> sheriff: no ad-hoc polymorphism in Haskell, if that's what you're asking for.
14:56:09 <rwbarton> though not especially helpful
14:56:45 <sheriff> Redefining && is not going to be a particularly big deal, though, right? It'll be easy to incorporate the 'old' functionality with Bools
14:56:54 <Eduard_Munteanu> Where ad-hoc polymorphism is C++-style overloading, in simpler terms.
14:57:13 <Eduard_Munteanu> :t (&&)
14:57:13 <shachaf> sheriff: It's quite likely a bad idea.
14:57:14 <lambdabot> Bool -> Bool -> Bool
14:57:15 <sheriff> I just need some kind of super-class that is Bool | MyType
14:57:19 <shachaf> sheriff: But why do you want to do it?
14:57:31 <rwbarton> data Super = B Bool | M MyType
14:57:39 <rwbarton> but...
14:57:51 <sheriff> shachaf: I'm implementing a DSL for homework. I currently have it working just fine with MyType:&&:MyTpe
14:58:06 <sheriff> But the professor's examples specifically /don't/ use that syntax
14:58:12 <cmccann> there are plenty of places where using && would make sense on non-Bool values.
14:58:14 <sheriff> Which I imagine is an oversight, but I want to nail this
14:58:57 <cmccann> building expressions being a fine example. you can use Num to build arithmetic expression trees, for instance.
14:58:59 <parcs`> if it's a contrived homework assignment then by all means redefine &&
14:59:23 <sheriff> I think I will redefine && using the super type, which is kinda what I'd been planning to do anyway
14:59:29 <sheriff> Just wanted to know if there was a more sensible way
14:59:38 <sheriff> I'll also document why it'd be a bad idea in the comments
14:59:39 <rwbarton> (ignore what I wrote about Super)
14:59:44 <ddarius> & is available (though not |)
14:59:55 <rwbarton> @type (.&.)
14:59:56 <lambdabot>     Ambiguous occurrence `.&.'
14:59:56 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
14:59:56 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
15:00:03 <rwbarton> @type (Data.Bits..&.)
15:00:04 <lambdabot> forall a. (Bits a) => a -> a -> a
15:00:05 <rwbarton> -- ugh
15:00:16 <rwbarton> what a hideous name
15:00:17 <cmccann> just use ∧ and ∨. ;]
15:00:20 <sheriff> ddarius: Sure, and I can also just use :&&:, /but/ it's a contrived homework example :)
15:00:28 <rwbarton> @src Bits
15:00:28 <lambdabot> Source not found. That's something I cannot allow to happen.
15:00:38 <shachaf> ∧ and ∨ are available.
15:00:42 <sheriff> A very minor part of a much larger assignment, but I am really trying to nail this
15:01:01 <rwbarton> find a unicode character that looks like &&
15:01:09 <sheriff> rwbarton: I am one step ahead there :-)
15:01:16 <sheriff> I was just thinking something perverted like that
15:01:18 <shachaf> ⅋
15:01:25 <sheriff> hrmmmmm
15:01:31 <sheriff> OK, thanks all
15:01:36 <cmccann> shachaf, that's a disjunction :P
15:01:37 * sheriff gets back to the hard parts
15:01:38 <dolio> rwbarton: Consider v = [[[1,2],[]],[[3,4],[5,6]]], I think. join v = [[1,2],[5,6]] is the outer square, but map join = [[], [3,6]].
15:01:43 <Eduard_Munteanu> shachaf: what's that, a bird?
15:01:49 <shachaf> 214B   TURNED AMPERSAND     [⅋]
15:01:57 <Eduard_Munteanu> :O
15:02:00 <ddarius> Bird?
15:02:01 <sheriff> Disjunction is surely just V
15:02:14 <rwbarton> dolio, hmm
15:02:19 <Eduard_Munteanu> ddarius: it looks like a bird eating something to me.
15:02:21 <shachaf> conjunction and njunction, right?
15:02:26 <sheriff> Hrm
15:02:36 <sheriff> I could use /\ for 'conjunction' and V for disjunction
15:02:51 <ddarius> There are more disjunctions in heaven and earth, sheriff, than dreamt of in your philosophy.
15:03:35 * cmccann considers the humor value of using njunction, disjunction, conjunction, and codisjunction for the four linear logic connectives.
15:03:42 <Eduard_Munteanu> Ah, DejaVu Sans Mono is at fault here. That, or my eyes :)
15:03:54 <shachaf> cmccann: First four?
15:04:07 <cmccann> shachaf, hm?
15:04:22 <ddarius> There are more if you go to an ordered linear logic.
15:04:25 <shachaf> Oh, linear logic has four.
15:04:50 <shachaf> ezyang_: What's the context of the intuitionistic logic thing you're doing, by the way?
15:04:59 <ezyang_> shachaf: Just for fun.
15:05:05 <cmccann> there's also implication and whatnot, but yes I meant the usual four. :P
15:05:21 <shachaf> ezyang_: (Are you in the bay area yet? roconnor is doing a talk at Stanford on Wednesday.)
15:05:23 <ezyang_> Hmm, quite pleased with how the call/cc proof turned out
15:05:34 * cmccann wondered if ezyang_ is doing something related to http://logitext.mit.edu/main
15:05:44 <shachaf> cmccann: Yes, that's what I was wondering by "context".
15:05:48 <ezyang_> shachaf: I'll probably be tied up with first year PhD students
15:05:56 <ezyang_> cmccann: That is the project I am hacking on
15:06:03 <ezyang_> *first year PhD students orientation
15:06:13 * shachaf has the feeling http://slbkbs.org/proof.png is more complicated than it needs to be.
15:06:14 <cmccann> ezyang_, it's a pretty neat project!
15:06:30 <shachaf> These proofs seem to be basically write-only. :-(
15:07:11 <ezyang_> yes, it is a common problem with proof assistants
15:07:14 <ezyang_> cmccann: Thanks!
15:07:37 <shachaf> Yes, it is.
15:07:54 <cmccann> ezyang_, I've been on a linear logic kick lately so I was tempted to hack on it to support that but the effort of getting coq and ur/web set up was more than I wanted to deal with. :T
15:08:04 <pr> so, i had a 32bit version of ghc 7.4.1 installed (i guess from the haskell platform, don't remember) and i probably need to replace it with the 64bit version. i downloaded and installed the 64bit version of the haskell platform, but the installer fails right at the end (still providing me with a 64bit ghc and all that good stuff)
15:08:16 <pr> now, what it doesn't do is give me an error log, so i don't really know what failed
15:08:48 <pr> oh, i'm on os x 10.8 btw
15:08:50 <shachaf> I was trying to figure out a way of making a friendly puzzle game (in the style of http://www.dragonboxapp.com/) based on intuitionistic-logic proofs and Curry-Howard.
15:09:45 <cmccann> shachaf, hahaha, I was thinking pretty much the same thing (possibly inspired by the same source, even)
15:10:14 <ezyang_> cmccann: Yes, it is a bit of a bother
15:10:20 <ezyang_> Though I can iterate pretty fast once it's setup
15:10:24 <shachaf> cmccann: In the context of thinking about this, linear logic seems in some ways more sensible than regular logic.
15:10:38 <rwbarton> dolio: ah yes, now I see where I was going wrong before. Thanks for the example
15:10:40 <pr> perhaps the installer fails because things like cabal are still flying around in the system, dunno. is there any way to really know what's going on, except for "The installer failed. Please contact the developers"
15:10:46 <rwbarton> now I need to figure out who I heard this claim from :)
15:11:14 <cmccann> shachaf, I'm very fond of it these days. it's nicely constructive, though mostly in that things you can do by abusing CPS transforms becomes implicit
15:12:09 <ezyang_> ...huh, I wonder if I actually need contraction at all for prop-intui logic
15:12:23 <rwbarton> shachaf: did you see the 200...6 icfp contest? the one about sand-based computing? it contained an adventure game that involved proving theorems in the fragment of intuitionistic logic with just ->
15:12:24 <thetallguy1> need a human hoogle
15:12:37 <cmccann> the toy linear logic implementation I was hacking on the other day basically represents linear implication as "Kleisli Cont"
15:13:00 <shachaf> rwbarton: Not in much detail.
15:13:23 <rwbarton> let me see if I can dig up some info about it
15:13:33 <thetallguy1> given an import statement, does there exist a function somewhere that returns a Maybe FilePath of the corresponding file in the project directory?
15:13:33 <dolio> rwbarton: Yeah. And considering the 'smallest square' thing behaves that way, and that's the obvious definition, I'm tempted to say there's just no way to do it.
15:13:43 <dolio> I wasn't sure there for a few minutes.
15:13:58 <shachaf> cmccann: I've been trying to figure out a nice graphical representation for lambdas etc., linear or otherwise.
15:14:17 <rwbarton> shachaf: see http://www.boundvariable.org/press/tr-06-163.pdf section 3.9 (starts on page 8)
15:15:09 <rwbarton> part I
15:16:00 <thetallguy1> Hah, I knew if I asked, then went back to look, I'd find it.
15:16:16 <ezyang_> oh hey, there are papers about contraction-free
15:16:25 <cmccann> shachaf, how so? lambdas aren't really distinct from any other kind of function in this kind of representation, I'd think
15:16:49 <rwbarton> The T-0010-BQH is an exemplary instance of part number T-0010-BQH. Interestingly, this one is indigo. Also, it is broken: it is (a T-0010-BQH missing a X-1623-GTO and a N-5065-AGS and a B-4292-LWV and a R-6678-FJZ) missing (a T-0010-BQH missing a X-1623-GTO and a X-1623-GTO and (a X-1623-GTO missing a T-0010-BQH)).
15:17:10 <shachaf> ezyang_: Watch out for the medical papers about pregnancy.
15:17:20 <cmccann> and if you implicitly treat logical connectives as commutative/associative you don't really need lambdas as such
15:17:23 <shachaf> cmccann: I mean for functions.
15:17:59 <cmccann> binding things to a name is mostly useful for avoiding stuff like the horrendous tuple-munging you get in Arrow-based or pointfree code
15:18:04 <rwbarton> sorry, this is linear logic not ordinary intuitionistic logic
15:18:58 <ezyang_> wait wait, is 'A → B ∨ C ⊢ (A → B) ∨ (A → C)' provable in intuitionistic logic...
15:19:08 <rwbarton> I don't know how easily you can pictorially represent "an X missing (a Y missing a Z)" though
15:19:17 <shachaf> ezyang_: Doesn't look provable.
15:19:26 <shachaf> You need the a before you know if it's Left or Right.
15:19:39 <ezyang_> ok, glad I'm not smoking crack
15:19:40 <dolio> ezyang_: No. That is the freshman's dream, as Ed calls it.
15:19:46 <shachaf> (You can do the other direction, though.)
15:19:47 <dolio> (A + B)^C = A^C + B^C.
15:20:02 <dolio> edwardk, that is. Not you.
15:20:18 <edwardk> heh
15:20:23 <cmccann> @djinn (a -> Either b c) -> Either (a -> b) (a -> c)
15:20:23 <lambdabot> -- f cannot be realized.
15:20:35 <hpc> (a -> b) = b^a
15:21:12 <hpc> er
15:21:14 <hpc> that was right
15:21:38 <hpc> and you just can't transform it in that direction
15:21:49 <hpc> @djinn Either (a -> b) (a -> c) -> (a -> Either b c)
15:21:49 <lambdabot> f a b =
15:21:50 <lambdabot>     case a of
15:21:50 <lambdabot>     Left c -> Left (c b)
15:21:50 <lambdabot>     Right d -> Right (d b)
15:21:50 <cmccann> freshman's dream is actually a well-known name for that non-identity, written algebraically
15:22:09 <edwardk> cmccann: exactly
15:22:51 <ddarius> It would be very convenient if it were true algebraically.
15:23:07 <qpfiffer> Hey guys, Haskell noob here. I'm working my way through project Euler and just came up with this for problem #2:
15:23:09 <qpfiffer> sum $ filter even $ takeWhile (< 4000000) (map fibonacci' [1,2..])
15:23:21 <qpfiffer> Good/bad?
15:23:37 <otters> bad
15:23:42 <otters> map fibonacci'?
15:23:45 <cmccann> does it give the right answer in a reasonable amount of time? :P
15:23:49 <otters> why doesn't it create an infinite list?
15:23:57 <ezyang_> Hmm, I wonder if I should (1) deploy this, (2) work on lambda term extraction, (3) work on the linear logic version
15:24:01 <otters> because that's like
15:24:07 <ddarius> Why aren't you using pencil and paper?
15:24:16 <qpfiffer> cmccann: Yes, Id say so
15:24:17 <otters> what is the time complexity of calculating each fibonacci number individually?
15:24:25 <rwbarton> the "sum $ filter even $ takeWhile (< 4000000)" part is good
15:24:26 <qpfiffer> otters: Lazy evaluation, I think
15:24:28 <ezyang_> ddarius: It's for people who are too lazy to pencil and paper...
15:24:45 <otters> qpfiffer: no, the point is, you can make Fibonacci numbers in a single computation
15:24:47 <otters> for want of a better word
15:25:08 <edwardk> ddarius: well, (x+y)^p does = x^p + y^p -- as long as your field (or ring i guess) has characteristic p  and p is prime iirc. =)
15:25:11 <rwbarton> perhaps fibonacci' uses Binet's formula, then it is good
15:25:12 <qpfiffer> otters: Ah, I see. Generate al ist of fibonacci instead of map
15:25:13 <rwbarton> :)
15:25:18 <otters> yes
15:25:27 <qpfiffer> rwbarton otters Cool, thanks for your input
15:25:28 <ddarius> edwardk: I know.  It's why GF(2) is nice.
15:25:33 <ddarius> (Among other things.)
15:25:35 <edwardk> exactly
15:26:01 <otters> qpfiffer: my personal favorite is let fibs@(t:fibs') = 1:t:zipWith (+) fibs fibs'
15:27:02 <rwbarton> bigger primes are better, lots of weird stuff happens when p = 2 :)
15:27:22 <ddarius> s/weird/wonderful/
15:30:41 <mm_freak_> rwbarton: what weird stuff?
15:31:15 <mm_freak_> you may consider it weird that 1 = -1, but that's all i can come up with =)
15:31:29 <startling> otters, woah, didn't know you could do patterns on the whole
15:31:32 <Cale> edwardk: Right, because p choose k is divisible by p for all 0 < k < p.
15:31:59 <edwardk> cale: yep
15:32:10 <rwbarton> the examples that come to mind all involve a fair amount of homological algebra or homotopy theory
15:33:00 <startling> > let fibs@(_:fs) = 1:1: zipWith (+) fibs fs in take 5 fibs
15:33:01 <lambdabot>   [1,1,2,3,5]
15:33:09 <startling> neat
15:33:58 <shachaf> tail is only mildly evil there, since the list is infinite.
15:34:12 <shachaf> If there was a stream type tail would hardly be evil at all.
15:34:44 <ddarius> It would be completely not evil.
15:35:07 <shachaf> Well, if by "evil" you mean "partial".
15:35:08 <mm_freak_> i really wonder why there is no stream type predefined with all the nice optimizations that [] has
15:35:39 <mm_freak_> "predefined" as in "part of the base library"
15:35:40 <shachaf> There are still many cases where pattern-matching on streams is nicer than head and tail.
15:35:44 <ddarius> shachaf: It's somewhat silly to have a stream type without tail.
15:35:56 <shachaf> Sure.
15:35:58 <startling> by "stream type", do you mean "list with at least one element"?
15:36:20 <mm_freak_> i couldn't bring myself to define Stream without head and tail
15:36:23 <shachaf> A stream is a list such that all its tails have at least one element. :-)
15:36:24 <mm_freak_> data Stream a = Stream { head :: a, tail :: Stream a }
15:36:31 <startling> mm_freak_, right
15:36:42 <shachaf> startling: That's very different from what you said.
15:37:05 <mm_freak_> also a very useful type:  newtype StreamT f a = StreamT (f (a, StreamT f a))
15:37:12 * cmccann still wants a Natural type more than streams. >:[
15:37:15 <startling> shachaf: oh, that's true
15:37:22 <startling> hmm
15:37:27 <mm_freak_> yet another useful type:  newtype Auto a b = Auto (a -> (b, Auto a b))
15:37:39 <startling> a list with at least infinity elements?
15:37:42 <mm_freak_> and the most useful type:  newtype Wire a b = Wire (a -> (Maybe b, Wire a b))
15:37:43 <mm_freak_> =)
15:37:51 <shachaf> mm_freak_: Remember data Foo t = forall a. Foo a (a -> a) (a -> t)?
15:37:59 <dolio> Streams are the largest type such that all values of the type have a head, and a tail that is also a stream.
15:38:02 <mm_freak_> shachaf: yeah
15:38:02 <shachaf> mm_freak_: That's yet another thing isomorphic to Stream. :-)
15:38:10 <mm_freak_> shachaf: i know (now) =)
15:38:39 <shachaf> Stream is actually nicer than the (Nat ->) I mentioned at the time.
15:39:08 <mm_freak_> shachaf: i wonder if there is a simpler way to prove such isomorphisms than to actually write conversion functions
15:39:37 <shachaf> mm_freak_: Writing conversion functions is hardly sufficient without proving them, anyway.
15:39:41 <mm_freak_> i remember a paper that did such proofs using equational reasoning
15:39:55 <mm_freak_> shachaf: i suppose they are proven, if they are total
15:40:05 <mm_freak_> you have to prove totality yourself, of course
15:40:14 <shachaf> mm_freak_: Not really.
15:40:37 <shachaf> foo :: Int -> Bool; foo _ = False; bar :: Bool -> Int; bar _ = 5
15:40:38 <dolio> Just prove that shachaf's type is a terminal stream coalgebra. Then they're isomorphic automatically.
15:40:39 <rwbarton> the composition could be a shift or something
15:40:56 <shachaf> Or did you mean in this specific case?
15:41:29 <shachaf> There are lots of cases where you care about isomorphisms that "type-checks + total" isn't enough to satisfy.
15:41:43 <mm_freak_> shachaf: oh, of course…  you have to show that f . g = id
15:41:53 <shachaf> Right, and g . f
15:56:35 <ddarius> An obvious solution to the initial algebra problem is: type Initial f = forall a. (f a -> a) -> a.  Dually, type Terminal f = exists a. (a, a -> f a).  type Foo t = exists a. (a, a -> (a,t)).
15:57:47 <ddarius> Now dolio's problem is reduced to just showing that they are using the same f.
16:16:24 <shachaf> @girl19
16:16:24 <lambdabot> is this a help channel for hackers-beginners?
16:20:47 <MostAwesomeDude> Is there a delightful incantation I can feed to cabal to tell it to install all the profiling libraries? I kind of forgot to set the flag long ago in the past, and now it's come back to bite me.
16:21:01 <shachaf> Nope.
16:21:13 <shachaf> Well, maybe cabal install world or something. But probably not.
16:21:20 <cmccann> does "reinstall everything with said flag set" count as magic?
16:21:21 <MostAwesomeDude> Hmmmm.
16:21:26 <cmccann> pretty sure there's a way to do that, at least.
16:21:32 <shachaf> ~/.cabal/world has a list of things you installed.
16:21:50 <MostAwesomeDude> I was kinda hoping for $ cabal install --reinstall --only-dependencies
16:21:59 <MostAwesomeDude> Except that doesn't work.
16:22:17 <rwbarton> what's --only-dependencies supposed to mean?
16:22:32 <hpc> rwbarton: install everything but the thing itself
16:22:39 <rwbarton> where's the thing
16:22:40 <shachaf> rwbarton: When you're in a directory containing a .cabal file, it'll install all its dependencies but not it.
16:22:42 <rwbarton> omitted I guess
16:22:45 <rwbarton> oh I see
16:22:51 <shachaf> I assume MostAwesomeDude wants to profile a specific program.
16:22:54 * rwbarton is never in a directory containing a .cabal file
16:23:05 <MostAwesomeDude> shachaf: Yep.
16:23:11 <shachaf> rwbarton only uses GHC for its type-chcker.
16:23:24 <MostAwesomeDude> I can appreciate that.
16:28:11 <jmcarthur> leave it to quickcheck to show me how bad of a programmer i really am
16:28:45 <MostAwesomeDude> Hey, related: How can I convince somebody to update their package on Hackage? I submitted a patch and haven't heard anything.
16:29:15 <antalsz> I just installed GHC 7.4.2 from Homebrew a couple days ago, and GHCi is segfaulting about 50% of the time when I try to start it up.  I don't think I've had any problems with GHC itself, but I can't quite tell.  Does anybody have any idea why this would be happening?
16:30:00 <Cale> antalsz: Why Homebrew?
16:30:35 <Cale> I seem to recall hearing about other people having problems like that which were solved by just installing GHC normally.
16:31:04 <antalsz> Cale: Why not?  :-)  I hadn't heard anything at the time, so I went with it because it seemed straightforward.
16:31:18 <Cale> http://www.haskell.org/ghc/download_ghc_7_4_2#macosxintel
16:31:28 <antalsz> But that's good to know, I can give it a shot manually
16:31:51 <antalsz> (My previous install from homebrew had worked fine *shrug*)
16:32:33 <antalsz> Thanks for the info/link
16:33:33 <Cale> It's been a while since I last used OS X, but the MacPorts version of GHC was never particularly well-supported, so I wouldn't have had high hopes for Homebrew either. The .pkg installers have basically always worked well though.
16:34:00 <janiczek> is there an easy way to overload Data.Ratio (%) operator so that it can work with its own Rational types too? http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ratio.html
16:34:14 <janiczek> so i could do 1 % (2 % 1) — == 1 % 2
16:34:25 <janiczek> --*
16:34:47 <janiczek> it seems to have a Integral constraint
16:34:56 <Cale> Use (/)
16:35:10 <Cale> > 1 / (2 / 1)
16:35:11 <lambdabot>   0.5
16:35:13 <Cale> > 1 / (2 / 1) :: Rational
16:35:14 <lambdabot>   1 % 2
16:35:30 <janiczek> > 1 / (3 / 1) :: Rational
16:35:31 <lambdabot>   1 % 3
16:35:33 <janiczek> hm ..
16:35:47 <janiczek> will that be safe with floating numbers and all that stuff?
16:35:54 <Cale> What do you mean?
16:36:00 <benmachine> all the division will be done with the Rational type
16:36:03 <Cale> If the type is Rational, then you don't have floating point.
16:36:18 <janiczek> well im concerned with (/)
16:36:29 <Cale> (/) doesn't convert to Double or anything like that
16:36:45 <Cale> > 37189402758930217589320178902374839107439 / 473812905723890157892301752389107523895071890 :: Rational
16:36:46 <lambdabot>   37189402758930217589320178902374839107439 % 4738129057238901578923017523891...
16:37:10 <benmachine> yeah, % is just for making a fraction when you have integers; dividing fractions is done with /
16:37:34 <janiczek> aha
16:38:04 <Cale> :t (/)
16:38:05 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:38:33 <Cale> You can see that it preserves whatever type of arguments you give it, and it ensures they have the same type.
16:38:50 <antalsz> Cale: Oh, I think I see the problem.  Homebrew fetches the GHC bindist (same URL as on the download page), but that's for 10.7 and I'm running 10.6.
16:38:58 <Fuuzetsu> :t lookup
16:38:59 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:39:01 <Cale> antalsz: ah
16:39:17 <janiczek> Cale, benmachine: thanks
16:40:57 <antalsz> So I suppose I should either go back to 7.2 or upgrade OS X
16:41:15 <hpaste> linux2342 pasted “getStatusR” at http://hpaste.org/74838
16:41:57 <jkff_> Hey folks. Can you point me to some really good comonad tutorials? Do they (comonads) have any "spectacular" applications? E.g. I consider parsers and asynchronous continuations to be spectacular examples of monads.
16:42:20 <shachaf> edwardk: This one's probably for you. :-)
16:42:32 <edwardk> sorry man, dinner =)
16:42:43 <jkff_> I specifically do NOT want a tutorial that concentrates on trivial examples, like if a monad tutorial showed me Maybe, IO and Either.
16:43:07 <jkff_> However, I found some slides about comonadic zippers and attribute grammars and that was a little too hardcore for me.
16:43:19 <Clint> i liked the blur example
16:43:20 <jkff_> I'm now reading http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html - is it good?
16:43:29 <jkff_> Oh yeah, it exactly contains the blur example
16:43:31 <edwardk> jkff: re spectacular applications, i use them in my parsers in scala because monad transformers suck in scala and they work well for tracking additional state. comonads are useful in defining lenses, cellular automata, dataflow programming
16:44:14 <jkff_> edwardk: Hm, for parsers? Can you point to a blogpost / article / code?
16:44:19 <edwardk> they are useful in stream processing, you can use a comonad for doing image manipulation, where each pass defines a single pixel of the output image, so its easy to do blur effects, etc.
16:44:31 <jkff_> I think I already understand intuitively how they can be useful for lenses
16:44:38 <jkff_> However I should probably implement this to really understand.
16:44:56 <edwardk> jkff_: i haven't written anything up. note the parser itself remains monadic. its just that when parsing i often want to track a bunch of things about currently open patterns, like what variables to close, etc.
16:45:17 <edwardk> tracking that in scala is hard, because you can't (nicely) make a monad transformer that tracks this additional context
16:45:38 <jkff_> Oh, I see
16:45:41 <edwardk> but you can use a semimonoidal comonad (ComonadApply) to hold onto the names you've bound and how to unbind them
16:46:02 <edwardk> (technically strong lax symmetric semimonoidal)
16:46:13 <jkff_> Is there a consensus on a "codo" notation?
16:46:28 <edwardk> jkff: dominic orchard defined a half-way decent one
16:46:38 <edwardk> thats the closest anyone gets
16:46:51 <jkff_> Thanks, found it
16:47:03 <hpc> edwardk: is it what i think it is?
16:47:03 <edwardk> in practice the usecases i have for comonads don't tend to require me to chain lots of actions
16:47:18 <edwardk> hpc: no idea what you are thinking. =)
16:47:54 <jkff_> Monads give us analogues of imperative control structures; is something co-similar true for comonads?
16:48:41 <edwardk> jkff_: think of comonads as redecorating a structure. they'll never change the number of 'a's in it. they'll just give you different perspectives on it, and stitch those together into a mosaic that is the new comonadic value.
16:48:51 <hpc> edwardk: double-checking the definition of Comonad, i actually have no idea either... :P
16:49:24 <jkff_> edwardk: That makes sense. Is it actually true for all of them? (I see how it's true for the "pointed array" comonad)
16:49:29 <edwardk> jkff_: the cellular automata or blurring example is probably as close to canonical as they get
16:49:40 <edwardk> jkff_: yeah, its true for all of them
16:49:48 <jkff_> Cool! Is there a "mother of all comonads" just as Cont is the mother of all monads?
16:50:03 <jkff_> Or maybe all comonads are the mother of something...
16:50:12 <hpc> isn't Cont a comonad?
16:50:16 <edwardk> well, the adjunction that gives rise to cont gives you a comonad… its just in hask-op ;)
16:50:32 <edwardk> so cont is also the mother of all comonads as it were. just in the wrong category
16:50:41 <jkff_> Hm, nice
16:50:49 <jkff_> That will take some time to digest.
16:51:00 <edwardk> i use that fact to make a comonad-to-monad-transformer
16:51:15 <edwardk> every comonad in haskell gives rise not only to a monad, but a monad-transformer
16:51:20 <edwardk> i talk about this on my blog
16:52:02 <edwardk> brb, like i said, food ;)
16:53:01 <cmccann> jkff_, everything sigfpe writes is good as far as I recall
16:53:17 <jkff_> cmccann: can't disagree with that :)
16:53:30 <cmccann> also, edwardk's blog has lots of interesting examples but might be a bit much to digest at first
16:54:29 <jkff_> Oh well, by the way. Guess whom we interviewed on Friday for fprog.ru! (the russian functional programming journal)
16:54:33 <edwardk> you can also spend some time playing with the comonad-transformers package
16:54:43 <jkff_> (it's completely offtopic, I just can't resist to show off :) )
16:55:13 <BMeph> jkff_: Oleg Kiselyov!
16:55:24 <jkff_> BMeph: You knew!
16:55:32 <hpc> jkff_: it wasn't hard to guess :P
16:55:33 <cmccann> haha, nice
16:55:44 <BMeph> jkff_: No, I'm just a ->very<- good guesser. ;)
16:56:13 <jkff_> BMeph: You really are. Btw this ->very<- now looks like a pointed array comonad to me...
16:57:24 <jkff_> Ok, back to blurs.
17:00:08 <Fuuzetsu> :t maybe
17:00:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:00:51 <benmachine> @. djinn type maybe
17:00:52 <lambdabot> f a b c =
17:00:52 <lambdabot>     case c of
17:00:52 <lambdabot>     Nothing -> a
17:00:52 <lambdabot>     Just d -> b d
17:10:03 <john_r_watson> > logBase 10 1000
17:10:04 <lambdabot>   2.9999999999999996
17:10:11 <john_r_watson> > logBase 10 100
17:10:12 <lambdabot>   2.0
17:10:16 <john_r_watson> > logBase 10 10
17:10:17 <lambdabot>   1.0
17:10:23 <john_r_watson> > logBase 10 10000
17:10:25 <lambdabot>   4.0
17:10:34 <john_r_watson> why does logBase hate 1000?
17:11:06 <latro`a> it's not 1000 in particular; I'm sure it has something to do with the floating point representation of 1000 being slightly less accurate
17:11:17 <latro`a> but that happens in various places
17:11:19 <twanvl_> john_r_watson: ?
17:11:28 <latro`a> for example the floating point representation of 1/3 is "unusually" accurate
17:11:28 <john_r_watson> latro`a: yeah - just unfortunate
17:11:28 <jkff_> > map (logBase 10) [10,100,1000,10000,100000,1000000,10000000]
17:11:29 <lambdabot>   [1.0,2.0,2.9999999999999996,4.0,5.0,5.999999999999999,7.0]
17:11:52 <latro`a> > 1/3
17:11:53 <lambdabot>   0.3333333333333333
17:12:00 <latro`a> > 1/5
17:12:01 <lambdabot>   0.2
17:12:03 <latro`a> huh
17:12:15 <john_r_watson> > map ((logBase 10) . (10 **)) [1..9]
17:12:17 <lambdabot>   [1.0,2.0,2.9999999999999996,4.0,5.0,5.999999999999999,7.0,8.0,8.99999999999...
17:12:36 <jkff_> > map (logBase 3) [3,9,27,81,243,729,2187,6561]
17:12:37 <lambdabot>   [1.0,2.0,3.0,4.0,4.999999999999999,6.0,7.0,8.0]
17:23:19 <shachaf> > map (logBase 3 . (3^)) [1..]
17:23:21 <lambdabot>   [1.0,2.0,3.0,4.0,4.999999999999999,6.0,7.0,8.0,9.0,9.999999999999998,11.0,1...
17:23:48 <shachaf> Oh, you had that above.
17:24:23 <daniel_-> is there any good libraries for haskell for http requests with post/put/delete/get etc.
17:24:42 <hpc> @hoogle HTTP
17:24:43 <lambdabot> package HTTP
17:24:43 <lambdabot> package http-date
17:24:43 <lambdabot> package http-enumerator
17:24:54 <jkff_> http://hackage.haskell.org/package/curl-1.3.7
17:25:00 <hpc> curl is good
17:25:03 <jkff_> Never used it, but it's written by dons and it's curl
17:26:06 <benmachine> http-conduit is supposed to be good, I think
17:26:36 <luite> and you don't need foreign libs
17:27:06 <KirinDave> luite: Could I ask you another yesod question?
17:27:23 <latro`a> ...um
17:27:47 <latro`a> > filter (\(x,y) -> x /= y) $ zip [1..50] $ map (logBase 3 . (3^)) [1..50]
17:27:49 <lambdabot>   [(5.0,4.999999999999999),(10.0,9.999999999999998),(13.0,12.999999999999998)...
17:27:53 <latro`a> um...
17:27:57 <latro`a> in my ghci I get []
17:28:02 * latro`a scratches head
17:28:18 <latro`a> :t filter (\(x,y) -> x /= y) $ zip [1..50] $ map (logBase 3 . (3^)) [1..50]
17:28:19 <lambdabot> forall b. (Floating b, Enum b) => [(b, b)]
17:28:32 <latro`a> same on my ghci, hrm
17:28:45 <latro`a> any idea what's doing that?
17:29:26 <latro`a> > filter (\(x,y) -> x /= y) $ zip [1..50] $ map (logBase 3 . (3^)) [1..50] :: Double
17:29:27 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
17:29:28 <lambdabot>         against inferred ty...
17:29:29 <latro`a> err
17:29:33 <latro`a> > filter (\(x,y) -> x /= y) $ zip [1..50] $ map (logBase 3 . (3^)) [1..50] :: [Double]
17:29:34 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
17:29:34 <lambdabot>         against inferred ty...
17:29:38 <latro`a> ....
17:29:49 <latro`a> > (filter (\(x,y) -> x /= y) $ zip [1..50] $ map (logBase 3 . (3^)) [1..50]) :: [Double]
17:29:50 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
17:29:50 <lambdabot>         against inferred ty...
17:29:54 <latro`a> oh, duh
17:29:59 <latro`a> > (filter (\(x,y) -> x /= y) $ zip [1..50] $ map (logBase 3 . (3^)) [1..50]) :: [(Double,Double)]
17:30:01 <lambdabot>   [(5.0,4.999999999999999),(10.0,9.999999999999998),(13.0,12.999999999999998)...
17:30:36 <latro`a> still [] on my end, that's weird
17:31:36 <luite> KirinDave: you can try ;p
17:31:52 <geekosaur> are you on the same platform?
17:32:05 <latro`a> might be 32 bit/64 bit
17:32:09 <latro`a> I'm on a 32 bit machine
17:32:21 <geekosaur> even 32 vs. 64 might matter, yeh, but I was thinking amd vs. intel implementation or even arm vs. x86
17:32:23 <latro`a> (old, old windows install)
17:32:52 <rwbarton> or compiled vs. interpreted
17:33:18 <KirinDave> luite: yesod: readProcess: runghc "--numeric-version" "0"
17:33:27 <KirinDave> luite: I've yet to to get Yesod to actually run.
17:33:58 <KirinDave> luite: I'm kinda surprised how crazy hard it seems to be. Just building it, I had to ditch my entire haskell installation and start from scratch with platform.
17:35:16 <luite> KirinDave: hm, what's that message? when do you get it?
17:35:25 <KirinDave> luite: "yesod devel"
17:35:34 <KirinDave> luite: Or "yesod --dev devel"
17:35:34 <KirinDave> I tried both
17:35:48 <KirinDave> Googling it shows a single random github patchset.
17:37:59 <luite> KirinDave: what does it say if you run # runghc --numeric-version 0
17:38:17 <KirinDave> luite: Nothing.
17:38:21 <KirinDave> Should it say something?
17:38:26 <luite> yes the ghc version
17:38:43 <KirinDave> ghc --version works.
17:38:54 <KirinDave> So.
17:38:59 <luite> can you check if runghc and ghc are from the same ghc installation?
17:39:29 <luite> KirinDave: the 0 is important btw
17:40:05 <dmwit> ?where rwh
17:40:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:40:11 <KirinDave> Hmm
17:40:39 <KirinDave> Man
17:40:41 <KirinDave> So close
17:40:46 <KirinDave> it started up then immediately crashed
17:40:51 <KirinDave> Devel application launched: http://localhost:3000
17:40:52 <KirinDave> Exit code: ExitFailure 11
17:40:53 <luite> segfault?
17:41:02 <KirinDave> I wonder if this computer is just screwed for haskell.
17:41:05 <luite> let me guess, you have mac os x and ghc 7.4.x or 7.0.x?
17:41:08 <KirinDave> It's a really finnicky distribution.
17:41:10 <KirinDave> Yes.
17:41:15 <luite> and you installed a 64 bit ghc
17:41:25 <KirinDave> I used platform, pretty sure.
17:41:36 <KirinDave> But I can't imagine choosing 32-bit.
17:41:39 <luite> right in that case it crashes, known bug
17:41:46 <KirinDave> So. Can't use it period.
17:42:02 <luite> you can use 7.4.x 32 bit, or 7.6.x 64 bit
17:42:16 <luite> 32 bit also works with 7.6
17:42:28 <KirinDave> Would yesod even work in the 7.6.* ecosystem?
17:42:39 <KirinDave> I thought it was really fresh.
17:42:42 <luite> yeah michael updated it recently
17:42:54 <KirinDave> I'd have to make sure that hakyll does too.
17:42:55 <luite> latest yesod-platform should work
17:43:25 <KirinDave> luite: Given the age of 7.4.1, I assume that it's not something fixable.
17:44:13 <luite> KirinDave: this crash? i don't think another 7.4 release is planned, but if you really want to keep using 7.4, you can apply the patch manually and compile your own
17:44:40 <KirinDave> Ah. Thanks, I'll consider what I can do to fix.
17:45:01 <luite> see ghc trac ticket #7040, i used the patch with 7.4.2 for a while and it also works there
17:45:42 <luite> KirinDave: if you install happy first, plain ghc, without platform, should also work fine
17:45:56 <luite> if you don't have happy, you'll get a problem with language-javascript
17:46:00 <KirinDave> luite: Ty for the advice.
17:46:06 <KirinDave> Yeah I wrote down the steps as I did them. :)
17:46:09 <KirinDave> Ty for the reminder tho.
17:53:22 <colluphid> can anyone tell me what '.|.' means?
17:53:29 <colluphid>  attrmask = cWOverrideRedirect .|. cWBorderPixel .|. cWBackPixel
17:53:38 <colluphid> in that context?
17:53:41 <MostAwesomeDude> :t (.|.)
17:53:42 <lambdabot> forall a. (Bits a) => a -> a -> a
17:53:46 <twanvl_> bitwise or
17:53:47 <MostAwesomeDude> Probably bitwise OR.
17:55:09 <colluphid> MostAwesome: thanks that looks like it
17:55:22 <SLi> I have a feeling that this may actually not be possible in Haskell's type system, but anyway: Since it's possible to have something like class BoolFun t where { applyBool :: (Bool -> t) -> Bool -> t; toBool :: Maybe Bool }, and to have instance BoolFun Bool and instance BoolFun t => BoolFun (Bool -> t), is it possible to write using these a function of type (Bool -> Bool -> ... -> Bool) -> Bool which, say, repeatedly applies ...
17:55:28 <SLi> ... (via applyBool) the function to, say, True, until a simple Bool is left?
17:56:29 <SLi> That would effectively create a recursion on the type of the parameter.
17:57:32 <SLi> The type of that function would be BoolFun t => t -> Bool. But is it possible to actually write such a function :)
17:57:45 <MostAwesomeDude> SLi: Hm. Why do you want this?
17:58:52 <SLi> MostAwesomeDude, well, a simple scenario would be printing a truth table (essentially I'm analyzing boolean functions and generating minimized expressions for them, but printing a truth table is a simpler task :)
17:59:11 <john_r_watson> pl (\n -> (a n) && (b n) && (c n))
17:59:15 <john_r_watson> @pl (\n -> (a n) && (b n) && (c n))
17:59:15 <lambdabot> liftM2 (&&) a (liftM2 (&&) b c)
18:00:45 <latro`a> I feel like you should be able to do that with a foldr
18:01:16 <latro`a> @pl \n -> all ($ n) [a,b,c]
18:01:16 <lambdabot> flip all [a, b, c] . flip id
18:01:22 <latro`a> *sigh*
18:01:55 <latro`a> anyway, john_r_watson, you meant something like that, I think
18:01:59 <john_r_watson> latro`a: yeah
18:02:03 <Nereid> :t all
18:02:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:02:26 <latro`a> :t flip id
18:02:27 <lambdabot> forall a b. a -> (a -> b) -> b
18:02:31 <Nereid> :t all id
18:02:32 <lambdabot> [Bool] -> Bool
18:02:35 <Nereid> :t and
18:02:36 <lambdabot> [Bool] -> Bool
18:02:38 <Nereid> right.
18:02:54 <Nereid> :t and .: map
18:02:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:03:00 <latro`a> yes, as usual there are special cases of higher order functions where you plug in id :p
18:03:33 <Nereid> is there a version of and for Foldable?
18:03:44 <Nereid> of course there is.
18:03:46 <BMeph> @hoogle and
18:03:46 <lambdabot> Prelude and :: [Bool] -> Bool
18:03:46 <lambdabot> Data.List and :: [Bool] -> Bool
18:03:46 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
18:03:55 <latro`a> seems trivial that there would be, yeah
18:04:03 <latro`a> since it's just foldr (&&) True
18:04:22 <Nereid> it's defined using foldMap, heh.
18:04:32 <latro`a> eh, right, right, but still
18:04:34 <latro`a> it's just a right fold
18:04:37 <latro`a> is the point
18:04:38 <Nereid> yeah
18:04:58 <Nereid> why isn't this stuff in the Prelude? :v
18:05:09 <latro`a> use one of the kajillion alternative preludes
18:05:15 <Nereid> true
18:05:19 <byorgey> well, we can't put *everything* in the Prelude
18:05:29 <latro`a> module Prelude where
18:05:35 <latro`a> import ALLTHETHINGS
18:05:38 <Nereid> :D
18:05:41 <latro`a> <EOF>
18:15:53 <Ralith> bos: so, I've got a pretty far along wrapper package; would you be interested in merging that?
18:18:28 <Ralith> it's not complete, but it's got most of the important stuff (my current backend is working through it); I think it'd work best to let it be fleshed out fully on an as-needed basis
18:19:13 <SLi> Turns out it's at least possible to write a function that takes as parameter any function of type Bool -> Bool -> ... -> Bool and returns the number of Bools in that list.
18:19:34 <SLi> (Which is of course a compile time constant)
18:20:45 <mm_freak_> sure it's possible
18:26:28 <john_r_watson> @pl (\p -> (count p, p))
18:26:28 <lambdabot> (,) =<< count
18:26:53 <john_r_watson> functions as monads FTW
18:26:59 <SLi> Ah, I think I figured out how to write a function to repeatedly evaluate a function of type Bool -> Bool -> ... -> Bool until a simple Bool is left. :) The trick is to have class BoolFun f where applyBools :: t -> [Bool] -> Bool, and then we can have instance BoolFun Bool and instance BoolFun u => BoolFun (Bool -> u).
18:29:15 <latro`a> you can actually find a post just like that on stackoverflow
18:29:20 <latro`a> I think they call the class Predicate
18:30:17 <byorgey> SLi: yep.  A similar trick is used in the Text.Printf library to define a printf function with a variable number of arguments.
18:30:47 <SLi> byorgey, ah, makes sense.
18:30:51 <latro`a> essentially they define a class Predicate with a function complement :: p -> p, then they have instance Predicate Bool where complement = not; instance Predicate p => Predicate (a->p) where complement = (complement .)
18:31:06 <latro`a> also printf is kinda disturbing >.<
18:31:10 <SLi> Actually I've wondered about how that is defined, but it didn't occur to me that this is the same problem :)
18:40:41 <benmachine> printf is fun because it's haskell98
18:40:49 <benmachine> doesn't even use FlexibleInstances
18:43:11 <dncr> do ppl end up using a lot a generic-programming things at once?
18:44:02 <dncr> is it even possible to use "deriving Data" for SYB and then also the TH "$(derive ..)" to get SYB.WithClass's Data?
18:44:13 <dncr> two different Datas
18:49:56 <dmwit> Hm, what methods do I have of controlling what goes in cabal's Paths_* module?
18:52:35 * hackagebot accelerate-cuda 0.12.1.2 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.12.1.2 (TrevorMcDonell)
18:52:58 <dmwit> Specifically, what do I have to do for it to be GHC-7.6-buildable?
18:53:44 <hpaste> dmwit pasted “cabal, Paths_foo, and GHC 7.6” at http://hpaste.org/74839
18:54:17 <JoeyA> dmwit: What if you cabal clean first?
18:54:34 <dmwit> That is from a clean directory.
18:55:29 <JoeyA> So Paths_ modules are broken in GHC 7.6?
18:55:32 <JoeyA> Or just this one?
18:55:44 <dmwit> I don't know. Can you name another package that uses it for me to test?
18:57:53 <JoeyA> Maybe I should write an acme module that uses Paths_
18:59:21 <byorgey> dmwit: what version of cabal are you using?
18:59:41 <dmwit> cabal-install 0.10.2, Cabal 1.10.2
18:59:51 <dmwit> newer cabal-install's don't build with 7.6 =P
19:00:10 <byorgey> I think you are hosed
19:00:18 <byorgey> ;)
19:00:20 <dmwit> =D
19:00:32 <byorgey> I think the thing with 'catch' has been fixed in cabal-install HEAD
19:00:46 <byorgey> and it sounds like an 0.16 release is forthcoming shortly
19:00:55 <dmwit> alright
19:00:57 <dmwit> Thanks.
19:01:06 <rwbarton> maybe your distro includes a newer-but-not-too-new cabal-install?
19:01:56 <rwbarton> I mean I assume someone somewhere is successfully using cabal-install on ghc 7.6
19:06:00 <dmwit> urgh, ignoring the dependencies in ./*.cabal when the version in ./*.cabal matches something in cabal's cache is beyond confusing
19:14:16 <Fuuzetsu> > evaluate "a"
19:14:17 <lambdabot>   Not in scope: `evaluate'
19:14:53 <dmwit> sigh
19:19:27 <marcot> Hi.  What does SYSTEM means in profiling by retainer (-hr)?
19:33:44 <kallisti> @hoogle (<.>)
19:33:44 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
19:33:44 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
19:37:36 * hackagebot Elm 0.4.0 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.4.0 (EvanCzaplicki)
19:52:02 <pharaun> do we have a RIO - read only IO monad, if not, all i need to do is create one that exports only the reading functions in the IO ?
19:52:27 <johnw> ReaderT a IO b
19:52:36 <johnw> oh, wait
19:52:42 <johnw> you want an IO that allows no changes
19:52:46 <pharaun> yeah
19:52:58 <pharaun> just so i can be able to claim that X section of the program is read only
19:53:04 <johnw> you could write another Monad
19:53:12 <johnw> and just export the reading functions across
19:53:16 <pharaun> so i would basically be ... yeah
19:53:27 <JoeyA> You don't even need to define a type.
19:53:41 <JoeyA> class MonadRIO m where readFile :: ...
19:53:42 <pharaun> is this a good thing to do or? I'm just thinking that it would be nice from a type pov to prove/define a read only io
19:53:57 <JoeyA> then instance MonadRIO IO where readFile = Prelude.readFile; ...
19:54:26 <JoeyA> err, class Monad m => MonadRIO m
19:54:55 <JoeyA> Then: foo :: MonadRIO m => FilePath -> m String; foo = ...
19:55:28 <JoeyA> Even though foo is instantiated with IO, its type guarantees that it will only perform the actions listed in the MonadRIO class.
19:56:06 <johnw> neat try, JoeyA
19:56:09 <johnw> trick
19:56:09 <JoeyA> pharaun: Well, hGetLine, for example, is not read-only, since it modifies the state of the Handle.
19:56:30 <pharaun> JoeyA: ByteString hGet?
19:56:45 <JoeyA> If it advances the stream position, it's a modification.
19:56:45 <ddarius> Reading memory is, in general, not read-only.
19:56:56 <pharaun> i'm just trying to define/figure out how to limit the scope of IO action
19:57:11 <JoeyA> pharaun: What's the bigger picture?
19:57:35 <pharaun> a file hasher, i give it a list of paths
19:57:46 <nu11ptr> anybody want to answer a quick q on state monad?
19:57:48 <ddarius> Really this is just a naming thing.  JoeyA's approach will work with a variety of restrictions and their combinations.
19:57:48 <JoeyA> Though I suppose "What's the bigger picture" is a warning sign that modularity is about to be broken.
19:57:50 <pharaun> and it hashes the file and go into the directory's children and hash those file
19:58:16 <pharaun> and it seems to make sense to restrict that part of the code base to a read only io of some form
19:58:25 <pharaun> beacuse it shouldn't be like opening a file and writing something for ex
19:58:39 <pharaun> the fact that its in IO gives it the ability to do just that
19:58:56 <JoeyA> pharaun: You could just define a monad class like I described, so you can list exactly what actions the code is allowed to perform.
19:59:03 <JoeyA> You could even use this for mocking, for example.
19:59:18 <pharaun> JoeyA: yeah i was starting to wonder how i was going to test some of these IO related submodules
19:59:21 <ddarius> Yes, this would be convenient/useful for more than just restricting the code.
19:59:36 <pharaun> so if i can do this then mock out the IO part and use that for testing, even better
19:59:46 <ddarius> It would also allow you to seamlessly generalize to monad transformer stacks or other non-IO monads.
20:00:49 <nu11ptr> http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Introducing_State
20:00:58 <nu11ptr> got a quick q on the 'rollDie' function
20:01:02 <pharaun> JoeyA: ddarius thanks :)
20:01:16 <johnw> it's similar the "roll, play dead" command humans give to dogs
20:01:19 <ddarius> It would be extremely useful to factor various IO operations into various classes and have many functions written in terms of these methods rather than directly against their archetypical IO instantiations.
20:01:40 <nu11ptr> first line has a "get", but the function takes zero params - how does 'get' return the state from the monad when it isn't passed into the function?
20:01:49 <pharaun> ddarius: i was hoping to eventually do that, like haveing NIO (network io), (rio) read only io, etc
20:02:14 <cmccann> an approach I am somewhat fond of is to have no class constraint other than Monad itself, and instead pass in arguments (or use ReaderT) to provide appropriate operations.
20:02:14 <pharaun> so i can better isolate parts of the code and take better advantage of monad stack/transformers
20:02:39 <cmccann> that restricts such code to the operations you hand it at run time, as well as making it easier to swap out the choice of monad for e.g. testing purposes.
20:03:01 * ddarius would be perfectly happy with that too.
20:03:14 <ddarius> The real issue we have is recreating all the IO-only libraries.
20:03:37 <ddarius> @google "object capabilities"
20:03:38 <lambdabot> http://en.wikipedia.org/wiki/Object-capability_model
20:03:38 <lambdabot> Title: Object-capability model - Wikipedia, the free encyclopedia
20:04:02 <pharaun> it seems like breaking down the IO monad into smaller types is a better thing?
20:04:24 <ddarius> @hackage IOSpec
20:04:25 <lambdabot> http://hackage.haskell.org/package/IOSpec
20:04:43 <pharaun> ooo nice
20:05:21 <hpaste> “Joey Adams” pasted “Using a monad class to restrict what an action may do” at http://hpaste.org/74840
20:05:34 <johnw> huh; what's the use case for IOSpec?
20:05:50 <pharaun> testing?
20:06:04 <johnw> that's a thought...
20:06:12 <ddarius> Debugging as well.
20:06:18 <johnw> debugging how?
20:06:50 <JoeyA> pharaun: You'll probably want to tweak it, but my paste is a simple example of using a monad class to restrict what an action can do, and enable mocking later on.
20:07:02 <ddarius> You can step through the IO actions and print out the entire "state" at each step if you wanted.
20:07:12 <JoeyA> The last action is pretty interesting: yield :: Entry -> m ()
20:07:18 <johnw> ddarius: that's very cool; do you have example of using it to do so?
20:07:27 <JoeyA> How that's implemented is up in the air.
20:07:36 <johnw> i could _really_ use that for the next phase of gitlib's debugging
20:07:37 <ddarius> johnw: No, but I imagine they have an example of doing such things.
20:08:13 <pharaun> JoeyA: that is where its actually computing it?
20:08:37 <johnw> i find such an example not
20:08:46 <johnw> would love to see an article on that
20:08:47 <JoeyA> pharaun: What do you mean?
20:08:55 <ddarius> There's a paper on it.
20:08:55 <johnw> "Debugging effects with IOSpec, by JoeyA"
20:08:58 <johnw> ooh
20:08:59 <johnw> where?
20:09:12 <JoeyA> I don't know anything about IOSpec
20:09:13 <johnw> @google haskell IOSpec
20:09:14 <lambdabot> http://hackage.haskell.org/package/IOSpec
20:09:14 <lambdabot> Title: HackageDB: IOSpec-0.2.5
20:09:23 <pharaun> hehe
20:09:47 <johnw> "IoSpec - A test suite specification of the Io Programming Language."
20:10:00 <johnw> "Iospec. A simple behaviour driven development (BDD) framework for testing Io code. "
20:10:12 <ddarius> @google IOSpec Haskell filetype:pdf
20:10:14 <lambdabot> http://code.haskell.org/~byorgey/code/hwn/archives/20070427.pdf
20:10:14 <lambdabot> Title: Haskell Weekly News
20:10:19 <johnw> oh wow
20:10:25 <johnw> my goolge fu just doubled
20:10:53 <rwbarton> oh neat, I just wanted that earlier today
20:11:14 <JoeyA> pharaun: But a nice thing about the monad class approach is, you don't have to worry about defining and stacking an ugly monad up front.
20:11:21 <ddarius> @google "Beauty in the Beast" Swierstra
20:11:23 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.5377&rep=rep1&type=pdf
20:11:23 <lambdabot> Title: Beauty in the Beast
20:11:33 <JoeyA> Just put together a shopping list of what you need, and implement the instance somewhere else.
20:11:40 <pharaun> aha ;)
20:11:47 <pharaun> :) that's awesome
20:11:58 <pharaun> i need to work more on my monad/transformer skill
20:13:12 <JoeyA> If you want, you can implement several different "shopping list" monad classes, and have one god monad implement all of them.
20:13:28 <JoeyA> Monotheistic programming
20:13:37 <pharaun> xmonad, and a few other project have a god monad plus couple of submonad i think
20:13:47 <pharaun> was looking at their source for that bit
20:14:09 <JoeyA> Well, the downside is, sometimes you want certain effects for the short term
20:14:10 <ddarius> Clean has a pretty clean approach for these sort of things.
20:14:28 <ddarius> JoeyA: The other downside is sometimes certain effects are implementation details.
20:14:31 <johnw> sadly, IOSpec is too sparsely documented for me to make sense of it
20:14:47 <johnw> my sample code fails with a type I've no clue how to solve
20:15:03 <johnw> No instance for (Teletype :<: f0)
20:15:22 <ddarius> Did you look at the "several well-documented examples included with the source distribution"?
20:15:28 <johnw> oh, no
20:15:37 <johnw> i never even think of the source distribution
20:15:38 <JoeyA> ddarius: What do you mean?
20:15:39 <johnw> thanks for the pointer
20:15:58 <JoeyA> (re implementation details)
20:16:08 <ddarius> johnw: I was quoting the package description blurb.
20:17:00 <johnw> wow
20:17:01 <ddarius> JoeyA: I may use some concurrency or mutable variables internally that aren't relevant to my users.
20:17:09 * johnw slaps self with a trout
20:18:47 <JoeyA> ddarius: So you don't want to end up with mutable references showing up in your exposed API, simply because your code needs them internally?
20:19:15 <JoeyA> (as seen in older versions of conduit)
20:19:51 <JoeyA> err, mutable reference functions
20:23:08 <JoeyA> "<ddarius> JoeyA: The other downside is sometimes certain effects are implementation details."  Another example might be Data.Map, where most functions need Ord while some do not.
20:23:12 <JoeyA> :t Data.Map.empty
20:23:13 <lambdabot> forall k a. M.Map k a
20:23:20 <ddarius> JoeyA: Something like what you first said.
20:23:53 <ddarius> That said, I'm more keen on making such things explicit and not allowing an "escape hatch".  See my earlier reference to object capabilities.
20:24:05 <JoeyA> Though I suppose this is not exposing an implementation detail, since empty is not given any objects to compare.
20:26:08 <JoeyA> How does MonadHash m => FilePath -> m () have an "escape hatch" ?
20:26:26 <JoeyA> Granted, the MonadHash class has to list what operations are allowed.
20:26:39 <ddarius> JoeyA: It doesn't.  I'm saying I would prefer this in spite of arguments about exposing "implementation details".
20:26:42 <JoeyA> (being able to subclass typeclasses in Haskell helps)
20:26:59 <JoeyA> oh
20:27:42 <JoeyA> Well, in the face of concurrency and asynchronous exceptions, mutable references can very easily become an external concern.
20:27:50 * ddarius should make something like ST only for concurrency.
20:28:29 <JoeyA> You mean like STM?
20:28:32 <ddarius> No.
20:29:01 <JoeyA> So a parallel ST?
20:29:29 <ddarius> A concurrent ST except it would probably be restricted in the type of variables it had.
20:30:50 <shachaf> Do you mean something deterministic?
20:30:55 <ddarius> Probably.
20:31:14 <dmwit> There are IVars.
20:31:23 <ddarius> It'd probably have to be deterministic to guarantee referential transparency.
20:31:27 <shachaf> monad-par?
20:31:49 <ddarius> I haven't looked at monad-par, but I'm pretty sure it's not what I'm thinking of.
20:32:29 <ddarius> Definitely not what I'm thinking of.
20:33:51 <sordina> Hey guys. I'm trying to compile Agda with ghc 7.6.1, but I'm getting some odd error about a bad interface file in template haskell.
20:34:09 * shachaf wonders what deterministic concurrency would be.
20:34:24 <sordina>     Bad interface file: /Users/lyndon/.cabal/lib/template-haskell-2.7.0.0/ghc-7.6.1/Language/Haskell/TH.hi
20:34:26 <sordina>         Something is amiss; requested module  template-haskell-2.7.0.0:Language.Haskell.TH differs from name found in the interface file template-haskell:Language.Haskell.TH
20:34:31 <ddarius> @google "declarative concurrency"
20:34:32 <lambdabot> http://c2.com/cgi/wiki?DeclarativeConcurrency
20:34:32 <lambdabot> Title: Declarative Concurrency
20:34:39 <sordina> Has anyone encountered something like this before?
20:37:12 <ddarius> Argh.
20:37:20 * ddarius wants a synchronous zip for pipes.
20:47:02 * ddarius starts envisioning a DAG monoid-based fusion-y thing.  Something like finger-trees for DAGs.
20:50:26 <johnw> ddarius: I could use that for my gitlib perhaps
20:50:44 <pharaun> heh
20:52:38 * hackagebot stylish-haskell 0.5.0.2 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.0.2 (JasperVanDerJeugt)
20:56:24 <startling> would it be evil to break the lens laws for an "asList" lens for Data.Map ?
20:56:59 <startling> or should that be a traversal or something?
20:57:08 <dmwit> illegal things are often also evil
20:57:35 * shachaf doubts that.
20:57:55 <pharaun> its illegal to speed
20:59:08 <shachaf> NO PERFORMANCE OPTIMIZATIONS BEYOND THIS POINT
21:02:21 <JoeyA> startling: Well, if you do, document the instance, like they do for the ArrowLoop instance of Kleisli.
21:02:48 <JoeyA> -- | You can document instances with Haddock like this.
21:02:51 <JoeyA> instance ...
21:04:22 <zzing> Does the generalization of map, always apply a function over a container's elements, or is it more simply a generalization that transforms the container without necessarily touching the elements?
21:05:14 <JoeyA> Which generalization?
21:05:19 <JoeyA> :t map
21:05:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:05:27 <zzing> fmap
21:05:34 <zzing> :t fmap
21:05:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:05:37 <shachaf> fmap isn't (only) for containers.
21:05:45 <shachaf> In fact most functors aren't containers.
21:06:01 <zzing> I am using container in the very loosest sense
21:06:14 <JoeyA> Yes, fmap :: (String -> b) -> IO String -> IO b  touches the String inside of IO String.
21:06:44 <shachaf> The sense that means "functor"?
21:06:56 <shachaf> I don't know what an "element" is. :-)
21:07:06 <zzing> hmm, I am not sure I have the vocabulary to describe this.
21:07:23 <dmwit> fmap is not allowed to change the structure of the thing it's acting on.
21:07:41 <dmwit> You have your intuition correct, despite all the pedantry in the room.
21:08:05 <JoeyA> @quote dmwit "You have your intuition correct, despite all the pedantry in the room."
21:08:05 <lambdabot> No quotes match. Where did you learn to type?
21:08:09 <JoeyA> @remember dmwit "You have your intuition correct, despite all the pedantry in the room."
21:08:09 <lambdabot> Done.
21:08:10 <shachaf> I didn't see that question anywhere.
21:08:16 <shachaf> @forget dmwit "You have your intuition correct, despite all the pedantry in the room."
21:08:16 <lambdabot> Done.
21:08:20 <JoeyA> :(
21:08:21 <shachaf> @remember dmwit You have your intuition correct, despite all the pedantry in the room.
21:08:21 <lambdabot> It is forever etched in my memory.
21:08:29 <JoeyA> oh
21:08:52 <startling> lambdabot: forever???
21:09:02 <JoeyA> @quote forever
21:09:03 <lambdabot> kmc says: commenting on proggit is like one of those video games where enemies come at you in waves forever
21:09:06 <JoeyA> @quote forever
21:09:06 <lambdabot> Loriel says: I will forever feel funny talking about C++ because I cannot say 'functor' to mean 'object with operator()' anymore without feeling ridiculous. Thanks, Haskell!
21:09:08 <JoeyA> nvm
21:09:19 <shachaf> zzing: Does knowing that "fmap id x" is the same as "x" help?
21:09:44 <zzing> shachaf, I would accept that as an axiom.
21:10:14 <startling> zzing, it's a functor law
21:10:16 <zzing> I just found this one: http://www.haskellforall.com/2012/08/the-category-design-pattern.html  and its successor post. I do find my knowledge and intuition lacking. So I need to fit some of this back into my schedule to get better at this stuff.
21:10:37 <startling> zzing: do you understand how fmap on functions is (.) ?
21:11:31 <zzing> startling, intuitively - no. However, I have done the a <$> b thing more recently, and even a bit of a <$> b <*> c <* d
21:12:27 <startling> zzing, so there's this type called ((->) a b). ((->) a) is a functor
21:12:30 <zzing> Has anyone written really good books that cover this kind of theory? (something that might go further than typeclassopedia)
21:12:38 <zzing> Reader a
21:13:35 <dmwit> There's lots of books on CT.
21:13:56 <dmwit> Awodey is one; MacLane is sort of the one that kicked everything off; Pierce has one that I haven't read
21:14:24 <zzing> I think I want is one that does practical in haskell as well as the theory.
21:16:00 <dmwit> ?remember BenjaminPierce That book [Basic Category Theory for Computer Scientists] knew more category theory than me even when I was writing it.
21:16:01 <lambdabot> Nice!
21:18:15 <pharaun> @quote etched
21:18:16 <lambdabot> command says: lambdabot will say 'it is forever etched into my memory' and then forget the quote by tomorrow.
21:18:35 <dmwit> \bot should just ?flush more often
21:18:43 <zzing> This one was recommended on one of the stackoverflow related sites: http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_1?s=books&ie=UTF8&qid=1347855396&sr=1-1&keywords=Awodey%3A+Category+theory#productPromotions
21:19:01 <startling> so I've got a Tree and two lenses on it -- "leaf" and "branch". say there's a leaf at key k. what should happen if I do "set (branch k) Nothing"? should it delete the leaf?
21:19:06 <dmwit> Yes, Awodey is always near the top of the list of suggestions.
21:20:02 <dmwit> I wonder how many of the people who suggest it have actually read it.
21:20:08 <dmwit> For example, I suggested it, and I haven't read it.
21:20:28 * shachaf hasn't read LYAH or RWH either.
21:21:12 <zzing> j'ai RWH.
21:21:54 <dmwit> This is why I suggest the Gentle Intro.
21:21:56 <dmwit> ;-)
21:23:06 <zzing> My university library does not have a book on category theory written since 1988.
21:23:22 <startling> category theory is that old?
21:23:22 <zzing> It has many written in the 60s and 70s
21:23:35 <cmccann> has anything in CT relevant to Haskell changed since 1988 anyway?
21:23:43 <zzing> Theory of categories.    Mitchell, Barry.   Publisher: 	New York : Academic Press, 1965 [reprinted 1969]
21:23:46 <cmccann> I mean, this is not complicated stuff.
21:24:02 <nexx> Yeah, I think the category theory guy is even dead.
21:24:07 <zzing> Kan extensions in enriched category theory / Eduardo J. Dubuc.   (1970)
21:24:11 <zzing> So yeah, this thing is old :P
21:24:42 <zzing> What is the relationship to "module theory" or something like that I heard a reference to?
21:24:46 <Playground> Haskell's design really strikes me as beautiful for the most part. But I have always wondered, why are type classes and modules separate features?
21:25:01 <startling> Playground: huh?
21:25:02 <cmccann> every use of CT in Haskell I've seen either is explained in the first half of every introduction to CT I've seen or came from one of edwardk's libraries
21:25:05 <MostAwesomeDude> Playground: What do you mean?
21:25:18 <MostAwesomeDude> cmccann: Or sometimes both!
21:26:00 <startling> cmccann, so what you're saying is that none of the concepts in commonly-used libraries is explained in the first half of every introduction to CT
21:26:27 <mm_freak_> Playground: modules are about namespaces, type classes are about implicit passing of functionality
21:26:40 <mm_freak_> (disregarding fancier stuff like type-level programming)
21:26:48 <Playground> startling, MostAwesomeDude, mm_freak_: Sometimes I find myself wishing type class instances had tags.
21:26:51 <zzing> Would it be reasonable to explain to the CS student who has never used or possibly heard of haskell to describe a typeclass as a sort of interface, reluctantly comparing it in conceptual terms to an interface in java?
21:27:03 <cmccann> on a more serious note I've read chunks of Awodey's book and found it pretty approachable
21:27:36 <cmccann> as far as intrinsically wrong comparisons involving type classes go, OO interfaces is the least wrong
21:27:36 <Playground> startling, MostAwesomeDude, mm_freak_: Tags could be optional. That way, if you do not supply a tag, the default type class instance is used.
21:27:57 <zzing> I find myself using that comparison when people are curious
21:28:04 <zzing> cmccann, I don't think i ahve seen you here before
21:28:17 <mm_freak_> Playground: if a type class is too static for you, you can always use 'data' instead
21:28:29 <startling> zzing: yeah, I think that's pretty common
21:29:02 <cmccann> zzing, my presence on IRC is inconsistent at best
21:29:04 <Playground> mm_freak_: But that would completely ruin infix functions.
21:29:12 <startling> Playground, you can make a newtype an instance of whatever class
21:29:13 <Playground> And I freaking love Haskell'
21:29:16 <Playground> s infix functions
21:29:30 <mm_freak_> Playground: why?  f (Num (+) (-) (*) …) x y z = …
21:30:01 <zzing> cmccann, nice to meet you. Now I have a web project to move forward in Yesod.
21:30:50 <Playground> mm_freak_: I want to be able to say "x + y" and use the default Num implementation, and "x otherNumInstance.+ y", and use some other implementation.
21:31:20 <mm_freak_> Playground: how would a type signature look like for a function that uses both variants?
21:31:33 <mm_freak_> just a Num constraint would be wrong
21:31:58 <Playground> mm_freak_: It would have two Num instances as its parameters.
21:32:10 <startling> maybe "context otherNumInstance (a + b)
21:32:19 <startling> or something? I know what you're getting at, though
21:32:25 <Ralith> it sounds like it would have only one num instance as a parameter, since you explicitly name the other
21:33:06 <mm_freak_> i don't know if this is such a good idea
21:33:31 <startling> Playground: anyway, newtype OtherNum = OtherNum d; instance Num OtherNum where...; OtherNum a + OtherNum b
21:33:56 <mm_freak_> i can see that it could work, but you really just want namespaces for instances
21:34:55 <startling> instances are kind of annoying as they are now
21:37:08 <Playground> mm_freak_: Namespaces? Not really. Namespaces in other languages have brought nothing but pain to me.
21:37:27 <mm_freak_> Playground: not namespaces in the OO sense
21:37:41 <mm_freak_> Playground: haskell's module system is also a namespacing concept
21:38:35 <mm_freak_> startling: what is annoying is that people often write classes what shouldn't be classes
21:38:47 <mm_freak_> type classes are fine as they are…  it's just that there is too much abuse
21:38:52 <startling> mm_freak_, I mean how they're automagically imported and can conflict
21:39:18 <mm_freak_> startling: the original concept would make everything else wrong
21:39:31 <mm_freak_> think of instances as supposed to be unique worldwide
21:39:33 <cmccann> it's not clear that there are clearly superior alternatives to type classes as they are now.
21:39:48 <mm_freak_> there is only one Monad instance for Maybe, and no second should exist, otherwise it's either not Monad or not Maybe
21:40:04 <mm_freak_> so auto-importing is totally sensible
21:40:11 <cmccann> the alternatives I'm aware of either don't work as well in practice, or have different limitations of similar magnitude.
21:40:41 <mm_freak_> if this universal uniqueness is bothering you it's probably because what you have isn't actually a type class
21:40:46 <startling> mm_freak_, what about when a built-in type is not an instance of some class and can be? then multiple people define instances in different places
21:41:11 <mm_freak_> startling: that's the unfortunate thing about it, but that problem can't be solved without changing the concept entirely
21:41:15 <mapreduce> Show seems like a class people might genuinely want differing instances of.
21:41:24 <startling> yeah, Show is kind of weird
21:41:33 <Ralith> Ord's a classic example
21:41:35 <mm_freak_> why?  Show is a debugging feature
21:42:16 <Ralith> just because Monad Maybe obviously has only one reasonable instance doesn't mean that all typeclasses are such.
21:42:22 <cmccann> if you look at what the default instances do, Show and Read are best regarded as serialization functions.
21:42:47 <mm_freak_> Ralith: i'm aware that you could order Integer differently, but the point is:  then it's not Integer
21:42:54 <mm_freak_> newtype MyInteger = MyInteger Integer
21:43:12 <cmccann> if we're complaining about wanting multiple instances, Monoid is a better example...
21:43:20 <Ralith> mm_freak_: again, you pick a trivially obvious case and assume that none others exist.
21:43:24 <startling> speaking of Show, a TH deriver for Show with lenses would be super helpful
21:43:28 <Ralith> not every type is Maybe or Integer.
21:43:42 <mm_freak_> Ralith: no, i'm saying that you may be misunderstanding the whole idea behind type classes
21:43:45 <startling> mm_freak_, what about Monoid
21:43:46 <startling> ?
21:44:07 <mm_freak_> startling: what about it?
21:44:19 <mm_freak_> Monoid is a great example, because the base library actually does the right thing there
21:44:23 <startling> mm_freak_, numbers can have a number of different Monoid instances
21:44:25 <mm_freak_> see First, Last, Sum, Product, etc.
21:44:39 <liyang> cmccann: there's a selection of wrappers in Data.Monoid, like newtype Dual and what mm_freak_ said.
21:44:57 <cmccann> yes, I know, and newtype wrappers are a horrendous irritation to use in many cases.
21:44:59 <startling> oh, huh, didn't know those were defined there
21:45:09 <dmwit> FWIW, I agree with Ralith: not all classes have only one reasonable implementation at each type.
21:45:11 <mm_freak_> you don't want multiple instances for the same type…  you want single instances for multiple types
21:45:13 <cmccann> it's a terrible solution but I'm not convinced there's any better way to do it.
21:45:16 <mm_freak_> instances are inherently type-bound
21:45:18 <mm_freak_> not usage-bound
21:45:29 <dmwit> And the introduction of newtype wrappers just to deal with that can be quite annoying.
21:45:38 <mm_freak_> dmwit: and i'm saying the problem is for them to be defined as classes in the first place
21:45:45 <dmwit> Luckily, these days GADTs can alleviate many of those problems.
21:45:54 <dmwit> mm_freak_: Ord is darn convenient, even though it has this problem.
21:45:59 <liyang> cmccann: there's http://hackage.haskell.org/package/newtype …
21:46:10 <cmccann> yes, I'm familiar with it.
21:46:23 <mm_freak_> dmwit: i wouldn't mind writing f (Ord { ordGT = (>) }) … = …
21:46:28 * cmccann has some infix lifting operators and other combinators based on the newtype package somewhere.
21:46:57 <mm_freak_> have an Ord class for the common case and an Ord' type for alternatives
21:47:28 <mm_freak_> backwards :: Ord' Integer
21:47:28 <cmccann> as for Ord, I have plenty of grievances against it for other reasons, heh
21:47:42 <mm_freak_> backwards :: (Ord a) => Ord' a
21:48:26 <dmwit> In one of my projects, I have a hack like this:
21:49:19 <dmwit> instead of class Foo a b where bar :: a -> b, I have data Foo a b = unFoo { bar :: a -> b } and a bunch of instances like instance Default (Foo SpecificA SpecificB).
21:49:56 <dmwit> This way I still have to pass dictionaries around explicitly, but if I just want the "standard" dictionary for a particular type I can get it with "def" and type inference.
21:50:02 <dmwit> It's not horrible, but it's not great.
21:50:07 <shachaf> GHC has a newtype with a backwards Ord instance in the standard library.
21:50:11 <cmccann> that's an interesting hack, I will say.
21:51:22 <shachaf> Data.Ord.Down
21:51:38 <mapreduce> Would it be bad to be able to locally replace an instance?
21:51:47 <shachaf> Yes.
21:51:55 <dmwit> Yes. The standard example is by breaking invariants in, e.g., Data.Map's structure.
21:52:25 <dmwit> As I alluded to above, one solution would be to make Data.Map store the class dictionary in its data structure (via GADTs).
21:52:36 <dmwit> I don't think anybody's tried writing a competitor that does this, though.
21:52:45 <shachaf> dmwit: I don't think you even need GADTs.
21:52:53 <shachaf> But that prevents you from doing things like uniion.
21:53:11 <dmwit> yep
21:53:29 <shachaf> It might be nice to have a Data.Map that takes a first-class comparison function anyway.
21:53:36 <cmccann> unless you have some way to provide a witness to equality between the two captured instances.
21:53:39 <shachaf> But you couldn't do as much with it.
21:53:47 <cmccann> but at that point we're not really making things easier...
21:53:52 <shachaf> cmccann: Hmm, how might you do that?
21:54:00 <dmwit> unsafePtrEqual
21:54:03 <dmwit> lolol
21:54:04 <cmccann> hahaha
21:55:07 <shachaf> dmwit: There's a reason I asked cmccann and not you.
21:55:41 * cmccann isn't sure how it would work, but there's probably a way, if only by placing restrictions on how the instance is captured.
21:56:13 <cmccann> but really, I think local instances is going to be a bad idea in practice however you go about it.
21:57:05 <cmccann> even if it occasionally seems like it would make sense to have it, with local instances being captured by closures like explicit arguments to avoid the "conflicting Ord instance" problem
21:57:17 <mm_freak_> i don't have Data.Ord.Down
21:57:18 <cmccann> or whatever version of that people came up with
21:57:18 <MostAwesomeDude> Hey, is there a Num instance for Num a => Num (a,a) anywhere in base?
21:57:31 <cmccann> what would that instance do?
21:57:41 <shachaf> Oh, you're talking about instances, not first-class comparison functions for Map.
21:57:42 <cmccann> pointwise multiplication is kinda... weird.
21:57:47 <mm_freak_> anyway, i'm not particularly fond of newtype wrappers…  i mostly prefer to pass dictionaries
21:58:07 <shachaf> MostAwesomeDude: There's Complex and there's Rational which are both kind of like that (and very different).
21:58:12 <mm_freak_> oh, i do have Down…  it's not a submodule, but a type =)
21:58:14 <copumpkin> mm_freak_: they have different properties
21:58:26 <cmccann> shachaf, it amounts to the same thing at some level. once you accept instances as non-global you're basically working with their dictionaries, which in the case of Ord is a comparison function
21:58:26 <dmwit> MostAwesomeDude: I don't think so, but there are Hackage packages providing an instance (Monad m, Num a) => Num (m a) and a monad data Pair a = Pair a a.
21:58:29 <mm_freak_> copumpkin: "they"?
21:58:36 <MostAwesomeDude> Hmmm.
21:58:42 <shachaf> cmccann: True.
21:58:45 <copumpkin> mm_freak_: I mean that typeclasses and explicit dictionaries are kind of solving different problems
21:58:45 <mapreduce> Scala perhaps accidentally allows replacing instances, though I guess there they become part of the data structure instead of always being passed with functions.
21:58:59 <shachaf> cmccann: Thought storing the function in the data type itself is slightly different from passing it to each Map operation.
21:59:07 <dmwit> join (Pair (Pair a b) (Pair c d)) = Pair a d
21:59:13 <MostAwesomeDude> Hmmm.
21:59:16 <cmccann> yes, let's talk about how scala handles things, that's going to end well.
21:59:20 <mm_freak_> copumpkin: that's the point i've been explaining for the last 30 minutes =)
21:59:21 <cmccann> especially with copumpkin around :P
21:59:29 <copumpkin> lol
21:59:35 <copumpkin> [00:57:26] <mm_freak_> anyway, i'm not particularly fond of newtype wrappers…  i mostly prefer to pass dictionaries
21:59:36 <shachaf> Hmm, if you had Set that stored its comparison function as part of the data structure, would that be a monad?
21:59:43 <shachaf> Er, no, it wouldn't.
21:59:44 <copumpkin> mm_freak_: that just made it sound like they were interchangeable and a matter of style
21:59:45 <MostAwesomeDude> Well, whatever. I just wanted convenience for +~ and += but I can write more code.
21:59:48 <copumpkin> I haven't been following otherwise :)
21:59:50 <mapreduce> cmccann: I was just trying to see whether the objections here would show up a problem for Scala, which I guess they don't.
22:00:03 <shachaf> It would be even less of a functor than current Set, inf act. :-)
22:00:10 <mm_freak_> copumpkin: yeah, you got me wrong…  the backlog could help =)
22:00:18 <cmccann> mapreduce, I've heard many complaints at great length on how scala handles some things, and I'm pretty sure this is one of them
22:00:54 <mm_freak_> shachaf: it would be a Bind =)
22:01:51 <cmccann> MostAwesomeDude, about what, a Num instance for (a, a)? there's no single obvious way to do that, but that's the only problem.
22:02:32 <cmccann> I'd be inclined to make a separate type instead of using (,) if I wanted such an instance myself
22:04:09 <cark> I have an error when leaving out a type declaration for one of my functions, and suspect i could get ghc to guess it instead of me providing it, here is a gist https://gist.github.com/3735643 . Any idea on how to do that ?
22:04:17 <mm_freak_> there is a Num instance for (Num a, Num b) => (a, b)
22:04:24 <mm_freak_> a weird one, but yeah
22:05:02 <cmccann> for (a, b) I assume it does everything pointwise?
22:05:13 <mm_freak_> yeah
22:05:25 <shachaf> > (1,2) + (2,3)
22:05:26 <lambdabot>   (3,5)
22:05:29 <mm_freak_> i really think that the numeric type classes should be more inspired by group theory
22:05:41 <shachaf> > fst 5
22:05:41 <cmccann> maybe it's just my taste in mathematics but pointwise multiplication feels strange and wrong there :[
22:05:41 <lambdabot>   5
22:06:07 <cmccann> if I was pressed to pick a "most natural" Num instance for pairs it would probably be complex numbers
22:06:17 <cmccann> but that's probably just me :T
22:06:27 <shachaf> cmccann: Not rationals?
22:06:33 <liyang> There's dual numbers too.
22:06:38 <shachaf> Dual numbers?
22:06:46 <shachaf> Is that the one where e^2 = 0?
22:06:49 <cmccann> no, because I think of rationals as single numbers.
22:06:57 <liyang> shachaf: yah.
22:07:00 <shachaf> I think of complex numbers as single numbers. :-)
22:07:01 <rwbarton> nothing wrong with the product of rings
22:07:08 <copumpkin> cmccann: http://en.wikipedia.org/wiki/Algebra_over_a_field#Classification_of_low-dimensional_algebras
22:07:13 <cmccann> whereas complex numbers I think of as a sum of elements, like a vector.
22:07:29 <mapreduce> Presumably you'd be more specific than just Num for components of a rational.
22:07:31 <cmccann> it's not anything coherent, just the sorta intuitive gut reaction.
22:07:36 <shachaf> cmccann: OK, but complex numbers have the odd property that (0,1) * (0,1) = (-1,0)
22:07:53 <cmccann> but that doesn't strike me as odd. :]
22:08:08 <shachaf> Why -1?
22:08:35 <rwbarton> because if you picked 0 or 1 you'd get something else
22:08:35 <cmccann> because it's two quarter turns in the complex plane, obviously
22:08:52 <maukd> cark: monomorphism restriction?
22:08:54 <shachaf> What do you get if you pick 1?
22:09:14 <pikhq> shachaf: sqrt((1,0)) = (0,1)?
22:09:27 <shachaf> pikhq: No, sqrt((1,0)) = (1,0)
22:09:28 <rwbarton> you get R x R again I think
22:09:35 <shachaf> Just like sqrt(9) = 3
22:09:40 <maukd> > sqrt((1,0))
22:09:41 <lambdabot>   (1.0,0.0)
22:09:48 <cark> maukd: mhh don't think so, if i uncomment the type declaration, it goes well, at no time did i get any error related to monomorphic resitriction
22:09:55 <pikhq> shachaf: But if (0,1)*(0,1)=(1,0) then...
22:09:56 <liyang> > sqrt NaN
22:09:57 <lambdabot>   Not in scope: data constructor `NaN'
22:09:58 <cark> maukd: tho i can try to lift it just for the test
22:10:03 <shachaf> pikhq: Then what?
22:10:11 <pikhq> Then I don't know
22:10:11 <shachaf> Are you one of those "sqrt is not a function" people?
22:10:29 <copumpkin> sqrt is obviously a function
22:10:31 <pikhq> Then it'd follow that I'm being silly.
22:10:51 <cark> maukd: it worked !
22:11:16 <cark> maukd: any idea on how i can spot that kind of stuff on my own ?
22:11:18 <rwbarton> shachaf: (1,0) corresponds to (1,1) in R x R and (0, 1) corresponds to (1,-1) in R x R
22:11:29 <pikhq> shachaf: Anyways, the (silly) starting assumption is that we wanted sqrt(-1) to be defined, so we made it a tuple and sqrt((-1,0)) needed a definition, so we decided (0,1).
22:11:33 <pikhq> </boring>
22:11:45 <rwbarton> because (1,1) is the unit and (1,-1) is another linearly independent element whose square is (1,1)
22:12:22 <maukd> cark: a definition of the work 'aSingleIdentifier = ...', a type error, and the type error disappearing if you add an explicit type signature
22:12:22 <shachaf> R x R as in pointwise multiplication?
22:12:25 <rwbarton> yes
22:12:31 <maukd> er, of the form*
22:13:16 * shachaf wonders why (0,1)^2 has to be (x,0) at all.
22:13:44 <shachaf> Well, if you treat (a,b) as a+bx, (0,1)^2 wouldn't be of the form a+bx at all.
22:13:50 <cark> maukd: this also explain why the insertPerson function needed its own declaration too.
22:13:52 <cmccann> it can be whatever you want as long as the result is self-consistent in some sense
22:13:53 <cark> maukd: thanks a lot !
22:14:18 <cmccann> my default intuition is heavily geometric but that's just me.
22:14:39 * cmccann thinks of quaternions as 3D rotations, too.
22:14:43 <Nereid> pointwise multiplication is by far the most "natural" thing to do on pairs
22:14:57 <Nereid> since that corresponds to the product of (say) rings
22:14:58 <shachaf> Right, but can it be self-consistent for (0,1)^2 to be (0,something)?
22:15:02 <Nereid> (in the category-theoretic sense)
22:15:43 * shachaf tends to be very non-geometric.
22:15:46 <cmccann> pointwise multiplication on pairs only feels sensible to me as a special case of fixed-length vectors
22:16:10 <Nereid> cmccann: think of it as functions on a 2-element set.
22:16:28 <cmccann> yes, I understand how it works and why it makes sense.
22:16:30 <rwbarton> well let's assume 1 = (1,0) and let x = (0,1), then x^2 = ax + b for some a and b... by completing the square we can assume WLOG a = 0 and then b is either positive, negative or zero
22:16:33 <cmccann> just feels counterintuitive to me.
22:16:44 <Nereid> cmccann: what would you do for triples?
22:16:44 <rwbarton> those are the three cases
22:17:04 <ddarius> sqrt is a function on a Riemann surface.
22:17:12 <Nereid> ddarius: what about at 0?
22:17:51 <Nereid> well ok.
22:17:56 <Nereid> yeah.
22:18:44 <cmccann> incidentally, my heavily geometric intuition here is probably ddarius's fault.
22:18:57 <ddarius> Yay mind corruption!
22:19:17 * ddarius endeavors to corrupt as many minds as possible.
22:19:29 <Nereid> cmccann: but there's geometry in a 2-point set.
22:19:31 <rwbarton> shachaf: in other words if x^2 = ax + b with a not 0, then replace x by (-a/2,1)
22:19:32 <Nereid> although it's not very interesting.
22:19:49 <Nereid> rwbarton: what if 2 = 0?
22:20:02 <rwbarton> I thought R meant the reals
22:20:08 <Nereid> oh
22:20:14 <rwbarton> but if it means any ring then yes that is another case
22:20:29 <cmccann> finally having a good understanding of why quaternions can represent 3D rotations was pretty persuasive to my intuition.
22:20:29 <Nereid> or field
22:20:34 <rwbarton> apparently I introduced R so I guess I get to be right :)
22:20:39 <cmccann> previously that always seemed bizarre to me.
22:21:15 <Nereid> cmccann: it's a lucky accident.
22:21:22 <cmccann> not really?
22:21:36 <shachaf> What does it take to get your mind corrupted by ddarius around here?
22:21:37 <cmccann> no more than complex numbers representing 2D rotations is.
22:21:39 <Nereid> I think it's pretty lucky that sp(1) ~= so(3).
22:21:43 * ddarius agrees with cmccann here, though for it to be an algebra as well is a "lucky" accident.
22:22:38 <cmccann> I'll grant the existence of that particular sub-algebra as lucky, which I guess is what ddarius just said
22:23:13 <cmccann> though you probably have no idea what I'm referring to at this point, heh
22:24:11 <Nereid> although really there aren't that many lie algebras of rank 1 so heh.
22:27:50 <Nereid> cmccann: I do know what you're referring to though.
22:27:51 <Nereid> I think.
22:28:33 <maukd> the algebra is a lie
22:28:40 <cmccann> geometric interpretations of clifford algebras.
22:28:44 <Nereid> yes.
22:29:00 <cmccann> which reminds me, has anyone put a decent geometric algebra library on hackage yet?
22:29:09 * cmccann is still trying to avoid writing one.
22:30:32 <liyang> edwardk already did it.
22:30:43 <liyang> (Probably.)
22:30:48 <Nereid> probably.
22:30:48 <Nereid> :P
22:30:57 <cmccann> Nereid, but yeah, bivectors directly represent rotations, so anything you get by considering only bivectors and scalars strikes me as talking about rotation for entirely non-accidental reasons
22:31:05 <Nereid> of course.
22:31:23 <Nereid> but the fact that they form a division algebra in low dimensions is quite lucky.
22:31:45 <cmccann> right, like I said, I'll grant that part
22:31:48 <rwbarton> it has to be lucky in some sense because it stops working in higher dimension
22:31:55 <Nereid> although really it doesn't matter that they're a division algebra.
22:32:03 <Nereid> you can still do the same construction in any dimension.
22:32:34 <cmccann> but bivectors work just fine for rotation in any number of dimensions, it's only the low-dimension cases where you can have only bivectors
22:32:36 <Nereid> although soon enough the dimension of the algebra is high enough that you may as well just use rotation matrices.
22:33:21 <ddarius> Rotors represent rotations.
22:33:53 <cmccann> also, edwardk has "geometric coalgebra", which should surprise nobody
22:34:02 <Nereid> haha.
22:34:20 * ddarius stills needs to write up an article/paper on that stuff.
22:34:21 <cmccann> but it's not really what I'm after
22:35:24 <amosr> type inference seems kind of poor when using unboxed types (eg Int#). is this a known thing?
22:35:50 <cmccann> ddarius, incidentally, the representation I'm using for linear implication turned out to be (nearly) identical to the linear map edwardk has in that package
22:35:55 <ddarius> amosr: Why are you using unboxed types?
22:36:25 <amosr> ddarius: 'cause my boss told me to :-)
22:36:51 <amosr> uhh, because it's easier than relying on strictness analysis, which changes over versions of ghc
22:36:56 <ddarius> That said, I don't think types being boxed or not affects type inference at all.  It does affect typing (primarily via kinds) but not inference to my knowledge.
22:37:15 <ddarius> amosr: Use strictness annotations(?)
22:37:34 <ddarius> BangPatterns makes this much more pleasant than it used to be.
22:37:56 <amosr> yeah. I'm not sure of the exact details, but:
22:38:17 <amosr> DPH was originally using unboxed everything, then they changed to boxed with bang patterns and seqs
22:38:35 <amosr> and they've decided it's much better to just be explicit and use unboxed
22:40:35 <cmccann> still don't see any geometric algebra on hackage. bluh.
22:40:56 * cmccann doesn't want to write his own library for that. :[ :[
22:41:20 <ddarius> The geometric coalgebra is actually a good idea since it allows you to represent the exponentially growing basis set rather compactly.
22:42:00 <hpaste> amosr pasted “Unboxed requires type signatures” at http://hpaste.org/74842
22:42:11 <cmccann> I'm really only interested in at most 5 dimensions, though
22:42:34 <amosr> not that it's a problem, I've added the type signature. I just thought it was interesting
22:42:56 <amosr> I had another one that didn't need type signature until I changed a 5-tuple to a 6-tuple. whacky
22:44:11 <ddarius> Well, I guess kind inference defaults to *, though I'm not exactly sure what the rules are for ordinary functions since in Haskell 98/2010 the issue doesn't come up.
22:44:37 <cmccann> the coalgebra is really neat and probably would work well enough with strategically placed memoization, but for my purposes I'm pretty sure something like an unboxed array would be better
22:44:57 <johnw> hmm.. I want a haskell version of "mbuffer"
22:45:40 <cmccann> so write one?
22:45:48 <johnw> yeah, don't have time now
22:45:53 <johnw> too many other things in my queue
22:46:21 <cmccann> just do both non-strictly and wait to see which project gets forced first :]
22:46:28 <johnw> haha
22:46:41 <johnw> use case: http://blogs.everycity.co.uk/alasdair/2010/07/using-mbuffer-to-speed-up-slow-zfs-send-zfs-receive/
22:48:19 <cmccann> sounds pretty simple in concept which means it probably has a bunch of fantastically complicated corner cases it has to handle.
22:48:21 <ddarius> cmccann: It's awkward to make good generic geometric algebra libraries.  Code generation is probably the best bet and what the C++ clifford library does (via template metaprogramming).
22:48:42 <cmccann> ddarius, yes, I've considered that.
22:48:59 <cmccann> part of why I'm trying to avoid writing my own is that I really don't feel like mucking with TH.
22:49:53 <ddarius> However making a package that specifically covers 3D Euclidean GA, 4D Homogeneous GA, and 5D CGA probably covers many, many use cases.
22:49:58 <cmccann> since even the (at most) half dozen cases I'm interested in is probably too much to handle generically and efficiently without bigger headaches than TH anyway.
22:51:19 <cmccann> right, where "many, many use cases" means "anything involving 3D graphics".
22:51:33 <cmccann> which is clearly my interest, as you probably guessed from "at most 5D"
22:53:37 <ddarius> type GA3D = Complex (Complex Double) (Complex Double)
22:53:50 <ddarius> Er -(Complex Double)
22:54:25 <ddarius> Might need more layers.
22:54:33 <cmccann> thing is, dealing with both euclidean and non-euclidean spaces seems like a significant increase in complexity
22:54:45 <cmccann> unless there's some easy trick I'm not aware of
22:56:47 <cmccann> dunno, I haven't really spent much time looking into it. :T
22:59:28 <ddarius> cmccann: If you're generating code, it's just a matter of changing the signature for handling the squares of vectors, and then the rest follows.
23:00:22 <ddarius> If you are writing it by hand, then you do this yourself and only handle the cases people care about, and most things don't require anything particularly special.
23:02:00 <cmccann> right, but for non-code generation generic approaches it seems like it'd be horrendous
23:02:01 <ddarius> What I typically do when I hand-write some GA code is explicitly make Vector/Bivector/Rotor types (actually classes since I've done this in C++ and C# more than Haskell.)
23:02:30 <ddarius> Almost any runtime generic approach is going to be horrendous.
23:02:38 <ddarius> Efficiency-wise.
23:02:47 <cmccann> wanting 5D CGA is what would (will?) probably force me to either hand-roll specific versions or use codegen.
23:05:03 <ddarius> Even for lower dimensionalities, dualizing is a common and important operation that is, for any dimension, just a permutation and some sign flips.  Figuring out this permutation and the sign flips every time you dualize is going to be painful as is the (equivalent) pseudo-vector arbitrary multivector (or worse, arbitrary multivector-multivector) multiplication.
23:05:54 <cmccann> if everything is euclidean I think you could get away with pre-computing more stuff than otherwise and get tolerable performance
23:05:58 <cmccann> but I'm not sure, so eh
23:06:10 <ddarius> The signature should have very little impact.
23:07:04 <ddarius> You could just embed into the 2^D matrix algebra.
23:07:16 <ddarius> Just do 32x32 matrix multiplications all the time.
23:07:22 <cmccann> heh
23:07:34 <cmccann> I'll probably just write a hand-rolled non-generic version at some point
23:08:01 <cmccann> unless I feel like playing with TH
23:08:24 <cmccann> since it looks like waiting for someone else to write a library first isn't working. :[
23:08:36 <ddarius> It's not that bad to write, though there is a lot of tedious calculation to figure certain things out (like which signs flip) so some computer algebra system may be recommended.
23:09:26 <cmccann> yeah
23:10:33 <cmccann> in a previous half-assed implementation I had it calculate most stuff as lookup tables or whatnot
23:10:42 <cmccann> which at least is only calculating it at runtime once
23:11:20 <cmccann> was pretty horrendous code though. :T
23:22:41 * hackagebot hedn 0.1.5.2 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.5.2 (AlexanderBondarenko)
23:32:42 * hackagebot lojysamban 0.0.1 - Prolog with lojban  http://hackage.haskell.org/package/lojysamban-0.0.1 (YoshikuniJujo)
23:35:33 <johnw> can one do a proper emdash with Haddock?
23:36:03 <shachaf> —?
23:36:09 <johnw> yes
23:36:17 <johnw> oh, there's a thought
23:36:34 <johnw> you can tell how long I've been coding that I would never even think of putting a Unicode character in a source file :)
23:37:42 * hackagebot binary 0.6.0.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.6.0.0 (LennartKolmodin)
23:38:18 <pharaun> is the scheme wikibook the best source on creating/supporting a language in haskell? i was thinking of a little runtime DSL for a project
23:38:40 <shachaf> Probably not.
23:45:06 <pharaun> hm
23:54:05 <johnw> where is edwardk when one needeth him
23:55:20 <shachaf> People should call "in the direction of Boston "Edward".
23:55:36 <shachaf> With an extra '"' in there.
23:57:47 <johnw> say I have Tree k v = Map k (Either v (Tree k v))
23:58:16 <johnw> if I use: myMap ^. at "foo" . at "bar", it doesn't working because the second at can't be applied to a Maybe
23:58:29 <johnw> what is the "lensy" way to descend a series of Maybes?
23:58:35 <shachaf> Didn't someone ask about that in here recently?
23:58:53 <shachaf> I think the answer was that it can't be a lens because it violates the lens laws, but it can be a traversal. Or something.
23:59:53 <ddarius> johnw: Just FYI, Haskell source files have been defined to be Unicode since at least Haskell 98.
