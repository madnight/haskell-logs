00:00:01 <startling> k. you'll get there
00:00:09 <startling> replicateM repeats a monadic action n times
00:00:15 <startling> putStrLn x is a monadic action
00:00:34 <dibblego> startling: "and collects the result" — therefore, you might want replicateM_ for that action
00:00:40 <beaky> Is a monad like a closure?
00:00:49 <dibblego> no
00:00:56 <beaky> so it's more like a functor?
00:01:15 <dibblego> it is definitely one of those, but it has more properties too
00:01:26 <beaky> :( I don't get the difference between a closure and a functor
00:01:39 <shachaf> Are you a C++ programmer by any chance?
00:01:47 <beaky> shachaf: yes ^^
00:01:47 <dibblego> heh
00:01:55 <lpvb> > mapM (\_ -> putStr "beaky ") [1..10]
00:01:56 <lambdabot>   <IO [()]>
00:01:56 <shachaf> beaky: OK. Please forget everything you know about C++.
00:02:02 <shachaf> Especially the word "functor".
00:02:04 <dibblego> this is important
00:02:08 <beaky> right
00:02:22 <shachaf> beaky: You shouldn't really care what a "closure" is.
00:02:29 <startling> dibblego: sure. good point
00:02:59 <mysticc> whats wrong with this code http://hpaste.org/74328
00:03:07 <startling> beaky: a monad is like a burrito
00:03:12 <shachaf> startling: Stop that.
00:03:23 <startling> (they're both used in bad similes)
00:03:30 <shachaf> You're really not helping anyone or making anyone's life better by saying that.
00:03:35 <beaky> so the burrito represents encapsulated state?
00:03:42 <lpvb> no
00:03:56 <startling> beaky: forget I said it, it's a dumb in-joke
00:04:00 <beaky> lol
00:04:01 <lpvb> Just get to the monad chaptyer in lyah
00:04:04 * hackagebot bytedump 1.0 - Flexible byte dump helpers for human readers.  http://hackage.haskell.org/package/bytedump-1.0 (VincentHanquez)
00:04:08 <startling> shachaf: sorry, duly noted
00:04:22 <beaky> alright. maybe once I've gotten to that part I'll get the burrito joke ^^
00:04:24 <dibblego> mysticc: you probably need a fundep there to make it usable — also, it's rather classy-prelude (ish)
00:04:49 <mysticc> dibblego: what is classy-prelude ?
00:04:51 <lpvb> beaky: the joke is that it's a bad analogy to understand monads, so don't try to understand it
00:04:59 <beaky> lol
00:05:17 <dibblego> mysticc: it has type-classes like your Format, which is a questionable design
00:05:53 <mysticc> dibblego: What about http://hpaste.org/74328
00:06:17 <mysticc> dibblego: What about http://hpaste.org/74329 .. oops
00:06:41 <dibblego> mysticc: a lot better
00:06:42 <mysticc> whats the problem with this ^^
00:06:57 <mysticc> dibblego: It still doesn't work ..
00:07:23 <dibblego> works fine for me — you can ditch FlexibleInstances
00:07:37 <mysticc> oh sorry .. my mistake ..
00:10:58 <startling> So I've got a value of a type that has Monoid. Can I compare it against mempty without also having Eq?
00:11:38 <Cale> startling: no
00:12:31 <Cale> startling: Consider something like Endo Integer ~= Integer -> Integer, which has a monoid instance where mempty is essentially id and mappend is (.)
00:13:02 <startling> hmmm
00:25:54 <shachaf> So for a concurrent program, is it standard to have something like ReaderT (TVar Foo) IO where you might in other contexts use StateT Foo IO?
00:26:12 <Cale> It's an option
00:26:24 <Cale> You can also pass the TVar around explicitly of course
00:26:33 <dibblego> certainly, I have many other contexts where I might use ReaderT or StateT in the same position
00:26:35 <shachaf> Sure.
00:27:19 <Cale> One thing I really like to do, moreso with MVar and IORef than STM stuff, is to pass around readIORef r and writeIORef r or similar for MVars
00:27:32 <Cale> also works well with Chan
00:28:14 <Cale> and that, in addition to letting you control which parts of the program have read and write access to the state, also lets you control the semantics of reading and writing that state from a centralised place
00:29:33 <Cale> (Which is nice if at some point you decide that you don't really care about missing updates and can replace a Chan with an IORef by changing one line)
00:29:40 <Cale> or vice-versa
00:45:59 <pharaun> readIORef is restricted to only be able to read from a ioref? none of that other scary io side-effects?
00:46:11 <pharaun> or am i missing something
00:46:12 <shachaf> Not in its type.
00:46:16 <shachaf> But that's what the function does.
00:46:55 <shachaf> Cale is suggesting that instead of passing around (ref :: IORef Foo), you pass around (readRef :: IO Foo), where readRef = readIORef ref
00:47:45 <pharaun> aha!
00:49:36 <Nereid> or pass around a pair (readRef, writeRef)
00:49:38 <Cale> and then to a possibly different part of your program, you can pass writeIORef r :: Foo -> IO ()
00:50:03 <lpvb> how do I retrieve a webpage as a bytestring in the http library? I only see how to fetch them as Strings
00:50:04 <Nereid> this smells lens-like
00:52:08 <Cale> lpvb: Most of the operations are polymorphic in the type of the resulting stream
00:52:48 <Cale> lpvb: You'll notice a lot of HStream constraints -- there are instances of that class for String and for strict and lazy ByteString
00:53:10 <lpvb> I can't use something simple like getRequest?
00:54:08 <Cale> oddly, you can't, because its type is specialised
00:54:29 <Nereid> that is odd indeed
00:54:30 <lpvb> so I have to roll my own? :(
00:54:39 <randomclown> @pl \x -> (x, f x)
00:54:39 <lambdabot> ap (,) f
00:54:51 <Cale> lpvb: But you can look at how it's implemented, which is really straightforward
00:54:59 <Cale> lpvb: and use the very same code if you like
00:55:08 <Nereid> and just generalize the type
00:55:13 <Cale> I don't know why its type is specialised, that's rather unfortunate.
00:55:42 <Cale> It seems like the refactoring to make HTTP support other stream types isn't quite complete.
00:56:08 <Cale> (but it's almost there)
00:56:14 <randomclown> @pl \x -> (x, f)
00:56:14 <lambdabot> flip (,) f
00:56:27 <Nereid> -- or (,f) with -XTupleSections
00:57:02 <Nereid> @pl \x -> (f x, g x)
00:57:03 <lambdabot> liftM2 (,) f g
00:57:06 <Nereid> bah
00:57:11 <Cale> I also don't understand what possessed someone to define these Request_String and Response_String type aliases
00:57:21 <Nereid> yes that looks weird.
00:57:23 <Cale> they're aliases for Request String and Response String, respectively.
00:57:43 <randomclown> @pl \x -> (x,x,x,x,x, f)
00:57:43 <lambdabot> flip (join (join (join (join (,,,,,))))) f
00:57:58 <Nereid> @type join (,,)
00:57:59 <lambdabot> forall a c. a -> c -> (a, a, c)
00:58:03 <Nereid> cute
00:58:26 <Nereid> @pl \x -> (x,x)
00:58:26 <lambdabot> join (,)
00:58:28 <Nereid> yeah.
00:58:30 <Nereid> duh.
01:02:22 <Z`> Why when I write:   instance Monad MyState where ... ghci tells me that it expects 1 or more arguments to `MyState' ? BTW, MyState is defined as newtype MyState s a = MyState (s -> (a,s)) ?
01:02:38 <Z`> er scrath the last '?'
01:02:45 <Nereid> Z`: instance Monad (MyState s)
01:03:15 <Nereid> Monads have kind * -> *, while MyState has kind * -> * -> *
01:03:28 <Z`> thanks, that worked. ahh ok
01:03:40 <Nereid> so you need to partially apply it to get something of kind * -> * and yeah.
01:03:50 <Z`> nice explanation,thanks Nereid
01:50:42 * shachaf wonders why Data.ByteString has putStrLn
01:50:59 <atriq> For putting strings followed by a line, of course
01:51:33 <shachaf> What's a line?
01:52:08 <atriq> The appropriate character or sequence of characters for printing a newline on the appropriate operating system
01:52:24 <shachaf> What's a newline?
01:52:53 <beaky> a newline is an abstract idea
01:53:28 <beaky> imagine an infinitely long piece of tape
01:53:45 <beaky> and a device that reads and writes to that tape
01:54:01 <liyang> wrapped around a perfect sphere, in simple harmonic motion.
01:54:09 <beaky> yes
01:56:25 <beaky> when the machine is done writing on a segment of the tape, it pushes a new segment in
01:56:40 <beaky> that new segment is essentally a newline
01:59:29 <lpvb> how do I keep global, mutable state in haskell?
01:59:43 <hiptobecubic> :D
01:59:54 <hiptobecubic> or are you serious
02:00:02 <dmwit> Ooooo, I like this a lot.
02:00:18 <dmwit> Oh man, this is going to be even more dramatic in lambdabot.
02:00:20 <dmwit> > 0o678
02:00:22 <lambdabot>   55
02:01:00 <lpvb> I want to parse some JSON data and keep that data somewhere so when a user request for it again, the data doesn't have to be refetched. I only want to fetch JSON every 5 minutes
02:01:06 <dmwit> shachaf: Surely only Data.ByteString.Char8 has putStrLn.
02:01:40 <dmwit> lpvb: Pass around an IORef (or MVar if you're a scaredy-cat).
02:01:42 <fmap> @type Data.ByteString.putStrLn
02:01:43 <lambdabot> BSC.ByteString -> IO ()
02:01:51 <dmwit> yuck
02:02:28 <lpvb> hmm IORefs and MVars, aren't covered in the books
02:03:02 <dmwit> lpvb: You know any other languages?
02:03:10 <shachaf> dmwit: That's the thing.
02:03:15 <shachaf> Data.ByteString has one.
02:03:26 <dmwit> Right, as fmap just demonstrated and I just agreed is horrible.
02:03:33 <shachaf> > (+) 0o678
02:03:34 <lambdabot>   63
02:03:46 <saep> lpvb, do you actually use multiple threads?
02:03:46 <lpvb> dmwit: some C++, some Java
02:03:56 <lpvb> saep: no
02:04:06 <dmwit> lpvb: x :: IORef Int is int &x in C++
02:04:07 <saep> then you can simply use a state-transformer-monad
02:04:29 <dmwit> StateT is a good choice, too.
02:04:40 <lpvb> I set the ref in a monad?
02:04:52 <dmwit> IORefs can only be read or written in IO, yes.
02:05:03 <shachaf> dmwit: More like int *x, I think.
02:05:11 <hiptobecubic> does it allocate?
02:05:11 <dmwit> No, you can't do pointer arithmetic with IORef.
02:05:18 <shachaf> Well, yes.
02:05:26 <shachaf> But you have to explicitly dereference it and so on.
02:05:47 <shachaf> std::something_ptr<int> x; or something.
02:05:51 <dmwit> You have to use the assignment operator, it just happens not to be spelled "=".
02:06:07 <shachaf> Yes, but you also have to use the reading operator.
02:06:12 <shachaf> Which is named "" in C++ with references.
02:06:13 <dmwit> Yes, that's a little different.
02:06:42 <lpvb> dmwit: and how do I wait in an IO monad for 5 minutes?
02:06:42 <dmwit> Anyway, I think it's more like int & than int *.
02:06:49 <dmwit> You never use an IORef for an array.
02:06:58 <dmwit> lpvb: threadDelay, I guess?
02:07:14 <dmwit> ?hackage unbounded-delays
02:07:14 <lambdabot> http://hackage.haskell.org/package/unbounded-delays
02:07:22 <Z`> How can I see the definion of a monad ? so that I know the exact signature of >>= and return ?
02:07:28 <Z`> Can I :t something in ghci ?
02:07:32 <shachaf> :i Monad
02:07:41 <dmwit> ?src Monad
02:07:42 <lambdabot> class  Monad m  where
02:07:42 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
02:07:42 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
02:07:42 <lambdabot>     return      :: a -> m a
02:07:42 <lambdabot>     fail        :: String -> m a
02:07:44 <Z`> thanks!
02:08:27 <Z`> Is it typical to use the same symbol for a variable name and for a type ?
02:08:47 <QinGW> :t newtype
02:08:49 <lambdabot> parse error on input `newtype'
02:08:53 <shachaf> As in data Foo = Foo ...?
02:08:55 <shachaf> That's pretty common.
02:09:01 <Z`> alright,thanks
02:09:01 <shachaf> Oh, for a variable name.
02:09:11 <dmwit> Was the question precise?
02:09:13 <Z`> more like   return a = ...  ?
02:09:18 <shachaf> That's somewhat common? Nothing wrong with it, I think.
02:09:22 <Z`> since return :: a -> m a
02:09:26 <Z`> ok
02:09:30 <shachaf> That's not that common.
02:09:30 <dmwit> Yes, it's common when the function is very polymorphic.
02:09:43 <shachaf> People usually use x for values and a for types, or something.
02:09:52 <dmwit> I do it all the time. -_-
02:10:03 <shachaf> Well, you're dmwit.
02:10:07 <Z`> :)
02:10:08 <shachaf> You use mixed tabs and spaces.
02:10:18 * hiptobecubic shudders
02:10:26 <timthelion> WHAT!  dmwit mixes tabs and spaces!??
02:10:28 <shachaf> Z`: Just watch out that you don't confuse types and values.
02:10:32 * timthelion grabs his pitchfork
02:10:49 <Z`> ok shachaf-- perhaps I'll use different symbols, until I advance at haskell
02:11:03 * timthelion uses the same symbol all the time.
02:11:19 <timthelion> shachaf: evidence of this crime?
02:11:26 <shachaf> Did Z` just -- me? :-(
02:11:38 <dmwit> Yes, I use mixed tabs and spaces.
02:11:41 <dmwit> On purpose.
02:11:51 <plat0> shachaf: it was an m-dash
02:11:54 <dmwit> I use tabs for indentation, and spaces for alignment, just like God intended.
02:12:01 <hiptobecubic> foo:: a -> m a;  foo a = aa a*a where aa = let aaa = return in aaa
02:12:01 * timthelion is never talking to dmwit again.
02:12:05 <plat0> all hail dmwit
02:12:06 <hiptobecubic> dmwit, disgusting
02:12:08 <plat0> he knows the one true way
02:12:10 <shachaf> plat0: Well, lambdabot doesn't care about mdashes!
02:12:15 <shachaf> I still lost Internet points. :-(
02:12:20 <plat0> shachaf++
02:12:26 <dmwit> All of my code is 100% readable and correct at all tabstop sizes.
02:12:40 * shachaf 's tabstop is 0.
02:12:47 <plat0> dmwit: what editor do you use?
02:12:50 <dmwit> vim
02:12:56 <liyang> dmwit: I used to, until the rest of my team beat me into sticking to 4 spaces instead of tabs. :(
02:12:57 <Z`> Is there any decent mode for emacs ? I tried ghc-mod and haskell-mode, but they don't align my equations nicely
02:13:06 <plat0> I've kind of given up the fight for tabs
02:13:14 * timthelion always uses just 1 space, rather than 4 :)
02:13:15 <plat0> but I look up to you as a kind of freedom fighter
02:13:20 <plat0> like che guevara
02:13:24 <dmwit> hahaha
02:13:24 <plat0> I'll put you on my t-shirt
02:13:43 <plat0> I didn't even realise tabs were accepted in haskell
02:14:02 <dmwit> Yep, though they made the mistake of saying they expanded out to (up to) eight spaces. =/
02:14:10 <shachaf> Oh, it's deprecated.
02:14:10 <timthelion> dmwit: actually, I thought that you where MIXING the tabs and spaces aka indent like "spacetabtabspacespacespace"
02:14:14 <dmwit> The One True Way is for tabs and spaces to be of incomparable width.
02:14:15 <shachaf>              Deprecated: "Use Data.ByteString.Char8.hPutStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Char8)"
02:14:21 <plat0> dmwit: yes I agree
02:14:26 <dmwit> timthelion: Yes, I do that.
02:14:40 <timthelion> dmwit: WTF?
02:14:49 <dmwit> timthelion: Though starting with a space is pretty unusual.
02:15:12 <plat0> tabs to indent, spaces to align, and tabs to indent further
02:15:16 <dmwit> timthelion: I'll hpaste an example of when it's reasonable and correct.
02:15:21 <plat0> dmwit: is whitespace visible in your editor?
02:15:21 * timthelion finds his indent levels get too high with just 1 space per column change.
02:15:22 <dmwit> ...yes, what plat0 said
02:15:28 <dmwit> Now I don't have to hpaste. =)
02:15:31 <dmwit> plat0: yes
02:15:32 <plat0> today I have a new hero
02:15:47 <shachaf> Hmm.
02:15:49 * timthelion just lost respect for one of his old heros.
02:16:01 <Jafet> People still write programs in plain text?
02:16:02 <shachaf> All my SB8.hPutStrLns seem to be doing nothing.
02:16:06 <plat0> dmwit: i would appreciate the hpaste anyway
02:16:12 <dmwit> alright
02:16:16 <shachaf> Never mind that I'm using SB8.hPutStrLn.
02:16:26 <timthelion> ;) dmwit I'm just kidding, ok :) I'll still respect you, but for this one fatal flaw.
02:16:26 <shachaf> strace is showing no write() call.
02:16:34 <shachaf> Is this something to do with this Handle being a Socket?
02:17:31 <timthelion> dmwit: I've been meaning to ask. Why is your gtk2hs tutorial written from the standpoint of windows?  Are you actually a windows user?  Do you also use xmonad on windows?
02:17:44 <hpaste> dmwit pasted “tabs and spaces lol” at http://hpaste.org/74331
02:17:47 <Botje> burn the witch!
02:18:16 <dmwit> Lines 6 and 7 are of particular interest.
02:18:38 <plat0> dmwit: very nice
02:18:42 <shachaf> I didn't mean to start a tab-space war. :-(
02:18:42 <dmwit> I didn't write my tutorial from the viewpoint of Windows, but I included Windows details because sometimes people run gtk2hs programs on Windows, and they need to know how to write correct programs, too.
02:19:21 <timthelion> dmwit: you actually only ever mention Win32 there.  It kind of threw me for a loop.
02:19:23 <plat0> Maybe I need to switch to vim
02:19:31 <timthelion> plat0: from?
02:19:33 <dmwit> Linux is so sane it doesn't need any special mention. ;-)
02:19:34 <plat0> dmwit: how do you display whitespace in you editor?
02:19:36 <plat0> timthelion: emacs
02:19:41 <dmwit> plat0: one moment
02:19:56 <dmwit> set listchars=tab:>\ ,trail:#,extends:>
02:19:58 <dmwit> set list
02:20:08 <timthelion> plat0: and why not just use evil?
02:20:39 <plat0> dmwit: what does that actually show though?
02:21:04 <shachaf> Ugh, it's buffering, isn't it.
02:21:05 <plat0> timthelion: i've never heard of evil
02:21:12 <hiptobecubic> plat0 vim emulation
02:21:19 <dmwit> It shows a ">" at the beginning of each tab, empty space for spaces, and a "#" for any trailing whitespace (i.e. anything matching "\s+$").
02:21:24 <shachaf> Yep. It's buffering.
02:21:39 <dmwit> These are all in a slightly lighter color than the normal text.
02:22:00 <hiptobecubic> mine are blue
02:22:05 <plat0> dmwit: nice.
02:22:09 <hiptobecubic> set listchars=tab:▹⋅,trail:⋅,nbsp:⋅
02:22:23 <AfC> dmwit: are you the ringleader of gtk2hs these days?
02:22:35 <dmwit> I'm too much of a newb to correctly use Unicode in my vimrc.
02:22:38 <timthelion> dmwit: wait, you use dark on light!!!! Heritick!(just kidding this time :) I do too when I'm outside.)
02:22:39 <plat0> hiptobecubic: vim emulation for emacs?  That boggles my mind.
02:22:42 <dmwit> AfC: I suppose so, sort of.
02:22:56 * shachaf uses :set listchars=tab:>-,trail:☢ " U+2622
02:22:57 <dmwit> timthelion: No way. :colors darkblue is the best scheme.
02:23:14 <ziman> but once you're some distance from the left margin, you don't know where a tab will take you, do you?
02:23:19 <hiptobecubic> plat0, http://i.imgur.com/yLZHm.png
02:23:31 <dmwit> ziman: That's a very editor-specific question.
02:23:32 <hiptobecubic> shachaf, :D
02:23:54 <ziman> because tabs form a grid with cells of unknown width, starting at the left margin
02:24:02 <dmwit> Only in today's editors.
02:24:07 <AfC> dmwit: no, that's cool; I've casually been on the lookout for the Haskell bindings team. I figure I could at least lend moral support if nothing else.
02:24:07 * hackagebot her-lexer 0.1.1 - A lexer for Haskell source code.  http://hackage.haskell.org/package/her-lexer-0.1.1 (TimothyHobbs)
02:24:11 <ziman> if i understand correctly, the argument for spaces-only is that it works everywhere
02:24:21 <shachaf> Also, people who have trailing spaces anywhere ought to have something lingering with boiling oil in it done to them.
02:24:27 <dmwit> yes
02:24:29 <dmwit> shachaf++
02:24:42 <dmwit> emacs people are the worst offenders here for some reason.
02:24:51 <dmwit> I think emacs itself just inserts spaces sometimes for no good reason.
02:25:02 <timthelion> shachaf: what's wrong with trailing spaces?
02:25:10 <dmwit> The argument for spaces only is that you don't need to be careful and consistent.
02:25:30 <AfC> dmwit: though I specifically want to talk about memory management on the C side with someone who knows the internals.
02:26:15 <dmwit> I actually don't know all that much about the memory management of Gtk stuff. I know the current bindings work really hard to GC things correctly.
02:26:46 <AfC> dmwit: it's arcane, to be sure.
02:27:03 <hiptobecubic> shachaf, http://vpaste.net/lpjgd?ft=vim  :)
02:27:21 <dmwit> timthelion: In reality, there's nothing wrong with trailing spaces.
02:27:25 <dmwit> They just give me the heebie-jeebies.
02:27:31 <plat0> Did Yi ever get any good?
02:27:36 <hiptobecubic> they waste precious bytes
02:27:41 <AfC> dmwit: It's getting better, but there are some legacy APIs I'm still beating them over the head about it.
02:27:52 <dmwit> "them"?
02:27:56 <hiptobecubic> and screw up your copy-pasting
02:28:00 <AfC> dmwit: the GTK hackers
02:28:12 <shachaf> hiptobecubic: I think it's faster to type :%s/\s\+$//g than that long name/
02:28:15 <shachaf> s/.$/./
02:28:42 <timthelion> AfC: wait, what are you doing, with whom do you comunicate? I haven't seen you on the gtk2hs list
02:28:46 <AfC> dmwit: anyway, I figure since I already made the GTK2 → GTK3 transition in the bindings I maintain, I might be able to, if not lend a hand, at least help compare notes as you work through that.
02:29:00 <dmwit> oh yeah
02:29:08 <dmwit> dang, I've really been putting that off
02:29:21 <AfC> timthelion: I'm not on that list (or am I? Who knows, these days) I'm looking to chat with some of the gtk2hs people by IRC
02:31:16 <dmwit> Okay, I have to go to bed now.
02:31:35 <timthelion> AfC: it's just, that I want a say in how the next gtk2hs version will look. I want big changes :/
02:32:27 <AfC> timthelion: well, that's certainly not up to me. :)
02:32:46 <timthelion> OK
02:32:49 <AfC> timthelion: If we were talking about the language I *do* maintain, then sure, but Haskell, well that's up to the people who are doing the work here.
02:33:01 <timthelion> AfC:
02:33:03 <timthelion> OK
02:33:20 <AfC> timthelion: obviously I have some pretty fervent ideas about API design in bindings :)
02:34:14 <AfC> [it's a tough bridge to build; you want to be true to (ie) GTK in (ie) Haskell, but you need come up with an API that makes sense in your target language, which can be tricky as many of the [C] GTKisms don't translate]
02:34:20 * timthelion feels like he's the only one in the haskell community that takes GUI as a priority, rather than an after-thought front end.  And is appaled by the bad design of every GUI FFI that currently exists.
02:34:52 <AfC> anyway, I've been at it for 7+ years. It's hard work.
02:36:11 <AfC> timthelion: I think you're probably asking a lot; especially given the functional nature of Haskell vs the event driven & pseudo OO style of GTK; I daresay you'll have a hard time finding any designthat is going to make you happy --
02:36:17 <timthelion> AfC: Well the biggest upfront flaw(according to me) should be fixable.  It's that there is a global state, that is in no way contained.  If I could only have a GTK object, that was returned by initGUI, so I could run initGUI multiple times and have multiple such objects, with no overlap... But right now, things are just as anti-functional as they could get.
02:36:19 <AfC> -- without making your own [new] toolkit
02:37:51 <timthelion> Every single gui ffi currently has this pseudoglobal state.  It's not even global, because it's somehow bound to a thread.  In order to do multithreading, we need to have an object(certainly one with it's own OS thread) that is contained.
02:38:24 <Z`> when implementing >>= can I have both arguments to the right ? or one left one right ?
02:39:05 <typoclass> Z`: both are possible. you can do "x >>= y = ..." or "(>>=) x y = ..."
02:39:05 <timthelion> AfC: I'm actually as involved with the blind community as I am with haskell.  And I tell you, knowing the work that the screen reader people have put into GTK, I'd never dream of trying to replicate all that.
02:39:16 <Z`> thanks typoclass
02:39:37 <shachaf> Z`: The usual answer to a question like that is "try it out!". :-)
02:40:19 <Z`> ghci hates me, but you people are very kind :P
02:41:07 <timthelion> Perhaps Z` needs some hugs ^_^ <- evil eyes.
02:41:21 <Z`> hugs gives me great error messages
02:41:31 <Z`> but sometimgs it errors on code that ghc is fine with
02:41:37 * timthelion didn't know hugs still exists.
02:47:06 <lpvb> Z`: any operator can be written to the left if you put it in parenthesis
02:47:13 <lpvb> > (+) 2 3
02:47:14 <lambdabot>   5
02:47:27 <shachaf> > (`isInfixOf`) "a" "abc"
02:47:28 <lambdabot>   <no location info>: parse error on input `)'
02:50:07 <timthelion> shachaf: http://hackage.haskell.org/trac/ghc/ticket/7188
02:50:35 <shachaf> timthelion: What?
02:50:41 <shachaf> That's specified by the report to be that way.
02:50:44 <shachaf> It's not a GHC bug.
02:50:54 <timthelion> I know.
02:51:45 * timthelion isn't sure *why* the report specified it like that.
02:51:57 <plat0> Yes, what is the rationale for that?
02:52:08 <shachaf> Does it matter?
02:52:09 <typoclass> so the bug should have been filed against the report, not against ghc. seems almost like a technicality
02:52:21 <shachaf> The report doesn't take bug reports.
02:52:23 <hiptobecubic> that doesn't even make sense
02:52:46 <timthelion> shachaf: the report is perfect.  Like the bible.
02:53:33 <hiptobecubic> i don't even see what the 'bug' is
02:53:48 <hiptobecubic> div 3 4  is fine... why would you `div` 3 4?
02:54:01 <timthelion> hiptobecubic: well you would think that two infix operators would act the same way.
02:54:06 <AfC> timthelion: there's some things you need to know about GTK and threading. I'm going to be afk for a while, but if you'll be on in 3-4 hours, I'd be happy to chat with you about it.
02:54:30 <timthelion> AfC: I already know quite a bit.  I've written a lot of GTK threaded GUI :)
02:54:31 <AfC> timthelion: [and we'll do it in another channel so as not to be too OT for #haskell]
02:54:44 <timthelion> AfC: OK
02:54:54 <AfC> timthelion: I'm talking about from the bindings engineering standpoint, and also about the changes that are coming in GTK4
02:55:00 <timthelion> OK
02:55:04 <timthelion> thanks :)
02:55:24 <AfC> sure. You seem to be enthusiastic. Figure least I can do is help channel it a bit :)
02:55:28 <AfC> I'll ping you later.
02:55:36 <hiptobecubic> i thought `` was more of a magic trick to make otherwise normal functions work as infix. div is not an 'infix' anymore than map.
02:55:45 <hiptobecubic> any more*
02:56:14 <timthelion> hiptobecubic: I'd rather have regularities than magic tricks.  if ` makes something infix, it better be infix :)
02:56:34 <timthelion> hiptobecubic: remember, we're not talking about div, but `div` :)
02:56:40 <typoclass> > 3 `(div)` 2
02:56:40 * timthelion doesn't actually care. 
02:56:41 <lambdabot>   <no location info>: parse error on input `('
02:56:42 <hiptobecubic> `div`   is not a thing.
02:56:52 <hiptobecubic> :t `div`
02:56:53 <lambdabot> parse error on input ``'
02:57:00 <shachaf> Y'all should stop arguing about this.
02:57:05 <shachaf> You'll be happier.
02:57:12 * timthelion agrees with shachaf :)
02:57:25 <shachaf> Uh-oh.
02:57:30 <shachaf> This is a bad position to be in.
02:57:34 <hiptobecubic> shachaf, now you're dirty
02:57:42 * timthelion reported the bug as a joke, because, you know, it is technically fucked up...
02:58:01 * timthelion whipes his tim kudies off shachaf 
02:59:08 * hackagebot egison 2.4.3 - An Interpreter and Compiler for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.4.3 (SatoshiEgi)
03:00:24 <timthelion> Who names a programming language after themselves.  That just seems masochistic.
03:00:48 <hiptobecubic> "Egison has Twitter account. Please follow Egison."
03:01:40 <timthelion> Well the thing is, that when an Egison program doesn't work, you're just like "fuck egison" and you're actually cursing a human being instead of a blob of bytes.
03:02:07 <hiptobecubic> no, that's egisan. egison is just a language.
03:02:25 <timthelion> The nice thing about swearing at Haskell, is that Mr. Curry is long dead.
03:10:42 <amiller> if a bit is a unit of information
03:10:46 <amiller> is a cobit a unit of computation
03:11:13 <shachaf> If a cobit is a unit of computation, is a bit a counit of mputation?
03:11:33 <typoclass> *groaaan* =)
03:13:00 <paolino> hello everyone, is there a way to stop an accumArray after a given time, to get a statistic on samples, time bounded ?
03:13:14 <dzhus> Is there `uncurry` for 3-tuples?
03:13:41 <shachaf> paolino: You can time out an entire computation with "timeout".
03:13:51 <shachaf> But that'll just kill the thread wherever it is.
03:13:55 <shachaf> dzhus: No.
03:14:01 <t7> uncurry3
03:14:22 <shachaf> If you were to make that function, you might name it that.
03:14:58 <paolino> shachaf, what about the array ? It could be a ST feature to stop by IO ?
03:15:01 <lpvb> threadDelay says GHC only, what would a portable implementation of waiting be?
03:15:27 <shachaf> paolino: There is none.
03:15:49 <shachaf> But probably any other Haskell implementation that tries to be practical would implement it too.
03:16:02 <paolino> shachaf, it's for referential transparency ?
03:16:10 <shachaf> What?
03:16:24 <shachaf> paolino: Oh, that was meant to go to lpvb.
03:16:42 <paolino> not stop accumArray by IO
03:16:43 <t7> we need more haskell implementations
03:16:45 <shachaf> paolino: In general you can't "stop a computation in the middle" purely because of that sort of reason, yes.
03:16:59 <t7> maybe a subset of haskell should be standardized
03:18:05 <timthelion> t7: why would we want them?
03:18:17 <t7> because ghc is huge
03:19:13 <paolino> there is haskell platform
03:19:39 <timthelion> paolino: I think he wanst "hasekll platform mini"
03:19:50 <Tinned_Tuna> t7: There is a standard Haskell.
03:20:15 <Tinned_Tuna> as in, Haskell is a standardised language. GHC keeps on adding extensions and such, deviating from the standard.
03:20:32 <timthelion> With pink wheels and a blond chick wearring bug eye sunglasses.
03:20:39 <t7> yeah but its quite a big language with lots of redundant features
03:20:57 <t7> function groups and case statements, let and where
03:20:59 <t7> etc etc
03:21:24 <timthelion> t7: neither of those adds more than like 10-20 lines of code to GHC.
03:21:36 <t7> lisp -> scheme    haskell -> ?
03:21:53 <paolino> repa
03:21:57 <t7> timthelion: i bet its more
03:22:00 <timthelion> haskell -> SK
03:22:05 <t7> alot more, parsing etc
03:22:13 <SHAQQQQQQQRRRR> Tinned_Tuna, GHC is a superset of the standard right?
03:22:26 <paolino> t7 that is libraries
03:22:33 <Tinned_Tuna> SHAQQQQQQQRRRR: I believe so
03:22:50 <timthelion> t7: have you written a parser?  They require really very little code for such trivialities.
03:23:26 <Tinned_Tuna> t7: seriously, the difference between a parser which includes both let and where vs. one which contains only one is going to be tiny
03:23:35 <t7> removing function groups would simplify the AST
03:23:57 <Tinned_Tuna> t7: especially if it's written using a combinatoral parser library, such as parsec.
03:24:21 <t7> the point it: im sure theres more things that could be stripped out
03:24:37 <t7> and still leave a useful subset that could be experimented on
03:25:00 <paolino> many libraries are mere correct exercises, which looks good to me in the end (at least the correct part)
03:27:14 <fmap> SHAQQQQQQQRRRR: not really, for example, report specifies Num as `class (Eq a, Show a) ⇒ Num a where …' but in GHC it's just `class Num a where …'
03:27:57 <paolino> t7, It's good to see there are varying level of abstraction on the same pattern, because it takes time to climb them all. How could someone rule out the simpler ones ?
03:28:03 <ivanm> that's in Haskell' though, isn't it?
03:28:11 <ivanm> (the removal of superclasses for Num)
03:52:42 <paolino> unsafeRead and unsafeWrite ar not exported from MArray :-(
03:54:28 <paolino> does it mean every operation is wrapped in a bounds check for the index ?
04:03:18 <Z`> I a little confused. When we write a -> b -> c we mean a function that takes a and maps it to another function taking b and mapping to c
04:03:55 <Z`> would the a -> b -> c type signature be ok for both:  f x = ... and f x y = ... ?
04:05:49 <mysticc> @src foldl
04:05:49 <lambdabot> foldl f z []     = z
04:05:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:07:26 <paolino> Z`: a -> b ->c == a -> (b -> c)
04:07:26 <fmap> Z`: yes
04:07:39 <fmap> > let f :: a -> b -> c; f x y = f x y in f undefined undefined
04:07:42 <lambdabot>   mueval-core: Time limit exceeded
04:07:43 <fmap> > let f :: a -> b -> c; f x = f x in f undefined undefined
04:07:47 <lambdabot>   mueval-core: Time limit exceeded
04:08:21 <Z`> thank you fmap
04:08:32 <fmap> or even
04:08:36 <fmap> > let f :: a -> b -> c; f = f in f undefined undefined
04:08:40 <lambdabot>   mueval-core: Time limit exceeded
04:09:27 <Z`> or things like:    let f = x (\y -> x + y)
04:09:30 <Z`> er
04:09:34 <Z`> or things like:    let f  x = (\y -> x + y)
04:09:45 <Z`> and then f 1 2
04:12:44 <kstt> hello ! What do you think about the usage of String as the base type in the "directory" and "filepath" packages ? I'm more often embarassed than not with it, I'd often prefer to have a raw bytestring.
04:14:00 <kstt> are there equivalent packages based on bytestrings ?
04:14:34 <LambdaDusk> hi, I have a question regarding how [a] is a monad... does that mean the do notation concatenates?
04:15:18 <Botje> LambdaDusk: do notation is sugar for >>=, right?
04:15:25 <shachaf> kstt: It's kind of annoying.
04:15:27 <LambdaDusk> Botje: yes
04:15:38 <Botje> a >>= b will take each element of a in turn
04:15:41 <Botje> pass it to b
04:15:50 <shachaf> kstt: The Linux filesystem API is based on bytes; the Windows API is based on Unicode codepoints, I think (or UTF-16 code units, or something).
04:15:52 <Botje> and collect the resulting list into the result of a >>= b
04:15:55 <Botje> so ..
04:15:56 <shachaf> I don't know of another interface for it, though.
04:16:06 <Botje> > [ 1, 2, 3] >>= \x -> [x, -x]
04:16:07 <lambdabot>   [1,-1,2,-2,3,-3]
04:16:12 <merijn> LambdaDusk: The compiler literally translates do notation to >>= and >> so do notation will just behave like those two functions for a given monad
04:16:39 <merijn> > do { x <- [1..3]; [x, -x] }
04:16:40 <lambdabot>   [1,-1,2,-2,3,-3]
04:17:05 <Botje> merijn: right, thanks.
04:17:25 <LambdaDusk> > do { [1,2]; [2,3] }
04:17:26 <lambdabot>   [2,3,2,3]
04:17:33 <LambdaDusk> huh
04:17:51 <merijn> > [1,2] >> [2,3]
04:17:52 <lambdabot>   [2,3,2,3]
04:17:58 <merijn> > [1,2] >>= \_ -> [2,3]
04:17:59 <lambdabot>   [2,3,2,3]
04:18:15 <kstt> shachaf: ah, thx, i wasn't aware of the differences
04:18:25 <fmap> > concatMap (\_ -> [2,3]) [1,2]
04:18:26 <lambdabot>   [2,3,2,3]
04:18:37 <LambdaDusk> so I'll just keep away from it
04:18:41 <shachaf> kstt: Anyway, you're right and it's annoying, but I don't know a good solution.
04:18:43 <typoclass> shachaf: i thought it's technically bytes, but de-facto it's utf-8. "ls" for example will assume utf8
04:18:51 <typoclass> s/utf8/utf-8
04:19:08 <shachaf> typoclass: Right, but you can have a path that contains the byte 0xFF
04:19:29 <shachaf> I don't think you can open that path with the Haskell API, since there's no way to refer to it.
04:20:20 <kstt> typoclass: having conventions and restrictions on tools that need to display paths ( like ls ) is ok.
04:21:33 <typoclass> > "shachaf: you mean the haskell library would encode \xff to some two-byte utf-8 thingy, which is not what you meant to refer to, right"
04:21:34 <lambdabot>   "shachaf: you mean the haskell library would encode \255 to some two-byte u...
04:21:45 <merijn> If I have "MonadTrans t => Foo -> t IO ()" I guess I could just prefix it with "runIdent" to turn it into "Foo -> IO ()", right?
04:21:56 <kstt> that requires to decode the path through an encoding. However, I'm annoyed because my tools often don't need to display paths, and having String *as the base type* is not handy.
04:22:22 <shachaf> typoclass: Yes. 11000011 10111111
04:24:10 <darthdeus> 22]
04:24:10 <typoclass> i see the problem. to be fair, everybody uses shell scripts all the time, and there it's difficult to even support spaces and (afaik) nearly impossible to support \n in filenames
04:24:33 <Ferdirand> lies
04:24:35 <typoclass> but yeah, haskell should try harder and allow even the weirdest junk like 0xff
04:24:45 <shachaf> typoclass: It's not very impossible.
04:25:51 <darthdeus> hey guys, i know you probably hear this question all the time, but here it is anyway, since i never got a good answer ... I've been doing ruby for about 4 years, and I really want to learn some more functional programming ... the problem is I have no idea how to start, like what would be a good type of project to learn haskell
04:26:18 <shachaf> darthdeus: You should probably start by reading introductions.
04:26:29 <kstt> darthdeus: you can start by programming as much functionnaly as possible in ruby
04:26:37 <shachaf> Haskell is a pretty different langauge from what you're used to, and it'll probably take you longer to get to the point of doing useful things with it.
04:26:51 <typoclass> darthdeus: glad to hear it. check out the book LYAH, which is available free of charge
04:26:53 <typoclass> @where lyah
04:26:53 <lambdabot> http://www.learnyouahaskell.com/
04:27:20 <kstt> ruby can be programmed functionnaly quiet easily, though that will slow execution (even more ...)
04:27:33 <darthdeus> kstt: i try to program functionally, like I try to have as few side effects as possible and rather pass things around, which helps me when testing etc, but I still don't know where could I plug haskell in :)
04:27:51 <Botje> LYAH is so good, I bought a copy just to look at the pictures.
04:28:11 <darthdeus> thanks, i'll take a look at it
04:28:15 <kstt> LYAH is a good introduction indeed, consider buying it
04:28:19 <merijn> darthdeus: The biggest problem is that it will require quite some reading to get ready for writing some actual projects. Although I guess the easiest type of project would be some kind of parser using parsec?
04:28:32 <lpvb> Botje: for Great Good!
04:28:59 <lpvb> the sun says, "Holy shit!", it's so good
04:29:22 <merijn> hmm
04:30:06 <merijn> There's no (limited version) of "(a -> b) -> FunPtr (a -> b)"?
04:30:39 <shachaf> "limited version"?
04:31:15 <laurynne> LYAH is really good, but I was disappointed to see that the pictures are only greyscale when I bought the book :(
04:31:30 <merijn> shachaf: Well, I don't think I'd need one that works for arbitrary functions, some limited/statically known subset would be good enough
04:31:35 <lpvb> laurynne: awwwwwwww
04:31:38 <laurynne> but I can live with it ^^
04:31:45 <shachaf> merijn: Are you asking how to create a FunPtr?
04:31:48 <merijn> shachaf: I just don't see anything that returns a FunPtr in Foreign.Marshal/Foreign.Ptr
04:31:48 <tsou> laurynne: indeed, but color printing costs much more ;)
04:31:54 <merijn> shachaf: Pretty much
04:31:57 <shachaf> merijn: foreign import "wrapper"
04:32:24 <merijn> shachaf: Where are the docs for that?
04:32:47 <shachaf> merijn: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Ptr.html
04:32:59 <typoclass> just for the record, for a file with \n in the name, "echo *" produces one line in bash, two lines in zsh. so i don't think it's going to be fun and easy
04:33:16 <laurynne> tsou: yeah, and LYAH wouldn't really profit from colour printing aside from the pictures. I'm still frequently using the online version where they're nice to look at :)
04:33:20 <shachaf> merijn: It's documented in the Report.
04:33:37 <shachaf> merijn: So probably any documentation about the FFI will mention it somewhere.
04:33:43 <lpvb> laurynne: trat it like a coloring book :)
04:33:51 <lpvb> treat*
04:34:17 <merijn> shachaf: Blah, I glossed entirely over that example >.>
04:34:22 <laurynne> lpvb: I shall never lay a hand/pencil on my books O_O
04:34:27 <shachaf> merijn: http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1610008.5
04:34:47 <lpvb> laurynne: party pooper
04:34:49 <laurynne> I could never smear ink or something around in my precious books
04:35:10 <tsou> laurynne: why a book then? :P
04:35:34 <tsou> that's the point of books.. wonderful margins to write on
04:36:03 <laurynne> tsou: I admit, I sometimes make small annotations with a pencil
04:38:40 <tsou> laurynne: shame on you :P
04:40:22 <laurynne> tsou: I know ;(
04:42:35 <laurynne> as for "why a book": I just HAD to have that elephant on my bookshelf.
04:42:47 <tsou> understandable
04:43:02 <tsou> there's a colorful pdf if you prefer that though..
04:43:03 <laurynne> I always wanted to know, does he or she have a name, actually?
04:43:18 <Botje> I wonder if the elephant is a reference to dons...
04:44:25 <tsou> nah, probably just trying to steal some of the popularity of the elephant book on topos theory..  *obviously*.. :P
04:45:55 <LambdaDusk> Is there anyone around who can tell me why this happstack code doesn't work as I expect it to? https://gist.github.com/3655307
05:00:24 <merijn> LambdaDusk: Well, a description of A) what you expect it to do and B) what actually happens would be helpful
05:03:41 <merijn> You know, I'm starting to dig the FFI :D
05:04:10 <merijn> Haskell is debugging the ptr/type errors in my C interface for me \o/
05:05:21 <typoclass> @remember merijn Haskell is debugging the ptr/type errors in my C interface for me \o/
05:05:22 <lambdabot> Nice!
05:09:29 <merijn> Relatedly, someone here mentioned an (E)DSL for hsc2hs that would generated code from C headers?
05:09:35 <merijn> But I forgot what it's called...
05:14:43 <Guest7965> hello
05:15:00 <darthdeus> should I install haskell platform via http://hackage.haskell.org/platform/mac.html or via homebrew on mac?
05:15:01 <darthdeus> should I install haskell platform via http://hackage.haskell.org/platform/mac.html or via homebrew on mac?
05:16:05 <merijn> darthdeus: I always install from the website using the .pkg
05:16:31 <merijn> darthdeus: Compiling GHC takes ages and there's no real reason (since I mostly only use cabal to install haskell packages/dependencies)
05:16:32 <ivanm> merijn: you forgot the second answer!
05:16:50 <darthdeus> merijn: won't there be problems with dependencies?
05:17:37 <merijn> darthdeus: No, almost all libraries work out of the box, I've only had 1 or so library that required me to install an extra C library using macports
05:17:49 <darthdeus> merijn: cool, thanks
05:17:50 <merijn> ivanm: Weren't you the one that mentioned the hsc2hs DSL yesterday?
05:18:08 <ivanm> merijn: I highly doubt it
05:18:12 <ivanm> since I've never used hsc2hs
05:18:21 <shachaf> hsc2hs2h2
05:18:21 <merijn> blah, then I don't remember who >.>
05:18:33 <shachaf> merijn: Are you thinking of johnw?
05:19:02 <hiptobecubic> shachaf, yes.
05:19:06 <ivanm> merijn: https://bitbucket.org/mauricio/bindings-dsl/wiki/Home ?
05:19:06 <merijn> shachaf: He was working on a tool for that, I remember. But that doesn't actually compile yet
05:19:21 <merijn> Someone else mentioned some hsc2hs DSL separate from that
05:19:24 <ivanm> from parcs`
05:19:33 <ivanm> that's what grepping my logs reveals, anyway ;)
05:19:40 <ivanm> <parcs`>        merijn: for the most part bindings-DSL is self-contained and doesn't really require knowledge of hsc2hs's macros, so you can skip reading an hsc2hs tutorial
05:20:03 <merijn> ivanm: \o/
05:20:25 <merijn> I should maybe some time configure irssi to do logging...
05:20:35 <shachaf> No!
05:20:36 <shachaf> Don't log!
05:21:22 * ivanm can't tell if shachaf is being serious or not
05:21:47 <shachaf> Logging is bad.
05:21:49 <hiptobecubic> it's looog, looog, it's big, it's heavy, it's wood!
05:22:00 <ivanm> I quite like wooden furniture
05:22:09 <typoclass> you can just download the public logs. they're linked in the topic
05:22:11 <ivanm> and it's all sustainable growth anyway
05:22:52 <ivanm> typoclass: yes, but the timezones in them are all wrong!
05:22:59 <ivanm> they should be UTC+10!!! :p
05:29:26 <hpc> ivanm: ppsh, they should be in that one random timezone that's half an hour off
05:30:05 <ivanm> hpc: oh, you mean the timezone in South Australia?
05:30:45 <hpc> yes, except there seem to be many of those now
05:30:54 <hpc> and a +12:45 zone too
05:31:35 <typoclass> hpc: afaik about 20% of humanity lives in one of those weird 30-min timezones
05:31:47 * ivanm thinks #haskell and #haskell-blah have switched places again...
05:44:05 <AfC> timthelion:
05:44:10 <AfC> timthelion: ping
05:45:00 <timthelion> AfC: pong
05:45:09 <LambdaDusk> what is the simplest way to send a POST request in haskell?
05:45:52 <AfC> timthelion: → pm
05:46:53 <k00mi> LambdaDusk: probably simpleHTTP from the HTTP package
05:47:16 <typoclass> LambdaDusk: you could take a look at http-conduit
05:47:56 <LambdaDusk> typoclass: I did and there's a load of instances I would have to implement or something
05:48:22 <LambdaDusk> it seems to be an overkill for just a request that will most likely return 5 lines of JSON at max
05:49:51 <merijn> LambdaDusk: heh, what instance would you have to implement?
05:50:02 <kstt> conduit is quiet convoluted :/
05:50:07 <typoclass> LambdaDusk: have you seen http://hackage.haskell.org/packages/archive/http-conduit/1.6.0.1/doc/html/Network-HTTP-Conduit.html#g:3 ? i think you can insert that kind of code into the examples at the top of the page (2nd example)
05:50:51 <LambdaDusk> merijn: It is the classes necessary for ResourceT
05:50:57 <LambdaDusk> or rather runResourceT
05:51:06 <nand`> Is it possible to use GHC to type check and print warnings only, without actually producing output?
05:51:18 <LambdaDusk> merijn: because I am within a ServerPartT
05:51:34 <kstt> LambdaDusk: have a look at http-conduit
05:51:46 <danr> nand`: hmm. definitely possible if using ghc as an api, but otherwise I'm not sure
05:51:50 <luite> LambdaDusk: can't you liftIO out the part that does the http request?
05:52:31 <kstt> surprisingly, there isn't many http client library in haskell. http-conduit is quiet "conduit-tainted", conduit being itself quiet tainted in its style as well.
05:52:46 <danr> nand`: what about the -E option?
05:52:48 <LambdaDusk> luite: "No instance for (resourcet-0.3.3.1:Control.Monad.Trans.Resource.MonadResourceIO)"
05:53:08 <merijn> LambdaDusk: I don't think you have to implement a ResourceT just to run a simple post...
05:53:19 <merijn> kstt: I suspect you mean quite?
05:53:44 <nand`> oh, I figured I can just use ghci -Wall and :l the file
05:53:49 <luite> LambdaDusk:are you doing a runResourceT ?
05:53:59 <kstt> merijn: ahah, thank you for correcting me !
05:54:02 <luite> nand`: there is -fno-code, bit i think it will still generate some files
05:54:02 <danr> nand`: ok good, because the -E option was totally wrong ;)
05:54:06 <merijn> kstt: I only wrote a simple request runner to fetch some stuff from a site and http-conduit seemed perfectly simple for that?
05:54:21 <merijn> kstt: Unless you were trying to imply that conduits make very little sound... :p
05:54:22 <LambdaDusk> merijn, luite: I want to execute the checkAssertion method here: http://hackage.haskell.org/packages/archive/authenticate/1.3.1/doc/html/Web-Authenticate-BrowserId.html
05:54:30 <typoclass> kstt: i think it only looks convoluted. in the end it's quite simple to use. you need just a few lines of code, e.g. http://hackage.haskell.org/packages/archive/http-conduit/1.6.0.1/doc/html/Network-HTTP-Conduit.html
05:54:36 <kstt> indeed it is
05:54:42 <nand`> -fno-code seems to have worked fine, thanks luite
05:54:47 <nand`> no output either
05:54:55 <luite> ah good :)
05:55:08 <LambdaDusk> merijn, luite: It wraps a simple POST request, but I can't get it to work because of that error above
05:55:25 <merijn> LambdaDusk: You're gonna have to hpaste the code + full error
05:55:31 <LambdaDusk> luite, merijn: My code is this: https://gist.github.com/3655954
05:55:37 <merijn> (Preferably a minimal subset of the code that reproduces the error)
05:55:39 <LambdaDusk> or better hpaste?
05:56:41 <hpaste> LambdaDusk pasted “Auth.hs” at http://hpaste.org/74334
05:56:42 <merijn> oh, you're trying to use it from happstack?
05:58:14 <LambdaDusk> merijn: Yes, to create a route that verifies the browserId login
05:59:22 <merijn> ServerPart a seems to just be a transformer around IO
06:00:03 <luite> LambdaDusk: what's the full error?
06:00:15 <luite> it looks ok to me so far
06:00:18 <LambdaDusk> I pasted it in the source
06:00:28 <merijn> And I suspect IO is also an instance of resourceT, so turning them into each other should be easy, I think?
06:00:28 <LambdaDusk> from line 20
06:01:02 <luite> oh right, i was still looking at the github thing
06:02:23 <LambdaDusk> merijn: Obviously IO is not an instance of MonadResource
06:02:42 <LambdaDusk> oh god I am so stupid
06:02:50 <LambdaDusk> liftIO . withManager works fine
06:02:54 <luite> LambdaDusk: change checkAssertion audience assertion to runResourceT . checkAssertion audience assertion
06:04:15 <hpaste> LambdaDusk annotated “Auth.hs” with “Auth.hs (annotation)” at http://hpaste.org/74334#a74335
06:04:28 <luite> oh that also works, even easier :)
06:05:08 <LambdaDusk> sorry to have bothered you =/
06:10:19 <akamaus> Hi, I need to read portions of a huge binary file. What's the best approach?
06:11:05 <akamaus> I can use hGetBuf, but is there any higher level solution?
06:11:41 <hiptobecubic> is there a hGetContents in bytestring?
06:12:11 <hiptobecubic> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#v:hGetContents
06:12:11 <shachaf> @google is there a hGetContents in bytestring?
06:12:12 <lambdabot> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.8/doc/html/Data-ByteString-Lazy.html
06:12:12 <lambdabot> Title: Data.ByteString.Lazy
06:12:55 <Botje> akamaus: mmap the file and wrap a pointer in a ByteString or something?
06:13:30 <shachaf> /!\
06:14:00 <akamaus> Botje, I thought about it. The file is actually /proc/<pid>/mem. I'm not sure mmaping it is good idea :)
06:14:58 <shachaf> akamaus: maurer was working on a library that mmapped /proc/pid/mem
06:15:06 <Botje> akamaus: if you know an exact offset you can mmap a chunk of it.
06:15:10 <shachaf> @google maurer ptrace
06:15:12 <lambdabot> https://github.com/maurer/ptrace
06:17:31 <LambdaDusk> is a "newtype" instead of "data" always the better idea when it is possible to use it?
06:18:50 <hiptobecubic> /proc/<pid>/mem is what exactly?
06:19:04 <akamaus> shachaf, great! Will take a look, thanks a lot
06:19:29 <shachaf> @google what is /proc/pid/mem?
06:19:30 <lambdabot> http://unix.stackexchange.com/questions/6301/how-do-i-read-from-proc-pid-mem-under-linux
06:19:31 <lambdabot> Title: kernel - How do I read from /proc/$pid/mem under Linux? - Unix and Linux
06:19:32 <akamaus> hiptobecubic, it's a pseudofile which mirrors memory of some process
06:20:04 <Botje> LambdaDusk: yes.
06:21:05 <darthdeus> here's another dumb question for you guys, what does haskell compile to? does it have a VM?
06:21:37 <LambdaDusk> darthdeus: Haskell compiles to binary, like gcc does
06:21:39 <shachaf> Haskell doesn't compile to anything. It's a language.
06:21:59 <shachaf> You can interpret it or compile it or hang Haskell programs up on the wall.
06:22:00 <ddarius> While it's not surprising Wolfram|Alpha does this, using a cellular automata as a pacifier is a great idea.
06:22:13 <darthdeus> shachaf: theoretically or practically?
06:22:27 <shachaf> GHC compiles Haskell programs to lots of things, including C-- and LLVM and x86 machine code and interpreted bytecode.
06:22:30 <darthdeus> I mean if I was to write a web app in haskell, is it like framework specific if it compiles or interprets or whatever?
06:22:31 <shachaf> Hugs interprets it.
06:22:35 <darthdeus> oh
06:22:51 <ddarius> "Framework specific"?
06:24:02 <darthdeus> I just started looking into haskell like 3 hours ago, so I'm not sure how things work, but if I was writing a web app in ruby, it would still be interpreted by the ruby interpreter, but run in a web server ... but if haskell compiles to a binary, i'm not sure how that would work
06:24:20 <typoclass> darthdeus: most likely you'll use the compiler ghc and produce binaries. they run directly (they don't involve something like the java virtual machine)
06:26:37 <Botje> darthdeus: people typically deploy web applications as standalone web servers (on a weird port) and use apache or nginx or something to shove requests into it
06:26:59 <darthdeus> Botje: cool that makes sense
06:27:00 <shachaf> darthdeus: You probably should start with things that aren't web applications.
06:27:35 <darthdeus> shachaf: I want to start with something simple, but being a web developer for my whole programming career it's not that easy for me to find something suitable for my brain
06:27:35 <Botje> darthdeus: do you know how CGI works?
06:27:50 <shachaf> darthdeus: Anyway, the answer to your question is (a) Haskell is a language, and you can do lots of things with a language; (b) the main Haskell compiler, GHC, generates native machine code for your computer.
06:27:58 <Ferdirand> there's no VM but it is still worth mentioning the RTS, yes ?
06:28:07 <darthdeus> Botje: afaik it runs an arbitrary binary
06:28:08 <shachaf> darthdeus: OK, if you're "a web developer for my whole programming career" then you *definitely* shouldn't start with a web application.
06:28:14 <ddarius> Ferdirand: Not really.
06:28:44 <Botje> darthdeus: well, the whole weird-webserver culture derived from the fact that you need to start a whole new process for each CGI request
06:29:30 <darthdeus> Botje: oh so that's what basically what php does without an accelerator, it starts for every request separately right?
06:30:03 <darthdeus> shachaf: so far i've only found that functional languages are best for data processing and parsing, but i know that's a huge generalization
06:30:09 <Botje> you're probably thinking about mod_php there, which integrates a php interpreter into the webserver (don;t do that)
06:30:21 <Botje> but you can also run php using CGI
06:31:36 * ddarius awaits Botje saying something that will make his comments make sense.
06:32:09 <Botje> ddarius: no, just background information about why people deploy web apps as separate web servers
06:32:19 <Botje> but i'll go do something useful instead :)
06:33:08 <ddarius> Botje: At least for the life-time doing web application development was even remotely popular in Haskell, pretty much all web servers had means better than CGI for communicating to other processes.
06:33:49 <Botje> i'm not selling CGI :)
06:33:51 <merijn> darthdeus: The problem with webprogramming in haskell is that the more advanced/nice frameworks can be quite complex if you're not to familiar with haskell and some common libraries
06:34:29 <ddarius> Botje: Yes, but I'm not sure why you are bringing it up as I don't think that motivates any aspect of why web frameworks in Haskell are the way they are.
06:35:25 <darthdeus> merijn: so what would be another good fit for haskell in the web world if not a web application in itself ... like background processing, server monitoring etc., are there some good use cases? or am i just being too generic?
06:35:48 <Botje> as I read it, darthdeus was confused on how HTTP queries reach Haskell web apps ("ruby interpreter .. still run in a web server")
06:36:37 <merijn> darthdeus: I think writing simple networking software (or servers) in haskell is pretty easy, for example
06:36:54 <darthdeus> Botje: yeah my confusion is that for example in ruby, i would have a web server as a separate library, but if I compile haskell, I would have to compile that part into the application binary
06:37:19 <merijn> darthdeus: The problem is pretty much this, if someone asked you "what should I write in ruby?" or "what is ruby good for?" what would you answer (if we conveniently ignore the existence of RoR)
06:37:53 <darthdeus> well i would say i wouldn't write a banking system or airplane control
06:38:14 <osfameron> "whatever you want, it's turing complete"
06:38:41 <ddarius> osfameron: Better answer: "Nothing."
06:38:42 <matthiasgorgens> merijn: there are some things ruby isn't good for.
06:38:42 <darthdeus> the question is also related to the libraries/environment around the language, because for example ruby is largely defined by how rubygems work
06:38:51 <nand`> what does the GHC RTS *actually* do? garbage collection and threading?
06:38:56 <matthiasgorgens> merijn: eg very low level stuff.
06:39:16 <merijn> darthdeus: Well, there's WAI (Web Application Interface) which specifies an interface for web requests, so most frameworks end up producing WAI applications and there are some libraries which implement "runWaiApp" which essentially takes a WAI application and runs a daemon that executes that WAI app
06:39:29 <merijn> nand`: IO, thunk forcing
06:39:30 <darthdeus> i also wouldn't suggest ruby for anything like implementing a VM or doing desktop apps or whatever that needs to be fast, but i would recommend it for network and other things, where it doesn't matter that much how fast the raw execeution is
06:40:20 <matthiasgorgens> ruby is probably also need the right choice for when you basically want to guarantee correctness.
06:40:22 <darthdeus> merijn: hmm interesting
06:40:25 <matthiasgorgens> way too dynamic.
06:41:01 <otters> I can't parse the first sentence
06:41:20 <luite> merijn: IO isn't really special, it just applies functions
06:41:54 <merijn> darthdeus: I would recommend haskell for most things that aren't straight up high performance (games, number crunching). Actually I'd still use it for those, but only once you have an intuition for how much speed you need, because understanding haskell performance/optimisation can be tricky
06:42:10 <nand`> I figured thunk forcing would be taken care of the actual code
06:42:20 <ddarius> s/Haskell performance/software performance/
06:42:20 <merijn> luite: Sure, but still they're implemented in the runtime, no?
06:42:43 <nand`> by the*
06:43:14 <nand`> merijn: no I believe it translates directly down to code which is then ran in the usual way
06:43:14 <merijn> ddarius: Haskell is definitely on the trickier end of the language scale when it comes to cost models
06:43:36 <typoclass> darthdeus: i think haskell is a little weak at making gui programs, because getting gtk to work or wx might cost some effort (depending on what your OS is). apart from that, it's pretty awesome at everything :-)
06:43:48 <darthdeus> merijn: so would you say that haskell is "productive", as in if I compare ruby to java, i would say that i can write an app way faster in ruby ... but i thought because haskell is so static and kind of rigid it would be slow to write apps in ... again sorry for a generalization
06:44:02 <luite> merijn: nah i mean that some x :: IO a is compiled to some function x :: v -> IO (# a, v #) ghc compiles "running" x to case x v of ...
06:44:04 <matthiasgorgens> typoclass: yeah, and that's mostly a library issue.
06:44:13 * hackagebot esqueleto 0.2.2 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2.2 (FelipeLessa)
06:44:15 <merijn> darthdeus: I come from a python background and I'd say haskell is much easier/faster to write
06:44:16 <matthiasgorgens> darthdeus: haskell is static, but not rigid.
06:44:44 <luite> merijn: so what i meant is that in the end, IO actions don't really look different from other functions
06:44:56 <matthiasgorgens> darthdeus: type inference also removes most of the burden of static typing.
06:45:05 <nand`> once you get used to it, Haskell is very fast for prototyping and producing code quickly
06:45:08 <merijn> darthdeus: Haskell's type system is *much* more expressive than anything you have worked with. It can take some time to learn and get used to the type system, but when you do you most likely won't want to go back
06:45:21 <matthiasgorgens> luite: aren't IO actions and functions something completely different?
06:45:22 <luite> merijn: except that v is a void argument, so it doesn't really have to pass it. So you get a thing that behaves like a function without the overhead of passing arguments
06:45:24 <nand`> the strong static typing isn't a hindrance when you know in advance what your types are going to look like, which is something that requires a bit of experience
06:45:29 <darthdeus> hmm this is really interesting, i thought it would be quite the opposite
06:45:45 <luite> matthiasgorgens: yes in haskell, but this is what it's compiled down to
06:45:48 <darthdeus> because everywhere I read that haskell is the most "static" language there is
06:45:50 <matthiasgorgens> darthdeus: could you elaborate what you mean by opposite?
06:45:58 <matthiasgorgens> luite: oh, ok.
06:46:06 <nand`> darthdeus: it's not the most static language ‘there is’; I could invent one that's more static
06:46:06 <typoclass> darthdeus: yup, the difference is that haskell has powerful type inference (java hasn't). you could say it gives you much of the dynamic feel (no declaring types over and over again), while still giving you all the compiler assistance and safety (much more than java, for instance)
06:46:13 <matthiasgorgens> darthdeus: yes, it is static.  but in a very technical sense of the word.
06:46:25 <nand`> static, to me, means ‘you know a lot at compile time’
06:46:28 <nand`> like
06:46:28 <darthdeus> matthiasgorgens: well if I hear static language that compiles to binary, I think of C++, which to me is the last language to think of as easy/fast to write apps in
06:46:35 <luite> matthiasgorgens: at this point, type classes also don't exist anymore, everything has been replaced with dictionaries
06:46:40 <nand`> if you have static guarantees of something, you know at compile time that the guarantee is inevitably true
06:46:41 <matthiasgorgens> c++ is as far away from haskell as you can go.
06:46:47 <merijn> darthdeus: The workflow I have (for example in my current project) is that I start writing down type signatures of functions I want, defining types as I go (with no "implementation")
06:46:57 <tdammers> matthiasgorgens: not true. Because PHP.
06:47:06 <nand`> haskell's type system and semantics great for enforcing static guarantees
06:47:07 <matthiasgorgens> tdammers: that's a different direction. :o)
06:47:09 <darthdeus> tdammers: PHP is not a language :P
06:47:20 <matthiasgorgens> tdammers: I was also thinking about adding perl as an exception.
06:47:29 <merijn> darthdeus: Then I start slowly filling in actual implementations for my type signature, by calling (as yet unimplemented) functions and as I go I add more type signatures and slowly flesh out functions + types
06:47:48 <matthiasgorgens> merijn: and while you are at it, the compiler will catch lots of mistakes.
06:47:52 <nand`> darthdeus: also, strong static typing makes refactoring a lot easier
06:47:54 <matthiasgorgens> that otherwise you'd only see at runtime.
06:47:59 <darthdeus> merijn: hmm, that sounds like nothing i've ever done before ^^ i totally have to give this a try
06:48:04 <matthiasgorgens> nand`: yeah, you know when you are finished. :o)
06:48:07 <nand`> exactly
06:48:11 <merijn> darthdeus: The type checker can then tell me whether my implemented function (using 5 completely non-existent functions) actually has the correct type
06:48:16 <nand`> you change one thing and the compiler tells you everything else you need to adjust
06:48:21 <matthiasgorgens> nand`: though, we would do better, if we had more IDE support.
06:48:26 <nand`> perhaps
06:48:33 <tdammers> one could say that PHP is to other programming languages what slapping someone in the face, stealing their food and then pissing on their doormat is to English
06:48:33 <nand`> not really a fan of IDEs
06:48:33 <matthiasgorgens> we scrape by without, because haskell has this nice compiler.
06:48:50 <matthiasgorgens> nand`: or IDE is the wrong word.  i mean tools for manipulating code.
06:48:53 <frerich> darthdeus: One concern I used to have about Haskell is that all the fancy type safety requires that you know where you want to go. If you're just sketching things and you're prototyping, it may be cumbersome and slow you down. However, I then realized that you can use 'undefined' in basically all places to have a "filler" value. Like, you can have functions, write their signatures like "isValid :: String -> Bool"
06:48:53 <frerich>  and then just write "isValid = undefined". This will cause a run-time error, but the code compiles and you ca start using the function i other places (and you can put functios together as you like).
06:48:55 <merijn> matthiasgorgens: Peaker is working on a structural editor, if that pans out we won't need an IDE
06:48:55 <nand`> if it wasn't for hoogle and hayoo I'd definitely want an IDE with tab completion/inline docs
06:49:00 <matthiasgorgens> in a more structured fashion than a general purpose text editor.
06:49:04 <nand`> matthiasgorgens: you might be interes-- yeah, Peaker's editors
06:49:13 * hackagebot esqueleto 0.2.3 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2.3 (FelipeLessa)
06:49:28 <merijn> matthiasgorgens: https://github.com/Peaker/bottle
06:49:44 <darthdeus> frerich: wow that's really cool
06:49:46 <typoclass> frerich: you don't _have_ to write type signatures when sketching. i thought everyone left them most of them out at first, and added them when things got stable
06:49:56 <matthiasgorgens> nand`: hayoo and hoogle are great.  especially hoogle shows off the advantages of haskell's type system for documentation purposes.
06:50:05 <matthiasgorgens> merijn: thanks.
06:50:06 <merijn> darthdeus: I started my programming career learning Java/C++, then I learned Python and I learned that strong/static typing sucked
06:50:17 <darthdeus> ok while you're guys at IDEs, how's the support in emacs/vim/sublime?
06:50:30 <shachaf> darthdeus: Have you seen the FAQ, by the way?
06:50:30 <matthiasgorgens> typoclass: depends.  sometimes I write the signatures first, sometimes the definitions.
06:50:31 <merijn> darthdeus: 3-4 years later I started learning haskell and realised I don't hate strong/static typing, I just hate Java/C++'s typing :p
06:50:35 <nand`> emacs has some fancy haskell-modes
06:50:39 <shachaf> Many of the questions you're asking have been asked many times before.
06:50:40 <nand`> I've heard vim has them too but I don't use it
06:50:40 <shachaf> @where faq
06:50:40 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
06:50:43 <Peaker> merijn, heh, just showed bottle off to some people :)
06:50:45 <matthiasgorgens> typoclass: depends on how I approach a specific problem.
06:50:49 <frerich> typoclass: For me it's the other way roud - I always write the types (that includes the types of my functios, i.e. the type signatures) up front but leave the implementation 'undefined'. I can actually flesh out large parts of my program like that, just by combining signatures - without implementing anything.
06:50:51 <darthdeus> shachaf: i'll take a look at it
06:51:17 <merijn> Peaker: What was the response?
06:51:32 <lpvb> has anyone worked with aeson? I'm trying to get it to parse an object with an arbitrary numbeer of key:value pairs into a Map k v or [(k,v)], but it keeps returning Nothing
06:51:34 <typoclass> frerich: interesting, i wouldn't have thought to do it that way
06:51:52 <matthiasgorgens> frerich: both approaches are useful.  for example, sometimes when I break up a big function into smaller ones, I just move the code around, and add the types later.
06:52:02 <Peaker> merijn, "cool" :)
06:52:08 <Peaker> merijn, we've made lots of progress
06:52:20 <nand`> I tend to approach a problem like this: 1. figure out what I want to model and choose an appropriate type for it (defining my own if necessary); 2. figure out what transformations I want to model and start implementing these. if I need some helper function, I'll recurse into that afterwards
06:52:32 <merijn> frerich, typoclass: I work that way too, although I've now started to use "error "foo not implemented"" instead of undefined, since that helps you if you forget an undefined somewhere :p
06:52:33 <matthiasgorgens> typoclass: but often, you can give the types first.  and if you chose them right, there will be only one obviously correct solution.
06:52:45 <shachaf> merijn: Soon GHC will have holes!
06:52:48 <nand`> as a consequence I usually define all of my types before writing a single function
06:52:51 <fmap> lpvb: consider pasting the code with some sample inputs/outputs
06:52:51 <merijn> shachaf: <3
06:52:57 <merijn> shachaf: How soon?
06:52:59 <matthiasgorgens> merijn: grep -RI undefined .
06:53:01 <nand`> 7.6?
06:53:03 <shachaf> merijn: I don't know.
06:53:07 <merijn> :(
06:53:14 <lpvb> fmap: okay
06:53:43 <merijn> shachaf: Now I just need Epigram style program-derivation :p
06:53:52 <shachaf> merijn: And dependent types!
06:54:06 <nand`> Epigram's syntax looks funky (the ASCII one)
06:54:33 <merijn> nand`: Yeah, that just means we need a structural editor with unicode support!
06:55:09 <nand`> merijn: a structural editor that displays code in the LaTeX style would be interesting
06:55:22 <nand`> like, you see this while editing: https://upload.wikimedia.org/wikipedia/en/math/c/0/1/c012cc213bfb3429116b81ce952050bb.png
06:55:42 <matthiasgorgens> nand`: a bit like emacs with auctex mode?
06:55:51 <nand`> no idea what that is
06:55:59 <matthiasgorgens> basically you write your tex in ascii,
06:56:06 <matthiasgorgens> but when your cursor isn't over a specific part,
06:56:13 <matthiasgorgens> you get the LaTeX preview.
06:56:27 <nand`> ah; I meant a bottle-style structural editor where you never write the actual syntax
06:56:27 <matthiasgorgens> so you can write in ascii syntax, but see the nicely typesetted formulas.
06:56:34 <matthiasgorgens> nand`: ok.
06:57:00 <matthiasgorgens> but, how do you put in stuff like -> and all the other crazy symbols?
06:57:12 <matthiasgorgens> I'm ok with using ascii approximations as input,
06:57:18 <matthiasgorgens> because my keyboard is quite good at them.
06:57:26 <matthiasgorgens> and then getting it displayed in a nicer format.
06:57:31 <matthiasgorgens> (interactively.)
06:57:43 <nand`> I think in bottle you don't actually type out the ->, you'd press a button to ‘go to the next type’ in the type sig
06:57:45 <matthiasgorgens> otherwise I'll either need a bigger keyboard, or use the mouse or so.
06:57:48 <nand`> or something to that effect
06:58:00 <nand`> and the -> would be inserted as a consequence (assuming you don't leave it empty)
06:58:43 <nand`> but this is only a spontaneous idea, it's not like I've sketched out how it would work for epigram or anything - I don't even know epigram, for starters
07:00:53 <merijn> nand`: I don't think anyone does, except McBride xD
07:01:32 <nand`> heh
07:04:09 <Peaker> nand`, in bottle, most of the time you don't type the (->) because it is inferred
07:04:24 <Peaker> nand`, but in general, you just choose (->) like you choose operators, in the hole, and then you navigate between its holes
07:04:35 <Peaker> nand`, you can play around with it now :)
07:07:24 * byorgey tries building bottle
07:10:00 <merijn> Is FlexibleInstances considered acceptable to use?
07:10:19 <shachaf> Yes.
07:10:23 <merijn> (Also, did GHC have type level naturals already?)
07:10:53 <shachaf> 7.6
07:10:57 <merijn> Damn!
07:10:57 <byorgey> merijn: 7.6.1 has limited support for type-level naturals
07:11:07 <byorgey> but I emphasize the "limited" part
07:11:36 <merijn> byorgey: I just need to enforce list lengths based on type
07:11:46 <byorgey> IIUC, the domain-specific constraint solver is not really ready for primetime
07:12:14 <byorgey> merijn: it's not too bad to do that by just promoting  data Nat = Zero | Succ Nat
07:12:20 <merijn> i.e. "(a -> a -> b) -> [a](length == 2) -> b"
07:12:22 <byorgey> and writing an addition type family yourself
07:12:26 <typoclass> byorgey: does it do "hour is an int >= 0 and <= 23"? it doesn't really, right?
07:12:36 <byorgey> typoclass: no, that's different
07:12:51 <typoclass> right
07:12:57 <merijn> byorgey: I've never used type families, any recommend intro/tutorials?
07:13:16 <shachaf> I don't think you need type families for that.
07:13:25 <hiptobecubic> what is a type family?
07:13:32 <hiptobecubic> and how is it different from a class?
07:13:34 <Jello_Raptor> o/
07:13:40 <hpaste> merijn pasted “Dirty things I do with typeclasses” at http://hpaste.org/74340
07:13:42 <shachaf> @google what is a type family? haskell
07:13:43 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
07:13:43 <lambdabot> Title: GHC/Type families - HaskellWiki
07:13:58 <typoclass> merijn: dunno about type families specifically, but very often the chapters in the ghc user guide are well-written and/or have links to papers
07:14:00 <hiptobecubic> shachaf, alright. Next time I'll try your voodoo
07:14:25 <hpaste> JEllo pasted “Emun stupidity” at http://hpaste.org/74341
07:14:31 <Jello_Raptor> :o
07:14:37 * typoclass thinks the user guide is underrated anyway
07:14:38 <Jello_Raptor> hpaste does that automatically?
07:14:56 <typoclass> Jello_Raptor: yup
07:14:57 <Jello_Raptor> anyway, there has *got* to be a better way to do that
07:16:14 <byorgey> Jello_Raptor: add  'deriving Show'  to the end of your data declaration, and then do something like  dnaToChar Gap = '-'; dnaToChar d = head (show d)
07:16:28 <byorgey> Jello_Raptor: incidentally, funtion names may not begin with a capital letter
07:16:29 <typoclass> Jello_Raptor: you could stick a "deriving (Read, Show)" on your data, and then ... er, yeah
07:17:02 <hiptobecubic> oh wow
07:17:06 <hiptobecubic> this is nice
07:17:08 <Jello_Raptor> byorgey: typoclass: thanks, this is me jumping back into haskell for the first time after having read LYAH a few months back
07:17:24 <byorgey> Jello_Raptor: cool, welcome back =)
07:18:46 <Jello_Raptor> thanks :)
07:19:13 <typoclass> Jello_Raptor: tangentially, somethingToOther is of course common, but it's also common to just say fromDNA and toDNA. it's slightly shorter and possibly clearer
07:19:24 <Jello_Raptor> also is there a list of style standards for haskell? stuff that everyone follows, like the function thing?
07:19:37 <Jello_Raptor> typoclass: thanks :)
07:20:20 <lpvb> fmap: I got it, it was just a stupid mistake of feeding it the wrong data
07:21:09 <byorgey> Jello_Raptor: there is a very nice style guide here: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
07:21:13 <matthiasgorgens> Jello_Raptor: there's the haskell style checker, and hlint.
07:21:28 <byorgey> Jello_Raptor: though you'll find that not necessarily everyone follows exactly those conventions
07:22:03 <Jello_Raptor> byorgey: right, it's just that I like learning with the proper style conventions so I don't have to change later.
07:22:05 <byorgey> Jello_Raptor: wait, "like the function thing", you mean what I said about capital letters?
07:22:21 <byorgey> Jello_Raptor: that's not a style issue, the language does not allow functions to begin with capital letters.
07:22:22 <typoclass> Jello_Raptor: turning on warnings (-Wall) is a good idea once your code has a little stabilized. and you can always put your program on hpaste and ask in here
07:22:51 <merijn> Although I'd recommend "-fno-warn-unused-do-bind" with -Wall >.>
07:23:11 <danr> @hoogle void
07:23:11 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
07:23:11 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
07:23:11 <lambdabot> package void
07:24:09 <matthiasgorgens> danr: Control.Monad.void is probably the one you want.
07:24:29 <danr> matthiasgorgens: yes :) I was silently looking at merijn actually
07:24:34 <matthiasgorgens> there's also the more general <$ in Control.Applicative.
07:24:50 <matthiasgorgens> danr: oh, ok.
07:25:59 <mm_freak> :t fmap . const
07:26:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
07:26:19 <matthiasgorgens> :t (<$)
07:26:21 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
07:26:27 <matthiasgorgens> same thing.
07:26:35 <mm_freak> no, i want the other type!!
07:27:01 <matthiasgorgens> yeah, the other type is alphabetically ordered.
07:27:03 <matthiasgorgens> that's better.
07:27:27 <merijn> danr: Prefixing tons of lines with "void $" reads terrible
07:27:29 <mm_freak> way better…  makes your code moaar awesome
07:27:46 <shachaf> > length "_<-"
07:27:47 <lambdabot>   3
07:28:00 <merijn> shachaf: *shudder*
07:28:06 <mm_freak> i really wonder how people actually need 'void'
07:28:07 <typoclass> merijn: i like "_ <-", but yeah, it might be annoying if you have a lot of functions that yield a mostly-useless value
07:28:17 <shachaf> @ty when
07:28:18 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:29:43 <matthiasgorgens> mm_freak: to make the typesignatures come out right.
07:29:52 <typoclass> conjecture: if void had been around at the time, people wouldn't have only made mapM, but not mapM_
07:29:56 <matthiasgorgens> for the last line in a do-block.
07:30:13 <matthiasgorgens> typoclass: why?  that relies on lazyness, doesn't it?
07:30:27 <mm_freak> matthiasgorgens: in those rare cases i return ()
07:30:28 <matthiasgorgens> to make the compiler figure out, that it doesn't have to make the list, and then throw it away?
07:31:05 <typoclass> no i meant just from the user perspective. "i don't care about the return values" could be expressed by "void $ mapM"
07:31:11 <mm_freak> typoclass: your conjecture is wrong
07:31:24 <matthiasgorgens> typoclass: but is ghc currently smart enough, to make those equivalent?
07:31:29 <mm_freak> typoclass: compare the types of mapM (void f) and mapM_ f
07:31:35 <mm_freak> typoclass: compare the types of mapM (void . f) and mapM_ f
07:31:50 <typoclass> matthiasgorgens: no idea
07:32:05 <danr> @hoogle comparing void -- this is a pretty neat use of void
07:32:05 <lambdabot> Parse error:
07:32:06 <lambdabot>   comparing void -- this is a pretty neat use of void
07:32:06 <lambdabot>                  ^
07:32:12 <danr> @type comparing void -- as a type
07:32:13 <lambdabot> Not in scope: `void'
07:32:16 <danr> :(
07:32:26 <matthiasgorgens> to make (mapM_ f) compile to the same code as (void . mapM f).
07:32:32 <mm_freak> typoclass: then compare void (mapM return [1..]) to mapM_ return [1..]
07:32:47 <mm_freak> GHC is not smart enough
07:32:49 <mm_freak> it can't be
07:32:54 <matthiasgorgens> why not?
07:32:58 <mm_freak> because such a transformation would change semantics
07:33:15 <matthiasgorgens> mm_freak: how?
07:33:17 <merijn> typoclass: Especially with the state lenses like += it quickly looks awful
07:33:18 <nand`> oh, void as in Functor f => f a -> f (); I was thinking void :: Void -> a
07:33:26 <matthiasgorgens> you could make currently make it with rewrite rules.
07:33:48 <matthiasgorgens> -make.
07:34:44 <mm_freak> there are many things you could make, but not everything is correct
07:34:53 <mm_freak> reverse . reverse = id?  no!
07:35:46 <matthiasgorgens> ok, so how does (void . mapM f) change semantics?
07:35:46 <mm_freak> if the transformation optimizes your program, that's fine…  it if changes your program's meaning, that's very bad
07:35:56 <matthiasgorgens> I just don't see it.
07:36:14 <matthiasgorgens> there are no side-effects in making the list, or are there?
07:36:16 <mm_freak> not sure, but i would be very wary about such a transformation when it comes to monads with strict bind
07:36:43 <matthiasgorgens> hmm, ok.
07:38:26 <mm_freak> changing bottom to something defined would be the worst case =)
07:39:01 <mm_freak> at least from a theoretical standpoint
07:39:16 <mm_freak> also i really prefer to write mapM_ ;)
07:39:30 <mm_freak> the void function is really ugly in code
07:40:27 <yogsototh> I am reading http://blog.sigfpe.com/2008/12/mother-of-all-monads.html but
07:40:35 <mm_freak> also i think that (<$) has a very bad name, because i mostly use it in compositions…  a wordy name would be better
07:40:54 <yogsototh> import Control.Monad.Cont does not provide a Cont datatype (only ContT)
07:41:05 <matthiasgorgens> mm_freak: i agree about <$.
07:41:11 <mm_freak> yogsototh: Cont is defined in terms of ContT
07:41:20 <applicative> Cont is a type synonym, yogsototh
07:41:24 <mm_freak> yogsototh: type Cont r = ContT r Identity
07:41:34 <matthiasgorgens> mm_freak: you could use the (->r) Monad though. :o)
07:41:34 <JustSomeGuy> hi is there any general purpose template engine? i want to use something like hakyll for bash script generaton
07:41:55 <yogsototh> thanks! mm_freak
07:42:06 <byorgey> yogsototh: yes, that changed since that blog post was written.  Use the 'cont' function in place of the Cont constructor
07:43:08 <yogsototh> Thank you byorgey
07:43:52 <mm_freak> matthiasgorgens: i don't understand your last remark
07:44:24 <matthiasgorgens> mm_freak: if you use <$ in compositions,
07:44:43 <matthiasgorgens> you can use (->r) to deal with the extra argument.
07:45:01 <matthiasgorgens> (<$) a <$> f
07:45:02 <matthiasgorgens> or so.
07:45:10 <hpaste> dongwusch pasted “Problem understanding error” at http://hpaste.org/74344
07:45:18 <matthiasgorgens> that would be besides the point, of course.
07:45:32 <dispy> could you explain to me what this error means in fact? http://hpaste.org/74344
07:45:40 <dispy> what is this "a0" ?
07:45:42 <matthiasgorgens> since when you use (<$) with the parens around it, you might as well stick to . instead of fmap / <$>
07:47:25 <matthiasgorgens> dispy: what's the type of extractSubList?
07:47:37 <dispy> extractSubList :: Position -> [Integer] -> Direction -> Integer -> [Integer]
07:47:41 <matthiasgorgens> you probably forget parentheses around the last two argument?
07:47:49 <matthiasgorgens> hmm, no.
07:48:07 <matthiasgorgens> or, yeah.
07:48:24 <matthiasgorgens> basically, extractSubList + four arguments gives you a value.
07:48:31 <dispy> yes
07:48:32 <matthiasgorgens> but . expects a function on the right.
07:48:42 <typoclass> dispy: the type of (.) is "(b -> c) -> (a -> b) -> (a -> c)". this means it expects two functions
07:48:44 <dispy> ah well
07:48:56 <dispy> easy. thanks ;)
07:49:03 <dispy> I just didn'T get the error message
07:49:10 <copumpkin> typoclass: at least two!
07:49:10 * typoclass thinks this sort of error message could be improved if ghc printed out the type of the offending function (.)
07:49:30 <oka_> sort [6927,661,9999]
07:49:46 <matthiasgorgens> oka_: you have to tell lambdabot to pay attention.
07:50:11 <typoclass> copumpkin: how would one (.) take more than two arguments?
07:50:22 <copumpkin> :t (.) ?f ?g (+1) (+2) (+3) (+4)
07:50:23 <lambdabot> forall a t a1 a2 a3 a4. (?f::a -> (a2 -> a2) -> (a3 -> a3) -> (a4 -> a4) -> t, ?g::(a1 -> a1) -> a, Num a1, Num a2, Num a3, Num a4) => t
07:50:26 <oka_> ?
07:50:55 <oka_> delete.you
07:51:57 <matthiasgorgens> typoclass: actually, (.) only takes one argument..
07:52:37 <typoclass> copumpkin: hmm ... not sure. doesn't work in my ghci. i suspect it's caleskell treating (.) a little differently than Prelude
07:53:15 <copumpkin> typoclass: works fine in mine
07:53:15 <typoclass> (i pasted the type above from Prelude and didn't do ":t (.)". i felt very clever.)
07:53:23 <copumpkin> you need to enable implicit params
07:53:49 <copumpkin> typoclass: basically, the a and c type vars can be instantiated to other functions
07:53:49 <dispy> wow. deeply impressed
07:53:58 <copumpkin> :t (.)
07:53:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:54:03 <copumpkin> gah
07:54:07 <copumpkin> :t (P..)
07:54:08 <lambdabot> Couldn't find qualified module.
07:54:12 <copumpkin> :t (Prelude..)
07:54:13 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:54:17 <dispy> Haskell is really funny. It takes me an awful lot of time to get the program run. But once it does - it does. It gave me the correct answer right off the bat ;D
07:54:28 <typoclass> i meant, this works "(.) (+1) (+2) 5" while this doesn't "(.) (+1) (+2) (+3) (+4) 5"
07:54:56 <nand`> dispy: with a little experience, getting it to run will be fast as well :)
07:55:05 <dispy> ;-)
07:55:05 <matthiasgorgens> nand`: undefined helps.
07:55:12 <nand`> matthiasgorgens: true..
07:55:17 <matthiasgorgens> nand`: but you are less likely to get the right answer off the bat, then.
07:55:33 <nand`> perhaps if you add an assumption that you get an answer at all
07:55:38 <matthiasgorgens> for very understated values of "less likely".
07:55:51 <nand`> then you could define main = main and get a program that runs
07:55:57 <nand`> and if it produces an answer, it will be correct
07:56:13 <matthiasgorgens> nand`: ghc detects that and print <<loop>>, i think.
07:56:17 <typoclass> copumpkin: er wait, it'd work if i plugged in (.) for ?f and also for ?g, is that what you meant?
07:57:40 <nand`> matthiasgorgens: yeah, you're right. hmm
07:58:07 <nand`> main = return (last [0..]) then :D
07:58:11 <typoclass> ah well whatever. less thinking more programming :-)
07:58:35 <nand`> :t (Prelude..) . (Prelude..)
07:58:36 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:58:42 <nand`> there you go, expects more arguments
08:01:01 <_flow_> Is it possible to use STM together with a mutable map?
08:01:39 <merijn> _flow_: Without any STM experience I'm going to say "probably"
08:01:49 <matthiasgorgens> _flow_: what do you mean by "together"?
08:01:56 <danr> what do you mean by mutable map?
08:02:06 <mm_freak> nand`: that program will happily do nothing
08:02:11 <mm_freak> (main = return undefined)
08:03:00 <Cale> _flow_: sure, but it's a little unusual to even bother with anything finer-grained than TVar (Map a b)
08:03:00 <_flow_> matthiasgorgens: I need a concurrent map. I current use just STM with map. But if I have many keys (>100000) the GC runs amok
08:03:15 <Cale> hmm
08:03:22 <nand`> mm_freak: oh right, it just returns right away
08:03:23 <t7> haskell doesnt let you shadow type names, right?
08:03:37 <mm_freak> t7: inter-module you can
08:03:45 <_flow_> I am not sure if it's related to the map. But I suspect that every atmotic transaction creates a new map. is this true?
08:03:53 <nand`> but that's not shadowing is it? you still can't refer to either type without disambiguating
08:03:58 <mm_freak> _flow_: if the map has changed, yes
08:04:08 <matthiasgorgens> _flow_: so you want, Map k (TVar v)?
08:04:11 <mm_freak> _flow_: but if the change is small, most of the map is just shared
08:04:23 <Cale> _flow_: Yes, but that usually only involves constructing a few new nodes
08:05:16 <_flow_> so if i insert a new item into the map only the new item is added and everything else isn't moved
08:05:17 <Cale> _flow_: When you do an insert in a Data.Map for example, only the O(log n) path between that element and the root needs reconstruction, and everything else is shared
08:05:33 <_flow_> ahh ok
08:06:20 <Cale> (well, it's not *just* the path directly, but a slightly wider swath in general to allow for rebalancing, but still O(log n) in size)
08:06:46 <_flow_> Maybe i need to investige first what causes all the garbage. Any suggestions to do so?
08:08:22 <Cale> You can do a normal profile and look at what does all the allocation.
08:08:53 <_flow_> Cale: simply with +RTS -p?
08:08:57 <Cale> yeah
08:09:01 <Cale> (and possibly compare that with a heap profile to see what's actually in memory)
08:09:05 <matthiasgorgens> _flow_: why do you use the Map in the first place?
08:09:22 <matthiasgorgens> perhaps we can come up with another data structure that's more apt?
08:09:29 <matthiasgorgens> or structure for your program.
08:09:33 <_flow_> matthiasgorgens: I am open to alternatives. I need to map a lot of keys to values :)
08:09:36 <matthiasgorgens> but yeah, profiling goes into the same direction.
08:09:53 <_flow_> I also tried the hashtables package
08:09:59 <matthiasgorgens> _flow_: do you have your program online somewhere?  github or hpaste or so?
08:10:44 <_flow_> Not public yet. But I can give you access if you are interested
08:11:04 <matthiasgorgens> _flow_: thanks.
08:11:35 <matthiasgorgens> _flow_: have you considered just binding to postgres, or something like that?
08:12:05 <_flow_> No the data need to be kept in memory
08:12:30 <matthiasgorgens> _flow_: postgres probably supports that.
08:13:14 <matthiasgorgens> you can probably go pretty far with haskell, but if your programme includes database functionality, then using an actual database might not be a bad idea. :o)
08:13:22 <_flow_> Yeah maybe. But I need a pure haskell solution. I know that it may not exists (yet). Therefore I am looking for the best possible solution atm
08:13:38 <merijn> byorgey: So I've been reading the type family stuff, but I'm not sure how it'd be needed/helpful for encoding type level list lengths?
08:13:39 <matthiasgorgens> where do the requirements for pure haskell and in-memory come from?
08:14:23 <_flow_> It's part of my bachelor thesis. Exploring the posiblities
08:14:50 <matthiasgorgens> _flow_: oh, ok.
08:15:36 <_flow_> And one of my first aproaches was STM (since it seems to be *the* way to do concurrent transactions) and map (since it's *the* functional data structure)
08:16:04 <matthiasgorgens> ok.
08:16:16 <matthiasgorgens> yeah, it's a good first choice, before profiling.
08:17:29 <t7> i thought map was fast
08:17:41 <t7> isnt access O(log n) ?
08:17:50 <sipa> yes
08:17:55 <matthiasgorgens> the O notation hides the constant factors.
08:18:01 <matthiasgorgens> also there's stuff like cache sizes,
08:18:05 <matthiasgorgens> and memory locality.
08:18:26 <sipa> in short: O notation doesn't say anything about real behaviour, only about asymptotic behaviour
08:19:15 <matthiasgorgens> sipa: actually, asymptotics and abstracting away constant factors are two different things.
08:19:23 <sipa> agree
08:19:25 <matthiasgorgens> and O notation does both. :o)
08:20:45 <sipa> right; O(log n) basically says: for large enough input, if you double its size, a constant extra time is added
08:22:52 <matthiasgorgens> yeah.
08:23:38 <fmap> @hoogle (f (Free f a) -> g (Free g a)) -> Free f a -> Free g a
08:23:38 <lambdabot> Warning: Unknown type Free
08:23:38 <lambdabot> No results found
08:24:53 <mrg> hi
08:26:03 <mandarg> would this be a good place to ask about cabal's memory consumption
08:26:04 <mandarg> ?
08:26:24 <matthiasgorgens> mandarg: as good as any I can imagine.
08:27:00 <mandarg> i'm seeing it run out of memory while upgrading on a low-end 512 MB VPS that I have
08:27:18 <dcoutts_> mandarg: is it cabal running out of memory or the linking?
08:27:25 <dcoutts_> usually it's the linking
08:27:30 <hiptobecubic> mandarg, some packages take a *huge* amount of memory to link
08:27:38 * hiptobecubic eyes gtk
08:27:55 <mandarg> dmesg shows me the process or a child being killed
08:27:56 <mandarg> [1196830.032182] Out of memory: kill process 14634 (cabal) score 4047 or a child
08:27:57 <mandarg> [1196830.032187] Killed process 14634 (cabal)
08:28:21 <hiptobecubic> because cabal calls ghc which takes a lot of memory when building
08:28:41 <dcoutts_> mandarg: ok ok but what was it doing at the time? the OOM killer can pick whatever process it likes to kill in an OOM situation
08:28:42 <hiptobecubic> is it possible to use a different linker?
08:29:09 <dcoutts_> if you must build on a host with low memory (rather than building elsewhere and moving the binaries) then it is possible to do a build of ghc without the "split objs" feature, which is the thing that really makes the linker cry
08:29:27 <dcoutts_> or possibly, using dynamic linking might also work (because that doesn't use split objs either)
08:29:54 <jfischoff> what's the downside of not using split obis?
08:30:02 <dcoutts_> hiptobecubic: I don't think gold does a whole lot better for split objs archives
08:30:12 <dcoutts_> jfischoff: bigger static binaries
08:30:18 <jfischoff> ah
08:30:45 <mrg> i want to use a monad transformer for Maybe and found MaybeT at http://www.haskell.org/haskellwiki/New_monads/MaybeT but ghci does not know Control.Monad.Maybe... why?
08:30:50 <dcoutts_> jfischoff: the split objs feature is there to help the linker to only link in the bits of libs that are used. This is particularly relevant for big general purpose things like the base package
08:31:12 * jfischoff nods
08:31:15 <matthiasgorgens> mrg: you probably need to install the package.
08:31:35 <matthiasgorgens> mrg: in the transformers package.
08:31:42 <matthiasgorgens> mrg: do you know about packages and stuff?
08:31:47 <dcoutts_> mandarg: e.g. for the gentoo ghc package, it used to always disable split objs for systems with 512Mb or less
08:31:53 <mrg> no sorry
08:32:05 <mrg> is there some kind of how to or introduction?
08:32:13 <matthiasgorgens> mrg: do you use linux?
08:32:24 <dcoutts_> mandarg: but if you can use dynamic linking that's probably the easier approach these days than rebuilding ghc from source without splitobjs
08:32:30 <mrg> no
08:32:52 <matthiasgorgens> mrg: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall is probably your best bet.
08:33:07 <mrg> tnaks matthiasgorgens !
08:33:21 <mrg> ... thanks ;)
08:33:35 <mandarg> dcoutts_: thanks, I'll look around and try to find how to do that
08:33:49 <matthiasgorgens> mrg: actually, installing the haskell platform might be even better.
08:33:51 <mandarg> sorry for the cluelessness, I'm completely new to haskell
08:33:54 <matthiasgorgens> http://hackage.haskell.org/platform/
08:34:07 <matthiasgorgens> the platform comes with the ghc compiler and lots of commonly used packages.
08:34:14 <dcoutts_> mandarg: mainly involves using --enable-dynamic with cabal, but it has to be done for all packages you depend on
08:34:18 <mrg> i've already installed the platform
08:34:19 <matthiasgorgens> mrg: http://hackage.haskell.org/platform/
08:34:35 <matthiasgorgens> mrg: strange, http://lambda.haskell.org/platform/doc/current/index.html says transformers is part of the platform.
08:34:45 <matthiasgorgens> mrg, http://lambda.haskell.org/platform/doc/current/packages/transformers-0.3.0.0/doc/html/Control-Monad-Trans-Maybe.html
08:37:31 <mrg> matthiasgorgens: i tried to use Control.Monad.Maybe... ill update my haskell-platform and try Control.Monad.Trans.Maybe
08:38:57 <matthiasgorgens> mrg: do you know about hoogle?
08:39:02 <matthiasgorgens> (and hayoo)
08:40:37 <`Jake`> What was the module I can use to execute bash-commands again?
08:42:05 <matthiasgorgens> `Jake`: System?
08:42:11 <matthiasgorgens> System.Process
08:42:15 <`Jake`> thanks
08:43:25 <jsimons> could somebody help to find a synonym for pointed in "pointed functor" ? i'm trying to translate a sentence from the typeclassopedia into german
08:44:07 <matthiasgorgens> jsimons: look into geometry, that's where the term comes from.
08:44:31 <copumpkin> http://de.wikipedia.org/wiki/Punktierter_topologischer_Raum
08:46:09 <jsimons> thx ... so "punktierter Funktor" would be a correct translation ?
08:46:27 <copumpkin> I'd guess
08:46:29 <matthiasgorgens> jsimons: yeah.
08:46:31 <copumpkin> I don't actually speak german
08:46:43 <matthiasgorgens> see also https://de.wikipedia.org/wiki/Darstellbarkeit_(Kategorientheorie)
08:47:04 <matthiasgorgens> also uses similar vocabulary.
08:49:16 * hackagebot monarch 0.5.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.5.0.0 (NoriyukiOhkawa)
08:49:17 <jsimons> thanks to you all
08:51:37 <mrg> matthiasgorgens: Control.Monad.Trans.Maybe works fine... thanks
09:02:27 <jsimons> is it valid to use "lift" in context of values instead of functions ?
09:04:31 <Cale> jsimons: Not sure what you mean.
09:04:45 <Cale> jsimons: Are you talking about Control.Monad.Trans.lift?
09:04:57 <Cale> :t lift
09:04:59 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:05:50 <jsimons> is it fine to write "pure lifts a value into a context"
09:06:21 <jsimons> pure as method of Pointed
09:06:22 <Cale> jsimons: The word "lift" generally gets used for most any operation which takes something from a "simple" type and adds structure to it in some fashion to reflect it in a more complex type.
09:06:29 <Cale> So yes
09:06:59 <Cale> But I'm not sure that's the most helpful way to describe pure
09:07:28 <Cale> pure takes a value and produces a computation which does nothing except to have that value as its result.
09:10:04 <jsimons> thx ... a much better explanation
09:10:31 <aristid> oO 7.6 out already?
09:13:41 <mrg> i am experimenting with MaybeT and have already written my own implementation... tested the transformer with "MaybeT Maybe Int" and it worked fine but using it with "MaybeT (Either String) Int" won't work: ghci complains that "Either String" is no instance for Monad... trying the same with the implementation in Control.Monad.Trans.Maybe works fine... why?
09:14:17 * hackagebot pureMD5 2.1.2.1 - A Haskell-only implementation of the MD5 digest (hash) algorithm.  http://hackage.haskell.org/package/pureMD5-2.1.2.1 (ThomasDuBuisson)
09:15:11 <c_wraith> mrg: depending on the version of GHC you have, the monad instance for Either is in different spots
09:15:25 <c_wraith> mrg: try importing Control.Monad.Instances
09:16:04 <c_wraith> mrg: it's quite possible Control.Monad.Trans.Maybe imports the Either a Monad instance - since instance imports are transitive
09:17:56 <mrg> c_wraith: works fine! thanks a lot!
09:19:17 * hackagebot puppetresources 0.1.3 - A program that displays the puppet resources associated to a node given .pp files.  http://hackage.haskell.org/package/puppetresources-0.1.3 (SimonMarechal)
09:20:55 <byorgey> jsimons: note that the latest version of the Typeclassopedia does not talk about pointed functors anyway
09:21:13 <byorgey> jsimons: @where typeclassopedia
09:21:17 <byorgey> oops
09:21:21 <byorgey> @where typeclassopedia
09:21:21 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:21:35 <byorgey> jsimons: ^^^ I hope you are using that version and not the PDF from the Monad.Reader
09:21:42 <byorgey> the PDF version is out of date.
09:23:27 <aristid> somebody please update the topic to reflect that the current version of GHC is 7.6.1 :)
09:28:44 <gwern> @quote
09:28:44 <lambdabot> typoclass says: also, we should have noms de guerre for everyone, e.g. edward "trembling categories" kmett
09:29:17 * hackagebot syb-with-class 0.6.1.4 - Scrap Your Boilerplate With Class  http://hackage.haskell.org/package/syb-with-class-0.6.1.4 (AndreaVezzosi)
09:32:15 <nand`> Edwardk "Zen Comaster" Kmett
09:32:26 <monochrom> haha
09:32:39 <nand`> ..
09:32:42 <nand`> Edward*
09:33:24 <nand`> @quote polykinded
09:33:24 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
09:33:27 <nand`> ah, shame
09:33:44 <nand`> @remember shachaf Polykinded Indexed Monads is the name of edwardk's new band.
09:33:44 <lambdabot> I will remember.
09:34:18 * hackagebot TYB 0.2.2 - Template Your Boilerplate - a Template Haskell version of SYB  http://hackage.haskell.org/package/TYB-0.2.2 (ThomasDuBuisson)
09:37:07 <hpaste> JEllo pasted “Multiple Names” at http://hpaste.org/74348
09:37:32 <Jello_Raptor> so, there's an obvious error with multiple declarations, but given how the Spec defines both codes that looks like the simples way, is there an alternate idiom I should Use?
09:37:56 <mroman> Prefix.
09:38:08 <mroman> or put it in different Modules.
09:38:26 <mroman> so you can import them under a qualified name.
09:40:42 <monochrom> onoes, GHC 7.6.1 is out
09:42:23 <Jello_Raptor> mroman: i'm not sure what you mean with "Prefix.", and the different modules seem like it would just clutter things up.
09:42:39 <monochrom> it means changing names
09:42:48 <Sculptor> hi
09:44:05 <monochrom> "It is now possible to defer type errors until runtime using the -fdefer-type-errors flag."  hahahaha  (GHC 7.6.1)
09:44:18 <eikke> is there a cheap way to cast some bool to a 0/1 int, without introducing jumps in the resulting asm?
09:45:22 <nh2> why doesn't this work? "import qualified My.Module.Main as Main; main :: IO (); main = Main.main"? I get "ambiguous reference"
09:45:33 <nh2> oops of course
09:45:40 <nh2> "module Main where" ...
09:46:27 <Eduard_Munteanu> monochrom: lolz, maek Haskell moar like PHP
09:46:38 <Mon_Ouie> eikke: Why not define a function that does that (with pattern matching or whatever) and simply trust the compiler?
09:47:02 <eikke> Mon_Ouie: tried that, and checked compiler output. it does introduce jumps.
09:47:53 <eikke> Mon_Ouie: it's a game with a colleague, getting close to his hand-optimized C code from within Haskell, but I'm stuck with something along the lines of "uint16_t val = (x == y)"
09:48:33 <Eduard_Munteanu> eikke: write that bit using Prim stuff
09:49:20 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/7.2.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
09:49:37 <Eduard_Munteanu> There should be something like that in there.
09:50:05 <eikke> Eduard_Munteanu: thanks for the pointer, will check
09:50:51 <Eduard_Munteanu> eikke: mind by the time you get that done, it might not look a lot like Haskell anymore, or better than the C variant.
09:52:03 <eikke> Eduard_Munteanu: that's OK, we always assume things start from "very high level" implementations, then optimising on-the-go
10:01:40 <danr> bah, is there no zipWithM3?
10:02:20 <saep> nm-applet
10:02:31 <saep> sorry, fc :(
10:02:56 <byorgey> danr: zipWithM3 f xs ys zs = sequence (zipWith3 f xs ys zs)
10:03:10 <byorgey> and no, it does not appear to be pre-defined
10:04:11 <Ralith> I'm building bobth a cabal library and a program that relies on it. When I try to 'cabal build' the program, cabal doesn't see my 'cabal install'ed library. How do I fix this?
10:04:18 * hackagebot esqueleto 0.2.4 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2.4 (FelipeLessa)
10:06:00 <dcoutts_> Ralith: it has to be installed (or at least registered)
10:06:26 <dcoutts_> Ralith: easiest thing is just to install it, it's also possible to register in-place without installing
10:07:51 <Ralith> dcoutts_: as I said, it is installed
10:08:29 <dcoutts_> Ralith: oh I assumed you meant you'd only run cabal build on the library.
10:08:57 <dcoutts_> Ralith: to be clear: is the lib a separate package from the exes or all one single .cabal package?
10:09:06 <Ralith> separate.
10:09:18 <dcoutts_> ok, then it's just a matter of installing the library
10:09:38 <dcoutts_> if it installs successfully then it will be available, you can confirm this with ghc-pkg list
10:09:46 <Ralith> dcoutts_: I already installed it.
10:10:01 <Ralith> as I said.
10:10:03 <dcoutts_> is it actually registered?
10:10:06 <Ralith> yes.
10:10:13 <Ralith> ghc-pkg list shows it.
10:10:56 <dcoutts_> Ralith: then running cabal configure; cabal build  for the exes that depend on it should just work. If it doesn't you'll need to show us the error, e.g. hpaste
10:11:27 <Ralith> oh, just needed to rerun 'configure'
10:11:28 <Ralith> thanks
10:12:31 <joeyh> in a cabal file, is there any way to add a file to C-Sources contingent on the build OS?
10:12:47 <EvanR> the difference between 'nullable' types in most popular systems and Maybe a in haskell is that you can have Maybe (Maybe Foo)
10:12:51 <EvanR> is there any other?
10:12:56 <EvanR> difference
10:13:11 <dcoutts_> joeyh: yep, see the cabal user guide, the stuff about conditionals, if os(...)
10:13:54 <Ralith> EvanR: you'll have to define what you're comparing with better.
10:14:14 <Ralith> but I doubt most other systems let you define such a thing in-lang, or present a monadic interface.
10:14:18 * hackagebot dates 0.1.0.0 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.1.0.0 (IlyaPortnov)
10:15:18 <joeyh> dcoutts: I see I can provide different versions of it for different oses that way, but not add a file to it
10:15:34 <joeyh> if I have some other files I always want in it
10:17:49 <dcoutts_> joeyh: I don't follow, surely just: if os(blah)  c-sources: blah
10:18:02 <joeyh> oh, does that append to a prior c-sources line?
10:18:08 <dcoutts_> yes
10:18:11 <joeyh> ah, awesome
10:18:20 <joeyh> thanks, I didn't know .cabal worked that way
10:18:27 <dcoutts_> cabal files are basically completely monoidal
10:18:47 <joeyh> heh, ok
10:19:22 <joeyh> I have to say, I often with it were real haskell syntax
10:19:40 <joeyh> wish
10:23:56 <nand`> I wonder what cabal would look like as an actual Haskell EDSL in the Setup.hs file instead of a separate .cabal
10:24:13 <nand`> but I imagine you lose the power to parse the files that way
10:24:28 <nand`> (without executing the Haskell code or anything like that)
10:25:33 <mm_freak> import Prelude hiding (Ord(..))
10:25:50 <mm_freak> description "some very long string"
10:25:55 <joeyh> nand`: wonder if Safe haskell could be used for parsing
10:25:57 <mm_freak> i don't know if this is such a good idea
10:26:44 <nand`> mm_freak: perhaps with liberal TH/QQ
10:26:57 <dcoutts_> nand`: yes that was the original design but was changed to a declarative data file fairly early on because it's clearly superior :-)
10:27:01 <nand`> but still giving you the ability to inline haskell expressions, up to and including manipulating the tree in any way you want
10:27:41 <dcoutts_> nand`: it does mean it becomes execute only, you would not be able to load and edit one in an IDE for example
10:27:52 <byorgey> that sounds terrible.
10:27:58 <nh2> how can I set the equivalent for hs-source-dirs in runghc?
10:28:04 <mm_freak> nand`: then you would need to have a non-standard compiler, which destroys the point of cabal
10:28:08 <nh2> alias where it shall look for modules
10:28:11 <dcoutts_> nand`: and similarly, impossible to translate into other package formats (.rpm etc)
10:28:16 <mm_freak> i think the separately parsed file is fine…  not everything has to be a haskell EDSL
10:28:23 <byorgey> doing arbitrary magic to your personal window manager is one thing, using it for something meant to be widely distributed is another.
10:28:49 <sykora> ...aaaand I'm off to the airport to get on the plane to ICFP. See you all there :)
10:28:58 <dcoutts_> nh2: -i flag, e.g. -ifoo/ -ibar/ or -ifoo:bar
10:29:01 <byorgey> sykora: have a good flight, see you soon!
10:29:34 <dcoutts_> sykora: you're leaving early :-)
10:29:54 <sykora> dcoutts_: I'm presenting at XLDI on Sunday
10:29:58 <dcoutts_> ah
10:30:15 * dcoutts_ will be going via ferry + overnight train, arriving 10am Monday
10:30:25 <nh2> dcoutts: awsome
10:30:34 <dcoutts_> missing first invited talk! ho hum
10:31:07 <byorgey> overnight train, sounds fun
10:31:21 <byorgey> though perhaps it only sounds fun because I've never been on one
10:32:24 <luite> hm i found sleeping in them not particularly easy, but at least it's a lot better than bus
10:32:35 <dcoutts_> byorgey: no it is fun, European trains have bunk beds, so no sleeping in an upright seat
10:32:52 <sykora> dcoutts_: unlike a plane :|
10:33:02 <byorgey> dcoutts_: ah, excellent
10:33:13 <dcoutts_> sykora: my commiserations
10:33:14 * byorgey is taking an overnight plane and does not expect it to be fun
10:33:37 <luite> sykora: some planes do have beds! you just have to pay a little more
10:33:45 <byorgey> s/little/lot/
10:34:01 <sykora> luite: just a few more ... orders of magnitude?
10:34:19 * hackagebot type-prelude 0.1 - Partial port of prelude to the type level. Requires GHC 7.6.1.  http://hackage.haskell.org/package/type-prelude-0.1 (EtienneLaurin)
10:34:23 <Clint> usually not more than 1 order
10:34:39 <luite> yeah i guess, those a380 beds are probably at least 5000 for a transatlantic flight...
10:35:55 <nand`> LambdaCase and MultiWayIf nom nom
10:37:02 <Cale> LambdaCase's concrete syntax makes me sad
10:37:31 <nand`> I would have expected \case of Nothing -> ...
10:37:37 <nand`> but what would you have?
10:38:42 <ben> > (+) 0o678
10:38:43 <lambdabot>   63
10:38:46 <ben> Haskell is the worst syntax
10:39:06 <Ferdirand> wait
10:39:08 <Ferdirand> what ?
10:39:32 <ben> 0o, so it's an octal literal. but 8 isn't an octal digit, so that's suddenly a separate token or something
10:39:33 * Ferdirand fires up ghci
10:39:36 <Cale> nand`: Leaving the scrutinee of a case expression blank should make it a lambda, just like other kinds of sections.
10:39:42 <ben> so it's (+) 55 8
10:39:55 <Cale> nand`: So it would be  case of Nothing -> ...; Just x -> ...
10:40:00 <ben> someone posted 0o678 on reddit or somewhere
10:40:04 <ben> > 0o678
10:40:05 <lambdabot>   55
10:40:07 <nand`> Cale: yeah, that seems sane enough to me as well
10:40:12 <ben> heh, funky Num instance
10:41:28 <lightquake> it's not a num instance
10:41:52 <nand`> lightquake: it is in this case
10:42:07 <fryguybob> > 55 8
10:42:08 <lambdabot>   55
10:42:18 <lightquake> well i mean, it is, but 55 being an instance of Num is kind of expected :P
10:42:37 <nand`> the ‘funky’ part here referred to ‘55 8’ being valid
10:42:54 <lightquake> oh, that
10:42:55 <zhulikas> >0o123
10:42:57 <lightquake> yeah
10:43:06 <zhulikas> > 0o123
10:43:07 <lambdabot>   83
10:43:12 <zhulikas> how is that a number ?
10:43:26 <lightquake> octal?
10:43:34 * zhulikas looks up
10:43:41 <ben> > 0o10
10:43:42 <lambdabot>   8
10:43:43 <ben> yeah.
10:43:47 <zhulikas> oh, righty.
10:44:10 <nand`> so how come we have 0o and 0x but not 0b ?
10:44:19 <lightquake> > 0b1
10:44:20 <lambdabot>   Not in scope: `b1'
10:45:30 <sipa> > 0o77
10:45:31 <lambdabot>   63
10:47:23 <ben> that's still gross tokenization
10:47:26 <ben> > 0length
10:47:28 <lambdabot>   0
10:54:19 * hackagebot dates 0.1.1.0 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.1.1.0 (IlyaPortnov)
10:59:19 * hackagebot todos 0.5.3 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.5.3 (IlyaPortnov)
11:03:12 <kost> is anyone here?
11:03:33 <Cale> yes
11:03:37 <Botje> at the vrry least, you and lambdabot
11:03:53 <kost> > print "I love lambdabot"
11:03:54 <Cale> There are 952 users, someone has got to be here :)
11:03:54 <lambdabot>   <IO ()>
11:04:11 <kost> why doesn't lambdabot love me back?
11:04:19 <kost> > "I love lambdabot"
11:04:19 * hackagebot hspec-expectations 0.3.0.2 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.3.0.2 (SimonHengel)
11:04:20 <lambdabot>   "I love lambdabot"
11:05:27 <t7> > let f w x y z = 1 in (f 1) 2 3 4
11:05:28 <lambdabot>   1
11:06:05 <kost> > let f w x y z = 1 in (f 1)
11:06:06 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1 -> t2 -> t3)
11:06:06 <lambdabot>    arising fr...
11:06:13 <kost> > let f w x y z = 1 in f 1
11:06:15 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1 -> t2 -> t3)
11:06:15 <lambdabot>    arising fr...
11:06:46 <Z`> people when I write:   State x >>= f = State (\s0 -> ... here s0 is x ?
11:07:06 <Jello_Raptor> so i'm trying to make a 'safeComp :: (a -> Maybe a) -> a -> a' that'll take a function that might fail, and if it does fail just return the original value instead of Nothing. I am totally stumped,.
11:07:06 <Cale> Z`: no
11:07:30 <Cale> Z`: in fact, when you're defining bind, I think you'll find it much clearer just to write x >>= f on the left hand side
11:07:47 <dmos> can a function a -> b -> IO c be lifted with liftIO in pointfree style?
11:07:47 <Z`> Alright. What about the value of s0 though ?
11:07:57 <Cale> Z`: okay, let's define State
11:08:09 <Z`> newtype State s a = State (s -> (a, s))
11:08:09 <dmos> I came up with (liftIO .) . f , is there a better solution?
11:08:13 <Cale> Z`: I'm going to name the constructor a little differently just to make it easier to talk about
11:08:17 <Z`> ah ok
11:08:18 <Z`> thank you Cale
11:08:25 <Cale> newtype State s a = S (s -> (s,a))
11:08:37 <Cale> runState :: State s a -> s -> (s,a)
11:08:46 <Cale> runState (S f) s = f s
11:10:10 <Cale> Z`: We're implementing these computations which operate on a state of type s (reading and writing it), and produce a result of type a, using functions from an initial state to pairs consisting of a final state and the result
11:10:13 <Cale> Z`: yeah?
11:10:19 <Z`> ok
11:10:23 <Cale> S :: (s -> (s,a)) -> State s a
11:10:32 <Cale> this S will package up such a function
11:10:52 <Cale> runState's implementation is particularly easy because of the way we're representing these
11:10:52 <kost> did any of you ever worked on real Haskell programs? More then 10k lines of code (haskell compilers themselves don't count ;) )
11:10:58 <Cale> kost: sure
11:11:10 <kost> can you name some of them?
11:12:24 <Cale> kost: I first worked on a pipeline scheduler and register allocator as part of a compiler for signal processing applications in Haskell. My piece of the code for that was maybe only a couple thousand lines (and that was mostly comments), but it would have been perhaps 50 or 60 thousand lines in C.
11:12:28 <dmos> @pl \a b -> return (a,b)
11:12:28 <lambdabot> (return .) . (,)
11:12:51 <atriq> :t uncurry return
11:12:52 <lambdabot> forall a b. (a, b) -> a
11:12:57 <Cale> kost: I more recently worked on a game engine on iOS in Haskell, and an action RPG to go with it called BloodKnight
11:13:01 <atriq> :t (return .) . (,)
11:13:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> b -> m (a, b)
11:13:08 <atriq> :t curry return
11:13:08 <kost> that's cool
11:13:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => a -> b -> m (a, b)
11:13:20 <atriq> dmos, ^^^
11:13:55 <dmos> orig problem was (liftIO .) . f where f :: a -> b -> IO c
11:13:58 <Cale> kost: and that was, well, I'm not sure off hand, but definitely more than 10k lines of Haskell.
11:14:08 <dmos> atriq: ^
11:14:10 <Cale> The core FRP system was maybe 3k lines.
11:14:20 * hackagebot array 0.4.0.1 - Mutable and immutable arrays  http://hackage.haskell.org/package/array-0.4.0.1 (IanLynagh)
11:14:22 * hackagebot base 4.6.0.0 - Basic libraries  http://hackage.haskell.org/package/base-4.6.0.0 (IanLynagh)
11:14:23 <dmos> is there a better way?
11:14:23 * hackagebot deepseq 1.3.0.1 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.3.0.1 (IanLynagh)
11:14:26 * hackagebot unfoldable 0.7.1 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.7.1 (SjoerdVisscher)
11:14:28 * hackagebot directory 1.2.0.0 - library for directory handling  http://hackage.haskell.org/package/directory-1.2.0.0 (IanLynagh)
11:14:33 <kost> cool
11:14:40 <kost> is it open Source?
11:14:42 <Cale> no
11:14:48 <kost> :(
11:14:52 <Cal_> ?src and
11:14:52 <lambdabot> and   =  foldr (&&) True
11:15:00 <atriq> dmos, oh, then the ugh is what you want unless you want to get an obscure pointless library. \a b -> liftIO (f a b) is a LOT less ugly
11:15:05 <timthelion> GADTs are great.  Except apparently, you can't actually use them most of the time :(  If I have a data Foo a where Bar :: Foo BarT ; Baz :: Foo BazT then I cannot make the list [Bar, Baz] !
11:15:22 <kost> is there any big open-source haskell programs you will recommend reading the code?
11:15:54 <timthelion> kost: probably darcs.  Not the best code in the world. But easy reading.
11:15:58 <Cale> There are lots of libraries which are very much worth reading.
11:16:06 <merijn> kost: xmonad is not very big
11:16:09 <dmos> atriq: that's what I thought. It's only passing bindings through, but the definition looks fairly obscure.
11:16:13 <EvanR> the libraries are nice but libraries arent programs
11:16:19 <merijn> kost: Parsec is probably also worth reading?
11:16:29 <Cale> Yeah, but well-designed programs are libraries. :)
11:16:32 <kost> cool
11:16:53 <timthelion> Cale: that's not quite true.
11:17:01 <kost> sometimes it looks like all the big Haskell programs are libraries o_0
11:17:52 <timthelion> Either there is a hell of a lot of haskell code wrapped up in the banks and millitary where it never gets seen, or all these libraries are ultimately entirely unused :/
11:18:23 <kost> both alternatives suck :(
11:18:29 <Cale> There are a lot of libraries which get used by people for little programs which probably aren't worth sharing with others too.
11:18:30 <mrg> hi, is there some equivalent to #define and #ifdef for ghc?
11:18:41 <Clint> yes
11:18:44 <Cale> mrg: You can just turn on CPP
11:18:48 <sm> kost: how about GHC
11:18:49 <Cale> {-# LANGUAGE CPP #-}
11:18:53 <Cale> at the top of your file
11:19:00 <Cale> and then you can use the preprocessor
11:19:02 <timthelion> sm: I tried reading GHC, but it's not easy reading!
11:19:09 <kost> well, I said no compilers ;)
11:19:22 <mrg> Cale: thanks, are there any drawbacks for this solution?
11:19:26 <sm> ah. Oops. (Speaking of which, GOOO GHC!!!!)
11:19:30 * hackagebot filepath 1.3.0.1 - Library for manipulating FilePaths in a cross platform way.  http://hackage.haskell.org/package/filepath-1.3.0.1 (IanLynagh)
11:19:32 * hackagebot haskell2010 1.1.1.0 - Compatibility with Haskell 2010  http://hackage.haskell.org/package/haskell2010-1.1.1.0 (IanLynagh)
11:19:34 * hackagebot haskell98 2.0.0.2 - Compatibility with Haskell 98  http://hackage.haskell.org/package/haskell98-2.0.0.2 (IanLynagh)
11:19:36 * hackagebot hpc 0.6.0.0 - Code Coverage Library for Haskell  http://hackage.haskell.org/package/hpc-0.6.0.0 (IanLynagh)
11:19:38 * hackagebot old-locale 1.0.0.5 - locale library  http://hackage.haskell.org/package/old-locale-1.0.0.5 (IanLynagh)
11:19:44 <Cale> mrg: uhh, depends? There might be a better solution, depending on what you're trying to do.
11:19:48 <timthelion> hackagebot kicked for flood.
11:20:18 <Cale> GHC 7.6.1 was just released :)
11:20:26 <dmos> looks like it.
11:20:31 <johnw> woohoo!
11:20:54 <timthelion> johnw: why woohoo, all that means is now everything will break :P
11:21:05 <johnw> yeah, well, that's the kind of guy I am
11:21:17 <Clint> yay progress
11:21:27 <johnw> now I can code my whole program at the kind level
11:21:30 <johnw> ;)
11:21:30 <luite> i downloaded ghc-7.6.1-src.tar.bz2 yesterday, is that still the same or were there any last-minute changes?
11:21:37 <Cale> YAY MORE COMPILER BUGS^WFEATURES
11:22:23 * timthelion cries.
11:22:25 <byorgey> luite: no last-minute changes, I did a diff to be sure =)
11:22:40 <luite> great, tnx :)
11:22:46 <mrg> Cale: i've two implementations sharing the same test environment and i'd like to switch between them... for c compiler-switch would be the best solution i think...
11:22:50 * timthelion converted all his types to GADTs thinking that they would offer better type stictness.  And they are too typestrict and he has to go back.
11:23:37 <Cale> timthelion: heh, or you could go forward... with existentials
11:23:49 <timthelion> Cale: do you read cafe?
11:24:03 <Cale> timthelion: I subscribe to cafe, but rarely actually read it
11:24:19 <timthelion> oh, there was a long discussion that I started about over-general types in haskell.
11:24:32 <johnw> does this usually mean having to rebuild my whole cabal world?
11:24:40 * hackagebot old-time 1.1.0.1 - Time library  http://hackage.haskell.org/package/old-time-1.1.0.1 (IanLynagh)
11:24:42 * hackagebot process 1.1.0.2 - Process libraries  http://hackage.haskell.org/package/process-1.1.0.2 (IanLynagh)
11:24:44 * hackagebot template-haskell 2.8.0.0 -   http://hackage.haskell.org/package/template-haskell-2.8.0.0 (IanLynagh)
11:24:46 * hackagebot unix 2.6.0.0 - POSIX functionality  http://hackage.haskell.org/package/unix-2.6.0.0 (IanLynagh)
11:24:58 <timthelion> the only real sugestions where A: union types, which are ugly. and B: GADTs, and it turns out that GADTs won't work at all.
11:25:14 <newsham> iOS game engine in haskell?  performed well on cell phone?
11:25:16 <Cale> timthelion: I was only half-joking there. GADTs inside existentials actually tend to work pretty well
11:25:18 <byorgey> johnw: yes, libraries compiled with one version of GHC cannot be used with a different version.
11:25:35 <Cale> timthelion: because when you pattern match, you get to recover the type information discarded by the existential
11:25:51 <timthelion> Cale: Oh!
11:25:58 <timthelion> Cale: do you have an example somewhere?
11:26:09 <Cale> I might be able to google one
11:26:18 <Cal_> ?src foldl
11:26:18 <lambdabot> foldl f z []     = z
11:26:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:26:31 <merijn> Is it wise to explicitly call finalizeForeignPtr to avoid resource leaks or will GC usually call the finalizer reasonably swiftly?
11:26:42 <Cale> But it's really just as simple as what it sounds like. Suppose you have something like:
11:26:49 <Cale> data Expr a where
11:26:54 <Cale>    ... stuff ...
11:26:57 <Cale> some GADT
11:27:02 <Cale> and then you write
11:27:04 <timthelion> Cale: the problem, is that any time you have data Foo = Bar | Baz, and a function f :: Foo which then calls functions g and d where g should have the type g :: Bar and d should have the type d :: Baz...
11:27:06 <Cale> data SomeExpr where
11:27:16 <Cale>   SomeExpr :: Expr a -> SomeExpr
11:27:41 <timthelion> Cale: weird :)
11:27:44 <c_wraith> merijn: non-memory resources don't exert pressure on the garbage collector, so it may not result in running them in a timely manner.  However, calling finalizeForeignPtr too soon is a disaster
11:27:44 <Cale> and then values of type SomeExpr can be treated uniformly
11:28:01 <johnw> i think i'll let the dust settle then
11:28:11 <timthelion> Cale so then I can have a list [Bar, Baz] and also a function that only takes a Bar and not a Baz?
11:28:14 <Cale> timthelion: But when you pattern match on the Expr constructors, you recover the type equality constraints which they impose.
11:28:21 <Cale> yes
11:28:24 <c_wraith> merijn: so I'd only add calls to finalizeForeignPtr if there's an observable issue with temporary resource leaks
11:28:26 <Cale> essentially
11:28:29 <timthelion> Cale: exactly what I'm looking for :)
11:28:36 <Cale> Well, it's that, but one level up
11:28:37 <merijn> c_wraith: Yes, but the GC can't notice memory pressure from external pointers, right?
11:28:51 <Cale> The way to do what you're describing is just plain sum types
11:29:12 <c_wraith> merijn: correct.  Still, the results of getting it wrong are likely segfaults
11:29:14 <timthelion> Cale: so I would have a list of type [SomeExpr] and I would have a function f :: SomeExpr ; f Bar bar = g bar where g :: Bar?
11:29:30 <merijn> c_wraith: I'm rewriting a C codebase and finalizeForeignPtr would essentially just come in place of the current "externalFree"
11:29:50 <timthelion> Cale: I might want just plain sum types.  Though they are ugly as hell most of the time.
11:29:53 <merijn> c_wraith: So unless I screw up I should already know when I can safely free them
11:30:02 <Cale> timthelion: you're missing the SomeExpr constructor there
11:30:03 <merijn> (eh, screw up the reimplementation)
11:30:13 <Cale> timthelion: but more or less...
11:30:28 <timthelion> Cale: so f (SomeExpr (Bar bar)) = g bar?
11:30:38 <Cale> timthelion: It's hard to be precise about it without an actual data declaration :)
11:31:09 <timthelion> Cale: Is there really a difference between GADTs and union types besides a nicer syntax?
11:31:09 <Cale> yeah, maybe :)
11:31:14 <Cale> Oh, yes
11:31:26 <Cale> (the maybe was to the previous question)
11:31:34 <Cale> GADTs let you do things like this:
11:31:46 <Cale> data Expr a where
11:31:58 <Cale>   Lit :: Integer -> Expr Integer
11:32:12 <Cale>   IsZero :: Expr Integer -> Expr Bool
11:32:30 <Cale>   If :: Expr Bool -> Expr a -> Expr a -> Expr a
11:32:38 <Cale>   ... and so on ...
11:32:40 <Nereid> Fun :: Expr a -> Expr b -> Expr (a -> b)
11:32:44 <Nereid> I dunno
11:33:03 <Cale> Note that the type of the result of your constructor isn't just directly dependent on the type of its arguments
11:33:22 <Cale> and constructors can construct Expr values with specific type parameters
11:33:53 <timthelion> Cale: but if we were using union types, then If :: IsZero -> Expr -> Expr -> Expr
11:34:04 <Cale> Like, if you have an (IsZero x), you know that this is an Expr Bool
11:34:22 <Cale> While if you write something like this:
11:34:52 <Cale> data Expr = Lit Integer | IsZero (Expr Integer) | If Expr Expr Expr | ...
11:34:57 <Cale> errr
11:35:02 <Cale> data Expr = Lit Integer | IsZero Expr | If Expr Expr Expr | ...
11:35:23 <Cale> now your terms aren't typechecked, and you'll have to check the types in your evaluator
11:35:43 <Cale> With the GADT, you could write an eval :: Expr a -> a
11:35:59 <Cale> But with this type, it's hard to say what type the terms evaluate to
11:36:05 <timthelion> Cale: but what about newtype LitT = LitT Integer ; newtype IsZeroT = IsZeroT Expr ect and data Expr = Lit LitT | IsZero IsZeroT
11:36:08 <Cale> and even if we stick in phantom types
11:36:37 <Cale> data Expr a = Lit Integer | IsZero (Expr Integer) | If (Expr Bool) (Expr a) (Expr a) | ...
11:36:37 <rwbarton> timthelion, but then you have no guarantee that the types of the second and third expressions match; and also the first argument of If needn't be an IsZero constructor, it could be another If expression, but only if the result type is Bool... how are you going to encode all that
11:37:06 <Cale> then we still have nonsense like  IsZero (Lit 5) :: Expr String
11:37:20 <Cale> there's no way to restrict the type of the result
11:37:24 <Cale> of each constructor
11:37:59 <Nereid> yay, ghc 7.6.1 :o
11:38:16 <Cale> timthelion: Make sense?
11:38:30 <Nereid> time to set the topic?
11:38:35 <Cale> timthelion: So GADTs have this extra quality of discharging type equality constraints when you pattern match on them
11:38:57 <Cale> To say "oh, I know the type of this expression more fully now, because I know that it's an IsZero constructor"
11:39:15 <timthelion> Cale: I understand that. But that can also be acheived through plain old union types.
11:39:19 <Cale> NO
11:39:21 <Cale> :)
11:39:31 <Cale> try it!
11:39:50 <Cale> I'm going to write this eval:
11:39:58 <Cale> eval :: Expr a -> a
11:40:03 <Cale> eval (Lit x) = x
11:40:14 <Cale> eval (IsZero e) = eval e == 0
11:40:30 <Cale> eval (If b t e) = if eval b then eval t else eval e
11:40:51 <Cale> Try to define a plain old union type for which that safe eval can be written
11:40:55 <Cale> and not have any error cases
11:41:07 <timthelion> Cale: I see what you're saying.  I would need a typeclass+ a union type for that :D
11:41:28 <Cale> Typeclasses are also open
11:41:42 <Cale> So you can't really be sure that you have all the cases you need to handle then
11:43:17 <timthelion> Cale: I've been working on two largish applications.  And the main thing I've learned from all this.  Is I NEVER want the normal "data Foo = Bar | Baz" not even for bool replacements.  Some of the supposedly experienced people on cafe dissagree. But it's been my hard experience that the standard data is just evil.  Now I have to find ways to replace it.
11:43:18 <Cale> (sometimes that's a good thing, but sometimes you really want something which defines all the cases in one place and be able to tell that you've exhaustively handled them all)
11:43:36 <Cale> I also disagree
11:43:47 <Cale> But you usually don't just want Bool replacements
11:43:54 <Cale> because you usually don't just want Bool
11:44:16 <Cale> You almost never just want to know whether or not something is true. You want a witness to that truth.
11:44:28 <timthelion> Cale: I'm sorry, but my real life coding experience is showing me that every single time I've used the standard data, without at least making it a union type, it's bitten me in the arse :(
11:44:31 <Cale> Which means you have something like Maybe or Either instead.
11:45:19 <Cale> That's not to say that Bool is useless -- look at all the handy applications of filter
11:45:44 <Nereid> I wish bool :: a -> a -> Bool -> a existed.
11:45:48 <Cale> But just that it's frequently the case that it's not really sufficient.
11:45:52 <Nereid> actually
11:46:06 <Nereid> why can't we automatically derive catamorphisms for every data type?
11:46:13 <Nereid> er, why don't we
11:46:58 <timthelion> Cale: If you look at isParameter https://github.com/timthelion/haskarrow/blob/master/Language/Haskarrow/Types.lhs#L21 ... You can see a great example, of a seamingly inocuos bool replacement. Totally wrong design choice though. And now I'm going back and making phantom types for the true and false values of the IsParameter type.
11:47:11 <Nereid> time to play with them
11:47:18 <timthelion> Cale: so even the most harmless looking cases of data are evil!
11:47:59 <timthelion> Cale: because what if I want to only operate on Values that are parameters.  And not on values that aren't?  I then either have incomplete functions, or I have to redo my types.
11:48:53 <Cale> timthelion: Well, it's just a matter of deciding what you want to check at compile time vs. dynamically.
11:49:16 <timthelion> Cale: well obviously, I want to check as much as possible at compile time :)  Otherwise I'd be coding in Python.
11:49:30 <Cale> Well...
11:49:46 <Cale> You're typically not going to want to represent *all* the behaviour of your program in the types.
11:49:56 <timthelion> How do you know?
11:49:58 <Cale> It's nice to get what you can get cheaply :)
11:50:01 <Philippa> types don't talk about airborne nukes too well
11:50:55 <Cale> But Haskell isn't designed to be a theorem prover -- you can start to try to use it as one with lots of GHC extensions, but you'll get some annoyance that way too.
11:51:57 <Cale> I'm not totally disagreeing with you here though, you can obviously do better in a lot of cases. :)
11:52:05 <timthelion> Cale: I'm not trying to prove anything. I'm trying to write programs with tens of thousands of lines of code, which don't have incomplete functions, don't have their type constraits defined by comments, and don't crash.
11:52:45 <Cale> But that is a big proof :)
11:53:00 <Cale> (well, it's lots of little theorems)
11:53:03 <timthelion> :P
11:53:22 <timthelion> Cale: are any of those desires somehow unresonable?
11:53:37 <Cale> Those are all good ideals
11:54:29 <Cale> They're very reasonable desires, but programs often do complicated things, and making it so that the typechecker can check all that statically is an art-form.
11:55:32 <Cale> Those desires are why everyone loves it when GHC adds new type system extensions.
11:56:11 <Cale> Fancier types push back the boundary on programs where you can really make sure that nothing fails.
11:56:18 <Cale> (without running it)
11:57:00 <Cale> timthelion: So, the first thing I'd suggest trying in this case is just a phantom type
11:57:01 <Nereid> indexed monads are cool.
11:57:07 <timthelion> Cale: now I'm going to read back in the history everything that you said. So don't expect me to say anything for a while.
11:57:38 <Nereid> I'm going to give another shot at playing with PolyKinds soon.
11:57:45 <timthelion> Cale: Well I can make a Phantom type, and parametricise Value, but I need to have lists of Values that are both Parameters and not Parameters.
11:58:11 <Cale> Yeah, okay, use a GADT then.
11:58:33 <timthelion> Cale: If Value has the type Value parameter = then I can no longer do a [Value parameter] with multiple types of values.
11:58:46 <Cale> You can do a polymorphic one
11:58:49 <Cale> errr
11:58:57 <timthelion> Cale: So I need to make some kind of your exicential type.
11:58:59 <Cale> well, sorta :)
11:59:06 <Cale> But yeah, you'll end up with an existential
11:59:21 * hackagebot flock 0.3.1.2 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.3.1.2 (ErikHesselink)
11:59:26 <timthelion> Which means I need to scroll back 20 minutes in the chat to see how you did that :)
11:59:29 <Cale> and then if it's not a GADT, you'll have no way of recovering the type that the existential discarded
12:00:55 <lispy> Nereid: what do you use indexed monads for?
12:01:05 <timthelion> Cale: so I need data SomeValue where SomeValue :: Value a -> SomeValue
12:01:23 <timthelion> Cale: and then I need to change the types of every function in my program :)
12:01:24 <Cale> timthelion: yeah
12:01:31 <Nereid> lispy: for example, statically checking pre/postconditions
12:01:53 <Nereid> lispy: http://personal.cis.strath.ac.uk/~conor/Kleisli.pdf
12:01:58 <Cale> timthelion: Believe me, you don't really have to do this everywhere for every sum type :)
12:02:14 <timthelion> Cale: perfection!
12:02:42 <timthelion> Cale: it doesn't matter if there are dirty dishes in the sink, or my cloths smell. I want coding perfection, do you hear me.
12:02:59 <Cale> timthelion: It's only when you have complex stuff that only applies to some of the cases of the sum type, and you want to reflect that fact at the type level.
12:03:03 <t7> timthelion: better start coding in ruby then
12:03:16 <Cale> t7: lol
12:03:36 <timthelion> Cale: But you see, when you're writting large extencible applications. That which is simple now, may not be simple in the future.
12:03:58 <lispy> Nereid: I'm familiar with indexed monads and I've seen how they related to resource management, sequencing operations, and continuations. I guess I was wondering what applications you have in mind :)
12:04:07 <timthelion> Cale: the definition of Simple, is something that will be complex next time we add a feature.
12:04:09 <Nereid> lispy: oh, no specific applications.
12:04:18 <Nereid> just playing.
12:04:34 <lispy> Nereid: ah cool.
12:04:57 <rwbarton> with that attitude we should just give up and never write any program at all
12:05:39 <newsham> rwbarton: good thinking.  also since you're writing a perfect program you can just do it on paper.  no need to run it.. its already perfect.
12:05:54 <timthelion> rwbarton: Hey, I'm really progressing.  I add something refactor, and start over.  Now I'm refactoring.  But I've done quite a bit with this little program so far.
12:05:55 <lispy> Nereid: FWIW, I started implementing them in the darcs source for making patch sequencing operations more type safe, but I stopped because it wasn't very technically satisfying (the properties weren't really enforceable and it quite painful)
12:06:21 <Cale> timthelion: Yeah, but the type system makes that refactoring possible
12:06:32 <Cale> timthelion: So you don't have to over-design early.
12:07:00 * lispy 's experience with Haskell-isms that approach dependently typed programming is that they become exponentially hairy
12:07:04 <Cale> You change something and then steamroll it with GHC and fix type errors until it compiles
12:07:12 <timthelion> Cale: I do that a lot.
12:07:40 <merijn> lispy: Time to switch to agda!
12:07:55 <lispy> merijn: or idris!
12:08:27 <raek> is main of type IO () or IO a?
12:08:41 <t7> IO a i think
12:08:53 <Cale> It's of type IO A, where A can be whatever type you like
12:08:55 <lispy> Actually, I would love to be able to write more proofs about my Haskell code. To this end Brian Huffman has done some great work in Isabelle. You should look for his ICFP talk if you're into that kind of tihng.
12:09:04 <Cale> (which is different from being polymorphic)
12:09:45 <c_wraith> hmm.  does GHC 7.6 have arithmetic on its type-level naturals?
12:10:05 <t7> arith is just a type level function
12:10:25 <raek> ok, thanks
12:10:27 <c_wraith> yes, but having it defined by the extension is nicer than writing it yourself
12:11:07 <t7> i like a smaller compiler and a bigger std lib
12:12:04 <c_wraith> I'm mostly asking because the code for it *did* already exist as part of the type level naturals extension being worked on for the past years
12:12:22 <c_wraith> Also, it apparently was *way* faster than any library implementation
12:12:47 <c_wraith> because it actually used domain semantics, rather than having to re-implement addition from scratch
12:14:04 <Jello_Raptor> huh, why am I getting this error? http://hpaste.org/74356 (line 6 in the error is line 8 in the paste)
12:14:07 <Jello_Raptor> 36*
12:14:32 <Jello_Raptor> can you not mix pattern matching and guards?
12:14:57 <matthiasgorgens> Jello_Raptor: try _ instead of -.
12:15:03 * Jello_Raptor facepalms 
12:15:06 <Jello_Raptor> matthiasgorgens: thanks :)
12:15:31 <matthiasgorgens> Jello_Raptor: parseEntry - _ would have probably given an even better error message. :o)
12:15:57 <Jello_Raptor> matthiasgorgens:  <_< it compiles
12:17:40 <timthelion> Cale: thanks, exicentials will save me :)
12:18:05 <Cale> matthiasgorgens: lol, if it gave an error at all
12:18:52 <Cale> let parseEntry - _ = Nothing in "blah"
12:18:55 <Cale> > let parseEntry - _ = Nothing in "blah"
12:18:56 <lambdabot>   "blah"
12:19:01 <Cale> > let parseEntry - _ = Nothing in 5 - 6
12:19:02 <lambdabot>   Nothing
12:19:22 * hackagebot kqueue 0.1.2.4 - A binding to the kqueue event library.  http://hackage.haskell.org/package/kqueue-0.1.2.4 (ErikHesselink)
12:19:24 * hackagebot chuchu 0.1.2 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.1.2 (FelipeLessa)
12:20:34 <johnw> can conduit each run in their own thread, for parallel pipelining?
12:21:06 <johnw> I have an archive unextractor that essentially will do something like tar | gzip -d > foo, and I want the tar and gzip parts to execute concurrently
12:21:09 <merijn> johnw: Not easily
12:21:39 <merijn> johnw: I've thought about it for a while and I don't think its possible without reimplementing (or maybe even reenvisioning) conduits
12:21:54 <johnw> hrpmh
12:22:26 <johnw> how would you solve that problem without conduits?
12:22:29 <johnw> my current code doesn't use them
12:22:39 <johnw> it just does the steps one by one in a recursive function
12:25:04 <johnw> @src const
12:25:04 <lambdabot> const x _ = x
12:25:18 <johnw> @pl (\_ -> f)
12:25:18 <lambdabot> const f
12:25:27 <msieradzki> I have 1 question I always worked around in weird ways, if I have GHC 7.6.1 what cabal-install should I get and where from? from git (1.17 where GHC's is 1.16)
12:26:13 <johnw> huh, 1.14 is what's on hackage
12:26:45 <Nereid> msieradzki: cabal /= cabal-install
12:26:54 <Nereid> cabal comes with ghc
12:27:02 <nand`> When loading files with :l Foo.hs Bar.hs  is it possible to automatically re-import the modules that got unloaded by doing so?
12:28:17 <msieradzki> Nereid, I know that
12:28:56 <Nereid> msieradzki: there is no cabal-install 1.17 or 1.16. the latest is 0.14.0
12:28:58 <msieradzki> ok simpler question does cabal-install 1.14 work correctly with ghc 7.6.1 and GHC's library Cabal =1.16
12:29:08 <Nereid> it should
12:29:10 <msieradzki> Nereid, github disagrees with you
12:29:27 <dcoutts_> msieradzki: yes
12:29:35 <dcoutts_> I was using it yesterday
12:29:42 <Nereid> ok, 0.17.0
12:29:42 <johnw> can ghc safely be built with make -jX?
12:30:01 <thoughtpolice> johnw: yes
12:30:05 <johnw> cool
12:30:05 <msieradzki> that's another question :) I was asking about newer cabal-install because I heard it finally supports -j something
12:30:06 <johnw> thanks
12:30:06 <thoughtpolice> it makes the build much faster
12:30:15 <thoughtpolice> and the build system has quite good dependency tracking
12:30:28 <johnw> ok, make -j20 it is...
12:30:29 <thoughtpolice> so fiddling with stuff and running 'make' again should almost always Just Work(TM), modulo some stuff
12:30:38 <johnw> some projects are never fully reliable with highly parallel builds
12:30:59 <johnw> so, today I need to make a "rehoo" utility
12:31:06 <thoughtpolice> it's pretty important to get a GHC build down to decent times, honestly. just compile the libraries with optimization only too and it saves a lot of time
12:31:10 <johnw> because hoogle combine *.hoo fails with "too many open files"
12:31:27 <johnw> i want something that builds a tree of .hoo's, and then "collapses" each tree segment in parallel
12:31:31 <thoughtpolice> of course, i've nurtured half-day long GHC builds before, so my brain timers may be off
12:32:15 <johnw> thoughtpolice: what do you mean by "optimization only"?
12:32:19 <johnw> there aren't many options to ./configure
12:33:27 <mm_freak> -j20 is not a good idea for haskell, unless you really have 20 cores
12:33:34 <johnw> yeah, I almost do
12:33:41 <paolino> @src scanl
12:33:41 <lambdabot> scanl f q ls = q : case ls of
12:33:42 <lambdabot>     []   -> []
12:33:42 <lambdabot>     x:xs -> scanl f (f q x) xs
12:33:43 <mm_freak> unlike compilers for other languages GHC is actually quite CPU-busy
12:34:05 <johnw> i'll have to give it some of my IRC client's time slices then ;)
12:34:24 * hackagebot fclabels 1.1.4.3 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.4.3 (ErikHesselink)
12:34:29 <johnw> well, I only use 1-2 ghc's running anyway
12:34:35 <johnw> at least in this first part of the build
12:34:41 <johnw> s/use/see
12:35:08 <mm_freak> GHC is sufficiently fast on my systems that i never really bothered to ask for parallel compilation, even though i have quite a large ~/.cabal/world
12:35:09 <Nolrai> Hey anyone here know Coq or where to find people who do? The freenode chanel seems dead.
12:35:34 <mm_freak> Nolrai: is it a Coq-specific question, or could agda people answer it as well?
12:35:48 <mm_freak> #agda is a somewhat active channel
12:35:57 <johnw> mm_freak: building GHC takes a couple hours for me
12:36:06 <mm_freak> johnw: i don't build GHC
12:36:06 <johnw> and I like to run the full test suites
12:36:09 <johnw> oh, ok
12:36:24 <thoughtpolice> johnw: you have to modify mk/build.mk, and tell the build system to compile the libraries with optimization, not GHC. you don't really need GHC to be optimized as much as you do the libraries you're going to use
12:36:25 <johnw> Nolrai: first, prove that it's dead
12:36:27 <mm_freak> seems unreasonable to do, unless you want to become a GHC developer
12:36:30 <thoughtpolice> this will save you a lot of time
12:36:42 <Mathnerd314> when is GHC going to switch to a cabal-only build?
12:36:42 <johnw> thoughtpolice: what does it do otherwise?
12:36:43 <thoughtpolice> i can build GHC in >20 minutes easily on a dual core corei5
12:36:49 <thoughtpolice> johnw: it builds with full optimization
12:36:51 <thoughtpolice> Mathnerd314: probably never
12:36:54 <johnw> oh, I see
12:36:57 <mm_freak> thoughtpolice: johnw builds GHC in >20 minutes, too =)
12:37:02 <thoughtpolice> er, <20
12:37:03 <johnw> haha
12:37:03 <thoughtpolice> :)
12:37:08 <johnw> good one, mm_freak
12:37:18 <mm_freak> easily ;)
12:37:36 <thoughtpolice> johnw: http://hackage.haskell.org/trac/ghc/wiki/Building read all this
12:37:56 <thoughtpolice> especially the "Getting started for developers guide", it contains a lot of good info on how it works and what options there are to cut down build times
12:38:09 <Mathnerd314> thoughtpolice: even if GHC and cabal can do fully parallel builds?
12:38:18 <thoughtpolice> building GHC without optimization and building in parallel are really the two biggest wins
12:39:14 <thoughtpolice> Mathnerd314: GHC's build system does a lot more than cabal supports (very advanced dependency tracking for one.) GHC also doesn't abide by any standard hierarchial filesystem layout. cabal IS used in the GHC build system for a lot of stuff, but much of the rules are defined elsewhere in make.
12:39:24 * hackagebot una 2.1.0 - Universal un-archiver utility  http://hackage.haskell.org/package/una-2.1.0 (JohnWiegley)
12:39:57 <thoughtpolice> and there's everything in there from patching stuff (although i think most of that is gone wrt libffi now) to running the full testsuite to having many options to control the build and it's settings that cabal just can't handle as it stands
12:40:28 <thoughtpolice> it's really tough to even work on GHC unless you know some of these tricks, they can make the turnaround time substantially more tolerable and easy to work with when you're hacking on something
12:42:22 <johnw> thoughtpolice: well, I'm not going to use 7.6 anyway today, so I'll just let it merrily munch away &
12:42:55 <dispy> [x | x <- xs, x `mod` p > 0] << what does this extension do? make a list of x where x is element of xs and x mod p > 0 for each x ?
12:42:55 <SLi> Still GHC's build system doesn't seem to do everything. Yesterday I toyed a bit with template haskell, but ended up not using it in my project at that point because the payoff would have been small and it complicated building with profiling (instead of saying that I need to build the project first without profiling and with some magic -prefix flags, couldn't ghc --make do that automatically for me?).
12:43:00 <dispy> *this expression
12:43:51 <johnw> dispy: yes
12:44:33 <dispy> what does <-, exactly? By now, I only know that from IO monads
12:44:46 <johnw> it's almost the exact same thing, if you think of the List monad
12:44:56 <nand`> do { a <- b; c} is sugar for b >>= \a -> c
12:45:02 <nand`> oh
12:45:05 * nand` should read context
12:45:28 <nand`> dispy: <- does the same thing it does for monads, actually :P
12:45:34 <johnw> is there a variant of setNumCapabilities that is the same as -N with no number?
12:45:41 <johnw> I want my app to auto-use all available cores
12:45:51 <dispy> nand: I just suspect that xs is tacked with a monad at all :)
12:45:54 <nand`> [a | b <- c] is (with MonadComprehensions) sugar for c >>= \b -> a
12:46:02 <thoughtpolice> there's an API in there somewhere that will tell you the max number of cores, IIRC
12:46:05 <nand`> err
12:46:06 <nand`> return a*
12:46:11 <thoughtpolice> in Control.Concurrent i'm pretty sure
12:46:13 <johnw> i guess i call it with getNumCapabilities
12:46:30 <johnw> GHC.Conc.setNumCapabilities <$> GHC.Conc.getNumCapabilities
12:46:39 <johnw> wrap 14, scotty!
12:46:39 <dispy> a* ? :X
12:46:57 <nand`> a
12:47:14 <shachaf> getNumProcessors is what you're looking for.
12:47:25 <nand`> while it doesn't exactly generalize to the case with multiple lists, you can see [a | b <- c] as equivalent to map (\b -> a) c
12:47:34 <shachaf> Keep in mind that if it's lower than the number of capabilities GHC won't be able to do anything.
12:47:59 <luite> I'm pretty happy with the setNumCapabilities addition :)
12:48:13 <dispy> hm okay nand`
12:49:34 <thoughtpolice> SLi: i'm not referring to --make. it's not used in GHC's build system, it does manual dependency tracking which is how it allows parallel builds. cabal's resolver and/or --make could be smarter in that case probably, but it's not what i'm talking about
12:50:01 <SLi> thoughtpolice, ah! I misunderstood.
12:50:29 <SLi> I didn't read very thoroughly and just parsed "GHC's build system" as "ghc --make". Now it's obvious you are talking about building GHC :)
12:54:25 * hackagebot happstack-clientsession 7.2.1 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.2.1 (JeremyShaw)
13:00:04 <johnw> thoughtpolice: the only gripe I have with GHC's tests are the OOM tests
13:00:16 <johnw> on the Mac, at least, these cause swap exhaustion and bring my machine to a halt, while never completing
13:01:23 <paolino> is it expected no difference in performance using data A a = A a a or newtype A a = A (a,a) ?
13:01:27 <Igloo> johnw: Which tests are they?
13:01:36 <johnw> I'm running again right now and will let you know
13:01:49 <johnw> i think they have OOM or OutOfMemory in the name, IIRC
13:02:10 <johnw> test/rts/outofmem.hs and test/rts/outofmem2.hs
13:02:28 <Igloo> johnw: outofmem is being run for you on OS X?
13:02:38 <johnw> i'll let you know soon
13:02:42 <johnw> maybe this was fixed in the recent past
13:05:09 <applicative> wow, the new the pipes library looks awesome
13:07:51 <startling> paolino: I suspect that the latter might perform better
13:07:57 <startling> but I don't actually no
13:07:58 <startling> *know
13:08:05 <hpaste> marcot pasted “Type error” at http://hpaste.org/74361
13:08:32 <marcot> Hi.  I'm having a problem interpreting this type error.  I can't think of a type signature that would solve the issue.
13:09:06 <timthelion> marcot: get rid of the type signature if you can't think of one. Where's there error message?
13:09:22 <marcot> timthelion: I just pasted.
13:09:34 <marcot> Sorry, I pasted the code.
13:09:37 <marcot> I'll paste the error.
13:09:55 <hpaste> marcot annotated “Type error” with “Type error (annotation)” at http://hpaste.org/74361#a74362
13:10:54 <johnw> @pl (\p -> return $ extension p == ".ext")
13:10:54 <lambdabot> return . (".ext" ==) . extension
13:10:54 <startling> marcot: is the error the same without a type signature? if not, paste that one too
13:11:42 <msieradzki> I totally forgot what was the cause but I'm getting it again: loadObj... HSprimitive-0.4.1.o failed (mingw32 version) unknwon PEi386 section '.eh_frame'
13:11:48 <msieradzki> with GHC 7.6.1
13:12:09 <marcot> startling: Is it possible to declare a class method without a type signature?
13:14:10 <startling> marcot: oh oops, lemme look a little more closely
13:14:19 <Nolrai> Oh its a default implemetation.
13:14:25 <msieradzki> nevermind I used too new GCC (4.6.2 while GHC has 4.5.2 bundled)
13:14:26 <Nolrai> That makes more sense.
13:14:49 <paolino> startling, I realize now there is no difference because of the tuple, which count as a datatype wrapping
13:15:15 <startling> paolino: that might be true
13:15:36 <Z`> I'm trying to understand this line from gentle intro to haskell:   State c1 >>= fc2 = State (\s0 -> let (r, s1) = c1 s0; State c2 = fc2 r in c2 s1) , specifically I'm puzzle by c1 so. What does that do ?
13:15:59 <nand`> with -XDataKinds, are negative numeric literals promoted also?
13:16:50 <paolino> Z`: c1 :: s  -> (a ,s)
13:17:40 <timthelion> marcot: There's an obvious problem.  You are asking if an "item" is an element of a list of type [Item item]
13:18:03 <paolino> Z` it takes a state and produce a value with a new state
13:18:06 <Z`> paolino: how did you figure out its type? Judging from "State c1" ?
13:18:15 <paolino> sure
13:18:20 <Z`> thank you
13:18:26 <paolino> @src State
13:18:26 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:18:39 <timthelion> marcot: look at the type signature of LL.head :: list -> item. It's not head :: list -> Item item
13:18:40 <mm_freak> +T
13:18:56 <timthelion> marcot: no clue how to fix it though.
13:18:58 <c_wraith> nand`: the fact that they have kind Nat would imply not
13:19:22 <nand`> c_wraith: which is why I'm wondering, since the text just mentions ‘numeric literals’
13:19:37 <marcot> timthelion: The context of the class declaration is ListLike full (Item full), so LL.head gets the type full -> Item full
13:19:37 <nand`> but the name implies positive numbers only
13:19:44 <dispy> how can I count the number of occurences of a value x in a list?
13:19:44 <timthelion> marcot: perhaps just (Item x) `element` from
13:19:45 <Z`> so, since c1 :: s -> (a, s), then c1 s0 = (a, s0) ?
13:19:47 <dispy> frequency?
13:19:49 <nand`> positive integers, even
13:19:59 <marcot> timthelion: Item is a type function.
13:20:09 <paolino> dispy length . filter (==x)
13:20:20 <dispy> thanks
13:20:28 <timthelion> marcot: but that makes from :: [Item (Item full)]
13:20:33 <mm_freak> Z`: if you sitll have problems with State, try to implement Reader first…  the 'Reader e' monad provides an environment of type 'e', something like State where you can't change the state
13:20:34 <startling> ^ that's O(2n), though, isn't it?
13:20:45 <mm_freak> Z`: newtype Reader e a = Reader (e -> a)
13:20:52 <startling> you can do it with one iteration
13:21:21 <timthelion> marcot: or from :: [Item (Item a)]
13:21:29 <timthelion> marcot: they still don't match up
13:21:30 <mm_freak> Z`: notice how it's like State, but doesn't return a new state as part of the result
13:21:37 <lightquake> startling: O(2n) is the same as O(n)
13:21:39 <Z`> mm_freak: I'm in a state (pwn unintended:P) that I have to figure things out, because If I switch to another problem, even if simpler, new questions arise. I'll figure it out now that paolino hinted me
13:21:47 <marcot> timthelion: I'm not following you.  from is the first parameter of replaceOneOf, which type is simply [Item full].
13:21:52 <timthelion> marcot: because from isn't a list of "item"s but a list of "Item item"s
13:22:05 <mm_freak> Z`: ok, and once you've done that, implement Reader =)
13:22:08 <Cale> Z`: oh, I was going to explain State to you, but I got pulled away by work
13:22:10 <Z`> mm_freak: sure thing!
13:22:12 <marcot> timthelion: There's no such type as item.  There's only full and Item full.
13:22:33 <Cale> Z`: come to #haskell-overflow and we'll implement State, and explain the steps
13:22:34 <mm_freak> Cale: he is starting to understand how State is not about mutable state, but about transition functions
13:22:38 <startling> lightquake: it could be. how would you denote "iterates twice" otherwise?
13:22:40 <timthelion> marcot: go back and look at your code.
13:23:00 <mm_freak> Cale: yesterday he implemented most of State except the Monad instance, which i told him to save for the very end
13:23:09 <marcot> timthelion: I'm looking at it while I'm talkin to you.  What are you calling "item"?
13:23:21 <lightquake> startling: not using big-O notation :P
13:23:32 <mm_freak> Cale: so you can assume knowledge of basic State computations, fmap (stateMap) and return (stateId)
13:23:47 <Z`> mm_freak: yes, I understood how you 'emulate' a state by injecting it into a state transition function.thansk!
13:24:16 <timthelion> marcot: what is the type of x?
13:25:37 <mm_freak> Cale: and you're one of the few people who would prefer the name "stateId" over "stateReturn" or "statePure" =P
13:25:51 <nobdrais1ntone> Is there a method in cabal-devel to get latest version of package?
13:26:01 <timthelion> marcot: once you figure out the type of x, and see that x :: a doesn't fit with from :: [a]  you'll see the error.
13:26:10 <marcot> I belive the type of x is x :: (ListLike list item, LikeLike full (Item full)) => item, which is x :: Item full
13:26:29 <Cale> mm_freak: I usually just call it return
13:26:34 <Cale> ?
13:26:47 <mm_freak> Cale: i let him implement it separately
13:26:54 <timthelion> marcot: does the error change if you tell GHC that?
13:27:45 <mm_freak> later he can say return = pure = stateId and gets id = Kleisli stateId
13:28:29 <marcot> timthelion: I tried to do that by adding a method to that class: hd :: full -> Item full; hd = LL.head
13:28:36 <marcot> timthelion: But the error hasn't changed.
13:29:21 <timthelion> marcot: but did you type x :: (ListLike list item, LikeLike full (Item full)) => item before the x = ?
13:29:43 <timthelion> marcot: or better.  x :: Item a
13:30:42 <marcot> timthelion: Well, x is not Item a, x is Item full.  It's not possible to refer to an external type variable in a where clause.
13:30:55 <marcot> timthelion: So there's no way to tell GHC that x is Item full.
13:31:50 <timthelion> marcot: I'm afraid I cannot help you then :(
13:31:55 <mm_freak> marcot: there are many ways…  either directly through the ScopedTypeVariables extension or indirectly via asTypeOf
13:32:33 <mm_freak> f :: forall a. a -> Maybe a; f x = y where { y :: Maybe a; y = Just x }
13:32:48 <mm_freak> that's ScopedTypeVariables…  the 'forall' brings 'a' into scope inside the where clause
13:34:46 <dgpratt> maybe because I'm tired, but I can't figure out how the types work out for a particular definition I'm looking at
13:34:52 <hpaste> dgpratt pasted “type checking improve” at http://hpaste.org/74363
13:35:23 <marcot> mm_freak: Well, what if the function is the default implementation of a class method?  Have you seem the paste?
13:35:32 <dgpratt> can someone explain how the type of 'improve' works out considering its definition?
13:35:42 <marcot> mm_freak: http://hpaste.org/74361
13:36:44 <dgpratt> any type that involves a scoped 'forall' causes my head to hurt
13:37:29 <johnw> @pl (case y of "" -> "default.hoo"; x -> x)
13:37:29 <lambdabot> (line 1, column 15):
13:37:29 <lambdabot> unexpected ">"
13:37:29 <lambdabot> expecting variable, "(", operator or ")"
13:37:46 <johnw> what is wrong with that syntax?
13:37:54 <shachaf> dgpratt: Just think of it as an argument.
13:38:10 <shachaf> johnw: How do you expect @pl to handle pattern-matching?
13:38:11 <mm_freak> marcot: i think GHC 7.6 will have the possibility to refer to class type variables
13:38:15 <marcot> @pl (case y of {"" -> "default.hoo"; x -> x})
13:38:15 <lambdabot> (line 1, column 12):
13:38:15 <lambdabot> unexpected "{"
13:38:15 <lambdabot> expecting variable, "(", operator or ")"
13:38:24 <mm_freak> marcot: until then you will have to use the indirect way via asTypeOf
13:38:31 <dgpratt> oh, I think maybe I just figured it out
13:38:38 <mm_freak> > (3 `asTypeOf` sin) 4
13:38:39 <lambdabot>   3.0
13:39:16 <mm_freak> marcot: using ScopedTypeVariables you can also write type signatures for patterns
13:39:36 <mm_freak> replaceOneOf (from :: …) (to :: …) …
13:39:44 <mm_freak> those type variables are in scoped inside the 'where'
13:39:49 <mm_freak> scope
13:40:21 <mm_freak> the main type signature establishes the connection to the class type variables, while the argument signatures allow you to reintroduce names
13:40:24 <mm_freak> ugly, but works
13:40:29 <marcot> mm_freak: cool.  About the type error on the paste, do you have any clue?
13:41:34 <mm_freak> sorry, no clue without looking deeper
13:41:53 <dgpratt> in this case it is 'improve' that gets to choose the instance of 'TreeLike' (and it chooses the 'CTree' instance), not the caller as is usually the case, yes?
13:42:02 <marcot> mm_freak: I have created a dummy parameter to use asTypeOf, but it is still not working.  I'll paste.
13:42:22 <hpaste> marcot annotated “Type error” with “asTypeOf” at http://hpaste.org/74361#a74364
13:44:02 <applicative> dgpratt: it is awfully clever, that improve...
13:44:39 <dgpratt> applicative: 'tis :)
13:44:51 <dgpratt> applicative: too clever for me to really comprehend, in fact
13:46:49 <dgpratt> is there a specific term for what I would call the 'caller' or 'call site' of a function?
13:47:02 <kanedank> I still don't understand do blocks and how they require an expression at the end -- what should I be reading more of?
13:48:34 <applicative> Main.abs insists on reading m as in CTree a -- since thats Treelike, its must be one of the types m appears in -- and  so on
13:48:58 <applicative> kanedank: your block ends with a 'z <- action' ?
13:49:49 <applicative> kanedank but in the usual account of desugaring, this is the same as 'action >>= \z -> '
13:49:58 <applicative> which is no way to end anything...
13:50:45 <Mathnerd314> why doesn't type Z '(a,b) = Either a b work?
13:50:52 <monochrom> I just say "caller" and everyone understands
13:50:56 <kanedank> applicative: that helped, thanks!
13:51:00 <applicative> so, whenever you write 'x <- m' you need another line
13:51:12 <applicative> monochrom: I never understand that language
13:51:33 <hpaste> dongwusch pasted “endless recursion” at http://hpaste.org/74365
13:51:49 <dispy> any ideas on why this: http://hpaste.org/74365 ends in an endless recursion?
13:52:11 <monochrom> I say "caller" and "callee" all the time and everyone seems to understand. "f :: forall t. (forall b. ...b...) -> t" I say "caller chooses t, callee chooses b" and everyone agrees
13:52:23 <shachaf> dispy: foo bar^x === (foo bar)^(x)
13:52:32 <applicative> except me , not that I disagree.
13:53:01 <dispy> sachaf: so (bar^x) was right?
13:53:04 <dispy> * would be
13:53:14 <mm_freak> dgpratt: "caller" is fine…  also valid are "user" or "application"
13:53:14 <jfischoff> this looks pretty cool: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/promotion.html#promoted-literals. Anyone messed around with these yet?
13:53:21 <shachaf> forall t. (forall b. ...(forall m. ...m...) -> ...b...) -> ...t...
13:53:29 <monochrom> "caller" and "callee" come from the imperative world, but they're perfectly applicable to the functional world too. In fact, with rank-N types and existential types, you need to say them more
13:53:54 <dgpratt> mm_freak, monochrom: ok, good; didn't want to cause undue confusion with that terminology
13:54:14 <mm_freak> well, "caller" is unfortunate, but it's also a word everybody understands
13:54:32 <monochrom> do you prefer "call site"?
13:54:38 <dgpratt> still training myself to say 'function application' instead of 'function execution' (or some variation thereof)
13:55:08 <mm_freak> i prefer "user"
13:55:09 <monochrom> I just like how "caller" and "callee" have the same length. it's better symmetry :)
13:55:22 <startling> thunker and thunkee
13:55:26 * applicative tries to imagine a mathematician using the language of calling and being called 
13:55:27 <monochrom> oh, then the pair is "user" and "implementer"
13:55:47 <mm_freak> implementator
13:55:53 <applicative> Mathnerd314: what would T ('Either a b) be?
13:55:58 <monochrom> usor and implementor!
13:56:02 <mm_freak> implementozer
13:56:08 <monochrom> usator? :)
13:56:15 <mm_freak> usinator
13:56:24 <Mathnerd314> applicative: a kind error
13:56:36 <kanedank> can someone help me with this code?: I can't figure out how I'm supposed to fix my createAgent funciton... http://hpaste.org/74366
13:56:47 <mm_freak> i'm usinating on the function
13:56:51 <mm_freak> s/on//
13:57:04 <shachaf> kanedank: "return a"?
13:57:22 <shachaf> kanedank: You should read an introduction to IO in Haskell, if you haven't already.
13:57:31 <monochrom> eh? you have misalignment, lines 40 and 41, "do" and "let" should not be aligned
13:58:06 <monochrom> similarly for the rest of createAgent
13:58:29 <shachaf> Oh, that too.
13:58:55 <kanedank> shachaf: hmm, I tried that but I got the same error:     The last statement in a 'do' construct must be an expression: r <- randomIO
13:59:09 <startling> hmmm? it's not a misalignment
13:59:15 <Mathnerd314> applicative: perhaps you meant T '(Left a)?
13:59:19 <shachaf> kanedank: Well, that error message indicates that it thinks that the last statement is "r <- randomIO", doesn't it?
13:59:28 <shachaf> kanedank: So fix that. :-)
13:59:28 <kanedank> startling: actually I didn't check that yet, whoops
13:59:32 <shachaf> @quote alignment
13:59:32 <lambdabot> No quotes match.
13:59:40 <shachaf> @quote aligned
13:59:40 <lambdabot> thoughtpolice says: at least with python you have the comfort of knowing that one day you won't be woken up to discover your house is burned, family & dog raped, and civilization collapsed due to
13:59:40 <lambdabot> some C++ insanity that happens only when the moons are aligned correctly, it's friday, you're wearing a green t-shirt and it's the 27th day of june on a 10 year cycle
13:59:42 <hpc> it's alignment; look again
13:59:55 <hpc> the layout rules are that the block starts after the keyword
14:00:04 <hpc> do |r <- ...
14:00:16 <hpc>    ^-- block starts there
14:00:19 <dispy> haskell has allocated about 1,3 GB of my 2GB RAM and I can't kikll it :( neither killall nor kill on the pid are working
14:00:20 <hpc>     etc
14:00:22 <hpc>     etc
14:00:30 <startling> dispy: kill -9 yo
14:00:30 <dispy> I#ve got Ubuntu 12.04 lts :X
14:00:44 <startling> dispy: kill -9 pid
14:00:57 <hpc> http://hpaste.org/74366 -- that should fix it
14:01:12 <hpc> (scroll down)
14:01:25 <shachaf> hpc: Except it doesn't fix the type error...
14:01:34 <dispy> thanks ;)
14:01:45 <hpc> shachaf: parsing is more important :P
14:01:51 <shachaf> Also, that's probably not how you should fix it.
14:01:57 <shachaf> Something like foo = do\n    ...
14:02:59 <applicative> Mathnerd314: yes, sorry.  But doesn't my question stand?  E.g. type T (z :: (k -> k -> *)) a b = Either a b makes sense ...
14:03:02 <kanedank> this is what I have so far: http://hpaste.org/74368
14:03:31 <kanedank> haskell mode is trying to help me but I don't know what I'm doing :(
14:04:45 <monochrom> that is not what I get in haskell mode. at the end of "do r <- randomIO", I hit <enter>, I get the cursor under "r", not under "do"
14:05:30 <akamaus> Hi! What do you think of recently released ghc-7.6.1? So much so nice syntactic extensions :)
14:06:14 <shachaf> Wait, it's out?
14:06:19 <shachaf> whoa, dude
14:06:20 <monochrom> choose 'turn-on-haskell-indentation. do not choose 'turn-on-haskell-indent or 'turn-on-haskell-simple-indent
14:06:31 <shachaf> Someone update the topic!
14:06:32 <Cale> akamaus: The LambdaCase extension isn't quite how I wanted it to be. The real things I'm excited about are the typesystem things more than the syntax sugar though.
14:06:49 <shachaf> Cale: Finally we can -fdefer-type-errors!
14:06:55 <Cale> lol
14:06:57 <monochrom> I know one day I will have to set the topic for GHC 7.6.1
14:06:58 <Mathnerd314> applicative: well, I don't see any problems with it. The question is why GHC doesn't accept it.
14:07:20 <akamaus> Cale, I'm now skinning through release notes :) Syntax caches the eye
14:07:22 <monochrom> poll: which url shortener do you prefer? :)
14:07:30 <applicative> Mathnerd314: even if you drop fancy kinds, does type T (a,b) = Either a b make sense ?
14:08:01 <akamaus> shachaf, what's the use case for  -fdefer-type-errors?
14:08:03 <monochrom> and defer-type-errors is evil
14:08:30 <monochrom> oh, but I just heard a nice use case. to write tests for "must not type-check"
14:08:42 <startling> haha
14:08:47 <akamaus> :))
14:09:02 <startling> when does it defer them to?
14:09:08 <startling> run-time ?? o.o
14:09:13 <Cale> startling: run-time, yes
14:09:16 <monochrom> so, I imagine, the test contains type-wrong code, and outside it an exception-catching wrapper. if exception, good; if no exception, bad
14:09:29 <akamaus> welcome dynamic madness :)
14:09:33 <Cale> and it's not quite the same as being dynamically typed
14:09:49 <akamaus> Cale, can you elaborate a bit?
14:10:22 <Mathnerd314> applicative: sure, it generates the constraint (T (a,b) ~ Either a b)
14:10:50 <Cale> It's just that the type equality constraints which are generated in System FC are implemented by errors whenever the typechecker would otherwise have complained.
14:10:54 <Mathnerd314> applicative: and I think that's all you can do with it.
14:11:02 <Cale> It still infers and checks types
14:11:24 <kanedank> monochrom: thank you for helping me fix emacs!
14:11:35 <Cale> it just defers any type errors to runtime by literally putting the error message in that spot in the code statically where it will occur.
14:11:48 <startling> oh, that's not too bad
14:11:59 <akamaus> Cale,  so you can run a semi-complete program?
14:12:02 <Cale> yes
14:12:30 <akamaus> hm.. sounds good for prototyping and experiments
14:13:40 <Cale> (you also still get warnings about the type errors which it found)
14:15:50 --- mode: ChanServ set +o monochrom
14:16:08 <johnw> is there a concurrent library that implements "pools"?
14:16:21 --- topic: set to '["GHC 7.6.1 http://v.gd/CEBRVo ","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
14:16:26 <johnw> I'm calling forkIO a lot, but I only want X jobs happening at once; the others should block until a slot is free
14:16:56 * monochrom decides to promote "v.gd". yes, even more than "is.gd"
14:17:09 --- mode: monochrom set -o monochrom
14:17:14 <Clint> johnw: does resource-pool not fit?
14:17:15 <rwbarton> is.gd is good, but v.gd is very good?
14:17:28 <monochrom> yes IMO v.gd is better :)
14:17:59 <monochrom> I think the difference comes down to just this: is.gd defaults to direct jump. v.gd defaults to preview. both defaults can be cookie-changed
14:18:07 <parcs`> you shouldn't be promoting any url minifier ;)
14:18:19 <parcs`> they are bad for the web!
14:18:24 <Mathnerd314> hmm, my vote would have been for http://tinyarrows.com/
14:18:32 <monochrom> but I want to promote "default to preview". it is more moral for most circumstances
14:19:19 <akamaus> By they way, Is ghc-7.6.1 feasible now? I mean, how many packages from hackage can be compiled with it?
14:19:59 <parcs`> i don't think anybody knows that yet
14:21:17 <Cale> johnw: you're aware that there is an N:M scheduler which schedules the Haskell threads created by forkIO onto available OS threads created by +RTS -N#?
14:21:51 <Cale> (assuming that you're using the threaded runtime, otherwise, there's only one thread running at a time)
14:22:33 <Cale> johnw: Is there a particular reason why you want to avoid creating too many Haskell threads?
14:22:39 <johnw> ok, here's what I do
14:22:44 <Cale> You can use a quantity semaphore
14:22:45 <johnw> I create threads that run shelly tasks
14:22:52 <johnw> so each thread blocks pretty quickly
14:23:00 <johnw> meaning that Haskell can then run the other threads
14:23:09 <johnw> which means I end up running all N shelly tasks
14:23:15 <johnw> I need to restrict the concurrency to N shelly tasks at a time
14:23:22 <Cale> okay
14:23:24 <johnw> a quantity semaphore?
14:23:30 <timthelion> Cale: Do I undestand correctly, that with my Values which we talked about earlier.  In order to get the name of the value, I need to now define a function anyValueName with cases for all the different types of parametricity?(That doesn't sound bad on the start of it, but I calculated that with the level of algebraicism I would like I'd need 9 cases per record!
14:23:31 <johnw> you mean, a counted MVar?
14:23:35 <applicative> Mathnerd314: this works, so I guess I see type family TT (f :: (*,*)) :: * ; type instance TT '(a,b) = Either a b
14:23:54 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-QSem.html -- oh, huh, it looks like they're removing these?
14:23:57 <Cale> I wonder why...
14:24:01 <shachaf> That's not a real semaphore. It's only a semiphore.
14:24:03 <applicative> Mathnerd314: then eg a :: TT '(Int,Char); a = Left 5  works
14:24:27 <timthelion> What is the purpose of a semiphore when we have MVars?
14:24:27 <Cale> http://hackage.haskell.org/packages/archive/SafeSemaphore/0.9.0/doc/html/Control-Concurrent-MSem.html
14:24:37 <Cale> timthelion: To count?
14:24:41 <johnw> ok, that should do the trick, Cale
14:24:54 <Cale> It's easy to implement with MVars of course :)
14:24:58 <johnw> i'll just consume the MSem count before each shelly job, and restore it after
14:25:06 <Cale> johnw: right
14:25:07 <johnw> yeha, maybe I should just do that
14:25:28 <Cale> actually, it's not *that* easy
14:25:44 <johnw> so I should use MSem?
14:25:52 <Cale> yeah, just use MSem, I think :)
14:25:56 <timthelion> Cale: how is it not easy?
14:26:04 <shachaf> Why are they getting rid of QSem?
14:26:16 <c_wraith> it's broken
14:26:29 <Cale> Apparently it doesn't handle exceptions properly
14:26:32 <c_wraith> I don't remember the details, something to do with not being exception-safe
14:27:43 <Cale> timthelion: Perhaps it would be easier with Chan ()
14:28:44 <Cale> timthelion: the semantics you want are like those of Chan (), so you can increment the number of something available, as well as decrement it, and if a decrement would make the amount negative, it has to block until someone else does an increment.
14:29:09 <Mathnerd314> applicative: right, so why does it have to be a type family instead of a type synonym?
14:29:50 <applicative> Mathnerd314: yes, I came around to your position.
14:30:01 <timthelion> Cale: seems like a fine place to have an STM that retrys while negative.
14:30:05 <Cale> yes
14:30:13 <Cale> With STM it's definitely easy
14:30:44 <applicative> Mathnerd314: now I'm wondering if its the same as the issue raised by edwardk on the glasgow-haskell-users list
14:31:06 <Cale> with MVar, you end up in a funny position of needing to check if the MVar is empty or not before incrementing, if you do it the naive way, where an empty MVar represents zero resource available so that things will block.
14:31:09 <johnw> ok, MSem is really easy to use
14:31:14 <kenneth2> has anyone gotten haskell to run on ubuntu 12.10 ?
14:31:26 <Cale> johnw: yeah :)
14:33:48 <johnw> this is odd, getNumCapabilities is returning 1 on my machine
14:34:01 <Cale> Does it bother anyone else that the haddock says "Safe-Infered" rather than "Safe-Inferred"?
14:34:03 <dzhus> johnw: do you run with +RTS -N?
14:34:12 <monochrom> yes because it comes from run time +RTS -N and defaults to 1
14:34:13 <johnw> oh
14:34:15 <applicative> johnw: doesn't it tell you .... what dzhus said
14:34:15 <johnw> I get it
14:34:27 <c_wraith> Cale: must have been written by Philip Hammond-Baker
14:34:35 <shachaf> "error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory"
14:34:36 <Twisol> Cale: yep
14:34:42 <shachaf> I hope I don't have to compile GHC by hand?
14:34:42 <c_wraith> (the guy who famously misspelled the "referrer" header in HTTP)
14:34:48 * shachaf doesn't remember the standard solution to this...
14:35:02 <monochrom> oh but there are two standard solutions
14:35:04 <parcs`> shachaf: get an older version of gmp
14:35:15 <dzhus> enjoy your revdep-rebuild
14:35:25 <shachaf> parcs`: Not really available.
14:35:29 <dzhus> is using UndecidableInstances damages the performance?
14:35:38 <dzhus> *does
14:35:39 <dzhus> *damage
14:35:43 <monochrom> the second standard solution is hex-edit the ghc executable to change the libgmp version
14:35:45 <Cale> dzhus: Of the compiler?
14:35:51 <dzhus> Cale: now, the runtime
14:35:54 <dzhus> *no
14:35:57 <parcs`> shachaf: what's your distribution?
14:36:08 <dzhus> me spikin cat language??
14:36:08 <shachaf> parcs`: Debian.
14:36:11 <Cale> dzhus: Not any more than the usual overhead of typeclasses.
14:36:21 <monochrom> UndecidableInstances damages compile-time performance
14:37:04 <dzhus> Cale: From what I previously heard if instance can be decided statically in compile-time there's little to no overhead (no dictionaries swinging around). But seems like with UndecidableInstances this is not the case.
14:37:21 <Cale> dzhus: Types don't exist at runtime
14:37:33 <Cale> dzhus: So it *has* to do this at compile time
14:37:53 <parcs`> shachaf: looks like libgmp3c2 provides it
14:38:08 <Cale> also, it *will* pass dictionaries around pretty much regardless, unless you explicitly add SPECIALISE pragmas to everything
14:38:24 <shachaf> parcs`: No such package.
14:38:34 <parcs`> shachaf: yeah just noticed it's only for squeeze
14:39:00 * shachaf sighs at Debian.
14:39:22 <Cale> shachaf: What does the GHC package depend on?
14:39:23 <parcs`> don't sigh at debian, sigh at the build bots that link against an old version of gmp
14:39:31 <Cale> shachaf: (in the version of debian you're using)
14:39:41 <parcs`> shachaf: you can probably bump the so version on relevant binaries without much trouble
14:40:01 <shachaf> parcs`: Debian Wheezy is missing all sorts of packages that are both in Squeeze and in Sid.
14:40:16 <shachaf> Cale: Debian's GHC package depnds on libgmp10.
14:40:23 <shachaf> Presumably they compile it themselves.
14:40:27 <Cale> shachaf: is that installed?
14:40:30 <shachaf> Which, uh, I guess I can do with ghc6, too.
14:40:32 <shachaf> Cale: Yes.
14:40:47 <Cale> trololol, make a symlink and hope for the best?
14:41:01 <shachaf> Maybe I'll just compile from source.
14:41:11 <parcs`> shachaf: wait are you trying to install 7.6 via haskell.org or 7.4 via apt?
14:41:15 <applicative> Mathnerd314: you can write type T (x :: (*,*)) = Either (Fst x) (Snd x)
14:41:20 <shachaf> parcs`: 7.6 via haskell.org
14:41:40 <parcs`> yeah those get built against debian squeeze..
14:42:18 <shachaf> thanks ghc
14:42:49 <parcs`> shachaf: http://hackage.haskell.org/trac/ghc/ticket/7202
14:43:44 <applicative> Mathnerd314: ... if you have type families for Fst and Snd.   It is a little opaque
14:44:19 <shachaf> "Our build machines are all on Ubuntu 12.04 now, which has libgmp.so.10, so the next set of bindists will be linked against that."
14:44:24 <shachaf> 6 days ago.
14:44:33 <shachaf> Doesn't seem to have happened.
14:44:48 <shachaf> JaffaCake: Was that supposed to be for 7.6 or for future versions?
14:44:59 <parcs`> why did they switch to ubuntu anyway :(
14:45:07 <Cale> nooooo
14:45:28 <parcs`> debian 7 is just around the corner
14:45:51 <monochrom> what's wrong with ubuntu for their purpose. repeat: for their purpose
14:46:00 <monochrom> (I'm sure ubuntu is all wrong for you, yes)
14:46:18 * shachaf installs Squeeze libgmp3c2
14:46:23 <Cale> Upgrading Ubuntu beyond 11.04 sucks
14:46:36 <shachaf> Hah! .debs from a different version of the distribution.
14:46:40 <Cale> I've tried to do it more than once and been forced back
14:46:48 <shachaf> It's like early-2000s RPM heaven!
14:46:48 <Cale> by various stupid issues
14:46:58 * shachaf remembers it fondly.
14:47:22 <monochrom> looks like I will have to repeat 3 times next time
14:47:33 <monochrom> what's wrong with ubuntu for their purpose. repeat: for their purpose. repeat: for their purpose.
14:47:39 <sully> so, I want a "random list monad", which is would be like the list monad but shuffles the list before doing the map over it
14:47:53 <sully> has somebody produced code for this already?
14:48:15 <parcs`> monochrom: what's wrong with debian (the os they have been using before allegedly switching to ubuntu) for their purpose
14:48:28 <Cale> monochrom: "There's nothing wrong with Ubuntu, it's just not for you, Ubuntu users."
14:48:47 <parcs`> i don't see the point of ubuntu lts over debian stable
14:48:54 <parcs`> s/point/advantage
14:48:56 <timthelion> Is ubuntu for someone?
14:48:56 <monochrom> that one I don't know
14:49:15 <Cale> There was at one point an advantage: it used to be configured more sanely out of the box.
14:49:23 <timthelion> parcs`: does debian have a graphical installer yet?
14:49:30 <Cale> This has becoming less and less true over time
14:49:44 <Cale> as the Ubuntu devs apparently all decided we're on touchscreen tablets?
14:50:00 <parcs`> timthelion: i think so, if you install via live disk
14:50:01 <Jeanne-Kamikaze> yeah
14:50:13 <Cale> and need a user interface with gigantic icons for our big stubby fingers
14:50:16 * timthelion remembers when ubuntu was the only distro shipping binarry ATI drivers(or was it nvidia...) and all the others wanted you to patch the kernel by hand after every update.
14:50:23 <Jeanne-Kamikaze> I never got the whole let's pretend the desktop is a table thing
14:50:31 <Cale> and that audio should auto-mute when you plug in headphones, just like an iPod Touch would.
14:51:00 * timthelion is on a tablet.
14:51:05 <Cale> because you're not on a desktop machine, and it's totally not a problem to plug and unplug your headphones all the time
14:51:54 <Cale> also, the Gnome 2 panel was too useful and configurable, so they removed all the configurability of it
14:51:56 <shachaf> Bah, everything's broken with 7.6.
14:52:02 * timthelion is in the odd possition of both liking Arch and not being able to reccomend it to anyone
14:52:03 <Cale> and then they put it back, only worse
14:52:27 <timthelion> Cale: do you want to start on PulseAudio yet?
14:52:34 <Twisol> XD
14:52:39 <timthelion> :D
14:52:43 <Cale> also, they removed the pretty configuration interfaces to many things, and then put them into an ugly Tweak tool
14:52:52 <johnw> Cale: got a moment for a little code review: https://github.com/jwiegley/rehoo/blob/master/Main.hs
14:52:55 <Cale> becasue that's the sensible thing to do ;)
14:53:06 <johnw> it starts out being just as parallel as I want, but then it slows down to one process at a time
14:53:07 * timthelion sentences Cale to 30 days of windows 8 trail for his rantings.
14:53:15 <Cale> timthelion: It's not even just PA anymore
14:53:21 <Cale> It's ALSA too.
14:53:28 <Cale> somehow
14:53:32 <timthelion> Cale: alsa works great for me here on arch...
14:54:02 <Cale> There's this stupid jack-sensing garbage in the kernel. I'll admit I haven't tried to see what happens when I rebuild my kernel.
14:54:16 <Cale> But if I start doing stuff like that, what the hell is the point of using a linux distribution?
14:54:18 <parcs`> timthelion: except when two applications try to play audio at once
14:54:56 <timthelion> parcs`: haven't tried that.  I usually(read have never) want that.  I mean, if I was DJing I'd use jackd2.
14:55:12 <Twisol> Having used all three big OSes, and having settled on (for the moment) Mac, what draws people to Linux?
14:55:24 * timthelion wishes jackd was "the default" for linux.  It rocks once you get it running.  
14:55:32 * Twisol prays a flame war doesn't start
14:55:40 <timthelion> Twisol: easy.  Configurability
14:55:55 <Cale> So I gave up on upgrading, even though the main reason was to be able to run a 64 bit OS now that I have more than 4GB of memory, and am still stuck on a 32 bit version of 11.04 with a PAE kernel. I guess I could try to get a 64 bit version of 11.04 or maybe an even earlier version.
14:55:57 <monochrom> lack of money and a bit of liking unix draw me to linux
14:56:14 <timthelion> Twisol: have you used xmonad, 3i, ratpoison, or one of the other "greats" of the tiling window world?  Or compiz for that matter?
14:56:15 <monochrom> also how ghc works better on linux than on mac
14:56:24 <Twisol> timthelion: I can see that, sure. I always felt like I was about to brick my installation when I tried changing things though.
14:56:55 <Twisol> timthelion: I've tried xmonad on Mac, but I'm sure that's not where it was intended to run. Didn't get too much into it, but I liked the design.
14:56:55 <timthelion> Twisol: at this point, I wouldn't be comfortable anywhere else.  And it only takes me an hour and a half to re-install.
14:57:24 <Cale> I have an even longer list of complaints about Windows and MacOS.
14:57:26 <timthelion> Twisol: actually, the ease of re-instalation is a biggy. On windows the files get put everywhere.
14:57:36 <timthelion> Cale: :P
14:57:50 * timthelion cannot complain about either, as he has never used Mac, and windows was years ago.
14:58:13 <Twisol> I have a Windows partition I only use for gaming.
14:58:13 <timthelion> Twisol: but I live in xmonad. I'd never leave
14:58:25 * timthelion doesn't game
14:58:38 * Cale games under Wine
14:58:57 * timthelion has skype installed on his android phone.
14:59:01 <Cale> I sometimes have to do elaborate things to get games running, but it generally works pretty well.
14:59:08 <timthelion> but not on the normal linux box.
14:59:15 <Twisol> It's funny. I started getting into Ruby when I used Ubuntu. A lot of that community uses Mac, so when I switched, things were suddenly very smooth.
14:59:21 <Twisol> Now I'm getting into Haskell, and it's like reversed.
15:00:08 <Cale> I have Skype on my iPod Touch as well as my desktop.
15:00:15 <timthelion> Twisol: I think another reason not to use Mac, is the moral shadyness of the people who use it.  Since it is a comercial OS, there is more likelyhood that the people who are writting the software you're using are assholes trying to screw you over.
15:00:39 <timthelion> Good reason not to use android too.
15:00:54 <Cale> Skype on my iPod touch does this irritating thing when I start it up where before I can chat with someone, I have to watch it slowly iterate over all the chat messages from the last several days.
15:00:58 <Twisol> Good reason not to use a lot of things.
15:01:11 <monochrom> good riddance
15:01:11 <Twisol> timthelion: didn't Microsoft pick up Skype? ;)
15:01:14 <timthelion> Twisol: I'm not saying that you personally are morally shady.  I hope it didn't come accross that way.  Just the ecosystem
15:01:22 <timthelion> Twisol: yes, MS owns skype.
15:01:26 <Twisol> timthelion: Hehe, I understood.
15:01:59 <rwbarton> for me the main advantage of linux over mac can be summed up by "apt-get install"
15:02:05 <Twisol> <3 apt
15:02:07 <timthelion> rwbarton: very true
15:02:15 <timthelion> pacman -Syu foo
15:02:16 <Cale> Apple is now more evil than MS ever was, when it comes to screwing with the people trying to develop for their devices.
15:02:33 <rwbarton> macs are quite tolerable though, just installing software could be a hassle at times (not applications, but stuff like a jabber server)
15:02:42 <Twisol> *nod*
15:02:54 <hpc> Cale: they've gotten pretty anticompetitive too
15:03:03 <Twisol> I just use Mac because it's so easy to interface with. By which I mean gestures.
15:03:36 <Cale> People say such good things about Apple's UI design, and I don't understand why.
15:03:39 <Twisol> and the Ruby ecosystem is pretty strong too
15:03:41 <timthelion> Twisol: Compiz invented those.
15:03:55 <Twisol> timthelion: I don't doubt that. I never noticed though.
15:04:15 <Twisol> Cale: Have you never experience the glory of three-finger horizontal swipe?
15:04:17 <Twisol> *experienced
15:04:20 <timthelion> compiz is an unstable load of Cr*p comapaired with xmonad though :D
15:04:35 <Cale> Most of their UI design is a mishmash of things cargo culted from 80's Apple UIs which made sense in a time where you ran one application at a time, and things which no thought went into beyond making it look cool.
15:04:37 <hpc> Cale: the only argument i really understand is "it's a unix environment that doesn't take 30 hours to set up"
15:04:47 * applicative must have  disabled three-finger horizontal swipe
15:05:05 <Twisol> applicative: switches between adjacent desktops/full-screen apps
15:05:29 <timthelion> hpc: isn't that what fedora core is for?
15:05:50 <hpc> i always saw fedora as "the other debian"
15:06:04 <timthelion> hpc: debian isn't corporate sponsored
15:06:21 * timthelion found fedora to be horrible.  Which means his dad would like it.
15:06:53 <saml> http://en.reddit.com/r/explainlikeimfive/comments/zh0d8/what_is_comonad/
15:07:08 <Cale> hpc: But it does take quite a bit of time to set up if you want it to *really* behave sanely. Like, there's the hack to make home/end/pgup/pgdn work correctly (i.e. like they do on every other computer ever), which involves creating and/or editing a text file in an undocumented(?) format.
15:07:19 <Cale> and lots of other little things like that
15:07:58 <Twisol> Funny thing about Ubuntu. I always had trouble getting the media keys, keyboard backlight, etc. working.
15:08:03 <imeredith> after using redhat before the days of yum, I then dicovered debian apt-get - i think that has coloured my view on fedora
15:08:03 <Cale> saml: lol
15:08:05 <hpaste> keep_learning pasted “Network Transport first code” at http://hpaste.org/74369
15:08:06 <monochrom> I don't understand the "explain like I'm 5" attitude. a 5-year-old probably doesn't even understand the concept of "5". what could you possibly explain?
15:08:20 <Twisol> Which made using the computer a bit of a pain, because I use Pandora. :P
15:08:31 <keep_learning> Hello All
15:08:34 <timthelion> imeredith: nah, fedora still has crappy package management.  Too many user run repos.  There are 4 default file managers
15:08:48 <johnw> "explain like I'm 5" means: Give me a cookie so I can't be amused at your funny hair while you're mouth moves around
15:08:49 <keep_learning> I am going through this example https://github.com/haskell-distributed/distributed-process/wiki/Network.Transport
15:08:54 <johnw> s/can't/can
15:09:00 <johnw> s/you're/your.  sigh
15:09:04 <monochrom> perhaps I should just s/don't understand/disagree with/. it is not supposed to be understood.
15:09:09 <parcs`> monochrom: you should start an "EL15 EL15" thread
15:09:21 <parcs`> ELI5*
15:09:28 <keep_learning> and trying to modify the code to send the response by server and receive the answer by client.
15:10:18 <keep_learning> When server gets the client's ConnectionId but I am not sure how to send the response to client and how to read this response in client
15:12:51 <keep_learning> some one please.
15:13:11 <shachaf> I don't get it.
15:13:23 <shachaf> build-depends: base >= 3 && < 5, containers >= 0.3 && < 0.6
15:13:37 <shachaf> Why is `cabal install` trying to install containers-0.4.* for this?
15:13:47 <shachaf> 0.4.2.1
15:13:53 <benmachine> shachaf: add all the -v?
15:14:07 <benmachine> modern cabal is quite informative, I find, about why it makes decisions
15:14:29 * hackagebot rehoo 0.1.0 - Rebuild default.hoo from many .hoo files in the current directory  http://hackage.haskell.org/package/rehoo-0.1.0 (JohnWiegley)
15:14:31 * hackagebot rehoo 0.1.1 - Rebuild default.hoo from many .hoo files in the current directory  http://hackage.haskell.org/package/rehoo-0.1.1 (JohnWiegley)
15:14:35 <monochrom> yes. also add --dry-run always for safety
15:15:09 <monochrom> also, with 99% probability the problem is elsewhere, i.e., the existence of some other packages
15:15:44 <shachaf> [__6] rejecting: containers-0.5.0.0/installed-e49..., 0.5.0.0 (global constraint requires <0.5)
15:15:47 <shachaf> But why?
15:15:54 <shachaf> Where's that constraint coming from?
15:16:02 <monochrom> some other line
15:16:49 <JoeyA> Is GHC 7.6 intended as a preview-ish release sort of like 7.2 was?
15:17:04 <shachaf> monochrom: The only line before that that mentions containers is [__6] next goal: containers (dependency of semigroups-0.8.4:-base2)
15:19:55 <JoeyA> I was under the impression there were still a number of issues to resolve (e.g. constraint solving so type-level arithmetic works)
15:21:13 <monochrom> I wonder where does "global constraint" come from
15:21:43 <shachaf> ...Ugh.
15:21:57 <shachaf> shachaf@carbon:~$ grep containers ~/.cabal/config
15:21:57 <shachaf> constraint: containers < 0.5
15:22:18 <shachaf> monochrom: Thanks for that. :-)
15:22:21 <zzing_> Is there any way to enable acls on a file system without reboot? (file system is /)
15:24:18 <johnw> zzing_: uh, OS?  filesystem?  ACL scheme?
15:24:31 <johnw> the answer to your qusetion is: it depends
15:24:32 <zzing_> oh sorry, wrong channel
15:24:42 <zzing_> I thought I was in #freebsd, my very bad :P
15:24:46 <johnw> ah :)
15:24:48 <shachaf> @tell conal GHC 7.6 breaks TypeCompose (new type operators behavior)
15:24:48 <lambdabot> Consider it noted.
15:25:13 <johnw> @tell shachaf I know what you did last summer.
15:25:13 <lambdabot> Consider it noted.
15:25:35 <shachaf> @messages johnw: What?
15:25:35 <lambdabot> johnw said 22s ago: I know what you did last summer.
15:26:27 <johnw> :)
15:26:40 <johnw> for some reason, I just like messing you with, I gives me lulz
15:27:24 <johnw> the other day I was musing about creating a lambdabot clone named lamdabot, as in Lam, Da Bot, and I just kept laughing to myself thinking how much you'd hate that name
15:28:25 <Jeanne-Kamikaze> that's pretty good
15:30:16 <parcs`> > sum $ take 1000 (iterate (/3) 1)
15:30:17 <lambdabot>   1.5
15:30:36 <parcs`> nice
15:30:46 <`Jake`> cool
15:32:27 <parcs`> > sum $ take 1000 (iterate (/3) (2/3))
15:32:28 <lambdabot>   0.9999999999999997
15:33:01 <`Jake`> > sum $ take 10000 (iterate (/3) (2/3))
15:33:02 <lambdabot>   0.9999999999999997
15:36:21 <ion> > sum (take 100) (iterate (/3) (2/3)) :: CReal
15:36:22 <lambdabot>   Couldn't match expected type `[a]'
15:36:22 <lambdabot>         against inferred type `[a1] -> [...
15:36:31 <ion> > sum (take 100 (iterate (/3) (2/3))) :: CReal
15:36:33 <lambdabot>   1.0
15:37:15 <ion> > showCReal 200 (sum (take 100 (iterate (/3) (2/3))))
15:37:16 <lambdabot>   "0.999999999999999999999999999999999999999999999998059674782517367162411493...
15:38:34 <`Jake`> > showCReal 200 (sum (take 1000 (iterate (/3) (2/3))))
15:38:38 <lambdabot>   mueval-core: Time limit exceeded
15:38:45 <johnw> do we think holes will be 7.8?
15:40:31 <conal> shachaf: uh oh. what happens to TypeCompose in 7.6?
15:40:31 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:42:42 <conal> @tell member:shachaf uh oh. what happens to TypeCompose in 7.6?
15:42:42 <lambdabot> Consider it noted.
15:42:56 <shachaf> I don't think that @tell will go through.
15:43:20 <shachaf> conal: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html
15:43:21 <conal> oh. my client added something.
15:43:24 <shachaf> The behavior of the TypeOperator extension has changed: previously, only type operators starting with ":" were considered type constructors, and other operators were treated as type variables. Now type operators are always constructors.
15:43:35 <shachaf> Which means you can't use ~> as a type variable.
15:43:46 <conal> shachaf: oh, rats. that's terrible.
15:43:47 <conal> i
15:43:47 <conal> wond
15:43:48 <conal> er
15:43:57 <conal> i wonder whether that decision is reversible.
15:44:08 <shachaf> There was a mailing list discussion about it.
15:44:15 <conal> yeah?
15:44:26 <shachaf> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg21084.html
15:44:32 <conal> thx
15:45:35 <conal> sigh. i'm very fond of these infix variables for arrow-ish stuff.
15:47:34 <conal> shachaf: thanks for the alert
15:48:25 <johnw> is there an env var that GHC built executables use for dynamic loading of packages?
15:48:45 <shachaf> Dynamic loading?
15:48:53 <johnw> my lambdabot was built with cabal-dev, and it's failing to find runtime loaded packages in that cabal-dev repo
15:49:03 <johnw> I type "> 1 + 2", and it says it can't find Test.IOSpec
15:49:11 <johnw> which only lives in .../lambdabot/cabal-dev/...
15:49:58 <shachaf> This is a runtime code running thing.
15:50:01 <shachaf> Which is completely different.
15:50:06 <shachaf> It uses the GHC API and all that for it.
15:50:17 <johnw> how do I configure paths for that then?
15:50:34 <johnw> GHC 7.6.1 fulltest finished on OS X 10.7.4:
15:50:36 <johnw> https://gist.github.com/3661018
15:50:43 <johnw> I didn't have any OOM problems with this build
15:50:46 <shachaf> Look at how it runs the code.
15:50:47 <johnw> 46 unexpected failures :(
15:50:51 <shachaf> Look at the documentation for that.
15:50:53 <shachaf> I don't know.
15:51:09 * shachaf ☟
15:52:15 <johnw> oh, I see
15:52:21 <johnw> it's using the mueval binary
15:54:31 <johnw> well, given that mueval -e '1 + 2' doesn't work either, I shouldn't expect much
15:57:07 <johnw> shachaf: GHC_PACKAGE_PATH is what I was looking for
15:58:33 <johnw> yay, it works
16:00:21 <startling> are monad transformers usually newtypes or what?
16:01:15 <monochrom> usually yes
16:01:29 <startling> k.
16:04:29 <johnw> @djinn (a -> b) -> [a] -> b
16:04:29 <lambdabot> Error: Undefined type []
16:04:33 <johnw> @djinn foo :: (a -> b) -> [a] -> b
16:04:33 <lambdabot> Cannot parse command
16:04:58 <johnw> @djinn (a -> b) -> a -> b
16:04:59 <lambdabot> f a = a
16:05:08 <mm_freak> @djinn (a -> b) -> Maybe a -> b  -- impossible
16:05:08 <lambdabot> Cannot parse command
16:05:11 <johnw> @djinn (a -> b) -> a -> Maybe b
16:05:11 <lambdabot> f a b = Just (a b)
16:05:12 <mm_freak> @djinn (a -> b) -> Maybe a -> b
16:05:13 <lambdabot> -- f cannot be realized.
16:05:51 <johnw> what other cool stuff can lambdabot do?
16:06:20 <startling> @pl is my favorite
16:06:20 <lambdabot> is my favorite
16:06:28 <startling> heh
16:06:28 <johnw> :)
16:06:40 <mm_freak> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
16:06:41 <lambdabot> forall a b (f :: * -> *) a1 (f1 :: * -> *). (Functor f1, Functor f) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
16:06:59 <mm_freak> looks incomplete
16:07:08 <startling> @djinn Monoid m => (a -> m) -> [a] -> m
16:07:08 <lambdabot> Error: Undefined type []
16:07:13 <mm_freak> :t fmap
16:07:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:07:54 <mm_freak> @djinn b -> (a -> b) -> Maybe a -> b
16:07:54 <lambdabot> f a b c =
16:07:54 <lambdabot>     case c of
16:07:54 <lambdabot>     Nothing -> a
16:07:54 <lambdabot>     Just d -> b d
16:08:48 <mm_freak> @djinn b -> (e -> b) -> (a -> b) -> Either (Maybe e) (Maybe a) -> b
16:08:48 <lambdabot> f a b c d =
16:08:48 <lambdabot>     case d of
16:08:48 <lambdabot>     Left e -> case e of
16:08:48 <lambdabot>               Nothing -> a
16:08:48 <lambdabot>               Just f -> b f
16:08:50 <lambdabot>     Right g -> case g of
16:08:52 <lambdabot>                Nothing -> a
16:08:54 <lambdabot>                Just h -> c h
16:09:35 <mm_freak> djinn can spam quite a lot
16:09:40 <mm_freak> @djinn b -> (a -> b) -> Maybe (Maybe (Maybe (Maybe a))) -> b
16:09:40 <lambdabot> f a b c =
16:09:40 <lambdabot>     case c of
16:09:41 <lambdabot>     Nothing -> a
16:09:41 <lambdabot>     Just d -> case d of
16:09:41 <lambdabot>               Nothing -> a
16:09:42 <lambdabot>               Just e -> case e of
16:09:44 <lambdabot>                         Nothing -> a
16:09:46 <lambdabot>                         Just f -> case f of
16:09:48 <lambdabot>                                   Nothing -> a
16:09:50 <lambdabot>                                   Just g -> b g
16:10:08 <zomg> What is this?
16:10:20 <parcs`> @help djinn
16:10:20 <lambdabot> djinn <type>.
16:10:21 <lambdabot> Generates Haskell code from a type.
16:10:21 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
16:10:21 <zomg> It generates a function from the signature that does.. something?
16:10:21 <mm_freak> zomg: give it a type and it constructs a function of that type
16:10:23 <dmwit> give a type signature, get code
16:10:36 <zomg> I see
16:10:38 <parcs`> @djinn Maybe (Either a b) -> Either (Maybe a) (Maybe b)
16:10:38 <lambdabot> f a =
16:10:39 <lambdabot>     case a of
16:10:39 <lambdabot>     Nothing -> Left Nothing
16:10:39 <lambdabot>     Just b -> case b of
16:10:39 <lambdabot>               Left c -> Left (Just c)
16:10:39 <startling> @djinn a -> [[[[[[[[[[a]]]]]]]]]]
16:10:40 <mm_freak> zomg: it's a realization of the curry-howard isomorphism…  if a defined function exists, djinn will find it
16:10:41 <lambdabot>               Right d -> Right (Just d)
16:10:42 <lambdabot> Error: Undefined type []
16:10:58 <startling> what's the `undefined type []` thing?
16:10:59 <zomg> Useful? =)
16:11:15 <hpc> startling: djinn doesn't do recursively defined types
16:11:22 <mm_freak> zomg: yes, it can construct callCC and some other fancy stuff for you
16:11:31 <startling> hpc: oh. bleh
16:11:49 <zomg> mm_freak: I don't know what that is but I'll take your word for it :D
16:11:52 <hpc> startling: i imagine it wouldn't be too hard to get it into some infinite loops that way
16:11:56 <dmwit> ?djinn Maybe (Either a b) -> Either a (Maybe b)
16:11:57 <lambdabot> f a =
16:11:59 <lambdabot>     case a of
16:12:00 <mm_freak> zomg: callCC for the Cont monad
16:12:01 <lambdabot>     Nothing -> Right Nothing
16:12:01 <hpc> @djinn-env
16:12:03 <lambdabot>     Just b -> case b of
16:12:05 <lambdabot>               Left c -> Left c
16:12:07 <lambdabot>               Right d -> Right (Just d)
16:12:08 <hpc> wait, crap
16:12:09 <lambdabot> data () = ()
16:12:11 <lambdabot> data Either a b = Left a | Right b
16:12:13 <lambdabot> data Maybe a = Nothing | Just a
16:12:15 <mm_freak> zomg: the good old call/cc from scheme, just fancier and typed =)
16:12:15 <lambdabot> data Bool = False | True
16:12:16 <hpc> @stfu
16:12:17 <lambdabot> Plugin `djinn' failed with: thread killed
16:12:19 <lambdabot> Unknown command, try @list
16:12:22 <startling> hpc: haha
16:12:27 <rwbarton> @. djinn type let f x = (x,x) in f.f.f.f.f
16:12:28 <lambdabot> f a =
16:12:28 <lambdabot>     (((((a, a), (a, a)), ((a, a), (a, a))),
16:12:28 <lambdabot>       (((a, a), (a, a)), ((a, a), (a, a)))),
16:12:28 <lambdabot>      ((((a, a), (a, a)), ((a, a), (a, a))),
16:12:29 <lambdabot>       (((a, a), (a, a)), ((a, a), (a, a)))))
16:12:32 <zomg> mm_freak: yeah now I just need to learn scheme and the cont monad... ;)
16:12:52 <mm_freak> zomg: you don't know the mother of all monads? ;)
16:13:00 <zomg> Guess not!
16:13:04 <mm_freak> newtype Cont r a = Cont ((a -> r) -> r)
16:13:26 <mm_freak> instead of giving a value right away, take a function to pass the value to…  simple continuation passing style
16:13:32 <mm_freak> and CPS forms a monad:  Cont =)
16:13:36 <hpc> zomg: you can learn Cont without scheme :P
16:13:49 <zomg> hpc: well in order to learn what call/cc is I would need to learn scheme :D
16:14:05 <mm_freak> Cont is the little sister of Free and allows some really fancy stuff like labels and goto
16:14:06 <hpc> :t callCC
16:14:07 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
16:14:21 <hpc> zomg: learn Cont through experimentation for a bit
16:14:29 <hpc> then read sigfpe's reinversion of control post
16:14:51 <mm_freak> one of the things i like to use Cont for is aborting a 'forever' =)
16:15:00 <zomg> Yeah I've probably used something like that but without knowing that it's that monad :P
16:15:08 <johnw> what does @unlambda do?
16:15:17 <mm_freak> johnw: evaluates an unlambda expression
16:15:18 <rwbarton> gives an error message
16:15:19 <zomg> I mean in nodejs etc. you often pass functions as parameters which sort of act like in this fashion
16:15:23 <johnw> what are those?
16:15:27 <hpc> i use ContT to unfuck certain libraries that will remain nameless
16:15:28 <mm_freak> or what rwbarton said =)
16:15:36 <hpc> *cough*gtk*caugh*
16:16:03 <mm_freak> zomg: implement Cont yourself, it's not that hard
16:16:09 <mm_freak> State is harder to implement =)
16:16:31 <hpc> @unmtl a -> Cont r a
16:16:31 <lambdabot> a -> Cont r a
16:16:37 <hpc> oh come on
16:16:39 <hpc> @unmtl Cont r a
16:16:40 <lambdabot> (a -> r) -> r
16:16:48 <hpc> @djinn a -> (a -> r) -> r
16:16:48 <lambdabot> f a b = b a
16:16:53 <hpc> there's return
16:17:02 <hpc> (spoiler alert)
16:17:03 <mm_freak> almost, yeah
16:17:12 <Twisol> O_o
16:17:14 <mm_freak> djinn can even construct (>>=) for Cont =)
16:17:24 <hpc> don't do that until you get stuck
16:17:31 <hpc> you can also try writing join
16:17:36 <hpc> and fmap
16:17:56 <hpc> don't try (<*>) though - that way lies madness
16:18:13 <parcs`> i wish all forked threads were killed when 'main' exits
16:18:22 <johnw> hrpm,h I can't get @djinn to work locally, although it works from command-line ust fine
16:18:24 <mm_freak> parcs`: that's what happens
16:18:42 <mm_freak> parcs`: only exception is when the threads hang in an FFI call
16:19:01 <hpc> johnw: see the end of http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13
16:19:11 <johnw> thank you!
16:19:11 <parcs`> mm_freak: ah, i meant running 'main' through the ghci prompt
16:19:26 <KirinDave> In this code
16:19:27 <KirinDave> https://github.com/Barrucadu/Citation-Needed/blob/master/hakyll.lhs
16:19:32 <KirinDave> What is -->?
16:19:43 <mm_freak> KirinDave: a function
16:19:54 <KirinDave> mm_freak: Oh. Fascinating.
16:19:56 <hpc> johnw: i would send all those changes upstream if i could only figure out who has the power to apply the patch
16:20:00 <hpc> :/
16:20:03 <KirinDave> I'm just wondering if it's some standard function I'm unaware of.
16:20:11 <hpc> @hoogle (-->)
16:20:11 <lambdabot> No results found
16:20:19 <rwbarton> KirinDave, see line 184
16:20:22 <mm_freak> KirinDave: where xs --> fs = sequence (xs <**> fs)
16:20:26 <mm_freak> KirinDave: it's in the code =)
16:20:27 <johnw> hpc: oh, you did it!
16:20:30 <johnw> thank you so much for that blog entry
16:20:36 <KirinDave> Oh weird.
16:20:41 <KirinDave> I didn't see it
16:20:42 <johnw> the only thing I would add is that newcomers to doing this should install lambdabot using cabal-dev
16:20:45 <KirinDave> I was like Chrome, please find -->
16:20:48 <KirinDave> And it came up empty
16:20:50 <KirinDave> Weird.
16:20:53 <hpc> johnw: i did it in a VM ;)
16:20:55 <KirinDave> But sure enough it's right there and simple
16:20:56 <johnw> my main ~/.cabal conflicted in perfectly silently ways that led to deadlocks
16:21:04 <KirinDave> Well.
16:21:08 <KirinDave> "Simple"
16:21:27 <johnw> ok, now @djinn a -> b reports nothing at all
16:21:32 <dcoutts_> johnw: what deadlocks?
16:21:42 <johnw> lambdabot
16:21:46 <johnw> on my machine
16:21:52 <mm_freak> johnw: does a -> a work?
16:21:57 <johnw> mm_freak: no
16:22:06 <johnw> oh, wait, yes it does
16:22:14 <johnw> wonder why a -> b doesn't
16:22:14 <mm_freak> you know, you need your own nuclear reactor for djinn to receive enough power
16:22:20 <mm_freak> well, simple
16:22:25 <mm_freak> there is no defined function of type a -> b =)
16:22:28 <hpc> johnw: you try coming up with a definition yourself ;)
16:22:30 <johnw> haha
16:22:38 <johnw> be nice if it told me that
16:22:51 <johnw> ok, it's working fine now
16:22:56 <mm_freak> johnw: it's useful to know the CH to work with djinn =)
16:22:57 <johnw> thanks hpc, mm_freak!
16:23:18 <johnw> I now am able to type C-c C-b in any Haskell mode buffer, and communicate with my own personal lambdabot
16:23:37 <hpc> johnw: there's still a lot of lambdabot that won't work which i haven't gotten around to documenting fixes for
16:23:41 <johnw> i wish @djinn handled []
16:23:43 <mm_freak> "forall a b. a -> b" is a logical statement:  "for all a and b, from a follows b"
16:23:46 <mm_freak> which is clearly false
16:23:47 <johnw> hpc: like what?
16:23:51 <hpc> uh
16:23:56 <hpc> oeis probably
16:24:03 <hpc> that one i have no idea why it doesn't work
16:24:17 <johnw> what is the syntax?
16:24:19 <johnw> @oeis x
16:24:26 <hpc> @oeis 1,1,2,3,5
16:24:29 <lambdabot>  Expansion of product (1+x^(2k+1)), k=0..inf; number of partitions of n into ...
16:24:29 <lambdabot>  [1,1,0,1,1,1,1,1,2,2,2,2,3,3,3,4,5,5,5,6,7,8,8,9,11,12,12,14,16,17,18,20,23,...
16:24:38 <hpc> wtf lambdabot
16:24:41 <lambdabot> Plugin `oeis' failed with: thread killed
16:24:45 <johnw> hpc: that command worked fine here
16:24:50 <mm_freak> lo
16:24:50 <hpc> oh, neat
16:24:53 <rwbarton> @oeis 1 1 2 3 5
16:24:54 <johnw>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
16:24:54 <johnw>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,
16:24:54 <johnw> 39088169]
16:24:54 <johnw>  
16:25:02 <startling> how do I use lenses from `lens` with Data.Map?
16:25:05 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
16:25:05 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:25:12 <hpc> i probably messed something up with my VM then
16:25:14 <johnw> startling: try "at"
16:25:22 <Cale> startling: didn't I answer that question the other day?
16:25:25 <johnw> as in, m . at "foo"
16:25:27 <startling> Cale: not to me
16:25:33 <startling> johnw: thanks
16:25:44 <johnw> hpc: how do I load new modules into lambdabot's mueval namespace?
16:25:49 <johnw> I want Control.Lens available
16:25:54 <hpc> johnw: edit L.hs
16:26:00 <johnw> ahh
16:26:00 <hpc> in... State probably
16:26:05 <johnw> that's what that gigantic set of imports is all about
16:26:48 <hpc> if your machine sucks as much as mine does, you probably also want to factor out the L.hs into a package
16:26:54 <Cale> startling: you mostly use ^. which is also called view and .~ which is also called set
16:26:58 <johnw> hpc: what do you mean?
16:26:59 <hpc> (which has to be cabal-installed for mueval)
16:27:05 <hpc> my L.hs is
16:27:13 <hpc> module L where import IRC.Bot.L
16:27:24 <hpc> plus some extensions
16:27:29 <startling> Cale: oh. I meant specifically for key lookup and setting
16:27:30 <johnw> i don't know what you mean
16:27:39 <startling> johnw: do you know where `at` is defined? I'm looking through the haddocks for it
16:27:41 <hpc> nvm :P
16:27:47 <startling> oh wait, :info
16:27:48 <hpc> johnw: im just rambling at this point
16:27:59 <Cale> startling: Which lens exactly do you have?
16:28:10 <startling> Cale: `lens`
16:28:17 <startling> the latest one on hackage
16:28:17 <hpc> long story short, my computer is so slow that compiling L.hs exceeds the mueval time window
16:28:27 <Cale> lens is a function which makes a lens from a getter and setter
16:28:41 <Cale> (you could use it infix with backticks if you wanted)
16:28:41 <startling> Cale: yes, I know
16:28:49 <startling> Cale: I mean the package `lens`
16:28:58 <startling> Cale: what are you asking?
16:29:10 <Cale> I'm asking which actual lens you're trying to use to get or set something
16:29:17 <Cale> (which value)
16:29:43 <startling> Cale: none at the moment. I was asking which lenses to use on Data.Map.Maps
16:29:56 <Cale> oh, I see
16:29:58 <Cale> lol
16:30:04 <hpc> startling: follow the types?
16:30:08 <Cale> Somehow I completely missed that
16:30:12 <Cale> haha
16:30:14 <startling> Cale: oh ha
16:30:25 <startling> Cale: I was puzzled
16:30:56 <startling> hpc: yep, working on that now. I didn't realize that IndexedLens was what I wanted
16:31:03 <Cale> yeah, Control.Lens.IndexedLens
16:31:25 <Cale> defines an At class which has instances for Map, IntMap and HashMap
16:31:27 <johnw> I can't find `at` either, though I was sure I saw edwardk use it
16:31:33 <Cale> and that has   at :: k -> SimpleIndexedLens k (m v) (Maybe v)
16:31:51 <johnw> Cale: which version of lens?
16:32:00 <Cale> 2.6.1?
16:32:06 <johnw> ah, I was looking at the 2.0 docs for some reason
16:32:28 <startling> johnw: google led you astray?
16:32:42 <johnw> no, more complex than that
16:32:48 <johnw> i'm using a local hoogle, remmebr :)
16:33:02 <startling> haha
16:33:03 <johnw> apparently it defaults to use the oldest version of installed haddock docs
16:33:10 <startling> ugh
16:34:31 <startling> @hoogle Foldable f => f (Either a b) -> [a]
16:34:31 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
16:34:31 <lambdabot> Data.Graph.Inductive.Query.DFS topsort' :: Graph gr => gr a b -> [a]
16:34:31 <lambdabot> Data.Either rights :: [Either a b] -> [b]
16:34:44 <Cale> There's a TV corporation here called Global, and they have a news program called Global National, and then that news program has a local segment, which is the Global National Local News.
16:35:12 <hpc> startling: you can write your own by copying the lefts definition, assuming it uses a fold and not recursion
16:35:26 <hpc> Cale: i love it
16:35:30 <startling> hpc: yeah, that's true
16:35:56 <startling> hpc: lefts x = [a | Left a <- x]
16:36:12 <hpc> :(
16:36:17 <startling> :(
16:36:35 <hpc> that's the worst possible definition
16:37:16 <johnw> it should crash pretty fast too, I'd bet
16:37:24 <johnw> non-exhaustive, and all
16:37:42 <hpc> no, it uses fail
16:37:46 <hpc> @src [] fail
16:37:46 <lambdabot> fail _      = []
16:37:46 <johnw> oh, I see
16:37:54 <johnw> I forgot about that sugar in do notation too
16:38:02 <johnw> guess it's the same in list comprehensions
16:38:46 <startling> :t foldr (\a b -> if isLeft b then a:b else b) []
16:38:47 <lambdabot> Not in scope: `isLeft'
16:39:10 <startling> :t foldr (\a b -> if isLeft b then a:b else b) [] where isLeft (Left a) = True
16:39:11 <lambdabot> parse error on input `where'
16:39:23 <startling> you get the idea
16:39:52 <Cale> hpc: It morally doesn't use fail though ;)
16:39:53 <hpc> :t foldr (\a b -> case b of Left a -> a:b; _ -> b) []
16:39:54 <lambdabot>     Couldn't match expected type `[t]'
16:39:54 <lambdabot>            against inferred type `Either t t1'
16:39:54 <lambdabot>     In the second argument of `(:)', namely `b'
16:40:10 <Cale> I like the list comprehension way
16:40:16 <hpc> :t foldr (\b a -> case b of Left a -> a:b; _ -> b) []
16:40:17 <lambdabot>     Couldn't match expected type `[t]'
16:40:17 <lambdabot>            against inferred type `Either t t1'
16:40:18 <lambdabot>     In the second argument of `(:)', namely `b'
16:40:20 <hpc> pah
16:40:32 <hpc> Cale: yeah, lists have a nice fail
16:40:39 <hpc> as does Maybe
16:40:41 <Cale> As long as the word 'fail' doesn't explicitly occur somewhere, it's probably okay
16:40:49 <Cale> because it could secretly be mzero :)
16:41:21 <startling> hpc: oh, should be isLeft a
16:41:26 <startling> or case a of
16:42:17 <kenneth2> I'm trying to do "cabal install Network.BSD" and its not working. What am I doing wrong?
16:42:50 <aristid> kenneth2: install the package, not the module
16:43:06 <dcoutts_> kenneth2: package names are not the same as module names. library packages contain a bunch of modules.
16:43:11 <kenneth2> so "cabal install Network " ?
16:43:21 <startling> kenneth2: probably not
16:43:29 <startling> kenneth2: where did you hear about Network.BSD?
16:43:44 <aristid> it's in the network package
16:43:54 <dcoutts_> kenneth2: yes. You can confirm this by running: cabal info network
16:43:57 <kenneth2> oh I'm trying to run this program here: http://blog.moertel.com/articles/2004/03/13/concurrent-port-scanner-in-haskell
16:44:13 <johnw> ooh, LambdaCase got in
16:45:18 <startling> johnw: yeah!
16:45:25 <johnw> ooh, and multi-way if too
16:45:42 <johnw> though I don't quite see the value of that, except for code generators
16:45:49 <johnw> clearer to just put a function in a where clause
16:46:34 <johnw> oh, I like <> == mappend too
16:47:01 <startling> johnw: that's not new?
16:47:12 <johnw> it's mentioned in the 7.6 release notes
16:47:21 <johnw> if it's not new, I didn't know
16:47:21 <startling> oh, is it imported in Prelude?
16:47:24 <startling> > [1, 2, 3] <> []
16:47:25 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
16:47:26 <lambdabot>         agains...
16:47:38 <johnw> it's now in Data.Monoid
16:47:50 <monochrom> multi-way-if solves all problems!
16:47:52 <startling> weird, I've been using it for quite some time
16:48:04 <daniel_-> if i create a subfolder LocalA/ with LocalA/Main.hs and do "import LocalA" will it interpet automaticly take Main.hs then?
16:48:06 <johnw> monochrom: i can just rewrite my whole program as a main function now :)
16:48:08 <aristid> johnw: <> was in 7.4 already i'm pretty sure
16:48:15 <startling> daniel_-: no
16:48:23 <daniel_-> mkay
16:48:41 <johnw> :t (Data.Monoid.<>)
16:48:41 <startling> daniel_-: you'd have a LocalA.hs that exports LocalA.Main
16:48:42 <lambdabot> Not in scope: `Data.Monoid.<>'
16:48:50 <johnw> @hoogle (<>)
16:48:51 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
16:48:51 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
16:48:51 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
16:48:54 <johnw> doesn't seem so
16:49:04 <daniel_-> example LocalA/LocalA.hs then?
16:49:12 <startling> daniel_-: no
16:49:17 <startling> daniel_-: just LocalA.hs
16:49:19 <daniel_-> ye
16:49:23 <benmachine> <> definitely in my 7.4.2
16:49:25 <daniel_-> that's how i have it now
16:49:41 <johnw> oh, I don't know what version lambdabot is on
16:49:56 <startling> mine too
16:50:01 <Nereid> lambdabot is on some 6.x
16:50:10 <Nereid> 6.10?
16:50:14 <startling> anyway, the real solution would be (++) = mappend
16:50:21 <johnw> hpc: :t doesn't work in local lambdabot
16:50:35 <Nereid> indeed, use @type
16:50:47 <johnw> ah, thank you Nereid
16:50:53 <johnw> how come :t works here in the channe?
16:50:58 <Nereid> magic
16:51:02 <johnw> haha
16:51:06 <johnw> and what kind of magic is that?
16:51:06 <hpc> johnw: strange configuration
16:51:17 <monochrom> special case by popular demand
16:51:17 <hpc> the :t command doesn't work in PM either with this lambdabot
16:51:20 <johnw> lambdabot> @type (<>)
16:51:20 <johnw> forall m. Monoid m => m -> m -> m
16:51:21 <Nereid> it doesn't work here because no one told it to work here
16:51:22 <hpc> but it does work with @type
16:56:23 <johntromp> :t ap
16:56:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:56:33 <johnw> @src ap
16:56:33 <lambdabot> ap = liftM2 id
16:57:10 <johnw> um, how is that right?
16:57:14 <johntromp> > take 7$ap$iterate(>>=(\x->[x+1,1/(1+1/x)]))[1%1]
16:57:15 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
16:57:23 <johnw> oh, never mind
16:57:25 <johnw> i see it now
16:57:30 <johntromp> > take 7$join$iterate(>>=(\x->[x+1,1/(1+1/x)]))[1%1]
16:57:31 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,2 % 3,3 % 2,1 % 3]
16:57:47 <startling> :t flip id
16:57:48 <lambdabot> forall a b. a -> (a -> b) -> b
16:57:57 <startling> johnw: same idea
16:58:52 <johnw> how is that the same?
16:59:18 <johnw> liftM2 id (m (a -> b)) (m a) ends up being m ((a -> b) a)
16:59:37 <johnw> flip id is something else entirely
17:00:01 <startling> johnw: they both exploit id :: (a -> b) -> a -> b
17:00:06 <johnw> so, unless I'm wrong, ap = <*>
17:00:18 <startling> johnw: yeah, but it doesn't require Applicative
17:00:22 <johnw> startling: oh, I see
17:00:53 <startling> which is silly, but
17:01:32 <S11001001> :t (<.>)
17:01:33 <lambdabot> forall v. (InnerSpace v) => v -> v -> Scalar v
17:01:45 <startling> @hoogle (<.>)
17:01:45 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
17:01:45 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
17:02:00 <lpvb> how do I format a duration of time in seconds to HH:MM?
17:02:06 <lpvb> I thought there would be an easy way?
17:02:15 <startling> lpvb: Data.Time.NominalDiffTime
17:02:54 <startling> err, just DiffTime
17:03:26 <startling> lpvb: use secondsToDiffTime and then formatTime
17:04:55 <lpvb> formatTime doesn't take difftime
17:05:22 <startling> whoops
17:05:29 <startling> that's dumb
17:06:27 <lpvb> startling: :(
17:06:36 <lpvb> difftime is useless
17:07:52 <startling> lpvb: let minutes = myseconds `div` 60 `mod` 60; let hours = myseconds `div` 3600
17:07:58 <startling> I think that's right
17:10:09 <Cale> seconds since when?
17:10:14 <Cale> Just seconds in general?
17:10:45 <S11001001> startling: was hoping for Apply's operator from edwardk's semigroupoids
17:11:04 <Bynbo7> "(.) :: (Ob c a, Ob c b, Ob c c) => c b c -> c a b -> c a c" from the 7.6.1 release notes, that seems wrong to me c seems to be used for two different things?
17:11:07 <startling> S11001001: no idea
17:11:17 <S11001001> startling: generalized <*>
17:11:38 <dmwit> Axman6: Yes, looks wrong.
17:11:44 <dmwit> Probably cat b c -> cat a b -> cat a c
17:11:53 <Axman6> yeah
17:11:55 <Cale> lol
17:12:01 <Axman6> i'll let them know in #ghc
17:12:06 <dmwit> Though the constraints look really weird, too.
17:12:12 <Cale> Kind-distinguished type variables
17:12:14 <Cale> lol
17:12:19 <benmachine> lpvb: timeToTimeOfDay will turn DiffTime into TimeOfDay which can then be formatted
17:12:52 <dmwit> Oh, I get it.
17:13:01 <dmwit> The constraints are like Ob cat a, Ob cat b, Ob cat c
17:13:27 <Axman6> yeah
17:13:37 <monochrom> should s/cat/kitteh/
17:14:08 <lpvb> benmachine: Thanks, the show instance for TimeOfDay works great
17:14:16 <lpvb> was worried
17:14:26 <johnw> when I type "kitteh foo" at the shell, it just plays with my data, it doesn't give it back
17:14:40 <johntromp> > mapM_ print$join$iterate(>>=(\x->[x+1,1/(1+1/x)]))[1%1]
17:14:41 <lambdabot>   <IO ()>
17:14:52 <johntromp> > join$iterate(>>=(\x->[x+1,1/(1+1/x)]))[1%1]
17:14:53 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,2 % 3,3 % 2,1 % 3,4 % 1,3 % 4,5 % 3,2 % 5,5 % 2,3 ...
17:15:23 <Cale> It's possible that he really wants to `div` by 60 and (60*60) though, as it'll do something different when the number of hours goes above 24. TimeOfDay will put the excess seconds into the seconds place.
17:15:35 <Cale> ghci> timeToTimeOfDay 100000
17:15:35 <Cale> 23:59:13660
17:15:46 <lpvb> :O
17:16:05 <dmwit> That just seems wrong. =P
17:16:12 <rwbarton> for those days that never seem to end
17:16:19 <lpvb> haha
17:16:21 <Cale> Hey, there might be lots and lots of leap seconds
17:16:25 <Cale> ;)
17:17:10 <Cale> It's the right thing to do when you're dealing with leap seconds, anyway
17:17:33 <dmwit> > 24*60*60
17:17:34 <lambdabot>   86400
17:17:56 <dmwit> How did that number end in 60?
17:18:02 <dmwit> > 100000-86400
17:18:03 <lambdabot>   13600
17:18:10 <dmwit> oic
17:18:19 <dmwit> 00:00:00 is 23:59:60
17:18:23 <Cale> ghci> timeToTimeOfDay (24 * 60 * 60)
17:18:23 <Cale> 23:59:60
17:18:36 <dmwit> right
17:18:36 <startling> heh
17:18:58 <lpvb> > 5
17:19:00 <lambdabot>   5
17:19:02 <lpvb> > 10 - it
17:19:03 <Cale> (that's a valid time, and actually occurs sometimes)
17:19:03 <lambdabot>   Not in scope: `it'
17:19:40 <Cale> June 30, 2012 had a 23:59:60 UTC
17:20:54 <lpvb> google just says screw it and makes their seconds longer
17:22:28 <Dodek> leap seconds are serious business
17:22:52 <donri> is there a way to make `length "str"` work in ghci with OverloadedStrings?
17:23:07 <donri> without having to give the string a type sig
17:23:08 <dmwit> > length "str"
17:23:09 <lambdabot>   3
17:23:35 <dmwit> > length ('s':"tr")
17:23:36 <lambdabot>   3
17:23:44 <donri> No instance for (Data.String.IsString [a0])
17:23:47 <donri> with OverloadedStrings
17:23:53 <Axman6> o.O
17:24:00 <dmwit> donri: Did you try my second example?
17:24:02 <lpvb> I've been googling a lot for how inaccurate system time clocks are but I never get anything
17:24:05 <dmwit> Axman6: It's because the instance is for [Char].
17:24:16 <donri> dmwit: that's not really better than ("str"::String) :)
17:24:29 <dmwit> Not my fault you asked the wrong question. =)
17:24:33 * hackagebot c2hsc 0.3.3 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.3.3 (JohnWiegley)
17:24:44 <dmwit> donri: let strLen :: String -> Int; strLen = length
17:24:52 <Nereid> ^
17:25:05 <donri> dmwit: "length" was just an example
17:25:22 <Nereid> just specialize whatever function you want to use to String
17:25:48 <rwbarton> (... ":set -XNoOverloadedStrings")
17:26:16 <donri> rwbarton: well duh. thing is i have :set -XOverloadedStrings in ~/.ghci because it makes life easier when you're playing with such packages
17:26:21 <donri> but life harder when you just want a String
17:26:50 <rwbarton> with great power comes great responsibility
17:26:58 <rwbarton> (sorry i have nothing helpful to say)
17:26:58 <donri> :)
17:27:58 <rwbarton> you could define str :: String -> String, str = id, that might ease the syntax a bit
17:28:10 <donri> good one
17:28:40 <Nereid> cute.
17:31:31 <lpvb> > let fmtSecs s = printf "%02d hours, %02d minutes" (s `div` 3600) (s `div` 60 `mod` 60) in fmtSecs 100000
17:31:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:31:32 <lambdabot>    `GHC.Show.Show a'
17:31:32 <lambdabot>      a...
17:32:06 <lpvb> :t printf
17:32:07 <lambdabot> forall r. (PrintfType r) => String -> r
17:33:36 <lpvb> Monomorphism restriction?
17:34:13 <lpvb> oh nvm
17:34:15 <parcs`> :: String
17:35:21 <startling> is a type-safe printf possible with template haskell?
17:35:42 <startling> I'm thinking printf "%d %f" :: Integer -> Float -> String
17:35:56 <parcs`> donri: hmmm
17:36:31 <parcs`> donri: you know what, if the IsString String instance were changed to 'instance (a ~ Char) => IsString [a]' inference would work as expected
17:37:01 <ivanm> there is a typesafe printf on hackage
17:37:09 <lpvb> how do I escape a percent char '%' in a printf format string?
17:37:14 <rwbarton> %%
17:37:22 <startling> ivanm: o rly. neat
17:38:40 <lpvb> thanks, rwbarton
17:47:59 <donri> ivanm: which package?
17:48:12 <donri> parcs`: interesting. you think they'd change it though?
17:48:26 <ivanm> Printf-TH I think
17:48:43 <ivanm> there's also xformat
17:49:38 <donri> i wish there was a QQ with c#/python style formatting
17:49:52 <donri> i like interpolatedstring-perl6 but it only does interpolation
17:50:22 <startling> I like python's .format a lot
17:50:23 <t7> donri: whats that look like (c#/python) ?
17:51:19 <donri> t7: http://docs.python.org/library/string.html#format-string-syntax
17:51:46 <applicative> donri: it is a favorite oleg topic, http://okmij.org/ftp/typed-formatting/
17:52:55 <t7> python is yuck
17:52:58 <donri> something like interpolatedstring-perl6 plus text-format might be nice
17:58:45 <donri> printf "0x%06x" 255 -> [q|0x{left 6 '0' $ hex 255}|]
17:58:49 <marcot> @hoogle Text -> Int
17:58:50 <lambdabot> Data.Text length :: Text -> Int
17:58:50 <lambdabot> Data.Text.Foreign lengthWord16 :: Text -> Int
17:58:50 <lambdabot> Data.Text count :: Text -> Text -> Int
17:59:02 * applicative investigates whether oleg's printf might allow a perverted use of -XOverloadedStrings, seems not
17:59:33 * hackagebot rehoo 0.1.2 - Rebuild default.hoo from many .hoo files in the current directory  http://hackage.haskell.org/package/rehoo-0.1.2 (JohnWiegley)
18:00:08 <donri> or maybe, [q|0x{left 6 '0' . hex}|] 255
18:03:11 <hpaste> jello pasted “there has to be a better way” at http://hpaste.org/74371
18:03:55 <Jello_Raptor> and hpaste gives me the answer i was looking for :p
18:04:02 <donri> Jello_Raptor: also "and"
18:04:03 <dibblego> and = all (\x → x)
18:04:15 <Jello_Raptor> ahh
18:04:26 <Jello_Raptor> and is = (\x -> x)?
18:04:30 <dibblego> isSubSequence a = and . zipWith isSubBase a
18:04:37 <dibblego> s/is/id yes
18:04:50 <ddarius> applicative: That's because it has a particularly nice solution using delimited continuations, though you'll need to read Kenichi Asai's paper for that.
18:05:06 <Jello_Raptor> dibblego: thanks :)
18:05:14 <dibblego> np
18:06:08 <applicative> ddarius: you mean the problem has a better solution
18:08:38 <johnw> @src and
18:08:38 <lambdabot> and   =  foldr (&&) True
18:08:44 <johnw> @src all
18:08:44 <lambdabot> all p =  and . map p
18:09:05 <johnw> and = all id
18:11:41 <alFReD-NSH> hi, I'm new to Haskell and looking for a good unit testing framework
18:11:51 <ddarius> @google haskell unit testing framework
18:11:52 <lambdabot> http://hunit.sourceforge.net/
18:11:53 <lambdabot> Title: HUnit -- Haskell Unit Testing
18:11:56 <lpvb> > fromIntegral 5 / 3.0
18:11:57 <lambdabot>   1.6666666666666667
18:12:03 <alFReD-NSH> anyone can help?
18:12:08 <donri> alFReD-NSH: http://batterseapower.github.com/test-framework/
18:12:26 <donri> you'll want hunit for actual tests, but test-framework is a nice wrapper/runner
18:12:54 <alFReD-NSH> I know how to google, just looking for community accepted one
18:14:20 <donri> also http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
18:14:35 <donri> (ignore "detailed"
18:14:37 <donri> )
18:14:42 <johnw> HUnit really needs more examples
18:14:58 <johnw> the ones the documentation shows aren't even fully explained
18:15:20 <ddarius> Sounds like it needs more explanation rather than more examples.
18:16:26 <alFReD-NSH> johnw: comparing to the JavaScript, where I come from, moatly everything in Haskell that I saw need more examples
18:16:27 <johnw> or both :)
18:16:58 <johnw> yeah, some libraries are a good exception, like pipes or parsec
18:17:19 <johnw> i want a really good guide to lens about now
18:17:42 <dibblego> johnw: this is a great guide http://hackage.haskell.org/package/lens
18:17:56 <johnw> in what way??
18:18:07 <johnw> it's these haddock docs which have me feeling so confused
18:18:29 <ddarius> Documentation: Beyond Thankless
18:18:33 <johnw> those huge blue boxes are *not* helpful
18:18:46 <johnw> ah, there's this: https://github.com/ekmett/lens/wiki/Tutorial
18:21:32 <Lutin`> johnw: I find that links on hackage pages often have as much if not more information.
18:21:36 <startling> that tutorial could be a bit better
18:21:46 <Clint> there's more info on one of the github pages
18:22:19 <ddarius> startling: Thanks for driving my point home.
18:22:32 <startling> the lens one, I mean
18:24:07 <Lutin`> https://github.com/ekmett/lens/wiki/Derivation
18:24:12 <Lutin`> If you really want to learn it
18:24:14 <Lutin`> derive it
18:24:50 <Lutin`> imo you truly grasp something once you can derive it solely from axioms
18:25:05 <Lutin`> imho
18:25:14 <startling> no, I know
18:25:23 <startling> but I still don't know what lenses are in the package, for example
18:25:46 <applicative> startling: in the lens package?
18:26:07 <johnw> Lutin`: thus far, that approach to learning has had the opposite effect for me
18:26:15 <applicative> startling they are in the various modules Data.Lens.List  Data.Lens.Tuple etc.
18:26:20 <Lutin`> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Type.hs
18:26:43 <johnw> I want to see compelling real-world examples, that then walk me down to fundamentals; rather than a set of laws and exercise asking me to derive the library from them, before I even know what it's good for
18:27:22 <dmwit> johnw: here:
18:27:32 <dmwit> http://twanvl.nl/blog/haskell/overloading-functional-references
18:27:40 <applicative> johnw: there is `nand s game in the examples folder
18:27:50 <startling> applicative: yes, I know
18:27:57 <startling> applicative: but it'd be the kind of thing you'd want in a tutorial
18:28:12 <startling> johnw: yeah, exactly
18:28:59 <applicative> startling: part of the trouble is that the use that will be most compelling is where you derive or write such lenses for some gruesome record type you are using to represent state
18:30:00 <cmears> I just got GHC 7.6.1, which comes with Cabal-1.16.0 -- what is the right version of cabal-install to go with it?
18:30:04 <lpvb> what's the best way to catch an IO exception in an IO monad where 'a <- potentialFailure'?
18:30:28 <Clint> depends how you want to handle it?
18:30:45 <parcs`> :t try
18:30:46 <lambdabot> Not in scope: `try'
18:30:48 <Lutin`> johnw: Yeah I understand
18:30:50 <applicative> cmears,  do you already have a cabal executable
18:30:57 <lpvb> I want to return a String containing a descriptive message
18:30:58 <lpvb> IO String
18:31:15 <Clint> what does potentialFailure return?
18:31:24 <parcs`> donri: not sure. it would overlap with other instances of the form [T]
18:31:29 <lpvb> IO L.ByteString
18:31:35 <Clint> perhaps you want an Either
18:31:45 <lpvb> the block itself returns IO String
18:31:55 <donri> parcs`: ah yea. not sure how common outside [Char], but yea.
18:31:57 <cmears> applicative: Yes, version 0.14.0 (with Cabal-1.14.0)
18:32:08 <applicative> cmears: I haven't had difficulty using my  existing cabal install with ghc-7.6 and the previous bits of ghc-head
18:32:47 <cmears> applicative: Thanks, it does seem to work OK
18:32:59 <applicative> cmears: Cabal is the library , the executable compiled with Cabal-1.14 is happy to call ghc-7.6
18:33:26 <Clint> lpvb: ah, then you can use Control.Exception.Base.catch
18:34:42 <lpvb> Clint: how would I do that?
18:34:52 <cmears> applicative: Yeah, cabal is working -- just not the packages that don't want to compile any more (:
18:34:58 <lpvb> put the catch before the 'do'?
18:35:26 <applicative> cmears: hm, what packages?
18:35:50 <applicative> cmears ghc-7.6 will break half of hackage
18:36:14 <cmears> What's changed to break so much?
18:37:11 <applicative> cmears for one thing the new rules for TypeOperators, I guess the new constraints on Num were already in 7.4
18:38:04 <YayMe> Anyone have tips for a hands-on learner to study up on algorithm design and analysis?
18:38:17 <YayMe> Just start writing some? heh that's my best guess
18:38:42 <nand`> johnw: lenses are good for composing accessors and mutators (also folds, traversals, isomorphisms etc.)
18:38:57 <SLi> What does the syntax "let f !a = a in ..." mean *without* the BangPatterns extension? For example, ghci happily accepts "let f !a = a", but does not bind anything to f.
18:39:08 <YayMe> Learn you a haskell was a great hands on intro into haskell, but I'm guessing there's nothing like that for algorithms since there's no real beginning level there
18:39:13 <SLi> So... What happens, why no error message :)
18:39:26 <nand`> johnw: think records, and how painful it is to modify a record within a record, especially point-free
18:39:47 <SLi> Ah, or does it define the operator (!)?
18:39:56 <johnw> nand`: I actually grok lens just fine.  My problem is that now that I understand the basics, it does nothing to help me become familiar with all that the package has to offer
18:40:18 <nand`> ah
18:40:20 <johnw> the quantity of operators is simply overwhelming, without examples, without rationale.  It's like I'm supposed to wake up one day and just *know* hat to do
18:40:30 <edwardk> johnw: thats my fault. i really need to put together more of a tutorial on the depths of it
18:40:31 <SLi> Yes, that's what it does.
18:40:36 <nand`> the most confusing thing imo is the plentiful overloading with typeclasses etc.
18:40:41 <Clint> lpvb: are you just taking the value from potentialFailure and converting it to a String?
18:40:51 <johnw> edwardk: I think your library is being utilized at 1% of its total power right now
18:41:01 <edwardk> johnw: probably true
18:41:03 <johnw> it could be as compelling a thing as monads, in my opinion
18:41:18 <edwardk> roconnor seems to echo that opinion
18:41:21 <nand`> one thing I've never studied is the platet stuff, mainly because I have no idea what uniplates etc. are
18:41:21 <applicative> johnw: hasn't it only been around for a couple weeks?
18:41:24 <nand`> plated*
18:41:27 <dysinger> anyone else get "Warning: Couldn't figure out LLVM version!" on 7.6.1 on Mtn Lion ?
18:41:29 <johnw> it really solves the problem of "get this out of that", and "put this in that" in a truly composable way
18:41:48 <edwardk> nand`: a plate is a recursion scheme for finding copies of yourself inside yourself. =)
18:42:00 <lpvb> Clint: No, I'm doing some JSON parsing from the bytestring and turning it into a string
18:42:02 <edwardk> e.g. find the children expressions of the current expression
18:42:36 <johnw> a lens pick out nodes from a tree, and a uniplate pickes out subtrees from a tree, right?
18:42:44 <johnw> damn, picks
18:42:48 <edwardk> johnw: yep
18:42:54 <johnw> and biplates...?
18:42:58 <edwardk> its a traversal of self-similar children
18:43:07 <edwardk> biplates find potentially other types in a type
18:43:10 <johnw> then uniplates are related to comonads?
18:43:28 <edwardk> johnw: not sure i follow.
18:43:33 <edwardk> oh the perspective thing?
18:43:42 <johnw> the Comonad.extend is a traversal of self-similar chlidren
18:43:48 <johnw> where each step of the traversal returns a node value
18:44:08 <johnw> is a biplate a self-similar traversal that returns self-similar results?
18:44:13 <edwardk> i can see the leap you're making but i think you're bolting it on sideways
18:44:22 <edwardk> so lets make a binary tree and a uniplate
18:44:24 <applicative> dysinger: did ghc-7.4 -fllvm work?
18:44:32 <edwardk> data Tree a = Bin (Tree a) (Tree a) | Tip a
18:44:33 <Clint> lpvb: if potentialFailure is the only IO action, you could do something like catch (do a <- potentialFailure; let b = doStuffToA a; return b) (\_ -> return "Some kind of error occurred")
18:44:42 <edwardk> now we can make a uniplate for (Tree a)
18:45:28 <edwardk> instance Plated (Tree a) where plate f (Bin l r) = Bin <$> f l <*> f r; plate _ (Tip a) = pure $ Tip a
18:45:28 <startling> edwardk: youre alive!
18:45:43 <johnw> startling: I said the word lens often enough
18:45:44 <dysinger> applicative: yeah I can compile ghc-7.4.x with no special flags on Mtn Lion.
18:45:44 <SLi> Heap profiling haskell programs seems still a bit mysterious. As in, I think I understand it in theory, but what always seems to happen is that I scratch my head looking at the data, add `seq`s and `deepseq`s to different places and usually only make the program take more space, then at some point understand what the problem is, refactor the code and get much nicer behavior. Then a week later I look at it again, try removing all the sequentiality and ...
18:45:49 <startling> johnw: aha
18:45:50 <edwardk> 'plate' finds subtrees
18:45:51 <SLi> ... the program becomes much faster and less memory-intensive.
18:45:59 <johnw> applicative: yes, that works here too (10.7.4)
18:46:00 <dysinger> applicative: I have 7.4.2 currently
18:46:20 <edwardk> now, in the uniplate package, 'biplate' would find other types in a container. e.g. you can have Biplate (Tree a) (Tree a)   and Biplate (Tree a) a
18:46:32 <lpvb> Clint: Okay, I did "handle handlerFunction $ do IO stuff" instead.. is that acceptable?
18:46:49 <lpvb> does the IOException propagate to the end of the do block?
18:47:01 <johnw> Plated is just how I'd write fmap for Tree, except that plate doesn't return Tip (f a)
18:47:05 <edwardk> (now you can also see the overlap between Tree a  and a, which makes that instance hard
18:47:08 <applicative> my 7.6 is working find but I still have the previous os x.  it's using the llc from homebrew.
18:47:15 <edwardk> johnw: its very close to traverse for Tree a
18:47:44 <edwardk> instance Traversable Tree where traverse f (Bin l r) = Bin <$> traverse f l <*> traverse f r; traverse f (Pure a) = Pure <$> f a
18:47:45 <johnw> oh, and fmap wouldn't be f l, f r
18:47:49 <edwardk> yep
18:47:52 <Clint> lpvb: think of it as aborting the do block as soon as it fails
18:48:06 <johnw> it'd be plate f l
18:48:25 <johnw> your tree doesn't have values in anything but leaves?
18:48:34 <edwardk> so plate :: Plated t => Simple Traversal t t
18:48:50 <edwardk> correct, though you could define it with values in nodes as well
18:49:45 <applicative> dysinger: does e.g. llc -version  show that lcc is around?
18:50:02 <Lutin`> edwardk: What order should I read your source files in
18:50:05 <Lutin`> for lens
18:50:09 <johnw> how would extend diff for your Tree?  It would need to call (Tip (f a)) right, but everything else would be the same?
18:50:25 <edwardk> Lutin`: hrmm, start with the wiki honestly
18:50:48 <edwardk> if you put values in the nodes, you wind up with a Cofree comonad
18:50:56 <parcs`> donri: http://hackage.haskell.org/trac/ghc/ticket/1974
18:51:21 <nejucomo> I want Just the minimum value of a list with 1 or more Ord elements or Nothing otherwise...
18:51:29 <ddarius> Clearly one should topologically sort the call graph and read in that order.
18:51:41 <nejucomo> I was reading over Data.Foldable, but I haven't figured it out yet.  Any advice?
18:51:42 <johnw> edwardk: sadly, I don't know Cofree yet
18:51:47 <startling> so I've got a newtype Tree k a = Tree Map k (Either a (Tree k a)). what would be the best way to extract leaves or branches with a lens?
18:51:57 <ddarius> nejucomo: Foldable = toList.  That is -all- there is to it.
18:51:59 <donri> parcs`: thanks
18:52:49 <dysinger> applicative: no I don't have a lcc.
18:52:49 <edwardk> startling: inserting and deleting from nested maps is still hard with lenses
18:53:06 <startling> edwardk: alright. I wasn't seeing it, thanks for confirmation
18:53:27 <johnw> nejucomo: Data.Foldable is a generalized way of folding over anything that has an instance for Foldable
18:53:28 <dysinger> applicative: gcc reports i386-apple-darwin-11-llvm-gcc-4.2 though
18:53:37 <dysinger> i686 rather
18:53:39 <johnw> basically it gives a type class to the notion of folding
18:53:47 <applicative> dysinger: it should be okay unless you use -fllvm
18:53:48 <johnw> while Prelude.foldl only works on lists
18:53:53 <edwardk> startling: the problem is nested maps are hard because you need to decide what happens with the empty trees when you delete the last key in them, etc.
18:54:06 <edwardk> afk a bit
18:54:10 <startling> edwardk: oh. that's easy for me
18:54:12 <nejucomo> I understand that.  What I want is:  (a -> a -> b) -> [a] -> Maybe b
18:54:15 <startling> empty branches stick around
18:54:28 <edwardk> startling: sure. but thats not something i can make combinators that assume uniformly ;)
18:54:29 <applicative> dysinger: if you want to use llvm you cant use the apple machinery, it doesn't give you llc unfortunately, so you have to 'brew install llvm' unfortunately
18:54:37 <edwardk> thats something you can write though
18:54:41 <applicative> dysinger: or the equivalent for  macports or whatever
18:54:46 <dysinger> ack
18:54:50 <startling> edwardk: understood. any idea where I should get started?
18:55:05 <ddarius> Everything in Data.Foldable is trivially implementable in terms of toList.  Data.Foldable is just a class for things that can be turned into lists.
18:56:35 <edwardk> startling: well, there is always the 'at' lens you can use in whatever combinators you write
18:56:51 <johnw> nejucomo: I don't understand the first function argument
18:57:05 <johnw> nejucomo: for [1,2,3,4], you want your function called with 1 2?
18:57:25 <startling> edwardk: hmmm, I don't know that I can
18:57:43 <startling> edwardk: since looking up from my Tree k a gets you an Either a (Tree k a)
18:58:07 <Lutin`> Is there a way to type a finite list?
18:58:22 <startling> oh, you mean just using `at` for the internal map
18:58:28 <edwardk> startling: yes
18:58:33 <nejucomo> I think I want something like...
18:58:35 <johnw> Lutin`: I think in 7.6 you can :)
18:58:38 <nejucomo> I think I just want: foldl (liftM2 min) Nothing . map Just
18:58:42 <edwardk> just saying you can compose whatever you need using that at least as a building block
18:58:54 <johnw> :t foldl (liftM2 min) Nothing . map Just
18:58:55 <lambdabot> forall a1. (Ord a1) => [a1] -> Maybe a1
18:58:57 <applicative> Lutin`: you mean you want a type FiniteList with only finite members?
18:59:11 <nejucomo> Except I never remember if I want foldl, foldl', or foldr.  :-/
18:59:25 <johnw> :t (\f -> foldl (liftM2 f) Nothing . map Just)
18:59:27 <lambdabot> forall a2 r. (r -> a2 -> r) -> [a2] -> Maybe r
18:59:32 <johnw> yeah, there you go
19:00:16 <johnw> note that using Maybe like this feels like you want the Any or All Monoid
19:00:23 <applicative> nejucomo: dumb rule of thumb: you want foldl' if the operation is very strict like +  * and so on ; otherwise foldr; never foldl
19:00:35 <nejucomo> Nope.  It has the right type, but the result is always Nothing because of the liftM2.
19:01:03 <nejucomo> applicative: Thanks, I'll remember that.
19:01:14 <nejucomo> johnw: Thanks, I'll look that up.
19:02:51 <shapr> oi #haskell! como vai?
19:02:59 <nand`> where can I find examples of code that uses datakinds? specifically, I'm curious about [*]
19:03:49 <johnw> nejucomo: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids
19:03:51 <johnw> search for "getAny"
19:04:47 <nejucomo> This is exactly what I want, but seems klunky: (\f xs -> if length xs > 0 then Just (foldl1 f xs) else Nothing)
19:05:36 <nand`> in such cases it's always better to do pattern matching
19:05:37 <nejucomo> :t (\f xs -> if length xs > 0 then Just (foldl1 f xs) else Nothing)
19:05:38 <lambdabot> forall a. (a -> a -> a) -> [a] -> Maybe a
19:05:44 <nand`> case xs of [] -> Nothing; (x:xs) -> foldl f x xs
19:05:50 <nand`> add a Just
19:05:52 <donri> huh, 7.6 butchered type operators? :(
19:05:54 <applicative> nand`: there's a bunch of stupid examples in the ghc test directories
19:06:06 <nejucomo> nand`: Thanks.
19:06:38 <nejucomo> I still suspect there's a more concise way to write this.
19:06:43 <nejucomo> -but that's good enough for now.
19:06:58 <dibblego> nejucomo: perhaps you want to look at Data.Foldable1 and Data.Traversable1
19:07:27 <DT`> nejucomo, let uncons f [] = Nothing; uncons f (x:xs) = f x xs in uncons (foldr f) xs?
19:07:43 <applicative> nand`: they are mostly boring but some helpful, I thought https://github.com/ghc/testsuite/tree/master/tests/polykinds
19:07:47 <DT`> *uncons f (x:xs) = Just (f x xs), sorry
19:07:56 <nand`> applicative: thanks
19:08:57 <`Jake`> > ((++)<*>show)"((++)<*>show)"
19:08:59 <lambdabot>   "((++)<*>show)\"((++)<*>show)\""
19:10:58 <ion> nice
19:11:00 <ddarius> `Jake`: It's much more compact with ap.
19:11:35 <`Jake`> how does that look?
19:11:56 <`Jake`> ddarius
19:11:58 <nand`> > ap(++)show"ap(++)show"
19:12:00 <lambdabot>   "ap(++)show\"ap(++)show\""
19:12:02 <`Jake`> ok
19:12:05 <`Jake`> thanks
19:12:12 <DT`> nice.
19:12:37 <`Jake`> you'd have to import Control.Monad in a real program, right?
19:14:05 <ddarius> @hoogle ap
19:14:05 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
19:14:05 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
19:14:05 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
19:14:19 <nand`> don't forget Control.Monad.Instances for the ((->) r)
19:15:16 <ddarius> Last I checked though, (<*>) wasn't in the Prelude either.
19:15:23 <`Jake`> true
19:16:37 <applicative> >  text$ap(++)(show)"text$ap(++)show"
19:16:39 <lambdabot>   text$ap(++)show"text$ap(++)show"
19:16:59 <`Jake`> I'm actually trying to write a program which writes random programs and checkes if it prints out itself, and I'm just trying to find out which resources I need to provide
19:17:52 <jfischoff> ^ http://en.wikipedia.org/wiki/Quine_(computing)
19:25:43 <nejucomo> This new-to-me technique of passing in type parameters where I used to use enums is panning out nicely.
19:26:06 <ion> Passing in type parameters?
19:26:33 <ion> As in higher-order types?
19:28:06 <nejucomo> ion: After realizing phantom types were possible, I also realized I could do something similar when I want structurally identical types, but I want to keep them separate in the type system.
19:28:33 <nejucomo> What I'm doing isn't phantom types per se, and I'm not sure if there's a name for it.
19:29:03 <nejucomo> For example, instead of: data Currency = Currency Decimal Denomination -- and then: data Denomination = USD | EUR
19:29:34 <nejucomo> -I'm doing: data Currency denom = Currency Decimal denom -- and then: data USD = USD ; data EUR = EUR.
19:29:47 <startling> oh, that's interesting
19:30:02 <nejucomo> This way I can specify that some places only handle one type of currency, in other places I can handle Currency generally.
19:30:13 <nejucomo> It seems slightly weird though.
19:30:16 <startling> yeah. very cool
19:30:48 <Twisol> Basically carrying a unit along with a value?
19:30:59 <nejucomo> So now I have all these "single valued types" everywhere (which all become instances of Default so you can do things like ask for a denomination "value" for log representations)...
19:31:04 <nejucomo> Right.
19:31:09 <ddarius> nejucomo: That's exactly phantom typse.
19:31:18 <Twisol> ^
19:31:50 <nejucomo> I was hunting for a general "unit" system that would allow you to say multiple 3 USD * 1 Week but only add USD to USD...
19:32:04 <nejucomo> There's one library someone here mentioned that does that for a fixed set of 6 physical dimensions.
19:32:20 <dmwit> It's kind of a hard problem.
19:32:28 <nejucomo> ddarius: Ah, from this wiki: https://en.wikibooks.org/wiki/Haskell/GADT#Phantom_types - I thought phantom types never have runtime values.
19:33:02 <nejucomo> dmwit: Yeah...  I've been pondering if it's possible in haskell on and off for a couple of weeks, but my type system knowledge is still...  basic to intermediate.
19:33:27 <ddarius> nejucomo: Oh sorry, I didn't read your type closely enough, but it is certainly in the same spirit.
19:33:35 <nand`> would something like this work? data Denom = USD | EUR; data Currency (denom :: Denom) = Currency Decimal denom ?
19:33:56 <DT`> nejucomo, the (new) DataKind extensio-nand` was faster than me.
19:33:58 <dmwit> I would say that this is more in the spirit of singleton types than phantom types.
19:34:02 <applicative> nand`: thats what I was thinking
19:34:17 <applicative> no scrap the second use of denom on the rhs
19:34:27 <nejucomo> dmwit: Yes, because I use the values sometimes.
19:34:36 <nejucomo> Actually so far I only use the values for Show.
19:35:06 <nejucomo> nand`: I'm unfamiliar with that syntax...  but I suspect it's not what I want.
19:35:08 <nand`> applicative: oh, yes
19:35:37 <nejucomo> -unless that means: "Currency takes a type parameter called Denom which *must be* only one of the types in this set: ..."
19:35:53 <DT`> nejucomo, it means exactly that.
19:36:01 <nejucomo> Weird.
19:36:01 <nand`> Currency takes a type parameter called denom which must be one of the lifted ‘data USD, data EUR ...’
19:36:18 <nejucomo> So what is the type for USD versus EUR?
19:36:37 <dmwit> USD is a type with kind Denom in nand`'s code
19:36:38 <nand`> fiveEuro :: Currency EUR
19:36:40 <DT`> USD is of kind Denom here.
19:36:46 <dmwit> It needs a relatively modern GHC.
19:36:51 <nand`> 7.4 should work
19:37:00 <nejucomo> Wait a minute... did that introduce a kind?
19:37:04 <nand`> yeah
19:37:06 <Twisol> Is this in relation to that presentation on a new kind system someone linked recently?
19:37:12 <nejucomo> Woah.  Where can I read about this?
19:37:25 <nand`> with DataKinds there are more kinds than *
19:37:41 <nand`> (and * -> * etc.)
19:37:42 <nejucomo> It seems odd to me that it uses "data" to declare.  To me it looks exactly like Denom is a type with two values.
19:37:55 <nejucomo> Is that still true?
19:37:56 <dysinger> applicative: homebrew llvm fixed my problems although I'm curious as to why that's needed since apple has switch to llvm across the board in mountain lion AFAIK
19:38:06 <DT`> next: kind-level programming, kind of kind polymorphism, -XDataKindsKinds.
19:38:06 <dmwit> nejucomo: http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
19:38:09 <nand`> nejucomo: it *is*; but with DataKinds it gets automatically lifted to a kind as well
19:38:10 <nejucomo> If not, I would hope for something like "kind Denom = USD | EUR".
19:38:12 <gwern> @quote
19:38:13 <lambdabot> Wikipedia says: In topology, the long line (or Alexandroff line) is a topological space analogous to the real line, but much longer.
19:38:19 <nand`> DT`: next: sort polymorphism
19:38:21 <nejucomo> huh.  Ok.
19:38:24 <nand`> (the level above kinds)
19:38:27 * nejucomo loads up the pdf.
19:38:28 <startling> nand`: neat
19:38:35 <DT`> are they really called sort?
19:38:49 <nand`> afaik yes
19:38:53 <nand`> GHC 7.6 only has one sort, BOX
19:39:03 <nand`> not even BOX -> BOX or anything, just BOX
19:39:07 <Twisol> How deep does the rabbit hole go? :/
19:39:14 <DT`> Twisol, infinitely.
19:39:15 <nand`> in Agda, as far as you want
19:39:24 <Twisol> How is that useful? :(
19:39:30 <DT`> Twisol, infinitely.
19:39:36 <nand`> (but Agda has a different type system)
19:39:45 <DT`> infinitely useful, that is.
19:40:32 <startling> is there a nice type synonym I can use for lenses?
19:40:37 <startling> from `lens`
19:40:59 <nand`> there are lots of type synonyms in lens
19:41:10 <latro`a> lots of names for id, too
19:41:14 <nand`> what's the type you're trying to prettify?
19:43:00 <Twisol> Is it a bad idea to use GADTSyntax if I'm not defining a GADT?
19:43:00 <startling> node :: (Functor f, Ord k) => k -> (Maybe (Either a (Tree k a)) -> f (Maybe (Either a (Tree k a)))) -> Tree k a -> f (Tree k a)
19:43:30 <latro`a> interesting type...
19:45:07 <applicative> Twisol: well it's not portable, otherwise why would it be?
19:45:26 <applicative> Twisol: I mean otherwise why would it be bad?
19:45:42 <Twisol> *shrug* That's why I'm asking. I don't know enough about the Haskell conceptual landscape to know if I'm wandering into a minefield.
19:46:15 <nand`> startling: Ord k => k -> Simple Lens (Tree k a) (Maybe (Either a (Tree k a))
19:46:42 <DT`> Twisol, Haskell is monopolized by GHC anyway, and IMO the syntax is nicer.
19:46:57 <startling> nand`: oh, very nice
19:47:12 <nand`> the Maybe seems a bit odd to me, though I don't know what the lens is doing
19:47:46 <startling> nand`: it's looking up from a nested map
19:49:36 * hackagebot haskeline 0.7.0.3 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.7.0.3 (JudahJacobson)
19:56:27 <startling> So I've got a lens into a structure; viewing the lens gets you a Monoid. can I create a structure from mappending the result of the lens on two of these structures?
19:56:31 <startling> wow, that was a mouthful
19:57:38 <nand`> mappend `on` view l -- ?
19:58:59 <latro`a> isn't it the other order
19:59:00 <latro`a> :t on
19:59:01 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:59:04 <latro`a> nvm
20:01:50 <gwern> @quote mappend
20:01:50 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
20:02:08 <gwern> hm. I don't get it.
20:02:39 <jfischoff> @quote mappend
20:02:40 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
20:03:00 <startling> @pl m a b = Tree ((mappend `on` _see) a b)
20:03:00 <lambdabot> (line 1, column 7):
20:03:00 <lambdabot> unexpected "="
20:03:00 <lambdabot> expecting variable, "(", operator or end of input
20:03:14 <startling> @pl \a b -> Tree ((mappend `on` _see) a b)
20:03:14 <lambdabot> (line 1, column 29):
20:03:15 <lambdabot> unexpected "_"
20:03:15 <lambdabot> expecting space or simple term
20:03:22 <startling> @pl \a b -> Tree ((mappend `on` see) a b)
20:03:23 <lambdabot> (Tree .) . (mappend `on` see)
20:03:38 <startling> weird, @pl doesn't accept underscores?
20:03:43 <nand`> Tree .: (mappend `on` see)
20:04:09 <startling> @hoogle (.:)
20:04:10 <lambdabot> No results found
20:04:14 <startling> where do I get it?
20:04:23 <nand`> (.:) = (.).(.)
20:04:42 <nand`> it's in Data.Function.Pointless for example
20:05:20 <startling> neat
20:07:13 <startling> :t (.).(.)
20:07:14 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:07:23 <startling> huh
20:10:18 <mm_freak> :t (Prelude..) Prelude.. (Prelude..)
20:10:19 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:12:10 <startling> oh heh
20:24:30 <nejucomo> Some more new-to-me syntax/semantics: type family ... \n type instance ...
20:24:36 * nejucomo searches haskell wiki.
20:27:34 <rwbarton> has anyone here used the yaml package? it seems to have odd ideas about formatting numbers, which python's yaml library disagrees with
20:27:43 * ddarius actually finds it easier to see what is happening with the Functor version.
20:30:48 * ddarius thinks mathematics is trying to tell him that, if you don't know the signal-to-noise ratio at all, you can't differentiate between noisy signal and noisy lack of signal.
20:32:58 <ddarius> Actually, I'm integrating the wrong expression.
20:33:14 <johnw> isn't (.).(.) == fmap fmap fmap?
20:33:17 <johnw> :t fmap fmap fmap
20:33:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:33:26 <johnw> which in turn is
20:33:29 <johnw> :t fmap . fmap
20:33:29 <shachaf> rwbarton: YamlReference isn't useful for actually using YAML, but it's probably the most compliant. :-)
20:33:29 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:34:05 <djahandarie> (.).(.) = (.) (.) (.) = fmap (.) (.) ~= fmap fmap fmap
20:35:09 <ddarius> Wolfram|Alpha doesns't understand "more".
20:35:10 <djahandarie> The ~= due to the type being different, but still acting equivalently if you use the Functor instance for (->).
20:35:35 <johnw> ah, gotcha
20:35:45 <johnw> @unpl fmap fmap fmap
20:35:45 <lambdabot> fmap fmap fmap
20:35:51 <johnw> @unpl fmap fmap fmap f
20:35:51 <lambdabot> fmap fmap fmap f
20:36:37 <johnw> so, I guess you can use .: then to map over two IO (Maybe Int) values
20:36:53 <johnw> not really sure when else I'd use it
20:37:02 <rwbarton> shachaf: oh, huh. let me try it out
20:39:04 <rwbarton> though my casual reading of the yaml spec seems to indicate that yaml has no concept of the difference between integers and strings, unless you use explicit type tags
20:39:05 <ddarius> :t nonNegative
20:39:06 <lambdabot> Not in scope: `nonNegative'
20:39:29 <rwbarton> or rather, the assignment of types to scalars "depends on the application"
20:42:53 <johnw> darn, edwardk is gone
20:43:30 <ddarius> Yes, I need to ask him why my error estimates rise.
20:44:55 <johnw> equeleto sounds nice
20:45:03 <johnw> i'm wondering if his ^. operator is related to lens at all
20:49:09 <ddarius> > exp(-50)
20:49:10 <lambdabot>   1.9287498479639178e-22
20:49:37 * hackagebot logict 0.5.0.2 - A backtracking logic-programming monad.  http://hackage.haskell.org/package/logict-0.5.0.2 (DanDoel)
20:50:20 <mgsloan> johnw: it is related to lens, in that it applies to getters
20:51:02 <mgsloan> It's the same thing as "view", and trivially runs the lens
20:51:35 <mgsloan> (well, "view" flipped)
20:52:51 <johnw> mgsloan: did you write it?
20:53:26 <mgsloan> so, for example, _2, which is a lens on any arity tuple >= 2, will let you access a tuple like ('a', 'b') ^. _2, and get out 'b'
20:53:45 <johnw> mgsloan: I meant ^. as used in esqueleto
20:54:11 <mgsloan> ohh
20:54:26 <mgsloan> yeah, nah, I've just been working on some of lens' TH stuff
20:54:34 <johnw> ah, ok
20:55:05 <mgsloan> got introduced to the library in person by ekmett while at hac-phi
20:55:11 <johnw> nice
20:55:12 <mgsloan> it's pretty epic
20:55:16 <johnw> it really is
20:55:37 <johnw> and the fact that no new syntax was required speaks reams for PF/Haskell
20:57:29 <mgsloan> yup, and that it uses function composition from the prelude, and that looks just like traditional nested field dereference (well, if you ignore the ^ in the initial  (^.))
20:57:43 <johnw> does it use composition from Control.Category?
20:57:46 <johnw> s/does/doesn't
20:57:59 <mgsloan> it does for isomorphisms
20:58:03 <mgsloan> but otherwise, no
20:58:17 <mgsloan> other lens libraries needed to use Control.Category
20:58:35 <johnw> let's first kill the other lens libraries then
20:59:15 <mgsloan> and none of them had proper composition of isomorphisms / lenses / traversals / folds / etc
21:00:39 <mgsloan> it's a fairly clever observation that might lead to cool stuff elsewhere - if you can formulate a set of things that should combine in lattice-like ways - then have type synonyms that introduce class constraints
21:01:22 <mgsloan> s/formulate a set of things/formulate a set of things as type synonyms
21:01:23 <scri> i really want to have haskell-mode show types in inf-haskell
21:01:36 <johnw> scri: I've fixed that
21:01:41 <johnw> github.com/jwiegley/haskell-config
21:01:58 <johnw> it shows type kinds in the minibuffer
21:03:47 <scri> baller! ok, which is the relevant function?
21:04:35 <johnw> let me check
21:04:38 * hackagebot egison 2.4.4 - An Interpreter and Compiler for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.4.4 (SatoshiEgi)
21:04:59 <johnw> oh, snap
21:05:04 <johnw> i bet i pushed it upstream
21:05:08 <johnw> have you updated haskell-mode recently?
21:05:30 <johnw> see d1dd80c
21:05:46 <johnw> although that doesn't tie it into the eldoc output
21:05:48 <johnw> searching...
21:06:13 <scri> i'm using elpa now, not sure if that updates automatically...
21:06:34 <johnw> do you have the function `inferior-haskell-kind'?
21:06:48 <johnw> ok, yeah, this is all upstream now
21:07:04 <johnw> `haskell-doc-sym-doc' tries shows the kind if it can't determine the type
21:07:22 <johnw> so for value constructors of the same name, you'll only get the function type
21:07:36 <scri> yes, ok i've got it
21:07:48 <johnw> we'd need to improve ghc-mod to distinguish namespaces
21:08:17 <scri> i'd like to have the timer showing types as in haskell-mode, though
21:08:33 <scri> i can probably put that together
21:08:40 <johnw> i don',t understan,d that's exactly what I have here
21:08:57 <johnw> put these on your haskell-mode-hook:
21:08:58 <johnw> turn-on-eldoc-mode turn-on-haskell-doc-mode
21:09:09 <johnw> you may only need the latter
21:09:32 <johnw> no, you need them both
21:09:45 <scri> ah ok, i thought i had them on but
21:12:03 <scri> ok weird, it's only showing the eldoc for an instant
21:12:50 <scri> they seem to be conflicting
21:13:03 <johnw> haskell-doc hooks into eldoc
21:14:54 <scri> well thanks, i will sort it out
21:16:38 <pharaun> @pl foo x = bar x $ yaz x
21:16:39 <lambdabot> foo = ap bar yaz
21:17:10 <johnw> @src ap
21:17:10 <lambdabot> ap = liftM2 id
21:17:24 <johnw> foo = bar <*> yaz
21:17:45 <johnw> if it's applicative
21:17:52 <pharaun> hmm that seems to read better
21:18:07 <johnw> well, bar `ap` yaz isn't that bad either
21:18:25 <pharaun> yeah, i already have all of the applicative stuff in this file anyway, might as well use it
21:18:32 <johnw> oh, then by all means!
21:18:35 <johnw> i love applicative
21:18:40 <johnw> i've started using it everywhere now
21:18:58 <startling> applicative is great
21:19:02 <pharaun> heh yeah i'm still trying to pick up on it, i like it so far with parsing but in other context i sometime trip up with it
21:19:17 <startling> <$> is great as well
21:19:26 <startling> I remember doing "x >>= return . y" tons
21:19:31 <pharaun> makes my parsing code so clean :)
21:20:32 <johnw> :t x >>= return . y
21:20:33 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
21:20:33 <lambdabot>     In the first argument of `(>>=)', namely `x'
21:20:33 <lambdabot>     In the expression: x >>= return . y
21:20:44 <johnw> isn't that the same as x <*> y?
21:21:17 <rwbarton> y <$> x
21:21:21 <johnw> ahh
21:21:30 <johnw> yes
21:22:51 <johnw> is there a newer version of cabal-install yet for GHC 7.6.1?
21:24:30 * nand` .oO( [1,4,9..100]  =>  [1,4,9,16,25,36,49,64,81,100] )
21:26:55 <startling> wow, clever
21:27:06 <startling> > [1, 4, 9, 10..100]
21:27:07 <lambdabot>   <no location info>: parse error on input `..'
21:27:18 <startling> > [1, 4, 9..100]
21:27:19 <lambdabot>   <no location info>: parse error on input `..'
21:27:34 <startling> >[1,4,9..100]
21:27:39 <startling> > [1,4,9..100]
21:27:40 <lambdabot>   <no location info>: parse error on input `..'
21:27:43 <startling> weird
21:27:44 <ivanm> you can only do one step AFAIK
21:27:52 <ivanm> > [1,4..100]
21:27:53 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
21:28:03 <startling> oh
21:28:03 <ivanm> not sure where nand` got the 9 from
21:28:09 <ivanm> johnw: does the 1.14 release work?
21:28:11 <johnw> he was musing
21:28:16 <johnw> ivanm: trying it in a VM now
21:28:21 <ivanm> * 0.14
21:28:23 <johnw> and the answer is, no
21:28:33 <johnw> Configuring Cabal-1.14.0...
21:28:34 <johnw> Setup: At least the following dependencies are missing:
21:28:34 <johnw> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6
21:28:54 <ivanm> what version of base comes with 7.6?
21:29:16 <ivanm> ahhhh, you need unix 2.6 for 7.6 IIUC
21:29:32 <ivanm> johnw: try just unpacking it, editing the .cabal file to allow unix-2.6 and then install that
21:29:52 <johnw> ok
21:30:05 <YayMe> About to post an hpaste, someone tell me what I'm doing wrong (or possible right?)
21:30:13 <nand`> it was in a thinking bubble for a reason
21:30:27 <ivanm> nand`: ahhh, missed that
21:30:36 <hpaste> YayMe pasted “Attempt at tree insertion” at http://hpaste.org/74373
21:30:58 <ivanm> does anyone know if the #darcs team is working on 7.6 support yet?
21:31:07 <ivanm> YayMe: and your error is???
21:31:09 <YayMe> Alright, that's just annoying, even hpaste is telling me I suck at this
21:31:20 <ivanm> though using == is bad for left/right
21:31:22 <rwbarton> @let (...) [] = repeat 0; (...) (x:xs) = scanl (+) x ((...) $ zipWith (-) xs (x:xs))
21:31:24 <lambdabot>  Defined.
21:31:26 <ivanm> use pattern matching
21:31:28 <YayMe> ivanm: It compiles, I haven't tested it, would it create a good tree?
21:31:30 <rwbarton> > ([1,4,9]...)
21:31:32 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
21:31:35 <ivanm> and why mix guards with if-then-else
21:31:42 <ivanm> YayMe: I don't know what kind of tree you're making :)
21:31:56 <YayMe> ivanm: Will it be sorted? Balanced?
21:32:05 <YayMe> by that insert
21:32:16 <ivanm> well, you're going to be losing values left, right and center
21:32:19 <ivanm> (pun intended :p)
21:32:21 <YayMe> It's not a type of tree you recognize?
21:32:24 <YayMe> hahaha
21:32:25 <YayMe> awesome.
21:32:32 <ivanm> see lines 7 and 11
21:32:38 <ivanm> you're dropping parentVal, etc.
21:32:56 <ivanm> you're _attempting_ to make it sorted
21:32:57 <YayMe> My first crack at trying to write a tree insertion function and haven't looked at any materials on how to do it correctly
21:32:58 <ivanm> but failing
21:33:03 <ivanm> as for balancing, not really
21:33:23 <ivanm> to balance a binary tree, you need to know how many nodes are in each sub-tree, etc.
21:33:37 <ivanm> so either store that in each Branch, or count them each time
21:34:01 <ivanm> or else use a smarter data structure that attempts to have it automagically balance over time as you use it
21:34:11 <ivanm> e.g. splay tree
21:34:13 <YayMe> Yeah, I don't really like the data structure
21:34:17 <ivanm> no, wait, wrong one
21:34:30 <ivanm> it's been a while since I did my data structures course :p
21:34:42 <YayMe> someone suggested it to me as my first attempt at creating a data structure for tree was as bad as my first insertion function there heh
21:34:43 <ivanm> AVL trees attempt to be self-balancing
21:34:55 <johnw> ivanm: got past that by skipping the Cabal build, and now mtl-2.1 fails to build
21:35:10 <ivanm> johnw: what's trying to get mtl-2 ?
21:35:12 <YayMe> I was going to try an avl tree after I actually got *any* tree working
21:35:19 <johnw> the cabal-install bootstrap
21:35:37 * mgsloan votes to replace lambdabot caleskell with ekskell
21:36:02 <ivanm> johnw: oh, c-i also deps on mtl < 3 for some reason :/
21:36:08 <ivanm> mgsloan: what's the difference?
21:36:13 <johnw> Control/Monad/Error/Class.hs:93:18: Not in scope: `catch'
21:36:23 <johnw> isn't the current version of mtl just 2.1.2?
21:36:37 <ivanm> oh, right
21:36:42 <ivanm> I'm getting mixed up with transformers
21:37:41 <johnw> oh, probably this is due to OldException being completely gone now
21:37:44 <ivanm> johnw: poke edwardk to fix that; he seems to have  apatch for it applied to the github version
21:37:48 <ivanm> yeah
21:38:00 <johnw> i'm in no hurry for 7.6
21:38:08 <johnw> so this can wait until the next cabal-install
21:38:25 <ivanm> yeah, I'll wait until c-i and darcs are available for 7.6
21:38:28 <YayMe> ivanm: is it bad style for a tree structure's nodes to know their parent?
21:38:34 <ivanm> YayMe: yes
21:38:39 <YayMe> Balls.
21:38:40 <ivanm> makes it harder to update anything
21:38:44 <YayMe> makes sense
21:38:53 <ivanm> and thus can't do any updates purely and efficiently
21:39:05 <ivanm> that's what zippers are for!
21:39:33 <johnw> YayMe: you also then have a special case for the top node
21:40:06 <scri> johnw: i think this should use define-minor-mode haskell-doc-mode
21:40:29 <scri> that's the idiomatic method for minor modes, in elisp
21:40:40 <johnw> yeah, likely
21:40:50 <scri> i would like to work on this a bit and see if i can help
21:41:02 <johnw> i got the feeling Chris is more of a Haskeller than a Lisper
21:41:17 <johnw> if you want me to review your changes, you can fork my repo and send me a pull request
21:41:25 <ivanm> yup
21:41:30 <johnw> i've been fixing stuff as I come across it too
21:41:32 <scri> that often happens with people who write language modes
21:41:47 <ivanm> johnw: why not just fork the official repo rather than doing a fork of a fork?
21:41:50 <scri> Matz's inf-ruby had some serious bugs a little while ago
21:42:02 <johnw> I have a lot of new features in my haskell-config.el, which I'm going to migrate over to haskell-mode when they are fully stable
21:42:15 <johnw> ivanm: I did fork the official repo
21:42:16 <scri> i'm pretty busy now but would like to work on it
21:42:20 <johnw> I'm saying scri can use me as a filter
21:42:20 * ivanm needs to go and make the "indent and sort imports" stuff toggle-able
21:42:35 <johnw> ivanm: for me that only happens if I use C-c C-..
21:42:42 <ivanm> johnw: sure, but why not just look at his patches from his own fork or something?
21:43:05 <johnw> because that requires me to proactively look at his stuff
21:43:18 <scri> haha, no worries
21:43:20 <johnw> if he does it with pull requests on my repo, i can deal with it reactively
21:43:38 <ivanm> johnw: it's the "magic space" stuff chrisdone has added; typing "import<space>" brings up an ido-filter of possible imports (cool), auto-indents the imports (could be cool) and also sorts them (not cool; I like Data before Control)
21:43:46 <scri> i'll let you know if i come up with something
21:43:54 <ivanm> also, none of his import code understands imports when you have newlines between groups of imports
21:44:06 <ivanm> johnw: can he still then do a pull request on the _official_ repo?
21:44:22 <johnw> no
21:44:28 <johnw> i would do that for him
21:45:00 <ivanm> which means he's relying on you from now on, unless he deletes his fork and re-creates it based upon the official repo
21:45:11 <johnw> yeah, but in this I'm pretty reliable
21:45:11 <ivanm> (this is in part why I'm not a big fan of github's forking model)
21:45:19 <ivanm> for _ever_ ?
21:45:20 <ivanm> ;)
21:45:25 <johnw> until 2073 at least
21:45:52 <ivanm> so you'll be checking github daily from now until 2073? :p
21:45:59 <johnw> i don't have to, it e-mails me
21:46:00 <ivanm> (just in case scri decides to send you patches)
21:46:08 <ivanm> OK, you'll be checking your emails daily
21:46:12 <johnw> *and* I see it in my RSS reader
21:46:19 <johnw> I check e-mails like 20-50 times a day
21:46:25 <johnw> i have fetchmail on IDLE talking to Growl
21:46:26 <ivanm> even on holidays?
21:46:30 <johnw> yes
21:46:34 <johnw> computers are my hobby, not just my job
21:46:37 <ivanm> IDLE? isn't that a python "IDE" ?
21:46:40 <johnw> IMAP IDLE
21:46:53 <ivanm> so you never go camping, to the beach, etc.? :p
21:47:02 <johnw> i'm assuming scri can handle a few days of lag
21:47:16 <johnw> lol, you are just trolling now
21:47:32 <ivanm> mebbe
21:47:34 <otters> @pl \f -> (\x -> f x x) (\x -> f x x)
21:47:34 <lambdabot> ap join join
21:47:36 <ivanm> ;)
21:47:56 <otters> :t ap join join
21:47:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
21:47:57 <lambdabot>     Probable cause: `join' is applied to too few arguments
21:47:57 <lambdabot>     In the second argument of `ap', namely `join'
21:48:03 <centrinia> @pl \f a b c d e g -> d c b g a e
21:48:03 <lambdabot> const ((((flip .) .) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . flip id)))
21:48:10 <shachaf> @ @pl @where y
21:48:12 <shachaf> @@ @pl @where y
21:48:12 <lambdabot>  ap (. join outR) (InR . (. join outR))
21:48:14 <scri> also, i think semantic is the bright future of emacs, but i haven't delved into that yet
21:48:24 <otters> @pl \a b c d e f -> f e d c b a
21:48:25 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
21:48:28 <ivanm> scri: I don't know how well that will work with Haskell
21:48:41 <johnw> semantics totally blows in my opinion
21:48:42 <ivanm> chrisdone was saying we really need to get something more slime-like
21:48:48 <johnw> but that's a #emacs discussion
21:48:53 <ivanm> johnw: just to check: is blows "good" or "bad"? :p
21:49:07 <johnw> yes, something along the lines of SLIME for Haskell would be awesome
21:49:18 <ivanm> what's that program some people (nomeata?) were working on to act as a backend or emacs, vi, etc.?
21:49:18 <johnw> i seriously miss developing Common Lisp code with SLIME
21:49:19 <scri> in any case, it would need a real haskell wizard to get right
21:49:23 <johnw> it blows BAD
21:49:31 <johnw> semantic is the wrong way to solve the problem
21:49:37 <johnw> SLIME is the right way
21:49:51 <shachaf> Hi! I see you're trying to write a type signature!
21:49:56 <johnw> let Haskell code in a server do the heavy lifting (like what ghc-mod does), with a common interface
21:50:20 <nand`> ‘It appears you are trying to write a Haskell function... let me help you with that!’ <- by inserting undefined
21:50:54 <ivanm> dammit, I can't remember the name of that program that was meant to do Haskell querying for editors
21:51:19 <shachaf> Looks like your program doesn't type-check. Do you want me to insert {-# OPTIONS_GHC -fdefer-type-errors #-}?
21:51:28 <amosr> *cough* can I use the term "curly braces" in a thesisy thing?
21:51:30 <johnw> you mean scion?
21:51:36 <ivanm> shachaf: chrisdone already has some things like that from error message parsing
21:51:54 <johnw> scri: I _just_ starting integrating debugging support
21:52:05 <johnw> I can now C-x SPC on an expression, and get a breakpoint set for that line/column
21:52:06 <ivanm> johnw: that's the one!
21:52:19 <applicative> shachaf: oh god have you tried -fdefer-type-errors yet
21:52:21 <johnw> what I want next is subexpression highlighting while stepping
21:52:36 <nand`> amosr: https://en.wikipedia.org/wiki/Curly_braces#Curly_brackets_.7B_.7D <- doesn't seem to mention any more technical name
21:52:38 * rwbarton tries to figure out how to work in a "fix error" pun
21:52:52 <shachaf> applicative: Not until you asked that question!
21:52:52 <nand`> unicode ‘LEFT CURLY BRACKET’
21:53:05 <shachaf> v.hs:1:1: Warning: Couldn't match expected type `IO t0' with actual type `Char'
21:53:08 * applicative refuses 
21:53:18 <applicative> ha
21:53:20 <monochrom> yes you can use the term "curly braces" in a thesis
21:53:25 <shachaf> Next up we need -fdefer-kind-errors
21:53:36 <monochrom> -fdefer-evaluation
21:53:44 <monochrom> wait, we already have that by default
21:53:47 <rwbarton> what happens with "No instance for (Num [Char])" errors, does it cook up a dictionary full of errors?
21:53:49 <nand`> -fdefer-type-errors seems useful for debugging portions of code; ghci -fdefer-type-errors :l File.hs and test the portions you're interested in
21:53:50 <scri> well, first things first then, and i have a lot to learn yet
21:53:51 <amosr> excellent! it just sounds like a funny word to me
21:53:55 <amosr> s/word/term/
21:53:56 <nand`> monochrom: heh
21:53:57 <monochrom> -fno-laziness
21:54:20 <rwbarton> or what happens with show . read
21:54:36 <johnw> -fimperative
21:54:44 <nand`> rwbarton: presumably, trying to use the function that would require either of those to type check would throw the error
21:55:03 <johnw> assumes every line is in IO and wrapped by (unsafePerformIO $ ...)
21:55:17 <rwbarton> I think it's something more subtle/well-principled than replacing non-typechecking definitions with error
21:55:18 <shachaf> I think it just makes a special type of undefined that dies with "deferred type error".
21:55:25 <shachaf> Oh, it is?
21:55:37 <nand`> rwbarton: test it out, I don't have GHC 7.6 yet
21:55:43 <rwbarton> I don't have GHC 7.4 yet!
21:55:54 <nand`> rwbarton: note that x = 5 :: Int; y = x :: Char; z = y :: Int  <- z will error with -fdefer-type-errors
21:55:59 <nand`> even though it technically has the right type
21:56:01 <shachaf> rwbarton: You know GHC 7.4 lets you say "data Foo" in ghci, right?
21:56:06 <shachaf> That's reason enough to upgrade.
21:56:18 * applicative is still protesting that one too
21:56:19 <johnw> shachaf: heh, I've been using that a lot
21:56:22 <rwbarton> But I think "1 + if False then () else 2" is supposed to work, for example
21:56:23 <johnw> I didn't realize it was new in 7.4
21:56:38 * shachaf wonders what happens if just one thread dies with a deferred type error.
21:56:43 <ivanm> I wish I could import other modules from the same project in ghci
21:56:47 <ivanm> even if I haven't transitively loaded them
21:56:56 <Twisol> Isn't monomorphism restriction lifted in ghci now too?
21:56:56 <applicative> typing the words "instance Monad Blah where ..." inside a repl is a crime!
21:56:59 <nand`> shachaf: what happens if just one thread dies with undefined?
21:57:07 <johnw> Twisol: yes, I read that
22:01:47 <ddarius> defer-type-errors should give you the same errors you'd get without it, just at the last possible moment.
22:01:58 <cmears> ivanm: was it you who asked about turning defer-type-errors on and off in ghci?
22:02:04 <ivanm> cmears: yup
22:02:06 <cmears> It looks like you can switch it on and off freely
22:02:13 <ivanm> yeah, got a response for it
22:02:30 <hpaste> YayMe pasted “Attempt at tree insertion” at http://hpaste.org/74374
22:02:31 <nand`> :set -fdefer-type-errors; :set -fno-defer-type-errors ?
22:02:32 <ivanm> they didn't list the -fno-* option in the actual documentation for what it does
22:02:39 <ivanm> nand`: yup
22:02:45 <cmears> nand`: you can use ":unset" too
22:02:48 <YayMe> Now how's it look ivanm?
22:03:09 <ivanm> YayMe: first of all, I'd have the Int before the sub-trees
22:03:18 <YayMe> Ok
22:03:22 <ivanm> (and consider using a record type to at least document what it menas)
22:03:32 <YayMe> I know I need to make that $ (+1) $ childCount better
22:03:52 <YayMe> ivanm: I did use a record type actually then realized I wasn't using any of the key names so tossed it
22:04:02 <ivanm> better of doing: | newVal > parentVal = case right of EmptyTree -> ..., etc.
22:04:03 <YayMe> Is it good to use record types even when you aren't using the key names to access the values directly?
22:04:29 <ivanm> as documentation, sure
22:04:36 <YayMe> ivanm: Will it be sorted and return the *whole* tree upon insertion now?
22:04:42 <ivanm> though there's some contention in that they'll be partial
22:04:52 <YayMe> I know I'm not using the counter to balance it
22:05:19 <ivanm> YayMe: your counting isn't correct: you need to add the value to the appropriate sub-tree, and then use _that_ in currentChildCount
22:05:58 <ivanm> e.g. let right' = insert newVal right in Branch parentVal left right' (1 + currentChildCount left right')
22:06:05 <ivanm> (for line 5)
22:06:41 <ivanm> and when you create a new leaf node, the count should be _one_, not zero
22:06:46 <YayMe> yeah
22:06:51 <YayMe> I just fixed the one thing, just saw it too heh
22:06:56 <YayMe> it would just be always 0 everywhere
22:06:59 <ivanm> I would even define a new function: singletonTree x = Branch x EmptyTree EmptyTree 1
22:07:04 <YayMe> but I don't understand how I am incorrectly counting?
22:07:06 <rwbarton> this code is perplexing in several ways
22:07:18 <ivanm> YayMe: you add a new value to the right tree, but then use the _old_ count
22:07:27 <ivanm> oh, is that what your +1 is meant to be for?
22:07:34 <ivanm> if so, you're not counting the node stored at the root
22:07:44 <YayMe> right that's the +1
22:08:22 <rwbarton> can't you just use childCount and skip the whole currentChildCount thing
22:08:30 <ivanm> YayMe: I you could also use the records in currentChildCount: (Branch{ sizeTree = cl }) (Branch{sizeTree = cr}) = cl + cr
22:08:51 <ivanm> YayMe: and you need another +1 for the root node
22:09:14 <ivanm> you could also do it as a Tree a -> Tree a function to update the tree size
22:09:17 <YayMe> ivanm: am I adding +1 too many times due to the number of layers I might walk down
22:09:25 <ivanm> no, you're not adding it _enough_
22:09:34 <ivanm> YayMe: play with your code
22:09:39 <ivanm> and see what the count is like
22:09:48 <rwbarton> also you should have a case for inserting into an empty tree... then you wouldn't need line 4 or line 6
22:09:51 <YayMe> if it has to walk 3 times, would it add +1 to each node and effectively give +3 which would be wrong? hrmm..
22:10:14 <YayMe> rwbarton: Good point!
22:10:25 <ivanm> rwbarton: huh?
22:10:43 <ivanm> he's checking if the right/left branches are empty
22:10:50 <rwbarton> which is unnecessary
22:10:56 <ivanm> why?
22:11:11 <ivanm> insert 2 (Branch 3 (Branch 4 Empty Empty) Empty)
22:11:12 <rwbarton> because you do the same thing as in the empty case, namely insert the newVal into the child...
22:11:25 <ivanm> yes, but the ordering would be different
22:11:28 <ivanm> oh, right
22:11:30 <YayMe> insert newVal EmptyTree = Branch 1 newVal EmptyTree EmptyTree
22:11:33 <ivanm> he needs the Empty case up the top
22:11:36 <ivanm> gotcha
22:11:41 <rwbarton> yeah
22:11:42 <otters> there should be a Stop Making Blog Posts About the Monad Tutorial Fallacy fallacy
22:11:59 <ivanm> otters: it's wrong to say that people shouldn't make blog posts about monads?
22:12:07 <ivanm> I wouldn't say it's a _fallacy_
22:12:11 <ivanm> a meme maybe...
22:12:14 <otters> no, there are now sufficient blog posts saying that there are too many monad tutorials
22:12:19 <otters> yeah, fallacy was the wrong word
22:12:22 <otters> I just wanted to have it repeated
22:12:28 <ivanm> heh
22:12:34 <rwbarton> Stop Making Blog Posts About the Monad Tutorial Fallacy Considered Harmful
22:12:52 <johnw> well, at least now every monad tutorial starts by saying there are "probably too many monad tutorials"
22:12:56 <johnw> so they are self-affirming
22:12:58 <rwbarton> I think I confused myself with that
22:12:59 <otters> yeah
22:13:04 <otters> I'm writing my own, but it's not actually a tutorial
22:13:08 <otters> nor is it about monads
22:13:25 <nand`> is it okay if I write a monad tutorial as an indirection to LYAH?
22:13:29 <ivanm> is it about Haskell? ;)
22:13:37 <ivanm> *even about
22:14:38 <YayMe> My implementation isn't tail call optimized either is it? I'll have to think about an appropriate accumulator structure..
22:15:14 <otters> It's definitely about Haskell
22:15:24 <ivanm> YayMe: tail call optimisation isn't that important in Haskell
22:15:26 <nand`> the mathematician or the language?
22:15:32 <ivanm> or the place?
22:15:40 <ivanm> or some other random person called Haskell?
22:15:47 <otters> no, it's about the language
22:15:59 <BMeph> Not the school? ;þ
22:16:01 <johnw> i must say, not naming the language Curry was a good choice :)
22:16:03 <ddarius> ivanm: It's exactly as important in Haskell as it is in Scheme.
22:16:08 <YayMe> ivanm: No? But if the tree is sufficiently tall would I not still stackoverflow?
22:16:20 <ddarius> johnw: There is a Curry language, though it followed Haskell.
22:16:45 <johnw> i'm going to write a language called ⊥
22:16:51 * BMeph is impressed that Haskell Brook Curry has a programming language using each of his three names
22:16:52 <ivanm> ddarius: oh? I thought laziness offset TCO more
22:16:55 <nand`> so would a derivative that mixes features of Haskell into Curry be called Haskell Curry?
22:17:01 <ivanm> BMeph: what's Brook?
22:17:37 <ddarius> ivanm: It makes some things that aren't tail calls anyway, to not require unbounded stack (though as people well know it goes the other way too).
22:18:06 <BMeph> ivanm: It's yet another "let's take C and give it something to make it more 'modern'" variants.
22:18:17 <ivanm> BMeph: ahhhh
22:18:32 <startling> BMeph: there are like three of those
22:18:34 <johnw> is Go flourishing anywhere?
22:18:49 <ddarius> And yet I don't believe there is an Alonzo language and possibly not even a Church language.
22:19:00 <ivanm> ddarius: well, haven't there been arguments made recently about the "fallacy" (to make otters happy :p) that people have (had?) been spreading that you need  TCO in Haskell?
22:19:01 <BMeph> ivanm: See http://graphics.stanford.edu/projects/brookgpu/lang.html for details.
22:19:02 <shachaf> Church language is sometimes called "tongues"
22:19:14 <startling> there is apparently an Alonzo
22:19:15 <johnw> what about a Turing language?
22:19:37 <nand`> johnw: there are at least 6 ongoing major Go tournaments
22:19:41 <startling> and a Church
22:19:47 <startling> nand`: heh
22:19:56 <ddarius> ivanm: You need TCO in Haskell.  foldl', for example, evaluates exactly the same in Haskell as Scheme.  I.e. any strict loop, of which there are plenty, has exactly the same constraints in Haskell as Scheme.
22:20:10 <mm_freak> ivanm: tail calls are not that important, but tail call optimization certainly is…  however, the way GHC compiles haskell programs doesn't actually need the optimization
22:20:19 <ivanm> *nod*
22:20:52 <mm_freak> you often don't have tail calls, but semantics save you
22:21:07 <ddarius> If your calls aren't tail calls, TCO is irrelevant.
22:22:40 <mm_freak> it's interesting that in a nonstrict functional language you don't actually need TCO, if you compile it to an (ST)G-machine…  there tail calls are jumps by concept
22:23:14 <ddarius> mm_freak: That's just saying that the implementation does perform "TCO".  It doesn't need to be performed exactly at described in the 1970s paper.
22:23:36 <ddarius> At any rate, in my opinion TCO isn't an "optimization", rather implementations lacking it are simply broken.
22:23:45 <mm_freak> true
22:23:50 <ddarius> Or slightly less negatively, "pessimized".
22:24:45 <ddarius> If you do beta reduction by syntactic substition (or in many other models), tail call "optimization" happens automatically.  Note, you can define a notion of "call stack" even in the syntactic substitution model.
22:25:07 <otters> oh what's the point
22:25:08 <ddarius> And even without a formal notion, it's quite easy to recognize non-tail call behavior.
22:25:11 <otters> byorgey said it rather better than I did
22:26:15 <dolio> Is that like how ML performs optimizations so that pattern matching doesn't use stack?
22:26:20 <hpaste> YayMe pasted “Attempt at tree insertion” at http://hpaste.org/74375
22:26:50 <YayMe> ivanm: better? :)
22:27:27 <YayMe> Or anyone? Is my tree inserting without losing nodes and maintaining a subnode count and sort correctly? (While admittedly unbalanced)
22:27:27 <ddarius> In fact, the fact that there's nothing to "optimize" in the archetypical models of e.g. lambda calculus makes tail call optimization rather hard to define precisely.
22:27:34 <ivanm> YayMe: yup
22:28:53 <YayMe> Don't know why I used an if/else instead of guard
22:29:23 <johnw> i still do that too
22:29:30 <YayMe> Ok, now to move on to figuring out how to make it maintain balance
22:30:06 <johnw> YayMe: I assume you know about balanced trees?
22:30:10 <YayMe> I don't like if/else in haskell at all but I still can't think up the correct way to write a guard for things right off having written if/elses for so many years heh
22:30:20 <YayMe> johnw: That's why I'm doing this, trying to learn
22:30:26 <YayMe> never implemented one before
22:30:35 <johnw> there are several different balancing strategies
22:30:42 <johnw> I happen to like red-black
22:30:54 <johnw> haven't implemented it in Haskell before, but I've done it in C
22:31:38 <johnw> what will be tricky will be the Functor instance
22:32:04 <YayMe> I looked at avl and red-black last night, red-black was really obvious visually, but I can't imagine how to actually implement either of them, though since I'm a hands on learner, that's to be my task of present. I think I can start to see it a bit since I'm really reconstructing the whole tree on each insertion, the parents are recreated
22:32:25 <johnw> one good way to implement red-black at first is in pseudo-code
22:32:51 <ADNAUSEAM> johnw: it should be simple. functors are basically data given a specific form. take a minute and write down how you think it will behave before you get onto programming it - that will help a lot
22:33:05 <johnw> you'll also find yourself drawing diagrams on paper, if you're like me at all :)
22:33:10 <YayMe> aye, I'll have to think about it, but it's time for the sleep, gotta hit the bed before the wife gets too mad at me for staying up studying this shit
22:34:18 <johnw> ADNAUSEAM: I guess the rebalancing isn't any worse than any other insertion
22:34:37 <YayMe> johnw: I've been an OOP developer for 10 years now, I'm quite demanding on white boards for diagramming heh, but all this algorithm stuff is new to me having done largely CRUD apps and writing my most complex algorithms in SQL which is very natural but different than any other language I know
22:34:38 <ADNAUSEAM> it's just a concept mate
22:34:39 <johnw> so yo'ure right, it should follow simply once you have a "balance" function
22:34:43 <ADNAUSEAM> once you get it down, you got it
22:35:04 <ADNAUSEAM> it's like understanding something - it's not a regenerative puzzle
22:35:17 <ADNAUSEAM> you can actually apply it later to many things
22:38:25 <Twisol> How does read :: Char behave? If I do read <$> getLine it gives me a parse failure. I was hoping it would take the first character in the line.
22:39:22 <shachaf> > read :: Char
22:39:23 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
22:39:23 <lambdabot>         against inferred type...
22:39:26 <shachaf> It doesn't.
22:39:28 <startling> Twisol: why not head <$> getLine ?
22:39:33 <amosr> head <$> getLine ?
22:39:40 <johnw> getLine >>= fmap read
22:39:50 <startling> ohhh, that's what he wants
22:39:50 <johnw> should read every char on the line into a list
22:40:10 <shachaf> johnw: What?
22:40:18 <Twisol> I have a generic 'prompt' action that spits out a prompt and waits for input
22:40:31 * ddarius watches shachaf's spirit be chipped away.
22:40:33 <johnw> shachaf: no?
22:40:35 <johnw> hahaha
22:40:40 <Twisol> ^_^
22:40:45 <johnw> i'm not saying he SHOULD do it
22:40:55 <johnw> i'm just pointing out why his expression didn't type check
22:40:59 <Twisol> It type checks
22:41:04 <Twisol> The parse failure is at runtime.
22:41:08 <johnw> ohh
22:41:12 <Twisol> (also, <$> == fmap)
22:41:13 <johnw> ok, never mind me then
22:41:33 <johnw> oh, I see
22:41:38 <johnw> I was distracted by the read :: Char thing
22:41:44 <johnw> read <$> getLine want a String
22:41:52 <Twisol> Yeah, read's polymorphic so I wanted to make it clear what I was using it for.
22:41:56 <johnw> because the <$> is boxing/unboxing (just for you, shachaf) IO
22:42:12 <shachaf> johnw: I don't get it.
22:42:22 <johnw> :t read <$> getLine
22:42:23 <lambdabot> forall a. (Read a) => IO a
22:42:36 <johnw> will call read :: String, yes?
22:42:45 <ddarius> :t read
22:42:45 <shachaf> > read :: String
22:42:46 <lambdabot> forall a. (Read a) => String -> a
22:42:46 <lambdabot>   Couldn't match expected type `GHC.Base.String'
22:42:46 <lambdabot>         against inferred typ...
22:42:52 <johnw> if he wants read :: Char, he needs to fmap read over that string
22:42:57 <johnw> thus, getLine >>= fmap read
22:42:59 <Twisol> It will accept a String, but return whatever it is I use the result for later on
22:43:05 <shachaf> johnw: I don't think anthing you're saying is correct. :-(
22:43:06 <ddarius> read's type is always String -> A for some A.
22:43:20 <Twisol> For -any- A - it's polymorphic depending on context
22:43:24 <johnw> shachaf: how about saying what is correct, then, instead of sniping from your ivory tower, mk?
22:43:27 <Twisol> any A implementing the Read interface
22:43:42 <Twisol> read "142" :: Int gives me an Int
22:43:55 <johnw> ah, he wants read :: String -> Char
22:44:09 <shachaf> I don't think anyone wants read :: String -> Char
22:44:10 <Twisol> Thus read :: Char, explicitly pointing out that it's failing when I use it in a Char context.
22:44:24 <johnw> > read "'a'" :: Char
22:44:24 <amosr> read "'c'" :: Char gives you 'c', but is that really what you cant?
22:44:25 <lambdabot>   'a'
22:44:40 <Twisol> amosr: It is - I'm using this for a command line utility
22:44:57 <Twisol> "Enter your selection: " where you can type a set of one-char commands
22:45:02 <amosr> you don't want "'" in this case?
22:45:04 <shachaf> ddarius: Did you drive along Hwy 1 when you were here?
22:45:07 <Twisol> Ah
22:45:22 <Twisol> amosr: The single quote was hidden by those doubles. That's exactly my problem, thanks.
22:45:28 * Twisol scurries off
22:45:30 <amosr> you may just want to get the head of the string
22:45:35 <startling> Twisol: you don't need `read` at all
22:45:39 <ddarius> shachaf: Yes, I drove from LA to about 80 miles north of San Francisco.
22:45:46 <Twisol> prompt str = putStr str >> hFlush stdout >> read <$> getLine
22:45:49 <Twisol> ^ is what I have
22:45:59 <startling> Twisol: try head <$> getLine
22:46:03 <shachaf> ddarius: Aha.
22:46:04 <Twisol> I'm using it in two contexts: where I want a one-char command, and where I want an integer
22:46:12 <johnw> Twisol: what do you want the result of prompt to be?
22:46:13 <Twisol> I was hoping to reuse the same function both places.
22:46:14 <amosr> s <- getLine; case s of "c" -> do blah
22:46:19 <shachaf> ddarius: I'll probably do some of that in the other direction tomorrow.
22:46:30 <ddarius> shachaf: I recommend it more than going down 5.
22:46:34 <startling> prompt reader str = putStr str >> hFlush stdout >> reader <$> getLine
22:46:37 <startling> Twisol: ^
22:47:04 <startling> then `prompt (read :: String -> Integer)` and `prompt head`
22:47:19 <startling> Twisol: read is absolutely not what you want for single characters
22:47:34 <Twisol> y'all are missing my point
22:47:35 <shachaf> Yes, several people have.
22:47:49 <startling> Twisol: what's your point?
22:47:53 <Twisol> I know how to accomplish the mighty feat of reading a character. :)
22:48:23 <Twisol> I'm doing something multiple places that only varies on the thing I'm reading in.
22:48:36 <Twisol> the generic prompt thing with a reader arg is definitely closer to what I want
22:49:17 <startling> you could have a typeclass
22:49:17 <Twisol> Can I newtype over Char and re-implement Show to get the functionality I desire?
22:49:30 <startling> Show?
22:49:33 <Twisol> *Read
22:49:35 <Twisol> Sorry.
22:49:38 <shachaf> You can make a type class for this.
22:49:45 <startling> I would have a separate typeclass
22:49:46 <shachaf> It might be that a type class isn't what you actually want.
22:49:57 <ddarius> Twisol: You could but that would be extremely silly.
22:50:37 <Twisol> I guess I'm trying to get a C-like scanf() functionality. scanf() has a %c flag for a single char as well as an %i flag for integers, and so on.
22:52:39 <scri> that seems tricky in haskell. i know ocaml has a weird mechanism for printf
22:52:56 <startling> Twisol: you're going to have to explicitly dispatch against each possibility
22:53:51 <ddarius> It's pretty straightforward to implement something comparable to C's scanf in Haskell.
22:55:05 <Twisol> it seems like Read is almost exactly like scanf, but with an extensible set of accepted types.
22:56:19 <ddarius> Twisol: With scanf I could read in the format string at run-time and then parse based on that.  You cannot do that with read (though you could certainly use read to make a function that could do that.)
22:58:36 <Twisol> meh, DC'd
22:59:49 <hpaste> Twisol pasted “Single character read” at http://hpaste.org/74376
23:00:37 <Twisol> meh, forgot to rename it at one spot
23:00:59 <ddarius> Please integrate e^(2ax-a^2)/a from a = m to n  (m, n real, both > 0 with m < n)
23:03:51 <Nereid> ddarius: that doesn't have a nice answer.
23:04:00 <ddarius> Yeah, I know.
23:04:22 <Nereid> unless x = 0.
23:05:15 <Nereid> and even if x = 0.
23:05:23 <ddarius> It's still erf
23:05:33 <Nereid> no, it isn't, because of that /a
23:05:39 <ddarius> Oh yes.
23:06:28 * ddarius should see the growth rate for it when bounded rather than when n -> infinity.
23:12:33 * ddarius thinks about convolution with a differential operator.
23:14:30 <lightquake> does _|_ inhabit Void?
23:16:02 <ddarius> It inhabits all types in Haskell.
23:16:23 <evincar> lightquake: Intuitively, bottom and void are the same thing.
23:16:55 <ddarius> evincar: _|_ is a value, Void is a type.
23:17:45 <johnw> is it really a value?
23:17:51 <ddarius> Also the function void :: Void -> a is a function and, I believe, distinguishable from undefined.
23:17:53 <johnw> i thought it also stood for non-termination
23:18:06 <ddarius> In Haskell, the non-terminating computation is a value.
23:18:11 <johnw> ah, ok
23:18:20 <evincar> ddarius: Kind of. Haskell's bottom type is a unit type, not a void one.
23:18:28 <evincar> But bottom in general is not defined that way.
23:19:05 <ddarius> evincar: The _|_ notation comes from lattice theory where it just means the bottom of a lattice.  E.g. in the normal ordering lattice on naturals, _|_ would be 0.
23:21:07 <evincar> ddarius: Didn't know that. It would help if these terms weren't overloaded. :P
23:22:10 <evincar> I think of types as asets, and bottom as the empty set.
23:22:14 <evincar> Which is trivially a subset of all others.
23:22:19 <evincar> *sets
23:22:44 <ddarius> Viewing types as (plain) sets falls apart pretty quickly.
23:22:47 <Jafet> That's a different lattice
23:23:07 <evincar> Yes, but it's a good intuitive starting point.
23:23:27 <evincar> It's easy to explain union and intersection types that way.
23:23:35 <evincar> And ordering.
23:24:08 <jedws> I thought that was Unit
23:24:13 <evincar> I have had to use complement types in type inference before. :P
23:25:01 <Jafet> However, Haskell doesn't have those.
23:25:33 <evincar> Which is probably a good thing.
23:25:50 <evincar> But it vexes me to no end when I *want* an intersection type and can't have it.
23:25:51 * ddarius suspects evincar was (implicitly) using something more intuitionistic than "complement of a set" would suggest.
23:26:55 <drbean> I have to write my own lookup of an association list`, if I want it to die rather than give me a Nothing?
23:27:07 <otters> you could just use fromJust
23:27:13 <ddarius> Or you could just not do that.
23:27:16 <dmwit> don't do this =(
23:27:20 <otters> yeah
23:27:26 <johnw> drbean: yes
23:27:26 <otters> unsafeRecommendFromJust
23:27:28 <otters> night
23:27:37 <dmwit> johnw: That is incorrect.
23:27:44 <evincar> ddarius: Check out Wand's "Type Inclusion Constraints and Type Inference" if you care to know the details.
23:27:49 <dmwit> As otters said, if you choose to throw away good advice, fromJust exists.
23:27:51 <johnw> if he wants that behavior to be an aspect of the list itself
23:28:02 <dmwit> I have no idea what that means.
23:28:09 <ion> or we could burn otters at the stake
23:28:15 <johnw> he wants a dangerous association list, don't you drbean?
23:28:16 <otters> you wouldn't
23:28:18 <otters> otters are adorable
23:28:30 <johnw> or do you just want a dangerous lookup?
23:28:36 <ddarius> otters: So are lambs.
23:28:46 <otters> I don't burn lambs at the stake either.
23:28:48 <johnw> in that case, lookup' = fromJust . lookup
23:28:49 <otters> I don't know what point you're making
23:28:55 * dmwit tries to imagine what "dangerous association list" could possibly mean.
23:28:58 <otters> :t fromJust . lookup
23:28:59 <lambdabot>     Couldn't match expected type `Maybe a'
23:28:59 <lambdabot>            against inferred type `[(a1, b)] -> Maybe b'
23:28:59 <lambdabot>     Probable cause: `lookup' is applied to too few arguments
23:29:05 <ddarius> otters: Lamb tastes good.
23:29:06 <otters> :t (fromJust .) . lookup
23:29:07 <lambdabot> forall a a1. (Eq a1) => a1 -> [(a1, a)] -> a
23:29:11 <drbean> It means I forgot something.
23:29:11 <otters> Don't listen to johnw.
23:29:14 <otters> He's special.
23:29:15 <startling> dmwit: bad things will happen if you associate with the people in this list
23:29:19 <evincar> (.:) really should be in the Prelude...
23:29:30 <evincar> Or not.
23:29:36 <johnw> oh, yeah, lookup takes two args
23:29:39 <otters> :t fromJust .: lookup
23:29:40 <lambdabot> forall a a1. (Eq a1) => a1 -> [(a1, a)] -> a
23:29:49 <otters> @src (.:)
23:29:50 <lambdabot> Source not found. My mind is going. I can feel it.
23:29:56 <dmwit> :t \k -> fromJust . lookup k
23:29:57 <lambdabot> forall a a1. (Eq a1) => a1 -> [(a1, a)] -> a
23:29:58 <johnw> nice
23:29:58 <startling> otters: it's (.).(.)
23:30:05 <otters> heh heh
23:30:05 <johnw> that's a great usage of (.:)!
23:30:18 <dmwit> That's like *the* archetypical usage of (.:).
23:30:26 <startling> :t (.:)
23:30:27 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
23:30:31 <startling> :t(.::)
23:30:36 <startling> aw
23:30:47 <evincar> startling: At work we call the next one (.:.)
23:30:55 <startling> :t (:.)
23:30:55 <lambdabot> Not in scope: data constructor `:.'
23:30:58 <johnw> to compose a -> b with c -> d -> a?
23:31:07 <startling> johnw: yep
23:31:17 <johnw> that's much more understandable than fmap fmap fmap
23:31:19 <startling> evincar: the next on e in which direction?
23:31:34 <ADNAUSEAM> (.).(.) looks like boobies
23:31:39 <otters> ddarius: but at the stake?
23:31:50 <startling> otters: *steak
23:32:07 <otters> lambs don't make steak
23:32:20 <pharaun> I could use a bit of parsing advice - any good way to do dynamic parsing, ie I have a bitmask that indicates what fields are present, and each field have different value, string, integer, boolean, a couple of states
23:32:24 <startling> no, he means he's grilling it
23:32:24 <evincar> startling: Unary with ternary, so (.) . (.:)
23:32:26 <johnw> dmwit: ah, now I see what you mean
23:32:32 <pharaun> i'm a bit stuck on a good way of parsing this
23:32:32 <startling> at the (same place as the) steak
23:32:32 <johnw> dmwit: bah, I'm off my game tonight
23:32:46 <startling> evincar: ah
23:32:58 <ddarius> otters: Usually on a vertical spit in a broiler.
23:33:10 <otters> Well, I don't know much about cooking lambs.
23:33:30 <evincar> pharaun: By "dynamic" you mean "context sensitive", so monadic parsing.
23:33:50 <ddarius> otters: Well you still have the point that people don't typically eat otters, though I'd be willing to give it a go.
23:33:57 <evincar> (Stock answer.)
23:34:21 <johnw> having known an actual lamb that lived at a friend's house for the first week of its life, I have to say that they are awfully cute themselves
23:34:23 <evincar> ddarius: On average, cuteness correlates with deliciousness.
23:34:26 <pharaun> evincar: i've figured that out so far :p but my problem is i hve up to 56 possible fields, i do not want to have to enumerate each
23:34:50 <pharaun> i was just going to store the result in a int map but that would force me to store it all as a string, i guess :\
23:35:16 <lpvb> I have an IO ByteString that I want to feed into a function ByteString -> Irc (), where Irc is defined here: https://github.com/jaspervdj/number-six/blob/master/src/NumberSix/Irc.hs
23:35:22 <lpvb> any idea how I would do that?
23:35:31 <pharaun> well i do have 5-6 types so i could store the type/data in the intmap np, but my primary problem is parsing the damn thing
23:35:33 <otters> fmap
23:35:42 <dmwit> probably liftIO ioBS >>= fBSToIRC
23:36:04 <dmwit> Yes, Irc is a MonadIO instance, so that.
23:36:21 <lpvb> k thanks
23:36:39 <otters> deriving Monad
23:36:43 <otters> that's really something
23:36:45 <evincar> pharaun: I probably don't know your problem well enough, but why not just an ADT with a ctor for each type, and an IntMap That?
23:36:58 <dmwit> otters: newtypes are easier than most types
23:36:58 <evincar> But parsing.
23:37:26 <lpvb> what does liftIO do? It's something about monad transformers?
23:37:26 <dmwit> otters: You can just pull up any old instance by throwing away/adding the single constructor everywhere appropriate in the underlying instance.
23:37:33 <dmwit> :t liftIO
23:37:34 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:38:00 <lpvb> so it will convert an IO monad into any other monad type?
23:38:04 <pharaun> evincar: yeah i'm probably going to just do that ADT would take care of that part :) i think i have a solution forming, i guess talking it out helped
23:38:18 <lpvb> that's cool
23:38:26 <avpx> lpvb: Not quite "any" other monad type
23:38:27 <dmwit> No, only other monads that implement MonadIO.
23:38:38 <otters> sorry, still can't extract the value
23:38:45 <dmwit> Usually, that means any monad transformer stack that has IO at the bottom.
23:38:49 <lpvb> oh, yea, I missed the class constraint
23:38:50 <avpx> But yes, it's quite useful
23:39:18 <dmwit> lpvb and avpx are going to confuse me. irssi even chose to color their nicks the same way.
23:39:28 <otters> use weechat
23:39:28 <evincar> pharaun: Rubberducking remains my #1 problem solving tool, with another human or without.
23:39:33 <ddarius> @google "when you have a pig like that"
23:39:34 <lambdabot> http://www.jokesplace.com/joke/famouspig.html
23:39:34 <lambdabot> Title: The Famous Pig - Animal Jokes - Jokes Place!
23:39:34 <avpx> dmwit: Hah.
23:39:54 <pharaun> evincar: indeed :D well thanks for rubberducking for me and suggesting ADT with a ctor
23:44:41 * hackagebot egison-quote 0.2 - A quasi quotes for using Egison expression in Haskell code  http://hackage.haskell.org/package/egison-quote-0.2 (TakuyaKuwahara)
23:55:52 <evincar> Hmm. Can't use GADTs to enforce types that Haskell doesn't have. :(
23:56:12 <lpvb> are ghc libs linked statically into programs? my executable is hugeeeee
23:56:35 <johnw> did you strip it?
23:56:48 <lpvb> johnw: I just did --make
23:56:57 <johnw> my typical executable is around 3.3M
23:57:14 <lpvb> can I run the executable on another machine without recompiling it?
23:57:15 <johnw> the biggest one I have is 59M
23:57:23 <johnw> lpvb: what OS are you on?
23:57:27 <lpvb> archlinux
23:57:30 <lpvb> target is ubunut
23:57:32 <johnw> run "ldd <file>"
23:57:33 <lpvb> ubuntu
23:57:36 <johnw> hmm
23:57:46 <johnw> you can always try :)
23:58:31 <evincar> johnw: But how would I get points on SO if everyone tried things before asking about them?
23:58:43 <lpvb> the server ubuntu ghc stuff is very outdated
23:58:45 <johnw> lol
23:59:05 <evincar> It's disingenuous to encourage that kind of behaviour.
23:59:07 <evincar> I want points. :P
23:59:10 <lpvb> evincar: low hanging fruit
23:59:15 <evincar> Heh.
23:59:28 <shachaf> evincar: Feel free to ask a question and then answer it.
23:59:50 <evincar> shachaf: Self-answers might as well be blog articles.
