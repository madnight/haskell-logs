00:00:25 <edwardk> haven't set up the meeting yet, but probably ~3 weeks from now. i like to give about that much lead time to the announcements
00:00:33 <johnw> oh, too bad
00:00:39 <edwardk> are you in the area?
00:00:44 <johnw> i'm heading to the C++ standards meeting too soon after that to be able to go
00:00:53 <johnw> my business is headquartered in Boston, so I maybe could have come
00:01:07 <johnw> i'll be at the LLVM dev conference too, in Mountain View
00:01:09 <johnw> 11/5
00:01:13 <johnw> will you be there around there?
00:01:21 <edwardk> well, we do boston haskell meetups ever couple of months, whenever i can get a speaker
00:01:43 <edwardk> i'll be there from 10/18-10/22 or so, but i'll be gone by 11/5
00:01:52 <shachaf> edwardk: Funny, I thought a projector was the main piece of equipment you used.
00:02:01 <edwardk> shachaf++
00:02:13 <shachaf> edwardk: (Inquiring about the bahaskell thing.)
00:02:32 <ion> blahaskell
00:02:43 <ion> #-blah should be named that.
00:02:55 <johnw> edwardk: I'll be taking the train down to that area on 10/19
00:03:01 <johnw> so maybe I could meet you up for dinner
00:03:17 <edwardk> johnw: i'll be there for the gsoc mentor summit that weekend, sure.
00:03:39 <johnw> great, i'll contact you by e-mail soon then
00:04:02 <shachaf> johnw: You should come to bahaskell if it works out to be on 2012-10-18!
00:04:07 <edwardk> if you ever want to give a talk at boston haskell, let me know ;)
00:04:31 <johnw> shachaf: I was talking about being in Mountain View on 10/19
00:04:39 <Twisol> Hm. Any south-california haskellers here?
00:04:43 <edwardk> even if its, 'what haskell looks like to a boost guy' ;)
00:04:47 <johnw> but I'd certainly love to come to Boston Haskell!
00:04:52 * shachaf is currently in San Diego, but only for a few more days.
00:05:10 <mjrosenb> dmwit: i know. i've already started implementing one of them, but i figure if someone could say X is probably better, i'd implement that first :-p
00:05:22 <Twisol> shachaf: too south :(
00:05:45 <shachaf> mjrosenb: Unfortunately benchmarks with only one entry aren't all that useful.
00:05:51 <johnw> I wouldn't mind presenting on using Haskell in Emacs :)
00:06:12 <edwardk> johnw: https://groups.google.com/forum/?fromgroups#!forum/bostonhaskell is probably the best way to keep informed of when the meetings are, etc.
00:06:21 <johnw> the other day I did want to port Boost.Graph to Haskell, if that hasn't been done already
00:06:32 <shachaf> edwardk: OK, it looks like my response is "I'm a bit swamped, can you send an email to the mailing list asking if people would be OK with it?".
00:06:43 <edwardk> heh
00:07:05 <edwardk> johnw: https://github.com/ekmett/graphs
00:07:24 <johnw> you are such a crazy man :)
00:07:27 <johnw> and awesome!
00:07:32 * johnw hugs edwardk
00:07:34 <edwardk> johnw: its sort of the bastard child of my old comonadic annotated graph library and bgl
00:07:49 <edwardk> johnw: it needs some love and attention and i'm not entirely pleased with the api
00:07:55 * johnw strictly hugs shachaf, avoiding contact with any bottoms
00:08:26 <edwardk> if you are worried about that sort of thing, note that being strict is more likely to bring you into contact with bottoms, so relax and be lazy.
00:08:28 <shachaf> edwardk: Do you know what I should put in that email to convince people?
00:08:33 <johnw> edwardk: well, I have an accounting app that uses BGL to resolve commodity values, so when I get to porting that to Haskell (if I do), I'll certainly have some comments for you
00:09:04 <edwardk> shachaf: that i'd be happy to come out and give a nice long talk on lenses, folds and traversals and why they matter?
00:09:32 <lpvb> Did haskell get slower compared to 3 years ago? Old internet messages say the computer language benchmark game showed similar performance as C then.
00:09:37 <johnw> edwardk: here's my first Lens-using utility: https://github.com/jwiegley/sizes/blob/master/Main.hs
00:09:47 <johnw> it's kind of a du on steroids
00:09:53 <edwardk> johnw: fair nuff. the model i have there is more or less read-only when it comes to the shape of the graph, but supports lots of edge and node annotations/lookups, etc.
00:10:00 <edwardk> that was what i needed at the time
00:10:06 <johnw> something that I use all the time to find bloat on my filesystems.  The current version is in bash, and was too slow and didn't have much capability
00:10:23 <johnw> the Haskell version is concurrent (for a 30% speed gain) and has the features I needed
00:10:38 <shachaf> edwardk: OK, I'll write that. :-)
00:10:53 <mjrosenb> johnw: du on steroids sounds useful.
00:11:00 <johnw> let me upload it
00:11:49 * mjrosenb frequently uses ncdu for a 'du-on-steriods' like program
00:12:00 <edwardk> johnw: fwiw- makeLenses ''EntryInfo  can be swapped for makeClasy ''EntryInfo  and that will give you a HasEntryInfo class. doesn't matter on something this small
00:12:30 <johnw> mjrosenb: basic usage is "sizes *".  it shows you all files/dirs >10MB at the top level, plus i-node consumption (which can make rsync and backup utilities VERY slow, even if the directories are not large)
00:12:33 <edwardk> but when you go to extend it, its nice, because you can then lift all the lenses that know how to access parts of EntryInfo into a larger data type.
00:12:54 <johnw> edwardk: should I always be using makeClasy?
00:13:13 <edwardk> e.g. data FooInfo = FooInfo { _fooEntryInfo :: EntryInfo, _fooBar :: Int }; makeClassy ''FooInto; instance HasEntryInfo FooInfo where entryInfo = fooEntryInfo
00:13:38 <edwardk> the rule of thumb is if your data type has no arguments, use makeClassy. if it has type arguments use makeLenses
00:13:57 <johnw> ok, this is a great item for the talk/FAQ/README/book signing deal
00:14:00 <johnw> oh, and the movie
00:14:03 <edwardk> yep
00:14:16 <shachaf> What's makeClassy?
00:14:16 <edwardk> Lenses: the Motion Picture
00:14:27 <edwardk> shachaf: bolts a typeclass on the front of every lens
00:14:44 <shachaf> Why is that needed?
00:14:53 <edwardk> shachaf: e.g. for his EntryInfo, it would have class HasEntryInfo t where entryInfo :: Simple Lens t EntryInfo
00:15:11 <shachaf> Control.Lens.Th should probably have this rule of thumb as well as an example of generated code. :-)
00:15:39 <edwardk> shachaf: then entryPath :: HasEntryInfo t => Simple Lens t FilePath   -- rather than entryPath :: Simple Lens EntryInfo FilePath
00:15:59 <edwardk> shachaf: probably. patch it. i'll take it =)
00:16:51 <johnw> coding in Haskell is so much FUN
00:17:34 <lpvb> Is Data.Vector better than Data.Array?
00:17:38 <johnw> i can't even play video games anymore, because 5 mins after starting I feel like I'd rather be discovering stuff in Haskell
00:17:52 <Twisol> johnw: I always say, programming is my video game. ;)
00:17:53 <lpvb> ^^
00:17:53 <edwardk> lpvb: depends on your usecase. its nice if you don't need the complex indexing that array supports
00:18:02 <johnw> Twisol: indeed!
00:18:13 <johnw> i was reading up on DSTM today
00:18:15 <lpvb> complex indexing?
00:18:25 <johnw> it's just so *cool* all these facilities that are within such easy reach!
00:18:52 <edwardk> lpvb: Data.Array supports indexing by arbitrary types that have an Ix constraint on them, so you can make multidimensional arrays, arrays indexed by enumerable types like Ordering, etc.
00:18:57 <johnw> i'm making code parallel and concurrent now without really thinking about it much; whereas in C++ it's a serious undertaking that requires weighing the costs vs. the benefits
00:19:13 <edwardk> johnw: the major selling point for haskell for me is concurrency.
00:20:07 <johnw> interestingly, "sizes -j2/3/4" are the only values that offer much speedup over -j1.  At -j8 it gets worse, and -j16 is much worse.  Which is odd, since I'm running it on an SSD...  Guess I'm thrashing the controller or something
00:20:14 <lpvb> edwardk: thanks
00:20:49 <edwardk> johnw: did you see 'speculation'?
00:20:50 <johnw> mjrosenb: "sizes" should be on Hackage now
00:21:08 <johnw> edwardk: is there somewhere that I can just see a list of all your amazing libraries?
00:21:08 <edwardk> @hackage speculation
00:21:09 <lambdabot> http://hackage.haskell.org/package/speculation
00:21:16 <shachaf> edwardk: Is that another lens thing?
00:21:17 <johnw> i have a feeling i'm going to want to use a lot of them
00:21:28 <edwardk> johnw: https://github.com/ekmett/ has most of them
00:21:30 <johnw> also, I'd like to know which ones you recommend using, and which are deprecated
00:21:34 <edwardk> at least the ones from the last 2 years or so
00:22:12 * nejucomo hunts for an http library that has client & server apis; is cross platform; and has SSL support.  Any recommendations?
00:22:17 <edwardk> i should go through and mark the few i'd consider deprecated or obsolete as such on github
00:22:28 <mikeplus64> is there a function :: ByteString -> IO CString ?
00:22:35 <johnw> edwardk: what's a typical use case for speculation?
00:22:59 <mikeplus64> other than useAsCString x return, which doesn't seem to be working anyway (i suspect - as the docs say - the string is being automatically freed)
00:23:06 <edwardk> johnw: say you have a big pipeline. lets just assume it has two stages for now. phase 1, and phase 2, where phase 2 depends on an answer calculated in phase 1
00:23:21 <edwardk> johnw: but you have a decent guess at what the answer of phase 1 could be, that is say, 80% accurate
00:23:25 <shachaf> mikeplus64: If it's not automatically freed, how are you hoping to free it?
00:23:33 <shachaf> Manually?
00:23:38 <edwardk> you can start calculating phase 2 using the guess in an otherwise idle core
00:23:44 <edwardk> and then check that you guessed correctly
00:23:46 <johnw> ahh
00:23:51 <johnw> do you use speculation much?
00:23:52 <mikeplus64> shachaf: i suppose
00:23:59 <edwardk> and if so yield the answer, otherwise start over
00:24:03 <edwardk> the implementation fits on a line
00:24:16 <mikeplus64> shachaf: i'm trying to make a function :: ByteString -> IO (Ptr GLchar)
00:24:35 <edwardk> spec guess f actual = speculation `par` if guess == actual then speculation else f actual where speculation = f guess
00:24:36 <johnw> edwardk: very nice
00:24:49 <shachaf> mikeplus64: You can make ByteString -> (Ptr GLchar -> IO a) -> IO a
00:24:50 <edwardk> i do.
00:25:04 <mikeplus64> shachaf: how?
00:25:17 <edwardk> it turns out that lots of processes admit speculation a to their intermediate results with decent surety
00:25:19 <shachaf> mikeplus64: Using useAsCString
00:25:27 <mikeplus64> and castPtr?
00:25:33 <edwardk> and if i can guess right 80% of the time, i can get almost 80% utilization out of otherwise idle cpus
00:25:34 <shachaf> It'll have the property of automatically freeing the CString too.
00:25:40 <mikeplus64> yeah
00:25:44 <shachaf> mikeplus64: Presumably...
00:25:51 <shachaf> I don't know about the details of GLchar.
00:26:20 <mikeplus64> newtype GLchar = GLchar CChar
00:26:32 <mikeplus64> so i think that castPtr should work on it?
00:26:38 <edwardk> consider lexical analysis or huffman decoding. you can start a lexer, say 80 characters before rather than at the start of the file, and get a good guess at the lexer state that is probably 90% accurate for c/c++ lexing. this means you can lex and parse in parallel
00:26:56 * hackagebot sizes 1.0.0 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-1.0.0 (JohnWiegley)
00:27:03 <shachaf> mikeplus64: Who knows.
00:27:15 <johnw> mjrosenb: at last
00:27:48 <edwardk> with huffman decoding, the state that is the top of the huffman tree is by far the most likely state to be in between any two given bits, so you can start decoding with a guess that you are at the top of the tree and maybe get 40% accuracy. even more if your compressed format has reset points or illegal sequences and you lag the input a bit
00:29:03 <edwardk> johnw: but the beauty to me is that unlike, say an equivalent framework in c++, when i determine i don't need the speculated result, sparks don't act as garbage collection roots, so the speculated calculation can be garbage collected _while its running_ ;)
00:29:16 <edwardk> it literally will garbage collect the task
00:29:19 <johnw> that sounds very cool
00:29:36 <johnw> i'll have to keep that in mind; I've never had such a utility before
00:29:46 <shachaf> edwardk: Hah.
00:29:59 <mikeplus64> shachaf: *Main Foreign B> useAsGLString "hello" (\x -> B.packCString (castPtr x) >>= B.putStrLn)
00:30:01 <mikeplus64> hello
00:30:03 <mikeplus64> yippee
00:30:12 <edwardk> and since sparks are best effort, under load, they'll just get thrown away, so you can sprinkle spec calls into otherwise parallel code, and it won't steal resources from real worker threads, etc.
00:34:34 <shachaf> @where Twisol
00:34:34 <lambdabot> I know nothing about twisol.
00:34:40 <Twisol> ?
00:37:40 <mjrosenb> ok, slightly less silly question: is it likely that this code is blowing up because it is attempting to keep the entire unpacked bytestring in memory? http://hpaste.org/74576
00:39:43 <mjrosenb> alternately, is there any way of figuring out why that eats at least 2G of memory when the input bytstring is ~60 mb
00:40:02 <shachaf> mjrosenb: I think I'd expect that to keep the entire bytestring in memory until the SB.unpack list is fully evaluated.
00:40:03 <johnw> use -ddump-simpl
00:40:09 <johnw> see what the underlying code is doing
00:41:11 <shachaf> mjrosenb: Would it be easy to @paste a runnable file?
00:41:52 <johnw> mjrosenb: are you counting ASCII letter frequency?
00:42:18 <mjrosenb> johnw: i am counting Word8 frequency in a file
00:42:27 <Twisol> I'm really liking this new bidirectional support in pipes-2.3.0.
00:43:07 <Ralith> what's it for?
00:43:11 <johnw> so you're turning every byte x of the file into (x,())
00:43:21 <johnw> I think your 2G is a massive web of thunks
00:43:38 <johnw> you need accumArray to process the data set non-lazily
00:45:13 <mjrosenb> http://pastebin.mozilla.org/1815245
00:46:36 <mjrosenb> johnw: yes, well I was hoping that accumArray would pull off the head of the list, it'd make and evaluate a few thunks, then the head could be gc'd, then it would look at the second element, etc.
00:46:50 <mjrosenb> shachaf: ^
00:46:57 * hackagebot hsqml 0.1.1 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.1.1 (RobinKay)
00:46:59 * hackagebot dia-base 0.1.1.2 - An EDSL for teaching Haskell with diagrams - data types  http://hackage.haskell.org/package/dia-base-0.1.1.2 (PeterDivianszky)
00:47:07 <johnw> I'd try: assocs $!! accumArray
00:47:13 <mjrosenb> johnw: yeah, I didn't see a non-lazy variant of accumArray :(
00:47:19 <johnw> that may even be too far out
00:47:39 <johnw> http://www.hulver.com/scoop/story/2004/4/13/13058/9211 is related to your problem
00:47:53 <shachaf> mjrosenb: Ouch, that's a lot of memory usage.
00:48:02 <mjrosenb> johnw: what do I need to import for $!! ?
00:48:11 <johnw> Control.DeepSeq
00:48:14 <johnw> in the deepseq package
00:48:17 * shachaf suspects DeepSeq isn't the answer.
00:48:26 <mjrosenb> that does not sound like what I want
00:48:26 <shachaf> DeepSeq is often not what you want.
00:48:28 <johnw> shachaf: yeah, I have a suspicion about that too
00:48:41 <ezyang> I'm trying to understand: why is induction/coinduction usually presented with an algebra/coalgebra?
00:48:45 <Ralith> it's easy to test, though
00:48:47 <johnw> all the nasty thunks may already have been built by then by accumAray
00:49:04 <edwardk> ezyang: what would you rather use?
00:49:29 <ezyang> I dunno. But I feel like induction ought to be more fundamental than its presentation with algebras
00:50:50 <johnw> mjrosenb: try Data.Array.Unboxed
00:50:52 <ezyang> Huh, so initial F-algebras are *exactly* the induction principle? News to me!
00:50:54 <johnw> "A UArray will generally be more efficient (in terms of both time and space) than the equivalent Array with the same element type. However, UArray is strict in its elements - so don't use UArray if you require the non-strictness that Array provides."
00:51:26 <shachaf> mjrosenb: Let me see.
00:51:57 * hackagebot dia-functions 0.2.1.3 - An EDSL for teaching Haskell with diagrams - functions  http://hackage.haskell.org/package/dia-functions-0.2.1.3 (PeterDivianszky)
00:53:02 <shachaf> mjrosenb: All the "process" code is irrelevant, right?
00:55:55 <Nereid> ezyang: an F-algebra is precisely the data needed to do induction.
00:56:25 <Nereid> well, an F-algebra structure.
00:56:38 <mjrosenb> shachaf: yes.
00:56:55 <Nereid> and then the morphism from the initial algebra (= N) gives you the result of induction.
00:57:12 <lpvb> is repa mature and stable?
00:57:14 <Nereid> (for FX = 1 + X)
00:57:32 * mjrosenb changed it to UArray and it still oom'ed
01:01:36 <Hadaka> hello! I want to spawn a bunch of threads, wait until all of them finish and check if they finished without errors (exceptions), and then exit
01:01:57 * hackagebot activehs-base 0.3.0.2 - Basic definitions for activehs  http://hackage.haskell.org/package/activehs-base-0.3.0.2 (PeterDivianszky)
01:02:02 <Hadaka> is Control.Concurrent.Async cool for this, or are there nicer or more commonly used packages for this?
01:02:04 <johnw> mjrosenb: paste something we can run here at home
01:02:27 <johnw> Hadaka: what the type of the function you want to spawn into threads?
01:02:31 <mjrosenb> johnw: i did, did the mozilla.org paste not compile for you?
01:02:48 <johnw> no, I never saw the paste
01:02:49 <Hadaka> johnw: IO (), it's a thread that does a HTTP upload
01:02:57 <Hadaka> err, function, whatever
01:02:59 <johnw> Hadaka: I highly recommend using parallel-io
01:03:17 <johnw> you basically just change your mapM f xs to parallel $ map f xs
01:03:26 <johnw> and put a stopGlobalPool at the end of main
01:03:39 <johnw> and boom, it will use all available cores if you run with +RTS -N
01:03:48 <johnw> (make sure to compile with -threaded too)
01:04:09 <Hadaka> johnw: hmmh, right, thanks
01:04:16 <johnw> it handles exceptions well too
01:06:59 * hackagebot async 2.0.1.3 - Run IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/async-2.0.1.3 (SimonMarlow)
01:08:17 <Hadaka> hmmh... is the global thread pool limited somehow? I do need *all* of the threads running at the same time and not some default thread pool size only
01:08:39 <johnw> Hadaka: it's limited to the number of capabilities by default, I believe
01:08:54 <johnw> that's why I mentioned +RTS -N
01:09:17 * Ralith notes the distinction between concurrent I/O and concurrent computation
01:09:31 <johnw> you mean, between concurrency and parallelism? :)
01:09:47 * Ralith meant what he said.
01:09:58 <ciaranm> annoyingly, java books have taken to not making the distinction
01:10:23 <johnw> what's concurrent computation then?
01:10:57 <ciaranm> what your FPU does, when multiplications take different amounts of time to finish
01:11:11 <aleator> Anyone want to be critical towards my (tentative, underconstruction, ugly, silly) lecture-materials? http://functional-programming.it.jyu.fi/static/CourseMaterial2012.html
01:11:57 * hackagebot bamstats 0.3 - A program to extract various information from BAM alignmnet files.  http://hackage.haskell.org/package/bamstats-0.3 (KetilMalde)
01:12:09 * ciaranm searches for "monad" on aleator's page
01:12:19 <ciaranm> comparing >> to ; is wrong!
01:12:33 <shachaf> mjrosenb: If I do BS.foldl' it doesn't use crazy amounts of memory.
01:12:43 <shachaf> Hmm, I'm also using Data.Map instead of Array, though.
01:13:22 <mjrosenb> shachaf: i mean, it is a temporary
01:13:27 <johnw> since he wants to visit each byte in the BS, I think BS.foldl' is the right start
01:13:57 <shachaf> A temporary what?
01:14:13 <johnw> he doesn't need it after the function is done
01:14:20 <shachaf> johnw: Why should (foldl' f z . BS.unpack) be different from (BS.foldl' f z)?
01:14:33 <johnw> shachaf: let me check that
01:14:39 <shachaf> I mean, other than constant factors.
01:14:42 <johnw> shachaf: are you building with -O?
01:14:46 <shachaf> Yes.
01:14:50 <mjrosenb> a compiler temporary, its value never gets bound to anything, so it doesn't really matter what type it has, as long as every bound variable keeps its type
01:15:16 <shachaf> Anyway the program runs on 50MB in ~8 seconds this way without OOMing.
01:15:49 <merijn> johnw: I see you pinged me yesterday night?
01:16:11 <mjrosenb> shachaf: can you @paste it?
01:16:49 <shachaf> I mean just the byteCounts part of the program.
01:17:09 <johnw> merijn: to see if you'd gotten c2hsc working
01:18:05 <hpaste> “[author]” pasted “for mjrosenb” at http://hpaste.org/74578
01:18:34 <johnw> shachaf: well, in Core they call different functions to do the work.  I guess it's a question of whether BS.foldl' can be faster in some way, though you're right, I don't see why it should be off-hand
01:18:49 <johnw> but Haskell has a way of defeating my notions of what the machine is doing
01:19:04 <merijn> johnw: Yeah, I thought I already told you. c2hsc is working as of right now, but suffers from a similar problem as c2hs does. Language.C resolves types to their primitive type, which may not be (or in my case, definitely isn't) what people want
01:19:19 <johnw> merijn: so let's add translation types
01:19:31 <johnw> there's already a Data.Map that holds C->FFI type translations
01:19:35 <mjrosenb> shachaf: sure.
01:19:56 <johnw> shachaf: what is your max heap now?
01:19:59 <merijn> johnw: Because it results in my "struct Foo { intptr_t bar; }" becoming "data Foo = Foo { bar :: CLong }" as opposed to "data Foo = Foo { bar :: IntPtr }"
01:20:04 <aleator> ciaranm: Oh. Indeed it is. Where do I do that? Must be a leftover from some edit.
01:20:11 <johnw> merijn: this I can fix
01:20:15 <shachaf> mjrosenb: Anyway that doesn't explain why the thing you wrote wasn't working.
01:20:17 <merijn> johnw: I looked into the code a little, but wasn't really sure where to start so I figured I'd wait for you :p
01:20:32 <johnw> want me to just do it, or would you like to understand how?
01:20:59 <ciaranm> aleator: bullet point 4
01:21:15 <merijn> johnw: Both would be fine for me (I think the best approach would be to have a "strict C" flag that maintains the current behaviour and have the default translate to the "proper" FFI types)
01:21:38 <johnw> so, check out line 179
01:21:43 <johnw> the definition of TypeMap
01:21:56 <aleator> ciaranm: The short note on IO thing?
01:22:11 <johnw> I'm going to change the value to become a record that also holds a Bool to say whether the type definiton is an "override"
01:22:26 <johnw> that way, you can force type translations, and I'll ignore any typedefs I see in C code
01:22:30 <merijn> johnw: The mappings I can think of/encountered so far are size_t -> Foreign.C.CSize, intptr_t -> Foreign.Ptr.IntPtr and uintptr_t -> Foreign.Ptr.WordPtr
01:22:58 <johnw> yeah, I should probably "seed" the override map with those
01:23:03 <aleator> ciaranm: Hmm. Indeed. I hoped I could get away with saying that in the context of IO. But the statement where it appears is useless anyway, so I'll just drop that.
01:23:04 <johnw> one sec, adding overrides now
01:24:06 <Wheat> Hi, would someone be able to tell me what the term "local rewrites" means?
01:24:36 <merijn> johnw: btw, another thing I'd change is that it currently will only accept module names that have a prefix (i.e. leaving the -p/--prefix option off c2hsc will refuse to run)
01:24:46 <merijn> Wheat: Can you provide some more context?
01:25:09 <shachaf> ezyang: When are you going to be in the area?
01:25:46 <Wheat> "compiler optimisations can be represented as local rewrites"
01:26:01 <johnw> merijn: yes; how would you like it to behave?  I need to know where in module hierarchy to create your FFI modules
01:26:22 <Wheat> "on the expression tree representing the program"
01:26:23 <shachaf> Wheat: Presumably a rewrite which is local to some code rather than global to the entire program.
01:26:47 <Wheat> ok can we start with what is a rewrite?
01:26:57 <merijn> johnw: Right now some of my modules are in the top level (because I'm just writing some basic test stuff and don't feel like worrying about the hierarchy yet)
01:26:58 * hackagebot acid-state 0.7.3 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.3 (DavidHimmelstrup)
01:26:59 * hackagebot haskell-updater 1.2.0.7 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.7 (SergeiTrofimovich)
01:27:27 <merijn> johnw: In which case the prefix is basically empty, but that's not accepted
01:27:42 <shachaf> Wheat: Changing something to something else.
01:27:58 <shachaf> Things like "map f (map g x) = map (f.g) x" are rewrite rules in GHC.
01:28:10 <johnw> merijn: ok
01:28:23 <johnw> you realize they be root at ".Foo", right?
01:28:29 <Wheat> haha really? here i was thinking it was something complex
01:28:41 <Wheat> thanks for your help
01:29:26 <Wheat> so the "map (f.g) x" is the "rewritten part
01:29:34 <Wheat> in your example
01:29:45 <shachaf> Presumably.
01:29:59 <Wheat> cool
01:30:33 <Wheat> but isn't it just how we are defining map to work?
01:30:46 <shachaf> @src map
01:30:46 <lambdabot> map _ []     = []
01:30:46 <lambdabot> map f (x:xs) = f x : map f xs
01:30:53 <shachaf> That's the definition of map.
01:31:20 <shachaf> An optimization of the program "map (+1) (map (*2) xs)" is "map ((+1) . (*2)) xs"
01:31:23 <Wheat> oh im sorry i mean "f"
01:31:45 <merijn> johnw: I haven't actually tried that. I would personally just say have the prefix be of type Maybe String and then name the module "name module = case prefix of Just s -> s ++ "." ++ module; Nothing -> module"
01:31:58 * hackagebot acid-state 0.7.4 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.4 (DavidHimmelstrup)
01:33:05 <merijn> johnw: btw, while I'm bugging you with minor details anyway...it produces an include for #include <git2.h>
01:33:18 <merijn> And I dunno where that is coming from/required for
01:33:58 <Wheat> in your example "map f (map g x) = map (f.g) x" aren't we defining how f wil work over the rest of the function? its just sounds like we are calling the same thing a different name?
01:34:11 <shachaf> Function?
01:34:14 <shachaf> Defining?
01:34:20 <merijn> Wheat: It is an optimisation in the compiler
01:34:51 <merijn> Wheat: GHC reorders your code so that "map f (map g x)" is replaced with "map (f.g) x", because that is more efficient (maps only once)
01:35:13 <merijn> Wheat: This has nothing to do anymore with actual source or things like function definitions. They're AST transformations
01:36:29 <Wheat> umm ok well i got to go ill figure it out, thanks though
01:36:51 <johnw> merijn: oops!  fixed that :)
01:38:02 <johnw> ok, overrides are working
01:38:29 <johnw> merijn: now I need an interface for them
01:38:44 <johnw> reading names in from a file is probably best
01:42:03 <merijn> johnw: Yeah, I would say either from a file or maybe inline pragma's? Although the latter is probably a lot more work to implement
01:42:54 <johnw> and the person may not have the freedom to change code
01:44:18 <merijn> johnw: That to
01:49:19 <merijn> Hmm, I'm getting this message when I run ghc-pkg list: "WARNING: cache is out of date: (dir here) use 'ghc-pkg recache' to fix."
01:49:55 <merijn> But running ghc-pkg recache doesn't seem to fix it? (I have to run it as sudo and the cache it complains about is in my home dir, maybe that's the problem?)
01:50:31 <Rc43> Hi, guys.
01:51:13 <Rc43> I have a problem with BNFC. (Never used before happy/alex/lex/etc.)
01:51:27 <Rc43> I just trying to compile example from docs: http://bnfc.digitalgrammars.com/doc/tutorial/bnfc-tutorial.html
01:51:37 <Rc43> (look at Calc.cf)
01:52:13 <Rc43> `make' fails with requirement about `alexGetByte'. I googled and found that I can use "%wrapper "basic""
01:52:39 <Rc43> But looking at LexCalc.x (generated by bnfc) I see that there are already some of definitions of wrapper
01:52:39 <johnw> IO is a monoid, right?
01:52:53 <Rc43> But it lacks of "alexGetByte".
01:52:57 <shachaf> johnw: A monoid?
01:53:09 <shachaf> It's not even the right kind to be a monoid!
01:53:15 <johnw> duh
01:53:17 <johnw> never mind
01:53:22 <johnw> it's getting late
01:53:38 <shachaf> It's a monoid in the usual monadic way.
01:53:52 <johnw> i was thinking of (>>) as (<>)
01:54:01 <johnw> but it neither has mempty, nor is it associative
01:54:08 <johnw> or is it associative?
01:54:12 <johnw> i'm going to stop talking now
01:54:13 <shachaf> It's associative.
01:54:14 <Nereid> yes it is
01:54:20 <shachaf> And (return ()) can be its mempty, sort of.
01:54:31 <Nereid> no, the type tells you right away that it can't have one.
01:54:38 <shachaf> If you're just talking about effects, at least.
01:55:08 <Nereid> then return anything will do.
01:55:11 <Rc43> Guys, anybody used BNFC?
01:55:46 <johnw> bleh, StateT is neither Foldable nor a Monoid
01:55:46 <shachaf> Sure.
01:56:10 <shachaf> For any monoid w, (w,) is a monad where (w,_) >> (w',x) = (w <> w',x)
01:56:33 <johnw> i can make it such, it just doesn't come that way out of the box
01:56:40 <johnw> (or so the type errors would have me think)
01:56:50 <shachaf> You can make it such?
01:56:55 <johnw> make an instance?
01:57:06 <johnw> L.foldr (>>) (return ()) looks like it will do what I need
01:57:14 <shachaf> @src sequence
01:57:14 <lambdabot> sequence []     = return []
01:57:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:57:14 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
01:57:22 <shachaf> @src sequence_
01:57:23 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
01:57:34 <johnw> and so that fold . map = mapM
01:57:42 <johnw> which is what I had, which didn't work, so back to drawing board
01:57:44 <Rc43> I also tried to install 'alex < 3' with cabal; but its compilation failed.
01:57:47 <shachaf> That is indeed the definition of mapM.
01:57:49 <shachaf> @src mapM
01:57:49 <lambdabot> mapM f as = sequence (map f as)
01:58:49 <merijn> johnw: On the upside the version I just grabbed from GitHub works (modulo some small changes)
01:58:59 <johnw> oh, I got it!
01:59:18 <shachaf> mapM_, I mean.
01:59:27 <johnw> i mean, I figured out what I had to do
02:00:05 <johnw> I have an ugly return type in one function: IO (State a ())
02:00:14 <johnw> for which a is a monad
02:00:30 <johnw> and I was wondering how to return back the packaged up monadic value, even though the "value" of the State monad is ()
02:00:38 <johnw> I just needed monad-value >> return ()
02:01:02 <merijn> johnw: The two things that I had to fix by hand were 1) generated .hsc file doesn't #include the header file it is generated from 2) the binding-DSL complains about missing imports for IntPtr/WordPtr/etc unless you explicitly import Foreign.Ptr
02:01:04 * shachaf isn't sure what you mean.
02:01:26 <johnw> shachaf: it's hard to explain, I'll show you in a sec, shachaf
02:01:27 <shachaf> (State s ()) is approximately (s -> s)
02:01:48 <johnw> merijn: can you make a pull request?
02:08:14 <johnw> :t void
02:08:16 <lambdabot> Not in scope: `void'
02:08:33 <johnw> huh
02:08:40 <merijn> void :: Functor f => f a -> f ()
02:08:42 <johnw> void x = x >> return ()
02:08:47 <johnw> just what I needed
02:08:53 <johnw> thank you, hlint
02:08:55 <shachaf> Except Functor.
02:09:30 <johnw> Functor is ok here
02:09:38 <shachaf> Functor is much better.
02:10:08 <johnw> ahh, intercalate " " = unwords
02:10:10 <johnw> should have thought of that
02:10:14 <johnw> hlint is great for learning the Plerude
02:10:15 <johnw> Prelude
02:10:48 <shachaf> intercalate "\n" /= unlines
02:11:02 <johnw> yeah, because there's be a trailing newline missing
02:12:01 <johnw> i'm actually a bit shocked that this worked
02:12:24 <johnw> it represents a huge leap forward in my understanding of type errors
02:12:31 <johnw> like, *huge*
02:13:00 <johnw> shachaf: here's the code I was talking about: https://github.com/jwiegley/c2hsc/blob/master/Main.hs#L101
02:13:07 <johnw> at line 117, the defineTypeOverrides function
02:13:34 <johnw> it's in IO because it reads from a file, but it has to return my state monad with the provided type definitions recorded in the state map
02:14:05 <johnw> you see how in the let types = ... , types is now an Output [..], not an Output ()
02:14:17 <johnw> I wasnt sure how to turn it into an Output () without losing the state
02:14:21 <shachaf> "return my state monad" :-(
02:14:26 <johnw> that's what return (void types) does
02:14:40 <johnw> I use "monad" with a lower case to mean my monadic value
02:14:56 <johnw> my final Output ()
02:15:02 <johnw> what would you call that?
02:15:07 <merijn> Wouldn't it be easier to use "StateT a IO"?
02:15:09 <johnw> "a value in the Output monad"?
02:15:19 <johnw> merijn: I don't need IO in most of the code
02:15:27 * shachaf can't quite figure out what that's doing.
02:15:39 <johnw> shachaf: can't figure out which?
02:15:43 <shachaf> I think you might want to split your foldr into a sequence_ and something else.
02:16:12 <johnw> the foldr is going over the lines in the file, of the form "a -> b", and recording the fact that a means b in the type map within the Output state
02:17:11 <shachaf> Output () is approximately (HscOutput -> HscOutput)
02:17:29 <shachaf> Are you sure State isn't making your life more complicated here?
02:17:30 <johnw> ah, what you said above
02:17:45 <johnw> shachaf: in that function?  Yes, it's making life quite complicated
02:18:02 <johnw> i see what you're saying
02:18:08 <johnw> just return an HscOutput
02:18:12 <johnw> and use that as an initial state
02:18:18 <merijn> johnw: Sent you a pull request
02:18:23 <johnw> merijn: great!
02:18:38 <blackh> So is Hackage down?
02:18:39 <shachaf> Instead of this mapM (uncurry ...) thing with a state, you can just fold a function :: HscOutput -> HscOutput
02:18:44 <shachaf> Since all you care about is the effects.
02:18:51 <johnw> yeah, I didn't even think of that at all
02:18:53 <shachaf> blackh: hackage.haskell.org:80 is up for me.
02:18:55 <johnw> thanks, shachaf
02:19:00 <shachaf> johnw: Also there are other things you can do.
02:19:19 <johnw> merijn: merged
02:19:34 <merijn> johnw: On the upside it now does exactly what I need, now I just need to figure out how to get cabal to call c2hsc before building :)
02:19:39 <shachaf> johnw: E.g. the things in http://slbkbs.org/johnw.hs
02:19:49 <kaos`> Hi - I have a process that keeps a file open as a handle - is there anyway of detecting if a user deletes the file?
02:20:08 <johnw> ah, yes
02:20:12 <shachaf> johnw: And also a few more things.
02:20:17 <johnw> my imperative background comes shining through
02:20:22 <blackh> shachaf: Can you ping it? I can't contact it in any way.
02:20:41 <shachaf> blackh: Can't ping it but I can GET it.
02:20:53 <johnw> I can httping http://www.haskell.org/hackage just fine
02:20:57 <johnw> latency is around 270ms
02:21:01 <johnw> (normal)
02:21:13 <johnw> I don't think it responds to ICMP
02:21:35 <johnw> yes
02:21:39 <johnw> i cannot ping it, but I can httping it
02:21:44 <johnw> (http://hackage.haskell.org)
02:21:46 <shachaf> johnw: Your foldr is just a map + sequence_
02:22:00 <shachaf> Maybe with a reverse too.
02:22:22 <shachaf> Anyway I think if you're passing State values around like that you might be best off not using State at all for some of it.
02:22:56 <johnw> shachaf: your where is no in scope for the first definition
02:23:16 <shachaf> johnw: Oh, right.
02:23:24 <shachaf> Anyway the point stands.
02:23:57 <shachaf> Though the code doesn't. :-)
02:23:58 <mgsloan> From GHC.Generics:
02:23:58 <mgsloan> newtype M1 i c f p = M1 { unM1 :: f p }
02:24:11 <johnw> you weren't being point-free?
02:24:15 <mgsloan> lol @ polymorphic variable names
02:25:41 <shachaf> johnw: foldr (.) id is your friend, by the way.
02:25:47 <blackh> shachaf, johnw: Thanks for your help there. It seems I can reach it quite happily through a USA-based server but not directly from New Zealand. How annoying!
02:26:47 <johnw> shachaf: what does that do?
02:26:50 <shachaf> I'm afraid you're a casualty of the kiwifruit boycott.
02:26:54 <johnw> :t foldr (.) id
02:26:55 <lambdabot> forall b. [b -> b] -> b -> b
02:27:12 <shachaf> > foldr (.) id [f,g] x
02:27:14 <lambdabot>   f (g x)
02:27:21 <johnw> huh
02:27:29 <johnw> oh, duh
02:27:40 <shachaf> It does sequence_ for a bunch of State s a values. :-)
02:27:50 <shachaf> Except without all the State nonsense.
02:27:51 <johnw> I changed it to:
02:27:57 <johnw> https://gist.github.com/3697190
02:28:04 <johnw> which is indeed simpler
02:28:28 <shachaf> @ty mapM_
02:28:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:28:46 <shachaf> Wait, that's not the same.
02:28:47 <johnw> but that will return IO ()
02:28:58 <shachaf> Huh?
02:29:12 <johnw> were you thinking return $ mapM_ instead of return $ void $ mapM ?
02:29:33 <shachaf> Yes.
02:29:46 <shachaf> johnw: You forgot to (>> void types) or something.
02:29:58 * shachaf would really recommend trying it the non-State way, though.
02:30:11 <johnw> actually, mapM_ works quite well
02:30:13 <johnw> return $ mapM_
02:30:20 <johnw> == return $ void $ mapM
02:30:25 <shachaf> Except better.
02:30:33 <johnw> how better?
02:30:47 <shachaf> Well, it's probably only more efficient or something.
02:30:58 <shachaf> The effect will be the same.
02:32:06 <shachaf> johnw: I think a lot of the functions in that file would be improved by being actual functions rather than Outputs.
02:32:06 <johnw> now with shachaf effects: https://github.com/jwiegley/c2hsc/blob/master/Main.hs#L117
02:32:31 <shachaf> lookupType :: String -> Output (Maybe Typedef)
02:32:31 <johnw> really?  I need access to the typedef map at the deepest levels of the recursion, though
02:32:45 <TheBrayn> hi
02:32:48 <johnw> pass it around as an argument was just too gross
02:33:01 <shachaf> Compare to lookupType :: String -> HscOutput -> Maybe Typedef
02:33:15 <johnw> but then the caller of lookupType has to receive an HscOutput
02:33:19 <shachaf> johnw: Maybe Output makes sense for some of the functions but that doesn't mean it makes sense for all of them.
02:33:27 <shachaf> Right, but the caller already has one anyway.
02:33:28 <johnw> oh
02:33:35 <shachaf> Your code is full of "get"s that could just be arguments.
02:33:42 <johnw> I was modelling lookupType as a fancy "get"
02:34:01 <johnw> doesn't that just move the gets elsewhere, and result in more of them?
02:34:04 <shachaf> Well, I don't know exactly, I haven't looked at the code.
02:34:20 <yorkc> join emberjs
02:34:21 <TheBrayn> Why does "let removeLowerCase st = [ c | c <- st, c `elem` ' ':['A'..'Z']]" work but "let removeLowerCase st = [ c | c <- st, elem c  ' ':['A'..'Z']]" does not?
02:34:44 <johnw> I'm using the state monad to accumulate the lines that go into the .hsc and .hsc.helper.c files, plus maintain a typedef mapping that will be updated as we parse by typedefs in the C code
02:34:53 <shachaf> johnw: I think you should try converting a few of these to this style and see how it goes.
02:35:11 <shachaf> Also you should be aware of modify :: (s -> s) -> State s ()
02:35:27 <johnw> ah, I haven't used modify yet
02:35:29 <shachaf> TheBrayn: What does it mean when something doesn't work?
02:35:36 <johnw> this was first program that used State in earnest
02:36:05 <TheBrayn> http://codepad.org/5LLti0tp <- this errormessage
02:36:09 <TheBrayn> but I don't know what it means
02:36:22 <shachaf> TheBrayn: That's not the code you wrote.
02:36:26 <johnw> TheBrayn: the latter one is parsing "elem c ' '" as the head of the list
02:36:51 <shachaf> elem(c ' ':...) is passing a single nonsensical argument to elem.
02:36:51 <TheBrayn> shachaf: yeah, I copied the wrong line
02:37:13 <TheBrayn> I was trying some stuff since I'm trying to learn haskell
02:37:34 <TheBrayn> johnw: thanks for the answer
02:38:06 <johnw> TheBrayn: yeah, function application is always first
02:38:13 <johnw> I get bit by that too
02:40:32 <shachaf> johnw: Is your code supposed to compile with 7.6?
02:40:40 <shachaf> Well, HStringTemplate is the thing that isn't compiling for me.
02:40:59 <johnw> shachaf: I haven't tried yet
02:41:15 <shachaf> Blugh.
02:41:18 <johnw> I think I had problems with HStringTemplate too.  I'm still in the midst of trying to replicate my world in 7.6.1 in my VM
02:41:29 <shachaf> Well, if I can't type-check your code, I can't show you what I mean. :-)
02:41:55 <johnw> wow, you moved up to 7.6.1 already?
02:42:09 <shachaf> Sure.
02:42:26 <johnw> i don't like that cabal-install won't build
02:42:29 <shachaf> Don't stand in the way of progress, johnw!
02:42:32 <shachaf> It won't?
02:42:37 <shachaf> I wouldn't know. I'm still using my old one.
02:43:16 <shachaf> johnw: ...Output [()]?
02:43:19 <johnw> yeah, exactly
02:43:30 <johnw> that was to quite the type checker, I'm not proud of it
02:43:39 <shachaf> Just use another mapM_
02:43:51 <shachaf> GHC has quite the type checker, indeed.
02:44:03 <johnw> oh, yeah, duh
02:45:42 <blackh> My problems contacting hackage.haskell.org have turned out to be a DNS problem. There seems to be a bad A record floating around (69.30.63.204).
02:46:09 <shachaf> blackh: Hackage's IP changed a week or two ago.
02:48:23 <johnw> shachaf: you're a good code reviewer
02:48:41 <johnw> I've got more, if you ever get bored :)
02:52:07 <shachaf> You said you were using lenses here, didn't you?
02:52:14 <johnw> no, in sizes
02:52:23 <johnw> https://github.com/jwiegley/sizes/blob/master/Main.hs
02:52:30 * edwardk fights the urge to reply with '?'
02:52:43 <Enigmagic> ?
02:52:44 <shachaf> edwardk: johnw isn't using lenses like he should be.
02:53:01 * edwardk reminds himself that he should get some sleep
02:53:07 * shachaf wonders how many hilights edwardk has.
02:53:16 <johnw> how should I be using lenses?
02:53:24 <edwardk> shachaf: he has some in there
02:53:39 <edwardk> shachaf: he just did't lens the SizesOpts stuff
02:53:51 <johnw> ah, no
02:54:02 <johnw> my use of CmdArgs was copied over from years ago
02:54:04 <shachaf> edwardk: I don't mean sizes.
02:54:07 <johnw> I didn't even think to modernize it
02:54:09 <shachaf> The other thing.
02:54:17 <johnw> in c2hsc?
02:54:19 <edwardk> but lensing that doesn't help until i bother to write a lensed command-line parser ;)
02:54:21 <johnw> i didn't even know lenses then :)
02:54:59 <shachaf> Yes, the thing full of State.
02:55:06 <johnw> chock full o' state
02:55:09 <johnw> that was my first name choice
02:55:15 <edwardk> i've actually been playing with a design for monoidal+lensed configurations that looks pretty nice so far
02:55:45 <edwardk> basically its a 'representable configuration'
02:56:59 * hackagebot lifter 0.1 - A boulderdash-like game and solution validator  http://hackage.haskell.org/package/lifter-0.1 (EdwinBrady)
02:57:11 <johnw> edAwake .~ False $ edwardk
02:58:06 <edwardk> the problem is that edAwake is a traversal. edAwake = ignored -- so that has no effect.
02:58:13 <johnw> lol
02:58:22 <johnw> edAwake .~~~ False $ edwardk
02:58:26 <johnw> there, I forced it
02:58:47 <Enigmagic> is that drool?
02:58:57 <johnw> you could said that you're just being non-strict in your evaluation
02:59:03 <edwardk> that reminds me i need to add the monadic strict getters and setters, etc.
02:59:17 <edwardk> er monadic strict setter actions at least
03:00:03 <edwardk> no idea what symbols to use for it really
03:00:15 <johnw> >>=~
03:00:24 <edwardk> %!~   or something
03:00:38 <johnw> oh, strictness
03:00:43 <johnw> yeah, %!~
03:00:49 <johnw> or %~!
03:00:53 <edwardk> yeah, using the monad
03:01:08 <edwardk> kinda thinking i'll want to keep it to the left of the ~ or =
03:03:44 <johnw> strange, cabal install created some directories in my /tmp, and now I can't rm -fr them
03:04:04 <johnw> they are empty, but the system says "Directory not empty"
03:05:01 * shachaf can't figure out this code.
03:05:27 <bartavelle> why are those XML libraries so complicated ?
03:05:46 <bartavelle> how do I do this with HXT ?   (getVal "port" `orElse` returnA "")
03:05:52 <bartavelle> returnA is not the proper function here
03:05:59 <bartavelle> I'd like something like "pure" or "return" probably
03:06:12 * bartavelle is brute forcing the arrows syntax
03:06:12 <johnw> returnA -< "" ?
03:06:33 <bartavelle> p <- (getVal "port" `orElse` returnA -< "")  -< ent
03:06:39 <bartavelle> that's my full "proc" lune
03:06:40 <johnw> oh
03:06:40 <bartavelle> line
03:06:42 <johnw> i see
03:06:52 <Saizan> arr (const "")
03:07:08 <johnw> yeah, that
03:07:10 <bartavelle> thanks
03:07:24 <Saizan> maybe there's a constA somewhere
03:07:31 <ion> @hoogle constA
03:07:31 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Constant :: Src
03:07:32 <lambdabot> Data.Functor.Constant Constant :: a -> Constant a b
03:07:32 <lambdabot> Data.Functor.Constant newtype Constant a b
03:09:27 <shachaf> johnw: Does applyDeclrs actually modify the state?
03:10:16 <johnw> no, but it ends up calling typeName, which must access it
03:10:35 <johnw> oh, maybe not
03:10:44 <johnw> maybe it just applies the declarators
03:10:49 <johnw> and the base type name is already known
03:11:06 <shachaf> derDeclrTypeName' uses it only for effects.
03:11:06 <johnw> all that applicative stuff in there is pretty gross, isn't it
03:11:11 <shachaf> Does it have effects?
03:11:26 <shachaf> Blah, another kernel failure. :-(
03:11:28 <johnw> no
03:11:41 <johnw> only appendHsc, appendHelper, and defineType, have effects
03:11:48 <shachaf> So that line in derDeblah is redundant?
03:12:09 <johnw> the call to apply?
03:12:14 <johnw> it's returning a string
03:12:23 <johnw> wrapped up with the (unchanged) state
03:12:28 <shachaf> Oh, wait.
03:12:32 <shachaf> That's the last line of the do block.
03:12:34 <shachaf> Never mind.
03:12:49 <johnw> but I think you're right in that applyDeclrs doesn't need to access the state at all
03:13:01 <johnw> it just needs to provide a new string based on nm
03:13:27 <johnw> this code is hard to read in part because language-c ASTs are hard to read
03:13:43 <bartavelle> ok, so this XHT arrow (atTag "any" >>> isElem >>> arr (const Any)) always returns Any, some others functions "stop" the arrow if they don't match
03:13:53 <bartavelle> is there something simpler to parse XML ?
03:13:58 <johnw> i like this code the least of what I've written lately
03:14:07 <bartavelle> I don't have time to learn all there is about arrows and wrap my mind around
03:14:39 <shachaf> This code is pretty low-level in the Perlis sense.
03:14:40 <bartavelle> I also tried haXml but it seems I have no clue how do construct a CFilter that does what I expect
03:14:43 <johnw> yeah
03:14:50 <johnw> it's really a big hack
03:14:56 <merijn> Is there a way to figure out where libraries/header files are being installed?
03:14:57 <shachaf> Haskell code tends to be "low-level" in that sense in a very different way from other code.
03:15:03 <johnw> the quickest path to getting a bunch of .hsc files, which I now have
03:15:45 <typoclass> merijn: for me the all-purpose universal figuring-out tool is strace
03:15:50 <johnw> man, I'm backing up 1.2 million files to crashplan
03:16:00 <shachaf> Ayway the State thing isn't helping with reading it.
03:16:03 <shachaf> You never know what does what.
03:16:08 <johnw> it's not the data size that gets me, it's the file count.  It takes 2 days just to scan them all
03:16:14 <johnw> shachaf: true, very true
03:16:28 <johnw> shachaf: I'll remove applyDeclrs from Output, and see wherever else I can shed it
03:16:40 <johnw> but another day, now is sleep time
03:16:49 <merijn> (Specifically, bindings-DSL installs header files in ~/Library/Haskell/ghc-7.4.1/lib/bindings-DSL-1.0.15/lib/include, which makes it almost impossible to give my code depending on bindings-DSL the proper include path...
03:16:50 <johnw> thanks for all your help, shachaf, edwardk, everyone
03:17:04 <Saizan> bartavelle: http://www.haskell.org/hoogle/?hoogle=xml
03:17:07 <shachaf> Oh, these are mutually recursive functions.
03:17:15 <johnw> shachaf: yeah
03:18:05 <johnw> but I don't think applyDeclrs can get back down to typeName
03:18:39 <johnw> oops, sufQualsToString is just plain wrong
03:19:20 <johnw> oh, I'm wrong
03:19:32 <johnw> applyDeclrs -> cdeclTypeName -> derDeclrTypeName -> typeName
03:19:33 <johnw> :(
03:20:11 <johnw> thanks for even trying to read this
03:22:23 <timthelion> I have a bunch of functions that return (SourceID, [SourceID] ->IO ()) and another function, "doModifications" that takes a list of such values and "evaluates" them.  It seems like a good place to make a monad, just so my users could write doModification $ do {a;b;c} rather than doModification $ a:b:c:[]...  Is that a reasonable thought?
03:22:27 <shachaf> declSpecTypeName' cStyle = flip (derDeclrTypeName' cStyle) []
03:23:15 <tdammers> any news on the 'trusted hackage' front?
03:23:25 <merijn_> Isn't cabal supposed to call Setup.hs?
03:23:57 <typoclass> merijn_: depends, there's "Simple" mode and "Custom" mode
03:25:06 <typoclass> (you're right, it can trip you up)
03:25:06 <Saizan> merijn_: unless you have build-type: Simple
03:25:35 <Saizan> merijn_: use build-type: Custom
03:25:40 <merijn_> Ah, right
03:26:40 <merijn_> Is there more elaborate UserHooks documentation beyonds what I found at: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/Cabal/Distribution-Simple-UserHooks.html ?
03:27:34 <merijn_> The hooks all return HookedBuildInfo and what not, but with no explanation of what it does
03:28:02 <merijn_> All I want to do is call an executable at the right moment, but I can't for the life of me manage to find out how to tell that to cabal
03:28:48 <Saizan> when is the moment?
03:29:11 <merijn> preBuild
03:31:18 <Saizan> you could let the default implementation of preBuild return the HookedBuildInfo, unless you think it's relevant to you
03:31:31 <typoclass> merijn: maybe return emptyHookedBuildInfo if you don't want to change anything?
03:32:00 * hackagebot sizes 1.0.2 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-1.0.2 (JohnWiegley)
03:32:36 <merijn> typoclass: I tried that, but that aborts the compile
03:32:54 <typoclass> merijn: oh :( then i concur with saizan
03:33:00 <merijn> typoclass: Right now I'm trying to use simpleUserHooks and wrap preBuild with something that passes on the result, I guess
03:33:14 <merijn> ok, that seems to work-ish
03:35:36 <Saizan> btw, are you using Cabal-1.8.0.2? because that's the docs' version
03:36:13 <Saizan> (the UserHooks' API is stable, but still)
03:36:46 <merijn> Saizan: I think I'm using 1.10 or something, those were just the first Google hit for documentation
03:37:56 * typoclass will give a million billions to whoever makes google just go to the current documentation and ignore all the old stuff
03:41:01 <timthelion> typoclass: you should send your resume to Bing.  They are very interested in people who know how to make concrete critisizm of the king of search.
03:41:54 <typoclass> timthelion: er, i was being tongue-in-cheeck. i think it'd be just a matter of changing a few lines in hackage's robots.txt file
03:42:01 * hackagebot doctest 0.9.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.0 (SimonHengel)
03:43:12 <timthelion> Too many G_D D_MN_D simons!!!
03:43:30 <osfameron> s_m_ns!
03:44:19 * timthelion thinks we need a new plural form for the Simons of the Haskell comunity.  Perhaps, one Simon, two Sime...
03:44:22 <ion> T__ m__ ___ ______ ________
03:44:41 <ion> ___’_ ____ ____ ___ ____ ___ __!
03:44:49 <ion> __________ _____.
03:45:04 <Adeon> are you certain you used enough _s
03:45:18 <ion> Well, i wouldn’t want to use any words that may offend someone by accident.
03:45:27 <timthelion> ion: Reminds me of http://wondermark.com/257/
03:45:57 <timthelion> Warning, politically incorrect comic.
03:46:43 <osfameron> mad libs?
03:47:37 <timthelion> osfameron: https://en.wikipedia.org/wiki/Mad_Libs
03:48:25 <osfameron> ah
03:49:43 <timthelion> osfameron: they are little booklets sold in America which have stories in them.  Rather than being complete, the stories have blanks which read "_noun_" or "_adjective_" one person reads the word class aloud. When person1 says "noun", person2 must say a noun.  And thus the stories are humorously filled in.
03:54:21 <timthelion> osfameron: My dyslexia tells me, that you are a charitable robot: https://en.wikipedia.org/wiki/Oxfam
03:55:07 * osfameron wonders if timdelion is related to dandelion ;-)
03:55:18 <ion> 0xfam
03:55:27 <ion> > 0xfam
03:55:28 <lambdabot>   250
03:56:07 <timthelion> osfameron: No, I am not a feline gansta named Dan.
04:05:48 <xz> what's the nice way to say \ x y -> f x = f y ?
04:06:05 <shachaf> Tht's a syntax error.
04:06:13 <shachaf> But if you mean (==), you can use Data.Function.on
04:06:14 <xz> but you know what I mean right?
04:06:17 <typoclass> xz: what do you want the function to do?
04:06:19 <shachaf> ((==) `on` f)
04:06:23 <xz> shachaf: thanks :)
04:06:54 <shachaf> I might know what you mean but that doesn't mean you shouldn't say what you mean. :-)
04:07:35 <xz> also, is there a nice way to simultaneously group the elements of a list and pair them with the thing you're grouping by?
04:08:21 <xz> [x0,y1,y0,x2] -> [(0,[x0,y0]), (1,[y1]), (2,[x2])]
04:08:36 <xz> (presuming extracting the 0 from x0 is easy)
04:09:09 <xz> I was going to use groupBy, but then I have to recalculate the keys to get the pairs
04:09:41 <shachaf> You could groupBy ((==) `on` fst) . map foo
04:09:49 <shachaf> Where foo x0 = (0,x0)
04:09:56 <shachaf> Er, and then remove the keys afterwards, I guess.
04:10:06 <shachaf> Not sure how much that saves you.
04:10:12 <typoclass> xz: i'd try something like "groupBy (...) $ zip (map makekey xs) xs"
04:10:50 <shachaf> zip (map f xs) xs = map (\x -> (f x,x)) xs
04:12:17 <typoclass> at any rate, i keep coming across that function. i think there'd be a place for it in the standard library. "annot x f = (x, f x)"
04:13:18 <mm_freak> > groupBy ((==) `on` generalCategory) "Insanely brilliant super-stuff!!"
04:13:19 <lambdabot>   ["I","nsanely"," ","brilliant"," ","super","-","stuff","!!"]
04:13:31 <ion> witchcraft
04:14:20 <typoclass> ah right -- group and groupBy consider only successive elements, right
04:14:24 <ion> > (transpose . groupBy ((==) `on` generalCategory)) "Insanely brilliant super-stuff!!"
04:14:26 <lambdabot>   ["In b s-s!","srut!","aipu","nlef","elrf","li","ya","n","t"]
04:14:51 <typoclass> xz: you might want to put that all into a Data.Map and then do Data.Map.toList
04:35:05 <Z`> hi people. what does the <- operator do inside a do block ?
04:35:40 <hpc> Z`: it's not an operator; it's part of the syntax
04:36:07 <hpc> play around a bit with @undo in PM to see what do-notation is really doing
04:36:11 <merijn> There's no way to "close" the open world assumption for a given typeclass, right?
04:36:16 <hpc> @undo do {x <- m; f x}
04:36:17 <lambdabot> m >>= \ x -> f x
04:36:21 <Z`> ah ok, because I didn't remember it to be in the Monad class
04:38:57 <Z`> what if it is just x <- m; or is this disallowed ?
04:39:44 <hpc> @undo do {x <- m}
04:39:45 <lambdabot>  Parse error at "}" (column 11)
04:39:56 <hpc> > do {x <- undefined}
04:39:58 <lambdabot>   <no location info>:
04:39:58 <lambdabot>      The last statement in a 'do' construct must be an ...
04:39:59 <Z`> thanks :)
04:40:03 <hpc> :P
04:40:16 <Z`> everything starting with @ is processed by the bot ?
04:45:15 <typoclass> Z`: yes, exactly. you can play around in a private chat window
04:45:35 <Z`> yep, I tried it in private. thanks!
04:47:02 * hackagebot acid-state 0.7.5 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.5 (DavidHimmelstrup)
05:00:35 <lpvb> I'm trying to add a dependency to a project but it keeps saying Parse of field 'build-depends' failed
05:00:45 <lpvb> I added socks >= 0.4.2
05:00:53 <hpc> comma?
05:01:05 <lpvb> ah that was it
05:01:06 <lpvb> thanks
05:01:32 <lpvb> the small things go unnoticed
05:06:55 <Z`> I have a function processLine :: String -> String
05:07:16 <Z`> I'd like to break that string into a list of strings. This works in ghci (as I;ve been told here):
05:07:22 <Z`> let [x,y,z] = words s in (x,y,z)
05:07:37 <Z`> but If I try to put it inside the function, it fails
05:08:01 <Z`> because whatever I type in the next line, it thinks that I'm applying (x,y,z) into whatever follows
05:09:32 <Botje> Z`: well, the (x,y,z) is just an example of a body.
05:09:50 <Botje> just replace that part by the actual stuff you want to do, now that you have x,y,z in scope
05:10:01 <Z`> oh. ok
05:10:07 <Z`> thanks Botje
05:11:03 <hpc> > let [x,y,z] = words "one two three" in x
05:11:05 <lambdabot>   "one"
05:11:19 <Z`> yep got it. silly question
05:14:54 <Z`> alright. So what if I'd like processLine to return some string or nothing at all. Would I turn it onto:
05:15:00 <Z`> processLine :: String -> Maybe String?
05:15:40 <lpvb> Z`: ys
05:15:42 <lpvb> yes
05:16:36 <lpvb> > break (==':') "uri:port"
05:16:37 <lambdabot>   ("uri",":port")
05:16:44 <lpvb> is that the best way to go about that?
05:16:46 <Z`> alright! 1 of 2 errors gone
05:17:52 <Botje> lpvb: for smallish things, yes
05:17:52 <Z`> So I have this function that returns Maybe String, and I'd like to teach unlines to operate on it. What do I need to do ?
05:18:14 <Botje> Z`: pattern match on Nothing, and pattern match on Just lines
05:18:22 <lpvb> Z`: fmap unlines string
05:18:45 <Z`> thanks will try both
05:18:48 <lpvb> > fmap unlines (Just "line1\nline2\nline3")
05:18:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:18:50 <lambdabot>         against inferred ty...
05:18:55 <lpvb> hmm
05:19:26 <Mon_Ouie> > fmap lines (Just "line1\nline2\nline3")
05:19:27 <lambdabot>   Just ["line1","line2","line3"]
05:19:36 <lpvb> ah
05:20:01 <lpvb> > lines <$> (Just "1\n2\n3")
05:20:03 <lambdabot>   Just ["1","2","3"]
05:21:13 <lpvb> > (\u p -> (u, read $ tail p :: Int)) . break (==':') $ "uri:1337"
05:21:15 <lambdabot>   Overlapping instances for GHC.Show.Show
05:21:15 <lambdabot>                              ([GHC....
05:23:02 <fmap> > second (\p -> read $ tail p :: Int) . break (==':') $ "uri:1337"
05:23:05 <lambdabot>   ("uri",1337)
05:23:27 <lpvb> why didn't the first one work?
05:24:02 <fmap> `(u,p) ->', not `\u p ->'
05:24:07 <lpvb> oh right
05:24:20 <lpvb> I need to get some coffee
05:25:03 <lpvb> @hoogle second
05:25:03 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
05:25:04 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec class SecondaryColor a
05:25:04 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec secondaryColor :: SecondaryColor a => a -> IO ()
05:25:42 <benmachine> fmap: do you find that you get highlighted a lot, by any chance
05:26:45 <lpvb> so it looks like second takes an arrow which acts like a function, and applies it to the second tuple argument?
05:26:55 <MHD> What's a good way, knowing haskell, to learn OCaml?
05:27:12 <MHD> lpvb: correct
05:27:19 <lpvb> yay me
05:27:25 <MHD> lpvb: Functions are arrows too
05:27:38 <lpvb> okay
05:27:41 <MHD> :t second (\x -> x+1)
05:27:42 <lambdabot> forall b d. (Num b) => (d, b) -> (d, b)
05:27:52 <benmachine> lpvb: doesn't need to be an arrow that acts like a function
05:28:01 <lpvb> yea I got it
05:28:03 <benmachine> except inasmuch as all arrows act like a function to some degree, because of arr
05:28:15 <benmachine> @arr
05:28:16 <lambdabot> I'll crush ye barnacles!
05:28:21 <lpvb> so arrows are more general than functions?
05:28:35 <MHD> lpvb: That is the idea, yeah
05:28:35 <benmachine> you can convert from functions into arrows
05:28:41 <lpvb> what part of mathematics is that?
05:28:47 <MHD> Categories
05:28:55 <benmachine> well, it's a certain kind of category
05:28:58 <fmap> benmachine: no
05:29:02 <benmachine> but what kind I don't actually know
05:29:25 <MHD> It is a category
05:29:45 <MHD> But one where the carthesian product rules are wonky
05:29:55 <benmachine> wonky?
05:30:18 <MHD> Because f *** g >>> arr fst =/= f
05:30:36 <MHD> because g might have side effects
05:30:47 <MHD> Such as Kleisli IO
05:31:10 <benmachine> oh right, yes
05:34:53 <Z`> do we write Maybe [String] or [Maybe String] ?
05:34:56 <Z`> in the type signature
05:34:59 <lpvb> first one
05:35:02 <Z`> thanks
05:35:27 <lpvb> unless you wanted a list of maybe strings?
05:35:33 <lpvb> or do you want a maybe with a list of strings?
05:35:48 <Z`> I'm still trying to figure out what I want
05:36:02 <fmap> That's different types
05:36:04 <fmap> > return $ return "hello" :: Maybe [String]
05:36:05 <lambdabot>   Just ["hello"]
05:36:07 <fmap> > return $ return "hello" :: [Maybe String]
05:36:08 <lambdabot>   [Just "hello"]
05:36:43 <lpvb> :t [Just 5, Nothing, Just 3]
05:36:45 <lambdabot> forall t. (Num t) => [Maybe t]
05:36:59 <lpvb> :t Just ["hello", "bye", "hi"]
05:37:00 <lambdabot> Maybe [[Char]]
05:37:03 * hackagebot happstack-foundation 0.2.2 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.2.2 (JeremyShaw)
05:39:37 <MagneticDuck> hey haskellers, I'm having trouble installing the gtk package from cabal
05:39:47 <MagneticDuck> I'm having a lot of trouble installing packages lately actually
05:39:50 <MagneticDuck> x)
05:40:25 <MagneticDuck> well
05:40:34 <MagneticDuck> I'm following this help:
05:40:40 <MagneticDuck> http://www.haskell.org/haskellwiki/Gtk2Hs/Linux
05:41:14 <MagneticDuck> I can't get libpangol, the name seems to be incorrect
05:41:36 <MagneticDuck> can anyone else try to follow the same steps and duplicate a problem?
05:41:59 <haja> it's pango1 (one)
05:42:08 <ivanm> which distro?
05:42:29 <MagneticDuck> ubuntu
05:42:33 <MagneticDuck> second to latest version
05:42:39 <MagneticDuck> can't remember the name...
05:42:42 <MagneticDuck> x)
05:42:46 <ivanm> they seriously append the version number to the package name?
05:42:57 <MagneticDuck> weird right?
05:43:15 <MagneticDuck> thanks haja
05:43:18 <Z`> if I:  map processLine myLines    where processLine :: String -> Maybe String and myLines :: [String] then I get as a result [Maybe String]. Right ?
05:43:27 <Botje> Z`: yes.
05:43:35 <Z`> thank you Botje
05:43:38 <haja> no problem MagneticDuck. copyPaste is your friend ;)
05:43:56 <MagneticDuck> erm, the package is called pango1?
05:44:11 <Botje> libpango1.0-dev - Development files for the Pango
05:44:14 <MagneticDuck> apt-get can't locate
05:44:15 <Botje> at least on debian.
05:44:20 <MagneticDuck> hm
05:44:33 <MagneticDuck> oh yay
05:44:40 <MagneticDuck> lol, must have been a typo
05:44:55 <haja> is it working now?
05:44:59 <MagneticDuck> gad this is a big  package
05:45:03 <MagneticDuck> yeah
05:45:05 <MagneticDuck> and all its dependencies!
05:45:07 <MagneticDuck> :O
05:45:21 <MagneticDuck> I guess I'm used to working with my pathetically small packages
05:46:44 <MagneticDuck> okay all set
05:46:46 <MagneticDuck> phew
05:46:58 <MagneticDuck> I love cabal compared to apt-get I have to say
05:47:12 <MagneticDuck> why the whole world no use haskell?
05:47:16 <MagneticDuck> weird people
05:47:58 <Jetbeard> MagneticDuck, because ghc on most linux distros is upwards of 700MiB :)
05:48:08 <MagneticDuck> yeah I suppose
05:48:10 <MagneticDuck> :P
05:48:13 <haja> magneticDuck well, I have to say don't love haskell that much anymore
05:48:23 <MagneticDuck> why not>
05:48:27 <MagneticDuck> *?
05:48:33 <MagneticDuck> I'm a newbie here, just fallen in love with haskell
05:49:04 <MHD> haskell is p great for most things
05:49:11 <MHD> What doesn't haskell do well?
05:49:27 <MagneticDuck> garr, now I'm on a wild goose chase trying to find the bad dependency
05:49:33 <MagneticDuck> installing the whole line manually
05:49:37 <MagneticDuck> grrrrr
05:49:42 <haja> It's too hard to modify code. especially if somebody else has written it, and is using all kinds of extensions and weird self-implemented monads you have to understand first.
05:50:01 <flux> mhd, fast compilations
05:50:21 <Jetbeard> I also agree that Haskell's pretty great for most things, but I've noticed that whenever somebody speaks out against Haskell they're instantly questioned about that - more so than they would when saying they don't like almost any other programming language
05:50:42 <MagneticDuck> lol, I just noticed that vim has a directory navigator
05:50:47 <haja> hmm, don't know about that jetbeard
05:50:48 <Jetbeard> I think this might be a symptom of the belief of most Haskell users that Haskell is some sort of panacea
05:51:03 <benmachine> Jetbeard: I think anyone who likes a language being told that someone else doesn't like it will want to know why
05:51:19 <benmachine> Jetbeard: unless you're writing PHP in which case you're probably used to everyone else hating you
05:51:49 <MagneticDuck> personally, I love haskell because, unlike most other languages, there isn't that much "magic"
05:51:51 <haja> what's really missing are tools. there is no tool for refactoring haskell.
05:52:00 <MagneticDuck> like in C, lists and strings are almost atoms
05:52:06 <MagneticDuck> you couldn't have implemented thenm
05:52:10 <MagneticDuck> *them
05:52:12 <MagneticDuck> haskell is more like math
05:52:14 <Jetbeard> benmachine, yeah, telling PHP users why they're wrong is just flogging a dead horse
05:52:15 <Z`> How could I turn Maybe String to String? I wrote something like:    unMaybe s = case s of Nothing -> ""; _ -> ... ?
05:52:32 <MagneticDuck> Z: concat . maybeToList
05:52:33 <haja> wait for monads and monadTranformers, that's magic all over again, if you ask me
05:52:44 <Jetbeard> Z`, data Maybe a = Nothing | Just a
05:52:46 <MagneticDuck> > concat . maybeToList $ Nothing
05:52:48 <lambdabot>   []
05:52:54 <MagneticDuck> > concat . maybeToList $ Just "hello"
05:52:57 <lambdabot>   "hello"
05:53:00 <MagneticDuck> tadaa
05:53:03 <benmachine> haja: but that's exactly the point, they aren't magic, they're just ordinary code
05:53:14 <benmachine> they may seem like magic, but they're not, really
05:53:20 <MagneticDuck> yeah
05:53:33 <MagneticDuck> they come from type constructors and typeclasses
05:53:37 <MagneticDuck> no magic there
05:53:42 <MagneticDuck> they're tricky!
05:53:46 <MagneticDuck> but they're not god-like
05:53:49 <MagneticDuck> :P
05:53:55 <haja> benmachine: I know, but still I can't seem to understand them. For me they are still magic. Maybe I'm just way too stupid...
05:54:06 <Jetbeard> > let unMaybe s = case s of Nothing -> ""; (Just x) -> x in (unMaybe Nothing, unMaybe $ Just "Hello!")
05:54:07 <lambdabot>   ("","Hello!")
05:54:18 <Jetbeard> Z`, that's a completion of your code
05:54:22 <Jetbeard> though there are much better ways to do it
05:54:28 <benmachine> haja: I'm not saying they're easy
05:54:38 <Z`> thanks Jetbeard -- that pattern matching I was missing
05:54:44 <lpvb> Am I allowed to use Network.BSD functions on linux?
05:54:45 <MagneticDuck> Jetbeard: mine was "concat . maybeToList"
05:54:46 <benmachine> haja: just that it's cool that all these things fundamental to writing Haskell don't need to be built in
05:54:56 <Jetbeard> MagneticDuck, yes, yours is better
05:55:01 <MagneticDuck> >:D
05:55:03 <benmachine> lpvb: I... think so? if they're there, then why not/
05:55:03 <Jetbeard> mine is what Z` had written, but completed
05:55:03 <Z`> Jetbeard: much in what sense ?
05:55:11 <lpvb> because it's called BSD
05:55:17 <lpvb> and not linux
05:55:18 <ski> Jetbeard : you could write `Just x -> x' there
05:55:22 <lpvb> or Unix
05:55:23 <Mon_Ouie> It treats Just "" and Nothing the same way, which may matter
05:55:35 <MagneticDuck> hey, what do people think about fromJust?
05:55:39 <Entroacceptor> :t concat . maybeToList
05:55:40 <lambdabot> forall a. Maybe [a] -> [a]
05:55:43 <Jetbeard> :t fromJust
05:55:44 <benmachine> lpvb: I think it means "the interface that originated on BSD" rather than "the interface that is only on BSD"
05:55:44 <lambdabot> forall a. Maybe a -> a
05:55:54 <lpvb> use fromMaybe
05:56:03 <Entroacceptor> :t fromMaybe
05:56:04 <lambdabot> forall a. a -> Maybe a -> a
05:56:06 <benmachine> lpvb: but honestly, if it's there feel free
05:56:06 <ski> > (fromMaybe "" Nothing,fromMaybe "" (Just "Hello !"))
05:56:07 <lambdabot>   ("","Hello !")
05:56:13 <lpvb> benmachine: okay, doesn't say that in there though
05:56:13 <haja> benmachine: I agree, but it doesn't make them better per se
05:56:34 <Jetbeard> Z`, I think 'fromMaybe ""' is the best you'll get
05:56:38 <haja> Z` how about fromMaybe ""
05:56:39 <benmachine> haja: I think it's an important property
05:56:46 <Jetbeard> it's shorter and uses existing library functions rather than rolling your own
05:56:50 <benmachine> haja: but I appreciate it's not much use /to you/ :)
05:56:52 <Jetbeard> (and it's point-free)
05:57:07 <MagneticDuck> lpvb: you're missing the point
05:57:13 <benmachine> MagneticDuck: fromJust is bad
05:57:15 <MagneticDuck> > fromMaybe  Nothing
05:57:16 <lambdabot>   Overlapping instances for GHC.Show.Show
05:57:17 <lambdabot>                              (Data....
05:57:24 <Z`> What package provides fromMaybe ?
05:57:29 <lpvb> > fromMaybe "" Nothing :: Maybe Int
05:57:30 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
05:57:30 <lambdabot>         again...
05:57:31 <benmachine> MagneticDuck: even 'let Just x = v in ... x ...' is better
05:57:38 <benmachine> Z`: it's in Data.Maybe which is in base
05:57:39 <lpvb> > fromMaybe "" Nothing :: Maybe String
05:57:40 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Base.String'
05:57:40 <lambdabot>         aga...
05:57:45 <lpvb> I suck
05:57:58 <lpvb> > fromMaybe "" Nothing :: String
05:57:59 <lambdabot>   ""
05:58:02 <benmachine> > fromMaybe "" (Nothing :: Maybe String)
05:58:03 <lambdabot>   ""
05:58:08 <benmachine> or in fact
05:58:11 <Jetbeard> > fromMaybe "" (Nothing :: Maybe Int)
05:58:13 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:58:13 <lambdabot>         against inferred ty...
05:58:13 <benmachine> > fromMaybe "" Nothing -- :)
05:58:14 <lambdabot>   ""
05:58:19 <lpvb> Z`: Data.Maybe
05:58:21 <MagneticDuck> ah
05:59:09 <benmachine> lpvb: network is a sufficiently low-level package that the rule is pretty much "if it works, you are free to use it"
05:59:18 <benmachine> lpvb: at least, that's how I understand it
05:59:48 <lpvb> would it work on Windows?
06:00:38 <Z`> alright. and is there a function that accepts a predicate and returns the elements of the list that satisfy it ?
06:00:47 <MagneticDuck> yes
06:00:49 <MagneticDuck> filter
06:00:54 <MagneticDuck> @type filter
06:00:55 <Z`> yupi.thanks
06:00:56 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:00:59 <MagneticDuck> > filter (>5) [1..10]
06:01:00 <lambdabot>   [6,7,8,9,10]
06:01:40 <MagneticDuck> > filter (isInfix "fish") cake
06:01:41 <lambdabot>   Not in scope: `isInfix'
06:01:46 <MagneticDuck> rr
06:01:58 <MagneticDuck> what
06:02:03 <MagneticDuck> what's what function called..
06:02:11 <lpvb> isInfixOf
06:02:16 <MagneticDuck> ah yeah
06:02:25 <MagneticDuck> > filter (isInfoxOf "fish") cake
06:02:26 <lambdabot>   Not in scope: `isInfoxOf'
06:02:29 <MagneticDuck> ~_~
06:02:30 <lpvb> infox
06:02:35 <MagneticDuck> haha
06:02:39 <MagneticDuck> in ze fox
06:02:48 <MagneticDuck> g2g
06:03:25 <Z`> jesus. finally i did it! thanks people
06:03:27 <lpvb> There's no possible way to make a function that does IO a -> a, is there?
06:03:58 <Jetbeard> :t unsafePerformIO
06:03:59 <lambdabot> Not in scope: `unsafePerformIO'
06:03:59 <tdammers> lpvb: unsafePerformIO - but that's a dirty trick
06:04:07 <layladylay> I have the function "parseInput :: String -> Either String String" Now I would like to say "main = do case parseInput "xyz" of  Left error -> print error [...]" buit this is not possible because I would mix up the Either and IO monad? How can I do what I want to do?
06:04:07 <mux> don't get caught by the type police
06:04:08 <Jetbeard> :t System.IO.Unsafe.unsafePerformIO
06:04:09 <lambdabot> forall a. IO a -> a
06:04:21 <bitonic> @type foo _ = undefined -- lpvb
06:04:22 <lambdabot> parse error on input `='
06:04:32 <bitonic> @type \_ -> undefined -- lpvb
06:04:33 <lambdabot> forall t a. t -> a
06:04:43 <Jetbeard> From the docs: "This is the "back door" into the IO monad, allowing IO computation to be performed at any time."
06:04:48 <bitonic> @type (\_ -> undefined) :: IO a -> a -- lpvb
06:04:49 <lambdabot> forall a. IO a -> a
06:05:05 <bitonic> @type (\_ -> let x = x in x) :: IO a -> a -- lpvb
06:05:06 <lambdabot> forall a. IO a -> a
06:05:08 <lpvb> hmm
06:05:10 <bitonic> etc. etc.
06:05:23 <bitonic> @type undefined :: IO a -> a -- lpvb
06:05:25 <lambdabot> forall a. IO a -> a
06:05:37 <bitonic> so the short answer is: yes.
06:05:44 <bitonic> probably doesn't do what you want.
06:05:48 <tdammers> the problem is, "at any time" means literally that.
06:05:51 <lpvb> but it's generally not a good idea?
06:05:54 <tdammers> no.
06:06:06 <tdammers> the compiler treats unsafePerformIO like any other pure function
06:06:07 <Jetbeard> layladylay, I think you'd want to say "main = do input <- parseInput "xyz"; case input of Left error -> ..."
06:06:09 <haja> actually, I've got some problem. I want to change the package haskell-src-exts (http://hackage.haskell.org/package/haskell-src-exts-1.11.1) to allow prettyPrinting of modules including the comments in the module. see also http://stackoverflow.com/q/9392546/1225326 since I can't find any other module which provides this, I wan't to implement it myself. Is anybody familiar with this package, especially with the module Language.Haskell.Exts.Pretty ?
06:06:18 <tdammers> but it's not pure, so all sorts of nasty things can happen
06:06:29 <tdammers> especially when your IO action has destructive side effects
06:07:06 <lpvb> I just want getHostName to return HostName instead of IO HostName
06:07:12 <lpvb> but I can refractor if that's a bad idea
06:07:25 <tdammers> well, the hostname is unlikely to change during the execution time of your program
06:07:37 <bitonic> lpvb: `IO HostName' is some computation that returns HostName
06:07:44 <Jetbeard> lpvb, in that specific case using unsafePerformIO wouldn't be the absolute end of the world
06:07:56 <Jetbeard> but it's more sensible to write your program in a clean way
06:08:01 <bitonic> lpvb: execute it where you want to get the HostName and then pass that around in some way
06:08:13 <Jetbeard> main = do hostname <- getHostName; ...
06:08:18 <tdammers> maybe some kind of Reader or State monad?
06:08:25 <bitonic> lpvb: if you want to get it once, you can use TemplateHaskell
06:08:26 <lpvb> oh no, acutally the function I wanted was HostName -> IO HostEntry to HostName -> HostEntry
06:08:38 <haja> I'm trying to wrap the Doc type with a StateT to carry the comments around, but it's just not working.
06:09:14 <haja> I can't modify the inner DocM monad properly so my printed comments get added to the final Doc
06:09:28 <benmachine> lpvb: refactor - get the hostname out in your IO code and then pass it around
06:09:35 <Jetbeard> Same principle, lpvb - it's true that that function will probably act pure-ish
06:09:46 <Jetbeard> but it's better to do it cleanly
06:10:02 <lpvb> understood
06:12:45 <bitonic> it's not even true that that function is safe, the hostname might change
06:13:44 <Jetbeard> bitonic, hence "probably"
06:14:09 <bitonic> Jetbeard: there is no "probably pure
06:14:12 <bitonic> " function
06:14:32 <bitonic> it's like saying "a little bit dead"
06:14:40 <Jetbeard> f is pure iff it has no side-effects, and for the same input always gives the same output
06:14:59 <Jetbeard> f is probably pure if it probably has no side-effects, and for the same input probably always gives the sam output :)
06:15:30 <bitonic> Jetbeard: when a probably pure function is impure.  so it's a pretty misleading term
06:15:46 <layladylay> Jetbeard: then I get "Couldn't match expected type `[Char]'                 with actual type `Either t0 t1'"
06:16:07 <bitonic> Jetbeard: I'd just stick to "impure" for functions that are not pure
06:16:21 <Jetbeard> bitonic, modern software engineer is built on a pile a mountain high of the words "maybe", "probably", "usually"
06:16:29 <Jetbeard> and more "hopefully"s than I'd like
06:16:32 <Jetbeard> *engineering
06:16:49 <lpvb> "probably always" is misleading, no?
06:16:52 <TheBrayn> "next {month,week,day}"
06:16:59 <bitonic> Jetbeard: well but here saying "probably pure" is just misleading - that function is impure
06:17:13 <bitonic> anyway, it doesn't matter, hopefully lpvb got the point
06:17:24 <lpvb> I know what both of you are saying
06:17:55 <Z`> How could I tell lambdabot print me the type of      foo = show "hi" ?
06:18:06 <lpvb> :t show "hi"
06:18:08 <lambdabot> String
06:18:22 <Z`> it doesn't work in PM
06:18:38 <bitonic> Z`: try @type
06:18:47 <bitonic> @type show "hi"
06:18:48 <lambdabot> String
06:18:49 <Z`> ah ok, thanks
06:21:41 <tdammers> what about things like `let f a = if null a then return "" else getContents a in f ""`? That's technically impure, but the side effect can never be triggered
06:22:04 <tdammers> it's a contrived example, but well...
06:23:15 <bitonic> tdammers: well that is fine, but you can't convince the compiler that it is.  so if you can't modify `f' you could use `unsafePerformIO'.
06:23:42 <tdammers> bitonic: exactly.
06:23:50 <tdammers> that's what I was getting at.
06:23:54 <benmachine> tdammers: that expression is equal to 'return ""' which is pure but not observably so
06:24:26 <tdammers> yes. conceptually pure, but the compiler can't tell (or at least, the language semantics can't)
06:24:26 <xz> how do I change thigns in the HTTP header when using Text.Xhtml ?
06:24:33 <benmachine> and, well, whether or not an implementation has to make return "" bona-fide pure is probably unspecified, since the IO type has no denotational semantics
06:24:51 <tdammers> so I tend to think of unsafePerformIO as a way of telling the compiler "this thing here doesn't look pure, but trust me, it is".
06:25:06 <tdammers> and of course, if you lie to the compiler, you deserve punishment.
06:25:36 <bitonic> `unsafePerformIO' and unsafe functions in general have their place.  a lot of important packages make heavy use of them
06:25:37 <xz> I mean using runCGI... oh ok I should check its docs
06:25:40 <benmachine> tdammers: right, or "this thing is internally impure, but has a pure interface"
06:26:47 <tdammers> yeah
06:27:05 <tdammers> but then, it can be argued whether something that is only internally impure is really impure
06:27:22 <tdammers> in other words, are non-observable side effects really side effects?
06:32:01 <Z`> I'd like to call a function from inside a do block that prints a string. But I use show, it fails. I need to use print which returns an IO ()
06:32:08 <Z`> why is IO sticky ?
06:32:22 <lpvb> what's the type of the do block
06:32:24 <lpvb> IO String?
06:32:27 <lpvb> or IO ()
06:32:32 <Z`> IO () it's from main
06:33:04 <Eduard_Munteanu> @src print
06:33:04 <lambdabot> print x = putStrLn (show x)
06:33:11 <Eduard_Munteanu> Z`: ^^
06:33:15 <Mon_Ouie> show returns a string, it doesn't print anything
06:33:18 <Botje> Z`: a do block demands that each statement has type IO something
06:33:26 <otters> :t putStrLn . show
06:33:27 <lambdabot> forall a. (Show a) => a -> IO ()
06:33:39 <Z`> ooops, ok, pebkac
06:33:44 <Z`> :P
06:35:19 <tdammers> it's a bit confusing that in ghci, show *does* seem to print something
06:35:43 <Z`> mm, show adds " " around the string ?
06:35:53 <tdammers> (it doesn't really print anything itself, that's ghci wrapping it, but it looks like it)
06:36:06 <Z`> rather around a
06:36:37 <Z`> ah ok got it
06:36:37 <Eduard_Munteanu> Z`: show is designed to represent things as they would be in source code
06:36:59 <Eduard_Munteanu> > show "Hello"
06:37:01 <lambdabot>   "\"Hello\""
06:37:23 <Z`> duh, ok. fixed
06:38:09 <Jetbeard> If you want to convert a string to be usable with putStrLn without adding any decoration, you'll need the "id" function ;)
06:38:13 <Eduard_Munteanu> > show 2
06:38:14 <lambdabot>   "2"
06:38:26 <mux> > show 'a'
06:38:27 <lambdabot>   "'a'"
06:43:31 <redjohn> anyone have recommendations for a good library/framework for restful web services?
06:45:21 <fmap> rails?
06:45:46 <redjohn> haha, trying to get away from that actually
06:46:37 <qwr> snap and yesod are in haskell ;)
06:47:06 <tdammers> happstack can probably be bashed into a REST server with little effort
06:47:11 <trescenzi>  if you like php i really enjoy laravel. and i've had fun with yesod if you want haskell
06:47:14 <qwr> (not a recommendation, i've not written any web service long time)
06:48:13 <redjohn> i've been looking into yesod. we currently are using grape (https://github.com/intridea/grape) at work, which takes care of some things more specific to web services
06:48:34 <Jetbeard> Yeah, I've heard many good things about Yesod
06:48:34 <redjohn> like supporting multiple versions and formats
06:48:44 <Jetbeard> (In fact, I've literally never heard anything bad about it.)
06:48:55 <redjohn> and i was wondering if there was something in haskell that was similar to it
06:48:58 <Jetbeard> Quick, somebody tell me something bad about Yesod, I feel too partisan now!
06:49:14 <redjohn> Jetbeard, never heard anything bad either
06:49:18 <trescenzi> It has a weird name?
06:49:21 <redjohn> template haskell maybe?
06:50:33 <Cale> Yesod is filled with TH languages which automatically define all kinds of things which aren't explicitly given names.
06:51:19 <Cale> At least, last time I looked, that's what it seemed to do.
06:51:53 <Cale> They might be better documented now (hopefully) than when I looked at Yesod before.
06:52:07 <redjohn> i've found the documentation to be quite good
06:53:17 <Cale> But I thought that stylistically, I'd prefer if the domain specific languages were embedded and there was less magic.
06:54:05 <tdammers> Cale: yeah, that's one of the things that put me off yesod
06:54:06 <stepkut> donri: I am not against the idea.. just haven't gotten that far yet :)
06:54:19 <donri> stepkut: wrong channel :)
06:55:03 <trescenzi> Rails is full of magic though. Most frameworks bother me because of the massive amount of magic
06:55:58 <stepkut> donri: oops
06:56:14 <lpvb> how do I update cabal libraries? Do the old ones remain in the system?
06:56:18 <donri> trescenzi: you need more happstack in your life
06:56:40 <xz> easy way to use ghc to make all the .hs files in a directory?
06:57:49 <trescenzi> donri: what's it like? less magic?
06:57:51 <donri> xz: you'd normally use cabal
06:58:05 <xz> donri: if I don't want to use cabal...?
06:58:17 <donri> trescenzi: than rails? certainly
06:58:43 <donri> xz: are the .hs files separate executables, or do they form a library?
06:58:49 <xz> donri: separate exes
06:58:55 <trescenzi> I'll have to check it out then. I've been working with yesod lately but that has a good deal of magic going on too
06:59:21 <merijn> trescenzi: I kinda like Yesod, but that may have to much magic, still? Although most of it seems to come from the scaffolding, if you strip it a lot of magic disappears.
06:59:32 <donri> xz: maybe: find -iname '*.hs' -exec ghc {} \;
06:59:46 <xz> donri: yeah I just did something like that - cheers :)
07:00:14 <donri> trescenzi: duno what magic means in haskell, but happstack certainly uses much less TH, or type classes for that matter
07:00:16 <merijn> lpvb: I think the only real way to uninstall them is to "ghc-pkg unregister" and then delete the relevant folder in .ghc or .cabal (I forget which)
07:01:24 <donri> trescenzi: ... or IOVars, which seems to be how yesod likes to solve any problem they run into
07:01:41 <trescenzi> donri: yea that's what i enjoy about haskell. I really don't have tons of experience with it but when looking at languages recently I thought it looked like the most fun and powerful
07:02:13 <Z`> I'm loading an .hs file into ghci. How could I use its functions? ghci tells me that they are not in scope
07:02:30 <haja> trescenzi: if you like to start fighting with the compiler about function types quite often... (the problems which annoy me the most) ;)
07:02:50 <Sculptor> o/
07:02:51 <donri> Z`: does a module declaration hide them from being exported?
07:03:28 <trescenzi> haja: See I enjoy compile errors more than runtime errors. I hate interpreted languages because of that. They can be great but for most things i like compile and type errors
07:04:05 <Z`> not that I know of donri . Does it hurt that I have main = do .. .?
07:04:22 <donri> Z`: shouldn't hurt, if the functions you want are top-level
07:04:33 <donri> Z`: how are you loading it in ghci?
07:04:33 <Z`> ah, no they are after main
07:04:38 <Z`> :l myfile.hs
07:04:53 <donri> after main is fine, as long as they're not defined in a where-clause or such
07:05:00 <haja> trescenzi: yes, me too, but it's not fun at all.
07:05:37 <trescenzi> yea I guess fun is a misnomer lol
07:06:21 <haja> not if you alter (mostly) undocumented code using own-written monads. and the type-definitions are missing ;)
07:06:49 <donri> haja: easy enough to inspect the types
07:07:05 * hackagebot RefSerialize 0.3.0.0 - Write to and read from ByteStrings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.3.0.0 (AlbertoCorona)
07:07:06 <donri> e.g. https://github.com/bitc/vim-hdevtools
07:07:20 <haja> how? ghci? in some not-exported function? honestly, I'm curious :)
07:07:40 <donri> the one i linked can inspect types of sub-expressions
07:08:32 <Z`> at some point I do pattern matching on a line read by a file. what if the line is malformed. How could I catch that ?
07:08:46 <Z`> currently haskell dies with rf: rf.hs:26:7-23: Irrefutable pattern failed for pattern [x, y, z]
07:09:28 <mm_freak> trescenzi: static checking does not contradict interpretation
07:09:39 <donri> Z`: the usual way is to complete the pattern, possibly via a catch-all
07:09:42 <oscar_> exit
07:09:55 <mm_freak> you can have static checking in an interpreted implementation, and GHC is an example of that
07:10:16 <donri> mm_freak: or static checking in a compiled build :) -fdefer-type-errors
07:10:21 <Z`> thanks donri
07:10:45 <trescenzi> mm_freak: true. I guess I'm thinking of stuff like php and javascript. more traditionally interpreted only languages that are dynamically typed
07:10:49 <donri> Z`: maybe hpaste.org the code?
07:10:54 <mm_freak> i don't understand -fdefer-type-errors, and cabal should introduce an option to reject packages that use that flag
07:11:19 <mm_freak> trescenzi: dynamic typing also doesn't contradict static typing…  PHP and JavaScript are simply bad languages
07:11:19 <merijn> In the trying to do insane things at the type level category: It's not possible to close a typeclass, right?
07:11:22 <MagneticDuck> hey, I'm trying to install the cabal package GTK..
07:11:32 <Z`> http://paste.lisp.org/display/131729
07:11:33 <mm_freak> merijn: "close"?
07:11:34 <donri> "meh", lots of ways to cause runtime errors already, i doubt deferred type errors are going to be an issue
07:11:43 <mm_freak> merijn: such that you can't write further instances?
07:11:45 <MagneticDuck> but I get an error "the pkg-config package gtk+- 2.0 is required but it could not be found"
07:11:47 <merijn> mm_freak: Yes
07:11:49 <MagneticDuck> what should I do?
07:11:58 <haja> donri: thanks. I've been looking for something like this
07:11:59 <mm_freak> merijn: no, but you can write type families with DataKinds
07:11:59 <merijn> mm_freak: The open world assumption ruins my day every time >.>
07:12:10 <mm_freak> merijn: type family Plus :: Nat -> Nat -> Nat
07:12:24 <donri> Z`: ah yea if you use "let" like that you can't pattern match completely
07:12:26 <merijn> oh, maybe that'd be sufficient
07:12:45 <Z`> is there a way to rewrite that block to allow for catching _ at the end ?
07:13:11 <merijn> mm_freak: I'm not really sure what consists a type family yet, though. The example code I saw on the wiki doesn't really clearly distinguish the differences to me
07:13:58 <mm_freak> merijn: with classes you program in a prolog-like logic paradigm, with type families you actually write type functions
07:13:59 <merijn> And the "Fun with Type Funs" papers mostly was about type funs, as far as I understand the paper
07:14:06 <hpaste> donri pasted “for Z`” at http://hpaste.org/74586
07:14:07 <mm_freak> it's more straightforwrad
07:14:27 <mm_freak> type instance Plus x (S y) = S (Plus x y)
07:14:34 <mm_freak> type instance Plus x Z = x
07:14:40 <donri> Z`: ^
07:15:00 <mm_freak> merijn: you can actually use infix operators now, which is great
07:15:04 <trescenzi> mm_freak: I'm not entirely certain how you could have both dynamic and static typing, I have to admit I don't know a ton about this sort of thing. Like a late bound but with a known type?
07:15:08 <merijn> mm_freak: Yeah, I get the type functions part of it, but not really which syntax creates a family
07:15:35 <linusoleander> How come the first example works, but not the later one?
07:15:36 <linusoleander> https://gist.github.com/0992cd0ffc853bd3a79b
07:15:39 <mm_freak> type family (:+:) :: Nat -> Nat -> Nat  -- requires DataKinds, KindSignatures and TypeFamilies
07:15:42 <merijn> mm_freak: Oh? I didn't see mention of infix yet?
07:15:49 <mm_freak> that's a type family
07:15:51 <linusoleander> Why isn't line 18 working?
07:15:59 <db81> MagneticDuck: install the development version of gtk-2.0, it's usually the package with name ending with -dev suffix, depending on your distro.
07:16:02 <mm_freak> type instance x :+: S y = S (x :+: y)
07:16:03 <linusoleander> But 7 are
07:16:09 <mm_freak> type instance x :+: Z = x
07:16:44 <copumpkin> it's more conventional to recurse on the left argument
07:16:44 <mm_freak> read the family declaration like a type signature for the type function and the instances as the function body
07:16:51 <donri> linusoleander: is Exp a Num?
07:16:56 <copumpkin> it makes things like list concat more natural
07:17:13 <linusoleander> donri: I*ve no idea :)
07:17:31 <ski> Z :  fst (break (==':') x)  can be written as  takeWhile (/= ':') x  and  snd (break (/='*') z)  as  dropWhile (== '*') z
07:17:49 <linusoleander> donri: Yeah, in this case "n" must be an int
07:17:51 <donri> linusoleander: IsZero contains an Exp which you are then comparing to 0 (zero), which means Exp must be a Num and an Eq
07:17:59 <donri> linusoleander: "n" is an Exp
07:18:07 <merijn> mm_freak: The Plus example is the same as something like "class Plus x y where type PlusFun x y" and "instance Plus x Z where PlusFun x Z = x; instance Plus x (S y) where PlusFun x (S y) = S (PlusFun x y)", right?
07:18:26 <donri> linusoleander: you have IsZero :: Exp -> Exp, not IsZero :: Int -> Exp
07:18:40 <Z`> thanks donri for caring
07:19:00 <linusoleander> donri: How do I force Exp to only be an Num=
07:19:06 <linusoleander> Num a => … ?
07:19:17 <mm_freak> merijn: yes, but the class-bound version is uglier, requires more extensions and doesn't do more
07:19:34 <merijn> mm_freak: It only requires TypeFamilies in my source?
07:19:42 <merijn> mm_freak: But it's uglier, yes
07:19:44 <donri> linusoleander: any Num? you'd need existentials or something for that
07:19:47 <mm_freak> merijn: i just gave you the complete code
07:19:53 <merijn> mm_freak: Just wanted to make sure I didn't have things confused :p
07:20:06 <mm_freak> merijn: btw, this is not how you do that with classes normally
07:20:23 <haja> MagneticDuck: you have to install some linux-distro packages first: on ubuntu it should be these:
07:20:23 <haja> libglib2.0-dev libcairo2-dev libpango1.0-dev libgtk2.0-dev libgtksourceview2.0-dev
07:20:34 <haja> then you have to do cabal install gtk2hs-buildtools
07:20:39 <mm_freak> merijn: btw, you can actually close a type class
07:20:44 <merijn> mm_freak: Oh?
07:20:47 <linusoleander> donri: Okay, so what's the solution ?
07:20:53 <mm_freak> merijn: if you enable DataKinds and KindSignatures
07:20:59 <donri> linusoleander: depends what you're trying to do
07:21:02 <mm_freak> class MyClass (a :: MyKind)
07:21:10 <donri> linusoleander: is it intentional that you're using GADTs?
07:21:18 <ski> Z` : btw, are you sure you don't want to use `show' instead ?
07:21:31 <linusoleander> donri: Yes, I'm taking a course in generic programming
07:21:44 <Z`> ski: where/how ?
07:22:10 <merijn> mm_freak: And then define MyKind to consist of only the type I want?
07:22:32 <donri> linusoleander: presumably you have more in the Exp data type than IsZero? it's a bit difficult to tell what you're trying to do with just IsZero
07:22:53 <linusoleander> donri: Yes, I've a bunch of expressions
07:23:04 <linusoleander> If, Add and so on
07:23:14 <merijn> donri: Presumably he basically wants GADTs
07:23:26 <donri> merijn: he's using GADTs
07:23:32 <ski> > let string = "string" in "\"" ++ string ++ "\""
07:23:34 <lambdabot>   "\"string\""
07:23:39 <ski> > let string = "string" in show string
07:23:40 <lambdabot>   "\"string\""
07:23:50 <Z`> how could I combine write something like:   case words s of [x, "add|print|rem", z] of ... and match any of that words ? they would all have the same result
07:23:53 <ski> > let string = "string0\nstring1" in "\"" ++ string ++ "\""
07:23:55 <lambdabot>   "\"string0\nstring1\""
07:23:56 <merijn> donri: oh, then how is "IsZero :: Exp -> Exp"?
07:23:58 <ski> > let string = "string0\nstring1" in show string
07:24:00 <lambdabot>   "\"string0\\nstring1\""
07:24:12 <Botje> Z`: use a guard
07:24:13 <donri> ski: because it's defined like that, but with GADTs notation
07:24:16 <merijn> donri: Shouldn't that be "IsZero :: Num a => Exp a -> Exp Bool"
07:24:18 <Botje> vs
07:24:20 <donri> uh, merijn *
07:24:22 <Z`> thanks Botje
07:24:30 <ski> donri : sorry ?
07:24:34 <Botje> case words s of [x, cmd,z] | cmd `elem` words "add print rem" = ...
07:24:37 <donri> ski: nevermind
07:24:48 <donri> merijn: maybe. can you use class constraints in a GADT like that?
07:24:48 <ski> s/=/->/
07:24:52 <mm_freak> merijn: data MyKind = MyType1 | MyType2
07:24:54 <merijn> donri: No clue :p
07:25:03 <donri> linusoleander: try what merijn said ^_^
07:25:08 <ski> Z` : do you see ?
07:25:10 <mm_freak> merijn: that's promoted from value/type level to type/kind level
07:25:25 <merijn> mm_freak: I'm just gonna go read up on DataKinds, KindSignatures and reread TypeFamilies
07:25:29 <merijn> mm_freak: Thanks for the help!
07:25:48 <Z`> ski: will read it in a bit. too much scrolling
07:26:03 <mm_freak> merijn: you must have missed a lot…  by now we even have kind polymorphism =)
07:26:09 <mm_freak> although i have never used it
07:26:23 <mm_freak> also make sure you have GHC 7.4
07:26:24 <merijn> mm_freak: I never really did much type level stuff before recently
07:26:31 <donri> linusoleander: actually, with that you need to add a parameter to Exp. which you probably want to do anyway.
07:26:43 <merijn> I have 7.4, I'm waiting for 7.6 in HP so I get Type Literals \o/
07:27:07 * hackagebot TCache 0.10.0.0 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.0 (AlbertoCorona)
07:27:24 <Z`> Botje: that gives me a parse error on =
07:28:10 <Botje> Z`: yes, that should be -> as ski pointed out
07:28:36 <Z`> cool,thanks both
07:28:39 <linusoleander> donri: I'm not sure I'm following. I'm only suppose to implement the "eval" method, not isZero
07:29:02 <donri> linusoleander: and you're sure Exp is defined like that?
07:29:43 <linusoleander> Yes, I just copied the definition from the exercise
07:29:57 <mm_freak> linusoleander: the Exp type in the paste doesn't make much sense
07:30:11 <mm_freak> the only possible values are:  undefined, Exp undefined, Exp (Exp undefined), etc.
07:30:17 <linusoleander> mm_freak: I'll bin the full exp
07:30:33 <mm_freak> lol
07:30:39 <donri> mm_freak: (you mean IsZero, right?)
07:30:51 <mm_freak> you can't expect anyone to help, if your types are incompletely defined ;)
07:30:51 <linusoleander> mm_freak: https://gist.github.com/c57468a8b3ffbcec7428
07:31:14 <mm_freak> linusoleander: that type definition is invalid
07:31:46 <linusoleander> mm_freak: Ooops, most of the stuff i missing
07:31:50 <linusoleander> hold on
07:31:55 <merijn> mm_freak: DataKinds automatically promotes to the kind level when you use it in a type signature? Or do you need to annotate it somehow?
07:32:05 <mm_freak> merijn: automatically
07:32:59 <linusoleander> mm_freak: Reload the gist
07:33:05 <merijn> mm_freak: And if you use it in both types and values, will it essentially generate two parallel versions? (type and value level) or produce an error?
07:33:26 <donri> linusoleander: still invalid
07:33:41 <merijn> I guess I should just test >.>
07:34:06 <mm_freak> merijn: i think where there is ambiguity there is a prefix you can use, but i forgot what it was
07:34:16 <mm_freak> like:  data X = X
07:34:17 <linusoleander> donri: Now?
07:34:19 <donri> also still not sure why Exp is a GADT there
07:34:47 <donri> are you sure there's no type parameter in Exp
07:34:55 <donri> are you copying this by hand from print or something?
07:35:54 <Z`> If I have a long line like:     let mycmds = words "this is a very long line"  how can I break it and continue writing in a new line? like \ in C
07:35:55 <linusoleander> donri: I'm trying to copy the content from a pdf, but os x ignores much of the characters, i'm not sure why
07:36:14 <donri> linusoleander: maybe easier just print-screening it xD
07:36:21 <merijn> mm_freak: No, I meant if you had the data definition and tried to use it both as value and as type, but I just tested it instead of being lazy and GHC produces an error (as I'd expect)
07:37:00 <merijn> These extensions are going to result in monstrous code xD
07:37:07 * hackagebot Workflow 0.7.0.0 - Monadic transformer for persistence in threads. and workflow patterns  http://hackage.haskell.org/package/Workflow-0.7.0.0 (AlbertoCorona)
07:37:18 <donri> heh, all these awesome type extensions sort of make me wonder about dependent types
07:37:34 <Botje> z]
07:37:38 <Botje> oops, grrr
07:37:55 <linusoleander> So what's the solution here, how can I force "n" to be a Num?
07:38:30 <merijn> mm_freak: I think I got the TypeFamilies code confused mostly due to the Data Families example in the same wiki entry
07:38:35 <donri> linusoleander: you're probably meant to check for (IsZero (Int n))
07:40:06 <linusoleander> donri: That gives me "Not in scope: data constructor `Int'"
07:40:22 <donri> linusoleander: you just pasted for us that it's part of Exp
07:40:52 <linusoleander> Did I?=
07:40:58 <donri> https://gist.github.com/c57468a8b3ffbcec7428
07:41:06 <donri> Int :: Int -> Exp
07:42:13 <linusoleander> donri: Awesome
07:42:20 <linusoleander> Now it worked, thanks
07:42:23 <linusoleander> *works
07:42:41 <mm_freak> Botje: you can add lots of fancy type extensions, as long as you don't introduce dependent types
07:42:57 <mm_freak> uh
07:43:02 <mm_freak> that was for donri, not Botje =)
07:43:34 <mm_freak> Botje: haskell survives type extensions as long as they don't collapse the levels
07:48:15 <Mortchek> mm_freak, why can't extensions introduce dependent types?
07:50:10 <Jetbeard> A "Hello World!" Haskell program on my machine will be >1MiB and about 700KiB after stripping. With "-dynamic" the situation's much better, 17KiB and 9.2KiB
07:50:15 <mm_freak> Mortchek: because that would turn haskell in a sufficiently different language that you could almost start from scratch
07:50:51 <Jetbeard> The dynamic version depends on 14 libraries, compared to the 3 that the C version depends on
07:51:36 <Jetbeard> Will we ever be at the point where all the unnecessary stuff will no longer be included, and we can get binaries out of Haskell with a comparable size/library-count to C?
07:52:02 <copumpkin> never
07:53:34 <merijn> Jetbeard: There's pretty much zero motivation to do that
07:53:44 <merijn> Jetbeard: Disk space is cheap, engineering effort isn't
07:55:09 <Jetbeard> merijn, Disk space might be cheap where you are, but in the embedded systems world, not so much
07:55:22 <hiptobecubic> Are there any books or anything that go into detail about the thought process behind some successful applications/libraries in haskell? Not like a tutorial, but an after-the-fact analysis or so?
07:55:26 <int-e> Are there any serious jhc users that could say how big binaries produced are?
07:56:01 <hpaste> int80_h pasted “reactive banana sanity check” at http://hpaste.org/74588
07:57:16 <Botje> hiptobecubic: 'architecture of open source programs' has a really nice chapter on GHC
07:57:16 <merijn> Jetbeard: Haskell has no serious application in the embedded world for the forseeable future
07:58:05 <mm_freak> Jetbeard: a haskell program needs at least the run-time system, which is a C library and somewhat large
07:58:07 <merijn> Jetbeard: At least not as a language running *on* embedded systems. I think people at the University of Twente were using Haskell to design hardware, instead of vhdl
07:58:28 <mm_freak> Jetbeard: even if you manage to decrease the library count, you won't decrease the size, because you can't live without the RTS
07:59:02 <merijn> mm_freak: Well, you could strip the runtime, but that's (as I said) not really a worthwhile resource investment
07:59:54 <hiptobecubic> Botje, thank you
08:00:39 <mm_freak> i doubt that you can make the RTS /much/ smaller without giving up some of haskell's features
08:00:43 <Jetbeard> mm_freak, I think library count might be more important than binary size
08:01:03 <mm_freak> Jetbeard: but honestly i don't see that one decrease either
08:01:48 <merijn> mm_freak: My point was that in embedded giving up some features may make sense (multithreading perhaps?)
08:04:55 <mm_freak> merijn: we already have a single-threaded RTS, which is large enough
08:05:13 <mm_freak> only -threaded links against the multi-threaded RTS
08:05:33 <int80_h> any reactive-banana folks about?
08:05:49 <djahandarie> Radioactive banana
08:06:05 <int80_h> lol
08:06:28 <int80_h> don't worry, it's the kind of banana that gives you super powers.
08:06:35 <int80_h> I mean radioactivity.
08:06:38 <mm_freak> that reminds me…  netwire 4 code is now done…  i'm writing a tutorial and then i'll release =)
08:07:12 <mm_freak> for those who can't wait anymore:  darcs get http://darcs.ertes.de/netwire/
08:07:14 <mm_freak> =)
08:07:25 <merijn> donri: I just checked, you're allowed to have class restrictions on GADT constructors
08:08:13 <donri> merijn: yea i checked too, but couldn't actually *use* it
08:08:22 <donri> but, not sure i did it right
08:09:17 <int80_h> mm_freak: mind taking a look at my hpaste?
08:09:50 <donri> merijn: ah yea, it works if you do Exp a, but not just Exp
08:10:13 <mm_freak> int80_h: i don't have experience with reactive-banana
08:10:31 <merijn> donri: of course, you can only restrict on a type parameter
08:10:39 <merijn> donri: Otherwise it'd make no sense :p
08:10:59 <donri> merijn: Well I was trying Number :: Num a => a -> Exp, which is accepted as a data decl
08:11:12 <donri> but then I couldn't construct a Number 2 etc
08:11:48 <int80_h> mm_freak : oh no worries, I thought I saw some types in your code that looked like they may have been from reactive-banana
08:11:58 <donri> actually can construct but not pattern match, looks like
08:12:06 <merijn> donri: I tested with "Foo :: (Ord a) => a -> Exp a" and that works as expected
08:12:20 <mm_freak> int80_h: it's the other way around =)
08:12:25 <donri> merijn: yea i tested that too and that one works fine
08:12:28 <merijn> Anyhoo, time to go home
08:12:38 <lpvb> I'm trying to follow this example: https://github.com/vincenthz/hs-socks/blob/master/Example.hs
08:12:54 <mm_freak> int80_h: netwire is based on yampa, yampa is based on dependent ZipStreams…  reactive-banana is based on non-dependent ZipStreams
08:13:02 <lpvb> but when I get the serverName and serverPort from the commandline options it says it cant connect
08:13:14 <lpvb> but connects if I hard code them in (leave as is)
08:13:47 <donri> mm_freak: is nw4 a complete rewrite?
08:13:50 <lpvb> the types of serverName and serverPort from commandLine args are String and Word16
08:14:01 <mm_freak> donri: of netwire?  yes
08:14:20 <donri> mm_freak: cool. so, fastirc nest week?
08:14:47 <mm_freak> hehe no, my first step will be a small proof of concept gloss wrapper
08:15:55 <mm_freak> fastirc will take a bit longer, because i will rewrite it from scratch…  i have planned an applicative parser combinator library for fast network protocol parsing
08:16:41 <mm_freak> it will use a wire category for both beauty and efficiency =)
08:17:04 <mm_freak> just like netwire =)
08:18:11 <donri> attoparsec not good enough?
08:20:55 <mm_freak> donri: not for parsing protocols that are exceedingly about comparing strings
08:20:57 <mm_freak> like IRC
08:22:10 <donri> hm, isn't http the same?
08:22:37 <rwbarton> I would ask how fast an IRC client needs to be, but I suppose if you are going to name yours fastirc then you should go all out
08:23:22 <djahandarie> mm_freak, I'm definitely looking forward to whatever you come up with, I use fastirc fairly extensively.
08:23:33 <djahandarie> rwbarton, for bots it can be pretty useful to be able to parse things fast.
08:24:21 <donri> djahandarie: what kind of bot do you have that needs that kind of performance though? :p
08:24:44 <djahandarie> I wrote something like an open proxy monitor IRC bot in Haskell.
08:24:53 <djahandarie> The actual open proxy monitoring code itself isn't in Haskell though.
08:24:58 <djahandarie> It just interfaces with a C binary.
08:25:25 <Entroacceptor> mm_freak: make it so that you can use one part as a bouncer and connect with multiple frontends
08:25:26 <djahandarie> Either way, it needs to be able to handle bursts of 10k or 20k instantly
08:25:34 <donri> i suppose
08:27:17 <lpvb> can I do pattern matching with 'let' inside a do block?
08:27:33 <mm_freak> Entroacceptor: fastirc will become a pure parsing library…  the actual bot library will be a different one based on fastirc and netwire
08:27:44 <djahandarie> Excellent
08:27:54 <djahandarie> That's exactly what I'm looking for :)
08:28:08 <mm_freak> =)
08:28:28 <c_wraith> lpvb: you can, though it has some special rules for when the pattern-match fails
08:28:29 <mm_freak> fastirc was my original motivation for starting with netwire in the first place…  that's why it was called "net"-wire =)
08:29:01 <lpvb> > do {let [uno, dos] = ["hi","bye"]; print uno}
08:29:02 <lambdabot>   <no location info>: parse error on input `}'
08:29:10 <lpvb> > do let [uno, dos] = ["hi","bye"]; print uno
08:29:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:29:14 <lpvb> ?
08:29:42 <mm_freak> > (do let Just x = Nothing; return 3) :: Maybe Int
08:29:42 <c_wraith> you need extra braces in braces-mode
08:29:43 <lambdabot>   <no location info>: parse error on input `)'
08:29:55 <mm_freak> > (do let { Just x = Nothing }; return 3) :: Maybe Int
08:29:56 <lambdabot>   Just 3
08:29:58 <c_wraith> because the let needs its own braces
08:30:11 <mm_freak> > (do let { y@(Just x) = Nothing }; y `seq` return 3) :: Maybe Int
08:30:13 <lambdabot>   *Exception: <interactive>:3:10-29: Irrefutable pattern failed for pattern (...
08:30:31 <mm_freak> c_wraith: apparently the special fail rule is only for binding, not for letting
08:30:49 <c_wraith> oh, right
08:31:01 <c_wraith> how'd I mess that up?  Too early to brain
08:31:13 <lpvb> > (do { let [uno, dos] = ["hi","bye"]; print uno; };)
08:31:14 <mm_freak> well, let-patterns are always irrefutable
08:31:15 <lambdabot>   <no location info>: parse error on input `;'
08:31:25 <lpvb> > (do { let [uno, dos] = ["hi","bye"]; print uno } )
08:31:26 <lambdabot>   <no location info>: parse error on input `}'
08:31:31 <mm_freak> > (do let { Just x = Nothing }; Just y) :: Maybe Int
08:31:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:31:32 <lambdabot>         against inferred type ...
08:31:42 <mm_freak> > (do let { Just x = Nothing }; Just x) :: Maybe Int
08:31:42 <lpvb> > (do let { [uno, dos] = ["hi","bye"]; print uno } )
08:31:43 <lambdabot>   Just *Exception: <interactive>:3:10-25: Irrefutable pattern failed for patt...
08:31:43 <lambdabot>   can't find file: L.hs
08:32:06 <lpvb> > (do let { [uno, dos] = ["hi","bye"]; print uno } )
08:32:08 <lambdabot>   <no location info>: parse error on input `}'
08:32:11 <lpvb> idk
08:32:22 <c_wraith> you forgot a closing brace in that one
08:32:38 <c_wraith> and an opening brace
08:32:39 <c_wraith> wow
08:32:44 <lpvb> > (do let { [uno, dos] = ["hi","bye"]}; print uno )
08:32:45 <lambdabot>   <IO ()>
08:33:03 <c_wraith> oh, and yeah, lambdabot doesn't execute IO
08:34:11 <hpaste> lpvb pasted “Still not working” at http://hpaste.org/74589
08:34:28 <lpvb> xample.hs:15:3: parse error on input `let'
08:34:44 <djahandarie> > launchMissiles
08:34:46 <lambdabot>   <IO ()>
08:34:54 <lpvb> lol
08:35:14 <c_wraith> lpvb: I think the parse error is caused by you using tabs
08:35:20 <lpvb> I dont use tabs
08:35:23 <geekosaur> lpvb, indentation is significant in haskell; you terminated the do at that first let because it's outdented
08:35:23 <c_wraith> lpvb: given the way that looks in the past, anyway
08:35:33 <c_wraith> *paste
08:35:43 <mm_freak> many people have been saying, "i don't use tabs", in the past =)
08:36:17 <lpvb> omg
08:36:27 <lpvb> I copied the example, and didn't realize the guy used tabs
08:36:35 <mm_freak> see? ;)
08:36:44 <lpvb> my mistake :(
08:36:52 <c_wraith> my text editor is set to highlight tabs in a bright red "wtf is this, get rid of it" color. :)
08:37:03 <lpvb> c_wraith: good idea
08:37:11 <dgpratt> c_wraith: ooh, good idea!
08:37:29 <Cale> c_wraith: Mine too
08:37:38 <dgpratt> Cale: good idea!
08:38:05 <c_wraith> lpvb: and now you know the treachery of invisible tabs. :)
08:38:07 <edwardk> zomg github is down
08:38:33 <c_wraith> that is one angry unicorn
08:41:08 <hpaste> lpvb pasted “Connection Error?” at http://hpaste.org/74591
08:41:13 <lpvb> okay sorry, one more problem
08:41:25 <lpvb> $ ./Example localhost 9050 'www.google.com'
08:41:27 <lpvb> Example: connect: does not exist (Connection refused)
08:41:32 <lpvb> when I run that
08:41:37 <lpvb> but the hardcoded values don't fail?
08:42:22 <c_wraith> don't use the PortNum constructor directly
08:42:32 <lpvb> what should I use?
08:42:33 <c_wraith> it doesn't work the way you think it should.  (Or the way I think it should)
08:42:46 <c_wraith> :t toEnum
08:42:47 <lambdabot> forall a. (Enum a) => Int -> a
08:42:51 <c_wraith> that's the one
08:42:57 <geekosaur> ^^ IIRC it requires network byte order so a conversion step is needed
08:43:00 <geekosaur> which is screwy
08:43:06 <lpvb> toEnum?
08:43:09 <c_wraith> yeah
08:43:11 <lpvb> how am I suppoed to know that
08:43:15 <lpvb> just asking
08:43:18 <geekosaur> that's why it's screwy
08:43:23 <c_wraith> sadly, that isn't documented well anywhere
08:43:27 <geekosaur> it's a horrid API
08:43:27 <c_wraith> it catches a lot of people
08:43:43 <notdan> Wait, where you have to put toEnum?
08:44:09 <Cale> It's an okay API, but the constructor probably shouldn't be exposed.
08:44:14 <lpvb> ooh it works now :D
08:44:28 <lpvb> lemme see if it works on the non-trivial example
08:44:31 <c_wraith> yeah, it'd be fine if the constructor wasn't exported
08:45:11 <mm_freak> my editor also highlights trailing spaces
08:45:13 <notdan> Sorry, guys, I am looking at lpvb's code and I don't seem to understand how are you supposed to fix it
08:45:21 <mm_freak> those are just as annoying as tabs =)
08:45:23 <notdan> do you have to replace PortNum with toEnum?
08:45:35 <lpvb> ya
08:45:44 <c_wraith> notdan: yes.  and change the type of read to String -> INt
08:45:47 <c_wraith> err, Int
08:46:05 <Cale> you could also use fromIntegral/fromInteger
08:46:07 <notdan> Right, thanks
08:46:20 <Cale> or maybe even just remove PortNum altogether
08:46:25 <Cale> and let it be implied
08:46:32 <hpaste> ghorn pasted “functor composition” at http://hpaste.org/74593
08:46:51 <ghorn> i'm trying to write this Functor instance for a type operator
08:46:53 <c_wraith> does the Read instance for PortNum do the right thing?
08:47:25 <dmos> given a (deeply nested) ADT S representing the (synchronized) state of a remote system
08:47:33 <Cale> ghorn: There's no type level lambda
08:47:39 <dmos> where S(t0) is the current state of synchronization and S(d) is the desired state to transition to
08:47:58 <dmos> how do I go about to 'declare' what commands have to be sent over the communication link so that S(t0) can transition to S(d)?
08:48:18 <Cale> ghorn: you can write   data (f :* g) a = f a :* g a
08:48:26 <dmos> (if the commands don't trivially correspond to the ADT modification)
08:49:03 <Cale> ghorn: and then   instance (Functor f, Functor g) => Functor (f :* g) where fmap f (x :* y) = fmap f x :* fmap f y
08:49:42 <lpvb> c_wraith: thanks alot!
08:50:40 <ghorn> Cale: are you saying "\x ->" is incorrect syntax or that it's impossible to do a type level lambda at all?
08:50:47 <ghorn> Cale: that solution works btw
08:50:53 <ghorn> thnks
08:51:54 <Cale> ghorn: It's impossible to do a type-level lambda at all in Haskell
08:52:10 <Cale> ghorn: (at least, right now, with current implementations)
08:59:01 <sully> is there an option to the RTS that will just make it print out when a GC pass is happening?
08:59:47 <Cale> sully: Have you tried the mode which beeps?
09:00:58 <geekosaur> +RTS -B and pipe stderr through sed 's/\07/[GC]/' or something?
09:01:49 <yitz> Cale: well, oleg knows how to do type-level lambdas, but i don't think that's what ghorn is looking for. ;)
09:02:32 <mm_freak> what's a "type level lambda" anyway?  the big lambda operator from typed lambda calculus is on the value level
09:02:35 <mm_freak> on the type level we have forall
09:02:40 <Cale> Well, you can implement the lambda calculus at the type level, but I'm not sure that's the same thing as a type level lambda.
09:03:19 <sully> ok, answer: it is GCing all the time :P
09:04:55 <mm_freak> sully: that's not unusual in haskell
09:07:38 <Cale> sully: GCs happen so frequently and so quickly that you probably don't want a printout of it :)
09:08:13 <Cale> (at least, most GCs happen quickly -- major collections can take a possibly noticeable amount of time on slow platforms)
09:09:30 <sully> mm_freak: some typed lambda calculuses also have lambdas from types to types
09:09:58 <sully> mm_freak: the different sorts of ways that terms and types can depend on each other is described by the lambda cube
09:10:55 <sully> mm_freak: basically everything lets terms depend on terms (regular lambdas); if you add polymorphism, that is terms depending on types; if you add type level lambdas, that is types depending on types; if you add dependent types, that is types depending on terms
09:11:21 <sully> and this defines 3 axes
09:11:40 <sully> having none of them is the simply typed lambda caluclus
09:11:57 <sully> the first is the polymorphic lambda calculus (system F)
09:12:11 <sully> first two is the higher order polymorphic lambda calculus (system F-omega)
09:12:16 <sully> just the third is LF
09:12:22 <sully> all three is the Calculus of Constructions
09:12:42 <yitz> sully: when kinds come into play, do we get a tesseract?
09:13:05 <djahandarie> yitz, yes, looks at pure type systems.
09:13:06 <sully> kinds are already in play
09:13:31 <sully> you need kinds once you have type level lambdas or dependent types
09:13:39 <sully> (in LF, you can also have kinds depend on terms)
09:15:20 <djahandarie> When you say it like that it sounds like you're talking about a universe hierarchy, which LF doesn't have. lambda-pi calculus has terms, types, and families of types.
09:16:46 * djahandarie will bbiab
09:28:18 <Z`> people. I need your expertise, please. I have a function 'processLine' which does some work. I call it like "let w = map processLines myLines"
09:28:19 <MoZaHeM> people. I need your expertise, please. I have a function 'processLine' which does some work. I call it like "let w = map processLines myLines"
09:28:50 <Z`> The thing is that prcessLine extracts some information from a line, that I'd like to save it
09:28:55 <Z`> so that I don't scan the file again
09:29:33 <Z`> I can't think of a way to accumulate that information
09:29:51 <napping> as you wrote it, any information you have is in w
09:30:04 <Z`> yes, I could change it to return a tuple perhaps
09:30:18 <Z`> but my difficulty is to accumulate the extra information
09:31:01 <Z`> or I could just make another function and call it again on the same line. a bit overheard but simpler
09:31:56 <napping> unzip or mapAccumL may be what you want
09:32:15 <Z`> thanks napping . wil read both of them
09:32:40 <ski> @type mapAccumL
09:32:41 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:38:38 <Z`> mm, I can't paste a function declaration in ghci
09:38:47 <Z`> it wants it written in a single line
09:38:56 <e98> hi guys
09:39:17 <typoclass> Z`: you can use ":l filename.hs" to load a file. you can then run all the functions in there
09:39:20 <ski> Z` : try separating the equations with `;', putting it all in one line ?
09:39:26 <e98> what's the process of uploading a new zlib to hackage which adapts the build-depends for ghc-7.6.1?
09:39:33 <Z`> typoclass: I did, but my function isn't in scope
09:39:41 <Z`> thanks ski
09:40:03 <Z`> I mean, I copied the function from the .hs file (which is a function spanning across many lines) and pasted it in ghci
09:40:56 <typoclass> Z`: hm. if you have a line like "module Something" at the top, make sure you're exporting the function you want to run. also, try ":l Something.hs" + "import Something"
09:41:10 <c_wraith> Z`: why not just load the file that has the function?
09:41:25 <Z`> I don't have the word module inside the file anywhere
09:41:33 <typoclass> c_wraith: he says it's not in scope when he does that
09:42:04 <c_wraith> Oh.  Do you have a compiled version of that file in the same directory?
09:42:10 <Z`> yes, probably
09:42:17 <c_wraith> then use  :l *filename.hs
09:42:37 <c_wraith> that forces it to interpret it, rather than use the compiled version, which probably has that function inlined away
09:42:45 <Z`> oO it worked..
09:43:07 <Z`> (thanks)
09:53:13 <Z`> when I bind an expression to a variable, like: let x = map somef somelist
09:53:16 <Z`> and type 'x' in ghci
09:53:20 <Z`> is the expression reevaluated ?
09:53:26 <Z`> again and again, every time I hit 'x' ?
09:54:17 <qwr> probably not, but why should it matter?
09:55:07 <qwr> you can try with some time-consuming-to-calculate expression
09:55:11 <qwr> like let x = length [1..100000000]
09:56:30 <Z`> alright.thanks
10:00:22 <djanatyn> > let juxt fs x = map (\f -> f x) fs in juxt [(+2) (+3) (+4)] 1
10:00:25 <lambdabot>   [10]
10:01:09 <shachaf> > sequence [(+2) (+3) (+4)] 1
10:01:10 <lambdabot>   [10]
10:01:20 <shachaf> > sequence [(+2), (+3), (+4)] 1
10:01:22 <lambdabot>   [3,4,5]
10:01:31 <shachaf> > map ($ 1) [(+2), (+3), (+4)]
10:01:33 <lambdabot>   [3,4,5]
10:01:34 <djanatyn> oops, too much lisp
10:01:41 <ski> > (+2) (+3) (+4) 1
10:01:42 <djanatyn> forgot my commas :)
10:01:42 <lambdabot>   10
10:02:27 <Z`> why could this:  [x, y, z] | y `elem` yy -> [[x, y], z] return a type error for z ?
10:02:55 <Botje> [[x,y], z]in itself is already a type error.
10:03:04 <Z`> I can't construct lists like that? ok
10:03:43 <Z`> ah right, lists are homogenous
10:03:45 <Z`> in haskell
10:03:52 <Botje> no. haskell demands all list elements have the same type
10:04:25 <Z`> ok, so I'll just write [[x,y], [z]] :P
10:07:53 <benmachine> Botje: pedantically, it's a type error assuming z is not a list of xs, which use in [x,y,z] demands is the case
10:22:12 * hackagebot X11 1.6.0.2 - A binding to the X11 graphics library  http://hackage.haskell.org/package/X11-1.6.0.2 (DanielWagner)
10:23:54 <shachaf> It would be nice if it was possible to alloca $ \(a,b,c,d) -> ... instead of using four alloca calls.
10:24:20 <shachaf> Though a (Storable a,Storable b) => Storable (a,b) instance isn't really morally correct...
10:24:58 <Ferdirand> why so ?
10:25:17 <shachaf> Which which?
10:25:42 <Ferdirand> why not morally correct
10:26:04 <Ferdirand> i dont'know storable, but just curious
10:26:28 <shachaf> Well, *maybe* it's morally correct if you just store a and b contiguous in memory or something.
10:26:52 <shachaf> And then you can implement peek and poke and all that.
10:26:59 <shachaf> That wasn't what I meant with alloca, though. Though maybe it would be reasonable.
10:27:34 <Ferdirand> need to read more on that
10:27:46 <Ferdirand> thanks for the insight :)
10:29:37 <ski> @type runContT (liftM4 (,,,) (ContT Foreign.alloca) (ContT Foreign.alloca) (ContT Foreign.alloca) (ContT Foreign.alloca))
10:29:38 <lambdabot> forall a r a1 a2 a3. (Foreign.Storable.Storable a, Foreign.Storable.Storable a1, Foreign.Storable.Storable a2, Foreign.Storable.Storable a3) => ((GHC.Ptr.Ptr a, GHC.Ptr.Ptr a1, GHC.Ptr.Ptr a2, GHC.
10:29:38 <lambdabot> Ptr.Ptr a3) -> IO r) -> IO r
10:32:13 * hackagebot MFlow 0.0.5 - Web application serverfor processes with type safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.0.5 (AlbertoCorona)
10:42:13 * hackagebot MFlow 0.0.5.1 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.0.5.1 (AlbertoCorona)
10:42:15 * hackagebot reactive-bacon 0.4.1 - FRP (functional reactive programming) framework  http://hackage.haskell.org/package/reactive-bacon-0.4.1 (JuhaPaananen)
10:46:15 <rudyl313> is anybody else finding Hackage to be really unreliable the last couple days?
10:47:42 <typoclass> rudyl313: yes 1 or 2 days ago people talked about some dns issue that caused it to be unreachable from large portions of the internet
10:48:07 <c_wraith> in particular, anonymous brought down godaddy's DNS servers.  That took out a lot of websites
10:48:24 <rudyl313> oh lame
10:49:17 <rudyl313> looks like I will have to use google cache to browse hackage
10:49:40 <sm> godaddy denies it was a DDOS
10:50:03 <c_wraith> that's not the only way to bring down a server
10:50:22 <c_wraith> anon claimed credit.  that's all I know
10:50:28 <sm> ah
10:51:48 <rudyl313> godaddy's system alerts show that the issue is resolved, and yet I can't connect to hackage right now http://support.godaddy.com/system-alerts/
10:52:15 <Saizan> it kept working fine for me with google's DNS
10:52:33 <rwbarton> Someone here said earlier that haskell.org DNS isn't hosted by godaddy.
10:52:59 <c_wraith> hmm.  Well, hackage seems to be up for me.  So...  it must be having some other kind of issues
10:53:54 <geekosaur> Someone other than godaddy seems to be having issues as well... there's some other sites I can't reach, also not involved with godaddy
10:54:05 <rudyl313> seems to be back up now
10:54:11 <rudyl313> strange
10:54:42 <Z`> Suppose I have a list: let x = [[1,2], [3,4], [5,6]] and I'd like to get [[1,3,5], [2,4,6]] with mapAccumL. Could it be done ?
10:54:58 <sclv> hackage still out for me, but new-hackage fine. who knows
10:55:38 <c_wraith> Z`: is there any reason to not just use transpose?
10:57:48 <Z`> for example I would like to return the 1st item of each sublist into its own list, and also the 2nd item of each list agumented by 1 (not a real case, just want to understand mapAccumL beyond the examples in the docs)
10:58:23 <ski> > foldr (zipWith (:)) (repeat []) [[1,2], [3,4], [5,6]]
10:58:25 <lambdabot>   [[1,3,5],[2,4,6]]
11:00:07 <Z`> ok.. so it can't be done with mapAccumL ?
11:00:13 <ski> > mapAccumL (\acc a -> (a + acc :: Expr,a^2)) 100 [0,1,2,3]
11:00:14 <lambdabot>   (3 + (2 + (1 + (0 + 100))),[0 * 0,1 * 1,2 * 2,3 * 3])
11:00:18 <c_wraith> It probably *can*
11:00:20 <c_wraith> But why?
11:00:28 <efie> I'm searching for a library to 1) play audio files and 2) to concat severals ones to one  file. formats: mp3 or wav. Can someone suggest a (best very simple) library for this? I looked thtrough http://hackage.haskell.org/packages/archive/pkg-list.html#cat:sound but I couldn't find one with an easy example for example how to play a audio file
11:00:49 <Z`> the docs have only examples where the state parameter is integral. i'd like to see an example with accumulating into a list
11:01:30 <ski> do you have any example doing that, with explicit recursion ?
11:01:34 <c_wraith> Does that change anything?
11:01:52 <statusfailed> Is it a bad idea to be using [] for streaming data?
11:01:59 <c_wraith> I mean.. An accumulator is an accumulator.
11:02:23 <ski> statusfailed : not sure what you mean ..
11:02:26 <c_wraith> :t mapAccumL
11:02:28 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:02:44 <zzing> I want to make a set of data structures that reference each other. So my Planet type has an owner, the owner is a Player and player has properties. Is there a way that I can link these together without maintaining separate copies or resorting to some kind of an index that would break easily?
11:02:54 <Z`> never mind. I'll think an example. Thanks!
11:03:36 <statusfailed> ski: If i have a possibly infinite stream of items, say from a socket, is using [] a bad idea?
11:03:38 <c_wraith> > mapAccumL (\xs -> x -> (x:xs, x + 1)) [] [1, 2, 3, 4, 5]
11:03:40 <lambdabot>   Pattern syntax in expression context: \ xs -> x -> (x : xs, x + 1)
11:03:45 <c_wraith> heh, oops
11:03:49 <statusfailed> I just realised I have a space leak because I later evaluate the length of the list i'm using, but I still want to know :p
11:03:50 <c_wraith> > mapAccumL (\xs x -> (x:xs, x + 1)) [] [1, 2, 3, 4, 5]
11:03:52 <lambdabot>   ([5,4,3,2,1],[2,3,4,5,6])
11:03:59 <c_wraith> The accumulator is a list.
11:04:01 <c_wraith> Nothing special
11:04:04 <ski> statusfailed : not necessarily
11:04:51 <ski> statusfailed : you could increment a count as you go, i suppose
11:05:02 <ski> or `zip [0 ..]'
11:05:17 <Nisstyre-laptop> zzing: data Planet n o = Planet n (Player o) ?
11:05:57 <zzing> Nisstyre-laptop, that would be a copy of the player. What I need I guess is some kind of reference.
11:06:04 <statusfailed> ski: oh, that zip would work
11:06:15 <zzing> I also need to be able to store planets in a data structure like a sequence or list
11:06:58 <Nisstyre-laptop> okay, well I don't know, but I have to go
11:10:54 <hpaste> danald pasted “ghc panic when using TypeLits without importing GHC.TypeLits” at http://hpaste.org/74597
11:12:15 * hackagebot MFlow 0.0.5.2 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.0.5.2 (AlbertoCorona)
11:26:10 <hpaste> int80_h annotated “reactive banana sanity check” with “reactive banana sanity check (annotation)” at http://hpaste.org/74588#a74598
11:28:03 <int80_h> hmm, that's not what I intended. anyway, I needed someone to talk about reactive-banana with.
11:33:55 <mm_freak> int80_h: your best bet is to contact the author
12:05:47 <int80_h>  mm_freak: good idea, thanks :)
12:14:54 <Hadaka> argh, is there a *good* tutorial in the usage of Control.Exception? all I'm working on is examples from there and some random snippets of code
12:14:56 <hiptobecubic> @pl  \p -> p || not p
12:14:57 <lambdabot> ap (||) not
12:15:01 <hiptobecubic> What's going on there?
12:15:30 <mm_freak> Hadaka: doesn't the module's haddock documentation cover everything?
12:16:26 <Hadaka> mm_freak: probably so if I understood Haskell a little better, or Typeable, or the implementation of Control.Exception
12:16:57 <latro`a_> hiptobecubic: for (->), ap f g x = f x (g x)
12:17:26 <latro`a_> more generally, ap fs xs = do {f <- fs; x <- xs; return (f x)}
12:17:33 <latro`a_> for any monad
12:17:41 <hiptobecubic> hm
12:17:56 <latro`a_> ap is also the same as <*> in Applicative, but specialized to monads only
12:18:00 <geekosaur> aka primitive reader monad
12:18:04 <ski> `ap f g x = f x (g x)' is the `S'-combinator
12:18:29 <hiptobecubic> I haven't actually studied lambda calculus, so that's not as helpful as it should be :/
12:18:46 <latro`a_> not really that important, but you should probably look up applicative functors nonetheless
12:18:50 <latro`a_> er
12:19:04 <latro`a_> the name "S combinator" isn't that important for practical use, is what I meant
12:19:12 <hiptobecubic> latro`a_, I have. I'm slowly coming to understand it.
12:19:26 <mm_freak> Hadaka: types of the Typeable class are basically just types, for which you can ask for the type at runtime
12:19:29 <latro`a_> some people have an easier time understanding applicatives using their "categorical" definition
12:19:47 <mm_freak> Hadaka: SomeException envelopes an arbitrary exception of an arbitrary exception type
12:19:53 <latro`a_> which is class Applicative f where unit :: f (); pair :: f a -> f b -> f (a,b)
12:19:58 <latro`a_> (I forget the usual categorical name for pair)
12:20:00 <mm_freak> Hadaka: that way using 'catch' you can catch certain exception types
12:20:06 <mm_freak> hence the Typeable constraint
12:20:34 <latro`a_> then the normal Applicative functions are pure x = fmap (const x) unit, and fs <*> xs = fmap (\(f,x) -> f x) (pair fs xs)
12:21:06 <hiptobecubic> fmap (const x) unit?
12:21:38 <ski> you can say `\() -> x' instead of `const x', if you prefer
12:21:59 <hiptobecubic> oh, the unit is just to feed to const
12:22:00 <hiptobecubic> ok
12:22:03 <latro`a_> I think unit is probably throwing him off more
12:22:22 <latro`a_> example values of unit are [()], Just (), etc.
12:22:28 <hiptobecubic> yes
12:22:41 <latro`a_> they have no "structure" in the sense that pair unit xs = fmap (\x -> ((),x) xs
12:22:43 <hiptobecubic> i get it now
12:22:44 <Hadaka> mm_freak: why does the type I declare for my exception handler function change the exceptions that are caught? how does the code even dig out what type it is?
12:22:44 <latro`a_> er
12:22:47 <latro`a_> missed a paren
12:22:51 <mm_freak> ski: that's not the same as const x though
12:22:54 <latro`a_> pair unit xs = fmap (\x -> ((),x)) xs
12:23:12 <mm_freak> Hadaka: Typeable =)
12:23:34 <latro`a_> hrm
12:23:37 <latro`a_> :t fmap curry
12:23:39 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f ((a, b) -> c) -> f (a -> b -> c)
12:23:40 <ski> mm_freak : not counting strictness, no
12:24:03 <ski> (and then arguably `\() -> x' seems more right, to me)
12:24:05 <latro`a_> @pl (\f,x) -> f x
12:24:05 <lambdabot> (line 1, column 6):
12:24:05 <lambdabot> unexpected ")"
12:24:05 <lambdabot> expecting letter or digit, operator, ",", pattern or "->"
12:24:10 <latro`a_> wat
12:24:13 <latro`a_> er
12:24:13 <latro`a_> duh
12:24:17 <latro`a_> @pl \(f,x) -> f x
12:24:18 <lambdabot> ap fst snd
12:24:30 <latro`a_> circular then, I guess
12:24:35 <hiptobecubic> did not see that coming
12:24:40 <Hadaka> mm_freak: I can somehow fathom that I can declare a datatype (data) as Typeable - but how does it dig out the type of my handler? that's just a function? or is my handler something like Typeable e => e -> ()?
12:25:17 <ski> @type Control.Exception.catch
12:25:18 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
12:25:35 <ski> Hadaka : see the `Exception e =>' there
12:26:06 <mm_freak> Hadaka: class (Show e, Typeable e) => Exception e
12:26:13 <mm_freak> every exception type is also a Typeable
12:26:17 <ski> Hadaka : you can think of it as `catch' secretly getting an extra implict argument of "type" `Exception e'
12:26:36 <hiptobecubic> Why is ap defined that way for (->) ?
12:26:51 <ski> this contains information about what type `e' is -- and then when catching an exception, the types has to match
12:26:53 <hiptobecubic> ap f g x = f x (g x)  ?
12:26:59 <Eduard_Munteanu> It's not (->), but (r ->)
12:27:16 <hiptobecubic> Eduard_Munteanu, why (r ->)
12:27:27 <latro`a_> hiptobecubic, if you go via pair, it might be more obvious
12:27:33 <latro`a_> pair :: f a -> f b -> f (a,b)
12:27:34 <latro`a_> which means
12:27:40 <Eduard_Munteanu> :k (->)
12:27:42 <lambdabot> ?? -> ? -> *
12:27:42 <ski> hiptobecubic : it is defined as latro`a_ said (in a generic way), `ap f g x = f x (g x)' is just a simplification of it, in the case of `Monad (r ->)'
12:27:43 <latro`a_> pair :: (r->a) -> (r->b) -> (r->(a,b))
12:28:06 <mm_freak> hiptobecubic: 'ap' is the same as (<*>), but with a Monad constraint and rerived automatically from the Monad instance
12:28:09 <latro`a_> which makes it clear that pair f g x = (f x,g x)
12:28:27 <latro`a_> then <*> follows
12:28:33 <mm_freak> hiptobecubic: and (<*>) is really just a generalization of the S combinator
12:28:48 <Eduard_Munteanu> hiptobecubic: f a where f = (->) doesn't give you anything sensible
12:28:59 <Hadaka> hmmh
12:29:01 <mm_freak> which in the '(->) r' monad is just the actual classic S combinator
12:29:12 <Eduard_Munteanu> This is just the naked reader monad functor.
12:29:23 <latro`a_> referencing the S combinator doesn't really help here
12:29:33 <hiptobecubic> No sadly. It does not :/
12:29:39 <latro`a_> in that you could just as easily help with the S combinator from here
12:29:44 <mm_freak> hiptobecubic: do you know SK calculus?
12:29:44 <latro`a_> but
12:29:50 <mm_freak> S f g x = f x (g x)
12:29:55 <Hadaka> it's still hard for me to see how the results of type inference can be available to the code to query
12:29:55 <mm_freak> K x y = x
12:30:01 <latro`a_> clearly pair :: (r -> a) -> (r -> b) -> (r -> (a,b))
12:30:09 <latro`a_> means pair f g x = (f x,g x)
12:30:17 <hiptobecubic> mm_freak, not anymore than what you just said.
12:30:17 <mm_freak> the Applicative class generalizes this calculus, and 'ap' is really just an applicative functor operation
12:30:25 <hiptobecubic> mm_freak, and not practically.
12:30:44 <mm_freak> hiptobecubic: what i just said is the SK calculus…  it's turing-complete, just like lambda calculus
12:31:04 <latro`a_> then f <*> g = fmap (\(f,x) -> f x) (pair f g), or (\(f,x) -> f x) . pair f g
12:32:03 <latro`a_> so you have (\(f,x) -> f x) . (\x -> (f x,g x))
12:32:10 <latro`a_> which is precisely \x -> f x (g x)
12:32:23 <latro`a_> err...bah, must've made a mistake somewhere, dammit
12:32:41 <latro`a_> uh...oh, no I didn't
12:32:41 <Hadaka> say I have data Foo deriving (Typeable) and data Bar deriving (Typeable) - now, if I write \(x :: Foo) -> return () somewhere, I can somehow write code that can ask from the function (at runtime?) which type it takes in as a parameter?
12:32:45 <mm_freak> not sure if this 'pair' approach is really a good way to teach all this
12:32:56 <latro`a_> mm_freak: it helps in the generic setting I think
12:33:08 <latro`a_> less in the ((->) r) setting
12:33:10 <mm_freak> Hadaka: yes, see the Typeable class
12:33:21 <hiptobecubic> the problem is that I can clearly see *what* ap is doing. Just not why
12:33:44 <rwbarton> presumably he knows to see the Typeable class, given the first part of the question
12:33:52 <mm_freak> hiptobecubic: cf `ap` cx = do f <- cf; x <- cx; return (f x)
12:34:04 <latro`a_> <*> in the function case is pretty much the only function of the right type
12:34:23 <mm_freak> > ap (Just sin) (Just 3)
12:34:24 <lambdabot>   Just 0.1411200080598672
12:34:37 <latro`a_> proceeding directly you get (<*>) :: (r->a->b) -> (r->a) -> (r->b)
12:35:01 <mm_freak> > ap (Just sin) Nothing
12:35:02 <lambdabot>   Nothing
12:35:22 <Hadaka> mm_freak: are *all* functions Typeable automatically?
12:35:25 <Nereid> @type liftA2 ($)
12:35:27 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
12:35:30 <latro`a_> so you need to be able to apply the output function to an r and get a b, which means you need to apply the first argument to an r and an a; since there's only one way to get an r, the r is the input, and since there's only one way to get an a, the a is from the second argument
12:35:40 <latro`a_> nereid: circular
12:35:43 <Nereid> ;)
12:35:52 <mm_freak> Hadaka: if the input/output types are, then yes
12:35:57 <ski> Hadaka : "I can somehow write code that can ask from the function (at runtime?) which type it takes in as a parameter?" -- at compile-time, information about which type `e' is will be inserted in the call to `catch' -- however it may in some cases be that this information isn't actually statically know, but just extracted from other values passed around at run-time
12:36:12 <Nereid> latro`a_: but it might help with intuition
12:36:18 <Nereid> I dunno
12:36:24 <mm_freak> Hadaka: well, almost…  functions are Typeable2
12:37:01 <mm_freak> well, apparently they are also Typeable
12:37:04 <mm_freak> > typeOf sin
12:37:05 <Hadaka> mm_freak: what foul wizardry is this? why are they that automatically?
12:37:05 <lambdabot>   Double -> Double
12:37:25 <mm_freak> Hadaka: because the instances are predefined
12:37:26 <mm_freak> Hadaka: Typeable is not magic, you could define it yourself
12:37:35 <latro`a_> hiptobecubic,
12:37:39 <ski> Hadaka : anyway, in no case is it possible to ask at run-time which type a certain value has. if the type, say `a', has a `Typeable a' constraint, (a run-time representation of) the type can be extracted from that constraint at run-time
12:37:42 <latro`a_> going any better?
12:37:46 <mm_freak> class RuntimeType a where getType :: a -> String
12:38:22 <ski>   instance RuntimeType Bool where getType _ = "Bool"
12:38:31 <Nereid> > typeOf undefined
12:38:33 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:38:33 <lambdabot>    `Data.Typeable.Typeable a...
12:38:40 <Nereid> > typeOf 1
12:38:41 <lambdabot>   Integer
12:38:43 <Nereid> aw.
12:38:47 <ski> > typeOf (undefined :: IO String)
12:38:48 <lambdabot>   IO [Char]
12:38:55 <ski> > typeOf (undefined `asTypeOf` getLine)
12:38:56 <Hadaka> okay, so I could declare class DickWeedable for (->) myself?
12:38:56 <lambdabot>   IO [Char]
12:39:23 <ski> > typeOf (typeOf 4)
12:39:24 <lambdabot>   TypeRep
12:39:25 <hiptobecubic> latro`a_, i can see why it does what it does for something like Maybe
12:39:31 <ski> @type typeRep
12:39:32 <lambdabot> Not in scope: `typeRep'
12:39:42 <Hadaka> ski: hmmh, okay
12:39:55 <mm_freak> Hadaka: if you have a class DickWeedable, you can define (->) instances for it (the exact shape depends on the kind of the class variables)
12:39:57 <geekosaur> @type Data.Typeable.typeRep
12:39:58 <lambdabot> Not in scope: `Data.Typeable.typeRep'
12:40:01 <ski> er
12:40:04 <ski> @type typeOf
12:40:06 <lambdabot> forall a. (Typeable a) => a -> TypeRep
12:40:06 <latro`a_> hiptobecubic, to generalize that intuition you need to figure out where the "value" lives; for functions it lives in the output after supplying one argument
12:40:15 <lightquake> when is typeable going to get polykinded?
12:40:29 <hiptobecubic> latro`a_, hmm. yes i suppose it does
12:40:40 <latro`a_> this same idea applies to the reader monad
12:40:41 <mm_freak> lightquake: when class variables are allowed to have a polymorhpic kind
12:41:10 <mm_freak> hiptobecubic: if it helps, define:  type Reader = (->)
12:41:20 <mm_freak> hiptobecubic: then 'Reader e' is a monad
12:41:27 <lightquake> mm_freak:  so, when -XPolyKinds gets to be standard?
12:41:33 <Nereid> lightquake: it's already in ghc
12:41:37 <latro`a_> I don't know if teaching applicative functors via monads really makes sense
12:41:42 <Hadaka> mm_freak: okay so - all functions are always instances of Typeable2 - and if the argument types to Typeable2 are instances of Typeable, I can query the types - right?
12:41:43 <Nereid> and well
12:41:44 <mm_freak> lightquake: i doubt that it will become standard any time soon
12:41:46 <Nereid> :v
12:42:04 <lightquake> i mean ghc is basically the de facto standard :V
12:42:04 <mm_freak> latro`a_: i wasn't sure whether you're teaching applicative functors or monads
12:42:10 <Nereid> Hadaka: (->) is an instance of Typeable2.
12:42:10 <mm_freak> but there you go, Reader e is also an Applicative
12:42:15 <ski> (s/when class variables are allowed to have a polymorhpic kind/when classes are allowed to be polymorphic/)
12:42:44 <mm_freak> Hadaka: you don't need Typeable2
12:42:47 <mm_freak> Hadaka:
12:42:50 <mm_freak> > typeOf sin
12:42:51 <lambdabot>   Double -> Double
12:43:09 <Nereid> > typeOf2 sin
12:43:10 <lambdabot>   ->
12:43:19 <ski> Hadaka : "all functions are always instances of Typeable2" -- functions are values, values can't be instances of classes, only types can be
12:43:25 <rwbarton> @type typeOf2
12:43:26 <lambdabot> forall (t :: * -> * -> *) a b. (Typeable2 t) => t a b -> TypeRep
12:43:34 <hiptobecubic> latro`a_, i always feel like there's no beginning to these things. One is defined by the other which is then explained in terms of the one again.
12:43:38 <rwbarton> @type typeOf1
12:43:40 <lambdabot> forall (t :: * -> *) a. (Typeable1 t) => t a -> TypeRep
12:43:51 <Nereid> > typeOf1 sin
12:43:52 <lambdabot>   -> Double
12:43:56 <latro`a_> every monad is an applicative functor via the definition of ap using >>= and return
12:44:05 <latro`a_> not every applicative functor is a monad
12:44:10 <rwbarton> that's ... confusing notation
12:44:12 <latro`a_> the usual counterexample is ZipList
12:44:19 <Nereid> rwbarton: it is. lol
12:44:24 <lightquake> anyway basically i want polykindd typeable to displace the non-poly-kinded one
12:44:30 <nand`> except ZipList forms a monad, just a fairly complicated one :)
12:44:31 <lightquake> but i doubt that's going to happen any time soon :(
12:44:40 <nand`> I think Const is a good example
12:44:44 <Nereid> lightquake: what would typeOf be?
12:44:57 <latro`a_> nand`, perhaps, but it's an uninteresting one
12:44:59 <latro`a_> also
12:45:04 <Hadaka> hrr
12:45:04 <latro`a_> what's ZipList's one?
12:45:08 <latro`a_> join = diag?
12:45:08 <Nereid> but it's an easy one ot understand :p
12:45:29 <lightquake> Nereid: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html#kind-polymorphism ?
12:45:29 <rwbarton> you need to take the "correct" diag
12:45:34 <ski> > typeOf2 sin `mkAppTy` typeOf False `mkAppTy` typeOf ()
12:45:35 <lambdabot>   Bool -> ()
12:45:43 <Nereid> lightquake: oh right that trick.
12:45:43 <nand`> for a strange notion of ‘uninteresting’; and I'm not fully sure on the specifics but involves something like taking the first n elements of the first n elements then doing something with them
12:46:14 <lightquake> @type mkAppTy
12:46:15 <lambdabot> TypeRep -> TypeRep -> TypeRep
12:46:29 <lightquake> cute
12:46:51 <ski> > typeOf2 sin `mkAppTy` typeOf False `mkAppTy` typeOf () `mkAppTy` typeOf1 []
12:46:53 <lambdabot>   -> Bool () []
12:47:00 <rwbarton> if you imagine the [[a]] as laid out in two dimensions then it's not simply the longest diagonal that fits in the list, it's the diagonal of the largest square that fist in the list
12:47:06 <DT`> hiptobecubic, see if this helps: http://hpaste.org/74599
12:47:21 <Nereid> lightquake: although the 7.6.1 documentation is more up to date :P
12:47:29 <lightquake> that was the first google result :P
12:47:52 <Hadaka> okay, I think I got it: class Typeable2 instance (->) requires that both type arguments are Typeable
12:48:24 <hiptobecubic> DT`, I appreciate the effort.  Why is x :: f a?
12:48:32 <hiptobecubic> Oh nevermind, f is just some type variable?
12:48:43 <hiptobecubic> yes, some functor i guess
12:48:50 <DT`> a type constructor, it might be [a], Maybe a, ...
12:48:54 <hiptobecubic> yeah
12:49:00 <Hadaka> so if I try 'typeOf x' where x is some function where the arguments are not deriving from Typeable, I get a compile error?
12:49:00 <mm_freak> hiptobecubic: what are you trying to learn exactly?  applicative functors?
12:49:25 <hiptobecubic> mm_freak, i'm trying to understand things like this in the future
12:49:28 <hiptobecubic> @pl \p -> p || not p
12:49:29 <lambdabot> ap (||) not
12:49:35 <lightquake> 15:47:30             <Hadaka> okay, I think I got it: class Typeable2 instance (->) requires that both type arguments are Typeable
12:49:38 <lightquake> no it doesn't
12:49:49 <mm_freak> hiptobecubic: do you understand the reader monad?
12:50:14 <mm_freak> s/monad/monads/
12:50:30 <Nereid> Hadaka: the Typeable (a -> b) instance requires that a and b are typeable
12:50:34 <hiptobecubic> mm_freak, the way a blind person understands color
12:50:44 <Nereid> but the Typeable2 isntance for (->) doesn't mention any specific arguments
12:50:59 <Nereid> Hadaka: Typeable2 tells you something about the *type constructor* (->)
12:51:07 <Hadaka> Nereid: ahha! okay, I just don't understand Typeable2 at all, but I guess I don't have to
12:51:12 <Nereid> yeah
12:51:13 <mm_freak> hiptobecubic: what monads do you understand already?
12:51:18 <Nereid> don't worry about it
12:51:40 <lightquake> > typeOf ((++) :: String -> String)
12:51:41 <lambdabot>   Couldn't match expected type `GHC.Base.String'
12:51:41 <lambdabot>         against inferred typ...
12:51:49 <lightquake> > typeOf ((++) :: String -> String -> String)
12:51:52 <lambdabot>   [Char] -> [Char] -> [Char]
12:51:52 <Nereid> > typeOf (Prelude.++)
12:51:53 <lambdabot>   Not in scope: `Prelude.++'
12:51:55 <Nereid> oh.
12:52:06 <Nereid> > typeOf (++) -- I knew it.
12:52:07 <lambdabot>   Ambiguous type variable `m' in the constraints:
12:52:08 <lambdabot>    `Data.Monoid.Monoid m'
12:52:08 <lambdabot>  ...
12:52:18 <Nereid> damn you caaaaaaaaaale!
12:52:51 <mm_freak> i'm saying it all the time…  the changed type signatures in lambdabot don't help…  they just suck
12:53:06 <Hadaka> okay, so I get an Ambiguous type variable if I call typeOf on a function which doesn't limit the type enough, and No instance for Typeable if a call typeOf on a function whose arguments are not Typeable, right?
12:53:10 <rwbarton> wait how is Prelude.++ not in scope
12:53:21 <Nereid> because cale
12:53:23 <rwbarton> import qualified Prelude hiding ((++)) -- ??
12:53:23 <Nereid> :^
12:53:37 <hiptobecubic> mm_freak, I think I get the idea of monads in general... mostly. Off the top of my head i think i understand the simpler ones pretty well. maybe, list, either, state..
12:53:37 <rwbarton> > typeOf (Prelude..)
12:53:38 <lambdabot>   Not in scope: `Prelude..'
12:53:44 <Nereid> import qualified Prelude ((.), ...)
12:53:46 <Nereid> eh what
12:53:50 <rwbarton> oh I thought that worked
12:53:52 <nand`> > typeOf (P..)
12:53:52 <Nereid> me too!
12:53:53 <lambdabot>   Ambiguous type variable `b' in the constraint:
12:53:53 <lambdabot>    `Data.Typeable.Typeable b...
12:53:57 <rwbarton> ah
12:53:58 <nand`> > typeOf (P.++)
12:53:59 <Nereid> @type (Prelude..)
12:54:00 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:54:00 <lambdabot>    `Data.Typeable.Typeable a...
12:54:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:54:05 <mm_freak> hiptobecubic: newtype State s a = State (s -> (a, s))
12:54:08 <Nereid> it's just a @type thing
12:54:14 <mm_freak> hiptobecubic: newtype Reader e a = Reader (e -> a)
12:54:15 <Hadaka> okay, I hope I'm right about this now .. gotta go afk for a while...
12:54:17 <rwbarton> that's not exactly helpful either, @type and > having such different imports
12:54:24 <Nereid> I know.
12:54:27 <rwbarton> > typeOf (P.++)
12:54:28 <nand`> yes
12:54:28 <mm_freak> hiptobecubic: so Reader is really similar to State, except that you can't update the state
12:54:29 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:54:29 <lambdabot>    `Data.Typeable.Typeable a...
12:54:31 <Cale> I have no idea where @type gets its imports
12:54:32 <nand`> also where are my lenses? :(
12:54:36 <hiptobecubic> mm_freak, right ok. sure
12:54:37 <nand`> Cale: ~/.ghci
12:54:49 <Cale> nand`: hmm
12:55:00 <mm_freak> hiptobecubic: now you can go ahead and define Reader like this:  type Reader e a = e -> a
12:55:01 <hiptobecubic> mm_freak, doesn't seem quite so useful, but sure.
12:55:06 <Nereid> @typeOf2 (++)
12:55:07 <lambdabot> Unknown command, try @list
12:55:09 <Nereid> > typeOf2 (++)
12:55:10 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:55:10 <lambdabot>    `Data.Monoid.Monoid a'
12:55:10 <lambdabot>   ...
12:55:12 <Nereid> yeah.
12:55:18 <Nereid> > typeOf2 ((++) :: [a] -> [a] -> [a])
12:55:19 <mm_freak> hiptobecubic: now Reader e a is really the same as e -> a
12:55:20 <lambdabot>   ->
12:55:23 <Nereid> duh.
12:55:35 <mm_freak> hiptobecubic: Reader e = (e ->)  -- pseudosyntax
12:55:37 <ski> mm_freak : hm, changed how ?
12:55:41 <mm_freak> and that's a monad
12:55:50 <mm_freak> ski: ?
12:56:13 <Nereid> mm_freak: is there a nice adjunction that it comes from?
12:56:14 <ski> "the changed type signatures in lambdabot don't help…  they just suck"
12:56:29 <mm_freak> hiptobecubic: now consider 'ask' for the real Reader monad:  ask = Reader id
12:56:36 <hiptobecubic> mm_freak, by not specifying what e goes to?
12:56:45 <mm_freak> hiptobecubic: yes
12:57:00 <Nereid> Reader e a ~~ e -> a
12:57:05 <mm_freak> hiptobecubic: now go implement the Reader monads yourself =)
12:57:12 <mm_freak> ski:
12:57:14 <mm_freak> :t (.)
12:57:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:57:17 <ski> @unmtl Reader rho a
12:57:17 <lambdabot> rho -> a
12:57:33 <nand`> Nereid: writer e is adjoint to reader e
12:57:34 <mm_freak> hiptobecubic: start like this:  newtype Reader e a = Reader (e -> a)
12:57:43 <ski> mm_freak : oh, Caleskell
12:57:57 <Nereid> nand`: no, I mean
12:58:00 <Nereid> monads come from adjunctions
12:58:10 <Nereid> e.g. State comes from the adjunction between (s ->) and (,s)
12:59:05 <rwbarton> I think it's something like the diagonal/product adjunction between Hask and Hask^e
12:59:12 <rwbarton> having not really thought about it
12:59:19 <Nereid> hmm
12:59:29 <rwbarton> also that only really makes sense for Set but I usually pretend Hask = Set
12:59:35 <Nereid> sure ;)
12:59:49 <Nereid> I'll think about it later.
12:59:52 <Nereid> gotta go.
13:00:42 <nand`> main difference between Hask and Set is that Hask functions aren't total, right?
13:01:41 <Nereid> nand`: well Hask is more like domains than sets.
13:02:47 <Eduard_Munteanu> And Hask only gives you, well, computable functions.
13:03:22 <nand`> ah, yeah
13:03:24 <rwbarton> Hask has a very limited supply of objects, you can't form quotients for example
13:03:44 <nand`> quotients?
13:04:13 <ski> conceptually we form subobjects and quotients, using abstract data types
13:04:23 <rwbarton> like "take the type Integer but identify x and negate x for all x"
13:04:25 <rwbarton> for example
13:04:51 <ski> nand` : e.g. treating two different trees representing the same (finite) set as the same
13:05:02 <rwbarton> yes, a more practical example :)
13:05:32 <ski> nand` : implementing rationals as a pair of (not necessary normalized) integers is another example
13:05:59 <rwbarton> for subobjects: allowing only, say, sorted lists among [Int] or rationals in reduced form among (Int, Int)
13:06:24 <ski> (as well as disallowing the denominator from being zero)
13:06:32 <Eduard_Munteanu> That kinda follows from the lack of subtyping.
13:06:42 <rwbarton> if I have a set S and a function f : S -> Bool I can form the subset of elements of S on which f is true, but I can't do that if you replace "set" by "type" everywhere
13:07:25 <rwbarton> well even if I don't want a "subtype" in the type theory sense but just want a type S' with an injection S' -> S, I still can't do it
13:08:23 <Eduard_Munteanu> Ah.
13:08:33 <nand`> ski: I see
13:08:43 <rwbarton> at least, not in any general way; in many particular instances I might have an ad-hoc way to do it
13:09:11 <ski> nand` : sometimes one thinks of the values in the quotient set as being "equivalence classes" of values from the original set
13:12:10 <Hadaka> okay, one more thing I don't get
13:12:15 <Hadaka> I have a function which takes in an exception, and returns a datatype which is not Typeable
13:12:22 <Hadaka> calling typeOf on this function results in a compilation error
13:12:28 <Hadaka> how is this function still usable as an exception handler?
13:13:16 <c_wraith> the exception type must be an instance of Typeable
13:13:27 <c_wraith> There's no requirement that the handler type must be an instance of Typeable
13:13:36 <rwbarton> you can use a trick like this
13:13:52 <Hadaka> so how do you dig out the type of the first argument to the function without getting the type of the function?
13:13:52 <rwbarton> if I have f :: a -> b and I want the runtime representation of a
13:14:01 <rwbarton> argType :: (a -> b) -> a; argType f = undefined
13:14:10 <rwbarton> then typeOf (argType f)
13:14:21 <Hadaka> rwbarton: ahha!
13:14:38 <c_wraith> Hadaka: you don't.  It's known at compile time, not runtime.
13:14:40 <ski> key is that `typeOf' never looks at its argument
13:15:13 <rwbarton> it's the kind of trick that is so stupid you probably won't think of it unless you have seen it before :)
13:15:20 <Hadaka> ski: I think I understood that - I just didn't understand how you could get the type of the argument without the type of the function being typeable
13:15:37 <Hadaka> rwbarton: yeah, it is really simple now that it has been shown
13:17:12 <Hadaka> so, to bastardize the whole thing in to an explanation I can grok: "you use type inference to create a new value whose type is the argument type to the function" and that type is then typeable because of the Exception constraint, even though the function is not
13:17:27 <rwbarton> you can usually (always?) also do something more complicated using asTypeOf without having to write a type signature
13:17:47 <mm_freak> Hadaka: i recommend implementing a custom class to get run-time type information
13:18:14 <mm_freak> Hadaka: start like this:  class MyTypeable a where myTypeOf :: a -> String
13:18:17 <mm_freak> (String for simplicity)
13:18:18 <Hadaka> yeah, I think I understand the basic gist of it now, and now it almost sort of makes sense why typing matters for the exception handler functions even if the exception argument is not used anywhere
13:18:48 <mm_freak> yes, the type determines semantics
13:19:39 <zomg> Hadaka: apron or without apron?
13:19:40 <zomg> lol
13:21:03 <Hadaka> okay, so then one more thing - this means that I can never write a handler that handles both IOException and ArithException as the argument can't be both types at once, can I?
13:22:18 * hackagebot ghc-syb-utils 0.2.1.1 - Scrap Your Boilerplate utilities for the GHC API.  http://hackage.haskell.org/package/ghc-syb-utils-0.2.1.1 (ThomasSchilling)
13:22:47 <c_wraith> Hadaka: that is...  half-true.
13:23:11 <c_wraith> Hadaka: you can't do it the very straight-forward way.  You can, however, branch on attempting to convert it to the types in question
13:23:24 <mm_freak> Hadaka: c `catch` handler1 `catch` handler2
13:23:32 <c_wraith> Hadaka: But unless there's a lot of shared code, you're better off using catches
13:23:34 <mm_freak> just like in your favorite imperative language
13:23:50 <efie> during the cabal install of Haskore I get the following error : "ghc: could not execute: /usr/local/lib/ghc-7.4.2/unlit". I looked into the ghc-7.4.2 folder, but there is no "unlit" file. What can I do?
13:24:11 <c_wraith> efie: how did you install GHC?
13:24:39 <efie> c_wraith: I think I installed it via the haskell platform
13:25:58 <benmachine> efie: weird, I have that file
13:26:03 <benmachine> I didn't install from HP though
13:26:09 <c_wraith> Hmm.  It sounds like a broken install.  I'm not sure how that would have happened unless you're using like debian's install
13:26:23 <c_wraith> since the .deb packaging intentionally breaks GHC into like 5 pieces
13:26:34 <Hadaka> okay so handleIO :: IOException -> IO (); handleIO _ == realHandler; handleArith :: ArithException -> IO (); handleArith _ = realHandler; c `catch` handleIO `catch` handleArith?
13:26:58 <Hadaka> I'm not really going to write this, don't worry :)
13:27:04 <c_wraith> that would work, yes
13:27:09 <efie> I just saw that there is this unlit file in my ghc-7.0.4 folder. probably something during the update went wrong? maybe it works if I just copy the file?
13:27:11 <benmachine> Hadaka: single equals sign not double, otherwise yes
13:27:16 <Hadaka> benmachine: yeah, typo
13:27:40 <benmachine> efie: it might do, but I'd be more inclined to either find out what was wrong or try reinstalling
13:27:48 <benmachine> efie: you don't know what else might have gone wrong
13:28:24 <Hadaka> or, c `catches` [Handler handleIO, Handler handleArith]
13:28:27 <efie> benmachine: hm yeah
13:28:47 <Hadaka> okay, thank you all, I think my understanding of typeable and exceptions is a lot broader now
13:29:02 <joeyh> I have a problem where I got a Socket allocated with Network.Socket.socket, but it's not open, and so sClose doesn't deallocate it. Could really use a hand with this https://github.com/audreyt/network-multicast/issues/2
13:29:18 <Hadaka> and now I gotta take the dogs out
13:29:24 <startling> how do I "sequence" s -> k -> m s given a [k]?
13:30:00 <shachaf> @ty foldM
13:30:01 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:30:28 <shachaf> @hoogle (s -> k -> m s) -> [k] -> something
13:30:29 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:30:29 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
13:30:29 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
13:31:00 <startling> ooh, thanks
13:38:49 <msieradzki> is cabal-install 1.15.2+ silent by default or did I just get it to be silent by weird .cabal/config?
13:45:08 <johnw> where did you get cabal-install 1.15?
13:45:08 <lambdabot> johnw: You have 3 new messages. '/msg lambdabot @messages' to read them.
13:48:57 <shachaf> johnw: Yesterday I tried out the thing I mentioned on your code.
13:49:05 <shachaf> I may have overdone it a bit.
13:49:31 <johnw> :)
13:51:26 <shachaf> johnw: http://slbkbs.org/johnw.diff is the general idea.
13:51:35 <shachaf> It's mostly mindless.
13:51:56 <johnw> L.foldr (.) id . map (uncurry overrideType . parseLine)
13:51:59 <johnw> :(
13:52:16 <johnw> wow, you really went all out
13:52:27 <shachaf> johnw: OK, that was a bit far.
13:52:50 <shachaf> I don't recommend taking those changes as-is.
13:53:08 <parcs`> shachaf: is that a .h -> .hs converter
13:53:22 <johnw> parcs`: .h -> .hsc
13:53:32 <parcs`> oh right
13:54:17 <parcs`> nice
13:54:32 <parcs`> one of those would be very handy
13:54:39 <johnw> cabal install c2hsc
13:54:52 <johnw> it's capable enough now to do most of the work
13:55:07 <johnw> but I don't think it will ever do all of the work
13:56:19 <Igloo> Is there a working hackage-reverse-deps site anywhere at the moment?
13:56:40 <benmachine> Igloo: http://packdeps.haskellers.com/reverse perhaps
13:56:51 <benmachine> unless you meant hackage-2.0-with-revdeps-enabled
13:57:15 <Igloo> No, thanks, that's great!
13:58:19 <johnw> that list is a bit out of date, isn't it?
13:58:23 <johnw> i see none of my packages on it
13:58:57 <johnw> huh, I see them on packdeps
13:59:00 <johnw> just not /reverse
14:03:00 <msieradzki> johnw, git
14:03:08 <johnw> yes?
14:03:24 <benmachine> johnw: maybe none of your packages have any revdeps? >_>
14:03:27 <msieradzki> anyway nvm because newer cabal-install is really more silent
14:03:31 <johnw> oh, that could be :)
14:03:46 <msieradzki> for instance https://gist.github.com/3032723 I just didn't know that
14:04:36 <Z`> Can I have a function that reads a file and returns a string with the contents ? or all IO needs to be inside main ?
14:04:49 <startling> :t readFile
14:04:51 <lambdabot> FilePath -> IO String
14:04:57 <startling> it's not a function, though
14:05:19 <Z`> I mean, call readFile from inside a function, rathen than inside main = do ...
14:05:27 <startling> and for it to be executed, it needs to be called (possibly indirectly) by main.
14:05:32 <Z`> (readFile / openFile / hGetContents / whatever)
14:05:47 <Z`> ok
14:06:21 <startling> Z`: you can do "x = readFile "hi.txt"" and main = do { myfile <- x; ... }", if that's what you're asking
14:10:07 <Z`> I was imagining something like: loadFile = do { h <- openFile "..."; let mylines = fmap lines (hGetContents h); ... }
14:10:40 <startling> :t fmap lines (hGetContents h)
14:10:42 <lambdabot> Not in scope: `hGetContents'
14:11:04 <startling> bah
14:11:07 <startling> Z`: yes, you can do that
14:11:21 <startling> oh wait, no you can't
14:11:22 <Z`> ok, so with both methods I end up with an IO string
14:11:39 <startling> Z`: yep
14:11:40 <mikeplus64> Z`: mylines <- fmap ...
14:11:51 <Z`> rather IO [String] in the fmap case
14:12:11 <mikeplus64> remember to close the handle when you're done :)
14:12:17 <Cale> NO
14:12:24 <Z`> I think hGetConents does that for me ?
14:12:26 <Cale> Never close a handle that you apply hGetContents to
14:12:26 <Z`> or ?
14:12:43 <Cale> hGetContents takes over that responsibility
14:12:50 <rwbarton> not much reason I can see to use openFile and then hGetContents rather than simply readFile
14:12:55 <Cale> yeah
14:12:57 <Z`> mikeplus64: I can't end my do block with mylines <- ...
14:13:17 <Cale> Z`: right, you can't, but that's okay, because you're about to do *something* with those lines
14:13:32 <Z`> I wanted to return them to the caller :P
14:13:45 <Cale> Z`: oh, in that case, don't even bind the variable
14:13:48 <mikeplus64> Z`: then just end the block with fmap lines (hGetContents h)
14:13:55 <mikeplus64> Cale: oops
14:14:08 <Z`> ah ok. I was doing let mylines = fmap ... in mylines
14:14:15 <Cale> Z`: Or, of course, you can use  return mylines
14:14:33 <Cale> right, well, that'll define that action and then immediately run it
14:14:45 <Z`> duh, I forgot about return. return and >>= are the 2 operators of a monad
14:14:48 <Cale> let x = y in x
14:14:50 <Cale> is the same thing as
14:14:51 <Cale> y
14:15:20 <Cale> (unless y mentions x, in which case you might need to take care of the recursion :)
14:15:31 <Z`> Should I be worried that my function returns IO [String] rather than [String]? What are the ramifications of it ?
14:15:37 <Z`> heh:)
14:16:02 <Cale> a value of type IO t represents an action which, if executed, will produce a value of type t
14:16:12 <Cale> You can only execute IO actions from inside other IO actions
14:16:20 <Z`> so wait!
14:16:23 <Cale> evaluating IO actions is not the same thing as executing them
14:16:41 <Z`> my function doesn't return the contents of the file but rather an action that if executed will return the conents of the file ?
14:16:47 <Cale> yes
14:16:51 <Z`> wow! just wow!
14:16:53 <Z`> I'm wet.
14:17:07 <Cale> also, it's not even a function, the way you have it here
14:17:12 <Cale> because it has no parameters
14:17:38 <Z`> mm ok. right. also If I wanted to return [String], I would have to "enforce" executing the action with like say <- ?
14:17:41 <Cale> loadFile :: IO [String]  means that loadFile is directly just an action
14:17:50 <Cale> yeah, you have to run the action with <-
14:18:19 <Z`> like, myIOLines <- fmap lines ... ; myLines <- myIOLines;
14:18:21 <Cale> when you have  v <- x  in a do-block, and  x :: IO t,  then  v :: t  and v is the result of executing x
14:19:01 <Cale> So, as a simple example, you can write
14:19:10 <Cale> main = do x <- getLine; putStrLn x
14:19:12 <Z`> ok, so suppose that I wrote: myLines <- myIOLines; then I have the [String] in myLines. How can I return that ?
14:19:23 <Cale> return myLines
14:19:25 <Z`> a ha.
14:19:38 <Z`> that won't work here (tried it already:P)
14:19:38 <Cale> and the do-block as a whole will have type  IO [String]  then
14:19:52 <Z`>     Couldn't match expected type `IO t0' with actual type `[String]'
14:19:52 <Z`>     In a stmt of a 'do' block: myLines <- myIOLines
14:19:54 <Cale> Because that's what do-blocks do
14:20:02 <Cale> they glue together actions into larger actions
14:20:17 <rwbarton> "myIOLines <- fmap lines ... ; myLines <- myIOLines" is wrong
14:20:30 <rwbarton> you ran the ... action already on the first line
14:20:36 <Cale> right
14:20:41 <rwbarton> Did you mean: let myIOLines = fmap lines ... ; myLines <- myIOLines
14:20:59 <Z`> how is that different from what I wrote ?
14:21:01 * Z` checking
14:21:11 <Cale> Z`: Remember, <- actually runs the action.
14:21:17 <Z`> ah yes oopos
14:21:36 <Cale> Z`: but the do-block as a whole becomes another IO action
14:22:05 <Cale> Z`: the action only "gets executed" inside the description of a bigger action
14:22:14 <Cale> Z`: and then in a compiled program, main is executed
14:22:32 <Cale> Z`: or if you type an action at the GHCi prompt, it will execute it for you
14:22:50 <Z`> ok, so http://paste.lisp.org/display/131758 why this still has type IO [String]
14:23:22 <Cale> Z`: Okay, if you have   do ... v <- x ...
14:23:29 <Cale> Z`: and x :: IO t
14:23:33 <Cale> Z`: then v :: t
14:23:43 <Cale> Z`: and the whole do-expression has type  IO s
14:23:59 <Cale> for possibly some different type s (whatever the type of the result of the last action in it was)
14:24:14 <Z`> ok
14:24:21 <Cale> because the v <- x is going on inside a description of another IO action
14:24:28 <Cale> right?
14:24:32 <Z`> ok
14:24:46 <Cale> So myReadFile is itself an IO action here
14:24:48 <copumpkin> > toRational (0 / 0 :: Double)
14:24:49 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
14:24:55 <Z`> but what follows v <- x is just a return
14:25:00 <Cale> right
14:25:05 <copumpkin> > toRational (1 / 0 :: Double)
14:25:06 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
14:25:10 <Cale> For IO, we have  return :: a -> IO a
14:25:14 <Z`> oh
14:25:30 <Cale> return is a function which takes a value, and makes an action which does nothing, except to return that value as its result
14:25:45 <Z`> Cale: so since everything I do in that 'function' is inside a do block, I'm bout to have an IO something at the end ?
14:25:48 <Cale> which is useful at the end of do-blocks for instance, when you want to decide for yourself which value you're returning
14:26:06 <Z`> bound*
14:26:14 <Cale> (rather than leaving it up to whatever the last action in the block would have been otherwise)
14:26:21 <Cale> in this case, it's kinda silly
14:26:30 <Cale> Whenever you have:
14:26:37 <Cale> do ... v <- x; return v
14:26:40 <Cale> this is the same as
14:26:46 <Cale> do ... x
14:27:15 <Z`> ok. so what about returning the actual array of strings here, rather than an action that if executed it will return them ?
14:27:28 <Cale> The do-block as a whole has to be an action
14:27:36 <Z`> oh
14:27:38 <Cale> which you will run from inside of another IO action
14:27:52 <Cale> and ultimately, from main, which is an IO action
14:27:57 <Z`> so even if I ran the execution at myLines <- myIOLines I'm still trapped inside a bigger IO action ?
14:28:04 <Cale> yes
14:28:14 <shachaf> Why "trapped"?
14:28:22 <Cale> But you're not really trapped in any sense
14:28:28 <shachaf> That's like saying you're "trapped" in C because everything has to be called from main().
14:28:28 <Z`> I'm putting a bit of a drama tone :P
14:28:32 <Cale> you have more permissions to do things inside an IO action than in a pure function
14:28:41 <int80_h> http://hpaste.org/74588
14:28:47 <Cale> including passing that list of strings you got to pure functions that you've written elsewhere
14:29:03 <int80_h> It's a problem with reactive-banana
14:29:18 <Z`> ok, so ! from the POV of the do block itself myLines *is* a [String]. Right ? I mean If I could break just before the return and hit :t myLines, it would print [String] ?
14:29:44 <shachaf> Yep, like Cale said above.
14:29:46 <rwbarton> this image may clarify:     dprf("mv = %d\n", mv);
14:29:48 <rwbarton> oops
14:29:49 <shachaf> 14:23 <Cale> Z`: and x :: IO t
14:29:49 <shachaf> 14:23 <Cale> Z`: then v :: t
14:29:52 <Z`> it's just that return [String] turns that into IO [String]
14:29:53 <Z`> ok
14:29:57 <rwbarton> http://4.bp.blogspot.com/_79IsVE3vX_Y/R4NaeBNqyJI/AAAAAAAAABc/MM4OvhJ3zJ4/s320/haskell-io-monad.jpg
14:30:14 <Z`> Sorry for being slow shachaf . THis is a new universe to me.
14:30:20 <Cale> Z`: we know :)
14:30:30 <shachaf> Someone pointed out to me that you can say you're "trapped in the IO monad" but you can just as reasonably say that you're "trapped outside of the IO monad".
14:30:59 <Z`> Also, Cale said that I can pass the result of myReadFile to other *pure* functions
14:31:07 <Cale> The IO monad is the side of the glass on which you really have all the power.
14:31:20 <Cale> Z`: indeed
14:31:29 <bootcode_> Z`: it may seem it is [String], but it doesn't really exist until executing the action
14:31:29 <Cale> Z`: for example
14:31:34 <Z`> I fail to see how I could do that, since I would need to have a function accepting IO [String]
14:31:38 <Cale> Z`: reverse :: [a] -> [a]
14:31:38 <bootcode_> so there is no magical way to get it out (well..)
14:31:40 <Cale> is a pure function
14:32:12 <Cale> you could write myReadFile = do h <- openFile "test.s" ReadMode; myLines <- fmap lines (hGetContents h); return (reverse myLines)
14:32:14 <Z`> bootcode_: yeh, that is assuming I ran the myLines <- myIOLines action
14:32:17 <MostAwesomeDude> @quote ls
14:32:18 <lambdabot> Vellos says: "I would strangle children with the entrails of other children to ensure a constant supply of this crack."
14:32:18 <Cale> also, look!
14:32:24 <Cale> lines :: String -> [String]
14:32:25 <MostAwesomeDude> @quote contains a list
14:32:26 <Z`> Cale: ah! you mean *inside* the do block
14:32:26 <lambdabot> No quotes for this person. :(
14:32:27 <Cale> is a pure function
14:32:28 <MostAwesomeDude> @quote contains
14:32:29 <lambdabot> astrolabe says: I put my thing in inverted commas because it isn't a really stalactite, but it looks like one, and contains nitrates from urea.
14:32:40 <Z`> I can use pure functions inside the do-block
14:32:40 <MostAwesomeDude> Dammit quotefile, stop failing me.
14:32:51 <geekosaur> @quote list.of.files
14:32:51 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:33:07 <Z`> hahaha, nice quote!
14:33:18 <int80_h> that's great
14:33:20 <Cale> Z`: right, and so you can take the results of IO actions that you captured, pass them out to pure functions which do anything you want to them, and then take the results of those pure functions and perhaps do some output of some sort
14:33:20 <johnw> that is a nice quote
14:34:05 <Z`> Cale: thanks! But! If I return an IO action from a function. Then another function accepting that as input, needs to have a do block in it where it could process/execute that action. right ?
14:35:08 <statusfailed> Should I define a MonadWhatever class for my transformer if it's just a simple composite of two others?
14:35:25 <Cale> Z`: that's right
14:35:30 <Cale> Z`: well...
14:35:39 <shachaf> statusfailed: Are you sure you need a transformer if it's just a simple composite of two others?
14:35:48 <statusfailed> shachaf: nope, but how do I combine the effects?
14:35:54 <Cale> Z`: at least sort of right -- it doesn't *need* to have a do-block, there are certainly other functions which can operate on IO actions
14:36:01 <statusfailed> Although tbh I was just learning monad transformers :p
14:36:18 <Cale> Z`: and it can certainly pass along IO actions that it gets to somewhere else -- put them in data structures or whatever
14:36:25 <shachaf> statusfailed: By making a monad?
14:36:40 <Z`> Cale: excellent. You shed some light in my darkness. thanks. will try some of the stuff we discussed here.
14:37:02 <zzing_> Can I compose Sequences like I can with lists in the Sequence monad?
14:37:05 <Cale> Z`: but in order to execute an IO action and capture its result, that's best served by do-notation. There's also an operation called >>= which is actually what do-notation translates into
14:37:11 <latro`a_> statusfailed: can you fuse any monad with your transformer?
14:37:20 * hackagebot sizes 1.1.0 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-1.1.0 (JohnWiegley)
14:37:22 <latro`a_> er
14:37:24 <latro`a_> "transformer"?
14:37:29 <statusfailed> sorry, not following there
14:37:29 <Cale> Z`: In the case of IO, we have (>>=) :: IO a -> (a -> IO b) -> IO b
14:37:35 <latro`a_> or do they only work together as one pair
14:37:57 <statusfailed> well I need both transformers, so I guess yes?
14:37:58 <Z`> Cale: neat, that corresponds perfect to the type signature of a monad: m a -> (a -> m b) -> m b
14:37:58 <Cale> Z`: that is, it takes an IO action with a result of type a, and a function from values of type a, to further IO actions having results of type b
14:38:02 <Cale> yes
14:38:20 <Cale> and it's this operation, along with return, which makes IO into a monad
14:38:36 <statusfailed> latro`a_: what do you mean by 'fuse any monad' with my transformer?
14:38:47 <Cale> But of course, there are lots of other special things about IO and ways to put IO actions together -- saying that it's a monad just tells us this tiny thing about what's available in the library.
14:38:50 <latro`a_> does it make sense to do YourMonadT SomeMonad for any SomeMonad
14:38:51 <latro`a_> ?
14:39:00 <latro`a_> or is it just YourMonadT YourOtherMonad
14:39:32 <latro`a_> basically IO being a monad lets us stick the other pieces together
14:39:52 <statusfailed> hmm.. not sure? I can think of times I'd want to add BothMonadsT to a bigger stack
14:39:56 <statusfailed> if that makes sense
14:40:05 <bootcode_> latro`a: if you have a monad transformer, is it not all or nothing? I mean if you have it you can use it for any monad, don't you?
14:41:14 <Cale> Z`: http://www.haskell.org/haskellwiki/Introduction_to_IO has a recap of what I just went through :)
14:41:20 <statusfailed> latro`a_: the main reason I made it a transformer is because you get a monad for free by just sticking Identity in there
14:41:29 <Z`> Cale: thanks <3 will read it
14:42:22 * hackagebot network-data 0.3.0 - Library for network data structures (ex: ethernet/ip/udp/tcp headers and helper functions)  http://hackage.haskell.org/package/network-data-0.3.0 (ThomasDuBuisson)
14:42:24 * hackagebot sizes 1.1.1 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-1.1.1 (JohnWiegley)
14:42:28 <latro`a_> statusfailed, sure, but does YourMonadT SomeMonad have reasonable semantics for an arbitrary monad?
14:42:46 <latro`a_> this isn't always the case even if it looks like it should be; the obvious definition of ListT is the classic example of this, as I recall
14:43:14 <statusfailed> Hmm, possibly no then
14:43:16 <bootcode_> i see
14:44:07 <latro`a_> bootcode_, you *can*, but it can fail to satisfy the monad laws
14:44:12 <latro`a_> iirc ListT will do this
14:45:40 <benmachine> ListT does indeed fail the monad laws
14:45:43 <janiczek> hi guys, how to rewrite [x | x <- xs, length x < 3] into filter ??? xs?
14:45:55 <MostAwesomeDude> janiczek: Homework?
14:45:57 <benmachine> janiczek: do you know how to use lambda functions?
14:46:08 <janiczek> i am stuck on something like filter (length . < 3) xs :D but to no avail
14:46:16 <janiczek> no, not homework, just poking around
14:46:21 <rwbarton> janiczek: close
14:46:32 <MostAwesomeDude> (\x -> length x < 3)
14:46:44 <latro`a_> but without lambdas you can do ((<3) . length)
14:46:45 <rwbarton> you want to apply length first though, and then (< 3)
14:46:55 <latro`a_> which will apply length first
14:46:56 <benmachine> latro`a_: (<3)
14:47:00 <benmachine> :P
14:47:01 <latro`a_> yes :)
14:47:16 <shachaf> Also, (length x < 3) is generally an evil thing to do.
14:47:35 <benmachine> shachaf: that's a relatively advanced topic for someone who still isn't sure how the syntax works :P
14:47:39 <janiczek> aha! :) i absolutely forgot the lambda functions are a possibility :D still so much to learn! and the point free version - hmm, probably wouldnt have guessed :D
14:47:52 <benmachine> janiczek: don't worry about pointfree for now
14:48:12 <benmachine> it's a really cool tool but you need to be comfortable with the basic function syntax first
14:48:14 <janiczek> i must look into these . and $ sometimes ... :) right now im solving these things with parentheses
14:48:22 <benmachine> parentheses are fine most of the time
14:48:25 <shachaf> benmachine: Might as well start indoctrinating them early.
14:48:47 <rwbarton> better to understand how to write with parentheses but not $ than vice versa IMO
14:48:56 <shachaf> ==rwbarton
14:49:07 <janiczek> well with parentheses its as in every other language .. no problem there :)
14:49:17 <shachaf> $ tends to be way overused.
14:49:41 <rwbarton> Okay, you should also learn how not to write lots of redundant parentheses
14:50:33 <statusfailed> ooh, style question! which of these: "f . g . h $ x" or "f . g $ h x"?
14:50:44 <statusfailed> I guess #2 'cos it's shorter
14:51:03 <rwbarton> it depends, I will guess many will pick #1 though
14:51:14 <statusfailed> yeah, I do
14:51:19 <statusfailed> never wrote them side by side before :D
14:52:24 <shachaf> The annoying thing about #1 is that when you have a two-argument function, it treats the two arguments differently when maybe that doesn't make sense.
14:52:29 <shachaf> As in foo . bar . zip xs $ ys
14:52:46 <benmachine> yeah, I'd prefer foo . bar $ zip xs ys
14:52:57 <rwbarton> but it might make sense if it is like foo . bar . zip [0..] $ ys
14:53:01 <benmachine> yeah
14:53:06 <benmachine> basically
14:53:09 <benmachine> do whatever you want :P
14:53:17 <shachaf> rwbarton: Right.
14:53:26 <shachaf> (I almost gave that example, but then I realized that it made sense so I changed it.)
14:53:49 <rwbarton> I agree your change was successful.
14:54:16 <benmachine> (sometimes I use parentheses instead of $)
14:54:59 <shachaf> benmachine: That section can be shortened to (sometimes I use parentheses instead of)
14:55:10 <benmachine> shachaf: :>
14:55:13 <nejucomo> I rarely use $ -when I first learned it I used it a lot, and now I think I've gone too far in the other direction.
14:55:35 <benmachine> I tend to use it in forM_ xs $ \x ->
14:55:45 <nejucomo> Is there a . with the reverse order?  f <op> g   <=>  g . f  ?
14:55:48 <benmachine> and docTypeHtml $ do
14:55:57 <shachaf> nejucomo: Control.Arrow has (>>>)
14:56:05 <shachaf> Other than that there's nothing in the standard library.
14:56:18 <nejucomo> benmachine: I also rarely use multiline lambdas or do-notation in an argument.
14:56:34 <nejucomo> I think it's because I'm less certain about that syntax, but now that I've been reading it more it looks more natural.
14:57:28 <Z`> mm, ok, I have a contradicting mental message here. I wrote in ghci:   readMyFile  and it printed the contents of the file. Shouldn't it have printed something like, I don't know, just "IO [String]" ?
14:57:49 <benmachine> Z`: no, ghci is clever like that
14:57:57 <benmachine> Z`: it will try to guess what you want and do that
14:58:03 <rwbarton> you have caught on to ghci's tricks
14:58:07 <Z`> a ha. ok.
14:58:13 <janiczek> one more question guys :) is there some kind of "reverse" map? meaning that I have one value and I want to try few functions on it
14:58:15 <rwbarton> IO actions are executed, other values are evaluated
14:58:18 <Z`> I was just worried that I understood something wrong.
14:58:20 <benmachine> Z`: see http://stackoverflow.com/a/11939250/812053
14:58:21 <Z`> Thanks!
14:58:50 <benmachine> @type map ($ 7) -- janiczek
14:58:52 <lambdabot> forall a b. (Num a) => [a -> b] -> [b]
14:59:53 <nejucomo> benmachine: Nice.  I've wanted that on several occasions.
15:00:20 <benmachine> > map ($ 7) [succ, pred, subtract 12]
15:00:21 <lambdabot>   [8,6,-5]
15:00:23 <janiczek> um so it's normal map? how do I use it, if I want to do something like this?
15:00:23 <janiczek> maximum $ [(f val), (g val), (h val)]
15:00:24 <frio> janiczek: map the value onto the functions :)
15:00:27 <janiczek> aha!
15:00:38 <benmachine> janiczek: the key is the $ in the thing I wrote
15:00:46 <benmachine> janiczek: another way to write it would be
15:00:52 <benmachine> > map (\f -> f 7) [succ, pred, subtract 12]
15:00:53 <shachaf> ($ 7) === (\f -> f 7)
15:00:54 <lambdabot>   [8,6,-5]
15:01:08 <shachaf> > sequence [succ,pred,subtract 12] 7
15:01:09 <lambdabot>   [8,6,-5]
15:01:22 <shachaf> (But map ($ 7) is probably better.)
15:01:25 <janiczek> map ($ val) [f, g, h] -- correct?
15:02:05 <shachaf> janiczek: Try it!
15:02:09 <johnw> > map ($ val) [f, g, h]
15:02:10 <lambdabot>   Ambiguous occurrence `f'
15:02:10 <lambdabot>  It could refer to either `L.f', defined at <local...
15:02:30 <janiczek> works :)
15:02:32 <shachaf> Trying things is your best friend when learning something.
15:02:45 <shachaf> (#haskell is one of your worst enemies.)
15:02:46 <janiczek> yeah, was just thinking still in this window, not in my source :D
15:03:22 <antris> hey guys is this a multiplayer REPL
15:03:31 <johnw> isn't that called IRC?
15:03:46 <MostAwesomeDude> Could somebody say "hello" in this channel? :3
15:04:12 <janiczek> well ... that finishes my PE 11 :) https://gist.github.com/3702444
15:04:19 <janiczek> learnt a ton of things
15:05:35 <frio> nice janiczek :)
15:05:35 <janiczek> and probably could have done lots of things better :D
15:05:53 <zzing_> If I have a sequence A that contains items that reference items in sequence B by index, what would be a good approach to this? Most of my problems seems to be because I am referencing by index.
15:06:08 <frio> I should restart PE at some point...
15:06:51 <Cale> zzing_: Don't use lists if you need random access. Data.Sequence might be appropriate, or perhaps Data.Map or Data.IntMap
15:06:53 <janiczek> frio: i have done majority of the problems in python ... now trying in haskell :) PE is still the best thing (for me) to learn new languages on :)
15:07:07 <zzing_> Cale, I said sequence :-)
15:07:26 <newmind> zzing_: is performance an issue?
15:07:32 <zzing_> newmind, no
15:07:48 <zzing_> At least not right now :-). n would be too small to care
15:07:51 <frio> majority :O, well done. i can generally build solutions to them, but the leap towards a solution (or at least, an elegant leap...) eludes me a lot of the time
15:08:06 <efie> could someone help me to solve this problem? http://hpaste.org/74602
15:08:25 <zzing_> I am somewhat concerned that my data model is non-ideal. I am defining things in a relational fashion.
15:08:42 <janiczek> frio: oh, i meant it majority of "solved by me" ... :) some of these were Mathematica, some C++, etc ... i am far from solving majority of PE problems :D
15:09:00 <newmind> probably, but without a bit more information its hard to improve on it
15:09:11 <johnw> what are PE problems?
15:09:14 <johnw> oh, project euler
15:09:15 <johnw> n/m
15:10:07 <janiczek> "last solved a problem 194 days ago" :S :D
15:12:47 <newmind> zzing_: well, you can get rid of the reference by index by just maping over the sequence, returning a sequence of the objects referenced, but depending on your use case that might not be what you want
15:13:01 <latro`a_> project euler scales up in difficulty way too fast for my tastes
15:13:18 <latro`a_> (this is after having done something like 60 of them)
15:14:32 <janiczek> latro`a_: yeah, I usually "hit the ceiling" after 10 problems or so ... then I take a break for few months till I'm able to solve more of them
15:15:04 <efie> if I have two functions x :: IO () and y :: IO Int, how can I say something like "if ... then x else y"?
15:15:26 <latro`a_> that depends on what you mean by that
15:15:33 <Botje> y >> return ()
15:15:34 <latro`a_> since the types are different, you can't mean exactly what you're saying
15:15:35 <Twisol> efie: if … then x else y >> return ()
15:15:44 <zzing_> newmind, interesting, that could work.
15:15:53 <zzing_> newmind, I think my problem can be solved much simpler by having an index in the datatypes - if I want to keep the relational model.
15:15:56 <newmind> you'll loose the Int of y though
15:15:56 <latro`a_> >> return () is one way, however
15:16:14 <efie> thanks!
15:16:22 <Twisol> if you want to keep y, provide a default value in the then branch: if … then x >> return 42 else y
15:16:31 <newmind> returning an int with x would be an alternative
15:16:38 <latro`a_> also works
15:16:50 <newmind> (depends on what you use it for obviously)
15:17:19 <zzing_> :t fmap
15:17:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:17:47 <zzing_> I think I can come up with a means of doing this thank you
15:18:01 <latro`a_> janiczek, http://www.haskell.org/haskellwiki/Avoiding_partial_functions
15:18:07 <latro`a_> #5
15:18:53 <latro`a_> also, takeConsAcc is a left fold
15:21:24 <janiczek> latro`a_: #5? I don't really understand that one... is it the takeTopRightDiagonalsAcc?
15:21:36 <latro`a_> #5 on the avoiding partial functions article
15:21:39 <latro`a_> is something you should look at
15:21:48 <janiczek> well i see that
15:21:57 <janiczek> but i dont really understand the "irrefutable pattern match on (:)"
15:22:15 <janiczek> trying to figure out what is it about
15:22:17 <latro`a_> the second line in the first example irrefutably matches on (:)
15:22:18 <benmachine> janiczek: let (x:xs) = ys is an irrefutable pattern match
15:22:35 <Twisol> It either passes or it crashes.
15:22:35 <latro`a_> that is, it forces the list to not be empty, which it checks with a *predicate* in the if
15:22:48 <latro`a_> which is not a good thing when it can be avoided
15:23:01 <latro`a_> the fromJust example is the same idea
15:23:45 <latro`a_> that said, I was mistaken, because this isn't exactly a left fold
15:24:09 <latro`a_> it can be written as a left fold, but doing so causes it to recurse longer than necessary
15:24:13 <janiczek> latro`a_: which part of my code is "guilty" of that #5? didn't really use something like x:xs anywhere AFAIK
15:24:32 <latro`a_> it's not the matching issue, it's just using length conditions in general
15:24:36 <janiczek> aha
15:24:41 <latro`a_> every length computation is O(n)
15:25:19 <latro`a_> you can write a lazier function that only traverses up to some n, but if not you traverse the whole list
15:26:04 <benmachine> I'd say #4 was better at illustrating how to avoid length checks
15:26:13 <latro`a_> ah
15:26:14 <latro`a_> yes
15:26:15 <latro`a_> sorry
15:29:03 <efie> do you know how I could concat two .wav files using haskell? I cannot find an audio library for this... I haven't worked with ByteStrings yet - is it possible to "export" (or so) the wav files into a Byte strings, concat the Byte Strings and then save it as a .wav file?
15:29:23 <newmind> same format?
15:29:42 <hpaste> latro`a pasted “takeConsAcc'” at http://hpaste.org/74604
15:29:44 <zzing_> efie, are you trying to  just do   cat wave1 wave2 >wave3?
15:29:56 <latro`a_> ^janiczek
15:29:58 <shachaf> efie: You would need to parse the WAV format, I think.
15:30:01 <newmind> well, wav files have a header iirc
15:30:14 <latro`a_> err
15:30:15 <newmind> which define samplerate and size
15:30:18 <latro`a_> sorry
15:30:30 <hpaste> latro`a annotated “takeConsAcc'” with “takeConsAcc' (annotation)” at http://hpaste.org/74604#a74605
15:30:48 <shachaf> Yes, the format is pretty simple.
15:30:50 <latro`a_> should probably not use acc twice
15:31:02 <efie> newmind: yes, I have two .wav files
15:31:18 <newmind> if the format is the same you should be alright just appending one to the other (removing the header from the 2nd one)
15:31:22 <janiczek> latro`a_: looking at it, thanks ... couldnt have thought about a way of making the takeConsAcc as a foldl
15:31:33 <latro`a_> also made one more mistake with the splitAt
15:31:41 <efie> newmind: should I do this using ByteString?
15:31:42 <shachaf> newmind: I don't think so...
15:31:55 <latro`a_> needed to split rest I think
15:32:00 <shachaf> newmind: Wouldn't you need to change the size, at least?
15:32:04 <hpaste> latro`a annotated “takeConsAcc'” with “takeConsAcc' (annotation) (annotation)” at http://hpaste.org/74604#a74606
15:32:09 <latro`a_> ^is correct, I think
15:32:12 <shachaf> Also the format of the two files might be different.
15:32:27 <newmind> shachaf: i don't know if the total number of frames is stored in the header
15:32:29 <zzing_> If I had a sequence A [a, b, c, d, …], and I wanted to compare every pair of elements so I construct another sequence that contains [ a < b, b < c, c < d, … ]  is there a standard method for something like this? I was close to folding, but realized it wasn't the same.
15:32:31 <latro`a_> another good general rule
15:32:33 <latro`a_> never append
15:32:49 <newmind> you'd have to look up whats stored in there
15:32:50 <latro`a_> always prepend and reverse
15:32:59 <SLi> I'm trying to figure out how to use formatTime from Data.Time without using the deprecated System.Locale. formatTime :: FormatTime t => TimeLocale -> String -> t -> String, but FormatTime is only defined in the deprecated System.Locale?
15:33:17 <newmind> but looks like there are libs for parsing/building WAV files for haskell
15:33:44 <SLi> Or, even better: What's the easiest way to get a millisecond or microsecond timestamp (say, as seconds since the unix epoch)
15:34:05 <shachaf> newmind: Wikipedia seems to confirm it.
15:34:11 <benmachine> SLi: System.Locale isn't really deprecated inasmuch as the replacement was never developed
15:34:18 <SLi> benmachine, ah, ok.
15:34:41 <newmind> shachaf: then yes, you probably have to correct the header too....
15:34:54 <SLi> benmachine: So I should just add a dependency to old-locale in my .cabal file?
15:34:58 <benmachine> SLi: getCurrentTime should have picosecond accuracy
15:35:00 <benmachine> SLi: yes
15:35:01 <newmind> the files are probably still playable by most players if you'd just append them with headers and all
15:35:21 <benmachine> SLi: well I say "accuracy"... it provides that much, can't guarantee all of it is accurate :)
15:35:26 <SLi> Hmm, or work around it by just using getCurrentTime and calculating something from the fields, since I'm not so much interested in precise local time.
15:35:32 <SLi> benmachine, yeah, I'm aware of that. :)
15:35:37 <efie> newmind: I'll check it out, thank you all =)
15:35:44 <shachaf> newmind: And if th two files are of different formats then you might need something more.
15:35:49 <benmachine> SLi: depending on old-locale is absolutely fine
15:36:06 <newmind> if the files are different formats or rates, then you need to convert them, sure
15:36:12 <janiczek> latro`a_: prepend and reverse? hmm, why's that better? does that have something to do with how lists are made in haskell?
15:36:18 <newmind> especially rate conversion can be pretty challanging
15:36:25 <janiczek> something like consing in lisp?
15:36:55 <SLi> By the way, what version of oldlocale should I generally depend on in a package? The current version is apparently 1.0.0.4; should I write something like >= 1.0.0.4?
15:36:57 <KirinDave> If there is anyone here familiar with Hakyll, #hakyll is really unresponsive lately.
15:37:01 <SLi> old-locale
15:37:02 <KirinDave> I was trying to clean up some ugly code.
15:37:06 <KirinDave> Specifically: https://gist.github.com/81f55e2e8d422b53d7af
15:37:17 <latro`a_> janiczek, append is O(n) where n is the length of the first argument
15:37:21 <benmachine> latro`a_: I wouldn't prepend and reverse, either, I'd do something else
15:37:22 <latro`a_> so n appends is O(n^2)
15:37:33 <latro`a_> n prepends and a reversal is O(n)
15:37:42 <KirinDave> Since I am not any good at all at Haskell, I was sorting hoping someone could help me cleanthings up. If only to help me understand why i need the ()'s around the outer setFieldA. If I don't have them it's a parse error. But I thought >>> was fairly low in the prec order.
15:38:06 <janiczek> latro`a_: so in order to append it has to traverse to the last element, correct?
15:38:10 <latro`a_> yeah
15:38:15 <latro`a_> well, only the last one of the first list
15:38:18 <janiczek> yeah
15:38:23 <benmachine> appends are definitely bad, but you can often do better than prepend-reverse
15:38:23 <janiczek> thats what i had in mind
15:38:38 <latro`a_> prepend-reverse isn't the best
15:38:43 <latro`a_> but is sometimes the best option
15:38:49 <latro`a_> and always better than n appends
15:39:53 <janiczek> so instead of [1,2,3] ++ [4] I should do reverse $ [4] ++ reverse [1,2,3] ? if I want [1,2,3,4] as a result
15:40:00 <latro`a_> well, just :
15:40:04 <latro`a_> reverse $ 4:[1,2,3]
15:40:11 <latro`a_> but it doesn't make a difference with only one append
15:40:14 <benmachine> latro`a_: reverse (4 : reverse [1,2,3])
15:40:20 <shachaf> janiczek: No.
15:40:23 <benmachine> and yes, it doesn't make a difference with only one append
15:40:26 <janiczek> yeah, i get that it makes sense in a loop
15:40:29 <benmachine> in fact, the reverse version is slower
15:40:31 <latro`a_> er yeah, sorry
15:40:39 <latro`a_> in that one case it's slower, it only adds up when you do more appends
15:41:02 <janiczek> ... and the first reverse is applicable when the loop ends then
15:41:12 <benmachine> latro`a_: is takeConsAcc supposed to throw away the end of the list?
15:41:17 <latro`a_> you should only have to reverse once if you build up the list in the right order
15:41:24 <benmachine> latro`a_: I mean, any bits that don't fit into a multiple of n
15:41:25 <latro`a_> and if n is positive it should benmachine
15:41:28 <janiczek> gah, getting all tangled up in this :) but I think I understand you
15:41:43 <benmachine> janiczek: one sec, I'm going to write a different approach
15:41:54 <zzing_> This is so easy to mystify: (S.zip <*> drop1) $ S.fromList [1,2,3,4,5,6]   => fromList [(1,2),(2,3),(3,4),(4,5),(5,6)]
15:42:10 <benmachine> janiczek: actually, can you tell me what the original problem was?
15:42:10 <meiji11> is it possible to locally overwrite a type?
15:42:27 <latro`a_> I'm not sure what the purpose of takeConsAcc was originally
15:43:19 <zzing_> meiji11, do you mean substitute a new type OR make a new type of the same name?
15:43:26 <meiji11> new type of the same name.
15:43:39 <zzing_> meiji11, where does the existing type come from?
15:44:10 <zzing_> The quick answer is to qualify the import so it isn't there, otherwise, a conflict I don't think haskell handles
15:44:12 <meiji11> zzing_: the Data.Graph module. I want to overwrite Edge, to contain an instance of the old Edge type, as well as a numeric weight.
15:44:38 <meiji11> and I want this new Edge to take the place of the old Edge as I use functions defined in Data.Graph
15:44:43 <meiji11> if that's at all doable, of course..
15:44:49 <janiczek> benmachine: well, latro`a_ was talking about how appending is worse than prepending and reversing ... for sake of simplicity, lets say i want to create [1,2,3,4] ... so instead of making [] ++ [1], [1] ++ [2], [1,2] ++ [3], [1,2,3] ++ [4], I should do 1:[], 2:[1], 3:[2,1], 4:[3,2,1] and then reverse, right?
15:45:13 <zzing_> meiji11, that will not work, Data.Graph expects a certain type
15:45:20 <shachaf> janiczek: Sometimes that's what you want to do.
15:45:25 <zzing_> Unless the functions are part of a typeclass
15:45:35 <shachaf> janiczek: But there's not enough context to be able to say here.
15:45:41 <latro`a_> janiczek, sorta, though in practice you go the other way
15:45:55 <latro`a_> that is [1..4] never calls reverse, iirc
15:46:00 <benmachine> janiczek: the way I'd do it is just build the list "straight away"
15:46:01 <latro`a_> ...yeah, it never does
15:46:06 <latro`a_> you do 1:rec
15:46:09 <latro`a_> rec=2:rec
15:46:12 <latro`a_> er
15:46:12 <shachaf> janiczek: In Haskell in particular you somtimes do it differently from in other languages because of laziness.
15:46:13 <benmachine> janiczek: possibly using a technique called difference lists
15:46:15 <latro`a_> rec=2:rec'
15:46:15 <latro`a_> etc.
15:46:26 <benmachine> janiczek: if you give me a specific function to implement in this style, I can show you
15:46:29 <shachaf> Difference lists are yet another different thing.
15:46:53 <meiji11> zzing_: I see. I should define my own edge, vertex and graph types then..
15:47:02 <zzing_> meiji11, basically
15:47:19 <benmachine> meiji11: or maybe you just need a different graph library, try fgl
15:47:34 <meiji11> benmachine: not a bad idea.
15:48:03 <benmachine> meiji11: or you could keep a map of edges to weights, rather than storing the weights in the graph
15:48:34 <benmachine> meiji11: disclaimer: I've never actually used fgl so I don't know if it solves your problem, but I do know that Data.Graph is a little unloved
15:49:04 <Z`> when I :l afile.hs  that has a main block, does it automatically run ? (because I don't see anything printed in the prompt)
15:49:16 <Z`> ah , I have to execute 'main'
15:49:26 <meiji11> benmachine: this is a learning exercise for me, so that's fine.. I'll figure something out :P
15:49:44 <janiczek> benmachine: well lets try on the takeCons. the purpose of this is to take the all the ways to form n adjacent elements in a list. because of the PE 11 question. greatest product of four adjacent numbers in a row. so takeCons 2 [1..5] would be [[1,2],[2,3],[3,4],[4,5]] ... takeCons 3 [1..5] would be [[1,2,3],[2,3,4],[3,4,5]]
15:49:53 <ezyang> So, I'm trying to understand how recursion corresponds to induction, and I'm having a little difficulty figuring out what the type of 'f' in 'fold f' is in this setting.
15:50:23 <statusfailed> Won't most monad transformer stacks with RandT fail the associativity law?
15:50:31 <ezyang> Namely, if I think of the natural numbers, I have the functor F(X) = 1 + X
15:50:32 <benmachine> janiczek: right, I wouldn't use an accumulator/reversal for that, one sec
15:50:50 <benmachine> statusfailed: RandT is just a specialised StateT, more or less, so I wouldn't think so
15:51:04 <benmachine> statusfailed: you may find the random numbers not as random as you'd hoped though :P
15:51:10 <ezyang> But what do I instantiate X to, when I'm doing an inductive proof? Prop seems too big.
15:51:24 <statusfailed> benmachine: why do you say that? Can't I swap in different RandomGens?
15:51:25 <meiji11> yeah, fgl looks much better. thanks.
15:51:27 <ezyang> And if I do something like an indexed type, how do I make the index change inside the recursion?
15:51:55 <benmachine> statusfailed: I mean inasmuch as you could possibly use a transformer to "roll back" state changes and then not realise you are getting the same random numbers again
15:52:02 <mm_freak> is there anything that is faster for lookup than HashMap from unordered-containers that supports Integer keys?  the usage is:  i'm constructing a very large map from Integer key to Integer value once and then doing lookups…  both operations should be as fast as possible
15:52:03 <statusfailed> also, I think I was confused about what "associativity" meant for a second there... :D
15:52:15 <statusfailed> benmachine: yeek, how would that happen?
15:52:22 * hackagebot syntactic 1.0 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.0 (EmilAxelsson)
15:52:30 <mm_freak> in the optimal case the map fills my entire memory, so fast construction is also needed
15:52:37 <mm_freak> HashMap gives me about twice the speed of Map there
15:52:46 <mm_freak> but a C equivalent using bsearch() was faster
15:53:00 <benmachine> mm_freak: are the integer keys small enough that an array would work?
15:53:07 <mm_freak> benmachine: no, they are huge
15:53:11 <benmachine> statusfailed: I'm not sure if it would, I haven't thought about it enough
15:53:20 <benmachine> mm_freak: in that case I don't have any ideas, maybe someone else will
15:53:46 <mm_freak> the great thing is:  haskell outperforms C for arithmetic, but the HashMap is a real bottleneck
15:54:08 <statusfailed> benmachine: ok, i'lll be wary just in case though :)
15:54:26 <benmachine> statusfailed: do you understand how the state monad works?
15:54:30 <benmachine> esp. StateT?
15:55:01 <mm_freak> it suffices to have a fast membership test…  lookup can actually be slow
15:55:56 <statusfailed> benmachine: Yep
15:55:59 <statusfailed> at least I hope so...
15:56:23 <benmachine> statusfailed: so RandT is basically just StateT with a random seed as state
15:56:35 <statusfailed> Sure
15:56:49 <statusfailed> Doesn't it hide the "get" and "put"?
15:56:53 <benmachine> sure
15:57:02 <benmachine> but I mean it has the same semantics as a transformer
15:57:29 <benmachine> statusfailed: I'd really have to think about it a bit more to see if I could work out if the random seed is reused
15:57:43 <statusfailed> I can see where you're coming from
15:57:53 <benmachine> I'm trying to write a function for janiczek atm :P
15:57:59 <statusfailed> carry on ^^
15:58:02 <hpaste> benmachine pasted “takeCons” at http://hpaste.org/74607
15:58:10 <mm_freak> can i ask for the current heap size somehow?
15:58:16 <mm_freak> usage that is
15:58:28 <benmachine> janiczek: ^ this implicitly assumes the input list is big enough
15:58:31 <newmind> benmachine: thanks for making me feel dumb <.<
15:58:48 <benmachine> newmind: uhh, no problem? I guess? :P
15:58:58 <janiczek> benmachine: thanks! didn't really know about the splitAt before ..thats handy
15:59:04 <benmachine> (what are you even talking about I am super dumb)
15:59:16 <statusfailed> I'm the dumbest!
15:59:16 <benmachine> janiczek: splitAt n xs = (take n xs, drop n xs) basically
15:59:25 <johnw> I like Data.List.Split
15:59:29 <nejucomo> mm_freak: How does haskell outperform C for arithmetic?  Can you point me to a benchmark/
15:59:29 <benmachine> janiczek: but slightly more efficient
15:59:31 <nejucomo> ?
15:59:32 <janiczek> will try to wrap my head around it
15:59:37 <statusfailed> johnw: me too! great library
15:59:39 <nejucomo> -or better yet an explanation of why this is true?
15:59:41 <latro`a_> I suspect that takeCons can actually be written as a foldr
15:59:47 <latro`a_> by first converting the list into a list of n-chunks
15:59:49 <benmachine> janiczek: the main point is here how I'm building the output list
15:59:50 <newmind> although i did get a working solution, its just not as elegant
15:59:57 <latro`a_> actually
15:59:59 <latro`a_> nvm
16:00:03 <latro`a_> it *IS* the list of n-chunks
16:00:06 <benmachine> janiczek: it's only a single traversal, but with no reverse
16:00:11 <benmachine> latro`a_: :P
16:00:18 <janiczek> benmachine: actually that doesn't do the same thing I think
16:00:28 <benmachine> janiczek: ohh, you're right, sorry
16:00:32 <mm_freak> nejucomo: as soon as i release my code, yes…  it outperforms C (mpz_*) with its own Integer arithmetic
16:00:40 <benmachine> janiczek: I had one thing in my mind and then I did something else entirely
16:00:45 <nejucomo> Ah, gotcha.
16:00:47 <nejucomo> Cool.
16:00:48 <benmachine> janiczek: sec
16:01:20 <Hail_Spacecake> I'm going through this tutorial
16:01:21 <Hail_Spacecake> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
16:01:32 <Hail_Spacecake> and I'm having trouble understanding what this line in the eval function is doing
16:01:34 <Hail_Spacecake> eval h x | "!id " `isPrefixOf` x = privmsg h (drop 4 x)
16:01:36 <nejucomo> What is the cost of a class method evaluation compared to a function evaluation?
16:02:04 <latro`a_> basically equal to a function evaluation with more arguments
16:02:14 <latro`a_> one extra argument per constraint
16:02:23 <Cale> Hail_Spacecake: if the string x starts with "!id ", then it drops that prefix and sends a message back to the user h with the remainder of the string
16:02:29 <johnw> Hail_Spacecake: it's looking for IRC messages of the form "!id XXX", in which case it will rewhisper them to 'h', dropping the '!id ' part
16:02:36 <janiczek> benmachine: it's cool :) I was thinking before about how to do the exact thing you did :D and would do it in some stupid way. realized that i need a different function then ... :)
16:02:42 <hpaste> benmachine annotated “takeCons” with “takeCons (annotation)” at http://hpaste.org/74607#a74608
16:02:52 <benmachine> janiczek: there we go
16:03:08 <Hail_Spacecake> Cale right, but I don't understand what the | syntax is doing
16:03:15 <johnw> it's a guard
16:03:23 <janiczek> benmachine: looking at it :)
16:03:25 <johnw> you can read it is "if X is true, the definition of the function is Y"
16:03:25 <janiczek> thx
16:03:54 <Cale> http://www.cs.utep.edu/cheon/cs3360/pages/haskell-syntax.html#Guards
16:03:55 <johnw> in fact, I think it desugars to a chain of ifs, right Cale?
16:04:02 <Cale> more or less
16:04:13 <Cale> if itself is syntax sugar for case
16:04:20 <johnw> oh, haha
16:04:21 <janiczek> benmachine: um will have to lookup what does xs@(_:t)
16:04:21 <janiczek> do
16:04:27 <johnw> it all desugars down to 1 or 0
16:04:30 <janiczek> the @ thing
16:04:30 <Cale> So you'll get a bunch of pattern matches on Bool values
16:04:34 <Hail_Spacecake> so in general it's
16:04:37 <shachaf> johnw: No, that's not sugar.
16:04:38 <latro`a_> it matches on (_:t) and calls the whole list xs
16:04:44 <Hail_Spacecake> function name arg1 arg2 | <condition> = whatever
16:04:48 <latro`a_> so now xs = a:t
16:04:48 <johnw> shachaf: was just a compiler joke
16:04:51 <Cale> Hail_Spacecake: yeah
16:04:51 <Hail_Spacecake> and then whatever is the definition iff <conditoin> holds
16:04:54 <benmachine> janiczek: I can paste another version without using that syntax, one sec
16:04:54 <latro`a_> for some (thrown away) a
16:05:03 <Hail_Spacecake> oka
16:05:03 <Hail_Spacecake> y
16:05:16 <Cale> yes, that's right, and if the condition doesn't hold, it falls through to the next guard or pattern to match
16:05:26 <janiczek> latro`a_: thanks ... so its pattern matching basically
16:05:34 <hpaste> benmachine annotated “takeCons” with “takeCons (annotation) (annotation)” at http://hpaste.org/74607#a74609
16:05:39 <latro`a_> it's a type of pattern matching, yes
16:05:41 <janiczek> you still have xs but now you have the t as sa tail
16:05:43 <latro`a_> it saves you a let
16:05:48 <shachaf> "Tarski tried to publish his theorem [the equivalence between AC and 'every infinite set A has the same cardinality as AxA', see above] in Comptes Rendus, but Fréchet and Lebesgue refused to present it. Fréchet wrote that an implication between two well known [true] propositions is not a new result, and Lebesgue wrote that an implication between two false propositions is of no interest".
16:05:48 <janiczek> a tail*
16:05:54 <benmachine> janiczek: that's the trivial translation of it, but you actually made me realise I can do this differently, moment
16:06:03 <latro`a_> f xs@(y:ys) = ... is the same as f (y:ys) = let xs = (y:ys) in ...
16:06:17 <janiczek> latro`a_: yeah ... :)
16:06:18 <Cale> shachaf: lol
16:06:40 <janiczek> benmachine: :D whatever, i still have to catch up with your train of thought anyway :)
16:06:47 <typoclass> shachaf: at least they agreed that the theorem was not worth publishing
16:06:48 <janiczek> thanks for your time! :)
16:06:52 <Cale> shachaf: and the implication shouldn't actually hold...
16:07:03 <benmachine> janiczek: I decided the other way was silly anyway :P
16:07:03 <janiczek> i appreciate that you try to teach me how to do these things better
16:07:17 <Cale> shachaf: oh, no, it does, I just misread it
16:07:39 <benmachine> yep, I remember having to prove that last term
16:07:48 <Cale> A has the same cardinality as AxA
16:07:51 <benmachine> I think it was in the exam, actually
16:07:58 <Cale> when A is infinite
16:08:05 <benmachine> for all infinite cardinals m, m^2 = m
16:08:55 <Dodek> benmachine: this is not particularly easy. what was your approach?
16:09:09 <janiczek> benmachine: does the compiler intelligently use that (x:t) and [x:t] or is it less efficient than using the xs from your first edit?
16:09:30 <janiczek> (my main concern being creating the same thing on multiple places)
16:09:46 <benmachine> janiczek: I'm... not actually sure. it might actually be subtly different, in which case the compiler wouldn't be allowed to be clever
16:10:00 <benmachine> Dodek: to proving that? I can't remember it off the top of my head
16:11:05 <benmachine> Dodek: I think what we were actually taught is a proof that m^2 = m implies the well-ordering principle
16:11:13 <benmachine> using a Hartogs ordinal
16:11:38 <benmachine> or something.
16:11:44 * benmachine scratches head
16:11:59 <benmachine> I should probably know this, maybe I will dig out my notes
16:12:41 * benmachine doodles a bit
16:12:57 <janiczek> benmachine: I think I finally understand. you do the splitAt as before for taking the first n elements, but you have the t (as tail) handy so you can call the takeCons again on the tail ... thats clever! :)
16:13:15 <benmachine> janiczek: right. and you just build up the output list element by element, without appending anywhere
16:15:18 <newmind> benmachine: would the call stack build up when building the list like that?
16:16:01 <Z`> I have lots of pure functions that I call from within main = do ... so I'm accumulating lots of lines with:  let r = ... let g = ... is this is a sign of doing something wrong?
16:16:10 <Z`> also, I'm running out of letters :P
16:16:11 <janiczek> benmachine: yes ... maybe I should first dust off my knowledge of basic Haskell syntax (as previously mentioned by somebody) like the x:t, and what I can and can't do (like the splitAt function), before I tackle these things. I basically did the PE 11 program in Haskell with LISP style, not Haskell style. :)
16:16:19 <benmachine> newmind: if the function consuming the list does so element by element, it can consume the list as it goes
16:16:35 <benmachine> newmind: so you don't get any accumulation of values
16:16:44 <ski> Z` : .. perhaps you want a state monad
16:16:47 <newmind> beauty of lazy evaluation :)
16:16:52 <benmachine> yep!
16:16:55 <ski> (or possibly use composition)
16:17:08 <newmind> actually, this should work on infinite lists, now that i think about it
16:17:10 <benmachine> but also any Haskell implementation won't have the same kind of call stack as other languages
16:17:24 <benmachine> you wouldn't have a stack frame per function call, that would be insane
16:17:33 <benmachine> because recursion is so ubiquitous
16:18:00 <newmind> well, if you're not tail-recursing, you have to store your return path somewhere
16:19:19 <ski> except that laziness means that often things are more "scattered"
16:19:36 <Cale> also, silly
16:19:56 <ski> in `f x = g (h x) (i x)', `h x' and `i x' will possibly not be called before `f x' returns
16:20:03 <benmachine> Dodek: so, do you want a proof of m^2 = m => AC? I think I remembered it
16:20:24 <Dodek> benmachine: nah, i could recall it if i tried hard
16:20:25 <ski> therefore, in such cases, you don't store a return path for `g' which includes going back to `f'
16:20:37 <Dodek> benmachine: or at least find it in a dictionary
16:20:38 <Dodek> er
16:20:40 <Dodek> in a book
16:20:57 <Dodek> benmachine: i'm more interested in other direction, since it's a bit easier
16:21:05 <Dodek> benmachine: and there are multiple approaches
16:21:08 <benmachine> AC => m^2 = m?
16:21:11 <ski> .. er, s/for `g'/for `h' (resp. `i')/
16:21:14 <newmind> ski: you still need to fully recurse it as soon as you need the result
16:21:20 <benmachine> I always found that proof pretty confusing, actually
16:21:34 <Dodek> benmachine: i would do it using kuratowski-zorn lemma
16:21:53 <benmachine> something about how you can well-order α^2 with an ordering of type α
16:22:05 <benmachine> and then well-ordering principle etc.
16:22:26 <ski> newmind : you need to call `h' then, yes
16:22:32 <benmachine> Dodek: oh, I don't think I know that one
16:22:38 <benmachine> Dodek: I mean, the proof using that :P
16:22:45 <ski> but possibly you don't need the result of the recursive call in `h' at that point in time
16:22:47 <benmachine> obv I know what zorn's lemma is
16:22:51 <Dodek> benmachine: take set m, consider a set { (p, f): p is a subset of m and f: p x p -> p is a bijection }
16:23:36 <benmachine> Dodek: okay, partially ordered by set inclusion and the functions being extensions of each other?
16:23:50 <benmachine> err, ykwim
16:23:52 <Dodek> benmachine: something like this
16:23:56 <Dodek> i recall there was some problem
16:24:03 <Dodek> with just taking extensions
16:24:10 <benmachine> yeah it sounds a bit strange
16:24:53 <benmachine> so I guess the partial order would have to be a bit subtle
16:24:57 <Dodek> yeah
16:25:01 <Dodek> i don't recall the details.
16:25:13 <benmachine> ok, interesting though, thanks :)
16:25:18 <Dodek> :)
16:26:09 <benmachine> oh hey, shit, I just worked out a more intuitive way of looking at my proof
16:26:18 <benmachine> that would have been great for the exam three months ago
16:26:25 <benmachine> oh well, it didn't even come up anyway :P
16:30:36 <janiczek> benmachine and Dodek: are you guys studying math or CS? can't tell if this stuff comes up on CS too
16:30:49 <benmachine> janiczek: I'm a maths student
16:31:07 <benmachine> but I've always been a CS hobbyist
16:31:17 <Jetbeard> janiczek, CS varies a lot from place to place - I'm a CS student and the first language I was taught was haskell, other places will use Java as their main language
16:31:28 <MostAwesomeDude> Or Python.
16:31:39 <MostAwesomeDude> Or C. Or Scheme.
16:31:45 <Dodek> janiczek: i studied both of them
16:32:31 <Dodek> janiczek: but i had this stuff on course for CS degree
16:32:33 <janiczek> benmachine: same here ... but I'm just starting the 2nd year in college and my reasoning about proofs right now ... well ... far from what I've read here a while ago :D
16:32:34 <geekosaur> C++ has been known to be a first language as well
16:32:48 <Dodek> janiczek: my university is very theory-focused.
16:33:43 <janiczek> Jetbeard, MostAwesomeDude, geekosaur: on my university, when I went to an optional "functional programming" course from CS faculty, they told us to look at Prolog (I secretly hoped for Haskell :/ )
16:34:01 <benmachine> my university is apparently keen on ML
16:34:01 <janiczek> and for programming, they teach us C, C++ and Java. booooring
16:34:08 <benmachine> but also does Java
16:34:10 <MostAwesomeDude> janiczek: My university offers C and Java only. It's pretty pathetic.
16:34:18 <benmachine> I've avoided both so far :P
16:34:19 <newmind> prolog is kinda weird
16:34:24 <Dodek> i took "functional programming" course, but it was just basic ocaml
16:34:43 <MostAwesomeDude> You *should* learn C and you should be aware of Java's idioms and structure.
16:35:04 <janiczek> MostAwesomeDude: well, yeah, but I'm not learning nothing new there, just getting free credit points
16:35:07 <Dodek> there was also "advanced functional programming" course, led by a different guy, that was quite heavy on haskell, categories, monads and shit
16:35:09 <ski> Prolog is nice, but not an FPL
16:35:14 <Jetbeard> Dodek, I used OCaml in my compilers course :)
16:35:16 <janiczek> Dodek: would want that
16:35:45 <Dodek> i didn't have time to take it, though, and now i don't study cs anymore
16:36:55 <Z`> I'm doing some progress guys. I wrote a couple of lines and they compiled at 1st attempt :P
16:37:26 <ski> @quote it.compiles
16:37:26 <lambdabot> SPJ says: "If it compiles, it works."
16:37:41 <newmind> thats one of my weirdst experiences with haskell yet: writing a couple of lines, compiling it, and it works, no error... i'm not used to that :D
16:37:49 <Z`> haha. I guess in haskell it is a bit more true, than other languages ?
16:38:10 <Dodek> Z`: heh. i have funny workflow with haskell that's quite different from workflow in other languages. basically, i think for a while, then i write code for half an hour or so, then i compile it, fix all compilation errors,
16:38:17 <newmind> the compiler catches a lot of possible errors just by type checking
16:38:25 <Dodek> and after that, it works most of the time
16:38:39 <janiczek> ski and newmind: well the prolog course at my uni was on Saturdays and I didn't attend it because of that - but was seriously looking at Prolog at home because I thought that TA guy is gonna kick my ass if I didn't. in the end all he wanted from us was theory of lambda calculus. pff :) wasn't really the functional programming I was hoping for :D
16:39:51 <newmind> janiczek: i looked at prolog a bit, nice concept, but once you want to do some _actual_ work with it, you have to start thinking about how your code is interpreted
16:40:00 <ski> janiczek : well, imo, you ought to learn at least one logic programming language
16:40:18 <newmind> which ruins the whole point of a logic based language
16:40:35 <ski> newmind : yes, you do need to be aware of both declarative and procedural semantics, for efficiency
16:41:00 <janiczek> ski: yeah, if they named the course "logic programming", I wouldnt say a word against it :)
16:41:30 <janiczek> and I very much like the more declarative way of haskell/prolog/erlang (the last one being my crush right now)
16:41:34 <ski> janiczek : there is a ##prolog channel here on FreeNode, if you're interested
16:42:10 <janiczek> ski: not really. :) prolog was interesting when I was looking into it, but as newmind said a while ago, not really much practical
16:42:15 <janiczek> but thanks
16:42:38 <janiczek> interesting that erlang is based on it but is soo much practical in my eyes
16:42:54 <janiczek> soo much more*
16:43:10 <ski> (.. someone is talking in ##prolog atm partly about using it to generate web pages to be used in a virtual world)
16:43:23 <janiczek> :D
16:43:55 <ski> (pay-job)
16:47:23 * hackagebot cgi 3001.1.8.3 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.1.8.3 (AndersKaseorg)
16:52:56 <efie> I'd like to concat 2 .wav files using the Codec library. http://hackage.haskell.org/packages/archive/HCodecs/0.2.2/doc/html/Codec-Wav.html I use "importFile" to get 2 "Audio Int16". Now I'd like to combine those 2 "Audio Int16" and then create a new .wav file using the "exportFile" function. Audio a consists of sampleRate, channelNumber (these are the same in both files, so thats easy) and sampleData. How do I concat the 2 sampleDatas?
16:52:58 <efie> There is the function "buildSampleData :: (a -> Builder) -> SampleData a -> Builder" and then I can concat 2 Builders but how do I come back from Builders to SamepleData?
16:52:59 <Cale_> benmachine: I think I know which proof you had.
16:53:08 <benmachine> Cale: of what?
16:53:34 <Cale> That A x A ~= A implies AC
16:53:48 <benmachine> oh right
16:53:57 <benmachine> go on? :P
16:54:05 <benmachine> or do you want me to write it out so you can see
16:55:09 <Cale> There's this technical lemma that if A is any set, and if B is a well-ordered set, and if there is an injection A x B -> A + B, then A and B are comparable (i.e. there is an injection A -> B, or an injection B -> A)
16:55:37 <Nereid> what if B is empty
16:55:58 <Nereid> oh
16:56:03 <benmachine> Nereid: then the result is fairly simple :P
16:56:05 <Nereid> misread.
16:56:15 <Nereid> bah non-choice.
16:56:18 <benmachine> Cale: hmm, sounds similar but not the same to what I have
16:56:26 <Jafet> There are incomparable sets?
16:56:39 <benmachine> Jafet: AC says all sets are comparable
16:56:40 <Nereid> Jafet: without choice, yes
16:57:14 <benmachine> efie: well, SampleData is just a UArray, so you might be able to mess about with that representation directly
16:57:17 <Jafet> Oh, ok.
16:58:37 <efie> benmachine: is there a way to concat 2 UArrays?
16:58:59 <benmachine> efie: I don't think there is a predefined function to do so, but you could just create a new array and fill it with data from the old ones
17:00:22 <Cale> benmachine: So, if our injection is f: A x B -> A + B, there are two cases: either for some x in A, we have {f(x,b) : b in B} lies entirely in the image of A, in which case we get an injection from B to A.
17:00:41 <pnielsen> is the haskell.org mailman buggy?
17:01:03 <pnielsen> tried signing up with a diff email a couple times over the past few weeks, but haven't gotten any confirmation message (or list message)
17:01:56 <Cale> Or for every x in A, there is some y in B such that f(x,y) is in the image of B, in which case we can define an injection g: A -> B by g(x) = h(x,y) where y in B is the least one with f(x,y) is in B. (Ignoring the distinction between B and its image in the sum a bit)
17:02:28 <Cale> g(x) = f(x,y)
17:02:30 <Cale> sorry
17:02:49 <Cale> and so in that case we get an injection A -> B
17:05:06 <benmachine> Cale: that sounds similar to what I've got but not quite the same, wait for me to write it up
17:05:09 <Cale> benmachine: and so next, we suppose that for every infinite set A there's a bijection to A x A, and if we fix some infinite set A, then we can get a Hartogs ordinal aleph(A) which is the least cardinal larger than A.
17:05:31 <Cale> i.e. there is no injection aleph(A) -> A
17:05:38 <efie> could someone provide a small example how to create a new / get data from an UArray? (if it not takes  too much time)
17:05:44 <benmachine> Cale: actually I think this is essentially the same proof, but set up a bit differently
17:06:17 <benmachine> efie: use the functions from the IArray class; if you're still stuck I'll help a bit more later
17:07:31 <shachaf> λ> (listArray (0,5) [1,8,1,3,4] :: UArray Int Int) ! 1
17:07:32 <shachaf> 8
17:08:56 <latro`a_> the Array stuff is a tiny bit confusing because most of the stuff you would want to do with it is actually in typeclasses
17:09:41 <shachaf> Of course I missed an element in that list...
17:09:47 * shachaf not good at counting
17:10:07 <efie> benmachine: I'll go to bed and try it tomorrow, thanks =)
17:10:27 <benmachine> hf gn
17:10:28 <Cale> and then by our hypothesis, we have that since there's the natural injection: A x aleph(A) -> (A + aleph(A)) x (A + aleph(A)), which just sends (a,b) to (Left a, Right B), and this latter set is in bijection with (A + aleph(A)) by our assumption, we have an injection A x aleph(A) -> A + aleph(A)
17:10:41 <Cale> and so A and aleph(A) are comparable
17:11:16 <Cale> but we know that an injection aleph(A) -> A is impossible, so there must be one A -> aleph(A), and we get a well ordering of A
17:11:51 <Cale> MAGIC!
17:12:07 <Cale> benmachine: What does your proof do?
17:12:17 <zenware> It's only magic till you understand it ;)
17:12:27 <Cale> It's still somewhat magic
17:12:33 <efie> shachaf: thanks
17:12:34 <benmachine> Cale: confuses me
17:12:36 <Cale> Because of the nature of AC :)
17:12:44 <benmachine> that's what my proof does
17:12:50 <shachaf> Cale: Hah, is this still about that axiom of choice thing?
17:12:54 <Cale> yes
17:13:30 * shachaf hasn't read the backlog.
17:13:37 <hpaste> benmachine pasted “m^2 = m => AC” at http://hpaste.org/74610
17:13:37 <Cale> I just proved that every infinite set A can be well ordered from the assumption that for every infinite set, we have A x A is in bijection with A.
17:13:42 <benmachine> aaagh
17:13:55 <benmachine> no line breaks for the wicket
17:13:57 <benmachine> er wicked
17:14:01 <benmachine> let me annotate that with formatting
17:14:09 <latro`a_> ...wow
17:14:14 <latro`a_> injection A->aleph(A) is WOP
17:14:19 <latro`a_> that's great
17:14:24 <hpaste> benmachine annotated “m^2 = m => AC” with “m^2 = m => AC (annotation)” at http://hpaste.org/74610#a74611
17:14:55 <benmachine> http://hpaste.org/74611 there we go
17:15:04 <latro`a_> lol, cantor-bernstein
17:15:07 <Cale> Okay, that's the same except in reverse order and at breakneck speed.
17:15:13 <latro`a_> never heard it with that name
17:15:18 <Cale> and using CSB
17:15:21 <latro`a_> heard schroder-bernstein and cantor-schroder-bernstein
17:15:25 <latro`a_> but never cantor-bernstein
17:15:31 <benmachine> Cale: it sounds very similar but the details are a bit different
17:15:33 <Cale> Cool Story Bro
17:15:35 <benmachine> :P
17:16:09 <benmachine> man, now I am reading "cool story bro" as a noun phrase and wishing my bro was one
17:16:22 <Cale> lol
17:16:42 <typoclass> cool story bros before cool story ... er nvm
17:17:04 <Cale> benmachine: That last bit is essentially the proof of comparability that I gave
17:17:41 <benmachine> Cale: I'm too sleepy to work out the details :P
17:17:43 <Cale> but yeah, it's like all the pieces have been jumbled up, but they're all still recognisably there :)
17:17:48 <benmachine> mm
17:18:12 <Cale> ah, I see
17:19:12 <Z`> Hey people. I have a list of strings. I'd like to do some operation on those strings of the list that are past some string. Ideas ?
17:19:27 <c_wraith> what does "past" mean?
17:19:34 <Z`> sorry, after
17:19:36 <Cale> dropWhile (not (== thatString))
17:19:41 <Cale> er
17:19:43 <Cale> dropWhile (not . (== thatString))
17:19:59 <typoclass> Z`: yes, check takeWhile and dropWhile
17:20:18 <Z`> cool. thanks !
17:20:32 <Cale> I wish I didn't have to take allergy medication every day. Damn hayfever.
17:20:45 <Z`> ( I was thinking to find the index of thaString and then use filter (\x -> x >= idxOfThatString)
17:20:58 <Z`> anti-histamines ?
17:21:05 <Clint> reduce the allergens in your environment
17:21:07 <Cale> yeah, Loratadine
17:21:13 <benmachine> Cale: in September? sux4u
17:21:23 <Cale> benmachine: yeah, somehow
17:21:27 <benmachine> I had them from something like May until August to be fair
17:21:53 <typoclass> Cale: could (not . (== ...)) be simplified to (/=) ?
17:22:00 <Cale> typoclass: yes
17:22:07 <typoclass> ok
17:22:09 <typoclass> thanks
17:22:25 <Cale> (but in order to make that simplification, I would have to be not addled by allergy medication :)
17:22:34 <Z`> :P
17:23:04 <typoclass> Cale: no worries, irc is multiplayer disaddlication :)
17:36:32 <Z`> Is there a pattern, syntax, whatever that simplifies expressions like:  map f1 $ map f2 $ map f3 x
17:36:48 <latro`a_> in the actual case of map you can fuse
17:36:49 <MostAwesomeDude> Z`: map (f1 . f2 . f3) x
17:36:52 <latro`a_> map (f1 . f2 . f3) x
17:36:57 <latro`a_> same for any fmap
17:37:00 <Z`> brilliant
18:04:56 <johnw> f1 . f2 . f3 <$> x
18:07:25 * hackagebot lojbanParser 0.1 - lojban parser  http://hackage.haskell.org/package/lojbanParser-0.1 (YoshikuniJujo)
18:15:26 <Z`> I'm inside a do block and I have [String]. I'd like to print each one of them. map putStrLn mystrings is -guess what- type error
18:15:44 <luite> Z`: mapM_
18:15:59 <Z`> oh boy
18:16:09 <Z`> luite: you are such a great person. thank you. it worked
18:17:05 <shachaf> Z`: Now figure out why mapM_.
18:17:17 <Z`> I already knew that I needed something that would return IO ()
18:17:25 <Z`> I just didn't know its name
18:17:27 <luite> Z`: also see mapM if you want the result from each action you run, mapM_ is the version that discards the results
18:17:43 <shachaf> Z`: OK, then figure out how you would write mapM_ yourself. :-)
18:17:53 <shachaf> Also:
18:18:09 <latro`a_> if you don't want a hint, ignore the following
18:18:10 <latro`a_> but if you do
18:18:12 <latro`a_> @type sequence
18:18:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:18:21 <startling> > map putStrLn ["hello", "world"]
18:18:22 <lambdabot>   [<IO ()>,<IO ()>]
18:18:27 <startling> ^ not a type error
18:18:29 <shachaf> @hoogle (a -> IO b) -> [a] -> IO ()
18:18:30 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
18:18:30 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
18:18:30 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
18:18:38 <latro`a_> it's not a type error in general, but it can't be a line of a do block
18:18:45 <startling> oh, right
18:18:54 <latro`a_> er, it can't be a line of a do block in IO
18:19:02 <startling> yeah, understood
18:19:51 <latro`a_> still useful to point out, though; the fact that IO actions are first class is somewhat profound when you get used to it
18:23:40 <startling> Z`: anyway, do you understand why "map putStrLn ["hello", "world"]" doesn't do what you want?
18:24:15 <heatsink> Is there a way to write an irrefutable pattern binding in a do block?
18:24:40 <startling> x <- whatever ?
18:25:02 <heatsink> > do {Just x <- [Nothing]; return x}
18:25:03 <lambdabot>   []
18:25:14 <heatsink> I want it to raise an exception
18:25:27 <Z`> startling: vaguely. care to explain ?
18:25:41 <lpvb> :t map
18:25:42 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:25:47 <lpvb> :t mapM_
18:25:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
18:26:01 <startling> :t map putStrLn ["hello", "world"]
18:26:02 <lambdabot> [IO ()]
18:26:05 <Z`> yeh, besides the types signatures. whether there's some deeper meaning
18:26:10 <lpvb> replace m with IO
18:26:13 <startling> ^ it's a list of IO actions, rather than an IO action
18:26:25 <nand`> > do {~Just x <- [Nothing]; return x}
18:26:27 <lambdabot>   <no location info>: Parse error in pattern
18:26:47 <nand`> > do {~(Just x) <- [Nothing]; return x}
18:26:48 <lambdabot>   [*Exception: <interactive>:3:4-25: Irrefutable pattern failed for pattern (...
18:26:52 <startling> heatsink: fromJust might work, dunno for sure
18:27:09 <startling> heatsink: it's sort of weird to want an exception, though
18:27:18 <lpvb> > fromJust Nothing
18:27:19 <lambdabot>   *Exception: Maybe.fromJust: Nothing
18:27:20 <heatsink> nand`, that only raises an exception when x is forced
18:27:29 <nand`> isn't that what you asked?
18:27:42 <nand`> that's how irrefutable pattern matches work
18:27:50 <startling> Z`: the way you take more than one monadic action and connect them is with (>>=) in general ((>>) is a specific case of (>>=))
18:28:05 <startling> @src sequence
18:28:05 <lambdabot> sequence []     = return []
18:28:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:28:05 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
18:28:34 <startling> ^ sequence takes a list of monadic actions and runs (>>=) between them all, essentially
18:29:13 <Z`> cool,thanks
18:29:15 <heatsink> nand`, the binding with ~ is strict but the binding without ~ is lazy
18:29:35 <heatsink> > [() | Just x <- undefined]
18:29:36 <lambdabot>   *Exception: Prelude.undefined
18:29:40 <heatsink> > [() | ~(Just x) <- undefined]
18:29:41 <lambdabot>   *Exception: Prelude.undefined
18:29:48 <heatsink> > [() | ~(Just x) <- [undefined]]
18:29:49 <lambdabot>   [()]
18:30:01 <heatsink> That's what I meant.  It doesn't actually check against 'Just'.
18:30:17 <heatsink> On the other hand,
18:30:18 <heatsink> > [() | Just x <- [undefined]]
18:30:19 <lambdabot>   *Exception: Prelude.undefined
18:30:25 <nand`> I don't understand your question then
18:30:41 <startling> Z`: mapM is just "\fn -> sequence . map fn" and mapM sticks a >> return () afterwards
18:31:05 <nand`> startling: no, mapM_ uses sequence_
18:31:19 <lpvb> in a do block, >> precedes non-binding statements, and >>= precedes binding ones like args <- getArgs, right?
18:31:32 <startling> nand`: oh. same idea, though
18:31:56 <heatsink> I want a version of the <- syntax that desugars to do x <- m; case x of PATTERN -> k
18:32:15 <heatsink> instead of do x <- m; case x of {PATTERN -> k; _ -> fail}
18:32:58 <lpvb> aren't those the same thing?
18:33:06 <nand`> lpvb: no
18:33:46 <Nereid> > fail :: [()]
18:33:47 <lambdabot>   Couldn't match expected type `[()]'
18:33:47 <lambdabot>         against inferred type `GHC.Base...
18:33:51 <Nereid> ehghtrh
18:33:56 <heatsink> I forgot fail takes an argument
18:33:59 <Nereid> > fail "blah" :: [()]
18:34:00 <parcs`> startling: using sequence_ is a little more efficient that sequence when you ignore its return value
18:34:01 <lambdabot>   []
18:34:05 <parcs`> than*
18:34:26 <startling> parcs`: right, because you're not constructing an intermediary list, understood
18:36:03 <heatsink> Oh qwell, I can just use case.
18:36:37 <heatsink> lpvb, >>= follows binding statements
18:37:14 <Nereid> > fail "" :: Maybe a
18:37:15 <lambdabot>   Nothing
18:40:06 <mizu_no_oto> I'm currently using Ubuntu and ghc 7.4.1.  When I try compiling my program with -prof, I get the message "Could not find module 'Prelude'".  What's the easiest fix for this?
18:40:46 <Nereid> mizu_no_oto: have you installed the profiling packages?
18:41:20 <Nereid> the *-prof ones
18:41:28 <ski> > mzero :: [()]
18:41:29 <mizu_no_oto> How do I install the profiling version of prelude?
18:41:29 <lambdabot>   []
18:41:42 <ivanm> mizu_no_oto: you need to install the profiling libraries for ghc
18:41:46 <Z`> Is there a symbol, like /=, that means "not a member of" ? like in this expr:   not $ 1 `elem` [1..10]  returns False
18:41:54 <ivanm> if you're on ubuntu or something I think there's something like ghc-prof
18:41:56 <ski> @hoogle notElem
18:41:57 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
18:41:57 <lambdabot> Data.List notElem :: Eq a => a -> [a] -> Bool
18:41:57 <lambdabot> Data.Foldable notElem :: (Foldable t, Eq a) => a -> t a -> Bool
18:42:02 <Z`> thank you ski !
18:42:15 <ivanm> @hoogle a -> [a] -> Bool
18:42:15 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
18:42:15 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
18:42:15 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
18:52:50 <Z`> mm is there anything like takeWhile that also includes the first element where the condition is not met ?
18:53:25 <zenware> Is it strange that I come here solely to ponder life?
18:53:40 <Z`> or rather how could I append the first element after takeWHile terminates
18:54:19 <luite> Z`: break
18:54:25 <ParahSailin_> @src takeWhile
18:54:25 <lambdabot> takeWhile _ []                 =  []
18:54:25 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
18:54:25 <lambdabot>                    | otherwise =  []
18:54:31 <amosr> I think if I wanted to ponder life, I'd be at the beach or at the pub
18:54:40 <Z`> thanks
18:55:46 <johnw> amosr: all depends on what kind of answer you want to get
18:56:01 <johnw> #haskell is a part of life too :)
18:56:19 <Z`> luite: it worked. Thanks.
18:58:04 <ParahSailin_> @src break
18:58:04 <lambdabot> break p =  span (not . p)
18:58:16 <luite> Z`: oh i actually meant span instead of break :) but it's just the same with the predicate negated
18:58:33 <ParahSailin_> @src span
18:58:33 <lambdabot> span _ xs@[]                     =  (xs, xs)
18:58:33 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
18:58:33 <lambdabot>                   | otherwise    =  ([],xs)
18:59:00 <zenware> amosr: I like being in a chatroom full of smart people, if I decide something rash like suicide, I'm sure someone would talk me out of it.
18:59:13 <ski> > span isDigit "0123456789abcdef"
18:59:14 <lambdabot>   ("0123456789","abcdef")
18:59:43 <ski> > let (prefix,char:_) = span isDigit "0123456789" in (prefix,char)
18:59:44 <lambdabot>   ("*Exception: <interactive>:3:4-46: Irrefutable pattern failed for pattern ...
18:59:57 <ddarius> zenware: Talking people out of suicide is off-topic.
18:59:58 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
19:00:01 <ski> > let (prefix,~(char:_)) = span isDigit "0123456789" in (prefix,char)
19:00:02 <lambdabot>   ("0123456789",*Exception: <interactive>:3:4-49: Irrefutable pattern failed ...
19:00:37 <johnw> ski: why are you using a lazy pattern there?
19:01:05 <johnw> ski: in case snd isn't a tuple?
19:01:12 <ski> johnw : to show that it could successfully compute `prefix' in that case
19:01:19 <johnw> od
19:01:20 <johnw> oh
19:01:23 <johnw> just for demonstration
19:01:31 <ski> ("in case snd isn't a tuple?" -- huh ?)
19:01:39 <zenware> ddarius: Anything not related to haskell is off topic.
19:01:40 <liyang> in case snd is ""
19:01:46 <Z`> cool, span could work as well here. break is bit easier, because I don't have to concatenate the results
19:02:15 <johnw> oh, sorry, I misread
19:02:18 <johnw> (:), not (,)
19:02:24 <johnw> in case snd isn't []/"", yeah
19:02:56 <ski> > let in case snd is "" of (){} -> []
19:02:58 <lambdabot>   Couldn't match expected type `(a, b)'
19:02:58 <lambdabot>         against inferred type `Text.P...
19:03:29 <johnw> are you mocking me in Haskell??
19:03:40 <int80_h> any people familiar with reactive-banana here?
19:03:41 <liyang> Looks that way.
19:03:50 <ski> johnw : rather liyang, in that case ..
19:04:09 <BMeph> BRB - Ween-Doze needs changing... :(
19:04:29 <ski> (though actually i was expressing my incomprehension of `<liyang> in case snd is ""')
19:05:06 * liyang should concentrate on work instead of butting in to IRC conversations.
19:05:26 <johnw> liyang: where do you work?
19:05:43 <ddarius> :t is
19:05:44 <lambdabot> Doc
19:05:48 <liyang> johnw: http://www.tsurucapital.com/en/
19:05:49 <ddarius> > is
19:05:51 <lambdabot>   are
19:06:10 <ddarius> @undefine
19:06:14 <ddarius> > is
19:06:15 <lambdabot>   Not in scope: `is'
19:06:16 <johnw> wow, I bet you care a lot about performance then
19:06:29 <liyang> Performance is an issue, yes…
19:06:50 <johnw> > let ski = strange cat in huh where strange x = x; huh = strange id
19:06:51 <lambdabot>   <no location info>: parse error on input `where'
19:07:03 <johnw> oh, need another ;
19:07:47 <int80_h> liyang: still looking for a programmer?
19:09:31 <liyang> int80_h: not actively hiring right now, but if you're interested please apply and we'll get back to you when we start hiring again.
19:09:41 <copumpkin> liyang: I just noticed that the dog has a weird outline
19:10:04 <copumpkin> tetto?
19:10:18 <copumpkin> omg they've embedded a secret message in the dog
19:10:20 <djahandarie> Wait, that's a dog?
19:10:28 <int80_h> liyang: okay cool. The specifics of what was wanted out of a programmer was intriguing.
19:10:42 <liyang> copumpkin: she's just a puppy in that one! She's grown lots since then.
19:10:51 <djahandarie> Oh, on the employment page, okay.
19:10:51 <copumpkin> aww
19:11:02 <copumpkin> liyang: you see the secret outline I'm talking about though?
19:11:06 <copumpkin> dark gray on black
19:11:48 <liyang> copumpkin: teto, from https://www.google.co.jp/search?q=teto+nausicaa
19:11:59 <copumpkin> aha
19:12:02 <int80_h> copumpkin: it's like an after-image, I see it!
19:12:28 <liyang> copumpkin: I'm not sure what you're talking about…
19:13:03 <djahandarie> Crank up the brightness on your monitor
19:13:15 <djahandarie> copumpkin can probably see it because he's on a mac
19:13:22 <copumpkin> shush you
19:13:26 <copumpkin> I can see because I'm awesome
19:13:38 <int80_h> I can see it and I'm on an ordinary asus laptop using enlightenment WM.
19:14:00 <johnw> i don't see anything
19:14:13 <johnw> but, I think there's a money on that baseball...
19:14:13 <liyang> I'm not sure what I'm supposed to be seeing.
19:14:32 <djahandarie> liyang, who cares, because now everyone's looking at your employment page!
19:14:35 <johnw> liyang: why do "traders" who program makes twice what the programmers make?
19:14:38 <copumpkin> liyang: in http://www.tsurucapital.com/img/tetto.jpg, in the upper left you'll see a slight area of dark gray
19:14:52 <int80_h> liyang: it looks like an after-image to me, an outline that is more clearly seen on the right side of the dog.
19:14:54 <copumpkin> liyang: and around her years
19:14:59 <copumpkin> *ears
19:15:00 <copumpkin> grr
19:15:02 <johnw> oh yeah, I see it now
19:15:06 <johnw> it's like a bone!
19:15:21 <copumpkin> liyang: it's a steganographic scheme to find the most awesome potential employees, admit it.
19:15:33 <copumpkin> although that would mean I just messed it up by posting in here
19:15:33 <copumpkin> dammit
19:15:52 <Jafet> So they want Ghibli fans?
19:16:04 <copumpkin> don't all companies?
19:16:14 <Jafet> I can't really argue with that
19:16:39 <johnw> it's quite visible if you only look at the blue channel
19:16:45 <copumpkin> lol
19:16:49 <liyang> I think that's just down to us not being that proficient at Photoshop.
19:16:53 <johnw> it's just artifacts left over from masking out the dog
19:16:54 <copumpkin> now I've got everyone looking at their employment page
19:16:59 <djahandarie> copumpkin, interestingly enough, if you rotate your head to the right and look at http://www.tsurucapital.com/img/logo.jpg, it kind of looks like a running dog.
19:16:59 * copumpkin bows
19:17:36 <copumpkin> :)
19:17:58 <tgeeky> i see that
19:18:20 <ddarius> johnw: Why would you pay someone who can do A + B less than someone who can only do B?
19:19:02 <johnw> ddarius: it depends on if we're talking about a trader who knows a little programming versus a senior engineer, or a senior enginer-cum-trader versus a junior engineer who doesn't have the skills to also trade
19:19:20 <copumpkin> johnw: I think their idea of trader is "l33t haskeller who also makes us lots of money"
19:19:41 <liyang> We're all programmers.
19:19:42 <ddarius> johnw: Well since "elite intern" was suggested for the programmer position, it doesn't sound like a "senior engineer" position.
19:19:50 <johnw> ah
19:20:08 <int80_h> ddarius: that's what I found appealing, I'm not a senior engineer.
19:20:31 <copumpkin> what if you're a senior in an engineering program?
19:20:33 <liyang> I don't think we're large enough to have that level of hierarchy. There's only a dozen of us.
19:21:02 <copumpkin> that's a fair number of haskellers in one place
19:21:06 <int80_h> wow
19:21:39 <johnw> i want Programmer Emeritus of Awesomeness Who Is Too Good to Trade, for $24000/month
19:21:42 <int80_h> that sounds like shangri-la to me.
19:21:51 <copumpkin> johnw: why would you not want to trade?
19:22:01 <johnw> sounds very stressful
19:22:12 <liyang> Well it's all automated.
19:22:16 <copumpkin> unless you have 100%* guaranteed winnings
19:22:16 <johnw> and you'd be creating things that would become invalid relatively quickly
19:24:24 <copumpkin> johnw: the whole infrastructure might not
19:24:27 <copumpkin> the individual strategies might
19:24:39 <copumpkin> not really sure what kinds of things they do, and they probably don't talk about it much :P
19:25:01 <copumpkin> liyang: or do you? :)
19:26:01 <Jafet> I can't say for sure, but I'd guess that you'd try to sell things at a higher price than when they were purchased.
19:26:02 <liyang> I guess it's more iterative rather than replacing strategies entirely.
19:26:15 <liyang> Jafet: buy high sell low!
19:26:24 * ddarius thinks about Ed's rough salary and where Ed lives and can only come to the conclusion that he (Ed) fucked up by getting an education.
19:26:26 <copumpkin> that's always been my strategy with bitcoin
19:26:28 <Z`> mm, why span (>5) [1..10] returns empty list as the 1st element of the tuple ?
19:26:43 <liyang> (is what Knight Capital did.)
19:26:53 <copumpkin> lots of people do it
19:26:57 <Jafet> > (>5) 1
19:26:58 <lambdabot>   False
19:27:15 <copumpkin> it's the easiest strategy to implement :)
19:27:30 <djahandarie> ddarius, how are your undergraduate studies going?
19:27:40 <ddarius> djahandarie: They were completed a while ago.
19:27:45 <shachaf> copumpkin: Isn't randomness easier?
19:27:47 <Z`> Jafet: but (>5) 6 is true. Shouldn't it return [6..10] ?
19:27:48 <int80_h> it makes sense that if you have so much money it's falling out th window, you'd want to get rid of some of it.
19:27:54 <startling> Z`: it breaks the list where the predicate is false
19:27:56 <djahandarie> Nice. Degree in CS?
19:28:03 <startling> Z`: (for the first time)
19:28:04 <shachaf> ddarius was undergraduate-studying?
19:28:05 <Jafet> > partition (>5) [1..10]
19:28:06 <ddarius> shachaf: Making a good random number generator isn't easy.
19:28:06 <lambdabot>   ([6,7,8,9,10],[1,2,3,4,5])
19:28:07 <copumpkin> shachaf: sure
19:28:10 <ddarius> shachaf: Not really.
19:28:23 <ddarius> djahandarie: For some value of "degree" and "CS".
19:28:24 <Jafet> ddarius: nine nine nine nine...
19:28:28 <johnw> lol
19:28:34 <johnw> Jafet: you beat me to it
19:28:38 <shachaf> "CS" stands for "Celsius", right?
19:28:46 <Z`> startling: ah ok :) thanks
19:28:59 <johnw> shachaf: it's the righthand side of (c:cs)
19:29:10 <Jafet> (b:cs)
19:29:23 <benmachine> Z`: basically, span p xs = (takeWhile p xs, dropWhile p xs)
19:29:46 <djahandarie> ddarius, by the way, what do you know about the categorical semantics for dependent elimination / induction?
19:30:38 <ddarius> djahandarie: You should be able to do something similar to the "Initial algebras are enough" in a comprehension category.
19:32:35 <ddarius> edwardk: You just missed me talking trash about your life choices.
19:32:44 <edwardk> which ones?
19:32:46 <djahandarie> I've seen it interpreted as the section over the display map B -> W where B is given an F-algebra structure, and the display map is an F-algebra homomorphism.
19:32:54 <ddarius> edwardk: The education one.
19:33:08 <edwardk> how so?
19:33:16 <djahandarie> I think just saying "initial algebras are enough" still only gives you recursion in a dependently typed context.
19:33:35 <int80_h> anyone use reactive-banana? I'd like to throw out some design ideas I have for a project of mine.
19:33:47 <ddarius> djahandarie: Do you know the paper I'm referring to?
19:33:49 <johnw> int80_h: what do you use it for?
19:33:57 <ddarius> edwardk: The crippling debt.
19:34:07 <djahandarie> ddarius, oh, didn't realize you were talking about a paper. I'll go look at that.
19:34:21 <edwardk> meh
19:34:23 <int80_h> johnw: I'm writing an implementation of "Grand Theft Wumpus".
19:34:51 <johnw> oh, that was you
19:34:51 <Jafet> Sounds violent.
19:34:54 <int80_h> johnw: Starting very simply, just having a Player being able to traverse a simple Graph that represents the city.
19:35:02 <johnw> I saw your e-mail
19:35:03 <int80_h> johnw: yup.
19:35:31 <int80_h> johnw: I've had time to re-think my approach. Maybe I do have a dynamic graph after all.
19:36:37 <int80_h> johnw: I was thinking, at first, that the graph doesn't change, only they values inside a given node.
19:36:52 <int80_h> johnw: But I think that's the wrong way to think about this.
19:37:05 <djahandarie> ddarius, okay, quickly skimmed it, but I don't think this will give you dependent elimination, even in a category for dependent type theories that handle substitution and such correctly.
19:37:26 * hackagebot hOpenPGP 0.5 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.5 (ClintAdams)
19:42:31 <ered> I'm trying to build haskell-platform on arch in AUR. First time I got an error about GHC being too new (7.4.2 vs 7.4.1). I added --enable-unsupported-ghc-version to ./configure in the PKGBUILD but then I got this error when building HUnit
19:42:39 <ered> ghc-pkg: /usr/lib/ghc-7.4.2/package.conf.d/: openBinaryTempFile: permission deni
19:42:39 <ered> ed (Permission denied)
19:42:52 <ered> It's the same error message in https://aur.archlinux.org/packages.php?ID=56992
19:43:00 <ered> Should I go ask this in #archlinux instead or is here okay?
19:48:49 <mm_freak> what's the easiest way to get the current available system memory?
19:49:06 <mm_freak> the size of
19:49:41 <mm_freak> is there a way without going through the 'free' command?
19:49:44 <zzing> :t zip
19:49:45 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
19:49:55 <ered> okay that feels like cheating, i had to make the package as root
19:50:02 <ered> like that can't be right
19:50:08 <zzing> :t (<*>)
19:50:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:50:27 <zzing> :t (<*>) zip
19:50:29 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
19:51:04 <copumpkin> mm_freak: it's not a well defined concept
19:51:21 <copumpkin> especially across operating systems
19:51:28 <copumpkin> but even within operating systems, it's a bit misleading
19:51:34 <johnw> and do you mean stack, heap, virtual mem?
19:55:13 <zzing> How does (<*>) Data.Sequence.zip    become (Seq a -> Seq b) -> Seq a -> Seq (a,b)    I am having trouble figuring out the types
19:57:09 <ddarius> :t Data.Sequence.zip
19:57:10 <lambdabot> forall a b. Seq.Seq a -> Seq.Seq b -> Seq.Seq (a, b)
19:57:24 <ddarius> :t (<*>)
19:57:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:57:45 <parcs`> :t \f -> const ((<*>) f) (f undefined)
19:57:46 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
19:57:58 <ddarius> :t asTypeIn
19:57:59 <lambdabot> forall a b. a -> (a -> b) -> a
19:58:24 <ski> match `f1 (a1 -> b1)' with `Seq a0 -> Seq b0 -> Seq (a0,b0)', getting :
19:58:31 <ivanm> @index asTypeIn
19:58:31 <lambdabot> bzzt
19:58:32 <ski>   f1 = (Seq a0 ->)
19:58:35 <parcs`> :t \f -> (<*>) f `asTypeIn` ($ undefined)
19:58:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:58:37 <ivanm> where is asTypeIn from?
19:58:42 <copumpkin> ivanm: it's const, with a more restricted type
19:58:44 <copumpkin> L.hs
19:58:45 <ski>   a1 = Seq b0
19:58:47 <ivanm> ahhh
19:58:48 <copumpkin> or whatever it is
19:58:53 <ski>   b1 = Seq (a0,b0)
19:58:54 <ivanm> copumpkin: just never heard of it before :)
19:58:59 <copumpkin> it's a lambdabot thing
19:59:02 <ivanm> I know asTypeOf, but not asTypeIn
19:59:04 <ivanm> *nod*
19:59:06 <copumpkin> I think ski came up with it
19:59:08 <copumpkin> or someone in here
19:59:13 <copumpkin> when in doubt, blame ski
19:59:20 <ivanm> copumpkin: well, it's unlikely for a non-IRCer to add it to lambdabot :p
19:59:27 <ddarius> copumpkin: That's my motto too.
19:59:27 <mm_freak> copumpkin: the point is:  i want to allocate a chunk of memory of the given size or the free system memory if no size is given
19:59:34 <ski> then `f1 a1 -> f1 b1' becomes `(Seq a0 ->) Seq b0 -> (Seq a0 ->) Seq (a0,b0)'
19:59:48 <mm_freak> copumpkin: this is for a very practical application
19:59:57 <ski> iow `(Seq a0 -> Seq b0) -> (Seq a0 -> Seq (a0,b0))'
20:00:08 <copumpkin> mm_freak: some OSes strive to keep almost no free memory at most times
20:00:13 <ski> @src asTypeIn
20:00:14 <lambdabot> a `asTypeIn` f = a where _ = f a
20:00:14 <lambdabot> infixl 0 `asTypeIn`
20:00:16 <ivanm> copumpkin: I think that's the latest trend
20:00:22 <matthavener> can i coerce the return value of a function into two separate types in a list comprehension? something like [ ms | str <- listofstrs, let m = str =~ "someregex", let (_,_,_,_,ms) = m, m :: Bool]
20:00:22 <ivanm> because if it's free it takes longer to allocate
20:00:27 <mm_freak> copumpkin: 'free' respects that, unless you call it with -o
20:00:28 <ski> ivanm : suggested by me to Cale
20:00:28 <ivanm> and it's useless
20:00:33 <ski> @where L.hs
20:00:33 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
20:00:50 <ski> @type asAppliedTo
20:00:51 <lambdabot> forall t b. (t -> b) -> t -> t -> b
20:00:52 <ivanm> ski: OK, I _was_ tempted to suggest Cale when copumpkin said you should be blamed :p
20:01:14 <mm_freak> copumpkin: then a different question:  is there a way to get the current RAM size?
20:01:20 <ski> @remember copumpkin when in doubt, blame ski
20:01:20 <lambdabot> Done.
20:02:16 <copumpkin> mm_freak: not that I know of
20:02:25 <copumpkin> I don't think it's generally encouraged to base your decisions on things like that
20:02:32 <copumpkin> which might be why APIs for them are lacking
20:03:16 <ski> matthavener : `m' can only have one type -- not sure if that's what you're asking about
20:03:17 * ivanm is tempted to @remember ski tacitly admitting that he should be the default point of blame by @remembering copumpkin's quote :p
20:03:47 <matthavener> ski: yep, basically
20:03:57 <ivanm> matthavener: how can a Bool be a tuple though?
20:04:00 <ski> matthavener : in any case, a type signature isn't valid (directly) inside a list comprehension
20:04:02 <ivanm> what you're saying doesn't seem to make sense...
20:04:09 <ddarius> ski: If it was let-bound rather than lambda-bound, it could be instantiated to different types.
20:04:17 <ivanm> and since you're not using m as a Bool, why would you want to?
20:04:23 <ddarius> -,
20:04:35 <matthavener> ivanm: what
20:04:55 <matthavener> i'm using it as a bool to filter the list for the comprehension
20:04:59 <ivanm> matthavener: how want m to be a Bool, but you're also treating it as a 5-tuple
20:05:02 <ddarius> What he's doing should work fine.
20:05:06 <ski> ddarius : hm, point. for some reason i was assuming matthavener meant `m :: Bool' as a type signature, not as an ascription
20:05:07 <ivanm> in let (_,_,_,_,ms) = m
20:05:54 <ddarius> I thought he wanted str to be instantiated at different types, but he just wants m to be, and that's no problem.
20:06:05 <ddarius> +at first
20:06:06 * ski nods
20:06:14 <matthavener> ivanm: yeah i want to coerce it to a bool for the filter, and coerce it to a 5 -tuple to get the sub-parts of the regex
20:06:26 <ddarius> matthavener: "Coerce" is a bad choice of words.
20:06:26 <ski> matthavener : see what ddarius said above
20:06:31 * ivanm is confused as to how that a) makes sense, and b) could possibly work
20:06:41 <johnw> danr: ping
20:06:44 <ddarius> ivanm: You haven't used regexes in Haskell enough.
20:06:53 <ivanm> ddarius: s/ enough// ;)
20:06:56 <matthavener> ddarius: what's the proper term?
20:07:10 <ddarius> matthavener: "Instantiate"
20:07:18 <matthavener> ah ok
20:07:29 <matthavener> so what do you mean by making it "let bound"? ddarius?
20:07:30 <ski> > let m :: Read a => a; m = read "1234" in (m :: Integer,m :: Double)  -- ivanm, compare
20:07:31 <lambdabot>   (1234,1234.0)
20:07:31 <ivanm> ddarius: oh, the "let m = " remains as a non-monomorphic type?
20:07:40 <ivanm> ski: yeah, just figured it was that case
20:08:03 <ddarius> Unless you are using a very new GHC with some new-ish extensions, yes.
20:08:10 <ivanm> *nod*
20:08:29 <ddarius> (Even then it would work with a type signature.)
20:08:58 <ski> matthavener : another valid term would be "constrain"
20:09:13 <matthavener> so, i need to bind it to two different names with let ?
20:09:26 <ddarius> matthavener: No, what you wrote should just work.
20:09:29 <ski> matthavener : you can say that in `m :: Bool' you ascribe that expression the type `Bool', thereby constraining it to have that type
20:09:39 <matthavener> ddarius: strange, ok, let me paste what i have
20:09:45 <matthavener> and my error
20:10:01 <ski> and because `m' is polymorphic, this will work simultaneously as `let (_,_,_,_,ms) = m'
20:11:17 <ddarius> This is probably not a big concern, but doing this will lead to the regex match occurring twice.
20:11:17 <rwbarton> does MonoLocalBinds apply here?
20:12:08 <ddarius> You could just use the results from the tuple to determine whether a match occurred.  (Surely one component of the five-tuple conveniently answers that question.)
20:12:31 <hpaste> matthavener pasted “multiple instantiations” at http://hpaste.org/74615
20:14:45 <rwbarton> this sort of thing seems to work with -XNoMonomorphismRestriction and -XNoMonoLocalBinds
20:15:44 <matthavener> is that a global ghc option?
20:16:03 <ivanm> either global or at least per-module, depending how you set it
20:16:15 <rwbarton> you can set them in ghci (:set -XNoMonoLocalBinds) or in a file ({-# LANGUAGE NoMonoLocalBinds #-})
20:16:29 * ddarius remembers the good ole days of -fglasgow-exts
20:16:46 <matthavener> interesting, cool, let me try that
20:16:50 <rwbarton> we should have -Xn options like -On options
20:17:10 <ivanm> rwbarton: except it's harder to tell what numeric options there should be
20:17:20 <ivanm> ddarius: AKA "enable all the things"? :p
20:17:22 <Ralith> obviously it should be the decimal encoding of a bitfield
20:17:28 <ivanm> Ralith: heh
20:17:30 <ddarius> ivanm: No, it didn't enable everything.
20:17:37 <ivanm> ddarius: oh? what didn't it enable?
20:17:59 <ddarius> ivanm: OverlappingInstances I think, and definitely not IncoherentInstances and UndecidableInstances.
20:18:12 <ivanm> oh, the _really_ dangerous ones?
20:18:27 <rwbarton> ivanm: -X1 would give the stuff everybody likes, -X2 would give the stuff I like, -X3 would give the stuff only crazy people like. :)
20:18:47 <ivanm> rwbarton: what does _everybody_ like though?
20:19:00 <ddarius> NoMonomorphismRestriction
20:19:04 <rwbarton> TypeSynonymInstances
20:19:21 <ivanm> rwbarton: I think I'll beg to differ on TypeSynonymInstances
20:19:34 <rwbarton> seriously?
20:19:49 <ddarius> NHC just never implemented the monomorphism restriction.  Presumably HBC never implemented it either.
20:20:25 <ivanm> rwbarton: from memory I had a case where it had some subtle breakage; admittedly, that could have been a different error :p
20:20:43 <ivanm> but I generally take the Show approach when I want to special case String, etc.
20:20:49 <rwbarton> that is FlexibleInstances
20:21:14 <rwbarton> TypeSynonymInstances means if I have type T = T' I can write instance C T instead of instance C T'
20:21:24 <startling> no type synonym instances is pretty silly. what if a module exports a type synonym but doesn't give you the original, for instance?
20:21:25 <ivanm> yeah, maybe I'm getting them mixed up
20:21:56 <startling> it makes you code around implementation details
20:22:16 <rwbarton> Sort of a moot point though since I would have included FlexibleInstances and FlexibleContexts in -X1 as well
20:22:24 <startling> hehe
20:22:50 * ivanm afk for a bit
20:23:43 <shachaf> rwbarton: I'd also like things like -OUnboxStrictFields and -WNoIncompletePattern.
20:24:43 <rwbarton> don't those things exist?
20:24:56 <shachaf> No, it's all -f
20:25:00 <rwbarton> oh, okay
20:25:12 <shachaf> I'd also like {-# WARN/OPTIMISE #-}
20:25:20 <shachaf> Though maybe that's too compiler-specific to be very useful.
20:25:38 <shachaf> I'd particularly like localized {-# WARN #-}.
20:25:46 <rwbarton> yeah
20:26:23 <shachaf> (Though that's unrelated to everything else I've said.)
20:26:27 <zzing> {-# Delete All Files #-}
20:26:44 <shachaf> zzing: .ghci is able to do that; that's enough for me.
20:26:49 <shachaf> I guess TemplateHaskell can do it too.
20:27:20 <Jafet> {-# EX-TER-MI-NATE #-}
20:27:41 <monochrom> exterminate all humans
20:28:04 <ddarius> Just the kind of thing monochrom would say.
20:28:40 <shachaf> {-# LANGUAGE TERMINATE #-}
20:28:47 <Jafet> -XTerminate
20:28:50 <zzing> {-# rm -fr / #-}
20:28:55 <monochrom> heh
20:28:57 <ddarius> 50 pages of introductory text from 2000 or 22 pages of original research from 1999?
20:29:04 <startling> -XNoHaltingProblem
20:29:39 <startling> if (not isHalting) halt
20:30:33 <zzing> {-# P=NP #-}
20:31:20 <shachaf> No halting? No problem!
20:33:58 <ddarius> Yay solutions that produce answers of no practical interest!
20:34:57 * ddarius is starting to like this paper.
20:35:27 <ski> preflex: xseen augustss
20:35:33 <shachaf> ski: preflex is dead. :-(
20:35:34 <ski> preflex: xseen preflex
20:35:56 <shachaf> And augustss is not dead, but you might think so if your only source was IRC.
20:36:30 <monochrom> right, but we're just saying that preflex is dead
20:36:46 <monochrom> misread. nevermind.
20:37:21 <mgsloan> I hope mmorrow is alright
20:37:23 <mgsloan> :(
20:38:03 <ski> and there's TheHunter ..
20:38:10 <mgsloan> oh yeah
20:38:50 <zzing> I am having trouble figuring how (Seq.zip <*>) becomes (Seq a -> Seq b) -> Seq a -> Seq (a,b)  when (<*>)  takes an Seq (a -> b) -> Seq a -> Seq b   but Zip is Seq a -> Seq b -> Seq (a,b) - how does this zip work into (Seq a -> Seq b)?
20:39:05 <mgsloan> well if I get super busy, and maybe start having some life balance it might happen to me too!  (not that I'm really a very prominent denizen)
20:39:13 <ski> zzing : did you see my explanation above ?
20:39:41 <zzing> ski, I missed that completely, let me go up
20:40:39 <johnw> zzing: also, I think Seq.zip <*> is using the Applicative for (->) r
20:40:52 <ski> yes
20:40:56 <zzing> ski, I see that now but I am not sure I am following it
20:41:07 <zzing> oh dear, that is why I am not getting this
20:41:22 <shachaf> zzing: (<*>) x y z = x z (y z)
20:41:36 * ddarius encourages all Haskell educators to start their classes by teaching Prolog.
20:41:49 <johnw> is there a Prolog implementation for Haskell?
20:41:54 <shachaf> ddarius: Typical.
20:42:15 <ski> zzing : `Seq a -> Seq b -> Seq (a,b)' is the same as `(Seq a ->) (Seq b -> Seq (a,b))' (pseudo-syntax), or `(->) (Seq a) (Seq b -> Seq (a,b))' (actual syntax)
20:43:25 * ski . o O ( "TYPICAL for Annotated Prolog" <http://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/news/tools/others/typical.html> )
20:44:48 <ddarius> "There are no restrictions on the Prolog programs. For instance, you do not have to restrict your code to a subset of Prolog in order to type check it. On the other hand, type checking will not always ensure type safety."
20:46:58 <zzing> ski, so that treating (->) as a function with (Seq a) as the first parameter (Seq b -> Seq (a,b))
20:48:16 <ski> zzing : it's hard to parse what you just wrote
20:48:23 <zzing> sorry
20:49:30 <zzing> ok, so another way of putting zip is   (->) (Seq a) (Seq b -> Seq (a, b)      but turning -> from an operator into a function, so how does Seq a match f (a->b) of <*>
20:50:35 <ddarius> @google "On the statistical analysis of dirty pictures"
20:50:37 <lambdabot> http://www.stat.duke.edu/~scs/Courses/Stat376/Papers/GibbsFieldEst/BesagDirtyPicsJRSSB1986.pdf
20:50:37 <lambdabot> Title: On the Statistical Analysis of Dirty Pictures Julian Besag Journal of the Royal  ...
21:03:36 <ski> zzing : `f' matches `(->) (Seq a)'
21:03:55 <ski> (because `(->) (Seq a) (Seq b -> Seq (a, b)' really is `((->) (Seq a)) (Seq b -> Seq (a, b)')
21:07:39 <zzing> ski, this is almost breaking my mind :-), triyng harder ...
21:09:25 <zzing> ski, so if I rewrite <*> with (->) (Seq a)  replacing f, should that be a direction to understanding what this is doing?
21:09:56 <ski> yes
21:10:47 <YayMe> Has anyone here looked at Ela at all?
21:11:45 <ski> @type (<*>) `asAppliedTo` Data.Sequence.zip
21:11:46 <lambdabot> forall a b. (Seq.Seq a -> Seq.Seq b -> Seq.Seq (a, b)) -> (Seq.Seq a -> Seq.Seq b) -> Seq.Seq a -> Seq.Seq (a, b)
21:11:57 <ski> @type (<*>)
21:11:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:12:15 <ski> the latter gets specialized to the former, when being applied to `Data.Sequence.zip'
21:15:30 <zzing> Now (->)Seq a  is a structure containing all functions taking Seq a correct?
21:17:26 * BMeph would disagree with "structure," but otherwise...
21:18:05 <zzing> BMeph, would you accept collection?
21:18:34 * ddarius would say zzing's terminology indicates significant confusion.
21:19:10 <zzing> ddarius, quite right
21:20:09 <zzing> ddarius, I have the function I needed, but I want to understand how it works and this is some real crazy shit I got myself into :P
21:20:42 <monochrom> "Seq a" is a type. "(->) (Seq a)" is also a type.
21:21:19 <monochrom> however, it is a strange type
21:21:21 <ski> however, the latter isn't a "concrete type"
21:21:41 <monochrom> here, "strange" is just casual english
21:21:59 <ski> just like saying `x :: Maybe' is nonsense, `x :: (->) (Seq a)' would also be nonsense
21:22:42 <ski> iow, like e.g. `Maybe',`IO',`Either',`Either (Bool -> String)', `(->) (Seq a)' is a type that can't possibly have any values, because it's not "complete"
21:22:59 <ddarius> :k (->) (Seq Int)
21:23:00 <lambdabot> Not in scope: type constructor or class `Seq'
21:23:09 <ddarius> :k (->) (Data.Sequence.Seq Int)
21:23:11 <lambdabot> ? -> *
21:23:26 <ski> however, if we apply this type to e.g. the type `[a -> Bool]' we get a concrete type `(->) (Seq a) [a -> Bool]', which is the same as `Seq a -> [a -> Bool]'
21:23:41 <zzing> I don't know kinds exactly
21:25:08 * ddarius thinks he has $15-20 in quarters on his window sill.
21:25:19 <frio> ski: just for my own sanity, (->) (Seq a) is a prefix way of writing Seq a ->, right?
21:26:04 <shachaf> frio: Yes, except that the latter is invalid syntax (on its own).
21:26:12 <ski> frio : `(->) (Seq a) Blah' is a prefix way of writing `Seq a -> Blah', yes
21:26:14 <frio> yep shachaf :).  cool, thanks
21:26:15 <shachaf> "a -> b" really means "(->) a b"
21:26:30 <td123> hi, I'm getting the following error when trying to compile glib with ghc 7.6.1 pastie.org/4705733
21:27:18 <ski> often we write `(Seq a ->)' instead of (just) `(->) (Seq a)' (by analogy with operator sections on the expression level), but that's just pseudo-syntax, not actual allowed syntax
21:27:40 <frio> i see
21:27:41 <td123> I've encountered this type of error before, where a newtype has to have its constructor imported along with the type, but I can't seem to decipher this error
21:28:55 <Clint> td123: why are you passing an IO ()?
21:29:46 <td123> Clint: not really sure, I didn't write this code, just trying to fix the compile error
21:31:54 <zzing> Is (a ->) the Reader?
21:32:02 <shachaf> @src Reader
21:32:02 <lambdabot> Source not found. I am sorry.
21:32:14 <shachaf> newtype Reader r a = Reader (r -> a)
21:32:20 <shachaf> So yes. :-)
21:32:42 <Clint> td123: what's the c function prototype?
21:33:01 <ddarius> In numerous applications, sL^3 << s^L
21:34:25 <copumpkin> > 207691874341393105141219853168803840001 * 2**(-125) :: CReal
21:34:26 <lambdabot>   4.8828125000000000000000000000000000000235
21:34:54 <copumpkin> > 207691874341393105141219853168803840001 * 2**(-115) :: CReal
21:34:55 <lambdabot>   5000.0000000000000000000000000000000000240741
21:35:00 <copumpkin> that's more like it
21:35:14 <ddarius> Forgot to borrow the 1?
21:35:28 <latro`a> > 2^115
21:35:29 <lambdabot>   41538374868278621028243970633760768
21:35:35 <copumpkin> trying to figure out my exponent given my significand
21:35:38 <latro`a> > 2^115*5000
21:35:39 <lambdabot>   207691874341393105141219853168803840000
21:35:44 <latro`a> ahh
21:35:46 <latro`a> got it
21:36:10 <latro`a> > 2**(-115) :: CReal
21:36:11 <lambdabot>   0.0000000000000000000000000000000000240741
21:37:01 <ddarius> copumpkin: Wouldn't a logarithm be a more traditional method?
21:37:11 <copumpkin> if I were smart, maybe
21:37:20 <td123> Clint: http://developer.gnome.org/glib/2.31/glib-Datasets.html#GDestroyNotify
21:37:27 <ddarius> "Figure 1 about here"
21:38:06 <jathd> Hi. I'm trying to write an REPL that parses input with Parsec. Is there a way to make it consume just as much input as it needs? I can only see ways to make it parse a String, but then I'd have to decide before parsing how much input I need, which I can't do without parsing...
21:39:18 <ddarius> jathd: You can run the parser and have it return the remainder.
21:42:23 <mm_freak> ddarius: i don't see a way to do that with parsec
21:42:36 <jathd> ddarius: Ok, but I still have to take too much input, not too little...
21:42:52 <mm_freak> you can really only let that become part of the parser
21:43:06 <rwbarton> you want something like the python interpreter's multi-line input?
21:43:20 <jathd> mm_freak: using getInput?
21:44:32 <jathd> rwbarton: it's for a Lisp; assume the user types "(+ 1" on line 1 and then "2)" on the second line.
21:44:48 <jathd> I'd need to read 2 lines and give them to parsec
21:44:55 <shachaf> Multi-lion input? Have you no shame?
21:45:06 <jathd> But how do I know I don't need 3? (Without parsing...)
21:45:16 * shachaf guesses that pun was too far stretched.
21:45:37 <ddarius> mm_freak: runParsecT gives you the final parsing state, though it's probably easier to just do liftM2 (,) p getInput
21:45:50 <rwbarton> I bet you can cook up something with a parsec Stream in some kind of ContT r IO monad
21:46:04 <mm_freak> jathd: apparently you want more than you asked for…  unfortunately parsec doesn't give you a nice interface for incremental parsing
21:46:29 <mm_freak> jathd: you could try attoparsec (no error reporting) or trifecta (amazing error reporting, harder to learn)
21:46:49 <ddarius> rwbarton: You can do incremental parsing with Parsec 3 with enough abuse.
21:47:09 <jathd> Oh wait, actually what you suggested might work. If I run parsec again and again on the remaining input, and at the end something remains, then it means it needs more input.
21:47:44 <jathd> But I'll also go take a look at trifecta.
21:48:12 <ddarius> Trifecta probably is a good choice for this.  attoparsec doesn't make much sense.
21:48:14 <mm_freak> jathd: you can't just restart the parser…  you have to actually interrupt the parsing
21:48:33 <zungaloca> soooo how can i update GHC
21:48:36 <martint> is there a way to specify a short name for the current module for the purpose of disambiguating names?
21:48:39 <zungaloca> with cabal?
21:48:40 <mm_freak> ddarius: attoparsec can parse Text by now, but it still doesn't have error reporting
21:48:50 <mm_freak> zungaloca: which operating system?
21:49:26 <zungaloca> mm_freak: OSX
21:49:33 <roconnor> > let ns = 1 : 1 : zipWith (+) ns (tail ns) in take 10 ns
21:49:35 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
21:49:45 <jathd> mm_freak: I don't understand what you mean. If I give it "1 (+ 2" it could parse 1 and return "(+ 2" as remaining input; then I give it "(+ 2" and it returns no parse with remaining input "(+ 2", so I know it needs more input.
21:50:00 <mm_freak> martint: that's not possible (AFAIK), so your best bet is to import the other module with a short name and qualified
21:50:10 <jathd> mm_freak: Although that might break error reporting...
21:50:37 <mm_freak> jathd: what about "(+ 2" itself?
21:50:41 <mm_freak> you can't just restart the parser
21:50:48 <ddarius> jathd: Yes, but then you either need to restart at the beginning and reparse, or ...
21:50:58 <ddarius> Beginning being "(+ 2" here.
21:51:20 <jathd> ddarius: Yes, I was thinking of reparsing from the beginning
21:51:33 <jathd> Not very efficient, but well...
21:51:58 <ddarius> It would probably be adequate for a REPL until someone cats their file into it.
21:52:03 <zungaloca> ?
21:52:33 <mm_freak> it also will make position reporting and other things more difficult
21:52:46 <mm_freak> i recommend using an incremental parser
21:53:02 <ddarius> Trifecta is a good fit for this and probably worth learning.
21:53:06 <jathd> mm_freak: Yeah, I think I'll do that.
21:53:30 <jathd> Ok, I'm off to learn trifecta then. Thanks a lot.
21:58:53 <roconnor> is Ivan Tarasov here?
22:02:08 <shachaf> roconnor: He's rarely on IRC, but he's online.
22:02:51 <roconnor> ok
22:03:01 <roconnor> it isn't urgent
22:03:43 * shachaf wonders the context.
22:05:13 <roconnor> I'm in the Bay area in the next two weeks and I wanted to post to the BAHUG list.
22:06:04 <shachaf> Oh, you should come!
22:06:28 <shachaf> The meeting is usually on the third Wednesday of the month.
22:06:38 <roconnor> I intend to come
22:07:11 * timthelion has a new feature request :)
22:07:22 <roconnor> I couldn't tell if you had a speaker, so I offered to scramble together a talk on lenses/traversals (or maybe something else) if you guys wanted.
22:07:39 <roconnor> OTOH I see now that edwardk is scheduled in October on the same topic :D
22:07:46 <shachaf> roconnor: Hah, edwardk is -- yes. :-)
22:07:47 <roconnor> so maybe you don't need two back to back talks
22:07:51 <timthelion> > let data Foo = Bar | Baz ; f Bar = "hi" ; f Baz = "bye" in f Bar -- I want to let data constructors.  Of course you wouldn't be able to return a type that was leted, but you can use it within the scope of the let.
22:07:52 <lambdabot>   <no location info>: parse error on input `data'
22:08:05 <edwardk> roconnor: heh
22:08:36 <shachaf> roconnor: But I'm sure people would be happy to have you speak. I don't know if there's something arranged yet.
22:09:00 <eyebloom> Is there a way to construct a type such that one of the parameters is taken apart as shown in this paste?
22:09:03 <hpaste> ibloom pasted “Type question” at http://hpaste.org/74617
22:09:41 <roconnor> shachaf: I could also talk about Haskelly related things such as Nixos or Coq/SSReflect/Proof of the odd order theorem.
22:09:55 <Twisol> eyebloom: I'm a novice, but GADTs might be useful?
22:09:59 <roconnor> shachaf: of course if you do have a speaker arranged then I don't have to do any work!
22:10:02 <eyebloom> or some alternative method of achieving something similar.
22:10:03 <Twisol> And/or phantom types
22:10:11 <c_wraith> actually, I think that one's a case for type families
22:10:22 <eyebloom> How would you construct such a type?
22:10:29 <shachaf> roconnor: Those sound interesting!
22:10:39 * shachaf sort of gave up on NixOS a while ago but maybe things have changed since then.
22:11:07 <startling> nixos is pretty crazy
22:11:13 <startling> I never got the hang of it either
22:13:52 <roconnor> shachaf: oh?  I've been running NixOS for almost 3 years now.
22:14:09 <shachaf> roconnor: <ivant> I had a speaker, but he hasn't yet confirmed, so we might need Russel
22:14:17 <shachaf> I think he saw your joining-list request, anyway.
22:14:23 <roconnor> ah okay
22:14:34 <shachaf> roconnor: Ah, it's quite possibly more than 3 years ago that I tried it.
22:15:04 <timthelion> Has an STM for network protocol been written for haskell?  If I have value A shared by 10 peers over a network. And two peers set value A, then I have a race condition.  It seems to me, that the best way arround this is a "value version number" so peer1 sets value A version 1 and peer2 sets valueA version1 at the same time.  At some point a peer3 is asked by both peer1 and peer2 to set valueA version1 and so peer3 tells peer1 and peer2 to r
22:15:11 <roconnor> shachaf: you might want to give it a try again.  I mostly love it
22:15:11 <timthelion> Has this been done yet?
22:15:48 <shachaf> roconnor: Maybe next computer/hard drive failure. :-)
22:15:57 <edwardk> if i told my wife i mostly loved her, i'd be sleeping on the couch ;)
22:15:58 <roconnor> shachaf: It was a bit disappoint at first when I realized it didn't solve *all* software dependency problems, but it does solve many of them.  And atomic, revertable, system upgrades is so nice.
22:16:06 <roconnor> shachaf: yep
22:16:24 <roconnor> edwardk: does your wife have atomic rollbacks?
22:16:27 * timthelion has yet to figure out how peer3 telling both peer1 and peer2 to retry at the same time(especially if peers 4 5 and 6 were alos doing so, how this wouldn't lead to a loop of peer1 and peer2 both trying to set valueA version1 again...)
22:17:00 <edwardk> roconnor: she's a personal trainer. maybe she has an exercise by that name, but I don't know ;)
22:17:42 <shachaf> I love almost all of you! If you pick an arbitrary thing about you, I love it with probability 1!
22:21:25 <Gracenotes> shachaf: man, Cantor was crazy.
22:22:33 <shachaf> Gracenotes: He certainly ended up that way!
22:22:49 <Twisol> I read a little about Kleisi arrows recently. What I got out of it is that (<=<) is to (.) as (=<<) is to ($). Is that right?
22:24:39 <roconnor> Twisol: that seems about right.
22:24:56 <roconnor> @src (.) Kleisli
22:24:57 <lambdabot> Source not found. That's something I cannot allow to happen.
22:25:03 <roconnor> @src Kleisli (.)
22:25:03 <lambdabot> Source not found. My mind is going. I can feel it.
22:25:15 <Gracenotes> shachaf: I think it's always a useful thing to remember when you see really strange consequences of being able to reason about infinity.
22:25:52 <Gracenotes> like uniform probability distributions...
22:28:23 <ski> @type liftA2 (Prelude..)
22:28:25 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
22:30:47 <ski> timthelion : fyi, cut off near ".. At some point a peer3 is asked by both peer1 and peer2 to set valueA version1 and so peer3 tells peer1 and peer2 to r"
22:36:07 <timthelion> ski: thanks... At some point a peer3 is  asked by both peer1 and peer2 to set  valueA version1 and so peer3 tells peer1  and peer2 to retry.
22:36:44 <timthelion> Seems like it should be a classic application of STM, to share values over a network.
22:37:50 <ketil> cs
22:37:50 <lambdabot> ketil: You have 1 new message. '/msg lambdabot @messages' to read it.
22:40:31 <Cale> I want her almost everywhere/And if she's within epsilon I know my cares have probability zero./But to love her is to need her on a set with null complement in Borel measure~
22:40:41 <Cale> Not quite as catchy as the original
22:41:33 <shachaf> Not as catchy, but more cauchy, perhaps.
22:42:04 * BMeph clicks his instantrimshot.com button!
22:47:38 <ddarius> Kids these days.  They live in a world where buttons are clicked rather than pressed.
22:48:02 <nand`> with buckling springs, every button clicks
22:48:51 * BMeph prefers his buttons clicked, and his shirts pressed. Light starch, please, it's still hot outside...
22:57:59 <pirates> no one say  something
22:59:33 <johnw> @,l iafijt
22:59:33 <lambdabot> iafijt
22:59:36 <johnw> @wn cauchy
22:59:36 <lambdabot> No match for "cauchy".
22:59:51 <shachaf> @google cauchy
22:59:51 <lambdabot> http://en.wikipedia.org/wiki/Augustin-Louis_Cauchy
22:59:51 <lambdabot> Title: Augustin-Louis Cauchy - Wikipedia, the free encyclopedia
23:37:54 <pikitgb> Hi :) Im really new in Haskell, i have some questions about how use Haskell for the Web Programming ... (Thanks)
23:38:48 <shachaf> pikitgb: #haskell-web might know more than #haskell
23:38:53 <shachaf> But in general you should just ask your questions.
23:39:19 <shachaf> If you're just learning Haskell, I think web programming is probably not the best thing to start with.
23:41:04 <pikitgb> Is for my Tesis
23:41:16 <pikitgb> i am from cuba
23:41:36 <pikitgb> in my tesis i need work with mathematics methods
23:41:41 <pikitgb> and in my search i found that haskell is very beatifull
23:42:30 <pikitgb> The sintax is really nice
23:42:52 <pikitgb> But
23:42:53 <pikitgb> i need create a web application that in the backend work with haskell
23:42:53 <pikitgb> can i do this ?
23:43:31 <bitonic> pikitgb: if it's only the backend (e.g. user submits form, haskell application does something with the data, results are displayed) you don't need to code the web app in Haskell
23:43:50 <bitonic> pikitgb: or you can just use CGI
23:44:06 <bitonic> which works very much like in every other language
23:44:16 <adnam> but yes you can do that in haskell, there are multiple frameworks available, snap, yesod, happstack
23:44:28 <pikitgb> I try with Ruby on Rails
23:44:45 <pikitgb> but the Work with the Math functions is not really nice
23:45:04 <bitonic> don't you read "Hacker News"?  RoR is not hip anymore.  you must use node.js.
23:45:10 <adnam> :[
23:45:16 <shachaf> bitonic: Not in here, please.
23:45:31 <bitonic> shachaf: hey, I was joking.  anyway.
23:45:48 <bitonic> pikitgb: what web application do you need to program?
23:47:42 <Jafet> I use server-side HTML5.
23:54:55 <pikitgb> bitonic can you recommend some links with 'programming web in haskell' ?
23:55:40 <bitonic> pikitgb: google happstack, yesod, snap.  but if your application is simply some simple input device to some Haskell function, that's overkill
23:56:48 <bitonic> pikitgb: the happstack crash course is probably the best resource
23:56:54 <bitonic> @google happstack crash course
23:56:55 <lambdabot> http://happstack.com/docs/crashcourse/index.html
23:56:55 <lambdabot> Title: Crash Course in Happstack
23:58:48 <pdxleif> pikitgb: For simple web stuff, you could program directly against WAI: https://www.wunki.org/posts/2012-01-15-haskells-wai-for-dummies.html
23:59:25 <pdxleif> e.g. just to handle an http request / response. Then your app can be deployed as CGI or as its own webserver or whatever.
