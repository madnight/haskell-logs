00:00:07 <ddarius> djahandarie: He read the shorter one months ago.
00:00:48 <ddarius> johnw: There are utilities to read C and produce various artifacts for FFI.  Usually they don't (explicitly) go through hsc.
00:01:09 <startling> sheldonh: main = return (myFn arg) >> return () maybe?
00:01:32 <ddarius> sheldonh: Did you do --auto-all when you built?
00:02:12 * hackagebot fast-logger 0.3.1 - A fast logging system  http://hackage.haskell.org/package/fast-logger-0.3.1 (KazuYamamoto)
00:04:53 <dolio> ddarius: So, you weren't able to shape up the 'monads are M = K ()' thing the other day? :)
00:06:32 <ddarius> dolio: "Shape up"?
00:07:59 <dolio> It looks like a muddled version of the adjunction with the Kleisli category.
00:08:17 <johnw> ddarius: I have a whole bunch of files that are .hsc, but they are just a bit out of date.  The translation is purely mechanical, at this point, so for the new files I need to add, I figured there'd be something that was possible to sped things up...
00:08:22 <johnw> a "starting point" at the very least
00:08:24 <dolio> Which is a more general thing.
00:10:00 <ddarius> Sep 01 15:55:59 <ddarius> plat0: Using a more traditional CT notation, you are saying K(a,b) ~ Set(a, K(1,b)).  Of course, this would be saying a is in Set and K, so we actually need a conversion, call it I : Set -> K.  We now have K(I(a),b) ~ Set(a, K(1,b)) or I -| K(1, -)
00:10:18 <ddarius> Also, when did it become September?
00:12:08 <dolio> Yes, but it ended up on the Haskell reddit without the I.
00:12:25 <dolio> And also, that only works for monads over Set, or Hask if that's what you're enriched in.
00:12:36 <dolio> And with a 1 object.
00:12:47 <ddarius> Actually, 1 isn't used anywhere.  So it could be any object.
00:13:13 <ddarius> And yes, I defined Set = (->) earlier.  I was primarily rewording what he had.
00:16:38 <ddarius> At any rate, I thought about it a little longer, said some other random stuff, and then probably wrote a bunch of unscented Kalman filter code.
00:17:09 <ddarius> Now I think I'll write some change point detection code and read the HMM paper I downloaded many hours ago.
00:18:45 <dolio> Anyhow, if you stop caring that the functor is corepresentable, too (and why would you, really), you have K(I(a), b) ~ Set(a, U(b)).
00:19:04 <dolio> Or even K(I(a), b) ~ C(a, U(b)).
00:31:18 * ddarius should probably learn more (something) about the "KL divergence".
00:39:18 <sheldonh> ddarius: i did ghc --auto-all -rtsopts=all -prof Transpose.hs ... ghc says --auto-all is unrecognized flags
00:39:51 <Saizan> sheldonh: one dash, iirc
00:40:03 <centrinia> Is that matrix transposition?
00:42:05 <thirsteh> Do I need to worry about read contention with TVars (writes are very rare) at all?
00:43:36 <Enigmagic> no
00:45:24 <thirsteh> alright
00:46:33 <sheldonh> ddarius, Saiza: thanks. that's the secret sauce :)
00:48:31 <ddarius> centrinia: They aren't inner products, though, presumably "adjunction" is inspired by adjoint linear operators. (/me guessing context)
00:49:03 <poisonarms> http://pastie.org/4654888 - So, I am trying to write a string join function (new to Haskell, functional programming, and recursion) - I know you can do ++, but I am trying to start thinking recursively. Currently, the results of stringJoin "HELLO" " WORLD" produces "  WORLD" - Can anyone tell me how far off I am at this point?
00:49:28 <poisonarms> Rather, "  WORLD"
00:52:13 * hackagebot hxournal 0.6.6.1 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.6.1 (IanWooKim)
00:52:16 <Dodek> else (head (stringJoin (tail str1) str2)) : (str2)
00:52:29 <Dodek> this convoluted line essentially appends the head of a result to str2
00:53:07 <Dodek> and since your functions never actually use any data from str1, it's the head of str2
00:53:26 <poisonarms> Dodek: I see.
00:53:33 <Dodek> poisonarms: you really should be using pattern matching instead of ifs.
00:53:57 <poisonarms> Dodek: First day in Haskell...I'm half way down the first page of Learn You A Haskell, :P
00:54:03 <Dodek> and you shouldn't check if length is equal to zero, if all you care is whether list is empty.
00:54:16 <Dodek> it should be something like
00:54:25 <Dodek> stringJoin [] str2 = str2
00:54:35 <Dodek> stringJoin (x:xs) str2 = ...
00:54:56 <Dodek> now you have x as the head of a first argument and xs as a tail
00:55:24 <Dodek> what you want to do now is to append xs to str2 and the head to the result
00:57:13 * hackagebot sylvia 0.2.0.1 - Lambda calculus visualization  http://hackage.haskell.org/package/sylvia-0.2.0.1 (ChrisWong)
01:05:35 <bartavelle> I believe I found a bug in either GHC or a very common package. How can I diagnose it ? I have the faulty behaviour on a computer, and correct one on another
01:10:38 <Peaker> bartavelle, which package?
01:24:25 <bartavelle> I filled a bug with all (I hope) data : http://hackage.haskell.org/trac/ghc/ticket/7211
01:25:01 <bartavelle> but I believe those are all very common packages, the most exotic might be Data.HashMap ..
01:47:30 <sheldonh> linear algebra comes before calculus, right? *blush*
01:47:54 <randomclown> sheldonh: neither
01:50:54 <ADNAUSEAM> sheldonh: i'm doing both
01:51:00 <ADNAUSEAM> well, i will be.
01:51:04 <ADNAUSEAM> they're not really related.
01:51:20 <SHACHAF> HI ADNAUSEAM
01:52:51 <sheldonh> adnauseam: i'm just having to choose carefully what book to buy next, because the maths textbooks i'm looking at on amazon are outrageously expensive
01:53:01 <ddarius> ADNAUSEAM: They are deeply related, but you can certainly learn things about each without knowing anything about the other, though linear algebra is certainly more fundamental and more of a prerequisite to calculus than the other way around.
01:53:06 <Nereid> ^
01:53:20 <Nereid> deeply related as in
01:53:33 <Nereid> you won't see the relationship in a first encounter with calculus
01:53:43 <Nereid> not yet
01:54:02 <Nereid> mostly because lots of things degenerate in the single-variable case.
01:54:08 <ddarius> Yeah.
01:54:45 <sheldonh> i was going to buy Apostol's Calculus, but i see he's also got a Linear Algebra book, and it's considerably cheaper :)
01:54:47 <Nereid> linear algebra is probably easier to get a handle on if you haven't seen either, though.
01:54:49 <ddarius> Specifically the space of linear maps in 1D is isomorphic to the real numbers so you don't get the fundamental insight that the derivative is simply a first-order (i.e. linear) approximation to the function.
01:55:05 <sheldonh> i wish i'd studied on my parents' tab when i had the chance
01:55:11 <ddarius> Linear algebra is often presented in a much less sexy way than calculus though.
01:55:29 <Nereid> calculus is presented in a sexy way?
01:55:31 <randomclown> isomorphisms are pretty sexy though
01:55:42 <randomclown> Nereid: all those curves
01:56:47 <ddarius> Nereid: Getting general solutions to problems that seem, at first to have only ad-hoc solutions, e.g. calculating areas, is relatively nice, and certainly a lot nicer than having a mess of linear equations and bunches of matrices of numbers.
01:57:00 <ADNAUSEAM> well aye
01:57:14 <ADNAUSEAM> analysis 1 and linear algebra 1 here
01:57:21 <ADNAUSEAM> so not yet biting into the meat
01:57:29 <Nereid> both get much more fun the deeper you go into them.
01:57:33 <Nereid> for some definition of "fun".
01:57:36 <ddarius> Nereid: Damn skippy.
01:58:00 <ddarius> The derivative is a linear operator so it falls within the realm of (infinite dimensional) linear algebra, for aspects going the other way.
01:58:44 <sheldonh> someone suggested to me that linear algebra might be a nicer way to ease into maths, because it's easier to visualise. not sure i trust him. sound sane?
01:58:45 <ddarius> This has a lot of relevance to quantum theory, Fourier analysis (the Fourier transform is another linear operator), and some nice tricks for doing calculus.
01:58:57 <sheldonh> (by visualize, he meant get a computer to make pretty pictures)
01:59:03 <ddarius> sheldonh: Linear algebra is often very concrete.  Somewhat overly concrete in many cases.
01:59:13 <Nereid> you can make pretty pictures from calculus too.
01:59:41 <ddarius> There are less pretty pictures in linear algebra (another reason why calculus is more sexily presented), though both are very useful for generating pretty pictures.
01:59:56 <ddarius> Computer graphics draws heavily from both fields, though probably more from linear algebra.
02:00:03 <amosr> ray tracing?
02:00:11 <sheldonh> meh, maybe i just need to have a chat with my wife and secure more of my own salary for my own studies :)
02:00:21 <ADNAUSEAM> hmm
02:00:26 <ADNAUSEAM> while we're on the subject
02:00:33 <ADNAUSEAM> i tried asking this in #math but they're dicks
02:00:36 <ddarius> sheldonh: You can learn a lot with materials that are freely available and without classes.
02:00:38 <sheldonh> lol
02:00:38 <ADNAUSEAM> http://pastebin.com/qndGydQD
02:00:46 <ADNAUSEAM> why do i need 7 :o
02:01:11 <ADNAUSEAM> why couldn't i just have skipped step 7, and went from 3 to 8
02:01:11 <ddarius> Damn, mauke isn't around.
02:01:33 <sheldonh> ddarius: mmmmm, khan academy
02:02:01 <ddarius> sheldonh: Just google.  There are -tons- of texts, particularly for linear algebra, available online.
02:02:06 <Nereid> ADNAUSEAM: depends on what the objective is. you also could have skipped 9, going straight from 8 to 10.
02:02:40 <ddarius> I would recommend that if you do pay for a book, and are financially constrained in this area, that you go after highly recommended ones, regardless of cost [within sanity].
02:03:19 <sheldonh> ddarius: indeed. for calculus, it came down to spivak or apostol. both expensive, both highly rated :)
02:03:32 <ADNAUSEAM> Nereid: it's a proof for modus ponens basically
02:03:49 <Nereid> I don't see how.
02:03:52 <ADNAUSEAM> "if x is given, and x -> y, then y"
02:03:58 <ADNAUSEAM> yeah me niether >.<
02:04:13 <ddarius> sheldonh: Also, you can probably get a lot of books from a local college/public library.
02:04:47 <Nereid> libraries are cool.
02:05:00 <SHACHAF> My local university library won't let me check out books.
02:05:01 <ddarius> ADNAUSEAM: By the way, I'd recommend any of the profligate mass of paste bin sites on the internet that don't have ads and such.
02:05:13 <SHACHAF> Their hours are often incompatible with my hours.
02:05:22 <Nereid> pastebin has ads?
02:05:26 <Nereid> pastebin.com
02:05:35 <SHACHAF> Many.
02:05:43 <Nereid> never seen one :v
02:06:06 <SHACHAF> :∧
02:06:14 <tdammers> those uppercase nicks are truly disturbing
02:06:21 <SHACHAF> tdammers: They're wonderful.
02:06:23 <SHACHAF> Try it!
02:06:32 <SHACHAF> HI TDAMMERS
02:06:35 <TDAMMERS> HI SHACHAF!
02:06:36 <SHACHAF> Welcome to THE CLUB
02:06:39 <TDAMMERS> YAY!
02:06:40 <NEREID> oh dear, what have I gotten into?
02:06:50 <SHACHAF> NEREID: THE CLUB. Enjoy your stay.
02:06:50 * TDAMMERS FEELS BRAND NEW
02:06:57 <ADNAUSEAM> ddarius: oh sorry about that- i've got adblock :o
02:06:57 <merijn> today is all caps day?
02:07:05 <ADNAUSEAM> so i rarely ever notice ads
02:07:13 <SHACHAF> merijn: No.
02:07:13 <arcatan> HI EVERYONE
02:07:21 * MERIJN is cool too
02:07:23 <TDAMMERS>  \o/
02:07:24 <MERIJN> eh
02:07:28 <SHACHAF> arcatan: You should capitalize on the occasion!
02:07:31 * MERIJN IS COOL TOO?
02:07:39 <SHACHAF> MERIJN: Naturally!
02:07:43 <MERIJN> I have a feeling I should move to -blah >.>
02:08:31 <ddarius> ADNAUSEAM: Surely you notice a bunch of empty boxes and such, as well as just a generally noisy UI.
02:09:00 <ddarius> Christ.
02:12:55 <sheldonh> ddarius: a library. wow, i haven't thought about those in years! thanks! :)
02:14:45 <ADNAUSEAM> ddarius: no :o
02:15:03 <ADNAUSEAM> my browser is fully fortified o_0
02:21:49 <Z`> Hi people. I was looking at the types of map and fmap
02:22:04 <Z`> can anyone comment on the essence of their difference ?
02:22:23 <bitonic> Z`: do you know what typeclasses are?
02:22:24 <lpvb> map only works on lists
02:22:33 <Z`> map accepts as argument a function that maps a's to b's and a list of a's, and returns a list of b's
02:22:34 <lpvb> fmap works on any functor
02:22:43 <Z`> bitonic: a little bit
02:23:00 <bitonic> Z`: well, I think that you'll understand the difference when you understand typeclass
02:23:12 <ADNAUSEAM> :t map
02:23:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:23:14 <Z`> alright, then I'll read on typeclass again
02:23:14 <randomclown> bitonic: http://stackoverflow.com/questions/7463500/why-do-we-have-map-fmap-and-liftm
02:23:15 <ADNAUSEAM> :t fmap
02:23:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:23:25 <lpvb> map works on concrete types, fmap works on functors...
02:23:33 <bitonic> randomclown: well, that's a different question
02:23:38 <TDAMMERS> Z`: to use map, your arguments must be actual lists; for fmap, they just need to be members for the Functor typeclass
02:23:47 <bitonic> lpvb: not really, map is polymorphic as well
02:24:04 <lpvb> what's a better word to describe it
02:24:07 <ADNAUSEAM> @google learn you a functor
02:24:08 <lambdabot> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
02:24:08 <lambdabot> Title: Functors, Applicative Functors and Monoids - Learn You a Haskell for Great Good!
02:24:17 <TDAMMERS> map is polymorphic in the element type, not the container type
02:24:17 <ADNAUSEAM> mhm, wrong chapter
02:24:43 <osfameron> WHY IS EVERYBODY SHOUTING?
02:24:49 <ADNAUSEAM> I DONT KNOW MAN
02:25:03 <lpvb> that's the right chapter
02:25:05 <TDAMMERS> JOIN THE CLUB AT #haskell-blah!
02:25:06 <ADNAUSEAM> Z`: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
02:25:19 <ADNAUSEAM> a functor is a type of data structure
02:25:23 <ADNAUSEAM> well, think of it that way
02:25:51 <ADNAUSEAM> and fmap can iterate over it
02:26:08 <merijn> When do I want strict RWST and when lazy RWST?
02:26:19 <Z`> Is fmap more general than map ? (I guess yes)
02:26:31 <lpvb> yes
02:26:57 <lpvb> fmap works on any data type that has an instance of functor
02:27:03 <ADNAUSEAM> yes it is, because lists are functors too
02:27:15 * hackagebot lens 2.6 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-2.6 (EdwardKmett)
02:27:46 <ADNAUSEAM> i'm pretty sure they are at least
02:27:52 <ADNAUSEAM> i could be wrong, make sure :o
02:27:55 <ddarius> @instances Functor
02:27:56 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
02:27:56 <ADNAUSEAM> never trust anything i say :o
02:28:09 <ADNAUSEAM> oh, there it is at the end!
02:28:13 <lpvb> they are
02:28:14 * ADNAUSEAM feels vindicated 
02:28:34 <lpvb> > fmap (fmap (+3)) [Just 1, Just 5, Nothing, Just 10]
02:28:35 <lambdabot>   [Just 4,Just 8,Nothing,Just 13]
02:29:09 <ADNAUSEAM> neat isn't it
02:31:12 <baobab> Hi, I'm programming some concurrent haskell code with asynchronous exceptions. Sometimes my threads just die, for no apparent reason... is there any debugging tool/flag/info I can exploit to understand what's going on?
02:31:38 <baobab> There is no message being output, I really have no idea what's happening
02:31:43 <lpvb> there's the ghci debugger
02:31:48 <lpvb> :help in ghci
02:32:00 <baobab> does it work with concurrent programs?
02:32:10 <lpvb> idk
02:32:15 <baobab> ...
02:32:31 <baobab> besides, they seem to die quite randomly
02:33:08 <amosr> looking at the eventlog in threadscope might help?
02:33:11 <baobab> is there some sort of hidden log, or hidden information that ghc can give
02:33:14 <merijn> baobab: The entire program or just individual threads?
02:33:34 <baobab> merijn: just some threads
02:33:37 <amosr> to get eventlog, compile with -eventlog and run with +RTS -la
02:33:46 <thirsteh> is there a stdlib function that turns an association list with duplicates [(a1,b1),(a1,b2),(a2,b3)] into [(a1,[b1,b2]),(a2,[b3])] ?
02:34:05 <baobab> amosr: cool, it sounds promising
02:34:15 <baobab> amosr: what kind of information can I find in the event log?
02:34:18 <thirsteh> duplicate keys, that is
02:34:34 <Botje> thirsteh: I'd go via Map for that one.
02:34:54 <SHACHAF> baobab: Fork them with a handler that catches and prints exceptions?
02:34:57 <amosr> hmm. it says when gc starts, when threads yield or start
02:35:07 <SHACHAF> I think the default thread exception handler just dies silently.
02:35:12 <amosr> I don't know if it'd have anything useful for you
02:35:13 <lpvb> thirsteh: you can't have a list that contains different types
02:35:31 <thirsteh> lpvb: they're values, not types
02:35:34 <Botje> thirsteh: toList . fromListWith (++) . map (second return)
02:35:35 <thirsteh> sorry if I'm not using the right terminology
02:35:53 <baobab> SHACHAF: all my threads already run with a handler for my special kind of exceptions.. wait maybe I'm discarding something there?
02:36:03 <thirsteh> Botje: thanks!
02:36:07 <SHACHAF> baobab: Any kind of exception?
02:36:15 <baobab> SHACHAF: let me check
02:36:26 <Botje> thirsteh: most of those functions are in Data.Map, second is from Control.Arrow
02:36:27 <SHACHAF> Enigmagic mentioned something about this once.
02:36:59 <thirsteh> lpvb: [("foo", 1),("foo", 2),("bar",1)] -> [("foo", [1,2]), ("bar", [1])] is what I meant
02:37:01 <baobab> SHACHAF: well this might be wierd
02:37:29 <baobab> I have: data MyException = A | B ... | Z deriving (Typeable)
02:37:56 <baobab> and my handler handles all cases of my exceptions
02:38:25 <baobab> Maybe I can nest exception handlers
02:38:41 <SHACHAF> baobab: Write a handler that catches *any* exception and prints it out.
02:38:47 <SHACHAF> That way you'll know why your threads are dying.
02:39:03 <baobab> SHACHAF: yes I'll definitely do that
02:39:23 <baobab> thanks a lot guys! this channel is really awesome :)
02:41:51 <EDWARDK> so why the uppercase names?
02:42:01 <SHACHAF> EDWARDK: It has to do with trains.
02:42:07 <EDWARDK> obviously
02:42:12 <COMPANION_CUBE> NOPE, IT HAS TO DO WITH COOLNESS
02:42:17 <SHACHAF> We're fighting oppression!
02:42:19 <SHACHAF> Well, I am.
02:42:19 <Botje> is international baudot day today?
02:42:26 <Botje> I thought it was later in the month.
02:46:36 * lpvb LPVB
02:47:44 <timthelion> > concatMap (\n->intersperse n [0..10]) [10..0]
02:47:45 <lambdabot>   []
02:47:59 * NAOLSGM reverse . map upper $ "mgsloan"
02:48:05 <timthelion> why doesn't that return something along the lines of [0,10,1,10,2,10...?
02:48:40 <NAOLSGM> s/upper/toUpper/
02:48:41 <osfameron> > [10..0]
02:48:42 <lambdabot>   []
02:48:49 <osfameron> > [10,9..0]
02:48:50 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
02:48:57 <timthelion> osfameron: aha,
02:49:00 * timthelion is an idiot
02:49:12 <osfameron> nah, it's possibly surprising
02:49:16 <osfameron> there are good reasons for it though
02:49:23 <NAOLSGM> > concat . intersperse "! " . repeat . reverse . map upper $ "mgsloan"
02:49:24 <lambdabot>   Not in scope: `upper'
02:49:34 <NAOLSGM> > concat . intersperse "! " . repeat . reverse . map toUpper $ "mgsloan"
02:49:36 <lambdabot>   "NAOLSGM! NAOLSGM! NAOLSGM! NAOLSGM! NAOLSGM! NAOLSGM! NAOLSGM! NAOLSGM! NA...
02:50:43 <mikeplus64> > (concat . intersperse "1 " . words . map toUpper) "why are we yelling"
02:50:44 <lambdabot>   "WHY1 ARE1 WE1 YELLING"
02:50:50 <mikeplus64> > (concat . intersperse "! " . words . map toUpper) "why are we yelling"
02:50:52 <lambdabot>   "WHY! ARE! WE! YELLING"
02:50:55 <mikeplus64> broken shift :(
02:51:59 <mgsloan> it's because everyone's already frustrated with no fap september
02:52:22 <fmap> @check \xs ys -> concat (intersperse ys xs) == intercalate ys xs
02:52:23 <lambdabot>   "OK, passed 500 tests."
02:52:29 <mikeplus64> > (intercalate "! " . words . map toUpper) "fair enough"
02:52:31 <lambdabot>   "FAIR! ENOUGH"
02:52:36 <baobab> "thread blocked indefinitely in an MVar operation"
02:52:41 <baobab> -___-
02:53:02 <mgsloan> "thread blocked till end of september"
02:53:07 <thirsteh> Botje: worked perfectly. Thanks much.
02:53:33 * mgsloan almost feels bad about proliferating this 4chan meme (of course I caught it via reddit) 
02:54:05 <baobab> my threads are on strike -__-
02:58:56 <SHACHAF> baobab: OK, your threads are being killed because they're blocking on MVars that no other thread has a reference to.
03:00:04 <baobab> SHACHAF: yes, I was reading the documentation
03:02:02 <timthelion> is there a foldUntil :: (a -> Maybe b -> Maybe b) -> Maybe b -> [a] -> Maybe b which returns the Just before the nothing?
03:02:17 <baobab> SHACHAF: I guess I cannot get any more information about this exception from GHC, right?
03:02:30 <SHACHAF> baobab: Maybe you can?
03:03:20 <baobab> SHACHAF: Do you know if there is any more information I can get from it?
03:03:34 <baobab> SHACHAF: well, I mean how :)
03:03:52 <SHACHAF> Well, you can figure out the thread ID, probably. Maybe you already know that.
03:04:03 <SHACHAF> You can probably figure out more information about where the exception was thrown but I don't really know.
03:05:40 <ddarius> baobab: You may also not care...
03:05:52 <sheldonh> scanr (^) 1 [2,3,4] gives me [2417851639229258349412352,81,4,1] ... Int wrap?
03:06:54 <SHACHAF> sheldonh: No?
03:07:02 <SHACHAF> What result are you expecting?
03:07:11 <ddarius> sheldonh: The default default is Integer anyway.
03:07:20 <ddarius> > product [1..100]
03:07:21 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
03:07:49 <SHACHAF> > scanr f 1 [2,3,4] :: [Expr]
03:07:50 <lambdabot>   [f 2 (f 3 (f 4 1)),f 3 (f 4 1),f 4 1,1]
03:08:05 <SHACHAF> We need an infix operator for Expr.
03:08:45 <amosr> > map f [1..5]
03:08:46 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:08:46 <lambdabot>    `SimpleReflect.FromExpr ...
03:09:02 <amosr> > map f [1..5] :: [Expr]
03:09:03 <lambdabot>   [f 1,f 2,f 3,f 4,f 5]
03:09:08 <amosr> that is very clever
03:09:29 <ddarius> > var "aou"
03:09:30 <lambdabot>   aou
03:09:36 <ddarius> > var "+"
03:09:37 <lambdabot>   +
03:09:46 <ddarius> > op "+"
03:09:47 <lambdabot>   Couldn't match expected type `o -> n'
03:09:47 <lambdabot>         against inferred type `[GHC.T...
03:09:50 <ddarius> :t op
03:09:51 <lambdabot> forall o n. (Newtype n o) => (o -> n) -> n -> o
03:10:27 <SHACHAF> @ty fun
03:10:29 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
03:10:29 <ddarius> > map (+) [1..5] :: [Expr]
03:10:30 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
03:10:30 <lambdabot>         against inferred ...
03:10:40 <ddarius> > scanr (+) [1..5] :: [Expr]
03:10:41 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
03:10:41 <lambdabot>         against inferre...
03:10:45 <ddarius> > scanr (+) 0 [1..5] :: [Expr]
03:10:46 <lambdabot>   [1 + (2 + (3 + (4 + (5 + 0)))),2 + (3 + (4 + (5 + 0))),3 + (4 + (5 + 0)),4 ...
03:10:53 <SHACHAF> Aha. Right, of course.
03:15:23 <Z`> does that :: [Expr] trick work in ghci ?
03:15:25 <Z`> I liked it
03:15:48 <amosr> :t f
03:15:49 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
03:17:49 <ddarius> Z`: It does if you have the appropriate library in scope.
03:18:15 <Z`> what library is that ddarius ?
03:18:47 <ddarius> @hackage simple-reflect
03:18:47 <lambdabot> http://hackage.haskell.org/package/simple-reflect
03:20:10 <Z`> thanks!
03:21:44 <adnam> how do i load cabal libraries when compiling with `ghc`? I tried `ghc -package PKG-VER` but it only searches for imports locally
03:22:45 <Z`> A type class resembles a Java interface. It lists the operation  an instance of that class should support. Right ?
03:23:05 <adnam> Z`: right
03:23:43 <sheldonh> SHACHAF: i was expecting 4096 :)
03:23:59 <ddarius> Z`: Very vaguely.
03:24:17 <ddarius> Z`: It's generally a bad idea to try to understand things in Haskell by analogy to OOP.
03:24:47 <Z`> What is wrong in this particular example?
03:26:56 <ddarius> Z`: I'm too tired to explain.  Attempt to use them that way and you will quickly find out, or you could avoid the whole problem.
03:27:16 <Z`> ok
03:27:26 <amosr> Z`: if you have an interface called Num, and you want to write a java function ... dot product, say
03:28:10 <amosr> then your function would be "Num dotProduct(Vector<Num> x)"
03:29:03 <merijn> Z`: Typeclass are more general than interfaces, for example: Java interfaces can't provide polymorphic constants and they cannot be polymorphic in return values
03:29:08 <amosr> the type signature just says any 'num' works for all the cases, so dot product might take a vector of nums and return a Float
03:29:16 <merijn> Z`: Also, interfaces can't abstract over multiple argument types of a function
03:30:08 <fmap> can you add interface to third-party class in java?
03:30:13 <Z`> ok
03:30:51 <merijn> Z`: Also as fmap points out you can define instance for types without touching their implementation
03:31:14 <ddarius> Type classes are different than Java interfaces, neither more nor less general.
03:31:15 <frerich> merijn: I think 'polymorphic constants' and 'polymorphic return values' are not specific to type classes, so this is not a distinct features to distinguish typeclasses from Java interfaces (read: not a very good example to explain why one is better or worse than the other).
03:31:23 <merijn> > (maxBound :: Char, minBound :: Int)
03:31:24 <lambdabot>   ('\1114111',-9223372036854775808)
03:32:01 <merijn> > (read "12" :: Int, read "True" :: Bool)
03:32:02 <lambdabot>   (12,True)
03:32:37 <merijn> Z`: Think on how those two examples work with typeclasses and you can see one difference from (Java) interfaces
03:32:54 <merijn> This StackOverflow question seems to have a quite elaborate explanation (though I haven't read it): http://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes
03:32:55 <Z`> alright, I will try.thanks
03:37:38 <gensymv> can someone please tell me why I am getting this error?
03:37:40 <gensymv> http://bpaste.net/show/sjwKn51VmIj2bNWKtlfX/
03:38:42 <gensymv> is it because I declare the type as [a] instead of [Eq a]?
03:38:45 <merijn> gensymv: Simple, you are using (==) to compare the elements in your input list, but you're type signature doesn't say those items should be comparable
03:38:55 <gensymv> ah, I see.
03:38:59 <merijn> gensymv: The correct type would be "Eq a => [a] -> [a]"
03:39:06 <gensymv> merijn: thanks
03:39:29 <merijn> gensymv: Which translates to "for all a's that are comparable (i.e. Eq instances), compress has type [a] -> [a]"
03:40:08 <gensymv> merijn, thanks a lot.
03:40:42 <merijn> gensymv: If you look at the error that's also what it says "No instance for (Eq a)" (a is not comparable) "arising from a use of `=='" (but you are still using ==) "In the expression: (head z == y)" (in this part of your function)
03:41:00 <timthelion> Why can't I do : >type Bucket = (a, [a])
03:41:06 <frerich> merijn: Why doesn't ghc deduce that 'a' must be an instance of Eq?
03:41:18 <gensymv> yeah, I got that. It wasn't obvious to me that I had to declare that explicitly
03:41:21 <merijn> frerich: It would, if you didn't provide the type signature
03:41:29 <frerich> merijn: Ah, gotcha
03:41:37 <gensymv> i.e SML would do that automatically
03:41:40 <merijn> If you'd written compress without the explicit type signature it would compile fine
03:41:51 <kane77_> hi, I'm trying to setup cabal project.. I split my files to src and test folders and have this cabal file: http://hpaste.org/74155 if I do cabal configure & cabal build it compiles fine, however if I configure with --enable-tests it won't build and give this <command line>: cannot satisfy -package-id hpoker-0.1.0.0-inplac
03:42:02 <merijn> GHC assumes that if you provide one, it should match and if it doesn't it will complain
03:42:43 <merijn> > (map :: (Int -> Int) -> [Int] -> [Int]) (+1) [1..5]
03:42:44 <lambdabot>   [2,3,4,5,6]
03:42:50 <merijn> > (map :: (Int -> Int) -> [Int] -> [Int]) (+1) ['a'..'f']
03:42:52 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:42:52 <lambdabot>         against inferred type ...
03:43:02 <merijn> > (map :: (Int -> Int) -> [Int] -> [Int]) succ ['a'..'f']
03:43:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:43:04 <lambdabot>         against inferred type ...
03:43:14 <merijn> > map succ ['a'..'f']
03:43:15 <lambdabot>   "bcdefg"
03:43:36 <SHACHAF> > map rot13c ['a'..'f']
03:43:38 <lambdabot>   "nopqrs"
03:44:05 <merijn> In short, GHC will always follow what you claim to want (i.e. the signature you write) and will complain if there's no way to match your signature to the code you wrote
03:45:11 <Z`> When we see fmap :: (a -> b) -> f a -> f b, do we read it as "fmap accepts a function mapping a's to b's and a functor a, and returns a functor b"?
03:45:55 <Botje> Z`: (a -> b) -> (f a -> f b) is more natural, actually.
03:46:03 <Botje> fmap lifts a function a -> b to work on functors
03:46:05 <frerich> gensymv: I think your 'compress' function is the same as 'compress xs = map head (group xs)' (or "compress = map head . group" if you like the point-free style).
03:46:12 <merijn> Z`: Well, 'f' is a functor, "f a" is (I don't actually know what to call that?)
03:46:27 <Z`> Botje: thanks, that is an intuitive way to look at ti
03:46:43 <Z`> thanks merijn I had the same difficulty at 'naming it'
03:46:45 <merijn> Z`: Always remember -> associates right ;)
03:47:03 <Z`> mm, yeh, indeed!
03:47:13 <gensymv> fredrich: it seems so
03:47:24 <gensymv> fredrich: at least, yours is the one that is in the wiki ^^
03:48:11 <frerich> gensymv: Oh, a lucky shot. That means it can't be totally stupid, I think!
03:48:32 <frerich> gensymv: Unless the Wiki uses it as an example for a totally stupid implementation of the function...
03:48:49 <SHACHAF> @fresh
03:48:49 <timthelion> Nooooooo!  (!!) :: [a] -> Int -> a and not (!!) :: Integral n => [a] -> n -> a :/ :/ !
03:48:49 <lambdabot> Hahh
03:48:54 * timthelion cries.
03:49:02 <gensymv> ^^
03:49:08 <SHACHAF> @hoogle Integral n => [a] -> n -> a
03:49:08 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
03:49:08 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
03:49:09 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
03:49:25 <SHACHAF> (!!) is a terrible function anyway, though.
03:49:53 <timthelion> there is NO reason for that type restriction.
03:50:09 <timthelion> SHACHAF: thanks by the way
03:50:16 <SHACHAF> NO reason!!!
03:50:43 <atriq> I'm going to think outloud for a bit
03:51:13 <atriq> edwardk's lenses are type Lens a b c d = Functor f => (c -> f d) -> a -> f b, right?
03:52:23 <atriq> It's like removing the c from the a so there's a hole in the a such that when it's filled with a d it becomes a b
03:52:43 <atriq> Then running the first function on the c, and fmap-ing the holey a around it
03:57:05 <hpaste> timthelion pasted “Type error which I cannot figure out” at http://hpaste.org/74157
03:57:18 <timthelion> Can someone look at my type error please?
03:57:56 <gensymv> is there any semantic difference between where and let clauses? or is it just another way of doing the same thing?
03:58:11 <mikeplus64> gensymv: just another way of doing the same thing
03:58:12 <SHACHAF> gensymv: In the places where you can use either one, they mean the same thing.
03:58:17 <frerich> gensymv : http://www.haskell.org/haskellwiki/Let_vs._Where
03:58:22 <SHACHAF> frerich++
03:58:29 <gensymv> frerich: that's handy thanks
04:07:17 * hackagebot local-search 0.0.5 - A first attempt at generalised local search within Haskell, for applications in combinatorial optimisation.  http://hackage.haskell.org/package/local-search-0.0.5 (RichardSenington)
04:08:37 <fmap> timthelion: will it compile if you remove type signatures from `buckets' and `whichBucket'?
04:10:41 <timthelion> fmap: I'm working on that now.
04:10:54 <timthelion> as it was, it wouldn't
04:12:25 <ocharles> Hey, I'm working on a problem where I have some sort of mini intepreter in my project for talking to a database, and I'd like to be able to rewrite various queries with more optimistic versions, so a bit like a compiler that transform queries before they run.
04:12:33 <ocharles> For example, I may have something like: getRelease 5 >>= \r -> (loadArtist r >> (getTracks >>= mapM loadArtist))
04:12:41 <ocharles> which can be transformed into: getRelease 5 >>= \r -> getTracks >>= \ts -> mapM loadArtist (ts ++ [r])
04:12:46 <ocharles> (This is pseudo code obviously)
04:13:10 <Jeanne-Kamikaze> template haskell ?
04:13:19 <ocharles> I'm not really sure what structures to use here. It feels like I want some sort of AST and the ability to manipulate it (which makes me think of using uniplate or something), but it also feels like I might want to write the intepretor in a free monad
04:13:24 <ddarius> @hoogle pgm
04:13:24 <lambdabot> package pgm
04:13:25 <lambdabot> package bindings-gpgme
04:13:25 <lambdabot> package hs-pgms
04:13:35 <ocharles> does a free monad yield a tree like structure that I could reorganise before interpreting?
04:15:32 <amosr> ocharles: I think accelerate (gpu stuff) does something similar, building up an ast then optimising it
04:15:48 <ocharles> interesting
04:15:55 <ocharles> that might be worth reading about then!
04:16:25 <ocharles> i mostly want to group calls when all dependencies have been 'resolved'. so in this case, loading artist can be deferred until after tracks have loaded, in order to maximize the amount of loading done in one call
04:18:55 <ddarius> ocharles: If your domain is simple enough, instead of some AST-like structure, you could simply represent it as a normalized data structure.  Say, you'll load releases, then tracks, then artists.  Your data structure could just be a triple of sets.
04:20:47 <ddarius> @hackage pnm
04:20:47 <lambdabot> http://hackage.haskell.org/package/pnm
04:20:51 <merijn> Where does lift (monad transformer one) come from?
04:21:08 <SHACHAF> @hoogle lift
04:21:09 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
04:21:09 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
04:21:09 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:21:13 <SHACHAF> You need a library for pnm?
04:21:24 <SHACHAF> Isn't the whole point of pnm that you basically don't need a library?
04:21:36 <merijn> SHACHAF: Hoogle suggests Control.Monad.Trans.Class but then I still get a compile error
04:21:43 <pliushkin> helloooo
04:22:16 <pliushkin> what is the biggest number the huskell might deal with
04:22:35 <merijn> pliushkin: What do you mean?
04:22:36 <SHACHAF> 14
04:22:44 <SHACHAF> 15 if you use unlimited-precision integers.
04:22:46 <pliushkin> does it have more than 100 000 000 zeroes?
04:23:26 <mikeplus64> pliushkin: haskell has integers that can be as large as your memory permits (the Integer type)
04:23:27 <pliushkin> ok
04:23:41 <SHACHAF> mikeplus64: I suspect GMP has other limitations.
04:24:02 <pliushkin> gmp is nice idea
04:24:26 <pliushkin> does it work with huskell?
04:24:33 <statusfailed> pliushkin: the Integer type uses GMP
04:24:35 <statusfailed> under the hood
04:24:36 <merijn> GMP has limitations that your ints can't take up more than 2^64 machine words, I think
04:24:54 <merijn> Although, realistically you're probably out of memory before then
04:25:07 <pliushkin> ok
04:25:44 <merijn> pliushkin: The basic answers is *big*, significantly bigger than say (2^64)^2 or something
04:25:48 <pliushkin> than i'll just work with sql trough api not to use operative
04:25:53 <merijn> > (2^64)^2
04:25:54 <lambdabot>   340282366920938463463374607431768211456
04:25:58 <merijn> > (2^64)^10
04:25:59 <lambdabot>   456244061762219521864117160570029132489322850724855993057919251789927516720...
04:26:02 <merijn> > (2^64)^100
04:26:03 <lambdabot>   390815922664323873317461428361483673112676810704634122725066747207685355684...
04:26:04 <pliushkin> i understood thx
04:26:06 * ddarius awaits the day when computers regularly have 4 billion times the amount of memory as now.
04:26:30 * pliushkin too
04:26:51 * daniel_- wait no more http://www.downloadmoreram.com/
04:26:53 <sipa> i've only seen that number grow 4000x during my life
04:27:16 <merijn> sipa: You must be *reall* young?
04:27:21 <sipa> eh no
04:27:32 <sipa> i should have added "on computers of my own"
04:28:02 <merijn> Even so? I'm like 26 and I've seen it go from a few kb to Gb in computers I own...
04:28:18 <sipa> my first computer was a 33MHz 386 with 2 MiB of RAM
04:28:20 <merijn> That's already approaching 1,000,000
04:28:37 <sipa> (and I'm 27)
04:28:40 <merijn> (Depending on whether "computer I could use in my house" qualifies as mine)
04:29:27 <sipa> right, I've certainly seen computers with less memory than that, but never used those actively
04:29:29 <pliushkin> <sipa>, my was ~2mhz 10kb ram
04:30:08 <Xantheon> Starting ghc on Ubuntu 12.04 (AMD64) and getting an error "ghc: can't find a package database at" ... it id work like a charm a week ago ... re-installed and compiled a tar myself with no results ... I am a haskell beginner :(
04:30:23 <Xantheon> ... did ...
04:30:32 <amosr> my parents had, sitting around in their garage, an old banking server that had 200mb hard drive. I wonder how much ram that had
04:30:45 <sipa> 200 millibyte?
04:30:51 <ddarius> 200MB of disk is quite a bit.
04:31:11 <krageon> sipa: millibit
04:31:27 <sipa> krageon: oh yes!
04:32:01 <dropster> My first computer was an ZX Spectrum 48K :D
04:32:50 <sipa> so 0.2 bit; that'd be a binary variable that has 3.11% chance to be true, and 96.89% chance to be false
04:34:06 <ddarius> sipa: It's not a matter of probability of being true or false, it's a matter of probability of being correct/readable.
04:34:26 <pliushkin> I had russian ZX called Delta.
04:34:34 <sipa> ddarius: how so?
04:34:47 <merijn> Does anyone know where the edwardk put the state lenses in Control.Lens (i.e., the equivalents of the stuff in data-lens-fd)?
04:35:08 <sipa> ddarius: a binary variable with a 3%/97% distribution has around 0.2 bit of entropy
04:36:52 <merijn> Oh, Control.Lens.Getter and Control.Lens.Setter, apparently
04:37:01 <Saizan> has anyone ever used syb-with-class with a non-regular datatype?
04:54:35 <clsmith> hmm, would it be irresponsible for me to summarise (while making another point) the IO monad as ~ a 'list of things to do'?
04:55:41 <timthelion> clsmith: Perhaps it would be better to say that a value of type IO is a list of things to do!
04:57:01 <clsmith> timthelion: that could work. you think that'd be a fair (not deceptive) summary?
04:57:46 <timthelion> clsmith: yes, I think it's fair.  Though it's not a list, but a tree.  I don't think that you need to say that though.
04:57:58 <ddarius> It's not a tree either.
04:58:12 <clsmith> it's a list, isn't it? what with join.
04:58:55 * timthelion isn't sure now exactly.
04:59:18 <ddarius> clsmith: It's a list of things to do exactly as much as a C program is a list of things to do, which depends on how you are interpreting it and what constitutes a "thing to do".
04:59:29 <clsmith> i plan to explain in simple terms the idea of a function f doing [x,y] and that's incorporated into a function g by way of cat(w,f,z)
05:00:32 <clsmith> basically as a stepping stone into reasoning about different kinds of continuations
05:00:52 <timthelion> ddarius: but C isn't a list of things to do.  It has forks (if, while,for ect) which makes it more tree like than list like.
05:02:05 <ddarius> timthelion: From the perspective control flow, while and recursion and goto and indirect calls would make it a graph, hence, control flow graph.
05:02:49 <clsmith> i'm talking more about the monad value being built than the way that value is built (which would be by way of a graph)
05:04:27 <clsmith> i mean, if you have g = [ w | f | z ], if f lazily transpires to be [ x | y ], g = [ w | x | y | z ], where each are 'things to do'. is my interpretation.
05:04:34 <mm_freak> the list interpretation for IO fails for (>>=)
05:04:52 <clsmith> how so?
05:05:02 * timthelion thinks that the O(n) notation is evil, because so few people realise that an O that is two times harder is the same as a simple O that is O(2n)...
05:05:11 <mm_freak> clsmith: getLine >>= putStrLn
05:05:29 <mm_freak> either you now need mutable variables in your list or you need something that is not a simple list
05:06:02 <clsmith> mm_freak: right, so it's kinda like a list with extents of scope or something
05:06:03 <TDAMMERS> depends how you evaluate the list
05:06:05 <timthelion> mm_freak: with >>= it is more of a function that returns a continuation and a value type list.
05:06:08 <mm_freak> i'd summarize IO as a recipe language…  a value of type IO X is a recipe that results in an X
05:06:21 <ddarius> timthelion: Of the relevant people, I don't think that's the case.  I would hope the majority of the relevant group understand that.  (Though that is, relatively, "a few people" in absolute terms.)
05:07:26 <ddarius> s/that results in/for making/
05:07:36 <mm_freak> yeah, that's better worded
05:08:00 <clsmith> basically, i hope to reason about continuations in terms of 'slices of IO', so instead of having to worry about weird things like call stacks you can just think of storing the 'things to do' in a first-class kinda way. if that makes sense.
05:08:22 <clsmith> (this may be totally wrong, i'm trying to work it out atm)
05:08:44 <mm_freak> clsmith: you can define your own little IO in terms of Free, which is basically a CPS language
05:08:52 <LaughingMan> haddock (and only haddock) gives me this error: parse error on input `module'. Anyone seen that before?
05:09:29 <mm_freak> data IOF a = GetLine (String -> a) | PutStrLn String a | …
05:09:40 <mm_freak> type MyIO = Free IOF
05:10:15 <mm_freak> LaughingMan: code?
05:11:48 <ddarius> For a formalish perspective that's readily approachable, I'd just talk about evaluation(/execution) contexts.  I see no reason to make up a new gimmicky language/notation.  Alternatively, just explain it in terms of CPS, though the evaluation contexts version conflates less things and more closely matches formalisms actually used.
05:12:07 <LaughingMan> http://pastebin.com/1qMFbPfJ
05:12:15 <LaughingMan> I forgot to say, its an lhs file
05:12:19 <Mon_Ouie> u
05:12:28 <Mon_Ouie> (Sorry, didn't mean to type that)
05:13:35 <mm_freak> LaughingMan: not sure if you can really do that…  the syntax seems correct for haddock
05:13:48 <mm_freak> if it weren't an LHS file that is
05:15:03 <merijn> Any Control.Lens wizards around ? :p
05:15:21 <LaughingMan_> It worked before on another file. Haddock doesn't like something in this file. But I don't know what
05:16:06 <mm_freak> LaughingMan: perhaps it doesn't like the trailing ',' on line 59
05:16:36 <mm_freak> GHC wouldn't complain, but haddock might
05:17:51 <LaughingMan> mm_freak: same error without the trailing ,
05:22:24 <krageon> sipa: A bit belated, but I suspect another way to view .2 bits is voltage: .2 of what would make 1. It would still yield 0 when read (100% of the time), in that case
05:24:03 <sipa> krageon: sure that's a possible interpretation, but it doesn't look particularly useful
05:29:19 <LaughingMan> maybe this a bug in Haddock?
05:33:46 <coldpizza72i> So I'm thinking of registering for a course in haskell, and I'm looking at assignments from a previous professor who taught it last spring to get an idea of the level of difficulty of the homework problems… I came across some arrow notation that I am not familiar with like in problem 1 here: http://www.cs.rit.edu/~mtf/teaching/20113/psfp/homeworks/homework03/homework03.html which makes it hard to judge. Is it possible that someone
05:33:47 <coldpizza72i> could give me a quick description of the meaning of these arrow statements?
05:34:50 <Philippa> coldpizza72i: That looks like it's being used for "evaluates to". Also, you might not want to call that "arrow notation", that's something else more specific
05:34:50 <nand`> I don't see any arrow notation on that page
05:35:02 <randomclown> so has anyone implemented the ukkonen O(n) suffix tree algorithm in haskell yet?
05:35:45 <merijn> preflex: seen edwardk
05:35:54 <merijn> hmm, I fail at preflex :\
05:36:04 <ddarius> preflex fails at preflex
05:36:11 <merijn> oh, he's dead :p
05:36:43 <ddarius> randomclown: I don't think so, but people tend to implement cool/interesting algorithms in Haskell seemingly arbitrarily, so you should check Hackage.
05:37:35 <merijn> @hoogle m (a -> b) -> a -> m b
05:37:35 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
05:37:35 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
05:37:35 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
05:37:48 <merijn> :(
05:37:51 <ddarius> :t (return .)
05:37:52 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
05:38:58 <merijn> ddarius: Yeah, that just makes my code even more awful
05:39:25 <merijn> I think I just need to wait for edwardk (or someone equally knowledgeable of lens) to show up and help me clean up my code
05:39:36 <ddarius> You could write fmap return but someone would probably shoot you.
05:39:47 <timthelion> I was just doing some very memory intensive thing in GHCI, when xmonad quit suddenly!
05:40:17 <ddarius> timthelion: Probably the OOM killer.
05:40:22 <merijn> timthelion: Linux?
05:40:31 <timthelion> merijn: yes, linux
05:40:40 <merijn> If yes, congratulations. You have just met the dreaded OOM
05:40:51 <hiptobecubic> oom?
05:40:54 <merijn> Go go stupid OS design!
05:40:58 * timthelion has never had this happen before.
05:41:00 * ddarius had thought they'd made it smarter about killing things.
05:41:07 <raichoo> Ah the greatness of linux playing russian roulette with the processes again.
05:41:12 <merijn> hiptobecubic: The "OOM killer" is the "out of memory killer"
05:41:34 <sheldonh> it'
05:41:39 <merijn> hiptobecubic: Instead of malloc ever failing and returning NULL linux overcommits and when it runs out of actual memory will kill a random process
05:41:40 <osfameron> qu'est-ce que c'est?
05:41:40 <sheldonh> it's the end of the world as i knew it
05:41:47 <timthelion> the last time I did the same thing in GHCi it just told me out of memory exception...
05:42:23 <sheldonh> merijn: it's not a random process :)
05:42:34 <merijn> sheldonh: Random enough
05:42:47 <merijn> I had a fun problem with linux OOM constantly killing sshd on a remote server >.>
05:43:02 <raichoo> sweet
05:43:19 <sheldonh> merijn: any sufficiently advanced process selection algorithm appears to be random :)
05:43:41 <hiptobecubic> http://linux-mm.org/OOM_Killer   looks pretty great, yeah
05:44:51 <hiptobecubic> why doesn't malloc just return null. what are the benefits of over committing ?
05:45:15 <Z`> I think overcommiting can be turned off
05:45:26 <sheldonh> hiptobecubic: hysterical raisins. it didn't in the beginning, so now it can't
05:45:57 <timthelion> hiptobecubic: there is a rule that the external linux abi must NEVER change :)
05:46:04 <merijn> sheldonh: malloc has *always* returned null on failed allocation
05:46:12 <sheldonh> merijn: no
05:46:28 <kranius> gnu malloc ?
05:46:36 <merijn> sheldonh: Eh, yes. All the way back for the ancient BSD's and SYS V malloc...
05:46:41 <sheldonh> merijn: certainly not on FreeBSD
05:46:48 <merijn> sheldonh: I have a first edition K&R showing malloc returning NULL on error
05:46:54 <merijn> sheldonh: Yes it has
05:47:01 <sheldonh> merijn: FreeBSD malloc aborted on failure
05:47:07 <merijn> FreeBSD has a default overcommit ratio of 30% after which it will return NULL
05:47:42 <sheldonh> merijn: the point is, you can't rely on malloc returning null, because it may abort
05:47:53 <merijn> sheldonh: That's irrelevant
05:48:03 <merijn> If code aborts you can't respond anyway
05:48:18 <sheldonh> merijn: exactly, so why bother coding for the null return?
05:48:30 <merijn> btw, FreeBSD manpage, first paragraph in the RETURN VALUES section says malloc returns NULL and sets errno on failed allocation
05:48:38 <merijn> sheldonh: I didn't say you had to change your code...
05:48:43 <merijn> I said overcommit is dumb
05:48:44 <sheldonh> merijn: google for phk dillon malloc abort :)
05:49:01 <merijn> sheldonh: Completely irrelevant to any statement I've made in this conversation
05:49:41 <sheldonh> merijn: if what i'm saying is irrelevant, then there's not much point in conversing :)
05:49:59 <merijn> sheldonh: The fact that malloc sometimes doesn't return in some implementation doesn't change the fact that failed malloc has *always* returned NULL
05:50:20 <merijn> (hint, if malloc doesn't return it doesn't return *anything*, so the point is moot)
05:50:36 <hiptobecubic> Welp. I guess the only thing left to do is play with it and see if it dies.
05:50:40 <merijn> And my original point was that full overcommit is dumb and there is no historical reason for it
05:51:01 <sheldonh> merijn: your original point is solid
05:51:03 <hiptobecubic> returned null
05:52:05 <merijn> So is my follow up point, unless you will argue that "getPid" doesn't always return a PID because the machine might be destroyed before the function returns...
05:52:20 <hiptobecubic> Felt good to calloc 14GB and realize it wasn't enough to test it yet :)
05:52:34 <sheldonh> hiptobecubic: they don't make 'em like they used to ;)
05:52:39 <hiptobecubic> sheldonh, nope
05:52:43 <hiptobecubic> thankfully
05:52:59 <hiptobecubic> I have a 2MB stick lying around somewhere
05:53:20 <sheldonh> merijn: my point is that it's unwise to assume that you can safely call malloc in low memory conditions. i appreciate that this is tangential to the point you're making
05:53:59 <hiptobecubic> according to this page on the badness() calculator, xmonad really should just never be killed
05:54:00 <sheldonh> merijn: what a lot of people have overlooked, with drastic consequences, is that "return NULL" is not the *only* thing malloc can do in an out of memory situation
05:58:07 <ddarius> hiptobecubic: Yes, that's what I'd expect.
05:59:28 <ddarius> Few programs have a particularly graceful response to not being able to allocate the memory that they need.
06:00:07 <sheldonh> ah. i said this about malloc not returning NULL "hiptobecubic: hysterical raisins. it didn't in the beginning, so now it can't"... that was an exceptionally poor representation of my opinion, sorry for the fuss :)
06:00:44 <sheldonh> hiptobecubic: if malloc does not abort on failure, it returns NULL :)
06:01:13 <mux> not necessarily
06:01:24 <sheldonh> ddarius: yeah. and when you're, for example, writing a fsck, it pays to do your mallocs outside critical moments
06:01:58 <mux> many OSes do overcommit, meaning you won't get a NULL from malloc() but an address that will cause a segmentation fault when you will later try to access it
06:02:24 <mux> supposedly those OSes offer ways to specify that you want malloc() to do swap reservation to ensure this doesn't happen (Linux, FreeBSD)
06:03:08 <sheldonh> mux: i would consider a junk pointer a bug. who does that? :(
06:03:18 <mux> Linux, FreeBSD and probably others
06:03:28 <mux> it's a significant optimization
06:03:33 <sheldonh> mux: when did FreeBSD start doing that?
06:03:39 <sheldonh> mux: that's just heinous!
06:03:43 <mux> the pages are actually only allocated in the page fault handler
06:03:51 <mux> sheldonh: long ago, I cannot tell precisely
06:04:39 <sheldonh> mux: i can just imagine the bunfight on -hackers :)
06:05:24 <hpc> mux: so if you allocate a junk pointer and wait until after you free() some other memory, it will work fine?
06:05:43 <mux> hpc: I suppose so
06:06:00 <hpc> neat
06:06:02 <mux> fwiw, I just checked and it seems overcommit is off by default on FreeBSD these days; see the vm.overcommit sysctl (used to be on)
06:06:12 <sheldonh> ha! sanity still prevails :)
06:06:16 <Adeon> I thought they return a valid pointer but the consequences of accessing it can invoke the OOM killer (on linux) or do something else
06:06:16 <hpc> it'd be interesting to have it just block until it can allocate
06:06:20 <mux> I'm not sure about Linux
06:06:47 <mux> the pointer is valid, it's a VA; the problem is that the page fault handler will subsequently be unable to actually allocate physical memory pages
06:06:50 <hpc> but i think that's getting into concurrency problems, at the kernel level
06:06:50 <hiptobecubic> hpc, "interesting"
06:06:58 <hpc> yeah, "interesting"
06:07:43 <ARISTID> sheldonh: it seems like the big reason for overcommit are Copy-on-Write memory pages that the vast majority of the time do not trigger the copy. (for example when using fork())
06:07:44 <hpc> the world needs more things with concurrent semantics :P
06:08:06 <mux> AIX has a SIGDANGER signal that can be used in those situations, IIRC
06:08:12 <Adeon> I know applications that purposely allocate huge amounts of memory becaue they know they can overcommit
06:08:38 <Adeon> hundreds of gigabytes on 64-bit platforms
06:08:46 <sheldonh> sad
06:08:55 <ARISTID> i wonder if mmap counts in that limit
06:09:07 <mux> it kills applications by default, but you can attach a signal handler and be preserved that way if your app is sensitive about such things
06:09:29 <ARISTID> you can also disable memory overcommit completely
06:10:05 <sheldonh> malloc_options='X' for all your predictability needs :)
06:10:45 <mux> I'm guilty of often using xmalloc(), xrealloc(), etc wrappers in my apps where it doesn't really matter
06:11:16 <mux> that's arguably ugly
06:12:25 <Adeon> I believe it should depend on application; probably in libraries they should not be used
06:12:54 <mux> oh yeah, I would never do that in a library :)
06:14:35 <sheldonh> most of the stuff i do these days can just explode when the operating system says so
06:14:50 <sheldonh> in fact... come to think of it, i really hate systems programming :)
06:15:02 <hpc> hah, me too
06:15:02 <sheldonh> it's much nicer being on top
06:15:41 <mux> btw, the FreeBSD kernel malloc() has a M_WAITOK flag you can use to block until memory becomes available
06:16:03 <mux> which, to be honest, is partly a lie
06:16:21 <typoclass> mux: that's clever
06:16:45 <Z`> Can I create an instance of Functor for lists ?
06:16:47 <mux> as long as you don't use it in critical code paths, or to allocate too much memory, I guess it's ok
06:17:21 <hpc> Z`: there already is one
06:17:24 <hpc> where fmap = map
06:17:40 <Phlogistique> in Control.Monad.Instances
06:17:46 <Z`> I'd like to replicate that behavior for education purposes. Can I un-define it somehow ?
06:18:00 <Z`> or define it an module or something ?
06:18:16 <mux> as far as I know, you can only newtype lists and add an instance for that
06:18:17 <hpc> define a completely separate "data List a = Nil | Cons a (List a)"
06:18:26 <hpc> and write that instance
06:18:34 <Z`> ah ok, thanks hpc / mux
06:19:49 <Z`> btw, is Cons a data constructor here ?
06:19:55 <hpc> yes
06:19:58 <hpc> Cons and Nil
06:20:09 <Z`> alright
06:20:31 <Z`> but I could define my own data constructors, right ?
06:20:37 <hpc> yeah
06:20:42 <Z`> thanks
06:20:48 <hpc> that's in fact what you would be doing with Cons
06:21:00 <Z`> why Cons in specific ?
06:21:14 <hpc> it's a lisp term
06:21:24 <Z`> ah ok
06:21:35 <hpc> nil for "empty", cons for "construct"
06:21:42 <Z`> great
06:21:57 <Z`> supopse that I'd like to create a Tree, I would use Leaf and Branch
06:22:07 <Z`> but I should define what is a Leaf and what is a Branch. right ?
06:22:29 <Z`> because there aren't any default data construcotrs for those
06:22:34 <hpc> with trees, it's interesting; there's many different kinds of trees
06:23:10 <Z`> but the general idea is that if you use data type there, there should exist a data constructor, either by default or supplied by the programmer. correct ?
06:23:30 <hpc> Z`: when you define a data type, the constructors are defined at the same time
06:23:58 <hpc> so if you did
06:24:16 <hpc> data Blargh = Snargle | BlipBlop | HoyvinMoyvin
06:24:21 <hpc> you've defined a type Blargh
06:24:31 <hpc> and you have defined 3 data constructors
06:24:32 <Z`> but I haven't defined Snargle, etc
06:24:35 <Z`> ah
06:24:37 <hpc> you have, just there
06:24:39 <hpc> :P
06:24:48 <Z`> interesting
06:24:52 <Z`> but, hold on a sec!
06:25:52 <Z`> crap you are right
06:40:44 <Z`> http://paste.lisp.org/display/131491 Any tip on what am I doing wrong? (please don't answer it full, I'd like to find out myself)
06:43:09 <jtza8> Is there a way that I could do the following in a list comprehension?
06:43:24 <Mon_Ouie> Z`: If you want to call fmap map a, a needs to be a Functor
06:43:34 <nand`> Z`: two mistakes I see: 1. List isn't a data constructor, 2. one ‘fmap’ is incorrect
06:43:51 <Z`> Thanks guys. I'll try to reread my book and check the code!
06:44:00 <jtza8> ... where   jux f xs = concatMap (zipWith f xs) (tails xs)
06:44:55 <jtza8> Would be a function that takes a function and compares each item in that list with each other item once only?
06:45:15 <hpc> jtza8: that looks like a type error
06:45:36 <hiptobecubic> tails is a list of lists
06:46:04 <hiptobecubic> so unless f is a -> [a] -> b then it doesn't check, i guess
06:46:31 <fmap> @type \f xs -> concatMap (zipWith f xs) (tails xs)
06:46:32 <lambdabot> forall a b. (a -> a -> b) -> [a] -> [b]
06:46:34 <hpc> :t \f xs -> concatMap (zipWith f xs) (tails xs)
06:46:35 <lambdabot> forall a b. (a -> a -> b) -> [a] -> [b]
06:46:39 <hpc> oh, huh
06:46:47 <hpc> oh, zip /= zipWith durr
06:47:21 * hackagebot uni-uDrawGraph 2.2.0.2 - Graphs binding  http://hackage.haskell.org/package/uni-uDrawGraph-2.2.0.2 (ChristianMaeder)
06:47:45 * jtza8 tries something...
06:47:46 <hpc> jtza8: list comprehensions translate trivially to do-notation, which translates trivially to (>>=)
06:47:52 <hpc> and concatMap = (>>=)
06:48:07 <hpc> er, (=<<), probably
06:48:12 <hpc> so what we have is
06:48:23 <hpc> jux f xs = tails xs >>= zipWith f xs
06:48:40 <hpc> jux f xs = do {t <- tails xs; zipWith f xs t}
06:49:04 <hpc> jux f xs = [zip'd | t <- tails xs, zip'd <- zipWith f xs t]
06:49:22 <hpc> make sense?
06:49:47 <jtza8> Yeah, thanks, quite a lot for me to learn. :)
06:49:58 <hpc> :D
06:56:25 <merijn> bah, I wish cyclical imports weren't such a pain to deal with :(
06:58:47 <timthelion> merijn: :/
06:58:52 <timthelion> merijn: I hate them too.
06:59:17 <Z`> functor1.hs:7:1: parse error (possibly incorrect indentation).  I don't have any tabs, just spaces. And the indentation seems correct
06:59:32 <merijn> Now I need to introduce a global Types.hs or something and break all my nice conceptual split
06:59:35 <timthelion> Z`: probably an unclosed paren...
06:59:36 <merijn> Z`: Hpaste the code
06:59:48 <hpc> Z`: look on the lines above the location it gives
07:00:21 <timthelion> merijn: yes, haskell's module system sucks.  You can also use the cpp preprocessor.
07:00:41 <Z`> wow, the problem was in: let x = Cons 1 (Cons 2 (Cons 3 Nil))
07:01:00 * timthelion doesn't see a problem there.
07:01:01 <Z`> thnaks
07:01:14 <Z`> I'm loading it in ghci
07:01:34 <Z`> BTW, I think better just compile it. sometimes my code fails in ghci and compiles/runs fine.
07:01:57 <ddarius> GHCi doesn't accept arbitrary Haskell (though they've vastly widened it very recently)
07:02:43 <merijn> The standard even specifies recursive modules :(
07:02:55 <hpc> in general, you want to use ghci for loading files and evaluating expressions only
07:03:15 <hpc> anything more complex than that generally belongs in a file
07:03:19 <hpc> even if just for reuse
07:03:29 <Z`> okay
07:04:01 <merijn> Z`: You can also just write a file and load it into GHCi to play with the code you wrote
07:04:03 <timthelion> merijn: really :)  so when will GHC support it?  I'm waiting for your patch.
07:04:16 <Z`> yeh, I'm  using :l file.hs
07:04:29 <timthelion> merijn: I would build GHC from source to get recursively dependent module support.
07:04:29 <Cale> Z`: that ought to work if compiling it will
07:04:48 <Cale> Is your code pasted somewhere?
07:05:01 <Z`> I fixed it, thanks
07:05:14 <typoclass> merijn: these days i think of a "nice conceptual split" the same i think of, i dunno, sorting all the functions alphabetically. it looks neat, but why would you do that, and ultimately it's not worth it
07:06:34 <merijn> typoclass: I have Record and Streams of Record's, unfortunately one of my record constructors has a stream argument (to replace the stream it is read from), since Stream carry records they need to import Record.hs and since that one record has a Stream it needs to import Stream.hs, bam circular import
07:06:54 <merijn> The only solution is to stuff all my datatypes in one big Types.hs file making one big mess of things
07:07:00 <Cale> merijn: Usually, a per-module Types.hs is enough
07:07:34 <merijn> typoclass: "Ultimately it's not worth it", elaborate. Seems totally worth it to me if the implementations actually implemented mutual imports
07:07:51 <merijn> Cale: Yes, but then I end up throwing all data types in there even if they're not remotely related...
07:08:14 <hiptobecubic> Everyone always complains about the module system and praises ocamls. What makes haskell's so bad and ocaml's not? What hasn't that been adapted for haskell?
07:08:29 <argiopeweb> Before I go duplicating them, have there been any experiments done with the alternatives to malloc (jemalloc, tcmalloc, etc), or does the runtime's memory management malloc often enough to even benefit from the performance?
07:08:32 <Cale> merijn: Can you abstract Stream over the Record type in some way?
07:08:37 <timthelion> hiptobecubic: the problem that merijn is having is what makes haskell's so bad :)
07:08:41 <hpc> hiptobecubic: i think it's mostly how it does re-exports
07:08:50 <hpc> (having never used OCaml)
07:08:53 <merijn> Cale: I could but then all my type signatures become a pain everywhere
07:09:08 <ddarius> merijn: It doesn't specify how recursive modules are handled and also it arguably is mis-specified so that implementing separate compilation and recursive modules is extremely difficult.
07:09:17 <companion_cube> hiptobecubic: the OCaml module system is simply more powerful
07:09:28 <companion_cube> but OCaml has no typeclasses, otoh
07:09:50 <merijn> Cale: Actually, no. I can't even parameterise to "Stream a" as I have some stream methods that explicitly use Record in them
07:10:08 <Cale> merijn: hmm
07:10:11 <ddarius> merijn: Also, putting everything in one Types file isn't the only solution.  Often you can generalize and get a better interface that doesn't have the mutual recursion.
07:10:25 <merijn> ddarius: I can't generalise in this scenario
07:10:32 <hiptobecubic> companion_cube, but that's what I'm asking about. What does that mean in this case? What kind of power are we missing?
07:10:36 <Cale> merijn: (maybe Stream and Record aren't as conceptually separate as you thought?)
07:10:44 <merijn> Well, I could parameterise the Record but that would A) not make sense and B) make the code awful
07:10:59 <typoclass> merijn: do you expect that people will frequently import one (not both) of your Record and Stream modules?
07:11:02 <merijn> Cale: By that logic I might as well stuff my entire package in one file :\
07:11:11 <merijn> typoclass: I do not expect to ever import either
07:11:34 <Cale> merijn: Well, just with the mutual recursion and everything, it seems hard to discuss one without the other.
07:11:59 <aib> since ##math seems to be idle: would this be a good place to ask some basic questions about Category Theory while I try to read up on it and learn?
07:12:08 <ddarius> There is no competition here.  Haskell's module system is purposefully and explicitly simplistic, and O'Caml's is one of the more sophisticated ones available.
07:12:31 <Eduard_Munteanu> aib: sounds alright, but there's ##categorytheory too ;)
07:12:36 <Z`> Alright, given data List a = Nil | Cons a (List a), how would I write my pattern matching?    fmap map (Cons a b) = ... ?
07:12:45 <Cale> aib: yes
07:12:54 <Cale> aib: You might also try ##categorytheory
07:13:02 * ddarius would also recommend ##categorytheory where it would be on topic.
07:13:04 <companion_cube> hiptobecubic: module parametrized by other modules
07:13:12 <merijn> Cale: Sure, it's just a bit annoying :\
07:13:12 <hpc> ocaml's module system sounds a lot like agda's
07:13:24 <companion_cube> it's actually modula-3 module system, afaik
07:13:29 <aib> ahhh, ##categorytheory. nice :)
07:13:37 * Eduard_Munteanu would also like it if ddarius autojoined ##categorytheory :P
07:13:39 <hpc> which is to say, it sounds like it overloads organization of code with defining semantics
07:14:07 <ddarius> Eduard_Munteanu: I did for a while, then I reinstalled my operating system and/or got a new computer.
07:14:59 <ddarius> Haskell's type classes, though, do provide a fairly powerful module-like system, but no one uses them that way.
07:15:18 <ddarius> If we had "associated classes" we'd be set.
07:15:19 <merijn> Cale: My main problem is that I basically end up having all my data types in Types and none in the files where the code is actually used, making it annoying to easily see what's going on
07:18:16 <timthelion> merijn: the only thing I can sugest for that is xmonad.  xmonad is a beast for showing two terminal windows at once.
07:18:48 <ocharles> Does anyone know if the state of the art wrt type safe and w3c complient HTML5 generation has changed at all recently? The last research i know is the Strong (X)HTML paper from Jul 2010
07:19:19 <hpc> timthelion: i had no idea there was a current state-of-the-art in rendering two columns of monospace text ;)
07:20:15 <timthelion> hpc: oh, it's a hotly contested feild.  The major issues now are the visual distinction between focused and non focused columns and the best ways of switching between them.
07:25:06 <merijn> timthelion: heh, you must not now tmux xD
07:25:20 <merijn> timthelion: I only ever have a single terminal full screen
07:27:22 * hackagebot monoid-extras 0.2.0.0 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.2.0.0 (BrentYorgey)
07:43:18 <Z`> http://paste.lisp.org/display/131493 any hint? error says it can't match type b with List b. But If I try to write (Cons a (List b)) then it fails with List not being a data constructor
07:45:19 <nand`> you could probably change ‘Cons a (List a)’ to ‘Cons (List a) (List a)’ in the definition and get it to work; but it wouldn't be a legal functor
07:45:50 <Botje> Z`: you're changing the shape of the list there ..
07:45:55 <int-e> Z`: Your fmap is quite wrong. Maybe start smaller, write a function inc :: List Int -> List Int that increments every element of the list, then model fmap after that.
07:46:32 <Botje> Z`: have you tried working out what fmap (+1) y does?
07:46:47 <Z`> no
07:46:59 <int-e> (indeed, inc = fmap (+1)  once you have fmap)
07:47:00 <byorgey> Z`: a good place to start is to make sure you can answer this question: in the LHS  'fmap map (Cons a b) = ...', what are the types of map, a, and b ?
07:47:23 <byorgey> starting with inc is good too
07:47:29 <byorgey> concrete examples always help
07:47:44 <Z`> map is type (a->b)
07:47:50 <byorgey> right
07:47:55 <Z`> since fmap is (a->b) -> f a -> f b
07:48:03 <byorgey> yep
07:48:17 <Z`> (Cons a b) matches the (Const a (List a))
07:48:30 <byorgey> right
07:48:42 <Z`> so b should be type List, for a I'm not sure how to express it
07:48:55 <int-e> And of course, there's the subtle naming trick specificially for patterns matching lists:   Cons a as.
07:49:12 <byorgey> Z`: 'List' by itself is not a type.  List what?
07:49:15 <Z`> b should be Type List b
07:49:22 <byorgey> right
07:49:27 <byorgey> uh, wait, no
07:49:31 <Z`> er sorry List a
07:49:34 <byorgey> right
07:49:36 <Z`> sorry typo
07:49:38 <byorgey> np
07:49:42 <byorgey> and a?
07:49:52 <Z`> and a it depends.. if I write Const 1 Nil, then a is Integer
07:50:02 <byorgey> (it's a bit confusing using variable names that are the same as the type variables)
07:50:11 <rosie> If I have a monad class whose only function defined is a lift into that Monad, how to I ever get values back out? And If I can't, how can I use the values inside the Monad to, for example, print the value?
07:50:12 <mroman> Since b ist List b you can call fmap map directly on b.
07:50:12 <byorgey> Z`: yes, but in the definition of fmap?
07:50:36 <Z`> ah, in the definion of fmap ... hm
07:51:16 <mroman> thus leading to Cons (map a) $ fmap map b
07:51:19 <byorgey> rosie: it depends on the monad.  Many monads come wiht some specific way to 'run' them and get some value(s) out
07:51:51 <rosie> byorgey: Is there an implicit run function? All I see is one function defined in the class which is a lift.
07:51:55 <Z`> I dunno :P I'm stuck
07:51:56 <byorgey> rosie: no, there isn't.
07:52:15 <mroman> Z`: Your Cons is Cons a (List a)
07:52:16 <rosie> err… how is this monad useful, then?
07:52:31 <mroman> fmap is (a->b) -> f a -> f b
07:52:48 <byorgey> Z`: in  fmap map (Cons a b) = ..., you told me  map :: a -> b, and  Cons a b :: List a, right?
07:52:48 <Z`> so, there must be f a
07:52:51 <mroman> so Cons a b is ~= Cons a (f b)
07:53:03 <Z`> right
07:53:11 <byorgey> mroman: what? that doesn't make sense
07:53:24 <mroman> Yeah, but I don't know how to formulate it else
07:53:28 <mroman> :)
07:53:46 <byorgey> Z`: actually, let's use different letters, this is too confusing
07:53:49 <nand`> rosie: if the constructors are exported you could patten match
07:53:53 <byorgey> Z`:  fmap map (Cons x xs) = ...
07:53:54 <mroman> Cons (fmap map b) Nil would make it f (f b) in that analogy.
07:53:54 <byorgey> OK ?
07:53:58 <Z`> ok
07:54:08 <byorgey> Z`: so  Cons x xs :: List a
07:54:21 <Z`> yes, I agree/get that
07:54:23 <byorgey> Z`: so what are the types of x and xs?
07:54:42 <mroman> http://codepad.org/aE4aaXFM is what you probably want *spoiler*
07:54:51 <byorgey> mroman: you're not helping.
07:54:59 <mroman> ok. I'm backing off.
07:55:07 <Z`> x :: Cons a, xs :: List a ?
07:55:14 <nand`> Cons a is not a type
07:55:17 <byorgey> Z`: not quite.
07:55:25 <Z`> sorry
07:55:32 <byorgey> Z`: no need to apologize =)
07:55:35 <rosie> hand`: Can we never escape the IO monad in part because the constructors aren't exported?
07:55:49 <nand`> rosie: yeah pretty much
07:55:51 <hpc> rosie: yes
07:55:53 <byorgey> Z`: List a = ... | Cons a (List a)  means that one way to construct a list is by using Cons and giving it a value of type a, and a value of type List a
07:55:53 <rosie> cool thanks
07:56:05 <hpc> with no constructors, no pattern matching
07:56:14 <Z`> so x :: a, xs :: List a?
07:56:15 <hpc> which restricts you to just the operations on IO that they want you to have
07:56:21 <byorgey> Z`: so if we see something of type  List a  that looks like a Cons constructor applied to two things...
07:56:22 <nand`> you'd need a function of type IO a -> a to ever ‘escape’ the IO monad
07:56:24 <byorgey> Z`: right!
07:56:32 <hpc> @hoogle IO a -> a
07:56:32 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
07:56:33 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
07:56:33 <lambdabot> Foreign unsafePerformIO :: IO a -> a
07:56:41 <hpc> pay no attention to the man behind the curtain!
07:57:09 <nand`> you should probably forget about unsafePerformIO
07:57:13 <Z`> ugh, so x is not a functor, therefore we can't say fmap map x
07:57:19 <byorgey> Z`: right
07:57:26 <Z`> (whereas we can say that for xs which is)
07:57:31 <nand`> Z`: look again at the type of ‘map’ and put two and two together
07:57:51 <byorgey> Z`: what should be the type of the RHS of  fmap map (Cons x xs) = ... ?
07:57:54 <Z`> map :: a -> [a] -> [b] . ok let me check
07:57:58 <nand`> uhm
07:58:01 <nand`> that's not the map I meant, sorry
07:58:06 <Z`> ah fmap
07:58:07 <Z`> ok
07:58:07 <nand`> I meant the ‘map’ in ‘fmap map’
07:58:12 <nand`> the variable you bound
07:58:17 <Z`> RHS should be :: f b
07:58:19 <nand`> (it's a poor name, admittedly)
07:58:23 <Z`> or wait
07:58:28 <byorgey> Z`: right, and specifically what is f ?
07:58:37 <Z`> f is 'map'
07:58:41 <Z`> er
07:58:48 <Z`> wth, I'm talking nonsense. sorry
07:58:56 <byorgey> hehe, no worries =)
07:59:11 <byorgey> just take your time and work things out.  There's no rush =)
07:59:14 <nand`> (when we renamed a/b to x/xs, did we also rename ‘map’ to ‘f’?)
07:59:17 <hpc> if you're having trouble with just the names of things, rename your parameters
07:59:22 <byorgey> nand`: not that I know if
07:59:24 <byorgey> *of
07:59:35 <Z`> f is the functor class ?
07:59:41 <nand`> perhaps ‘g’ would be most appropriate
07:59:46 <nand`> (for the parameter)
07:59:52 <hpc> or "func"
07:59:53 <byorgey> Z`: f is the type we are making an instance of Functor
08:00:00 <nand`> fmap g (Cons x xs) = ...
08:00:01 <Z`> List!@
08:00:05 <byorgey> Z`: right
08:01:29 <Z`> So the RHS should be of type List b?
08:02:02 <byorgey> right
08:02:31 <byorgey> so we should create it using a Cons constructor (which is what you have), since we started with a Cons constructor on the LHS
08:02:43 <Z`> Alright, ok
08:02:46 <byorgey> and what should the types of the arguments to that Cons be?
08:03:11 <Z`> the first should be List something.
08:03:12 <Z`> :)
08:03:25 <byorgey> no, the first argument to Cons is not a list
08:03:25 <Z`> I'm a bit confused by the switch from a,b to x,xs
08:03:35 <byorgey> Z`: why?
08:03:42 <Z`> data List a = Nil | Cons a (List a)
08:03:49 <hiptobecubic> looks good
08:03:55 <Z`> the first argument is 'a'
08:04:02 <byorgey> right
08:04:30 <byorgey> except in this case we are trying to construct something of type  List b
08:05:23 <byorgey> Z`: previously when we were using a,b, that meant there were two things each named a and b: the *variables* a and b and the *types* a and b
08:05:30 <byorgey> and they didn't really have anything to do with each other
08:05:32 <byorgey> which is very confusing
08:05:38 <Z`> ok
08:05:46 <hiptobecubic> i wasted a lot of time sorting that out when i started
08:05:52 <byorgey> that's why I wanted to switch to different names
08:07:03 <byorgey> Z`: anyway, why don't you try writing a function  inc :: List Int -> List Int  which adds 1 to every element of a list, like someone else suggested
08:07:10 <merijn> I have a newtype and/or monad transformer question: Given "newtype StateT s m a = StateT { runStateT :: s -> m (a, s) }" how is the code for the function runStateT produced? Or is it just the fact that the StateT constructors already accepts functions of the appropriate type?
08:07:19 <byorgey> Z`: don't worry about fmap quite yet
08:07:22 <Z`> I would really like to figure this out. Thanks for helping anyway
08:07:35 <Cale> merijn: That's a field name
08:07:46 <byorgey> Z`: doing inc will give you a better sense of what is going on structurally, without having to worry as much about the types
08:07:46 <nand`> runStateT (StateT r) = r
08:07:47 <Cale> merijn: So it extracts the field
08:07:50 <Botje> merijn: runStateT (StateT x) = x
08:07:56 <byorgey> Z`: then once you get that you can come back to fmap
08:08:25 <Z`> I'll give the fmap case a little bit more of time, and check inc if I don't do any progress. Thanks!
08:30:22 <hpc> . o O (is there an elegant way of writing a class / type family to express IO/STRef, and mutable array references?)
08:34:28 <merijn> If I do "forkIO foo" the thread will not be spawned until the resulting value encounters a >>/>>= (or functor/applicative versions), be it in do notation or not, right?
08:34:53 <merijn> Actually, I guess not even necessarily then...
08:35:17 <merijn> hmm, I need to meditate on my design :p
08:36:11 <mm_freak> merijn: i don't understand the question
08:36:32 <merijn> mm_freak: The question is wrong, ignore it :0
08:36:55 <mm_freak> given forkIO x >> y, the thread x will have been spawned by the time y is evaluated…  it's not necessarily already in execution, but it will at least have been spawned
08:37:38 <copumpkin> @tell edwardk I pushed the current state of my precision fork. It should 1) not have any segfaults anymore, with or without ghci (well, you'll get weird shit if you ask toString for a large number base) 2) fix a bunch of random bugs that I found while testing it 3) factor out a lot of the common cmm code. The build process is all fucked, still, but if you tinker (or ask me) you should be able to figure it out
08:37:39 <lambdabot> Consider it noted.
08:37:50 <rosie> How can I get better at understanding  type-mismatch error messages? e.g. parsing something like this:  Couldn't match expected type `DBAction t0' with actual type `[a0]' or  No instance for (MonadDB (LIO DCLabel))
08:38:18 <merijn> mm_freak: No, my realisation was that I can evaluate "forkIO x >> y" without a thread actually be created
08:38:33 <mm_freak> rosie: the mismatch messages can be taken literally…  the missing instance messages usually point to a type error in polymorphic code (in seldom cases you actually missed an instance)
08:38:50 <mm_freak> merijn: correct
08:39:02 <merijn> mm_freak: Which drastically simplifies my problem :p
08:39:40 <mm_freak> merijn: the evaluation doesn't do much though
08:40:01 <mm_freak> in other words:  let c = forkIO x >> y in c `seq` d
08:40:07 <mm_freak> hardly does anything
08:40:15 <monochrom> yeah
08:40:30 <mm_freak> (>>) and (>>=) are nonstrict for IO
08:40:56 <monochrom> let c = forkIO c >> c in c `seq` putStrLn "hi"
08:41:03 <rosie> mm_freak. Thanks. What do you mean by "in seldom cases you actually missed an instance" ?
08:41:15 <mm_freak> evaluation is only useful, if the application of of (>>) is itself constructed from a complicated formula
08:41:32 <mm_freak> like when the action is built by a parser or something (Parser (IO ()))
08:41:46 <mm_freak> rosie: for example open GHCi and type:  sin + cos
08:42:13 <mm_freak> (you can try lambdabot, too, but you'll get a different error message)
08:43:03 <mm_freak> now there are two possibilities…  either it's actually a type error and you really just forgot to write the arguments
08:43:15 <rosie> mm_freak: So the operands of + are expected to be an instance of Num, and they're a -> a instead, and a -> a is not an instance of the Num class?
08:43:21 <monochrom> let c = [()] >> c in putStrLn "hi"
08:43:26 <mm_freak> or you did actually want the sum of the two functions, in which case you are missing the Num instance for (Num a) => a -> a
08:43:39 <monochrom> err, let c = [()] >> c in c `seq` putStrLn "hi"
08:43:40 <mm_freak> rosie: correct
08:44:00 <mm_freak> rosie: however assuming the instances are actually there you will get this:
08:44:02 <mm_freak> > sin + cos
08:44:03 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:44:04 <lambdabot>    arising from a use of `...
08:44:16 <mm_freak> ok, in GHCi you would get a missing instance
08:44:30 <mm_freak> hmm, no
08:44:35 <monochrom> there is a new article on "reading GHC error messages" in The Monad Reader
08:44:39 <donri> :t (+) <$> sin <*> cos
08:44:40 <lambdabot> forall a. (Floating a) => a -> a
08:44:48 <mm_freak> why is there a Show instance for functions in Data.NumInstances?
08:45:02 <monochrom> http://themonadreader.wordpress.com/
08:45:19 <monochrom> but it is wrongly titled "Haskell error messages"
08:47:05 <rosie> monochrom: Thanks. Which issue?
08:47:38 <mm_freak> rosie: the latest
08:48:16 <rosie> mm_freak: awesome found it.
08:50:05 <drchaos> what is <+>?
08:50:09 <drchaos> how does it work?
08:50:29 <monochrom> which package?
08:50:35 <atriq> :t (<+>)
08:50:36 <lambdabot>     Ambiguous occurrence `<+>'
08:50:36 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
08:50:36 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
08:50:45 <drchaos> oh, XMonad
08:51:01 <monochrom> then I don't know, but glad I asked
08:51:49 <Reactionary> @hoogle Category
08:51:50 <lambdabot> Control.Category class Category cat
08:51:50 <lambdabot> Control.Category module Control.Category
08:51:50 <lambdabot> package category-extras
08:52:02 <mm_freak> nobody seems to use (<+>) from Control.Arrow, even though it's so useful
08:52:10 <mm_freak> but of course it's just a convoluted (<|>)
08:52:45 <fmap> drchaos: that's mappend
08:54:03 <monochrom> "Infix mappend. Compose two ManageHook from right to left."
08:54:18 <monochrom> hrm, right to left? :)
08:54:36 <Reactionary> Should the Functor type class not be defined in terms of a Category instance?
08:55:29 <atriq> Reactionary, how so?
08:55:40 <atriq> Oh, I see
08:55:42 <atriq> I'd say no
08:57:17 <mm_freak> Reactionary: since all functors in haskell are endofunctors for Hask, i'd second the no
08:58:30 <Reactionary> Something like (Category arr1, Category arr2) => Functor f arr1 arr2 where fmap :: (a `arr1` b) -> (a `arr2` b) (Not 100% sure about the syntax)
08:59:33 <mm_freak> Reactionary: i get what you're saying, but Functor in haskell is really EndofunctorFromHaskToASubcategoryOfHask
08:59:33 <byorgey> Reactionary: see http://hackage.haskell.org/packages/archive/categories/1.0.3/doc/html/Control-Categorical-Functor.html
08:59:49 <byorgey> but that level of generality would not be very useful in day-to-day Haskell
08:59:52 <Reactionary> byorgey: Not found error. :-S
09:00:05 <Reactionary> Oh, sorry, Emacs playing weird tricks on me.
09:00:18 <Reactionary> Oh, nice!
09:03:57 <copumpkin> omg it's an edwardk
09:04:04 * edwardk waves hello.
09:04:04 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:04:13 * zhulikas didn't notice how did he get here!
09:04:25 <zhulikas> but out of the sudden he's just here!
09:04:35 <atriq> edwardk, I'm glad you've quietened down
09:04:49 <edwardk> copumpkin: re: the mpfr branch, nice! =)
09:05:19 <copumpkin> so yeah, now you just have to battle the build process a bit ;)
09:05:21 <zhulikas> > map toUpper "edwardk"
09:05:23 <lambdabot>   "EDWARDK"
09:05:51 <Sculptor> ok, i have a question. what modules should i make myself familiar with, for starters
09:06:00 <monochrom> Prelude
09:06:05 <Sculptor> check
09:06:07 <edwardk> copumpkin: so what is still borked in the build process?
09:06:08 <merijn> edwardk: Just the man I need, I have some StateT code using lenses, which I think could be written cleaner, but with the insanely generic types I'm having a hard time finding the functions I'd need :p
09:06:12 <Sculptor> besides Prelude?
09:06:18 <mm_freak> Sculptor: Data.Map
09:06:22 <edwardk> merijn: hpaste?
09:06:25 <monochrom> everything in the Haskell 2010 Report
09:06:39 <Sculptor> k tx
09:06:51 <mm_freak> Sculptor: Data.Map teaches you not to use lists all the time and it lets you master imports a bit =)
09:06:56 <merijn> edwardk: Yeah, working on that :)
09:07:10 <Sculptor> excellent, thanks
09:07:35 <copumpkin> edwardk: I've been trying to build a static library but failed, and it's currently building a dynamic one and linking to a static location on my directory hierarchy (so you need to change the .cabal file to point to yours, because relative paths aren't allowed). Basically it needs someone who knows cabal inside-out to figure out how to do what we need, which is basically to configure/build the bundled MPFR, then run the constants program, get 
09:07:35 <copumpkin>  header file we need, build our cmm, then build our hs. I think cabal can do most of that automagically but cabal tinkering isn't really my idea of a good time
09:07:38 <hpaste> merijn pasted “lens code” at http://hpaste.org/74172
09:08:12 <edwardk> copumpkin: ah, we should be able to do that. i've done a pretty hairy custom Setup before
09:08:22 <copumpkin> you should see what it is now :)
09:08:27 <copumpkin> it's pretty hairy, but flawed
09:08:31 <merijn> edwardk: The main problem seems to be that I have StateT functions inside the StateT so I end up having to do ugly stuff with join/ap to get what I want from use
09:08:52 <edwardk> merijn: fair enough
09:08:56 <copumpkin> edwardk: but other than that, the functionality seems decent. I've added some comments to the haskell code about things I noticed but weren't necessarily wrong
09:09:14 <copumpkin> edwardk: like the fromInt# not taking a rounding argument
09:09:32 <edwardk> hrmm
09:09:35 <merijn> edwardk: Would it makes sense to have generic operators for that, or should I just write my own/leave it as-is?
09:10:19 <edwardk> merijn: honestly its not a scenario i see commonly enough to make sensible combinators for, but i'm happy to try to figure out how to tweak the code you have, probably using <~, etc.
09:12:12 <edwardk> hrmm not much that you can clean up. these nested states are icky
09:12:29 <edwardk> use output `ap` return rec  can become uses output ($rec)
09:12:47 <hpaste> fizzbang pasted “a numeric type” at http://hpaste.org/74173
09:13:23 <fizzbang> hi! i'm trying to make a type which behaves like a number in most respects
09:13:35 <fizzbang> but it seems Num is not derivable..
09:13:55 <fizzbang> i think i'm doing something wrong systemically, but i'm not sure what
09:14:07 <edwardk> fizzbang: have you seen 'dimensional'?
09:14:18 <byorgey> no, Num cannot be automatically derived
09:14:21 <edwardk> and you'd have to make your own Num for this type
09:15:01 <byorgey> fizzbang: anyway, multiplying two values in Newtons would give you Newtons^2, which cannot be represented by your type anyway
09:15:05 <merijn> edwardk: I'll just roll my own operator then. Unrelatedly, what'd be an easy way to change the lens naming generated by makeLenses? Can I somehow provide a "String -> String" function to do the mangling?
09:15:17 <edwardk> makeLensesFor
09:15:23 <k610> i am trying to compile from sources cabal but my ubunu server is weak and the compilation fully freezes the machine after downloading all the packages
09:15:26 <byorgey> fizzbang: http://hackage.haskell.org/package/dimensional
09:15:26 <edwardk> that takes a list of source/target pairs
09:15:37 <k610> I tried using cpulimit without success
09:15:44 <fizzbang> edwardk: i just looked at it, but i'm trying to learn about the type system before moving on to actually good packages..
09:15:51 <merijn> edwardk: Meh, close enough. Thanks!
09:16:15 <mesharey> hello
09:16:21 <edwardk> if that isn't sufficient you can use makeLensesWith $ lensField .~ foo $ lensRules
09:16:28 <edwardk> where foo is a function from String -> MaybeString
09:16:34 <edwardk> er String -> MaybeString
09:16:39 <mesharey> anybody there.
09:16:55 <fizzbang> byorgey: Newtons^2 is a type?
09:17:14 <mesharey> i have question please
09:17:18 <byorgey> it is a unit
09:17:29 <edwardk> basically makeLensesFor is that using list lookup ;)
09:17:29 <edwardk> mesharey: don't ask to ask, just ask
09:17:46 <byorgey> fizzbang: google "dimensional analysis"
09:17:51 <mesharey> ok
09:18:28 <mesharey> can please tell me how to learn programming quickly
09:18:51 <edwardk> mesharey: spend ~10,000 hours programming. then you'll probably be good at it
09:19:17 <mesharey> what should i do
09:19:24 <mesharey> read books
09:19:31 <fizzbang> byorgey: so it seems i'm simply going about this the wrong way? what I was hoping to accomplish was to have the haskell type system disallow sill errors like (Kilogram 4) * (Newton 5) ..
09:19:37 <fizzbang> silly*
09:19:38 <Jesin> I'm curious about http://hackage.haskell.org/package/pipes-core and http://hackage.haskell.org/package/conduit and whether they could be used to produce a safer interface to /dev/random, etc
09:20:07 <k610> how can i successfully compile this ? the apt-get install will always fail btw
09:20:12 <owst> fizzbang: why is that silly?
09:20:22 <byorgey> fizzbang: that is a wonderful goal, but it's quite difficult to get it all to work properly.
09:20:25 <owst> (Kg 4) + (N 5) on the otherhand ...
09:20:27 <mesharey> or just watch this black bakground
09:20:30 <byorgey> fizzbang: fortunately, someone else has already done all the hard work
09:20:40 <byorgey> fizzbang: just use the 'dimensional' package which I linked to above
09:20:47 <edwardk> Jesin: what are you trying to do with /dev/random that is unsafe in the first place? ;)
09:20:50 <sellout42> mesharey: I don't know a good intro-to-programming book that uses Haskell, but “A Gentle Introduction to Symbolic Computation” is a good one that uses Common Lisp.
09:21:02 <fizzbang> owst: because if you want to multiply those quantities, you need to construct a new type which accurately represents the new units
09:21:10 <fizzbang> byorgey: alright, i'll check it out.
09:21:15 <owst> byorgey, fizzbang: or investigate Andrew Kennedy's work on adding dimension types to F#
09:21:16 <fizzbang> byorgey: edwardk: thanks
09:21:19 <mesharey> thanks sellout42
09:21:47 <mesharey> exit
09:21:54 <mesharey> oh forgot.
09:22:43 <Jesin> edwardk: I was wondering why neither http://hackage.haskell.org/packages/archive/MonadRandom/latest/doc/html/Control-Monad-Random-Class.html nor http://hackage.haskell.org/packages/archive/random/latest/doc/html/System-Random.html seemed to have a good interface for /dev/random , yesterday
09:22:45 <sellout42> mesharey: After that, read Learn You A Haskell :)
09:22:48 <sellout42> damn
09:23:58 <edwardk> Jesin: nothing really stops you from making an instance that just grabs a file handle to /dev/random and slurps bits from it to feed getRandom etc.
09:24:11 <Jesin> edwardk: I talked to people about it in here, and apparently implementing those interfaces using http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.9.2.1/Data-ByteString-Lazy.html#readFile would involve unsafeInterleaveIO
09:24:20 <Jesin> which they complained about
09:24:40 <edwardk> Jesin: not necessarily. MonadRadom has a monad at all the effect sites
09:24:45 <edwardk> it could do the IO in your instance
09:24:47 <Jesin> umm
09:25:43 <edwardk> newtype DevRandom a = DevRandom { runDevRandom :: Handle -> ByteString -> IO (a, Handle, ByteString) }
09:25:47 <edwardk> er
09:25:53 <edwardk> newtype DevRandom a = DevRandom { runDevRandom :: Handle -> ByteString -> IO (a, ByteString) }
09:25:57 <edwardk> you never change handle
09:25:58 <Jesin> edwardk: the problem I'm having with that is I don't know that it's possible, given the interface to the Random typeclass, to implement "getRandom :: Random a => m a" and such without using RandomGen, which does not have a monad at all the effect sites and includes functions for obtaining infinite streams of random data, which would involve the unsafeInterleaveIO
09:26:29 <edwardk> getRandoms can always read a seed from the file to give you the infinite list
09:26:49 <Jesin> =/
09:26:52 <purefn1> edwardk: trying to play with machines-0.1 but cabal can't seem to find it on hackage
09:26:57 <edwardk> or you can let it unsafeInterleaveIO, but given the semantics of your instance I don't really see a problem with unafeInterleaveIO
09:26:59 <Jesin> and then use a PRNG for the rest?
09:27:08 <Jesin> heh.
09:27:13 <edwardk> merijn: i don't think i've shipped it officially yet
09:27:26 <Jesin> I was wondering whether http://hackage.haskell.org/package/conduit or http://hackage.haskell.org/package/pipes-core might help....
09:27:37 <Jesin> perhaps not
09:27:37 <edwardk> oh i guess i did
09:27:39 <edwardk> http://hackage.haskell.org/package/machines
09:27:52 <edwardk> Jesin: same problem if you want those instances
09:27:56 <Jesin> or I might want to write a more general TrueRandom class?
09:28:18 <Jesin> except that'd be a misnomer, kind of
09:28:23 <edwardk> anyways this is the rare case where unsafeInterleaveIO isn't unsound though
09:28:32 <Jesin> hah
09:28:36 <Jesin> really?
09:28:38 <edwardk> because /dev/random isn't going anywhere
09:28:42 <Jesin> yay
09:28:44 <edwardk> and you aren't going to move it ;)
09:28:59 <Jesin> I wasn't sure what exactly the "unsafeness" was
09:29:11 <Jesin> people complained about how non-monadic actions that block on IO are not at all nice
09:29:25 <edwardk> the unsafeness is, if i write something that unsafeInterleaveIO's I have to force the entire list, etc. before its safe for me to move the file
09:29:30 <ben> people need to stop using virtual memory then~
09:29:39 <edwardk> ben: exactly!
09:29:51 <Jesin> wait what?
09:29:54 <Jesin> virtual memory?
09:29:56 <Jesin> <_<
09:29:59 <Jesin> I'm confuse
09:30:10 <edwardk> Jesin: if you use virtual memory, when stuff gets paged out you 'block on IO' waiting for it to page back in
09:30:17 <Jesin> ...
09:30:19 <Jesin> lol
09:30:23 <edwardk> every process you ever use uses virtual memory
09:30:30 <Jesin> yaaaaay
09:30:31 <edwardk> so the 'non-IO things blocking' is a bunk argument
09:30:31 <Jesin> also
09:30:32 <purefn1> edwardk: any idea why cabal can't find it?
09:30:33 <ben> It arguably is more IO-blocky than /dev/urandom
09:30:40 <edwardk> purefn1: not off hand
09:30:53 <edwardk> not sure why the build failed either
09:30:54 <Jesin> I specified /dev/random instead of /dev/urandom because I have this nice daemon http://www.issihosts.com/haveged/
09:31:10 <maurer> I mean, virtual memory != your memory can get paged out. You can run a system that doesn't do swap
09:31:16 <edwardk> ah Data.Machine.Source was missing from the distro
09:31:18 <edwardk> one sec
09:31:33 <Jesin> which, when given "-w 4096", appears to be able to write a little bit over 3MB/s of random data to my hard drive.
09:33:04 <edwardk> purefn1: pushed 0.1.1 to hackage just now
09:33:08 <edwardk> should build. one sec
09:36:12 <purefn1> edwardk: sweet! that did the trick, thanks!
09:36:17 <edwardk> np
09:37:25 * hackagebot machines 0.1.1 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.1.1 (EdwardKmett)
09:38:19 <yitz> edwardk: having a nice entropy daemon (if that one really is good) shouldn't affect your choice of random or urandom.
09:41:45 <Sculptor> i don't think that i'll ever learn Graphics.Win32
09:46:19 <jaredj> there's a Maybe and an Either. Is there a OneOf?
09:46:38 <matthiasgorgens> what do you mean?
09:47:22 * Clint squints.
09:47:22 <jaredj> Maybe is a type I pick or None. Either is one of two types I pick. Is there something that's one of n types I pick?
09:47:29 <jaredj> er, Nothin
09:47:30 <jaredj> g
09:47:31 <hpc> no
09:47:48 <hpc> not without extensions, at least
09:48:08 <hpc> then you can define a type-level Nat, and use that to make an n-ary sum type
09:49:20 <Cale> jaredj: Generally for larger sum types, you'll really want to define your own more meaningful names for the cases.
09:49:34 <jaredj> oh, rather than Left and Right
09:49:41 <jaredj> or Case1, Case2, ...
09:49:59 <Cale> yeah
09:50:21 <jaredj> i think my typing conundrum is much too basic to drag extensions in
09:50:55 <Cale> Yeah, most likely you can solve the problem with just a data declaration for the type that you want.
09:50:59 <jaredj> i'm parsing a file format which can have any of several things at the top level, and a few of those things can have children.
09:51:09 <jaredj> so i cheerfully made record types for all the things
09:51:35 <jaredj> but now oh crap what type does my toplevel parser return? lists cannot contain different types
09:52:22 <jaredj> => either i unite all those record types into one type with many constructors, or i make a new type with many constructors each of which takes one of the record types i have
09:52:29 <hpaste> rosie pasted “instance Enum Char” at http://hpaste.org/74176
09:52:40 <matthiasgorgens> jaredj: yeah.  or use heterogenous lists.
09:52:41 <matthiasgorgens> (don't.)
09:53:03 <rosie> I'm looking at the Enum Char instance definition. What's the meaning of all the hashtags?
09:53:06 <jaredj> complication: one of the subordinate things is a Text, and you can also have a toplevel Text
09:53:12 <Cale> jaredj: I'd say go for option 2 there
09:53:34 <geekosaur> rosie, a convention in ghc is internal types / unlifted types have trailing #s
09:53:56 <geekosaur> (this requires a compilr extension which makes # an identifier character instead of an operator character)
09:54:13 <geekosaur> so Int# is a raw machine word, Char# is an unlifted byte
09:54:19 <monochrom> since Char is a built-in, it is unlikely that reading Enum Char implementation will be informative. unless you're also a compiler writer
09:54:30 <clsmith> isn't the term 'unboxed'?
09:54:32 <geekosaur> that too
09:54:40 <clsmith> or are they synonymous?
09:54:54 <geekosaur> clsmith, both are used.  admittedly "lifted" has multiple meanings already
09:55:01 <rosie> geekosaur: Thanks. What does it mean for a byte to be unlifted?
09:55:19 <clsmith> rosie: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/primitives.html has a little about it
09:55:58 <geekosaur> a lifted/boxed type is a pointer to storage, which can also represent _|_ (bottom, nontermination).  the unlifted one is just a raw machine value
09:56:24 <geekosaur> laziness is possible specifically because most values in Haskell are boxed/lifted
09:56:48 <geekosaur> but when you're implementing primitive types you need to work with the unlifted machine representations
09:57:27 <geekosaur> you could say, btw, that the hashes are a sort of "no user serviceable parts inside"
09:57:27 <Cale> fsvo need to
09:57:52 <jaredj> ?
09:58:33 <Cale> (you could try to define everything using data declarations, but it would result in a somewhat inefficient implementation)
09:59:13 <geekosaur> Peano Char-s?
09:59:29 <Cale> Hopefully if you were being serious, you'd do it a bit better than that :)
09:59:32 <rosie> geekosaur: Thanks. What does it mean that the value of a Char is a pointer to a heap object? Let's say you have 'm'. How would its underlying value be generated? Where do we create the pointer?
10:00:08 <geekosaur> @src Char
10:00:08 <lambdabot> data Char = C# Char#
10:00:45 <geekosaur> so 'c'# is an unlifted character literal, whereas internally a lifted character literal 'c' is internally the tagged value (C# 'c'#)
10:01:38 <geekosaur> which is a pointer to an internal representation containing at least the tag and the unlifted character.  it may contain other things, I do not know details of how ghc represents boxed values
10:01:40 <nand`> how many primitive types does GHC have (not counting RealWorld)? I know of Int# and Char#
10:01:52 <dolio> Unboxed is the 'no indirection.' Unlifted is 'has no extra bottom element.' They're not the same.
10:02:18 <hpc> nand`: you can see most of them if you compile GHC yourself
10:02:27 <dolio> In ML, you'd have most types boxed, for polymorphism, but they'd be unlifted.
10:02:29 <nand`> I do compile GHC myself actually
10:02:29 <hpc> it detects their machine-representations from your hardware
10:03:54 <rosie> geekosaur: thanks!
10:12:53 <tibbe> dcoutts: around?
10:14:24 <tibbe> dcoutts: have you ever seen "sibling" fusion rules, for fusing e.g. let xs = … in (map f xs, map g xs) as let xs = … in unzip (map (f *** g) xs)
10:14:36 <rosie> What are examples of implicit calls in Haskell, like fromInteger and fromString?
10:14:53 <tibbe> dcoutts: I have a special case where I have a good consumer of the unzip.
10:15:08 <tibbe> rosie: the ones for literals are the only ones I know of
10:15:18 <tibbe> rosie: and I think they're the only ones
10:15:32 <rosie> tibbe: Which are those?
10:15:46 <tibbe> rosie: fromIntegral, fromString
10:15:52 <tibbe> rosie: maybe one for floating point to
10:15:54 <nand`> there are also implicit calls on == (in addition to fromIntegral) when pattern matching on numbers
10:15:54 <tibbe> too*
10:15:59 <nand`> fromRational
10:16:35 <nand`> well, there are implicit calls in general in that certain syntax desugars to applications of other functions
10:16:49 <fmap> > 0.01 :: Ratio Int
10:16:50 <lambdabot>   1 % 100
10:16:52 <fmap> hmm
10:16:58 <tibbe> rosie: list comprehensions desugar to calls to concatMap, filter, etc
10:17:20 <nand`> it also desugars to monad stuff with -XMonadComprehensions
10:17:47 <rosie> nand` and tibbe: Thank you!
10:19:09 <tibbe> rosie: you're welcome
10:21:24 <timthelion> Amazing how many goats you have to kill to get (1000/(1000/99)) to equal 99 in a statically typed language.
10:22:08 <yitz> edwardk: fyi. i googled around a little about havege. i'm no expert on this, but it doesn't sound like a very good idea for /dev/random to be fed by havege.
10:22:24 <edwardk> havege?
10:22:34 <edwardk> the dev/random process guy was someone else
10:22:36 <rking> timthelion: That's just floating-point arithmetic trouble, I think. Which is almost unavoidable.
10:22:47 <edwardk> i was just saying you can interleaveIO from it sanely
10:23:44 <yitz> edwardk: oh sorry it was Jevin, not you.
10:24:23 <yitz> *Jesin
10:26:09 <parcs`> > (1000/(1000/99)) == 99
10:26:10 <lambdabot>   True
10:27:09 <copumpkin> Prelude Numeric.Rounded> sin pi :: Rounded TowardZero $(bits 512)
10:27:09 <copumpkin> 0.266312059246010026416205255559426165896076919361199954077523661842089778871142377633756765104817453039326456918044433243785594843470290770010458035743402162
10:28:10 <timthelion> When I hoogled: (Fractional a , Inegral b) => a -> b first answer is unsafeCoerce :D
10:28:27 <nand`> copumpkin: ‘bits’ is TH for the Fixed stuff?
10:28:42 <copumpkin> yeah, although edwardk has some other way to use it too
10:28:46 <typoclass> copumpkin: what package houses Numeric.Rounded?
10:28:51 <copumpkin> or was planning on it, at least judging from his example code
10:29:05 <copumpkin> typoclass: precision, but I don't think it's on hackage yet
10:29:22 <hpaste> timthelion pasted “doesn't typechech error at bottom” at http://hpaste.org/74177
10:29:26 <edwardk> typoclass: its going to be in precision once we can work out the packaging details
10:29:37 <copumpkin> @hackage hmpfr
10:29:37 <lambdabot> http://hackage.haskell.org/package/hmpfr
10:29:43 <copumpkin> that's our competition
10:29:46 <edwardk> basically its a port of mpfr that works ;)
10:29:48 <typoclass> i see, thanks
10:30:04 <timthelion> parcs`: that still doesn't make whichBucket, line 142, typecheck.
10:30:14 <yitz> um copumpkin? is that supposed to be a good estimate for sin pi?
10:30:15 <typoclass> edwardk: always a good quality in a package :)
10:30:27 <edwardk> even if copumpkin had to concoct some horrible gc tricks to make it work ;)
10:30:33 <copumpkin> yitz: nope, it's a bug :)
10:30:44 <edwardk> > sin pi
10:30:45 <parcs`> timthelion: oh you mean having to use fromIntegral ,realToFrac etc?
10:30:45 <yitz> copumpkin: sure is! :)
10:30:45 <lambdabot>   1.2246467991473532e-16
10:31:04 <timthelion> parcs`: What do I need there?
10:31:11 * typoclass just thought the ":: Rounded TowardZero" thing looked spiffy
10:31:19 <copumpkin> it is really spiffy
10:31:28 <edwardk> copumpkin: not much competition at this point ;)
10:31:38 <yitz> edwardk: a little better. but still not great.
10:31:57 <Eduard_Munteanu> > sin 0
10:31:58 <lambdabot>   0.0
10:32:11 <copumpkin> edwardk: gonna fix that bug :P
10:32:15 <timthelion> parcs`: really, round didn't help.
10:32:18 <edwardk> k
10:32:20 <copumpkin> it's a toString bug, I think
10:32:24 <parcs`> timthelion: where?
10:32:30 <edwardk> ah
10:32:30 <copumpkin> since I fucked with that a decent amount and replaced the old Show instance
10:32:30 <timthelion> parcs`: see paste...
10:32:33 <parcs`> oh
10:32:39 <timthelion> parcs`: line 142
10:33:00 <timthelion> error's at the bottom
10:33:41 <parcs`> what's the intended type of whichBucket?
10:34:10 <timthelion> parcs`: Int, as it's the index of a mutable array.
10:34:17 <beaky> How do you build Haskell projects with GNU Autotools?
10:34:18 <copumpkin> aha, I was just misinterpreting the result of get_str :)
10:34:25 <edwardk> copumpkin: whew =)
10:34:30 <matthavener> is there a better way to do HTTPS in haskell other than the curl wrappeR?
10:34:45 <c_wraith> the curl wrapper is about the worst way to do it
10:34:47 <copumpkin> matthavener: http-enumerator isn't bad
10:34:57 <edwardk> beaky: you can set up a cabal project that has a autoconf based build-type
10:35:07 <c_wraith> since it doesn't initialize openssl properly to be thread-safe
10:35:10 <matthavener> copumpkin:ah, thank you
10:35:10 <parcs`> timthelion: ah, you probably want to use `div` instead of /
10:35:14 <c_wraith> so it's a good way to get segfaults
10:35:37 <timthelion> parcs`: but then (1000/(1000/99))=100 :/
10:36:04 <matthavener> c_wraith: wow, strange, i'd think most programs using the network would also use threads :), unless i'm missing some other non-blocking system in haskell
10:36:08 <edwardk> beaky: https://github.com/ekmett/wl-pprint-terminfo uses autoconf: https://github.com/ekmett/wl-pprint-terminfo/blob/master/Setup.lhs#L3
10:36:25 <typoclass> matthavener: doesn't http-conduit allow https as well?
10:36:43 <timthelion> parcs`: now do you see the trouble?
10:36:48 <c_wraith> yeah, use http-conduit.  http-enumerator is deprecated
10:36:57 <parcs`> timthelion: then floor (fromIntegral (number - min) / (fromIntegral (max - min) / fromIntegral numBuckets))
10:37:09 <typoclass> matthavener: it's pretty straightforward to use: http://hackage.haskell.org/packages/archive/http-conduit/1.6.0.1/doc/html/Network-HTTP-Conduit.html
10:37:18 <timthelion> parcs`: I'll try anything :)
10:37:19 <matthavener> ah ok, but both of these are non-builtin, right?
10:37:32 <jdnavarro> is there a way to do the equivalent of `unhex`(http://hackage.haskell.org/packages/archive/hex/0.1.2/doc/html/Data-Hex.html) in standard Haskell?
10:38:00 <jdnavarro> standard Haskell == a function that can be imported from the Haskell platform
10:38:05 <timthelion> parcs`: :) that's awful :D
10:38:48 <timthelion> parcs`: but still gets the wrong answer :(
10:38:59 <parcs`> timthelion: perhaps you want 'round' instead of 'floor' in case of precision errors
10:39:47 <timthelion> parcs`: nope :/
10:40:10 <copumpkin> aha, a memory leak too
10:40:51 <parcs`> :(
10:43:16 <timthelion> Hpaste is down!
10:44:30 <hpaste> applicative pasted “sacre blue!” at http://hpaste.org/74178
10:44:55 <applicative> bleu rather
10:46:36 <timthelion> parcs`: it's working now, thanks :)
10:46:47 * timthelion was an idiot and was passing wrong arguments to it.
10:47:07 <applicative> jdnavarro: the text package treats hexadecimals
10:47:35 <applicative> jdnavarro: don't know if it does all you want, but isnt it in the 'platform'  http://hackage.haskell.org/packages/archive/text/0.11.2.2/doc/html/src/Data-Text-Lazy-Read.html#hexadecimal
10:48:25 <jdnavarro> applicative: I missed that, that's what I need
10:48:57 <jdnavarro> applicative: the package text is included in the platform, isn't it?
10:49:32 <applicative> jdnavarro: it is now
10:49:58 <jdnavarro> applicative: that will do, thanks!
10:51:57 <copumpkin> edwardk: so what's a good display format? what threshold should we use to cut over to scientific notation?
10:52:33 <edwardk> copumpkin: hrmm, well, we have an exact number of bits, so we could always just show the number fully expanded ;)
10:52:49 <copumpkin> yeah, but do people really want that?
10:52:51 <edwardk> ask for 512 bits of precision? fine, you get 512 bits of precision
10:52:52 <copumpkin> that'd be easiest to implement
10:53:03 <edwardk> *nods*
10:53:07 <copumpkin> well, we can show an arbitrarily large significand
10:53:09 <edwardk> lets just do that and see who complains
10:53:13 <copumpkin> but avoid a bunch of zeros past a certain point
10:53:21 <copumpkin> I wouldn't want to lose precision
10:53:25 <edwardk> i'd be okay with that too
10:53:26 <copumpkin> but a bunch of zeros are a waste
10:53:49 <edwardk> the trick is that most of these will not be trailing all 0s, because the exponentiation is in powers of 2
10:53:57 <copumpkin> alright, I'll do that for now
10:54:16 <edwardk> btw- thanks for picking this back up. i'd given up ;)
10:54:31 <copumpkin> hah
10:54:37 <copumpkin> it felt like a waste of effort
10:54:39 <copumpkin> can't have that
10:54:55 <copumpkin> I think we're pretty good as far as memory issues go now, apart from this leak
10:54:56 <edwardk> would the easiest way to get the build configured be to just use autoconf hooks like i do in wl-pprint-terminfo?
10:55:13 <copumpkin> not sure, what do you do there?
10:55:50 <edwardk> https://github.com/ekmett/wl-pprint-terminfo/blob/master/Setup.lhs#L3 then use a custom https://github.com/ekmett/wl-pprint-terminfo/blob/master/configure.ac
10:56:42 <copumpkin> hmm
10:56:52 <copumpkin> well, we need to run a configure script and also do some other stuff
10:57:00 <edwardk> then i bolt the library in with https://github.com/ekmett/wl-pprint-terminfo/blob/master/wl-pprint-terminfo.buildinfo.in
11:05:27 <timthelion> division is really much much harder than comparison eh :(
11:08:17 <copumpkin> oh wait, there's no memory leak, whee
11:08:23 <copumpkin> cause it's GHC's allocator
11:08:38 * copumpkin hugs GHC's allocat
11:08:44 <edwardk> =)
11:09:10 <edwardk> was this the extra spaces allocated in toString?
11:09:36 <copumpkin> nah, just the toString underlying function, we tell mpfr_get_str to allocate its own string
11:09:41 <copumpkin> because it knows how big it needs to be
11:09:54 <copumpkin> in theory you're supposed to free it, but we don't
11:10:03 <edwardk> thats what i meant. it winds up allocating ~3 or so versions some times, etc.
11:10:12 <copumpkin> oh really?
11:10:14 <edwardk> that was an old problem but now it shouldnt be an issue
11:10:18 <copumpkin> I haven't actually watched what it does
11:10:46 <edwardk> it has to do some tricks to deal with rounding properly
11:11:00 <edwardk> for display
11:11:04 <copumpkin> ah
11:13:02 <scshunt> Hey all
11:13:09 <scshunt> any way to make GHCi put multiple modules in scope?
11:13:15 <scshunt> if I :l multiple modules, only the first one is in scope
11:15:44 <Botje> :m +Foo Bar Baz
11:16:56 <Z`> I tried to write a functor over lists, that adds 1 on every element, but I failed even in that simple example :(
11:17:20 <edwardk> Z`: You mean you tried to fmap over the list?
11:17:26 <edwardk> > map (+1) [1,2,3]
11:17:27 <lambdabot>   [2,3,4]
11:17:31 <edwardk> > fmap (+1) [1,2,3]
11:17:32 <lambdabot>   [2,3,4]
11:18:05 <Z`> I tried to write an instance of Functor for a custom List type
11:18:26 <Z`> http://paste.lisp.org/display/131494
11:19:09 <opqdonut> you've kind of written out what "fmap inc list" would do
11:19:20 <opqdonut> but the function argument to fmap can be anything!
11:19:21 <opqdonut> :t fmap
11:19:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:19:48 <opqdonut> to prevent confusion you should write the equations as
11:19:56 <opqdonut> fmap f Nil = ...
11:20:01 <opqdonut> fmap f (Cons x xs) = ...
11:20:34 <Z`> ok, still hugs will give me an error:
11:20:39 <Z`> *** Expected type : Functor List => (a -> b) -> List a -> List b
11:20:39 <Z`> *** Inferred type : Functor List => (a -> a) -> List a -> List a
11:20:57 <Z`> I'm failing to derive the type b
11:21:11 <opqdonut> well the problem is the (x+1)
11:21:44 <opqdonut> also, I guess you're not using f anywhere (except passing it on to the next fmap)
11:21:52 <Z`> yes
11:24:56 <barrucadu> Z`: fmap inc (Cons x xs) = Cons (inc x) (fmap inc xs)
11:25:04 <barrucadu> You need to use the function that is passed in
11:26:05 <Z`> thanks barrucadu
11:26:44 <Z`> and then I could write: fmap (\x -> x+1) (Cons 1 Nil)
11:27:00 <barrucadu> Yes
11:27:09 <Z`> sweet
11:27:31 * hackagebot persistent 1.0.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.0.1 (FelipeLessa)
11:32:31 <tigger123> Hi All, I just finished a package I want to upload to hackage. Locally I am able to run cabal haddock, and go to the dist folder with the docs there, but when I try to upload I don't see the module links highlighted. Is there something I need to do to make sure the docs show up?
11:32:33 <tigger123> thanks
11:34:54 <edwardk> tigger123: hackage builds the docs every ~12 hours
11:35:03 <edwardk> tigger123: until then the links won't light up
11:35:07 <schellsan> I'd like to see the Show instance for Float. Is there a way to do that in ghci?
11:36:11 <tigger123> ok! so If I can build them locally, they should eventually show up (for the most part)?
11:36:50 <edwardk> tigger123: assuming the build server can compile the package. this doesn't work when the package needs a lib, etc. that may not be installed on the hackage server
11:36:56 <c_wraith> schellsan: no, ghci operates on compiled code, not source.  It doesn't store the source of anything
11:37:53 <tigger123> edwardk: hmm, okay I'm working on the portaudio bindings, so I'm guessing it would not be able to compile since it needs the portaudio library
11:37:58 <schellsan> c_wraith: bummer, thanks. does haskell platform come with source?
11:38:37 <edwardk> sadly
11:39:09 <tigger123> ok, also If I have an examples folder, how can I get sdist to tar those along with the src directory?
11:39:59 <edwardk> tigger123: add extra-source-files: to your cabal file
11:40:20 <edwardk> https://github.com/ekmett/lens/blob/master/lens.cabal#L86
11:41:00 <tigger123> ok thanks for your help!
11:41:12 <c_wraith> schellsan: amusingly, not for that, since base (the package that contains the Float type) is a package that comes with ghc and is distributed already-compiled.  you could run "cabal unpack base" and it will fetch and unzip the base package for you to examine
11:41:47 <edwardk> tigger123: there are a numberof other tricks in that cabal file you might want to borrow as well
11:41:50 <c_wraith> schellsan: you can also say base-versionnumber to get a specific version
11:41:59 <c_wraith> schellsan: in the cabal unpack command, that is
11:43:55 <schellsan> c_wraith: okay, thanks - so in general i have to read the source to see specific instance implementations...
11:44:53 <c_wraith> schellsan: yeah.  that one's probably going to be extra-tricky to find, since there's a lot of native code in the implementation of instances for Float (since it's a native type underneath a boxed wrapper)
11:46:16 <schellsan> c_wraith: k, thanks again
11:46:21 <tigger123> edwardk: thanks! I'll just wait to see if the docs get generated.
11:47:31 * hackagebot portaudio 0.2.2 - Haskell bindings for the PortAudio library.  http://hackage.haskell.org/package/portaudio-0.2.2 (AnilVaitla)
12:03:52 <aleksandar> hi
12:04:08 <aleksandar> does anybody know hen will gtk2hs be ported to gtk 3?
12:04:13 <aleksandar> when*
12:11:16 <copumpkin> edwardk: holy shit, http://hackage.haskell.org/packages/archive/base/3.0.3.2/doc/html/src/GHC-Float.html#formatRealFloat
12:11:19 <copumpkin> that's an ugly beast
12:11:40 <copumpkin> doing more than we need though
12:11:44 <edwardk> copumpkin: yeah
12:12:04 <edwardk> isn't that what we're just asking mpfr to do for us though?
12:12:17 <copumpkin> sorta, except I wanted to replicate its rules about switching to exponential notation
12:12:45 <edwardk> ah
12:12:53 <edwardk> what are the rules that are problematic?
12:13:22 <copumpkin> there aren't any problematic ones, it's just hard to know if I have all the edge cases correct
12:13:26 <phy1729> I need to store what is essentually a state map (directed graph each state has only one arrow out) and need to get cycle lengths and reachability out what data type should I be using?
12:20:34 <hpaste> applicative pasted “indexed.group” at http://hpaste.org/74183
12:20:56 <applicative> edwardk: here's my deep contribution to 'indexed' :)
12:21:12 <edwardk> applicative: =)
12:21:27 <Yiq> can you build the haskell twitter?
12:21:41 <edwardk> i was actually thinking about adding that =)
12:22:16 <Botje> Yiq: don't see why not.
12:22:47 <Yiq> apaprently cabal install twitter treies installing something else, what i dont know
12:22:57 <Yiq> how does it search anyway?
12:23:19 <Botje> "twitter program: A Haskell-based CLI Twitter client"
12:23:29 <Botje> it just uses whatever you give it as package name
12:23:35 <applicative> Yiq it has a list of things if you do cabal update
12:23:40 <Yiq> ïf i write yiqsprog and there is yiqsprogram1 and yiqsprogram2 then it will take yiqsprogram1 +
12:24:10 <applicative> edwardk: somehow, I can't see these groupoids being as fruitful as they might be
12:24:53 <edwardk> when i put the --author on the commit, who should i put it as?
12:25:17 <copumpkin> i.e., "who the fuck are you"
12:25:21 <edwardk> hah
12:25:36 <applicative> not sure really
12:25:45 <edwardk> was just looking for an email address, but i can just leave off the author tagging
12:25:49 <edwardk> =)
12:26:06 <Jeanne-Kamikaze> good one copumpkin
12:26:25 <edwardk> ok, committing it normally then
12:26:45 <applicative> seems best
12:26:57 <copumpkin> we need applicative to be copointed so we can get the secret out
12:27:39 <Botje> Sometimes I wonder if there is a #cohaskell
12:27:52 <Botje> but I'm pretty sure it exists :)
12:28:01 <edwardk> applicative: pushed
12:28:08 <applicative> ah good.
12:28:16 <edwardk> i proved in my blog that cohaskell is less useful than haskell ;)
12:28:22 <edwardk> sorry copumpkin
12:28:34 <copumpkin> :(
12:28:52 <applicative> somehow that the typechecker accepts the groupoid instance for == is reassuring ...
12:29:08 <edwardk> applicative: yeah. there is a similar instance in Type.Eq in my eq package
12:29:25 <timthelion> google doesn't know about cohaskell.
12:29:27 <edwardk> but i wanted to use (==) in this package =)
12:30:14 <edwardk> timthelion: http://comonad.com/reader/2011/monad-transformers-from-comonads/ every comonad gives rise to a monad transformer, but not every monad gives you a comonad transformer
12:30:22 <edwardk> hence there are fewer comonads than monads
12:30:48 <applicative> == is nice, I wonder why I haven't seen it before.
12:30:57 <edwardk> applicative: it only became usable in 7.6
12:31:20 <edwardk> before it had to start with a : to be an infix type constructor
12:31:22 <copumpkin> there's a lot of obsolete crap in GHC.Float
12:31:24 <applicative> ah, is that it.   I am frequently in a muddle about what is legitimate where
12:31:54 <applicative> but the 'data constructors' still obey the :+<> rule
12:31:58 <edwardk> indexed basically hitches its wagon to 7.6 for so much stuff it'd be silly not to use the extra stuff
12:31:59 <edwardk> yeah
12:32:11 <edwardk> but its nice that you can say type (+) = Either
12:33:08 <timthelion> edwardk: Every type in haskell can be made an instance of functor.  Does that mean we should give up on monads and just go with functors.(I actually have no clue what I'm talking about, just seems like the logical counter argument to such a blog post.)
12:33:42 <edwardk> timthelion: actually not every type in haskell can be made an instance of Functor
12:33:51 <edwardk> i look forward to your Functor for Endo =)
12:34:02 * timthelion is surprised.
12:34:10 * timthelion will look at Endo now...
12:34:11 <edwardk> newtype Endo a = Endo (a -> a)
12:34:19 <edwardk> a occurs in both positive and negative position
12:34:32 <edwardk> fmap gets stuck trying to provide the 'input' a
12:34:47 <edwardk> more simply
12:34:54 <edwardk> newtype Predicate a = Predicate (a -> Bool)
12:34:54 <Yiq> > ((+1) &&& (-1)) . (\x->(x,x)) $ 5
12:34:56 <lambdabot>   ((6,6),-1)
12:35:02 <edwardk> is Contravariant, not a Functor.
12:35:03 <applicative> ah, I can write type family (a :: Nat) +  (b :: Nat) :: Nat too
12:35:17 <edwardk> applicative: yeah that was pretty much why it was done i think
12:35:24 <Yiq> > ((+1) *** (-1)) . (\x->(x,x)) $ 5
12:35:26 <lambdabot>   (6,-1)
12:35:35 * timthelion has had a bit of his mind opened up today :)
12:35:43 <Yiq> > ((+1) *** (-1)) $ (5,5)
12:35:44 <lambdabot>   (6,-1)
12:35:52 <Yiq> > ((+1) *** (+3)) $ (5,5)
12:35:53 <lambdabot>   (6,8)
12:35:58 <Yiq> > ((+1) *** (1-)) $ (5,5)
12:35:59 <lambdabot>   (6,-4)
12:36:12 <Yiq> > ((+1) *** (-1)) $ (5,5)
12:36:13 <lambdabot>   (6,-1)
12:36:19 <Yiq> why doesnt -1 work+
12:36:30 <Mortchek> -1 is negative one, not a section
12:36:30 <Yiq> > ((+1) *** (-1)) . \x->(x,x) $ 5
12:36:31 <lambdabot>   Couldn't match expected type `a -> b'
12:36:31 <lambdabot>         against inferred type `(t, t)'
12:36:33 <Nereid> (subtract 1)
12:37:11 <Yiq> > ((+1) *** (subtract 1)) . (\x -> (x,x)) $ 5
12:37:12 <Nereid> ((+1) *** (subtract 1)) $ (5,5)
12:37:13 <lambdabot>   (6,4)
12:37:20 <Nereid> heh.
12:37:33 * hackagebot cblrepo 0.6.3 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.6.3 (MagnusTherning)
12:37:44 <Yiq> @type (&&&)
12:37:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:37:50 <Yiq> @src (&&&)
12:37:50 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
12:38:03 <Nereid> (+1) &&& (subtract 1) $ 5
12:38:07 <Nereid> > (+1) &&& (subtract 1) $ 5
12:38:08 <lambdabot>   (6,4)
12:38:11 <Yiq> > ((+3) &&& (+5)) 5
12:38:12 <lambdabot>   (8,10)
12:38:35 <hpaste> timthelion pasted “Why isn't this faster than the naive version ?” at http://hpaste.org/74184
12:38:39 * timthelion thinks that GHC's profiler is just plain broken :(
12:39:51 <timthelion> What could possibly be taking a long time in whichBucket?
12:40:17 <copumpkin> Prelude Numeric.Rounded> sin pi :: Rounded TowardZero $(bits 512)
12:40:17 <copumpkin> 2.66312059246010026416205255559426165896076919361199954077523661842089778871142377633756765104817453039326456918044433243785594843470290770010458035743402162e-153
12:40:20 <copumpkin> better?
12:40:22 <copumpkin> :P
12:40:43 <nand`> seems mildly more accurate
12:40:56 <copumpkin> hmm, I might have a slight bug though
12:41:56 <timthelion> What is the chance that the profiler is just giving me BS?
12:42:04 <copumpkin> yeah, fucking off-by-one error
12:42:07 * copumpkin sighs
12:42:35 * hackagebot hlibgit2 0.2.1 - Low-level bindings to libgit2.  http://hackage.haskell.org/package/hlibgit2-0.2.1 (JohnWiegley)
12:49:39 <hpaste> t7 pasted “babbys first scheme parser” at http://hpaste.org/74187
12:49:47 <ion> > showCReal 200 (sin pi)
12:49:48 <lambdabot>   "0.0"
12:50:54 <applicative> > ((+ 1) *** (subtract 1)) . join (,) $ 5
12:50:55 <lambdabot>   (6,4)
12:51:12 <nand`> > (+1) &&& (subtract 1) $ 5
12:51:13 <lambdabot>   (6,4)
12:51:24 <ion> > (succ &&& pred) 5
12:51:25 <lambdabot>   (6,4)
12:51:44 <edwardk> copumpkin: so close =)
12:51:48 <Botje> t7: now do it in parsec!
12:52:59 <Yiq> benny banks ftw
12:53:24 <edwardk> copumpkin: thinking about renaming the repo to 'rounded' since the major module is Numeric.Rounded
12:53:26 <t7> i like my spaghetti more
12:53:36 <copumpkin> edwardk: that'd make sense
12:53:48 * nand` feels like learning trifecta
12:54:07 <copumpkin> Prelude Numeric.Rounded> 1e6 :: Rounded TowardZero Double
12:54:08 <copumpkin> 1.0000000000000000e7
12:54:09 <copumpkin> hmm :)
12:54:11 * edwardk feels like documenting trifecta
12:54:16 <edwardk> copumpkin: hahaha
12:54:21 <ion> edwardk: yay
12:54:38 <edwardk> oh wait, nope. i got over it
12:54:43 <ion> aww
12:54:47 <nand`> edwardk: I was about to suggest piping it :(
12:54:47 <edwardk> whew, that was close
12:55:15 <nand`> (edwardk :: Trifecta -> Documentation) >>> (nand` :: Documentation -> Code)
12:55:30 <edwardk> the main issue is that to work on trifecta i have to finish porting stuff from 0.5x to 0.90
12:55:36 <ion> nand: Parse error
12:55:46 <Yiq> getMentions :: Maybe String -> Maybe String -> TM [Status]
12:55:51 <edwardk> nand' . edwardk
12:55:55 <Yiq> why would it take Maybe String a sinput?
12:56:11 <ion> Why is the sky blue?
12:56:35 <t7> magnets
12:57:21 <copumpkin> edwardk: I pushed the toString fix
12:57:23 <Yiq> i should say it is the twitter API
12:57:29 <edwardk> copumpkin: sweet =)
12:57:44 <edwardk> so what is left, setting up a nice autoconf and reference to the lib?
12:57:54 <timthelion> So after spending an hour scratching my head, simply compiling with -O2 improved runtime by 4x ! :D
12:58:00 <copumpkin> edwardk: reference to the lib?
12:58:24 <edwardk> you said something about a hand-coded path you hated
12:58:24 <copumpkin> ideally it would grab the lib externally and patch it on the fly :) but I don't feel like doing all that shit
12:58:40 <copumpkin> oh yeah, it's in the .cabal file, referencing my home dir
12:59:01 <copumpkin> it's also impossible to build the lib the first time you try it
12:59:03 <timthelion> So basically, it turns out that when you compile without -O2, the profiling numbers are pretty meaningless...
12:59:08 <copumpkin> you need to remove the lib reference, build, then put it back in
12:59:09 <edwardk> does extra-lib-dirs: dist/lib work?
12:59:10 <copumpkin> then build again
12:59:12 <copumpkin> no
12:59:19 <edwardk> shucks
12:59:23 <copumpkin> that's because it gets linked dynamically
12:59:28 <copumpkin> which I also don't want
12:59:41 <edwardk> so that means a custom cabal Setup.hs that builds and then adds the path?
12:59:50 <copumpkin> something like that, yeah
13:00:01 <copumpkin> I struggled with cabal enough to write the pile o' crap that's in Setup.hs right now
13:00:02 <edwardk> something like what the darcs.cabal file does
13:00:05 <copumpkin> and then decided to give up
13:00:20 <copumpkin> perhaps dcoutts knows best
13:00:21 <copumpkin> :P
13:00:36 <edwardk> oh whoa. you do quite a bit in there
13:01:49 <copumpkin> yeah :P
13:02:03 <copumpkin> currently it reconfigures and rebuilds the whole mpfr lib every time
13:02:03 <Rc43> Hi, guys.
13:02:13 <copumpkin> which is annoying as hell for typos and the like
13:02:36 <copumpkin> I'd imagine cabal knows how to do some of that stuff itself but I got sick of trying :)
13:02:54 <Rc43> Are there any repl-plugins for vim+ghci? I want something like selection-code-interpreting. I have heard that there is such thing for lisp.
13:03:18 <edwardk> hrmm integer-gmp doesn't exist on ghc 7.6?
13:03:35 * t7 wonders if you could write a scheme in C++ using sharedptr for garbage collection... 
13:03:47 <Rc43> So, I mean this "1. Open haskell code in vim. 2. Select some code. 3. Launch relatively to scopes in which this code is."
13:04:10 <Rc43> Instead of retyping / copy-pasting code into ghci.
13:04:22 <Rc43> And copy-pasting will lose scope, etc.
13:04:26 <copumpkin> edwardk: beats me! seems weird if it doesn't
13:04:30 <copumpkin> what does ghc-pkg list show you?
13:05:22 <edwardk> ah nm     integer-gmp-0.5.0.0
13:05:42 <Yiq> getMentions mbId mbMax returns the 20 most recent mentions #anyone familiar with hs-twitter and twitter? what is mbId and mbMax?
13:06:22 <copumpkin> mmmm mango kombucha
13:08:41 <edwardk> hrmm config.status: error: cannot find input file: `doc/Makefile.in'
13:09:29 <nand`> (it is normal for the RFC2616.hs example not to build?)
13:09:36 <copumpkin> edwardk: hmm!
13:10:11 <sheldonh> is there a way i can say that "a" must be Integral here? data Fraction = Fraction {numerator :: a, denominator :: a}
13:11:02 <nand`> (are you sure that's what you want to do? Why not just use Integer?)
13:11:25 <sheldonh> nand`: thinking... :)
13:12:07 <sheldonh> nand`: no. i want to use Integer :)
13:12:17 <nand`> I mean, the only real way you could specify that as ‘all Integral types’ is with an existential quantification, and then the only useful thing you could do with it at the end of the day is convert it to an Integer; unless perhaps you meant ‘data Fraction a = ...’
13:12:22 <nand`> also see the type ‘Rational’
13:12:31 <nand`> which is Ratio Integer, and probably close to what you want
13:12:44 <sheldonh> nand`: ta
13:14:16 <edwardk> copumpkin: did you omit committing mpfr-3.1.0/doc ? or something?
13:15:30 <edwardk> copumpkin: also there is a bugfix 3.1.1 release out there ;)
13:15:46 <edwardk> http://www.mpfr.org/mpfr-3.1.1/
13:15:49 <copumpkin> hmm, git isn't listing it as missing, but it didn't get committed
13:15:54 <gentleben> anyone familiar with mallocPlainForeignPtrBytes?
13:16:06 <copumpkin> must be on some ignore list
13:16:09 <edwardk> copumpkin: check .gitignore ;)
13:16:12 <edwardk> its in there ;)
13:16:13 <edwardk> thats why
13:16:22 <copumpkin> that'll do it
13:16:24 <copumpkin> boo :P
13:16:35 <edwardk> drop doc from gitignore and try again
13:16:42 <copumpkin> yup
13:17:17 <copumpkin> pushed again
13:17:21 <osa1> is there a string that this parsec parser accepts: ((string "ok") `sepBy` (try $ char ',')) >> char ',') ?
13:17:24 <edwardk> score, pulling
13:17:30 <copumpkin> I was gonna wait until a bigger new release
13:17:43 <copumpkin> also, how do you want to track versions?
13:17:56 <copumpkin> the patches I made to the project are pretty minimal, honestly
13:18:07 <copumpkin> but they're not something that can be described easily by patch files
13:18:22 <copumpkin> I could probably write a small patcher program that takes a source tree and makes some transformations to it though
13:18:28 <copumpkin> if you want to arrange the build/retrieval of it :P
13:19:26 <sheldonh> nand`: all i really want is my own Fractional against which to write my own *, +, / and ^ functions for, to practice. thought i might try apply what i'm learning about the type system. clearly, i've not absorbed much :)
13:20:25 <nand`> well, the way Ratio works is basically the same way as the Fractional type you posted earlier except the ‘a’ is a type parameter
13:20:31 <nand`> like data Fractional a = ...
13:21:17 <edwardk> i'm okay with bundling for now -- i just want it to be able to install directly for the end user
13:21:58 <Yiq> Basic authentication is not supported # from hs-twitter. the login doesnt give anything back, success or fail so hard to know what fails exactly.
13:22:20 <Yiq> but I get "Basic authentication is not supported" when having logged in and trying to tweet
13:22:28 <Yiq> anyone know hs-twitter?
13:22:30 <sheldonh> nand`: and then when i define functions, i say stuff like (*) :: (Integral a, Fractional Integral b) => a -> a -> b ?
13:22:40 <nand`> sheldonh: no
13:22:45 <nand`> Fractional is not a typeclass there
13:22:51 <edwardk> copumpkin: a diff might be handy to have though, just for reference when folks want to upgrade it to a later mpfr
13:22:52 <Yiq> Sigbjorn Finne are you here?
13:23:03 <copumpkin> Yiq: I don't think he does much haskell anymore
13:23:04 <nand`> it would be something like mul :: Integral a => Fractional a -> Fractional a -> Fractional a
13:23:19 <sheldonh> nand`: just a constructor with parametised type. yes?
13:23:30 <nand`> yes
13:23:33 <copumpkin> edwardk: alright, I'll throw something together
13:24:01 <edwardk> ghci> sin pi :: Rounded TowardZero $(bits 512)
13:24:02 <edwardk> 2.66312059246010026416205255559426165896076919361199954077523661842089778871142377633756765104817453039326456918044433243785594843470290770010458035743402162e-153
13:24:09 <edwardk> nifty keen
13:24:38 <Yiq> copumpkin: then we have no choice but to kill him unfortuneately
13:24:44 <nand`> is ‘bits’ total?
13:25:09 <edwardk> copumpkin: one quirk is it shows:  .000000000000000000000000000 with no leading 0
13:25:11 <sheldonh> nand`: alright, let's see if i can bang my head into this square shaped hole without further hand holding. thanks :)
13:25:18 <copumpkin> edwardk: damn!
13:25:19 <copumpkin> lol
13:25:40 <edwardk> nand`: takes positive ints, but otherwise,
13:25:48 <copumpkin> edwardk: I think it'd be better to delegate pretty printing to the fancy printf-variant that's inside mpfr, honestly
13:25:59 <copumpkin> we can give it format specifiers and have it do the thinking for us
13:26:03 <copumpkin> instead of mangling the string ourselves
13:26:20 <edwardk> actually i don't recommend trying negative integers, they turn into words
13:26:25 <edwardk> and then your computer hangs ;)
13:26:50 <nand`> ‘they turn into words’? you mean they get wrapped around?
13:26:56 <edwardk> yeah
13:27:00 <nand`> ouch
13:27:08 <nand`> better fail gracefully on that :)
13:27:14 <edwardk> maybe i should make bits complain more gracefully =)
13:27:23 <copumpkin> lol
13:28:35 <applicative> Yiq: I think you'll do better if you  also study the twitter api itself, heaven forfend https://dev.twitter.com/docs/working-with-timelines
13:29:14 <Yiq> heaven forfend?
13:29:39 <applicative> Yiq: I'd love to try it, but I think a Monad Twitter would require authentication, and thus an account..
13:31:56 <applicative> copumpkin: you mean Sigbjorn F isn't bringing haskell goodness into the Opera browser?
13:32:08 <copumpkin> perhaps he is :)
13:32:35 <applicative> somewhat irksome this.
13:35:51 * applicative signed up to 'follow' the Fay programming language on github, but they commit too much so I'm axing them.
13:36:11 <knrafto> is it always best to use lazy patterns when a type only has a single constructor?
13:36:35 <Cale> knrafto: not always
13:37:20 <Cale> Sometimes it's better in terms of space to get the expressions into an evaluated form
13:37:47 <knrafto> explain
13:38:43 <knrafto> how would it save space?
13:39:13 <knrafto> less thunks?
13:39:14 <Cale> knrafto: Pattern matching is what causes evaluation to occur. Expressions exist at runtime, and can hold on to pointers to other things.
13:39:38 <Cale> Yeah, thunks are the datastructures which implement expressions at runtime.
13:40:13 <Cale> (but it's usually easiest just to think of them as expression trees or if you want to be really precise, expression graphs)
13:40:37 <knrafto> Okay, thanks
13:42:13 <Cale> It's really something which has to be treated on a case-by-case basis. Sometimes the lazy pattern match will be more efficient, or even make the difference between termination and nontermination, sometimes forcing the evaluation to occur a little sooner is desirable, usually to save space.
13:43:09 <gentleben> Anyone familiar with PlainPtr?
13:43:37 <gentleben> I want to make sure that I understand correctly that it does not have a finalizer
13:43:56 <Cale> data ForeignPtrContents
13:43:56 <Cale>   = PlainForeignPtr !(IORef [IO ()])
13:43:56 <Cale>   | MallocPtr      (MutableByteArray# RealWorld) !(IORef [IO ()])
13:43:56 <Cale>   | PlainPtr       (MutableByteArray# RealWorld)
13:43:59 <Cale> that one?
13:44:25 <gentleben> yes
13:44:33 <tdammers> what's the easiest way to control how a number is formatted when printing it as a string?
13:44:43 <gentleben> i am hunting a memory leak right now
13:44:50 <dolio> There are some weird corner cases, too. Like you might have an expression e that evaluates to (5, e'), where e' takes up a lot of memory. If every use of it looks like "fst e", then the garbage collector can be smart, and replace those expressions with 5, and collect e', freeing lots of memory.
13:45:05 <dolio> But it can only do that if it knows the evaluated form of e.
13:45:18 <gentleben> and if PlainPtr  does not have a finalizer, which seem to be indicated by both docs and code, then i have found it
13:45:30 <gentleben> but i wanted to check and make sure
13:45:34 <Cale> gentleben: It definitely seems that way
13:45:42 <gentleben> thanks
13:45:44 <Cale> but I'm not an expert on that part of GHC
13:45:51 <gentleben> yeah, me either
13:46:37 <Cale> gentleben: There's a comment which explicitly says that "It is not possible to add a finalizer to a ForeignPtr created with mallocPlainForeignPtr"
13:47:17 <tdammers> nm, found Text.Printf ;)
13:47:19 <Cale> and the result of mallocPlainForeignPtr is a ForeignPtr whose contents is a PlainPtr
13:48:54 <parcs`> tdammers: import Numeric
13:51:04 <nobdrais1ntone> Could someone remind what is a name of a book about lambda calculus with some comics with kitties on the cover?
13:57:11 <tdammers> parcs`: that would work too
14:02:54 <edwardk> nand`: bits now just takes max n 2 :)
14:04:43 <copumpkin> edwardk: we should probably put similar validation into toString, for bases above 62 or whatever it is
14:04:46 <copumpkin> :P
14:04:54 <edwardk> heh
14:05:26 <thoughtpolice> copumpkin: oh, that again? :)
14:05:45 <copumpkin> MPFR? :P yep
14:06:00 <thoughtpolice> copumpkin: btw, how functional would you say that old arm disassembler in your gh is? worth salvaging?
14:06:04 <copumpkin> it probably needs to be updated to use all the latest edwardk-isms
14:06:23 <thoughtpolice> oh, that was definitely on the roadmap
14:06:26 <thoughtpolice> :P
14:06:27 <copumpkin> thoughtpolice: oh, I mostly like it, except it isn't really usable yet. newsham was taking a look for a while
14:06:40 <copumpkin> thoughtpolice: I was planning on restructuring it a bit but I can't remember how
14:07:39 <reinoud> seen colah*
14:07:47 <thoughtpolice> copumpkin: and it uses she :)
14:07:56 <reinoud> hmm... no presence bot around :-(
14:07:58 <copumpkin> nothing wrong with SHE
14:08:04 <thoughtpolice> copumpkin: no, i like it
14:08:08 <copumpkin> reinoud: most of them don't respond to commands like that
14:08:25 <copumpkin> but yeah, preflex seems to be gone
14:08:28 <copumpkin> as does mauke
14:08:58 <thoughtpolice> copumpkin: i'm playing around with the idea of implementing courgette, and i wanted to prototype some of the basic ideas in haskell before anything, so i was wondering how much work an ARM version would be
14:09:12 <thoughtpolice> given that the number of programmable ARM devices i have now is rather substantial :P
14:09:45 <copumpkin> http://www.chromium.org/developers/design-documents/software-updates-courgette that?
14:09:48 <thoughtpolice> yeah
14:09:59 <copumpkin> ah
14:10:03 <copumpkin> that'd be cool
14:10:04 <thoughtpolice> the code is available but it's pretty crazy and really embedded into the chromium source tree
14:10:15 <copumpkin> charm needs some work :)
14:10:28 <copumpkin> but I think it has potential! and I've already put a fuckton of work into it
14:10:28 <thoughtpolice> i'd inevitably like to have a portable C implementation (there's some basic stuff) but i'm prototyping everything first
14:10:33 <copumpkin> it's just a high-commitment project :P
14:10:38 <thoughtpolice> copumpkin: i can tell, and yes, it is
14:10:40 <copumpkin> and I'm at a low-commitment point
14:11:10 <thoughtpolice> copumpkin: well i'm gonna need you to fix that, like
14:11:12 <thoughtpolice> right meow
14:11:24 <copumpkin> hah okay
14:11:35 <Rc43> Anybody knows function for splitting by multiple separators `Eq a => [a] -> [a] -> [[a]]` ?
14:11:40 <copumpkin> I still need to finish edwardk's proof while he goes off and does insane things with mpfr now
14:12:03 <edwardk> heh. the proof for the lca code?
14:12:14 <copumpkin> yeah :P
14:12:20 <nand`> Rc43: http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html#v:splitOn
14:12:21 <edwardk> would be handy =)
14:12:31 <nand`> oh, or splitOneOf
14:12:35 <edwardk> i should probably write that up as a pearl
14:12:48 <copumpkin> that'd be fun
14:12:52 <copumpkin> or you could just write it in perl
14:13:04 <Rc43> nand, thank you
14:13:05 <edwardk> dadum*ching*
14:13:12 <thoughtpolice> edwardk: a pearl, lol. i still think you win the award for 'take a pearl that oleg wrote and condense it into a 15 line module' (re: reflection)
14:13:21 <edwardk> thoughtpolice: =)
14:13:32 <edwardk> well, most of that module is documentation ;)
14:13:34 <Yiq> how would i get out of the TM (Maybe AuthUser)? TM is a data TM a and is an instance of Monad.
14:13:35 <thoughtpolice> there needs to be some kind of nice plaque you get for doing that
14:13:48 <edwardk> and elliott should share the plaque
14:14:07 <edwardk> nand`: when you said 'splitOneOf' i thought you wanted a lens combinator ;)
14:14:13 <DMWIT> Yiq: Very much depends on what TM is. Generally speaking, the Monad interface does not provide enough "stuff" to "get out".
14:14:17 <DMWIT> (on purpose)
14:16:02 <typoclass> Yiq: you generally take the (pure) functions that do something with your Maybe AuthUser and put them *in* your TM thingy. you don't usually get stuff out of it
14:16:06 <Yiq> it took me 2 minutes to install and use the python twitter api. in haskell i dont get anywhere
14:16:19 <Rc43> Hmm, why `cabal install split` gives me split-0.1.4.2 instead split-0.2.0.0?
14:16:27 <Yiq> typoclass: but i want to see what i got
14:16:29 <Rc43> *instead of
14:16:29 <applicative> Yiq: unTM yiq is a function from TMEnv to IO whatever
14:16:45 <donri> Rc43: have you done cabal update+
14:17:07 <DMWIT> Yiq: Dang, two minutes. That's a long time.
14:17:08 <Rc43> donri, it's fresh haskell platform, but I will try
14:17:26 <Yiq> where did you find unTM?
14:17:27 <typoclass> Yiq: have you tried "user <- (expression that gives you the TM (Maybe AuthUser))" ?
14:17:52 <copumpkin> unTM is probably not what you want
14:17:55 <Rc43> donri, it works, thanks
14:18:11 <Yiq> DMWIT: well more like 1min
14:18:21 <DMWIT> Wow, even longer.
14:18:24 <Yiq> typoclass: that didnt work
14:18:29 <typoclass> Yiq: you can then go on with case user of Nothing -> ... ; Just u -> ...
14:18:44 <DMWIT> Yiq: Have you looked in the documentation?
14:18:45 <reinoud> copumpkin: on #reprap it works like that :) so i had hopes here too
14:18:45 <typoclass> Yiq: put the code that you have on hpaste, along with any error messages you're getting
14:19:40 <DMWIT> (If the package is twitter-enumerator, then I'm looking in the documentation, and it's very helpful. Try clicking "ReaderT".)
14:20:02 <DMWIT> (...in fact, you don't even need to click. They've re-exported the relevant functions below.)
14:21:56 <Yiq> Terrile design choice 1. letting you login and not saying if it succeeds or not
14:22:41 <Rc43> Can I combine splitting strategies in `split` ? I want to split string by any of words from list.
14:23:05 <Rc43> Before I have used `parsec` for it, but it seems it is better to do it simplier.
14:23:52 <typoclass> Yiq: where? which package?
14:24:34 <donri> Rc43: can't you just use "oneOf" for that
14:25:17 <Rc43> donri, I need [a] -> [[a]] -> [[a]].
14:25:29 <Rc43> (string -> [string] -> [string])
14:25:56 <Rc43> oneOf gives me only [a] -> [a] -> [[a]]
14:26:30 <gentleben> Cale: Yeah I saw that. I just wanted a second opinion as this is a leak in attoparsec. Its going to touch quite a few people
14:29:58 <hpaste> Yiq pasted “twitter” at http://hpaste.org/74197
14:31:06 <Yiq> +why cant i construct with M.TM? i cant patternmatch like so: M.TM (Just x)
14:31:30 <DMWIT> Because TM isn't a constructor of the TM type.
14:32:23 <DMWIT> Seriously, though: did you read the documentation?
14:32:31 <Yiq> yes
14:32:35 * hackagebot darcs 2.8.2 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.8.2 (GaneshSittampalam)
14:32:57 <Yiq> TM doesnt have a constructor?
14:33:04 <DMWIT> Not a public one, no.
14:33:38 <DMWIT> I now know you are using hs-twitter, not twitter-enumerator; however, my conclusion stands: the documentation is very helpful.
14:33:43 <DMWIT> You should try reading it again.
14:34:10 <DMWIT> Hint: look for a function which takes a TM foo as an argument and doesn't return a TM bar as a result.
14:35:00 <Yiq> i find haskell docs to be terrible generally. people use short cryptic names to spare 4-5 chars and rarely(here it is decently docked though, just missing more examples) any comments. its like people have never used other peoples code and expect others to just "get" their code liek they wrote it themselves
14:35:10 <djcoin> Hi all !
14:36:10 <DMWIT> even more hints because I feel like I was being grumpy before: http://hackage.haskell.org/packages/archive/hs-twitter/0.2.8/doc/html/Web-Twitter-Monad.html#v:runTM
14:37:55 <ddarius> DMWIT: What's wrong with being grumpy?
14:37:57 <typoclass> Yiq: you're right that haddocks are often pretty poor, in my opinion that's the biggest drawback of haskell. i can't figure out the hs-twitter package either
14:39:02 <Sculptor> i didn't expect haskell to be that immense
14:39:02 <djcoin> I have a question regarding Monad (I'm beginning Haskell but i'm fluent in javascript/python and did a bit of ocaml, whatever :) ). I was wondering if you could define a Monad from a multiparameter type. I know this is possible (ie: Reader Monad with e -> a). But in fact I want the "contained" structure in my monad to have at least 3 'fields' with type a b c for example.
14:39:08 <mcstar> hey
14:39:31 <mcstar> i have yet another stupid question
14:39:35 <djcoin> Sorry if my question is a bit irrelevant - and I guess you must have a lot of monad related question :| -
14:39:38 <DMWIT> djcoin: Currently, all monads must take their contained type as their last argument.
14:39:46 <DMWIT> err
14:39:47 <DMWIT> all Monads
14:40:19 <djcoin> DMWIT: Thanks a lot for your reply - I saw that as the compiler yelled at me :)
14:40:44 <djcoin> But is there a way to "constraint" the contained structure or whatever to have "3 parts"
14:40:47 <mcstar> is it possible, for a function to take a value constructor as argument, and for example, pattern match on it? is there something similar?
14:40:50 <djcoin> It may be obivous
14:40:51 <parcs`> it's three years old
14:40:53 <DMWIT> djcoin: I don't understand the question.
14:40:54 <djcoin> obvious *
14:40:58 <parcs`> you probably shouldn't be using the package
14:41:18 <DMWIT> djcoin: No, I do understand the question now.
14:41:28 <DMWIT> djcoin: The answer is no: a Monad must be able to contain values of any type.
14:41:41 <DMWIT> djcoin: However, you're free to define a different typeclass that isn't so restrictive.
14:41:44 <djcoin> Sorry, I will give an example. For fun I was defining a type "Battle a b c = { result: a, team1: b, team2: c}
14:42:00 <typoclass> parcs`: who?
14:42:17 <parcs`> typoclass: anybody
14:42:17 <DMWIT> mcstar: Yes, one moment while I find my StackOverflow answer about this.
14:42:25 <mcstar> k, thanks
14:42:55 <DMWIT> mcstar: http://stackoverflow.com/q/11336687/791604
14:43:15 <typoclass> parcs`: i meant to ask who you're addressing and what package you're referring to
14:43:20 <djcoin> DMWIT: thanks a lot, that is what I thought too. Does a typeclass will "constraint" the structure ? (I will try out by myself but as I'm beginning haskell do not see exactly yet what you meant :))
14:43:28 <Yiq> the runTM takes a TM a, that doesnt help me when thats what i want to get
14:43:35 <DMWIT> ?src Monad
14:43:35 <lambdabot> class  Monad m  where
14:43:35 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:43:35 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:43:35 <lambdabot>     return      :: a -> m a
14:43:35 <lambdabot>     fail        :: String -> m a
14:44:10 <DMWIT> djcoin: The type of "return" (for example) constrains very much what types "m" may instantiate this class: because it is so polymorphic, it must be able to contain anything.
14:44:26 <parcs`> typoclass: hs-twitter is three years old which is a very long time in haskell years and in "website api" years -- the package should not be used
14:45:01 <mcstar> DMWIT: bit of a long article, il sketch my case for you, so y ou could tell me how relevant that is, ok?
14:45:02 <DMWIT> djcoin: A less polymorphic class might have, say, "class Foo m where lessConstrainedReturn :: (a, b, c) -> m (a, b, c)" if you want to allow "m"s to only contain things with three or more kinds of things in them.
14:45:03 <typoclass> parcs`: right, i see. do you have a suggestion for a replacement?
14:45:08 <djcoin> DMWIT: oh i see when you meant different typeclass, you were telling me of dropping the monad typeclass for an other one ?
14:45:15 <DMWIT> yes
14:45:22 <djcoin> s/of dropping/to drop
14:45:30 <djcoin> Sorry for my english :\
14:45:55 <djcoin> DMWIT: all right, thanks a lot. Well my point was to meditate on the power of monads with a fun example
14:46:02 <djcoin> I will see then :)
14:46:05 <djcoin> Thanks a lot
14:46:08 <djcoin> again
14:46:56 <parcs`> typoclass: nope
14:47:34 <mcstar> so, i have a data Some = A Int | B Int | C Int, and i have a list of Some, but only with the first 2 constructors. now i want a function, that maps over the list, and provided a contructor A or B, will transform all the A int or B int to C int in the list, leaving the oppsite contructor unchanged.
14:47:37 <mcstar> DMWIT: ^^
14:47:52 <kane77> any recommendations for books to read? not necessarily on haskell, but on (functional) programming etc..
14:48:11 <Nereid> mcstar: first write a function that does it for one Some
14:48:24 <mcstar> why?
14:48:46 <Nereid> because it's easier and you can use map to make it work on a list.
14:48:50 <Nereid> unless I'm misunderstanding you.
14:48:57 <mcstar> im not a total newbie
14:49:13 <mcstar> i just dont want a bool-like variable given to the function to decide what to do
14:49:23 <DMWIT> mcstar: I agree with Nereid, for what it's worth. Why pass in A or B instead of passing in a function a2c or b2c?
14:49:24 <mcstar> instead i want to decide on the data constructor
14:49:24 <Yiq> ok got something working now
14:49:28 <mcstar> since its already there..
14:49:47 <Nereid> mcsmash: so you want like [A 1, B 2] to go to [C 1, C 2]?
14:49:53 <mcstar> no
14:49:57 <Nereid> then I'm misunderstanding you.
14:50:01 <Nereid> or you are being unclear.
14:50:05 <Nereid> ??
14:50:07 <DMWIT> No, he's being clear.
14:50:12 <DMWIT> You're just not reading carefully.
14:50:13 <mcstar> translate [A 1, B 2] A = [C 1, B 2]
14:50:17 <Nereid> oh.
14:50:18 <mcstar> translate [A 1, B 2] B = [A 1, C 2]
14:50:41 <SHACHAF> mcstar: Have you considered data Some = Some Tag Int; data Tag = A | B | C?
14:50:42 <DMWIT> I'll ask again: why not translate [A 1, B 2] a2c = [C 1, B 2]?
14:51:05 <SHACHAF> But DMWIT's solution suggestion seems reasonable.
14:51:09 <SHACHAF> (hi DMWIT!)
14:51:17 <DMWIT> (hi SHACHAF!!1!)
14:51:47 <mcstar> id need to write a2c and b2c
14:51:54 <DMWIT> yep
14:52:05 <mcstar> i was wondering if there some neat solution
14:52:09 <mcstar> is*
14:52:15 <parcs`> what SHACHAF said
14:52:24 <DMWIT> what the StackOverflow answer said
14:52:36 * hackagebot lens 2.6.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-2.6.1 (EdwardKmett)
14:52:44 <parcs`> there's also
14:52:51 <jaredj> why do the famous people have LOUD NAMES
14:52:55 <ddarius> DMWIT: tl;dr just tell me
14:52:58 <SHACHAF> mcstar: Perhaps if you provided more context people would be able to provide a better solution.
14:53:07 <mcstar> wthats all the context
14:53:10 <mcstar> literally
14:53:14 <mcstar> my 2 lines
14:53:25 <ddarius> DMWIT: Your response was tl;dr
14:53:44 <SHACHAF> As it is, Unicode silly question, get a silly Consortium.
14:53:56 <DMWIT> I know. If four lines of code is too much to write, then surely 14 pages of conference paper is too much to read. =/
14:54:02 <hpaste> typoclass annotated “twitter” with “twitter (annotation)” at http://hpaste.org/74197#a74205
14:54:21 <DMWIT> jaredj: The question is: do you want to be known as FAMOUS or not??
14:54:26 <mcstar> SHACHAF: i considered your solution, but i want to make it easy to construct the values of Some
14:54:28 <djcoin> Web.Twitter.Monad damn. I'm just beginning Haskell. Is this a joke ? :)
14:54:30 <typoclass> Yiq: ^^ this works for me, somewhat. i don't have a twitter password handy, however
14:54:31 <djcoin> huhu
14:54:43 <mcstar> SHACHAF: Some A 1 creates a value of Some, vs. A 1
14:55:12 <mcstar> SHACHAF: i liked the simplicity of the latter, because possibly ill have to type in the data
14:55:29 <Nereid> Some A 1 is an error.
14:55:33 <mcstar> i think ill make a new constructor function for Some A, Some B...
14:55:43 <Nereid> unless you mean the tag version
14:55:44 <mcstar> why?
14:55:44 <SHACHAF> a :: Int -> Some 1; a = Some A
14:55:47 <mcstar> ofc
14:55:54 <SHACHAF> s/ 1//
14:56:02 <Nereid> a = Some . A
14:56:04 <Nereid> er
14:56:05 <Nereid> oops.
14:56:07 <mcstar> SHACHAF: yes, like i said above
14:56:12 <mcstar> i thnk ill do that
14:56:13 <Nereid> ignore everything I say forever.
14:56:18 <SHACHAF> What?
14:56:26 <mcstar> 'i think ill make a new constructor function for Some A, Some B'
14:56:27 <edwardk> clearly i gave up my fame and returned to relative anonymity when i lowercased my nick once more
14:56:36 <jaredj> who's this guy
14:56:37 <_CUCK_> bonsoir
14:56:55 <DMWIT> edwardk: pfft, newb
14:57:26 <mcstar> DMWIT: i promise, ill read in that paper on a quiet day
14:57:27 <hum> whats the correct name of the -> operator in haskell's type signatures ?
14:57:31 <SHACHAF> Don't be intolerant, DMWIT.
14:57:46 <ddarius> hum: ->
14:57:47 <SHACHAF> hum: "*grunt*" is how I pronounce it.
14:57:57 <SHACHAF> Hmm, that's how I pronounce all of them, though.
14:58:00 <typoclass> djcoin: nope :-/ but "monad" is just a goofy name for, handwavingly, a list of commands or list of closures (you've probably come across them in javascript)
14:58:29 <hum> ddarius, SHACHAF thx
14:58:37 <parcs`> minus greater-than
14:58:57 <SHACHAF> →
14:59:03 <DMWIT> hum: -> is the type constructor for function types, somtimes called arrow (=> is double-arrow), and pronounced "to"
14:59:04 <SHACHAF> RIGHTWARDS ARROW
14:59:05 <Botje> hum: or you can call it 'to'. 'a to b to pair of a, b'
14:59:13 <typoclass> hum: i pronounce it "to", as in "a function which maps a to b" ("a -> b")
14:59:14 <SHACHAF> "implies"
14:59:19 <DMWIT> Ignore these unhelpful jerks. ;-)
14:59:24 <Rc43> Is there monad transformer for (->r)  and [] ?
14:59:29 <parcs`> > ord "→"
14:59:30 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:59:30 <lambdabot>         against inferred type...
14:59:31 <SHACHAF> Hmm, I should pronounce it "implicates".
14:59:35 <DMWIT> Rc43: ReaderT and LogicT
14:59:35 <Nereid> Rc43: ReaderT and ListT
14:59:38 <SHACHAF> Rc43: ReaderT and not in the standard library.
14:59:40 <DMWIT> Don't use ListT
14:59:42 <Nereid> oh
14:59:43 <mcstar> SHACHAF: or, there is another solution: give the function an argument of the type constructor full applied with some bogus value
14:59:51 <Nereid> well whatever is right should be called ListT.
14:59:52 <DMWIT> ...unless you know the underlying monad is commutative (most aren't).
15:00:03 <mcstar> fully*
15:00:10 <Rc43> DMWIT, why not ListT?
15:00:33 <DMWIT> Rc43: If m is a monad, but not a commutative monad, then ListT m is not a monad.
15:00:35 <Nereid> it's not strictly a monad transformer.
15:00:38 <Nereid> yeah.
15:00:52 <Nereid> (it's almost, but not quite, associative.)
15:00:55 <SHACHAF> @google listt done right
15:00:56 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
15:00:57 <lambdabot> Title: ListT done right - HaskellWiki
15:00:59 <DMWIT> Moreover, most monads that are useful in Haskell are not commutative.
15:01:12 <Rc43> DMWIT, understood, thanks
15:03:04 <Rc43> DMWIT, hmm, but what is commutative monad? By which operation?
15:04:01 <Nereid> Rc43: exercise: implement swap :: m (m a) -> m (m a). the monad is commutative iff join = join . swap
15:04:10 <hum> i'm currently reading http://thread.gmane.org/gmane.comp.lang.haskell.cafe/40508/focus=40610 ... the conclusion sentence states "So you can see that depending on the forall's position with respect to
15:04:11 <hum> the ->
15:04:18 <hum> argh :-/
15:04:31 <mcstar> what a great way to end a sentence
15:04:35 <mcstar> ->
15:04:37 <Nereid> I should do this exercise myself.
15:04:38 <mcstar> continued
15:04:40 <SHACHAF> swap = id
15:04:42 <DMWIT> Rc43: http://www.haskell.org/haskellwiki/Monad#Commutative_monads
15:04:48 <SHACHAF> All monads are commutative.
15:04:58 <djcoin> typoclass: sorry i was away (related to "monad" twitter). But I guess it may be more than a goofy name, it is an (algebraic) datastructure shared accross all the code base. Does having monad (and other mathematical structure) really leverage their use (apart from knowing what a monad is and thus the ability to use it easily) ?
15:05:25 <hum> however .. i don't want to call it just -> isn't there a better word ?!
15:05:40 <SHACHAF> People gave you lots of words.
15:05:51 <Rc43> DMWIT, so (->r) isn't commutative and ListT won't help me, right?
15:06:01 <typoclass> hum: as i said, i call it "to"
15:06:07 <SHACHAF> I like "implicates". foo :: Int -> Char: "Char lets you represent surrogate code units! Criminal!!!"
15:06:08 <djcoin> ((and apart from their use in dealing with side effects)
15:06:14 <SHACHAF> (-- Int)
15:06:17 <Nereid> hmm.
15:06:20 <DMWIT> Rc43: (->r) isn't a monad, but (r->) is probably commutative
15:06:20 <SHACHAF> (++
15:06:30 <Nereid> Rc43: you probably meant to write (->) r
15:06:39 <typoclass> SHACHAF: what are you talking about ...?
15:06:48 <DMWIT> djcoin: The whole point of monads is their shared interface, so "apart from the ability to use it easily" is like saying "apart from the whole point, what's the point?".
15:06:54 <SHACHAF> typoclass: Maybe I should talk about it in the other channel.
15:07:00 <typoclass> (... oh, a pun on 'implicates', i see)
15:07:03 <Rc43> DMWIT, Nereid, yes, you are right
15:07:23 <djcoin> DMWIT: I meant not easily, but common knowledge
15:07:38 <Rc43> DMWIT, but why (->) r is commutative? f . g . h /= f . h . g
15:07:49 <DMWIT> Bind is not function composition.
15:07:50 <djcoin> Like, you have the ahem Factory Pattern, and anyone know what it's supposed to be when they see this name
15:08:02 <mcstar> ouch
15:08:02 <djcoin> in oop
15:08:13 <SHACHAF> djcoin: I don't.
15:08:31 <mcstar> apparently ppl dont get oo design patterns right
15:08:38 <DMWIT> Also, I think this wiki page is wrong. I'm going to fix it.
15:08:42 <mcstar> a monad on the other hand is much simpler
15:09:09 <Rc43> DMWIT, `a <- f` for (->) r is just intermediate result?
15:09:22 <mcstar> <- is syntax
15:09:24 <Rc43> (I mean, variable a takes intermediate result)
15:09:25 <djcoin> Yeah :) And I on the other hand, don't have much knowledge yet in monads, to see all the benefits (which are guess are really great). Just being .. curious
15:09:30 <Ralith> SHACHAF: why are you capital?
15:09:36 <typoclass> djcoin: not sure what you mean by 'leverage'. in my opinion Monad is a typeclass that has 3-4 functions, there's various instances (IO, lists, Maybe, ...), it's used a fair bit. end of story, as far as i can tell :)
15:09:54 <SHACHAF> Ralith: A better question is: Why aren't you?
15:09:59 <Ralith> :O
15:10:01 * Ralith existential shock
15:10:06 <djcoin> x)
15:10:07 <DMWIT> Rc43: Your question is not precise enough to have a meaningful answer.
15:10:09 <merijn> djcoin: The main advantage is that there's lots of very generic monad code, which means that when I write code dealing with monads it's usually 80-90% just calling existing library functions to write my programs
15:10:32 <Rc43> DMWIT, I am sorry, I didn't see your msg about function composition
15:10:42 <merijn> djcoin: I have done C, Java, Python and some other languages and I've never seen the amount of code reuse that typeclasses like monad allow you to have
15:10:43 <djcoin> merijn: composability then
15:10:50 <merijn> djcoin: Definitely
15:10:52 <Nereid> yeah I guess I was wrong again. :v
15:11:14 <DMWIT> Step one: be wrong a lot. Step two: be right a lot.
15:11:26 <merijn> djcoin: Take a look at (for example) the monad-loops package
15:11:28 <djcoin> I'm really curious about this datastructure and how it can be so generic it can be bend and usefull in lots of cases without too much limitation
15:11:38 <SHACHAF> djcoin: "Monad" isn't a data structure.
15:11:40 <SHACHAF> It's an API.
15:11:44 <mcstar> not a data structure
15:11:48 <djcoin> Yeah, sorry :)
15:11:48 <merijn> djcoin: It's not really a data structure, it's an API for data structures
15:12:04 <djcoin> I did meant that .. NoooOOo
15:12:04 <merijn> djcoin: Do you understand typeclasses already?
15:12:05 <djcoin> :)
15:12:14 <SHACHAF> djcoin: I recommend not worrying about it.
15:12:15 <djcoin> Yep, I see what they mean
15:12:19 <SHACHAF> djcoin: Read the FAQ entry on it:
15:12:21 <SHACHAF> @where faq
15:12:21 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:12:35 <djcoin> Monad is a typeclass requiring bind and return
15:12:41 <merijn> djcoin: The most useful thing to do then is to take a look at the Maybe, Either a and list monads
15:12:44 <SHACHAF> Do you understand not just type classes but type classes of kind * -> *?
15:12:53 <typoclass> djcoin: yup, you're on the right track there
15:13:00 <DMWIT> djcoin: 1995: "Dang, I use all these things, and they have this crazy thing in common." 2012: "Wow, why is this crazy thing such a good generalization of so many things?"
15:13:03 * SHACHAF sighs because djcoin isn't going to read the FAQ.
15:13:06 <djcoin> SHACHAF: Compiler yelled at me because I was trying to give him * -> * -> *
15:13:23 <djcoin> I understand only i had to fed him one only type
15:13:35 <merijn> djcoin: Actually, if you already understand typeclasses you might as well go straight to the source
15:15:05 <merijn> djcoin: "Monads for Functional Programming" by Wadler is the paper that introduced monads as programming tool and the paper is quite readable and deals with three examples (an interpreter, state monad and IO)
15:15:15 <mcstar> djcoin: on a meta level id compare monads, as a feature of haskell, to classes as a feature of some other language, it lets you abstract things away. with classes, you can build object hierarchies, and polymorphism, with monads, you can build composition of stuff
15:15:18 <djcoin> merijn: yeah thanks for the input. I have taken the habit to not be so afraid/shy and to go to the source more quickly everytime
15:16:16 <djcoin> merijn: thanks for the pointer, I got this paper and read half of it. I left it to play with haskell. I have to pick it back
15:16:17 <merijn> djcoin: Well, I actually meant the paper introducing them, rather than source code source, but the source code is also pretty readable, so it can't hurt :p
15:17:04 <djcoin> mcstar: but to build composition everything has to be "lift" up to a monad thing ?
15:17:20 <mcstar> yes
15:17:24 <merijn> djcoin: There's also the blog post "You could've invented monads! (and maybe you already have)", which explains by way of having you come up with several different monads to implement
15:17:38 <mcstar> djcoin: only a monad composes with a monad
15:17:55 <DMWIT> Monads do not compose. That is why monad transformers exist.
15:17:59 <mcstar> but there are monad transformers of which i know nothing about
15:18:00 <djcoin> yeah but they must be of the same type too
15:18:00 <merijn> djcoin: Once you've seen a handful you'll slowly see how general the interface is
15:18:01 <djcoin> ?
15:18:16 <mcstar> DMWIT: i meant within the same type of monad
15:18:31 <Yiq> so is math invented or discovered?
15:18:42 <DMWIT> mu
15:18:42 <typoclass> djcoin: check out the source of Control.Monad.Instances, for me it was an absolutely clear answer to several issues i'd been having
15:18:44 <djcoin> discovered :)
15:19:08 <djcoin> typoclass: thanks a lot
15:19:15 <edwardk> typoclass: Control.Monad.Instances should be empty now ;)
15:19:30 <typoclass> er what ...
15:20:47 <djcoin> I'm kinda impatient to understand other "structure" like arrows and such and bend my mind (lenses and stuff)
15:21:04 <djcoin> Huge to learn
15:21:12 <merijn> The structure of lenses breaks my brain (at least, edwardk's lenses :p)
15:21:19 <merijn> but using lenses is pretty damn easy
15:21:22 <mcstar> it is not like you have to know all these to get stuff done
15:21:25 <typoclass> Yiq: just a reminder, i annotated the paste you made with a minimal example of how to use that twitter package you had
15:21:45 <geoffh> ls
15:21:49 <mcstar> . ..
15:21:49 <djcoin> mcstar: yeah, it's kinda daunting
15:21:50 <edwardk> i think the main thing i want to work on for the next release of lens is adding more examples
15:21:55 <typoclass> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad-Instances.html <- latest still has it
15:21:57 <DMWIT> djcoin: To learn lenses: http://twanvl.nl/blog/haskell/overloading-functional-references
15:22:08 <DMWIT> (Admittedly, not edwardk's interface to lenses, just the underlying ideas.)
15:22:18 <djcoin> DMWIT: thanks a lot :)
15:22:21 <mcstar> djcoin: i think most of these guy are doing this for years
15:22:28 <merijn> edwardk: I think what'd mostly help is not so much examples, but examples in the form of less general type signatures
15:22:33 <djcoin> I saw it was a cute getter/setter. It's fun
15:22:35 <mcstar> s*
15:22:54 <edwardk> merijn: i put on average 4 versions of the type signature on each function ;)
15:23:40 <typoclass> edwardk: examples are great, thanks a lot
15:24:13 <merijn> edwardk: For example, when I read "uses :: MonadState a m => Getting e a c -> (c -> e) -> m e" and look up "type Getting r a c = (c -> Accessor r c) -> a -> Accessor r a" my brain just goes "screw this, I'm gonna think about pretty pictures instead" :p
15:24:48 <SHACHAF> merijn: You only need to understand a type like "Getting" once.
15:25:19 <merijn> (Although admittedly, if I just ignore the whole "Getting e a c" part it becomes pretty readable)
15:25:23 <edwardk> merijn: http://ekmett.github.com/lens/Control-Lens-Getter.html#v:uses there are 5 type signatures you can think of uses as having written right underneath it
15:25:31 <edwardk> uses :: MonadState a m             => Getter a c           -> (c -> e) -> m e
15:25:31 <edwardk>  uses :: (MonadState a m, Monoid r) => Fold a c             -> (c -> r) -> m r
15:25:32 <edwardk>  uses :: MonadState a m             => Simple Lens a c      -> (c -> e) -> m e
15:25:33 <edwardk>  uses :: MonadState a m             => Simple Iso a c       -> (c -> e) -> m e
15:25:34 <edwardk>  uses :: (MonadState a m, Monoid r) => Simple Traversal a c -> (c -> r) -> m r
15:26:19 <edwardk> Getting is hard. This is why i put all the extra signatures in the source file so you can see how to think of it
15:26:19 <typoclass> so a 'Getter a c' is a thing that can get you a 'c' out of an 'a'?
15:26:22 <merijn> I guess I should maybe actually study the diagram first instead of just using them and figuring the type system will save my ass :p
15:26:24 <mcstar> how does these things affect compilation times?
15:26:25 <DMWIT> edwardk: This is probably going to blow your mind, but... those are still way too polymorphic for some people to grasp. =)
15:26:26 <edwardk> typoclass: yes
15:26:52 <merijn> DMWIT: Crazy talk!
15:26:56 <edwardk> a Fold knows how to get multiple c's
15:27:04 <edwardk> DMWIT: this is why i want to add more examples
15:27:09 <DMWIT> right
15:27:11 <DMWIT> I endorse this message.
15:27:12 <typoclass> edwardk: nice. fwiw, i understand that "Getter" signature rightaway, with no prior exposure to the lens package
15:27:32 <edwardk> typoclass: now, the actual signature is:
15:27:33 <edwardk> uses :: MonadState a m => Getting e a c -> (c -> e) -> m e
15:27:40 <edwardk> Getting is more complicated =)
15:27:56 <edwardk> but by using Getting i can allow all those other 'fake' signatures to be valid.
15:27:57 <typoclass> yeah, 50% more complicated, it has 3 parameters
15:28:01 <merijn> edwardk: Although tbh I think Control.Lens obsoletes 40-50% of my program code, so with that in mind it's probably a good investment to learn the types anyway xD
15:28:08 <edwardk> well, the actual implementation is hard to follow
15:28:17 <edwardk> merijn: =)
15:28:34 <djcoin> What is "too polymorphic for some people to grasp" ? :)
15:29:04 <edwardk> djcoin: lots of my code is basically a soup of type variables, some people have a hard time grasping the meaning of lots of floating type variables
15:29:10 <merijn> djcoin: Well, did you understand what all the letters in those signatures meant? If the answer is "no" then that's your answer ;)
15:29:44 <edwardk> to me, i'm much much happier with type variables in a signature than concrete types
15:29:47 <mcstar> if im not mistaken, lenses try to solve something that the language should have
15:29:53 <djcoin> merijn: all right :) I was wondering if you were talking about those signatures. kk
15:29:53 <mcstar> or am i wrong?
15:29:56 <edwardk> with a type variable i know there is nothing hinky going on.
15:30:04 <merijn> mcstar: Control.Lens is *so much* more than that
15:30:34 <edwardk> mcstar: 'lens' provides lenses, getters, traversals, indexed containers, etc. its a lot more than just a lens type which would be encapsulated in some kind of record proposal
15:31:10 <mcstar> ok, ill keep it in mind
15:31:18 <edwardk> arguably, perhaps a functional reference type should be included in a record proposal, but lens is about showing that you can compose functions like 'traverse'.
15:31:29 <edwardk> and that the result of the composition is useful
15:31:55 <edwardk> and it is a different way to design a class hierarchy, where you don't use a lot of random lifting operations to get the intersection of complex functionality
15:32:42 <edwardk> e.g. you can just take an isomorphism like 'packed' and flip it, or compose it with (.) and get another traversal or lens based on what you compose it iwth
15:32:43 <djcoin> edwardk: lens seems so 'simple', so composable, that you must achieve crazy stuff
15:32:46 <djcoin> :)
15:33:18 <edwardk> there were a lot of jokes in here about how most of the functions in lens are just variations on 'id' when i started putting it together ;)
15:33:47 <djcoin> I had an other question regarding monads. There are a hell lot of function calls. Some call monads 'programmable semicolon' but in performance term, it's kinda far I guess. Even if I'm not worried about performance, can it be a problem ? Can the Haskell compiler "optimize" those repeated calls ? Just curious again
15:34:30 <edwardk> ghc does a crazy amount of inlining and code motion relative to literally every other compiler on the planet.
15:34:32 <merijn> djcoin: The joke of "programmable semicolon" comes from do-notation
15:34:41 <edwardk> i wouldn't worry about performance until something becomes too slow
15:34:52 <edwardk> then there are plenty of tools to make it faster ;)
15:35:20 <SHACHAF> That's not a nice way to talk about the people in #haskell.
15:35:31 <Nereid> lol
15:35:35 <edwardk> i'm sorry shachaf, but you're a tool ;)
15:35:36 <merijn> djcoin: "do { foo; bar }" becomes "foo >> bar" (or, replacing the implementation of >> with >>=) "foo >>= \_ -> bar"
15:35:54 <djcoin> merijn: Yeah I know that already :)
15:36:12 <djcoin> What astound me is that you can use stuff like: let foo in bar
15:36:25 <mcstar> i had to read it 2x to get the joke, nice one btw
15:37:00 <djcoin> But the whole thing must be packed in an invisible function. Great
15:37:01 <djcoin> :b
15:37:30 <mcstar> there is let and case on the core level
15:37:36 <mcstar> let is lazy case is strict
15:41:34 <djcoin> Well thanks all for your answers (and all the fish) ! Got to go
15:41:47 <djcoin> Thanks again, ++
15:41:52 <Nereid> is there any difference between let p = a in b, and case a of ~p -> b ?
15:42:08 <hpc> Nereid: shouldn't be
15:42:16 <Nereid> yeah, I don't see any
15:42:31 <Peaker> layout/syntactic constraints, maybe
15:43:03 <Nereid> I mean semantically.
15:43:37 <mcstar> look at the core
15:43:41 <Nereid> heh.
15:44:13 <tromp_> i dont think the ~ matters in front of a plain variable
15:44:25 <Nereid> p is a pattern, sorry.
15:44:31 <tromp_> ok, then it matters:)
15:44:34 <hpc> tromp_: 'p' there is a wildcard for "some kind of a pattern"
15:44:44 <Peaker> I wish all product patterns were ~ automatically
15:45:09 <hpc> sometimes you want the strictness
15:45:10 <tromp_> then you cant distinguish multiple cases
15:45:19 <hpc> like with strict product types
15:45:35 <hpc> where matching on the (,) matches the insides too
15:45:44 <Peaker> and I wish sums needed some explicit "allow fail" when matched in a "let", lambda or left of "<-" -- rather than having a no-warn python-style runtime error
15:46:01 <Peaker> tromp_, product types only have 1 case
15:46:20 <Peaker> having product pattern matches be ~ automatically is essentially having unlifted products, I think
15:46:45 <tromp_> right you are
15:46:54 <Peaker> and if that were the case, there'd be no reason to have (,,) and (,,,) ... as they would be the same, semantically, as nested tuples
15:47:11 <Peaker> and probably lots of optimizations would become valid
15:50:22 <edwardk>  lens officially now has more lines of comments (4594) than code (4008)
15:50:50 <edwardk> this is a perversion of the natural order of things ;)
15:51:13 <hpc> clearly it should be 4008 lines of comments and 4594 lines of code
15:51:16 <Peaker> wow, 4KLOC.. we only have 7.9KLOC in bottle and we've been at it for many many months...
15:52:06 <edwardk> well, its 9616 if you just use wc -l
15:52:12 <mcstar> yeah, but you built on lenses to keep the loc count low :)
15:52:52 <Peaker> edwardk, I use cloc to count non-blank/non-comment lines
15:53:14 <edwardk> installing
15:53:37 <mgsloan> according to sloccount, lens is estimated to cost $150,000
15:53:46 <mgsloan> oh cocomo, you so silly
15:54:10 <mgsloan> (not that isn't worth quite a bit!)
15:56:15 <mgsloan> also, if you include examples / tests / benchmarks, I'm getting 5083 LOC
15:57:09 <edwardk> @hpaste
15:57:09 <lambdabot> Haskell pastebin: http://hpaste.org/
15:57:25 <hpaste> edwardk pasted “lens cloc” at http://hpaste.org/74213
15:58:08 <Peaker> edwardk, quite large
15:58:18 * mgsloan guesses that the number of blanks is close to the number of functions ;)
15:58:50 <edwardk> sloccount thinks its about twice as valuable as 'ad'. hrmph ;)
15:59:09 <edwardk> but not quite as valuable as algebra
15:59:32 <hpc> measuring code by lines is like measuring airplanes by weight
15:59:34 <edwardk> testing my entire haskell folder
15:59:36 <edwardk> yes
15:59:40 <hpc> :P
16:00:16 <Peaker> hpc, unless you know the code style to be good, then comparing two good-styled bases may make sense
16:00:42 <Peaker> maybe comparing projects by the same author in the same language can give you a good perspective on their relative sizes
16:00:46 <edwardk> i agree its a crap metric
16:00:47 <edwardk> apparently sloccount thinks the code i've generated in the last two years is $5,784,720 worth of effort.
16:01:16 <hpc> i wish i made that kind of money with my code
16:01:24 <edwardk> assuming i was willing to take only $56k/year of salary
16:01:50 <edwardk> and ignoring all the scala code that is in another folder ;)
16:02:00 <edwardk> er and my gpu work
16:02:16 <edwardk> ok, cute ego boost. now how to monetize it ;)
16:02:21 <Saizan> how many lines of code a day does sloccount considers?
16:02:40 <mgsloan> why, 1 KLOC / mo of course! what else?
16:03:17 <Sculptor> including full line comments ;)
16:03:44 * typoclass . o O ( a line of code probably should be worth more dollars the more often it is used. which i don't think that tool can figure out. )
16:03:53 <edwardk> well it seems to consider it 166kloc, 42.82 person years
16:04:07 <tibbe> edwardk: around?
16:04:07 <edwardk> so back into it from there
16:04:14 <edwardk> tibbe: yeah
16:04:47 <Ralith> hm, arch's ghc package has its own libffi, and built binaries try to link against system FFI and fail
16:04:49 <mgsloan> typoclass: I think it's attempting to measure cost to produce (by very very bad coders, apparently), rather than actual value
16:04:50 <Ralith> wtf
16:05:04 <tibbe> edwardk: have you ever seen an AST that rewrites expressions that refer to the same variable e.g. (Add (Var "x") 1, Add (Var "x") 2)
16:05:10 <Sculptor> so you wrote 42 person years of code in two years, edwardk
16:05:26 <tibbe> edwardk: I'd like to rewrite the Vars but a normal tree walk seems to make that hard, as I might not see both Adds at the same time.
16:05:28 <edwardk> Sculptor: apparently. not counting all the other code i wrote ;)
16:05:30 <mgsloan> edwardk: imagine pressing the enter key 166 thousand times.  Now imagine typing something meaningful between each one.  That's a lot!!
16:06:21 <edwardk> tibbe: you want to rewrite them to what?
16:06:59 <tibbe> edwardk: let me give you the real example: I want to rewrite (map f xs, map f xs) to (unzip (map (f *** g) xs))
16:07:21 <tibbe> edwardk: but the two map calls might of course occur anywhere in the AST, not necessarily in a pair like that.
16:07:29 <edwardk> ah, it can be tricky to get that kind of rewrite rule to fire
16:07:53 <edwardk> fortunately you have no lambdas to get in the way
16:08:07 <edwardk> so you can probably do a lot more optimization than usual
16:09:26 <edwardk> i'd probably go looking for all 'map' _ 'xs' calls in the syntax tree, see if there are any funny interdependencies, and then take the set of all of them that are fusable and smash them together, replacing them in the original call sites
16:09:29 <tibbe> edwardk: it seems easy to do that rewrite if I turned all the references in the AST around
16:10:10 <tibbe> edwardk: I will need something zipper like to remember the locations in the tree of the maps no?
16:10:42 <edwardk> just go find all the uses of 'map _ xs' and replace them with vars.
16:10:57 <edwardk> and retain the mapping from name var to what was being mapped ;)
16:11:01 <edwardk> then you cn substitute later
16:11:04 <edwardk> but i need to run
16:11:14 <tibbe> ah
16:11:15 <tibbe> thanks
16:22:00 <Lutin`> So I really really really want to start using vim after watching people code using it
16:22:10 <MattCodr> Hi all, please what would you recommend for an already programmer, but starting with FP and haskell? http://book.realworldhaskell.org/read/ or http://learnyouahaskell.com/chapters
16:22:46 <Lutin`> But I can't seem to get comfortable coding in Haskell in it yet, not sure if that's a #vim issue or a #haskell issue so I figured I'd see how you guys that use vim are setup
16:23:17 <LPVB> MattCodr: I'd say get the theory in with LYAH first
16:23:40 <LPVB> MattCodr: RWH is practical programming practice
16:24:52 <LPVB> Lutin`: Install Vundle first so you can install vim scripts easily off github
16:25:53 <MattCodr> LPVB, Thanks, and I already had started with this book, since I read this: "This tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java, Python ) but haven't programmed in a functional language before (Haskell, ML, OCaml )."
16:26:42 <LPVB> then you Just put Bundle "'gitusername/scriptname'" in .vimrc, and install https://github.com/ujihisa/neco-ghc https://github.com/dag/vim2hs https://github.com/Shougo/neocomplcache
16:27:03 <LPVB> and cabal install {ghc-mod,hlint}
16:28:10 <LPVB> MattCodr: It doesn't matter what imperative language you learned before if at all, because FP is very different and you will be constantly learning the FP way to do things
16:28:37 <Lutin`> Ah so
16:28:51 <Lutin`> I just update .vimrc then run :BundleInstall
16:28:57 <LPVB> yea
16:28:58 <Lutin`> And it git clones them?
16:29:02 <LPVB> yea
16:29:05 <Lutin`> Hot damn
16:29:08 <Lutin`> That is sexy
16:29:16 <MattCodr> LPVB, right, thanks!
16:29:29 <Lutin`> LPVB: what platform are you on?
16:29:39 <LPVB> linux x86_64
16:29:49 <Lutin`> What distro?
16:29:53 <LPVB> arch
16:31:27 <Lutin`> Ah yeah? That's what I've got on my VM right now
16:31:40 <Ralith> anyone have any idea why a haskell binary that links libffi might link the GHC one rather than the system one?
16:32:57 <LPVB> Lutin`: also, Bundle 'vim-scripts/indenthaskell.vim'
16:33:23 <Lutin`> What WM do you use?
16:33:39 <LPVB> xmonad ofc
16:33:57 <Lutin`> See I'm trying to ween myself off Windows
16:34:21 <Lutin`> Cause I need to stop gaming as much and focus on my studies and work and the only reason I stay on windows is gaming
16:34:49 <Lutin`> So I'm trying to setup the perfect VM setup first and then shift it over to a raw disk
16:34:58 <LPVB> Lutin`: A good way I deal with that is wipe drive and install linux
16:35:47 <barrucadu> Lutin`: I have Windows for games and Linux for everything else, I find simply being in Linux makes me want to play games less (although it doesn't help with other forms of procrastination) - simply because it's a little effort to change OS
16:36:10 <Lutin`> Well that's what I'm trying to accomplish
16:36:29 <Lutin`> But atm my desktop is down and all I have is this laptop and the largest external storage I have is 16GB
16:38:07 <mm_freak> i see no problems switching to linux entirely…  by now there are many linux games and most windows games run well in wine (sometimes with some winetricks applied)
16:38:52 <Lutin`> So far I get better battery life in Windows
16:39:11 <Lutin`> And in linux I don't have 802.11n
16:39:14 <mm_freak> Lutin`: install laptop-mode (called laptop-mode-tools in some distributions)
16:39:16 * timthelion cannot imagine switching back to windows.  No tiling windows...
16:39:31 <watermind> I'm using listings for Haskell code in LaTeX, and inline listings is eating away some spaces :S
16:39:33 <mm_freak> that daemon improved my laptop battery life from 3 hrs to 5 hrs
16:39:34 <hpc> timthelion: in 7, you can tile two windows side-by-side
16:39:35 <watermind> e.g.  \lstinline|reverse . reverse = id|
16:39:35 <barrucadu> mm_freak: I want to keep the games out of my partially-procrastination-free OS :P
16:39:52 <timthelion> hpc: How does that compare to xmonad's tiling ?
16:39:55 <watermind> there are no spaces between the compostion and no space on the right side of =
16:39:56 <hpc> and in 8, you can "tile" windows side-by-side at a horrible 4:1 ratio
16:40:00 <watermind> is this usual?
16:40:00 <mm_freak> barrucadu: it doesn't really matter whether you keep them in /mnt/windows or ~/.wine
16:40:03 <hpc> timthelion: just being pedantic ;)
16:40:09 <mm_freak> barrucadu: i have ~/win for everything that is windows
16:40:38 <barrucadu> mm_freak: At the moment I have to reboot into WIndows to play games, which is enough to stop me just firing one up when bored of working on something
16:42:30 <mcstar> regular exercise helps weening yourself off of gaming and procrastination
16:42:34 <mcstar> especially running
16:43:02 <Lutin`> Yeah running is just so easy
16:43:09 <mcstar> playing games too much is just too stupid
16:43:15 <Lutin`> I don't know why I don't do it more
16:43:25 <mcstar> you suspect this is so, but later, you will find out the hard way
16:43:29 <mcstar> be smart
16:47:04 <mm_freak> well, it's wrong to reject all games…  every game is mental training…  you just shouldn't exaggerate
16:47:11 <mm_freak> after all to many of us haskell is a game =)
16:47:26 <mcstar> i fall into the fps trap
16:47:34 <mcstar> believe me, it wasnt a mental exercise
16:47:59 <Lutin`2> Recently for me it's been RPGs
16:48:02 <Lutin`2> And Minecraft
16:48:15 <mcstar> (after a while you do it wo thinking, and with much cussing)
16:48:16 <parcs`> FPSes exercise your reflexes, teamwork, spatial reasoning, reverse psychology skills, etc
16:48:19 <clsmith> i find it very difficult to play games for any real length of time. i've managed to play a game regularly for maybe a week and a bit and then i just kinda stop. i'm not very good at watching tv either.
16:48:22 <timthelion> mm_freak: There is a problem with any online multiplayer game, which makes it fundimentally different from other forms of entertainment.  And that is that you likely "cannot" gettup to go pee.
16:48:23 <parcs`> they are not totally a waste of time
16:48:39 <Lutin`2> And FPSs
16:48:43 <clsmith> parcs`: the real world exercises your spatial reasoning :p
16:48:52 <mcstar> parcs`: you can acquire those same skills from outdoor team sports
16:48:56 <parcs`> the real world? isn't that a tv show? :)
16:49:07 <mcstar> clsmith: high five
16:49:10 <parcs`> mcstar: so what
16:49:21 <mm_freak> clsmith: there seems to be a connection between the two, because it's exactly the same for me
16:49:35 <mm_freak> i also have a difficult time programming in PHP for more than 30 minutes
16:49:47 <clsmith> i think i just sort of default to working on things. i find doing little very difficult to do for very long.
16:50:05 * timthelion has no trouble watching this channel run by for hours on end.
16:50:08 <timthelion> :(
16:50:27 <timthelion> and checking his email.  That's the worst.  And reading reddit...
16:50:36 <mcstar> growing beard
16:50:39 <Lutin`2> OH god
16:50:41 <timthelion> internet news is like crack for me :(
16:50:44 <Lutin`2> reddit takes all my time
16:50:51 <mcstar> haha
16:50:55 <mcstar> i guess we are different
16:51:10 <mcstar> i cant read redit and stuff like that
16:51:12 <clsmith> i don't find reddit very interesting. hacker news has some interesting things occasionally.
16:51:24 <parcs`> hacker news is worse than reddit
16:51:38 <timthelion> I find hacker news to be so infuriatingly boring!  Such idiots there, everything is a linkspam.
16:51:41 <clsmith> well, once you get past the yuppies you get some good CS discussion
16:51:44 <parcs`> timthelion++
16:51:51 <timthelion> at least on reddit they're clever.
16:51:55 <clsmith> hah.
16:51:59 <rhodesd> reddit/prog is pretty good about not posting political machinations
16:52:14 <Lutin`2> THere's also /r/haskell!
16:52:30 <mm_freak> i could read interesting type signatures for hours
16:52:38 <clsmith> i think i'm starting to move on from HN tbh. recently it's become a lot less programming and a lot more "how the app store is like starbucks"
16:52:48 <clsmith> maybe the next stop is LtU
16:54:30 <timthelion> LtU?
16:54:40 <clsmith> lambda the ultimate
16:54:48 <Lutin`2> So...
16:54:56 <Lutin`2> I'm creating a windows recovery disc
16:55:03 <Lutin`2> And then I'm wiping and installing linux!
16:55:06 <hpc> i understand maybe a tenth of what's posted to ltu
16:55:06 <mm_freak> HN?  do you mean the HWN?
16:55:14 <Lutin`2> mm_freak
16:55:20 <Lutin`2> I assume ycombinator
16:55:21 <clsmith> hwm..?
16:55:24 <clsmith> yeah, hacker news
16:55:28 <Peaker> I used to enjoy HN and find it really high quality. Now I find it mediocre. I don't know if I changed or if HN changed
16:55:31 <mm_freak> haskell weekly newsletter
16:55:33 <Lutin`2> Also fail autocomplete
16:55:45 <hpc> Peaker: probably both
16:55:47 <clsmith> mm_freak: ah, hm, i've not tried that
16:55:51 <hpc> i hear that sentiment a lot
16:55:58 <mm_freak> no, what is HN?
16:56:11 <hpc> news.ycombinator.com
16:56:18 <parcs`> a crappy news aggregate for "hack3rs"
16:56:18 <hpc> or whatever the url is
16:56:19 <mm_freak> ah…  weird abbreviation
16:56:23 <Peaker> I think it's still much less of a troll-fest than Reddit, and probably more positive
16:56:28 <hpc> "hacker news"
16:56:51 <mm_freak> i see
16:56:53 <clsmith> see, i occasionally post my stuff to it and sometimes get good feedback and stuff. so that's cool.
16:57:19 <mm_freak> dunno, i'm reading reddit and stackoverflow via gmane, and that's about it
16:57:48 <hpc> i read SO, thedailywtf, and some random blogs
16:57:53 <mm_freak> i used to read the HWN, but it basically just reflects what i'm reading via gmane anyway and has a short list of funny quotes, but that's about it
16:58:03 <mm_freak> the HWN used to be more interesting
16:58:25 <mm_freak> and i read the monad reader and from time to time the comonad reader
16:58:32 <ben> I like the funny quotes
16:58:59 <mgsloan> HN: a news aggregator for "upwardly mobile hack3rs"
17:00:20 <clsmith> the trouble is, there's no real aggregator for just really-interesting-things-involving-computer-science.
17:00:37 <clsmith> i'm not so enthralled with haskell that i want nothing else, you know?
17:01:15 <mgsloan> well, there's http://www.reddit.com/r/compsci and related
17:01:27 <Lutin`2> LIke http://www.reddit.com/r/compscipapers
17:01:29 <mgsloan> but yeah, r/programming has devolved a bit
17:01:52 <timthelion> The real trouble with haskell, is there aren't enough BIG exciting open source projects being written in it yet, so very few people actually know what they're talking about.  We need to get back to coding and MAKE some news :D
17:01:54 * mgsloan puts on "off my lawn" long-time-redditor hat
17:02:22 <Lutin`2> I'd be down to work on a project with someone
17:02:32 <clsmith> my impression of reddit has been that it's largely composed of people who really think they know everything about computers >.>
17:02:33 <mgsloan> timthelion: The problem with that is that most haskellers have day jobs or day school
17:03:12 <mgsloan> so the big news is mostly academic projects, which are only interesting to the already-convinced
17:03:51 <mgsloan> somehow we need a way to make everyone that likes Haskell simultaneously independently wealthy
17:04:15 <clsmith> i support this motion through pure self-interest
17:04:35 <mgsloan> :D
17:05:06 <clsmith> is there any kind of aggregator for general programming language theory?
17:05:41 <mm_freak> i figured that most of computer science is not very interesting
17:05:47 <mm_freak> and most interesting things are haskell-related
17:05:49 <Lutin`2> You can search for different subreddits or reddit
17:05:54 <Lutin`2> on*
17:06:09 <johnw> I'm trying hard to wrap my head around the fact that (. (a . b)) . (==) is the same as (\x -> (x ==) . a . b), and I think I see the light.  Probably a good reason not to use it, though.
17:06:18 <mm_freak> it might well be that the "more interesting" source doesn't exist by design
17:06:55 <clsmith> mm_freak: i basically find programming language design fascinating. the rest of CS is a bit boring. >.>
17:07:05 <Lutin`2> Ah I see what you're saying
17:07:39 <mm_freak> clsmith: are you sure you find that fascinating?  consider that most languages are poorly designed, and the better designed languages are either impractical or haskell
17:08:14 <timthelion> johnw: isn't the first one infix though?
17:08:28 <clsmith> well, i like all the unusual semantics, like conditions, continuations, alternatives to references, reasons why OO is stupid, ... :p
17:08:46 <johnw> timthelion: how do you mean?
17:08:54 <Lutin`2> I know there's the esoteric lang wiki
17:09:03 <latro`a> several of those things have nothing to do with programming language semantics :p
17:09:04 <Lutin`2> And I think they have an IRC channel somewhere
17:09:17 <timthelion> johnw: well it depends on the types of a and b, but both take 2 arguments I presume, and the first should be infix, no
17:09:17 <mgsloan> join #esolang
17:09:20 <mgsloan> err
17:09:24 <parcs`> johnw: replace the outermost (.) by its definition, tada
17:09:28 <clsmith> latro`a: it depends where you define the language as beginning and ending, really.
17:09:36 <latro`a> also depends on the language itself
17:09:37 <johnw> in this case, a and b are both a -> b
17:09:37 <mgsloan> nope, #esolang doesn't exist
17:09:44 <monochrom> (. blahblah) is analogous to (+ blahblah), i.e., section
17:09:44 <johnw> == is the only binary operator
17:10:15 <latro`a> in an imperative-ish language, continuations are more complicated
17:10:19 <monochrom> (. blahblah) = \x -> x . blahblah
17:10:21 <johnw> yeah, so (. (a . b)) . (==), when fed the first argument, result in (==a) . (a . b)
17:10:21 <latro`a> because they're like closures on steroids
17:10:40 <mm_freak> from a theoretical standpoint there are only three interesting esoteric languages
17:10:43 <clsmith> latro`a: well, conditions require special call stack semantics, as do continuations-done-well; values instead of references, and generalised variables... all these things could be done totally macro'd, but it's still a design of the language if you build the language around these concepts
17:10:44 <johnw> then when fed the second argument, becomes ((a ( b y)) == x)
17:10:46 <mm_freak> brainfuck, lazy k and unlambda
17:11:28 <latro`a> clsmith--consider haskell, where continuations are not anything special
17:11:32 <johnw> but I'm beginning to think that sectioning . is just bad style
17:11:32 <parcs`> why brainfuck?
17:11:42 <Boney> fg
17:11:45 <clsmith> latro`a: sure, but that's because of the design of the language. that in itself is quite interesting.
17:11:52 <latro`a> sure
17:11:55 <mm_freak> parcs`: brainfuck is to turing machines what lazy k is to lazily reduced lambda calculus
17:12:17 <mm_freak> well, no
17:12:18 <tromp_> blc is closer to lambda calculus
17:12:35 <mm_freak> what lazy k is to lazily reduced SK calculus
17:12:36 <tromp_> lazyk/unlambda are closer to combinatory logic
17:12:37 <clsmith> i'm quite interested in how one can add more and more to lambda calculus and by introducing new forms of expression create wildly different languages
17:12:42 <mm_freak> yeah
17:13:34 <copumpkin> edwardk: a more friendly approach to compiling the subproject might be to ./configure it, modify the generated header file to be flexible across GHC's major platforms, then remove configure and autotools altogether, and have cabal compile the c files itself without making a separate library at all, since I've been trying to do the static linkage which is a pain in the ass on OS X
17:13:37 <mm_freak> i wouldn't add too much to lambda calculus
17:14:08 <mm_freak> i think lambda calculus is fine as it is, just add types
17:14:30 <clsmith> well, i like a little sugar in my lambda :p
17:14:45 <mm_freak> clsmith: that's not related to lambda /calculus/…  that's just representation
17:14:50 <mm_freak> or notation if you will
17:15:26 <clsmith> oh, sure. but i'm sure using no more than sugar you can build entirely different languages. add sugary monads and get imperative, for example.
17:15:43 <clsmith> i.e. do-notation
17:15:55 <mm_freak> you really don't need all that…  just allow infix notation
17:16:13 <mm_freak> applications of (>>=) and (>>) don't look much worse than do-notation
17:16:16 <mm_freak> perhaps also allow let
17:16:18 <clsmith> you don't /need/ anything :p
17:16:28 <mm_freak> (most sensible core languages have let and letrec)
17:16:32 <clsmith> i think it would be informative, is all.
17:17:41 <mm_freak> clsmith: my point is, it's not really of theoretical interest, and you don't need the sugar to get an imperative-looking language
17:18:25 <parcs`> mm_freak: there are smaller languages than brainfuck that are turing complete http://semarch.linguistics.fas.nyu.edu/barker/Iota/
17:18:38 <clsmith> building up from untyped lambda calculus to a sugared functional language, and exploring different things like side-effects with monads, continuations, conditions... i think that would make a good book or something :p not pushing the boundaries of theory, just thought-provoking, for non-phd programmers :p
17:19:01 <mm_freak> parcs`: of course…  lazy k is smaller and turing-complete, but that's not really the point
17:19:29 <mm_freak> clsmith: note that most high level languages make a break after the core language
17:19:43 <mm_freak> for example haskell is compiled to a core language
17:19:53 <parcs`> mm_freak: then why is brainfuck to turing machines?
17:20:32 <clsmith> mm_freak: sure. but it has a whole bunch of sugar on top :p
17:21:14 <mm_freak> parcs`: because of the infinite band, the read/write head and the simple moving/writing operations
17:21:31 <clsmith> yeah, brainfuck is very turing machine-y
17:21:47 <clsmith> plus IO, oddly
17:22:01 <mm_freak> yeah, IO is misplaced there
17:22:07 <mm_freak> but unlambda suffers from the same problem
17:27:27 <tromp_> lambda calculus is a lot more expressive than brainfuck though
17:28:05 <tromp_> i wouldn't want to write a lambda calculus interpreter in brainfuck...
17:28:16 <Lutin`2> I wouldn't want to write in brainfuck
17:29:50 <mm_freak> tromp_: you're making assumptions there
17:30:21 <mm_freak> notice that lambda calculus has no let expressions, no recursion and no predefined numbers
17:30:44 <tromp_> those are all easily expressed though
17:30:52 <mm_freak> easily, but not nicely
17:31:24 <monochrom> still less work than brainfuck
17:31:45 <tromp_> so you write programs with the syntactic sugar and then desugar at small overhead
17:31:50 <Lutin`2> http://www.reddit.com/r/tinycode would probably interest some of you
17:32:04 <mm_freak> tromp_: that doesn't count, because you can do the same with brainfuck
17:32:13 <tromp_> not with small overhead
17:32:16 <mm_freak> write a program that outputs this sequence forever:
17:32:19 <mm_freak> > [1..]
17:32:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:32:23 <mrlemao2> Q: I don't understand this: newChannel :: (Serializable a) ⇒ ProcessM (SendPort a, ReceivePort a) — how/when is the type of a defined?
17:32:25 <mm_freak> uhm
17:32:26 <mm_freak> no
17:32:34 <mm_freak> > map (`mod` 10) [1..]
17:32:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,...
17:32:36 <mm_freak> this one
17:32:53 <mm_freak> easy in brainfuck, hard in lambda calculus
17:32:54 <johnw> is there a good templating library for Haskell?  I.e., interpolating the results of expressions into a big fat string?
17:33:21 <mm_freak> johnw: there are good HTML templating libraries…  i don't know about generic string templates, because most assume XML
17:33:24 <johnw> found HStringTemplate
17:33:27 <tromp_> does brainfuck have byte sized or unbounded cells?
17:33:40 <mm_freak> tromp_: byte
17:33:43 <Mortchek> tromp_, implementation-dependent. Well written programs assume the former.
17:33:45 <otters> mrlemao2: class constraint
17:34:05 <johnw> i'm busily writing a c2hsc generator
17:34:10 <tromp_> then it's not much harder in lc than in bf
17:34:12 <johnw> thanks to language-c, it's going very well
17:34:28 <tromp_> in fact i wrote a small blc program that outputs that listy
17:34:40 <Mortchek> The mod 10 one?
17:34:47 <tromp_> no the full one
17:35:32 <tromp_> i wrote a blc program that outputs a list of primes in decimal
17:35:44 <Mortchek> What is blc?
17:35:53 <tromp_> binary lambda calclus
17:35:56 <mrlemao2> otters: oops, that seems quite obvious ( public <T extends Serializable> T newChan() )
17:35:58 <mm_freak> tromp_: it's way easier to write and read in brainfuck in this case…  the only real pain is the modulo operation
17:36:09 <mm_freak> also i'm not familiar with binary lambda calculus
17:37:31 <tromp_> i claim its easier in blc than in bf
17:37:37 <hpaste> MrLemao pasted “newChan” at http://hpaste.org/74219
17:38:35 <mm_freak> tromp_: ok, a very contrived example…  let's let it count this way instead:
17:38:42 <mm_freak> > cycle [1..8]
17:38:43 <lambdabot>   [1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,...
17:38:53 <mm_freak> that one is really short and sweet in brainfuck
17:39:20 <mm_freak> my point is that pure lambda calculus is not universally more convenient to write actual programs in than brainfuck
17:39:39 <mrlemao2> Q2, newChan has no params so how does 'ask' return a specific 'proc' value? Some sort of global? But that is not possible in Haskell?!
17:39:50 <tromp_> and my point is that it is
17:40:10 <Lutin`2> mrlemao2
17:40:27 <Lutin`2> FFS this irc client always messes up my completes
17:41:47 <Lutin`2> I'm not sure what you're asking in that second question exactly, but may I point you to http://www.haskell.org/haskellwiki/Type_inference
17:42:00 <tromp_> how many bytes do you need to output "1 2 3 4 5 6 7 8 9 10 11..." in bf?
17:43:33 <Mortchek> Anything wrong with this? >++++++++[<++++++>-]<[.+.+.+.+.+.+.+.+.+.---------]
17:43:34 <Lutin`2> tromp_ : +[.+]
17:44:01 <Mortchek> Displays 0..9, no spaces in between, forever.
17:44:36 <Mortchek> Probably wouldn't be much harder to add spaces though.
17:45:04 <Lutin`2> Oh wait yeah
17:45:11 <tromp_> that works only up to 255
17:45:13 <mm_freak> tromp_: ++++++[>++++++++<-]>[.+.+.+.+.+.+.+.-------]
17:45:28 <mm_freak> outputs this:
17:45:33 <tromp_> blc does it in 68 bytes,
17:45:35 <mm_freak> > cycle ['0'..'7']
17:45:36 <lambdabot>   "01234567012345670123456701234567012345670123456701234567012345670123456701...
17:45:51 <mm_freak> oh, Mortchek was faster
17:45:55 <mrlemao2> Lutin `2: “newChan” at http://hpaste.org/74219 — newChan has no input parameters, but it returns me a new output all the time that that seems to be happening in 'proc <- ask' but what is the input to ask?
17:46:15 <Lutin`2> Hmm
17:46:16 <mm_freak> i wanted to do it a bit more elegantly at first, but realized that this version is easy to write and read =)
17:46:22 <tromp_> seems you're having trouble finding things that bf does better than blc :)
17:46:28 <Mortchek> mm_freak, how would you make it more elegant?
17:46:51 <timthelion> Anyone who thinks haskell is a great language has clearly never written a parser for it capable of handling the do clause with currly brackets.
17:47:27 <mm_freak> Mortchek: i wanted to count in (+ 2^5)-steps in one register and in (+ 1)-steps in the other…  when the first one is 0, subtract 8 from the second
17:47:41 <Lutin`2> mrlemao2: Not quite. The output comes from line 5
17:47:55 <mm_freak> timthelion: nobody claims that haskell is easy to parse
17:48:00 <tromp_> anything you can do with an n-byte BF program can be done with am n+112 byte blc program
17:48:22 <tromp_> usually  MUCH  less though
17:48:27 <mm_freak> still, i'm not familiar with "binary" lambda calculus
17:48:33 <tromp_> then get familiar:)
17:48:46 <mm_freak> why?  we were talking about lambda calculus, not a dialect of it
17:49:05 <tromp_> it's not a dialect
17:49:24 <tromp_> it's the pure thing, with conventions for IO
17:49:34 <mrlemao2> Lutin `2: true, but to my untrained eye 'ask' has no input params so in pure haskell it should be a constant, but the rest of the impl depends on proc being specific to the current call
17:49:55 <Lutin`2> Uh
17:50:01 <Lutin`2> That code isn't pure haskell
17:50:12 <latro`a> that is not how ask works
17:50:28 <latro`a> it is a constant, like anything else, but its output when you bind isn't
17:50:46 <nand`> ask is constant like /bin/ls is constant
17:50:47 <latro`a> (eh, "isn't" modulo the semantics of Reader)
17:50:53 <latro`a> yeah, like that
17:50:55 <Lutin`2> I think you might not understand do syntax and monads yet
17:51:47 <mrlemao2> but what is the 'context' for ask?
17:51:54 <mm_freak> tromp_: my point was that brainfuck has an advantage when it comes to very simple numeric operations, simply because they are predefined
17:52:15 <mm_freak> lambda calculus does not predefine anything
17:52:27 <mm_freak> it's about as small as a language can get
17:52:30 <edwardk> copumpkin: sounds like a plan. it'd probably be a lot easier to work with
17:52:36 <mm_freak> i think only SK calculus beats that
17:52:40 * hackagebot blaze-html 0.5.1.0 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.5.1.0 (JasperVanDerJeugt)
17:52:58 <nand`> a language with as little as one function can be turing complete
17:53:16 <nand`> one function, and application
17:53:25 <mm_freak> huh?  doubt it
17:53:38 <tromp_> and you'd be surprised how easily numbers are defined in lc, so the bf advantage is small
17:53:48 <nand`> mm_freak: you can mix the SK combinators into one function and re-extract S and K by repeatedly applying it to itself
17:54:05 <nand`> it's not a combinator though, notably
17:54:08 <mm_freak> nand`: do you have an example of such a function?
17:54:14 <nand`> sure one sec
17:54:20 <nand`> https://en.wikipedia.org/wiki/Iota_and_Jot
17:54:20 <tromp_> it's <K,S,K>
17:54:28 <timthelion> It's strange, how I can talk to pretty much the same nicks, all day.. And then, I happen to be up at 3 am one night, and all the same nicks are STILL there!
17:54:36 <Lutin`2> mrlemao2: I think it is type inference that has you confused
17:54:49 <clsmith> i invented a language called 'my god it's full of stars', which goes like so - ********** - you get the number of stars, and translate that into brainfuck via BCD, et voila... >.>
17:54:50 <nand`> U f = fSK
17:54:56 <mrlemao2> here ask's type — ask :: MonadReader r m => m r, if I fire ghci, import Control.Monad.Reader and then enter ask I get an "Ambiguous type variables `r0', `m0' in the constraint:"
17:55:11 <nand`> K = U(U(UU)), S = UK
17:55:17 <tromp_> <K,S,K> <K,S,K> = <K,S,K> K S K = K K S K S K = K K S K = K K
17:55:32 <mm_freak> nand`: interesting
17:55:36 <clsmith> timthelion: we never sleep
17:55:41 <tromp_> K K <K,S,K> = K
17:56:02 <tromp_> <K,S,K> (K K) = K K K S K = K S K = S
17:56:08 <clsmith> (that's a lie, i'm going to bed now)
17:56:21 <mm_freak> timthelion: i'm working
17:56:28 <Lutin`2> Doesn't mean you'll sleep clsmith haha
17:56:39 <tromp_> similar to U, but youy get S and K in fewer steps
17:56:40 <nand`> mm_freak: another ‘tiny’ language is http://esolangs.org/wiki/Jot
17:56:45 <clsmith> true. i will just wait.
17:56:49 <nand`> mm_freak: every combination of 0 and 1 is a valid Jot program
17:56:53 <nand`> and it's TC
17:56:55 <ReinH> weird, I've defined an instance of Arbitrary for Piece but GHC is obstinately telling me I don't have an instance of arbitrary for piece :(
17:57:15 * timthelion thinks that there is a practical use to such trivial KS calculi...  If the algebraic replacements can be done in place, such as in conways life, these cacluli could be converted literally to really cool physical parallel processors.
17:57:30 <Lutin`2> nand`: Now that
17:57:31 <ddarius> > log 0.00000001
17:57:32 <lambdabot>   -18.420680743952367
17:57:37 <Lutin`2> THat looks very interesting
17:57:39 <tromp_> but again, all those SK based languages like lazyk, unlambda, iota and jot is less expressive than blc
17:57:41 <edwardk> timthelion: look up the reduceron
17:57:52 <nand`> the reduceron is super cool
17:57:57 <nand`> I recently read the paper
17:57:58 <timthelion> edwardk: doing so
17:58:01 <Dread> How fast is Haskell's pattern matching on an enum type? Is it O(1)?
17:58:04 <nand`> I wonder how much the FPGA costs
17:58:14 <nand`> (It's a Xilinx Virtex-5)
17:58:29 <mm_freak> nand`: would be interesting to write a random number generator and just see what the generated program does =)
17:58:47 <mm_freak> you could probably even use an evolutionary algorithm
17:58:54 <mm_freak> and "grow" your program =)
17:58:59 <nand`> Dread: pattern matching doesn't scale with the size of the enum type, as far as I know - it's just an integer and comparisons under the hood
17:59:02 <MostAwesomeDude> Dread: Does it matter? (IIUC it's per-implementation and not specified.)
17:59:22 <nand`> (though what I just said is not necessarily true)
17:59:24 <mm_freak> tromp_: those languages are not designed to be expressive…  they are designed to be minimal
17:59:28 <nand`> implementation specific
17:59:35 <Lutin`2> MostAwesomeDude: THen assume he means GHC's pattern matching implementation
17:59:37 <tromp_> unlambda is far from minimal
17:59:43 <tromp_> and far from pure
17:59:46 <nand`> mm_freak: heh, yeah
17:59:50 <clsmith> mm_freak: you could then optimise either for "infinite loop" or "nothing useful", depending on your needs
17:59:59 <mm_freak> hehe
18:00:03 <nand`> mm_freak: you can use it to sort lambda terms :)
18:00:16 <nand`> or other fun things with gödel numbering
18:00:19 <mm_freak> tromp_: the original unlambda was minimal, before the author added all those additional combinators
18:00:31 <timthelion> edwardk: very cooll
18:00:39 <mm_freak> it was just S, K, I, I/O and application
18:00:39 <nand`> I think lazy K is smaller than unlambda, no?>
18:00:43 <mm_freak> yes, it is
18:00:50 <nand`> it doesn't have the extra overhead unlambda needs due to not being lazy/pure
18:00:55 <tromp_> yes, lazy is very similar to blc
18:00:58 <tromp_> lazyk
18:01:01 <Dread> MostAwesomeDude: It matters quite a bit.
18:01:11 <nand`> I think lazy k is the ‘true’ unlambda
18:01:22 <nand`> as in, it gets closer to the spirit of unlambda than unlambda itself
18:01:25 <MostAwesomeDude> Dread: Why does it matter *to you* right now? :3
18:01:26 <tromp_> yes, it's much cleaner than unlambda
18:02:10 <timthelion> I think that we could implement conway's life with a single nand circute, a capacitor and 5 diods per cell.  Which would mean that you might fit a 10,000x10,000 conways life board onto a single chip using current technology...  You could have a billion core processecor, however pathetic such cores would be :)
18:02:35 <nand`> well
18:02:43 <mm_freak> "circute"…  that's a nice typo =)
18:02:47 <nand`> you can build anything in conway's game of life
18:02:49 <Dread> MostAwesomeDude: I suppose if I learned how to use TH it wouldn't matter. I'm writing a simulation and so I need quite a bit of performance.
18:02:56 <nand`> computers, graph reducers, you name it
18:03:12 <MostAwesomeDude> Dread: Well, I'd suggest you use a profiler and look for hotspots.
18:03:27 * nand` wants to try building an SK machine
18:03:33 <timthelion> nand`: One trouble with such processor, is that you could only write to the edges of the board.  But I checked it out, and that actually suffices, for writting to the entire board, by pushing some machinery.
18:04:04 <ddarius> timthelion: The Connection Machine had (up to) 65536 processors, albeit each was a one bit processor.
18:04:07 <kanedank> I want to create a simple 2d array based data structure for a game, what should I use for it? I'm thinking of using a hashmap with "x.y" as the index (where x and y are the string versions of the vars) but I don't think that's the best way
18:04:15 <Lutin`2> nand`: I'm a comp engi major and I'm hoping it won't take long have unrestricted 1 on 1 time with some really nice FPGAs
18:04:22 <Lutin`2> lol
18:04:30 <timthelion> ddarius: sounds similar to what I'm thinking :)
18:04:33 <MostAwesomeDude> kanedank: There is an Array type in the array package.
18:04:35 <nand`> kanedank: a Map (Int, Int) would certainly be better than a hashmap with "x.y" as the indices
18:04:41 <mm_freak> kanedank: that's actually a very ugly way to do it…  you have vectors, arrays and repa
18:04:50 <nand`> but yeah ^
18:05:19 <mm_freak> kanedank: in any case, if you have real indices, use them instead of converting them to strings…  that's a pretty stupid thing to do in haskell
18:05:28 <ddarius> How would one even come up with that representation as a first pass?
18:05:36 <nand`> Lutin`2: nice, do you know of the Haskell libraries for describing FPGAs?
18:05:40 <Lutin`2> NOt yet
18:05:44 <mm_freak> ddarius: by being used to poor languages like PHP or JavaScript
18:05:51 <Lutin`2> I've mostly just been tinkering with Haskell
18:06:02 <nand`> @hackage york-lava
18:06:03 <lambdabot> http://hackage.haskell.org/package/york-lava
18:06:08 <Lutin`2> Haven't been able to get a good environment in Windows to do much more than
18:06:09 <ddarius> mm_freak: You can have arrays of arrays in javascript and I'm sure PHP is capable of it as well.
18:06:28 <mm_freak> ddarius: it is, but keys are either numbers or strings…  they don't have type classes
18:06:30 <monochrom> shell scripts, awk scripts, and perl scripts are how one comes up with "use a string" all the time
18:06:52 <Mortchek> JS objects, including arrays, are only allowed strings as property names
18:06:56 <mm_freak> yeah, those are better examples, but PHP/JS aren't /much/ better
18:07:17 <geekosaur> php's worse; *everything* is a string
18:07:29 <mm_freak> geekosaur: that's not true
18:07:45 <monochrom> also, I keep forgetting tcl
18:07:58 <ddarius> Mortchek: The issue is the user's (i.e. programmer's) perspective.
18:08:15 <Mortchek> Yeah, understood. Even in JS, nested arrays would be way better for that sort of thing.
18:08:20 <spirity> I typically don't treat everything as a string when I write perl scripts
18:08:37 <Lutin`2> Hey
18:08:39 <Lutin`2> GUys
18:08:47 <Lutin`2> Stop arguing and help the guy out! lol
18:08:51 <monochrom> also, 2012 is a fine year to blame it on Turing :)
18:09:06 <mm_freak> Lutin`2: we did, and he has yet to respond
18:09:07 * ddarius actually does stick things together in strings for pairs in certain cases...
18:09:18 <Mortchek> ddarius, like what?
18:09:22 <Lutin`2> mm_freak: oh yeah, fair enough
18:09:27 <kanedank> well, I'm trying to rewrite it now, but I can't figure out how to create map instance like that
18:09:41 <mm_freak> kanedank: tuples can be keys
18:09:45 <ddarius> Mortchek: Like doing look ups in SSRS reports on multiple columns.
18:10:00 <kanedank> mm_freak: how do I create a map like that?
18:10:09 <Mortchek> ddarius, is that a requirement of the API?
18:10:20 <mm_freak> kanedank: what are the types of the coordinates?
18:10:21 <ddarius> I guess it would actually work to use a VB.NET object maybe...
18:10:25 <kanedank> just Map (Int, Int)?
18:10:29 <mm_freak> kanedank: yes
18:10:30 <kanedank> mm_freak: ints
18:10:41 <kanedank> mm_freak: thanks!
18:10:44 <nand`> Map (Int, Int) Foo where Foo is the value type
18:10:44 <mm_freak> kanedank: Map allows anything that is an Ord instance
18:11:03 <Dread> MostAwesomeDude: I just need to know if pattern matching an enum type is O(1)
18:11:27 <Lutin`2> Why don't you profile it and find out?
18:11:33 <spirity> Dread: I believe it is.
18:11:42 <nand`> again, depends on the implementation
18:11:42 <spirity> if it not, then it's usually a negligible cost.
18:11:44 <mm_freak> kanedank: you can have Map (Int, String) as well as Map [(Map Int String, String)]
18:12:03 <ddarius> Mortchek: Actually, I might be able to use pairs.  I'll have to try it.  I'm not sure if it's worthwhile though, especially since there isn't a handy tuple type avaliable.
18:12:16 <nand`> I could write an implementation which uses huge scott encodings underneath and matching on enum types would be as slow as applying a huge function
18:12:50 <mm_freak> Dread: as far as i know unguarded, non-overlapping pattern-matching is always O(1)
18:13:01 <ddarius> nand`: That would still be constant time for a reasonable implementation of functions.
18:13:17 <ddarius> nand`: Basically it would be an array index and a jump.
18:13:18 <Dread> mm_freak: Thanks
18:13:24 <mm_freak> Dread: but it's safer to check, because i'm not sure
18:13:25 <latro`a> wait, O(1) in what
18:13:25 <Mortchek> ddarius, true. For a tuple, you could really go with either an array or an object with known property names, depending.
18:13:32 <latro`a> in the number of patterns?
18:13:34 <Mortchek> I do the former in my JS vector module.
18:13:52 <mm_freak> Dread: mostly when there is The Right Thing, GHC does it
18:14:02 <latro`a> if so, does that mean GHC does different stuff for overlapping patterns and non-overlapping patterns?
18:14:09 <kanedank> is Map (Int, Int) a map of int tuples to any datatype I want, or just ints to ints?
18:14:28 <latro`a> does it merge them when some overlap and others don't, for example the sequence Nothing, Just (x:xs), and _
18:15:23 <mm_freak> latro`a: not sure what happens for overlapping patterns…  at least if they are overlapping like Just X vs. Just Y, i wouldn't count on O(1) pattern matching
18:15:26 <nand`> kanedank: ‘Map (Int, Int)’ is not a fully applied type
18:15:56 <nand`> but Map k v is a map from k to v, and v can be any type you want
18:16:02 <nand`> k has to be Ord, but that's it
18:16:09 <nand`> that's pretty much the only restriction
18:16:10 <Lutin`2> I dream for the day
18:16:12 <mm_freak> latro`a: the thing to watch for is whether the order of the patterns matters
18:16:19 <Lutin`2> When mathematics and computer science are the same field
18:16:19 <mm_freak> if it does, you won't get O(1) pattern-matching
18:16:25 <nand`> Lutin`2: they aren't?
18:16:43 <latro`a> sure, but what if the order of *some* patterns matter
18:16:48 <Lutin`2> Many computer scientists would be offended if you were to suggest such lol
18:16:51 <mm_freak> kanedank: check the type signatures of the Map operations
18:16:54 <latro`a> for example Nothing and Just (x:xs) are interchangeable but moving _ away from the end breaks things
18:17:04 <Lutin`2> Well let me rephrase
18:17:09 <mm_freak> kanedank: insert :: (Ord k) => k -> a -> Map k a -> Map k a
18:17:09 <ddarius> nand`: Of course not. And why would we want them to be?  That would be like saying "I dream of the day when medicine and cardiology are the same field."
18:17:25 <mm_freak> kanedank: as you see there is an Ord requirement on 'k' and no requirement on 'a'
18:17:40 <Lutin`2> I mean when computer science is viewed as a pure subset of mathematics
18:17:57 <ddarius> Lutin`2: Mathematics is a pure subset of computer science.
18:18:00 <nand`> I think mathematics is so broad and so uncontainable/undefinable it arguably encompasses every other field
18:18:12 <mm_freak> kanedank: Map (Int -> Int) Int is a valid type, but you won't find any useful operations for that one…  what is allowed is determined by what the operations require
18:18:17 <kanedank> does a tuple with ints fulfill the Ord requirement?
18:18:21 <nand`> kanedank: yes
18:18:28 <Lutin`2> Hmm I cannot seem to properly express my notions
18:18:33 <nand`> kanedank: there's an (Ord a, Ord b) => Ord (a,b) instance
18:18:35 <nand`> and an Ord Int instance
18:18:50 <mm_freak> kanedank: fire up GHCi and type:  :i (,)
18:18:58 <kanedank> well here is what I have so far: http://hpaste.org/74220
18:19:22 <kanedank> I'm just trying to create a 9x9 map atm, and right now I'm just using "[ ]" as the empty placeholder
18:19:23 <jmcarthur> :i (,)
18:19:40 <jmcarthur> aw
18:19:50 <ddarius> jmcarthur: Feel free to make the plugin.
18:19:51 <MostAwesomeDude> Hey, is there a Monoid for updating records with the most recent data? I want to have a Writer that merely keeps a tally of what's been done.
18:20:03 <ddarius> MostAwesomeDude: Last I think.
18:20:09 <ddarius> @hoogle Last
18:20:09 <lambdabot> Prelude last :: [a] -> a
18:20:09 <lambdabot> Data.List last :: [a] -> a
18:20:09 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
18:20:31 <nand`> kanedank: ‘Map (Int, Int)’ is a type, not a value
18:20:56 <Lutin`2> :kind Map
18:20:56 <kanedank> nand`: how do I create a value of such type?
18:20:57 <Mortchek> A type constructor, isn't it?
18:21:01 <ddarius> :k Map (Int, Int)
18:21:02 <lambdabot> Not in scope: type constructor or class `Map'
18:21:19 <nand`> Mortchek: it's not exported
18:21:34 <nand`> kanedank: Data.Map provides a few functions for it
18:21:52 <Lutin`2> :k Data.Map
18:21:53 <lambdabot> Couldn't find qualified module.
18:21:56 <mm_freak> kanedank: http://hackage.haskell.org/packages/archive/containers/0.4.2.1/doc/html/Data-Map.html#g:4
18:22:00 <Mortchek> Maybe I don't have the correct definition of "type constructor".
18:22:02 <nand`> kanedank: you'd probably be interested in Data.Map.empty :: Map k v  and Data.Map.fromList :: Ord k => [(k,v)] -> Map k v
18:22:05 <Lutin`2> Oh bah
18:22:12 <MostAwesomeDude> > tell . Last . Just $ 1
18:22:13 <lambdabot>   No instance for (GHC.Show.Show (m ()))
18:22:13 <lambdabot>    arising from a use of `M389667635...
18:22:39 <nand`> Mortchek: a ‘type constructor’ is a type that, when applied to another type, produces a type
18:22:52 <MostAwesomeDude> > runWriter (tell . Last . Just $ 1)
18:22:54 <lambdabot>   ((),Last {getLast = Just 1})
18:22:59 <Mortchek> Ah, okay. So, Map (Int, Int) is a type constructor then.
18:23:12 <Lutin`2> Anything that isn't a concrete type, correct nand`?
18:23:22 <MostAwesomeDude> > runWriter $ do {tell . Last . Just $ 1; tell . Last . Just $ 2}
18:23:23 <lambdabot>   ((),Last {getLast = Just 2})
18:23:27 <MostAwesomeDude> Sweet.
18:23:32 <MostAwesomeDude> ddarius: Thanks!
18:23:32 <Lutin`2> Or are they not uh
18:23:35 <nand`> yeah pretty much anything with kind a -> * could be called a ‘type constructor’
18:23:46 <mm_freak> Mortchek: a type constructor is any type of kind * -> a for every 'a'
18:23:58 <Mortchek> Okay.
18:24:05 <mm_freak> not a -> *, but * -> a
18:24:09 <Lutin`2> Ah
18:24:14 <Lutin`2> That makes sense
18:24:15 <mm_freak> otherwise (->) wouldn't be a type constructor
18:24:27 <Mortchek> Where a is * or * -> a?
18:24:28 <Lutin`2> Yeah looking at it from the wrong way haha
18:24:34 <nand`> a -> b perhaps
18:24:35 <mm_freak> Mortchek: for every 'a'
18:24:46 <Mortchek> But what are the possible a's?
18:24:55 <Lutin`2> Any valid kind
18:25:14 <mm_freak> Mortchek: everything…  we can't really express "type constructor" on the kind level
18:25:25 <Lutin`2> Can't you?
18:25:30 <nand`> mm_freak: if you limit it to * -> a then something like (* -> *) -> * wouldn't be a valid type constructor, even though ‘Foo Just’ would be a valid type
18:25:34 <mm_freak> because something of kind * -> Constraint wouldn't be a type constructor
18:25:45 <nand`> also, * -> a includes constraints with ConstraintKinds
18:25:46 <Lutin`2> It's a function from the set of concrete types to the set of kinds
18:25:48 <nand`> yeah
18:25:52 <Lutin`2> Isn't it?
18:26:03 <kanedank> is there something like [(0,0)..(2,2)] for tuples?
18:26:14 <mm_freak> nand`: with your version you are /only/ allowing higher order stuff or * -> *
18:26:21 <monochrom> > [(0,0) .. (2,2)]
18:26:22 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
18:26:22 <lambdabot>    arising from a use of `e_10022' ...
18:26:26 <monochrom> no
18:26:30 <Mortchek> I notice (->) has kind ?? -> ? -> *. What do ?? and ? mean?
18:26:31 <mm_freak> we don't have kind classes, so we can't really express "type constructor" on the kind level
18:26:43 <nand`> mm_freak: a -> b -> ... -> *   :)
18:26:45 <monochrom> oh, I know why. but you're asking an XY Problem
18:26:51 * nand` gives up
18:26:53 <Lutin`2> Ah you mean you can't express in haskell, mm_freak?
18:26:56 <nand`> ‘type constructor’ isn't really well defined
18:26:58 <mm_freak> Mortchek: if you are a haskell beginner or use GHC >= 7.4, they mean * =)
18:27:01 <nand`> it's just a common term
18:27:11 <Mortchek> Ha. Okay.
18:27:25 <mm_freak> nand`: i think it is well defined…  (Type b) => a -> b
18:27:25 <monochrom> "type constructor" is what the Haskell 2010 Report uses
18:27:41 <nand`> mm_freak: ‘Type’?
18:28:02 <mm_freak> nand`: a hypothetical kind class Type with instances for * and (Type b) => a -> b
18:28:02 <MostAwesomeDude> > range ((0,0),(2,2))
18:28:03 <lambdabot>   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
18:28:08 <MostAwesomeDude> kanedank: ^^
18:28:13 <nand`> mm_freak: fair enough
18:28:16 <MostAwesomeDude> kanedank: Check out Data.Ix and Data.Array.
18:28:44 <scshunt> my definition: a constructor is in CamelCase. A constructor that produces a type is a type constructor, otherwise a value constructor
18:28:54 <mm_freak> Lutin`2: yes, a type constructor is something that, when applied, results in either a type constructor or a type
18:29:21 <mm_freak> there is no way to express that on the kind level in haskell
18:29:23 <Lutin`2> And it must be applied to a concrete type?
18:29:28 <mm_freak> nope
18:29:34 <Lutin`2> Or to what?
18:29:40 <mm_freak> it can be applied to a Constraint, for example
18:29:41 <Mortchek> :k Just Just
18:29:41 <lambdabot> Not in scope: type constructor or class `Just'
18:29:42 <lambdabot> Not in scope: type constructor or class `Just'
18:29:44 <nand`> scshunt: ‘produces’ ?
18:29:47 <Mortchek> Woops, silly me
18:29:50 <Mortchek> :k Maybe Maybe
18:29:51 <lambdabot>     `Maybe' is not applied to enough type arguments
18:29:51 <lambdabot>     The first argument of `Maybe' should have kind `*',
18:29:52 <lambdabot>     but `Maybe' has kind `* -> *'
18:30:25 <wy> weird ...
18:30:37 <mm_freak> :k Kleisli Maybe
18:30:38 <lambdabot> * -> * -> *
18:30:47 <Mortchek> So, the kind a type constructor will take depends on the actual type constructor.
18:31:00 <mm_freak> yes
18:31:00 <nand`> well yes
18:31:03 <mm_freak> :k Kleisli
18:31:04 <lambdabot> (* -> *) -> * -> * -> *
18:31:05 <mm_freak> :k Maybe
18:31:06 <lambdabot> * -> *
18:31:08 <nand`> just like the type a function will take depends on the actual function :P
18:31:09 <mm_freak> two type constructors
18:31:19 <Lutin`2> Yes
18:31:20 <Mortchek> Yeah. I haven't made all the associations yet. :P
18:31:38 <mm_freak> Mortchek: kinds are to types what types are to values
18:31:43 <mm_freak> and you could continue that hierarchy
18:31:59 <mm_freak> (although * is a weird name)
18:33:38 <kanedank> MostAwesomeDude: thanks!
18:34:16 <nand`> I guess (Type -> Type) -> Type -> Type -> Type was too verbose
18:34:29 <nand`> (and not too great of a name either)
18:35:07 <Lutin`2> Hmm
18:35:09 <mm_freak> how about T?
18:35:17 <kanedank> MostAwesomeDude: where do I import range from? How would I normally look that up in general?
18:35:31 <Lutin`2> mm_freak: My brain is just seeking further abstraction
18:35:41 <mm_freak> kanedank: Data.Ix
18:35:49 <Lutin`2> So I was seeking some definite parallel between kinds and types and values
18:36:17 <nand`> why stop at kinds? :(
18:36:39 <nand`> (or values, for that matter)
18:36:47 <Lutin`2> Well I mean optimally I would learn category theory
18:37:05 <Lutin`2> But I'm already taking several courses :[
18:37:25 <nand`> I'm not convinced that's optimal either
18:37:28 <mm_freak> nand`: because haskell is designed such that you don't really need the next level
18:37:38 <Lutin`2> Well see
18:37:52 <Lutin`2> I really like graphs
18:38:01 <mm_freak> nand`: you can't define kinds and the only predefined ones all have the same sort, if you call the next level the sort level
18:38:12 <Lutin`2> But I want graphs in an environment
18:38:14 <mm_freak> for more levels to make sense you need a dependently typed language
18:38:19 <Lutin`2> idk if that makes sense
18:38:35 <dolio> No, you don't.
18:38:52 <nand`> mm_freak: yeah, I was more or less poking fun - isn't it possible to go the other way by extending the value level with a ‘proofs’ level, hypothetically? (not sure how great it'd work out in practice)
18:38:56 <mm_freak> or at least you need to be able to define types for every level
18:39:25 <gwern> @quotes
18:39:25 <lambdabot> sethg says: I feel like I still don't understand comonads.  Maybe I just need a Zen comaster to hit me with a costick and then I'll become coenlightened.
18:39:48 <Cale> Whoa, d
18:39:50 <nand`> ‘Zen Comaster’ edwardk's middle name
18:39:51 <mm_freak> sorry, i don't understand that question
18:39:53 <Lutin`2> See that's what I want nand`
18:40:04 <Lutin`2> Being able to prove everything that I code
18:40:06 <Cale> did anyone else notice that Enlightenment has started doing releases again?
18:40:07 <typoclass> or he could read a dozen comonad tutorials
18:40:19 <nand`> ah yes, where are the comonad tutorials at?
18:40:20 <Cale> http://www.enlightenment.org/ :O
18:40:28 <Lutin`2> Orly now Cale
18:40:45 <mm_freak> he could also read a codozen monad cotutorials
18:41:01 <nand`> if a tutorial makes you smarter
18:41:07 <nand`> does a monad cotutorial make you dumber?
18:41:12 <edwardk> cale: guess alan cox's endorsement after the whole de icaza kerfuffle paid off ;)
18:41:47 <mm_freak> that would be an antitutorial
18:41:53 <mm_freak> nobody understands what a cotutorial does
18:42:52 <nand`> consider a tutorial as an arrow or family of arrows in the poset category of wisdom states
18:43:09 <ReinH> o_O
18:43:13 <Cale> Haha, this version number: 0.16.999.76015
18:43:39 <nand`> Cale: how long until it gets rounded to e17 by limited precision versioning systems?
18:43:46 <ddarius> @karma lwall
18:43:46 <lambdabot> lwall has a karma of 0
18:44:39 <ion> This features a number of improvements, include LESS CRASHING and IMPROVEMENTS TO NOT CRASHING.
18:44:59 <typoclass> cale: 1) what's enlightenment? 2) does it do xmonad?
18:45:07 <SHACHAF> @karma nobody
18:45:07 <lambdabot> nobody has a karma of 2000
18:45:14 <SHACHAF> Cale: What did you do to lambdabot?
18:45:27 <Lutin`2> Hey guys
18:45:29 <typoclass> ("what's enlightenment" in the sense of, what's special about it)
18:45:30 <nand`> @karma somebody
18:45:30 <lambdabot> somebody has a karma of 0
18:45:33 <nand`> that is true
18:46:11 <Cale> typoclass: 1) A heavyweight window manager / lightweight desktop which has been around for ages, used to be really popular several years ago. 2) No, you couldn't run both at once because it's a WM.
18:46:33 <nand`> ‘you couldn't run both at once’ challenge accepted
18:46:36 <typoclass> cale: thank you
18:48:27 <Cale> typoclass: At one point, it was the fanciest WM, and sort of pushed the cool factor of Linux on desktop machines forward by a good bit. It had snapshotting pagers where you could drag your windows around visually between desktops before any of the compositing stuff came around.
18:50:04 <Cale> Oh, and fake translucency effects like drop shadows and translucent terminals before that was really meant to be possible :)
18:50:21 <mm_freak> @karma Everybody
18:50:21 <lambdabot> Everybody has a karma of 0
18:50:28 <Lutin`2> Alright guys time to work out installing archlinux
18:50:34 * ddarius that there was a system for Intensional Type Analysis that had four levels of sorts.
18:50:40 <typoclass> cale: oh no. i googled it and now i'm tempted to hack up the snapshotting thing as an xmonad module =)
18:50:45 <Lutin`2> BRB!
18:50:53 <Lutin`2> hopefully!
18:51:16 <mm_freak> i like the CoC, because it just makes sense
18:51:25 <typoclass> ddarius: why doesn't it have proper levels, only levels of sorts?
18:51:33 <Cale> typoclass: I really really loved my snapshotting iconbox and pager, and I still kinda miss them in Gnome 2.
18:51:39 <mm_freak> instead of having different type levels, you have a single type level with a builtin Set type family
18:51:50 <mm_freak> now every type has itself a type
18:52:13 <mm_freak> 15 : Integer : Set 0 : Set 1 : Set 2 : Set 3 : …
18:52:21 <mm_freak> assuming a right-associative ':'
18:52:29 <typoclass> cale: so a pager is a small proportional representation of all the workspaces (desktops). and an iconbox?
18:52:36 <scshunt> mm_freak: CoC?
18:52:40 <Cale> typoclass: where things go when you minimise
18:52:44 <mm_freak> scshunt: calculus of constructions
18:52:47 <typoclass> ah
18:52:51 <scshunt> mm_freak: thx
18:53:04 <Cale> typoclass: it would screenshot them and shrink them into it nicely
18:53:11 <dolio> That is not a description of the calculus of constructions.
18:54:09 <mm_freak> dolio: i think dependent types are implied by that description
18:54:41 <mm_freak> if you have Int and Set 0 on the same level, then Int -> Set 0 is also on that level
18:54:51 <dolio> It's still not a description of the calculus of constructions.
18:55:08 <mm_freak> what's missing?
18:55:32 <nand`> (polymorphism?)
18:55:50 <mm_freak> nand`: it's there
18:56:18 <dolio> The calculus of constructions doesn't have infinitely many levels, let alone an indexed family of levels.
18:56:52 <mm_freak> dolio: i'm saying it has two levels:  values and types
18:57:50 <mm_freak> and the line between those two levels is very blurry
18:59:28 <dolio> The calculus of constructions has, depending on the presentation, values, types kinds, and then a box that classifies kinds.
18:59:45 <dolio> Sometimes a triangle above box. I've seen that once.
18:59:49 <dolio> But it typically stops there.
19:00:49 <ddarius> My changepoint detection code seems to be working.
19:00:50 <mm_freak> if you want to be pedantic, there is only a single level and infinitely many predefined values (Set n)
19:01:12 <dolio> No, there is no analogue to the Set n you're talking about.
19:01:50 <mm_freak> isn't martin-löf type theory an extension of CoC?
19:01:58 <ddarius> No.
19:01:59 <dolio> No.
19:02:11 <mm_freak> ok, forgive my ignorance
19:02:16 <dolio> Martin-Loef type theory also doesn't have infinitely many universes.
19:02:21 <dolio> Just one.
19:02:28 <dolio> Typically.
19:02:49 <mm_freak> you mean as originally specified by martin-löf?
19:03:05 <dolio> Yeah.
19:03:28 <mm_freak> yeah, but that one is inconsistent
19:03:35 <dolio> I mean, you could keep going, but most presentations don't bother after U.
19:04:34 <mm_freak> and i think i have never heard a name for the calculus with an infinite hierarchy of universes
19:04:46 <dolio> There are many.
19:04:55 <mm_freak> the one that extends type theory
19:05:20 <dolio> Extended calculus of constructions is something Luo defined with infinitely many universes.
19:05:28 <dolio> Calculus of Inductive Construction is what Coq is based on.
19:05:49 <dolio> Luo also has UTT, which is 'universal type theory' or something.
19:06:13 <mm_freak> what's the name of agda's calculus?
19:06:27 <mm_freak> the agda calculus?
19:06:29 <dolio> I don't think anyone gave it a name.
19:06:44 <dolio> It's Martin-Loef type theory plus a bunch of goodies, more or less.
19:07:37 <Nolrai> Has anyone here used unbound?
19:07:54 <dolio> The calculus of constructions is in the same gene pool as System F and the like, though. So it has impredicative quantification, which makes it different from Martin-Loef type theory.
19:08:15 <Nolrai> Wow, I want to talk about the CoC too.
19:08:22 <Nolrai> Huh..
19:08:39 <edwardk> nolrai: yes
19:09:42 <Nolrai> edwardk: what for may I ask? I am trying to figure out if I can use it for the CoC but am having trouble figureing out if/how it can handle variables with a runtime type.
19:10:19 <edwardk> Nolrai: i was using it for a little dependent type checker last year. in the end it wasn't fast enough for what i wanted to do so i wrote a library 'bound' that i use instead for this sort of thing now ;)
19:10:29 <mm_freak> you could call agda's calculus the norell calculus…  but i'm not sure whether this would be fair
19:11:01 <edwardk> 'ulf' sounds more like a random calculus acronym than norell
19:11:18 <mm_freak> System UlF
19:11:38 <edwardk> elf, twelf, ulf, etc.
19:11:44 <mm_freak> one might read that one as System Ultra-F
19:12:20 <Nolrai> edwardk: did you put bound up anywhere?
19:12:28 <mm_freak> but the name norell reminds me of SuSE, which is unfortunate
19:12:29 <edwardk> @hackage bound
19:12:30 <lambdabot> http://hackage.haskell.org/package/bound
19:12:35 <Nolrai> (but I don't really care about speed..)
19:12:42 * hackagebot dual-tree 0.1.0.0 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.1.0.0 (BrentYorgey)
19:13:24 <edwardk> nolrai: i care about a.) speed and b.) ease of use and c.) types that keep you from shooting yourself in the foot
19:13:58 <Nolrai> edwardk: Actually is your dependant typer up anywhere? or any notes/code pieces..it sounds sufficently similar to what I want to do to be useful.
19:14:21 <edwardk> mine never made it anywhere, but dolio has a dependent type system thing he was hacking up with bound
19:14:27 <mm_freak> PolyKinds doesn't apply to type classes?
19:14:37 <edwardk> mm_freak: sure it does
19:14:58 <Nolrai> edwardk: is there a link? or a name? Or do I need to track down dolio?
19:15:08 <ddarius> It's not hard to find dolio...
19:15:13 <mm_freak> for 'class X (a :: a)' it gives me a syntax error
19:15:28 <edwardk> Nolrai: http://code.haskell.org/~dolio/upts/
19:15:33 <edwardk> looks like it references bound
19:15:48 <Nolrai> Arigato!
19:15:52 <edwardk> codolio: might be able to answer more about the state of it
19:16:15 <Nolrai> So does codolio alow me to extract?
19:16:15 <dolio> It does stuff.
19:16:27 <dolio> I think it loads all the files it used to.
19:16:38 <dolio> So at this point I can't recall what it's missing.
19:17:18 <Nolrai> Is there a way to download a who folder like that from a browser?
19:17:27 <ddarius> wget
19:17:29 <dolio> It's a darcs repository.
19:17:42 <Nolrai> Oh..both of those will work!
19:17:45 <Nolrai> Thanks!
19:18:36 <dolio> I think what's missing is type checking/normalization in some ambient context, but somehow I made it work without that.
19:18:41 <mm_freak> anyone know how i can have a class type variable with a polymorphic kind?
19:18:42 <dolio> Maybe by just substituting in.
19:18:59 <edwardk> nolrai: there are 3 worked examples in the examples folder https://github.com/ekmett/bound/tree/master/examples
19:18:59 <mm_freak> is that even possible?
19:19:11 <ddarius> dolio: Is there an evaluator?
19:19:14 <edwardk> Nolrai: also slides: http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less
19:19:25 <dolio> Yes.
19:20:08 <dolio> Wait, maybe I didn't fix it....
19:20:40 <startling> hi, what date/time format should I use?
19:21:07 <dolio> Yeah, looks like it still has problems with type checking things involving previous definitions.
19:21:18 <dolio> And I couldn't settle on something I liked.
19:21:35 <dolio> But the core stuff is there.
19:22:20 <Nolrai> Cool, well we will see If I can get anywhere, but having a leg up makes a huge differnce.
19:22:22 <startling> also, anyone have an example project somewhere using quickcheck and cabal test?
19:22:35 <parcs`> > length "000000001C224A565252524E201E0000"
19:22:36 <lambdabot>   32
19:23:05 <typoclass> startling: for what do you need the date/time format?
19:23:09 <ddarius> Hmm, is the weighted mean of the Gaussian's in a Gaussian mixture the same as the mean of the whole mixture?
19:23:29 <startling> typoclass: dates of blog posts. so they're user-reported and I don't care about leap whatevers
19:25:01 <typoclass> startling: i'd display it as "20:32, 4 Sep 2012" then *shrug*
19:25:27 <startling> oh oops, I don't mean "format"
19:25:46 <startling> I mean "what type and associated functions should I use to deal with times for this thing?"
19:26:36 <ddarius> Wait, I'm an idiot.  E is linear.
19:29:45 <typoclass> startling: i see. i'd consider if i can get away with using a plain String. that'd work if it's just fed in, stored, and then displayed somewhere. if you want to do more, e.g. sort by dates, then you likely won't get away with a String and need a proper ZonedTime or UTCTime (from Data.Time)
19:30:38 <startling> yeah, I need to be able to sort by date. Hm, is there something analogous to unix time?
19:30:38 <otters> @pl \f g x -> f x (g x)
19:30:38 <lambdabot> ap
19:30:44 <otters> @pl \f g x -> f (g x) (g x)
19:30:44 <lambdabot> join . liftM2
19:30:58 <typoclass> startling: there's a parsing facility. you give it a bizarre format string like "%a, %d/%b/%y" or whatever, and the String from the user, and it will try to make a ZonedTime (UTCTime)
19:31:08 <otters> @pl \f g h x -> f x (g x (h x))
19:31:08 <lambdabot> (. ap) . (.) . ap
19:31:17 <typoclass> (it's bizarre, but documented)
19:31:30 <startling> typoclass, is it strptime format?
19:31:44 <typoclass> startling: yeah, or something very similar
19:31:49 <startling> yeah, I
19:31:54 <startling> 'm familiar with that. thanks!
19:32:24 <ddarius> @hoogle first
19:32:24 <lambdabot> Data.Monoid First :: Maybe a -> First a
19:32:24 <lambdabot> Data.Monoid newtype First a
19:32:24 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
19:32:45 <otters> why doesn't command-line lambdabot's @pl work?
19:33:00 <otters> It just hangs forever :(
19:33:51 <typoclass> startling: heads-up -- doing stuff with Data.Time is usually fairly simple in the end, but it takes forever to figure anything out from the haddocks :-) so asking in here is probably quicker
19:34:54 <startling> typoclass: thanks.
19:40:23 <Cale> otoh, as someone who is being paid to maintain poorly written code dealing with times and dates, if you're not at least 90% as smart as Ashley Yakeley, you should probably never be allowed anywhere near code that deals with times and dates. :)
19:42:00 <ddarius> Yay!  Cale's being paid.
19:42:31 * geekosaur remembers parsedate.y.  date handling suuuuuuuuucks
19:43:47 <ReinH> Can someone explain this pointfree output please?
19:43:49 <ReinH> @pl prop_readSquare square = (readSquare . showSquare) square == return square
19:43:49 <lambdabot> prop_readSquare = ap ((==) . readSquare . showSquare) return
19:43:55 <ReinH> I think I understand ap but...
19:44:04 <Cale> ap f g x = f x (g x)
19:44:05 <typoclass> Cale: right, it's complex and subtle
19:44:36 <vwvwvwv> ap is the S combinator?
19:44:40 <Cale> yes
19:44:51 <Cale> (generalised)
19:45:00 <Cale> :t ap
19:45:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:45:28 <Cale> Take m = (->) e, and you get  ap :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
19:45:53 <vwvwvwv> very interesting, thank you
19:45:54 <ddarius> vwvwvwv: So S corresponds to (<*>) and K corresponds to pure so you can define bracket abstraction to an arbitrary applicative functor.
19:46:14 <ReinH> so this is the function instance of monad?
19:46:22 <Cale> ReinH: yes, that's right :)
19:46:28 <ReinH> Cale: fucking magical :)
19:46:36 <Cale> > join (*) 5
19:46:36 <ReinH> Cale: where is the function instance defined?
19:46:37 <lambdabot>   25
19:46:45 <Cale> ReinH: Control.Monad.Instances should have it
19:46:54 <avpx> return is the K-combinator, I believe
19:46:57 <Cale> there are a bunch of other things which happen to export it
19:46:57 <avpx> > return 1 2
19:46:58 <lambdabot>   1
19:47:04 <Cale> yes, return and pure are both K
19:47:14 <Cale> (of course, they're the same thing)
19:47:19 <avpx> Ah, I see ddarius mentioned that above.
19:47:22 <Cale> Applicative can be viewed as a generalisation of the SK calculus
19:47:27 <ReinH> return is const
19:47:50 <typoclass> > 1 2
19:47:51 <lambdabot>   1
19:48:44 <Cale> Actually, I've never thought about this -- do any of the traditional combinators correspond to bind?
19:49:06 <ddarius> Cale: I think it would be S'.
19:49:21 <ddarius> Since it works out to just flip ap
19:49:36 <ReinH> Cale: I'm trying to come up with a plain english way of explaining the use of ap there
19:50:10 <ddarius> :t (<*> pure)
19:50:11 <lambdabot> forall b a (f :: * -> *). (Applicative f) => (a -> f a -> b) -> a -> b
19:50:15 <Cale> ReinH: ap can be thought of as a fundamental way to duplicate the use of a parameter
19:50:33 <avpx> Another thought: you can substitute just one combinator for S and K, iota u = u S K
19:50:40 <avpx> Is there an equivalent for that in Haskell?
19:51:00 <Cale> ReinH: since square occurred twice in your expression, you can bet that @pl is going to use the Monad instance for functions somehow.
19:51:07 <ReinH> heh :)
19:51:25 <ddarius> avpx: If you expand S and K that fails to be a combinator though it is occasionally referred to as a pseudocombinator.
19:51:52 <avpx> Hmm, I wasn't aware of that
19:51:55 <ddarius> What @pl does is basically a fancy bracket abstraction.
19:53:02 <typoclass> > (ap (==) reverse) "radar" -- ReinH: checking for palindromes
19:53:03 <lambdabot>   True
19:53:25 <ReinH> typoclass: thanks
19:54:01 <ddarius> > ap(++)show"ap(++)show"
19:54:03 <lambdabot>   "ap(++)show\"ap(++)show\""
19:54:08 <ReinH> so ap (==) f is \x -> x == f x
19:54:11 <typoclass> oh, you can actually leave out the parens in this version. with <*> they're necessary
19:55:06 <scshunt> haskell needs more levels of precedence
19:55:11 <scshunt> so more things can be expressed without parens
19:55:26 <scshunt> we also need a syntax for reversing the precedence of an operator for the same reason
19:56:26 <sellout42> scshunt: I can never remember precedence anyway, so I use a lot of parens. I write in something like a lispy-Haskell, I suppose.
19:57:13 <typoclass> ReinH: yes. as cale said, ap f g x = f x (g x). or in english, ap takes two functions, stuffs the argument value into the right function, and to the left function feeds both the right's result and the original value
19:57:42 <Cale> sellout42: There's really only one precedence rule which is important to remember, which is that function application binds tighter than any infix operator.
20:01:55 <Saizan> which are some good and short examples of laziness other than numeric sequences and if/then/else ?
20:04:41 <Cale> Saizan: any (isPrefixOf needle) (tails haystack)
20:05:20 <latro`a> anything involving Maybe ever
20:05:20 <Cale> Saizan: Also, there are a few somewhat more involved examples in "Why Functional Programming Matters"
20:05:32 <mlh> or reading a file?
20:05:41 <Cale> Maybe can be useful in a strict setting...
20:05:49 <lispy> sellout42: hmm...I think my style is pretty standard. Not a lot of parens.
20:05:52 <vwvwvwv> ddarius: thank you for that, you just gave me something to think about for a while :)
20:05:52 <latro`a> sure, but that's not what I meant
20:05:58 <latro`a> Nothing >>= _ = Nothing
20:06:07 <latro`a> ^extremely lazy, and can result in a whole bunch of computation not happening
20:06:08 <vwvwvwv> I needed it
20:06:28 <latro`a> arguably that's equivalent to if/then/else, though
20:06:36 <sellout42> lispy: Hah!
20:06:42 <latro`a> but it hides it
20:06:55 <Cale> latro`a: uh, but even in a strict evaluator, so long as it doesn't evaluate under unapplied lambdas, the Maybe monad will still be "lazy" enough to work
20:07:19 <lispy> sellout42: but I know what you mean. Knowing precedence is nice, but if you switch languages frequently it's hard to keep it all straight
20:07:27 <typoclass> > let evens = 0 : map (+1) odds; odds = map (+1) evens in (take 10 evens, take 10 odds) -- Saizan, you'll probably count it as a numeric sequence, but i liked this one
20:07:28 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18],[1,3,5,7,9,11,13,15,17,19])
20:07:41 <Cale> Think about if there was some function in the right parameter to >>= there, even if it was evaluated, it'd probably almost immediately be a lambda.
20:08:02 <latro`a> even if there wasn't, the function doesn't get evaluated, nor does any of its contents
20:08:12 <Saizan> typoclass: yep, i have that one already :)
20:08:23 <latro`a> my point is that if you have something like
20:08:30 <Cale> Saizan: The idiom of using zip [0..] to number the elements of a list :)
20:08:31 <Saizan> Cale: thanks, i had forgotten about whyfp
20:08:33 <latro`a> do {x <- someCheapQuery; y <- someExpensiveQuery}
20:08:38 <latro`a> and someCheapQuery is actually Nothing
20:08:43 <latro`a> someExpensiveQuery never happens
20:08:58 <sellout42> lispy: Indeed. And I (usually) get paid to write Lisp, so I'm used to parens and not caring about precedence. Although, currently I'm getting paid to write Haskell (and Haskell-like stuff), so maybe I'll go back to lisp frustrated about parens *shrug*
20:08:59 <Cale> Yes, but that's not a property of laziness, is it?
20:09:11 <latro`a> eh, it kinda is, in that it requires >>= to be a lazy function
20:09:31 <Cale> someCheapQuery >>= (\x -> someExpensiveQuery >>= \y -> return (x,y))
20:09:45 <Cale> If someCheapQuery gives Nothing, then the lambda can't be applied
20:09:52 <Cale> and someExpensiveQuery will never be computed
20:10:02 <latro`a> sure, but you also never evaluate the *contents* of the lambda
20:10:05 <Cale> Even under strict evaluation
20:10:43 <Cale> (In fact, lazy and strict evaluation will be identical here, because there's only one redex)
20:11:16 <latro`a> as I said, this doesn't really require laziness, since you can evaluate the function, and since you never apply it, its contents don't get executed
20:11:38 <Cale> okay, I think we're just agreeing with each other then :)
20:11:49 <latro`a> more or less, I just think this is still lazy-ish
20:11:56 <latro`a> it would work with strictness, but it is a lazy *idea*
20:12:16 <Cale> I guess the whole idea of not evaluating underneath lambdas is kinda lazyish to begin with
20:12:20 <latro`a> the idea that the output of a function can be dependent on a proper subset of its arguments
20:12:30 <latro`a> *only on
20:13:12 <latro`a> is a lazy idea, even if it can be simulated in a strict setting
20:14:15 <latro`a> anyway
20:14:23 <latro`a> returning to more legitimately lazy things
20:28:00 <dolio> edwardk: What's the purpose of this Any type that inhabits all kinds again?
20:28:28 <edwardk> they desugar polymorphic stuff to it as i recall
20:29:36 <dolio> Apparently eta is not in the cards currently.
20:29:54 <dolio> Quite annoying.
20:30:06 <edwardk> was there an update?
20:30:51 <edwardk> ah andrea killed it
20:30:52 <dolio> Someone showed that assuming an eta rule is unsound, because you can write a type family that distinguishes Any and (Fst Any, Snd Any).
20:31:06 <dolio> Since the first has constructor Any and the second has constructor (,).
20:32:47 <ddarius> That's very similar to an exercise in "Lectures on the Curry-Howard Isomorphism"
20:33:15 <Tekmo> How do you fix the "Could not find link destinations" think for haddock?
20:33:20 <Tekmo> I know it's not important, but it annoys me
20:34:17 <Clint> edwardk: is there an easy way to export TH-generated lenses?
20:34:33 <edwardk> Clint: ah because you can't write them in the export list?
20:34:54 <Clint> well, i could write them by hand
20:35:08 <edwardk> hrmm
20:35:39 <edwardk> i could actually work on the TH code generator for makeClassy to make sure it puts all of them inside of the class. then you could use makeClassy ''Foo
20:35:42 <edwardk> and just export HasFoo(..)
20:35:57 <edwardk> right now it puts them outside of the class
20:36:21 <edwardk> this doesn't help non-classy lens generation though
20:36:34 <Clint> well, it's not that important
20:36:40 * ddarius needs to apply signal processing to his signal processing output.
20:37:09 <edwardk> i'll leave it as a feature request for mgsloan ;)
20:37:41 <edwardk> and see if it makes sense to get it in for 2.7
20:43:30 <Tekmo> edwardk: What is the speed cost for using lenses?
20:43:36 <Tekmo> I've never actually benchmarked it
20:43:50 <edwardk> with -O2 very little to nothing
20:43:57 <Tekmo> Awesome
20:44:04 <edwardk> in fact the lens based uniplate combinators are faster than uniplate
20:44:10 <edwardk> by about 30%
20:44:45 <edwardk> (when using the Data -based traversals)
20:50:17 * ddarius guesses he can just use a very simple high pass filter to get what he wants.
20:51:26 <ReinH> so ap makes sense now
20:51:27 <ReinH> thanks everyone
20:55:19 <Saizan> dolio: one use of Any is to fill in unconstrained meta-ty-vars that don't get generalized
20:56:05 <ivanm> @ask dcoutts is there any way to have "cabal test" spit everything out like it used to pre 0.14? I find it a little odd to have no output and not know whether it's frozen or just churning merrily along
20:56:06 <lambdabot> Consider it noted.
20:57:11 <dolio> Yeah, that's true. Its existence is really inconvenient, though.
20:57:20 <dolio> At least, inhabiting data kinds.
20:58:46 <Saizan> yep, i'd tend to seek ways to get rid of it
20:59:20 <Saizan> or keep it :: ... -> *
21:01:50 <nolrai> Yo, "ghc -Wall -hide-package mtl --make "%f" -outputdir ../bin -dumpdir ../dump -ddump-to-file -ddump-ds -ddump-stg -dsuppress-uniques" should create a execuible when run on a file containing the Main module right?
21:02:57 <nolrai> (the %f is from my text editor, just means the file it is run on.)
21:03:00 <ivanm> "Yo" ?
21:03:18 <ivanm> nolrai: but yes, in ../bin
21:03:19 <Saizan> btw, i didn't expect "type family Test (a -> Maybe a) :: *; type instance Test 'Just = ()"
21:03:26 <Tekmo> Just out of curiosity, why are you hiding the mtl package?
21:03:37 <ivanm> Tekmo: monads-tf ?
21:03:53 <nolrai> Tekmo: ivanm
21:04:00 <ddarius> Saizan: Nice.
21:04:00 <Tekmo> Got it
21:04:24 <ivanm> though Cabal + project-specific .ghci files can help with that
21:06:53 <nolrai> ivanm: huh..the exe apeares to be in my src directory..how odd.
21:06:54 <edwardk> wait, someone is still trying to use monads-tf? *sigh*
21:07:06 <nolrai> edwardk: is it bad?
21:07:09 <SHACHAF> edwardk: Why do you hate type families? :-(
21:07:15 <edwardk> nolrai: terrible
21:07:20 <edwardk> SHACHAF: i love type families.
21:07:22 <ivanm> nolrai: -outputdir might only be for .o and .hi files rather than generated binaries
21:07:33 <ivanm> edwardk: so what's wrong with monads-tf ?
21:07:41 <ivanm> just that we should let mtl win?
21:07:53 <nolrai> ivanm: hmm, that makes sense.
21:07:53 <edwardk> the problem with monads-tf is that is tromples on the same module names as the mtl. so when you use it you wind up becoming incompatible with the entire damn ecosystem
21:08:07 <edwardk> ivanm: no. but monads-tf isn't the path to victory
21:08:21 <edwardk> if it had the same code in different module names i wouldn't complain
21:08:21 <ddarius> I never wanted anyone to use my code anyway.
21:08:26 <ivanm> ddarius: heh
21:08:28 <Tekmo> Yeah
21:08:31 <Tekmo> Usually you use mtl or transformers
21:08:37 <Tekmo> which respect each other's namespaces
21:08:38 <ivanm> ddarius: _really_ working on the "no success" path :p
21:08:54 <ivanm> Tekmo: well, you'd hope they would since mtl uses transformers :p
21:09:14 <edwardk> transformers is the basis for monads-tf, but monads-tf is really part of an old design, where ross originally intended folks to be able to choose between the two, but it just had the impact of splintering the community three ways between mtl, monads-fd, and monads-tf.
21:09:17 <edwardk> and it was awful
21:09:20 <WhoNeedszzz> Hey guys
21:09:28 <ivanm> edwardk: yeah
21:09:34 <edwardk> so we merged mtl and monads-fd, and monads-tf was left to die a lonely death
21:09:44 <Tekmo> Well
21:09:46 <Tekmo> What you should do
21:09:52 <Tekmo> is find the packages that depend on monads-tf
21:10:01 <Tekmo> and just go through them and urge their maintainers to switch
21:10:06 <ivanm> if you want to be evil, use GHC's PackageImports extension :p
21:10:12 <edwardk> if its contents were shifted into another package, and moved so they didn't collide with the module names from monads-fd then you'd be fine
21:10:17 <Tekmo> And then clearly mark monads-tf as obsolete and document the reason hwy
21:10:20 * ivanm waves idly in WhoNeedszzz's general direction
21:10:21 <edwardk> ivanm: that "cure" is worse that the disease
21:10:30 <ivanm> edwardk: I did say "evil", right?
21:10:41 <SHACHAF> ghcevil, v2.0 of ghclive
21:10:43 <WhoNeedszzz> I'm just learning Haskell so please bear with me :)
21:10:46 <ivanm> SHACHAF: heh
21:10:54 <ivanm> @quote learn.*haskell
21:10:55 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
21:10:55 <lambdabot> of insight hits and it all makes sense.
21:11:06 <ivanm> was hoping for Cale's statement about still learning haskell...
21:11:09 <edwardk> Tekmo: it was documented a couple years ago in the libraries discussions when we killed it, but i don't think the parties involved were eager to go chase down and antagonize the few remaining users of monads-tf ;)
21:11:11 <ivanm> @quote Cale learn.*haskell
21:11:11 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
21:11:13 <ivanm> bah
21:11:28 <WhoNeedszzz> I'm trying to compute the highest power of num1 that divides num2. I've tried the following function, but it isn't working. http://ideone.com/kfLGC
21:11:40 <startling> is there something simple somewhere that will parse "a: b" lines into a [(String, String)]?
21:11:47 <Tekmo> edwardk: At the very least, the package documentation should clearly note the problems with using it
21:11:48 <edwardk> oh, btw- tekmo you might find github.com/ekmett/indexed interesting
21:11:56 <startling> I'd rather not have to depend on parsec for this project but you know
21:11:57 <ivanm> startling: use Data.List.split ?
21:12:10 <startling> ivanm: that's promising.
21:12:11 <edwardk> Tekmo: alas monads-tf is maintained by ross, you can send him an email and in 6 months it may happen
21:12:19 <ivanm> or if you want some kind of parser combinator, there's ReadP
21:12:22 <Saizan> > break (==':') "a: b"
21:12:22 <ivanm> that comes with GHC
21:12:23 <lambdabot>   ("a",": b")
21:12:34 * ddarius can detect falling edges extremely confidently (which isn't surprising) but rising edges are harder.
21:12:46 <edwardk> but the package has been rotting for 2 years since it was determined to be a bad idea ;)
21:13:03 <Saizan> i'm surprised it still builds
21:13:13 <SHACHAF> But type families are so much nicer, man.
21:13:15 <ivanm> WhoNeedszzz: how isn't it working?
21:13:29 <Clint> mport Network.HTTP.Types (headerContentType, Method, RequestHeaders, unauthorized401)
21:13:29 <startling> ivanm: interesting, thanks
21:13:35 <Clint> argh
21:13:37 <ivanm> SHACHAF: except for when you want GeneralizedNewtypeDeriving
21:13:37 <edwardk> SHACHAF: type families are fine, i don't happen to like them for the mtl, because i find that the code is universally more verbose in TF style
21:13:45 <edwardk> for this particular case
21:13:45 <WhoNeedszzz> ivanm, Say given highestPowerDivisor 2 50 it should return 1, but it returns 0
21:13:45 <ivanm> startling: np
21:13:51 <edwardk> for other things, i love them
21:14:08 <ivanm> WhoNeedszzz: you need to pass power around
21:14:29 <ivanm> I suggest having a helper function inside a where clause for highestPowerDivisor which just takes the power
21:14:37 <edwardk> you're trading in saving 2 characters on each use of MonadState for writing 'StateType ' somewhere else in the type signature
21:14:43 <SHACHAF> WhoNeedszzz: The only thing that function can ever return is 0.
21:14:47 <ivanm> and defaults to 0 (since you _know_ that x^0 divides everything)
21:14:49 <edwardk> if you only reference the state type once, that means you pay 8 characters per signature
21:14:49 <SHACHAF> (If it returns at all.)
21:15:02 <Tekmo> edwardk: I can tell you that I'm am actually eventually switching to not using indexed types in a future pipes release
21:15:06 <ivanm> WhoNeedszzz: remember, no global variables!
21:15:12 <WhoNeedszzz> right
21:15:12 <Tekmo> edwardk: I found a satisfactory finalization solution for ordinary monads
21:15:18 <WhoNeedszzz> Like I said, just learning Haskell, heh
21:15:27 <edwardk> Tekmo: good. honestly the indexed stuff was part of why we were scared away from pipes here ;)
21:15:28 <ivanm> SHACHAF: yeah, infininite loops are _fun_
21:15:42 <Tekmo> edwardk: There is only one deficiency with ordinary approach
21:15:44 <hpaste> XexonixXexillion pasted “Halp, ffi segfaults” at http://hpaste.org/74225
21:15:45 <ivanm> oh, right, you need to pass num1 around as well
21:15:47 <SHACHAF> >  "inf" ++ cycle "in"
21:15:49 <lambdabot>   "infininininininininininininininininininininininininininininininininininini...
21:15:51 <edwardk> Tekmo: i just started packaging it up because i wound up needing a lot of indexed monads for working with 'bound' with types
21:16:01 <Tekmo> edwardk: Which is that you can't auto-run the finalizers.  At best, you can collect them and then run the collection
21:16:02 <ivanm> WhoNeedszzz: also, num2 `mod` num1 reads nicer than mod num2 num1
21:16:11 <XexonixXexillion> I keep getting segfaults in my haskell code (the equivalent c works fine)
21:16:23 <avpx> XexonixXexillion: Segfaults? What in the world are you doing?
21:16:25 <SHACHAF> XexonixXexillion: I suspect the C is not actually equivalent.
21:16:33 <avpx> Hah.
21:16:37 <Tekmo> edwardk: It looks something like: runFinalizers (p1 <-< p2 <-< p3)
21:16:57 <Tekmo> edwardk: However, the bonus feature from switching to ordinary monads
21:17:08 <Tekmo> edwardk: Is that you can now also suspend and reinitialize upstraem and downstream
21:17:10 <edwardk> one of these days i'll need to get finalizer and resource management into machines
21:17:14 <Tekmo> edwardk: And that is instantaneous
21:17:21 <XexonixXexillion> SHACHAF: No, but the calls to the imported c functions are the same
21:17:36 <Tekmo> edwardk: Another advantage is that
21:17:39 <SHACHAF> XexonixXexillion: I have a strong suspicion that something is different.
21:17:43 <Tekmo> edwardk: You can now add debugging statements to pipes, too
21:17:49 <SHACHAF> Evidence: Your Haskell code is segfaulting and your C code isn't.
21:17:52 <Tekmo> edwardk: So you can observe the state of the pipeline at the point of termination
21:18:22 <Tekmo> edwardk: I'm splitting these features into 3 releases
21:18:27 <Tekmo> edwardk: The first release will be this week
21:18:30 <ivanm> SHACHAF: thought you were saying something to someone called Evidence at first :p
21:18:30 <nolrai> hmm. Is there a way to redirect where ghc puts the executable?
21:18:41 <ivanm> nolrai: must be, because Cabal does it
21:18:53 <Tekmo> edwardk: It's the most interesting one because I found a way to send information upstream and still form a category
21:18:55 <edwardk> sounds fun
21:19:09 <edwardk> sounds like the model i used to use before machines
21:19:19 <edwardk> i had bidirectional protocols
21:19:32 <edwardk> that gave you the upstream communication path
21:19:33 <Tekmo> edwardk: I proved the category laws for this one
21:19:48 <ivanm> OK, the ghc man page _sucks_
21:19:51 <Tekmo> edwardk: I have it one github.  I'll link it and you can compare to what you wrote
21:20:00 <ivanm> "see for details ..." <-- wtf does that mean?
21:20:10 <nolrai> ivanm: grr. cant find it in the ghc doctumentation..
21:20:17 <ivanm> nolrai: you could always use -o
21:20:19 <XexonixXexillion> SHACHAF: I think the bug is in the ffi, I also got an error when I aded a few random print lines which was "schedule: re-entered unsafely"
21:20:31 <ivanm> actually, that's probably what Cabal does as you specify an executable name as well
21:20:33 <Evidence> XexonixXexillion: Are you doing foreign import "unsafe"?
21:20:36 <ddarius> ivan`: Probably supposed to be a link that didn't render.
21:20:45 <ivanm> ddarius: hmmm, possibly
21:20:46 <ddarius> ivanm: It's better than ghc --help at least.
21:20:49 <ivanm> heh
21:20:50 <ivanm> yeah
21:21:04 <XexonixXexillion> The code is on hpaste, but no, they're all safe
21:21:25 <Evidence> XexonixXexillion: Oh, I didn't see that.
21:21:33 <Tekmo> https://github.com/Gabriel439/Haskell-Pipes-Library/blob/adapter/Control/Proxy.hs
21:21:55 <ivanm> Evidence: smart arse
21:21:56 <Evidence> Aligned allocs and mprotect? What are you doing?
21:22:07 <SHACHAF> ivanm: That's some good evidence!
21:22:19 <ivanm> SHACHAF: what, that you're a smart arse? :p
21:22:37 <Saizan> XexonixXexillion: try changing those safe with unsafe
21:22:52 <XexonixXexillion> I'm doing aligned allocs and mprotect :p
21:23:02 <WhoNeedszzz> ivanm, I'm not sure what you mean about using a helper function in a where clause
21:23:26 <ivanm> WhoNeedszzz: OK, just define a separate helper function
21:23:31 <ivanm> not necessarily in a where clause
21:23:45 <XexonixXexillion> it's not actually important for anything, I just want to know why it doesn't work as opposed to just accepting that it doesn't
21:23:52 <Evidence> XexonixXexillion: Maybe this is interfering with GHC's allocator somehow?
21:24:00 <Evidence> I think they should work together, though...
21:24:08 <Evidence> ByteString malloc()s its memory, after all.
21:25:01 <Evidence> XexonixXexillion: Oh. Maybe you just need to unprotect the memory before freeing it?
21:25:43 <Saizan> ok, unsafe wouldn't help.
21:26:18 <WhoNeedszzz> ivanm, I still don't know what to do. I don't know how to think functionally yet
21:26:22 <Evidence> XexonixXexillion: It works fine here if I allocate a page (4096 bytes) instead of 512 bytes.
21:26:33 <carter> Tekmo: I look forward to the release :)
21:26:36 <ivanm> WhoNeedszzz: it has nothing to do with thinking functionally
21:26:48 <carter> the work on pipes et al (and Machines)
21:26:48 <Tekmo> The bidirectional stuff will be this week
21:26:48 <ivanm> you just want to use a second function that takes in the two numbers as _well_ as the power
21:26:56 <carter> has been pretty awesome in the past year
21:26:57 <Tekmo> The next release
21:26:58 <carter> cool
21:27:00 <Tekmo> is pipe transformers
21:27:06 <carter> and what'll those be?
21:27:06 <Tekmo> which will include parsing and error handling
21:27:08 <WhoNeedszzz> ivanm, Oh i see
21:27:29 <Tekmo> Basically, it's a way to automatically extend pipes with outer monad transformers and still lift composition correctly
21:27:35 <Evidence> XexonixXexillion: I think if you're mprotecting a page, you'd better make sure the whole page is yours to mess with.
21:27:51 <Tekmo> The third release will be finalization, suspension, and reinitialization
21:27:52 <Evidence> XexonixXexillion: I'm gueesing what's going on is that it allocates 512 bytes inside a page that's used for something else by GHC's allocator.
21:28:15 <Tekmo> for ordinary monads
21:28:17 <Evidence> XexonixXexillion: Then you're protecting the whole page and GHC's allocator gets confused when it tries to write to it.
21:28:18 <Tekmo> and probably removing frames
21:28:19 <DMWIT> In the expression "f x y z", is there a halfway decent name that I could use that would clearly refer to "f", "x", and "y", but not "z"?
21:28:25 <DMWIT> ...or short phrase
21:28:38 <XexonixXexillion> Evidence: and now I just get schedule: re-entered unsafely
21:28:38 <Evidence> XexonixXexillion: Something similar would probably happen in a larger C program that did a bunch more allocations.
21:28:50 * BMeph likes "fXY"...
21:28:57 <carter> Tekmo: on a related note: earlier you and edwardk were talking about having the internals be CPS or not
21:29:04 <Tekmo> If all those go well, I'll just focus on optimizing using rewrite rules and then fleshing out a standard library
21:29:08 <Tekmo> Oh
21:29:09 <Evidence> XexonixXexillion: I haven't managed to get that...
21:29:10 <XexonixXexillion> Evidence: well, on the rest of the program I haven't posted
21:29:15 <Evidence> Oh.
21:29:18 <carter> was it that Pipes can't, or that it'd be hairirer to right?
21:29:18 <XexonixXexillion> Evidence: sorry for the confusion
21:29:19 <DMWIT> BMeph: If I hadn't used the exact example expression "f x y z", would that name have made any sense...?
21:29:27 <Tekmo> carter: So the idea is that CPS makes some things faster and some things slower
21:29:27 <carter> *write correctly
21:29:39 <Evidence> XexonixXexillion: If you always allocate at least one page instead of 512 bytes, does it still happen?
21:29:43 <Tekmo> carter: It makes composition slower because composition is biased towards the head of the free monad
21:29:45 <carter> edwardk was saying that composition is asymptotically slower?
21:29:48 <carter> ok
21:29:51 <Tekmo> carter: but it makes the monad instance faster
21:29:53 <carter> vs whats faster?
21:29:55 <DMWIT> BMeph: I'm writing a data type for an AST and have a distinction between the first bits of an expression and the final argument, and I'm trying to name the type that the first bits inhabit.
21:29:58 <carter> how so?
21:30:03 <edwardk> carter: in my case it was that i chose to divide things betwee what works fast in cps and what works fast directly, and then only allow the fast compositions
21:30:04 <Evidence> hi newsham
21:30:14 <Tekmo> It's mainly if you have something like
21:30:23 <XexonixXexillion> Evidence: now when I poke the memory, haskell throws the error instead of going to my signal handler
21:30:24 <Tekmo> do { x <- someLongFreeMonad; somethingelse }
21:30:31 <Tekmo> in order to bind somethingElse after the long free monad
21:30:37 <Tekmo> you have to retraverse the entire long free monad
21:30:44 <edwardk> so plans are cps'd and support >>= but machines are direct style and support (.). when you go to support both like tekmo does you have a problem, because you can make >>= suck, which is what pipes does ;) or you can make (.) suck ;)
21:30:44 <Tekmo> This normally doesn't occur much for typical code
21:30:47 <ddarius> Changepoint detection: http://imm.io/D9DQ
21:30:49 <carter> and whats the free monad in this case?
21:30:51 <Evidence> XexonixXexillion: I don't see any signal handlers or memory-poking. :-)
21:30:57 <Tekmo> Pipes/machines
21:31:01 <Tekmo> Are based on free monads
21:31:12 <Tekmo> Edward is a CPS-style free monad
21:31:16 <Tekmo> Pipes is non-CPS free monad
21:31:25 <carter> ok, i'm thinking Free as in abstract thing
21:31:28 <carter> a la algebra
21:31:32 <Tekmo> Oh
21:31:35 <carter> which doesn't help here :)
21:31:38 <Tekmo> It has a very specific meaning in the Haskell community
21:31:39 <carter> a la free groups
21:31:44 <carter> wheres the definition?
21:31:47 <edwardk> carter: its free, its the free monad for its f-algebras
21:31:52 <Tekmo> Check out the "free" package
21:31:57 <avpx> Is "free monad" quite distinct from the idea of a free structure in algebra?
21:32:00 <hpaste> XexonixXexillion pasted “re-entered unsafely” at http://hpaste.org/74227
21:32:07 <Tekmo> A free monad is a list of functors
21:32:09 <ddarius> avpx: No.
21:32:10 <Tekmo> in Haskell terminology
21:32:11 <DMWIT> carter: Yes, it's free in the sense of free algebra.
21:32:12 <edwardk> i give a set of definitions of why the free monads are free in the free monad documentation
21:32:21 <Tekmo> data Free f r = Free (f (Free f r)) | Pure r
21:32:22 <DMWIT> Tekmo: what
21:32:34 <Tekmo> That's the Haskell free monad
21:32:40 <Evidence> XexonixXexillion: You really ought to be pasting all your imports. :-(
21:32:42 <DMWIT> Tekmo: That is not a list of functors.
21:33:00 <DMWIT> And the specific meaning it has in the Haskell community comes from the specific name it has in algebra/category theory. =P
21:33:02 <Tekmo> It is when viewed in the domain of natural transformations
21:33:06 <edwardk> carter: http://hackage.haskell.org/packages/archive/free/3.1.1/doc/html/Control-Monad-Free.html gives the motivation for why it is free
21:33:12 * ddarius would recommend the more precise phrase "free monad generated from a functor (/signature)"
21:33:12 <XexonixXexillion> sorry, I forgot you didn't see the original one
21:33:16 <carter> edwardk: ok , I think i got it
21:33:20 <Tekmo> Free :: f ~> Free f, analogous to Cons
21:33:21 <Evidence> XexonixXexillion: (I'm SHACHAF.)
21:33:35 <Tekmo> Pure :: () ~> Free f, analogous to Nil
21:33:44 <Tekmo> Oops, sorry
21:33:51 <Tekmo> I wrote the one for Free wrong
21:33:54 <Tekmo> that should have been liftF
21:33:56 <Evidence> XexonixXexillion: Anyway, that program runs for me.
21:33:57 <Tekmo> which is equivalent to singleton
21:34:05 <Tekmo> Free is
21:34:07 <edwardk> its provably left adjoint to the forgetful functor that forgets the monad structure for a functor f and just leaves you the functor ;)
21:34:09 <XexonixXexillion> Evidence: What does it do?
21:34:09 <Evidence> XexonixXexillion: Oh, but it's not poking the memory.
21:34:19 <Tekmo> Free :: f x (Free f) ~> Free f
21:34:20 <edwardk> free functors are left adjoint to forgetful functors, thats all there is to them
21:34:21 <XexonixXexillion> Evidence: derp
21:34:35 <XexonixXexillion> Evidence: copying and pasting from my terminal is difficult
21:34:38 <Tekmo> In fact
21:34:42 <Tekmo> I even went all the way to prove this
21:34:46 <Tekmo> by defining free monad comprehensions
21:34:48 <Tekmo> using index-core
21:34:53 <ddarius> edwardk: Baez defines a free functor as "a functor."
21:34:57 <Evidence> How do you poke?
21:34:59 <edwardk> ddarius: haha
21:35:00 <ddarius> Sorry, a forgetful functor.
21:35:25 <liyang> ddarius: I see what you did there.
21:35:31 <hpaste> XexonixXexillion annotated “re-entered unsafely” with “re-entered unsafely (annotation)” at http://hpaste.org/74227#a74228
21:35:32 <DMWIT> Maybe I'll just use "pre-arguments".
21:35:32 <avpx> Hah.
21:35:40 <carter> Ok, I'm going to have to chew on this
21:35:55 <carter> and also be thankful for the fact I ordered maclane last week to up my CT fu
21:35:55 <Evidence> XexonixXexillion: Still doesn't have all your imports. :-)
21:35:59 <Evidence> (Foreign.Ptr and all that.)
21:36:19 <ddarius> The notion of "essentially k-surjective" is needed to facilitate differentiating different "kinds" of "forgetful" functors.
21:36:43 <dolio> ddarius: That's no good. It should be a functor with a left adjoint, no?
21:37:04 <edwardk> ddarius: from this http://math.ucr.edu/home/baez/qg-spring2004/discussion.html ?
21:37:05 <ddarius> carter: Categories for the Working Mathematician would be better if it was a bit more "reference" geared.
21:37:10 <dolio> Actually, that's probably no good either.
21:37:15 <hpaste> XexonixXexillion annotated “re-entered unsafely” with “re-entered unsafely (annotation) (annotation)” at http://hpaste.org/74227#a74229
21:37:24 <dolio> Since for cofree, you want it to have a right adjoint.
21:37:30 <carter> I've got a few other algebra books,
21:37:44 <carter> I need to see the work in the wild
21:37:45 <carter> :)
21:37:50 <Tekmo> Well
21:37:56 <Tekmo> pipes is a free monad in the wild
21:38:06 <ddarius> edwardk: I wasn't referring to that article in particle, but those are the topics, yes.
21:38:38 <carter> Tekmo: I mean lots of CT in action
21:38:40 <XexonixXexillion> Evidence: is that better?
21:38:46 <Tekmo> Well
21:38:54 <carter> hence
21:38:54 <Tekmo> Check out pipe transformers, too, when they come out
21:39:01 <Tekmo> lots of functor goodness going on in that release
21:39:08 <carter> Tekmo I'll be checking out irrespective of that
21:39:21 <carter> but I may as well leverage my math background to see lots of other CT language
21:39:31 <carter> 'cause bread of context helps with depth of understanding :)
21:39:35 <carter> *breadth
21:40:31 <Tekmo> Alright, I'll see you guys later
21:41:15 <Evidence> XexonixXexillion: Are you sure you're supposed to be able to do signal handling like that?
21:41:42 <XexonixXexillion> Evidence: Yeah, at least I am in C
21:41:55 <Evidence> XexonixXexillion: Yes, but this isn't C.
21:42:10 <Evidence> Is there a reason not to use System.Posix's signal-handling thing?
21:42:37 <Evidence> Who knows what GHC does, with foreign import "wrapper", but it's probably something you're not allowed to do in a signal handler.
21:42:40 <Evidence> (It's quite a long list.)
21:43:26 <XexonixXexillion> Evidence: A signal handler is just a function pointer
21:44:27 <Evidence> XexonixXexillion: A function which is supposed to behave in a very particular way.
21:44:28 <carter> edwardk : thanks for your outstanding patience with me re asking the same things again again
21:44:37 <edwardk> np
21:44:42 <carter> I'll have more interesting CT + haskell questions  in a few weeks
21:44:53 <startling> carter: bread helps too
21:44:58 <edwardk> this time i could just reference a definition i already wrote ;)
21:44:58 <carter> right now its hacking on some repa related ideas etc
21:45:06 <carter> startling?
21:45:18 <carter> edwardk: thats always true with everything though :)
21:45:52 <startling> carter: makes it easier to get your 6-11 servings, you know
21:46:00 <carter> i don't get your joke
21:46:02 <Evidence> XexonixXexillion: Also, GHC does its own signal thing all the time.
21:46:13 <Evidence> Including lots of calls to sigprocmask that probably mask out your installed signal.
21:46:18 <carter> edwardk: but yeah, i've some *really* cool ideas i'll be layering on top of the REPA machinery this month
21:46:19 <Evidence> (handler)
21:46:29 <edwardk> carter: usda food pyramid humor
21:46:29 <startling> carter: < carter> 'cause bread of context helps with depth of understanding :)
21:46:31 <purefn1> edwardk: would love to see finalizer and resource management in machines
21:46:37 <carter> oh
21:46:41 <carter> breadthhhh
21:46:42 <startling> carter: ;)
21:46:43 <carter> gott it
21:47:03 <XexonixXexillion> Evidence: Makes sense
21:47:12 <purefn1> the indexed type stuff has me a bit scared away from pipes too, otherwise i really like it
21:47:44 <carter> purefn1: tekmo was just telling us how he's reverting to normal monads
21:48:01 <purefn1> carter: i saw, can't wait to see how it turns out
21:48:07 <purefn1> very cool stuff
21:48:17 <Evidence> XexonixXexillion: What *are* you doing, anyway?
21:48:39 <carter> keeping track of irc vs other internet handles of folks is hardd
21:48:41 <startling> man, I'd really like OverloadedChars
21:48:53 <carter> startling: they are cool
21:48:58 <carter> overloaded any const
21:49:03 <carter> for that matter
21:49:04 <Evidence> startling: That sounds like the devil.
21:50:17 <carter> night all
21:50:37 <startling> Evidence: it'd make working with Word8s (and thus bytestrings) a little easier
21:50:39 <johnw> hey
21:50:56 <XexonixXexillion> Evidence: Finding out what the limits of the ffi is by rewriting the exercises the Operating Systems students have in Haskell
21:51:06 <johnw> I've got c2hsc working for functions and inlines!
21:51:14 <startling> johnw: neat !
21:51:22 <johnw> https://github.com/jwiegley/c2hsc
21:51:28 <johnw> next is structs
21:51:29 <XexonixXexillion> So nothing with an actual purpose, just procrastinating from actual work
21:51:30 <startling> johnw: does it just take the .h file or what?
21:51:33 <johnw> yeah
21:51:38 <johnw> give it a .h, it gives you a .hsc
21:51:45 <startling> johnw: very cool, I was looking for one of them a while ago
21:51:55 <johnw> yeah; I just couldn't stomach keeping hlibgit2 up to date by hand
21:51:59 <johnw> when it so generateable
21:52:15 <startling> mhm
21:52:26 <johnw> it means I discovered language-c today
21:52:29 <johnw> which is super cool
21:52:48 <startling> that *is* cool
21:52:51 <SHACHAF> startling: Overloaded character literals that resolve to Word8s?
21:52:57 <SHACHAF> That's *definitely* the devil.
21:53:08 <SHACHAF> XexonixXexillion: Oh.
21:53:18 <johnw> SHACHAF: feeling loud today?
21:53:19 <SHACHAF> XexonixXexillion: Well, you'll have to coöperate with the GHC RTS.
21:53:28 <SHACHAF> Every day, johnw!
21:53:30 <johnw> lol
21:53:36 <SHACHAF> Just ask edwardk.
21:53:42 <hpaste> Reko pasted “Reader” at http://hpaste.org/74230
21:53:43 <johnw> hi edwardk
21:54:00 <startling> SHACHAF: I want to use Data.ByteString.Lazy.break to break on ":". break (== ':') would be nice
21:54:02 <Reko_> Can anyone explain why the Reader monad doesn't seem to unwrap its value when used with the bind operator?
21:54:03 <ddarius> language-c is impressive.
21:54:05 <XexonixXexillion> SHACHAF: nah, I'll just do it in ada (yes ada, not agda) instead. Much easier
21:54:07 <edwardk> what did i get volunteered for? =)
21:54:24 <SHACHAF> startling: break (== ord ':')
21:54:44 <SHACHAF> Maybe not ord but something else.
21:54:46 <startling> SHACHAF: what's ord?
21:54:55 <SHACHAF> No, you don't want ord.
21:55:11 <SHACHAF> iPromiseToBehave :: Char -> Word8
21:55:18 <startling> too bad Char isn't Integral
21:55:24 <startling> SHACHAF: hehe
21:55:53 <startling> why *isn't* Char integral? unicode code points would be the obvious thing
21:56:12 <edwardk> startling: why should i be able to multiply code points? how do they wrap?
21:56:14 <ddarius> Integral is a subclass of Num.
21:56:19 <startling> oh
21:56:19 <edwardk> what happens when i step into the unicode deadzone
21:56:22 <Ralith> startling: because 'obvious' is different than 'correct'
21:56:29 <startling> Ralith: true
21:56:42 <Ralith> now, Enum I could see
21:56:45 <ddarius> Char is Enum which seems reasonable enough.
21:56:50 <SHACHAF> Unicode code points are very weird.
21:56:50 <edwardk> > succ 'a'
21:56:51 <Ralith> well then.
21:56:51 <lambdabot>   'b'
21:56:58 <edwardk> > ['a'..'z']
21:56:59 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
21:57:01 <SHACHAF> For example, I don't think 0xD800 is a valid code point.
21:57:02 <startling> oh, I can use fromEnum
21:57:02 <edwardk> it is enum ;)
21:57:07 <Ralith> > succ '☃'
21:57:08 <lambdabot>   '\9732'
21:57:11 <Ralith> aw
21:57:33 <lambdabot> ☄
21:57:45 <ddarius> > text [succ '☃']
21:57:46 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
21:58:04 <WhoNeedszzz> ivanm, Well this works. http://ideone.com/oOZYk . Is that what you were saying?
21:58:10 <startling> doesn't succ have all the problems codepoint multiplication/addition would?
21:58:19 <startling> peano axioms and all that
21:58:21 <lambdabot> succ '☃' = ☄
21:58:21 <ddarius> startling: It has some of them.
21:59:08 <smw_> what is the most popular Haskell Web Framework so far ?
21:59:25 <SHACHAF> smw_: Try #haskell-web
21:59:29 <antontyre> > ['a', 'c', ..]
21:59:30 <lambdabot>   <no location info>: parse error on input `..'
21:59:33 <smw_> ah sorry
21:59:33 <startling> guess I could use OverloadedStringLiterals and do head ":"
21:59:37 <antontyre> > ['a', 'c' ..]
21:59:37 <lambdabot>   "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\153\15...
21:59:49 <antontyre> Funky
21:59:52 <SHACHAF> startling: ...Why?
21:59:58 <startling> where `head` is Data.ByteString.Lazy.head
22:00:06 <ddarius> instance IsString Char ...
22:00:07 <SHACHAF> Just write a function foo :: Char -> Word8 and then do foo ':'
22:00:22 <SHACHAF> startling: And don't use Data.ByteString.Lazy.Char8!
22:00:35 <startling> SHACHAF: I'm not?
22:00:48 <SHACHAF> Then you don't have an IsString Data.ByteString.Lazy.ByteString instance.
22:00:59 <startling> SHACHAF: oh.
22:01:08 <SHACHAF> Perhaps one day the world will be rid of blatant racism like this. But that day is not today.
22:02:01 <startling> k.
22:07:08 <qweec> "I DNF is blabla if each its conjunct is a conjunction  of eq1, eq2, eq3 or eq4,eq5" -  is following DNF blabla ?  eq1/\eq2 \/ eq1/\eq3/\eq4
22:07:22 <qweec> "A DNF is blabla if each its conjunct is a conjunction  of eq1, eq2, eq3 or eq4,eq5" -  is following DNF blabla ?  eq1/\eq2 \/ eq1/\eq3/\eq4
22:07:45 <SHACHAF> Why are you asking in here?
22:07:59 <qweec> where can I ask?
22:08:43 <popl> qweec: some channel that doesn't mind doing your logic homework, presumably
22:09:07 <qweec> it is not homework!
22:09:27 <SHACHAF> If this is logic, you could try ##logic.
22:09:37 <SHACHAF> But you might want to get a grammatical definition first.
22:09:43 <popl> DNF is disjunctive normal form
22:09:51 <qweec> yes right
22:09:57 <qweec> DNF is ...
22:10:13 <qweec> I need to state that defination in correct way
22:10:27 <qweec> just wanted to verify here :)
22:10:30 <SHACHAF> You should go to that other channel I mentioned.
22:10:36 <qweec> ok
22:10:37 <popl> This channel is about Haskell, qweec.
22:10:37 <qweec> thx
22:10:47 <qweec> ok
22:19:51 * nand` could really use (&&&) :: Applicative f => f a -> f b -> f (a,b)  right about now
22:20:14 <SHACHAF> liftA2 (,)
22:20:22 <nand`> ugly, and not an operator
22:20:59 <rking> nand`: Wait, with all of Haskell's wild operators, there's actually a fixed list? ☹
22:21:43 <zzing> If I install ghc 7.4.2 and install globally a set of packages that are in the haskell platform, will that essentially be the same thing?     I am having an issue with runhaskell and yesod that seem to be isolated to the haskell platform which is 7.4.1.
22:21:50 <startling> can Applicative be made an arrow?
22:23:15 <Saizan> newtype StaticArrow f a b = SA (f (a -> b)) -- that's an Arrow when f is Applicative
22:32:46 * hackagebot gloss 1.7.5.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.5.1 (BenLippmeier)
22:32:48 * hackagebot gloss-raster 1.7.5.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.5.1 (BenLippmeier)
22:32:50 * hackagebot gloss-examples 1.7.5.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.5.1 (BenLippmeier)
22:34:30 <zzing> Is there any difference between the 32 bit haskell platform and 64 bit? (platform mac). According to a [yesod] post the 32 bit platform will solve my issue.
22:35:19 <SHACHAF> Yes, there are many differences.
22:35:25 <SHACHAF> Pointer size comes to mind.
22:35:57 <zzing> Not too much issue to me with yesod right now unless I try to deal with opengl later on.
22:36:25 <SHACHAF> FAHCAHS: Try rot13 instead of reverse.
22:36:31 <FAHCAHS> wouldn't there also be more space for pointerflags maybe?  Or is it still blocks of 8?
22:37:07 <FAHCAHS> SHACHAF: But I like the symmetry ;)
22:37:15 <SHACHAF> Pointerflags?
22:37:30 <zzing> nice nicks :P
22:37:31 <FAHCAHS> GHC packs 3 flags into pointers
22:37:43 <SHACHAF> Oh, yes, it's 3 for 64-bit pointers and 2 for 32-bit.
22:37:50 <SHACHAF> Like you'd probably expect.
22:38:21 <FAHCAHS> seems reasonable.  Interesting how many generation things can change with bit architecture
22:38:52 <zzing> On the mac does uninstalling ghc also do the platform?
22:38:58 * FAHCAHS prefixed with MUDDA
22:39:44 <newsham> shachaf: does that mean it can only address 2^63 bytes? :(
22:39:51 <newsham> shachaf: does that mean it can only address 2^59 bytes? :(
22:40:13 <mgsloan> no, it means that it can address 2^64 bytes, rounded to the nearest 8 ;)
22:40:14 <SHACHAF> newsham: GHC doesn't address things smaller than the word size.
22:40:20 <startling> zzing: 64-bit is buggy on snow leopard and older, fwiw
22:40:34 <mgsloan> pointers to datastructures usually have a few zeros
22:40:37 <SHACHAF> newsham: But I think you'll find that your CPU limits you to 2^48. :-)
22:40:39 <newsham> C Ptrs?
22:40:55 <zzing> startling, mountain lion here. But I have a bug that apparently the 64 bit version has that 32 doesn't when using runhaskell/ghci with yesod
22:40:55 <newsham> shachaf: time to buy a new cpu
22:41:02 <startling> zzing: aw
22:41:11 <SHACHAF> newsham: I heard Haswell will have 56 address bits.
22:42:20 <mgsloan> it'd be cool if you could ask virtual memory to not use / care about some of the higher order bits, and use those for more flags
22:42:42 <mgsloan> does the code generated by GHC need to mask the pointers before use, or is that just implicit?
22:42:42 <SHACHAF> mgsloan: People do use those bits.
22:42:47 * hackagebot gloss 1.7.5.2 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.5.2 (BenLippmeier)
22:43:02 <SHACHAF> mgsloan: You're explicitly not supposed to and AMD makes your life hard when you do it.
22:43:06 <mgsloan> SHACHAF: Whoah, awesome!
22:43:12 <mgsloan> :/
22:43:15 <SHACHAF> Because they don't want programs to break when you get more RAM and fancier CPUs.
22:43:16 <mgsloan> it seems pretty reasonable to me
22:43:18 <SHACHAF> But you can use them.
22:43:18 <mgsloan> yeah
22:43:28 <mgsloan> it'd be quite reasonable for JIT
22:43:48 <SHACHAF> The only requirement is that the highest 16 bits of any address are all 0 or all 1.
22:44:16 <mgsloan> strange requirement
22:44:28 <mgsloan> that's where the 48 comes from?
22:44:35 <SHACHAF> Yes.
22:44:54 <SHACHAF> This means that your usable address space is divided into two non-contiguous chunks. :-)
22:44:55 <mgsloan> shouldn't it just be "but if there are no highest contiguous 16, all 64 are used"?
22:45:10 <newsham> shachaf: how is that non-contiguous?
22:45:22 <ddarius> Extra address space can be used for more ASLR.
22:45:34 <mgsloan> newsham: well, if you look at the numerical values of the pointers, there is a big jump
22:45:49 <flux> mgsloan, but they're just next to each other..
22:45:53 <newsham> msgloan: only if you treat it as unsigned.
22:46:05 <mgsloan> newsham: ahh :D
22:46:06 <edwardk> its also nice because that means you have just enough bits to make pointers into a valid NaN with some extra tagging
22:46:43 * ddarius loves loading pointers into floating point registers.
22:46:45 <flux> oh, I suppose you mean in the case you use only those prefixes
22:47:03 <SHACHAF> Addresses ought to be floating-point anyway, so you can address individual bits in a byte.
22:47:06 <SHACHAF> It's only sensible.
22:47:20 <mgsloan> and put things between bits, of course
22:47:24 <flux> but once you have enough memory for 48 bit memory to be mapped, you can't anymore expect to use those bits :)
22:47:25 <edwardk> SHACHAF: dave taylor's old pinky processor did that =P
22:47:36 <edwardk> at least fixed point, so you could address indiividual bits
22:47:46 <SHACHAF> edwardk: Yes, floating point is completely insane.
22:48:06 <SHACHAF> A Double has a 52-bit mantissa, though, right? That's plenty.
22:48:11 <flux> actually you can probably consume 48 bits by mapping a large storage system
22:49:00 <edwardk> SHACHAF: 52 bits present, 1 bit virtual. that means you've got 12 bits left 1 of which is the sign, 11 are exponent, which leaves you 4 bits in the msb region for tagging
22:49:33 <edwardk> and you can use that to make things signal or not, turn them into legal pointers, and still tag a dozen or so different kinds of structures, like, ints, etc.
22:50:29 <nand`> “Could not find module `Graphics.Gloss.Interface.Pure.Game'  There are files missing in the `gloss-1.7.5.1' package, try running 'ghc-pkg check'” <- huh?  /usr/lib64/gloss-1.7.5.1/ghc-7.4.2/Graphics/Gloss/Interface/Pure/Game.hi exists and ghc-pkg check reports no errors
22:50:58 <nand`> tried uninstalling and reinstalling gloss to no avail
22:53:00 <nand`> I get the same error even if gloss is not installed. What gives?
22:53:09 <lpvb> hey guys, can you help me understand why difference lists are faster than normal appending lists?
22:54:08 <SHACHAF> lpvb: Compare: (a ++ b) ++ c with: a ++ (b ++ c)
22:54:13 <SHACHAF> Do you understand why the latter is better?
22:55:05 <lpvb> SHACHAF: wouldn't the former version also run in the same speed if the compiler remembers where the end of the appended list is?
22:55:29 <SHACHAF> You're ascribing some kind of magical remembering power to the compiler.
22:55:45 <lpvb> SHACHAF: If it's not doing that I assume that it's because a and b are longer together and it has to step through a longer list to get to the end
22:55:56 <nand`> I.. what; with -v it looks in ~/.cabal/lib/gloss-...
22:55:57 <SHACHAF> I'm sure there are ways to optimize (a ++ b) ++ c, but ignoring optimizations and just thinking about graph reduction, do you see why it's less efficient?
22:56:34 <lpvb> SHACHAF: the latter still has to step through list a though, right?
22:56:45 <nand`> apparently gloss-1.7.5.1 got added to my local ghc-pkg cache somehow
22:56:48 <SHACHAF> lpvb: Try doing the reduction by hand.
22:57:04 <lpvb> reduction?
22:57:13 <SHACHAF> At a high level, ([1,2,3] ++ [4,5,6]) ++ [7,8,9] ==> [1,2,3,4,5,6] ++ [7,8,9]
22:57:24 <SHACHAF> Notice that each of these cons cells is going to have to be thrown away now.
22:57:30 <dibblego> (a ++ b) ++ c runs a, then a ++ b
22:57:31 <SHACHAF> (In the first list, that is.)
23:01:58 <lpvb> SHACHAF: I think the part that is confusing me is that difference lists supposedly have O(1) appends, when I thought ++ always does O(n)
23:02:39 <nand`> lpvb: appending difference lists is just function composition; the actual work is delayed until you convert it to a regular list - which can be done in one pass
23:03:13 <lpvb> why is it done in one pass if it's a ++ (b ++ c)?
23:03:42 <nand`> because (b ++ c) gets reused
23:03:48 <SHACHAF> What difference lists do is turn a big tree like (((a ++ b) ++ (c ++ d)) ++ ((e ++ f) ++ g)) into right-associative (a ++ b ++ c ++ d ++ e ++ f ++ g)
23:04:23 <lpvb> I know that part, but isn't it O(n) when it appends a with the longer list?
23:04:50 <lpvb> because it has to iterate through list a to get to the end and append b ++ c to it?
23:06:06 <SHACHAF> Calling it O(1) is -- well, it can be misinterpreted. (fromDList (appendDList (toDList a) (toDList b))) is still going to be doing the append, in the end.
23:06:43 <nand`> the O(1) here means that appending DLists has no extra cost over the fromDList you need to run either way
23:06:53 <nand`> well
23:06:56 <nand`> it has a cost; but a constant one
23:07:17 <SHACHAF> > foldl f z [a,b,c,d]
23:07:18 <lambdabot>   f (f (f (f z a) b) c) d
23:07:19 <SHACHAF> > ($ z) $ foldl (.) id [f a,f b,f c,f d]
23:07:21 <lambdabot>   f a (f b (f c (f d z)))
23:07:33 <SHACHAF> See the difference there?
23:07:41 <SHACHAF> > foldr f z [a,b,c,d]
23:07:42 <lambdabot>   f a (f b (f c (f d z)))
23:07:53 <SHACHAF> DList turns the foldl into the foldr.
23:08:07 <lpvb> I know that =(
23:08:22 <SHACHAF> So your question is why the foldr is better?
23:09:19 <lpvb> My question is not about the associativity, it's about why appending list a with list b runs in O(1)
23:09:38 <lpvb> when I though list a has to be iterated through to find the end
23:09:45 <SHACHAF> It does.
23:09:54 <lpvb> Then it runs in O(n)?
23:09:57 <nand`> again, DList append is just function composition
23:10:05 <SHACHAF> lpvb: DList (++) is O(1), but DList-to-list conversion is O(n)
23:10:07 <SHACHAF> How's that?
23:11:32 <pfurla> hey
23:11:57 <SHACHAF> hi pfurla
23:12:08 <nand`> toDList a ++ toDList b  is O(1) the same way factorize . multiplyWithVeryLargeNumber is O(1)
23:12:10 <pfurla> what am i doing wrong here, this one works: foldl (\a b -> b : a) [] [1..3], but i'd like to replace the lambda with flip
23:12:22 <SHACHAF> nand`: That's not really true.
23:12:35 <SHACHAF> pfurla: flip (:)
23:12:39 <nand`> SHACHAF: how so?
23:13:06 <SHACHAF> Well, maybe I just don't understand what you mean.
23:13:21 <pfurla> ah
23:13:37 <ddarius> Both just allocate a two element environment and build a closure containing the two arguments to (.).
23:13:41 <ddarius> Constant time.
23:13:42 <pfurla> foldl (flip (:)) [] [1..3] !
23:14:03 <pfurla> i was forgeting the first aparenthis
23:14:10 <nand`> as in, the composition of the two functions is O(1) even though the functions themselves may be expensive
23:14:14 <pfurla> parenthesis
23:14:14 <SHACHAF> Well, yes. But that's missing something in the DList version.
23:14:24 <ddarius> pfurla: In general, you want to use foldl' (in Data.List) or foldr, though this is one of the few cases where it doesn't really matter.
23:15:22 <pfurla> ddarius: it's only intended to be a demo of haskell expressiveness
23:16:00 <ddarius> So demo good practices.
23:16:15 <lpvb> SHACHAF: after it's done building list a in a ++ (b ++ c), does it forget where the end is once it encounters ++, and have to iterate through list a again?
23:16:41 <SHACHAF> Forget?
23:16:49 <SHACHAF> ("it"?)
23:17:12 <lpvb> does GHC optimize it so that a only has to be traversed once in that expression?
23:17:26 <ddarius> There is no need to optimize anything.
23:17:37 <ddarius> The naive semantics will only traverse a once.
23:18:18 <ddarius> lpvb: Figure out what shachaf meant by "reduction" and then apply it to this example using the definition of (++).
23:18:37 <lpvb> Can you point me to a resource or something?
23:19:42 <nand`> is there a type like data BinTree a = Leaf a | Branch (BinTree a) (BinTree a) anywhere?
23:21:02 <SHACHAF> @google lazy.xhtml
23:21:03 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
23:21:14 <SHACHAF> lpvb: ☝
23:22:16 <pfurla> thanks for the help guys, gotta go now
23:22:42 <amosr> speaking of lazy. does foldr/build fuse the ((a ++ b) ++ c) case anyway?
23:23:22 <DMWIT> outlook not good
23:23:24 <randomclown> is it possible to have sets in ST?
23:23:27 <ddarius> nand`: No because it would be mostly useless.  It would either save you like four lines of code, or it would "not quite" be what you want, at which point you'd write a slightly different four lines of code.
23:23:56 <nand`> ddarius: I might as well just generalize it to rose trees
23:23:57 <DMWIT> randomclown: What makes you worried that you can't?
23:24:10 <randomclown> mutable sets in ST?
23:24:34 <DMWIT> randomclown: Again, what makes you worried that you can't?
23:24:35 <ddarius> nand`: Data.Tree does have rose trees, but again, it's mostly useless unless it happens to be exactly what you want at which point it's saved you like ten lines of code.
23:24:35 <SHACHAF> Looking at the Core for (a ++ b) ++ c, *something* turns it into a ++ (b ++ c)
23:24:52 <randomclown> DMWIT: has somebody already make an implementation?
23:25:05 * SHACHAF finds it strange that a standard-library [] is so useful and a standard-library Tree isn't.
23:25:05 <ddarius> There's probably a rewrite rule for append over append.
23:25:06 <DMWIT> Ah. That I don't know.
23:25:33 <SHACHAF> There are some varieties on [], but people mostly want them for type-safety, like Stream and NonEmpty.
23:25:48 <ddarius> shachaf: [] represents something fundamental.  Trees are also fundamental but have a lot more variety and are extremely easy to define in Haskell.
23:26:59 <SHACHAF> [] is also easy to define.
23:27:08 <SHACHAF> But writing all the utility functions for it is a big hassle.
23:27:17 <ddarius> shachaf: Yes, but there isn't a lot of them and [] is usually the one you want.
23:28:41 <ddarius> That said, probably one of the most generic "tree" types, is a free monad.
23:28:54 <Lutin`> So I have now successfully made the switch to arch
23:29:06 <Lutin`> Now what's the best way to Haskell on it?
23:29:20 <SHACHAF> You mean Free in general or Free on some specific functor?
23:29:29 <ddarius> Free in general.
23:29:34 <DMWIT> When I was on Arch, I managed Haskell myself.
23:29:36 <SHACHAF> Lutin`: #arch-haskell
23:29:56 <ddarius> If you were to abstract from rose trees/binary trees/etc. you'd end up with something rather like a free monad.
23:30:03 <ddarius> Or a cofree comonad.
23:30:14 <Lutin`> Oho!
23:30:30 * SHACHAF still isn't sure what "cofree" means in general.
23:30:43 <plat0> Yeah, what is "cofree"?
23:30:45 <edwardk> SHACHAF: got adjunctions down?
23:30:52 <ddarius> shachaf: It means you have a right adjoint instead of a left.
23:30:55 <edwardk> cofree is 'right adjoint to a forgetful functor.
23:31:00 <SHACHAF> edwardk: Nope.
23:31:03 <edwardk> free is left adjoint to a forgetful functor
23:31:13 <plat0> Any intuition for that?
23:31:20 <plat0> I mean for cofree?
23:31:31 <edwardk> plat0: i gave a quick overview of how lists are the free monoid in https://plus.google.com/106871002817915335660/posts/g9LASrMjeFS
23:31:45 <SHACHAF> Is there such a thing as a cofree monad?
23:31:48 <plat0> I know what free is
23:31:55 <plat0> I don't have an intuition for cofree though
23:32:02 * SHACHAF should just find a place to read about category theory and read about it rather than picking up random snippets in #haskell.
23:32:03 <johnw> is cofree Free (Free a) a?
23:32:04 <plat0> Also, I don't *really* know what a forgetful functor is.
23:32:21 <johnw> SHACHAF: if you find a good one, let us know
23:32:21 <edwardk> johnw: no
23:32:26 <plat0> Is there a definition of forgetful functor that isn't trivial?
23:32:37 <edwardk> plat0: just throw some stuff away ;)
23:32:49 <edwardk> but no its one of those 'you know it when you see it' things
23:32:55 <johnw> is a forgetful functor catamorphic?
23:33:30 <startling> anyone have any high-ish level combinators for writing css?
23:33:44 <ddarius> shachaf: I find a lawn chair on a nice, quiet, sunny hill is a good place to read about category theory.
23:34:09 <SHACHAF> «A free foo happens to be the simplest thing that satisfies all of the 'foo' laws.»
23:34:16 <SHACHAF> Does "cofree" have a definition like that?
23:34:26 <ddarius> plat0: There are technical definitions forr "forgetful functor" but they tend to be not generally applicable.  There is no general definition of a forgetful functor.
23:34:29 <SHACHAF> ddarius: Sounds like good advice.
23:35:07 <dibblego> would you like a cofree with your coffee?
23:35:08 <ddarius> shachaf: If a free structure is entirely characterized by how you can build it, a cofree structure would be entirely characterized by the observations you can make of it.
23:35:10 <dibblego> haha I am so funny!
23:35:19 <plat0> startling: I use language-css.  I'm not an expert, but it seems to do the job.
23:35:39 <edwardk> basically when you get down to it, giving a monad homomorphism from a free monad to another monad is equivalent to giving a functor homomorphism (natural transformation) from its base functor to that monad. while on the cofree front, every comonad homomorphism to that comonad, is equivalent to giving a natural transformation from the comonad's functor to that base functor.
23:35:53 <edwardk> but these definitions follow trivially from the fact that you have an adjunction
23:35:56 <ddarius> Categories of automata have good examples of cofree structures and coalgebras.
23:36:19 <SHACHAF> ddarius: What should I read on that lawnchair?
23:36:44 <edwardk> because given f a -> b   and a -> u b where u is forgetting the monad, and f is the free monad construction, the isomorphism between those two things is an isomorphism between an arrow in the category of monads (monad homomorphisms) and one in the category of functors (natural transformations)
23:36:51 <ddarius> shachaf: Awodey's book and/or Barr and Wells' ESSLLI lecture notes to start.
23:37:25 <edwardk> dibblego is overly medicated again ;)
23:37:37 <dibblego> actually I'm not, but hi!
23:37:58 <ddarius> Goguen has quite a bit of stuff on categories of automata and coalgebras.
23:38:15 <ddarius> JJMM Rutten's coalgebra stuff is also somewhat interesting.
23:38:29 <SHACHAF> Hmm, these textbooks are always so expensive.
23:38:39 <ddarius> @google Barr Wells ESSLLI
23:38:41 <lambdabot> http://www.ling.ohio-state.edu/~plummer/courses/winter09/ling681/barrwells.pdf
23:38:42 <ddarius> free ^
23:38:43 <SHACHAF> Ah, the paperback is a bit better.
23:38:50 <SHACHAF> Yes, I found that.
23:38:59 <ddarius> Also there are libraries.
23:39:17 <SHACHAF> There are, but the university ones don't usually let me check out books.
23:39:29 <SHACHAF> I don't think the non-university ones have tend to have the books I'm looking for.
23:40:39 <BMeph> SHACHAF: You should go to California, then... ;)
23:40:55 <SHACHAF> BMeph: What does California have to do with it?
23:41:54 <ddarius> Anyway, there are plenty of resources readily available for free online.  It just takes more effort and false starts than a good book, though even then there are plenty of not-so-good books.
23:42:03 <BMeph> SHACHAF: California public libraries ;allow you to check out their university's library books.
23:42:35 <SHACHAF> BMeph: Ah. I live near Stanford but they can presumably do whatever they want with their books.
23:42:48 * BMeph has SPJ's "Implementing Functional Languages" bok checked out
23:43:03 * BMeph meant "book" not "bok"
23:43:32 <ddarius> Yeah, you usually don't return bok choy.
23:43:41 <BMeph> SHACHAF: I get Uni books through the county library (San Diego)
23:44:56 <BMeph> SHACHAF: I've seen Alameda county on the list, so maybe you can do something through the county library where you are.
23:46:26 <startling> where can I host yesod et al applications?
23:48:09 <scottj> startling: heroku probably
23:49:38 <DMWIT> You know, many public libraries have a request system that draws from nearby and far away Universities.
23:49:44 <DMWIT> It's not special to California.
23:50:20 <SHACHAF> Hmm. I could try it.
23:50:39 <DMWIT> You might even be able to do it from your armchair.
23:51:05 <nand`> does Parsec have helpers for parsing a single chain of infix operators, instead of needing an OperatorTable that looks like [[Infix .. AssocLeft]] ?
23:51:12 * ddarius has no armchairs.
23:51:20 <SHACHAF> I'd rather do it from my lawn chair.
23:51:25 <SHACHAF> Or maybe ddarius's lawn chair.
23:51:53 <nand`> oh, chainl1 might do what I want
23:53:46 <edwardk> nand`: thats what chainr, and chainl are for
23:54:55 <SHACHAF> Hmm, DiffArray doesn't even compile these days.
