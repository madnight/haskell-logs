00:02:18 <startling> so uh, if I write this thing in haskell will it be the first porn site written in haskell?
00:04:25 <ivanm> startling: ummmm.... quite possibly.....
00:04:33 <ivanm> doesn't sound like avoiding success... :p
00:07:09 <startling> p.s., can I build without gmp somehow? I heard there was a pure haskell alternative somewhere. Seems like gmp's a pain for deploying to heroku
00:08:20 <ivanm> startling: yes, it's a compile-time option for ghc I believe
00:08:26 <ivanm> it just makes Integer really, really slow
00:08:42 <SHACHAF> But who uses Integers?
00:08:47 <ivanm> SHACHAF: fromIntegral ?
00:08:55 <ivanm> doesn't that round-trip via Integer?
00:08:59 <startling> ivanm: darn. :/
00:09:02 * SHACHAF was not completely serious.
00:09:18 <SHACHAF> Someone should make a BSD-licensed competitor to GMP!
00:09:20 <startling> Nat is all you need !
00:09:50 <startling> The thing is: I don't even know whether I'd need to use Integer
00:10:17 <startling> hash functions would probably restrict themselves to IntXX, right?
00:10:33 <sheldonh> i think Functor might be the thing that breaks me. :(
00:10:36 <ivanm> startling: if you ever use fromIntegral, or integral literals then you've used Integer
00:11:39 <startling> ivanm: yeah. idk
00:12:04 <johnw> got structures working
00:12:06 <johnw> on to typedefs...
00:12:49 * hackagebot ghc-heap-view 0.3.0.1 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.3.0.1 (JoachimBreitner)
00:13:05 <johnw> ooh, I wonder if the new ghc-heap-view works on Mac...
00:14:08 <ivanm> johnw: with your blog post about svndump, do I understand correctly that in the end to get a list of results you kept doing a single parse and evaluating that parse?
00:14:33 <johnw> i repeat the "entry parse" on demand in the form of a lazy list
00:15:18 <johnw> so (take 1 ...) would only parse a hundred bytes at most, no matter the file size -- if that's what you're asking
00:15:46 <ivanm> I just never considered repeatedly parsing, getting the result, then recursing on the output
00:15:53 <ivanm> rather than building up a parser that does the recursion for you
00:16:10 <johnw> yeah, except Attoparsec sequences that recursion
00:16:43 <johnw> bah, still seg faults
00:19:09 <startling> johnw, your hsc thing?
00:19:11 <startling> or something else?
00:19:27 <johnw> no, ghc-vis
00:19:32 <johnw> the hsc thing is going strong
00:19:38 <johnw> I was able to purify 95% of it by using State
00:19:47 <johnw> always feels good :)
00:20:50 <user> my ubuntu server crashes when i run : bash bootstrap.sh
00:21:03 <johnw> the kernel crashes?
00:21:11 <user> the machine freezes
00:21:15 <user> and i need to reboot
00:21:26 <johnw> how much memory?
00:22:04 <DMWIT> Your usual debugging strategies ought to be helpful. Execute bootstrap.sh line by line and see which is the first one that dies.
00:22:11 <DMWIT> Then you'll know much more about what happened.
00:22:35 <user> i could try that,
00:22:44 <user> it's 0.7GHz 376MB
00:22:58 <johnw> watch "top" as you run too
00:23:07 <johnw> heavy thrashing can often look like freezing
00:24:38 <startling> user: uh, maybe you should cross-compile?
00:27:29 <ivanm> startling: GHC doesn't support cross-compiling...
00:27:32 <ivanm> (yet)
00:27:59 <DMWIT> Cross-compiling was just the wrong term for what startling meant, I'm sure.
00:28:09 <ivanm> oh, right
00:28:10 <startling> ivanm, surely you could build it on some other machine and scp it over?
00:28:14 <DMWIT> Compiling on one machine for another works just fine if they're the same architecture.
00:28:25 <ivanm> startling: yes, but cross-compiling normally refers to doing it on a different architecture
00:28:27 <startling> yeah, that's what I meant. "cross-compiling" was wrong
00:28:30 <ivanm> DMWIT: and have the same C libraries
00:28:36 <ivanm> GMP is the usual one to trip me up...
00:28:40 <ivanm> glibc sometimes as well
00:28:41 <DMWIT> same here =)
00:29:12 <DMWIT> But at least it makes it far enough into the executable to know that libraries are the problem. =)
00:30:52 <covi> Is there a parser (read?) for Verbosity values?
00:30:58 <startling> user: wait, this is ubuntu?
00:31:04 <startling> user: surely you can download a binary?
00:31:17 <user> apt-get install fails
00:31:40 <ivanm> user: ... why does it fail ?
00:32:42 <DMWIT> apt-get install what?
00:32:50 <user> cabal-install
00:32:58 <DMWIT> (bootstrap.sh has an apt-get install line??)
00:33:00 <pharaun> oh noes capitalized
00:33:05 <ivanm> @hoogle Verbosity
00:33:05 <lambdabot> No results found
00:33:11 <ivanm> covi: where is Verbosity from?
00:34:46 <ddarius> fromIntegral only nominally goes via Integer.  Most types have rewrite rules defined to do direct translations and if you are adding a new type, it would behoove you to do the same.
00:35:04 <ivanm> ddarius: oh? nice!
00:35:06 <covi> ivanm: Distribution.Verbosity
00:35:09 <DMWIT> Wait, what?
00:35:11 <ivanm> covi: which package?
00:35:20 <DMWIT> How do you write a rewrite rule that eliminates fromInteger?
00:35:37 <ivanm> covi: from Cabal?
00:35:41 <ivanm> there's a Read instance...
00:36:14 <ivanm> covi: otherwise, I believe you're meant to use intToVerbosity
00:36:26 <ivanm> especially as the constructors for Verbosity aren't exported...
00:36:52 <DMWIT> Oh, now I understand the "apt-get install fails" comment.
00:36:52 <covi> ivanm: I mean sth like parseVerbo :: String -> Verbosity
00:36:55 <DMWIT> I'm an idiot.
00:37:07 <covi> ivanm: show $ read "normal" in ghci does not succeed
00:37:31 <ivanm> covi: what are you trying to do?
00:37:53 <ddarius> {-# RULES "myfoo/Int" fromInteger = myFooToInt #-}
00:38:08 <ddarius> Er it would be for fromIntegral
00:38:11 <DMWIT> covi: I would expect read "Normal"
00:38:12 <ivanm> heh, about to say
00:38:27 <ivanm> > read "Normal" :: Verbosity
00:38:28 <lambdabot>   Not in scope: type constructor or class `Verbosity'
00:38:31 <ivanm> didn't think so
00:38:39 <covi> the values are in lower case
00:38:48 <ivanm> covi: the exported _functions_ are in lower case
00:38:53 <DMWIT> ddarius: Oh, yes, I can believe that fromIntegral can be rewritten away.
00:39:00 <ivanm> s/functions/values/
00:39:08 <ivanm> but they're just wrappers around the non-exported constructors
00:39:25 <covi> ivanm: oops
00:39:49 <ivanm> I guess the constructors aren't exported so people can't write custom Verbosity -> Blah functions?
00:40:06 <DMWIT> covi: FWIW going the other way (read $ show normal) works fine, and should have been a clue that you should try "show normal" to see what format read expects. =)
00:41:01 <DMWIT> ivanm: There's an Eq instance, so you can still write such functions.
00:41:32 <ivanm> DMWIT: oh, by going "myVerbosity == normal" ?
00:41:37 <ivanm> seems even more weird then
00:41:48 <DMWIT> Yeah, I don't know why the constructors are hidden.
00:41:58 <ivanm> I'm guessing for hysterical raisins
00:42:14 <covi> Anyhoo, I wrote the simple parser myself
00:46:15 <startling> anyway, do people like yesod? or should I use one of those other things?
00:46:27 <SHACHAF> #haskell-web
00:46:57 <johnw> yay, typedefs work great
00:47:02 <johnw> on to enums...
00:47:04 <ivanm> startling: if people didn't like it, why would they keep writing about it, developing more libraries, buying the book, etc.? :p
00:47:23 <Reko_> startling: what are you trying to accomplish?
00:47:49 * hackagebot regex-genex 0.5.0 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.5.0 (AudreyTang)
00:48:09 <startling> ivanm, people still write about and develop libraries and buy books for C, C++, Java ...
00:48:36 <ivanm> startling: yes, but some people _like_ C, C++, Java
00:48:56 <ivanm> Reko_: from what he said earlier, a NSFW website...
00:49:08 <DMWIT> haha, stupid Linus, he should rewrite the kernel in Haskell
00:49:14 <startling> well, this *is* work for me
00:49:41 <startling> DMWIT: I'm sure Linus has a fair share of cuss words for C
00:49:49 <Reko_> happstack is nice if you're picky and want to be able to choose which components to use. yesod is kind of an all-in-one thing so it depends what percentage of it you feel suits your situation. snap appears to be a rails-y solution
00:49:56 <ivanm> DMWIT: didn't someone write a blog post or something about how to write kernel modules in Haskell using a modified GHC?
00:50:12 <ivanm> Reko_: the yesod devs keep saying you can pick and mix as well
00:50:27 <johnw> is there a whenJust?
00:50:42 <startling> johnw: what does that do?
00:50:42 <DMWIT> johnw: What do you want it to do?
00:50:56 <DMWIT> (The answer is probably "yes".)
00:51:00 <johnw> case x of Nothing -> return () ; Just y -> ...
00:51:01 <Reko_> ivanm: that may be true, but I wouldn't know where to start. Whereas with happstack, you start with nothing and build up
00:51:11 <johnw> so, whenJust x $ \y -> ...
00:51:15 <DMWIT> :t maybe (return ())
00:51:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
00:51:25 <Reko_> and the more components of a framework you reject, the less a return you get from it. libraries vs. frameworks, I guess.
00:51:27 <ivanm> yeah, I've used maybe (return ()) a fair amount
00:51:30 <johnw> ah, thank you
00:51:51 <johnw> whenJust = maybe (return ()) ;)
00:51:57 <DMWIT> right =)
00:52:30 <johnw> oh man, so much nicer
00:53:10 <johnw> this: case ident of Nothing -> return (); Just (Ident name _ _) -> ...
00:53:12 <johnw> becomes: whenJust ident $ \(Ident name _ _) -> ...
00:53:21 <johnw> this is going to really clear things up
00:53:43 <liyang> johnw: instead of whenJust, you can just use for_ or traverse_
00:53:53 <liyang> (from Data.Foldable)
00:54:00 <johnw> hmm
00:54:24 <johnw> that is a really good idea
00:54:47 <johnw> yep, whenJust = for_
00:55:03 <DMWIT> Oh, I like that.
00:55:07 <DMWIT> liyang++
00:55:19 <startling> :t maybe (return ())
00:55:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
00:55:30 <startling> @hoogle (Monad m) => (a -> m ()) -> Maybe a -> m ()
00:55:31 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
00:55:31 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:55:31 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:55:34 <johnw> and it works for lists too
00:55:38 <ivanm> oh, I found that mapM from Traversable worked really nicely with a Maybe inside a monad
00:55:39 <johnw> so my whenJust ... forM_ ...
00:55:44 <johnw> just became for_ ... for_ ... :)
00:57:49 <johnw> huh, so why do I need forM_?  if the Monad isn't Applicative?
00:58:16 <startling> aren't all monads applicative?
00:58:21 <DMWIT> You generally don't need forM_.
00:58:22 <johnw> well, they _should_ be
00:58:38 <startling> oh, it isn't instanced somewhere?
00:58:46 <DMWIT> It can't be, unfortunately.
00:58:50 <johnw> applicatives came after monads
00:58:55 <startling> oh, it's undecidable isn't it
00:59:13 <DMWIT> The correct thing would be class Applicative m => Monad m, but "that would break like one package on Hackage, waaaaah".
00:59:28 <startling> haha
00:59:44 <DMWIT> It's nothing to do with undecidability and everything to do with overlapping instances.
00:59:47 <johnw> is there map_? :)
01:00:03 <DMWIT> You can't write instance Monad m => Applicative m because that precludes *all* other Applicative instances ever.
01:00:19 <DMWIT> So you would then no longer be allowed to have an Applicative that wasn't also a Monad, and the class would be pointless.
01:00:30 <liyang> johnw: you mean traverse_?
01:00:43 <johnw> damn you, liyang, your kung fu is strong
01:01:06 <startling> DMWIT, right. but you could do it with undecidable instances? (but you shouldn't)
01:01:14 <DMWIT> startling: How?
01:01:27 <startling> isn't it of the same form in this post?
01:01:30 <startling> http://lukepalmer.wordpress.com/2008/04/08/stop-using-undecidable-instances/
01:01:35 <startling> instance Num g => Group g where
01:01:44 <startling> instance Monad m => Applicative m where
01:02:08 <johnw> ok, enum members work, but I'm not getting the #integral_t for the... ah.  it's a typedef enum {} name;  blasted declarator rules...
01:02:24 <DMWIT> um
01:02:35 <DMWIT> That post is just not quite right, I think. =)
01:02:54 <DMWIT> You probably do need UndecidableInstances, but the reason it's undesirable is because of the overlapping instances, not the undecidableness.
01:02:56 <liyang> johnw: actually, someone else here pointed (or on haskell-libraries; I forget, it was some time ago) out to me that whenJust is just for_. I hadn't realised it even though I'd been using Applicative/Foldable/Traversable for years.
01:03:27 <johnw> i am still learning the Power of the Applicative
01:03:36 <johnw> AFT is a real powerhouse
01:03:46 <johnw> especially with Monads that support Applicative
01:04:09 <DMWIT> startling: He's actually railing against the "instance Foo a => Bar a" antipattern in that post; the talk about undecidable instances is a red herring.
01:04:31 <startling> DMWIT: oh hm
01:04:42 <ddarius> DMWIT: It's not specific to that, but it also isn't some rigorous denunciation.
01:04:55 <startling> so where do undecidable instances come in the picture? I don't understand them, apparently
01:05:06 <randomclown> @pl \x -> maybe (error "asd") (return) (M.lookup a x)
01:05:06 <lambdabot> maybe (error "asd") return . M.lookup a
01:05:20 <ddarius> He's mostly complaining about people using less than pleasant extensions with no justification or understanding of them.
01:05:33 <DMWIT> bleh
01:05:53 <ddarius> startling: Just ignore them.  You typically do not need them.  Needing them usually indicates a design problem.
01:05:54 <amosr> isn't "GHC told me to" valid justification?
01:05:59 <ddarius> amosr: No.
01:06:02 <DMWIT> My top-level point is that "instance Monad m => Applicative m" would be very undesirable, for several reasons, one of which may or may not be the need for undecidable instances.
01:06:05 <amosr> :)
01:06:24 <ddarius> amosr: GHC will tell you to make Integer an instance of Fractional, but that doesn't mean it's the right thing to do.
01:06:52 <ddarius> DMWIT: It's more that it just wouldn't work in the ways you outlined.
01:06:55 <startling> ddarius: hehe
01:07:50 * hackagebot multirec 0.7.3 - Generic programming for families of recursive datatypes  http://hackage.haskell.org/package/multirec-0.7.3 (AndresLoeh)
01:07:59 <ddarius> GHC is always right when it says you're wrong, but that's it.
01:08:26 <randomclown> if I have a Data.Map of Strings to STRefs Int, what's the best way to convert this map back to Map Strings Int?
01:10:47 <ivanm> randomclown: if your keys are strings, using HashedMap from unordered-containers will probably be better
01:11:07 <ivanm> but as for your actual question... don't you need to change STRef stuff in IO?
01:11:21 <randomclown> this is in a ST monad
01:11:27 <ivanm> oh, righ
01:11:28 <ivanm> *right
01:11:55 <ivanm> I'm going to guess some from of Traversable function or something
01:11:59 <DMWIT> fromList <$> sequence [readSTRef v >>= \v -> return (k, v) | (k, v) <- assocs m]
01:12:00 <ivanm> *form
01:12:16 <ivanm> DMWIT: well, I was trying to think of how to do it without going via a list ;)
01:12:29 <ivanm> and you could use fromAscList here for performance
01:12:32 <DMWIT> don't think there's a way
01:13:00 <DMWIT> Hm, it's Traversable/Foldable.
01:13:03 <DMWIT> So maybe there's a way after all.
01:13:15 <ivanm> mapM ?
01:13:29 <DMWIT> traverse readSTRef
01:13:32 <ivanm> @type Data.Traversable.mapM readSTRef
01:13:34 <lambdabot> forall s b (t :: * -> *). (Data.Traversable.Traversable t) => t (STRef s b) -> ST s (t b)
01:14:26 <DMWIT> My Data.Traversable doesn't have mapM. =/
01:14:30 <ivanm> oh?
01:14:34 <liyang> :t traverse readSTRef
01:14:35 <lambdabot> Not in scope: `traverse'
01:14:41 <liyang> Wat.
01:14:49 <DMWIT> :t Data.Traversable.traverse readSTRef
01:14:50 <SHACHAF> DMWIT: Are you sure it's not just in a class?
01:14:50 <lambdabot> forall s b (t :: * -> *). (Data.Traversable.Traversable t, Applicative (ST s)) => t (STRef s b) -> ST s (t b)
01:14:52 <ivanm> I'm looking at the docs for 4.5.1.0
01:15:14 <ivanm> are traverse and mapM the same, just an applicative/monad split?
01:15:19 <liyang> I'd avoid using the mapM* functions in favour of traverse*
01:15:24 <johnw> alright, enums looking good too
01:15:25 <liyang> ivanm: essentially.
01:15:26 <DMWIT> ivanm: I believe so, yes.
01:15:34 <johnw> now the special handling of inline functions...
01:15:38 <ivanm> liyang: why?
01:16:23 <liyang> ivanm: the class constraints are different: one requires Monad m, the other asks for Applicative f… but as was just discussed, every Monad is also Applicative.
01:16:27 <ivanm> especially since mapM defaults to using traverse with WrapMonad
01:16:53 <DMWIT> every monad is applicative, and all the sane Monads are Applicatives, too
01:17:13 <randomclown> so mapM (readSTRef) map should do it?
01:17:22 <ivanm> randomclown: no need for parens
01:17:23 <DMWIT> yep, don't even need parentheses
01:17:28 <ddarius> Even for not sane monads, you can simply declare an instance of Applicative as long as you aren't writing a library.
01:17:30 <ivanm> and make sure you're using the Traversable mapM, not the default one
01:17:50 * hackagebot regex-genex 0.5.1 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.5.1 (AudreyTang)
01:18:35 <randomclown> can you import qualified a single function?
01:18:52 <randomclown> ah you can
01:18:53 <nand`> import qualified Foo.Bar as Bat (barFoo)
01:19:09 <ivanm> why bother though?
01:19:25 <ivanm> unless you're going to import more than one module with the same qualification that has the same function name...
01:20:31 <randomclown> ivanm: so what would you do, since it would clash with control.monad mapm
01:20:46 <ivanm> randomclown: import Data.Traversable qualified
01:20:50 <ddarius> ivanm: That's a good reason and I occassionally do that.  Also, you may import different modules at different times (rather than the same time) with the same qualifier which I'm doing in code right now to switch between examples.
01:21:12 <ddarius> randomclown: Just don't import Control.Monad.mapM
01:21:34 <ivanm> ddarius: oh? the only occasion I've seen importing more than one module with the same qualification is for things like Data.ByteString{,.IO}
01:22:50 * hackagebot zipper 0.4.2 - Generic zipper for families of recursive datatypes  http://hackage.haskell.org/package/zipper-0.4.2 (AndresLoeh)
01:23:42 <johnw> is there a capitalize function?
01:24:22 <ivanm> map toUpper ?
01:24:30 <johnw> foo -> Foo, not FOO
01:24:33 <ivanm> oh, wait, just the first word to be capitalised?
01:24:40 <ivanm> do a case on the word
01:24:47 <ivanm> toUpper the head if there is one, leave the tail as-is
01:24:51 <nand`> hey edwardk, a ‘byWords’ or ‘byLines’ traversal lens would be cool
01:24:55 <johnw> ok
01:25:05 <johnw> but, I'm just surprised this isn't there
01:25:30 <ivanm> *shrug* not used all that much
01:25:43 <ivanm> besides, people are shifting over to Text, so it'd be better off having it there
01:25:55 <liyang> :t uncurry (++) . first toUpper . splitAt 1
01:25:56 <lambdabot>     Couldn't match expected type `Char' against inferred type `[a]'
01:25:56 <lambdabot>       Expected type: [a] -> (Char, Char)
01:25:56 <lambdabot>       Inferred type: [a] -> ([a], [a])
01:26:25 <liyang> > uncurry (++) . first (map toUpper) . splitAt 1 $ "hello there"
01:26:27 <lambdabot>   "Hello there"
01:26:29 <ivanm> liyang: (:), not ++
01:26:35 <ivanm> oh, right, it's a list
01:26:36 <ivanm> duh
01:26:36 <johnw> there's also toTitle
01:26:38 * ivanm facepalms
01:26:42 <johnw> capitalize (x:xs) = toTitle x : xs
01:26:46 <ivanm> @hoogle toTitle
01:26:46 <lambdabot> Data.Char toTitle :: Char -> Char
01:26:53 * ivanm wonders how it differs from toUpper
01:27:00 <ivanm> @index Data.Char
01:27:00 <lambdabot> bzzt
01:27:04 <amosr> weird unicode thing?
01:27:05 <ivanm> @doc Data.Char
01:27:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
01:27:11 <ivanm> amosr: sounds likely
01:27:21 <nand`> λ (traverseHead %~ toUpper) "foo"
01:27:23 <nand`> "Foo"
01:27:26 <nand`> pointless fun
01:27:38 <ivanm> ahhh, it's for some ligature characters
01:27:49 <ivanm> @hoogle (%~)
01:27:49 <lambdabot> No results found
01:27:59 <nand`> ivanm: package lens
01:28:01 <ivanm> ahhh
01:28:34 <nand`> edwardk: ah, but now that I think of it, that probably won't satisfy identity, unless you include extra spaces as part of the words
01:28:52 <nand`> err or just include empty words
01:28:56 <nand`> the latter seems sane enough
01:29:18 <johnw> lens is just too awesome, I have to say
01:30:49 <ivanm> never used any of lens, fclabels, etc.
01:30:56 <ivanm> no real intention of changing that any time soon
01:31:04 <johnw> it's still awesome :)
01:31:38 <johnw> _directory . _filename .~ "hey" $ "/root/foo/bar.cpp" => "/root/hey/bar.cpp"
01:32:13 <ivanm> I take it _directory and _filename are also lenses?
01:32:18 <johnw> and if the path were embedded in a map under "foo", you could map .at "foo" . _directory . _filename etc..
01:32:19 <johnw> yes
01:32:22 <johnw> FilePath lenss
01:32:25 <ivanm> hmmm
01:32:29 <ivanm> that's actually rather nice
01:32:46 <johnw> yes, it brings the power of composition to addressing paths within structures
01:32:54 <johnw> whether for reading or modification
01:34:00 <johnw> i just learned right now that there's a lens for "head", but I should have guessed :)
01:35:20 <nand`> yeah but it fails on []
01:35:24 <johnw> liyang: what is the traverse_/for_ equiv for folding?
01:35:35 <johnw> nand`: reasonable
01:35:53 <johnw> there should be a headIfExists lens!
01:35:59 <johnw> but what would modifying through such a lens mean?
01:36:08 <ddarius> consing if necessary
01:37:21 <liyang> johnw: not sure if these are equivalent in the sense you mean, but Data.Foldable (fold, foldMap)?
01:37:26 <nand`> johnw: what about traverseHead?
01:37:48 <johnw> liyang: I mean, instead of writing foldl... or do I just write foldl?
01:39:18 <liyang> Well, there are Data.Foldable (foldl, foldr) too which are more general than the list-based folds.
01:39:51 <nand`> ddarius: you mean like Simple Lens [a] (Maybe a) where l .~ Just 3 $ [] would be [3] ?
01:39:52 <liyang> They're implemented in terms of fold and/or foldMap I believe.
01:41:19 <ddarius> nand`: Something like that, yes.
01:41:52 <ddarius> More general in a relatively superficial way.
01:51:34 <Z`> Hi all. If I wanted to write a function that would accept as argument an int and it would return either int or double, its type would be:   myf :: Int -> Either Int Double ?
01:52:08 <startling> Z`: sure
01:53:16 <Z`> okl, and If I wanted to actually return something of that type I would write for example
01:53:23 <Z`> myf _ = Left 1
01:53:29 <Z`> for returning an integer, right?
01:54:40 <startling> Z`: yep
01:54:50 <Z`> thanks
01:56:11 <lpvb> yes no questions can be answered by trying :/
01:58:42 <merijn> lpvb: Not always trivially :p
01:59:06 <LaughingMan> is there a strict replicateM somewhere?
02:12:40 <johnw> it's alive!
02:12:58 <johnw> inline helpers work now too
02:13:01 <johnw> i do believe that's everything
02:15:07 <Reko_> Can anyone explain this error? http://hpaste.org/74232
02:16:10 <XexonixXexillion> What does the compilation error "ghc: fd:9: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)" mean?
02:16:35 <johnw> I think you may need a lift in there
02:17:23 <Botje> XexonixXexillion: sounds like it was expecting utf-8 and you gave it another encoding
02:17:43 <SHACHAF> Botje: Not like it was just an invalid UTF-8 file?
02:18:02 <Botje> or that.
02:18:17 <XexonixXexillion> How do I tell? It was compiling a moment ago...
02:18:20 <merijn> Reko_: The types don't match...
02:18:32 <Botje> but that's caused by mismatched encodings, in my experience
02:18:43 <merijn> Reko_: (I think, I can't be arsed to look up all the imported types)
02:18:46 <Botje> XexonixXexillion: well, what encoding is your ifle in?
02:18:58 <SHACHAF> Yep.
02:19:07 <SHACHAF> XexonixXexillion: Oh, wait, this is when you're running GHC?
02:19:18 <XexonixXexillion> SHACHAF: yep
02:19:22 <SHACHAF> XexonixXexillion: Sounds like you did something with your file.
02:19:25 <Reko_> MarkupM and Html should be equivalent. What I don't get is why >>= f is delivering the monad to 'f' instead of just 'Html'
02:20:06 <merijn> Reko_: Are you sure it's correct that msg is Reader while layout is ReaderT?
02:20:10 <XexonixXexillion> SHACHAF: how can I fix it?
02:20:19 <SHACHAF> XexonixXexillion: I don't know. What did you do to it?
02:20:25 <Botje> 'nothing!'
02:20:41 <SHACHAF> You can @paste the file, but you'd have to @paste the bytes.
02:20:59 <XexonixXexillion> SHACHAF: I moved a horrible looking list comprehension into a separate function, saved, attempted to recompile and got this error
02:21:03 <merijn> SHACHAF: Doesn't file or something detect encoding?
02:21:16 <Reko_> I use ReaderT in 'layout' since I need to transform the IO monad... but I have no such requirement in msg
02:21:49 <SHACHAF> merijn: Does it actually scan through the entire file for invalid bytes?
02:21:56 <merijn> Reko_: Are you sure that works out types wise? You can simply pass ReaderT values to a >>= expecting Reader, for example
02:22:03 <merijn> SHACHAF: Probably not?
02:22:05 <SHACHAF> XexonixXexillion: Try @pasting `xxd file.hs`, if it's small.
02:24:06 <hpaste> “xxd output” pasted “XexonixXexillion” at http://hpaste.org/74233
02:24:49 <merijn> Reko_: I don't know if H.html or H.body magically add an IO into your Reader, but if they don't (which I don't expect them to) it is a type error to use "Reader AppState Html" where you're supposed to use "ReaderT AppState IO Html"
02:25:00 <SHACHAF> XexonixXexillion: Compiles for me.
02:25:47 <XexonixXexillion> SHACHAF: I'd strongly advise not running it :p
02:26:02 <SHACHAF> XexonixXexillion: Wasn't planning to.
02:26:11 <SHACHAF> XexonixXexillion: Please don't use ByteString.Char8. :-(
02:26:24 <SHACHAF> import qualified Data.ByteString as BS
02:26:41 <SHACHAF> Then use 0x0 and 0xff instead of '\0' and '\255'
02:26:46 <SHACHAF> It makes you a better person.
02:26:56 <XexonixXexillion> SHACHAF: I also shouldn't model a bitmap as a string, it's a hack job. It was originally just a String
02:27:14 <johnw> sachaf: What's wrong with ByteString.Char8?
02:27:16 <SHACHAF> OK, but the change I just mentioned makes your program *shorter*.
02:27:23 <SHACHAF> johnw: ByteString holds bytes, not Chars.
02:27:44 <johnw> and bytes can be seen as 8-bit chars..., if you are not dealing with Unicode
02:27:51 * hackagebot c2hsc 0.1.0 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.1.0 (JohnWiegley)
02:27:56 <SHACHAF> BS.pack "ש" will just give you junk.
02:28:07 <SHACHAF> johnw: Yes, if you're RACIST!
02:28:17 <SHACHAF> Seriously, though, "Char" represents a Unicode character.
02:28:38 <XexonixXexillion> SHACHAF: as I'm using them as 8-bit numbers...
02:28:50 <SHACHAF> Writing software that doesn't support Unicode has the unfortunate property that it works for you but then doesn't work for other people who don't speak English, much later.
02:28:57 <SHACHAF> XexonixXexillion: GHC has a type for 8-bit numbers. :-)
02:29:17 <SHACHAF> Data.ByteString's interface exposes Word8 instead of Char.
02:29:38 <XexonixXexillion> SHACHAF: also, the change to Char8 was actually after this error first appeared
02:29:38 <hiptobecubic> SHACHAF, WHY SO LOUD TODAY?
02:29:42 <johnw> I use BS.Encoding.encode/decodeUtf8 when I want to pack/unpack like that
02:29:49 <johnw> but something BC8.pack has its uses
02:29:53 <johnw> s/something/sometimes
02:29:58 <nand`> ByteString.Char8 has caused me a number of headaches
02:30:01 <nand`> because people use it
02:30:02 <Reko_> merijn: But msg is pure, so it doesn't need to be IO, so what sort of signature should it have in that case?
02:30:04 <nand`> when they shouldn't
02:30:10 <johnw> let's just all ban it then
02:30:17 <johnw> anyone who uses it is perma-banned from the channel
02:30:18 <nand`> and I'm left wondering why the application crashes when I try to enter unicode
02:30:21 <SHACHAF> XexonixXexillion: Yes, I doubt it has to do with this error. I'm just saying.
02:31:04 <johnw> nand`: the place where I use it is to convert data generated by a utility; humans are never involved and the data follows a specification
02:31:05 <startling> wow, snap is nice
02:31:14 <johnw> what is snap?
02:31:20 <startling> web framework
02:31:24 <XexonixXexillion> SHACHAF: I still can't get it to work
02:31:26 <johnw> oh snap!
02:31:34 <SHACHAF> XexonixXexillion: Are you sure the file it's failing on is the file you think it's failing on?
02:31:47 <startling> johnw: :/ :( :\
02:31:56 <SHACHAF> Oh, I guess you only have one file...
02:31:57 <SHACHAF> But still.
02:32:06 <SHACHAF> XexonixXexillion: Maybe @paste `strace ghc foo.hs`
02:32:23 <XexonixXexillion> SHACHAF: I opened a new terminal and it magically started working
02:32:43 <Botje> O_o
02:33:19 <ousado> nand`: crashes because of using the wrong type, in a UI, a thing written in haskell only?
02:33:24 <SHACHAF> Maybe you messed up your locale.
02:33:25 <dabblego> is there a channel for category theory? if so what is its name?
02:33:33 <SHACHAF> dabblego: ##categorytheory
02:33:35 <startling> there's ##math
02:33:36 <dabblego> ah thanks
02:33:37 <startling> oh
02:35:13 <XexonixXexillion> SHACHAF: as I'm writing things directly to /dev/mem it wouldn't surprise me :p
02:35:23 <johnw> i'm too scared to even think of going into ##math
02:35:31 <johnw> they'd factor me into oblivion
02:35:39 <SHACHAF> You think ##math would do that?
02:35:43 <SHACHAF> try #concatenative!
02:35:43 <Botje> johnw: bet you're thinking about it now! muahahahaha!
02:36:07 <startling> ##math is pretty friendly
02:36:27 <startling> they're easier on newbies than this channel. :)
02:36:33 <johnw> I hear serial murderers are too, at first
02:36:39 <SHACHAF> Remember TRWBW?
02:36:42 <SHACHAF> Those were the days.
02:36:46 <johnw> this channel is pretty good to newbies
02:36:53 <Reko_> So, how could I interface Reader and ReaderT?
02:36:54 <johnw> unlike the newbie rage I've seen on #lisp
02:36:59 <startling> johnw: oh, there's no rage
02:37:03 <startling> johnw: more like drowning
02:37:06 <Reko_> johnw: do you have any choice quotes of that?
02:37:08 <johnw> they've kicked people for asking uninteresting questions
02:37:13 <nand`> ousado: eg. crashes because of broken formatting being sent to other applications (over HTTP, to a database, etc.)
02:37:17 <SHACHAF> Please, no choice quotes of how bad other channels are in here.
02:37:17 <Eduard_Munteanu> Reko_: interface how?
02:37:28 <startling> johnw: drowning in a sea of category-theoretic terminology
02:37:32 <Reko_> Eduard_Munteanu: I have a function using Reader that I want to call from a function using ReaderT
02:37:44 <johnw> i left #lisp 5 years ago due to their treatment of newbs, and have vowed never to return.  I much prefer #haskell
02:38:02 <johnw> monad transformers are still scary
02:38:04 * lpvb goes to #lisp and asks what's lisp
02:38:06 <johnw> but not as scary as ##math
02:38:13 <SHACHAF> Please don't troll.
02:38:18 <SHACHAF> And don't feed trolls.
02:38:20 <johnw> or, troll well
02:38:28 <Botje> Reko_: can you change the functon to MonadReader r m => .... m a ?
02:38:35 <SHACHAF> johnw: :-(
02:38:43 <Reko_> Botje: oooooh
02:38:44 <johnw> yeah, you can keep your frowny face dude
02:39:06 <johnw> meanwhile, I'm in Cabal hell, thanks to mtl
02:39:21 <johnw> seems some packages won't accept anything other than mtl-1.1.1.1, and others demand mtl-2.1
02:39:35 <johnw> so a large chunk of my world, and 10 mins of time each time, is being spent reinstalling
02:39:42 <merijn> Reko_: Why not just replace your Reader with ReaderT?
02:39:58 <Reko_> merijn: ReaderT transforming what monad?
02:40:07 <SHACHAF> I think what you usually want is MonadReader, rather than either of them.
02:40:17 <Eduard_Munteanu> Reader should already be ReaderT over Identity
02:40:24 <johnw> isn't MonadReader just a type class?
02:40:32 <johnw> I'm unfamiliar with this one
02:40:42 <johnw> :t MonadReader
02:40:43 <lambdabot> Not in scope: data constructor `MonadReader'
02:40:49 <johnw> @hoogle MonadReader
02:40:49 <lambdabot> Control.Monad.Reader.Class class Monad m => MonadReader r m | m -> r
02:40:49 <lambdabot> Control.Monad.Reader class Monad m => MonadReader r m | m -> r
02:40:57 <Eduard_Munteanu> @src MonadReader
02:40:57 <lambdabot> Source not found.
02:40:58 <merijn> Eduard_Munteanu: He's trying to use a Reader as input to >>= in a context where the result should be ReaderT IO, which of course won't work
02:40:58 <johnw> ah
02:41:09 <johnw> it's got those fancy type finalizers, or whatever they're called
02:41:16 <Eduard_Munteanu> Ah.
02:41:42 <johnw> i learned about n+k patterns the other day, kind of bizarre
02:41:48 <merijn> Reko_: Transforming IO, the only way to not do that is to have an "evalReader" (or whatever it is called) and then pass the results of that to the function
02:41:54 <johnw> there's quite a bit of stuff in Haskell no one ever mentions
02:41:55 <merijn> Reko_: Which is probably not what you want to do
02:42:06 <SHACHAF> johnw: n+k patterns aren't in Haskell.
02:42:15 <Eduard_Munteanu> johnw: possibly because they're deprecated already
02:42:51 * hackagebot lhs2tex 1.18 - Preprocessor for typesetting Haskell sources with LaTeX  http://hackage.haskell.org/package/lhs2tex-1.18 (AndresLoeh)
02:42:52 <johnw> huh, wonder why the "history of haskell" paper mentioned that they were still in the language
02:42:53 <lpvb> johnw: they were pretty kind to me
02:43:09 <johnw> lpvb: you are brave soul
02:43:21 <ddarius> johnw: Because it was written in 2007 or something like that and they were removed in Haskell 2010.
02:43:22 <johnw> are there still lazy patterns?
02:43:32 <lpvb> I asked them if it was the channel to discuss speech impediments and treatment
02:43:36 <Cale> johnw: yes
02:43:46 <johnw> i'm reading haskell 2010 report at the same time, but my Kindle has murdered it
02:43:47 <johnw> Cale!
02:43:51 <Cale> hi
02:43:55 <johnw> hi there
02:44:07 <Cale> (I should not be awake right now, but I am :)
02:44:17 <johnw> (same here, I really need to go to sleep)
02:44:26 <johnw> Haskell is just too ADDICTIVE
02:44:39 <johnw> i've been coding c2hsc for 14 hours now
02:44:48 <Cale> In my case it's just allergies
02:45:06 <johnw> and I'm finding that type errors are getting easier to resolve
02:45:08 <lpvb> c2hsc?
02:45:18 <johnw> c2hsc takes a C header file and spits out a .hsc
02:45:36 <Reko_> johnw: wait, that sounds addictive
02:45:46 <lpvb> johnw: google is not helping me
02:45:46 <Reko_> is it like an automatic FFI binding generator?
02:46:09 <johnw> lpvb: https://github.com/jwiegley/c2hsc
02:46:13 <johnw> it's a little too new for Google, I think
02:46:19 <johnw> Reko_: precisely
02:46:31 <johnw> because I'm a little too lazy to keep writing them by hand
02:46:48 <shachaf> Are you seriously calling it "c2hsc"?
02:46:49 <Reko_> What libraries have you been interfacing?
02:47:14 <johnw> for my next trick I'm going to change the build process for hlibgit2 to use c2hsc as part of its build process, rather than checking in .hsc files
02:47:17 <shachaf> You know there's already a program called c2hs, right?
02:47:33 <johnw> shachaf: yeah, but c2shachaf is too hard to type
02:47:42 <ousado> johnw: how are you dealing with preprocessor macros?
02:47:57 <johnw> ousado: I'm using the language-c library, which preprocesses the code
02:48:06 <johnw> so, I'm only dealing with actual C declarations
02:48:13 <ousado> nice
02:48:24 <shachaf> Well, that doesn't help you with #define foo(x)
02:48:35 <shachaf> (On its own.)
02:48:42 <johnw> shachaf: what would that mean to an FFI binding?
02:48:52 <Jeanne-Kamikaze> that moment when you're doing C++ and you forget you have loops so make your function tail recursive so that it runs in constant space
02:48:53 <shachaf> johnw: Anything can be a macro instead of a symbol.
02:49:20 <shachaf> johnw: Some FFI wrappers do things like int wrap_foo(int x, int y) { return foo(x, y); }
02:49:29 <shachaf> Maybe that's also necessary for inline functions?
02:49:32 <johnw> shachaf: hmm.. well, it's only at 0.1, I expect maturity will take a while
02:49:36 <ousado> oh I assumed language-c turns macros into meaningful things
02:49:39 <johnw> shachaf: I handle inlines using Bindings-DSL
02:49:59 <ousado> .. after you answered like you did
02:50:12 <johnw> it's really a C -> Bindings-DSL-style-.hsc utility
02:50:35 <ousado> johnw: I'm not sure about the name bur adrien in #ocaml did a similar thing that deals with them somehow
02:50:41 <shachaf> johnw: Whatever you do for inline functions you can probably do for macros too.
02:50:49 <shachaf> Assuming the macros are things that can even exist on their own.
02:50:50 <johnw> ousado: let's say, I don't have any macros in the library I'm binding to, so I haven't run into it yet
02:51:11 <ousado> johnw: it's a very common case
02:51:14 <johnw> shachaf: ok, I'll keep that in mind
02:51:46 <johnw> my first 4 hours on this project were spent writing a Parsec parser to chop away at C code
02:51:50 <johnw> not so much fun, that
02:54:52 <johnw> ousado: do you know of a library that depends on handling macros that I can test against?
02:57:29 <shachaf> Write your own.
02:57:37 <johnw> not interesting
02:58:09 <shachaf> It's a one-line thing...
02:58:20 <johnw> submissions welcome :)
02:58:47 <bitonic> shachaf: ah!  you're not caps anymore.  you're green again now.
02:59:40 <ousado> johnw: e.g. openssl :)
02:59:52 <sHACHAF> johnw: #define foo(x) ((x) + 1)
02:59:54 <n00b6502> zlib is quite #define heavy if i recall
02:59:56 <johnw> ousado: thanks!  i'll give that a try when next I have time
03:00:02 <johnw> night all
03:01:49 <Reko_> johnw: I once came across this mad project, which appears to be a CLOS/Objective-C-ish OO C implementation
03:02:01 <Reko_> johnw: It uses macros like crazy, I never deciphered them all... https://github.com/CObjectSystem/COS
03:02:16 <Reko_> johnw: but that might be a bit too extreme for your purposes
03:02:37 * timthelion no longer sees "parse error" but rather 10 pages of type errors.  Begins jumping up and down in excitement.
03:17:39 <astry_> hi
03:18:37 <astry_> i want to match against a pattern where one bit of the value gets put through a function, how can i do that?
03:19:09 <astry_> for example i want (_, 'b') to match ("foo", "bar"), and the function being applied is head
03:20:11 <sHACHAF> ?
03:20:22 <sHACHAF> Can you explain that differently?
03:20:29 <Saizan> you can use ViewPatterns
03:20:38 <sHACHAF> Oh, I see.
03:20:48 <sHACHAF> Yes, ViewPatterns.
03:20:48 <danr> astry_: http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
03:20:55 <sHACHAF> (_, listToMaybe -> Just 'b')
03:21:20 <sHACHAF> Alternatively you might be able to use PatternGuards, but that'll still require naming the thing.
03:21:43 <sHACHAF> Also you can just say (_, 'b':_) in this case.
03:21:51 <sHACHAF> "head" is an evil function and you should never use it. :-(
03:21:53 <astry_> 'head' was just an example
03:22:07 <sHACHAF> OK. :-)
03:23:38 <astry_> we can just use toUpper.head instead
03:23:58 <astry_> or (map toUpper)
03:26:03 <astry_> how would you use ViewPatterns? I can't figure out how this stuff would actually be used
03:26:38 <astry_> for example how would I implement this (toUpper.head) example?
03:27:07 <merijn> @tell johnw Holy crap, I love you! c2hsc is exactly what I've been looking for for a week!
03:27:08 <lambdabot> Consider it noted.
03:27:50 <danr> astry_: foo (toUpper . head -> 'X') = ...
03:28:15 <danr> but as sHACHAF points out, you might want to do (fmap toUpper . listToMaybe -> Just 'X')
03:28:41 <Z`> Whe, I define a new monad, like:  data SM a = SM (S -> (a,S))  do I have  to use some explicit type for 'S ?
03:28:44 <Z`> When*
03:29:12 <sHACHAF> Yes, if it's uppercase.
03:29:17 <sHACHAF> Uppercase means it's a concrete type.
03:29:20 <merijn> Z`: Yes, unless you define it like "data SM s a = SM (s -> (a, s))"
03:29:24 <sHACHAF> If you want, you can pass it as a parameter.
03:29:27 <sHACHAF> The way merijn said.
03:29:34 <astry_> danr: why would i want to?
03:29:46 <merijn> Z`: In which case you can't define "Monad SM", you'd have to define "Monad (SM Foo)"
03:29:46 <Z`> alright, thanks!
03:30:18 <merijn> (Because SM would have kind * -> * -> *, whereas Monad expects a type of kind * -> *)
03:32:16 <danr> astry_: otherwise your function crashes when evaluated on empty lists
03:32:21 <Z`> ok, so the state monad is about a computation that it is being done and at the same time about modifying a state
03:32:55 <merijn> Z`: Yes, it is a computation that happens relative to some state s
03:33:12 <danr> (since it must necessarily evaluate head [] to see if that view pattern matches)
03:33:46 <astry_> > let foo (listToMaybe -> Just 'x') = 2 in foo "xyz"
03:33:47 <lambdabot>   2
03:34:04 <astry_> danr: right, so this is just to let the compiler check the function correctness statically
03:34:10 <astry_> thanks
03:34:47 <merijn> > let foo :: State Int (); foo = do { x <- get; put (x+1) } in runState foo 0
03:34:48 <lambdabot>   ((),1)
03:34:53 <merijn> > let foo :: State Int (); foo = do { x <- get; put (x+1) } in runState foo 10
03:34:54 <lambdabot>   ((),11)
03:35:16 <merijn> > let foo :: State Int (); foo = do { x <- get; put (x+1) return (2*x)} in runState foo 5
03:35:17 <lambdabot>   Couldn't match expected type `s
03:35:17 <lambdabot>                                -> Control.M...
03:35:31 <merijn> > let foo :: State Int Int; foo = do { x <- get; put (x+1); return (2*x)} in runState foo 5
03:35:32 <lambdabot>   (10,6)
03:35:38 <merijn> Err, that's what I meant :p
03:36:56 <danr> astry_: no it has nothing to do with correctness, it is if you want to match something else too or if you don't want your functions to crash :)
03:38:04 <astry_> but that's exactly it, correctness
03:38:52 <astry_> correctness means that a piece of code can return a value given any value of its type
03:39:13 <danr> right. I would call that total functions though :)
03:40:10 <danr> and my point is that even if a function is total it may be "incorrect" (wrt to some specification) because of bugs
03:41:48 <merijn> Is it possible to let ghci produce all the -Wall compiler warnings when loading a file?
03:42:24 <danr> do you mean loading inside ghc, as with :load ?
03:42:27 <danr> ghci^
03:43:00 <danr> anyways, either works on my ghci 7.4.1 if I start ghci with -Wall
03:43:35 <merijn> danr: Yeah, that seems to work, I guess that should've been obvious :>
03:43:50 <danr> :)
03:45:19 <astry_> danr: the word "correctness" has a very specific meaning in computer science
03:45:55 <astry_> danr: also, from what i know haskell functions are not total (or not necessarily total)
03:48:12 <bitonic> astry_: yeah, Haskell functions are not necessarily total.  which is true for any turing-complete programming language
03:48:32 <astry_> aha
03:49:21 <astry_> i wonder if there's something like a total monad
03:50:11 <Z`> I tried to import System.Random module, but it couldn't be found (following a wiki tutorial). What'ss the deal ?
03:50:20 <ddarius> astry_: Not in Haskell, in the same way there isn't something like a "Pure" monad in SML.
03:50:49 <astry_> why not?
03:51:02 <danr> you're out of luck. you cannot enforce static verification of totality in Haskell. But in Agda, which is total, there is a partiality monad (http://www.cse.chalmers.se/~nad/publications/danielsson-semantics-partiality-monad.html)
03:51:03 <ddarius> Once the genie is out of the bottle, you can't put it back in.
03:51:39 <lpvb> Z`: cabal install random
03:52:03 <Z`> thanks lpvb
03:52:09 <astry_> why can you not enforce that, danr?
03:52:35 <merijn> Is there a MonadTrans instance for "StateT s"?
03:52:38 <rosie> Does anyone know of a function called "u" that converts a String to a Data.Text.Text?
03:52:54 <merijn> rosie: fromString
03:53:07 <merijn> oh, called "u", then no :p
03:53:20 <astry_> let u = fromString
03:53:21 <danr> astry_: because proving termination is an undecidable problem
03:53:47 <rosie> merijn: The function is called "u" (as in: lookup (u "description") doc), but I can't seem to find it anywhere. The library has been changed, though...
03:53:48 <danr> and Haskell admits general recursion
03:54:03 <astry_> danr: why is it necessary to prove termination in order to enforce static verification of totality in a specific program?
03:54:15 <astry_> is it because of recursion?
03:54:15 <danr> because a function that does not terminate on some value is not total
03:54:37 <astry_> what if we told the compiler "this function is not recursive"
03:54:56 <danr> then you would either be lying, or not writing any interesting functions :)
03:55:29 <astry_> but apparently people program in Agda, and all functions there are total, how does Agda know they're total?
03:55:30 <danr> or you would be writing functions that are provably terminating (though using recursion), as is the case in Agda and other languages (Coq, Isabel, etc)
03:55:58 <astry_> so if we limited ourselves to such functions, we could prove totality in haskell?
03:56:54 <danr> well yes. things are a bit more complicated because of corecursion (infinite lazy values) though
03:57:51 <merijn> astry_: Agda's type theory is consistent and strongly terminating, so it is impossible to write correctly typed functions that do not terminate in Agda (or Coq, for that matter)
03:58:14 <merijn> This also means Agda is not Turing complete without disabling (parts of) the type checker
04:00:27 <astry_> it would be fun if it were possible in haskell to go and say: "hey, in this part of the program i give up this special ability of Haskell, but instead i gain some other thing"
04:00:52 <astry_> this could apply to non-totality, garbage collection, etc.
04:01:41 <merijn> You can already give up garbage collection, just do some allocation using the FFI
04:02:19 <merijn> (In fact, that's what I'm writing right now xD)
04:02:53 <sHACHAF> That's not "giving up garbage collection" exactly.
04:03:02 <byorgey> being able to explicitly program in a total subset of Haskell would be cool indeed
04:03:17 <sHACHAF> Well, you still get some of the disadvantages of garbage collection.
04:03:30 <merijn> byorgey: Isn't that what SafeHaskell lets you do?
04:03:46 <byorgey> merijn: no
04:03:57 <byorgey> merijn: SafeHaskell doesn't do any termination analysis, for example
04:04:05 <byorgey> it just makes sure you're not using things like unsafePerformIO
04:04:08 <merijn> byorgey: oh, right
04:04:21 <merijn> byorgey: Well it doesn't allow partial functions either, does it?
04:04:34 <sHACHAF> They should just write a totality checker for existing Haskell instead of a subset.
04:04:37 <sHACHAF> I mean, how hard can it be?
04:04:39 <merijn> I was mixing up total and "non-partial"
04:04:55 <sHACHAF> "total" and "non-partial" mean the same thing, I think...
04:05:02 <byorgey> merijn: I'm not sure, but I don't think so.  Checking for partiality is also quite difficult in general.
04:05:34 <merijn> sHACHAF: Then maybe my understanding of partial is wrong
04:05:40 <sHACHAF> Or maybe mine is!
04:05:44 <merijn> Completely unrelated: is it possible to rename a function on export?
04:05:52 <byorgey> partial = not total.
04:06:12 <byorgey> merijn: no, but you can always write   foo = bar  and then export foo
04:06:51 <merijn> byorgey: That'd give me a collision with an internal function that's not being exported. I guess I should just find a better name for the internal function
04:07:04 <byorgey> hehe, yes you should
04:07:42 <sHACHAF> Haskell used to have import renaming
04:11:05 <merijn> Uninitialised fields in record syntax are initialised to undefined, right?
04:11:24 <sHACHAF> Well, to _|_
04:11:47 <sHACHAF> *** Exception: <interactive>:3:1-6: Missing field in record construction
04:12:10 <merijn> ok, close enough for me
04:12:30 <sHACHAF> But you also get a compile-time warning.
04:27:49 <merijn> hmm
04:28:35 <merijn> Shouldn't there be an instance "instance (MonadTrans t, Monad m) => Monad (t m)"?
04:29:05 <sHACHAF> No -- each transformer defines that instance for itself.
04:29:19 <danr> not all monads are transformers either... look at IO
04:29:35 <sHACHAF> danr: That's true but irrelevant.
04:29:41 <merijn> danr: That's not relevant
04:30:13 <danr> right
04:30:17 <merijn> I had a function "MonadTrans t => Foo -> t IO Foo", but it complains it can't deduce that "t IO" is a monad from there
04:30:29 <sHACHAF> merijn: Think about where the definition of (>>=) and return comes from. It has to be somewhere. :-)
04:30:34 <merijn> I guess I should make it "Monad (t IO), MonadTrans t =>"?
04:30:50 <sHACHAF> That would work...
04:30:56 <sHACHAF> I'm not sure whether there's a better solution.
04:31:10 <Z`> I'm not familiar with this syntax, when invoking a function:      random generator :: (Int, StdGen)   How does it work?
04:31:27 <sHACHAF> (x :: y) means x of type y.
04:31:34 <sHACHAF> If the type is ambiguous it might be necessary.
04:31:36 <sHACHAF> @ty 5
04:31:37 <lambdabot> forall t. (Num t) => t
04:31:37 <sHACHAF> @ty 5 :: It
04:31:38 <lambdabot> Not in scope: type constructor or class `It'
04:31:40 <sHACHAF> @ty 5 :: Int
04:31:41 <lambdabot> Int
04:31:41 <Z`> ah
04:31:59 <Z`> thanks
04:31:59 <merijn> Z`: In toher words, it's not a function, it's value whose type needs to be specified
04:32:27 <sHACHAF> Yes, this has nothing to do with functions.
04:32:39 <sHACHAF> Functions aren't really "invoked" or "called" in Haskell.
04:33:30 <Z`> but random has type:  random :: (RandomGen g, Random a) => g -> (a, g)
04:34:03 <Z`> isn't that a function mapping g's to tuples of a's and g's ?
04:34:09 <sHACHAF> It is.
04:34:23 <sHACHAF> But (random generator) has type (RandomGen g, Random a) => g -> (a,g)
04:34:32 <sHACHAF> Or probably something more specific depending on the type of generator.
04:35:33 <majoran> fail
04:35:55 <Z`> I don't get why 'random generator' results in a type error
04:36:08 <majoran> random generator :: (RandomGen g, Random a) => (a, g)
04:36:38 <majoran> :t random ?generator
04:36:39 <lambdabot> forall g a. (?generator::g, Random a, RandomGen g) => (a, g)
04:38:17 <merijn> :t random
04:38:18 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
04:38:25 <merijn> :t random undefined
04:38:26 <lambdabot> forall a a1. (Random a1, RandomGen a) => (a1, a)
04:38:43 <merijn> Z`: How should the compiler know which types you want for a1 and a?
04:42:22 <Z`> for the generator it knows its type, because I bind it like: let generator = mkStdGen 0 -- so it's 'StdGen'. For Random, yeh it doesn't know its type
04:53:39 <astry_> is it ok to ask a question about not haskell?
04:53:53 <merijn> astry_: Depends on how unrelated it is :p
04:54:41 <astry_> it's fairly general
04:54:49 <astry_> which version of my function should i keep? http://i.imgur.com/qJ5Xf.png
04:55:50 <astry_> text: http://paste.ubuntu.com/1185594/
04:55:59 <latro`a> ....why did you do that indexing trick just to do a boolean...
04:56:24 <astry_> because the older version (below) looked horrible
04:56:52 <latro`a> then use setting
04:57:04 <astry_> in what way?
04:57:04 <latro`a> like, assign the variables etc.
04:57:14 <astry_> how would you do that?
04:57:37 <latro`a> what makes the chain so ugly is mainly the long names in the == I think
04:58:10 <astry_> don't you think the upper version is more readable?
04:58:15 <latro`a> also it looks like val is not None causes more forking
04:58:20 <latro`a> so it could be at the top
04:58:27 <latro`a> and not really, no, it requires backtracking to read
04:58:38 <astry_> really? hmm
04:58:55 <timthelion> Why does "(foo,) `fmap` readTChan tchan" require -XTupleSections?  I cannot see anything "weird" about that code...
04:58:55 <latro`a> you can refactor the bottom one to make val is None be top level
04:59:12 <latro`a> which will remove several lines
04:59:22 <latro`a> also, it requires TupleSections because you used a tuple section
04:59:43 <timthelion> how is that any different than (,) 1 2?  Which requires none.
05:00:14 <latro`a> the tuple constructor isn't an actual infix function, for readability reasons
05:00:31 <latro`a> so doing sections with it requires some parsing shenanigans
05:00:41 <fmap> > (1,) 2
05:00:42 <latro`a> (,) 1 2, by contrast, is prefix, which works like any ordinary function
05:00:42 <lambdabot>   Illegal tuple section: use -XTupleSections
05:01:12 <timthelion> *sigh*
05:01:30 <latro`a> just turn on TupleSections if you want them
05:01:35 <timthelion> I did :)
05:02:39 <timthelion> Funny, when I was  a newbie, I looked at code like that and I was like WTF, why don't those guys just program normally.  And now I'm to lazy to add another line to my code to bind a variable and put a return statement :D
05:02:53 <timthelion> s/to/too/
05:02:54 <latro`a> lol
05:04:08 <fmap> ew, (1,,2) 3 works too with -XTupleSections
05:04:22 <latro`a> figures
05:04:31 <int-e> does (,2,) 1 3  work?
05:04:58 <fmap> yes
05:06:32 <randomclown> @pl \x -> if x then 1 else 0
05:06:32 <lambdabot> flip (flip if' 1) 0
05:12:11 <randomclown> does this count as tail recursive in haskell? f = putStrLn >> f
05:12:33 <latro`a> that's a type error
05:12:56 <latro`a> oh wait function monad
05:12:59 <randomclown> f = putStrLn "forever" >> f*
05:13:00 <latro`a> still probably doesn't do what you think
05:13:10 <majoran> :t let f = putStrLn >>f in f
05:13:11 <lambdabot> forall b. String -> b
05:13:22 <latro`a> right
05:13:34 <latro`a> > let f = putStrLn >> f in f "foo"
05:13:37 <lambdabot>  Terminated
05:13:41 <latro`a> :(
05:13:54 <latro`a> shouldn't do anything anyway
05:14:01 <merijn> randomclown: tail recursion isn't very important in haskell
05:14:17 <randomclown> I won't want this loop to blow the stack
05:14:24 <latro`a> ehh
05:14:34 <latro`a> > foldl (+) 0 [1..5000000]
05:14:36 <majoran> what stack?
05:14:39 <lambdabot>   mueval: ExitFailure 1
05:14:40 <lambdabot>  mueval: Prelude.undefined
05:14:45 <latro`a> > foldl' (+) 0 [1..5000000]
05:14:52 <merijn> randomclown: Haskell doesn't have a function call stack
05:14:52 <lambdabot>   mueval-core: Time limit exceeded
05:14:56 <latro`a> ...dammit lambdabot
05:15:09 <parcs`> randomclown: better to make the sharing explicit with f = let f' = putStrLn "Forever" >> f' in f'
05:15:14 <merijn> randomclown: Haskell has a pattern matching stack, as a result you don't necessarily need (or even want!) tail recursive functions
05:15:38 <parcs`> or just f = fix (putStrLn "forever" >>)
05:15:54 <merijn> randomclown: For example, "map f [] = []; map f (x:xs) = f x : xs" takes constant stack space
05:16:03 <merijn> Even though it isn't tail recursive
05:16:42 <latro`a> did you mean to recurse
05:16:47 <latro`a> because you didn't >.>
05:16:55 <fmap> `f = putStrLn >> f' => `f = (>>) putStrLn f' so it's probably not tail-recursive
05:16:58 <fmap> not if it matters
05:17:24 <latro`a> anyway
05:17:37 <latro`a> foldl' (+) 0 [1..10^7] finishes in a few seconds
05:17:47 <latro`a> (on my slowass machine)
05:18:05 <latro`a> foldl also does, surprisingly, might need to raise the cap a bit
05:18:07 <randomclown> how is 'f = putStrLn "forever" >> f' not recursive"
05:19:01 <astry_> what about those? http://dpaste.com/796188/
05:19:25 <latro`a> there we go
05:19:40 <byorgey> randomclown: that is fine.  It will not blow the stack.  In fact, there is already a combinator called 'forever' to do this
05:19:40 <latro`a> surprisingly I didn't stack overflow
05:19:43 <latro`a> but I did space leak
05:19:45 <latro`a> heavily
05:19:58 <byorgey> randomclown: you can just say  forever (putStrLn "forever")
05:20:07 <latro`a> that is the foldl version ran out of memory and the foldl' version didn't
05:20:19 <astry_> i thought you were talking about my paste for a second there
05:20:42 <byorgey> randomclown: whether it is "tail recursive" doesn't really matter in Haskell
05:21:38 <randomclown> from the 3 paragraph on article "stack overflow" on haskell wiki "if you are not writing your code tail-recursively, then that is why you are getting stack overflows"
05:22:50 <randomclown> byorgey: are they talking about something else?
05:23:11 <majoran> sounds like the wiki is wrong
05:24:06 <byorgey> the wiki is definitely wrong
05:24:21 <byorgey> what the heck
05:25:15 * byorgey makes a todo item to fix it eventually if no one gets around to it, I don't have time at the moment
05:25:41 <merijn> randomclown: Got a link for that wiki entry?
05:26:21 <randomclown> merijn: www.haskell.org/haskellwiki/Stack_overflow
05:29:18 <Saizan> randomclown: that sentence is correct if you are strict on the recursive call
05:30:22 <Saizan> randomclown: because in that case the stack essentially behaves the same as with eager-evaluation
05:33:47 <randomclown> Saizan: then would using "forever" in control.monad give rise to a space leak or something
05:35:30 <parcs`> sometimes
05:36:20 <Saizan> randomclown: forever is not strict on the recursive call,
05:39:36 <Saizan> randomclown: for most monads (>>) is not strict on the second argument
05:39:50 <randomclown> Saizan: ah ok
05:40:29 <Saizan> since the produced action when executed will trigger the execution of the first argument first (what "execution" means exactly depends on the monad)
05:40:31 <latro`a> that's a little surprising actually
05:40:46 <latro`a> I can run through examples to see that you're right, but still
05:45:44 <KBme> hi
05:46:02 <KBme> does anyone know where I can find a tutorial for creating .cabal files for happstack projects?
05:57:09 <Z`> If I :l myprogram.hs into ghci, I can then type 'x' and ghci will print a string represenation of x
05:57:21 <Z`> How could I make the same thing in a stand alone application that gets compiled ?
05:57:41 <mikeplus64> KBme: if cabal can figure out your project (if you have a src/ directory, you have a good chance of it), you can probably just run "cabal init" and it will generate a proper .cabal file for you
05:57:58 <mikeplus64> Z`: show
05:58:23 <Z`> mikeplus64: I love you. it worked
06:02:32 <timthelion> Damn... Consider "_<-takeMVar mvar;putMVar mvar val"  What if the mvar is empty?  You actually need: "putter mvar val = do{_ <- tryTakeMVar mvar; success <- tryPutMVar mvar val ; if success then return () else putter mvar val}"
06:02:59 <majoran> wat
06:03:56 <timthelion> majoran: If the MVar is full, take the contents out and then put the new contents in.  Otherwise, put the new contents in.  In case of a race, where new contents got added as soon as the old ones where discarded, take those new contents out again and repeat.
06:04:07 <majoran> how about no
06:04:17 <timthelion> majoran: ?  Better ideas?
06:04:27 <majoran> what are you trying to achieve?
06:04:52 <timthelion> I'm trying to discard the current contents of an mvar and put new contents in of course :)
06:04:58 <timthelion> without blocking indefinitely.
06:05:17 <parcs`> STM!
06:05:22 <majoran> ok, you can't do that
06:05:27 <timthelion> parcs`: of course that works too :)
06:05:32 <majoran> anything else?
06:05:36 <timthelion> majoran: I can.  I just showed you the code.
06:05:59 <majoran> you said "without blocking indefinitely"
06:06:00 <parcs`> timthelion: you probably don't want an MVar if you need that operation
06:06:45 <timthelion> majoran: my code won't block indefinitely.
06:07:05 <timthelion> parcs`: perhaps not.  Not sure.  Maybe IORef would actually be better here.  I'll think about it.
06:07:10 <majoran> ok, good for you
06:07:33 <majoran> IORef would definitely not be better because it's not an MVar, though
06:09:19 <timthelion> I could get away with an IORef here.  I'm not sure if I should.
06:09:30 <timthelion> I presume I should actually.  They're faster.
06:09:34 <timthelion> I presume.
06:09:57 <majoran> you can't use an IORef for this because it's not an MVar
06:10:07 <majoran> your stated goal is to use an MVar
06:10:22 <majoran> nothing but an MVar will achieve this
06:10:23 <timthelion> majoran: my stated goal is to write an application.
06:10:38 <majoran> where did you state that?
06:10:50 <timthelion> majoran: damn you're good at trolling
06:10:53 <timthelion> majoran++
06:11:00 <merijn> hmm, there's no "Storable a => a -> Ptr a"?
06:11:15 <parcs`> @hoogle with -- merijn
06:11:15 <majoran> merijn: needs at least some IO in there
06:11:16 <lambdabot> Parse error:
06:11:16 <lambdabot>   with -- merijn
06:11:16 <lambdabot>        ^
06:11:30 <parcs`> meretrix: with :: Storable a => a -> (Ptr a -> IO b) -> IO b
06:11:41 <mm_freak> timthelion: what's the application?  try to explain without haskell terms
06:11:45 <deech> In the new 7.6 release if I defer type errors can I still load the program into GHCI and step through it in the debugger?
06:11:54 <parcs`> yep
06:11:57 <merijn> parcs`: \o/ that's exactly what I wanted :)
06:12:38 <parcs`> pointer manipulation is surprisingly pleasant in haskell :)
06:13:15 <timthelion> mm_freak: I mistyped there. It's actually a framework.  It's a DERE-re-EVAL(don't google it, the term doesn't exist) framework.  Which is a method of evaluation, where each function has a list of dependencies, and it gets run once those dependencies are finished running(using STM)
06:13:27 <merijn> parcs`: Yeah, I noticed, wrapping structs is annoying, though
06:13:56 <merijn> parcs`: Although I saw someone working on a program that generates hsc2hs files from C headers :p
06:14:30 <parcs`> merijn: that would be great
06:14:38 <timthelion> mm_freak: that's DEREVAL(Dependency resolution evaluation(which creates a static structure)) and the dynamic STM version is "DER-re-EVAL" (Dependency resolution re-evaluation)
06:14:54 <parcs`> merijn: are you using bindings-DSL to wrap structs?
06:14:55 <astry_> timthelion: so it's a constraint solver?
06:15:10 <timthelion> astry_: Yes, exactly.  But it's not frame based :)
06:15:28 <timthelion> astry_: one directional, non frame based constrained solver.
06:15:35 <astry_> what is a "frame based solver"?
06:15:55 <merijn> parcs`: What's that?
06:16:05 <timthelion> astry_: one where you have to re-evaluate everything for every change, rather than only re-evaluating the affected nodes.
06:16:17 <mm_freak> timthelion: what's an example application of such a framework?  makefiles?
06:16:20 <astry_> what is a "frame"?
06:17:14 <parcs`> merijn: it's a set of macros for hsc2hs that make ffi bindings really easy
06:17:14 <timthelion> mm_freak: no, applications.
06:17:29 <timthelion> astry_: a frame, like in the term "Frames per seccond" in video
06:17:33 <mm_freak> timthelion: yes, but would "make" be an application?
06:17:36 <merijn> parcs`: I was using c2hs instead of hsc2hs because I couldn't find any quick documentation for hsc2hs
06:18:51 <timthelion> mm_freak: Well, consider a text editor, with a font size.  The text view is one object, and in my system, that object can listen to changes on objects it depends upon.  The text view depends on the font size, so by changing the font size the text view gets automatically redrawn.
06:19:27 <timthelion> mm_freak: this can be done very nicely with STM and orElse statements.  The text view just waits on orElse listening to all the values it depends upon.
06:20:29 <timthelion> mm_freak: it can also be done without STM, by registering the text view with the font size.  But there is a problem with that, as garbage collection isn't automatic...
06:20:35 <astry_> timthelion: no idea how that definition of "frame" relates to our discussion
06:21:17 <timthelion> astry_: well if you have an application with mutable state.  Most constraint resolvers will redraw that state entirely for each change(for each frame).
06:22:03 <int-e> maybe "time slice" would be better. the movie "frame" comes from a painting metaphor.
06:22:23 <parcs`> merijn: ah, i haven't used c2hs much. i noticed that it encourages mixing the preprocessor/FFI stuff within haskell code, which i don't like. bindings-DSL on the other hand encourages isolating the preprocessor/FFU stuff into a single file
06:22:26 * timthelion always thought that "frame" was a pretty standard term for that.
06:22:34 <astry_> timthelion: aha
06:22:56 <timthelion> astry_: but with depencency resolution based re-evaluation. I only have to re-evaluate part of the state.
06:23:09 <merijn> parcs`: Well, I'm open to nice hsc2hs tutorials :p
06:24:38 <mm_freak> timthelion: sounds like you're writing a (somewhat convoluted) FRP library =)
06:25:01 <timthelion> mm_freak: FRP is frame/time-slice based though.  And all the current implementations SUCK! :)
06:25:05 <latro`a> FRP is like kan extensions, basically everything seems to be it
06:25:38 <mm_freak> timthelion: that's a bit of an offense and shows that you at least haven't tried my own FRP library, netwire
06:25:53 <timthelion> mm_freak: I haven't tried netwire, it's true.
06:26:16 <parcs`> merijn: https://bitbucket.org/mauricio/bindings-dsl/wiki/Home
06:27:00 <mm_freak> for marketing reasons most haskellers seem to think that FRP = reactive-banana or yampa…  some of them eventually hear about netwire and migrate =)
06:27:14 <timthelion> mm_freak: actually, I'm sorry.  I didn't mean to offend.  Really. That was rude of me.  I was just venting my frustration at everyone telling me I should be using FRP, when I have repeatedly read up on FRP and either found problems with the implementations, or had trouble understanding the syntax.
06:27:41 <parcs`> merijn: for the most part bindings-DSL is self-contained and doesn't really require knowledge of hsc2hs's macros, so you can skip reading an hsc2hs tutorial
06:28:07 <timthelion> mm_freak: I'm doing my own thing, and I kind of wish people would stop telling me "you're just writting a crappy implementation of FRP" even in the face of my statements on why my system is better.
06:28:15 <mm_freak> timthelion: fmap (printf "%8.2f") (2 * time), is that really difficult to read? =P
06:28:20 <mm_freak> yes, that's netwire code =)
06:28:32 <srhb> mm_freak: What does that do?
06:29:02 <timthelion> mm_freak: have you written any large GUI apps with your framework yet?
06:29:02 <mm_freak> srhb: it's 2 times time…  when you run that application, it displays a clock that is double the speed of real time
06:29:16 <srhb> Okay.
06:29:51 <mm_freak> timthelion: no, because i'm working on version 4 right now…  if you want to try netwire, i suggest getting this:  darcs get http://darcs.ertes.de/netwire/
06:30:09 <mm_freak> as soon as it's released i'll go for a GUI
06:30:23 * timthelion doesn't trust anyone who hasn't written a GUI :)
06:30:42 <mm_freak> i've written a proof of concept web framework based on an old version of netwire, if that counts =)
06:31:41 <mm_freak> most of my applications use netwire where it's actually invisible to the user…  as latro`a noted, a lot of things are reactive, you just need to recognize them =)
06:31:48 <timthelion> mm_freak: but you would admit that you're using whole state re-evaluation based frames...
06:32:39 <mm_freak> timthelion: no, i wouldn't…  netwire is based on a category that is an extension of the automaton arrow
06:32:52 <mm_freak> it allows routing, selection and even waiting
06:33:19 <timthelion> You lost me already :)
06:33:46 <mm_freak> ok, to put it differently:  it is frame-based, but state is local
06:33:56 <mm_freak> if something isn't necessary, it isn't computed
06:34:38 <timthelion> state is local to what?
06:35:08 <mm_freak> timthelion: hold (time . periodically 1)
06:35:13 <mm_freak> that one is a second-wise clock
06:35:23 <mm_freak> the time is only calculated each second
06:35:45 <timthelion> mm_freak: and that's in it's own thread, or what?
06:36:04 <mm_freak> it's a pure thing
06:37:11 <mm_freak> no threads or any IO for that matter =)
06:37:11 * timthelion goes back to coding, so he can show mm_freak who's boss :)
06:37:21 <mm_freak> hehe
06:38:02 <mm_freak> but i'm pretty sure netwire has by far the nicest syntax compared to any other FRP library =)
06:38:44 <mm_freak> "yes" . wackelkontaktM 0.5 <|> "no"
06:38:57 <mm_freak> sometimes "yes", sometimes "no" =)
06:39:14 <clsmith> wackelkontaktM. nice.
06:39:35 <mm_freak> ("wackelkontakt" is german and means "loose wire"…  it's a netwire running gag)
06:39:43 <clsmith> i see:p
06:40:15 <clsmith> kinda makes sense. 'wagglecontact'.
06:40:29 <mm_freak> indeed =)
06:42:05 <timthelion> is that Dutch?
06:42:19 <tdammers> German, almost
06:42:56 <timthelion> oh, I see, german...
06:43:22 * tdammers is wondering what an elegant way would be to check whether a Parsec input stream is at the beginning of a line
06:43:39 <timthelion> Reminds me of my Uncle in the Czech republic, from back when I didn't speak Czech.  Only English he knew was "Do you speak Deutsch"  And I didn't know that Deutsch meand German and not Dutch :)
06:44:55 <timthelion> tdammers: I just use "lines" and then map, and foldr.  Parsec is for weirdos.
06:45:12 <hpaste> “Ertugrul Söylemez” pasted “This is what a GUI in Netwire 4 will look like” at http://hpaste.org/74238
06:45:24 <mm_freak> @ timthelion, clsmith
06:45:28 <mm_freak> see paste
06:46:05 <tdammers> timthelion: that doesn't cut it, I'm afraid
06:46:13 <timthelion> mm_freak: nice.  What about layout?
06:46:27 <mm_freak> timthelion: it's there…  think of (~-~) as "over"
06:46:47 <tdammers> under normal circumstances, I want to preserve newlines
06:47:07 <tdammers> the only exception is when a statement within {% ... %} is on its own line; in that case I want to eat the trailing newline
06:47:40 <timthelion> tdammers: I find http://hackage.haskell.org/package/her-lexer-0.0 to be very enlightening.  Conor McBride basically just uses a fold, and parses most of haskell.
06:47:47 <mm_freak> tdammers: you can't check that in parsec without state…  if you are already on the new line, then you have already missed the line feed or it has become part of your state
06:48:07 <tdammers> mm_freak: that's what I figured
06:48:27 <tdammers> I'm just wondering what the most elegant way would be to update said state
06:48:54 <tdammers> my parser is already stateful in other things, so might as well add a "start-of-line" flag or something
06:48:57 <tdammers> hold on
06:49:13 <mm_freak> tdammers: the elegant way would be not to use state, but select the path of the parser earlier
06:49:14 <tdammers> source column is always 1 at start of line, so maybe I can use that
06:49:20 <mm_freak> Parser is a monad after all =)
06:49:36 <tdammers> well, yeah, I tried that too
06:50:03 <tdammers> it doesn't work for multiple consecutive whole-line statements
06:50:38 <tdammers> I think I'll try the column number thing
06:51:00 <timthelion> mm_freak: Looking at your example, that's basically what I want.  I've just killed a lot of sheep to make mine super efficient and to be independent of GUI framework...  So I'll be successfull, while you'll be beautifull.
06:52:24 <mm_freak> timthelion: why wouldn't i have the same advantages + beauty?
06:53:46 <mm_freak> netwire easily performs 100-200 million FPS
06:54:27 <timthelion> mm_freak: But what if you have 100 gui elements.  It takes half a seccond to draw all of them.
06:54:30 <mm_freak> and it's independent of GUI framework by design…  it's a pure FRP library that can be integrated into even the most stubborn framworks like gloss, and it has been done (not by me though)
06:54:42 <mm_freak> timthelion: why would i draw all of them?
06:54:57 <mm_freak> i draw those that need to be drawn
06:54:57 <timthelion> mm_freak: consider a table.
06:55:36 <timthelion> mm_freak: and how do you tell what needs to be drawn?
06:55:50 <mm_freak> timthelion: by signal inhibition and holding
06:56:10 <timthelion> mm_freak: what is signal inhibition?  How do you tell which signals need to be inhibited?
06:57:05 <ghorn> what does it mean when my package (bindings to a C++ library) works fine when i build an executable with ghc, but gives "undefined symbol" errors when I use with ghci?
06:57:15 <mm_freak> consider a text field…  it produces when it has changed…  i'm also considering moving this part to the GUI binding
06:57:34 <mm_freak> so it can actually update subwires individually
06:57:34 <timthelion> mm_freak: but how do you know when it has changed?
06:57:50 <mm_freak> the GUI binding processes GUI events under the hood
06:58:03 <mm_freak> take the example from before
06:58:08 <mm_freak> hold (time . periodically 1)
06:58:24 <mm_freak> 'periodically 1' inhibits most of the time, but produces once each second
06:58:37 <mm_freak> 'time' is never reached most of the time
06:58:58 <timthelion> mm_freak: OK, and for a button click?
06:59:25 <mm_freak> x . clicked myButton
07:00:04 <timthelion> interesting method.  Very different from mine...
07:00:36 <mm_freak> this is all hypothetical, it works as a concept, but let me make the release of netwire 4 first
07:00:46 <timthelion> OK
07:00:54 <mm_freak> then (since so many people are waiting for it) i'll write a GUI binding, perhaps to wx or GTK
07:01:54 <mm_freak> i'm myself not that much interested in GUI programming, because i see web programming as the GUI programming of 2012 =)
07:02:29 <timthelion> The web isn't preformant enough to support my needs.
07:02:50 <timthelion> And never will be!(because I can always suck more power)
07:07:16 <timthelion> IORefs cannot be empty :(
07:07:50 <RichyB> ghorn: I think that means that you need to perform some mischief in order to get GHCi to know that it needs to pick up the appropriate .o or .so file for that C++ library.
07:08:07 <RichyB> I don't know what the appropriate mischief is, sorry.
07:08:11 <ghorn> heh
07:08:12 <levi-g> bot
07:08:15 <levi-g> help
07:08:23 <RichyB> @botsnack
07:08:23 <lambdabot> :)
07:08:28 <levi-g> @help
07:08:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:08:38 <RichyB> levi-g: /msg lambdabot @help list
07:08:46 <RichyB> Or maybe without the @, I can't remember.
07:08:48 <levi-g> thx alot
07:08:58 <levi-g> @help list
07:08:58 <lambdabot> list [module|command]
07:08:58 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
07:09:11 <levi-g> @list
07:09:11 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:09:35 <levi-g> @babel
07:09:35 <lambdabot>   bzzt.
07:09:46 <levi-g> @babel if
07:09:46 <lambdabot>   bzzt.
07:10:23 <RichyB> Please could you type "/query lambdabot"? That should open up a new window in your IRC client so that you can test commands in PM instead of in the channel. :)
07:14:17 <levi-g> @help babel
07:14:18 <lambdabot> babel <lang1> <lang2> <phrase>.
07:14:18 <lambdabot> Translate a phrase in lang1 to lang2.
07:14:18 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
07:14:34 <levi-g> @help bf
07:14:34 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
07:14:48 <clsmith> apparently not
07:14:55 <levi-g> @help check
07:14:55 <lambdabot> check <expr>
07:14:55 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
07:15:15 <levi-g> hehe
07:15:21 <levi-g> @.
07:15:21 <ghorn> RichyB: do you know if this issue is specific to C++?
07:15:21 <lambdabot> Not enough arguments to @.
07:15:25 <mux> @check 2 == 2
07:15:27 <lambdabot>   "OK, passed 500 tests."
07:15:34 <levi-g> @help .
07:15:34 <lambdabot> . <cmd1> <cmd2> [args].
07:15:34 <lambdabot> . [or compose] is the composition of two plugins
07:15:34 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
07:16:05 <levi-g> @help dice
07:16:05 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
07:16:20 <clsmith> levi-g: seriously, couldn't you do that privately?
07:16:40 <levi-g> sure, sorry, how to do that?
07:16:52 <clsmith> 15:10 < RichyB> Please could you type "/query lambdabot"? That should open up a new window in your IRC client so that you can test commands in PM instead of in the channel. :)
07:17:00 <majoran> RichyB told you
07:17:34 <levi-g> o, thanks, just away for a sec.
07:17:59 <levi-g> sorry for bother you all.
07:18:04 <clsmith> np
07:18:16 <clsmith> @babel de en wackelkontakt
07:18:17 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
07:18:24 <clsmith> oh dear >.>;
07:18:36 <Z`> I did an: import Control.Monad.State, then I tried to write an instance declaration:  instance Monad (State s) ... but it failed with illegal declaration + something about synonyms. Hints ?
07:19:46 <majoran> Z`: what are you trying to achieve?
07:19:50 <clsmith> i think generally the compiler error itself is better than a vague paraphrasing of the error :p
07:20:16 <majoran> clsmith: in this case it's fairly obvious, though
07:20:20 <Z`> I'm trying to write a simple random number generator, where the state of the generator is tracked by a state monad
07:20:28 <majoran> ok
07:20:39 <Z`> disclaimer: I'm haskell newbie
07:20:40 <merijn> Z`: "State s" is already a monad
07:20:54 <majoran> how does that lead to "instance Monad (State s)"?
07:21:29 <mm_freak> Z`: the Control.Monad.State module is (likely) from the monad transformer library
07:21:34 <Z`> ah, so State already defines return >>= and >> ?
07:21:35 <mm_freak> in that library State is just a type synonym
07:21:46 <majoran> Z`: yes
07:21:47 <mm_freak> type State s = StateT s Identity
07:22:03 <mm_freak> Z`: to practice implementing State yourself, define it yourself…  don't import Control.Monad.State
07:22:13 <Z`> oh ok, that is what confused me then
07:22:16 <mm_freak> if you want to practice /using/ State, you don't have to define a Monad instance
07:22:30 <mm_freak> everything you need is predefined for you
07:22:38 <merijn> > let foo :: Int -> State Int (); foo i = do { x <- get; put (x+i); return (3*x) } in runState (foo 1 >>= foo) 2
07:22:39 <lambdabot>   Couldn't match expected type `()'
07:22:39 <lambdabot>         against inferred type `GHC.Types....
07:22:42 <merijn> err
07:22:46 <merijn> I fail >.>
07:22:53 <merijn> > let foo :: Int -> State Int Int; foo i = do { x <- get; put (x+i); return (3*x) } in runState (foo 1 >>= foo) 2
07:22:55 <lambdabot>   (9,9)
07:22:57 <Z`> if I wanted to use a State, how would I start writing my program ?
07:22:59 <merijn> > let foo :: Int -> State Int Int; foo i = do { x <- get; put (x+i); return (3*x) } in runState (foo 1 >>= foo) 10
07:23:00 <lambdabot>   (33,41)
07:23:13 <merijn> Z`: Well, those two lines are an example :)
07:23:16 <Z`> thanks merijn
07:23:25 <mm_freak> Z`: the way you like…  i often give my monads a name:  type MyMonad = State StdGen
07:23:31 <mm_freak> myComp :: MyMonad String
07:23:51 <Z`> alright guys, you shed some light. Let me experiment a bit on what you said and come back later with any questions
07:23:54 <mm_freak> 'type' introduces a type alias, so MyMonad = State StdGen
07:23:54 <Z`> thanks
07:24:01 <mm_freak> have fun =)
07:24:09 <RichyB> ghorn: I believe that you need to do the same mischief to get .o files to be loaded by ghci for C libraries too.
07:30:23 <arthur_h1neynet> quick question about http-conduit. I have this working, but can't figure
07:30:36 <arthur_h1neynet> out how to tell it to not check SSL certificates
07:30:57 <arthur_h1neynet> ie wget --no-check-certificates equililent for connecting to websites with self-signed or
07:31:00 <arthur_h1neynet> otherwise bad certs
07:33:51 <shuvarek> ?
07:34:02 <d-snp> conduit is such a horrible name, it really makes me not want to find out what it does :P
07:34:40 <srhb> Conveys things, obviously.
07:34:52 <srhb> Or conducts.
07:36:40 <timthelion> srhb: I think it's a blend of con,fondue, and it.  "Conduit: 1. To pour fake molten cheese over something."
07:36:59 <srhb> Which everyone should want at some point anyway.
07:39:53 <clsmith> relevant: http://prettyfoods.tumblr.com/post/3579295550/aliform-cupcake-fondue
07:40:13 <clsmith> or maybe not so relevant. but seriously, cupcake fondue. genius.
07:40:24 <srhb> growrlwlrr
07:47:36 <mm_freak> arthur_h1neynet: i don't see how to do that in the interface…  you should probably ask on the yesod mailing list
07:54:59 <sheldonh> is the point of fmap to extract iterating a function over (or into) a container, for use by higher order functions that don't want to know the container type?
07:55:08 <sheldonh> s/extract/abstract/
07:55:33 <majoran> to a first approximation, yes
07:55:48 <majoran> later on it turns out that many "containers" aren't actually containers
07:56:14 <sheldonh> majoran: okay, so maybe it'll make sense later on, because i'm having trouble understanding the value fmap adds over map
07:56:34 <mm_freak> sheldonh: to understand 'fmap' it's actually useful to understand in simple terms what a functor is
07:56:56 <mm_freak> a functor takes a type and maps it to another type…  fmap the maps functions to the new wrapper type
07:56:57 <majoran> sheldonh: that's easy. it works for more than just lists
07:57:03 <mm_freak> this can be a container and many other things
07:57:20 <EvanR> map works on lists, fmap works on any functor, including lists
07:57:21 <sheldonh> oh. of course. map :: (a -> b) -> [a] -> [b]
07:57:25 <majoran> mm_freak: clarity destroyed by "the"
07:57:58 <mm_freak> the Maybe functor maps Int to Maybe Int, its corresponding fmap maps Int -> Int to Maybe Int -> Maybe Int
07:58:15 <sheldonh> so i have a data type that i think is traversable, and i make my type an instance of Functor and implement the traversal fmap?
07:58:17 <mm_freak> fmap :: (Functor f) => (a -> b) -> (f a -> f b)
07:58:45 <mm_freak> sheldonh: it doesn't have to be traversable…  it just needs to be "sensible" to lift functions that way
07:59:19 <mm_freak> (there is a formal definition of "sensible", but ignore that for now)
07:59:36 <pmade> I was looking at the breadcrumbs the other day and this didn't seem correct to me: last lst = lst !! (length lst)
07:59:55 <EvanR> heh
08:00:11 <mm_freak> pmade: that's a very bad definition of 'last' anyway =)
08:00:14 <pmade> There's not contact information on that page, so I'm not sure who to ask about that.
08:00:21 <EvanR> @pl \lst -> lst !! (length lst)
08:00:25 <lambdabot> ap (!!) length
08:00:32 <mm_freak> it's also incorrect
08:00:39 <mm_freak> > "abc" !! 3
08:00:40 <lambdabot>   *Exception: Prelude.(!!): index too large
08:00:48 <EvanR> @pl \lst -> lst !! (length lst - 1)
08:00:48 <lambdabot> ap (!!) (subtract 1 . length)
08:12:15 <hpaste> Rob pasted “Using functional dependencies to combine...” at http://hpaste.org/74246
08:12:26 <robstewartuk> Hi, I'm having an issue with using Data.Text with GenParser. See http://hpaste.org/74246
08:12:37 <robstewartuk> I've pasted the error there also. Any ideas ?
08:14:17 <majoran> :t satisfy
08:14:19 <lambdabot> Not in scope: `satisfy'
08:14:22 <majoran> oh well
08:15:24 <Aune> Im taking a first look at GADTs. This might b a stupid question but can I write an extraction function for this GADT?: http://hpaste.org/74247
08:16:33 <sheldonh> mm_freak: oh. lifting is just when you lift data out of compound data, right? (like lifting an Int out of a Maybe Int)
08:16:52 <mm_freak> sheldonh: no, lifting a -> b to Maybe a -> Maybe b
08:17:00 <mm_freak> check the type signature of fmap
08:17:08 <mm_freak> :t fmap (+1)
08:17:09 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
08:17:26 <majoran> sheldonh: I think that's called a projection
08:21:52 <latro`a> sheldonh, lifting is the other direction more or less
08:23:18 <latro`a> anyway, Aune, I don't see how, at least not with those constructors alone
08:24:52 <Aune> latro`a, ok. If I want to be able to do that, is there a simple rewrite of the constructors that do that?
08:25:06 <hiptobecubic> We don't have higher order types do we?
08:25:09 <latro`a> you can map back to Unsafe
08:25:13 <latro`a> and then pattern match
08:25:13 <latro`a> I think
08:25:22 <latro`a> could be mistaken (I'm also new with GADTs)
08:25:36 <mm_freak> hiptobecubic: if you define higher order types as types of kind (* -> *) -> *, then yes, we have them
08:25:47 <mm_freak> check Kleisli
08:27:59 * hackagebot warp 1.3.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.1 (MichaelSnoyman)
08:31:35 <Lutin_> knock knock
08:37:16 <hpaste> danald annotated “Extracting data from GADT” with “Extracting data from GADT (annotation)” at http://hpaste.org/74247#a74251
08:37:46 <Eduard_Munteanu> Lutin_: who's there?
08:40:49 <thirsteh> can I pattern match the head of a list, discarding the rest, i.e. case args of [arg,_] ->   ?
08:41:27 <Mortchek> thirsteh, (x:_)
08:41:52 <hpaste> rosie pasted “data conversion” at http://hpaste.org/74252
08:42:17 <rosie> What's an example of how I could pattern match against the last value in an instance defined in the hpaste?
08:42:31 <thirsteh> Mortchek: oh, thanks! For some reason I only expected that to work on (a,b,c) etc.
08:42:54 <rosie> I figure I would have had to have constructed a BsonVal using one type, and then I use it in a place where another type is expected...
08:43:14 <Mortchek> thirsteh, : is the list constructor. The parens are only for the sake of precedence[1;5C[1;5C
08:43:23 <Mortchek> Sorry about the garbage :P
08:43:46 <thirsteh> Mortchek: makes sense now
08:44:09 <Lutin_> Eduard_Munteanu: Lutin_
08:44:14 <Lutin_> Lutin_ is there
08:44:16 <typoclass> thirsteh: yeah, the important thing there is the ":", the list constructor, and not the parens. might be a little confusing. so comma is tuples, colon is lists, and the parens are not the point :-)
08:44:20 <Eduard_Munteanu> Lutin_: Lutin_ who?
08:44:22 <Lutin_> Who else would be knocking!?
08:44:32 <Aune> danald, thanks. Thats nice.
08:44:32 <Mortchek> Pattern matching on a tuple would look like (x, _)
08:44:35 <Eduard_Munteanu> :P
08:45:05 <Lutin_> Mortcheck: on a pair?
08:46:21 <thirsteh> typoclass, Mortchek: yeah, the being used to triplets between parens was what threw me off, but it makes sense that it's only precedence and cons etc. are the constructors
08:46:36 <Eduard_Munteanu> rosie: I'm not sure, do you want to extract values from arbitrary things?
08:49:56 <Mortchek> Lutin_, that example was on a pair, but you can do it with any tuple. (Sorry, lost wifi.)
08:50:27 <sheldonh> gosh, RWH explains functors way better than LYAH. i guess you really do need both books if you're completely green :)
08:50:38 <Lutin_> Yeah I was just trying to clarify it only works on a pair instead of any tuple
08:50:40 <thirsteh> sheldonh: they complement each other
08:50:54 <Lutin_> Since any other tuple you have to do (x,_,_,etc)
08:51:09 <Mortchek> > let f (_, a, _, b) = a + b in f (1, 2, 3, 4)
08:51:10 <lambdabot>   6
08:51:23 <Lutin_> Yeah
08:51:25 <Eduard_Munteanu> sheldonh: it often happens you need a second take on a given topic to get it :)
08:52:12 <Eduard_Munteanu> Google also helps there.
08:54:18 <Lutin_> I'm sitting in a C++ based programming class right now
08:54:21 <Lutin_> I'm so bored :X
08:54:35 <Lutin_> This isn't even fun to code in
08:54:49 <Eduard_Munteanu> Lutin_: it could work on any tuple if you used unlifted tuples, like (x, (y, z))
08:54:52 <qwr> Lutin_: do some C++ template metaprogramming then
08:54:59 <Eduard_Munteanu> Unlifted pairs that is.
08:55:18 <Lutin_> Eduard_Munteanu: Ahhh, that's what I was looking for earlier
08:55:23 <qwr> Lutin_: C++ templates are quite weird functional language by their own
08:55:59 <Lutin_> qwr: Yeah I wish we were even getting into that. I mean I know how to do it, but I think the guy would look at me funny if I used them right now lol
08:56:16 <Lutin_> It's just a prereq class and I couldn't get out of it
08:57:11 <Eduard_Munteanu> It's funny how parametric polymorphism got pushed into the esoteric / complex stuff corner of C++.
08:57:22 <Lutin_> I know :[
08:57:39 <Lutin_> He's not even explaining these concepts in the best ways imo
08:58:16 <Eduard_Munteanu> In Haskell it's the other way around.
08:59:09 <Lutin_> It's partially because people view it as a superset of C, and then code like it's C
08:59:33 <Eduard_Munteanu> Mm, C doesn't have ad-hoc polymorphism either, though.
08:59:34 <Lutin_> instead of being like "Woah, lets start over now that we have all this cool shit"
08:59:45 <Eduard_Munteanu> So my guess is it's more of a OOP thingy.
09:00:57 <Eduard_Munteanu> While parametricity goes well with the functional paradigm, on the other hand.
09:06:21 <hpaste> rosie pasted “data conversion, more info” at http://hpaste.org/74253
09:06:24 <rosie> Edward_Munteanu: thanks, I've provided more info on the specific situation. Let me know if I can provide any more information!
09:15:00 <MHD> What's a good -XViewPatterns tutorial?
09:17:27 <majoran_> map _ [] = []; map f ((f -> y) : (map f -> ys)) = y : ys
09:17:31 <danr> MHD: did you check the ghc trac? http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
09:17:45 <danr> also what majoran said
09:17:47 <danr> ;)
09:18:16 <MHD> hmmm
09:18:24 <MHD> That is seriously strangeloopy
09:18:25 <Eduard_Munteanu> It's also nice to use with Seqs.
09:18:33 <MHD> I can imagine
09:19:03 <Eduard_Munteanu> You can do stuff like f (viewl -> a :< as) = ...
09:19:14 <MHD> nice
09:20:04 <MHD> What is the -X... that uses IsString for polymorphic string literals?
09:20:27 <Eduard_Munteanu> OverloadedStrings IIRC?
09:24:31 <MHD> Is there a corresponding one for plain Lists?
09:25:51 <MHD> what is the difference between -XRank2Types and -XRankNTypews
09:26:09 <MHD> s/-XRankNTypews/-XRankNTypes/
09:26:31 <majoran> the N stands for "three"
09:26:45 <Eduard_Munteanu> MHD: well, pretty much what the name says, Rank2Types only gets you rank <= 2 types.
09:26:59 <danr> MHD: http://en.wikipedia.org/wiki/Higher-ranked_polymorphism#Higher-ranked_polymorphism
09:27:05 <Ralith> Enigmagic: you around?
09:27:46 <Ralith> Eduard_Munteanu: why doesn't Rank2Types get subsumed?
09:28:01 <Eduard_Munteanu> Ralith: it is subsumed by RankNTypes
09:28:20 <Ralith> I mean, why does the option exist anymore? Backwards compatibility?
09:28:36 <majoran> other implementations only go up to 2
09:28:43 <majoran> also, rank-2 is theoretically decidable
09:28:54 <majoran> inference, that is
09:29:03 <Eduard_Munteanu> Ralith: oh, not sure exactly why. Might have something to do with what majoran says or with the fact rank 2 types can be inferred and rank >= 3 can't.
09:29:24 <Ralith> ah.
09:29:33 <MHD> What does GHC do with RankNTypes and an undecidable inference? Barf?
09:29:52 <n-dolio> Some compilers implement Rank2Types but not RanNTypes.
09:29:58 <Eduard_Munteanu> MHD: it still tries to infer rank 1 types
09:30:05 <robstewartuk> yikes, this error is killing me :-/ http://hpaste.org/74246
09:30:17 <Eduard_Munteanu> But you don't really have principal typing anymore.
09:30:35 <MHD> Is that bad?
09:30:56 <Ralith> not terribly.
09:31:00 <Eduard_Munteanu> MHD: you have to provide annotations for non-rank 1 types.
09:31:13 <Eduard_Munteanu> Type signatures I mean.
09:31:13 <MHD> ok
09:32:28 <Peaker> Do people pronounce "GADT" as "G.D.T"? I thought "Gaddetts"
09:33:10 <danr> G.A.D.T.s is a common pronounciation
09:33:39 <MHD> I pronounce it Generalized Algebraic Data Types
09:33:56 <MHD> or gen alg data
09:34:45 <thirsteh> Genalgatypes
09:34:50 <Peaker> -XDataKinds seems to make data constructor names go into the type-level too.. no more   data A = A ?
09:37:51 <Peaker> Nice! HList is so much nicer with -XDataKinds
09:37:56 <Peaker> watching http://vimeo.com/42399455
09:41:40 <jfischoff> I wish i could see the slides better :(
09:42:00 * jfischoff just noticed the link
09:48:01 * hackagebot optparse-applicative 0.4.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.4.1 (PaoloCapriotti)
09:49:19 <Z`> I'm starting to understand things. \o/
09:49:44 <MHD> Z`: congrats!
09:49:52 <notdan> Hello.
09:50:03 <Z`> This channel is very helpful
09:50:05 <Z`> hi notdan
09:50:10 <notdan> I want to make a timer in Haskell, what do you people recommend?
09:50:22 <Clint> an egg timer?
09:50:23 <notdan> I thought about using simple threads + some sort of `sleep'?
09:50:36 <notdan> Well, a general timer
09:51:11 <MHD> Is there some sort of monad class that supports monads which has runXxx to IO
09:51:19 <notdan> At which packages should I take a look?
09:51:59 <c_wraith> MHD: something like m a -> IO b, or something like IO a -> m a  ?
09:52:10 <k0ral> hello
09:52:43 <k0ral> I hope there are proficient users of the glib/gtk package here, I have a conceptual question about it
09:53:16 <c_wraith> MHD: the former is basically any monad transformer, plus some custom things built on top of IO that don't expose a transformer.  The latter is the MonadIO class
09:53:18 <MHD> c_wraith: I am not sure what I was thinking, let me mull it over.
09:54:43 <k0ral> when binding a callback function to a GObject signal, it seems impossible to do purely stateful computations inside the callback; I mean: I can't see any way for the callback to change a global state without using IORefs (or MVar or...)
09:55:13 <majoran> k0ral: how could it be otherwise?
09:55:48 <k0ral> majoran: I guess it's obvious that it couldn't, but it didn't strike me until now
09:56:06 <k0ral> majoran: at least you're answering my actual question which was: do you confirm ?
09:56:28 <k0ral> and now I have to turn every MonadState into an IORef
09:56:36 <majoran> also, what's a global state?
09:57:47 <k0ral> majoran: anything I can read/write from anywhere in the application, including callback functions
09:58:23 <majoran> there is no such thing
09:58:45 <k0ral> majoran: I tried using MonadState and liftBaseWith from monad-control, but I noticed every state modification performed inside the callback were lost right after
09:58:55 <majoran> haskell doesn't believe in global state
09:59:19 <majoran> State is merely a thin wrapper around s -> (a, s)
09:59:20 <zachk> haskell might believe in immutable global state.... that is well defined at compile defined....
09:59:28 <majoran> IORefs et al. can't be global
09:59:28 <k0ral> well, using glib, I have no choice
09:59:52 <zachk> majoran: not even with unsafePerformIO ?
10:00:06 <k0ral> glib has you creating callback functions, which naturally leads you to need global state
10:00:44 <zachk> k0ral: you dont need a global state per se, you just nee a parameter/argument/variable that can hold/represent such state , and the ability to "pass it around"
10:00:52 <majoran> zachk: we don't talk about that here
10:01:07 <majoran> k0ral: technically, that's local state
10:01:12 <zachk> majoran: fair enough
10:01:19 <majoran> :-)
10:01:42 <zachk> k0ral: you only have in a function what you bring into into it in haskell
10:01:52 <k0ral> zachk: I thought so, but given the glib API, there is no way to get a return value from a callback function triggered on a GObject signal
10:02:21 <k0ral> zachk: so any state you would pass to it would be thrown away at the end
10:02:35 <zachk> k0ral: you have a link to the glib api?
10:02:44 <k0ral> zachk: I have to resort to IORefs
10:02:59 <k0ral> zachk: http://hackage.haskell.org/packages/archive/glib/0.12.3.1/doc/html/System-Glib-Signals.html
10:03:19 <k0ral> majoran: a local state covering 99% of my application runtime
10:04:05 <zachk> k0ral: you could have it perform an action on an IO Channel possibly, that is in another thread
10:05:13 <k0ral> zachk: that means using IO anyway :)
10:05:37 <zachk> k0ral: but it might be what you want, whats wrong with IO anyways, if you are doing alot of IO ?
10:06:01 <notdan> from Control.Concurrent docs on threadDelay "There is no guarantee that the thread will be rescheduled promptly when the delay has expired". This might be a stupid question (and I suspect that the answer is `no'), but is it possible to make thread sleep for _exact_ number of ms?
10:06:02 <k0ral> zachk: the least IO I do, the better, you know the deal :)
10:06:27 <zachk> whose deal? is it your deal of having a something working you can show other humans in a short, reasonable amount of time?
10:06:31 <majoran> notdan: that's impossible on any computer with an OS
10:06:52 <k0ral> majoran: not even using real time OS-es ?
10:06:59 <notdan> majoran: ah, like i've suspected; but I assume the difference is so small it's almost impossible for a human to distinguish?
10:07:00 <majoran> ok, point
10:07:06 <majoran> I meant "desktop OS"
10:07:18 <majoran> notdan: depends on what everything else is doing
10:07:25 <k0ral> zachk: yes it is :)
10:15:47 <majoran> zachk: there are modules for memoization
10:16:40 <zachk> majoran: I don't want to use a module for memoization at this point in my haskelling
10:19:14 <EvanR> "forgot to memoize"
10:19:50 <Ralith> How can I spawn a process and write to its stdin/read from its stdout?
10:20:32 <zachk> Ralith: attempt to google: circular pipes or something to that affect
10:20:56 <Ralith> wat
10:22:18 <majoran> @hoogle createProcess
10:22:18 <lambdabot> System.Process CreateProcess :: CmdSpec -> Maybe FilePath -> Maybe [(String, String)] -> StdStream -> StdStream -> StdStream -> Bool -> CreateProcess
10:22:18 <lambdabot> System.Process data CreateProcess
10:22:18 <lambdabot> System.Process createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
10:22:40 <Ralith> thanks
10:22:44 <Ralith> looks perfect :D
10:23:02 * hackagebot grid 1.0 - Tools for working with regular grids\/graphs\/lattices.  http://hackage.haskell.org/package/grid-1.0 (AmyDeBuitleir)
10:24:03 <Z`> http://paste.lisp.org/display/131512 any idea on my question on last line ?
10:24:34 <sellout42> Ralith: You've relocated :)
10:24:57 <Ralith> sellout42: the dependent types were over here.
10:25:10 <sellout42> Heh.
10:26:40 <zachk> Z`: what is the type signature of execState?
10:26:48 <majoran> Z`: why do "we" want the return value?
10:27:12 <Z`> execState :: State s a -> s -> s
10:27:46 <zachk> and the type signature of tick?
10:27:50 <Z`> majoran: perhaps I'm thinking imperative.. don't we want our function plus to return the new value after he have run the computation ?
10:27:53 <Z`> tick is hm
10:27:58 <Z`> tick :: State Int Int
10:28:12 <majoran> Z`: I don't know. do we?
10:28:41 <majoran> where is this code coming from?
10:28:45 <Z`> I think we do, otherwise plus 5 would return 5. although reality is the opposite of my expectation
10:29:00 <aleksandar> what's the topic?
10:29:07 <Z`> from hackage.haskell.org
10:29:08 <zachk> so if you apply execState to tick, what is the type signature of the resulting (partial) application?
10:29:56 <Z`> execState tick :: Int-> INt
10:30:27 <zachk> so Z`, do you even need the n? :-D
10:30:58 <EvanR> :t succ
10:30:59 <lambdabot> forall a. (Enum a) => a -> a
10:33:32 <aleksandar> :t toUpper
10:33:33 <lambdabot> Char -> Char
10:33:42 <aleksandar> cool
10:33:55 <aleksandar> what else can haskell's irc bot do except
10:34:03 <aleksandar> type signatures
10:34:09 <EvanR> > toUpper 'a'
10:34:10 <lambdabot>   'A'
10:34:25 <EvanR> > unsafePerformIO deleteFileSystem
10:34:26 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `deleteFileSystem'
10:34:31 <aleksandar> map toUpper "aleksandar"
10:35:20 <aleksandar> map (\c -> toUpper c) "aleksandar"
10:35:56 <nejucomo> How is lambdabot sandboxed?  Is it sandboxed at the language level or "underneath at the os layer"?
10:36:09 <ksf> both
10:36:48 <aleksandar> hoogle map
10:36:58 <aleksandar> can lambdabot invoke hoogle?
10:37:04 <ksf> you don't get to execute any IO stuff and there's no unsafeCoerce so your code can't run wild in the first place.
10:37:05 <tgeeky> @hoogle map
10:37:05 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
10:37:06 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
10:37:06 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:37:11 <tgeeky> aleksandar: yes
10:37:56 <aleksandar> @tgeeky thanks
10:37:57 <lambdabot> Unknown command, try @list
10:38:01 <aleksandar> @list
10:38:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:38:23 <aleksandar> http://code.haskell.org/lambdabot/COMMANDS
10:39:06 <aleksandar> is lambdabot visible for everyone in this chat?
10:42:01 <astry_> aleksandar: yes
10:42:38 <aleksandar> how can I send a message so that is like <red>tgeeky</red> thanks
10:42:49 <astry_> you don't
10:42:56 <astry_> this is irc not aol chat
10:43:09 <astry_> if you want to higlight someone you just say their name
10:43:26 <astry_> it's customary to send messages directed to someone by starting with their nick and then a colon
10:43:32 <astry_> like this...
10:43:41 <astry_> aleksandar: this message is for you
10:44:18 <aleksandar> astry_: hello
10:44:36 <astry_> hi
10:45:01 <astry_> because you said my name, your nick showed up in yellow, as opposed to the usual gray
10:45:06 <astry_> so it stood out
10:46:54 <astry_> aleksandar: anyways you can get more help here http://freenode.net/using_the_network.shtml
10:47:38 <aleksandar> astry_: thanks
10:47:41 <astry_> yw
10:52:51 <Sculptor> hi
10:53:18 <aleksandar> hi
10:53:45 <Sculptor> poz zemljace
10:54:39 <aleksandar> :D
10:54:45 <aleksandar> sta ima
10:54:55 <Sculptor> nothing much. just came home from work
10:55:06 <aleksandar> where do you work?
10:55:12 <Sculptor> it's a secret
10:56:16 <aleksandar> well I know you work in the country :D
10:58:42 <Sculptor> tally ho
10:58:44 <OceanSpray> I need a set of simple mutually recursive definitions that don't make use of any functions other than themselves
11:00:27 <osfameron> don't we all
11:05:16 <Dodek> OceanSpray: what do you mean by "don't make use of any functions other than themselves"?
11:05:49 <OceanSpray> by that I mean no "odd; even" because they make use of arithmetic functions
11:06:02 <OceanSpray> I'm trying to test a type checker
11:06:18 <OceanSpray> all I got are lambdas
11:06:26 <OceanSpray> so I'm kind of working in a vacuum
11:07:41 <aleksandar> like (\x -> x + 1) 1
11:07:56 <OceanSpray> I don't have (+)
11:08:04 <OceanSpray> hell, I don't have numbers
11:08:18 <majoran> are all values of type a@(a -> a)?
11:08:42 <OceanSpray> yes
11:08:52 <majoran> then you can't have type errors
11:09:15 <OceanSpray> majoran, what do you mean by a@(a -> a) then
11:09:58 <majoran> "a function that takes a function of its own type and returns a function of its own type"
11:10:07 <OceanSpray> then no
11:10:10 <majoran> pure lambda calculus, basically
11:10:21 <OceanSpray> think pure System F instead
11:10:41 <majoran> I don't know System F
11:11:12 <OceanSpray> there's plenty of opportunity for occurs and escape check violations
11:11:23 <OceanSpray> okay maybe not the latter
11:11:56 <majoran> is (\x -> x x) an error?
11:12:21 <Botje> an infinite type, yes.
11:14:14 <johnw> majoran: if you call it, I believe the answer is "bottom"
11:14:15 <lambdabot> johnw: You have 1 new message. '/msg lambdabot @messages' to read it.
11:14:39 <majoran> johnw: your belief is unfounded
11:15:12 <johnw> it's it the same as fix id?
11:15:16 <johnw> s/it's/isn't
11:15:56 <majoran> no
11:16:30 <majoran> consider (\x -> x) (\y -> z)
11:16:35 <majoran> er
11:16:37 <johnw> i guess (\x -> x x) (const 10) should just return 10
11:16:39 <johnw> so, ok
11:16:42 <majoran> right
11:16:59 <johnw> i just woke up, neurons are lazy
11:17:12 <Cale> (\x -> x x) (\x -> x x) is another matter though
11:17:33 <Cale> @pl (\x -> x x) (\x -> x x)
11:17:35 <nand`> yeah, if you have (\x -> x x) your system can't be normalizing
11:17:36 <lambdabot> ap id id (ap id id)
11:17:37 <lambdabot> optimization suspended, use @pl-resume to continue.
11:18:00 <johnw> is that the same as fix (\x -> x x)? :)
11:18:12 <mm_freak> there is no (\x -> x x) in haskell
11:18:28 <johnw> :t (\x -> x x)
11:18:28 <Cale> You can approximate (\x -> x x) in Haskell with a newtype though
11:18:29 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:18:29 <lambdabot>     Probable cause: `x' is applied to too many arguments
11:18:29 <lambdabot>     In the expression: x x
11:18:39 * nand` .oO( Can you write it with some recursive type trickery? )
11:18:47 <Cale> absolutely
11:18:55 <mm_freak> newtype/data trickery
11:19:04 <mm_freak> not literally 'type' trickery
11:19:17 <majoran> ocaml -rectypes
11:19:17 <nand`> yes
11:19:42 <Cale> > (\x -> outR x x) (InR (\x -> outR x x))
11:19:46 <edwardk> clearly that should just be \x -> unsafeCoerce x x
11:19:57 <majoran> :t Mu
11:20:01 <lambdabot>   mueval: ExitFailure 1
11:20:01 <lambdabot>  mueval: Prelude.undefined
11:20:04 <lambdabot> Not in scope: data constructor `Mu'
11:20:21 <nand`> that's a lot of errors
11:20:27 <edwardk> :t \x -> unsafeCoerce x x      :: a -> t
11:20:28 <lambdabot> Not in scope: `unsafeCoerce'
11:20:38 <Cale> newtype Rec a = InR { outR :: Rec a -> a }
11:21:26 <Cale> This provides an isomorphism between  Rec a and Rec a -> a, which is enough to make things like the Y combinator and that omega expression typecheck :)
11:21:48 <majoran> > 1 :: Void
11:21:51 <lambdabot>   Not in scope: type constructor or class `Void'
11:22:20 <majoran> @let scream = unwords . sequence . words; newtype Void = V Void
11:22:20 <lambdabot>  Invalid declaration
11:22:39 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
11:22:42 <lambdabot>   3628800
11:23:35 <nand`> I've wondered before, would it be possible to empower type signatures with a concept of ‘holes’, or types that you don't want to specify? Only the parts that you did specify would be used by the type checker; for example something like (undefined :: _ -> _), which in this case doesn't save you much over (undefined :: a -> b) but consider something like (fromIntegral :: _ -> Rational) which would get its
11:23:37 <nand`> type inferred as Integral a => a -> Rational
11:24:01 <nand`> the same thing could in this case be achieved by using (\x -> fromIntegral x :: Rational)
11:24:45 <majoran> :t (\x _ -> x x) (\x _ -> x x)
11:24:46 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:24:46 <lambdabot>     Probable cause: `x' is applied to too many arguments
11:24:46 <lambdabot>     In the expression: x x
11:25:06 <majoran> :t (\x _ -> outR x x) (InR (\x _ -> outR x x))
11:25:07 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
11:25:08 <Cale> nand`: Yes
11:25:08 <lambdabot>     Probable cause: `outR' is applied to too few arguments
11:25:08 <lambdabot>     In the expression: outR x x
11:25:14 <ReinH> Cale: btw I think this is a very obvious demonstration of how ap works with the function monad:
11:25:14 <Cale> nand`: In fact, isn't that implemented?
11:25:18 <ReinH> > ap (,) (+1) 1
11:25:19 <lambdabot>   (1,2)
11:25:28 <nand`> for another construed example, suppose you have some tuple of type Integral a => (a, ReallyLongType), and I just want to write myTuple :: (Int, _)
11:25:39 <ReinH> Cale: getting back to my epiphany from yesterday :)
11:25:59 <nand`> Cale: if so, would you know how and where?
11:26:50 <Cale> nand`: I thought I heard something about it recently, like it may be in GHC HEAD now or something.
11:27:22 <hpaste> keep_learning pasted “Thread Blocking” at http://hpaste.org/74254
11:27:36 <keep_learning> Hello All
11:28:07 <keep_learning> I am trying put the main thread to sleep as mentioned in Real World Haskell "If we try to put a value into an MVar that is already full, our thread is put to sleep until another thread takes the value out."
11:28:48 <keep_learning> I created a new MVar and put the value inside it.
11:28:52 <Ralith> any users of the LLVM bindings around?
11:29:01 <Cale> keep_learning: are you getting thread blocked indefinitely on MVar about half of the time?
11:29:04 <johnw> Ralith: I'm a big LLVM user
11:29:08 <nand`> even easier to create an empty MVar and read it, that way you don't even need to provide a value
11:29:25 <johnw> I just haven't used the *Haskell* bindings for LLVM yet :)
11:29:40 <Ralith> johnw: oh, well, that describes me as well :P
11:29:51 <Ralith> I suppose I should just ask anyway:
11:29:52 <johnw> but I mean, how strange can it be?
11:30:01 <Ralith> you might be surprised
11:30:02 <keep_learning> Cale, No Its finishing every time .
11:30:27 <Cale> keep_learning: if your main thread finishes, the whole program ends
11:30:31 <johnw> so, it looks like c2hsc can't properly handle macros
11:30:38 <Cale> keep_learning: and all other threads are killed
11:30:46 <johnw> as such, it will have to be a "first cut" tool, with refinements left up to the user
11:31:00 <Cale> (I'm not sure whether or not I like this semantics, but it's the way things currently work)
11:31:52 <keep_learning> Cale, So every time my Main finish before fun. If fun finish before main then main will go to sleep ? Am I correct ?
11:32:17 <johnw> Ralith: what's the question, anyway?
11:32:23 <johnw> Ralith: maybe together we can find an answer
11:32:58 <Ralith> The high level LLVM bindings define IR function definition builders which seem to require a static argument count.
11:33:00 <Cale> Well, if fun is able to fill the MVar, then main will get stuck, which will cause a "thread blocked indefinitely" exception because there's no thread to take the MVar, and then the program will die.
11:33:05 * hackagebot portaudio 0.2.3 - Haskell bindings for the PortAudio library.  http://hackage.haskell.org/package/portaudio-0.2.3 (AnilVaitla)
11:33:26 <Ralith> it's not clear to me how to build a function which takes an argument count determined dynamically by, say, an AST.
11:33:50 <Ralith> that is to say, the ultimately built function takes a fixed number of args, but that number is not known when the compiler is compiled
11:33:52 <Cale> If main fills the MVar first, then fun will get blocked if it tries to put, and its thread will die with a "thread blocked indefinitely"
11:34:03 <Ralith> because it depends on the input source code
11:34:16 <Cale> but possibly main will finish first in that case, which will mean fun never gets to try to write the MVar
11:34:42 <johnw> Ralith: well, that's easy to do in the IRBuilder, right?
11:34:47 <Ralith> johnw: trivial.
11:35:22 <Ralith> johnw: refer to https://github.com/bos/llvm/blob/master/examples/Fibonacci.hs
11:36:01 <hpaste> keep_learning annotated “Thread Blocking” with “Thread Blocking (annotation)” at http://hpaste.org/74254#a74255
11:36:21 <keep_learning> Cale, Thanks but I am not getting any exceptions for output
11:36:24 <Cale> keep_learning: Yeah, it looks like things favour main finishing first.
11:36:33 <johnw> ah, I see
11:36:48 <Ralith> the high level bindings have a ton of tricks to give huge improvements in safety, but it's not clear to me how to write e.g. f n = LLVM function taking n args
11:36:49 <johnw> it infers the arguments from the lambda body
11:36:52 <keep_learning> Cale, Thank you!
11:37:20 <Ralith> I think I need some RankNTypes trickery or something?
11:37:22 <johnw> so they went with a DSL that's close to writing IR by hand
11:37:34 <notdan> Is there a special function for (sequence_ . mapM)?
11:37:39 <nobdrais1ntone> Where can I found Eq instance for xml?
11:37:49 <johnw> @pl (sequence_ . traverse)
11:37:49 <lambdabot> sequence_ . traverse
11:37:55 <keep_learning> Cale, Should not it be 50 - 50 chance for getting blocked or run successfully ?
11:38:01 <Cale> keep_learning: You might try compiling with -threaded and running the program with +RTS -N2 to see if it behaves any differently.
11:38:07 * hackagebot ad 3.1.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.1.1 (EdwardKmett)
11:38:11 <Cale> You're running it in the unthreaded runtime.
11:38:18 <ReinH> edwardk: why are you so good at haskell
11:38:19 <Cale> So it may very well be deterministic.
11:38:20 <ReinH> stop it
11:38:30 <Cale> ReinH: lol
11:38:39 <Cale> ReinH: are you referring to the ad package release?
11:38:49 <ReinH> Cale: all of his stuff
11:38:50 <ReinH> it's too much
11:38:54 <ReinH> it makes me feel inadequate ;)
11:38:55 <nand`> in the untyped lambda calculus, y k is a function that takes an argument and then returns itself?
11:39:12 <Cale> nand`: y is fix
11:39:15 <johnw> Ralith: I see what you mean now
11:39:25 <johnw> Ralith: It's like a building block is missing
11:39:51 <Cale> nand`: (Y refers to a specific implementation, or perhaps a couple, of a fixed point combinator)
11:39:57 <Ralith> johnw: Enigmagic mentioned something about rank 2 types being necessary for serious work in this lib; I'm skimming the mailing list for hopes of an example...
11:39:58 <nand`> fix k then
11:40:07 <hpaste> keep_learning annotated “Thread Blocking” with “Thread Blocking (annotation) (annotation)” at http://hpaste.org/74254#a74256
11:40:08 <Cale> fix k = k (fix k)
11:40:30 <johnw> I don't see how that helps you dynamically create a function with n-args at runtime though
11:40:31 <nand`> yeah it seems sane to me, just asking for confirmation
11:40:32 <Cale> keep_learning: huh, oh well :)
11:41:00 <nand`> (I was thinking of an example of a function that could never be ‘fully applied’, ie. takes an infinite number of arguments)
11:41:21 <johnw> oh well, llvm-base failed to install here
11:41:25 <johnw> so I can't play around
11:41:45 <Lutin_> nand`: Guess what I'm running now :D
11:42:27 <Ralith> johnw: note that getParams does exist
11:42:40 <johnw> yes, just not setParams
11:42:44 <Ralith> :P
11:42:49 <nand`> Lutin_: xmonad?
11:43:03 <Lutin_> yep
11:43:05 <Lutin_> And arch
11:43:13 <Ralith> johnw: what's the build error? I had some issues, but I got it to work (though I forget the specifics)
11:43:15 <Lutin_> Only thing I need to nail down is the battery life
11:43:26 <nand`> Not a fan of arch. A fan of xmonad though :)
11:43:35 <Lutin_> I've got laptop-mode and configured it but it's still short :[
11:43:51 <Lutin_> ~2 compared to ~4 on windows
11:44:00 <Cale> nand`: perhaps  y (\u k -> u)
11:44:17 <Ralith> LK4D4: be careful with laptop-mode, it can kill hdds
11:44:22 <Ralith> er
11:44:23 <Ralith> Lutin_:
11:44:41 <astry_> why?
11:44:42 <nand`> Cale: (which is k)
11:45:07 <Lutin_> Ralith: Which part of it?
11:45:08 <johnw> Ralith: something about a function "Print" missing
11:45:15 <Cale> oh, I see what you mean by k now :)
11:45:18 <johnw> likely I need to point it at the right version of llvm
11:45:20 <mornfall> Lutin_: power cycling the hdd can
11:45:21 <astry_> Ralith: how does laptop-mode kill hdds?
11:45:41 <mornfall> There's an upper limit on how many on/off cycles a hdd will live.
11:45:42 <nand`> presumably because it parks the HDD when not in use for ~1 minute
11:45:44 <Ralith> astry_: thrashes the head park operation
11:46:01 <Ralith> johnw: oh, I just fixed that by hand
11:46:04 <nand`> you can work around it by getting a netbook with an SSD :)
11:46:06 <Ralith> iirc
11:46:08 <johnw> Ralith: how?
11:46:10 <nand`> which is quieter too
11:46:18 <johnw> error: ‘class llvm::SMDiagnostic’ has no member named ‘Print’
11:46:18 * timthelion is at that place where one starts using IORefs, just to make the types work.  When writting to IORefs is usefull simply because they return ().
11:46:24 <Ralith> I forget, and I can't find the code >:/
11:46:30 * Ralith fiddle
11:46:30 <Cale> y k 1 2 3 = k (y k) 1 2 3 = y k 2 3 = k (y k) 2 3 = y k 3 = k (y k) 3 = y k -- omnomnom
11:46:39 <Ralith> johnw: iirc it was just a capitalization issue though
11:46:45 <johnw> oh, ok
11:46:50 <johnw> a bug in llvm-base?
11:47:12 <Ralith> johnw: likely LLVM changed there from 3.0 to 3.1
11:47:33 <astry_> Ralith: ok
11:47:35 <astry_> thanks
11:48:05 * hackagebot c2hsc 0.2.0 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.2.0 (JohnWiegley)
11:59:26 <nand`> edwardk: can I use bound to, say, translate each name to a unique natural number?
11:59:45 <Lutin_> gah
11:59:51 <edwardk> nand`: sure
11:59:57 <Lutin_> I don't know how I lasted on windows without a tiling wm
12:00:03 <Lutin_> for even 2 minutes
12:00:32 <edwardk> nand`: an expression using bound has a monad and traversable instance. you can Data.Foldable.toList to get all the free variables even ;)
12:01:22 <nand`> edwardk: can you show me a quick example of what it would look like (I can't figure out bound)? suppose my expression tree is data Expr a = Var a | App (Expr a) a; how would I use this to translate eg. “x y z z x y” to “1 2 3 3 1 2” ?
12:01:35 <edwardk> and if you have things already bound, up you can swap to the barendregt convention by just walking down the tree
12:01:49 <edwardk> App (Expr a) (Expr a)?
12:01:56 <edwardk> or did you really mean the former
12:01:57 <nand`> no, (Expr a) a
12:02:03 <edwardk> what does the monad do?
12:02:16 <nand`> I wasn't aware it was a monad
12:02:19 <edwardk> e.g. how do i substitute into that expression?
12:02:28 <nand`> does it have to be a monad for bound to work?
12:02:38 <edwardk> its a pretty deep seated assumption ;)
12:02:48 <edwardk> that you can do substitution into the syntax tree for variables
12:03:00 <nand`> though note that technically it's just a nonempty snoc list
12:03:00 <majoran> ok, so an Expr is a non-empty list
12:03:02 <edwardk> this rules out, e.g. launchbury semantics, etc.
12:03:04 <nand`> so you could make a monad like that
12:03:07 <johnw> in Haskell FFI, is Bool == CInt?
12:03:20 <edwardk> you could though i honestly don't know what that would mean here ;)
12:03:39 <majoran> johnw: I wasn't aware you could use Bool in foreign declarations
12:04:19 <johnw> yeah, it's not even being mentioned anywhere
12:04:35 <nand`> well, right now I'm doing a (manual) traverse to collect the names and create a Map String Integer  (zip names [0..]), then fmapping over my expression with replace :: String -> Integer
12:04:37 <majoran> so ... don't do that then?
12:04:40 <johnw> I have C macros of the form "... (x == y)"  What should their type be?
12:04:58 <majoran> johnw: none. macros aren't functions
12:04:58 <nand`> hmm
12:05:07 <majoran> also, you can't foreign import macros
12:05:09 <nand`> is there a lens op like that? something like toSetOf traverse
12:05:16 <edwardk> setOf
12:05:16 <johnw> in Bindings-DSL, I use: #cinline FOO , CInt -> ...?
12:05:29 <majoran> johnw: what does this have to do with Bool, though?
12:05:32 <edwardk> setOf folded will work even
12:05:36 <johnw> the result of FOO is effectively a boolean
12:05:48 <majoran> I don't know Bindings-DSL
12:05:53 <majoran> I only know C
12:06:05 <edwardk> i use it a lot in the syntax tree manipulation in Language.Hasekell.TH.Lens and Control.Lens.TH
12:07:02 <majoran> hmm. if you wanted to model C's ==, it would be something like (==) :: (Scalar a) => a -> a -> Int
12:07:32 <johnw> so, CInt then on the Haskell side?
12:07:58 <nand`> SPJ mentions Wadler 1987 for flattening complex pattern matches into multiple case expressions, what publication does this reference exactly?
12:08:02 <majoran> johnw: are you really asking "what type does C's == return?"?
12:08:15 <edwardk> nand`: the chapter in SPJ & Wadler's book
12:08:21 <johnw> I'm asking "what type in Haskell should I assign to the return value from =="?
12:08:29 <johnw> not being able to pass it to an "if" sounds strange
12:08:44 <majoran> johnw: well, what type does == return in C?
12:08:50 <johnw> int :(
12:09:00 <majoran> right, so that's CInt in Haskell
12:09:02 <Botje> @where implementation of functional programming languages
12:09:02 <lambdabot> I know nothing about implementation.
12:09:06 <Botje> boo
12:09:09 <Botje> @where ifpl
12:09:09 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
12:09:13 <johnw> ok, that's what I had, was just trying to be sure
12:09:14 <edwardk> nand`: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/start.htm
12:09:15 <Botje> nand`: ^^ that.
12:09:28 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
12:09:32 <edwardk> oh someone else linked
12:09:32 <majoran> johnw: no one's forcing you to make that the Haskell API, though
12:09:48 <nand`> Botje: edwardk: thanks
12:09:50 <johnw> i know.  I'm also building a type library around this API
12:09:53 <majoran> johnw: you could define a public wrapper function foo x y = realFoo x y /= 0; or something
12:09:54 <johnw> so i can solve it there
12:10:36 <Ralith> johnw: hm, I'm beginning to suspect that these llvm bindings are simply not meant for compiler backends.
12:10:48 <johnw> Ralith: it sounds like it's a user-oriented DSL
12:10:55 <majoran> I wonder if the guts of 0::CInt/1::Cint and False/True are similar enough for unsafeCoerce to work (and by "work" I mean "not crash")
12:10:56 <johnw> Ralith: not a Haskell binding for the IR Builder
12:11:00 <Ralith> yeah
12:11:02 <Lutin_> nand`: What distro are you on
12:11:07 <Ralith> I mean, clearly it binds the IR builder
12:11:12 <nand`> Lutin_: gentoo
12:11:31 <Ralith> but it doesn't attempt to enable everything you can do with it
12:12:14 <johnw> Ralith: which is much less useful, in my opinion
12:12:27 <johnw> I don't want to write pseudo-IR in Haskell, I want to create backends
12:12:31 <Ralith> indeed.
12:13:41 <Enigmagic> it's certainly possible
12:13:54 <Ralith> Enigmagic: there you are!
12:14:06 <Ralith> Enigmagic: so how do I define f n = function taking n args?
12:14:18 <Botje> carefully!
12:14:38 <Enigmagic> Ralith: with Data.TypeLevel.reifyInteger
12:14:51 <Ralith> ..?
12:15:12 <Ralith> what?
12:15:17 <Enigmagic> Ralith: well, easiest way is to let me copy and paste some code up :)
12:15:22 <Ralith> kay
12:16:34 <Enigmagic> oh nevermind, i only use variable sized structures not variable argument functions
12:16:43 <Lutin_> Enigmagic: I don't see anything on Hackage, something like this?
12:16:43 <Enigmagic> lemme look a little more
12:16:47 <Lutin_> http://hpaste.org/raw/7299
12:18:01 <Ralith> anyone know where to find the llvm bindings ghc uses?
12:18:14 <Enigmagic> Ralith: it doesn't use bindings
12:18:19 <Enigmagic> it's just an assembly printer
12:18:40 <Ralith> ew.
12:19:05 <Lutin_> Ralith:"his binding currently works by producing LLVM assembly code in a temporary file. We want to change this to use the LLVM API instead as this should bring faster compile speeds and allow us to extend the API offered by GHC to include LLVM features."
12:19:07 <Enigmagic> it should be possible to make variable argument functions, lessee if i can whip something up real quick
12:19:10 <Lutin_> THat was 2 years ago :[
12:19:18 <johnw> aha
12:19:22 <johnw> Ralith: there you go
12:19:37 <Ralith> well, llvm-base looks like a simple faithful translation of the C API
12:19:43 <Ralith> so that's usable enough at least
12:20:17 <Lutin_> Ralith: not sure if you've seen this http://www.cse.unsw.edu.au/~pls/thesis/davidt-thesis.pdf
12:21:02 <Ralith> Lutin_: not really looking for it, but thanks
12:22:07 <Lutin_> np
12:26:00 <Ferdirand> hello haskellers, what is your favorite way to write "map (const x) l" ?
12:26:10 <Ferdirand> i've found "(>> [x])"
12:26:28 <Ferdirand> but that is somewhat obscure
12:26:48 <majoran> [x|_<-l]
12:26:52 <nand`> mapped .~ x
12:26:53 <Botje> replicate (length l) x
12:27:03 <majoran> Botje: somewhat fail
12:27:11 <nand`> mine's point-free, does that mean I win?
12:27:22 <Ferdirand> Botje: that's not very lazy, is it ?
12:27:22 <Botje> nand`: lies! it has a point right there! :)
12:27:34 <Botje> Ferdirand: you did not state this was a requirement :)
12:27:43 <Ferdirand> indeed
12:27:59 <majoran> Botje: in that case my solution is error "hi"
12:28:15 <nand`> > "foo" <$ [1..10]
12:28:16 <lambdabot>   ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo"]
12:28:35 <Botje> Ferdirand: for small l it matches the intent perfectly, which is far more valuable to me than a bit of performance :)
12:28:57 <majoran> this isn't about performance
12:28:58 <Ferdirand> ooh, i like nand`'s last one much
12:28:59 <nand`> disagree, the intent is to replace every element - not construct a new list of length l
12:29:23 <nand`> note that <$ etc. readily generate to any functor
12:29:26 <nand`> generalize*
12:29:35 <majoran> map (const "foo") (cycle [1,2,3]) works
12:29:43 <majoran> replicate/length does not
12:30:17 <Ferdirand> nand`: yup, that was exactly the operator I was looking for. I don't understand how I couldn't find it on hoogle.
12:30:23 <Ferdirand> thanks much :D
12:30:42 <nand`> http://www.haskell.org/hoogle/?hoogle=a+-%3E+%5Bb%5D+-%3E+%5Ba%5D <- picks it up :)
12:30:52 <Botje> what a gnarly url that is.
12:35:34 <Ralith> bos: any interest in a layer slightly above llvm-base that handles haskell/C value conversion and such but is still a fairly faithful mapping of the C API?
12:36:17 <nobdrais1ntone> How can I compare 2 strings by `((/=) `on`) :: Eq b => (a -> b) -> a -> a -> Bool' on that method 'parse :: String -> IO Document' ?
12:36:20 <nobdrais1ntone> I wanna do something like `((/=) `on` parse)' but obviously there is no instance for (Eq (IO Document))
12:36:27 <nobdrais1ntone> IO Bool result will be ok
12:37:00 <majoran> fmap it in
12:37:12 <majoran> wait, no
12:37:44 <Ferdirand> ap it in
12:37:53 <Botje> nobdrais1ntone: what are Documents here?
12:38:03 <bos> Ralith: sure, patches welcome
12:38:03 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
12:38:24 <Ralith> bos: great! Will do.
12:38:28 <Botje> nobdrais1ntone: liftM2 (/=) (parse a) (parse b) -- is one option
12:38:35 <nobdrais1ntone> Botje: Document from Text.XML (xml-conduit package)
12:38:37 <majoran> :t let parse :: String -> IO Document; parse = undefined in liftA2 (/=) (parse ?x) (parse ?y)
12:38:39 <lambdabot>     Not in scope: type constructor or class `Document'
12:38:45 <majoran> aw
12:38:53 <FireFly> what is .~ in    nand` | mapped .~ x  ?
12:38:57 <majoran> :t let parse :: String -> IO (Tree ()); parse = undefined in liftA2 (/=) (parse ?x) (parse ?y)
12:38:58 <lambdabot> (?y::String, ?x::String) => IO Bool
12:39:07 <nand`> FireFly: (Control.Lens.Setter..~)
12:39:31 <FireFly> nand`: ah, thanks
12:40:35 <nobdrais1ntone> Is there a way to call parse function only once?
12:40:57 <majoran> nobdrais1ntone: ... with two different arguments?
12:41:57 <majoran> :t let parse :: String -> IO (Tree ()); parse = undefined in (liftA2 (/=) `on` parse)
12:41:58 <lambdabot> String -> String -> IO Bool
12:42:07 <EvanR> who read this http://pragprog.com/book/btlang/seven-languages-in-seven-weeks
12:42:25 <Botje> majoran: nice!
12:42:47 <nobdrais1ntone> majoran: exactly, thanks
12:44:25 <Ralith> ahah
12:44:31 <Ralith> johnw: see https://github.com/bos/llvm/pull/37
12:44:40 <bos> Ralith: it's quite an effort to keep the llvm package from bit-rotting
12:44:51 <johnw> thank you!
12:44:58 <bos> Ralith: so if you feel like working on it, probably step 1 would be "make it work with llvm 3.1"
12:45:14 <johnw> but now that I know it's just an assembly generator, I'm not so excited anymore
12:45:14 <Ralith> bos: I believe the above pull req is all that's necessary for that.
12:45:32 <Ralith> johnw: llvm-base is still useful; perhaps you'd like to join me in making a nicer wrapper of it?
12:45:57 <johnw> Ralith: I would indeed, I just worry that my time is too divided.  I'll help where I can though
12:46:02 * Ralith nod
12:46:19 <kanedank> hey, I managed to get my emacs setup following this tutorial http://sritchie.github.com/2011/09/25/haskell-in-emacs.html
12:46:31 <nobdrais1ntone> @hoogle m Bool -> m () -> m ()
12:46:33 <lambdabot> Data.Generics.Aliases ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
12:46:33 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
12:46:33 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
12:46:39 <johnw> i'm always looking to improve my LLVM knowledge, though, so doing that with you might be just the thing I need
12:46:47 <nobdrais1ntone> Is there some whenM or something?
12:46:52 <kanedank> but I'm having a bit of trouble in that when I screw something up and I get a red line to signify an error, it's not obvious for me how to figure out what the error is
12:46:52 <johnw> (I'm currently using LLVM to build a C++ backend for EDG)
12:47:04 <Ralith> well, writing bindings is rarely very educational beyond seeing the breadth of the API
12:47:09 <Ralith> a C++ backend?
12:47:18 <johnw> using LLVM to create a backend for a C++ compiler
12:47:22 <Ralith> ah.
12:47:29 <Ralith> thought you meant a backend emitting C++ :P
12:47:31 <johnw> so I've been deep into BasicBlocks and getting PHInode right and all that :)
12:47:48 <Ralith> I can provide advice there if you haven't sorted it all out
12:48:02 <johnw> thanks!  we've spoken on #llvm, haven't we?
12:48:12 <Ralith> it's possible!
12:48:15 <johnw> :)
12:48:16 * Ralith doesn't recall.
12:48:20 <johnw> i'm always there, as well as here
12:48:24 <Ralith> same
12:48:29 <mm_freak> nobdrais1ntone: not predefined
12:48:39 <mm_freak> nobdrais1ntone: but it's easy enough to define it yourself
12:49:26 <mm_freak> whenM p c = p >>= flip when c
12:50:57 <thoughtpolice> Ralith: GHC's LLVM code generator is braindead; it's actually just a very simple AST with a pretty printer. after you generate C--, the AST is just directly translated, pretty printed, and fed to llc
12:51:16 <thoughtpolice> that said, it wouldn't be hard to rip that code out of GHC. it's fairly standalone and a few other people have done it
12:51:52 <thoughtpolice> Ralith: if you want something more like that and less FFI-y, then you could try this: https://github.com/elliottt/llvm-pretty
12:53:10 * hackagebot hlibgit2 0.3.0 - Low-level bindings to libgit2.  http://hackage.haskell.org/package/hlibgit2-0.3.0 (JohnWiegley)
12:53:13 <Ralith> thoughtpolice: thanks, but I tend to favor using the first party tools when practical
12:54:01 <johnw> just regenerated all the libgit2 bindings with c2hsc.  Found like 12 bugs, but it's close enough to solve 80% of the problem well
12:54:52 <johnw> thoughtpolice: do you mean that -fllvm is still very basic?
12:57:04 <notdan> Is there a shortcut for `if cond then stuff else return ()'?
12:57:17 <johnw> when cond $ stuff
12:57:51 <matthiasgorgens> http://michaelochurch.wordpress.com/2012/04/24/functional-programming-is-a-ghetto/
12:57:52 <notdan> Ah, it's in Control.Monad
12:57:54 <notdan> thanks johnw
12:58:04 <thoughtpolice> johnw: it's "basic" in the sense it's not really a lot of code and doesn't do much in terms of complexity (it's mostly an AST and a pretty printer like I said.) but that's all it needs to be, because a good chunk of the important stuff GHC does happens before then anyway
12:58:05 <matthiasgorgens> (a bit too self-congratulatory, I fear.)
12:59:20 <thoughtpolice> i should have said 'very simple' as opposed to braindead. (there are still some things that LLVM wins at that the NCG doesn't though, and vice versa.)
12:59:43 <johnw> well, and the LLVM optimizer can make up for a lot of smartness
13:00:29 <sipa> > fix ((0:) . scanl (+1)
13:00:31 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:00:46 <thoughtpolice> some things it's not so smart about wrt GHC, but it takes care of a lot of complexity in other ways, sure.
13:02:34 <notdan> Has anyone used gtk2hs? I want to do a simple task: generate a group of radio buttons from a list and then make an even for a regular button, which would show user the name of the currently active button
13:02:36 <thoughtpolice> a lot of those things have been ironed out now IIRC, but there are still things like the stack/heap registers, and alias information that LLVM doesn't know how to properly reason about in GHC-mode (tl;dr it doesn't know that e.g. stack checks can be elided, and it can't see that things like the stack and heap registers never alias, and take advantage of that, etc.)
13:02:38 <notdan> active radio button*
13:02:46 <notdan> So far I've achived the first part
13:02:54 <johnw> edwardk: is "free" still a deprecated package in favor of comonad-transformers?
13:03:01 <Peaker> Ferdirand, about your question above, I love SECs so (map . const) is a very usual combinator
13:03:05 <notdan> but I struggle to see how can work around Gtk's weird radio button design
13:03:16 <notdan> without using mutable state
13:03:58 <kanedank> why does fromList $ Data.Ix.range((0,0),(1,1)) produce fromList[(0,1),(1,1)]?
13:05:32 <timthelion> notdan: Use mutable state. How is mutable state within haskell any worse than a mutably stated GUI framework?
13:06:37 <timthelion> notdan: this is one of the trouble with haskellers. They have no trouble sinnin, so long as the sins can't be seen, and someone else does them.
13:06:57 <timthelion> but when it comes to getting their hands dirty, they freek out.
13:07:03 <Cale> Speak for yourself ;)
13:07:37 <notdan> timthelion: well, the problem is that I don't know much about mutable capabilities of haskell ):
13:07:56 <notdan> Well, the hell with it, I'll use regular buttons instead :)
13:08:07 <Cale> notdan: Usually when you set up your event handlers in Gtk2Hs applications, you'll want to do it all from inside some action where you can distribute shared IORefs to the various event handlers.
13:08:26 <Cale> notdan: Are you familiar with IORef?
13:08:40 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/Data-IORef.html
13:08:44 <timthelion> Cale: I wasn't aware that you where also a GUI coder.  I haven't seen your code, what have you written?
13:09:07 <Cale> timthelion: A long time ago I wrote nymphaea with Paolo Martini
13:09:11 <notdan> Cale: not really, I've seen some example and I can look it up easily
13:09:18 <notdan> but maybe next time
13:09:27 <notdan> I'll just go with buttons and maybe change the GUI latter
13:10:00 <Cale> notdan: Take a quick look at that link I just pasted
13:10:01 <kanedank> how do I create an infinite list of Cell/Nil with this data type declaration?: http://hpaste.org/74260
13:10:05 <Cale> notdan: IORef is really simple
13:11:03 <Cale> notdan: you can just put  r <- newIORef <initial value>  above your event handlers, and then  v <- readIORef r  will get the value of the IORef inside one of your event handlers, and  writeIORef r <new value>  will write it.
13:11:20 <timthelion> Cale: interesting.  I'll read the code.  I'm really interested in all of the *actual* GUI that has been created in Haskell, as there seems to be a big shortage!
13:13:36 <notdan> Cale: alright, you've convinced me, it is really easy :]
13:14:40 <Cale> notdan: This is assuming you set them all up inside of one big do-block, but that's basically what I recommend doing for gtk2hs.
13:14:56 <timthelion> notdan: it really is easy.  The rule that I use, is to never use mutable state within one (non-eventful)thread, but when I need to comunicate between threads, or events, then I use it.
13:15:21 <Cale> Of course, we sadly can't use threads with any of the existing GUI libraries
13:15:42 <timthelion> Cale: Actually gtk2hs has good support for threads.  Just entirely undocumented.
13:15:48 <Cale> Despite the fact that concurrency is a natural thing to want with GUI code, all of the GUI libraries written in C sabotage this.
13:16:04 <Cale> (or make it hard to do)
13:16:24 <timthelion> Cale: Not really.  So long as you postGUISync or postGUIAsync its easy with gtk2hs
13:17:10 <timthelion> The problem, is there is no good docs on how to do it right, and a surprising amount of completely misleading information about the subject.
13:17:51 * timthelion should probably throw together a one page manual on threaded gtk2hs
13:18:04 <notdan> well i just use forkIO for button events D8
13:18:08 <notdan> and it seem to kinda work
13:18:46 <timthelion> notdan: watch out!  If you do any GTK actions, you must wrap them in the functions postGUIAsync or postGUISync, otherwise your program may crash!
13:19:23 <notdan> oh, you mean that
13:19:36 <notdan> nah, I do a bunch of other stuff like console i/o and computing
13:19:40 <notdan> (in a different thread)
13:19:45 <timthelion> notdan: ok, that's fine.
13:19:54 <notdan> my interface is really simple, I am making an egg/tea timer actually
13:20:04 <timthelion> notdan: cool :)
13:20:28 <notdan> I know that I can do that with 2 lines of bash + notify-send, but I thought that this might be a good practice opportunity
13:21:25 <timthelion> notdan: yep :)
13:22:04 <datura> notdan: i had a shellscript using osd_cat for that. with a big, red "tea is ready" all over the screen so there way no way to miss it :)
13:23:25 <nand`> -XRecordWildCards works surprisingly well for Text.Parsec.Token
13:23:43 <notdan> datura: that is true, but different kinds of tea require different brewing time
13:23:51 <notdan> Ah, sorry, this is actually getting offtopic :)
13:24:09 <datura> notdan: are there libxosd bindings for haskell, maybe?
13:25:01 <notdan> Hm, I am using libnotify
13:25:22 <notdan> Frankly, that's the only reason I am using GTK, since libnotify does already depend on it
13:28:26 <byorgey> there are xosd bindings, but quite old and no longer supported it seems
13:28:40 <byorgey> there is also http://hackage.haskell.org/package/aosd
13:31:28 <kanedank> what does this error mean?: http://hpaste.org/74264
13:33:11 * hackagebot seqloc-datafiles 0.2.2.2 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.2.2.2 (NicholasIngolia)
13:34:26 <byorgey> kanedank: since createMap does not have an IO type, you should use   let m = createMap 9 9;   instead of  m <- createMap 9 9
13:34:58 <byorgey> <- desugars into a call to (>>=), the monadic bind operator, so the thing on the RHS of the <- must have a monadic type
13:35:08 <byorgey> <- is not assignment
13:35:17 <startling> it desugars into >>= and a lambda, right?
13:35:32 <byorgey> well, yes
13:35:52 <startling> That was unclear to me when I learned haskell, so I thought i'd mention it
13:35:57 <byorgey> I should have been more precise, yes
13:36:16 <byorgey> specifically,  x <- m   desugars into    m >>= \x -> ...
13:36:24 <lpvb> yes..
13:36:27 <byorgey> where the ... is the desugaring of the rest of the do-block
13:37:27 <Ralith> Is there any way to get a file descriptor out of a handle?
13:37:31 <Ralith> a Handle, that is
13:39:03 <Enigmagic> @hoogle Handle -> IO Fd
13:39:04 <lambdabot> System.Posix.IO handleToFd :: Handle -> IO Fd
13:39:04 <lambdabot> Network.BufferType buf_hGetContents :: BufferOp a -> Handle -> IO a
13:39:04 <lambdabot> Network.BufferType buf_hGetLine :: BufferOp a -> Handle -> IO a
13:39:13 <Ralith> oh, right, hoogle
13:39:36 <Enigmagic> Ralith: i'll look at that llvm thing in a sec but it's not going to be pretty
13:39:45 <matthiasgorgens> I wonder whether it is possible to built something remotely as useful as hoogle for, say, python.
13:39:54 <Ralith> Enigmagic: yeah, I think it's clear that the llvm binding isn't really appropriate for compiler backends.
13:40:02 <matthiasgorgens> or even Java (which has more static typing than python).
13:40:08 <startling> matthiasgorgens, what would you search by with python?
13:40:26 <matthiasgorgens> startling: you'd have to formalize the effects of a function somehow.
13:40:32 <startling> matthiasgorgens: yeah ...
13:40:34 <kanedank> byorgey: thanks!
13:41:08 <matthiasgorgens> startling: searching by guessing names doesn't work tooo badly for python documentation.
13:41:12 <matthiasgorgens> but it's not hoogle.
13:41:17 <startling> indeed
13:41:25 <kanedank> also, right now I got my code to sort of work... but how do I make it so that instaed of just creating a hashmap with the value of 2 for everything create a Nil::Cell or Node::Cell?
13:41:31 <startling> on the other hand, python folks tend to write tutorials and nice docs...
13:41:51 <matthiasgorgens> their culture of using methods (that have implicit state because of the object they are attached to) makes the parameters less meaningful than in haskell.
13:41:54 <matthiasgorgens> and return values.
13:42:17 <startling> matthiasgorgens: sure. that's inherent in OO, isn't it?
13:46:06 <matthiasgorgens> hmm.  is that a philosophical trick question?
13:48:38 <Z`> I'd like to have a state monad like:  tick = do { n <- get; put (n+1); return n; } and then do execState tick 1 and return '1,2,3,4...'
13:48:47 <Z`> instead of execState tick 1 returning 2 always
13:49:06 <mizu_no_oto> startling:  Not quite inherent in OO itself.  Scala is 100% OO (it bolts some functional sugar on top), and has a hoogle like search engine.
13:49:35 <Jeanne-Kamikaze> wouldn't that imply that your state is escaping the state monad ?
13:49:48 <MostAwesomeDude> What she said.
13:49:57 <Jeanne-Kamikaze> she ?
13:50:21 <Z`> What construct should I use to achieve the above behaviour ?
13:50:44 <MostAwesomeDude> Jeanne-Kamikaze: Sorry, guessed from your nick. :c
13:50:46 <Jeanne-Kamikaze> don't ask me, but I think you simply can't
13:50:58 <Jeanne-Kamikaze> MostAwesomeDude: yeah, I admit it's quite female, in fact it's an old ani,me
13:51:00 <Jeanne-Kamikaze> *anime
13:51:01 <MostAwesomeDude> Z`: Why do you want this?
13:51:15 <MostAwesomeDude> Jeanne-Kamikaze: Ah. I'm not very knowledgeable about anime, so that would explain things.
13:51:33 <Jeanne-Kamikaze> I'm not a fan of it either, I've been carrying this nick for like 9 years
13:51:33 <Z`> Just playing around. It seems that the state monad can hold only the initial state that I supply it ?
13:51:46 <Jeanne-Kamikaze> it can hold state within the monad itself
13:52:03 <Z`> Can't it update the state of itself based on the result of the computation ?
13:52:09 <MostAwesomeDude> Z`: Right. The State monad carries a state through a sequence of computations; it doesn't create some kind of global state.
13:53:14 <MostAwesomeDude> Z`: Imagine that the definition of State is: newtype State s a = { runState :: s -> (a, s) }
13:53:26 <MostAwesomeDude> You can't get something out of it that you didn't put in.
13:53:46 <startling> mizu_no_oto: isn't the heart of OO "using methods (that have implicit state because of the object they are attached to)"?
13:53:53 <Z`> so, everytime I write:  runState mySM initlVal, initVal will override 'a' ?
13:54:07 <Z`> er s*
13:54:20 <startling> matthiasgorgens, anyway, I think you could maybe do it with interfaces in python
13:54:25 <MostAwesomeDude> Don't think of it as overriding. It's providing that initial argument.
13:54:41 <MostAwesomeDude> And since this is pure code, if you have the same input every time, you're gonna get the same output.
13:56:06 <edwardk> @remember sclv I think we should start adding "this is popular among hydrologists" to random documentation on hackage
13:56:06 <lambdabot> Done.
13:56:07 <mizu_no_oto> startling:  that's true
13:56:18 <Z`> So, how could I achieve this:  1. have a structure that maintains a state (say an integer counter) 2. assign an initial value of zero to it 3. every time I apply some function to it, the counter is increased by 1 ?
13:56:42 <MostAwesomeDude> Z`: You will have to (4) carry that structure around with you.
13:56:55 <Z`> a ha.
13:57:00 <MostAwesomeDude> Or, rather, carry the latest version of that structure around with you.
13:57:18 <Z`> alright, this is a new perspective. I will explore it. Thanks MostAwesomeDude :)
13:57:19 <mm_freak> Z`: this sounds like you're trying to write C++ in haskell…  try to explain your application without using haskell/programming terms
13:57:53 <Z`> I'm not writing any application. I'm just writing random stuff and today I mess with the state monad
13:58:02 <startling> Or you can put that state in a state itself. :)
13:58:21 <Z`> mind blowing
13:58:25 <mm_freak> Z`: you should write real programs, because right now you're exploring how haskell can behave like your prior language =)
13:59:08 <Z`> I can't write a real application in haskell, unless I advance a bit in it
14:00:06 <matthiasgorgens> Z`: you could try to apply an argument to a function. :o)
14:00:23 <dufflebunk> I have a haskell program which output "<<loop>>". I'm almost certain it's because I'm doing something bad with the IO monad. Is there a GHC flag I can run it with to get a better idea of what's going wrong?
14:00:40 <matthiasgorgens> dufflebunk: shouldn't have much to do with IO itself.
14:00:40 <mm_freak> Z`: get started with syntax and semantics by solving some Project Euler problems…  while not helpful to write real software they get you trained in syntax, semantics, haskell algorithm design and data structures
14:00:59 <matthiasgorgens> dufflebunk: perhaps you have a definition like
14:00:59 <matthiasgorgens> x = x
14:01:00 <matthiasgorgens> somewhere?
14:01:05 <mm_freak> dufflebunk: that's not related to IO…  you have some infinite recursion somewhere
14:01:31 <dufflebunk> matthiasgorgens, No, nothing like that
14:01:34 <matthiasgorgens> mm_freak: project euler is useful for language learning, only if you are already comfortable with dynamic programming.
14:01:57 <Z`> For example, If I write a pseudo number generator, I'd like to provide it a seed only once, and from there on write 'nextRand' and have it return me the next number.
14:02:06 <matthiasgorgens> dufflebunk: what mm_freak said. :o)  (It's the same thing as I said, only more general.  your problem might not be immediately obvious.)
14:02:09 <mm_freak> matthiasgorgens: i don't even know what that is, yet they were useful enough that i recommend solving the first 10-15 problems to everyone
14:02:21 <matthiasgorgens> Z`: look at the random monad.
14:02:34 <startling> Z`: sure. that's a good use for State
14:02:35 <mm_freak> no, please don't look at "the random monad"
14:02:42 <matthiasgorgens> mm_freak: why not?
14:02:49 <startling> mm_freak: any random monad !
14:02:52 <mm_freak> first see how a pure random number generator works
14:03:00 <mm_freak> without statefulness
14:03:19 <MostAwesomeDude> mm_freak: Is there a problem with using Control.Monad.Random once one understands how it all works?
14:03:21 <matthiasgorgens> mm_freak: if he looks at the implementation of the random monad, he'll see how the pure stuff works.
14:03:35 <identity> If one understands how PRNGs work(as in, seed -> etc), then those are a good way to understand the State monad
14:03:38 <Z`> my problem is that if I write:   nextRand = runState rndGen (random (mkStdGen 0))  then the zero seed will always be assigned to my state monad
14:03:43 <Z`> and the result will be the same
14:03:55 <d-snp> hey, is there a neat way to run an attoparsec parser from within an attoparsec parser?
14:04:15 <mm_freak> MostAwesomeDude: no, but the premise doesn't even hold…  again, my impression is that Z` is still writing C++ in haskell
14:04:21 <startling> d-snp: why do you want to?
14:04:30 <mm_freak> please stop suggesting random monads
14:04:32 <d-snp> so I parsed a length field, then use AP.take to consume that amount of bytes in a bytestring, and then run a parser on that bytestring
14:04:38 <Z`> sketch code:  http://paste.lisp.org/display/131517
14:04:41 <d-snp> does that seem logical to you?
14:05:01 <mm_freak> d-snp: not really
14:05:04 <MostAwesomeDude> mm_freak: Well, right now, in another tab, I'm writing code using it and I want to know if I should be using something else because there's some horrible bug or breakage.
14:05:07 <Jeanne-Kamikaze> Z`: you have to save the new state for later, or do your stuff inside the monad, or use the IO random, but then you're trapped in IO
14:05:13 <mm_freak> d-snp: you could just as well integrate the parser into the main parser
14:05:17 <identity> d-snp: parser = { lengthField <- lengthFieldParser; rest <- parseRestOfString; }
14:05:31 <identity> if you "parse the length field" that part is already consumed
14:05:38 <mizu_no_oto> Z': That's what newStdGen is for - getting an initial seed based off of the current time
14:05:42 <identity> oh, forgot a "do" there
14:05:43 <mm_freak> MostAwesomeDude: i see what you're asking…  my way of passing random numbers around looks like this:
14:05:55 <d-snp> identity: yes, but how do I make sure that parseRestOfString doesn't consume more than lengthField bytes?
14:06:07 <mm_freak> myFunc :: (Monad m) => (forall a. (Random a) => (a, a) -> m a) -> m X
14:06:13 <startling> Jeanne-Kamikaze: http://acm.wustl.edu/functional/io-monad.jpg
14:06:16 <mm_freak> no PRNG monad at all
14:06:32 <Jeanne-Kamikaze> yeah saw that one :)
14:06:57 <mm_freak> the advantage is that the user of that function can choose the monad, while with a PRNG monad you have to write ugly monad transformer code most of the time
14:07:05 <dufflebunk> matthiasgorgens, is there any way to get some kind of output about what the loop involves?
14:07:08 <d-snp> mm_freak: how would you integrate it then? it seemed appealing to use take because it really enforces a byte amount
14:07:10 <Z`> When I write 'put ...' don't I save the new state for later ?
14:07:13 <identity> d-snp: Ah, I see. I'm not entirely sure there. I haven't used attoparsec too much.
14:07:37 <mm_freak> d-snp: i recall that there is a combinator for that, but i forgot its name…  something with isolation
14:07:53 <mm_freak> Z`: 'put' does not "save"
14:08:01 <d-snp> identity: yeah in a message based protocol your suggestion would make sense, but I get a stream where length delimits the messages
14:08:12 <Z`> It updates the state with a new one
14:08:15 <d-snp> mm_freak: alright I'll search for that
14:08:18 <Jeanne-Kamikaze> Z`: would you know how to implement state yourself ?
14:08:35 <mm_freak> Z`: you should implement State yourself
14:08:39 <Z`> Jeanne-Kamikaze: with a bit of effort yes
14:09:00 <mm_freak> then you will see how state monads are about the least useful monads
14:09:22 <startling> Z`: State just wraps an a -> (b, a) function
14:09:35 <startling> Z`: so, in your case it'd be oldSeed -> (value, newSeed)
14:09:46 <d-snp> mm_freak: would that combinator be in some other package than AP.Combinator?
14:09:53 <mm_freak> startling: it would be seed -> (value, seed)
14:10:00 <identity> d-snp: I'm sure there is some smart way to do this, that won't require you to *parse length field* *parse (take lengthFieldValue . drop lengthOfLengthField $ string)
14:10:14 <mm_freak> d-snp: no idea, sorry
14:10:21 <d-snp> k np thanks anyway :)
14:10:38 <hpaste> timthelion pasted “Threaded GTK” at http://hpaste.org/74267
14:10:38 <mm_freak> d-snp: in any case, nesting parsers is usually a bad idea
14:11:07 <timthelion> Cale: notdan : see my paste
14:11:08 <startling> mm_freak: If we're going to use a made-up syntax for illustrating functions, does it have to be a specific made-up syntax? :)
14:11:24 <timthelion> So where should I upload that where people will see it?  The wiki?
14:11:40 <mm_freak> startling: you should keep value level separate from type level, otherwise the confusion will increase
14:12:12 <startling> mm_freak: s'true. I was trying to illustrate value-level. I probably shouldn't have used ->
14:12:31 * timthelion will put it on the wiki
14:12:39 <Jeanne-Kamikaze> Z`: think of the state as an implicit argument you're passing between the functions; put just replaces that implicit argument with a value of your choosing
14:12:39 <mm_freak> probably you should have used words instead of symbols =)
14:12:40 <nobdrais1ntone> Is there a way to define that all that 3 xmls are equal? http://hpaste.org/74268
14:12:52 <startling> mm_freak: fair enough
14:13:25 <d-snp> mm_freak: you were thinking of cereal's isolate function, AP.Binary doesn't have it
14:13:28 <mm_freak> nobdrais1ntone: through a schema
14:13:31 <d-snp> but it's exactly what I need I think
14:13:33 <Botje> nobdrais1ntone: if the DTD/XSchema allows it, sort the tags by tag name.
14:13:36 <Botje> or that.
14:13:46 <mm_freak> nobdrais1ntone: Relax NG can do that…  DTD can't
14:13:53 <mm_freak> and i don't know XSchema
14:14:15 <johnw> is there a way to encode --haddock-hoogle into ~/.cabal/config, so that it happens for all packages?
14:15:09 <Jeanne-Kamikaze> Z`: the state isn't saved anywhere; you just pass an initial state to a monadic action, it does stuff with it and returns a new state; the state is not saved anywhere, it's just passed around implicitly _within_ the state monad, but at the end of the day running your state action is just like a regular function call: you give it something and it returns something else in return
14:15:42 <Z`> Jeanne-Kamikaze: I think they keyword here that I missed is that the state is passed inside the context of the state monad itself
14:15:49 <Jeanne-Kamikaze> yes
14:16:15 <Z`> thanks for caring enough to explain it
14:16:25 <identity> Z`: That's how #haskell rolls, bro.
14:16:40 <Z`> thank you all :) I'll go back to read more
14:17:02 <Jeanne-Kamikaze> are you reading LYAH ?
14:18:36 <Lutin`> Yessssss
14:18:47 <Lutin`> Finally now I have ~5 hours of battery life on Arch Linux
14:18:56 <Lutin`> There is no reason to return to M$!
14:18:59 <mm_freak> Z`: you have functions of type S -> (a, S) for various types 'a'…  the monad State S just lets you compose those functionsd
14:19:04 <mm_freak> you could have worked with those functions directly instead
14:19:20 <Z`> Jeanne-Kamikaze: I ordered it but hasn't arrived it yet. In the meantime I'm reading a gentle intro to haskell + the wiki etc
14:19:34 <mm_freak> you can read LYAH online
14:19:38 <Lutin`> 4 phree
14:19:48 <mm_freak> @where LYAH
14:19:48 <lambdabot> http://www.learnyouahaskell.com/
14:19:54 <Z`> hey neat
14:20:26 <mm_freak> don't cancel the order though =)
14:20:30 <Ralith> bos: what's the rationale between which FFI funcs are and are not IO?
14:20:41 <Lutin`> Except the server seems to be nonresponsive atm, mm_freak
14:20:56 <zachk> > "Also you can use lambabot Z`, even via /msg lamdabot > expressionHere"
14:20:56 <edwardk> Ralith: if the answer can change, or is system dependent it should be in IO
14:20:57 <lambdabot>   "Also you can use lambabot Z`, even via /msg lamdabot > expressionHere"
14:21:02 <armlesshobo> same with realworld Haskell
14:21:05 <Heffalump> System.IO allows you to use a TextEncoding to decode/encode character data as it's being read from/written to a file handle. Is there any easy way to do this directly, e.g. [Char] -> [Word8] and vice-versa?
14:21:15 <Ralith> edwardk: right, he's put a bunch of stuff in IO that is neither of those.
14:21:23 <edwardk> Ralith: in what?
14:21:26 <Ralith> I think.
14:21:28 <Ralith> llvm-base
14:21:31 <Z`> thanks zachk
14:21:38 <Ralith> hm, maybe not
14:21:43 <sHACHAF> Heffalump: Well, There are Text -> ByteString and ByteString -> Text in "text".
14:21:46 <edwardk> oh, you still have the problem that llvm internally uses mutable objects, etc.
14:21:54 <zachk> if you are looking for an older, more scholastic and elementary introduction to haskell, check out "Programming in Haskell" by Graham Hutton, it removed most of my "newbish" questions in about a week
14:22:10 <bos> Ralith: at least in principle it's guided by whether said functions are pure
14:22:20 <Z`> Ah I think I've came across it @ amazon. Alright, will order it.
14:22:41 <bos> Ralith: that said, augustss hacked on the package like crazy without much oversight, so there may be mistakes in there that i didn't catch and he didn't notice
14:22:46 <Lutin`> Z`: Order all the haskell books! haha
14:22:55 <Z`> All your haskell books are belong to me
14:22:56 <Ralith> bos: are LLVM types mutable?
14:22:58 <Heffalump> sHACHAF: those are specialised to a fairly limited set of encodings
14:23:00 <bos> Heffalump: i don't know of anything that decouples the two
14:23:18 <bos> Heffalump: closest i can think of is text-icu
14:23:37 <edwardk> Consider a ModuleRef, you can setDataLayout, disposeModule, setTarget, etc.
14:23:40 <bos> Ralith: types? depends.
14:23:42 <Heffalump> I need something in the Platform, ideally - need to make the HTTP package actually respect encodings :-(
14:24:00 <sHACHAF> Heffalump: There are some functions in GHC.IO.Encoding but they look kind of low-level.
14:24:11 <Heffalump> sHACHAF: yeah, I saw those
14:24:16 <bos> Heffalump: oh, i think you can forget about that, but the HTTP library is kind of hopeless anyway
14:24:27 <mm_freak> Heffalump: the text library is probably your best bet…  pick a sensible internal encoding and recode everything into it
14:24:29 <Ralith> bos: e.g. can the return type of a function be modified?
14:24:30 * sHACHAF wonders whether you can hSetEncoding a Handle midstream.
14:24:37 <Heffalump> as you say they're low-level, and they're in GHC
14:24:45 <zachk> Z`: there is also "The Craft of Functional Programming" by Paul Hudak, I have not read, and it is supposedly a bit data but it used to be quite popular
14:24:52 <bos> Ralith: it depends
14:25:01 <Ralith> on what?
14:25:18 <bos> Ralith: llvm is huge, there are all kinds of functions that have all kinds of different behaviours. there is not a generic answer to this question.
14:25:38 <sHACHAF> Hmm, GHC/IO/Encoding/UTF8 has yet another UTF-8 decoder.
14:25:44 <zachk> Ralith: you could extend the return type easily with a newtype or data statement to include the original type , and then parse out the mess with left hand side pattern matching in function definitions
14:25:46 <Heffalump> bos: calling it hopeless isn't very constructive :-) We either need to make it less hopeless, or replace it.
14:25:46 <sHACHAF> There are way too many UTF-8 decoders written in Haskell.
14:26:10 <Botje> maybe we need an UTF8-decoder rewrite rule.
14:26:12 <Heffalump> I don't want a UTF-8 decoder, I want to be able to look at the content-type a webserver sends and decode whatever that is
14:26:27 <sHACHAF> Yes.
14:26:32 <Ralith> bos: so basically, you're playing it safe with the accessor types?
14:26:40 <Ralith> zachk: we're discussing LLVM.
14:26:45 <bos> Heffalump: there is definitely nothing in the platform that will help you.
14:26:52 <zachk> oh ok, sorry :-|
14:27:00 <Ralith> hehe
14:27:26 <Heffalump> my current best plan is either to do something hacky with Handle (particularly if I can make an inmemory one..) or use the GHC.* internals
14:28:08 <Heffalump> bos: ok, thanks. I guess in theory that's a gap that would be worth filling, so I guess I could also investigate doing that.
14:28:22 <mm_freak> Heffalump: another way is to interface to iconv
14:28:37 <Heffalump> mm_freak: that violates the "in the Platform" requirement
14:28:50 <mm_freak> i think there is no way that doesn't =)
14:29:05 <Heffalump> well, I guess I could add stuff myself, but then I'm in a world of OS-dependent hell
14:29:20 <Lutin`> Heffalump: You've probably seen this but
14:29:22 <Lutin`> http://www.haskell.org/haskellwiki/Library/Data_encoding
14:29:45 <bos> Heffalump: i think you're guaranteed a world of hurt.
14:30:08 <bos> Heffalump: the only library that is portable is ICU, which is why text-icu depends on it.
14:30:15 <Heffalump> Lutin`: I was aware of that in another context, but my problem is to do with charset encoding like iso8859-1/utf-8/etc
14:30:27 <Heffalump> bos: I think being able to do whatever GHC can do would be good enough as a starting point
14:30:36 <dufflebunk> mm_freak, in a monad instance would having the following cause the <<loop>? return a = Foo $ return a
14:31:10 <Lutin`> Heffalump: What about http://www.haskell.org/haskellwiki/Library/Streams
14:31:17 <Heffalump> presumably at some point text-icu might end up in the Platform and become a good core library for everything else to use
14:31:28 <parcs`> dufflebunk: depends on the type of Foo
14:32:04 <mm_freak> dufflebunk: how is Foo defined?
14:32:29 <dufflebunk> Monad m => Foo m a
14:32:34 <Heffalump> Lutin`: interesting (though no doubt very much "not in the Platform" :-)
14:32:40 <dufflebunk> data Monad m => Foo m a = ...
14:32:41 <Lutin`> Yes
14:33:04 <Heffalump> and looks like it hasn't seen any development since hackage came out (or that wiki page hasn't been updated)!
14:33:26 <dufflebunk> so the return function is correct, it must be somethign else.
14:34:02 <Lutin`> Just when you first asked the question the first thing I thought of was streams so when I found that I sent it your way
14:34:29 <Heffalump> yeah, in terms of simulating a Handle it looks ideal
14:34:48 <dufflebunk> Bah, I defined >>= in terms of >>. That would be a problem, since the default implmentation of >> uses >>= and return.
14:35:54 <Lutin`> Heffalump: What about conduits?
14:36:46 <Lutin`> http://hackage.haskell.org/package/conduit
14:42:15 <dufflebunk> Hah! Found it. A goofy liftIO.
14:44:45 <johnw> it's hard to imagine what Haskell would be like without Applicative
14:45:19 <timthelion> johnw: still great.  No clue what Applicative is and Haskell is still wonderful.
14:45:34 <johnw> Applicative is <$> and <*> and *>, etc.
14:45:40 <timthelion> oh,
14:45:45 <Lutin`> Did this channel die for 5 minutes or did I lose messages :[
14:45:49 <johnw> it makes it easy to work with functions while having context managed behind the scenes
14:46:01 <johnw> Lutin it was very quiet
14:46:02 <timthelion> Lutin`: die?
14:46:14 <Lutin`> Like it was silent
14:46:20 <johnw> yeah, it happens
14:46:24 <timthelion> johnw: I thought <$> was just fmap
14:46:33 <Heffalump> Lutin`: looks like it's just based on the restricted set of encoding functions in text
14:46:40 <johnw> <$> is just fmap, but <*> isn't, and they go together nicely
14:46:56 <Lutin`> Heffalump: Damn, you can't do your own Codecs?
14:47:04 <johnw> when I find myself using "<-" too much in monads, I start remembering applicatives
14:47:13 <johnw> or when I want to apply functions to sets of Maybe values, etc.
14:47:17 <timthelion> johnw: Whenever I hear fmap, I think http://www.youtube.com/watch?feature=player_embedded&v=pShf2VuAu_Q
14:49:05 <Lutin`> wow
14:49:10 <Lutin`> How does it make you think of that
14:49:29 <johnw> yeah...
14:49:38 <johnw> i can see that being the result of fmap.. :)
14:50:21 <timthelion> Lutin`: becuase if you think of a Functor as being a pair of pants...
14:50:25 <johnw> why can I not get hoogle server --local to work?
14:50:29 <Lutin`> No I don't
14:50:29 <johnw> it insists on using haskell.org
14:50:49 <Heffalump> Lutin`: you can, but you'd have to implement them
14:50:59 <Heffalump> actually, it's abstract, so perhaps not even that
14:51:35 <Lutin`> did you look here
14:51:35 <Lutin`> http://hackage.haskell.org/packages/archive/conduit/0.5.2.3/doc/html/src/Data-Conduit-Text.html
14:51:55 <hpc> johnw: what exactly is your end goal?
14:52:00 <Heffalump> yes
14:52:08 <johnw> I can query for, say, "head"
14:52:14 <johnw> when I click on it, I want it to browse my local Haddock documentation
14:52:16 <Lutin`> I guess I just don't know what you're looking for
14:52:19 <johnw> and not go to haskell.org
14:52:56 <johnw> the whole aim of running a local Hoogle is to (a) use it offline, and (b) use it when haskell.org is down
14:53:11 <johnw> otherwise, what do I care that only the initial query results are local?
14:53:23 <Heffalump> for example, encode :: String -> String -> ByteString where encode "utf-8" (unicode string) = (utf-8 encoded string)
14:54:09 <hpc> johnw: use "hoogle data -l"
14:54:13 <johnw> did that
14:54:16 <johnw> in fact, I did hoogle data -r -l all
14:54:24 <johnw> and I built my packages with cabal install --haddock-hoogle
14:54:24 <Peaker> I wish OverloadedStrings, DeriveFunctor, ScopedTypeVariables (without need for "forall") all went into the standard
14:54:27 <johnw> I can see lens.txt there
14:54:38 <johnw> it's the same as the lens.txt that hoogle data all downloads
14:54:42 <hpc> no idea, then
14:54:46 <johnw> and I have all the lens HTML docs
14:54:48 <hpc> your setup is more complex than mine
14:54:52 <johnw> but hoogle server refuses to use it
14:54:53 <edwardk> lens.txt?
14:55:09 <johnw> edwardk: the Hoogle text database that gets generated from your Haddock documentation
14:55:26 <hpc> Peaker: probably not overloaded strings, but definitely the other two would be awesome
14:55:27 <edwardk> ah
14:55:30 <xp_prg> does haskell have built in backward chaining?
14:55:35 <hpc> and they are definitely harmless
14:55:43 <edwardk> i have yet to see what hoogle does to lens ;)
14:55:51 <squidz> is there a collection of haskell patterns/anti-patterns somewhere
14:55:52 <nand`> what's backward chaining?
14:55:57 <Peaker> the amount of annoyances due to Applicative not being a constraint for Monad is huge too :(
14:56:10 <xp_prg> in a decision tree you can go back to previous choice points
14:56:54 <squidz> i would like to read into what design principles are tested, so i would like to read them somewhere
14:56:55 <hpc> xp_prg: are you asking about type inference, or backward chaining as a computation?
14:57:04 <hpc> (a la prolog)
14:57:09 <xp_prg> backward chaining just like prolog yes
14:57:52 <hpc> in that case, haskell isn't a logic language, and doesn't have backward chaining
14:58:14 <hpc> (as a language feature; i am sure it exists on hackage as a library)
14:58:30 <xp_prg> stupid question, are there any other logic programming languages with backward chaining?!! :(
14:58:53 <johnw> oh, hey, some of the query hits ARE local
14:59:04 <johnw> so now I have to figure out how it determines which are local and which aren't
14:59:12 <nand`> I'm not sure if it has backward chaining, but Mercury is a logic language inspired by prolog afaik; so maybe that has it
14:59:18 <monochrom> try mercury for a logic language
14:59:54 <hpc> xp_prg: you might have better luck in #prolog (or ##prolog, silly naming conventions)
15:00:10 <monochrom> haskell is not a logic language, a theorem prover, a computer algebra system, or a kitchen sink. this surprises many people, and I don't know why.
15:00:35 <nand`> ?faq Can Haskell be a kitchen sink?
15:00:35 <lambdabot> The answer is: Yes! Haskell can do that.
15:00:45 <zachk> because it almost tricks you into thinking it is :D
15:00:55 <hpc> monochrom: probably because coming from other languages, libraries look like syntax
15:01:03 <dufflebunk> monochrom, hmmm, maybe that's why my dishes from last night are still dirty.
15:01:19 <zachk> maybe is because coq isn't a dishwasher?
15:01:19 <monochrom> for example people expect "filter (== 1) (repeat 0)" = []
15:01:56 <zachk> _|_ right?
15:01:59 <monochrom> yes
15:02:22 <zachk> is that also the same as undefined in GHC....wait my logic brain says noo....
15:02:30 <monochrom> yes
15:02:38 <hpc> undefined is /one of many/ bottoms
15:03:03 <zachk> a plethora of bottoms....where is my top hat and sword of chivalrous might?
15:03:06 <timthelion> monochrom: but we can still make EDSL's for all of those :)
15:03:44 <timthelion> > unsafePreformWashTheDishes
15:03:45 <lambdabot>   Not in scope: `unsafePreformWashTheDishes'
15:03:59 <hpc> unsafePerformSwanLake
15:04:07 <hpc> (spoiler alert)
15:05:24 <timthelion> > let unsafeShoot x = undefined in unsafeShoot theTerrorist -- Hmm, I wonder if we can pun out lambdabot
15:05:25 <lambdabot>   Not in scope: `theTerrorist'
15:05:29 <timthelion> :D
15:05:52 * timthelion has the humor of a 5 year old.
15:05:53 <monochrom> haha
15:06:22 <mm_freak> lambdabot, the lambda sniper
15:06:29 <typoclass> johnw: not sure if this has anything to do with anything, but when i do "hoogle --dump|grep http", it shows a lot of packages with a lot of links to hackage.haskell.org. just fwiw.
15:06:55 <johnw> well, I've now found that many of my .txt files in hoogle/databases have @url file://...
15:06:57 <johnw> all pointing to the right place
15:07:18 <johnw> so I don't understand why, for example, my local hoogle can't find functions in the lens package, or why it wants to browse the lens package remotely
15:07:55 <edwardk> does it not like higher rank types or something?
15:08:15 <johnw> I can search for "lens", but not "iterated"
15:08:18 <johnw> something very odd is going on
15:08:33 <johnw> my default.hoo is really old too
15:09:18 <typoclass> johnw: not sure what those .txt files are you're mentioning :-) for me, a file ~/.cabal/.../default.hoo is involved. could you "strace hoogle map" and verify that it open()s those .txt files?
15:09:33 <johnw> a .txt is the precursor to a .hoo
15:09:42 <johnw> you use "hoogle convert foo.txt -> foo.hoo"
15:10:00 <johnw> hold on, I'm recreating default.hoo now
15:10:10 <johnw> I thought hoogle data all would do that
15:10:16 <gdeest_> Hi, does someone know of a nice, example-based presentation of Type Literals / Type Nats ?
15:10:35 <gdeest_> I'm trying to figure out what can and cannot be done with them...
15:10:35 <typoclass> johnw: i see. (i usually use the online thing, because it's just so complicated to set up locally, and i bet a few months down the line it'll break and i'll have to start over)
15:11:05 <johnw> setting it up locally hasn't been all that hard, actually
15:11:32 <johnw> it's most a matter of enabling documentation: true in .cabal, rebuilding world, installing hoogle, hoogle data -r -l all, and then hoogle server -l
15:11:49 <johnw> but clearly there are some snags yet
15:12:22 <typoclass> oh, good to know. where does the convert thing you mentioned fit in?
15:12:42 <johnw> you shuoldn't have to do that
15:12:51 <johnw> I'm only doing it to find out why things are broken
15:13:11 <johnw> when you install with --haddock-hoogle, you get a .txt which you can turn into a .hoo, which can mereg into default.hoo
15:13:22 <johnw> that way, you can add local Hoogle support for packages you haven't uploaded to Hackage
15:14:08 <typoclass> (i just tried to set it up once and discovered i'd have to manually run a command for every package installed, or some such, and decided that's too annoying. this was perhaps 2 years ago. i think it's made progress.)
15:14:23 <johnw> yeah, Neil keeps working on it
15:14:35 <johnw> see you later
15:14:49 <mrg_> hi
15:16:44 <mrg_> i'd like to explore monad transformers and found MaybeT in Control.Monad.Maybe but import with GHCI fails
15:16:59 <kanedank> so I have this code: http://hpaste.org/74269 and this is my effort to test it: http://hpaste.org/74270
15:17:52 <kanedank> forget it, forgot to call Data.Map.lookup instead
15:17:58 <kanedank> sorry!
15:20:21 <mrg_> i found MaybeT right here: http://www.haskell.org/haskellwiki/New_monads/MaybeT
15:20:42 <mrg_> aren't the "new monads" included in some package or whatever?
15:21:17 <Ralith> How do I get 'cabal build' to respect locally-installed packages that aren't on hackage?
15:27:57 <kanedank> hey why do I get an error for multiple declarations when I have a var of the same name defined in different records?
15:28:11 <kanedank> do records in the same file share a namespace or something?
15:28:25 <ddarius> No, functions share a namespace.
15:28:30 <ddarius> Record accessors are just functions.
15:31:29 <typoclass> kanedank: you could put the records in different modules, and then do "import BlahBlah as X ; import OtherBlahBlah as Y" and use X.theField and Y.theField without a clash (note "theField" == "theField"). or you could bake in that prefix and call them all unique names (xTheField, yTheField)
15:32:20 <nand`> you can simulate record namespaces by placing each record into a separate module and then importing those qualified by the record name, but that might be tedious or even difficult/impossible (consider corecursive records)
15:34:21 <ddarius> It would be much less tedious with local modules.  Local Modules 2014.
15:35:02 <nand`> or perhaps an extension could provide actual namespaces for each record
15:35:21 <ddarius> Fuck that.
15:35:45 <ddarius> Unless we're going to unify modules and records.
15:35:49 <typoclass> nand`: while we're at it, let's have a huge discussion about type-directed name resolution
15:36:00 <nand`> type-directed name resolution?
15:36:38 <maukd> ad hoc overloading
15:36:54 <typoclass> nand`: eh, one of the proposed approaches to do what you suggested, as far as i understand it
15:36:57 <nand`> like, if x is known to be of type RecordA (as opposed to RecordB), foo x would automatically disambiguate to the only version that accepts RecordA?
15:37:09 * ddarius thinks maukd and mauke hash to the same color in xchat.
15:37:22 <nand`> they definitely do not in weechat, and it is very confusing
15:37:26 <maukd> just as keikaku
15:37:43 <nand`> the hasher is also case sensitive, so stuff like SHACHAF appears in a different color as sHACHAF and shachaf
15:37:50 <nand`> it's very annoying
15:37:55 <maukd> now that's just stupid
15:39:12 <`Jake`> Aren't there user preferences or something to change that?
15:40:20 <parcs`> probably. weechat has a ton of options
15:40:47 <`Jake`> Well then it should be acceptable
15:41:13 <nand`> I don't think there are
15:41:45 <`Jake`> Well then it's not acceptable
15:41:47 <nand`> there's a setting to override certain nicks, and a setting to ignore suffixes (eg. everything after and including =_|[`)
15:41:53 <nand`> but no setting to control case sensitivity
15:42:39 <ddarius> With a bit of care, you could probably correct the problem by changing just a few bytes of the binary.
15:43:02 <`Jake`> Just make sure that you change the right bytes
15:43:38 <typoclass> maybe by a brute force approach. try all the bytes!
15:43:45 <nand`> you could probably either write a script (I don't know how much power scripts have over the color hashing process, but worst comes to worst you can simple write a script to overwrite the color), or just modify the source code itself
15:46:01 <`Jake`> I just wanted to know in which language weechat was written, and the first thing I read on wikipedia was "multilingual". I was confused for a moment.
15:46:12 <nand`> haha
15:46:29 <maukd> C
15:46:36 <maukd> terrible C
15:46:38 <nand`> It's written in C, and scripts can be written in Perl, Python, Ruby, Lua, Tcl and Scheme - unfortunately, not Haskell
15:46:54 <ddarius> maukd: Do you know where I can get a terrible C compiler?
15:46:55 <nand`> I've been considering writing a Haskell plugin for weechat on multiple occasions before but I can't figure out the FFI
15:47:00 <nand`> so that was the end of that
15:47:24 <c_wraith> ddarius: do you know where I can get a *not*-terrible C compiler?
15:47:59 <maukd> I once read weechat's scripting api
15:48:05 <maukd> and then I stopped
15:48:11 <ddarius> c_wraith: I don't know the language *not*-terrible C.
15:48:50 <Twisol> I'm looking for a little advice on designing a library for reading a Telnet data stream. <http://hpaste.org/74272> Right now I have a typeclass defining various actions (onText, onQuery, onCommand), and a function that [doesn't actually parse Telnet yet but] executes a sequence of these actions based on a chunk of data. I like the typeclass thing, but I feel a bit lost otherwise. Like for example, should the type implementing onText etc. be different from
15:48:50 <Twisol> the type of the parser itself?
15:51:02 <typoclass> i think c can be shoehorned into becoming nonterrible c. it requires standards, a lot of discipline, strong oversight, and an experienced dude who gives feedback
15:52:57 <clsmith> eh, for something designed in 1969 C is pretty sweet.
15:53:12 <hbIppo> clsmith: seconded
15:53:25 <typoclass> > 2012 - 1969
15:53:26 <lambdabot>   43
15:53:53 <ddarius> There were better languages than (modern) C in 1969, and also 1969 C was not modern C.
15:54:06 <clsmith> well, we should have moved on. but most more recent languages suck more. so, let's toast.
15:54:15 <clsmith> ddarius: like what?
15:54:39 <nand`> ‘most more recent languages suck more’ <- what about the ones that don't?
15:54:43 <schellsan> lisp?
15:55:17 <clsmith> nand`: most of them aren't designed for the same purposes as C
15:55:26 <schellsan> wasn't that around in the 50's?
15:55:44 <clsmith> no, 1962 was the first lisp impl
15:56:04 <`Jake`> wikipedia sais "Appeard in 1958"
15:56:08 <clsmith> schellsan: 1, 1969 lisp was not modern lisp. 2, is it better? dynamically typed, etc...
15:56:12 <`Jake`> or something like that without a typo
15:56:19 <clsmith> `Jake`: no implementation.
15:56:22 <`Jake`> ok
15:56:44 <schellsan> so two years senior - tho at that point it was probably hardly practical
15:57:14 <hbIppo> ((lambda (x) (list x (list 'quote x)))
15:57:20 <clsmith> i mean, i don't know when macros appeared in lisp.
15:57:24 <hbIppo>   '(lambda (x) (list x (list 'quote x))))oh right, so much better and simpler than c
15:57:39 <typoclass> memory safety is a good idea. i can't believe people are even debating that
15:57:39 <schellsan> ;P
15:57:43 <hbIppo> (sorry, I mangled the lines)
15:58:02 <clsmith> yeah, i'm personally not a lisp fan. to me it feels like .. coarse sand? hard to describe.
15:58:49 <clsmith> typoclass: a lot of things are good ideas; not all of them should necessarily be in every language
15:58:57 <schellsan> i'm not much of an anything but haskell fan as of late…hence being in this room
15:59:02 <maukd> when did lisp grow lexical scoping? the 70s?
15:59:05 <hbIppo> on the other hand
15:59:07 <hbIppo> c allows this
15:59:11 <hbIppo> void (*(*f[])())()
15:59:28 <hbIppo> so yeah, maybe lisp is not *that* worse
15:59:40 <ddarius> maukd: Scheme was the first lexically scoped Lisp.
15:59:45 <nand`> (why bother discussing languages that were around in 1969? Not much we can change about that now)
15:59:48 <maukd> :t ?void (*(*?f[])())()
15:59:49 <lambdabot> Not in scope: `*?'
15:59:52 <clsmith> so, 1975
15:59:53 <maukd> :t ?void (*(* ?f[])())()
15:59:54 <lambdabot>     No instance for (Num ())
15:59:54 <lambdabot>       arising from a use of `*' at <interactive>:1:9-14
15:59:54 <lambdabot>     Possible fix: add an instance declaration for (Num ())
16:00:06 <maukd> hbIppo: looks like haskell allows it too
16:00:19 <hbIppo> oh god
16:00:24 <ben> What's with the ??
16:00:31 <clsmith> the ???
16:00:35 <ben> No, the ?
16:00:37 <nand`> implicit parameters
16:00:39 <schellsan> \?
16:00:42 <ben> oh :(
16:00:49 <maukd> :t ?f ?x
16:00:50 <lambdabot> forall t t1. (?x::t, ?f::t -> t1) => t1
16:00:56 <nand`> omitting them would have given a ‘no such name: void’ error of sorts
16:07:52 <Twisol> Is Cont generally a good option for implementing a network parser with?
16:10:31 <Eduard_Munteanu> Twisol: Cont gets you complex control flow, do you need that in your parser?
16:11:12 <maukd> what's a network parser?
16:11:20 <Twisol> maukd: parser of network data?
16:11:30 <Saizan> attoparsec is more specifically appropriate
16:11:32 <Twisol> implying that the data isn't all available immediately
16:11:54 <nand`> attoparsec handles suspensions, doesn't it?
16:12:05 <nand`> ie. if parsing requires more input, a suspension is returned instead of a value, and you can resume it yourself
16:12:12 <dolio> Isn't algol 68 better than C 69?
16:12:35 <Twisol> Eduard_Munteanu: I think so; maybe you can tell me whether I'm correct. (1) If the parser needs more data, but the chunk has run out, I figured the parse could be interrupted until more is available. And (2) the parse may need to be halted because the data format is about to change (think HTTP's Upgrade mechanism with WebSocket)
16:13:00 <Twisol> if a Telnet event is received stating that compression is about to begin, the parse should be halted so the remainder of the chunk can be decompressed before continuing
16:13:12 <MostAwesomeDude> Twisol: Well, if you're implementing WebSockets, I would recommend bashing your head against a wall before proceeding.
16:13:18 <Twisol> nand`: Telnet, actually.
16:13:26 <Twisol> *MostAwesomeDude
16:13:44 <MostAwesomeDude> Twisol: http://hackage.haskell.org/packages/archive/attoparsec/0.10.2.0/doc/html/Data-Attoparsec-ByteString.html
16:13:50 <MostAwesomeDude> Check out the IResult type.
16:14:48 <Twisol> MostAwesomeDude: If the parse had to be halted for some reason other than end-of-input, would there be a way to recover the remainder?
16:15:16 <nand`> Twisol: if a parse fails, the rest of the input is returned
16:15:27 <nand`> if it success, it is as well
16:15:31 <nand`> succeeds*
16:15:54 <Twisol> nand`: But in this case, I still want to consume more input. It's just being yielded back to the caller so that the so-called upgrade can occur
16:17:14 <mapreduce> I've seen Control.Workflow, which is interesting, but is there anything that can take a chain of actions and allow one to inspect (say, from another thread) the chain to see where it's up to, and rerun from a certain point?  I'm looking for inspiration for a non-Haskell solution, so vapourware or stuff in other languages is ok.
16:17:20 <nand`> oh, I think I see what you want to do now - you want to suspend back to the caller with something like Partial' t (t -> IResult t r) where the caller would take the ‘t’, transform it, and pass that back?
16:17:28 <Twisol> nand`: Essentially!
16:17:35 <MostAwesomeDude> Twisol: TBH I'd go with the Twisted protocol pattern: When you get data, concat it into a buffer of all unprocessed data. Parse out as many events as you can, and then save the buffer for later.
16:17:49 <MostAwesomeDude> Twisol: Note that there *are* tools to do this on top of conduits, if you're using attoparsec or cereal.
16:18:10 <nand`> also yes, conduits etc. can do stuff like handle decompression ‘on the fly’
16:18:18 <nand`> I'm not sure how that'd play together with attoparsing
16:18:53 <Twisol> Well, this is what I have right now: http://hpaste.org/74272
16:19:00 <nand`> attoparsec provides a monad doesn't it? so it should be possible to switch parsers while parsing
16:19:07 <Twisol> I don't know whether that's anything close to what I should be doing.
16:19:30 <dolio> Or even algol 60.
16:22:23 <Twisol> The idea in that paste is, if any of the actions (except onQuery) provide a False value, the parse would stop, provide the remainder of the chunk, and a continuation to proceed.
16:25:00 <putty> @pl \a (fmap fst) .( filter ((`elem` es) . snd)) . assocs a
16:25:00 <lambdabot> (line 1, column 10):
16:25:00 <lambdabot> unexpected "f"
16:25:00 <lambdabot> expecting operator or ")"
16:25:10 <putty> @pl \a -> (fmap fst) .( filter ((`elem` es) . snd)) . assocs a
16:25:11 <lambdabot> ((fmap fst . filter ((`elem` es) . snd)) .) . assocs
16:34:12 <gertc> @t Maybe 1
16:34:12 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:34:41 <gertc> @type Maybe 1
16:34:42 <lambdabot> Not in scope: data constructor `Maybe'
16:34:49 <gertc> @type Just 1
16:34:51 <lambdabot> forall t. (Num t) => Maybe t
16:34:59 <daniel_-> does haskell have anything like pythons String translate() http://docs.python.org/library/string.html#string.translate
16:35:06 <MostAwesomeDude> Is there a fair random insertion or random deletion for lists somewhere already?
16:35:11 <gertc> @type [1]
16:35:12 <lambdabot> forall t. (Num t) => [t]
16:37:15 <DMWIT> daniel_-: I haven't got a browser handy at the moment; what does translate do?
16:37:30 <DMWIT> shift every character or something like that?
16:37:35 <daniel_-> "Delete all characters from s that are in deletechars (if present), and then translate the characters using table, which must be a 256-character string giving the translation for each character value, indexed by its ordinal. If table is None, then only the character deletion step is performed."
16:37:42 <daniel_-> yee
16:38:37 <DMWIT> > let table 'a' = 'b'; table x = x; deletions = "cd" in map table . (\\deletions) $ "abcd"
16:38:39 <lambdabot>   "bb"
16:38:46 <benmachine> woo, I just wrote possibly my longest SO answer ever :P http://stackoverflow.com/a/12272689/812053
16:38:56 <nand`> > "abcdcd" \\ "cd"
16:38:57 <lambdabot>   "abcd"
16:39:01 <DMWIT> whoops
16:39:06 <DMWIT> :t difference
16:39:07 <lambdabot> Not in scope: `difference'
16:39:11 <nand`> > filter (not . (`elem` "cd")) "abcdcd"
16:39:11 <benmachine> and it would have been longer except I started doubting anyone's ability to stay awake throughout
16:39:13 <lambdabot>   "ab"
16:39:31 <nand`> (is there an inverted filter?)
16:39:42 <DMWIT> > filter (`notElem` "cd") "abcdcdcd"
16:39:43 <lambdabot>   "ab"
16:39:48 <nand`> nice
16:40:05 <nand`> so yeah, daniel_- a filter and a map
16:40:19 <DMWIT> > let table 'a' = 'b'; table x = x; deletions = "cd" in [table c | c <- "abcde", c `notElem` deletions]
16:40:19 <nand`> why python provides such a needlessly complex/specific and seemingly arbitrary function I cannot fathom
16:40:21 <lambdabot>   "bbe"
16:40:58 <MostAwesomeDude> nand`: It's a translation table for ASII.
16:41:02 <MostAwesomeDude> Er, *ASCII.
16:41:18 <DMWIT> I think Python provides it because somebody liked the "tr" command.
16:41:23 <daniel_-> see python example http://en.wikipedia.org/wiki/Hash-based_message_authentication_code#Implementation
16:41:34 <MostAwesomeDude> DMWIT: Pretty much.
16:42:12 <nand`> the translation table seems redundant in that example
16:42:15 <nand`> why not map (xor 0x5c)
16:42:25 <DMWIT> daniel_-: The Haskell-ish way to do that is to map (...what nand` said.
16:42:37 <DMWIT> And to not use String in the first place.
16:42:42 <nand`> yes
16:42:54 <nand`> stringy semantics like that are bad and you should feel bad :(
16:44:30 <benmachine> python3 at least has proper support for bytestrings
16:44:52 <benmachine> /in other news/ I also rewrote this article today: http://www.haskell.org/haskellwiki/Polymorphism
16:44:57 <benmachine> and merged two other articles into it
16:45:03 <benmachine> I hope no-one thinks this impertinent of me
16:45:14 <MostAwesomeDude> @pl \i xs x -> let (before, after) = splitAt i xs in before ++ x:after
16:45:14 <lambdabot> (line 1, column 16):
16:45:14 <lambdabot> unexpected "("
16:45:14 <lambdabot> expecting "()", natural, identifier or "in"
16:45:24 <benmachine> I think there ought to be a broader discussion of what haskellwiki is for and what sort of thing should go on it
16:45:24 <MostAwesomeDude> @pl (\i xs x -> let (before, after) = splitAt i xs in before ++ x:after)
16:45:24 <lambdabot> (line 1, column 17):
16:45:25 <lambdabot> unexpected "("
16:45:25 <lambdabot> expecting "()", natural, identifier or "in"
16:45:33 <MostAwesomeDude> Oh, @pl can't handle that. Hm.
16:45:40 <benmachine> but haskell-cafe frightens me, so I am hesitant to start that discussion
16:45:45 <nand`> λ let val = iso ord chr in (mapped.val %~ xor 0x5c) "Hello, world!"
16:45:47 <nand`> "\DC49003p|+3.08}"
16:45:56 <nand`> @ask edwardk why isn't there a xor lens in Data.Bits.Lens? Would make some golf prettier
16:45:57 <lambdabot> Consider it noted.
16:46:18 <DMWIT> pretty golf: the driving factor behind the entire Hackage codebase
16:46:28 <nand`> hehe
16:46:56 <benmachine> @pl (\i xs x -> (\(before, after) -> before ++ x:after) (splitAt i xs))
16:46:56 <lambdabot> (flip ((`ap` snd) . (. fst) . flip ((.) . (++)) . (:)) .) . splitAt
16:46:58 <nand`> @ask edwardk also an ‘iso ord chr’ lens could be interesting
16:46:58 <lambdabot> Consider it noted.
16:47:06 <benmachine> MostAwesomeDude: ^ was it worth it :P
16:47:12 <MostAwesomeDude> benmachine: Of course not. :3
16:47:26 <MostAwesomeDude> I am a little sad that this particular combinator, insertAt, isn't in Data.List.
16:47:27 <Ralith> bos: shouldn't LLVMConst* be pure?
16:47:36 <benmachine> :t \x -> uncurry (++) . fmap (x:)
16:47:37 <lambdabot> forall a. a -> ([a], [a]) -> [a]
16:48:00 <tibbe> Is there a QuickCheck-like package for testing strictness properties of functions?
16:48:04 <Lutin`> What is @pl
16:48:13 <nand`>  @pointless
16:48:17 <Lutin`> ah
16:48:20 <nand`> @help pl
16:48:20 <lambdabot> pointless <expr>. Play with pointfree code.
16:48:28 <MostAwesomeDude> Lutin`: "point-less"; it removes points (bound names) from expressions.
16:48:49 <Lutin`> Yeah I know what pointless means
16:48:53 <daniel_-> @hoogle iso
16:48:54 <lambdabot> Data.Char isOctDigit :: Char -> Bool
16:48:54 <lambdabot> package iso3166-country-codes
16:48:54 <lambdabot> System.Locale iso8601DateFormat :: Maybe String -> String
16:49:19 <Lutin`> point free
16:49:20 <Lutin`> w/e
16:52:12 <benmachine> tibbe: I'm sure I'd heard of one, but I can't find it now
16:52:34 <daniel_-> nand` what is the (%~), iso and mapped.val
16:52:47 <nand`> daniel_-: stuff from Control.Lens (package "lens" on hackage)
16:52:50 <hpc> daniel_-: iso defines an isomorphism
16:53:03 <daniel_-> okay
16:53:14 <hpc> (iso ord chr) is an isomporphism between Int and Char, with ord and chr being the two conversions
16:53:19 <hpc> > ord 32
16:53:20 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
16:53:20 <lambdabot>    arising from the literal `3...
16:53:21 <daniel_-> so above my knowledgelevel, roger that
16:53:21 <hpc> er
16:53:24 <hpc> > chr 32
16:53:25 <lambdabot>   ' '
16:53:28 <hpc> > ord ' '
16:53:29 <lambdabot>   32
16:53:59 <hpc> mappend is an operation on Monoids
16:54:02 <hpc> and i don't know the rest
16:54:09 <nand`> it's mapped, not mappend :D
16:54:13 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html
16:54:16 <hpc> oh, mapped
16:54:24 <hpc> then i don't know that either
16:54:34 <nand`> mapped is a setter from f a to a where f is a functor
16:55:00 <nand`> that is to say, mapped :: Functor f => Setter (f a) (f b) a b
16:56:08 <daniel_-> sometimes i wonder by i even bother with haskell without a CS/Math/etc education
16:56:33 <hpc> daniel_-: because eventually, with enough haskell, you will have that education
16:56:34 <hpc> ;)
16:56:37 * nand` doesn't have a CS/Math/etc education
16:56:39 <monochrom> perhaps haskell is your CS education
16:56:47 * hpc has a BS CS
16:56:59 <benmachine> certainly you shouldn't bother with haskell if you're not willing to learn
16:57:04 <benmachine> or, you know, getting out of bed :P
16:57:06 <fds> It is indeed difficult to learn things without learning anything. :-)
16:57:34 <benmachine> (although, saying that, in this modern age it's quite possible to learn haskell without getting out of bed...)
16:57:37 <daniel_-> the day i understand lenses and all the weird haskell magic things seems like soo far away
16:58:00 <daniel_-> i really would like to learn
16:58:13 <nand`> understanding how to use lenses is probably easier than foundationally understanding them
16:58:35 <nand`> https://github.com/ekmett/lens/wiki/Tutorial
16:58:40 <nand`> should be fairly accessible
16:59:10 <benmachine> I have no idea how the latest set of lenses work, but I'm pretty sure I can write software that uses them
16:59:23 <benmachine> the theory is /nice/ but it's often /optional/
16:59:24 <Lutin`> I just wish there was some place that would teach it to me like I'm a math major :[
16:59:27 <Ralith> bos: hm, I'm getting a duplicate definition error for LLVMAddAlwaysInlinerPass on linking llvm-base; any ideas?
17:00:02 <bos> Ralith: still at work, busy, sorry
17:00:14 <daniel_-> i wish there was something like readthedocs for haskell and not just endless API docs (hackage) and some hidden tutorials if you're lucky
17:00:19 <Ralith> bos: kk, no worries
17:00:24 <nand`> what's readthedocs?
17:00:52 <daniel_-> a site that promoted every package to have their documentation there
17:01:05 <daniel_-> so everything can be found at one place
17:01:42 <nand`> Lutin`: “oh, lens families are just readers on indexed store comonads” ?
17:01:54 <Lutin`> Yeah but see
17:01:56 <daniel_-> tutorials, documentation and api documentation all collected at one place for every package with a nice search
17:02:04 <Lutin`> I need learn what those are
17:02:09 <daniel_-> api reference*
17:02:12 <Lutin`> But yes like that
17:02:20 <nand`> daniel_-: ah, so it's like hackage but you get tutorials and examples too?
17:02:27 <daniel_-> yep
17:02:34 <nand`> that doesn't sound half bad
17:02:58 <Lutin`> Cause I've already got most of my basic algebraic structures down, just not the categories
17:02:59 <nand`> I do often find myself searching for examples/tutorials on stuff that's too whopping to just pick up from looking at haddocks
17:03:17 * hackagebot iteratee 0.8.9.4 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.9.4 (JohnLato)
17:03:20 <benmachine> Lutin`: there are SO MANY ALGEBRAIC STRUCTURES.
17:03:26 <benmachine> people just keep coming up with the buggers
17:03:26 <nand`> Lutin`: “oh, comonads are just monoids in the cocategory of endofunctors”
17:03:43 <nand`> benmachine: and they all have names that have nothing to do with eachother, even if the structures are related
17:03:45 <benmachine> nand`: is that... actually true
17:03:49 <nand`> benmachine: it is
17:03:54 <benmachine> oh
17:04:04 * benmachine scratches head a bit
17:04:08 <edwardk> nand`: Data.Char.Lens with _chr or something could work. not sure what else can be put in there though
17:04:30 <Lutin`> nand`: I'm up to rings, and what they include
17:04:37 <nand`> I named it ‘val’ for local use, don't know what would be better though
17:04:41 <nand`> as in, the value of characters
17:04:43 <daniel_-> i think my next step in haskell progress is stop using the IO monad for everything, but i never see myself needing to use anything else :( (reader, writer, list monads and the combined versions)
17:04:45 <nand`> maybe .codepoint
17:04:47 <Lutin`> I need to take a class on category theory
17:04:54 <MostAwesomeDude> daniel_-: IO is not your enemy.
17:04:55 <benmachine> Lutin`: ah but are those rings or rngs or rigs, are they commutative or not... :P
17:05:13 <edwardk> codepoint is awkward because it'd usualy be used for multipoint decoding if you went by java's methodnames
17:05:13 <nand`> names like ‘rigs’ and ‘rngs’ amuse me
17:05:17 <nand`> it's a shame they don't localize too well
17:05:19 <Lutin`> Yeah
17:05:24 <Lutin`> It took me a bit
17:05:27 <benmachine> daniel_-: most haskell you don't use any of those, you just write functions
17:05:33 <Lutin`> What's rngs
17:05:37 <Lutin`> I mean rigs
17:05:44 <benmachine> Lutin`: without negation
17:05:47 <Lutin`> Ah
17:05:52 <Lutin`> addtive inverse
17:05:55 <benmachine> yeah
17:06:05 <nand`> edwardk: but, it's a lens between characters and their unicode codepoints, is it not? it seems fitting to me
17:06:19 <hpc> daniel_-: i think your next step is actually to transform those things ON TOP of IO
17:06:21 <nand`> not sure how java method names relate (I don't know java)
17:06:50 <hpc> which gives you some nice features
17:06:54 <edwardk> Lutin`: to check your list of algebraic structures, go through https://github.com/ekmett/algebra
17:06:55 <daniel_-> ye
17:07:01 <Lutin`> daniel_-: You could write all your programs using free monads
17:07:05 <benmachine> nand`: I'm still curious, what's a cocategory/
17:07:06 <nand`> RWST conf log state IO -- the love of imperative programmers everywhere
17:07:12 <nand`> benmachine: the dual of any category
17:07:15 <edwardk> i'm sure you'll have missed a few useful ones along the way ;)
17:07:17 <nand`> (arrows reversed)
17:07:26 <daniel_-> but now im mostly finding myself rewriting my ADT's constantly since i find out ways to make them better
17:07:26 <benmachine> nand`: wouldn't that just be a category, but a different one?
17:07:31 <hpc> nand`: haha
17:07:35 <nand`> benmachine: correct
17:07:35 <edwardk> its just a category
17:07:36 <daniel_-> and therefore breaking much of my program
17:07:43 <MostAwesomeDude> nand`: Hey, don't be mean; that's a really useful monad for e.g. SDL work.
17:07:55 <edwardk> like cofunctor = functor, kind of a useless name ;)
17:07:55 <benmachine> nand`: hmph. I call that unhelpful terminology
17:08:02 <nand`> MostAwesomeDude: I wasn't trying to be mean - I didn't meant to imply imperative algorithms are necessarily bad
17:08:11 <benmachine> edwardk: yeah but in that case it's even the same functor, right?
17:08:16 <MostAwesomeDude> nand`: Also I actually legitimately used RWS the other day. RWS Ticks Notes Position for writing out MIDI from an AST.
17:08:17 <benmachine> or wait no
17:08:19 <edwardk> benmachine: yep
17:08:19 <benmachine> whatever :P
17:08:39 <MostAwesomeDude> nand`: I can't not think imperatively when doing SDL. :3
17:08:46 <hpc> for certain values of S, RWS can express a website
17:08:54 <hpc> (ie, database)
17:09:06 <nand`> I have used RWST IO or flavors of it (eg. without the writer or reader) often enough
17:09:23 <Lutin`> What's the T in RWST
17:09:28 <benmachine> Lutin`: transformer
17:09:29 <Twisol> transformer
17:09:29 <hpc> transformer
17:09:32 <benmachine> I win
17:09:33 <Lutin`> figured
17:09:43 <nand`> usually, I split applications into the ‘library’ (backend) and the ‘frontend’, and I do things imperative for the frontend since it often involves stuff like user input
17:09:54 <nand`> ‘reader writer state transformer’ has a nice ring :)
17:10:07 <Twisol> nand`: a Linkin Park ring?
17:10:09 <Twisol> er
17:10:13 <Twisol> Not Linkin Park
17:10:14 <MostAwesomeDude> Really, RWS is State, but with the promise that you won't write to, or read from, certain parts of your state.
17:10:15 <Lutin`> Daft Punk
17:10:19 <Twisol> Yes. >_<
17:10:23 <Lutin`> technologic - daft punk
17:10:27 <nand`> now that you mention it, you're right
17:10:34 <MostAwesomeDude> Oh god, can't unhear it.
17:10:35 <nand`> Lutin`: don't you mean ‘Harder Better Faster Stronger’ for that particular ring?
17:10:39 <Lutin`> no
17:10:39 <nand`> wait
17:10:41 <nand`> they have the same pattern
17:10:46 <Lutin`> Not really
17:10:47 <benmachine> almost
17:10:48 <hpc> almost
17:10:56 <hpc> technologic is more repetitive
17:10:58 <benmachine> move one of the syllables from one word to the other
17:11:06 <Lutin`> But like
17:11:07 <geekosaur> they're dance, they're going to be pretty similar anyway :p
17:11:11 <benmachine> heh
17:11:14 <nand`> I thought they're both iambic
17:11:18 <Lutin`> Thing about the actual music part
17:11:29 * hpc is more fond of around the world
17:11:36 <Twisol> I was thinking Harder Better Faster Stronger too, myself
17:11:41 <benmachine> nand`: the emphasis sounds like it's on the first foot to me
17:11:48 <nand`> uh, not iambic
17:11:51 <nand`> trochaic
17:11:52 <Lutin`> Nah like
17:11:54 <benmachine> that's the one
17:11:58 <nand`> those names are confusing
17:12:05 <Lutin`> I like it a lot more with technologic
17:12:13 <benmachine> trochaic... tetrameter? I guess?
17:12:16 <Lutin`> I mean it's a lot shorter
17:12:31 <nand`> benmachine: for HBFS and RWST yeah
17:13:32 <Lutin`> It's just like
17:13:36 <Lutin`> Transformer
17:13:42 <Lutin`> CANNOT fit into HBFS
17:14:00 <Lutin`> All the phrases in HBFS are 2 beats
17:14:08 <benmachine> Lutin`: yeah, so you just move the phrase boundaries
17:14:12 <Lutin`> That's what was throwing me off
17:14:16 <nand`> yeah, it'd be ‘State-trans For-mer’
17:14:20 <MostAwesomeDude> do it, bind it, run it, stack it, reader, writer, state trans-, -former
17:14:27 <nand`> MostAwesomeDude: perfect
17:14:40 <Twisol> HBFS is 2-2-2-2, RWST is 2-2-1-3
17:14:40 <MostAwesomeDude> If only I had my drum machine at work.
17:15:08 <Twisol> *applause*
17:15:14 <Lutin`> And parts of technologic
17:15:15 <benmachine> MostAwesomeDude: I was trying to think of things that would match up, so it would be more like "ask it, tell it, put it, ... something"
17:15:20 <Lutin`> Are also 2-2-1-3
17:15:27 <MostAwesomeDude> benmachine: Oh, if you need more words, definitely.
17:15:36 <MostAwesomeDude> I mean, what's the point of a parody if you can't come up with full verses? :3
17:15:38 <benmachine> but then the moved phrase boundary would screw up when they interleave them :(
17:15:49 <callen> I wasn't able to get very far, or very productive with Haskell itself, but I would like to state that monads have cleaned up my python code considerably.
17:15:54 <callen> that is all.
17:15:58 <benmachine> callen: neat!
17:16:03 <callen> benmachine: fewer if statements :P
17:16:07 <callen> or at least, simpler ones.
17:16:20 <Twisol> callen: functional concepts have a habit of spreading virally into the rest of your code
17:16:22 <Twisol> :D
17:16:26 <nand`> ‘ask it, tell it, put it, run it, reader, writer, state trans-, -former’
17:16:29 <benmachine> I got nostalgic for a haskell library (blaze-markup) in my python programs and tried to reimplement it
17:16:29 <hpc> same happened to me with perl
17:16:38 <hpc> though i didn't end up actually writing Monad
17:16:42 <callen> Twisol: my python was already somewhat functional due to my lisp experience, that's why I mentioned monads specifically.
17:16:45 <hpc> or even /a/ monad
17:16:51 <callen> Twisol: monadic composition and structuring isn't as common in Lisp.
17:16:53 <MostAwesomeDude> callen: My biggest breakthrough was realizing that Deferred (from Twisted) is a Monad.
17:16:55 <Twisol> callen: my statement still stands, I hope
17:16:56 <Lutin`> nono nade
17:16:57 <benmachine> the result... I'm pretty sure one of "terrible" and "wonderful" apply and I'm not sure which
17:16:58 <hpc> just some really specific Cont trickery
17:17:00 <benmachine> ≥ 1
17:17:06 <Lutin`> Technologic is 2-2-2-2 2-2-1-3
17:17:06 <callen> Twisol: more or less.
17:17:14 <Lutin`> So don't split transformer
17:17:36 <benmachine> Lutin`: hasn't it got a bunch more 2s
17:17:44 <Lutin`> Uh
17:17:46 <Lutin`> Just repeat that
17:17:49 <benmachine> I dunno, my iPod is... somewhere else
17:17:56 <benmachine> Lutin`: oh, I suppose
17:18:12 <benmachine> I thought the 1-3 bits were less regular than that but I guess you're right
17:18:23 <Lutin`> [2-2-2-2 2-2-1-3]x4 [1-1-1-1]x4 intro music repeat
17:18:56 <benmachine> fair enough :P
17:19:15 <Lutin`> Or 8 times the first time
17:19:22 <Lutin`> If I actually look at the lyrics lol
17:21:59 <edwardk> nand`: re harder, better, faster, stronger, wrong package. that comes up in trifecta. ;) https://github.com/ekmett/trifecta/blob/master/src/Text/Trifecta/Util/It.hs#L16
17:22:33 <edwardk> too bad simplifyIt broke my rhythm
17:24:18 <nand`> if you can come up with one more ‘xit’ and another one syllable word the ‘rewindit’ would fit the end nicely
17:24:46 <maukd> this is how I design my APIs
17:28:17 * hackagebot lzma-conduit 0.5.2.1 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.5.2.1 (NathanHowell)
17:28:19 * hackagebot http-server 1.0.1 - A library for writing Haskell web servers.  http://hackage.haskell.org/package/http-server-1.0.1 (IavorDiatchki)
17:55:51 <nh2> how do I do a cabal build that shows all warnings (even if the build succeeded just before)?
17:56:26 <nh2> I do not care if the input changed, I just want to see all the warnings
17:56:50 <hpc> nh2: do a clean build
17:56:56 <dcoutts> cabal build --ghc-options="-fforce-rebuild -Wall"
17:57:04 <hpc> like that
17:57:05 <nh2> hpc: that takes 5 minutes ;)
17:57:11 <hpc> well...
17:57:13 <hpc> tough
17:57:14 <hpc> :D
17:57:27 <nh2> dcoutts: that will also take the same time, right?
17:57:31 <dcoutts> or was it -fforce-recomp, I forget
17:57:40 <hpc> recomp
17:57:48 <hpc> so says ghc-man-completion
17:57:56 * dcoutts defers to hpc
17:58:17 <dcoutts> nh2: more or less, it has to actually do the build to get the warnings, you can use -O0 though
17:58:35 <hpc> you can also -Werror
17:58:50 <hpc> and then over rebuilds, there will be no recompilation of files without warnings
17:58:55 <hpc> (unless they change)
18:01:24 <nh2> hpc, dcoutts: okay, -O0 better, but it still takes very long. I mean theoretically I only want to type-check, and do no codegen at all
18:01:54 <dcoutts> nh2: that's possible, there's a ghc flag for that and you could use that with cabal build --ghc-option=...
18:01:58 <hpc> nh2: you can try one of the flags that stops after a specific stage
18:02:09 <hpc> i think the earliest you can terminate is core, though
18:02:13 <dcoutts> there's one that does everything except generate code
18:02:18 <dcoutts> so it generates the .hi file
18:02:33 <nh2> where could I look up how these stages/options are called?
18:02:39 <dcoutts> nh2: the ghc user guide
18:02:58 <Lutin`> SO how many of you use xmonad?
18:03:10 <hpc> i want to say it's the -pgm* options, but i honestly don't remember
18:03:34 <nh2> awesome, when I google ghc "only type-check " I get PHP results
18:03:48 <dcoutts> nh2: google for the "ghc user guide"
18:03:55 <johnsonmax> Hi. New installation of haskell-platform. Trying to install pandoc and the dependencies all fail to build with "The build-tool has reset ENV.". Googling for this and extraordinarily it's a googlewhack! So no help there. Anyone seen this message before?
18:04:42 <dcoutts> johnsonmax: never seen that, it doesn't sound like a cabal message
18:05:05 <hpc> johnsonmax: can you paste the output of cabal?
18:05:43 <Lutin`> Are you on OSX johnsonmax?
18:05:54 <johnsonmax> hpc: this is fresh installation of haskell-platform on OS X, via homebrew http://pastebin.com/UiKcKb48
18:06:09 <Lutin`> "The build-tool has reset ENV."
18:06:11 <nh2> dcoutts, hpc: this one looks good: -fno-code
18:06:12 <johnsonmax> hpc: and it's a fresh install of os x as of an hour ago so no existing crud
18:06:12 <startling> johnsonmax: which os x?
18:06:13 <Lutin`> Yeah
18:06:17 <hpc> nh2: :D
18:06:21 <Lutin`> https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&ved=0CCIQFjAA&url=https%3A%2F%2Fgithub.com%2Fmxcl%2Fhomebrew%2Fissues%2F14392&ei=K6VGUJCmEITe2QWD_4HYBA&usg=AFQjCNGwndm7f6DizXFlyjFfJ0BNjIo9AQ&sig2=ImIs8VMUkxqekFRpOzSPpA
18:06:26 <johnsonmax> startling: 10.8, latest
18:06:29 <Lutin`> Woah that link
18:07:03 <nh2> here we go, this is over 4 times faster
18:07:14 <nh2> thanks, guys!
18:07:26 <startling> johnsonmax: k. I asked because 64-bit ghc on snow leopard and older can cause weird weird errors, but I guess that's not it.
18:07:29 <Lutin`> nh2 whatcha doin
18:07:42 <johnsonmax> Lutin`: that page doesn't seem to include the string when you actually search for it on the page
18:08:24 <Lutin`> It's in the diff notes
18:08:26 <nh2> Lutin`: trying to recompile with cabal build, just to reshow the warnings (usually it takes 5 minutes with forced recompilation, but with -fno-code it is faster)
18:08:50 <Lutin`>  	 134	
18:08:50 <Lutin`> +####################################################################### sanity
18:08:50 <Lutin`>  	 135	
18:08:50 <Lutin`> +abort "The build-tool has reset ENV. --lame-env required." unless ENV['HOMEBREW_BREW_FILE']
18:08:55 <Lutin`> Woah sorry guys
18:08:59 <Lutin`> Wrong clipboard
18:10:15 <johnsonmax> Lutin`: so this may be the interface to xcode's c compiler, something to do with xcode-selection perhaps
18:10:40 <Lutin`> Either way what is this homebrew thing
18:10:49 <Lutin`> You should ask on there
18:10:51 <Lutin`> not here
18:10:54 <johnsonmax> Lutin`: roger, will take it there
18:10:58 <Lutin`> You'd probably get more answers
18:11:25 <Lutin`> But stay in here someone might be able to help, we shall see
18:18:54 <frio> Lutin`: homebrew is a package manager for OSX, like apt/yum
18:20:13 <nh2> hpc: here we have it for future reference: http://stackoverflow.com/questions/12273315/how-to-recompile-haskell-with-cabal-build-showing-only-warnings
18:20:35 <hpc> nice
18:20:42 <hpc> i love "asked and answered" questions
18:22:14 <nh2> hpc: yeah, unfortunately they only allow to accept own answers after 2 days - I guess that's how they bind customers. I'm already bad with keeping my SO clean with normal questions
18:22:52 <hpc> nh2: ostensibly, if someone has a better answer than what you found
18:23:55 <nh2> hpc: yes, of course, generally it makes sense, but they could at least save me from doing the cleanup and allow me to auto-selfanswer if nobody else answers in the time
18:24:03 <hpc> heh
18:25:16 <nh2> the only thing that could be even faster than this might be ghc-mod lint, but that isn't for the whole project and doesn't like me these days (empty output)
18:25:55 <Saizan> cleanup?
18:27:03 <Cale> SO and friends would be so much better if they were just big wikis where anyone could edit anything
18:27:14 <hpc> they are, to a certain extent
18:27:18 <hpc> but more structured
18:27:44 <Cale> The extra structure they provide doesn't really help anyone, I think.
18:28:13 <Cale> Well, tagging, sure.
18:28:19 <Saizan> maybe it helps getting traffic
18:30:49 <maukd> Cale: ... anyone?
18:31:06 <maukd> they would be spammed to death
18:31:11 <Cale> huh?
18:31:28 <Cale> maukd: Like wikipedia is?
18:31:44 <maukd> yes
18:32:19 <Cale> We all know that wikipedia is about to die from all the spam you see in the articles ;)
18:38:53 <mm_freak> edwardk: i did some experiments with SpaceT…  while it's very elegant, it doesn't get along well with movements…  moving the space is a function composition instead of simple arithmetic
18:39:20 <mm_freak> so i guess a simple modification of StoreT is a better approach
18:39:22 <edwardk> well you could add a coordinate transform to the pipeline
18:39:38 <edwardk> and just store that directly as a matrix or linear transformation
18:40:08 <edwardk> e.g. instead of giving just a function give a function and a linear map to apply to it
18:40:21 <mm_freak> yeah, that's what i mean…  it's basically just a modified StoreT
18:40:22 <edwardk> then composition of the linear map can be constant time
18:40:41 <mm_freak> where you don't store the coordinate, but a transformation
18:40:55 <MostAwesomeDude> edwardk: I have a couple patches for trifecta. How do you prefer them?
18:40:59 <edwardk> well, i was thinking of the transformation in traced form
18:41:23 <edwardk> MostAwesomeDude: github pull requests. the tricky part is the mainline branch of the repository is on 0.90 already
18:41:38 <mm_freak> also i'm being unfair…  i have a lot of trouble implementing comonad transformers, so i'm in fact implementing Space, not SpaceT =)
18:41:42 <MostAwesomeDude> edwardk: Yes, and that's what I'm running for lye right now.
18:41:54 <edwardk> so you'll probably need to fork the repository and rewind a couple of versions to get.. oh. great =)
18:42:09 <MostAwesomeDude> I kind of went ahead and depended on trifecta from git; I want to get the whole stack up on Hackage so that I can finally upload lye and get people to laugh at it.
18:42:15 <MostAwesomeDude> Er, *critique it. :3
18:42:21 <edwardk> then yes, feel free to fork the repo and send me pull requests. i'm pretty fast at merging things
18:42:27 <MostAwesomeDude> Sweet.
18:42:46 <mm_freak>     extend f (IdT c') = IdT (extend (f . IdT) c')
18:43:00 <mm_freak> is that a correct implementation for newtype IdT w a = IdT (w a)?
18:43:10 <edwardk> mm_freak: yeah comonad transformers are still a little unnatural to me ;)
18:43:47 <mm_freak> they are a headache to implement to me…  it took me 10 minutes to write the implementation of IdT, and i'm not even sure it's correct
18:43:51 <edwardk> mm_freak: https://github.com/ekmett/comonad/blob/master/Control/Comonad.hs#L129
18:44:00 <edwardk> looks right to me
18:44:10 <mm_freak> ok, great =)
18:44:15 <edwardk> i tend to write the duplicate first, then use that and the shape of fmap to find where to drop the 'f'
18:44:38 <edwardk> duplicate (IdentityT m) = IdentityT (extend IdentityT m)
18:44:48 <mm_freak> i wanted to start with duplicate, but found that even harder…  i find it more natural to think in terms of extend
18:44:57 <edwardk> *nods*
18:45:10 <edwardk> the store example is how i usually sell duplicate over extend for implementation
18:45:17 <edwardk> duplicate (Store f s) = Store (Store f) s
18:45:23 <mm_freak> so if you're saying they are difficult, then i'm glad i'm not just too stupid =)
18:45:56 <edwardk> well, i kind of had to figure out the theory for them as i was going and had no guidelines for how they worked. so i was paying the trendsetter tax as well ;)
18:46:09 <mm_freak> yeah, duplicate is easy for Store, but i haven't managed to write either duplicate or extend for SpaceT =)
18:46:20 <edwardk> plus the first time i implemented them i screwed them up
18:46:27 <edwardk> many of the ones in category-extras were backwards, etc.
18:46:36 <putty> @pl \a b -> (fmap fst) .( filter ((`elem` b) . snd)) . assocs a
18:46:36 <lambdabot> ((fmap fst .) .) . flip ((.) . filter . (. snd) . flip elem) . assocs
18:47:16 <mm_freak> is there any theory?  comonad transformers seem even more arbitrary to me than monad transformers
18:47:54 <edwardk> mm_freak: they have exactly the same laws as a monad transformer, in fact the distributive laws for them are universally just the dual or opposite compositon of adjunctions that give you the monad transformers
18:48:17 <edwardk> that is why when you use 'Co' from kan-extensions to transform a comonad into a monad-transformer you get well known monad-transformers
18:48:20 * hackagebot range-space 0.1.0.0 - A Range type with vector-space instances  http://hackage.haskell.org/package/range-space-0.1.0.0 (JohnLato)
18:48:34 <mm_freak> i think i have never bothered to prove any monad /transformer/ laws
18:48:37 <benmachine> Cale: I think you underestimate the motivating power of rep as ego-inflation :P
18:48:47 <mm_freak> despite having implemented loads and loads of them
18:49:16 <edwardk> given a comonad w, you get a monad: Co w a = Co { runCo :: forall r. w (a -> r) -> r }
18:49:28 <edwardk> if you take Store s for w you get a monad that is a state monad, etc.
18:50:23 <mm_freak> interesting, but that isn't a transformer
18:50:35 <edwardk> you're right
18:50:49 <edwardk> just showing you how to get intuition for the individual comonads from their monadic analogues
18:51:27 <mm_freak> i have no problem with comonads…  my problem is with /implementing/ comonad /transformers/…  it's not even about using them, but really about implementing them =)
18:51:30 <edwardk> basically a monad transformer should give two monad homomorphisms, one from the underlying monad @m@ you're transforming, and for, say @StateT s@  one from @State s@
18:51:55 <maukd> oh god, comonads are monads all over again
18:52:07 <avpx> Hah.
18:52:20 <edwardk> with comonad transformers the situation is dualized. you need two comonad homomorphisms, one to the underlying comonad, and one to the 'simple' version of the transformer.
18:52:36 <edwardk> maukd: =)
18:52:54 <avpx> That makes sense
18:53:02 <maukd> just a bunch of flimsy arbitrary type signatures
18:53:13 <edwardk> writing comonad-transformers was almost as hard as writing monad-ran, just because i had no guidance for what should distribute over what how
18:53:16 <mm_freak> edwardk: ok, that's actually helpful
18:54:14 <edwardk> i need to go through and write an optimized version of monad-ran with what parts of it actually work, and use it to sell right kan extensions harder
18:54:20 <maukd> .oO( "what is a ran?" )
18:54:24 <mm_freak> edwardk: is there a nontrivial comonad transformer, for which 'extend' can be implemented without using the underlying comonad's 'extend'?
18:54:39 <ivanm> @wn ran
18:54:39 <lambdabot> No match for "ran".
18:54:58 <maukd> a miserable little pile of secrets
18:54:59 <edwardk> showing that every monad (and monad-transformer) in haskell that you use can be converted to right kan-extension (transformer) was an eye opener for me
18:55:08 <edwardk> ivanm: right kan extension
18:55:19 <ivanm> edwardk: yeah, I guessed that
18:55:19 <edwardk> mm_freak: no
18:55:30 <ivanm> I was just trying to see if wn could come up with an answer to make maukd happy :p
18:55:49 <maukd> extremely unlikely
18:56:03 <edwardk> mm_freak: actually, there is
18:56:36 <edwardk> mm_freak: https://github.com/ekmett/kan-extensions/blob/master/src/Control/Comonad/Density.hs#L36
18:56:49 <edwardk> Density is a comonad transformer and extend doesn't use the inderlying extend
18:57:10 <edwardk> data Density k a where  Density :: (k b -> a) -> k b -> Density k a
18:57:48 <edwardk> it should look a lot like Store ;)
18:57:51 <mm_freak> Density looks like Store to me
18:57:56 <edwardk> yep
18:58:00 <scshunt> hah
18:58:03 <edwardk> but note the existential b
18:58:23 <mm_freak> ah, indeed
18:58:24 <edwardk> Density was a candidate for what StoreT should be
18:58:31 <edwardk> well without the existential
18:58:41 <edwardk> but turns out that that doesn't give you the laws you want a Store to have
18:59:19 <edwardk> there is a comonad i call 'Discont' that is that without the existential
18:59:36 <edwardk> data Discont r k a = Discont (k r -> a) (k r)
18:59:47 <edwardk> that is a legal comonad transformer as well
18:59:54 <edwardk> but its not very useful, compared to cont
19:00:37 <mm_freak> that one looks like a weird StoreT
19:00:42 <edwardk> that has to do with the way cont 'twists' between Hask and Hask^op, because (_ -> r) is contravariant and so is self dual
19:00:47 <edwardk> yep
19:00:53 <edwardk> but it doesn't have the laws you want for Stores
19:01:09 <mm_freak> yeah, the 'k r' argument seems to mess things up
19:01:16 <edwardk> er not self dual, self adjoint
19:01:46 <edwardk> (and because (_ -> r) is adjoint to itself, cont is self dual)
19:02:23 <mm_freak> why did you name it "discont"?
19:02:28 <edwardk> the comonad you get by composing the adjunction (_ -> r) -| (_ -> r) is a comonad in hask^op, which is just Cont when you pull it back to Hask
19:02:51 <edwardk> because if you take Cont as the right kan extension of a constant functor, then Discont is the left kan extension of a constant functor
19:03:32 <edwardk> and Continuation/Discontinuation ;)
19:03:32 <edwardk> i tried to come up with a nice use for discont for months off and on
19:03:36 <mm_freak> is there also a Cocont?  or perhaps Nt?
19:03:46 <edwardk> Cocont = Cont
19:03:55 <mm_freak> ah, of course
19:04:01 <edwardk> well, 'Co' is a bad word to use to flip a monad to a comonad
19:04:07 <edwardk> becauseyou just compose the adjunction the other way
19:04:09 <edwardk> that isn't dual
19:04:17 <maukd> why is =>> not primitive? and why is extend not called <<= ?
19:04:29 <edwardk> maukd: because it is just awful to program with
19:04:46 <edwardk> maukd: i actually tried writing them all that way once
19:04:56 <putty> @pl \a b -> filter (==a) b
19:04:56 <lambdabot> filter . (==)
19:05:05 <edwardk> maukd: but you almost always wind up applying extend point free inside of the code for a comonad or a comonad-transformer
19:05:17 <maukd> ah
19:05:19 <mm_freak> it's categorically proven that every nut is a coconut
19:05:39 <edwardk> also >>= is a pretty dumb encoding of bind from a categorical perspective
19:05:39 <maukd> that boy needs therapy
19:06:07 <avpx> Why didn't we just use fmap/join/return?
19:06:10 <edwardk> (=<<) :: Monad m => (a ~> m b) -> (m a ~> m b)   takes an arrow in the kleisli category of m and gives you one in the base category.
19:06:19 <mm_freak> avpx: because we want to program with monads
19:06:44 <edwardk> avpx; because it takes 1 fewer definition, and we're programming so we almost always use join fused with fmap
19:07:18 <mm_freak> avpx: just consider how often you use (>>=) and how seldomly you use 'join'
19:07:22 <lewis1711> I am trying to do a list function that does something like "If any two elements are identical, fold them together, else do nothing". from list -> list
19:07:27 <maukd> try desugaring do notation into join/fmap
19:07:39 <mm_freak> lewis1711: map head . group?
19:07:40 <edwardk> but (>>=) has no such intuition. when you go to explain how to dualize (>>=) you get muddled in how exponentials work in the category, the strength of every functor in hask, etc.
19:07:43 <avpx> mm_freak: Yes, but it also strikes me that >>= could be in Control.Monad and return/fmap/join in Prelude
19:07:56 <mm_freak> > (map head . group) "abdddcggssakkk"
19:07:58 <avpx> And in the instances for Functor and Monad
19:07:58 <lambdabot>   "abdcgsak"
19:08:03 <latro`a> how can >>= have different intuition than =<<
19:08:15 <latro`a> they're the same thing, the parens just go the other way
19:08:38 <edwardk> latro`a: the second -> i mentioned gets 'split' across the (a -> m b)
19:08:48 <edwardk> the usual rule for dualizing something is 'flip all the arrows'
19:08:53 <mm_freak> avpx: that's a different question
19:08:56 <edwardk> what arrows do i flip in m a -> (a -> m b) -> m b
19:09:00 <edwardk> ?
19:09:02 <maukd> hidden generalizations lurk here
19:09:04 <latro`a> eh, I guess I see what you mean
19:09:28 <latro`a> of course, you flip the first and then the new second
19:09:29 <latro`a> :p
19:09:33 <maukd> edwardk: all of them?
19:09:34 <latro`a> (more or less)
19:09:47 <latro`a> actually, all of them, yeah
19:09:47 <maukd> m a <- (a <- m b) <- m b
19:09:50 <edwardk> maukd: nope, because the arrows in (=<<) aren't all 'created equal.
19:10:07 <latro`a> problem is you also have to flip associativity
19:10:10 <latro`a> which you don't with =<<
19:10:27 <maukd> and then you go through the looking glass and get: b m -> (b m -> a) -> a m
19:10:28 <edwardk> (=<<) :: (a ~> m b) -> (m a ~> m b) -- the first is the arrow in the kleisli category the last is the result of binding.
19:10:34 <carter_> MostAwesomeDude edwardk wheres this 0.9 version of trifecta... I don't see it
19:10:40 <edwardk> carter_: on github
19:10:47 <edwardk> carter_: its not on hackage yet
19:10:54 <edwardk> i want to add more functionality to it before i ship it
19:11:07 <edwardk> i'll happily take patches that port more of the 0.53 code to 0.90
19:11:11 <carter_> edwardk: ohhh, i misread the .cabal version
19:11:11 <carter_> :)
19:11:25 <maukd> .oO( destructor classes )
19:11:31 <carter_> and that is why I know i'm hardcapped at 40 hours of clever thought a week
19:11:47 <latro`a> ...kind of a silly question, but how does pattern matching with GADTs work
19:11:48 <edwardk> i'm hard capped at around 20, so you're doing better than me ;)
19:11:50 <latro`a> (randomish)
19:11:51 <carter> edwardk whats new in 0.9
19:11:54 <carter> ?
19:12:00 <maukd> latro`a: the usual way
19:12:05 <putty> @pl \a b -> head $ filter (==a) b
19:12:05 <lambdabot> (head .) . filter . (==)
19:12:10 <carter> edwardk: yes,  but you make keyboards click for  a larger fraction of that time!
19:12:10 <latro`a> even if the input to the constructor is type constrained?
19:12:12 <edwardk> 0.90 switches to using 'parsers' for everything, and greatly streamlines the API
19:12:18 <latro`a> like
19:12:25 <MostAwesomeDude> carter: The API's way smaller on the surface.
19:12:36 <edwardk> no most of my keyboard clicking comes later while i drone on implementing ;)
19:12:38 <carter> MostAwesomeDude: so i should git clone and do a local haddock build
19:12:40 <maukd> latro`a: then your variables have constrained types
19:12:44 <carter> ahhh
19:12:45 <carter> ok
19:12:47 <carter> good point
19:12:48 <MostAwesomeDude> Now you write stuff with parsers, and then you never actually mention trifecta except at the top of your actual parsing worker.
19:12:52 <edwardk> i think it shrank from ~70 modules to ~12
19:13:03 <MostAwesomeDude> carter: Go for it. It Haddocks fine.
19:13:04 <carter> i'm tired enough that i'm forgetting that I plan hard afore I code
19:13:07 <carter> cool
19:13:08 <MostAwesomeDude> I'll post patches when I get home.
19:13:45 <edwardk> i should also ship attoparsec-parsers and parsec-parsers some time
19:13:54 <edwardk> so you can have the flexibility of using them instead of trifecta
19:14:12 <carter> edwardk: are those backed by trifecta too?
19:14:13 <carter> or
19:14:55 <carter> nomenclature late at night always gets me confusing myself
19:16:08 <edwardk> carter: by parsers
19:16:29 <carter> edwardk: oh yeah, \
19:16:29 <edwardk> 'parsers' is a suite of combinators that work for parsers and let you apply monad transformers to parsers
19:16:33 <carter> ok
19:16:42 <edwardk> so you can work in StateT m (Parsec …)  if you want to
19:16:44 <carter> then what does trifecta let you do relativel to that
19:16:54 <carter> relative to that
19:16:56 <edwardk> trifecta gives you all the sexy error reporting, highlighting, etc.
19:17:04 <edwardk> parsers factors out the common core combinators
19:17:18 <carter> ok
19:17:18 <edwardk> and lets you write code in a parser-framework agnostic fashion for the most part
19:17:22 <carter> i'm out of date then
19:17:26 <edwardk> also trifecta gives you cheap slicing, and some other things
19:17:33 <edwardk> well, 0.90 isn't shipped yet
19:17:39 <edwardk> so you aren't _that_ out of date ;)
19:17:46 <carter> so parsers is a "front end"
19:17:53 <carter> to different parser combinator backends
19:17:57 <carter> one of which is trifecta?
19:18:33 <MostAwesomeDude> Yeah.
19:18:37 <carter> ok
19:18:38 <carter> cool
19:18:41 <carter> that makes sense
19:18:48 <carter> even for my late even beaddled brain
19:19:12 <carter> solo biz building sucks all the ability to think / do in the evenings out of ya
19:19:13 <carter> :)
19:19:20 <carter> cool
19:19:33 <carter> i'm installing the dependences so that cabal will let me run the cabal haddock command
19:19:52 <carter> late night cabal logic
19:20:31 <edwardk> carter: yep
19:20:51 <carter> everybody wins!
19:20:52 <edwardk> also the dependency set shrank a great deal in trifecta 0.90
19:21:13 <edwardk> i factored the charsets back into 'charset' where they came from, etc.
19:21:28 <edwardk> now, i did piss away some performance in the conversion
19:21:30 <carter> i noticed
19:21:35 <carter> oh?
19:21:36 <edwardk> but i don't think you'll notice too much
19:21:40 <carter> which conversion?
19:21:45 <edwardk> to 0.90
19:21:54 <carter> yeah, its not using every other category extras package :)
19:22:00 <carter> which performance goes down?
19:22:13 <edwardk> parsers was basically a slightly dumbed down version of the trifecta api, in that it doesn't make assumptions about utf-8 encoding, etc.
19:22:29 <edwardk> so the benefits i could get in trifecta when i knew the line contained only low ascii characters, etc. are gone
19:22:37 <edwardk> but they really really complicated the code for the prim parser
19:22:40 <carter> ok, bear in mind i'm not super familiar with trifecta generally
19:22:44 <carter> ok
19:22:45 <edwardk> so much so that no other prim parsers got written
19:22:46 <carter> that makes sese
19:23:04 <carter> and decided it didn't really make sense engineering wise?
19:23:13 <edwardk> so i'd rather actually have something i might finish than something ridiculously optimized that i'll never finish
19:35:10 <benmachine> I have never submitted anything to reddit before
19:35:19 <benmachine> is it standard practice to submit things you wrote?
19:35:42 <benmachine> if so should I go to particular effort to make it clear I wrote it
19:35:52 <benmachine> actually that's not a big deal, my name is in the title in giant letters
19:37:47 <ParahSailin_> ill upvote it
19:38:12 <edwardk> just post. i post links to my own posts about half the time, half the time other people do
19:38:29 <edwardk> there isn't much etiquette about it
19:38:40 <syntaxfree> reddit? it's a crowd nowadays.
19:38:47 <edwardk> if you wrote it, it makes sense to reap the karma ;)
19:39:04 <syntaxfree> the "reddiquette" is like a 1930s etiquette manual.
19:39:22 <syntaxfree> worth reading it for the general gist, but the specifics have long drifted since.
19:39:48 <syntaxfree> actually, 'twas #haskell that introduced me to reddit.
19:39:48 <johnw> yes!  I got Hoogle to work fully locally!!
19:39:55 <syntaxfree> that deep the rabbit hole goes.
19:39:59 <johnw> i need to blog about this, to capture the knowledge
19:51:47 <Lutin`> syntaxfree: Twas reddit that introduced me to #haskell!
19:52:15 <syntaxfree> I have to say, that's vastly more common.
19:52:30 <Lutin`> I'm sure
19:55:07 <gtmanfred> which bot does the pastes from hpaste.org?
19:55:48 <hpaste> Lutin pasted “This Bot” at http://hpaste.org/74276
19:58:22 * hackagebot range-space 0.1.0.1 - A Range type with vector-space instances  http://hackage.haskell.org/package/range-space-0.1.0.1 (JohnLato)
20:02:18 <startling> hehe
20:11:25 <johnw> Blogged: http://newartisans.com/2012/09/running-a-fully-local-hoogle/
20:11:36 <johnw> only too two weeks to figure all that out
20:11:38 <johnw> s/too/took
20:29:24 <pharaun> heh
20:29:29 <pharaun> i might have to try that out :)
20:31:18 <syntaxfree> do you know about anything being in the works re: a Sublime Text build mode for the Haskell Platform?
20:32:33 <syntaxfree> (the syntax coloring could use some works too, but I'm already writing syntax coloring for Stata
20:32:35 <syntaxfree> )
20:43:40 <syntaxfree> ahh. in a blah-ish note, I finally got my new custom macbook. it arrived to the wrong address (not to apple`s fault) and I had to wait three weeks more.
20:44:22 <syntaxfree> went from a core duo with 2GB RAM and a tiny hard drive to a core i7 with 8gb ram and a 128gb SSD.
20:44:54 <syntaxfree> plus my keyboard was bunk and the touchpad was semi-broken for years now. (Spilled coke...)
20:45:09 <johnw> big upgrade
20:45:15 <syntaxfree> many years.
20:45:57 <syntaxfree> I've got a kinesis advantage coming by mail. I won't make the mistake of overexerting the built-in keyboard again.
20:46:22 <johnw> heh
20:46:35 <syntaxfree> not to mention overexerting my frakking hands.
20:46:52 <syntaxfree> switched to a trackball at work about a month ago. left wrist pain is gone.
20:47:26 <Ralith> is there any actual evidence that kineses keyboards help
20:47:35 <syntaxfree> I wore a rubber support for a couple of weeks but anyway.
20:47:37 <liyang> syntaxfree: you're left-handed I guess?
20:47:46 <Nafai> johnw: I submitted it to reddit :)
20:47:51 <syntaxfree> who knows. learning something like that is good for neuroplasticity anyway.
20:58:17 <randomclown> so why would anyone use kinds in haskell
20:59:48 <amosr> what do you mean? they're a fundamental part of the type system, aren't they?
21:00:16 <startling> yes
21:00:39 <randomclown> what are they used for?
21:00:45 <startling> randomclown: when you do data Wraps a = Wraps a, you make a thing with kind * -> *
21:01:07 <startling> randomclown: because it has one free type
21:01:38 <startling> randomclown: kinds are basically a mini type system for types
21:02:06 <randomclown> startling: why would one ever need to write them?
21:02:14 <startling> randomclown: you don't
21:02:33 <randomclown> what's the point of the KindSignatures extension then?
21:02:37 <amosr> only for really crazy functions, like
21:02:42 <startling> randomclown: kinds are "*" or "* -> *" or "* -> * -> *" or so on
21:02:50 <liyang> (except those times where you do need to write them.)
21:03:00 <startling> when do you need to write them?
21:04:38 <amosr> I thought you needed to write them for classes with higher kinds?
21:04:38 <dolio> One situation is when you have 'data I f = I Int'.
21:04:47 <dolio> That will infer as f :: *, but you may want some other kind.
21:08:23 * hackagebot system-filepath 0.4.7 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.7 (JohnMillikin)
21:14:08 <nkpart> It'd be cool if hackagebot included a link to hdiff: http://hdiff.luite.com/cgit/system-filepath/commit?id=0.4.7
21:21:47 <copumpkin> :t cont . flip all
21:21:48 <lambdabot> forall a. [a] -> Cont Bool a
21:21:59 <copumpkin> :t all
21:22:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:22:31 * copumpkin found another random ski snippet
21:22:47 <copumpkin> > let forAll = cont . flip all; forAny = cont . flip any in evalCont $ do x <- forAll [6,10,15,55]; y <- forAny [2,3,5]; return (x `mod` y == 0)
21:22:48 <lambdabot>   Not in scope: `evalCont'
21:22:59 <copumpkin> > let forAll = cont . flip all; forAny = cont . flip any in runCont $ do x <- forAll [6,10,15,55]; y <- forAny [2,3,5]; return (x `mod` y == 0)
21:23:00 <lambdabot>   Overlapping instances for GHC.Show.Show
21:23:00 <lambdabot>                              ((GHC....
21:23:13 <copumpkin> :t let forAll = cont . flip all; forAny = cont . flip any in runCont $ do x <- forAll [6,10,15,55]; y <- forAny [2,3,5]; return (x `mod` y == 0)
21:23:14 <lambdabot> (Bool -> Bool) -> Bool
21:23:16 <sHACHAF> That's fancy.
21:23:26 <copumpkin> > let forAll = cont . flip all; forAny = cont . flip any in runCont (do x <- forAll [6,10,15,55]; y <- forAny [2,3,5]; return (x `mod` y == 0)) id
21:23:28 <lambdabot>   True
21:24:27 <copumpkin> yeah
21:24:54 <johnw> :t Data.Foldable.concat
21:24:55 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t [a] -> [a]
21:25:01 <johnw> why isn't that t [a] -> t a?
21:25:09 <johnw> :t Data.List.concat
21:25:10 <lambdabot> forall a. [[a]] -> [a]
21:25:15 <copumpkin> because Foldable doesn't give you that kind of power
21:25:42 <sHACHAF> Cont gives you too much power.
21:26:19 <sHACHAF> Cont lets you travel back in time and shoot your grandfather in the foot.
21:26:47 <startling> sHACHAF: calming down?
21:26:59 <johnw> what's the common way of doing that?  concat <$> ..?
21:27:15 <sHACHAF> startling: Usernames start with a lowercase letter. Everyone knows that.
21:27:29 <sHACHAF> johnw: concat <$> is a pretty common way...
21:27:29 <startling> sHACHAF: persuasive argument
21:27:38 <Nafai> I like going against the grain
21:27:47 <sHACHAF> @arr gument
21:27:47 <lambdabot> Avast!
21:27:55 <sully> Cont is what helped me understand the typing for delimited continuations
21:28:07 <sHACHAF> The typing?
21:28:31 <sully> like, how to type delimited continuations
21:28:43 <sHACHAF> You just did it twice.
21:28:49 <sully> har
21:29:15 <sHACHAF> How do you type delimited continuations?
21:29:25 <startling> sHACHAF: you start with the d
21:29:26 * sHACHAF suspects he doesn't properly understand delimited continuations.
21:29:50 <johnw> shachaf: how would you do a ++ b ++ c, if a, b and c were values in a monad?
21:29:58 <sully> so, the mtl Cont library doesn't actually have shift and reset provided
21:30:01 <johnw> a ++ b is easy enough: (++) <$> a <*> b
21:30:01 <sully> but you can define them
21:30:09 <sHACHAF> johnw: concat <$> sequence [a,b,c]?
21:30:12 <sully> (see http://okmij.org/ftp/continuations/ContExample.hs)
21:30:41 <dolio> Those are lame delimited continuations.
21:30:43 <johnw> ah, I was missing the sequence bit
21:30:44 <Twisol> Why is hGetSome defined in Data.ByteString but not Data.ByteString.Char8? It's like I have to choose between BS.pack and hGetSome.
21:30:47 <sHACHAF> Hmm, so shift and reset use the first argument to Cont.
21:30:50 <sully> the funny thing about typing delimited continuations is that you need to talk about the type of the "final result"
21:30:54 <johnw> of course, i had [t a], not t [a], thanks
21:31:04 <sHACHAF> Twisol: Because you shouldn't use pack
21:31:12 <dolio> The real types are: reset :: Cont a a -> a
21:31:22 <dolio> shift :: ((a -> r) -> r) -> Cont r a
21:31:36 <Twisol> sHACHAF: what other easy way is there to feed my program test data?
21:31:44 <sHACHAF> Twisol: encodeUTF8
21:32:07 <dolio> That way the types guarantee properties of the operators.
21:32:12 <dolio> Like, no control escapes reset.
21:32:21 <dolio> And similarly for the properties of shift.
21:32:26 <copumpkin> NONE SHALL PASS
21:32:29 <sHACHAF> Can you write those in Haskell?
21:32:35 <dolio> Yes.
21:32:35 <copumpkin> he did, in that file
21:32:39 <copumpkin> with different names
21:32:41 <copumpkin> runC
21:32:44 <dolio> @type runCont id
21:32:45 <lambdabot>     Couldn't match expected type `Cont r a'
21:32:45 <lambdabot>            against inferred type `a1 -> a1'
21:32:46 <lambdabot>     In the first argument of `runCont', namely `id'
21:32:47 <sHACHAF> Oh, yes.
21:32:52 <dolio> @type flip runCont id
21:32:53 <lambdabot> forall a. Cont a a -> a
21:32:55 <dolio> @type cont
21:32:56 <copumpkin> :t cont
21:32:56 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
21:32:57 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
21:33:01 <sully> do you lose anything doing it like that?
21:33:19 <sHACHAF> Hah, (`runCont` id) and (cont). Makes sense.
21:33:25 <dolio> Not really.
21:33:57 <dolio> The reset with Cont in the result type is just pure . reset
21:34:30 <Twisol> sHACHAF: (encodeUtf8 . T.pack) "test" ?
21:34:40 <sHACHAF> Twisol: For example.
21:34:52 <Twisol> That works, then. Thanks!
21:35:17 <dolio> And the difference between the shifts is more like whose obligation it is to enforce purity.
21:36:04 <dolio> You could also have ((a -> r) -> Cont r r) -> Cont r a, or something like that.
21:36:24 <Twisol> Is it a good idea to import a module qualified (like Text as T), but separately import the typenames unqualified? I don't like having to write T.Text.
21:36:45 <sHACHAF> Twisol: I've done that.
21:36:57 <startling> me too
21:37:01 <Twisol> Excellent
21:37:17 <Twisol> tbh wasn't sure it would even work
21:37:23 <startling> heh
21:53:28 <Twisol> Should I be overly worried about using libraries/features that aren't supported cross-compiler?
21:53:43 <copumpkin> no
21:56:06 <sHACHAF> "cross-compiler"? As in, both GHC 7.4 and GHC 7.0?
21:56:31 <startling> guessing he means ghc vs not-ghc
21:56:32 <gentleben> don't worry about it
21:56:41 <gentleben> just use GHC
21:56:42 <startling> Twisol: everyone uses ghc
21:56:46 <sHACHAF> startling: GHC vs. what?
21:56:56 <Twisol> Hugs, say
21:56:58 <Twisol> Okay.
21:57:10 <sHACHAF> Oh, hugs!
21:57:12 * sHACHAF hugs Twisol.
21:57:15 <Twisol> :P
21:57:49 <startling> sHACHAF: oranges
21:57:51 <startling> sHACHAF: chairs
21:58:16 <gentleben> whats hugs
21:59:23 <mapreduce> @google hugs
21:59:24 <lambdabot> http://www.hugslove.org/
21:59:25 <lambdabot> Title: HUGS Hawaii - Welcome TO HUGS! - Home Page
21:59:57 <mapreduce> damn it, I tried with my google profile and in incognito and got 'our' hugs as the top result in both.
22:00:02 <startling> @hugs google
22:00:02 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
22:00:15 <startling> o.o
22:01:12 <syntaxfree> google personalized search creeps me fuck out ever since I started to advise a young social media company on data mining.
22:01:37 <gentleben> i was joking…sort of
22:01:47 <syntaxfree> I started applying these textbook methods and getting epsilon-smart results.
22:02:10 <gentleben> my google actually has all hugs blocked so their old pages don't show up
22:02:20 <syntaxfree> I've since switched to DDG, installed Ghostery and blocked all cookies coming from Google in chrome.
22:02:36 <syntaxfree> DDG = DuckDuckGo
22:02:57 <syntaxfree> they still get to comb my mail from gmail, but I'm using Sparrow.
22:03:13 <syntaxfree> so no cross-linking between search and mail.
22:03:28 <syntaxfree> it's in cross-linking across categories of behavior that the real gold lays.
22:03:36 <syntaxfree> s/lays/lies
22:03:52 <gentleben> you know, i would love to see a worm distribute ad block plus
22:03:58 <startling> haha
22:04:07 <gentleben> google and facebook would collapse in one quarter
22:04:09 <syntaxfree> Ghostery also blocks those pesky "Like this" buttons.
22:04:13 <syntaxfree> they're all tracking elements.
22:04:44 <gentleben> that would jsut be funny
22:05:14 <syntaxfree> the only websites I allow are iftt.com, because it's so damn useful, and Klout, because I'm a vain idiot.
22:05:14 <gentleben> especially considering apple increased in value by 1/4 of a facebook today
22:05:26 <gentleben> klout haha
22:05:33 <startling> hahaha klout
22:05:56 <syntaxfree> I've dreamed of a reputation market since reading "Accelerando", a sci-fi novel.
22:05:56 <gentleben> so you are probably a klouchebag
22:06:15 <syntaxfree> Klout is a poor proxy, but what the hell, someone at least implemented something.
22:06:19 <startling> syntaxfree: charlie stross thinks klout is hilarious too. :)
22:06:27 <Kiba> hello
22:06:32 <Kiba> anyone on archlinux?
22:06:34 <syntaxfree> I know. And dangerous as in data-collecting.
22:06:38 <gentleben> yup spagetti at the wall
22:06:38 <Kiba> I installed pandoc with cabal-install
22:06:44 <Kiba> but I can't find the command pandoc
22:06:47 <gentleben> and what happened?
22:06:57 <startling> Kiba: you need to add cabal's directory to your PATH
22:07:04 <syntaxfree> Stross basically thinks most of the really cool tech in Accelerando is laughable.
22:07:17 <startling> Kiba: ~/.cabal/bin
22:07:18 <syntaxfree> the singularity and uploads a pipe dream slash nightmare, etc.
22:07:34 <syntaxfree> it was cool to follow him on the preparations from the London jockfest though.
22:07:44 <startling> olympics?
22:07:50 <Kiba> startling: thank you
22:08:13 <gentleben> i owned all the empty olympic seats
22:08:18 <syntaxfree> chess is historically considered a sport. poker in some circles. no chess or poker in the jockfest, it's no olympics.
22:08:51 <gentleben> poker is THE sport in some circles...
22:09:08 <Kiba> it's a sport in term that your heart rate goes up and your pupil dilate
22:09:32 <syntaxfree> I read and reread Accelerando like some S&M pipe-dreamers read 0x32 shades of grey. It's the ultimate in escapism.
22:09:54 <syntaxfree> No elfs, no orcs, no winter coming. It's all plausible, all an escape of reality that could be reality.
22:09:58 <gentleben> shades of grey is for girls
22:10:12 <gentleben> its my screening question right now
22:10:16 <dibblego> hey guys, want to take it to #haskell-blah please?
22:10:21 <syntaxfree> all epsilon-close to how we live, but not there.
22:10:35 <syntaxfree> sure. #haskell was dormant. when the main channel is dormant -blah goes into a comma
22:10:41 <syntaxfree> or a coma.
22:10:47 <Twisol> ,,,!
22:12:01 <gentleben> conversation killer
22:12:01 <amosr> is there a #haskell.au-blah too?
22:12:58 <amosr> anyone know much about DPH, by any chance?
22:13:20 <gentleben> i am a monad-par user myself
22:13:22 <mendez> amosr: it's good for alergies
22:13:54 <mendez> hyuk hyuk hyuk
22:14:49 <startling> what is the DPH amosr meant?
22:15:19 <syntaxfree> @google dph
22:15:20 <lambdabot> Plugin `search' failed with: getAddrInfo: does not exist (Name or service not known)
22:15:26 <gentleben> Data Parallel Haskell
22:15:31 * Kiba should become a real haskell user
22:15:36 <syntaxfree> now you know. and knowing is half the battle.
22:15:44 <gentleben> yes, yes you should
22:15:48 <Kiba> I don't even use haskell! I came here because I heard pandoc is really good
22:15:57 <Kiba> and I need to install it, and I did
22:16:01 <syntaxfree> I'm considering Clojure/Incanter and Haskell to replace Matlab/Octave for production code.
22:16:14 <Kiba> and xmonad uses haskell!
22:16:21 <gentleben> why Clojure?
22:16:32 <gentleben> not judging just curious
22:16:47 <gentleben> i am at a mostly haskell shop
22:17:17 <syntaxfree> Parenthetical syntax, macros and JVM. Plus Incanter wraps around a lot of numerical stuff.
22:17:36 <gentleben> is the JVM #1?
22:18:00 <syntaxfree> I basically need to work with sparse matrices for SVD and such.
22:18:09 <gentleben> I used to write tons of scala for hive/hadood
22:18:13 <syntaxfree> Ease of transition from Matlab being #1.
22:18:15 <arbn> Kiba: XMonad and Pandoc were the gateway drugs for me, long ago... and I was just recently offered a full-time, long-term job as a Haskell developer, and am reading about category theory in my free time. It's a very slippery slope. :P
22:18:17 <gentleben> ah, no c++?
22:18:34 <syntaxfree> Incanter transparently implements matrix stuff.
22:18:43 <gentleben> arbn: so you are really joining the cult
22:18:54 <arbn> gentleben: Apparently.
22:19:00 <syntaxfree> I bought numerical recipes, but just gaussian elimination on paper and pencil makes my head spin.
22:19:21 <syntaxfree> I forgot all the low-level stuff.
22:19:38 <gentleben> syntaxfree: interesting. we have not done tons in haskell. mostly link in c/c++ for that kind of thing
22:20:10 <syntaxfree> I mean, "Numerical recipes", formerly "Numerical recipes in C++". You know, the big heavy book, passes for a bible if pressed.
22:20:46 <gentleben> yeah, i know. i like avoid writing those when possible
22:21:00 <syntaxfree> I know about LAPACK and stuff, but life is so short.
22:21:24 <Twisol> I wonder if Haskell is the new Python Paradox. http://paulgraham.com/pypar.html
22:21:52 <arbn> Twisol: I honestly suspect that it is. It's fairly difficult to find a really stupid developer who is good with Haskell.
22:22:11 <Twisol> *nodnod*
22:22:27 <syntaxfree> running Matlab code in Octave was being good enough, even as I had to rewrite some libraries to rid them of object orientation. But scale kills, and there was some table crossing that should be done in SQL but my startup partners are doing code + marketing + capital raising + witchcraft rituals to make this thing work.
22:22:29 <Kiba> stupid? there's no such as stupid! Just incurious
22:22:39 <gentleben> Twisol: absolutely not
22:22:50 <Kiba> well, maybe if you're really really retarded
22:22:55 <syntaxfree> thankfully I have a 2% stake on the company and spend little time actually coding. So far -- Matlab basically flows off your head.
22:23:16 <gentleben> there are tons of retarded python devs
22:23:22 <gentleben> i know lots of them
22:23:30 <Kiba> why they retarded?
22:23:44 <syntaxfree> yeah. the folks are php debs, looking forward to "upgrade" to python.
22:23:56 <gentleben> have you seen a web server process 10 requests per second
22:24:00 <Twisol> gentleben: That essay was written in 2004. That's 8 years ago
22:24:04 <gentleben> they have as well
22:24:05 <arbn> gentleben: That's true of Python *now*. There was a time when that was less common, however.
22:24:09 <syntaxfree> I arrived really late in the game, dudes realized they needed someone who knew maths to make their social network stuff do something nontrivial.
22:24:10 <startling> gentleben: heh
22:24:18 <Kiba> php?
22:24:38 <gentleben> acutaly i use python for scripting
22:25:17 <Kiba> I used ruby
22:25:22 <syntaxfree> I've seen one of them set up A/B testing in PHP in front of my eyes, typing really fast on that fashionable mac editor for web editing.
22:25:33 <Kiba> textmate?
22:25:38 <arbn> I would use Python long before I would touch Java or C#. The reference semantics of the latter two languages really bug me. Mutability everywhere!
22:25:40 <Kiba> it's finally open source, wee!
22:25:57 <syntaxfree> Python's defaults bug the hell out of me.
22:25:58 <copumpkin> this channel seems to have gone astray
22:25:58 <Twisol> Sublime Text 2 ftw
22:26:05 <johnw> can I make a cabal test dependent on an executable I'm building?
22:26:06 <mapreduce> How is Python stronger on mutability?
22:26:06 <syntaxfree> Sublime Text2 ftw [2]
22:26:13 <copumpkin> seriously
22:26:14 <johnw> i want the test to run the executable so I can compare the output
22:26:14 <mapreduce> [than Java or C#]
22:26:18 <copumpkin> can we bring this back to haskell?
22:26:20 <gentleben> i wrote los of c#. don't compare it to java, i had to write that as well
22:26:30 <Lutin`> I'm with copumpkin
22:26:33 <copumpkin> gentleben, Kiba, syntaxfree, etc.
22:26:40 <syntaxfree> sure.
22:26:43 <arbn> copumpkin: Fair enough. Sorry for the diversion.
22:26:44 <copumpkin> thanks!
22:26:50 <syntaxfree> just following the flow. sorry.
22:27:14 <copumpkin> nobody's fault, just wanted to bring things back a bit :)
22:27:26 <copumpkin> I think some actual haskelly stuff was getting lost
22:27:37 <Lutin`> Though to not come back too quickly
22:27:38 <gentleben> coming back to haskell, Instruments was clutch today. hunted down some leaks
22:27:51 <Lutin`> I've been struggling to decide on my editor of choice
22:27:58 <Lutin`> Sublime or vim
22:28:06 <gentleben> are people interested in how to hunt leaks or no?
22:28:15 <Lutin`> I love vim's capability but the learning curve is daunting
22:28:32 <Twisol> Lutin`: #haskell-blah?
22:28:36 <arbn> Lutin`: Emacs. :P
22:28:48 <arbn> Lutin`: Seriously, though, that's not an answerable question.
22:29:07 <Lutin`> I haven't asked a question yet
22:29:31 <srhb> Lutin`: I'm with the conservatives, you should learn vi no matter what - take the opportunity. Same goes for Emacs.
22:29:47 <rking> Lutin`: I don't know if I agree. I got better in vim than in Notepad-like editors in a matter of hours. I got better than my (fairly practiced) Emacs skills in a matter of a week or two. Then from there it's just a continual climb up and up. Almost every day I :help and "wow".
22:29:50 <gentleben> OH at Haskell event: See EMACS is based on lambda calculus. So its better than VIM
22:30:03 <gentleben> it was like a bomb went off
22:30:16 <Twisol> Rofl.
22:30:27 <startling> vim is kind of shitty in that regard
22:30:32 <startling> vimscript is pretty bad
22:30:35 <copumpkin> seriously
22:30:44 <copumpkin> editor discussion really isn't the topic of this channel
22:30:47 <copumpkin> #haskell-blah
22:30:49 <copumpkin> or somewhere else
22:31:06 <copumpkin> 900 people come here for haskell, type systems, abstract math, and so on :)
22:31:17 <sHACHAF> How 'bout them delimited continuations, copumpkin?
22:31:18 <Lutin`> I'm there already :P
22:31:24 <copumpkin> okay, then talk about it in there
22:31:36 <copumpkin> =)
22:31:37 <sHACHAF> What's the different between "one-shot continuations" and "coroutines"?
22:31:53 <copumpkin> sHACHAF: the difference is that vim >>>> emacs
22:31:54 <copumpkin> duh
22:32:02 <copumpkin> coroutines are like vim
22:32:07 <copumpkin> continuations are emacs
22:32:33 * copumpkin shuts up
22:32:35 <gentleben> i might conjecture that the 900 people here primarily come here to talk to people of comperable intellect. But I am
22:32:39 <Twisol> :P
22:32:41 <startling> @hoogle (>>>>)
22:32:41 <lambdabot> No results found
22:32:41 <gentleben> going to bed
22:32:45 <Twisol> Night.
22:32:46 <startling> :/
22:33:04 <Twisol> Speaking of continuations, I saw a post about using them to implement a form of goto
22:33:08 <copumpkin> gentleben: that's what the offshoot channels are for :)
22:33:09 <Twisol> I wish i could find the link
22:33:13 <arbn> OK. Someone step up to plate and start talking about comonads or dependent type theory... :P
22:33:18 <copumpkin> okay
22:33:20 <startling> Twisol: was it in python?
22:33:22 <Twisol> but it actually reminded me more of longjmp and setjmp than goto, because it reverted to an earlier state
22:33:25 <copumpkin> so I want very dependent types
22:33:26 <Twisol> No, Haskell.
22:33:32 <startling> oh
22:33:38 <gentleben> only haskell
22:33:47 <startling> Twisol: someone used python's generators to do a goto
22:33:55 <Twisol> Nice.
22:33:56 <copumpkin> I think we should have a partial very dependent language
22:34:02 <copumpkin> so you don't have to worry about what other types you refer to
22:34:09 <copumpkin> what other values, I mean
22:34:12 <edwardk> gentleben: i joined the haskell channel because it was the largest group of smart people i could find on the internet. it helped that the language was nice, too
22:34:43 <Twisol> ^
22:34:54 <Saizan> copumpkin: "very" dependent?
22:34:56 <edwardk> that and i watched a stream of people come into the channel and everyone was so disarmingly helpful that it made me want to try to be a little bit more helpful myself
22:35:00 <sHACHAF> "#haskell largest group of smart people on internet, reports #haskell"
22:35:22 <copumpkin> Saizan: dolio was telling me about them recently
22:35:24 <edwardk> not enough that i actually write docs or anything, but still
22:35:42 <sHACHAF> edwardk: Hah.
22:35:43 <copumpkin> Saizan: basically, what's needed to be able to write sigma using a (very dependent) pi
22:35:46 <sHACHAF> That's going too far, eh?
22:35:57 <edwardk> yes, a man has to have standards
22:36:18 <dolio> Saizan: They're pis where the type of f (1+n) is able to depend on the value of f n, and such.
22:36:37 <edwardk> clearly it is more efficient for me to walk everyone in the channel through how comonads work one on one than it is for me to write a cogent and coherent tutorial
22:36:38 <gentleben> edwardk: even when i disagree with most haskell developers I usually respect their opinion. So i find the community to be great
22:36:49 <arbn> Actually, Wadler's recent work on casting between dependent and simple types is pretty interesting. Are there any languages using anything like the blame calculus?
22:37:31 <Twisol> edwardk: to be fair, there is something about one-on-one assistance lacking from general documentation
22:37:44 <edwardk> true enough
22:37:55 <mapreduce> Teach a man to fish and he'll write a tutorial about how fishing is like boxes.
22:38:01 <zzing> :t string
22:38:02 <lambdabot> Not in scope: `string'
22:39:31 <gentleben>  Twisol you just need a coworker who knows more about haskell than you
22:40:02 <Twisol> you mean the categorical dual of a worker?
22:40:06 <dolio> Saizan: I have no idea what the sigma analogue of that is, though, so it seems kind of ad-hoc.
22:40:18 <gentleben> of super smart worker
22:40:37 <Twisol> I don't really have a job; I'm a college student
22:40:42 <johnw> anyone know how to make an option required with CmdArgs?
22:40:48 <johnw> I found argRequire, but have no clue how to use it
22:42:00 <Saizan> dolio: sounds induction-recursy
22:42:22 <thirsteh> is there an easy/right way to do "zip" [["a","b","c"],["d","e","f"]] [1..] =-> [[(1,"a"), (2,"b"), (3,"c")],[(4,"d"), (5,"e"), (6,"f")]] ?
22:42:32 <srhb> johnw: Did you check its type?
22:42:45 <johnw> of argRequire?  yes, that didn't help me
22:42:57 <dibblego> thirsteh: check out functions concat and zip
22:43:01 <thirsteh> erh, ("a",1) etc.
22:43:14 <thirsteh> dibblego: I want to retain the groupings
22:43:29 <dibblego> oh ok, check out map and zip
22:43:42 <thirsteh> dibblego: but I want to use the same list of ints
22:43:52 <thirsteh> that's why I'm asking--the stuff i'm thinking of now is not so pretty
22:45:04 <Twisol> so this is insufficient? map (zip [1..]) [["a", "b", "c"], ["d", "e", "f"]]
22:45:12 <Saizan> yes
22:45:20 <thirsteh> I want to number each element of each sublist, not the sublists
22:45:33 <Saizan> sounds like a job for State [Int]
22:45:49 <Twisol> Well, that gives me this: [[(1,"a"),(2,"b"),(3,"c")],[(1,"d"),(2,"e"),(3,"f")]]
22:45:53 <Twisol> but it's not what you wanted anyways
22:46:00 <thirsteh> Twisol: correct, I want 1,2,3,4,5,6 across lists
22:46:08 <johnw> > map (map (1,)) [["a", "b", "c"], ["d", "e", "f"]]
22:46:09 <lambdabot>   Illegal tuple section: use -XTupleSections
22:46:24 <johnw> oh, never mind
22:47:01 <thirsteh> Saizan: maybe
22:47:20 <Lutin`> I'm thinking some sort of fold should be able to do it
22:47:46 <Saizan> ?type let next = do (x:xs) <- get; put xs; return x in mapM (mapM (\x -> (,x) <$> next))
22:47:47 <lambdabot> Illegal tuple section: use -XTupleSections
22:48:00 <Saizan> ?type let next = do (x:xs) <- get; put xs; return x in mapM (mapM (\x -> (\n -> (n,x)) <$> next))
22:48:01 <lambdabot> forall a a1 (m :: * -> *). (MonadState [a1] m, Functor m) => [[a]] -> m [[(a1, a)]]
22:48:43 <Saizan> ?type let next = do (x:xs) <- get; put xs; return x in evalState . mapM (mapM (\x -> (\n -> (n,x)) <$> next))
22:48:44 <lambdabot> forall a a1. [[a]] -> [a1] -> [[(a1, a)]]
22:48:57 <thirsteh> Lutin`: hmm yeah, I could keep track of the lengths of each list
22:50:12 <Saizan> > let next = do (x:xs) <- get; put xs; return x; f xs = evalState . mapM (mapM (\x -> (\n -> (n,x)) <$> next)) [1..] xs in f [words "a b c",words "d e f"]
22:50:13 <lambdabot>   <no location info>: parse error on input `='
22:50:23 <Lutin`> thirsteh: think mapAccum
22:50:37 <Saizan> > let next = do {(x:xs) <- get; put xs; return x}; f xs = evalState . mapM (mapM (\x -> (\n -> (n,x)) <$> next)) [1..] xs in f [words "a b c",words "d e f"]
22:50:38 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.State
22:50:38 <lambdabot>         ...
22:50:38 <thirsteh> Lutin`: yeah
22:50:42 <Lutin`> But you aren't relly accumulating
22:50:46 <Lutin`> You're removing
22:51:06 <Lutin`> So you map over the lists till you get a char
22:51:27 <Saizan> > let next = do {(x:xs) <- get; put xs; return x}; f xs = evalState (mapM (mapM (\x -> (\n -> (n,x)) <$> next)) xs) [1..] in f [words "a b c",words "d e f"]
22:51:28 <lambdabot>   [[(1,"a"),(2,"b"),(3,"c")],[(4,"d"),(5,"e"),(6,"f")]]
22:51:40 <thirsteh> hello :)
22:52:05 <thirsteh> Saizan: I understand some of those words, but thanks, I'll use this for now
22:52:30 <Saizan> thirsteh: look up the definitions of the others :)
22:53:09 <Saizan> btw, mapAccumL is the specialization of mapM to State
22:53:09 <thirsteh> Saizan: trust me, if you type "h" in my address bar, it immediately suggests haskell.org
22:53:15 <Lutin`> Saizan: Oh hey yeah I just saw that
22:53:19 <ion> edwardk: Is there a nice Control.Lens way to do what thirsteh was asking?
22:53:21 <mapreduce> > let f indexes sublists = if length sublists == 0 then [] else zip indexes (head sublists) : f (drop (length (head sublists)) indexes) (tail sublists) in f [1..] [["a", "b", "c"], ["d", "e", "f"]]
22:53:22 <lambdabot>   [[(1,"a"),(2,"b"),(3,"c")],[(4,"d"),(5,"e"),(6,"f")]]
22:53:38 <edwardk> ion: getting lenses to suggest haskell.org?
22:53:45 <thirsteh> edwardk: lol
22:53:49 <thirsteh> mapreduce: oh, that's nice
22:53:57 <thirsteh> edwardk: to do what mapreduce/Saizan just did
22:54:19 <mapreduce> and it worked first time, I'm shocked
22:54:33 <thirsteh> I get that a lot with Haskell. It's nice.
22:55:02 <edwardk> yes. lets see
22:55:23 <Saizan> i imagine with lenses the two mapM would become something like mapOf (traverse . traverse)
22:55:48 <johnw> > snd $ Prelude.foldl (\acc x -> (fst acc + length x, snd acc ++ [zip [fst acc..] x])) (1,[]) [[1,2,3], [4,5,6]]
22:55:50 <lambdabot>   [[(1,1),(2,2),(3,3)],[(4,4),(5,5),(6,6)]]
22:56:39 <edwardk> ghci> itoListOf (indexed (folded.folded)) [["a","b","c"],["d","e","f"]]     ==> [(0,"a"),(1,"b"),(2,"c"),(3,"d"),(4,"e"),(5,"f")]
22:56:45 <edwardk> off by one =)
22:56:56 <johnw> @hoogle itoListOf
22:56:57 <lambdabot> No results found
22:57:04 <edwardk> johnw: its in lens
22:57:11 <johnw> of course :)
22:57:15 <thirsteh> nice.
22:57:21 <ion> edwardk: How about zipping with an arbitrary list instead of [0..]?
22:57:26 <thirsteh> thanks guys
22:57:26 <Twisol> johnw's thing works for me if I replace the [1,2,3], [4,5,6] with ["a", "b", "c"], ["d", "e", "f"]
22:57:45 <edwardk> ion: thats a bit more awkward. you'd want to use 'partsOf' from Control.Lens.Plated to zip the lists
22:58:27 <mapreduce> edwardk: You lost the nested list structure in the result
22:58:35 <mapreduce> He wanted to keep that.
22:58:42 <edwardk> oh, i can fix that
23:01:19 <edwardk> ghci> imapOf (indexed (traverse.traverse)) (\i a -> (i + 1, a)) $ [["a","b","c"],["d","e","f"]]     ==> [[(1,"a"),(2,"b"),(3,"c")],[(4,"d"),(5,"e"),(6,"f")]]
23:01:27 <edwardk> er no need for the $
23:01:53 <thirsteh> I wonder what happens if I just keep waiting
23:02:03 <edwardk> thirsteh: usually the answers just keep getting shorter
23:02:13 <thirsteh> :D
23:02:14 <edwardk> then someone points out a function in the prelude that just does it
23:02:30 <edwardk> and we all hang our heads
23:02:40 <Lutin`> See here's my issue
23:02:51 <Lutin`> We should be able to find it out once
23:02:53 <Twisol> It's absolutely crazy that that's already so small. :O
23:02:58 <edwardk> heh
23:02:59 <Lutin`> And then auto shrink it
23:03:09 <ion> @type curry (first (+1))
23:03:10 <lambdabot> forall a b. (Num a) => a -> b -> (a, b)
23:03:20 <Lutin`> using some magical magic
23:03:37 <johnw> well, with the right Comonad instance it  wouldn't be hard either
23:03:42 <Lutin`> I'm not sure the algo, but it all comes down to rewriting
23:03:50 <edwardk> just set up an irc bot that when it sees a function that produces an answer it already has seen just emits the stuff its also already seen golfed on the channel that a.) produces the same output and b.) is shorter
23:04:26 <ion> Heh, that would be fun.
23:04:37 <edwardk> so if someone came in and wrote
23:04:38 <edwardk> > let z a b c d w@(x:y)=let t=a`div`c in if all(>0)[a,b,c,d]&&t==b`div`d then t:z(10*(a-c*t))(10*(b-d*t))c d w else z(x*a+b)a(x*c+d)c y;f n=1:1:n:f(n+2)in z 1 0 0 1(2:1:2:f 4)>>=show
23:04:39 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
23:04:53 <Lutin`> What if it was like
23:05:01 <edwardk> it can write
23:05:04 <edwardk> > (!!2)<$>transpose[show$sum$scanl div(10^2^n)[1..2^n]|n<-[0..]]
23:05:05 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
23:05:05 <Twisol> > const [[(1,"a"), (2,"b"), (3,"c")], [(4,"d"), (5,"e", (6,"f")]]
23:05:06 <lambdabot>   <no location info>: parse error on input `]'
23:05:23 <Twisol> > [[(1,"a"), (2,"b"), (3,"c")], [(4,"d"), (5,"e", (6,"f")]]
23:05:24 <edwardk> Twisol: this may limit its overall effectiveness, yes ;)
23:05:24 <lambdabot>   <no location info>: parse error on input `]'
23:05:36 <Twisol> edwardk: I seem to have mistyped, but you get my point ^_^;
23:05:50 <edwardk> @where e_11
23:05:50 <lambdabot> I know nothing about e_11.
23:05:51 <Lutin`> edwardk: I'm thinking something like use quickcheck to create input
23:05:52 <mapreduce> Missed the ) after e
23:05:53 <edwardk> @where pi_11
23:05:53 <lambdabot> [show(foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..4*2^n])!!n|n<-[0..]]
23:05:58 <johnw> is there a function that given two lists, uses the second list if the first is empty?
23:06:02 <Twisol> mapreduce: good eye!
23:06:04 <edwardk> @where pi_9
23:06:04 <lambdabot> I know nothing about pi_9.
23:06:19 <johnw> I have this: if null args then withArgs ["--help"] else withArgs args
23:06:37 <johnw> I'd like: withArgs $ eitherOr args ["--help"]
23:06:41 <mapreduce> @hoogle [a] -> [a] -> [a]
23:06:42 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
23:06:42 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
23:06:42 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
23:06:43 <ion> > uncurry(++).second tail.splitAt 1.showCReal 1000$exp 1
23:06:45 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
23:07:04 <edwardk> withArgs $ if null args then ["--help"] else args
23:07:09 <edwardk> gets you closer
23:07:11 <johnw> true
23:08:13 <ion> > (\(a:b:c)->a:c).showCReal 1000$exp 1
23:08:15 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
23:08:28 <edwardk> ion: its explicitly disallowed from using CReal ;)
23:08:40 <lpvb> I like ion's answer ;)
23:08:55 <edwardk> plus it needs to be a spigot
23:08:57 <ion> edwardk: I guess it would suffice to require the string to actually be infinite.
23:09:01 <edwardk> yeah
23:09:02 <Twisol> if mempty == left then right else left
23:09:27 <edwardk> the current answer basically just keeps doubling the number of digits it produces
23:09:48 <edwardk> and transposes and chooses the right answers out of the sequence to avoid rounding issues
23:11:09 <Twisol> johnw: head $ dropWhile null [[], ["--help"]]
23:11:22 <Twisol> let firstNonEmpty = head . dropWhile null
23:11:34 <ion> head for the lose.
23:11:53 <ion> listToMaybe . dropWhile null
23:12:16 <edwardk> the pi answer is using portions of the taylor series 4*atan 1 = 4 - 4/3 + 4/5 + 4/7 - …
23:12:24 <Twisol> ion: Didn't know about that function, thanks!
23:12:37 <johnw> Twisol: um, yuck?
23:12:38 <edwardk> sadly that converges pretty slowly
23:13:00 <Twisol> johnw: What?
23:13:15 <johnw> making a bigger list, and using dropWhile and head
23:13:28 <ion> edwardk: Thanks for the explanations of what the expressions do. Interesting.
23:13:36 <lpvb> chudnovsky pi in one line, go go go
23:15:52 <Twisol> johnw: well, I can't find anything generic but cleaner than the straight-up if-else-then
23:20:26 <johnw> i went with if null x then y else x
23:20:40 <Twisol> probably best
23:20:42 <johnw> thanks for looking!
23:20:55 <Nereid> what if we use pl and get something cool like
23:20:58 <johnw> and thank goodness for Debug.Trace
23:21:33 <Nereid> (not . null >>= if') x y
23:21:38 <Nereid> where if' b x y = if b then x else y
23:22:14 <johnw> yes, but then I'm losing readibility
23:22:20 <Nereid> but gaining cuteness
23:22:20 <johnw> like "what the heck is >>= if'?
23:22:58 <ivanm> @type (>>= if')
23:22:59 <lambdabot> Not in scope: `if''
23:23:01 <ivanm> bah
23:23:08 <johnw> anyone know how to write a cabal test that runs the main executable built by the same project?
23:23:12 <ion> if' is the evil twin sister of bool.
23:23:16 <ivanm> @type let if' p t f = if p then t else f in (>>= if')
23:23:17 <lambdabot> forall t. (t -> Bool) -> t -> t -> t
23:23:18 <Cale> johnw: you're familiar with do-notation in general?
23:23:31 <johnw> sure
23:23:32 <ivanm> johnw: don't think that's possible
23:23:36 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
23:23:37 <lambdabot>   ("hello","olleh","HELLO")
23:23:51 <ivanm> johnw: but you could import the Main module from the executable and call the main from there...
23:23:52 <ion> johnw: Using pattern matching is probably nicer than “if null …”
23:24:12 <Cale> johnw: So "running" a function in the function monad means applying it to the argument to the whole function.
23:24:35 <johnw> Cale: this is apropos of what exactly?
23:24:52 <Cale> johnw: and of course, x >>= f has its usual interpretation: first "run" x, and if its result is v, then "run" f v
23:25:05 <johnw> oh, I understand the syntax
23:25:14 <johnw> I just meant it creates a knot for others reading my code
23:25:19 <Cale> oh, sure
23:25:31 <Cale> I was just going to explain how that code actually worked :)
23:25:37 <johnw> ah, thank you!
23:25:50 <johnw> I'm getting quite comfortable with Monads now
23:26:06 <johnw> I'm using State in my code to avoid polluting it with IO
23:26:52 <Cale> So we apply not . null to x, and then apply if' to its result, and then we're "running" that, so we apply if' (not . null $ x) to x again
23:27:02 <Cale> and then apply that to y
23:27:28 <Cale> So we get if' (not (null x)) x y
23:27:29 <Nereid> @pl \x y -> if p x then x else y
23:27:29 <lambdabot> if' =<< p
23:27:31 <Nereid> :P
23:28:02 <Nereid> or, null >>= flip if'
23:28:07 <Nereid> er oops.
23:28:21 <Nereid> @pl \x y -> if p x then y else x
23:28:21 <lambdabot> flip =<< if' . p
23:28:24 <Nereid> heh.
23:28:57 <Nereid> a little more confusing.
23:35:59 <zzing> If I have a function that returns an m [Entity k v]  can I do something like this to retrieve the first item?        (Entity _ page):[_] <- runDB $ selectList [documentSlug ==. pageName] []
23:37:03 <nand`> that will only match a list that has two elements
23:38:08 <zzing> I just realized that I need to be able to detect an empty list or a list with one element, a list with more than one element would be exceptional
23:38:13 <BMeph> zzing: So close - try "(Entity _ page):_ <- runDB $ selectList [documentSlug ==. pageName] []".
23:38:48 <zzing> Oh I see why, thanks BMeph
23:38:50 * Kiba stays up all night to install haskell
23:39:10 * zzing tosses Kiba a monad and an arrow
23:39:32 <Kiba> I think it's about 2 or 3 AM here
23:39:51 <zzing> In that case..
23:39:57 * zzing tosses Kiba a comonad
23:40:12 <mapreduce> 3:40am here, don't worry.
23:40:25 <zzing> If were to say s <- runDB ….    and then I could use case with matching against [] and (Entity _ page):_  to check for 0 or 1+ items?
23:40:57 * BMeph nods in agreement
23:41:34 * zzing hands BMeph a category, and a super monadic arrowing applicative functor.
23:43:28 <zzing> Yesod is so addicting
23:45:12 * nand` throws a few kan extensions in the general direction of zzing
23:45:35 * zzing drinks Olde Fortran out of a Kleine bottle
23:49:32 <zzing> I think we need a beer called Applicative Functor with the lambda logo on the bottole
23:51:38 <mapreduce> Beer Goggles with real functional lenses.
23:53:38 <nand`> it's rumored to be the best beer in the world but so far nobody knows how to unscrew the cap, which has a very strange topology
23:56:04 * BMeph would like to see the brewery that makes Arrogant Bastard Ale put out a Stone-faced Git brew...
23:58:34 <mklinik> What do I do when cabal install <somepackage> gives me: "cabal: Couldn't read cabal file "iteratee/0.8.9.3/iteratee.cabal""
23:59:12 <johnw> some type errors still take me almost 45 mins to figure out
