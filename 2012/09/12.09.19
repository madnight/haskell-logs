00:00:57 <startling> edwardk: so if I do want a lens, I'm basically stuck using the function "lens"?
00:01:14 <edwardk> startling: i never use lens. i just write it by hand
00:01:26 <edwardk> _2 f (a,b) = (,) a <$> f b
00:01:35 <edwardk> both f (a,b) = (,) <$> f a <*> f b
00:01:37 <startling> that's a possibility
00:01:39 <edwardk> thats a lens and a traversa
00:01:41 <edwardk> er traversal
00:02:40 <edwardk> you can see the lens nature of the first by the fact that it uses <$>, not <*> and the parts it passes to f and the parts it puts back on after the fmap are disjoint and it puts them back in the right places
00:02:58 <startling> interesting
00:03:42 <edwardk> notice how much shorter that is than the equivalent code written using lens ;)
00:03:59 <startling> haha
00:04:55 <shachaf> edwardk: Does this do the share-work-between-getter-and-setter thing?
00:05:00 <edwardk> yep
00:05:32 <edwardk> when i realized that is when i dropped my objection to van laarhoven lenses
00:05:32 <startling> edwardk: so for "_2 f (a,b) = (,) a <$> f b", how does getting work? I can see how `over` and thus setting work, but I don't see getting.
00:05:58 <edwardk> view l = getConst . l Const
00:06:25 <edwardk> over l f = runIdentity . l (Identity . f)
00:08:19 <startling> why can't "over _2 fn" be "_2 fn" ?
00:08:41 <startling> and what's getConst?
00:08:52 <edwardk> data Const b a = Const { getConst :: b }
00:08:58 <edwardk> (newtype actually)
00:09:21 <startling> oh, is it an identity-ish functor?
00:09:30 <edwardk> (the actual view is slightly more complicated to support some corner cases like wanting backwards to work for folds)
00:09:33 <pharaun> nice feeling when i finish working on a big stack of pure code and plug it in and it start to crank out what seems to be the right result :)
00:09:34 * hackagebot acid-state 0.7.6 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.6 (DavidHimmelstrup)
00:09:36 * hackagebot safecopy 0.6.2 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.6.2 (DavidHimmelstrup)
00:09:43 <pharaun> still need to get testing/quickcheck going on this badboy
00:09:46 <edwardk> startling: almost the opposite. notice the b is the wrong argument. =)
00:09:54 <startling> edwardk: oh woah
00:10:03 <Trudko> Hi guys I hae th pleasure hopefully, to learn haskell. Can you recomend me some great tutorial on that? I found some on the Internet of course, but cant saz right awaz which are ok and which are great :)
00:10:12 <edwardk> startling: thats trivially a Functor.
00:10:20 <edwardk> it just ignores the phantom a.
00:10:21 <pharaun> Trudko: lyah and rwh
00:10:24 <startling> edwardk: fmap = id?
00:10:26 <startling> yeah
00:10:34 <startling> er well, id doesn't work I guess
00:10:39 <edwardk> startling: modulo the need to unwrap and rewrap it to make the type system happy
00:10:39 <pharaun> Trudko: there's also the spec i guess
00:10:40 <edwardk> yeah
00:10:52 <startling> Trudko: seconding lyah
00:10:54 <edwardk> i have a class i use for getters in lens
00:10:56 <startling> @where lyah
00:10:56 <lambdabot> http://www.learnyouahaskell.com/
00:11:04 <pharaun> @where rwh
00:11:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:11:11 <edwardk> class Functor f => Gettable f where coerce :: f a -> f b  -- subject to the condition that fmap f = coerce
00:11:23 <edwardk> and an instance Gettable Const
00:11:28 <Trudko> startling, pharaun you mean this ?! http://learnyouahaskell.com/
00:11:33 <startling> Trudko: yes
00:11:36 <edwardk> then a getter is kind of like a lens
00:11:49 <edwardk> type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
00:12:01 <Trudko> awesome btw I heard that haskell is sused outside of academia, is that true?
00:12:10 <startling> Trudko: yes
00:12:10 <edwardk> type Getter a b c d = forall f. Gettable f => (c -> f d) -> a -> f b
00:12:15 <edwardk> Trudko: yes
00:12:21 <pharaun> Trudko: yes
00:12:23 <startling> edwardk: you're losing me. :(
00:12:35 <pordan30> Trudko: http://www.haskell.org/haskellwiki/Haskell_in_industry
00:12:40 <Trudko> awesome
00:12:41 <edwardk> startling: the Gettable class is used only so i can get pretty error messages
00:12:51 <startling> edwardk: oh.
00:12:52 <edwardk> startling: so you can largely ignore it except for expert use of the library
00:13:06 <pharaun> Trudko: i mean it might not be as widespread as some of the say java jobs but on the other hand it *is* being used in the industry
00:13:07 <startling> mhm
00:13:13 <edwardk> it turns type errors for lens from huge unification errors down into pretty 'no instance for Gettable Mutator' messages
00:13:26 <edwardk> when you go to say, read from a Setter.
00:14:01 <startling> haha
00:14:27 <edwardk> i came up with the hack at hac phi
00:14:42 <edwardk> it really made the errors a lot less scary =)
00:15:31 <donri> one of these days lens is going to become self-aware
00:15:54 <Trudko> pharaun: ys of course, personally I hope it helps me to understand javascript more which afaik is functional language too and it more wide spread
00:15:56 <edwardk> shhh, don't tell it. you'll build up its ego
00:16:11 <mcstar> impossible,
00:16:18 <mcstar> :t self-aware
00:16:19 <lambdabot> Not in scope: `self'
00:16:19 <lambdabot> Not in scope: `aware'
00:16:24 <mcstar> doesnt typecheck ^^
00:16:58 <Trudko> eventhough javascript is inspired more by scheme as far as i know
00:17:28 <mcstar> i have a conjecture: it is impossible to write strong ai in a strongly typed language
00:17:36 <startling> edwardk, I'd hate to see what the errors looked like *before*
00:17:45 <edwardk> startling: =)
00:17:53 <startling> mcstar, not even python??
00:18:03 <pordan30> is there a good reason to use ml-style avl trees with balance factors of two over ordinary avl-trees with balance factors of one, e.g., the default haskell implementation?
00:18:11 <mcstar> python is ok, you can do it in that
00:18:15 <hirsch_> Morning, I'm searching a TH quasiquoter which creates a [String] from quasiquoted lines, anybody know it such a thing exists?
00:18:26 <startling> mcstar, but it's a strongly-type language!
00:18:28 <avpx> mcstar: I think the concept of strong/weak AI is misguided. Plus you can do not-typesafe things in Haskell.
00:18:48 <mcstar> nice, this flamethrower works...
00:18:53 <shachaf> edwardk: That's a funny hack.
00:18:58 <avpx> mcstar: I knew it.
00:19:06 <mcstar> :)
00:19:21 <edwardk> once unification succeeds the type error messages become much more civilized
00:19:39 <mcstar> but, consider this, which is not new to you probably, but just occured to me
00:19:49 <mcstar> an evolving program most of the time wouldnt typecheck
00:20:01 <nicoo> pordan30: Balance of two is used in OCaml's standard lib (and was chosen by benchmarking)
00:20:22 <startling> mcstar, you don't "evolve" a program by applying random transmutations on the source code
00:20:33 <mcstar> i guess
00:20:40 <mcstar> that would be stupid, right?
00:20:42 <shachaf> pordan30: Haskell has a default AVL tree implementation?
00:20:44 <edwardk> mcstar: you can factor the type system into the splicing rules for, say genetic programming a la Koza
00:20:47 <mcstar> you set up a semantics, that you evolve
00:21:42 <mcstar> is there a conclusion? does strong static typing helps with that, or stands in the way?
00:22:04 <mgsloan> hirsch: It's not too hard to make one - take a look at th-lift
00:22:12 <pordan30> nicoo: so the basic operations have the same complexity but benchmark better? thanks
00:22:27 <Trudko> startling: pharaun btw eventhough there is not that jobs for haskell that for java , here are pretty good amount of people, why is so?
00:22:38 <pordan30> shachaf: i thought that Data.Tree.AVL was a default implementation; at least, I have seen it referred to as the default implementation.
00:22:42 <startling> Trudko, companies are dumb
00:22:43 <mgsloan> hirsch: Something like "QuasiQuoter (lift . lines) undefined undefined undefined"
00:23:37 <avpx> startling: Perhaps not. Few people know how to write programs in a functional style, or have had to deal with a type system like Haskell's.
00:23:55 <startling> avpx: people are dumb too!
00:23:57 <startling> it's all dumb
00:24:04 <pharaun> its dumb all the way down
00:24:04 <avpx> startling: Now you're talking
00:24:09 <mcstar> edwardk: what a picture, gentle smile, nice lighting, and a 1000 pentiums in the background!
00:24:39 <edwardk> mcstar: ?
00:24:47 <mcstar> http://www.genetic-programming.com/johnkoza.html
00:25:00 <edwardk> ah
00:25:25 <edwardk> if you want to learn generic algorithms and genetic programming koza's book is still a good starting point
00:25:34 <Trudko> startling: heh I am nore courious why haskell is popular here rather then why is not popular in companies :D
00:25:35 <mcstar> unforunately i dont
00:25:49 <mcstar> i want to learn first order logic
00:25:49 <edwardk> it gets a bit repetitive, because he keeps reusing the same examples, but it means you can step into a chapter and know whats going on
00:25:54 <pharaun> Trudko: this is the haskell irc channel :p so...
00:26:12 <edwardk> Trudko: i work in industry writing haskell. so do a lot of people here
00:26:27 <edwardk> haskell is popular in many domains where correctness by construction is very important
00:26:44 <edwardk> its also just generally nice to think in
00:26:53 <mcstar> haskell is also popular among unpaid amateurs who want to broaden their horizons
00:26:57 <Trudko> edwardk: yeah but schek shceme so fw people there
00:27:10 <startling> mcstar: ;)
00:27:18 <avpx> mcstar: Yeah, I'm in that boat
00:27:22 <mcstar> :)
00:27:30 <edwardk> scheme is nice to get started with functional programming, but the nature of the language and community make it hard to do serious work in
00:27:44 <avpx> Also learning type theory/first order logic, crawling through Mac Lane...
00:27:58 <mcstar> avpx: is that a book?
00:28:10 <mgsloan> yeah, it's got pictures of cats in it
00:28:16 <pordan30> mcstar: you might be interested in the handbook of automated reasoning if you're interested in the computational side of logic and functional programming.
00:28:24 <mcstar> pordan30: harrison?
00:28:30 <mcstar> yeah, working on it
00:28:56 <avpx> mcstar: Categories for the Working Mathematician by Mac Lane. It's an interesting read, but challenging as I have but one semester of abstract algebra behind me (not a lot of background)
00:29:45 <avpx> mcstar: Someone also pointed out this reference on logic/type theory that I have been finding to be cool: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.7385
00:29:56 <mcstar> ok, then my best bet is on HPLAR
00:31:26 <mcstar> since when is citeseerx free?
00:32:08 <mcstar> i have a vague memory, that i needed institutional ip to download from it
00:32:22 <mcstar> but i might be confusing it with some other service
00:32:59 <avpx> mcstar: Yeah, I'm curious about that too. Anyway, that's been a nice read.
00:33:47 <mcstar> probalem is, that theres always too much to do
00:33:55 <mcstar> i have to make a precedence
00:34:00 <pordan30> i didn't realize that lectures on the curry-howard isomorphism was free online. thanks.
00:34:08 <mcstar> and that is HPLAR first
00:34:28 <avpx> I've had to shelve a lot of these resources because my undergrad studies are keeping me plenty busy
00:34:35 <mcstar> avpx: but im sure it is interesting, maybe in a couple of years....
00:34:44 <mcstar> same here
00:35:35 <mcstar> i wonder how many hard computer scientist are there
00:35:59 <mcstar> wrt researchers of natural sciencies
00:36:20 <pordan30> also, barendregt's introduction to lambda-calculus is free online
00:36:43 <mcstar> but do you guys understand really well the concepts without doing exercises?
00:36:55 <mcstar> cause my own experience is that you need to do them
00:37:09 <mcstar> you read something, and that will mostly be shallow knowledge
00:37:49 <Trudko> edwardk: ou ok I just want to knwo as much of practical use as possible but I wont probably use it at home or would I? Normally I would probably use Ruby because its fun language more or less and its popular so I can find job with it
00:38:07 <Trudko> and I heard it is good for multicore development?
00:38:29 <mcstar> ruby?
00:39:19 <edwardk> Trudko: haskell's parallelism story was the thingthat sort of lured me in and kept me here. when your language is pure you don't need to worry about what core something runs on nearly as much, and aren't constantly worrying about sequencing what happens next, and can instead focus on how to build the dependencies between your data, and just sprinkle some 'par' calls or other parallelism intrinsics and it just works
00:39:40 <shachaf> edwardk: I thought GHC didn't have the threaded RTS in 2006? :-)
00:40:20 <avpx> Trudko: Haskell really separates "what you want to compute" from "how you want to evaluate it". You *can* influence that latter part, but usually the compiler figures it out.
00:40:38 <avpx> Usually it does a pretty good job with parallelism and the like
00:40:41 <Trudko> edwardk: what do you mean by pure language? and I am not really experience in non web programming  wouldnt I use C or C++ for multicore pgoramming?
00:40:42 <shachaf> avpx: That
00:40:47 <shachaf> 's not really true...
00:41:01 <avpx> shachaf: For a minute I thought you were agreeing
00:41:04 <avpx> Oh well
00:41:17 <shachaf> It's a high level language but it's not magic. If you want a smart algorithm you're still going to have to write it.
00:41:32 <edwardk> Trudko: haskell doesn't have side-effects by default. by not having side-effects (like printing to the screen) it is much easier to know when two bits of code interact.
00:41:37 <avpx> I didn't mean to imply that there was magic
00:42:42 <edwardk> shachaf: i'm pretty sure it did: http://www.haskell.org/ghc/docs/6.6/html/users_guide/sec-using-smp.html
00:43:07 <mcstar> pordan30: did you use ocaml with HPLAR, or turned the code into haskell?
00:44:03 <edwardk> Trudko: i wrote (and still write) a fair bit of c/c++, etc. however. when you go to write parallel code in c/c++ its a _lot_ of work, just getting the scaffolding in place and setting up all your code to reason about happensbefore semantics, etc.
00:44:24 <edwardk> Trudko: comparatively writing parallel code in haskell is trivial.
00:44:41 <shachaf> edwardk: It got it in 6.6, I think.
00:44:48 <avpx> And some common parallel tasks are *actually* trivial
00:44:50 <edwardk> i've taken entire research papers from folks who wrote them in c# and replaced them with literally 2 lines of haskell =P
00:44:53 <shachaf> Which was released in late 2006, I guess.
00:44:57 <pordan30> i used it as a reference a few times, because one of my faculty had a copy. looking at amazon, it's ridiculously expensive. so it's probably not a good recommendation unless you have access to a university library.
00:44:58 <Trudko> ok so paralel programing is one thing where I can use it I guess is not really web language is it?
00:45:03 <edwardk> shachaf: yeah
00:45:09 <avpx> Trudko: "web language?"
00:45:16 <edwardk> i knew it was here right when i was coming on the scene
00:45:28 <avpx> Trudko: Lots of code for the web is written in Haskell
00:45:33 <mcstar> pordan30: i have access to the book, i just thought you worked through it
00:45:51 <mcstar> im thinking about replicating (sort of) the code as i go in haskell
00:45:54 <raichoo> Trudko: What defines a "web language"?
00:46:03 <mcstar> there would no point in writing it in a slightly different way in ocaml
00:46:05 <mcstar> i think...
00:46:06 <edwardk> Trudko: its a general purpose programming language. you can go write pretty much anything you want in it =P
00:46:10 * shachaf suspects nothing good will come of this discussion.
00:46:11 <mcstar> would be*
00:47:19 <mcstar> let me be the fly in the soup, where are parallal examples of sorting/graph searching or alike in haskell?
00:47:24 <raichoo> Trudko: There are people who even write games in Haskell http://joyridelabs.de/ :) There are also several web frameword out there :)
00:47:28 <mcstar> with 'automatic parallelism'?
00:47:33 <raichoo> frameworks that is
00:47:35 <mcstar> and what is the performance of those?
00:49:11 <Trudko> avpx raichoo sorry for my english , by web language I meant language used for web application like is ruby, python, php , java for example
00:49:17 <Trudko> or javascript ofc.
00:50:10 <raichoo> Trudko: I'd choose haskell over python, ruby and ofc php every day.
00:50:20 <raichoo> For web programming that is.
00:51:22 <mcstar> i guess the guys who know parallel programming didnt read my comment...
00:51:35 <Trudko> raichoo: arent you biased :D? ofc I would chooose anything over php everyday :D
00:52:12 <raichoo> Trudko: I'm writing 9 programming language at my dayjob, dunno if you can call that biased ^^
00:52:30 <raichoo> dang, my typing sucks this morning.
00:52:47 <Trudko> ? writting 9 ?
00:53:09 <raichoo> Using 9 that is.
00:53:36 <Trudko> which ones?
00:54:13 <raichoo> C, C++, C#, ObjC, Java, JavaScript, Scala, Haskell, Python
00:54:53 <Trudko> how is C or objC web language?
00:55:28 <raichoo> How is Python?
00:55:40 <companion_cube> how are you?
00:55:45 <raichoo> fine :)
00:55:48 <raichoo> :p
00:55:52 <companion_cube> ^^
00:56:41 <Trudko> raichoo: because this is what it used for a lot I guess not sure about python dont work with that, but take java Java EE is used the most (now mobile are more popular thx to Android)
00:57:02 <Trudko> or javasript is nice example it could be used outside of web browseer but it much more common for its browser use
00:57:55 <raichoo> Trudko: So what exactly is your argument. I don't see where you are trying to get.
00:58:40 <raichoo> I'm doing far more than just web coding, but haskell can do that.
00:58:47 <Trudko> raichoo: what I am saying is that  by web language I meant that language is used often for web applications like php is for example
00:59:22 <Trudko> raichoo: sorry for not being clear I am sure it CAN be used but questions is how often is it or where it is primary use , yeap primary use would be better I guess
00:59:52 <raichoo> Trudko: It's a general purpose programming language. People use it for all kinds of things.
01:00:17 <raichoo> It's a tool. No more, no less.
01:00:50 <zomg> Web app developers generally don't speak Haskell
01:01:01 <zomg> If they did I'm sure they might use it more since it's pretty good for that too
01:01:01 <zomg> =)
01:01:12 <raichoo> +1
01:02:03 <Trudko> ou HI zomg :)
01:02:09 <zomg> Hey
01:02:11 <Trudko> raichoo: ok got you
01:02:18 <Trudko> thx for all info
01:05:50 <Trudko> btw I am try haskell http://tryhaskell.org/  but  for example let myF = [[]] returns http://tryhaskell.org/
01:05:59 <Trudko> returns http://tryhaskell.org/
01:06:01 <Trudko> omg sorry
01:06:06 <Trudko> returns not an expression error
01:06:17 <mcstar> edwardk: if youre available.... can you comment on my comment?
01:06:24 <edwardk> ?
01:06:37 <mcstar> "let me be the fly in the soup, where are parallal examples of sorting/graph searching or alike in haskell?"
01:06:44 <donri> Trudko: tryhaskell isn't ghci. try http://ghc.io/
01:06:48 <Trudko> zomg: do you work with haskell? btw hughjack. was here also
01:07:09 <Trudko> donri: what does it mean ? I have ghci open thats why I am puzzled why  try haskell is not working same
01:07:41 <edwardk> mcstar: sorry i'd tuned out the channel and was getting work done. =P re sorting/graph searching, the issues there are boring and solved. the reason its not being done is its not interesting
01:07:48 <donri> Trudko: tryhaskell evaluates haskell expressions. ghci puts you inside a do-block of the IO monad, sort of.
01:08:19 <edwardk> i have some code inside of my multipass framework for doing fused sorting of large data sets up to the structure required to compute certain order statistics, etc.
01:08:23 <donri> Trudko: "let" without "in" is valid inside a do-block, but isn't an expression alone
01:08:24 <edwardk> but the vanilla case is boring
01:08:28 <Trudko> donri: not whare what you mean but what i am courious will everything works in ghci?
01:08:34 <mcstar> edwardk: but wouldnt that sort of problem be a good introduction to haskell's half-implicit parallelism?
01:08:41 <donri> Trudko: please rephrase?
01:09:01 <edwardk> mcstar: its a pretty crappy fit, honestly ;)
01:09:13 <Trudko> donri: does ghci any serious limitation or can I freely test al kinds of stuff there ofc I do realize is not ful lIDe
01:09:15 <Trudko> IDE
01:09:31 <mcstar> edwardk: im just trying to get a feel for this, then when is this kind of parallelism a good fit?
01:09:45 <zomg> Trudko: yeah I use haskell with some of my personal projects
01:09:52 <donri> Trudko: no serious limitation that i'm aware of.
01:10:05 <Trudko> donri: ok
01:10:34 <Trudko> zomg:  cool how does JS comapre to haskell? I knwo JS is inspired by Scheme
01:10:41 <Nereid> cool, I have an actual project I can use haskell for, instead of just fiddling around
01:10:52 <raichoo> Trudko: Depends on what you consider an IDE. My vim is pimped out for pretty much everything when it comes to haskell :) I'm sure the same applies to emacs et al.
01:10:56 <mansoor-s> Has anyone created a 3d game with haskell? I cant find any
01:10:58 <zomg> Trudko: Kind of hard to compare since they are pretty different :D
01:11:01 <Nereid> but now I go to bed
01:11:03 <raichoo> mansoor-s: frag
01:11:04 <edwardk> i get wins out of haskell's parallelism where i can sprinkle a few par's in some kind of graph problem. i use it in type checkers, when i have multiple stages of a pipeline and a guess at the intermediate result (see speculation), when i have a big fork/join parallelism/incrementalization graph using revisions, i get to enjoy the benefit that code written using STM actually composes and can be understood in isolations, unlike code wri
01:11:04 <edwardk>  with java locks
01:11:05 <Trudko> Nereid: what's  rhe project
01:11:19 <donri> Trudko: JS and HS are kinda each others opposites :p
01:11:31 <edwardk> now, its not a perfect replacement for everything i can do in other languages
01:11:38 <Trudko> donri: zomg lol ok :D i mean both are functional
01:11:41 <raichoo> Trudko & donri: there is fay. It's haskell that compiles to JS.
01:11:52 <edwardk> i can still do some pretty spiffy things with, say, intel's thread building blocks that have no viable analogue in haskell
01:11:52 <donri> raichoo: i know, i'm a contributor ;)
01:11:59 <raichoo> cool :)
01:12:20 <edwardk> but DPH is in theory coming down the pipe, and will hopefully redress that imbalance somewhat
01:12:27 <donri> Trudko: true, although JS functions and HS functions are quite different stories
01:12:28 <donri> bbl
01:13:04 <mcstar> edwardk: so, if i understand it correctly, the motto is, leave the serial code almost intact, let it work on the lowest level, and compose the output of smaller inputs computed by the serial code, using high level parallelism?
01:13:26 <edwardk> for the most part
01:13:39 <mcstar> tbb is low level, right?
01:13:50 <edwardk> if you have a task that may take a while but you know you will need it, par/pseq chain it
01:13:53 <mcstar> like, scheduling single operations?
01:14:02 <Trudko> donri: ok I kind of hoped that even if I end up not using haskel much I can at least enrich my understanding of javascript .
01:14:07 <edwardk> tbb has a pretty wide range of abstraction
01:14:26 <edwardk> from parallel for blocks to splittable ranges, and scheduling continuations etc.
01:14:34 <Trudko> donri: ofc I realize more language you use more you understand them but I thought haskell js relationship would be kind of more special :)
01:14:57 <Nereid> Trudko: something~
01:14:59 <Nereid> anyway
01:15:00 <mcstar> edwardk: do you write desktop parallel, or massively parallel stuff? or both
01:15:19 <Nereid> is there any way to tell cabal install to automatically generate html documentation and stuff?
01:15:30 <edwardk> now? desktop parallel stuff mostly, before, more on the massively parallel side
01:15:40 <mcstar> edwardk: whenever :)
01:15:49 <mcstar> experience doesnt disappear with time
01:16:29 <mcstar> edwardk: for massively parallel stuff, you need some transparent networking
01:16:38 <mcstar> idk anything else then mpi for that
01:16:41 <Nereid> oh found it
01:16:47 <edwardk> well, it becomes less relevant. the cycle counts i held in my head as gospel are sadly mesofacts, so their accuracy in reflecting the optimal way to code things at the lowest levels fades with time ;)
01:18:04 <edwardk> mpi is one model. i used to have a distributed column store that was good for different workloads, distributed bloom joins, parallel blast and gis queries, etc., there is map-reduce, etc.
01:18:33 <edwardk> depends on what you want to do. not everything is boring synchronous parallel like mpi handles ;)
01:19:06 <edwardk> and the mpi model has a hard time scaling at decent cost.
01:19:41 <edwardk> when you scale up large enough on commodity hardware failure becomes the norm not the exception. and mpi doesn't really deal with failure
01:20:19 <edwardk> i don't want to restart my calculation when a server dies, if its happening more often than not
01:20:44 <mcstar> edwardk: back to the basic stuff, lets consider sorting, would a parallel sort algorithm, in lazy pure haskell, implemented with parallel constructs, like par,pseq, would give some benefit over C performance wise?(single threaded)
01:20:56 <edwardk> no
01:21:11 <edwardk> hand super-tuned c code will trump what you can do
01:21:18 <mcstar> ok
01:21:24 <edwardk> the trick is that i can optimize 50x as much code as you can in the same time ;)
01:21:38 <mcstar> no, not me
01:21:48 <mcstar> you can do at least 500x
01:21:51 <edwardk> well, you being 'generic c/c++ developer'
01:21:55 <mcstar> :)
01:23:04 <mcstar> edwardk: did you have the sscenario, when you wrote some C, which was really faster than haskell, and parallelized it from within haskell?
01:23:30 <mcstar> i meant distributed
01:23:35 <mcstar> not parallelized
01:24:11 <Trudko> OK guys thanks again for help and I go t leave
01:24:19 <edwardk> my parallelism background and my haskell background only barely intersect
01:24:41 <edwardk> i don't even think about the same problems in the two languages
01:25:00 <edwardk> so in many ways i'm kind of a patchwork person when it comes to these two world views =)
01:25:40 <mcstar> you started with "par/pseq like parallelism was what started me on with haskell"
01:25:48 <mcstar> iirc
01:26:06 <edwardk> i can say that i had a bunch of hand tuned fast code for dealing with a bunch of parsing tasks in c that when ported to haskell i could do asymptotically more efficiently by working smarter, and that laziness lets me fuse together naive algorothms into a pretty good default
01:26:28 <edwardk> well, its what sold me on haskell, explicitly because i'd done so much of it the crappy way before
01:26:52 <edwardk> 'par' is an amazingly powerful combinator compared to anything you get out of the imperative world
01:27:57 <edwardk> the fact that 'revisions' lets me rewrite fairly naive imperative code in just a different monad with a few parallelization points, and lets me get a superlinear speedup on 8 cores (22x for some problems due to incrementalization), that kind of thing makes me excited
01:28:39 <mcstar> hm?
01:28:56 <mcstar> thats how 'linear scaling' is calculated?
01:28:57 <edwardk> my point was that while you can hand roll c/c++ code that can beat haskell code, its hard enough that you just don't in practice do it very often
01:29:18 <mcstar> id say it is linear if it is a line on a log plot
01:30:18 <donri> edwardk: and probably requires major restructuring for existing code?
01:30:26 <edwardk> its superlinear because in this case im comparing apples and oranges. the same tool that gives me parallelism gives me the points i need for incrementalization. this means you get two orthogonal dimensions providing you speedup over the naive direct code
01:30:33 <edwardk> donri: that too
01:30:44 * hackagebot wai-handler-devel 1.3.0.2 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.3.0.2 (MichaelSnoyman)
01:31:35 <edwardk> my revisions package gets pretty crappy parallelism, but the model gets great incrementalization
01:32:04 <edwardk> woot. i just got the breadcrumb code to save and restore paths!
01:32:21 <mcstar> point is, haskell's parallelism is not some hype
01:32:38 <edwardk> mcstar: correct =)
01:32:41 <mcstar> not sure about dph, that probably still limelight ready?
01:32:48 <mcstar> still isnt*
01:32:54 <edwardk> dph is pie in the sky.
01:33:03 <edwardk> honestly? i wouldn't care if it never saw the light of day
01:33:11 <mcstar> ok
01:33:14 <edwardk> it led to a ton of improvements in things we use every day
01:33:16 <mcstar> i prefer honesty
01:33:35 <edwardk> it caused us to get type families, data families, a ton of work on the code emitter, etc.
01:33:41 <edwardk> these are all general purpose improvements
01:34:02 <edwardk> that far outweigh the benefit of some fairly limited and brittle nested data parallelism model
01:36:17 <mcstar> edwardk: i dont think i saw a conclusion, how does haskell's current capabilites compare to tbb?
01:36:28 <edwardk> they are very different
01:36:39 <edwardk> tbb does big block parallel splittable range stuff very well
01:36:44 <edwardk> haskell has no answer for that
01:37:09 <edwardk> haskell does lots of mixed parallelism/staging/revision control/stm/etc. stuff
01:37:26 <edwardk> DPH is the closest thing to the answer to the tbb stuff
01:37:43 <edwardk> i still use tbb for some code because its just that much faster for certain workloads
01:37:52 <edwardk> otoh, i also still use cuda, etc.
01:38:10 <edwardk> i'm not a haskell zealot, its just a much nicer place to think about parallelism
01:38:41 <anakreon> Hello. How can one jump to an error reported by ghci from within emacs to the corresponding line in the source file?
01:38:54 <mcstar> edwardk: did you miss haskell's type system when working with tbb?
01:39:20 <edwardk> i'd written c++ for a long time before i came to haskell, it has its own .. charm ;)
01:39:21 <anakreon> From what I could see, there was no such function in haskell-mode
01:40:03 <mcstar> meta-g g linennumber
01:40:05 <sqrt> I have a stupid question about records. Can a function in a record use data from the record itself?
01:40:24 <merijn> ok, I'm having some issues with polymorphic code not being as polymorphic as I thought: http://hpaste.org/74921
01:40:35 <edwardk> sqrt: you can tie the knot, but then updates to the record won't be visible to it
01:40:41 <sqrt> Because all the fields in the record are in fact functions, right?
01:40:42 <mcstar> edwardk: wel, thanks, i hope i learned something :)
01:40:59 <Nereid> ok
01:41:01 <Nereid> one more question
01:41:09 <edwardk> sqrt: you can always pass the record to your functions from the record as an argument =)
01:41:09 <Nereid> I've turned on the documentation flag in .cabal/config
01:41:16 <Nereid> but is there a way to tell it to use hscolour too?
01:41:53 <anakreon> Isn't anyone using emacs? So strange
01:41:55 <sqrt> edwardk: I have this record named Maze with fields cellmatrix, width, height and lastly getCell
01:41:58 <Nereid> other than passing --haddock-hyperlink-source all the time
01:42:10 <edwardk> sqrt: then its 'openly' recursive enough that you can see edits
01:42:10 <edwardk> data Foo = Foo { blah :: Foo -> Int, bar :: Foo -> Double, width :: Int, height :: Double }
01:42:11 <mcstar> sqrt: rec {field1 = field2 rec + 1}?
01:42:41 <sqrt> The getCell function would look best if it had the value Position -> Cell .... but then it would have to access the cellmatrix of the maze.
01:42:55 <Nereid> sqrt: why is getCell part of the record?
01:43:01 <edwardk> then blah :: Foo -> Foo -> Int   -- the first Foo is the recor dyou got it from and the second is the one you are passing it for open recursion/self reference
01:43:19 <edwardk> so blah_ f = blah f f  gives you something that you can see whats in the record with you.
01:43:26 <edwardk> but its a pretty awkward design
01:43:37 <sqrt> Hmm.
01:43:46 <mcstar> anakreon: ist it good enough, to enter the line number?
01:43:53 <sqrt> I think I've got an awkward design to begin with as well.
01:44:00 <Nereid> mhm
01:44:05 <mcstar> i run the interpreter outside emacs though
01:44:08 <edwardk> i'd just as soon make getCell a method out at the top level somewhere, that just takes a record rather than live IN the record
01:44:27 <sqrt> Yes, that would be prettier.
01:46:12 <isomorphic> hrmm.  I have a case expression within a do-block that happily selects between two different putStrLn's.   Should it be possible to just return a bare string instead of an IO action?
01:46:39 <sqrt> I was just thinking, all elements of a record are in fact functions ... like height. I write height :: Int, but then that means height is a function Maze -> Int.
01:46:43 <Nereid> so, nothing I can put in .cabal/config that will do that for me?
01:47:01 <anakreon> I see. For me it is very convinient to execute the interpreter from within emacs. The only problem is that I have to go by C-g g to a line when an error occurs.
01:47:04 <Nereid> isomorphic: sure, why not?
01:47:17 <mcstar> anakreon: m-g g
01:47:32 <sqrt> Then maybe I can put in all sorts of functions inside a record?
01:47:33 <anakreon> Right, M-g
01:47:35 <isomorphic> Nereid: Well, I thought so - but ghci barfs and complains if I try it ;)
01:47:44 <Nereid> can't you change, say, case x of _ -> putStrLn "a"
01:47:45 <Nereid> to
01:47:52 <Nereid> putStrLn $ case x of _ -> "a"
01:47:53 <Nereid> etc
01:48:13 <isomorphic> Ah - yes - but then I'd still be returning an action
01:48:23 <Nereid> well it's hard to say more without seeing the surrounding code
01:48:25 <isomorphic> this is in the context of a function that I'm currently not calling from anywhere
01:48:39 <isomorphic> (so there's no type inference going on)
01:48:40 <mcstar> anakreon: does tab completion work from emacs in ghci? that was one reason i didnt use it that way
01:48:50 <Nereid> maybe you should put a type signature? :v
01:48:55 <anakreon> I suppose the haskell-mode would need to find in the interpeter buffer the last session and make the errors available to emacs.
01:49:37 <mcstar> it could just grep the output of the itnerpreter
01:50:01 <hpaste> isomorphic pasted “Without an IO action? ” at http://hpaste.org/74949
01:50:17 <anakreon> I don't know, I never use that. If I need to complete a function I type M-/
01:50:27 <Nereid> isomorphic: and what stops you from moving putStrLn outside the case?
01:50:39 <Nereid> or
01:50:46 <mcstar> anakreon: but that emacs own completion, right? not what ghci knows about
01:50:48 <Nereid> isomorphic: are you trying to return the string from that?
01:50:53 <isomorphic> Nereid:  I'd like to just return a string - it's to be consumed by something that's expecting a string
01:50:53 <Nereid> or something
01:50:59 <isomorphic> Nereid: yes
01:51:00 <anakreon> Right.
01:51:04 <Nereid> isomorphic: well assuming submit is some IO action, you better return an IO String.
01:51:11 <Nereid> with return
01:51:34 <isomorphic> Nereid:  s/putStrLn/return ?
01:51:38 <Nereid> sure.
01:51:42 <Nereid> or have return outside the case.
01:52:40 <isomorphic> Nereid:  Hrmm.  Ghci hates that - No instance for (Control.Failure.Failure HttpException m0)   arising from a use of `submit'
01:52:56 <Nereid> eh
01:53:25 <Nereid> surely it says more than that
01:54:59 <mcstar> anakreon: theres on Error menu, though im not sure how that is supposed to work, since it doesnt work on error when i load upa  file
01:55:23 <chris__> #happs
01:55:42 <isomorphic> Nereid: It suggests that I add an instance for Control.Failure.Failure HttpException m0, but the remainder of the message is just identifying the context of the line that contains submit in the function
01:56:03 <Nereid> oh, so maybe "return" isn't specific enough or something
01:56:11 <Nereid> you should give getButton2 a type signature.
01:56:13 <Nereid> :V
01:56:58 <isomorphic> Nereid: Thanks!  It likes IO String as its type
01:57:03 <Nereid> ok
01:57:14 <Nereid> but looking at the function, maybe it should be a IO (Maybe String) or the like so you can distinguish an actual html string from an error
01:57:29 <Nereid> and style note: s/err/_/ on line 4
01:57:54 <isomorphic> Ah - thanks on both points :)
01:58:01 <anakreon> mcstar: It doesn't work and even if it did I would have to switch to the interpreter buffer to  acces that menu item which is not much better then M-g
01:58:13 <mcstar> yes
01:58:17 <t7> anyone on windows:  http://superuser.com/questions/269818/change-default-code-page-of-windows-console-to-utf-8
01:58:38 <t7> also change console font to a true type one = ghci can output unicode chars :D
01:58:43 <anakreon> I will submit a request to the author of haskell-mode
01:59:09 <mcstar> anakreon: im sure you can macgyver something
02:00:25 <Nereid> t7: cool, thanks
02:00:26 <isomorphic> mcstar:  I am missing the context, but I have this picture of somebody writing a web browser out of three operators and flip, or something like that.
02:00:30 <Nereid> (doing the autorun thing)
02:02:46 <t7> Nereid: did you have to make the key? i didnt have one...
02:02:51 <Nereid> string value
02:03:06 <Nereid> so yeah
02:03:16 <Nereid> not a key
02:03:44 <t7> god i hate windows
02:03:51 <Nereid> :D
02:03:57 <Nereid> hmm
02:04:03 <Botje> but they allow the sun into your house!
02:04:10 <t7> i cant think of one thing windows does better than *nix. Drivers don't count
02:04:23 <Nereid> video games D:
02:05:04 <t7> thats not microsoft, thats game devs, unless you are saying directx is better than opengl?
02:05:06 <Nereid> someone should fix this ;o http://hackage.haskell.org/trac/hackage/ticket/517
02:05:11 <Nereid> t7: yeah, I know.
02:05:23 <Nereid> I'd fix it myself but I had a quick look at the cabal-install source and didn't understand it.
02:08:42 <juriily> configuring multiple screens is much easier on Windows
02:09:17 <isomorphic> Nereid:  Incidentally - is Maybe IO String or IO (Maybe String) preferable?
02:09:24 <Nereid> Maybe IO String won't work.
02:09:33 <Nereid> neither will Maybe (IO String)
02:09:43 <t7> seemed the same for me :| amdcccle and stuff. actually i couldnt set primary monitor in x but thats probably me being ignorant
02:09:45 <Nereid> whether the result is an error or not depends on IO
02:10:09 <mcstar> isomorphic: Yes! Haskell can do that!
02:11:09 <mcstar> t7: why not using mintty?
02:12:04 <mcstar> xterm meets windows! wait until it reaches the masses
02:12:13 <t7> ah cool
02:12:26 <mcstar> i see my mother using Alpine on xp
02:12:30 <t7> i probably have this in my mingw install allready
02:12:51 <isomorphic> Nereid:  Ok.  Should making the result of the case statement "Just (C.unpack html)" have worked for the IO (Maybe String) case?
02:13:04 <Nereid> that should work, yes.
02:13:08 <Nereid> well, together with return
02:14:11 <isomorphic> Nereid:  I see.  I was assuming that the return was unnecessary because this is the last statement of the do block
02:14:18 <isomorphic> Nereid:  I gather that's wrong
02:14:30 <isomorphic> Nereid: Incidentally - it works now with the return ;)
02:14:38 <Nereid> return is a very important thing
02:15:15 <Nereid> specialized to IO, we have return :: a -> IO a
02:15:30 <Nereid> and uh
02:15:52 <Nereid> well yeah, the types all have to work out.
02:16:04 <Nereid> someone can explain this better than me.
02:16:19 <isomorphic> Nereid:  Thanks very much, you've been very very helpful :)
02:16:47 <mcstar> Nereid: lifting a value into a monad?
02:17:03 <Nereid> yeah.
02:20:01 <merijn> Rank2Types hate me and I don't understand why... somehow I cannot partially apply a function of type "PatternSet s -> Int -> (forall p . Pattern p -> a) -> a" to get a function of type "(forall p . Pattern p -> a) -> a"?
02:20:16 <Igloo> ddarius: What am I up to?
02:20:26 <Nereid> merijn: do you have enough type signatures?
02:21:43 <merijn> Nereid: Apparently I suck, I was convinced I tried explicitly adding it yesterday and it didn't work, but now it seems to...
02:21:50 <Nereid> lol
02:22:09 <t7> mcstar: mintty has its own root
02:22:17 <t7> and doesnt know any windows commands :(
02:23:01 <mcstar> yeah
02:23:16 <mcstar> im sure theres a workaround :)
02:23:44 <mcstar> there are better consoles for powershell, i suspect those support simple cmd too
02:24:25 <mcstar> something called powegui
02:24:28 <mcstar> for instance
02:24:33 <mcstar> powergui*
02:25:33 <mcstar> t7: i googled this for you: http://gerardlee.wordpress.com/2010/08/02/a-hack-for-mintty-to-use-as-windows-command-console-cmd/
02:28:36 <mcstar> t7: maybe this is better http://www.hanselman.com/blog/Console2ABetterWindowsCommandPrompt.aspx
02:28:56 <mcstar> i actually used 'console' in my windows days, but it was so long ago i totally forgot about it
02:30:37 <merijn> @pl f x $ g $ h y
02:30:37 <lambdabot> f x (g (h y))
02:31:11 <t7> mcstar aha!
02:46:53 <Expez> I understand the semantics of the QuickCheck properties, but the syntax is confusing. If I do 'test_prop = testProperty "foo prop" prop where prop a = ...' (Using test-framework). How can the function call 'prop' be without any argument? How does QC know to use generators to fill inn the missing arguments in 'foo a' by using generators?
02:49:06 <farzan> hello
02:50:05 <farzan> ??
02:50:14 <Saizan> Expez: typeclass instances are there that fill prop with arguments according to the type of prop
02:50:17 <Saizan> farzan: hi
02:50:36 <farzan> hi
02:51:15 <jonathan1> Does inserting into a hashmap create a new copy of the entire hashmap?
02:51:26 <frerich2> I think "Aslan986" wrote an interesting question at http://stackoverflow.com/questions/12492217/in-a-list-of-lists-impose-the-same-length - I had a similiar issue in the past (I needed a list of a fixed length, I did that using peano numbers). Maybe somebody here can shed some light?
02:52:55 <Nereid> gave up so I just made a shell alias
02:53:26 <Expez> Saizan: Why does 'prop' even parse when the where clause says that prop takes an argument?
02:54:32 <Saizan> Expez: in haskell functions are values too, and can be passed to other functions as arguments
02:54:38 <matthiasgorgens> Expez: taking an argument is something for the type system to worry about.  not the parser.
02:54:50 <matthiasgorgens> (and what saizan said. :o)
02:55:01 <quicksilver> jonathan1: I imagine not. Which hashmap?
02:55:26 <jonathan1> IntMap
02:56:18 <matthiasgorgens> jonathan1: that creates a copy, but the copy shares almost all of it's data with the original.
02:56:29 <quicksilver> jonathan1: IntMap is a patricia trie; inserting is very quick
02:56:34 <Lemmih> jonathan1: (btw, IntMap is a patricia tree.)
02:56:41 <quicksilver> matthiasgorgens: which is not really "creates a copy" :)
02:56:50 <matthiasgorgens> jonathan1: by the way, I wouldn't call IntMap a hashmap, because we have http://hackage.haskell.org/package/hashmap, too.
02:56:56 <matthiasgorgens> and so that just causes confusion.
02:57:09 <Expez> Saizan: Right, thanks.
02:57:36 <quicksilver> on average it has to copy around log n data, where n is the number of elements.
02:58:01 <ksf> ...of the spine, not the elements
02:58:52 <quicksilver> no, n is the number of elements.
02:58:55 <matthiasgorgens> quicksilver: yes, performance-wise it doesn't create a copy.  semantically you can pretend it does. :o)
02:59:02 <ksf> but only the spine is copied around.
02:59:08 <quicksilver> right.
02:59:14 <quicksilver> the spine is the "around log n data"
02:59:20 <jonathan1> Ah, didn't know that. Well thank you :) Now I just have to figure out why it's so slow
02:59:36 <matthiasgorgens> jonathan1: do you know how to profile?
02:59:45 <matthiasgorgens> jonathan1: and can you post your source on hpaste?
02:59:50 <matthiasgorgens> post -> paste.
03:06:32 <jonathan1> It's too ugly for me to post :) But I should be able to find my bug, it's just a little weird
03:07:30 <matthiasgorgens> re.
03:12:58 <fracture> is there a difference in runtime overhead if you use fmap instead of map for a list?
03:13:28 <fracture> (e.g. more indirect calls...)
03:14:09 <Lemmih> fracture: No.
03:15:17 <fracture> cool---does that apply in general to calling functions that are part of a type class?
03:15:24 <fracture> or is it special because it's prelude?
03:15:44 <ksf> it's general agressive inlining
03:16:14 <fracture> k; thanks
03:25:47 <MHD> I had a strange idea: Supposing * is carthesian product and + is type union, you can model a Semiring in the type system
03:25:56 <mcstar> but sometimes calls cant be inlined, like, you have to look up what to call at runtime
03:26:13 <MHD> With bottom and unit being additive and multiplicative identities respectively
03:26:38 <mcstar> thats what i learned from here, sort of like a virtual method call in c++?(the typeclass'd functions)
03:27:11 <mcstar> ksf: ^^
03:27:17 <MHD> mcstar: Most of the time, the typeclass calls can be inferred at compiletime
03:27:46 <MHD> I have mostly used type classes as static polymorphism
03:27:54 <mcstar> how special are the use-cases when it cannot be?
03:28:21 * ksf can't imagine any on the spot
03:28:31 <MHD> Something like quantified types
03:28:45 <ksf> well, yes, that's exotic matter.
03:29:02 <MHD> data Printable = forall a . (Show a) => Printable a
03:29:05 <mcstar> how about a simple polymorphic map on a list, that is wrote in a module, will that be inlined?
03:29:07 <fracture> does it matter if the function with the type constraint is in a different module?
03:29:17 <mcstar> is->I
03:29:32 <ksf> mcstar, yes.
03:29:37 <ksf> if in doubt, check the core.
03:29:41 <ksf> cabal install ghc-core
03:29:49 <ksf> or ghc -ddump-simpl
03:29:54 <mcstar> i have colored core :)
03:30:08 <mcstar> but now im just talking hypothetically
03:30:47 <ksf> cross-module inlining is more complicated. that's also why there's this beast called monomorphism restriction.
03:31:16 <ksf> ...but then there's SPECIALISE pragmas.
03:31:18 <mcstar> i didnt know it had to do with modules
03:31:36 <ksf> well, you can't just inline assembly in every case.
03:31:45 <quicksilver> mcstar: it has to do with compilation units.
03:31:47 <ksf> you need the core, at least.
03:32:00 <quicksilver> if you compile bits seperately then obviously inlining across units is more complex matter.
03:32:04 <mcstar> quicksilver: that can be a single line in ghci rigth?
03:32:11 <quicksilver> (for GHC a module is a compilation unit)
03:32:22 <quicksilver> ghci doesn't use the main compilation path
03:32:26 <ksf> ghci is interpreted and a completely different beast
03:32:28 <quicksilver> ghci uses a bytecode
03:32:34 <mcstar> yes
03:32:41 <mcstar> it says so, i believe
03:33:01 <MHD> ghci uses a bytecode implementation of the STG, no?
03:35:00 <quicksilver> don't know, actually
03:35:06 <quicksilver> never read much about ghci bytecode
03:35:23 <quicksilver> the heap object/thunk update stuff is the same though
03:35:39 <quicksilver> (bytecode and binary code are compatible and can be combined)
03:35:52 <quicksilver> so it's only the true code segments which are different.
03:38:05 <mcstar> i can imagine a situation like this: i have a sum type, and lets say i add it as an instance of Show, now i want to show differently the different types that this type subsumes, so i make them each an instance of Show, now when i call the 'show' function on the value of that type, it must figure out what other 'show' function it needs to call at runtime
03:38:11 <mcstar> am i correct?
03:38:41 <quicksilver> nope
03:38:48 <quicksilver> it knows what the types are at compile time
03:38:56 <quicksilver> that's the nature of compilation in haskell
03:39:01 <mcstar> yes, the types are given
03:39:12 <quicksilver> nothing is 'figured out' at runtime
03:39:20 <quicksilver> the show function called is determined by the type
03:39:26 <quicksilver> which can all be worked out at compile time
03:39:52 <mcstar> data MyType = V1 Int | V2 String
03:40:06 <mcstar> now when i call 'show' on a MyType
03:40:13 <mcstar> wait
03:40:56 <mcstar> well, yes, when i call show on value :: MyType it has to figure out if that value is constructed by V1 or V2
03:41:08 <mcstar> thereby use different 'show' for Int and String
03:41:14 <quicksilver> well that's true yes.
03:41:19 <quicksilver> it will generate the following code:
03:41:29 <quicksilver> case m of V1 a -> show a; V2 b -> show b
03:41:56 <fracture> quicksilver: part of what I was wondering:  if I have some function foo taking Showable a, called with various a's, will the compiler emit type-specialized versions of foo or do runtime dispatch on the type of a
03:41:57 <quicksilver> if that's what you meant by figuring out runtime then you were right, yes :)
03:42:09 <quicksilver> neither
03:42:11 <fracture> and also does it depend on whether the function foo is in the same compilation unit as its callers
03:42:24 <fracture> ah?
03:42:24 <quicksilver> the GHC implementation passes the show function as a hidden parameter
03:42:30 <quicksilver> you can imagine otehr implementations though.
03:42:49 <fracture> if you pass the function as a parameter, that sounds like an indirect call to me (i.e. runtime dispatch)
03:42:57 <fracture> (am I missing something?)
03:43:07 <mcstar> ah, thats the dictionary
03:43:17 <mcstar> a dict of functions for every typeclass
03:43:23 <mcstar> that the parameter of 'foo' has
03:43:30 <fracture> ... sounds like a vtable :-/
03:43:47 <mcstar> fracture: thanks, i think that was my point i wanted to say
03:43:57 <quicksilver> fracture: passing functions as parameters is what you do every single day in haskell
03:43:57 <fracture> (but hey, type classes are pretty cool anyway :)
03:44:01 <mcstar> but i got derailed by myself..
03:44:02 <quicksilver> you don't call it indirect calls
03:44:07 <quicksilver> that's just, having first class functions
03:44:14 <quicksilver> (but yes, of course, it's like an indirect call)
03:44:27 <fracture> I meant indirect call at the machine level; I know laziness involves that a lot, but I was curious if type classes do also
03:44:49 <merijn> I guess this implementation means it can be inlined for fixed types, though
03:44:49 <quicksilver> a dict is a bit like a vtable, yes
03:45:07 <quicksilver> as merijn says this happens all *before* the standard inlining and constant lifting
03:45:15 <mcstar> quicksilver: does this always happen? that at the call site of 'show' in 'foo' it has to look up 'show' from the Show dictioniary?
03:45:21 <quicksilver> so the normal optimisations complete eliminate the dictionary pass
03:45:21 <mcstar> or can THIS be inlined?
03:45:27 <fracture> cool; thanks for clarifying this
03:45:27 <mcstar> or does it matter?
03:45:31 <quicksilver> it gets completely eliminated in almost all common cases
03:45:37 <fracture> ah
03:45:50 <quicksilver> so there is a distinction from the "compilation technique" (of dictionary passing)
03:46:03 <quicksilver> and "code actually generated" - there may well be no dictionaries
03:46:11 <Eduard_Munteanu> mcstar: unless you SPECIALIZE
03:46:15 <quicksilver> because the optimiser has eliminated them like it can with other constant data.
03:46:26 <merijn> fracture: In the "data MyType = V1 Int | V2 String" you could inline the dictionary lookup + function call in the implementation of show for MyType, since the dictionaries never change
03:46:46 <quicksilver> one of the key differences between a dictionary and a vtable is that vtables are stored with the object
03:46:49 <fracture> I see---so to actually predict what's going to happen for a given callsite and a given type class ... I should just look at core or whatever?
03:47:02 <quicksilver> every time (except for entirely non-virtual classes)
03:47:09 <fracture> quicksilver: ah interesting point
03:47:11 <quicksilver> where as a dictionary is never "stored with" the value
03:47:19 <quicksilver> and dictionaries aren't "per value" but "per type"
03:47:21 <fracture> it's a compile-time constant
03:47:25 <quicksilver> yes.
03:47:25 <fracture> neat.
03:47:30 <quicksilver> there is just one String-Show dictionary
03:47:39 <quicksilver> not a vtable for each String object.
03:47:46 <mcstar> ofc
03:47:51 <mcstar> that would be stupid
03:48:05 <quicksilver> it would be 'obviously stupid' if you think about it, yes
03:48:16 <quicksilver> but it's an important failure in the analogy between vtables and dictionaries.
03:48:17 <fracture> it also wouldn't even work:  you can declare new instance declarations for existing types in random modules
03:48:31 <mcstar> quicksilver: but, isnt the dictionary associated with simply Show, a typeclass? (you said String-Show)
03:48:44 <quicksilver> mcstar: no, it's associated with an instance of the typeclass.
03:48:54 <quicksilver> the String instance of Show is one dictionary
03:48:56 <fracture> basically an instance declaration declares the dictionary
03:49:01 <fracture> (I guess?)
03:49:03 <quicksilver> there are other dictionaries which are other instances of Show
03:49:08 <mcstar> quicksilver: oh, ok
03:49:08 <hpaste> merijn pasted “peek/poke simplification?” at http://hpaste.org/74955
03:49:17 <quicksilver> but.. I emphasise .. dictionaries are a compilaton technique, not part of haskell
03:49:17 <Saizan> you can think if the class as declaring the type of the dictionary, and instances as declaring a value of that type
03:49:21 <merijn> I don't suppose there's a way to simplify/cleanup that peek/poke example?
03:49:24 <Saizan> *of the class
03:49:26 <quicksilver> JHC doesn't use dictionary-passing
03:50:02 <mcstar> quicksilver: now this makes more sense to me, as you described this as a compilation techinique
03:50:39 <mcstar> vtables are obviously not
03:50:55 <mcstar> i think they are like a 'compiler done tagged variant'
03:52:51 <fracture> quicksilver: what's jhc do?  always emit specialized code?
03:52:52 <mcstar> ok, this resolves another one of my questoins that i dont have to ask now :)
03:53:05 <Saizan> (btw, i still imagine that unless one gets to declare new classes at runtime all the vtable values are determined statically and it's just the choice of which one a particular value uses that's determined dynamically)
03:54:21 <fracture> Saizan: Yeah.  and technically vtables are only one of the legal strategies (pretty much ubiquitous, though) for implementing C++ virtuals
03:54:21 <mcstar> all classes that have non abstract virtual methods have vtables, that is generated at compile time
03:54:34 <quicksilver> fracture: it passes types themselves
03:54:47 <quicksilver> Saizan: a vtable is just a bunch of pointers to concrete classes
03:55:11 <quicksilver> one per virtual class that you are a descendant of I guess
03:55:16 <quicksilver> maybe there is a way to reduce that numbe
03:56:05 <fracture> it's a pointer to a block of function pointers (not sure what you mean by pointers to classes)
03:57:43 <nikita-0> fracture: a bit more complicated in a case of virtual inheritance (diamond shaped inheritance graph), where the same superclass is inherited through multiple paths.
03:58:00 <fracture> nikita-0: not really, you still just have pointers to functions in implementations I'm aware of
03:58:19 <fracture> (they just read other parts of the object to find the offset of the relevant virtual bases, no?)
03:58:31 <nikita-0> fracture: well, either you generate trampolines for each case, or you store "this delta" along with each pointer.
03:58:33 <fracture> ... err, this isn't #c++ ... oops
03:58:52 <mcstar> sharp-c++?
03:58:59 <quicksilver> fracture: by class I meant "the concrete implementation of a class" which is, of course a bunch of functior pointers to method code, yes.
03:59:13 <fracture> quicksilver: ah makes sense
03:59:19 <fracture> nikita-0: if you mean doing that for all pointers, no one does that
03:59:33 <quicksilver> I'd forgotten you could statically work out the base class offsets
03:59:47 <quicksilver> long time since I've thought hard about how to compile C++
03:59:52 <nikita-0> fracture: gcc used to do this until certain version.
04:00:23 <nikita-0> This is, by the way, the method described in that old Straustrup book.
04:00:30 <fracture> nikita-0: I must be misunderstanding what you mean then---pointers have never been "fat" in gcc
04:00:50 <nikita-0> fracture: sorry, not pointers! vtable entries.
04:01:00 <fracture> ohh ok; yeah you can do that
04:01:03 <fracture> :)
04:01:27 <mcstar> quicksilver: just to put my mind to rest, there ARE situations when that actual dictionary cannot be eliminated at compile time?
04:02:04 <quicksilver> mcstar: oh yes, there certainly are
04:02:18 <quicksilver> mcstar: generally when you have cross-module polymorphism
04:02:41 <quicksilver> so one piece of code is compiled and will be invoked by other code later at unknown types
04:02:57 <quicksilver> "unknown" at the point in time that the first code got compiled
04:03:13 <mcstar> yes, ok, so compiled library code cannot be inlined, thats it?
04:03:20 <quicksilver> not that simple :)
04:03:26 <quicksilver> compiled library code can be and *is* inlined
04:03:42 <quicksilver> but it's not always going to be, there is a threshold for cross-module inlining
04:04:31 <mcstar> what is ths threashold a measure of?
04:05:08 <mcstar> certain number of 'indirections'?
04:05:27 <mcstar> like, when it is called the first time it is inlined, but a call to itselfs isnt
04:05:30 <mcstar> ?
04:05:33 <quicksilver> no, it's a property of the function
04:05:41 <quicksilver> "map" will *always* be inlined
04:05:49 <quicksilver> irrespective of the degree of indirection.
04:06:17 <quicksilver> the compiler puts "small" functions into the .hi file (as source code more-or-less, not as compiled code)
04:06:22 <mcstar> or can this threshold be expressed in typing?
04:06:26 <quicksilver> so they are available for inlining
04:06:32 <quicksilver> no, it's a very heuristic thershold
04:06:37 <quicksilver> it's just about the size of the code
04:06:48 <quicksilver> although there are some other factors (Recursive functions don't inline)
04:06:58 <quicksilver> and there are pragmas to control it.
04:07:08 <quicksilver> and even if a function is available for inlining, it may not be inlined at every call site.
04:07:27 <quicksilver> the inliner is probably the most important single part of the GHC optimisation strategy
04:07:38 <quicksilver> and I don't claim to know every detail of it :)
04:08:05 <mcstar> ok, so this is largely irrelevant for mortals up to a certain point
04:08:43 <quicksilver> it's irrelevant to you until it turns out to matter because your code is slower than you need it to be :)
04:08:46 <mcstar> (as in, it takes some haskell practice, before you should worry about these issues...(
04:10:02 <merijn> If I import "import Foo hiding (bar)" and export "module Foo" will bar be hidden in the exported module?
04:10:52 <fracture> quicksilver: out of curiousity, is there anything else interesting in those .hi files?
04:12:36 <fracture> nm looks like there's some info around online
04:12:57 <fracture> (and apparently --show-iface)
04:14:57 <quicksilver> fracture: their primary purpose is to contain all the types of exported symbols
04:15:09 <quicksilver> fracture: you could consider them 'auto-generated .h files' in that sense.
04:15:25 <quicksilver> but secondarily they also have this inlining info. And probably some other things.
04:15:49 <quicksilver> merijn: I think exporting module Foo only exports the parts you imported, yes.
04:15:54 * hackagebot murmur-hash 0.1.0.6 - MurmurHash2 implementation for Haskell.  http://hackage.haskell.org/package/murmur-hash-0.1.0.6 (ThomasSchilling)
04:20:14 <mcstar> +1 if you look at the source code of the original murmurhash
04:20:19 <mcstar> looked*
04:23:44 <merijn> @pl \x -> f x $ \y -> x
04:23:44 <lambdabot> ap f const
04:23:52 <merijn> :t ap
04:23:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:28:22 <hpaste> timthelion pasted “What causes this?” at http://hpaste.org/74957
04:28:32 <timthelion> Hey, any ideas what might cause such a link error?
04:29:19 <moobull69> good morning/day everyone
04:29:25 <timthelion> mornin
04:30:36 <moobull69> I am trying to get lambdabot installed on my linux system, but seem to be having difficulty with the readline framework. Can anyone offer me some adivce?
04:32:03 <timthelion> moobull69: you'll have to ask johnw when he comes in.  He recently fought through that.  It's non trivial as I understand, to get lambdabot to work.
04:32:33 <moobull69> ooh, ok
04:33:33 <moobull69> non-trivial as in easy? lol
04:33:48 <moobull69> well, ty. Ill wait around and see
04:34:02 <moobull69> probably try googling more in a bit too
04:34:26 <merijn> I don't suppose there's a cleaner to check for a constructor and then name the entire match than aliasing like "r@(Rec _ _ _)"?
04:34:42 <timthelion> moobull69: well, johnw spent like a week or more getting it to work. and I don't think he's stupid.
04:35:07 <timthelion> moobull69: but now that he knows how, he could probably help you.
04:37:09 <t7> timthelion: you missing a static link lib?
04:37:11 <mcstar> > "setting up lambdabot costs this much: " ++ show (7 * 8 * 2000 / 217)
04:37:13 <lambdabot>   "setting up lambdabot costs this much: 516.1290322580645"
04:37:17 <t7> in gcc
04:37:23 <mcstar> dollars that is
04:37:33 <timthelion> t7: is there a good way to find out what lib I'm missing?
04:37:51 <t7> let me check
04:38:22 <timthelion> t7: Also, I don't really understand why ImplicitCAD would be requiering anything unusual. it uses some extentions, but it's really quite vanilla.
04:38:44 <mcstar> timthelion: ldd
04:38:54 <t7> hmm the cabal file doesnt look suspicious
04:38:59 <t7> i duno
04:40:53 <mcstar> oh, link error, then you dont yet have an exe
04:40:54 <timthelion> mcstar: So I should go into ImplicitCAD/dist and run ldd on the .so files?
04:41:11 <mcstar> no, it lists the dynamic libs an exe needs
04:41:15 <timthelion> mcstar: ImplicitCAD compiles fine, but when I import things from it, then I get those.
04:41:15 <mcstar> so not really applicable
04:41:29 <timthelion> Even in ghci I get these errors.
04:42:00 <timthelion> like if I start ghci and type "import Graphics.Implicit.Primitives" and then try to use a function from there I get a link error.
04:42:06 <mcstar> possibly, the compiler doesnt know to link with that lib, that those referenced functions live in
04:42:49 <mcstar> timthelion: you can add the path of that implicit cad .so lib, to LD_LIBRARY_PATH
04:43:44 <mcstar> that would solve the ghci issue
04:44:10 <timthelion> mcstar: I actually don't see any .so's in dist, and it's installed with cabal, so I don't see why cabal wouldn't have done that for me.
04:45:34 * timthelion has recompiled all of cabal, even with default config, deleted the ImplicitCAD directory and recompiled that. ect.  Nothing has helped.  Even reported a ticked to trac over a week ago, but the GHC devs seem to be on vacation.
04:47:47 <mcstar> ok, so i think then ghci can load object files
04:54:28 <gienah> timthelion: you can try running: ldd -r libsomething.so
04:54:54 <gienah> timthelion: to check if it has all its required libraries specified as NEEDED
04:55:16 <gienah> timthelion: where on linux you can display the NEEDED libs with: scanelf -n libsomething.so
04:55:32 <mcstar> cabal compiles a .a static lib archive and an object file .o for ghci
04:55:54 <mcstar> (i think...)
04:56:25 <gienah> timthelion: to demangle the symbol names you can do:  echo 'implicitzm0zi0zi2_GraphicsziImplicitziExportziTextBuilderUtils_zdwbuildTruncFloat_info' | c++filt
04:58:40 <timthelion> gienah: c++filt seems to be the id function here.
04:58:43 <timthelion> at least on that string
04:59:13 <timthelion> and as I have discovered, there are no .so's just .o's.
04:59:16 <timthelion> and .a's
04:59:16 <lpsmith> haskell-mode works suprisingly well for editing inline SQL
04:59:18 <timthelion> and .hi's
04:59:32 <lpsmith> not perfect,  but actually not too bad
04:59:33 <mcstar> timthelion: im building the deps right now
05:01:59 <mcstar> there are some library issues mentioned on the github page
05:02:24 <timthelion> mcstar: I saw that.  And tried that .but the error is different, and the fix does nothing for me.
05:02:41 <mcstar> lets see if i can reproduce
05:02:51 <mcstar> lol
05:03:02 <mcstar> i dont mean me, but if i can reproduce the error
05:05:34 <franco00> "I am ashamed of myself question" of the day: I cannot find for the love of god a .hs file (I probably removed it), but I have the .o and .hi . Is there a way to recover the code?
05:05:52 <mcstar> no
05:06:03 <franco00> It was not very long but, well, I thought to ask.
05:06:06 <timthelion> mcstar: the version from git works for you?
05:06:13 <mcstar> timthelion: in progress
05:06:17 <lpsmith> You could recover the types from the .hi file
05:06:21 <lpsmith> that's about it
05:06:31 <gienah> timthelion: sorry seems everything I wrote is irrelevant to your problem
05:06:35 <Saizan> .hi files might have some code
05:06:46 <Saizan> use ghc --show-iface foo.hi
05:06:49 <timthelion> gienah: happens :P
05:06:53 <mcstar> franco00: your best bet is trash/or data recovery
05:07:05 <mcstar> files arent 'deleted' just unlinked
05:07:34 <lpsmith> unless you call shred,  on a non-COW filesystem.   Then they really are gone
05:07:48 <mcstar> :)
05:07:49 <merijn> This is why you make backups :p
05:07:51 <mcstar> unless
05:07:53 <timthelion> mcstar: the minimum test case is ghci \n import Graphics.Implicit.Primitives \n rect3R 0 (0,0,0) (0,0,0)\n
05:08:23 <merijn> Most of my development I do in my dropbox folder anyway, so even if I forget to commit and delete I can usually still recover from there :p
05:09:20 <timthelion> mcstar: hehe, unlinked.  One time a guy threatened to phisically harm me if I didn't delete a photo from my camera...  I didn't have to think twice about that one :D
05:09:33 <mcstar> :)
05:11:24 <mcstar> actually, this makes me wonder if the deletion progress bar is just for show
05:11:45 <timthelion> mcstar: I don't know. rm is quite quick here.
05:11:49 <mcstar> i dont have any recent hardware, but i remember that deletion took time in the old days
05:12:11 <timthelion> mcstar: the other thing, is that it has to check if the resource is locked.
05:12:14 <mcstar> i mean, like on phones/cameras
05:12:23 <quicksilver> I think it has to unhook each block
05:12:28 <quicksilver> I'm not sure.
05:12:36 <mcstar> and those had fat usually
05:12:43 <quicksilver> deleting multi-gigabytes files takes an appreciable time on ext2 as well
05:12:54 <merijn> mcstar: On which platform?
05:13:06 <merijn> Windows deletion is extra slow because windows can't delete files that are in use
05:13:10 <mcstar> merijn: old digital camera? idk what platform that is
05:13:28 <merijn> mcstar: Oh, those are FAT, those are also quite slow usually
05:13:37 <quicksilver> I think on ext2 you have to mark each inode
05:13:44 <mcstar> yeah, but i was just following up on timthelion's comment
05:13:56 <mcstar> on deleting something, because he was sure he could recover it
05:14:37 <timthelion> merijn: linux actually also has locks on files.  It's just that they aren't normally enforced in userspace because sometimes you actually WANT two programs to have access to a file at the same time.
05:14:56 <franco00> mcstar: ok thanks
05:16:09 <mcstar> timthelion:     Could not find module `Graphics.Implicit.Primitives'
05:16:12 <mcstar>     it is a hidden module in the package `implicit-0.0.2'
05:16:16 <merijn> timthelion: Posix locks are optional an unenforced
05:16:41 <merijn> timthelion: i.e. the kernel doesn't care that files are locked when deleting them
05:16:57 <timthelion> merijn: Ah yes, sorry I meant import Graphics.Implicit
05:17:03 <timthelion> you don't need the Primitives there.
05:17:36 <merijn> Linux will happily run "rm song.mp3" while your mediaplayer is playing, Windows will refuse and complain to delete
05:17:54 <merijn> (Which can make it very tedious to remove files that are opened by a process at boot)
05:18:15 <mcstar> it makes some sense to refuse deletion of open files
05:18:18 <timthelion> merijn: yes, but they CAN be locked.  For example, /dev/dsp is locked by the program that is currently writting to it.
05:18:31 <mcstar> but i guess, your music player doesnt keep the file actually open
05:18:37 <timthelion> merijn: seems like a great way to make a non-deletable malware :D
05:18:49 <merijn> timthelion: Not portably, afaik
05:18:58 <gienah> timthelion: I see in your earlier output that it used: ghc Solenoid-holder-long.hs it should create a .cabal file to import the library, or maybe ghc --make with an option to import the library might work
05:19:04 <merijn> timthelion: Like I said, posix file locks are optional and can be ignored
05:19:29 <christiaanb> anybody present that got to build a recent version of ghc-HEAD on OS X?
05:19:42 <Spockz> Is it in general possible to define (sensible) Show instances for something in the ArrowChoice class?
05:19:44 <timthelion> gienah: you mean I *must* use cabal?
05:19:47 <mcstar> timthelion: ok, reproduced
05:20:06 <mcstar> timthelion: the problem is solvable
05:20:08 <mcstar> hang on
05:20:15 <timthelion> mcstar: thanks
05:20:22 <quicksilver> Spockz: it is not possible to define sensible show instances for any arrow
05:20:22 <gienah> timthelion: well, no, but it might be easier. maybe ghc --make with some option to import the library might work
05:20:29 <quicksilver> Spockz: Choice or not.
05:20:35 <mcstar> merijn: "but i guess, your music player doesnt keep the file actually open"
05:20:41 <Spockz> quicksilver: well if you leave out showing functions ofc
05:21:31 <merijn> mcstar: It does, linux will mark open files that have been deleted in the kernel. The space will be freed when the last handle on said file is closed
05:21:42 <merijn> mcstar: But in the mean time it is already gone from the directory tree
05:21:46 <timthelion> mcstar: how do I solve the problem?
05:22:10 <merijn> Windows on the other hand insists on *immediately* freeing space when a file is deleted and so can't delete open files
05:22:25 <mcstar> timthelion: i said hang on
05:22:41 <timthelion> merijn: what?  you're saying that linux actually uses a reference counting GC for files???
05:23:12 <merijn> Eh, yes?
05:23:17 <merijn> Why wouldn't it?
05:23:44 <timthelion> merijn: it just seems rather surprising to me, that someone put so much thought into architecting file removal.
05:24:27 <jtza8> timthelion: It makes sense once you consider the many weird things people do with them.
05:24:40 <merijn> timthelion: inodes have a reference fields (indicating how many links exist to them in the file hierarchy, i.e. when you hardlink files) and an open field (indicating the number of file handles relating to that inode)
05:24:43 <newmind> thats a pretty simple solution
05:24:52 <newmind> compared to the alternatives
05:25:04 <timthelion> merijn: and furthermore, I was under the impression, that such GC's were rather new.  Like Java for example, is too old to have a proper reference counting GC, which is one of the reasons it sucks...  So I assumed they were some new thing that came long after linux standardized it's file management behavior.
05:25:10 <merijn> timthelion: If (fs references == 0 && open handles == 0) then delete inode
05:25:47 <newmind> you don't actually have to have to "delete" anything
05:25:50 <quicksilver> timthelion: "proper" "reference counting" "GC"
05:25:56 <quicksilver> timthelion: these words make a strange phrase.
05:25:57 <merijn> This behaviour is older than linux itself, reference counting is simple when you have guaranteed mutual exclusion
05:25:58 <newmind> just make sure it can be overwritten in the future
05:26:13 <quicksilver> reference counting is a simplistic memory strategy which most people don't consider "true" GC
05:26:15 <merijn> newmind: Which means marking all blocks in the file as free and freeing the inode in the inode table
05:26:21 <quicksilver> what would 'proper reference counting GC' be?
05:27:10 <timthelion> quicksilver: I actually realised,after I wrote that, my statement about Java is factually incorrect.  Java does count references. but it does so after the fact. it looks through all memory at idle time counting references and freeing the stuff that is no longer needed. Where as a modern GC just keeps a list for each reference and free's imediately.
05:27:14 <merijn> timthelion: The problem with reference counting in a programming language setting are the fact that you can have races and cyclical references
05:27:47 <merijn> timthelion: Modern GC's are a mix of track/trace (what you just described for Java) and ref counting
05:27:57 <newmind> java does a bit more than simple reference counting
05:28:05 <quicksilver> timthelion: that seems like a broadly incorrect description.
05:28:09 <newmind> at least the common JVMs
05:28:22 <quicksilver> the sun JVM has always done "proper" GC (that is, not refcounting)
05:28:28 <mcstar> timthelion: Haskell test results in module is not loaded: 'Graphics.Implicit' (./Graphics/Implicit.hs)
05:28:32 <quicksilver> although certainly the strategy has been refined over the years.
05:28:39 <merijn> timthelion: And your description of Java's GC is high level to the point of being ridiculously wrong
05:28:58 <mcstar> from the github site, thats the error that you get when trying to work with ghci from the cloned firectory
05:29:01 <mcstar> directory*
05:29:03 <quicksilver> timthelion: "keeping a list for each reference and freeing immediately" is a terrible idea, by the way
05:29:12 <quicksilver> don't think any real language works that way.
05:29:29 <quicksilver> perl keeps a count for each reference (but not a list, just the count)
05:29:31 <mcstar> timthelion: btw, can you BUILD simple examples?
05:29:33 <quicksilver> that's why it's called refcounting.
05:29:44 <quicksilver> most other languages do a 'true' GC.
05:30:03 <timthelion> mcstar: sorry, I'm trying to read what you're saying through the flood.  It's tricky...
05:48:12 <vikt0r0> merijn: Hey :) I read the sigfpe paper yesterday, and I am currently doing an assignment where I have to define a monad that should be capable of error handling and maintain some state. It made sense how to do this in the sigfpe paper, but I am having a hard time working out what type it should have in this case. Do you have time to have a look at it?
05:52:57 <ski> @unmtl ErrorT e (StateT s m) a
05:52:57 <lambdabot> s -> m (Either e a, s)
05:52:59 <ski> @unmtl StateT s (ErrorT e m) a
05:52:59 <lambdabot> s -> m (Either e (a, s))
06:03:35 <vikt0r0> vikt0r0: asdf
06:04:07 <mcstar> cabal+hackage is better than asdf imho
06:04:25 <mcstar> but you should compare it to quicklisp,really
06:06:43 <vikt0r0> mcstar: Wholeheartedly agree, but I was just testing notifications for my new client… sorry for the confusion :-)
06:09:10 <mcstar> it was a lame joke
06:09:51 <mcstar> vikt0r0: some more notifications
06:10:25 <kstt> hello
06:11:29 <vikt0r0> mcstar: It works!
06:11:51 <vikt0r0> vikt0r0: lol, found it funny nevertheless
06:12:01 <vikt0r0> mcstar: whoops.
06:12:23 <kstt> I have a weird request : it is possible to bundle an external file into a haskell binary, as a bytestring, and use it as such at runtime ? I would really like to distribute a tool as a single, self-contained executable, but there are a couple of small images that should be bundled to it.
06:12:49 <mcstar> base64 encoding
06:13:01 <kstt> well, ideally I'd like to avoid doing that by hand
06:13:17 <mcstar> dont do it by hand then
06:13:29 <kstt> nice idea :) can cabal do that for me ?
06:13:35 <tibbe> kstt: you could probably do it using TemplateHaskell
06:13:38 <mcstar> i wouldnt, encoding/decoding can be really tiresome
06:13:46 <tibbe> kstt: which would allow you to read a file at compile time
06:14:26 <mcstar> if you want to use it at runtime, then, just read it back and decode at runtim
06:14:28 <mcstar> e
06:14:34 <kstt> ah of course tibbe ! thanks, I didn't think of TH, but that's probably the best bet
06:15:19 <kopi> Hi.What would be best CPU for compiling (Haskell).:)
06:15:26 <quicksilver> kstt: you could use a modern OS which has a sensible way of bundling files with applications *ducks*
06:15:40 <mcstar> i dont understand
06:15:47 <mcstar> why TH if you want it at Runtime?
06:15:58 <quicksilver> mcstar: he wants it physically part of the executable
06:16:04 <quicksilver> so the compiler must bundle it
06:16:05 <kopi> i allready have six cores Thuban OC at 4.2
06:16:12 <quicksilver> ...so the bundling happens at compile time.
06:16:14 <mcstar> you can just use a CAF string for that
06:16:32 <mcstar> image = "sdafw86f7as5f43da673fas"
06:16:34 <quicksilver> indeed. The question is the best way to turn an external file into a CAF, I think.
06:16:40 <mcstar> now decode at runtime, and display it
06:16:41 <quicksilver> and the answer is that TH may be a convenient solution.
06:16:51 <quicksilver> there are some packages on hackage which do just this, also.
06:17:53 <kopi> and also gentoo or slackware for Haskell development, source based distros
06:18:06 <kstt> quicksilver: ah, I'd be interested to use a ready-to-use solution, could you name some packages please ?
06:18:17 <tibbe> kstt: other ways to bundle data with applications (without being embedded) is by using Cabal's data-files mechanism
06:18:20 <kopi> any got experince with it which one is better more up to date packages
06:18:54 <tibbe> kstt: data-files will be installed together with your package and you can find them using the special YourPackageName_Paths module Cabal compiles for you.
06:18:59 <mcstar> kopi: ghc only works really well above 8 cores :(
06:19:21 <quicksilver> kstt: http://hackage.haskell.org/package/file-embed
06:19:26 <quicksilver> I think there was another.
06:19:29 <kopi> so only 8 cores
06:19:32 <kstt> quicksilver: as for the modern os problem, I don't have much influence on the platform of the users
06:19:34 <kopi> nothing above that
06:19:43 <mcstar> around 8
06:19:46 <mcstar> 8-12
06:19:51 <mcstar> thats really good
06:19:54 <kopi> hmm
06:20:00 <moobull69> anyone familiar with installing lambdabot?
06:20:17 <kstt> tibbe: good track, I will read some documentation on it right now, thank you
06:20:24 <kopi> i wished to install 4 opteron 12 cores
06:20:24 <mcstar> i certainly wouldnt bother with programming in haskell on less than 6 cores
06:20:28 <tibbe> kstt: you're welcome
06:20:34 <kopi> for a server platform
06:20:37 <Saizan> moobull69: it's a mess, but you can find some experiences by googling i believe
06:21:18 <kopi> where i can read more about it, comiling speed up
06:21:24 <kopi> *compiling
06:21:32 <quicksilver> kopi: GHC only uses one core to compile.
06:21:47 <kopi> :(
06:21:49 <quicksilver> haskell code compiled by GHC may well be written to benefit from more
06:21:57 <quicksilver> but GHC is a singlethreaded design, IO aside.
06:22:08 <kopi> hmm
06:22:19 <quicksilver> what are you doing in which compile time matters?
06:22:54 <kopi> im just buidling the hardware and distro a friend of mine wantet to build such machine
06:23:03 <kstt> the fact that GHC is imperative at its core is quiet surprising, given that GHC is often cited as a reference haskell software
06:23:03 <kopi> to speed up comiling time
06:23:05 <typoclass> kopi: the haskell compiler ghc is fine with 1 or 2 cores, just as it is fine with 6 or 8 cores. what mcstar is saying is wrong. it's probably meant to be a joke
06:23:25 <mcstar> you can certainly compile something at parallel on 12 cores, and see, if they produce the same output, to be absolutely certain..
06:23:40 <quicksilver> kstt: in what sense is GHC imperative at its core?
06:23:54 <kopi> can you speciffy at comping time to only use 1 core
06:23:59 <mcstar> typoclass: you look right through me
06:24:02 <kopi> so i can see if there is a differnece
06:24:07 <Expez> One of the functions, like 3 layers down, really needs a RNG. Is my best option to use the state monad to keep the seed value?
06:24:56 <kstt> quicksilver: IIUC, in the sens that it is hard to parallelize code paths
06:25:22 <typoclass> kopi: the simplest would be to run 'top' while compiling. it will tell you if the cpu is near 100% (= 1 core in use), or 200%, or 400% (2 or 4 cores in use)
06:25:23 <mcstar> Expez: you can pass a list of an infinite random list
06:25:48 <Saizan> kopi: see the +RTS options, ghc +RTS -N1 -RTS ... should do
06:25:56 <kopi> ah ok will do that and report back..:)
06:26:08 <kopi> Thanks everyone.:)
06:26:38 <mcstar> kopi: hey, sorry, but asking 'what would be the best cpu for haskell' is idk, weird
06:26:49 <kopi> :P
06:27:09 <Phlogistique> is any of the "fancy" Haskell GUI toolkits (using FRP) mature and documented enough to start using it quickly?
06:27:39 <quicksilver> kstt: "single-threaded" != "imperative"
06:27:47 <mcstar> Phlogistique: did you see the reactive banana + wxwidgets examples?
06:27:52 <mcstar> worth checking out
06:27:57 <Expez> mcstar: But then I would have to thread that list through 3 functions down to where it's actually consumed. Basically the same as threading a generator through entire program, no?
06:28:05 <timthelion> Phlogistique: Well, http://hackage.haskell.org/package/sodium is mature and well documented. It is not toolkit specific.
06:28:06 <quicksilver> kstt: the fast majority of functional code - for example, every possible haskel2010 program - is notionally single-threaded. They are not imperative.
06:28:08 <kstt> quicksilver: fair enough
06:28:17 <mcstar> Expez: well, yes
06:28:34 <timthelion> mcstar: reactivebanana is not mature!
06:28:37 <Phlogistique> 15:27:23 < mcstar> Phlogistique: did you see the reactive banana + wxwidgets examples? <- never looked into them too deeply; I'll do so
06:29:08 <mcstar> timthelion: he meant, if the widget toolkit is mature
06:29:12 <mcstar> not the frp part
06:29:19 <kstt> however, please explain why every possible haskell2010 program is "notionally" (?) single-threaded ?
06:29:34 <quicksilver> kstt: it *is* very embarassing that GHC uses mutable state hacks deep wthin its compilation mechanism even though haskell is meant to be a great language for writing compilers :)
06:29:53 <quicksilver> kstt: haskell2010 has no parallelism or concurrency features.
06:30:08 <quicksilver> forkIO and `par` are both GHC extensions.
06:30:33 <kstt> ok, I thought forkIO was a standard primitive
06:30:51 <kstt> I understand your point now
06:31:14 <typoclass> forkIO is considered ugly now?
06:31:22 <timthelion> typoclass: no, not at all :)
06:31:25 <quicksilver> not by me.
06:31:49 <typoclass> ok, just sounded like that for a minute
06:32:13 <timthelion> typoclass: it's simply not in the standard(though the standard is bad)
06:32:35 <kopi> I used this example
06:32:36 <kopi> http://www.haskell.org/haskellwiki/Performance
06:32:45 <kopi> ghc -O2 --make InsertMillionElements.hs && time ./InsertMillionElements +RTS -K100M
06:32:51 <kopi> is o2 how many cores
06:32:55 <Expez> mcstar: Isn't that 'ugly'? All the exported functions in this one module will have to take this list of randoms / generator as an argument whereas it's only being used in a single 3 line function.
06:33:29 <kopi> executing the programm is great uses all cpu cores 99%
06:33:42 <quicksilver> kopi: GHC itself is single-threaded.
06:33:51 <quicksilver> kopi: compilation is therefore single-threaded.
06:33:55 <quicksilver> I already said this once.
06:33:59 <kopi> ok
06:34:11 <kopi> Thanks.:)
06:34:22 <quicksilver> Expez: it would be much uglier if your functions weren't actually functions
06:34:29 <quicksilver> (because they had randomness in)
06:35:09 <mcstar> it might be ugly
06:35:21 <mcstar> maybe you can structure your code better
06:35:22 <typoclass> Expez: alternatives to passing an argument are State (as you pointed out) and implicit parameters. also, you could perhaps pass the list of random numbers to the function that needs it, then pass that function around
06:35:24 <Expez> quicksilver: This is true, but I was hoping I could use some kind of abstraction to hide the generator away.
06:35:48 <quicksilver> there are all kinds of abstraction
06:35:52 <quicksilver> they all involve changing the type
06:35:56 <mcstar> but then necessarily means monands afaik
06:36:00 <quicksilver> and really they're all adding another parameter behind the scenes
06:36:14 <quicksilver> that can just be more-or-less hidden by the type itself
06:36:22 <quicksilver> and by using monadic operators
06:36:47 <mcstar> thats the highlight of pure functional programming you either see the state, or see it in the type
06:37:20 <Expez> Neither way of doing it is considered a better style?
06:37:37 <quicksilver> just use the one which feels most lightweight in the context you're in
06:37:51 <quicksilver> understanding both options is a valuable thing
06:38:00 <quicksilver> trying them both might be educational :)
06:38:26 <Expez> Guess I'll try the state monad then, never used it before
06:38:38 <mcstar> maybe, if you pass other things around too, you can make the random seed or list part of that
06:39:48 <Expez> yeah, I thought about that, but the data structure the functions are working on is huge. The overhead in creating a new one everyone time the seed gets updated is proably too big.
06:40:03 <quicksilver> probably not as big as you imagine
06:40:05 <mcstar> it wont
06:40:08 <quicksilver> what kind of structure is it?
06:40:09 <mcstar> well, depends
06:40:11 <typoclass> Expez: if you only want to read (not write) those extra variables, you can use the Reader monad, aka environment monad. once changing the variables is necessary, use State
06:40:18 <mcstar> but if its a simple record update, thats ok
06:41:01 <Expez> The biggest part of the data structure is a 1000x1000 matrix of doubles heh
06:41:11 <mcstar> bigRecord {lengthyStuff :: Array... , randomList :: [Int]}
06:41:44 <Expez> typoclass: thanks for the tip
06:42:06 <mcstar> it is necessary to 'change' the variables
06:42:16 <SLi> Occured to me after forgetting to commit a module containing only a class definition to a VCS and thus causing grief to others: Is it so that class definitions (save for default implementations of functions) can always be fully deduced from code that uses them?
06:42:40 <mcstar> i dont see any benefit of introducing a monad just to have random numbers in an otherwise pure code
06:44:01 <Expez> mcstar: updating this record is cheap even though it contains this gigantic matrix?
06:44:08 <typoclass> mcstar: as far as i can tell, the issue is 'passing around' things without actually passing them around as arguments. Reader seems like a common solution for that.
06:44:25 <Botje> Expez: is your matrix [[Int]]
06:44:29 <Saizan> Expez: yeah, the record has just a pointer to the matrix
06:44:30 <t7> :t lookup
06:44:31 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:44:42 <t7> :t find
06:44:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
06:44:51 <Expez> Botje: Matrix from the hmatrix package
06:45:04 <Expez> Saizan: aha, makes sense
06:45:07 <Botje> okay
06:45:07 <mcstar> Expez: ofc, thats why i recommended it, the matrix doesnt change
06:46:06 <Expez> Aight, thanks for all the help!
06:46:18 <quicksilver> mcstar: [benefit of introducing the monad] - it can prevent certain kinds of coding errors
06:46:24 <Expez> This channel is part of making Haskell awesome :)
06:46:27 <mcstar> typoclass: but you have to change it on each 'read', cause either you have to have a seed that changes on each new random number, or a list of random numbers, that you keep un-consing, can you do that with Reader?
06:46:28 <quicksilver> where you accidentally return the wrong seed
06:46:42 <quicksilver> (the old one, say)
06:46:56 <quicksilver> and it means you don't have to manually handle the s, s', s'', etc.
06:46:59 <mcstar> but makes the code imho unglier
06:47:03 <quicksilver> sometimes, yes.
06:47:14 <quicksilver> it is certainly a trade-off
06:47:22 <quicksilver> but there *is* a benefit, along with the cost.
06:47:36 <quicksilver> one version of GHC was release with a serious bug caused by using s'' instead of s'
06:47:37 <mcstar> ok, but as i said i didnt see it
06:47:43 <quicksilver> (manually threaded 'state' variable)
06:47:44 <mcstar> now, thanks for pointing out
06:47:50 <mcstar> (im not sold on it)
06:47:56 <quicksilver> other way around. s' instead of s''.
06:48:27 <mcstar> if haskell bidings werent recursive by default...
06:48:40 <mcstar> actually im glad they are
06:48:48 <dmwit> > "\x50\x72\x6f\x50\x75\x6b\x65\x20\x69\x73\x20\x61\x77\x65\x73\x6f\x6d\x65"
06:48:49 <lambdabot>   "ProPuke is awesome"
06:48:50 <typoclass> mcstar: in the case you describe, yes, you'd need more than reader. he didn't paste code, but as far as i understood him, he needs one infinite list somewhere, which could be done with Reader
06:48:55 <dmwit> ...okay
06:49:09 <t7> :t indexOf
06:49:10 <lambdabot> Not in scope: `indexOf'
06:49:13 <t7> :t indexof
06:49:14 <lambdabot> Not in scope: `indexof'
06:49:18 <t7> @hoogle index
06:49:18 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
06:49:18 <quicksilver> typoclass: but if you  want to 'uncons' from the infinite list you need to return the tail somewhere
06:49:18 <lambdabot> Data.Data indexConstr :: DataType -> ConIndex -> Constr
06:49:18 <lambdabot> Control.Exception.Base IndexOutOfBounds :: String -> ArrayException
06:49:27 <typoclass> quicksilver: yes
06:49:27 <mcstar> in ocaml, ppl just redefine variables with the same name, but different type
06:49:28 <quicksilver> typoclass: otherwise everything which wants a random number gets the 'head'
06:49:31 <quicksilver> and that's then more than reader
06:49:35 <quicksilver> the bit that returns the tail.
06:49:42 <quicksilver> reader + returning the tail === state
06:49:45 <mcstar> like a string is 'n' and after i read an int from it, id also call it 'n'
06:49:46 <typoclass> quicksilver: yes, absolutely
06:49:48 <mcstar> thats super confusing
06:58:47 <Sculptor> yo
07:00:58 <byorgey> hi Sculptor
07:01:18 <Sculptor> hello
07:12:20 <mcstar> i reached the right end of the world
07:12:23 <mcstar> took half a day
07:13:39 <mcstar> (xkcd, if it wasnt clear from the context)
07:16:02 <timthelion> mcstar: some people actually scooped the images. so you can now find the hole world as one picture.  And btw, -blah
07:17:08 <mcstar> (i got aggrevated, and had to stop dragging it, in the morning)
07:22:35 <bford> is anyone using protocol-buffers?
07:24:11 <Guest88> @help
07:24:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:24:20 <merijn> bford: PResumably someone is, but you might get more useful answers when you ask a specific question
07:24:39 <byorgey> hi Guest88
07:25:01 <Guest88> hi
07:26:02 * hackagebot sssp 1.0.0 - HTTP proxy for S3.  http://hackage.haskell.org/package/sssp-1.0.0 (JasonDusek)
07:26:12 <bford> merijn, it always seems abrupt to just dive in and start asking :-). My question however is that hprotoc doesn't seem to work with protocol buffers extensions
07:27:07 <byorgey> Guest88: trying you a haskell? =)
07:27:13 <byorgey> Guest88: feel free to ask any questions in here
07:29:21 <mcstar> byorgey: lower your voice
07:30:14 <byorgey> mcstar: SORRY, IS THIS BETTER
07:30:35 <mcstar> dont shout
07:31:00 <mcstar> i was thinking about asing him, if he wants to learn haskell
07:31:04 <mcstar> asking*
07:35:06 <mcstar> anyone reading this blog: http://prog21.dadgum.com/ ?
07:36:02 * hackagebot lojbanParser 0.1.2 - lojban parser  http://hackage.haskell.org/package/lojbanParser-0.1.2 (YoshikuniJujo)
07:36:04 * hackagebot lojysamban 0.0.6 - Prolog with lojban  http://hackage.haskell.org/package/lojysamban-0.0.6 (YoshikuniJujo)
07:36:22 <nand`> no, but this quote is hilarious: “In the early 1990s, Forth creator Chuck Moore had an epiphany and decided that interactively hex-editing 32-bit x86 machine code was the way to go. (After writing an entire chip layout package this way he realized there were some drawbacks to the scheme and reverted to designing languages that used source code.)”
07:36:32 <mcstar> seems like an-assembly-game-programmer-in-the-80s-turned-high-level-programmer-even-used-haskell-changed-his-mind-and-doesnt-find-functional-programming-that-useful-anymore person
07:39:44 <MostAwesomeDude> Chuck Moore?
07:39:47 <bford> mcstar, he's written some stuff in favour of FP too
07:40:19 <frerich2> mcstar: http://xkcd-map.rent-a-geek.de/ <-- may be interesting to you
07:41:16 <mcstar> he did, but sort of turned on them
07:41:30 <mcstar> like saying: in the end, for a big project, you always need a back door
07:41:38 <mcstar> rather, escape hatch
07:42:40 <mcstar> which here means, solving some unexpected complication with global variables, mutable state..
07:42:57 <mcstar> without re-architecturing the whole of the software
07:44:43 <mcstar> frerich2: is it supposed to freeze my chromium
07:44:46 <mcstar> ?
07:44:48 <parcs`> that's a great blog
07:45:07 <mcstar> parcs`: i found it quite shallow
07:45:17 <frerich2> mcstar: It works with Chrome :) It's the entire xkcd image in one big zoomeable on-demand loaded view. Lots of easter eggs hidden.
07:45:27 <mcstar> maybe his conclusions are spot on, idk, but theres little with which he backs them up
07:46:04 <nand`> I see an entirely blank page on frerich2's link
07:46:39 <mcstar> parcs`: any comments on this?
07:47:46 <Clint> nand`: http://www.mrphlip.com/xkcd1110/ may be better for you
07:48:51 <nand`> Clint: yes, I see something on that page
07:49:36 <mcstar> (the original is great, id use it in Anger Management courses)
07:49:55 <hpaste> t7 pasted “t7's awesome c compiler” at http://hpaste.org/74959
07:49:55 <bford> my mistake on hprotoc - it seems to be imports that are tripping it up - I'm sure this used to work!
07:53:40 <mcstar> what is C about that?
07:54:19 <merijn> hmm, I seem to have found some way of constantly crashing Haddock with GHC 7.6...
07:54:31 <quicksilver> mcstar: well it is a subset of C
07:54:44 <mcstar> doesnt look like C
07:54:54 <mcstar> the one in the comment does :)
07:54:59 <quicksilver> exactly.
07:55:20 <quicksilver> it is a compiler for the subset of C with functions, local variables, but the only statement is return and the only operator is +.
07:55:21 <mcstar> that code uses a human to turn the C comment into haskell
07:55:28 <mcstar> and then compiles it to asm
07:55:33 <quicksilver> not into haskell, no
07:55:35 <quicksilver> into an AST
07:55:38 <quicksilver> but that's just parsing
07:55:38 <merijn> t7: You're not encoding type information in your AST types!
07:55:41 <quicksilver> parsing is trivial.
07:56:09 <quicksilver> (oh add "and all variables are int" to my previous list)
07:57:24 <t7> merijn: i am, everything is an int32
07:59:12 <mcstar> i think it would be cumbersome to write C directly as an AST
07:59:30 <quicksilver> mcstar: sure.
07:59:44 <quicksilver> but I think t7 is at this moment interested in code gen.
07:59:54 <mcstar> you could make a monad, that would resemble C semantics, right?
07:59:57 <mcstar> and make a little dsl
07:59:59 <quicksilver> once you have an AST structure it is not a hard job to write a quick parser.
08:00:11 <quicksilver> the IO monad already does resemble C semantics
08:00:16 <quicksilver> depending what you think you mean by that :)
08:00:28 <quicksilver> but yes you can specifically model some aspects of the language in a DSL certainly
08:00:37 <mcstar> like adding types, and pointer semantics
08:02:02 <quicksilver> yes, if you want to support the (void*) cast then you need your own little oasis of types
08:02:04 <t7> if i was gonna redo C there would be no implicit casting
08:02:13 <t7> and there would be type inference with type classes
08:02:23 <mcstar> what i dont like in that code, is how the strings representing asm instructions are directly intertwined with the logic of address computation
08:03:12 <t7> mcstar: i should have done an x86 DSL for my 20 line haskell thing?
08:03:22 <merijn> t7: And pure functions! And GC! And...haskell?
08:03:44 <mcstar> t7: dont take it the wrong way, im more of beginner than you probably
08:03:56 <fmap> What's the relationship between Fix (as in `newtype Fix f = Fix (f (Fix f))') and Free (as in `data Free f a = Pure a | Free (f (Free f a))')?
08:03:59 <t7> Nah no gc. and mutation is ok
08:04:32 <MostAwesomeDude> fmap: The most interesting difference is that Free is a Monad if f is a Functor.
08:05:05 <ski> merijn : keeping track of initialization states, and by-reference expressions
08:05:38 <MostAwesomeDude> fmap: edwardk had a series of blog posts investigating the properties of Free. Check out comonad.com/reader
08:06:26 <hpaste> merijn pasted “unhelpful haddock error” at http://hpaste.org/74960
08:06:47 <fmap> MostAwesomeDude: okay, thanks
08:07:39 <merijn> Haddock is being most unhelpful in its error reporting :\
08:07:53 <scshunt> edwardk: did you take out Data.Map.Lens for the reasons we discussed?
08:08:21 <MostAwesomeDude> fmap: http://comonad.com/reader/2008/monads-for-free/ for example.
08:08:27 <edwardk> scshunt: because all of its functionality was moved into Control.Lens? yes
08:08:30 <rwbarton> fmap: https://personal.cis.strath.ac.uk/robert.atkey/interleaving.pdf should be relevant
08:08:31 <scshunt> oh, it was?
08:08:49 <typoclass> merijn: do you have information what file it is choking on?
08:09:01 <edwardk> at, traverseAt, traverseMin, traverseMax, traverseWithIndex are all generalized
08:09:14 <merijn> typoclass: Nope, before then it prints a few module names and then that error
08:09:43 <typoclass> merijn: hm ... strace?
08:10:41 <merijn> typoclass: How do I strace a program that I don't manually run?
08:10:50 <merijn> I'm just calling "cabal install"
08:11:05 <nand`> Fix is like an infinite composition of functors; Free on the other hand can come to an end; eg. Fix ((,) a) is like an infinite list of ‘a’s; whereas Free ((,) a) is like [a]
08:12:13 <nand`> sorry, Free ((,) a) () is like [a]
08:12:13 <geekosaur> strace -ff cabal install
08:12:54 <typoclass> merijn: man strace suggests the switch -f makes it also strace all the children. alternatively, try making cabal more verbose so that it tells you the exact commands it's running
08:13:29 <mcstar> "You shouldn't be allowed to write a library for use by other people until you have ten years of programming under your belt."
08:15:32 <Botje> that's belt-ist!
08:15:33 <merijn> geekosaur, typoclass: Oh wait, strace is linux only >.>
08:15:44 <geekosaur> what platform are you on?
08:16:03 <geekosaur> OS X, it's a dtruss invocation but you'd need to run as root or make dtruss suid >.<
08:16:21 <typoclass> merijn: i think the mac has something similar. dtrace? the "instruments" gui thingy? it comes with xcode i think
08:17:01 <scshunt> edwardk: thanks
08:17:08 <merijn> DTrace is to strace as a sonic screwdriver to a screwdriver. With similar difficulty gap, I imagine ;)
08:17:15 <geekosaur> can't use the -ff trick, but dtruss -f should work
08:17:39 <geekosaur> alternately run dtruss -n whichevercommand in one terminal and cabal install in the other
08:18:23 <geekosaur> (you can sanely sudo the latter, even, without running the cabal install as root)
08:20:21 <typoclass> merijn: i don't think strace tries to do everything that dtrace does. it's more like a naming coincidence
08:21:29 <typoclass> merijn: imho strace is quite useful quite often. you can run it with no switches at all, just "strace" prepended to the command, and it produces useful output. i've only a few times looked at instruments (dtrace), but each time it was so complicated that i got nothing useful out of it
08:24:08 <merijn> hmm, apparently haddock is trying to stat a non-existent temporary ghc file...
08:24:36 <typoclass> merijn: directly before the crash?
08:24:53 <merijn> Yeah
08:25:00 <merijn> It doesn't actually crash, it just panics
08:27:50 <merijn> It says "file a bug with GHC", but without any useful bug reporting info :\
08:27:57 <merijn> The odd thing is...it worked earlier today
08:29:39 <merijn> Everything still compiles, fortunately. It's just annoying to see it always terminate with a crash :p
08:31:26 <typoclass> merijn: maybe try to pinpoint the problematic file by checking which html files haddock generated and which not
08:35:56 <merijn> typoclass: Presumably none, since I don't have any haddock comments atm?
08:36:11 <ssbr> Hey folks. Two problems: http://bpaste.net/show/bA6qk7DdDRBhM9IAyOgW/
08:36:45 <ssbr> for persistent-equivalence, I'm not sure why it says that's missing. For base, I don't think it really matters what version for my program, so I'd like to loosen the requirements. How do I find out what base versions correspond to which versions of GHC?
08:36:56 <ssbr> I have GHC 7.0.4
08:37:32 <byorgey> ssbr: do  ghc-pkg list base   to see what version of base you have
08:37:58 <byorgey> ssbr: edit the .cabal file and change  base ==4.5.*  to something like   base >= 4 && < 5
08:37:59 <typoclass> ssbr: you'd edit the file replay.cabal and remove or loosen the constraint on 'base'
08:38:21 <ssbr> typoclass: Yes, I know, but I wanted to know what to loosen it to
08:38:24 <ssbr> thanks both of you
08:38:42 <ssbr> what about persistent-equivalence? ghc-pkg list persistent-equivalence says I have version 0.3
08:39:02 <thirsteh> byorgey: or just 4.*, no?
08:39:23 <byorgey> thirsteh: sure, 4.* would work
08:39:28 <typoclass> ssbr: is it hidden? if it is, i think ghc-pkg shows it in blue, or in parens
08:39:51 <ssbr> typoclass: it isn't colored or in parentheses. I'll paste the exact output now
08:40:03 <ssbr> http://bpaste.net/show/Z1FrLoyXlbNaRyZlaEnp/
08:40:14 <byorgey> ssbr: where does it say persistent-equivalence is missing?
08:40:22 <byorgey> oh, sorry, I see
08:40:59 <ssbr> My current situation is this: http://bpaste.net/show/nfWXhDHSpKDkxoXtd07m/
08:41:14 <byorgey> ssbr: by the way, don't do  runghc Setup.hs configure, use  'cabal configure'
08:41:22 <ssbr> FWIW I was able to use this on Windows
08:41:29 <ssbr> byorgey: Ah! thanks
08:41:30 <byorgey> these days you should never need to run Setup.hs manually
08:41:37 <byorgey> I don't know if that's the problem, just an aside
08:41:55 <ssbr> byorgey: well, it compiles when I do that
08:41:59 <typoclass> byorgey: what if i have cabal-the-library installed, but not cabal-the-command-line-tool? =D
08:42:19 <ssbr> the Cabal guide says to use runhaskell on Setup.hs . Why would it work with cabal configure, but not with runghc Setup.hs configure ?
08:42:22 <byorgey> ssbr: ok, maybe that was it then =)  doing it with 'cabal' includes a bunch of extra dependency-chasing smarts
08:42:28 <typoclass> (j/k, that's thoroughly implausible)
08:42:30 <ssbr> byorgey: ughhhhh. OK.
08:42:31 <osa1> is there a way to eliminate shift/reduce conflicts in this parser: http://hpaste.org/74961 ? I already specified all operator precedences ..
08:42:41 <ssbr> typoclass: hey, man, that was my situation like 10 minutes ago
08:42:53 <ssbr> Anyway, thanks again!
08:43:55 <typoclass> byorgey: extra dependency chasing smarts == can find things in /home/joe/.cabal/ ?
08:43:58 <pcavs> If I was interested in writing a HTTP service that would take requests, keep writing to the client until the client hangs up, and then after the client hangs up, report (to some datastore) how long the client was listening, where would be a good place to start that wouldn't make me reinvent the HTTP stack.
08:45:05 <byorgey> typoclass: dunno
08:50:58 <ssbr> Oops. Haskell imports are case sensitive. Ha ha ha ha.
08:51:04 * hackagebot BlogLiterately 0.5.2.1 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.5.2.1 (BrentYorgey)
08:51:07 <ssbr> Serves me right for developing on a case-insensitive filesystem :|
08:52:37 <sithisbitch> casesensitivity is the devil
08:52:47 <sithisbitch> it was better times when we only use lowercase
08:53:07 <mcstar> it is worse when you are light-sensitive
08:53:22 <sithisbitch> light-sensitive ?
08:53:41 <mcstar> yes, like your skin cant stand sunlight
08:55:43 <centrinia> What happens if your light-sensitive skin is exposed to sunlight for extended periods?
08:57:11 <dmwit> ddarius: Some time ago, I was talking to you about how to make square matrices in H98, and you suggested a paper about constructing data types with constrained shapes.
08:57:29 <dmwit> I'me having trouble finding this paper now; do you remember what it was called or who it was by or some such pointer?
08:58:45 <mcstar> i am not light-sensitive
08:58:56 <dmwit> (context is http://stackoverflow.com/a/12495541/791604 if you just want to post a link directly)
09:05:48 * frerich2 is very proud because my very first Haskell suggestion for improving some Haskell code posted at http://codereview.stackexchange.com/questions/15722/how-to-shorten-this-terrible-code was accepted (and it was favored over a *much* longer suggestion)
09:06:19 <dmwit> Well done, mate!
09:06:37 * hackagebot strptime 1.0.7 - Efficient parsing of LocalTime using a binding to C's strptime,  with some extra features (i.e. fractional seconds)  http://hackage.haskell.org/package/strptime-1.0.7 (EugeneKirpichov)
09:07:08 <dmwit> I bet the other guy feels a bit used, though. =(
09:07:47 <mcstar> i think i downloaded once a paper that does just like that
09:08:00 <mcstar> lets see if this nepomuk finds it
09:08:09 <dmwit> mcstar: Oh, great.
09:08:10 <frerich2> dmwit: I didn't know how to write "do { ch <- hGetChar stdin; go (ch:xs); }" nicer though. I tried to write ("\ch -> go (ch:xs)") point-free and then fmap that but somehow I didn't figure out how to make it pretty instead of contrived...
09:08:44 <dmwit> I think do { ch <- hGetChar stdin; go (ch:xs) } is quite pretty; why do you want to change it?
09:09:31 <frerich2> dmwit: Usually I find that if I have "do { x <- foo; return $ f x; }" I can make it mroe concise yet readable by using  (or some applicative stuff)
09:10:12 <dmwit> I don't see a "return" in the code you're trying to prettify.
09:10:12 <frerich2> I hoped that maybe I could do it in this case as well, but 'ch' is hidden in the middle of the expression, I coudln't find a way to make it pretty so I left it as it is :]
09:13:08 <mcstar> dmwit: sorry, it doesnt work
09:13:12 <Philippa> freiksenet: hGetChar stdin >>= go . (:xs) ?
09:13:49 <mcstar> it has almost indexed 100K files, still the ones i want, cannot find them
09:13:53 <dmwit> mcstar: Do you happen to remember the title or author of the paper?
09:13:59 <Philippa> sorry, frerich2 even
09:14:05 <mcstar> no
09:14:12 <Philippa> we have too many people in here, nick prefix collision frequency is huge!
09:14:31 <dmwit> mcstar: I have the same problem. =P
09:14:57 <dmwit> I thought it was something like "constrained shape data", but a Google scholar search for that only turns up REPA stuff.
09:15:20 <hpaste> stepkut pasted “the disappearing type variable” at http://hpaste.org/74962
09:15:46 <noviceprogrammer> hello
09:16:00 <stepkut> Ran across something surprising today.. not sure if it is a GHC bug, or a weird Haskell misfeature.. (see the paste for a full description)
09:16:03 <frerich2> Philippa: :-) What you wrote is also what I came up with, but it seemed like trying to be point-free too hard.
09:18:03 <mcstar> dmwit: was it about dependent typing?
09:18:38 <mcstar> http://jeltsch.wordpress.com/2012/04/30/dependently-typed-programming-and-theorem-proving-in-haskell/
09:19:04 <dmwit> mcstar: No, it was all H98.
09:19:55 <mcstar> oleg has a 'types parameterized by numbers' article
09:19:58 <dmwit> stepkut: It's not a bug.
09:20:05 <dmwit> stepkut: It's an odd, but valid, bit of Haskell.
09:20:17 <stepkut> ok, so a misfeature then
09:20:25 <dmwit> I don't know about that.
09:20:33 <stepkut> i do :)
09:20:44 <mcstar> dmwit: http://okmij.org/ftp/papers/number-parameterized-types.pdf
09:20:48 <dmwit> You've declared that the type of 'func' is 'a -> b' and that 'func (undefined :: Int) :: String', which looks totally reasonable to me.
09:21:17 <mcstar> http://www.haskell.org/pipermail/haskell/2005-May/015815.html
09:21:25 <mcstar> this is another author of similar things
09:21:35 <stepkut> dmwit: yes. So, let's reject, type Foo a b = a, ?
09:22:04 <dmwit> Why reject it?
09:22:12 <mcstar> "The second will implement
09:22:14 <mcstar> the same functions using no extensions to Haskell 98."
09:22:16 <stepkut> because it leads to confusing code as shown in hpaste
09:22:22 <dmwit> mcstar: Thanks. This is good, but still not as good as the paper ddarius pointed me at. =)
09:22:27 <merijn> stepkut: Eh, doing that will break some very important functionality
09:22:33 <dmwit> stepkut: I didn't find it confusion.
09:22:36 <merijn> stepkut: You couldn't have phantom types without that
09:22:38 <dmwit> s/confusion/confusing/
09:22:54 <dmwit> merijn: You can have phantom types without that.
09:23:08 <stepkut> merijn: but that is the point.. it is not a phantom type.. when you use newtype or data it works fine, but when you use type, you don't actually get a phantom type
09:23:09 <dmwit> merijn: (He's only proposing rejecting this *type* declaration -- data and newtype would remain unchanged.)
09:23:10 <Saizan> stepkut: you wouldn't be surprised that const x y == const x z
09:23:50 <merijn> dmwit, stepkut: Maybe I don't understand the problem, I didn't actually read the paste yet :p
09:24:05 <Philippa> frerich2: I like the cons section, though
09:24:24 <stepkut> merijn: the paste it short.. two functions with types that look identical type check differently
09:24:25 <Saizan> stepkut: and your type alias Foo is the equivalent of const, while Foo2 works more like a data constructor
09:24:35 <merijn> stepkut: Oh, I don't really see the problem there
09:24:38 <dmwit> The types don't look identical!
09:24:57 <Saizan> stepkut: maybe type aliases should be lowercase :)
09:24:58 <stepkut> dmwit: the types don't but the type signatures for func and func2 do
09:25:02 <dmwit> Haskell has all kinds of different type-level entities... type aliases, type constructors, type families...
09:25:06 <Saizan> *synonyms
09:25:11 <merijn> type functions! \o/
09:25:27 <dmwit> merijn: a.k.a. type families, which I mentioned ;-)
09:25:58 <dmwit> It's not surprising or weird or bad that these different entities behave differently, and that you have to know which one of these entities a particular identifier is to understand a piece of code.
09:26:17 <stepkut> dmwit: I guess it is always a problem with type aliases that you can't tell if something will type check or not until you substitute the aliases :-/
09:26:37 * stepkut proposing banning type aliases next
09:26:46 <dmwit> =/
09:27:33 <dmwit> Okay. You were surprised, that's clear. But surprising features aren't ipso facto bad.
09:27:57 <stepkut> yes they are :)
09:28:24 <dmwit> I was surprised by the type (a -> b -> c) being the same as (a -> (b -> c)) once, is that bad?
09:28:43 <stepkut> I've been writing exclusively in Haskell as my day job for 10 years.. if I'm surprised, it must be bad :p
09:28:54 <Saizan> of course there's a difference between learning curves and hard-to-reason-about in general
09:30:14 <Philippa> stepcut: would you settle for an "expand aliases" command in ghci?
09:30:19 <stepkut> so, what are some useful cases where I want to do, type Foo a b = a?
09:30:20 <Saizan> though expecting injectivity is kind of an Haskell perversion that we need to renounce
09:30:50 <Philippa> dmwit: yeah, the type language is real messy nowadays
09:31:31 <Philippa> (to a first approximation, for values I mostly want to know "is it a function or not?" followed by "what's its type?" - and there aren't a lot of other entities)
09:31:32 <stepkut> Philippa: meh. I probably wouldn't use it
09:32:57 <ReinH> EvanR: I'm not sure why that would annoy you.
09:33:30 <ReinH> EvanR: heh, I was scrolled back like 3 days without knowing it
09:33:32 <ReinH> please disregard
09:34:28 <Saizan> stepkut: would you also be against "type family Mul n m :: *; type instance Mul Zero _ = Zero; ..." ?
09:36:55 <donri> what's an example of a Typeable cast between different types that doesn't result in Nothing?
09:37:03 <stepkut> Saizan: i dunno, is that useful ?
09:37:18 <c_wraith> donri: any time the compiler already knows they're the same type
09:37:20 <dmwit> donri: There isn't one; that's sort of the point.
09:37:29 <c_wraith> well, no. sorry, the compiler doesn't know
09:37:41 <c_wraith> But they have to be the same type
09:37:41 <Saizan> stepkut: it's type-level multiplication
09:37:43 <dmwit> c_wraith: Perhaps you misread the question?
09:37:47 <c_wraith> Typeable never allows changing the type
09:38:36 <dmwit> stepkut: My search of Hackage suggests a few things; Agda has type Infinity a b = b for example.
09:38:41 <donri> dmwit: hm, so what is "cast" used for?
09:38:54 <dmwit> I see type True a b = a; type False a b = b scrolling by (didn't catch which package).
09:39:03 <dfordivam> helo
09:39:13 <djahandarie> HELO
09:39:44 <Saizan> donri: you can cast between locally unspecified types
09:39:49 <dmwit> 250 Hello dfordivam, #haskell is glad to meet you.
09:39:52 <Saizan> e.g. a bad example would be
09:40:01 <Saizan> ?type let x === y = cast x == Just y in (===)
09:40:02 <lambdabot> forall a b. (Eq b, Typeable b, Typeable a) => a -> b -> Bool
09:40:10 <c_wraith> EHLO ESMTP SUPPORTED
09:42:36 <dmwit> donri: cast is used when you know a thing has a particular type at runtime, but it's too hard/too annoying/impossible to prove that to the compiler statically.
09:43:02 <Saizan> or even for checking if a thing has that particular type
09:43:19 <dmwit> yes
09:43:40 <Saizan> most SYB combinators encourage you to do that to pick which cases you want to handle
09:44:57 <donri> so why is there both Data and Generic?
09:45:13 <donri> are they that different, or is Data deprecated
09:45:43 <dmwit> I bet there's papers associated with each of them, and that the one that came later has a related works section comparing them. =)
09:46:09 <Saizan> Generic feels more structural while Data is more nominal, i don't know enough about Generic to say more
09:46:16 <typoclass> donri: it'd help if you told us a little more about what you're trying to achieve
09:46:25 <stepkut> donri: because Data got it wrong so they had to make Generic :p
09:46:53 <donri> typoclass: nothing specific. understanding generics/syb. understanding the use of casts in acid-state :p
09:47:02 <donri> (internally)
09:47:43 <jfischoff> Generic is more type safe, but less powerful (It only can handle types with one type variable at most … I think)
09:50:02 <donri> hm wasn't some new ghc stuff help solve the Foo{1,2,3} class issue
09:50:08 <donri> polykinds?
09:52:08 <jfischoff> donri: I can't remember the name either, I know it will fix the issue with Typeable not sure about Generic though ...
09:57:46 <hpaste> int80_h pasted “Scaling question concerning TMVars” at http://hpaste.org/74963
09:58:32 <int80_h> Hey is there a way to fix my formatting for the hpaste I just submitted?
09:58:43 <dfordivam> What is recommended using Data.Map lazy or strict?
09:58:47 <c_wraith> nope.  hpaste is for code, not text.
09:58:55 <c_wraith> dfordivam: what are the values you're storing?
09:59:26 <hpaste> int80_h annotated “Scaling question concerning TMVars” with “Scaling question concerning TMVars (annotation)” at http://hpaste.org/74963#a74964
10:00:03 <dfordivam> c_wraith : I might store some Data type containing strings
10:00:29 <dfordivam> and the strings might come from parsing some ling string obj
10:00:38 <c_wraith> dfordivam: in that case, it's unlikely to matter, given how lazy strings are.
10:01:02 <dfordivam> So where does it matter, what to look out for
10:01:16 <c_wraith> int80_h: with the current implementation of STM, it's fantastic for the use case of "I have a lot of mutable cells, and I want to update small subsets of them simultaneously, and the updates usually won't overlap with other updating processes."
10:02:07 <c_wraith> dfordivam: first of all, both versions of Data.Map are strict in the keys.  (actually, they're the same data structure - the two modules just provide different functions for working with them)
10:02:48 <dfordivam> c_wraith : ok i see that thanks!
10:02:48 <c_wraith> dfordivam: so the difference is in the values.  If you want them to be calculated (to WHNF) when the pair is added to the Map, use .Strict
10:03:04 <c_wraith> dfordivam: if you want to leave the values uncalculated, use .Lazy
10:03:37 <c_wraith> dfordivam: If you frequently are updating the map in terms of itself, .Strict is usually the way to go
10:04:03 <dfordivam> c_wraith: " in terms of itself" ???
10:04:35 <shachaf> If you just "import Data.Map", that'll import some functions from Lazy and some from Strict.
10:04:36 <c_wraith> dfordivam: like looking up a value associated with some key, then storing some manipulation of that value in the Map
10:04:41 <shachaf> Maybe that happens to be the mix you want.
10:05:01 <c_wraith> dfordivam: like, say, using it to create a frequency table for words in text.
10:05:48 <c_wraith> dfordivam: if you do that with the lazy version, you end up with a *lot* of unevaluated thunks in memory, and generally end up holding on to a lot of memory that would be released if those thunks were evaluated
10:05:51 <dfordivam> c_wraith: aah i got it, at some places i need only look up but at some I do need to modify them back (like increment)
10:06:40 <c_wraith> dfordivam: however, the strict version is only strict to WHNF.  If you're storing complex objects, you'll need to help it out further.
10:07:19 <shachaf> c_wraith: Nope, data Complex a = !a :+ !a 	-- Defined in `Data.Complex'
10:07:26 <c_wraith> ... boo. :P
10:07:52 <c_wraith> I said complex, not Complex! Capitalization matters!
10:07:57 <dfordivam> c_wraith: and I know that most of the data might not even get looked up in the lifetime of the map, so lazy is the winner here
10:08:04 <EvanR> ReinH: lol
10:08:34 <int80_h> c_wraith: excellent. A friend of mine suggested what I wanted to do wasn't scalable, but (1) I may not have explained myself clearly (2) I didn't have any evidence to refute him.
10:09:47 <c_wraith> int80_h: One thing I question is if you need TMVars.  Would TVar do the job, or do you actively need the concept of "a possibly-empty" box?
10:10:03 <c_wraith> ugh.  "possibly-empty box".  I keep putting quotes in the wrong spot
10:11:21 <int80_h> c_wraith : Yeah I need a possibly empty box. The idea is I want to be able to block when I'm doing an operation on a Planet.
10:11:38 <mcstar> planetwars?
10:11:52 <int80_h> mcstar: you got it
10:12:10 <mcstar> hehe, little late for that, but great for learning
10:12:12 <int80_h> mcstar: well it will be a buy/sell game with guns and trechery.
10:12:20 <mcstar> oh, then no
10:12:26 <mcstar> i meant PlanetWars
10:14:23 <int80_h> mcstar: this is entirely a leraning exercise. I aim to make this a game people can write bots for. I hope to be able to study what people do with machine learning algorithms.
10:15:07 <mcstar> int80_h: are you aware that there was a university of waterloo science club organized Planet Wars ai competition?
10:15:31 <mcstar> aware of*
10:15:37 <int80_h> mcsta: no! was not aware. have a url for me?
10:15:50 <int80_h> mcstar: no! was not aware. have a url for me?
10:15:53 <mcstar> since then, there was another, a year ago, called Ants
10:16:33 <int80_h> way cool, I suppose googling will turn something up
10:16:34 <mcstar> int80_h: http://planetwars.aichallenge.org/ and http://aichallenge.org/ for the latter
10:16:42 <int80_h> oh nice :)
10:17:07 <mcstar> many thousands of submissions, in any lanuguage you want
10:17:16 <int80_h> sweet.
10:17:52 <mcstar> in only participated in Ants, but it was great
10:18:15 <mcstar> before that, ther was a Tron lightcycle contest, and a rock paper scissors one
10:18:27 <hpaste> “Jonathan Fischoff” pasted “Removing Left Recursion” at http://hpaste.org/74965
10:19:29 <jfischoff> shachaf: Expr is what I am starting with and ExprLF is what I get. (I don't remember why I named it ExprLF)
10:19:41 <mcstar> int80_h: if you are interested in such a thing, maybe you could help with the next competition, it is quite open
10:20:11 <mcstar> but now, there are organizational issues that need to be settled, like ... financing
10:20:48 <int80_h> mcstar: when is the next competition?
10:21:05 <mcstar> not decided, because of the issues
10:21:26 <mcstar> it would be preferable to set up a non for profit organization, to be able to accept donations
10:21:29 <int80_h> mcstar: I'll look into it. Sounds exciting.
10:21:40 <int80_h> mcstar: agreed.
10:21:42 <mcstar> on which, the servers could be rented
10:26:17 <merijn> Any cabal experts around? Specifically, anyone with experience adding custom build tools?
10:26:57 <jfischoff> merijn: so using a custom Setup.hs?
10:28:44 <merijn> No, using the Build-Tools field for programs that aren't preconfigured in cabal
10:29:05 <jfischoff> ah
10:29:10 <merijn> The cabal documentation says it is possible to do this, but doesn't actually mention how or where I can find this in the docs
10:33:54 <ClaudiusMaximus> merijn: maybe ask the gtk2hs folks, but iirc they do weird preprocessing of cabal stuff / custom setup / etc
10:34:29 <jfischoff> shachaf: to your other point, I think the Add and P parser could be combine somewhat
10:38:35 <pyf> Does anyone know how to convert a Decimal to a Float?
10:38:53 <shachaf> No one does, unforunately. :-(
10:38:56 <shachaf> @hoogle Decimal
10:38:57 <lambdabot> Data.Char DecimalNumber :: GeneralCategory
10:38:57 <lambdabot> package Decimal
10:38:57 <lambdabot> Text.Parsec.Token decimal :: GenTokenParser s u m -> ParsecT s u m Integer
10:41:57 <copumpkin> pyf: Decimal?
10:42:26 <mcstar> i bet he meant integer
10:43:13 <ClaudiusMaximus> @type realToFrac
10:43:14 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
10:43:36 <ClaudiusMaximus> @type fromIntegral
10:43:37 <lambdabot> forall a b. (Integral a, Num b) => a -> b
10:43:47 <ClaudiusMaximus> probably one of those
10:43:56 <ClaudiusMaximus> pyf: ^^
10:44:17 <johnw> why does lambdabot use existential types?  and why when it is not needed?
10:44:28 <ClaudiusMaximus> you mean explict foralls?
10:44:31 <johnw> yeah
10:44:31 <merijn> johnw: It doesn't use existential types
10:44:33 <ClaudiusMaximus> it annoys me too
10:44:38 <ClaudiusMaximus> but ghci uses them too
10:44:40 <copumpkin> forall = universal :)
10:44:42 <ClaudiusMaximus> and that annoys me too
10:44:49 <shachaf> johnw: GHC doesn't have existential types. :-(
10:45:05 <johnw> http://www.haskell.org/haskellwiki/Existential_types?
10:45:07 <merijn> johnw: Forall is a polymorphic variable scoper (which is hijacked to do existential quantification)
10:45:33 <johnw> but in the case of a -> b, isn't it always unnecessary?
10:45:42 <johnw> i thought you only needed it for a -> a
10:45:54 <johnw> :t id
10:45:55 <lambdabot> forall a. a -> a
10:46:17 <johnw> well, I'm not even sure what it means here
10:46:30 <johnw> it sounds like that means id could return anything at all
10:46:30 <shachaf> johnw: GHC doesn't have *first-class* existential types.
10:46:35 <merijn> johnw: No, it is not unnecessary. It's normally just implicit
10:46:41 <shachaf> johnw: It's saying: For any type "a", id is a function from a to a.
10:46:52 <shachaf> For example, you could decide that a = Int, and then id :: Int -> INt
10:47:02 <Ralith> it's just standard universal quantification
10:47:03 <merijn> johnw: No, it's saying that "for all types a" id is a function with type "a -> a"
10:47:04 <pyf> copumpkin: From the decimal package
10:47:08 <johnw> doesn't 'forall a' mean that anywhere you read 'a', any type is allowed that satisfies the constraints?
10:47:15 <pyf> copumpkin: It's in Data.Decimal
10:47:15 <Ralith> no.
10:47:20 <copumpkin> @hackage decimal
10:47:20 <lambdabot> http://hackage.haskell.org/package/decimal
10:47:22 <merijn> johnw: All a's have to be the same, obviously
10:47:32 <merijn> johnw: Which is why the forall is normally implicit
10:47:38 <Ralith> it means anywhere you read 'a', the same type must be substituted.
10:47:45 <johnw> i thought the whole point of existential types (per that web page) is that they don't have to all be the same
10:47:52 <shachaf> johnw: These aren't existential types!
10:47:57 <shachaf> GHC doesn't have first-class existential types.
10:48:00 <johnw> forall a. (Eq a) => [a]
10:48:04 <copumpkin> pyf: realToFrac then
10:48:07 <Ralith> johnw: forall is the universal quantifier.
10:48:10 <Ralith> not existential.
10:48:18 <shachaf> johnw: Do you know ∀ in logic?
10:48:25 <Ralith> ∀a. a -> a
10:48:32 * Ralith too slow
10:48:40 <copumpkin> johnw: the confusing thing is that making an existential type means that its constructor is universally quantified
10:48:52 <copumpkin> johnw: that's why you see forall in "existential types"
10:48:56 <copumpkin> that doesn't mean that forall = exists
10:49:14 <shachaf> You probably shouldn't worry about existential types before understanding universal types.
10:49:28 <shachaf> Since the latter are generally much more common/natural in Haskell.
10:50:04 <merijn> johnw: An example, I have a PatternCollection which contains a bunch of "Pattern p" values, but the p in the different patterns is not always the same type
10:50:32 <shachaf> You can take from logic the fact that "(∃x.P(x)) -> Blah" == "(∀x. P(x) -> Blah)" to understand the relation.
10:50:39 <shachaf> But you have to understand ∀ first. :-)
10:50:51 <merijn> johnw: This means the function "map :: PatternCollection -> (Pattern p -> a) -> [a]" is wrong, because the function only needs to deal with one type "Pattern p"
10:50:57 <johnw> shachaf: ok
10:51:15 <shachaf> I think kmc wrote an article on forall which might be helpful.
10:51:19 <shachaf> @google mainisusuallyafunction forall
10:51:20 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html
10:51:29 <merijn> johnw: You can, however, write "map :: PatternCollection -> (forall p . Pattern p -> a) -> [a]"
10:51:34 <shachaf> This thing is underdocumented for some reason.
10:51:35 <johnw> nice, will read
10:51:57 <shachaf> johnw: Oops, that's not the article I was after.
10:52:20 <merijn> johnw: The forall p here says the function doesn't only need to deal with *one* specific "Pattern p" it says that the function has to be able to deal with a "Pattern p" *no matter what value p has*
10:52:20 <shachaf> @google site:mainisusuallyafunction.blogspot.com quantification
10:52:21 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
10:53:32 <merijn> johnw: Notice how the scope of the forall there is limited to the function argument. The other variables are also scoped, but differently. i.e., the full correct type would be
10:53:52 <merijn> "map :: forall a . PatternCollection -> (forall p . Pattern p -> a) -> [a]"
10:54:34 <merijn> johnw: It's just that by default/convention forall's that scope over the entire type signature are dropped (since they are trivially inferred by human readers)
10:54:41 * shachaf has the vague suspicion that what merijn is saying is making things more rather than less confusing...
10:55:15 <merijn> shachaf: And you're predicate logic example isn't? xD
10:55:15 <shachaf> But hopefully my suspicion is wrong. :-) Rank-2 types are probably the right way to explain forall, anyway.
10:55:17 <johnw> (you are right)
10:55:20 <merijn> s/you're/your
10:55:33 <shachaf> merijn: I'm predicate logic example? Say that to my face!
10:55:54 <shachaf> merijn: Mine was a one-off example explicitly not meant to explain things!
10:56:37 <merijn> I've got example code for my type signature, but since it uses DataKinds/GADTs I'm not sure that's going to help much >.>
10:56:43 * shachaf tries to link to web pages rather than type lectures into IRC these days, if such web pages are available.
10:57:07 <johnw> that is a gratifying approach, shachaf
10:57:14 <merijn> shachaf: I'm planning to write a guided tour of type extensions based on the code I've been working on when it is done :p
10:57:16 <typoclass> -XTypeLectures
10:57:18 <johnw> since I prefer to queue these into my Kindle and enjoy them as my end-of-day reading
10:57:22 * shachaf can't tell if johnw is sarcastic.
10:57:29 <johnw> I'm not being sarcastic!
10:57:33 <shachaf> OK.
10:57:48 <johnw> last night I was reading about Type Families
10:57:59 <johnw> another thing I completely don't grok yet, at all
10:58:10 <merijn> See, another reason for my guided tour :p
10:58:16 <johnw> so, on my to-conquer list: existential types, GADTs, type families
10:58:25 <merijn> I'd do the last two first
10:58:29 <merijn> They're easier IMO
10:58:30 <johnw> ok
10:58:35 <merijn> And much cooler!
10:58:55 <shachaf> I should type up a proper explanation of "forall" sometime, since most of the ones that exist are unsatisfactory in one way or another.
10:59:04 <shachaf> johnw: Universal quantification first!
10:59:09 <johnw> shachaf: indeed.  please do!
11:00:23 <shachaf> johnw: Add RankNTypes to your list.
11:00:31 <johnw> oh yeah!
11:00:33 <shachaf> And all the related extensions.
11:00:42 <johnw> and now data kinds too
11:00:55 <johnw> i really am weak on the type system in general
11:01:06 <shachaf> These are all unrelated things.
11:01:14 <johnw> they are all related to types :)
11:01:28 * merijn doesn't get RankNTypes yet
11:01:30 <shachaf> Data kinds are pretty recent.
11:01:42 <shachaf> merijn: But you just gave an example of a rank-2 type?
11:01:51 <merijn> Or maybe I do, I've just figured out Rank2Types, not sure what the difference is
11:02:45 <shachaf> merijn: foralls nested more deeply than one layer in.
11:03:09 <shachaf> Like callCC :: forall r a. ((a -> forall b. Cont r b) -> Cont r a) -> Cont r a
11:06:27 <shachaf> Hmm, maybe that should be ((a -> Cont r (forall b. b)) -> Cont r a) -> Cont r a
11:06:40 * hackagebot one-liner 0 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0 (SjoerdVisscher)
11:06:53 <shachaf> Probably not. Does that make it impredicative or something?
11:06:54 <johnw> yay, version 0!
11:08:28 <merijn> bah
11:08:38 <merijn> License-File in cabal only accepts a single entry
11:09:20 <johnw> merijn: it's really early for you right now, isn't it?
11:09:39 <merijn> What? It's 20:00 :p
11:09:42 <johnw> oh
11:09:55 <shachaf> @localtime merijn
11:09:56 <lambdabot> Local time for merijn is Wed Sep 19 20:09:35 2012
11:10:14 <shachaf> @localtime johnw
11:10:15 <lambdabot> Local time for johnw is Wed Sep 19 13:09:54 2012
11:10:21 <johnw> when you took your lunch break, it was 4am for me
11:11:43 <typoclass> shachaf: possibly johnw was referring to an earth that rotates east to west ...
11:12:43 <johnw> 4am for me = 11am for merijn
11:12:47 <johnw> hence, he took lunch
11:13:18 <merijn> Since cabal only accepts a single license file and LGPL3 consists of two files, which file do I pick as license-file? LICENSE or LICENSE.LESSER?
11:13:28 <johnw> THE-ONE-LICENSE
11:13:54 <osfameron> cat them together?
11:14:17 <johnw> in WoW there is an item called "The 1 Ring".  It's description says: "Not quite as good as the 2 Ring."
11:14:29 <merijn> osfameron: There's a pull request for an Extra-License-File field in cabal, but dcoutts is slacking
11:15:10 <merijn> He also hasn't merged my autoconf fix yet...I need to set up a spambot to bug him :p
11:16:37 <mcstar> @localtime
11:16:40 <lambdabot> Local time for mcstar is Wed Sep 19 22:51:30 2012
11:17:59 <mantovani> morning guys!
11:18:44 <mcstar> according to my calculations, my clock shows 2:35 more than it should
11:18:57 <mcstar> how do you say it, when it is in a 'hurry'?
11:19:50 <mcstar> ahead of time? maybe
11:19:51 <c_wraith> man.  Laziness sure can eliminate a bunch of clunky logic
11:20:10 <shachaf> c_wraith: Especially when you're so lazy you don't even bother writing the logic.
11:21:10 <c_wraith> This is mostly something I encounter when porting imperative algorithms to haskell.  Things that have lots of boundary cases that just vanish when I pad the input to infinity, and only take the necessary amount of output.
11:22:18 <byorgey> mcstar: usually you say 'my clock is 2 and a half hours fast'
11:22:53 <mcstar> thanks
11:28:14 <merijn> How can I specify to add the install directory of another package to the include path while building? (Specifically, how do I tell to look for the headers that bindings-DSL installs?)
11:29:31 <merijn> (I know cabal has an "include-dirs" field, I'm just not sure how to set that to the proper cabal install directory without manually looking for it)
11:37:34 <merijn> hmm, apparently cabal auto-generates some function that let you find out the directories for packages you're installing, but not for others
11:37:39 <merijn> Which seems a bit useless >.>
11:41:11 <johnw> c_wraith: that's been my experience too
11:41:25 <johnw> c_wraith: don't need to optimize as much for corner cases anymore
12:09:16 <monokrome> Does TryHaskell use an in-browser implementation of Haskell or is it run server-side?...
12:09:57 <EvanR> server side
12:10:46 <hiptobecubic> Vim users that write lhaskell, how did you get syntax highlighting to act reasonably?
12:11:04 <monokrome> ah
12:11:23 <lpvb> monokrome: server-side
12:12:59 <mcstar> ghci terminates when i close a Gloss display window
12:13:26 <mcstar> is it possible that it can display something, and not terminate ghci when i close the window?
12:13:38 <mcstar> without pushing it to another thread..
12:15:54 <mcstar> <interactive>: interrupted
12:16:48 <byorgey> mcstar: probably when you close the window it throws an exception
12:17:08 <byorgey> so you could try surrounding the gloss call with a catch, perhaps?
12:17:11 <mcstar> i think it is set to end the application
12:17:33 <int80_h_> Hi all. Testing new Irc client. How can I tell if I validated correctly?
12:17:36 <byorgey> I'm not actually familiar with gloss.
12:17:38 <mcstar> byorgey: ^^ is that the sign of an exception?
12:17:50 <byorgey> mcstar: I'm not actually sure
12:18:02 <Botje> int80_h_: have you considered mining existing irc libraries for tests?
12:18:03 <mcstar> i can try nevertheless
12:18:12 <Botje> int80_h_: the perl POE::Component::IRC distribution probably has some.
12:19:24 <int80_h> I see I'm logged in with irssi as well. oops.
12:21:43 * hackagebot HStringTemplate 0.6.10 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.10 (SterlingClover)
12:21:45 * hackagebot swish 0.8.0.3 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.8.0.3 (DouglasBurke)
12:21:45 <mcstar> byorgey: well, this message disappeared <interactive>: interrupted, but it still terminates
12:27:23 <int80_h> Botje: I don't want to test. I had install a client on my iphone and it just now managed to login. It didn't look like I had validated but I wanted to be sure. Then I noticed why it didn't validate. No worries.
12:27:56 <merijn> Does cabal have a way to query libdir/datadir of other packages?
12:27:56 <mcstar> byorgey: it kills ghci even if i start the display with forkOS
12:28:14 <byorgey> mcstar: =(
12:29:04 <Botje> int80_h: okay
12:41:29 <FatPhil> @pl and $ zipWith (==) xs (reverse xs)
12:41:30 <lambdabot> and (zipWith (==) xs (reverse xs))
12:41:47 <Botje> try again with \xs ->
12:41:57 <FatPhil> @pl (\xs -> and $ zipWith (==) xs (reverse xs))
12:41:58 <lambdabot> and . ap (zipWith (==)) reverse
12:44:33 <mcstar> thanks!
12:51:19 <statusfailed> edwardk: What does "slow diagonalization" mean in the Monad instance for Data.Machine.Mealy ?
12:51:38 <edwardk> meaning that its not a monad you probably want to use because it slows asymptotically the longer the machine runs
12:52:10 <edwardk> there is a monad for infinite vectors that chooses the nth element of the nth vector as the nth element of the result
12:52:27 <edwardk> this means that it takes O(n^2) to access the nth element of a >>=
12:52:42 <edwardk> er the first n elements of a >>= result
12:54:37 <statusfailed> well the first part answered my question, but I didn't quite follow the next bit :)
12:55:09 <statusfailed> oh, are you saying the Mealy monad _is_ that monad of infinite vectors somehow?
12:55:16 <edwardk> yes
12:55:35 <edwardk> its taking the inputs and playing them back on each output in turn
12:55:55 <edwardk> and taking the nth output of the nth mealy machine after it receives the n inputs
12:56:18 <edwardk> you can see how this gets expensive
12:56:19 <edwardk> =)
12:56:41 <statusfailed> I don't see where there are multiple outputs though :P
12:57:17 <edwardk> consider join, not >>= for a sec
12:57:24 <edwardk> Mealy a (Mealy a b)
12:57:33 <edwardk> Mealy a (Mealy a b) -> Mealy a b
12:57:41 <edwardk> you now have a mealy machine generating mealy machines
12:58:14 <edwardk> each machine it generates gets run a given number of steps, so the first machine it generates gets run one step with the same input as the machine generating machine, and we take its answer and that is the b
12:58:38 <edwardk> the second machine gets run 2 steps, with the first two inputs that were fed to the machine generating machine, and we take its output as the second output b from the joined machine
12:58:42 <edwardk> the third machine...
12:59:04 <statusfailed> oh , I think I get it
12:59:43 <edwardk> so to get the nth output we have to run the nth machine n steps feeding it the inputs we've seen so far, and we have to run the entire machine all those steps just to get one output, then we throw away the machine
13:00:02 <edwardk> thats why its slow =)
13:00:15 <statusfailed> ahh ok
13:00:16 <edwardk> its the only legal monad for Mealy, and it exists as an instance for that reason
13:00:25 <statusfailed> cheers :)
13:00:37 <edwardk> but i felt the need to comment on it in the code because of the dreadful inefficiency
13:00:43 <edwardk> especially once you start chaining >>='s
13:00:58 <statusfailed> Yeah, that would have come as a shock :D
13:01:45 * hackagebot protocol-buffers 2.0.12 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.12 (ChrisKuklewicz)
13:01:47 * hackagebot protocol-buffers-descriptor 2.0.12 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.12 (ChrisKuklewicz)
13:01:49 * hackagebot hprotoc 2.0.12 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.12 (ChrisKuklewicz)
13:12:09 <jnhnum1> why doesn't hoogle search some packages that are on hackage? like I can't find things that are defined in http://hackage.haskell.org/packages/archive/hmatrix/0.14.1.0/doc/html/Data-Packed-Matrix.html
13:12:45 <jnhnum1> for example, I can't find fromBlocks on hoogle
13:13:04 <KirinDave> Does anyone know if there are outstanding issues with OSX 10.8 and GHC 7.4.1/haskell-platform?
13:14:56 <luite> hm i didn't really have problems
13:15:06 <luite> except for the known crashes with ghci and yesod devel
13:15:42 <kame> you need to use +package on hoogle
13:15:53 <kame> in this case +hmatrix
13:16:45 * hackagebot snap-server 0.9.2.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.2.1 (GregoryCollins)
13:18:08 <jnhnum1> oh ok
13:18:20 <jnhnum1> doesn't hoogle already include some packages which are not built-in though
13:18:22 <jnhnum1> ?
13:21:18 <SeroPositief> hey, a quick question; why was System.Random removed from the stanard library?
13:21:22 <SeroPositief> *standard
13:25:40 <Saizan> it's in its own package which i think is included in the platform
13:26:24 <SeroPositief> I'm just surprised it's not in base anymore
13:26:45 * hackagebot BerkeleyDB 0.8.6 - Berkeley DB binding  http://hackage.haskell.org/package/BerkeleyDB-0.8.6 (StephenBlackheath)
13:26:55 <geekosaur> don't be; base is essentiallyt the stuff needed to build ghc, and as much of that as possible is being unbundled
13:27:16 <geekosaur> base is not the batteries-included library.  the haskell platform is.
13:27:16 <Saizan> there's a tendency to make base smaller so it's easier to maintain
13:27:28 <geekosaur> (and the runtime)
13:27:35 <Cale> I kinda find that sad though
13:27:38 <Cale> In some ways
13:27:57 <Cale> In particular it means that it takes longer and longer for a new GHC release to be usable
13:28:07 <Cale> though I guess that's partly an illusion
13:28:24 <Saizan> it should take less effort for the GHC devs though
13:28:41 <Saizan> (assuming they find other maintainers for these spin-offs)
13:29:22 <Cale> and I never install the platform anyhow, I just get packages from cabal, but it's still nice to have *some* things right after installing GHC (not too bad though)
13:30:15 <SeroPositief> ah okay, thank you :)
13:31:20 <Saizan> i find it funny how long i can go without installing network
13:31:27 <Cale> There ought to just be a haskell-platform metapackage which if installed via cabal pulls in the associated packages as dependencies.
13:31:49 <Cale> I would probably actually use that.
13:32:12 <startling> me too
13:32:50 <Saizan> it'd be nice, but i'm not quite sure what's the benefit over the platform installer
13:33:27 <Saizan> the main thing i get from avoiding the platform is avoiding packages i don't need, especially if they are not that easy to build
13:33:47 <Cale> The benefit is that fuck the platform installer.
13:33:48 <startling> installers are kind of annoying on some platforms
13:33:52 <startling> e.g. os x
13:34:21 <Cale> It's this awkward autoconf thing
13:34:53 <Saizan> most of them have their awkward autoconf thingies though :)
13:36:11 <Saizan> where them = the packages
13:37:02 <Cale> and you have to choose a prefix to install into explicitly
13:37:14 <Cale> which is silly, I obviously want the packages installed as user
13:37:33 <Cale> ;)
13:37:54 <Cale> and then it's picky about the exact GHC version
13:38:00 <Cale> and there's another flag to avoid that
13:38:15 <Cale> JUST GIVE ME A CABAL PACKAGE ALREADY :)
13:41:02 <bamotarp> gentoo.de fascist?
13:41:13 <Saizan> https://github.com/haskell/haskell-platform/blob/master/haskell-platform.cabal <- but there is, the problem is if cabal-install can handle it :)
13:47:31 <edwardk> >>> zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
13:47:31 <edwardk> ("Jelly","world")
13:49:57 <edwardk> >>> zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % right1 % focus .~ 'o' % rightmost % focus .~ 'y' % rezip   ==> ("Jolly","world")
13:51:13 <jfischoff> it looks jumbled at first but actually reads well
13:51:23 <jfischoff> pretty cool
13:52:55 <Saizan> :type zipper ?
13:53:34 <byorgey> edwardk: that's sick
13:53:40 <byorgey> and I mean that in a good way
13:54:03 <edwardk> byorgey: =)
13:54:07 <byorgey> the 'fromWithin traverse' is the only part I don't understand
13:54:11 <edwardk> zipper :: a -> Top :> a
13:54:31 <Ralith> why right1 and not right 1?
13:54:50 <edwardk> within :: Simple Traversal b c -> (a :> b) -> Maybe (a :> b :> c)
13:54:56 <edwardk> fromWithin is basically fromMaybe . within
13:55:18 <edwardk> basically it bolts a traversal onto the current zipper, letting you move left or right within the traversal
13:56:12 <copumpkin> omg it's an edwardk
13:56:16 <edwardk> Ralith: right :: (a :> b) -> Maybe (a :> b) is the error-happy version of right that complains if you move past the end.  -- right1 :: (a :> b) -> a :> b      moves only up to the end
13:56:32 <edwardk> there is also 'rights' and 'rights1' to move n elements in that direction
13:57:16 <edwardk> byorgey: so by naming 'traverse' as the next level we've walked down into, left and right are now navigating through the first string
13:57:20 <donri> sanity check: is there anything preventing setting -trust (SafeHaskell) from cabal ghc-options or an OPTIONS_GHC pragma, etc?
13:57:40 <edwardk> you can do things like:
13:57:45 <edwardk> >>> zipper ("hello","world") % fromWithin (both.traverse) % focus .~ 'J' % right1 % focus .~ 'o' % rightmost % focus .~ 'y' % rezip   ==> ("Jollo","worly")
13:57:57 <donri> or perhaps i'm confusing myself, hmm
13:58:05 <edwardk> note: that rightmost is now walking all the way over to the right most element of 'world'
13:58:15 <edwardk> because the 'slice' i took with fromWithin now cuts across both strings
13:58:40 <donri> 'lens' is edwardk's evil plan to get more perl programmers into haskell
13:58:52 <Ralith> devious!
13:59:12 <edwardk> i do like the way the types work of for these zippers though
14:00:02 <Saizan> why do you need both down _1 and fromWithin traverse above?
14:00:03 <byorgey> edwardk: cool =)
14:00:03 <edwardk> Top :> a is the trivial zipper, Top :> (String,String) :> String :> Char  -- is the type you are working with in the Jelly world example, while Top :> (String,String) :> Char  is the one from the Jello worly example.
14:00:17 <edwardk> Saizan: you can come back 'up'
14:00:40 <edwardk> down is a safer form of fromWithin that only takes a lens. fromWithin requires you to know the traversal is non-empty
14:00:50 <edwardk> within is the Maybe-returning version of it
14:01:23 <jfischoff> so does fromWithin throw an error if the traversal is empty?
14:01:30 <edwardk> [16:57] edwardk: note: that rightmost is now walking all the way over
14:01:34 <edwardk> er
14:01:42 <edwardk> >>> zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % right1 % focus .~ 'o' % rightmost % focus .~ 'y' % up % focus %~ reverse % rezip   ==> ("ylloJ","world")
14:01:45 <Saizan> ah, i see, i wasn't counting the .. :> Char
14:02:22 <edwardk> jfischoff: fromWithin is slightly more insidious than that. it'll actually let you do some editing, as long as you never force the focus you can come back out of it safely
14:02:36 <edwardk> if you force the focus or try to move right it'll crash on you though
14:03:01 <edwardk> basically its as lazy as i can make it
14:03:39 <edwardk> for some reason this code crashes doctest though
14:03:56 <edwardk> guessing because its the only code i have in lens that actually defines a type family
14:04:04 <edwardk> and they may have a bug with those
14:04:38 <jfischoff> so do you partial and total versions of most functions?
14:04:53 <jfischoff> err total versions of the partial functions I mean
14:04:54 <edwardk> this is particularly slick when combined with all the uniplate combinators in lens, e.g. walking down plate
14:05:05 <jfischoff> yeah
14:05:37 <jfischoff> I messed around with plated for a quick moment, but was confused about how I was supposed to not create orphan instances
14:05:48 <Morgawr> hello everyone.. I have a question.. can you guys point me to any document/paper/article that may teach how to structure a complex Haskell program? I mean, I've learned Haskell only by writing small-ish programs to test stuff out and I decided it's time to write a bigger application/program. Something with a few sub-modules to get started...
14:06:06 <edwardk> i tried to make everything avoid crashing that can. so there are sensible defaults like left, right, etc. all work in Maybe, (up is total)
14:06:13 <Morgawr> I'm mainly looking for a "standard" way to subdivide these modules (which datatypes/functions to put in each, for example), number of lines (more or less) and folder/directory structure
14:06:19 <Morgawr> I'd be really glad if you had something on the matter :)
14:06:19 <edwardk> and then lateral movements have the '1' variants that clamp
14:06:33 <jfischoff> that's good
14:06:47 <byorgey> Morgawr: I don't know of any such document.  My best advice would be to find a large project you admire and see how it is organized.
14:07:26 <edwardk> i added saving and restoring of the current path, so you can save your location as a Tape, and then play back the tape to move in another object to the same location. but there are now 2 ways that can go wrong
14:07:30 <Morgawr> byorgey: yeah, I've been checking on github, though I'm always afraid I might find a project that isn't the "perfect" (I know there's no real perfect) way to implement it...
14:07:43 <Morgawr> if you had any projects I could look at, it'd be nice :)
14:07:45 <edwardk> it can go wrong because the position laterally doesn't exist, or because it doesn't exist horizontally (e.g. the traversal is empty)
14:07:49 <edwardk> the former can be clamped or not
14:07:53 <byorgey> Morgawr: no project is perfect =)
14:08:04 <edwardk> and the latter can do the fromWithin trick or not, so there are 3 versions of restore
14:08:21 <jfischoff> I was thinking with a mix of zipper and some form of generics, you could maybe approximate row polymorphism
14:08:27 <jfischoff> err
14:08:33 <jfischoff> maybe zipper doesn't matter
14:08:39 <byorgey> Morgawr: you could look at https://github.com/diagrams/diagrams-lib
14:08:51 <Morgawr> byorgey: thanks!
14:08:59 <byorgey> let me know if you have questions
14:09:03 <Morgawr> sure, thanks for the help
14:09:05 <byorgey> and I certainly don't claim it is perfect =)
14:09:27 <jfischoff> I guess a zipper lens combo is good for a lot of interactive  editor programs
14:09:44 <byorgey> zipper + lens + ropes!
14:09:44 <edwardk> Morgawr: http://hackage.haskell.org/package/machines is probably a good approximation of good factoring
14:09:51 <Morgawr> edwardk: thanks
14:10:12 <edwardk> Morgawr: even if not yet a good example of good documentation ;)
14:10:36 <Morgawr> edwardk: no big deal, I love documenting the stuff I write so that's not a problem for me :D
14:10:38 <edwardk> Morgawr: http://hackage.haskell.org/package/trifecta is probably an example on the overkill side of the spectrum
14:10:56 <edwardk> i can confess that as the author of both =P
14:11:01 <Morgawr> ahaha
14:14:04 <Ralith> edwardk: has anyone looked into combining lenses and conduits?
14:14:25 <edwardk> Ralith: i've been playing with them with machines, but i confess i don't give conduit much thought
14:14:44 <jfischoff> why not?
14:14:47 * Ralith isn't familiar with machines
14:15:24 <edwardk> jfischoff: scared off by the classy prelude
14:15:31 <jfischoff> aye
14:16:32 <Enigmagic> i select packages individually, not because of the author.
14:17:01 <gspr> Suppose I have some C struct that is opaque to me, but that I can initialize from C. Suppose further that the initialization of this struct is essentially pure, by which I mean only dependent on some given parameters. Can I make a corresponding Haskell type an instance of Storable and manage it on the Haskell heap, while still initializing in C?
14:17:19 <gspr> (Ḯ'm familiar with basics of the FFI, I've just never treated opaque structs)
14:17:45 <gspr> (especially not ones whose initialization/creation I'd like to treat as pure)
14:17:52 <ben> you'd have to hide the constructors and promise to only create it by calling FFI?
14:18:04 <ben> you'd just not give the FFI-imported C function an IO type, I suppose
14:18:15 <gspr> ben: Would the constructor be empty also? This is confusing me
14:18:21 <gspr> ben: Since the struct is opaque, I mean
14:18:36 <gspr> ben: I don't know how it's defined. I only know its size.
14:19:13 <ben> Okay, I haven't thought this through ;)
14:19:16 <startling> gspr: data Mystruct = Mystruct Ptr or whatever?
14:19:32 <maukd> gspr: then why make it an instance of Storable?
14:19:56 <gspr> startling: That's what I've thought of so far. But the falue of the Ptr in Mystruct will (possibly) change, even when the initialization parameters are the same
14:20:37 <startling> oh yeah. hrm
14:20:45 <gspr> maukd: Don't I need to have it as an instance of Storable to "fill it"/initialize it from C, while having it managed on the Haskell heap?
14:20:51 <startling> gspr: data Mystrct = Mystruct ByteString? :)
14:21:01 <gspr> maukd: As far as I know I certainly have to in the non-opaque case
14:21:19 <maukd> gspr: I don't see why
14:21:21 <gspr> startling: Hmm yeah, that's a possibility I guess! Didn't think of that. Thanks, I'll consider it
14:21:56 <startling> gspr: there might be a better way, though; using a ByteString seems kind of crazy and non-obvious
14:22:03 <gspr> maukd: I'm probably just missing something then. So if Foo is not an instance of Storable, can I still get a Foo by allocating memory in Haskell and passing a pointer to it to the C function?
14:22:09 <startling> thought I suppose it doesn't matter much if you don't export the constructor
14:22:09 <gspr> startling: I agree :)
14:22:15 <gspr> mhm
14:22:15 <ben> I'd look at the innards of bytestring
14:22:28 <maukd> gspr: what Foo?
14:22:33 <gspr> ben: I've looked at it a bit, but I'm a bit scared to use something from there without really understanding what's going on
14:23:13 <gspr> maukd: Let's say Foo is the Haskell version of the opaque data type. I need to pass it to and from C, and most importantly, initialize one by running an IO action taking a Ptr Foo.
14:23:29 <maukd> gspr: why do you have a haskell version?
14:23:49 <gspr> maukd: Well.. I need a type, don't I? How do I pass around something that isn't a type?
14:24:06 <maukd> you could use Ptr () or something
14:24:17 <gspr> maukd: It'd possibly change on every initialization
14:24:22 <maukd> or define 'data Foo' with no constructors
14:24:26 <maukd> gspr: what does that mean?
14:24:43 <gspr> maukd: Remember the C function creates identical such structs on identical input
14:24:59 <maukd> the C function creates nothing
14:25:05 <maukd> the C function initializes
14:25:13 <gspr> right, sorry
14:25:22 <maukd> why does that matter?
14:25:29 <gspr> what I mean is after C has done its thing, the memory is identical if the input to the initialization is the same
14:25:44 <gspr> ugh, bad sentence: given identical parameters, the C function produces identical memory segments
14:25:47 <maukd> why does that matter?
14:26:06 <gspr> well, it seems to me that I can thus force Haskell to accept these gadgets as pure constructions...
14:27:05 <gspr> suppose  fromInt :: Int -> Foo  essentially calls the C initializer with the Int on some newly allocated memory...
14:27:17 <gspr> wrapped in unsafePerformIO of course
14:27:34 <gspr> that all seems "safe" to me if the C initializer in fact produces identical data on identical input
14:28:05 <gspr> (although there is of course the possibility that I'm missing something important here :) )
14:28:34 <maukd> you'll never have a Foo
14:28:37 <maukd> only a Ptr Foo
14:28:44 <gspr> it's not possible?
14:29:03 <maukd> well, I suppose you could type Foo = Ptr Foo_internal
14:29:14 <maukd> but that depends on the rest of the operations
14:30:34 <gspr> I'll try to make the question clearer. Suppose there is an opaque C datatype foo_t and a C function void init(foo_t*, int) that initializes the foo_t in some way. The foo_t is initialized identically for identical ints. Suppose now that I want use the fact that "init is essentially pure" to initialize a pure Haskell value...
14:30:59 <maukd> init is not essentially pure
14:31:01 <gspr> sorry... by "pure haskell value" a mean "a haskell value outside the IO monad"
14:31:06 <gspr> maukd: Not?
14:31:12 <maukd> and it still depends on the rest of the operations
14:32:14 <gspr> maukd: Hmm, I don't get that... couldn't it be treated as pure if the memory pointed to by the foo_t* parameter is completely independent of side-effects?
14:32:45 <gspr> (I'm not doubting that you're right, btw, I'm just confused)
14:33:04 <maukd> writing to memory is a side effect
14:33:16 <maukd> if it wasn't, you'd never need to call that function
14:34:17 <merijn> gspr: Is your Foo an instance of Storable?
14:34:35 <gspr> Suppose the Haskell function that calls init is called fromInt :: Int -> Foo. Surely I'd want to call fromInt 4 to make one specific Foo value, and fromInt 5 to create another?
14:34:43 <maukd> merijn: ...
14:35:02 <maukd> gspr: WHAT ARE THE OTHER OPERATIONS?
14:35:08 <maukd> you keep ignoring that
14:35:10 <merijn> oh, wait, I missed the start
14:35:32 <gspr> maukd: What other operations? Other operations on such a Foo?
14:35:45 <merijn> gspr: Does C actually need to change the Foo?
14:35:52 <geekosaur> gspr, if a Foo is completely characterized by that Int, then your covnersion function is toEnum
14:35:56 <gspr> merijn: In init, yes.
14:36:02 <maukd> gspr: yes
14:36:11 <geekosaur> if you need a fromInt, then there must be *something* special about your Foo
14:36:18 <merijn> gspr: Then Foo will have to be Storable
14:36:25 <maukd> merijn: what
14:36:48 <maukd> gspr: or foo_t, actually
14:36:56 <merijn> maukd: If he wants to edit Foo in C he has two options, convert it to something else (say, an enum) or make it Storable
14:37:05 <maukd> merijn: wrong
14:37:16 <merijn> Unless I'm missing something very specific (I only glossed over the backlog)
14:37:23 <maukd> there is no Foo in the first place
14:37:23 <merijn> maukd: Elaborate?
14:37:29 <merijn> heh
14:37:44 <merijn> Then I don't understand the problem
14:38:06 <maukd> that's because we only have half of the problem description
14:38:18 <gspr> Hmm... I'll try rephrasing again
14:38:47 <maukd> seriously?
14:38:55 <maukd> are you trying to piss me off?
14:38:59 <gspr> Not at all
14:39:03 <gspr> I'll leave you alone if you wish
14:39:08 <gspr> thanks for the help anyway
14:39:10 <maukd> I'm not looking for another rephrasing of the first half
14:39:15 <maukd> I want to know the second half
14:39:20 <Ralith> gspr: I think maukd is annoyed because you still haven't named the other operations supported on foo_t.
14:40:30 <gspr> Ralith: Right, OK, sorry. Let's make up another operation. Let's say there is a C function char bar(foo_t). It returns a character depending only on the contents of the foo_t
14:40:44 <gspr> I'd like to pass my Foo to bar from Haskell also
14:40:54 <maukd> is that the only possible operation on foo_t?
14:40:59 <gspr> let's say it is
14:41:06 <maukd> type Foo = Char
14:41:08 <maukd> done
14:41:23 <startling> haha
14:41:30 <Ralith> :P
14:41:37 <startling> type Foo = Word8 would probably be better
14:41:44 <gspr> that would accomplish the same goal, I agree
14:41:45 <maukd> CChar, actually
14:42:06 <startling> maukd: oh right, sizeof(char) is platform-dependent
14:42:11 <maukd> startling: no, it's 1
14:42:26 <maukd> if the only thing you can do with foo_t * is to extract a char from it ... then you can represent it as a char
14:42:26 <gspr> but let's say that bar is incredibly complicated and out of my control
14:42:28 <startling> maukd: you know what I mean!
14:42:32 <gspr> I can't even begin to reproduce it, let's say!
14:42:37 <maukd> startling: I'm not sure
14:42:45 <maukd> gspr: irrelevant
14:42:46 <gspr> so I really need to pass my complex opaque structure to a magical (but oh-so-safe) C function
14:42:49 <merijn> startling: sizeof(char) is defined to be one, the number of bits however is variable (but at least sufficient for 0-255)
14:42:50 <maukd> gspr: you're simply going to call it
14:43:00 <startling> maukd: char is not necessarily 8 bits is what I meant
14:43:21 <gspr> but what do I do if sizeof(foo_t) is 124012? There's no Word124012?
14:43:29 <startling> so Word8 would not necessarily be a faithful reproduction
14:43:34 <maukd> gspr: wat
14:43:50 <gspr> you suggested type Foo = Word8 for the char situation
14:44:09 <startling> gspr, you want type Foo = Word992096 at least
14:44:11 <maukd> fooFromInt n = Foo <$> unsafePerformIO (allocaBytes sizeOfFoo $ \ptr -> initFoo ptr; bar ptr)
14:44:50 <maukd> oops
14:44:58 <maukd> fooFromInt n = Foo <$> unsafePerformIO (allocaBytes sizeOfFoo $ \ptr -> initFoo ptr (fromIntegral n); bar ptr)
14:45:05 <gspr> startling: hehe
14:45:29 <gspr> maukd: Right, that makes sense
14:47:25 <gspr> maukd: I appreciate the help
14:49:19 <gspr> As you can probably tell from my confusion, I didn't realize the other operations mattered. I thought the problem was well-posed if all I wanted to do was "make a Foo"
14:49:45 <maukd> no, because we don't know what a "Foo" is
14:50:23 <gspr> you see, that's my problem too. I was thinking that *I* don't even know what a Foo is, since foo_t is opaque to me.
14:50:41 <maukd> the two are relatively unrelated
14:50:51 <gspr> maukd: Yes, I see that know, thanks to your explanation :)
14:51:25 <gspr> Whenever I've been playing with FFI before I've been making Haskell datatypes that mirror c structs for which I know the internals
14:53:26 <Saizan> in some cases you want to do newtype Foo = Foo (Ptr Foo);
14:53:31 <gspr> I greatly appreciate your help, even though it may not have seemed like it when I didn't realize that I wasn't giving the full story
14:54:13 <gspr> Saizan: But then the value of the pointer may change even when all parameters to the initialization function do not
14:54:29 <gspr> Saizan: Surely that'll blow up in my face if I start wrapping things in unsafePerformIO?
14:55:11 <merijn> I guess my best bet for detailed cabal help is a mailing list (which I'm assuming exists) or ambushing dcoutts in here?
14:55:21 <Saizan> gspr: yep, i suspect so, unless all your operations on Foo will return the same result for Foo's initialized with the same int
14:55:26 <dcoutts_> @yarr!
14:55:26 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
14:55:30 <Ralith> Saizan: I think that is the case.
14:55:40 <dcoutts_> merijn: you rang?
14:55:55 <Ralith> gspr: you should be safe so long as the pointer identity doesn't actually matter.
14:56:00 <gspr> Saizan: It will! But I was affraid that things could still go wrong since a "field" in Foo can still change (the pointer's value)
14:56:05 <gspr> Ralith: Ah! Very nice!
14:56:12 <Ralith> gspr: if the value can be modified, then it's not safe.
14:56:15 <Ralith> because it's not pure.
14:56:24 <Ralith> because that makes pointer identity matter.
14:56:44 <merijn> dcoutts_: I have two problems/questions
14:56:47 <gspr> oh yes right :)
14:56:50 <gspr> as I feared
14:56:52 <Ralith> the C value, that is.
14:57:00 <Ralith> it sounds like what you're doing is okay.
14:57:04 <merijn> dcoutts_: 1) Can I find out where other cabal libraries/packages installed their headers?
14:57:05 <Saizan> btw, you want to attach a finalizer for freeing the memory if you do it this way
14:57:12 <Ralith> yes, definitely that
14:57:17 <gspr> Yeah I know
14:57:38 <merijn> dcoutts_: Specifically, bindings-DSL installs header files, but I don't know how to make my package make sure that the installed header files are in my include path
14:57:43 <dcoutts_> merijn: no, but you can find out what header files and include dirs other packages need
14:57:58 <acowley> My upgrade to GHC 7.6.1 has failed so hard I think I'm just going to have to throw out all electronic devices I own and start again.
14:58:15 <dcoutts_> merijn: sounds like you should just install them as data files
14:58:26 <acowley> GHC 7.6.1 came with Cabal-1.16, cabal-install on hackage won't work with that, and cabal-install from github wants at least Cabal-1.17
14:59:04 <merijn> dcoutts_: Well, they're not my packages. bindings-DSL installs the header files using "install-includes", so I figured cabal must know ehre it's leaving them
14:59:33 <Saizan> acowley: there's a trick: ask for cabal-install-0.14.0
14:59:36 <dcoutts_> merijn: and your package depends on bindings-DSL and you just need those header files when your package is being built?
14:59:48 <merijn> dcoutts_: Correct
14:59:51 <luite> acowley: works fine here, even after resettin gthe packages
15:00:05 <luite> Saizan: but then you dont get the parallel install goodness from the git version
15:00:07 <acowley> Saizan: all the versions of cabal-install on hackage seem to require Cabal < 1.15
15:00:15 <dcoutts_> merijn: ok, then that "just works". You can simply #include them. Cabal passes the appropriate -I flags when building your package.
15:00:20 <acowley> luite: did you install GHC from a bandits?
15:00:26 <acowley> s/bandits/bindist
15:00:34 <merijn> dcoutts_: ok, nice :)
15:00:48 <luite> acowley: source
15:01:05 <acowley> luite: and what version of Cabal did that leave you with?
15:01:05 <Saizan> acowley: oh right, i installed it with the 7.4.1 i had around
15:01:09 <merijn> dcoutts_: The second question I had is about custom build tools, the documentation mentions you can specify those in Setup.hs, but I couldn't find any explanation about how?
15:01:34 <gspr> Ralith, Saizan: So am I correct in believing that even though function blah that unsafePerformIO-calls C to initialize some data may create a Foo with a Ptr field that is not *only* dependent on blah's parameters, this is *ok* as long as any function taking a Foo doesn't really care about the *value* of the pointer?
15:01:35 <dcoutts_> merijn: have you looked at the API docs at the UserHooks stuff?
15:01:36 <luite> acowley: 1.16.0
15:01:56 <acowley> luite: that's what I have, but when I try to bootstrap cabal-install, it barfs on its own installation because it wants 1.17
15:02:16 <luite> acowley: oh perhaps you need another branch?
15:02:23 <acowley> luite: probably
15:02:44 <Saizan> gspr: yeah
15:02:49 <luite> i think i built the cabal-1.16 branch, not master, but i'm not sure
15:02:57 <merijn> dcoutts_: Only enough to rig it so that it shells out using system and calls the build tool I wanted. I just wanted to clean things up a bit and have cabal check whether the correct version is installed (it's installed using a cabal package)
15:03:00 <Saizan> gspr: bytestring is a good example of that
15:03:01 <luite> anyway, parallel cabal-install baby!
15:03:09 <acowley> luite: I'm giving that a try now
15:03:11 <dcoutts_> merijn: you specify build-tools: blah  in your .cabal file (or blah >= 1.0 or whatever). And in the Setup.hs you declare what "blah" means, how to find its version etc.
15:03:14 <acowley> how do I do parallel cabal-install?
15:03:25 <dcoutts_> acowley: -j{n}
15:03:26 <gspr> Saizan: Great! Thanks, this, combined with what maukd told me earlier cleared up a lot of things
15:03:39 <dcoutts_> acowley: oh, or did you mean install multiple versions of it at once?
15:03:46 <acowley> dcouts: I meant -j
15:04:00 <dcoutts_> ok, it's only parallel at the package level, not within
15:04:17 <dcoutts_> so far, and it interleaves output :-)
15:04:19 <dcoutts_> but it is faster
15:05:02 <gspr> Saizan: I guess I was fearing that GHC could end up realizing that two Foos returned by blah aren't *really* the same (due to a possibly differing pointer), even though I promise that they are for every function taking them
15:05:11 <gspr> Saizan: and blow up and burn down my house or something
15:05:27 <merijn> dcoutts_: And defining the programs is a matter of having a Distribution.Simple.Program instance and having that in hookedPrograms for UserHooks?
15:05:32 <startling> gspr, oh, your house will be safe
15:05:47 <startling> gspr, you don't have to worry about ghc doing anything to your *house*
15:05:51 <Saizan> gspr: it doesn't command a ninja squad, even if we like to say otherwise
15:05:54 <dcoutts_> merijn: yes, there's a few examples of this on hackage
15:05:55 <acowley> Something's not right. I have cabal-install-0.15.2 and Cabal-1.16.0 now, but cabal install won't do "cabal install world" (I want to install profiling libraries), it says "cabal: Command.optionToFieldDescr: feature not implemented"
15:06:09 <gspr> Saizan: outstanding feature request still?
15:06:16 <merijn> dcoutts_: ok, I can probably figure it out from there, I hope :)
15:06:22 <merijn> dcoutts_: Thanks :)
15:06:25 <dcoutts_> np
15:06:33 <Saizan> gspr: hopefully a wontfix
15:06:50 <gspr> :)
15:06:57 <dcoutts_> acowley: something odd in the ~/.cabal/config? if not, try reproducing with a released combination
15:07:01 <merijn> dcoutts_: Will it automatically fetch newer versions if the version is wrong? Or do I need to add it to build-depends?
15:07:26 <merijn> (Although I didn't think build-depends worked for non-library packages)
15:07:35 <acowley> dcoutts_: I couldn't find a released combination. I installed GHC-7.6.1 which gave me Cabal-1.16 which is too new for any cabal-install on hackage. I have my current cabal-install from the Cabal-1.16 branch of the repo.
15:07:54 <dcoutts_> merijn: at the moment cabal-install only considers deps on libs when making an install plan. It check libs, progs, C libs, etc etc when configuring but doesn't take them into account yet when planning. Or short answer: no, not yet.
15:08:44 <dcoutts_> acowley: ok, I'll try to remember to check cabal install world before we release the next cabal-install
15:08:46 <merijn> dcoutts_: ok, it'll just produce a warning/error during configure when it's not installed? I guess that's good enough for now
15:08:58 <dcoutts_> merijn: yes, it'll stop with an error
15:09:05 <gspr> Saizan: These things can be hard to know when you're not experienced. It's not easy to dare bet that the runtime doesn't go through and existential crisis if the pointer field of  blah 5  called at noon differs from the pointer field of  blah 5  called an hour later :)
15:09:10 <acowley> dcoutts_: I suspect my setup is just totally hosed now, so it might not be a problem with cabal-install's source, per se
15:09:15 <gspr> *an existential
15:09:46 <dcoutts_> acowley: the only things it should depend on are the versions you're using, and the contents of your .cabal/config
15:10:00 <acowley> dcoutts_: my .cabal/config is freshly generated by cabal update
15:10:10 <dcoutts_> acowley: then it may well be a new bug
15:10:12 <acowley> I nuked my old .cabal
15:11:02 <merijn> dcoutts_: Actually, while I'm bugging you anyway...I still have a trivial pull request on GitHub that fixes a problem with cabal+autotools I kept running into :p
15:12:08 <dcoutts_> merijn: oh yes, I read it. I'd thought I'd applied it already but I see I havn't.
15:12:44 <dcoutts_> merijn: thanks
15:12:51 <merijn> dcoutts_: I'll let you get back to whatever you were doing now, it's time to head for bed :p
15:12:59 * dcoutts_ too
15:13:36 <Saizan> gspr: yeah, i understand, but the RTS is actually less controlling than you might imagine, there are some impure primitives behind the scenes afterall
15:15:17 <acowley> Wow, my hole is getting deeper
15:15:19 <acowley> $ cabal update
15:15:19 <acowley> cabal: Command.optionToFieldDescr: feature not implemented
15:15:29 <acowley> #Winning
15:15:55 <startling> ouch
15:18:17 <dcoutts_> acowley: ok, will test with clean config file
15:18:26 <dcoutts_> but not right now, bed beckons
15:20:04 <acowley> dcoutts_: I'm going to try going to Cabal-1.17 so I can use cabal-install HEAD. I figure I can't break my installation any more than it already is.
15:23:21 <acowley> dcoutts_: Going to latest and greatest seems to be working
15:23:38 <acowley> dcoutts_: But it seems pretty bad to me that the Cabal that ships with GHC 7.6.1 isn't supported by any cabal-install
15:25:42 <shachaf> cmccann: Are you in PGH these days?
15:26:34 <cmccann> man, why are people always stalking me by my hostname. :P
15:34:25 <startling> can there be a lens like "head :: Simple Lens [a] (Maybe a)"? what would it look like?
15:34:32 <edwardk> no
15:34:57 <jfischoff> you can have a traversal thought, right?
15:35:01 <edwardk> yes
15:35:02 <jfischoff> *though
15:35:04 <startling> yeah, I see the traversal
15:35:08 <startling> thanks!
15:35:31 <edwardk> the problem with the lens is that it necessarily changes the rest of the list or deletes the head changing the target for subsequent invalidations
15:35:39 <edwardk> er subsequent uses
15:36:00 <edwardk> both alternatives violate the laws
15:36:09 <startling> edwardk, oh, right
15:36:25 <startling> edwardk, but I could write a traversal and a getter, though, right?
15:36:41 <edwardk> startling: yes. you can even fuse them together as a projection
15:37:00 <startling> I guess I don't intuitively understand the difference between the strength of a lens and the strength of having a getter and a traversal.
15:37:11 <Philonous> Does the FFI give me access to constants in a C library?
15:37:15 <nexion> hey guys, if I have a huge graph stored in one TVar and then writeTVar every time there is a small change, will the entire graph be rewritten or only what has changed? (perf question)
15:37:45 <shachaf> nexion: This has nothing to do with TVar. It just depends on how your graph type is implemented.
15:37:46 <edwardk> well, you can only 'get' a Maybe, and you can traverse it, but a lens would let you turn Nothing into Just
15:38:10 <edwardk> if the element is missing, the traversal can never put it back in
15:38:12 <startling> edwardk: which changes the structure of the thing
15:38:18 <startling> yeah, that makes sense
15:38:18 <edwardk> yep
15:38:24 <startling> edwardk: what are these projections?
15:38:56 <edwardk> startling: http://hackage.haskell.org/packages/archive/lens/2.9/doc/html/Control-Lens-Projection.html
15:39:05 <nexion> shachaf, how does it work with Data.Map? a huge Map in a TVar, readTVar to access and occasionally readTVar, modify, writeTVar
15:39:15 <edwardk> projection :: (d -> a) -> (a -> Maybe c) -> Projection a b c d
15:39:49 <edwardk> exception :: (Exception a, Exception b) => Projection SomeException SomeException a b
15:40:01 <startling> edwardk, huh, interesting
15:40:19 <startling> what's the (d -> a)?
15:40:22 <edwardk> this lets you use the projection as a traversal of the contents, but you can also use ^.by to go the other way
15:40:29 <shachaf> nexion: A Data.Map update would probably update ~log n nodes in the data structure.
15:40:41 <shachaf> (By which I mean allocate ~log n new nodes and share the rest, of course.)
15:40:54 <edwardk> well, its easier to see when they are Simple. projection :: (b -> a) -> (a -> Maybe b) -> Simple Projection a b
15:41:46 <edwardk> a projection is the opposite of an embedding. an embedding woud have an a -> b, and you might be able to get the value back out (b -> Maybe a)
15:41:53 <nexion> shachaf: so it isn't just a blind write, but it somehow tracks what has changed?
15:42:04 <startling> edwardk: where does the traversal fit in, though?
15:42:12 <shachaf> nexion: I'm not sure what you mean. That's how Data.Map works.
15:42:17 <edwardk> a projetion on the other side, you may be able to access something, but if you put it in you can definitely get it out
15:42:20 <startling> edwardk: Im assuming (a -> Maybe b) is the getter?
15:42:25 <edwardk> no
15:42:42 <edwardk> you can use a Projection a b c d as a Traversal a b c d
15:42:48 <shachaf> cmccann: Because what else would we use?
15:43:00 <merijn> Philonous: If the constants are just C variables, yes.
15:43:04 <edwardk> by :: Projection a b c d -> Getter d a
15:43:18 <edwardk> that turns it around and lets you get the getter that works the other way
15:43:23 <merijn> Philonous: Although I guess that with the CPP extension you could get access to macro constants too
15:43:30 <edwardk> consider a projection for head. we know we can traverse head.
15:43:38 <nexion> shachaf: Data.Map does, but I'm wondering about TVar... when writeTVar is called, how would it know that it doesn't need to copy the entire Map if only one item was added?
15:43:50 <edwardk> but we can also take a single 'a' and make a list, such that head of that list gives you that a back
15:44:16 <edwardk> this means we can make traverseHead a full projection, rather than just a traversal
15:44:16 <edwardk> because then 2^.by traverseHead  = [2]
15:44:28 <startling> edwardk: sure. so how would you write that with `projection`?
15:44:37 <shachaf> nexion: It has nothing to do with TVar.
15:44:43 <cmccann> shachaf, dunno. autonomous surveillance drones, maybe? that sounds fun.
15:44:59 <edwardk> projection return listToMaybe
15:45:21 <startling> edwardk: ...huh.
15:46:25 <startling> this is going to need some reflection. let me play around with those a bit.
15:47:00 <edwardk> nah, reflection is a completely different package of mine ;)
15:47:59 <startling> >:(
15:48:02 <nexion> shachaf: my question is this: if I have a Data.Map with 1 million elements inside a TVar, and I readTVar, Map.insert, writeTVar, what will the runtime of that be like? will it have to access all 1 million elements to do the update?
15:48:04 <Philonous> merijn:  How would I do that for a C variable?
15:48:37 <Ralith> nexion: I don't think so. Profile it!
15:49:04 <edwardk> nexion: the cost will be logarithmic in the size of the map
15:49:06 <shachaf> nexion: Nope. Data.Map is implemented as a balanced binary tree, and an update to a leaf will probably involve allocating ~log n new elements.
15:49:12 <startling> edwardk, you need to write "The Annotated Edwardk Reader"
15:49:18 <shachaf> (And accessing a similar number of elements.)
15:50:14 <Philonous> merijn:  Never mind, found it after all
15:50:16 <startling> edwardk: "The Portable Edwardk"
15:50:23 <nexion> so Map.insert would be ~log n
15:50:25 <nexion> what about writeTVar?
15:50:32 <ivanm> startling: heh
15:50:41 <shachaf> nexion: writeTVar is completely unrelated to the Map.
15:51:00 <edwardk> nexion: writeTVar will depend entirely on contention for that tvar.
15:52:15 <nexion> if it's a Map with 1 million elements (and only 1 has changed since the Map was read from that same TVar), will it access all 1 million elements?
15:52:36 <nexion> that's the part I'm confused about
15:55:37 <zenware> Does haskell have a library for working with image data or pixel data? I'm wanting to create a 2d planetary gravitation simulation and I feel like doing it in a functional language, because it seems that that would work well.
15:55:38 <edwardk> nexion: no. you only touch the nodes that are on the path down to the entry you found, there are log n of the, so ~20, not 1 million
15:55:48 <edwardk> of them
15:56:04 <geekosaur> zenware, several.  I think JuicyPixels is the most recent
15:56:10 <startling> edwardk: oh, so Projectionsare new
15:56:17 <edwardk> startling: fairly
15:56:45 <startling> oh, heh, I haven't cabal updated in a bit
15:56:46 <bos> JuicyPixels is somehow such an unappealing name
15:56:53 * hackagebot snap-server 0.9.2.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.2.2 (GregoryCollins)
15:56:56 <bos> might as well call it MoistMonitor
15:57:03 <edwardk> not as new as zippers though, which have yet to hit hackage
15:57:04 <jfischoff> zenware: there is also repa-devil
15:58:03 <startling> edwardk, you should have an rss feed
15:58:03 <edwardk> bos: =)
15:58:24 <edwardk> startling: just subscribe to hackage updates, it'll be about 30% on topic ;)
15:58:29 <startling> heh
16:00:02 <Ralith> bos: did you see my earlier messages re: llvm?
16:00:24 <bos> Ralith: i don't know
16:01:24 <Ralith> bos: I mentioned that the low-level wrapper was complete enough to be useful but not comprehensive, and asked if you would be willing to accept it in such a state
16:01:37 <copumpkin> moo
16:01:39 <startling> edwardk, projection return listToMaybe gives me No instance for (Projective k0 [c0] c0) arising from a use of `projection'
16:01:40 <bos> Ralith: ah.
16:01:49 <bos> Ralith: probably, yes
16:02:01 <Ralith> great
16:02:11 <Ralith> I'll tidy up a bit and submit a pull request
16:03:11 <edwardk> :t projection return listToMaybe
16:03:11 <edwardk>   :: (Control.Applicative.Applicative f, Projective k [c] c) =>
16:03:11 <lambdabot> Not in scope: `projection'
16:03:13 <edwardk>      k (c -> f c) ([c] -> f [c])
16:03:56 <edwardk> startling: :set -XNoMonomorphismRestriction if you are going to use stuff like that at the REPL in older GHCs
16:03:59 <Ralith> Is there a way to say to the haskell module system "Import symbol from this other module and also export it from the current module"?
16:04:24 <edwardk> Ralith: module Foo ( bar ) where import Bar (bar)
16:04:27 <ivanm> Ralith: explicit export lists
16:04:35 <ivanm> also lets you export an entire module
16:04:41 <Ralith> edwardk: I mean, without repeating the symbol.
16:04:47 <edwardk> Ralith: no
16:04:52 <Ralith> ivanm: I specifically want to import/export a subset of the module's exports.
16:04:55 <Ralith> ah well; thanks.
16:04:59 <edwardk> Ralith: other than re-exporting the whole module or everything you imported from it
16:05:11 <edwardk> you can say things like
16:05:13 <startling> edwardk, oh, looks like I need FlexibleConstraints for the type annotation to work anyway
16:05:25 <edwardk> module Foo ( module Bar ) where import Bar (bar)
16:05:28 <ivanm> Ralith: only import those items you want exported from the module, then export the module
16:05:32 <ivanm> as edwardk just demonstrated
16:05:35 <Ralith> ooh
16:05:36 <Ralith> perfect!
16:05:38 <Ralith> thanks :D
16:05:40 <edwardk> be warned
16:05:46 <edwardk> i'm not sure how well the haddocks look for that
16:05:57 <ivanm> edwardk: it says the entire module is exported
16:05:57 <Ralith> this is a wrapper around a wrapper around a wrapper anyway
16:06:07 <ivanm> (assuming Bar has separate haddocks)
16:06:07 <startling> err, FlexibleContexts of course
16:06:07 <edwardk> thats what i was afraid of
16:06:13 <ivanm> yeah, it's not the best
16:06:24 <Ralith> the users should be referring to the original API's docs
16:06:47 <edwardk> Ralith: yes, but they may look at the haddocks and not understand why that can't see some of the methods from Bar
16:06:53 <edwardk> even though the haddocks say you are re-exporting it
16:07:04 * Ralith nod
16:07:08 <Ralith> I appreciate that it's suboptimal
16:07:29 <Ralith> but I'm not particularly concerned.
17:04:02 <dcb> :t map
17:04:03 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:06:57 * hackagebot stylish-haskell 0.5.1.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.1.0 (JasperVanDerJeugt)
17:14:45 <nexion> if I have a custom type MyType, what can I do to make "TVar MyType" be capable of being a key in a Map? (need Ord)
17:15:28 <MostAwesomeDude> nexion: Uh. That seems kind of curious. You want to map *TVars* to things?
17:15:48 <nexion> yeah
17:15:55 <bos> nexion: you can't do that
17:15:56 <liyang> You'd need an (forall a.) instance Ord (TVar a)
17:15:57 <nexion> I know it seems odd
17:16:10 <nexion> oh, that sounds bad
17:16:30 <nand`> Was ‘--’ picked for any reason in particular for Haskell comments? Perhaps to look like an em-dash?
17:16:53 <bos> nexion: in order to put a value into a map, the type must be an instance of both Eq and Ord
17:16:54 <liyang> There's an instance Eq (TVar a) so Ord doesn't seem that far-fetched.
17:17:10 <shachaf> Just use the Pugs trick!!!
17:17:12 <shachaf> https://github.com/perl6/Pugs.hs/blob/master/Pugs/src/Pugs/AST/Types.hs#L380
17:17:18 <shachaf> (Note: Do not use the Pugs trick.)
17:17:42 <Clint> haskell is secretly based on lua
17:18:30 <XCOHeN> Clint, hmm
17:18:39 <XCOHeN> Elleau
17:19:15 <copumpkin> shachaf: wow, that seems like a bad idea
17:19:21 <bos> nexion: Map also requires immutable keys and values, which a TVar isn't
17:19:38 <shachaf> copumpkin: Who cares if your Map invariants break after a GC?
17:19:43 <shachaf> I mean, how often do those happen?
17:19:49 <nexion> bos: you're right.. this is sounding like a bad idea
17:20:02 <MostAwesomeDude> nexion: So why did you want to do this?
17:20:08 <bos> and the Eq instance for TVar compares for address equality of the TVar itself, not whatever it points to
17:20:16 <copumpkin> well, a Map doesn't care about the values, just the keys
17:20:20 <copumpkin> so you could have TVars in your values
17:20:33 <copumpkin> the map would just be storing the TVar's identity, of course
17:21:34 <shachaf> copumpkin: There's also https://github.com/perl6/Pugs.hs/blob/master/Pugs/src/Pugs/Types.hs#L628
17:21:49 <copumpkin> lol
17:21:52 <shachaf> (type VHandle = Handle)
17:22:20 <copumpkin> instance (Ord a) => Ord (Tree a) where compare _ _ = EQ
17:22:23 <Eduard_Munteanu> Scary.
17:22:24 <copumpkin> I see
17:22:24 <shachaf> Yep.
17:22:36 <MostAwesomeDude> TIL Pugs.
17:24:51 <shachaf> Pugs really likes Ord instances.
17:26:12 <nexion> so where I wanted to use TVars as keys, there is a unique String that can be used instead
17:26:19 <nexion> which makes more sense
17:26:21 <hpaste> YayMe pasted “isPrime in need of thunk” at http://hpaste.org/74973
17:26:31 <YayMe> Someone help me force a thunk?
17:26:59 <YayMe> I'm running out of memory, I presume because it's just growing the thunk too much
17:27:04 <nexion> but I'd like to have a Set of elements with type (String, SomeCustomType)
17:27:08 <nexion> how can that be made Ord?
17:27:17 <YayMe> I need to put a ! somewhere in there
17:27:19 <nexion> (based on String)
17:27:29 <MostAwesomeDude> nexion: Is SomeCustomType a member of Ord?
17:27:34 <nexion> it's not
17:27:42 <MostAwesomeDude> nexion: There's an instance for (Ord a, Ord b) => Ord (a, b)
17:27:46 <MostAwesomeDude> Well, can you fix that?
17:27:52 <nexion> let's say SomeCustomType is TVar a
17:27:57 <copumpkin> lol
17:27:59 <copumpkin> why do you need it in the key?
17:28:04 <copumpkin> if it won't affect ordering or equality?
17:28:24 <copumpkin> how are you going to look up values?
17:28:24 <MostAwesomeDude> No, no, waaaait. Instead of Set, can you do Map String SomeCustomType instead?
17:28:30 <nexion> just need it to be part of a Set
17:28:38 <copumpkin> why not just make it a map?
17:28:49 <nexion> good point
17:28:51 <copumpkin> a Set of (k, v) is just a less convenient Map k v
17:29:00 <YayMe> Anyone help me force eagerness?
17:29:15 <copumpkin> (assuming v doesn't have meaningful ordering or lookup properties)
17:29:19 <YayMe> Can you even force eagerness in the midst of a list comprehension or do I have to restructure it with higher order functions?
17:29:22 <nexion> :)
17:29:43 <cmccann> "data Disorder a = Disorder String a", write your own Ord instance that only uses the String. sometimes that sort of thing is what you actually want...
17:29:51 <cmccann> but usually not
17:30:31 <MostAwesomeDude> YayMe: This seems like a really bad way to generate primes.
17:30:35 <Cale> YayMe: You can do it after defining the list.
17:30:54 <YayMe> MostAwesomeDude: I doesn't generate them, just checks if it is prime, but it may be a bad way to do that
17:31:12 <YayMe> Cale: Does that mean the entire list comprehension will be in the thunk though?
17:31:15 <Cale> YayMe: Try this (which is still bad, but not so bad)
17:31:52 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in prime
17:31:53 <lambdabot>   Not in scope: `prime'
17:31:54 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
17:31:55 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:32:00 <shachaf> jkff: Good luck to your cat!
17:32:17 <jkff> shachaf: thanks!
17:32:37 <Cale> YayMe: This takes advantage of lazy evaluation rather than fighting against it :)
17:32:51 <MostAwesomeDude> let primes = nubBy (\x y -> gcd x y > 1) [2..] in primes
17:32:58 <MostAwesomeDude> > let primes = nubBy (\x y -> gcd x y > 1) [2..] in primes
17:33:00 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:33:12 <Cale> (that is much worse)
17:33:29 <MostAwesomeDude> (Yea, I have sinned on this day.)
17:33:31 <YayMe> Cale: Basically, the use of a list comprehension is what screws me isn't it?
17:33:39 <Cale> no
17:34:25 <Cale> (==) False is the same thing as  not
17:34:34 <Cale> actually it's the foldl
17:34:40 <YayMe> Ah
17:34:44 <Cale> you don't want foldl1, you want a right fold
17:34:51 <YayMe> oh
17:34:53 <Cale> or just use and
17:35:00 <YayMe> hah true
17:35:13 <cmccann> yay, standard libraries!
17:35:14 <YayMe> I didn't think about that..
17:35:46 <YayMe> That's why I'm working through project euler, it's stupid simple stuff but seems like a great way to get in the habit of all these built-ins
17:36:11 <YayMe> at least it starts out simple, I'm sure it will get less so
17:37:30 <Cale> anyway, the reason that  and = foldr (&&) True  is that you want the recursion to not continue once a False element is found
17:37:46 <Cale> @src foldr
17:37:46 <lambdabot> foldr f z []     = z
17:37:46 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:38:10 <Cale> you can see that foldr f z (x:xs) immediately passes control to f, giving it the option of evaluating its second parameter
17:38:24 <Cale> (or, importantly, not doing so)
17:38:29 <Cale> @src foldl
17:38:29 <lambdabot> foldl f z []     = z
17:38:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:38:48 <YayMe> I thought foldr isn't tail call optimized though?
17:38:52 <Cale> foldl does nothing except to apply itself to a shorter list until it reaches the end
17:39:00 <Cale> There is no call stack in Haskell
17:39:06 <Cale> Or more precisely, in GHC
17:39:16 <YayMe> You can still stackoverflow with ghc can't you?
17:39:24 <Cale> Yes, but not the call stack :)
17:39:30 <YayMe> ?
17:39:31 <Cale> because that doesn't exist
17:39:42 <Cale> There *is* a pattern match stack
17:39:48 <YayMe> oh
17:39:49 <YayMe> ok
17:40:02 <Cale> consisting of all the case expressions who are waiting for their scrutinee to be sufficiently evaluated to pattern match
17:40:04 <zzing> Is there a reason why we have the "where" keyword in a module statement? It seems like it performs no useful function
17:40:41 <Cale> zzing: I dunno, I think it kinda makes sense that it's there
17:40:55 <Cale> zzing: Your whole module is in the module declaration's where clause.
17:41:37 <Cale> It would make more sense if we were allowed to put more than one module per file. The standard doesn't say anything about how code is divided into files or anything like that.
17:41:43 <zzing> Cale, if we just had 'where' and then a bunch of stuff equaling each other it would make sense linguistically. But having a bunch of imports kind of breaks the linguistic flow. It seems to me that we could do without the 'where' keyword and have no problems.
17:41:44 * cmccann suggests adding support for "what" "which" and "why" as well as "where"
17:42:07 <Cale> cmccann: 'whence'
17:42:12 <cmccann> ooh, good idea
17:43:26 <maukd> zzing: ambiguous syntax
17:43:40 <maukd> module Foo (a, b, c) = (1, 2, 3) what
17:44:16 <nand`> ghc-7.4.2-src.tar.bz2 is 26 MB (same for 7.4.1); 7.0.4 is 25 MB; 6.12.3 is 27 MB. Meanwhile, 7.6.1 is 111MB. Is there a reason for this large disparity?
17:44:42 <copumpkin> next we need a kind of modules, and parametrized modules
17:44:43 <ku> Would Haskell be a good fit for AI?
17:44:49 <copumpkin> anyone wanna throw that into the haskell type system?
17:44:52 <copumpkin> kthx
17:44:55 <nand`> (the numbers are quoted from the source package portage downloaded to compile ghc, I think it may be possible that a binary version of GHC is included in this)
17:44:56 <latro`a> @faq can haskell do AI?
17:44:56 <lambdabot> The answer is: Yes! Haskell can do that.
17:45:17 <copumpkin> Data.List :: Module
17:45:23 * ku facepalms and stares at latro`a
17:45:28 <ku> I asked if it was a good fit
17:45:36 <cmccann> define "AI"
17:45:41 <latro`a> it was a joke
17:45:53 <maukd> ku: what's an AI?
17:46:09 <nand`> oh, on a second glance, I think that is the case - ghc-bin-7.4.1-amd64.tbz2 is present (92 MB) but a version for 7.6.1 is notably missing
17:46:58 * hackagebot lojysamban 0.0.7 - Prolog with lojban  http://hackage.haskell.org/package/lojysamban-0.0.7 (YoshikuniJujo)
17:46:59 <ku> maukd: artificial intelligence, although I mean more like a chess AI than a human AI...
17:47:07 <typoclass> latro`a: a smiley would be a good idea there. i think you can expect channel regulars to know what @faq does, but not random people with innocent questions
17:47:24 <latro`a> yeah, I should probably have thrown out a ";)"
17:47:30 <cmccann> it's pretty obvious what @faq does
17:47:44 <copumpkin> @faq can Haskell tell me what @faq does?
17:47:45 <lambdabot> The answer is: Yes! Haskell can do that.
17:49:50 <cmccann> anyway, AI covers a huge range of topics and Haskell is probably just fine for most stuff you'd want to do
17:50:25 <nand`> will Haskell ever gain a conscience and protest against its makers?
17:50:58 <cmccann> no, it'll just start making snide remarks when code doesn't type check
17:51:04 <typoclass> cmccann: i think you'll have to see @faq at least twice. and i still maintain that when someone comes in here with an honest question, it is less than courteous if the first thing they hear is some joke
17:51:32 <cmccann> yes, that's true
17:52:09 <cmccann> which is why it's most often used when a question is unanswerably broad or ill-defined
17:52:53 <copumpkin> @@ @faq @faq
17:52:53 <lambdabot>  The answer is: Yes! Haskell can do that.
17:53:16 <cmccann> I will note that, in such cases, @faq does generally give the correct answer
17:53:35 <cmccann> which is more than such questions would get in plenty of IRC channels I've known
17:54:14 <simon> if I've got newtype Foo = Foo { foo :: Int -> (Int, Int) }, why is the type of foo then Foo -> Int -> (Int, Int)? (with regards to the first Foo in this type signature)
17:54:38 <MostAwesomeDude> simon: Do you understand how records work?
17:54:44 <maukd> simon: what else would it be?
17:55:01 <simon> MostAwesomeDude, I assume ignorantly that they are synonymous to tuples. ah...
17:55:10 <simon> MostAwesomeDude, of course, the selector foo needs a Foo first.
17:55:12 <Eduard_Munteanu> simon: foo takes that newtype apart and gives you the Int -> (Int, Int)
17:55:18 <MostAwesomeDude> simon: Bingo.
17:57:04 <shapr> What the heck does lojysamban do?
17:57:15 <nand`> data Tuple a b = Tuple { fst :: a, snd :: b }
17:57:52 <simon> shapr, it is related to Lojban, it seems.
17:58:28 <shapr> Yah, but mixing lojban and prolog sounds ... well it's causing me cognitive dissonance.
17:59:50 <latro`a> lojysamban would "mean" "logical computer language"
17:59:56 <latro`a> no idea what it means in context
18:00:55 <XCOHeN> nand`, is it actually possible to define your own type constructors in fancy syntax like (a, b) instead of Pair a b?
18:01:20 <nand`> (a, b) is built-in sugar and pretty much undefinable in-language afaik
18:01:28 <nand`> but you can build your own type operators
18:01:31 <nand`> maybe something like a :, b
18:02:45 <XCOHeN> Ah, so you can only make infix type operators and not cinterfix?
18:03:01 <nand`> cinterfix?
18:03:12 <XCOHeN> Hmm, how does Haskell disambiguate between infix type constructors and infix oprations on values since you can't start those characters with a capital?
18:03:15 <nand`> and no, you can't define free-form operators like in some other languages; only infix
18:03:16 <XCOHeN> circumfix + infix
18:03:36 <nexion> is it easy to write a Show instance for TVar a where a is a showable type? I'm suspecting not without requiring that all TVars require showable types
18:03:37 <nand`> XCOHeN: infix type constructors start with a :
18:03:47 <XCOHeN> Ahhh
18:03:47 <nand`> type operators*
18:03:51 <XCOHeN> Yeah
18:04:09 <XCOHeN> Makes sense, never really used them
18:04:57 <simon> nexion, instance Show a => TVar a where ..., or something like that?
18:05:10 <nexion> instance Show (TVar a) where
18:05:11 <nexion>   show _ = "TVar"
18:05:16 <nexion> is what I have, but I'd like to print a there too
18:05:51 <nexion> only if it's deriving Show, of course.. otherwise just "TVar"
18:05:59 <simon> oops, instance Show a => Show (TVar a) where ...
18:06:08 <nexion> but I suspect this would already be implemented if it was easy
18:08:33 <simon> nexion, I can make that work.
18:09:58 <nexion> simon, how would that work?
18:11:49 <cmccann> if you want show to display the contents of the TVar I suggest getting used to disappointment
18:14:15 <nexion> lol
18:14:24 <nexion> that was my suspicion
18:14:52 <kaidelong> @ty atomically . readTVar
18:14:53 <lambdabot> Not in scope: `atomically'
18:14:53 <lambdabot> Not in scope: `readTVar'
18:15:25 <nexion> maybe something with unsafe IO?
18:15:34 <cmccann> seriously, this is a very special kind of impossible
18:16:27 <kaidelong> what is specifically impossible?
18:16:54 <nexion> is it that IO/STM neded to read the value isn't available inside "show"?
18:16:55 <kaidelong> showing the state of a TVaar before a call to writeTVar is finished?
18:16:56 <nexion> needed*
18:17:30 <nexion> or is it that accessing a (in TVar a) for showing requires that a be deriving Show?
18:17:49 <simon> oh, nexion, I don't think I understood that TVar was a library type.
18:18:17 <kaidelong> anyway looking at the docs you could do something to the tune of
18:18:40 <kaidelong> show =<< (atomically (readTVar t))
18:19:19 <nexion> yeah, but..
18:19:37 <nexion> that only shows the first level :)
18:20:19 <YayMe> Anyone here use haskell mode in emacs?
18:20:36 <simon> most, I would guess. ;-)
18:20:57 <nexion> I heard vi is better
18:21:02 <nexion> j/k
18:21:20 <YayMe> I've been in visual studio over 10 years now, but forcing myself to emacs lately as every haskeller seems to not even waste mental cycles on whether a non-emacs ide is worth while
18:21:33 <simon> I switched from vim to emacs last year for haskell-mode.
18:21:48 <YayMe> I haven't setup haskell mode yet
18:21:57 <tsou> simon: for how long had you been using vim?
18:22:09 <jkff> I tried haskell-mode, it's better than what vim gives, but not enough to make me abandon vim and learn emacs :)
18:22:10 <amosr> really? I've been thinking about trying emacs properly (from vim). do you use the vi emulation, viper, I think?
18:22:38 <tsou> viper ain't vim though :P
18:22:38 <simon> tsou, vi since 13 years ago, vim since somewhere after that.
18:22:48 <dgpratt> YayMe: from someone else who's been using VS for over a decade, I've been getting along pretty well with EclipseFP of late
18:22:59 <tsou> simon: similar here.. and how painful was the transition?
18:23:34 <simon> tsou, I still use vim for quick editing, especially across ssh with latency. not painful at all... well, writing a .emacs was slightly painful. :)
18:24:04 <Ralith> simon: emacs has support for editing files on remote servers so you don't need to deal with latency at all
18:24:08 <Ralith> ^^
18:24:12 <Ralith> (tramp)
18:24:22 <tsou> simon: i even find it hard to write text in html <textareas> without the modes and the h,j,k,l keys.. :(  and i'll need to use emacs soon.. it's scary
18:24:30 <Ralith> (supports ssh and ftp, among other protocols)
18:24:48 <YayMe> dgpratt: eh, I'm going emacs to get away from the big-ide, I was using leksah for months learning haskell and I actually found it great, but my thinking is this: I forced myself to learn haskell disregarding the impulses of "yuck, that looks grody, these people are making something meaninglessly complex" and trusting that the many things I ever read of haskell were from really smart people always says something to the tune of "holy shit
18:24:53 <geekosaur> ...so does vim
18:24:54 <tsou> Ralith: every operating system has tools to support those things, and therefore so does emacs :P
18:25:14 <YayMe> dgpratt: I'm forcing myself out of the bulky IDE style development I'm used to under the same faith...
18:25:24 <startling> tsou, evil-mode is slightly better
18:25:36 <Ralith> tsou: and yet people still use it to justify use of vim!
18:26:05 <tsou> Ralith: i'd be happy using emacs if i could have vim as an editor there.. this would make things less painful
18:26:13 <dgpratt> YayMe: gotcha; actually I use sublime-text a lot for small experiments
18:26:13 <YayMe> Has anyone setup haskell mode on windows?
18:26:32 <YayMe> dgpratt: never heard of that, is that like notepad++?
18:27:00 * hackagebot kure 2.4.2 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.4.2 (NeilSculthorpe)
18:27:04 <cmccann> YayMe, I use SciTE which offers... syntax highlighting
18:27:06 <cmccann> and that's about it
18:27:16 <Ralith> tsou: that can be easily had :P
18:27:16 <dgpratt> YayMe: somewhat; more like TextMate probably
18:27:35 <Ralith> geekosaur: pretty weak argument, then, if it's a misuse even of vim.
18:27:54 <geekosaur> huh?
18:28:07 <YayMe> wow, the demonstration gif on sublimt-text's frontpage is impressive
18:28:08 <Ralith> if you were replying to me
18:28:17 <tsou> Ralith: *that* cannot be had, something-that-tries-to-be-like-that, can
18:28:23 <dgpratt> YayMe: actually, I have haskell-mode in Emacs too, just don't use it
18:28:31 <dgpratt> YayMe: (on Windows)
18:28:32 * geekosaur uses emacs and vi/vim, is rather more familar with vi than vim's extensions, but knows some of the things vim has added over vi
18:28:51 <Ralith> tsou: nonsense
18:29:22 <tsou> Ralith: really?
18:29:42 <Ralith> tsou: there's a terminal emulator!
18:29:44 <Ralith> :D
18:30:14 <tsou> Ralith: then it's not in emacs, but in a terminal-in-emacs, which makes it pointless to use, cause you don't have any of the emacs goodies :P
18:30:52 <YayMe> I spent last night working on euler with emacs splitting it's screen between ghci and the euler.hs, seems pretty simple.. What does haskell-mode really give?
18:31:23 <startling> YayMe, C-c C-l reloads the code in the ghci window
18:31:23 <Ralith> tsou: picky, picky.
18:31:35 <startling> YayMe: so you can tell without C-x o-ing over whether it compiles
18:31:47 <YayMe> ah fair
18:32:19 <Ralith> if it's integrated with emacs, it's not vi, if it's vi, it's not integrated with emacs
18:32:22 <Ralith> :P
18:33:00 <startling> YayMe: and C-u C-c C-t adds a type annotation over the function your cursor's on
18:33:50 <startling> those are really the only parts i use, but it's definitely an improvement over M-x ansi-term RET ghci RET
18:33:59 <tsou> Ralith: unfortunatelly, that's my complaint :(
18:34:25 <Ralith> your complaint is that emacs does not resolve a logical absurdity?
18:34:30 <Ralith> well, it would be nice if it was capable of magic.
18:34:37 <Ralith> but we make do.
18:35:29 <tsou> Ralith: no, my complaint is that emacs doesn't have a text-editor that I like for.. well.. text-editing, but i'm not in the mood for a vi/emacs discussion :P
18:35:34 <nand`> “emacs, but like vim” seems pretty obvious to me
18:35:49 <nand`> no absurdities involved
18:36:05 <Ralith> that's not what tsou seemed to me to be asking for.
18:36:05 <tsou> nand` seems to get it
18:36:06 <tsou> ;)
18:36:19 <Ralith> but indeed this is offtopic.
18:36:27 <YayMe> I kind of like it to be sure, reminds me of spending years in the linux console years ago, just pondering getting an irc client to pop into one of the windows as my F1 for help to get me over here
18:36:37 <amosr> surely you could write a lisp evaluator in vimscript easily enough
18:36:49 <YayMe> has anyone used an irc client inside emacs?
18:36:56 <startling> YayMe: yeah, people do
18:37:17 <startling> YayMe: sometimes you see it in /quit messages. "erc" or something?
18:37:24 <sipa> indeed, erc
18:38:43 <startling> hmm, I should try erc actually
18:38:47 <startling> might be better than irssi
18:41:41 <startling> yeah wow, erc is kind of nice
18:49:28 <YayMe> chiefly when I'm trying to hack on haskell I'm between editor, this, command line and google, I'll bet someone has either stuffed chrome into emacs or emacs into chrome by now
18:50:55 <startling> yeah, for me it's emacs + ghci (in haskell-mode) + irc + chrome
18:52:38 * nand` prefers to use both firefox and vim simultaneously, with a good system to coordinate them - that system is xmonad
18:52:53 <nand`> why bother sticking everything into the same program?
18:53:42 <YayMe> because I've never really liked having unattached windows
18:53:47 <startling> nand`: less context-switching
18:54:00 <YayMe> I want one full screen thing with stuff docked together in it
18:54:10 <startling> though yeah, xmonad is great but not likely to work on OS X
18:54:11 <YayMe> which xmonad may be able to emulate
18:54:27 <YayMe> I'm thinking it won't work so good on windows (or does it?)
18:54:37 * ddarius also uses xmonad more or less for that purpose.
18:55:10 <nand`> you can run X on windows via xming or whatever it's called, with xmonad interfacing with that
18:55:27 <Ralith> there are window tiling systems that run natively on windows
18:55:29 * ddarius has actually only run ion2 (3?) on Windows.
18:55:30 <Ralith> much less of a hack
18:55:36 <nand`> but I don't think you can display any non-X windows that way (eg. winforms, except maybe via some mechanism like wine uses)
18:55:45 <nand`> Ralith: yeah, but xmonad?
18:56:00 <Ralith> nand`: I expect YayMe doesn't need xmonad in particular.
18:56:05 * ddarius rarely uses the tiling feature of xmonad.
18:56:23 * Ralith wonders what feature of xmonad ddarius uses
18:56:27 <nand`> perhaps; I personally find xmonad in particular important because it's programmable in haskell
18:56:47 <nand`> ddarius: do you use some floating window mode?
18:57:02 <ddarius> I pretty much only use full screen.
18:57:09 <nand`> oh
18:57:18 <ddarius> And multiple "desktops"/"workspaces" wtf they're called.
18:57:31 <ddarius> Well I guess both multiple "desktops" and "workspaces".
18:57:33 <nand`> I use the full screen for IRC, browser, most other programs - and tiled windows for terminals
18:57:40 <ddarius> Firefox is always Meta-3.
18:57:50 <nand`> eg. if I'm working on something, I'll have 3 or 4 terminals open running vim
18:58:12 <nand`> meta-9 for me; and the term is ‘workspaces’ - xmonad doesn't have a concept of a ‘desktop’
18:58:36 <startling> nand`: full screen for irc? doesn't your neck hurt?
18:59:22 <nand`> startling: I don't follow
18:59:58 <startling> nand`, always looking at the bottom of the screen for the newest messages
19:01:26 <nand`> the screen is in a comfortable orientation in which I can see all of it fairly well without having to move my neck; but apart from that my IRC program tiles its buffers internally and my most visited channels are in the top half, so the lines I look at are near the center of the screen
19:01:57 <nand`> in particular the top right (#haskell), which means I'm looking at pretty much the exact center
19:03:19 <startling> ah.
19:04:15 <mkramer1> Has anyone here tried to do machine learning in Haskell? Do functional data structures pose problems for decision tree algorithms? How well do the imperative algos transfer?
19:04:51 <nand`> I can't answer most of those questions due to infamiliarity with the field; but it's generally fairly possible to transfer imperative algorithms to Haskell
19:05:24 <YayMe> I haven't had a pleasant experience with *nix since I got rid of my last nix desktop ~10 years ago, but I still always leave unpartitioned space on every machine I've had in that time in case I wanted to pop it on there... maybe I should go ahead and put nix on my spare space and dual boot this since I'm mostly just using this laptop for haskelling
19:05:30 <nand`> from as simple as tail call recursion to as complex as something like mutable ST arrays, you can model computations on mutable data fairly well
19:06:53 <nand`> YayMe: I got used to it inside a virtual machine, that's the approach I would take; it allows a grace period as well
19:07:20 <nand`> and when done, I simply transferred the contents of the VM onto a new hard drive
19:15:06 <Nisstyre> Is it possible to write an existentially quantified type with more than one type class constraint? Imagined syntax: forall a. (Foo a, Show a) => Whatever a
19:15:24 <dolio> Yes.
19:15:30 <Nisstyre> dolio: what's the syntax for that?
19:15:38 <dolio> What you wrote.
19:16:05 <Nisstyre> dolio: oh, I'm an idiot, nevermind. I forgot to save my work and GHC complained about something else :P
19:17:40 <YayMe> haha I love when that happens, you see an error and it makes you question some foundational thing you had previously assumed, only to realize you made a stupid mistake somewhere else
19:19:09 <Nisstyre> YayMe: thankfully it doesn't happen that often
19:21:41 <YayMe`> hey, erc is built into emacs
19:22:04 * YayMe` wonders how to get his ghci window back now
19:27:31 <ben> yo does any haskell web stack free me from the terrible burden of having to learn to write javascript?
19:27:44 <luite> not yet
19:28:00 <byorgey> though it seems things are moving in that direction.
19:28:16 <YayMe`> I don't know any serverside stuff that does that, erlang's nitrogen looks to do some of it for you
19:28:21 <YayMe`> otherwise look at dart
19:28:25 <Nisstyre> ben: I think that was the intention behind "Links"
19:28:34 <Nisstyre> but I don't think it ever gained any traction
19:28:56 <Nisstyre> ben: maybe you should look at Coffeescript
19:29:00 <luite> ben: fay-lang.org  is probably a good start, a "cheap and cheerful" subset of haskell to get you started
19:29:02 <YayMe`> If you haven't learned javascript yet, and you can choose not to use it, I'd go for dart myself
19:29:03 <Nisstyre> it is slightly better than using JS
19:29:17 <ben> this opalang thing looks pretty sweet in that it compiles to javascript
19:29:36 <luite> ben: and more full-featured haskell->js compilers are in the works
19:29:37 <nand`> there are probably around half a dozen or so haskell-to-javascript compilers around
19:29:38 <ben> but it's not haskell, so welp
19:29:49 <Nisstyre> also there is Whalesong which compiles Racket to JS
19:30:05 <nand`> http://altjs.org/ has a list
19:30:11 <nand`> I don't know if it's complete
19:30:43 <Nisstyre> http://hashcollision.org/whalesong/
19:30:46 <YayMe`> ben: What's your reason of avoiding javascript out of curiosity? You haven't learned it yet, or?
19:30:47 <ben> fay-lang.org seems dead
19:30:49 <nand`> thought it doesn't include, for example, fay
19:30:59 <luite> ben: oh looks like chris messed up somehow
19:31:03 <luite> ben: it should be back soon
19:31:19 <johnw> what's a good library for reading and writing YAML?
19:31:25 <ddarius> Use GWT then you can replace Javascript with glorious Java.
19:31:28 <luite> ben: it's a small subset of haskell, no typeclasses, but the most friendly to install
19:31:48 <ben> YayMe`: I've not got a lot of experience with web development at all and writing good javascript and integrating it with the server bits without messing up seems really tricky
19:31:52 <nand`> haskell without typeclasses sounds like haskell's predecessors
19:31:58 <Nisstyre> could probably implement some sort of Haskell -> Typed Racket -> Whalesong toolchain
19:32:39 <luite> Nisstyre: would that be better than compiling haskell directly?
19:32:50 <YayMe`> ben: tip, don't 'integrate' the javascript with the server side
19:33:02 <Nisstyre> luite: depends which compiler you think does a better job of compiling javascript
19:33:16 <luite> Nisstyre: the one i'm writing ;p
19:33:16 <Nisstyre> *compiling to
19:34:28 <YayMe`> ben: keep your client code as loosely coupled as possible, have it make requests of the server but don't have it generated by the server, that is a train wreck that played out for too many years already
19:35:00 <Nisstyre> luite: I think the advantage of making Typed Racket the target language would be the ability to preserve most of Haskell's features, like type classes
19:35:08 <ben> but then i'm basically writing two programs
19:35:12 <ben> that seems like a lot of effort
19:35:14 <luite> Nisstyre: most haskell->js compilers also do that
19:35:24 <YayMe`> ben: exactly, but it's less effort over time
19:35:39 <YayMe`> ben: and best of all, your javascript will be *much* better
19:35:42 <luite> Nisstyre: fay is unique in that it doesn't use an existing compiler front end
19:35:53 <Nisstyre> luite: okay, sounds interesting
19:36:19 <YayMe`> ben: you'll learn javascript correctly that way as well.
19:38:07 <YayMe`> has anyone actually used a haskell->js compiler and found it stable performant js? I remember looking into that a while ago and everything I read gave the inclination that all the haskell->js compilers had been incomplete/unstable and then fallen to obsolescence(sp?)
19:38:24 <YayMe`> but I didn't try any out
19:39:12 <YayMe`> on a side note, are there any LLVM bytecode->JavaScript decompilers? (Is that even possible?)
19:39:18 <luite> yes, emscripten
19:40:16 <startling> YayMe`: it's just a compiler when you do that. :)
19:40:28 <centrinia> There are Javascript backends for LLVM.
19:40:41 <centrinia> https://github.com/kripken/emscripten
19:41:08 <luite> YayMe`: though i don't think anyone has ever succeeded getting haskell -> llvm -> js working with ghc
19:41:10 <startling> YayMe`, but yeah, seems like people are going more towards writing little functional languages that compile to js rather than compiling haskell itself
19:41:19 <luite> (neither do i think it's a great idea)
19:41:20 <startling> YayMe`, see elm and roy
19:41:43 <luite> startling: problem is that doing a full haskell compiler, even with an existing front end like ghc, is a huge amount of work
19:41:53 <luite> and many features don't really map easily to javascript
19:41:55 <luite> so more work
19:42:01 <startling> luite: yeah, I understand
19:42:04 <nand`> GHC already uses a number of intermediate languages for code generation, there are a few attempts at using those intermediate languages as ‘simpler languages to compile to javascript’
19:42:23 <startling> there was a small subset of haskell that someone had compiling to js, though I forget the name
19:42:24 <luite> haste and ghcjs both translate STG to javascript
19:42:28 <luite> startling: fay
19:42:32 <startling> ah
19:42:57 <YayMe> llvm byte code supports things javascript can't I would guess based on the plethora of languages that can compile to it
19:43:05 <luite> currently the generated code of ghcjs and haste looks very similar (if you overlook superficial details)
19:43:16 <luite> but i'm working on a new generator for ghcjs
19:43:37 <YayMe> I would think emscripten can only therefore naturally translate a subset
19:44:01 <luite> YayMe: emscripten doesn't support everything, but what features do you think it cannot support?
19:44:17 <startling> YayMe, well, they're both turing-complete languages
19:44:48 <luite> right, but javascript is a pretty terrible target language :)
19:45:04 <nand`> startling: of course, it's just possible to write a simulation of an x86 processor in javascript; but that would be fairly slow and undesirable
19:45:23 <startling> I assume emscripten has a runtime?
19:45:46 <luite> a major problem for haskell implementations is that javascript doesn't have tail calls
19:45:55 <startling> not yet!
19:47:00 <YayMe> luite: I'm just making a conclusion from the number of languages that can be represented in LLVM bytecode, including D, openJDK
19:47:08 <ddarius> nand`: http://www.visual6502.org/JSSim/
19:47:27 <nand`> ddarius: heh
19:47:39 <nand`> part of me knew it had already been done for educational purposes :)
19:47:56 <YayMe> luite: I presume that those languages have a super set of features in comparison to javascript, some portions of those languages could not map 1:1 with anything in javascript I am guessing
19:48:07 <ddarius> nand`: This is way beyond what you suggested.
19:48:44 <startling> nand`: http://bellard.org/jslinux
19:48:46 <nand`> ddarius: how so? it's a simulation of a processor, is it not?
19:49:28 <startling> nand`: simulating a circuit is different from simulating a processor
19:50:09 <nand`> (keep in mind that I'm looking at a relatively blank screen and have no idea what it is apart from the title ‘The Visual 6502’)
19:50:49 <ddarius> You could try clicking on the FAQ link.
19:52:24 <nand`> ah, I see; so it's a simulation of the underlying electric circuitry?
19:52:31 <nand`> in full scope
19:53:06 <YayMe> the things people are doing in javascript these days are baffling to me..
19:54:03 <ddarius> Don't worry.  The "fast" version is in Python.
19:54:19 <latro`a> *snrk*
19:54:37 <mkramer1> javascript is often faster than python at this point
19:56:06 <ParahSailin> v8 is pretty fast
19:56:38 <mkramer1> Less than 100 times slower than Haskell!
19:56:54 <nand`> Haskell is neither fast nor slow, did you mean GHC?
19:57:01 <lightquake> 22:56:33              <nand`> Haskell is neither fast nor slow, did you mean GHC?
19:57:04 <lightquake> is driving faster than walking?
19:57:18 <startling> mkramer1, pypy is pretty close if I recall correctly
19:57:21 <lightquake> or, i guess a better analogy would be 'is driving faster than running?'
19:57:26 <YayMe> lightquake: not if you're driving a pinto! o! burn!
19:57:49 <lightquake> if you're driving a pinto, then you will burn, yes
19:59:44 <YayMe> what's the built in function for isIn?
20:00:02 <YayMe> like isIn :: a -> [a] -> bool
20:00:02 <amosr> :t elem
20:00:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
20:00:18 <YayMe> right thanks
20:00:24 * YayMe thinks he needs to go read LYAH again
20:00:26 <amosr> @hoogle Eq a => a -> [a] -> Bool
20:00:26 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
20:00:26 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
20:00:26 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
20:00:32 <amosr> :D
20:00:43 <YayMe> oh that's how you use hoogle
20:00:46 <YayMe> that's fantastic
20:01:04 <amosr> yes, I think it's amazing
20:01:28 <johnw> hoogle is my sine qua non for Haskell coding
20:09:15 <moobull69> victory! I managed to get lambdabot compiled!
20:09:30 <startling> moobull69: are you on os x perchance?
20:09:35 <moobull69> And I would rather drown a puppy in a lake then do that over again XD
20:09:38 <carter> moobull69 congrats! with a recent version of ghc and a modern os?
20:09:49 <moobull69> ooh nope Im on ubuntu linux
20:09:52 <nand`> funny, compiling lambdabot was as easy as typing in the command over here
20:09:56 <moobull69> I believe it is recent
20:10:08 <carter> which version? ;p
20:10:11 <startling> I get a bunch of hsreadline errors because OS X's readline is bsd readline
20:10:26 <moobull69> their is a fix for that in google I think
20:10:30 <nand`> lambdabot 4.2.3.2 over here, probably a bit outdated by now
20:10:43 <carter> startling: you can brew install readline, and then brew link it
20:10:47 <carter> if you're using mac homebrew
20:11:04 <nand`> that being said, I haven't gotten it to compile under GHC 7.6.1 (I haven't attempted either)
20:11:09 <moobull69> how do I find out cabal's version?
20:11:18 <moobull69> x.x
20:11:19 <carter> cabal --version
20:11:24 <carter> same for ghc :)
20:11:35 <startling> carter: oh rly. that works?
20:11:40 <carter> should
20:11:42 <carter> for readline?
20:11:44 <carter> yes
20:11:48 <moobull69> cabal-install version 0.14.0
20:11:48 <moobull69>   using version 1.14.0 of the Cabal library
20:11:51 <carter> ok
20:11:53 <carter> ang hc?
20:11:57 <carter> and ghc?
20:12:17 <moobull69> The Glorious Glasgow Haskell Compilation System, version 7.4.1
20:12:37 <carter> cool
20:12:52 <carter> what were the challenges in building it?
20:13:04 <nand`> (any reason why 7.4.1 and not 7.4.2?)
20:13:09 <moobull69> I got stuck at the readline dependancy's. but I just had to download all of the different libs and the -dev ones too
20:13:14 <carter> ok
20:13:17 <carter> so yer on linux :)
20:13:31 <moobull69> mostly every time I did cabal install lambdabot it would error out with a missing dependancy
20:13:38 <moobull69> yep :P
20:13:51 <nand`> for me the dependencies got pulled in automatically
20:13:57 <nand`> very handy
20:14:13 <startling> I get /Users/tim/.cabal/lib/readline-1.0.1.0/ghc-7.4.2/HSreadline-1.0.1.0.o: unknown symbol `_rl_basic_quote_characters' / ghc: unable to load package `readline-1.0.1.0'
20:14:15 <moobull69> I am wondering why it didn't for me. but then again I compiled from source so thats prob why
20:14:18 <startling> even after brew link readline
20:14:19 <carter> moobull69: you may want ot use cabal-dev
20:14:22 <nand`> moobull69: so did I
20:14:25 <nand`> moobull69: I didn't use cabal-install
20:14:44 <carter> startling: you need to rebuild the haskell readline lib :)
20:14:48 <moobull69> I ment I compiled the haskell compilers from source :P
20:14:48 <carter> its linking to the wrong one!
20:14:54 <nand`> moobull69: so did I :)
20:14:59 <moobull69> ooh lol :)
20:15:07 <ddarius> Why would you build 7.4.1 then?
20:15:12 <moobull69> it is weird mine didn't pull them down
20:15:22 <moobull69> I actually had trouble finding the newest one
20:15:31 <nand`> the newest one is 7.6.1
20:15:36 <nand`> the newest stable one*
20:15:38 <ddarius> haskell.org/ghc
20:16:15 <carter> though lambdabot may not play nice with ghc 7.61....
20:16:23 <carter> a bunch of ghc specific api's changed
20:16:38 <carter> from 7.4 to 7.6
20:16:44 <moobull69> on the site before you build haskell from source it sas to get ghc 7.4.1
20:16:46 <nand`> yes, lambdabot as-is certainly does not compile under 7.6.1
20:16:52 <nand`> either due to its dependencies being broken or it itself being broken
20:17:11 <moobull69> thats what I did :P
20:17:41 <moobull69> I guess its a good thing I didn't get the latest one, I would have lost all my hair trying to fix it XD
20:17:58 <YayMe> what is lambdabot for other than irc? Can you have it in console mode to just sit there and query it directly?
20:18:02 <nand`> 7.4.2 was a drop-in replacement for 7.4.1 for me
20:18:02 <carter> moobull69 now you know to ask the irc greybeards
20:18:03 <carter> :)
20:18:06 <nand`> and lambdabot compiles fine under 7.4.2
20:18:16 <nand`> YayMe: exactly
20:18:21 <carter> yeah, actually 7.4.2 fixes a few big bugs
20:18:24 <carter> I forget what
20:18:39 <dmwit> bleh
20:18:45 <johnw> carter: darn, just shaved today
20:18:58 <carter>  johnw : me too
20:19:03 <carter> darn ingrowns
20:19:09 <dmwit> ddarius: Do you remember the name/title of that paper about putting constraints on the number of elements in a data structure?
20:19:21 <carter> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/release-7-4-2.html
20:19:29 <dmwit> Like, only allowing numbers from a certain polynomial?
20:19:29 <carter> lists a LARGE number of bug fixes
20:19:34 <moobull69> lol true
20:19:51 <carter> moobull69: you may want to switch to a prebult 7.4.2 build :)
20:19:53 <carter> soonish
20:20:39 <moobull69> ooh, ok
20:20:56 <carter> the lambda bot binary should still be "ok"
20:20:58 <carter> mabye
20:21:07 <carter> but you can easily rebuild anything for 7.4.2
20:21:23 <moobull69> so only get ghc 7.4.2?
20:22:02 <carter> for now yes... many libraries don't quite yet build for 7.6
20:22:15 <carter> or be one of the daring bold awesome folks
20:22:26 <carter> who find the problems that prevent things from building
20:22:37 <carter> and get em patched afore everyone else joints in
20:22:40 <carter> joins in
20:22:48 <carter> :-)
20:22:54 <moobull69> lol
20:22:57 <carter> depends on if ghc is for fun or profit or both
20:23:12 <carter> i'm either for fun or both fun and profit
20:23:20 <carter> so may as well help out when i can
20:23:48 * carter found a ghc type inference bug that got fixed in the 7.6 release candidate while trying to get idris to build on 7.6 :)
20:24:02 <YayMe> what's new in 7.6?
20:24:17 <carter> YayMe: Datakinds / type level data stuff
20:24:24 <carter> is now "fully working"
20:24:28 <carter> theres a few experimental things
20:24:35 <carter> a new code generator backend thats still experimental
20:24:36 <startling> what's new in 7.6 that breaks old packages?
20:25:03 <carter> startling: for one thing, some ghc api changes
20:25:13 <nand`> startling: most breakage seems to be from base library changes from what I can tell
20:25:21 <startling> oh, that makes sense
20:25:22 <carter> version bumps of some core libraries also break cabal building
20:25:32 <nand`> eg. the Bits class no longer having Num as a superclass
20:25:42 <nand`> and other changes like that
20:25:42 <carter> a bunch of api changes that were warnings in 7.4 are now errors
20:25:47 <carter> nand` yup!
20:25:48 <YayMe> I don't think I fully understand "kinds", I read the bits in LYAH but it just seemed to me like a classification system that exists as a less general form of signature than the signature already had
20:25:49 <nand`> or the old Prelude.catch stuff being removed
20:26:08 <carter> YayMe: in some ways, YES
20:26:13 <nand`> YayMe: kinds are like the types of types, if that makes sense
20:26:22 <YayMe> that's basically what I thought
20:26:31 <mgsloan> yeah, most of what I saw was either Prelude.catch, changes to InlinePragma in TH, or more stringent requirements on FFI newtype usage
20:26:32 <YayMe> problem is, I don't see how that's useful
20:26:43 <carter> mgsloan yup, thats what i've seen
20:26:52 <carter> YayMe: dont' worry, it is :)
20:26:54 <YayMe> I'm sure it is otherwise it wouldn't be there, but since I don't see how it's useful I figure I'm missing something
20:27:10 <nand`> if we didn't have a kind system, it would be possible to represent illogical things like ‘List List’; as opposed to something like ‘List (List Char)’. List :: * -> *
20:27:45 <nand`> so you can't give a kind ‘* -> *’ to a type that expects an argument of kind ‘*’; the same way you can't pass a function of type ‘Int -> Char’ to a function that expects an argument of type ‘Char’
20:28:17 <YayMe> nand: ah, so it is another classification system that's not a subset of the normal signatures
20:28:18 <ddarius> dmwit: Manufacturing Data Types?
20:28:30 <nand`> it's not a subset; it's a separate layer on top
20:28:40 <nand`> so yeah, it's another classification system
20:28:49 <nand`> values have types; types have kinds; kinds have sorts; etc.
20:29:04 <YayMe> nand`: but it creates segments in the types based on what you just said
20:29:18 <carter> YayMe: whats a segement here? :)
20:29:21 <mgsloan> was just watching the SPJ video.. looking forward to the TH revamp
20:29:22 <YayMe> if the boundaries it implied didn't exist, the types would have an amorphousness that would allow illogical things
20:29:23 <nand`> I don't know what you mean by ‘segment in the types’
20:29:33 <YayMe> i mean.. seperates them
20:29:51 <scshunt> TH revamp?
20:29:52 <scshunt> Uh oh
20:29:52 <nand`> well yeah, each kind is like a set of types - sort of like how each type is like a set of values
20:30:27 <carter> mgsloan: the typed and mushy th variants?? yesss :)
20:30:33 <YayMe> nand`: right, so it's not a superset but it's not necessarily a superset right
20:30:40 <dmwit> ddarius: Yes! Thank you! permanently bookmarked
20:30:53 <YayMe> s/superset/subset/f
20:30:56 <nand`> the kind * ‘contains’ stuff like Int or Bool the same way the type Bool ‘contains’ values like True or False; similarly the type ‘Int -> Char’ could contain something like ‘chr’, while ‘* -> *’ could contain something like ‘Maybe’
20:31:22 <YayMe> right
20:31:32 <mgsloan> carter: oh yeah!!  I'll have to file in my 2 cents about TH tweaks soon - can't go revamping it all the time afterall.
20:31:57 <carter> review periods etc
20:31:57 <YayMe> so kind's are basically the signatures of constructors?
20:32:11 <carter> YayMe: yess
20:32:18 <carter> theres more you can do
20:32:20 <carter> but to start with
20:32:21 <carter> yes
20:32:22 <nand`> type constructors, yeah
20:32:25 <nand`> or just types in general
20:32:37 <nand`> (‘constructor’ also refers to value constructors like Just)
20:32:53 <YayMe> right
20:33:40 <YayMe> I've kind of come to think of the haskell type system like this: If the first letter's a capital, it's a constructor function
20:34:14 <nand`> capital names have different meanings depending on the context
20:34:32 <YayMe> How so?
20:34:39 <nand`> (in value contexts, they are value constructors like Just; in type contexts they are types like Maybe or Int)
20:34:50 <nand`> Foo :: Foo  -- Foo has two different meanings here
20:34:52 <nand`> see data Foo = Foo
20:35:05 <dolio> Capital types are the type constructors.
20:35:32 <dolio> Well, that's actually not true.
20:35:47 <dolio> Unfortunately.
20:36:12 <ddarius> That analogy has been destroyed over time.
20:36:26 <dolio> It was never right. Because of type.
20:36:27 <dmwit> This paper really is a gem.
20:37:21 <ddarius> dmwit: Yeah, I find myself trying to remember it every few years.
20:38:18 <Nisstyre-laptop> type operator == type constructor?
20:38:42 <Nisstyre-laptop> is -> considered a type constructor?
20:38:47 <dolio> Yes.
20:38:50 <Nisstyre-laptop> cool
20:39:43 <dolio> Types declared with newtype and data, tuples and (->) are the type constructors, more or less.
20:39:43 <dmwit> I think it's possible to have type operators that are variables, not constructors.
20:39:46 <dmwit> At least, it used to be.
20:39:54 <dolio> They act like constructors of *.
20:39:57 <nand`> ‘type operator’ to me means something like ‘data a + b = L a | R b’
20:40:00 <nand`> + being the operator
20:40:10 * ddarius views -> as a kind constructor.
20:40:27 <Nisstyre-laptop> nand`: I think "type operator" means something that constructs new instances of types
20:40:31 <dmwit> -> is universe-polymorphic!
20:40:33 <dolio> And you can do case analysis on * with them, via type classes.
20:40:35 <Nisstyre-laptop> possibly nullary types
20:40:56 <Nisstyre-laptop> someone correct me if I'm way off
20:41:10 <dolio> Or on * -> *, or ....
20:41:25 <dolio> I guess in that sense they're weird.
20:41:33 <nand`> ‘kind constructor’ has me a bit puzzled
20:42:07 <nand`> oh, because * -> * is a valid kind ?
20:42:13 * cmccann prefers unkind constructors. programmers have it too easy.
20:42:16 <Nisstyre-laptop> nand`: well, I've been reading papers on hindley-milner/system f/etc... and it seems like "type operator" gets used such that it includes -> as a type operatr
20:42:19 <Nisstyre-laptop> *operator
20:42:36 <Nisstyre-laptop> s/f/w/
20:43:26 <Nisstyre-laptop> I have no idea if Haskell's type system considers them to be the same thing
20:43:40 <cmears> Is it considered bad form to put "-O2" in the ghc-options part of a cabal configuration?
20:44:00 <YayMe> let's see if I can avoid asking and just use hoogle..
20:44:02 <dolio> The thing that makes them really like constructors is that they're disjoint and injective by hypothesis in GHC.
20:44:26 <dolio> Of course, that's not necessarily a characteristic of constructors on the value level if you get fancy enough.
20:45:15 <YayMe> @hoogle (a -> Bool) [a] -> Bool
20:45:15 <lambdabot> No results found
20:45:26 <YayMe> balls, I stink at this
20:45:45 <MostAwesomeDude> @hoogle (a -> Bool) -> [a] -> Bool
20:45:46 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
20:45:46 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
20:45:46 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
20:45:49 <dolio> Have you been writing Clean?
20:45:51 <Nisstyre-laptop> @hoogle (a -> a -> Bool) -> [a] -> [a]
20:45:52 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
20:45:52 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
20:45:52 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
20:45:56 <YayMe> me?
20:45:59 <dolio> Yes.
20:46:02 <YayMe> No
20:46:13 <YayMe> I just did a dumbs
20:46:28 <dolio> Clean has type signatures that look like 'S T -> U' instead of 'S -> T -> U' as I recall.
20:46:41 <YayMe> more like SKI
20:46:47 <dolio> With slightly different characteristics, probably.
20:47:19 <dolio> Or perhaps not, I'm not sure.
20:47:24 <nand`> would the opposite of ‘higher order language’ be ‘first order language’?
20:47:30 <Nisstyre-laptop> nand`: lower order?
20:48:11 <YayMe> lower disorder gibberish?
20:49:23 <dolio> You'd have to define "opposite" I think.
20:50:03 <Nisstyre-laptop> dolio: depends if you want a precise answer or not
20:51:45 <nand`> dolio: negation; a synonym for “non-higher-order language”
20:52:13 <YayMe> I presume "all" will die at the first false, no?
20:52:20 <nand`> YayMe: yes
20:52:22 <ddarius> dolio: Yes S T -> U is slightly different from S -> T -> U
20:52:37 <nand`> YayMe: the semantics of (&&) dictate it
20:52:58 <Cale> @src (&&)
20:52:59 <lambdabot> True  && x = x
20:52:59 <lambdabot> False && _ = False
20:53:15 <Cale> > undefined
20:53:16 <lambdabot>   *Exception: Prelude.undefined
20:53:20 <nand`> ah https://en.wikipedia.org/wiki/Higher-order_function
20:53:22 <Cale> > False && undefined
20:53:24 <lambdabot>   False
20:53:37 <dolio> Well, 'higher-order' often means that you get nth-order for all n. So there are lots of not-higher-order things. Just cut off at any finite n.
20:53:40 <nand`> “all other functions are first order functions” <- I presume the same extends to languages, higher order language simply meaning a language which has higher order functions
20:53:47 <YayMe> I'm not sure how I feel about this erc, it scrolls half a window up in chunks
20:53:53 <nand`> dolio: yeah, n=1 aka first-order sounds fair enough
20:54:47 * ddarius was given a boule of sourdough at work this evening.
20:54:53 <startling> twelth order
20:57:26 * cmccann uses only fifteen-and-three-quarters-th order constructs and not one jot or tittle higher.
20:57:49 <nexion> if I have a list of pairs (key, value) with some duplicate keys, how can I combine them by summing the values and thus eliminate the duplicates?
20:58:16 <nexion> it's fairly easy either way, but I'd like to know which helper functions are there for it
20:58:25 <nand`> n=0, rather*
20:59:02 <cmccann> I usually do the quick and easy thing and shove them into Data.Map using the insert and accumulate thingie
20:59:12 <nexion> oh
20:59:13 * cmccann can't remember what the function's name is
20:59:18 <ddarius> FP (and Sisal?) was a second order language.
20:59:55 <guymann> compiling ghc ;)
21:00:32 <luite> nexion: toList . fromListWith if your keys are Ord
21:00:45 <ddarius> Heffalump: What have you been up to?
21:01:17 <luite> nexion: that's Data.Map, the full thing would probably be toList . fromListWith (+)
21:01:59 <ddarius> @hoogle fromListWith'
21:01:59 <lambdabot> No results found
21:04:28 <nexion> luite, works.. ty :)
21:04:51 * ddarius doesn't believe that.
21:08:06 <Axman6> ddarius: that luite works?
21:12:29 <YayMe> @hoogle (a -> Bool) -> [a] -> a
21:12:29 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
21:12:29 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
21:12:29 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
21:17:12 <YayMe> if I use somefunc $ someRangeGenerator
21:17:36 <YayMe> will the range generator generate the entire range before feeding values to someFunc?
21:18:11 <startling> YayMe: not of its own volition
21:18:29 <startling> YayMe: but if someFunc is `length`, for example...
21:18:41 <YayMe> so the $ will still allow the laziness to feed them in
21:18:53 <dmwit> The pedantic answer is "the language definition doesn't say".
21:18:56 <startling> x $ y is the same as x y
21:19:07 <YayMe> startling: ok good to hear
21:19:13 <startling> @src ($)
21:19:13 <lambdabot> f $ x = f x
21:35:52 <NemesisD> hi all. isn't there some trick for getting bytestring's isstring instance working?
21:36:38 <ivanm> NemesisD: import the Char8 module
21:38:16 <hpaste> NemesisD pasted “domain socket test” at http://hpaste.org/74979
21:38:28 <NemesisD> doesn't seem to be working
21:41:50 <fmap> Network.Socket.recv returns IO String
21:43:06 <fmap> hmm, interesting, you don't get `ambiguous recv' error
21:43:10 <DijkstraGroupie> What is the latest version of cabal-install?
21:43:28 <ivanm> 0.14
21:44:25 <NemesisD> fmap: realized my mistake and hid recv from Socket, imported recv from Socket.ByteString but the thing its bugged about is it isn't turning the string literal into a bytestring
21:46:45 <fmap> NemesisD: what
21:47:04 * hackagebot websockets 0.7.0.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.7.0.0 (JasperVanDerJeugt)
21:47:29 <fmap> NemesisD: if msg1 is ∷ String, how can it turn "msg1: " literal into ByteString?
21:48:35 <NemesisD> fmap: it isn't, it should be BS8.ByteString using OverloadedStrings
21:49:46 <NemesisD> erm i must have fixed it. now it is a runtime error because it can't find the domain socket. would you happen to know the proper way of creaating the socket file?
21:51:15 <fmap> NemesisD: It is, your "where" clauses aren't used
21:52:04 * hackagebot websockets-snap 0.7.0.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.7.0.0 (JasperVanDerJeugt)
21:55:02 <fmap> NemesisD: It can be helpful to run code with -Wall, then you see "shadows the existing binding" warnings
21:56:23 <NemesisD> fmap: yeah. that was from copying from my other haskell file which is the receiving end
21:58:06 <zzing> :t unsafePerformIO
21:58:07 <lambdabot> Not in scope: `unsafePerformIO'
21:58:24 <Nereid> someone remind me what that thing is called, where given two lists [a,b] (possibly infinite), I get a list of all pairs (a,b) from those lists
21:58:40 <mm_freak> Nereid: zip?
21:58:43 <Nereid> no
21:58:57 <mm_freak> Nereid: give a type
21:59:05 <Nereid> [a] -> [b] -> [(a,b)]
21:59:06 <Nereid> but I mean
21:59:16 <Nereid> given [1..] and [1..], I should see things like [(1,1), (1,2), (2,1), (1,3), (2,2), (3,1), ...]
21:59:26 <ivanm> Nereid: [ (x,y) | x <- xs, y <- ys ]
21:59:28 <Nereid> so every pair of positive integers appears
21:59:30 <ivanm> cross-product
21:59:35 <mm_freak> Nereid: ah, see the 'logict' package
21:59:37 <Nereid> ivanm: that doesn't work when xs is infinite
21:59:40 <fmap> NemesisD: so, you receive `String' from `recv', then you have a list `["msg1: " ∷ IsString a => a, msg1 ∷ String]' and the only thing which typechecks would be ["msg1: " ∷ String]
21:59:56 <mm_freak> Nereid: it does exactly that
21:59:56 <ivanm> Nereid: sure it does; just might not give the order you want!
22:00:02 <Nereid> ivanm: no, it really doesn't work
22:00:04 <mm_freak> ivanm: it doesn't
22:00:10 <fmap> (last [] are actually `')
22:00:13 <ivanm> oh? how doesn't it?
22:00:18 <mm_freak> ivanm: it diverges
22:00:23 <mm_freak> ah, no
22:00:26 <Nereid> > [(x,y) | x <- [1..], y  <- [1..]]
22:00:27 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
22:00:32 <Nereid> clearly it'll never produce (2,1)
22:00:35 <mm_freak> but it doesn't diagonalize
22:00:49 <ivanm> Nereid: sure, but that's an ordering problem
22:00:58 <Jafet> > [(x,y) | x <- [1..], y <- [1..x]]
22:00:59 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5...
22:01:02 <Nereid> ivanm: yes, omega and omega^2 are very different ordinals
22:01:06 <ivanm> doesn't it require better knowledge of the types involved to be able to give you the output you want?
22:01:07 <Nereid> we can only see up to omega
22:01:31 <Jafet> You can just combine arbitrary lists in the same order that would be given by the above
22:01:50 <Nereid> Jafet: that doesn't the ones where x < y
22:02:01 <Nereid> oops, verb
22:02:03 <ivanm> Nereid: but if you want arbitrary [a] -> [b] -> [(a,b)] how can you guarantee any ordering?
22:02:11 <NemesisD> fmap: yeah i follow now. my typechecking errors are over. the problem now is the socket is showing as "no such file or directory"
22:02:26 <Jafet> [(y, x-y) | x <- [1..], y <- [0..x-1]]
22:02:32 <mm_freak> ivanm: the list /monad/ doesn't do what Nereid does, no matter what types you use
22:02:33 <Jafet> Or something
22:02:38 <mm_freak> s/does/wants/
22:03:28 <mm_freak> and i have a feeling that Nereid wants something practical =)
22:03:32 <Nereid> I do
22:03:33 <ivanm> mm_freak: sure, but is there a function of type [a] -> [b] -> [(a,b)] that does what he want?
22:03:36 <mm_freak> so see the logict package
22:03:37 <Nereid> yes
22:03:41 <Nereid> mm_freak: I'm looking
22:03:53 <mm_freak> ivanm: sure, it's in the logict package 0)
22:03:55 <mm_freak> =)
22:03:56 <copumpkin> or control-monad-omega
22:04:03 * ivanm is looking, hold your horses!
22:04:12 <copumpkin> @hackage control-monad-omega
22:04:12 <lambdabot> http://hackage.haskell.org/package/control-monad-omega
22:04:15 <Nereid> copumpkin: yes! that's what I was trying to find.
22:04:16 <scshunt> omega^omega is fun :P
22:04:22 <copumpkin> http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html
22:04:24 <Nereid> copumpkin: I just forgot the name. thanks!
22:04:28 <copumpkin> np
22:04:48 <copumpkin> Cale: can we haz Omega? :)
22:04:53 <ivanm> mm_freak: I don't see anything that jumps out at me for writing said function
22:04:58 <zzing> I am so going to hell… logLogFile (unsafePerformIO $ openFile "/var/log/socrlog" AppendMode)
22:05:20 <copumpkin> runOmega $ liftM2 (,) (each [0..]) (each [0..])
22:05:31 <ivanm> copumpkin: yes, I meant in logicT
22:05:37 <mm_freak> ivanm: 'interleave'
22:05:47 <mm_freak> ivanm: Control.Monad.Logic.Class
22:05:53 <copumpkin> > fix (interleave [0..])
22:05:54 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
22:06:01 <ivanm> ahhh, I wasn't looking in Class
22:06:35 <ivanm> > let odds = return 1 `mplus` liftM (2+) odds in odds
22:06:38 <lambdabot>   No instance for (GHC.Show.Show (m t))
22:06:38 <lambdabot>    arising from a use of `M1158599620...
22:06:57 <ivanm> bah
22:07:44 <Cale> > runOmega $ liftM2 (,) (each [0..]) (each [0..])
22:07:45 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
22:07:53 <NemesisD> i guess before banging my head on this further i should ask if unix domain sockets are the right choice
22:07:54 <copumpkin> yay!
22:07:58 * copumpkin hugs Cale 
22:08:05 <copumpkin> :t runOmega
22:08:06 <lambdabot> forall a. Omega a -> [a]
22:08:20 <ivanm> @type interleave
22:08:20 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
22:08:21 <NemesisD> i've got a long-running process management process in hsakell and i want to write small binaries that will interrogate it for info or send it commands
22:09:39 <AfC> NemesisD: Unix sockets as opposed to TCP sockets to localhost? (or as opposed to some completely different approach?)
22:10:24 <NemesisD> AfC: exactly, i'd consider other approaches too. looking for something simple. windows support is not required
22:11:02 <johnny934759> when is haskell prime suppose to be release?
22:11:09 <ivanm> johnny934759: never
22:11:11 <ivanm> that's the whole point
22:11:18 <AfC> NemesisD: I mean, Unix sockets are *fine* and under extreme load give _slightly_ better performance. But most people are more used to programming against (much) higher level APIs
22:11:29 <ivanm> if you mean "when is the next version coming out of Haskell' going to come out", next year IIRC
22:11:45 <NemesisD> AfC: such as?
22:11:47 <ivanm> wasn't that when we were going to have the Monad hierarchy fixed with backward-incompatible changes, etc.?
22:11:53 <johnny934759> ivanm: ummm ok when will all these extensions to incorporated into haskell/ghc
22:12:03 <johnny934759> so many to keep track of
22:12:26 <AfC> NemesisD: ie HTTP, but it all depends what you're trying to do. If you've already got a control protocol written, then a local socket is certainly going to work, but if you want to escalate up the layers and work in HTTP et al that's fine too. Unless you're doing crazy load against it. Which it doesn't sound liek
22:12:39 <ivanm> johnny934759: not all will get incorporated from GHC into a new Haskell standard
22:12:46 <NemesisD> AfC: load is almost nil. the only thing instigating these connections will be a person typing a command on the command line
22:12:51 <ivanm> for starters, at least one other implementation has to have that extension if memory serves
22:13:15 <NemesisD> AfC: http would be a weird choice. maybe it would help to know the project
22:13:17 <ivanm> and a lot of the extensions probably _shouldn't_ be formalised and made official as they can cause problems if not used carefully
22:13:29 <ivanm> (e.g. UndecidableInstances)
22:13:34 <johnny934759> sometimes i feel everyone is using a different subset of haskell extensions
22:13:35 <NemesisD> i'm working on the Angel project, which is a process monitor that keeps an eye on processes and restarts them when they die
22:13:46 <AfC> NemesisD: just saying
22:14:01 <AfC> NemesisD: we use Angel. Love it. (rough edges, but definitely on the right track)
22:14:07 <NemesisD> i want to add a suite of subcommands that interrogate/control the monitor, like angel-status, or angel-restart someprogram
22:14:10 <johnny934759> it would be good if another release brings them together into a more organize langauge
22:14:48 <NemesisD> AfC: yeah i want to use it at my company so i wanted to help get it a bit more full featured before i can truly advocate it (we're a ruby shop)
22:15:12 <AfC> NemesisD: did you ever use `supervise` from DJB's daemontools?
22:15:59 <Cale> johnny934759: It's better imo to just standardise the extensions as extensions. Standardisation also has the really annoying property of causing stagnation.
22:16:23 <AfC> NemesisD: (if so, then you're likely to be happy with Angel. If not, then you might end up banging your head against its design)
22:16:52 <NemesisD> AfC: nope. we've only used ruby process monitors, god and bluepill, both of which are abandoned and seem to fail to do their job lots of the time
22:17:11 <AfC> NemesisD: [I can't stay to talk; have to finish up my slides for a (Haskell!) talk I'm giving at fp-syd tonight. ping me tomorrow? I'd love to talk with you further]
22:17:12 <ivanm> johnny934759: the only "difference" in subsets of extensions you tend to find is TFs vs MPTCs+FDs
22:17:40 <ivanm> oh, and I think UHC has some slightly different extensions
22:17:41 <NemesisD> AfC: sure, i'll be back on maybe around this time tomorrow if i remember
22:17:45 <ivanm> (Kind promotion?)
22:18:10 <Cale> and even multiparameter typeclasses and type families work together pretty well
22:19:15 <johnny934759> but most tutorials and books dont cover anything pass haskell98
22:19:31 <ivanm> because a) they're too old for Haskell2010
22:19:42 <ivanm> b) they're trying to teach you the fundamentals first rather than fancy stuff
22:19:48 <ivanm> though I think RWH covered some extensions
22:23:48 <Cale> You can pick up the extensions just by reading the GHC User's Guide and/or specific tutorials though.
22:26:12 <zzing> :t (+)
22:26:13 <lambdabot> forall a. (Num a) => a -> a -> a
22:26:36 <latro`a> I feel like a lot of the tutorials for extensions aren't very good at showing why you want them
22:27:05 <latro`a> for example I still don't really understand why MPTCs without anything else are near-useless
22:34:36 <johnny934759> that's true, instead of many little extensions for more expressive types... why not use dependent types?
22:34:50 <johnny934759> technical reasons?
22:36:52 <mm_freak> johnny934759: dependent types have some consequences we don't want in general in haskell
22:38:30 <mm_freak> johnny934759: also the need for dependent types gets smaller and smaller, while keeping those desirable properties (like decidability) of the type system
22:38:46 <johnny934759> i see
22:39:09 <mm_freak> also without termination checking DTs are like masturbating without the payoff
22:48:34 <ddarius> The general thrust of GHC and Haskell type extensions in general has not been toward dependent types, though there is certainly some inspiration from there.
22:58:40 * ddarius would also like to point out that most of the "dependently typed" languages people talk about, particularly Coq, are in the most powerful corner of the lambda cube and so would subsume most of Haskell's type system even completely neglecting dependent typing.
22:59:07 <pharaun> isn't Coq still fairly experimental?
22:59:26 <ddarius> In other words, these languages have extremely powerful type systems because they have extremely powerful type systems, not because a dash of dependent types was added.
23:00:23 <pharaun> and here i was thinking that i had finally gotten a powerful type system ;)
23:00:53 <Nereid> for a second I was thinking
23:00:58 <Nereid> "what's an easier way to write"
23:01:05 <Nereid> @type liftA2 f (pure x)
23:01:06 <lambdabot> forall b c (f :: * -> *). (Show b, SimpleReflect.FromExpr c, Applicative f) => f b -> f c
23:01:07 <Nereid> er
23:01:12 <Nereid> @type \f x -> liftA2 f (pure x)
23:01:13 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> a -> f b -> f c
23:01:19 <Nereid> but then it's obvious.
23:01:35 <latro`a> fmap (f x)
23:01:36 <Nereid> @type \f x -> fmap . f $ x
23:01:37 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> a -> b) -> a1 -> f a -> f b
23:01:39 <ddarius> pharaun: Coq is older than Haskell.  It's a fairly mature system.
23:01:45 <Nereid> yeah.
23:02:07 <NemesisD> anyone know anything about domain sockets? i've got a test program going but for some reason the socket file gets left around after all connections are closed on both ends. whats up with that
23:02:09 <pharaun> ddarius: oh? hah i suppose i'll check it out eventually then :)
23:02:26 <ddarius> pharaun: You can view Haskell as exploring the world of polymorphic and qualified types under the constraint of maintaining almost full type inference.
23:02:47 <ddarius> (As well as other, non-type related areas of the PL design space.)
23:02:51 <Nereid> and then my code got a lot cleaner.
23:02:57 <Nereid> instead of
23:03:17 <Nereid> map (liftA2 (!) (pure arr)) xs
23:03:22 <Nereid> I get (map . map) (arr !) xs
23:03:23 <Nereid> duh
23:03:45 <ddarius> Nereid: It's easier to see that using (<$>) and (<*>).
23:04:00 <Nereid> it was easy enough to see.
23:04:38 <ddarius> Maybe what I want to say is if you used (<$>) and (<*>) you would have seen it to begin with or possibly never written it to begin with.
23:04:45 <Nereid> I did initially have that.
23:05:06 <Ralith> pharaun: my understanding is that coq is more oriented on theorem proving than actual direct programming, though.
23:05:06 <Nereid> but then I went in the wrong direction.
23:05:24 <Ralith> pharaun: idris is exciting in that it attempts the reverse
23:05:41 <dolio> The main thing that GHC has that people think of with dependent types is inductive families (GADTs), but they aren't strictly related to dependent types.
23:05:44 <ddarius> That said, since I come from a time before Applicative, let alone it's popularity, I do have a soft spot for liftMn and co.
23:05:51 <dolio> They just allow you to do a lot of the stuff that people associate with dependent types.
23:05:55 <Nisstyre> coq is great for proving things in constructive logic
23:06:02 <ddarius> dolio++
23:06:05 <Nereid> anyway, this is why I should write code more often.
23:06:37 <ddarius> It took several years for Applicative to actually start being used.
23:06:47 <dolio> I thought of an example a while back of stuff you really couldn't do with GHC's approach, but I can't remember what it was.
23:06:48 <ddarius> And then it just happened overnight.
23:06:58 <Nisstyre> Ralith: I guess Coq can extract a program from your proof, though :P
23:07:06 * hackagebot hdiscount 0.1.0.0 - Haskell bindings to the Discount markdown library  http://hackage.haskell.org/package/hdiscount-0.1.0.0 (JamieTurner)
23:07:08 <Nisstyre> so that makes it useful for programming
23:07:09 <pharaun> Ralith: aha i see :)
23:07:16 <ddarius> Nisstyre: If only it extracted a good program...
23:07:22 <Nisstyre> ddarius: haha
23:07:23 <certainty> moin
23:07:32 <dolio> I think it had to do with the fact that you would never be able to start using an inductive family of singleton function types instead of the normal function space.
23:07:52 <dolio> So you're screwed if you want to depend on a function.
23:07:53 <Ralith> pharaun: contribute to idris! \o/
23:08:01 <Nereid> @type liftA2 (map . (+))
23:08:02 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f [a] -> f [a]
23:09:29 <ddarius> @google Atsushi Ohori "Register Allocation by Proof Transformation"
23:09:31 <lambdabot> http://dl.acm.org/citation.cfm?id=1765741
23:09:31 <lambdabot> Title: Register allocation by proof transformation
23:10:33 <pharaun> Ralith: heh i'll take a look at it, i'm still fairly happy with haskell so far :)
23:10:36 <ddarius> A lot of what people associate with dependent types has little/nothing to do with dependent types and tends to be type level calculation.
23:10:54 <ddarius> Also, people who think dependent types are wonder magic should try programming in Elf or Twelf.
23:11:04 <pharaun> never heard of elf/twelf
23:12:49 <dolio> ddarius: Well, doing somewhat advanced levels of program verification is associated with dependent types, I think. And you can arrange to do that a lot of times by reconstructing everything at the type level and having everything at the term level correspond to the type level by construction.
23:13:01 <dolio> Which is awful, but you can do it.
23:13:47 <dolio> Then you're not really proving things about your terms directly like you would with dependent types. You're proving things about the types which corresponds to things about the terms by construction.
23:13:59 <ddarius> LF is a lot closer to \P which is what you'd get by adding only dependent types to the simply typed lambda calculus.
23:14:59 <dolio> I think that approach probably blows up when you want to prove things about algorithms that are higher-order, but I don't have a good example off hand.
23:16:49 <maukd> so I'm implementing 32-bit integers in lambda calculus
23:17:19 <maukd> is there a smart way to convert from/to native ints?
23:17:37 <ddarius> Without GADTs, I think that approach blows up (though not completely) as soon as you move beyond singleton types which you will usually want/need to do.  Basically, then you have to use probably phantom types and then you lose the "true by construction" and instead have to enforce that with an abstraction barrier.
23:18:17 <dolio> No, I'm talking about GADTs.
23:18:42 <ddarius> It's not as clear with GADTs.
23:18:44 <dolio> Everything you use at the term level is a GADT indexed by what you really want moved up to the type level.
23:20:15 <dolio> But there's no GADT of functions indexed by themselves moved up to the type level.
23:20:41 <dolio> Because function spaces aren't inductive families.
23:20:58 <dolio> At least, not normally.
23:21:42 * ddarius should see what happens if you use nested types at the type level.
23:22:03 <ddarius> We need to add kind polymorphic recursion.
23:22:20 <dolio> Yeah. Everyone loves nested types.
23:23:03 <tims> /quit
23:23:10 <shachaf> dolio: Nice talk about dependent types by roconnor today. Pity you missed it.
23:23:44 <dolio> Yeah.
23:24:03 <shachaf> Well, it probably didn't really have anything you didn't already know about.
23:24:12 <dolio> That's also probably true.
23:24:20 <ddarius> He could have asked questions about things he didn't already know about.
23:24:22 <dolio> I'd at least know what roconnor looks like, though.
23:24:45 <dolio> That's worth round trip plane fare to California.
23:25:14 <ddarius> At any rate, the depths of parametric programming or even higher order programming have scarcely been plumbed.
23:25:16 <shachaf> dolio: Probably round-trip plane fare to Ontario is easier.
23:25:21 <ddarius> Weird shit happens with 3rd order programs.
23:25:22 <shachaf> He's only here for a week.
23:25:35 <mm_freak> dependent types alone really just collapse some of the separate definitions in haskell (liftA*, zip*, etc.)
23:26:05 <dolio> shachaf: I'll probably just meet him when we hire him.
23:26:07 <dolio> Bwahahahaha.
23:26:14 <ddarius> mm_freak: That would be more power than you'd need unless you wanted to do something like read in the number of elements to zip.
23:27:13 <mm_freak> also what people forget:  dependent types make programming more inconvenient in general except for the corners where you want to harness the power of them
23:27:16 <dolio> I'm not sure I've ever seen a zip* that's any good even in a dependently typed language.
23:27:37 <ddarius> The hard thing is curryN.
23:27:53 <ddarius> The Zip Calculus should be pretty straightforward to encode into something like Agda.
23:28:42 <mm_freak> ddarius: that's what i was thinking:  (n : Nat) -> Zip n
23:42:07 * hackagebot word8 0.0.0 - Word8 library  http://hackage.haskell.org/package/word8-0.0.0 (KazuYamamoto)
23:45:03 <johnw> word8 != ByteString?
23:45:40 <ivanm> yeah, it seems to be treating Word8's as Chars
23:45:49 <ivanm> for use with bytestring presumably
23:45:56 <johnw> and that != ByteString.Char8?
23:46:14 <pharaun> weeee! just found the performance issue in conduit
23:46:16 <Axman6> contains isControl, isSpace, isLower, isUpper wtc
23:46:18 <ivanm> johnw: .Char8 has the conversions to/from Char, which can build up
23:46:25 <ivanm> pharaun: oh?
23:46:25 <johnw> pharaun: cool, what was it?
23:46:25 <pharaun> i'm getting *near* my custom implementation in speed :)
23:46:51 <pharaun> ivanm: not with conduit itself, but a sink that i was using from crypto-conduit was about twice as slow
23:47:04 <pharaun> as me just doing it myself via manual low level file gets
23:47:23 <ivanm> so you're sending a patch upstream I presume?
23:47:31 <Heffalump> ddarius: stuff :-) can't keep up with #haskell any more, it's too crowded
23:47:34 <Nereid> FlexibleContexts is considered safe yes?
23:47:38 <pharaun> johnw: not quite for sure yet but it has something to do with how the sinkHash was doing things, i on a hutch rewrote the sinkHash and it is almost same performance
23:47:51 <pharaun> ivanm: i'm not sure i can generalize this but i can contact the crypto-conduit author and talk about it
23:47:54 <johnw> as the fully-in-memory ByteString solution?
23:48:11 <pharaun> johnw: nah sadly no where close :) but i'm getting ~600MiB/s for this now
23:48:20 <johnw> does conduit allow concurrency if the stream can be segmented into chunks?
23:48:33 <johnw> or, I guess I should call that parallelism
23:48:59 <Axman6> i know the guys at Tsusu wrote some nice things for Iteratee that allowed for concurrent processing of each part of the pipeline
23:49:07 <pharaun> i'm not familiar enough with the guts of conduit yet to say yes/no to that, but right now, from what i understand, probably not, not unless you stream the entire thing into memory then parallel process it
23:49:15 <pharaun> but won't be surprised if there has been work on this
23:49:37 <ddarius> Nereid: In what way would it be "unsafe".
23:49:37 <ddarius> ?
23:49:42 <johnw> it should be smarter enough to pull in N chunks, process them, and then keep pulling in more chunks as capacities become free
23:49:43 <Nereid> no idea
23:49:44 <Nereid> :V
23:49:44 <pharaun> johnw: i do see it has a readSegment where you can give it a offset and a size so...
23:50:08 <johnw> yeah, I'm be surprised if there weren't a "parallel chunk transformer"
23:50:15 <pharaun> johnw: yeah like i said i'm not familiar enough with the guts to give you a definitive answer there, i'm just happy i was able to track down my conduit performance issue :)
23:50:42 <pharaun> going to have to try to see if i can't somehow generalize it in a way that is useful upstream for the crypto-conduit folks
23:52:07 * hackagebot authenticate-oauth 1.4.0.2 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.4.0.2 (HiromiIshii)
23:52:13 <johnw> are you measuring 600 MB/s with a RAM disk?
23:52:46 <pharaun> yeah, its only getting 600MB/s cos i'm not doing any parallelism on the actual hashing part :)
23:53:04 <pharaun> easier to deal with for the time being, and like i said i'm working on the problem one piece at a time
23:53:25 <pharaun> i'll probably eventually attempt to bring back in some form of parallelism
23:54:11 <pharaun> johnw: the md4 hash is only getting ~800ish MB/s so... there's going to be a little bit of overhead from fact that i'm running 2 hashes and rolling and some other management stuff
23:56:38 <johnw> there is a way to make sources and sinks concurrent
23:56:55 <johnw> but I haven't yet found a way to make a converter inherently parallel
23:57:38 <johnw> I guess you need a "chunking" converter, and then another converter that maps over chunks
23:57:50 <johnw> you should then be able to make that converter parallel with parMap
23:58:10 <johnw> (or I guess it would be the hashing sink, in this case)
23:59:09 <johnw> I wish ByteString.Lazy's toChunks function accepted a "block size"
23:59:26 <pharaun> yeah that was a major pain point for me
23:59:40 <shachaf> johnw: The block size is already decided by the time you have a ByteString.Lazy
23:59:55 <johnw> yeah, and there's no way to decide it
